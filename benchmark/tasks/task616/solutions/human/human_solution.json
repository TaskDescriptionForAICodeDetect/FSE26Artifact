[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\n/*Starry Sky Tree*/\n/*Range Add Min(Max) Query*/\n/*区間加算、区間Min,区間Max*/\n\nclass RMAQ{\npublic: \n  \n  //遅延用の型  \n  struct T{\n    bool type; //0 - empty   , 1 - update\n    int value;\n    T():type(0),value(0){}\n    T(bool type,int value):type(type),value(value){}\n  };\n\n  //比較可能な主データ型\n  struct D{\n    int value;\n    D():value(0){} /*適切な値にする!!!!!!*/\n    D(int value):value(value){}\n    bool operator < (D a)const {return value < a.value;} //merge用\n  };\n  \n  int n;\n  vector<D> dat;\n  vector<T> td;\n  D returnD = D(0); // 範囲外の時に返す値。\n  \n  RMAQ(){n=-1;}\n  RMAQ(int n_){\n    n=1;\n    while(n<n_)n*=2;\n    td.resize(2*n-1,T());\n    dat.resize(2*n-1,D());\n  }\n  \n  D merge(D a,D b){return a.value + b.value;}\n  \n  void delay(int k,int len){\n    if(td[k].type==0) return;\n    int v = td[k].value;\n    td[k].type = 0;\n    td[k].value = 0;\n    \n    len /= 2;\n    int l = k*2+1,r = k*2+2;\n    dat[l].value = v * len; td[l].type = 1; td[l].value = v;\n    dat[r].value = v * len; td[r].type = 1; td[r].value = v;\n  }\n\n  D update(int k,int x, int len){\n    dat[k].value = x * len;\n    td[k].type = 1;\n    td[k].value = x;\n    return dat[k];\n  }\n  \n  //[a,b)の値をx加算　add(a,b,x)\n  D query(int a,int b,int x,bool flg=true,int k=0,int l=0,int r=-1){\n    if(r==-1) r=n, assert(a <= n && b <= n);\n    if(r<=a||b<=l) return flg? dat[k]:returnD;\n    if(a<=l&&r<=b) return flg? update(k, x, r - l):dat[k];\n    \n    delay(k, r - l);\n    D vl = query(a,b,x,flg,k*2+1,l,(l+r)/2);\n    D vr = query(a,b,x,flg,k*2+2,(l+r)/2,r);\n    if(flg) dat[k] = merge(vl,vr);\n    return merge(vl,vr);\n  }\n  \n  //[a,b)の合計値を得る　find(a,b);\n  int find(int a,int b){\n    D res = query(a,b,0,false);\n    return res.value;\n  }\n};\n\n\nsigned main(){\n  int n,q;\n  cin>>n>>q;\n  \n  RMAQ rmaq(n);\n  while(q--){\n    int cmd;\n    cin>>cmd;\n    if(cmd == 0){\n      int s,t,x;\n      cin>>s>>t>>x;\n      rmaq.query(s,t+1,x);\n    }\n    if(cmd == 1){\n      int s,t;\n      cin>>s>>t;\n      cout<<rmaq.find(s,t+1)<<endl;\n    }\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing uint = unsigned int;\nusing lint = long long int;\nusing ulint = unsigned long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T, class U> void assign(V<T>& v, int n, const U& a) { v.assign(n, a); }\ntemplate<class T, class... Args> void assign(V<T>& v, int n, const Args&... args) { v.resize(n); for (auto&& e : v) assign(e, args...); }\n\n\ntemplate<class Int> Int rng(Int a, Int b) {\n  static mt19937 mt(chrono::steady_clock().now().time_since_epoch().count());\n  assert(a < b);\n  return uniform_int_distribution<Int>(a, b - 1)(mt);\n}\n\nnamespace PersistentRandomizedBinaryTree {\n  using T = struct { int sum, len; };\n  T op(const T& lhs, const T& rhs) { return {lhs.sum + rhs.sum, lhs.len + rhs.len}; }\n  T op(const T& lhs, const T& mhs, const T& rhs) { return op(op(lhs, mhs), rhs); }\n  constexpr T e = {0, 0};\n\n  using U = int;\n  constexpr U id = 1001;\n  T ap(const U& f, const T& x) { return f != id ? T{f * x.len, x.len} : x; }\n  U cp(const U& g, const U& f) { return g != id ? g : f; }\n\n  struct Node;\n  using Tree = shared_ptr<const Node>;\n  struct Node {\n    int sz = 0;\n    T val = e, acc = e;\n    U laz = id;\n    bool rev = false;\n    Tree cl = nullptr, cr = nullptr;\n    Node() {} // nil\n    Node(const T& val); // leaf\n    Node(const T& val, const T& acc, const U& laz, bool rev, Tree cl, Tree cr) :\n      sz(cl->sz + 1 + cr->sz), val(val), acc(acc), laz(laz), rev(rev), cl(cl), cr(cr) {}\n    Node(Tree t, Tree cl, Tree cr) :\n      sz(cl->sz + 1 + cr->sz), val(t->val), acc(op(cl->acc, t->val, cr->acc)), laz(t->laz), rev(t->rev), cl(cl), cr(cr) {}\n  };\n  Tree nil = make_shared<Node>();\n  Node::Node(const T& val) : sz(1), val(val), acc(val), cl(nil), cr(nil) {}\n\n  Tree act(Tree t, const U& f) {\n    if (t == nil) return t;\n    return make_shared<Node>(ap(f, t->val), ap(f, t->acc), cp(f, t->laz), t->rev, t->cl, t->cr);\n  }\n  Tree reverse(Tree t) {\n    if (t == nil) return t;\n    return make_shared<Node>(t->val, t->acc, t->laz, !t->rev, t->cr, t->cl);\n  }\n  Tree push(Tree t) {\n    if (t->laz == id and !t->rev) return t;\n    Tree cl = t->laz != id ? act(t->cl, t->laz) : t->cl;\n    Tree cr = t->laz != id ? act(t->cr, t->laz) : t->cr;\n    if (t->rev) {\n      cl = reverse(cl);\n      cr = reverse(cr);\n    }\n    return make_shared<Node>(t->val, t->acc, id, false, cl, cr);\n  }\n\n  template<class Itr> Tree build(Itr first, Itr last) {\n    int n = distance(first, last);\n    if (n == 0) return nil;\n    Itr middle = next(first, n / 2);\n    Tree cl = build(first, middle);\n    Tree cr = build(next(middle), last);\n    return make_shared<Node>(*middle, op(cl->acc, *middle, cr->acc), id, false, cl, cr);\n  }\n  template<class Itr> Itr dump(Tree t, Itr res) {\n    if (t == nil) return res;\n    push(t);\n    res = dump(t->cl, res);\n    *res++ = t->val;\n    res = dump(t->cr, res);\n    return res;\n  }\n  Tree rebuild(Tree t) {\n    V<T> v(t->sz);\n    dump(t, begin(v));\n    return build(begin(v), end(v));\n  }\n\n  Tree merge(Tree tl, Tree tr) {\n    if (tr == nil) return tl;\n    if (tl == nil) return tr;\n    if (rng(0, tl->sz + tr->sz) < tl->sz) {\n      tl = push(tl);\n      return make_shared<Node>(tl, tl->cl, merge(tl->cr, tr));\n    } else {\n      tr = push(tr);\n      return make_shared<Node>(tr, merge(tl, tr->cl), tr->cr);\n    }\n  }\n  Tree merge(Tree tl, Tree tm, Tree tr) {\n    return merge(merge(tl, tm), tr);\n  }\n  pair<Tree, Tree> split(Tree t, int i) {\n    if (t == nil) return {nil, nil};\n    t = push(t);\n    if (i <= t->cl->sz) {\n      Tree tl, cl;\n      tie(tl, cl) = split(t->cl, i);\n      return {tl, make_shared<Node>(t, cl, t->cr)};\n    } else {\n      Tree cr, tr;\n      tie(cr, tr) = split(t->cr, i - t->cl->sz - 1);\n      return {make_shared<Node>(t, t->cl, cr), tr};\n    }\n  }\n  tuple<Tree, Tree, Tree> split(Tree t, int l, int r) {\n    Tree tl, tm, tr;\n    tie(tl, tr) = split(t, r);\n    tie(tl, tm) = split(tl, l);\n    return make_tuple(tl, tm, tr);\n  }\n\n  Tree insert(Tree t, int i, const T& val) {\n    Tree tl, tr;\n    tie(tl, tr) = split(t, i);\n    return merge(tl, make_shared<Node>(val), tr);\n  }\n  Tree erase(Tree t, int i) {\n    Tree tl, tm, tr;\n    tie(tl, tm, tr) = split(t, i, i + 1);\n    return merge(tl, tr);\n  }\n\n  T get_val(Tree t, int i) {\n    if (t == nil) return e;\n    if (i == t->cl->sz) return t->val;\n    t = push(t);\n    if (i < t->cl->sz) return get_val(t->cl, i);\n    else return get_val(t->cr, i - t->cl->sz - 1);\n  }\n  Tree set_val(Tree t, int i, const T& val) {\n    if (t == nil) return t;\n    t = push(t);\n    if (i == t->cl->sz) return make_shared<Node>(val, op(t->cl->acc, val, t->cr->acc), t->laz, t->rev, t->cl, t->cr);\n    if (i < t->cl->sz) {\n      Tree cl = set_val(t->cl, i, val);\n      return make_shared<Node>(t, cl, t->cr);\n    } else {\n      Tree cr = set_val(t->cr, i - t->cl->sz - 1, val);\n      return make_shared<Node>(t, t->cl, cr);\n    }\n  }\n\n  T acc(Tree t, int l, int r) {\n    if (t == nil or l <= 0 and t->sz <= r) return t->acc;\n    t = push(t);\n    T resl = l < t->cl->sz ? acc(t->cl, l, r) : e;\n    T resr = t->cl->sz + 1 < r ? acc(t->cr, l - t->cl->sz - 1, r - t->cl->sz - 1) : e;\n    T resm = l <= t->cl->sz and t->cl->sz < r ? t->val : e;\n    return op(resl, resm, resr);\n  }\n  Tree act(Tree t, int l, int r, const U& f) {\n    if (t == nil or l <= 0 and t->sz <= r) return act(t, f);\n    t = push(t);\n    Tree cl = l < t->cl->sz ? act(t->cl, l, r, f) : t->cl;\n    Tree cr = t->cl->sz + 1 < r ? act(t->cr, l - t->cl->sz - 1, r - t->cl->sz - 1, f) : t->cr;\n    T val = l <= t->cl->sz and t->cl->sz < r ? ap(f, t->val) : t->val;\n    T acc = op(cl->acc, val, cr->acc);\n    return make_shared<Node>(val, acc, t->laz, t->rev, cl, cr);\n  }\n  Tree reverse(Tree t, int l, int r) {\n    Tree tl, tm, tr;\n    tie(tl, tm, tr) = split(t, l, r);\n    tm = reverse(tm);\n    return merge(tl, tm, tr);\n  }\n}\n\nusing namespace PersistentRandomizedBinaryTree;\n\nint main() {\n  cin.tie(nullptr); ios_base::sync_with_stdio(false);\n  int n, q; cin >> n >> q;\n  V<T> a(n, {0, 1});\n  Tree t = build(begin(a), end(a));\n  while (q--) {\n    int type; cin >> type;\n    if (type == 0) {\n      int l, r, x; cin >> l >> r >> x, ++r;\n      t = act(t, l, r, x);\n    } else {\n      int l, r; cin >> l >> r, ++r;\n      cout << acc(t, l, r).sum << '\\n';\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<iomanip>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n#include <stdio.h>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <map>\n#include <list>\n#include <string>\n#include <numeric>\n#include <utility>\n#include <cfloat>\n#include <set>\n \nusing namespace std;\n \nint sqrtN = 512;\nstruct SqrtDecomposition{\n    int N, K;\n    vector <long long> data;\n    vector <long long> bucketUpdatedLazy;\n    vector <long long> bucketSum;\n    vector <bool> needUpdate;\n    SqrtDecomposition(int n){\n        N = n;\n        K = (N + sqrtN - 1) / sqrtN;\n        data.assign(N + sqrtN, 0);\n        bucketUpdatedLazy.assign(K, 0);\n        needUpdate.assign(K, false);\n        bucketSum.assign(K, 0);\n    }\n \n    void propagateLazy(int k){\n        if(!needUpdate[k]){\n            return;\n        }\n        for(int i = 0; i < sqrtN; i++){\n            data[k * sqrtN + i] = bucketUpdatedLazy[k];\n        }\n        bucketSum[k] = bucketUpdatedLazy[k] * sqrtN;\n        needUpdate[k] = false;\n    }\n\n\n    long long get(int x){\n        propagateLazy(x / sqrtN);\n        return data[x];\n    }\n\n    long long getSum(int x, int y){\n        propagateLazy(x / sqrtN);\n        propagateLazy((y - 1) / sqrtN);\n        long long ans = 0;\n        if(y - x < sqrtN){\n            for(int i = x; i < y; i++){\n                ans += data[i];\n            }\n            return ans;\n        }\n        for(int i = x / sqrtN + 1; i < y / sqrtN; i++){\n            ans += bucketSum[i];\n        }                  \n\n        for(int i = x; i < (x / sqrtN + 1) * sqrtN; i++){\n            ans += data[i];\n        }\n        for(int i = y / sqrtN * sqrtN; i < y; i++){\n            ans += data[i];\n        }\n        return ans;\n    }\n \n    void update(int x, int y, long long a){\n        if(y - x < sqrtN){\n            propagateLazy(x / sqrtN);\n            propagateLazy((y - 1) / sqrtN);\n            for(int i = x; i < y; i++){\n                bucketSum[i/sqrtN] += (a - data[i]);\n                data[i] = a;\n            }\n            return;\n        }\n        for(int i = x / sqrtN + 1; i < y / sqrtN; i++){\n            bucketUpdatedLazy[i] = a;\n            needUpdate[i] = true;\n            bucketSum[i] = a * sqrtN;\n        }\n\n        propagateLazy(x / sqrtN);\n        for(int i = x; i < (x / sqrtN + 1) * sqrtN; i++){\n            bucketSum[i/sqrtN] += (a - data[i]);\n            data[i] = a;\n        }\n        propagateLazy((y - 1)/ sqrtN);\n        for(int i = y / sqrtN * sqrtN; i < y; i++){\n            bucketSum[i/sqrtN] += (a - data[i]);\n            data[i] = a;\n        }\n    }\n     \n};\n\n \nint main(){\n    int n;\n    int q;\n    cin >> n >> q;\n    SqrtDecomposition sq(n);\n    for(int i = 0; i < q; i++){\n        int com;\n        int s;\n        int t;\n        int x;\n        cin >> com;\n        if(com == 0){\n            cin >> s >> t >> x;\n            sq.update(s, t + 1, x);\n        } else {\n            cin >> s >> t;\n            cout << sq.getSum(s, t + 1) << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vl = vector<ll>;\ntemplate<class T> using vc = vector<T>;\ntemplate<class T> using vvc = vector<vector<T>>;\n\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define repr(i, n) for (ll i = (n)-1; i >= 0; i--)\n#define repe(i, l, r) for (ll i = (l); i < (r); i++)\n#define reper(i, l, r) for (ll i = (r)-1; i >= (l); i--)\n#define repa(i,n) for (auto& i: n)\n\ntemplate<class T> inline bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nvoid init() {cin.tie(0);ios::sync_with_stdio(false);cout << fixed << setprecision(15);}\n\n#ifdef DEBUG\ntemplate <class T, class N> void verr(const T& a, const N& n) { rep(i, n) cerr << a[i] << \" \"; cerr << \"\\n\" << flush; }\nll dbgt = 1; void err() { cerr << \"passed \" << dbgt++ << \"\\n\" << flush; }\ntemplate<class H, class... T> void err(H&& h,T&&... t){ cerr<< h << (sizeof...(t)?\" \":\"\\n\") << flush; if(sizeof...(t)>0) err(forward<T>(t)...); }\n#endif\n\nconst ll INF = 4e18;\nconst ld EPS = 1e-11;\nconst ld PI = acos(-1.0L);\nconst ll MOD = 1e9 + 7;\n// const ll MOD = 998244353;\n//--------------------------------------------------------------------------------//\ntemplate <class T, class U = T>\nstruct LazySegTree {\n    int n, height;\n    // 値配列, 値の単位元\n    vector<T> data;\n    T dataId;\n    // 遅延配列, 遅延値の単位元\n    vector<U> lazy;\n    U lazyId;\n\n    function<T(T, T)> fOperate;\n    function<T(T, U)> fAct;\n    function<U(U, U)> fMerge;\n\n    LazySegTree(\n        int _n, T _did = INF, U _lid = INF,\n        function<T(T, T)> _op = [](T t1, T t2) { return min(t1, t2); },\n        function<T(T, U)> _ac = [](T t1, U u1) { return u1; },\n        function<U(U, U)> _me = [](U u1, U a) { return a; }\n    )\n        : dataId(_did), lazyId(_lid), fOperate(_op), fAct(_ac), fMerge(_me) {\n        n = 1, height = 0;\n        while (n < _n) n *= 2, height++;\n        data = vector<T>(2 * n, dataId);\n        lazy = vector<U>(2 * n, lazyId);\n    }\n\n    inline T act(int k){\n        return lazy[k] == lazyId ? data[k] : fAct(data[k], lazy[k]);\n    }\n\n    inline void propagate(int k){\n        if (lazy[k] == lazyId) return;\n        lazy[2 * k + 0] = fMerge(lazy[2 * k + 0], lazy[k]);\n        lazy[2 * k + 1] = fMerge(lazy[2 * k + 1], lazy[k]);\n        data[k] = act(k), lazy[k] = lazyId;\n    }\n\n\n    // [a, b)を更新\n    inline void update(int a, int b, U x) {\n        a += n, b += n - 1;\n        for (int i = height; i > 0; i--) propagate(a >> i), propagate(b >> i);\n        for (int l = a, r = b + 1; l < r; l /= 2, r /= 2) {\n            if (l & 1) lazy[l] = fMerge(lazy[l], x), l++;\n            if (r & 1) r--, lazy[r] = fMerge(lazy[r], x);\n        }\n        for (int l = a / 2, r = b / 2; l > 0; l /= 2, r /= 2) {\n            data[l] = fOperate(act(2 * l + 0), act(2 * l + 1));\n            data[r] = fOperate(act(2 * r + 0), act(2 * r + 1));\n        }\n    }\n\n    // [l, r)の区間クエリ\n    inline T query(int a, int b){\n        a += n, b += n - 1;\n        for (int i = height; i > 0; i--) propagate(a >> i), propagate(b >> i);\n        T Lret = dataId, Rret = dataId;\n        for (int l = a, r = b + 1; l < r; l /= 2, r /= 2){\n            if (l & 1) Lret = fOperate(Lret, act(l++));\n            if (r & 1) Rret = fOperate(act(--r), Rret);\n        }\n        return fOperate(Lret, Rret);\n    }\n\n    inline void build(vector<T> vec){\n        for (int i = 0; i < vec.size(); i++) data[i + n] = vec[i];\n        for (int i = n - 1; i > 0; i--) data[i] = fOperate(data[2 * i + 0], data[2 * i + 1]);\n    }\n\n    // 添字でアクセス\n    inline T& operator[](int i) {\n        return data[i + n];\n    }\n};\n// LazySegTree<T, U = T> seg(N, dataId, lazyId, fOp, fMe, fAc)\n// 要素数, 要素単位元, 遅延値単位元, 要素ｘ要素, 要素ｘ作用素, 作用素ｘ作用素\n// デフォルト引数　dataId = INF, lazyId = INF, fOp : min, fAct : update, fMerge : update\n\nusing P = pair<ll, ll>;\nint main() {\n    init();\n    ll N, Q;\n    cin >> N >> Q;\n    auto op = [](P a, P b) { return P(a.first + b.first, a.second + b.second); };\n    auto act = [](P a, ll b) { return P(a.second * b, a.second); };\n    auto mer = [](ll a, ll b) { return b; };\n    LazySegTree<P, ll> seg(N, P(0, 1), INF, op, act, mer);\n    seg.build(vc<P>(N, P(0, 1)));\n\n    ll ans = 0;\n    rep(_, Q){\n        ll q, a, b;\n        cin >> q >> a >> b;\n        if(q==0){\n            ll x;\n            cin >> x;\n            seg.update(a, b + 1, x);\n        }else{\n            cout << seg.query(a, b + 1).first << '\\n';\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass segment_tree{\n    vector<int64_t> val;\n    vector<pair<int64_t, int64_t>> op;\n    vector<pair<size_t, size_t>> range;\n\n    pair<int64_t, int64_t> ident = {1, 0};\n    size_t N, depth;\n\n    inline void merge(size_t target, int64_t alpha, int64_t beta){\n        op[target] = {op[target].first * alpha, op[target].second * alpha + beta};\n    }\n    inline void propagate(size_t target){\n        // min, max -> width = 1\n        if(op[target] == ident) return;\n        val[target] = op[target].first * val[target] + op[target].second * (range[target].second - range[target].first);\n        if(target  < N){\n            merge(2*target, op[target].first, op[target].second);\n            merge(2*target+1, op[target].first, op[target].second);\n        }\n        op[target] = {1, 0};\n    }\n    \n    inline void eval(int n){\n        stack<size_t> stk;\n        for(;n>0;n>>=1) stk.push(n);\n        while(!stk.empty()){\n            propagate(stk.top());\n            stk.pop();\n        }\n    }\n    inline void get_target(vector<size_t> &target, size_t left, size_t right, stack<size_t> *refresh=nullptr){\n        queue<size_t> partial;\n        \n        if(left <= 0 && right >= N) target.push_back(1);\n        else partial.push(1);\n\n        while(!partial.empty()){\n            size_t i = partial.front();\n            if(refresh != nullptr) refresh->push(i);\n            partial.pop();\n\n            propagate(i);\n\n            if(left <= range[i].first){\n                if(right < range[i*2].second) partial.push(i*2);\n                else{\n                    target.push_back(i*2);\n                    if(range[i*2+1].first < right) partial.push(i*2+1);\n                }\n            }else{\n                if(left < range[i*2].second){\n                    partial.push(i*2);\n                    if(range[i*2+1].second <= right) target.push_back(i*2+1);\n                    else if(range[i*2].second < right) partial.push(i*2+1); \n                }else{\n                    if(left <= range[i*2+1].first && range[i*2+1].second <= right) target.push_back(i*2+1);\n                    else partial.push(i*2+1);\n                }\n            }\n        }\n    }\npublic:\n    segment_tree(size_t n){\n        for(depth=0;(1ULL<<depth)<n;depth++);\n        N = 1ULL<<depth;\n        val.reserve(1ULL<<(++depth));\n        op.reserve(1ULL<<depth);\n        range.reserve(1ULL<<depth);\n        for(size_t i=2*N-1;i>0;i--){\n            op[i] = ident;\n            if(i>=N) range[i] = {i-N, i-N+1};\n            else range[i] = {range[2*i].first, range[2*i+1].second};\n        }\n    }\n    int64_t operator[](size_t i){\n        eval(N+i);\n        return val[N+i];\n    }\n    void operate(int64_t alpha, int64_t beta, size_t left, size_t right){\n        if(right <= left) return;\n\n        vector<size_t> target;\n        stack<size_t> refresh;\n        get_target(target, left, right, &refresh);\n        for(auto i : target){\n            merge(i, alpha, beta);\n            propagate(i);\n        }\n        while(!refresh.empty()){\n            size_t i = refresh.top();\n            refresh.pop();\n            //min, max -> change\n            propagate(i*2);\n            propagate(i*2+1);\n            val[i] = val[i*2] + val[i*2+1];\n        }\n    }\n    int64_t get_sum(size_t left, size_t right){\n        if(right <= left) return 0;\n        \n        vector<size_t> target;\n        get_target(target, left, right);\n        int64_t ret = 0;\n        for(auto i : target){\n            ret += op[i].first * val[i] + op[i].second * (range[i].second - range[i].first);\n        }\n        return ret;\n    }\n    void update(int64_t val, size_t pos){\n        operate(0, val, pos, pos+1);\n    }\n    void update(int64_t val, size_t left, size_t right){\n        operate(0, val, left, right);\n    }\n    void add(int64_t val, size_t pos){\n        operate(1, val, pos, pos+1);\n    }\n    void add(int64_t val, size_t left, size_t right){\n        operate(1, val, left, right);\n    }\n\n    void dump(){\n        for(int i=1;i<2*N;i++){\n            eval(i);\n            cerr << val[i] << \" \";\n        }\n        cerr << endl;\n    }\n};\n\nint main(){\n    int n, q;\n    cin >> n >> q;\n    segment_tree st(n);\n\n    for(int i=0;i<q;i++){\n        int com;\n        cin >> com;\n        if(com == 0){\n            int s, t, x;\n            cin >> s >> t >> x;\n            st.update(x, s, t+1);\n        }else{\n            int s, t;\n            cin >> s >> t;\n            cout << st.get_sum(s, t+1) << endl;\n        }\n        //st.dump();\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<set>\n#include<queue>\n#include<cstdlib>\n#include<algorithm>\n\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define ls(x) (x << 1)\n#define rs(x) (x<<1|1)\n#define SZ(x) (int)(x).size()\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\ntypedef pair<LL, LL> pll;\ntypedef pair<bool, int> pbi;\n\nconst double eps = 1e-10;\nconst double PI = acos(-1.0);\n//const double PI = 3.14159265358979323846264338327950288419716939937510\nint dcmp(const double &x) { if (fabs(x) < eps) return 0; return x < 0 ? -1 : 1; }\nconst int MOD = 1e9 + 7;\nconst int INF = 2147483647;\nconst double INF_d = 1e64;\n\ntemplate<class T>\nT qmod(T a, T b){ T ret = 1; while (b){ if (b & 1) ret *= a; b >>= 1; a *= a; } return ret; }\ntemplate<class T>\nT gcd(T a, T b){ return !b ? a : gcd(b, a % b); }\ntemplate<class T>\nT ex_gcd(T a, T b, T &x, T &y){\n    if (!b){ x = 1, y = 0; return a; }\n    T t, ret;\n    ret = ex_gcd(b, a % b, x, y);\n    t = x, x = y, y = t - a / b * y;\n    return ret;\n}\ntemplate<class T>\nT inv(T t, T p){ return t == 1 ? 1 : (p - p / t) * inv(p % t, p) % p; }\n\n// head\n\nconst int N = 2e5 + 7;\nstruct node{\n    int l, r, tag;\n    LL val;\n};\n\nint n, m, op, x, y, w;\nnode T[N << 2];\n\nvoid build(int rt, int l, int r){\n    T[rt].l = l, T[rt].r = r, T[rt].val = 0, T[rt].tag = 1234;\n    if (l == r) return;\n    int mid = (l + r) >> 1;\n    build(ls(rt), l, mid);\n    build(rs(rt), mid + 1, r);\n}\n\nvoid push_down(int rt){\n    if (T[rt].tag != 1234){\n        T[ls(rt)].tag = T[rt].tag, T[rs(rt)].tag = T[rt].tag;\n        T[ls(rt)].val = (LL)T[rt].tag * (T[ls(rt)].r - T[ls(rt)].l + 1);\n        T[rs(rt)].val = (LL)T[rt].tag * (T[rs(rt)].r - T[rs(rt)].l + 1);\n        T[rt].tag = 1234;\n    }\n}\n\nvoid push_up(int rt){\n    T[rt].val = T[ls(rt)].val + T[rs(rt)].val;\n}\n\nvoid update(int rt, int l, int r, int val){\n    if (l > T[rt].r || r < T[rt].l) return;\n    if (l <= T[rt].l && T[rt].r <= r){\n        T[rt].val = (LL)val * (T[rt].r - T[rt].l + 1);\n        T[rt].tag = val; return;\n    }\n    push_down(rt);\n    int mid = (T[rt].l + T[rt].r) >> 1;\n    if (l <= mid) update(ls(rt), l, r, val);\n    if (r > mid) update(rs(rt), l, r, val);\n    push_up(rt);\n}\n\nLL query(int rt, int l, int r){\n    if (l > T[rt].r || T[rt].l > r) return 0;\n    if (l <= T[rt].l && T[rt].r <= r) return T[rt].val;\n    push_down(rt);\n    LL ret = 0;\n    int mid = (T[rt].l + T[rt].r) >> 1;\n    if (l <= mid) ret += query(ls(rt), l, r);\n    if (r > mid) ret += query(rs(rt), l, r);\n    return ret;\n}\n\nint main(){\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n    scanf(\"%d%d\", &n, &m);\n    build(1, 1, n);\n    for (int i = 0; i < m; i++){\n        scanf(\"%d\", &op);\n        if (!op){\n            scanf(\"%d%d%d\", &x, &y, &w); x++, y++;\n            update(1, x, y, w);\n        }\n        else{\n            scanf(\"%d%d\", &x, &y); x++, y++;\n            printf(\"%lld\\n\", query(1, x, y));\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <cassert>\n#include <stdexcept>\n#include <utility>\n\ntemplate <class ValueMonoid, class OperatorMonoid, class Modifier,\n\ttemplate <class> class Container>\nclass lazy_segment_tree {\npublic:\n\tusing value_structure = ValueMonoid;\n\tusing value_type = typename value_structure::value_type;\n\tusing const_reference = const value_type &;\n\tusing operator_structure = OperatorMonoid;\n\tusing operator_type = typename operator_structure::value_type;\n\tusing modifier_type = Modifier;\n\tusing container_type = Container<::std::pair<value_type, operator_type>>;\n\tusing size_type = typename container_type::size_type;\n\nprivate:\n\tsize_type size_, height;\n\tcontainer_type c;\n\tstatic size_type getheight(const size_type size) noexcept {\n\t\tsize_type ret = 0;\n\t\twhile (static_cast<size_type>(1) << ret < size)\n\t\t\t++ret;\n\t\treturn ret;\n\t}\n\tstatic value_type reflect(typename container_type::const_reference element) {\n\t\treturn modifier_type::operation(element.first, element.second);\n\t}\n\tvoid recalc(const size_type index) {\n\t\tc[index].first = value_structure::operation(reflect(c[index << 1]),\n\t\t\treflect(c[index << 1 | 1]));\n\t}\n\tstatic void assign(operator_type &element, const operator_type &data) {\n\t\telement = operator_structure::operation(element, data);\n\t}\n\tvoid push(const size_type index) {\n\t\tassign(c[index << 1].second, c[index].second);\n\t\tassign(c[index << 1 | 1].second, c[index].second);\n\t\tc[index].second = operator_structure::identity();\n\t}\n\tvoid propagate(const size_type index) {\n\t\tfor (size_type i = height; i; --i)\n\t\t\tpush(index >> i);\n\t}\n\tvoid thrust(const size_type index) {\n\t\tc[index].first = reflect(c[index]);\n\t\tpush(index);\n\t}\n\tvoid evaluate(const size_type index) {\n\t\tfor (size_type i = height; i; --i)\n\t\t\tthrust(index >> i);\n\t}\n\tvoid build(size_type index) {\n\t\twhile (index >>= 1)\n\t\t\trecalc(index);\n\t}\n\tsize_type base_size() const { return static_cast<size_type>(1) << height; }\n\npublic:\n\tlazy_segment_tree() : size_(0), height(0), c() {}\n\texplicit lazy_segment_tree(const size_type size)\n\t\t: size_(size), height(getheight(size_)),\n\t\tc(static_cast<size_type>(1) << (height + 1),\n\t\t{ value_structure::identity(), operator_structure::identity() }) {}\n\n\tbool empty() const { return !size_; }\n\tsize_type size() const { return size_; }\n\n\tconst_reference operator[](size_type index) {\n\t\tassert(index < size());\n\t\tindex += base_size();\n\t\tevaluate(index);\n\t\tc[index].first = reflect(c[index]);\n\t\tc[index].second = operator_structure::identity();\n\t\treturn c[index].first;\n\t}\n\tconst_reference at(size_type index) {\n\t\tif (index < size()) {\n\t\t\tthrow ::std::out_of_range(\"index out of range\");\n\t\t}\n\t\telse {\n\t\t\tindex += base_size();\n\t\t\tevaluate(index);\n\t\t\tc[index].first = reflect(c[index]);\n\t\t\tc[index].second = operator_structure::identity();\n\t\t\treturn c[index].first;\n\t\t}\n\t}\n\tvalue_type fold(size_type first, size_type last) {\n\t\tassert(first <= last);\n\t\tassert(first <= size());\n\t\tassert(last <= size());\n\t\tfirst += base_size();\n\t\tlast += base_size();\n\t\tevaluate(first);\n\t\tevaluate(last - 1);\n\t\tvalue_type retL = value_structure::identity(),\n\t\t\tretR = value_structure::identity();\n\t\tfor (; first < last; first >>= 1, last >>= 1) {\n\t\t\tif (first & 1)\n\t\t\t\tretL = value_structure::operation(retL, reflect(c[first++]));\n\t\t\tif (last & 1)\n\t\t\t\tretR = value_structure::operation(reflect(c[last - 1]), retR);\n\t\t}\n\t\treturn value_structure::operation(retL, retR);\n\t}\n\ttemplate <class F> size_type search(const F &f) {\n\t\tif (f(value_structure::identity()))\n\t\t\treturn static_cast<size_type>(0);\n\t\tif (!f(reflect(c[1])))\n\t\t\treturn size() + 1;\n\t\tvalue_type acc = value_structure::identity();\n\t\tsize_type i = 1;\n\t\twhile (i < base_size()) {\n\t\t\tthrust(i);\n\t\t\tif (!f(value_structure::operation(acc, reflect(c[i <<= 1]))))\n\t\t\t\tacc = value_structure::operation(acc, reflect(c[i++]));\n\t\t}\n\t\treturn i - base_size() + 1;\n\t}\n\n\tvoid update(const size_type index, const value_type &data) {\n\t\tassert(index < size());\n\t\tindex += base_size();\n\t\tpropagate(index);\n\t\tc[index].first = data;\n\t\tc[index].second = operator_structure::identity();\n\t\tbuild(index);\n\t}\n\tvoid update(size_type first, size_type last, const operator_type &data) {\n\t\tassert(first <= last);\n\t\tassert(first <= size());\n\t\tassert(last <= size());\n\t\tfirst += base_size();\n\t\tlast += base_size();\n\t\tpropagate(first);\n\t\tpropagate(last - 1);\n\t\tfor (size_type left = first, right = last; left < right;\n\t\t\tleft >>= 1, right >>= 1) {\n\t\t\tif (left & 1)\n\t\t\t\tassign(c[left++].second, data);\n\t\t\tif (right & 1)\n\t\t\t\tassign(c[right - 1].second, data);\n\t\t}\n\t\tbuild(first);\n\t\tbuild(last - 1);\n\t}\n};\n\n#include <cstddef>\n#include <utility>\ntemplate <class T, class Size = ::std::size_t> class sum_monoid {\npublic:\n\tusing size_type = Size;\n\tusing value_type = ::std::pair<T, size_type>;\n\tstatic T get(const value_type &x) { return x.first; }\n\tstatic value_type operation(const value_type &x, const value_type &y) {\n\t\treturn value_type(x.first + y.first, x.second + y.second);\n\t}\n\tstatic value_type identity() { return value_type(T(0), size_type(0)); }\n\tstatic value_type reverse(const value_type &x) { return x; }\n};\n\n#include <type_traits>\n#include <utility>\ntemplate <class T> class optional {\npublic:\n\tusing value_type = T;\n\nprivate:\n\ttypename ::std::aligned_storage<sizeof(value_type), alignof(value_type)>::type\n\t\tstorage;\n\tbool hasv;\n\tvalue_type *data() {\n\t\treturn static_cast<value_type *>(static_cast<void *>(&storage));\n\t}\n\tconst value_type *data() const {\n\t\treturn static_cast<const value_type *>(static_cast<const void *>(&storage));\n\t}\n\npublic:\n\toptional() : hasv(0) {}\n\ttemplate <class... Args> explicit optional(Args &&... args) : hasv(1) {\n\t\t::new (data()) value_type(::std::forward<Args>(args)...);\n\t}\n\tvoid reset() {\n\t\thasv = 0;\n\t\tdata()->~value_type();\n\t}\n\tvalue_type &operator*() & { return *data(); }\n\tconst value_type &operator*() const & { return *data(); }\n\tvalue_type &&operator*() && { return *data(); }\n\tconst value_type &&operator*() const && { return *data(); }\n\tvalue_type *operator->() { return data(); }\n\tconst value_type *operator->() const { return data(); }\n\texplicit operator bool() const { return hasv; }\n\tbool has_value() const { return hasv; }\n\tvalue_type &value() & { return *data(); }\n\tconst value_type &value() const & { return *data(); }\n\tvalue_type &&value() && { return *data(); }\n\tconst value_type &&value() const && { return *data(); }\n\ttemplate <class U> value_type value_or(U &&v) const & {\n\t\treturn has_value() ? value() : static_cast<T>(::std::forward<U>(v));\n\t}\n\ttemplate <class U> value_type value_or(U &&v) && {\n\t\treturn has_value() ? value() : static_cast<T>(::std::forward<U>(v));\n\t}\n};\ntemplate <class T> class assign_monoid {\npublic:\n\tusing value_type = optional<T>;\n\tstatic value_type operation(const value_type &x, const value_type &y) {\n\t\treturn y ? y : x;\n\t}\n\tstatic value_type identity() { return value_type(); }\n};\n\n#include <utility>\ntemplate <class T, class S> class sum_assignment {\npublic:\n\tstatic ::std::pair<T, S> operation(const ::std::pair<T, S> &x, const optional<T> &y) {\n\t\treturn y ? ::std::pair<T, S>(y.value() * x.second, x.second) : x;\n\t}\n};\n\n\n#include <cstdio>\n#include <vector>\n\ntemplate<class T> using vec_alias = ::std::vector<T>;\n\nint main() {\n\tusing uint = unsigned int;\n\tusing sum = sum_monoid<int>;\n\n\tuint n, q;\n\tscanf(\"%u%u\", &n, &q);\n\n\tlazy_segment_tree<\n\t\tsum,\n\t\tassign_monoid<int>,\n\t\tsum_assignment<int,sum::size_type>,\n\t\tvec_alias> seg(n);\n\tfor (int i = 0;i < n;++i)\n\t\tseg.update(i, { 0,1 });\n\n\tuint c, s, t;\n\tint x;\n\twhile (q--) {\n\t\tscanf(\"%u%u%u\", &c, &s, &t);\n\n\t\tif (c) {\n\t\t\tprintf(\"%d\\n\", seg.fold(s, t + 1).first);\n\t\t}\n\t\telse {\n\t\t\tscanf(\"%d\", &x);\n\t\t\tseg.update(s, t + 1, optional<int>(x));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Template Headers {{{\nusing pii = pair<int, int>; using vpii = vector<pii>;\nusing vi = vector<int>; using vvi = vector<vi>;\nusing ll = long long; using vll = vector<long long>;\ntemplate <class T> using min_queue = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T> istream &operator>>(istream &, vector<T> &);\ntemplate <class T> ostream &operator<<(ostream &, const vector<T> &);\ntemplate <class T, class U> istream &operator>>(istream &, pair<T, U> &);\ntemplate <class T, class U> ostream &operator<<(ostream &, const pair<T, U> &);\ntemplate <class T> struct Inf { static constexpr T inf() { return std::numeric_limits<T>::has_infinity() ? std::numeric_limits<T>::infinty() : std::numeric_limits<T>::max(); } };\ntemplate <> struct Inf<int> { static constexpr int inf() { return 0x3f3f3f3f; } };\ntemplate <> struct Inf<long long> { static constexpr long long inf() { return 0x3f3f3f3f3f3f3f3fLL; } };\nconstexpr int INF = Inf<int>::inf(); constexpr ll BINF = Inf<ll>::inf();\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n// }}}\n\n// Lazy Segment Tree {{{\ntemplate <class T, class LazyOp>\nclass LazySegmentTree {\nprivate:\n\tLazyOp op;\n\tint n, h;\n\tstd::vector<T> tree, lazy;\n\tstd::vector<bool> tag;\n\n\tvoid calc(int p, int len) {\n\t\ttree[p] = op(tree[p << 1], tree[p << 1 | 1]);\n\t\tif (tag[p]) op.upd(tree[p], lazy[p], len);\n\t}\n\n\tvoid apply(int p, const T &val, int len) {\n\t\top.upd(tree[p], val, len);\n\t\tif (p < n) op.upd(lazy[p], val), tag[p] = true;\n\t}\n\n\tvoid build(int p) {\n\t\tint len = 2;\n\t\tfor (p += n; p >>= 1; len <<= 1) calc(p, len);\n\t}\n\n\tvoid push(int p) {\n\t\tint s = h, len = 1 << (h - 1);\n\t\tfor (p += n; s > 0; s--, len >>= 1) {\n\t\t\tint i = p >> s;\n\t\t\tif (tag[i]) {\n\t\t\t\tapply(i << 1, lazy[i], len);\n\t\t\t\tapply(i << 1 | 1, lazy[i], len);\n\t\t\t\tlazy[i] = op.udef(), tag[i] = false;\n\t\t\t}\n\t\t}\n\t}\n\npublic:\n\tLazySegmentTree(const std::vector<T> &init) : n(init.size()), h(0), tree(n), lazy(n + n, op.udef()), tag(n + n) {\n\t\tfor (const T &x : init) tree.push_back(x);\n\t\twhile ((1 << h) <= n) h++;\n\t\tfor (int i=n-1;i>0;i--) tree[i] = op(tree[i << 1], tree[i << 1 | 1]);\n\t}\n\n\tvoid modify(int l, int r, const T &val) {\n\t\tpush(l); push(r);\n\t\tint l0 = l, r0 = r, len = 1;\n\t\tfor (l += n, r += n + 1; l < r; l >>= 1, r >>= 1, len <<= 1) {\n\t\t\tif (l & 1) apply(l++, val, len);\n\t\t\tif (r & 1) apply(--r, val, len);\n\t\t}\n\t\tbuild(l0); build(r0);\n\t}\n\n\tT query(int l, int r) {\n\t\tpush(l); push(r);\n\t\tT res = op.def();\n\t\tfor (l += n, r += n + 1; l < r; l >>= 1, r >>= 1) {\n\t\t\tif (l & 1) res = op(res, tree[l++]);\n\t\t\tif (r & 1) res = op(tree[--r], res);\n\t\t}\n\t\treturn res;\n\t}\n\n};\n// }}}\n\n// Segment Tree Operators {{{\ntemplate <class T> struct SegOpTemp {\n\tconstexpr virtual T operator()(const T &lhs, const T &rhs) = 0; // query (e.g. range max/sum)\n\tconstexpr virtual T &upd(T &lhs, const T &rhs, int len = 1) = 0; // update (e.g. range add/assign)\n\tconstexpr virtual const T def() = 0; // default value for result (e.g. INF for min query)\n\tconstexpr virtual const T udef() = 0; // default value for update (e.g. 0 for add updates)\n};\n\ntemplate <class T> struct SumAdd : SegOpTemp<T> {\n\tconstexpr T operator()(const T &lhs, const T &rhs) { return lhs + rhs; }\n\tconstexpr T &upd(T &lhs, const T &rhs, int len = 1) { return lhs += rhs * len; }\n\tconstexpr const T def() { return 0; }\n\tconstexpr const T udef() { return 0; }\n};\n\ntemplate <class T> struct SumAsg : SegOpTemp<T> {\n\tconstexpr T operator()(const T &lhs, const T &rhs) { return lhs + rhs; }\n\tconstexpr T &upd(T &lhs, const T &rhs, int len = 1) { return lhs = rhs * len; }\n\tconstexpr const T def() { return 0; }\n\tconstexpr const T udef() { return 0; }\n};\n\ntemplate <class T> struct MinAdd : SegOpTemp<T> {\n\tconstexpr T operator()(const T &lhs, const T &rhs) { return min(lhs, rhs); }\n\tconstexpr T &upd(T &lhs, const T &rhs, int = 1) { return lhs += rhs; }\n\tconstexpr const T def() { return Inf<T>::inf(); }\n\tconstexpr const T udef() { return 0; }\n};\n\ntemplate <class T> struct MinAsg : SegOpTemp<T> {\n\tconstexpr T operator()(const T &lhs, const T &rhs) { return min(lhs, rhs); }\n\tconstexpr T &upd(T &lhs, const T &rhs, int = 1) { return lhs = rhs; }\n\tconstexpr const T def() { return Inf<T>::inf(); }\n\tconstexpr const T udef() { return 0; }\n};\n// }}}\n\nint solve() {\n\tint n, q; cin >> n >> q;\n\tvll init(n);\n\tLazySegmentTree<ll, SumAsg<ll>> lst(init);\n\twhile (q--) {\n\t\tint op; cin >> op;\n\t\tif (op == 0) {\n\t\t\tint l, r, v; cin >> l >> r >> v;\n\t\t\t// l--, r--;\n\t\t\tlst.modify(l, r, v);\n\t\t} else {\n\t\t\tint l, r; cin >> l >> r;\n\t\t\t// l--, r--;\n\t\t\tcout << lst.query(l, r) << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n// Template Main {{{\nint main() {\n\tios::sync_with_stdio(0);\n\t// precompute();\n\t// int t; cin >> t; for (int i=1;i<=t;i++)\n\tsolve();\n\t// cout << \"Case #\" << i << \": \", solve();\n\treturn 0;\n}\n\ntemplate <class T> istream &operator>>(istream &is, vector<T> &v) {\n\tfor (auto it=v.begin();it!=v.end();++it) is >> *it;\n\treturn is;\n}\n\ntemplate <class T> ostream &operator<<(ostream &os, const vector<T> &v) {\n\tfor (auto it=v.begin();it!=v.end();) os << *it, os << \" \\n\"[++it==v.end()];\n\treturn os;\n}\n\ntemplate <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) {\n\treturn is >> p.first >> p.second;\n}\n\ntemplate <class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) {\n\treturn os << p.first << ' ' << p.second;\n}\n// }}}\n\n// vim: fdm=marker\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define REP(i, n) for(ll i = 0;i < n;i++)\n#define REPR(i, n) for(ll i = n;i >= 0;i--)\n#define FOR(i, m, n) for(ll i = m;i < n;i++)\n#define FORR(i, m, n) for(ll i = m;i >= n;i--)\n#define REPO(i, n) for(ll i = 1;i <= n;i++)\n#define ll long long\n#define INF (ll)1 << 60\n#define MINF (-1 * INF)\n#define ALL(n) n.begin(),n.end()\n#define MOD 1000000007\n#define P pair<ll, ll>\n\n//つよいせぐつりー！(RUQ+RAQ) ばぐってるかも\nstruct LazySegTree { //参照は + sz - 1;\n\tll sz;\n\tvector<ll> node, lazy;\n\tvector<bool> lazyFlag;\n\tLazySegTree(ll n) {\n\t\tsz = 1;\n\t\twhile (sz < n) sz *= 2;\n\t\tnode.resize(2 * sz - 1);//\n\t\tlazy.resize(2 * sz - 1);//\n\t\tlazyFlag.resize(2 * sz - 1);\n\t}\n\tvoid eval(ll k, ll l, ll r) {\n\t\tif (lazyFlag[k]) {\n\t\t\tnode[k] = lazy[k];//\n\t\t\tif (r - l > 1) {\n\t\t\t\tlazy[2 * k + 1] = lazy[k] / 2;//\n\t\t\t\tlazy[2 * k + 2] = lazy[k] / 2;//\n\t\t\t\tlazyFlag[2 * k + 1] = lazyFlag[2 * k + 2] = true;\n\t\t\t}\n\t\t\tlazyFlag[k] = false;\n\t\t\tlazy[k] = 0;//\n\t\t}\n\t\telse {\n\t\t\tif (lazy[k] == 0)return;\n\t\t\tnode[k] += lazy[k];//\n\t\t\tif (r - l > 1) {\n\t\t\t\tlazy[2 * k + 1] += lazy[k] / 2;//\n\t\t\t\tlazy[2 * k + 2] += lazy[k] / 2;//\n\t\t\t}\n\t\t\tlazy[k] = 0;//\n\t\t}\n\t}\n\tvoid add(ll a, ll b, ll x, ll k = 0, ll l = 0, ll r = -1) {\n\t\tif (r < 0) r = sz;\n\t\teval(k, l, r);\n\t\tif (b <= l || r <= a) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlazy[k] += (r - l) * x;//\n\t\t\teval(k, l, r);\n\n\t\t}\n\t\telse {\n\t\t\tadd(a, b, x, 2 * k + 1, l, (l + r) / 2);\n\t\t\tadd(a, b, x, 2 * k + 2, (l + r) / 2, r);\n\t\t\tnode[k] = node[2 * k + 1] + node[2 * k + 2];//\n\t\t}\n\t}\n\tvoid update(ll a, ll b, ll x, ll k = 0, ll l = 0, ll r = -1) {\n\t\tif (r < 0) r = sz;\n\t\teval(k, l, r);\n\t\tif (b <= l || r <= a) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlazy[k] = (r - l) * x;//\t\n\t\t\tlazyFlag[k] = true;\n\t\t\teval(k, l, r);\n\n\t\t}\n\t\telse {\n\t\t\tupdate(a, b, x, 2 * k + 1, l, (l + r) / 2);\n\t\t\tupdate(a, b, x, 2 * k + 2, (l + r) / 2, r);\n\t\t\tnode[k] = node[2 * k + 1] + node[2 * k + 2];//\n\t\t}\n\t}\n    void add(ll a, ll x) {\n\t\tadd(a, a + 1, x);\n\t}\n\tvoid update(ll a, ll x) {\n\t\tupdate(a, a + 1, x);\n\t}\n\tll query(ll a, ll b, ll k = 0, ll l = 0, ll r = -1) {\n\t\tif (r < 0) r = sz;\n\t\teval(k, l, r);\n\t\tif (b <= l || r <= a) return 0;//\n\t\tif (a <= l && r <= b) return node[k];\n\t\tll vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n\t\tll vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n\t\treturn vl + vr;//\n\t}\n\tvoid init() {\n\t\tREPR(i, sz - 2) node[i] = node[2 * i + 1] + node[2 * i + 2];//\n\t}\n};\n\nint main() {\n    ll n, q;\n    cin >> n >> q;\n    LazySegTree seg(n);\n    REP(i, q){\n        ll t;\n        cin >> t;\n        if(t == 0){\n            ll a, b, c;\n            cin >> a >> b >> c;\n            seg.update(a, b + 1, c);\n            seg.add(a, b + 1, c);\n            seg.add(a, b + 1, -c);\n        }\n        else{\n            ll a, b;\n            cin >> a >> b;\n            cout << seg.query(a, b + 1) << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * Lazy Segment Tree\n * Construction: O(n)\n * Update:       O(log n)\n * Query:        O(log n)\n *\n * Memory Usage: 3n\n */\n\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\nclass SegmentTree {\n    const int N; // array size\n    const int M; // initial value\n    const int O; // initial value of the query\n    const int H; // height of the tree, the highest significant bit in N\n\n    int (*f)(int, int); // query operation\n    int (*g)(int, int); // update operation\n    int (*h)(int, int); // delayed operation\n\npublic:\n    vector<int> t; // tree\n    vector<int> d; // delayed tree\n    vector<bool> u; // is delayed\n\n    SegmentTree(int N, int M, int O, int (*f)(int, int), int (*g)(int, int), int (*h)(int, int)) :\n            N(N), M(M), O(O), H(sizeof(int) * 8 - __builtin_clz(N)),\n            f(f), g(g), h(h), t(2 * N, M), d(N), u(N) {}\n\n    void init() { // init tree from leaves\n        for (int i = N - 1; i > 0; --i)\n            t[i] = f(t[i << 1], t[i << 1 | 1]);\n    }\n\n    void set(int k, int val) { // direct edit\n        t[k + N] = val;\n    }\n\n    void apply(int p, int val, int k) { // propagate helper\n        t[p] = g(h(val, k), t[p]);\n        if (p < N) {\n            d[p] = g(val, d[p]);\n            u[p] = true;\n        }\n    }\n\n    void calc(int p, int k) { // build helper\n        if (u[p]) t[p] = h(d[p], k);\n        else t[p] = f(t[p << 1], t[p << 1 | 1]);\n    }\n\n    void build(int p) { // build from p th node to root\n        int k = 2;\n        for (p += N; p > 1; k <<= 1) {\n            p >>= 1;\n            calc(p, k);\n        }\n    }\n\n    void propagate(int p) { // propagate to p th node from root\n        p += N;\n        for (int s = H, k = 1 << (H - 1); s > 0; --s, k >>= 1) {\n            int i = p >> s;\n            if (u[i]) {\n                apply(i << 1, d[i], k);\n                apply(i << 1 | 1, d[i], k);\n                d[i] = 0;\n                u[i] = false;\n            }\n        }\n    }\n\n    void update(int l, int r, int val) { // set val at interval [l, r)\n        propagate(l);\n        propagate(r - 1); // make sure old propagation is completed\n\n        int k = 1; // interval level\n        int l0 = l, r0 = r;\n        l += N, r += N;\n\n        for (; l < r; l >>= 1, r >>= 1, k <<= 1) {\n            if (l & 1) apply(l++, val, k);\n            if (r & 1) apply(--r, val, k);\n        }\n\n        build(l0);\n        build(r0 - 1);\n    }\n\n    int query(int l, int r) { // query on interval [l, r)\n        propagate(l);\n        propagate(r - 1);\n        int res = O;\n        for (l += N, r += N; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) res = f(t[l++], res);\n            if (r & 1) res = f(t[--r], res);\n        }\n        return res;\n    }\n};\n\nvoid put_int(int n) {\n    if (!n) {\n        putchar_unlocked('0');\n        return;\n    }\n    if (n < 0) n = -n, putchar_unlocked('-');\n    char buf[11];\n    int i = 0;\n    while (n) buf[i++] = (char) (n % 10 + '0'), n /= 10;\n    while (i--)putchar_unlocked(buf[i]);\n}\n\nint get_int() {\n    int n = 0;\n    int c = getchar_unlocked();\n    if (c == 45) {\n        c = getchar_unlocked();\n        while (47 < c && c < 58) n = 10 * n + (c & 0xf), c = getchar_unlocked();\n        return -n;\n    } else if (c < 48 || 57 < c) return c;\n    while (47 < c && c < 58) n = 10 * n + (c & 0xf), c = getchar_unlocked();\n    return n;\n}\n\nvoid test() {\n    int n = get_int();\n    int q = get_int();\n    SegmentTree T(n, 0, 0,\n                  [](int a, int b) { return a + b; },\n                  [](int a, int b) { return a; },\n                  [](int a, int b) { return a * b; }\n    );\n\n    while (q--) {\n        int type = get_int();\n        if (type) {\n            int s = get_int();\n            int t = get_int();\n            put_int(T.query(s, t + 1));\n            putchar_unlocked('\\n');\n        } else {\n            int s = get_int();\n            int t = get_int();\n            int x = get_int();\n            T.update(s, t + 1, x);\n        }\n    }\n}\n\nint main() {\n    test();\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nstatic const int MAX_N = 100000;\n\nint n, q;\n\nint n_;\nint dat[4 * MAX_N], laz[4 * MAX_N];\n\nvoid init(){\n\tn_ = 1;\n\twhile(n_ < n) n_ *= 2;\n\tfor(int i = 0; i < 2 * n_ - 1; i++){\n\t\tdat[i] = 0;\n\t\tlaz[i] = -1001;\n\t}\n}\nvoid prop(int k){\n\tif(laz[k] == -1001) return;\n\tif(2 * k + 1 < 2 * n_ - 1){\n\t\tlaz[2 * k + 1] = laz[k] / 2;\n\t\tlaz[2 * k + 2] = laz[k] / 2;\n\t}\n\tdat[k] = laz[k];\n\tlaz[k] = -1001;\n}\nvoid update(int a, int b, int x, int k, int l, int r){\n\tprop(k);\n\tif(r <= a || b <= l) return;\n\tif(a <= l && r <= b){\n\t\tlaz[k] = x * (r - l);\n\t\treturn;\n\t}\n\tprop(k);\n\tupdate(a, b, x, 2 * k + 1, l, (l + r) / 2);\n\tupdate(a, b, x, 2 * k + 2, (l + r) / 2, r);\n\tint vl = (laz[2 * k + 1] == -1001 ? dat[2 * k + 1] : laz[2 * k + 1]);\n\tint vr = (laz[2 * k + 2] == -1001 ? dat[2 * k + 2] : laz[2 * k + 2]);\n\tdat[k] = vl + vr;\n}\nint find(int a, int b, int k, int l, int r){\n\tprop(k);\n\tif(r <= a || b <= l) return 0;\n\tif(a <= l && r <= b) return dat[k];\n\tint vl = find(a, b, 2 * k + 1, l, (l + r) / 2);\n\tint vr = find(a, b, 2 * k + 2, (l + r) / 2, r);\n\treturn vl + vr;\n}\n\nint main(){\n\tscanf(\"%d %d\", &n, &q);\n\tinit();\n\tfor(int i = 0; i < q; i++){\n\t\tint op;\n\t\tscanf(\"%d\", &op);\n\t\tif(op == 0){\n\t\t\tint s, t, x;\n\t\t\tscanf(\"%d %d %d\", &s, &t, &x);\n\t\t\tupdate(s, t + 1, x, 0, 0, n_);\n\t\t}else{\n\t\t\tint s,t;\n\t\t\tscanf(\"%d %d\", &s, &t);\n\t\t\tprintf(\"%d\\n\", find(s, t + 1, 0, 0, n_));\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\nusing namespace std;\n\nstruct Monoid {\n  int64_t val, len;\n  Monoid() {}\n  Monoid(int64_t v, int64_t l) : val(v), len(l) {}\n  static Monoid ident() { return Monoid(0, 0); }\n  static Monoid multiply(Monoid l, Monoid r) {\n    return Monoid(l.val + r.val, l.len + r.len);\n  }\n  bool operator==(const Monoid &rhs) const {\n    return val == rhs.val and len == rhs.len;\n  }\n};\n\nstruct Lonoid {\n  int64_t x;\n  Lonoid() {}\n  Lonoid(int64_t x) : x(x) {}\n  static Lonoid ident() { return Lonoid(numeric_limits<int>::min()); }\n  static Lonoid multiply(Lonoid f, Lonoid g) { // f \\circ g\n    if (f == Lonoid::ident()) return g;\n    return f;\n  }\n  static Monoid apply(Lonoid f, Monoid m) { // f(m)\n    if (f == Lonoid::ident()) return m;\n    return Monoid(f.x * m.len, m.len);\n  }\n  bool operator==(const Lonoid &rhs) const { return x == rhs.x; }\n};\n\ntemplate <typename M, typename L>\nstruct SegmentTree {\n  int n;\n  M em;\n  L el;\n  vector<M> dat;\n  vector<L> laz;\n  SegmentTree(int N, vector<M> a) {\n    assert(N == (int)a.size());\n    n = 1;\n    em = M::ident();\n    el = L::ident();\n    while (n < N) {\n      n *= 2;\n    }\n    dat.resize(n * 2 - 1, em);\n    rep(i, N) dat[i + n - 1] = a[i];\n    for (int i = n - 2; i >= 0; i--) {\n      dat[i] = M::multiply(dat[i * 2 + 1], dat[i * 2 + 2]);\n    }\n    laz.resize(n * 2 - 1, el);\n  }\n  void _update(int i, L f) {\n    dat[i] = L::apply(f, dat[i]);\n    laz[i] = L::multiply(f, laz[i]);\n  }\n  void update(int ql, int qr, L f) { update(ql, qr, f, 0, 0, n); }\n  void update(int ql, int qr, L f, int i, int il, int ir) {\n    if (qr <= il or ir <= ql) return;\n    if (ql <= il and ir <= qr) {\n      _update(i, f);\n    } else {\n      auto m = (il + ir) / 2, lch = i * 2 + 1, rch = i * 2 + 2;\n      _update(lch, laz[i]);\n      _update(rch, laz[i]);\n      laz[i] = el;\n      update(ql, qr, f, lch, il, m);\n      update(ql, qr, f, rch, m, ir);\n      dat[i] = M::multiply(dat[lch], dat[rch]);\n    }\n  }\n  M query(int ql, int qr) { return query(ql, qr, 0, 0, n); }\n  M query(int ql, int qr, int i, int il, int ir) {\n    if (ql <= il and ir <= qr) {\n      return dat[i];\n    } else if (qr <= il or ir <= ql) {\n      return em;\n    } else {\n      auto m = (il + ir) / 2;\n      return L::apply(laz[i], M::multiply(query(ql, qr, i * 2 + 1, il, m),\n                                          query(ql, qr, i * 2 + 2, m, ir)));\n    }\n  }\n};\n\nint main() {\n\n  int n, q;\n  cin >> n >> q;\n  SegmentTree<Monoid, Lonoid> seg(n, vector<Monoid>(n, Monoid(0, 1)));\n  while (q--) {\n    int t;\n    cin >> t;\n    if (t == 0) {\n      int s, t, x;\n      cin >> s >> t >> x;\n      seg.update(s, t + 1, Lonoid(x));\n    } else {\n      int s, t;\n      cin >> s >> t;\n      cout << seg.query(s, t + 1).val << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<list>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<ctime>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int NIL = -1;\nconst int MAX = 2147483647;\nconst int INF = -10001;\nconst int N = 1000001;\nclock_t START, END;\nbool debug = false;\n\nint setv[N << 2], sumv[N << 2];\nint ql, qr, p, v;\nint _sum;\n\nvoid pushdown(int o)\n{\n\tint lc = o * 2, rc = o * 2 + 1;\n\tif (setv[o] > INF) {\n\t\tsetv[lc] = setv[rc] = setv[o];\n\t\tsetv[o] = INF;\n\t}\n}\n\nvoid maintain(int o, int L, int R)\n{\n\tint lc = o * 2, rc = 2 * o + 1;\n\tif (setv[o] > INF) {\n\t\tsumv[o] = setv[o] * (R - L + 1);\n\t}\n\telse {\n\t\tsumv[o] = sumv[lc] + sumv[rc];\n\t}\n}\n\nvoid query(int o, int L, int R, int add)\n{\n\tint M = L + (R - L) / 2;\n\tif (setv[o] > INF) {\n\t\t_sum += setv[o] * (min(R, qr) - max(L, ql) + 1);\n\t}\n\telse if (ql <= L && qr >= R) {\n\t\t_sum += sumv[o];\n\t}\n\telse {\n\t\tif (ql <= M)\n\t\t\tquery(o * 2, L, M, add + sumv[o]);\n\t\tif (qr > M)\n\t\t\tquery(o * 2 + 1, M + 1, R, add + sumv[o]);\n\t}\n}\n\nvoid update(int o, int L, int R)\n{\n\tint M = L + (R - L) / 2;\n\tint lc = o * 2, rc = o * 2 + 1;\n\tif (ql <= L && qr >= R) {\n\t\tsetv[o] = v;\n\t}\n\telse {\n\t\tpushdown(o);\n\t\tif (ql <= M)\n\t\t\tupdate(lc, L, M);\n\t\telse\n\t\t\tmaintain(lc, L, M);\n\t\tif (qr > M)\n\t\t\tupdate(rc, M + 1, R);\n\t\telse\n\t\t\tmaintain(rc, M + 1, R);\n\t}\n\tmaintain(o, L, R);\n}\n\n\nint main(void)\n{\n\tif (debug) {\n\t\tSTART = clock();\n\t\tfreopen(\"in18.txt\", \"r\", stdin);\n\t\tfreopen(\"out.txt\", \"w\", stdout);\n\t}\n\tint n, q, com;\n\tscanf(\"%d%d\", &n, &q);\n\tfor (int i = 0; i <= 4 * n; i++) {\n\t\tsetv[i] = INF;\n\t\tsumv[i] = 0;\n\t}\n\tfor (int i = 0; i < q; i++) {\n\t\tscanf(\"%d\", &com);\n\t\tif (com) {\n\t\t\tscanf(\"%d%d\", &ql, &qr);\n\t\t\tql++;\n\t\t\tqr++;\n\t\t\t_sum = 0;\n\t\t\tquery(1, 1, n, 0);\n\t\t\tprintf(\"%d\\n\", _sum);\n\t\t}\n\t\telse {\n\t\t\tscanf(\"%d%d%d\", &ql, &qr, &v);\n\t\t\tql++;\n\t\t\tqr++;\n\t\t\tupdate(1, 1, n);\n\t\t}\n\t}\n\tif (debug) {\n\t\tEND = clock();\n\t\tdouble endtime = (double)(END - START) / 1000;\n\t\tprintf(\"total time = %lf s\", endtime);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,num) for(ll i=0;i<(num);++i)\n#define FOR(i,c,num) for(ll (i)=(c);(i)<(num);++(i))\n#define LOOP(i) while(i--)\n#define ALL(c) c.begin(),c.end()\n#define PRINTALL(c) for(auto pitr=c.begin();pitr!=c.end();++pitr){cout<<*pitr;if(next(pitr,1)!=c.end())cout<<' ';}cout<<endl;\n#define PAIRCOMP(c,comp) [](const pair<ll,ll>& lhs,const pair<ll,ll>& rhs){return lhs.c comp rhs.c;}\n\nusing namespace std;\nusing ll = long long;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\n\nconstexpr ll atcoder_mod = 1e9+7;\n\ntemplate<typename T=ll>\nT in(){T x; cin >> x; return (x);}\ntemplate<typename T=ll,typename C=vector<T>>\nC vecin(int N){C x(N);REP(i,N){x[i]=in<T>();}return x;}\n\nvoid vout(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid vout(Head&& h,Tail&&... t){cout << ' ' << h;vout(forward<Tail>(t)...);}\nvoid out(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid out(Head&& h,Tail&&... t){cout << h;vout(forward<Tail>(t)...);}\n\ntemplate<typename T>\nbool chmax(T& a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>\nbool chmin(T& a,T b){if(a>b){a=b;return true;}return false;}\n\n/* 処理：範囲加算　出力：範囲合計値\nauto fx = [](ll x1, ll x2){ return x1 + x2; };\nauto fa = [](ll x, ll m){ return x + m; };\nauto fm = [](ll m1, ll m2){ return m1 + m2; };\nauto fp = [](ll m, ll n){ return m * n; };\nlong long ex = 0;\nlong long em = 0;\n*/\n\n/* 処理：範囲加算　出力：範囲最小値\nauto fx = [](ll x1, ll x2){ return min(x1 , x2); };\nauto fa = [](ll x, ll m){ return x + m; };\nauto fm = [](ll m1, ll m2){ return m1 + m2; };\nauto fp = [](ll m, ll n){ return m; };\nlong long ex = numeric_limits<ll>::max();\nlong long em = 0;\n*/\n\n/* 処理：範囲変更　出力：範囲最小値\nauto fx = [](ll x1, ll x2){ return min(x1 , x2); };\nauto fa = [](ll x, ll m){ return m; };\nauto fm = [](ll m1, ll m2){ return m2; };\nauto fp = [](ll m, ll n){ return m; };\nlong long ex = numeric_limits<ll>::max();\nlong long em = numeric_limits<ll>::max();\n*/\n\n/*\nauto fx = [](ll x1, ll x2){ return x1 + x2; };\nauto fa = [](ll x, ll m){ return m; };\nauto fm = [](ll m1, ll m2){ return m2; };\nauto fp = [](ll m, ll n){ return m*n; };\nlong long ex = 0;\nlong long em = numeric_limits<ll>::max();\n*/\n\nclass RangeUpdate{\npublic:\n\tvirtual ll fa(ll x,ll m)=0;\n\tvirtual ll fm(ll m1,ll m2)=0;\n\tll em;\n};\n\nclass RangeUpdateChange:public RangeUpdate{\npublic:\n\tRangeUpdateChange(){em = numeric_limits<ll>::max();}\n\tll fa(ll x,ll m){return m;}\n\tll fm(ll m1,ll m2){return m2;}\n};\n\nclass RangeUpdateAdd:public RangeUpdate{\npublic:\n\tRangeUpdateAdd(){em = 0;}\n\tll fa(ll x,ll m){return x+m;}\n\tll fm(ll m1,ll m2){return m1+m2;}\n};\n\nclass RangeQuery{\npublic:\n\tvirtual ll fx(ll x1,ll x2)=0;\n\tvirtual ll fp(ll m,ll n)=0;\n\tll ex;\n};\n\nclass RangeQuerySum:public RangeQuery{\npublic:\n\tRangeQuerySum(){ex=0;}\n\tll fx(ll x1,ll x2){return x1+x2;}\n\tll fp(ll m,ll n){return m*n;}\n};\n\nclass RangeQueryMin:public RangeQuery{\npublic:\n\tRangeQueryMin(){ex = numeric_limits<ll>::max();}\n\tll fx(ll x1,ll x2){return min(x1,x2);}\n\tll fp(ll m,ll n){return m;}\n};\n\nclass SegmentTree{\n\tunique_ptr<RangeUpdate> range_update;\n\tunique_ptr<RangeQuery> range_query;\n\n\t/* lazy eval */\n\tvoid Eval(int k,int len){\n\t\tif(lazy[k]==range_update->em) return;  // 更新するものが無ければ終了\n\t\tif(k<size-1){            // 葉でなければ子に伝搬\n\t\t\tlazy[k*2+1] = range_update->fm(lazy[k*2+1],lazy[k]);\n\t\t\tlazy[k*2+2] = range_update->fm(lazy[k*2+2],lazy[k]);\n\t\t}\n\t\t// 自身を更新\n\t\tdat[k] = range_update->fa(dat[k],range_query->fp(lazy[k],len));\n\t\tlazy[k] = range_update->em;\n\t}\n\n\tll Query(ll a, ll b, ll k, ll l, ll r){\n\t\tEval(k,r-l);\n\t\tif(r<=a || b<=l){  // 完全に外側の時\n\t\t\treturn range_query->ex;\n\t\t}\n\t\telse if(a <= l && r <= b){  // 完全に内側の時\n\t\t\treturn dat[k];\n\t\t}\n\t\telse{  // 一部区間が被る時\n\t\t\tll vl = Query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tll vr = Query(a,b,k*2+2,(l+r)/2,r);\n\t\t\treturn range_query->fx(vl,vr);\n\t\t}\n\t}\n\n\tvoid Update(ll a, ll b, ll x, ll k, ll l, ll r) {\n\t\tEval(k,r-l);\n\t\tif(a<=l && r<=b){  // 完全に内側の時\n\t\t\tlazy[k] = range_update->fm(lazy[k],x);\n\t\t\tEval(k,r-l);\n\t\t}\n\t\telse if(a<r && l<b){                     // 一部区間が被る時\n\t\t\tUpdate(a,b,x,k*2+1,l,(l+r)/2);  // 左の子\n\t\t\tUpdate(a,b,x,k*2+2,(l+r)/2,r);  // 右の子\n\t\t\tdat[k] = range_query->fx(dat[k*2+1],dat[k*2+2]);\n\t\t}\n\t}\npublic:\n\tll size;\n\tvector<ll> dat;\n\tvector<ll> lazy;\n\tSegmentTree(ll N, unique_ptr<RangeUpdate> rup,unique_ptr<RangeQuery> rqp)\n\t\t: range_update(std::move(rup)), range_query(std::move(rqp)){\n\t\tdat.resize(4*N,range_query->ex);\n\t\tlazy.resize(4*N,range_update->em);\n\t\tll x = 1;\n\t\twhile(N>x) x *= 2;\n\t\tsize = x;\n\t}\n\tvoid Set(int i, ll x){dat[i+size-1]=x;}\n\tvoid Build(){\n\t\tfor(ll k=size-2ll;k>=0;k--) dat[k] = range_query->fx(dat[2*k+1],dat[2*k+2]);\n\t}\n\t\n\tvoid Update(ll a, ll b, ll x){Update(a, b, x, 0, 0, size);}\n\tll Query(int a, int b){return Query(a, b, 0, 0, size);}\n};\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(10);\n\n\tauto N=in(),Q=in();\n\n\tSegmentTree rsq(N, make_unique<RangeUpdateChange>(),make_unique<RangeQuerySum>());\n\tfor (int i = 0; i < N; i++) {\n\t\trsq.Set(i, 0);\n\t}\n\trsq.Build();\n\n\tvector<long long> ans;\n\tfor (int i = 0; i < Q; i++) {\n\t\tint c;\n\t\tcin >> c;\n\t\tif (c == 0) {\n\t\t\tint s, t;\n\t\t\tlong long x;\n\t\t\tcin >> s >> t >> x;\n\t\t\t//s--, t--;\n\t\t\trsq.Update(s, t + 1, x);\n\t\t} else if (c == 1) {\n\t\t\tint s, t;\n\t\t\tcin >> s >> t;\n\t\t\t//s--, t--;\n\t\t\tans.push_back(rsq.Query(s, t + 1));\n\t\t}\n\t}\n\tfor (auto i : ans) {\n\t\tcout << i << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\n\ntemplate <class T>\nclass LazySegmentTree{\nprivate:\n    int n;\n    vector<T> dat, lazy;\n    vector<bool> flag;\n    T def;\n\n    void _eval(int k, int l, int r){\n        if(flag[k]){\n            dat[k] = (r-l) * lazy[k];\n            if(1<r-l){\n                lazy[2*k+1] = lazy[k];\n                lazy[2*k+2] = lazy[k];\n                flag[2*k+1] = true;\n                flag[2*k+2] = true;\n            }\n            flag[k] = false;\n        }\n    }\n\n    T _query(int a, int b, int k, int l, int r){\n        // [a, b), [l, r)\n        if(r<=a or b<=l) return def;\n        _eval(k, l, r);\n        if(a<=l and r<=b) return dat[k];\n        else{\n            T c1 = _query(a, b, 2*k+1, l, (l+r)/2);\n            T c2 = _query(a, b, 2*k+2, (l+r)/2, r);\n            return c1 + c2;\n        }\n    }\n\n    void _change(int a, int b, T x, int k, int l, int r){\n        _eval(k, l, r);\n        if(b<=l or r<=a) return;\n        else if(a<=l and r<=b){\n            lazy[k] = x;\n            flag[k] = true;\n            _eval(k, l, r);\n        } else {\n            _change(a, b, x, 2*k+1, l, (l+r)/2);\n            _change(a, b, x, 2*k+2, (l+r)/2, r);\n            dat[k] = dat[2*k+1] + dat[2*k+2];\n        }\n    }\n\n    int _find(T x, int k, int l, int r){\n        if(r-l==1) return k - n + 1;\n        _eval(2*k+1, l, (l+r)/2);\n        _eval(k, 2*k+2, (l+r)/2, r);\n        if(dat[2*k+1]>=x) return _find(x, 2*k+1, l, (l+r)/2);\n        else return _find(x, 2*k+2, (l+r)/2, r);\n    }\n\npublic:\n    // [a, b)\n    T query(int a, int b){\n        return _query(a, b, 0, 0, n);\n    }\n\n    void change(int a, int b, T x){\n        _change(a, b, x, 0, 0, n);\n    }\n\n    int find(T x){\n        _eval(0, 0, n);\n        if(dat[0]<x) return -1;\n        return _find(x, 0, 0, n);\n    }\n\n    T operator[](int i){\n        return dat[i+n-1];\n    }\n\n    LazySegmentTree(size_t _n, T _def)\n            : def(_def){\n        n = 1;\n        while(n < _n){\n            n *= 2;\n        }\n        dat.assign(2*n-1, def);\n        flag.assign(2*n-1, false);\n        lazy.resize(2*n-1);\n    }\n\n    LazySegmentTree(size_t _n, T _def, vector<T>& _v)\n            : def(_def){\n        n = 1;\n        while(n < _n){\n            n *= 2;\n        }\n        dat.assign(2*n-1, def);\n        flag.assign(2*n-1, false);\n        lazy.resize(2*n-1);\n        for(int i=0;i<_n;++i) dat[n-1+i] = _v[i];\n        for(int i=n-2;0<=i;--i) dat[i] = dat[2*i+1] + dat[2*i+2];\n    }\n};\n\nclass Task{\npublic:\n    void solve(istream& in, ostream& out){\n        int N, tt;\n        in>>N>>tt;\n        LazySegmentTree<int> ldat(N, 0);\n        while(tt--){\n            int t;\n            in>>t;\n            if(t){\n                int l, r;\n                in>>l>>r;\n                out<<ldat.query(l, r+1)<<'\\n';\n            }else{\n                int l, r, x;\n                in>>l>>r>>x;\n                ldat.change(l, r+1, x);\n            }\n        }\n    }\n};\n\nint main(){\n    Task solver;\n    istream& in(cin);\n    ostream& out(cout);\n    ios::sync_with_stdio(false);\n    in.tie(nullptr), out.tie(nullptr);\n    solver.solve(in, out);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n\nusing namespace std;\ntypedef long long ll;\n\nstruct SegmentTree {\nprivate:\n    //////////////////////\n    // TODO Change them //\n    //////////////////////\n    constexpr static int UPDATE_IDENTITY_ELEMENT = 0;\n    constexpr static int CALCULATE_IDENTITY_ELEMENT = 0;\n    constexpr static bool IS_LAZY = true;\n\n    inline static void update(ll &x, ll y) { x = y; }\n\n    inline static ll calculate(ll x, ll y) { return x + y; }\n\n    inline void evaluation(int index, int nowL, int nowR) {\n        if (changed[index]) {\n            update(data[index], (nowR - nowL) * lazy[index]); // TODO Change updating\n            if (nowR - nowL > 1) {\n                update(lazy[index * 2], lazy[index]), changed[index * 2] = true;\n                update(lazy[index * 2 + 1], lazy[index]), changed[index * 2 + 1] = true;\n            }\n            lazy[index] = UPDATE_IDENTITY_ELEMENT, changed[index] = false;\n        }\n    }\n    //////////////////////\n    // TODO Change them //\n    //////////////////////\n\n\n    int n;\n    vector<ll> data;\n    vector<ll> lazy;\n    vector<bool> changed;\n\n    void initialize(int size, vector<ll> &v) {\n        n = 1;\n        while (n < size)n <<= 1;\n        data.resize(2 * n);\n        if (IS_LAZY) {\n            lazy.assign(2 * n, UPDATE_IDENTITY_ELEMENT);\n            changed.resize(2 * n);\n        }\n\n        for (int i = n; i < n + v.size(); i++)data[i] = v[i - n];\n        for (int i = n - 1; i > 0; i--)data[i] = children(i);\n    }\n\n    inline ll children(int index) { return calculate(data[index * 2], data[index * 2 + 1]); }\n\n    inline void update_point(int index, int value) {\n        index += n;\n        update(data[index], value);\n        while (index > 1) {\n            index >>= 1;\n            data[index] = children(index);\n        }\n    }\n\n    inline void update_range(int wantL, int wantR, ll value, int index, int nowL, int nowR) {\n        evaluation(index, nowL, nowR);\n\n        if (nowR <= wantL || wantR <= nowL)return;\n\n        if (wantL <= nowL && nowR <= wantR) {\n            update(lazy[index], value), changed[index] = true;\n            evaluation(index, nowL, nowR);\n        } else {\n            int mid = (nowL + nowR) / 2;\n            update_range(wantL, wantR, value, index * 2, nowL, mid);\n            update_range(wantL, wantR, value, index * 2 + 1, mid, nowR);\n            data[index] = children(index);\n        }\n    }\n\n    inline ll query(int wantL, int wantR, int index, int nowL, int nowR) {\n        if (nowR <= wantL || wantR <= nowL)return CALCULATE_IDENTITY_ELEMENT;\n\n        if (IS_LAZY)evaluation(index, nowL, nowR);\n        if (wantL <= nowL && nowR <= wantR) return data[index];\n        else {\n            int mid = (nowL + nowR) / 2;\n            ll valueL = query(wantL, wantR, index * 2, nowL, mid);\n            ll valueR = query(wantL, wantR, index * 2 + 1, mid, nowR);\n            return calculate(valueL, valueR);\n        }\n    }\n\npublic:\n    SegmentTree(int size, ll value) {\n        vector<ll> tmp(size, value);\n        initialize(size, tmp);\n    }\n\n    SegmentTree(vector<ll> &v) { initialize(v.size(), v); }\n\n    inline void update(int index, ll value) {\n        if (IS_LAZY) update(index, index + 1, value);\n        else update_point(index, value);\n    }\n\n    inline void update(int indexL, int indexR, ll value) {\n        if (IS_LAZY) update_range(indexL, indexR, value, 1, 0, n);\n        else {\n            for (int i = indexL; i < indexR; i++)update(i, value);\n        }\n    }\n\n    inline ll get(int index) { return get(index, index + 1); }\n\n    inline ll get(int indexL, int indexR) { return query(indexL, indexR, 1, 0, n); }\n};\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    SegmentTree seg(n, 0);\n    for (int i = 0; i < q; i++) {\n        int com;\n        cin >> com;\n        if (com == 0) {\n            int s, t, x;\n            cin >> s >> t >> x;\n            seg.update(s, t + 1, x);\n        } else {\n            int s, t;\n            cin >> s >> t;\n            cout << seg.get(s, t + 1) << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long int\n#define MOD(x) ((x % MOD_N) + MOD_N) % MOD_N\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define RFORE(i,a,b) for(int i=(b);i>=(a);--i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define RALL(c) (c).rbegin(),(c).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(c) (int)((c).size())\n#define EACH(i,v) for(auto i=v.begin();i!=v.end();++i)\n#define REACH(i,v) for(auto i=v.rbegin();i!=v.rend();++i)\n#define LB(c,x) distance((c).begin(),lower_bound(ALL(c),x))\n#define UB(c,x) distance((c).begin(),upper_bound(ALL(c),x))\n#define COUNT(c,x) (lower_bound(ALL(c),x)-upper_bound(ALL(c),x))\n#define UNIQUE(c) SORT(c); (c).erase(unique(ALL(c)),(c).end());\n#define COPY(c1,c2) copy(ALL(c1),(c2).begin())\n#define EXIST(s,e) (bool)((s).find(e)!=(s).end())\n#define PB push_back\n#define MP make_pair\n#define DUMP(x)  cerr<<#x<<\" = \"<<(x)<<endl;\n#define NL cerr<<endl;\nusing namespace std;\ntemplate<typename T,typename U> using P=pair<T,U>;\ntemplate<typename T> using V=vector<T>;\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T sum(vector<T>&v){return accumulate(ALL(v),T());}\ntemplate<typename T>T sum(vector<T>&v,int a,int b){return accumulate(v.begin()+a,v.begin()+b,T());}\ntemplate<typename T>T max(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T min(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T max_index(vector<T>&v){return distance((v).begin(),max_element(ALL(v)));}\ntemplate<typename T>T min_index(vector<T>&v){return distance((v).begin(),min_element(ALL(v)));}\n\nstruct edge { int to, cost; };\n\ntemplate<typename T>auto&operator<<(ostream&s,const vector<T>&v){s<<\"[\";bool a=1;for(auto e:v){s<<(a?\"\":\" \")<<e;a=0;}s<<\"]\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const pair<T,U>&p){s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return s;}\ntemplate<typename T>auto&operator<<(ostream&s,const set<T>&st){s<<\"{\";bool a=1;for(auto e:st){s<<(a?\"\":\" \")<<e;a=0;}s<<\"}\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const map<T,U>&m){s<<\"{\";bool a=1;for(auto e:m){s<<(a?\"\":\" \")<<e.first<<\":\"<<e.second;a=0;}s<<\"}\";return s;}\n\nconst int INF = 1e18;\nconst int MOD_N = 1e9+7;\n\ntemplate< typename Monoid, typename OperatorMonoid = Monoid >\nstruct LazySegmentTree {\n   using F = function< Monoid(Monoid, Monoid) >;\n   using G = function< Monoid(Monoid, OperatorMonoid, int) >;\n   using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n   int sz;\n   vector< Monoid > data;\n   vector< OperatorMonoid > lazy;\n   const F f;\n   const G g;\n   const H h;\n   const Monoid M1;\n   const OperatorMonoid OM0;\n   LazySegmentTree(int n, const F f, const G g, const H h,\n                   const Monoid &M1, const OperatorMonoid OM0)\n         : f(f), g(g), h(h), M1(M1), OM0(OM0) {\n      sz = 1;\n      while(sz < n) sz <<= 1;\n      data.assign(2 * sz, M1);\n      lazy.assign(2 * sz, OM0);\n   }\n\n   void set(int k, const Monoid &x) {\n      data[k + sz] = x;\n   }\n   void build() {\n      for(int k = sz - 1; k > 0; k--) {\n         data[k] = f(data[2 * k + 0], data[2 * k + 1]);\n      }\n   }\n   void propagate(int k, int len) {\n      if(lazy[k] != OM0) {\n         if(k < sz) {\n            lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n            lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n         }\n         data[k] = g(data[k], lazy[k], len);\n         lazy[k] = OM0;\n      }\n   }\n   Monoid update(int a, int b, const OperatorMonoid &x, int k, int l, int r) {\n      propagate(k, r - l);\n      if(r <= a || b <= l) {\n         return data[k];\n      } else if(a <= l && r <= b) {\n         lazy[k] = h(lazy[k], x);\n         propagate(k, r - l);\n         return data[k];\n      } else {\n         return data[k] = f(update(a, b, x, 2 * k + 0, l, (l + r) >> 1),\n                            update(a, b, x, 2 * k + 1, (l + r) >> 1, r));\n      }\n   }\n   Monoid update(int a, int b, const OperatorMonoid &x) {\n      return update(a, b, x, 1, 0, sz);\n   }\n   Monoid query(int a, int b, int k, int l, int r) {\n      propagate(k, r - l);\n      if(r <= a || b <= l) {\n         return M1;\n      } else if(a <= l && r <= b) {\n         return data[k];\n      } else {\n         return f(query(a, b, 2 * k + 0, l, (l + r) >> 1),\n                  query(a, b, 2 * k + 1, (l + r) >> 1, r));\n      }\n   }\n   Monoid query(int a, int b) {\n      return query(a, b, 1, 0, sz);\n   }\n   Monoid operator[](const int &k) {\n      return query(k, k + 1);\n   }\n};\n\nsigned main()\n{\n   int n, q; cin >> n >> q;\n   V<int> c(q), s(q), t(q), x(q);\n   REP(i, q) {\n      cin >> c[i];\n      if (c[i] == 0) {\n         cin >> s[i] >> t[i] >> x[i];\n      } else {\n         cin >> s[i] >> t[i];\n      }\n   }\n   LazySegmentTree<int> lsegt(n,\n         [](int a,int b){ return a + b; },\n         [](int a,int b,int c){ return b * c; },\n         [](int a,int b){ return b; }, 0, 0);\n   REP(i, q) {\n      if (c[i] == 0) {\n         lsegt.update(s[i], t[i]+1, x[i]);\n      } else {\n         cout << lsegt.query(s[i], t[i]+1) << endl;\n      }\n   }\n\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n//RSQ\nstruct SegmentTree{\nprivate:\n\tint N;\n\tvector<long long> node, lazy;\n\tvector<bool> lazyFlg;\n\tconst long long DEFAULT = 0LL;\npublic:\n\tvoid init(int n){ //初期化 O(N)\n\t\tnode.clear();\n\t\tlazy.clear();\n\t\tlazyFlg.clear();\n\t\tN = 1;\n\t\twhile(N < n) N = (N<<1);\n\t\tfor(int i=0; i<2*N-1; i++){\n\t\t\tnode.push_back(DEFAULT);\n\t\t\tlazy.push_back(0LL);\n\t\t\tlazyFlg.push_back(false);\n\t\t}\n\t}\n\tvoid eval(int k, int l, int r){ //遅延評価 O(1)\n\t\tif(lazyFlg[k]){ //RUQ：下に更新クエリが溜まっていても加算クエリが溜まっていても上書き\n\t\t\tnode[k] = lazy[k];\n\t\t\tif(r-l > 1){\n\t\t\t\tlazy[2*k+1] = lazy[k] / 2;\n\t\t\t\tlazyFlg[2*k+1] = true;\n\t\t\t\tlazy[2*k+2] = lazy[k] / 2;\n\t\t\t\tlazyFlg[2*k+2] = true;\n\t\t\t}\n\t\t\tlazy[k] = 0LL;\n\t\t\tlazyFlg[k] = false;\n\t\t}\n\t\telse{ //RAQ：下に更新クエリが溜まっていても加算クエリが溜まっていても加算\n\t\t\tnode[k] += lazy[k];\n\t\t\tif(r-l > 1){\n\t\t\t\tlazy[2*k+1] += lazy[k] / 2;\n\t\t\t\tlazy[2*k+2] += lazy[k] / 2;\n\t\t\t}\n\t\t\tlazy[k] = 0LL;\n\t\t}\n\t}\n\tvoid update(int a, long long x){ //[a,a+1)の値を変更 O(log N)\n\t\tupdate(a, a+1, x);\n\t}\n\tvoid update(int a, int b, long long x, int k=0, int l=0, int r=-1){ //[a,b)の値を変更 O(log N)\n\t\tif(r == -1) r = N;\n\t\teval(k, l, r);\n\t\tif(b <= l || r <= a) return; //交差する場合\n\t\tif(a <= l && r <= b){ //完全に含む場合\n\t\t\tlazy[k] = x * (r-l);\n\t\t\tlazyFlg[k] = true;\n\t\t\teval(k, l, r);\n\t\t}\n\t\telse{\n\t\t\tupdate(a, b, x, 2*k+1, l, (l+r)/2);\n\t\t\tupdate(a, b, x, 2*k+2, (l+r)/2, r);\n\t\t\tnode[k] = node[2*k+1] + node[2*k+2];\n\t\t}\n\t}\n\tvoid add(int a, long long x){ //[a,a+1)の値に加算 O(log N)\n\t\tadd(a, a+1, x);\n\t}\n\tvoid add(int a, int b, long long x, int k=0, int l=0, int r=-1){ //[a,b)の値に加算 O(log N)\n\t\tif(r == -1) r = N;\n\t\teval(k, l, r);\n\t\tif(b <= l || r <= a) return; //交差する場合\n\t\tif(a <= l && r <= b){ //完全に含む場合\n\t\t\tlazy[k] += x * (r-l);\n\t\t\teval(k, l, r);\n\t\t}\n\t\telse{\n\t\t\tadd(a, b, x, 2*k+1, l, (l+r)/2);\n\t\t\tadd(a, b, x, 2*k+2, (l+r)/2, r);\n\t\t\tnode[k] = node[2*k+1] + node[2*k+2];\n\t\t}\n\t}\n\tlong long sum(int a, int b, int k=0, int l=0, int r=-1){ //[a,b)の和 O(log N)\n\t\tif(r == -1) r = N;\n\t\tif(b <= l || r <= a) return DEFAULT; //交差する場合\n\t\teval(k, l, r);\n\t\tif(a <= l && r <= b) return node[k]; //完全に含む場合\n\t\treturn sum(a, b, k*2+1, l, (l+r)/2) + sum(a, b, k*2+2, (l+r)/2, r);\n\t}\n};\n\nint main(){\n\tint N, Q;\n\tcin >> N >> Q;\n\tSegmentTree st;\n\tst.init(N+1);\n\tfor(int q=0; q<Q; q++){\n\t\tint c, s, t;\n\t\tcin >> c >> s >> t;\n\t\tif(c == 0){\n\t\t\tint x; cin >> x;\n\t\t\tst.update(s, t+1, x);\n\t\t}\n\t\telse cout << st.sum(s, t+1) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define EACH(i, c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n//#define LOCAL 0\n//#ifdef LOCAL\n//#define DEBUG(s) cout << (s) << endl\n//#define dump(x)  cerr << #x << \" = \" << (x) << endl\n//#define BR cout << endl;\n//#else\n//#define DEBUG(s) do{}while(0)\n//#define dump(x) do{}while(0)\n//#define BR\n//#endif\n\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n//ここから編集する\n\ntemplate<typename T, typename E>\nstruct SegmentTree {\n    using F = function<T(T, T)>;\n    using G = function<T(T, E)>;\n    using H = function<E(E, E)>;\n    using P = function<E(E, size_t)>;\n    int n;\n    F f; //要素と要素のマージ\n    G g; //要素に作用素を作用\n    H h; //作用素と作用素をマージ\n    T ti; //要素の単位元?\n    E ei; //作用素の単位元?\n    P p; //b個の作用素aをマージした場合\n    vector<T> dat;\n    vector<E> laz;\n\n    SegmentTree(int n_, F f, G g, H h, T ti, E ei,\n                P p = [](E a, size_t b) {\n                    b++;\n                    return a;\n                }) :\n            f(f), g(g), h(h), ti(ti), ei(ei), p(p) {\n        init(n_);\n    }\n\n    void init(int n_) {\n        n = 1;\n        while (n < n_) n *= 2;\n        dat.assign(2 * n - 1, ti);\n        laz.assign(2 * n - 1, ei);\n    }\n\n    void build(int n_, vector<T> v) {\n        for (int i = 0; i < n_; i++) dat[i + n - 1] = v[i];\n        for (int i = n - 2; i >= 0; i--)\n            dat[i] = f(dat[i * 2 + 1], dat[i * 2 + 2]);\n    }\n\n    inline void eval(int len, int k) {\n        if (laz[k] == ei) return;\n        if (k * 2 + 1 < n * 2 - 1) {\n            laz[k * 2 + 1] = h(laz[k * 2 + 1], laz[k]);\n            laz[k * 2 + 2] = h(laz[k * 2 + 2], laz[k]);\n        }\n        dat[k] = g(dat[k], p(laz[k], len));\n        laz[k] = ei;\n    }\n\n    T update(int a, int b, E x, int k, int l, int r) {\n        eval(r - l, k);\n        if (r <= a || b <= l) return dat[k];\n        if (a <= l && r <= b) {\n            laz[k] = h(laz[k], x);\n            return g(dat[k], p(laz[k], r - l));\n        }\n        return dat[k] = f(update(a, b, x, k * 2 + 1, l, (l + r) / 2),\n                          update(a, b, x, k * 2 + 2, (l + r) / 2, r));\n    }\n\n    T update(int a, int b, E x) {\n        return update(a, b, x, 0, 0, n);\n    }\n\n    T query(int a, int b, int k, int l, int r) {\n        eval(r - l, k);\n        if (r <= a || b <= l) return ti;\n        if (a <= l && r <= b) return dat[k];\n        T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return f(vl, vr);\n    }\n\n    T query(int a, int b) {\n        return query(a, b, 0, 0, n);\n    }\n\n    /**\n     * kをxに更新する\n     */\n    void update(int k, T x) {\n        query(k, k + 1);//evaluate\n        k += n - 1;\n        dat[k] = x;\n        while (k) {\n            k = (k - 1) / 2;\n            dat[k] = f(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, q;\n    cin >> n >> q;\n\n    using T = pair<ll, int>;\n    using E = pair<ll, int>;\n    auto f = [](T a, T b) {\n        a.first += b.first;\n        a.second = max(a.second, b.second);\n        return a;\n    }; // 要素と要素のマージ\n\n    auto g = [](T a, E b) {\n        if (a.second > b.second) {\n            return a;\n        } else {\n            return b;\n        }\n    }; // 要素に作用素を作用\n\n    auto h = [](E a, E b) {\n        if (a.second > b.second) {\n            return a;\n        } else {\n            return b;\n        }\n    }; // 作用素と作用素をマージ\n\n    auto p = [](E a, int b) {\n        a.first *= b;\n        return a;\n    }; // 作用素を区間加算する場合\n    T ti = pair<ll, int>(0, 0); //要素の単位元?\n    E ei = pair<ll, int>(0, 0); //作用素の単位元?\n    SegmentTree<T, E> treeone(n, f, g, h, ti, ei, p);\n\n    int time = 0;\n    while (q--) {\n        int cmd;\n        cin >> cmd;\n        if (cmd) {\n            int s, t;\n            cin >> s >> t;\n\n            cout << treeone.query(s, t + 1).first << endl;\n\n        } else {\n            int s, t, x;\n            cin >> s >> t >> x;\n            pair<int, int> tmp(x, +time);\n            treeone.update(s, t + 1, tmp);\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdint>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define FOR(i, s, t) for (int i = s; i < t; i++)\n#define ALL(obj) obj.begin(), obj.end()\n\nconst int iINF = 1e9;\nconst long long llINF = 1e18;\nconst int MOD = 1e9 + 7;\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\n\ntemplate <int MOD>\nstruct ModInt {\n    long long val;\n    constexpr ModInt(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr ModInt operator-() const noexcept { return val ? MOD - val : 0; }\n    constexpr ModInt operator+(const ModInt& r) const noexcept { return ModInt(*this) += r; }\n    constexpr ModInt operator-(const ModInt& r) const noexcept { return ModInt(*this) -= r; }\n    constexpr ModInt operator*(const ModInt& r) const noexcept { return ModInt(*this) *= r; }\n    constexpr ModInt operator/(const ModInt& r) const noexcept { return ModInt(*this) /= r; }\n    constexpr ModInt& operator+=(const ModInt& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr ModInt& operator-=(const ModInt& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr ModInt& operator*=(const ModInt& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr ModInt& operator/=(const ModInt& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b;\n            swap(a, b);\n            u -= t * v;\n            swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator==(const ModInt& r) const noexcept { return this->val == r.val; }\n    constexpr bool operator!=(const ModInt& r) const noexcept { return this->val != r.val; }\n    friend constexpr ostream& operator<<(ostream& os, const ModInt<MOD>& x) noexcept { return os << x.val; }\n\n    friend constexpr istream& operator>>(istream& is, ModInt<MOD>& x) noexcept { return is >> x.val; }\n    friend constexpr ModInt<MOD> modpow(const ModInt<MOD>& a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\nusing mint = ModInt<MOD>;\n\nlong long modPow(long long x, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * x % mod;\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nlong long extGCD(long long a, long long b, long long& x, long long& y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n\n    long long d = extGCD(b, a % b, y, x);\n    y -= a / b * x;\n    return d;\n}\n\nlong long gcd(long long a, long long b) {\n    if (b == 0) {\n        return a;\n    } else {\n        return gcd(b, a % b);\n    }\n}\n\nlong long lcm(long long a, long long b) { return a / gcd(a, b) * b; }\n\ntemplate <typename T>\nmap<T, int> compress(vector<T> x) {\n    map<T, int> res;\n    sort(x.begin(), x.end());\n    x.erase(unique(x.begin(), x.end()), x.end());\n    for (int i = 0; i < x.size(); i++) {\n        res[x[i]] = i;\n    }\n\n    return res;\n}\n\ntemplate <typename T>\nint former(const vector<T>& v, T x) {\n    return upper_bound(v.begin(), v.end(), x) - v.begin() - 1;\n}\n\ntemplate <typename T>\nint latter(const vector<T>& v, T x) {\n    return lower_bound(v.begin(), v.end(), x) - v.begin();\n}\n\ntemplate <typename T>\nusing Vec = vector<T>;\ntemplate <typename T>\nusing VVec = vector<vector<T>>;\nusing LL = long long;\n\ntemplate <typename MonoidType, typename OperatorType>\nstruct LazySegmentTree {\n    using MMtoM = function<MonoidType(MonoidType, MonoidType)>;\n    using OOtoO = function<OperatorType(OperatorType, OperatorType)>;\n    using MOtoM = function<MonoidType(MonoidType, OperatorType)>;\n    using OItoO = function<OperatorType(OperatorType, int)>;\n\n    // node, lazy, update flag (for lazy), identity element\n    int n;\n    vector<MonoidType> node;\n    vector<OperatorType> lazy;\n    vector<bool> need_update;\n    MonoidType E0;\n    OperatorType E1;\n\n    // update / combine / lazy / accumulate function\n    MOtoM upd_f;\n    MMtoM cmb_f;\n    OOtoO lzy_f;\n    OItoO acc_f;\n\n    void build(int m, vector<MonoidType> v = vector<MonoidType>()) {\n        if (v != vector<MonoidType>()) m = v.size();\n        n = 1;\n        while (n < m) n *= 2;\n\n        node = vector<MonoidType>(2 * n - 1, E0);\n        lazy = vector<OperatorType>(2 * n - 1, E1);\n        need_update = vector<bool>(2 * n - 1, false);\n        if (v != vector<MonoidType>()) {\n            for (int i = 0; i < m; i++) {\n                node[n - 1 + i] = v[i];\n            }\n            for (int i = n - 2; i >= 0; i--) {\n                node[i] = cmb_f(node[2 * i + 1], node[2 * i + 2]);\n            }\n        }\n    }\n\n    // initialize\n    LazySegmentTree() {}\n    LazySegmentTree(int n_, MonoidType E0_, OperatorType E1_, MOtoM upd_f_, MMtoM cmb_f_, OOtoO lzy_f_, OItoO acc_f_,\n                    vector<MonoidType> v = vector<MonoidType>())\n        : E0(E0_), E1(E1_), upd_f(upd_f_), cmb_f(cmb_f_), lzy_f(lzy_f_), acc_f(acc_f_) {\n        build(n_, v);\n    }\n\n    void eval(int k, int l, int r) {\n        if (!need_update[k]) return;\n        node[k] = upd_f(node[k], acc_f(lazy[k], r - l));\n        if (r - l > 1) {\n            lazy[2 * k + 1] = lzy_f(lazy[2 * k + 1], lazy[k]);\n            lazy[2 * k + 2] = lzy_f(lazy[2 * k + 2], lazy[k]);\n            need_update[2 * k + 1] = need_update[2 * k + 2] = true;\n        }\n        lazy[k] = E1;\n        need_update[k] = false;\n    }\n\n    void update(int a, int b, OperatorType x, int l, int r, int k) {\n        eval(k, l, r);\n        if (b <= l or r <= a) return;\n        if (a <= l and r <= b) {\n            lazy[k] = lzy_f(lazy[k], x);\n            need_update[k] = true;\n            eval(k, l, r);\n        } else {\n            int mid = (l + r) / 2;\n            update(a, b, x, l, mid, 2 * k + 1);\n            update(a, b, x, mid, r, 2 * k + 2);\n            node[k] = cmb_f(node[2 * k + 1], node[2 * k + 2]);\n        }\n    }\n\n    MonoidType query(int a, int b, int l, int r, int k) {\n        if (b <= l or r <= a) return E0;\n        eval(k, l, r);\n        if (a <= l and r <= b) return node[k];\n        int mid = (l + r) / 2;\n        MonoidType vl = query(a, b, l, mid, 2 * k + 1);\n        MonoidType vr = query(a, b, mid, r, 2 * k + 2);\n        return cmb_f(vl, vr);\n    }\n\n    // update [a, b)-th element (applied value, x)\n    void update(int a, int b, OperatorType x) { update(a, b, x, 0, n, 0); }\n\n    // range query for [a, b)\n    MonoidType query(int a, int b) { return query(a, b, 0, n, 0); }\n};\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    LazySegmentTree<LL, LL> seg(n, 0, 0, \n        [](LL a, LL b) { return b; },\n        [](LL a, LL b) { return a + b; },\n        [](LL a, LL b) { return b; }, \n        [](LL a, int x) { return a * x; });\n\n    REP(i, q) {\n        int c;\n        cin >> c;\n        if (c == 0) {\n            int s, t, x;\n            cin >> s >> t >> x;\n            seg.update(s, t + 1, x);\n        } else {\n            int s, t;\n            cin >> s >> t;\n            cout << seg.query(s, t + 1) << endl;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\n\ntemplate<typename T, typename E>\nclass SegTree{\nprivate:\n\tusing F = function<T(T, T)>;\n\tusing G = function<T(T, E)>;\n\tint32 n;\n\tF f;\n\tG g;\n\tT ti; // e0:F\n\tvector<T> node;\npublic:\n\tSegTree(int32 _n, F f, G g, T ti):f(f), g(g), ti(ti){\n\t\tinit(_n);\n\t}\n\tSegTree(vector<T> v, F f, G g, T ti):f(f), g(g), ti(ti){\n\t\tinit(v.size());\n\t\tfor(int32 i = 0;i < v.size();i++) node[i+n-1] = v[i];\n\t\tfor(int32 i = n-2;i >= 0;i--) merge(i);\n\t}\n\n\tinline void init(int32 _n){\n\t\tn = 1;\n\t\twhile(n < _n) n *= 2;\n\t\tnode.resize(2*n-1, ti);\n\t}\n\n\tinline void merge(int32 k){\n\t\tif(node[k*2+1] == ti) node[k] = node[k*2+2];\n\t\telse if(node[k*2+2] == ti) node[k] = node[k*2+1];\n\t\telse node[k] = f(node[k*2+1], node[k*2+2]);\n\t}\n\n\tvoid update(int32 k, E x){\n\t\tk += n-1;\n\t\tnode[k] = g(node[k], x);\n\t\twhile(k){\n\t\t\tk = (k-1)/2;\n\t\t\tmerge(k);\n\t\t}\n\t}\n\n\tT query(int32 a, int32 b, int32 k=0, int32 l=0, int32 r=-1){\n\t\tif(r < 0) r = n;\n\t\tif(b <= l || r <= a) return ti;\n\t\tif(a <= l && r <= b) return node[k];\n\t\treturn f(query(a, b, k*2+1, l, (l+r)/2), query(a, b, k*2+2, (l+r)/2, r));\n\t}\n};\n\ntemplate<typename T, typename E>\nclass LazySegTree{\nprivate:\n\tusing F = function<T(T, T)>;\n\tusing G = function<T(T, E)>;\n\tusing H = function<E(E, E)>;\n\tusing P = function<E(E, int32)>;\n\tint32 n;\n\tvector<T> node;\n\tvector<E> lazy;\n\tF f;\n\tG g;\n\tH h;\n\tP p;\n\tT ti;\n\tE ei;\npublic:\n\tLazySegTree(int32 _n, F f, G g, H h, T ti, E ei, P p = [](E a, int32 b){return a;}):f(f), g(g), h(h), p(p), ti(ti), ei(ei){\n\t\tinit(_n);\n\t}\n\n\tLazySegTree(vector<T> v, F f, G g, H h, T ti, E ei, P p = [](E a, int32 b){return a;}):f(f), g(g), h(h), p(p), ti(ti), ei(ei){\n\t\tinit(v.size());\n\t\tfor(int32 i = 0;i < v.size();i++) node[i+n-1] = v[i];\n\t\tfor(int32 i = n-2;i >= 0;i--) merge(i);\n\t}\n\n\tvoid init(int32 _n){\n\t\tn = 1;\n\t\twhile(n < _n) n*=2;\n\t\tnode.resize(2*n-1, ti);\n\t\tlazy.resize(2*n-1, ei);\n\t}\n\n\tinline void merge(int32 k){\n\t\tif(node[k*2+1] == ti) node[k] = node[k*2+2];\n\t\telse if(node[k*2+2] == ti) node[k] = node[k*2+1];\n\t\tnode[k] = f(node[k*2+2], node[k*2+1]);\n\t}\n\n\tinline void eval(int32 k, int32 l, int32 r){\n\t\tif(lazy[k] == ei) return;\n\t\tnode[k] = g(node[k], p(lazy[k], r-l));\n\t\tif(r-l > 1){\n\t\t\tlazy[k*2+1] = h(lazy[k*2+1], lazy[k]);\n\t\t\tlazy[k*2+2] = h(lazy[k*2+2], lazy[k]);\n\t\t}\n\t\tlazy[k] = ei;\n\t}\n\n\tT update(int32 a, int32 b, E x, int32 k=0, int32 l=0, int32 r=-1){\n\t\tif(r<0) r = n;\n\t\teval(k, l, r);\n\t\tif(b <= l || r <= a) return node[k];\n\t\tif(a <= l && r <= b){\n\t\t\tlazy[k] = h(lazy[k], x);\n\t\t\treturn g(node[k], p(lazy[k], r-l));\n\t}\n\t\treturn node[k] = f(update(a, b, x, k*2+1, l, (l+r)/2), update(a, b, x, k*2+2, (l+r)/2, r));\n\t}\n\n\tT query(int32 a, int32 b, int32 k=0, int32 l=0, int32 r=-1){\n\t\tif(r<0) r = n;\n\t\teval(k, l, r);\n\t\tif(b <= l || r <= a) return ti;\n\t\tif(a <= l && r <= b) return node[k];\n\t\treturn f(query(a, b, k*2+1, l, (l+r)/2), query(a, b, k*2+2, (l+r)/2, r));\n\t}\n};\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint32 n, q;\n\tcin >> n >> q;\n\tLazySegTree<int64, int64> sg(\n\t\tvector<int64>(n, 0)\n\t\t, [](int64 a, int64 b){return a+b;}\n\t\t, [](int64 a, int64 b){return b;}\n\t\t, [](int64 a, int64 b){return b;}\n\t\t, 0\n\t\t, 0\n\t\t, [](int64 a, int64 b){return a*b;});\n\tREP(i, q){\n\t\tint64 com, x, y;\n\t\tcin >> com >> x >> y;\n\t\tif(com == 0){\n\t\t\tint64 z;\n\t\t\tcin >> z;\n\t\t\tsg.update(x, y+1, z);\n\t\t}else{\n\t\t\tcout << sg.query(x, y+1) << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nclass SegmentTree {\nprivate:\n\tstd::vector<int64_t> sumContainer_, updateContainer_;\n\tint tree_width_;\n\n\tvoid lazyEvaluate(const int node_i)\n\t{\n\t\tif (updateContainer_[node_i] == LLONG_MAX) return;\n\t\tsumContainer_[node_i] = updateContainer_[node_i];\n\t\tif (node_i < tree_width_)\n\t\t{\n\t\t\tupdateContainer_[2 * node_i] = updateContainer_[node_i] >> 1;\n\t\t\tupdateContainer_[2 * node_i + 1] = updateContainer_[node_i] >> 1;\n\t\t}\n\t\tupdateContainer_[node_i] = LLONG_MAX;\n\t}\n\n\tvoid updateImplement(const int query_l, const int query_r, const int node_l, const int node_r, const int node_i, const int64_t assigned)\n\t{\n\t\tif (query_l <= node_l && node_r <= query_r)\n\t\t{\n\t\t\tupdateContainer_[node_i] = assigned;\n\t\t\tlazyEvaluate(node_i);\n\t\t\treturn;\n\t\t}\n\t\tlazyEvaluate(node_i);\n\t\tif (node_r <= query_l || query_r <= node_l) return;\n\t\tconst int node_m{(node_l + node_r) >> 1};\n\t\tupdateImplement(query_l, query_r, node_l, node_m, 2 * node_i, assigned >> 1);\n\t\tupdateImplement(query_l, query_r, node_m, node_r, 2 * node_i + 1, assigned >> 1);\n\t\tsumContainer_[node_i] = sumContainer_[2 * node_i] + sumContainer_[2 * node_i + 1];\n\t}\n\n\tint64_t findImplement(const int query_l, const int query_r, const int node_l, const int node_r, const int node_i)\n\t{\n\t\tif (node_r <= query_l || query_r <= node_l) return 0ll;\n\t\tlazyEvaluate(node_i);\n\t\tif (query_l <= node_l && node_r <= query_r) return sumContainer_[node_i];\n\t\tconst int node_m{(node_l + node_r) >> 1};\n\t\treturn findImplement(query_l, query_r, node_l, node_m, 2 * node_i) + findImplement(query_l, query_r, node_m, node_r, 2 * node_i + 1);\n\t}\npublic:\n\tSegmentTree(const int n)\n\t{\n\t\tint size{1};\n\t\twhile (size < n) size <<= 1;\n\t\ttree_width_ = size;\n\t\tsumContainer_.resize(2 * size);\n\t\tupdateContainer_.resize(2 * size);\n\t}\n\n\tvoid update(const int left, const int right, int64_t assigned)\n\t{\n\t\tupdateImplement(left, right, 0, tree_width_, 1, assigned * tree_width_);\n\t}\n\n\tint64_t find(const int left, const int right)\n\t{\n\t\treturn findImplement(left, right, 0, tree_width_, 1);\n\t}\n};\n\nint main()\n{\n\tint n, q;\n\tscanf(\"%d%d\", &n, &q);\n\tSegmentTree st(n);\n\tfor (int q_i{}; q_i < q; q_i++)\n\t{\n\t\tint query, s, t;\n\t\tscanf(\"%d%d%d\", &query, &s, &t);\n\t\tt++;\n\t\tif (query == 0)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tst.update(s, t, x);\n\t\t}\n\t\telse\n\t\t\tprintf(\"%lld\\n\", st.find(s, t));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<iostream>\n#include<functional>\n\nusing namespace std;\ntypedef long long ll;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\n// Mq : Monoid(query) , Mo : Monoid(output), (time, num)\n\ntemplate <typename Mq=ll, typename Mo=std::pair<ll, ll>> class DelayedSegmentTree {\n    public:\n    using Mqq_func = function<Mq(Mq, Mq)>;\n    using Mqo_func = function<Mq(Mq, Mo)>;\n    using Moo_func = function<Mo(Mo, Mo)>;\n    using Mp_func = function<Mo(Mo, ll)>;\n    ll size;\n    std::vector<Mq> segment;  // 1-indexed 葉ノードは size ~ 2*size-1\n    std::vector<Mo> laz;\n    ll time;\n    Mq Mq_id; Mo Mo_id;\n    Mqq_func Mqq_calc; Mqo_func Mqo_calc; Moo_func Moo_calc; Mp_func Mp_calc;\n\n    DelayedSegmentTree(\n                ll N, \n                Mq Mq_id = 0,\n                Mo Mo_id = std::make_pair(0, 0),\n                Mqq_func Mqq_calc = [](ll a, ll b){return a+b;},\n                Mqo_func Mqo_calc = [](ll a, std::pair<ll, ll> b){return a+b.second;},\n                Moo_func Moo_calc = [](std::pair<ll, ll> a, std::pair<ll, ll> b){return std::make_pair(std::max(a.first, b.first), a.second+b.second);},\n                Mp_func Mp_calc = [](std::pair<ll, ll> a, ll b){return std::make_pair(a.first, a.second*b);}) \n            : size(1), time(1), Mq_id(Mq_id), Mo_id(Mo_id), Mqq_calc(Mqq_calc), Mqo_calc(Mqo_calc), Moo_calc(Moo_calc), Mp_calc(Mp_calc) {\n        while(size < N) size <<= 1;\n        segment.assign(size*2, Mq_id);\n        laz.assign(size*2, Mo_id);\n    }\n\n    void build(){  // 全てのノードを再計算\n        for(ll k=size-1; k>0; k--) segment[k] = Mqq_calc(segment[k*2], segment[k*2+1]);\n    }    \n    void build(std::vector<Mq> v){\n        for(ll k=0; k<size; k++)segment[k+size]=v[k];\n        for(ll k=size-1; k>0; k--) segment[k] = Mqq_calc(segment[k*2], segment[k*2+1]);\n    }\n    void eval(ll len, ll node){\n        if(laz[node] == Mo_id) return;\n        if(node*2<size*2){\n            laz[node*2] = Moo_calc(laz[node*2], laz[node]);\n            laz[node*2+1] = Moo_calc(laz[node*2+1], laz[node]);\n        }\n        segment[node] = Mqo_calc(segment[node], Mp_calc(laz[node], len));\n        laz[node] = Mo_id;\n    }\n    Mq update(ll a, ll b, Mo x, ll node, ll l, ll r){\n        eval(r-l, node);\n        if(r <= a || b <= l) return segment[node]; // 範囲外\n        if(a <= l && r <= b){  // 包含\n            laz[node] = Moo_calc(laz[node], x);\n            return Mqo_calc(segment[node], Mp_calc(laz[node], r-l));\n        }\n        return segment[node] = Mqq_calc(update(a, b, x, node*2, l, (l+r)/2), update(a, b, x, node*2+1, (l+r)/2, r));\n    }\n    Mq update(ll a, ll b, Mo x){\n        time++;\n        return update(a,b,x,1,0,size);\n    }\n    Mq query(ll a, ll b, ll node, ll l, ll r){\n        eval(r-l, node);\n        if(r <= a || b <= l) return Mq_id;\n        if(a <= l && r <= b) return segment[node];\n        return Mqq_calc(query(a, b, node*2, l, (l+r)/2), query(a, b, node*2+1, (l+r)/2, r));\n    }\n    Mq query(ll a, ll b){ // [a, b)の演算結果\n        return query(a, b, 1, 0, size);\n    }\n\n    Mq operator[](const ll &k) const{\n        return segment[k+size];\n    }\n};\n\nint main(){\n    ll n,q, com, s, t, x;\n\n    cin >> n >> q;\n    DelayedSegmentTree<ll, std::pair<ll, ll>> dst(\n        n, 0, std::make_pair(0, 0),\n        [](ll a, ll b){return a+b;},\n        [](ll a, std::pair<ll, ll> b){return b.first>0 ? b.second : a;},\n        [](std::pair<ll, ll> a, std::pair<ll, ll> b){\n            return a.first>b.first ? std::make_pair(a.first, a.second) : std::make_pair(b.first, b.second);\n        },\n        [](std::pair<ll, ll> a, ll b){\n            return std::make_pair(a.first, a.second*b);\n        });\n    std::vector<ll> a; a.assign(dst.size, 0);\n    dst.build(a);\n    REP(i,q){\n        cin >> com;\n        if(com==0){\n            cin >> s >> t >> x;\n            dst.update(s, t+1, std::make_pair(dst.time, x));\n        }\n        else{\n            cin >> s >> t;\n            cout << dst.query(s,t+1) << endl;\n        }\n        //for(auto j : dst.segment) if(j==2147483647)cout<<\"x\"; else cout<<j;\n        //cout << \"###\" << endl;\n        //for(auto j : dst.laz) cout << j.first << \" \" << j.second << \"  \";\n        //cout << \"######\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<iomanip>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n#include <stdio.h>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <map>\n#include <list>\n#include <string>\n#include <numeric>\n#include <utility>\n#include <cfloat>\n#include <set>\n \nusing namespace std;\n \nint sqrtN = 512;\nstruct SqrtDecomposition{\n    int N, K;\n    vector <long long> data;\n    vector <long long> bucketUpdatedLazy;\n    vector <long long> bucketSum;\n     \n    SqrtDecomposition(int n){\n        N = n;\n        K = (N + sqrtN - 1) / sqrtN;\n        data.assign(N + sqrtN, 0);\n        bucketUpdatedLazy.assign(K, -1);\n        bucketSum.assign(K, 0);\n    }\n \n    void propagateLazy(int k){\n        if(bucketUpdatedLazy[k] < 0){\n            return;\n        }\n        for(int i = 0; i < sqrtN; i++){\n            data[k * sqrtN + i] = bucketUpdatedLazy[k];\n        }\n        bucketSum[k] = bucketUpdatedLazy[k] * sqrtN;\n        bucketUpdatedLazy[k] = -1;\n    }\n\n\n    long long get(int x){\n        propagateLazy(x / sqrtN);\n        return data[x];\n    }\n\n    long long getSum(int x, int y){\n        propagateLazy(x / sqrtN);\n        propagateLazy((y - 1) / sqrtN);\n        long long ans = 0;\n        if(y - x < sqrtN){\n            for(int i = x; i < y; i++){\n                ans += data[i];\n            }\n            return ans;\n        }\n        for(int i = x / sqrtN + 1; i < y / sqrtN; i++){\n            ans += bucketSum[i];\n        }\n\n        for(int i = x; i < (x / sqrtN + 1) * sqrtN; i++){\n            ans += data[i];\n        }\n        for(int i = y / sqrtN * sqrtN; i < y; i++){\n            ans += data[i];\n        }\n        return ans;\n    }\n \n    void update(int x, int y, long long a){\n        if(y - x < sqrtN){\n            propagateLazy(x / sqrtN);\n            propagateLazy((y - 1) / sqrtN);\n            for(int i = x; i < y; i++){\n                bucketSum[i/sqrtN] += (a - data[i]);\n                data[i] = a;\n            }\n            return;\n        }\n        for(int i = x / sqrtN + 1; i < y / sqrtN; i++){\n            bucketUpdatedLazy[i] = a;\n            bucketSum[i] = a * sqrtN;\n        }\n\n        propagateLazy(x / sqrtN);\n        for(int i = x; i < (x / sqrtN + 1) * sqrtN; i++){\n            bucketSum[i/sqrtN] += (a - data[i]);\n            data[i] = a;\n        }\n        propagateLazy((y - 1)/ sqrtN);\n        for(int i = y / sqrtN * sqrtN; i < y; i++){\n            bucketSum[i/sqrtN] += (a - data[i]);\n            data[i] = a;\n        }\n    }\n     \n};\n\n \nint main(){\n    int n;\n    int q;\n    cin >> n >> q;\n    SqrtDecomposition sq(n);\n    for(int i = 0; i < q; i++){\n        int com;\n        int s;\n        int t;\n        int x;\n        cin >> com;\n        if(com == 0){\n            cin >> s >> t >> x;\n            sq.update(s, t + 1, x);\n        } else {\n            cin >> s >> t;\n            cout << sq.getSum(s, t + 1) << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\nconst int INF = 1e9;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = { 0, 1, 0, -1 }, dx4 = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\n\n\ntemplate <typename T> class LazySegmentTree {\nprivate:\n    const int array_size;\n    int n;\n    std::vector<T> data, lazy;\n    std::vector<bool> lazyFlag;\n    function<T(T,T)> f; //要素に適用する演算\n    function<T(T,T)> g; //作用素の適用\n    function<T(T,T)> h; //作用素の合成\n    function<T(T,int)> p;\n    T unit;\n\npublic:\n    enum Mode {\n        RangeMinimumQuery,\n        RangeMaximumQuery,\n        RangeSummationQuery,\n    };\n\n    enum UpdateMode {\n        Update,\n        Add,\n    };\n\n    LazySegmentTree(const std::vector<LL> &v, Mode mode, UpdateMode updateMode) : array_size(v.size()) {\n        if (mode == RangeMinimumQuery) {\n            unit = INT_MAX;\n            f = [](T a, T b) { return std::min(a, b); };\n\n            if (updateMode == Update) {\n                g = [](T a, T b) { return b; };\n                h = g;\n                p = [](T a, int len) { return a; };\n            }\n            else if (updateMode == Add) {\n                g = [](T a, T b) { return a + b; };\n                h = g;\n                p = [](T a, int len) { return a; };\n            }\n        }\n        else if (mode == RangeMaximumQuery) {\n            unit = -INT_MAX;\n            f = [](T a, T b) { return std::max(a, b); };\n            if (updateMode == Update) {\n                g = [](T a, T b) { return b; };\n                h = g;\n                p = [](T a, int len) { return a; };\n            }\n            else if (updateMode == Add) {\n                g = [](T a, T b) { return a + b; };\n                h = g;\n                p = [](T a, int len) { return a; };\n            }\n        }\n        else if (mode == RangeSummationQuery) {\n            unit = 0;\n            f = [](T a, T b) { return a + b; };\n\n            if (updateMode == Update) {\n                g = [](T a, T b) { return b;};\n                h = g;\n                p = [](T a, int len) {return a * len;};\n            }\n            else if (updateMode == Add) {\n\n            }\n        }\n        else {\n            assert(false);\n        }\n\n        n = 1;\n        while (n < array_size) { n *= 2; }\n        data.resize(2 * n - 1, unit);\n        lazy.resize(2 * n - 1, 0);\n        lazyFlag.resize(2 * n - 1, false);\n\n        for (int i = 0; i < array_size; ++i) {\n            data[i + n - 1] = v[i];\n        }\n        for (int i = n - 2; i >= 0; i--) {\n            data[i] = f(data[i * 2 + 1], data[i * 2 + 2]);\n        }\n    }\n\n    // array[idx]\n    // log(N)\n    T access(int idx) {\n        return query(idx, idx + 1, 0, 0, n);\n    }\n\n    // array[idx] += x\n    // log(N)\n    void update(int idx, T x) {\n        update(idx, idx + 1, x);\n    }\n\n    // array[left, right) += x\n    // log(N)\n    void update(int left, int right, T x) {\n        assert(0 <= left and left < right and right <= array_size);\n        update(left, right, x, 0, 0, n);\n    }\n\n    // op(array[a, b))\n    // log(N)\n    T query(int left, int right) {\n        return query(left, right, 0, 0, n);\n    }\n\nprivate:\n    T update(int a, int b, T x, int k, int l, int r) {\n        propagate(k, r - l);\n\n        // 範囲外\n        if (b <= l or r <= a) {\n            return data[k];\n        }\n        // 完全に含む\n        else if (a <= l and r <= b) {\n            lazy[k] = h(lazy[k], x);\n            lazyFlag[k] = true;\n            propagate(k, r - l);\n            return g(data[k], p(lazy[k], r - l));\n        }\n        // 一部含む\n        else {\n            T lv = update(a, b, x, 2 * k + 1, l, (l + r) / 2);    // 左の子\n            T rv = update(a, b, x, 2 * k + 2, (l + r) / 2, r);    // 右の子\n            return data[k] = f(lv, rv);\n        }\n    }\n\n    // [a, b)の目的値をノードk（区間[l, r]）から検索\n    T query(int a, int b, int k, int l, int r) {\n        propagate(k, r - l);\n\n        // 範囲外\n        if (b <= l or r <= a) {\n            return unit;\n        }\n        // 完全に含む\n        else if (a <= l && r <= b) {\n            return data[k];\n        }\n        // 一部含む\n        else {\n            T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);    // 左の子\n            T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);    // 右の子\n            return f(vl, vr);\n        }\n    }\n\n    void propagate(const int k, const int len) {\n        if (not lazyFlag[k]) {\n            return;\n        }\n\n        if (len > 1) {\n            lazy[k * 2 + 1] = h(lazy[k * 2 + 1], lazy[k]);\n            lazyFlag[2 * k + 1] = true;\n            lazy[k * 2 + 2] = h(lazy[k * 2 + 2], lazy[k]);\n            lazyFlag[2 * k + 2] = true;\n        }\n        data[k] = g(data[k], p(lazy[k], len));\n        lazyFlag[k] = false;\n    }\n};\n\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, Q;\n    cin >> N >> Q;\n\n    vector<LL> v(N + 1, 0);\n\n    LazySegmentTree<LL> lst(v, LazySegmentTree<LL>::Mode::RangeSummationQuery, LazySegmentTree<LL>::UpdateMode::Update);\n\n    FOR(_, 0, Q) {\n        int query, s, t, x, i;\n        cin >> query;\n        if (query == 0) {\n            cin >> s >> t >> x;\n            lst.update(s, t + 1, x);\n        }\n        else {\n            cin >> s >> t;\n            print(lst.query(s, t + 1));\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <limits>\n#include <fstream>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\ntypedef long long ll;\nconst ll sqrtN = 512;\nstruct SqrtDecomposition {\n  ll N, K;\n  vector<ll> data;\n  vector<ll> bucketSum;\n  vector<ll> lazyUpdate;\n  SqrtDecomposition(ll n) : N(n) {\n    K = (N + sqrtN - 1) / sqrtN;\n    data.assign(K * sqrtN, 0);\n    bucketSum.assign(K, 0);\n    lazyUpdate.assign(K, 1111);\n  }\n  void eval(ll k) {\n    if (lazyUpdate[k] != 1111) {\n      for (ll i = k * sqrtN; i < (k + 1) * sqrtN; ++i) {\n        data[i] = lazyUpdate[k];\n      }\n      lazyUpdate[k] = 1111;\n    }\n  }\n  // [s, t)\n  void update(ll s, ll t, ll x) {\n    for (ll k = 0; k < K; ++k) {\n      ll l = k * sqrtN, r = (k + 1) * sqrtN;\n      if (r <= s || t <= l)\n        continue;\n      if (s <= l && r <= t) {\n        bucketSum[k] = x * sqrtN;\n        lazyUpdate[k] = x;\n      } else {\n        eval(k);\n        for (ll i = max(s, l); i < min(t, r); ++i) {\n          data[i] = x;\n        }\n        for (ll i = k * sqrtN; i < (k + 1) * sqrtN; ++i) {\n          bucketSum[k] = data[i];\n        }\n      }\n    }\n  }\n  // [s, t)\n  ll find(ll s, ll t) {\n    ll ans = 0;\n    for (ll k = 0; k < K; ++k) {\n      ll l = k * sqrtN, r = (k + 1) * sqrtN;\n      if (r <= s || t <= l)\n        continue;\n      if (s <= l && r <= t) {\n        ans += bucketSum[k];\n      } else {\n        eval(k);\n        for (ll i = max(s, l); i < min(t, r); ++i) {\n          ans += data[i];\n        }\n      }\n    }\n    return ans;\n  }\n};\n\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  ll n, q;\n  cin >> n >> q;\n  SqrtDecomposition sd(n);\n  FOR(i,0,q) {\n    ll f;\n    cin >> f;\n    if(f) {\n      ll s,t;\n      cin >> s >> t;\n      cout << sd.find(s, t+1) << endl;\n    } else {\n      ll s,t,x;\n      cin >> s >> t >> x;\n      sd.update(s,t+1,x);\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long int\n#define MOD(x) ((x % MOD_N) + MOD_N) % MOD_N\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define RFORE(i,a,b) for(int i=(b);i>=(a);--i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define RALL(c) (c).rbegin(),(c).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(c) (int)((c).size())\n#define EACH(i,v) for(auto i=v.begin();i!=v.end();++i)\n#define REACH(i,v) for(auto i=v.rbegin();i!=v.rend();++i)\n#define LB(c,x) distance((c).begin(),lower_bound(ALL(c),x))\n#define UB(c,x) distance((c).begin(),upper_bound(ALL(c),x))\n#define COUNT(c,x) (lower_bound(ALL(c),x)-upper_bound(ALL(c),x))\n#define UNIQUE(c) SORT(c); (c).erase(unique(ALL(c)),(c).end());\n#define COPY(c1,c2) copy(ALL(c1),(c2).begin())\n#define EXIST(s,e) (bool)((s).find(e)!=(s).end())\n#define PB push_back\n#define MP make_pair\n#define DUMP(x)  cerr<<#x<<\" = \"<<(x)<<endl;\n#define NL cerr<<endl;\nusing namespace std;\ntemplate<typename T,typename U> using P=pair<T,U>;\ntemplate<typename T> using V=vector<T>;\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T sum(vector<T>&v){return accumulate(ALL(v),T());}\ntemplate<typename T>T sum(vector<T>&v,int a,int b){return accumulate(v.begin()+a,v.begin()+b,T());}\ntemplate<typename T>T max(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T min(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T max_index(vector<T>&v){return distance((v).begin(),max_element(ALL(v)));}\ntemplate<typename T>T min_index(vector<T>&v){return distance((v).begin(),min_element(ALL(v)));}\n\nstruct edge { int to, cost; };\n\ntemplate<typename T>auto&operator<<(ostream&s,const vector<T>&v){s<<\"[\";bool a=1;for(auto e:v){s<<(a?\"\":\" \")<<e;a=0;}s<<\"]\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const pair<T,U>&p){s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return s;}\ntemplate<typename T>auto&operator<<(ostream&s,const set<T>&st){s<<\"{\";bool a=1;for(auto e:st){s<<(a?\"\":\" \")<<e;a=0;}s<<\"}\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const map<T,U>&m){s<<\"{\";bool a=1;for(auto e:m){s<<(a?\"\":\" \")<<e.first<<\":\"<<e.second;a=0;}s<<\"}\";return s;}\n\nconst int INF = 1e18;\nconst int MOD_N = 1e9+7;\n\ntemplate< typename Monoid, typename OperatorMonoid = Monoid >\nstruct LazySegmentTree {\n   using F = function< Monoid(Monoid, Monoid) >;\n   using G = function< Monoid(Monoid, OperatorMonoid, int) >;\n   using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n   int sz;\n   vector< Monoid > data;\n   vector< OperatorMonoid > lazy;\n   const F f;\n   const G g;\n   const H h;\n   const Monoid M1;\n   const OperatorMonoid OM0;\n   LazySegmentTree(int n, const F f, const G g, const H h,\n                   const Monoid &M1, const OperatorMonoid OM0)\n         : f(f), g(g), h(h), M1(M1), OM0(OM0) {\n      sz = 1;\n      while(sz < n) sz <<= 1;\n      data.assign(2 * sz, M1);\n      lazy.assign(2 * sz, OM0);\n   }\n\n   void set(int k, const Monoid &x) {\n      data[k + sz] = x;\n   }\n   void build() {\n      for(int k = sz - 1; k > 0; k--) {\n         data[k] = f(data[2 * k + 0], data[2 * k + 1]);\n      }\n   }\n   void propagate(int k, int len) {\n      if(lazy[k] != OM0) {\n         if(k < sz) {\n            lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n            lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n         }\n         data[k] = g(data[k], lazy[k], len);\n         lazy[k] = OM0;\n      }\n   }\n   Monoid update(int a, int b, const OperatorMonoid &x, int k, int l, int r) {\n      propagate(k, r - l);\n      if(r <= a || b <= l) {\n         return data[k];\n      } else if(a <= l && r <= b) {\n         lazy[k] = h(lazy[k], x);\n         propagate(k, r - l);\n         return data[k];\n      } else {\n         return data[k] = f(update(a, b, x, 2 * k + 0, l, (l + r) >> 1),\n                            update(a, b, x, 2 * k + 1, (l + r) >> 1, r));\n      }\n   }\n   Monoid update(int a, int b, const OperatorMonoid &x) {\n      return update(a, b, x, 1, 0, sz);\n   }\n   Monoid query(int a, int b, int k, int l, int r) {\n      propagate(k, r - l);\n      if(r <= a || b <= l) {\n         return M1;\n      } else if(a <= l && r <= b) {\n         return data[k];\n      } else {\n         return f(query(a, b, 2 * k + 0, l, (l + r) >> 1),\n                  query(a, b, 2 * k + 1, (l + r) >> 1, r));\n      }\n   }\n   Monoid query(int a, int b) {\n      return query(a, b, 1, 0, sz);\n   }\n   Monoid operator[](const int &k) {\n      return query(k, k + 1);\n   }\n};\ntemplate<typename T> struct RSQ_RUQ {\n   LazySegmentTree<T> lsegt;\n   RSQ_RUQ(int n) : lsegt(n,\n      [](T a,T b){ return a + b; },\n      [](T a,T b,T c){ return b * c; },\n      [](T a,T b){ return b; }, 0, INF){}\n   void update(int a, int b, T x) { lsegt.update(a, b, x); }\n   T query(int a, int b) { lsegt.query(a, b); }\n};\n\nsigned main()\n{\n   int n, q; cin >> n >> q;\n   V<int> c(q), s(q), t(q), x(q);\n   REP(i, q) {\n      cin >> c[i];\n      if (c[i] == 0) {\n         cin >> s[i] >> t[i] >> x[i];\n      } else {\n         cin >> s[i] >> t[i];\n      }\n   }\n   LazySegmentTree<int> lsegt(n,\n         [](int a,int b){ return a + b; },\n         [](int a,int b,int c){ return b * c; },\n         [](int a,int b){ return b; }, 0, INF);\n   RSQ_RUQ<int> rsqruq(n);\n   REP(i, q) {\n      if (c[i] == 0) {\n         lsegt.update(s[i], t[i]+1, x[i]);\n      } else {\n         cout << lsegt.query(s[i], t[i]+1) << endl;\n      }\n   }\n\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef long long ll;\n\nenum SegtreeType{\n\tCUSTOM,\n\tRAQ_RMQ,\n\tRAQ_RSQ,\n\tRUQ_RMQ,\n\tRUQ_RSQ,\n\tRMQ_RMQ\n};\ntemplate<SegtreeType ty,class T>\nclass LazySegtree{\n\tint n;\n\tvector<T>dat,lazy;\n\tT INIT;\n\tT E0,E1;\n\tfunction<T(T,T,int)>F0;\n\tfunction<T(T,T)>F1,F2;\npublic:\n\tLazySegtree(int n_,T INIT,T E0,T E1\n\t,function<T(T,T,int)>F0,function<T(T,T)>F1,function<T(T,T)>F2):\n\t\tINIT(INIT),E0(E0),E1(E1),F0(F0),F1(F1),F2(F2){\n\t\tn=1;while(n<n_)n<<=1;\n\t\tdat=lazy=vector<T>(2*n);\n\t\tfor(int i=0;i<2*n-1;i++){\n\t\t\tdat[i]=INIT;\n\t\t\tlazy[i]=E1;\n\t\t}\n\t}\n\tLazySegtree(int n_){\n\t\tswitch(ty){\n\t\tcase RAQ_RMQ:\n\t\t\tINIT=0;\n\t\t\tE0=numeric_limits<T>::max();\n\t\t\tE1=0;\n\t\t\tF0=[](T a,T b,int s){return a+b;};\n\t\t\tF1=[](T a,T b){return a+b;};\n\t\t\tF2=[](T a,T b){return min(a,b);};\n\t\t\tbreak;\n\t\tcase RAQ_RSQ:\n\t\t\tINIT=0;\n\t\t\tE0=0;\n\t\t\tE1=0;\n\t\t\tF0=[](T a,T b,int s){return a+b*s;};\n\t\t\tF1=[](T a,T b){return a+b;};\n\t\t\tF2=[](T a,T b){return a+b;};\n\t\t\tbreak;\n\t\tcase RUQ_RMQ:\n\t\t\tINIT=numeric_limits<T>::max();\n\t\t\tE0=numeric_limits<T>::max();\n\t\t\tE1=numeric_limits<T>::min();\n\t\t\tF0=[](T a,T b,int s){return b;};\n\t\t\tF1=[](T a,T b){return b;};\n\t\t\tF2=[](T a,T b){return min(a,b);};\n\t\t\tbreak;\n\t\tcase RUQ_RSQ:\n\t\t\tINIT=0;\n\t\t\tE0=0;\n\t\t\tE1=numeric_limits<T>::min();\n\t\t\tF0=[](T a,T b,int s){return b*s;};\n\t\t\tF1=[](T a,T b){return b;};\n\t\t\tF2=[](T a,T b){return a+b;};\n\t\t\tbreak;\n\t\tcase RMQ_RMQ:\n\t\t\tINIT=numeric_limits<T>::max();\n\t\t\tE0=numeric_limits<T>::max();\n\t\t\tE1=numeric_limits<T>::max();\n\t\t\tF0=[](T a,T b,int s){return min(a,b);};\n\t\t\tF1=[](T a,T b){return min(a,b);};\n\t\t\tF2=[](T a,T b){return min(a,b);};\n\t\t\tbreak;\n\t\t}\n\t\tn=1;while(n<n_)n<<=1;\n\t\tdat=lazy=vector<T>(2*n);\n\t\tfor(int i=0;i<2*n-1;i++){\n\t\t\tdat[i]=INIT;\n\t\t\tlazy[i]=E1;\n\t\t}\n\t}\n\tinline void push(int k,int s){\n\t\tif(lazy[k]==E1)return;\n\t\tdat[k]=F0(dat[k],lazy[k],s);\n\t\tif(k<n-1){\n\t\t\tlazy[k*2+1]=F1(lazy[k*2+1],lazy[k]);\n\t\t\tlazy[k*2+2]=F1(lazy[k*2+2],lazy[k]);\n\t\t}\n\t\tlazy[k]=E1;\n\t}\n\tinline void upnode(int k){\n\t\tdat[k]=F2(dat[k*2+1],dat[k*2+2]);\n\t}\n\tinline void update(int a,int b,T x,int k,int l,int r){\n\t\tpush(k,r-l);\n\t\tif(r<=a||b<=l)return;\n\t\tif(a<=l&&r<=b){\n\t\t\tlazy[k]=F1(lazy[k],x);\n\t\t\tpush(k,r-l);\n\t\t\treturn;\n\t\t}\n\t\tupdate(a,b,x,k*2+1,l,(l+r)/2);\n\t\tupdate(a,b,x,k*2+2,(l+r)/2,r);\n\t\tupnode(k);\n\t}\n\tinline T query(int a,int b,int k,int l,int r){\n\t\tpush(k,r-l);\n\t\tif(b<=l||r<=a)return E0;\n\t\tif(a<=l&&r<=b)return dat[k];\n\t\tT lb=query(a,b,k*2+1,l,(l+r)/2);\n\t\tT rb=query(a,b,k*2+2,(l+r)/2,r);\n\t\tupnode(k);\n\t\treturn F2(lb,rb);\n\t}\n\tinline void update(int a,int b,T x){\n\t\tupdate(a,b,x,0,0,n);\n\t}\n\tinline void update(int a,T x){\n\t\tupdate(a,a+1,x);\n\t}\n\tinline T query(int a,int b){\n\t\treturn query(a,b,0,0,n);\n\t}\n\tinline T query(int a){\n\t\treturn query(a,a+1);\n\t}\n};\n\nint main(){\n\tint n,q;cin>>n>>q;\n\tLazySegtree<RUQ_RSQ,int>seg(n);\n\trep(i,q){\n\t\tint ty;scanf(\"%d\",&ty);\n\t\tif(ty==0){\n\t\t\tint l,r,x;scanf(\"%d%d%d\",&l,&r,&x);r++;\n\t\t\tseg.update(l,r,x);\n\t\t}\n\t\telse{\n\t\t\tint l,r;scanf(\"%d%d\",&l,&r);r++;\n\t\t\tprintf(\"%d\\n\",seg.query(l,r));\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#define _CRT_SECURE_NO_WARNINGS\n#include <array>\n#include <cstddef>\n#include <cstdint>\n#include <cstdio>\n#include <limits>\n#include <memory>\n#include <string>\n#include <type_traits>\n\ntemplate <class Integral> class Rirange;\n\ntemplate <class Integral = std::size_t> class irange {\npublic:\n\tusing value_type = Integral;\n\tusing reference = value_type &;\n\tusing const_reference = const value_type &;\n\tclass irangeitr {\n\t\tfriend irange;\n\t\tvalue_type i;\n\t\tirangeitr(const value_type x) noexcept : i(x) {}\n\n\tpublic:\n\t\tvoid operator++() noexcept { ++i; }\n\t\tvalue_type &operator*() noexcept { return i; }\n\t\tconst_reference operator*() const noexcept { return i; }\n\t\tbool operator!=(const irangeitr &x) const noexcept { return i < x.i; }\n\t};\n\nprivate:\n\tconst value_type f, l;\n\npublic:\n\tirange(const value_type first, const value_type last) noexcept\n\t\t: f(first), l(last) {}\n\tirangeitr begin() const noexcept { return irangeitr(f); }\n\tirangeitr end() const noexcept { return irangeitr(l); }\n\tRirange<value_type> rev() const noexcept {\n\t\treturn Rirange<value_type>(l - 1, f - 1);\n\t}\n};\ntemplate <class Integral = std::size_t> class Rirange {\npublic:\n\tusing value_type = Integral;\n\tusing reference = value_type &;\n\tusing const_reference = const value_type &;\n\tclass Rirangeitr {\n\t\tfriend Rirange;\n\t\tvalue_type i;\n\t\tRirangeitr(const value_type x) noexcept : i(x) {}\n\n\tpublic:\n\t\tvoid operator++() noexcept { --i; }\n\t\treference operator*() noexcept { return i; }\n\t\tconst_reference operator*() const noexcept { return i; }\n\t\tbool operator!=(const Rirangeitr &x) const noexcept {\n\t\t\treturn (!~x.i && ~i) || x.i < i;\n\t\t}\n\t};\n\nprivate:\n\tconst value_type f, l;\n\npublic:\n\tRirange(const value_type x, const value_type y) noexcept : f(x), l(y) {}\n\tRirangeitr begin() const noexcept { return Rirangeitr(f); }\n\tRirangeitr end() const noexcept { return Rirangeitr(l); }\n\tirange<value_type> rev() const noexcept {\n\t\treturn irange<value_type>(l + 1, f + 1);\n\t}\n};\n\ntemplate <class T> bool maxi(T &a, const T &b) {\n\tif (b < a)\n\t\treturn 0;\n\ta = b;\n\treturn 1;\n}\ntemplate <class T> bool mini(T &a, const T &b) {\n\tif (a < b)\n\t\treturn 0;\n\ta = b;\n\treturn 1;\n}\ntemplate <class T> bool smaxi(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T> bool smini(T &a, const T &b) {\n\tif (b < a) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nstruct customIO {\n\tint c;\n\tbool f;\n\tstd::array<int, 30> buf;\n\tconst std::array<int, 10> itoc;\n\tstd::array<std::uint_least8_t, 256> ctoi_base;\n\tconst std::uint_least8_t *const ctoi;\n\tvoid get_c() { c = fgetc(stdin); }\n\tvoid put_c(int x) { fputc(x, stdout); }\n\tbool vacant() { return c == ' ' || c == '\\n'; }\n\toperator int() { return 0; }\n\n\texplicit customIO()\n\t\t: itoc({ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' }),\n\t\tctoi(std::addressof(ctoi_base[-static_cast<std::int_fast16_t>(\n\t\t\tstd::numeric_limits<char>::min())])) {\n\t\tfor (std::uint_least8_t i = 0; i < 10; ++i)\n\t\t\tctoi_base[static_cast<int>(\"0123456789\"[i]) -\n\t\t\tstatic_cast<std::int_fast16_t>(\n\t\t\t\tstd::numeric_limits<char>::min())] = i;\n\t}\n\t// in\n\n\tvoid cueing() {\n\t\twhile (get_c(), vacant())\n\t\t\t;\n\t}\n\ttemplate <class T>\n\tauto operator>>(T &d) ->\n\t\ttypename std::enable_if<std::is_signed<T>::value, customIO &>::type {\n\t\td = 0;\n\t\tf = 0;\n\t\tcueing();\n\t\tif (c == '-')\n\t\t\tf = 1, get_c();\n\t\tdo\n\t\t\td = d * 10 + ctoi[c];\n\t\twhile (get_c(), !vacant());\n\t\tif (f)\n\t\t\td = -d;\n\t\treturn *this;\n\t}\n\ttemplate <class T>\n\tauto operator>>(T &d) ->\n\t\ttypename std::enable_if<!std::is_signed<T>::value, customIO &>::type {\n\t\td = 0;\n\t\tcueing();\n\t\tdo\n\t\t\td = d * 10 + ctoi[c];\n\t\twhile (get_c(), !vacant());\n\t\treturn *this;\n\t}\n\tcustomIO &operator>>(char &d) {\n\t\tcueing();\n\t\td = c;\n\t\treturn *this;\n\t}\n\tcustomIO &operator>>(double &d) {\n\t\tscanf(\"%lf\", &d);\n\t\treturn *this;\n\t}\n\tcustomIO &operator>>(std::string &d) {\n\t\td.clear();\n\t\tcueing();\n\t\tdo\n\t\t\td.push_back(c);\n\t\twhile (get_c(), !vacant());\n\t\treturn *this;\n\t}\n\ttemplate <class T> T input() {\n\t\tT d;\n\t\t*this >> d;\n\t\treturn d;\n\t}\n\n\t// out\n\n\ttemplate <class T>\n\tauto operator<<(T d) ->\n\t\ttypename std::enable_if<std::is_signed<T>::value, customIO &>::type {\n\t\tc = 0;\n\t\tf = 0;\n\t\tif (d < static_cast<T>(0))\n\t\t\tf = 1, d = -d;\n\t\twhile (d)\n\t\t\tbuf[c++] = itoc[d % 10], d /= 10;\n\t\tif (!c)\n\t\t\tbuf[c++] = itoc[0];\n\t\tif (f)\n\t\t\tput_c('-');\n\t\twhile (c--)\n\t\t\tput_c(buf[c]);\n\t\treturn *this;\n\t}\n\ttemplate <class T>\n\tauto operator<<(T d) ->\n\t\ttypename std::enable_if<!std::is_signed<T>::value, customIO &>::type {\n\t\tc = 0;\n\t\twhile (d)\n\t\t\tbuf[c++] = itoc[d % 10], d /= 10;\n\t\tif (!c)\n\t\t\tbuf[c++] = itoc[0];\n\t\twhile (c--)\n\t\t\tput_c(buf[c]);\n\t\treturn *this;\n\t}\n\tcustomIO &operator<<(char d) {\n\t\tput_c(d);\n\t\treturn *this;\n\t}\n\tcustomIO &operator<<(double d) {\n\t\tprintf(\"%f\", d);\n\t\treturn *this;\n\t}\n\tcustomIO &operator<<(const std::string &d) {\n\t\tfor (const auto e : d)\n\t\t\tput_c(e);\n\t\treturn *this;\n\t}\n\tcustomIO &operator<<(const char *d) {\n\t\twhile (*d != '\\0')\n\t\t\tput_c(*(d++));\n\t\treturn *this;\n\t}\n\tvoid endl() { put_c('\\n'); }\n\tvoid space() { put_c(' '); }\n} IO;\n\nusing int32 = std::int_fast32_t;\nusing int64 = std::int_fast64_t;\nusing uint32 = std::uint_fast32_t;\nusing uint64 = std::uint_fast64_t;\nusing intl32 = std::int_least32_t;\nusing intl64 = std::int_least64_t;\nusing uintl32 = std::uint_least32_t;\nusing uintl64 = std::uint_least64_t;\n#include <cassert>\n#include <functional>\n#include <utility>\n#include <vector>\n\ntemplate <typename ValueMonoid, typename OperatorMonoid, class Modify>\nclass LazySegmentTree {\npublic:\n\tusing value_type = ValueMonoid;\n\tusing reference = value_type &;\n\tusing const_reference = const value_type &;\n\tusing operator_type = OperatorMonoid;\n\nprivate:\n\tusing container_type = std::vector<std::pair<value_type, operator_type>>;\n\npublic:\n\tusing size_type = typename container_type::size_type;\n\nprivate:\n\tconst Modify m;\n\tconst size_type size_, height, capacity;\n\tcontainer_type tree;\n\tstatic size_type getheight(const size_type &size) noexcept {\n\t\tsize_type ret = 0;\n\t\twhile (static_cast<size_type>(1) << ret < size)\n\t\t\t++ret;\n\t\treturn ret;\n\t}\n\tvalue_type reflect(const size_type &index) {\n\t\treturn m(tree[index].first, tree[index].second);\n\t}\n\tvoid recalc(const size_type &index) {\n\t\ttree[index].first = reflect(index << 1) + reflect(index << 1 | 1);\n\t}\n\tvoid assign(const size_type &index, const operator_type &data) {\n\t\ttree[index].second = tree[index].second + data;\n\t}\n\tvoid push(const size_type &index) {\n\t\tassign(index << 1, tree[index].second);\n\t\tassign(index << 1 | 1, tree[index].second);\n\t\ttree[index].second = operator_type();\n\t}\n\tvoid propagate(const size_type &index) {\n\t\tfor (size_type i = height; i; --i)\n\t\t\tpush(index >> i);\n\t}\n\tvoid thrust(const size_type &index) {\n\t\ttree[index].first = reflect(index);\n\t\tpush(index);\n\t}\n\tvoid evaluate(const size_type &index) {\n\t\tfor (size_type i = height; i; --i)\n\t\t\tthrust(index >> i);\n\t}\n\tvoid build(size_type index) {\n\t\twhile (index >>= 1)\n\t\t\trecalc(index);\n\t}\n\npublic:\n\texplicit LazySegmentTree(const size_type &size, const Modify &m = Modify())\n\t\t: m(m), size_(size), height(getheight(size_)),\n\t\tcapacity(static_cast<size_type>(1) << height), tree(capacity << 1) {}\n\tvoid update(size_type begin, size_type end, const operator_type &data) {\n\t\tassert(begin <= end);\n\t\tassert(begin <= size());\n\t\tassert(end <= size());\n\t\tbegin += capacity;\n\t\tend += capacity;\n\t\tpropagate(begin);\n\t\tpropagate(end - 1);\n\t\tfor (size_type left = begin, right = end; left < right;\n\t\t\tleft >>= 1, right >>= 1) {\n\t\t\tif (left & 1)\n\t\t\t\tassign(left++, data);\n\t\t\tif (right & 1)\n\t\t\t\tassign(right - 1, data);\n\t\t}\n\t\tbuild(begin);\n\t\tbuild(end - 1);\n\t}\n\tvoid update(size_type index,\n\t\tconst std::function<value_type(const_reference)> &f) {\n\t\tassert(index < size());\n\t\tindex += capacity;\n\t\tpropagate(index);\n\t\ttree[index].first = f(reflect(index));\n\t\ttree[index].second = operator_type();\n\t\tbuild(index);\n\t}\n\tvoid update(const size_type index, const_reference data) {\n\t\tassert(index < size());\n\t\tupdate(index, [&data](const_reference d) { return data; });\n\t}\n\tvalue_type range(size_type begin, size_type end) {\n\t\tassert(begin <= end);\n\t\tassert(begin <= size());\n\t\tassert(end <= size());\n\t\tbegin += capacity;\n\t\tend += capacity;\n\t\tevaluate(begin);\n\t\tevaluate(end - 1);\n\t\tvalue_type retL, retR;\n\t\tfor (; begin < end; begin >>= 1, end >>= 1) {\n\t\t\tif (begin & 1)\n\t\t\t\tretL = retL + reflect(begin++);\n\t\t\tif (end & 1)\n\t\t\t\tretR = reflect(end - 1) + retR;\n\t\t}\n\t\treturn retL + retR;\n\t}\n\tsize_type search(const std::function<bool(const_reference)> &b) {\n\t\tif (b(value_type()))\n\t\t\treturn 0;\n\t\tif (!b(reflect(1)))\n\t\t\treturn size() + 1;\n\t\tvalue_type acc;\n\t\tsize_type i = 1;\n\t\twhile (i < capacity) {\n\t\t\tthrust(i);\n\t\t\tif (!b(acc + reflect(i <<= 1)))\n\t\t\t\tacc = acc + reflect(i++);\n\t\t}\n\t\treturn i - capacity + 1;\n\t}\n\tconst_reference operator[](size_type index) {\n\t\tassert(index < size());\n\t\tindex += capacity;\n\t\tevaluate(index);\n\t\ttree[index].first = reflect(index);\n\t\ttree[index].second = operator_type();\n\t\treturn tree[index].first;\n\t}\n\tsize_type size() const noexcept { return size_; }\n\tbool empty() const noexcept { return !size_; }\n};\n\ntemplate <typename V, typename O, class F>\nLazySegmentTree<V, O, F>\nmake_Lazy(const typename LazySegmentTree<V, O, F>::size_type &size,\n\tconst F &f) {\n\treturn LazySegmentTree<V, O, F>(size, f);\n}\n#include <algorithm>\n#include <cstddef>\n#include <limits>\n#include <utility>\n\ntemplate <class T> struct Ass {\n\tusing value_type = T;\n\tvalue_type a;\n\tbool f;\n\tAss() : f(0) {}\n\texplicit Ass(const value_type &x) : a(x), f(1) {}\n\texplicit Ass(value_type &&x) : a(std::move(x)), f(1) {}\n\tAss operator+(const Ass &o) const { return o.f ? o : *this; }\n};\n\ntemplate <class T> struct Add {\n\tusing value_type = T;\n\tvalue_type a;\n\tAdd() : a(0) {}\n\texplicit Add(const value_type &x) : a(x) {}\n\texplicit Add(value_type &&x) : a(std::move(x)) {}\n\tAdd operator+(const Add &o) const { return Add(a + o.a); }\n};\n\ntemplate <class T> struct Mini {\n\tusing value_type = T;\n\tvalue_type a;\n\tMini() : a(std::numeric_limits<value_type>::max()) {}\n\texplicit Mini(const value_type &x) : a(x) {}\n\texplicit Mini(value_type &&x) : a(std::move(x)) {}\n\tMini operator+(const Mini &o) const { return Mini(std::min(a, o.a)); }\n\tMini operator*(const Ass<value_type> &o) const {\n\t\treturn o.f ? Mini(o.a) : *this;\n\t}\n\tMini operator*(const Add<value_type> &o) const { return Mini(a + o.a); }\n};\n\ntemplate <class T> struct Maxi {\n\tusing value_type = T;\n\tvalue_type a;\n\tMaxi() : a(std::numeric_limits<value_type>::min()) {}\n\texplicit Maxi(const value_type &x) : a(x) {}\n\texplicit Maxi(value_type &&x) : a(std::move(x)) {}\n\tMaxi operator+(const Maxi &o) const { return Maxi(std::max(a, o.a)); }\n\tMaxi operator*(const Ass<value_type> &o) const {\n\t\treturn o.f ? Maxi(o.a) : *this;\n\t}\n\tMaxi operator*(const Add<value_type> &o) const { return Maxi(a + o.a); }\n};\n\ntemplate <class T> struct Sum {\n\tusing value_type = T;\n\tusing size_type = std::size_t;\n\tvalue_type a;\n\tsize_type s;\n\tSum() : a(0), s(1) {}\n\texplicit Sum(const value_type &x, const size_type y) : a(x), s(y) {}\n\texplicit Sum(value_type &&x, const size_type y) : a(std::move(x)), s(y) {}\n\tSum operator+(const Sum &o) const { return Sum(a + o.a, s + o.s); }\n\tSum operator*(const Ass<value_type> &o) const {\n\t\treturn o.f ? Sum(o.a * s, s) : *this;\n\t}\n\tSum operator*(const Add<value_type> &o) const { return Sum(a + o.a * s, s); }\n};\n\ntemplate<class T,class U>\nstruct multi {\n\tT operator()(const T &x, const U &y)const {\n\t\treturn x*y;\n\t}\n};\nint main() {\n\tusing S = Sum<int64>;\n\tusing A = Ass<int64>;\n\tconst auto n = IO.input<uint32>();\n\tuint32 q;\n\tIO >> q;\n\tLazySegmentTree<S, A, multi<S, A>> T(n);\n\tuint32 c, s, t;\n\tint64 x;\n\twhile (q--) {\n\t\tIO >> c >> s >> t;\n\t\tif (c)\n\t\t\tIO << T.range(s, t + 1).a << '\\n';\n\t\telse\n\t\t\tIO >> x, T.update(s, t + 1, A(x));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// AOJ DSL_2_I Range Update and Sum\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <iostream>\n#include <tuple>\n#include <vector>\nusing namespace std;\nusing ll = long long;\n\nstruct Seg {\n  ll vv(ll value1, ll value2) { return value1 + value2; } // add\n  ll pp(ll oldpending, ll newpending) {                   // set\n    return newpending;\n  }\n  // set, accounting for the size of the interval\n  ll vp(int i, ll oldvalue, ll newpending) {\n    int l, r;\n    tie(l, r) = Endpoints(i);\n    return (r - l) * newpending;\n  }\n\n  vector<ll> A;\n  vector<bool> flag;\n  vector<ll> pending;\n  int n;\n\n  // Endpoints returns the (closed) endpoints of the interval owned by the\n  // node with array index `i`\n  pair<int, int> Endpoints(int i) {\n    int depth = static_cast<int>(floor(log2(i)));\n    // 2^d nodes with depth d\n    int per_node_in_row = n >> depth;\n    int l = 1 + (i - (1 << depth)) * per_node_in_row;\n    int r = l + per_node_in_row;\n    return {l, r};\n  }\n\n  // ContainedIn returns whether the node with array index `i`'s interval\n  // is contained in the interval [s, t)\n  bool ContainedIn(int i, int s, int t) {\n    int l, r;\n    tie(l, r) = Endpoints(i);\n    return (s <= l and t >= r);\n  }\n\n  // Intersects returns whether the node with array index `i`'s interval\n  // intersects with the interval [s, t)\n  bool Intersects(int i, int s, int t) {\n    if (s == t) // empty\n      return false;\n    int l, r;\n    tie(l, r) = Endpoints(i);\n    return (l >= s and l < t) or (s >= l and s < r);\n  }\n\n  void Propagate(int i) {\n    if (!flag[i])\n      return;\n    flag[i] = false;\n    A[i] = vp(i, A[i], pending[i]);\n    if (i < n) { // internal node\n      if (flag[2 * i]) {\n        pending[2 * i] = pp(pending[2 * i], pending[i]);\n      } else {\n        pending[2 * i] = pending[i];\n        flag[2 * i] = true;\n      }\n      if (flag[2 * i + 1]) {\n        pending[2 * i + 1] = pp(pending[2 * i + 1], pending[i]);\n      } else {\n        pending[2 * i + 1] = pending[i];\n        flag[2 * i + 1] = true;\n      }\n    }\n  }\n\n  ll Get(int i, int s, int t) { // open interval [s, t)\n    Propagate(i);\n    if (ContainedIn(i, s, t))\n      return A[i];\n    if (Intersects(2 * i, s, t) and Intersects(2 * i + 1, s, t))\n      return vv(Get(2 * i, s, t), Get(2 * i + 1, s, t));\n    if (Intersects(2 * i, s, t))\n      return Get(2 * i, s, t);\n    if (Intersects(2 * i + 1, s, t))\n      return Get(2 * i + 1, s, t);\n  }\n\n  void Modify(int i, int s, int t, ll x) {\n    Propagate(i);\n    if (ContainedIn(i, s, t)) {\n      if (flag[i]) {\n        pending[i] = pp(pending[i], x);\n      } else {\n        pending[i] = x;\n        flag[i] = true;\n      }\n    } else if (i < n) { // internal node\n      if (Intersects(2 * i, s, t))\n        Modify(2 * i, s, t, x);\n      if (Intersects(2 * i + 1, s, t))\n        Modify(2 * i + 1, s, t, x);\n      Propagate(2 * i);\n      Propagate(2 * i + 1);\n      A[i] = vv(A[2 * i], A[2 * i + 1]);\n    }\n  }\n\n  Seg(int n, ll default_value)\n      : n(n), pending(2 * n), A(2 * n, default_value), flag(2 * n) {\n    for (int i = n - 1; i > 0; --i)\n      A[i] = vv(A[2 * i], A[2 * i + 1]);\n  }\n};\n\nint main() {\n  // interface: 0-indexing, closed intervals\n  // internal: 1-indexing, open intervals\n  int n, q;\n  ll x;\n  cin >> n >> q;\n  Seg seg(1 << static_cast<int>(ceil(log2(n))), 0);\n  for (int c, s, t, i; cin >> c;) {\n    if (c == 0) { // add(s,t,x): each i=s,..,t set a[i]+=x\n      cin >> s >> t >> x;\n      seg.Modify(1, s + 1, t + 2, x);\n    }\n    if (c == 1) { // get(s,t): output sum(a[s],...,a[t])\n      cin >> s >> t;\n      cout << seg.Get(1, s + 1, t + 2) << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <climits>\nusing namespace std;\n\ntemplate <typename MonoidType, typename OperatorType>\nstruct LazySegmentTree {\n    using MMtoM = function< MonoidType(MonoidType, MonoidType) >;\n    using OOtoO = function< OperatorType(OperatorType, OperatorType) >;\n    using MOtoM = function< MonoidType(MonoidType, OperatorType) >;\n    using OItoO = function< OperatorType(OperatorType, int) >;\n\n    // node, lazy, update flag (for lazy), identity element\n    int n;\n    vector<MonoidType> node;\n    vector<OperatorType> lazy;\n    vector<bool> need_update;\n    MonoidType E0;\n    OperatorType E1;\n\n    // update / combine / lazy / accumulate function\n    OOtoO upd_f;\n    MMtoM cmb_f;\n    MOtoM lzy_f;\n    OItoO acc_f;\n\n    void build(int m, vector<MonoidType> v = vector<MonoidType>()) {\n        if(v != vector<MonoidType>()) m = v.size();\n        n = 1; while(n < m) n *= 2;\n\n        node = vector<MonoidType>(2*n-1, E0);\n        lazy = vector<OperatorType>(2*n-1, E1);\n        need_update = vector<bool>(2*n-1, false);\n        if(v != vector<MonoidType>()) {\n            for(int i=0; i<m; i++) {\n                node[n-1+i] = v[i];\n            }\n            for(int i=n-2; i>=0; i--) {\n                node[i] = cmb_f(node[2*i+1], node[2*i+2]);\n            }\n        }\n    }\n\n    // initialize\n    LazySegmentTree() {}\n    LazySegmentTree(int n_, MonoidType E0_, OperatorType E1_,\n                    OOtoO upd_f_, MMtoM cmb_f_, MOtoM lzy_f_, OItoO acc_f_,\n                    vector<MonoidType> v = vector<MonoidType>()) :\n        E0(E0_), E1(E1_),\n        upd_f(upd_f_), cmb_f(cmb_f_), lzy_f(lzy_f_), acc_f(acc_f_) {\n        build(n_, v);\n    }\n\n    void eval(int k, int l, int r) {\n        if(!need_update[k]) return;\n        node[k] = upd_f(node[k], acc_f(lazy[k], r - l));\n        if(r - l > 1) {\n            lazy[2*k+1] = lzy_f(lazy[2*k+1], lazy[k]);\n            lazy[2*k+2] = lzy_f(lazy[2*k+2], lazy[k]);\n            need_update[2*k+1] = need_update[2*k+2] = true;\n        }\n        lazy[k] = E1;\n        need_update[k] = false;\n    }\n\n    void update(int a, int b, OperatorType x, int l, int r, int k) {\n        eval(k, l, r);\n        if(b <= l or  r <= a) return;\n        if(a <= l and r <= b) {\n            lazy[k] = lzy_f(lazy[k], x);\n            need_update[k] = true;\n            eval(k, l, r);\n        }\n        else {\n            int mid = (l + r) / 2;\n            update(a, b, x, l, mid, 2*k+1);\n            update(a, b, x, mid, r, 2*k+2);\n            node[k] = cmb_f(node[2*k+1], node[2*k+2]);\n        }\n    }\n\n    MonoidType query(int a, int b, int l, int r, int k) {\n        if(b <= l or  r <= a) return E0;\n        eval(k, l, r);\n        if(a <= l and r <= b) return node[k];\n        int mid = (l + r) / 2;\n        MonoidType vl = query(a, b, l, mid, 2*k+1);\n        MonoidType vr = query(a, b, mid, r, 2*k+2);\n        return cmb_f(vl, vr);\n    }\n\n    // update [a, b)-th element (applied value, x)\n    void update(int a, int b, OperatorType x) {\n        update(a, b, x, 0, n, 0);\n    }\n\n    // range query for [a, b)\n    MonoidType query(int a, int b) {\n        return query(a, b, 0, n, 0);\n    }\n\n    void dump() {\n        fprintf(stderr, \"[lazy]\\n\");\n        for(int i=0; i<2*n-1; i++) {\n            if(i == n-1) fprintf(stderr, \"xxx \");\n            if(lazy[i] == E1) fprintf(stderr, \"  E \");\n            else fprintf(stderr, \"%3d \", lazy[i]);\n        }\n        fprintf(stderr, \"\\n\");\n\n        fprintf(stderr, \"[node]\\n\");\n        for(int i=0; i<2*n-1; i++) {\n            if(i == n-1) fprintf(stderr, \"xxx \");\n            if(node[i] == E0) fprintf(stderr, \"  E \");\n            else fprintf(stderr, \"%3d \", node[i]);\n        }\n        fprintf(stderr, \"\\n\");\n    }\n};\n\n\nvoid DSL_2_D() {\n    int N, Q; cin >> N >> Q;\n    LazySegmentTree<int, int> seg(N, INT_MAX, INT_MAX,\n                                  [](int a, int b) { return b;         },  // upd\n                                  [](int a, int b) { return min(a, b); },  // cmb\n                                  [](int a, int b) { return b;         },  // lzy\n                                  [](int a, int x) { return a;         }); // acc\n    \n    int indexed = 0;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s; cin >> s;\n            s -= indexed;\n            cout << seg.query(s, s+1) << endl;\n        }\n        // seg.dump();\n    }\n}\n\nvoid DSL_2_E() {\n    int N, Q; cin >> N >> Q;\n    LazySegmentTree<int, int> seg(N, 0, 0,\n                                  [](int a, int b) { return a + b; },  // upd\n                                  [](int a, int b) { return a + b; },  // cmb\n                                  [](int a, int b) { return a + b; },  // lzy\n                                  [](int a, int x) { return a * x; }); // acc\n    \n    int indexed = 1;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s; cin >> s;\n            s -= indexed;\n            cout << seg.query(s, s+1) << endl;\n        }\n        // seg.dump();\n    }    \n}\n\nvoid DSL_2_F() {\n    int N, Q; cin >> N >> Q;\n    LazySegmentTree<int, int> seg(N, INT_MAX, 0,\n                                  [](int a, int b) { return b;         },  // upd\n                                  [](int a, int b) { return min(a, b); },  // cmb\n                                  [](int a, int b) { return b;         },  // lzy\n                                  [](int a, int x) { return a;         }); // acc\n    \n    int indexed = 0;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s, t; cin >> s >> t; t++;\n            s -= indexed; t -= indexed;\n            cout << seg.query(s, t) << endl;\n        }\n        // seg.dump();\n    }    \n}\n\nvoid DSL_2_G() {\n    int N, Q; cin >> N >> Q;\n    using ll = long long int;\n    LazySegmentTree<ll, ll> seg(N, 0, 0,\n                                  [](ll a, ll  b) { return a + b; },  // upd\n                                  [](ll a, ll  b) { return a + b; },  // cmb\n                                  [](ll a, ll  b) { return a + b; },  // lzy\n                                  [](ll a, int x) { return a * x; }); // acc\n    \n    int indexed = 1;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s, t; cin >> s >> t; t++;\n            s -= indexed; t -= indexed;\n            cout << seg.query(s, t) << endl;\n        }\n        // seg.dump();\n    }    \n}\n\nvoid DSL_2_H() {\n    int N, Q; cin >> N >> Q;\n    using ll = long long int;\n    LazySegmentTree<ll, ll> seg(N, INT_MAX, 0,\n                                [](ll a, ll  b) { return a + b;     },  // upd\n                                [](ll a, ll  b) { return min(a, b); },  // cmb\n                                [](ll a, ll  b) { return a + b;     },  // lzy\n                                [](ll a, int x) { return a;         },  // acc\n                                vector<ll>(N));\n    \n    int indexed = 0;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s, t; cin >> s >> t; t++;\n            s -= indexed; t -= indexed;\n            cout << seg.query(s, t) << endl;\n        }\n        // seg.dump();\n    }    \n}\n\nvoid DSL_2_I() {\n    int N, Q; cin >> N >> Q;\n    using ll = long long int;\n    LazySegmentTree<ll, ll> seg(N, 0, 0,\n                                [](ll a, ll  b) { return b;     },  // upd\n                                [](ll a, ll  b) { return a + b; },  // cmb\n                                [](ll a, ll  b) { return b;     },  // lzy\n                                [](ll a, int x) { return a * x; },  // acc\n                                vector<ll>(N));\n    \n    int indexed = 0;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s, t; cin >> s >> t; t++;\n            s -= indexed; t -= indexed;\n            cout << seg.query(s, t) << endl;\n        }\n        // seg.dump();\n    }    \n}\n\nint main() {\n    // DSL_2_D();\n    // DSL_2_E();\n    // DSL_2_F();\n    // DSL_2_G();\n    // DSL_2_H();\n    DSL_2_I();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a) {\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n    out<<'[';\n    for(const T &i: a) out<<i<<',';\n    out<<']';\n    return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out, const set<T>& a) {\n    out<<'{';\n    for(const T &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\ntemplate<class T, class S>\nostream &operator <<(ostream& out, const map<T,S>& a) {\n    out<<'{';\n    for(auto &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\ntemplate <typename Monoid>\nstruct lazysegtree {\n    using T = typename Monoid::T;\n    using E = typename Monoid::E;\n    int n, height;\n    vector<T> dat;\n    vector<E> lazy;\n\n    lazysegtree() {}\n    lazysegtree(int n_) {\n        n = 1, height = 0;\n        while(n < n_) { n *= 2; height++; }\n        dat.assign(n*2, Monoid::dt());\n        lazy.assign(n*2, Monoid::de());\n    }\n    void build(vector<T> v) {\n        REP(i, v.size()) dat[i+n] = v[i];\n        for(int i=n-1; i>0; --i) dat[i] = Monoid::f(dat[i*2], dat[i*2+1]);\n    }\n\n    inline T reflect(int k) { return lazy[k]==Monoid::de()?dat[k]:Monoid::g(dat[k], lazy[k]); }\n    inline void eval(int k) {\n        if(lazy[k] == Monoid::de()) return;\n        lazy[2*k]   = Monoid::h(lazy[k*2],   lazy[k]);\n        lazy[2*k+1] = Monoid::h(lazy[k*2+1], lazy[k]);\n        dat[k] = reflect(k);\n        lazy[k] = Monoid::de();\n    }\n    inline void thrust(int k) { for(int i=height;i;--i) eval(k>>i); }\n    inline void recalc(int k) { while(k>>=1) dat[k] = Monoid::f(reflect(k*2), reflect(k*2+1)); }\n\n    void update(int a, int b, E x) {\n        thrust(a+=n);\n        thrust(b+=n-1);\n        for(int l=a, r=b+1; l<r; l>>=1,r>>=1) {\n            if(l&1) lazy[l] = Monoid::h(lazy[l], x), ++l;\n            if(r&1) --r, lazy[r] = Monoid::h(lazy[r], x);\n        }\n        recalc(a);\n        recalc(b);\n    }\n    T query(int a, int b) {\n        thrust(a+=n);\n        thrust(b+=n-1);\n        T vl=Monoid::dt(), vr=Monoid::dt();\n        for(int l=a, r=b+1; l<r; l>>=1,r>>=1) {\n            if(l&1) vl=Monoid::f(vl, reflect(l++));\n            if(r&1) vr=Monoid::f(reflect(--r), vr);\n        }\n        return Monoid::f(vl, vr);\n    }\n\n    friend ostream &operator <<(ostream& out,const lazysegtree<Monoid>& seg) {\n        out << \"---------------------\" << endl;\n        int cnt = 1;\n        for(int i=1; i<=seg.n; i*=2) {\n            REP(j, i) {\n                out << \"(\" << seg.dat[cnt] << \",\" << seg.lazy[cnt] << \") \";\n                cnt++;\n            }\n            out << endl;\n        }\n        out << \"---------------------\" << endl;\n        return out;\n    }\n};\n\nstruct update_min {\n    using T = ll;\n    using E = ll;\n    static constexpr T dt() { return INT_MAX; }\n    static constexpr E de() { return INT_MAX; }\n    static T f(const T &a, const T &b) { return min(a, b); }\n    static T g(const T &a, const E &b) { return b; }\n    static E h(const E &a, const E &b) { return b; }\n};\nstruct add_sum {\n    using T = PII;  // (頂点の値, 頂点の区間長)\n    using E = ll;\n    static constexpr T dt() { return PII(0,0); }\n    static constexpr E de() { return 0; }\n    static T f(const T &a, const T &b) { return PII(a.first+b.first, a.second+b.second); }\n    static T g(const T &a, const E &b) { return PII(a.first+b*a.second, a.second); }\n    static E h(const E &a, const E &b) { return a+b; }\n};\nstruct update_sum {\n    using T = PII;\n    using E = ll;\n    static constexpr T dt() { return PII(0, 0); }\n    static constexpr E de() { return LLINF; }\n    static T f(const T &a, const T &b) { return PII(a.first+b.first,a.second+b.second); }\n    static T g(const T &a, const E &b) { return PII(b*a.second, a.second); }\n    static E h(const E &a, const E &b) { return b; }\n};\nstruct add_min {\n    using T = PII;  // (頂点の値, 頂点の区間長)\n    using E = ll;\n    static constexpr T dt() { return PII(LLINF,0); }\n    static constexpr E de() { return 0; }\n    static T f(const T &a, const T &b) { return min(a, b); }\n    static T g(const T &a, const E &b) { return PII(a.first+(b==LLINF?0:b)*a.second, a.second); }\n    static E h(const E &a, const E &b) { return a+b; }\n};\nstruct xor_sum {\n    using T = PII;  // (頂点の値, 頂点の区間長)\n    using E = ll;\n    static constexpr T dt() { return PII(0,0); }\n    static constexpr E de() { return 0; }\n    static T f(const T &a, const T &b) { return PII(a.first+b.first, a.second+b.second); }\n    static T g(const T &a, const E &b) { return PII((b>=1?b-a.first:a.first)*a.second, a.second); }\n    static E h(const E &a, const E &b) { return a^b; }\n};\n// ToDo: 一次式を乗せるやつを書く\nstruct node {\n    ll sum, max, min, len;\n    node() : sum(0), max(-LLINF), min(LLINF), len(0) {}\n    node(ll a, ll b, ll c, ll d) : sum(a), max(b), min(c), len(d) {}\n};\nstruct linear_exp {\n    using T = node;\n    using E = PII;\n    static T dt() { return node(0, -LLINF, LLINF, 0); }\n    static constexpr E de() { return PII(LLINF, LLINF); }\n    static T f(const T &a, const T &b) {\n        node ret;\n        ret.sum = a.sum + b.sum;\n        ret.min = min(a.min, b.min);\n        ret.max = max(a.max, b.max);\n        ret.len = a.len + b.len;\n        return ret;\n    }\n    static T g(const T &a, E b) {\n        if(b.first == LLINF) b = PII(1, 0);\n        node ret;\n        ret.sum = (b.first*a.sum+b.second)*a.len;\n        ret.min = b.first*a.min+b.second;\n        ret.max = b.first*a.max+b.second;\n        ret.len = a.len;\n        return ret;\n    }\n    static E h(const E &a, const E &b) {\n        return PII(b.first*a.first, b.first*a.second+b.second);\n    }\n};\n\n// 点更新区間最小\nnamespace DSL2A {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        lazysegtree<update_min> seg(n);\n        while(q--) {\n            int c, x, y;\n            cin >> c >> x >> y;\n            if(c == 0) {\n                seg.update(x, x+1, y);\n            } else {\n                cout << seg.query(x, y+1) << endl;\n            }\n        }\n    }\n}\n\n// 点加算区間和\nnamespace DSL2B {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        lazysegtree<add_sum> seg(n);\n        seg.build(vector<PII>(n, PII(0,1)));\n        while(q--) {\n            int c, x, y;\n            cin >> c >> x >> y;\n            if(c == 0) {\n                x--;\n                seg.update(x, x+1, y);\n            } else {\n                x--, y--;\n                cout << seg.query(x, y+1).first << endl;\n            }\n        }\n    }\n}\n\n// 区間更新区間最小\nnamespace DSL2F {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        lazysegtree<update_min> seg(n);\n        while(q--) {\n            int c, s, t;\n            cin >> c >> s >> t;\n            if(c == 0) {\n                int x;\n                cin >> x;\n                seg.update(s, t + 1, x);\n            } else {\n                cout << seg.query(s, t + 1) << endl;\n            }\n        }\n    }\n}\n\n// 区間加算区間和\nnamespace DSL2G {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        lazysegtree<add_sum> seg(n);\n        seg.build(vector<PII>(n, PII(0,1)));\n        while(q--) {\n            int c, s, t;\n            cin >> c >> s >> t;\n            s--, t--;\n            if(c == 0) {\n                int x;\n                cin >> x;\n                seg.update(s, t + 1, x);\n            } else {\n                cout << seg.query(s, t + 1).first << endl;\n            }\n        }\n    }\n}\n\n// 区間加算区間最小\nnamespace DSL2H {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        lazysegtree<add_min> seg(n);\n        seg.build(vector<PII>(n, PII(0,1)));\n        while(q--) {\n            int c, s, t;\n            cin >> c >> s >> t;\n            if(c == 0) {\n                int x;\n                cin >> x;\n                seg.update(s, t+1, x);\n            } else {\n                cout << seg.query(s, t+1).first << endl;\n            }\n            REP(i, n) seg.query(i, i+1);\n            cout << seg << endl;\n        }\n    }\n}\n\n// 区間更新区間和\nnamespace DSL2I {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        lazysegtree<update_sum> seg(n);\n        seg.build(vector<PII>(n, PII(0, 1)));\n        while(q--) {\n            int c, s, t;\n            cin >> c >> s >> t;\n            if(c == 0) {\n                int x;\n                cin >> x;\n                seg.update(s, t+1, x);\n            } else {\n                cout << seg.query(s, t+1).first << endl;\n            }\n        }\n    }\n\n    void solve2() {\n        int n, q;\n        cin >> n >> q;\n\n        lazysegtree<linear_exp> seg(n);\n        seg.build(vector<node>(n, node(0, 0, 0, 1)));\n        while(q--) {\n            int c, s, t;\n            cin >> c >> s >> t;\n            if(c == 0) {\n                int x;\n                cin >> x;\n                seg.update(s, t+1, PII(0, x));\n            } else {\n                cout << seg.query(s, t+1).sum << endl;\n            }\n        }\n    }\n}\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    // DSL2A::solve();\n    // DSL2B::solve();\n    // DSL2F::solve();\n    // DSL2G::solve();\n    // DSL2H::solve();\n    // DSL2I::solve();\n    DSL2I::solve2();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n    out<<'['; for(T i: a) {out<<i<<',';} out<<']'; return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\ntemplate<class T, class E=T>\nstruct RBST {\n    using F = function<T(T,T)>;\n    using G = function<T(T,E)>;\n    using H = function<E(E,E)>;\n    using P = function<E(E,int)>;\n\n    const F f; const G g; const H h; const P p;\n    const T dt; const E de;\n\n    struct node {\n        node *l, *r;\n        T val, sum;\n        E lazy;\n        bool rev;\n        int sz;\n\n        node(T v, E p) : l(nullptr),r(nullptr),val(v),sum(v),lazy(p),rev(false),sz(1) {}\n    };\n\n    RBST(F f, T dt) :\n        f(f), g(G()), h(H()), p(P()), dt(dt), de(E()) {}\n    RBST(F f, G g, H h, P p, T dt, E de) :\n        f(f), g(g), h(h), p(p), dt(dt), de(de) {}\n\n    // 子を操作したあとに呼ぶ\n    node* fix(node* a) {\n        a->sz = size(a->l) + 1 + size(a->r);\n        a->sum = f(f(sum(a->l), a->val), sum(a->r));\n        return a;\n    }\n    // valとsumを操作したあとに呼ぶ\n    void eval(node* a) {\n        if(a->lazy != de) {\n            a->val = g(a->val, a->lazy);\n            a->sum = g(a->sum, p(a->lazy, a->sz));\n            if(a->l != nullptr) a->l->lazy = h(a->l->lazy, a->lazy);\n            if(a->r != nullptr) a->r->lazy = h(a->r->lazy, a->lazy);\n            a->lazy = de;\n        }\n        if(a->rev) {\n            std::swap(a->l, a->r);\n            if(a->l != nullptr) a->l->rev ^= 1;\n            if(a->r != nullptr) a->r->rev ^= 1;\n            a->rev = false;\n        }\n    }\n    T sum(node* a) { return a == nullptr ? dt : (eval(a), a->sum); }\n    int size(node* a) { return a == nullptr ? 0 : a->sz; }\n\n    inline int xor128() {\n        static int x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n        int t;\n        t = x ^ (x << 11); x = y; y = z; z = w;\n        return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n    }\n\n    node* merge(node* a, node* b) {\n        if(a == nullptr) return b;\n        if(b == nullptr) return a;\n        eval(a); eval(b);\n        if(xor128() % (size(a) + size(b)) < size(a)) {\n            a->r = merge(a->r, b);\n            return fix(a);\n        } else {\n            b->l = merge(a, b->l);\n            return fix(b);\n        }\n    }\n    // [0,k) [k,n)\n    pair<node*, node*> split(node* a, int k) {\n        if(a == nullptr) return pair<node*, node*>(nullptr, nullptr);\n        eval(a);\n        node *sl, *sr;\n        if(k <= size(a->l)) {\n            std::tie(sl, sr) = split(a->l, k);\n            a->l = sr;\n            return pair<node*, node*>(sl, fix(a));\n        } else {\n            std::tie(sl, sr) = split(a->r, k - size(a->l) - 1);\n            a->r = sl;\n            return pair<node*, node*>(fix(a), sr);\n        }\n    }\n    // 要素の挿入/削除\n    void insert(node*& a, int k, const T& x) {\n        node *sl, *sr;\n        std::tie(sl, sr) = split(a, k);\n        a = merge(sl, merge(new node(x, de), sr));\n    }\n    T erase(node*& a, int k) {\n        node *sl, *sr, *tl, *tr;\n        std::tie(sl, sr) = split(a, k + 1);\n        std::tie(tl, tr) = split(sl, k);\n        a = merge(tl, sr);\n        return tr->val;\n    }\n    // 点代入\n    void set_element(node*& a, int k, const T& x) {\n        node *sl, *sr, *tl, *tr;\n        std::tie(sl, sr) = split(a, k + 1);\n        std::tie(tl, tr) = split(sl, k);\n        if(tr != nullptr) tr->val = tr->sum = x;\n        a = merge(merge(tl, tr), sr);\n    }\n    // 区間更新\n    void update(node*& a, int l, int r, const E& m) {\n        node *sl, *sr, *tl, *tr;\n        std::tie(sl, sr) = split(a, r);\n        std::tie(tl, tr) = split(sl, l);\n        if(tr != nullptr) tr->lazy = h(tr->lazy, m);\n        a = merge(merge(tl, tr), sr);\n    }\n    // 点取得\n    T get(node*& a, int k) {\n        node *sl, *sr, *tl, *tr;\n        std::tie(sl, sr) = split(a, k + 1);\n        std::tie(tl, tr) = split(sl, k);\n        T res = tr == nullptr ? dt : tr->val;\n        a = merge(merge(tl, tr), sr);\n        return res;\n    }\n    // 区間クエリ\n    T query(node*& a, int l, int r) {\n        node *sl, *sr, *tl, *tr;\n        std::tie(sl, sr) = split(a, r);\n        std::tie(tl, tr) = split(sl, l);\n        T res = tr == nullptr ? dt : tr->sum;\n        a = merge(merge(tl, tr), sr);\n        return res;\n    }\n    // 区間[l,r)の反転\n    void reverse(node*& a, int l, int r) {\n        node *sl, *sr, *tl, *tr;\n        std::tie(sl, sr) = split(a, r);\n        std::tie(tl, tr) = split(sl, l);\n        if(tr != nullptr) tr->rev ^= 1;\n        a = merge(merge(tl, tr), sr);\n    }\n    // デバッグ用\n    void debug(node* t) {\n        if(t == nullptr) return;\n        cout << \"{\";\n        debug(t->l);\n        cout << \" \" << t->val << \" \";\n        debug(t->r);\n        cout << \"}\";\n    }\n    void dump(node *r, typename vector< T >::iterator &it) {\n        if(!r) return;\n        eval(r);\n        dump(r->l, it);\n        *it = r->val;\n        dump(r->r, ++it);\n    }\n    vector<T> dump(node *r) {\n        vector<T> v((size_t) size(r));\n        auto it = begin(v);\n        dump(r, it);\n        return v;\n    }\n};\n\ntemplate<class T>\nstruct OrderedMultiSet : RBST<T> {\n    using node = typename RBST<T>::node;\n\n    OrderedMultiSet() : RBST<T>([&](T x, T y) { return x; }, T()) {}\n\n    // k番目の要素を求める\n    T kth_element(node *t, int k) {\n        if(k < RBST<T>::size(t->l)) return kth_element(t->l, k);\n        if(k == RBST<T>::size(t->l)) return t->val;\n        return kth_element(t->r, k - RBST<T>::size(t->l) - 1);\n    }\n    // 要素xを追加する\n    virtual void insert_key(node *&t, const T &x) {\n        RBST<T>::insert(t, lower_bound(t, x), x);\n    }\n    // 要素xを消す\n    void erase_key(node *&t, const T &x) {\n        if(!count(t, x)) return;\n        RBST<T>::erase(t, lower_bound(t, x));\n    }\n    // xの個数\n    int count(node *t, const T &x) {\n        return upper_bound(t, x) - lower_bound(t, x);\n    }\n    // x以上の最小の位置\n    int lower_bound(node *t, const T &x) {\n        if(!t) return 0;\n        if(x <= t->val) return lower_bound(t->l, x);\n        return lower_bound(t->r, x) + RBST<T>::size(t->l) + 1;\n    }\n    // xより大きい最小の位置\n    int upper_bound(node *t, const T &x) {\n        if(!t) return 0;\n        if(x < t->val) return upper_bound(t->l, x);\n        return upper_bound(t->r, x) + RBST<T>::size(t->l) + 1;\n    }\n};\ntemplate<class T>\nstruct OrderedSet : OrderedMultiSet<T>  {\n    using SET = OrderedMultiSet<T>;\n    using RBST = typename SET::RBST;\n    using node = typename RBST::node;\n\n    OrderedSet(int sz) : OrderedMultiSet<T>(sz) {}\n\n    void insert_key(node *&t, const T &x) override {\n        if(SET::count(t, x)) return;\n        RBST::insert(t, SET::lower_bound(t, x), x);\n    }\n};\n\n// k-th element\nnamespace ARC033C {\n    void solve() {\n        ll q;\n        cin >> q;\n        OrderedMultiSet<ll> st;\n        OrderedMultiSet<ll>::RBST::node *root = nullptr;\n        while(q--) {\n            ll t, x;\n            cin >> t >> x;\n            if(t == 1) {\n                st.insert_key(root, x);\n            } else {\n                ll val = st.kth_element(root, x-1);\n                cout << val << endl;\n                st.erase_key(root, val);\n            }\n        }\n    }\n}\n\n// 点更新区間最小\nnamespace DSL2A {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        auto f = [](ll l, ll r) { return min(l, r); };\n        RBST<ll> tree(f, INT_MAX);\n\n        RBST<ll,ll>::node* root = nullptr;\n        for(int i = 0; i < n; i++) tree.insert(root, i, INT_MAX);\n        while(q--) {\n            int c, x, y;\n            cin >> c >> x >> y;\n            if(c == 0) {\n                tree.set_element(root, x, y);\n            } else {\n                cout << tree.query(root, x, y+1) << endl;\n            }\n        }\n    }\n}\n\n// 点加算区間和\nnamespace DSL2B {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        auto f = [](ll l, ll r) { return l+r; };\n        RBST<ll> tree(f, 0);\n\n        RBST<ll,ll>::node* root = nullptr;\n        for(int i = 0; i < n; i++) tree.insert(root, i, 0);\n        while(q--) {\n            int c, x, y;\n            cin >> c >> x >> y;\n            if(c == 0) {\n                x--;\n                tree.set_element(root, x, tree.get(root, x) + y);\n            } else {\n                x--, y--;\n                cout << tree.query(root, x, y+1) << endl;\n            }\n        }\n    }\n}\n\n// 区間更新区間最小\nnamespace DSL2F {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        auto f = [](ll l, ll r) { return min(l, r); };\n        auto g = [](ll l, ll r) { return r; };\n        auto p = [](ll l, int r) { return l; };\n        RBST<ll,ll> tree(f, g, g, p, INT_MAX, INT_MAX);\n\n        RBST<ll,ll>::node* root = nullptr;\n        for(int i = 0; i < n; i++) tree.insert(root, i, INT_MAX);\n        while(q--) {\n            int c, s, t;\n            cin >> c >> s >> t;\n            if(c == 0) {\n                int x;\n                cin >> x;\n                tree.update(root, s, t + 1, x);\n            } else {\n                cout << tree.query(root, s, t + 1) << endl;\n            }\n        }\n    }\n}\n\n// 区間加算区間和\nnamespace DSL2G {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        auto f = [](ll l, ll r) { return l+r; };\n        auto p = [](ll l, int r) { return l*r; };\n        RBST<ll,ll> tree(f, f, f, p, 0, 0);\n\n        RBST<ll,ll>::node* root = nullptr;\n        for(int i = 0; i < n; i++) tree.insert(root, i, 0);\n        while(q--) {\n            int c, s, t;\n            cin >> c >> s >> t;\n            s--, t--;\n            if(c == 0) {\n                int x;\n                cin >> x;\n                tree.update(root, s, t + 1, x);\n            } else {\n                cout << tree.query(root, s, t + 1) << endl;\n            }\n        }\n    }\n}\n\n// 区間加算区間最小\nnamespace DSL2H {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        auto f = [](ll l, ll r) { return min(l, r); };\n        auto g = [](ll l, ll r) { return l+r; };\n        auto p = [](ll l, int r) { return l; };\n        RBST<ll,ll> tree(f, g, g, p, INT_MAX, 0);\n\n        RBST<ll,ll>::node* root = nullptr;\n        for(int i = 0; i < n; i++) tree.insert(root, i, 0);\n        while(q--) {\n            int c, s, t;\n            cin >> c >> s >> t;\n            if(c == 0) {\n                int x;\n                cin >> x;\n                tree.update(root, s, t+1, x);\n            } else {\n                cout << tree.query(root, s, t+1) << endl;\n            }\n        }\n    }\n}\n\n// 区間更新区間和\nnamespace DSL2I {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        auto f = [](ll l, ll r) { return l+r; };\n        auto g = [](ll l, ll r) { return r; };\n        auto p = [](ll l, int r) { return l*r; };\n        RBST<ll,ll> tree(f, g, g, p, 0, 0);\n\n        RBST<ll,ll>::node* root = nullptr;\n        for(int i = 0; i < n; i++) tree.insert(root, i, 0);\n        while(q--) {\n            int c, s, t;\n            cin >> c >> s >> t;\n            if(c == 0) {\n                int x;\n                cin >> x;\n                tree.update(root, s, t+1, x);\n            } else {\n                cout << tree.query(root, s, t+1) << endl;\n            }\n        }\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    // ARC033C::solve();\n    // DSL2A::solve();\n    // DSL2B::solve();\n    // DSL2F::solve();\n    // DSL2G::solve();\n    // DSL2H::solve();\n    DSL2I::solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <cstring>\n#include <utility>\n#include <numeric>\n\nusing namespace std;\n\n// LazyUpdateSegmentTree\ntemplate<typename T>\nclass LazyUpdateSegTree{\npublic:\n    int n;\n    T defaultValue;\n    vector<T> dat;\n    vector<T> lazy;\n    vector<bool> isSetLazy;\n\n    LazyUpdateSegTree(vector<T>& v, T defaultValue){\n        n = 1;\n        int vSize = (int)v.size();\n        while(n < vSize){\n            n *= 2;\n        }\n        dat.assign(2 * n - 1, defaultValue);\n        lazy.assign(2 * n - 1, 0);\n        isSetLazy.assign(2 * n - 1, false);\n        this->defaultValue = defaultValue;\n\n        for(int i = 0; i < vSize; i++){\n            dat[i + n - 1] = v[i];\n        }\n        for(int i = n - 2; i >= 0; i--){\n            dat[i] = ope(dat[2 * i + 1], dat[2 * i + 2]);\n        }\n    }\n\n    T update(int a, int b, T value, int k = 0, int l = 0, int r = -1){\n        if(r < 0){\n            r = n;\n        }\n        propagate(k);\n\n        if(r <= a || b <= l){\n            return dat[k];\n        }\n\n        if(a <= l && r <= b){\n            lazy[k] = lazyUpdate(value, l, r);\n            isSetLazy[k] = true;\n            propagate(k);\n            return dat[k];\n        }\n        else{\n            T vl = update(a, b, value, 2 * k + 1, l, (l + r) / 2);\n            T vr = update(a, b, value, 2 * k + 2, (l + r) / 2, r);\n            dat[k] = ope(vl, vr);\n            return dat[k];\n        }\n    }\n\n    T query(int a, int b, int k = 0, int l = 0, int r = -1){\n        if(r < 0){\n            r = n;\n        }\n\n        if(r <= a || b <= l){\n            return defaultValue;\n        }\n        propagate(k);\n\n        if(a <= l && r <= b){\n            return dat[k];\n        }\n        else{\n            T vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n            T vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n            return ope(vl, vr);\n        }\n    }\n\nprivate:\n\n    void propagate(int k){\n        if(isSetLazy[k]){\n            dat[k] = lazy[k];\n            if(k <= n - 2){\n                T value = lazyPropUpdate(lazy[k]);\n                lazy[2 * k + 1] = value;\n                lazy[2 * k + 2] = value;\n                isSetLazy[2 * k + 1] = true;\n                isSetLazy[2 * k + 2] = true;\n            }\n\n            isSetLazy[k] = false;\n        }\n    }\n\n    T ope(T a, T b){\n        return a + b;\n    }\n\n    T lazyUpdate(T value, int l, int r){\n        return (r - l) * value;\n    }\n\n    T lazyPropUpdate(T value){\n        return value / 2;\n    }\n};\n\nint main(){\n\n    int n, q;\n    cin >> n >> q;\n    vector<long long> v(n, 0);\n    LazyUpdateSegTree<long long> segTree(v, 0);\n    for(int i = 0; i < q; i++){\n        int type;\n        cin >> type;\n        if(type == 0){\n            int s, t, x;\n            cin >> s >> t >> x;\n            segTree.update(s, t + 1, x);\n        }\n        else{\n            int s, t;\n            cin >> s >> t;\n            cout << segTree.query(s, t + 1) << endl;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\ntemplate <class Tp, class BinaryOperation1, class BinaryOperation2>\nclass segment_tree {\npublic:\n  using binary_operation1 = BinaryOperation1;\n  using binary_operation2 = BinaryOperation2;\n  using value_type = Tp;\n\nprivate:\n  size_t m, h;\n  std::vector<value_type> c, d;\n  binary_operation1 op1;  // aggregate\n  binary_operation2 op2;  // update\n\n  size_t height(size_t n) const {\n    return 64 - __builtin_clzll(n);\n  }\n\n  void init_aggregate() {\n    for (size_t i = m/2; i-- > 1;)\n      c[i] = op1(c[i<<1], c[i<<1|1]);\n  }\n\n  void calc(size_t p, size_t k) {\n    // called in build()\n    c[p] = op1(c[p<<1], c[p<<1|1]);\n    if (p < m/2) c[p] = op2(c[p], d[p], k);\n  }\n\n  void apply(size_t i, Tp x, size_t k) {\n    // called in push() and update()\n    c[i] = op2(c[i], x, k);\n    if (i < m/2) d[i] = op2(d[i], x);\n  }\n\n  void build(size_t i) {\n    size_t k = 2;\n    for (i += m/2; i > 1; k <<= 1) {\n      i >>= 1;\n      calc(i, k);\n    }\n  }\n\n  void push(size_t i) {\n    i += m/2;\n    for (size_t s = h, k = 1 << (h-1); s > 0; --s, k >>= 1) {\n      size_t j = i >> s;\n      if (d[j] != op2.identity) {\n        apply(j<<1|0, d[j], k);\n        apply(j<<1|1, d[j], k);\n        d[j] = op2.identity;\n      }\n    }\n  }\n\npublic:\n  segment_tree(size_t n,\n               BinaryOperation1 op1 = BinaryOperation1(),\n               BinaryOperation2 op2 = BinaryOperation2()):\n    m(2*n), h(height(n)), c(m, op1.identity), d(n, op2.identity),\n    op1(op1), op2(op2)\n  {}\n\n  segment_tree(size_t n, const value_type& e,\n               BinaryOperation1 op1 = BinaryOperation1(),\n               BinaryOperation2 op2 = BinaryOperation2()):\n    m(2*n), h(height(n)), c(m, e), d(n, op2.identity), op1(op1), op2(op2)\n  {\n    for (size_t i = n; i < m; ++i) c[i] = e;\n    init_aggregate();\n  }\n\n  template <class ForwardIt>\n  segment_tree(ForwardIt first, ForwardIt last,\n               BinaryOperation1 op1 = BinaryOperation1(),\n               BinaryOperation2 op2 = BinaryOperation2()):\n    m(2*std::distance(first, last)), h(height(m/2)), c(m),\n    d(m/2, op2.identity), op1(op1), op2(op2)\n  {\n    static_assert(std::is_same<Tp, typename ForwardIt::value_type>::value, \"\");\n    for (size_t i = m/2; first != last; ++i) c[i] = *first++;\n    init_aggregate();\n  }\n\n  void update(size_t l, size_t r, Tp x) {\n    push(l);\n    push(r-1);\n    size_t l0 = l;\n    size_t r0 = r;\n    l += m/2;\n    r += m/2;\n    size_t k = 1;\n    while (l < r) {\n      if (l & 1) apply(l++, x, k);\n      if (r & 1) apply(--r, x, k);\n      l >>= 1;\n      r >>= 1;\n      k <<= 1;\n    }\n    build(l0);\n    build(r0-1);\n  }\n\n  value_type aggregate(size_t l, size_t r) {\n    push(l);\n    push(r-1);\n    value_type resl = op1.identity;\n    value_type resr = op1.identity;\n    l += m/2;\n    r += m/2;\n    while (l < r) {\n      if (l & 1) resl = op1(resl, c[l++]);\n      if (r & 1) resr = op1(c[--r], resr);\n      l >>= 1;\n      r >>= 1;\n    }\n    return op1(resl, resr);\n  }\n};\n\ntemplate <class Tp>\nstruct find {\n  using pair_type = std::pair<Tp, bool>;\n  pair_type identity = {0, false};\n  pair_type operator ()(const pair_type& x, const pair_type& y) const {\n    return {x.first + y.first, false};\n  }\n};\n\ntemplate <class Tp>\nstruct update {\n  using pair_type = std::pair<Tp, bool>;\n  pair_type identity = {0, false};\n  pair_type operator ()(const pair_type& x, const pair_type& y) const {\n    return y.second? y:x;\n  }\n  pair_type operator ()(const pair_type& x, const pair_type& y, size_t k) const {\n    return y.second? std::make_pair(y.first*Tp(k), true) : x;\n  }\n};\n\nint main() {\n  size_t n, q;\n  scanf(\"%zu %zu\", &n, &q);\n\n  segment_tree<std::pair<int, bool>, find<int>, update<int>> st(n);\n  for (size_t i = 0; i < q; ++i) {\n    int com;\n    scanf(\"%d\", &com);\n\n    if (com == 0) {\n      // update(s, t, x)\n      size_t s, t;\n      int x;\n      scanf(\"%zu %zu %d\", &s, &t, &x);\n      st.update(s, t+1, {x, true});\n    } else if (com == 1) {\n      // find(s, t)\n      size_t s, t;\n      scanf(\"%zu %zu\", &s, &t);\n      printf(\"%d\\n\", st.aggregate(s, t+1).first);\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\ntemplate<typename T, typename E> struct LazySegmentTree {\n  using F = function<T(T, T)>;\n  using G = function<T(T, E)>;\n  using H = function<E(E, E)>;\n  using P = function<E(E, size_t)>;\n\n  size_t n;\n  T initT;\n  E initE;\n  F f;\n  G g;\n  H h;\n  P p;\n  vector<T> data;\n  vector<E> lazy;\n\n  LazySegmentTree(size_t n_, F f, G g, H h, T initT = INT_MAX, E initE = INT_MAX,\n      vector<T> v = vector<T>(), P p = [](E a, size_t b) { ++b; return a; })\n      : f(f), g(g), h(h), initT(initT), initE(initE), p(p) {\n    n = 1;\n    while (n < n_) n *= 2;\n    data.assign(n * 2 - 1, initT);\n    lazy.assign(n * 2 - 1, initE);\n    if (n_ == v.size()) build(v);\n  }\n  void build(vector<T> v) {\n    for (int i = 0; i < v.size(); ++i) data[i + n - 1] = v[i];\n    for (int i = n - 2; i >= 0; --i) {\n      data[i] = f(data[i * 2 + 1], data[i * 2 + 2]);\n    }\n  }\n  inline void eval(int len, int k) {\n    if (lazy[k] == initE) return;\n    if (k * 2 + 1 < n * 2 - 1) {\n      lazy[k * 2 + 1] = h(lazy[k * 2 + 1], lazy[k]);\n      lazy[k * 2 + 2] = h(lazy[k * 2 + 2], lazy[k]);\n    }\n    data[k] = g(data[k], p(lazy[k], len));\n    lazy[k] = initE;\n  }\n  T update(int a, int b, E x, int k = 0, int l = 0, int r = -1) {\n    if (r < 0) r = n;\n    eval(r - l, k);\n    if (b <= l || r <= a) return data[k];\n    if (a <= l && r <= b) {\n      lazy[k] = h(lazy[k], x);\n      return g(data[k], p(lazy[k], r - l));\n    }\n    T vl = update(a, b, x, k * 2 + 1, l, (l + r) / 2);\n    T vr = update(a, b, x, k * 2 + 2, (l + r) / 2, r);\n    return data[k] = f(vl, vr);\n  }\n  T query(int a, int b, int k = 0, int l = 0, int r = -1) {\n    if (r < 0) r = n;\n    eval(r - l, k);\n    if (b <= l || r <= a) return initT;\n    if (a <= l && r <= b) return data[k];\n    T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n    T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n    return f(vl, vr);\n  }\n};\n//\n// e.g.\n//      |     f     |   g   |   h   |   initT   | initE |   p\n// -----+-----------+-------+-------+-----------+-------+--------\n//  RMQ | min / max |       |       | INF / 0   |       | (mult)\n//  RSQ | plus      |       |       | 0         |       | (mult)\n//  RUQ |           | (ass) | (ass) |           | INF   | (mult)\n//  RAQ |           | plus  | plus  |           | 0     | (mult)\n//\n//  (ass)  := ex_assign;\n//  (mult) := ex_multiplies;\n//\ntemplate<typename T> constexpr function<T(T, T)> ex_assign(T initE) {\n  return [&initE](const T& x, const T& y) -> const T { return (y == initE) ? x : y; };\n}\ntemplate<typename T> constexpr function<T(T, size_t)> ex_multiplies(T initE) {\n  return [&initE](const T& x, size_t y) -> const T { return (x == initE) ? x : x * y; };\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  const ll initT = 0;\n  const ll initE = 1e9;\n  const LazySegmentTree<ll, ll>::F f = plus<ll>();\n  const LazySegmentTree<ll, ll>::G g = ex_assign<ll>(initE);\n  const LazySegmentTree<ll, ll>::H h = ex_assign<ll>(initE);\n  const LazySegmentTree<ll, ll>::P p = ex_multiplies<ll>(initE);\n\n  int n, q; cin >> n >> q;\n  LazySegmentTree<ll, ll> seg(n, f, g, h, initT, initE, vector<ll>(), p);\n\n  while (q--) {\n    int com; cin >> com;\n    if (com) {\n      int s, t; cin >> s >> t;\n      cout << seg.query(s, t + 1) << endl;\n    } else {\n      int s, t, x; cin >> s >> t >> x;\n      seg.update(s, t + 1, x);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\n/*Starry Sky Tree*/\n/*Range Add Min(Max) Query*/\n/*区間加算、区間Min,区間Max*/\n\nclass RSUQ{\npublic: \n  \n  //遅延用の型  \n  struct T{\n    bool type; //0 - empty   , 1 - update\n    int value;\n    T():type(0),value(0){}\n    T(bool type,int value):type(type),value(value){}\n  };\n\n  //マージ可能な主データ型\n  struct D{\n    int value;\n    D():value(0){} /*適切な値にする!!!!!!*/\n    D(int value):value(value){}\n    bool operator < (D a)const {return value < a.value;} //merge用\n  };\n  \n  int n;\n  vector<D> dat;\n  vector<T> td;\n  D returnD = D(0); // 範囲外の時に返す値。\n  \n  RSUQ(){n=-1;}\n  RSUQ(int n_){\n    n=1;\n    while(n<n_)n*=2;\n    td.resize(2*n-1,T());\n    dat.resize(2*n-1,D());\n  }\n  \n  D merge(D a,D b){return a.value + b.value;}\n  \n  void delay(int k,int len){\n    if(td[k].type==0) return;\n    int v = td[k].value;\n    td[k].type = 0;\n    td[k].value = 0;\n    \n    len /= 2;\n    int l = k*2+1,r = k*2+2;\n    dat[l].value = v * len; td[l].type = 1; td[l].value = v;\n    dat[r].value = v * len; td[r].type = 1; td[r].value = v;\n  }\n\n  D update(int k,int x, int len){\n    dat[k].value = x * len;\n    td[k].type = 1;\n    td[k].value = x;\n    return dat[k];\n  }\n  \n  //[a,b)の値をx変更　add(a,b,x)\n  D query(int a,int b,int x,bool flg=true,int k=0,int l=0,int r=-1){\n    if(r==-1) r=n, assert(a <= n && b <= n);\n    if(r<=a||b<=l) return flg? dat[k]:returnD;\n    if(a<=l&&r<=b) return flg? update(k, x, r - l):dat[k];\n    \n    delay(k, r - l);\n    D vl = query(a,b,x,flg,k*2+1,l,(l+r)/2);\n    D vr = query(a,b,x,flg,k*2+2,(l+r)/2,r);\n    if(flg) dat[k] = merge(vl,vr);\n    return merge(vl,vr);\n  }\n  \n  //[a,b)の合計値を得る　find(a,b);\n  int find(int a,int b){\n    D res = query(a,b,0,false);\n    return res.value;\n  }\n};\n\n\nsigned main(){\n  int n,q;\n  cin>>n>>q;\n  \n  RSUQ rsuq(n);\n  while(q--){\n    int cmd;\n    cin>>cmd;\n    if(cmd == 0){\n      int s,t,x;\n      cin>>s>>t>>x;\n      rsuq.query(s,t+1,x);\n    }\n    if(cmd == 1){\n      int s,t;\n      cin>>s>>t;\n      cout<<rsuq.find(s,t+1)<<endl;\n    }\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define FOR(i,n,m) for(int i=(int)(n); i<=(int)(m); i++)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define RITR(x,c) for(__typeof(c.rbegin()) x=c.rbegin();x!=c.rend();x++)\n#define setp(n) fixed << setprecision(n)\n\n#define ld long double\n#define ll long long\n#define vll vector<ll>\n#define vi vector<int>\n#define pll pair<ll,ll>\n#define pi pair<int,int>\n\n#define all(a) (a.begin()),(a.end())\n#define rall(a) (a.rbegin()),(a.rend())\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define ins insert\n\nusing namespace std;\n\n//-------------------------------------------------\n//--Lazy Evaluation Segment tree (Proportional)\n//-------------------------------------------------\ntemplate<typename T, typename E>\nclass LazySegmentTree\n{\nprivate:\n    using F = ::std::function<T(T,T)>;\n    using G = ::std::function<T(T,E)>;\n    using H = ::std::function<E(E,E)>;\n    F f; G g; H h;\n    int n, height;\n    ::std::vector<T> seg;\n    ::std::vector<E> lazy;\n    T te; E ee;\npublic:\n    LazySegmentTree(int _n, F f, G g, H h, T te, E ee)\n        : f(f),g(g),h(h),te(te),ee(ee)\n    {\n        init(_n);\n    }\n    LazySegmentTree(::std::vector<T> &v, F f, G g, H h, T te, E ee)\n        : f(f),g(g),h(h),te(te),ee(ee)\n    {\n        int _n = v.size();\n        init(_n);\n        for(int i=n; i<n+_n; i++) seg[i] = v[i-n];\n        build();\n    }\n    void init(int _n){\n        n = 1; height=0;\n        while(n<_n) n<<=1, height++;\n        seg.resize(2*n, te);\n        lazy.resize(2*n, ee);\n    }\n    void build(){\n        for(int i=n-1; i>0; i--) seg[i] = f(seg[i<<1], seg[i<<1|1]);\n    }\n    T eval(int k){\n        int c = breadth(k);\n        return (lazy[k]==ee) ? seg[k] : g(seg[k],quantify(lazy[k], c));\n    }\n    void waveto(int k){\n        for(int i=height; i>0; i--) wave(k>>i);\n    }\n    void wave(int k){\n        seg[k] = eval(k);\n        lazy[k<<1] = h(lazy[k<<1],lazy[k]);\n        lazy[k<<1|1] = h(lazy[k<<1|1],lazy[k]);\n        lazy[k] = ee;\n    }\n    void recalc(int k){\n        for(int i=1; i<=height; i++){\n            int m = k>>i;\n            seg[m] = f(eval(m<<1), eval(m<<1|1));\n        }\n    }\n    void update(int a, int b, E x){\n        if (b<=a) return;\n        waveto(a+=n);\n        waveto(b+=n-1);\n        T L=ee, R=ee;\n        int l=a, r=b;\n        while(l<=r){\n            if (l&1) lazy[l] = h(lazy[l], x), l++;\n            if (!(r&1)) lazy[r] = h(lazy[r], x), r--;\n            l>>=1; r>>=1;\n        }\n        recalc(a);\n        recalc(b);\n    }\n    T query(int a, int b){\n        waveto(a+=n);\n        waveto(b+=n-1);\n        T L=te, R=te;\n        int l=a, r=b;\n        while(l<=r){\n            if (l&1) L = f(L, eval(l++));\n            if (!(r&1)) R = f(eval(r--), R);\n            l>>=1; r>>=1;\n        }\n        return f(L,R);\n    }\n    T operator[](int k){return query(k, k+1);};\n    inline int breadth(int k){\n        int ret = height-31+__builtin_clz(k);\n        return 1<<ret;\n    }\n    //return value proportional to segment's width\n    inline E quantify(E laz, int c){\n        return laz*c;\n    }\n};\n\nconst ll INF = INT_MAX;\n\nint main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,q; cin>>n>>q;\n    vll a(n,0);\n    LazySegmentTree<ll,ll> seg(a,\n        [](ll x, ll y){return x+y;},\n        [](ll x, ll y){return y;},\n        [](ll x, ll y){return (y==INF)?x:y;},\n        0,INF\n    );\n    while(q--){\n        int c; cin>>c;\n        if (c==1){\n            int s,t; cin>>s>>t;\n            cout<<seg.query(s,t+1)<<endl;\n        }else{\n            int s,t,x; cin>>s>>t>>x;\n            seg.update(s,t+1,x);\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(i = 0;i < n;++i)\n#define all(v) v.begin(), v.end()\nusing ll = long long;\n\ntemplate <typename T>\nstruct SegmentTreeLazy //デフォルトは区間変更区間合計\n{\n    int n;\n    const T ex = 0; //dat 初期値(合計なので)\n    const T em = 1ll << 60; //lazy 初期値(updateするので)\n    //lazyで一括更新をもって、datでqueryに対応する。\n    vector<T> dat, lazy, weight; //tree本体\n    SegmentTreeLazy(vector<T> v){\n        int x = 1;\n        int i;\n        n = v.size();\n        while(x < n) x <<= 1;\n        n = x; \n        dat.resize(2*n-1, ex); //tree本体\n        lazy.resize(2*n-1, em); //遅延評価\n        weight.resize(2*n-1, 0); //何node持ってるか\n        for(i = 0;i < v.size();++i){\n            dat.at(i + n - 1) = v.at(i);\n            weight.at(i + n - 1) = 1;\n        }\n        for(i = n-2;i >= 0;--i){\n            dat.at(i) = fx(dat.at(2*i+1), dat.at(2*i+2));\n            weight.at(i) = weight.at(2*i + 1) + weight.at(2*i + 2);\n        }\n    }\n    \n    T fx(T a, T b){ //dat上での計算\n        return a + b; //区間加算なので加算\n    }\n\n    T fm(T a){ //lazy上での計算\n        return min(a, em);\n    }\n    \n    void eval(int now){ //区間下は全て影響を受ける。(受ける時しか呼ばれない)\n        if(lazy.at(now) == em) return;\n        if(now < n - 1){ //区間加算なので値を代入する。\n            lazy.at(2*now + 1) = fm(lazy.at(now));\n            lazy.at(2*now + 2) = fm(lazy.at(now));\n        }\n        //**********************ここが大事\n        dat.at(now) = lazy.at(now)*weight.at(now); //区間加算する。\n        //**********************\n        lazy.at(now) = em;\n    }\n    \n    void update(int a, int b, T x, int now, int l, int r){\n        eval(now);\n        if(a <= l && r<= b){ //区間内に全部いる。\n            lazy.at(now) = x; //上から書き換える。区間最小なので同じ値を足す。\n            eval(now);\n        }else if(a < r && l < b){\n            update(a, b, x, 2*now + 1, l, (l + r)/2);\n            update(a, b, x, 2*now + 2, (l + r)/2, r);\n            dat.at(now) = fx(dat.at(2*now + 1), dat.at(2*now + 2));\n        }\n    }\n    void update(int a, int b, T x){update(a, b, x, 0, 0, n);}\n    \n    T query(int a, int b){return query_sub(a, b, 0, 0, n);}\n    T query_sub(int a, int b, int now, int l, int r){\n        eval(now);\n        if(r <= a || b <= l) return ex;\n        else if(a <= l && r <= b) return dat.at(now);\n        else{\n            T vl = query_sub(a, b, 2*now + 1, l, (l + r)/2);\n            T vr = query_sub(a, b, 2*now + 2, (l + r)/2, r);\n            return fx(vl, vr);\n        }\n    }\n\n    inline T operator[](int a) { return query(a, a + 1); }\n    void print() {\n        for (int i = 0; i < 2 * n - 1; ++i) {\n            cout << (*this)[i];\n            if (i != n) cout << \",\";\n        }\n        cout << endl;\n    }\n};\n\nint main()\n{\n    ll i,j;\n    ll n,q;\n    cin >> n >> q;\n    vector<ll> a(n, 0);\n    SegmentTreeLazy<ll> seg(a);\n    for(i = 0;i < q;++i){\n        ll com;\n        cin >> com;\n        if(com == 0){\n            ll s,t,x;\n            cin >> s >> t >> x;\n            seg.update(s, t+1, x);\n        }else{\n            ll s,t;\n            cin >> s >> t;\n            cout << seg.query(s, t+1) << endl;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define FOR(i, m, n) for(int i=(m); i<(n); ++i)\n#define rrep(i, n) for(int i=(n)-1; i>=0; --i)\n#define rfor(i, m, n) for(int i=(m); i>=(n); --i)\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\nusing LL = long long;\t\tusing VB = vector<bool>;\nusing VI = vector<int>;\t\tusing VL = vector<LL>;\nusing VS = vector<string>;\tusing VD = vector<double>;\nusing VVI = vector<VI>;\t\tusing VVL = vector<VL>;\nusing PII = pair<int, int>;\tusing PLL = pair<LL, LL>;\nusing VP = vector<PII>;\t\tusing VPL = vector<PLL>;\nconst int inf = (int)1e9;\nconst LL inf_ll = (LL)1e18, MOD = 1000000007;\nconst double PI = acos(-1.0), EPS = 1e-12;\n\ntemplate<class T>inline void Sort(T& a)noexcept { sort(all(a)); }\ntemplate<class T>inline void RSort(T& a)noexcept { sort(rall(a)); }\ntemplate<class T>inline void Reverse(T& a)noexcept { reverse(all(a)); }\ntemplate<class T>inline void Unique(T& a)noexcept { a.erase(unique(all(a)), a.end()); }\ntemplate<class T>inline T Sorted(T a)noexcept { Sort(a); return a; }\ntemplate<class T>inline T RSorted(T a)noexcept { RSort(a); return a; }\ntemplate<class T>inline T Reversed(T a)noexcept { Reverse(a); return a; }\ntemplate<class T>inline T Uniqued(T a)noexcept { Unique(a); return a; }\ntemplate<class T>inline auto Max(const T& a)noexcept { return *max_element(all(a)); }\ntemplate<class T>inline auto Min(const T& a)noexcept { return *min_element(all(a)); }\ntemplate<class T>inline int MaxPos(const T& a)noexcept { return max_element(all(a)) - a.begin(); }\ntemplate<class T>inline int MinPos(const T& a)noexcept { return min_element(all(a)) - a.begin(); }\ntemplate<class T, class U>inline int Count(const T& a, const  U& v)noexcept { return count(all(a), v); }\ntemplate<class T, class U>inline int Find(const T& a, const U& v)noexcept { auto pos = find(all(a), v); return pos == a.end() ? -1 : pos - a.begin(); }\ntemplate<class T, class U>inline U Sum(const T& a, const U& v)noexcept { return accumulate(all(a), v); }\ntemplate<class T, class U>inline int Lower(const T& a, const U& v)noexcept { return lower_bound(all(a), v) - a.begin(); }\ntemplate<class T, class U>inline int Upper(const T& a, const U& v)noexcept { return upper_bound(all(a), v) - a.begin(); }\ntemplate<class T, class P>inline void RemoveIf(T& a, P f)noexcept { a.erase(remove_if(all(a), f), a.end()); }\ntemplate<class T>inline T Age(T n, T m)noexcept { return (n + m - 1) / m; }\ntemplate<class T>inline T Age2(T n, T m)noexcept { return Age(n, m) * m; }\ntemplate<class T>inline T Tri(T n)noexcept { return (n & 1) ? (n + 1) / 2 * n : n / 2 * (n + 1); }\ntemplate<class T>inline T Gcd(T n, T m)noexcept { return m ? Gcd(m, n % m) : n; }\ntemplate<class T>inline T Lcm(T n, T m)noexcept { return n / Gcd(n, m) * m; }\ntemplate<class T>inline T Pow(T a, T n)noexcept { T r = 1; while (n > 0) { if (n & 1)r *= a; a *= a; n /= 2; }return r; }\ntemplate<class T>inline T Powmod(T a, T n, T m = MOD)noexcept { T r = 1; while (n > 0) { if (n & 1)r = r * a % m, n--; else a = a * a % m, n /= 2; }return r; }\ntemplate<class T>inline bool chmax(T& a, const T& b)noexcept { if (a < b) { a = b; return true; } return false; }\ntemplate<class T>inline bool chmin(T& a, const T& b)noexcept { if (a > b) { a = b; return true; } return false; }\ninline string operator*(string s, int n)noexcept { string ret; rep(i, n)ret += s; return ret; }\n\n// --- input --- //\n#if defined(_MSC_VER) || defined(ONLINE_JUDGE)\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\ninline int gc()noexcept { return getchar_unlocked(); }\ntemplate<class T>inline void InputF(T& v)noexcept { cin >> v; }\ninline void InputF(char& v)noexcept { while (isspace(v = gc())); }\ninline void InputF(string& v)noexcept {\n\tchar c; for (InputF(c); !isspace(c); c = gc())v += c;\n}\ninline void InputF(int& v)noexcept {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(long long& v)noexcept {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(double& v)noexcept {\n\tdouble dp = 1; bool neg = false, adp = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\tif (c == '.')adp = true;\n\t\telse if (adp)v += (c - '0') * (dp *= 0.1);\n\t\telse v = v * 10 + (c - '0');\n\t}\n\tif (neg)v = -v;\n}\ntemplate<class T, class U>inline void InputF(pair<T, U>& v)noexcept {\n\tInputF(v.first); InputF(v.second);\n}\ntemplate<class T>inline void InputF(vector<T>& v)noexcept {\n\tfor (auto& e : v)InputF(e);\n}\nstruct InputV {\n\tint n, m;\n\tInputV(int N) :n(N), m(0) {}\n\tInputV(pair<int, int> N) :n(N.first), m(N.second) {}\n\ttemplate<class T>operator vector<T>()noexcept {\n\t\tvector<T> v(n); InputF(v); return v;\n\t}\n\ttemplate<class T>operator vector<vector<T>>()noexcept {\n\t\tvector<vector<T>> v(n, vector<T>(m)); InputF(v); return v;\n\t}\n};\nstruct Input {\n\ttemplate<class T>operator T()noexcept { T v; InputF(v); return v; }\n\tint operator--(int) { int v; InputF(v); v--; return v; }\n\tInputV operator[](int n)noexcept { return InputV(n); }\n\tInputV operator[](pair<int, int> n)noexcept { return InputV(n); }\n\ttemplate<class T, size_t W>array<vector<T>, W> get(int H) {\n\t\tarray<vector<T>, W> ret;\n\t\trep(i, H)rep(j, W) { T x = *this; ret[j].push_back(x); }\n\t\treturn ret;\n\t}\n}in;\n\n// --- output --- //\nstruct BoolStr {\n\tconst char* t, * f; BoolStr(const char* _t, const char* _f) :t(_t), f(_f) {}\n}Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\"), Int(\"1\", \"0\");\nstruct DivStr {\n\tconst char* d, * l; DivStr(const char* _d, const char* _l) :d(_d), l(_l) {}\n}spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), end_line(\"\\n\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Output {\n\tBoolStr B{ Yes }; DivStr D{ spc }; bool isPrint = true;\n\tvoid p(double v) { printf(\"%.20f\", v); } void p(long double v) { printf(\"%.20Lf\", v); }\n\tvoid p(int v) { printf(\"%d\", v); }\tvoid p(LL v) { printf(\"%lld\", v); }\n\tvoid p(char v) { putchar(v); }\t\tvoid p(bool v) { printf(v ? B.t : B.f); }\n\ttemplate<class T>void p(const T& v) { cout << v; }\n\ttemplate<class T, class U>void p(const pair<T, U>& v) { p(v.first); printf(D.d); p(v.second); }\n\ttemplate<class T>void p(const vector<T>& v) { rep(i, sz(v)) { if (i)printf(D.d); p(v[i]); } }\n\ttemplate<class T>void p(const vector<vector<T>>& v) { rep(i, sz(v)) { if (i)printf(D.l); p(v[i]); } }\n\tvoid p(const BoolStr& v) { B = v; isPrint = false; } void p(const DivStr& v) { D = v; isPrint = false; }\npublic:\n\tvoid operator()() { printf(D.l); }\n\ttemplate<class H>void operator()(H&& h) {\n\t\tp(h); if (isPrint)printf(D.l); isPrint = true; B = Yes; D = spc;\n\t}\n\ttemplate<class H, class...T>void operator()(H&& h, T&& ...t) {\n\t\tp(h); if (isPrint)printf(D.d); isPrint = true; operator()(forward<T>(t)...);\n\t}\n\ttemplate<class...T>void exit(T&& ...t) {\n\t\toperator()(forward<T>(t)...); std::exit(EXIT_SUCCESS);\n\t}\n}out;\n\n// --- dump --- //\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) (void(0))\n#endif\n\n\ntemplate<class T>class RSQ_RUQ {\n\tconst int N = 0, sqrtN = 320;\n\tint B;\n\tvector<T> A, Update, Sum;\n\tvector<bool> Flag;\n\n\tvoid eval(int i) {\n\t\tif (Flag[i]) {\n\t\t\tfill(A.begin() + i * sqrtN, A.begin() + (i + 1) * sqrtN, Update[i]);\n\t\t\tFlag[i] = false;\n\t\t}\n\t}\n\npublic:\n\tRSQ_RUQ(int _n) :N(_n), B((_n + sqrtN - 1) / sqrtN) {\n\t\tA.resize(sqrtN * B); Update.resize(B); Flag.resize(B); Sum.resize(B);\n\t}\n\t//[s, t)\n\tvoid update(int s, int t, T x) {\n\t\tfor (int i = 0; i < B; i++) {\n\t\t\tint l = i * sqrtN, r = (i + 1) * sqrtN; //[r, l)\n\t\t\tif (r <= s || t <= l) {\n\t\t\t\tcontinue;\n\t\t\t} else if (s <= l && r <= t) {\n\t\t\t\tUpdate[i] = x; Flag[i] = true;\n\t\t\t\tSum[i] = x * sqrtN;\n\t\t\t} else {\n\t\t\t\teval(i);\n\t\t\t\tfill(A.begin() + max(s, l), A.begin() + min(t, r), x);\n\t\t\t\tSum[i] = accumulate(A.begin() + i * sqrtN, A.begin() + (i + 1) * sqrtN, T{});\n\t\t\t}\n\t\t}\n\t}\n\t//[s, t)\n\tLL sum(int s, int t) {\n\t\tLL ret = 0;\n\t\tfor (int i = 0; i < B; i++) {\n\t\t\tint l = i * sqrtN, r = (i + 1) * sqrtN; //[r, l)\n\t\t\tif (r <= s || t <= l) {\n\t\t\t\tcontinue;\n\t\t\t} else if (s <= l && r <= t) {\n\t\t\t\tret += Sum[i];\n\t\t\t} else {\n\t\t\t\teval(i);\n\t\t\t\tret += accumulate(A.begin() + max(s, l), A.begin() + min(t, r), T{});\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\n\n\nint main() {\n\tint n = in, q = in;\n\tRSQ_RUQ<LL> r(n);\n\trep(i, q) {\n\t\tint op = in;\n\t\tif (op == 0) {\n\t\t\tint s = in, t = in; LL x = in;\n\t\t\tr.update(s, t + 1, x);\n\t\t} else {\n\t\t\tint s = in, t = in;\n\t\t\tout(r.sum(s, t + 1));\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nconst double pi = 3.141592653589793238462643383279;\nusing namespace std;\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n \n \n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \n \n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n \n \n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n \n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n\n//ここから編集\ntemplate<typename T>\nstruct LazySegmentTree{\n  const int INF = numeric_limits<int>::max();\n  int n0;\n  vector<T> node, lazy;\n\n  LazySegmentTree(vector<T> &v){\n    int n = v.size();\n    n0 = 1;\n    while(n0 < n) n0 <<= 1;\n    node.resize(2*n0-1);\n    lazy.assign(2*n0-1, INF);\n    for(int i=0; i<n; i++) node[i+n0-1] = v[i];\n    for(int i=n0-2; i>=0; i--) node[i] = node[i*2+1] + node[i*2+2];\n  }\n\n  void eval(int k, int p){\n    if(lazy[k] == INF) return;\n    \n    if(k < n0-1){\n      lazy[k*2+1] = lazy[k];\n      lazy[k*2+2] = lazy[k];\n    }\n    node[k] = lazy[k] * p;\n    lazy[k] = INF;\n  }\n\n  void update(int a, int b, T x, int k, ll l, ll r){\n    eval(k, r-l);\n    if(a <= l && r <= b){\n      lazy[k] = x;\n      eval(k, r-l);\n    }else if(a < r && l < b) {\n      update(a, b, x, k*2+1, l, (l+r)/2);\n      update(a, b, x, k*2+2, (l+r)/2, r);\n      node[k] = node[k*2+1] + node[k*2+2];\n    }\n  }\n\n  void update(int l, int r, T x) { update(l, r, x, 0, 0, n0); }\n\n  T query(int a, int b, int k, ll l, ll r){\n    eval(k, r-l);\n    if(r <= a || b <= l) return 0;\n    else if(a <= l && r <= b){\n      return node[k];\n    }else{\n      T vl = query(a, b, k*2+1, l, (l+r)/2);\n      T vr = query(a, b, k*2+2, (l+r)/2, r);\n      return vl+vr;\n    }\n  }\n  T query(int l, int r) { return query(l, r, 0, 0, n0); }\n\n  inline T operator[](int a) { return query(a, a + 1); }\n};\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(5);\n  \n  int N, Q; cin >> N >> Q;\n  vector<ll> a(N, 0);\n  LazySegmentTree<ll> seg(a);\n\n  REP(i,Q){\n    int q; cin >> q;\n    if(q == 0){\n      int s, t, x;\n      cin >> s >> t >> x;\n      seg.update(s, t+1, x);\n    }else{\n      int s, t; cin >> s >> t;\n      cout << seg.query(s, t+1) << endl;\n    }\n    // for(int j=0; j<N; j++){\n    //   cout << seg[j] << \" \";\n    // }\n    // cout << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n// #define double long double\n#define FOR(i, a, b) for(ll i = (a); i < (b); ++i)\n#define FORR(i, a, b) for(ll i = (a); i > (b); --i)\n#define REP(i, n) for(ll i = 0; i < (n); ++i)\n#define REPR(i, n) for(ll i = n; i >= 0; i--)\n#define FOREACH(x, a) for(auto &(x) : (a))\n#define VECCIN(x)                                                              \\\n    for(auto &youso_ : (x)) cin >> youso_\n#define bitcnt __builtin_popcount\n#define SZ(x) ((ll)(x).size())\n#define fi first\n#define se second\n#define All(a) (a).begin(), (a).end()\ntemplate <typename T = long long> inline T IN() {\n    T x;\n    cin >> x;\n    return (x);\n}\ninline void CIN() {}\ntemplate <class Head, class... Tail>\ninline void CIN(Head &&head, Tail &&... tail) {\n    cin >> head;\n    CIN(move(tail)...);\n}\n#define CCIN(...)                                                              \\\n    char __VA_ARGS__;                                                          \\\n    CIN(__VA_ARGS__)\n#define DCIN(...)                                                              \\\n    double __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define LCIN(...)                                                              \\\n    ll __VA_ARGS__;                                                            \\\n    CIN(__VA_ARGS__)\n#define SCIN(...)                                                              \\\n    string __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define Printv(v)                                                              \\\n    {                                                                          \\\n        REP(x, v.size()) { cout << v[x] << (x == v.size() - 1 ? \"\\n\" : \" \"); } \\\n    }\ntemplate <typename T = string> inline void eputs(T s) {\n    cout << s << \"\\n\";\n    exit(0);\n}\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *)array, (T *)(array + N), val);\n}\ntemplate <typename T> using PQG = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T> using PQ = priority_queue<T>;\n\ntypedef long long ll;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<ll, ll> PL;\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\nconst double PI = atan(1.0) * 4.0;\nconst ll LINF = 1e18;\nconst ll dx[] = {1, 0, -1, 0};\nconst ll dy[] = {0, 1, 0, -1};\n\nvoid cinfast() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n}\n\n//遅延seg\ntemplate <typename T, typename E> struct SegmentTree {\n    using F = function<T(T, T)>;\n    using G = function<T(T, E)>;\n    using H = function<E(E, E)>;\n    using P = function<E(E, int)>;\n    int n;\n    F f;\n    G g;\n    H h;\n    P p;\n    T e1;\n    E e2;\n    vector<T> dat;\n    vector<E> laz;\n    SegmentTree(int n_, F f, G g, H h, T e1, E e2, vector<T> v = vector<T>(),\n                P p = [](E a, int b) { return a; })\n        : f(f), g(g), h(h), e1(e1), e2(e2), p(p) {\n        init(n_);\n        if(n_ == (int)v.size()) build(n_, v);\n    }\n    void init(int n_) {\n        n = 1;\n        while(n < n_) n *= 2;\n        dat.clear();\n        dat.resize(2 * n - 1, e1);\n        laz.clear();\n        laz.resize(2 * n - 1, e2);\n    }\n    void build(int n_, vector<T> v) {\n        for(int i = 0; i < n_; i++) dat[i + n - 1] = v[i];\n        for(int i = n - 2; i >= 0; i--)\n            dat[i] = f(dat[i * 2 + 1], dat[i * 2 + 2]);\n    }\n    inline void eval(int len, int k) {\n        if(laz[k] == e2) return;\n        if(k * 2 + 1 < n * 2 - 1) {\n            laz[k * 2 + 1] = h(laz[k * 2 + 1], laz[k]);\n            laz[k * 2 + 2] = h(laz[k * 2 + 2], laz[k]);\n        }\n        dat[k] = g(dat[k], p(laz[k], len));\n        laz[k] = e2;\n    }\n    T update(int a, int b, E x, int k, int l, int r) {\n        eval(r - l, k);\n        if(r <= a || b <= l) return dat[k];\n        if(a <= l && r <= b) {\n            laz[k] = h(laz[k], x);\n            return g(dat[k], p(laz[k], r - l));\n        }\n        eval(r - l, k);\n        return dat[k] = f(update(a, b, x, k * 2 + 1, l, (l + r) / 2),\n                          update(a, b, x, k * 2 + 2, (l + r) / 2, r));\n    }\n    T update(int a, int b, E x) { return update(a, b, x, 0, 0, n); }\n    T query(int a, int b, int k, int l, int r) {\n        eval(r - l, k);\n        if(r <= a || b <= l) return e1;\n        if(a <= l && r <= b) return dat[k];\n        T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return f(vl, vr);\n    }\n    T query(int a, int b) { return query(a, b, 0, 0, n); }\n};\n\nsigned main() {\n    LCIN(n, q);\n    ll e1 = 0, e2 = 1 << 30;\n    SegmentTree<ll, ll> seg(n, [](ll a, ll b) { return a + b; },\n                            [e2](ll a, ll b) { return (b == e2 ? a : b); },\n                            [e2](ll a, ll b) { return (b == e2 ? a : b); }, e1,\n                            e2, VL(n, e1), [](ll a, ll b) { return a * b; });\n    REP(i, q) {\n        if(IN()) {\n            LCIN(s, t);\n            cout << seg.query(s, t + 1) << \"\\n\";\n        } else {\n            LCIN(s, t, x);\n            seg.update(s, t + 1, x);\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nconst ull mod = 1e9 + 7;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntemplate<class S, class T> ostream& operator << (ostream& os, const pair<S, T> v){\n  os << \"(\" << v.first << \", \" << v.second << \")\"; return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<T> v){\n  for(int i = 0; i < (int)v.size(); i++){if(i > 0){os << \" \";} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<vector<T>> v){\n  for(int i = 0; i < (int)v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\n\ntemplate< typename Monoid, typename OperatorMonoid, typename F, typename G, typename H >\nstruct LazySegmentTree {\n  // std::function は遅いので使わないことを推奨\n  //using F = function< Monoid(Monoid, Monoid) >;\n  //using G = function< Monoid(Monoid, OperatorMonoid) >;\n  //using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n\n  int sz, height;\n  vector< Monoid > data;\n  vector< OperatorMonoid > lazy;\n  const F f;\n  const G g;\n  const H h;\n  const Monoid M1;\n  const OperatorMonoid OM0;\n\n\n  // n: サイズ\n  // f: 二つの区間をマージする二項演算\n  // g: 要素と作用素をマージする二項演算\n  // h: 作用素同士をマージする二項演算\n  // M1: モノイドの単位元\n  // OM0: 作用素の単位元\n\n  // 初期化を忘れない！x を初期値とすると\n  // REP(i, n) seg[i].set(x);\n  // seg.build();\n\n  // 初期化なしだとM1で初期化される\n  // range sum をするときは，M1は(0, 0)だが初期化は(0, 1)であることに注意！\n\n  LazySegmentTree(int n, const F f, const G g, const H h,\n                  const Monoid &M1, const OperatorMonoid OM0)\n      : f(f), g(g), h(h), M1(M1), OM0(OM0) {\n    sz = 1;\n    height = 0;\n    while(sz < n) sz <<= 1, height++;\n    data.assign(2 * sz, M1);\n    lazy.assign(2 * sz, OM0);\n  }\n\n  void set(int k, const Monoid &x) {\n    data[k + sz] = x;\n  }\n\n  void build() {\n    for(int k = sz - 1; k > 0; k--) {\n      data[k] = f(data[2 * k + 0], data[2 * k + 1]);\n    }\n  }\n\n  inline void propagate(int k) {\n    if(lazy[k] != OM0) {\n      lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n      lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n      data[k] = reflect(k);\n      lazy[k] = OM0;\n    }\n  }\n\n  inline Monoid reflect(int k) {\n    return lazy[k] == OM0 ? data[k] : g(data[k], lazy[k]);\n  }\n\n  inline void recalc(int k) {\n    while(k >>= 1) data[k] = f(reflect(2 * k + 0), reflect(2 * k + 1));\n  }\n\n  inline void thrust(int k) {\n    for(int i = height; i > 0; i--) propagate(k >> i);\n  }\n\n  void update(int a, int b, const OperatorMonoid &x) {\n    thrust(a += sz);\n    thrust(b += sz - 1);\n    for(int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) lazy[l] = h(lazy[l], x), ++l;\n      if(r & 1) --r, lazy[r] = h(lazy[r], x);\n    }\n    recalc(a);\n    recalc(b);\n  }\n\n  Monoid query(int a, int b) {\n    thrust(a += sz);\n    thrust(b += sz - 1);\n    Monoid L = M1, R = M1;\n    for(int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) L = f(L, reflect(l++));\n      if(r & 1) R = f(reflect(--r), R);\n    }\n    return f(L, R);\n  }\n\n  Monoid operator[](const int &k) {\n    return query(k, k + 1);\n  }\n\n  template< typename C >\n  int find_subtree(int a, const C &check, Monoid &M, bool type) {\n    while(a < sz) {\n      propagate(a);\n      Monoid nxt = type ? f(reflect(2 * a + type), M) : f(M, reflect(2 * a + type));\n      if(check(nxt)) a = 2 * a + type;\n      else M = nxt, a = 2 * a + 1 - type;\n    }\n    return a - sz;\n  }\n\n  template< typename C >\n  int find_first(int a, const C &check) {\n    Monoid L = M1;\n    if(a <= 0) {\n      if(check(f(L, reflect(1)))) return find_subtree(1, check, L, false);\n      return -1;\n    }\n    thrust(a + sz);\n    int b = sz;\n    for(a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n      if(a & 1) {\n        Monoid nxt = f(L, reflect(a));\n        if(check(nxt)) return find_subtree(a, check, L, false);\n        L = nxt;\n        ++a;\n      }\n    }\n    return -1;\n  }\n\n\n  template< typename C >\n  int find_last(int b, const C &check) {\n    Monoid R = M1;\n    if(b >= sz) {\n      if(check(f(reflect(1), R))) return find_subtree(1, check, R, true);\n      return -1;\n    }\n    thrust(b + sz - 1);\n    int a = sz;\n    for(b += sz; a < b; a >>= 1, b >>= 1) {\n      if(b & 1) {\n        Monoid nxt = f(reflect(--b), R);\n        if(check(nxt)) return find_subtree(b, check, R, true);\n        R = nxt;\n      }\n    }\n    return -1;\n  }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll n, q;\n    cin >> n >> q;\n\n    // OM0 は演算の途中で被ってもダメなので注意！\n    const ll INF = (1ll<<60);\n    auto f = [](pll x, pll y){return pll(x.first+y.first, x.second+y.second);};\n    auto g = [](pll x, ll a){return (a==INF ? x : pll(a*x.second, x.second));};\n    auto h = [](ll a, ll b){return (b==INF ? a : b);};\n    pll M1 = {0, 0};\n    ll OM0 = INF;\n    LazySegmentTree<pll, ll, decltype(f), decltype(g), decltype(h)> seg(n, f, g, h, M1, OM0);\n    REP(i, n) seg.set(i, {0, 1});\n    seg.build();\n\n\n    while(q--){\n    \tll Q;\n    \tcin >> Q;\n    \tif(Q){\n    \t\tll s, t;\n    \t\tcin >> s >> t;\n    \t\tcout << seg.query(s, t+1).first << endl;\n    \t}else{\n    \t\tll s, t, x;\n    \t\tcin >> s >> t >> x;\n    \t\tseg.update(s, t+1, x);\n    \t}\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\n\nint n,q;\nint S[4*maxn],lazy[4*maxn];\n\nvoid upd(int id,int l,int r,int ql,int qr,int v) {\n    if (ql==l && qr==r) {\n        lazy[id]=v;\n        return;\n    }\n    if (lazy[id]) {\n        S[id]=lazy[id]*(r-l+1);\n        if (l!=r) {\n            lazy[id<<1]=lazy[id];\n            lazy[id<<1|1]=lazy[id];\n        }\n        lazy[id]=0;\n    }\n    int m=l+r>>1;\n    if (qr<=m) upd(id<<1,l,m,ql,qr,v);\n    else if (ql>m) upd(id<<1|1,m+1,r,ql,qr,v);\n    else upd(id<<1,l,m,ql,m,v),\n         upd(id<<1|1,m+1,r,m+1,qr,v);\n    S[id]=(lazy[id<<1]?lazy[id<<1]*(m-l+1):S[id<<1])+\n          (lazy[id<<1|1]?lazy[id<<1|1]*(r-m):S[id<<1|1]);\n}\n\nint query(int id,int l,int r,int ql,int qr) {\n    if (lazy[id]) {\n        S[id]=lazy[id]*(r-l+1);\n        if (l!=r) {\n            lazy[id<<1]=lazy[id];\n            lazy[id<<1|1]=lazy[id];\n        }\n        lazy[id]=0;\n    }\n    if (ql==l && qr==r) return S[id];\n    int m=l+r>>1;\n    if (qr<=m) return query(id<<1,l,m,ql,qr);\n    else if (ql>m) return query(id<<1|1,m+1,r,ql,qr);\n    else return query(id<<1,l,m,ql,m)+query(id<<1|1,m+1,r,m+1,qr);\n}\n\nint main() {\n    cin>>n>>q;\n    for (int i=0;i<q;i++) {\n        int f,s,t,x; cin>>f>>s>>t;\n        if (f) cout<<query(1,0,n-1,s,t)<<'\\n';\n        else {\n            cin>>x;\n            upd(1,0,n-1,s,t,x);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(ll i = ll(a); i < ll(b); i++)\n#define rer(i, a, b) for(ll i = ll(a) - 1; i >= ll(b); i--)\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sc second\n#define fr first\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int, int> P;\n\nconst ll MOD=1000000007;\nconst int MAX_N=1<<17; //nの2倍くらい\nconst ll INF=(1LL<<31)-1;\n// RSQ&RAQ\n/*\nstruct LazySegmentTree{\n    ll node[2*MAX_N-1], lazy[2*MAX_N-1], SIZE; //SIZE:nを２べきにしたもの\n    \n    //初期化\n    void init(int n_){\n        //要素数を2べきに\n        SIZE=1;\n        while(SIZE<n_) SIZE*=2;\n        \n        //全ての値をI_MAXに\n        rep(i,0,2*SIZE-1) node[i]=0;\n    }\n    \n    //k番目のノードについて遅延評価を行う\n    void eval(int k, int l, int r){\n        // 遅延配列が空でない場合、自ノード及び子ノードへの値の伝播が起こる\n        if(lazy[k]!=0){\n            node[k]+=lazy[k];\n            // 最下段かどうかのチェックをしよう\n            if(r-l>1){\n                lazy[2*k+1]+=lazy[k]/2;\n                lazy[2*k+2]+=lazy[k]/2;\n            }\n            // 伝播が終わったので、自ノードの遅延配列を空にする\n            lazy[k] = 0;\n        }\n    }\n    \n    void add(int a, int b, ll x, int k=0, int l=0, int r=-1){\n        if(r<0) r=SIZE;\n        eval(k,l,r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b) {\n            lazy[k] += (r - l) * x;\n            eval(k, l, r);\n        }\n        else{\n            add(a, b, x, 2*k+1, l, (l+r)/2);\n            add(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k]=node[2*k+1]+node[2*k+2];\n        }\n    }\n    \n    ll getsum(int a, int b, int k=0, int l=0, int r=-1){\n        if(r<0) r=SIZE;\n        if(b <= l || r <= a) return 0;\n        eval(k,l,r);\n        if(a <= l && r <= b) return node[k];\n        ll vl=getsum(a, b, 2*k+1, l, (l+r)/2);\n        ll vr=getsum(a, b, 2*k+2, (l+r)/2, r);\n        return vl+vr;\n    }\n};\n*/\n\n//RMQ&RUQ\n/*\nstruct LazySegmentTree{\n    ll node[2*MAX_N-1], lazy[2*MAX_N-1], SIZE; //SIZE:nを２べきにしたもの\n    bool lazyflag[2*MAX_N-1];\n    \n    //初期化\n    void init(int n_){\n        //要素数を2べきに\n        SIZE=1;\n        while(SIZE<n_) SIZE*=2;\n        \n        //全ての値をI_MAXに\n        rep(i,0,2*SIZE-1) node[i]=INF;\n    }\n    \n    //k番目のノードについて遅延評価を行う\n    void eval(int k, int l, int r){\n        // 遅延配列が空でない場合、自ノード及び子ノードへの値の伝播が起こる\n        if(lazyflag[k]){\n            node[k]=lazy[k];\n            // 最下段かどうかのチェックをしよう\n            if(r-l>1){\n                lazy[k*2+1] = lazy[k*2+2] = lazy[k];\n                lazyflag[k*2+1] = lazyflag[k*2+2] = true;\n            }\n            lazyflag[k] = false;\n        }\n    }\n    \n    void update(int a, int b, ll x, int k=0, int l=0, int r=-1){\n        if(r<0) r=SIZE;\n        eval(k,l,r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b) {\n            lazy[k] = x;\n            lazyflag[k]=true;\n            eval(k, l, r);\n        }\n        else{\n            update(a, b, x, 2*k+1, l, (l+r)/2);\n            update(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k]=min(node[2*k+1], node[2*k+2]);\n        }\n    }\n    \n    ll getmin(int a, int b, int k=0, int l=0, int r=-1){\n        if(r<0) r=SIZE;\n        eval(k,l,r);\n        if(b <= l || r <= a) return INF;\n        if(a <= l && r <= b) return node[k];\n        ll vl=getmin(a, b, 2*k+1, l, (l+r)/2);\n        ll vr=getmin(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl, vr);\n    }\n};*/\n\n//RMQ&RAQ\n/*\nstruct LazySegmentTree{\n    ll node[2*MAX_N-1], lazy[2*MAX_N-1], SIZE; //SIZE:nを２べきにしたもの\n    bool lazyflag[2*MAX_N-1];\n    //初期化\n    void init(int n_){\n        //要素数を2べきに\n        SIZE=1;\n        while(SIZE<n_) SIZE*=2;\n        \n        //全ての値をI_MAXに\n        rep(i,0,2*SIZE-1) node[i]=0;\n    }\n    \n    //k番目のノードについて遅延評価を行う\n    void eval(int k, int l, int r){\n        // 遅延配列が空でない場合、自ノード及び子ノードへの値の伝播が起こる\n        if(lazyflag[k]){\n            node[k]+=lazy[k];\n            // 最下段かどうかのチェックをしよう\n            if(r-l>1){\n                lazy[k*2+1] += lazy[k];\n                lazy[k*2+2] += lazy[k];\n                lazyflag[k*2+1] = lazyflag[k*2+2] = true;\n            }\n            lazyflag[k] = false;\n            lazy[k]=0;\n        }\n    }\n    \n    void add(int a, int b, ll x, int k=0, int l=0, int r=-1){\n        if(r<0) r=SIZE;\n        eval(k,l,r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b) {\n            lazy[k] += x;\n            lazyflag[k]=true;\n            eval(k, l, r);\n        }\n        else{\n            add(a, b, x, 2*k+1, l, (l+r)/2);\n            add(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k]=min(node[2*k+1], node[2*k+2]);\n        }\n    }\n    \n    ll getmin(int a, int b, int k=0, int l=0, int r=-1){\n        if(r<0) r=SIZE;\n        eval(k,l,r);\n        if(b <= l || r <= a) return INF;\n        if(a <= l && r <= b) return node[k];\n        ll vl=getmin(a, b, 2*k+1, l, (l+r)/2);\n        ll vr=getmin(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl, vr);\n    }\n};*/\n\n//RSQ&RUQ\nstruct LazySegmentTree{\n    ll node[2*MAX_N-1], lazy[2*MAX_N-1], SIZE; //SIZE:nを２べきにしたもの\n    bool lazyflag[2*MAX_N-1];\n    \n    //初期化\n    void init(int n_){\n        //要素数を2べきに\n        SIZE=1;\n        while(SIZE<n_) SIZE*=2;\n        \n        //全ての値をI_MAXに\n        rep(i,0,2*SIZE-1) node[i]=0;\n    }\n    \n    //k番目のノードについて遅延評価を行う\n    void eval(int k, int l, int r){\n        // 遅延配列が空でない場合、自ノード及び子ノードへの値の伝播が起こる\n        if(lazyflag[k]){\n            node[k]=(r-l) * lazy[k];\n            // 最下段かどうかのチェックをしよう\n            if(r-l>1){\n                lazy[k*2+1] = lazy[k*2+2] = lazy[k];\n                lazyflag[k*2+1] = lazyflag[k*2+2] = true;\n            }\n            lazyflag[k] = false;\n        }\n    }\n    \n    void update(int a, int b, ll x, int k=0, int l=0, int r=-1){\n        if(r<0) r=SIZE;\n        eval(k,l,r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b) {\n            lazy[k] = x;\n            lazyflag[k]=true;\n            eval(k, l, r);\n        }\n        else{\n            update(a, b, x, 2*k+1, l, (l+r)/2);\n            update(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k]=node[2*k+1]+node[2*k+2];\n        }\n    }\n    \n    ll getsum(int a, int b, int k=0, int l=0, int r=-1){\n        if(r<0) r=SIZE;\n        eval(k,l,r);\n        if(b <= l || r <= a) return 0;\n        if(a <= l && r <= b) return node[k];\n        ll vl=getsum(a, b, 2*k+1, l, (l+r)/2);\n        ll vr=getsum(a, b, 2*k+2, (l+r)/2, r);\n        return vl+vr;\n    }\n};\n\nLazySegmentTree S;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n,q;\n    cin>>n>>q;\n    S.init(n);\n    rep(i,0,q){\n        int b;\n        cin>>b;\n        if(b){\n            int s,t;\n            cin>>s>>t;\n            cout<<S.getsum(s, t+1)<<\"\\n\";\n        }\n        else{\n            int s,t;\n            cin>>s>>t;\n            ll x;\n            cin>>x;\n            S.update(s, t+1, x);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n#define int long long int\n\n// quoted from beet-aizu\ntemplate <typename T,typename E, typename F, typename G, typename H>\nstruct LazySegmentTree{\n    //using F = function<T(T,T)>;\n    //using G = function<T(T,E)>;\n    //using H = function<E(E,E)>;\n    int n,height;\n    F f;\n    G g;\n    H h;\n    T ti;\n    E ei;\n    vector<T> dat;\n    vector<E> laz;\n    LazySegmentTree(F f,G g,H h,T ti,E ei):\n        f(f),g(g),h(h),ti(ti),ei(ei){}\n\n    void init(int n_){\n        n=1;height=0;\n        while(n<n_) n<<=1,height++;\n        dat.assign(2*n,ti);\n        laz.assign(2*n,ei);\n    }\n    void build(const vector<T> &v){\n        int n_=v.size();\n        init(n_);\n        for(int i=0;i<n_;i++) dat[n+i]=v[i];\n        for(int i=n-1;i;i--)\n            dat[i]=f(dat[(i<<1)|0],dat[(i<<1)|1]);\n    }\n    inline T reflect(int k){\n        return laz[k]==ei?dat[k]:g(dat[k],laz[k]);\n    }\n    inline void eval(int k){\n        if(laz[k]==ei) return;\n        laz[(k<<1)|0]=h(laz[(k<<1)|0],laz[k]);\n        laz[(k<<1)|1]=h(laz[(k<<1)|1],laz[k]);\n        dat[k]=reflect(k);\n        laz[k]=ei;\n    }\n    inline void thrust(int k){\n        for(int i=height;i;i--) eval(k>>i);\n    }\n    inline void recalc(int k){    \n        while(k>>=1)\n            dat[k]=f(reflect((k<<1)|0),reflect((k<<1)|1));\n    }\n    void update(int a,int b,E x){\n        thrust(a+=n);\n        thrust(b+=n-1);\n        for(int l=a,r=b+1;l<r;l>>=1,r>>=1){\n            if(l&1) laz[l]=h(laz[l],x),l++;\n            if(r&1) --r,laz[r]=h(laz[r],x);\n        }\n        recalc(a);\n        recalc(b);\n    }\n    void set_val(int a,T x){\n        thrust(a+=n);\n        dat[a]=x;laz[a]=ei;\n        recalc(a);\n    }\n    T query(int a,int b){\n        thrust(a+=n);\n        thrust(b+=n-1);\n        T vl=ti,vr=ti;\n        for(int l=a,r=b+1;l<r;l>>=1,r>>=1) {\n            if(l&1) vl=f(vl,reflect(l++));\n            if(r&1) vr=f(reflect(--r),vr);\n        }\n        return f(vl,vr);\n    }\n};\n\nsigned main(){\n    \n    int n, q; cin >> n >> q;\n    using P = pair<int, int>;\n    auto f = [](P a, P b){ return P(a.first + b.first, a.second + b.second); };\n    auto g = [](P a, int b){ return P(a.second * b, a.second); };\n    auto h = [](int a, int b){ return b != INT_MAX ? b : a; };\n    LazySegmentTree<P, int, decltype(f), decltype(g), decltype(h)> sg(f, g, h, P(0, 0), INT_MAX);\n    sg.build(vector<P>(n, P(0, 1)));\n    \n    for(int i = 0; i < q; i++){\n        int com; cin >> com;\n        if(!com){\n            int s, t, x; cin >> s >> t >> x;\n            sg.update(s, t + 1, x);\n        }else{\n            int s, t; cin >> s >> t;\n            cout << sg.query(s, t + 1).first << endl;\n        }   \n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#define _CRT_SECURE_NO_WARNINGS\n#include <array>\n#include <cstddef>\n#include <cstdint>\n#include <cstdio>\n#include <limits>\n#include <memory>\n#include <string>\n#include <type_traits>\n\ntemplate <class Integral> class Rirange;\n\ntemplate <class Integral = std::size_t> class irange {\npublic:\n\tusing value_type = Integral;\n\tusing reference = value_type &;\n\tusing const_reference = const value_type &;\n\tclass irangeitr {\n\t\tfriend irange;\n\t\tvalue_type i;\n\t\tirangeitr(const value_type x) noexcept : i(x) {}\n\n\tpublic:\n\t\tvoid operator++() noexcept { ++i; }\n\t\tvalue_type &operator*() noexcept { return i; }\n\t\tconst_reference operator*() const noexcept { return i; }\n\t\tbool operator!=(const irangeitr &x) const noexcept { return i < x.i; }\n\t};\n\nprivate:\n\tconst value_type f, l;\n\npublic:\n\tirange(const value_type first, const value_type last) noexcept\n\t\t: f(first), l(last) {}\n\tirangeitr begin() const noexcept { return irangeitr(f); }\n\tirangeitr end() const noexcept { return irangeitr(l); }\n\tRirange<value_type> rev() const noexcept {\n\t\treturn Rirange<value_type>(l - 1, f - 1);\n\t}\n};\ntemplate <class Integral = std::size_t> class Rirange {\npublic:\n\tusing value_type = Integral;\n\tusing reference = value_type &;\n\tusing const_reference = const value_type &;\n\tclass Rirangeitr {\n\t\tfriend Rirange;\n\t\tvalue_type i;\n\t\tRirangeitr(const value_type x) noexcept : i(x) {}\n\n\tpublic:\n\t\tvoid operator++() noexcept { --i; }\n\t\treference operator*() noexcept { return i; }\n\t\tconst_reference operator*() const noexcept { return i; }\n\t\tbool operator!=(const Rirangeitr &x) const noexcept {\n\t\t\treturn (!~x.i && ~i) || x.i < i;\n\t\t}\n\t};\n\nprivate:\n\tconst value_type f, l;\n\npublic:\n\tRirange(const value_type x, const value_type y) noexcept : f(x), l(y) {}\n\tRirangeitr begin() const noexcept { return Rirangeitr(f); }\n\tRirangeitr end() const noexcept { return Rirangeitr(l); }\n\tirange<value_type> rev() const noexcept {\n\t\treturn irange<value_type>(l + 1, f + 1);\n\t}\n};\n\ntemplate <class T> bool maxi(T &a, const T &b) {\n\tif (b < a)\n\t\treturn 0;\n\ta = b;\n\treturn 1;\n}\ntemplate <class T> bool mini(T &a, const T &b) {\n\tif (a < b)\n\t\treturn 0;\n\ta = b;\n\treturn 1;\n}\ntemplate <class T> bool smaxi(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T> bool smini(T &a, const T &b) {\n\tif (b < a) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nstruct customIO {\n\tint c;\n\tbool f;\n\tstd::array<int, 30> buf;\n\tconst std::array<int, 10> itoc;\n\tstd::array<std::uint_least8_t, 256> ctoi_base;\n\tconst std::uint_least8_t *const ctoi;\n\tvoid get_c() { c = fgetc(stdin); }\n\tvoid put_c(int x) { fputc(x, stdout); }\n\tbool vacant() { return c == ' ' || c == '\\n'; }\n\toperator int() { return 0; }\n\n\texplicit customIO()\n\t\t: itoc({ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' }),\n\t\tctoi(std::addressof(ctoi_base[-static_cast<std::int_fast16_t>(\n\t\t\tstd::numeric_limits<char>::min())])) {\n\t\tfor (std::uint_least8_t i = 0; i < 10; ++i)\n\t\t\tctoi_base[static_cast<int>(\"0123456789\"[i]) -\n\t\t\tstatic_cast<std::int_fast16_t>(\n\t\t\t\tstd::numeric_limits<char>::min())] = i;\n\t}\n\t// in\n\n\tvoid cueing() {\n\t\twhile (get_c(), vacant())\n\t\t\t;\n\t}\n\ttemplate <class T>\n\tauto operator>>(T &d) ->\n\t\ttypename std::enable_if<std::is_signed<T>::value, customIO &>::type {\n\t\td = 0;\n\t\tf = 0;\n\t\tcueing();\n\t\tif (c == '-')\n\t\t\tf = 1, get_c();\n\t\tdo\n\t\t\td = d * 10 + ctoi[c];\n\t\twhile (get_c(), !vacant());\n\t\tif (f)\n\t\t\td = -d;\n\t\treturn *this;\n\t}\n\ttemplate <class T>\n\tauto operator>>(T &d) ->\n\t\ttypename std::enable_if<!std::is_signed<T>::value, customIO &>::type {\n\t\td = 0;\n\t\tcueing();\n\t\tdo\n\t\t\td = d * 10 + ctoi[c];\n\t\twhile (get_c(), !vacant());\n\t\treturn *this;\n\t}\n\tcustomIO &operator>>(char &d) {\n\t\tcueing();\n\t\td = c;\n\t\treturn *this;\n\t}\n\tcustomIO &operator>>(double &d) {\n\t\tscanf(\"%lf\", &d);\n\t\treturn *this;\n\t}\n\tcustomIO &operator>>(std::string &d) {\n\t\td.clear();\n\t\tcueing();\n\t\tdo\n\t\t\td.push_back(c);\n\t\twhile (get_c(), !vacant());\n\t\treturn *this;\n\t}\n\ttemplate <class T> T input() {\n\t\tT d;\n\t\t*this >> d;\n\t\treturn d;\n\t}\n\n\t// out\n\n\ttemplate <class T>\n\tauto operator<<(T d) ->\n\t\ttypename std::enable_if<std::is_signed<T>::value, customIO &>::type {\n\t\tc = 0;\n\t\tf = 0;\n\t\tif (d < static_cast<T>(0))\n\t\t\tf = 1, d = -d;\n\t\twhile (d)\n\t\t\tbuf[c++] = itoc[d % 10], d /= 10;\n\t\tif (!c)\n\t\t\tbuf[c++] = itoc[0];\n\t\tif (f)\n\t\t\tput_c('-');\n\t\twhile (c--)\n\t\t\tput_c(buf[c]);\n\t\treturn *this;\n\t}\n\ttemplate <class T>\n\tauto operator<<(T d) ->\n\t\ttypename std::enable_if<!std::is_signed<T>::value, customIO &>::type {\n\t\tc = 0;\n\t\twhile (d)\n\t\t\tbuf[c++] = itoc[d % 10], d /= 10;\n\t\tif (!c)\n\t\t\tbuf[c++] = itoc[0];\n\t\twhile (c--)\n\t\t\tput_c(buf[c]);\n\t\treturn *this;\n\t}\n\tcustomIO &operator<<(char d) {\n\t\tput_c(d);\n\t\treturn *this;\n\t}\n\tcustomIO &operator<<(double d) {\n\t\tprintf(\"%f\", d);\n\t\treturn *this;\n\t}\n\tcustomIO &operator<<(const std::string &d) {\n\t\tfor (const auto e : d)\n\t\t\tput_c(e);\n\t\treturn *this;\n\t}\n\tcustomIO &operator<<(const char *d) {\n\t\twhile (*d != '\\0')\n\t\t\tput_c(*(d++));\n\t\treturn *this;\n\t}\n\tvoid endl() { put_c('\\n'); }\n\tvoid space() { put_c(' '); }\n} IO;\n\nusing int32 = std::int_fast32_t;\nusing int64 = std::int_fast64_t;\nusing uint32 = std::uint_fast32_t;\nusing uint64 = std::uint_fast64_t;\nusing intl32 = std::int_least32_t;\nusing intl64 = std::int_least64_t;\nusing uintl32 = std::uint_least32_t;\nusing uintl64 = std::uint_least64_t;\n#include <cassert>\n#include <functional>\n#include <utility>\n#include <vector>\n\ntemplate <typename ValueMonoid, typename OperatorMonoid, class Modify>\nclass LazySegmentTree {\npublic:\n\tusing value_type = ValueMonoid;\n\tusing reference = value_type &;\n\tusing const_reference = const value_type &;\n\tusing operator_type = OperatorMonoid;\n\nprivate:\n\tusing container_type = std::vector<std::pair<value_type, operator_type>>;\n\npublic:\n\tusing size_type = typename container_type::size_type;\n\nprivate:\n\tconst Modify m;\n\tconst size_type size_, height, capacity;\n\tcontainer_type tree;\n\tstatic size_type getheight(const size_type &size) noexcept {\n\t\tsize_type ret = 0;\n\t\twhile (static_cast<size_type>(1) << ret < size)\n\t\t\t++ret;\n\t\treturn ret;\n\t}\n\tvalue_type reflect(const size_type &index) {\n\t\treturn m(tree[index].first, tree[index].second);\n\t}\n\tvoid recalc(const size_type &index) {\n\t\ttree[index].first = reflect(index << 1) + reflect(index << 1 | 1);\n\t}\n\tvoid assign(const size_type &index, const operator_type &data) {\n\t\ttree[index].second = tree[index].second + data;\n\t}\n\tvoid push(const size_type &index) {\n\t\tassign(index << 1, tree[index].second);\n\t\tassign(index << 1 | 1, tree[index].second);\n\t\ttree[index].second = operator_type();\n\t}\n\tvoid propagate(const size_type &index) {\n\t\tfor (size_type i = height; i; --i)\n\t\t\tpush(index >> i);\n\t}\n\tvoid thrust(const size_type &index) {\n\t\ttree[index].first = reflect(index);\n\t\tpush(index);\n\t}\n\tvoid evaluate(const size_type &index) {\n\t\tfor (size_type i = height; i; --i)\n\t\t\tthrust(index >> i);\n\t}\n\tvoid build(size_type index) {\n\t\twhile (index >>= 1)\n\t\t\trecalc(index);\n\t}\n\npublic:\n\texplicit LazySegmentTree(const size_type &size, const Modify &m = Modify())\n\t\t: m(m), size_(size), height(getheight(size_)),\n\t\tcapacity(static_cast<size_type>(1) << height), tree(capacity << 1) {}\n\tvoid update(size_type begin, size_type end, const operator_type &data) {\n\t\tassert(begin <= end);\n\t\tassert(begin <= size());\n\t\tassert(end <= size());\n\t\tbegin += capacity;\n\t\tend += capacity;\n\t\tpropagate(begin);\n\t\tpropagate(end - 1);\n\t\tfor (size_type left = begin, right = end; left < right;\n\t\t\tleft >>= 1, right >>= 1) {\n\t\t\tif (left & 1)\n\t\t\t\tassign(left++, data);\n\t\t\tif (right & 1)\n\t\t\t\tassign(right - 1, data);\n\t\t}\n\t\tbuild(begin);\n\t\tbuild(end - 1);\n\t}\n\tvoid update(size_type index,\n\t\tconst std::function<value_type(const_reference)> &f) {\n\t\tassert(index < size());\n\t\tindex += capacity;\n\t\tpropagate(index);\n\t\ttree[index].first = f(reflect(index));\n\t\ttree[index].second = operator_type();\n\t\tbuild(index);\n\t}\n\tvoid update(const size_type index, const_reference data) {\n\t\tassert(index < size());\n\t\tupdate(index, [&data](const_reference d) { return data; });\n\t}\n\tvalue_type range(size_type begin, size_type end) {\n\t\tassert(begin <= end);\n\t\tassert(begin <= size());\n\t\tassert(end <= size());\n\t\tbegin += capacity;\n\t\tend += capacity;\n\t\tevaluate(begin);\n\t\tevaluate(end - 1);\n\t\tvalue_type retL, retR;\n\t\tfor (; begin < end; begin >>= 1, end >>= 1) {\n\t\t\tif (begin & 1)\n\t\t\t\tretL = retL + reflect(begin++);\n\t\t\tif (end & 1)\n\t\t\t\tretR = reflect(end - 1) + retR;\n\t\t}\n\t\treturn retL + retR;\n\t}\n\tsize_type search(const std::function<bool(const_reference)> &b) {\n\t\tif (b(value_type()))\n\t\t\treturn 0;\n\t\tif (!b(reflect(1)))\n\t\t\treturn size() + 1;\n\t\tvalue_type acc;\n\t\tsize_type i = 1;\n\t\twhile (i < capacity) {\n\t\t\tthrust(i);\n\t\t\tif (!b(acc + reflect(i <<= 1)))\n\t\t\t\tacc = acc + reflect(i++);\n\t\t}\n\t\treturn i - capacity + 1;\n\t}\n\tconst_reference operator[](size_type index) {\n\t\tassert(index < size());\n\t\tindex += capacity;\n\t\tevaluate(index);\n\t\ttree[index].first = reflect(index);\n\t\ttree[index].second = operator_type();\n\t\treturn tree[index].first;\n\t}\n\tsize_type size() const noexcept { return size_; }\n\tbool empty() const noexcept { return !size_; }\n};\n\ntemplate <typename V, typename O, class F>\nLazySegmentTree<V, O, F>\nmake_Lazy(const typename LazySegmentTree<V, O, F>::size_type &size,\n\tconst F &f) {\n\treturn LazySegmentTree<V, O, F>(size, f);\n}\n#include <algorithm>\n#include <cstddef>\n#include <limits>\n#include <utility>\n\ntemplate <class T> struct Ass {\n\tusing value_type = T;\n\tvalue_type a;\n\tbool f;\n\tAss() : f(0) {}\n\texplicit Ass(const value_type &x) : a(x), f(1) {}\n\texplicit Ass(value_type &&x) : a(std::move(x)), f(1) {}\n\tAss operator+(const Ass &o) const { return o.f ? o : *this; }\n};\n\ntemplate <class T> struct Add {\n\tusing value_type = T;\n\tvalue_type a;\n\tAdd() : a(0) {}\n\texplicit Add(const value_type &x) : a(x) {}\n\texplicit Add(value_type &&x) : a(std::move(x)) {}\n\tAdd operator+(const Add &o) const { return Add(a + o.a); }\n};\n\ntemplate <class T> struct Mini {\n\tusing value_type = T;\n\tvalue_type a;\n\tMini() : a(std::numeric_limits<value_type>::max()) {}\n\texplicit Mini(const value_type &x) : a(x) {}\n\texplicit Mini(value_type &&x) : a(std::move(x)) {}\n\tMini operator+(const Mini &o) const { return Mini(std::min(a, o.a)); }\n\tMini operator*(const Ass<value_type> &o) const {\n\t\treturn o.f ? Mini(o.a) : *this;\n\t}\n\tMini operator*(const Add<value_type> &o) const { return Mini(a + o.a); }\n};\n\ntemplate <class T> struct Maxi {\n\tusing value_type = T;\n\tvalue_type a;\n\tMaxi() : a(std::numeric_limits<value_type>::min()) {}\n\texplicit Maxi(const value_type &x) : a(x) {}\n\texplicit Maxi(value_type &&x) : a(std::move(x)) {}\n\tMaxi operator+(const Maxi &o) const { return Maxi(std::max(a, o.a)); }\n\tMaxi operator*(const Ass<value_type> &o) const {\n\t\treturn o.f ? Maxi(o.a) : *this;\n\t}\n\tMaxi operator*(const Add<value_type> &o) const { return Maxi(a + o.a); }\n};\n\ntemplate <class T> struct Sum {\n\tusing value_type = T;\n\tusing size_type = std::size_t;\n\tvalue_type a;\n\tsize_type s;\n\tSum() : a(0), s(0) {}\n\texplicit Sum(const value_type &x, const size_type y) : a(x), s(y) {}\n\texplicit Sum(value_type &&x, const size_type y) : a(std::move(x)), s(y) {}\n\tSum operator+(const Sum &o) const { return Sum(a + o.a, s + o.s); }\n\tSum operator*(const Ass<value_type> &o) const {\n\t\treturn o.f ? Sum(o.a * s, s) : *this;\n\t}\n\tSum operator*(const Add<value_type> &o) const { return Sum(a + o.a * s, s); }\n};\n\ntemplate<class T,class U>\nstruct multi {\n\tT operator()(const T &x, const U &y)const {\n\t\treturn x*y;\n\t}\n};\nint main() {\n\tusing S = Sum<int64>;\n\tusing A = Ass<int64>;\n\tconst auto n = IO.input<uint32>();\n\tuint32 q;\n\tIO >> q;\n\tLazySegmentTree<S, A, multi<S, A>> T(n);\n\tfor (const auto i : irange<>(0, n))\n\t\tT.update(i, S(0, 1));\n\tuint32 c, s, t;\n\tint64 x;\n\twhile (q--) {\n\t\tIO >> c >> s >> t;\n\t\tif (c)\n\t\t\tIO << T.range(s, t + 1).a << '\\n';\n\t\telse\n\t\t\tIO >> x, T.update(s, t + 1, A(x));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate <typename T,typename E>\nstruct SegmentTree{\n  using F = function<T(T,T)>;\n  using G = function<T(T,E)>;\n  using H = function<E(E,E)>;\n  using P = function<E(E,size_t)>;\n  Int n;\n  F f;\n  G g;\n  H h;\n  T ti;\n  E ei;\n  P p;\n  vector<T> dat;\n  vector<E> laz;\n  SegmentTree(Int n_,F f,G g,H h,T ti,E ei,\n\t      P p=[](E a,size_t b){b++;return a;}):\n    f(f),g(g),h(h),ti(ti),ei(ei),p(p){\n    init(n_);\n  }\n  void init(Int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.assign(2*n-1,ti);\n    laz.assign(2*n-1,ei);\n  }\n  void build(Int n_, vector<T> v){\n    for(Int i=0;i<n_;i++) dat[i+n-1]=v[i];\n    for(Int i=n-2;i>=0;i--)\n      dat[i]=f(dat[i*2+1],dat[i*2+2]);\n  }\n  inline void eval(Int len,Int k){\n    if(laz[k]==ei) return;\n    if(k*2+1<n*2-1){\n      laz[k*2+1]=h(laz[k*2+1],laz[k]);\n      laz[k*2+2]=h(laz[k*2+2],laz[k]);\n    }\n    dat[k]=g(dat[k],p(laz[k],len));\n    laz[k]=ei;\n  }\n  T update(Int a,Int b,E x,Int k,Int l,Int r){\n    eval(r-l,k);\n    if(r<=a||b<=l) return dat[k];\n    if(a<=l&&r<=b){\n      laz[k]=h(laz[k],x);\n      return g(dat[k],p(laz[k],r-l));\n    }\n    return dat[k]=f(update(a,b,x,k*2+1,l,(l+r)/2),\n\t\t    update(a,b,x,k*2+2,(l+r)/2,r));\n  }\n  T update(Int a,Int b,E x){\n    return update(a,b,x,0,0,n);\n  }\n  T query(Int a,Int b,Int k,Int l,Int r){\n    eval(r-l,k);\n    if(r<=a||b<=l) return ti;\n    if(a<=l&&r<=b) return dat[k];\n    T vl=query(a,b,k*2+1,l,(l+r)/2);\n    T vr=query(a,b,k*2+2,(l+r)/2,r);\n    return f(vl,vr);\n  }\n  T query(Int a,Int b){\n    return query(a,b,0,0,n);\n  }\n  void update(Int k,T x){\n    query(k,k+1);//evaluate\n    k+=n-1;\n    dat[k]=x;\n    while(k){\n      k=(k-1)/2;\n      dat[k]=f(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,q;\n  cin>>n>>q;\n  \n  Int INF = 1e9;\n  SegmentTree<Int, Int>::F f=[&](Int a,Int b){return a+b;};\n  SegmentTree<Int, Int>::G g=[&](Int a,Int b){return b==INF?a:b;};\n  SegmentTree<Int, Int>::H h=[&](Int a,Int b){return b==INF?a:b;};\n  SegmentTree<Int, Int>::P p=[&](Int a,size_t b){return a==INF?a:a*b;};\n\n  SegmentTree<Int, Int> seg(n,f,g,h,0,INF,p);\n  seg.build(n,vector<Int>(n,0));\n\n  for(Int i=0;i<q;i++){\n    Int c,s,t,x;\n    cin>>c>>s>>t;\n    t++;\n    if(c){\n      cout<<seg.query(s,t)<<endl;\n    }else{\n      cin>>x;\n      seg.update(s,t,x);\n    }\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define Rep(i,n) for(int i=0;i<(int)(n);i++)\n#define For(i,n1,n2) for(int i=(int)(n1);i<(int)(n2);i++)\n#define REP(i,n) for(ll i=0;i<(ll)(n);i++)\n#define RREP(i,n) for(ll i=((ll)(n)-1);i>=0;i--)\n#define FOR(i,n1,n2) for(ll i=(ll)(n1);i<(ll)(n2);i++)\n#define RFOR(i,n1,n2) for(ll i=((ll)(n1)-1);i>=(ll)(n2);i--)\n#define all(a)  (a).begin(),(a).end()\n#define IOS std::cin.tie(0),std::ios::sync_with_stdio(false)\n\nnamespace idaten {\n\n\tusing namespace std;\n\tusing ll = int_fast64_t;\n\tusing ull = uint_fast64_t;\n\tusing P = std::pair<int64_t, int64_t>;\n\ttemplate<typename T1, typename T2> inline bool chmin(T1& a, T2 b) { if (a > b) { a = b; return 1; }return 0; }\n\ttemplate<typename T1, typename T2> inline bool chmax(T1& a, T2 b) { if (a < b) { a = b; return 1; }return 0; }\n\ttemplate<class Type>struct is_vector : std::false_type {};\n\ttemplate<class ValueType, class Alloc>struct is_vector<std::vector<ValueType, Alloc>> : std::true_type {};\n\ttemplate <typename T> inline std::ostream& operator << (std::ostream& out, const std::vector<T>& v) {\n\t\tif (v.empty())return out;\n\t\tconstexpr bool is_vector_v = is_vector<T>::value;\n\t\tif (is_vector_v)for (auto itr = v.begin(); itr != v.end();)out << (*itr), out << ((++itr != v.end()) ? \"\\n\" : \"\");\n\t\telse for (auto itr = v.begin(); itr != v.end();)out << (*itr), out << ((++itr != v.end()) ? \" \" : \"\");\n\t\treturn out;\n\t}\n\tinline void put() {}\n\ttemplate<class T> inline void put(const T& first) { std::cout << first << \"\\n\"; }\n\ttemplate<class T, class... N> inline void put(const T& first, const N& ... rest) { std::cout << first << \" \"; put(rest...); }\n\tinline void putn() {}\n\ttemplate<class T, class... N> inline void putn(const T& first, const N& ... rest) { std::cout << first << \"\\n\"; putn(rest...); }\n\t//*\n\ttemplate<typename F,typename T>\n\tclass Monoid {\n\tpublic:\n\t\tconst T unit; // 単位元\n\t\tconst F f; // 関数\n\t\tconst int flag;\n\t\tMonoid(F f, T unit, int flag = 0) : f(f), unit(unit), flag(flag) {}\n\t};\n\n\ttemplate<typename Up, typename Proc>\n\tclass LazySegmentTree {\n\tpublic:\n\t\tint sz = 1;\n\t\tconst Up up;\t\t// 更新関数\n\t\tconst Proc proc;\t// 取得関数\n\t\tusing T = remove_const_t<decltype(up.unit)>; // up関数の型\n\t\tvector<T> seg; // セグメント木のデータ配列\n\t\tvector<T> lazy; // 遅延評価用の配列\n\t\tLazySegmentTree(int n, Up up, Proc proc) : up(up), proc(proc) {\n\t\t\twhile (sz < n) sz <<= 1;\n\t\t\tseg.clear();\n\t\t\tlazy.clear();\n\t\t\tseg.resize(sz * 2, proc.unit);\n\t\t\tlazy.resize(sz * 2, up.unit);\n\t\t}\n\t\tT cont(T& a, int b) { // aをb回procした値\n\t\t\tif (b <= 0)return proc.unit;\n\t\t\tif (b % 2 == 0) {\n\t\t\t\tT c = cont(a, b / 2);\n\t\t\t\treturn proc.f(c, c);\n\t\t\t} else {\n\t\t\t\treturn proc.f(a, cont(a, b - 1));\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\tT contSum(T& a, int b) { // procが加算のとき\n\t\t\treturn a * b;\n\t\t}\n\t\tT contId(T& a, int b) { // procが繰り返しても同じ値になるもの(max,min,etc...)\n\t\t\treturn a;\n\t\t}\n\t\tvoid init(std::vector<T> ary) { // aryで初期化する\n\t\t\tconst int n = (int)ary.size();\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tset(i, ary[i]);\n\t\t\t}\n\t\t\tfor (int i = sz - 2; i >= 0; --i) {\n\t\t\t\tseg[i] = proc.f(seg[2 * i + 1], seg[2 * i + 2]);\n\t\t\t}\n\t\t}\n\t\tvoid init(T a) { // sz個の全要素をaで初期化する\n\t\t\tfor (int i = 0; i < sz; ++i) {\n\t\t\t\tset(i, a);\n\t\t\t}\n\t\t\tfor (int i = sz - 2; i >= 0; --i) {\n\t\t\t\tseg[i] = proc.f(seg[2 * i + 1], seg[2 * i + 2]);\n\t\t\t}\n\t\t}\n\t\tinline void set(const int& k, const T& x) {// 左からk番目の葉にxを代入する\n\t\t\tseg[sz - 1 + k] = x;\n\t\t}\n\n\t\t// k 番目のノードについて遅延評価を行う\n\t\tvoid eval(int k, int l, int r) { // k = [l,r)\n\t\t\tif (lazy[k] != up.unit) {\n\t\t\t\tint len = r - l;\n\t\t\t\tif (len > 1) {\n\t\t\t\t\tlazy[2 * k + 1] = up.f(lazy[2 * k + 1], lazy[k]);\n\t\t\t\t\tlazy[2 * k + 2] = up.f(lazy[2 * k + 2], lazy[k]);\n\t\t\t\t}\n\t\t\t\tif (proc.flag == 0) {\n\t\t\t\t\tseg[k] = up.f(seg[k], cont(lazy[k], len));\n\t\t\t\t} else if (proc.flag == 1) {\n\t\t\t\t\tseg[k] = up.f(seg[k], contSum(lazy[k], len));\n\t\t\t\t} else if (proc.flag == 2) {\n\t\t\t\t\tseg[k] = up.f(seg[k], contId(lazy[k], len));\n\t\t\t\t}\n\t\t\t\tlazy[k] = up.unit;\n\t\t\t}\n\t\t}\n\t\tvoid update(int a, int b, T x, int k = 0, int l = 0, int r = -1) { // i in [a,b)に更新up(seg[i],a)を適用\n\t\t\tif (r < 0) r = sz;\n\t\t\teval(k, l, r);\n\t\t\tif (b <= l || r <= a) return;\n\t\t\tif (a <= l && r <= b) {// 被覆\n\t\t\t\tlazy[k] = up.f(lazy[k], x);\n\t\t\t\teval(k, l, r);\n\t\t\t} else {// 非被覆\n\t\t\t\tupdate(a, b, x, 2 * k + 1, l, (l + r) / 2);\n\t\t\t\tupdate(a, b, x, 2 * k + 2, (l + r) / 2, r);\n\t\t\t\tseg[k] = proc.f(seg[2 * k + 1], seg[2 * k + 2]);\n\t\t\t}\n\t\t}\n\t\tT query(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\t\tif (r < 0) r = sz;\n\t\t\tif (b <= l || r <= a) return proc.unit;\n\t\t\teval(k, l, r);\n\t\t\tif (a <= l && r <= b) return seg[k];\n\t\t\tT vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n\t\t\tT vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n\t\t\treturn proc.f(vl, vr);\n\t\t}\n\t};\n\n\t\n\tvoid solve() {\n\t\tusing type = int64_t;\n\t\tauto assign_lambda = [](type& a, type b) {\n\t\t\treturn b;\n\t\t};\n\t\tconstexpr type assignUnit = std::numeric_limits<type>::min();\n\t\tMonoid<decltype(assign_lambda),decltype(assignUnit)> assign(assign_lambda, assignUnit, 2);\n\t\t//Monoid assign(assign_lambda, assignUnit, 2);\n\n\t\tauto sum_lambda = [](type& a, type b) {\n\t\t\treturn a + b;\n\t\t};\n\t\tconstexpr type sumUnit = 0;\n\t\tMonoid<decltype(sum_lambda), decltype(sumUnit)> sum(sum_lambda, sumUnit, 1);\n\t\t//Monoid sum(sum_lambda, sumUnit, 1);\n\n\t\tauto min_lambda = [](type& a, type b) {\n\t\t\tif (a < b)return a;\n\t\t\treturn b;\n\t\t};\n\t\tconstexpr type minUnit = numeric_limits<type>::max();\n\t\tMonoid<decltype(min_lambda), decltype(minUnit)> intmin(min_lambda, minUnit, 2);\n\t\t//Monoid intmin(min_lambda, minUnit, 2);\n\n\t\tauto max_lambda = [](type& a, type b) {\n\t\t\tif (a > b)return a;\n\t\t\treturn b;\n\t\t};\n\t\tconstexpr type maxUnit = std::numeric_limits<type>::min();\n\t\tMonoid<decltype(max_lambda), decltype(maxUnit)> intmax(max_lambda, maxUnit, 2);\n\t\t//Monoid intmax(max_lambda, maxUnit, 2);\n\n\t\tint n, q;\n\t\tcin >> n >> q;\n\t\tLazySegmentTree<decltype(assign), decltype(sum)> lst(n, assign, sum);\n\t\tlst.init(0);\n\t\t//LazySegmentTree lst(n, assignt, intmin);\n\t\tREP(i, q) {\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tif (a) {\n\t\t\t\tint s, t;\n\t\t\t\tcin >> s >> t;\n\t\t\t\t//s--, t--;\n\t\t\t\tput(lst.query(s, t + 1));\n\t\t\t} else {\n\t\t\t\tint s, t, x;\n\t\t\t\tcin >> s >> t >> x;\n\t\t\t\t//s--, t--;\n\t\t\t\tlst.update(s, t + 1, x);\n\t\t\t}\n\n\t\t}\n\t}\n} // namespace idaten\n\nint main() {\n\tidaten::solve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n#ifdef _DEBUG\n#define _GLIBCXX_DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int long long\n#define ll long long\n#define DBG 1\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#define rrep(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define loop(n) rep(loop, (0), (n))\n#define all(c) begin(c), end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\nusing pii = pair<int, int>;\n// template<class T> ostream &operator<<(ostream &os,T &t){dump(t);return os;}\ntemplate <typename T, typename S>istream &operator>>(istream &is, pair<T, S> &p) { is >> p.first >> p.second; return is; }\n//template <typename T, typename S>ostream &operator<<(ostream &os, pair<T, S> &p) {os << p.first << \" \" << p.second;return os;}\n\ntemplate <typename T> void printvv(const vector<vector<T>> &v) {\n\tcerr << endl;\n\trep(i, 0, v.size()) rep(j, 0, v[i].size()) {\n\t\tif (typeid(v[i][j]).name() == typeid(INF).name() and v[i][j] == INF) {\n\t\t\tcerr << \"INF\";\n\t\t}\n\t\telse\n\t\t\tcerr << v[i][j];\n\t\tcerr << (j == v[i].size() - 1 ? '\\n' : ' ');\n\t}\n\tcerr << endl;\n}\n\n#ifndef _DEBUG\n#define printvv(...)\n#endif\nvoid YES(bool f) { cout << (f ? \"YES\" : \"NO\") << endl; }\nvoid Yes(bool f) { cout << (f ? \"Yes\" : \"No\") << endl; }\ntemplate <class T, class U>bool chmin(T& a, U b) { if (a > b) { a = b; return true; }return false; }\ntemplate <class T, class U>bool chmax(T& a, U b) { if (a < b) { a = b; return true; }return false; }\ntemplate< typename Monoid, typename OperatorMonoid, typename F, typename G, typename H>\nstruct LazySegmentTree {\n\n\tint sz, height;\n\tvector< Monoid > data;\n\tvector< OperatorMonoid > lazy;\n\tconst F f;\n\tconst G g;\n\tconst H h;\n\tconst Monoid M1;\n\tconst OperatorMonoid OM0;\n\n\n\tLazySegmentTree(int n, const F f, const G g, const H h,\n\t\tconst Monoid &M1, const OperatorMonoid OM0)\n\t\t: f(f), g(g), h(h), M1(M1), OM0(OM0) {\n\t\tsz = 1;\n\t\theight = 0;\n\t\twhile (sz < n) sz <<= 1, height++;\n\t\tdata.assign(2 * sz, M1);\n\t\tlazy.assign(2 * sz, OM0);\n\t}\n\n\tvoid set(int k, const Monoid &x) {\n\t\tdata[k + sz] = x;\n\t}\n\n\tvoid build() {\n\t\tfor (int k = sz - 1; k > 0; k--) {\n\t\t\tdata[k] = f(data[2 * k + 0], data[2 * k + 1]);\n\t\t}\n\t}\n\n\tinline void propagate(int k) {\n\t\tif (lazy[k] != OM0) {\n\t\t\tlazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n\t\t\tlazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n\t\t\tdata[k] = reflect(k);\n\t\t\tlazy[k] = OM0;\n\t\t}\n\t}\n\n\tinline Monoid reflect(int k) {\n\t\treturn lazy[k] == OM0 ? data[k] : g(data[k], lazy[k]);\n\t}\n\n\tinline void recalc(int k) {\n\t\twhile (k >>= 1) data[k] = f(reflect(2 * k + 0), reflect(2 * k + 1));\n\t}\n\n\tinline void thrust(int k) {\n\t\tfor (int i = height; i > 0; i--) propagate(k >> i);\n\t}\n\n\tvoid update(int a, int b, const OperatorMonoid &x) {\n\t\tthrust(a += sz);\n\t\tthrust(b += sz - 1);\n\t\tfor (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n\t\t\tif (l & 1) lazy[l] = h(lazy[l], x), ++l;\n\t\t\tif (r & 1) --r, lazy[r] = h(lazy[r], x);\n\t\t}\n\t\trecalc(a);\n\t\trecalc(b);\n\t}\n\n\tMonoid query(int a, int b) {\n\t\tthrust(a += sz);\n\t\tthrust(b += sz - 1);\n\t\tMonoid L = M1, R = M1;\n\t\tfor (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n\t\t\tif (l & 1) L = f(L, reflect(l++));\n\t\t\tif (r & 1) R = f(reflect(--r), R);\n\t\t}\n\t\treturn f(L, R);\n\t}\n\n\tMonoid operator[](const int &k) {\n\t\treturn query(k, k + 1);\n\t}\n\n\ttemplate< typename C >\n\tint find_subtree(int a, const C &check, Monoid &M, bool type) {\n\t\twhile (a < sz) {\n\t\t\tpropagate(a);\n\t\t\tMonoid nxt = type ? f(reflect(2 * a + type), M) : f(M, reflect(2 * a + type));\n\t\t\tif (check(nxt)) a = 2 * a + type;\n\t\t\telse M = nxt, a = 2 * a + 1 - type;\n\t\t}\n\t\treturn a - sz;\n\t}\n\n\ttemplate< typename C >\n\tint find_first(int a, const C &check) {\n\t\tMonoid L = M1;\n\t\tif (a <= 0) {\n\t\t\tif (check(f(L, reflect(1)))) return find_subtree(1, check, L, false);\n\t\t\treturn -1;\n\t\t}\n\t\tthrust(a + sz);\n\t\tint b = sz;\n\t\tfor (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n\t\t\tif (a & 1) {\n\t\t\t\tMonoid nxt = f(L, reflect(a));\n\t\t\t\tif (check(nxt)) return find_subtree(a, check, L, false);\n\t\t\t\tL = nxt;\n\t\t\t\t++a;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\n\ttemplate< typename C >\n\tint find_last(int b, const C &check) {\n\t\tMonoid R = M1;\n\t\tif (b >= sz) {\n\t\t\tif (check(f(reflect(1), R))) return find_subtree(1, check, R, true);\n\t\t\treturn -1;\n\t\t}\n\t\tthrust(b + sz - 1);\n\t\tint a = sz;\n\t\tfor (b += sz; a < b; a >>= 1, b >>= 1) {\n\t\t\tif (b & 1) {\n\t\t\t\tMonoid nxt = f(reflect(--b), R);\n\t\t\t\tif (check(nxt)) return find_subtree(b, check, R, true);\n\t\t\t\tR = nxt;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n};\n\nsigned main(signed argc, char *argv[]) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(12);\n\n\tint N, Q; cin >> N >> Q;\n\tauto f = [](pii a, pii b) {return pii(a.first + b.first, a.second + b.second); };\n\tauto g = [](pii a, int b) {return pii(a.second*b, a.second); };\n\tauto h = [](int a, int b) {return b; };\n\tLazySegmentTree<pii, int, decltype(f), decltype(g), decltype(h)>seg(N, f, g, h, pii(0, 1), INF);\n\tseg.build();\n\tloop(Q) {\n\t\tint com; cin >> com;\n\t\tif (com) {\n\t\t\tint s, t; cin >> s >> t;\n\t\t\tcout << seg.query(s, t + 1).first << endl;\n\t\t}\n\t\telse {\n\t\t\tint s, t, x; cin >> s >> t >> x;\n\t\t\tseg.update(s, t + 1, x);\n\t\t}\n\n\t}\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\ntemplate<typename LSTTrait> class LazySegTree {\n  using FoldMonoid = typename LSTTrait::FoldMonoid;\n  using ActionMonoid = typename LSTTrait::ActionMonoid;\n  using T = typename FoldMonoid::value_type;\n  using Q = typename ActionMonoid::value_type;\n\n  LSTTrait lstTrait; // apply :: (T, Q) -> T, pow :: (Q, int) -> Q\n  FoldMonoid foldM;\n  ActionMonoid actionM;\n  int size = 1;\n  vector<T> tree; // 1-indexed\n  vector<Q> lazy; // 1-indexed\n\n  void push(int i) {\n    stack<pair<int, int>> s;\n    for (int d = 1; i /= 2; d *= 2) s.emplace(i, d);\n    for (int x, d; s.size(); s.pop()) {\n      tie(x, d) = s.top();\n      update(x * 2, lazy[x], d);\n      update(x * 2 + 1, lazy[x], d);\n      lazy[x] = actionM.id();\n    }\n  }\n\n  void update(const int &i, const Q &x, const int &d) {\n    tree[i] = lstTrait.apply(tree[i], lstTrait.pow(x, d));\n    if (i < size) lazy[i] = actionM(lazy[i], x);\n  }\n\n  void build(int i) {\n    for (int d = 2; i /= 2; d *= 2) tree[i] = lstTrait.apply(foldM(tree[i * 2], tree[i * 2 + 1]), lstTrait.pow(lazy[i], d));\n  }\n\npublic:\n  LazySegTree(const int &n = 0) {\n    while (size < n) size *= 2;\n    tree.assign(size * 2, foldM.id());\n    lazy.assign(size, actionM.id());\n  }\n\n  LazySegTree(const int &n, const T &x) {\n    while (size < n) size *= 2;\n    tree.assign(size * 2, x);\n    lazy.assign(size, actionM.id());\n    for (int i = size - 1; i >= 1; i--) tree[i] = foldM(tree[i * 2], tree[i * 2 + 1]);\n  }\n\n  template<typename InputIterator> LazySegTree(InputIterator first, InputIterator last) {\n    int n = distance(first, last);\n    while (size < n) size *= 2;\n    tree.resize(size * 2, foldM.id());\n    lazy.assign(size, actionM.id());\n    copy(first, last, tree.begin() + size);\n    for (int i = size - 1; i >= 1; i--) tree[i] = foldM(tree[i * 2], tree[i * 2 + 1]);\n  }\n\n  void act(int l, int r, const Q &x) { // [l, r) += x\n    int l0 = l += size, r0 = r += size;\n    push(l0), push(r0 - 1);\n    for (int d = 1; l < r; l /= 2, r /= 2, d *= 2) {\n      if (l & 1) update(l++, x, d);\n      if (r & 1) update(--r, x, d);\n    }\n    build(l0);\n    build(r0 - 1);\n  }\n\n  T fold(int l, int r) { // [l, r)\n    T accl = foldM.id(), accr = foldM.id();\n    for (push(l += size), push((r += size) - 1); l < r; l /= 2, r /= 2) {\n      if (l & 1) accl = foldM(accl, tree[l++]);\n      if (r & 1) accr = foldM(tree[--r], accr);\n    }\n    return foldM(accl, accr);\n  }\n};\n\ntemplate<typename T> struct sumMonoid {\n  using value_type = T;\n  value_type id() { return 0; }\n  value_type operator()(const value_type &a, const value_type &b) { return a + b; }\n};\n\ntemplate<typename T> struct updateMonoid {\n  using value_type = pair<bool, T>;\n  value_type id() { return {false, T()}; }\n  value_type operator()(const value_type &a, const value_type &b) { return b.first ? b : a; }\n};\n\ntemplate<typename T> struct RSQ_RUQ_Trait {\n  using FoldMonoid = sumMonoid<T>;\n  using ActionMonoid = updateMonoid<T>;\n  typename FoldMonoid::value_type apply(typename FoldMonoid::value_type t, typename ActionMonoid::value_type q) { return q.first ? q.second : t; }\n  typename ActionMonoid::value_type pow(typename ActionMonoid::value_type q, const int &d) { return {q.first, q.second * d}; }\n};\n\nmain {\n  int n, q;\n  cin >> n >> q;\n  LazySegTree<RSQ_RUQ_Trait<int>> lst(n);\n  while (q--) {\n    if (in()) {\n      int s, t;\n      cin >> s >> t;\n      cout << lst.fold(s, t + 1) << endl;\n    } else {\n      int s, t, x;\n      cin >> s >> t >> x;\n      lst.act(s, t + 1, {true, x});\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct lst\n{\nprivate:\n    int n;\n    vector<ll> node;\n    vector<ll> lazy;\n    vector<bool> lflg;\n\n    void lazy2node(int k, int l, int r)\n    {\n        if(lflg[k])\n        {\n            node[k]=(r-l+1)*lazy[k];\n            prop(lazy[k], k, l, r);\n            lazy[k]=0;\n            lflg[k]=false;\n        }\n    }\n\n    void prop(ll v, int k, int l, int r)\n    {\n        if(r-l>0)\n        {\n            lazy[2*k+1]=lazy[2*k+2]=v;\n            lflg[2*k+1]=lflg[2*k+2]=true;\n        }\n    }\n\npublic:\n    lst(int sz)\n    {\n        n=1; while(n<sz) n*=2;\n        node.resize(2*n-1, 0);\n        lazy.resize(2*n-1, 0);\n        lflg.resize(2*n-1, false);\n    }\n    void update(int qa, int qb, ll v, int k=0, int l=0, int r=-1)\n    {\n        if(r<0) r=n-1;\n        lazy2node(k, l, r);\n        if(qb<l || r<qa) return; \n        if(qa<=l && r<=qb)\n        {\n            node[k]=(r-l+1)*v;\n            prop(v, k, l, r);\n        }\n        else\n        {\n            int m=(l+r)/2;\n            update(qa, qb, v, 2*k+1, l, m);\n            update(qa, qb, v, 2*k+2, m+1, r);\n            node[k]=node[2*k+1]+node[2*k+2];\n        }\n    }\n\n    ll get(int qa, int qb, int k=0, int l=0, int r=-1)\n    {\n        if(r<0) r=n-1;\n        lazy2node(k, l, r);\n        if(qb<l || r<qa) return 0;\n        if(qa<=l && r<=qb) return node[k];\n        else\n        {\n            int m=(l+r)/2;\n            ll ls=get(qa, qb, 2*k+1, l, m);\n            ll rs=get(qa, qb, 2*k+2, m+1, r);\n            return ls+rs;\n        }\n    }\n};\n\nint main()\n{\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n    lst tree=lst(n);\n    for(int i=0; i<q; i++)\n    {\n        int c;\n        scanf(\"%d\", &c);\n        if(c)\n        {\n            int s, t;\n            scanf(\"%d %d\", &s, &t);\n            printf(\"%lld\\n\", tree.get(s,t));\n        }\n        else\n        {\n            int s, t, v;\n            scanf(\"%d %d %d\", &s, &t, &v);\n            tree.update(s,t, (ll)v);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <boost/multiprecision/cpp_dec_float.hpp>\n#include <boost/multiprecision/cpp_int.hpp>\n#include <boost/numeric/interval.hpp>\n#include <boost/numeric/interval/io.hpp>\n#include <boost/any.hpp>\nusing namespace::std;\nnamespace mp = boost::multiprecision;\ntypedef mp::number<mp::cpp_dec_float<32,int64_t>> cfloat;\ntypedef mp::cpp_int cint;\ntypedef long long lint;\ntypedef long long ll;\ntypedef long double ldouble;\ntypedef vector<lint> vec;\ntypedef vector<vector<lint>> mat;\ntypedef vector<vector<vector<lint>>> mat3;\ntypedef vector<double> dvec;\ntypedef vector<vector<double>> dmat;\ntypedef vector<vector<vector<double>>> dmat3;\ntypedef vector<string> svec;\ntypedef vector<vector<string>> smat;\ntypedef vector<vector<vector<string>>> smat3;\ntypedef vector<pair<lint,lint>> pvec;\ntypedef vector<vector<pair<lint,lint>>> pmat;\ntypedef vector<vector<vector<pair<lint,lint>>>> pmat3;\n#define rep(i, n) for(lint i = 0; i < (lint)(n); i++)\n#define irep(i) for(lint i = 0;; i++)\n#define irep1(i) for(lint i = 1;; i++)\n#define irep2(i) for(lint i = 2;; i++)\n#define rrep(i, n) for(lint i = (lint)(n-1); i >-1; i--)\n#define rrepi(i,a,b) for(lint i = (lint)(b-1); i >a-1; i--)\n#define repi(i,a,b) for(lint i=lint(a);i<lint(b);i++)\n#define rep2(i,a,b,c) for(lint i=lint(a);i>lint(b);i+=c)\n#define all(x) (x).begin(),(x).end()\n#define PI 3.141592653589793\n#define cout (cout<<fixed<<setprecision(15))\n#define dist(x1,y1,x2,y2) (pow(pow(x2-x1,2)+pow(y2-y1,2),0.5))\n#define output(v) do{bool f=0;for(auto i:v){cout<<(f?\" \":\"\")<<i;f=1;}cout<<\"\\n\";}while(0)\n#define output2(v) for(auto i:v)output(i);\n#define input(a,n) lint n;cin>>n;vector<lint>a(n);rep(i,n)cin>>a[i];\n#define sum(v) accumulate(all(v),0LL)\n#define INF (1LL<<60)\n#define IINF (1<<30)\n#define LINF 9223372036854775807\n#define MOD 1000000007\nvector<lint> dx={-1,1,0,0,1,1,-1,-1};\nvector<lint> dy={0,0,-1,1,1,-1,1,-1};\ninline lint gcd(lint a,lint b){return b?gcd(b,a%b):a;}\ninline lint lcm(lint a,lint b){return a*b/gcd(a,b);}\ntemplate<typename T,typename E>struct LSEG{\n    lint n=1;\n    vector<T> node;\n    vector<E> lazy;\n    T et;\n    E ee;\n    LSEG(lint size,T et,E ee,T ft,E fe):et(et),ee(ee){\n        while(n<size)n<<=1;\n        node.resize(2*n-1,ft);\n        lazy.resize(2*n-1,fe);\n    }\n    inline void eval(lint k,lint len){\n        if(lazy[k]==ee) return;\n        if(k*2+1<n*2-1){\n            lazy[k*2+1]=g(lazy[k*2+1],lazy[k]);\n            lazy[k*2+2]=g(lazy[k*2+2],lazy[k]);\n        }\n        node[k]=h(node[k],lazy[k],len);\n        lazy[k]=ee;\n    }\n\n    //0-indexed [a,b)\n    T update(lint a,lint b,E x,lint k=0,lint l=0,lint r=-1){\n        if(r<0)r=n;\n        eval(k,r-l);\n        //区間外\n        if(r<=a||b<=l)return node[k];\n        //全部区間内\n        if(a<=l&&r<=b){\n            lazy[k]=g(lazy[k],x);\n            return h(node[k],lazy[k],r-l);\n        }\n        //一部区間内\n        return node[k]=f(update(a,b,x,2*k+1,l,(l+r)/2),update(a,b,x,2*k+2,(l+r)/2,r));\n    }\n    //0-indexed [a,b)\n    T get(lint a,lint b,lint k=0,lint l=0,lint r=-1){\n        if(r<0)r=n;\n        eval(k,r-l);\n        //区間外\n        if(r<=a||b<=l)return et;\n        //全部区間内\n        if(a<=l&&r<=b)return node[k];\n        //一部区間内\n        return f(get(a,b,2*k+1,l,(l+r)/2),get(a,b,2*k+2,(l+r)/2,r));\n    }\n    T f(T a,T b){\n        return a+b;\n    }\n    T h(T a,E b,lint len){\n        return b==INF?a:b*len;\n    }\n    E g(E a,E b){\n        return b;\n    }\n};\nint main(){\n    lint n,q;\n    cin>>n>>q;\n    LSEG<lint,lint> seg=LSEG<lint,lint>(n,0,INF,0,INF);\n    rep(i,q){\n        lint query;\n        cin>>query;\n        if(query==0){\n            lint s,t,x;\n            cin>>s>>t>>x;\n            seg.update(s,t+1,x);\n        }else{\n            lint s,t;\n            cin>>s>>t;\n            cout<<seg.get(s,t+1)<<endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/*Range Sum Update Query*/\n\ntemplate<typename D, int useAssert = 1>\nclass RSUQ{\npublic :\n  struct T{ //遅延データ\n    int type; //0 - empty, 1 - update\n    D value;\n    T():type(0){}\n    T(int type, D value):type(type), value(value){}\n  };\n\n  int n, n_;\n  vector<D> dat;\n  vector<T> td;\n\n  RSUQ(){n=-1;}\n  RSUQ(int n_):n_(n_){\n    n=1;\n    while(n<n_) n *= 2;\n    td.resize(2*n-1, T());\n    dat.resize(2*n-1, 0);\n  }\n\n  //目的データのマージ\n  inline D mergeD(D l, D r){return l + r;}\n\n  //遅延データのマージ\n  inline T mergeT(const T &from, const T &to){\n    if(to.type == 0) return from;\n    return to;\n  }\n\n  //目的データに遅延データを反映\n  inline void apply(D &a, const T &b, int len){\n    if(b.type == 0) return;\n    a = b.value * len; //update\n  }\n\n  D dfs(int a, int b,const T x, int k, int l, int r){\n    if(r <= a || b <= l) return x.type == 0? 0 : dat[k];\n    if(a <= l && r <= b){\n      td[k] = mergeT(td[k], x);\n      apply(dat[k], x, r - l);\n      return dat[k];\n    }\n    int kl = k * 2 + 1, kr = k * 2 + 2;\n    { //遅延を子に反映\n      td[kl] = mergeT(td[kl], td[k]);\n      td[kr] = mergeT(td[kr], td[k]);\n      apply(dat[kl], td[k], (r - l)/2);\n      apply(dat[kr], td[k], (r - l)/2);\n      td[k] = T();\n    }\n    D vl = dfs(a, b, x, kl, l, (l+r)/2);\n    D vr = dfs(a, b, x, kr, (l+r)/2, r);\n    return x.type == 0? mergeD(vl,vr) : (dat[k] = mergeD(vl, vr));\n  }\n\n  //[l,r)の値をxに変更　update(l,r,x)\n  void update(int l,int r, D x){\n    if(useAssert) assert(l <= r), assert(l <= n && r <= n), assert(l >= 0 && r >= 0);\n    dfs(l, r,  T(1, x), 0, 0, n);\n  }\n\n  //[l,r)の総和を得る　get(l,r);\n  D get(int l,int r){\n    if(useAssert) assert(l <= r), assert(l <= n && r <= n), assert(l >= 0 && r >= 0);\n    return dfs(l, r, T(), 0 , 0 ,n);\n  }\n};\n\n\nsigned main(){\n  int n,q;\n  cin>>n>>q;\n\n  RSUQ<int, 0> rsuq(n);\n\n  while(q--){\n    int cmd;\n    cin>>cmd;\n    if(cmd == 0){\n      int s,t,x;\n      cin>>s>>t>>x;\n      rsuq.update(s,t+1,x);\n    }\n\n    if(cmd == 1){\n      int s,t;\n      cin>>s>>t;\n      cout<<rsuq.get(s,t+1)<<endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ld long double\n#define ll long long\n#define P pair<int,int>\n#define fi first\n#define se second\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define pb push_back\n#define eb emplace_back\ntemplate<class T>void chmax(T &a,T b){if(a<b)a=b;}\ntemplate<class T>void chmin(T &a,T b){if(a>b)a=b;}\nconstexpr int INF=1000000000000000000;\nconstexpr int mod=1000000007;\nconstexpr double eps=1e-8;\nconst double pi=acos(-1);\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nint Random(int mi,int ma){\n    random_device rnd;\n    mt19937 mt(rnd());//32bit\n    //[mi,ma]\n    uniform_int_distribution<int>engine(mi,ma);\n    return engine(mt);\n}\nint gcd(int a,int b){\n    if(b==0)return a;\n    return gcd(b,a%b);\n}\nint lcm(int a,int b){\n    return a/gcd(a,b)*b;\n}\nbool prime(int a){\n    if(a==1)return false;\n    for(int i=2;i*i<=a;i++){\n        if(a%i==0)return false;\n    }\n    return true;\n}\nint modpow(int a,int b){\n    if(b==0)return 1;\n    if(b%2)return modpow(a,b-1)*a%mod;\n    int memo=modpow(a,b/2);\n    return memo*memo%mod;\n}\nvector<int>kaijo,invkaijo;\nvoid init_fact(int n){\n    kaijo.resize(n+1);\n    invkaijo.resize(n+1);\n    kaijo[0]=1;\n    for(int i=1;i<=n;i++){\n        kaijo[i]=kaijo[i-1]*i;\n        kaijo[i]%=mod;\n    }\n    rep(i,n+1)invkaijo[i]=modpow(kaijo[i],mod-2);\n}\nint comb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return kaijo[a]*invkaijo[a-b]%mod*invkaijo[b]%mod;\n}\nint inv(int x){\n    x=modpow(x,mod-2);\n    return x;\n}\nstruct Segtree{\n    int siz=1;\n    vector<int>dat,laz;\n    vector<bool>lazf;\n    Segtree(int n){\n        while(siz<n)siz*=2;\n        dat.resize(siz*2-1,0);\n        laz.resize(siz*2-1,0);\n        lazf.resize(siz*2-1,false);\n    }\n    void eval(int k,int l,int r){\n        if(lazf[k]){\n            dat[k]=laz[k]*(r-l);\n            if(r-l>1){\n                laz[2*k+1]=laz[k];\n                laz[2*k+2]=laz[k];\n                lazf[2*k+1]=true;\n                lazf[2*k+2]=true;\n            }\n            lazf[k]=false;\n        }\n    }\n    void update(int a,int b,int x,int k=0,int l=0,int r=-1){\n        if(r==-1)r=siz;\n        eval(k,l,r);\n        if(b<=l||r<=a)return;\n        if(a<=l&&r<=b){\n            laz[k]=x;\n            lazf[k]=true;\n            eval(k,l,r);\n            return;\n        }\n        update(a,b,x,2*k+1,l,(l+r)/2);\n        update(a,b,x,2*k+2,(l+r)/2,r);\n        dat[k]=dat[2*k+1]+dat[2*k+2];\n    }\n    int query(int a,int b,int k=0,int l=0,int r=-1){\n        if(r==-1)r=siz;\n        if(b<=l||r<=a)return 0;\n        eval(k,l,r);\n        if(a<=l&&r<=b)return dat[k];\n        int vl=query(a,b,2*k+1,l,(l+r)/2);\n        int vr=query(a,b,2*k+2,(l+r)/2,r);\n        return vl+vr;\n    }\n};\nsigned main(){\n    cin.tie(0);ios::sync_with_stdio(false);\n    int n,q;\n    cin>>n>>q;\n    Segtree seg(n);\n    while(q--){\n        int type;\n        cin>>type;\n        if(type==0){\n            int s,t,x;\n            cin>>s>>t>>x;\n            seg.update(s,t+1,x);\n        }\n        else{\n            int s,t;\n            cin>>s>>t;\n            cout<<seg.query(s,t+1)<<endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n//typedef unsigned long long ll;\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n//#define rep(i, n) for (ll i = 0; i < (n); ++i)\n//#define sz(x) ll(x.size())\n//typedef pair<ll, int> P;\ntypedef pair<ll, ll> P;\n//const double INF = 1e10;\nconst ll INF = LONG_LONG_MAX / 10;\n//const ll INF = (1ll << 31) - 1;\n//const ll INF = 1e15;\nconst ll MINF = LONG_LONG_MIN;\n//const int INF = INT_MAX / 10;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n//typedef pair<int, int> P;\n//typedef pair<double, double> P;\n\nbool contain(set<P> &s, P a) { return s.find(a) != s.end(); }\n\n//ifstream myfile(\"C:\\\\Users\\\\riku\\\\Downloads\\\\0_00.txt\");\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\n\n\nvoid print_line(vector<ll> &line) {\n    if (line.size() == 0ll) {\n        cout << endl;\n        return;\n    }\n    for (ll i = 0; i < line.size(); i++) {\n        cout << line[i];\n        if (i == line.size() - 1) cout << endl;\n        else cout << ' ';\n    }\n}\n\n\ntypedef priority_queue<long long, vector<long long>, greater<long long>> PQ_ASK;\nconst int mod = 1000000007;\n\n// https://onlinejudge.u-aizu.ac.jp/solutions/problem/DSL_2_F/review/3380631/face4/C++14\nclass STlazy {\nprivate:\n    int n;\n    vector<int> node, lazy;\n\npublic:\n    STlazy() {\n        n = (1 << 17) - 1;\n        node.resize(2 * n - 1, 0);\n        lazy.resize(2 * n - 1, -1001);\n    }\n\n    void eval(int k, int l, int r) {\n        if (lazy[k] == -1001) return;\n        node[k] = (r - l) * lazy[k];\n        if (r - l > 1) {\n            lazy[2 * k + 1] = lazy[k];\n            lazy[2 * k + 2] = lazy[k];\n        }\n        lazy[k] = -1001;\n    }\n\n    void update(int a, int b, int x, int k = 0, int l = 0, int r = -1) {\n        if (r < 0) r = n;\n        eval(k, l, r);\n        if (r <= a || b <= l) return;\n        if (a <= l && r <= b) {\n            lazy[k] = x;\n            eval(k, l, r);\n            return;\n        }\n        update(a, b, x, 2 * k + 1, l, (l + r) / 2);\n        update(a, b, x, 2 * k + 2, (l + r) / 2, r);\n        node[k] = node[2 * k + 1] + node[2 * k + 2];\n    }\n\n    int query(int a, int b, int k = 0, int l = 0, int r = -1) {\n        if (r < 0) r = n;\n        if (r <= a || b <= l) return 0;\n        eval(k, l, r);\n        if (a <= l && r <= b) return node[k];\n        int lx = query(a, b, 2 * k + 1, l, (l + r) / 2);\n        int rx = query(a, b, 2 * k + 2, (l + r) / 2, r);\n        return lx + rx;\n    }\n};\n\nint main() {\n\n    int n, q;\n    cin >> n >> q;\n\n    STlazy st;\n\n    rep(i, q) {\n        int query;\n        cin >> query;\n\n        if (query == 0) {\n            int s, t, x;\n            cin >> s >> t >> x;\n            t++;\n            st.update(s, t, x);\n        } else if (query == 1) {\n            int s, t;\n            cin >> s >> t;\n            t++;\n            cout << st.query(s, t) << endl;\n        }\n\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<pii> vii;\ntypedef vector<pll> vll;\n#define fi first\n#define se second\nconst ll INFLL=LLONG_MAX;\nconst int INF=INT_MAX;\n#define eb emplace_back\n#define emp emplace\n#define mp(a,b) make_pair(a,b)\ntemplate<class T> using min_heap=priority_queue<T,vector<T>,greater<T> >;\ntemplate<class T>\nvoid sort(vector<T>& v){\n\tsort(v.begin(),v.end());\n}\ntemplate <class T, class U>\nvoid sort(vector<T>& v,U func){\n\tsort(v.begin(),v.end(),func);\n}\ntemplate <class T>\nint lb_index(vector<T>& v,T k){\n\treturn lower_bound(v.begin(),v.end(),k)-v.begin();\n}\ntemplate <class T>\nint ub_index(vector<T>& v,T k){\n\treturn upper_bound(v.begin(),v.end(),k)-v.begin();\n}\ntemplate<class T>\nstruct segtree{\nprivate:\n\tT init;\n\tint n;\n\tfunction<T(T,T)> op;\n\tvector<T>arr;\n\tvector<T>st;\n\tvector<T>lz;\n\tvoid build(int lo,int hi,int u){\n\t\tif(lo==hi){\n\t\t\tst[u]=arr[lo];\n\t\t}\n\t\telse{\n\t\t\tint mi=(hi+lo)>>1;\n\t\t\tbuild(lo,mi,u<<1);\n\t\t\tbuild(mi+1,hi,u<<1|1);\n\t\t\tst[u]=op(st[u<<1],st[u<<1|1]);\n\t\t}\n\t}\n\tvoid apply(T x,int u,int lo,int hi){\n// \t\tst[u]+=x*(hi-lo+1);\n// \t\tst[u]+=x;\n//\t\tst[u]=x;\n \t\tst[u]=x*(hi-lo+1);\n// \t\tlz[u]+=x;\n\t\tlz[u]=x;\n\t}\n\tvoid push(int u,int lo,int hi){\n\t\tif(lz[u]!=init){\n\t\t\tint mi=(lo+hi)>>1;\n\t\t\tapply(lz[u],u<<1,lo,mi);\n\t\t\tapply(lz[u],u<<1|1,mi+1,hi);\n\t\t\tlz[u]=init;\n\t\t}\n\t}\n\tvoid modify(int l,int r,T x,int u,int lo,int hi){\n\t\tif(r<lo||l>hi||l>r)return;\n\t\tif(l<=lo&&r>=hi){\n\t\t\tapply(x,u,lo,hi);\n\t\t\treturn;\n\t\t}\n\t\tpush(u,lo,hi);\n\t\tint mi=(lo+hi)>>1;\n\t\tif(mi>=r){\n\t\t\tmodify(l,r,x,u<<1,lo,mi);\n\t\t}\n\t\telse if(mi<l){\n\t\t\tmodify(l,r,x,u<<1|1,mi+1,hi);\n\t\t}\n\t\telse{\n\t\t\tmodify(l,mi,x,u<<1,lo,mi);\n\t\t\tmodify(mi+1,r,x,u<<1|1,mi+1,hi);\n\t\t}\n\t\tst[u]=op(st[u<<1],st[u<<1|1]);\n\t}\n\tT query(int l,int r,int u,int lo,int hi){\n\t\tif(l>r||l>hi||r<lo)return init;\n\t\tif(l<=lo&&r>=hi){\n\t\t\treturn st[u];\n\t\t}\n\t\tpush(u,lo,hi);\n\t\tint mi=(hi+lo)>>1;\n\t\tif(mi>=r){\n\t\t\treturn query(l,r,u<<1,lo,mi);\n\t\t}\n\t\telse if(mi<l){\n\t\t\treturn query(l,r,u<<1|1,mi+1,hi);\n\t\t}\n\t\telse{\n\t\t\treturn op(query(l,mi,u<<1,lo,mi),query(mi+1,r,u<<1|1,mi+1,hi));\n\t\t}\n\t}\npublic:\n\tsegtree(T n,function<T(T,T)> op):n(n),st(n*4),op(op),lz(n*4){\n\t\tinit=T();\n\t}\n\tsegtree(vector<T> v,function<T(T,T)> op):n(v.size()),st(v.size()*4),op(op),lz(v.size()*4){\n\t\tinit=T();\n\t\tarr=v;\n\t\tbuild(0,n-1,1);\n\t}\n\tT query(int l,int r){\n\t\treturn query(l,r,1,0,n-1);\n\t}\n\tvoid setinit(T x){\n\t\tinit=x;\n\t\tfor(int i=0;i<4*n;i++){\n//\t\t\tst[i]=init;\n\t\t\tlz[i]=init;\n\t\t}\n\t}\n\tvoid modify(int l,int r,T x){\n\t\tmodify(l,r,x,1,0,n-1);\n\t}\n\tvoid debug(){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i;j<n;j++){\n\t\t\t\tcout<<i<<\" \"<<j<<\" \"<<query(i,j)<<\"\\n\";\n\t\t\t}\n\t\t}\n\t}\n};\nint main(){\n\tint n,q;\n\tcin>>n>>q;\n\tsegtree<int> seg(n,[](int a,int b){\n\t\treturn a+b;\n\t});\n\tseg.setinit(INF);\n\twhile(q--){\n\t\tint c;\n\t\tcin>>c;\n\t\tif(c){\n\t\t\tint l,r;\n\t\t\tcin>>l>>r;\n\t\t\tif(l==-1)seg.debug();\n\t\t\telse cout<<seg.query(l,r)<<\"\\n\";\n\t\t}\n\t\telse{\n\t\t\tint l,r,x;\n\t\t\tcin>>l>>r>>x;\n\t\t\tseg.modify(l,r,x);\n\t\t\t\n\t\t}\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"test/aoj/DSL2I.test.cpp\"\n#define PROBLEM \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_I\"\n#include <iostream>\n#include <utility>\n#line 1 \"segment_tree/lazy_segment_tree.hpp\"\n\n\n\n#include <vector>\n#include <cstdint>\n#line 1 \"bit/msb.hpp\"\n\n\n\n#line 5 \"bit/msb.hpp\"\n\ninline int msb32(uint32_t x) {\n        if (x == 0) return -1;\n#ifndef __has_builtin\n        int r = 0;\n        if (x >> 16) x >>= 16, r |= 16;\n        if (x >> 8) x >>= 8, r |= 8;\n        if (x >> 4) x >>= 4, r |= 4;\n        if (x >> 2) x >>= 2, r |= 2;\n        return r | (x >> 1);\n#else\n        return 31 - __builtin_clz(x);\n#endif\n};\n\ninline int msb64(uint64_t x) {\n    if (x == 0) return -1;\n\n    #ifndef __has_builtin\n        int r = 0;\n        if (x >> 32) x >>= 32, r |= 32;\n        if (x >> 16) x >>= 16, r |= 16;\n        if (x >> 8) x >>= 8, r |= 8;\n        if (x >> 4) x >>= 4, r |= 4;\n        if (x >> 2) x >>= 2, r |= 2;\n        return r | (x >> 1);\n#else\n    return 63 - __builtin_clzll(x);\n#endif\n};\n\n\n#line 7 \"segment_tree/lazy_segment_tree.hpp\"\n\n//===\ntemplate<class MonoidwithOperator>\nstruct LazySegmentTree {\n    using M = MonoidwithOperator;\n    using V = typename M::value_structure;\n    using T = typename V::value_type;\n    using O = typename M::operator_structure;\n    using E = typename O::value_type;\n\n    // mergeMonoid V::operation\n    // applyOperator M::operation\n    // mergeOperator O::operation\n\n    struct Node {\n        T dat;\n        E lazy;\n        Node (T dat, E lazy): dat(dat), lazy(lazy) {};\n    };\n\n    std::vector<Node> tree;\n\n    LazySegmentTree() = default;\n    explicit LazySegmentTree(uint32_t n):\n        tree(n * 2 + 2, Node(V::identity(), O::identity())) {};\n\n    int size() {\n        return tree.size() >> 1;\n    };\n    \n    void propagation(uint32_t k) {\n        const uint32_t l = (k << 1) | 0;\n        const uint32_t r = (k << 1) | 1;\n        tree[l].lazy = O::operation(tree[l].lazy, tree[k].lazy);\n        tree[r].lazy = O::operation(tree[r].lazy, tree[k].lazy);\n        tree[l].dat = M::operation(tree[l].dat, tree[k].lazy);\n        tree[r].dat = M::operation(tree[r].dat, tree[k].lazy);\n        tree[k].lazy = O::identity();\n    };\n    void push_down(uint32_t k) {\n        if (k == 0) return;\n        uint32_t w = msb32(k);\n        for (int i = w; i > 0; i--) propagation(k >> i);\n    };\n    void recalc(uint32_t k) {\n        while (k > 1) {\n            k >>= 1;\n            tree[k].dat = V::operation(tree[(k << 1) | 0].dat,\n                                       tree[(k << 1) | 1].dat);\n        }\n    };\n    \n    // [l, r) += op\n    void update(uint32_t l, uint32_t r, E op) {\n        l += size();\n        r += size();\n        uint32_t tmpl = l;\n        uint32_t tmpr = r;\n        push_down(l);\n        push_down(r - 1);\n\n        while (l < r) {\n            if (l & 1) {\n                tree[l].lazy = O::operation(tree[l].lazy, op);\n                tree[l].dat = M::operation(tree[l].dat, op);\n                l++;\n            }\n            if (r & 1) {\n                --r;\n                tree[r].lazy = O::operation(tree[r].lazy, op);\n                tree[r].dat = M::operation(tree[r].dat, op);\n            }\n            l >>= 1;\n            r >>= 1;\n        }\n\n        push_down(tmpl);\n        push_down(tmpr - 1);\n        recalc(tmpl);\n        recalc(tmpr - 1);\n    };\n    void update(uint32_t idx, T x) {\n        idx += size();\n        push_down(idx);\n        tree[idx].dat = x;\n        recalc(idx);\n    };\n    void set(uint32_t idx, T x) {\n        update(idx, x);\n    };\n\n    // foldl[l, r)\n    T fold(uint32_t l, uint32_t r) {\n        l += size();\n        r += size();\n        push_down(l);\n        push_down(r - 1);\n\n        T lv = V::identity();\n        T rv = V::identity();\n\n        while (l < r) {\n            if (l & 1) lv = V::operation(lv, tree[l].dat), l++;\n            if (r & 1) --r, rv = V::operation(tree[r].dat, rv);\n\n            l >>= 1;\n            r >>= 1;\n        }\n\n        return V::operation(lv, rv);\n    };\n\n    T operator [](const uint32_t &k) {\n        push_down(k + size());\n        return tree[k + size()].dat;\n    };\n};\n//===\n\n\n#line 5 \"test/aoj/DSL2I.test.cpp\"\nusing namespace std;\nusing llong = long long;\n\nstruct Monoid {\n    using T = pair<llong, llong>;\n    using value_type = pair<llong, llong>;\n    inline static T identity() {\n        return {0ll, 0ll};\n    };\n    inline static T operation(T &a, T &b) {\n        return {a.first + b.first, a.second + b.second};\n    };\n};\nstruct Operator {\n    using E = llong;\n    using value_type = llong;\n    inline static E identity() {\n        return -1024;\n    };\n    inline static E operation(E &a, E &b) {\n        if (b == identity()) return a;\n        else return b;\n    };\n};\nstruct A {\n    using value_structure = Monoid;\n    using operator_structure = Operator;\n    using T = typename value_structure::T;\n    using E = typename operator_structure::E;\n    inline static T operation(T &a, E &b) {\n        if (b == operator_structure::identity()) return a;\n        return {b * a.second, a.second};\n    };\n};\n\nllong n, q;\nllong com, s, t, x;\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    cin >> n >> q;\n    LazySegmentTree<A> seg(n);\n\n    for (int i = 0; i < n; i++) seg.set(i, {0ll, 1ll});\n\n    while (q--) {\n        cin >> com;\n        if (com == 0) {\n            cin >> s >> t >> x;\n            seg.update(s, t + 1, x);\n        }\n        else {\n            cin >> s >> t;\n            cout << seg.fold(s, t + 1).first << '\\n';\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename Monoid,typename OperatorMonoid>\nstruct LazySegmentTree{\n    typedef function<Monoid(Monoid,Monoid)> F;\n    typedef function<Monoid(Monoid,OperatorMonoid)> G;\n    typedef function<OperatorMonoid(OperatorMonoid,OperatorMonoid)> H;\n    int n,hi;\n    F f;\n    G g;\n    H h;\n    Monoid id0;\n    OperatorMonoid id1;\n    vector<Monoid> dat;\n    vector<OperatorMonoid> laz;\n    LazySegmentTree(int n_,F f,G g,H h,Monoid id0,OperatorMonoid id1):\n                    f(f),g(g),h(h),id0(id0),id1(id1){init(n_);}\n    void init(int n_){\n        n=1,hi=0;\n        while(n<n_) n<<=1,++hi;\n        dat.assign(n<<1,id0);\n        laz.assign(n<<1,id1);\n    }\n    void build(const vector<Monoid> &v){\n        for (int i=0;i<v.size();++i) dat[i+n]=v[i];\n        for (int i=n-1;i;--i) dat[i]=f(dat[i<<1|0],dat[i<<1|1]);\n    }\n    inline Monoid reflect(int k){\n        return laz[k]==id1?dat[k]:g(dat[k],laz[k]);\n    }\n    inline void propagate(int k){\n        if (laz[k]==id1) return;\n        laz[k<<1|0]=h(laz[k<<1|0],laz[k]);\n        laz[k<<1|1]=h(laz[k<<1|1],laz[k]);\n        dat[k]=reflect(k);\n        laz[k]=id1;\n    }\n    inline void thrust(int k){\n        for (int i=hi;i;--i) propagate(k>>i);\n    }\n    inline void recalc(int k){\n        while(k>>=1) dat[k]=f(reflect(k<<1|0),reflect(k<<1|1));\n    }\n    void update(int a,int b,OperatorMonoid x){\n        if (a>=b) return;\n        thrust(a+=n),thrust(b+=n-1);\n        for (int l=a,r=b+1;l<r;l>>=1,r>>=1){\n            if (l&1) laz[l]=h(laz[l],x),++l;\n            if (r&1) --r,laz[r]=h(laz[r],x);\n        }\n        recalc(a),recalc(b);\n    }\n    void set_val(int k,Monoid x){\n        thrust(k+=n);\n        dat[k]=x,laz[k]=id1;\n        recalc(k);\n    }\n    Monoid query(int a,int b){\n        if (a>=b) return id0;\n        thrust(a+=n),thrust(b+=n-1);\n        Monoid vl=id0,vr=id0;\n        for (int l=a,r=b+1;l<r;l>>=1,r>>=1){\n            if (l&1) vl=f(vl,reflect(l++));\n            if (r&1) vr=f(reflect(--r),vr);\n        }\n        return f(vl,vr);\n    }\n    Monoid operator[](int i){return query(i,i+1);}\n};\n\n// https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/all/DSL_2_D\n// RUQ\n\nvoid DSL_2_D(){\n    int n,q; cin >> n >> q;\n    auto f=[](int a,int b){return min(a,b);};\n    auto g=[](int a,int b){return (~b?b:a);};\n    auto h=[](int a,int b){return b;};\n    LazySegmentTree<int,int> seg(n,f,g,h,INT_MAX,-1);\n    for (;q--;){\n        int c,s,t,x,i; cin >> c;\n        if (!c){\n            cin >> s >> t >> x;\n            seg.update(s,t+1,x);\n        } else {\n            cin >> i;\n            cout << seg[i] << '\\n';\n        }\n    }\n}\n\n// https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/2/DSL_2_E\n// RAQ\n\nvoid DSL_2_E(){\n    int n,q; cin >> n >> q;\n    auto f=[](int a,int b){return a+b;};\n    LazySegmentTree<int,int> seg(n,f,f,f,0,0);\n    for (;q--;){\n        int c,s,t,x,i; cin >> c;\n        if (!c){\n            cin >> s >> t >> x;\n            seg.update(s-1,t,x);\n        } else {\n            cin >> i;\n            cout << seg[i-1] << '\\n';\n        }\n    }\n}\n\n// https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/2/DSL_2_F\n// RMQ and RAQ\n\nvoid DSL_2_F(){\n    int n,q; cin >> n >> q;\n    auto f=[](int a,int b){return min(a,b);};\n    auto g=[](int a,int b){return (~b?b:a);};\n    auto h=[](int a,int b){return b;};\n    LazySegmentTree<int,int> seg(n,f,g,h,INT_MAX,-1);\n    for (;q--;){\n        int c,s,t,x; cin >> c >> s >> t;\n        if (!c){\n            cin >> x;\n            seg.update(s,t+1,x);\n        } else cout << seg.query(s,t+1) << '\\n';\n    }\n}\n\n// https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/2/DSL_2_G\n// RSQ and RUQ\n\nvoid DSL_2_G(){\n    int n,q; cin >> n >> q;\n    auto f=[](pair<long long,long long> a,pair<long long,long long> b){return make_pair(a.first+b.first,a.second+b.second);};\n    auto g=[](pair<long long,long long> a,long long x){return make_pair(a.first+a.second*x,a.second);};\n    auto h=[](long long a,long long b){return a+b;};\n    LazySegmentTree<pair<long long,long long>,long long> seg(n,f,g,h,{0,0},0);\n    vector<pair<long long,long long>> v(n,{0,1});\n    seg.build(v);\n    for (;q--;){\n        int c,s,t,x; cin >> c >> s >> t;\n        if (!c){\n            cin >> x;\n            seg.update(s-1,t,x);\n        } else cout << seg.query(s-1,t).first << '\\n';\n    }\n}\n\n// https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/2/DSL_2_H\n// RMQ and RAQ\n\nvoid DSL_2_H(){\n    int n,q; cin >> n >> q;\n    auto f=[](int a,int b){return min(a,b);};\n    auto g=[](int a,int b){return a+b;};\n    LazySegmentTree<int,int> seg(n,f,g,g,INT_MAX,0);\n    vector<int> v(n,0);\n    seg.build(v);\n    for (;q--;){\n        int c,s,t,x; cin >> c >> s >> t;\n        if (!c){\n            cin >> x;\n            seg.update(s,t+1,x);\n        } else cout << seg.query(s,t+1) << '\\n';\n    }\n}\n\n// https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/2/DSL_2_I\n// RSQ and RUQ\n\nvoid DSL_2_I(){\n    const int inf=1<<30;\n    int n,q; cin >> n >> q;\n    auto f=[](pair<long long,long long> a,pair<long long,long long> b){return make_pair(a.first+b.first,a.second+b.second);};\n    auto g=[](pair<long long,long long> a,long long x){return make_pair(x!=inf?x*a.second:a.first,a.second);};\n    auto h=[](long long a,long long b){return b;};\n    LazySegmentTree<pair<long long,long long>,long long> seg(n,f,g,h,{0,0},inf);\n    vector<pair<long long,long long>> v(n,{0,1});\n    seg.build(v);\n    for (;q--;){\n        int c,s,t,x; cin >> c >> s >> t;\n        if (!c){\n            cin >> x;\n            seg.update(s,t+1,x);\n        } else cout << seg.query(s,t+1).first << '\\n';\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    DSL_2_I();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (long long i=0;i<(n);i++)\n#define dump(x)  cerr << #x << \" => \" << (x) << endl;\n#define dump1d_arr(array) REP(i,array.size()) cerr << #array << \"[\" << (i) << \"] ==> \" << (array[i]) << endl;\nusing namespace std;\n/*\nstruct Monoid {\n    using T = _underlying_set_;\n    static  T op(const T& a, const T& b) { return _a_op_b_; }\n    static constexpr T identity() { return _identity_element_; }\n};\n*/\ntemplate <class Monoid,class MonoidAct,typename N>\nclass LazySegmentTree {\nprivate:\n    using T1 = typename Monoid::T;\n    using T2 = typename MonoidAct::T;\n    vector<T1> data;\n    vector<T2> lazy;\n    vector<N> rank; \n    const size_t h, n;\n\n    //オペレータ2 MonoidAct -> Monoid (値がどう変化するか)\n\n    // RUQ -> RMQ\n    //static T1 op2(const T1& l,const T2& r,const N& num) {return r != MonoidAct::id() ? r : l; }\n    // RAQ -> RMQ\n    //static T1 op2(const T1& l,const T2& r,const N& num) {return l + r; }\n    // RAQ -> RSQ \n    //static T1 op2(const T1& l,const T2& r,const N& num) {return l + (r*num); }\n    // RUQ -> RSQ\n    static T1 op2(const T1& l,const T2& r,const N& num) {return r != MonoidAct::id() ? r*num : l; }\n\n\n\nprivate:\n    void eval(size_t node) {\n        if (lazy[node] == MonoidAct::id()) return;\n        if (node < n) {\n            lazy[node * 2] = MonoidAct::op3(lazy[node * 2], lazy[node]);\n            lazy[node * 2 + 1] = MonoidAct::op3(lazy[node * 2 + 1], lazy[node]);\n        }\n        data[node] = op2(data[node],lazy[node],rank[node]);\n        lazy[node] = MonoidAct::id();\n    }\n    void update(size_t node) {\n        data[node] = Monoid::op1(op2(data[node * 2],lazy[node * 2],rank[node*2])\n                        ,op2(data[node * 2 + 1],lazy[node * 2 + 1],rank[node*2+1]));\n    }\n\npublic:\n    LazySegmentTree(size_t n_)\n        : h(ceil(log2(n_))), n(1 << h) {data.resize(n * 2, Monoid::id());lazy.resize(n * 2, MonoidAct::id());rank.resize(n*2);init();}\n    LazySegmentTree(size_t n_, T1 v1)\n        : h(ceil(log2(n_))), n(1 << h) {data.resize(n * 2, v1);lazy.resize(n * 2, MonoidAct::id());rank.resize(n*2);init();}\n    LazySegmentTree(const vector<T1>& data_)\n        : h(ceil(log2(data_.size()))), n(1 << h) {\n            data.resize(n * 2,Monoid::id());\n            lazy.resize(n * 2, MonoidAct::id());\n            rank.resize(n*2);\n            init(data_);\n    }\n    void init() {\n        for (N i = 0;i < n;i++) rank[i+n] = 1;\n        for (N i = n - 1; i >= 1; i--) {\n            data[i] = Monoid::op1(data[i * 2], data[i * 2 + 1]);\n            rank[i] += (rank[i*2] + rank[i*2+1]);\n        }\n    }\n    void init(const vector<T1>& data_) {\n        for (N i = 0; i < (N)data_.size(); i++) {\n            data[i + n] = data_[i];\n        }\n        init();\n    }\n\n    T1 operator[](size_t i) { return find(i,i+1);}\n\n    void update(size_t l, size_t r, T2 val) {\n        l += n, r += n - 1;\n        for (N i = h; i > 0; i--) eval(l >> i), eval(r >> i);\n        size_t tl = l, tr = r;\n        r++;\n        while (l < r) {\n            if (l & 1) lazy[l] = MonoidAct::op3(lazy[l], val), l++;\n            if (r & 1) r--, lazy[r] = MonoidAct::op3(lazy[r],val);\n            l >>= 1; r >>= 1;\n        }\n        while (tl >>= 1, tr >>= 1, tl) {\n            if (lazy[tl] == MonoidAct::id()) update(tl);\n            if (lazy[tr] == MonoidAct::id()) update(tr);\n        }\n    }\n    T1 find(size_t l, size_t r) {\n        l += n, r += n - 1;\n        for (N i = h; i > 0; i--) eval(l >> i), eval(r >> i);\n        r++;\n        T1 res1 = Monoid::id(), res2 = Monoid::id();\n        while (l < r) {\n            if (l & 1) res1 = Monoid::op1(res1, op2(data[l],lazy[l],rank[l])), l++;\n            if (r & 1) r--, res2 = Monoid::op1(op2(data[r],lazy[r],rank[r]),res2);\n            l >>= 1; r >>= 1;\n        }\n        return Monoid::op1(res1, res2);\n    }\n};\n\n\n// findモノイド\nstruct RMQ { // 区間の最小\n    using T = long;\n    static T op1(const T& a, const T& b) { return min(a,b); }\n    static constexpr T id() {return numeric_limits<T>::max();}\n};\nstruct RSQ { // 区間の和\n    using T = long;\n    static T op1(const T& a, const T& b) { return (a+b); }\n    static constexpr T id() {return 0; }\n};\n\n// updateモノイド\nstruct RUQ { // 区間に代入更新\n    using T = int;\n    static T op3(const T& l,const T& r) { return r != id() ? r : l;}\n    static constexpr T id() { return numeric_limits<T>::max(); }\n};\n\nstruct RAQ { // 区間に加算\n    using T = long;\n    static T op3(const T& l,const T& r) { return l+r;}\n    static constexpr T id() { return 0;}\n};\n\n\nint main(void) {\n    int n,q,com,s,t,x;\n    cin >> n >> q;\n    LazySegmentTree<RSQ,RUQ,long> sg(n,0);\n    REP(i,q) {\n        cin >> com;\n        if (!com) {\n            cin >> s >> t >> x;\n            sg.update(s,t+1,x);\n        }\n        else {\n            cin >> s >> t;\n            cout << sg.find(s,t+1) << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100000\n\nint N = 1;\nint data[4*NUM];\n\nvoid init(int first_N){\n\twhile(N < first_N)N *= 2;\n}\n\nvoid update(int update_left,int update_right,int new_value,int node_id,int node_left,int node_right){\n\tif(update_right < node_left || update_left > node_right)return;\n\telse if(update_left <= node_left && update_right >= node_right){\n\t\tdata[node_id] = new_value;\n\t}else{\n\t\tif(data[node_id] != -BIG_NUM){\n\t\t\tdata[2*node_id+1] = data[node_id];\n\t\t\tdata[2*node_id+2] = data[node_id];\n\t\t\tdata[node_id] = -BIG_NUM;\n\t\t}\n\t\tupdate(update_left,update_right,new_value,2*node_id+1,node_left,(node_left+node_right)/2);\n\t\tupdate(update_left,update_right,new_value,2*node_id+2,(node_left+node_right)/2+1,node_right);\n\t}\n}\n\nint getSum(int search_left,int search_right,int node_id,int node_left,int node_right){\n\tif(search_right < node_left || search_left > node_right){\n\t\treturn 0;\n\t}else{\n\t\tif(data[node_id] == -BIG_NUM){\n\t\t\tint left = getSum(search_left,search_right,2*node_id+1,node_left,(node_left+node_right)/2);\n\t\t\tint right = getSum(search_left,search_right,2*node_id+2,(node_left+node_right)/2+1,node_right);\n\t\t\treturn left+right;\n\t\t}else{\n\t\t\treturn (min(search_right,node_right)-max(search_left,node_left)+1)*data[node_id];\n\t\t}\n\t}\n}\n\n\nint main(){\n\n\tint first_N,num_query;\n\tscanf(\"%d %d\",&first_N,&num_query);\n\n\tinit(first_N);\n\n\tfor(int i = 0; i <= 2*N-2; i++){\n\t\tdata[i] = 0;\n\t}\n\n\tint command,left,right,value;\n\n\tfor(int loop = 0; loop < num_query; loop++){\n\t\tscanf(\"%d\",&command);\n\n\t\tif(command == 0){ //update\n\t\t\tscanf(\"%d %d %d\",&left,&right,&value);\n\t\t\tupdate(left,right,value,0,0,N-1);\n\t\t}else{\n\t\t\tscanf(\"%d %d\",&left,&right);\n\t\t\tprintf(\"%d\\n\",getSum(left,right,0,0,N-1));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nlong long INF = (1 << 31) - 1;\n\nclass LazySegmentTree {\nprivate:\n\tlong long Size;\n\tvector<long long> Node, Lazy;\n\tvector<bool> Flag;\npublic:\n\tLazySegmentTree(long long N) {\n\t\tSize = 1;\n\t\twhile (Size < N) Size <<= 1;\n\t\tNode.assign(Size * 2, 0);\n\t\tLazy.assign(Size * 2, 0);\n\t\tFlag.assign(Size * 2, false);\n\t}\n\tvoid Eval(long long K, long long L, long long R) {\n\t\tif (Flag[K]) {\n\t\t\tNode[K] = Lazy[K] * (R - L);\n\t\t\tif (R - L > 1) {\n\t\t\t\tLazy[K * 2] = Lazy[K];\n\t\t\t\tFlag[K * 2] = true;\n\t\t\t\tLazy[K * 2 + 1] = Lazy[K];\n\t\t\t\tFlag[K * 2 + 1] = true;\n\t\t\t}\n\t\t\tFlag[K] = false;\n\t\t}\n\t}\n\tvoid Update(long long A, long long B, long long X, long long K, long long L, long long R) {\n\t\tEval(K, L, R);\n\t\tif (B <= L || R <= A) return;\n\t\tif (A <= L && R <= B) {\n\t\t\tLazy[K] = X;\n\t\t\tFlag[K] = true;\n\t\t\tEval(K, L, R);\n\t\t\treturn;\n\t\t}\n\t\tUpdate(A, B, X, K * 2, L, (L + R) / 2);\n\t\tUpdate(A, B, X, K * 2 + 1, (L + R) / 2, R);\n\t\tNode[K] = Node[K * 2] + Node[K * 2 + 1];\n\t}\n\tvoid Update(long long A, long long B, long long X) {\n\t\tUpdate(A, B, X, 1, 0, Size);\n\t\treturn;\n\t}\n\tlong long Query(long long A, long long B, long long K, long long L, long long R) {\n\t\tEval(K, L, R);\n\t\tif (B <= L || R <= A) return 0;\n\t\tif (A <= L && R <= B) return Node[K];\n\t\treturn Query(A, B, K * 2, L, (L + R) / 2) + Query(A, B, K * 2 + 1, (L + R) / 2, R);\n\t}\n\tlong long Query(long long A, long long B) {\n\t\treturn Query(A, B, 1, 0, Size);\n\t}\n};\n\nint main() {\n\tlong long N, Q;\n\tcin >> N >> Q;\n\tLazySegmentTree Seg(N);\n\tfor (int i = 0; i < Q; i++) {\n\t\tlong long Mode;\n\t\tcin >> Mode;\n\t\tif (Mode == 0) {\n\t\t\tlong long A, B, X;\n\t\t\tcin >> A >> B >> X;\n\t\t\tSeg.Update(A, B + 1, X);\n\t\t}\n\t\telse {\n\t\t\tlong long A, B;\n\t\t\tcin >> A >> B;\n\t\t\tcout << Seg.Query(A, B + 1) << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long int\n#define MOD(x) ((x % MOD_N) + MOD_N) % MOD_N\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define RFORE(i,a,b) for(int i=(b);i>=(a);--i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define RALL(c) (c).rbegin(),(c).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(c) (int)((c).size())\n#define EACH(i,v) for(auto i=v.begin();i!=v.end();++i)\n#define REACH(i,v) for(auto i=v.rbegin();i!=v.rend();++i)\n#define LB(c,x) distance((c).begin(),lower_bound(ALL(c),x))\n#define UB(c,x) distance((c).begin(),upper_bound(ALL(c),x))\n#define COUNT(c,x) (lower_bound(ALL(c),x)-upper_bound(ALL(c),x))\n#define UNIQUE(c) SORT(c); (c).erase(unique(ALL(c)),(c).end());\n#define COPY(c1,c2) copy(ALL(c1),(c2).begin())\n#define EXIST(s,e) (bool)((s).find(e)!=(s).end())\n#define PB push_back\n#define MP make_pair\n#define DUMP(x)  cerr<<#x<<\" = \"<<(x)<<endl;\n#define NL cerr<<endl;\nusing namespace std;\ntemplate<typename T,typename U> using P=pair<T,U>;\ntemplate<typename T> using V=vector<T>;\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T sum(vector<T>&v){return accumulate(ALL(v),T());}\ntemplate<typename T>T sum(vector<T>&v,int a,int b){return accumulate(v.begin()+a,v.begin()+b,T());}\ntemplate<typename T>T max(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T min(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T max_index(vector<T>&v){return distance((v).begin(),max_element(ALL(v)));}\ntemplate<typename T>T min_index(vector<T>&v){return distance((v).begin(),min_element(ALL(v)));}\n\nstruct edge { int to, cost; };\n\ntemplate<typename T>auto&operator<<(ostream&s,const vector<T>&v){s<<\"[\";bool a=1;for(auto e:v){s<<(a?\"\":\" \")<<e;a=0;}s<<\"]\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const pair<T,U>&p){s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return s;}\ntemplate<typename T>auto&operator<<(ostream&s,const set<T>&st){s<<\"{\";bool a=1;for(auto e:st){s<<(a?\"\":\" \")<<e;a=0;}s<<\"}\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const map<T,U>&m){s<<\"{\";bool a=1;for(auto e:m){s<<(a?\"\":\" \")<<e.first<<\":\"<<e.second;a=0;}s<<\"}\";return s;}\n\nconst int INF = 1e18;\nconst int MOD_N = 1e9+7;\n\ntemplate< typename Monoid, typename OperatorMonoid = Monoid >\nstruct LazySegmentTree {\n   using F = function< Monoid(Monoid, Monoid) >;\n   using G = function< Monoid(Monoid, OperatorMonoid, int) >;\n   using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n   int sz;\n   vector< Monoid > data;\n   vector< OperatorMonoid > lazy;\n   const F f;\n   const G g;\n   const H h;\n   const Monoid M1;\n   const OperatorMonoid OM0;\n   LazySegmentTree(int n, const F f, const G g, const H h,\n                   const Monoid &M1, const OperatorMonoid OM0)\n         : f(f), g(g), h(h), M1(M1), OM0(OM0) {\n      sz = 1;\n      while(sz < n) sz <<= 1;\n      data.assign(2 * sz, M1);\n      lazy.assign(2 * sz, OM0);\n   }\n\n   void set(int k, const Monoid &x) {\n      data[k + sz] = x;\n   }\n   void build() {\n      for(int k = sz - 1; k > 0; k--) {\n         data[k] = f(data[2 * k + 0], data[2 * k + 1]);\n      }\n   }\n   void propagate(int k, int len) {\n      if(lazy[k] != OM0) {\n         if(k < sz) {\n            lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n            lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n         }\n         data[k] = g(data[k], lazy[k], len);\n         lazy[k] = OM0;\n      }\n   }\n   Monoid update(int a, int b, const OperatorMonoid &x, int k, int l, int r) {\n      propagate(k, r - l);\n      if(r <= a || b <= l) {\n         return data[k];\n      } else if(a <= l && r <= b) {\n         lazy[k] = h(lazy[k], x);\n         propagate(k, r - l);\n         return data[k];\n      } else {\n         return data[k] = f(update(a, b, x, 2 * k + 0, l, (l + r) >> 1),\n                            update(a, b, x, 2 * k + 1, (l + r) >> 1, r));\n      }\n   }\n   Monoid update(int a, int b, const OperatorMonoid &x) {\n      return update(a, b, x, 1, 0, sz);\n   }\n   Monoid query(int a, int b, int k, int l, int r) {\n      propagate(k, r - l);\n      if(r <= a || b <= l) {\n         return M1;\n      } else if(a <= l && r <= b) {\n         return data[k];\n      } else {\n         return f(query(a, b, 2 * k + 0, l, (l + r) >> 1),\n                  query(a, b, 2 * k + 1, (l + r) >> 1, r));\n      }\n   }\n   Monoid query(int a, int b) {\n      return query(a, b, 1, 0, sz);\n   }\n   Monoid operator[](const int &k) {\n      return query(k, k + 1);\n   }\n};\n\nsigned main()\n{\n   int n, q; cin >> n >> q;\n   V<int> c(q), s(q), t(q), x(q);\n   REP(i, q) {\n      cin >> c[i];\n      if (c[i] == 0) {\n         cin >> s[i] >> t[i] >> x[i];\n      } else {\n         cin >> s[i] >> t[i];\n      }\n   }\n   LazySegmentTree<int> lsegt(n,\n         [](int a,int b){ return a + b; },\n         [](int a,int b,int c){ return b * c; },\n         [](int a,int b){ return b; }, 0, 0);\n   REP(i, q) {\n      if (c[i] == 0) {\n         lsegt.update(s[i], t[i]+1, x[i]);\n      } else {\n         cout << lsegt.query(s[i], t[i]+1) << endl;\n      }\n   }\n\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <functional>\n\n#include <algorithm>\n#include <iostream>\n#include <utility>\n\n// Segment tree with lazy propagation.\ntemplate <class Data, class Operator>\nclass LazySegmentTree\n{\n\tint size_, height_;\n\n\t// (Data, F) is a monoid.\n\tstd::vector<Data> data_;\n\tusing F = std::function<Data(Data, Data)>;\n\tconst F f_;\n\tconst Data data_id_;\n\n\t// This is operation.\n\tusing G = std::function<Data(Data, Operator)>;\n\tconst G g_;\n\n\t// (Operator, H) is a monoid.\n\tstd::vector<Operator> lazy_;\n\tusing H = std::function<Operator(Operator, Operator)>;\n\tconst H h_;\n\tconst Operator operator_id_;\n\n\tvoid init(int num)\n\t{\n\t\tsize_ = 1;\n\t\theight_ = 0;\n\t\twhile (size_ < num)\n\t\t{\n\t\t\tsize_ <<= 1;\n\t\t\t++height_;\n\t\t}\n\t\tdata_.assign(size_ << 1, data_id_);\n\t\tlazy_.assign(size_ << 1, operator_id_);\n\t}\n\n\tinline Data reflect(int k)\n\t{\n\t\tif (lazy_[k] == operator_id_)\n\t\t{\n\t\t\treturn data_[k];\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn g_(data_[k], lazy_[k]);\n\t\t}\n\t}\n\n\tinline void eval(int k)\n\t{\n\t\tif (lazy_[k] == operator_id_)\n\t\t\treturn;\n\t\tlazy_[(k << 1) | 0] = h_(lazy_[(k << 1) | 0], lazy_[k]);\n\t\tlazy_[(k << 1) | 1] = h_(lazy_[(k << 1) | 1], lazy_[k]);\n\t\tdata_[k] = reflect(k);\n\t\tlazy_[k] = operator_id_;\n\t}\n\n\tinline void thrust(int k)\n\t{\n\t\tfor (int i = height_; i > 0; --i)\n\t\t{\n\t\t\teval(k >> i);\n\t\t}\n\t}\n\n\tinline void recalc(int k)\n\t{\n\t\twhile (k >>= 1)\n\t\t{\n\t\t\tdata_[k] = f_(reflect((k << 1) | 0), reflect((k << 1) | 1));\n\t\t}\n\t}\n\n  public:\n\tLazySegmentTree(F f, G g, H h, Data data_id, Operator operator_id)\n\t\t: f_(f), data_id_(data_id), g_(g), h_(h), operator_id_(operator_id) {}\n\n\tvoid build(const std::vector<Data> &elements)\n\t{\n\t\tconst int num = elements.size();\n\t\tinit(num);\n\t\tfor (int i = 0; i < num; ++i)\n\t\t{\n\t\t\tdata_[size_ + i] = elements[i];\n\t\t}\n\t\tfor (int i = size_ - 1; i > 0; --i)\n\t\t{\n\t\t\tdata_[i] = f_(data_[(i << 1) | 0], data_[(i << 1) | 1]);\n\t\t}\n\t}\n\n\tvoid update(int a, int b, Operator x)\n\t{\n\t\tthrust(a += size_);\n\t\tthrust(b += size_ - 1);\n\t\tfor (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1)\n\t\t{\n\t\t\tif (l & 1)\n\t\t\t{\n\t\t\t\tlazy_[l] = h_(lazy_[l], x);\n\t\t\t\t++l;\n\t\t\t}\n\t\t\tif (r & 1)\n\t\t\t{\n\t\t\t\t--r;\n\t\t\t\tlazy_[r] = h_(lazy_[r], x);\n\t\t\t}\n\t\t}\n\t\trecalc(a);\n\t\trecalc(b);\n\t}\n\n\tvoid set(int a, Data x)\n\t{\n\t\tthrust(a += size_);\n\t\tdata_[a] = x;\n\t\tlazy_[a] = operator_id_;\n\t\trecalc(a);\n\t}\n\n\tData query(int a, int b)\n\t{\n\t\tthrust(a += size_);\n\t\tthrust(b += size_ - 1);\n\t\tData vl = data_id_, vr = data_id_;\n\t\tfor (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1)\n\t\t{\n\t\t\tif (l & 1)\n\t\t\t{\n\t\t\t\tvl = f_(vl, reflect(l++));\n\t\t\t}\n\t\t\tif (r & 1)\n\t\t\t{\n\t\t\t\tvr = f_(reflect(--r), vr);\n\t\t\t}\n\t\t}\n\t\treturn f_(vl, vr);\n\t}\n};\n\nint main()\n{\n\t// range update, range sum\n\tint n, q;\n\tstd::cin >> n >> q;\n\tusing ll = long long;\n\tusing P = std::pair<ll, ll>;\n\tauto f = [](P a, P b) {\n\t\treturn P(a.first + b.first, a.second + b.second);\n\t};\n\tauto g = [](P a, ll b) {\n\t\tif (b == 1e12)\n\t\t{\n\t\t\treturn P(a.first, a.second);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn P(b * a.second, a.second);\n\t\t}\n\t};\n\tauto h = [](ll a, ll b) { return b; };\n\tLazySegmentTree<P, ll> seg_tree(f, g, h, P(0, 0), 1e12);\n\tseg_tree.build(std::vector<P>(n, P(0, 1)));\n\tfor (int i = 0; i < q; ++i)\n\t{\n\t\tint c, s, t;\n\t\tll x;\n\t\tstd::cin >> c;\n\t\tif (c)\n\t\t{\n\t\t\tstd::cin >> s >> t;\n\t\t\tstd::cout << seg_tree.query(s, t + 1).first << std::endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstd::cin >> s >> t >> x;\n\t\t\tseg_tree.update(s, t + 1, x);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <cassert>\n#include <stdexcept>\n#include <utility>\n\ntemplate <class ValueMonoid, class OperatorMonoid, class Modifier,\n\ttemplate <class> class Container>\nclass lazy_segment_tree {\npublic:\n\tusing value_structure = ValueMonoid;\n\tusing value_type = typename value_structure::value_type;\n\tusing const_reference = const value_type &;\n\tusing operator_structure = OperatorMonoid;\n\tusing operator_type = typename operator_structure::value_type;\n\tusing modifier_type = Modifier;\n\tusing container_type = Container<::std::pair<value_type, operator_type>>;\n\tusing size_type = typename container_type::size_type;\n\nprivate:\n\tsize_type size_, height;\n\tcontainer_type c;\n\tstatic size_type getheight(const size_type size) noexcept {\n\t\tsize_type ret = 0;\n\t\twhile (static_cast<size_type>(1) << ret < size)\n\t\t\t++ret;\n\t\treturn ret;\n\t}\n\tstatic value_type reflect(typename container_type::const_reference element) {\n\t\treturn modifier_type::operation(element.first, element.second);\n\t}\n\tvoid recalc(const size_type index) {\n\t\tc[index].first = value_structure::operation(reflect(c[index << 1]),\n\t\t\treflect(c[index << 1 | 1]));\n\t}\n\tstatic void assign(operator_type &element, const operator_type &data) {\n\t\telement = operator_structure::operation(element, data);\n\t}\n\tvoid push(const size_type index) {\n\t\tassign(c[index << 1].second, c[index].second);\n\t\tassign(c[index << 1 | 1].second, c[index].second);\n\t\tc[index].second = operator_structure::identity();\n\t}\n\tvoid propagate(const size_type index) {\n\t\tfor (size_type i = height; i; --i)\n\t\t\tpush(index >> i);\n\t}\n\tvoid thrust(const size_type index) {\n\t\tc[index].first = reflect(c[index]);\n\t\tpush(index);\n\t}\n\tvoid evaluate(const size_type index) {\n\t\tfor (size_type i = height; i; --i)\n\t\t\tthrust(index >> i);\n\t}\n\tvoid build(size_type index) {\n\t\twhile (index >>= 1)\n\t\t\trecalc(index);\n\t}\n\tsize_type base_size() const { return static_cast<size_type>(1) << height; }\n\npublic:\n\tlazy_segment_tree() : size_(0), height(0), c() {}\n\texplicit lazy_segment_tree(const size_type size)\n\t\t: size_(size), height(getheight(size_)),\n\t\tc(static_cast<size_type>(1) << (height + 1),\n\t\t{ value_structure::identity(), operator_structure::identity() }) {}\n\n\tbool empty() const { return !size_; }\n\tsize_type size() const { return size_; }\n\n\tconst_reference operator[](size_type index) {\n\t\tassert(index < size());\n\t\tindex += base_size();\n\t\tevaluate(index);\n\t\tc[index].first = reflect(c[index]);\n\t\tc[index].second = operator_structure::identity();\n\t\treturn c[index].first;\n\t}\n\tconst_reference at(size_type index) {\n\t\tif (index < size()) {\n\t\t\tthrow ::std::out_of_range(\"index out of range\");\n\t\t}\n\t\telse {\n\t\t\tindex += base_size();\n\t\t\tevaluate(index);\n\t\t\tc[index].first = reflect(c[index]);\n\t\t\tc[index].second = operator_structure::identity();\n\t\t\treturn c[index].first;\n\t\t}\n\t}\n\tvalue_type fold(size_type first, size_type last) {\n\t\tassert(first <= last);\n\t\tassert(first <= size());\n\t\tassert(last <= size());\n\t\tfirst += base_size();\n\t\tlast += base_size();\n\t\tevaluate(first);\n\t\tevaluate(last - 1);\n\t\tvalue_type retL = value_structure::identity(),\n\t\t\tretR = value_structure::identity();\n\t\tfor (; first < last; first >>= 1, last >>= 1) {\n\t\t\tif (first & 1)\n\t\t\t\tretL = value_structure::operation(retL, reflect(c[first++]));\n\t\t\tif (last & 1)\n\t\t\t\tretR = value_structure::operation(reflect(c[last - 1]), retR);\n\t\t}\n\t\treturn value_structure::operation(retL, retR);\n\t}\n\ttemplate <class F> size_type search(const F &f) {\n\t\tif (f(value_structure::identity()))\n\t\t\treturn static_cast<size_type>(0);\n\t\tif (!f(reflect(c[1])))\n\t\t\treturn size() + 1;\n\t\tvalue_type acc = value_structure::identity();\n\t\tsize_type i = 1;\n\t\twhile (i < base_size()) {\n\t\t\tthrust(i);\n\t\t\tif (!f(value_structure::operation(acc, reflect(c[i <<= 1]))))\n\t\t\t\tacc = value_structure::operation(acc, reflect(c[i++]));\n\t\t}\n\t\treturn i - base_size() + 1;\n\t}\n\n\tvoid update(size_type index, const value_type &data) {\n\t\tassert(index < size());\n\t\tindex += base_size();\n\t\tpropagate(index);\n\t\tc[index].first = data;\n\t\tc[index].second = operator_structure::identity();\n\t\tbuild(index);\n\t}\n\tvoid update(size_type first, size_type last, const operator_type &data) {\n\t\tassert(first <= last);\n\t\tassert(first <= size());\n\t\tassert(last <= size());\n\t\tfirst += base_size();\n\t\tlast += base_size();\n\t\tpropagate(first);\n\t\tpropagate(last - 1);\n\t\tfor (size_type left = first, right = last; left < right;\n\t\t\tleft >>= 1, right >>= 1) {\n\t\t\tif (left & 1)\n\t\t\t\tassign(c[left++].second, data);\n\t\t\tif (right & 1)\n\t\t\t\tassign(c[right - 1].second, data);\n\t\t}\n\t\tbuild(first);\n\t\tbuild(last - 1);\n\t}\n};\n\n#include <cstddef>\n#include <utility>\ntemplate <class T, class Size = ::std::size_t> class sum_monoid {\npublic:\n\tusing size_type = Size;\n\tusing value_type = ::std::pair<T, size_type>;\n\tstatic T get(const value_type &x) { return x.first; }\n\tstatic value_type operation(const value_type &x, const value_type &y) {\n\t\treturn value_type(x.first + y.first, x.second + y.second);\n\t}\n\tstatic value_type identity() { return value_type(T(0), size_type(0)); }\n\tstatic value_type reverse(const value_type &x) { return x; }\n};\n\n#include <type_traits>\n#include <utility>\ntemplate <class T> class optional {\npublic:\n\tusing value_type = T;\n\nprivate:\n\ttypename ::std::aligned_storage<sizeof(value_type), alignof(value_type)>::type\n\t\tstorage;\n\tbool hasv;\n\tvalue_type *data() {\n\t\treturn static_cast<value_type *>(static_cast<void *>(&storage));\n\t}\n\tconst value_type *data() const {\n\t\treturn static_cast<const value_type *>(static_cast<const void *>(&storage));\n\t}\n\npublic:\n\toptional() : hasv(0) {}\n\ttemplate <class... Args> explicit optional(Args &&... args) : hasv(1) {\n\t\t::new (data()) value_type(::std::forward<Args>(args)...);\n\t}\n\tvoid reset() {\n\t\thasv = 0;\n\t\tdata()->~value_type();\n\t}\n\tvalue_type &operator*() & { return *data(); }\n\tconst value_type &operator*() const & { return *data(); }\n\tvalue_type &&operator*() && { return *data(); }\n\tconst value_type &&operator*() const && { return *data(); }\n\tvalue_type *operator->() { return data(); }\n\tconst value_type *operator->() const { return data(); }\n\texplicit operator bool() const { return hasv; }\n\tbool has_value() const { return hasv; }\n\tvalue_type &value() & { return *data(); }\n\tconst value_type &value() const & { return *data(); }\n\tvalue_type &&value() && { return *data(); }\n\tconst value_type &&value() const && { return *data(); }\n\ttemplate <class U> value_type value_or(U &&v) const & {\n\t\treturn has_value() ? value() : static_cast<T>(::std::forward<U>(v));\n\t}\n\ttemplate <class U> value_type value_or(U &&v) && {\n\t\treturn has_value() ? value() : static_cast<T>(::std::forward<U>(v));\n\t}\n};\ntemplate <class T> class assign_monoid {\npublic:\n\tusing value_type = optional<T>;\n\tstatic value_type operation(const value_type &x, const value_type &y) {\n\t\treturn y ? y : x;\n\t}\n\tstatic value_type identity() { return value_type(); }\n};\n\n#include <utility>\ntemplate <class T, class S> class sum_assignment {\npublic:\n\tstatic ::std::pair<T, S> operation(const ::std::pair<T, S> &x, const optional<T> &y) {\n\t\treturn y ? ::std::pair<T, S>(y.value() * x.second, x.second) : x;\n\t}\n};\n\n\n#include <cstdio>\n#include <vector>\n\ntemplate<class T> using vec_alias = ::std::vector<T>;\n\nint main() {\n\tusing uint = unsigned int;\n\tusing sum = sum_monoid<int>;\n\n\tuint n, q;\n\tscanf(\"%u%u\", &n, &q);\n\n\tlazy_segment_tree<\n\t\tsum,\n\t\tassign_monoid<int>,\n\t\tsum_assignment<int,sum::size_type>,\n\t\tvec_alias> seg(n);\n\tfor (int i = 0;i < n;++i)\n\t\tseg.update(i, { 0,1 });\n\n\tuint c, s, t;\n\tint x;\n\twhile (q--) {\n\t\tscanf(\"%u%u%u\", &c, &s, &t);\n\n\t\tif (c) {\n\t\t\tprintf(\"%d\\n\", seg.fold(s, t + 1).first);\n\t\t}\n\t\telse {\n\t\t\tscanf(\"%d\", &x);\n\t\t\tseg.update(s, t + 1, optional<int>(x));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<iomanip>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n#include <stdio.h>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <map>\n#include <list>\n#include <string>\n#include <numeric>\n#include <utility>\n#include <cfloat>\n#include <set>\n \nusing namespace std;\n \nint sqrtN = 512;\nstruct SqrtDecomposition{\n    int N, K;\n    vector <long long> data;\n    vector <long long> bucketUpdatedLazy;\n    vector <long long> bucketSum;\n     \n    SqrtDecomposition(int n){\n        N = n;\n        K = (N + sqrtN - 1) / sqrtN;\n        data.assign(N + sqrtN, 0);\n        bucketUpdatedLazy.assign(K, -1);\n        bucketSum.assign(K, 0);\n    }\n \n    void propagateLazy(int k){\n        if(bucketUpdatedLazy[k] < 0){\n            return;\n        }\n        for(int i = 0; i < sqrtN; i++){\n            data[k * sqrtN + i] = bucketUpdatedLazy[k];\n        }\n        bucketSum[k] = bucketUpdatedLazy[k] * sqrtN;\n        bucketUpdatedLazy[k] = -1;\n    }\n\n\n    long long get(int x){\n        propagateLazy(x / sqrtN);\n        return data[x];\n    }\n\n    long long getSum(int x, int y){\n        propagateLazy(x / sqrtN);\n        propagateLazy((y - 1) / sqrtN);\n        long long ans = 0;\n        if(y - x < sqrtN){\n            for(int i = x; i < y; i++){\n                ans += data[i];\n            }\n            return ans;\n        }\n        for(int i = x / sqrtN + 1; i < y / sqrtN; i++){\n            ans += bucketSum[i];\n        }\n\n        for(int i = x; i < (x / sqrtN + 1) * sqrtN; i++){\n            ans += data[i];\n        }\n        for(int i = y / sqrtN * sqrtN; i < y; i++){\n            ans += data[i];\n        }\n        return ans;\n    }\n \n    void update(int x, int y, long long a){\n        if(y - x < sqrtN){\n            propagateLazy(x / sqrtN);\n            propagateLazy((y - 1) / sqrtN);\n            for(int i = x; i < y; i++){\n                bucketSum[i/sqrtN] += (a - data[i]);\n                data[i] = a;\n            }\n            return;\n        }\n        for(int i = x / sqrtN + 1; i < y / sqrtN; i++){\n            bucketUpdatedLazy[i] = a;\n            bucketSum[i] = a * sqrtN;\n        }\n\n        propagateLazy(x / sqrtN);\n        for(int i = x; i < (x / sqrtN + 1) * sqrtN; i++){\n            bucketSum[i/sqrtN] += (a - data[i]);\n            data[i] = a;\n        }\n        propagateLazy((y - 1)/ sqrtN);\n        for(int i = y / sqrtN * sqrtN; i < y; i++){\n            bucketSum[i/sqrtN] += (a - data[i]);\n            data[i] = a;\n        }\n    }\n     \n};\n\n \nint main(){\n    int n;\n    int q;\n    cin >> n >> q;\n    SqrtDecomposition sq(n);\n    for(int i = 0; i < q; i++){\n        int com;\n        int s;\n        int t;\n        int x;\n        cin >> com;\n        if(com == 0){\n            cin >> s >> t >> x;\n            sq.update(s, t + 1, x);\n        } else {\n            cin >> s >> t;\n            cout << sq.getSum(s, t + 1) << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\n/*Starry Sky Tree*/\n/*Range Add Min(Max) Query*/\n/*区間加算、区間Min,区間Max*/\n\nclass RSUQ{\npublic: \n  \n  //遅延用の型  \n  struct T{\n    int type; //0 - empty   , 1 - update\n    int value;\n    T():type(0),value(0){}\n    T(int type,int value):type(type),value(value){}\n  };\n\n  //マージ可能な主データ型\n  struct D{\n    int value;\n    D():value(0){} /*適切な値にする!!!!!!*/\n    D(int value):value(value){}\n    bool operator < (D a)const {return value < a.value;} //merge用\n  };\n  \n  int n;\n  vector<D> dat;\n  vector<T> td;\n  D returnD = D(0); // 範囲外の時に返す値。\n  \n  RSUQ(){n=-1;}\n  RSUQ(int n_){\n    n=1;\n    while(n < n_) n *= 2;\n    td.resize(2*n-1,T());\n    dat.resize(2*n-1,D());\n  }\n  \n  D merge(D a,D b){return a.value + b.value;}\n  \n  void delay(int k,int len){\n    if(td[k].type==0) return;\n    int v = td[k].value;\n    td[k].type = 0;\n    td[k].value = 0;\n    \n    len /= 2;\n    int l = k*2+1,r = k*2+2;\n    dat[l].value = v * len; td[l].type = 1; td[l].value = v;\n    dat[r].value = v * len; td[r].type = 1; td[r].value = v;\n  }\n\n  D write(int k,int x, int len){\n    dat[k].value = x * len;\n    td[k].type = 1;\n    td[k].value = x;\n    return dat[k];\n  }\n  \n  //[a,b)の値をx変更　query(a,b,x)\n  D update(int a,int b,int x,bool flg=true,int k=0,int l=0,int r=-1){\n    if(r==-1) r=n, assert(a <= n && b <= n);\n    if(r <= a||b <= l) return flg? dat[k]:returnD;\n    if(a <= l && r <= b) return flg? write(k, x, r - l):dat[k];\n    \n    delay(k, r - l);\n    D vl = update(a,b,x,flg,k*2+1,l,(l+r)/2);\n    D vr = update(a,b,x,flg,k*2+2,(l+r)/2,r);\n    if(flg) dat[k] = merge(vl, vr);\n    return merge(vl, vr);\n  }\n  \n  //[a,b)の合計値を得る　find(a,b);\n  int find(int a,int b){\n    D res = update(a,b,0,false);\n    return res.value;\n  }\n};\n\n\nsigned main(){\n  int n,q;\n  cin>>n>>q;\n  \n  RSUQ rsuq(n);\n\n  while(q--){\n    int cmd;\n    cin>>cmd;\n    if(cmd == 0){\n      int s,t,x;\n      cin>>s>>t>>x;\n      rsuq.update(s,t+1,x);\n    }\n    if(cmd == 1){\n      int s,t;\n      cin>>s>>t;\n      assert(s != t);\n      cout<<rsuq.find(s,t+1)<<endl;\n    }\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define all(vec) vec.begin(), vec.end()\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nconstexpr ll INF = (1LL << 30) - 1LL;\nconstexpr ll LINF = (1LL << 60) - 1LL;\nconstexpr double eps = 1e-9;\nconstexpr ll MOD = 1000000007LL;\ntemplate <typename T>\nbool chmin(T& a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n};\ntemplate <typename T>\nbool chmax(T& a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n};\ntemplate <typename T>\nostream& operator<<(ostream& os, vector<T> v) {\n    for(int i = 0; i < v.size(); i++) {\n        os << v[i] << (i + 1 == v.size() ? \"\\n\" : \" \");\n    }\n    return os;\n}\ntemplate <typename T>\nvector<T> make_v(size_t a) {\n    return vector<T>(a);\n}\ntemplate <typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\ntemplate <typename T, typename V>\ntypename enable_if<is_class<T>::value == 0>::type fill_v(T& t, const V& v) {\n    t = v;\n}\ntemplate <typename T, typename V>\ntypename enable_if<is_class<T>::value != 0>::type fill_v(T& t, const V& v) {\n    for(auto& e : t) {\n        fill_v(e, v);\n    }\n};\ntemplate <class Monoid, class OperatorMonoid>\nstruct Segtree {\n    using T = typename Monoid::T;\n    using E = typename OperatorMonoid::E;\n    int n, h;\n    vector<T> dat;\n    vector<E> laz;\n    Segtree(int n_) {\n        n = 1, h = 0;\n        while(n < n_) {\n            n <<= 1;\n            ++h;\n        }\n        dat.resize(2 * n, Monoid::id());\n        laz.resize(2 * n, OperatorMonoid::id());\n    }\n    inline int len(int k) { return (n >> (int)log2(k)); }\n    inline T prop(int k) {\n        if(laz[k] == OperatorMonoid::id()) {\n            return dat[k];\n        }\n        dat[k] = OperatorMonoid::merge(dat[k], laz[k], len(k));\n        if(k < n) {\n            laz[k << 1] = OperatorMonoid::op(laz[k << 1], laz[k]);\n            laz[k << 1 | 1] = OperatorMonoid::op(laz[k << 1 | 1], laz[k]);\n        }\n        laz[k] = OperatorMonoid::id();\n        return dat[k];\n    }\n    inline void down(int k) {\n        for(int i = h; i > 0; i--) {\n            prop(k >> i);\n        }\n    }\n    inline void up(int k) {\n        while(k >>= 1) {\n            dat[k] = Monoid::op(prop(k << 1), prop(k << 1 | 1));\n        }\n    }\n    void update(int a, int b, const E& x) {  //[a,b]->[a,b)\n        int l = a + n, r = b + n;\n        down(l);\n        down(r);\n        for(++r; l < r; l >>= 1, r >>= 1) {\n            if(l & 1) {\n                laz[l] = OperatorMonoid::op(laz[l], x);\n                l++;\n            }\n            if(r & 1) {\n                --r;\n                laz[r] = OperatorMonoid::op(laz[r], x);\n            }\n        }\n        l = a + n, r = b + n;\n        up(l);\n        up(r);\n    }\n    T query(int a, int b) {  //[a,b]->[a,b)\n        int l = a + n, r = b + n;\n        down(l);\n        down(r);\n        T vl = Monoid::id(), vr = Monoid::id();\n        for(++r; l < r; l >>= 1, r >>= 1) {\n            if(l & 1) {\n                vl = Monoid::op(vl, prop(l++));\n            }\n            if(r & 1) {\n                vr = Monoid::op(prop(--r), vr);\n            }\n        }\n        return Monoid::op(vl, vr);\n    }\n};\ntemplate <class U>\nstruct RangeSum {\n    using T = U;\n    static T op(const T& a, const T& b) { return a + b; }\n    static constexpr T id() { return 0; }\n};\n\ntemplate <class V>\nstruct RangeUpd {\n    using E = V;\n    static E op(const E& a, const E& b) { return b; }\n    template <typename T>\n    static T merge(const T& a, const E& b, const ll& len) {\n        return b * len;\n    }\n    static constexpr E id() { return INF; }\n};\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, q;\n    cin >> n >> q;\n    Segtree<RangeSum<ll>, RangeUpd<ll>> seg(n);\n    while(q--) {\n        int t, l, r;\n        cin >> t >> l >> r;\n        if(t == 0) {\n            ll x;\n            cin >> x;\n            seg.update(l, r, x);\n        } else {\n            cout << seg.query(l, r) << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n// #define inf  998244353\n\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int Gcd(int v,int b){\n                                \tif(v==0) return b;\n                                \tif(b==0) return v;\n                                \tif(v>b) return Gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn Gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                              \n                int pr[10];\n                int inv[10];\n                \n\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=((ll)pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=(ll)inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\nstruct seg_rangeupd_getsum{\n\t//       1\n\t//   2        3\n\t// 4   5   6    7\n\t\n\t\n\tprivate:\n\tpublic:\n\t\n\t// (1<<15)=32768\n\t// 1<<16 = 65536\n\t// 1<<17 = 131072\n\t// 1<<18 = 262144\n\t\n\tint cor=(1<<18);\n\tint inff=inf*1000000ll;\n\t\n\tvector<int> vec;\n\tvector<int> lazy;\n\tvoid shoki1(){\n\t\tvec.resize(2*cor+3, 0);\n\t\tlazy.resize(2*cor+3, inff);\n\t}\n\tvoid shoki2(){\n\t\t//lazy[1]=(1ll<<31)-1;\n\t\t//初期値\n\t}\n\t\t\n\tint chien(int k,int len){\n\t\tif(lazy[k]==inff) return vec[k];\n\t\tif(k<cor){\n\t\t\tvec[k]=lazy[k]*len;\n\t\t\tlazy[2*k]=lazy[k];\n\t\t\tlazy[2*k+1]=lazy[k];\n\t\t\tlazy[k]=inff;\n\t\t}\n\t\telse {\n\t\t\tvec[k]=lazy[k];\n\t\t\tlazy[k]=inff;\n\t\t}\n\t\treturn vec[k];\n\t}\n\tvoid  clear_chien(int r){\n\t\t// 1 ~ r までの遅延を開放する\n\t\tif(r==0)return;\n\t\tint f=31-__builtin_clz(r);\n\t\tint pos=0;\n\t\tint len=cor;\n\t\tfor(int i=f;i>=0;i--){\n\t\t\tpos*=2;\n\t\t\tpos+=!!(r&(1<<i));\n\t\t\tchien(pos,len);\n\t\t\tlen/=2;\n\t\t}\n\t\t\n\t}\n\n\n\tvoid rangeupd(int a,int b,int w){\n\t\ta+=cor,b+=cor;\n\t\tint aa=a/(a&(-a))/2;\n\t\tint bb=b/(b&(-b))/2;\n\t\tint lenaa=2*(a&-a);\n\t\tint lenbb=2*(b&-b);\n\tclear_chien(aa);\n\tclear_chien(bb);\n\t\twhile(a<b){\n\t\t\tif(a&1){\n\t\t\t\tlazy[a]=w;\n\t\t\t\ta++;\n\t\t\t}\n\t\t\tif(b&1){\n\t\t\t\tb--;\n\t\t\t\tlazy[b]=w;\n\t\t\t}\n\t\t\ta/=2,b/=2;\n\t\t}\n\n\t\twhile(aa>0 || bb>0){\n\t\t\tif(aa>bb){\n\t\t\t\tvec[aa]=chien(2*aa,lenaa/2)+chien(2*aa+1,lenaa/2);\n\t\t\t\taa/=2;\t\t\n\t\t\t\tlenaa*=2;\n\t\t\t}\n\t\t\telse if(aa<bb){\n\t\t\t\tvec[bb]=chien(2*bb,lenbb/2)+chien(2*bb+1,lenbb/2);\n\t\t\t\tbb/=2;\t\n\t\t\t\tlenbb*=2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tvec[aa]=chien(2*aa,lenaa/2)+chien(2*aa+1,lenaa/2);\n\t\t\t\taa/=2;\t\t\n\t\t\t\tlenaa*=2;\n\t\t\t\tbb=aa,lenbb=aa;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tint getsum(int a,int b){\n\t\ta+=cor,b+=cor;\n\t\tint aa=a/(a&(-a))/2;\n\t\tint bb=b/(b&(-b))/2;\n\t\tclear_chien(aa);\n\t\tclear_chien(bb);\n\t\n\t\tint ans=0;\n\t\t\n\t\tint len=1;\n\t\twhile(a<b){\n\t\t\tif(a&1){\n\t\t\t\tans+=chien(a,len);\n\t\t\t\ta++;\n\t\t\t}\n\t\t\tif(b&1){\n\t\t\t\tb--;\n\t\t\t\tans+=chien(b,len);\n\t\t\t}\n\t\t\ta/=2,b/=2,len*=2;\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\t\n\t\n\t// 位置pからはじめて和がx以上になる位置．ない場合はcorが返る\n\tint lower_bound(int p,int x){\n\t\tp+=cor;\n\t\tint ima=0;\n\t\tbool fst=1;\n\t\tint len=1;\n\t\twhile(1){\n\t\t\twhile(!(p&1))p/=2,len*=2;\n\t\t\tif(fst)fst=0,clear_chien(p/2);\n\t\t\tif(ima+chien(p,len)>=x)break;//条件を満たさなくなる\n\t\t\tima=ima+vec[p];\n\t\t\tp++;\n\t\t\tif(p==(p&(-p))) return cor;\n\t\t}\n\t\twhile(1){\n\t\t\tif(p>=cor) return p-cor;\n\t\t\tp*=2;\n\t\t\tlen/=2;\n\t\t\tif(ima+chien(p,len)<x){//条件を満たす\n\t\t\t\tima+=vec[p];\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\t// 位置pからはじめて和がxより大になる位置．ない場合はcorが返る\n\tint upper_bound(int p,int x){\n\t\tp+=cor;\n\t\tint ima=0;\n\t\tbool fst=1;\n\t\tint len=1;\n\t\twhile(1){\n\t\t\twhile(!(p&1))p/=2,len*=2;\n\t\t\tif(fst)fst=0,clear_chien(p/2);\n\t\t\tif(ima+chien(p,len)>x)break;//条件を満たさなくなる\n\t\t\tima=ima+vec[p];\n\t\t\tp++;\n\t\t\tif(p==(p&(-p))) return cor;\n\t\t}\n\t\twhile(1){\n\t\t\tif(p>=cor) return p-cor;\n\t\t\tp*=2;\n\t\t\tlen/=2;\n\t\t\tif(ima+chien(p,len)<=x){//条件を満たす\n\t\t\t\tima+=vec[p];\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t}\n\t\n};\n\n\n\nint rand2(){\n\treturn rand()*rand()&((1<<18)-1);\n}\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\nint n,q;\n\tcin>>n>>q;\nseg_rangeupd_getsum ss;\n//seg_rangeadd_getmin2 ss2;\n\tss.shoki1();\n//\tss2.shoki1();\n\t\n\tfor(int i=0;i<q;i++){\n\t\tint t;\n\t\tcin>>t;\n\t\tif(t){\n\t\t\tint y,yy;\n\t\t\tcin>>y>>yy;\n\t\t\tyy++;\n\t\t\tcout<<ss.getsum(y,yy)<<endl;\n\t\t}\n\t\telse{\n\t\t\tint y,yy,yyy;\n\t\t\t\n\t\t\tcin>>y>>yy>>yyy;\n\t\t\tss.rangeupd(y,yy+1,yyy);\n\t\t}\n\t}\n\t\n\t/*\n\tfor(int i=0;i<=1000000;i++){\n\t//\tcout<<rand2()<<endl;\n\t\tif(rand()&1){\n\t\t\tint l=rand2();\n\t\t\tint r=rand2();\n\t\t\tif(l>r)swap(l,r);\n\t\t\tint v=rand()%100;\n\t\t\tv-=49;\n\t//\t\tcout<<v<<endl;\n\t\t\tss.rangeadd(l,r,v);\n\t\t//\tss2.rangeadd(l,r,v);\n\t\t\t\n\t\t\t\n\t\t}\n\t\telse{\n\t\t\tint l=rand2();\n\t\t\tint r=rand2();\n\t\t\tif(l>r)swap(l,r);\n\t\t\tif(l==r)continue;\n\t\t\t\n\t\t\tif(ss2.getmin(l,r)!=ss.getmin(l,r)){\n\t\t\t\tcout<<i<<endl;\n\t\t\t\tcout<<\"!!!\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t\tans^=ss.getmin(l,r);\n\t\t}\n\t}\n*/\n\t\n\treturn 0;\n }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<iomanip>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n#include <stdio.h>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <map>\n#include <list>\n#include <string>\n#include <numeric>\n#include <utility>\n#include <cfloat>\n#include <set>\n \nusing namespace std;\n \nint sqrtN = 512;\nstruct SqrtDecomposition{\n    int N, K;\n    vector <long long> data;\n    vector <long long> bucketUpdatedLazy;\n    vector <long long> bucketSum;\n     \n    SqrtDecomposition(int n){\n        N = n;\n        K = (N + sqrtN - 1) / sqrtN;\n        data.assign(N + sqrtN, 0);\n        bucketUpdatedLazy.assign(K, -1);\n        bucketSum.assign(K, 0);\n    }\n \n    void propagateLazy(int k){\n        if(bucketUpdatedLazy[k] < 0){\n            return;\n        }\n        for(int i = 0; i < sqrtN; i++){\n            data[k * sqrtN + i] = bucketUpdatedLazy[k];\n        }\n        bucketSum[k] = bucketUpdatedLazy[k] * sqrtN;\n        bucketUpdatedLazy[k] = -1;\n    }\n\n\n    long long get(int x){\n        propagateLazy(x / sqrtN);\n        return data[x];\n    }\n\n    long long getSum(int x, int y){\n        propagateLazy(x / sqrtN);\n        propagateLazy((y - 1) / sqrtN);\n        long long ans = 0;\n        if(y - x < sqrtN){\n            for(int i = x; i < y; i++){\n                ans += data[i];\n            }\n            return ans;\n        }\n        for(int i = x / sqrtN + 1; i < y / sqrtN; i++){\n            ans += bucketSum[i];\n        }\n\n        for(int i = x; i < (x / sqrtN + 1) * sqrtN; i++){\n            ans += data[i];\n        }\n        for(int i = y / sqrtN * sqrtN; i < y; i++){\n            ans += data[i];\n        }\n        return ans;\n    }\n \n    void update(int x, int y, long long a){\n        if(y - x < sqrtN){\n            propagateLazy(x / sqrtN);\n            propagateLazy((y - 1) / sqrtN);\n            for(int i = x; i < y; i++){\n                bucketSum[i/sqrtN] += (a - data[i]);\n                data[i] = a;\n            }\n            return;\n        }\n        for(int i = x / sqrtN + 1; i < y / sqrtN; i++){\n            bucketUpdatedLazy[i] = a;\n            bucketSum[i] = a * sqrtN;\n        }\n\n        propagateLazy(x / sqrtN);\n        for(int i = x; i < (x / sqrtN + 1) * sqrtN; i++){\n            bucketSum[i/sqrtN] += (a - data[i]);\n            data[i] = a;\n        }\n        propagateLazy((y - 1)/ sqrtN);\n        for(int i = y / sqrtN * sqrtN; i < y; i++){\n            bucketSum[i/sqrtN] += (a - data[i]);\n            data[i] = a;\n        }\n    }\n     \n};\n\n \nint main(){\n    int n;\n    int q;\n    cin >> n >> q;\n    SqrtDecomposition sq(n);\n    for(int i = 0; i < q; i++){\n        int com;\n        int s;\n        int t;\n        int x;\n        cin >> com;\n        if(com == 0){\n            cin >> s >> t >> x;\n            sq.update(s, t + 1, x);\n        } else {\n            cin >> s >> t;\n            cout << sq.getSum(s, t + 1) << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T, class E> struct LazySegmentTree {\n    using F = function<T(T, T)>;\n    using G = function<T(T, E)>;\n    using H = function<E(E, E)>;\n    using P = function<E(E, int)>;\nprivate :\n    int n;\n    F f;\n    G g;\n    H h;\n    P p;\n    T id1;\n    E id0;\n    vector<T> node;\n    vector<E> lazy;\npublic :\n    LazySegmentTree (int sz, F f, G g, H h, T id1, E id0, P p)\n            : f(f), g(g), h(h), id1(id1), id0(id0), p(p) {\n        n = 1; while (n < sz) n *= 2;\n        node.resize(2*n-1, id1);\n        lazy.resize(2*n-1, id0);\n    }\n\n    LazySegmentTree (vector<T> v, F f, G g, H h, T id1, E id0, P p)\n            : f(f), g(g), h(h), id1(id1), id0(id0), p(p) {\n        n = 1; while (n < (int)v.size()) n *= 2;\n        node.resize(2*n-1, id1);\n        lazy.resize(2*n-1, id0);\n        for (int i = 0; i < (int)v.size(); i++){\n            node[i+n-1] = v[i];\n        }\n        for (int i = n-2; i >= 0; i--) {\n            node[i] = f(node[2*i+1], node[2*i+2]);\n        }\n    }\n\n    inline void eval (int len, int k) {\n        if (lazy[k] == id0) return;\n        if (k*2+1 < n*2-1) {\n            lazy[2*k+1] = h(lazy[2*k+1], lazy[k]);\n            lazy[2*k+2] = h(lazy[2*k+2], lazy[k]);\n        }\n        node[k] = g(node[k], p(lazy[k], len));\n        lazy[k] = id0;\n    }\n\n    T update (int a, int b, E x, int k, int l, int r) {\n        eval(r-l, k);\n        if (r <= a || b <= l) return node[k];\n        if (a <= l && r <= b) {\n            lazy[k] = h(lazy[k], x);\n            return g(node[k], p(lazy[k], r-l));\n        }\n        return node[k] = f(update(a, b, x, 2*k+1, l, (l+r)/2),\n                           update(a, b, x, 2*k+2, (l+r)/2, r));\n    }\n\n    T update (int a, int b, E x) {\n        return update(a, b, x, 0, 0, n);\n    }\n\n    T query (int a, int b, int k, int l, int r) {\n        eval(r-l, k);\n        if (r <= a || b <= l) return id1;\n        if (a <= l && r <= b) return node[k];\n        T vl = query(a, b, 2*k+1, l, (l+r)/2);\n        T vr = query(a, b, 2*k+2, (l+r)/2, r);\n        return f(vl, vr);\n    }\n\n    T query (int a, int b) {\n        return query(a, b, 0, 0, n);\n    }\n\n};\n\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    \n    const long long id1 = 0LL;\n    const long long id0 = INT64_MAX;\n    auto f = [](long long a, long long b) { return a + b; };\n    auto g = [&](long long a, long long b) { return (b == id0 ? a : b); };\n    auto h = [&](long long a, long long b) { return (b == id0 ? a : b); };\n    auto p = [](long long a, int b) { return (long long)a*b; };\n    LazySegmentTree<long long, long long> seg(vector<long long>(n, 0LL), f, g, h, id1, id0, p);\n\n\n    while (q--) {\n        int op;\n        cin >> op;\n        if (op == 0) {\n            int s, t;\n            long long x;\n            cin >> s >> t >> x;\n            seg.update(s, t+1, x);\n        } else {\n            int s, t;\n            cin >> s >> t;\n            cout << seg.query(s, t+1) << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <functional>\n#include <limits>\n\ntemplate <class Data, class Operator>\nclass LazySegmentTree {\n    using DataMerger = std::function<Data(Data, Data)>;\n    using OperatorMerger = std::function<Operator(Operator, Operator)>;\n    using Applier = std::function<Data(Data, Operator, int)>;\n\npublic:\n    int length;\n    std::vector<Data> dat;\n    std::vector<Operator> ope;\n    Data dat_id;\n    Operator ope_id;\n    DataMerger datm;\n    OperatorMerger opem;\n    Applier app;\n\n    explicit LazySegmentTree(int N, Data dat_id, Operator ope_id, DataMerger datm, OperatorMerger opem, Applier app)\n        : length(1), dat_id(dat_id), ope_id(ope_id), datm(datm), opem(opem), app(app) {\n        while (length < N) length *= 2;\n        dat.assign(length * 2, dat_id);\n        ope.assign(length * 2, ope_id);\n    }\n\n    void eval(int nidx, int len) {\n        if (ope[nidx] == ope_id) return;\n        // 子に作用素を伝播\n        if (nidx * 2 + 1 < length * 2) {\n            ope[nidx * 2] = opem(ope[nidx * 2], ope[nidx]);\n            ope[nidx * 2 + 1] = opem(ope[nidx * 2 + 1], ope[nidx]);\n        }\n        // 値に作用素を反映\n        dat[nidx] = app(dat[nidx], ope[nidx], len);\n        ope[nidx] = ope_id;\n    }\n\n    // half-open interval [ql, qr)\n    Data update(int ql, int qr, Operator e) { return update(ql, qr, e, 1, 0, length); }\n    Data update(int ql, int qr, Operator e, int nidx, int nl, int nr) {\n        eval(nidx, nr - nl);\n        if (nr <= ql || qr <= nl) return dat[nidx];\n        if (ql <= nl && nr <= qr) {\n            ope[nidx] = opem(ope[nidx], e);\n            return app(dat[nidx], ope[nidx], nr - nl);\n        }\n        // 子を再帰的に更新\n        Data vl = update(ql, qr, e, nidx * 2, nl, (nl + nr) / 2);\n        Data vr = update(ql, qr, e, nidx * 2 + 1, (nl + nr) / 2, nr);\n        // 子の更新後から値を更新\n        return dat[nidx] = datm(vl, vr);\n    }\n\n    // half-open interval [ql, qr)\n    Data query(int ql, int qr) { return query(ql, qr, 1, 0, length); }\n    Data query(int ql, int qr, int nidx, int nl, int nr) {\n        eval(nidx, nr - nl);\n        if (nr <= ql || qr <= nl) return dat_id;\n        if (ql <= nl && nr <= qr) return dat[nidx];\n        Data vl = query(ql, qr, nidx * 2, nl, (nl + nr) / 2);\n        Data vr = query(ql, qr, nidx * 2 + 1, (nl + nr) / 2, nr);\n        return datm(vl, vr);\n    }\n};\n\nusing ll = long long;\nconst ll INF = std::numeric_limits<ll>::max();\n\nint main() {\n    int N, Q;\n    std::cin >> N >> Q;\n    LazySegmentTree<ll, ll> seg(N, 0, -INF,\n                                [](ll a, ll b) { return a + b; },\n                                [](ll e, ll f) { return (f == -INF ? e : f); },\n                                [](ll a, ll e, int k) { return (e == -INF ? a : e * k); });\n\n    for (int q = 0; q < Q; ++q) {\n        int k;\n        std::cin >> k;\n        if (k == 0) {\n            int l, r;\n            ll x;\n            std::cin >> l >> r >> x;\n            seg.update(l, r + 1, x);\n        } else {\n            int l, r;\n            std::cin >> l >> r;\n            std::cout << seg.query(l, r + 1) << std::endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)n; i++)\nusing ll = long long;\nconst ll INF = 1e17;\n\ntemplate<typename T, typename E, typename F, typename G, typename H>\nclass LazySegmentTree {\n  int n, height;\n  F f; G g; H h; const T ti; const E ei;\n  vector<T> dat; vector<E> laz; vector<int> highest;\n\n  void propagate(int k) {\n    if(laz[k] != ei) {\n      laz[2*k] = h(laz[2*k],laz[k]); laz[2*k+1] = h(laz[2*k+1],laz[k]);\n      dat[k] = g(dat[k],laz[k],n/highest[k]);\n      laz[k] = ei;\n    }\n  }\n  inline void recalc(int k) {\n    while(k >>= 1) dat[k] = f(g(dat[2*k],laz[2*k],n/highest[2*k]),g(dat[2*k+1],laz[2*k+1],n/highest[2*k+1]));\n  }\n  inline void thrust(int k) {\n    for(int i = height; i > 0; i--) propagate(k >> i);\n  }\npublic:\n  LazySegmentTree(int _n, F f, G g, H h, T ti, E ei): f(f), g(g), h(h), ti(ti), ei(ei) {\n    n = 1; height = 0;\n    while(n < _n) n <<= 1, height++;\n    dat.assign(2*n,ti); laz.assign(2*n,ei); highest.assign(2*n,0);\n    int c = 1;\n    for(int i = 1; i < 2*n; i++) {\n      if(c*2 <= i) c <<= 1;\n      highest[i] = c;\n    }\n  }\n  void set(int k, T x) {\n    dat[k+n] = x;\n  }\n  void build() {\n    for(int i = n-1; i >= 0; i--) {\n      dat[i] = f(dat[2*i],dat[2*i+1]);\n    }\n  }\n  void update(int a, int b, const E x) {\n    thrust(a += n); thrust(b += n-1);\n    for(int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) laz[l] = h(laz[l],x), ++l;\n      if(r & 1) --r, laz[r] = h(laz[r],x);\n    }\n    recalc(a); recalc(b);\n  }\n  T query(int a, int b) {\n    thrust(a += n); thrust(b += n-1);\n    T l = ti, r = ti; b++;\n    while(a < b) {\n      if(a & 1) l = f(l,g(dat[a],laz[a],n/highest[a])), a++;\n      if(b & 1) b--, r = f(g(dat[b],laz[b],n/highest[b]),r);\n      a >>= 1; b >>= 1;\n    }\n    return f(l,r);\n  }\n};\n\nint main(){\n  int n, q;\n  cin >> n >> q;\n  auto f = [](ll a, ll b){return a+b;};\n  auto g = [](ll a, ll b, int l){return b == INF ? a : b*l;};\n  auto h = [](ll a, ll b) {return b;};\n  LazySegmentTree<ll,ll,decltype(f),decltype(g),decltype(h)> lst(n,f,g,h,0,INF);\n  rep(i,n) lst.set(i,0);\n  lst.build();\n  vector<ll> ans;\n  rep(i,q) {\n    int t;\n    cin >> t;\n    if(t == 0) {\n      int l, r; ll x;\n      cin >> l >> r >> x;\n      lst.update(l,r+1,x);\n    } else {\n      int l, r;\n      cin >> l >> r;\n      ans.push_back(lst.query(l,r+1));\n    }\n  }\n  for(auto x : ans) cout << x << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a) {\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n    out<<'[';\n    for(const T &i: a) out<<i<<',';\n    out<<']';\n    return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out, const set<T>& a) {\n    out<<'{';\n    for(const T &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\ntemplate<class T, class S>\nostream &operator <<(ostream& out, const map<T,S>& a) {\n    out<<'{';\n    for(auto &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\ntemplate <typename Monoid>\nstruct lazysegtree {\n    using T = typename Monoid::T;\n    using E = typename Monoid::E;\n    int n, height;\n    vector<T> dat;\n    vector<E> lazy;\n\n    lazysegtree() {}\n    lazysegtree(int n_) {\n        n = 1, height = 0;\n        while(n < n_) { n *= 2; height++; }\n        dat.assign(n*2, Monoid::dt());\n        lazy.assign(n*2, Monoid::de());\n    }\n    void build(vector<T> v) {\n        REP(i, v.size()) dat[i+n] = v[i];\n        for(int i=n-1; i>0; --i) dat[i] = Monoid::f(dat[i*2], dat[i*2+1]);\n    }\n\n    inline T reflect(int k) { return lazy[k]==Monoid::de()?dat[k]:Monoid::g(dat[k], lazy[k]); }\n    inline void eval(int k) {\n        if(lazy[k] == Monoid::de()) return;\n        lazy[2*k]   = Monoid::h(lazy[k*2],   lazy[k]);\n        lazy[2*k+1] = Monoid::h(lazy[k*2+1], lazy[k]);\n        dat[k] = reflect(k);\n        lazy[k] = Monoid::de();\n    }\n    inline void thrust(int k) { for(int i=height;i;--i) eval(k>>i); }\n    inline void recalc(int k) { while(k>>=1) dat[k] = Monoid::f(reflect(k*2), reflect(k*2+1)); }\n\n    void update(int a, int b, E x) {\n        thrust(a+=n);\n        thrust(b+=n-1);\n        for(int l=a, r=b+1; l<r; l>>=1,r>>=1) {\n            if(l&1) lazy[l] = Monoid::h(lazy[l], x), ++l;\n            if(r&1) --r, lazy[r] = Monoid::h(lazy[r], x);\n        }\n        recalc(a);\n        recalc(b);\n    }\n    T query(int a, int b) {\n        thrust(a+=n);\n        thrust(b+=n-1);\n        T vl=Monoid::dt(), vr=Monoid::dt();\n        for(int l=a, r=b+1; l<r; l>>=1,r>>=1) {\n            if(l&1) vl=Monoid::f(vl, reflect(l++));\n            if(r&1) vr=Monoid::f(reflect(--r), vr);\n        }\n        return Monoid::f(vl, vr);\n    }\n\n    friend ostream &operator <<(ostream& out,const lazysegtree<Monoid>& seg) {\n        out << \"---------------------\" << endl;\n        int cnt = 1;\n        for(int i=1; i<=seg.n; i*=2) {\n            REP(j, i) {\n                out << \"(\" << seg.dat[cnt] << \",\" << seg.lazy[cnt] << \") \";\n                cnt++;\n            }\n            out << endl;\n        }\n        out << \"---------------------\" << endl;\n        return out;\n    }\n};\n\nstruct update_min {\n    using T = ll;\n    using E = ll;\n    static constexpr T dt() { return INT_MAX; }\n    static constexpr E de() { return INT_MAX; }\n    static T f(const T &a, const T &b) { return min(a, b); }\n    static T g(const T &a, const E &b) { return b; }\n    static E h(const E &a, const E &b) { return b; }\n};\nstruct add_sum {\n    using T = PII;  // (頂点の値, 頂点の区間長)\n    using E = ll;\n    static constexpr T dt() { return PII(0,0); }\n    static constexpr E de() { return 0; }\n    static T f(const T &a, const T &b) { return PII(a.first+b.first, a.second+b.second); }\n    static T g(const T &a, const E &b) { return PII(a.first+b*a.second, a.second); }\n    static E h(const E &a, const E &b) { return a+b; }\n};\nstruct update_sum {\n    using T = PII;\n    using E = ll;\n    static constexpr T dt() { return PII(0, 0); }\n    static constexpr E de() { return LLINF; }\n    static T f(const T &a, const T &b) { return PII(a.first+b.first,a.second+b.second); }\n    static T g(const T &a, const E &b) { return PII(b*a.second, a.second); }\n    static E h(const E &a, const E &b) { return b; }\n};\nstruct add_min {\n    using T = PII;  // (頂点の値, 頂点の区間長)\n    using E = ll;\n    static constexpr T dt() { return PII(LLINF,0); }\n    static constexpr E de() { return 0; }\n    static T f(const T &a, const T &b) { return min(a, b); }\n    static T g(const T &a, const E &b) { return PII(a.first+(b==LLINF?0:b)*a.second, a.second); }\n    static E h(const E &a, const E &b) { return a+b; }\n};\nstruct xor_sum {\n    using T = PII;  // (頂点の値, 頂点の区間長)\n    using E = ll;\n    static constexpr T dt() { return PII(0,0); }\n    static constexpr E de() { return 0; }\n    static T f(const T &a, const T &b) { return PII(a.first+b.first, a.second+b.second); }\n    static T g(const T &a, const E &b) { return PII((b>=1?b-a.first:a.first)*a.second, a.second); }\n    static E h(const E &a, const E &b) { return a^b; }\n};\n\n// 点更新区間最小\nnamespace DSL2A {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        lazysegtree<update_min> seg(n);\n        while(q--) {\n            int c, x, y;\n            cin >> c >> x >> y;\n            if(c == 0) {\n                seg.update(x, x+1, y);\n            } else {\n                cout << seg.query(x, y+1) << endl;\n            }\n        }\n    }\n}\n\n// 点加算区間和\nnamespace DSL2B {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        lazysegtree<add_sum> seg(n);\n        seg.build(vector<PII>(n, PII(0,1)));\n        while(q--) {\n            int c, x, y;\n            cin >> c >> x >> y;\n            if(c == 0) {\n                x--;\n                seg.update(x, x+1, y);\n            } else {\n                x--, y--;\n                cout << seg.query(x, y+1).first << endl;\n            }\n        }\n    }\n}\n\n// 区間更新区間最小\nnamespace DSL2F {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        lazysegtree<update_min> seg(n);\n        while(q--) {\n            int c, s, t;\n            cin >> c >> s >> t;\n            if(c == 0) {\n                int x;\n                cin >> x;\n                seg.update(s, t + 1, x);\n            } else {\n                cout << seg.query(s, t + 1) << endl;\n            }\n        }\n    }\n}\n\n// 区間加算区間和\nnamespace DSL2G {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        lazysegtree<add_sum> seg(n);\n        seg.build(vector<PII>(n, PII(0,1)));\n        while(q--) {\n            int c, s, t;\n            cin >> c >> s >> t;\n            s--, t--;\n            if(c == 0) {\n                int x;\n                cin >> x;\n                seg.update(s, t + 1, x);\n            } else {\n                cout << seg.query(s, t + 1).first << endl;\n            }\n        }\n    }\n}\n\n// 区間加算区間最小\nnamespace DSL2H {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        lazysegtree<add_min> seg(n);\n        seg.build(vector<PII>(n, PII(0,1)));\n        while(q--) {\n            int c, s, t;\n            cin >> c >> s >> t;\n            if(c == 0) {\n                int x;\n                cin >> x;\n                seg.update(s, t+1, x);\n            } else {\n                cout << seg.query(s, t+1).first << endl;\n            }\n            REP(i, n) seg.query(i, i+1);\n            cout << seg << endl;\n        }\n    }\n}\n\n// 区間更新区間和\nnamespace DSL2I {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        lazysegtree<update_sum> seg(n);\n        seg.build(vector<PII>(n, PII(0, 1)));\n        while(q--) {\n            int c, s, t;\n            cin >> c >> s >> t;\n            if(c == 0) {\n                int x;\n                cin >> x;\n                seg.update(s, t+1, x);\n            } else {\n                cout << seg.query(s, t+1).first << endl;\n            }\n\n            // REP(i, n) seg.query(i, i+1);\n            // cout << seg << endl;\n        }\n    }\n}\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    // DSL2A::solve();\n    // DSL2B::solve();\n    // DSL2F::solve();\n    // DSL2G::solve();\n    // DSL2H::solve();\n    DSL2I::solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) a.begin(),a.end()\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-(x)))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 1e9 + 7;\nconst ll inf = 1e9 + 7;\nconst ld eps = 1e-9;\nconst db PI = atan(1) * 4;\n\ntemplate<typename T, typename S>inline bool upmin(T&a, const S&b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T, typename S>inline bool upmax(T&a, const S&b) { return a < b ? a = b, 1 : 0; }\n\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a%b); }\nll pow(ll a, ll b) {\n\tif (b == 0) {\n\t\treturn 1;\n\t}\n\tif (b == 1) {\n\t\treturn a;\n\t}\n\tll ans = pow(a, b / 2);\n\tans *= ans;\n\tans *= b % 2 == 1 ? a : 1;\n\treturn ans;\n}\n\nnamespace SOLVE {\n\tVI A;\n\n\tstruct SegTree {\n\t\tstatic const int maxn = 100000;\n\n\t\tstruct node {\n\t\t\tll l, r, value, lazy;\n\t\t};\n\n\t\tll amount(node n) {\n\t\t\treturn n.r - n.l + 1;\n\t\t}\n\n\t\tnode no[maxn * 4];\n\t\tvoid push_up(int ind) {\n\t\t\tno[ind].value = (no[lson].value + no[rson].value);\n\t\t}\n\t\tvoid push_down(int ind) {\n\t\t\tif (no[ind].lazy == 1) {\n\t\t\t\tll one = no[ind].value / amount(no[ind]);\n\t\t\t\tno[lson].value = one * amount(no[lson]);\n\t\t\t\tno[rson].value = one * amount(no[rson]);\n\t\t\t\tno[lson].lazy = 1;\n\t\t\t\tno[rson].lazy = 1;\n\t\t\t\tno[ind].lazy = 0;\n\t\t\t}\n\t\t}\n\n\t\tvoid build(int l, int r, int ind) {\n\t\t\tno[ind].l = l;\n\t\t\tno[ind].r = r;\n\t\t\tno[ind].value = 0;\n\t\t\tno[ind].lazy = 0;\n\t\t\tif (l == r) {\n\t\t\t\tno[l].value = 0;\n\t\t\t\tno[l].lazy = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint mid = (l + r) / 2;\n\t\t\t\tbuild(l, mid, lson);\n\t\t\t\tbuild(mid + 1, r, rson);\n\t\t\t\tpush_up(ind);\n\t\t\t}\n\t\t}\n\n\t\tvoid update(int l, int r, int ind, ll val) {\n\t\t\tif (l > no[ind].r || r < no[ind].l)return;\n\t\t\tif (l <= no[ind].l && no[ind].r <= r) {\n\t\t\t\tno[ind].value = val * amount(no[ind]);\n\t\t\t\tno[ind].lazy = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpush_down(ind);\n\t\t\t\tupdate(l, r, lson, val);\n\t\t\t\tupdate(l, r, rson, val);\n\t\t\t\tpush_up(ind);\n\t\t\t}\n\t\t}\n\t\tvoid query(int l, int r, int ind, ll& ans) {\n\t\t\tif (l > no[ind].r || r < no[ind].l) {\n\t\t\t\tans = 0;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (l <= no[ind].l && no[ind].r <= r) {\n\t\t\t\tans = no[ind].value;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tll ans1, ans2;\n\t\t\t\tpush_down(ind);\n\t\t\t\tquery(l, r, lson, ans1);\n\t\t\t\tquery(l, r, rson, ans2);\n\t\t\t\tans = ans1 + ans2;\n\t\t\t\tpush_up(ind);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tvoid show(int x) {\n\t\t\tREP(i, 1, x) {\n\t\t\t\tcout << no[i].value << ' ';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t};\n\n\n\n\n\n\n\tSegTree tree;\n\n\tvoid main() {\n\t\tll n, q, a, b, c, d, ans;\n\t\tcin >> n >> q;\n\n\t\tA.resize(n, pow(2,31)-1);\n\n\t\ttree.build(0, n-1, 1);\n\t\n\t\tREP(i, 0, q) {\n\t\t\tcin >> a;\n\t\t\tif (a == 0) {\n\t\t\t\tcin >> b >> c >> d;\n\t\t\t\ttree.update(b, c, 1, d);\n\t\t\t\t\n\t\t\t}\n\t\t\telse {\n\t\t\t\t\n\t\t\t\tcin >> b >> c;\n\t\t\t\ttree.query(b, c, 1, ans);\n\t\t\t\tcout << ans << endl;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nsigned main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tint t;\n\t//    in(t);\n\tt = 1;\n\twhile (t--) {\n\t\tSOLVE::main();\n\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long int\n#define MOD(x) ((x % MOD_N) + MOD_N) % MOD_N\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define RFORE(i,a,b) for(int i=(b);i>=(a);--i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define RALL(c) (c).rbegin(),(c).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(c) (int)((c).size())\n#define EACH(i,v) for(auto i=v.begin();i!=v.end();++i)\n#define REACH(i,v) for(auto i=v.rbegin();i!=v.rend();++i)\n#define LB(c,x) distance((c).begin(),lower_bound(ALL(c),x))\n#define UB(c,x) distance((c).begin(),upper_bound(ALL(c),x))\n#define COUNT(c,x) (lower_bound(ALL(c),x)-upper_bound(ALL(c),x))\n#define UNIQUE(c) SORT(c); (c).erase(unique(ALL(c)),(c).end());\n#define COPY(c1,c2) copy(ALL(c1),(c2).begin())\n#define EXIST(s,e) (bool)((s).find(e)!=(s).end())\n#define PB push_back\n#define MP make_pair\n#define DUMP(x)  cerr<<#x<<\" = \"<<(x)<<endl;\n#define NL cerr<<endl;\nusing namespace std;\ntemplate<typename T,typename U> using P=pair<T,U>;\ntemplate<typename T> using V=vector<T>;\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T sum(vector<T>&v){return accumulate(ALL(v),T());}\ntemplate<typename T>T sum(vector<T>&v,int a,int b){return accumulate(v.begin()+a,v.begin()+b,T());}\ntemplate<typename T>T max(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T min(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T max_index(vector<T>&v){return distance((v).begin(),max_element(ALL(v)));}\ntemplate<typename T>T min_index(vector<T>&v){return distance((v).begin(),min_element(ALL(v)));}\n\nstruct edge { int to, cost; };\n\ntemplate<typename T>auto&operator<<(ostream&s,const vector<T>&v){s<<\"[\";bool a=1;for(auto e:v){s<<(a?\"\":\" \")<<e;a=0;}s<<\"]\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const pair<T,U>&p){s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return s;}\ntemplate<typename T>auto&operator<<(ostream&s,const set<T>&st){s<<\"{\";bool a=1;for(auto e:st){s<<(a?\"\":\" \")<<e;a=0;}s<<\"}\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const map<T,U>&m){s<<\"{\";bool a=1;for(auto e:m){s<<(a?\"\":\" \")<<e.first<<\":\"<<e.second;a=0;}s<<\"}\";return s;}\n\nconst int INF = 1e18;\nconst int MOD_N = 1e9+7;\n\ntemplate< typename Monoid, typename OperatorMonoid = Monoid >\nstruct LazySegmentTree {\n   using F = function< Monoid(Monoid, Monoid) >;\n   using G = function< Monoid(Monoid, OperatorMonoid, int) >;\n   using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n   int sz;\n   vector< Monoid > data;\n   vector< OperatorMonoid > lazy;\n   const F f;\n   const G g;\n   const H h;\n   const Monoid M1;\n   const OperatorMonoid OM0;\n   LazySegmentTree(int n, const F f, const G g, const H h,\n                   const Monoid &M1, const OperatorMonoid OM0)\n         : f(f), g(g), h(h), M1(M1), OM0(OM0) {\n      sz = 1;\n      while(sz < n) sz <<= 1;\n      data.assign(2 * sz, M1);\n      lazy.assign(2 * sz, OM0);\n   }\n\n   void set(int k, const Monoid &x) {\n      data[k + sz] = x;\n   }\n   void build() {\n      for(int k = sz - 1; k > 0; k--) {\n         data[k] = f(data[2 * k + 0], data[2 * k + 1]);\n      }\n   }\n   void propagate(int k, int len) {\n      if(lazy[k] != OM0) {\n         if(k < sz) {\n            lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n            lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n         }\n         data[k] = g(data[k], lazy[k], len);\n         lazy[k] = OM0;\n      }\n   }\n   Monoid update(int a, int b, const OperatorMonoid &x, int k, int l, int r) {\n      propagate(k, r - l);\n      if(r <= a || b <= l) {\n         return data[k];\n      } else if(a <= l && r <= b) {\n         lazy[k] = h(lazy[k], x);\n         propagate(k, r - l);\n         return data[k];\n      } else {\n         return data[k] = f(update(a, b, x, 2 * k + 0, l, (l + r) >> 1),\n                            update(a, b, x, 2 * k + 1, (l + r) >> 1, r));\n      }\n   }\n   Monoid update(int a, int b, const OperatorMonoid &x) {\n      return update(a, b, x, 1, 0, sz);\n   }\n   Monoid query(int a, int b, int k, int l, int r) {\n      propagate(k, r - l);\n      if(r <= a || b <= l) {\n         return M1;\n      } else if(a <= l && r <= b) {\n         return data[k];\n      } else {\n         return f(query(a, b, 2 * k + 0, l, (l + r) >> 1),\n                  query(a, b, 2 * k + 1, (l + r) >> 1, r));\n      }\n   }\n   Monoid query(int a, int b) {\n      return query(a, b, 1, 0, sz);\n   }\n   Monoid operator[](const int &k) {\n      return query(k, k + 1);\n   }\n};\ntemplate<typename T> struct RSQ_RUQ {\n   LazySegmentTree<T> lsegt;\n   RSQ_RUQ(int n) : lsegt(n,\n      [](T a,T b){ return a + b; },\n      [](T a,T b,T c){ return b * c; },\n      [](T a,T b){ return b; }, 0, INF){}\n   void update(int a, int b, T x) { lsegt.update(a, b, x); }\n   T query(int a, int b) { return lsegt.query(a, b); }\n};\n\nsigned main()\n{\n   int n, q; cin >> n >> q;\n   V<int> c(q), s(q), t(q), x(q);\n   REP(i, q) {\n      cin >> c[i];\n      if (c[i] == 0) {\n         cin >> s[i] >> t[i] >> x[i];\n      } else {\n         cin >> s[i] >> t[i];\n      }\n   }\n   RSQ_RUQ<int> rsqruq(n);\n   REP(i, q) {\n      if (c[i] == 0) {\n         rsqruq.update(s[i], t[i]+1, x[i]);\n      } else {\n         cout << rsqruq.query(s[i], t[i]+1) << endl;\n      }\n   }\n\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,s,e) for(int i=(s); i<(e);i++)\n#define rep(i,n) REP(i,0,n)\n#define rep1(i,n) REP(i,1,n)\n#define repe(i,n) for(auto &&i:n)\n#define all(v) (v).begin(),(v).end()\n#define decimal fixed<<setprecision(20)\n#define fastcin() cin.tie(0);ios::sync_with_stdio(false)\nusing namespace std;\nusing LL = long long;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst int INF = 1e9;\nconst LL LLINF = 1e16;\n\n/*\n!) 0-indexed 遅延伝搬セグメント木\n!) [a, b)に対する演算\n!) M0, L0, merge, updateNode, propagateを書く\n*/\ntemplate <typename Monoid>\nstruct LazySegtree {\n    int n;\n    vector<Monoid> dat, lazy;\n    // データと遅延配列の初期化値 queryに合わせて選択する\n    Monoid M0 = 0, L0 = LLINF;\n\n\n    LazySegtree(int sz, Monoid dat_init){\n        n = 1;\n        while (n < sz) n *= 2;\n        dat.assign(2*n-1, dat_init);\n        lazy.assign(2*n-1, L0);\n    }\n\n    Monoid merge(Monoid a, Monoid b){ return a + b; }\n    void updateNode(int k, Monoid x){ lazy[k] = x; }\n    void propagate(int k, int l, int r){ dat[k] = lazy[k]*(r-l); }\n\n    void eval(int k, int l, int r) {\n        if(lazy[k] == L0) return;\n        propagate(k, l, r);\n        if(r-l > 1) {\n            updateNode(2*k+1, lazy[k]);\n            updateNode(2*k+2, lazy[k]);\n        }\n        lazy[k] = L0;\n    }\n\n    void update(int a, int b, Monoid x, int k, int l, int r) {\n        eval(k, l, r);\n        if (r <= a || b <= l) return;\n        if (a <= l && r <= b) {\n            updateNode(k, x);\n            eval(k, l, r);\n        }else{\n            update(a, b, x, k*2+1, l, (l+r)/2);\n            update(a, b, x, k*2+2, (l+r)/2, r);\n            dat[k] = merge(dat[2*k+1], dat[2*k+2]);\n        }\n    }\n\n    void update(int a, int b, Monoid x) {\n        update(a, b, x, 0, 0, n);\n    }\n\n    Monoid query(int a, int b, int k, int l, int r) {\n        eval(k, l, r);\n        if (r <= a || b <= l) return M0;\n        if (a <= l && r <= b) return dat[k];\n        Monoid L = query(a, b, k*2+1, l, (l+r)/2);\n        Monoid R = query(a, b, k*2+2, (l+r)/2, r);\n        return merge(L, R);\n    }\n\n    Monoid query(int a, int b){\n        return query(a, b, 0, 0, n);\n    }\n};\n\n//########## 例 ##########\n// Range update - min (AOJ DSL_2_F)\n// Monoid M0 = LLINF, L0 = LLINF;\n// Monoid merge(Monoid a, Monoid b){ return min(a, b); }\n// void updateNode(int k, Monoid x){ lazy[k] = x; }\n// void propagate(int k, int l, int r){ dat[k] = lazy[k]; }\n// LazySegtree<LL> seg(n+1, (1LL<<31)-1);\n\n// // Range update - sum (AOJ DSL_2_I)\n// Monoid M0 = 0, L0 = LLINF;\n// Monoid merge(Monoid a, Monoid b){ return a + b; }\n// void updateNode(int k, Monoid x){ lazy[k] = x; }\n// void propagate(int k, int l, int r){ dat[k] = lazy[k]*(r-l); }\n// LazySegtree<LL> seg(n+1, 0);\n\n// // Range add - min (AOJ DSL_2_H)\n// Monoid M0 = LLINF, L0 = 0;\n// Monoid merge(Monoid a, Monoid b){ return min(a, b); }\n// void updateNode(int k, Monoid x){ lazy[k] += x; }\n// void propagate(int k, int l, int r){ dat[k] += lazy[k]; }\n// LazySegtree<LL> seg(n+1, 0);\n\n// // Range add - sum (AOJ DSL_2_G)\n// Monoid M0 = 0, L0 = 0;\n// Monoid merge(Monoid a, Monoid b){ return a + b; }\n// void updateNode(int k, Monoid x){ lazy[k] += x; }\n// void propagate(int k, int l, int r){ dat[k] += lazy[k]*(r-l); }\n// LazySegtree<LL> seg(n+1, 0);\n\n\n\nint main(){\n    int n, q;\n    cin >> n >> q;\n    LazySegtree<LL> seg(n+1, 0);\n\n    rep(i, q){\n        int p;\n        cin >> p;\n        if(p == 0){\n            LL s, t, x;\n            cin >> s >> t >> x;\n            seg.update(s, t+1, x);\n        }else{\n            LL s, t;\n            cin >> s >> t;\n            cout << seg.query(s, t+1) << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n   \nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n   \nconst int MAX_N=1<<17;\nconst ll INF=1e9;\n    \nll sum[2*MAX_N-1], part[2*MAX_N-1];\nint m;\n   \nvoid init(int n){\n    m=1;\n    while(m<n) m*=2;\n}\n  \nvoid eval(int k, int l, int r){\n    if(part[k]<INF){\n        sum[k]=part[k]*((ll)(r-l));\n        if(k<m-1){\n            part[2*k+1]=part[k];\n            part[2*k+2]=part[k];\n        }\n        part[k]=INF;\n    }\n}\n    \nvoid update(int a, int b, ll x, int k, int l, int r){\n\teval(k, l, r);\n\tif(r<=a || b<=l) return;\n    if(a<=l && r<=b){\n        part[k]=x;\n        eval(k, l, r);\n    }else{\n        update(a, b, x, k*2+1, l, (l+r)/2);\n        update(a, b, x, k*2+2, (l+r)/2, r);\n        sum[k]=sum[2*k+1]+sum[2*k+2];\n    }\n}\n    \nll getsum(int a, int b, int k, int l, int r){\n\teval(k, l, r);\n    if(b<=l || r<=a){\n        return 0;\n    }\n    if(a<=l && r<=b){\n        return sum[k];\n    }else{\n        return getsum(a, b, 2*k+1, l, (l+r)/2)+getsum(a, b, 2*k+2, (l+r)/2, r);\n    }\n}\n   \nint main()\n{\n    int n, q;\n    cin>>n>>q;\n    init(n);\n    for(int i=0; i<q; i++){\n        int tp;\n        cin>>tp;\n        if(tp==0){\n            int s, t; ll x;\n            cin>>s>>t>>x;\n            update(s, t+1, x, 0, 0, m);\n        }else{\n            int s, t;\n            cin>>s>>t;\n            cout<<getsum(s, t+1, 0, 0, m)<<endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\nusing namespace std;\n#define f(i,n) for(int i=0;i<int(n);i++)\n#define N (1<<18)\n#define INIT 9223372036854775807\n#define INIT2 0\n#define INIT3 0\nlong long a[(2 * N)];\nlong long laz[(2 * N)];\nint l[(2 * N)];\nint r[(2 * N)];\n\nlong long f1(long long x, long long y) {\n\tif (x != INIT)return x;\n\treturn y;\n}\nlong long f2(long long k, long long x, long long y) {\n\tif (x != INIT)return x*(r[k]-l[k]);\n\treturn y;\n}\nlong long f3(long long x, long long y) {\n\treturn (x + y);\n}\n\n\nvoid init(void) {\n\tf(i, (2 * N)) {\n\t\ta[i] = INIT2;\n\t\tlaz[i] = INIT;\n\t}\n\tl[1] = 0;\n\tr[1] = N;\n\tfor (int i = 1; i < N; i++) {\n\t\tl[(2 * i)] = l[i];\n\t\tr[(2 * i)] = (l[i] + r[i]) / 2;\n\t\tl[(2 * i) + 1] = (l[i] + r[i]) / 2;\n\t\tr[(2 * i) + 1] = r[i];\n\t}\n\treturn;\n}\n\n\n\nlong long change(int ll, int rr, int k, long long x) {\n\tlong long vl, vr;\n\tif ((rr <= l[k]) || (r[k] <= ll))return f2(k, laz[k], a[k]);\n\tif (laz[k] != INIT) {\n\t\ta[k] = f2(k, laz[k], a[k]);\n\t\tif (k < N) {\n\t\t\tlaz[(2 * k)] = f1(laz[k], laz[(2 * k)]);\n\t\t\tlaz[(2 * k) + 1] = f1(laz[k], laz[(2 * k) + 1]);\n\t\t}\n\t\tlaz[k] = INIT;\n\t}\n\tif ((ll <= l[k]) && (r[k] <= rr)) {\n\t\tlaz[k] = f1(x, laz[k]);\n\t\treturn f2(k, laz[k], a[k]);\n\t}\n\telse {\n\t\tint mm = (l[k] + r[k]) / 2;\n\t\tif ((l[k] < rr) && (ll < mm)) {\n\t\t\tvl = change(ll, rr, 2 * k, x);\n\t\t}\n\t\telse vl = f2((2 * k), laz[(2 * k)], a[(2 * k)]);\n\n\t\tif ((mm < rr) && (ll < r[k])) {\n\t\t\tvr = change(ll, rr, (2 * k) + 1, x);\n\t\t}\n\t\telse vr = f2((2 * k) + 1, laz[(2 * k) + 1], a[(2 * k + 1)]);\n\n\t\ta[k] = f3(vl, vr);\n\t\treturn f2(k, laz[k], a[k]);\n\t}\n}\n\n\nlong long search(int ll, int rr, int k) {\n\tif (laz[k] != INIT) {\n\t\ta[k] = f2(k, laz[k], a[k]);\n\t\tif (k < N) {\n\t\t\tlaz[(2 * k)] = f1(laz[k], laz[(2 * k)]);\n\t\t\tlaz[(2 * k) + 1] = f1(laz[k], laz[(2 * k) + 1]);\n\t\t}\n\t\tlaz[k] = INIT;\n\t}\n\tlong long vl, vr;\n\tif (rr <= l[k] || r[k] <= ll)return INIT3;\n\telse if (ll <= l[k] && r[k] <= rr) return f2(k, laz[k], a[k]);\n\telse {\n\t\tvl = search(ll, rr, 2 * k);\n\t\tvr = search(ll, rr, (2 * k) + 1);\n\t\ta[k] = f3(f2((2 * k), laz[(2 * k)], a[(2 * k)]), f2((2 * k) + 1, laz[(2 * k) + 1], a[(2 * k) + 1]));\n\t\treturn f3(vl, vr);\n\t}\n}\n\n\nint main(void) {\n\tint q;\n\tint c, x, y;\n\tlong long k;\n\tinit();\n\tscanf(\"%d %d\", &c, &q);\n\tf(qq, q) {\n\t\tscanf(\"%d\", &c);\n\t\tif (c == 0) {\n\t\t\tscanf(\"%d %d %lld\", &x, &y, &k);\n\t\t\tchange(x, y + 1, 1, k);\n\t\t}\n\t\telse if (c == 1) {\n\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\tk = search(x, y + 1, 1);\n\t\t\tprintf(\"%lld\\n\", k);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <cassert>\n#include <stdexcept>\n#include <utility>\n\ntemplate <class ValueMonoid, class OperatorMonoid, class Modifier,\n\ttemplate <class> class Container>\nclass lazy_segment_tree {\npublic:\n\tusing value_structure = ValueMonoid;\n\tusing value_type = typename value_structure::value_type;\n\tusing const_reference = const value_type &;\n\tusing operator_structure = OperatorMonoid;\n\tusing operator_type = typename operator_structure::value_type;\n\tusing modifier_type = Modifier;\n\tusing container_type = Container<::std::pair<value_type, operator_type>>;\n\tusing size_type = typename container_type::size_type;\n\nprivate:\n\tsize_type size_, height;\n\tcontainer_type c;\n\tstatic size_type getheight(const size_type size) noexcept {\n\t\tsize_type ret = 0;\n\t\twhile (static_cast<size_type>(1) << ret < size)\n\t\t\t++ret;\n\t\treturn ret;\n\t}\n\tstatic value_type reflect(typename container_type::const_reference element) {\n\t\treturn modifier_type::operation(element.first, element.second);\n\t}\n\tvoid recalc(const size_type index) {\n\t\tc[index].first = value_structure::operation(reflect(c[index << 1]),\n\t\t\treflect(c[index << 1 | 1]));\n\t}\n\tstatic void assign(operator_type &element, const operator_type &data) {\n\t\telement = operator_structure::operation(element, data);\n\t}\n\tvoid push(const size_type index) {\n\t\tassign(c[index << 1].second, c[index].second);\n\t\tassign(c[index << 1 | 1].second, c[index].second);\n\t\tc[index].second = operator_structure::identity();\n\t}\n\tvoid propagate(const size_type index) {\n\t\tfor (size_type i = height; i; --i)\n\t\t\tpush(index >> i);\n\t}\n\tvoid thrust(const size_type index) {\n\t\tc[index].first = reflect(c[index]);\n\t\tpush(index);\n\t}\n\tvoid evaluate(const size_type index) {\n\t\tfor (size_type i = height; i; --i)\n\t\t\tthrust(index >> i);\n\t}\n\tvoid build(size_type index) {\n\t\twhile (index >>= 1)\n\t\t\trecalc(index);\n\t}\n\tsize_type base_size() const { return static_cast<size_type>(1) << height; }\n\npublic:\n\tlazy_segment_tree() : size_(0), height(0), c() {}\n\texplicit lazy_segment_tree(const size_type size)\n\t\t: size_(size), height(getheight(size_)),\n\t\tc(static_cast<size_type>(1) << (height + 1),\n\t\t{ value_structure::identity(), operator_structure::identity() }) {}\n\n\tbool empty() const { return !size_; }\n\tsize_type size() const { return size_; }\n\n\tconst_reference operator[](size_type index) {\n\t\tassert(index < size());\n\t\tindex += base_size();\n\t\tevaluate(index);\n\t\tc[index].first = reflect(c[index]);\n\t\tc[index].second = operator_structure::identity();\n\t\treturn c[index].first;\n\t}\n\tconst_reference at(size_type index) {\n\t\tif (index < size()) {\n\t\t\tthrow ::std::out_of_range(\"index out of range\");\n\t\t}\n\t\telse {\n\t\t\tindex += base_size();\n\t\t\tevaluate(index);\n\t\t\tc[index].first = reflect(c[index]);\n\t\t\tc[index].second = operator_structure::identity();\n\t\t\treturn c[index].first;\n\t\t}\n\t}\n\tvalue_type fold(size_type first, size_type last) {\n\t\tassert(first <= last);\n\t\tassert(first <= size());\n\t\tassert(last <= size());\n\t\tfirst += base_size();\n\t\tlast += base_size();\n\t\tevaluate(first);\n\t\tevaluate(last - 1);\n\t\tvalue_type retL = value_structure::identity(),\n\t\t\tretR = value_structure::identity();\n\t\tfor (; first < last; first >>= 1, last >>= 1) {\n\t\t\tif (first & 1)\n\t\t\t\tretL = value_structure::operation(retL, reflect(c[first++]));\n\t\t\tif (last & 1)\n\t\t\t\tretR = value_structure::operation(reflect(c[last - 1]), retR);\n\t\t}\n\t\treturn value_structure::operation(retL, retR);\n\t}\n\ttemplate <class F> size_type search(const F &f) {\n\t\tif (f(value_structure::identity()))\n\t\t\treturn static_cast<size_type>(0);\n\t\tif (!f(reflect(c[1])))\n\t\t\treturn size() + 1;\n\t\tvalue_type acc = value_structure::identity();\n\t\tsize_type i = 1;\n\t\twhile (i < base_size()) {\n\t\t\tthrust(i);\n\t\t\tif (!f(value_structure::operation(acc, reflect(c[i <<= 1]))))\n\t\t\t\tacc = value_structure::operation(acc, reflect(c[i++]));\n\t\t}\n\t\treturn i - base_size() + 1;\n\t}\n\n\tvoid update(const size_type index, const value_type &data) {\n\t\tassert(index < size());\n\t\tindex += base_size();\n\t\tpropagate(index);\n\t\tc[index].first = data;\n\t\tc[index].second = operator_structure::identity();\n\t\tbuild(index);\n\t}\n\tvoid update(size_type first, size_type last, const operator_type &data) {\n\t\tassert(first <= last);\n\t\tassert(first <= size());\n\t\tassert(last <= size());\n\t\tfirst += base_size();\n\t\tlast += base_size();\n\t\tpropagate(first);\n\t\tpropagate(last - 1);\n\t\tfor (size_type left = first, right = last; left < right;\n\t\t\tleft >>= 1, right >>= 1) {\n\t\t\tif (left & 1)\n\t\t\t\tassign(c[left++].second, data);\n\t\t\tif (right & 1)\n\t\t\t\tassign(c[right - 1].second, data);\n\t\t}\n\t\tbuild(first);\n\t\tbuild(last - 1);\n\t}\n};\n\n#include <cstddef>\n#include <utility>\ntemplate <class T, class Size = ::std::size_t> class sum_monoid {\npublic:\n\tusing size_type = Size;\n\tusing value_type = ::std::pair<T, size_type>;\n\tstatic T get(const value_type &x) { return x.first; }\n\tstatic value_type operation(const value_type &x, const value_type &y) {\n\t\treturn value_type(x.first + y.first, x.second + y.second);\n\t}\n\tstatic value_type identity() { return value_type(T(0), size_type(0)); }\n\tstatic value_type reverse(const value_type &x) { return x; }\n};\n\n#include <type_traits>\n#include <utility>\ntemplate <class T> class optional {\npublic:\n\tusing value_type = T;\n\nprivate:\n\ttypename ::std::aligned_storage<sizeof(value_type), alignof(value_type)>::type\n\t\tstorage;\n\tbool hasv;\n\tvalue_type *data() {\n\t\treturn static_cast<value_type *>(static_cast<void *>(&storage));\n\t}\n\tconst value_type *data() const {\n\t\treturn static_cast<const value_type *>(static_cast<const void *>(&storage));\n\t}\n\npublic:\n\toptional() : hasv(0) {}\n\ttemplate <class... Args> explicit optional(Args &&... args) : hasv(1) {\n\t\t::new (data()) value_type(::std::forward<Args>(args)...);\n\t}\n\tvoid reset() {\n\t\thasv = 0;\n\t\tdata()->~value_type();\n\t}\n\tvalue_type &operator*() & { return *data(); }\n\tconst value_type &operator*() const & { return *data(); }\n\tvalue_type &&operator*() && { return *data(); }\n\tconst value_type &&operator*() const && { return *data(); }\n\tvalue_type *operator->() { return data(); }\n\tconst value_type *operator->() const { return data(); }\n\texplicit operator bool() const { return hasv; }\n\tbool has_value() const { return hasv; }\n\tvalue_type &value() & { return *data(); }\n\tconst value_type &value() const & { return *data(); }\n\tvalue_type &&value() && { return *data(); }\n\tconst value_type &&value() const && { return *data(); }\n\ttemplate <class U> value_type value_or(U &&v) const & {\n\t\treturn has_value() ? value() : static_cast<T>(::std::forward<U>(v));\n\t}\n\ttemplate <class U> value_type value_or(U &&v) && {\n\t\treturn has_value() ? value() : static_cast<T>(::std::forward<U>(v));\n\t}\n};\ntemplate <class T> class assign_monoid {\npublic:\n\tusing value_type = optional<T>;\n\tstatic value_type operation(const value_type &x, const value_type &y) {\n\t\treturn y ? y : x;\n\t}\n\tstatic value_type identity() { return value_type(); }\n};\n\n#include <utility>\ntemplate <class T, class S> class sum_assignment {\npublic:\n\tstatic ::std::pair<T, S> operation(const ::std::pair<T, S> &x, const optional<T> &y) {\n\t\treturn y ? ::std::pair<T, S>(y.value() * x.second, x.second) : x;\n\t}\n};\n\n\n#include <cstdio>\n#include <vector>\n\ntemplate<class T> using vec_alias = ::std::vector<T>;\n\nint main() {\n\tusing uint = unsigned int;\n\tusing sum = sum_monoid<int>;\n\n\tuint n, q;\n\tscanf(\"%u%u\", &n, &q);\n\n\tlazy_segment_tree<\n\t\tsum,\n\t\tassign_monoid<int>,\n\t\tsum_assignment<int,sum::size_type>,\n\t\tvec_alias> seg(n);\n\n\tuint c, s, t;\n\tint x;\n\twhile (q--) {\n\t\tscanf(\"%u%u%u\", &c, &s, &t);\n\n\t\tif (c) {\n\t\t\tprintf(\"%d\\n\", seg.fold(s, t + 1).first);\n\t\t}\n\t\telse {\n\t\t\tscanf(\"%d\", &x);\n\t\t\tseg.update(s, t + 1, optional<int>(x));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct RSQ {\n\tusing type = int;\n\tstatic type id() { return 0; }\n\tstatic type op(const type& l, const type & r) { return l + r; }\n};\n\nstruct seg_node {\n\tusing M = RSQ;\n\tusing T = typename M::type;\n\tusing U = int;\n\n\tT val;\n\nprivate:\n\tint size;\n\tbool flag;\n\tU lazy;\n\npublic:\n\tseg_node() : val(), size(0), flag(false) {}\n\tvoid init_leaf(const T& v) {\n\t\tval = v;\n\t\tsize = 1;\n\t}\n\tvoid init_non_leaf(const seg_node& l, const seg_node& r) {\n\t\tval = M::op(l.val, r.val);\n\t\tsize = l.size + r.size;\n\t}\n\tvoid update(U v) {\n\t\tval = v * size;\n\t\tlazy = v;\n\t\tflag = true;\n\t}\n\tvoid push(seg_node& l, seg_node& r) {\n\t\tif (!flag) return;\n\t\tl.update(lazy);\n\t\tr.update(lazy);\n\t\tflag = false;\n\t}\n\tbool is_updated() const {\n\t\treturn flag;\n\t}\n\n};\n\nclass lazy_segment_tree {\n\tusing M = typename seg_node::M;\n\tusing T = typename seg_node::T;\n\tusing U = typename seg_node::U;\n\tconst int h, n;\n\tvector<seg_node> data;\n\tvoid push(int node) {\n\t\tdata[node].push(data[node << 1], data[(node << 1) | 1]);\n\t}\n\tvoid update(int node) {\n\t\tdata[node].val = M::op(data[node << 1].val, data[(node << 1) | 1].val);\n\t}\npublic:\n\tlazy_segment_tree(int n_)\n\t\t: h(ceil(log2(n_))), n(1 << h), data(n * 2) {}\n\tlazy_segment_tree(int n_, T v1)\n\t\t: h(ceil(log2(n_))), n(1 << h), data(n * 2) {\n\t\tfor (int i = 0; i < n_; i++)\n\t\t\tdata[i + n].init_leaf(v1);\n\t\tfor (int i = n - 1; i >= 1; i--)\n\t\t\tdata[i].init_non_leaf(data[i << 1], data[(i << 1) | 1]);\n\t}\n\tlazy_segment_tree(const vector<T>& data_)\n\t\t: h(ceil(log2(data_.size()))), n(1 << h), data(n * 2) {\n\t\tfor (int i = 0; i < (int)data_.size(); i++)\n\t\t\tdata[i + n].init_leaf(data_[i]);\n\t\tfor (int i = n - 1; i >= 1; i--)\n\t\t\tdata[i].init_non_leaf(data[i << 1], data[(i << 1) | 1]);\n\t}\n\tvoid update(int l, int r, U val) {\n\t\tl += n, r += n;\n\t\tfor (int i = h; i > 0; i--) push(l >> i), push(r >> i);\n\t\tint tl = l, tr = r;\n\t\tr++;\n\t\twhile (l < r) {\n\t\t\tif (l & 1) data[l++].update(val);\n\t\t\tif (r & 1) data[--r].update(val);\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t\twhile (tl >>= 1, tr >>= 1, tl) {\n\t\t\tif (!data[tl].is_updated()) update(tl);\n\t\t\tif (!data[tr].is_updated()) update(tr);\n\t\t}\n\t}\n\tT find(int l, int r) {\n\t\tl += n, r += n;\n\t\tfor (int i = h; i > 0; i--) push(l >> i), push(r >> i);\n\t\tr++;\n\t\tT res1 = M::id(), res2 = M::id();\n\t\twhile (l < r) {\n\t\t\tif (l & 1) res1 = M::op(res1, data[l++].val);\n\t\t\tif (r & 1) res2 = M::op(data[--r].val, res2);\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t\treturn M::op(res1, res2);\n\t}\n};\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n, q;\n\tcin >> n >> q;\n\tlazy_segment_tree st(n, 0);\n\twhile (q--) {\n\t\tint com;\n\t\tcin >> com;\n\t\tif (com == 0) {\n\t\t\tint s, t, x;\n\t\t\tcin >> s >> t >> x;\n\t\t\tst.update(s, t, x);\n\t\t}\n\t\telse {\n\t\t\tint s, t;\n\t\t\tcin >> s >> t;\n\t\t\tprintf(\"%d\\n\", st.find(s, t));\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\n#include <type_traits>\n#include <mutex>\n#include <array>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\ntypedef unsigned int uint;\ntypedef long long llong;\ntypedef unsigned long long ullong;\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 28)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\n#define PRED(a,exp) [&](const auto & a) -> bool { return exp; }\n#define COMP(a,b,exp) [&](const auto & a, const auto & b) -> bool { return exp; }\n#define CONV2(a,b,exp) [&](const auto & a, const auto & b) -> auto { return exp; }\n#define CONV3(a,b,c,exp) [&](const auto & a, const auto & b, const auto & c) -> auto { return exp; }\n\ninline int sign_of(double x) { return abs(x) < EPS ? 0 : x > 0 ? 1 : -1; }\ninline bool inRange(int val, int min, int max) { return val >= min && val < max; }\ninline bool inRange(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\ninline bool inRange(int x, int y, int W, int H) { return x >= 0 && x < W && y >= 0 && y < H; } // W,H含まない\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\n\n//// i/o helper ////\n\nnamespace std {\n\ttemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\n\ttemplate <class T1, class T2> inline ostream & operator << (ostream &out, const pair<T1, T2> &p) { out << p.first << \" \" << p.second; return out; }\n}\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; v.reserve(n); REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; v.reserve(n); REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T> struct iter_pair_t { T beg, end; };\ntemplate <class T> iter_pair_t<T> iter_pair(T beg, T end) { return iter_pair_t<T>{beg, end}; }\ntemplate <class T> ostream & operator << (ostream &out, const iter_pair_t<T> &v)\n{\n\tstd::copy(v.beg, v.end, ostream_iterator<typename decltype(v.beg)::reference>(out, \" \"));\n\treturn out;\n}\ntemplate <class T1> ostream & operator << (ostream &out, const vector<T1> &v) { return out << iter_pair(begin(v), end(v)); }\ntemplate <class T1> ostream & operator << (ostream &out, const set<T1> &v) { return out << iter_pair(begin(v), end(v)); }\ntemplate <class T1, class T2> ostream & operator << (ostream &out, const map<T1, T2> &v) { return out << iter_pair(begin(v), end(v)); }\n\nstruct _Reader { istream &cin; template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { ostream &cout; bool f{ false }; template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; (_Reader{cin}), __VA_ARGS__\n#define WRITE(...) (_Writer{cout}), __VA_ARGS__; cout << '\\n'\n#define DEBUG(...) (_Writer{cerr}), __VA_ARGS__; cerr << '\\n'\n\nvoid solve();\nint main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\n\t//auto temp = ctype<char>::classic_table();\n\t//vector<ctype<char>::mask> bar(temp, temp + ctype<char>::table_size);\n\t//bar[':'] |= ctype_base::space;\n\t//cin.imbue(locale(cin.getloc(), new ctype<char>(bar.data())));\n\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed;\n\tcout << setprecision(std::numeric_limits<double>::max_digits10);\n\tsolve();\n\n\treturn 0;\n}\n\ntemplate <class T>\nstruct RangeSegTrees\n{\n\ttemplate<class TUpdater, class TResolver, class TAccumulator>\n\tstruct Tree\n\t{\n\t\tTree(int count, TUpdater updater, TResolver resolver, TAccumulator accumulator, T initialValue)\n\t\t\t: size(msb(count - 1) << 1)\n\t\t\t, data(size * 2), lazy(size * 2)\n\t\t\t, updater(updater), resolver(resolver), accumulator(accumulator), initialValue(initialValue)\n\t\t{\n\t\t\tlazy[1] = { true, initialValue };\n\t\t}\n\n\t\tvoid update_range(int begin, int end, T value)\n\t\t{\n\t\t\tupdate_range(begin, end, 1, 0, size, value);\n\t\t}\n\n\t\tT query(int begin, int end)\n\t\t{\n\t\t\treturn query(begin, end, 1, 0, size);\n\t\t}\n\n\tprivate:\n\t\tint size;\n\t\tvector<T> data;\n\t\tstruct LAZY { bool use; T val; };\n\t\tvector<LAZY> lazy;\n\n\t\tTUpdater updater;\n\t\tTResolver resolver;\n\t\tTAccumulator accumulator;\n\n\t\tT initialValue;\n\t\tstatic constexpr unsigned int msb(unsigned int v) { REP(i, 5) v |= v >> (1 << i); return (v >> 1) + 1; }\n\n\t\tvoid update_lazy(LAZY &val, T newVal)\n\t\t{\n\t\t\tif (val.use) { val.val = updater(val.val, newVal); }\n\t\t\telse { val.val = newVal; }\n\t\t\tval.use = true;\n\t\t}\n\n\t\tvoid propergate(int i, int l, int r)\n\t\t{\n\t\t\tif (lazy[i].use)\n\t\t\t{\n\t\t\t\tdata[i] = resolver(data[i], lazy[i].val, r - l);\n\t\t\t\tif (i < size)\n\t\t\t\t{\n\t\t\t\t\tupdate_lazy(lazy[i * 2], lazy[i].val);\n\t\t\t\t\tupdate_lazy(lazy[i * 2 + 1], lazy[i].val);\n\t\t\t\t}\n\t\t\t\tlazy[i] = { false, initialValue };\n\t\t\t}\n\t\t}\n\n\t\tT update_range(int s, int e, int i, int l, int r, T value)\n\t\t{\n\t\t\tif (r <= s || e <= l)\n\t\t\t{\n\t\t\t\tpropergate(i, l, r);\n\t\t\t\treturn data[i];\n\t\t\t}\n\n\t\t\tif (s <= l && r <= e)\n\t\t\t{\n\t\t\t\tupdate_lazy(lazy[i], value);\n\t\t\t\tpropergate(i, l, r);\n\t\t\t\treturn data[i];\n\t\t\t}\n\t\t\t\n\t\t\tpropergate(i, l, r);\n\t\t\tint m = (l + r) / 2;\n\t\t\treturn data[i] = accumulator(\n\t\t\t\tupdate_range(s, e, i * 2, l, m, value),\n\t\t\t\tupdate_range(s, e, i * 2 + 1, m, r, value));\n\t\t}\n\n\t\tT query(int s, int e, int i, int l, int r)\n\t\t{\n\t\t\tpropergate(i, l, r);\n\t\t\tif (s <= l && r <= e) { return data[i]; }\n\t\t\tint m = (l + r) / 2;\n\t\t\tif (s < m && e > m)\n\t\t\t{\n\t\t\t\treturn accumulator(query(s, e, i * 2, l, m), query(s, e, i * 2 + 1, m, r));\n\t\t\t}\n\t\t\treturn s < m\n\t\t\t\t? query(s, e, i * 2, l, m)\n\t\t\t\t: query(s, e, i * 2 + 1, m, r);\n\t\t}\n\t};\n\n\ttemplate <class TUpdater, class TResolver, class TAccumulator>\n\tstatic auto RangeSegTree(int n, TUpdater upd, TResolver res, TAccumulator acm, T initial)\n\t{\n\t\treturn Tree<TUpdater, TResolver, TAccumulator>(n, upd, res, acm, initial);\n\t}\n\n\tstatic auto RangeUpdateQuery(int n, T initial = numeric_limits<int>::max())\n\t{\n\t\treturn RangeSegTree(n, CONV2(,b,b), CONV3(,b,,b), CONV2(,b,b), initial);\n\t}\n\n\tstatic auto RangeAddQuery(int n, T initial = 0)\n\t{\n\t\treturn RangeSegTree(n, CONV2(a,b,a+b), CONV3(a,b,c,a+b*c), CONV2(a,b,a+b), initial);\n\t}\n\n\tstatic auto RMQnRUQ(int n, T initial = numeric_limits<int>::max())\n\t{\n\t\treturn RangeSegTree(n, CONV2(,b,b), CONV3(,b,,b), CONV2(a, b, min(a, b)), initial);\n\t}\n\n\tstatic auto RSQnRAQ(int n, T initial = 0)\n\t{\n\t\treturn RangeSegTree(n, CONV2(a,b,a+b), CONV3(a,b,c,a+b*c), CONV2(a,b,a+b), initial);\n\t}\n\n\tstatic auto RMQnRAQ(int n, T initial = 0)\n\t{\n\t\treturn RangeSegTree(n, CONV2(a,b,a+b), CONV3(a,b,,a+b), CONV2(a,b,min(a,b)), initial);\n\t}\n\n\tstatic auto RSQnRUQ(int n, T initial = 0)\n\t{\n\t\treturn RangeSegTree(n, CONV2(,b,b), CONV3(,b,c,b*c), CONV2(a,b,a+b), initial);\n\t}\n};\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tREAD(int, n, q);\n\tauto tree = RangeSegTrees<llong>::RSQnRUQ(n);\n\tint origin = 0;\n\tREP(qq, q)\n\t{\n\t\tREAD(int, c);\n\t\tif (c == 0)\n\t\t{\n\t\t\tREAD(int, s, t, x);\n\t\t\ttree.update_range(s - origin, t + 1 - origin, x);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tREAD(int, s, t);\n\t\t\tllong v = tree.query(s - origin, t + 1 - origin);\n\t\t\tWRITE(v);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n//#pragma GCC optimize (\"-O3\")\n#include <bits/stdc++.h>\nusing namespace std;\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} __initon;\n//衝突対策\n#define ws ___ws\nstruct T {\n    int f, s, t;\n    T() { f = -1, s = -1, t = -1; }\n    T(int f, int s, int t) : f(f), s(s), t(t) {}\n    bool operator<(const T &r) const {\n        return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 大きい順\n    }\n    bool operator>(const T &r) const {\n        return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順\n    }\n    bool operator==(const T &r) const {\n        return f == r.f && s == r.s && t == r.t;\n    }\n    bool operator!=(const T &r) const {\n        return f != r.f || s != r.s || t != r.t;\n    }\n    int operator[](int i) {\n        assert(i < 3);\n        return i == 0 ? f : i == 1 ? s : t;\n    }\n};\n#define int long long\n#define ll long long\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\n\n#define fi first\n#define se second\n#define vec vector\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n\n\n//マクロ省略系 コンテナ\n\nusing vi = vector<int>;\n#define _overloadvvi(_1, _2, _3, _4, name, ...) name\n#define vvi0() vec<vi>\n#define vvi1(a) vec<vi> a\n#define vvi2(a, b) vec<vi> a(b)\n#define vvi3(a, b, c) vec<vi> a(b,vi(c))\n#define vvi4(a, b, c, d) vec<vi> a(b,vi(c,d))\n#define vvi(...) _overloadvvi(__VA_ARGS__,vvi4,vvi3,vvi2 ,vvi1,vvi0)(__VA_ARGS__)\n\n\nusing vl = vector<ll>;\n#define _overloadvvl(_1, _2, _3, _4, name, ...) name\n#define vvl1(a) vec<vl> a\n#define vvl2(a, b) vec<vl> a(b)\n#define vvl3(a, b, c) vec<vl> a(b,vl(c))\n#define vvl4(a, b, c, d) vec<vl> a(b,vl(c,d))\n#define vvl(...) _overloadvvl(__VA_ARGS__,vvl4,vvl3,vvl2 ,vvl1)(__VA_ARGS__)\n\nusing vb = vector<bool>;\n#define _overloadvvb(_1, _2, _3, _4, name, ...) name\n#define vvb1(a) vec<vb> a\n#define vvb2(a, b) vec<vb> a(b)\n#define vvb3(a, b, c) vec<vb> a(b,vb(c))\n#define vvb4(a, b, c, d) vec<vb> a(b,vb(c,d))\n#define vvb(...) _overloadvvb(__VA_ARGS__,vvb4,vvb3,vvb2 ,vvb1)(__VA_ARGS__)\n\nusing vs = vector<string>;\n#define _overloadvvs(_1, _2, _3, _4, name, ...) name\n#define vvs1(a) vec<vs> a\n#define vvs2(a, b) vec<vs> a(b)\n#define vvs3(a, b, c) vec<vs> a(b,vs(c))\n#define vvs4(a, b, c, d) vec<vs> a(b,vs(c,d))\n#define vvs(...) _overloadvvs(__VA_ARGS__,vvs4,vvs3,vvs2 ,vvs1)(__VA_ARGS__)\n\nusing vd = vector<double>;\n#define _overloadvvd(_1, _2, _3, _4, name, ...) name\n#define vvd1(a) vec<vd> a\n#define vvd2(a, b) vec<vd> a(b)\n#define vvd3(a, b, c) vec<vd> a(b,vd(c))\n#define vvd4(a, b, c, d) vec<vd> a(b,vd(c,d))\n#define vvd(...) _overloadvvd(__VA_ARGS__,vvd4,vvd3,vvd2 ,vvd1)(__VA_ARGS__)\n\nusing vc=vector<char>;\n#define _overloadvvc(_1, _2, _3, _4, name, ...) name\n#define vvc1(a) vec<vc> a\n#define vvc2(a, b) vec<vc> a(b)\n#define vvc3(a, b, c) vec<vc> a(b,vc(c))\n#define vvc4(a, b, c, d) vec<vc> a(b,vc(c,d))\n#define vvc(...) _overloadvvc(__VA_ARGS__,vvc4,vvc3,vvc2 ,vvc1)(__VA_ARGS__)\n\nusing vp = vector<P>;\n#define _overloadvvp(_1, _2, _3, _4, name, ...) name\n#define vvp1(a) vec<vp> a\n#define vvp2(a, b) vec<vp> a(b)\n#define vvp3(a, b, c) vec<vp> a(b,vp(c))\n#define vvp4(a, b, c, d) vec<vp> a(b,vp(c,d))\n\nusing vt = vector<T>;\n#define _overloadvvt(_1, _2, _3, _4, name, ...) name\n#define vvt1(a) vec<vt> a\n#define vvt2(a, b) vec<vt> a(b)\n#define vvt3(a, b, c) vec<vt> a(b,vt(c))\n#define vvt4(a, b, c, d) vec<vt> a(b,vt(c,d))\n\n#define v3i(a, b, c, d) vector<vector<vi>> a(b, vector<vi>(c, vi(d)))\n#define v3d(a, b, c, d) vector<vector<vd>> a(b, vector<vd>(c, vd(d)))\n#define v3m(a, b, c, d) vector<vector<vm>> a(b, vector<vm>(c, vm(d)))\n\n#define _vvi vector<vi>\n#define _vvl vector<vl>\n#define _vvb vector<vb>\n#define _vvs vector<vs>\n#define _vvd vector<vd>\n#define _vvc vector<vc>\n#define _vvp vector<vp>\n\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\n#define tos to_string\nusing mapi = map<int, int>;\nusing mapd = map<dou, int>;\nusing mapc = map<char, int>;\nusing maps = map<str, int>;\nusing seti = set<int>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<int>;\n#define bset bitset\n#define uset unordered_set\n#define mset multiset\n#define umap unordered_map\n#define umapi unordered_map<int,int>\n#define umapp unordered_map<P,int>\n#define mmap multimap\n\n//マクロ 繰り返し\n#define _overloadrep(_1, _2, _3, _4, name, ...) name\n# define _rep(i, n) for(int i = 0,_lim=n; i < _lim ; i++)\n#define repi(i, m, n) for(int i = m,_lim=n; i < _lim ; i++)\n#define repadd(i, m, n, ad) for(int i = m,_lim=n; i < _lim ; i+= ad)\n#define rep(...) _overloadrep(__VA_ARGS__,repadd,repi,_rep,)(__VA_ARGS__)\n#define _rer(i, n) for(int i = n; i >= 0 ; i--)\n#define reri(i, m, n) for(int i = m,_lim=n; i >= _lim ; i--)\n#define rerdec(i, m, n, dec) for(int i = m,_lim=n; i >= _lim ; i-=dec)\n#define rer(...) _overloadrep(__VA_ARGS__,rerdec,reri,_rer,)(__VA_ARGS__)\n#define fora(a, b) for(auto&& a : b)\n#define forg(gi, ve) for (int gi = 0, f, t, c; gi < ve.size() && (f = ve[gi].f, t = ve[gi].t, c = ve[gi].c, true); gi++)\n#define fort(gi, ve) for (int gi = 0, f, t, c; gi < ve.size() && (f = ve[gi].f, t = ve[gi].t, c = ve[gi].c, true); gi++)if(t!=p)\n//#define fort(gi, ve) for (int gi = 0, f, t, c;gi<ve.size()&& (gi+= (ve[gi].t==p))< ve.size() && (f = ve[gi].f,t=ve[gi].t, c = ve[gi].c,true); gi++)\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\nconst int inf = (int) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nconst double eps = 1e-9;\nconst double PI = 3.1415926535897932384626433832795029L;\nll ma = numeric_limits<ll>::min();\nll mi = numeric_limits<ll>::max();\nconst int y4[] = {-1, 1, 0, 0};\nconst int x4[] = {0, 0, -1, 1};\nconst int y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconst int x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) ((int)(a).size())\n#define rs resize\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\n\ninline void sort(string &a) { sort(a.begin(), a.end()); }\ntemplate<class T> inline void sort(vector<T> &a) { sort(a.begin(), a.end()); };\ntemplate<class T> inline void sort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len); };\ntemplate<class T, class F> inline void sort(vector<T> &a, F f) { sort(a.begin(), a.end(), [&](T l, T r) { return f(l) < f(r); }); };\nenum ___pcomparator {\n    fisi, fisd, fdsi, fdsd, sifi, sifd, sdfi, sdfd\n};\ninline void sort(vector<P> &a, ___pcomparator type) {\n    switch (type) {\n        case fisi:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi < r.fi : l.se < r.se; });\n            break;\n        case fisd:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi < r.fi : l.se > r.se; });\n            break;\n        case fdsi:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi > r.fi : l.se < r.se; });\n            break;\n        case fdsd:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi > r.fi : l.se > r.se; });\n            break;\n        case sifi:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se < r.se : l.fi < r.fi; });\n            break;\n        case sifd:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se < r.se : l.fi > r.fi; });\n            break;\n        case sdfi:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se > r.se : l.fi < r.fi; });\n            break;\n        case sdfd:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se > r.se : l.fi > r.fi; });\n            break;\n    }\n};\ninline void sort(vector<T> &a, ___pcomparator type) {\n    switch (type) {\n        case fisi:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f < r.f : l.s < r.s; });\n            break;\n        case\n            fisd:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f < r.f : l.s > r.s; });\n            break;\n        case\n            fdsi:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f > r.f : l.s < r.s; });\n            break;\n        case\n            fdsd:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f > r.f : l.s > r.s; });\n            break;\n        case\n            sifi:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s < r.s : l.f < r.f; });\n            break;\n        case\n            sifd:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s < r.s : l.f > r.f; });\n            break;\n        case\n            sdfi:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s > r.s : l.f < r.f; });\n            break;\n        case\n            sdfd:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s > r.s : l.f > r.f; });\n            break;\n    }\n};\ntemplate<class T> inline void rsort(vector<T> &a) { sort(a.begin(), a.end(), greater<T>()); };\ntemplate<class T> inline void rsort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len, greater<T>()); };\ntemplate<class U, class F> inline void rsort(vector<U> &a, F f) { sort(a.begin(), a.end(), [&](U l, U r) { return f(l) > f(r); }); };\ntemplate<class U> inline void sortp(vector<U> &a, vector<U> &b) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;;\n    }\n};\n//F = T<T>\n//例えばreturn p.fi + p.se;\ntemplate<class U, class F> inline void sortp(vector<U> &a, vector<U> &b, F f) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c, f);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U, class F> inline void sortp(vector<U> &a, vector<U> &b, char type) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c, type);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U> inline void rsortp(vector<U> &a, vector<U> &b) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    rsort(c);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U, class F> inline void rsortp(vector<U> &a, vector<U> &b, F f) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    rsort(c, f);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U> inline void sortt(vector<U> &a, vector<U> &b, vector<U> &c) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    sort(r);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class U, class F> inline void sortt(vector<U> &a, vector<U> &b, vector<U> &c, F f) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    sort(r, f);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class U, class F> inline void rsortt(vector<U> &a, vector<U> &b, vector<U> &c, F f) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    rsort(r, f);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class T> inline void sort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)sort(a[i]); }\ntemplate<class T> inline void rsort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)rsort(a[i]); }\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }\ntemplate<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\n\ntemplate<typename V, typename T>\nvoid fill(V &xx, const T vall) {\n    xx = vall;\n}\ntemplate<typename V, typename T>\nvoid fill(vector<V> &vecc, const T vall) {\n    for (auto &&vx: vecc) fill(vx, vall);\n}\n\n//@汎用便利関数 入力\ntemplate<typename T = int> T _in() {\n    T x;\n    cin >> x;\n    return (x);\n}\n#define _overloadin(_1, _2, _3, _4, name, ...) name\n#define in0() _in()\n#define in1(a) cin>>a\n#define in2(a, b) cin>>a>>b\n#define in3(a, b, c) cin>>a>>b>>c\n#define in4(a, b, c, d) cin>>a>>b>>c>>d\n#define in(...) _overloadin(__VA_ARGS__,in4,in3,in2 ,in1,in0)(__VA_ARGS__)\n\n#define _overloaddin(_1, _2, _3, _4, name, ...) name\n#define din1(a) int a;cin>>a\n#define din2(a, b) int a,b;cin>>a>>b\n#define din3(a, b, c) int a,b,c;cin>>a>>b>>c\n#define din4(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d\n#define din(...) _overloadin(__VA_ARGS__,din4,din3,din2 ,din1)(__VA_ARGS__)\n\n#define _overloaddind(_1, _2, _3, _4, name, ...) name\n#define din1d(a) int a;cin>>a;a--\n#define din2d(a, b) int a,b;cin>>a>>b;a--,b--\n#define din3d(a, b, c) int a,b,c;cin>>a>>b>>c;a--,b--,c--\n#define din4d(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d;;a--,b--,c--,d--\n#define dind(...) _overloaddind(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\n\n\nstring sin() { return _in<string>(); }\nll lin() { return _in<ll>(); }\n#define na(a, n) a.resize(n); rep(i,n) cin >> a[i];\n#define nao(a, n) a.resize(n+1); rep(i,n) cin >> a[i+1];\n#define nad(a, n) a.resize(n); rep(i,n){ cin >> a[i]; a[i]--;}\n#define na2(a, b, n) a.resize(n),b.resize(n);rep(i, n)cin >> a[i] >> b[i];\n#define na2d(a, b, n) a.resize(n),b.resize(n);rep(i, n){cin >> a[i] >> b[i];a[i]--,b[i]--;}\n#define na3(a, b, c, n) a.resize(n),b.resize(n),c.resize(n);   rep(i, n)cin >> a[i] >> b[i] >> c[i];\n#define na3d(a, b, c, n) a.resize(n),b.resize(n),c.resize(n);   rep(i, n){cin >> a[i] >> b[i] >> c[i];a[i]--,b[i]--,c[i]--;}\n#define nt(a, h, w) resize(a,h,w);rep(hi,h)rep(wi,w) cin >> a[hi][wi];\n#define ntd(a, h, w) rs(a,h,w);rep(hi,h)rep(wi,w) cin >> a[hi][wi], a[hi][wi]--;\n#define ntp(a, h, w) fill(a,'#');rep(hi,1,h+1)rep(wi,1,w+1) cin >> a[hi][wi];\n\n//デバッグ\n#define sp << \" \" <<\n\n#define debugName(VariableName) # VariableName\n\n#define _deb1(x) cerr <<  debugName(x)<<\" = \"<<x << endl\n#define _deb2(x, y) cerr <<  debugName(x)<<\" = \"<<x<<\", \"<< debugName(y)<<\" = \"<<y<< endl\n#define _deb3(x, y, z) cerr <<  debugName(x)<<\" = \"<<x  << \", \" <<  debugName(y)<<\" = \"<<y <<\", \" debugName(z)<<\" = \"<<z <<endl\n#define _deb4(x, y, z, a) cerr <<  debugName(x)<<\" = \"<<x <<\", \" <<   debugName(y)<<\" = \"<<y <<\", \" <<  debugName(z)<<\" = \"<<z <<\", \" <<  debugName(a)<<\" = \"<<a<<endl\n#define _deb5(x, y, z, a, b) cerr <<  debugName(x)<<\" = \"<<x <<\", \" <<   debugName(y)<<\" = \"<<y <<\", \" <<  debugName(z)<<\" = \"<<z <<\", \" <<  debugName(a)<<\" = \"<<a<<\", \" <<  debugName(b)<<\" = \"<<b<<endl\n\n\n#define _overloadebug(_1, _2, _3, _4, _5, name, ...) name\n#define debug(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n#define deb(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\nvoid ole() {\n#ifdef _DEBUG\n    debugline(\"ole\");\n    exit(0);\n#endif\n    string a = \"a\";\n    rep(i, 30)a += a;\n    rep(i, 1 << 17)cout << a << endl;\n    cout << \"OLE 出力長制限超過\" << endl;\n    exit(0);\n}\nvoid tle() { while (inf)cout << inf << endl; }\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll gcd(vi b) {\n    ll res = b[0];\n    for (auto &&v :b)res = gcd(v, res);\n    return res;\n}\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll rev(ll a) {\n    ll res = 0;\n    while (a) {\n        res *= 10;\n        res += a % 10;\n        a /= 10;\n    }\n    return res;\n}\ntemplate<class T> void rev(vector<T> &a) {\n    reverse(all(a));\n}\nvoid rev(string &a) {\n    reverse(all(a));\n}\nll ceil(ll a, ll b) {\n    if (b == 0) {\n        debugline(\"ceil\");\n        deb(a, b);\n        ole();\n        return -1;\n    } else return (a + b - 1) / b;\n}\nll sqrt(ll a) {\n    if (a < 0) {\n        debugline(\"sqrt\");\n        deb(a);\n        ole();\n    }\n    ll res = (ll) std::sqrt(a);\n    while (res * res < a)res++;\n    return res;\n}\ndouble log(double e, double x) { return log(x) / log(e); }\nll sig(ll t) { return (1 + t) * t / 2; }\nll sig(ll s, ll t) { return (s + t) * (t - s + 1) / 2; }\n\nvi divisors(int v) {\n    vi res;\n    double lim = std::sqrt(v);\n    for (int i = 1; i <= lim; ++i) {\n        if (v % i == 0) {\n            res.pb(i);\n            if (i != v / i)res.pb(v / i);\n        }\n    }\n    return res;\n}\n\nvb isPrime;\nvi primes;\n\nvoid setPrime() {\n    int len = 4010101;\n    isPrime.resize(4010101);\n    fill(isPrime, true);\n    isPrime[0] = isPrime[1] = false;\n    for (int i = 2; i <= sqrt(len) + 5; ++i) {\n        if (!isPrime[i])continue;\n        for (int j = 2; i * j < len; ++j) {\n            isPrime[i * j] = false;\n        }\n    }\n    rep(i, len)if (isPrime[i])primes.pb(i);\n}\n\nvi factorization(int v) {\n    int tv = v;\n    vi res;\n    if (isPrime.size() == 0)setPrime();\n    for (auto &&p :primes) {\n        if (v % p == 0)res.push_back(p);\n        while (v % p == 0) {\n            v /= p;\n        }\n        if (v == 1 || p * p > tv)break;\n    }\n    if (v > 1)res.pb(v);\n    return res;\n}\ninline bool inside(int h, int w, int H, int W) { return h >= 0 && w >= 0 && h < H && w < W; }\ninline bool inside(int v, int l, int r) { return l <= v && v < r; }\n#define ins inside\nll u(ll a) { return a < 0 ? 0 : a; }\ntemplate<class T> vector<T> u(const vector<T> &a) {\n    vector<T> ret = a;\n    fora(v, ret)v = u(v);\n    return ret;\n}\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\n\nvoid yn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n}\nvoid Yn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n}\nvoid YN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n}\nvoid fyn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n    exit(0);\n}\nvoid fYn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    exit(0);\n}\nvoid fYN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n    exit(0);\n}\nvoid Possible(bool a) {\n    if (a)cout << \"Possible\" << endl;\n    else cout << \"Impossible\" << endl;\n    exit(0);\n}\nvoid POSSIBLE(bool a) {\n    if (a)cout << \"POSSIBLE\" << endl;\n    else cout << \"IMPOSSIBLE\" << endl;\n    exit(0);\n}\ntemplate<class T, class U> set<T> &operator+=(set<T> &a, U v) {\n    a.insert(v);\n    return a;\n}\ntemplate<class T, class U> vector<T> &operator+=(vector<T> &a, U v) {\n    a.pb(v);\n    return a;\n}\ntemplate<class T> T sum(vector<T> &v, int s = 0, int t = inf) {\n    T ret = 0;\n    rep(i, s, min(sz(v), t))ret += v[i];\n    return ret;\n}\nvoid mod(int &a, int m) { a = (a % m + m) % m; }\ntemplate<class F> inline int mgr(int ok, int ng, F f) {\n#define _mgrbody int mid = (ok + ng) / 2; if (f(mid))ok = mid; else ng = mid;\n    if (ok < ng)while (ng - ok > 1) { _mgrbody } else while (ok - ng > 1) { _mgrbody }\n    return ok;\n}\n\ntemplate<class F> inline int mgr(int ok, int ng, int second, F f) {\n#define _mgrbody2 int mid = (ok + ng) / 2; if (f(mid, second))ok = mid; else ng = mid;\n    if (ok < ng) while (ng - ok > 1) { _mgrbody2 } else while (ok - ng > 1) { _mgrbody2 }\n    return ok;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &m) {\n    for (auto &&v:m) os << v << \" \";\n    return os;\n}\nconstexpr bool bget(ll m, int keta) { return (m >> keta) & 1; }\nint bget(ll m, int keta, int sinsuu) {\n    m /= (ll) pow(sinsuu, keta);\n    return m % sinsuu;\n}\nll bit(int n) { return (1LL << (n)); }\nll bit(int n, int sinsuu) { return (ll) pow(sinsuu, n); }\nint mask(int n) { return (1ll << n) - 1; }\n#define bcou __builtin_popcountll\ntemplate<class T> vector<T> ruiv(vector<T> &a) {\n    vector<T> ret(a.size() + 1);\n    rep(i, a.size())ret[i + 1] = ret[i] + a[i];\n    return ret;\n}\ntemplate<class T, class U> inline bool chma(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class U> inline bool chma(const U &b) { return chma(ma, b); }\ntemplate<class T, class U> inline bool chmi(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class U> inline bool chmi(const U &b) { return chmi(mi, b); }\n#define unique(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\nint n, m, k, d, H, W, x, y, z, q;\nint cou;\nvi a, b, c;\nvvi (s, 0, 0);\nvvc (ba, 0, 0);\nvp p;\n\ntemplate<typename T> struct segusum {/*@formatter:off*/\n    int n, height;\n    T fvv(T a, T b) {return a+b;}\n    T fvl(int len, T x) {return len*x;}\n    T ve = 0; //演算における単位元\n    T le = MIN(T);//作用素に対しての単位元\n    vector<T> dat;\n    vector<T> laz;\n    vi len;\n    segusum(vector<T> a) {        n = 1;        int n_ = a.size();        height = 0;        while (n <= n_) n <<= 1, height++;        dat.assign(n << 1, ve);        laz.assign(n << 1, le);        len.assign(n << 1, 0);        int l = 1, v = n;        rep(i, 1, n << 1) {            if ((l << 1) == i) {                l <<= 1;                v >>= 1;            }            len[i] = v;        }        for (int i = 0; i < n_; i++) dat[n + i] = a[i];        for (int i = n - 1; i; i--)            dat[i] = fvv(dat[(i << 1) | 0], dat[(i << 1) | 1]);    }\n    //おそらく1-indexed\n    T reflect(int k) {        return laz[k] == le ? dat[k] : fvl(len[k], laz[k]);    }\n    void eval(int k) {        if (laz[k] == le) return;        laz[(k << 1)] = laz[k];        laz[(k << 1) | 1] = laz[k];        dat[k] = reflect(k);        laz[k] = le;    }\n    void thrust(int k) {for (int i = height; i; i--) eval(k >> i);}\n    void recalc(int k) {        while (k >>= 1)dat[k] = fvv(reflect((k << 1) | 0), reflect((k << 1) | 1));    }\n    void update(int a, int b, T x) {        thrust(a += n);        thrust(b += n - 1);        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {            if (l & 1) laz[l] = x, l++;            if (r & 1) --r, laz[r] = x;        }        recalc(a);        recalc(b);    }\n//    void set_val(int a, T x) {        thrust(a += n);        dat[a] = x;        laz[a] = le;        recalc(a);    }\n    T get(int a, int b) {        thrust(a += n);        thrust(b += n - 1);        T vl = ve, vr = ve;        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {            if (l & 1) vl = fvv(vl, reflect(l++));            if (r & 1) vr = fvv(reflect(--r), vr);        }        return fvv(vl, vr);    }\n    void debu() {        rep(i, min(n, 10ll)) {            cerr << get(i, i + 1) << \" \";        }        cerr << \"\" << endl;    }/*@formatter:on*/\n};\nsigned main() {\n    cin >> n >> q;\n    segusum<int> seg(vi(k5));\n    while (q--) {\n        int t;\n        cin >> t;\n        if (t == 0) {\n            int s, t, a;\n            cin >> s >> t >> a;\n            seg.update(s, t + 1, a);\n        } else {\n            int s, t;\n            cin >> s >> t;\n            cout << seg.get(s, t + 1) << endl;\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/*Range Add Min(Max) Query*/\n/*区間加算、区間Min,区間Max*/\n\nclass RSUQ{\npublic: \n  typedef long long ll;\n\n  //マージ可能な主データ型\n  struct D{\n    ll value;\n    D():value(0){} /*適切な値にする!!!!!!*/\n    D(ll value):value(value){}\n    bool operator < (D a)const {return value < a.value;}\n  };\n\n  //遅延用の型  \n  struct T{\n    int type; //0 - empty   , 1 - update\n    ll value;\n    T():type(0),value(0){}\n    T(int type,ll value):type(type),value(value){}\n  };\n\n  \n  int n, n_;\n  vector<D> dat;\n  vector<T> td;\n  D returnD = D(0); // 範囲外の時に返す値。\n  \n  RSUQ(){n=-1;}\n  RSUQ(int n_):n_(n_){\n    n=1;\n    while(n < n_) n *= 2;\n    td.resize(2*n-1,T());\n    dat.resize(2*n-1,D());\n  }\n  \n  inline D merge(D a,D b){return a.value + b.value;}\n  \n  void delay(int k,int len){\n    if(td[k].type==0) return;\n    ll type = td[k].type;\n    ll v = td[k].value;\n    td[k].type = 0;\n    td[k].value = 0;\n    \n    len /= 2;\n    {\n      int l = k*2+1;\n      dat[l].value = v * len;\n      td[l].type = type;\n      td[l].value = v;\n    }\n    {\n      int r = k*2+2;\n      dat[r].value = v * len;\n      td[r].type = type;\n      td[r].value = v;\n    }\n  }\n\n  D write(int k, D x, int len){\n    dat[k].value = x.value * len;\n    td[k].type = 1;\n    td[k].value = x.value;\n    return dat[k];\n  }\n\n  D test(int a,int b,D x, bool flag){\n    \n    function<D(int,int,int)> dfs = [&](int k, int l, int r){\n      if(r <= a||b <= l) return flag? dat[k]:returnD;\n      if(a <= l && r <= b) return flag? write(k, x, r - l):dat[k];\n      delay(k, r - l);\n      D vl = dfs(k*2+1, l, (l+r)/2);\n      D vr = dfs(k*2+2, (l+r)/2, r);\n      return flag? (dat[k] = merge(vl, vr)):merge(vl, vr);\n    };\n    return dfs(0, 0, n);\n  }\n\n  //[l,r)の値をx変更　query(l,r,x)\n  void update(int l,int r,ll x){\n    assert(l <= r);\n    assert(0 <= l && l <= n);\n    assert(0 <= r && r <= n);\n    test(l, r, D(x), true);\n  }\n  \n  //[l,r)の合計値を得る　find(a,b);\n  ll find(int l,int r){\n    assert(l <= r);\n    assert(0 <= l && l <= n);\n    assert(0 <= r && r <= n);\n    D res = test(l, r, D(), false);\n    return res.value;\n  }\n};\n\n\nsigned main(){\n  int n,q;\n  cin>>n>>q;\n  \n  RSUQ rsuq(n);\n\n  while(q--){\n    int cmd;\n    cin>>cmd;\n    if(cmd == 0){\n      int s,t,x;\n      cin>>s>>t>>x;\n      rsuq.update(s,t+1,x);\n    }\n    \n    if(cmd == 1){\n      int s,t;\n      cin>>s>>t;\n      cout<<rsuq.find(s,t+1)<<endl;\n    }\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\nclass Add_Segment_Tree {\n\tvector<long long int>v;\n\tvector<long long int>add;\n\tvector<long long int>modi;\n\tvector<int>l;\n\tvector<int>r;\n\tint num;\n\tlong long int ret;\n\tvoid Left(int place) {\n\t\tif (place >= v.size() / 2) {\n\t\t\tl[place] = place - v.size() / 2;\n\t\t\treturn;\n\t\t}\n\t\tLeft(place * 2);\n\t\tLeft(place * 2 + 1);\n\t\tl[place] = l[place * 2];\n\t\treturn;\n\t}\n\tvoid Right(int place) {\n\t\tif (place >= v.size() / 2) {\n\t\t\tr[place] = place - v.size() / 2;\n\t\t\treturn;\n\t\t}\n\t\tRight(place * 2);\n\t\tRight(place * 2 + 1);\n\t\tr[place] = r[place * 2 + 1];\n\t\treturn;\n\t}\n\tlong long int Update(int place) {\n\t\tif (place >= v.size() / 2) {\n\t\t\treturn v[place];\n\t\t}\n\t\tv[place] = Update(place * 2) + Update(place * 2 + 1);\n\t\treturn v[place];\n\t}\n\tvoid Modify(int a, int b, long long int num, int place) {\n\t\tif (l[place] >= a && r[place] <= b) {\n\t\t\tmodi[place] = num * (r[place] - l[place] + 1);\n\t\t\tv[place] = num * (r[place] - l[place] + 1);\n\t\t\tadd[place] = 0;\n\t\t\treturn;\n\t\t}\n\t\tif (l[place] > b || r[place] < a)return;\n\t\tif (modi[place] != LLONG_MAX) {\n\t\t\tmodi[place * 2] = modi[place * 2 + 1] = modi[place]/2;\n\t\t\tv[place * 2] = v[place * 2 + 1] = modi[place]/2;\n\t\t\tadd[place * 2] = add[place * 2 + 1] = 0;\n\t\t\tmodi[place] = LLONG_MAX;\n\t\t}\n\t\tadd[place * 2] += add[place]/2;\n\t\tadd[place * 2 + 1] += add[place]/2;\n\t\tadd[place] = 0;\n\t\tModify(a, b, num, place * 2);\n\t\tModify(a, b, num, place * 2 + 1);\n\t\tv[place] = v[place * 2] + add[place * 2] + v[place * 2 + 1] + add[place * 2 + 1];\n\t\treturn;\n\t}\n\tvoid Add(int a, int b, long long int num, int place) {\n\t\tif (l[place] >= a && r[place] <= b) {\n\t\t\tif (modi[place] != LLONG_MAX) {\n\t\t\t\tif (place * 2 < v.size()) {\n\t\t\t\t\tmodi[place * 2] = modi[place * 2 + 1] = modi[place] / 2;\n\t\t\t\t\tv[place * 2] = v[place * 2 + 1] = modi[place] / 2;\n\t\t\t\t\tadd[place * 2] = add[place * 2 + 1] = 0;\n\t\t\t\t}\n\t\t\t\tmodi[place] = LLONG_MAX;\n\t\t\t}\n\t\t\tadd[place] += num * (r[place] - l[place] + 1);\n\t\t\treturn;\n\t\t}\n\t\tif (l[place] > b || r[place] < a)return;\n\t\tif (modi[place] != LLONG_MAX) {\n\t\t\tmodi[place * 2] = modi[place * 2 + 1] = modi[place]/2;\n\t\t\tv[place * 2] = v[place * 2 + 1] = modi[place]/2;\n\t\t\tadd[place * 2] = add[place * 2 + 1] = 0;\n\t\t\tmodi[place] = LLONG_MAX;\n\t\t}\n\t\tadd[place * 2] += add[place]/2;\n\t\tadd[place * 2 + 1] += add[place]/2;\n\t\tadd[place] = 0;\n\t\tAdd(a, b, num, place * 2);\n\t\tAdd(a, b, num, place * 2 + 1);\n\t\tv[place] = v[place * 2] + add[place * 2] + v[place * 2 + 1] + add[place * 2 + 1];\n\t\treturn;\n\t}\n\tvoid Sum(int a, int b, int place) {\n\t\tif (l[place] >= a && r[place] <= b) {\n\t\t\tif (modi[place] != LLONG_MAX) {\n\t\t\t\tif (place * 2 < v.size()) {\n\t\t\t\t\tmodi[place * 2] = modi[place * 2 + 1] = modi[place] / 2;\n\t\t\t\t\tv[place * 2] = v[place * 2 + 1] = modi[place] / 2;\n\t\t\t\t\tadd[place * 2] = add[place * 2 + 1] = 0;\n\t\t\t\t}\n\t\t\t\tmodi[place] = LLONG_MAX;\n\t\t\t}\n\t\t\tret += v[place] + add[place];\n\t\t\treturn;\n\t\t}\n\t\tif (l[place]>b || r[place]<a) return;\n\t\tif (modi[place] != LLONG_MAX) {\n\t\t\tmodi[place * 2] = modi[place * 2 + 1] = modi[place]/2;\n\t\t\tv[place * 2] = v[place * 2 + 1] = modi[place] / 2;\n\t\t\tadd[place * 2] = add[place * 2 + 1] = 0;\n\t\t\tmodi[place] = LLONG_MAX;\n\t\t}\n\t\tadd[place * 2] += add[place]/2;\n\t\tadd[place * 2 + 1] += add[place]/2;\n\t\tadd[place] = 0;\n\t\tSum(a, b, place * 2);\n\t\tSum(a, b, place * 2 + 1);\n\t\tv[place] = v[place * 2] + add[place * 2] + v[place * 2 + 1] + add[place * 2 + 1];\n\t\treturn;\n\t}\npublic:\n\tAdd_Segment_Tree(int n) {\n\t\tn++;\n\t\tnum = 1;\n\t\twhile (num < n * 2) {\n\t\t\tnum *= 2;\n\t\t}\n\t\tl.resize(num);\n\t\tr.resize(num);\n\t\tv.resize(num, 0);\n\t\tadd.resize(num, 0);\n\t\tmodi.resize(num, LLONG_MAX);\n\t\tLeft(1);\n\t\tRight(1);\n\t}\n\tvoid Insert(int place, long long int num, bool update) {\n\t\tplace += v.size() / 2;\n\t\tv[place] = num;\n\t\tif (!update)return;\n\t\tplace /= 2;\n\t\twhile (place) {\n\t\t\tv[place] = v[place * 2] + v[place * 2 + 1];\n\t\t\tplace /= 2;\n\t\t}\n\t}\n\tvoid Modify(int a, int b, long long int num) {\n\t\tModify(a, b, num, 1);\n\t}\n\tvoid Add(int a, int b, long long int num) {\n\t\tAdd(a, b, num, 1);\n\t}\n\tvoid Init() {\n\t\tUpdate(1);\n\t}\n\tlong long int Sum(int a, int b) {\n\t\tret = 0;\n\t\tSum(a, b, 1);\n\t\treturn ret;\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> K;\n\tvector<long long int>ans;\n\tAdd_Segment_Tree asg(N);\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> M;\n\t\tif (M) {\n\t\t\tcin >> L >> R;\n\t\t\tans.push_back(asg.Sum(L, R));\n\t\t}\n\t\telse {\n\t\t\tcin >> L >> R >> H;\n\t\t\tasg.Modify(L, R, H);\n\t\t}\n\t}\n\tfor (auto i : ans) {\n\t\tcout << i << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <limits>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <random>\n#include <memory>\n#include <utility>\n \n#define rep(i, a, b) for (long long (i) = (a); i < (b); i++)\n#define all(i) i.begin(), i.end()\n#define debug(i) std::cerr << \"debug \" <<\"LINE:\"<<__LINE__<<\"  \"<< #i <<\":\"<< i << std::endl\n\n \ntemplate <typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& os, std::pair<T1, T2> pa) {\n  return os << pa.first << \" \" << pa.second;\n}\n \ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> vec) {\n  for (int i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n  return os;\n}\n \ntemplate<typename T1,typename T2>\ninline bool chmax(T1& a,T2 b){return a<b && (a=b,true);}\n \ntemplate<typename T1,typename T2>\ninline bool chmin(T1& a,T2 b){return a>b && (a=b,true);}\n \nlong long pow_mod(long long a, long long b, long long mod=-1) {\n  if ((a == 0)||(mod!=-1&&a%mod==0)) {\n    return 0;\n  }\n \n  long long x = 1;\n \n  while (b > 0) {\n    if (b & 1) {\n      x = (mod!=-1)?(x * a) % mod:x*a;\n    }\n    a = (mod!=-1)?(a * a) % mod:a*a;\n    b >>= 1;\n  }\n  return x;\n}\n \n// const long long MOD = 998244353;\nconst long long MOD = 1e9 + 7;\n\nusing ll = long long;\nusing P = std::pair<ll, ll>;\n\n//遅延セグ木\ntemplate<typename T,typename E>\nclass LazySegmentTree{\n  private:\n  int n,n0;\n  std::vector<T> dat;\n  std::vector<E> lazy;\n\n  T init_t;\n  E init_e;\n\n  using F=std::function<T(T,T)>;\n  using G=std::function<T(T,E)>;\n  using H=std::function<E(E,E)>;\n  using P=std::function<E(E,int)>;\n\n  F f;\n  G g;\n  H h;\n  P p;\n\n  T update(int a,int b,T val,int l,int r,int k){\n    if(lazy[k]!=init_e){\n      if(k<n0-1){\n        lazy[2*k+1]=h(lazy[2*k+1],lazy[k]);\n        lazy[2*k+2]=h(lazy[2*k+2],lazy[k]);\n      }\n      dat[k]=g(dat[k],p(lazy[k],r-l));\n      lazy[k]=init_e;\n    }\n\n    if(r<=a||b<=l)return dat[k];\n    if(a<=l&&r<=b){\n      lazy[k]=h(lazy[k],val);\n      return g(dat[k],p(lazy[k],r-l));\n    }\n\n    return dat[k]=f(update(a,b,val,l,l+(r-l)/2,2*k+1),update(a,b,val,l+(r-l)/2,r,2*k+2));\n  }\n\n  T query(int a,int b,int l,int r,int k){\n    if(lazy[k]!=init_e){\n      if(k<n0-1){\n        lazy[2*k+1]=h(lazy[2*k+1],lazy[k]);\n        lazy[2*k+2]=h(lazy[2*k+2],lazy[k]);\n      }\n      dat[k]=g(dat[k],p(lazy[k],r-l));\n      lazy[k]=init_e;\n    }\n\n    if(r<=a||b<=l)return init_t;\n    if(a<=l&&r<=b)return dat[k];\n    T lval=query(a,b,l,l+(r-l)/2,2*k+1);\n    T rval=query(a,b,l+(r-l)/2,r,2*k+2);\n    return f(lval,rval);\n  }\n\n  public:\n\n  LazySegmentTree(int n_,F f_,G g_,H h_,T t,E e,std::vector<T> dat_=std::vector<T>(),P p_=[](E a,int n){return a;})\n    :n(n_),init_t(t),init_e(e),f(f_),g(g_),h(h_),p(p_){\n\n    n0=1;\n    while(n0<n)n0<<=1;\n    dat=std::vector<T>(2*n0-1,init_t);\n    lazy=std::vector<E>(2*n0-1,init_e);\n    if(n_==dat_.size()){\n      for(int i=0;i<n_;i++)dat[i+n0-1]=dat_[i];\n      for(int i=n0-2;i>=0;i--)dat[i]=f(dat[2*i+1],dat[2*i+2]);\n    }\n  }\n\n  void update(int a,int b,T val){\n    update(a,b,val,0,n0,0);\n  }\n\n  T query(int a,int b){\n    return query(a,b,0,n0,0);\n  }\n};\n\nint main() {\n  std::cin.tie(0);\n  std::ios::sync_with_stdio(false);\n\n  ll n,q;\n  std::cin>>n>>q;\n\n  LazySegmentTree<ll,ll> seg(n,[](ll a,ll b){return a+b;},\n                              [](ll a,ll b){return (b==MOD)?a:b;},\n                              [](ll a,ll b){return (b==MOD)?a:b;},\n                              0,MOD,std::vector<ll>(n,0),[](ll a,int b){return (a==MOD)?MOD:a*b;});\n\n  rep(_,0,q){\n    ll com;\n    std::cin>>com;\n    if(com==0){\n      ll s,t,x;\n      std::cin>>s>>t>>x;\n      seg.update(s,t+1,x);\n    }else{\n      ll s,t;\n      std::cin>>s>>t;\n      std::cout<<seg.query(s,t+1)<<\"\\n\";\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\ntypedef pair<pii,int> ppi;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a/gcd(a,b)*b;\n}\n\nclass LazySegmentTree{\nprivate:\n    int n;\n    vector<long long> node, lazy;\n    long long node_init = 0; // sum, max, update\n    //long long node_init = LINF; // min\n    long long lazy_init = 0; // default\n    //long long lazy_init = LINF; // min\n\n    long long lazy_update(long long a,long long b){\n        //return a+b; // sum query\n        //return max(a,b); // max query\n        //return min(a,b); // min query\n        return b; // update query\n    }\n\n    long long node_update(long long a, long long b, int l, int r){ // lazy を node に反映\n        //return a + b; // min query\n        return b; // update query\n        return b * (r-l); // sum query\n    }\n\n    long long combine(long long a,long long b){\n        return a+b; // sum query\n        //return max(a,b); // max query\n        //return min(a,b); // min query\n    }\n\npublic:\n    LazySegmentTree(){}\n    LazySegmentTree(vector<long long> in){\n        n = 1;\n        while(n < in.size())n <<= 1;\n        node = vector<long long>(2*n, node_init);\n        lazy = vector<long long>(2*n, lazy_init);\n        for(int i = n-1+in.size()-1; i >= 0; i--){\n            if(n-1 <= i)node[i] = in[i-(n-1)];\n            else node[i] = combine(node[i*2+1], node[i*2+2]);\n        }\n    }\n    void eval(int k, int l, int r){\n        if(lazy[k] != lazy_init){\n            node[k] = node_update(node[k], lazy[k], l, r);\n            if(r - l > 1){\n                lazy[2*k+1] = lazy_update(lazy[2*k+1], lazy[k]);\n                lazy[2*k+2] = lazy_update(lazy[2*k+2], lazy[k]);\n            }\n            lazy[k] = lazy_init;\n        }\n    }\n    void update(int a, int b, long long x, int k = 0, int l = 0, int r = -1){\n        if(r < 0)r = n;\n        eval(k,l,r);\n        if(b <= l || r <= a)return;\n        if(a <= l && r <= b){\n            lazy[k] = x;\n            eval(k,l,r);\n        }else{\n            update(a,b,x,2*k+1,l,(l+r)/2);\n            update(a,b,x,2*k+2,(l+r)/2,r);\n            node[k] = combine(node[2*k+1], node[2*k+2]);\n        }\n    }\n    long long query(int a, int b, int k = 0, int l = 0, int r = -1){\n        if(r < 0)r = n;\n        if(b <= l || r <= a)return node_init;\n        eval(k,l,r);\n        if(a <= l && r <= b)return node[k];\n        return combine(query(a,b,2*k+1,l,(l+r)/2), query(a,b,2*k+2,(l+r)/2,r));\n    }\n    void show(){\n        cout << \"node :\";\n        for(int i = 0; i < 2*n; i++){\n            if(i == n)cout << \"     \";\n            cout << \" \" << node[i];\n        }\n        cout << endl;\n        cout << \"lazy :\";\n        for(int i = 0; i < 2*n; i++){\n            if(i == n)cout << \"     \";\n            cout << \" \" << lazy[i];\n        }\n        cout << endl;\n    }\n};\n\nsigned main(void) {\n\n    int n,q;\n    cin >> n >> q;\n    LazySegmentTree lazy = LazySegmentTree(vi(n));\n\n    rep(i,q){\n        int a;\n        cin >> a;\n        if(a == 0){//update\n            int s,t,x;\n            cin >> s >> t >> x;\n            lazy.update(s,t+1,x);\n        }else{//query\n            int s,t;\n            cin >> s >> t;\n            cout << lazy.query(s,t+1) << endl;\n        }\n        //lazy.show();\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define eb emplace_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\ntemplate<class A,class B>\nostream& operator<<(ostream& ost,const pair<A,B>&p){\n\tost<<\"{\"<<p.first<<\",\"<<p.second<<\"}\";\n\treturn ost;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& ost,const vector<T>&v){\n\tost<<\"{\";\n\tfor(int i=0;i<v.size();i++){\n\t\tif(i)ost<<\",\";\n\t\tost<<v[i];\n\t}\n\tost<<\"}\";\n\treturn ost;\n}\ntemplate<class T,class E,class F,class G,class H>\nstruct LazySegmentTree{\n\tF f;\n\tG g;\n\tH h;\n\n\tT ti;\n\tE ei;\n\n\tvector<T>dat;\n\tvector<E>put;\n\tint sz;\n\tLazySegmentTree(const T &ti,const E &ei,const F &f,const G &g,const H &h):ti(ti),ei(ei),f(f),g(g),h(h){}\n\n\tvoid build(const vector<T>&v){\n\t\tassert(v.size());\n\t\tsz=1;\n\t\twhile(sz<v.size())sz<<=1;\n\t\tdat.resize(sz<<1,ti);\n\t\tput.resize(sz<<1,ei);\n\t\tfor(int i=0;i<v.size();i++)dat[sz-1+i]=v[i];\n\t\tfor(int i=sz-2;i>=0;i--)dat[i]=f(dat[i*2+1],dat[i*2+2]);\n\t}\n\tinline void push(int k,int l,int r){\n\t\tdat[k]=g(dat[k],put[k],r-l);\n\t\tif(k<sz-1){\n\t\t\tput[k*2+1]=h(put[k*2+1],put[k]);\n\t\t\tput[k*2+2]=h(put[k*2+2],put[k]);\n\t\t}\n\t\tput[k]=ei;\n\t}\n\n\tvoid modify(int a,int b,E x,int k,int l,int r){\n\t\tpush(k,l,r);\n\t\tif(r<=a||b<=l)return;\n\t\tif(a<=l&&r<=b){\n\t\t\tput[k]=x;\n\t\t\tpush(k,l,r);\n\t\t\treturn;\n\t\t}\n\t\tmodify(a,b,x,k*2+1,l,(l+r)/2);\n\t\tmodify(a,b,x,k*2+2,(l+r)/2,r);\n\t\tdat[k]=f(dat[k*2+1],dat[k*2+2]);\n\t}\n\n\tinline void modify(int a,int b,E x){\n\t\treturn modify(a,b,x,0,0,sz);\n\t}\n\tT query(int a,int b,int k,int l,int r){\n\t\tpush(k,l,r);\n\t\tif(r<=a||b<=l)return ti;\n\t\tif(a<=l&&r<=b)return dat[k];\n\t\treturn f(query(a,b,k*2+1,l,(l+r)/2),query(a,b,k*2+2,(l+r)/2,r));\n\t}\n\tinline T query(int a,int b){\n\t\treturn query(a,b,0,0,sz);\n\t}\n};\n\nsigned main(){\n\tint ti=0;\n\tint ei=-1001001001;\n\tauto f=[&](int a,int b){return a+b;};\n\tauto g=[&](int a,int b,int l){\n\t\tif(b==ei)return a;\n\t\treturn b*l;\n\t};\n\tauto h=[&](int a,int b){\n\t\tif(b==ei)return a;\n\t\treturn b;\n\t};\n\tLazySegmentTree<int,int,decltype(f),decltype(g),decltype(h)>seg(ti,ei,f,g,h);\n\n\tint N,Q;\n\tscanf(\"%lld%lld\",&N,&Q);\n\tseg.build(vint(N,0));\n\twhile(Q--){\n\t\tint p,s,t,x;\n\t\tscanf(\"%lld%lld%lld\",&p,&s,&t);\n\t\tt++;\n\t\tif(p==0){\n\t\t\tscanf(\"%lld\",&x);\n\t\t\tseg.modify(s,t,x);\n\t\t}\n\t\telse{\n\t\t\tprintf(\"%lld\\n\",seg.query(s,t));\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <initializer_list>\n#include <math.h>\n#include <map>\n#include <random>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <queue>\n#include <vector>\n#include <type_traits>\n\n#define FOR(i, a, b) for(int (i) = (a); (i) < (b); ++(i))\n#define rFOR(i, a, b) for(int (i) = (b); (i) >= (a); --(i))\n#define REP(i, n) FOR(i, 0, n)\n#define rREP(i, n) rFOR(i, 0, (n-1))\n#define SORT(A) std::sort((A).begin(), (A).end())\n#define ALL(A) (A).begin(), (A).end()\n// 座標圧縮 (for vector) : ソートしてから使うのが一般的 ; SORT(A) => COORDINATE_COMPRESSION(A)\n#define COORDINATE_COMPRESSION(A) (A).erase(unique((A).begin(),(A).end()),(A).end())\n\nusing lli = long long int;\nusing pii = std::pair<int, int>;\n\n// グリッド上の縦横移動\nconstexpr std::array<std::pair<int, int>, 4> dxdy = {\n    std::pair<int, int>( 1,  0),\n    std::pair<int, int>(-1,  0),\n    std::pair<int, int>( 0,  1),\n    std::pair<int, int>( 0, -1)\n};\n\nvoid VintOut(std::vector<int>& A){\n    const int n = A.size();\n    if(n == 0){putchar('\\n'); return;}\n    printf(\"%d\", A[0]);\n    for(int i = 1; i < n; ++i) printf(\" %d\", A[i]);\n    putchar('\\n');\n}\nvoid VintOut(std::vector<long long int>& A){\n    const int n = A.size();\n    if(n == 0){ putchar('\\n'); return;}\n    printf(\"%lld\", A[0]);\n    for(int i = 1; i < n; ++i) printf(\" %lld\", A[i]);\n    putchar('\\n');\n}\n\ntemplate <typename T>\ninline bool chmin(T& a, T b){\n    if(b < a){ a = b; return true;}\n    return false;\n}\n\ntemplate <typename T>\ninline bool chmax(T& a, T b){\n    if(a < b){ a = b; return true;}\n    return false;\n}\n\ninline bool isIn(int x, int y, int H, int W){\n    return 0 <= x and x < H and 0 <= y and y < W;\n}\ninline bool bitUP(int state, int k){ return (state >> k) & 1; }\ninline bool bitUP(long long int state, int k){ return (state >> k) & 1;}\n\n// z-algorithm\ntemplate <class T> std::vector<int> z_algorithm(const T &str) {\n    const int n = str.size();\n    std::vector<int> resOfCP(n); resOfCP[0] = n;\n    int i = 1, j = 0;\n    while (i < n) {\n        while (i + j < n and str[j] == str[i + j]) ++j;\n        resOfCP[i] = j;\n        if (j == 0) { ++i; continue;}\n        int k = 1;\n        while (i + k < n and k + resOfCP[k] < j) resOfCP[i + k] = resOfCP[k], ++k;\n        i += k; j -= k;\n    }\n    return resOfCP;\n}\n\n\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n/*\ntemplate <typename element_t, typename operate_t>\nstruct Monoid_for_LazySegmentTree{\n    static constexpr element_t id_ele;\n    static constexpr operate_t id_ope;\n    virtual element_t queryE(element_t x, element_t y);\n    virtual element_t updateByOp(element_t x, operate_t op);\n    virtual operate_t updateOfOp(operate_t op1, operate_t op2);\n    virtual operate_t opeValueByRange(operate_t op, int len);\n};\n*/\n\nstruct M{\n    static const lli id_ele;\n    static const lli id_ope;\n    static lli queryE(lli x, lli y){return x + y;}\n    static lli updateByOp(lli x, lli op){return op == id_ope ? x : op;}\n    static lli updateOfOp(lli op1, lli op2){return op2 == id_ope ? op1 : op2;}\n    static lli opeValueByRange(lli op1, int len){return op1 == id_ope ? op1 : op1 * len;}\n};\nconst lli M::id_ele = 0;\nconst lli M::id_ope = 1e18 + 334 + 810 + 1919 + 114514;\n\n\n// 遅延伝搬セグメント木\ntemplate <typename element_t, typename operate_t, typename monoid_t>\nclass LazySegmentTree{\nprivate:\n    // データ群\n    size_t size_;      // データのサイズ : 2のべき乗\n    size_t height; // \"木の高さ\" : n = 2^height ≥ value.size\n    std::vector<element_t> data;   // データの値本体\n    std::vector<operate_t> lazy;   // 遅延評価の作用素\n    std::vector<unsigned int> len; // len[i] = data[i], lazy[i]の指す区間の幅\n\n    // 引数がサブタイプか判定する : virtualの関係でだめ\n    //static_assert(std::is_base_of<Monoid_for_LazySegmentTree<element_t, operate_t>, monoid_t>::value, \n    //              \"The third argument of LazySegmentTree must be a subtype of monoid_for_LazySegemnetTree\"\n    //             );\n\n    // lazy[k]の情報を子ノードに伝搬, data[k]の評価を行う\n    inline void eval(int k){\n        if(lazy[k] == monoid_t::id_ope) return;\n        if(k < size_){ // 2 * k + 1 < 2 * size_ : 配列内の参照か\n            lazy[2 * k]     = monoid_t::updateOfOp(lazy[2 * k],     lazy[k]);\n            lazy[2 * k + 1] = monoid_t::updateOfOp(lazy[2 * k + 1], lazy[k]);\n        }\n        data[k] = monoid_t::updateByOp(data[k], monoid_t::opeValueByRange(lazy[k], len[k]));\n        lazy[k] = monoid_t::id_ope;\n    }\n\n    // 親ノードからlazyの値を遅延伝搬評価をする (全体に広げる) | トップダウン(lazyの伝搬)\n    // -> 区間を完全平衡二分木とした時親から子ノードに向かって繋がっているノード全てにdataの評価, lazyの伝搬を行う\n    inline void evalFromTheRoot(int k){\n        for(int i = height; i > 0; --i) eval(k >> i);\n    }\n\n    // 子ノードから親ノードに向かってdataの値を計算する | ボトムアップ(dataの伝搬, 更新) | すでに伝搬はされていると仮定する\n    inline void computeDataToTheRoot(int k) {\n         while(k >>= 1) data[k] = monoid_t::queryE(reflect(2 * k), reflect(2 * k + 1));\n    }\n    \n    element_t reflect(int k){\n        if(lazy[k] == monoid_t::id_ope) return data[k];\n        return monoid_t::updateByOp(data[k], monoid_t::opeValueByRange(lazy[k], len[k]));\n    }\npublic:\n    // コンストラクタ based on size\n    LazySegmentTree(const size_t N){\n        size_ = 1; height = 0; while(size_ < N){ size_ *= 2; ++height; }\n        data.assign(2 * size_, monoid_t::id_ele);\n        lazy.assign(2 * size_, monoid_t::id_ope);\n        // 区間の幅を与える\n        len.resize( 2 * size_);\n        for(int level = 0; level <= height; ++level){\n            int length = size_ >> level; // 高さ level における幅\n            int rng    =   1   << level; // rng, rng + 1, ..., 2*rng - 1\n            for(int x = 0; x < rng; ++x) len[x + rng] = length;\n        }\n    }\n    // コンストラクタ based on size and value\n    LazySegmentTree(const size_t N, const element_t init_val){\n        size_ = 1; height = 0; while(size_ < N){ size_ *= 2; ++height; }\n        data.assign(2 * size_, monoid_t::id_ele);\n        lazy.assign(2 * size_, monoid_t::id_ope);\n         // あらかじめ data の値を更新しておく\n        for(int i = 0; i < N; ++i) data[i + size_] = init_val;\n        for(int i = size_ - 1; i >= 0; --i) data[i] = monoid_t::queryE(data[2 * i], data[2 * i + 1]);\n        // 区間の幅を与える\n        len.resize( 2 * size_);\n        for(int level = 0; level <= height; ++level){\n            int length = size_ >> level; // 高さ level における幅\n            int rng    =   1   << level; // rng, rng + 1, ..., 2*rng - 1\n            for(int x = 0; x < rng; ++x) len[x + rng] = length;\n        }\n    }\n    // コンストラクタ based on vector\n\tLazySegmentTree(const std::vector<element_t>& A) {\n        const size_t N = A.size();\n        size_ = 1; height = 0; while(size_ < N){ size_ *= 2; ++height; }\n        data.assign(2 * size_, monoid_t::id_ele);\n        lazy.assign(2 * size_, monoid_t::id_ope);\n        // あらかじめ data の値を更新しておく\n        for(int i = 0; i < N; ++i) data[i + size_] = A[i];\n        for(int i = size_ - 1; i >= 0; --i) data[i] = monoid_t::queryE(data[2 * i], data[2 * i + 1]);\n\t\t// 区間の幅を与える\n        len.resize( 2 * size_);\n        for(int level = 0; level <= height; ++level){\n            int length = size_ >> level; // 高さ level における幅\n            int rng    =   1   << level; // rng, rng + 1, ..., 2*rng - 1\n            for(int x = 0; x < rng; ++x) len[x + rng] = length;\n        }\n\t}\n    // 区間 [left, right) (0-indexed) に (遅延評価)作用素を与える\n    inline void update(int left, int right, const operate_t& op){\n        if(left >= right) return ;\n\n        // ボトムアップに伝搬を伝える\n        int l = left  + size_ ;    evalFromTheRoot(l);\n        int r = right + size_ - 1; evalFromTheRoot(r);\n\n        for(int ll = l, rr = r + 1; ll < rr; ll >>= 1, rr >>= 1){\n            if(ll & 1){ \n                lazy[ll] = monoid_t::updateOfOp(lazy[ll], op); // eval(ll);\n                ++ll;\n            }\n            if(rr & 1){ \n                --rr; \n                lazy[rr] = monoid_t::updateOfOp(lazy[rr], op); // eval(rr);\n            }\n        }\n        computeDataToTheRoot(l); computeDataToTheRoot(r);\n    }\n\n    // 区間 [left, right) (0-indexed) の値を求める\n    inline element_t query(int left, int right){\n\n        if(left >= right) return monoid_t::id_ele;\n        // ボトムアップに伝搬を伝える\n        int l = left  + size_ ;    evalFromTheRoot(l);\n        int r = right + size_ - 1; evalFromTheRoot(r);\n\n        element_t vl = monoid_t::id_ele, vr = monoid_t::id_ele;\n        for(int ll = l, rr = r + 1; ll < rr; ll >>= 1, rr >>= 1) {\n            if (ll & 1) {\n                vl = monoid_t::queryE(vl, \n                                     monoid_t::updateByOp(\n                                                data[ll], \n                                                monoid_t::opeValueByRange(lazy[ll], len[ll])\n                                                )\n                                    ); \n                ++ll;\n            }\n            if (rr & 1) {\n                --rr;\n                vr = monoid_t::queryE( monoid_t::updateByOp( \n                                                data[rr], \n                                                monoid_t::opeValueByRange(lazy[rr], len[rr])\n                                                ),\n                                       vr\n                                    ); \n            }\n        }\n        return monoid_t::queryE(vl, vr);\n    }\n};\n\n\n\n\n\n\nint main(void){\n    int n, q; scanf(\"%d%d\", &n, &q);\n    LazySegmentTree<lli, lli, M> L(n, 0);\n    while(q--){\n        char c; scanf(\"%*c%c\", &c);\n        if(c == '0'){\n            int s, t, x; scanf(\"%d%d%d\", &s, &t, &x); t++;\n            L.update(s, t, x);\n        }\n        else{\n            int s, t; scanf(\"%d%d\", &s, &t); t++;\n            printf(\"%lld\\n\", L.query(s, t));\n        }\n    }\n\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nclass LazySegmentTree\n{\n    int n;\n    using T1 = long long;\n    using T2 = long long;\n    T1 id1 = 0;\n    T2 id2 = -INT_MAX;\n    std::vector<T1> node; // sum\n    std::vector<T2> lazy; // update\n\n    // 遅延評価\n    void eval(int k, int l, int r)\n    {\n        // 遅延配列が空なら終了\n        if (lazy[k] == id2)\n            return;\n        // 遅延配列を適用\n        node[k] = lazy[k];\n        if (r - l > 1)\n        {\n            lazy[2 * k + 1] = lazy[k] / 2;\n            lazy[2 * k + 2] = lazy[k] / 2;\n        }\n        // 遅延配列初期化\n        lazy[k] = id2;\n    }\n\n  public:\n    LazySegmentTree(int _n)\n    {\n        int sz = _n;\n        n = 1;\n        while (n < sz)\n            n *= 2;\n        // 配列初期化\n        node.resize(2 * n - 1, id1);\n        lazy.resize(2 * n - 1, id2);\n    }\n    // 半開区間 [a, b) に対して値 val を反映させる\n    void update(int a, int b, T2 val, int l = 0, int r = -1, int k = 0)\n    {\n        if (r < 0)\n            r = n;\n        // ノード k で遅延評価\n        eval(k, l, r);\n        if (b <= l || r <= a)\n            return;\n        // 区間が被覆されている場合\n        if (a <= l && r <= b)\n        {\n            // 遅延配列更新, 評価\n            lazy[k] = (r - l) * val;\n            eval(k, l, r);\n        }\n        else\n        {\n            // 子ノードの値を評価し, 更新\n            int mid = (l + r) / 2;\n            update(a, b, val, l, mid, 2 * k + 1);\n            update(a, b, val, mid, r, 2 * k + 2);\n            node[k] = node[2 * k + 1] + node[2 * k + 2];\n        }\n    }\n\n    // 半開区間 [a, b) に対してクエリを投げる\n    T1 query(int a, int b, int l = 0, int r = -1, int k = 0)\n    {\n        if (r < 0)\n            r = n;\n        eval(k, l, r);\n        // 範囲外なら単位元返す\n        if (b <= l || r <= a)\n            return id1;\n        if (a <= l && r <= b)\n            return node[k];\n        int mid = (l + r) / 2;\n        T1 vl = query(a, b, l, mid, 2 * k + 1);\n        T1 vr = query(a, b, mid, r, 2 * k + 2);\n        return vl + vr;\n    }\n};\n\nusing namespace std;\n\nvoid solve_dsl_2_i()\n{\n    int n, q;\n    cin >> n >> q;\n    LazySegmentTree lst(n);\n    while (q--)\n    {\n        int type;\n        cin >> type;\n        if (type == 0)\n        {\n            int s, t, x;\n            cin >> s >> t >> x;\n            t++;\n            lst.update(s, t, x);\n        }\n        else\n        {\n            int s, t;\n            cin >> s >> t;\n            t++;\n            cout << lst.query(s, t) << endl;\n        }\n    }\n}\n\nint main()\n{\n    solve_dsl_2_i();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\n/*Starry Sky Tree*/\n/*Range Add Min(Max) Query*/\n/*区間加算、区間Min,区間Max*/\n\nclass RSUQ{\npublic: \n  \n  //遅延用の型  \n  struct T{\n    int type; //0 - empty   , 1 - update\n    int value;\n    T():type(0),value(0){}\n    T(int type,int value):type(type),value(value){}\n  };\n\n  //マージ可能な主データ型\n  struct D{\n    int value;\n    D():value(0){} /*適切な値にする!!!!!!*/\n    D(int value):value(value){}\n    bool operator < (D a)const {return value < a.value;} //merge用\n  };\n  \n  int n;\n  vector<D> dat;\n  vector<T> td;\n  D returnD = D(0); // 範囲外の時に返す値。\n  \n  RSUQ(){n=-1;}\n  RSUQ(int n_){\n    n=1;\n    while(n < n_) n *= 2;\n    td.resize(2*n-1,T());\n    dat.resize(2*n-1,D());\n  }\n  \n  inline D merge(D a,D b){return a.value + b.value;}\n  \n  void delay(int k,int len){\n    if(td[k].type==0) return;\n    int v = td[k].value;\n    td[k].type = 0;\n    td[k].value = 0;\n    \n    len /= 2;\n    int l = k*2+1,r = k*2+2;\n    dat[l].value = v * len; td[l].type = 1; td[l].value = v;\n    dat[r].value = v * len; td[r].type = 1; td[r].value = v;\n  }\n\n  D write(int k,int x, int len){\n    dat[k].value = x * len;\n    td[k].type = 1;\n    td[k].value = x;\n    return dat[k];\n  }\n  \n  //[a,b)の値をx変更　query(a,b,x)\n  D update(int a,int b,int x,bool flg=true,int k=0,int l=0,int r=-1){\n    if(r==-1) r=n, assert(a <= n && b <= n);\n    if(r <= a||b <= l) return flg? dat[k]:returnD;\n    if(a <= l && r <= b) return flg? write(k, x, r - l):dat[k];\n    \n    delay(k, r - l);\n    D vl = update(a,b,x,flg,k*2+1,l,(l+r)/2);\n    D vr = update(a,b,x,flg,k*2+2,(l+r)/2,r);\n    if(flg) dat[k] = merge(vl, vr);\n    return merge(vl, vr);\n  }\n  \n  //[a,b)の合計値を得る　find(a,b);\n  int find(int a,int b){\n    D res = update(a,b,0,false);\n    return res.value;\n  }\n};\n\n\nsigned main(){\n  int n,q;\n  cin>>n>>q;\n  \n  RSUQ rsuq(n);\n\n  while(q--){\n    int cmd;\n    cin>>cmd;\n    if(cmd == 0){\n      int s,t,x;\n      cin>>s>>t>>x;\n      rsuq.update(s,t+1,x);\n    }\n    if(cmd == 1){\n      int s,t;\n      cin>>s>>t;\n      cout<<rsuq.find(s,t+1)<<endl;\n    }\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\n#define sp ' '\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define nyan \"(=^･ω･^=)\"\n#define mkp make_pair\n#define mkt make_tuple\n#define lP pair<ll, ll>\n#define iP pair<int,int>\ntypedef long long ll;\nusing namespace std;\n\nint n, q, s, t, x, u, a[1 << 18], i;\niP b[1 << 18];\nbool f;\n\nvoid update(int k, int l, int r) {\n\tif (!(t < l || r <= s)) {\n\t\tif (s <= l&&r - 1 <= t) {\n\t\t\ta[k] = x*(r - l);\n\t\t\tb[k] = mkp(x, i);\n\t\t}\n\t\telse {\n\t\t\tif (b[k].second > b[k * 2].second) {\n\t\t\t\tb[k * 2] = b[k];\n\t\t\t\ta[k * 2] = b[k].first*(r - l) / 2;\n\t\t\t}\n\t\t\tif (b[k].second > b[k * 2 + 1].second) {\n\t\t\t\tb[k * 2 + 1] = b[k];\n\t\t\t\ta[k * 2 + 1] = b[k].first*(r - l) / 2;\n\t\t\t}\n\t\t\tupdate(k * 2, l, (l + r) / 2);\n\t\t\tupdate(k * 2 + 1, (l + r) / 2, r);\n\t\t\ta[k] = a[k * 2] + a[k * 2 + 1];\n\t\t}\n\t}\n}\nint getSum(int k,int l,int r){\n\tif (t < l || r <= s)return 0;\n\telse if (s <= l&&r - 1 <= t)\n\t\treturn a[k];\n\telse {\n\t\tif (b[k].second > b[k * 2].second) {\n\t\t\tb[k * 2] = b[k];\n\t\t\ta[k * 2] = b[k].first*(r - l) / 2;\n\t\t}\n\t\tif (b[k].second > b[k * 2 + 1].second) {\n\t\t\tb[k * 2 + 1] = b[k];\n\t\t\ta[k * 2 + 1] = b[k].first*(r - l) / 2;\n\t\t}\n\t\tint A = getSum(k * 2, l, (l + r) / 2) + getSum(k * 2 + 1, (l + r) / 2, r);\n\t\ta[k] = a[k * 2] + a[k * 2 + 1];\n\t\treturn A;\n\t}\n}\nint main(){\n\tcin >> n >> q;\n\tfor (u = 1; u < n; u *= 2);\n\tfor (i = 1; i != q + 1; ++i) {\n\t\tcin >> f >> s >> t;\n\t\tif (f)\n\t\t\tcout << getSum(1, 0, u) << endl;\n\t\telse {\n\t\t\tcin >> x;\n\t\t\tupdate(1, 0, u);\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define all(vec) vec.begin(), vec.end()\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nconstexpr ll INF = (1LL << 30) - 1LL;\nconstexpr ll LINF = (1LL << 60) - 1LL;\nconstexpr double eps = 1e-9;\nconstexpr ll MOD = 1000000007LL;\ntemplate <typename T>\nbool chmin(T& a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n};\ntemplate <typename T>\nbool chmax(T& a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n};\ntemplate <typename T>\nostream& operator<<(ostream& os, vector<T> v) {\n    for(int i = 0; i < v.size(); i++) {\n        os << v[i] << (i + 1 == v.size() ? \"\\n\" : \" \");\n    }\n    return os;\n}\ntemplate <typename T>\nvector<T> make_v(size_t a) {\n    return vector<T>(a);\n}\ntemplate <typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\ntemplate <typename T, typename V>\ntypename enable_if<is_class<T>::value == 0>::type fill_v(T& t, const V& v) {\n    t = v;\n}\ntemplate <typename T, typename V>\ntypename enable_if<is_class<T>::value != 0>::type fill_v(T& t, const V& v) {\n    for(auto& e : t) {\n        fill_v(e, v);\n    }\n};\ntemplate <class Monoid, class OperatorMonoid>\nstruct Segtree {\n    using T = typename Monoid::T;\n    using E = typename OperatorMonoid::E;\n    int n, h;\n    vector<T> dat;\n    vector<E> laz;\n    Segtree(int n_) {\n        n = 1, h = 0;\n        while(n < n_) {\n            n <<= 1;\n            ++h;\n        }\n        dat.resize(2 * n, Monoid::id());\n        laz.resize(2 * n, OperatorMonoid::id());\n    }\n    inline int len(int k) { return (n >> (int)log2(k)); }\n    inline T prop(int k) {\n        if(laz[k] == OperatorMonoid::id()) {\n            return dat[k];\n        }\n        dat[k] = OperatorMonoid::merge(dat[k], laz[k], len(k));\n        if(k < n) {\n            laz[k << 1] = OperatorMonoid::op(laz[k << 1], laz[k]);\n            laz[k << 1 | 1] = OperatorMonoid::op(laz[k << 1 | 1], laz[k]);\n        }\n        laz[k] = OperatorMonoid::id();\n        return dat[k];\n    }\n    inline void down(int k) {\n        for(int i = h; i > 0; i--) {\n            prop(k >> i);\n        }\n    }\n    inline void up(int k) {\n        while(k >>= 1) {\n            dat[k] = Monoid::op(prop(k << 1), prop(k << 1 | 1));\n        }\n    }\n    inline void update(int a, int b, const E& x) {  //[a,b]->[a,b)\n        int l = a + n, r = b + n;\n        down(l);\n        down(r);\n        for(++r; l < r; l >>= 1, r >>= 1) {\n            if(l & 1) {\n                laz[l] = OperatorMonoid::op(laz[l], x);\n                l++;\n            }\n            if(r & 1) {\n                --r;\n                laz[r] = OperatorMonoid::op(laz[r], x);\n            }\n        }\n        l = a + n, r = b + n;\n        up(l);\n        up(r);\n    }\n    inline T query(int a, int b) {  //[a,b]->[a,b)\n        int l = a + n, r = b + n;\n        down(l);\n        down(r);\n        T vl = Monoid::id(), vr = Monoid::id();\n        for(++r; l < r; l >>= 1, r >>= 1) {\n            if(l & 1) {\n                vl = Monoid::op(vl, prop(l++));\n            }\n            if(r & 1) {\n                vr = Monoid::op(prop(--r), vr);\n            }\n        }\n        return Monoid::op(vl, vr);\n    }\n};\ntemplate <class U>\nstruct RangeSum {\n    using T = U;\n    static T op(const T& a, const T& b) { return a + b; }\n    static constexpr T id() { return 0; }\n};\n\ntemplate <class V>\nstruct RangeUpd {\n    using E = V;\n    static E op(const E& a, const E& b) { return b; }\n    template <typename T>\n    static T merge(const T& a, const E& b, const ll& len) {\n        return b * len;\n    }\n    static constexpr E id() { return INF; }\n};\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, q;\n    cin >> n >> q;\n    Segtree<RangeSum<ll>, RangeUpd<ll>> seg(n);\n    while(q--) {\n        int t, l, r;\n        cin >> t >> l >> r;\n        if(t == 0) {\n            ll x;\n            cin >> x;\n            seg.update(l, r, x);\n        } else {\n            cout << seg.query(l, r) << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\nconst int INF = 1e9;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = { 0, 1, 0, -1 }, dx4 = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\n\n\ntemplate <typename T> class LazySegmentTree {\nprivate:\n    const int array_size;\n    int n;\n    std::vector<T> data, lazy;\n    std::vector<bool> lazyFlag;\n    function<T(T,T)> f; //要素に適用する演算\n    function<T(T,T)> g; //作用素の適用\n    function<T(T,T)> h; //作用素の合成\n    function<T(T,int)> p;\n    T unit;\n\npublic:\n    enum Mode {\n        RangeMinimumQuery,\n        RangeMaximumQuery,\n        RangeSummationQuery,\n    };\n\n    enum UpdateMode {\n        Update,\n        Add,\n    };\n\n    LazySegmentTree(const std::vector<LL> &v, Mode mode, UpdateMode updateMode) : array_size(v.size()) {\n        if (mode == RangeMinimumQuery) {\n            unit = INT_MAX;\n            f = [](T a, T b) { return std::min(a, b); };\n\n            if (updateMode == Update) {\n                g = [](T a, T b) { return b; };\n                h = g;\n                p = [](T a, int len) { return a; };\n            }\n            else if (updateMode == Add) {\n                g = [](T a, T b) { return a + b; };\n                h = g;\n                p = [](T a, int len) { return a; };\n            }\n        }\n        else if (mode == RangeMaximumQuery) {\n            unit = -INT_MAX;\n            f = [](T a, T b) { return std::max(a, b); };\n            if (updateMode == Update) {\n                g = [](T a, T b) { return b; };\n                h = g;\n                p = [](T a, int len) { return a; };\n            }\n            else if (updateMode == Add) {\n                g = [](T a, T b) { return a + b; };\n                h = g;\n                p = [](T a, int len) { return a; };\n            }\n        }\n        else if (mode == RangeSummationQuery) {\n            unit = 0;\n            f = [](T a, T b) { return a + b; };\n\n            if (updateMode == Update) {\n                g = [](T a, T b) { return b == INF ? a : b;};\n                h = g;\n                p = [](T a, int len) {return a == INF ? a : a * len;};\n            }\n            else if (updateMode == Add) {\n\n            }\n        }\n        else {\n            assert(false);\n        }\n\n        n = 1;\n        while (n < array_size) { n *= 2; }\n        data.resize(2 * n - 1, unit);\n        lazy.resize(2 * n - 1, INF);\n        lazyFlag.resize(2 * n - 1, false);\n\n        for (int i = 0; i < array_size; ++i) {\n            data[i + n - 1] = v[i];\n        }\n        for (int i = n - 2; i >= 0; i--) {\n            data[i] = f(data[i * 2 + 1], data[i * 2 + 2]);\n        }\n    }\n\n    // array[idx]\n    // log(N)\n    T access(int idx) {\n        return query(idx, idx + 1, 0, 0, n);\n    }\n\n    // array[idx] += x\n    // log(N)\n    void update(int idx, T x) {\n        update(idx, idx + 1, x);\n    }\n\n    // array[left, right) += x\n    // log(N)\n    void update(int left, int right, T x) {\n        assert(0 <= left and left < right and right <= array_size);\n        update(left, right, x, 0, 0, n);\n    }\n\n    // op(array[a, b))\n    // log(N)\n    T query(int left, int right) {\n        return query(left, right, 0, 0, n);\n    }\n\nprivate:\n    T update(int a, int b, T x, int k, int l, int r) {\n        propagate(k, r - l);\n\n        // 範囲外\n        if (b <= l or r <= a) {\n            return data[k];\n        }\n        // 完全に含む\n        else if (a <= l and r <= b) {\n            lazy[k] = h(lazy[k], x);\n            lazyFlag[k] = true;\n            propagate(k, r - l);\n            return g(data[k], p(lazy[k], r - l));\n        }\n        // 一部含む\n        else {\n            T lv = update(a, b, x, 2 * k + 1, l, (l + r) / 2);    // 左の子\n            T rv = update(a, b, x, 2 * k + 2, (l + r) / 2, r);    // 右の子\n            return data[k] = f(lv, rv);\n        }\n    }\n\n    // [a, b)の目的値をノードk（区間[l, r]）から検索\n    T query(int a, int b, int k, int l, int r) {\n        propagate(k, r - l);\n\n        // 範囲外\n        if (b <= l or r <= a) {\n            return unit;\n        }\n        // 完全に含む\n        else if (a <= l && r <= b) {\n            return data[k];\n        }\n        // 一部含む\n        else {\n            T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);    // 左の子\n            T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);    // 右の子\n            return f(vl, vr);\n        }\n    }\n\n    void propagate(const int k, const int len) {\n        if (not lazyFlag[k]) {\n            return;\n        }\n        if (lazy[k] == INF) {\n            return;\n        }\n\n        if (len > 1) {\n            lazy[k * 2 + 1] = h(lazy[k * 2 + 1], lazy[k]);\n            lazyFlag[2 * k + 1] = true;\n            lazy[k * 2 + 2] = h(lazy[k * 2 + 2], lazy[k]);\n            lazyFlag[2 * k + 2] = true;\n        }\n        data[k] = g(data[k], p(lazy[k], len));\n        lazy[k] = INF;\n        lazyFlag[k] = false;\n    }\n};\n\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, Q;\n    cin >> N >> Q;\n\n    vector<LL> v(N + 1, 0);\n\n    LazySegmentTree<LL> lst(v, LazySegmentTree<LL>::Mode::RangeSummationQuery, LazySegmentTree<LL>::UpdateMode::Update);\n\n    FOR(_, 0, Q) {\n        int query, s, t, x, i;\n        cin >> query;\n        if (query == 0) {\n            cin >> s >> t >> x;\n            lst.update(s, t + 1, x);\n        }\n        else {\n            cin >> s >> t;\n            print(lst.query(s, t + 1));\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//BEGIN CUT HERE\ntemplate <typename T,typename E>\nstruct SegmentTree{\n  using F = function<T(T,T)>;\n  using G = function<T(T,E)>;\n  using H = function<E(E,E)>;\n  using P = function<E(E,size_t)>;\n  int n;\n  F f;\n  G g;\n  H h;\n  T ti;\n  E ei;\n  P p;\n  vector<T> dat;\n  vector<E> laz;\n  SegmentTree(int n_,F f,G g,H h,T ti,E ei,\n\t      P p=[](E a,size_t b){return a;}):\n    f(f),g(g),h(h),ti(ti),ei(ei),p(p){\n    init(n_);\n  }\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.assign(2*n-1,ti);\n    laz.assign(2*n-1,ei);\n  }\n  void build(int n_, vector<T> v){\n    for(int i=0;i<n_;i++) dat[i+n-1]=v[i];\n    for(int i=n-2;i>=0;i--)\n      dat[i]=f(dat[i*2+1],dat[i*2+2]);\n  }\n  inline void eval(int len,int k){\n    if(laz[k]==ei) return;\n    if(k*2+1<n*2-1){\n      laz[k*2+1]=h(laz[k*2+1],laz[k]);\n      laz[k*2+2]=h(laz[k*2+2],laz[k]);\n    }\n    dat[k]=g(dat[k],p(laz[k],len));\n    laz[k]=ei;\n  }\n  T update(int a,int b,E x,int k,int l,int r){\n    eval(r-l,k);\n    if(r<=a||b<=l) return dat[k];\n    if(a<=l&&r<=b){\n      laz[k]=h(laz[k],x);\n      return g(dat[k],p(laz[k],r-l));\n    }\n    return dat[k]=f(update(a,b,x,k*2+1,l,(l+r)/2),\n\t\t    update(a,b,x,k*2+2,(l+r)/2,r));\n  }\n  T update(int a,int b,E x){\n    return update(a,b,x,0,0,n);\n  }\n  T query(int a,int b,int k,int l,int r){\n    eval(r-l,k);\n    if(r<=a||b<=l) return ti;\n    if(a<=l&&r<=b) return dat[k];\n    T vl=query(a,b,k*2+1,l,(l+r)/2);\n    T vr=query(a,b,k*2+2,(l+r)/2,r);\n    return f(vl,vr);\n  }\n  T query(int a,int b){\n    return query(a,b,0,0,n);\n  }\n  void update(int k,T x){\n    query(k,k+1);//evaluate\n    k+=n-1;\n    dat[k]=x;\n    while(k){\n      k=(k-1)/2;\n      dat[k]=f(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n};\n//END CUT HERE\nsigned main(){\n  int n,q;\n  cin>>n>>q;\n  SegmentTree<int,int> ch(n,\n\t\t\t  [](int a,int b){return a+b;},\n\t\t\t  [](int a,int b){return b;},\n\t\t\t  [](int a,int b){return a+b;},\n\t\t\t  0,0,\n\t\t\t  [](int a,int b){return a*b;});\n  ch.build(n,vector<int>(n,0));\n  for(int i=0;i<q;i++){\n    int c,s,t,x;\n    cin>>c;\n    if(c){\n      cin>>s>>t;\n      cout<<ch.query(s-1,t)<<endl;\n    }else{\n      cin>>s>>t>>x;\n      ch.update(s-1,t,x);\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ld> pld;\ntypedef pair<pii, int> ppiii;\ntypedef pair<pii, ll> ppiil;\ntypedef pair<pll, ll> pplll;\ntypedef pair<pli, int> pplii;\ntypedef vector<vector<ll>> vvl;\ntypedef vector<vector<int>> vvi;\ntypedef vector<vector<pll>> vvpll;\n#define rep(i, a, b) for (ll i=(a); i<(b); i++)\n#define rrep(i, a, b) for (ll i=(a); i>(b); i--)\n#define pb push_back\n#define tostr to_string\n#define mkp make_pair\nconst ll INF = 1e18;\nconst ll MOD = 1e9 + 7;\n\nvoid print(ld out) { cout << fixed << setprecision(12) << out << '\\n'; }\ntemplate<typename T> void print(T out) { cout << out << '\\n'; }\ntemplate<typename T1, typename T2> void print(pair<T1, T2> out) { cout << out.first << ' ' << out.second << '\\n'; }\ntemplate<typename T> void print(vector<T> A) { rep(i, 0, A.size()) { cout << A[i]; cout << (i == A.size()-1 ? '\\n' : ' '); } }\ntemplate<typename T> void print(set<T> S) { vector<T> A(S.begin(), S.end()); print(A); }\n\ntemplate<typename T> inline bool chmax(T &x, T y) { return (y > x) ? x = y, true : false; }\ntemplate<typename T> inline bool chmin(T &x, T y) { return (y < x) ? x = y, true : false; }\n\nll sum(vector<ll> A) { ll res = 0; for (ll a: A) res += a; return res; }\nll max(vector<ll> A) { ll res = -INF; for (ll a: A) chmax(res, a); return res; }\nll min(vector<ll> A) { ll res = INF; for (ll a: A) chmin(res, a); return res; }\n\nll toint(string s) { ll res = 0; for (char c : s) { res *= 10; res += (c - '0'); } return res; }\nint toint(char c) { return c - '0'; }\nchar tochar(int i) { return '0' + i; }\n\ninline ll pow(int x, ll n) { ll res = 1; rep(_, 0, n) res *= x; return res; }\ninline ll pow(ll x, ll n, int mod) { ll res = 1; while (n > 0) { if (n & 1) { res = (res * x) % mod; } x = (x * x) % mod; n >>= 1; } return res; }\n\ninline ll floor(ll a, ll b) { if (a < 0) { return (a-b+1) / b; } else { return a / b; } }\ninline ll ceil(ll a, ll b) { if (a >= 0) { return (a+b-1) / b; } else { return a / b; } }\n\nint popcount(ll S) { return __builtin_popcountll(S); }\nll gcd(ll a, ll b) { return __gcd(a, b); }\n\ntemplate <typename T,typename E>\nstruct SegmentTree{\n    typedef function<T(T,T)> F;\n    typedef function<T(T,E)> G;\n    typedef function<E(E,E)> H;\n    typedef function<E(E,int)> P;\n    int n;\n    F f;\n    G g;\n    H h;\n    P p;\n    T d1;\n    E d0;\n    vector<T> dat;\n    vector<E> laz;\n    SegmentTree(int n_,F f,G g,H h,T d1,E d0,\n            vector<T> v=vector<T>(),P p=[](E a,int b){return a;}):\n        f(f),g(g),h(h),d1(d1),d0(d0),p(p){\n        init(n_);\n        if(n_==(int)v.size()) build(n_,v);\n    }\n    void init(int n_){\n        n=1;\n        while(n<n_) n*=2;\n        dat.clear();\n        dat.resize(2*n-1,d1);\n        laz.clear();\n        laz.resize(2*n-1,d0);\n    }\n    void build(int n_, vector<T> v){\n        for(int i=0;i<n_;i++) dat[i+n-1]=v[i];\n        for(int i=n-2;i>=0;i--)\n        dat[i]=f(dat[i*2+1],dat[i*2+2]);\n    }\n    inline void eval(int len,int k){\n        if(laz[k]==d0) return;\n        if(k*2+1<n*2-1){\n        laz[k*2+1]=h(laz[k*2+1],laz[k]);\n        laz[k*2+2]=h(laz[k*2+2],laz[k]);\n        }\n        dat[k]=g(dat[k],p(laz[k],len));\n        laz[k]=d0;\n    }\n    T update(int a,int b,E x,int k,int l,int r){\n        eval(r-l,k);\n        if(r<=a||b<=l) return dat[k];\n        if(a<=l&&r<=b){\n        laz[k]=h(laz[k],x);\n        return g(dat[k],p(laz[k],r-l));\n        }\n        return dat[k]=f(update(a,b,x,k*2+1,l,(l+r)/2),\n                update(a,b,x,k*2+2,(l+r)/2,r));\n    }\n    T update(int a,int b,E x){\n        return update(a,b,x,0,0,n);\n    }\n    T query(int a,int b,int k,int l,int r){\n        eval(r-l,k);\n        if(r<=a||b<=l) return d1;\n        if(a<=l&&r<=b) return dat[k];\n        T vl=query(a,b,k*2+1,l,(l+r)/2);\n        T vr=query(a,b,k*2+2,(l+r)/2,r);\n        return f(vl,vr);\n    }\n    T query(int a,int b){\n        return query(a,b,0,0,n);\n    }\n};\n\nll N, Q;\n// 区間更新・区間合計\nauto f = [](ll a, ll b) -> ll { return a + b; };\nauto g = [](ll a, ll b) -> ll { (void)a; return b; };\nauto p = [](ll a, ll b) -> ll { return a * b; };\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> N >> Q;\n    SegmentTree<ll, ll> seg(N, f, g, g, 0, INT_MAX, vector<ll>(N, 0), p);\n\n    ll op, s, t, x;\n    rep(i, 0, Q) {\n        cin >> op;\n        if (op == 0) {\n            cin >> s >> t >> x;\n            seg.update(s, t+1, x);\n        } else {\n            cin >> s >> t;\n            print(seg.query(s, t+1));\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\n/*Starry Sky Tree*/\n/*Range Add Min(Max) Query*/\n/*区間加算、区間Min,区間Max*/\n\nclass RSUQ{\npublic: \n  \n  //遅延用の型  \n  struct T{\n    int type; //0 - empty   , 1 - update\n    int value;\n    T():type(0),value(0){}\n    T(int type,int value):type(type),value(value){}\n  };\n\n  //マージ可能な主データ型\n  struct D{\n    int value;\n    D():value(0){} /*適切な値にする!!!!!!*/\n    D(int value):value(value){}\n    bool operator < (D a)const {return value < a.value;} //merge用\n  };\n  \n  int n;\n  vector<D> dat;\n  vector<T> td;\n  D returnD = D(0); // 範囲外の時に返す値。\n  \n  RSUQ(){n=-1;}\n  RSUQ(int n_){\n    n=1;\n    while(n<n_)n*=2;\n    td.resize(2*n-1,T());\n    dat.resize(2*n-1,D());\n  }\n  \n  D merge(D a,D b){return a.value + b.value;}\n  \n  void delay(int k,int len){\n    if(td[k].type==0) return;\n    int v = td[k].value;\n    td[k].type = 0;\n    td[k].value = 0;\n    \n    len /= 2;\n    int l = k*2+1,r = k*2+2;\n    dat[l].value = v * len; td[l].type = 1; td[l].value = v;\n    dat[r].value = v * len; td[r].type = 1; td[r].value = v;\n  }\n\n  D update(int k,int x, int len){\n    dat[k].value = x * len;\n    td[k].type = 1;\n    td[k].value = x;\n    return dat[k];\n  }\n  \n  //[a,b)の値をx変更　add(a,b,x)\n  D query(int a,int b,int x,bool flg=true,int k=0,int l=0,int r=-1){\n    if(r==-1) r=n, assert(a <= n && b <= n);\n    if(r<=a||b<=l) return flg? dat[k]:returnD;\n    if(a<=l&&r<=b) return flg? update(k, x, r - l):dat[k];\n    \n    delay(k, r - l);\n    D vl = query(a,b,x,flg,k*2+1,l,(l+r)/2);\n    D vr = query(a,b,x,flg,k*2+2,(l+r)/2,r);\n    if(flg) dat[k] = merge(vl,vr);\n    return merge(vl,vr);\n  }\n  \n  //[a,b)の合計値を得る　find(a,b);\n  int find(int a,int b){\n    D res = query(a,b,0,false);\n    return res.value;\n  }\n};\n\n\nsigned main(){\n  int n,q;\n  cin>>n>>q;\n  \n  RSUQ rsuq(n);\n  while(q--){\n    int cmd;\n    cin>>cmd;\n    if(cmd == 0){\n      int s,t,x;\n      cin>>s>>t>>x;\n      rsuq.query(s,t+1,x);\n    }\n    if(cmd == 1){\n      int s,t;\n      cin>>s>>t;\n      cout<<rsuq.find(s,t+1)<<endl;\n    }\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  math2do\n *    created: 28.02.2020 20:21:13\n**/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass segtree {\n public:\n  struct node {\n    // don't forget to set default value (used for leaves)\n    // not necessarily neutral element!\n\n    int val = 0;\n    int sum = 0;\n    bool mark = false;\n\n    void apply(int l, int h, int v) {\n      val = v;\n      sum = (h - l + 1) * v;\n      mark = true;\n    }\n  };\n \n  node unite(const node &a, const node &b) const {\n    node res;\n    res.sum = a.sum + b.sum;\n    return res;\n  }\n \n  inline void push(int i, int l, int h) {\n    int m = (l + h) >> 1;\n    // push from i into left child and right child\n    if (tree[i].mark) {\n      tree[i << 1].apply(l, m, tree[i].val);\n      tree[(i << 1) + 1].apply(m + 1, h, tree[i].val);\n      tree[i].mark = false;\n    }\n  }\n \n  inline void pull(int i) {\n    tree[i] = unite(tree[i << 1], tree[(i << 1) + 1]);\n  }\n \n  int n;\n  vector<node> tree;\n \n  void build(int i, int l, int h) {\n    if (l == h) {\n      return;\n    }\n    int m = (l + h) >> 1;\n    build(i << 1, l, m);\n    build((i << 1) + 1, m + 1, h);\n    pull(i);\n  }\n \n  template <typename M>\n  void build(int i, int l, int h, const vector<M> &v) {\n    if (l == h) {\n      tree[i].apply(l, h, v[l]);\n      return;\n    }\n    int m = (l + h) >> 1;\n    build(i << 1, l, m, v);\n    build((i << 1) + 1, m + 1, h, v);\n    pull(i);\n  }\n \n  node get(int i, int l, int h, int ql, int qh) {\n    if (ql <= l && h <= qh) {\n      return tree[i];\n    }\n    int m = (l + h) >> 1;\n    push(i, l, h);\n    node res{};\n    if (qh <= m) {\n      res = get(i << 1, l, m, ql, qh);\n    } else {\n      if (ql > m) {\n        res = get((i << 1) + 1, m + 1, h, ql, qh);\n      } else {\n        res = unite(get(i << 1, l, m, ql, qh), get((i << 1) + 1, m + 1, h, ql, qh));\n      }\n    }\n    pull(i);\n    return res;\n  }\n \n  template <typename... M>\n  void modify(int i, int l, int h, int ql, int qh, const M&... v) {\n    if (ql <= l && h <= qh) {\n      tree[i].apply(l, h, v...);\n      return;\n    }\n    int m = (l + h) >> 1;\n    push(i, l, h);\n    if (ql <= m) {\n      modify(i << 1, l, m, ql, qh, v...);\n    }\n    if (qh > m) {\n      modify((i << 1) + 1, m + 1, h, ql, qh, v...);\n    }\n    pull(i);\n  }\n \n  int find_first_knowingly(int i, int l, int h, const function<bool(const node&)> &f) {\n    if (l == h) {\n      return l;\n    }\n    push(i, l, h);\n    int m = (l + h) >> 1;\n    int res;\n    if (f(tree[i << 1])) {\n      res = find_first_knowingly(i << 1, l, m, f);\n    } else {\n      res = find_first_knowingly((i << 1) + 1, m + 1, h, f);\n    }\n    pull(i);\n    return res;\n  }\n \n  int find_first(int i, int l, int h, int ql, int qh, const function<bool(const node&)> &f) {\n    if (ql <= l && h <= qh) {\n      if (!f(tree[i])) {\n        return -1;\n      }\n      return find_first_knowingly(i, l, h, f);\n    }\n    push(i, l, h);\n    int m = (l + h) >> 1;\n    int res = -1;\n    if (ql <= m) {\n      res = find_first(i << 1, l, m, ql, qh, f);\n    }\n    if (qh > m && res == -1) {\n      res = find_first((i << 1) + 1, m + 1, h, ql, qh, f);\n    }\n    pull(i);\n    return res;\n  }\n \n  int find_last_knowingly(int i, int l, int h, const function<bool(const node&)> &f) {\n    if (l == h) {\n      return l;\n    }\n    push(i, l, h);\n    int m = (l + h) >> 1;\n    int res;\n    if (f(tree[(i << 1) + 1])) {\n      res = find_last_knowingly((i << 1) + 1, m + 1, h, f);\n    } else {\n      res = find_last_knowingly(i << 1, l, m, f);\n    }\n    pull(i);\n    return res;\n  }\n \n  int find_last(int i, int l, int h, int ql, int qh, const function<bool(const node&)> &f) {\n    if (ql <= l && h <= qh) {\n      if (!f(tree[i])) {\n        return -1;\n      }\n      return find_last_knowingly(i, l, h, f);\n    }\n    push(i, l, h);\n    int m = (l + h) >> 1;\n    int res = -1;\n    if (qh > m) {\n      res = find_last((i << 1) + 1, m + 1, h, ql, qh, f);\n    }\n    if (ql <= m && res == -1) {\n      res = find_last(i << 1, l, m, ql, qh, f);\n    }\n    pull(i);\n    return res;\n  }\n \n  segtree(int _n) : n(_n) {\n    assert(n > 0);\n    tree.resize(4 * n);\n    build(1, 0, n - 1);\n  }\n \n  template <typename M>\n  segtree(const vector<M> &v) {\n    n = v.size();\n    assert(n > 0);\n    tree.resize(4 * n);\n    build(1, 0, n - 1, v);\n  }\n \n  node get(int ql, int qh) {\n    assert(0 <= ql && ql <= qh && qh <= n - 1);\n    return get(1, 0, n - 1, ql, qh);\n  }\n \n  node get(int p) {\n    assert(0 <= p && p <= n - 1);\n    return get(1, 0, n - 1, p, p);\n  }\n \n  template <typename... M>\n  void modify(int ql, int qh, const M&... v) {\n    assert(0 <= ql && ql <= qh && qh <= n - 1);\n    modify(1, 0, n - 1, ql, qh, v...);\n  }\n \n  // find_first and find_last call all FALSE elements\n  // to the left (right) of the sought position exactly once\n \n  int find_first(int ql, int qh, const function<bool(const node&)> &f) {\n    assert(0 <= ql && ql <= qh && qh <= n - 1);\n    return find_first(1, 0, n - 1, ql, qh, f);\n  }\n \n  int find_last(int ql, int qh, const function<bool(const node&)> &f) {\n    assert(0 <= ql && ql <= qh && qh <= n - 1);\n    return find_last(1, 0, n - 1, ql, qh, f);\n  }\n};\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n, q;\n  cin >> n >> q;\n  segtree st(n);\n  while (q--) {\n    int t;\n    cin >> t;\n    if (t == 0) {\n      int x, y, v;\n      cin >> x >> y >> v;\n      st.modify(x, y, v);\n    } else {\n      int x, y;\n      cin >> x >> y;\n      auto ans = st.get(x, y);\n      cout << ans.sum << '\\n';\n    } \n  } \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<class T, class Func = function<T(T,T)>>\nstruct foldMonoid{\n    T e;\n    const Func f;\n    foldMonoid(T e_, const Func f_) : e(e_),f(f_){};\n};\n\ntemplate<class T, class Func = function<T(T,T)>>\nstruct ActionMonoid{\n    T e;\n    const Func g,h,p;\n    ActionMonoid(T e_,const Func g_, const Func h_, const Func p_) : e(e_),g(g_), h(h_), p(p_){};\n};\n/*\n       g : T × E -> T s.t apply E to T\n       h : E × E -> merge E and E\n       p : E × N -> p(a,b):= g(a,a,......a ),\n                               |__________|\n                                    b\n*/\ntemplate<class T, class Func = function<T(T,T)>>\nclass LazySegtree{\nprivate:\n    const size_t N;\n    const ActionMonoid<T> action_monoid;\n    const foldMonoid<T> fold_monoid;\n    size_t offset;\n    vector<T>obj, lazy;\n    Func action_updater, lazy_updater;\n    /* re-size vectors capacity */\n    size_t bufsize(size_t num) {\n        int i = 1;\n        for (; (int) num + 1 > i; i <<= 1);\n        offset = i - 1;\n        return (i << 1) - 1;\n    }\n    /* update k-node*/\n    void flush(int k, int l, int r){\n        if(lazy[k] == action_monoid.e){\n            // There is no vlaue to propagate\n        } else {\n            obj[k] = action_monoid.g(obj[k],action_monoid.p(lazy[k],r - l));\n            // if(r - l <= 1) -> least\n            if(r - l > 1) {\n                lazy[2 * k + 1] = action_monoid.h( lazy[2 * k + 1],lazy[k]);\n                lazy[2 * k + 2] = action_monoid.h( lazy[2 * k + 2],lazy[k]);\n            }\n            lazy[k] = action_monoid.e;\n        }\n    }\n    void action(int a, int b, T val, int k, int l, int r){\n        if (r < 0) r = (int)offset + 1;\n        flush(k,l,r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b){\n            // perfectly coverd range\n            // TODO := why f???\n            lazy[k] = action_monoid.h(lazy[k], val);\n            flush(k, l, r);\n        } else {\n            action(a, b, val, 2 * k + 1, l, (l+r)/2);\n            action(a, b, val, 2 * k + 2, (l+r)/2, r);\n            obj[k] = fold_monoid.f(obj[2 * k + 1],obj[2 * k + 2]);\n        }\n    }\n    T query(int a, int b, int k, int l, int r) {\n        flush(k,l,r);\n        if (r <= a || b <= l)return fold_monoid.e;\n        if (a <= l && r <= b)return obj[k];\n        else return fold_monoid.f(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n    }\npublic:\n    void action(int l,int r, T val){\n        action(l,r,val,0,0,-1);\n    }\n    T query(int a, int b) {//[a,b)\n        return query(a, b, 0, 0, (int)offset + 1);\n    }\n    \n    LazySegtree(size_t treesize_,T init_, foldMonoid<T>foldM, ActionMonoid<T>ActionM)\n    : N(treesize_),fold_monoid(foldM), action_monoid(ActionM)\n    {\n        obj  = vector<T>(bufsize(N), init_);\n        lazy = vector<T>(bufsize(N), action_monoid.e);\n        \n    }\n    \n};\nauto Add = [](Int a, Int b ) {return a + b;};\nauto Mul = [](Int a, Int b ) {return a * b;};\nauto g = [](int a, int b){return b;};\nInt e = 0LL;\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n; cin >> n;\n    int q; cin >> q;\n    ActionMonoid<Int>act(-10000000,g,g,Mul);\n    foldMonoid<Int>fm(e,Add);\n    LazySegtree<Int>lsgt(n,e,fm,act);\n    for(int i = 0; i < q; ++i){\n        int Q; cin >> Q;\n        if(Q == 1){\n            int s,t; cin >> s >> t;\n            ++t;\n            cout << lsgt.query(s,t) << endl;\n        } else {\n            int s,t,x; cin >> s >> t >> x;\n            ++t;\n            lsgt.action(s,t,(Int)x);\n        }\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <random>\n#include <regex>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/timeb.h>\n#include <vector>\n\nusing namespace std;\n\n#define repr(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) repr(i, 0, n)\n#define reprrev(i, a, b) for (int i = (int)(b)-1; i >= (int)(a); i--)\n#define reprev(i, n) reprrev(i, 0, n)\n#define repi(itr, ds) for (auto itr = ds.begin(); itr != ds.end(); itr++)\n#define chmin(mi, val) mi = min(mi, val)\n#define chmax(ma, val) ma = max(ma, val)\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define mp make_pair\n#define mt make_tuple\n#define INF 1050000000\n#define INFR INT_MAX\n#define INFL (long long)(4e18)\n#define INFLR LLONG_MAX\n#define EPS (1e-10)\n#define MOD 1000000007\n//#define MOD 998244353\n#define PI 3.141592653589793238\n#define RMAX 4294967295\n\ntypedef long long ll;\ntypedef pair< int, int > Pi;\ntypedef pair< ll, ll > Pll;\ntypedef pair< double, double > Pd;\ntypedef vector< int > vi;\ntypedef vector< ll > vll;\ntypedef vector< bool > vb;\ntypedef vector< char > vc;\ntypedef vector< string > vs;\ntypedef vector< double > vd;\ntypedef vector< Pi > vPi;\ntypedef vector< Pll > vPll;\ntypedef vector< Pd > vPd;\ntypedef vector< vector< int > > vvi;\ntypedef vector< vector< bool > > vvb;\ntypedef vector< vector< ll > > vvll;\ntypedef vector< vector< char > > vvc;\ntypedef vector< vector< string > > vvs;\ntypedef vector< vector< double > > vvd;\ntypedef vector< vector< Pi > > vvPi;\ntypedef vector< vector< vector< int > > > vvvi;\ntypedef vector< vector< vector< ll > > > vvvll;\ntypedef vector< vector< vector< Pi > > > vvvPi;\ntypedef vector< vector< vector< vector< Pi > > > > vvvvPi;\ntypedef priority_queue< int, vector< int >, greater< int > > pqli;\ntypedef priority_queue< ll, vector< ll >, greater< ll > > pqlll;\ntypedef priority_queue< Pi, vector< Pi >, greater< Pi > > pqlP;\ntemplate < class T >\nusing vec = vector< T >;\ntemplate < class T >\nusing pql = priority_queue< T, vector< T >, greater< T > >;\n\n// vvvvvvvvvvvvvvvvvvvvvvv debug output vvvvvvvvvvvvvvvvvvvvvvv\n// vector\ntemplate < typename T >\nistream &operator>>(istream &is, vector< T > &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\n// pair\ntemplate < typename T, typename U >\nostream &operator<<(ostream &os, pair< T, U > &pair_var) {\n    os << \"(\" << pair_var.first << \",\" << pair_var.second << \")\";\n    return os;\n}\n// pair\ntemplate < typename T, typename U >\nostream &operator<<(ostream &os, const pair< T, U > &pair_var) {\n    os << \"(\" << pair_var.first << \",\" << pair_var.second << \")\";\n    return os;\n}\n// vector\ntemplate < typename T >\nostream &operator<<(ostream &os, const vector< T > &vec) {\n    os << \"{\";\n    for (int i = 0; i < vec.size(); i++) {\n        os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \");\n    }\n    os << \"}\";\n    return os;\n}\n// map\ntemplate < typename T, typename U >\nostream &operator<<(ostream &os, map< T, U > &map_var) {\n    os << \"{\";\n    repi(itr, map_var) {\n        os << \"(\" << itr->first << \",\" << itr->second << \")\";\n        itr++;\n        if (itr == map_var.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n// set\ntemplate < typename T >\nostream &operator<<(ostream &os, set< T > &set_var) {\n    os << \"{\";\n    repi(itr, set_var) {\n        os << \"  \" << *itr << endl;\n        itr++;\n        if (itr == set_var.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n\n#define DUMPOUT cerr\n\nvoid dump_func() {\n    DUMPOUT << endl;\n}\ntemplate < class Head, class... Tail >\nvoid dump_func(Head &&head, Tail &&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) > 0) {\n        DUMPOUT << \", \";\n    }\n    dump_func(std::move(tail)...);\n}\n#ifdef DEBUG_\n#define DEB\n#define dump(...)                                                              \\\n    DUMPOUT << \"  \" << string(#__VA_ARGS__) << \": \"                            \\\n            << \"[\" << to_string(__LINE__) << \":\" << __FUNCTION__ << \"]\"        \\\n            << endl                                                            \\\n            << \"    \",                                                         \\\n        dump_func(__VA_ARGS__)\n#else\n#define DEB if (false)\n#define dump(...)\n#endif\n\n// ^^^^^^^^^^^^^^^^^^^^^^^ debug output ^^^^^^^^^^^^^^^^^^^^^^^\n\nstring YN(bool y, int id = 0) {\n    if (id) cout << id;\n    return (y ? \"YES\" : \"NO\");\n}\nstring yn(bool y, int id = 0) {\n    if (id) cout << id;\n    return (y ? \"Yes\" : \"No\");\n}\nstring ON(bool y, int id = 0) {\n    if (id) cout << id;\n    return (y ? \"OK\" : \"NG\");\n}\n\nint dir4[4][2] = {{0, -1}, {-1, 0}, {1, 0}, {0, 1}};\nint dir8[8][2] = {{-1, -1}, {0, -1}, {1, -1}, {-1, 0},\n                  {1, 0},   {-1, 1}, {0, 1},  {1, 1}};\nchar dirchar[4] = {'<', '^', '>', 'v'};\n\n// [a,b)\nint irand(int a, int b) {\n    static mt19937 Rand(static_cast< unsigned int >(time(nullptr)));\n    uniform_int_distribution< int > dist(a, b - 1);\n    return dist(Rand);\n}\n\n// [a,b)\ndouble drand(int a, int b) {\n    static mt19937 Rand(static_cast< unsigned int >(time(nullptr)));\n    uniform_real_distribution< double > dist(a, b);\n    return dist(Rand);\n}\n\n// 多次元vector生成\ntemplate < class T >\nvector< T > make_v(size_t size, const T &init) {\n    return vector< T >(size, init);\n}\ntemplate < class... Ts >\nauto make_v(size_t size, Ts... rest) {\n    return vector< decltype(make_v(rest...)) >(size, make_v(rest...));\n}\n\ntemplate < typename T >\nT max(vector< T > a) {\n    return *max_element(all(a));\n}\ntemplate < typename T >\nT min(vector< T > a) {\n    return *min_element(all(a));\n}\ntemplate < typename T >\nT sum(vector< T > a) {\n    return accumulate(all(a), (T)0);\n}\n\ntemplate < typename T >\nvoid add(map< T, int > &m, T item) {\n    if (m.find(item) == m.end()) {\n        m[item] = 1;\n    } else {\n        m[item]++;\n    }\n}\n\ntemplate < typename T, typename U >\nU get(map< T, U > m, T key, U def) {\n    if (m.find(key) == m.end()) {\n        return def;\n    } else {\n        return m[key];\n    }\n}\n\ntemplate < typename T >\nbool contains(set< T > t, const T &key) {\n    return t.find(key) != t.end();\n}\n\nstruct Edge {\n    int from, to, cost;\n    bool operator<(Edge e) {\n        return cost < e.cost;\n    }\n};\nusing Graph = vec< vec< Edge > >;\n\nostream &operator<<(ostream &os, Edge &edge) {\n    os << \"(\" << edge.from << \"->\" << edge.to << \":\" << edge.cost << \")\";\n    return os;\n}\n\n//======================================================\n\n// 区間加算区間和型\ntemplate < class T, class U >\nclass LazySegTree {\n    int n;\n    vector< T > dat;\n    vector< U > lazy;\n    vector< int > width;\n\n    function< T(T, T) > operation;\n    function< T(T, U) > adapt_lazy;\n    function< U(U, U) > merge_lazy;\n    function< U(U, int) > multiply_lazy;\n\n    T init, def, lazy_def;\n\n    // ツリー上のノード k に lazy 値 v をセット\n    void set_lazy(int k, U v) {\n        if (lazy[k] == lazy_def) {\n            lazy[k] = v;\n            dat[k] = adapt_lazy(dat[k], multiply_lazy(v, width[k]));\n        } else {\n            lazy[k] = merge_lazy(lazy[k], v);\n            dat[k] = adapt_lazy(dat[k], multiply_lazy(v, width[k]));\n        }\n    }\n    // lazy を 1 段下ろす\n    void push(int k) {\n        if (lazy[k] == lazy_def) return;\n        set_lazy(k * 2 + 1, lazy[k]);\n        set_lazy(k * 2 + 2, lazy[k]);\n        lazy[k] = lazy_def;\n    }\n\n    // 区間[a,b)の区間クエリ。ノードk=[l,r)に着目している。\n    long long _query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) return def; // 交差しない\n        if (a <= l && r <= b) return dat[k]; // a,l,r,bの順で完全に含まれる\n        push(k);\n        long long c1 = _query(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n        long long c2 = _query(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n        return operation(c1, c2);\n    }\n\n  public:\n    // _n:必要サイズ, _def:初期値, _operation:クエリ関数,\n    // _adapt_lazy:区間作用素適用関数, _merge_lazy:区間作用素マージ関数,\n    // _multiply_lazy:作用素を要素数で変形\n    LazySegTree(size_t _n, T _init, T _def, T _lazy_def,\n                function< T(T, T) > _operation, function< T(T, U) > _adapt_lazy,\n                function< U(U, U) > _merge_lazy,\n                function< U(U, int) > _multiply_lazy = [](U u,\n                                                          int n) { return u; })\n        : init(_init), def(_def), lazy_def(_lazy_def), operation(_operation),\n          adapt_lazy(_adapt_lazy), merge_lazy(_merge_lazy),\n          multiply_lazy(_multiply_lazy) {\n        n = 1;\n        while (n < _n) n *= 2;\n        dat = vector< long long >(2 * n - 1, init);\n        lazy = vector< long long >(2 * n - 1, lazy_def);\n        width = vector< int >(2 * n - 1);\n        width[0] = n;\n        repr(i, 1, 2 * n - 1) width[i] = width[(i - 1) / 2] / 2;\n    }\n\n    // 区間[a,b)にvを作用させる\n    void range_operation(int a, int b, long long v, int k = 0, int l = 0,\n                         int r = -1) {\n        if (r == -1) r = n;\n        if (r <= a || b <= l) return; // 交差しない\n        if (a <= l && r <= b) {       // a,l,r,bの順で完全に含まれる\n            set_lazy(k, v);\n            return;\n        }\n        push(k);\n        range_operation(a, b, v, 2 * k + 1, l, (l + r) / 2); // 左の子\n        range_operation(a, b, v, 2 * k + 2, (l + r) / 2, r); // 右の子\n        dat[k] = operation(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n\n    // [a, b)の区間クエリを実行\n    long long query(int a, int b) {\n        return _query(a, b, 0, 0, n);\n    }\n\n    //  添字でアクセス\n    long long operator[](int i) {\n        return query(i, i + 1);\n    }\n};\n\nint main(void) {\n    int N, Q;\n    cin >> N >> Q;\n    auto operation = [](ll a, ll b) { return a + b; };\n    auto adapt_lazy = [](ll a, ll b) { return b; };\n    auto merge_lazy = [](ll a, ll b) { return b; };\n    auto multiply_lazy = [](ll a, int n) { return a * n; };\n    LazySegTree< ll, ll > lst(N, 0, 0, -INFL, operation, adapt_lazy, merge_lazy,\n                              multiply_lazy);\n\n    rep(q, Q) {\n        int c;\n        cin >> c;\n        if (c == 0) {\n            // add(s, t, x)\n            int s, t, x;\n            cin >> s >> t >> x;\n            lst.range_operation(s, t + 1, x);\n        } else {\n            // getSum(s, t)\n            int s, t;\n            cin >> s >> t;\n            cout << lst.query(s, t + 1) << endl;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n    \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n                                     //----------------kokomade tenpure------------\n\n\n#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include<algorithm>\n#include<functional>\n#define ll long long\n\n#define pa pair<int,int>\n#define int long long\n\nusing namespace std;\n\n\nstruct seg_rangeupd_getsum{\n\t//       1\n\t//   2        3\n\t// 4   5   6    7\n\t\n\t\n\tprivate:\n\tpublic:\n\t\n\t// (1<<15)=32768\n\t// 1<<16 = 65536\n\t// 1<<17 = 131072\n\t// 1<<18 = 262144\n\t\n\tint cor=(1<<17);\n\tint inff=inf*1000000ll;\n\t\n\tvector<int> vec;\n\tvector<int> lazy;\n\tvoid shoki1(){\n\t\tvec.resize(2*cor+3, 0);\n\t\tlazy.resize(2*cor+3, inff);\n\t}\n\tvoid shoki2(){\n\t\t//lazy[1]=(1ll<<31)-1;\n\t\t//初期値\n\t}\n\t\t\n\tvoid chien(int k,int l,int r){\n\t\tif(lazy[k]==inff) return;\n\t\tif(l+1<r){\n\t\t\tvec[k]=lazy[k]*(r-l);\n\t\t\tlazy[2*k]=lazy[k];\n\t\t\tlazy[2*k+1]=lazy[k];\n\t\t\tlazy[k]=inff;\n\t\t}\n\t\telse {\n\t\t\tvec[k]=lazy[k];\n\t\t\tlazy[k]=inff;\n\t\t}\n\t}\n\t\n\tint rangeupd(int a,int b,int w, int k=1,int l=0,int r=-3){\n\t\t//[a,b)を wに変更\n\t\tif(r<0) r=cor;\n\t\t\n\t\tif(a<=l && r<=b){\n\t\t\tlazy[k]=w;\n\t\t\tchien(k,l,r);\n\t\t\treturn vec[k];\n\t\t}\n\t\tif(r<=a || b<=l){\n\t\t\tchien(k,l,r);\n\t\t\treturn vec[k];\n\t\t}\n\t\t\n\t\tchien(k,l,r);\n//\tcout<<k<<\" \"<<l<<\" \"<<r<<endl;\n\t\tint w1=rangeupd(a,b,w,k*2,l,(l+r)/2);\n\t\tint w2=rangeupd(a,b,w,k*2+1,(l+r)/2,r);\n\t\tvec[k]=w1+w2;\n\t\treturn vec[k];\n\t}\n\t\n\t// [a,b)\n\t// k-th node\n\t// k no kukanha [l,r)\n\t\n\tint getsum(int a,int b,int k=1,int l=0,int r=-1){\n\t\t//[a,b)のminを取得\n\t\tif(r<0) r=cor;\n\t\tchien(k,l,r);\n\t\tif(r<=a || b<=l){// 区間外\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif(a<=l && r<=b){// 完全含む\n\t\t\t\n\t\t\treturn vec[k];\n\t\t}\n\t\tint w1=getsum(a,b,k*2,l,(l+r)/2);\n\t\tint w2=getsum(a,b,k*2+1,(l+r)/2,r);\n\t\treturn (w1+w2);\n\t}\n\tvoid pre(){\n\t\tfor(int i=1;i<2*cor;i++){\n\t\t\tcout<<vec[i]<<\" \";\n\t\t\tif(((i+1)&(-(i+1)))==i+1) cout<<endl;\n\t\t}\n\t}\n\t\n};\n\n\n//[a,b)にxを一様加算 rangeadd(a,b,x)\n//[a,b)の和 getsum(a,b)\n\n\nseg_rangeupd_getsum SE;\n\t\n\n\n signed main(){\n\n  //  \t       cin.tie(0);\n  // \t\t\tios::sync_with_stdio(false);\n \tSE.shoki1();\n \tSE.shoki2();\n \tint n,q;\n \tcin>>n>>q;\n \tfor(int i=0;i<q;i++){\n \tint r;\n \t\tcin>>r;\n \t\tif(r){\n \t\tint s,t;\n \t\t\tcin>>s>>t;\n \t\t\tcout<<SE.getsum(s,t+1)<<endl;\n \t\t}\n \t\telse{\n \t\t\tint s,t,x;\n \t\t\tcin>>s>>t>>x;\n \t\t\tSE.rangeupd(s,t+1,x);\n \t\t}\n \t\n \t}\n \treturn 0;\n  }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long int\n#define MOD(x) ((x % MOD_N) + MOD_N) % MOD_N\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define RFORE(i,a,b) for(int i=(b);i>=(a);--i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define RALL(c) (c).rbegin(),(c).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(c) (int)((c).size())\n#define EACH(i,v) for(auto i=v.begin();i!=v.end();++i)\n#define REACH(i,v) for(auto i=v.rbegin();i!=v.rend();++i)\n#define LB(c,x) distance((c).begin(),lower_bound(ALL(c),x))\n#define UB(c,x) distance((c).begin(),upper_bound(ALL(c),x))\n#define COUNT(c,x) (lower_bound(ALL(c),x)-upper_bound(ALL(c),x))\n#define UNIQUE(c) SORT(c); (c).erase(unique(ALL(c)),(c).end());\n#define COPY(c1,c2) copy(ALL(c1),(c2).begin())\n#define EXIST(s,e) (bool)((s).find(e)!=(s).end())\n#define PB push_back\n#define MP make_pair\n#define DUMP(x)  cerr<<#x<<\" = \"<<(x)<<endl;\n#define NL cerr<<endl;\nusing namespace std;\ntemplate<typename T,typename U> using P=pair<T,U>;\ntemplate<typename T> using V=vector<T>;\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T sum(vector<T>&v){return accumulate(ALL(v),T());}\ntemplate<typename T>T sum(vector<T>&v,int a,int b){return accumulate(v.begin()+a,v.begin()+b,T());}\ntemplate<typename T>T max(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T min(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T max_index(vector<T>&v){return distance((v).begin(),max_element(ALL(v)));}\ntemplate<typename T>T min_index(vector<T>&v){return distance((v).begin(),min_element(ALL(v)));}\n\nstruct edge { int to, cost; };\n\ntemplate<typename T>auto&operator<<(ostream&s,const vector<T>&v){s<<\"[\";bool a=1;for(auto e:v){s<<(a?\"\":\" \")<<e;a=0;}s<<\"]\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const pair<T,U>&p){s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return s;}\ntemplate<typename T>auto&operator<<(ostream&s,const set<T>&st){s<<\"{\";bool a=1;for(auto e:st){s<<(a?\"\":\" \")<<e;a=0;}s<<\"}\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const map<T,U>&m){s<<\"{\";bool a=1;for(auto e:m){s<<(a?\"\":\" \")<<e.first<<\":\"<<e.second;a=0;}s<<\"}\";return s;}\n\nconst int INF = 1e18;\nconst int MOD_N = 1e9+7;\n\ntemplate< typename Monoid, typename OperatorMonoid = Monoid >\nstruct LazySegmentTree {\n   using F = function< Monoid(Monoid, Monoid) >;\n   using G = function< Monoid(Monoid, OperatorMonoid, int) >;\n   using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n   int sz;\n   vector< Monoid > data;\n   vector< OperatorMonoid > lazy;\n   const F f;\n   const G g;\n   const H h;\n   const Monoid M1;\n   const OperatorMonoid OM0;\n   LazySegmentTree(int n, const F f, const G g, const H h,\n                   const Monoid &M1, const OperatorMonoid OM0)\n         : f(f), g(g), h(h), M1(M1), OM0(OM0) {\n      sz = 1;\n      while(sz < n) sz <<= 1;\n      data.assign(2 * sz, M1);\n      lazy.assign(2 * sz, OM0);\n   }\n\n   void set(int k, const Monoid &x) {\n      data[k + sz] = x;\n   }\n   void build() {\n      for(int k = sz - 1; k > 0; k--) {\n         data[k] = f(data[2 * k + 0], data[2 * k + 1]);\n      }\n   }\n   void propagate(int k, int len) {\n      if(lazy[k] != OM0) {\n         if(k < sz) {\n            lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n            lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n         }\n         data[k] = g(data[k], lazy[k], len);\n         lazy[k] = OM0;\n      }\n   }\n   Monoid update(int a, int b, const OperatorMonoid &x, int k, int l, int r) {\n      propagate(k, r - l);\n      if(r <= a || b <= l) {\n         return data[k];\n      } else if(a <= l && r <= b) {\n         lazy[k] = h(lazy[k], x);\n         propagate(k, r - l);\n         return data[k];\n      } else {\n         return data[k] = f(update(a, b, x, 2 * k + 0, l, (l + r) >> 1),\n                            update(a, b, x, 2 * k + 1, (l + r) >> 1, r));\n      }\n   }\n   Monoid update(int a, int b, const OperatorMonoid &x) {\n      return update(a, b, x, 1, 0, sz);\n   }\n   Monoid query(int a, int b, int k, int l, int r) {\n      propagate(k, r - l);\n      if(r <= a || b <= l) {\n         return M1;\n      } else if(a <= l && r <= b) {\n         return data[k];\n      } else {\n         return f(query(a, b, 2 * k + 0, l, (l + r) >> 1),\n                  query(a, b, 2 * k + 1, (l + r) >> 1, r));\n      }\n   }\n   Monoid query(int a, int b) {\n      return query(a, b, 1, 0, sz);\n   }\n   Monoid operator[](const int &k) {\n      return query(k, k + 1);\n   }\n};\ntemplate<typename T> struct RSQ_RUQ {\n   LazySegmentTree<T> lsegt;\n   RSQ_RUQ(int n) : lsegt(n,\n      [](T a,T b){ return a + b; },\n      [](T a,T b,T c){ return b * c; },\n      [](T a,T b){ return b; }, 0, INF){}\n   void update(int a, int b, T x) { lsegt.update(a, b, x); }\n   T query(int a, int b) { lsegt.query(a, b); }\n};\n\nsigned main()\n{\n   int n, q; cin >> n >> q;\n   V<int> c(q), s(q), t(q), x(q);\n   REP(i, q) {\n      cin >> c[i];\n      if (c[i] == 0) {\n         cin >> s[i] >> t[i] >> x[i];\n      } else {\n         cin >> s[i] >> t[i];\n      }\n   }\n   // LazySegmentTree<int> lsegt(n,\n   //       [](int a,int b){ return a + b; },\n   //       [](int a,int b,int c){ return b * c; },\n   //       [](int a,int b){ return b; }, 0, INF);\n   RSQ_RUQ<int> rsqruq(n);\n   REP(i, q) {\n      if (c[i] == 0) {\n         rsqruq.update(s[i], t[i]+1, x[i]);\n      } else {\n         cout << rsqruq.query(s[i], t[i]+1) << endl;\n      }\n   }\n\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (long long i=0;i<(n);i++)\n#define dump(x)  cerr << #x << \" => \" << (x) << endl;\n#define dump1d_arr(array) REP(i,array.size()) cerr << #array << \"[\" << (i) << \"] ==> \" << (array[i]) << endl;\nusing namespace std;\n/*\nstruct Monoid {\n    using T = _underlying_set_;\n    static  T op(const T& a, const T& b) { return _a_op_b_; }\n    static constexpr T identity() { return _identity_element_; }\n};\n*/\ntemplate <class Monoid,class MonoidAct,typename N>\nclass LazySegmentTree {\nprivate:\n    using T1 = typename Monoid::T;\n    using T2 = typename MonoidAct::T;\n    vector<T1> data;\n    vector<T2> lazy;\n    vector<N> rank; \n    const size_t h, n;\n\n    //オペレータ2 MonoidAct -> Monoid (値がどう変化するか)\n\n    // RUQ -> RMQ\n    //static T1 op2(const T1& l,const T2& r,const N& num) {return r != MonoidAct::id() ? r : l; }\n    // RAQ -> RMQ\n    //static T1 op2(const T1& l,const T2& r,const N& num) {return l + r; }\n    // RAQ -> RSQ \n    //static T1 op2(const T1& l,const T2& r,const N& num) {return l + (r*num); }\n    // RUQ -> RSQ\n    static T1 op2(const T1& l,const T2& r,const N& num) {return r != MonoidAct::id() ? r*num : l; }\n\n\n\nprivate:\n    void eval(size_t node) {\n        if (lazy[node] == MonoidAct::id()) return;\n        if (node < n) {\n            lazy[node * 2] = MonoidAct::op3(lazy[node * 2], lazy[node]);\n            lazy[node * 2 + 1] = MonoidAct::op3(lazy[node * 2 + 1], lazy[node]);\n        }\n        data[node] = op2(data[node],lazy[node],rank[node]);\n        lazy[node] = MonoidAct::id();\n    }\n    void update(size_t node) {\n        data[node] = Monoid::op1(op2(data[node * 2],lazy[node * 2],rank[node*2])\n                        ,op2(data[node * 2 + 1],lazy[node * 2 + 1],rank[node*2+1]));\n    }\n\npublic:\n    LazySegmentTree(size_t n_)\n        : h(ceil(log2(n_))), n(1 << h) {data.resize(n * 2, Monoid::id());lazy.resize(n * 2, MonoidAct::id());rank.resize(n*2);init();}\n    LazySegmentTree(size_t n_, T1 v1)\n        : h(ceil(log2(n_))), n(1 << h) {data.resize(n * 2, v1);lazy.resize(n * 2, MonoidAct::id());rank.resize(n*2);init();}\n    LazySegmentTree(const vector<T1>& data_)\n        : h(ceil(log2(data_.size()))), n(1 << h) {\n            data.resize(n * 2,Monoid::id());\n            lazy.resize(n * 2, MonoidAct::id());\n            rank.resize(n*2);\n            init(data_);\n    }\n    void init() {\n        for (N i = 0;i < n;i++) rank[i+n] = 1;\n        for (N i = n - 1; i >= 1; i--) {\n            data[i] = Monoid::op1(data[i * 2], data[i * 2 + 1]);\n            rank[i] += (rank[i*2] + rank[i*2+1]);\n        }\n    }\n    void init(const vector<T1>& data_) {\n        for (N i = 0; i < (N)data_.size(); i++) {\n            data[i + n] = data_[i];\n        }\n        init();\n    }\n\n    T1 operator[](size_t i) { return find(i,i+1);}\n\n    void update(size_t l, size_t r, T2 val) {\n        l += n, r += n - 1;\n        for (N i = h; i > 0; i--) eval(l >> i), eval(r >> i);\n        size_t tl = l, tr = r;\n        r++;\n        while (l < r) {\n            if (l & 1) lazy[l] = MonoidAct::op3(lazy[l], val), l++;\n            if (r & 1) r--, lazy[r] = MonoidAct::op3(lazy[r],val);\n            l >>= 1; r >>= 1;\n        }\n        while (tl >>= 1, tr >>= 1, tl) {\n            if (lazy[tl] == MonoidAct::id()) update(tl);\n            if (lazy[tr] == MonoidAct::id()) update(tr);\n        }\n    }\n    T1 find(size_t l, size_t r) {\n        l += n, r += n - 1;\n        for (N i = h; i > 0; i--) eval(l >> i), eval(r >> i);\n        r++;\n        T1 res1 = Monoid::id(), res2 = Monoid::id();\n        while (l < r) {\n            if (l & 1) res1 = Monoid::op1(res1, op2(data[l],lazy[l],rank[l])), l++;\n            if (r & 1) r--, res2 = Monoid::op1(op2(data[r],lazy[r],rank[r]),res2);\n            l >>= 1; r >>= 1;\n        }\n        return Monoid::op1(res1, res2);\n    }\n};\n\n\n// findモノイド\nstruct RMQ { // 区間の最小\n    using T = long;\n    static T op1(const T& a, const T& b) { return min(a,b); }\n    static constexpr T id() {return numeric_limits<T>::max();}\n};\nstruct RSQ { // 区間の和\n    using T = long;\n    static T op1(const T& a, const T& b) { return (a+b); }\n    static constexpr T id() {return 0; }\n};\n\n// updateモノイド\nstruct RUQ { // 区間に代入更新\n    using T = long;\n    static T op3(const T& l,const T& r) { return r != id() ? r : l;}\n    static constexpr T id() { return numeric_limits<T>::max(); }\n};\n\nstruct RAQ { // 区間に加算\n    using T = long;\n    static T op3(const T& l,const T& r) { return l+r;}\n    static constexpr T id() { return 0;}\n};\n\n\nint main(void) {\n    int n,q,com,s,t,x;\n    cin >> n >> q;\n    LazySegmentTree<RSQ,RUQ,long> sg(n,0);\n    REP(i,q) {\n        cin >> com;\n        if (!com) {\n            cin >> s >> t >> x;\n            sg.update(s,t+1,x);\n        }\n        else {\n            cin >> s >> t;\n            cout << sg.find(s,t+1) << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#include \"bits/stdc++.h\"\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n#include <random>\n#ifdef _MSC_VER\n#include <ppl.h>\n//#include <boost/multiprecision/cpp_dec_float.hpp>\n//#include <boost/multiprecision/cpp_int.hpp>\n//#include <boost/rational.hpp>\n//#include <opencv2/core.hpp>\n//#include <opencv2/imgproc.hpp>\n//#include <opencv2/highgui.hpp>\n//#else\n//#include <omp.h>\n#endif\n\n\nusing namespace std;\n\n#define DUMPOUT cerr\n#define dump(...) DUMPOUT<<\"  \";DUMPOUT<<#__VA_ARGS__<<\" :[\"<<__LINE__<<\":\"<<__FUNCTION__<<\"]\"<<endl;DUMPOUT<<\"    \";dump_func(__VA_ARGS__)\n\nusing uint = unsigned; using ll = long long; using ull = unsigned long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using pdd = pair<double, double>; using pss = pair<string, string>;\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const pair<_KTy, _Ty>& m) { o << \"{\" << m.first << \", \" << m.second << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const map<_KTy, _Ty>& m) { if (m.empty()) { o << \"{ }\"; return o; } o << \"{\" << *m.begin(); for (auto itr = ++m.begin(); itr != m.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> ostream& operator << (ostream& o, const unordered_map<_KTy, _Ty>& m) { if (m.empty()) { o << \"{ }\"; return o; } o << \"{\" << *m.begin(); for (auto itr = ++m.begin(); itr != m.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const vector<_Ty>& v) { if (v.empty()) { o << \"{ }\"; return o; } o << \"{\" << v.front(); for (auto itr = ++v.begin(); itr != v.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const deque<_Ty>& v) { if (v.empty()) { o << \"{ }\"; return o; } o << \"{\" << v.front(); for (auto itr = ++v.begin(); itr != v.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const set<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } o << \"{\" << *(s.begin()); for (auto itr = ++s.begin(); itr != s.end(); itr++) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const unordered_set<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } o << \"{\" << *(s.begin()); for (auto itr = ++s.begin(); itr != s.end(); itr++) { o << \", \" << *itr; }\to << \"}\"; return o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const stack<_Ty>& s) { if (s.empty()) { o << \"{ }\"; return o; } stack<_Ty> t(s); o << \"{\" << t.top(); t.pop(); while (!t.empty()) { o << \", \" << t.top(); t.pop(); } o << \"}\";\treturn o; }\ntemplate <typename _Ty> ostream& operator << (ostream& o, const list<_Ty>& l) { if (l.empty()) { o << \"{ }\"; return o; } o << \"{\" << l.front(); for (auto itr = ++l.begin(); itr != l.end(); ++itr) { o << \", \" << *itr; } o << \"}\"; return o; }\ntemplate <typename _KTy, typename _Ty> istream& operator >> (istream& is, pair<_KTy, _Ty>& m) { is >> m.first >> m.second; return is; }\ntemplate <typename _Ty> istream& operator >> (istream& is, vector<_Ty>& v) { for (size_t t = 0; t < v.size(); t++) is >> v[t]; return is; }\ntemplate <typename _Ty> istream& operator >> (istream& is, deque<_Ty>& v) { for (size_t t = 0; t < v.size(); t++) is >> v[t]; return is; }\nnamespace aux { // print tuple\n  template<typename Ty, unsigned N, unsigned L> struct tp { static void print(ostream& os, const Ty& v) { os << get<N>(v) << \", \"; tp<Ty, N + 1, L>::print(os, v); } };\n  template<typename Ty, unsigned N> struct tp<Ty, N, N> { static void print(ostream& os, const Ty& v) { os << get<N>(v); } };\n}\n\ntemplate<typename... Tys> ostream& operator<<(ostream& os, const tuple<Tys...>& t) { os << \"{\"; aux::tp<tuple<Tys...>, 0, sizeof...(Tys) - 1>::print(os, t); os << \"}\"; return os; }\n\ntemplate<typename A, size_t N, typename T> inline void Fill(A(&array)[N], const T& val) { fill((T*)array, (T*)(array + N), val); }\n\ntemplate <typename ... Args>\nstd::string format(const std::string& fmt, Args ... args) {\n  size_t len = std::snprintf(nullptr, 0, fmt.c_str(), args ...);\n  std::vector<char> buf(len + 1);\n  std::snprintf(&buf[0], len + 1, fmt.c_str(), args ...);\n  return std::string(&buf[0], &buf[0] + len);\n}\n\nvoid dump_func() { DUMPOUT << endl; }\ntemplate <class Head, class... Tail> void dump_func(Head&& head, Tail&&... tail) { DUMPOUT << head; if (sizeof...(Tail) == 0) { DUMPOUT << \" \"; } else { DUMPOUT << \", \"; } dump_func(move(tail)...); }\n\n#define PI 3.14159265358979323846\n#define EPS 1e-8\n#define rep(t,n) for(int t=0;t<(n);++t)\n#define ALL(j) (j).begin(), (j).end()\n#define SZ(j) ((int)(j).size())\n#define fake false\n\nclass Timer {\npublic:\n  double t = 0;\n  Timer() {}\n  static double time() {\n#ifdef _MSC_VER\n    return __rdtsc() / 2.8e9;\n#else\n    unsigned long long a, d;\n    __asm__ volatile(\"rdtsc\"\n      : \"=a\"(a), \"=d\"(d));\n    return (d << 32 | a) / 2.8e9;\n#endif\n  }\n  void measure() { t = time() - t; }\n  double elapsedMs() { return (time() - t) * 1000.0; }\n} timer;\n\nstruct Xorshift {\n  uint64_t x = 88172645463325252LL;\n  unsigned next_int() {\n    x = x ^ (x << 7);\n    return x = x ^ (x >> 9);\n  }\n  unsigned next_int(unsigned mod) {\n    x = x ^ (x << 7);\n    x = x ^ (x >> 9);\n    return x % mod;\n  }\n  unsigned next_int(unsigned l, unsigned r) {\n    x = x ^ (x << 7);\n    x = x ^ (x >> 9);\n    return x % (r - l + 1) + l;\n  }\n  double next_double() {\n    return double(next_int()) / UINT_MAX;\n  }\n} rnd;\n\ntemplate<typename T>\nvoid shuffle_vector(vector<T>& v, Xorshift& rnd) {\n  int n = v.size();\n  for (int i = n - 1; i >= 1; i--) {\n    int r = rnd.next_int(i);\n    swap(v[i], v[r]);\n  }\n}\n\n\n\ntemplate<typename Monoid, typename OperatorMonoid = Monoid>\nstruct LazySegmentTree {\n  using F = function<Monoid(Monoid, Monoid)>;\n  using G = function<Monoid(Monoid, OperatorMonoid)>;\n  using H = function<OperatorMonoid(OperatorMonoid, OperatorMonoid)>;\n\n  int sz, height;\n  vector<Monoid> data;\n  vector<OperatorMonoid> lazy;\n  const F f;\n  const G g;\n  const H h;\n  const Monoid M1;\n  const OperatorMonoid OM0;\n\n  LazySegmentTree(int n, const F f, const G g, const H h, const Monoid& M1, const OperatorMonoid& OM0)\n    : f(f), g(g), h(h), M1(M1), OM0(OM0) {\n    sz = 1;\n    height = 0;\n    while (sz <= n) sz <<= 1, height++;\n    data.assign(2 * sz, M1);\n    lazy.assign(2 * sz, OM0);\n  }\n  void set(int k, const Monoid& x) {\n    data[k + sz] = x;\n  }\n  void build() {\n    for (int k = sz - 1; k > 0; k--) {\n      data[k] = f(data[2 * k + 0], data[2 * k + 1]);\n    }\n  }\n  inline void propagate(int k) {\n    if (lazy[k] != OM0) {\n      lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n      lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n      data[k] = reflect(k);\n      lazy[k] = OM0;\n    }\n  }\n  inline Monoid reflect(int k) {\n    return lazy[k] == OM0 ? data[k] : g(data[k], lazy[k]);\n  }\n  inline void recalc(int k) {\n    while (k >>= 1) data[k] = f(reflect(2 * k + 0), reflect(2 * k + 1));\n  }\n  inline void thrust(int k) {\n    for (int i = height; i > 0; i--) propagate(k >> i);\n  }\n  void update(int a, int b, const OperatorMonoid& x) {\n    thrust(a += sz);\n    thrust(b += sz - 1);\n    for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n      if (l & 1) lazy[l] = h(lazy[l], x), ++l;\n      if (r & 1) --r, lazy[r] = h(lazy[r], x);\n    }\n    recalc(a);\n    recalc(b);\n  }\n  Monoid query(int a, int b) {\n    thrust(a += sz);\n    thrust(b += sz - 1);\n    Monoid L = M1, R = M1;\n    for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n      if (l & 1) L = f(L, reflect(l++));\n      if (r & 1) R = f(reflect(--r), R);\n    }\n    return f(L, R);\n  }\n  Monoid operator[](const int& k) {\n    return query(k, k + 1);\n  }\n  template< typename C >\n  int find_subtree(int a, const C& check, Monoid& M, bool type) {\n    while (a < sz) {\n      propagate(a);\n      Monoid nxt = type ? f(reflect(2 * a + type), M) : f(M, reflect(2 * a + type));\n      if (check(nxt)) a = 2 * a + type;\n      else M = nxt, a = 2 * a + 1 - type;\n    }\n    return a - sz;\n  }\n  template< typename C >\n  int find_first(int a, const C& check) {\n    Monoid L = M1;\n    if (a <= 0) {\n      if (check(f(L, reflect(1)))) return find_subtree(1, check, L, false);\n      return -1;\n    }\n    thrust(a + sz);\n    int b = sz;\n    for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n      if (a & 1) {\n        Monoid nxt = f(L, reflect(a));\n        if (check(nxt)) return find_subtree(a, check, L, false);\n        L = nxt;\n        ++a;\n      }\n    }\n    return -1;\n  }\n  template< typename C >\n  int find_last(int b, const C& check) {\n    Monoid R = M1;\n    if (b >= sz) {\n      if (check(f(reflect(1), R))) return find_subtree(1, check, R, true);\n      return -1;\n    }\n    thrust(b + sz - 1);\n    int a = sz;\n    for (b += sz; a < b; a >>= 1, b >>= 1) {\n      if (b & 1) {\n        Monoid nxt = f(reflect(--b), R);\n        if (check(nxt)) return find_subtree(b, check, R, true);\n        R = nxt;\n      }\n    }\n    return -1;\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  using P = pair<ll, int>;\n\n  int n, q;\n  cin >> n >> q;\n  auto f = [](const P& a, const P& b) { return P(a.first + b.first, a.second + b.second); };\n  auto g = [](const P& a, ll x) { return P(x * a.second, a.second); };\n  auto h = [](ll a, ll b) { return b; };\n  LazySegmentTree<P, ll> seg(n, f, g, h, P(0LL, 1), INT64_MAX);\n  rep(i, n) seg.set(i, P(0LL, 1));\n  seg.build();\n  rep(_, q) {\n    int t, x, y, z;\n    cin >> t;\n    switch (t) {\n    case 0:\n      cin >> x >> y >> z;\n      seg.update(x, y + 1, z);\n      break;\n    case 1:\n      cin >> x >> y;\n      cout << seg.query(x, y + 1).first << '\\n';\n      break;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cmath>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#define FOR(i,a,b) for (int i=(a),for_##i##_max=(b);i<=(for_##i##_max);++i)\n#define RFOR(i,a,b) for (int i=(a),rfor_##i##_min=(b);i>=(rfor_##i##_min);--i)\n#define REP(i,n) for (int i=0,rep_##i##_len=(n);i<(rep_##i##_len);++i)\n#define RREP(i,n) for (int i=(n)-1;i>=0;--i)\n\nnamespace { // Basics\n\ntemplate<typename T>\nvoid chmin(T &x, T y) {\n  x = std::min(x, y);\n}\n\ntemplate<typename T>\nvoid chmax(T &x, T y) {\n  x = std::max(x, y);\n}\n\ntemplate<typename T>\n__attribute__((unused))\nconst auto minimum = static_cast<T const &(*)(T const &, T const &)>(std::min);\n\ntemplate<typename T>\n__attribute__((unused))\nconst auto maximum = static_cast<T const &(*)(T const &, T const &)>(std::max);\n\ntemplate<typename T>\n__attribute__((unused))\nT constexpr infty = std::numeric_limits<T>::max / 3;\ntemplate<>\n__attribute__((unused))\nauto constexpr infty<int> = 1'100'100'100;\ntemplate<>\n__attribute__((unused))\nauto constexpr infty<long long int> = 100'500'400'300'200'100LL;\n\nusing lli = long long int;\nusing ld = long double;\n\n} // namespace\n\nusing namespace std;\n\ntemplate <typename T>\nstruct service {\n  size_t L;\n  std::vector<T> dat;\n  std::vector<T> sum;\n  std::vector<T> lazy;\n  std::vector<bool> delayed;\n\n  explicit service(size_t n, T x)\n    : L(csqrt(n))\n    , dat(L * L, x)\n    , sum(L, x * L)\n    , lazy(L)\n    , delayed(L, false)\n  { }\n\n  void resolve(size_t g) {\n    if (!delayed[g]) { return; }\n    for (size_t i = g * L; i < (g + 1) * L; ++i) {\n      dat[i] = lazy[g];\n    }\n    delayed[g] = false;\n  }\n\n  void compute_sum(size_t g) {\n    assert(!delayed[g]);\n    T s = 0;\n    for (size_t i = g * L; i < (g + 1) * L; ++i) {\n      s += dat[i];\n    }\n    sum[g] = s;\n  }\n\n  void update(size_t begin, size_t end, T x) {\n    resolve(begin / L);\n    resolve(end / L);\n    size_t i;\n    for (i = begin; i < end && i % L != 0; ++i) {\n      dat[i] = x;\n    }\n    compute_sum(begin / L);\n    for (; i + L <= end; i += L) {\n      lazy[i / L] = x; delayed[i / L] = true;\n      sum[i / L] = x * L;\n    }\n    for (; i < end; ++i) {\n      dat[i] = x;\n    }\n    compute_sum(end / L);\n  }\n\n  T get_sum(size_t begin, size_t end) {\n    resolve(begin / L);\n    resolve(end / L);\n    size_t i;\n    T ans = 0;\n    for (i = begin; i < end && i % L != 0; ++i) {\n      ans += dat[i];\n    }\n    for (; i + L <= end; i += L) {\n      ans += sum[i / L];\n    }\n    for (; i < end; ++i) {\n      ans += dat[i];\n    }\n    return ans;\n  }\n\n  static size_t csqrt(size_t n) {\n    size_t k = 1;\n    while (k * k < n + 2) { ++k; }\n    return k;\n  }\n};\n\nint main() {\n  // cout << fixed << setprecision(10);\n\n  int N, Q; cin >> N >> Q;\n  service<lli> srv(N, 0);\n  REP(query, Q) {\n    int T; cin >> T;\n    if (T == 0) {\n      lli S, T, X; cin >> S >> T >> X;\n      srv.update(S, T+1, X);\n    } else {\n      lli S, T; cin >> S >> T;\n      cout << srv.get_sum(S, T+1) << endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <string>\n#include <queue>\n#include <cstdlib>\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> Pii;\n\nconst ll mod = 1000000007;\n\ntemplate <class T>\nstruct lazy_segtree {\n  int n;\n  vector<T> data;\n  vector<T> lazy;\n  vector<bool> lazyFlag;\n\n  lazy_segtree(const int s) {\n    init(s);\n  }\n\n  lazy_segtree(const int s, const T u) {\n    init(s);\n    for (int i = 0; i < s; i++) {\n      data[i+n-1] = u;\n    }\n    for (int i = n-2; i >= 0; i--) {\n      data[i] = min(data[i*2+1], data[i*2+2]);\n    }\n  }\n\n  lazy_segtree(const vector<T> &v) {\n    int s = v.size();\n    init(s);\n    for (int i = 0; i < s; i++) {\n      data[i+n-1] = v[i];\n    }\n    for (int i = n-2; i >= 0; i--) {\n      data[i] = min(data[i*2+1], data[i*2+2]);\n    }\n  }\n\n  void init(const int s) {\n    n = 1;\n    while (n < s) n <<= 1;\n    data = vector<T>(2*n-1);\n    lazy = vector<T>(2*n-1);\n    lazyFlag = vector<bool>(2*n-1);\n  }\n\n  void evaluate(int p, int a, int b) {\n    if (lazyFlag[p]) {\n      data[p] = lazy[p] * (b - a);\n      if (b - a > 1) {\n        lazy[p*2+1] = lazy[p];\n        lazy[p*2+2] = lazy[p];\n        lazyFlag[p*2+1] = true;\n        lazyFlag[p*2+2] = true;\n      }\n      lazy[p] = 0;\n      lazyFlag[p] = false;\n    }\n  }\n\n  void update(int l, int r, T v, int p = 0, int a = 0, int b = -1) {\n    if (b < 0) b = n; // init\n\n    // evaluate lazy value\n    evaluate(p, a, b);\n\n    if (r <= a || b <= l) return; // out of range\n    if (l <= a && b <= r) { // fully covered\n      lazy[p] = v;\n      lazyFlag[p] = true;\n      evaluate(p, a, b);\n    }\n    else {\n      update(l, r, v, p*2+1, a, (a + b) / 2); // left\n      update(l, r, v, p*2+2, (a + b) / 2, b); // right\n      data[p] = data[p*2+1] + data[p*2+2]; // update\n    }\n    return;\n  }\n\n  T query(int l, int r, T p = 0, int a = 0, int b = -1) {\n    if (b < 0) b = n; // init\n    if (r <= a || b <= l) return 0; // out of range\n\n    // evaluate lazy value\n    evaluate(p, a, b);\n\n    if (l <= a && b <= r) return data[p];// fully covered\n\n    T vl = query(l, r, p*2+1, a, (a + b) / 2); // left\n    T vr = query(l, r, p*2+2, (a + b) / 2, b); // right\n    return vl + vr;\n  }\n};\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, q;\n  cin >> n >> q;\n  vector<vector<int> > query(q, vector<int>(4));\n  for (int i = 0; i < q; i++) {\n    cin >> query[i][0] >> query[i][1] >> query[i][2];\n    if (query[i][0] == 0) cin >> query[i][3];\n  }\n\n  lazy_segtree<ll> lst(n);\n  vector<ll> ans;\n  for (int i = 0; i < q; i++) {\n    if (query[i][0] == 0) { // update\n      lst.update(query[i][1], query[i][2]+1, query[i][3]);\n    }\n    else { // getSum\n      ans.push_back(lst.query(query[i][1], query[i][2]+1));\n    }\n  }\n\n  for (auto &x: ans) cout << x << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, a, b) for (int i = (a); i < ((int)(b)); ++i)\n#define rrep(i, a, b) for (int i = ((int)(b)) - 1; i >= (a); --i)\n#define all(a) a.begin(),a.end()\n#define sz(a) ((int)a.size())\nusing pii = pair<int, int>;\nusing vvi = vector<vector<int>>;\nusing vi = vector<int>;\nconstexpr int INF = 1001001001001001001LL;\n\nvoid dump_impl(string s) {}\ntemplate <class H, class... T>\nvoid dump_impl(string s, const H &head, const T&... tail) {\n    int par = 0;\n    rep(i, 0, sz(s)) {\n        char ch = s[i];\n        if (ch == ',' && par == 0) {\n            cerr << \" = \" << head << \", \";\n            dump_impl(s.substr(i + 1), tail...);\n            return;\n        } else {\n            cerr << ch;\n            if (ch == '(') par++;\n            if (ch == ')') par--;\n        }\n    }\n}\n#define dump(...) do { cerr << \"\\x1b[33;1m\"; dump_impl(#__VA_ARGS__ \",\", __VA_ARGS__); cerr << \"\\x1b[0m\" << endl; } while (0)\n\ntemplate <class T>\nstruct LazySegmentTree {\n    const T query_ident = 0;\n    const T prop_ident = INF;\n    int size;\n    vector<T> data;\n    vector<T> lazy;\n    vi width;\n\n    LazySegmentTree(int n) {\n        size = 1;\n        while (size < n) size *= 2;\n        data.assign(size * 2, query_ident);\n        lazy.assign(size * 2, prop_ident);\n        width.assign(size * 2, 1);\n        rrep(k, 0, size - 1) {\n            width[k] = width[k * 2 + 1] + width[k * 2 + 2];\n        }\n    }\n    void lazy_propagate(int k) {\n        if (lazy[k] == prop_ident) return;\n        data[k] = lazy[k] * width[k];  // !\n        if (k < size - 1) {\n            lazy[k * 2 + 1] = lazy[k];  // !\n            lazy[k * 2 + 2] = lazy[k];  // !\n        }\n        lazy[k] = prop_ident;\n    }\n    void range_update(int ql, int qr, T value) {\n        range_update(ql, qr, value, 0, 0, size);\n    }\n    void range_update(int ql, int qr, T value, int k, int nl, int nr) {\n        if (qr <= nl || nr <= ql) {\n            lazy_propagate(k);\n            return;\n        }\n        if (ql <= nl && nr <= qr) {\n            lazy[k] = value;  // !\n            lazy_propagate(k);\n            return;\n        }\n        lazy_propagate(k);\n        int nm = (nl + nr) / 2;\n        range_update(ql, qr, value, k * 2 + 1, nl, nm);\n        range_update(ql, qr, value, k * 2 + 2, nm, nr);\n        data[k] = data[k * 2 + 1] + data[k * 2 + 2];  // !\n    }\n    T range_sum(int ql, int qr) {\n        return range_sum(ql, qr, 0, 0, size);\n    }\n    T range_sum(int ql, int qr, int k, int nl, int nr) {\n        if (qr <= nl || nr <= ql) {\n            return query_ident;\n        }\n        if (ql <= nl && nr <= qr) {\n            lazy_propagate(k);\n            return data[k];\n        }\n        lazy_propagate(k);\n        int nm = (nl + nr) / 2;\n        T res_l = range_sum(ql, qr, k * 2 + 1, nl, nm);\n        T res_r = range_sum(ql, qr, k * 2 + 2, nm, nr);\n        return res_l + res_r;  // !\n    }\n};\n\nsigned main() {\n    int N, Q;\n    cin >> N >> Q;\n    LazySegmentTree<int> seg(N);\n    rep(i, 0, Q) {\n        int com;\n        cin >> com;\n        if (com == 0) {\n            int L, R, X;\n            cin >> L >> R >> X;\n            seg.range_update(L, R + 1, X);\n        } else {\n            int L, R;\n            cin >> L >> R;\n            cout << seg.range_sum(L, R + 1) << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//BEGIN CUT HERE\ntemplate <typename T,typename E>\nstruct SegmentTree{\n  using F = function<T(T,T)>;\n  using G = function<T(T,E)>;\n  using H = function<E(E,E)>;\n  using P = function<E(E,size_t)>;\n  int n;\n  F f;\n  G g;\n  H h;\n  T ti;\n  E ei;\n  P p;\n  vector<T> dat;\n  vector<E> laz;\n  SegmentTree(int n_,F f,G g,H h,T ti,E ei,\n\t      P p=[](E a,size_t b){return a;}):\n    f(f),g(g),h(h),ti(ti),ei(ei),p(p){\n    init(n_);\n  }\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.assign(2*n-1,ti);\n    laz.assign(2*n-1,ei);\n  }\n  void build(int n_, vector<T> v){\n    for(int i=0;i<n_;i++) dat[i+n-1]=v[i];\n    for(int i=n-2;i>=0;i--)\n      dat[i]=f(dat[i*2+1],dat[i*2+2]);\n  }\n  inline void eval(int len,int k){\n    if(laz[k]==ei) return;\n    if(k*2+1<n*2-1){\n      laz[k*2+1]=h(laz[k*2+1],laz[k]);\n      laz[k*2+2]=h(laz[k*2+2],laz[k]);\n    }\n    dat[k]=g(dat[k],p(laz[k],len));\n    laz[k]=ei;\n  }\n  T update(int a,int b,E x,int k,int l,int r){\n    eval(r-l,k);\n    if(r<=a||b<=l) return dat[k];\n    if(a<=l&&r<=b){\n      laz[k]=h(laz[k],x);\n      return g(dat[k],p(laz[k],r-l));\n    }\n    return dat[k]=f(update(a,b,x,k*2+1,l,(l+r)/2),\n\t\t    update(a,b,x,k*2+2,(l+r)/2,r));\n  }\n  T update(int a,int b,E x){\n    return update(a,b,x,0,0,n);\n  }\n  T query(int a,int b,int k,int l,int r){\n    eval(r-l,k);\n    if(r<=a||b<=l) return ti;\n    if(a<=l&&r<=b) return dat[k];\n    T vl=query(a,b,k*2+1,l,(l+r)/2);\n    T vr=query(a,b,k*2+2,(l+r)/2,r);\n    return f(vl,vr);\n  }\n  T query(int a,int b){\n    return query(a,b,0,0,n);\n  }\n  void update(int k,T x){\n    query(k,k+1);//evaluate\n    k+=n-1;\n    dat[k]=x;\n    while(k){\n      k=(k-1)/2;\n      dat[k]=f(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n};\n//END CUT HERE\nsigned main(){\n  int n,q;\n  cin>>n>>q;\n  SegmentTree<int,int> ch(n,\n\t\t\t  [](int a,int b){return a+b;},\n\t\t\t  [](int a,int b){return b;},\n\t\t\t  [](int a,int b){return b;},\n\t\t\t  0,0,\n\t\t\t  [](int a,int b){return a*b;});\n  ch.build(n,vector<int>(n,0));\n  for(int i=0;i<q;i++){\n    int c,s,t,x;\n    cin>>c;\n    if(c){\n      cin>>s>>t;\n      cout<<ch.query(s-1,t)<<endl;\n    }else{\n      cin>>s>>t>>x;\n      ch.update(s-1,t,x);\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nusing uint = unsigned int;\nusing pcc = pair<char, char>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\nusing tuplis = array<ll, 3>;\ntemplate<class T> using pq = priority_queue<T, vector<T>, greater<T>>;\nconst ll LINF=0x1fffffffffffffff;\nconst ll MINF=0x7fffffffffff;\nconst int INF=0x3fffffff;\nconst int MOD=1000000007;\nconst int MODD=998244353;\nconst ld DINF=numeric_limits<ld>::infinity();\nconst ld EPS=1e-9;\nconst ld PI=3.1415926535897932;\nconst ll four[] = {0, 1, 0, -1, 0};\nconst ll eight[] = {0, 1, 1, 0, -1, -1, 1, -1, 0};\n#define overload4(_1,_2,_3,_4,name,...) name\n#define overload3(_1,_2,_3,name,...) name\n#define rep1(n) for(ll i=0;i<n;++i)\n#define rep2(i,n) for(ll i=0;i<n;++i)\n#define rep3(i,a,b) for(ll i=a;i<b;++i)\n#define rep4(i,a,b,c) for(ll i=a;i<b;i+=c)\n#define rep(...) overload4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n#define rrep1(n) for(ll i=(n)-1;i>=0;i--)\n#define rrep2(i,n) for(ll i=(n)-1;i>=0;i--)\n#define rrep3(i,a,b) for(ll i=(b)-1;i>=(a);i--)\n#define rrep4(i,a,b,c) for(ll i=a+(b-a-1)/c*c;i>=a;i-=c)\n#define rrep(...) overload4(__VA_ARGS__,rrep4,rrep3,rrep2,rrep1)(__VA_ARGS__)\n#define each(i,...) for(auto&& i:__VA_ARGS__)\n#define all1(i) begin(i),end(i)\n#define all2(i,a) begin(i),begin(i)+a\n#define all3(i,a,b) begin(i)+a,begin(i)+b\n#define all(...) overload3(__VA_ARGS__,all3,all2,all1)(__VA_ARGS__)\n#define rall1(i) (i).rbegin(),(i).rend()\n#define rall2(i,k) (i).rbegin(),(i).rbegin()+k\n#define rall3(i,a,b) (i).rbegin()+a,(i).rbegin()+b\n#define rall(...) overload3(__VA_ARGS__,rall3,rall2,rall1)(__VA_ARGS__)\n#define sum(...) accumulate(all(__VA_ARGS__),0LL)\n#define dsum(...) accumulate(all(__VA_ARGS__),0.0L)\n#define elif else if\n#define unless(a) if(!(a))\n#define mp make_pair\n#define mt make_tuple\n#define INT(...) int __VA_ARGS__;in(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;in(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;in(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;in(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;in(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__;in(__VA_ARGS__)\n#define SORT(a) sort(all(a))\n#define REVERSE(a) reverse(all(a))\n#define UNIQUE(a) sort(all(a));a.erase(unique(all(a)),end(a))\n#define vec(type,name,...) vector<type> name(__VA_ARGS__)\n#define VEC(type,name,size) vector<type> name(size);in(name)\n#define vv(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__))\n#define VV(type,name,h,w) vector<vector<type>>name(h,vector<type>(w));in(name)\n#define vvv(type,name,h,w,...) vector<vector<vector<type>>>name(h,vector<vector<type>>(w,vector<type>(__VA_ARGS__)))\ntemplate<class T> auto max(const T& a){ return *max_element(all(a)); }\ntemplate<class T> auto min(const T& a){ return *min_element(all(a)); }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nll intpow(ll a, ll b){ ll ans = 1; while(b){ if(b & 1) ans *= a; a *= a; b /= 2; } return ans; }\nll modpow(ll a, ll b, ll p){ ll ans = 1; while(b){ if(b & 1) (ans *= a) %= p; (a *= a) %= p; b /= 2; } return ans; }\ntemplate<class T> bool chmin(T& a, const T& b){ if(a > b){ a = b; return 1; } return 0; }\ntemplate<class T> bool chmax(T& a, const T& b){ if(a < b){ a = b; return 1; } return 0; }\nvector<pll> factor(ull x){ vector<pll> ans; for(ll i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nvector<ll> divisor(ull x){ vector<ll> ans; for(ll i = 1; i * i <= x; i++) if(x % i == 0) ans.push_back(i); rrep(ans.size() - (ans.back() * ans.back() == x)) ans.push_back(x / ans[i]); return ans; }\ntemplate<class T> unordered_map<T, ll> press(vector<T>& a){ auto b = a; sort(all(b)); b.erase(unique(all(b)), b.end()); unordered_map<T,ll> ans; rep(b.size()) ans[b[i]] = i; each(i, a) i = ans[i]; return ans; }\ntemplate<class T> map<T, ll> press_map(vector<T>& a){ auto b = a; sort(all(b)); b.erase(unique(all(b)), b.end()); map<T,ll> ans; rep(b.size()) ans[b[i]] = i; each(i, a) i = ans[i]; return ans; }\nint scan(){ return getchar(); }\nvoid scan(int& a){ scanf(\"%d\", &a); }\nvoid scan(unsigned& a){ scanf(\"%u\", &a); }\nvoid scan(long& a){ scanf(\"%ld\", &a); }\nvoid scan(long long& a){ scanf(\"%lld\", &a); }\nvoid scan(unsigned long long& a){ scanf(\"%llu\", &a); }\nvoid scan(char& a){ do{ a = getchar(); }while(a == ' ' || a == '\\n'); }\nvoid scan(float& a){ scanf(\"%f\", &a); }\nvoid scan(double& a){ scanf(\"%lf\", &a); }\nvoid scan(long double& a){ scanf(\"%Lf\", &a); }\nvoid scan(vector<bool>& a){ for(unsigned i = 0; i < a.size(); i++){ int b; scan(b); a[i] = b; } }\nvoid scan(char a[]){ scanf(\"%s\", a); }\nvoid scan(string& a){ cin >> a; }\ntemplate<class T> void scan(vector<T>&);\ntemplate<class T, size_t size> void scan(array<T, size>&);\ntemplate<class T, class L> void scan(pair<T, L>&);\ntemplate<class T, size_t size> void scan(T(&)[size]);\ntemplate<class T> void scan(vector<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(deque<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, size_t size> void scan(array<T, size>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, class L> void scan(pair<T, L>& p){ scan(p.first); scan(p.second); }\ntemplate<class T, size_t size> void scan(T (&a)[size]){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(T& a){ cin >> a; }\nvoid in(){}\ntemplate <class Head, class... Tail> void in(Head& head, Tail&... tail){ scan(head); in(tail...); }\nvoid print(){ putchar(' '); }\nvoid print(bool a){ printf(\"%d\", a); }\nvoid print(int a){ printf(\"%d\", a); }\nvoid print(unsigned a){ printf(\"%u\", a); }\nvoid print(long a){ printf(\"%ld\", a); }\nvoid print(long long a){ printf(\"%lld\", a); }\nvoid print(unsigned long long a){ printf(\"%llu\", a); }\nvoid print(char a){ printf(\"%c\", a); }\nvoid print(char a[]){ printf(\"%s\", a); }\nvoid print(const char a[]){ printf(\"%s\", a); }\nvoid print(float a){ printf(\"%.15f\", a); }\nvoid print(double a){ printf(\"%.15f\", a); }\nvoid print(long double a){ printf(\"%.15Lf\", a); }\nvoid print(const string& a){ for(auto&& i : a) print(i); }\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ print(p.first); putchar(' '); print(p.second); }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\n#ifdef DEBUG\nvoid err(){ putchar('\\n'); }\ntemplate<class T> void err(const T& t){ print(t); putchar('\\n'); }\ntemplate<class Head, class... Tail> void err(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); }\n#else\ntemplate<class... T> void err(const T&...){}\n#endif\nint first(bool i = true){ return out(i?\"first\":\"second\"); }\nint yes(bool i = true){ return out(i?\"yes\":\"no\"); }\nint Yes(bool i = true){ return out(i?\"Yes\":\"No\"); }\nint No(){ return out(\"No\"); }\nint YES(bool i = true){ return out(i?\"YES\":\"NO\"); }\nint NO(){ return out(\"NO\"); }\nint Yay(bool i = true){ return out(i?\"Yay!\":\":(\"); }\nint possible(bool i = true){ return out(i?\"possible\":\"impossible\"); }\nint Possible(bool i = true){ return out(i?\"Possible\":\"Impossible\"); }\nint POSSIBLE(bool i = true){ return out(i?\"POSSIBLE\":\"IMPOSSIBLE\"); }\nvoid Case(ll i){ printf(\"Case #%lld: \", i); }\n\n\ntemplate<class T, class U>\nstruct LazySegmentTree{\n    virtual T f(const T&, const T&) = 0;\n    virtual void m(ll, T&, const U&) = 0;\n    virtual void c(U&, const U&) = 0;\n    ll size = 1, rank = 0;\n    vector<T> data;\n    vector<U> lazy;\n    const T def_value;\n    const U def_lazy;\n    LazySegmentTree(ll n, const T& def_value, const U& def_lazy): def_value(def_value), def_lazy(def_lazy){\n        while(size < n){\n            size *= 2;\n            rank++;\n        }\n        data.assign(size * 2, def_value);\n        lazy.assign(size * 2, def_lazy);\n    }\n    LazySegmentTree(const vector<T>& v, const T& def_value, const U& def_lazy): def_value(def_value), def_lazy(def_lazy){\n        while(size < v.size()){\n            size *= 2;\n            rank++;\n        }\n        data.assign(size * 2, def_value);\n        lazy.assign(size * 2, def_lazy);\n        for(ll i = 0; i < v.size(); i++) data[size + i] = v[i];\n    }\n    void push(ll at){\n        if(!at) return;\n        ll r = 31 - __builtin_clz(at);\n        for(ll i = r; i > 0; i--){\n            ll a = at >> i;\n            if(lazy[a] != def_lazy){\n                m(rank + i - r - 1, data[a * 2], lazy[a]);\n                m(rank + i - r - 1, data[a * 2 + 1], lazy[a]);\n                c(lazy[a * 2], lazy[a]);\n                c(lazy[a * 2 + 1], lazy[a]);\n                lazy[a] = def_lazy;\n            }\n        }\n    }\n    void update(ll at){\n        while(at /= 2){\n            data[at] = f(data[at * 2], data[at * 2 + 1]);\n        }\n    }\n    T operator[](ll at){\n        at += size;\n        push(at);\n        return data[at];\n    }\n    void set(ll at, const T& val){\n        at += size;\n        push(at);\n        data[at] = val;\n        update(at);\n    }\n    void query(ll l, ll r, const U& val){\n        if(l >= r) return;\n        l += size;\n        r += size;\n        ll L = l >> __builtin_ctz(l), R = (r >> __builtin_ctz(r)) - 1;\n        push(L);\n        push(R);\n        for(ll rank = 0; l < r; l /= 2, r /= 2, rank++){\n            if(l & 1){\n                m(rank, data[l], val);\n                c(lazy[l++], val);\n            }\n            if(r & 1){\n                m(rank, data[--r], val);\n                c(lazy[r], val);\n            }\n        }\n        update(L);\n        update(R);\n    }\n    T get(ll l, ll r){\n        if(l >= r) return def_value;\n        T L = def_value, R = def_value;\n        l += size; r += size;\n        push(l);\n        push(r - 1);\n        for(; l < r; l /= 2, r /= 2){\n            if(l & 1) L = f(L, data[l++]);\n            if(r & 1) R = f(data[--r], R);\n        }\n        return f(L, R);\n    }\n    void clear(){\n        for(auto& i : data) i = def_value;\n    }\n};\ntemplate<class T>\nstruct RAQRSQ : LazySegmentTree<T, T>{\n    using Base = LazySegmentTree<T, T>;\n    T f(const T& a, const T& b){ return a + b; }\n    void m(ll rank, T& x, const T& val){ x += val << rank; }\n    void c(T& a, const T& b){ a += b; }\n    RAQRSQ(ll n, const T& def_value = T()) : Base(n, def_value, def_value){}\n    RAQRSQ(const vector<T>& v, const T& def_value = T()) : Base(v, def_value, def_value){\n        for(ll i = Base::size; --i;) Base::data[i] = f(Base::data[i * 2], Base::data[i * 2 + 1]);\n    }\n};\ntemplate<class T>\nstruct RUQRmQ : LazySegmentTree<T, T>{\n    using Base = LazySegmentTree<T, T>;\n    T f(const T& a, const T& b){ return min(a, b); }\n    void m(ll rank, T& x, const T& val){ x = val; }\n    void c(T& a, const T& b){ a = b; }\n    RUQRmQ(ll n, const T& def_value, const T& def_lazy = numeric_limits<T>::max()) : Base(n, def_value, def_lazy){}\n    RUQRmQ(const vector<T>& v, const T& def_value, const T& def_lazy = numeric_limits<T>::max()) : Base(v, def_value, def_lazy){\n        for(ll i = Base::size; --i;) Base::data[i] = f(Base::data[i * 2], Base::data[i * 2 + 1]);\n    }\n};\ntemplate<class T>\nstruct RAQRmQ : LazySegmentTree<T, T>{\n    using Base = LazySegmentTree<T, T>;\n    T f(const T& a, const T& b){ return min(a, b); }\n    void m(ll rank, T& x, const T& val){ x += val; }\n    void c(T& a, const T& b){ a += b; }\n    RAQRmQ(ll n, const T& def_value, const T& def_lazy = T()) : Base(n, def_value, def_lazy){}\n    RAQRmQ(const vector<T>& v, const T& def_value, const T& def_lazy = T()) : Base(v, def_value, def_lazy){\n        for(ll i = Base::size; --i;) Base::data[i] = f(Base::data[i * 2], Base::data[i * 2 + 1]);\n    }\n};\ntemplate<class T>\nstruct RUQRSQ : LazySegmentTree<T, T>{\n    using Base = LazySegmentTree<T, T>;\n    T f(const T& a, const T& b){ return a + b; }\n    void m(ll rank, T& x, const T& val){ x = val << rank; }\n    void c(T& a, const T& b){ a = b; }\n    RUQRSQ(ll n, const T& def_value = T(), const T& def_lazy = numeric_limits<T>::max()) : Base(n, def_value, def_lazy){}\n    RUQRSQ(const vector<T>& v, const T& def_value = T(), const T& def_lazy = numeric_limits<T>::max()) : Base(v, def_value, def_lazy){\n        for(ll i = Base::size; --i;) Base::data[i] = f(Base::data[i * 2], Base::data[i * 2 + 1]);\n    }\n};\nsigned main(){\n    LL(n,q);\n    RUQRSQ<ll>seg(n);\n    rep(q){\n        LL(type);\n        if(type){\n            LL(s,t);\n            out(seg.get(s,t+1));\n        }\n        else{\n            LL(s,t,x);\n            seg.query(s,t+1,x);\n        }\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <numeric>\n#include <vector>\n#include <array>\n#include <cstring>\n\ntemplate <class T, class U>\ninline bool chmin(T &lhs, const U &rhs) {\n  if (lhs > rhs) { lhs = rhs; return true; }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T &lhs, const U &rhs) {\n  if (lhs < rhs) { lhs = rhs; return true; }\n  return false;\n}\n\nstruct range {\n  using itr = int64_t;\n  struct iterator {\n    itr i;\n    constexpr iterator(itr i_) noexcept : i(i_) { }\n    constexpr void operator ++ () noexcept { ++i; }\n    constexpr itr operator * () const noexcept { return i; }\n    constexpr bool operator != (iterator x) const noexcept { return i != x.i; }\n  };\n  const iterator l, r;\n  constexpr range(itr l_, itr r_) noexcept : l(l_), r(std::max(l_, r_)) { }\n  constexpr iterator begin() const noexcept { return l; }\n  constexpr iterator end() const noexcept { return r; }\n};\n\nstruct revrange {\n  using itr = int64_t;\n  struct iterator {\n    itr i;\n    constexpr iterator(itr i_) noexcept : i(i_) { }\n    constexpr void operator ++ () noexcept { --i; }\n    constexpr itr operator * () const noexcept { return i; }\n    constexpr bool operator != (iterator x) const noexcept { return i != x.i; }\n  };\n  const iterator l, r;\n  constexpr revrange(itr l_, itr r_) noexcept : l(l_ - 1), r(std::max(l_, r_) - 1) { }\n  constexpr iterator begin() const noexcept { return r; }\n  constexpr iterator end() const noexcept { return l; }\n};\n\nnamespace fast_io {\n  static constexpr size_t buf_size = 1 << 18;\n  static constexpr size_t buf_margin = 1;\n  static constexpr size_t block_size = 10000;\n  static constexpr size_t integer_size = 20;\n\n  static char inbuf[buf_size + buf_margin] = {};\n  static char outbuf[buf_size + buf_margin] = {};\n  static char block_str[block_size * 4 + buf_margin] = {};\n\n  static constexpr uint64_t power10[] = {\n    1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000,\n    1000000000, 10000000000, 100000000000, 1000000000000, 10000000000000,\n    100000000000000, 1000000000000000, 10000000000000000, 100000000000000000,\n    1000000000000000000, 10000000000000000000u\n  };\n\n  class scanner {\n  private:\n    size_t M_in_pos = 0, M_in_end = buf_size;\n\n    void M_load() { \n      M_in_end = fread(inbuf, 1, buf_size, stdin); \n      inbuf[M_in_end] = '\\0';  \n    }\n    void M_reload() {\n      size_t length = M_in_end - M_in_pos;\n      memmove(inbuf, inbuf + M_in_pos, length);\n      M_in_end = length + fread(inbuf + length, 1, buf_size - length, stdin);\n      inbuf[M_in_end] = '\\0';\n      M_in_pos = 0;\n    }\n\n    void M_ignore_space() {\n      while (inbuf[M_in_pos] <= ' ') {\n        if (__builtin_expect(++M_in_pos == M_in_end, 0)) M_reload();\n      }\n    }\n\n    char M_next() { return inbuf[M_in_pos++]; }\n    char M_next_nonspace() {\n      M_ignore_space();\n      return inbuf[M_in_pos++];\n    }\n\n  public:\n    scanner() { M_load(); }\n    \n    void scan(char &c) { c = M_next_nonspace(); }\n    void scan(std::string &s) {\n      M_ignore_space();\n      s = \"\";\n      do {\n        size_t start = M_in_pos;\n        while (inbuf[M_in_pos] > ' ') ++M_in_pos;\n        s += std::string(inbuf + start, inbuf + M_in_pos);\n        if (inbuf[M_in_pos] != '\\0') break;\n        M_reload();\n      } while (true);\n    }\n\n    template <class T>\n    typename std::enable_if<std::is_integral<T>::value, void>::type scan(T &x) {\n      char c = M_next_nonspace();\n      if (__builtin_expect(M_in_pos + integer_size >= M_in_end, 0)) M_reload();\n      bool n = false;\n      if (c == '-') n = true, x = 0;\n      else x = c & 15;\n      while ((c = M_next()) >= '0') x = x * 10 + (c & 15);\n      if (n) x = -x;\n    }\n\n    template <class T, class... Args>\n    void scan(T &x, Args&... args) {\n      scan(x); scan(args...);\n    }\n\n    template <class T>\n    scanner& operator >> (T &x) {\n      scan(x); return *this;\n    }\n\n  };\n\n  class printer {\n  private:\n    size_t M_out_pos = 0;\n\n    void M_flush() {\n      fwrite(outbuf, 1, M_out_pos, stdout);\n      M_out_pos = 0;\n    }\n\n    void M_precompute() {\n      for (size_t i = 0; i < block_size; ++i) {\n        size_t j = 4, k = i;\n        while (j--) {\n          block_str[i * 4 + j] = k % 10 + '0';\n          k /= 10;\n        }\n      }\n    }\n\n    static constexpr size_t S_integer_digits(uint64_t n) {\n      if (n >= power10[10]) {\n        if (n >= power10[19]) return 20;\n        if (n >= power10[18]) return 19;\n        if (n >= power10[17]) return 18;\n        if (n >= power10[16]) return 17;\n        if (n >= power10[15]) return 16;\n        if (n >= power10[14]) return 15;\n        if (n >= power10[13]) return 14;\n        if (n >= power10[12]) return 13;\n        if (n >= power10[11]) return 12;\n        return 11;\n      }\n      else {\n        if (n >= power10[9]) return 10;\n        if (n >= power10[8]) return 9;\n        if (n >= power10[7]) return 8;\n        if (n >= power10[6]) return 7;\n        if (n >= power10[5]) return 6;\n        if (n >= power10[4]) return 5;\n        if (n >= power10[3]) return 4;\n        if (n >= power10[2]) return 3;\n        if (n >= power10[1]) return 2;\n        return 1;\n      }\n    }\n\n  public:\n    printer() { M_precompute(); }\n    ~printer() { M_flush(); }\n\n    void print(char c) { \n      outbuf[M_out_pos++] = c;\n      if (__builtin_expect(M_out_pos == buf_size, 0)) M_flush();\n    }\n    void print(const char *s) {\n      while (*s != 0) {\n        outbuf[M_out_pos++] = *s++;\n        if (M_out_pos == buf_size) M_flush();\n      }\n    }\n    void print(const std::string &s) {\n      for (auto c: s) {\n        outbuf[M_out_pos++] = c;\n        if (M_out_pos == buf_size) M_flush();\n      }\n    }\n    \n    template <class T>\n    typename std::enable_if<std::is_integral<T>::value, void>::type print(T x) {\n      if (__builtin_expect(M_out_pos + integer_size >= buf_size, 0)) M_flush();\n      if (x < 0) print('-'), x = -x;\n      size_t digit = S_integer_digits(x);\n      size_t len = digit;\n      while (len >= 4) {\n        len -= 4;\n        memcpy(outbuf + M_out_pos + len, block_str + (x % block_size) * 4, 4);\n        x /= 10000;\n      }\n      memcpy(outbuf + M_out_pos, block_str + x * 4 + 4 - len, len);\n      M_out_pos += digit;\n    }\n\n    template <class T, class... Args>\n    void print(const T &x, const Args&... args) {\n      print(x); print(' '); print(args...);\n    }\n\n    template <class... Args>\n    void println(const Args&... args) {\n      print(args...); print('\\n');\n    }\n\n    template <class T>\n    printer& operator << (const T &x) {\n      print(x); return *this;\n    }\n\n  };\n\n};\n\nfast_io::scanner cin;\nfast_io::printer cout;\n\ntemplate <class CombinedMonoid>\nclass lazy_propagation_segment_tree {\npublic:\n  using combined_monoid = CombinedMonoid;\n  using value_monoid    = typename CombinedMonoid::value_monoid;\n  using operator_monoid = typename CombinedMonoid::operator_monoid;\n  using value_type      = typename value_monoid::type;\n  using operator_type   = typename operator_monoid::type;\n  using size_type       = size_t;\n\nprivate:\n  class node_type {\n  public:\n    value_type    value;\n    operator_type lazy;\n    node_type(\n      const value_type    &value = value_monoid::identity(),\n      const operator_type &lazy  = operator_monoid::identity()\n    ): value(value), lazy(lazy) { }\n  };\n  \n  static size_type S_lsb(const size_type index) {\n    return      __builtin_ctz(index);\n  }\n  static size_type S_msb(const size_type index) {\n    return 31 - __builtin_clz(index);\n  }\n\n  static void S_apply(node_type &node, const operator_type &op, const size_type length) {\n    node.value = combined_monoid::operation(node.value, op, length);\n    node.lazy  = operator_monoid::operation(node.lazy, op);\n  }\n\n  void M_propagate(const size_type index, const size_type length) {\n    S_apply(M_tree[index << 1 | 0], M_tree[index].lazy, length);\n    S_apply(M_tree[index << 1 | 1], M_tree[index].lazy, length);\n    M_tree[index].lazy = operator_monoid::identity();\n  }\n  void M_fix_change(const size_type index) {\n    M_tree[index].value = \n      value_monoid::operation(M_tree[index << 1 | 0].value, M_tree[index << 1 | 1].value);\n  }\n\n  void M_pushdown(const size_type index) {\n    const size_type lsb = S_lsb(index);\n    for (size_type story = S_msb(index); story != lsb; --story) {\n      M_propagate(index >> story, 1 << (story - 1));\n    }\n  }\n  void M_pullup(size_type index) {\n    index >>= S_lsb(index);\n    while (index != 1) {\n      index >>= 1;\n      M_fix_change(index);\n    }\n  }\n\n  std::vector<node_type> M_tree;\n\npublic:\n  lazy_propagation_segment_tree() = default;\n  explicit lazy_propagation_segment_tree(const size_type size) { initialize(size); }\n  template <class InputIterator>\n  explicit lazy_propagation_segment_tree(InputIterator first, InputIterator last) { construct(first, last); }\n\n  void initialize(const size_type size) {\n    clear();\n    M_tree.assign(size << 1, node_type());\n  }\n\n  template <class InputIterator>\n  void construct(InputIterator first, InputIterator last) {\n    clear();\n    const size_type size = std::distance(first, last);\n    M_tree.reserve(size << 1);\n    M_tree.assign(size, node_type());\n    for (; first != last; ++first) {\n      M_tree.emplace_back(*first, operator_monoid::identity());\n    }\n    for (size_type index = size - 1; index != 0; --index) {\n      M_fix_change(index);\n    }\n  }\n\n  value_type fold(size_type first, size_type last) {\n    first += size();\n    last  += size();\n    M_pushdown(first);\n    M_pushdown(last);\n    value_type fold_l = value_monoid::identity();\n    value_type fold_r = value_monoid::identity();\n    while (first != last) {\n      if (first & 1) {\n        fold_l = value_monoid::operation(fold_l, M_tree[first].value);\n        ++first;\n      }\n      if (last & 1) {\n        --last;\n        fold_r = value_monoid::operation(M_tree[last].value, fold_r);\n      }\n      first >>= 1;\n      last  >>= 1;\n    }\n    return value_monoid::operation(fold_l, fold_r);\n  }\n\n  void operate(size_type first, size_type last, const operator_type &op) {\n    first += size();\n    last  += size();\n    M_pushdown(first);\n    M_pushdown(last);\n    const size_type first_c = first;\n    const size_type last_c  = last;\n    for (size_type story = 0; first != last; ++story) {\n      if (first & 1) {\n        S_apply(M_tree[first], op, 1 << story);\n        ++first;\n      }\n      if (last & 1) {\n        --last;\n        S_apply(M_tree[last], op, 1 << story);\n      }\n      first >>= 1;\n      last  >>= 1;\n    }\n    M_pullup(first_c);\n    M_pullup(last_c);\n  }\n\n  void assign(size_type index, const value_type &val) {\n    index += size();\n    for (size_type story = S_msb(index); story != 0; --story) {\n      M_propagate(index >> story, 1 << (story - 1));\n    }\n    M_tree[index].value = val;\n    M_tree[index].lazy  = operator_monoid::identity();\n  }\n\n  void clear() {\n    M_tree.clear();\n    M_tree.shrink_to_fit();\n  }\n\n  size_type size() const { \n    return M_tree.size() >> 1;\n  }\n\n};\n\ntemplate <class Monoid>\nclass segment_tree {\npublic:\n  using monoid     = Monoid;\n  using value_type = typename Monoid::type;\n  using size_type  = size_t;\n\nprivate:\n  std::vector<value_type> M_tree;\n\n  void M_fix_change(const size_type index) {\n    M_tree[index] = monoid::operation(M_tree[index << 1 | 0], M_tree[index << 1 | 1]);\n  }\n\npublic:\n  segment_tree() = default;\n  explicit segment_tree(const size_type size) { initialize(size); }\n  template <class InputIterator>\n  explicit segment_tree(InputIterator first, InputIterator last) { construct(first, last); }\n\n  void initialize(const size_type size) {\n    clear();\n    M_tree.assign(size << 1, monoid::identity());\n  }\n\n  template <class InputIterator>\n  void construct(InputIterator first, InputIterator last) {\n    clear();\n    const size_type size = std::distance(first, last);\n    M_tree.reserve(size << 1);\n    M_tree.assign(size, monoid::identity());\n    std::copy(first, last, std::back_inserter(M_tree));\n    for (size_type index = size - 1; index != 0; --index) {\n      M_fix_change(index);\n    }\n  }\n\n  void assign(size_type index, const value_type &value) {\n    index += size();\n    M_tree[index] = value;\n    while (index != 1) {\n      index >>= 1;\n      M_fix_change(index);\n    } \n  }\n\n  const value_type& at(size_type index) const { \n    return M_tree[index + size()];\n  }\n\n  value_type fold(size_type first, size_type last) const {\n    first += size();\n    last += size();\n    value_type fold_l = monoid::identity();\n    value_type fold_r = monoid::identity();\n    while (first != last) {\n      if (first & 1) {\n        fold_l = monoid::operation(fold_l, M_tree[first]);\n        ++first;\n      }\n      if (last & 1) {\n        --last;\n        fold_r = monoid::operation(M_tree[last], fold_r);      \n      }\n      first >>= 1;\n      last  >>= 1;\n    }\n    return monoid::operation(fold_l, fold_r);\n  }\n\n  void clear() {\n    M_tree.clear();\n    M_tree.shrink_to_fit();\n  }\n\n  size_type size() const { \n    return M_tree.size() >> 1;\n  }\n\n};\n\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n\nconstexpr i32 inf32 = (i32(1) << 30) - 1;\nconstexpr i64 inf64 = (i64(1) << 62) - 1;\n\nstruct monoid {\n  struct value_monoid {\n    using type = i64;\n    static constexpr type identity() { return 0; }\n    static type operation(const type& v1, const type& v2) { \n      return v1 + v2;\n    }\n  };\n  struct operator_monoid {\n    using type = std::pair<i32, bool>;\n    static type identity() { return { 0, false }; }\n    static type operation(const type& v1, const type& v2) { \n      if (!v2.second) return v1;\n      return v2;\n    }\n  };\n  static typename value_monoid::type operation(\n    const typename value_monoid::type    &val,\n    const typename operator_monoid::type &op,\n    const size_t length) {\n    if (!op.second) return val;\n    return op.first * length;\n  }\n};\n\nint main() {\n  size_t N, Q;\n  cin.scan(N, Q);\n  lazy_propagation_segment_tree<monoid> seg(N);\n  while (Q--) {\n    size_t t, x;\n    cin.scan(t, x);\n    if (t == 0) {\n      size_t y;\n      i32 s;\n      cin.scan(y, s);\n      seg.operate(x, y + 1, { s, true });\n    }\n    else {\n      size_t y;\n      cin.scan(y);\n      cout.println(seg.fold(x, y + 1));\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <limits>\n#include <fstream>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\ntypedef long long ll;\nconst ll sqrtN = 512;\nstruct SqrtDecomposition {\n  ll N, K;\n  vector<ll> data;\n  vector<ll> bucketSum;\n  vector<ll> lazyUpdate;\n  SqrtDecomposition(ll n) : N(n) {\n    K = (N + sqrtN - 1) / sqrtN;\n    data.assign(K * sqrtN, 0);\n    bucketSum.assign(K, 0);\n    lazyUpdate.assign(K, 1111);\n  }\n  void eval(ll k) {\n    if (lazyUpdate[k] != 1111) {\n      for (ll i = k * sqrtN; i < (k + 1) * sqrtN; ++i) {\n        data[i] = lazyUpdate[k];\n      }\n      lazyUpdate[k] = 1111;\n    }\n  }\n  // [s, t)\n  void update(ll s, ll t, ll x) {\n    for (ll k = 0; k < K; ++k) {\n      ll l = k * sqrtN, r = (k + 1) * sqrtN;\n      if (r <= s || t <= l)\n        continue;\n      if (s <= l && r <= t) {\n        bucketSum[k] = x * sqrtN;\n        lazyUpdate[k] = x;\n      } else {\n        eval(k);\n        for (ll i = max(s, l); i < min(t, r); ++i) {\n          data[i] = x;\n          bucketSum[k] += x;\n        }\n      }\n    }\n  }\n  // [s, t)\n  ll find(ll s, ll t) {\n    ll ans = 0;\n    for (ll k = 0; k < K; ++k) {\n      ll l = k * sqrtN, r = (k + 1) * sqrtN;\n      if (r <= s || t <= l)\n        continue;\n      if (s <= l && r <= t) {\n        ans += bucketSum[k];\n      } else {\n        eval(k);\n        for (ll i = max(s, l); i < min(t, r); ++i) {\n          ans += data[i];\n        }\n      }\n    }\n    return ans;\n  }\n};\n\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  ll n, q;\n  cin >> n >> q;\n  SqrtDecomposition sd(n);\n  FOR(i,0,q) {\n    ll f;\n    cin >> f;\n    if(f) {\n      ll s,t;\n      cin >> s >> t;\n      cout << sd.find(s, t+1) << endl;\n    } else {\n      ll s,t,x;\n      cin >> s >> t >> x;\n      sd.update(s,t+1,x);\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define all(V) (V).begin(),(V).end()\n#define umap unordered_map\n#define uset unordered_set\n#define br cout<<\"\\n\";\n\nconst int MAXN=1e5+10, MOD=1e9+7;\nint n,m;\nint arr[MAXN];\nint t[5*MAXN],lazy[5*MAXN],clazy[5*MAXN];\n\nint doit(int a,int b){\n\treturn (a+b);\n}\n\nvoid build(int start,int end,int index=1){\n\tif(start==end){\n\t\tt[index]=0;\n\t\treturn ;\n\t}\n\tint mid = start+end >> 1;\n\tbuild(start,mid,index << 1);\n\tbuild(mid+1,end,index<<1|1);\n\tt[index] = doit(t[index<<1], t[index<<1|1]);\n}\n\nvoid propagate(int start,int end,int index){\n\tt[index] = (end-start+1)*lazy[index];\n\t// bcz leaf not hv childs\n\tif(start!=end){\n\t\tclazy[index<<1] = clazy[index<<1|1] = 1;\n\t\tlazy[index<<1] = lazy[index];\n\t\tlazy[index<<1|1] = lazy[index];\n\t}\n\tclazy[index]=0;\n}\n\nint Query(int start,int end,int l,int r,int index=1){\n\n\tif(clazy[index]==1){\n\t\tpropagate(start,end,index);\n\t}\n\t// out range\n\tif(r<start or end<l){\n\t\treturn 0;\n\t}\n\t// in Raange\n\tif( l<=start and end<=r){\n\t\treturn t[index];\n\t}\n\tint mid = start+end >>1;\n\treturn doit(Query(start,mid,l,r,index<<1), Query(mid+1,end,l,r,index<<1|1));\n}\n\nvoid pUpdate(int start,int end,int point,int val,int index=1){\n\tif(start==end){\n\t\tt[index]=val;\n\t\treturn ;\n\t}\n\tint mid = start+end>>1;\n\tif(point <= mid){\n\t\tpUpdate(start,mid,point,val,index<<1);\n\t}\n\telse{\n\t\tpUpdate(mid+1,end,point,val,index<<1|1);\n\t}\n\tt[index] = doit(t[index <<  1] , t[index << 1 | 1]);\n}\n\n\nvoid rangeUpdate(int start,int end,int l,int r,int val,int index){\n\tif(clazy[index]==1){\n\t\tpropagate(start,end,index);\n\t}\n\tif(l>end or r<start){\n\t\treturn;\n\t}\n\t// in range\n\tif(l<=start and end<=r){\n\t\tclazy[index]=1;\n\t\tlazy[index]=val;\n\t\tpropagate(start,end,index);\n\t\treturn;\n\t}\n\tint mid = start+end>>1;\n\trangeUpdate(start,mid,l,r,val,index<<1);\n\trangeUpdate(mid+1,end,l,r,val,index<<1|1);\n\tt[index] = doit(t[index<<1],t[index<<1|1]);\n}\n\n\n\n\nsigned main()\n{\n// \t#ifndef ONLINE_JUDGE\n// \t\tfreopen(\"./input.txt\",\"r\",stdin);\n// \t\tfreopen(\"./output.txt\",\"w\",stdout);\n// \t#endif\n\tios::sync_with_stdio(false); cin.tie(nullptr);\n\tcin>>n>>m;\n\tmemset(lazy,2,sizeof lazy);\n\t// fill(lazy,lazy+5*MAXN,2000);\n\tbuild(0,n-1);\n\tfor(int i=1; i<=m; i++){\n\t\tint q; cin>>q;\n\t\tif(q==1){\n\t\t\tint s,t; cin>>s>>t;\n\t\t\tcout<<Query(0,n-1,s,t,1); br;\n\t\t}\n\t\telse{\n\t\t\tint s,t,x; cin>>s>>t>>x;\n\t\t\trangeUpdate(0,n-1,s,t,x,1);\n\t\t}\n\t}\t\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cinttypes>\n#include <climits>\n#include <iostream>\n\ntemplate <typename Tp, typename Op>\nclass segment_tree{\n    Tp *value;\n    Op *operation;\n    size_t *width;\n    const size_t length;\n    const Tp vid;\n    const Op oid;\n    Tp (*const merger)(const Tp &lhs, const Tp &rhs);\n    Op (*const composition)(const Op &lhs, const Op &rhs);\n    Tp (*const action)(const Op &f, const Tp &x, size_t width);\n\n    void evaluate(size_t pos){\n        if(operation[pos] == oid) return;\n        if(pos < length){\n            operation[pos<<1 | 0] = composition(operation[pos], operation[pos<<1 | 0]);\n            operation[pos<<1 | 1] = composition(operation[pos], operation[pos<<1 | 1]);\n        }\n        value[pos] = action(operation[pos], value[pos], width[pos]);\n        operation[pos] = oid;\n    }\n    void propagate(size_t left, size_t right){\n        for(int i = sizeof(unsigned int) * CHAR_BIT - __builtin_clz(left ) - 1; i > 0; --i) evaluate(left  >> i);\n        for(int i = sizeof(unsigned int) * CHAR_BIT - __builtin_clz(right) - 1; i > 0; --i) evaluate(right >> i);\n    }\n    void update(size_t left, size_t right){\n        for(left  >>= __builtin_ctz(left ) + 1; left ; left  >>= 1){\n            evaluate(left <<1 | 0);\n            evaluate(left <<1 | 1);\n            value[left ] = merger(value[left <<1 | 0], value[left <<1 | 1]);\n        }\n        for(right >>= __builtin_ctz(right) + 1; right; right >>= 1){\n            evaluate(right <<1 | 0);\n            evaluate(right <<1 | 1);\n            value[right] = merger(value[right<<1 | 0], value[right<<1 | 1]);\n        }\n    }\npublic:\n    segment_tree(size_t n, Tp e, Tp(*const fold)(const Tp&, const Tp&), Op id, Op (*const compose)(const Op&, const Op&), Tp (*const apply)(const Op&, const Tp&, size_t))\n    : length(n), vid(e), oid(id), merger(fold), composition(compose), action(apply){\n        value     = new Tp[n<<1];\n        operation = new Op[n<<1];\n        width     = new size_t[n<<1];\n        for(size_t i = 1; i < (n<<1); ++i){ value[i] = e; operation[i] = id; width[i] = 1; }\n        for(size_t i = n - 1; i > 0; --i) width[i] = width[i<<1 | 0] + width[i<<1 | 1];\n    }\n    void set(size_t left, size_t right, Op f){\n        if(left >= right) return;\n        size_t l, r;\n        l = left  = left  + length;\n        r = right = right + length;\n        propagate(left, right);\n        while(l < r){\n            if(l & 1){ operation[l] = composition(f, operation[l]); ++l; }\n            l >>= 1;\n            if(r & 1){ --r; operation[r] = composition(f, operation[r]); }\n            r >>= 1;\n        }\n        update(left, right);\n    }\n    Tp get(size_t left, size_t right){        \n        if(left >= right) return vid;\n        left  += length;\n        right += length;\n        propagate(left, right);\n        Tp lval = vid, rval = vid;\n        while(left < right){\n            if(left  & 1){ evaluate(left ); lval = merger(lval, value[left ]); ++left ; }\n            left >>= 1;\n            if(right & 1){ --right; evaluate(right); rval = merger(value[right], rval); }\n            right >>= 1;\n        }\n        return merger(lval, rval);\n    }\n};\n\nint main(){\n    size_t n;\n    int q;\n    std::cin >> n >> q;\n\n    using Tp = int64_t;\n    using Op = int64_t;\n    segment_tree<Tp, Op> st{ n,\n        0, [](auto lhs, auto rhs){ return lhs + rhs; },\n        2000, [](auto lhs, auto rhs){ return lhs == 2000 ? rhs : lhs; }, [](auto f, auto x, size_t w)->Tp{ return f == 2000 ? x : f * w; } };\n    while(q--){\n        int tp, s, t, x;\n        std::cin >> tp;\n        if(tp == 0){\n            std::cin >> s >> t >> x;\n            st.set(s, t+1, x);\n        }else{\n            std::cin >> s >> t;\n            std::cout << st.get(s, t+1) << std::endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\n/*Starry Sky Tree*/\n/*Range Add Min(Max) Query*/\n/*区間加算、区間Min,区間Max*/\n\nclass RSUQ{\npublic: \n  \n  //遅延用の型  \n  struct T{\n    int type; //0 - empty   , 1 - update\n    int value;\n    T():type(0),value(0){}\n    T(int type,int value):type(type),value(value){}\n  };\n\n  //マージ可能な主データ型\n  struct D{\n    int value;\n    D():value(0){} /*適切な値にする!!!!!!*/\n    D(int value):value(value){}\n    bool operator < (D a)const {return value < a.value;} //merge用\n  };\n  \n  int n;\n  vector<D> dat;\n  vector<T> td;\n  D returnD = D(0); // 範囲外の時に返す値。\n  \n  RSUQ(){n=-1;}\n  RSUQ(int n_){\n    n=1;\n    while(n < n_) n *= 2;\n    td.resize(2*n-1,T());\n    dat.resize(2*n-1,D());\n  }\n  \n  D merge(D a,D b){return a.value + b.value;}\n  \n  void delay(int k,int len){\n    if(td[k].type==0) return;\n    int v = td[k].value;\n    td[k].type = 0;\n    td[k].value = 0;\n    \n    len /= 2;\n    int l = k*2+1,r = k*2+2;\n    dat[l].value = v * len; td[l].type = 1; td[l].value = v;\n    dat[r].value = v * len; td[r].type = 1; td[r].value = v;\n  }\n\n  D write(int k,int x, int len){\n    dat[k].value = x * len;\n    td[k].type = 1;\n    td[k].value = x;\n    return dat[k];\n  }\n  \n  //[a,b)の値をx変更　query(a,b,x)\n  D update(int a,int b,int x,bool flg=true,int k=0,int l=0,int r=-1){\n    if(r==-1) r=n, assert(a <= n && b <= n);\n    if(r <= a||b <= l) return flg? dat[k]:returnD;\n    if(a <= l && r <= b) return flg? write(k, x, r - l):dat[k];\n    \n    delay(k, r - l);\n    D vl = update(a,b,x,flg,k*2+1,l,(l+r)/2);\n    D vr = update(a,b,x,flg,k*2+2,(l+r)/2,r);\n    if(flg) dat[k] = merge(vl, vr);\n    return merge(vl, vr);\n  }\n  \n  //[a,b)の合計値を得る　find(a,b);\n  int find(int a,int b){\n    D res = update(a,b,0,false);\n    return res.value;\n  }\n};\n\n\nsigned main(){\n  int n,q;\n  cin>>n>>q;\n  \n  RSUQ rsuq(n);\n\n  while(q--){\n    int cmd;\n    cin>>cmd;\n    if(cmd == 0){\n      int s,t,x;\n      cin>>s>>t>>x;\n      rsuq.update(s,t+1,x);\n    }\n    if(cmd == 1){\n      int s,t;\n      cin>>s>>t;\n      cout<<rsuq.find(s,t+1)<<endl;\n    }\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\nusing int64 = long long;\n\n#define all(_) begin(_), end(_)\n#define rall(_) rbegin(_), rend(_)\n\ntemplate <class M, class OM, class F1, class F2, class F3>\nclass LazySegmentTree {\n public:\n  LazySegmentTree(const std::vector<M>& data, M ie, OM oie, F1 f1, F2 f2, F3 f3)\n      : ie_(ie), oie_(oie), data_(data), f1_(f1), f2_(f2), f3_(f3) {\n    build();\n  }\n\n  void modify(int l, int r, OM val) {\n    if (l >= r) return;\n    thrust(l += n_);\n    thrust(r += n_ - 1);\n    for (int cl = l, cr = r + 1; cl < cr; cl >>= 1, cr >>= 1) {\n      if (cl & 1) lazy_[cl] = f3_(lazy_[cl], val), ++cl;\n      if (cr & 1) --cr, lazy_[cr] = f3_(lazy_[cr], val);\n    }\n    recalc(l);\n    recalc(r);\n  }\n\n  M get(int l, int r) {\n    if (l >= r) return ie_;\n    thrust(l + n_);\n    thrust(r + n_ - 1);\n    M vl = ie_, vr = ie_;\n    for (l += n_, r += n_; l < r; l >>= 1, r >>= 1) {\n      if (l & 1) vl = f1_(vl, apply(l++));\n      if (r & 1) vr = f1_(apply(--r), vr);\n    }\n    return f1_(vl, vr);\n  }\n\n private:\n  int n_, h_;\n  std::vector<M> data_;\n  std::vector<M> node_;\n  std::vector<OM> lazy_;\n  M ie_;\n  OM oie_;\n  F1 f1_;\n  F2 f2_;\n  F3 f3_;\n\n  void build() {\n    int sz = data_.size();\n    n_ = 1, h_ = 0;\n    while (n_ < sz) n_ <<= 1, ++h_;\n    node_.assign(2 * n_, ie_);\n    lazy_.assign(2 * n_, oie_);\n    for (int i = 0; i < sz; ++i) node_[i + n_] = data_[i];\n    for (int i = n_ - 1; i > 0; --i) node_[i] = f1_(node_[2 * i], node_[2 * i + 1]);\n  }\n\n  inline void propagate(int pos) {\n    if (lazy_[pos] != oie_) {\n      lazy_[2 * pos] = f3_(lazy_[2 * pos], lazy_[pos]);\n      lazy_[2 * pos + 1] = f3_(lazy_[2 * pos + 1], lazy_[pos]);\n      node_[pos] = apply(pos);\n      lazy_[pos] = oie_;\n    }\n  }\n\n  inline M apply(int pos) {\n    if (lazy_[pos] == oie_) {\n      return node_[pos];\n    } else {\n      return f2_(node_[pos], lazy_[pos]);\n    }\n  }\n\n  inline void recalc(int pos) {\n    while (pos >>= 1) node_[pos] = f1_(apply(2 * pos), apply(2 * pos + 1));\n  }\n\n  inline void thrust(int pos) {\n    for (int i = h_; i > 0; --i) propagate(pos >> i);\n  }\n};\n\n// RMQ and RUQ\nvoid DSL_2_F() {\n  int n, q; cin >> n >> q;\n  auto f1 = [](int e1, int e2){ return min(e1, e2); };\n  auto f2 = [](int e, int x){ return x; };\n  auto f3 = [](int x1, int x2){ return x2; };\n  constexpr int inf = 2147483647;\n  vector<int> v(n, inf);\n  LazySegmentTree<int, int, decltype(f1), decltype(f2), decltype(f3)> seg(v, inf, -1, f1, f2, f3);\n  while (q--) {\n    int op; cin >> op;\n    if (op == 0) {\n      int s, t, x; cin >> s >> t >> x;\n      seg.modify(s, t + 1, x);\n    } else {\n      int s, t; cin >> s >> t;\n      cout << seg.get(s, t + 1) << '\\n';\n    }\n  }\n}\n\n// RSQ and RAQ\nvoid DSL_2_G() {\n  int n, q; cin >> n >> q;\n  struct Node {\n    int64 val, len;\n  };\n  auto f1 = [](Node e1, Node e2) { return (Node){e1.val + e2.val, e1.len + e2.len}; };\n  auto f2 = [](Node e, int64 x){ return (Node){e.val + e.len * x, e.len}; };\n  auto f3 = [](int64 x1, int64 x2){ return x1 + x2; };\n  vector<Node> v(n, (Node){0, 1});\n  LazySegmentTree<Node, int64, decltype(f1), decltype(f2), decltype(f3)> seg(v, (Node){0, 1}, 0, f1, f2, f3);\n  while (q--) {\n    int op; cin >> op;\n    if (op == 0) {\n      int s, t; int64 x; cin >> s >> t >> x;\n      seg.modify(s - 1, t, x);\n    } else {\n      int s, t; cin >> s >> t;\n      cout << seg.get(s - 1, t).val << '\\n';\n    }\n  }\n}\n\n// RMQ and RAQ\nvoid DSL_2_H() {\n  int n, q; cin >> n >> q;\n  auto f1 = [](int e1, int e2){ return min(e1, e2); };\n  auto f2 = [](int e, int x){ return e + x; };\n  auto f3 = [](int x1, int x2){ return x1 + x2; };\n  constexpr int inf = (int)1e9;\n  vector<int> v(n, 0);\n  LazySegmentTree<int, int, decltype(f1), decltype(f2), decltype(f3)> seg(v, inf, 0, f1, f2, f3);\n  while (q--) {\n    int op; cin >> op;\n    if (op == 0) {\n      int s, t, x; cin >> s >> t >> x;\n      seg.modify(s, t + 1, x);\n    } else {\n      int s, t; cin >> s >> t;\n      cout << seg.get(s, t + 1) << '\\n';\n    }\n  }\n}\n\n// RSQ and RUQ\nvoid DSL_2_I() {\n  int n, q; cin >> n >> q;\n  struct Node {\n    int64 val, len;\n  };\n  auto f1 = [](Node e1, Node e2) { return (Node){e1.val + e2.val, e1.len + e2.len}; };\n  auto f2 = [](Node e, int64 x){ return (Node){e.len * x, e.len}; };\n  auto f3 = [](int64 x1, int64 x2){ return x2; };\n  vector<Node> v(n, (Node){0, 1});\n  LazySegmentTree<Node, int64, decltype(f1), decltype(f2), decltype(f3)> seg(v, (Node){0, 1}, -(int64)1e18, f1, f2, f3);\n  while (q--) {\n    int op; cin >> op;\n    if (op == 0) {\n      int s, t; int64 x; cin >> s >> t >> x;\n      seg.modify(s, t + 1, x);\n    } else {\n      int s, t; cin >> s >> t;\n      cout << seg.get(s, t + 1).val << '\\n';\n    }\n  }\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  //DSL_2_F();\n  //DSL_2_G();\n  //DSL_2_H();\n  DSL_2_I();\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing vi = vector<int>; using vvi = vector<vi>; using vvvi = vector<vvi>;\nusing ll = long long int;\nusing vll = vector<ll>; using vvll = vector<vll>; using vvvll = vector<vvll>;\nusing vd = vector<double>; using vvd = vector<vd>; using vvvd = vector<vvd>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing cdouble = complex<double>;\n\nconst double eps = 1e-7;\n#define Loop(i, n) for(int i = 0; i < int(n); i++)\n#define Loopll(i, n) for(ll i = 0; i < ll(n); i++)\n#define Loop1(i, n) for(int i = 1; i <= int(n); i++)\n#define Loopll1(i, n) for(ll i = 1; i <= ll(n); i++)\n#define Loopr(i, n) for(int i = int(n) - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = ll(n) - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = int(n); i >= 1; i--)\n#define Looprll1(i, n) for(ll i = ll(n); i >= 1; i--)\n#define Foreach(buf, container) for(const auto &buf : container)\n#define Loopdiag(i, j, h, w, sum) for(int i = ((sum) >= (h) ? (h) - 1 : (sum)), j = (sum) - i; i >= 0 && j < (w); i--, j++)\n#define Loopdiagr(i, j, h, w, sum) for(int j = ((sum) >= (w) ? (w) - 1 : (sum)), i = (sum) - j; j >= 0 && i < (h); j--, i++)\n#define Loopdiagsym(i, j, h, w, gap) for (int i = ((gap) >= 0 ? (gap) : 0), j = i - (gap); i < (h) && j < (w); i++, j++)\n#define Loopdiagsymr(i, j, h, w, gap) for (int i = ((gap) > (h) - (w) - 1 ? (h) - 1 : (w) - 1 + (gap)), j = i - (gap); i >= 0 && j >= 0; i--, j--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(ex_i, vector.size()) { cout << vector[ex_i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(ex_i, matrix.size()) { Loop(ex_j, matrix[ex_i].size()) { cout << matrix[ex_i][ex_j] << \" \"; } cout << endl; }\n#define quickio() ios::sync_with_stdio(false); cin.tie(0);\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\n#define Comp(type_t) bool operator<(const type_t &another) const\n#define fst first\n#define snd second\n#define INF INFINITY\nbool feq(double x, double y) { return abs(x - y) <= eps; }\nbool inrange(ll x, ll t) { return x >= 0 && x < t; }\nbool inrange(vll xs, ll t) { Foreach(x, xs) if (!(x >= 0 && x < t)) return false; return true; }\nint ceillog2(ll x) { return int(ceil(log2(x))); }\nint floorlog2(ll x) { return int(floor(log2(x))); }\nll rndf(double x) { return (ll)(x + (x >= 0 ? 0.5 : -0.5)); }\nll floorsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (m * m <= x ? 0 : -1); }\nll ceilsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (x <= m * m ? 0 : 1); }\nll rnddiv(ll a, ll b) { return (a / b + (a % b * 2 >= b ? 1 : 0)); }\nll ceildiv(ll a, ll b) { return (a / b + (a % b == 0 ? 0 : 1)); }\nll gcd(ll m, ll n) { if (n == 0) return m; else return gcd(n, m % n); }\nll lcm(ll m, ll n) { return m * n / gcd(m, n); }\n\n//========================================================================//\n\nclass SegTreeSum {\n\tusing val_t = ll;\nprivate:\n\tstruct segval_t {\n\t\tbool enable;\n\t\tval_t upd, add, sum;\n\t};\n\tint n, N; // n is the original size, while N is the extended size\n\tint base;\n\tvector<segval_t> nodes;\n\tvi idl, idr, cover_size;\n\tvoid merge(int id) {\n\t\tnodes[id].sum = nodes[idl[id]].sum + nodes[idl[id]].add * cover_size[idl[id]]\n\t\t\t+ nodes[idr[id]].sum + nodes[idr[id]].add * cover_size[idr[id]];\n\t}\n\tvoid lazy(int id) {\n\t\tif (id >= base) return;\n\t\tif (nodes[id].enable) {\n\t\t\tval_t upd = nodes[id].upd + nodes[id].add;\n\t\t\tnodes[idl[id]] = { true, upd, 0, upd * cover_size[idl[id]] };\n\t\t\tnodes[idr[id]] = { true, upd, 0, upd * cover_size[idr[id]] };\n\t\t\tnodes[id] = { false, 0, 0, upd * cover_size[id] };\n\t\t}\n\t\telse {\n\t\t\tnodes[idl[id]].add += nodes[id].add;\n\t\t\tnodes[idr[id]].add += nodes[id].add;\n\t\t\tnodes[id].add = 0;\n\t\t\tmerge(id);\n\t\t}\n\t}\n\tenum change_t {\n\t\tUPD, ADD\n\t};\n\tvoid change_rec(int s, int t, int l, int r, int id, val_t x, change_t op) {\n\t\tif (s == l && t == r) {\n\t\t\tif (op == UPD) nodes[id] = { true, x, 0, x * cover_size[id] };\n\t\t\telse if (op == ADD) nodes[id].add += x;\n\t\t}\n\t\telse {\n\t\t\tlazy(id);\n\t\t\tint m = (l + r) >> 1;\n\t\t\tif (s < m && m < t) {\n\t\t\t\tchange_rec(s, m, l, m, idl[id], x, op);\n\t\t\t\tchange_rec(m, t, m, r, idr[id], x, op);\n\t\t\t}\n\t\t\telse if (s < m) {\n\t\t\t\tchange_rec(s, t, l, m, idl[id], x, op);\n\t\t\t}\n\t\t\telse if (m < t) {\n\t\t\t\tchange_rec(s, t, m, r, idr[id], x, op);\n\t\t\t}\n\t\t\tmerge(id);\n\t\t}\n\t}\n\tval_t solve_rec(int s, int t, int l, int r, int id) {\n\t\tval_t v = 0;\n\t\tif (s == l && t == r) {\n\t\t\tv = nodes[id].sum;\n\t\t}\n\t\telse {\n\t\t\tlazy(id);\n\t\t\tint m = (l + r) >> 1;\n\t\t\tif (s < m && m < t) {\n\t\t\t\tval_t v0 = solve_rec(s, m, l, m, idl[id]);\n\t\t\t\tval_t v1 = solve_rec(m, t, m, r, idr[id]);\n\t\t\t\tv = v0 + v1;\n\t\t\t}\n\t\t\telse if (s < m) {\n\t\t\t\tv = solve_rec(s, t, l, m, idl[id]);\n\t\t\t}\n\t\t\telse if (m < t) {\n\t\t\t\tv = solve_rec(s, t, m, r, idr[id]);\n\t\t\t}\n\t\t}\n\t\tv += nodes[id].add * (t - s);\n\t\treturn v;\n\t}\n\tvoid common_init() {\n\t\tidl.resize(base + N, -1);\n\t\tidr.resize(base + N, -1);\n\t\tLoop(i, base) {\n\t\t\tidl[i] = (i << 1) + 1;\n\t\t\tidr[i] = (i << 1) + 2;\n\t\t}\n\t\tcover_size.resize(base + N);\n\t\tLoop(i, n) {\n\t\t\tcover_size[base + i] = 1;\n\t\t}\n\t\tLoopr(i, base) {\n\t\t\tcover_size[i] = cover_size[idl[i]] + cover_size[idr[i]];\n\t\t}\n\t}\npublic:\n\tSegTreeSum(int n, val_t init = 0) {\n\t\tthis->n = n;\n\t\tN = 1 << ceillog2(n);\n\t\tbase = N - 1;\n\t\tnodes = vector<segval_t>(base + N, { false, 0, 0, 0 });\n\t\tcommon_init();\n\t\tupd(0, n, init);\n\t}\n\tSegTreeSum(const vector<val_t> &a) {\n\t\tthis->n = a.size();\n\t\tN = 1 << ceillog2(n);\n\t\tbase = N - 1;\n\t\tnodes = vector<segval_t>(base + N, { false, 0, 0, 0 });\n\t\tcommon_init();\n\t\tLoop(i, n) {\n\t\t\tnodes[base + i] = { true, a[i], 0, a[i] };\n\t\t}\n\t\tLoopr(i, base) {\n\t\t\tmerge(i);\n\t\t}\n\t}\n\tvoid upd(int s, int t, val_t x) {\n\t\tchange_rec(s, t, 0, N, 0, x, UPD);\n\t}\n\tvoid add(int s, int t, val_t x) {\n\t\tchange_rec(s, t, 0, N, 0, x, ADD);\n\t}\n\tval_t sumof(int s, int t) {\n\t\treturn solve_rec(s, t, 0, N, 0);\n\t}\n};\n\nint main() {\n\tquickio();\n\tint n, q; cin >> n >> q;\n\tSegTreeSum st(n);\n\tLoop(_, q) {\n\t\tint op; cin >> op;\n\t\tint s, t; cin >> s >> t; t++;\n\t\tif (op == 0) {\n\t\t\tll x; cin >> x;\n\t\t\tst.upd(s, t, x);\n\t\t}\n\t\telse {\n\t\t\tcout << st.sumof(s, t) << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass segment_tree{\n    vector<int64_t> val;\n    vector<pair<int64_t, int64_t>> op;\n    vector<pair<size_t, size_t>> range;\n\n    size_t N, depth;\n\n    void merge(size_t target, int64_t alpha, int64_t beta){\n        op[target] = {op[target].first * alpha, op[target].second * alpha + beta};\n    }\n    void propagate(size_t target){\n        // min, max -> width = 1\n        val[target] = op[target].first * val[target] + op[target].second * (range[target].second - range[target].first);\n        if(target  < N){\n            merge(2*target, op[target].first, op[target].second);\n            merge(2*target+1, op[target].first, op[target].second);\n        }\n        op[target] = {1, 0};\n    }\n    \n    void eval(int n){\n        stack<size_t> stk;\n        for(;n>0;n>>=1) stk.push(n);\n        while(!stk.empty()){\n            propagate(stk.top());\n            stk.pop();\n        }\n    }\n    void get_target(vector<size_t> &target, size_t left, size_t right, stack<size_t> *refresh=nullptr){\n        queue<size_t> partial;\n        \n        if(left <= 0 && right >= N) target.push_back(1);\n        else partial.push(1);\n\n        while(!partial.empty()){\n            size_t i = partial.front();\n            if(refresh != nullptr) refresh->push(i);\n            partial.pop();\n\n            propagate(i);\n\n            if(left <= range[i].first){\n                if(right < range[i*2].second) partial.push(i*2);\n                else{\n                    target.push_back(i*2);\n                    if(range[i*2+1].first < right) partial.push(i*2+1);\n                }\n            }else{\n                if(left < range[i*2].second){\n                    partial.push(i*2);\n                    if(range[i*2+1].second <= right) target.push_back(i*2+1);\n                    else if(range[i*2].second < right) partial.push(i*2+1); \n                }else{\n                    if(left <= range[i*2+1].first && range[i*2+1].second <= right) target.push_back(i*2+1);\n                    else partial.push(i*2+1);\n                }\n            }\n        }\n    }\npublic:\n    segment_tree(size_t n){\n        for(depth=0;(1ULL<<depth)<n;depth++);\n        N = 1ULL<<depth;\n        val.reserve(1ULL<<(++depth));\n        op.reserve(1ULL<<depth);\n        range.reserve(1ULL<<depth);\n        for(size_t i=2*N-1;i>0;i--){\n            if(i>=N) range[i] = {i-N, i-N+1};\n            else range[i] = {range[2*i].first, range[2*i+1].second};\n        }\n    }\n    int64_t operator[](size_t i){\n        eval(N+i);\n        return val[N+i];\n    }\n    void operate(int64_t alpha, int64_t beta, size_t left, size_t right){\n        if(right <= left) return;\n\n        vector<size_t> target;\n        stack<size_t> refresh;\n        get_target(target, left, right, &refresh);\n        for(auto i : target){\n            merge(i, alpha, beta);\n            propagate(i);\n        }\n        while(!refresh.empty()){\n            size_t i = refresh.top();\n            refresh.pop();\n            //min, max -> change\n            propagate(i*2);\n            propagate(i*2+1);\n            val[i] = val[i*2] + val[i*2+1];\n        }\n    }\n    int64_t get_sum(size_t left, size_t right){\n        if(right <= left) return 0;\n        \n        vector<size_t> target;\n        get_target(target, left, right);\n        int64_t ret = 0;\n        for(auto i : target){\n            ret += op[i].first * val[i] + op[i].second * (range[i].second - range[i].first);\n        }\n        return ret;\n    }\n    void update(int64_t val, size_t pos){\n        operate(0, val, pos, pos+1);\n    }\n    void update(int64_t val, size_t left, size_t right){\n        operate(0, val, left, right);\n    }\n    void add(int64_t val, size_t pos){\n        operate(1, val, pos, pos+1);\n    }\n    void add(int64_t val, size_t left, size_t right){\n        operate(1, val, left, right);\n    }\n\n    void dump(){\n        for(int i=1;i<2*N;i++){\n            eval(i);\n            cerr << val[i] << \" \";\n        }\n        cerr << endl;\n    }\n};\n\nint main(){\n    int n, q;\n    cin >> n >> q;\n    segment_tree st(n);\n\n    for(int i=0;i<q;i++){\n        int com;\n        cin >> com;\n        if(com == 0){\n            int s, t, x;\n            cin >> s >> t >> x;\n            st.update(x, s, t+1);\n        }else{\n            int s, t;\n            cin >> s >> t;\n            cout << st.get_sum(s, t+1) << endl;\n        }\n        //st.dump();\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <limits>\n#include <memory>\n#include <utility>\n#include <vector>\nusing namespace std;\nusing ll = long long;\n\n// ----- SegTree -----\n// Referring to the following great materials.\n//  - tsutaj-san's article: https://tsutaj.hatenablog.com/entry/2017/03/30/224339\n//  - drken-san's article: https://drken1215.hatenablog.com/entry/2019/02/19/110200\n//  - tsutaj-san's libary: https://tsutaj.github.io/cpp_library/library/structure/strc_021_dynamic_lazy_segtree.cpp.html\n// Many thanks to them.\n\ntemplate <typename Monoid, typename Action>\nclass SegTree\n{\n  struct SegNode\n  {\n    bool need_update;\n    unique_ptr<SegNode> left, right;\n    Monoid value;\n    Action lazy_value;\n\n    SegNode() {}\n    SegNode(Monoid value, Action lazy_value) : need_update{false}, left{nullptr}, right{nullptr}, value{value}, lazy_value{lazy_value} {}\n  };\n\n  using FuncAction = function<void(Monoid &, Action)>;\n  using FuncMonoid = function<Monoid(Monoid, Monoid)>;\n  using FuncLazy = function<void(Action &, Action)>;\n  using FuncIndex = function<Action(Action, int)>;\n\n  // fields\n  int N;\n  unique_ptr<SegNode> root;\n  // unities\n  Monoid unity_monoid;\n  Action unity_action;\n  // functions\n  FuncAction func_update;\n  FuncMonoid func_combine;\n  FuncLazy func_lazy;\n  FuncIndex func_accumulate;\n\npublic:\n  SegTree() {}\n  SegTree(int n, Monoid unity_monoid, Action unity_action, FuncAction func_update, FuncMonoid func_combine, FuncLazy func_lazy, FuncIndex func_accumulate) : N{1}, root{make_unique<SegNode>(unity_monoid, unity_action)}, unity_monoid(unity_monoid), unity_action(unity_action), func_update(func_update), func_combine(func_combine), func_lazy(func_lazy), func_accumulate(func_accumulate)\n  {\n    while (N < n)\n    {\n      N <<= 1;\n    }\n  }\n\n  void update(int a, int b, Action const &x) { update(root.get(), a, b, x, 0, N); }\n  void update(int a, Action const &x) { update(a, a + 1, x); }\n  Monoid query(int a, int b) { return query(root.get(), a, b, 0, N); }\n  Monoid query(int a) { return query(a, a + 1); }\n  Monoid operator[](size_t i) { return query(static_cast<int>(i)); }\n\nprivate:\n  void node_maker(unique_ptr<SegNode> &pt) const\n  {\n    if (!pt)\n    {\n      pt = make_unique<SegNode>(unity_monoid, unity_action);\n    }\n  }\n\n  void evaluate(SegNode *node, int l, int r)\n  {\n    if (!node->need_update)\n    {\n      return;\n    }\n    func_update(node->value, func_accumulate(node->lazy_value, r - l));\n    if (r - l > 1)\n    {\n      node_maker(node->left);\n      func_lazy(node->left->lazy_value, node->lazy_value);\n      node->left->need_update = true;\n      node_maker(node->right);\n      func_lazy(node->right->lazy_value, node->lazy_value);\n      node->right->need_update = true;\n    }\n    node->lazy_value = unity_action;\n    node->need_update = false;\n  }\n\n  void update(SegNode *node, int a, int b, Action const &x, int l, int r)\n  {\n    evaluate(node, l, r);\n    if (b <= l || r <= a)\n    {\n      return;\n    }\n    if (a <= l && r <= b)\n    {\n      func_lazy(node->lazy_value, x);\n      node->need_update = true;\n      evaluate(node, l, r);\n    }\n    else\n    {\n      auto mid{(l + r) >> 1};\n      node_maker(node->left);\n      update(node->left.get(), a, b, x, l, mid);\n      node_maker(node->right);\n      update(node->right.get(), a, b, x, mid, r);\n      node->value = func_combine(node->left->value, node->right->value);\n    }\n  }\n\n  Monoid query(SegNode *node, int a, int b, int l, int r)\n  {\n    if (b <= l || r <= a)\n    {\n      return unity_monoid;\n    }\n    evaluate(node, l, r);\n    if (a <= l && r <= b)\n    {\n      return node->value;\n    }\n    auto mid{(l + r) >> 1};\n    auto vl{(node->left ? query(node->left.get(), a, b, l, mid) : unity_monoid)};\n    auto vr{(node->right ? query(node->right.get(), a, b, mid, r) : unity_monoid)};\n    return func_combine(vl, vr);\n  }\n};\n\n// ----- RangePlusQuery -----\n//  - update(i, x) : a[i] += x;,\n//  - update(s, t, x) : a[i] += x; for all i \\in [s, t),\n//  - query(i) : return a[i];,\n//  - query(s, t) : return the sum a[i] where i runs on [s, t).\n\n// ----- RangeSumQuery -----\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_B&lang=ja\n//  - update(i, x) : a[i] += x;,\n//  - query(s, t) : return the sum a[i] where i runs on [s, t).\n\n// ----- RangeAddQuery -----\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_E&lang=ja\n//  - update(s, t, x) : a[i] += x; for all i \\in [s, t),\n//  - query(i) : return a[i].\n\n// ----- RSU_RAU -----\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_G&lang=ja\n//  - update(s, t, x) : a[i] += x; for all i \\in [s, t),\n//  - query(s, t) : return the sum a[i] where i runs on [s, t).\n\ntemplate <typename Monoid>\nSegTree<Monoid, Monoid> RangePlusQuery(int N, Monoid const &monoid_zero)\n{\n  using Action = Monoid;\n  return SegTree<Monoid, Action>{\n      N, monoid_zero, monoid_zero,\n      [](Monoid &x, Action y) { x += y; },\n      [](Monoid x, Monoid y) { return x + y; },\n      [](Action &x, Action y) { return x += y; },\n      [](Action x, int y) { return x * y; }};\n}\n\ntemplate <typename Monoid>\nSegTree<Monoid, Monoid> RangePlusQuery(int N)\n{\n  return RangePlusQuery<Monoid>(N, 0);\n}\n\n// ----- RangeMinQuery -----\n//  - update(i, x) : a[i] = x;,\n//  - update(s, t, x) : a[i] = x; for all i \\in [s, t),\n//  - query(i) : return a[i];,\n//  - query(s, t) : return the minimum of a[i] where i runs on [s, t).\n\n// ----- RangeMinimumQuery -----\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_A&lang=ja\n//  - update(i, x) : a[i] = x;,\n//  - query(s, t) : return the minimum of a[i] where i runs on [s, t).\n\n// ----- RangeUpdateQuery -----\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_D&lang=ja\n//  - update(s, t, x) : a[i] = x; for all i \\in [s, t),\n//  - query(i) : return a[i].\n\n// ----- RMQ_RUQ -----\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_F&lang=ja\n//  - update(s, t, x) : a[i] = x; for all i \\in [s, t),\n//  - query(s, t) : return the minimum of a[i] where i runs on [s, t).\n\ntemplate <typename Monoid>\nSegTree<Monoid, Monoid> RangeMinQuery(int N, Monoid const &monoid_infty)\n{\n  using Action = Monoid;\n  return SegTree<Monoid, Action>{\n      N, monoid_infty, monoid_infty,\n      [](Monoid &x, Action y) { x = y; },\n      [](Monoid x, Monoid y) { return min(x, y); },\n      [](Action &x, Action y) { return x = y; },\n      [](Action x, int) { return x; }};\n}\n\ntemplate <typename Monoid>\nSegTree<Monoid, Monoid> RangeMinQuery(int N)\n{\n  return RangeMinQuery<Monoid>(N, numeric_limits<Monoid>::max());\n}\n\n// ----- RMQ_RAQ -----\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_H&lang=ja\n//  - update(s, t, x) : a[i] += x; for all i \\in [s, t),\n//  - query(s, t) : return the minimum of a[i] where i runs on [s, t).\n// update should be called as follows.\n// tree.update(s, t, make_tuple(x, true));\n\ntemplate <typename Monoid>\nSegTree<Monoid, tuple<Monoid, bool>> RMQ_RAQ(int N, Monoid const &ring_zero, Monoid const &ring_infty)\n{\n  using Action = tuple<Monoid, bool>;\n  auto tree{SegTree<Monoid, Action>{\n      N, ring_infty, Action{ring_zero, true},\n      [](Monoid &x, Action y) {\n        if (get<1>(y))\n        {\n          x += get<0>(y);\n        }\n        else\n        {\n          x = get<0>(y);\n        }\n      },\n      [](Monoid x, Monoid y) { return min(x, y); },\n      [](Action &x, Action y) {\n        if (get<1>(y))\n        {\n          get<0>(x) += get<0>(y);\n        }\n        else\n        {\n          x = y;\n        }\n      },\n      [](Action x, int) { return x; }}};\n  tree.update(0, N, Action{ring_zero, false});\n  return tree;\n}\n\ntemplate <typename Monoid>\nSegTree<Monoid, tuple<Monoid, bool>> RMQ_RAQ(int N)\n{\n  return RMQ_RAQ<Monoid>(N, 0, numeric_limits<Monoid>::max());\n}\n\n// ----- RSQ_RUQ -----\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_I&lang=ja\n//  - update(s, t, x) : a[i] = x; for all i \\in [s, t),\n//  - query(s, t) : return the sum of a[i] where i runs on [s, t).\n\ntemplate <typename Monoid>\nSegTree<Monoid, Monoid> RSQ_RUQ(int N, Monoid const &monoid_zero)\n{\n  using Action = Monoid;\n  return SegTree<Monoid, Action>{\n      N, monoid_zero, monoid_zero,\n      [](Monoid &x, Action y) { x = y; },\n      [](Monoid x, Monoid y) { return x + y; },\n      [](Action &x, Action y) { return x = y; },\n      [](Action x, int y) { return x * y; }};\n}\n\ntemplate <typename Monoid>\nSegTree<Monoid, Monoid> RSQ_RUQ(int N)\n{\n  return RSQ_RUQ<Monoid>(N, 0);\n}\n\nint main()\n{\n  int N;\n  cin >> N;\n  auto tree{RSQ_RUQ<ll>(N)};\n  int Q;\n  cin >> Q;\n  for (auto q{0}; q < Q; ++q)\n  {\n    int t;\n    cin >> t;\n    if (t == 0)\n    {\n      int s, t;\n      ll x;\n      cin >> s >> t >> x;\n      tree.update(s, t + 1, x);\n    }\n    else\n    {\n      int s, t;\n      cin >> s >> t;\n      cout << tree.query(s, t + 1) << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/2/DSL_2_I\n#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n#define NUM 100000\n\nint N = 1;\nint value[4*NUM];\n\nvoid init(int first_N){\n\twhile(N < first_N)N *= 2;\n}\n\nvoid update(int update_left,int update_right,int new_value,int node_id,int node_left,int node_right){\n\tif(update_right < node_left || update_left > node_right)return;\n\telse if(update_left <= node_left && update_right >= node_right){\n\t\tvalue[node_id] = new_value;\n\t}else{\n\t\tif(value[node_id] != -BIG_NUM){\n\t\t\tvalue[2*node_id+1] = value[node_id];\n\t\t\tvalue[2*node_id+2] = value[node_id];\n\t\t\tvalue[node_id] = -BIG_NUM;\n\t\t}\n\t\tupdate(update_left,update_right,new_value,2*node_id+1,node_left,(node_left+node_right)/2);\n\t\tupdate(update_left,update_right,new_value,2*node_id+2,(node_left+node_right)/2+1,node_right);\n\t}\n}\n\nint getSum(int search_left,int search_right,int node_id,int node_left,int node_right){\n\tif(search_right < node_left || search_left > node_right){\n\t\treturn 0;\n\t}else{\n\t\tif(value[node_id] == -BIG_NUM){\n\t\t\tint left = getSum(search_left,search_right,2*node_id+1,node_left,(node_left+node_right)/2);\n\t\t\tint right = getSum(search_left,search_right,2*node_id+2,(node_left+node_right)/2+1,node_right);\n\t\t\treturn left+right;\n\t\t}else{\n\t\t\treturn (min(search_right,node_right)-max(search_left,node_left)+1)*value[node_id];\n\t\t}\n\t}\n}\n\n\nint main(){\n\n\tint n,q; cin >> n >> q;\n\n\tinit(n);\n\n\tfor(int i = 0; i <= 2*N-2; i++) value[i] = 0;\n\n\tint command,left,right,value;\n\n\tfor(int loop = 0; loop < q; loop++){\n\t\tcin >> command;\n\n\t\tif(command == 0){ //update\n\t\t\tcin >> left >> right >> value;\n\t\t\tupdate(left,right,value,0,0,N-1);\n\t\t}else{\n\t\t\tcin >> left >> right;\n\t\t\tcout << getSum(left,right,0,0,N-1) << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a) {\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n    out<<'[';\n    for(const T &i: a) out<<i<<',';\n    out<<']';\n    return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out, const set<T>& a) {\n    out<<'{';\n    for(const T &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\ntemplate<class T, class S>\nostream &operator <<(ostream& out, const map<T,S>& a) {\n    out<<'{';\n    for(auto &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\ntemplate <typename Monoid>\nstruct lazysegtree {\n    using T = typename Monoid::T;\n    using E = typename Monoid::E;\n    int n, height;\n    vector<T> dat;\n    vector<E> lazy;\n\n    lazysegtree() {}\n    lazysegtree(int n_) {\n        n = 1, height = 0;\n        while(n < n_) { n *= 2; height++; }\n        dat.assign(n*2, Monoid::dt());\n        lazy.assign(n*2, Monoid::de());\n    }\n    void build(vector<T> v) {\n        REP(i, v.size()) dat[i+n] = v[i];\n        for(int i=n-1; i>0; --i) dat[i] = Monoid::f(dat[i*2], dat[i*2+1]);\n    }\n\n    inline T reflect(int k) { return lazy[k]==Monoid::de()?dat[k]:Monoid::g(dat[k], lazy[k]); }\n    inline void eval(int k) {\n        if(lazy[k] == Monoid::de()) return;\n        lazy[2*k]   = Monoid::h(lazy[k*2],   lazy[k]);\n        lazy[2*k+1] = Monoid::h(lazy[k*2+1], lazy[k]);\n        dat[k] = reflect(k);\n        lazy[k] = Monoid::de();\n    }\n    inline void thrust(int k) { for(int i=height;i;--i) eval(k>>i); }\n    inline void recalc(int k) { while(k>>=1) dat[k] = Monoid::f(reflect(k*2), reflect(k*2+1)); }\n\n    void update(int a, int b, E x) {\n        thrust(a+=n);\n        thrust(b+=n-1);\n        for(int l=a, r=b+1; l<r; l>>=1,r>>=1) {\n            if(l&1) lazy[l] = Monoid::h(lazy[l], x), ++l;\n            if(r&1) --r, lazy[r] = Monoid::h(lazy[r], x);\n        }\n        recalc(a);\n        recalc(b);\n    }\n    T query(int a, int b) {\n        thrust(a+=n);\n        thrust(b+=n-1);\n        T vl=Monoid::dt(), vr=Monoid::dt();\n        for(int l=a, r=b+1; l<r; l>>=1,r>>=1) {\n            if(l&1) vl=Monoid::f(vl, reflect(l++));\n            if(r&1) vr=Monoid::f(reflect(--r), vr);\n        }\n        return Monoid::f(vl, vr);\n    }\n\n    friend ostream &operator <<(ostream& out,const lazysegtree<Monoid>& seg) {\n        out << \"---------------------\" << endl;\n        int cnt = 1;\n        for(int i=1; i<=seg.n; i*=2) {\n            REP(j, i) {\n                out << \"(\" << seg.dat[cnt] << \",\" << seg.lazy[cnt] << \") \";\n                cnt++;\n            }\n            out << endl;\n        }\n        out << \"---------------------\" << endl;\n        return out;\n    }\n};\n\nstruct update_min {\n    using T = ll;\n    using E = ll;\n    static constexpr T dt() { return INT_MAX; }\n    static constexpr E de() { return INT_MAX; }\n    static T f(const T &a, const T &b) { return min(a, b); }\n    static T g(const T &a, const E &b) { return b; }\n    static E h(const E &a, const E &b) { return b; }\n};\nstruct add_sum {\n    using T = PII;  // (頂点の値, 頂点の区間長)\n    using E = ll;\n    static constexpr T dt() { return PII(0,0); }\n    static constexpr E de() { return 0; }\n    static T f(const T &a, const T &b) { return PII(a.first+b.first, a.second+b.second); }\n    static T g(const T &a, const E &b) { return PII(a.first+b*a.second, a.second); }\n    static E h(const E &a, const E &b) { return a+b; }\n};\nstruct update_sum {\n    using T = PII;\n    using E = ll;\n    static constexpr T dt() { return PII(0, 0); }\n    static constexpr E de() { return 0; }\n    static T f(const T &a, const T &b) { return PII(a.first+b.first,a.second+b.second); }\n    static T g(const T &a, const E &b) { return PII(b*a.second, a.second); }\n    static E h(const E &a, const E &b) { return b; }\n};\nstruct add_min {\n    using T = PII;  // (頂点の値, 頂点の区間長)\n    using E = ll;\n    static constexpr T dt() { return PII(LLINF,0); }\n    static constexpr E de() { return 0; }\n    static T f(const T &a, const T &b) { return min(a, b); }\n    static T g(const T &a, const E &b) { return PII(a.first+b*a.second, a.second); }\n    static E h(const E &a, const E &b) { return a+b; }\n};\nstruct xor_sum {\n    using T = PII;  // (頂点の値, 頂点の区間長)\n    using E = ll;\n    static constexpr T dt() { return PII(0,0); }\n    static constexpr E de() { return 0; }\n    static T f(const T &a, const T &b) { return PII(a.first+b.first, a.second+b.second); }\n    static T g(const T &a, const E &b) { return PII((b>=1?b-a.first:a.first)*a.second, a.second); }\n    static E h(const E &a, const E &b) { return a^b; }\n};\n\n// 点更新区間最小\nnamespace DSL2A {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        lazysegtree<update_min> seg(n);\n        while(q--) {\n            int c, x, y;\n            cin >> c >> x >> y;\n            if(c == 0) {\n                seg.update(x, x+1, y);\n            } else {\n                cout << seg.query(x, y+1) << endl;\n            }\n        }\n    }\n}\n\n// 点加算区間和\nnamespace DSL2B {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        lazysegtree<add_sum> seg(n);\n        seg.build(vector<PII>(n, PII(0,1)));\n        while(q--) {\n            int c, x, y;\n            cin >> c >> x >> y;\n            if(c == 0) {\n                x--;\n                seg.update(x, x+1, y);\n            } else {\n                x--, y--;\n                cout << seg.query(x, y+1).first << endl;\n            }\n        }\n    }\n}\n\n// 区間更新区間最小\nnamespace DSL2F {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        lazysegtree<update_min> seg(n);\n        while(q--) {\n            int c, s, t;\n            cin >> c >> s >> t;\n            if(c == 0) {\n                int x;\n                cin >> x;\n                seg.update(s, t + 1, x);\n            } else {\n                cout << seg.query(s, t + 1) << endl;\n            }\n        }\n    }\n}\n\n// 区間加算区間和\nnamespace DSL2G {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        lazysegtree<add_sum> seg(n);\n        seg.build(vector<PII>(n, PII(0,1)));\n        while(q--) {\n            int c, s, t;\n            cin >> c >> s >> t;\n            s--, t--;\n            if(c == 0) {\n                int x;\n                cin >> x;\n                seg.update(s, t + 1, x);\n            } else {\n                cout << seg.query(s, t + 1).first << endl;\n            }\n        }\n    }\n}\n\n// 区間加算区間最小\nnamespace DSL2H {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        lazysegtree<add_min> seg(n);\n        seg.build(vector<PII>(n, PII(0,1)));\n        while(q--) {\n            int c, s, t;\n            cin >> c >> s >> t;\n            if(c == 0) {\n                int x;\n                cin >> x;\n                seg.update(s, t+1, x);\n            } else {\n                cout << seg.query(s, t+1).first << endl;\n            }\n            REP(i, n) seg.query(i, i+1);\n            cout << seg << endl;\n        }\n    }\n}\n\n// 区間更新区間和\nnamespace DSL2I {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        lazysegtree<update_sum> seg(n);\n        seg.build(vector<PII>(n, PII(0, 1)));\n        while(q--) {\n            int c, s, t;\n            cin >> c >> s >> t;\n            if(c == 0) {\n                int x;\n                cin >> x;\n                seg.update(s, t+1, x);\n            } else {\n                cout << seg.query(s, t+1).first << endl;\n            }\n        }\n    }\n}\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    // DSL2A::solve();\n    // DSL2B::solve();\n    // DSL2F::solve();\n    // DSL2G::solve();\n    // DSL2H::solve();\n    DSL2I::solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long int\n#define MOD(x) ((x % MOD_N) + MOD_N) % MOD_N\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define RFORE(i,a,b) for(int i=(b);i>=(a);--i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define RALL(c) (c).rbegin(),(c).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(c) (int)((c).size())\n#define EACH(i,v) for(auto i=v.begin();i!=v.end();++i)\n#define REACH(i,v) for(auto i=v.rbegin();i!=v.rend();++i)\n#define LB(c,x) distance((c).begin(),lower_bound(ALL(c),x))\n#define UB(c,x) distance((c).begin(),upper_bound(ALL(c),x))\n#define COUNT(c,x) (lower_bound(ALL(c),x)-upper_bound(ALL(c),x))\n#define UNIQUE(c) SORT(c); (c).erase(unique(ALL(c)),(c).end());\n#define COPY(c1,c2) copy(ALL(c1),(c2).begin())\n#define EXIST(s,e) (bool)((s).find(e)!=(s).end())\n#define PB push_back\n#define MP make_pair\n#define DUMP(x)  cerr<<#x<<\" = \"<<(x)<<endl;\n#define NL cerr<<endl;\nusing namespace std;\ntemplate<typename T,typename U> using P=pair<T,U>;\ntemplate<typename T> using V=vector<T>;\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T sum(vector<T>&v){return accumulate(ALL(v),T());}\ntemplate<typename T>T sum(vector<T>&v,int a,int b){return accumulate(v.begin()+a,v.begin()+b,T());}\ntemplate<typename T>T max(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T min(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T max_index(vector<T>&v){return distance((v).begin(),max_element(ALL(v)));}\ntemplate<typename T>T min_index(vector<T>&v){return distance((v).begin(),min_element(ALL(v)));}\n\nstruct edge { int to, cost; };\n\ntemplate<typename T>auto&operator<<(ostream&s,const vector<T>&v){s<<\"[\";bool a=1;for(auto e:v){s<<(a?\"\":\" \")<<e;a=0;}s<<\"]\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const pair<T,U>&p){s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return s;}\ntemplate<typename T>auto&operator<<(ostream&s,const set<T>&st){s<<\"{\";bool a=1;for(auto e:st){s<<(a?\"\":\" \")<<e;a=0;}s<<\"}\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const map<T,U>&m){s<<\"{\";bool a=1;for(auto e:m){s<<(a?\"\":\" \")<<e.first<<\":\"<<e.second;a=0;}s<<\"}\";return s;}\n\nconst int INF = 1e18;\nconst int MOD_N = 1e9+7;\n\ntemplate< typename Monoid, typename OperatorMonoid = Monoid >\nstruct LazySegmentTree {\n   using F = function< Monoid(Monoid, Monoid) >;\n   using G = function< Monoid(Monoid, OperatorMonoid, int) >;\n   using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n   int sz;\n   vector< Monoid > data;\n   vector< OperatorMonoid > lazy;\n   const F f;\n   const G g;\n   const H h;\n   const Monoid M1;\n   const OperatorMonoid OM0;\n   LazySegmentTree(int n, const F f, const G g, const H h,\n                   const Monoid &M1, const OperatorMonoid OM0)\n         : f(f), g(g), h(h), M1(M1), OM0(OM0) {\n      sz = 1;\n      while(sz < n) sz <<= 1;\n      data.assign(2 * sz, M1);\n      lazy.assign(2 * sz, OM0);\n   }\n\n   void set(int k, const Monoid &x) {\n      data[k + sz] = x;\n   }\n   void build() {\n      for(int k = sz - 1; k > 0; k--) {\n         data[k] = f(data[2 * k + 0], data[2 * k + 1]);\n      }\n   }\n   void propagate(int k, int len) {\n      if(lazy[k] != OM0) {\n         if(k < sz) {\n            lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n            lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n         }\n         data[k] = g(data[k], lazy[k], len);\n         lazy[k] = OM0;\n      }\n   }\n   Monoid update(int a, int b, const OperatorMonoid &x, int k, int l, int r) {\n      propagate(k, r - l);\n      if(r <= a || b <= l) {\n         return data[k];\n      } else if(a <= l && r <= b) {\n         lazy[k] = h(lazy[k], x);\n         propagate(k, r - l);\n         return data[k];\n      } else {\n         return data[k] = f(update(a, b, x, 2 * k + 0, l, (l + r) >> 1),\n                            update(a, b, x, 2 * k + 1, (l + r) >> 1, r));\n      }\n   }\n   Monoid update(int a, int b, const OperatorMonoid &x) {\n      return update(a, b, x, 1, 0, sz);\n   }\n   Monoid query(int a, int b, int k, int l, int r) {\n      propagate(k, r - l);\n      if(r <= a || b <= l) {\n         return M1;\n      } else if(a <= l && r <= b) {\n         return data[k];\n      } else {\n         return f(query(a, b, 2 * k + 0, l, (l + r) >> 1),\n                  query(a, b, 2 * k + 1, (l + r) >> 1, r));\n      }\n   }\n   Monoid query(int a, int b) {\n      return query(a, b, 1, 0, sz);\n   }\n   Monoid operator[](const int &k) {\n      return query(k, k + 1);\n   }\n};\ntemplate<typename T> struct RSQ_RUQ {\n   LazySegmentTree<T> lsegt;\n   RSQ_RUQ(int n) : lsegt(n,\n      [](T a,T b){ return a + b; },\n      [](T a,T b,T c){ return b * c; },\n      [](T a,T b){ return b; }, 0, INF){}\n   void update(int a, int b, T x) { lsegt.update(a, b, x); }\n   T query(int a, int b) { lsegt.query(a, b); }\n};\n\nsigned main()\n{\n   int n, q; cin >> n >> q;\n   V<int> c(q), s(q), t(q), x(q);\n   REP(i, q) {\n      cin >> c[i];\n      if (c[i] == 0) {\n         cin >> s[i] >> t[i] >> x[i];\n      } else {\n         cin >> s[i] >> t[i];\n      }\n   }\n   // LazySegmentTree<int> lsegt(n,\n   //       [](int a,int b){ return a + b; },\n   //       [](int a,int b,int c){ return b * c; },\n   //       [](int a,int b){ return b; }, 0, INF);\n   RSQ_RUQ<int> rsqruq(n);\n   REP(i, q) {\n      if (c[i] == 0) {\n         rsqruq.update(s[i], t[i]+1, x[i]);\n      } else {\n         cout << rsqruq.query(s[i], t[i]+1) << endl;\n      }\n   }\n\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(ll i = 0, i##_len = (n); i < i##_len; i++)\n#define reps(i, s, n) for(ll i = (s), i##_len = (n); i < i##_len; i++)\n#define rrep(i, n) for(ll i = (n) - 1; i >= 0; i--)\n#define rreps(i, e, n) for(ll i = (n) - 1; i >= (e); i--)\n#define all(x) (x).begin(), (x).end()\n#define sz(x) ((ll)(x).size())\n#define len(x) ((ll)(x).length())\n\ntemplate<class T>\nstruct LazySegmentTree {\nprivate:\n    int n;\n    vector<T> node, lazy;\n    vector<bool> updated;\n    T def;\n    function<T(T,T)> out;\n    function<T(T,T,int)> app;\n    \n    void init(const vector<T> &v, T _def, function<T(T,T,int)> _app, function<T(T,T)> _out) {\n        def = _def; out = _out; app = _app;\n        int vl = (int)v.size();\n        n = 1; while(n < vl) n *= 2;\n        node.resize(2 * n - 1);\n        lazy.resize(2 * n - 1, def);\n        updated.resize(2 * n - 1, false);\n        for(int i = 0; i < vl; i++) node[i + n - 1] = v[i];\n        for(int i = n - 2; i >= 0; i--) node[i] = out(node[i * 2 + 1], node[i * 2 + 2]);\n    }\n    \n    void eval(int k, int l, int r) {\n        if (updated[k]) {\n            node[k] = app(node[k], lazy[k], r - l);\n            if ((r - l) > 1) {\n                lazy[k * 2 + 1] = lazy[k];\n                lazy[k * 2 + 2] = lazy[k];\n                updated[k * 2 + 1] = updated[k * 2 + 2] = true;\n            }\n            lazy[k] = 0;\n            updated[k] = false;\n        }\n    }\n    \npublic:\n    LazySegmentTree() {}\n    LazySegmentTree(int _n, T _def, function<T(T,T,int)> _app, function<T(T,T)> _out) {\n        init(vector<T>(_n, _def), _def, _app, _out);\n    }\n    LazySegmentTree(const vector<T> &v, T _def, function<T(T,T,int)> _app, function<T(T,T)> _out) {\n        init(v, _def, _app, _out);\n    }\n    \n    void update(int a, int b, T x, int k = 0, int l = 0, int r = -1) {\n        if (r < 0) r = n;\n        eval(k, l, r);\n        if((b <= l) || (r <= a)) return;\n        if((a <= l) && (r <= b)) {\n            lazy[k] = x;\n            updated[k] = true;\n            eval(k, l, r);\n        }\n        else {\n            update(a, b, x, 2 * k + 1, l, (l + r) / 2);\n            update(a, b, x, 2 * k + 2, (l + r) / 2, r);\n            node[k] = out(node[2 * k + 1], node[2 * k + 2]);\n        }\n    }\n    \n    T query(int a, int b, int k = 0, int l = 0, int r = -1) {\n        if (r < 0) r = n;\n        eval(k, l, r);\n        if ((b <= l) || (r <= a)) return def;\n        if ((a <= l) && (r <= b)) return node[k];\n        T vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n        T vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n        return out(vl, vr);\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    // ifstream in(\"input.txt\");\n    // cin.rdbuf(in.rdbuf());\n    ll n, q;\n    cin >> n >> q;\n    LazySegmentTree<ll> lst(n, 0, [](ll a, ll b, ll c){ return b * c; }, [](ll a, ll b){ return a + b; });\n    rep(i, q) {\n        ll com;\n        cin >> com;\n        if (com == 0) {\n            ll s, t, x;\n            cin >> s >> t >> x;\n            lst.update(s, t + 1, x);\n        }\n        else {\n            ll s, t;\n            cin >> s >> t;\n            cout << lst.query(s, t + 1) << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <cstring> //memset(dp,0,sizeof(dp))\n#include <functional>\n#include <cctype>\n#include <locale>\n#define ll long long\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define fi first\n#define se second\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\ntypedef pair<int,int> P;\ntypedef pair<long long,long long> Pll;\n#define fout(num) cout << fixed << setprecision(20) << (num) << endl\n//s[i]=tolower(s[i]); islower(s[i]); cout << tolower(s[i])はバグ\n//vector<vector<ll>> dp(n,vector<ll>(n))\n//exist x map o setconst ll MOD = 1e9+7;return fac[n]*(finv[k]*finv[n-k] % MOD) % MOD;\n\ntemplate<typename T>\nstruct LazySegmentTree{\nprivate:\n    int n;\n    vector<T> node,lazy;\n    vector<bool> flg;\npublic:\n    T SUP=0; /* 初期値　*/\n    T merge(T x,T y){\n        return x+y;\n    }\n    LazySegmentTree(vector<T> v){\n        int sz=(int)v.size();\n        n=1; while(n<sz) n*=2;\n        node.resize(2*n-1);\n        lazy.resize(2*n-1,0);\n        flg.resize(2*n-1,false);\n        for(int i=0;i<sz;i++) node[i+n-1]=v[i];\n        for(int i=n-2;i>=0;i--) node[i]=merge(node[2*i+1],node[2*i+2]);\n    }\n    void eval(int idx,int l,int r){\n        if(flg[idx]){\n            flg[idx]=false;\n            node[idx]=lazy[idx];\n            if(r-l>1){\n                /* node[idx]からの伝播  */\n                lazy[2*idx+1]=lazy[idx]/2;\n                lazy[2*idx+2]=lazy[idx]/2;\n                flg[2*idx+1]=flg[2*idx+2]=true;\n            }\n            lazy[idx]=0;\n        }\n    }\n    void update(int a,int b,T x,int idx=0,int l=0,int r=-1){\n        if(r<0) r=n;\n        eval(idx,l,r);\n        if(b<=l||r<=a) return;\n        if(a<=l&&r<=b){\n            lazy[idx]=x*(r-l);\n            flg[idx]=true;\n            eval(idx,l,r);\n        }else{\n            update(a,b,x,2*idx+1,l,(l+r)/2);\n            update(a,b,x,2*idx+2,(l+r)/2,r);\n            node[idx]=merge(node[2*idx+1],node[2*idx+2]);\n        }\n    }\n    T query(int a,int b,int idx=0,int l=0,int r=-1){\n        if(r<0) r=n;\n        if(b<=l || r<=a) return 0;\n        eval(idx,l,r);\n        if(a<=l && r<=b) return node[idx];\n        T vl = query(a,b,2*idx+1,l,(l+r)/2);\n        T vr = query(a,b,2*idx+2,(l+r)/2,r);\n        return merge(vl,vr);\n    };\n};\n\n\n\nsigned main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    int n,q; cin >> n >> q;\n    vector<ll> v(n,0);\n    LazySegmentTree<ll> lsg(v);\n    rep(i,q){\n        int x; cin >> x;\n        if(x==0){\n            int s,t,y; cin >> s >> t >> y;\n            t++;\n            lsg.update(s,t,y);\n        }else{\n            int s,t; cin >> s >> t;\n            t++;\n            cout << lsg.query(s,t) << \"\\n\";\n        }\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define moder (int)(1e9+7)\n#define inf (int)(3e18+7)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<n;i++)\n#define P pair<int,int>\n#define all(v) v.begin(),v.end()\n#define mkp make_pair\n#define mkt make_tuple\n#define prique(T) priority_queue<T,vector<T>,greater<T>>\n#define vecunique(vec) sort(vec.begin(), vec.end());decltype(vec)::iterator result = std::unique(vec.begin(), vec.end());vec.erase(result, vec.end())\nusing namespace std;\n\nbool prime(int x) {\n\tfor (int i = 2; i * i <= x; i++) {\n\t\tif (x % i == 0)return false;\n\t}\n\treturn x > 1;\n}\nint gcd(int x, int y) {\n\tif (y == 0)return x;\n\treturn gcd(y, x % y);\n}\nint lcm(int x, int y) {\n\treturn x * y / gcd(x, y);\n}\nint kai(int x) {\n\tif (x == 0)return 1;\n\treturn kai(x - 1) * x % moder;\n}\nint mod_pow(int x, int y, int mod) {\n\tint res = 1;\n\twhile (y > 0) {\n\t\tif (y & 1) {\n\t\t\tres = res * x % mod;\n\t\t}\n\t\tx = x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\nint comb(int x, int y) {\n\treturn kai(x)* mod_pow(kai(x - y), moder - 2, moder) % moder * mod_pow(kai(y), moder - 2, moder) % moder;\n}\n/*--------Library Zone!--------*/\n\n\nP dat[1000000];\nint size_ = 1;\nvoid init(int x) {\n\twhile (size_ < x)size_ *= 2;\n\trep(i, 2 * size_ - 1)dat[i] = { 0,inf };\n}\nvoid eval(int k, int l, int r) {\n\tif (dat[k].second != inf) {\n\t\tdat[k].first = dat[k].second;\n\t\tif (r - l > 1) {\n\t\t\tdat[k * 2 + 1].second = dat[k].second / 2;\n\t\t\tdat[k * 2 + 2].second = dat[k].second / 2;\n\t\t}\n\t\tdat[k].second = inf;\n\t}\n}\nvoid update(int a, int b, int k, int x, int l, int r) {\n\teval(k, l, r);\n\tif (r <= a || b <= l)return;\n\tif (a <= l && r <= b) {\n\t\tdat[k].second = x * (r - l);\n\t\teval(k, l, r);\n\t}\n\telse {\n\t\tupdate(a, b, k * 2 + 1, x, l, (l + r) / 2);\n\t\tupdate(a, b, k * 2 + 2, x, (l + r) / 2, r);\n\t\tdat[k].first = dat[k * 2 + 1].first + dat[k * 2 + 2].first;\n\t}\n}\nint query(int a, int b, int k, int l, int r) {\n\teval(k, l, r);\n\tif (r <= a || b <= l)return 0;\n\tif (a <= l && r <= b) {\n\t\treturn dat[k].first;\n\t}\n\tint lv = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\tint rv = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\treturn lv + rv;\n}\nsigned main() {\n\tint n, q;\n\tcin >> n >> q;\n\tinit(n);\n\trep(i, q) {\n\t\tint a; cin >> a;\n\t\tif (!a) {\n\t\t\tint s, t, x; cin >> s >> t >> x;\n\t\t\tupdate(s, t + 1, 0, x, 0, size_);\n\t\t}\n\t\telse {\n\t\t\tint s, t; cin >> s >> t;\n\t\t\tcout << query(s, t + 1, 0, 0, size_) << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "/* segment_tree_lazy_proportional.cpp\n    任意の作用つきモノイドに対して遅延評価セグメント木を構築する。\n    (区間に対する操作が要素数に比例する場合)\n\n    モノイドX、作用モノイドMに対するセグメント木を構築するために、\n        ・X上の二項演算 fx(•)\n        ・XとMの二項演算 fa(*)\n        ・M上の二項演算 fm\n        ・M上の写像 fp(m,n) = fm(m,m,m,...m) (n回mを演算する)\n        ・Xの単位元 ex\n        ・Mの単位元 em\n    を与える。ただし\n    ・fp は高速に計算可能\n    ・(x1•x2)*fp(m,n) = (x1*fp(m,n/2))•(x2*fp(m,n/2))\n    が成立する必要がある\n\n    RSQ・RAQ\n        using X = long long;\n        using M = long long;\n        auto fx = [](X x1, X x2) -> X { return x1 + x2; };\n        auto fa = [](X x, M m) -> X { return x + m; };\n        auto fm = [](M m1, M m2) -> M { return m1 + m2; };\n        auto fp = [](M m, long long n) -> M { return m * n; };\n        long long ex = 0;\n        long long em = 0;\n        SegTreeLazyProportional<X, M> rsq(n, fx, fa, fm, fp, ex, em);\n\n    verified: AOJ DSL_2_G RSQ and RAQ\n        http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_G\n */\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n/* SegTreeLazyProportional<X,M>(n,fx,fa,fm,fp,ex,em): モノイド(集合X, 二項演算fx,fa,fm,p\n   単位元ex,em)についてサイズnで構築\n    set(int i, X x), build(): i番目の要素をxにセット。まとめてセグ木を構築する。O(n)\n    update(i,x): i 番目の要素を x に更新。O(log(n))\n    query(a,b):  [a,b) 全てにfxを作用させた値を取得。O(log(n))\n*/\ntemplate <typename X, typename M>\nstruct SegTreeLazyProportional {\n    using FX = function<X(X, X)>;\n    using FA = function<X(X, M)>;\n    using FM = function<M(M, M)>;\n    using FP = function<M(M, int)>;\n    int n;\n    FX fx;\n    FA fa;\n    FM fm;\n    FP fp;\n    const X ex;\n    const M em;\n    vector<X> dat;\n    vector<M> lazy;\n    SegTreeLazyProportional(int n_, FX fx_, FA fa_, FM fm_, FP fp_, X ex_, M em_)\n        : n(), fx(fx_), fa(fa_), fm(fm_), fp(fp_), ex(ex_), em(em_), dat(n_ * 4, ex), lazy(n_ * 4, em) {\n        int x = 1;\n        while (n_ > x) x *= 2;\n        n = x;\n    }\n\n    void set(int i, X x) { dat[i + n - 1] = x; }\n    void build() {\n        for (int k = n - 2; k >= 0; k--) dat[k] = fx(dat[2 * k + 1], dat[2 * k + 2]);\n    }\n\n    /* lazy eval */\n    void eval(int k, int len) {\n        if (lazy[k] == em) return;  // 更新するものが無ければ終了\n        if (k < n - 1) {            // 葉でなければ子に伝搬\n            lazy[k * 2 + 1] = fm(lazy[k * 2 + 1], lazy[k]);\n            lazy[k * 2 + 2] = fm(lazy[k * 2 + 2], lazy[k]);\n        }\n        // 自身を更新\n        dat[k] = fa(dat[k], fp(lazy[k], len));\n        lazy[k] = em;\n    }\n\n    void update(int a, int b, M x, int k, int l, int r) {\n        eval(k, r - l);\n        if (a <= l && r <= b) {  // 完全に内側の時\n            lazy[k] = fm(lazy[k], x);\n            eval(k, r - l);\n        } else if (a < r && l < b) {                     // 一部区間が被る時\n            update(a, b, x, k * 2 + 1, l, (l + r) / 2);  // 左の子\n            update(a, b, x, k * 2 + 2, (l + r) / 2, r);  // 右の子\n            dat[k] = fx(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n    }\n    void update(int a, int b, M x) { update(a, b, x, 0, 0, n); }\n\n    X query_sub(int a, int b, int k, int l, int r) {\n        eval(k, r - l);\n        if (r <= a || b <= l) {  // 完全に外側の時\n            return ex;\n        } else if (a <= l && r <= b) {  // 完全に内側の時\n            return dat[k];\n        } else {  // 一部区間が被る時\n            X vl = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);\n            X vr = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);\n            return fx(vl, vr);\n        }\n    }\n    X query(int a, int b) { return query_sub(a, b, 0, 0, n); }\n\n    /* debug */\n    inline X operator[](int a) { return query(a, a + 1); }\n    void print() {\n        for (int i = 0; i < n; ++i) {\n            cout << (*this)[i];\n            if (i != n) cout << \",\";\n        }\n        cout << endl;\n    }\n};\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    using X = long long;\n    using M = long long;\n    auto fx = [](X x1, X x2) -> X { return x1 + x2; };\n    auto fa = [](X x, M m) -> X { return m; };\n    auto fm = [](M m1, M m2) -> M { return m2; };\n    auto fp = [](M m, long long n) -> M { return m * n; };\n    long long ex = 0;\n    long long em = numeric_limits<int>::max();\n    SegTreeLazyProportional<X, M> rsq(n, fx, fa, fm, fp, ex, em);\n\n    vector<long long> ans;\n    for (int i = 0; i < q; i++) {\n        int c;\n        cin >> c;\n        if (c == 0) {\n            int s, t;\n            long long x;\n            cin >> s >> t >> x;\n            rsq.update(s, t + 1, x);\n        } else if (c == 1) {\n            int s, t;\n            cin >> s >> t;\n            ans.push_back(rsq.query(s, t + 1));\n        }\n    }\n    for (auto i : ans) {\n        cout << i << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\nconst int INF = 1e9;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = { 0, 1, 0, -1 }, dx4 = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\n\n\ntemplate <typename T> class LazySegmentTree {\nprivate:\n    const int array_size;\n    int n;\n    std::vector<T> data, lazy;\n    std::vector<bool> lazyFlag;\n    const function<T (T, T)> f;     // 要素に適用する演算\n    const function<T (T, T)> g;     // 作用素の適用\n    const function<T (T, T)> h;     // 作用素の合成\n    const function<T (T, int)> p;\n    const T unit;\n\npublic:\n    class Mode {\n    public:\n        function<T (T, T)> f;\n        function<T (T, T)> g;\n        function<T (T, T)> h;\n        function<T (T, int)> p;\n        T unit;\n    };\n\n    enum Query {\n        RangeMinimumQuery,\n        RangeMaximumQuery,\n        RangeSummationQuery,\n    };\n\n    enum Operation {\n        Update,\n        Add,\n    };\n\n    LazySegmentTree(const std::vector<LL> &v, const Mode mode) : array_size(v.size()),  f(mode.f), g(mode.g), h(mode.h), p(mode.p), unit(mode.unit){\n        n = 1;\n        while (n < array_size) { n *= 2; }\n        data.resize(2 * n - 1, unit);\n        lazy.resize(2 * n - 1, 0);\n        lazyFlag.resize(2 * n - 1, false);\n\n        for (int i = 0; i < array_size; ++i) {\n            data[i + n - 1] = v[i];\n        }\n        for (int i = n - 2; i >= 0; i--) {\n            data[i] = f(data[i * 2 + 1], data[i * 2 + 2]);\n        }\n    }\n\n    static Mode getMode(const Query query, const Operation operation) {\n        Mode mode;\n        if (query == RangeMinimumQuery) {\n            mode.unit = INT_MAX;\n            mode.f = [](T a, T b) { return std::min(a, b); };\n\n            if (operation == Update) {\n                mode.g = [](T a, T b) { return b; };\n                mode.h = mode.g;\n                mode.p = [](T a, int len) { return a; };\n            }\n            else if (operation == Add) {\n                mode.g = [](T a, T b) { return a + b; };\n                mode.h = mode.g;\n                mode.p = [](T a, int len) { return a; };\n            }\n        }\n        else if (query == RangeMaximumQuery) {\n            mode.unit = -INT_MAX;\n            mode.f = [](T a, T b) { return std::max(a, b); };\n            if (operation == Update) {\n                mode.g = [](T a, T b) { return b; };\n                mode.h = mode.g;\n                mode.p = [](T a, int len) { return a; };\n            }\n            else if (operation == Add) {\n                mode.g = [](T a, T b) { return a + b; };\n                mode.h = mode.g;\n                mode.p = [](T a, int len) { return a; };\n            }\n        }\n        else if (query == RangeSummationQuery) {\n            mode.unit = 0;\n            mode.f = [](T a, T b) { return a + b; };\n\n            if (operation == Update) {\n                mode.g = [](T a, T b) { return b;};\n                mode.h = mode.g;\n                mode.p = [](T a, int len) {return a * len;};\n            }\n            else if (operation == Add) {\n                mode.g = [](T a, T b) { return b;};\n                mode.h = [](T a, T b) { return a + b;};\n                mode.p = [](T a, int len) {return a * len;};\n            }\n        }\n        else {\n            assert(false);\n        }\n        return mode;\n    }\n\n    // array[idx]\n    // log(N)\n    T access(const int idx) {\n        return query(idx, idx + 1, 0, 0, n);\n    }\n\n    // array[idx] += x\n    // log(N)\n    void update(const int idx, const T x) {\n        update(idx, idx + 1, x);\n    }\n\n    // array[left, right) += x\n    // log(N)\n    void update(const int left, const int right, const T x) {\n        assert(0 <= left and left < right and right <= array_size);\n        update(left, right, x, 0, 0, n);\n    }\n\n    // op(array[a, b))\n    // log(N)\n    T query(const int left, const int right) {\n        return query(left, right, 0, 0, n);\n    }\n\nprivate:\n    T update(const int a, const int b, const T x, const int k, const int l, const int r) {\n        propagate(k, r - l);\n\n        // 範囲外\n        if (b <= l or r <= a) {\n            return data[k];\n        }\n        // 完全に含む\n        else if (a <= l and r <= b) {\n            lazy[k] = h(lazy[k], x);\n            lazyFlag[k] = true;\n            propagate(k, r - l);\n            return g(data[k], p(lazy[k], r - l));\n        }\n        // 一部含む\n        else {\n            T lv = update(a, b, x, 2 * k + 1, l, (l + r) / 2);    // 左の子\n            T rv = update(a, b, x, 2 * k + 2, (l + r) / 2, r);    // 右の子\n            return data[k] = f(lv, rv);\n        }\n    }\n\n    // [a, b)の目的値をノードk（区間[l, r]）から検索\n    T query(const int a, const int b, const int k, const int l, const int r) {\n        propagate(k, r - l);\n\n        // 範囲外\n        if (b <= l or r <= a) {\n            return unit;\n        }\n        // 完全に含む\n        else if (a <= l && r <= b) {\n            return data[k];\n        }\n        // 一部含む\n        else {\n            T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);    // 左の子\n            T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);    // 右の子\n            return f(vl, vr);\n        }\n    }\n\n    void propagate(const int k, const int len) {\n        if (not lazyFlag[k]) {\n            return;\n        }\n\n        if (len > 1) {\n            lazy[k * 2 + 1] = h(lazy[k * 2 + 1], lazy[k]);\n            lazyFlag[2 * k + 1] = true;\n            lazy[k * 2 + 2] = h(lazy[k * 2 + 2], lazy[k]);\n            lazyFlag[2 * k + 2] = true;\n        }\n        data[k] = g(data[k], p(lazy[k], len));\n        lazyFlag[k] = false;\n    }\n};\n\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, Q;\n    cin >> N >> Q;\n\n    vector<LL> v(N + 1, 0);\n\n    auto mode = LazySegmentTree<LL>::getMode(LazySegmentTree<LL>::Query::RangeSummationQuery, LazySegmentTree<LL>::Operation::Update);\n    LazySegmentTree<LL> lst(v, mode);\n\n    FOR(_, 0, Q) {\n        int query, s, t, x, i;\n        cin >> query;\n        if (query == 0) {\n            cin >> s >> t >> x;\n            lst.update(s, t + 1, x);\n        }\n        else {\n            cin >> s >> t;\n            print(lst.query(s, t + 1));\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<iomanip>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n#include <stdio.h>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <map>\n#include <list>\n#include <string>\n#include <numeric>\n#include <utility>\n#include <cfloat>\n#include <set>\n \nusing namespace std;\n \nint sqrtN = 512;\nstruct SqrtDecomposition{\n    int N, K;\n    vector <long long> data;\n    vector <long long> bucketUpdatedLazy;\n    vector <long long> bucketSum;\n     \n    SqrtDecomposition(int n){\n        N = n;\n        K = (N + sqrtN - 1) / sqrtN;\n        data.assign(N + sqrtN, 0);\n        bucketUpdatedLazy.assign(K, -1);\n        bucketSum.assign(K, 0);\n    }\n \n    void propagateLazy(int k){\n        if(bucketUpdatedLazy[k] < 0){\n            return;\n        }\n        for(int i = 0; i < sqrtN; i++){\n            data[k * sqrtN + i] = bucketUpdatedLazy[k];\n        }\n        bucketSum[k] = bucketUpdatedLazy[k] * sqrtN;\n        bucketUpdatedLazy[k] = -1;\n    }\n\n\n    long long get(int x){\n        propagateLazy(x / sqrtN);\n        return data[x];\n    }\n\n    long long getSum(int x, int y){\n        propagateLazy(x / sqrtN);\n        propagateLazy((y - 1) / sqrtN);\n        long long ans = 0;\n        if(y - x < sqrtN){\n            for(int i = x; i < y; i++){\n                ans += data[i];\n            }\n            return ans;\n        }\n        for(int i = x / sqrtN + 1; i < y / sqrtN; i++){\n            ans += bucketSum[i];\n        }\n\n        for(int i = x; i < (x / sqrtN + 1) * sqrtN; i++){\n            ans += data[i];\n        }\n        for(int i = y / sqrtN * sqrtN; i < y; i++){\n            ans += data[i];\n        }\n        return ans;\n    }\n \n    void update(int x, int y, long long a){\n        if(y - x < sqrtN){\n            propagateLazy(x / sqrtN);\n            propagateLazy((y - 1) / sqrtN);\n            for(int i = x; i < y; i++){\n                bucketSum[i/sqrtN] += (a - data[i]);\n                data[i] = a;\n            }\n            return;\n        }\n        for(int i = x / sqrtN + 1; i < y / sqrtN; i++){\n            bucketUpdatedLazy[i] = a;\n        }\n\n        propagateLazy(x / sqrtN);\n        for(int i = x; i < (x / sqrtN + 1) * sqrtN; i++){\n            bucketSum[i/sqrtN] += (a - data[i]);\n            data[i] = a;\n        }\n        propagateLazy((y - 1)/ sqrtN);\n        for(int i = y / sqrtN * sqrtN; i < y; i++){\n            bucketSum[i/sqrtN] += (a - data[i]);\n            data[i] = a;\n        }\n    }\n     \n};\n\n \nint main(){\n    int n;\n    int q;\n    cin >> n >> q;\n    SqrtDecomposition sq(n);\n    for(int i = 0; i < q; i++){\n        int com;\n        int s;\n        int t;\n        int x;\n        cin >> com;\n        if(com == 0){\n            cin >> s >> t >> x;\n            sq.update(s, t + 1, x);\n        } else {\n            cin >> s >> t;\n            cout << sq.getSum(s, t + 1) << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\n\ntemplate<typename T, typename E>\nclass SegTree{\nprivate:\n\tusing F = function<T(T, T)>;\n\tusing G = function<T(T, E)>;\n\tint32 n;\n\tF f;\n\tG g;\n\tT ti; // e0:F\n\tvector<T> node;\npublic:\n\tSegTree(int32 _n, F f, G g, T ti):f(f), g(g), ti(ti){\n\t\tinit(_n);\n\t}\n\tSegTree(vector<T> v, F f, G g, T ti):f(f), g(g), ti(ti){\n\t\tinit(v.size());\n\t\tfor(int32 i = 0;i < v.size();i++) node[i+n-1] = v[i];\n\t\tfor(int32 i = n-2;i >= 0;i--) merge(i);\n\t}\n\n\tinline void init(int32 _n){\n\t\tn = 1;\n\t\twhile(n < _n) n *= 2;\n\t\tnode.resize(2*n-1, ti);\n\t}\n\n\tinline void merge(int32 k){\n\t\tif(node[k*2+1] == ti) node[k] = node[k*2+2];\n\t\telse if(node[k*2+2] == ti) node[k] = node[k*2+1];\n\t\telse node[k] = f(node[k*2+1], node[k*2+2]);\n\t}\n\n\tvoid update(int32 k, E x){\n\t\tk += n-1;\n\t\tnode[k] = g(node[k], x);\n\t\twhile(k){\n\t\t\tk = (k-1)/2;\n\t\t\tmerge(k);\n\t\t}\n\t}\n\n\tT query(int32 a, int32 b, int32 k=0, int32 l=0, int32 r=-1){\n\t\tif(r < 0) r = n;\n\t\tif(b <= l || r <= a) return ti;\n\t\tif(a <= l && r <= b) return node[k];\n\t\treturn f(query(a, b, k*2+1, l, (l+r)/2), query(a, b, k*2+2, (l+r)/2, r));\n\t}\n};\n\ntemplate<typename T, typename E>\nclass LazySegTree{\nprivate:\n\tusing F = function<T(T, T)>;\n\tusing G = function<T(T, E)>;\n\tusing H = function<E(E, E)>;\n\tusing P = function<E(E, int64)>;\n\tint32 n;\n\tvector<T> node;\n\tvector<E> lazy;\n\tF f;\n\tG g;\n\tH h;\n\tP p;\n\tT ti;\n\tE ei;\npublic:\n\tLazySegTree(int32 _n, F f, G g, H h, T ti, E ei, P p = [](E a, int32 b){return a;}):f(f), g(g), h(h), p(p), ti(ti), ei(ei){\n\t\tinit(_n);\n\t}\n\n\tLazySegTree(vector<T> v, F f, G g, H h, T ti, E ei, P p = [](E a, int32 b){return a;}):f(f), g(g), h(h), p(p), ti(ti), ei(ei){\n\t\tinit(v.size());\n\t\tfor(int32 i = 0;i < v.size();i++) node[i+n-1] = v[i];\n\t\tfor(int32 i = n-2;i >= 0;i--) merge(i);\n\t}\n\n\tvoid init(int32 _n){\n\t\tn = 1;\n\t\twhile(n < _n) n*=2;\n\t\tnode.resize(2*n-1, ti);\n\t\tlazy.resize(2*n-1, ei);\n\t}\n\n\tinline void merge(int32 k){\n\t\tif(node[k*2+1] == ti) node[k] = node[k*2+2];\n\t\telse if(node[k*2+2] == ti) node[k] = node[k*2+1];\n\t\tnode[k] = f(node[k*2+2], node[k*2+1]);\n\t}\n\n\tinline void eval(int32 k, int32 l, int32 r){\n\t\tif(lazy[k] == ei) return;\n\t\tnode[k] = g(node[k], p(lazy[k], r-l));\n\t\tif(r-l > 1){\n\t\t\tlazy[k*2+1] = h(lazy[k*2+1], lazy[k]);\n\t\t\tlazy[k*2+2] = h(lazy[k*2+2], lazy[k]);\n\t\t}\n\t\tlazy[k] = ei;\n\t}\n\n\tT update(int32 a, int32 b, E x, int32 k=0, int32 l=0, int32 r=-1){\n\t\tif(r<0) r = n;\n\t\teval(k, l, r);\n\t\tif(b <= l || r <= a) return node[k];\n\t\tif(a <= l && r <= b){\n\t\t\tlazy[k] = h(lazy[k], x);\n\t\t\treturn g(node[k], p(lazy[k], r-l));\n\t}\n\t\treturn node[k] = f(update(a, b, x, k*2+1, l, (l+r)/2), update(a, b, x, k*2+2, (l+r)/2, r));\n\t}\n\n\tT query(int32 a, int32 b, int32 k=0, int32 l=0, int32 r=-1){\n\t\tif(r<0) r = n;\n\t\teval(k, l, r);\n\t\tif(b <= l || r <= a) return ti;\n\t\tif(a <= l && r <= b) return node[k];\n\t\treturn f(query(a, b, k*2+1, l, (l+r)/2), query(a, b, k*2+2, (l+r)/2, r));\n\t}\n};\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint32 n, q;\n\tcin >> n >> q;\n\tLazySegTree<int64, int64> sg(\n\t\tvector<int64>(n, 0)\n\t\t, [](int64 a, int64 b){return a+b;}\n\t\t, [](int64 a, int64 b){return b;}\n\t\t, [](int64 a, int64 b){return b;}\n\t\t, 0\n\t\t, INF_LL\n\t\t, [](int64 a, int64 b){return a*b;});\n\tREP(i, q){\n\t\tint64 com, x, y;\n\t\tcin >> com >> x >> y;\n\t\tif(com == 0){\n\t\t\tint64 z;\n\t\t\tcin >> z;\n\t\t\tsg.update(x, y+1, z);\n\t\t}else{\n\t\t\tcout << sg.query(x, y+1) << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,N) for(int i=0;i<(int)N;++i)\n#define rep1(i,N) for(int i=1;i<=(int)N;++i)\n#define all(x) x.begin(),x.end()\n#define rall(x) x.rbegin(),x.rend()\n#define SZ(x) (int)x.size()\n#define e_b emplace_back\nusing ll = long long;\nconst ll LINF=1LL<<60;\nconst int INF=1<<30;\n\nstruct LazySegmentTree{\n\tint n;\n\tvector<ll> node,lazy;\n\tvector<bool> lazyFlag;\n\t\n\tLazySegmentTree(int sz){\n\t\tn=1;\n\t\twhile(sz>n) n<<=1;\n\t\tnode.assign(2*n,0);\n\t\tlazy.assign(2*n,0);\n\t\tlazyFlag.assign(2*n,false);\n\t}\n\t\n\tvoid eval(int k,int l,int r){\n\t\tif(lazyFlag[k]){\n\t\t\tnode[k]=lazy[k];\n\t\t\tif(r-l>1){\n\t\t\t\tlazy[2*k]=lazy[k]/2;\n\t\t\t\tlazyFlag[2*k]=true;\n\t\t\t\tlazy[2*k+1]=lazy[k]/2;\n\t\t\t\tlazyFlag[2*k+1]=true;\n\t\t\t}\n\t\t\tlazy[k]=0;\n\t\t\tlazyFlag[k]=false;\n\t\t}\n\t}\n\t\n\tvoid update(int a,int b,ll x,int k=1,int l=0,int r=-1){\n\t\tif(r<0) r=n;\n\t\teval(k,l,r);\n\t\tif(r<=a||b<=l) return;\n\t\tif(a<=l&&r<=b){\n\t\t\tlazy[k]=(r-l)*x;\n\t\t\tlazyFlag[k]=true;\n\t\t\teval(k,l,r);\n\t\t}\n\t\telse{\n\t\t\tupdate(a,b,x,2*k,l,(l+r)/2);\n\t\t\tupdate(a,b,x,2*k+1,(l+r)/2,r);\n\t\t\tnode[k]=node[2*k]+node[2*k+1];\n\t\t}\n\t}\n\t\n\tll getSum(int a,int b,int k=1,int l=0,int r=-1){\n\t\tif(r<0) r=n;\n\t\teval(k,l,r);\n\t\tif(r<=a||b<=l) return 0;\n\t\tif(a<=l&&r<=b) return node[k];\n\t\tll vl=getSum(a,b,2*k,l,(l+r)/2);\n\t\tll vr=getSum(a,b,2*k+1,(l+r)/2,r);\n\t\treturn vl+vr;\n\t}\n};\n\nint main(){\n\tint n,q; cin>>n>>q;\n\tLazySegmentTree tree(n);\n\trep(i,q){\n\t\tint m,s,t,x;\n\t\tcin>>m;\n\t\tif(m==0){\n\t\t\tcin>>s>>t>>x;\n\t\t\ttree.update(s,t+1,x);\n\t\t}else{\n\t\t\tcin>>s>>t;\n\t\t\tcout<<tree.getSum(s,t+1)<<endl;\n\t\t}\n\t}\n}\n\n\t\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define moder (int)(1e9+7)\n#define inf (int)(3e18+7)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<n;i++)\n#define P pair<int,int>\n#define all(v) v.begin(),v.end()\n#define mkp make_pair\n#define mkt make_tuple\n#define prique(T) priority_queue<T,vector<T>,greater<T>>\n#define vecunique(vec) sort(vec.begin(), vec.end());decltype(vec)::iterator result = std::unique(vec.begin(), vec.end());vec.erase(result, vec.end())\nusing namespace std;\n\nbool prime(int x) {\n\tfor (int i = 2; i * i <= x; i++) {\n\t\tif (x % i == 0)return false;\n\t}\n\treturn x > 1;\n}\nint gcd(int x, int y) {\n\tif (y == 0)return x;\n\treturn gcd(y, x % y);\n}\nint lcm(int x, int y) {\n\treturn x * y / gcd(x, y);\n}\nint kai(int x) {\n\tif (x == 0)return 1;\n\treturn kai(x - 1) * x % moder;\n}\nint mod_pow(int x, int y, int mod) {\n\tint res = 1;\n\twhile (y > 0) {\n\t\tif (y & 1) {\n\t\t\tres = res * x % mod;\n\t\t}\n\t\tx = x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\nint comb(int x, int y) {\n\treturn kai(x)* mod_pow(kai(x - y), moder - 2, moder) % moder * mod_pow(kai(y), moder - 2, moder) % moder;\n}\n/*--------Library Zone!--------*/\n\n\nP dat[1000000];\nint size_ = 1;\nvoid init(int x) {\n\twhile (size_ < x)size_ *= 2;\n\t//rep(i, 2 * size_ - 1)dat[i] = { ((int)(1) << 31) - 1,inf };\n}\nvoid eval(int k, int l, int r) {\n\tif (dat[k].second) {\n\t\tdat[k].first = dat[k].second;\n\t\tif (r - l > 1) {\n\t\t\tdat[k * 2 + 1].second = dat[k].second / 2;\n\t\t\tdat[k * 2 + 2].second = dat[k].second / 2;\n\t\t}\n\t\tdat[k].second = 0;\n\t}\n}\nvoid update(int a, int b, int k, int x, int l, int r) {\n\teval(k, l, r);\n\tif (r <= a || b <= l)return;\n\tif (a <= l && r <= b) {\n\t\tdat[k].second = x * (r - l);\n\t\teval(k, l, r);\n\t}\n\telse {\n\t\tupdate(a, b, k * 2 + 1, x, l, (l + r) / 2);\n\t\tupdate(a, b, k * 2 + 2, x, (l + r) / 2, r);\n\t\tdat[k].first = dat[k * 2 + 1].first + dat[k * 2 + 2].first;\n\t}\n}\nint query(int a, int b, int k, int l, int r) {\n\teval(k, l, r);\n\tif (r <= a || b <= l)return 0;\n\tif (a <= l && r <= b) {\n\t\treturn dat[k].first;\n\t}\n\tint lv = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\tint rv = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\treturn lv + rv;\n}\nsigned main() {\n\tint n, q;\n\tcin >> n >> q;\n\tinit(n);\n\trep(i, q) {\n\t\tint a; cin >> a;\n\t\tif (!a) {\n\t\t\tint s, t, x; cin >> s >> t >> x;\n\t\t\tupdate(s, t + 1, 0, x, 0, size_);\n\t\t}\n\t\telse {\n\t\t\tint s, t; cin >> s >> t;\n\t\t\tcout << query(s, t + 1, 0, 0, size_) << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\ntemplate<typename T, typename E> struct LazySegmentTree;\n\ntemplate<typename T, typename E> struct QueryObject {\n  LazySegmentTree<T, E> *lst;\n  int a, b;\n  E x;\n  int k;\n  int l, r;\n  QueryObject(LazySegmentTree<T, E> *lst,\n      int a, int b, E x = 0, int k = 0, int l = 0, int r = -1)\n      : lst(lst), a(a), b(b), x(x), k(k), l(l), r(r) {}\n};\n\ntemplate<typename T, typename E> struct QueryType {\n  virtual int outOfRange(QueryObject<T, E> o) = 0;\n  virtual int cover(QueryObject<T, E> o) = 0;\n  virtual int join(QueryObject<T, E> o, T vl, T vr) = 0;\n  T query(QueryObject<T, E> o) {\n    if (o.r < 0) o.r = o.lst->n;\n    o.lst->eval(o.r - o.l, o.k);\n    if (o.b <= o.l || o.r <= o.a) return outOfRange(o);\n    if (o.a <= o.l && o.r <= o.b) return cover(o);\n    QueryObject<T, E> o1 = o, o2 = o;\n    o1.k = o.k * 2 + 1; o1.r = (o.l + o.r) / 2;\n    o2.k = o.k * 2 + 2; o2.l = (o.l + o.r) / 2;\n    T vl = query(o1);\n    T vr = query(o2);\n    return join(o, vl, vr);\n  }\n};\n\ntemplate<typename T, typename E> struct Setter : QueryType<T, E> {\n  enum setter { RUQ, RAQ };\n  int outOfRange(QueryObject<T, E> o) {\n    return o.lst->data[o.k];\n  }\n  int cover(QueryObject<T, E> o) {\n    o.lst->lazy[o.k] = o.lst->h(o.lst->lazy[o.k], o.x);\n    o.lst->eval(o.r - o.l, o.k);\n    return o.lst->data[o.k];\n  }\n  int join(QueryObject<T, E> o, T vl, T vr) {\n    return o.lst->data[o.k] = o.lst->f(vl, vr);\n  }\n};\n\ntemplate<typename T, typename E> struct Getter : QueryType<T, E> {\n  enum getter { RMQ, RSQ };\n  int outOfRange(QueryObject<T, E> o) {\n    return o.lst->initT;\n  }\n  int cover(QueryObject<T, E> o) {\n    return o.lst->data[o.k];\n  }\n  int join(QueryObject<T, E> o, T vl, T vr) {\n    return o.lst->f(vl, vr);\n  }\n};\n\ntemplate<typename T, typename E> struct LazySegmentTree {\n  using F = function<T(T, T)>;\n  using G = function<T(T, E)>;\n  using H = function<E(E, E)>;\n  using P = function<E(E, int)>;\n  F add() {\n    return [&](const T& x, const T& y) -> const T { return x + y; };\n  }\n  F minimum() {\n    return [&](const T& x, const T& y) -> const T { return min(x, y); };\n  }\n  G ex_assign(E initE) {\n    return [&initE](const T& x, const E& y) -> const T { return (y == initE) ? x : y; };\n  }\n  P ex_multiplies(E initE) {\n    return [&initE](const E& x, int y) -> const E { return (x == initE) ? x : x * y; };\n  }\n\n  int n;\n  T initT;\n  E initE;\n  F f;\n  G g;\n  H h;\n  P p;\n  vector<T> data;\n  vector<E> lazy;\n  QueryType<T, E> *type;\n\n  LazySegmentTree() {}\n  LazySegmentTree(QueryType<T, E> *type_) { type = type_; }\n  LazySegmentTree(int n_, int setter, int getter,\n      T initT_ = INT_MAX, E initE_ = INT_MAX, vector<T> v = vector<T>{}) {\n    setQuery(setter, getter, initT_, initE_);\n    n = 1;\n    while (n < n_) n *= 2;\n    data.assign(n * 2 - 1, initT);\n    lazy.assign(n * 2 - 1, initE);\n    if (n_ == v.size()) build(v);\n  }\n  void build(vector<T> v) {\n    for (int i = 0; i < v.size(); ++i) data[i + n - 1] = v[i];\n    for (int i = n - 2; i >= 0; --i) {\n      data[i] = f(data[i * 2 + 1], data[i * 2 + 2]);\n    }\n  }\n  void setQuery(int setter, int getter, T initT_, E initE_) {\n    initT = vector<T>{initT_, 0}[getter];\n    initE = vector<E>{initE_, 0}[setter];\n    f = vector<F>{minimum(), add()}[getter];\n    g = vector<G>{ex_assign(initE), add()}[setter];\n    h = vector<H>{ex_assign(initE), add()}[setter];\n    p = ex_multiplies(initE);\n  }\n  inline void eval(int len, int k) {\n    if (lazy[k] == initE) return;\n    if (k * 2 + 1 < n * 2 - 1) {\n      lazy[k * 2 + 1] = h(lazy[k * 2 + 1], lazy[k]);\n      lazy[k * 2 + 2] = h(lazy[k * 2 + 2], lazy[k]);\n    }\n    data[k] = g(data[k], p(lazy[k], len));\n    lazy[k] = initE;\n  }\n  T query(QueryObject<T, E> obj) {\n    return type->query(obj);\n  }\n  T setData(int a, int b, E x, int k = 0, int l = 0, int r = -1) {\n    LazySegmentTree<T, E> lst(new Setter<T, E>());\n    QueryObject<T, E> obj(this, a, b, x, k, l, r);\n    return lst.query(obj);\n  }\n  T getData(int a, int b, int k = 0, int l = 0, int r = -1) {\n    LazySegmentTree<T, E> lst(new Getter<T, E>());\n    QueryObject<T, E> obj(this, a, b, 0, k, l, r);\n    return lst.query(obj);\n  }\n};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, q; cin >> n >> q;\n  LazySegmentTree<ll, ll> seg(n, Setter<ll, ll>::RUQ, Getter<ll, ll>::RSQ);\n\n  while (q--) {\n    int com; cin >> com;\n    if (com) {\n      int s, t; cin >> s >> t;\n      cout << seg.getData(s, t + 1) << endl;\n    } else {\n      int s, t, x; cin >> s >> t >> x;\n      seg.setData(s, t + 1, x);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vc = vector<char>;\nusing vvc = vector<vc>;\nusing pll = pair<ll, ll>;\nusing stkll = vector<pll>;\nconst ll INF = 1LL << 60;\nconst ll MOD = 1e9 + 7;\n#define rep(i, n) for (ll i = 0; i < (n); i++)\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n#ifndef ONLINE_JUDGE\n    #define debug(x) cerr << #x << \": \" << x << endl;\n#else\n    #define debug(x)\n#endif\n\n/*  RSQ & RUQ （区間和 ＆ 区間更新）\n    チェック問題： http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_I&lang=ja\n*/\n\n/* SegTreeLazyProportional<X,M>(n,fx,fa,fm,fp,ex,em): モノイド(集合X, 二項演算fx,fa,fm,fp\n   単位元ex,em)についてサイズnで構築\n    set(int i, X x), build(): i番目の要素をxにセット。まとめてセグ木を構築する。O(n)\n    update(i,x): i 番目の要素を x に更新。O(log(n))\n    query(a,b):  [a,b) 全てにfxを作用させた値を取得。O(log(n))\n*/\ntemplate <typename X, typename M>\nstruct SegTreeLazyProportional {\n    using FX = function<X(X, X)>;\n    using FA = function<X(X, M)>;\n    using FM = function<M(M, M)>;\n    using FP = function<M(M, int)>;\n    int n;\n    FX fx;\n    FA fa;\n    FM fm;\n    FP fp;\n    const X ex;\n    const M em;\n    vector<X> dat;\n    vector<M> lazy;\n    SegTreeLazyProportional(int n_, FX fx_, FA fa_, FM fm_, FP fp_, X ex_, M em_)\n        : n(), fx(fx_), fa(fa_), fm(fm_), fp(fp_), ex(ex_), em(em_), dat(n_ * 4, ex), lazy(n_ * 4, em) {\n        int x = 1;\n        while (n_ > x) x *= 2;\n        n = x;\n    }\n\n    void set(int i, X x) { dat[i + n - 1] = x; }\n    void build() {\n        for (int k = n - 2; k >= 0; k--) dat[k] = fx(dat[2 * k + 1], dat[2 * k + 2]);\n    }\n\n    /* lazy eval */\n    void eval(int k, int len) {\n        if (lazy[k] == em) return;  // 更新するものが無ければ終了\n        if (k < n - 1) {            // 葉でなければ子に伝搬\n            lazy[k * 2 + 1] = fm(lazy[k * 2 + 1], lazy[k]);\n            lazy[k * 2 + 2] = fm(lazy[k * 2 + 2], lazy[k]);\n        }\n        // 自身を更新\n        dat[k] = fa(dat[k], fp(lazy[k], len));\n        lazy[k] = em;\n    }\n\n    void update(int a, int b, M x, int k, int l, int r) {\n        eval(k, r - l);\n        if (a <= l && r <= b) {  // 完全に内側の時\n            lazy[k] = fm(lazy[k], x);\n            eval(k, r - l);\n        } else if (a < r && l < b) {                     // 一部区間が被る時\n            update(a, b, x, k * 2 + 1, l, (l + r) / 2);  // 左の子\n            update(a, b, x, k * 2 + 2, (l + r) / 2, r);  // 右の子\n            dat[k] = fx(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n    }\n    void update(int a, int b, M x) { update(a, b, x, 0, 0, n); }\n\n    X query_sub(int a, int b, int k, int l, int r) {\n        eval(k, r - l);\n        if (r <= a || b <= l) {  // 完全に外側の時\n            return ex;\n        } else if (a <= l && r <= b) {  // 完全に内側の時\n            return dat[k];\n        } else {  // 一部区間が被る時\n            X vl = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);\n            X vr = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);\n            return fx(vl, vr);\n        }\n    }\n    X query(int a, int b) { return query_sub(a, b, 0, 0, n); }\n\n    /* debug */\n    inline X operator[](int a) { return query(a, a + 1); }\n    void print() {\n        for (int i = 0; i < n; ++i) {\n            cout << (*this)[i];\n            if (i != n) cout << \",\";\n        }\n        cout << endl;\n    }\n};\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n\n    using X = ll;\n    using M = ll;\n    auto fx = [](X x1, X x2) -> X { return x1 + x2 ; };\n    auto fa = [](X x, M m) -> X { return m ; };\n    auto fm = [](M m1, M m2) -> M { return m2 ; };\n    auto fp = [](M m, int n) -> M {return m * n;};\n    X ex = 0;\n    M em = INF;\n    SegTreeLazyProportional<X, M> seg(n, fx, fa, fm, fp, ex, em);\n    rep(i, n) seg.set(i, 0);\n    seg.build();\n\n    rep(i, q) {\n        int com, s, t, x;\n        cin >> com >> s >> t;\n        if(com == 0) {\n            cin >> x;\n            seg.update(s, t+1, x);\n        }\n        else cout << seg.query(s, t+1) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\ntemplate<typename T, typename E> struct LazySegmentTree;\n\ntemplate<typename T, typename E> struct QueryObject {\n  LazySegmentTree<T, E> *lst;\n  int a, b;\n  E x;\n  int k;\n  int l, r;\n  QueryObject(LazySegmentTree<T, E> *lst,\n      int a, int b, E x = 0, int k = 0, int l = 0, int r = -1)\n      : lst(lst), a(a), b(b), x(x), k(k), l(l), r(r) {}\n};\n\ntemplate<typename T, typename E> struct QueryType {\n  virtual int outOfRange(QueryObject<T, E> o) = 0;\n  virtual int cover(QueryObject<T, E> o) = 0;\n  virtual int join(QueryObject<T, E> o, T vl, T vr) = 0;\n  T query(QueryObject<T, E> o) {\n    if (o.r < 0) o.r = o.lst->n;\n    o.lst->eval(o.r - o.l, o.k);\n    if (o.b <= o.l || o.r <= o.a) return outOfRange(o);\n    if (o.a <= o.l && o.r <= o.b) return cover(o);\n    QueryObject<T, E> o1 = o, o2 = o;\n    o1.k = o.k * 2 + 1; o1.r = (o.l + o.r) / 2;\n    o2.k = o.k * 2 + 2; o2.l = (o.l + o.r) / 2;\n    T vl = query(o1);\n    T vr = query(o2);\n    return join(o, vl, vr);\n  }\n};\n\ntemplate<typename T, typename E> struct Setter : QueryType<T, E> {\n  enum setter { RUQ, RAQ };\n  int outOfRange(QueryObject<T, E> o) {\n    return o.lst->data[o.k];\n  }\n  int cover(QueryObject<T, E> o) {\n    o.lst->lazy[o.k] = o.lst->h(o.lst->lazy[o.k], o.x);\n    o.lst->eval(o.r - o.l, o.k);\n    return o.lst->data[o.k];\n  }\n  int join(QueryObject<T, E> o, T vl, T vr) {\n    return o.lst->data[o.k] = o.lst->f(vl, vr);\n  }\n};\n\ntemplate<typename T, typename E> struct Getter : QueryType<T, E> {\n  enum getter { RMQ, RSQ };\n  int outOfRange(QueryObject<T, E> o) {\n    return o.lst->initT;\n  }\n  int cover(QueryObject<T, E> o) {\n    return o.lst->data[o.k];\n  }\n  int join(QueryObject<T, E> o, T vl, T vr) {\n    return o.lst->f(vl, vr);\n  }\n};\n\ntemplate<typename T, typename E> struct LazySegmentTree {\n  using F = function<T(T, T)>;\n  using G = function<T(T, E)>;\n  using H = function<E(E, E)>;\n  using P = function<E(E, int)>;\n  F add() {\n    return [&](const T& x, const T& y) -> const T { return x + y; };\n  }\n  F minimum() {\n    return [&](const T& x, const T& y) -> const T { return min(x, y); };\n  }\n  G ex_assign(E initE) {\n    return [&initE](const T& x, const E& y) -> const T { return (y == initE) ? x : y; };\n  }\n  P ex_multiplies(E initE) {\n    return [&initE](const E& x, int y) -> const E { return (x == initE) ? x : x * y; };\n  }\n\n  int n;\n  T initT;\n  E initE;\n  F f;\n  G g;\n  H h;\n  P p;\n  vector<T> data;\n  vector<E> lazy;\n  QueryType<T, E> *type;\n\n  LazySegmentTree() {}\n  LazySegmentTree(QueryType<T, E> *type_) { type = type_; }\n  LazySegmentTree(int n_, int setter, int getter,\n      T initT_ = INT_MAX, E initE_ = INT_MAX, vector<T> v = vector<T>()) {\n    setQuery(setter, getter, initT_, initE_);\n    n = 1;\n    while (n < n_) n *= 2;\n    data.assign(n * 2 - 1, initT);\n    lazy.assign(n * 2 - 1, initE);\n    if (n_ == v.size()) build(v);\n  }\n  void build(vector<T> v) {\n    for (int i = 0; i < v.size(); ++i) data[i + n - 1] = v[i];\n    for (int i = n - 2; i >= 0; --i) {\n      data[i] = f(data[i * 2 + 1], data[i * 2 + 2]);\n    }\n  }\n  void setQuery(int setter, int getter, T initT_, E initE_) {\n    initT = vector<T>{initT_, 0}[getter];\n    initE = vector<E>{initE_, 0}[setter];\n    f = vector<F>{minimum(), add()}[getter];\n    g = vector<G>{ex_assign(initE), add()}[setter];\n    h = vector<H>{ex_assign(initE), add()}[setter];\n    p = ex_multiplies(initE);\n  }\n  inline void eval(int len, int k) {\n    if (lazy[k] == initE) return;\n    if (k * 2 + 1 < n * 2 - 1) {\n      lazy[k * 2 + 1] = h(lazy[k * 2 + 1], lazy[k]);\n      lazy[k * 2 + 2] = h(lazy[k * 2 + 2], lazy[k]);\n    }\n    data[k] = g(data[k], p(lazy[k], len));\n    lazy[k] = initE;\n  }\n  T query(QueryObject<T, E>& obj) {\n    return type->query(obj);\n  }\n  T setData(int a, int b, E x) {\n    LazySegmentTree<T, E> lst(new Setter<T, E>());\n    QueryObject<T, E> obj(this, a, b, x);\n    return lst.query(obj);\n  }\n  T getData(int a, int b) {\n    LazySegmentTree<T, E> lst(new Getter<T, E>());\n    QueryObject<T, E> obj(this, a, b);\n    return lst.query(obj);\n  }\n};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, q; cin >> n >> q;\n  LazySegmentTree<ll, ll> seg(n, Setter<ll, ll>::RUQ, Getter<ll, ll>::RSQ);\n\n  while (q--) {\n    int com; cin >> com;\n    if (com) {\n      int s, t; cin >> s >> t;\n      cout << seg.getData(s, t + 1) << endl;\n    } else {\n      int s, t, x; cin >> s >> t >> x;\n      seg.setData(s, t + 1, x);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\n// T: The type of values.\n// U: The type of operators.\n// Three conditions.\n// - apply_op(merge(x1, x2), o) = merge(apply_op(x1, o), apply_op(x2, o))\n// - apply_op(apply_op(x, o1), o2) = apply_op(x, merge_op(o1, o2))\n// - apply_op(x, empty_op) = x\n// Verified: AOJ-DSL2F, AOJ_DSL2G\ntemplate<typename T, typename U>\nclass LazyPropagationSegmentTree {\n private:\n  function<T(T, T)> merge;\n  T empty_value;\n  function<U(U, U)> op_merge;\n  U empty_op;\n  function<T(T, U)> apply_op;\n  int num_nodes;  \n  vector<T> nodes;\n  vector<U> op_nodes;\n\n  void DoLazyPropagation(int node_index) {\n   if (op_nodes[node_index] != empty_op) {\n      nodes[node_index] = apply_op(nodes[node_index], op_nodes[node_index]);\n      if (node_index < num_nodes / 2) {\n        op_nodes[2 * node_index] =\n            op_merge(op_nodes[2 * node_index], op_nodes[node_index]);\n        op_nodes[2 * node_index + 1] =\n            op_merge(op_nodes[2 * node_index + 1], op_nodes[node_index]);\n      }\n      op_nodes[node_index] = empty_op;\n    }\n  }\n\n  void ApplyOpRangeInternal(\n      int node_index, int node_l, int node_r, int l, int r, U op) {\n    DoLazyPropagation(node_index);\n\n    if (node_r <= l || r <= node_l) return;\n\n    if (l <= node_l && node_r <= r) {\n      op_nodes[node_index] = op;\n      DoLazyPropagation(node_index);\n      return;\n    }\n    int node_m = (node_l + node_r) / 2;\n    ApplyOpRangeInternal(2 * node_index, node_l, node_m, l, r, op);\n    ApplyOpRangeInternal(2 * node_index + 1, node_m, node_r, l, r, op);\n    nodes[node_index] = merge(nodes[2 * node_index], nodes[2 * node_index + 1]);\n  }\n\n  T GetRangeInternal(\n      int node_index, int node_l, int node_r, int l, int r) {\n    DoLazyPropagation(node_index);\n\n    if (node_r <= l || r <= node_l) return empty_value;\n\n    if (l <= node_l && node_r <= r) {\n      return nodes[node_index];\n    }\n\n    int node_m = (node_l + node_r) / 2;\n    return merge(\n        GetRangeInternal(2 * node_index, node_l, node_m, l, r),\n        GetRangeInternal(2 * node_index + 1, node_m, node_r, l, r));\n  }\n\n public:\n  LazyPropagationSegmentTree(\n      function<T(T, T)> in_merge, T in_empty_value,\n      function<U(U, U)> in_op_merge, U in_empty_op,\n      function<T(T, U)> in_apply_op, vector<T> values) :\n          merge(in_merge), empty_value(in_empty_value), op_merge(in_op_merge),\n          empty_op(in_empty_op), apply_op(in_apply_op) {\n    int n = values.size();\n    num_nodes = 1;\n    while (num_nodes < n) num_nodes *= 2;\n    num_nodes *= 2;\n    nodes = vector<T>(num_nodes, empty_value);\n    op_nodes = vector<U>(num_nodes, empty_op);\n    for (int i = 0; i < values.size(); ++i) {\n      nodes[num_nodes / 2 + i] = values[i];\n    }\n    for (int i = num_nodes / 2 - 1; i >= 1; i--) {\n      nodes[i] = merge(nodes[2 * i], nodes[2 * i + 1]);\n    }\n  }\n\n  // Applies the operator to the range [l, r).\n  void ApplyOpRange(int l, int r, U op) {\n    return ApplyOpRangeInternal(1, 0, num_nodes / 2, l, r, op);\n  }\n\n  T GetRange(int l, int r) {\n    return GetRangeInternal(1, 0, num_nodes / 2, l, r);\n  }\n  \n  T Get(int i) { return GetRange(i, i + 1); }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n, q;\n  cin >> n >> q;\n  vector<pair<int64, int>> xs(n, make_pair(0, 1));\n\n  auto merge =\n      function<pair<int64, int>(pair<int64, int>, pair<int64, int>)>(\n          [] (pair<int64, int> e1, pair<int64, int> e2) {\n            return make_pair(e1.first + e2.first, e1.second + e2.second);\n          });\n  constexpr auto EMPTY_VALUE = make_pair(0, 0);\n  auto op_merge =\n      function<int64(int64, int64)>([] (int64 x, int64 y) { return y; });\n  constexpr int64 EMPTY_OP = INT_MIN;\n  auto apply_op =\n      function<pair<int64, int>(pair<int64, int>, int64)>(\n          [] (pair<int64, int> e, int64 op) {\n            return make_pair(e.second * op, e.second);\n          });\n  auto tree = LazyPropagationSegmentTree<pair<int64, int>, int64>(\n      merge, EMPTY_VALUE, op_merge, EMPTY_OP, apply_op, xs);\n\n  for (int i = 0; i < q; i++) {\n    int c;\n    cin >> c;\n    if (c == 0) {\n      int s, t, v;\n      cin >> s >> t >> v;\n      tree.ApplyOpRange(s, t + 1, v);\n      // tree.Dump();\n    } else {\n      int s, t;\n      cin >> s >> t;\n      cout << tree.GetRange(s, t + 1).first << endl;\n      // tree.Dump();\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n \nusing namespace std;\n \ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n \nconst int MAX_N = 100005;\n \ntemplate<typename T> class segtree {\nprivate:\n    int n,sz,h;\n    vector<T> node, lazy, lazyFlag;\n    void eval(int k) {\n        if(lazyFlag[k]){\n            node[k] = lazy[k];\n            if(k < n) {\n                lazy[k*2] = lazy[k*2+1] = lazy[k] / 2;\n                lazyFlag[k*2] = lazyFlag[k*2+1] = true;\n            }\n            lazyFlag[k] = false;\n        }\n    }\n\npublic:\n    segtree(vector<T>& v) : n(1), sz((int)v.size()), h(0) {\n        while(n < sz) n *= 2, h++;\n        node.resize(2*n, 0), lazy.resize(2*n, 0), lazyFlag.resize(2*n, false);\n        for(int i = 0; i < sz; i++) node[i+n] = v[i];\n        for(int i = n-1; i >= 1; i--) node[i] = node[2*i] + node[2*i+1];\n    }\n    void range(int a, int b, T x, int k=1, int l=0, int r=-1){\n        if(r < 0) r = n;\n        eval(k);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b){\n            lazy[k] = (r-l)*x; lazyFlag[k] = true, eval(k);\n        }else{\n            range(a, b, x, 2*k, l, (l+r)/2);\n            range(a, b, x, 2*k+1, (l+r)/2, r);\n            node[k] = node[2*k] + node[2*k+1];\n        }\n    }\n    T query(int a, int b) {\n        a += n, b += n - 1;\n        for(int i = h; i > 0; i--) eval(a >> i), eval(b >> i);\n        b++;\n        T res1 = 0, res2 = 0;\n        while(a < b) {\n            if(a & 1) eval(a), res1 += node[a++];\n            if(b & 1) eval(--b), res2 += node[b];\n            a >>= 1, b >>= 1;\n        }\n        return res1 + res2;\n    }\n    void print(){for(int i = 0; i < sz; i++) cout<<query(i,i+1)<< \" \";cout<<endl;}\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,q;\n    cin >> n >> q;\n    vector<int> vec(n,0);\n    segtree<int> sg2(vec);\n    rep(i,q){\n        int a;\n        cin >> a;\n        if(a==0){\n            int b,c,d;\n            cin >> b >> c >> d;\n            sg2.range(b,c+1,d);\n        }else{\n            int b,c;\n            cin >> b >> c;\n            cout << sg2.query(b,c+1) << \"\\n\";\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n// Debug\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\nusing LL = int64_t;\nconst int64_t MOD = 1e9+7;\ntemplate<typename M, typename OM = M>\nstruct RandomizedBinarySearchTree {\n    struct Node {\n        Node *lch, *rch;\n        int sz;\n        M data, sum;\n        OM lazy;\n        Node(const M& data, const OM& lazy) :\n            lch(nullptr), rch(nullptr), sz(1),\n            data(data), sum(data), lazy(lazy) {}\n    };\n    const function<M(M,M)> f;\n    const function<M(M,OM,int)> g;\n    const function<OM(OM,OM)> h;\n    const M e;\n    const OM oe;\n    std::mt19937 rand;\n    const int SEED = 0;\n    Node* root;\n    RandomizedBinarySearchTree(\n            const function<M(M,M)>& f,\n            const function<M(M,OM,int)>& g,\n            const function<OM(OM,OM)>& h,\n            const M& e, const OM& oe\n            ) : f(f), g(g), h(h), e(e), oe(oe), rand(SEED), root(nullptr) {}\n    Node* _build(const vector<M>& v, int l, int r) {\n        if (l+1 >= r) return _new(v[l]);\n        return merge(_build(v, l, (l+r)>>1),\n                     _build(v, (l+r)>>1, r));\n    }\n    void build(const vector<M>& v) { root = _build(v, 0, v.size()); }\n    Node* _build(int l, int r) {\n        if (l+1 >= r) return _new(e);\n        return merge(_build(l, (l+r)>>1),\n                     _build((l+r)>>1, r));\n    }\n    void build(int size) { root = _build(0, size); }\n    inline Node* _new(const M& data) { return new Node(data, oe); }\n    inline int size(Node* t) const { return t ? t->sz : 0; }\n    inline M sum(Node* t) const { return t ? t->sum : e; }\n    inline OM lazy(Node* t) const { return t ? t->lazy : oe; }\n    inline Node* modify(Node *t) {\n        t->sz = size(t->lch) + size(t->rch) + 1;\n        t->sum = f(f(sum(t->lch), t->data), sum(t->rch));\n        return t;\n    }\n    // Lazy Segment Tree\n    Node* propagate(Node* t) {\n        if (!t) return t;\n        if (lazy(t) == oe) return t;\n        if (t->lch != nullptr) {\n            t->lch->lazy = h(lazy(t->lch), lazy(t));\n            t->lch->sum = g(sum(t->lch), lazy(t), size(t->lch));\n        }\n        if (t->rch != nullptr) {\n            t->rch->lazy = h(lazy(t->rch), lazy(t));\n            t->rch->sum = g(sum(t->rch), lazy(t), size(t->rch));\n        }\n        t->data = g(t->data, lazy(t), 1);\n        t->lazy = oe;\n        return modify(t);\n    }\n    void update(int a, int b, const OM& lazy) {\n        // data[a, b) = g(data[a, b), lazy)\n        auto p0 = split(root, a);\n        auto p1 = split(p0.second, b-a);\n        p1.first->lazy = h(p1.first->lazy, lazy);\n        p1.first = propagate(p1.first);\n        root = merge(p0.first, merge(p1.first, p1.second));\n    }\n    M query(int a, int b) {\n        // return f[a,b)\n        auto p0 = split(root, a);\n        auto p1 = split(p0.second, b-a);\n        p1.first = propagate(p1.first);\n        M ret = sum(p1.first);\n        root = merge(p0.first, merge(p1.first, p1.second));\n        return ret;\n    }\n    // Binary Search Tree\n    Node* merge(Node *l, Node *r) {\n        if (!l) return r;\n        if (!r) return l;\n        std::uniform_int_distribution<> dist(1,size(l)+size(r));\n        if (dist(rand) > size(l)) {\n            r = propagate(r);\n            r->lch = merge(l, r->lch);\n            return modify(r);\n        } else {\n            l = propagate(l);\n            l->rch = merge(l->rch, r);\n            return modify(l);\n        }\n    }\n    pair<Node*, Node*> split(Node* t, int k) {\n        if (!t) return {t, t};\n        t = propagate(t);\n        if (k > size(t->lch)) {\n            auto p = split(t->rch, k-size(t->lch)-1);\n            t->rch = p.first;\n            return {modify(t), p.second};\n        } else {\n            auto p = split(t->lch, k);\n            t->lch = p.second;\n            return {p.first, modify(t)};\n        }\n    }\n    void insert(int k, const M& data) {\n        auto q = _new(data);\n        auto p = split(root, k);\n        root = merge(merge(p.first, q), p.second);\n    }\n    M erase(int k) {\n        auto p = split(root, k);\n        auto q = split(p.second, 1);\n        M ret = q.first->data;\n        root = merge(p.first, q.second);\n        return ret;\n    }\n    void print(Node* t) {\n        if (!t) return;\n        if (t->lch) { cout << \"(\"; print(t->lch); cout << \")\"; }\n        cout << t->data;\n        if (t->rch) { cout << \"(\"; print(t->rch); cout << \")\"; }\n    }\n    void print_sum(Node* t) {\n        if (!t) return;\n        if (t->lch) { cout << \"(\"; print(t->lch); cout << \")\"; }\n        cout << sum(t);\n        if (t->rch) { cout << \"(\"; print(t->rch); cout << \")\"; }\n    }\n    void print_lazy(Node* t) {\n        if (!t) return;\n        if (t->lch) { cout << \"(\"; print(t->lch); cout << \")\"; }\n        cout << lazy(t);\n        if (t->rch) { cout << \"(\"; print(t->rch); cout << \")\"; }\n    }\n    friend ostream& operator<<(ostream& os, RandomizedBinarySearchTree& tr) {\n        os << \"data: \"; tr.print(tr.root); os << endl;\n        os << \" sum: \"; tr.print_sum(tr.root); os << endl;\n        os << \"lazy: \"; tr.print_lazy(tr.root); os << endl;\n        return os;\n    }\n};\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n    RandomizedBinarySearchTree<int64_t> rsq_ruq(\n            [](int64_t a, int64_t b){ return a + b; },\n            [](int64_t a, int64_t b, int w){ return b*w; },\n            [](int64_t a, int64_t b){ return b; },\n            0, numeric_limits<int64_t>::max());\n    rsq_ruq.build(N);\n    while (Q--) {\n        int C; cin >> C;\n        if (C == 0) {\n            int S, T; int X;\n            cin >> S >> T >> X;\n            rsq_ruq.update(S, T+1, X);\n        } else {\n            int S, T;\n            cin >> S >> T;\n            cout << rsq_ruq.query(S, T+1) << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <functional>\nusing namespace std;\n\ntemplate<typename Monoid, typename OperatorMonoid>\nstruct LazySegmentTree {\n    using F = function<Monoid(Monoid, Monoid)>;\n    using G = function<Monoid(Monoid, OperatorMonoid)>;\n    using H = function<OperatorMonoid(OperatorMonoid, OperatorMonoid)>;\n    const F f;\n    const G g;\n    const H h;\n    const Monoid M1;\n    const OperatorMonoid OM0;\n    int sz, height;\n    vector<Monoid> data;\n    vector<OperatorMonoid> lazy;\n    LazySegmentTree(int n, const F f, const G g, const H h,\n                    const Monoid &M1, const OperatorMonoid &OM0)\n        : f(f), g(g), h(h), M1(M1), OM0(OM0), sz(1), height(0)\n    {\n        while (sz < n) sz <<= 1, height++;\n        data.assign(sz * 2, M1);\n        lazy.assign(sz * 2, OM0);\n    }\n    void set(int k, const Monoid &x) { data[k + sz] = x; }\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            data[k] = f(data[k << 1 | 0], data[k << 1 | 1]);\n        }\n    }\n    inline Monoid reflect(int k) {\n        return lazy[k] == OM0 ? data[k] : g(data[k], lazy[k]);\n    }\n    inline void propagate(int k) {\n        if (lazy[k] == OM0) return ;\n        lazy[k << 1 | 0] = h(lazy[k << 1 | 0], lazy[k]);\n        lazy[k << 1 | 1] = h(lazy[k << 1 | 1], lazy[k]);\n        data[k] = reflect(k);\n        lazy[k] = OM0;\n    }\n    inline void thrust(int k) {\n        for (int i = height; i > 0; i--) propagate(k >> i);\n    }\n    inline void recalc(int k) {\n        while (k >>= 1) data[k] = f(reflect(k << 1 | 0), reflect(k << 1 | 1));\n    }\n    void update(int a, int b, const OperatorMonoid &x) {\n        thrust(a += sz);\n        thrust(b += sz - 1);\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) lazy[l] = h(lazy[l], x), ++l;\n            if (r & 1) --r, lazy[r] = h(lazy[r], x);\n        }\n        recalc(a);\n        recalc(b);\n    }\n    Monoid get(int a, int b) {\n        thrust(a += sz);\n        thrust(b += sz - 1);\n        Monoid L = M1, R = M1;\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) L = f(L, reflect(l++));\n            if (r & 1) R = f(reflect(--r), R);\n        }\n        return f(L, R);\n    }\n    Monoid operator[](const int &k) { return get(k, k + 1); }\n};\n\nconst int INF = (int)1e9 + 7;\nint main() {\n    int n, q; cin >> n >> q;\n    struct T {\n        long long sum; int num;\n        T(long long sum, int num) : sum(sum), num(num) { }\n    };\n    using E = int;\n    auto f = [](T a, T b) { return T(a.sum + b.sum, a.num + b.num); };\n    auto g = [](T a, E b) { return T(a.num * b, a.num); };\n    auto h = [](E a, E b) { (void)a; return E(b); };\n    LazySegmentTree<T, E> seg(n, f, g, h, T(0, 1), E(INF));\n    seg.build();\n    while (q--) {\n        int op; cin >> op;\n        int s, t; cin >> s >> t; t++;\n        if (op == 0) {\n            int x; cin >> x;\n            seg.update(s, t, x);\n        }\n        if (op == 1) {\n            cout << seg.get(s, t).sum << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n/*昨日はStarry Sky Treeと同じ*/\n/*Range Add Min(Max) Query*/\n/*区間加算、区間Min,区間Max*/\n\nclass RSUQ{\npublic: \n  typedef long long ll;\n\n  //マージ可能な主データ型\n  struct D{\n    ll value;\n    D():value(0){} /*適切な値にする!!!!!!*/\n    D(ll value):value(value){}\n    bool operator < (D a)const {return value < a.value;}\n  };\n\n  //遅延用の型  \n  struct T{\n    int type; //0 - empty   , 1 - update\n    ll value;\n    T():type(0),value(0){}\n    T(int type,ll value):type(type),value(value){}\n  };\n\n  \n  int n, n_;\n  vector<D> dat;\n  vector<T> td;\n  D returnD = D(0); // 範囲外の時に返す値。\n  \n  RSUQ(){n=-1;}\n  RSUQ(int n_):n_(n_){\n    n=1;\n    while(n < n_) n *= 2;\n    td.resize(2*n-1,T());\n    dat.resize(2*n-1,D());\n  }\n  \n  inline D merge(D a,D b){return a.value + b.value;}\n  \n  void delay(int k,int len){\n    if(td[k].type==0) return;\n    ll v = td[k].value;\n    td[k].type = 0;\n    td[k].value = 0;\n    \n    len /= 2;\n    {\n      int l = k*2+1;\n      dat[l].value = v * len; td[l].type = 1; td[l].value = v;\n    }\n    {\n      int r = k*2+2;\n      dat[r].value = v * len; td[r].type = 1; td[r].value = v;\n    }\n  }\n\n  D write(int k, D x, int len){\n    dat[k].value = x.value * len;\n    td[k].type = 1;\n    td[k].value = x.value;\n    return dat[k];\n  }\n  \n  D dfs(int a, int b, D x, bool flag, int k, int l, int r){\n    if(r <= a||b <= l) return flag? dat[k]:returnD;\n    if(a <= l && r <= b) return flag? write(k, x, r - l):dat[k];\n    delay(k, r - l);\n    D vl = dfs(a, b, x, flag, k*2+1, l, (l+r)/2);\n    D vr = dfs(a, b, x, flag, k*2+2, (l+r)/2, r);\n    return flag? (dat[k] = merge(vl, vr)):merge(vl, vr);\n  }\n\n  //[l,r)の値をx変更　query(l,r,x)\n  void update(int l,int r,ll x){\n    assert(l <= r);\n    assert(0 <= l && l <= n);\n    assert(0 <= r && r <= n);\n    dfs(l, r, D(x), true, 0, 0, n);\n  }\n  \n  //[l,r)の合計値を得る　find(a,b);\n  ll find(int l,int r){\n    assert(l <= r);\n    assert(0 <= l && l <= n);\n    assert(0 <= r && r <= n);\n    D res = dfs(l, r, D(), false, 0, 0, n);\n    return res.value;\n  }\n};\n\n\nsigned main(){\n  int n,q;\n  cin>>n>>q;\n  \n  RSUQ rsuq(n);\n\n  while(q--){\n    int cmd;\n    cin>>cmd;\n    if(cmd == 0){\n      int s,t,x;\n      cin>>s>>t>>x;\n      rsuq.update(s,t+1,x);\n    }\n    \n    if(cmd == 1){\n      int s,t;\n      cin>>s>>t;\n      cout<<rsuq.find(s,t+1)<<endl;\n    }\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#line 2 \"library/other/template.hpp\"\n#define _CRT_SECURE_NO_WARNINGS\n#pragma target(\"avx2\")\n#pragma optimize(\"O3\")\n#pragma optimize(\"unroll-loops\")\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <memory>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <string.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define all(V) V.begin(),V.end()\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef std::pair<int, int> P;\ntypedef std::pair<lint, lint> LP;\nconstexpr int INF = INT_MAX/2;\nconstexpr lint LINF = LLONG_MAX/2;\nconstexpr double eps = DBL_EPSILON;\nconstexpr double PI=3.141592653589793238462643383279;\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\ntemplate <class T, class U>\ninline bool chmax(T& lhs, const U& rhs) {\n\tif (lhs < rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T, class U>\ninline bool chmin(T& lhs, const U& rhs) {\n\tif (lhs > rhs) {\n\t\tlhs = rhs;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ninline lint gcd(lint a, lint b) {\n\twhile (b) {\n\t\tlint c = a;\n\t\ta = b; b = c % b;\n\t}\n\treturn a;\n}\ninline lint lcm(lint a, lint b) {\n\treturn a / gcd(a, b) * b;\n}\nbool isprime(lint n) {\n\tif (n == 1)return false;\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0)return false;\n\t}\n\treturn true;\n}\ntemplate<typename T>\nT mypow(T a, lint b) {\n\tT res(1);\n\twhile(b){\n\t\tif(b&1)res*=a;\n\t\ta*=a;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\nlint modpow(lint a, lint b, lint m) {\n\tlint res(1);\n\twhile(b){\n\t\tif(b&1){\n\t\t\tres*=a;res%=m;\n\t\t}\n\t\ta*=a;a%=m;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\ntemplate<typename T>\nvoid printArray(std::vector<T>& vec) {\n\trep(i, vec.size()){\n\t\tstd::cout << vec[i];\n\t\tstd::cout<<(i==(int)vec.size()-1?\"\\n\":\" \");\n\t}\n}\ntemplate<typename T>\nvoid printArray(T l, T r) {\n\tT rprev = std::prev(r);\n\tfor (T i = l; i != rprev; i++) {\n\t\tstd::cout << *i << \" \";\n\t}\n\tstd::cout << *rprev << std::endl;\n}\nLP extGcd(lint a,lint b) {\n\tif(b==0)return {1,0};\n\tLP s=extGcd(b,a%b);\n\tstd::swap(s.first,s.second);\n\ts.second-=a/b*s.first;\n\treturn s;\n}\nLP ChineseRem(const lint& b1,const lint& m1,const lint& b2,const lint& m2) {\n\tlint p=extGcd(m1,m2).first;\n\tlint tmp=(b2-b1)*p%m2;\n\tlint r=(b1+m1*tmp+m1*m2)%(m1*m2);\n\treturn std::make_pair(r,m1*m2);\n}\n/*template<typename F>\ninline constexpr decltype(auto) lambda_fix(F&& f){\n\treturn [f=std::forward<F>(f)](auto&&... args){\n\t\treturn f(f,std::forward<decltype(args)>(args)...);\n\t};\n}*/\n#line 3 \"library/data-structure/SegTree.hpp\"\ntemplate<typename T>\nclass SegTree {\nprotected:\n\tunsigned int n = 1, rank = 0;\n\tstd::vector<T> node;\n\tT nodee;\n\tvirtual T nodef(const T&, const T&)const = 0;\npublic:\n\tSegTree(unsigned int m, T init, T nodee):nodee(nodee) {\n\t\twhile (n < m) {\n\t\t\tn *= 2;\n\t\t\trank++;\n\t\t}\n\t\tnode.resize(2 * n, nodee);\n\t\tfor (unsigned int i = n; i < 2 * n; i++)node[i] = init;\n\t}\n\tSegTree(const std::vector<T>& initvec, T nodee):nodee(nodee) {\n\t\tunsigned int m = initvec.size();\n\t\twhile (n < m) {\n\t\t\tn *= 2;\n\t\t\trank++;\n\t\t}\n\t\tnode.resize(2 * n, nodee);\n\t\tfor (unsigned int i = n; i < 2 * n; i++) {\n\t\t\tif (i - n < m)node[i] = initvec[i - n];\n\t\t}\n\t}\n\tvirtual void update(int i, T x) {\n\t\ti += n;\n\t\tnode[i] = x;\n\t\twhile (i != 1) {\n\t\t\ti >>= 1;\n\t\t\tnode[i] = nodef(node[2 * i], node[2 * i + 1]);\n\t\t}\n\t}\n\tvirtual T query(int l, int r) {\n\t\tl += n; r += n;\n\t\tT ls = nodee, rs = nodee;\n\t\twhile (l < r) {\n\t\t\tif (l & 1) {\n\t\t\t\tls = nodef(ls, node[l]);\n\t\t\t\tl++;\n\t\t\t}\n\t\t\tif (r & 1) {\n\t\t\t\tr--;\n\t\t\t\trs = nodef(node[r], rs);\n\t\t\t}\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t\treturn nodef(ls, rs);\n\t}\n\tvirtual T operator[](const int& x) {\n\t\treturn node[n + x];\n\t}\n\tvoid print() {\n\t\trep(i, n)std::cout << operator[](i) << \" \";\n\t\tstd::cout << std::endl;\n\t}\n};\nclass RSQ :public SegTree<lint> {\n\tlint nodef(const lint& lhs,const lint& rhs)const{return lhs+rhs;}\npublic:\n\tRSQ(int size, const lint& def = 0) :SegTree<lint>(size, def, 0) {\n\t\tfor(int i=n-1;i>0;i--)node[i]=nodef(node[i<<1],node[i<<1|1]);\n\t}\n\tRSQ(const std::vector<lint>& initvec) :SegTree<lint>(initvec, 0) {\n\t\tfor(int i=n-1;i>0;i--)node[i]=nodef(node[i<<1],node[i<<1|1]);\n\t}\n};\nclass RMiQ :public SegTree<lint> {\n\tlint nodef(const lint& lhs,const lint& rhs)const{return std::min(lhs,rhs);}\npublic:\n\tRMiQ(int size, const lint& def = 0) :SegTree<lint>(size, def, LINF) {\n\t\tfor(int i=n-1;i>0;i--)node[i]=nodef(node[i<<1],node[i<<1|1]);\n\t}\n\tRMiQ(const std::vector<lint>& initvec) :SegTree<lint>(initvec, LINF) {\n\t\tfor(int i=n-1;i>0;i--)node[i]=nodef(node[i<<1],node[i<<1|1]);\n\t}\n};\nclass RMaQ :public SegTree<lint> {\n\tlint nodef(const lint& lhs,const lint& rhs)const{return std::max(lhs,rhs);}\npublic:\n\tRMaQ(int size, const lint& def = 0) :SegTree<lint>(size, def, -LINF) {\n\t\tfor(int i=n-1;i>0;i--)node[i]=nodef(node[i<<1],node[i<<1|1]);\n\t}\n\tRMaQ(const std::vector<lint>& initvec) :SegTree<lint>(initvec, -LINF) {\n\t\tfor(int i=n-1;i>0;i--)node[i]=nodef(node[i<<1],node[i<<1|1]);\n\t}\n};\n#line 4 \"library/data-structure/IntervalSegTree.hpp\"\ntemplate<typename T, typename U>\nclass IntervalSegTree :public SegTree<T> {\nprotected:\n\tusing SegTree<T>::n;\n\tusing SegTree<T>::rank;\n\tusing SegTree<T>::node;\n\tusing SegTree<T>::nodef;\n\tusing SegTree<T>::nodee;\n\tstd::vector<U> lazy;\n\tstd::vector<bool> lazyflag;\n\tstd::vector<int> width;\n\tvirtual void lazyf(U&, const U&) = 0;\n\tvirtual void updf(T&, const U&, const unsigned int&) = 0;\n\tvoid eval(int k) {\n\t\tfor (int i = rank; i > 0; i--) {\n\t\t\tint nk = k >> i;\n\t\t\tif (lazyflag[nk]) {\n\t\t\t\tupdf(node[2 * nk], lazy[nk], width[2 * nk]);\n\t\t\t\tupdf(node[2 * nk + 1], lazy[nk], width[2 * nk + 1]);\n\t\t\t\tif (lazyflag[2 * nk])lazyf(lazy[2 * nk], lazy[nk]);\n\t\t\t\telse lazy[2 * nk] = lazy[nk];\n\t\t\t\tif (lazyflag[2 * nk + 1])lazyf(lazy[2 * nk + 1], lazy[nk]);\n\t\t\t\telse lazy[2 * nk + 1] = lazy[nk];\n\t\t\t\tlazyflag[2 * nk] = lazyflag[2 * nk + 1] = true;\n\t\t\t\tlazyflag[nk] = false;\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tIntervalSegTree(unsigned int m, T init, T nodee) :SegTree<T>(m, init, nodee) {\n\t\tlazy.resize(2 * n); lazyflag.resize(2 * n); width.resize(2 * n);\n\t\twidth[1] = n;\n\t\tfor (unsigned int i = 2; i < 2 * n; i++) {\n\t\t\twidth[i] = width[i >> 1] >> 1;\n\t\t}\n\t}\n\tIntervalSegTree(T nodee, const std::vector<T>& initvec) :SegTree<T>(initvec, nodee) {\n\t\tlazy.resize(2 * n); lazyflag.resize(2 * n); width.resize(2 * n);\n\t\twidth[1] = n;\n\t\tfor (unsigned int i = 2; i < 2 * n; i++) {\n\t\t\twidth[i] = width[i >> 1] >> 1;\n\t\t}\n\t}\n\tvoid update(int i, U x) {\n\t\ti += n;\n\t\teval(i);\n\t\tupdf(node[i], x, width[i]);\n\t\tif (lazyflag[i])lazyf(lazy[i], x);\n\t\telse {\n\t\t\tlazyflag[i] = true;\n\t\t\tlazy[i] = x;\n\t\t}\n\t\twhile (i /= 2)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n\t}\n\tvoid update(int l, int r, U x) {\n\t\tl += n; r += n;\n\t\tint nl = l, nr = r;\n\t\twhile (!(nl & 1))nl >>= 1;\n\t\twhile (!(nr & 1))nr >>= 1;\n\t\tnr--;\n\t\teval(nl); eval(nr);\n\t\twhile (l < r) {\n\t\t\tif (l & 1) {\n\t\t\t\tupdf(node[l], x, width[l]);\n\t\t\t\tif (lazyflag[l])lazyf(lazy[l], x);\n\t\t\t\telse {\n\t\t\t\t\tlazyflag[l] = true;\n\t\t\t\t\tlazy[l] = x;\n\t\t\t\t}\n\t\t\t\tl++;\n\t\t\t}\n\t\t\tif (r & 1) {\n\t\t\t\tr--;\n\t\t\t\tupdf(node[r], x, width[r]);\n\t\t\t\tif (lazyflag[r])lazyf(lazy[r], x);\n\t\t\t\telse {\n\t\t\t\t\tlazyflag[r] = true;\n\t\t\t\t\tlazy[r] = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t\twhile (nl >>= 1)node[nl] = nodef(node[2 * nl], node[2 * nl + 1]);\n\t\twhile (nr >>= 1)node[nr] = nodef(node[2 * nr], node[2 * nr + 1]);\n\t}\n\tT query(int l, int r) {\n\t\tl += n; r += n;\n\t\teval(l); eval(r - 1);\n\t\tT ls = nodee, rs = nodee;\n\t\twhile (l < r) {\n\t\t\tif (l & 1) {\n\t\t\t\tls = nodef(ls, node[l]);\n\t\t\t\tl++;\n\t\t\t}\n\t\t\tif (r & 1) {\n\t\t\t\tr--;\n\t\t\t\trs = nodef(node[r], rs);\n\t\t\t}\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t\treturn nodef(ls, rs);\n\t}\n\tT operator[](const int& x) {\n\t\teval(n + x);\n\t\treturn node[n + x];\n\t}\n\tT queryForAll() {\n\t\treturn node[1];\n\t}\n};\nclass RAQRSQ :public IntervalSegTree<lint, lint> {\n\tlint nodef(const lint& a, const lint& b)const { return a + b; }\n\tvoid lazyf(lint& a, const lint& b) { a += b; }\n\tvoid updf(lint& a, const lint& b, const unsigned int& width) { a += width * b; }\npublic:\n\tRAQRSQ(int size, const lint& def = 0) :IntervalSegTree<lint, lint>(size, def, 0) {\n\t\tfor (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n\t}\n\tRAQRSQ(const std::vector<lint>& initvec) :IntervalSegTree<lint, lint>((lint)0, initvec) {\n\t\tfor (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n\t}\n};\nclass RAQRMiQ :public IntervalSegTree<lint, lint> {\n\tlint nodef(const lint& a, const lint& b)const { return std::min(a, b); }\n\tvoid lazyf(lint& a, const lint& b) { a += b; }\n\tvoid updf(lint& a, const lint& b, const unsigned int& width) { a += b; }\npublic:\n\tRAQRMiQ(int size, const lint& def = 0) :IntervalSegTree<lint, lint>(size, def, LINF) {\n\t\tfor (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n\t}\n\tRAQRMiQ(const std::vector<lint>& initvec) :IntervalSegTree<lint, lint>(LINF, initvec) {\n\t\tfor (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n\t}\n};\nclass RAQRMaQ :public IntervalSegTree<lint, lint> {\n\tlint nodef(const lint& a, const lint& b)const { return std::max(a, b); }\n\tvoid lazyf(lint& a, const lint& b) { a += b; }\n\tvoid updf(lint& a, const lint& b, const unsigned int& width) { a += b; }\npublic:\n\tRAQRMaQ(unsigned int size, const lint& def = 0) :IntervalSegTree<lint, lint>(size, def, -LINF) {\n\t\tfor (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n\t}\n\tRAQRMaQ(const std::vector<lint>& initvec) :IntervalSegTree<lint, lint>(-LINF, initvec) {\n\t\tfor (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n\t}\n};\nclass RUQRSQ :public IntervalSegTree<lint, lint> {\n\tlint nodef(const lint& a, const lint& b)const { return a + b; }\n\tvoid lazyf(lint& a, const lint& b) { a = b; }\n\tvoid updf(lint& a, const lint& b, const unsigned int& width) { a = width * b; }\npublic:\n\tRUQRSQ(int size, const lint& def = 0) :IntervalSegTree<lint, lint>(size, def, 0) {\n\t\tfor (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n\t}\n\tRUQRSQ(const std::vector<lint>& initvec) :IntervalSegTree<lint, lint>((lint)0, initvec) {\n\t\tfor (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n\t}\n};\nclass RUQRMiQ :public IntervalSegTree<lint, lint> {\n\tlint nodef(const lint& a, const lint& b)const { return std::min(a, b); }\n\tvoid lazyf(lint& a, const lint& b) { a = b; }\n\tvoid updf(lint& a, const lint& b, const unsigned int& width) { a = b; }\npublic:\n\tRUQRMiQ(int size, const lint& def = 0) :IntervalSegTree<lint, lint>(size, def, LINF) {\n\t\tfor (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n\t}\n\tRUQRMiQ(const std::vector<lint>& initvec) :IntervalSegTree<lint, lint>(LINF, initvec) {\n\t\tfor (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n\t}\n};\nclass RUQRMaQ :public IntervalSegTree<lint, lint> {\n\tlint nodef(const lint& a, const lint& b)const { return std::max(a, b); }\n\tvoid lazyf(lint& a, const lint& b) { a = b; }\n\tvoid updf(lint& a, const lint& b, const unsigned int& width) { a = b; }\npublic:\n\tRUQRMaQ(int size, const lint& def = 0) :IntervalSegTree<lint, lint>(size, def, -LINF) {\n\t\tfor (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n\t}\n\tRUQRMaQ(const std::vector<lint>& initvec) :IntervalSegTree<lint, lint>(-LINF, initvec) {\n\t\tfor (int i = n - 1; i > 0; i--)node[i] = nodef(node[2 * i], node[2 * i + 1]);\n\t}\n};\n#line 3 \"main.cpp\"\nint n,q,com;\nint main(){\n\tstd::cin>>n>>q;\n\tRUQRSQ st(n,0);\n\trep(i,q){\n\t\tstd::cin>>com;\n\t\tif(com==0){\n\t\t\tint s,t,x;\n\t\t\tstd::cin>>s>>t>>x;\n\t\t\tst.update(s,t+1,x);\n\t\t}\n\t\telse{\n\t\t\tint s,t;\n\t\t\tstd::cin>>s>>t;\n\t\t\tstd::cout<<st.query(s,t+1)<<std::endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> vec;\n\nclass Seg\n{\npublic:\n    vec data;\n    vec lazy;\n    int n;\n    const int no=1001;\n\n    Seg(int _n)\n    {\n        data.resize(4*_n);\n        lazy.resize(4*_n);\n        for(n=1;n<_n;n<<=1);\n        fill(lazy.begin(),lazy.end(),no);\n    }\n\n    void Down(int p,int l,int r)\n    {\n        if(lazy[p]==no) return;\n        data[p]=lazy[p]*(r-l);\n        if(l+1<r)\n        {\n            lazy[p*2+1]=lazy[p*2+2]=lazy[p];\n        }\n        lazy[p]=no;\n    }\n\n    int update(int p,int l,int r,int x,int a,int b)\n    {\n        if(a>=r||l>=b)\n        {\n            Down(p,l,r);\n            return data[p];\n        }else if(a<=l&&r<=b)\n        {\n            lazy[p]=x;\n            Down(p,l,r);\n            return data[p];\n        }else\n        {\n            Down(p,l,r);\n            int mid=(l+r)/2;\n            return data[p]=update(p*2+1,l,mid,x,a,b)+update(p*2+2,mid,r,x,a,b);\n        }\n    }\n\n    int getSum(int p,int l,int r,int a,int b)\n    {\n        if(a>=r||l>=b) return 0;\n        else if(a<=l&&r<=b)\n        {\n            Down(p,l,r);\n            return data[p];\n        }else\n        {\n            Down(p,l,r);\n            int mid=(l+r)/2;\n            return getSum(p*2+1,l,mid,a,b)+getSum(p*2+2,mid,r,a,b);\n        }\n    }\n};\n\nint main()\n{\n    int n,q;\n\n    while(scanf(\"%d %d\",&n,&q)!=EOF)\n    {\n        Seg seg(n);\n        while(q--)\n        {\n            int op,a,b,c;\n            scanf(\"%d\",&op);\n            if(op)\n            {\n                scanf(\"%d %d\",&a,&b);\n                printf(\"%d\\n\",seg.getSum(0,0,seg.n,a,b+1));\n            }else\n            {\n                scanf(\"%d %d %d\",&a,&b,&c);\n                seg.update(0,0,seg.n,c,a,b+1);\n            }\n        }\n    }\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"stdio.h\"\n#include \"math.h\"\n#include <algorithm>\nusing namespace std;\n\ntypedef  long long ll;\n#define SUQARE_SIZE  100000\n\n// 一括更新\nll block[SUQARE_SIZE];\nll sumBlock[SUQARE_SIZE];\n\nint blockSize;\nint n;\n\nint getBlockIndex(int index){\n    return index / blockSize;\n}\n\n// arrをblock数分だけnumで更新する\nvoid updateArr(ll arr[],int left,ll num){\n    for(int i = left;i < left + blockSize;++i){\n        if(i >= n){\n            break;\n        }\n        arr[i] = num;\n    }\n}\n\nvoid update(ll arr[],int l, int r,int value)\n{\n    // 左端\n    int leftBlockIndex = l % blockSize;\n    // 更新がblockの先頭から始まらないケース\n    if(leftBlockIndex != 0){\n        // blockの値を初期化する\n        int blockIndex = getBlockIndex(l);\n        // blockの値が代入されていた場合はblockの値で、arrを更新する\n        if(block[blockIndex] != 0){\n            updateArr(arr, blockIndex * blockSize, block[blockIndex]);\n            // block値を初期化\n            block[blockIndex] = sumBlock[blockIndex] = 0;\n        }\n        // block間かつl < r間でarrを更新\n        do{\n            arr[l] = value;\n            l++;\n        }while(l % blockSize != 0 && l <= r);\n    }\n    \n    // block間\n    leftBlockIndex = l % blockSize;\n    // blockの先頭かつ、block1つ分を更新できる場合\n    if(leftBlockIndex == 0 && (l - 1) + blockSize <= r){\n        // blockの値を更新する\n        do{\n            int blockIndex = getBlockIndex(l);\n            block[blockIndex] = value;\n            // 0の場合は更新しないので、arrを0で更新する必要がある\n            if(value == 0){\n                updateArr(arr, l, value);\n            }\n            // sumは再び計算する必要がある\n            sumBlock[blockIndex] = 0;\n            l += blockSize;\n        }while((l - 1) + blockSize <= r);\n    }\n    \n    // 右端の更新\n    if(l <= r){\n        leftBlockIndex = l % blockSize;\n        int blockIndex = getBlockIndex(l);\n        // blockの値が代入されていた場合はblockの値で、arrを更新する\n        if(block[blockIndex] != 0){\n            updateArr(arr, blockIndex * blockSize, block[blockIndex]);\n            // block値を初期化\n            block[blockIndex] = sumBlock[blockIndex] = 0;\n        }\n        // l <= r間でarrを更新\n        do{\n            arr[l] = value;\n            l++;\n        }while(l <= r);\n    }\n}\n\nvoid updateSum(int blockIndex){\n    // 配列オーバーは考慮しない\n    for(int i = 0;i < blockSize;++i){\n        sumBlock[blockIndex] += block[blockIndex];\n    }\n}\n\nll query(ll arr[],int l,int r){\n    ll sum = 0;\n    // 左端\n    int leftBlockIndex = l % blockSize;\n    // 更新がblockの先頭から始まらないケース\n    if(leftBlockIndex != 0 && l <= r){\n        // arrが更新されていなかった場合更新する\n        int blockIndex = getBlockIndex(l);\n        if(block[blockIndex] != 0){\n            updateArr(arr, blockIndex * blockSize, block[blockIndex]);\n            // block値を初期化\n            block[blockIndex] = sumBlock[blockIndex] = 0;\n        }\n        \n        // block間かつl < r間でsumを取得\n        do{\n            sum += arr[l];\n            l++;\n        }while(l % blockSize != 0 && l <= r);\n    }\n    \n    // block間\n    leftBlockIndex = l % blockSize;\n    // blockの先頭かつ、block1つ分を更新できる場合\n    if(leftBlockIndex == 0 && (l - 1) + blockSize <= r){\n        // 合計値の更新\n        do{\n            int blockIndex = l / blockSize;\n            // ブロックが計算されていないケース\n            if(block[blockIndex] == 0){\n                do{\n                    sum += arr[l];\n                    l++;\n                }while(l % blockSize != 0);\n            }\n            else{\n                // sumが計算されていないケース\n                if(sumBlock[blockIndex] == 0){\n                    updateSum(blockIndex);\n                }\n                sum += sumBlock[blockIndex];\n                l += blockSize;\n            }\n        }while((l - 1) + blockSize <= r);\n    }\n    \n    // 右端の更新\n    if(l <= r){\n        // arrが更新されていなかった場合更新する\n        int blockIndex = getBlockIndex(l);\n        if(block[blockIndex] != 0){\n            updateArr(arr, blockIndex * blockSize, block[blockIndex]);\n            // block値を初期化\n            block[blockIndex] = sumBlock[blockIndex] = 0;\n        }\n        // l <＝= r間でsumを更新\n        do{\n            sum += arr[l];\n            l++;\n        }while(l <= r);\n    }\n    return sum;\n}\n\nint main(){\n    int q,command,l,r,x;\n    scanf(\"%d %d\",&n,&q);\n    ll a[n];\n    blockSize = sqrt(n);\n    \n    for(int i = 0;i < n;++i){\n        a[i] = block[i] = sumBlock[i] = 0;\n    }\n\n    for(int i = 0;i < q;++i){\n        scanf(\"%d\" \"%d\" \"%d\",&command,&l,&r);\n        // update(s,t,x): as,as+1,...,at をxに変更する。\n        if(command == 0){\n            scanf(\"%d\",&x);\n            update(a,l,r,x);\n        // getSum(s,t):as,as+1,...,at の合計値を出力する。\n        }else{\n            printf(\"%lld\\n\",query(a,l,r));\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> P;\ntypedef tuple<int,int,int> tpl;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SORT(c) sort((c).begin(),(c).end())\n#define REVERSE(c) reverse((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RFOR(i,a,b) for(int i=(a)-1;i>=(b);--i)\n#define RREP(i,n) RFOR(i,n,0)\n\nconst double EPS = 1e-9;\nconst double PI  = acos(-1.0);\nconst int INT_INF = 2147483647;\nconst long long LL_INF = 1LL<<60;\nconst long long MOD = 1000000007;\n\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\ntemplate <typename T,typename E>\nstruct LazySegmentTree{\n    typedef function<T(T,T)> F;\n    typedef function<T(T,E)> G;\n    typedef function<E(E,E)> H;\n    typedef function<E(E,int)> P;\n    int n;\n    F f;\n    G g;\n    H h;\n    P p;\n    T d1;\n    E d0;\n    vector<T> val;\n    vector<E> lazy;\n\n    LazySegmentTree(vector<T> a, F f_, G g_, H h_, T d1_, E d0_, P p_=[](E a,int b){return a;}):\n        f(f_),g(g_),h(h_),d1(d1_),d0(d0_),p(p_){\n\n        int sz = a.size();\n        n = 1;\n        while (n < sz) n <<= 1;\n        val.clear();\n        val.resize(2 * n - 1, d1);\n        lazy.clear();\n        lazy.resize(2 * n - 1, d0);\n        for (int i = 0; i < sz; i++) val[i + n - 1] = a[i];\n        for (int i = n - 2; i >= 0; i--) val[i] = f(val[i * 2 + 1], val[i * 2 + 2]);\n    }\n\n    inline void eval(int len, int k){\n        if(lazy[k] == d0) return;\n\n        if(2*k+1 < 2*n-1){\n            lazy[2*k+1] = h(lazy[2*k+1], lazy[k]);\n            lazy[2*k+2] = h(lazy[2*k+2], lazy[k]);\n        }\n        val[k] = g(val[k], p(lazy[k], len));\n        lazy[k] = d0;\n    }\n\n    void update(int a, int b, E x, int k=0, int l=0, int r=-1){\n        if(r < 0) r = n;\n        eval(r-l, k);\n        if(r <=a || b <= l) return;\n\n        if(a <= l && r <= b){\n            lazy[k] = h(lazy[k], x);\n            eval(r-l, k);\n        }\n        else{\n            update(a, b, x, 2*k+1, l, (l+r)/2);\n            update(a, b, x, 2*k+2, (l+r)/2, r);\n            val[k] = f(val[2*k+1], val[2*k+2]);\n        }\n    }\n\n    T query(int a, int b, int k=0, int l=0, int r=-1){\n        if(r < 0) r = n;\n        eval(r-l, k);\n        if(r <= a || b <= l) return d1;\n        if(a <= l && r <= b) return val[k];\n        T val_l = query(a, b , 2*k+1, l, (l+r)/2);\n        T val_r = query(a, b , 2*k+2, (l+r)/2, r);\n        return f(val_l, val_r);\n    }\n};\n\nint main(void){\n    auto f = [](int a, int b){return a+b;};\n    auto g = [](int a, int b){return b;};\n    auto h = [](int a, int b){return b;};\n    auto p = [](int a, int b){return a*b;};\n\n    int n,q; cin >> n >> q;\n    VI a(n,0);\n    LazySegmentTree<int,int> st(a, f, g, h, 0, -10000, p);\n    REP(i,q){\n        int c; cin >> c;\n        if(c == 0){\n            int s, t, x; cin >> s >> t >> x;\n            st.update(s, t+1, x);\n        }\n        else{\n            int s,t; cin >> s >> t;\n            cout << st.query(s,t+1) << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst long long INF = (1ll<<31)-1;\n\ntemplate<typename T>\nclass lazy_segment_tree{\n\tint n;\n\tT fval;\n\tvector<T> dat, lazy;\n\tvector<bool> lazyFlag;\n\t\npublic:\n\t\n\tlazy_segment_tree(){\n\t\t\n\t}\n\t\n\tlazy_segment_tree(int n_, T val){\n\t\tinit(n_, val);\n\t}\n\t\n\t~lazy_segment_tree(){\n\t\t\n\t}\n\t\n\tvoid init(int n_, T val){\n\t\tfval = val;\n\t\t\n\t\tn = 1;\n\t\t\n\t\twhile(n < n_) n *= 2;\n\t\t\n\t\tdat.resize(2 * n - 1);\n\t\tlazy.resize(2 * n - 1, fval);\n\t\tlazyFlag.resize(2 * n - 1, false);\n\t\n\t\tfor(int i = 0; i < 2 * n - 1; i++) dat[i] = fval;\n\t}\n\t\n\tvoid eval(int k, int l, int r){\n\t\t\n\t\tif(lazyFlag[k]){\n\t\t\tdat[k] = lazy[k] * (r - l);\n\t\t\t\n\t\t\tif(r - l > 1) {\n\t\t\t\tlazy[2*k+1] = lazy[2*k+2] = lazy[k];\n\t\t\t\tlazyFlag[2*k+1] = lazyFlag[2*k+2] = lazyFlag[k];\n\t\t\t}\n\t\t\t\n\t\t\tlazyFlag[k] = false;\n\t\t}\n\t}\n\t\n\tvoid update(int a, int b, T x, int k = 0, int l = 0, int r = -1){\n\t\tif(r < 0) r = n;\n\t\teval(k, l, r);\n\t\tif(b <= l || r <= a) {return ;}\n\t\tif(a <= l && r <= b){\n\t\t\tlazy[k] = x;\n\t\t\tlazyFlag[k] = true;\n\t\t\teval(k, l, r);\n\t\t} else {\n\t\t\tupdate(a, b, x, 2*k+1, l, (l+r)/2);\n\t\t\tupdate(a, b, x, 2*k+2, (l+r)/2, r);\n\t\t\tdat[k] = (dat[2*k+1] + dat[2*k+2]);\n\t\t}\n\t}\n\t\n\tT query(int a, int b, int k = 0, int l = 0, int r = -1){\n\t\tif(r < 0) r = n;\n\t\teval(k, l, r);\n\t\tif(r <= a || b <= l){\n\t\t\treturn fval;\n\t\t}\n\t\tif(a <= l && r <= b){\n\t\t\treturn dat[k];\n\t\t}else {\n\t\t\tT vl = query(a, b, k * 2 + 1, l, (l + r) / 2 );\n\t\t\tT vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\treturn (vl + vr);\n\t\t}\n\t}\n};\n\nsigned main(){\n\t\n\tlazy_segment_tree<long long> lseg;\n\t\n\tint n, q;\n\t\n\tcin>>n>>q;\n\t\n\tlseg.init(n+10, 0);\n\t\n\tfor(int i = 0; i < q; i++){\n\t\tint com, s, t, x;\n\t\tcin>>com>>s>>t;\n\t\ts++, t++;\n\t\tif(com){\n\t\t\tcout<<lseg.query(s,t+1)<<endl;\n\t\t} else {\n\t\t\tcin>>x;\n\t\t\tlseg.update(s, t+1, x);\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n// #define int long long\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000 //2e9\n#define LLINF 1000000000000000000ll // 1e18\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define dmp(x) cerr << #x << \": \" << x << endl;\n\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\n\ntemplate<class T> using MaxHeap = priority_queue<T>;\ntemplate<class T> using MinHeap = priority_queue<T,vector<T>,greater<T>>;\ntemplate<class T> vector<T> vect(int len,T elem){ return vector<T>(len,elem); }\n\ntemplate<class T,class U>\nostream& operator << (ostream& os,const pair<T,U>& p){\n  os << p.fi << ',' << p.sec; return os;\n}\ntemplate<class T,class U>\nistream& operator >> (istream& is,pair<T,U>& p){\n  is >> p.fi >> p.sec; return is;\n}\ntemplate<class T>\nostream& operator << (ostream &os,const vector<T> &vec){\n  for(int i=0;i<vec.size();i++){\n    os << vec[i];\n    if(i+1<vec.size())os << ' ';\n  }\n  return os;\n}\ntemplate<class T>\nistream& operator >> (istream &is,vector<T>& vec){\n  for(int i=0;i<vec.size();i++)is >> vec[i];\n  return is;\n}\nvoid fastio(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  cout<<fixed<<setprecision(20);\n}\n\nnamespace Math{\n  template<int MOD> // if inv is needed, this shold be prime.\n  struct ModInt{ ll val; ModInt():val(0ll){}\n    ModInt(const ll& v):val(((v%MOD)+MOD)%MOD){}\n    bool operator==(const ModInt& x)const{return val==x.val;}\n    bool operator!=(const ModInt& x)const{return !(*this==x);}\n    bool operator<(const ModInt& x)const{return val<x.val;}\n    bool operator>(const ModInt& x)const{return val>x.val;}\n    bool operator>=(const ModInt& x)const{return !(*this<x);}\n    bool operator<=(const ModInt& x)const{return !(*this>x);}\n    ModInt operator-()const{return ModInt(MOD-val);}\n    ModInt inv()const{return this->pow(MOD-2);}\n    ModInt& operator+=(const ModInt& x){if((val+=x.val)>=MOD)val-=MOD;return *this;}\n    ModInt& operator-=(const ModInt& x){if((val+=MOD-x.val)>=MOD)val-=MOD;return *this;}\n    ModInt& operator*=(const ModInt& x){(val*=x.val)%=MOD;return *this;}\n    ModInt& operator/=(const ModInt& x){return *this *= x.inv();};\n    ModInt operator+(const ModInt& x)const{return ModInt(*this)+=x;}\n    ModInt operator-(const ModInt& x)const{return ModInt(*this)-=x;}\n    ModInt operator*(const ModInt& x)const{return ModInt(*this)*=x;}\n    ModInt operator/(const ModInt& x)const{return ModInt(*this)/=x;}\n    friend istream& operator>>(istream&i,ModInt& x){ll v;i>>v;x=v;return i;}\n    friend ostream& operator<<(ostream&o,const ModInt& x){o<<x.val;return o;}\n    ModInt pow(ll x)const{\n      auto res = ModInt(1ll);\n      auto b = *this;\n      while(x){\n        if(x&1)res *= b;\n        x >>= 1;\n        b *= b;\n      }\n      return res;\n    }\n  };\n\n  template<int MOD>\n  ModInt<MOD> pow(ModInt<MOD> a,ll x){\n    ModInt<MOD> res = ModInt<MOD>(1ll);\n    while(x){\n      if(x&1)res *= a;\n      x >>= 1;\n      a *= a;\n    }\n    return res;\n  }\n\n  constexpr int MOD = 1e9+7;\n  // constexpr int MOD = 998244353;\n  using mint = ModInt<MOD>;\n\n  vector<mint> inv,fac,facinv;\n  // notice: 0C0 = 1 \n  ModInt<MOD> nCr(int n,int r){\n    assert(!(n<r));\n    assert(!(n<0||r<0));\n    return fac[n]*facinv[r]*facinv[n-r];\n  }\n  void init(int SIZE){\n    fac.resize(SIZE+1);\n    inv.resize(SIZE+1);\n    facinv.resize(SIZE+1);\n    fac[0] = inv[1] = facinv[0] = mint(1ll);\n    for(int i=1;i<=SIZE;i++)fac[i]=fac[i-1]*mint(i);\n    for(int i=2;i<=SIZE;i++)inv[i]=mint(0ll)-mint(MOD/i)*inv[MOD%i];\n    for(int i=1;i<=SIZE;i++)facinv[i]=facinv[i-1]*inv[i];\n    return;\n  }\n  template<class T>\n  int digit(T x){\n    int res = 0;\n    while(x){ x /= T(10); res++; }\n    return res;\n  }\n  template<class T>\n  int digit_sum(T x){\n    int res = 0;\n    while(x){ res+=x%10; x/=10; }\n    return res;\n  }\n  template<class T>\n  T gcd(T x,T y){\n    if(y==T(0))return x;\n    else return gcd(y,x%y);\n  }\n}\n\nnamespace DS{\n  template<class T>\n  struct RangeSum{\n    vector<T> vec;\n    RangeSum(){}\n    RangeSum(vector<T> elems):vec(elems){\n      for(int i=1;i<vec.size();i++){\n        vec[i] += vec[i-1];\n      }\n    }\n    T sum(int l,int r){\n      if(l>r)return T(0);\n      if(l==0)return vec[r];\n      else return vec[r]-vec[l-1];\n    }\n  };\n  template<class T>\n  struct BIT{\n    int N;\n    vector<T> bit;\n    BIT(int N):N(N){\n      bit = vector<T>(N+1,T(0));\n    }\n    void add(int i,T x){\n      i++;\n      while(i<=N){ bit[i]+=x; i+=i&-i; }\n      return;\n    }\n    T sum(int i){\n      i++;\n      T res = T(0);\n      while(i>0){ res+=bit[i]; i-=i&-i; }\n      return res;\n    }\n    T sum(int l,int r){// [l,r]\n      assert(l<=r);\n      if(l==0)return sum(r);\n      else return sum(r)-sum(l-1);\n    }\n  };\n  template<class T>\n  struct SlideMin{\n    vector<T> v;\n    deque<int> deq;\n    SlideMin(vector<T> &v):v(v){}\n    void add(int id){ // add v[id]\n      while(!deq.empty()&&v[deq.back()]>=v[id])deq.pop_back();\n      deq.push_back(id);\n    }\n    T get(int id){ // [id,added]\n      while(!deq.empty()&&deq.front()<id)deq.pop_front();\n      assert(!deq.empty());\n      return v[deq.front()];\n    }\n  };\n  template<class T>\n  struct SlideMax{\n    vector<T> v;\n    deque<int> deq;\n    SlideMax(vector<T> &v):v(v){}\n    void add(int id){\n      while(!deq.empty()&&v[deq.back()]<=v[id])deq.pop_back();\n      deq.push_back(id);\n    }\n    T get(int id){ // [id,added]\n      while(!deq.empty()&&deq.front()<id)deq.pop_front();\n      assert(!deq.empty());\n      return v[deq.front()];\n    }\n  };\n  template<class D,class O>\n  struct LazySegmentTree{\n    using DMerger = function<D(D,D)>;\n    using OMerger = function<O(O,O)>;\n    using Applier = function<D(D,O,int)>;\n\n    int length;\n\n    D d_unit;\n    O o_unit;\n\n    vector<D> seg;\n    vector<O> lazy;\n\n    DMerger dm;\n    OMerger om;\n    Applier app;\n\n    void lazy_evaluate(int k,int len){\n      if(lazy[k] == o_unit) return;\n      if(len>1){\n        lazy[2*k+1] = om(lazy[2*k+1],lazy[k]);\n        lazy[2*k+2] = om(lazy[2*k+2],lazy[k]);\n      }\n      seg[k] = app(seg[k],lazy[k],len);\n      lazy[k] = o_unit;\n    }\n    void update(int a,int b,int k,int l,int r,O x){\n      lazy_evaluate(k,r-l);\n      if(r<=a||b<=l)return;\n      else if(a<=l&&r<=b){\n        lazy[k] = om(lazy[k],x);\n        lazy_evaluate(k,r-l);\n      }else{\n        update(a,b,k*2+1,l,(l+r)/2,x);\n        update(a,b,k*2+2,(l+r)/2,r,x);\n        seg[k] = dm(seg[k*2+1],seg[k*2+2]);\n      }\n    }\n    void update(int a,int b,O x){\n      update(a,b,0,0,length,x);\n    }\n    D query(int a,int b,int k,int l,int r){\n      lazy_evaluate(k,r-l);\n      if(r<=a||b<=l)return d_unit; \n      else if(a<=l&&r<=b)return seg[k];\n      else{\n        D lch = query(a,b,k*2+1,l,(l+r)/2);\n        D rch = query(a,b,k*2+2,(l+r)/2,r);\n        return dm(lch,rch);\n      }\n    }\n    D query(int a,int b){\n      return query(a,b,0,0,length);\n    }\n    LazySegmentTree(int n,D d_unit,O o_unit,DMerger dm,OMerger om,Applier app)\n      :length(1),d_unit(d_unit),o_unit(o_unit),dm(dm),om(om),app(app) {\n      while(length<n){ length <<= 1; }\n      seg.assign(length * 2, d_unit);\n      lazy.assign(length * 2, o_unit);\n    }\n    LazySegmentTree(vector<D> vec,D d_unit,O o_unit,DMerger dm,OMerger om,Applier app)\n      :length(1),d_unit(d_unit),o_unit(o_unit),dm(dm),om(om),app(app) {\n      while(length<vec.size()){ length <<= 1; }\n      seg.assign(length * 2, d_unit);\n      lazy.assign(length * 2, o_unit);\n      for(int i=0;i<vec.size();i++)seg[length-1+i] = vec[i];\n      for(int i=length-2;i>=0;i--)seg[i] = dm(seg[i*2+1],seg[i*2+2]);\n    }\n  };\n  // RangeAddRangeSum update : a[l,r) += c\n  // verified https://atcoder.jp/contests/abc153/submissions/9866001\n  template<class T>\n  LazySegmentTree<T,T> RangeAddRangeSum(int size){\n    auto dm = [](T a,T b){return a+b;};\n    auto om = [](T a,T b){return a+b;};\n    auto app = [](T dat,T lz,int len){return dat+lz*T(len);};\n    return LazySegmentTree<T,T>(size,T(0),T(0),dm,om,app);\n  }\n  template<class T>\n  LazySegmentTree<T,T> RangeAddRangeSum(vector<T> vec){\n    auto dm = [](T a,T b){return a+b;};\n    auto om = [](T a,T b){return a+b;};\n    auto app = [](T dat,T lz,int len){return dat+lz*T(len);};\n    return LazySegmentTree<T,T>(vec,T(0),T(0),dm,om,app);\n  }\n  // RangeAddRangeMin\n  // NOT verified yet\n  LazySegmentTree<ll,ll> RangeAddRangeMin(int size){\n    auto dm = [](ll a,ll b){return min(a,b);};\n    auto om = [](ll a,ll b){return a+b;};\n    auto app = [](ll dat,ll lz,int len){return dat+lz;};\n    return LazySegmentTree<ll,ll>(size,LLINF,0ll,dm,om,app);\n  }\n  LazySegmentTree<ll,ll> RangeAddRangeMin(vector<ll> vec){\n    auto dm = [](ll a,ll b){return min(a,b);};\n    auto om = [](ll a,ll b){return a+b;};\n    auto app = [](ll dat,ll lz,int len){return dat+lz;};\n    return LazySegmentTree<ll,ll>(vec,LLINF,0ll,dm,om,app);\n  }\n  // RangeAffineRangeSum update (l,r,(p,q)) : a[i] = p * a[i] + q { i in [l,r) }\n  // verified https://judge.yosupo.jp/submission/3354\n  template<class T>\n  LazySegmentTree<ll,pair<T,T>> RangeAffineRangeSum(int size){\n    using f = pair<T,T>;\n    auto dm = [](T a,T b){return a+b;};\n    auto om = [](f a,f b){return f(b.fi*a.fi,b.fi*a.sec+b.sec);};\n    auto app = [](T dat,f lz,int len){return lz.fi*dat+lz.sec*T(len);};\n    return LazySegmentTree<T,f>(size,T(0),f(T(1),T(0)),dm,om,app);\n  }\n  template<class T>\n  LazySegmentTree<T,pair<T,T>> RangeAffineRangeSum(vector<T> vec){\n    using f = pair<T,T>;\n    auto dm = [](T a,T b){return a+b;};\n    auto om = [](f a,f b){return f(b.fi*a.fi,b.fi*a.sec+b.sec);};\n    auto app = [](T dat,f lz,int len){return lz.fi*dat+lz.sec*T(len);};\n    return LazySegmentTree<T,f>(vec,T(0),f(T(1),T(0)),dm,om,app);\n  }\n}\n\nnamespace Util{\n  template<class T>\n  vector<pair<T,int>> runLength(vector<T> v){\n    vector<pair<T,int>> res;\n    for(int i=0;i<v.size();i++){\n      if(res.empty()||res.back().first!=v[i])res.push_back(make_pair(v[i],1));\n      else res.back().second++;\n    }\n    return res;\n  }\n  template<class T>\n  void compress(vector<T> &v){\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n  }\n}\n\ntemplate<class D>\nstruct SegmentTree{\n  using DMerger = function<D(D,D)>;\n  int length;\n  D d_unit;\n  vector<D> seg;\n  DMerger dm;\n  void update(int k,D x){\n    k += length-1;\n    seg[k] = x;\n    while(k){\n      k = (k-1)/2;\n      seg[k] = dm(seg[2*k+1],seg[2*k+2]);\n    }\n  }\n  D query(int a,int b,int k,int l,int r){\n    if(r<=a||b<=l)return d_unit; \n    else if(a<=l&&r<=b)return seg[k];\n    else{\n      D lch = query(a,b,k*2+1,l,(l+r)/2);\n      D rch = query(a,b,k*2+2,(l+r)/2,r);\n      return dm(lch,rch);\n    }\n  }\n  D query(int a,int b){\n    return query(a,b,0,0,length);\n  }\n  D operator [] (int id) const {\n    assert(0<=id&&id<length);\n    return seg[length-1+id];\n  }\n  SegmentTree(int n,D d_unit,DMerger dm)\n    :length(1),d_unit(d_unit),dm(dm) {\n    while(length<n){ length <<= 1; }\n    seg.assign(length * 2, d_unit);\n  }\n  SegmentTree(vector<D> vec,D d_unit,DMerger dm)\n    :length(1),d_unit(d_unit),dm(dm) {\n    while(length<vec.size()){ length <<= 1; }\n    seg.assign(length * 2, d_unit);\n    for(int i=0;i<vec.size();i++)seg[length-1+i] = vec[i];\n    for(int i=length-2;i>=0;i--)seg[i] = dm(seg[i*2+1],seg[i*2+2]);\n  }\n};\n\ntemplate<class D>\nstruct SegmentTreeBeats{\n  using DMerger = function<D(D,D)>;\n  vector<D> seg;\n  int length;\n  DMerger dm;\n  D d_unit;\n  SegmentTreeBeats(const vector<D>& vec,DMerger dm,D d_unit = D()):length(1),dm(dm){\n    while(length<vec.size())length <<= 1;\n    seg.assign(length*2,d_unit);\n    for(int i=0;i<vec.size();i++){\n      seg[i+length-1] = vec[i];\n    }\n    for(int i=length-2;i>=0;i--){\n      seg[i] = dm(seg[i*2+1],seg[i*2+2]);\n    }\n  }\n  template<class F,class... Args>\n  void update(int a,int b,int k,int l,int r,F break_or_puttag,Args... args){\n    if(r<=a||b<=l)return;\n    if(a<=l&&r<=b&&(seg[k].*break_or_puttag)(args...))return;\n    seg[k].pushdown(seg[k*2+1],seg[k*2+2]);\n    update(a,b,k*2+1,l,(l+r)/2,break_or_puttag,args...);\n    update(a,b,k*2+2,(l+r)/2,r,break_or_puttag,args...);\n    seg[k] = dm(seg[k*2+1],seg[k*2+2]);\n  }\n  template<class F,class... Args>\n  void update(int a,int b,F break_or_puttag,Args... args){\n    update(a,b,0,0,length,break_or_puttag,args...);\n  }\n  template<class Getter,class QMerger,class Q>\n  Q query(int a,int b,int k,int l,int r,Getter getter,QMerger qm,Q q_unit){\n    if(r<=a||b<=l)return q_unit;\n    if(a<=l&&r<=b)return (seg[k].*getter)();\n    seg[k].pushdown(seg[k*2+1],seg[k*2+2]);\n    Q lch = query(a,b,k*2+1,l,(l+r)/2,getter,qm,q_unit);\n    Q rch = query(a,b,k*2+2,(l+r)/2,r,getter,qm,q_unit);\n    return qm(lch,rch);\n  }\n  template<class Getter,class QMerger,class Q>\n  Q query(int a,int b,Getter getter,QMerger qm,Q q_unit){\n    return query(a,b,0,0,length,getter,qm,q_unit);\n  }\n};\n\n// requirements :\n// static Data merge(Data l,Data r)\n// void pushdown(Data& l,Data& r) (push down tag)\n// \n// for each update query :\n// bool break_or_puttag_[QUERY] (TAGTYPE tag)\n//   if puttag condition is satisfied, update data and put tag\n//   return : if break condition or puttag condition is satisfied, return true, otherwise return false\n\nstruct Data{\n  ll tag,num,sum,mx,mi,second_mx,second_mi,mx_num,mi_num;\n  Data(ll v = 0ll):tag(0ll),num(1ll),sum(v),mx(v),mi(v),second_mx(-LLINF),second_mi(LLINF),mx_num(1),mi_num(1){}\n  static Data merge(Data l,Data r){\n    Data ret;\n    ret.tag = 0;\n    ret.sum = l.sum+r.sum;\n    ret.num = l.num+r.num;\n    ret.mx = max(l.mx,r.mx);\n    ret.mi = min(l.mi,r.mi);\n\n    ret.second_mx = -LLINF;\n    if(l.mx==ret.mx){\n      if(r.mx < ret.mx)chmax(ret.second_mx,r.mx);\n      chmax(ret.second_mx,l.second_mx);\n      chmax(ret.second_mx,r.second_mx);\n    }\n    if(r.mx==ret.mx){\n      if(l.mx < ret.mx)chmax(ret.second_mx,l.mx);\n      chmax(ret.second_mx,l.second_mx);\n      chmax(ret.second_mx,r.second_mx);\n    }\n\n    ret.second_mi = LLINF;\n    if(l.mi==ret.mi){\n      if(r.mi > ret.mi)chmin(ret.second_mi,r.mi);\n      chmin(ret.second_mi,l.second_mi);\n      chmin(ret.second_mi,r.second_mi);\n    }\n    if(r.mi==ret.mi){\n      if(l.mi > ret.mi)chmin(ret.second_mi,l.mi);\n      chmin(ret.second_mi,l.second_mi);\n      chmin(ret.second_mi,r.second_mi);\n    }\n\n    ret.mx_num = 0;\n    if(ret.mx==l.mx) ret.mx_num += l.mx_num;\n    if(ret.mx==r.mx) ret.mx_num += r.mx_num;\n\n    ret.mi_num = 0;\n    if(ret.mi==l.mi) ret.mi_num += l.mi_num;\n    if(ret.mi==r.mi) ret.mi_num += r.mi_num;\n\n    return ret;\n  }\n  bool add(ll x){\n    sum += num*x;\n    mx += x;\n    if(second_mx!=-LLINF)second_mx += x;\n    mi += x;\n    if(second_mi!=LLINF)second_mi += x;\n    tag += x;\n    return true;\n  }\n  void pushdown(Data& l,Data& r){\n    l.add(tag);\n    r.add(tag);\n    tag = 0ll;\n    if(l.mx > mx)l.chmin_query(mx);\n    if(r.mx > mx)r.chmin_query(mx);\n    if(l.mi < mi)l.chmax_query(mi);\n    if(r.mi < mi)r.chmax_query(mi);\n  }\n  bool chmax_query(ll x){\n    if(mi>=x)return true;\n    if(second_mi>x){\n      if(second_mi==LLINF){ // 1 value only\n        sum += (x-mi)*mi_num;\n        mi = x;\n        mx = x;\n      }\n      else if(second_mi==mx){ // 2 value only\n        sum += (x-mi)*mi_num;\n        mi = x;\n        second_mx = x;\n      }else{\n        sum += (x-mi)*mi_num;\n        mi = x;\n      }\n      return true;\n    }\n    return false;\n  }\n  bool chmin_query(ll x){\n    if(mx<=x)return true;\n    if(second_mx<x){\n      if(second_mx==-LLINF){ // 1 value only\n        sum -= (mx-x)*mx_num;\n        mx = x;\n        mi = x;\n      }\n      else if(second_mi==mx){ // 2 value only\n        sum -= (mx-x)*mx_num;\n        mx = x;\n        second_mi = x;\n      }else{\n        sum -= (mx-x)*mx_num;\n        mx = x;\n      }\n      return true;\n    }\n    return false;\n  }\n  ll get_sum(){\n    return sum;\n  }\n};\n\nvoid yosupo_RangeChminChmaxAddRangeSum(){\n  int n,q;\n  cin >> n >> q;\n  vector<Data> vec;\n  for(int i=0;i<n;i++){\n    ll a;\n    cin >> a;\n    vec.emplace_back(a);\n  }\n  SegmentTreeBeats<Data> seg(vec,Data::merge);\n  for(int i=0;i<q;i++){\n    int type,l,r,b; cin >> type;\n    if(type==0){\n      cin >> l >> r >> b;\n      seg.update(l,r,&Data::chmin_query,b);\n    }\n    if(type==1){\n      cin >> l >> r >> b;\n      seg.update(l,r,&Data::chmax_query,b);\n    }\n    if(type==2){\n      cin >> l >> r >> b;\n      seg.update(l,r,&Data::add,b);\n    }\n    if(type==3){\n      cin >> l >> r;\n      cout << seg.query(l,r,&Data::get_sum,[](ll x,ll y){return x+y;},0ll) << endl;\n    }\n    for(int j=0;j<seg.seg.size();j++){\n      cout << \"id : \" << j << endl;\n      cout << \" mx : \" << seg.seg[j].mx;\n      cout << \" second_mx : \" << seg.seg[j].second_mx;\n      cout << \" mx_num : \" << seg.seg[j].mx_num;\n      cout << \" mi : \" << seg.seg[j].mi;\n      cout << \" second_mi : \" << seg.seg[j].second_mi;\n      cout << \" mi_num : \" << seg.seg[j].mi_num;\n      cout << \" sum : \" << seg.seg[j].sum;\n      cout << \" num : \" << seg.seg[j].num;\n      cout << \" tag : \" << seg.seg[j].tag;\n      cout << endl;\n    }\n  }\n}\n\nvoid AOJ_DSL_2_G(){\n  int n,q;\n  cin >> n >> q;\n  vector<Data> vec(n);\n  SegmentTreeBeats<Data> seg(vec,Data::merge);\n  for(int i=0;i<q;i++){\n    int type,l,r,x;\n    cin >> type;\n    if(type==0){\n      cin >> l >> r >> x;\n      l--;\n      seg.update(l,r,&Data::add,x);\n    }\n    if(type==1){\n      cin >> l >> r;\n      l--;\n      cout << seg.query(l,r,&Data::get_sum,[](ll x,ll y){return x+y;},0ll) << endl;\n    }\n  }\n}\n\nvoid AOJ_DSL_2_I(){\n  int n,q;\n  cin >> n >> q;\n  vector<Data> vec(n);\n  SegmentTreeBeats<Data> seg(vec,Data::merge);\n  for(int i=0;i<q;i++){\n    int type,l,r,x;\n    cin >> type;\n    if(type==0){\n      cin >> l >> r >> x;\n      seg.update(l,r+1,&Data::chmax_query,2000);\n      seg.update(l,r+1,&Data::chmin_query,x);\n    }\n    if(type==1){\n      cin >> l >> r;\n      cout << seg.query(l,r+1,&Data::get_sum,[](ll x,ll y){return x+y;},0ll) << endl;\n    }\n    /*\n    for(int j=0;j<seg.seg.size();j++){\n      cout << \"id : \" << j << endl;\n      cout << \" mx : \" << seg.seg[j].mx;\n      cout << \" second_mx : \" << seg.seg[j].second_mx;\n      cout << \" mx_num : \" << seg.seg[j].mx_num;\n      cout << \" mi : \" << seg.seg[j].mi;\n      cout << \" second_mi : \" << seg.seg[j].second_mi;\n      cout << \" mi_num : \" << seg.seg[j].mi_num;\n      cout << \" sum : \" << seg.seg[j].sum;\n      cout << \" num : \" << seg.seg[j].num;\n      cout << \" tag : \" << seg.seg[j].tag;\n      cout << endl;\n    }\n    */\n  }\n}\n\nsigned main(){\n  fastio();\n  // yosupo_RangeChminChmaxAddRangeSum();\n  // AOJ_DSL_2_G();\n  AOJ_DSL_2_I();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//BEGIN CUT HERE\ntemplate <typename T,typename E>\nstruct SegmentTree{\n  using F = function<T(T,T)>;\n  using G = function<T(T,E)>;\n  using H = function<E(E,E)>;\n  using P = function<E(E,size_t)>;\n  int n;\n  F f;\n  G g;\n  H h;\n  T ti;\n  E ei;\n  P p;\n  vector<T> dat;\n  vector<E> laz;\n  SegmentTree(int n_,F f,G g,H h,T ti,E ei,\n\t      P p=[](E a,size_t b){return a;}):\n    f(f),g(g),h(h),ti(ti),ei(ei),p(p){\n    init(n_);\n  }\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.assign(2*n-1,ti);\n    laz.assign(2*n-1,ei);\n  }\n  void build(int n_, vector<T> v){\n    for(int i=0;i<n_;i++) dat[i+n-1]=v[i];\n    for(int i=n-2;i>=0;i--)\n      dat[i]=f(dat[i*2+1],dat[i*2+2]);\n  }\n  inline void eval(int len,int k){\n    if(laz[k]==ei) return;\n    if(k*2+1<n*2-1){\n      laz[k*2+1]=h(laz[k*2+1],laz[k]);\n      laz[k*2+2]=h(laz[k*2+2],laz[k]);\n    }\n    dat[k]=g(dat[k],p(laz[k],len));\n    laz[k]=ei;\n  }\n  T update(int a,int b,E x,int k,int l,int r){\n    eval(r-l,k);\n    if(r<=a||b<=l) return dat[k];\n    if(a<=l&&r<=b){\n      laz[k]=h(laz[k],x);\n      return g(dat[k],p(laz[k],r-l));\n    }\n    return dat[k]=f(update(a,b,x,k*2+1,l,(l+r)/2),\n\t\t    update(a,b,x,k*2+2,(l+r)/2,r));\n  }\n  T update(int a,int b,E x){\n    return update(a,b,x,0,0,n);\n  }\n  T query(int a,int b,int k,int l,int r){\n    eval(r-l,k);\n    if(r<=a||b<=l) return ti;\n    if(a<=l&&r<=b) return dat[k];\n    T vl=query(a,b,k*2+1,l,(l+r)/2);\n    T vr=query(a,b,k*2+2,(l+r)/2,r);\n    return f(vl,vr);\n  }\n  T query(int a,int b){\n    return query(a,b,0,0,n);\n  }\n  void update(int k,T x){\n    query(k,k+1);//evaluate\n    k+=n-1;\n    dat[k]=x;\n    while(k){\n      k=(k-1)/2;\n      dat[k]=f(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n};\n//END CUT HERE\nsigned main(){\n  int n,q;\n  cin>>n>>q;\n  SegmentTree<int,int> ch(n,\n\t\t\t  [](int a,int b){return a+b;},\n\t\t\t  [](int a,int b){return b;},\n\t\t\t  [](int a,int b){return a+b;},\n\t\t\t  0,0,\n\t\t\t  [](int a,int b){return a*b;});\n  ch.build(n,vector<int>(n,0));\n  for(int i=0;i<q;i++){\n    int c,s,t,x;\n    cin>>c;\n    if(c){\n      cin>>s>>t;\n      cout<<ch.query(s-1,t)<<endl;\n    }else{\n      cin>>s>>t>>x;\n      ch.update(s-1,t,x);\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> // ver2.4.1\n#include <complex.h>\n#include <limits>\n//#include <boost/math/tools/minima.hpp>\n//#include <boost/multiprecision/cpp_int.hpp>\n#define fmin brent_find_minima\n#define int long long\n#define endl \"\\n\"\n#define ALL(v) (v).begin(),(v).end()\n#define COUNT(a,k) upper_bound(ALL(a),k)-lower_bound(ALL(a),k)\n#define BIGGER(a,k) a.end()-upper_bound(ALL(a),k)\n#define SMALLER(a,k) lower_bound(ALL(a),k)-a.begin()\n#define Vi vector<int>\n#define VVi vector<Vi>\n#define Vm vector<mint>\n#define Vs vector<string>\n#define Pii pair<int,int>\n#define Pdd pair<double,double>\n#define VPii vector<Pii>\n#define Tiii tuple<int,int,int>\n#define VTiii vector<Tiii>\n#define PQi priority_queue<int>\n#define PQir priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define itos to_string\n#define stoi stoll\n#define FI first\n#define SE second\n#define cYES cout<<\"YES\"<<endl\n#define cNO cout<<\"NO\"<<endl\n#define cYes cout<<\"Yes\"<<endl\n#define cNo cout<<\"No\"<<endl\n#define cyes cout<<\"yes\"<<endl\n#define cno cout<<\"no\"<<endl\n#define sortr(v) sort(v,greater<>())\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define repeq(i,a,b) for(int i=a;i<=b;i++)\n#define repreq(i,a,b) for(int i=a;i>=b;i--)\n#define leng(n) (int)(log10(n)+1)\n#define dem(a,b) ((a+b-1)/(b))\n#define Vin(a) rep(iI,0,a.size())cin>>a[iI]\n#define INF 3000000000000000000  //  3.0*10^18(MAXの1/3くらい)\n#define MAX LLONG_MAX\n#define PI 3.141592653589793238462\n#define MOD 1000000007  //  10^9 + 7\n\nusing namespace std;\n/* fmin(f,L,R,100) で関数の最小値を(x,min)で返す　*/\n//using boost::math::tools::brent_find_minima;\n/* cpp_int (任意の長さのint) */\n//using boost::multiprecision::cpp_int;\n\n/* デバッグ用 */\nvoid Vout(auto a){if(a.size()==0) cout<<\".\"<<endl;\nelse{rep(i,0,a.size()-1)cout<<a[i]<<' ';if(a.size()>0)cout<<a.back()<<endl;}return;}\nvoid Verr(auto a){if(a.size()==0) cerr<<\".\"<<endl;\nelse{rep(i,0,a.size()-1)cerr<<a[i]<<' ';if(a.size()>0)cerr<<a.back()<<endl;}return;}\nvoid VVout(auto a){if(a.size()==0)cout<<\".\"<<endl;\nelse{rep(i,0,a.size())Vout(a[i]);}return;}\nvoid VVerr(auto a){if(a.size()==0)cerr<<\".\"<<endl;\nelse{rep(i,0,a.size())Verr(a[i]);}return;}\nvoid VPout(auto a){if(a.size()==0)cout<<\".\"<<endl;\nelse{rep(i,0,a.size())cout<<a[i].FI<<' '<<a[i].SE<<endl;}return;}\nvoid VPerr(auto a){if(a.size()==0)cerr<<\".\"<<endl;\nelse{rep(i,0,a.size())cerr<<a[i].FI<<' '<<a[i].SE<<endl;}return;}\n\n/* 便利関数 */\nint gcd(int a,int b){return b?gcd(b,a%b):a;} // 最大公約数gcd\nint lcm(int a,int b){return a/gcd(a,b)*b;} // 最小公倍数lcm\nint mypow(int x, int n, int m){ // 累乗x^n(mod m) O(log(n))\nif(n==0)return 1;if(n%2==0)return mypow(x*x%m,n/2,m);else return x*mypow(x,n-1,m)%m;}\nint scomb(int n, int r){if((n-r)<r)r=n-r; // nCr(小さい場合)\nint a=1;for(int i=n;i>n-r;--i){a=a*i;}for(int i=1;i<r+1;++i){a=a/i;}return a;}\nint comb(int n, int r){if((n-r)<r)r=n-r; // nCr(%MOD)\nint a=1;for(int i=n;i>n-r;--i){a=a*i%MOD;}for(int i=1;\ni<r+1;++i){a=a*mypow(i,MOD-2,MOD)%MOD;}return a%MOD;}\nVi stpowV(){Vi a(100005);\na[0]=1;repeq(i,1,100004)a[i]=a[i-1]*i%MOD;return a;}\n//Vi stpow = stpowV();  // 階乗配列(%MOD)\nVi Vsum(Vi &v){Vi S(v.size()+1);rep(i,1,S.size())S[i]+=v[i-1]+S[i-1];return S;}// 累積和\nint digit(int k,int i){string s = itos(k);return s[s.size()-i]-'0';} // i桁目の数字\nvoid press(auto &v){v.erase(unique(ALL(v)),v.end());} // 圧縮\nVi zip(Vi b){int Z=b.size(); // 座標圧縮\nPii p[Z+10];int a=b.size();Vi l(a);for(int i=0;i<a;i++)\np[i]=mp(b[i],i);sort(p,p+a);int w=0;for(int i=0;i<a;i++)\n{if(i&&p[i].first!=p[i-1].first)w++;l[p[i].second]=w;}return l;}\nVi beki2V(){Vi a(61);int q = 1;rep(i,0,61){a[i]=q;q*=2;}return a;}\nVi beki2 = beki2V(); // 2^n配列\nint modiv(int a,int b){return a*mypow(b,MOD-2,MOD)%MOD;} // a÷b(MOD環境)\n\n\n\nstruct RSUQ {\n  \n  /*　使い方まとめ(0-index)　*/\n  \n  /*\n  \n  RSUQ myvec(n) // 宣言 nは必要な要素数\n  myvec.at(i) // 配列のi番目にアクセス\n  myvec.rupdate(L,R,k) // 配列のL番目からR番目までをkにする\n  myvec.update(i,k) // 配列のi番目をkにする\n  myvec.rsum(i,j) // 配列の[i,j]の範囲の和を返す\n  \n  myvec.debug() // 元データ配列とバケット配列を標準エラー出力\n  \n  */\n  \n  vector<int> data;\n  vector<int> bucket1;\n  vector<int> bucket2;\n  int sq;\n  \n  RSUQ(int n) {\n    sq = sqrt(n);\n    if(sq*sq==n) sq--;\n    sq++;\n    data = Vi(sq*sq,0);\n    bucket1 = Vi(sq,-INF); // 1はRUQ成分(-INF)\n    bucket2 = Vi(sq,0); // 2はRSQ成分(0)\n  }\n  \n  void rupdate(int L,int R,int k) { // [L,R]は範囲\n     R++;\n     int dL,dR;\n     \n     rep(i,0,sq+1) {\n       dL = i*sq,dR = (i+1)*sq; // [dL,dR]は小範囲(バケット)\n       \n       if(dR <= L || R <= dL) continue; // 小範囲が完全に範囲外\n       \n       if(L <= dL && dR <= R) { // 小範囲が完全に範囲内\n         bucket1[i] = k;\n       }\n       \n       else { // 小範囲が範囲と一部重なる\n         \n         int minn = k;\n         \n         if(bucket1[i]!=-INF){\n           rep(j,dL,dR) {\n             data[j] = bucket1[i];\n           }\n           bucket1[i] = -INF;\n         }\n         \n         rep(j,max(L,dL),min(R,dR)) {\n           data[j] = k;\n         }\n         \n         int sum = 0;\n         rep(j,dL,dR) {\n           sum += data[j];\n         }\n         bucket2[i] = sum;\n         \n       }\n     }\n   }\n  \n  void update(int i,int k) {\n    rupdate(i,i,k);\n  }\n  \n  int rsum(int L,int R) {\n     R++;\n     int sum = 0;\n     int dL,dR;\n     \n     rep(i,0,sq+1) {\n       dL = i*sq,dR = (i+1)*sq; // [dL,dR]は小範囲\n       \n       if(dR <= L || R <= dL) continue; // 小範囲が完全に範囲外\n       \n       if(L <= dL && dR <= R) { // 小範囲が完全に範囲内\n         if(bucket1[i]!=-INF) sum += bucket1[i]*sq;\n         else sum += bucket2[i];\n       }\n       \n       else { // 小範囲が範囲と一部重なる\n         rep(j,max(L,dL),min(R,dR)) {\n           if(bucket1[i] == -INF) sum += data[j];\n           else sum += bucket1[i];\n         }\n       }\n     }\n     return sum;\n   }\n  \n  int at(int i) {\n    int ib = i/sq;\n    if(bucket1[ib]==-INF) return data[i];\n    else return bucket1[ib];\n  }\n  \n  void debug() {\n    Verr(data);\n    Verr(bucket1);\n    Verr(bucket2);\n    cerr << endl;\n  }\n  \n};\n\nsigned main() {\n  cin.tie(0);cout.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(12);\n  int n,m;\n  cin >> n >> m;\n  \n  RSUQ vec(n);\n  \n  int qw,er,ty,as;\n  \n  rep(i,0,m){\n    cin >> qw;\n    if(qw==0){\n      cin >> er >> ty >> as;\n      vec.rupdate(er,ty,as);\n    }\n    else {\n      cin >> er >> ty;\n      cout << vec.rsum(er,ty) << endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//BEGIN CUT HERE\ntemplate <typename T,typename E>\nstruct SegmentTree{\n  using F = function<T(T,T)>;\n  using G = function<T(T,E)>;\n  using H = function<E(E,E)>;\n  using P = function<E(E,size_t)>;\n  int n;\n  F f;\n  G g;\n  H h;\n  T ti;\n  E ei;\n  P p;\n  vector<T> dat;\n  vector<E> laz;\n  SegmentTree(int n_,F f,G g,H h,T ti,E ei,\n\t      P p=[](E a,size_t b){return a;}):\n    f(f),g(g),h(h),ti(ti),ei(ei),p(p){\n    init(n_);\n  }\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.assign(2*n-1,ti);\n    laz.assign(2*n-1,ei);\n  }\n  void build(int n_, vector<T> v){\n    for(int i=0;i<n_;i++) dat[i+n-1]=v[i];\n    for(int i=n-2;i>=0;i--)\n      dat[i]=f(dat[i*2+1],dat[i*2+2]);\n  }\n  inline void eval(int len,int k){\n    if(laz[k]==ei) return;\n    if(k*2+1<n*2-1){\n      laz[k*2+1]=h(laz[k*2+1],laz[k]);\n      laz[k*2+2]=h(laz[k*2+2],laz[k]);\n    }\n    dat[k]=g(dat[k],p(laz[k],len));\n    laz[k]=ei;\n  }\n  T update(int a,int b,E x,int k,int l,int r){\n    eval(r-l,k);\n    if(r<=a||b<=l) return dat[k];\n    if(a<=l&&r<=b){\n      laz[k]=h(laz[k],x);\n      return g(dat[k],p(laz[k],r-l));\n    }\n    return dat[k]=f(update(a,b,x,k*2+1,l,(l+r)/2),\n\t\t    update(a,b,x,k*2+2,(l+r)/2,r));\n  }\n  T update(int a,int b,E x){\n    return update(a,b,x,0,0,n);\n  }\n  T query(int a,int b,int k,int l,int r){\n    eval(r-l,k);\n    if(r<=a||b<=l) return ti;\n    if(a<=l&&r<=b) return dat[k];\n    T vl=query(a,b,k*2+1,l,(l+r)/2);\n    T vr=query(a,b,k*2+2,(l+r)/2,r);\n    return f(vl,vr);\n  }\n  T query(int a,int b){\n    return query(a,b,0,0,n);\n  }\n  void update(int k,T x){\n    query(k,k+1);//evaluate\n    k+=n-1;\n    dat[k]=x;\n    while(k){\n      k=(k-1)/2;\n      dat[k]=f(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n};\n//END CUT HERE\nsigned main(){\n  int n,q;\n  cin>>n>>q;\n  SegmentTree<int,int> ch(n,\n\t\t\t  [](int a,int b){return a+b;},\n\t\t\t  [](int a,int b){return b;},\n\t\t\t  [](int a,int b){return b;},\n\t\t\t  0,0,\n\t\t\t  [](int a,int b){return a*b;});\n  ch.build(n,vector<int>(n,0));\n  for(int i=0;i<q;i++){\n    int c,s,t,x;\n    cin>>c;\n    if(c){\n      cin>>s>>t;\n      cout<<ch.query(s,t)<<endl;\n    }else{\n      cin>>s>>t>>x;\n      ch.update(s,t,x);\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef LOCAL\n#define _GLIBCXX_DEBUG\n#endif\n#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rrep(i,n) for(int i=n-1;i>=0;--i)\n#define reps(i,a,b) for(int i=a;i<b;++i)\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\n#define sz(x) (int)(x).size()\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(),v.rend()\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\ntemplate<typename T> inline bool chmax(T &a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<typename T> inline bool chmin(T &a,T b){if(b<a){a=b;return 1;}return 0;}\ntemplate<typename T> vector<T> make_vec(size_t a){return vector<T>(a);}\ntemplate<typename T,typename... Ts>\nauto make_vec(size_t a,Ts... ts){return vector<decltype(make_vec<T>(ts...))>(a,make_vec<T>(ts...));}\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T,U>::value>::type fill_v(U &u,const V... v){u=U(v...);}\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<!is_same<T,U>::value>::type fill_v(U &u,const V... v){for(auto &e:u)fill_v<T>(e,v...);}\n\ntemplate <typename T, typename E>\nstruct lazy_segment_tree {\n    using F = function<T(T, T)>;\n    using G = function<T(T, E)>;\n    using H = function<E(E, E)>;\n    int n, height;\n    vector<T> data;\n    vector<E> lazy;\n    F f;\n    G g;\n    H h;\n    T ti;\n    E ei;\n    lazy_segment_tree(F f, G g, H h, T ti, E ei) : f(f), g(g), h(h), ti(ti), ei(ei) {}\n    void init(int n_) {\n        n = 1; height = 0;\n        while (n < n_) n <<= 1, height++;\n        data.assign(2*n, ti);\n        lazy.assign(2*n, ei);\n    }\n    void build(const vector<T> &v) {\n        int n_ = (int)v.size();\n        init(n_);\n        for (int i = 0; i < n_; ++i) data[n+i] = v[i];\n        for (int i = n-1; i >= 1; --i) {\n            data[i] = f(data[i<<1|0], data[i<<1|1]);\n        }\n    }\n    inline T reflect(int i) {\n        return lazy[i] == ei ? data[i] : g(data[i], lazy[i]);\n    }\n    inline void propagate(int i) {\n        if (lazy[i] == ei) return;\n        lazy[i<<1|0] = h(lazy[i<<1|0], lazy[i]);\n        lazy[i<<1|1] = h(lazy[i<<1|1], lazy[i]);\n        data[i] = reflect(i);\n        lazy[i] = ei;\n    }\n    inline void thrust(int i) {\n        for (int k = height; k >= 1; --k) propagate(i>>k);\n    }\n    inline void recalc(int i) {\n        while (i > 1) {\n            i >>= 1;\n            data[i] = f(reflect(i<<1|0), reflect(i<<1|1));\n        }\n    }\n    void update(int a, int b, E x) {\n        a += n; b += n;\n        thrust(a);\n        thrust(b-1);\n        int l = a, r = b;\n        while (l < r) {\n            if (l & 1) lazy[l] = h(lazy[l], x), l++;\n            if (r & 1) --r, lazy[r] = h(lazy[r], x);\n            l >>= 1; r >>= 1;\n        }\n        recalc(a);\n        recalc(b-1);\n    }\n    void set(int i, T x) {\n        i += n;\n        thrust(i);\n        data[i] = x;\n        lazy[i] = ei;\n        recalc(i);\n    }\n    T fold(int a, int b) {\n        a += n; b += n;\n        thrust(a);\n        thrust(b-1);\n        T resl = ti, resr = ti;\n        int l = a, r = b;\n        while (l < r) {\n            if (l & 1) resl = f(resl, reflect(l++));\n            if (r & 1) resr = f(reflect(--r), resr);\n            l >>= 1; r >>= 1;\n        }\n        return f(resl, resr);\n    }\n    // min idx s.t. st <= idx && !check(fold(st, idx-1)) && check(fold(st, idx))\n    template <typename C>\n    int find(int st, C &check, T &acc, int i, int l, int r) {\n        if (l+1 == r) {\n            acc = f(acc, reflect(i));\n            return check(acc) ? i-n : -1;\n        }\n        propagate(i);\n        int m = (l+r) >> 1;\n        if (m <= st) return find(st, check, acc, i<<1|1, m, r);\n        if (st <= l && !check(f(acc, data[i]))) {\n            acc = f(acc, data[i]);\n            return -1;\n        }\n        int vl = find(st, check, acc, i<<1|0, l, m);\n        if (vl != -1) return vl;\n        return find(st, check, acc, i<<1|1, m, r);\n    }\n    template <typename C>\n    int find(int st, C &check) {\n        T acc = ti;\n        return find(st, check, acc, 1, 0, n);\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, q;\n    cin >> n >> q;\n\n    auto f = [](P a, P b) { return P(a.fi + b.fi, a.se + b.se);};\n    auto g = [](P a, int b) { return P(b * a.se, a.se);};\n    auto h = [](int a, int b) { (void)a; return b;};\n    lazy_segment_tree<P, int> seg(f, g, h, P(0, 0), 1001);\n    seg.build(vector<P>(n, P(0, 1)));\n    \n    while (q--) {\n        int com, s, t, x;\n        cin >> com >> s >> t;\n        if (com == 0) {\n            cin >> x;\n            seg.update(s, t+1, x);\n        } else {\n            cout << seg.fold(s, t+1).fi << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\ntypedef complex<D> P;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n \ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,const pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,const vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\ntemplate<typename T>vector<T> & cset(vector<T> &A,T e=T()){for(auto &I:A){I=e;} return A;}\n \n \n#ifndef SEGMENT_TREE\n#define SEGMENT_TREE\n \ntemplate<typename Data,typename Mono>\nclass SegTree{\nprivate:\n  typedef function<void(Data&,Data&)> MergeData;\n  typedef function<void(Mono&,Mono&)> MergeMono;\n  typedef function<void(Data&,Mono&)> Culc;\n  typedef function<bool(Data&,Mono&,int&,int&)> UpdateQuery; //data,mono,left,right true::Data,Monoに作用する false::子に降りる\n \n \n  int size,high;\n  vector<int> left,right;\n  vector<Data> dv;\n  vector<Mono> mv;\n   \n  Data de;\n  Mono me;\n  MergeData df;\n  MergeMono mf;\n  Culc cf;\n   \n \n  inline bool nx(int &idx){\n    while(idx&1){idx>>=1; if(idx){reculc(idx);}}\n    return idx?idx|=1:idx;\n  }\n \n  inline void reculc(int idx){\n    dv[idx]=dv[idx<<1];\n    df(dv[idx],dv[(idx<<1)|1]);\n    cf(dv[idx],mv[idx]);\n  }\n \n  inline void down(int idx){\n    cf(dv[idx<<1],mv[idx]);\n    mf(mv[idx<<1],mv[idx]);\n    cf(dv[(idx<<1)|1],mv[idx]);\n    mf(mv[(idx<<1)|1],mv[idx]);\n    mv[idx]=me;\n  }\n \npublic:\n  SegTree(Data de,Mono me,MergeData df,MergeMono mf,Culc cf,int n=0):de(de),me(me),df(df),mf(mf),cf(cf){init(n);}\n \n  void init(int n){\n    size=1;\n    high=0;\n    while(size<n){size<<=1; high++;}\n    dv.assign(size<<1,de);\n    mv.assign(size<<1,me);\n    left.resize(size<<1);\n    right.resize(size<<1);\n    for(int i=0;i<size;i++){left[size|i]=i; right[size|i]=i+1;}\n    for(int i=size-1;i>0;i--){left[i]=left[i<<1]; right[i]=right[(i<<1)|1];}\n  }\n \n  void build(const vector<Data> &ary){\n    int n=ary.size();\n    init(n);\n    for(int i=0;i<n;i++){dv[size|i]=ary[i];}\n    for(int i=size-1;i>0;i--){dv[i]=dv[i<<1]; df(dv[i],dv[(i<<1)|1]);}\n  }\n \n  //[lf,rg)\n  Data query(int lf,int rg){\n    Data ret=de;\n    int idx=1;\n    bool j=true;\n    while(j){\n      if(right[idx]<=lf || rg<=left[idx]){j&=nx(idx);}\n      else if(lf<=left[idx] && right[idx]<=rg){df(ret,dv[idx]); j&=nx(idx);}\n      else{down(idx); idx<<=1;}\n    }\n    return ret;\n  }\n \n  void update(int lf,int rg,Mono m){\n    int idx=1;\n    bool j=true;\n    while(j){\n      if(right[idx]<=lf || rg<=left[idx]){j&=nx(idx);}\n      else if(lf<=left[idx] && right[idx]<=rg){\n        cf(dv[idx],m); mf(mv[idx],m); j&=nx(idx);\n      }\n      else{down(idx); idx<<=1;}\n    }\n  }\n \n  void update(int lf,int rg,UpdateQuery br){\n    int idx=1;\n    bool j=true;\n    while(j){\n      if(right[idx]<=lf || rg<=left[idx]){j&=nx(idx);}\n      else if(lf<=left[idx] && right[idx]<=rg){\n        if(br(dv[idx],mv[idx],left[idx],right[idx])){j&=nx(idx);}\n        else{down(idx); idx<<=1;}\n      }\n      else{down(idx); idx<<=1;}\n    }\n  }\n \n  void DEBUG(){cout<<dv<<endl;}\n};\n \n#endif /*SEGMENT_TREE*/\n \n \nvoid DSL_2_A(){\n  ll n,q;\n  cin>>n>>q;\n  auto df=[](ll &a,ll &b)->void{a=min(a,b);};\n  auto mf=[](pll &a,pll &b)->void{a=(b.F==0?a:b);};\n  auto cf=[](ll &a,pll &b)->void{if(b.F!=0){a=b.S;}};\n  ll de=1e18;\n  pll me={0,0};\n  SegTree<ll,pll> Tr(de,me,df,mf,cf);\n  Tr.build(vector<ll>(n,(1LL<<31)-1));\n  for(int i=0;i<q;i++){\n    int c,x,y;\n    cin>>c>>x>>y;\n    if(c){\n      cout<<Tr.query(x,y+1)<<endl;\n    }\n    else{\n      Tr.update(x,x+1,{1,y});\n    }\n  }\n}\n \nvoid DSL_2_B(){\n  ll n,q;\n  cin>>n>>q;\n  auto df=[](ll &a,ll &b)->void{a+=b;};\n  auto mf=[](ll &a,ll &b)->void{a+=b;};\n  auto cf=[](ll &a,ll &b)->void{a+=b;};\n  ll de=0;\n  ll me=0;\n  SegTree<ll,ll> Tr(de,me,df,mf,cf);\n  Tr.build(vector<ll>(n,0));\n  for(int i=0;i<q;i++){\n    int c,x,y;\n    cin>>c>>x>>y;\n    if(c){\n      x--;\n      cout<<Tr.query(x,y)<<endl;\n    }\n    else{\n      x--;\n      Tr.update(x,x+1,y);\n    }\n  }\n}\n \nvoid DSL_2_D(){\n  ll n,q;\n  cin>>n>>q;\n  auto df=[](ll &a,ll &b)->void{a=min(a,b);};\n  auto mf=[](pll &a,pll &b)->void{a=(b.F==0?a:b);};\n  auto cf=[](ll &a,pll &b)->void{if(b.F!=0){a=b.S;}};\n  ll de=1e18;\n  pll me={0,0};\n  SegTree<ll,pll> Tr(de,me,df,mf,cf);\n  Tr.build(vector<ll>(n,(1LL<<31)-1));\n  for(int i=0;i<q;i++){\n    int c,x,y,z;\n    cin>>c;\n    if(c){\n      cin>>x;\n      cout<<Tr.query(x,x+1)<<endl;\n    }\n    else{\n      cin>>x>>y>>z;\n      Tr.update(x,y+1,{1,z});\n    }\n  }\n}\n \nvoid DSL_2_E(){\n  ll n,q;\n  cin>>n>>q;\n  auto df=[](pll &a,pll &b)->void{a.F+=b.F; a.S+=b.S;};\n  auto mf=[](ll &a,ll &b)->void{a+=b;};\n  auto cf=[](pll &a,ll &b)->void{a.F+=b*a.S;};\n  pll de={0,0};\n  ll me=0;\n  SegTree<pll,ll> Tr(de,me,df,mf,cf);\n  Tr.build(vector<pll>(n,{0,1}));\n  for(int i=0;i<q;i++){\n    int c,x,y,z;\n    cin>>c>>x;\n    x--;\n    if(c){\n      cout<<Tr.query(x,x+1).F<<endl;\n    }\n    else{\n      cin>>y>>z;\n      Tr.update(x,y,z);\n    }\n  }\n}\n \nvoid DSL_2_F(){\n  ll n,q;\n  cin>>n>>q;\n  auto df=[](ll &a,ll &b)->void{a=min(a,b);};\n  auto mf=[](pll &a,pll &b)->void{a=(b.F==0?a:b);};\n  auto cf=[](ll &a,pll &b)->void{if(b.F!=0){a=b.S;}};\n  ll de=1e18;\n  pll me={0,0};\n  SegTree<ll,pll> Tr(de,me,df,mf,cf);\n  Tr.build(vector<ll>(n,(1LL<<31)-1));\n  for(int i=0;i<q;i++){\n    int c,x,y,z;\n    cin>>c;\n    if(c){\n      cin>>x>>y;\n      cout<<Tr.query(x,y+1)<<endl;\n    }\n    else{\n      cin>>x>>y>>z;\n      Tr.update(x,y+1,{1,z});\n    }\n  }\n}\n \nvoid DSL_2_G(){\n  ll n,q;\n  cin>>n>>q;\n  auto df=[](pll &a,pll &b)->void{a.F+=b.F; a.S+=b.S;};\n  auto mf=[](ll &a,ll &b)->void{a+=b;};\n  auto cf=[](pll &a,ll &b)->void{a.F+=b*a.S;};\n  pll de={0,0};\n  ll me=0;\n  SegTree<pll,ll> Tr(de,me,df,mf,cf);\n  Tr.build(vector<pll>(n,{0,1}));\n  for(int i=0;i<q;i++){\n    int c,x,y,z;\n    cin>>c>>x;\n    x--;\n    if(c){\n      cin>>y;\n      cout<<Tr.query(x,y).F<<endl;\n    }\n    else{\n      cin>>y>>z;\n      Tr.update(x,y,z);\n    }\n  }\n}\n \nvoid DSL_2_H(){\n  ll n,q;\n  cin>>n>>q;\n  auto df=[](ll &a,ll &b)->void{a=min(a,b);};\n  auto mf=[](ll &a,ll &b)->void{a+=b;};\n  auto cf=[](ll &a,ll &b)->void{a+=b;};\n  ll de=1e18;\n  ll me=0;\n  SegTree<ll,ll> Tr(de,me,df,mf,cf);\n  Tr.build(vector<ll>(n,0));\n  for(int i=0;i<q;i++){\n    int c,x,y,z;\n    cin>>c>>x;\n    if(c){\n      cin>>y;\n      cout<<Tr.query(x,y+1)<<endl;\n    }\n    else{\n      cin>>y>>z;\n      Tr.update(x,y+1,z);\n    }\n  }\n}\n \nvoid DSL_2_I(){\n  ll n,q;\n  cin>>n>>q;\n  auto df=[](pll &a,pll &b)->void{a.F+=b.F; a.S+=b.S;};\n  auto mf=[](pll &a,pll &b)->void{a=(b.F==0?a:b);};\n  auto cf=[](pll &a,pll &b)->void{if(b.F){a.F=b.S*a.S;}};\n  pll de={0,0};\n  pll me={0,0};\n  SegTree<pll,pll> Tr(de,me,df,mf,cf);\n  Tr.build(vector<pll>(n,{0,1}));\n  for(int i=0;i<q;i++){\n    int c,x,y,z;\n    cin>>c>>x;\n    if(c){\n      cin>>y;\n      cout<<Tr.query(x,y+1).F<<endl;\n    }\n    else{\n      cin>>y>>z;\n      Tr.update(x,y+1,{1,z});\n    }\n  }\n}\n \nint main(){\ncin.tie(0);\n    ios::sync_with_stdio(false);\n  DSL_2_I();\n \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <stack>\n#include <vector>\n#include <complex>\n#include <math.h>\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <iterator>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <regex>\n#include <limits>\n#include <time.h>\n#include <cstdint>\nusing namespace std;\nusing pii  = pair<int,int>;\nusing ll=long long;\nusing ld=long double;\n#define pb push_back\n#define mp make_pair\n#define sc second\n#define fr first\n#define stpr setprecision\n#define cYES cout<<\"YES\"<<endl\n#define cNO cout<<\"NO\"<<endl\n#define cYes cout<<\"Yes\"<<endl\n#define cNo cout<<\"No\"<<endl\n#define rep(i,n) for(ll i=0;i<(n);++i)\n#define Rep(i,a,b) for(ll i=(a);i<(b);++i)\n#define rrep(i,n) for(ll i=n-1;i>=0;i--)\n#define rRep(i,a,b) for(ll i=a;i>=b;i--)\n#define crep(i) for(char i='a';i<='z';++i)\n#define psortsecond(A,N) sort(A,A+N,[](const pii &a, const pii &b){return a.second<b.second;});\n#define ALL(x) (x).begin(),(x).end()\n#define debug(v) cout<<#v<<\":\";for(auto x:v){cout<<x<<' ';}cout<<endl;\n#define endl '\\n'\nint ctoi(const char c){\n  if('0' <= c && c <= '9') return (c-'0');\n  return -1;\n}\nll gcd(ll a,ll b){return (b == 0 ? a : gcd(b, a%b));}\nll lcm(ll a,ll b){return a*b/gcd(a,b);}\nconstexpr ll MOD=1000000007;\nconstexpr ll INF=1000000011;\nconstexpr ll MOD2=998244353;\nconstexpr ll LINF = 1001002003004005006ll;\nconstexpr ld EPS=10e-8;\ntemplate <class T, class U> inline bool chmax(T& lhs, const U& rhs) { if (lhs < rhs) { lhs = rhs; return 1; } return 0; }\ntemplate <class T, class U> inline bool chmin(T& lhs, const U& rhs) { if (lhs > rhs) { lhs = rhs; return 1; } return 0; }\ntemplate<typename T> istream& operator>>(istream& is,vector<T>& v){for(auto&& x:v)is >> x;return is;}\ntemplate<typename T,typename U> istream& operator>>(istream& is, pair<T,U>& p){ is >> p.first; is >> p.second; return is;}\ntemplate<typename T,typename U> ostream& operator>>(ostream& os, const pair<T,U>& p){ os << p.first << ' ' << p.second; return os;}\ntemplate<class T> ostream& operator<<(ostream& os, vector<T>& v){\n  for(auto i=begin(v); i != end(v); ++i){\n    if(i !=begin(v)) os << ' ';\n    os << *i;\n  }\n  return os;\n}\n\n// modint\n\ntemplate <std::uint_fast64_t Modulus> class modint {\n  using u64 = std::uint_fast64_t;\n\npublic:\n  u64 a;\n\n  constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n\ntemplate <typename T,typename E>\nstruct SegmentTree{\n  using F = function<T(T,T)>;\n  using G = function<T(T,E)>;\n  using H = function<E(E,E)>;\n  int n,height;\n  F f;\n  G g;\n  H h;\n  T ti;  // 単位元\n  E ei;  // 初期値\n  vector<T> dat;\n  vector<E> laz;\n  SegmentTree(F f,G g,H h,T ti,E ei):\n    f(f),g(g),h(h),ti(ti),ei(ei){}\n  \n  void init(int n_){\n    n=1;height=0;\n    while(n<n_) n<<=1,height++;\n    dat.assign(2*n,ti);\n    laz.assign(2*n,ei);\n  }\n  void build(const vector<T> &v){\n    int n_=v.size();\n    init(n_);\n    for(int i=0;i<n_;i++) dat[n+i]=v[i];\n    for(int i=n-1;i;i--)\n      dat[i]=f(dat[(i<<1)|0],dat[(i<<1)|1]);\n  }\n  inline T reflect(int k){\n    return laz[k]==ei?dat[k]:g(dat[k],laz[k]);\n  }\n  inline void eval(int k){\n    if(laz[k]==ei) return;\n    laz[(k<<1)|0]=h(laz[(k<<1)|0],laz[k]);\n    laz[(k<<1)|1]=h(laz[(k<<1)|1],laz[k]);\n    dat[k]=reflect(k);\n    laz[k]=ei;\n  }\n  inline void thrust(int k){\n    for(int i=height;i;i--) eval(k>>i);\n  }\n  inline void recalc(int k){    \n    while(k>>=1)  \n    dat[k]=f(reflect((k<<1)|0),reflect((k<<1)|1));\n  }\n  void update(int a,int b,E x){\n    thrust(a+=n);\n    thrust(b+=n-1);\n    for(int l=a,r=b+1;l<r;l>>=1,r>>=1){\n      if(l&1) laz[l]=h(laz[l],x),l++;\n      if(r&1) --r,laz[r]=h(laz[r],x);\n    }\n    recalc(a);\n    recalc(b);\n  }\n  void set_val(int a,T x){\n    thrust(a+=n);\n    dat[a]=x;laz[a]=ei;\n    recalc(a);\n  }\n  T query(int a,int b){\n    thrust(a+=n);\n    thrust(b+=n-1);\n    T vl=ti,vr=ti;\n    for(int l=a,r=b+1;l<r;l>>=1,r>>=1) {\n      if(l&1) vl=f(vl,reflect(l++));\n      if(r&1) vr=f(reflect(--r),vr);\n    }\n    return f(vl,vr);\n  }\n};\n\nsigned main(){\n  int N,Q;\n  cin >> N >> Q;\n  using P = pair<ll, ll>;\n  auto f=[](P a,P b){return P(a.first+b.first,a.second+b.second);};    //  date同士の演算\n  auto g=[](P a,ll b){return P(b*a.second,a.second);};    //  lazyからdateへ(bがlazy)\n  auto h=[](ll a,ll b){return b;};    // lazyの代入\n  SegmentTree<P,ll> rsq(f,g,h,mp(0,0),LINF);\n  vector<P> V;\n  V = vector<P>(N,mp(0,1));\n  rsq.build(V);\n\n\n\n  \n  for(int i=0;i<Q;i++){\n    int c,s,t,x;\n    cin>>c;\n    if(c){\n      cin>>s>>t;\n      cout<<rsq.query(s,t+1).fr<<endl;   // 0-indexed での[s,t) を入れる\n    }else{\n      cin>>s>>t>>x;\n      rsq.update(s,t+1,x);            // 0-indexed での[s,t) を入れる\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename T> class segtree {\nprivate:\n    int n,sz;\n    vector<T> node, min_val, second_val, lazy;\n    vector<int> count;\n    vector<bool> lazyFlag;\n    void update(int id){\n        node[id] = node[2*id+1] + node[2*id+2];\n        if(min_val[2*id+1] < min_val[2*id+2]){\n            min_val[id] = min_val[2*id+1];\n            second_val[id] = min(second_val[2*id+1],min_val[2*id+2]);\n            count[id] = count[2*id+1];\n        }else if(min_val[2*id+1] > min_val[2*id+2]){\n            min_val[id] = min_val[2*id+2];\n            second_val[id] = min(min_val[2*id+1],second_val[2*id+2]);\n            count[id] = count[2*id+2];\n        }else{\n            min_val[id] = min_val[2*id+1];\n            second_val[id] = min(second_val[2*id+1],second_val[2*id+2]);\n            count[id] = count[2*id+1]+count[2*id+2];\n        }\n    }\npublic:\n    segtree(vector<T>& v) {\n        sz = (int)v.size();\n        n = 1;\n        while(n < sz){\n            n *= 2;\n        }\n        node.resize(2*n-1, 0);\n        lazy.resize(2*n-1, 0);\n        lazyFlag.resize(2*n-1,false);\n        min_val.resize(2*n-1,numeric_limits<T>::max());\n        second_val.resize(2*n-1,numeric_limits<T>::max());\n        count.resize(2*n-1,1);\n        rep(i,sz){\n            node[i+n-1] = min_val[i+n-1] = v[i];\n        }\n        for(int i=n-2; i>=0; i--){\n            update(i);\n        }\n    }\n    void eval(int k, int l, int r) {\n        if(lazyFlag[k]){\n            if(lazy[k] > min_val[k]){\n                node[k] += (lazy[k] - min_val[k])*count[k];\n                min_val[k] = lazy[k];\n                if(r - l > 1){\n                    lazy[k*2+1] = lazy[k*2+2] = lazy[k];\n                    lazyFlag[k*2+1] = lazyFlag[k*2+2] = true;\n                }\n                // cout << node[k] << \" \" << min_val[k] << \"\\n\";\n            }\n            lazyFlag[k] = false;\n        }\n    }\n    void range(int a, int b, T x, int k=0, int l=0, int r=-1){\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a || min_val[k] >= x){\n            // cout << \"END \" << k << \"\\n\";\n            return;\n        }\n        if(a <= l && r <= b && second_val[k] > x) {\n            // cout << \"PUT \" << k << \"\\n\";\n            lazy[k] = x;\n            lazyFlag[k] = true;\n            eval(k, l, r);\n        }else{\n            // cout << \"NEXT \" << k << \"\\n\";\n            range(a, b, x, 2*k+1, l, (l+r)/2);\n            range(a, b, x, 2*k+2, (l+r)/2, r);\n            update(k);\n            // cout << k << \" \" << node[k] << \" \" << min_val[k] << \" \" << second_val[k] << \"\\n\";\n        }\n    }\n    T query(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a){\n            return 0;\n        }\n        if(a <= l && r <= b){\n            return node[k];\n        }\n        T vl = query(a, b, 2*k+1, l, (l+r)/2);\n        T vr = query(a, b, 2*k+2, (l+r)/2, r);\n        return vl + vr;\n    }\n    void print()\n    {\n        rep(i,sz){\n            cout << query(i,i+1) << \" \";\n        }\n        cout << endl;\n    }\n};\n\ntemplate<typename V> class segtree2 {\nprivate:\n    int n,sz;\n    vector<V> node, lazy;\n    vector<bool> lazyFlag;\n\npublic:\n    segtree2(vector<V>& v) {\n        sz = (int)v.size();\n        n = 1;\n        while(n < sz){\n            n *= 2;\n        }\n        node.resize(2*n-1, 0);\n        lazy.resize(2*n-1, 0);\n        lazyFlag.resize(2*n-1,false);\n        rep(i,sz){\n            node[i+n-1] = v[i];\n        }\n        for(int i=n-2; i>=0; i--){\n            node[i] = node[i*2+1] + node[i*2+2];\n        }\n    }\n    void eval(int k, int l, int r) {\n        if(lazyFlag[k]) {\n            node[k] = lazy[k]*(r-l);\n            if(r - l > 1) {\n                lazy[k*2+1] = lazy[k*2+2] = lazy[k];\n                lazyFlag[k*2+1] = lazyFlag[k*2+2] = true;\n            }\n            lazyFlag[k] = false;\n        }\n    }\n    void range(int a, int b, V x, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a){\n            return;\n        }\n        if(a <= l && r <= b) {\n            lazy[k] = x;\n            lazyFlag[k] = true;\n            eval(k, l, r);\n        }\n        else {\n            range(a, b, x, 2*k+1, l, (l+r)/2);\n            range(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k] = node[2*k+1] + node[2*k+2];\n        }\n    }\n    V query(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a){\n            return 0;\n        }\n        if(a <= l && r <= b){\n            return node[k];\n        }\n        V vl = query(a, b, 2*k+1, l, (l+r)/2);\n        V vr = query(a, b, 2*k+2, (l+r)/2, r);\n        return vl + vr;\n    }\n    void print()\n    {\n        rep(i,sz){\n            cout << query(i,i+1) << \" \";\n        }\n        cout << endl;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,q;\n    cin >> n >> q;\n    vector<int> vec(n,0);\n    segtree<int> sg(vec);\n    segtree2<int> sg2(vec);\n    rep(i,q){\n        int a;\n        cin >> a;\n        if(a==0){\n            int b,c,d;\n            cin >> b >> c >> d;\n            sg.range(b,c+1,d);\n            sg2.range(b,c+1,d);\n        }else{\n            int b,c;\n            cin >> b >> c;\n            sg.query(b,c+1);\n            cout << sg2.query(b,c+1) << \"\\n\";\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\nconst int INF=1e9;\n\nclass LazySegmentTree\n{\n private:\n    int n;\n    vector<int> node,lazy;\n public:\n    LazySegmentTree(int sz){\n        n=1;\n        while(n<sz) n*=2;\n        node.assign(2*n-1,0LL);\n        lazy.assign(2*n-1,INF);\n    }\n    void update(int a,int b,int x,int k,int l,int r){\n        if(a<=l and r<=b){\n            node[k]=x*(r-l);\n            lazy[k]=x;\n        }else{\n            if(lazy[k]!=INF) push(k,l,r),lazy[k]=INF;\n            if(check(a,b,l,(l+r)/2)) update(a,b,x,2*k+1,l,(l+r)/2);\n            if(check(a,b,(l+r)/2,r)) update(a,b,x,2*k+2,(l+r)/2,r);\n            node[k]=node[2*k+1]+node[2*k+2];\n        }\n    }\n    int get(int a,int b,int k,int l,int r){\n        if(a<=l and r<=b){\n            return node[k];\n        }else{\n            if(lazy[k]!=INF) push(k,l,r),lazy[k]=INF;\n            int res=0;\n            if(check(a,b,l,(l+r)/2)) res+=get(a,b,2*k+1,l,(l+r)/2);\n            if(check(a,b,(l+r)/2,r)) res+=get(a,b,2*k+2,(l+r)/2,r);\n            return res;\n        }\n    }\n    void push(int k,int l,int r){\n        node[2*k+1]=lazy[k]*(r-l)/2; lazy[2*k+1]=lazy[k];\n        node[2*k+2]=lazy[k]*(r-l)/2; lazy[2*k+2]=lazy[k];\n    }\n    bool check(int a,int b,int l,int r){\n        return max(a,l)<min(b,r);\n    }\n    void update(int a,int b,int x){ update(a,b,x,0,0,n); }\n    int get(int a,int b){ return get(a,b,0,0,n); }\n};\n\nsigned main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N,Q; cin>>N>>Q;\n    LazySegmentTree seg(N);\n    while(Q--){\n        int q; cin>>q;\n        if(q==0){\n            int s,t,x; cin>>s>>t>>x;\n            seg.update(s,t+1,x);\n        }else{\n            int s,t; cin>>s>>t;\n            cout<<seg.get(s,t+1)<<endl;\n        }\n        // for(int i=0;i<4;i++) cout<<seg.get(i,i+1)<<' '; cout<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass segment_tree{\n    vector<int64_t> val;\n    vector<pair<int64_t, int64_t>> op;\n    vector<pair<size_t, size_t>> range;\n\n    // min, max -> MAX, MIN\n    const int64_t def_value = 0;\n    const pair<int64_t, int64_t> ident = {1, 0};\n    struct{\n        int64_t operator()(const int64_t &lhs, const int64_t &rhs) const{\n            return lhs+rhs;\n        }\n    } f;\n\n    size_t N, depth;\n\n    inline void merge(size_t target, int64_t alpha, int64_t beta){\n        op[target] = {op[target].first * alpha, op[target].second * alpha + beta};\n    }\n    inline void propagate(size_t target){\n        if(op[target] == ident) return;\n        // min, max -> width = 1\n        val[target] = op[target].first * val[target] + op[target].second * (range[target].second - range[target].first);\n        if(target  < N){\n            merge(2*target, op[target].first, op[target].second);\n            merge(2*target+1, op[target].first, op[target].second);\n        }\n        op[target] = ident;\n    }\n    \n    inline void eval(int n){\n        stack<size_t> stk;\n        for(;n>0;n>>=1) stk.push(n);\n        while(!stk.empty()){\n            propagate(stk.top());\n            stk.pop();\n        }\n    }\n    inline void get_target(vector<size_t> &target, size_t left, size_t right, stack<size_t> *refresh=nullptr){\n        queue<size_t> partial;\n        \n        if(left <= 0 && right >= N) target.push_back(1);\n        else partial.push(1);\n\n        while(!partial.empty()){\n            size_t i = partial.front();\n            if(refresh != nullptr) refresh->push(i);\n            partial.pop();\n\n            propagate(i);\n\n            if(left <= range[i].first){\n                if(right < range[i*2].second) partial.push(i*2);\n                else{\n                    target.push_back(i*2);\n                    if(range[i*2+1].first < right) partial.push(i*2+1);\n                }\n            }else{\n                if(left < range[i*2].second){\n                    partial.push(i*2);\n                    if(range[i*2+1].second <= right) target.push_back(i*2+1);\n                    else if(range[i*2].second < right) partial.push(i*2+1); \n                }else{\n                    if(left <= range[i*2+1].first && range[i*2+1].second <= right) target.push_back(i*2+1);\n                    else partial.push(i*2+1);\n                }\n            }\n        }\n    }\npublic:\n    segment_tree(size_t n){\n        for(depth=0;(1ULL<<depth)<n;depth++);\n        N = 1ULL<<depth;\n        val.reserve(1ULL<<(++depth));\n        op.reserve(1ULL<<depth);\n        range.reserve(1ULL<<depth);\n        for(size_t i=2*N-1;i>0;i--){\n            val[i] = def_value;\n            op[i] = ident;\n            if(i>=N) range[i] = {i-N, i-N+1};\n            else range[i] = {range[2*i].first, range[2*i+1].second};\n        }\n    }\n    int64_t operator[](size_t i){\n        eval(N+i);\n        return val[N+i];\n    }\n    void operate(int64_t alpha, int64_t beta, size_t left, size_t right){\n        if(right <= left) return;\n\n        vector<size_t> target;\n        stack<size_t> refresh;\n        get_target(target, left, right, &refresh);\n        for(auto i : target){\n            merge(i, alpha, beta);\n            propagate(i);\n        }\n        while(!refresh.empty()){\n            size_t i = refresh.top();\n            refresh.pop();\n            propagate(i*2);\n            propagate(i*2+1);\n            val[i] = f(val[i*2], val[i*2+1]);\n        }\n    }\n    int64_t get_sum(size_t left, size_t right){\n        if(right <= left) return 0;\n        \n        vector<size_t> target;\n        get_target(target, left, right);\n        int64_t ret = 0;\n        for(auto i : target){\n            propagate(i);\n            ret = f(ret, val[i]);\n        }\n        return ret;\n    }\n    void update(int64_t val, size_t pos){\n        operate(0, val, pos, pos+1);\n    }\n    void update(int64_t val, size_t left, size_t right){\n        operate(0, val, left, right);\n    }\n    void add(int64_t val, size_t pos){\n        operate(1, val, pos, pos+1);\n    }\n    void add(int64_t val, size_t left, size_t right){\n        operate(1, val, left, right);\n    }\n\n    void dump(){\n        for(int i=1;i<2*N;i++){\n            cerr << val[i] << \"(\" << op[i].first << \",\" << op[i].second << \")\\t\";\n            if(__builtin_popcount(i+1)==1) cerr << endl;\n        }\n    }\n};\n\nint main(){\n    int n, q;\n    cin >> n >> q;\n    segment_tree st(n);\n\n    for(int i=0;i<q;i++){\n        int com;\n        cin >> com;\n        if(com == 0){\n            int s, t, x;\n            cin >> s >> t >> x;\n            st.update(x, s, t+1);\n        }else{\n            int s, t;\n            cin >> s >> t;\n            cout << st.get_sum(s, t+1) << endl;\n        }\n        //st.dump();\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\n// Range Update, Range Sum\ntemplate<class T>\nstruct lazy_segment_tree{\n  std::vector<T> data;\n  std::vector<T> lazy;\n  int n;\n  T identity1,identity2;\n  lazy_segment_tree(){}\n  lazy_segment_tree(int sz,T ide1,T ide2):identity1(ide1),identity2(ide2){\n    n = 1;\n    while(n<sz)n<<=1;\n    data.resize(2*n-1,identity1);\n    lazy.resize(2*n-1,identity2);\n  }\n  lazy_segment_tree(std::vector<T> const& vec,T ide1,T ide2):identity1(ide1),identity2(ide2){\n    int sz = vec.size();\n    n = 1;\n    while(n<sz)n<<=1;\n    data.resize(2*n-1,identity1);\n    lazy.resize(2*n-1,identity2);\n    for(int i=0;i<sz;++i){\n      data[i+n-1] = vec[i];\n    }\n    for(int i=sz-2;i>=0;--i){\n      data[i] = data[i*2+1] + data[i*2+2];\n    }\n  }\n  void eval(int k){\n    if(lazy[k]==identity2)return;\n    if(k<n-1){\n      lazy[2*k+1] = lazy[k]/2;\n      lazy[2*k+2] = lazy[k]/2;\n    }\n    data[k] = lazy[k];\n    lazy[k] = identity2;\n  }\n  void update_impl(int a,int b,T x,int k,int l,int r){\n    eval(k);\n    if(a<=l && r<=b){\n      lazy[k] = x*(r-l);\n      eval(k);\n    }\n    else if(a<r && l<b){\n      update_impl(a,b,x,2*k+1,l,(l+r)/2);\n      update_impl(a,b,x,2*k+2,(l+r)/2,r);\n      data[k] = data[2*k+1] + data[2*k+2];\n    }\n  }\n  T query_impl(int a,int b,int k,int l,int r){\n    eval(k);\n    if(r<=a||b<=l){\n      return identity1;\n    }\n    else if(a<=l && r<=b){\n      return data[k];\n    }\n    else{\n      T vl = query_impl(a,b,2*k+1,l,(l+r)/2);\n      T vr = query_impl(a,b,2*k+2,(l+r)/2,r);\n      return vl + vr;\n    }\n  }\n  void update(int a,int b,T x){\n    update_impl(a,b,x,0,0,n);\n  }\n  T query(int a,int b){\n    T res = query_impl(a,b,0,0,n);\n    return res;\n  }\n  T operator[](int i){\n    return query(i,i+1);\n  }\n  void dump(){\n    int cnt = 1;\n    int now = 0;\n    for(int i=0;i<2*n-1;++i){\n      eval(i);\n      cout<<data[i];\n      now++;\n      if(cnt==now){\n        cout<<endl;\n        cnt*=2;\n        now=0;\n      }else cout<<\" \";\n    }\n  }\n};\n\nsigned main(){\n  cin.tie(0);\n  std::ios::sync_with_stdio(false);\n  int N;cin>>N;\n  lazy_segment_tree<int> data(N,0,1001);\n  int Q;cin>>Q;\n  while(Q--){\n    int c;cin>>c;\n    if(c==0){\n      int s,t,x;cin>>s>>t>>x;\n      data.update(s,t+1,x);\n    }else{\n      int s,t;cin>>s>>t;\n      cout<< data.query(s,t+1) <<endl;\n    }\n    //data.dump();\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target (\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define _USE_MATH_DEFINES\n#include<iostream>\n#include<string>\n#include<queue>\n#include<cmath>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<random>\n#include<functional>\n#include<algorithm>\n#include<stack>\n#include<cstdio>\n#include<cstring>\n#include<bitset>\n#include<unordered_map>\n#include<climits>\n#include<fstream>\n#include<complex>\n#include<time.h>\n#include<cassert>\n#include<functional>\n#include<numeric>\n#include<tuple>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n#define int long long\n#define all(a) (a).begin(),(a).end()\n#define fs first\n#define sc second\n#define xx first\n#define yy second.first\n#define zz second.second\n#define H pair<int, int>\n#define P pair<int, pair<int, int>>\n#define Q(i,j,k) mkp(i,mkp(j,k))\n#define rng(i,s,n) for(int i = (s) ; i < (n) ; i++)\n#define rep(i,n) rng(i, 0, (n))\n#define mkp make_pair\n#define vec vector\n#define pb emplace_back\n#define crdcomp(b) sort(all((b)));(b).erase(unique(all((b))),(b).end())\n#define getidx(b,i) lower_bound(all(b),(i))-b.begin()\n#define ssp(i,n) (i==(int)(n)-1?\"\\n\":\" \")\n#define ctoi(c) (int)(c-'0')\n#define itoc(c) (char)(c+'0')\n#define pp(x,y) pb(H{x,y})\n#define ppp(x,y,z) pb(Q(x,y,z))\n#define cyes printf(\"Yes\\n\")\n#define cno printf(\"No\\n\")\n#define cdf(n) int quetimes_=(n);rep(qq123_,quetimes_)\n#define gcj printf(\"Case #%lld: \",qq123_+1)\n#define readv(a,n) a.resize(n,0);rep(i,(n)) a[i]=read()\n//#define endl \"\\n\"\nconstexpr int mod = 1e9 + 7;\nconstexpr int Mod = 998244353;\nconstexpr int MXN = 500000 + 100;\nconstexpr ld EPS = 1e-10;\nconstexpr ll inf = 3 * 1e18;\nconstexpr int Inf = 15 * 1e8;\nconst vec<int>dx{ -1,1,0,0 }, dy{ 0,0,-1,1 };\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\nll read() { ll u, k = scanf(\"%lld\", &u); return u; }\nstring reads() { string s; cin >> s; return s; }\nH readh(bool g = 0) { H u; int k = scanf(\"%lld %lld\", &u.fs, &u.sc); if (g) u.fs--, u.sc--; return u; }\nbool inarea(H t, int h, int w) { return 0 <= t.fs && t.fs < h && 0 <= t.sc && t.sc < w; }\nll gcd(ll i, ll j) { return j ? gcd(j, i % j) : i; }\nll mod_pow(ll x, ll n, ll p = mod) {\n\tll res = 1; x %= p;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % p;\n\t\tx = x * x % p;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}//x^n%p\nll bitcount(ll x) {\n\tint sum = 0; for (int i = 0; i < 60; i++)if ((1ll << i) & x) sum++;\n\treturn sum;\n}\nconstexpr int fn_ = 1000005;\nll fact_[fn_], comp_[fn_];\nll comb(ll x, ll y, ll Mod = mod) {\n\tif (!fact_[0]) {\n\t\tfact_[0] = 1; comp_[0] = 1;\n\t\tfor (int i = 1; i < fn_; i++)\n\t\t\tfact_[i] = fact_[i - 1] * i % Mod;\n\t\tcomp_[fn_ - 1] = mod_pow(fact_[fn_ - 1], Mod - 2, Mod);\n\t\tfor (int i = fn_ - 2; i > 0; i--)\n\t\t\tcomp_[i] = comp_[i + 1] * (i + 1) % Mod;\n\t}\n\tif (x < y) return 0;\n\treturn fact_[x] * comp_[x - y] % Mod * comp_[y] % Mod;\n}\n//--------------------------------------------------------------\nauto RUQ = [](int& num, int x, int width) {num = x; };\nauto RAQ = [](int& num, int x, int width) {num += x; };\nauto RCMXQ = [](int& num, int x, int width) {num = max(num, x); };\nauto RCMNQ = [](int& num, int x, int width) {num = min(num, x); };\nauto RASQ = [](int& num, int x, int width) {num += (x * width); };\nauto RUSQ = [](int& num, int x, int width) {num = (x * width); };\nauto RSQ = [](int x, int y)->int {return x + y; };\nauto RMXQ = [](int x, int y)->int {return max(x, y); };\nauto RMNQ = [](int x, int y)->int {return min(x, y); };\nclass Segtree {\n#define DAT_SIZE 2000000\n\tusing F = function<void(int&, int, int)>;\n\tusing T = function<int(int, int)>;\n\tint siz, rr, zer, zer2;\n\tint dat[DAT_SIZE], lazy[DAT_SIZE];\n\tbool updated[DAT_SIZE];\n\tF upd; T qur;\npublic:\n\t//for query, for update\n\tvoid init(int size, F update, T query, int zero, int zero2) {\n\t\tsiz = size, upd = update, qur = query, zer = zero, zer2 = zero2;\n\t\trr = 1; while (rr < size) rr *= 2;\n\t\tfor (int i = 0; i < DAT_SIZE; i++) dat[i] = zer, lazy[i] = zer2, updated[i] = 0;\n\t}\n\tvoid build(const vector<int>& a) {\n\t\tfor (int i = 0; i < min((int)a.size(), rr); i++)\n\t\t\tdat[rr + i - 1] = a[i];\n\t\tfor (int i = rr - 2; i >= 0; i--)\n\t\t\tdat[i] = qur(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t}\n\tvoid update(int a, int b, int x) {\n\t\tupdate(0, a, b, 0, rr, x);\n\t}\n\tint query(int a, int b) {\n\t\treturn query(0, a, b, 0, rr);\n\t}\n\tint lower_bound(int a, int b, function<bool(int)>comp) {\n\t\treturn lower_bound(0, a, b, 0, rr, comp);\n\t}\n\tint upper_bound(int a, int b, function<bool(int)>comp) {\n\t\treturn upper_bound(0, a, b, 0, rr, comp);\n\t}\nprivate:\n\tvoid eval(int i, int l, int r) {\n\t\tif (!updated[i]) return;\n\t\tif (r - l > 1) {\n\t\t\tupd(lazy[i * 2 + 1], lazy[i], 1);\n\t\t\tupd(lazy[i * 2 + 2], lazy[i], 1);\n\t\t\tupdated[i * 2 + 1] = updated[i * 2 + 2] = 1;\n\t\t}\n\t\tupd(dat[i], lazy[i], min(r, siz) - l);\n\t\tlazy[i] = zer2;\n\t\tupdated[i] = 0;\n\t}\n\tvoid update(int i, int a, int b, int l, int r, int x) {\n\t\teval(i, l, r);\n\t\tif (b <= l || r <= a) return;\n\t\tif (a <= l && r <= b) {\n\t\t\tupd(lazy[i], x, 1); updated[i] = 1;\n\t\t\teval(i, l, r);\n\t\t\treturn;\n\t\t}\n\t\tupdate(i * 2 + 1, a, b, l, (l + r) / 2, x);\n\t\tupdate(i * 2 + 2, a, b, (l + r) / 2, r, x);\n\t\tdat[i] = qur(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t}\n\tint query(int i, int a, int b, int l, int r) {\n\t\teval(i, l, r);\n\t\tif (b <= l || r <= a) return zer;\n\t\tif (a <= l && r <= b) return dat[i];\n\t\treturn qur(query(i * 2 + 1, a, b, l, (l + r) / 2),\n\t\t\tquery(i * 2 + 2, a, b, (l + r) / 2, r));\n\t}\n\tint lower_bound(int i, int a, int b, int l, int r, function<bool(int)>comp) {\n\t\teval(i, l, r);\n\t\tif (b <= l || r <= a || !comp(dat[i])) return -1;\n\t\tif (r - l == 1) return l;\n\t\tint tmp = lower_bound(i * 2 + 1, a, b, l, (l + r) / 2, comp);\n\t\tif (tmp >= 0) return tmp;\n\t\treturn lower_bound(i * 2 + 2, a, b, (l + r) / 2, r, comp);\n\t}\n\tint upper_bound(int i, int a, int b, int l, int r, function<bool(int)>comp) {\n\t\teval(i, l, r);\n\t\tif (b <= l || r <= a || !comp(dat[i])) return -1;\n\t\tif (r - l == 1) return r;\n\t\tint tmp = upper_bound(i * 2 + 2, a, b, (l + r) / 2, r, comp);\n\t\tif (tmp >= 0) return tmp;\n\t\treturn upper_bound(i * 2 + 1, a, b, l, (l + r) / 2, comp);\n\t}\n};\nSegtree seg;\nsigned main() {\n\tint n, q; cin >> n >> q;\n\tseg.init(n, RUSQ, RSQ, 0, 0);\n\tseg.build(vec<int>(n, 0));\n\tcdf(q) {\n\t\tint com, x, y, z; cin >> com;\n\t\tif (com == 0) {\n\t\t\tcin >> x >> y >> z;\n\t\t\tseg.update(x, y + 1, z);\n\t\t}\n\t\telse {\n\t\t\tcin >> x >> y;\n\t\t\tcout << seg.query(x, y + 1) << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define endl '\\n'\n#define MOD 1000000007\n#define maxn 100010\n\nint t[5 * maxn], lazy[5 * maxn], clazy[5 * maxn];\n\nint doit(int a, int b) {\n    return a + b;\n}\n\nvoid propagate(int start, int end, int index) {\n    t[index] = (end - start + 1) * lazy[index];\n    if (start != end) {\n        lazy[index << 1] = lazy[index];\n        clazy[index << 1] = 1;\n        clazy[index << 1 | 1] = 1;\n        lazy[index << 1 | 1] = lazy[index];\n    }\n    lazy[index] = 0;\n    clazy[index] = 0;\n}\n\nint query(int start, int end, int l, int r, int index = 1) {\n    if (clazy[index] == 1)\n        propagate(start, end, index);\n    //Invalid range\n    if (r < start or l > end)\n        return 0;\n\n    //In range\n    if (l <= start and end <= r) {\n        return t[index];\n    }\n\n    int mid = start + end >> 1;\n    return doit(query(start, mid, l, r, index << 1), query(mid + 1, end, l, r, index << 1 | 1));\n}\n\nvoid rangeUpdate(int start, int end, int l, int r, int val, int index) {\n    if (clazy[index] == 1)\n        propagate(start, end, index);\n    if (l > end or r < start)\n        return;\n\n    if (l <= start and end <= r) {\n        clazy[index] = 1;\n        lazy[index] = val;\n        propagate(start, end, index);\n        return;\n    }\n\n    int mid = start + end >> 1;\n    rangeUpdate(start, mid, l, r, val, index << 1);\n    rangeUpdate(mid + 1, end, l, r, val, index << 1 | 1);\n\n    t[index] = doit(t[index << 1], t[index << 1 | 1]);\n}\n\nvoid solve() {\n    int n, q;\n    cin >> n >> q;\n\n    for (int i = 0; i < q; i++) {\n        int a;\n        cin >> a;\n\n        if (a == 0) {\n            int s, t, x;\n            cin >> s >> t >> x;\n            rangeUpdate(0, n - 1, s, t, x, 1);\n        } else {\n            int s, t;\n            cin >> s >> t;\n\n            cout << query(0, n - 1, s, t, 1) << endl;\n        }\n    }\n}\n\nint32_t main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t = 1;\n//    cin >> t;\n\n    while (t--)\n        solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//----------------------------templates\n    #pragma GCC optimize (\"Ofast\")\n    #pragma GCC target (\"tune=native\")\n    #pragma GCC target (\"avx\")\n    //----------------------------\n    #include <bits/stdc++.h>\n    using namespace std;\n\n    typedef long long ll;\n    typedef unsigned long long ull;\n    #define int ll\n\n    #define FOR(i,j,n) for (int i=(int)(j);i<(n);i++)\n    #define REP(i,n) for (int i=0;i<(int)(n);i++)\n    #define REPS(i,n) for (int i=1;i<=(int)(n);i++)\n    #define REPN(i,n) for (int i=(int)(n)-1;i>=0;i--)\n    #define REPNS(i,n) for (int i=(int)(n);i>0;i--)\n\n    #define I(n) scanf(\"%lld\", &(n))\n    #define LL(n) scanf(\"%lld\", &(n))\n    #define pb(n) push_back((n))\n    #define mp(i,j) make_pair((i),(j))\n    #define eb(i,j) emplace_back((i),(j))\n    #define y0 y3487465\n    #define y1 y8687969\n    #define j0 j1347829\n    #define j1 j234892\n    #define uniq(v) v.erase( unique(v.begin(), v.end()), v.end() )\n\n    #define all(x) (x).begin(),(x).end()\n    #define sz(x) ((int)(x).size())\n\n    typedef vector<int> vi;\n    typedef pair<int,int> pi;\n    typedef vector<pi> vpi;\n    typedef vector<vi> vvi;\n    typedef vector<vpi> vvpi;\n    typedef vector<vvi> vvvi;\n\n    const int mod = 1000000007;\n\n//--------------------------------------------\n\nclass segment_tree_beats {\n    // MEMO: values for queries (max, min, lazy_add, and lazy_update) already apply to the current node; but not for children\n    typedef struct {\n        int max;\n        int max_second;\n        int max_count;\n        int min;\n        int min_second;\n        int min_count;\n        int lazy_add;\n        int lazy_update;\n        int sum;\n    } value_type;\n\n    int n;\n    vector<value_type> a;\n\n    public:\n    segment_tree_beats() = default;\n    segment_tree_beats(int n_) {\n        n = 1; while (n < n_) n *= 2;\n        a.resize(2 * n - 1);\n        tag<UPDATE>(0, 0);\n    }\n    template <class InputIterator>\n    segment_tree_beats(InputIterator first, InputIterator last) {\n        int n_ = distance(first, last);\n        n = 1; while (n < n_) n *= 2;\n        a.resize(2 * n - 1);\n        REP(i, n_) {\n            tag<UPDATE>(n - 1 + i, *(first + i));\n        }\n        FOR(i, n_, n) {\n            tag<UPDATE>(n - 1 + i, 0);\n        }\n        REPN(i, n-1) {\n            update(i);\n        }\n    }\n\n    void range_chmin(int l, int r, int value) {  // 0-based, [l, r)\n        assert (0 <= l and l <= r and r <= n);\n        range_apply<CHMIN>(0, 0, n, l, r, value);\n    }\n    void range_chmax(int l, int r, int value) {  // 0-based, [l, r)\n        assert (0 <= l and l <= r and r <= n);\n        range_apply<CHMAX>(0, 0, n, l, r, value);\n    }\n    void range_add(int l, int r, int value) {  // 0-based, [l, r)\n        assert (0 <= l and l <= r and r <= n);\n        range_apply<ADD>(0, 0, n, l, r, value);\n    }\n    void range_update(int l, int r, int value) {  // 0-based, [l, r)\n        assert (0 <= l and l <= r and r <= n);\n        range_apply<UPDATE>(0, 0, n, l, r, value);\n    }\n\n    int range_min(int l, int r) {  // 0-based, [l, r)\n        assert (0 <= l and l <= r and r <= n);\n        return range_get<MIN>(0, 0, n, l, r);\n    }\n    int range_max(int l, int r) {  // 0-based, [l, r)\n        assert (0 <= l and l <= r and r <= n);\n        return range_get<MAX>(0, 0, n, l, r);\n    }\n    int range_sum(int l, int r) {  // 0-based, [l, r)\n        assert (0 <= l and l <= r and r <= n);\n        return range_get<SUM>(0, 0, n, l, r);\n    }\n\n    private:\n    static constexpr char CHMIN = 0;\n    static constexpr char CHMAX = 1;\n    static constexpr char ADD = 2;\n    static constexpr char UPDATE = 3;\n    static constexpr char MIN = 10;\n    static constexpr char MAX = 11;\n    static constexpr char SUM = 12;\n\n    template <char TYPE>\n    void range_apply(int i, int il, int ir, int l, int r, int g) {\n        \n        if (ir <= l or r <= il or break_condition<TYPE>(i, g)) {\n            // break\n        } else if (l <= il and ir <= r and tag_condition<TYPE>(i, g)) {\n            tag<TYPE>(i, g);\n        } else {\n            pushdown(i);\n            range_apply<TYPE>(2 * i + 1, il, (il + ir) / 2, l, r, g);\n            range_apply<TYPE>(2 * i + 2, (il + ir) / 2, ir, l, r, g);\n            update(i);\n        }\n    }\n    template <char TYPE>\n    inline bool break_condition(int i, int g) {\n        switch (TYPE) {\n            case CHMIN: return a[i].max <= g;\n            case CHMAX: return g <= a[i].min;\n            case ADD: return false;\n            case UPDATE: return false;\n            default: assert (false);\n        }\n    }\n    template <char TYPE>\n    inline bool tag_condition(int i, int g) {\n        switch (TYPE) {\n            case CHMIN: return a[i].max_second < g and g < a[i].max;\n            case CHMAX: return a[i].min < g and g < a[i].min_second;\n            case ADD: return true;\n            case UPDATE: return true;\n            default: assert (false);\n        }\n    }\n    template <char TYPE>\n    inline void tag(int i, int g) {\n        int length = n >> (64 - __builtin_clzll(i + 1) - 1);\n        if (TYPE == CHMIN) {\n            if (a[i].max == a[i].min or g <= a[i].min) {\n                tag<UPDATE>(i, g);\n                return;\n            }\n            if (a[i].max != INT64_MIN) {\n                a[i].sum -= a[i].max * a[i].max_count;\n            }\n            a[i].max = g;\n            a[i].min_second = min(a[i].min_second, g);\n            if (a[i].lazy_update != INT64_MAX) {\n                a[i].lazy_update = min(a[i].lazy_update, g);\n            }\n            a[i].sum += g * a[i].max_count;\n        } else if (TYPE == CHMAX) {\n            if (a[i].max == a[i].min or a[i].max <= g) {\n                tag<UPDATE>(i, g);\n                return;\n            }\n            if (a[i].min != INT64_MAX) {\n                a[i].sum -= a[i].min * a[i].min_count;\n            }\n            a[i].min = g;\n            a[i].max_second = max(a[i].max_second, g);\n            if (a[i].lazy_update != INT64_MAX) {\n                a[i].lazy_update = max(a[i].lazy_update, g);\n            }\n            a[i].sum += g * a[i].min_count;\n        } else if (TYPE == ADD) {\n            if (a[i].max != INT64_MAX) {\n                a[i].max += g;\n            }\n            if (a[i].max_second != INT64_MIN) {\n                a[i].max_second += g;\n            }\n            if (a[i].min != INT64_MIN) {\n                a[i].min += g;\n            }\n            if (a[i].min_second != INT64_MAX) {\n                a[i].min_second += g;\n            }\n            a[i].lazy_add += g;\n            if (a[i].lazy_update != INT64_MAX) {\n                a[i].lazy_update += g;\n            }\n            a[i].sum += g * length;\n        } else if (TYPE == UPDATE) {\n            a[i].max = g;\n            a[i].max_second = INT64_MIN;\n            a[i].max_count = length;\n            a[i].min = g;\n            a[i].min_second = INT64_MAX;\n            a[i].min_count = length;\n            a[i].lazy_add = 0;\n            a[i].lazy_update = INT64_MAX;\n            a[i].sum = g * length;\n        } else {\n            assert (false);\n        }\n    }\n    void pushdown(int i) {\n        int l = 2 * i + 1;\n        int r = 2 * i + 2;\n        // update\n        if (a[i].lazy_update != INT64_MAX) {\n            tag<UPDATE>(l, a[i].lazy_update);\n            tag<UPDATE>(r, a[i].lazy_update);\n            a[i].lazy_update = INT64_MAX;\n            return;\n        }\n        // add\n        if (a[i].lazy_add != 0) {\n            tag<ADD>(l, a[i].lazy_add);\n            tag<ADD>(r, a[i].lazy_add);\n            a[i].lazy_add = 0;\n        }\n        // chmin\n        if (a[i].max < a[l].max) {\n            tag<CHMIN>(l, a[i].max);\n        }\n        if (a[i].max < a[r].max) {\n            tag<CHMIN>(r, a[i].max);\n        }\n        // chmax\n        if (a[l].min < a[i].min) {\n            tag<CHMAX>(l, a[i].min);\n        }\n        if (a[r].min < a[i].min) {\n            tag<CHMAX>(r, a[i].min);\n        }\n    }\n    void update(int i) {\n        int l = 2 * i + 1;\n        int r = 2 * i + 2;\n        // chmin\n        vector<int> b { a[l].max, a[l].max_second, a[r].max, a[r].max_second };\n        sort(b.rbegin(), b.rend());\n        uniq(b);\n        a[i].max = b[0];\n        a[i].max_second = b[1];\n        a[i].max_count = (b[0] == a[l].max ? a[l].max_count : 0) + (b[0] == a[r].max ? a[r].max_count : 0);\n        // chmax\n        vector<int> c { a[l].min, a[l].min_second, a[r].min, a[r].min_second };\n        sort(all(c));\n        uniq(c);\n        a[i].min = c[0];\n        a[i].min_second = c[1];\n        a[i].min_count = (c[0] == a[l].min ? a[l].min_count : 0) + (c[0] == a[r].min ? a[r].min_count : 0);\n        // add\n        a[i].lazy_add = 0;\n        // update\n        a[i].lazy_update = INT64_MAX;\n        // sum\n        a[i].sum = a[l].sum + a[r].sum;\n    }\n\n    template <char TYPE>\n    int range_get(int i, int il, int ir, int l, int r) {\n        if (ir <= l or r <= il) {\n            return TYPE == MIN ? INT64_MAX : 0;\n        } else if (l <= il and ir <= r) {\n            // base\n            switch (TYPE) {\n                case MIN: return a[i].min;\n                case MAX: return a[i].max;\n                case SUM: return a[i].sum;\n                default: assert (false);\n            }\n        } else {\n            pushdown(i);\n            int value_l = range_get<TYPE>(2 * i + 1, il, (il + ir) / 2, l, r);\n            int value_r = range_get<TYPE>(2 * i + 2, (il + ir) / 2, ir, l, r);\n            // mult\n            switch (TYPE) {\n                case MIN: return min(value_l, value_r);\n                case MAX: return max(value_l, value_r);\n                case SUM: return value_l + value_r;\n                default: assert (false);\n            }\n        }\n    }\n};\n\nsigned main(){\n    int n,q;\n    I(n); I(q);\n    segment_tree_beats sb(n);\n\n    REP(_,q){\n        int od,s,t,x;\n        I(od); I(s); I(t);\n        if (od == 0){\n            I(x);\n            sb.range_update(s,t+1,x);\n        } else {\n            printf(\"%lld\\n\", sb.range_sum(s,t+1));\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<queue>\n#define null NULL\nusing namespace std;\n/** 区间表示：[p->dl,p->dr]\n *  从0开始计数，[0,n-1]\n *  线段树RSQ\n *\n */\n\nstruct Node\n{\n    long long dl,dr,s,delta;\n    Node *pl,*pr;\n};\nint n,q;\n\nvoid build(Node *&p,int l,int r)\n{\n    p=(Node *)malloc(sizeof(Node));\n    p->dl=l,p->dr=r,p->s=0,p->delta=0;\n    p->pl=null,p->pr=null;\n    int mid=(l+r)/2;\n    if(r>l)\n    {\n        build(p->pl,l,mid);\n        build(p->pr,mid+1,r);\n    }\n}\n\nvoid preorder(Node *p)\n{\n    if(p!=null)\n    {\n        printf(\"%lld %lld %lld %lld\\n\",p->dl,p->dr,p->s,p->delta);\n        preorder(p->pl);\n        preorder(p->pr);\n    }\n}\n///在其他节点更新和查询的过程中都要向下延迟修改\nvoid pushdown(Node *&p,int delta)\n{\n    p->pl->s = p->delta*(p->pl->dr - p->pl->dl+1);\n    p->pr->s = p->delta*(p->pr->dr - p->pr->dl+1);\n    p->pl->delta = p->delta;\n    p->pr->delta = p->delta;\n    p->delta=0;\n}\n///当前区间的更新只更新到某些节点，下边节点的更新需要下次延迟修改\nvoid update(Node *&p,int l,int r,int data)\n{\n    ///[l,r]必然位于[p->dl,p->dr]子区间\n    ///当前节点的所有数据都是正确的！！\n    ///延迟修改-lazy-tag技术\n    ///此处下行的是之前的数据\n    if(p->delta!=0 && p->dr>p->dl)\n        pushdown(p,p->delta);\n\n    if(p->dl==l &&p->dr==r)\n    {\n        p->s=data*(r-l+1);\n        p->delta=data;\n        return ;\n    }\n    int mid=(p->dl+p->dr)/2;\n    if(r<=mid)\n        update(p->pl,l,r,data);\n    else if(l>mid)\n        update(p->pr,l,r,data);\n    else\n        update(p->pl,l,mid,data),update(p->pr,mid+1,r,data);\n    p->s=p->pl->s+p->pr->s;\n}\n///当前节点的所有数据都是正确的！！\n///即使不正确，在进入到这个之前也被pushdown过了,，所以一定是正确的\nlong long query(Node *&p,int l,int r)\n{\n    ///一个查询区间最终必然被分成若干个小的区间和，最后一个定会完全和区间贴合\n    if(p->delta!=0 && p->dr>p->dl)\n        pushdown(p,p->delta);\n\n    if(p->dl==l &&p->dr==r)\n        return p->s;\n    int mid=(p->dl+p->dr)/2;\n    ///判断查询区间与当前区间的位置关系\n    //全部位于左侧\n    if(r<=mid)\n        return query(p->pl,l,r);\n    //全部位于右侧\n    else if(l>mid)\n        return query(p->pr,l,r);\n    //两个都有\n    else\n        return query(p->pl,l,mid)+query(p->pr,mid+1,r);\n}\n\nint main()\n{\n    int i,type,tx,ty,x;\n    Node *tree=null;\n    scanf(\"%d%d\",&n,&q);\n    build(tree,0,n-1);\n    for(i=0;i<q;i++)\n    {\n        scanf(\"%d\",&type);\n        if(type==0)\n        {\n            scanf(\"%d%d%d\",&tx,&ty,&x);\n            update(tree,tx,ty,x);\n        }else\n        {\n            scanf(\"%d%d\",&tx,&ty);\n            long long ans=query(tree,tx,ty);\n            printf(\"%lld\\n\",ans);\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\ntypedef pair<LL, LL> pii;\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        sort(ALL((wpwpw)));(wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\nstruct LazySegmentTree {\n\tint n;\n\tvector<LL> node, lazy, flag;\npublic:\n\tLazySegmentTree(int sz, LL init) {\n\t\tn = 1;\n\t\twhile (n<sz)n *= 2;\n\t\tnode.resize(2 * n - 1, init);\n\t\tlazy.resize(2 * n - 1, INF<LL>());\n\t}\n\n\tvoid eval(int k, int l, int r) {\n\t\tif (lazy[k] != INF<LL>()) {\n\t\t\tnode[k] = lazy[k];\n\t\t\tif (r - l>1) {\n\t\t\t\tlazy[2 * k + 1] = lazy[k] / 2;\n\t\t\t\tlazy[2 * k + 2] = lazy[k] / 2;\n\t\t\t}\n\t\t}\n\t\tlazy[k] = INF<LL>();\n\t}\n\t//[a,b)にxを加算\n\tvoid update(int a, int b, LL x, int k = 0, int l = 0, int r = -1) {\n\t\tif (r<0)r = n;\n\t\teval(k, l, r);\n\t\tif (r <= a || b <= l)return;\n\t\tif (a <= l&&r <= b) {\n\t\t\tlazy[k] = x*(r - l);\n\t\t\teval(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tupdate(a, b, x, 2 * k + 1, l, (l + r) / 2);\n\t\t\tupdate(a, b, x, 2 * k + 2, (l + r) / 2, r);\n\t\t\tnode[k] = node[2 * k + 1] + node[2 * k + 2];\n\t\t}\n\t}\n\t//[a,b)での和を返す\n\tLL getsum(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif (r<0)r = n;\n\t\teval(k, l, r);\n\t\tif (r <= a || b <= l)return 0;\n\t\tif (a <= l&&r <= b)return node[k];\n\t\tLL xl = getsum(a, b, 2 * k + 1, l, (l + r) / 2);\n\t\tLL xr = getsum(a, b, 2 * k + 2, (l + r) / 2, r);\n\t\treturn xl + xr;\n\t}\n};\n\nint main() {\n\tint n, q;\n\tcin >> n >> q;\n\tLazySegmentTree sg(n, 0);\n\tREP(i, q) {\n\t\tint t; cin >> t;\n\t\tif (t) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\tb++;\n\t\t\tcout << sg.getsum(a, b) << endl;\n\t\t}\n\t\telse {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tsg.update(a, b + 1, c);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <tuple>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#define REP(i, n) for (int i = 0; i < (n); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) (int)(x).size()\nusing namespace std;\nusing ll = long long;\nconstexpr ll INF = 3000000000000000000;\n\ntemplate <typename Operator>\nstruct LazySegmentTree {\n    Operator OP;\n    using NodeType = decltype(OP.NodeE);\n    using FuncType = decltype(OP.FuncE);\n    int length, height;\n    vector<NodeType> node;\n    vector<FuncType> lazy;\n    vector<int> width;\n    LazySegmentTree(int n) {\n        length = 1;\n        height = 0;\n        while (length < n) {\n            length <<= 1;\n            ++height;\n        }\n        node.resize(length << 1, OP.NodeE);\n        lazy.resize(length << 1, OP.FuncE);\n        width.resize(length << 1, 1);\n        for (int i = length - 1; i > 0; --i) width[i] = width[i << 1] << 1;\n    }\n    LazySegmentTree(vector<NodeType> &vec) {\n        length = 1;\n        height = 0;\n        while (length < SZ(vec)) {\n            length <<= 1;\n            ++height;\n        }\n        node.resize(length << 1, OP.NodeE);\n        REP(i, SZ(vec)) node[i + length] = vec[i];\n        for (int i = length - 1; i > 0; --i) node[i] = OP.MergeNode(node[(i << 1) | 0], node[(i << 1) | 1]);\n        lazy.resize(length << 1, OP.FuncE);\n        width.resize(length << 1, 1);\n        for (int i = length - 1; i > 0; --i) width[i] = width[i << 1] << 1;\n    }\n    void eval(int n) {\n        node[n] = OP.NodeFunc(node[n], lazy[n], width[n]);\n        if (n < length) {\n            lazy[(n << 1) | 0] = OP.MergeFunc(lazy[(n << 1) | 0], lazy[n]);\n            lazy[(n << 1) | 1] = OP.MergeFunc(lazy[(n << 1) | 1], lazy[n]);\n        }\n        lazy[n] = OP.FuncE;\n    }\n    void update(int a, int b, FuncType x) {\n        int l = a + length, r = b + length - 1;\n        for (int i = height; i > 0; --i) {\n            eval(l >> i);\n            eval(r >> i);\n        }\n        ++r;\n        while (r > l) {\n            if (l & 1) {\n                lazy[l] = OP.MergeFunc(lazy[l], x);\n                eval(l);\n                ++l;\n            }\n            if (r & 1) {\n                --r;\n                lazy[r] = OP.MergeFunc(lazy[r], x);\n                eval(r);\n            }\n            l >>= 1; r >>= 1;\n        }\n        l = a + length; r = b + length - 1;\n        while (l >>= 1) node[l] = OP.MergeNode(OP.NodeFunc(node[(l << 1) | 0], lazy[(l << 1) | 0], width[(l << 1) | 0]), OP.NodeFunc(node[(l << 1) | 1], lazy[(l << 1) | 1], width[(l << 1) | 1]));\n        while (r >>= 1) node[r] = OP.MergeNode(OP.NodeFunc(node[(r << 1) | 0], lazy[(r << 1) | 0], width[(r << 1) | 0]), OP.NodeFunc(node[(r << 1) | 1], lazy[(r << 1) | 1], width[(r << 1) | 1]));\n    }\n    NodeType get(int a, int b) {\n        int l = a + length, r = b + length - 1;\n        for (int i = height; i >= 0; --i) {\n            eval(l >> i);\n            eval(r >> i);\n        }\n        ++r;\n        NodeType vl = OP.NodeE, vr = OP.NodeE;\n        while (l < r) {\n            if (l & 1) {\n                vl = OP.MergeNode(vl, OP.NodeFunc(node[l], lazy[l], width[l]));\n                ++l;\n            }\n            if (r & 1) {\n                --r;\n                vr = OP.MergeNode(OP.NodeFunc(node[r], lazy[r], width[r]), vr);\n            }\n            l >>= 1; r >>= 1;\n        }\n        return OP.MergeNode(vl, vr);\n    }\n};\n\nstruct hoge {\n    ll NodeE = 0;\n    ll FuncE = INF;\n    ll MergeNode(ll x, ll y) {\n        return x + y;\n    }\n    ll MergeFunc(ll x, ll y) {\n        if (y == INF) return x;\n        else return y;\n    }\n    ll NodeFunc(ll x, ll y, int len) {\n        if (y == INF) return x;\n        else return y * len;\n    }\n};\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    LazySegmentTree<hoge> LST(n);\n    REP(_, q) {\n        int num;\n        cin >> num;\n        if (!num) {\n            int s, t, x;\n            cin >> s >> t >> x;\n            ++t;\n            LST.update(s, t, x);\n        } else {\n            int s, t;\n            cin >> s >> t;\n            ++t;\n            cout << LST.get(s, t) << \"\\n\";\n        }\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define NDEBUG\n#define _CRT_SECURE_NO_WARNINGS\n#include <array>\n#include <cstddef>\n#include <cstdint>\n#include <cstdio>\n#include <limits>\n#include <memory>\n#include <string>\n#include <type_traits>\n\ntemplate <class Integral> class Rirange;\n\ntemplate <class Integral = std::size_t> class irange {\npublic:\n\tusing value_type = Integral;\n\tusing reference = value_type &;\n\tusing const_reference = const value_type &;\n\tclass irangeitr {\n\t\tfriend irange;\n\t\tvalue_type i;\n\t\tirangeitr(const value_type x) noexcept : i(x) {}\n\n\tpublic:\n\t\tvoid operator++() noexcept { ++i; }\n\t\tvalue_type &operator*() noexcept { return i; }\n\t\tconst_reference operator*() const noexcept { return i; }\n\t\tbool operator!=(const irangeitr &x) const noexcept { return i < x.i; }\n\t};\n\nprivate:\n\tconst value_type f, l;\n\npublic:\n\tirange(const value_type first, const value_type last) noexcept\n\t\t: f(first), l(last) {}\n\tirangeitr begin() const noexcept { return irangeitr(f); }\n\tirangeitr end() const noexcept { return irangeitr(l); }\n\tRirange<value_type> rev() const noexcept {\n\t\treturn Rirange<value_type>(l - 1, f - 1);\n\t}\n};\ntemplate <class Integral = std::size_t> class Rirange {\npublic:\n\tusing value_type = Integral;\n\tusing reference = value_type &;\n\tusing const_reference = const value_type &;\n\tclass Rirangeitr {\n\t\tfriend Rirange;\n\t\tvalue_type i;\n\t\tRirangeitr(const value_type x) noexcept : i(x) {}\n\n\tpublic:\n\t\tvoid operator++() noexcept { --i; }\n\t\treference operator*() noexcept { return i; }\n\t\tconst_reference operator*() const noexcept { return i; }\n\t\tbool operator!=(const Rirangeitr &x) const noexcept {\n\t\t\treturn (!~x.i && ~i) || x.i < i;\n\t\t}\n\t};\n\nprivate:\n\tconst value_type f, l;\n\npublic:\n\tRirange(const value_type x, const value_type y) noexcept : f(x), l(y) {}\n\tRirangeitr begin() const noexcept { return Rirangeitr(f); }\n\tRirangeitr end() const noexcept { return Rirangeitr(l); }\n\tirange<value_type> rev() const noexcept {\n\t\treturn irange<value_type>(l + 1, f + 1);\n\t}\n};\n\ntemplate <class T> bool maxi(T &a, const T &b) {\n\tif (b < a)\n\t\treturn 0;\n\ta = b;\n\treturn 1;\n}\ntemplate <class T> bool mini(T &a, const T &b) {\n\tif (a < b)\n\t\treturn 0;\n\ta = b;\n\treturn 1;\n}\ntemplate <class T> bool smaxi(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T> bool smini(T &a, const T &b) {\n\tif (b < a) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nstruct customIO {\n\tint c;\n\tbool f;\n\tstd::array<int, 30> buf;\n\tconst std::array<int, 10> itoc;\n\tstd::array<std::uint_least8_t, 256> ctoi_base;\n\tconst std::uint_least8_t *const ctoi;\n\tvoid get_c() { c = fgetc(stdin); }\n\tvoid put_c(int x) { fputc(x, stdout); }\n\tbool vacant() { return c == ' ' || c == '\\n'; }\n\toperator int() { return 0; }\n\n\texplicit customIO()\n\t\t: itoc({ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' }),\n\t\tctoi(std::addressof(ctoi_base[-static_cast<std::int_fast16_t>(\n\t\t\tstd::numeric_limits<char>::min())])) {\n\t\tfor (std::uint_least8_t i = 0; i < 10; ++i)\n\t\t\tctoi_base[static_cast<int>(\"0123456789\"[i]) -\n\t\t\tstatic_cast<std::int_fast16_t>(\n\t\t\t\tstd::numeric_limits<char>::min())] = i;\n\t}\n\t// in\n\n\tvoid cueing() {\n\t\twhile (get_c(), vacant())\n\t\t\t;\n\t}\n\ttemplate <class T>\n\tauto operator>>(T &d) ->\n\t\ttypename std::enable_if<std::is_signed<T>::value, customIO &>::type {\n\t\td = 0;\n\t\tf = 0;\n\t\tcueing();\n\t\tif (c == '-')\n\t\t\tf = 1, get_c();\n\t\tdo\n\t\t\td = d * 10 + ctoi[c];\n\t\twhile (get_c(), !vacant());\n\t\tif (f)\n\t\t\td = -d;\n\t\treturn *this;\n\t}\n\ttemplate <class T>\n\tauto operator>>(T &d) ->\n\t\ttypename std::enable_if<!std::is_signed<T>::value, customIO &>::type {\n\t\td = 0;\n\t\tcueing();\n\t\tdo\n\t\t\td = d * 10 + ctoi[c];\n\t\twhile (get_c(), !vacant());\n\t\treturn *this;\n\t}\n\tcustomIO &operator>>(char &d) {\n\t\tcueing();\n\t\td = c;\n\t\treturn *this;\n\t}\n\tcustomIO &operator>>(double &d) {\n\t\tscanf(\"%lf\", &d);\n\t\treturn *this;\n\t}\n\tcustomIO &operator>>(std::string &d) {\n\t\td.clear();\n\t\tcueing();\n\t\tdo\n\t\t\td.push_back(c);\n\t\twhile (get_c(), !vacant());\n\t\treturn *this;\n\t}\n\ttemplate <class T> T input() {\n\t\tT d;\n\t\t*this >> d;\n\t\treturn d;\n\t}\n\n\t// out\n\n\ttemplate <class T>\n\tauto operator<<(T d) ->\n\t\ttypename std::enable_if<std::is_signed<T>::value, customIO &>::type {\n\t\tc = 0;\n\t\tf = 0;\n\t\tif (d < static_cast<T>(0))\n\t\t\tf = 1, d = -d;\n\t\twhile (d)\n\t\t\tbuf[c++] = itoc[d % 10], d /= 10;\n\t\tif (!c)\n\t\t\tbuf[c++] = itoc[0];\n\t\tif (f)\n\t\t\tput_c('-');\n\t\twhile (c--)\n\t\t\tput_c(buf[c]);\n\t\treturn *this;\n\t}\n\ttemplate <class T>\n\tauto operator<<(T d) ->\n\t\ttypename std::enable_if<!std::is_signed<T>::value, customIO &>::type {\n\t\tc = 0;\n\t\twhile (d)\n\t\t\tbuf[c++] = itoc[d % 10], d /= 10;\n\t\tif (!c)\n\t\t\tbuf[c++] = itoc[0];\n\t\twhile (c--)\n\t\t\tput_c(buf[c]);\n\t\treturn *this;\n\t}\n\tcustomIO &operator<<(char d) {\n\t\tput_c(d);\n\t\treturn *this;\n\t}\n\tcustomIO &operator<<(double d) {\n\t\tprintf(\"%f\", d);\n\t\treturn *this;\n\t}\n\tcustomIO &operator<<(const std::string &d) {\n\t\tfor (const auto e : d)\n\t\t\tput_c(e);\n\t\treturn *this;\n\t}\n\tcustomIO &operator<<(const char *d) {\n\t\twhile (*d != '\\0')\n\t\t\tput_c(*(d++));\n\t\treturn *this;\n\t}\n\tvoid endl() { put_c('\\n'); }\n\tvoid space() { put_c(' '); }\n} IO;\n\nusing int32 = std::int_fast32_t;\nusing int64 = std::int_fast64_t;\nusing uint32 = std::uint_fast32_t;\nusing uint64 = std::uint_fast64_t;\nusing intl32 = std::int_least32_t;\nusing intl64 = std::int_least64_t;\nusing uintl32 = std::uint_least32_t;\nusing uintl64 = std::uint_least64_t;\n#include <cassert>\n#include <functional>\n#include <utility>\n#include <vector>\n\ntemplate <typename ValueMonoid, typename OperatorMonoid, class Modify>\nclass LazySegmentTree {\npublic:\n\tusing value_type = ValueMonoid;\n\tusing reference = value_type &;\n\tusing const_reference = const value_type &;\n\tusing operator_type = OperatorMonoid;\n\nprivate:\n\tusing container_type = std::vector<std::pair<value_type, operator_type>>;\n\npublic:\n\tusing size_type = typename container_type::size_type;\n\nprivate:\n\tconst Modify m;\n\tconst size_type size_, height, capacity;\n\tcontainer_type tree;\n\tstatic size_type getheight(const size_type &size) noexcept {\n\t\tsize_type ret = 0;\n\t\twhile (static_cast<size_type>(1) << ret < size)\n\t\t\t++ret;\n\t\treturn ret;\n\t}\n\tvalue_type reflect(const size_type &index) {\n\t\treturn m(tree[index].first, tree[index].second);\n\t}\n\tvoid recalc(const size_type &index) {\n\t\ttree[index].first = reflect(index << 1) + reflect(index << 1 | 1);\n\t}\n\tvoid assign(const size_type &index, const operator_type &data) {\n\t\ttree[index].second = tree[index].second + data;\n\t}\n\tvoid push(const size_type &index) {\n\t\tassign(index << 1, tree[index].second);\n\t\tassign(index << 1 | 1, tree[index].second);\n\t\ttree[index].second = operator_type();\n\t}\n\tvoid propagate(const size_type &index) {\n\t\tfor (size_type i = height; i; --i)\n\t\t\tpush(index >> i);\n\t}\n\tvoid thrust(const size_type &index) {\n\t\ttree[index].first = reflect(index);\n\t\tpush(index);\n\t}\n\tvoid evaluate(const size_type &index) {\n\t\tfor (size_type i = height; i; --i)\n\t\t\tthrust(index >> i);\n\t}\n\tvoid build(size_type index) {\n\t\twhile (index >>= 1)\n\t\t\trecalc(index);\n\t}\n\npublic:\n\texplicit LazySegmentTree(const size_type &size, const Modify &m = Modify())\n\t\t: m(m), size_(size), height(getheight(size_)),\n\t\tcapacity(static_cast<size_type>(1) << height), tree(capacity << 1) {}\n\tvoid update(size_type begin, size_type end, const operator_type &data) {\n\t\tassert(begin <= end);\n\t\tassert(begin <= size());\n\t\tassert(end <= size());\n\t\tbegin += capacity;\n\t\tend += capacity;\n\t\tpropagate(begin);\n\t\tpropagate(end - 1);\n\t\tfor (size_type left = begin, right = end; left < right;\n\t\t\tleft >>= 1, right >>= 1) {\n\t\t\tif (left & 1)\n\t\t\t\tassign(left++, data);\n\t\t\tif (right & 1)\n\t\t\t\tassign(right - 1, data);\n\t\t}\n\t\tbuild(begin);\n\t\tbuild(end - 1);\n\t}\n\tvoid update(size_type index,\n\t\tconst std::function<value_type(const_reference)> &f) {\n\t\tassert(index < size());\n\t\tindex += capacity;\n\t\tpropagate(index);\n\t\ttree[index].first = f(reflect(index));\n\t\ttree[index].second = operator_type();\n\t\tbuild(index);\n\t}\n\tvoid update(const size_type index, const_reference data) {\n\t\tassert(index < size());\n\t\tupdate(index, [&data](const_reference d) { return data; });\n\t}\n\tvalue_type range(size_type begin, size_type end) {\n\t\tassert(begin <= end);\n\t\tassert(begin <= size());\n\t\tassert(end <= size());\n\t\tbegin += capacity;\n\t\tend += capacity;\n\t\tevaluate(begin);\n\t\tevaluate(end - 1);\n\t\tvalue_type retL, retR;\n\t\tfor (; begin < end; begin >>= 1, end >>= 1) {\n\t\t\tif (begin & 1)\n\t\t\t\tretL = retL + reflect(begin++);\n\t\t\tif (end & 1)\n\t\t\t\tretR = reflect(end - 1) + retR;\n\t\t}\n\t\treturn retL + retR;\n\t}\n\tsize_type search(const std::function<bool(const_reference)> &b) {\n\t\tif (b(value_type()))\n\t\t\treturn 0;\n\t\tif (!b(reflect(1)))\n\t\t\treturn size() + 1;\n\t\tvalue_type acc;\n\t\tsize_type i = 1;\n\t\twhile (i < capacity) {\n\t\t\tthrust(i);\n\t\t\tif (!b(acc + reflect(i <<= 1)))\n\t\t\t\tacc = acc + reflect(i++);\n\t\t}\n\t\treturn i - capacity + 1;\n\t}\n\tconst_reference operator[](size_type index) {\n\t\tassert(index < size());\n\t\tindex += capacity;\n\t\tevaluate(index);\n\t\ttree[index].first = reflect(index);\n\t\ttree[index].second = operator_type();\n\t\treturn tree[index].first;\n\t}\n\tsize_type size() const noexcept { return size_; }\n\tbool empty() const noexcept { return !size_; }\n};\n\ntemplate <typename V, typename O, class F>\nLazySegmentTree<V, O, F>\nmake_Lazy(const typename LazySegmentTree<V, O, F>::size_type &size,\n\tconst F &f) {\n\treturn LazySegmentTree<V, O, F>(size, f);\n}\n#include <algorithm>\n#include <cstddef>\n#include <limits>\n#include <utility>\n\ntemplate <class T> struct Ass {\n\tusing value_type = T;\n\tvalue_type a;\n\tbool f;\n\tAss() : f(0) {}\n\texplicit Ass(const value_type &x) : a(x), f(1) {}\n\texplicit Ass(value_type &&x) : a(std::move(x)), f(1) {}\n\tAss operator+(const Ass &o) const { return o.f ? o : *this; }\n};\n\ntemplate <class T> struct Add {\n\tusing value_type = T;\n\tvalue_type a;\n\tAdd() : a(0) {}\n\texplicit Add(const value_type &x) : a(x) {}\n\texplicit Add(value_type &&x) : a(std::move(x)) {}\n\tAdd operator+(const Add &o) const { return Add(a + o.a); }\n};\n\ntemplate <class T> struct Mini {\n\tusing value_type = T;\n\tvalue_type a;\n\tMini() : a(std::numeric_limits<value_type>::max()) {}\n\texplicit Mini(const value_type &x) : a(x) {}\n\texplicit Mini(value_type &&x) : a(std::move(x)) {}\n\tMini operator+(const Mini &o) const { return Mini(std::min(a, o.a)); }\n\tMini operator*(const Ass<value_type> &o) const {\n\t\treturn o.f ? Mini(o.a) : *this;\n\t}\n\tMini operator*(const Add<value_type> &o) const { return Mini(a + o.a); }\n};\n\ntemplate <class T> struct Maxi {\n\tusing value_type = T;\n\tvalue_type a;\n\tMaxi() : a(std::numeric_limits<value_type>::min()) {}\n\texplicit Maxi(const value_type &x) : a(x) {}\n\texplicit Maxi(value_type &&x) : a(std::move(x)) {}\n\tMaxi operator+(const Maxi &o) const { return Maxi(std::max(a, o.a)); }\n\tMaxi operator*(const Ass<value_type> &o) const {\n\t\treturn o.f ? Maxi(o.a) : *this;\n\t}\n\tMaxi operator*(const Add<value_type> &o) const { return Maxi(a + o.a); }\n};\n\ntemplate <class T> struct Sum {\n\tusing value_type = T;\n\tusing size_type = std::size_t;\n\tvalue_type a;\n\tsize_type s;\n\tSum() : a(0), s(0) {}\n\texplicit Sum(const value_type &x, const size_type y) : a(x), s(y) {}\n\texplicit Sum(value_type &&x, const size_type y) : a(std::move(x)), s(y) {}\n\tSum operator+(const Sum &o) const { return Sum(a + o.a, s + o.s); }\n\tSum operator*(const Ass<value_type> &o) const {\n\t\treturn o.f ? Sum(o.a * s, s) : *this;\n\t}\n\tSum operator*(const Add<value_type> &o) const { return Sum(a + o.a * s, s); }\n};\n\ntemplate<class T,class U>\nstruct multi {\n\tT operator()(const T &x, const U &y)const {\n\t\treturn x*y;\n\t}\n};\nint main() {\n\tusing S = Sum<int64>;\n\tusing A = Ass<int64>;\n\tconst auto n = IO.input<uint32>();\n\tuint32 q;\n\tIO >> q;\n\tLazySegmentTree<S, A, multi<S, A>> T(n);\n\tfor (const auto i : irange<>(0, n))\n\t\tT.update(i, S(0, 1));\n\tuint32 c, s, t;\n\tint64 x;\n\twhile (q--) {\n\t\tIO >> c >> s >> t;\n\t\tif (c)\n\t\t\tIO << T.range(s, t + 1).a << '\\n';\n\t\telse\n\t\t\tIO >> x, T.update(s, t + 1, A(x));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T> int len(const T &v) { return v.size(); }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\ntemplate<typename LSTTrait> class LazySegTree {\n  using FoldMonoid = typename LSTTrait::FoldMonoid;\n  using ActionMonoid = typename LSTTrait::ActionMonoid;\n  using T = typename FoldMonoid::value_type;\n  using Q = typename ActionMonoid::value_type;\n\n  LSTTrait lstTrait; // apply :: (T, Q) -> T, pow :: (Q, int) -> Q\n  FoldMonoid foldM;\n  ActionMonoid actionM;\n  int size = 1;\n  vector<T> tree; // 1-indexed\n  vector<Q> lazy; // 1-indexed\n\n  void push(int i) {\n    stack<pair<int, int>> s;\n    for (int d = 1; i /= 2; d *= 2) s.emplace(i, d);\n    for (int x, d; s.size(); s.pop()) {\n      tie(x, d) = s.top();\n      update(x * 2, lazy[x], d);\n      update(x * 2 + 1, lazy[x], d);\n      lazy[x] = actionM.id();\n    }\n  }\n\n  void update(const int &i, const Q &x, const int &d) {\n    tree[i] = lstTrait.apply(tree[i], lstTrait.pow(x, d));\n    if (i < size) lazy[i] = actionM(lazy[i], x);\n  }\n\n  void build(int i) {\n    for (int d = 2; i /= 2; d *= 2) tree[i] = lstTrait.apply(foldM(tree[i * 2], tree[i * 2 + 1]), lstTrait.pow(lazy[i], d));\n  }\n\npublic:\n  LazySegTree(const int &n = 0) {\n    while (size < n) size *= 2;\n    tree.assign(size * 2, foldM.id());\n    lazy.assign(size, actionM.id());\n  }\n\n  LazySegTree(const int &n, const T &x) {\n    while (size < n) size *= 2;\n    tree.assign(size * 2, x);\n    lazy.assign(size, actionM.id());\n    for (int i = size - 1; i >= 1; i--) tree[i] = foldM(tree[i * 2], tree[i * 2 + 1]);\n  }\n\n  template<typename InputIterator> LazySegTree(InputIterator first, InputIterator last) {\n    int n = distance(first, last);\n    while (size < n) size *= 2;\n    tree.resize(size * 2, foldM.id());\n    lazy.assign(size, actionM.id());\n    copy(first, last, tree.begin() + size);\n    for (int i = size - 1; i >= 1; i--) tree[i] = foldM(tree[i * 2], tree[i * 2 + 1]);\n  }\n\n  void act(int l, int r, const Q &x) { // [l, r) += x\n    int l0 = l += size, r0 = r += size;\n    push(l0), push(r0 - 1);\n    for (int d = 1; l < r; l /= 2, r /= 2, d *= 2) {\n      if (l & 1) update(l++, x, d);\n      if (r & 1) update(--r, x, d);\n    }\n    build(l0), build(r0 - 1);\n  }\n\n  void update(int i, const T &x) {\n    push(i += size);\n    tree[i] = x;\n    while (i /= 2) tree[i] = foldM(tree[i * 2], tree[i * 2 + 1]);\n  }\n\n  T fold(int l, int r) { // [l, r)\n    T accl = foldM.id(), accr = foldM.id();\n    for (push(l += size), push((r += size) - 1); l < r; l /= 2, r /= 2) {\n      if (l & 1) accl = foldM(accl, tree[l++]);\n      if (r & 1) accr = foldM(tree[--r], accr);\n    }\n    return foldM(accl, accr);\n  }\n\n  T operator[](int i) { return push(i += size), tree[i]; }\n};\n\ntemplate<typename T> class RangeSumRangeUpdate {\n  struct trait {\n    struct FoldMonoid {\n      using value_type = T;\n      T id() { return T(); }\n      T operator()(const T &a, const T &b) { return a + b; }\n    };\n    struct ActionMonoid {\n      using value_type = pair<bool, T>;\n      pair<bool, T> id() { return {false, T()}; }\n      pair<bool, T> operator()(const pair<bool, T> &a, const pair<bool, T> &b) { return b.first ? b : a; }\n    };\n    T apply(const T &t, const pair<bool, T> &q) { return q.first ? q.second : t; }\n    pair<bool, T> pow(const pair<bool, T> &q, const int &d) { return {q.first, q.second * d}; }\n  };\n\n  LazySegTree<trait> lst;\n\npublic:\n  RangeSumRangeUpdate(const int &n = 0) : lst(n) {}\n  RangeSumRangeUpdate(const int &n, const T &x) : lst(n, x) {}\n  template<typename InputIterator> RangeSumRangeUpdate(InputIterator first, InputIterator last) : lst(first, last) {}\n  void update(const int &l, const int &r, const T &x) { lst.act(l, r, {true, x}); }\n  void update(const int &i, const T &x) { lst.update(i, x); }\n  T sum(const int &l, const int &r) { return lst.fold(l, r); }\n  T operator[](const int &i) { return lst[i]; }\n};\n\nmain {\n  int n, q;\n  cin >> n >> q;\n  RangeSumRangeUpdate<int> rsru(n, 0);\n  while (q--) {\n    int a, s, t;\n    cin >> a >> s >> t;\n    if (a) {\n      cout << rsru.sum(s, t + 1) << endl;\n    } else {\n      rsru.update(s, t + 1, in());\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing P = pair<ll, ll>;\nusing Graph = vector<vector<ll>>;\n#define rep(i, n) for(ll i=0;i<(ll)(n);i++)\n#define rep2(i, m, n) for(ll i=m;i<(ll)(n);i++)\n#define rrep(i, n, m) for(ll i=n;i>=(ll)(m);i--)\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nconst int ddx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst ll MOD = 1000000007;\nconst ll INF = 1000000000000000000L;\n#ifdef __DEBUG\n\n/**\n * For DEBUG\n * https://github.com/ta7uw/cpp-pyprint\n */\n#include \"cpp-pyprint/pyprint.h\"\n\n#endif\n\ntemplate<class Monoid, class Lazy>\nclass LazySegmentTree {\n\npublic:\n\n    /**\n     * @param N size\n     * @param initial_val initial value in `data`\n     * @param def identity element\n     * @param def_lazy identity element for `lazy`\n     * @param operation operation to merge `data`\n     * @param lazy_operation operation to update `data` using `lazy`\n     * @param lazy_updater operation to update `lazy`\n     * @param lazy_calc operation to calculate `lazy` value from length\n     */\n    LazySegmentTree(int N, Monoid initial_val, Monoid def, Lazy def_lazy,\n                    function<Monoid(Monoid, Monoid)> operation,\n                    function<Monoid(Monoid, Lazy)> lazy_operation,\n                    function<Lazy(Lazy, Lazy)> lazy_updater,\n                    function<Lazy(Lazy, ll)> lazy_calc)\n            : initial_val(initial_val), def(def), def_lazy(def_lazy), operation(operation),\n              lazy_operation(std::move(lazy_operation)), lazy_updater(std::move(lazy_updater)),\n              lazy_calc(std::move(lazy_calc)) {\n        n = 1;\n        while (n < N) {\n            n *= 2;\n        }\n        data = vector<Monoid>(2 * n - 1, initial_val);\n        lazy = vector<Monoid>(2 * n - 1, def_lazy);\n\n        for (int i = n - 2; i >= 0; i--) {\n            data[i] = operation(data[2 * i + 1], data[2 * i + 2]);\n        }\n    }\n\n    /**\n     * 区間更新 [a, b)\n     * O(logN)\n     */\n    void update(int a, int b, Lazy x) {\n        update(a, b, x, 0, 0, n);\n    }\n\n    /**\n     * 区間取得 [a, b)\n     * O(logN)\n     */\n    Monoid query(int a, int b) {\n        return query(a, b, 0, 0, n);\n    }\n\n    /**\n     * 添字でアクセス( 0-indexed )\n     */\n    Monoid operator[](int i) {\n        return data[i + n - 1];\n    }\n\nprivate:\n    int n;\n    vector<Monoid> data;\n    vector<Lazy> lazy;\n    Monoid initial_val;\n    Monoid def;\n    Lazy def_lazy;\n\n    // To merge data\n    function<Monoid(Monoid, Monoid)> operation;\n\n    // To update data using lazy\n    function<Monoid(Monoid, Lazy)> lazy_operation;\n\n    // To update lazy\n    function<Lazy(Lazy, Lazy)> lazy_updater;\n\n    // To calculate lazy value using length\n    function<Lazy(Lazy, ll)> lazy_calc;\n\n    void eval(int l, int r, int k) {\n        // 遅延伝播用の配列の値が初期値と同じかどうかを比較\n        if (lazy[k] == def_lazy) return;\n\n        if (r - l > 1) {\n            lazy[2 * k + 1] = lazy_updater(lazy[2 * k + 1], lazy[k]);\n            lazy[2 * k + 2] = lazy_updater(lazy[2 * k + 2], lazy[k]);\n        }\n\n        // k 番目ノードの値に対して遅延評価を行う\n        data[k] = lazy_operation(data[k], lazy_calc(lazy[k], r - l));\n\n        // 遅延伝播用の配列の値を初期値に戻す\n        lazy[k] = def_lazy;\n    }\n\n    Monoid update(int a, int b, Monoid x, int k, int l, int r) {\n        eval(l, r, k);\n        if (r <= a || b <= l) return data[k];\n        if (a <= l && r <= b) {\n            lazy[k] = lazy_updater(lazy[k], x);\n            return lazy_operation(data[k], lazy_calc(lazy[k], r - l));\n        }\n\n        return data[k] = operation(update(a, b, x, 2 * k + 1, l, (l + r) / 2),\n                                   update(a, b, x, 2 * k + 2, (l + r) / 2, r));\n    }\n\n    Monoid query(int a, int b, int k, int l, int r) {\n\n        // 交差しない\n        if (b <= l || r <= a) {\n            return def;\n        }\n        // 取得時に評価\n        eval(l, r, k);\n\n        // 区間 [a, b) に l, r が含まれる\n        if (a <= l && r <= b) {\n            return data[k];\n        }\n        // 左の子\n        Monoid vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n        // 右の子\n        Monoid vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n        return operation(vl, vr);\n    }\n};\n\nvoid Main() {\n    ll N, Q;\n    cin >> N >> Q;\n    LazySegmentTree<ll, ll> lazySegmentTree(N, 0, 0, -INF, [](ll a, ll b) { return a + b; },\n                                            [](ll a, ll b) { return b; },\n                                            [](ll a, ll b) { return b;},\n                                            [](ll a, ll b) { return a * b; });\n    rep(q, Q) {\n        int query;\n        cin >> query;\n        if (query) {\n            ll s, t;\n            cin >> s >> t;\n            ll ans = lazySegmentTree.query(s, t + 1);\n            cout << ans << '\\n';\n        } else {\n            ll s, t, x;\n            cin >> s >> t >> x;\n            lazySegmentTree.update(s, t + 1, x);\n        }\n    }\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    Main();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define REP(i, n) for (ll i = 0, max_i = (n); i < max_i; i++)\n#define REPI(i, a, b) for (ll i = (a), max_i = (b); i < max_i; i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define fi first\n#define se second\n#define pb push_back\n#define debug(x) cerr << #x << \": \" << (x) << endl\n#define debug2(x, y) cerr << #x << \": \" << (x) << \" \" << #y << \": \" << y << endl;\n#define int long long\nusing namespace std;\nusing II = pair<int, int>;\nusing VII = vector<II>;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VVVI = vector<VVI>;\ntemplate <class T = int> inline T in() { T x; cin >> x; return x; }\ntemplate <class T = int> inline bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate <class T = int> inline bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> ostream& operator<<(ostream &s, const vector<T>& d) { int n = d.size(); REP (i, n) s << d[i] << \" \"; return s; }\ntemplate <class T> ostream& operator<<(ostream &s, const vector<vector<T>>& dd) { for (vector<T> d: dd) s << d << endl; return s; }\nstruct Fast { Fast() { cin.tie(0); ios::sync_with_stdio(false); } } fast;\nconst int MOD = 1e9 + 7;\n\n// T0: 元の配列のモノイド\n// T1: T0に対する作用素モノイド\ntemplate <class T0, class T1>\nclass SegmentTree {\n  // k番目のノードにのlazyを伝搬\n  void eval(int k, int len) {\n    // u1が正確に単位元ならいらない\n    // if (lazy[k] == u1) return;\n    // len個分のlazy[k]を評価\n    node[k] = g(node[k], p(lazy[k], len));\n    if (k < N - 1) {\n      // 最下段でなければ下のlazyに伝搬\n      lazy[2 * k + 1] = f1(lazy[2 * k + 1], lazy[k]);\n      lazy[2 * k + 2] = f1(lazy[2 * k + 2], lazy[k]);\n    }\n    lazy[k] = u1;\n  }\n  // k番目のノード[l, r)について、[a, b)の範囲内にxを作用\n  void update(int a, int b, T1 x, int k, int l, int r) {\n    eval(k, r - l);\n    if (b <= l || r <= a) return;\n    if (a <= l && r <= b) {\n      lazy[k] = f1(lazy[k], x);\n      eval(k, r - l);\n    } else {\n      update(a, b, x, 2 * k + 1, l, (l + r) / 2);\n      update(a, b, x, 2 * k + 2, (l + r) / 2, r);\n      node[k] = f0(node[2 * k + 1], node[2 * k + 2]);\n    }\n  }\n  // k番目のノード[l, r)について、[a, b)のクエリを求める\n  T0 query(int a, int b, int k, int l, int r) {\n    if (r <= a || b <= l) return u0;\n    eval(k, r - l);\n    if (a <= l && r <= b) return node[k];\n    T0 vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n    T0 vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n    return f0(vl, vr);\n  }\npublic:\n  int N;\n  vector<T0> node;\n  vector<T1> lazy;\n  // T0上の演算、単位元\n  using F0 = function<T0(T0, T0)>;\n  F0 f0; T0 u0;\n  // T1上の演算、単位元\n  using F1 = function<T1(T1, T1)>;\n  F1 f1; T1 u1;\n  // 作用\n  using G = function<T0(T0, T1)>;\n  G g;\n  // 多数のt1(T1)に対するf1の合成\n  using P = function<T1(T1, int)>;\n  P p;\n  SegmentTree(const vector<T0>& a, F0 f0, T0 u0, F1 f1, T1 u1, G g, P p)\n  : f0(f0), u0(u0), f1(f1), u1(u1), g(g), p(p) {\n    int sz = a.size();\n    for (N = 1; N < sz; N *= 2);\n    node.resize(2 * N - 1);\n    lazy.resize(2 * N - 1, u1);\n    REP (i, sz) node[N - 1 + i] = a[i];\n    for (int i = N - 2; i >= 0; i--) node[i] = f0(node[2 * i + 1], node[2 * i + 2]);\n  }\n  // [a, b)にxを作用\n  void update(int a, int b, T1 x) {\n    update(a, b, x, 0, 0, N);\n  }\n  // [a, b)\n  T0 query(int a, int b) {\n    return query(a, b, 0, 0, N);\n  }\n};\n\nsigned main() {\n  // // Range Min Query & Range Update Query\n  // SegmentTree<int, int> seg(\n  //   VI(n, (1LL << 31) - 1),\n  //   [](int x, int y) { return min(x, y); }, 1e18,\n  //   [](int x, int y) { return y == 1e18 ? x : y; }, 1e18,\n  //   [](int x, int y) { return y == 1e18 ? x : y; },\n  //   [](int y, int len) { return y; }\n  // );\n\n  // // Range Sum Query & Range Add Query\n  // SegmentTree<int, int> seg(\n  //   VI(n, 0),\n  //   plus<int>(), 0,\n  //   plus<int>(), 0,\n  //   plus<int>(),\n  //   multiplies<int>()\n  // );\n\n  int n, q; cin >> n >> q;\n  // // Range Min Query & Range Add Query\n  // SegmentTree<int, int> seg(\n  //   VI(n, 0),\n  //   [](int x, int y) { return min(x, y); }, 1e18,\n  //   plus<int>(), 0,\n  //   plus<int>(),\n  //   [](int y, int len) { return y; }\n  // );\n\n  // Range Sum Query & Range Update Query\n  SegmentTree<int, int> seg(\n    VI(n),\n    plus<int>(), 0,\n    [](int x, int y) { return y == 1e18 ? x : y; }, 1e18,\n    [](int x, int y) { return y == 1e18 ? x : y; },\n    [](int y, int len) { return y == 1e18 ? 1e18 : y * len; }\n  );\n  while (q--) {\n    int z; cin >> z;\n    if (z == 0) {\n      int s, t, x; cin >> s >> t >> x;\n      seg.update(s, t + 1, x);\n    } else {\n      int s, t; cin >> s >> t;\n      cout << seg.query(s, t + 1) << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ln '\\n'\ntypedef long long ll;\ntypedef pair<long long, long long> pll;\n///////////////////////////////////////////////////////////////////////////\n\ntemplate<typename T, typename U, typename F, typename G, typename H>\nstruct LazySegmentTree {\n    T unitynode;\n    U unitylazy;\n    F f;\n    G g;\n    H h;\n    int N;\n    int height;\n    vector<T> node;\n    vector<U> lazy;\n\n    LazySegmentTree(F f, G g, H h, T unitynode, U unitylazy) : f(f), g(g), h(h), unitynode(unitynode), unitylazy(unitylazy) {}\n\n    void init(int sz) {\n        N = 1;\n        height = 0;\n        while (N < sz) {\n            N *= 2;\n            ++height;\n        }\n        node.assign(2*N,unitynode);\n        lazy.assign(2*N,unitylazy);\n    }\n\n    void set(int k, const T &val) {node[k+N] = val;}\n\n    void build() {\n        for (int i = N-1; i > 0; --i) {\n            node[i] = f(node[i<<1|0],node[i<<1|1]);\n        }\n    }\n\n    inline T reflect(int k) {\n        return lazy[k] == unitylazy ? node[k] : g(node[k],lazy[k]);\n    }\n\n    void eval(int k) {\n        if (lazy[k] == unitylazy) return;\n        if (k < N) {\n            lazy[k<<1|0] = h(lazy[k<<1|0],lazy[k]);\n            lazy[k<<1|1] = h(lazy[k<<1|1],lazy[k]);\n        }\n        node[k] = reflect(k);\n        lazy[k] = unitylazy;\n    }\n\n    inline void recalc(int k) {\n        while (k >>= 1) {\n            node[k] = f(reflect(k<<1|0),reflect(k<<1|1));\n        }\n    }\n\n    // [l,r) (0-indexed)\n    void update(int l, int r, U val) {\n        if (l >= r) return;\n        l += N; r += N-1;\n        for (int i = height; i > 0; --i) {\n            eval(l>>i);\n            eval(r>>i);\n        }\n        int a = l; int b = r++;\n        while (l < r) {\n            if (l & 1) lazy[l] = h(lazy[l],val), ++l;\n            if (r & 1) --r, lazy[r] = h(lazy[r],val);\n            l >>= 1; r >>= 1;\n        }\n        recalc(a);\n        recalc(b);\n    }\n\n    T get(int l, int r) {\n        if (l >= r) return unitynode;\n        l += N; r += N-1;\n        for (int i = height; i > 0; --i) {\n            eval(l>>i);\n            eval(r>>i);\n        }\n        ++r;\n        T vl = unitynode, vr = unitynode;\n        while (l < r) {\n            if (l & 1) vl = f(vl,reflect(l++));\n            if (r & 1) vr = f(reflect(--r),vr);\n            l >>= 1; r >>= 1;\n        }\n        return f(vl,vr);\n    }\n\n    T operator[](int x) {return reflect(x+N);}\n};\n\n/*\nexample\nauto f=[&](int a,int b){return max(a,b);};\nconst int id = -1e9;\nSegmentTree<int, decltype(f)> seg(f,id);\n*/\n\n////////////////////////////////////////////////////////////////////\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    int N,Q; cin >> N >> Q;\n\n    auto f=[](pll a, pll b) {return make_pair(a.first+b.first,a.second+b.second);};\n    auto g=[](pll a, ll b) {return make_pair(a.second*b,a.second);};\n    auto h=[](ll a, ll b) {return b;};\n    pll id1 = make_pair(0,0);\n    ll id2 = 1e9;\n    LazySegmentTree<pll, ll, decltype(f), decltype(g), decltype(h)> seg(f,g,h,id1,id2);\n    seg.init(N);\n    for (int i = 0; i < N; ++i) seg.set(i,make_pair(0,1));\n    seg.build();\n\n    while (Q--) {\n        int com; cin >> com;\n        if (com) {\n            int s,t; cin >> s >> t;\n            cout << seg.get(s,++t).first << ln;\n        } else {\n            ll s,t,x; cin >> s >> t >> x;\n            seg.update(s,++t,x);\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\nusing ll = long long;\nusing P = pair<ll, ll>;\nll GCD(ll a, ll b) { return b?GCD(b, a%b):a; }\nll LCM(ll a, ll b) { return a/GCD(a, b)*b; }\n\ntemplate <typename T, typename E>\nstruct LazeSegTree {\n    // 0-indexed\n    typedef function<T(T, T)> F;\n    typedef function<T(T, E)> G;\n    typedef function<E(E, E)> H;\n    int n, height;\n    F f;    // クエリ処理の関数\n    G g;    // 遅延伝搬を反映させる関数\n    H h;    // 遅延処理の更新を行う関数\n    T ti;   // クエリ処理の単位元\n    E ei;   // 遅延配列の単位元\n    vector<T> dat;\n    vector<E> laz;\n    LazeSegTree(){}\n    LazeSegTree(F f, G g, H h, T ti, E ei): \n        f(f), g(g), h(h), ti(ti), ei(ei) {}\n    \n    // 全体を初期化\n    void init(int n_) {\n        n = 1, height = 0;\n        while(n < n_) n <<= 1, ++height;\n        dat.assign(n<<1, ti);\n        laz.assign(n<<1, ei);\n    }\n\n    // 初期配列をセグ木の葉に\n    void build(const vector<T> &v) {\n        int n_ = v.size();\n        init(n_);\n        for(int i = 0; i < n_; ++i) dat[n+i] = v[i];\n        for(int i = n-1; i; --i) dat[i] = f(dat[(i<<1)|0], dat[(i<<1)|1]);\n    }\n\n    // 遅延伝搬の処理を行う\n    inline T reflect(int k) {\n        return laz[k] == ei ? dat[k] : g(dat[k], laz[k]);\n    }\n\n    // 遅延を子ノードに伝搬\n    inline void propagate(int k) {\n        if(laz[k] == ei) return;\n        laz[(k<<1)|0] = h(laz[(k<<1)|0], laz[k]);\n        laz[(k<<1)|1] = h(laz[(k<<1)|1], laz[k]);\n        dat[k] = reflect(k);\n        laz[k] = ei;\n    }\n\n    inline void thrust(int k) {\n        for(int i = height; i; --i) propagate(k>>i);\n        dat[k] = reflect(k);\n        laz[k] = ei;\n    }\n\n    // クエリ処理をマージ\n    inline void recalc(int k) {\n        while(k >>= 1) dat[k] = f(reflect((k<<1)|0), reflect((k<<1)|1));\n    }\n\n    void update(int a, int b, E x) {\n        if(a >= b) return;\n        thrust(a += n);\n        thrust(b += n-1);\n        for(int l = a, r = b+1; l < r; l >>= 1, r >>= 1) {\n            if(l&1) laz[l] = h(laz[l], x), l++;\n            if(r&1) --r, laz[r] = h(laz[r], x);\n        }\n        recalc(a);\n        recalc(b);\n    }\n\n    // buildをバラバラに行う\n    void set_val(int a, T x) {\n        thrust(a += n);\n        dat[a] = x; laz[a] = ei;\n        recalc(a);\n    }\n\n    T query(int a, int b) {\n        if(a >= b) return ti;\n        thrust(a += n);\n        thrust(b += n-1);\n        T vl = ti, vr = ti;\n        for(int l = a, r = b+1; l < r; l >>= 1, r >>= 1) {\n            if(l&1) vl = f(vl, reflect(l++));\n            if(r&1) vr = f(reflect(--r), vr);\n        }\n        return f(vl, vr);\n    }\n\n    template <typename C>\n    int find(int st, C &check, T &acc, int k, int l, int r) {\n        if(l+1 == r) {\n            acc = f(acc, reflect(k));\n            return check(acc) ? k-n : -1;\n        }\n        propagate(k);\n        int m = (l+r)>>1;\n        if(m <= st) return find(st, check, acc, (k<<1)|1, m, r);\n        if(st <= 1 && !check(f(acc, dat[k]))) {\n            acc = f(acc, dat[k]);\n            return -1;\n        }\n        int vl = find(st, check, acc, (k<<1)|0, l, m);\n        if(~vl) return vl;\n        return find(st, check, acc, (k<<1)|1, m, r);\n    }\n\n    template <typename C>\n    int find(int st, C &check) {\n        T acc = ti;\n        return find(st, check, acc, 1, 0, n);\n    }\n};\n\nint main() {\n    int n, q; cin >> n >> q;\n    auto f = [](P l, P r) { return P(l.first+r.first, l.second+r.second); };\n    auto g = [](P l, ll r) { return P(l.second*r, l.second); };\n    auto h = [](ll l, ll r) { return r; };\n\n    LazeSegTree<P, ll> lseg(f, g, h, P(0, 0), -1010);\n    lseg.build(vector<P>(n, P(0, 1)));\n\n    for(int i = 0; i < q; ++i) {\n        int c; cin >> c;\n        ll s, t, x;\n        if(c) {\n            cin >> s >> t;\n            cout << lseg.query(s, t+1).first << endl;\n        }else {\n            cin >> s >> t >> x;\n            lseg.update(s, t+1, x);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define repr(i, n) for (int i = (n)-1; i >= 0; i--)\nconstexpr char newl = '\\n';\n\nconstexpr int None = 1 << 30;\n\nconstexpr int h = 17;\nconstexpr int MaxN = 1 << h;\nint n, q;\n\nint dat[MaxN*2], laz[MaxN*2];\n\nvoid apply(int p, int x, int i) {\n  dat[p] = x << i;\n  laz[p] = x;\n}\n\nvoid flush(int p) {\n  repr(i, h) {\n    int q = p >> i+1;\n    if (laz[q] != None) {\n      apply(q<<1, laz[q], i);\n      apply(q<<1|1, laz[q], i);\n      laz[q] = None;\n    }\n  }\n}\n\nvoid build(int p) {\n  rep(i, h) {\n    int q = p >> i+1;\n    dat[q] = laz[q] != None ? laz[q] << i+1 : dat[q<<1] + dat[q<<1|1];\n  }\n}\n\nint main() {\n  cin >> n >> q;\n  fill(laz, laz+MaxN*2, None);\n  rep(_, q) {\n    int c, s, t; cin >> c >> s >> t;\n    if (c == 0) {\n      int x; cin >> x;\n      flush(s += MaxN); flush(t += MaxN);\n      int s0 = s, t0 = t, i;\n      for (i = 0, t++; s < t; s >>= 1, t >>= 1, i++) {\n        if (s&1) apply(s++, x, i);\n        if (t&1) apply(--t, x, i);\n      }\n      build(s0); build(t0);\n    } else {\n      flush(s += MaxN); flush(t += MaxN);\n      int res = 0;\n      for (t++; s < t; s >>= 1, t >>= 1) {\n        if (s&1) res += dat[s++];\n        if (t&1) res += dat[--t];\n      }\n      cout << res << newl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                  友利奈緒ぱわーでACしてくれ！！！！！！！！！！！！\n                  Charlotteまだ見てない人は見ような！！！！！！！\n\n                  ／　 /:／　　　　　　　　　　　 　 ＼:ヽ　＼\n  　　　　　　　 /　　／　　　　　　 　 　 　 　 　 　 　 ＼　　ヽ\n  　　　　　＼__L 彡　　　　　　　　　　　　　　　　　　　 ヽ　　',\n  　　　　　　　ﾌ /　　　/　　/　 /　　　,　　 　 　 　 ヽ　　', 　ｊ\n  　　　　　　　ﾚ　　　 /　　/ 　/　 　 　 　 　 　 　 　 ', 　ヽ　j\n  　　　 　 　 // 　 　 !　/_l＿/__ノ 　　{ ＼}　　　　 　 ',　　',/\n  　　　　　　i ﾊ 　 　 {　从j　ﾊ　i　　　 ',　 ト-､}　 i i　 }　　jj\n  　　　　　　( ﾊ　　　(　 川　ハ ﾊ　 !　 '　ﾊ　 ﾊ　j j　,' 　 八\n  　　　 ＜＿,ｨ∧　　　斗芹ﾃミxハ ﾊ　 ﾚ　} /__ﾚﾚ　/ 　 ∧ ＼　ﾉ\n  　　　 　 　 ∨　＼ 　ゝ　辷:ソ　　 　)　芹ﾚ心ヾレ′　/ ト--　´\n  　　　＼ｰ‐'　ﾉ　　 ＼ゝ　　　　　　 　 　 ゞ:_ソ \"/ 　／ 　ヽ\n  　　　　 　 フ　　　　i八 \" \"　　　,　　　　　　　ム彡　　　　＼\n  　　　　 　/　　/　　j　 ト　　　　　　 　 　 \" \"イト＜　 　 　 ＼＼\n  　　　　 /　　/　　　j　/／ヽ､ 　 ∩　　 　 イ　{ {　　￣ フフへ ＼＼\n  　　　　(　／　　　 ,/ / 　　i　＞――＜ニニニﾆ┐　 〃／: : ヽ　ヽヽ\n  　　　　／　　ィT´/ /┌―　￣￣ /::: , ,)　 　 　 〃／／: : : : : :}　ヽヽ)\n  　　　/ /　 ∧ヾi┌― { {￣　　　 ﾉ:::トﾟ<　 　 　 ∥//: : : : : : : : i　 ﾉ ﾉ\n  . 　　( 人　 {:ヽヾi∨　∧V　　　 /:::/　､ヽ　　　 ∥/: : : : : : : : : :}　/\n  　　　V　( ∧: :＼'∨　∧V　　 ﾉ:::/　 ∧ 〉＿__∥: : : : : :／: : : :ﾚ\n  　　 　 　 /∧: : : : ∨　∧V┬ｲ:::ﾉ　 〈 TT　|　|{{: : : : ／: : : : : ∧　　 ﾉ\n  　　　 　 (　ハ: : : : :∨'T∧Vi　i (　 　 V　!　!　{{: : ／ : : : : : : /　ｰ　ノ\n  　　　　　V　ハ: : : : :∨ﾍ∧V　i ゝゝ　 i／⌒＼{／ : : : : : : : /ｰ― ´\n  　　　　　 ∨　ヽ: : : : :∨ﾍ∧∨i　〉 〉 /　/二　 ): : : : : : : : :/\n\n          (https://seesaawiki.jp/asciiart/d/Charlotte より)\n*/\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long; using ull = unsigned long long;\n// #define int ll\n// #define DEBUG 42\ninline void nprint(){}\ntemplate <class Head, class... Tail>\ninline void nprint(Head &&head, Tail &&... tail) {\n    cout << head << endl;\n    nprint(move(tail)...);\n}\n#ifdef DEBUG\n  #define eprint(...) nprint(__VA_ARGS__)\n#else\n  #define eprint(...) if(0==1) cout << 1 << endl;\n#endif\n#define Yes(a) cout << (a ? \"Yes\" : \"No\") << endl\n#define YES(a) cout << (a ? \"YES\" : \"NO\") << endl\n#define POSSIBLE(a) cout << (a ? \"POSSIBLE\" : \"IMPOSSIBLE\") << endl\nusing cmp = complex<double>;\nusing vb = vector<bool>; using vvb = vector<vb>;\nusing vi = vector<int>; using vvi = vector<vi>;\nusing vl = vector<ll>; using vvl = vector<vl>;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<V<T>>;\n#define fi first\n#define se second\n#define maxs(x,y) (x=max(x,y))\n#define mins(x,y) (x=min(x,y))\nusing pii = pair<int,int>; using pll = pair<ll,ll>;\n#define FOR(i,a,b) for(ll i = (a); i < (ll)(b); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORS(i,a,b) FOR(i,a,b+1)\n#define REPS(i,n) REP(i,n+1)\n#define RFOR(i,a,b) for(ll i = (ll)(b)-1;i >= a;--i)\n#define RREP(i,n) RFOR(i,0,n)\n#define RREPS(i,n) RREP(i,n+1)\n#define RFORS(i,a,b) RFOR(i,a,b+1)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define PERM(c) sort(ALL(c)); for(bool cp = true;cp;cp = next_permutation(ALL(c)))\n#define eb(val) emplace_back(val)\nconst double PI = acos(-1), EPS = 1e-10;\nconstexpr ll MOD = 1E9+7;\nconstexpr int dx[] = {1,0,-1,0}; constexpr int dy[] = {0,1,0,-1};\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& p){\n  return s << \"(\" << p.first << \", \" << p.second << \")\";\n}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &st){\n  for(size_t i=0;i<st.size();++i) is >> st[i];\n  return is;\n}\ntemplate<class T> istream& operator>>(istream &is,vector<vector<T>> &st){\n  for(size_t i=0;i<st.size();++i) is >> st[i];\n  return is;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &st){\n  for(size_t i=0;i<st.size();++i){\n    if(i==st.size()-1) os << st[i];\n    else os << st[i] << \" \";\n  }\n  return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const vector<vector<T>> &st){\n  for(size_t i=0;i<st.size();++i){\n    os << st[i];\n    if(i!=st.size()-1) os << endl;\n  }\n  return os;\n}\ntemplate<typename T, typename E>\nstruct segment_tree{\n  typedef function<T(T,T)> F;\n  typedef function<T(T,E)> G;\n  typedef function<E(E,E)> H;\n  typedef function<E(E,int)> P;\n\n  vector<T> data;\n  vector<E> lazy;\n\n  F f;\n  G g;\n  H h;\n\n  int n;\n\n  T tid;\n  E eid;\n\n  P p;\n  segment_tree(int size, F f, G g, H h, T tid, E eid, P p=[](E a, int b){b=0;return a+b;}):f(f),g(g),h(h),tid(tid),eid(eid),p(p){\n    n = 1;\n    while(n<size) n<<=1;\n    data.assign(2*n-1,tid), lazy.assign(2*n-1,eid);\n  }\n  segment_tree(vector<T> v,F f, G g, H h, T tid, E eid, P p=[](E a, int b){b=0;return a+b;}):f(f),g(g),h(h),tid(tid),eid(eid),p(p){\n    int size = v.size();\n    n = 1;\n    while(n<size) n<<=1;\n    data.resize(2*n-1,tid);\n    assign(v);\n  }\n  void assign(vector<T> v){\n    assert((int)v.size()<=n);\n    for(size_t i=0;i<v.size();++i) data[i+n-1] = v[i];\n    for(int i=v.size();i<n;++i) data[i+n-1] = tid;\n    for(int i=n-2;i>=0;--i) data[i] = f(data[2*i+1],data[2*i+2]);\n    lazy.assign(2*n-1,eid);\n  }\n  inline void eval(int k, int len){\n    if(lazy[k]!=eid){\n      data[k] = g(data[k],p(lazy[k],len));\n      // k has children.\n      if(len > 1){\n        lazy[2*k+1] = h(lazy[2*k+1],lazy[k]);\n        lazy[2*k+2] = h(lazy[2*k+2],lazy[k]);\n      }\n      lazy[k] = eid;\n    }\n  }\n  void update(int i, E x){\n    update(i,i+1,x,0,0,n);\n  }\n  void update(int a,int b,E x){\n    update(a,b,x,0,0,n);\n  }\n  void update(int a, int b, E x,int k, int l, int r){\n    eval(k,r-l);\n\n    // [l,r) out of [a,b)\n    if(b<=l||r<=a) return;\n    // [l,r) in [a,b)\n    if(a<=l && r<=b){\n      lazy[k] = h(lazy[k],x);\n      eval(k,r-l);\n    }else{\n      update(a,b,x,2*k+1,l,(l+r)/2);\n      update(a,b,x,2*k+2,(l+r)/2,r);\n      data[k] = f(data[2*k+1],data[2*k+2]);\n    }\n  }\n  T find(int i){\n    return find(i,i+1,0,0,n);\n  }\n  // [a,b)\n  T find(int a,int b){\n    return find(a,b,0,0,n);\n  }\n  T find(int a,int b,int k,int l,int r){\n    eval(k,r-l);\n\n    // [l,r) out of [a,b)\n    if(r<=a||b<=l) return tid;\n\n    // [l,r) in [a,b)\n    if(a<=l&&r<=b) return data[k];\n\n    // else\n    return f(find(a,b,2*k+1,l,(l+r)/2),find(a,b,2*k+2,(l+r)/2,r));\n  }\n};\nstruct range_sum_query{\n  function<int(int,int)> updatef = [](int a, int b){return b!=1001?b:a;};\n  segment_tree<int,int> seg;\n  range_sum_query(int n):seg(n,plus<int>(),updatef,updatef,0,1001,multiplies<int>()){}\n\n  int getsum(int a, int b){\n    return seg.find(a,b);\n  }\n  void update(int s,int t, int x){\n    return seg.update(s,t,x);\n  }\n};\nsigned main(){\n  int n,q;\n  cin >> n >> q;\n  range_sum_query rsq(n);\n  for(int i=0;i<q;++i){\n    int com,s,t;\n    cin >> com >> s >> t;\n    if(com==0){\n      int x;cin >> x;\n      rsq.update(s,t+1,x);\n    }else{\n      cout << rsq.getsum(s,t+1) << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//BEGIN CUT HERE\ntemplate <typename T,typename E>\nstruct SegmentTree{\n  using F = function<T(T,T)>;\n  using G = function<T(T,E)>;\n  using H = function<E(E,E)>;\n  using P = function<E(E,size_t)>;\n  int n;\n  F f;\n  G g;\n  H h;\n  T ti;\n  E ei;\n  P p;\n  vector<T> dat;\n  vector<E> laz;\n  SegmentTree(int n_,F f,G g,H h,T ti,E ei,\n\t      P p=[](E a,size_t b){return a;}):\n    f(f),g(g),h(h),ti(ti),ei(ei),p(p){\n    init(n_);\n  }\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.assign(2*n-1,ti);\n    laz.assign(2*n-1,ei);\n  }\n  void build(int n_, vector<T> v){\n    for(int i=0;i<n_;i++) dat[i+n-1]=v[i];\n    for(int i=n-2;i>=0;i--)\n      dat[i]=f(dat[i*2+1],dat[i*2+2]);\n  }\n  inline void eval(int len,int k){\n    if(laz[k]==ei) return;\n    if(k*2+1<n*2-1){\n      laz[k*2+1]=h(laz[k*2+1],laz[k]);\n      laz[k*2+2]=h(laz[k*2+2],laz[k]);\n    }\n    dat[k]=g(dat[k],p(laz[k],len));\n    laz[k]=ei;\n  }\n  T update(int a,int b,E x,int k,int l,int r){\n    eval(r-l,k);\n    if(r<=a||b<=l) return dat[k];\n    if(a<=l&&r<=b){\n      laz[k]=h(laz[k],x);\n      return g(dat[k],p(laz[k],r-l));\n    }\n    return dat[k]=f(update(a,b,x,k*2+1,l,(l+r)/2),\n\t\t    update(a,b,x,k*2+2,(l+r)/2,r));\n  }\n  T update(int a,int b,E x){\n    return update(a,b,x,0,0,n);\n  }\n  T query(int a,int b,int k,int l,int r){\n    eval(r-l,k);\n    if(r<=a||b<=l) return ti;\n    if(a<=l&&r<=b) return dat[k];\n    T vl=query(a,b,k*2+1,l,(l+r)/2);\n    T vr=query(a,b,k*2+2,(l+r)/2,r);\n    return f(vl,vr);\n  }\n  T query(int a,int b){\n    return query(a,b,0,0,n);\n  }\n  void update(int k,T x){\n    query(k,k+1);//evaluate\n    k+=n-1;\n    dat[k]=x;\n    while(k){\n      k=(k-1)/2;\n      dat[k]=f(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n};\n//END CUT HERE\nsigned main(){\n  int n,q;\n  cin>>n>>q;\n  SegmentTree<int,int> ch(n,\n\t\t\t  [](int a,int b){return a+b;},\n\t\t\t  [](int a,int b){return b;},\n\t\t\t  [](int a,int b){return b;},\n\t\t\t  0,0,\n\t\t\t  [](int a,int b){return a*b;});\n  ch.build(n,vector<int>(n,0));\n  for(int i=0;i<q;i++){\n    int c,s,t,x;\n    cin>>c;\n    if(c){\n      cin>>s>>t;\n      cout<<ch.query(s-1,t)<<endl;\n    }else{\n      cin>>s>>t>>x;\n      ch.update(s-1,t,x);\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(n);++i)\n#define REP(i,n) FOR(i,0,n)\nusing namespace std;\nusing ll = int64_t;\nusing vecint = vector<int>;\nusing vecll = vector<ll>;\n\nsize_t ceil_pow2(size_t n) {\n  --n;\n  n |= n >> 1;\n  n |= n >> 2;\n  n |= n >> 4;\n  n |= n >> 8;\n  n |= n >> 16;\n  n |= n >> 32;\n  return n+1;\n}\n\nconstexpr int INF = 1000000000;\n\nclass SegmentTree {\n public:\n  SegmentTree(const size_t n)\n    : size(ceil_pow2(n)), data(2*size, INF), sum(2*size) {}\n  // [l, r)\n  void query_update(const size_t l, const size_t r, const int x) {\n    update_impl(1, 0, size, l, r, x);\n  }\n  int query_sum(const size_t l, const size_t r) const {\n    return sum_impl(1, 0, size, l, r);\n  }\n private:\n  void update_impl(const size_t idx, const size_t rngl, const size_t rngr,\n      const size_t l, const size_t r, const int x) {\n    if (r <= rngl || rngr <= l) return;\n    if (idx >= size) {\n      data[idx] = x;\n      sum[idx] = x;\n      return;\n    }\n    const auto mid = (rngl + rngr) / 2;\n    if (l <= rngl && rngr <= r) {\n      data[idx] = x;\n      sum[idx] = x * (rngr - rngl);\n    } else {\n      if (data[idx] != INF) {\n        update_impl(2*idx,   rngl, mid,  rngl, rngr, data[idx]);\n        update_impl(2*idx+1, mid,  rngr, rngl, rngr, data[idx]);\n      }\n      data[idx] = INF;\n      update_impl(2*idx,   rngl, mid,  l, r, x);\n      update_impl(2*idx+1, mid,  rngr, l, r, x);\n      sum[idx] = sum[2*idx] + sum[2*idx+1];\n    }\n  }\n  int sum_impl(const size_t idx, const size_t rngl, const size_t rngr,\n      const size_t l, const size_t r) const {\n    if (r <= rngl || rngr <= l) return 0;\n    if (idx >= size) return sum[idx];\n    const auto mid = (rngl + rngr) / 2;\n    if (data[idx] != INF) {\n      return data[idx] * (min(r, rngr) - max(l, rngl));\n    }\n    if (l <= rngl && rngr <= r) {\n      return sum[idx];\n    } else {\n      return sum_impl(2*idx,   rngl, mid,  l, r)\n        +    sum_impl(2*idx+1, mid,  rngr, l, r);\n    }\n  }\n  const size_t size;\n  vecint data;\n  vecint sum;\n};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n,q;\n  cin>>n>>q;\n  SegmentTree st(n);\n  st.query_update(0, n, 0);\n  REP(i,q) {\n    int a;\n    cin>>a;\n    if (a == 0) {\n      int s,t,x;\n      cin>>s>>t>>x;\n      st.query_update(s, t+1, x);\n    } else {\n      int s,t;\n      cin>>s>>t;\n      cout<<st.query_sum(s, t+1)<<endl;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n update(s,t,x): [s,t) をxに変更する。\n find(s,t): [s,t) の総和を出力する。\n */\n\nconst ll INIT = 0;\nconst ll NIL = LLONG_MAX;\nstruct SegTree {\n    int N;\n    ll init_v;\n    vector<ll> node, lazy;\n    \n    SegTree(int _N):init_v(INIT) {\n        N = 1;\n        while (N < _N) N *= 2;\n        node.resize(2 * N - 1, init_v);\n        lazy.resize(2 * N - 1, NIL);\n    }\n    SegTree(int _N, vector<ll>& a){\n        N = 1;\n        while (N < _N) N *= 2;\n        node.resize(2 * N - 1, init_v);\n        lazy.resize(2 * N - 1, NIL);\n        for(int i = 0; i < _N; i++){ node[i+N-1] = a[i]; }\n        build();\n    }\n    \n    ll merge(ll l,ll r){\n        return l + r;\n    }\n    void build(){ for(int k = N - 2; k >= 0; k--){ node[k] = node[2 * k + 1] + node[2 * k + 2];} }\n    \n    void lazy_evaluate(int k) {\n        if (lazy[k] == NIL) return;\n        node[k] = lazy[k];\n        if (k < N - 1) {\n            lazy[2 * k + 1] = lazy[k]/2;\n            lazy[2 * k + 2] = lazy[k]/2;\n        }\n        lazy[k] = NIL;\n    }\n    \n    /* [a,b) 引数の範囲に注意!! s~tまでを更新→update(s,t+1,~) */\n    ll update(int a, int b, ll x) { return update(a, b, 0, 0, N, x); }\n    ll update(int a, int b, int k, int l, int r, ll x) {\n        if (r <= a || b <= l) {\n            lazy_evaluate(k); // nodeの値を見るときは必ず遅延評価を更新する\n            return node[k]; // updateでは全体の中の最小を見つける必要があるため, [l,r)外になっても値を参照\n        }\n        if (a <= l && r <= b) {\n            lazy[k] = (r-l)*x;\n            lazy_evaluate(k);\n            return node[k];\n        }\n        else {\n            lazy_evaluate(k);\n            ll vl = update(a, b, 2 * k + 1, l, (l + r) / 2, x);\n            ll vr = update(a, b, 2 * k + 2, (l + r) / 2, r, x);\n            return node[k] = merge(vl,vr);\n        }\n    }\n    \n    /* [a,b) 引数の範囲に注意!! */\n    ll query(int a, int b) { return query(a, b, 0, 0, N); }\n    ll query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) return init_v;\n        if (a <= l && r <= b) {\n            lazy_evaluate(k);\n            return node[k];\n        }\n        else {\n            lazy_evaluate(k);\n            ll vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n            ll vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n            return merge(vl,vr);\n        }\n    }\n};\n\nint main(){\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    int n; cin >> n;\n    SegTree ST(n);\n    int q; cin >> q;\n    while(q--){\n        int com; cin >> com;\n        if(com == 0){\n            int s,t,x; cin >> s >> t >> x;\n            ST.update(s,t+1,x);\n        }else{\n            int s,t; cin >> s >> t;\n            cout << ST.query(s,t+1) << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma warning(disable : 4267) // \"int n = (unsigned)size\"\n\nusing vi = vector<int>; using vvi = vector<vi>; using vvvi = vector<vvi>;\nusing ll = long long int;\nusing vll = vector<ll>; using vvll = vector<vll>; using vvvll = vector<vvll>;\nusing vd = vector<double>; using vvd = vector<vd>; using vvvd = vector<vvd>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing cdouble = complex<double>;\n\nconst double eps = 1e-7;\nconst double INFD = numeric_limits<double>::infinity();\n#define Loop(i, n) for(int i = 0; i < int(n); i++)\n#define Loopll(i, n) for(ll i = 0; i < ll(n); i++)\n#define Loop1(i, n) for(int i = 1; i <= int(n); i++)\n#define Loopll1(i, n) for(ll i = 1; i <= ll(n); i++)\n#define Loopr(i, n) for(int i = int(n) - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = ll(n) - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = int(n); i >= 1; i--)\n#define Looprll1(i, n) for(ll i = ll(n); i >= 1; i--)\n#define Foreach(buf, container) for(auto buf : container)\n#define Loopdiag(i, j, h, w, sum) for(int i = ((sum) >= (h) ? (h) - 1 : (sum)), j = (sum) - i; i >= 0 && j < (w); i--, j++)\n#define Loopdiagr(i, j, h, w, sum) for(int j = ((sum) >= (w) ? (w) - 1 : (sum)), i = (sum) - j; j >= 0 && i < (h); j--, i++)\n#define Loopdiagsym(i, j, h, w, gap) for (int i = ((gap) >= 0 ? (gap) : 0), j = i - (gap); i < (h) && j < (w); i++, j++)\n#define Loopdiagsymr(i, j, h, w, gap) for (int i = ((gap) > (h) - (w) - 1 ? (h) - 1 : (w) - 1 + (gap)), j = i - (gap); i >= 0 && j >= 0; i--, j--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(ex_i, vector.size()) { cout << vector[ex_i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(ex_i, matrix.size()) { Loop(ex_j, matrix[ex_i].size()) { cout << matrix[ex_i][ex_j] << \" \"; } cout << endl; }\n#define quickio() ios::sync_with_stdio(false); cin.tie(0);\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\n#define Comp(type_t) bool operator<(const type_t &another) const\n#define fst first\n#define snd second\nbool nearlyeq(double x, double y) { return abs(x - y) < eps; }\nbool inrange(ll x, ll t) { return x >= 0 && x < t; }\nbool inrange(vll xs, ll t) { Foreach(x, xs) if (!(x >= 0 && x < t)) return false; return true; }\nint ceillog2(ll x) { int ret = 0;\tx--; while (x > 0) { ret++; x >>= 1; } return ret; }\nll rndf(double x) { return (ll)(x + (x >= 0 ? 0.5 : -0.5)); }\nll floorsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (m * m <= x ? 0 : -1); }\nll ceilsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (x <= m * m ? 0 : 1); }\nll rnddiv(ll a, ll b) { return (a / b + (a % b * 2 >= b ? 1 : 0)); }\nll ceildiv(ll a, ll b) { return (a / b + (a % b == 0 ? 0 : 1)); }\nll gcd(ll m, ll n) { if (n == 0) return m; else return gcd(n, m % n); }\nll lcm(ll m, ll n) { return m * n / gcd(m, n); }\n\n/*******************************************************/\n\ntemplate<class T>\nclass SegTree {\nprotected:\n\tint n, N; // n is the original size, while N is the extended size\n\tint base;\n\tvector<T> nodes;\n\tint left_of(int id) {\n\t\tif (id >= base) return -1;\n\t\telse return id * 2 + 1;\n\t}\n\tint right_of(int id) {\n\t\tif (id >= base) return -1;\n\t\telse return id * 2 + 2;\n\t}\n\tint parent_of(int id) {\n\t\tif (id == 0) return -1;\n\t\telse return (id - 1) >> 1;\n\t}\n\t// initially, (s, t, 0, N, 0, x, EXCEPTION);\n\tvoid update_rec(int s, int t, int l, int r, int id, ll x, ll v) {\n\t\tif (v == LLONG_MIN) {\n\t\t\tv = nodes[id].val;\n\t\t\tnodes[id].val = LLONG_MIN;\n\t\t}\n\t\tif (s == l && t == r) {\n\t\t\tif (x != LLONG_MIN) {\n\t\t\t\tnodes[id].val = x;\n\t\t\t\tnodes[id].sum = x * cover_size(id);\n\t\t\t}\n\t\t\telse if (v != LLONG_MIN) {\n\t\t\t\tnodes[id].val = v;\n\t\t\t\tnodes[id].sum = v * cover_size(id);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint m = (l + r) / 2;\n\t\t\tint id_l = left_of(id);\n\t\t\tint id_r = right_of(id);\n\t\t\tif (s < m && m < t) {\n\t\t\t\tupdate_rec(s, m, l, m, id_l, x, v);\n\t\t\t\tupdate_rec(m, t, m, r, id_r, x, v);\n\t\t\t}\n\t\t\telse if (s < m) {\n\t\t\t\tupdate_rec(s, t, l, m, id_l, x, v);\n\t\t\t\tif (v != LLONG_MIN) {\n\t\t\t\t\tnodes[id_r].val = v;\n\t\t\t\t\tnodes[id_r].sum = v * cover_size(id_r);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (m < t) {\n\t\t\t\tif (v != LLONG_MIN) {\n\t\t\t\t\tnodes[id_l].val = v;\n\t\t\t\t\tnodes[id_l].sum = v * cover_size(id_l);\n\t\t\t\t}\n\t\t\t\tupdate_rec(s, t, m, r, id_r, x, v);\n\t\t\t}\n\t\t\tnodes[id].val = LLONG_MIN;\n\t\t\tnodes[id].sum = nodes[id_l].sum + nodes[id_r].sum;\n\t\t}\n\t}\n\t// initially, (s, t, 0, N, 0, x, EXCEPTION);\n\tll solve_rec(int s, int t, int l, int r, int id, ll x, ll v) {\n\t\tif (s == l && t == r) {\n\t\t\treturn nodes[id].sum;\n\t\t}\n\t\telse {\n\t\t\tint m = (l + r) / 2;\n\t\t\tint id_l = left_of(id);\n\t\t\tint id_r = right_of(id);\n\t\t\tll v0 = 0, v1 = 0;\n\t\t\tif (s < m && m < t) {\n\t\t\t\tv0 = solve_rec(s, m, l, m, id_l, x, v);\n\t\t\t\tv1 = solve_rec(m, t, m, r, id_r, x, v);\n\t\t\t}\n\t\t\telse if (s < m) {\n\t\t\t\tv0 = solve_rec(s, t, l, m, id_l, x, v);\n\t\t\t}\n\t\t\telse if (m < t) {\n\t\t\t\tv1 = solve_rec(s, t, m, r, id_r, x, v);\n\t\t\t}\n\t\t\treturn v0 + v1;\n\t\t}\n\t}\npublic:\n\tSegTree(int n, T init) {\n\t\tSegTree::n = n;\n\t\tN = (int)pow(2, ceil(log2(n)));\n\t\tbase = N - 1;\n\t\tnodes = vector<T>(base + N, init);\n\t}\n\tint cover_size(int id) {\n\t\tint cnt = 1;\n\t\twhile (left_of(id) != -1) {\n\t\t\tid = left_of(id);\n\t\t\tcnt *= 2;\n\t\t}\n\t\tint l = id - base;\n\t\tint r = min(l + cnt, n);\n\t\treturn max(0, r - l);\n\t}\n\tvoid update(int s, int t, ll x) {\n\t\tupdate_rec(s, t, 0, N, 0, x, LLONG_MIN);\n\t}\n\tll solve(int s, int t) {\n\t\tupdate_rec(s, t, 0, N, 0, LLONG_MIN, LLONG_MIN);\n\t\treturn solve_rec(s, t, 0, N, 0, LLONG_MIN, LLONG_MIN);\n\t}\n};\n\nstruct val_t {\n\tll val;\n\tll sum;\n};\n\nint main() {\n\tint n; cin >> n;\n\tint q; cin >> q;\n\tSegTree<val_t> st(n, { 0, 0 });\n\tLoop(unused, q) {\n\t\tint op; cin >> op;\n\t\tint s, t; cin >> s >> t; t++;\n\t\tif (op == 0) {\n\t\t\tll x; cin >> x;\n\t\t\tst.update(s, t, x);\n\t\t}\n\t\telse {\n\t\t\tcout << st.solve(s, t) << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using treap = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n#define int long long\n#define REP(i, n) for (long long i = 0, max_i = (n); i < max_i; i++)\n#define REPI(i, a, b) for (long long i = (a), max_i = (b); i < max_i; i++)\n#define ALL(obj) begin(obj), end(obj)\n#define RALL(obj) rbegin(obj), rend(obj)\n#define fi first\n#define se second\nusing ii = pair<int, int>;\nvector<ii> dirs = {\n    {1, 0}, {0, 1}, {-1, 0}, {0, -1},  // 4方向\n    {1, 1}, {-1, 1}, {-1, -1}, {1, -1},  // 斜め\n    {0, 0},  // 自身\n};\ntemplate <class T> inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\ntemplate <class T> inline bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T, class S> vector<T> make_vec(size_t n, S x) { return vector<T>(n, x); }\ntemplate <class T, class... Ts> auto make_vec(size_t n, Ts... ts) { return vector<decltype(make_vec<T>(ts...))>(n, make_vec<T>(ts...)); }\n\n// debug\ntemplate <class T> ostream& operator<<(ostream& s, vector<T>& d) { REP (i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \" \"); return s; }\ntemplate <class T> ostream& operator<<(ostream& s, vector<vector<T>>& d) { REP (i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \"\\n\"); return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, pair<T, S>& p) { s << \"{\" << p.first << \", \" << p.second << \"}\"; return s; }\ntemplate <class T> ostream& operator<<(ostream& s, set<T> m) { for (auto it = m.begin(); it != m.end(); it++) { s << *it << (next(it) == m.end() ? \"\" : \"\\n\"); } return s; }\ntemplate <class T> ostream& operator<<(ostream& s, multiset<T> m) { for (auto it = m.begin(); it != m.end(); it++) { s << *it << (next(it) == m.end() ? \"\" : \"\\n\"); } return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, map<T, S> m) { for (auto it = m.begin(); it != m.end(); it++) { s << *it << (next(it) == m.end() ? \"\" : \"\\n\"); } return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, unordered_map<T, S> m) { for (auto it = m.begin(); it != m.end(); it++) { s << *it << (next(it) == m.end() ? \"\" : \"\\n\"); } return s; }\n#ifdef _MY_DEBUG\n    #define dump(...) cerr << \"/* \" << #__VA_ARGS__ << \" :[\" << __LINE__ << \":\" << __FUNCTION__ << \"]\" << endl, dump_func(__VA_ARGS__), cerr << \"*/\\n\\n\";\n#else\n    #define dump(...)\n    #define endl \"\\n\"\n#endif\nvoid dump_func() { cerr << endl; }\ntemplate <class Head, class... Tail> void dump_func(Head&& h, Tail&&... t) { cerr << h << (sizeof...(Tail) == 0 ? \"\" : \", \"), dump_func(forward<Tail>(t)...); }\n\nstruct Fast { Fast() { cin.tie(nullptr); ios::sync_with_stdio(false); } } fast;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr int MOD = 1000000007;\n// *************** TEMPLATE END *************** \n\n// T0: 元の配列のモノイド\n// T1: T0に対する作用素モノイド\ntemplate <class T0, class T1>\nclass BaseSegmentTree {\n    // k番目のノードにのlazyを伝搬\n    void eval(int k, int len) {\n        // 定数倍高速化\n        if (lazy[k] == u1) return;\n        // len個分のlazy[k]を評価\n        node[k] = g(node[k], p(lazy[k], len));\n        if (k < N - 1) {\n            // 最下段でなければ下のlazyに伝搬\n            lazy[2 * k + 1] = f1(lazy[2 * k + 1], lazy[k]);\n            lazy[2 * k + 2] = f1(lazy[2 * k + 2], lazy[k]);\n        }\n        lazy[k] = u1;\n    }\n    // k番目のノード[l, r)について、[a, b)の範囲内にxを作用\n    void update(int a, int b, T1 x, int k, int l, int r) {\n        eval(k, r - l);\n        if (b <= l || r <= a) return;\n        if (a <= l && r <= b) {\n            lazy[k] = f1(lazy[k], x);\n            eval(k, r - l);\n        } else {\n            update(a, b, x, 2 * k + 1, l, (l + r) / 2);\n            update(a, b, x, 2 * k + 2, (l + r) / 2, r);\n            node[k] = f0(node[2 * k + 1], node[2 * k + 2]);\n        }\n    }\n    // k番目のノード[l, r)について、[a, b)のクエリを求める\n    T0 query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) return u0;\n        eval(k, r - l);\n        if (a <= l && r <= b) return node[k];\n        T0 vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n        T0 vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n        return f0(vl, vr);\n    }\n\npublic:\n    int sz;  // 元の配列のサイズ\n    int N;\n    vector<T0> node;\n    vector<T1> lazy;\n    // T0上の演算、単位元\n    virtual T0 f0(T0, T0) = 0;\n    const T0 u0;\n    // T1上の演算、単位元\n    virtual T1 f1(T1, T1) = 0;\n    const T1 u1;\n    // T0に対するT1の作用\n    virtual T0 g(T0, T1) = 0;\n    // 多数のt1(T1)に対するf1の合成\n    virtual T1 p(T1, int) = 0;\n\n    BaseSegmentTree(T0 u0, T1 u1) : u0(u0), u1(u1) {}\n    void set_by_vector(const vector<T0>& a) {\n        sz = a.size();\n        for (N = 1; N < sz; N *= 2)\n            ;\n        node.resize(2 * N - 1, u0);\n        lazy.resize(2 * N - 1, u1);\n        for (int i = 0; i < sz; i++) node[N - 1 + i] = a[i];\n        for (int i = N - 2; i >= 0; i--) node[i] = f0(node[2 * i + 1], node[2 * i + 2]);\n    }\n    void set_by_unit(int n) {\n        sz = n;\n        for (N = 1; N < sz; N *= 2)\n            ;\n        node.resize(2 * N - 1, u0);\n        lazy.resize(2 * N - 1, u1);\n    }\n    // [a, b)にxを作用\n    void update(int a, int b, T1 x) {\n        assert(0 <= a && a < b && b <= sz);\n        update(a, b, x, 0, 0, N);\n    }\n    void update(int a, T1 x) { update(a, a + 1, x); }\n    // [a, b)\n    T0 query(int a, int b) { return query(a, b, 0, 0, N); }\n    T0 query(int a) { return query(a, a + 1); }\n};\n\ntemplate <class T0, class T1>\nstruct MinUpdateQuery : public BaseSegmentTree<T0, T1> {\n    using BaseSegmentTree<T0, T1>::BaseSegmentTree;\n    static constexpr T0 _u0 = numeric_limits<T0>::max();\n    static constexpr T1 _u1 = numeric_limits<T1>::min();\n    MinUpdateQuery() : MinUpdateQuery(_u0, _u1) {}\n    T0 f0(T0 x, T0 y) override { return min(x, y); }\n    T1 f1(T1 x, T1 y) override { return y == _u1 ? x : y; }\n    T0 g(T0 x, T1 y) override { return y == _u1 ? x : y; }\n    T1 p(T1 x, int len) override { return x; }\n};\n\ntemplate <class T0, class T1>\nstruct SumAddQuery : public BaseSegmentTree<T0, T1> {\n    using BaseSegmentTree<T0, T1>::BaseSegmentTree;\n    SumAddQuery() : SumAddQuery(0, 0) {}\n    T0 f0(T0 x, T0 y) override { return x + y; }\n    T1 f1(T1 x, T1 y) override { return x + y; }\n    T0 g(T0 x, T1 y) override { return x + y; }\n    T1 p(T1 x, int len) override { return x * len; }\n};\n\ntemplate <class T0, class T1>\nstruct MinAddQuery : public BaseSegmentTree<T0, T1> {\n    using BaseSegmentTree<T0, T1>::BaseSegmentTree;\n    static constexpr int _u0 = numeric_limits<T0>::max();\n    MinAddQuery() : MinAddQuery(_u0, 0) {}\n    T0 f0(T0 x, T0 y) override { return min(x, y); }\n    T1 f1(T1 x, T1 y) override { return x + y; }\n    T0 g(T0 x, T1 y) override { return x + y; }\n    T1 p(T1 x, int len) override { return x; }\n};\n\ntemplate <class T0, class T1>\nstruct SumUpdateQuery : public BaseSegmentTree<T0, T1> {\n    using BaseSegmentTree<T0, T1>::BaseSegmentTree;\n    static constexpr int _u1 = numeric_limits<T1>::min();\n    SumUpdateQuery() : SumUpdateQuery(0, _u1) {}\n    T0 f0(T0 x, T0 y) override { return x + y; }\n    T1 f1(T1 x, T1 y) override { return y == _u1 ? x : y; }\n    T0 g(T0 x, T1 y) override { return y == _u1 ? x : y; }\n    T1 p(T1 x, int len) override { return x == _u1 ? _u1 : x * len; }\n};\n\ntemplate <class T0>\nstruct SumAffineQuery : public BaseSegmentTree<T0, pair<T0, T0>> {\n    using T1 = pair<T0, T0>; // first * x + second\n    using BaseSegmentTree<T0, T1>::BaseSegmentTree;\n    static constexpr T1 _u1 = {1, 0};\n    SumAffineQuery() : SumAffineQuery(0, {1, 0}) {}  // TODO: _u1を使うとコンパイル通らない原因不明\n    T0 f0(T0 x, T0 y) override { return x + y; }\n    T1 f1(T1 x, T1 y) override { return {x.first * y.first, x.second * y.first + y.second}; }\n    T0 g(T0 x, T1 y) override { return y.first * x + y.second; }\n    T1 p(T1 x, int len) override { return {x.first, x.second * len}; }\n};\n\nvoid aoj_rmq_and_ruq() {\n    int n, Q; cin >> n >> Q;\n    MinUpdateQuery<int, int> seg;\n    seg.set_by_vector(vector<int>(n, (1LL << 31) - 1));\n    REP (q, Q) {\n        int c, s, t; cin >> c >> s >> t;\n        t++;\n        if (c == 0) {\n            int x; cin >> x;\n            seg.update(s, t, x);\n        } else {\n            cout << seg.query(s, t) << endl;\n        }\n    }\n}\nvoid aoj_rsq_and_raq() {\n    int n, Q; cin >> n >> Q;\n    SumAddQuery<int, int> seg;\n    seg.set_by_unit(n);\n    REP (q, Q) {\n        int c, s, t; cin >> c >> s >> t;\n        s--;\n        if (c == 0) {\n            int x; cin >> x;\n            seg.update(s, t, x);\n        } else {\n            cout << seg.query(s, t) << endl;\n        }\n    }\n}\nvoid aoj_rsq_and_raq2() {\n    int n, Q; cin >> n >> Q;\n    SumAffineQuery<int> seg;\n    seg.set_by_unit(n);\n    REP (q, Q) {\n        int c, s, t; cin >> c >> s >> t;\n        s--;\n        if (c == 0) {\n            int x; cin >> x;\n            seg.update(s, t, {1, x});\n        } else {\n            cout << seg.query(s, t) << endl;\n        }\n    }\n}\nvoid aoj_rmq_and_raq() {\n    int n, Q; cin >> n >> Q;\n    MinAddQuery<int, int> seg;\n    seg.set_by_vector(vector<int>(n));\n    REP (q, Q) {\n        int c, s, t; cin >> c >> s >> t;\n        t++;\n        if (c == 0) {\n            int x; cin >> x;\n            seg.update(s, t, x);\n        } else {\n            cout << seg.query(s, t) << endl;\n        }\n    }\n}\nvoid aoj_rsq_and_ruq() {\n    int n, Q; cin >> n >> Q;\n    SumUpdateQuery<int, int> seg;\n    seg.set_by_vector(vector<int>(n));\n    REP (q, Q) {\n        int c, s, t; cin >> c >> s >> t;\n        t++;\n        if (c == 0) {\n            int x; cin >> x;\n            seg.update(s, t, x);\n        } else {\n            cout << seg.query(s, t) << endl;\n        }\n    }\n}\nvoid aoj_rsq_and_ruq2() {\n    int n, Q; cin >> n >> Q;\n    SumAffineQuery<int> seg;\n    seg.set_by_unit(n);\n    REP (q, Q) {\n        int c, s, t; cin >> c >> s >> t;\n        t++;\n        if (c == 0) {\n            int x; cin >> x;\n            seg.update(s, t, {0, x});\n        } else {\n            cout << seg.query(s, t) << endl;\n        }\n    }\n}\n\nsigned main() {\n    // aoj_rmq_and_ruq();\n    // aoj_rsq_and_raq();\n    // aoj_rsq_and_raq2();\n    // aoj_rmq_and_raq();\n    // aoj_rsq_and_ruq();\n    aoj_rsq_and_ruq2();\n\n    // // Sum & Affine\n    // using T = mint;\n    // using Affine = pair<T, T>;\n    // SegmentTree<Affine, Affine> seg(\n    //   vector<Affine>(n),\n    //   [](Affine x, Affine y) { return Affine(x.first + y.first, x.second + y.second); }, Affine(0, 0),\n    //   [](Affine x, Affine y) { return Affine(x.first * y.first, x.second * y.first + y.second); }, Affine(1, 0),\n    //   [](Affine x, Affine y) { return Affine(x.first * y.first, x.second * y.first + y.second); },\n    //   [](Affine y, int len) { return Affine(y.first, y.second * len); }\n    // );\n    // // seg.update(i, j, {a, b}); // [i, j)にax + bを作用\n    // // seg.update(i, j, {0, a}); // update\n    // // seg.update(i, j, {1, a}); // 加算\n    // // seg.update(i, j, {a, 0}); // 倍\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b)*b; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T>& V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> >& Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T>& mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\ntemplate<typename T>vector<T> make_v(size_t a){return vector<T>(a);}\ntemplate<typename T,typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type fill_v(T &t,const V &v){t=v;}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type fill_v(T &t,const V &v){for(auto &e:t) fill_v(e,v);}\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\n/*\n 抽象化LazySegTree\n ref : https://ei1333.github.io/algorithm/segment-tree.html\n */\n\ntemplate< typename Monoid>\nstruct LazySegmentTree{\npublic:\n    using Type = typename Monoid::Type;\n    int sz; // Array size\n    \n    vector<Type> node;\n    vector<Type> lazy;\n    \n    LazySegmentTree(int n){\n        sz = 1;\n        while(sz < n) sz <<= 1;\n        node.assign(2*sz,Monoid::id());\n        lazy.assign(2*sz,Monoid::Nid());\n    }\n    void set(int k, const Type& val){ node[k + sz] = val; }\n    void build(){\n        for(int k = sz - 1; k > 0; k--) {\n            node[k] = Monoid::op1(node[2*k+0], node[2*k+1]);\n        }\n    }\n    \n    void lazy_update(int k, int len){\n        if(lazy[k] != Monoid::Nid()){\n            if(k < sz){\n                lazy[2 * k + 0] = Monoid::op3(lazy[2 * k + 0], lazy[k]);\n                lazy[2 * k + 1] = Monoid::op3(lazy[2 * k + 1], lazy[k]);\n            }\n            node[k] = Monoid::op2(node[k],Monoid::op4(lazy[k],len));\n            lazy[k] = Monoid::Nid();\n        }\n    }\n    inline Type update(int a,int b,const Type& val,int k,int l,int r){\n        lazy_update(k, r-l);\n        if(r <= a || b <= l){\n            return node[k];\n        }else if(a <= l && r <= b){\n            lazy[k] = Monoid::op3(lazy[k],val);\n            lazy_update(k, r-l);\n            return node[k];\n        }else{\n            return node[k] = Monoid::op1(\n                                         update(a, b, val, 2 * k + 0, l, (l+r)/2),\n                                         update(a, b, val, 2 * k + 1, (l+r)/2, r)\n                                         );\n        }\n    }\n    inline Type update(int a,int b,const Type& val){\n        return update(a,b,val,1,0,sz);\n    }\n    inline Type query(int a,int b,int k,int l,int r){\n        lazy_update(k, r - l);\n        if(r <= a || b <= l) {\n            return Monoid::Qid();\n        } else if(a <= l && r <= b) {\n            return node[k];\n        } else {\n            return Monoid::op1(\n                               query(a, b, 2 * k + 0, l, (l + r)/2),\n                               query(a, b, 2 * k + 1, (l + r)/2, r)\n                               );\n        }\n    }\n    inline Type query(int a,int b){\n        return query(a,b,1,0,sz);\n    }\n    Type operator[](int k){\n        return query(k,k+1);\n    }\n};\nstruct Monoid {\n    using Type = ll;/* Monoidに乗せる型 */\n    static Type id() { return  0; /* モノイドの初期値 */};\n    static Type Nid() { return LINF; /* 遅延評価時の初期値 */}\n    static Type Qid() { return  0; /* 範囲外クエリ処理時の値 */}\n    \n    // ================================================ //\n    //                              マージ処理                               //\n    // ================================================ //\n    \n    // 要素と要素のマージ\n    static Type op1(const Type&l, const Type &r) {\n        Type ret;\n        ret = l + r;\n        return ret;\n    }\n    \n    // 要素と作用素のマージ\n    static Type op2(const Type&l, const Type &r) {\n        Type ret;\n        ret = r;\n        return ret;\n    }\n    \n    // 作用素と作用素のマージ\n    static Type op3(const Type&l, const Type &r) {\n        Type ret;\n        ret = r;\n        return ret;\n    }\n    \n    // 作用素を下に降ろす時に行う演算\n    // (第一引数は作用素のもとの値, 第二引数は降ろした後の区間の長さ)\n    static Type op4(const Type&l, const int &r) {\n        Type ret;\n        ret = l * r; // sum : 区間の長さ分だけ乗算\n        return ret;\n    }\n};\n\ntemplate<class Type>\nType solve(Type res = Type()){\n    int n,q; cin >> n >> q;\n    LazySegmentTree<Monoid> LST(n);\n    while(q--){\n        int com; cin >> com;\n        if(com == 0){\n            int s,t,x; cin >> s >> t >> x;\n            LST.update(s,t+1,x);\n        }else{\n            int s,t; cin >> s >> t;\n            cout << LST.query(s,t+1) << endl;\n        }\n    }\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    solve(0);\n    // cout << fixed << setprecision(15) << solve<ll>() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define NDEBUG\n#include <cassert>\n#include <stdexcept>\n#include <utility>\n\ntemplate <class ValueMonoid, class OperatorMonoid, class Modifier,\n\ttemplate <class> class Container>\nclass lazy_segment_tree {\npublic:\n\tusing value_structure = ValueMonoid;\n\tusing value_type = typename value_structure::value_type;\n\tusing const_reference = const value_type &;\n\tusing operator_structure = OperatorMonoid;\n\tusing operator_type = typename operator_structure::value_type;\n\tusing modifier_type = Modifier;\n\tusing container_type = Container<::std::pair<value_type, operator_type>>;\n\tusing size_type = typename container_type::size_type;\n\nprivate:\n\tsize_type size_, height;\n\tcontainer_type c;\n\tstatic size_type getheight(const size_type size) noexcept {\n\t\tsize_type ret = 0;\n\t\twhile (static_cast<size_type>(1) << ret < size)\n\t\t\t++ret;\n\t\treturn ret;\n\t}\n\tstatic value_type reflect(typename container_type::const_reference element) {\n\t\treturn modifier_type::operation(element.first, element.second);\n\t}\n\tvoid recalc(const size_type index) {\n\t\tc[index].first = value_structure::operation(reflect(c[index << 1]),\n\t\t\treflect(c[index << 1 | 1]));\n\t}\n\tstatic void assign(operator_type &element, const operator_type &data) {\n\t\telement = operator_structure::operation(element, data);\n\t}\n\tvoid push(const size_type index) {\n\t\tassign(c[index << 1].second, c[index].second);\n\t\tassign(c[index << 1 | 1].second, c[index].second);\n\t\tc[index].second = operator_structure::identity();\n\t}\n\tvoid propagate(const size_type index) {\n\t\tfor (size_type i = height; i; --i)\n\t\t\tpush(index >> i);\n\t}\n\tvoid thrust(const size_type index) {\n\t\tc[index].first = reflect(c[index]);\n\t\tpush(index);\n\t}\n\tvoid evaluate(const size_type index) {\n\t\tfor (size_type i = height; i; --i)\n\t\t\tthrust(index >> i);\n\t}\n\tvoid build(size_type index) {\n\t\twhile (index >>= 1)\n\t\t\trecalc(index);\n\t}\n\tsize_type base_size() const { return static_cast<size_type>(1) << height; }\n\npublic:\n\tlazy_segment_tree() : size_(0), height(0), c() {}\n\texplicit lazy_segment_tree(const size_type size)\n\t\t: size_(size), height(getheight(size_)),\n\t\tc(static_cast<size_type>(1) << (height + 1),\n\t\t{ value_structure::identity(), operator_structure::identity() }) {}\n\n\tbool empty() const { return !size_; }\n\tsize_type size() const { return size_; }\n\n\tconst_reference operator[](size_type index) {\n\t\tassert(index < size());\n\t\tindex += base_size();\n\t\tevaluate(index);\n\t\tc[index].first = reflect(c[index]);\n\t\tc[index].second = operator_structure::identity();\n\t\treturn c[index].first;\n\t}\n\tconst_reference at(size_type index) {\n\t\tif (index < size()) {\n\t\t\tthrow ::std::out_of_range(\"index out of range\");\n\t\t}\n\t\telse {\n\t\t\tindex += base_size();\n\t\t\tevaluate(index);\n\t\t\tc[index].first = reflect(c[index]);\n\t\t\tc[index].second = operator_structure::identity();\n\t\t\treturn c[index].first;\n\t\t}\n\t}\n\tvalue_type fold(size_type first, size_type last) {\n\t\tassert(first <= last);\n\t\tassert(first <= size());\n\t\tassert(last <= size());\n\t\tfirst += base_size();\n\t\tlast += base_size();\n\t\tevaluate(first);\n\t\tevaluate(last - 1);\n\t\tvalue_type retL = value_structure::identity(),\n\t\t\tretR = value_structure::identity();\n\t\tfor (; first < last; first >>= 1, last >>= 1) {\n\t\t\tif (first & 1)\n\t\t\t\tretL = value_structure::operation(retL, reflect(c[first++]));\n\t\t\tif (last & 1)\n\t\t\t\tretR = value_structure::operation(reflect(c[last - 1]), retR);\n\t\t}\n\t\treturn value_structure::operation(retL, retR);\n\t}\n\ttemplate <class F> size_type search(const F &f) {\n\t\tif (f(value_structure::identity()))\n\t\t\treturn static_cast<size_type>(0);\n\t\tif (!f(reflect(c[1])))\n\t\t\treturn size() + 1;\n\t\tvalue_type acc = value_structure::identity();\n\t\tsize_type i = 1;\n\t\twhile (i < base_size()) {\n\t\t\tthrust(i);\n\t\t\tif (!f(value_structure::operation(acc, reflect(c[i <<= 1]))))\n\t\t\t\tacc = value_structure::operation(acc, reflect(c[i++]));\n\t\t}\n\t\treturn i - base_size() + 1;\n\t}\n\n\tvoid update(const size_type index, const value_type &data) {\n\t\tassert(index < size());\n\t\tindex += base_size();\n\t\tpropagate(index);\n\t\tc[index].first = data;\n\t\tc[index].second = operator_structure::identity();\n\t\tbuild(index);\n\t}\n\tvoid update(size_type first, size_type last, const operator_type &data) {\n\t\tassert(first <= last);\n\t\tassert(first <= size());\n\t\tassert(last <= size());\n\t\tfirst += base_size();\n\t\tlast += base_size();\n\t\tpropagate(first);\n\t\tpropagate(last - 1);\n\t\tfor (size_type left = first, right = last; left < right;\n\t\t\tleft >>= 1, right >>= 1) {\n\t\t\tif (left & 1)\n\t\t\t\tassign(c[left++].second, data);\n\t\t\tif (right & 1)\n\t\t\t\tassign(c[right - 1].second, data);\n\t\t}\n\t\tbuild(first);\n\t\tbuild(last - 1);\n\t}\n};\n\n#include <cstddef>\n#include <utility>\ntemplate <class T, class Size = ::std::size_t> class sum_monoid {\npublic:\n\tusing size_type = Size;\n\tusing value_type = ::std::pair<T, size_type>;\n\tstatic T get(const value_type &x) { return x.first; }\n\tstatic value_type operation(const value_type &x, const value_type &y) {\n\t\treturn value_type(x.first + y.first, x.second + y.second);\n\t}\n\tstatic value_type identity() { return value_type(T(0), size_type(0)); }\n\tstatic value_type reverse(const value_type &x) { return x; }\n};\n\n#include <type_traits>\n#include <utility>\ntemplate <class T> class optional {\npublic:\n\tusing value_type = T;\n\nprivate:\n\ttypename ::std::aligned_storage<sizeof(value_type), alignof(value_type)>::type\n\t\tstorage;\n\tbool hasv;\n\tvalue_type *data() {\n\t\treturn static_cast<value_type *>(static_cast<void *>(&storage));\n\t}\n\tconst value_type *data() const {\n\t\treturn static_cast<const value_type *>(static_cast<const void *>(&storage));\n\t}\n\npublic:\n\toptional() : hasv(0) {}\n\ttemplate <class... Args> explicit optional(Args &&... args) : hasv(1) {\n\t\t::new (data()) value_type(::std::forward<Args>(args)...);\n\t}\n\tvoid reset() {\n\t\thasv = 0;\n\t\tdata()->~value_type();\n\t}\n\tvalue_type &operator*() & { return *data(); }\n\tconst value_type &operator*() const & { return *data(); }\n\tvalue_type &&operator*() && { return *data(); }\n\tconst value_type &&operator*() const && { return *data(); }\n\tvalue_type *operator->() { return data(); }\n\tconst value_type *operator->() const { return data(); }\n\texplicit operator bool() const { return hasv; }\n\tbool has_value() const { return hasv; }\n\tvalue_type &value() & { return *data(); }\n\tconst value_type &value() const & { return *data(); }\n\tvalue_type &&value() && { return *data(); }\n\tconst value_type &&value() const && { return *data(); }\n\ttemplate <class U> value_type value_or(U &&v) const & {\n\t\treturn has_value() ? value() : static_cast<T>(::std::forward<U>(v));\n\t}\n\ttemplate <class U> value_type value_or(U &&v) && {\n\t\treturn has_value() ? value() : static_cast<T>(::std::forward<U>(v));\n\t}\n};\ntemplate <class T> class assign_monoid {\npublic:\n\tusing value_type = optional<T>;\n\tstatic value_type operation(const value_type &x, const value_type &y) {\n\t\treturn y ? y : x;\n\t}\n\tstatic value_type identity() { return value_type(); }\n};\n\n#include <utility>\ntemplate <class T, class S> class sum_assignment {\npublic:\n\tstatic ::std::pair<T, S> operation(const ::std::pair<T, S> &x, const T &y) {\n\t\treturn y ? ::std::pair<T, S>(y.first * x.second, x.second) : x;\n\t}\n};\n\n\n#include <cstdio>\n#include <vector>\n\ntemplate<class T> using vec_alias = ::std::vector<T>;\n\nint main() {\n\tusing uint = unsigned int;\n\tusing sum = sum_monoid<int>;\n\n\tuint n, q;\n\tscanf(\"%u%u\", &n, &q);\n\n\tlazy_segment_tree<\n\t\tsum,\n\t\tassign_monoid<int>,\n\t\tsum_assignment<sum::value_type,sum::size_type>,\n\t\tvec_alias> seg(n);\n\n\tuint c, s, t;\n\tint x;\n\twhile (q--) {\n\t\tscanf(\"%u%u%u\", &c, &s, &t);\n\n\t\tif (c) {\n\t\t\tprintf(\"%d\\n\", seg.fold(s, t + 1).first);\n\t\t}\n\t\telse {\n\t\t\tscanf(\"%d\", &x);\n\t\t\tseg.update(s, t + 1, optional<int>(x));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// 区間更新、区間和取得\n// https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/2/DSL_2_I\n\n\n#include <stdio.h>\n#include <string>\n#include <cstring>\n#include <stdlib.h>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <iterator>\n#include <assert.h>\n#pragma warning(disable:4996) \n \ntypedef long long ll;\n#define MIN(a, b) ((a)>(b)? (b): (a))\n#define MAX(a, b) ((a)<(b)? (b): (a))\n#define LINF 9223300000000000000\n#define INF 2140000000\nconst long long MOD = 1000000007;\nusing namespace std;\n\n\n\nconst long long INF2 = (((ll)1<<31)-1);\n\ntemplate<class T> class SegTree   // 0-indexed\n{\nprivate:\n    int n;             // 葉の数\n    vector<T> data;    // ノードの値を持つ配列\n    vector<T> lazy;    // 遅延評価を持つ配列\n    vector<bool> lazyflag;  // 遅延評価すべきか\n\n    T def0;               // 初期値\n    T def;                // 単位元\n    \n    T operation(T a, T b)    // 区間クエリで使う処理\n    {\n        //return min(a, b);   // 区間minクエリ\n        return a+b;           // 区間和クエリ\n    }\n\n    void eval( int k, int l, int r )   // ノードkについて遅延評価を行う\n    {\n        if(lazyflag[k]) {\n            data[k] = lazy[k]*(r-l);\n            if(r - l > 1) {\n                lazy[2*k+1] = lazy[2*k+2]= lazy[k];\n                lazyflag[2*k+1] = lazyflag[2*k+2] = true;   \n            }\n            lazy[k] = 0;\n            lazyflag[k]=false;\n        }\n        return;\n    }\n\n    void _add(int a, int b, T x, int k, int l, int r) {\n        if(r < 0) r = n;\n        eval(k, l, r);   // k 番目のノードに対して遅延評価を行う\n        \n        if(b <= l || r <= a) return;   // 範囲外なら何もしない\n    \n        // 完全に被覆しているならば、遅延配列に値を入れた後に評価\n        if(a <= l && r <= b) {\n            lazy[k] = x;\n            lazyflag[k] = true;\n            eval(k, l, r);\n        }\n\n        // そうでないならば、子ノードの値を再帰的に計算して、\n        // 計算済みの値をもらってくる\n        else {\n            _add(a, b, x, 2*k+1, l, (l+r)/2);\n            _add(a, b, x, 2*k+2, (l+r)/2, r);\n            data[k] = operation(data[2*k+1], data[2*k+2]);\n        }\n    }\n\n    // 区間[a,b)の総和。ノードk=[l,r)に着目している。\n    T _query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) return def; // 交差しない\n\n        eval(k, l, r);\n        if (a <= l && r <= b)\n            return data[k]; // a,l,r,bの順で完全に含まれる\n        else {\n            T c1 = _query(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n            T c2 = _query(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n            return operation(c1, c2);\n        }\n    }\n \npublic:\n    SegTree(int _n) {     // _n:必要サイズ\n        //def = INF2;        // 初期値かつ単位元（minのときINF2)\n        //def = 0;             // 初期値かつ単位元（和のとき0)\n        def0 = 0;              // 初期値\n        def  = 0;           // 単位元\n        n = 1;\n        while (n < _n) n *= 2;\n        data = vector<T>(2 * n - 1, def0);\n        lazy = vector<T>(2 * n - 1, 0);\n        lazyflag = vector<bool>(2 * n - 1, false);\n    }\n\n    // 区間更新\n    void add(int a, int b, T x) {\n        return _add(a, b, x, 0, 0, n);\n    }\n\n    // [a, b)の区間クエリを実行\n    T query(int a, int b) {\n        return _query(a, b, 0, 0, n);\n    }\n \n    // 添字でアクセス\n    T operator[](int i) {\n        return data[i + n - 1];\n    }\n};\n\nint main(int argc, char* argv[])\n{\n    int n,q;\n    scanf(\"%d%d\", &n, &q);\n    SegTree<ll> S(n);\n\n    int i;\n    for(i=0; i<q; i++) {\n#ifdef _DEBUG\n        {\n            int k;\n            for(k=0; k<n; k++) {\n                printf(\"%lld \", S.query(k,k+1));\n            }\n            printf(\"\\n\");\n        }\n#endif\n        int type, s, t, x;\n        scanf(\"%d\", &type);\n        if(type==0) {\n            scanf(\"%d%d%d\", &s, &t, &x);\n            S.add(s, t+1, x);\n        }\n        else {\n            scanf(\"%d%d\", &s, &t);\n            ll ans=S.query(s, t+1);\n            printf(\"%lld\\n\", ans);\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<math.h>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\n\nusing namespace std;\n#define N (1<<17)\n#define G 2147483647\nclass RUQ{\nprivate:\n    #define D 17\n    ll dat[2*N],laz[2*N];\n    ll eval(int k){\n\tif(laz[k]!=G){\n\t    dat[k]=laz[k]*(1<<(D-(ll)log2(k)));\n\t    if(k<N){\n\t\tlaz[k*2]=laz[k];\n\t\tlaz[k*2+1]=laz[k];\n\t    }\n\t}\n\tlaz[k]=G;\n\treturn dat[k];\n    }\npublic:\n    void Init(){\n\tlol(i,2*N)dat[i]=0,laz[i]=G;\n    }\n    void Upd(int l,int r,ll x){\n\tl+=N,r+=N+1;\n\tfor(int i=D;i>=0;i--){\n\t    eval(l>>i);eval(r>>i);\n\t}\n\tfor(int a=l,b=r;a<b;a>>=1,b>>=1){\n\t    if(a&1)laz[a++]=x;\n\t    if(b&1)laz[--b]=x;\n\t}\n\tfor(int a=l,b=r;a;a>>=1,b>>=1){\n\t    dat[a/2]=eval(a)+eval(a^1);\n\t    dat[b/2]=eval(b)+eval(b^1);\n\t}\n    }\n    ll Sum(int l,int r){\n\tl+=N,r+=N+1;\n\tfor(int i=D;i>=0;i--){\n\t    eval(l>>i);eval(r>>i);\n\t}\n\tll res=0;\n\tfor(int a=l,b=r;a<b;a>>=1,b>>=1){\n\t    if(a&1)res+=eval(a++);\n\t    if(b&1)res+=eval(--b);\n\t}\n\treturn res;\n    }\n};\nint main(){\n    int n,q;cin>>n>>q;\n    RUQ seg;seg.Init();\n    while(q--){\n\tll a,b,c;cin>>a;\n\tif(a==0){\n\t    cin>>a>>b>>c;\n\t    seg.Upd(a,b,c);\n\t}\n\telse{\n\t    cin>>a>>b;\n\t    cout<<seg.Sum(a,b)<<endl;\n\t}\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\ntypedef pair<pii,int> ppi;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a/gcd(a,b)*b;\n}\n\nclass LazySegmentTree{\nprivate:\n    int n;\n    vector<long long> node, lazy;\n    long long node_init = 0; // sum, max, update\n    //long long node_init = LINF; // min\n    //long long lazy_init = 0; // default\n    long long lazy_init = LINF; // min, update (存在しない値)\n\n    long long lazy_update(long long a,long long b){\n        //return a+b; // sum query\n        //return max(a,b); // max query\n        //return min(a,b); // min query\n        return b; // update query\n    }\n\n    long long node_update(long long a, long long b, int l, int r){ // lazy を node に反映\n        //return a + b; // min query\n        //return b; // update query\n        return b * (r-l); // sum query\n    }\n\n    long long combine(long long a,long long b){\n        return a+b; // sum query\n        //return max(a,b); // max query\n        //return min(a,b); // min query\n    }\n\npublic:\n    LazySegmentTree(){}\n    LazySegmentTree(vector<long long> in){\n        n = 1;\n        while(n < in.size())n <<= 1;\n        node = vector<long long>(2*n, node_init);\n        lazy = vector<long long>(2*n, lazy_init);\n        for(int i = n-1+in.size()-1; i >= 0; i--){\n            if(n-1 <= i)node[i] = in[i-(n-1)];\n            else node[i] = combine(node[i*2+1], node[i*2+2]);\n        }\n    }\n    void eval(int k, int l, int r){\n        if(lazy[k] != lazy_init){\n            node[k] = node_update(node[k], lazy[k], l, r);\n            if(r - l > 1){\n                lazy[2*k+1] = lazy_update(lazy[2*k+1], lazy[k]);\n                lazy[2*k+2] = lazy_update(lazy[2*k+2], lazy[k]);\n            }\n            lazy[k] = lazy_init;\n        }\n    }\n    void update(int a, int b, long long x, int k = 0, int l = 0, int r = -1){\n        if(r < 0)r = n;\n        eval(k,l,r);\n        if(b <= l || r <= a)return;\n        if(a <= l && r <= b){\n            lazy[k] = x;\n            eval(k,l,r);\n        }else{\n            update(a,b,x,2*k+1,l,(l+r)/2);\n            update(a,b,x,2*k+2,(l+r)/2,r);\n            node[k] = combine(node[2*k+1], node[2*k+2]);\n        }\n    }\n    long long query(int a, int b, int k = 0, int l = 0, int r = -1){\n        if(r < 0)r = n;\n        if(b <= l || r <= a)return node_init;\n        eval(k,l,r);\n        if(a <= l && r <= b)return node[k];\n        return combine(query(a,b,2*k+1,l,(l+r)/2), query(a,b,2*k+2,(l+r)/2,r));\n    }\n    void show(){\n        cout << \"node :\";\n        for(int i = 0; i < 2*n-1; i++){\n            if(i == n-1)cout << \"     \";\n            cout << \" \" << node[i];\n        }\n        cout << endl;\n        cout << \"lazy :\";\n        for(int i = 0; i < 2*n-1; i++){\n            if(i == n-1)cout << \"     \";\n            cout << \" \" << lazy[i];\n        }\n        cout << endl;\n    }\n};\n\nsigned main(void) {\n    int n,q;\n    cin >> n >> q;\n    LazySegmentTree lazy = LazySegmentTree(vi(n));\n\n    rep(i,q){\n        int a;\n        cin >> a;\n        if(a == 0){//update\n            int s,t,x;\n            cin >> s >> t >> x;\n            lazy.update(s,t+1,x);\n        }else{//query\n            int s,t;\n            cin >> s >> t;\n            cout << lazy.query(s,t+1) << endl;\n        }\n        //lazy.show();\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_I&lang=ja\n#define _DEBUG\n#include \"bits/stdc++.h\"\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,a4,x,...) x\n#define debug_1(x1) cout<<#x1<<\": \"<<x1<<endl\n#define debug_2(x1,x2) cout<<#x1<<\": \"<<x1<<\", \"#x2<<\": \"<<x2<<endl\n#define debug_3(x1,x2,x3) cout<<#x1<<\": \"<<x1<<\", \"#x2<<\": \"<<x2<<\", \"#x3<<\": \"<<x3<<endl\n#define debug_4(x1,x2,x3,x4) cout<<#x1<<\": \"<<x1<<\", \"#x2<<\": \"<<x2<<\", \"#x3<<\": \"<<x3<<\", \"#x4<<\": \"<<x4<<endl\n#define debug_5(x1,x2,x3,x4,x5) cout<<#x1<<\": \"<<x1<<\", \"#x2<<\": \"<<x2<<\", \"#x3<<\": \"<<x3<<\", \"#x4<<\": \"<<x4<<\", \"#x5<<\": \"<<x5<<endl\n#ifdef _DEBUG\n#define debug(...) CHOOSE((__VA_ARGS__,debug_5,debug_4,debug_3,debug_2,debug_1,~))(__VA_ARGS__)\n#else\n#define debug(...)\n#endif\n#define rep(index,num) for(int index=0;index<(int)num;index++)\n#define rep1(index,num) for(int index=1;index<=(int)num;index++)\n#define brep(index,num) for(int index=(int)num-1;index>=0;index--)\n#define brep1(index,num) for(int index=(int)num;index>0;index--)\n#define scan(argument) cin>>argument\n#define prin(argument) cout<<argument<<endl\n#define kaigyo cout<<endl\n#define eps 1e-7\n#define mp(a1,a2) make_pair(a1,a2)\n#define ALL(a) (a).begin(),(a).end()\n#define rALL(a) (a).rbegin(),(a).rend()\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pint;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef vector<pint> vpint;\ntypedef vector<pll> vpll;\nll INFl=(ll)1e+18+1;\nint INF=1e+9+1;\n/* SegTreeLazyProportional<X,M>(n,fx,fa,fm,fp,ex,em): モノイド(集合X, 二項演算fx,fa,fm,p 単位元ex,em)についてサイズnで構築\n    set(int i, X x), build(): i番目の要素をxにセット。まとめてセグ木を構築する。O(n)\n    update(i,x): i 番目の要素を x に更新。O(log(n))\n    query(a,b):  [a,b) 全てにfxを作用させた値を取得。O(log(n))\n*/\ntemplate <typename X, typename M>\nstruct SegTreeLazyProportional {\n    using FX = function<X(X, X)>;\n    using FA = function<X(X, M)>;\n    using FM = function<M(M, M)>;\n    using FP = function<M(M, int)>;\n    int n;\n    FX fx;\n    FA fa;\n    FM fm;\n    FP fp;\n    const X ex;\n    const M em;\n    vector<X> dat;\n    vector<M> lazy;\n    SegTreeLazyProportional(int n_, FX fx_, FA fa_, FM fm_, FP fp_, X ex_, M em_)\n        : n(), fx(fx_), fa(fa_), fm(fm_), fp(fp_), ex(ex_), em(em_), dat(n_ * 4, ex), lazy(n_ * 4, em) {\n        int x = 1;\n        while (n_ > x) x *= 2;\n        n = x;\n    }\n    void set(int i, X x) { dat[i + n - 1] = x; }\n    void build() {\n        for (int k = n - 2; k >= 0; k--) dat[k] = fx(dat[2 * k + 1], dat[2 * k + 2]);\n    }\n    /* lazy eval */\n    void eval(int k, int len) {\n        if (lazy[k] == em) return;  // 更新するものが無ければ終了\n        if (k < n - 1) {            // 葉でなければ子に伝搬\n            lazy[k * 2 + 1] = fm(lazy[k * 2 + 1], lazy[k]);\n            lazy[k * 2 + 2] = fm(lazy[k * 2 + 2], lazy[k]);\n        }\n        // 自身を更新\n        dat[k] = fa(dat[k], fp(lazy[k], len));\n        lazy[k] = em;\n    }\n    void update(int a, int b, M x, int k, int l, int r) {\n        eval(k, r - l);\n        if (a <= l && r <= b) {  // 完全に内側の時\n            lazy[k] = fm(lazy[k], x);\n            eval(k, r - l);\n        } else if (a < r && l < b) {                     // 一部区間が被る時\n            update(a, b, x, k * 2 + 1, l, (l + r) / 2);  // 左の子\n            update(a, b, x, k * 2 + 2, (l + r) / 2, r);  // 右の子\n            dat[k] = fx(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n    }\n    void update(int a, int b, M x) { update(a, b, x, 0, 0, n); }\n    X query_sub(int a, int b, int k, int l, int r) {\n        eval(k, r - l);\n        if (r <= a || b <= l) {  // 完全に外側の時\n            return ex;\n        } else if (a <= l && r <= b) {  // 完全に内側の時\n            return dat[k];\n        } else {  // 一部区間が被る時\n            X vl = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);\n            X vr = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);\n            return fx(vl, vr);\n        }\n    }\n    X query(int a, int b) { return query_sub(a, b, 0, 0, n); }\n};\n\nint main(){\n\tint N,Q;\n\tscan(N>>Q);\n    using X = ll;\n    using M = ll;\n    auto fx = [](X x1, X x2) -> X { return x1+x2; };\n    auto fa = [](X x, M m) -> X { return m; };\n    auto fm = [](M m1, M m2) -> M { return m2; };\n    auto fp = [](M m, long long n) -> M { return m * n; };\n    int ex = 0;\n    int em = INF;\n    SegTreeLazyProportional<X, M> seg(N, fx, fa, fm, fp, ex, em);\n\n    rep(i,Q){\n        int q;\n        scan(q);\n        if(q==0){\n            int s,t,x;\n            scan(s>>t>>x);\n            seg.update(s,t+1,x);\n        }\n        else{\n            int s,t;\n            scan(s>>t);\n            prin(seg.query(s,t+1));\n        }\n        /*rep(j,2*N-1){\n            printf(\"%lld \",seg.dat[j]);\n            if(j==0||j==2||j==6||j==14) kaigyo;\n        }\n        rep(j,2*N-1){\n            printf(\"%lld \",seg.lazy[j]);\n            if(j==0||j==2||j==6||j==14) kaigyo;\n        }*/\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int64_t;\nusing vi = vector<i64>;\nusing vvi = vector<vi>;\n#define endl '\\n'\n\nclass xorshift {\n    uint64_t x;\npublic:\n    xorshift() {\n        mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\n        x = rnd();\n        for (int i = 0; i < 100; i++) {\n            random();\n        }\n    }\n    uint64_t random() {\n        x = x ^ (x << 7);\n        return x = x ^ (x >> 9);\n    }\n};\n\nusing T = i64;\n\n// struct MinMonoid {\n//     static constexpr T id() {\n//         return 2e18;\n//     }\n//     static T op(T a, T b) {\n//         return min(a, b);\n//     }\n// };\n\n// struct AddMonoid {\n//     static constexpr T id() {\n//         return 0;\n//     }\n//     static T op(T a, T b) {\n//         return a + b;\n//     }\n// };\n\n// struct Modifier {\n//     // lazyの結果によってaccがどう変わるか。szは部分木のサイズ\n//     static T op(T a, T b, int sz) {\n//         return a + b;\n//     }\n// };\n\nstruct SumMonoid {\n    static constexpr T id() {\n        return 0;\n    }\n    static T op(T a, T b) {\n        return a + b;\n    }\n};\n\nstruct UpdateMonoid {\n    static constexpr T id() {\n        return 2e18;\n    }\n    static T op(T a, T b) {\n        return b;\n    }\n};\n\nstruct Modifier {\n    // lazyの結果によってaccがどう変わるか。szは部分木のサイズ\n    static T op(T a, T b, int sz) {\n        return b == UpdateMonoid::id() ? a : b * sz;\n    }\n};\n\ntemplate<class Monoid, class OperatorMonoid>\nclass ImplicitTreap {\n    xorshift rnd;\n    struct Node {\n        T value, acc, lazy;\n        int priority, cnt;\n        bool rev;\n        Node *l, *r;\n        Node(T value, int priority) : value(value), acc(Monoid::id()), lazy(OperatorMonoid::id()), priority(priority), cnt(1), rev(false), l(nullptr), r(nullptr) {}\n    } *root = nullptr;\n    using Tree = Node *;\n\n    int cnt(Tree t) {\n        return t ? t->cnt : 0;\n    }\n\n    T acc(Tree t) {\n        return t ? t->acc : Monoid::id();\n    }\n\n    void update_cnt(Tree t) {\n        if (t) {\n            t->cnt = 1 + cnt(t->l) + cnt(t->r);\n        }\n    }\n\n    void update_acc(Tree t) {\n        if (t) {\n            t->acc = Monoid::op(t->value, Monoid::op(acc(t->l), acc(t->r)));\n        }\n    }\n\n    void pushup(Tree t) {\n        update_cnt(t), update_acc(t);\n    }\n\n    void pushdown(Tree t) {\n        if (t && t->rev) {\n            t->rev = false;\n            swap(t->l, t->r);\n            if (t->l) t->l->rev ^= 1;\n            if (t->r) t->r->rev ^= 1;\n        }\n        if (t && t->lazy != OperatorMonoid::id()) {\n            if (t->l) {\n                t->l->lazy = OperatorMonoid::op(t->l->lazy, t->lazy);\n                t->l->acc = Modifier::op(t->l->acc, t->l->lazy, cnt(t->l));\n            }\n            if (t->r) {\n                t->r->lazy = OperatorMonoid::op(t->r->lazy, t->lazy);\n                t->r->acc = Modifier::op(t->r->acc, t->r->lazy, cnt(t->r));\n            }\n            t->value = Modifier::op(t->value, t->lazy, 1);\n            t->lazy = OperatorMonoid::id();\n        }\n        pushup(t);\n    }\n    \n    void split(Tree t, int key, Tree& l, Tree& r) {\n        if (!t) {\n            l = r = nullptr;\n            return;\n        }\n        pushdown(t);\n        int implicit_key = cnt(t->l) + 1;\n        if (key < implicit_key) {\n            split(t->l, key, l, t->l), r = t;\n        } else {\n            split(t->r, key - implicit_key, t->r, r), l = t;\n        }\n        pushup(t);\n    }\n    \n    void insert(Tree& t, int key, Tree item) {\n        Tree t1, t2;\n        split(t, key, t1, t2);\n        merge(t1, t1, item);\n        merge(t, t1, t2);\n    }\n\n    void merge(Tree& t, Tree l, Tree r) {\n        pushdown(l);\n        pushdown(r);\n        if (!l || !r) {\n            t = l ? l : r;\n        } else if (l->priority > r->priority) {\n            merge(l->r, l->r, r), t = l;\n        } else {\n            merge(r->l, l, r->l), t = r;\n        }\n        pushup(t);\n    }\n    \n    void erase(Tree& t, int key) {\n        Tree t1, t2, t3;\n        split(t, key + 1, t1, t2);\n        split(t1, key, t1, t3);\n        merge(t, t1, t2);\n    }\n\n    void update(Tree t, int l, int r, T x) {\n        Tree t1, t2, t3;\n        split(t, l, t1, t2);\n        split(t2, r - l, t2 , t3);\n        t2->lazy = OperatorMonoid::op(t2->lazy, x);\n        t2->acc = Modifier::op(t2->acc, t2->lazy, cnt(t2));\n        merge(t2, t2, t3);\n        merge(t, t1, t2);\n    }\n\n    T query(Tree t, int l, int r) {\n        Tree t1, t2, t3;\n        split(t, l, t1, t2);\n        split(t2, r - l, t2, t3);\n        T ret = t2->acc;\n        merge(t2, t2, t3);\n        merge(t, t1, t2);\n        return ret;\n    }\n\n    void reverse(Tree t, int l, int r) {\n        if (l > r) return;\n        Tree t1, t2, t3;\n        split(t, l, t1, t2);\n        split(t2, r - l, t2, t3);\n        t2->rev ^= 1;\n        merge(t2, t2, t3);\n        merge(t, t1, t2);\n    }\n\n    // [l, r)の先頭がmになるように左シフトさせる。std::rotateと同じ仕様\n    void rotate(Tree t, int l, int m, int r) {\n        reverse(t, l, r);\n        reverse(t, l, m);\n        reverse(t, m, r);\n    }\n\n    void dump(Tree t) {\n        if (!t) return;\n        pushdown(t);\n        dump(t->l);\n        cout << t->value << \" \";\n        dump(t->r);\n    }\n    \npublic:\n    ImplicitTreap(const vector<T> as) {\n        for (T a : as) {\n            insert(0, a);\n        }\n    }\n\n    void insert(int pos, T x) {\n        insert(root, pos, new Node(x, rnd.random()));\n    }\n\n    void update(int l, int r, T x) {\n        update(root, l, r, x);\n    }\n\n    T query(int l, int r) {\n        return query(root, l, r);\n    }\n\n    void erase(int pos) {\n        erase(root, pos);\n    }\n\n    void reverse(int l, int r) {\n        reverse(root, l, r);\n    }\n\n    void rotate(int l, int m, int r) {\n        rotate(root, l, m, r);\n    }\n\n    void dump() {\n        dump(root);\n        cout << endl;\n    }\n\n    T operator[](int pos) {\n        Tree t1, t2, t3;\n        split(root, pos + 1, t1, t2);\n        split(t1, pos, t1, t3);\n        T ret = t3->acc;\n        merge(t1, t1, t3);\n        merge(root, t1, t2);\n        return ret;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    int n, q;\n    cin >> n >> q;\n    vi as(n);\n    ImplicitTreap<SumMonoid, UpdateMonoid> tr(as);\n    while (q--) {\n        int type;\n        cin >> type;\n        if (type) {\n            int s, t;\n            cin >> s >> t;\n            cout << tr.query(s, t + 1) << endl;\n        } else {\n            int s, t, x;\n            cin >> s >> t >> x;\n            tr.update(s, t + 1, x);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n#define NL <<\"\\n\"\n\nusing namespace std;\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#include \"benri.h\"\n#else\n#define out(args...)\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nconst ll MOD=1e9+7; //998244353\n\nconst int N=(1<<17);\n\ntemplate<class T>\nstruct Seg{\n\tT s;\n\tSeg (T s=0):s(s){}\n\tSeg operator+(const Seg &seg){\n\t\treturn s+seg.s;\n\t}\n  static Seg e;\n};\ntemplate<class T> Seg<T> Seg<T>::e=Seg();\n\ntemplate<class T>\nstruct Lfun{\n\tT a,b;\n  Lfun(T a=1,T b=0):a(a),b(b){}\n\tvoid operator+=(const Lfun &lfun){\n\t\ta*=lfun.a;\n\t\t(b*=lfun.a)+=lfun.b;\n\t}\n\tbool operator==(const Lfun &lfun){ return a==lfun.a && b==lfun.b;}\n\n\tvoid eval(Seg<T> &s,int l,int r){\n\t\t(s.s*=a)+=b*(r-l);\n\t}\n\tstatic Lfun e;\n};\ntemplate<class T> Lfun<T> Lfun<T>::e=Lfun();\n\ntemplate<class Seg, class Ope>\nstruct SegTree{\n\tvector<Seg> segs;\n\tvector<Ope> opes;\n\t\n\tvoid lazy_eval(int k,int a,int b){\n\t\tif(opes[k]==Ope::e) return;\n\t\topes[k].eval(segs[k],a,b);\n\t\tif(2*k+2<opes.size()){\n\t\t\topes[2*k+1]+=opes[k];\n\t\t\topes[2*k+2]+=opes[k];\n\t\t}\n\t\topes[k]=Ope::e;\n\t}\n\tvoid upd_node(int k){segs[k]=segs[2*k+1]+segs[2*k+2];}\n\tvoid upd(int l,int r,Ope ope,int k,int a,int b){\n\t\tlazy_eval(k,a,b);\n\t\tif(b<=l || r<=a) return; \n\t\tif(l<=a && b<=r){\n\t\t\topes[k]+=ope;\n\t\t\tlazy_eval(k,a,b);\n\t\t\treturn;\n\t\t}\t\n\t\tint m=(a+b)/2;\n\t\tupd(l,r,ope,2*k+1,a,m);\n\t\tupd(l,r,ope,2*k+2,m,b);\n\t\tupd_node(k);\n\t}\n\n\tSeg query(int l,int r,int k,int a,int b){\n\t\tlazy_eval(k,a,b);\n\t\tif(b<=l || r<=a)return Seg::e; \n\t\tif(l<=a && b<=r){return segs[k];}\n  \n\t\tint m=(a+b)/2;\n\t\tSeg vl=query(l,r,2*k+1,a,m);\n\t\tSeg vr=query(l,r,2*k+2,m,b);\n\t\tupd_node(k);\n\t\treturn vl+vr;\n\t}\n\n\tSegTree(int n){\n\t\tint pw=1;\n\t\twhile(pw<n) pw*=2;\n\t\tsegs.resize(2*pw);\n\t\topes.resize(2*pw);\n\t}\n\tvoid operator()(int l,int r,Ope ope){ upd(l,r,ope,0,0,segs.size()/2);};\n\tSeg operator()(int l,int r){ return query(l,r,0,0,segs.size()/2);};\n};\n\nint main(){\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  cout<<fixed<<setprecision(0);\n\tint n,q;\n\tcin>>n>>q;\n\tSegTree<Seg<ll>,Lfun<ll>> st(n);\n\trep(i,q){\n\t\tint t;\n\t\tcin>>t;\n\t\tif(t){\n\t\t\tint s,t;\n\t\t\tcin>>s>>t; ++t;\n\t\t\tcout<<st(s,t).s NL;\n\t\t}else{\n\t\t\tint s,t,x;\n\t\t\tcin>>s>>t>>x; ++t;\n\t\t\tst(s,t,{0,x});\n\t\t}\n\t}\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<queue>\n#define null NULL\n#define maxn 2000\nusing namespace std;\n/** 区间表示：[p->dl,p->dr]\n *  从0开始计数，[0,n-1]\n *  线段树RSQ\n *\n */\n\nstruct Node\n{\n    long long dl,dr,s,delta;\n    Node *pl,*pr;\n};\nint n,q;\n\nvoid build(Node *&p,int l,int r)\n{\n    p=(Node *)malloc(sizeof(Node));\n    p->dl=l,p->dr=r,p->s=0,p->delta=maxn;\n    p->pl=null,p->pr=null;\n    int mid=(l+r)/2;\n    if(r>l)\n    {\n        build(p->pl,l,mid);\n        build(p->pr,mid+1,r);\n    }\n}\n\nvoid preorder(Node *p)\n{\n    if(p!=null)\n    {\n        printf(\"%lld %lld %lld %lld\\n\",p->dl,p->dr,p->s,p->delta);\n        preorder(p->pl);\n        preorder(p->pr);\n    }\n}\n///在其他节点更新和查询的过程中都要向下延迟修改\nvoid pushdown(Node *&p,int delta)\n{\n    p->pl->s = p->delta*(p->pl->dr - p->pl->dl+1);\n    p->pr->s = p->delta*(p->pr->dr - p->pr->dl+1);\n    p->pl->delta = p->delta;\n    p->pr->delta = p->delta;\n    p->delta=maxn;\n}\n///当前区间的更新只更新到某些节点，下边节点的更新需要下次延迟修改\nvoid update(Node *&p,int l,int r,int data)\n{\n    ///[l,r]必然位于[p->dl,p->dr]子区间\n    ///当前节点的所有数据都是正确的！！\n    ///延迟修改-lazy-tag技术\n    ///此处下行的是之前的数据\n    if(p->delta!=maxn && p->dr>p->dl)\n        pushdown(p,p->delta);\n\n    if(p->dl==l && p->dr==r)\n    {\n        p->s=data*(r-l+1);\n        p->delta=data;\n        return ;\n    }\n    int mid=(p->dl+p->dr)/2;\n    if(r<=mid)\n        update(p->pl,l,r,data);\n    else if(l>mid)\n        update(p->pr,l,r,data);\n    else\n        update(p->pl,l,mid,data),update(p->pr,mid+1,r,data);\n    p->s=p->pl->s+p->pr->s;\n}\n///当前节点的所有数据都是正确的！！\n///即使不正确，在进入到这个之前也被pushdown过了,，所以一定是正确的\nlong long query(Node *&p,int l,int r)\n{\n    ///一个查询区间最终必然被分成若干个小的区间和，最后一个定会完全和区间贴合\n    if(p->delta!=maxn && p->dr>p->dl)\n        pushdown(p,p->delta);\n\n    if(p->dl==l &&p->dr==r)\n        return p->s;\n    int mid=(p->dl+p->dr)/2;\n    ///判断查询区间与当前区间的位置关系\n    //全部位于左侧\n    if(r<=mid)\n        return query(p->pl,l,r);\n    //全部位于右侧\n    else if(l>mid)\n        return query(p->pr,l,r);\n    //两个都有\n    else\n        return query(p->pl,l,mid)+query(p->pr,mid+1,r);\n}\n\nint main()\n{\n    int i,type,tx,ty,x;\n    Node *tree=null;\n    scanf(\"%d%d\",&n,&q);\n    build(tree,0,n-1);\n    for(i=0;i<q;i++)\n    {\n        scanf(\"%d\",&type);\n        if(type==0)\n        {\n            scanf(\"%d%d%d\",&tx,&ty,&x);\n            update(tree,tx,ty,x);\n        }else\n        {\n            scanf(\"%d%d\",&tx,&ty);\n            long long ans=query(tree,tx,ty);\n            printf(\"%lld\\n\",ans);\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#include <time.h>\n#include <functional>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\ntypedef vector<ll> vll;\ntypedef vector< vector<ll> > matrix;\n#define REP(i, x, y) for(ll i = (ll)x; i < (ll)y; i++)\n#define DREP(i, x, y, d) for(ll i = (ll)x; i < (ll)y; i += (ll)d)\n#define PER(i, x, y) for(ll i = (ll)x; i > (ll)y; i--)\n#define DPER(i, x, y, d) for(ll i = (ll)x; i > (ll)y; i -= (ll)d)\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-12;\n\n//abstruct lazy segment tree 抽象化遅延評価セグメント木（非再帰）\ntemplate<typename D, typename L>\nstruct segtree {\n    using F = function<D(D, D)>;\n    using G = function<D(L, D)>;\n    using H = function<L(L, L)>;\n    F f;\n    G g;\n    H h;\n    D De;\n    L Le;\n    int n, height;\n    vector<D> dat;\n    vector<L> lazy;\n\n    segtree(F f, G g, H h, D De, L Le):\n        f(f), g(g), h(h), De(De), Le(Le){}\n \n    void init(int n_) {\n        n = 1;\n        height = 0;\n        while (n < n_) {\n            n <<= 1;\n            height++;\n        }\n        lazy.assign(2 * n, Le);\n        dat.assign(2 * n, De);\n    }\n\n    void build(const vector<D> &v) {\n        int n_ = v.size();\n        init(n_);\n        for (int i = 0; i < n_; i++) {\n            dat[i + n] = v[i];\n        }\n        for (int i = n - 1; i > 0; i--) {\n            dat[i] = f(dat[i << 1], dat[(i << 1) | 1]);\n        }\n    }\n\n    D reflect(int k) {\n        if (lazy[k] == Le) {\n            return dat[k];\n        } else {\n            return g(lazy[k], dat[k]);\n        }\n    }\n\n    void propagate(int k) {\n        if (lazy[k] == Le) {\n            return;\n        }\n        if (k < n) {\n            lazy[k << 1] = h(lazy[k], lazy[k << 1]);\n            lazy[(k << 1) | 1] = h(lazy[k], lazy[(k << 1) | 1]);\n        }\n        dat[k] = reflect(k);\n        lazy[k] = Le;\n    }\n\n    void thrust(int k) {\n        for (int i = height; i > 0; i--) {\n            propagate(k >> i);\n        }\n    }\n\n    void recalc(int k) {\n        while (k >>= 1) {\n            dat[k] = f(reflect(k << 1), reflect((k << 1) | 1));\n        }\n    }\n\n    //[a, b)の範囲に何かする\n    void update(int a, int b, L x) {\n        if (a >= b) {\n            return;\n        }\n        a += n;\n        thrust(a);\n        b += n - 1;\n        thrust(b);\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) {\n                lazy[l] = h(x, lazy[l]);\n                l++;\n            }\n            if (r & 1) {\n                r--;\n                lazy[r] = h(x, lazy[r]);\n            }\n        }\n        recalc(a);\n        recalc(b);\n    }\n\n    //k番目にaを代入する\n    void setval(int a, D x) {\n        a += n;\n        thrust(a);\n        dat[a] = x;\n        lazy[a] = Le;\n        recalc(a);\n    }\n\n    //[a, b)の範囲の情報を得る\n    D query(int a, int b) {\n        if (a >= b) {\n            return De;\n        }\n        a += n;\n        thrust(a);\n        b += n - 1;\n        thrust(b);\n        D vl = De, vr = De;\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) {\n                vl = f(vl, reflect(l));\n                l++;\n            }\n            if (r & 1) {\n                r--;\n                vr = f(reflect(r), vr);\n            }\n        }\n        return f(vl, vr);\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll n, q;\n    cin >> n >> q;\n    auto f = [](plglg a, plglg b){return plglg(a.first + b.first, a.second + b.second);};\n    auto g = [](ll a, plglg b){return plglg(a * b.second, b.second);};\n    auto h = [](ll a, ll b){return a;};\n    segtree<plglg, ll> seg(f, g, h, plglg(0, 0), inf);\n    seg.build(vector<plglg>(n, plglg(0, 1)));\n    REP(i, 0, q) {\n        ll que;\n        cin >> que;\n        if (que == 0) {\n            ll s, t, x;\n            cin >> s >> t >> x;\n            seg.update(s, t + 1, x);\n        } else {\n            ll s, t;\n            cin >> s >> t;\n            cout << seg.query(s, t + 1).first << endl;\n        }\n        // REP(i, 0, 2 * seg.n) {\n        //     cout << seg.dat[i].first << \" \" << seg.dat[i].second << \" aaa \";\n        // }\n        // cout << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n#define int long long int\n\n// quoted from beet-aizu\ntemplate <typename T,typename E, typename F, typename G, typename H>\nstruct LazySegmentTree{\n    //using F = function<T(T,T)>;\n    //using G = function<T(T,E)>;\n    //using H = function<E(E,E)>;\n    int n,height;\n    F f;\n    G g;\n    H h;\n    T ti;\n    E ei;\n    vector<T> dat;\n    vector<E> laz;\n    LazySegmentTree(F f,G g,H h,T ti,E ei):\n        f(f),g(g),h(h),ti(ti),ei(ei){}\n\n    void init(int n_){\n        n=1;height=0;\n        while(n<n_) n<<=1,height++;\n        dat.assign(2*n,ti);\n        laz.assign(2*n,ei);\n    }\n    void build(const vector<T> &v){\n        int n_=v.size();\n        init(n_);\n        for(int i=0;i<n_;i++) dat[n+i]=v[i];\n        for(int i=n-1;i;i--)\n            dat[i]=f(dat[(i<<1)|0],dat[(i<<1)|1]);\n    }\n    inline T reflect(int k){\n        return laz[k]==ei?dat[k]:g(dat[k],laz[k]);\n    }\n    inline void eval(int k){\n        if(laz[k]==ei) return;\n        laz[(k<<1)|0]=h(laz[(k<<1)|0],laz[k]);\n        laz[(k<<1)|1]=h(laz[(k<<1)|1],laz[k]);\n        dat[k]=reflect(k);\n        laz[k]=ei;\n    }\n    inline void thrust(int k){\n        for(int i=height;i;i--) eval(k>>i);\n    }\n    inline void recalc(int k){    \n        while(k>>=1)\n            dat[k]=f(reflect((k<<1)|0),reflect((k<<1)|1));\n    }\n    void update(int a,int b,E x){\n        thrust(a+=n);\n        thrust(b+=n-1);\n        for(int l=a,r=b+1;l<r;l>>=1,r>>=1){\n            if(l&1) laz[l]=h(laz[l],x),l++;\n            if(r&1) --r,laz[r]=h(laz[r],x);\n        }\n        recalc(a);\n        recalc(b);\n    }\n    void set_val(int a,T x){\n        thrust(a+=n);\n        dat[a]=x;laz[a]=ei;\n        recalc(a);\n    }\n    T query(int a,int b){\n        thrust(a+=n);\n        thrust(b+=n-1);\n        T vl=ti,vr=ti;\n        for(int l=a,r=b+1;l<r;l>>=1,r>>=1) {\n            if(l&1) vl=f(vl,reflect(l++));\n            if(r&1) vr=f(reflect(--r),vr);\n        }\n        return f(vl,vr);\n    }\n};\n\nsigned main(){\n    \n    int n, q; cin >> n >> q;\n    using P = pair<int, int>;\n    auto f = [](P a, P b){ return P(a.first + b.first, a.second + b.second); };\n    auto g = [](P a, int b){ return P(a.second * b, a.second); };\n    auto h = [](int a, int b){ return b != -1 ? b : a; };\n    LazySegmentTree<P, int, decltype(f), decltype(g), decltype(h)> sg(f, g, h, P(0, 0), -1);\n    sg.build(vector<P>(n, P(0, 1)));\n    \n    for(int i = 0; i < q; i++){\n        int com; cin >> com;\n        if(!com){\n            int s, t, x; cin >> s >> t >> x;\n            sg.update(s, t + 1, x);\n        }else{\n            int s, t; cin >> s >> t;\n            cout << sg.query(s, t + 1).first << endl;\n        }   \n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n//#include \"boost/multiprecision/cpp_int.hpp\"\n//typedef boost::multiprecision::cpp_int ll;\ntypedef long double dd;\n//#define i_7 (ll)(1E9+7)\n#define i_7 998244353\n#define i_5 i_7-2\n\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\ntypedef pair<ll,ll> l_l;\ntypedef pair<dd,dd> d_d;\nll inf=(ll)1E16;\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll &pos,ll val){pos=max(pos,val);}//Max(dp[n],dp[n-1]);\nvoid Min(ll &pos,ll val){pos=min(pos,val);}\nvoid Add(ll &pos,ll val){pos=mod(pos+val);}\ndd EPS=1E-9;\n#define fastio ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n//template<class T>void max(T a,T b){if(a<b)return b;else return a;}\n//template<class T>void min(T a,T b){if(a>b)return b;else return a;}\n//template<class T>bool Max(T&a, T b){if(a < b){a = b;return 1;}return 0;}\n//template<class T>bool Min(T&a, T b){if(a > b){a = b;return 1;}return 0;}\n\n//////////////////////////\n\n\n//from betrue12 Codeforces 1326E\ntemplate<typename F, typename T, typename Func_mf, typename Func_op, typename Func_mv>\nstruct LazySegtree {\n    ll n, n_org;\n    vector<T> dat;\n    vector<F> laz;\n    Func_mf merge_functions; //lazyとlazyの演算\n    Func_op operate;       //dataとlazyの演算\n    Func_mv merge_values;  //dataとdataの演算\n    F fe; //lazyの単位元かつ初期値\n    T te; //dataの単位元かつ初期値\n \n    LazySegtree(){}\n    LazySegtree(ll n_org,\n                Func_mf merge_functions,\n                Func_op operate,\n                Func_mv merge_values,\n                F fe, T te):\n                n_org(n_org),\n                merge_functions(merge_functions),\n                operate(operate),\n                merge_values(merge_values),\n                fe(fe), te(te){\n        n = 1;\n        while(n < n_org) n <<= 1;\n        dat.resize(2*n-1, te);\n        laz.resize(2*n-1, fe);\n    }\n \n    void build(vector<T>& A){\n        for(ll k=0; k<ll(A.size()); k++) dat[k+n-1] = A[k];\n        for(ll k=n-2; k>=0; k--) dat[k] = merge_values(dat[2*k+1], dat[2*k+2]);\n    }\n \n    void eval(ll k, ll w){\n        if(laz[k] == fe) return;\n        operate(dat[k], laz[k], w);\n        if(k < n-1){\n            merge_functions(laz[2*k+1], laz[k]);\n            merge_functions(laz[2*k+2], laz[k]);\n        }\n        laz[k] = fe;\n    }\n \n    void update(ll a, ll b, F x){ //[a,b]をupdate\n        update(a, b+1, x, 0, 0, n);\n    }\n \n    void update(ll a, ll b, F x, ll k, ll lb, ll rb){\n        eval(k, rb-lb);\n        if(b <= lb || rb <= a) return;\n        if(a <= lb && rb <= b){\n            merge_functions(laz[k], x);\n            eval(k, rb-lb);\n        }else{\n            ll mb = (lb+rb)>>1;\n            update(a, b, x, 2*k+1, lb, mb);\n            update(a, b, x, 2*k+2, mb, rb);\n            dat[k] = merge_values(dat[2*k+1], dat[2*k+2]);\n        }\n    }\n \n    T get(ll a, ll b){ //[a,b]から(最小値とか和とかを)get\n        return query(a, b+1, 0, 0, n);\n    }\n \n    T query(ll a, ll b, ll k, ll lb, ll rb){\n        eval(k, rb-lb);\n        if(rb<=a || b<=lb) return te;\n        if(a<=lb && rb<=b) return dat[k];\n        ll mb = (lb+rb)>>1;\n        T vl = query(a, b, 2*k+1, lb, mb);\n        T vr = query(a, b, 2*k+2, mb, rb);\n        return merge_values(vl, vr);\n    }\n};\n\nauto make_segtree = [](ll N){ //auto make_segtree = [&](ll N)\n    //区間最大にしたいときは　max(a,b)にするのと、単位元を-infにする。\n    //区間加算と区間最小\n    /*\n    using F = ll;\n    using T = ll;\n    auto merge_functions = [](F& f, F& g){f += g;};\n    auto operate = [](T& v, F& f, ll w){v += f;};\n    auto merge_values = [](T& a, T& b){return min(a, b);};\n    F fe = 0;\n    T te = inf;*/\n    \n    //区間加算と区間和\n    /*\n    using F = ll;\n    using T = ll;\n    auto merge_functions = [](F& f, F& g){f += g;};\n    auto operate = [](T& v, F& f, ll w){v += f*w;};\n    auto merge_values = [](T& a, T& b){return a+b;};\n    F fe = 0;\n    T te = 0;*/\n    \n    //区間更新と区間最小\n    /*\n    using F=ll;\n    using T=ll;\n    auto merge_functions=[](F& f,F& g){f=g;};\n    auto operate = [](T& v, F& f, ll w){v=f;};\n    auto merge_values = [](T& a, T& b){return min(a, b);};\n    F fe = inf;\n    T te = inf;*/\n    \n    //区間更新と区間和\n    using F=ll;\n    using T=ll;\n    auto merge_functions=[](F& f,F& g){f=g;};\n    auto operate = [](T& v, F& f, ll w){v=f*w;};\n    auto merge_values = [](T& a, T& b){return a+b;};\n    F fe = -inf;\n    T te = 0;\n    \n    return LazySegtree<F, T, decltype(merge_functions), decltype(operate), decltype(merge_values)>\n        (N, merge_functions, operate, merge_values, fe, te);\n};\n/*\nauto st = make_segtree(2*N+1);\nvector<ll> init(2*N+1);\nst.build(init);\n */\n\nint main(){fastio\n    ll n,q;cin>>n>>q;\n    vector<ll>init(n);\n    auto u=make_segtree(n);\n    u.build(init);\n    while(q--){\n        ll c;cin>>c;\n        if(c==0){\n            ll x,y,z;cin>>x>>y>>z;\n            u.update(x,y,z);\n        }else{\n            ll x,y;cin>>x>>y;\n            cout<<u.get(x,y)<<endl;\n        }\n        //rep(i,0,n-1)cout<<u.get(i,i)<<\" \";cout<<endl;\n    }\n    \n    \n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macro\n#pragma region Basic\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\n#define REP(i, n) for (int i = 0, i##_len = (n); i < i##_len; ++i)\n#define FOR(i, a, b) for (int i = (a), i##_len = (b); i < i##_len; i++)\n#define FORD(i, a, b) for (int i = (a), i##_len = (b); i > i##_len; i--)\n#define FORR(t, a) for (auto t : a)\n#define ALL(x) (x).begin(), (x).end()  // sortなどの引数を省略したい\n#define GET(i, j) get<j>(i)\n#define MT(x, ...) make_tuple(x, __VA_ARGS__)\n#define SZ(x) ((int)(x).size())\n//#define ZERO(x) memset(x, 0, sizeof(x))\n//#define FILL(x, y) memset(x, y, sizeof(x))\n#define UNUSED(x) (void(x));\n#define PB push_back\n#define EB emplace_back\n#ifdef _DEBUG\n#define PRE_COMMAND             \\\n    std::cin.rdbuf(in.rdbuf()); \\\n    cout << fixed << setprecision(15);\n#else\n#define PRE_COMMAND cout << fixed << setprecision(15);\n#endif\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\ntemplate <class T>\nauto MAX(T& seq) {\n    return *max_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto MIN(T& seq) {\n    return *min_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto SUM(T& seq) {\n    T temp{0};\n    auto& temp2 = temp[0];\n    return accumulate(seq.begin(), seq.end(), temp2);\n}\ntemplate <class T>\nvoid SORT(T& seq) {\n    sort(seq.begin(), seq.end());\n}\ntemplate <class T, class S>\nvoid SORT(T& seq, S& sort_order) {\n    sort(seq.begin(), seq.end(), sort_order);\n}\ntemplate <class T>\nvoid SORTR(vector<T>& seq) {\n    sort(seq.begin(), seq.end(), greater<T>());\n}\ntemplate <class T>\nvoid CHMAX(T& a, const T& b) {\n    if (a < b) { a = b; }\n}\ntemplate <class T>\nvoid CHMIN(T& a, const T& b) {\n    if (b < a) { a = b; }\n}\ntemplate <class T>\nset<T> VECTOR_2_SET(vector<T>& v) {\n    set<T> s;\n    for (auto ele : v) { s.insert(ele); }\n    return s;\n}\ntemplate <class T>\nvector<T> SET_2_VECTOR(set<T>& s) {\n    vector<T> v;\n    for (auto ele : s) { v.push_back(ele); }\n    return v;\n}\n#pragma endregion Basic\n#pragma region overload\ntemplate <class T, class S>\nvoid operator+=(vector<T>& l, S& r) {\n    for (auto i : r) { l.push_back(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(set<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(multiset<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\ntemplate <class T, class S>\nvector<T> operator+(vector<T>& l, S& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T>\nvector<T> operator+(const vector<T> l, const vector<T>& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nset<T> operator+(set<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nset<T> operator+(const set<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nmultiset<T> operator+(multiset<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nmultiset<T> operator+(const multiset<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\nstring operator+(const string l, const string& r) {\n    string str = l;\n    str += r;\n    return str;\n}\nstring operator*(const string l, const size_t& r) {\n    string str = l;\n    for (size_t i = 0; i < r; i++) { str += l; }\n    return str;\n}\n#pragma endregion overload\n#pragma region Input\ntemplate <class Head>\nvoid INPUT(vector<Head>& head);\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head);\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t);\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t);\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t);\ntemplate <class Head>\nvoid INPUT(Head& head);\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail);\n//本体\ntemplate <class Head>\nvoid INPUT(vector<Head>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t) {\n    cin >> get<0>(t);\n}\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t) {\n    cin >> get<0>(t) >> get<1>(t);\n}\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t);\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t);\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);\n}\ntemplate <class Head>\nvoid INPUT(Head& head) {\n    cin >> head;\n}\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail) {\n    INPUT(head);\n    INPUT((tail)...);\n}\n#pragma endregion Input\n#pragma region Print\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t);\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t);\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t);\ntemplate <class Head>\nvoid PRINT2(vector<Head> head);\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head);\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head);\ntemplate <class Head>\nvoid PRINT2(Head head);\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail);\ntemplate <class Head>\nvoid PRINT(Head head);\ntemplate <class... Head>\nvoid PRINT(Head... head);\ntemplate <int N, class Head>\nvoid PRINT(Head head);\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t) {\n    PRINT2(get<0>(t));\n}\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t) {\n    PRINT2(get<0>(t), get<1>(t));\n}\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t));\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t));\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t), get<4>(t));\n}\ntemplate <class Head>\nvoid PRINT2(vector<Head> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(Head head) {\n    cout << head;\n}\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail) {\n    PRINT2(head);\n    cout << \" \";\n    PRINT2((tail)...);\n}\ntemplate <class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\ntemplate <class... Head>\nvoid PRINT(Head... head) {\n    PRINT2((head)...);\n    cout << endl;\n}\ntemplate <int N, class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\n#pragma endregion Print\n#pragma endregion Macro\n\n// ini：上限（下限）,base：元の配列,monoid：モノイド,tree：セグ木,depth：treeの深さ,\n// basesize：baseの要素数,treesize：treeの要素数,num：treesize-basesize\n// 初期値（上限とか下限）を決定\ntemplate <class num_type>\nstruct segtree {\n    int num, depth, basesize, treesize;\n    vector<num_type> base, tree, lazy;\n    // monoidのini、operatorのiniの設定\n    num_type ini = 0, ini_op = pow(10, 9);\n    // lazyをスケール変換する関数\n    // 区間和のとき\n    num_type monoid(num_type& x, num_type& y) { return x + y; }\n    // lazyをスケール変換する関数\n    // 区間和のとき\n    num_type modify(int width, num_type& value) { return width * value; }\n    // yにxを作用させる関数\n    // 区間更新のとき\n    num_type operate(num_type& x, num_type& y) {\n        UNUSED(y);\n        return x;\n    }\n\n    // 元の配列, モノイド, 初期値\n    segtree(vector<num_type> temp) : base(temp) {\n        basesize = (int)base.size();\n        num = 1;\n        depth = 1;\n        while (num < basesize) {\n            num *= 2;\n            depth++;\n        }\n        num--;\n        treesize = num * 2 + 1;\n        tree.assign(treesize, ini);\n        lazy.assign(treesize, ini_op);\n        for (int i = num; i < num + basesize; i++) { tree[i] = base[i - num]; }\n        for (int i = num + basesize; i < treesize; i++) { tree[i] = ini; }\n        for (int i = num - 1; i > -1; i--) {\n            tree[i] = monoid(tree[2 * i + 1], tree[2 * i + 2]);\n        }\n    }\n    // modifyとoperateを同時に行う関数\n    num_type mod_op(int width, int node) {\n        if (lazy[node] != ini_op) {\n            num_type temp = modify(width, lazy[node]);\n            return operate(temp, tree[node]);\n        } else {\n            return tree[node];\n        }\n    }\n    // 半開区間[lower,upper)の最小値（とか）を探す関数\n    num_type search(int lower, int upper) {\n        num_type ret = ini, temp;\n        vector<tuple<int, int, int>> stack(1, make_tuple(0, num + 1, 0));\n        int l, r, m, node;\n        while (stack.size()) {\n            tie(l, r, node) = stack.back();\n            stack.pop_back();\n            m = (l + r) / 2;\n            if (lower <= l && r <= upper) {\n                temp = mod_op(r - l, node);\n                ret = monoid(ret, temp);\n            } else {\n                eval(l, r, node);\n                if (upper <= m) {\n                    stack.push_back(make_tuple(l, m, node * 2 + 1));\n                } else if (m <= lower) {\n                    stack.push_back(make_tuple(m, r, node * 2 + 2));\n                } else {\n                    stack.push_back(make_tuple(l, m, node * 2 + 1));\n                    stack.push_back(make_tuple(m, r, node * 2 + 2));\n                }\n            }\n        }\n        return ret;\n    }\n    // 葉方向に伝播させる関数\n    void eval(int& l, int& r, int& node) {\n        if (lazy[node] != ini_op) {\n            if (2 * node + 1 < treesize) {\n                if (num <= node * 2 + 1) {\n                    tree[node * 2 + 1] =\n                        operate(lazy[node], tree[node * 2 + 1]);\n                    tree[node * 2 + 2] =\n                        operate(lazy[node], tree[node * 2 + 2]);\n                } else {\n                    lazy[node * 2 + 1] =\n                        operate(lazy[node], lazy[node * 2 + 1]);\n                    lazy[node * 2 + 2] =\n                        operate(lazy[node], lazy[node * 2 + 2]);\n                }\n            }\n            num_type temp = modify(r - l, lazy[node]);\n            tree[node] = operate(temp, tree[node]);\n            lazy[node] = ini_op;\n        }\n    }\n    // base[l:r)をsに更新してセグ木全体を更新する関数\n    void update(int lower, int upper, num_type new_value) {\n        vector<tuple<int, int, int>> stack(1, make_tuple(0, num + 1, 0));\n        set<tuple<int, int>> nodeset;\n        int l, r, m, node, parent, width;\n        num_type value;\n        while (stack.size()) {\n            tie(l, r, node) = stack.back();\n            stack.pop_back();\n            m = (l + r) / 2;\n            width = r - l;\n            if (lower <= l && r <= upper) {\n                lazy[node] = operate(new_value, lazy[node]);\n                value = modify(width, new_value);\n                if (node != 0) {\n                    parent = (node - 1) / 2;\n                    nodeset.insert(make_tuple(parent, width));\n                }\n                if (width == 1) {\n                    value = modify(width, value);\n                    tree[node] = operate(value, tree[node]);\n                    lazy[node] = ini_op;\n                }\n            } else {\n                eval(l, r, node);\n                if (upper <= m) {\n                    stack.push_back(make_tuple(l, m, node * 2 + 1));\n                } else if (m <= lower) {\n                    stack.push_back(make_tuple(m, r, node * 2 + 2));\n                } else {\n                    stack.push_back(make_tuple(l, m, node * 2 + 1));\n                    stack.push_back(make_tuple(m, r, node * 2 + 2));\n                }\n            }\n        }\n        // DEBUG(tree, lazy);\n        num_type tmp1, tmp2;\n        while (nodeset.size()) {\n            tie(node, width) = *rbegin(nodeset);\n            nodeset.erase(make_tuple(node, width));\n            // PRINT(node, width);\n            tmp1 = mod_op(width, node * 2 + 1);\n            tmp2 = mod_op(width, node * 2 + 2);\n            tree[node] = monoid(tmp1, tmp2);\n            if (node != 0) {\n                nodeset.insert(make_tuple((node - 1) >> 1, width << 1));\n            }\n        }\n        // DEBUG(tree, lazy);\n    }\n};\n\nint main() {\n    PRE_COMMAND\n    int n, m;\n    INPUT(n, m);\n\n    ll ini = (ll)(0);\n    vector<ll> iniv(n, ini);\n    segtree<ll> seg(iniv);\n    ll c, x, y, z;\n    for (int i = 0; i < m; i++) {\n        INPUT(c, x, y);\n        if (c == 0) {\n            INPUT(z);\n            seg.update((int)x, (int)y + 1, z);\n        } else {\n            PRINT(seg.search((int)x, (int)y + 1));\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define UNIQUE(v) v.erase(unique(all(v)), v.end());\n#define ZIP(v) sort(all(v)),UNIQUE(v)\n#define ADD(a, b) a = (a + b) % mod\n#define SUB(a, b) a = (a+mod-b)%mod\n#define MUL(a, b) a = (a * b) % mod\n#define repi(i,m,n) for(int i = m;i < n;i++)\n#define drep(i,n,m) for(int i = n;i >= m;i--)\n#define rep(i,n) repi(i,0,n)\n#define rrep(i,n) repi(i,1,n+1)\n#define chmin(x,y) x = min(x,y)\n#define chmax(x,y) x = max(x,y)\n#define all(v) v.begin(),v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define dmp(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define fi first\n#define se second\ntypedef pair<int,int> P;\ntypedef pair<int, P> PP;\ntypedef pair<P, int> Pi;\ntypedef vector<int> vi;\ntypedef deque<int> dq;\nconst int inf = 1e9+7;\nconst int INF = 1e18+7;\n\nclass LazySegmentTree{\npublic:\n\tint n = 1;\n\tvector<int> node[3], lazy;\n\tvector<bool> lazyF;\n\tvoid init(int N){\n\t\twhile(n < N)n *= 2;\n\t\trep(i,3)node[i].resize(2*n-1);\n\t\tlazy.resize(2*n-1);lazyF.resize(2*n-1, false);\n\t}\n\tvoid lazy_evaluate(int k, int l, int r){\n\t\tif(lazyF[k] == false)return;\n\t\trep(i,3)node[i][k] = i==2 ? lazy[k]*(r-l) : lazy[k];\n\t\tif(k < n-1){\n\t\t\trrep(i,2)lazy[2*k+i] = lazy[k];\n\t\t\trrep(i,2)lazyF[2*k+i] = true;\n\t\t}\n\t\tlazyF[k] = false;\n\t}\n\tvoid update(int a, int b, int x, int k, int l, int r){\n\t\tlazy_evaluate(k, l, r);\n\t\tif(r <= a || b <= l)return;\n\t\tif(a <= l && r <= b){\n\t\t\tlazy[k] = x;\n\t\t\tlazyF[k] = true;\n\t\t\tlazy_evaluate(k, l, r);\n\t\t\treturn;\n\t\t}\n\t\tupdate(a, b, x, k*2+1, l, (l+r)/2);\n\t\tupdate(a, b, x, k*2+2, (l+r)/2, r);\n\t\tnode[0][k] = max(node[0][k*2+1], node[0][k*2+2]);\n\t\tnode[1][k] = min(node[1][k*2+1], node[1][k*2+2]);\n\t\tnode[2][k] = node[2][k*2+1]+node[2][k*2+2];\n\t}\n\tint calc(int a, int b, int k, int l, int r, int f){\n\t\tlazy_evaluate(k, l, r);\n\t\tif(r <= a || b <= l)return !f ? -INF : f==1 ? INF : 0;\n\t\tif(a <= l && r <= b)return node[f][k];\n\t\tint vl = calc(a, b, k*2+1, l, (l+r)/2, f);\n\t\tint vr = calc(a, b, k*2+2, (l+r)/2, r, f);\n\t\treturn !f ? max(vl, vr) : f==1 ? min(vl, vr) : vl+vr;\n\t}\n\tvoid replace(int a, int b, int x){update(a, b, x, 0, 0, n);}\n\tint get_max(int a, int b){return calc(a, b, 0, 0, n, 0);}\n\tint get_min(int a, int b){return calc(a, b, 0, 0, n, 1);}\n\tint get_sum(int a, int b){return calc(a, b, 0, 0, n, 2);}\n};\n\nsigned main(){\n\tint n, q, MAX = (1LL<<31)-1;\n\tscanf(\"%lld%lld\", &n, &q);\n\tLazySegmentTree seg;\n\tseg.init(n+1);\n\t//rep(i,n)seg.replace(i, i+1, MAX);\n\t\n\trrep(i,q){\n\t\tint c, s, t, x;\n\t\tscanf(\"%lld\",&c);\n\t\tif(c == 0){\n\t\t\tscanf(\"%lld%lld%lld\", &s, &t, &x);\n\t\t\tseg.replace(s, t+1, x);\n\t\t}else{\n\t\t\tscanf(\"%lld%lld\", &s, &t);\n\t\t\tprintf(\"%lld\\n\", seg.get_sum(s, t+1));\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<ll> vl;\ntypedef pair<ll, ll> PP;\n#define rep(i, n) for(ll i = 0; i < ll(n); i++)\n#define all(v) v.begin(), v.end()\nbool chmin(ll & a, ll  b) { if (b < a) { a = b; return 1; } return 0; }\nbool chmax(ll & a, ll b) { if (b > a) { a = b; return 1; } return 0; }\nconst ll INF = (1LL<<31)-1;\nconst ll MOD = 1000000007;\nconst ll MAX_N=500010;\nll a, b, c, d, e, f, p, t, x, y, z, q, m, n, r, h, k, w, l, ans;\ntemplate <typename T,typename E>\nstruct SegmentTree{\n  typedef function<T(T,T)> F;\n  typedef function<T(T,E)> G;\n  typedef function<E(E,E)> H;\n  typedef function<E(E,ll)> P;\n  ll n;\n  F f;\n  G g;\n  H h;\n  P p;\n  T d1;\n  E d0;\n  vector<T> dat;\n  vector<E> laz;\n  SegmentTree(ll n_,F f,G g,H h,T d1,E d0,\n\t      vector<T> v=vector<T>(),P p=[](E a,ll b){return a;}):\n    f(f),g(g),h(h),d1(d1),d0(d0),p(p){\n    init(n_);\n    if(n_==(ll)v.size()) build(n_,v);\n  }\n  void init(ll n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.clear();\n    dat.resize(2*n-1,d1);\n    laz.clear();\n    laz.resize(2*n-1,d0);\n  }\n  void build(ll n_, vector<T> v){\n    for(ll i=0;i<n_;i++) dat[i+n-1]=v[i];\n    for(ll i=n-2;i>=0;i--)\n      dat[i]=f(dat[i*2+1],dat[i*2+2]);\n  }\n  inline void eval(ll len,ll k){\n    if(laz[k]==d0) return;\n    if(k*2+1<n*2-1){\n      laz[k*2+1]=h(laz[k*2+1],laz[k]);\n      laz[k*2+2]=h(laz[k*2+2],laz[k]);\n    }\n    dat[k]=g(dat[k],p(laz[k],len));\n    laz[k]=d0;\n  }\n  T update(ll a,ll b,E x,ll k,ll l,ll r){\n    eval(r-l,k);\n    if(r<=a||b<=l) return dat[k];\n    if(a<=l&&r<=b){\n      laz[k]=h(laz[k],x);\n      return g(dat[k],p(laz[k],r-l));\n    }\n    return dat[k]=f(update(a,b,x,k*2+1,l,(l+r)/2),\n\t\t    update(a,b,x,k*2+2,(l+r)/2,r));\n  }\n  T update(ll a,ll b,E x){\n    return update(a,b,x,0,0,n);\n  }\n  T query(ll a,ll b,ll k,ll l,ll r){\n    eval(r-l,k);\n    if(r<=a||b<=l) return d1;\n    if(a<=l&&r<=b) return dat[k];\n    T vl=query(a,b,k*2+1,l,(l+r)/2);\n    T vr=query(a,b,k*2+2,(l+r)/2,r);\n    return f(vl,vr);\n  }\n  T query(ll a,ll b){\n    return query(a,b,0,0,n);\n  }\n};\nauto F = [](ll a, ll b) { return a + b; };\nauto G=[](ll a, ll b) { return b == INF ? a : b; };\nauto H = G;\nSegmentTree<ll, ll> seg(MAX_N, F, G, H, 0, INF, vl(MAX_N, 0),multiplies<ll>());\nint main() { cin >> n >> q; \nwhile(q--){\n    cin >> x;\n    if(x==0){\n        cin >> a >> b >> c;\n        seg.update(a, b + 1, c);\n    }\n    else{\n        cin >> a >> b;\n        cout << seg.query(a, b + 1)<<endl;\n    }\n}}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define EACH(i, c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(begin(c),end(c))\n#define pb emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\n//#define LOCAL 0\n//#ifdef LOCAL\n//#define DEBUG(s) cout << (s) << endl\n//#define dump(x)  cerr << #x << \" = \" << (x) << endl\n//#define BR cout << endl;\n//#else\n//#define DEBUG(s) do{}while(0)\n//#define dump(x) do{}while(0)\n//#define BR\n//#endif\n\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n//ここから編集する\n\ntemplate<typename T, typename E>\nstruct SegmentTree {\n    using F = function<T(T, T)>;\n    using G = function<T(T, E)>;\n    using H = function<E(E, E)>;\n    using P = function<E(E, size_t)>;\n    int n;\n    F f; //要素と要素のマージ\n    G g; //要素に作用素を作用\n    H h; //作用素と作用素をマージ\n    T ti; //要素の単位元?\n    E ei; //作用素の単位元?\n    P p; //b個の作用素aをマージした場合\n    vector<T> dat;\n    vector<E> laz;\n\n    SegmentTree(int n_, F f, G g, H h, T ti, E ei,\n                P p = [](E a, size_t b) {\n                    b++;\n                    return a;\n                }) :\n            f(f), g(g), h(h), ti(ti), ei(ei), p(p) {\n        init(n_);\n    }\n\n    void init(int n_) {\n        n = 1;\n        while (n < n_) n *= 2;\n        dat.assign(2 * n - 1, ti);\n        laz.assign(2 * n - 1, ei);\n    }\n\n    void build(int n_, vector<T> v) {\n        for (int i = 0; i < n_; i++) dat[i + n - 1] = v[i];\n        for (int i = n - 2; i >= 0; i--)\n            dat[i] = f(dat[i * 2 + 1], dat[i * 2 + 2]);\n    }\n\n    inline void eval(int len, int k) {\n        if (laz[k] == ei) return;\n        if (k * 2 + 1 < n * 2 - 1) {\n            laz[k * 2 + 1] = h(laz[k * 2 + 1], laz[k]);\n            laz[k * 2 + 2] = h(laz[k * 2 + 2], laz[k]);\n        }\n        dat[k] = g(dat[k], p(laz[k], len));\n        laz[k] = ei;\n    }\n\n    T update(int a, int b, E x, int k, int l, int r) {\n        eval(r - l, k);\n        if (r <= a || b <= l) return dat[k];\n        if (a <= l && r <= b) {\n            laz[k] = h(laz[k], x);\n            return g(dat[k], p(laz[k], r - l));\n        }\n        return dat[k] = f(update(a, b, x, k * 2 + 1, l, (l + r) / 2),\n                          update(a, b, x, k * 2 + 2, (l + r) / 2, r));\n    }\n\n    T update(int a, int b, E x) {\n        return update(a, b, x, 0, 0, n);\n    }\n\n    T query(int a, int b, int k, int l, int r) {\n        eval(r - l, k);\n        if (r <= a || b <= l) return ti;\n        if (a <= l && r <= b) return dat[k];\n        T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return f(vl, vr);\n    }\n\n    T query(int a, int b) {\n        return query(a, b, 0, 0, n);\n    }\n\n    /**\n     * kをxに更新する\n     */\n    void update(int k, T x) {\n        query(k, k + 1);//evaluate\n        k += n - 1;\n        dat[k] = x;\n        while (k) {\n            k = (k - 1) / 2;\n            dat[k] = f(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, q;\n    cin >> n >> q;\n\n    using T = pair<ll, int>;\n    using E = pair<ll, int>;\n    auto f = [](T a, T b) {\n        a.first += b.first;\n        a.second = max(a.second, b.second);\n        return a;\n    }; // 要素と要素のマージ\n\n    auto g = [](T a, E b) {\n        if (a.second > b.second) {\n            return a;\n        } else {\n            return b;\n        }\n    }; // 要素に作用素を作用\n\n    auto h = [](E a, E b) {\n        if (a.second > b.second) {\n            return a;\n        } else {\n            return b;\n        }\n    }; // 作用素と作用素をマージ\n\n    auto p = [](E a, int b) {\n        a.first *= b;\n        return a;\n    }; // 作用素を区間加算する場合\n    T ti = pair<ll, int>(0, 0); //要素の単位元?\n    E ei = pair<ll, int>(0, 0); //作用素の単位元?\n    SegmentTree<T, E> treeone(n, f, g, h, ti, ei, p);\n\n    int time = 0;\n    while (q--) {\n        int cmd;\n        cin >> cmd;\n        if (cmd) {\n            int s, t;\n            cin >> s >> t;\n\n            cout << treeone.query(s, t + 1).first << endl;\n\n        } else {\n            int s, t, x;\n            cin >> s >> t >> x;\n            pair<int, int> tmp(x, ++time);\n            treeone.update(s, t + 1, tmp);\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n\nusing namespace std;\n\nusing i64 = long long;\n\n\ntemplate <typename T>\nstruct MemoryPool{\n    int siz, idx;\n    stack<int> st;\n    vector<T*> pool;\n    struct Index{\n        int idx;\n        friend bool operator==(const Index& a, const Index& b){return a.idx == b.idx;}\n        friend bool operator!=(const Index& a, const Index& b){return a.idx != b.idx;}\n    };\n    MemoryPool() : siz(1), idx(0){}\n    void resize(){\n        pool.emplace_back(new T[siz]);\n        siz <<= 1;\n    }\n    Index alloc(){\n        if(!st.empty()){\n            int res = st.top();\n            st.pop();\n            return {res};\n        }\n        if(++idx == siz)\n            resize();\n        return {idx};\n    }\n    void free(Index x){\n        st.push(x.idx);\n    }\n    T& operator[](Index x){return pool[31 - __builtin_clz(x.idx)][x.idx & ~(1 << (31 - __builtin_clz(x.idx)))];}\n};\n\n\n// merge/split ベースの赤黒木(葉木)\ntemplate <typename T, typename U>\nstruct RedBlackTree{\n\n    struct Node;\n    using Index = typename MemoryPool<Node>::Index;\n\n    struct Node{\n        int siz, level;\n        T sum;\n        U lazy;\n        bool red;\n        typename MemoryPool<Node>::Index l, r;\n        Node(){}\n        Node(T val, U lazy, bool red, bool leaf, int li = -1, int ri = -1) : sum(val), lazy(lazy), siz(leaf), level(0), red(red){\n            l = {li};\n            r = {ri};\n        }\n    };\n\n    MemoryPool<Node> pool;\n    Index nil;\n    function<T(T, T)> f;\n    function<T(T, U, int)> g;\n    function<U(U, U)> h;\n    T op_t;\n    U op_u;\n    RedBlackTree(function<T(T, T)> f, function<T(T, U, int)> g, function<U(U, U)> h, T op_t, U op_u) : f(f), g(g), h(h), op_t(op_t), op_u(op_u){\n        nil = pool.alloc();\n        pool[nil] = Node(op_t, op_u, false, false);\n        pool[nil].l = pool[nil].r = nil;\n    }\n\n    Index build(vector<T>& a){\n        nil = pool.alloc();\n        pool[nil] = Node(op_t, op_u, false, false);\n        pool[nil].l = pool[nil].r = nil;\n        int siz = a.size();\n        vector<Index> v(siz);\n        for(int i = 0; i < siz; ++i)\n            v[i] = make(a[i]);\n        while(siz != 1){\n            int nex_siz = (siz + 1) >> 1;\n            vector<Index> nex(nex_siz);\n            for(int i = 0; i < (siz >> 1); ++i)\n                nex[i] = merge(v[2 * i], v[2 * i + 1]);\n            if(siz & 1)\n                nex.back() = v.back();\n            siz = nex_siz;\n            v = move(nex);\n        }\n        return v[0];\n    }\n\n    Index index(int x){return {x};}\n\n    T get_val(Index pi){\n        auto& p = get(pi);\n        return g(p.sum, p.lazy, p.siz);\n    }\n\n    void eval(Index pi){\n        if(pi == nil)\n            return;\n        auto& p = get(pi);\n        if(p.lazy == op_u)\n            return;\n        if(p.l != nil){\n            auto& l = get(p.l);\n            l.lazy = h(l.lazy, p.lazy);\n            auto& r = get(p.r);\n            r.lazy = h(r.lazy, p.lazy);\n        }\n        p.sum = get_val(pi);\n        p.lazy = op_u;\n    }\n\n    void update(Index pi){\n        if(pi == nil)\n            return;\n        auto& p = get(pi);\n        auto& l = get(p.l);\n        auto& r = get(p.r);\n        p.siz = l.siz + r.siz;\n        if(p.l != nil || p.r != nil)\n            p.sum = f(get_val(p.l), get_val(p.r));\n        p.level = l.level + !l.red;\n        assert(p.level == r.level + !r.red);\n    }\n\n    Index make(T val){\n        Index idx = pool.alloc();\n        pool[idx] = Node(val, op_u, false, true, nil.idx, nil.idx);\n        pool[idx].level = 1;\n        return idx;\n    }\n\n    Index mergeSub(Index ai, Index bi){\n        eval(ai);\n        eval(bi);\n        auto& a = get(ai);\n        auto& b = get(bi);\n        assert(ai != nil && bi != nil);\n        if(a.level < b.level){\n            Index ci = mergeSub(ai, b.l);\n            auto& c = get(ci);\n            if(!b.red && c.red && get(c.l).red){\n                if(!get(b.r).red){\n                    b.l = c.l;\n                    c.l = c.r;\n                    c.r = b.r;\n                    b.r = ci;\n                    update(ci);\n                    update(bi);\n                    return bi;\n                }\n                else{\n                    b.l = ci;\n                    b.red ^= 1;\n                    get(b.l).red ^= 1;\n                    get(b.r).red ^= 1;\n                    update(bi);\n                    return bi;\n                }\n            }\n            b.l = ci;\n            update(bi);\n            return bi;\n        }\n        else if(a.level > b.level){\n            Index ci = mergeSub(a.r, bi);\n            auto& c = get(ci);\n            if(!a.red && c.red && get(c.r).red){\n                if(!get(a.l).red){\n                    a.r = c.r;\n                    c.r = c.l;\n                    c.l = a.l;\n                    a.l = ci;\n                    update(ci);\n                    update(ai);\n                    return ai;\n                }\n                else{\n                    a.r = ci;\n                    a.red ^= 1;\n                    get(a.l).red ^= 1;\n                    get(a.r).red ^= 1;\n                    update(ai);\n                    return ai;\n                }\n            }\n            a.r = ci;\n            update(ai);\n            return ai;\n        }\n        else{\n            a.red = false;\n            b.red = false;\n            Index d = pool.alloc();\n            get(d) = Node(op_t, op_u, true, false, ai.idx, bi.idx);\n            update(d);\n            return d;\n        }\n    }\n\n    Index merge(Index ai, Index bi){\n        if(ai == nil)\n            return bi;\n        if(bi == nil)\n            return ai;\n        Index ci = mergeSub(ai, bi);\n        get(ci).red = false;\n        return ci;\n    }\n\n    pair<Index, Index> split(Index ai, int k){\n        eval(ai);\n        auto& a = get(ai);\n        if(k == 0)\n            return make_pair(nil, ai);\n        if(k == a.siz)\n            return make_pair(ai, nil);\n        Index li = a.l;\n        Index ri = a.r;\n        auto& l = get(li);\n        pool.free(ai);\n        if(k < l.siz){\n            auto res = split(li, k);\n            return make_pair(res.first, merge(res.second, ri));\n        }\n        else if(k > get(a.l).siz){\n            auto res = split(ri, k - l.siz);\n            return make_pair(merge(li, res.first), res.second);\n        }\n        else{\n            return make_pair(li, ri);\n        }\n    }\n\n    pair<T, Index> range_get(Index pi, int l, int r){\n        auto res = split(pi, r);\n        auto res2 = split(res.first, l);\n        T val = get_val(res2.second);\n        return make_pair(val, merge(merge(res2.first, res2.second), res.second));\n    }\n\n    Index range_update(Index pi, int l, int r, U val){\n        if(l == r)\n            return pi;\n        auto res = split(pi, r);\n        auto res2 = split(res.first, l);\n        auto& mid = get(res2.second);\n        mid.lazy = h(mid.lazy, val);\n        eval(res2.second);\n        return merge(merge(res2.first, res2.second), res.second);\n    }\n\n    Index insert(Index pi, int k, T val){\n        auto res = split(pi, k);\n        return merge(res.first, merge(make(val), res.second));\n    }\n\n    Index erase(Index pi, int k){\n        auto res = split(pi, k + 1);\n        auto res2 = split(res.first, k);\n        pool.free(res2.second);\n        return merge(res2.first, res.second);\n    }\n\n    Index access(Index pi, int k){\n        while(get(pi).l != nil || get(pi).r != nil){\n            eval(pi);\n            auto& p = get(pi);\n            assert(p.l != nil && p.r != nil);\n            if(get(p.l).siz <= k){\n                k -= get(p.l).siz;\n                pi = p.r;\n            }\n            else{\n                pi = p.l;\n            }\n        }\n        return pi;\n    }\n\n    void set(Index pi, int k, T val, function<T(T, T)> af = [](T x, T y){return y;}){\n        stack<Index> st;\n        while(get(pi).l != nil || get(pi).r != nil){\n            eval(pi);\n            auto& p = get(pi);\n            st.push(pi);\n            assert(p.l != nil && p.r != nil);\n            if(get(p.l).siz <= k){\n                k -= get(p.l).siz;\n                pi = p.r;\n            }\n            else{\n                pi = p.l;\n            }\n        }\n        auto& p = get(pi);\n        eval(pi);\n        p.sum = af(p.sum, val);\n        while(!st.empty()){\n            update(st.top());\n            st.pop();\n        }\n    }\n\n    Node& get(Index k){return pool[k];}\n    Node& operator[](Index k){return pool[k];}\n};\n\n\n\n\nsigned main(){\n    int n, q;\n    scanf(\"%d%d\", &n, &q);\n    RedBlackTree<int, int> s([](auto x, auto y){return x + y;}, [](auto x, auto y, int z){return y == 100000 ? x : y * z;}, [](auto x, auto y){return y == 100000 ? x : y;}, 0, 100000);\n    auto root = s.nil;\n    for(int i = 0; i < n; ++i)\n        root = s.insert(root, i, 0);\n    for(int i = 0; i < q; ++i){\n        int t;\n        scanf(\"%d\", &t);\n        if(t == 0){\n            int l, r, x;\n            scanf(\"%d%d%d\", &l, &r, &x);\n            root = s.range_update(root, l, r + 1, x);\n        }\n        else{\n            int l, r;\n            scanf(\"%d%d\", &l, &r);\n            auto res = s.range_get(root, l, r + 1);\n            root = res.second;\n            printf(\"%d\\n\", res.first);\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\n\nconst int64 infll = (1LL << 62) - 1;\nconst int inf = (1 << 30) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\ntemplate< typename F >\nstruct FixPoint : F {\n  FixPoint(F &&f) : F(forward< F >(f)) {}\n\n  template< typename... Args >\n  decltype(auto) operator()(Args &&... args) const {\n    return F::operator()(*this, forward< Args >(args)...);\n  }\n};\n\ntemplate< typename F >\ninline decltype(auto) MFP(F &&f) {\n  return FixPoint< F >{forward< F >(f)};\n}\n\ntemplate< typename Monoid, typename OperatorMonoid = Monoid >\nstruct LazySegmentTree {\n  using F = function< Monoid(Monoid, Monoid) >;\n  using G = function< Monoid(Monoid, OperatorMonoid) >;\n  using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n\n  int sz, height;\n  vector< Monoid > data;\n  vector< OperatorMonoid > lazy;\n  const F f;\n  const G g;\n  const H h;\n  const Monoid M1;\n  const OperatorMonoid OM0;\n\n\n  LazySegmentTree(int n, const F f, const G g, const H h,\n                  const Monoid &M1, const OperatorMonoid OM0)\n      : f(f), g(g), h(h), M1(M1), OM0(OM0) {\n    sz = 1;\n    height = 0;\n    while(sz < n) sz <<= 1, height++;\n    data.assign(2 * sz, M1);\n    lazy.assign(2 * sz, OM0);\n  }\n\n  void set(int k, const Monoid &x) {\n    data[k + sz] = x;\n  }\n\n  void build() {\n    for(int k = sz - 1; k > 0; k--) {\n      data[k] = f(data[2 * k + 0], data[2 * k + 1]);\n    }\n  }\n\n  inline void propagate(int k) {\n    if(lazy[k] != OM0) {\n      lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n      lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n      data[k] = reflect(k);\n      lazy[k] = OM0;\n    }\n  }\n\n  inline Monoid reflect(int k) {\n    return lazy[k] == OM0 ? data[k] : g(data[k], lazy[k]);\n  }\n\n  inline void recalc(int k) {\n    while(k >>= 1) data[k] = f(reflect(2 * k + 0), reflect(2 * k + 1));\n  }\n\n  inline void thrust(int k) {\n    for(int i = height; i > 0; i--) propagate(k >> i);\n  }\n\n  Monoid update(int a, int b, const OperatorMonoid &x) {\n    thrust(a += sz);\n    thrust(b += sz - 1);\n    for(int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) lazy[l] = h(lazy[l], x), ++l;\n      if(r & 1) --r, lazy[r] = h(lazy[r], x);\n    }\n    recalc(a);\n    recalc(b);\n  }\n\n  Monoid query(int a, int b) {\n    thrust(a += sz);\n    thrust(b += sz - 1);\n    Monoid L = M1, R = M1;\n    for(int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) L = f(L, reflect(l++));\n      if(r & 1) R = f(reflect(--r), R);\n    }\n    return f(L, R);\n  }\n\n  Monoid operator[](const int &k) {\n    return query(k, k + 1);\n  }\n};\n\n\nint main() {\n  int N, Q;\n  cin >> N >> Q;\n  using pi = pair< int64, int >;\n  auto f = [](const pi &a, const pi &b) { return pi(a.first + b.first, a.second + b.second); };\n  auto g = [](const pi &a, int b) { return pi(a.second * b, a.second); };\n  auto h = [](int a, int b) { return b; };\n  LazySegmentTree< pi, int > seg(N, f, g, h, pi(0, 0), inf);\n  for(int i = 0; i < N; i++) seg.set(i, pi(0, 1));\n  seg.build();\n  while(Q--) {\n    int t, a, b, c;\n    cin >> t >> a >> b;\n    ++b;\n    if(t == 0) {\n      cin >> c;\n      seg.update(a, b, c);\n    } else {\n      cout << seg.query(a, b).first << \"\\n\";\n    }\n  }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<algorithm>\n#include <vector>\n#include <functional>\n\ntemplate<typename T, typename S>\nstruct LazySegTree{\n    int size;\n    std::vector<T> nod;\n    std::vector<S> monoid;\n    std::vector<bool> flag;\n    T t0;\n    S s0;\n    std::function<T(T,T)> operation;\n    std::function<S(S,S)> merge;\n    std::function<T(T,S,int)> calc;\n    LazySegTree(int n, T _t0, S _s0, std::function<T(T,T)> _operation, std::function<S(S,S)> _merge, std::function<T(T,S,int)> _calc){\n        t0 = _t0;\n        s0 = _s0;\n        operation = _operation;\n        merge = _merge;\n        calc = _calc;\n        size = 1;\n        while(n > size) size *= 2;\n        nod = std::vector<T> (size*2-1, t0);\n        monoid = std::vector<S> (size*2-1, s0);\n        flag = std::vector<bool> (size*2-1);\n    }\n    void disassembly(int k, int l, int r){\n        if(r-l>1){\n            monoid[k*2+1] = merge(monoid[k*2+1], monoid[k]);\n            monoid[k*2+2] = merge(monoid[k*2+2], monoid[k]);\n            flag[k*2+1] = true;\n            flag[k*2+2] = true;\n        }\n        nod[k] = calc(nod[k],monoid[k],r-l);\n        monoid[k] = s0;\n        flag[k] = false;\n    }\n    S update_query(int a,int b,int k,int l,int r,S x){\n        //[a,b)について\n        //kは節点の番号,[l,r)はその節点がカバーする範囲\n        if(r<=a||b<=l){ //[a,b)と[l,r)が重なって無いとき\n            if(flag[k]) return calc(nod[k], monoid[k], r-l);\n            return nod[k];\n        }\n        if(a<=l && r<=b){ //[a,b)が[l,r)を完全に含んでいるとき\n            monoid[k] = merge(monoid[k], x);\n            flag[k] = true;\n            return calc(nod[k], monoid[k],r-l);\n        }\n        else{\n            if(flag[k]) disassembly(k,l,r);\n            nod[k] = operation(update_query(a,b,k*2+1,l,(l+r)/2,x), update_query(a,b,k*2+2,(l+r)/2,r,x));\n            return nod[k];\n        }\n    }\n    void update(int a, int b, S x){\n        // [a,b)をxに更新\n        update_query(a,b,0,0,size,x);\n    }\n    T sum_query(int a,int b,int k,int l,int r){\n        if(r<=a||b<=l){\n            return t0;\n        }\n        if(a<=l && r<=b){\n            if(flag[k]) return calc(nod[k],monoid[k],r-l);\n            else return nod[k];\n        }\n        if(flag[k]) disassembly(k, l, r);\n        return operation(sum_query(a,b,k*2+1,l,(l+r)/2),sum_query(a,b,k*2+2,(l+r)/2,r));\n    }\n    T sum(int a, int b){\n        return sum_query(a,b,0,0,size);\n    }\n   void deb(){ //全ノードの出力\n\t\tfor(int i=0;i<size*2-1;i++){\n\t\t\tif(i==size*2-2){\n\t\t\t\tstd::cout << nod[i] <<std:: endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstd::cout << nod[i] << ' ';\n\t\t\t}\n\t\t}\n        for(int i=0;i<size*2-1;i++){\n\t\t\tif(i==size*2-2){\n\t\t\t\tstd::cout << monoid[i] <<std:: endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstd::cout << monoid[i] << ' ';\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n};\n\nint main(){\n    int n,q; std::cin >> n >> q;\n    std::vector<int> ans(0);\n    LazySegTree<long long, long long> lst(n,0,0,[](long long a, long long b){return a+b;}, [](long long a, long long b){return b;},[](long long a, long long b, long long c){return b*c;});\n    for(int i= 0;i<q;i++){\n        int w; std::cin >> w;\n        if(w == 0){\n            int s,t,x; std::cin >> s >> t >> x;\n            lst.update(s, t+1, x);\n        }\n        else{\n            int s,t; std::cin >> s >> t;\n            ans.push_back(lst.sum(s,t+1));\n        }\n        //lst.deb();\n    }\n    for(int i = 0;i<ans.size();i++) std::printf(\"%d\\n\", ans[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=1<<18;\nconst ll INF=1LL<<60;\n\nint n;\nll max_fi[2*MAX-1],max_se[2*MAX-1],max_cnt[2*MAX-1];\nll min_fi[2*MAX-1],min_se[2*MAX-1],min_cnt[2*MAX-1];\nll sum[2*MAX-1];\nll lazyadd[2*MAX-1],lazyupdate[2*MAX-1];\nbool done[2*MAX-1];\n\nvoid init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n}\n\nvoid update_node_max(ll x,int k){\n    sum[k]+=(x-max_fi[k])*max_cnt[k];\n    \n    if(max_fi[k]==min_fi[k]){\n        max_fi[k]=min_fi[k]=x;\n    }else if(max_fi[k]==min_se[k]){\n        max_fi[k]=min_se[k]=x;\n    }else{\n        max_fi[k]=x;\n    }\n}\n\nvoid update_node_min(ll x,int k){\n    sum[k]+=(x-min_fi[k])*min_cnt[k];\n    \n    if(min_fi[k]==max_fi[k]){\n        min_fi[k]=max_fi[k]=x;\n    }else if(min_fi[k]==max_se[k]){\n        min_fi[k]=max_se[k]=x;\n    }else{\n        min_fi[k]=x;\n    }\n}\n\nvoid update_node_(ll x,int k,int l,int r){\n    max_fi[k]=x;\n    max_se[k]=-INF;\n    max_cnt[k]=r-l;\n    \n    min_fi[k]=x;\n    min_se[k]=INF;\n    min_cnt[k]=r-l;\n    \n    sum[k]=x*(r-l);\n    \n    lazyupdate[k]=x;\n    done[k]=1;\n    //lazyadd[k]=0;\n}\n\nvoid update_node_add(ll x,int k,int l,int r){\n    max_fi[k]+=x;\n    if(max_se[k]!=-INF) max_se[k]+=x;\n    max_cnt[k]=r-l;\n    \n    min_fi[k]+=x;\n    if(min_se[k]!=INF) min_se[k]+=x;\n    min_cnt[k]=r-l;\n    \n    sum[k]+=x*(r-l);\n    \n    if(done[k]){\n        lazyupdate[k]+=x;\n    }else{\n        lazyadd[k]+=x;\n    }\n}\n\nvoid eval(int k,int l,int r){\n    \n    if(l==r) return;\n    \n    if(done[k]){\n        update_node_(lazyupdate[k],2*k+1,l,(l+r)/2);\n        update_node_(lazyupdate[k],2*k+2,(l+r)/2,r);\n        done[k]=0;\n        //return;\n    }\n    \n    if(lazyadd[k]){\n        update_node_add(lazyadd[k],2*k+1,l,(l+r)/2);\n        update_node_add(lazyadd[k],2*k+2,(l+r)/2,r);\n        lazyadd[k]=0;\n    }\n    \n    if(max_fi[k]<max_fi[2*k+1]){\n        update_node_max(max_fi[k],2*k+1);\n    }\n    if(min_fi[k]>min_fi[2*k+1]){\n        update_node_min(min_fi[k],2*k+1);\n    }\n    if(max_fi[k]<max_fi[2*k+2]){\n        update_node_max(max_fi[k],2*k+2);\n    }\n    if(min_fi[k]>min_fi[2*k+2]){\n        update_node_min(min_fi[k],2*k+2);\n    }\n}\n\nvoid merge(int k){\n    sum[k]=sum[2*k+1]+sum[2*k+2];\n    \n    if(max_fi[2*k+1]>max_fi[2*k+2]){\n        max_fi[k]=max_fi[2*k+1];\n        max_cnt[k]=max_cnt[2*k+1];\n        max_se[k]=max(max_se[2*k+1],max_fi[2*k+2]);\n    }else if(max_fi[2*k+1]<max_fi[2*k+2]){\n        max_fi[k]=max_fi[2*k+2];\n        max_cnt[k]=max_cnt[2*k+2];\n        max_se[k]=max(max_fi[2*k+1],max_se[2*k+2]);\n    }else{\n        max_fi[k]=max_fi[2*k+1];\n        max_cnt[k]=max_cnt[2*k+1]+max_cnt[2*k+2];\n        max_se[k]=max(max_se[2*k+1],max_se[2*k+2]);\n    }\n    \n    if(min_fi[2*k+1]<min_fi[2*k+2]){\n        min_fi[k]=min_fi[2*k+1];\n        min_cnt[k]=min_cnt[2*k+1];\n        min_se[k]=min(min_se[2*k+1],min_fi[2*k+2]);\n    }else if(min_fi[2*k+1]>min_fi[2*k+2]){\n        min_fi[k]=min_fi[2*k+2];\n        min_cnt[k]=min_cnt[2*k+2];\n        min_se[k]=min(min_fi[2*k+1],min_se[2*k+2]);\n    }else{\n        min_fi[k]=min_fi[2*k+1];\n        min_cnt[k]=min_cnt[2*k+1]+min_cnt[2*k+2];\n        min_se[k]=min(min_se[2*k+1],min_se[2*k+2]);\n    }\n}\n\nvoid update_chmax(int a,int b,ll x,int k,int l,int r){\n    \n    eval(k,l,r);\n    \n    if(r<=a||b<=l||min_fi[k]>=x) return;\n    \n    if(a<=l&&r<=b&&min_se[k]>x){\n        update_node_min(x,k);\n    }else{\n        update_chmax(a,b,x,2*k+1,l,(l+r)/2);\n        update_chmax(a,b,x,2*k+2,(l+r)/2,r);\n        \n        merge(k);\n    }\n}\n\nvoid update_chmin(int a,int b,ll x,int k,int l,int r){\n    \n    eval(k,l,r);\n    \n    if(r<=a||b<=l||max_fi[k]<=x) return;\n    \n    if(a<=l&&r<=b&&max_se[k]<x){\n        update_node_max(x,k);\n    }else{\n        update_chmin(a,b,x,2*k+1,l,(l+r)/2);\n        update_chmin(a,b,x,2*k+2,(l+r)/2,r);\n        \n        merge(k);\n    }\n}\n\nvoid update(int a,int b,ll x,int k,int l,int r){\n    eval(k,l,r);\n    \n    if(r<=a||b<=l) return;\n    \n    if(a<=l&&r<=b){\n        update_node_(x,k,l,r);\n    }else{\n        update(a,b,x,2*k+1,l,(l+r)/2);\n        update(a,b,x,2*k+2,(l+r)/2,r);\n        merge(k);\n    }\n}\n\nvoid add(int a,int b,ll x,int k,int l,int r){\n    eval(k,l,r);\n    \n    if(r<=a||b<=l) return;\n    \n    if(a<=l&&r<=b){\n        update_node_add(x,k,l,r);\n    }else{\n        add(a,b,x,2*k+1,l,(l+r)/2);\n        add(a,b,x,2*k+2,(l+r)/2,r);\n        merge(k);\n    }\n}\n\nll query_sum(int a,int b,int k,int l,int r){\n    \n    if(r<=a||b<=l) return 0;\n    \n    eval(k,l,r);\n    \n    if(a<=l&&r<=b) return sum[k];\n    \n    ll vl=query_sum(a,b,2*k+1,l,(l+r)/2);\n    ll vr=query_sum(a,b,2*k+2,(l+r)/2,r);\n    return vl+vr;\n}\n\nll query_max(int a,int b,int k,int l,int r){\n    \n    if(r<=a||b<=l) return -INF;\n    \n    eval(k,l,r);\n    \n    if(a<=l&&r<=b) return max_fi[k];\n    \n    ll vl=query_max(a,b,2*k+1,l,(l+r)/2);\n    ll vr=query_max(a,b,2*k+2,(l+r)/2,r);\n    return max(vl,vr);\n}\n\nll query_min(int a,int b,int k,int l,int r){\n    \n    if(r<=a||b<=l) return INF;\n    \n    eval(k,l,r);\n    \n    if(a<=l&&r<=b) return min_fi[k];\n    \n    ll vl=query_min(a,b,2*k+1,l,(l+r)/2);\n    ll vr=query_min(a,b,2*k+2,(l+r)/2,r);\n    return min(vl,vr);\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N,Q;cin>>N>>Q;\n    init(N);\n    \n    /*for(int i=0;i<N;i++){\n        ll x;cin>>x;\n        update(i,i+1,x,0,0,n);\n    }\n    \n    while(Q--){\n        int t;cin>>t;\n        if(t==0){\n            int a,b;ll x;cin>>a>>b>>x;\n            update_chmin(a,b,x,0,0,n);\n        }else if(t==1){\n            int a,b;ll x;cin>>a>>b>>x;\n            update_chmax(a,b,x,0,0,n);\n        }else if(t==2){\n            int a,b;ll x;cin>>a>>b>>x;\n            add(a,b,x,0,0,n);\n        }else{\n            int a,b;cin>>a>>b;\n            cout<<query_sum(a,b,0,0,n)<<endl;\n        }\n    }*/\n    \n    while(Q--){\n        int t;cin>>t;\n        if(t==0){\n            int a,b;ll x;cin>>a>>b>>x;\n            b++;\n            update(a,b,x,0,0,n);\n        }else{\n            int a,b;cin>>a>>b;\n            b++;\n            cout<<query_sum(a,b,0,0,n)<<endl;\n        }\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\ntemplate<typename Monoid, typename OperatorMonoid=Monoid>\nstruct LazySegmentTree{\n\tusing F=function<Monoid(Monoid, Monoid)>;\n\tusing G=function<Monoid(Monoid, OperatorMonoid, int)>;\n\tusing H=function<OperatorMonoid(OperatorMonoid, OperatorMonoid)>;\n\tint sz;\n\tvector<Monoid> data;\n\tvector<OperatorMonoid> lazy;\n\tconst F f;\n\tconst G g;\n\tconst H h;\n\tconst Monoid e1;\n\tconst OperatorMonoid e0;\n\n\tLazySegmentTree(int n, const F f, const G g, const H h, const Monoid &e1, const OperatorMonoid &e0): f(f), g(g), h(h), e1(e1), e0(e0){\n\t\tsz=1;\n\t\twhile(sz<n) sz<<=1;\n\t\tdata.resize(2*sz-1, e1);\n\t\tlazy.resize(2*sz-1, e0);\n\t}\n\n\tvoid build(vector<Monoid> v){\n\t\tfor(int i=0; i<v.size(); i++) data[i+sz-1]=v[i];\n\t\tfor(int i=sz-2; i>=0; i--) data[i]=f(data[2*i+1], data[2*i+2]);\n\t}\n\n\tvoid eval(int k, int l, int r){\n\t\tif(lazy[k]!=e0){\n\t\t\tdata[k]=g(data[k], lazy[k], r-l);\n\t\t\tif(k<sz-1){\n\t\t\t\tlazy[2*k+1]=h(lazy[2*k+1], lazy[k]);\n\t\t\t\tlazy[2*k+2]=h(lazy[2*k+2], lazy[k]);\n\t\t\t}\n\t\t}\n\t\tlazy[k]=e0;\n\t}\n\n\tvoid update(int a, int b, const OperatorMonoid &x, int k, int l, int r){\n\t\teval(k, l, r);\n\t\tif(r<=a || b<=l) return;\n\t\tif(a<=l && r<=b){\n\t\t\tlazy[k]=h(lazy[k], x);\n\t\t\teval(k, l, r);\n\t\t}else{\n\t\t\tupdate(a, b, x, 2*k+1, l, (l+r)/2);\n\t\t\tupdate(a, b, x, 2*k+2, (l+r)/2, r);\n\t\t\tdata[k]=f(data[2*k+1], data[2*k+2]);\n\t\t}\n\t}\n\tvoid update(int a, int b, const OperatorMonoid &x){\n\t\treturn update(a, b, x, 0, 0, sz);\n\t}\n\n\tMonoid find(int a, int b, int k, int l, int r){\n\t\teval(k, l, r);\n\t\tif(b<=l || r<=a) return e1;\n\t\tif(a<=l && r<=b) return data[k];\n\t\telse return f(find(a, b, 2*k+1, l, (l+r)/2), find(a, b, 2*k+2, (l+r)/2, r));\n\t}\n\tMonoid find(int a, int b){\n\t\treturn find(a, b, 0, 0, sz);\n\t}\n};\nconst int INF=1e9+7;\nint main()\n{\n\tint n, q;\n\tscanf(\"%d %d\", &n, &q);\n\tauto f=[](int a, int b){ return a+b;};\n\tauto g=[](int a, int x, int len){ return x*len;};\n\tauto h=[](int x, int y){ return y;};\n\tLazySegmentTree<int> seg(n, f, g, h, 0, INF);\n\tfor(int z=0; z<q; z++){\n\t\tint p; scanf(\"%d\", &p);\n\t\tif(p==0){\n\t\t\tint s, t, x;\n\t\t\tscanf(\"%d %d %d\", &s, &t, &x);\n\t\t\tseg.update(s, t+1, x);\n\t\t}else{\n\t\t\tint s, t;\n\t\t\tscanf(\"%d %d\", &s, &t);\n\t\t\tprintf(\"%d\\n\", seg.find(s, t+1));\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n\n/*\n update(s,t,x): [s,t) をxに変更する。\n find(s,t): [s,t) の総和を出力する。\n */\n\nconst ll INIT = 0;\nconst ll NIL = LLONG_MAX;\nstruct SegTree {\n    int N;\n    ll init_v;\n    vector<ll> node, lazy;\n    \n    SegTree(int _N):init_v(INIT) {\n        N = 1;\n        while (N < _N) N *= 2;\n        node.resize(2 * N - 1, init_v);\n        lazy.resize(2 * N - 1, NIL);\n    }\n    SegTree(int _N, vector<ll>& a){\n        N = 1;\n        while (N < _N) N *= 2;\n        node.resize(2 * N - 1, init_v);\n        lazy.resize(2 * N - 1, NIL);\n        for(int i = 0; i < _N; i++){ node[i+N-1] = a[i]; }\n        build();\n    }\n    void build(){ for(int k = N - 2; k >= 0; k--){ node[k] = node[2 * k + 1] + node[2 * k + 2];} }\n    \n    void lazy_evaluate(int k) {\n        if (lazy[k] == NIL) return;\n        node[k] = lazy[k];\n        if (k < N - 1) {\n            lazy[2 * k + 1] = lazy[k]/2;\n            lazy[2 * k + 2] = lazy[k]/2;\n        }\n        lazy[k] = NIL;\n    }\n    \n    /* [a,b) 引数の範囲に注意!! s~tまでを更新→update(s,t+1,~) */\n    ll update(int a, int b, ll x) { return update(a, b, 0, 0, N, x); }\n    ll update(int a, int b, int k, int l, int r, ll x) {\n        if (r <= a || b <= l) {\n            lazy_evaluate(k); // nodeの値を見るときは必ず遅延評価を更新する\n            return node[k]; // updateでは全体の中の最小を見つける必要があるため, [l,r)外になっても値を参照\n        }\n        if (a <= l && r <= b) {\n            lazy[k] = (r-l)*x;\n            lazy_evaluate(k);\n            return node[k];\n        }\n        else {\n            lazy_evaluate(k);\n            ll vl = update(a, b, 2 * k + 1, l, (l + r) / 2, x);\n            ll vr = update(a, b, 2 * k + 2, (l + r) / 2, r, x);\n            return node[k] = vl + vr;\n        }\n    }\n    \n    /* [a,b) 引数の範囲に注意!! */\n    ll query(int a, int b) { return query(a, b, 0, 0, N); }\n    ll query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) return init_v;\n        if (a <= l && r <= b) {\n            lazy_evaluate(k);\n            return node[k];\n        }\n        else {\n            lazy_evaluate(k);\n            ll vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n            ll vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n            return vl + vr;\n        }\n    }\n};\n\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    int n,q; cin >> n >> q;\n    SegTree seg(n);\n    while(q--){\n        int com; cin >> com;\n        if(com == 0){\n            int s,t,x; cin >> s >> t >> x;\n            seg.update(s,t+1,x);\n        }else{\n            int s,t; cin >> s >> t;\n            cout << seg.query(s,t+1) << endl;\n        }\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#include <vector>\n#include <functional>\ntemplate<class T, class Lazy> struct LazySegTree {\n  private:\n  public:\n    int size;\n    vector<T> v; vector<Lazy> lazy;\n    vector<int> seg_size;\n    using F = function<T(T,T)>;\n    using G = function<Lazy(Lazy,Lazy)>;\n    using H = function<T(T,Lazy,int)>;\n    F f; G g; H h;\n    T default_value; Lazy default_lazy;\n  public:\n    LazySegTree(int n, T default_value, Lazy default_lazy, F f, G g, H h)\n      : default_value(default_value), default_lazy(default_lazy), f(f), g(g), h(h) {\n      size = 1;\n      while (size < n) size *= 2;\n\n      v.resize(2 * size - 1, default_value);\n      lazy.resize(4 * size - 1, default_lazy);\n      seg_size.resize(2 * size - 1, 1);\n\n      for (int i = 0; i < size - 1; ++i) {\n        int j = size - 2 - i;\n        seg_size[j] = seg_size[2 * j + 1] + seg_size[2 * j + 2];\n      }\n    }\n    void update(int index, T val) {\n      update(index, index+1, default_lazy);\n      index = index + size - 1;\n      v[index] = val;\n      while (index > 0) {\n        index = (index - 1) / 2;\n        v[index] = f(v[2 * index + 1], v[2 * index + 2]);\n      }\n    }\n    void eval(int index) {\n      v[index] = h(v[index], lazy[index], seg_size[index]);\n\n      lazy[2 * index + 1] = g(lazy[index], lazy[2 * index + 1]);\n      lazy[2 * index + 2] = g(lazy[index], lazy[2 * index + 2]);\n\n      lazy[index] = default_lazy;\n    }\n    T query(int l, int r) { return query(l, r, 0, size, 0); }\n    T query(int l, int r, int cur_l, int cur_r, int index) {\n      // [l, r)に対するクエリ\n      eval(index);\n      if (cur_r <= l || r <= cur_l) return default_value;\n      if (l <= cur_l && cur_r <= r) return v[index];\n\n      // 左右を見ていく\n      int mid = (cur_l + cur_r) / 2;\n      return f(\n          query(l, r, cur_l, mid, 2 * index + 1),\n          query(l, r, mid, cur_r, 2 * index + 2));\n    }\n    void update(int l, int r, Lazy x) { update(l, r, x, 0, size, 0); }\n    void update(int l, int r, Lazy x, int cur_l, int cur_r, int index) {\n      // [l, r)に対して操作する\n\n      eval(index);\n      if (cur_r <= l || r <= cur_l) return;\n      if (l <= cur_l && cur_r <= r) {\n        lazy[index] = x;\n        eval(index);\n        return;\n      }\n      // 左右を見ていく\n      int mid = (cur_l + cur_r) / 2;\n      update(l, r, x, cur_l, mid, 2 * index + 1);\n      update(l, r, x, mid, cur_r, 2 * index + 2);\n      v[index] = f(v[2 * index + 1], v[2 * index + 2]);\n    }\n};\n\n#define in(v) v; cin >> v;\nvoid ins() {}\ntemplate<class T,class... Rest>void ins(T& v,Rest&... rest){cin>>v;ins(rest...);}\n#define rep(i,n) for(int i=0,_i=(n);i<_i;++i)\n\nint main() {\n  int in(N); int in(Q);\n\n  // 範囲和\n  LazySegTree<int, int> T(N, 0, 1001,\n      [](int a, int b) {return a + b;},\n      [](int a, int b) {return a == 1001 ? b : a;},\n      [](int a, int b, int size) {return b == 1001 ? a : b * size;});\n\n  rep(i, Q) {\n    int in(com);\n    if (com == 0) {\n      int s, t, x;\n      ins(s, t, x);\n      ++t;\n      T.update(s, t, x);\n    } else {\n      int s, t;\n      ins(s, t);\n      ++t;\n      cout << T.query(s, t) << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <climits>\n#include <functional>\nusing namespace std;\n\n// 動的遅延セグメント木 (必要なところだけノードを作る)\n\ntemplate <typename MonoidType, typename OperatorType>\nstruct LazySegNode {\n    MonoidType value;\n    OperatorType lazy_value;\n    bool need_update;\n    LazySegNode *ch[2];\n    \n    LazySegNode() {}\n    LazySegNode(MonoidType value_, OperatorType lazy_value_) :\n        value(value_), lazy_value(lazy_value_) {\n        need_update = false;\n        ch[0] = ch[1] = nullptr;\n    }\n};\n\ntemplate <typename MonoidType, typename OperatorType, typename IdxType = int>\nstruct DynamicLazySegmentTree {\n    using MMtoM = function< MonoidType(MonoidType, MonoidType) >;\n    using OOtoO = function< OperatorType(OperatorType, OperatorType) >;\n    using MOtoM = function< MonoidType(MonoidType, OperatorType) >;\n    using OItoO = function< OperatorType(OperatorType, int) >;\n    using LNode = LazySegNode<MonoidType, OperatorType>;\n\n    // node, identity element\n    IdxType n;\n    LNode *root;\n    MonoidType E0;\n    OperatorType E1;\n\n    // update / combine / lazy / accumulate function\n    MOtoM upd_f;\n    MMtoM cmb_f;\n    OOtoO lzy_f;\n    OItoO acc_f;\n\n    DynamicLazySegmentTree() {}\n    DynamicLazySegmentTree(IdxType n_, MonoidType E0_, OperatorType E1_,\n                           MOtoM upd_f_, MMtoM cmb_f_, OOtoO lzy_f_, OItoO acc_f_) :\n        E0(E0_), E1(E1_),\n        upd_f(upd_f_), cmb_f(cmb_f_), lzy_f(lzy_f_), acc_f(acc_f_) {\n        root = new LNode(E0_, E1_);\n        n = 1; while(n < n_) n *= 2;\n    }\n\n    void eval(LNode *node, IdxType l, IdxType r) {\n        if(!node->need_update) return;\n        node->value = upd_f(node->value, acc_f(node->lazy_value, r - l));\n        if(r - l > 1) {\n            if(!node->ch[0]) node->ch[0] = new LNode(E0, E1);\n            if(!node->ch[1]) node->ch[1] = new LNode(E0, E1);\n            node->ch[0]->lazy_value = lzy_f(node->ch[0]->lazy_value, node->lazy_value);\n            node->ch[1]->lazy_value = lzy_f(node->ch[1]->lazy_value, node->lazy_value);\n            node->ch[0]->need_update = node->ch[1]->need_update = true;\n        }\n        node->lazy_value = E1;\n        node->need_update = false;\n    }\n\n    void update(LNode *node, IdxType a, IdxType b, OperatorType x,\n                IdxType l, IdxType r) {\n        eval(node, l, r);\n        if(b <= l or r <= a) return;\n        if(a <= l and r <= b) {\n            node->lazy_value = lzy_f(node->lazy_value, x);\n            node->need_update = true;\n            eval(node, l, r);\n        }\n        else {\n            IdxType mid = (l + r) / 2;\n            if(!node->ch[0]) node->ch[0] = new LNode(E0, E1);\n            if(!node->ch[1]) node->ch[1] = new LNode(E0, E1);\n            update(node->ch[0], a, b, x, l, mid);\n            update(node->ch[1], a, b, x, mid, r);\n            node->value = cmb_f(node->ch[0]->value, node->ch[1]->value);\n        }\n    }\n\n    MonoidType query(LNode *node, IdxType a, IdxType b, IdxType l, IdxType r) {\n        if(b <= l or r <= a) return E0;\n        eval(node, l, r);\n        if(a <= l and r <= b) return node->value;\n        IdxType mid = (l + r) / 2;\n        MonoidType vl = (node->ch[0] ? query(node->ch[0], a, b, l, mid) : E0);\n        MonoidType vr = (node->ch[1] ? query(node->ch[1], a, b, mid, r) : E0);\n        return cmb_f(vl, vr);\n    }\n\n    // update [a, b)-th element (applied value: x)\n    void update(IdxType a, IdxType b, OperatorType x) {\n        update(root, a, b, x, 0, n);\n    }\n\n    // range query for [a, b)\n    MonoidType query(IdxType a, IdxType b) {\n        return query(root, a, b, 0, n);\n    }\n};\n\n\nvoid DSL_2_D() {\n    int N, Q; cin >> N >> Q;\n    DynamicLazySegmentTree<int, int> seg(N, INT_MAX, INT_MAX,\n                                         [](int a, int b) { return b; },\n                                         [](int a, int b) { return min(a, b); },\n                                         [](int a, int b) { return b; },\n                                         [](int a, int b) { return a; });\n\n    int indexed = 0;\n    for(int i=0; i<Q; i++) {\n        int q; cin >> q;\n        if(q == 0) {\n            int s, t, x; cin >> s >> t >> x;\n            s -= indexed; t -= indexed; t++;\n            seg.update(s, t, x);\n        }\n        if(q == 1) {\n            int k; cin >> k;\n            k -= indexed;\n            cout << seg.query(k, k+1) << endl;\n        }\n    }\n}\n\n// Verified on Apr 27, 2019\nvoid DSL_2_E() {\n    int N, Q; cin >> N >> Q;\n    DynamicLazySegmentTree<int, int> seg(N, 0, 0,\n                                         [](int a, int b) { return a + b; },  // upd\n                                         [](int a, int b) { return a + b; },  // cmb\n                                         [](int a, int b) { return a + b; },  // lzy\n                                         [](int a, int x) { return a * x; }); // acc\n    \n    int indexed = 1;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s; cin >> s;\n            s -= indexed;\n            cout << seg.query(s, s+1) << endl;\n        }\n        // seg.dump();\n    }    \n}\n\n// Verified on Apr 27, 2019\nvoid DSL_2_F() {\n    int N, Q; cin >> N >> Q;\n    DynamicLazySegmentTree<int, int> seg(N, INT_MAX, 0,\n                                         [](int a, int b) { return b;         },  // upd\n                                         [](int a, int b) { return min(a, b); },  // cmb\n                                         [](int a, int b) { return b;         },  // lzy\n                                         [](int a, int x) { return a;         }); // acc\n    \n    int indexed = 0;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s, t; cin >> s >> t; t++;\n            s -= indexed; t -= indexed;\n            cout << seg.query(s, t) << endl;\n        }\n        // seg.dump();\n    }    \n}\n\n// Verified on Apr 27, 2019\nvoid DSL_2_G() {\n    int N, Q; cin >> N >> Q;\n    using ll = long long int;\n    DynamicLazySegmentTree<ll, ll> seg(N, 0, 0,\n                                       [](ll a, ll  b) { return a + b; },  // upd\n                                       [](ll a, ll  b) { return a + b; },  // cmb\n                                       [](ll a, ll  b) { return a + b; },  // lzy\n                                       [](ll a, int x) { return a * x; }); // acc\n    \n    int indexed = 1;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s, t; cin >> s >> t; t++;\n            s -= indexed; t -= indexed;\n            cout << seg.query(s, t) << endl;\n        }\n        // seg.dump();\n    }    \n}\n\n// Verified on Apr 27, 2019\nvoid DSL_2_H() {\n    int N, Q; cin >> N >> Q;\n    using ll = long long int;\n    using Pair = pair<ll, ll>;\n    DynamicLazySegmentTree<ll, Pair> seg(N, INT_MAX, make_pair(0, 0),\n                                       [](ll a, Pair b) {\n                                             if(b.second == 1) {\n                                                 return b.first;\n                                             }\n                                             else {\n                                                 return a + b.first;\n                                             }\n                                         },  // upd\n                                       [](ll a, ll  b) { return min(a, b); },  // cmb\n                                       [](Pair a, Pair b) {\n                                           if(a.second == 0 and b.second == 0) {\n                                               return make_pair(a.first + b.first, 0LL);\n                                           }\n                                           if(a.second == 0 and b.second == 1) {\n                                               return b;\n                                           }\n                                           if(a.second == 1 and b.second == 0) {\n                                               return make_pair(a.first + b.first, 1LL);\n                                           }\n                                           if(a.second == 1 and b.second == 1) {\n                                               return b;\n                                           }\n                                       },\n                                       [](Pair a, int x) { return a;         }); // acc\n    \n    int indexed = 0;\n    for(int i=0; i<N; i++) {\n        seg.update(i, i+1, make_pair(0, 1));\n    }\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, make_pair(x, 0));\n        }\n        if(query_type == 1) {\n            int s, t; cin >> s >> t; t++;\n            s -= indexed; t -= indexed;\n            cout << seg.query(s, t) << endl;\n        }\n        // seg.dump();\n    }    \n}\n\n// Verified on Apr 27, 2019\nvoid DSL_2_I() {\n    int N, Q; cin >> N >> Q;\n    using ll = long long int;\n    DynamicLazySegmentTree<ll, ll> seg(N, 0, 0,\n                                       [](ll a, ll  b) { return b;     },  // upd\n                                       [](ll a, ll  b) { return a + b; },  // cmb\n                                       [](ll a, ll  b) { return b;     },  // lzy\n                                       [](ll a, int x) { return a * x; }); // acc\n    \n    int indexed = 0;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s, t; cin >> s >> t; t++;\n            s -= indexed; t -= indexed;\n            cout << seg.query(s, t) << endl;\n        }\n        // seg.dump();\n    }    \n}\n\nint main() {\n    // DSL_2_D();\n    // DSL_2_E();\n    // DSL_2_F();\n    // DSL_2_G();\n    // DSL_2_H();\n    DSL_2_I();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\n#define p_ary(ary,a,b,i) do { cout << \"[\"; for (int (i) = (a);(i) < (b);++(i)) cout << ary[(i)] << ((b)-1 == (i) ? \"\" : \", \"); cout << \"]\\n\"; } while(0)\n#define p_map(map,it) do {cout << \"{\";for (auto (it) = map.begin();;++(it)) {if ((it) == map.end()) {cout << \"}\\n\";break;}else cout << \"\" << (it)->first << \"=>\" << (it)->second << \", \";}}while(0)\n\nstruct LazySegmentTree {\nprivate:\n    int n;\n    vector<ll> node,lazy;\n    vector<bool> upd;\npublic:\n    LazySegmentTree(vector<ll> v) {\n        int sz = v.size();\n        n = 1;\n        while (n < sz) n *= 2;\n        node.resize(2*n-1);\n        lazy.resize(2*n-1,0);\n        upd.resize(2*n-1,false);\n        for (int i = 0;i < sz;++i) node[i+n-1] = v[i];\n        for (int i = n-2;i >= 0;--i) node[i] = node[i*2+1]+node[i*2+2];\n    }\n\n    void eval(int k,int l,int r) {\n        if (upd[k]) {\n            node[k] = lazy[k]*(r-l);\n            if (r-l > 1) {\n                lazy[2*k+1] = lazy[2*k+2] = lazy[k];\n                upd[2*k+1] = upd[2*k+2] = true;\n            }\n            lazy[k] = 0;\n            upd[k] = false;\n        }\n    }\n\n    void update(int a,int b,ll x,int k = 0,int l = 0,int r = -1) {\n        if (r < 0) r = n;\n        eval(k,l,r);\n        if (b <= l || r <= a) return;\n        if (a <= l && r <= b) {\n            lazy[k] = x;\n            upd[k] = true;\n            eval(k,l,r);\n        } else {\n            update(a,b,x,2*k+1,l,(l+r)/2);\n            update(a,b,x,2*k+2,(l+r)/2,r);\n            node[k] = node[2*k+1]+node[2*k+2];\n        }\n    }\n\n    ll getsum(int a,int b,int k = 0,int l = 0,int r = -1) {\n        if (r < 0) r = n;\n        if (b <= l || r <= a) return 0;\n        eval(k,l,r);\n        if (a <= l && r <= b) return node[k];\n        ll vl = getsum(a,b,k*2+1,l,(l+r)/2);\n        ll vr = getsum(a,b,2*k+2,(l+r)/2,r);\n        return vl+vr;\n    }\n};\n\nint main() {\n    int n,q;\n    cin >> n >> q;\n    LazySegmentTree seg(vector<ll>(n,0));\n    for (int i = 0;i < q;++i) {\n        int c,s,t;\n        cin >> c >> s >> t;\n        if (c) cout << seg.getsum(s,t+1) << endl;\n        else {\n            int x;\n            cin >> x;\n            seg.update(s,t+1,x);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\nstruct LazySegmentTree{\n   int n;\n   vector<ll> node,lazy,flag;\npublic:\n   LazySegmentTree(int sz,ll init){\n       n=1;\n       while(n<sz)n*=2;\n       node.resize(2*n-1,init);\n       lazy.resize(2*n-1,longinf);\n   }\n\n   void eval(int k,int l,int r){\n       if(lazy[k]!=longinf){\n           node[k]=lazy[k];\n       if(r-l>1){\n            lazy[2*k+1]=lazy[k]/2;\n           lazy[2*k+2]=lazy[k]/2;\n       }\n       }\n       lazy[k]=longinf;\n    }\n       //[a,b)にxを加算\n    void update(int a,int b,ll x,int k=0,int l=0,int r=-1){\n        if(r<0)r=n;\n        eval(k,l,r);\n        if(r<=a||b<=l)return;\n        if(a<=l&&r<=b){\n           lazy[k]=x*(r-l);\n           eval(k,l,r);\n        }\n        else {\n           update(a,b,x,2*k+1,l,(l+r)/2);\n           update(a,b,x,2*k+2,(l+r)/2,r);\n           node[k]=node[2*k+1]+node[2*k+2];\n        }\n    }\n   //[a,b)での和を返す\n   ll get(int a,int b,int k=0,int l=0,int r=-1){\n       if(r<0)r=n;\n       eval(k,l,r);\n       if(r<=a||b<=l)return 0;\n       if(a<=l&&r<=b)return node[k];\n       ll xl=get(a,b,2*k+1,l,(l+r)/2);\n       ll xr=get(a,b,2*k+2,(l+r)/2,r);\n       return xl+xr;\n   }\n};\nint main(){\n   int n,q;\n   cin>>n>>q;\n   LazySegmentTree sg(n,0);\n   rep(i,q){\n       int t;cin>>t;\n       if(t){\n           int a,b;\n           cin>>a>>b;\n           b++;\n           cout<<sg.get(a,b)<<endl;\n       }\n       else {\n           int a,b,c;\n           cin>>a>>b>>c;\n           sg.update(a,b+1,c);\n       }\n   }\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<algorithm>\n#include<functional>\n\ntemplate<typename T>\nclass LazySegmentTree{\n    int n;\n    std::vector<T> node;\n    std::vector<T> lazy;\n    std::vector<int> length;\n    int height;\n\n    using F = std::function<T(T, T)>;\n    using S = std::function<T(T, int)>;\n\n    F f;\n    F g;\n    F h;\n    S s;\n    T id1;\n    T id2;\n\n    void evaluate(int k){\n        if(lazy[k] == id2){\n            return;\n        }\n\n        node[k] = g(node[k], s(lazy[k], length[k]));\n\n        if(k < n){\n            lazy[k << 1] = h(lazy[k << 1], lazy[k]);\n            lazy[(k << 1) | 1] = h(lazy[(k << 1) | 1], lazy[k]);\n        }\n\n        lazy[k] = id2;\n\n        return;\n    }\n\n    void evaluate(int l, int r){\n        for(int i = height ; 0 < i ; --i){\n            evaluate(l >> i);\n            evaluate(r >> i);\n        }\n\n        return;\n    }\n\npublic:\n    LazySegmentTree(int n_, F f_, F g_, F h_, T id1_, T id2_, S s_ = [](T x, int len){ return x; }){\n        init(n_, f_, g_, h_, id1_, id2_, s_);\n    }\n\n    LazySegmentTree(std::vector<T>& dat, F f_, F g_, F h_, T id1_, T id2_, S s_ = [](T x, int len){ return x; }){\n        build(dat, f_, g_, h_, id1_, id2_, s_);\n    }\n\n    void init(int n_, F f_, F g_, F h_, T id1_, T id2_, S s_ = [](T x, int len){ return x; }){\n        n = 1;\n        height = 0;\n        while(n < n_){\n            n <<= 1;\n            ++height;\n        }\n\n        f = f_;\n        g = g_;\n        h = h_;\n        id1 = id1_;\n        id2 = id2_;\n        s = s_;\n\n        node.assign(n << 1, id1);\n        lazy.assign(n << 1, id2);\n\n        length.assign(n << 1, 1);\n        fill(length.begin() + n + n_, length.end(), 0);\n        for(int i = n - 1 ; 0 < i ; --i){\n            length[i] = length[i << 1] + length[(i << 1) | 1];\n        }\n\n        return;\n    }\n\n    void build(std::vector<T>& dat, F f_, F g_, F h_, T id1_, T id2_, S s_ = [](T x, int len){ return x; }){\n        int n_ = (int)dat.size();\n\n        init(n_, f_, g_, h_, id1_, id2_, s_);\n\n        for(int i = 0 ; i < n_ ; ++i){\n            node[i + n] = dat[i];\n        }\n        for(int i = n - 1 ; 0 < i ; --i){\n            node[i] = f(node[i << 1], node[(i << 1) | 1]);\n        }\n\n        return;\n    }\n\n    void update(int l, int r, T x){\n        l += n;\n        r += n - 1;\n\n        int L = l;\n        int R = r;\n\n        evaluate(l, r);\n\n        ++r;\n\n        while(l < r){\n            if(r & 1){\n                --r;\n                lazy[r] = h(lazy[r], x);\n            }\n            r >>= 1;\n\n            if(l & 1){\n                lazy[l] = h(lazy[l], x);\n                ++l;\n            }\n            l >>= 1;\n        }\n\n        while(L >>= 1, R >>= 1, L){\n            evaluate(L << 1);\n            evaluate((L << 1) | 1);\n            node[L] = f(node[L << 1], node[(L << 1) | 1]);\n\n            evaluate(R << 1);\n            evaluate((R << 1) | 1);\n            node[R] = f(node[R << 1], node[(R << 1) | 1]);\n        }\n\n        return;\n    }\n\n    T get(int l, int r){\n        l += n;\n        r += n - 1;\n\n        evaluate(l, r);\n\n        ++r;\n\n        T res = id1;\n        while(l < r){\n            if(r & 1){\n                --r;\n                evaluate(r);\n                res = f(res, node[r]);\n            }\n            r >>= 1;\n\n            if(l & 1){\n                evaluate(l);\n                res = f(res, node[l]);\n                ++l;\n            }\n            l >>= 1;\n        }\n\n        return res;\n    }\n};\n\n#include<iostream>\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n\n    int n, q;\n    std::cin >> n >> q;\n\n    LazySegmentTree<long long> seg(n, [](long long l, long long r){ return l + r; }, [](long long l, long long r){ return r; },\n                                    [](long long l, long long r){ return r; }, 0LL, 1LL << 61, [](long long x, int len){ return x * len; });\n\n    while(q--){\n        int k, s, t;\n        long long x;\n        std::cin >> k;\n\n        if(k == 0){\n            std::cin >> s >> t >> x;\n            seg.update(s, t + 1, x);\n        }else{\n            std::cin >> s >> t;\n            std::cout << seg.get(s, t + 1) << '\\n';\n        }\n    }\n\n    std::cout << std::flush;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nfunction<void(vector<ll> &node, ll v, int k, int l, int r)> \ncpnode=[]    (vector<ll> &node, ll v, int k, int l, int r)\n{ node[k]=(r-l+1)*v; };\n\nfunction<void(vector<ll> &node, int k)> \nmgnode=[]    (vector<ll> &node, int k)\n{ node[k]=node[2*k+1]+node[2*k+2]; };\n\nfunction<ll(ll lv, ll rv)> \ngetnode=[] (ll lv, ll rv)\n{ return lv+rv; };\n\nstruct lst\n{\nprivate:\n    int n;\n    vector<ll> node;\n    vector<ll> lazy;\n    vector<bool> lflg;\n    function<void(vector<ll> &node, ll v, int k, int l, int r)> cpnode;\n    function<void(vector<ll> &node, int k)> mgnode;\n    function<ll(ll lv, ll rv)> getnode;\n\n    void lazy2node(int k, int l, int r)\n    {\n        if(lflg[k])\n        {\n            cpnode(node, lazy[k], k, l, r);\n            prop(lazy[k], k, l, r);\n            lazy[k]=0;\n            lflg[k]=false;\n        }\n    }\n\n    void prop(ll v, int k, int l, int r)\n    {\n\n        if(r-l>0)\n        {\n            lazy[2*k+1]=lazy[2*k+2]=v;\n            lflg[2*k+1]=lflg[2*k+2]=true;\n        }\n    }\n\npublic:\n    lst(int sz, \n        function<void(vector<ll>&, ll, int, int, int)>cpnode,\n        function<void(vector<ll>&, int)>mgnode,\n        function<ll(ll, ll)>getnode)\n    : n(1), cpnode(move(cpnode)), mgnode(move(mgnode)), getnode(move(getnode))\n    {\n        while(n<sz) n*=2;\n        node.resize(2*n-1, 0);\n        lazy.resize(2*n-1, 0);\n        lflg.resize(2*n-1, false);\n    }\n    void update(int qa, int qb, ll v, int k=0, int l=0, int r=-1)\n    {\n        if(r<0) r=n-1;\n        lazy2node(k, l, r);\n        if(qb<l || r<qa) return; \n        if(qa<=l && r<=qb)\n        {\n            cpnode(node, v, k, l, r);\n            prop(v, k, l, r);\n        }\n        else\n        {\n            int m=(l+r)/2;\n            update(qa, qb, v, 2*k+1, l, m);\n            update(qa, qb, v, 2*k+2, m+1, r);\n            mgnode(node, k);\n        }\n    }\n\n    ll get(int qa, int qb, int k=0, int l=0, int r=-1)\n    {\n        if(r<0) r=n-1;\n        lazy2node(k, l, r);\n        if(qb<l || r<qa) return 0;\n        if(qa<=l && r<=qb) return node[k];\n        else\n        {\n            int m=(l+r)/2;\n            ll lv=get(qa, qb, 2*k+1, l, m);\n            ll rv=get(qa, qb, 2*k+2, m+1, r);\n            return getnode(lv, rv);\n        }\n    }\n};\n\nint main()\n{\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n    lst tree=lst(n, cpnode, mgnode, getnode);\n    for(int i=0; i<q; i++)\n    {\n        int c;\n        scanf(\"%d\", &c);\n        if(c)\n        {\n            int s, t;\n            scanf(\"%d %d\", &s, &t);\n            printf(\"%lld\\n\", tree.get(s,t));\n        }\n        else\n        {\n            int s, t, v;\n            scanf(\"%d %d %d\", &s, &t, &v);\n            tree.update(s,t, (ll)v);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\n#include <type_traits>\n#include <mutex>\n#include <array>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\ntypedef unsigned int uint;\ntypedef long long llong;\ntypedef unsigned long long ullong;\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 28)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\n#define PRED(a,exp) [&](const auto & a) -> bool { return exp; }\n#define COMP(a,b,exp) [&](const auto & a, const auto & b) -> bool { return exp; }\n#define CONV1(a,exp) [&](const auto & a) -> auto { return exp; }\n#define CONV2(a,b,exp) [&](const auto & a, const auto & b) -> auto { return exp; }\n#define CONV3(a,b,c,exp) [&](const auto & a, const auto & b, const auto & c) -> auto { return exp; }\n\ninline int sign_of(double x) { return abs(x) < EPS ? 0 : x > 0 ? 1 : -1; }\ninline bool inRange(int val, int min, int max) { return val >= min && val < max; }\ninline bool inRange(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\ninline bool inRange(int x, int y, int W, int H) { return x >= 0 && x < W && y >= 0 && y < H; } // W,H含まない\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\n\n//// i/o helper ////\n\nnamespace std {\n\ttemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\n\ttemplate <class T1, class T2> inline ostream & operator << (ostream &out, const pair<T1, T2> &p) { out << p.first << \" \" << p.second; return out; }\n}\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; v.reserve(n); REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; v.reserve(n); REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T> struct iter_pair_t { T beg, end; };\ntemplate <class T> iter_pair_t<T> iter_pair(T beg, T end) { return iter_pair_t<T>{beg, end}; }\ntemplate <class T> ostream & operator << (ostream &out, const iter_pair_t<T> &v)\n{\n\tstd::copy(v.beg, v.end, ostream_iterator<typename decltype(v.beg)::reference>(out, \" \"));\n\treturn out;\n}\ntemplate <class T1> ostream & operator << (ostream &out, const vector<T1> &v) { return out << iter_pair(begin(v), end(v)); }\ntemplate <class T1> ostream & operator << (ostream &out, const set<T1> &v) { return out << iter_pair(begin(v), end(v)); }\ntemplate <class T1, class T2> ostream & operator << (ostream &out, const map<T1, T2> &v) { return out << iter_pair(begin(v), end(v)); }\n\nstruct _Reader { istream &cin; template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { ostream &cout; bool f{ false }; template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; (_Reader{cin}), __VA_ARGS__\n#define WRITE(...) (_Writer{cout}), __VA_ARGS__; cout << '\\n'\n#define DEBUG(...) (_Writer{cerr}), __VA_ARGS__; cerr << '\\n'\n\nvoid solve();\nint main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\n\t//auto temp = ctype<char>::classic_table();\n\t//vector<ctype<char>::mask> bar(temp, temp + ctype<char>::table_size);\n\t//bar[':'] |= ctype_base::space;\n\t//cin.imbue(locale(cin.getloc(), new ctype<char>(bar.data())));\n\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed;\n\tcout << setprecision(std::numeric_limits<double>::max_digits10);\n\tsolve();\n\n\treturn 0;\n}\n\ntemplate <class T>\nstruct RangeSegTrees\n{\n\ttemplate<class TUpdater, class TResolver, class TAccumulator>\n\tstruct Tree\n\t{\n\t\tTree(int count, T initialValue, TUpdater updater, TResolver resolver, TAccumulator accumulator)\n\t\t\t: size(msb(count - 1) << 1), data(size * 2), lazy(size * 2), initialValue(initialValue)\n\t\t\t, updater(updater), resolver(resolver), accumulator(accumulator)\n\t\t{\n\t\t\tlazy[1] = { true, initialValue };\n\t\t}\n\n\t\tvoid update_range(int begin, int end, T value)\n\t\t{\n\t\t\tupdate_range(begin, end, 1, 0, size, value);\n\t\t}\n\n\t\tT query(int begin, int end)\n\t\t{\n\t\t\treturn query(begin, end, 1, 0, size);\n\t\t}\n\n\tprivate:\n\t\tint size;\n\t\tvector<T> data;\n\t\tstruct LAZY { bool use; T val; };\n\t\tvector<LAZY> lazy;\n\t\tT initialValue;\n\n\t\tTUpdater updater;\n\t\tTResolver resolver;\n\t\tTAccumulator accumulator;\n\n\t\tstatic constexpr unsigned int msb(unsigned int v) { REP(i, 5) v |= v >> (1 << i); return (v >> 1) + 1; }\n\n\t\tvoid update_lazy(LAZY &val, T newVal)\n\t\t{\n\t\t\tif (val.use) { val.val = updater(val.val, newVal); }\n\t\t\telse { val.val = newVal; }\n\t\t\tval.use = true;\n\t\t}\n\n\t\tvoid propergate(int i, int l, int r)\n\t\t{\n\t\t\tif (lazy[i].use)\n\t\t\t{\n\t\t\t\tdata[i] = resolver(data[i], lazy[i].val, r - l);\n\t\t\t\tif (i < size)\n\t\t\t\t{\n\t\t\t\t\tupdate_lazy(lazy[i * 2], lazy[i].val);\n\t\t\t\t\tupdate_lazy(lazy[i * 2 + 1], lazy[i].val);\n\t\t\t\t}\n\t\t\t\tlazy[i] = { false, initialValue };\n\t\t\t}\n\t\t}\n\n\t\tT update_range(int s, int e, int i, int l, int r, T value)\n\t\t{\n\t\t\tif (r <= s || e <= l)\n\t\t\t{\n\t\t\t\tpropergate(i, l, r);\n\t\t\t\treturn data[i];\n\t\t\t}\n\n\t\t\tif (s <= l && r <= e)\n\t\t\t{\n\t\t\t\tupdate_lazy(lazy[i], value);\n\t\t\t\tpropergate(i, l, r);\n\t\t\t\treturn data[i];\n\t\t\t}\n\n\t\t\tpropergate(i, l, r);\n\t\t\tint m = (l + r) / 2;\n\t\t\treturn data[i] = accumulator(\n\t\t\t\tupdate_range(s, e, i * 2, l, m, value),\n\t\t\t\tupdate_range(s, e, i * 2 + 1, m, r, value));\n\t\t}\n\n\t\tT query(int s, int e, int i, int l, int r)\n\t\t{\n\t\t\tpropergate(i, l, r);\n\t\t\tif (s <= l && r <= e)\n\t\t\t{\n\t\t\t\treturn data[i];\n\t\t\t}\n\n\t\t\tint m = (l + r) / 2;\n\t\t\tif (s < m && e > m)\n\t\t\t{\n\t\t\t\treturn accumulator(query(s, e, i * 2, l, m), query(s, e, i * 2 + 1, m, r));\n\t\t\t}\n\t\t\telse if (s < m)\n\t\t\t{\n\t\t\t\treturn query(s, e, i * 2, l, m);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn query(s, e, i * 2 + 1, m, r);\n\t\t\t}\n\t\t}\n\t};\n\n\ttemplate <class TUpdater, class TResolver, class TAccumulator>\n\tstatic auto RangeSegTree(int N, TUpdater upd, TResolver res, TAccumulator acm, T initial)\n\t{\n\t\treturn Tree<TUpdater, TResolver, TAccumulator>(N, initial, upd, res, acm);\n\t}\n\n\tstatic auto QueryMinimumUpdateValue(int n, T initial = numeric_limits<int>::max())\n\t{\n\t\treturn RangeSegTree(n, CONV2(, b, b), CONV3(, b, , b), CONV2(a, b, min(a, b)), initial);\n\t}\n\n\tstatic auto QueryMinimumAddValue(int n, T initial = 0)\n\t{\n\t\treturn RangeSegTree(n, CONV2(a, b, a + b), CONV3(a, b, , a + b), CONV2(a, b, min(a, b)), initial);\n\t}\n\n\t// query sum, mov val\n\tstatic auto QuerySumUpdateValue(int n, T initial = 0)\n\t{\n\t\treturn RangeSegTree(n, CONV2(, b, b), CONV3(, b, c, b * c), CONV2(a, b, a + b), initial);\n\t}\n\n\t// query sum, add val\n\tstatic auto QuerySumAddValue(int n, T initial = 0)\n\t{\n\t\treturn RangeSegTree(n, CONV2(a, b, a + b), CONV3(a, b, c, a + b * c), CONV2(a, b, a + b), initial);\n\t}\n};\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tREAD(int, n, q);\n\tauto tree = RangeSegTrees<llong>::QuerySumUpdateValue(n);\n\tint origin = 0;\n\tREP(qq, q)\n\t{\n\t\tREAD(int, c);\n\t\tif (c == 0)\n\t\t{\n\t\t\tREAD(int, s, t, x);\n\t\t\ttree.update_range(s - origin, t + 1 - origin, x);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tREAD(int, s, t);\n\t\t\tllong v = tree.query(s - origin, t + 1 - origin);\n\t\t\tWRITE(v);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <queue>\n#include <stack>\n#include <utility>\n#include <vector>\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\n\n\n\n//see also: http://tsutaj.hatenablog.com/entry/2017/03/29/204841\n\ntemplate<typename VM,typename OM>\nclass LazySegmentTree{\nprotected:\n  int                 range_;\n  VM              value_identity_;\n  OM              operator_identity_;\n  std::vector<VM> value_tree_;\n  std::vector<OM> lazy_tree_;\n\n  virtual VM MergeValue(const VM& a, const VM& b)=0;\n  virtual OM MergeOperator(const OM& target,const OM& effector)=0;\n  virtual VM Operate(const VM& val, const OM& opl)=0;\n  virtual OM GetOperator(const OM& opl, const int n)=0;\n\n  VM InternalMerge(const VM& a, const VM& b){\n    if(a==value_identity_){\n      return b;\n    }else if(b==value_identity_){\n      return a;\n    }else{\n      return MergeValue(a,b);\n    }\n  }\n\n  int Parent(const int child) const{\n    return (child - 1) / 2;\n  }\n\n  int LeftChild(const int parent) const{\n    return parent * 2 + 1;\n  }\n\n  int RightChild(const int parent) const{\n    return parent * 2 + 2;\n  }\n\n  void Propagate(int node,int len){\n    if(lazy_tree_[node]!=operator_identity_){\n      if(node*2+2<range_*2){\n        lazy_tree_[LeftChild(node)]=MergeOperator(lazy_tree_[LeftChild(node)],lazy_tree_[node]);\n        lazy_tree_[RightChild(node)]=MergeOperator(lazy_tree_[RightChild(node)],lazy_tree_[node]);\n      }\n\n      value_tree_[node]=Operate(value_tree_[node],GetOperator(lazy_tree_[node],len));\n      lazy_tree_[node]=operator_identity_;\n    }\n  }\n\n  VM GetRangeOperation(int query_l, int query_r, int node, int l, int r){\n    Propagate(node,r-l);\n    if(r <= query_l || query_r <= l){\n      return value_identity_;\n    }else if(query_l <= l && r <= query_r){\n      return value_tree_[node];\n    }else{\n      VM vl = GetRangeOperation(query_l, query_r, LeftChild(node), l,\n                                    (l + r) / 2);\n      VM vr = GetRangeOperation(query_l, query_r, RightChild(node),\n                                    (l + r) / 2, r);\n      return InternalMerge(vl, vr);\n    }\n\n  }\n\n  VM Update(int a,int b, OM opr,int node,int l,int r){\n    Propagate(node, r - l);\n    if(r <= a || b <= l) return value_tree_[node];\n    if(a <= l && r <= b){\n      lazy_tree_[node] = MergeOperator(lazy_tree_[node],opr);\n      Propagate(node, r - l);\n      return Operate(value_tree_[node],GetOperator(lazy_tree_[node],r-l));\n    }else{\n      Update(a, b, opr, LeftChild(node), l, (l + r) / 2);\n      Update(a, b, opr, RightChild(node), (l + r) / 2, r);\n      value_tree_[node]= InternalMerge(value_tree_[LeftChild(node)],\n                                       value_tree_[RightChild(node)]);\n      return value_tree_[node];\n    }\n  }\n\npublic:\n\n  /// \\brief construct the segment tree.\n  /// \\param identity the element e s.t. a*e = e*a = a  (単位元)\n  //FIXME: コンストラクタ中で仮想関数を使わないようにする\n  LazySegmentTree(const VM& value_identity, const OM& operator_identity,\n      int size): value_identity_(\n      value_identity),operator_identity_(operator_identity){\n    int sz = size;\n    range_ = 1;\n    while(range_ < sz){\n      range_ *= 2;\n    }\n    value_tree_.resize(2 * range_ - 1, value_identity);\n    lazy_tree_.resize(2*range_-1,operator_identity);\n\n  }\n\n  void Init(const std::vector<VM>& v){\n    for(int i = 0; i < v.size(); i++){\n      value_tree_[i + range_ - 1] = v[i];\n    }\n    for(int i = range_ - 2; i >= 0; i--){\n      value_tree_[i] =\n          InternalMerge(value_tree_[LeftChild(i)], value_tree_[RightChild(i)]);\n    }\n  }\n\n\n  void Update(int a,int b, OM opr){\n    Update(a,b,opr,0,0,range_);\n  }\n\n  /// \\brief [l,r)に対して演算をした結果を返す\n  /// \\param l 範囲左端(lを含む)\n  /// \\param r 範囲右端(rを含まない)\n  /// \\return result\n\n  VM GetResult(int l, int r){\n    return GetRangeOperation(l, r, 0, 0, range_);\n  }\n};\n\n// verify\n\nclass RSQTree:public LazySegmentTree<int64_t,int64_t>{\nprotected:\n\n  int64_t MergeValue(const int64_t& a, const int64_t& b)override {\n    return a+b;\n  }\n  int64_t MergeOperator(const int64_t& target,const int64_t& effector)override {\n    if(effector==operator_identity_){\n      return target;\n    }else{\n      return effector;\n    }\n  }\n  int64_t Operate(const int64_t& val, const int64_t& opl)override {\n    if(opl==operator_identity_){\n      return val;\n    }else{\n      return opl;\n    }\n  }\n  int64_t GetOperator(const int64_t& opl, const int n)override {\n    return opl*(int64_t)n;\n  }\n\npublic:\n  RSQTree(int64_t n):LazySegmentTree(0,INT32_MAX,n){}\n\n};\n\n\nint main(void){\n  int64_t n,q;\n  cin>>n>>q;\n  RSQTree tree(n+1);\n  tree.Init(std::vector<int64_t>(n,0));\n  for(int64_t i=0;i<q;i++){\n    int64_t m;\n    cin>>m;\n    if(m==0){\n      int64_t s,t,x;\n      cin>>s>>t>>x;\n      tree.Update(s,t+1,x);\n    }else{\n      int64_t s,t;\n      cin>>s>>t;\n      cout<< tree.GetResult(s, t + 1)<<endl;\n    }\n  }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename V> class segtree2 {\nprivate:\n    int n,sz;\n    vector<V> node, lazy;\n    vector<bool> lazyFlag;\n\npublic:\n    segtree2(vector<V>& v) {\n        sz = (int)v.size();\n        n = 1;\n        while(n < sz){\n            n *= 2;\n        }\n        node.resize(2*n-1, 0);\n        lazy.resize(2*n-1, 0);\n        lazyFlag.resize(2*n-1,false);\n        rep(i,sz){\n            node[i+n-1] = v[i];\n        }\n        for(int i=n-2; i>=0; i--){\n            node[i] = node[i*2+1] + node[i*2+2];\n        }\n    }\n    void eval(int k, int l, int r) {\n        if(lazyFlag[k]) {\n            node[k] = lazy[k]*(r-l);\n            if(r - l > 1) {\n                lazy[k*2+1] = lazy[k*2+2] = lazy[k];\n                lazyFlag[k*2+1] = lazyFlag[k*2+2] = true;\n            }\n            lazyFlag[k] = false;\n        }\n    }\n    void range(int a, int b, V x, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a){\n            return;\n        }\n        if(a <= l && r <= b) {\n            lazy[k] = x;\n            lazyFlag[k] = true;\n            eval(k, l, r);\n        }\n        else {\n            range(a, b, x, 2*k+1, l, (l+r)/2);\n            range(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k] = node[2*k+1] + node[2*k+2];\n        }\n    }\n    V query(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a){\n            return 0;\n        }\n        if(a <= l && r <= b){\n            return node[k];\n        }\n        V vl = query(a, b, 2*k+1, l, (l+r)/2);\n        V vr = query(a, b, 2*k+2, (l+r)/2, r);\n        return vl + vr;\n    }\n    void print()\n    {\n        rep(i,sz){\n            cout << query(i,i+1) << \" \";\n        }\n        cout << endl;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,q;\n    cin >> n >> q;\n    vector<int> vec(n,0);\n    segtree2<int> sg2(vec);\n    rep(i,q){\n        int a;\n        cin >> a;\n        if(a==0){\n            int b,c,d;\n            cin >> b >> c >> d;\n            sg2.range(b,c+1,d);\n        }else{\n            int b,c;\n            cin >> b >> c;\n            cout << sg2.query(b,c+1) << \"\\n\";\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, n) for(int i = 0; i < n; i++)\n#define REPR(i, n) for(int i = n - 1; i >= 0; i--)\n#define FOR(i, m, n) for(int i = m; i <= n; i++)\n#define FORR(i, m, n) for(int i = m; i >= n; i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n \nusing ll = long long;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nusing P = pair<ll, ll>;\n\nll B = 400;\n// バケット i は [i*B, (i+1)*B) の記録を持つ\n// lazy[i] :=  バケットi の遅延を記録する\n// update の単位元を10000とする\n// i.e. lazy[i] == 10000 のときは消化時に何も伝播させないという遅延を与えるとみなして例外処理を行う\n// sum[i] := パケットi の総和\nvll lazy(B, 0), sum(B, 0), a(100000, 0);\nll unit = 10000;\n \n// a_s, ..., a_t に x を加算する\nvoid update(int s, int t, int x){\n    // s の属するバケット, t の属するバケット\n    int st = s / B, gt = t / B;\n\n    // st や gt に遅延を消化しておく\n    // 遅延はパケットごとに考えるから, 遅延が存在⇔パケット内は全て等しい値に更新されている\n    // したがって sum[st] = B * lazy[st] が成立\n    if (lazy[st] != unit){\n        for (int i = st * B; i < (st + 1) * B; i++) a[i] = lazy[st];\n        sum[st] = B * lazy[st];\n        lazy[st] = unit;\n    }\n    if (lazy[gt] != unit){\n        for (int i = gt * B; i < (gt + 1) * B; i++) a[i] = lazy[gt];\n        sum[gt] = B * lazy[gt];\n        lazy[gt] = unit;\n    }\n    \n    //... || ... s ... t ... || ...\n    //更新が同一パケット内で済むなら直接更新しても間に合う\n    if (st == gt){\n        for (int i = s; i <= t; i++) a[i] = x;\n        sum[st] = 0;\n        for (int i = st * B; i < (st + 1) * B; i++) sum[st] += a[i];\n    }\n\n    //... s ... || (被覆されるパケット) || ... t ...\n    else{\n        //端が属するパケット内は直接更新\n        for (int i = s; i < (st + 1) * B; i++) a[i] = x;\n        sum[st] = 0;\n        for (int i = st * B; i < (st + 1) * B; i++) sum[st] += a[i];\n \n        for (int i = gt * B; i <= t; i++) a[i] = x;\n        sum[gt] = 0;\n        for (int i = gt * B; i < (gt + 1) * B; i++) sum[gt] += a[i];\n\n        //区間に被覆されるパケットについては更新を遅延に残す\n        //区間内はすべて x に更新されるのでパケット内の総和は B * x になる\n        for (int i = st + 1; i < gt; i++){\n            lazy[i] = x;\n            sum[i] = B * x;\n        }\n    }\n}\n \n// a_s,...,a_t の sum を返す\nll getsum(int s, int t){\n    ll ret = 0;\n    int st = s / B, gt = t / B;\n\n    // まずは端の遅延を消化\n    if (lazy[st] != unit){\n        for (int i = st * B; i < (st + 1) * B; i++) a[i] = lazy[st];\n        sum[st] = B * lazy[st];\n        lazy[st] = unit;\n    }\n    if (lazy[gt] != unit){\n        for (int i = gt * B; i < (gt + 1) * B; i++) a[i] = lazy[gt];\n        sum[gt] = B * lazy[gt];\n        lazy[gt] = unit;\n    }\n\n    //... || ... s ... t ... || ...\n    //直接計算\n    if (st == gt){\n        for (int i = s; i <= t; i++) ret += a[i];\n    }\n    //... s ... || (被覆されるパケット)  || ... t ...\n    else{\n        //端が属するパケット内は直接計算\n        for (int i = s; i < (st + 1) * B; i++) ret += a[i];\n        for (int i = gt * B; i <= t; i++) ret += a[i];\n\n        //被覆されるパケットはパケット単位で調査する\n        for (int i = st + 1; i < gt; i++){\n            //遅延が存在しない場合, update() によって sum[i] に和が保持されている\n            if (lazy[i] == unit) ret += sum[i];\n            //遅延が存在するならばパケット内は全て等しい値 lazy[i] になっている\n            else ret += B * lazy[i];\n        }\n    }\n    return ret;\n}\n \nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, q;\n    cin >> n >> q;\n    REP(i, q){\n        int type;\n        cin >> type;\n        if(type == 0){\n            int s, t, x;\n            cin >> s >> t >> x;\n            update(s, t, x);\n        }\n        else{\n            int s, t;\n            cin >> s >> t;\n            cout << getsum(s, t) << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\ntemplate<typename T, typename E> struct LazySegmentTree;\n\ntemplate<typename T, typename E> struct QueryObject {\n  LazySegmentTree<T, E> *lst;\n  int a, b;\n  E x;\n  int k;\n  int l, r;\n  QueryObject(LazySegmentTree<T, E> *lst,\n      int a, int b, E x = 0, int k = 0, int l = 0, int r = -1)\n      : lst(lst), a(a), b(b), x(x), k(k), l(l), r(r) {}\n};\n\ntemplate<typename T, typename E> struct QueryType {\n  virtual int outOfRange(QueryObject<T, E> o) = 0;\n  virtual int cover(QueryObject<T, E> o) = 0;\n  virtual int join(QueryObject<T, E> o, T vl, T vr) = 0;\n  T query(QueryObject<T, E> o) {\n    if (o.r < 0) o.r = o.lst->n;\n    o.lst->eval(o.r - o.l, o.k);\n    if (o.b <= o.l || o.r <= o.a) return outOfRange(o);\n    if (o.a <= o.l && o.r <= o.b) return cover(o);\n    QueryObject<T, E> o1 = o, o2 = o;\n    o1.k = o.k * 2 + 1; o1.r = (o.l + o.r) / 2;\n    o2.k = o.k * 2 + 2; o2.l = (o.l + o.r) / 2;\n    T vl = query(o1);\n    T vr = query(o2);\n    return join(o, vl, vr);\n  }\n};\n\ntemplate<typename T, typename E> struct Setter : QueryType<T, E> {\n  enum setter { RUQ, RAQ };\n  int outOfRange(QueryObject<T, E> o) {\n    return o.lst->data[o.k];\n  }\n  int cover(QueryObject<T, E> o) {\n    o.lst->lazy[o.k] = o.lst->h(o.lst->lazy[o.k], o.x);\n    o.lst->eval(o.r - o.l, o.k);\n    return o.lst->data[o.k];\n  }\n  int join(QueryObject<T, E> o, T vl, T vr) {\n    return o.lst->data[o.k] = o.lst->f(vl, vr);\n  }\n};\n\ntemplate<typename T, typename E> struct Getter : QueryType<T, E> {\n  enum getter { RMQ, RSQ };\n  int outOfRange(QueryObject<T, E> o) {\n    return o.lst->initT;\n  }\n  int cover(QueryObject<T, E> o) {\n    return o.lst->data[o.k];\n  }\n  int join(QueryObject<T, E> o, T vl, T vr) {\n    return o.lst->f(vl, vr);\n  }\n};\n\ntemplate<typename T, typename E> struct LazySegmentTree {\n  using F = function<T(T, T)>;\n  using G = function<T(T, E)>;\n  using H = function<E(E, E)>;\n  using P = function<E(E, int)>;\n  F add() {\n    return [&](const T& x, const T& y) -> const T { return x + y; };\n  }\n  F minimum() {\n    return [&](const T& x, const T& y) -> const T { return min(x, y); };\n  }\n  G ex_assign(E initE) {\n    return [&initE](const T& x, const E& y) -> const T { return (y == initE) ? x : y; };\n  }\n  P ex_multiplies(E initE) {\n    return [&initE](const E& x, int y) -> const E { return (x == initE) ? x : x * y; };\n  }\n\n  int n;\n  T initT;\n  E initE;\n  F f;\n  G g;\n  H h;\n  P p;\n  vector<T> data;\n  vector<E> lazy;\n  QueryType<T, E> *type;\n\n  LazySegmentTree() {}\n  LazySegmentTree(QueryType<T, E> *type_) { type = type_; }\n  LazySegmentTree(int n_, int setter, int getter,\n      T initT_ = 0, E initE_ = 1e9, vector<T> v = vector<T>{}) {\n    setQuery(setter, getter, initT_, initE_);\n    n = 1;\n    while (n < n_) n *= 2;\n    data.assign(n * 2 - 1, initT);\n    lazy.assign(n * 2 - 1, initE);\n    if (n_ == v.size()) build(v);\n  }\n  void build(vector<T> v) {\n    for (int i = 0; i < v.size(); ++i) data[i + n - 1] = v[i];\n    for (int i = n - 2; i >= 0; --i) {\n      data[i] = f(data[i * 2 + 1], data[i * 2 + 2]);\n    }\n  }\n  void setQuery(int setter, int getter, T initT_, E initE_) {\n    initT = vector<T>{initT_, 0}[getter];\n    initE = vector<E>{initE_, 0}[setter];\n    f = vector<F>{minimum(), add()}[getter];\n    g = vector<G>{ex_assign(initE), add()}[setter];\n    h = vector<H>{ex_assign(initE), add()}[setter];\n    p = ex_multiplies(initE);\n  }\n  inline void eval(int len, int k) {\n    if (lazy[k] == initE) return;\n    if (k * 2 + 1 < n * 2 - 1) {\n      lazy[k * 2 + 1] = h(lazy[k * 2 + 1], lazy[k]);\n      lazy[k * 2 + 2] = h(lazy[k * 2 + 2], lazy[k]);\n    }\n    data[k] = g(data[k], p(lazy[k], len));\n    lazy[k] = initE;\n  }\n  T query(QueryObject<T, E> obj) {\n    return type->query(obj);\n  }\n  T setData(int a, int b, E x) {\n    LazySegmentTree<T, E> lst(new Setter<T, E>());\n    QueryObject<T, E> obj(this, a, b, x);\n    return lst.query(obj);\n  }\n  T getData(int a, int b) {\n    LazySegmentTree<T, E> lst(new Getter<T, E>());\n    QueryObject<T, E> obj(this, a, b);\n    return lst.query(obj);\n  }\n};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, q; cin >> n >> q;\n  LazySegmentTree<ll, ll> seg(n, Setter<ll, ll>::RUQ, Getter<ll, ll>::RSQ);\n\n  while (q--) {\n    int com; cin >> com;\n    if (com) {\n      int s, t; cin >> s >> t;\n      cout << seg.getData(s, t + 1) << endl;\n    } else {\n      int s, t, x; cin >> s >> t >> x;\n      seg.setData(s, t + 1, x);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=100005;\n\nint n,q;\nint S[4*maxn],lazy[4*maxn];\n\nvoid upd(int id,int l,int r,int ql,int qr,int v) {\n    if (ql==l && qr==r) {\n        lazy[id]=v;\n        return;\n    }\n    if (lazy[id]!=-1005) {\n        S[id]=lazy[id]*(r-l+1);\n        if (l!=r) {\n            lazy[id<<1]=lazy[id];\n            lazy[id<<1|1]=lazy[id];\n        }\n        lazy[id]=-1005;\n    }\n    int m=l+r>>1;\n    if (qr<=m) upd(id<<1,l,m,ql,qr,v);\n    else if (ql>m) upd(id<<1|1,m+1,r,ql,qr,v);\n    else upd(id<<1,l,m,ql,m,v),\n         upd(id<<1|1,m+1,r,m+1,qr,v);\n    S[id]=(lazy[id<<1]!=-1005?lazy[id<<1]*(m-l+1):S[id<<1])+\n          (lazy[id<<1|1]!=-1005?lazy[id<<1|1]*(r-m):S[id<<1|1]);\n}\n\nint query(int id,int l,int r,int ql,int qr) {\n    if (lazy[id]!=-1005) {\n        S[id]=lazy[id]*(r-l+1);\n        if (l!=r) {\n            lazy[id<<1]=lazy[id];\n            lazy[id<<1|1]=lazy[id];\n        }\n        lazy[id]=-1005;\n    }\n    if (ql==l && qr==r) return S[id];\n    int m=l+r>>1;\n    if (qr<=m) return query(id<<1,l,m,ql,qr);\n    else if (ql>m) return query(id<<1|1,m+1,r,ql,qr);\n    else return query(id<<1,l,m,ql,m)+query(id<<1|1,m+1,r,m+1,qr);\n}\n\nint main() {\n    cin>>n>>q;\n    for (int i=0;i<q;i++) {\n        int f,s,t,x; cin>>f>>s>>t;\n        if (f) cout<<query(1,0,n-1,s,t)<<'\\n';\n        else {\n            cin>>x;\n            upd(1,0,n-1,s,t,x);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n\n// RAQ RUQ and RSQ\n// varify : https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/2/DSL_2_G\n// varify : https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/2/DSL_2_I\ntemplate<typename Monoid>\nstruct LazySegmentTree {\nprivate:\n    using Func = std::function<Monoid(Monoid, Monoid)>;\n    Func F = [](Monoid a, Monoid b) { return a + b; };\n    Monoid UNITY = 0;\n    int n;\n    std::vector<Monoid> node, lazy;\n    std::vector<int> prop; // 何を伝播させるか 1:add 2:update\n\n    // propagation\n    void eval(int k, int l, int r) {\n        if (prop[k] != 0) {\n            node[k] = lazy[k] + (prop[k] == 1 ? node[k] : 0);\n            if (r - l > 1) {\n                lazy[2 * k + 1] = lazy[k] / 2 + (prop[k] == 1 ? lazy[2 * k + 1] : 0);\n                lazy[2 * k + 2] = lazy[k] / 2 + (prop[k] == 1 ? lazy[2 * k + 2] : 0);\n                prop[2 * k + 1] = prop[2 * k + 2] = prop[k];\n            }\n            lazy[k] = 0;\n            prop[k] = 0;\n        }\n    }\npublic:\n    LazySegmentTree(int m, Monoid val = LazySegmentTree::UNITY) {\n        n = 1; while (n < m) n <<= 1;\n        node.resize(n * 2 - 1, val);\n        lazy.resize(n * 2 - 1, 0);\n        prop.resize(n * 2 - 1, 0);\n        if (val != LazySegmentTree::UNITY) {\n            for (int i = n - 2; i >= 0; i--) node[i] = F(node[2 * i + 1], node[2 * i + 2]);\n        }\n    }\n\n    LazySegmentTree(const std::vector<Monoid>& v) {\n        int sz = v.size();\n        n = 1; while (n < sz) n <<= 1;\n        node.resize(n * 2 - 1, UNITY);\n        lazy.resize(n * 2 - 1, 0);\n        prop.resize(n * 2 - 1, 0);\n        for (int i = 0; i < sz; i++) node[i + n - 1] = v[i];\n        for (int i = n - 2; i >= 0; i--) node[i] = F(node[2 * i + 1], node[2 * i + 2]);\n    }\n\n    // 最後に build が必要\n    void set(int k, const Monoid &x) {\n        node[n + k - 1] = x;\n    }\n\n    void build() {\n        for (int i = n - 2; i >= 0; i--) node[i] = F(node[2 * i + 1], node[2 * i + 2]);\n    }\n\n    // [a,b) add\n    void add_query(int a, int b, Monoid x, int k = 0, int l = 0, int r = -1) {\n        if (r < 0) r = n;\n        eval(k, l, r);\n\n        // out of range\n        if (b <= l || r <= a) return;\n\n        if (a <= l && r <= b) {\n            prop[k] = 1;\n            lazy[k] += (r - l) * x;\n            eval(k, l, r);\n        }\n        else {\n            add_query(a, b, x, 2 * k + 1, l, (r - l) / 2 + l);\n            add_query(a, b, x, 2 * k + 2, (r - l) / 2 + l, r);\n            node[k] = F(node[2 * k + 1], node[2 * k + 2]);\n        }\n    }\n\n    // [a,b) update\n    void update_query(int a, int b, Monoid x, int k = 0, int l = 0, int r = -1) {\n        if (r < 0) r = n;\n        eval(k, l, r);\n\n        // out of range\n        if (b <= l || r <= a) return;\n\n        if (a <= l && r <= b) {\n            prop[k] = 2;\n            lazy[k] = (r - l) * x;\n            eval(k, l, r);\n        }\n        else {\n            update_query(a, b, x, 2 * k + 1, l, (r - l) / 2 + l);\n            update_query(a, b, x, 2 * k + 2, (r - l) / 2 + l, r);\n            node[k] = F(node[2 * k + 1], node[2 * k + 2]);\n        }\n    }\n\n    // [a,b) sum\n    Monoid get_query(int a, int b, int k = 0, int l = 0, int r = -1) {\n        if (r < 0) r = n;\n        if (r <= a || b <= l) return UNITY;\n        eval(k, l, r);\n        if (a <= l && r <= b) return node[k];\n        Monoid vl = get_query(a, b, 2 * k + 1, l, (r - l) / 2 + l);\n        Monoid vr = get_query(a, b, 2 * k + 2, (r - l) / 2 + l, r);\n        return F(vl, vr);\n    }\n\n    Monoid operator[](int x) {\n        return get_query(x, x + 1);\n    }\n\n    void print() {\n        for (int i = 0; i < n; i++) {\n            std::cout << i << \"\\t: \" << get_query(i, i + 1) << std::endl;\n        }\n    }\n};\n\nint main() {\n    int n, q; cin >> n >> q;\n    LazySegmentTree<ll> seg(n, 0);\n    for (int _ = 0; _ < q; _++) {\n        int p; cin >> p;\n        if (p == 0) {\n            int s, t, x; cin >> s >> t >> x;\n            //s--; t--;\n            seg.update_query(s, t + 1, x);\n            //seg.print();\n        }\n        else {\n            int s, t; cin >> s >> t;\n            //s--; t--;\n            cout << seg.get_query(s, t + 1) << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint ri() {\n\tint n;\n\tscanf(\"%d\", &n);\n\treturn n;\n}\n\nstruct AVL {\n\tstruct Node {\n\t\tint l;\n\t\tint r;\n\t\tint val;\n\t\tint sum;\n\t\tint lazy;\n\t\tint size;\n\t\tint height;\n\t};\n\tstatic std::vector<Node> nodes;\n\tint root = 0;\n\tAVL() {\n\t\tif (!nodes.size()) nodes.push_back({0, 0, 0, 0, -1000000000, 0, 0});\n\t}\nprivate:\n\tAVL(int root) : root(root) {}\n\tstatic inline int fetch(int i) {\n\t\tflush(i);\n\t\tif (nodes[i].l) flush(nodes[i].l);\n\t\tif (nodes[i].r) flush(nodes[i].r);\n\t\tnodes[i].size = 1 + nodes[nodes[i].l].size + nodes[nodes[i].r].size;\n\t\tnodes[i].height = 1 + std::max(nodes[nodes[i].l].height, nodes[nodes[i].r].height);\n\t\tnodes[i].sum = nodes[i].val + nodes[nodes[i].l].sum + nodes[nodes[i].r].sum;\n\t\treturn i;\n\t}\n\tstatic inline void flush(int i) {\n\t\tint val = nodes[i].lazy;\n\t\tif (val != -1000000000) {\n\t\t\tnodes[nodes[i].l].lazy = val;\n\t\t\tnodes[nodes[i].r].lazy = val;\n\t\t\tnodes[i].val = val;\n\t\t\tnodes[i].sum = val * nodes[i].size;\n\t\t}\n\t\tnodes[i].lazy = -1000000000;\n\t}\n\tstatic inline int rotate_l(int i) {\n\t\tflush(i);\n\t\tif (nodes[i].l) flush(nodes[i].l);\n\t\tif (nodes[i].r) flush(nodes[i].r);\n\t\tint new_root = nodes[i].r;\n\t\tnodes[i].r = nodes[new_root].l;\n\t\tnodes[new_root].l = i;\n\t\tfetch(i);\n\t\tfetch(new_root);\n\t\treturn new_root;\n\t}\n\tstatic inline int rotate_r(int i) {\n\t\tflush(i);\n\t\tif (nodes[i].l) flush(nodes[i].l);\n\t\tif (nodes[i].r) flush(nodes[i].r);\n\t\tint new_root = nodes[i].l;\n\t\tnodes[i].l = nodes[new_root].r;\n\t\tnodes[new_root].r = i;\n\t\tfetch(i);\n\t\tfetch(new_root);\n\t\treturn new_root;\n\t}\n\tstatic inline int height_diff(int i) {\n\t\treturn nodes[nodes[i].l].height - nodes[nodes[i].r].height;\n\t}\n\tstatic int balance(int i) {\n\t\tint dif = height_diff(i);\n\t\tif (dif == 2) {\n\t\t\tif (height_diff(nodes[i].l) < 0) nodes[i].l = rotate_l(nodes[i].l);\n\t\t\treturn rotate_r(i);\n\t\t} else if (dif == -2) {\n\t\t\tif (height_diff(nodes[i].r) > 0) nodes[i].r = rotate_r(nodes[i].r);\n\t\t\treturn rotate_l(i);\n\t\t} else return fetch(i);\n\t}\n\tstatic int insert(int node, int index, int val) {\n\t\tif (!node) {\n\t\t\tnodes.push_back({0, 0, val, val, -1000000000, 1, 1});\n\t\t\treturn nodes.size() - 1;\n\t\t}\n\t\tflush(node);\n\t\tint lsize = nodes[nodes[node].l].size, tmp;\n\t\tif (index <= lsize) tmp = insert(nodes[node].l, index, val), nodes[node].l = tmp;\n\t\telse tmp = insert(nodes[node].r, index - lsize - 1, val), nodes[node].r = tmp;\n\t\treturn balance(node);\n\t}\n\tstatic int removed_tmp;\n\tstatic int remove_rightest(int i) {\n\t\tflush(i);\n\t\tif (nodes[i].r) {\n\t\t\tnodes[i].r = remove_rightest(nodes[i].r);\n\t\t\treturn balance(i);\n\t\t} else return nodes[removed_tmp = i].l;\n\t}\n\tstatic int remove(int node, int index) {\n\t\tflush(node);\n\t\tint lsize = nodes[nodes[node].l].size;\n\t\tif (index < lsize) nodes[node].l = remove(nodes[node].l, index);\n\t\telse if (index > lsize) nodes[node].r = remove(nodes[node].r, index - lsize - 1);\n\t\telse {\n\t\t\tif (!nodes[node].l) return nodes[node].r;\n\t\t\tif (!nodes[node].r) return nodes[node].l;\n\t\t\tnodes[node].l = remove_rightest(nodes[node].l);\n\t\t\tnodes[removed_tmp].l = nodes[node].l;\n\t\t\tnodes[removed_tmp].r = nodes[node].r;\n\t\t\treturn balance(removed_tmp);\n\t\t}\n\t\treturn balance(node);\n\t}\n\t\n\tstatic int merge_with_root(int l, int root, int r) {\n\t\tint dif = nodes[l].height - nodes[r].height;\n\t\tif (-1 <= dif && dif <= 1) {\n\t\t\tnodes[root].l = l;\n\t\t\tnodes[root].r = r;\n\t\t\treturn fetch(root);\n\t\t} else if (dif > 0) {\n\t\t\tnodes[l].r = merge_with_root(nodes[l].r, root, r);\n\t\t\treturn balance(l);\n\t\t} else {\n\t\t\tnodes[r].l = merge_with_root(l, root, nodes[r].l);\n\t\t\treturn balance(r);\n\t\t}\n\t}\n\tstatic int merge(int l, int r) {\n\t\tif (!l) return r;\n\t\tif (!r) return l;\n\t\tl = remove_rightest(l);\n\t\treturn merge_with_root(l, removed_tmp, r);\n\t}\n\tstatic std::pair<int, int> split(int node, int index) {\n\t\tif (!node) return {0, 0};\n\t\tflush(node);\n\t\tint l = nodes[node].l;\n\t\tint r = nodes[node].r;\n\t\tint lsize = nodes[l].size;\n\t\tnodes[node].l = nodes[node].r = 0;\n\t\tif (index < lsize) {\n\t\t\tstd::pair<int, int> tmp = split(l, index);\n\t\t\treturn {tmp.first, merge_with_root(tmp.second, node, r)};\n\t\t} else if (index > lsize) {\n\t\t\tstd::pair<int, int> tmp = split(r, index - lsize - 1);\n\t\t\treturn {merge_with_root(l, node, tmp.first), tmp.second};\n\t\t} else return {l, merge(fetch(node), r)};\n\t}\n\tstatic int sum(int node, int l, int r) {\n\t\tflush(node);\n\t\tif (l <= 0 && r >= nodes[node].size) return nodes[node].sum;\n\t\tint res = 0;\n\t\tint lsize = nodes[nodes[node].l].size;\n\t\tif (l <= lsize && r > lsize) res = nodes[node].val;\n\t\tif (l < lsize && nodes[node].l) res += sum(nodes[node].l, l, r);\n\t\tif (r > lsize + 1 && nodes[node].r) res += sum(nodes[node].r, l - lsize - 1, r - lsize - 1);\n\t\treturn res;\n\t}\n\tstatic int update(int node, int l, int r, int val) {\n\t\tflush(node);\n\t\tif (l <= 0 && r >= nodes[node].size) {\n\t\t\tnodes[node].lazy = val;\n\t\t\tflush(node);\n\t\t\treturn node;\n\t\t}\n\t\tint lsize = nodes[nodes[node].l].size;\n\t\tif (l <= lsize && r > lsize) nodes[node].val = val;\n\t\tif (l < lsize && nodes[node].l) update(nodes[node].l, l, r, val);\n\t\tif (r > lsize + 1 && nodes[node].r) update(nodes[node].r, l - lsize - 1, r - lsize - 1, val);\n\t\treturn fetch(node);\n\t}\npublic:\n\tvoid insert(int index, int val) {\n\t\troot = insert(root, index, val);\n\t}\n\tvoid remove(int index) {\n\t\tassert(root);\n\t\troot = remove(root, index);\n\t}\n\tint operator [] (int i) {\n\t\tint cur = root;\n\t\twhile (1) {\n\t\t\tflush(cur);\n\t\t\tint lsize = nodes[nodes[cur].l].size;\n\t\t\tif (i < lsize) cur = nodes[cur].l;\n\t\t\telse if (i > lsize) cur = nodes[cur].r, i -= lsize + 1;\n\t\t\telse return nodes[cur].val;\n\t\t}\n\t}\n\tstatic AVL merge(AVL l, AVL r) {\n\t\treturn AVL(merge(l.root, r.root));\n\t}\n\tstd::pair<AVL, AVL> split(int index) {\n\t\tauto res = split(root, index);\n\t\treturn {AVL(res.first), AVL(res.second)};\n\t}\n\tint sum(int l, int r) {\n\t\treturn sum(root, l, r);\n\t}\n\tvoid update(int l, int r, int val) {\n\t\tupdate(root, l, r, val);\n\t}\n\t\n\tvoid debug(int i, int indent) {\n\t\tif (!i) return;\n\t\tfor (int i = 0; i < indent; i++) std::cerr << \" \";\n\t\tstd::cerr << i << \": val:\" << nodes[i].val << \" size:\" << nodes[i].size << \" height:\" << nodes[i].height << std::endl;\n\t\tif (nodes[i].l) debug(nodes[i].l, indent + 1);\n\t\tif (nodes[i].r) debug(nodes[i].r, indent + 1);\n\t}\n\tvoid debug() { debug(root, 0); }\n};\nstd::vector<AVL::Node> AVL::nodes;\nint AVL::removed_tmp;\n\nint main() {\n\tint n = ri(), q = ri();\n\tAVL tree;\n\tfor (int i = 0; i < n; i++) tree.insert(0, 0);\n\tfor (int i = 0; i < q; i++) {\n\t\tif (ri()) {\n\t\t\tint s = ri(), t = ri();\n\t\t\tprintf(\"%d\\n\", tree.sum(s, t + 1));\n\t\t} else {\n\t\t\tint s = ri(), t = ri(), x = ri();\n\t\t\ttree.update(s, t + 1, x);\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\n/*Starry Sky Tree*/\n/*Range Add Min(Max) Query*/\n/*区間加算、区間Min,区間Max*/\n\nclass RSUQ{\npublic: \n  \n  //遅延用の型  \n  struct T{\n    int type; //0 - empty   , 1 - update\n    int value;\n    T():type(0),value(0){}\n    T(int type,int value):type(type),value(value){}\n  };\n\n  //マージ可能な主データ型\n  struct D{\n    int value;\n    D():value(0){} /*適切な値にする!!!!!!*/\n    D(int value):value(value){}\n    bool operator < (D a)const {return value < a.value;} //merge用\n  };\n  \n  int n;\n  vector<D> dat;\n  vector<T> td;\n  D returnD = D(0); // 範囲外の時に返す値。\n  \n  RSUQ(){n=-1;}\n  RSUQ(int n_){\n    n=1;\n    while(n<n_)n*=2;\n    td.resize(2*n-1,T());\n    dat.resize(2*n-1,D());\n  }\n  \n  D merge(D a,D b){return a.value + b.value;}\n  \n  void delay(int k,int len){\n    if(td[k].type==0) return;\n    int v = td[k].value;\n    td[k].type = 0;\n    td[k].value = 0;\n    \n    len /= 2;\n    int l = k*2+1,r = k*2+2;\n    dat[l].value = v * len; td[l].type = 1; td[l].value = v;\n    dat[r].value = v * len; td[r].type = 1; td[r].value = v;\n  }\n\n  D update(int k,int x, int len){\n    dat[k].value = x * len;\n    td[k].type = 1;\n    td[k].value = x;\n    return dat[k];\n  }\n  \n  //[a,b)の値をx変更　add(a,b,x)\n  D query(int a,int b,int x,bool flg=true,int k=0,int l=0,int r=-1){\n    if(r==-1) r=n, assert(a <= n && b <= n);\n    if(r<=a||b<=l) return flg? dat[k]:returnD;\n    if(a<=l&&r<=b) return flg? update(k, x, r - l):dat[k];\n    \n    delay(k, r - l);\n    D vl = query(a,b,x,flg,k*2+1,l,(l+r)/2);\n    D vr = query(a,b,x,flg,k*2+2,(l+r)/2,r);\n    if(flg) dat[k] = merge(vl,vr);\n    return merge(vl,vr);\n  }\n  \n  //[a,b)の合計値を得る　find(a,b);\n  int find(int a,int b){\n    D res = query(a,b,0,false);\n    return res.value;\n  }\n};\n\n\nsigned main(){\n  int n,q;\n  cin>>n>>q;\n  \n  RSUQ rsuq(n);\n\n  //  rsuq.update(0, n-1, 1);\n  //for(int i=0;i<n;i++) cout<<rsuq.find(i, i+1)<<endl;\n  \n  while(q--){\n    int cmd;\n    cin>>cmd;\n    if(cmd == 0){\n      int s,t,x;\n      cin>>s>>t>>x;\n      rsuq.query(s,t+1,x);\n    }\n    if(cmd == 1){\n      int s,t;\n      cin>>s>>t;\n      assert(s != t);\n      cout<<rsuq.find(s,t+1)<<endl;\n    }\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass segment_tree{\n    vector<int64_t> val;\n    vector<pair<int64_t, int64_t>> op;\n    vector<pair<size_t, size_t>> range;\n\n    const pair<int64_t, int64_t> ident = {1, 0};\n    size_t N, depth;\n\n    inline void merge(size_t target, int64_t alpha, int64_t beta){\n        op[target] = {op[target].first * alpha, op[target].second * alpha + beta};\n    }\n    inline void propagate(size_t target){\n        if(op[target] == ident) return;\n        // min, max -> width = 1\n        val[target] = op[target].first * val[target] + op[target].second * (range[target].second - range[target].first);\n        if(target  < N){\n            merge(2*target, op[target].first, op[target].second);\n            merge(2*target+1, op[target].first, op[target].second);\n        }\n        op[target] = ident;\n    }\n    \n    inline void eval(int n){\n        stack<size_t> stk;\n        for(;n>0;n>>=1) stk.push(n);\n        while(!stk.empty()){\n            propagate(stk.top());\n            stk.pop();\n        }\n    }\n    inline void get_target(vector<size_t> &target, size_t left, size_t right, stack<size_t> *refresh=nullptr){\n        queue<size_t> partial;\n        \n        if(left <= 0 && right >= N) target.push_back(1);\n        else partial.push(1);\n\n        while(!partial.empty()){\n            size_t i = partial.front();\n            if(refresh != nullptr) refresh->push(i);\n            partial.pop();\n\n            propagate(i);\n\n            if(left <= range[i].first){\n                if(right < range[i*2].second) partial.push(i*2);\n                else{\n                    target.push_back(i*2);\n                    if(range[i*2+1].first < right) partial.push(i*2+1);\n                }\n            }else{\n                if(left < range[i*2].second){\n                    partial.push(i*2);\n                    if(range[i*2+1].second <= right) target.push_back(i*2+1);\n                    else if(range[i*2].second < right) partial.push(i*2+1); \n                }else{\n                    if(left <= range[i*2+1].first && range[i*2+1].second <= right) target.push_back(i*2+1);\n                    else partial.push(i*2+1);\n                }\n            }\n        }\n    }\npublic:\n    segment_tree(size_t n){\n        for(depth=0;(1ULL<<depth)<n;depth++);\n        N = 1ULL<<depth;\n        val.reserve(1ULL<<(++depth));\n        op.reserve(1ULL<<depth);\n        range.reserve(1ULL<<depth);\n        for(size_t i=2*N-1;i>0;i--){\n            op[i] = ident;\n            if(i>=N) range[i] = {i-N, i-N+1};\n            else range[i] = {range[2*i].first, range[2*i+1].second};\n        }\n    }\n    int64_t operator[](size_t i){\n        eval(N+i);\n        return val[N+i];\n    }\n    void operate(int64_t alpha, int64_t beta, size_t left, size_t right){\n        if(right <= left) return;\n\n        vector<size_t> target;\n        stack<size_t> refresh;\n        get_target(target, left, right, &refresh);\n        for(auto i : target){\n            merge(i, alpha, beta);\n            propagate(i);\n        }\n        while(!refresh.empty()){\n            size_t i = refresh.top();\n            refresh.pop();\n            //min, max -> change\n            propagate(i*2);\n            propagate(i*2+1);\n            val[i] = val[i*2] + val[i*2+1];\n        }\n    }\n    int64_t get_sum(size_t left, size_t right){\n        if(right <= left) return 0;\n        \n        vector<size_t> target;\n        get_target(target, left, right);\n        int64_t ret = 0;\n        for(auto i : target){\n            ret += op[i].first * val[i] + op[i].second * (range[i].second - range[i].first);\n        }\n        return ret;\n    }\n    void update(int64_t val, size_t pos){\n        operate(0, val, pos, pos+1);\n    }\n    void update(int64_t val, size_t left, size_t right){\n        operate(0, val, left, right);\n    }\n    void add(int64_t val, size_t pos){\n        operate(1, val, pos, pos+1);\n    }\n    void add(int64_t val, size_t left, size_t right){\n        operate(1, val, left, right);\n    }\n\n    void dump(){\n        for(int i=1;i<2*N;i++){\n            eval(i);\n            cerr << val[i] << \" \";\n        }\n        cerr << endl;\n    }\n};\n\nint main(){\n    int n, q;\n    cin >> n >> q;\n    segment_tree st(n);\n\n    for(int i=0;i<q;i++){\n        int com;\n        cin >> com;\n        if(com == 0){\n            int s, t, x;\n            cin >> s >> t >> x;\n            st.update(x, s, t+1);\n        }else{\n            int s, t;\n            cin >> s >> t;\n            cout << st.get_sum(s, t+1) << endl;\n        }\n        //st.dump();\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nこのコード、と～おれ!\nBe accepted!\n∧＿∧　\n（｡･ω･｡)つ━☆・*。\n⊂　　 ノ 　　　・゜+.\n　しーＪ　　　°。+ *´¨)\n 　　　　　　　　　.· ´¸.·*´¨) ¸.·*¨)\n\t\t  　　　　　　　　　　(¸.·´ (¸.·'* ☆\n*/\n\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <numeric>\n#include <iostream>\n#include <random>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <regex>\n#include <functional>\n#include <complex>\n#include <list>\n#include <cassert>\n#include <iomanip>\n#include <set>\n#include <stack>\n/*多倍長整数/cpp_intで宣言\n#include <boost/multiprecision/cpp_int.hpp>\nusing namespace boost::multiprecision;\n*/\n\n//#pragma gcc target (\"avx2\")\n//#pragma gcc optimization (\"o3\")\n//#pragma gcc optimization (\"unroll-loops\")\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define rep1(i, n) for(int i = 1; i <= (n); ++i)\n#define rep2(i, n) for(int i = 2; i < (n); ++i)\n#define repr(i, n) for(int i = n; i >= 0; --i)\n#define reprm(i, n) for(int i = n - 1; i >= 0; --i)\n#define printynl(a) printf(a ? \"yes\\n\" : \"no\\n\")\n#define printyn(a) printf(a ? \"Yes\\n\" : \"No\\n\")\n#define printYN(a) printf(a ? \"YES\\n\" : \"NO\\n\")\n#define printim(a) printf(a ? \"possible\\n\" : \"imposible\\n\")\n#define printdb(a) printf(\"%.50lf\\n\", a) //少数出力\n#define printLdb(a) printf(\"%.50Lf\\n\", a) //少数出力\n#define printdbd(a) printf(\"%.16lf\\n\", a) //少数出力(桁少なめ)\n#define prints(s) printf(\"%s\\n\", s.c_str()) //string出力\n#define all(x) (x).begin(), (x).end()\n#define allsum(a, b, c) ((a + b) * c / 2LL) //等差数列の和、初項,末項,項数\n#define pb push_back\n#define priq priority_queue\n#define rpriq priq<int, vector<int>, greater<int>>\n#define deg_to_rad(deg) (((deg)/360.0L)*2.0L*PI)\n#define rad_to_deg(rad) (((rad)/2.0L/PI)*360.0L)\n#define Please return\n#define AC 0\n#define manhattan_dist(a, b, c, d) (abs(a - c) + abs(b - d)) /*(a, b) から (c, d) のマンハッタン距離 */\n\n\nusing ll = long long;\n\nconstexpr int INF = 1073741823;\nconstexpr int MINF = -1073741823;\nconstexpr ll LINF = ll(4661686018427387903);\nconstexpr ll MOD = 1000000007;\nconst long double PI = acosl(-1.0L);\n\nusing namespace std;\n\nvoid scans(string& str) {\n\tchar c;\n\tstr = \"\";\n\tscanf(\"%c\", &c);\n\tif (c == '\\n')scanf(\"%c\", &c);\n\twhile (c != '\\n' && c != -1 && c != ' ') {\n\t\tstr += c;\n\t\tscanf(\"%c\", &c);\n\t}\n}\n\nvoid scanc(char& str) {\n\tchar c;\n\tscanf(\"%c\", &c);\n\tif (c == -1)return;\n\twhile (c == '\\n') {\n\t\tscanf(\"%c\", &c);\n\t}\n\tstr = c;\n}\n\ndouble acot(double x) {\n\treturn PI / 2 - atan(x);\n}\n\nll LSB(ll n) { return (n & (-n)); }\n\n/*-----------------------------------------ここからコード-----------------------------------------*/\n\n//セグ木/0-indexed/非再帰/n の大きさ, a (単位元), 本体のマージ関数, 遅延ノードの単位元, 遅延ノードのマージ関数, 遅延ノードと本体のマージ関数 で segtree を初期化する\ntemplate<typename T, typename U>\nstruct lazysegtree {\n\t//木を配列であらわしたもの\n\tvector<T> seg;\n\t//遅延ノード\n\tvector<U> lazy;\n\t//サイズノード\n\tvector<int> size;\n\t//遅延ノードのフラグ管理\n\tvector<bool> flag;\n\t//木の1/2の大きさ\n\tint siz, height;\n\t//本体の単位元\n\tconst T se;\n\t//遅延ノードの単位元\n\tconst U le;\n\t//本体のマージ関数の型\n\tusing F = function<T(T, T)>;\n\t//遅延ノードのマージ関数の型\n\tusing F2 = function<U(U, U)>;\n\t//遅延ノードと本体のマージ関数の型\n\tusing F3 = function<T(T, U)>;\n\t//サイズを使った演算をする関数の型\n\tusing F4 = function<U(U, int)>;\n\t//本体同士をマージする関数\n\tconst F f;\n\t//遅延ノード同士をマージする関数\n\tconst F2 f2;\n\t//遅延ノードと本体をマージする関数\n\tconst F3 f3;\n\t//サイズを使った演算をする関数\n\tconst F4 f4;\n\n\t//n の大きさ, a (単位元), 本体のマージ関数, 遅延ノードの単位元, 遅延ノードのマージ関数, 遅延ノードと本体のマージ関数, サイズを使った演算をする関数 で segtree を初期化する\n\tlazysegtree(int n, const T se, const F f, const U le, const F2 f2, const F3 f3, const F4 f4) : se(se), f(f), le(le), f2(f2), f3(f3), f4(f4) {\n\t\tsiz = 1;\n\t\theight = 0;\n\t\twhile (siz < n)siz <<= 1, ++height;\n\t\tseg.assign(2 * siz - 1, se);\n\t\tlazy.assign(2 * siz - 1, le);\n\t\tsize.assign(2 * siz - 1, 1);\n\t\tflag.assign(2 * siz - 1, false);\n\t\t--siz;\n\t}\n\n\t//k (0-indexed) 番目に t を代入\n\tvoid set(int k, const T& t) {\n\t\tseg[k + siz] = t;\n\t}\n\n\t//f によって木を構築\n\tvoid build() {\n\t\tfor (int i = siz - 1; i >= 0; --i) {\n\t\t\tseg[i] = f(seg[i * 2 + 1], seg[i * 2 + 2]);\n\t\t\tsize[i] = size[i * 2 + 1] + size[i * 2 + 2];\n\t\t}\n\t}\n\n\t//i 番目の要素を返す\n\tT operator[](const int i) {\n\t\treturn query(i, i + 1);\n\t}\n\n\t//k 番目の遅延ノードを伝播する\n\tinline T merge(int k) {\n\t\treturn (!flag[k] ? seg[k] : f3(seg[k], f4(lazy[k], size[k])));\n\t}\n\n\t//子に伝播\n\tinline void eval(int k) {\n\t\tif (flag[k]) {\n\t\t\tlazy[k * 2 + 1] = f2(lazy[k * 2 + 1], lazy[k]);\n\t\t\tlazy[k * 2 + 2] = f2(lazy[k * 2 + 2], lazy[k]);\n\t\t\tflag[k * 2 + 1] = flag[k * 2 + 2] = true;\n\t\t\tseg[k] = merge(k);\n\t\t\tlazy[k] = le;\n\t\t\tflag[k] = false;\n\t\t}\n\t}\n\n\tinline void bottomup(int k) {\n\t\twhile (k > 0) {\n\t\t\tk = ((k - 1) >> 1);\n\t\t\tseg[k] = f(merge(2 * k + 1), merge(2 * k + 2));\n\t\t}\n\t}\n\n\tinline void topdown(int k) {\n\t\tfor (int i = height; i > 0; --i) {\n\t\t\teval(((k + 1) >> i) - 1);\n\t\t}\n\t}\n\n\t//k 番目の値を a に更新\n\tvoid update(int k, T a) {\n\t\tk += siz;\n\t\t//必要であればここを変える\n\t\tseg[k] = a;\n\t\twhile (k > 0) {\n\t\t\tk = ((k - 1) >> 1);\n\t\t\tseg[k] = f(seg[k * 2 + 1], seg[k * 2 + 2]);\n\t\t}\n\t}\n\n\t//[l, r) の値を a に更新\n\tvoid update(int l, int r, T a) {\n\t\tint x = l + siz, y = r + siz - 1;\n\t\ttopdown(x);\n\t\ttopdown(y);\n\t\tfor (l += siz, r += siz; l < r; l >>= 1, r >>= 1) {\n\t\t\tif (!(l & 1)) {\n\t\t\t\tlazy[l] = f2(lazy[l], a);\n\t\t\t\tflag[l] = true;\n\t\t\t\t++l;\n\t\t\t}\n\t\t\tif (!(r & 1)) {\n\t\t\t\t--r;\n\t\t\t\tlazy[r] = f2(lazy[r], a);\n\t\t\t\tflag[r] = true;\n\t\t\t}\n\t\t}\n\t\tbottomup(x);\n\t\tbottomup(y);\n\t}\n\n\t//[a, b) について f した結果を返す\n\tT query(int a, int b) {\n\t\ttopdown(a += siz);\n\t\ttopdown(b += siz - 1);\n\t\tT l = se, r = se;\n\t\tfor (++b; a < b; a >>= 1, b >>= 1) {\n\t\t\tif (!(a & 1))l = f(l, merge(a++));\n\t\t\tif (!(b & 1))r = f(merge(--b), r);\n\t\t}\n\t\treturn f(l, r);\n\t}\n\n\n\t////[start, end) について、[l, r) を調べながら k 番目が check を満たすか二分探索 最後が true なら left, false なら right fの逆演算\n\t//template<typename C>\n\t//int find(const int start, const int end, int l, int r, int k, const C check, T& checknum, const bool b, const function<T(T, T)> revf) {\n\t//\t//cerr << checknum << '\\n';\n\t//\t//範囲外またはそこがすでに満たさないとき\n\t//\t//cerr << k << ',' << checknum << '\\n';\n\t//\tif (start <= l && r <= end && !check(seg[k], checknum)) {\n\t//\t\tchecknum = revf(checknum, seg[k]);\n\t//\t\treturn -1;\n\t//\t}\n\t//\tif ((r <= start || l >= end)) {\n\t//\t\treturn -1;\n\t//\t}\n\t//\t//既に葉\n\t//\tif (k >= siz) {\n\t//\t\treturn k - siz;\n\t//\t}\n\t//\tint res;\n\t//\tif (b) {\n\t//\t\t//左側を調べる\n\t//\t\tres = find< C >(start, end, l, ((l + r) >> 1), (k << 1) + 1, check, checknum, b, revf);\n\t//\t\t//左側が適してたらそれが答え\n\t//\t\tif (res != -1)return (res);\n\t//\t\treturn find< C >(start, end, ((l + r) >> 1), r, (k << 1) + 2, check, checknum, b, revf);\n\t//\t}\n\t//\telse {\n\t//\t\t//右側を調べる\n\t//\t\tres = find< C >(start, end, ((l + r) >> 1), r, (k << 1) + 2, check, checknum, b, revf);\n\t//\t\t//右側が適してたらそれが答え\n\t//\t\tif (res != -1)return (res);\n\t//\t\treturn find< C >(start, end, l, ((l + r) >> 1), (k << 1) + 1, check, checknum, b, revf);\n\t//\t}\n\t//}\n\n\t//template<typename C>\n\t//int find_left(int start, int end, const C check, T checknum, function<T(T, T)> revf) {\n\t//\treturn find< C >(start, end, 0, siz + 1, 0, check, checknum, true, revf);\n\t//}\n\n\t//template<typename C>\n\t//int find_right(int start, int end, const C check, T checknum, function<T(T, T)> revf) {\n\t//\treturn find< C >(start, end, 0, siz + 1, 0, check, checknum, false, revf);\n\t//}\n\n};\n\nint main() {\n\n\tint n, q;\n\tscanf(\"%d%d\", &n, &q);\n\tauto f1 = [](ll a, ll b) {return b; };\n\tauto f2 = [](ll a, int w) {return a * (ll)w; };\n\n\tlazysegtree<ll, ll> seg(n, 0, plus<ll>(), 0, f1, f1, f2);\n\tseg.build();\n\n\tint query, s, t, x;\n\twhile (q--) {\n\t\tscanf(\"%d\", &query);\n\t\tif (query) {\n\t\t\tscanf(\"%d%d\", &s, &t);\n\t\t\tprintf(\"%lld\\n\", seg.query(s, t + 1));\n\t\t}\n\t\telse {\n\t\t\tscanf(\"%d%d%d\", &s, &t, &x);\n\t\t\tseg.update(s, t + 1, x);\n\t\t}\n\t}\n\n\tPlease AC;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <unordered_map> \n#include <unordered_set>\n#include <functional>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P2;\ntypedef tuple<int, int, int> T;\n\nlong long int INF = 1e18;\nlong long int MOD = 1e9 + 7;\n\nint const TREE_SIZE = (1 << 20);\n\nclass LazySegTreeUpdate{\n\tpublic:\n\t// コンストラクタ\n\tLazySegTreeUpdate(function<long long int(long long int, long long int)> monoidFunc_, \n\t\tfunction<long long int(long long int, long long int)> nodeUpdateFunc_, \n\t\tfunction<long long int(long long int, long long int, long long int)> resultFunc_, long long int invalidValue_){\n\t\tmonoidFunc = monoidFunc_;\n\t\tnodeUpdateFunc = nodeUpdateFunc_;\n\t\tresultFunc = resultFunc_;\n\t\tinvalidValue = invalidValue_;\n\t}\n\t// 値の初期化\n\tvoid init(long long int initValue){\n\t\tfor(int i = 0; i < TREE_SIZE; i++){\n\t\t\tsegTree[i] = initValue;\n\t\t\tisAssigned[i] = false;\n\t\t}\n\t}\n\t// 区間 [a, b] (0-indexed)を w に変更する O(log N)\n\tvoid update(int a, int b, long long int w){\n\t\tupdate_(a + 1, b + 2, 1, w, 0, TREE_SIZE / 2);\n\t}\n\t// 区間 [a, b] (0-indexed)の値を求める O(log N)\n\tlong long int query(int a, int b){\n\t\treturn query_(a + 1, b + 2, 1, 0, TREE_SIZE / 2);\n\t}\n\tprivate:\n\tfunction<long long int(long long int, long long int)> monoidFunc;\n\tfunction<long long int(long long int, long long int)> nodeUpdateFunc;\n\tfunction<long long int(long long int, long long int, long long int)> resultFunc;\n\tlong long int invalidValue;\n\tlong long int segTree[TREE_SIZE]; // 1-indexed\n\tbool isAssigned[TREE_SIZE]; // 値か代入されたかどうか、1-indexed\n\n\t// [a, b) を num に変更する\n\tlong long int update_(int a, int b, int index, long long int num, int l, int r){\n\t\tif(r <= a || b <= l){\n\t\t\treturn segTree[index];\n\t\t}\n\t\tif(a <= l && r <= b){\n\t\t\tsegTree[index] = nodeUpdateFunc(num, r - l);\n\t\t\tisAssigned[index] = true;\n\t\t\treturn segTree[index];\n\t\t}\n\t\tif(isAssigned[index]){\n\t\t\tisAssigned[index * 2] = isAssigned[index * 2 + 1] = true;\n\t\t\tsegTree[index * 2] = segTree[index * 2 + 1] = resultFunc(segTree[index], r - l, (r - l) / 2);\n\t\t\tisAssigned[index] = false;\n\t\t}\n\t\treturn segTree[index] = monoidFunc(\n\t\t\tupdate_(a, b, index * 2, num, l, (l + r) / 2),\n\t\t\tupdate_(a, b, index * 2 + 1, num, (l + r) / 2, r)\n\t\t);\n\t}\n\t// 区間 [a, b) の値を求める O(log N)\n\tlong long int query_(int a, int b, int index, int l, int r){\n\t\tif(r <= a || b <= l){\n\t\t\treturn invalidValue;\n\t\t}\n\t\tif(a <= l && r <= b){\n\t\t\treturn segTree[index];\n\t\t}\n\t\tif(isAssigned[index]){\n\t\t\treturn resultFunc(segTree[index], (r - l), min(r, b) - max(l, a));\n\t\t}\n\t\treturn monoidFunc(\n\t\t\tquery_(a, b, index * 2, l, (l + r) / 2), \n\t\t\tquery_(a, b, index * 2 + 1, (l + r) / 2, r)\n\t\t);\n\t}\n};\n\nlong long int monoidFunc(long long int a, long long int b){\n\treturn a + b;\n}\n// 各要素に代入された値が num、区間幅が len のときの、区間の値\nlong long int nodeUpdateFunc(long long int num, long long int len){\n\treturn num * len;\n}\n// 頂点の区間の値が num、頂点の区間幅が len であるとおく。\n// 頂点の区間に含まれる区間のうち、区間幅が len1 である区間の値\nlong long int resultFunc(long long int num, long long int len, long long int len1){\n\treturn num / len * len1;\n}\nLazySegTreeUpdate segTree(monoidFunc, nodeUpdateFunc, resultFunc, 0);\n\nint main(){\n\tsegTree.init(0);\n\tint n, q;\n\tcin >> n >> q;\n\tfor(int i = 0; i < q; i++){\n\t\tlong long int tp, a, b;\n\t\tcin >> tp >> a >> b;\n\t\tif(tp == 0){\n\t\t\tlong long int x;\n\t\t\tcin >> x;\n\t\t\tsegTree.update(a, b, x);\n\t\t}else{\n\t\t\tcout << segTree.query(a, b) << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a) {\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n    out<<'[';\n    for(const T &i: a) out<<i<<',';\n    out<<']';\n    return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out, const set<T>& a) {\n    out<<'{';\n    for(const T &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\ntemplate<class T, class S>\nostream &operator <<(ostream& out, const map<T,S>& a) {\n    out<<'{';\n    for(auto &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\ntemplate <typename Monoid>\nstruct lazysegtree {\n    using T = typename Monoid::T;\n    using E = typename Monoid::E;\n    int n, height;\n    vector<T> dat;\n    vector<E> lazy;\n\n    lazysegtree() {}\n    lazysegtree(int n_) {\n        n = 1, height = 0;\n        while(n < n_) { n *= 2; height++; }\n        dat.assign(n*2, Monoid::dt());\n        lazy.assign(n*2, Monoid::de());\n    }\n    void build(vector<T> v) {\n        REP(i, v.size()) dat[i+n] = v[i];\n        for(int i=n-1; i>0; --i) dat[i] = Monoid::f(dat[i*2], dat[i*2+1]);\n    }\n\n    inline T reflect(int k) { return lazy[k]==Monoid::de()?dat[k]:Monoid::g(dat[k], lazy[k]); }\n    inline void eval(int k) {\n        if(lazy[k] == Monoid::de()) return;\n        lazy[2*k]   = Monoid::h(lazy[k*2],   lazy[k]);\n        lazy[2*k+1] = Monoid::h(lazy[k*2+1], lazy[k]);\n        dat[k] = reflect(k);\n        lazy[k] = Monoid::de();\n    }\n    inline void thrust(int k) { for(int i=height;i;--i) eval(k>>i); }\n    inline void recalc(int k) { while(k>>=1) dat[k] = Monoid::f(reflect(k*2), reflect(k*2+1)); }\n\n    void update(int a, int b, E x) {\n        thrust(a+=n);\n        thrust(b+=n-1);\n        for(int l=a, r=b+1; l<r; l>>=1,r>>=1) {\n            if(l&1) lazy[l] = Monoid::h(lazy[l], x), ++l;\n            if(r&1) --r, lazy[r] = Monoid::h(lazy[r], x);\n        }\n        recalc(a);\n        recalc(b);\n    }\n    T query(int a, int b) {\n        thrust(a+=n);\n        thrust(b+=n-1);\n        T vl=Monoid::dt(), vr=Monoid::dt();\n        for(int l=a, r=b+1; l<r; l>>=1,r>>=1) {\n            if(l&1) vl=Monoid::f(vl, reflect(l++));\n            if(r&1) vr=Monoid::f(reflect(--r), vr);\n        }\n        return Monoid::f(vl, vr);\n    }\n\n    friend ostream &operator <<(ostream& out,const lazysegtree<Monoid>& seg) {\n        out << \"---------------------\" << endl;\n        int cnt = 1;\n        for(int i=1; i<=seg.n; i*=2) {\n            REP(j, i) {\n                out << \"(\" << seg.dat[cnt] << \",\" << seg.lazy[cnt] << \") \";\n                cnt++;\n            }\n            out << endl;\n        }\n        out << \"---------------------\" << endl;\n        return out;\n    }\n};\n\nstruct update_min {\n    using T = ll;\n    using E = ll;\n    static constexpr T dt() { return INT_MAX; }\n    static constexpr E de() { return INT_MAX; }\n    static T f(const T &a, const T &b) { return min(a, b); }\n    static T g(const T &a, const E &b) { return b; }\n    static E h(const E &a, const E &b) { return b; }\n};\nstruct add_sum {\n    using T = PII;  // (頂点の値, 頂点の区間長)\n    using E = ll;\n    static constexpr T dt() { return PII(0,0); }\n    static constexpr E de() { return 0; }\n    static T f(const T &a, const T &b) { return PII(a.first+b.first, a.second+b.second); }\n    static T g(const T &a, const E &b) { return PII(a.first+b*a.second, a.second); }\n    static E h(const E &a, const E &b) { return a+b; }\n};\nstruct update_sum {\n    using T = ll;\n    using E = ll;\n    static constexpr T dt() { return 0; }\n    static constexpr E de() { return 0; }\n    static T f(const T &a, const T &b) { return a+b; }\n    static T g(const T &a, const E &b) { return b; }\n    static E h(const E &a, const E &b) { return b; }\n};\nstruct add_min {\n    using T = PII;  // (頂点の値, 頂点の区間長)\n    using E = ll;\n    static constexpr T dt() { return PII(LLINF,0); }\n    static constexpr E de() { return 0; }\n    static T f(const T &a, const T &b) { return min(a, b); }\n    static T g(const T &a, const E &b) { return PII(a.first+b*a.second, a.second); }\n    static E h(const E &a, const E &b) { return a+b; }\n};\nstruct xor_sum {\n    using T = PII;  // (頂点の値, 頂点の区間長)\n    using E = ll;\n    static constexpr T dt() { return PII(0,0); }\n    static constexpr E de() { return 0; }\n    static T f(const T &a, const T &b) { return PII(a.first+b.first, a.second+b.second); }\n    static T g(const T &a, const E &b) { return PII((b>=1?b-a.first:a.first)*a.second, a.second); }\n    static E h(const E &a, const E &b) { return a^b; }\n};\n\n// 点更新区間最小\nnamespace DSL2A {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        lazysegtree<update_min> seg(n);\n        while(q--) {\n            int c, x, y;\n            cin >> c >> x >> y;\n            if(c == 0) {\n                seg.update(x, x+1, y);\n            } else {\n                cout << seg.query(x, y+1) << endl;\n            }\n        }\n    }\n}\n\n// 点加算区間和\nnamespace DSL2B {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        lazysegtree<add_sum> seg(n);\n        seg.build(vector<PII>(n, PII(0,1)));\n        while(q--) {\n            int c, x, y;\n            cin >> c >> x >> y;\n            if(c == 0) {\n                x--;\n                seg.update(x, x+1, y);\n            } else {\n                x--, y--;\n                cout << seg.query(x, y+1).first << endl;\n            }\n        }\n    }\n}\n\n// 区間更新区間最小\nnamespace DSL2F {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        lazysegtree<update_min> seg(n);\n        while(q--) {\n            int c, s, t;\n            cin >> c >> s >> t;\n            if(c == 0) {\n                int x;\n                cin >> x;\n                seg.update(s, t + 1, x);\n            } else {\n                cout << seg.query(s, t + 1) << endl;\n            }\n        }\n    }\n}\n\n// 区間加算区間和\nnamespace DSL2G {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        lazysegtree<add_sum> seg(n);\n        seg.build(vector<PII>(n, PII(0,1)));\n        while(q--) {\n            int c, s, t;\n            cin >> c >> s >> t;\n            s--, t--;\n            if(c == 0) {\n                int x;\n                cin >> x;\n                seg.update(s, t + 1, x);\n            } else {\n                cout << seg.query(s, t + 1).first << endl;\n            }\n        }\n    }\n}\n\n// 区間加算区間最小\nnamespace DSL2H {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        lazysegtree<add_min> seg(n);\n        seg.build(vector<PII>(n, PII(0,1)));\n        while(q--) {\n            int c, s, t;\n            cin >> c >> s >> t;\n            if(c == 0) {\n                int x;\n                cin >> x;\n                seg.update(s, t+1, x);\n            } else {\n                cout << seg.query(s, t+1).first << endl;\n            }\n        }\n    }\n}\n\n// 区間更新区間和\nnamespace DSL2I {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        lazysegtree<update_sum> seg(n);\n        while(q--) {\n            int c, s, t;\n            cin >> c >> s >> t;\n            if(c == 0) {\n                int x;\n                cin >> x;\n                seg.update(s, t+1, x);\n            } else {\n                cout << seg.query(s, t+1) << endl;\n            }\n        }\n    }\n}\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    // DSL2A::solve();\n    // DSL2B::solve();\n    // DSL2F::solve();\n    // DSL2G::solve();\n    // DSL2H::solve();\n    DSL2I::solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define rep(i, a, b) for (auto (i) = (a); (i) < (b); (i)++)\n#define rrep(i, a, b) for (auto (i) = (a); (i) > (b); (i)--)\n#define UNIQUE(v) (v).erase(unique((v).begin(), (v).end()), (v).end());\n\n#ifdef LOCAL_DEFINE\nstruct InitInput{\n  InitInput() {\n    FILE *stream1;\n    stream1=freopen(\"/Users/aim_cpo/CLionProjects/competitive/in.txt\",\"r\",stdin);\n    assert(stream1 != nullptr);\n    cerr << \"This problem is not interactive\" << endl;\n  }\n}LOCAL_INPUT;\nstruct LOCAL_OUTPUT{\n  LOCAL_OUTPUT() {\n    FILE *stream2;\n    const char *outputfile = \"out.txt\";\n    stream2 = freopen(outputfile, \"w\", stdout);\n    assert(stream2 != nullptr);\n    cerr << \"output [ \" << outputfile << \" ]\" << endl;\n  }\n}/*LOCAL_OUTPUT*/;\n#define show(x) cerr << #x << \" = \" << (x) << \" (line \" << __LINE__ << \")\" << endl\n#define showV(v, n) do{\\\nfor(int _i_t_e_=0; _i_t_e_<(n);_i_t_e_++)\\\ncerr<<\"(\"<<_i_t_e_<<\" = \"<<(v)[_i_t_e_]<<\") \";\\\ncerr<<endl;}while(0)\n#define showA(a, n) do{\\\nfor(int _i_t_e_=0;_i_t_e_<(n);_i_t_e_++)\\\ncerr<<\"(\"<<_i_t_e_<<\" = \"<<(a)[_i_t_e_]<<\") \";\\\ncerr<<endl;}while(0)\n#define showA2(a, n, m) do{\\\nfor(int _i_t_e_=0;_i_t_e_<(n);_i_t_e_++){\\\nfor(int _i_t_e_2=0;_i_t_e_2<(m);_i_t_e_2++){\\\ncerr<<\"(\"<<_i_t_e_<<\", \"<<_i_t_e_2<<\" = \"<<(a)[_i_t_e_][_i_t_e_2]<<\") \";\\\n}cerr<<endl;}cerr<<endl;}while(0)\n#else\n#define show(x)\n#define showV(v, n)\n#define showA(a, n)\n#define showA2(a, n, m)\n#endif\n\nstruct InitAim{\n  InitAim() {\n    ios::sync_with_stdio(false);cin.tie(nullptr);\n    cout.precision(12);cout<<fixed;\n#ifdef LOCAL_DEFINE\n    cerr << \"This problem is not interactive\" << endl;\n#endif\n  }\n}aim_cpo;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nconstexpr const int INT_INF=0x3f3f3f3f; //1061109567\nconstexpr const ll LL_INF=0x3f3f3f3f3f3f3f3f; //4557430888798830399\n\ntemplate <typename T> bool chmin(T &a, T b){return a>b?(a=b,true):false;}\ntemplate <typename T> bool chmax(T &a, T b){return a<b?(a=b,true):false;}\ntemplate <typename T> void ln(T i, T n){cout<<(i==n-1?\"\\n\":\" \");}\ntemplate<typename T, typename S>\nostream &operator<<(ostream &out, const pair<T, S> &pair1) {\n  out << '(' << pair1.fi << \", \" << pair1.se << ')';\n  return out;\n}\ntemplate<typename T>\nostream &operator<<(ostream &out, const vector<T> &vector1) {\n  out << '[';\n  for (unsigned int i = 0; i < vector1.size(); i++) {\n    out << vector1[i];\n    if (i == vector1.size() - 1)out << \"]\"; else out << \", \";\n  }\n  return out;\n}\n\n// INT\n#define GCD(a, b) __gcd(a, b)\ntemplate <typename T> T LCM(T a, T b) {return a / GCD(a, b) * b;}\ntemplate <typename T> T EXTGCD(T a, T b, T& x, T& y) {\n  T d = a;\n  if (b != 0) {d=EXTGCD(b,a%b,y,x);y-=(a/b)*x;}\n  else x=1,y=0;\n  return d;\n}\ntemplate <typename T> bool is_prime(T a) {\n  for(int i=2;i*i<=a;i++)if(a%i==0)return true;\n  return false;\n}\ntemplate <typename T, typename S> T Pow(T a, S b) {\n  T res = 1, now = a;\n  while(b){if(b&1)res*=now;b>>=1;now*=now;}return res;\n}\n\n// MOD\nll MOD = 1000000000L + 7L;\n#define add(a, b) ((a % MOD) + (b % MOD)) % MOD\n#define mul(a, b) ((a % MOD) * (b % MOD)) % MOD\n#define sub(a, b) ((a % MOD) + MOD - (b % MOD)) % MOD\ntemplate <typename T, typename S> T ModPow(T a, S b) {\n  T res = 1, now = a;\n  while(b){if(b&1)res=mul(res,now);b>>=1;now=mul(now,now);}return res;\n}\ntemplate <typename T> T mod_inverse(T a, T mod, bool prime){ // if mod is prime, \"prime\" is true.\n  if(prime)return ModPow(a, mod - 2);\n  else{T x,y;EXTGCD(a,mod,x,y);return (mod+x%mod)%mod;}\n}\n#define divide(a, b) ((a % MOD) * (mod_inverse(b, MOD, true))) % MOD\n\n//LLの数値をつかう時は最後にLLをつける癖をつけよう\n///////////////////////////////////////////////////////////////////////////////////\n// VARIABLE\n///////////////////////////////////////////////////////////////////////////////////\n\nint n, q;\n\n///////////////////////////////////////////////////////////////////////////////////\n// TEMPLATE(data structure)\n///////////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename T, typename S = T>\nclass LazyIntervalTree {\n    using F = function<T(T, T)>;\n    using G = function<T(T, S, int)>;\n    using H = function<S(S, S)>;\npublic:\n    LazyIntervalTree(int n, const F f, const G g, const H h, const T &init, const S OM)\n    : f(f), g(g), h(h), init(init), OM(OM) {\n      size = 1;\n      while (size < n) size <<= 1;\n      data.assign(2 * size, init);\n      lazy.assign(2 * size, OM);\n    }\n    void set(int k, const T &x) {\n      data[k + size] = x;\n    }\n    void build() {\n      for (int i = size - 1; i > 0; i--) {\n        data[i] = f(data[2 * i], data[2 * i + 1]);\n      }\n    }\n    void propagate(int k, int len) {\n      if (lazy[k] != OM) {\n        if (k < size) {\n          lazy[2 * k] = h(lazy[2 * k], lazy[k]);\n          lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n        }\n        data[k] = g(data[k], lazy[k], len);\n        lazy[k] = OM;\n      }\n    }\n    T update(int a, int b, const S &x, int k, int l, int r) {\n      propagate(k, r - l);\n      if (r <= a || b <= l) {\n        return data[k];\n      } else if (a <= l && r <= b) {\n        lazy[k] = h(lazy[k], x);\n        propagate(k, r - l);\n        return data[k];\n      } else {\n        return data[k] = f(update(a, b, x, 2 * k, l, (l + r) >> 1),\n          update(a, b, x, 2 * k + 1, (l + r) >> 1, r));\n      }\n    }\n    T update(int a, int b, const S &x) {\n      return update(a, b, x, 1, 0, size);\n    }\n    T query(int a, int b, int k, int l, int r) {\n      propagate(k, r - l);\n      if (r <= a || b <= l) {\n        return init;\n      } else if (a <= l && r <= b) {\n        return data[k];\n      } else {\n        return f(query(a, b, 2 * k, l, (l + r) >> 1),\n          query(a, b, 2 * k + 1, (l + r) >> 1, r));\n      }\n    }\n    T query(int a, int b) {\n      return query(a, b, 1, 0, size);\n    }\n    T operator[](const int &k) {\n      return query(k, k + 1);\n    }\n    void showLazy() {\n      for (int i = 0; i < n; i++) {\n        cerr << lazy[i + size] << \" \";\n      }\n      cerr << endl;\n    }\nprivate:\n    int size;\n    vector <T> data;\n    vector <S> lazy;\n    const F f;\n    const G g;\n    const H h;\n    const T init;\n    const S OM;\n};\n\n///////////////////////////////////////////////////////////////////////////////////\n// MAIN\n///////////////////////////////////////////////////////////////////////////////////\n\nint main() {\n  cin >> n >> q;\n  LazyIntervalTree<ll, ll> seg(n, [](ll a, ll b){return a + b;},\n    [](ll a, ll b, int c){return (b == LL_INF ? a : b * c);},\n    [](ll a, ll b){return (b == LL_INF ? a : b);},\n    0, LL_INF);\n  rep(i, 0, n) seg.set(i, 0);\n  seg.build();\n  rep(i, 0, q) {\n    int a; cin >> a;\n    if (a) {\n      int l, r; cin >> l >> r;\n      cout << seg.query(l, r + 1) << endl;\n    } else {\n      int l, r; ll x; cin >> l >> r >> x;\n      seg.update(l, r + 1, x);\n    }\n  }\n#ifdef LOCAL_DEFINE\n  cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \"s.\" << endl;\n  show(MOD);\n#endif\n  return 0;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// NOTE\n///////////////////////////////////////////////////////////////////////////////////\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n\n#define MAX 500005\n\ntemplate<typename T>\nstruct SegTree {\n  const T INF = numeric_limits<T>::max();\n  int n;\n  vector<T> dat, lazy;\n  SegTree(int _n) : n(), dat(_n*4,0), lazy(_n*4,INF) {\n    int x = 1;\n    while (x < _n) x <<= 1;\n    n = x;\n  }\n  void set(int i, int x) { dat[i+n-1] = x; }\n  void build() { for (int k = n-2; k >= 0; k--) dat[k] = dat[k*2+1] + dat[k*2+2]; }\n\n  void eval(int k, int p) {\n    if (lazy[k] == INF) return;\n    if (k < n-1) {\n      lazy[k*2+1] = lazy[k];\n      lazy[k*2+2] = lazy[k];\n    }\n    dat[k] = lazy[k] * p;\n    lazy[k] = INF;\n  }\n  void update(int a, int b, int x, int k, int l, int r) {\n    eval(k, r-l);\n    if (r <= a || b <= l) return;\n    if (a <= l && r <= b) {\n      lazy[k] = x;\n      eval(k, r-l);\n    } else {\n      int mid = (l+r)>>1;\n      update(a,b,x,k*2+1,l,mid);\n      update(a,b,x,k*2+2,mid,r);\n      dat[k] = dat[k*2+1] + dat[k*2+2];\n    }\n  }\n  void update(int a, int b, int x) { update(a,b,x,0,0,n); }\n\n  T query(int a, int b, int k, int l, int r) {\n    eval(k, r-l);\n    if (r <= a || b <= l) return 0;\n    if (a <= l && r <= b) return dat[k];\n    int mid = (l+r)>>1;\n    T vl = query(a,b,k*2+1,l,mid);\n    T vr = query(a,b,k*2+2,mid,r);\n    return vl + vr;\n  }\n  T query(int a, int b) { return query(a,b,0,0,n); }\n  inline T operator[](int a) { return query(a,a+1); }\n};\n\nint main(int, char**)\n{\n  int n, q;\n  cin >> n >> q;\n\n  SegTree<ll> seg(n);\n\n  vector<ll> ans;\n  rep(i,q) {\n    int command; cin >> command;\n    if (command == 0) {\n      int s, t, x;\n      cin >> s >> t >> x;\n      seg.update(s,t+1,x);\n    } else if (command == 1) {\n      int s, t; cin >> s >> t;\n      ans.push_back(seg.query(s,t+1));\n    }\n  }\n  for (auto a : ans) cout << a << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define mod 1000000007\n#define dom 998244353\n#define all(c) begin(c),end(c)\n#define rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\ntemplate <typename T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate <typename T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n#define long long long\n#define List vector\n#define var auto\n#define Count size()\n#define Length size()\nint dd[] = { 0, 1, 0, -1, 0 }; //→↓←↑\n\ntemplate <typename T, typename U>\nstruct LazySegTree {\n\tint n;\n\tfunction<T(T, T)> calc;\n\tfunction<T(T, U, int)> apply;\n\tfunction<U(U, U)> merge;\n\tT ex;\n\tvector<T> data;\n\tvector<U> lazy;\n\tvector<bool> is_lazy;\n\tLazySegTree(int n_, function<T(T, T)> calc,\n\t\tfunction<T(T, U, int)> apply,\n\t\tfunction<U(U, U)> merge,\n\t\tT ex){\n\t\tthis->calc = calc;\n\t\tthis->apply = apply;\n\t\tthis->merge = merge;\n\t\tthis->ex = ex;\t\n\t\tinit(n_);\n\t}\n\tvoid init(int n_) {\n\t\tn = 1;\n\t\twhile (n < n_) n *= 2;\n\t\tdata.clear();\n\t\tdata.resize(2 * n - 1, ex);\n\t\tlazy.clear();\n\t\tlazy.resize(2 * n - 1, U());\n\t\tis_lazy.clear();\n\t\tis_lazy.resize(2 * n - 1, false);\n\t}\n\tvoid assign_lazy(int k, U x)\n\t{\n\t\tif (k >= (int)lazy.size()) return;\n\t\tif (is_lazy[k]) lazy[k] = merge(lazy[k], x);\n\t\telse\n\t\t{\n\t\t\tis_lazy[k] = true;\n\t\t\tlazy[k] = x;\n\t\t}\n\t}\n\tvoid eval(int len, int k) {\n\t\tif (!is_lazy[k]) return;\n\t\tassign_lazy(k * 2 + 1, lazy[k]);\n\t\tassign_lazy(k * 2 + 2, lazy[k]);\n\t\tdata[k] = apply(data[k], lazy[k], len);\n\t\tis_lazy[k] = false;\n\t}\n\tT update(int a, int b, U x, int k, int l, int r) {\n\t\teval(r - l, k);\n\t\tif (r <= a || b <= l) return data[k];\n\t\tif (a <= l && r <= b) {\n\t\t\tassign_lazy(k, x);\n\t\t\treturn apply(data[k], lazy[k], r - l);\n\t\t}\n\t\treturn data[k] = calc(update(a, b, x, k * 2 + 1, l, (l + r) / 2),\n\t\t\tupdate(a, b, x, k * 2 + 2, (l + r) / 2, r));\n\t}\n\t// [a, b]に対する閉区間更新 0-indexed\n\tT update(int a, int b, U x) {\n\t\tb++;\n\t\treturn update(a, b, x, 0, 0, n);\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\teval(r - l, k);\n\t\tif (r <= a || b <= l) return ex;\n\t\tif (a <= l && r <= b) return data[k];\n\t\tT vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tT vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn calc(vl, vr);\n\t}\n\t// return node [a,b] 閉区間クエリ 0-indexed\n\tT query(int a, int b) {\n\t\tb++;\n\t\treturn query(a, b, 0, 0, n);\n\t}\n\n\t//デバッグ用\n\tvector<T> items()\n\t{\n\t\tvector<T> ret(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tret[i] = query(i, i);\n\t\t}\n\t\treturn ret;\n\t}\n};\n//呼び出し方\n//区間Add区間Sum\n//LazySegTree<long, long> raq_rsq(N,\n//\t[](long a, long b) { return a + b; },\n//\t[](long a, long b, int len) { return a + b * len; },\n//\t[](long a, long b) { return a + b; },\n//\t0);\n\n//区間Add区間Min\n// 要素は一点の値だからlenを掛けない 最小値だからexはINF\n//LazySegTree<long, long> raq_rmq(N,\n//\t[](long a, long b) { return min(a, b); },\n//\t[](long a, long b, int len) { return a + b; },\n//\t[](long a, long b) { return a + b; },\n//\tINT_MAX);\n// 0に初期化する場合\n//raq_rmq.update(0, N - 1, -INT_MAX);\n\n//区間変更区間Min\n//LazySegTree<int, int> ruq_rmq(N,\n//\t[](int a, int b) { return min(a, b); },\n//\t[](int a, int b, int len) {return b; },\n//\t[](int a, int b) {return b; },\n//\tINT_MAX);\n\n//区間変更区間Sum\n\nvoid solve()\n{\n\tint N, Q;\n\tcin >> N >> Q;\n\n\tLazySegTree<long, long> ruq_rsq(N,\n\t[](long a, long b) { return a + b; },\n\t[](long a, long b, int len) { return b * len; },\n\t[](long a, long b) { return b; },\n\t0);\n\n\trep(i, Q)\n\t{\n\t\tint com;\n\t\tcin >> com;\n\t\tif (com == 0)\n\t\t{\n\t\t\tint s, t, x;\n\t\t\tcin >> s >> t >> x;\n\t\t\truq_rsq.update(s, t, x);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint s, t;\n\t\t\tcin >> s >> t;\n\t\t\tcout << ruq_rsq.query(s, t) << endl;\n\t\t}\n\t}\n\t//auto p = ruq_rsq.items();\n\t//rep(i, p.size())\n\t//{\n\t//\tcout << p[i] << \" \";\n\t//}\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma warning(disable : 4267) // \"int n = (unsigned)size\"\n\nusing vi = vector<int>; using vvi = vector<vi>; using vvvi = vector<vvi>;\nusing ll = long long int;\nusing vll = vector<ll>; using vvll = vector<vll>; using vvvll = vector<vvll>;\nusing vd = vector<double>; using vvd = vector<vd>; using vvvd = vector<vvd>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing cdouble = complex<double>;\n\nconst double eps = 1e-7;\nconst double INFD = numeric_limits<double>::infinity();\n#define Loop(i, n) for(int i = 0; i < int(n); i++)\n#define Loopll(i, n) for(ll i = 0; i < ll(n); i++)\n#define Loop1(i, n) for(int i = 1; i <= int(n); i++)\n#define Loopll1(i, n) for(ll i = 1; i <= ll(n); i++)\n#define Loopr(i, n) for(int i = int(n) - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = ll(n) - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = int(n); i >= 1; i--)\n#define Looprll1(i, n) for(ll i = ll(n); i >= 1; i--)\n#define Foreach(buf, container) for(auto buf : container)\n#define Loopdiag(i, j, h, w, sum) for(int i = ((sum) >= (h) ? (h) - 1 : (sum)), j = (sum) - i; i >= 0 && j < (w); i--, j++)\n#define Loopdiagr(i, j, h, w, sum) for(int j = ((sum) >= (w) ? (w) - 1 : (sum)), i = (sum) - j; j >= 0 && i < (h); j--, i++)\n#define Loopdiagsym(i, j, h, w, gap) for (int i = ((gap) >= 0 ? (gap) : 0), j = i - (gap); i < (h) && j < (w); i++, j++)\n#define Loopdiagsymr(i, j, h, w, gap) for (int i = ((gap) > (h) - (w) - 1 ? (h) - 1 : (w) - 1 + (gap)), j = i - (gap); i >= 0 && j >= 0; i--, j--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(ex_i, vector.size()) { cout << vector[ex_i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(ex_i, matrix.size()) { Loop(ex_j, matrix[ex_i].size()) { cout << matrix[ex_i][ex_j] << \" \"; } cout << endl; }\n#define quickio() ios::sync_with_stdio(false); cin.tie(0);\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\n#define Comp(type_t) bool operator<(const type_t &another) const\n#define fst first\n#define snd second\nbool nearlyeq(double x, double y) { return abs(x - y) < eps; }\nbool inrange(ll x, ll t) { return x >= 0 && x < t; }\nbool inrange(vll xs, ll t) { Foreach(x, xs) if (!(x >= 0 && x < t)) return false; return true; }\nint ceillog2(ll x) { int ret = 0;\tx--; while (x > 0) { ret++; x >>= 1; } return ret; }\nll rndf(double x) { return (ll)(x + (x >= 0 ? 0.5 : -0.5)); }\nll floorsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (m * m <= x ? 0 : -1); }\nll ceilsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (x <= m * m ? 0 : 1); }\nll rnddiv(ll a, ll b) { return (a / b + (a % b * 2 >= b ? 1 : 0)); }\nll ceildiv(ll a, ll b) { return (a / b + (a % b == 0 ? 0 : 1)); }\nll gcd(ll m, ll n) { if (n == 0) return m; else return gcd(n, m % n); }\nll lcm(ll m, ll n) { return m * n / gcd(m, n); }\n\n/*******************************************************/\n\ntemplate<class T>\nclass SegTree {\nprotected:\n\tint n, N; // n is the original size, while N is the extended size\n\tint base;\n\tvector<T> nodes;\n\tint left_of(int id) {\n\t\tif (id >= base) return -1;\n\t\telse return id * 2 + 1;\n\t}\n\tint right_of(int id) {\n\t\tif (id >= base) return -1;\n\t\telse return id * 2 + 2;\n\t}\n\tint parent_of(int id) {\n\t\tif (id == 0) return -1;\n\t\telse return (id - 1) >> 1;\n\t}\n\t// initially, (s, t, 0, N, 0, x, EXCEPTION);\n\tvoid update_rec(int s, int t, int l, int r, int id, ll x, ll v) {\n\t\tif (v == LLONG_MIN) {\n\t\t\tv = nodes[id].val;\n\t\t}\n\t\tif (s == l && t == r) {\n\t\t\tif (x != LLONG_MIN) {\n\t\t\t\tnodes[id].val = x;\n\t\t\t\tnodes[id].sum = x * cover_size(id);\n\t\t\t}\n\t\t\telse if (v != LLONG_MIN) {\n\t\t\t\tnodes[id].val = v;\n\t\t\t\tnodes[id].sum = v * cover_size(id);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint m = (l + r) / 2;\n\t\t\tint id_l = left_of(id);\n\t\t\tint id_r = right_of(id);\n\t\t\tif (s < m && m < t) {\n\t\t\t\tupdate_rec(s, m, l, m, id_l, x, v);\n\t\t\t\tupdate_rec(m, t, m, r, id_r, x, v);\n\t\t\t}\n\t\t\telse if (s < m) {\n\t\t\t\tupdate_rec(s, t, l, m, id_l, x, v);\n\t\t\t\tif (v != LLONG_MIN) {\n\t\t\t\t\tnodes[id_r].val = v;\n\t\t\t\t\tnodes[id_r].sum = v * cover_size(id_r);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (m < t) {\n\t\t\t\tif (v != LLONG_MIN) {\n\t\t\t\t\tnodes[id_l].val = v;\n\t\t\t\t\tnodes[id_l].sum = v * cover_size(id_l);\n\t\t\t\t}\n\t\t\t\tupdate_rec(s, t, m, r, id_r, x, v);\n\t\t\t}\n\t\t\tnodes[id].val = LLONG_MIN;\n\t\t\tnodes[id].sum = nodes[id_l].sum + nodes[id_r].sum;\n\t\t}\n\t}\n\t// initially, (s, t, 0, N, 0, x, EXCEPTION);\n\tll solve_rec(int s, int t, int l, int r, int id, ll x, ll v) {\n\t\tif (s == l && t == r) {\n\t\t\treturn nodes[id].sum;\n\t\t}\n\t\telse {\n\t\t\tint m = (l + r) / 2;\n\t\t\tint id_l = left_of(id);\n\t\t\tint id_r = right_of(id);\n\t\t\tll v0 = 0, v1 = 0;\n\t\t\tif (s < m && m < t) {\n\t\t\t\tv0 = solve_rec(s, m, l, m, id_l, x, v);\n\t\t\t\tv1 = solve_rec(m, t, m, r, id_r, x, v);\n\t\t\t}\n\t\t\telse if (s < m) {\n\t\t\t\tv0 = solve_rec(s, t, l, m, id_l, x, v);\n\t\t\t}\n\t\t\telse if (m < t) {\n\t\t\t\tv1 = solve_rec(s, t, m, r, id_r, x, v);\n\t\t\t}\n\t\t\treturn v0 + v1;\n\t\t}\n\t}\npublic:\n\tSegTree(int n, T init) {\n\t\tSegTree::n = n;\n\t\tN = (int)pow(2, ceil(log2(n)));\n\t\tbase = N - 1;\n\t\tnodes = vector<T>(base + N, init);\n\t}\n\tint cover_size(int id) {\n\t\tint cnt = 1;\n\t\twhile (left_of(id) != -1) {\n\t\t\tid = left_of(id);\n\t\t\tcnt *= 2;\n\t\t}\n\t\tint l = id - base;\n\t\tint r = min(l + cnt, n);\n\t\treturn max(0, r - l);\n\t}\n\tvoid update(int s, int t, ll x) {\n\t\tupdate_rec(s, t, 0, N, 0, x, LLONG_MIN);\n\t}\n\tll solve(int s, int t) {\n\t\tupdate_rec(s, t, 0, N, 0, LLONG_MIN, LLONG_MIN);\n\t\treturn solve_rec(s, t, 0, N, 0, LLONG_MIN, LLONG_MIN);\n\t}\n};\n\nstruct val_t {\n\tll val;\n\tll sum;\n};\n\nint main() {\n\tquickio();\n\tint n; cin >> n;\n\tint q; cin >> q;\n\tSegTree<val_t> st(n, { 0, 0 });\n\tLoop(unused, q) {\n\t\tint op; cin >> op;\n\t\tint s, t; cin >> s >> t; t++;\n\t\tif (op == 0) {\n\t\t\tll x; cin >> x;\n\t\t\tst.update(s, t, x);\n\t\t}\n\t\telse {\n\t\t\tcout << st.solve(s, t) << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntemplate<typename T>\nclass LazySegTree {\npublic:\n    explicit LazySegTree(int n, T init, T def) : N(calcN_(n)), def(def) {\n        mVal.assign(2*N+1, init);\n        mLazy.assign(2*N+1, 0);\n        mDirty.assign(2*N+1, 0);\n    }\n    void update(int l, int r, T value){\n        updateImpl_(l, r, value, 0, 0, N);\n    }\n    T get(int l, int r){\n        return getImpl_(l, r, 0, 0, N);\n    }\nprivate:\n    int calcN_(int n){\n        int res = 1;\n        while(res < n) res *= 2;\n        return res;\n    }\n    void updateImpl_(int l, int r, T value, int idx, int rangeL, int rangeR){\n        eval_(idx, rangeL, rangeR);\n        if(r <= rangeL || rangeR <= l) return;\n        if(l <= rangeL && rangeR <= r){\n            setLazy_(idx, value);\n            eval_(idx, rangeL, rangeR);\n        } else {\n            int rangeM = (rangeL+rangeR)/2;\n            updateImpl_(l, r, value, 2*idx+1, rangeL, rangeM);\n            updateImpl_(l, r, value, 2*idx+2, rangeM, rangeR);\n            mVal[idx] = operate_(mVal[2*idx+1], mVal[2*idx+2]);\n        }\n    }\n    void setLazy_(int idx, T value){\n        mLazy[idx] = value;\n        mDirty[idx] = 1;\n    }\n    T getImpl_(int l, int r, int idx, int rangeL, int rangeR){\n        if(r <= rangeL || rangeR <= l) return def;\n        eval_(idx, rangeL, rangeR);\n        if(l <= rangeL && rangeR <= r) return mVal[idx];\n        int rangeM = (rangeL+rangeR)/2;\n        T a = getImpl_(l, r, 2*idx+1, rangeL, rangeM);\n        T b = getImpl_(l, r, 2*idx+2, rangeM, rangeR);\n        return operate_(a, b);\n    }\n    void eval_(int idx, int rangeL, int rangeR){\n        if(!mDirty[idx]) return;\n        mVal[idx] = (rangeR - rangeL) * mLazy[idx];\n        if(idx < N-1){\n            setLazy_(2*idx+1, mLazy[idx]);\n            setLazy_(2*idx+2, mLazy[idx]);\n        }\n        mLazy[idx] = 0;\n        mDirty[idx] = 0;\n    }\n    T operate_(T a, T b) const { return a + b; }\n    const int N;\n    const T def;\n    vector<T> mVal; \n    vector<T> mLazy;\n    vector<int> mDirty;\n};\n\nint main(){\n    int n, q;\n    while(cin >> n >> q){\n        LazySegTree<int> seg(n, 0, 0);\n        for(int i=0;i<q;i++){\n            int c; cin >> c;\n            if(c == 0){\n                int s, t, x; cin >> s >> t >> x;\n                seg.update(s, t+1, x);\n            } else {\n                int s, t; cin >> s >> t;\n                cout << seg.get(s, t+1) << endl;\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF=INT_MAX;\n#define int long long\n\ntemplate <typename T,typename E>\nstruct SegmentTree{\n  using F = function<T(T,T)>;\n  using G = function<T(T,E)>;\n  using H = function<E(E,E)>;\n  //この辺はとりあえずbeetのブログ読むのが良さそう？\n  //最初の具体例で言うとTとEが0以上の整数で、F(a,b):max(a,b) G(a,α):if(α)a=α H(α,β):if(β)α=β のはず\n  int n,height;\n  F f;\n  G g;\n  H h;\n  T ti;\n  E ei;\n  vector<T> dat;\n  vector<E> laz;\n  vector<int> leng;\n  SegmentTree(F f,G g,H h,T ti,E ei):\n    f(f),g(g),h(h),ti(ti),ei(ei){}\n\n\n  /*\n  イメージ的には\n  initとbuildは初期化　buildだとvectorで初期化出来る\n  reflectは作用済のdatを返すので適切なdatとlazが入っていればいい\n  propagateはkの作用をeiにリセットする役割で、作用を全部済ませる（datの更新と子のlazへの渡し）\n  thrustは（vectorでの）kを渡すとkの列を上から順にpropagateすることで上のlazを空にする\n  recalcは（vectorでの）kを渡すとkの列を下から順にdatを子のdatのクエリ済のものに更新する（自分のlazは適用しない）\n  updateは（vectorでの）a,b,xを渡すと[a,b)に作用xを適用\n  　　　　　まず閉区間で区間の端二列に関してはlazを一回空にしておく\n  　　　　　区間をカバーする最小個のブロックのlazを更新する\n  　　　　　そのあと閉区間で端っこに関してはdatを変更していく\n  set_valは要素一つに値一つを代入する\n  　　　　　その列のlazを空にしてから一番下に代入して、上にどんどんdatを更新\n  queryは普通にやるだけなんだけど、なんでこれで良いかを考える必要がありそう\n  一番引っかかったのはqueryやupdateで両端だけthrustやrecalcをするか\n  例えば[a,b]にupdateやったあとに[c,d]に対してqueryをする時に[c,d]で見るノードは\n  1.[a,b]でアプデしたノード\n  2.[a,b]に関係ないノード\n  3.a,b,c,dいずれかの上にあるノード\n  だけってのが成り立つからっぽい気がする\n  */\n\n  void init(int n_){\n    n=1;height=0;\n    while(n<n_) n<<=1,height++;\n    dat.assign(2*n,ti);\n    laz.assign(2*n,ei);\n    leng.resize(2*n);\n    int tmp=n;\n    for(int j=1;j<n*2;j*=2){\n      for(int i=j;i<j*2;i++)leng[i]=tmp;\n      tmp/=2;\n    }\n  }\n\n  void build(const vector<T> &v){\n    int n_=v.size();\n    init(n_);\n    for(int i=0;i<n_;i++) dat[n+i]=v[i];\n    for(int i=n-1;i;i--)\n      dat[i]=f(dat[(i<<1)|0],dat[(i<<1)|1]);\n  }\n\n  //inlineは実行時間が短くなる魔法なので読む時には気にしなくていいはず\n\n  inline T reflect(int k){\n    return laz[k]==ei?dat[k]:g(dat[k],laz[k])*leng[k];//作用済のdat[k]の値を返す\n  }\n\n  //propagateは伝わるって意味らしい\n  inline void propagate(int k){//laz[k]をdat[k]と子のlazに適用して自身をeiに戻す\n    if(laz[k]==ei) return;\n    laz[(k<<1)|0]=h(laz[(k<<1)|0],laz[k]);\n    laz[(k<<1)|1]=h(laz[(k<<1)|1],laz[k]);//子の作用の更新\n    dat[k]=reflect(k);//dat[k]を作用済に変更\n    laz[k]=ei;//作用したのでlaz[k]はリセット\n  }\n\n  //thrustは突き出すって意味らしい\n  inline void thrust(int k){\n    for(int i=height;i;i--) propagate(k>>i);//kの列を一番上から更新させていく 子がいない一番下にはやらない\n  }\n\n  inline void recalc(int k){\n    while(k>>=1)\n      dat[k]=f(reflect((k<<1)|0),reflect((k<<1)|1));//kの列を下から上に更新していく\n  }\n\n  void update(int a,int b,E x){//[a,b)に作用Eを適用\n    thrust(a+=n);//aを一番下のそれにして、その列の一番上から現在溜まっている作用を済ませておく\n    thrust(b+=n-1);//bについても同様　ただしここでbは閉区間としてのそれになっている\n    for(int l=a,r=b+1;l<r;l>>=1,r>>=1){//[a,b)の範囲を一番カバーできるlaz(だいたいlog個)を更新する\n      if(l&1) laz[l]=h(laz[l],x),l++;\n      if(r&1) --r,laz[r]=h(laz[r],x);\n    }\n    recalc(a);//今回作用を施した端っこについて下から上にdatを更新していく\n    recalc(b);\n  }\n\n  void set_val(int a,T x){//aにxを代入\n    thrust(a+=n);//aを一番下のそれにして、その列の一番上から現在溜まっている作用を済ませておく\n    dat[a]=x;laz[a]=ei;//aの値をxに変更してそこのlazをリセット\n    recalc(a);//aの上のdatを更新\n  }\n\n  T query(int a,int b){//[a,b)のfを求めるいつものクエリ\n    thrust(a+=n);//aを一番下のそれにして、その列の一番上から現在溜まっている作用を済ませておく\n    thrust(b+=n-1);//bを一番下のそれにして、その列の一番上から現在溜まっている作用を済ませておく\n    T vl=ti,vr=ti;\n    for(int l=a,r=b+1;l<r;l>>=1,r>>=1) {\n      if(l&1) vl=f(vl,reflect(l++));\n      if(r&1) vr=f(reflect(--r),vr);\n    }\n    return f(vl,vr);\n  }\n\n  template<typename C>\n  int find(int st,C &check,T &acc,int k,int l,int r){\n    if(l+1==r){\n      acc=f(acc,reflect(k));\n      return check(acc)?k-n:-1;\n    }\n    propagate(k);\n    int m=(l+r)>>1;\n    if(m<=st) return find(st,check,acc,(k<<1)|1,m,r);\n    if(st<=l&&!check(f(acc,dat[k]))){\n      acc=f(acc,dat[k]);\n      return -1;\n    }\n    int vl=find(st,check,acc,(k<<1)|0,l,m);\n    if(~vl) return vl;\n    return find(st,check,acc,(k<<1)|1,m,r);\n  }\n\n  template<typename C>\n  int find(int st,C &check){\n    T acc=ti;\n    return find(st,check,acc,1,0,n);\n  }\n\n};\n\nsigned main(){\n  int n,q;cin>>n>>q;\n  auto f=[](int a,int b){return a+b;};\n  auto g=[](int a,int b){if(b<-1000)return a;return b;};\n  SegmentTree<int,int> seg(f,g,g,0,-10000);\n  seg.init(n);\n  vector<int> ans;\n  while(q--){\n    int c;cin>>c;\n    if(c){\n      int s,t;cin>>s>>t;\n      ans.push_back(seg.query(s,++t));\n    }\n    else{\n      int s,t,x;cin>>s>>t>>x;\n      seg.update(s,++t,x);\n    }\n  }\n  for(int p:ans)cout<<p<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\ntemplate<typename T, typename E> struct LazySegmentTree;\n\ntemplate<typename T, typename E> struct QueryObject {\n  LazySegmentTree<T, E> *lst;\n  int a, b;\n  E x;\n  int k;\n  int l, r;\n  QueryObject(LazySegmentTree<T, E> *lst_,\n      int a, int b, E x = 0, int k = 0, int l = 0, int r = -1)\n      : a(a), b(b), x(x), k(k), l(l), r(r) {\n    lst = lst_;\n  }\n};\n\ntemplate<typename T, typename E> struct QueryType {\n  virtual int outOfRange(QueryObject<T, E>& o) = 0;\n  virtual int cover(QueryObject<T, E>& o) = 0;\n  virtual int join(QueryObject<T, E>& o, T vl, T vr) = 0;\n  T query(QueryObject<T, E> o) {\n    if (o.r < 0) o.r = o.lst->n;\n    o.lst->eval(o.r - o.l, o.k);\n    if (o.b <= o.l || o.r <= o.a) return outOfRange(o);\n    if (o.a <= o.l && o.r <= o.b) return cover(o);\n    QueryObject<T, E> o1 = o, o2 = o;\n    o1.k = o.k * 2 + 1; o1.r = (o.l + o.r) / 2;\n    o2.k = o.k * 2 + 2; o2.l = (o.l + o.r) / 2;\n    T vl = query(o1);\n    T vr = query(o2);\n    return join(o, vl, vr);\n  }\n};\n\ntemplate<typename T, typename E> struct Setter : QueryType<T, E> {\n  enum setter { RUQ, RAQ };\n  int outOfRange(QueryObject<T, E>& o) {\n    return o.lst->data[o.k];\n  }\n  int cover(QueryObject<T, E>& o) {\n    o.lst->lazy[o.k] = o.lst->h(o.lst->lazy[o.k], o.x);\n    o.lst->eval(o.r - o.l, o.k);\n    return o.lst->data[o.k];\n  }\n  int join(QueryObject<T, E>& o, T vl, T vr) {\n    return o.lst->data[o.k] = o.lst->f(vl, vr);\n  }\n};\n\ntemplate<typename T, typename E> struct Getter : QueryType<T, E> {\n  enum getter { RMQ, RSQ };\n  int outOfRange(QueryObject<T, E>& o) {\n    return o.lst->initT;\n  }\n  int cover(QueryObject<T, E>& o) {\n    return o.lst->data[o.k];\n  }\n  int join(QueryObject<T, E>& o, T vl, T vr) {\n    return o.lst->f(vl, vr);\n  }\n};\n\ntemplate<typename T, typename E> struct LazySegmentTree {\n  using F = function<T(T, T)>;\n  using G = function<T(T, E)>;\n  using H = function<E(E, E)>;\n  using P = function<E(E, int)>;\n\n  F add() {\n    return [&](const T& x, const T& y) -> const T { return x + y; };\n  }\n  F minimum() {\n    return [&](const T& x, const T& y) -> const T { return min(x, y); };\n  }\n  G ex_assign(E initE) {\n    return [&initE](const T& x, const E& y) -> const T { return (y == initE) ? x : y; };\n  }\n  P ex_multiplies(E initE) {\n    return [&initE](const E& x, int y) -> const E { return (x == initE) ? x : x * y; };\n  }\n\n  int n;\n  T initT;\n  E initE;\n  F f;\n  G g;\n  H h;\n  P p;\n  vector<T> data;\n  vector<E> lazy;\n  QueryType<T, E> *type;\n\n  LazySegmentTree() {}\n  LazySegmentTree(QueryType<T, E> *type_) { type = type_; }\n  LazySegmentTree(int n_, int setter, int getter,\n      T initT_ = INT_MAX, E initE_ = INT_MAX, vector<T> v = vector<T>()) {\n    setQuery(setter, getter, initT_, initE_);\n    n = 1;\n    while (n < n_) n *= 2;\n    data.assign(n * 2 - 1, initT);\n    lazy.assign(n * 2 - 1, initE);\n    if (n_ == v.size()) build(v);\n  }\n  void build(vector<T> v) {\n    for (int i = 0; i < v.size(); ++i) data[i + n - 1] = v[i];\n    for (int i = n - 2; i >= 0; --i) {\n      data[i] = f(data[i * 2 + 1], data[i * 2 + 2]);\n    }\n  }\n  void setQuery(int setter, int getter, T initT_, E initE_) {\n    initT = vector<T>{initT_, 0}[getter];\n    initE = vector<E>{initE_, 0}[setter];\n    f = vector<F>{minimum(), add()}[getter];\n    g = vector<G>{ex_assign(initE), add()}[setter];\n    h = vector<H>{ex_assign(initE), add()}[setter];\n    p = ex_multiplies(initE);\n  }\n  inline void eval(int len, int k) {\n    if (lazy[k] == initE) return;\n    if (k * 2 + 1 < n * 2 - 1) {\n      lazy[k * 2 + 1] = h(lazy[k * 2 + 1], lazy[k]);\n      lazy[k * 2 + 2] = h(lazy[k * 2 + 2], lazy[k]);\n    }\n    data[k] = g(data[k], p(lazy[k], len));\n    lazy[k] = initE;\n  }\n  T query(QueryObject<T, E>& obj) {\n    return type->query(obj);\n  }\n  T setData(int a, int b, E x) {\n    LazySegmentTree<T, E> lst(new Setter<T, E>());\n    QueryObject<T, E> obj(this, a, b, x);\n    return lst.query(obj);\n  }\n  T getData(int a, int b) {\n    LazySegmentTree<T, E> lst(new Getter<T, E>());\n    QueryObject<T, E> obj(this, a, b);\n    return lst.query(obj);\n  }\n};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, q; cin >> n >> q;\n  LazySegmentTree<ll, ll> seg(n, Setter<ll, ll>::RUQ, Getter<ll, ll>::RSQ);\n\n  while (q--) {\n    int com; cin >> com;\n    if (com) {\n      int s, t; cin >> s >> t;\n      cout << seg.getData(s, t + 1) << endl;\n    } else {\n      int s, t, x; cin >> s >> t >> x;\n      seg.setData(s, t + 1, x);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <list>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\n\nlong long int INF = 1e18;\nint const TREE_SIZE = 1 << 20;\nlong long int seg_tree[TREE_SIZE] = {};\nbool is_a[TREE_SIZE] = {}; // その区間に値が代入されたかどうか\n\nlong long int getsum(int a, int b, int index, int l, int r){\n\t\n\t// [a, b) の合計値を求める\n\tif(r <= a || b <= l){\n\t\treturn 0;\n\t}\n\tif(a <= l && r <= b){\n\t\treturn seg_tree[index];\n\t}\n\tif(is_a[index]){\n\t\treturn seg_tree[index] / (r - l) * (min(r, b) - max(l, a)); // \n\t}\n\tlong long int ret = 0;\n\tret += getsum(a, b, index * 2, l, (l + r) / 2);\n\tret += getsum(a, b, index * 2 + 1, (l + r) / 2, r);\n\treturn ret;\n}\n\nlong long int update(int a, int b, int index, int num, int l, int r){\n\t\n\t// [a, b) を num に変更する\n\t\n\tif(r <= a || b <= l){\n\t\t//cout << l << \" \" << r << \" \" << seg_tree[index] << endl;\n\t\treturn seg_tree[index];\n\t}\n\tif(a <= l && r <= b){\n\t\tseg_tree[index] = num * (r - l);\n\t\tis_a[index] = true;\n\t\t//cout << l << \" \" << r << \" \" << seg_tree[index] << endl;\n\t\treturn seg_tree[index];\n\t}\n\tlong long int ret = 0;\n\tif(is_a[index]){\n\t\tis_a[index * 2] = true;\n\t\tseg_tree[index * 2] = seg_tree[index] / 2;\n\t\tis_a[index * 2 + 1] = true;\n\t\tseg_tree[index * 2 + 1] = seg_tree[index] / 2;\n\t\tis_a[index] = false;\n\t}\n\tret += update(a, b, index * 2, num, l, (l + r) / 2);\n\tret += update(a, b, index * 2 + 1, num, (l + r) / 2, r);\n\t//cout << l << \" \" << r << \" \" << ret << endl;\n\treturn seg_tree[index] = ret;\n}\n\nint main(){\n\t\n\tint n, q;\n\tcin >> n >> q;\n\t\n\tfor(int i = 0; i < q; i++){\n\t\tlong long int num, a, b, c;\n\t\tcin >> num;\n\t\tif(num == 0){\n\t\t\tcin >> a >> b >> c;\n\t\t\tupdate(a, b + 1, 1, c, 0, TREE_SIZE / 2);\n\t\t}else{\n\t\t\tcin >> a >> b;\n\t\t\tcout << getsum(a, b + 1, 1, 0, TREE_SIZE / 2) << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\ntemplate<typename T, typename E> struct LazySegmentTree;\n\ntemplate<typename T, typename E> struct QueryObject {\n  LazySegmentTree<T, E> *lst;\n  int a, b;\n  E x;\n  int k;\n  int l, r;\n  QueryObject(LazySegmentTree<T, E> *lst,\n      int a, int b, E x = 0, int k = 0, int l = 0, int r = -1)\n      : lst(lst), a(a), b(b), x(x), k(k), l(l), r(r) {}\n};\n\ntemplate<typename T, typename E> struct QueryType {\n  virtual int outOfRange(QueryObject<T, E> o) = 0;\n  virtual int cover(QueryObject<T, E> o) = 0;\n  virtual int join(QueryObject<T, E> o, T vl, T vr) = 0;\n  T query(QueryObject<T, E> o) {\n    if (o.r < 0) o.r = o.lst->n;\n    o.lst->eval(o.r - o.l, o.k);\n    if (o.b <= o.l || o.r <= o.a) return outOfRange(o);\n    if (o.a <= o.l && o.r <= o.b) return cover(o);\n    QueryObject<T, E> o1 = o, o2 = o;\n    o1.k = o.k * 2 + 1; o1.r = (o.l + o.r) / 2;\n    o2.k = o.k * 2 + 2; o2.l = (o.l + o.r) / 2;\n    T vl = query(o1);\n    T vr = query(o2);\n    return join(o, vl, vr);\n  }\n};\n\ntemplate<typename T, typename E> struct Setter : QueryType<T, E> {\n  enum setter { RUQ, RAQ };\n  int outOfRange(QueryObject<T, E> o) {\n    return o.lst->data[o.k];\n  }\n  int cover(QueryObject<T, E> o) {\n    o.lst->lazy[o.k] = o.lst->h(o.lst->lazy[o.k], o.x);\n    o.lst->eval(o.r - o.l, o.k);\n    return o.lst->data[o.k];\n  }\n  int join(QueryObject<T, E> o, T vl, T vr) {\n    return o.lst->data[o.k] = o.lst->f(vl, vr);\n  }\n};\n\ntemplate<typename T, typename E> struct Getter : QueryType<T, E> {\n  enum getter { RMQ, RSQ };\n  int outOfRange(QueryObject<T, E> o) {\n    return o.lst->initT;\n  }\n  int cover(QueryObject<T, E> o) {\n    return o.lst->data[o.k];\n  }\n  int join(QueryObject<T, E> o, T vl, T vr) {\n    return o.lst->f(vl, vr);\n  }\n};\n\ntemplate<typename T, typename E> struct LazySegmentTree {\n  using F = function<T(T, T)>;\n  using G = function<T(T, E)>;\n  using H = function<E(E, E)>;\n  using P = function<E(E, int)>;\n\n  F add() {\n    return [&](const T& x, const T& y) -> const T { return x + y; };\n  }\n  F minimum() {\n    return [&](const T& x, const T& y) -> const T { return min(x, y); };\n  }\n  G ex_assign(E initE) {\n    return [&initE](const T& x, const E& y) -> const T { return (y == initE) ? x : y; };\n  }\n  P ex_multiplies(E initE) {\n    return [&initE](const E& x, int y) -> const E { return (x == initE) ? x : x * y; };\n  }\n\n  int n;\n  T initT;\n  E initE;\n  F f;\n  G g;\n  H h;\n  P p;\n  vector<T> data;\n  vector<E> lazy;\n  QueryType<T, E> *type;\n\n  LazySegmentTree() {}\n  LazySegmentTree(QueryType<T, E> *type_) { type = type_; }\n  LazySegmentTree(int n_, int setter, int getter,\n      T initT_ = INT_MAX, E initE_ = INT_MAX, vector<T> v = vector<T>()) {\n    setQuery(setter, getter, initT_, initE_);\n    n = 1;\n    while (n < n_) n *= 2;\n    data.assign(n * 2 - 1, initT);\n    lazy.assign(n * 2 - 1, initE);\n    if (n_ == v.size()) build(v);\n  }\n  void build(vector<T> v) {\n    for (int i = 0; i < v.size(); ++i) data[i + n - 1] = v[i];\n    for (int i = n - 2; i >= 0; --i) {\n      data[i] = f(data[i * 2 + 1], data[i * 2 + 2]);\n    }\n  }\n  void setQuery(int setter, int getter, T initT_, E initE_) {\n    initT = vector<T>{initT_, 0}[getter];\n    initE = vector<E>{initE_, 0}[setter];\n    f = vector<F>{minimum(), add()}[getter];\n    g = vector<G>{ex_assign(initE_), add()}[setter];\n    h = vector<H>{ex_assign(initE_), add()}[setter];\n    p = ex_multiplies(initE_);\n  }\n  inline void eval(int len, int k) {\n    if (lazy[k] == initE) return;\n    if (k * 2 + 1 < n * 2 - 1) {\n      lazy[k * 2 + 1] = h(lazy[k * 2 + 1], lazy[k]);\n      lazy[k * 2 + 2] = h(lazy[k * 2 + 2], lazy[k]);\n    }\n    data[k] = g(data[k], p(lazy[k], len));\n    lazy[k] = initE;\n  }\n  T query(QueryObject<T, E>& obj) {\n    return type->query(obj);\n  }\n  T setData(int a, int b, E x) {\n    LazySegmentTree<T, E> lst(new Setter<T, E>());\n    QueryObject<T, E> obj(this, a, b, x);\n    return lst.query(obj);\n  }\n  T getData(int a, int b) {\n    LazySegmentTree<T, E> lst(new Getter<T, E>());\n    QueryObject<T, E> obj(this, a, b);\n    return lst.query(obj);\n  }\n};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, q; cin >> n >> q;\n  LazySegmentTree<ll, ll> seg(n, Setter<ll, ll>::RUQ, Getter<ll, ll>::RSQ);\n\n  while (q--) {\n    int com; cin >> com;\n    if (com) {\n      int s, t; cin >> s >> t;\n      cout << seg.getData(s, t + 1) << endl;\n    } else {\n      int s, t, x; cin >> s >> t >> x;\n      seg.setData(s, t + 1, x);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\nclass kin{\npublic:\n\tinline void open(FILE *,int);\n\tinline void close(void);\n\tinline void scan(void);\n\tinline kin &operator>(char &);\n\tinline kin &operator>(int &);\n\tinline kin &operator>(long long &);\n\tinline kin &operator>(double &);\n\tinline kin &operator>(long double &);\n\tinline kin &operator>(char *);\n\ttemplate<class T>\n\tinline void get(T *,int);\nprivate:\n\tFILE *fp;\n\tchar *buf;\n\tint siz;\n\tint idx;\n}in;\n\nclass kout{\npublic:\n\tinline void open(FILE *,int);\n\tinline void close(void);\n\tinline void print(void);\n\tinline kout &operator<(char);\n\tinline kout &operator<(int);\n\tinline kout &operator<(long long);\n\tinline kout &operator<(double);\n\tinline kout &operator<(long double);\n\tinline kout &operator<(const char *);\n\ttemplate<class T>\n\tinline void put(T *,int,char,char);\nprivate:\n\tFILE *fp;\n\tchar *buf;\n\tint siz;\n\tint idx;\n}out;\n\ntemplate<class T,class A,class F,class G,class H>\nclass rrseg{\npublic:\n\tinline void open(int);\n\tinline void close(void);\n\tinline void put(int,int,A);\n\tinline T get(int,int);\n\tinline void set(int,T);\n\tinline void build(void);\n\tinline rrseg(T,A);\n\tinline rrseg(T,A,int);\nprivate:\n\tint siz;\n\tint hgt;\n\tint node;\n\tT *dat;\n\tA *laz;\n\tT idt;\n\tA ida;\n\tF appf;\n\tG appg;\n\tH apph;\n\tinline T reflect(int,int);\n\tinline void update(int);\n};\n\nint main(int argc,char **argv){\n\tin.open(stdin,512);\n\tout.open(stdout,512);\n\tin.scan();\n\tstruct fnf{inline int operator()(int chx,int chy){return chx+chy;}};\n\tstruct fng{inline int operator()(int laz,int cnt,int dat){return laz*cnt;}};\n\tstruct fnh{inline int operator()(int par,int ch){return par;}};\n\tint n;\n\tin>n;\n\trrseg<int,int,fnf,fng,fnh> t(0,2147483647,n);\n\tint q;\n\tin>q;\n\tfor(int i=0;i<q;++i){\n\t\tint c,l,r;\n\t\tin>c>l>r;\n\t\tif(c==0){\n\t\t\tint x;\n\t\t\tin>x;\n\t\t\tt.put(l,r+1,x);\n\t\t}\n\t\telse out<t.get(l,r+1)<'\\n';\n\t}\n\tt.close();\n\tout.print();\n\tin.close();\n\tout.close();\n\treturn 0;\n}\n\ntemplate<class T,class A,class F,class G,class H>\ninline void rrseg<T,A,F,G,H>::open(int siza){\n\tsiz=1;\n\thgt=0;\n\twhile(siz<siza){\n\t\tsiz*=2;\n\t\t++hgt;\n\t}\n\tsiz=siza;\n\tnode=siz-1;\n\tint n=node+siz;\n\tdat=new T[n];\n\tlaz=new A[n];\n\tfor(int i=0;i<n;++i){\n\t\tdat[i]=idt;\n\t\tlaz[i]=ida;\n\t}\n\treturn;\n}\ntemplate<class T,class A,class F,class G,class H>\ninline void rrseg<T,A,F,G,H>::close(void){\n\tsiz=hgt=node=0;\n\tdelete[] dat;\n\tdelete[] laz;\n\tdat=laz=nullptr;\n\treturn;\n}\ntemplate<class T,class A,class F,class G,class H>\ninline void rrseg<T,A,F,G,H>::put(int first,int last,A val){\n\tupdate(first);\n\tupdate(last-1);\n\tint s=first+=node;\n\tint t=last+=node;\n\twhile(first<last){\n\t\tif(!(first&1)) laz[first]=apph(val,laz[first]);\n\t\tif(!(last&1)){\n\t\t\tlaz[last-1]=apph(val,laz[last-1]);\n\t\t\t--last;\n\t\t}\n\t\tfirst/=2;\n\t\tlast/=2;\n\t}\n\tint hs=s<(1<<hgt)-1?hgt-1:hgt;\n\tfor(int i=0;i<hs;++i){\n\t\ts=(s-1)/2;\n\t\tdat[s]=appf(reflect(s*2+1,1<<i),reflect(s*2+2,1<<i));\n\t}\n\tint ht=t<=(1<<hgt)-1?hgt-1:hgt;\n\tfor(int i=0;i<ht;++i){\n\t\tt/=2;\n\t\tdat[t-1]=appf(reflect(t*2-1,1<<i),reflect(t*2,1<<i));\n\t}\n\treturn;\n}\ntemplate<class T,class A,class F,class G,class H>\ninline T rrseg<T,A,F,G,H>::get(int first,int last){\n\tupdate(first);\n\tupdate(last-1);\n\tfirst+=node;\n\tlast+=node;\n\tT x=idt;\n\tint p=0;\n\twhile(first<last){\n\t\tif(!(first&1)) x=appf(reflect(first,1<<p),x);\n\t\tif(!(last&1)) x=appf(reflect(--last,1<<p),x);\n\t\tfirst/=2;\n\t\tlast/=2;\n\t\t++p;\n\t}\n\treturn x;\n}\ntemplate<class T,class A,class F,class G,class H>\ninline void rrseg<T,A,F,G,H>::set(int num,T val){\n\tdat[num+node]=val;\n\treturn;\n}\ntemplate<class T,class A,class F,class G,class H>\ninline void rrseg<T,A,F,G,H>::build(void){\n\tint d=node;\n\tfor(int k=(1<<hgt-1)-1;k<d;++k) dat[k]=appf(dat[k*2+1],dat[k*2+2]);\n\tfor(int i=hgt-2;i>=0;--i){\n\t\tint d=(1<<i+1)-1;\n\t\tfor(int k=(1<<i)-1;k<d;++k) dat[k]=appf(dat[k*2+1],dat[k*2+2]);\n\t}\n\treturn;\n}\ntemplate<class T,class A,class F,class G,class H>\ninline T rrseg<T,A,F,G,H>::reflect(int num,int cnt){\n\treturn laz[num]!=ida?appg(laz[num],cnt,dat[num]):dat[num];\n}\ntemplate<class T,class A,class F,class G,class H>\ninline void rrseg<T,A,F,G,H>::update(int num){\n\tint k=0;\n\tint h=num+node<(1<<hgt)-1?hgt-1:hgt;\n\tfor(int i=h-1;i>=0;--i){\n\t\tif(laz[k]!=ida){\n\t\t\tlaz[k*2+1]=apph(laz[k],laz[k*2+1]);\n\t\t\tlaz[k*2+2]=apph(laz[k],laz[k*2+2]);\n\t\t\tdat[k]=reflect(k,1<<i+1);\n\t\t\tlaz[k]=ida;\n\t\t}\n\t\tk=k*2+1+(num+siz>>i&1);\n\t}\n\treturn;\n}\ntemplate<class T,class A,class F,class G,class H>\ninline rrseg<T,A,F,G,H>::rrseg(T idta,A idaa){\n\tidt=idta;\n\tida=idaa;\n\tsiz=hgt=node=0;\n\tdat=laz=nullptr;\n}\ntemplate<class T,class A,class F,class G,class H>\ninline rrseg<T,A,F,G,H>::rrseg(T idta,A idaa,int siza){\n\tidt=idta;\n\tida=idaa;\n\topen(siza);\n}\n\ninline void kin::open(FILE *fpa,int siza){\n\tfp=fpa;\n\tbuf=new char[siza];\n\tsiz=siza;\n\tidx=0;\n\treturn;\n}\ninline void kin::close(void){\n\tfp=nullptr;\n\tdelete[] buf;\n\tbuf=nullptr;\n\tsiz=0;\n\tidx=0;\n\treturn;\n}\ninline void kin::scan(void){\n\tint readsiz=(int)std::fread((void *)buf,(std::size_t)1,(std::size_t)siz,fp);\n\tif(readsiz!=siz) buf[readsiz]='\\x00';\n\tidx=0;\n\treturn;\n}\ninline kin &kin::operator>(char &var){\n\tif(!buf[idx]){\n\t\tvar='\\x00';\n\t\treturn *this;\n\t}\n\tvar=buf[idx];\n\tif(++idx==siz) scan();\n\tif(++idx==siz) scan();\n\treturn *this;\n}\ninline kin &kin::operator>(int &var){\n\tif(!buf[idx]){\n\t\tvar=0;\n\t\treturn *this;\n\t}\n\tint sign=-1;\n\tif(buf[idx]=='-'){\n\t\tsign=1;\n\t\tif(++idx==siz) scan();\n\t}\n\tvar=0;\n\twhile(buf[idx]>='0'){\n\t\tvar=var*10-(int)(buf[idx]-'0');\n\t\tif(++idx==siz) scan();\n\t}\n\tvar*=sign;\n\tif(++idx==siz) scan();\n\treturn *this;\n}\ninline kin &kin::operator>(long long &var){\n\tif(!buf[idx]){\n\t\tvar=0LL;\n\t\treturn *this;\n\t}\n\tlong long sign=-1LL;\n\tif(buf[idx]=='-'){\n\t\tsign=1LL;\n\t\tif(++idx==siz) scan();\n\t}\n\tvar=0LL;\n\twhile(buf[idx]>='0'){\n\t\tvar=var*10LL-(long long)(buf[idx]-'0');\n\t\tif(++idx==siz) scan();\n\t}\n\tvar*=sign;\n\tif(++idx==siz) scan();\n\treturn *this;\n}\ninline kin &kin::operator>(double &var){\n\tif(!buf[idx]){\n\t\tvar=0.0;\n\t\treturn *this;\n\t}\n\tdouble sign=-1.0;\n\tif(buf[idx]=='-'){\n\t\tsign=1.0;\n\t\tif(++idx==siz) scan();\n\t}\n\tvar=0.0;\n\twhile(buf[idx]>='0'){\n\t\tvar=var*10.0-(double)(buf[idx]-'0');\n\t\tif(++idx==siz) scan();\n\t}\n\tif(buf[idx]=='.'){\n\t\tif(++idx==siz) scan();\n\t\tdouble dig=1.0;\n\t\twhile(buf[idx]>='0'){\n\t\t\tvar-=(double)(buf[idx]-'0')*(dig/=10.0);\n\t\t\tif(++idx==siz) scan();\n\t\t}\n\t}\n\tvar*=sign;\n\tif(++idx==siz) scan();\n\treturn *this;\n}\ninline kin &kin::operator>(long double &var){\n\tif(!buf[idx]){\n\t\tvar=0.0L;\n\t\treturn *this;\n\t}\n\tlong double sign=-1.0L;\n\tif(buf[idx]=='-'){\n\t\tsign=1.0L;\n\t\tif(++idx==siz) scan();\n\t}\n\tvar=0.0L;\n\twhile(buf[idx]>='0'){\n\t\tvar=var*10.0L-(long double)(buf[idx]-'0');\n\t\tif(++idx==siz) scan();\n\t}\n\tif(buf[idx]=='.'){\n\t\tif(++idx==siz) scan();\n\t\tlong double dig=1.0L;\n\t\twhile(buf[idx]>='0'){\n\t\t\tvar-=(long double)(buf[idx]-'0')*(dig/=10.0L);\n\t\t\tif(++idx==siz) scan();\n\t\t}\n\t}\n\tvar*=sign;\n\tif(++idx==siz) scan();\n\treturn *this;\n}\ninline kin &kin::operator>(char *var){\n\tif(!buf[idx]){\n\t\tvar[0]='\\x00';\n\t\treturn *this;\n\t}\n\tint ptr=0;\n\twhile(buf[idx]>='!'){\n\t\tvar[ptr++]=buf[idx];\n\t\tif(++idx==siz) scan();\n\t}\n\tvar[ptr]='\\x00';\n\tif(++idx==siz) scan();\n\treturn *this;\n}\ntemplate<class T>\ninline void kin::get(T *var,int num){\n\tfor(int i=0;i<num;++i) (*this)>var[i];\n\treturn;\n}\n\ninline void kout::open(FILE *fpa,int siza){\n\tfp=fpa;\n\tbuf=new char[siza];\n\tsiz=siza;\n\tidx=0;\n\treturn;\n}\ninline void kout::close(void){\n\tfp=nullptr;\n\tdelete[] buf;\n\tbuf=nullptr;\n\tsiz=0;\n\tidx=0;\n\treturn;\n}\ninline void kout::print(void){\n\tstd::fwrite((void *)buf,(std::size_t)1,(std::size_t)idx,fp);\n\tidx=0;\n\treturn;\n}\ninline kout &kout::operator<(char val){\n\tbuf[idx]=val;\n\tif(++idx==siz) print();\n\treturn *this;\n}\ninline kout &kout::operator<(int val){\n\tif(val<0){\n\t\tbuf[idx]='-';\n\t\tif(++idx==siz) print();\n\t}\n\telse val*=-1;\n\tchar dig[10];\n\tint ptr=0;\n\tdo{\n\t\tint tmp=val/10;\n\t\tdig[ptr++]=(char)-(val-tmp*10)+'0';\n\t\tval=tmp;\n\t}while(val);\n\twhile(ptr--){\n\t\tbuf[idx]=dig[ptr];\n\t\tif(++idx==siz) print();\n\t}\n\treturn *this;\n}\ninline kout &kout::operator<(long long val){\n\tif(val<0LL){\n\t\tbuf[idx]='-';\n\t\tif(++idx==siz) print();\n\t}\n\telse val*=-1LL;\n\tchar dig[19];\n\tint ptr=0;\n\tdo{\n\t\tlong long tmp=val/10LL;\n\t\tdig[ptr++]=(char)-(val-tmp*10LL)+'0';\n\t\tval=tmp;\n\t}while(val);\n\twhile(ptr--){\n\t\tbuf[idx]=dig[ptr];\n\t\tif(++idx==siz) print();\n\t}\n\treturn *this;\n}\ninline kout &kout::operator<(double val){\n\tif(val<0.0){\n\t\tbuf[idx]='-';\n\t\tif(++idx==siz) print();\n\t}\n\telse val*=-1.0;\n\tdouble dig=1.0;\n\twhile(val/dig<=-10.0) dig*=10.0;\n\tint tmp;\n\twhile(dig>=1.0){\n\t\tbuf[idx]=(char)-(tmp=(int)(val/dig))+'0';\n\t\tif(++idx==siz) print();\n\t\tval-=(double)tmp*dig;\n\t\tdig/=10.0;\n\t}\n\tbuf[idx]='.';\n\tif(++idx==siz) print();\n\tfor(int i=0;i<12;++i){\n\t\tbuf[idx]=(char)-(tmp=(int)(val/dig))+'0';\n\t\tif(++idx==siz) print();\n\t\tval-=(double)tmp*dig;\n\t\tdig/=10.0;\n\t}\n\treturn *this;\n}\ninline kout &kout::operator<(long double val){\n\tif(val<0.0L){\n\t\tbuf[idx]='-';\n\t\tif(++idx==siz) print();\n\t}\n\telse val*=-1.0L;\n\tlong double dig=1.0L;\n\twhile(val/dig<=-10.0L) dig*=10.0L;\n\tint tmp;\n\twhile(dig>=1.0L){\n\t\tbuf[idx]=(char)-(tmp=(int)(val/dig))+'0';\n\t\tif(++idx==siz) print();\n\t\tval-=(long double)tmp*dig;\n\t\tdig/=10.0L;\n\t}\n\tbuf[idx]='.';\n\tif(++idx==siz) print();\n\tfor(int i=0;i<16;++i){\n\t\tbuf[idx]=(char)-(tmp=(int)(val/dig))+'0';\n\t\tif(++idx==siz) print();\n\t\tval-=(long double)tmp*dig;\n\t\tdig/=10.0L;\n\t}\n\treturn *this;\n}\ninline kout &kout::operator<(const char *val){\n\tfor(int i=0;val[i];++i){\n\t\tbuf[idx]=val[i];\n\t\tif(++idx==siz) print();\n\t}\n\treturn *this;\n}\ntemplate<class T>\ninline void kout::put(T *val,int num,char spc,char end){\n\t--num;\n\tfor(int i=0;i<num;++i) (*this)<val[i]<spc;\n\t(*this)<val[num]<end;\n\treturn;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\ntemplate <class M>\nstruct LazySegmentTree{\n    using T = typename M::T;\n    using L = typename M::L;\n    int sz, height{};\n    vector<T> seg; vector<L> lazy;\n    explicit LazySegmentTree(int n) {\n        sz = 1;\n        while(sz < n) sz <<= 1, height++;\n        seg.assign(2*sz, M::e());\n        lazy.assign(2*sz, M::l());\n    }\n\n    void set(int k, const T &x){\n        seg[k + sz] = x;\n    }\n\n    void build(){\n        for (int i = sz-1; i > 0; --i) seg[i] = M::f(seg[2*i], seg[2*i+1]);\n    }\n\n    T reflect(int k){ return lazy[k] == M::l() ? seg[k] : M::g(seg[k], lazy[k]); }\n\n    void eval(int k){\n        if(lazy[k] == M::l()) return;\n        lazy[(k<<1)|0] = M::h(lazy[(k<<1)|0], lazy[k]);\n        lazy[(k<<1)|1] = M::h(lazy[(k<<1)|1], lazy[k]);\n        seg[k] = reflect(k);\n        lazy[k] = M::l();\n    }\n    void thrust(int k){ for (int i = height; i; --i) eval(k>>i); }\n    void recalc(int k) { while(k >>= 1) seg[k] = M::f(reflect((k<<1)|0), reflect((k<<1)|1));}\n    void update(int a, int b, const L &x){\n        thrust(a += sz); thrust(b += sz-1);\n        for (int l = a, r = b+1;l < r; l >>=1, r >>= 1) {\n            if(l&1) lazy[l] = M::h(lazy[l], x), l++;\n            if(r&1) --r, lazy[r] = M::h(lazy[r], x);\n        }\n        recalc(a);\n        recalc(b);\n    }\n\n    T query(int a, int b){ // [l, r)\n        thrust(a += sz);\n        thrust(b += sz-1);\n        T ll = M::e(), rr = M::e();\n        for(int l = a, r = b+1; l < r; l >>=1, r>>=1) {\n            if (l & 1) ll = M::f(ll, reflect(l++));\n            if (r & 1) rr = M::f(reflect(--r), rr);\n        }\n        return M::f(ll, rr);\n    }\n\n    T operator[](const int &k) const { // 0-indexed\n        return seg[k + sz];\n    }\n};\n\nstruct Monoid{\n    using T = pair<ll, ll>;\n    using L = ll;\n    static T f(T a, T b) { return {a.first+b.first, a.second+b.second}; }\n    static T g(T a, L b) {\n        if(b == l()) return a;\n        else return {b*a.second, a.second};\n    }\n    static L h(L a, L b) { if(b == l()) return a; else return b; }\n    static T e() { return {0, 0}; }\n    static L l() { return INF<int>; }\n};\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    LazySegmentTree<Monoid> seg(n);\n    for (int i = 0; i < n; ++i) {\n        seg.set(i, {0, 1});\n    }\n    seg.build();\n    for (int i = 0; i < q; ++i) {\n        int v;\n        scanf(\"%d\", &v);\n        if(v == 0){\n            int s, t; ll x;\n            scanf(\"%d%d%lld\", &s, &t, &x);\n            seg.update(s, t+1, x);\n        }else {\n            int a, b;\n            scanf(\"%d%d\", &a, &b);\n            printf(\"%lld\\n\", seg.query(a, b+1).first);\n        }\n    }\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T, typename U>\nstruct range_minimum_query {\n  const T id;\n  const function<T(T, T)> merge_function;\n  const function<void(U&)> twice;\n  const function<U(U)> half;\n  range_minimum_query(T id):\n    id(id),\n    merge_function ([](T a, T b) {return min(a, b);}),\n    twice ([](U& a) {}),\n    half ([](U a) {return a;})\n    {\n    }\n};\ntemplate<typename T, typename U>\nstruct range_maximum_query {\n  const T id;\n  const function<T(T, T)> merge_function;\n  const function<void(U&)> twice;\n  const function<U(U)> half;\n  range_maximum_query(T id):\n    id(id),\n    merge_function ([](T a, T b) {return max(a, b);}),\n    twice ([](U& a) {}),\n    half ([](U a) {return a;})\n    {\n    }\n};\ntemplate<typename T, typename U>\nstruct range_sum_query {\n  const T id;\n  const function<T(T, T)> merge_function;\n  const function<void(U&)> twice;\n  const function<U(U)> half;\n  range_sum_query(T id = 0):\n    id(id),\n    merge_function ([](T a, T b) {return a + b;}),\n    twice ([](U& a) {a *= 2;}),\n    half ([](U a) {return a / 2;})\n    {\n    }\n};\ntemplate<typename T, typename U>\nstruct range_update_query {\n    const U id;\n    const function<void(T&, U)> action;\n    const function<void(U&, U)> composition;\n  public:\n    range_update_query(U id = 0):\n      id(id),\n      action ([](T& a, U b) {a = b;}),\n      composition ([](U& a, U b) {a = b;})\n      {\n      }\n};\ntemplate<typename T, typename U>\nstruct range_add_query {\n    const U id;\n    const function<void(T&, U)> action;\n    const function<void(U&, U)> composition;\n  public:\n    range_add_query(U id = 0):\n      id(id),\n      action ([](T& a, U b) {a += b;}),\n      composition ([](U& a, U b) {a += b;})\n      {\n      }\n};\ntemplate<typename T, typename U>\nclass segment_tree {\n  int sz;\n  int Sz;\n  int ht;\n  vector<T> seg;\n  vector<U> act;\n  vector<bool> has_act;\n  const function<T(T, T)> o;\n  const function<void(T&, U)> oo;\n  const function<void(U&, U)> ooo;\n  const function<void(U&)> twice;\n  const function<U(U)> half;\n  const T tid;\n  const U uid;\n  \n  public:\n    segment_tree(\n        int n,\n        const function<T(T, T)> merge_function,\n        const function<void(T&, U)> action,\n        const function<void(U&, U)> composition,\n        const function<void(U&)> twice,\n        const function<U(U)> half,\n        const T seg_id,\n        const U act_id\n      )\n        : o(merge_function)\n        , oo(action)\n        , ooo(composition)\n        , twice(twice)\n        , half(half)\n        , tid(seg_id)\n        , uid(act_id)\n      {\n        ht = 1, sz = 1;\n        while(sz < n) ht++, sz <<= 1;\n        Sz = sz << 1;\n        seg.assign(Sz, tid);\n        act.resize(Sz, act_id);\n        has_act.assign(Sz, false);\n      }\n    \n    segment_tree(\n        const vector<T>& data,\n        const function<T(T, T)> merge_function,\n        const function<void(T&, U)> action,\n        const function<void(U&, U)> composition,\n        const function<void(U&)> twice,\n        const function<U(U)> half,\n        const T seg_id,\n        const U act_id\n      )\n        : segment_tree(\n            data.size(),\n            merge_function,\n            action,\n            composition,\n            twice,\n            half,\n            seg_id,\n            act_id\n          )\n      {\n        copy(data.begin(), data.end(), seg.begin() + sz);\n        for (int i = sz - 1; i >= 1; i--) seg[i] = o(seg[i << 1], seg[(i << 1) + 1]);\n      }\n    \n    template<typename V, typename M, typename A>\n    segment_tree(\n        const V n_or_v,\n        const M& merge_instance,\n        const A& action_instance\n      )\n        : segment_tree(\n          n_or_v,\n          merge_instance.merge_function,\n          action_instance.action,\n          action_instance.composition,\n          merge_instance.twice,\n          merge_instance.half,\n          merge_instance.id,\n          action_instance.id\n        )\n      {\n      }\n    \n    inline int lft (int i) {return i << 1;}\n    inline int rgt (int i) {return (i << 1) + 1;}\n    inline int upp (int i) {return i >> 1;}\n\n    inline void propagate (\n        int k,\n        int L,\n        int R\n      )\n      {\n        if (has_act[k]) {\n          oo(seg[k], act[k]);\n          if (k < sz) {\n            ooo(act[lft(k)], half(act[k]));\n            ooo(act[rgt(k)], half(act[k]));\n            has_act[lft(k)] = has_act[rgt(k)] = true;\n          }\n          act[k] = uid, has_act[k] = false;\n        }\n      }\n\n    void update (\n        int l,\n        int r,\n        T x,\n        int k = 1,\n        int L = 0,\n        int R = -1\n      )\n      {\n        if (R == -1) R = sz;\n        if (k == 1) for (int i = 0; i < ht - 1; i++) twice(x);\n        propagate(k, L, R);\n        if (R <= l || r <= L) return;\n        if (l <= L && R <= r) {\n          ooo(act[k], x), has_act[k] = true;\n          propagate(k, L, R);\n        } else {\n          int C = (L + R) >> 1;\n          update(l, r, half(x), lft(k), L, C);\n          update(l, r, half(x), rgt(k), C, R);\n          seg[k] = o(seg[lft(k)], seg[rgt(k)]);\n        }\n      }\n    \n    T find (\n        int l,\n        int r,\n        int k = 1,\n        int L = 0,\n        int R = -1\n      )\n      {\n        if (R == -1) R = sz;\n        propagate(k, L, R);\n        if (R <= l || r <= L) return tid;\n        if (l <= L && R <= r) {\n          propagate(k, L, R);\n          return seg[k];\n        } else {\n          int C = (L + R) >> 1;\n          T lv = find(l, r, lft(k), L, C);\n          T rv = find(l, r, rgt(k), C, R);\n          seg[k] = o(seg[lft(k)], seg[rgt(k)]);\n          return o(lv, rv);\n        }\n      }\n\n    void print(int w = 4) {\n      for (int i(1), last(2), output_size(w << ht); last <= Sz; last <<= 1, output_size >>= 1) {\n        for (; i < last; i++) {\n          cout << right << setw(w);\n          cout << (seg[i] != tid ? to_string(seg[i]) : \"\");\n          cout << setw(2) <<  \"<\";\n          cout << left << setw(output_size - w - 2);\n          cout << (has_act[i] ? to_string(act[i]) : \"\");\n        }\n        cout << endl;\n      }\n    }\n};\nint main() {\n  int n, q;\n  cin >> n >> q;\n  segment_tree<int, int> sgt(\n    vector<int>(n, 0),\n    range_sum_query<int, int>(),\n    range_update_query<int, int>()\n  );\n  while (q--) {\n    int c;\n    cin >> c;\n    if (c == 0) {\n      int l, r, x;\n      cin >> l >> r >> x;\n      sgt.update(l, ++r, x);\n    } else {\n      int l, r;\n      cin >> l >> r;\n      cout << sgt.find(l, ++r) << endl; \n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)\nconst ll INF = 1LL << 60; //MAX 9223372036854775807\n\n//子から親を求める演算\nauto calc_parent = [](ll x, ll y) { return x+y; };\n//親遅延配列を子に伝播する演算\nauto calc_lazychild = [](ll &x,ll y) { x=y/2; };\n//遅延配列をノードに反映する演算\nauto lazy_to_node = [](ll &x,ll y) { x=y; };\n//遅延配列に値を入れる演算 y-値 l,r-区間index\nauto intolazy = [](ll &x,ll y,ll r,ll l) { x=(r-l)*y; };\n//単位元\nconst ll unit = 0;\n\nstruct LazySegTree\n{\nprivate:\n  ll n;\n  vector<ll> node,lazy;\n  vector<bool> islazy;\n\npublic:\n  LazySegTree(vector<ll> v)\n  {\n    node.resize((1LL << 64 - __builtin_clzll(v.size())) * 2 - 1, unit); \n    lazy.resize((1LL << 64 - __builtin_clzll(v.size())) * 2 - 1, unit); \n    islazy.resize((1LL << 64 - __builtin_clzll(v.size())) * 2 - 1, 0); \n\n    n = 1LL << 64 - __builtin_clzll(v.size());\n    for (ll i = 0; i < v.size(); i++)\n      node[i + n - 1] = v[i]; //最下段から構築\n    for (ll i = n - 2; i >= 0; i--)\n      node[i] = calc_parent(node[2 * i + 1], node[2 * i + 2]);\n  }\n  \n  // k 番目のノードについて遅延評価を行う\n  void eval(int k, int l, int r){ \n    // 遅延配列が空でない場合、自ノード及び子ノードへの\n    // 値の伝播が起こる\n    if (islazy[k]){\n      lazy_to_node(node[k],lazy[k]);\n      // 最下段かどうかのチェック\n      if (r - l > 1){\n        calc_lazychild(lazy[2 * k + 1],lazy[k]);\n        calc_lazychild(lazy[2 * k + 2],lazy[k]);\n        islazy[2 * k + 1] = 1;\n        islazy[2 * k + 2] = 1;\n      }\n      // 伝播が終わったので、自ノードの遅延配列を空にする\n      islazy[k] = 0;\n      lazy[k] = unit;\n    }\n  }\n\n  void update(int a, int b, ll x, int k = 0, int l = 0, int r = -1){\n    if (r < 0)\n      r = n;\n    // k 番目のノードに対して遅延評価を行う\n    eval(k, l, r);\n    // 範囲外なら何もしない\n    if (b <= l || r <= a)\n      return;\n    // 完全に被覆しているならば、遅延配列に値を入れた後に評価\n    if (a <= l && r <= b){\n      intolazy(lazy[k],x,r,l);\n      islazy[k] = 1;\n      eval(k, l, r);\n    }\n    // そうでないならば、子ノードの値を再帰的に計算して、\n    // 計算済みの値をもらってくる\n    else{\n      update(a, b, x, 2 * k + 1, l, (l + r) / 2);\n      update(a, b, x, 2 * k + 2, (l + r) / 2, r);\n      node[k] = calc_parent(node[2 * k + 1] , node[2 * k + 2]);\n    }\n  }\n\n  // 要求区間 [a, b) 中の要素の最小値を答える k := 自分がいるノードのインデックス 対象区間は [l, r) にあたる\n  ll get(ll a, ll b, ll k = 0, ll l = 0, ll r = -1)\n  {\n    // 最初に呼び出されたときの対象区間は [0, n)\n    if (r < 0)\n      r = n;\n    // 要求区間と対象区間が交わらない -> 適当に返す\n    if (r <= a || b <= l)\n      return unit;\n    // 要求区間が対象区間を完全に被覆 -> 対象区間を答えの計算に使う\n    // 関数が呼び出されたら評価！\n    eval(k, l, r);\n    if (a <= l && r <= b)\n      return node[k];\n    // 要求区間が対象区間の一部を被覆 -> 子について探索を行う\n    // 左側の子を vl ・ 右側の子を vr としている\n    // 新しい対象区間は、現在の対象区間を半分に割ったもの\n    ll vl = get(a, b, 2 * k + 1, l, (l + r) / 2);\n    ll vr = get(a, b, 2 * k + 2, (l + r) / 2, r);\n    return calc_parent(vl, vr);\n  }\n};\n\nint main()\n{\nll n , q ;\ncin >> n >> q ;\n\nvector<ll> t(n,0);\nLazySegTree s(t);\nvector<ll> ans;\nrep(i,q){\n  ll a  ;\n  cin >> a  ;\n  if(!a){\n    ll b , c , d ;\n    cin >> b >> c >> d ;\n    s.update(b, c+1, d);\n  }\n  else {\n    ll b ,c;\n    cin >> b >>c;\n    ans.push_back(s.get(b, c+1));\n  }\n}\n\nrep(i,ans.size())cout<<ans[i]<<\"\\n\";\n\nreturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <functional>\nusing namespace std;\n\ntemplate<typename Monoid, typename OpMonoid = Monoid>\nclass LazySegmentTree{\nprivate:\n    using F = function<Monoid(Monoid, Monoid)>;\n    using G = function<Monoid(Monoid,OpMonoid)>;\n    using H = function<OpMonoid(OpMonoid,OpMonoid)>;\n    using P = function<OpMonoid(OpMonoid,int)>;\n    int sz;\n    vector<Monoid> data;\n    vector<OpMonoid> lazy;\n    const F func;\n    const G op;\n    const H mergeOp;\n    const P multmergeOp;\n    const Monoid e;\n    const OpMonoid op_e;\npublic:\n    LazySegmentTree(int n, const F f, const G g, const H h, const P p,\n    const Monoid &e, const OpMonoid op_e)\n    :func(f), op(g), mergeOp(h), multmergeOp(p), e(e), op_e(op_e){\n        sz = 1;\n        while(sz<n) sz <<= 1;\n        data.assign(2*sz,e);\n        lazy.assign(2*sz,op_e);\n    }\n    //初期化\n    void set(int k, const Monoid &x){\n        data[k+sz] = x;\n    }\n    //前計算\n    void build(){\n        for(int k=sz-1;k>0;k--){\n            data[k] = func(data[2*k],data[2*k+1]);\n        }\n    }\n    //kの子に長さlenの遅延を伝搬\n    void propagate(int k, int len){\n        if(lazy[k]!=op_e){\n            if(k<sz){\n                //遅延を下の段に伝搬、結果を分割する\n                lazy[2*k] = mergeOp(lazy[2*k],lazy[k]);\n                lazy[2*k+1] = mergeOp(lazy[2*k+1],lazy[k]);\n            }\n            data[k] = op(data[k],multmergeOp(lazy[k],len));\n            lazy[k] = op_e;\n        }\n    }\n    //更新\n    Monoid update(int a, int b, const OpMonoid &x, int k, int l, int r){\n        propagate(k,r-l);\n        if(r<=a || b<=l) return data[k];\n        else if(a<=l && r<=b){\n            lazy[k] = mergeOp(lazy[k],x);\n            propagate(k,r-l);\n            return data[k];\n        }else{\n            return data[k] = func(update(a,b,x,2*k,l,(l+r)>>1),update(a,b,x,2*k+1,(l+r)>>1,r));\n        }\n    }\n    Monoid update(int a, int b, const OpMonoid &x){\n        return update(a,b,x,1,0,sz);\n    }\n    //クエリ回答\n    Monoid query(int a, int b, int k, int l, int r){\n        propagate(k,r-l);\n        if(r<=a || b<=l){\n            return e;\n        }else if(a<=l && r<=b){\n            return data[k];\n        }else{\n            return func(query(a,b,2*k,l,(l+r)>>1),query(a,b,2*k+1,(l+r)>>1,r));\n        }\n    }\n    Monoid query(int a, int b){\n        return query(a,b,1,0,sz);\n    }\n    Monoid operator[](const int &k){\n        return query(k,k+1);\n    }\n};\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint main(){\n    int N,Q;\n    cin >> N >> Q;\n    auto func = [](P a, P b){return P(a.first+b.first,a.second+b.second);};\n    auto op = [](P a, ll b){return P(a.second*b,a.second);};\n    auto merge = [](ll a, ll b){return b!=INT_MAX? b:a;};\n    auto multmergeop = [](ll a, int b){return a;};\n    LazySegmentTree<P,ll>\n    seg(N,func,op,merge,multmergeop,P(0,0),INT_MAX);\n    for(int i=0;i<N;i++) seg.set(i,P(0,1));\n    seg.build();\n    for(int i=0;i<Q;i++){\n        ll c,s,t,x;\n        cin >> c;\n        if(c==0){\n            cin >> s >> t >> x;\n            seg.update(s,t+1,x);\n        }else{\n            cin >> s >> t;\n            cout << seg.query(s,t+1).first << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\ntemplate<typename T, typename E> struct LazySegmentTree;\n\ntemplate<typename T, typename E> struct QueryObject {\n  LazySegmentTree<T, E> *lst;\n  int a, b;\n  E x;\n  int k;\n  int l, r;\n  QueryObject(LazySegmentTree<T, E> *lst,\n      int a, int b, E x = 0, int k = 0, int l = 0, int r = -1)\n      : lst(lst), a(a), b(b), x(x), k(k), l(l), r(r) {}\n};\n\ntemplate<typename T, typename E> struct QueryType {\n  virtual int outOfRange(QueryObject<T, E> o) = 0;\n  virtual int cover(QueryObject<T, E> o) = 0;\n  virtual int join(QueryObject<T, E> o, T vl, T vr) = 0;\n  T query(QueryObject<T, E> o) {\n    if (o.r < 0) o.r = o.lst->n;\n    o.lst->eval(o.r - o.l, o.k);\n    if (o.b <= o.l || o.r <= o.a) return outOfRange(o);\n    if (o.a <= o.l && o.r <= o.b) return cover(o);\n    QueryObject<T, E> o1 = o, o2 = o;\n    o1.k = o.k * 2 + 1; o1.r = (o.l + o.r) / 2;\n    o2.k = o.k * 2 + 2; o2.l = (o.l + o.r) / 2;\n    T vl = query(o1);\n    T vr = query(o2);\n    return join(o, vl, vr);\n  }\n};\n\ntemplate<typename T, typename E> struct Setter : QueryType<T, E> {\n  enum setter { RUQ, RAQ };\n  int outOfRange(QueryObject<T, E> o) {\n    return o.lst->data[o.k];\n  }\n  int cover(QueryObject<T, E> o) {\n    o.lst->lazy[o.k] = o.lst->h(o.lst->lazy[o.k], o.x);\n    o.lst->eval(o.r - o.l, o.k);\n    return o.lst->data[o.k];\n  }\n  int join(QueryObject<T, E> o, T vl, T vr) {\n    return o.lst->data[o.k] = o.lst->f(vl, vr);\n  }\n};\n\ntemplate<typename T, typename E> struct Getter : QueryType<T, E> {\n  enum getter { RMQ, RSQ };\n  int outOfRange(QueryObject<T, E> o) {\n    return o.lst->initT;\n  }\n  int cover(QueryObject<T, E> o) {\n    return o.lst->data[o.k];\n  }\n  int join(QueryObject<T, E> o, T vl, T vr) {\n    return o.lst->f(vl, vr);\n  }\n};\n\ntemplate<typename T, typename E> struct LazySegmentTree {\n  using F = function<T(T, T)>;\n  using G = function<T(T, E)>;\n  using H = function<E(E, E)>;\n  using P = function<E(E, int)>;\n\n  F add() {\n    return [&](const T& x, const T& y) -> const T { return x + y; };\n  }\n  F minimum() {\n    return [&](const T& x, const T& y) -> const T { return min(x, y); };\n  }\n  G ex_assign(E initE) {\n    return [&initE](const T& x, const E& y) -> const T { return (y == initE) ? x : y; };\n  }\n  P ex_multiplies(E initE) {\n    return [&initE](const E& x, int y) -> const E { return (x == initE) ? x : x * y; };\n  }\n\n  int n;\n  T initT;\n  E initE;\n  F f;\n  G g;\n  H h;\n  P p;\n  vector<T> data;\n  vector<E> lazy;\n  QueryType<T, E> *type;\n\n  LazySegmentTree() {}\n  LazySegmentTree(QueryType<T, E> *type_) { type = type_; }\n  LazySegmentTree(int n_, int setter, int getter,\n      T initT_ = INT_MAX, E initE_ = INT_MAX, vector<T> v = vector<T>()) {\n    setQuery(setter, getter, initT_, initE_);\n    n = 1;\n    while (n < n_) n *= 2;\n    data.assign(n * 2 - 1, initT);\n    lazy.assign(n * 2 - 1, initE);\n    if (n_ == v.size()) build(v);\n  }\n  void build(vector<T> v) {\n    for (int i = 0; i < v.size(); ++i) data[i + n - 1] = v[i];\n    for (int i = n - 2; i >= 0; --i) {\n      data[i] = f(data[i * 2 + 1], data[i * 2 + 2]);\n    }\n  }\n  void setQuery(int setter, int getter, T initT_, E initE_) {\n    initT = vector<T>{initT_, 0}[getter];\n    initE = vector<E>{initE_, 0}[setter];\n    f = vector<F>{minimum(), add()}[getter];\n    g = vector<G>{ex_assign(initE), add()}[setter];\n    h = vector<H>{ex_assign(initE), add()}[setter];\n    p = ex_multiplies(initE);\n  }\n  inline void eval(int len, int k) {\n    if (lazy[k] == initE) return;\n    if (k * 2 + 1 < n * 2 - 1) {\n      lazy[k * 2 + 1] = h(lazy[k * 2 + 1], lazy[k]);\n      lazy[k * 2 + 2] = h(lazy[k * 2 + 2], lazy[k]);\n    }\n    data[k] = g(data[k], p(lazy[k], len));\n    lazy[k] = initE;\n  }\n  T query(QueryObject<T, E>& obj) {\n    return type->query(obj);\n  }\n  T setData(int a, int b, E x) {\n    LazySegmentTree<T, E> lst(new Setter<T, E>());\n    QueryObject<T, E> obj(this, a, b, x);\n    return lst.query(obj);\n  }\n  T getData(int a, int b) {\n    LazySegmentTree<T, E> lst(new Getter<T, E>());\n    QueryObject<T, E> obj(this, a, b);\n    return lst.query(obj);\n  }\n};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, q; cin >> n >> q;\n  LazySegmentTree<ll, ll> seg(n, Setter<ll, ll>::RUQ, Getter<ll, ll>::RSQ, 0, 1e9);\n\n  while (q--) {\n    int com; cin >> com;\n    if (com) {\n      int s, t; cin >> s >> t;\n      cout << seg.getData(s, t + 1) << endl;\n    } else {\n      int s, t, x; cin >> s >> t >> x;\n      seg.setData(s, t + 1, x);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\ntemplate<typename T, typename E> struct LazySegmentTree;\n\ntemplate<typename T, typename E> struct QueryObject {\n  LazySegmentTree<T, E> *lst;\n  int a, b;\n  E x;\n  int k;\n  int l, r;\n  QueryObject(LazySegmentTree<T, E> *lst_,\n      int a, int b, E x = 0, int k = 0, int l = 0, int r = -1)\n      : a(a), b(b), x(x), k(k), l(l), r(r) {\n    lst = lst_;\n  }\n};\n\ntemplate<typename T, typename E> struct QueryType {\n  virtual T outOfRange(QueryObject<T, E>& o) = 0;\n  virtual T cover(QueryObject<T, E>& o) = 0;\n  virtual T join(QueryObject<T, E>& o, T vl, T vr) = 0;\n  T query(QueryObject<T, E> o) {\n    if (o.r < 0) o.r = o.lst->n;\n    o.lst->eval(o.r - o.l, o.k);\n    if (o.b <= o.l || o.r <= o.a) return outOfRange(o);\n    if (o.a <= o.l && o.r <= o.b) return cover(o);\n    QueryObject<T, E> o1 = o, o2 = o;\n    o1.k = o.k * 2 + 1; o1.r = (o.l + o.r) / 2;\n    o2.k = o.k * 2 + 2; o2.l = (o.l + o.r) / 2;\n    T vl = query(o1);\n    T vr = query(o2);\n    return join(o, vl, vr);\n  }\n};\n\ntemplate<typename T, typename E> struct Setter : QueryType<T, E> {\n  enum setter { RUQ, RAQ };\n  T outOfRange(QueryObject<T, E>& o) {\n    return o.lst->data[o.k];\n  }\n  T cover(QueryObject<T, E>& o) {\n    o.lst->lazy[o.k] = o.lst->h(o.lst->lazy[o.k], o.x);\n    o.lst->eval(o.r - o.l, o.k);\n    return o.lst->data[o.k];\n  }\n  T join(QueryObject<T, E>& o, T vl, T vr) {\n    return o.lst->data[o.k] = o.lst->f(vl, vr);\n  }\n};\n\ntemplate<typename T, typename E> struct Getter : QueryType<T, E> {\n  enum getter { RMQ, RSQ };\n  T outOfRange(QueryObject<T, E>& o) {\n    return o.lst->initT;\n  }\n  T cover(QueryObject<T, E>& o) {\n    return o.lst->data[o.k];\n  }\n  T join(QueryObject<T, E>& o, T vl, T vr) {\n    return o.lst->f(vl, vr);\n  }\n};\n\ntemplate<typename T, typename E> struct LazySegmentTree {\n  using F = function<T(T, T)>;\n  using G = function<T(T, E)>;\n  using H = function<E(E, E)>;\n  using P = function<E(E, int)>;\n\n  F add() {\n    return [&](const T& x, const T& y) -> const T { return x + y; };\n  }\n  F minimum() {\n    return [&](const T& x, const T& y) -> const T { return min(x, y); };\n  }\n  G ex_assign(E initE) {\n    return [&initE](const T& x, const E& y) -> const T { return (y == initE) ? x : y; };\n  }\n  P ex_multiplies(E initE) {\n    return [&initE](const E& x, int y) -> const E { return (x == initE) ? x : x * y; };\n  }\n\n  int n;\n  T initT;\n  E initE;\n  F f;\n  G g;\n  H h;\n  P p;\n  vector<T> data;\n  vector<E> lazy;\n  QueryType<T, E> *type;\n\n  LazySegmentTree() {}\n  LazySegmentTree(QueryType<T, E> *type_) { type = type_; }\n  LazySegmentTree(int n_, int setter, int getter,\n      T initT_ = INT_MAX, E initE_ = INT_MAX, vector<T> v = vector<T>()) {\n    setQuery(setter, getter, initT_, initE_);\n    n = 1;\n    while (n < n_) n *= 2;\n    data.assign(n * 2 - 1, initT);\n    lazy.assign(n * 2 - 1, initE);\n    if (n_ == v.size()) build(v);\n  }\n  void build(vector<T> v) {\n    for (int i = 0; i < v.size(); ++i) data[i + n - 1] = v[i];\n    for (int i = n - 2; i >= 0; --i) {\n      data[i] = f(data[i * 2 + 1], data[i * 2 + 2]);\n    }\n  }\n  void setQuery(int setter, int getter, T initT_, E initE_) {\n    initT = vector<T>{initT_, 0}[getter];\n    initE = vector<E>{initE_, 0}[setter];\n    f = vector<F>{minimum(), add()}[getter];\n    g = vector<G>{ex_assign(initE), add()}[setter];\n    h = vector<H>{ex_assign(initE), add()}[setter];\n    p = ex_multiplies(initE);\n  }\n  inline void eval(int len, int k) {\n    if (lazy[k] == initE) return;\n    if (k * 2 + 1 < n * 2 - 1) {\n      lazy[k * 2 + 1] = h(lazy[k * 2 + 1], lazy[k]);\n      lazy[k * 2 + 2] = h(lazy[k * 2 + 2], lazy[k]);\n    }\n    data[k] = g(data[k], p(lazy[k], len));\n    lazy[k] = initE;\n  }\n  T query(QueryObject<T, E>& obj) {\n    return type->query(obj);\n  }\n  T setData(int a, int b, E x) {\n    LazySegmentTree<T, E> lst(new Setter<T, E>());\n    QueryObject<T, E> obj(this, a, b, x);\n    return lst.query(obj);\n  }\n  T getData(int a, int b) {\n    LazySegmentTree<T, E> lst(new Getter<T, E>());\n    QueryObject<T, E> obj(this, a, b);\n    return lst.query(obj);\n  }\n};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, q; cin >> n >> q;\n  LazySegmentTree<ll, ll> seg(n, Setter<ll, ll>::RUQ, Getter<ll, ll>::RSQ);\n\n  while (q--) {\n    int com; cin >> com;\n    if (com) {\n      int s, t; cin >> s >> t;\n      cout << seg.getData(s, t + 1) << endl;\n    } else {\n      int s, t, x; cin >> s >> t >> x;\n      seg.setData(s, t + 1, x);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * \n */\n\n// header {{{\n#include <bits/stdc++.h>\nusing namespace std;\n\n// C++17 polyfill {{{\ntemplate<bool B>\nusing BoolConstant = integral_constant<bool, B>;\n// }}}\n\n// C++20 polyfill {{{\nstruct IDENTITY {\n    using is_transparent = void;\n    template<typename T>\n    constexpr T&& operator()(T&& x) const noexcept {\n        return forward<T>(x);\n    }\n};\n// }}}\n\n#define CPP_STR(x) CPP_STR_I(x)\n#define CPP_CAT(x,y) CPP_CAT_I(x,y)\n#define CPP_STR_I(args...) #args\n#define CPP_CAT_I(x,y) x ## y\n\n#define SFINAE(pred...) std::enable_if_t<(pred), std::nullptr_t> = nullptr\n\n#define ASSERT(expr...) assert((expr))\n\nusing i8   = int8_t;\nusing u8   = uint8_t;\nusing i16  = int16_t;\nusing u16  = uint16_t;\nusing i32  = int32_t;\nusing u32  = uint32_t;\nusing i64  = int64_t;\nusing u64  = uint64_t;\n#ifdef __SIZEOF_INT128__\nusing i128 = __int128;\nusing u128 = unsigned __int128;\n#endif\n\nusing f32  = float;\nusing f64  = double;\nusing f80  = __float80;\nusing f128 = __float128;\n\nusing complex32 = complex<f32>;\nusing complex64 = complex<f64>;\nusing complex80 = complex<f80>;\n// }}}\n\ntemplate<typename T> constexpr T PROCON_INF();\ntemplate<> constexpr i64 PROCON_INF<i64>() { return 1'010'000'000'000'000'017LL; }\ntemplate<> constexpr f64 PROCON_INF<f64>() { return 1e100; }\n\nconstexpr i64 INF  = PROCON_INF<i64>();\nconstexpr f64 FINF = PROCON_INF<f64>();\n\nconstexpr i64 MOD = 1'000'000'007LL;\n\nconstexpr f64 EPS = 1e-12;\n\nconstexpr f64 PI = 3.14159265358979323846;\n\n// util {{{\n#define FOR(i, start, end) for(i64 i = (start), CPP_CAT(i,xxxx_end)=(end); i < CPP_CAT(i,xxxx_end); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,c,...) (([&](decltype((c)) cccc) { return (f)(std::begin(cccc), std::end(cccc), ## __VA_ARGS__); })(c))\n#define SLICE(f,c,l,r,...) (([&](decltype((c)) cccc, decltype((l)) llll, decltype((r)) rrrr) {\\\n    auto iiii = llll <= rrrr ? std::begin(cccc)+llll : std::end(cccc);\\\n    auto jjjj = llll <= rrrr ? std::begin(cccc)+rrrr : std::end(cccc);\\\n    return (f)(iiii, jjjj, ## __VA_ARGS__);\\\n})(c,l,r))\n\n#define GENERIC(f) ([](auto&&... args) -> decltype(auto) { return (f)(std::forward<decltype(args)>(args)...); })\n\n// ビット演算 {{{\n// 引数は [-INF,INF] のみ想定\n\ni64 BIT_I(i64 i) {\n    return 1LL << i;\n}\n\ni64 BIT_I_1(i64 i) {\n    return BIT_I(i) - 1;\n}\n\ni64 BIT_GET(i64 x, i64 i) {\n    return x & BIT_I(i);\n}\n\nbool BIT_TEST(i64 x, i64 i) {\n    return BIT_GET(x,i) != 0;\n}\n\ni64 BIT_SET(i64 x, i64 i) {\n    return x | BIT_I(i);\n}\n\ni64 BIT_CLEAR(i64 x, i64 i) {\n    return x & ~BIT_I(i);\n}\n\ni64 BIT_FLIP(i64 x, i64 i) {\n    return x ^ BIT_I(i);\n}\n\ni64 BIT_ASSIGN(i64 x, i64 i, bool b) {\n    return b ? BIT_SET(x,i) : BIT_CLEAR(x,i);\n}\n\ni64 BIT_COUNT_LEADING_ZEROS(i64 x) {\n    if(x == 0) return 64;\n    return __builtin_clzll(x);\n}\n\ni64 BIT_COUNT_LEADING_ONES(i64 x) {\n    return BIT_COUNT_LEADING_ZEROS(~x);\n}\n\ni64 BIT_COUNT_TRAILING_ZEROS(i64 x) {\n    if(x == 0) return 64;\n    return __builtin_ctzll(x);\n}\n\ni64 BIT_COUNT_TRAILING_ONES(i64 x) {\n    return BIT_COUNT_TRAILING_ZEROS(~x);\n}\n\n// 末尾へ続く0を識別するマスクを返す (ex. 0b10100 -> 0b00011)\n// x=0 なら -1 を返す\ni64 BIT_MASK_TRAILING_ZEROS(i64 x) {\n    return ~x & (x-1);\n}\n\n// 末尾へ続く1を識別するマスクを返す (ex. 0b10011 -> 0b00011)\n// x=-1 なら -1 を返す\ni64 BIT_MASK_TRAILING_ONES(i64 x) {\n    return x & ~(x+1);\n}\n\ni64 BIT_COUNT_ONES(i64 x) {\n    return __builtin_popcountll(x);\n}\n\ni64 BIT_COUNT_ZEROS(i64 x) {\n    return 64 - BIT_COUNT_ONES(x);\n}\n\n// 先頭から続く冗長な符号ビットを数える (ex. 1 -> 62, -1 -> 63)\ni64 BIT_COUNT_LEADING_REDUNDANT_SIGN_BITS(i64 x) {\n    return __builtin_clrsbll(x);\n}\n\n// 1の個数が奇数なら1, 偶数なら0を返す\ni64 BIT_PARITY(i64 x) {\n    return __builtin_parityll(x);\n}\n\n// 最右の0を分離する (ex. 0b11001 -> 0b00010)\n// x=-1 なら 0 を返す\ni64 BIT_EXTRACT_FIRST_ZERO(i64 x) {\n    return ~x & (x+1);\n}\n\n// 最右の1を分離する (ex. 0b10110 -> 0b00010)\n// x=0 なら 0 を返す\ni64 BIT_EXTRACT_FIRST_ONE(i64 x) {\n    return x & (-x);\n}\n\n// 最右の0を1にする (ex. 0b11001 -> 0b11011)\ni64 BIT_FLIP_FIRST_ZERO(i64 x) {\n    return x | (x+1);\n}\n\n// 最右の1を0にする (ex. 0b10110 -> 0b10100)\ni64 BIT_FLIP_FIRST_ONE(i64 x) {\n    return x & (x-1);\n}\n\n// 最右の1の位置(1-based)を得る\n// x=0 なら 0 を返す\ni64 BIT_FIND_FIRST_ONE(i64 x) {\n    return __builtin_ffsll(x);\n}\n\n// 最右の0の位置(1-based)を得る\n// x=-1 なら 0 を返す\ni64 BIT_FIND_FIRST_ZERO(i64 x) {\n    return BIT_FIND_FIRST_ONE(~x);\n}\n\n// 最右の0をそれより右に伝播する (ex. 0b11011 -> 0b11000)\n// x=-1 なら -1 を返す\ni64 BIT_PROPAGATE_FIRST_ZERO(i64 x) {\n    if(x == -1) return -1;\n    return x & (x+1);\n}\n\n// 最右の1をそれより右に伝播する (ex. 0b10100 -> 0b10111)\n// x=0 なら 0 を返す\ni64 BIT_PROPAGATE_FIRST_ONE(i64 x) {\n    if(x == 0) return 0;\n    return x | (x-1);\n}\n\n// 最右の0および末尾へ続く1を識別するマスクを返す (ex. 0b11011 -> 0b00111)\n// x=-1 なら 0 を返す\ni64 BIT_MASKTO_FIRST_ZERO(i64 x) {\n    if(x == -1) return 0;\n    return x ^ (x+1);\n}\n\n// 最右の1および末尾へ続く0を識別するマスクを返す (ex. 0b10100 -> 0b00111)\n// x=0 なら 0 を返す\ni64 BIT_MASKTO_FIRST_ONE(i64 x) {\n    if(x == 0) return 0;\n    return x ^ (x-1);\n}\n\n// 最右の連続した0を1にする (ex. 0b101001 -> 0b101111)\n// x=-1 なら -1 を返す\ni64 BIT_FLIP_FIRST_ZEROS(i64 x) {\n    return ((x&(x+1))-1) | x;\n}\n\n// 最右の連続した1を0にする (ex. 0b10110 -> 0b10000)\n// x=0 なら 0 を返す\ni64 BIT_FLIP_FIRST_ONES(i64 x) {\n    return ((x|(x-1))+1) & x;\n}\n\n// X ⊆ {0,1,...,n-1}, |X| = k なる部分集合 X を昇順に列挙する\n// comb(n,k) 個\n//\n// ex.\n// ```\n// i64 x = BIT_I_1(3);\n// do {\n//     // ...\n// } while(BIT_NEXT_SET_SIZED(x, 10));\n// ```\nbool BIT_NEXT_SET_SIZED(i64& x, i64 n) {\n    if(x == 0) return false;\n    i64 t = BIT_PROPAGATE_FIRST_ONE(x) + 1;\n    x = t | (BIT_MASK_TRAILING_ZEROS(t) >> (BIT_COUNT_TRAILING_ZEROS(x)+1));\n    return x < BIT_I(n);\n}\n\n// 集合 Y の部分集合 X を昇順に列挙する\n// 2^|Y| 個\n//\n// ex.\n// ```\n// i64 y = 0b10101;\n// i64 x = 0;\n// do {\n//     // ...\n// } while(BIT_NEXT_SUBSET(x, y));\n// ```\nbool BIT_NEXT_SUBSET(i64& x, i64 y) {\n    if(x == y) return false;\n    x = (x-y) & y;\n    return true;\n}\n\n// 集合 Y の部分集合 X を降順に列挙する\n// 2^|Y| 個\n//\n// ex.\n// ```\n// i64 y = 0b10101;\n// i64 x = y;\n// do {\n//     // ...\n// } while(BIT_PREV_SUBSET(x, y));\n// ```\nbool BIT_PREV_SUBSET(i64& x, i64 y) {\n    if(x == 0) return false;\n    x = (x-1) & y;\n    return true;\n}\n\n// 集合 Y を包含する集合 X ⊆ {0,1,...,n-1} を昇順に列挙する\n// 2^(n-|Y|) 個\n//\n// ex.\n// ```\n// i64 y = 0b00010101;\n// i64 x = y;\n// do {\n//     // ...\n// } while(BIT_NEXT_SUPERSET(x, 8, y));\n// ```\nbool BIT_NEXT_SUPERSET(i64& x, i64 n, i64 y) {\n    x = (x+1) | y;\n    return x < BIT_I(n);\n}\n// }}}\n\ntemplate<typename T1, typename T2, typename Comp=less<>,\n         SFINAE(\n             is_integral<T1>::value &&\n             is_integral<T2>::value &&\n             is_signed<T1>::value != is_unsigned<T2>::value\n         )>\ncommon_type_t<T1,T2> MAX(T1 x, T2 y, Comp comp={}) {\n    return max<common_type_t<T1,T2>>(x, y, comp);\n}\n\ntemplate<typename T1, typename T2, typename Comp=less<>,\n         SFINAE(\n             is_floating_point<T1>::value &&\n             is_floating_point<T2>::value\n         )>\ncommon_type_t<T1,T2> MAX(T1 x, T2 y, Comp comp={}) {\n    return max<common_type_t<T1,T2>>(x, y, comp);\n}\n\ntemplate<typename T, typename Comp=less<>>\nconst T& MAX(const T& x, const T& y, Comp comp={}) {\n    return max(x, y, comp);\n}\n\ntemplate<typename T, typename Comp=less<>>\nT MAX(initializer_list<T> ilist, Comp comp={}) {\n    return max(ilist, comp);\n}\n\ntemplate<typename T1, typename T2, typename Comp=less<>,\n         SFINAE(\n             is_integral<T1>::value &&\n             is_integral<T2>::value &&\n             is_signed<T1>::value != is_unsigned<T2>::value\n         )>\ncommon_type_t<T1,T2> MIN(T1 x, T2 y, Comp comp={}) {\n    return min<common_type_t<T1,T2>>(x, y, comp);\n}\n\ntemplate<typename T1, typename T2, typename Comp=less<>,\n         SFINAE(\n             is_floating_point<T1>::value &&\n             is_floating_point<T2>::value\n         )>\ncommon_type_t<T1,T2> MIN(T1 x, T2 y, Comp comp={}) {\n    return min<common_type_t<T1,T2>>(x, y, comp);\n}\n\ntemplate<typename T, typename Comp=less<>>\nconst T& MIN(const T& x, const T& y, Comp comp={}) {\n    return min(x, y, comp);\n}\n\ntemplate<typename T, typename Comp=less<>>\nT MIN(initializer_list<T> ilist, Comp comp={}) {\n    return min(ilist, comp);\n}\n\ntemplate<typename T>\nT ABS(T x) {\n    static_assert(is_signed<T>::value, \"ABS(): argument must be signed\");\n    return x < 0 ? -x : x;\n}\n\nf64 ROUND(f64 x) {\n    return round(x);\n}\n\ni64 IROUND(f64 x) {\n    return llround(x);\n}\n\ntemplate<typename C>\ni64 SIZE(const C& c) { return static_cast<i64>(c.size()); }\n\ntemplate<typename T, size_t N>\ni64 SIZE(const T (&)[N]) { return static_cast<i64>(N); }\n\nbool is_odd (i64 x) { return x % 2 != 0; }\nbool is_even(i64 x) { return x % 2 == 0; }\n\ntemplate<typename T> i64 cmp(T x, T y) { return (y<x) - (x<y); }\ntemplate<typename T> i64 sgn(T x) { return cmp(x, T(0)); }\n\n// 事前条件: a >= 0, b >= 0\ni64 gcd_impl(i64 a, i64 b) {\n    if(b == 0) return a;\n    return gcd_impl(b, a%b);\n}\n\n// GCD(0,0) = 0\ni64 GCD(i64 a, i64 b) {\n    return gcd_impl(ABS(a), ABS(b));\n}\n\n// LCM(0,x) は未定義\ni64 LCM(i64 a, i64 b) {\n    ASSERT(a != 0 && b != 0);\n    a = ABS(a);\n    b = ABS(b);\n    return a / gcd_impl(a,b) * b;\n}\n\n// lo:OK, hi:NG\ntemplate<typename Pred>\ni64 bisect_integer(i64 lo, i64 hi, Pred pred) {\n    ASSERT(lo < hi);\n\n    while(lo+1 < hi) {\n        i64 mid = (lo+hi) / 2;\n        if(pred(mid))\n            lo = mid;\n        else\n            hi = mid;\n    }\n    return lo;\n}\n\ntemplate<typename Pred>\nf64 bisect_real(f64 lo, f64 hi, Pred pred, i64 iter=100) {\n    ASSERT(lo < hi);\n\n    REP(_, iter) {\n        f64 mid = (lo+hi) / 2;\n        if(pred(mid))\n            lo = mid;\n        else\n            hi = mid;\n    }\n    return lo;\n}\n\ni64 ipow(i64 x, i64 e) {\n    ASSERT(e >= 0);\n    i64 res = 1;\n    REP(_, e) {\n        res *= x;\n    }\n    return res;\n}\n\ni64 sqrt_floor(i64 x) {\n    ASSERT(x >= 0);\n\n    i64 lo = 0;\n    i64 hi = MIN(x/2+2, 3037000500LL);\n    return bisect_integer(lo, hi, [x](i64 r) { return r*r <= x; });\n}\n\ni64 sqrt_ceil(i64 x) {\n    i64 r = sqrt_floor(x);\n    return r*r == x ? r : r+1;\n}\n\n// 0 <= log2_ceil(x) <= 63\ni64 log2_ceil(i64 x) {\n    ASSERT(x > 0);\n    return 64 - BIT_COUNT_LEADING_ZEROS(x-1);\n}\n\n// 0 <= log2_floor(x) <= 62\ni64 log2_floor(i64 x) {\n    ASSERT(x > 0);\n    return 63 - BIT_COUNT_LEADING_ZEROS(x);\n}\n\n// 2^n - 1 の形かどうか\nbool is_mersenne(i64 x) {\n    ASSERT(x >= 0);\n    return (x&(x+1)) == 0;\n}\n\nbool is_pow2(i64 x) {\n    ASSERT(x > 0);\n    return (x&(x-1)) == 0;\n}\n\n// x > 0\ni64 pow2_ceil(i64 x) {\n    return BIT_I(log2_ceil(x));\n}\n\n// x > 0\ni64 pow2_floor(i64 x) {\n    return BIT_I(log2_floor(x));\n}\n\n// Haskell の divMod と同じ\npair<i64,i64> divmod(i64 a, i64 b) {\n    i64 q = a / b;\n    i64 r = a % b;\n    if((b>0 && r<0) || (b<0 && r>0)) {\n        --q;\n        r += b;\n    }\n    return {q,r};\n}\n\ni64 div_ceil(i64 a, i64 b) {\n    i64 q = a / b;\n    i64 r = a % b;\n    if((b>0 && r>0) || (b<0 && r<0))\n        ++q;\n    return q;\n}\n\ni64 div_floor(i64 a, i64 b) {\n    return divmod(a,b).first;\n}\n\ni64 modulo(i64 a, i64 b) {\n    return divmod(a,b).second;\n}\n\n// x を align の倍数に切り上げる\ni64 align_ceil(i64 x, i64 align) {\n    ASSERT(align > 0);\n    return div_ceil(x,align) * align;\n}\n\n// x を align の倍数に切り下げる\ni64 align_floor(i64 x, i64 align) {\n    ASSERT(align > 0);\n    return div_floor(x,align) * align;\n}\n\nbool feq(f64 x, f64 y, f64 eps=EPS) {\n    return fabs(x-y) < eps;\n}\n\ntemplate<typename T, typename U, typename Comp=less<>>\nbool chmax(T& xmax, const U& x, Comp comp={}) {\n    if(comp(xmax, x)) {\n        xmax = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T, typename U, typename Comp=less<>>\nbool chmin(T& xmin, const U& x, Comp comp={}) {\n    if(comp(x, xmin)) {\n        xmin = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename Pred>\ni64 arg_find(i64 lo, i64 hi, Pred pred) {\n    ASSERT(lo < hi);\n\n    FOR(x, lo, hi) {\n        if(pred(x)) return x;\n    }\n    return INF;\n}\n\ntemplate<typename F>\ni64 arg_max(i64 lo, i64 hi, F f) {\n    ASSERT(lo < hi);\n\n    i64 res = lo;\n    auto ymax = f(lo);\n    FOR(x, lo+1, hi) {\n        if(chmax(ymax, f(x)))\n            res = x;\n    }\n    return res;\n}\n\ntemplate<typename F>\ni64 arg_min(i64 lo, i64 hi, F f) {\n    ASSERT(lo < hi);\n\n    i64 res = lo;\n    auto ymin = f(lo);\n    FOR(x, lo+1, hi) {\n        if(chmin(ymin, f(x)))\n            res = x;\n    }\n    return res;\n}\n\ntemplate<typename Pred>\ni64 arg_find_r(i64 lo, i64 hi, Pred pred) {\n    i64 x = arg_find(-hi+1, lo+1, [pred](i64 xx) { return pred(-xx); });\n    return x == INF ? INF : -x;\n}\n\ntemplate<typename F>\ni64 arg_max_r(i64 lo, i64 hi, F f) {\n    return -arg_max(-hi+1, lo+1, [f](i64 x) { return f(-x); });\n}\n\ntemplate<typename F>\ni64 arg_min_r(i64 lo, i64 hi, F f) {\n    return -arg_min(-hi+1, lo+1, [f](i64 x) { return f(-x); });\n}\n\ntemplate<typename ForwardIt, typename T, typename Comp=less<>>\nForwardIt bsearch_find(ForwardIt first, ForwardIt last, const T& x, Comp comp={}) {\n    auto it = lower_bound(first, last, x, comp);\n    if(it == last || comp(x,*it)) return last;\n    return it;\n}\n\n// x 未満の最後の要素\ntemplate<typename BidiIt, typename T, typename Comp=less<>>\nBidiIt bsearch_lt(BidiIt first, BidiIt last, const T& x, Comp comp={}) {\n    auto it = lower_bound(first, last, x, comp);\n    if(it == first) return last;\n    return prev(it);\n}\n\n// x 以下の最後の要素\ntemplate<typename BidiIt, typename T, typename Comp=less<>>\nBidiIt bsearch_le(BidiIt first, BidiIt last, const T& x, Comp comp={}) {\n    auto it = upper_bound(first, last, x, comp);\n    if(it == first) return last;\n    return prev(it);\n}\n\n// x より大きい最初の要素\ntemplate<typename BidiIt, typename T, typename Comp=less<>>\nBidiIt bsearch_gt(BidiIt first, BidiIt last, const T& x, Comp comp={}) {\n    return upper_bound(first, last, x, comp);\n}\n\n// x 以上の最初の要素\ntemplate<typename BidiIt, typename T, typename Comp=less<>>\nBidiIt bsearch_ge(BidiIt first, BidiIt last, const T& x, Comp comp={}) {\n    return lower_bound(first, last, x, comp);\n}\n\ntemplate<typename InputIt, typename BinaryOp>\nauto FOLD(InputIt first, InputIt last,\n          typename iterator_traits<InputIt>::value_type init,\n          BinaryOp op)\n{\n    for(; first != last; ++first)\n        init = op(move(init), *first);\n    return init;\n}\n\ntemplate<typename InputIt, typename BinaryOp>\nauto FOLD1(InputIt first, InputIt last, BinaryOp op) {\n    auto init = *first++;\n    return FOLD(first, last, init, op);\n}\n\ntemplate<typename InputIt>\nauto SUM(InputIt first, InputIt last) {\n    using T = typename iterator_traits<InputIt>::value_type;\n    return accumulate(first, last, T());\n}\n\ntemplate<typename ForwardIt, typename UnaryOperation>\nForwardIt transform_self(ForwardIt first, ForwardIt last, UnaryOperation op) {\n    return transform(first, last, first, op);\n}\n\ntemplate<typename C>\nvoid UNIQ(C& c) {\n    c.erase(ALL(unique,c), end(c));\n}\n\ntemplate<typename BinaryFunc>\nauto FLIP(BinaryFunc f) {\n    return [f](const auto& x, const auto& y) {\n        return f(y,x);\n    };\n}\n\ntemplate<typename BinaryFunc, typename UnaryFunc>\nauto ON(BinaryFunc bf, UnaryFunc uf) {\n    return [bf,uf](const auto& x, const auto& y) {\n        return bf(uf(x), uf(y));\n    };\n}\n\ntemplate<typename F>\nauto LT_ON(F f) { return ON(less<>(), f); }\n\ntemplate<typename F>\nauto GT_ON(F f) { return ON(greater<>(), f); }\n\ntemplate<typename F>\nauto EQ_ON(F f) { return ON(equal_to<>(), f); }\n\ntemplate<typename F>\nauto NE_ON(F f) { return ON(not_equal_to<>(), f); }\n\ntemplate<typename Comp=less<>>\nauto EQUIV(Comp comp={}) {\n    return [comp](const auto& lhs, const auto& rhs) {\n        return !comp(lhs,rhs) && !comp(rhs,lhs);\n    };\n}\n\ntemplate<typename ForwardIt>\nForwardIt next_bounded(ForwardIt last, ForwardIt it, i64 n=1) {\n    auto bound = distance(it, last);\n    return next(it, MIN(n, bound));\n}\n\ntemplate<typename ForwardIt>\nForwardIt prev_bounded(ForwardIt first, ForwardIt it, i64 n=1) {\n    auto bound = distance(first, it);\n    return prev(it, MIN(n, bound));\n}\n\ntemplate<typename ForwardIt>\nvoid advance_bounded(ForwardIt first, ForwardIt last, ForwardIt& it, i64 n) {\n    if(n > 0) {\n        auto bound = distance(it, last);\n        advance(it, MIN(n, bound));\n    }\n    else if(n < 0) {\n        auto bound = distance(it, first);\n        advance(it, MAX(n, bound));\n    }\n}\n\nchar digit_chr(i64 n) {\n    return static_cast<char>('0' + n);\n}\n\ni64 digit_ord(char c) {\n    return c - '0';\n}\n\nchar lower_chr(i64 n) {\n    return static_cast<char>('a' + n);\n}\n\ni64 lower_ord(char c) {\n    return c - 'a';\n}\n\nchar upper_chr(i64 n) {\n    return static_cast<char>('A' + n);\n}\n\ni64 upper_ord(char c) {\n    return c - 'A';\n}\n\n// 出力は operator<< を直接使わず、このテンプレート経由で行う\n// 提出用出力とデバッグ用出力を分けるため\ntemplate<typename T, typename Enable=void>\nstruct Formatter {\n    static ostream& write_str(ostream& out, const T& x)  { return out << x; }\n    static ostream& write_repr(ostream& out, const T& x) { return out << x; }\n};\n\ntemplate<typename T>\nostream& WRITE_STR(ostream& out, const T& x) {\n    return Formatter<T>::write_str(out, x);\n}\n\ntemplate<typename T>\nostream& WRITE_REPR(ostream& out, const T& x) {\n    return Formatter<T>::write_repr(out, x);\n}\n\ntemplate<typename InputIt>\nostream& WRITE_JOIN_STR(ostream& out, InputIt first, InputIt last, const string& sep) {\n    while(first != last) {\n        WRITE_STR(out, *first++);\n        if(first != last)\n            out << sep;\n    }\n    return out;\n}\n\ntemplate<typename InputIt>\nostream& WRITE_JOIN_REPR(ostream& out, InputIt first, InputIt last, const string& sep) {\n    while(first != last) {\n        WRITE_REPR(out, *first++);\n        if(first != last)\n            out << sep;\n    }\n    return out;\n}\n\ntemplate<typename InputIt>\nostream& WRITE_RANGE_STR(ostream& out, InputIt first, InputIt last) {\n    return WRITE_JOIN_STR(out, first, last, \" \");\n}\n\ntemplate<typename InputIt>\nostream& WRITE_RANGE_REPR(ostream& out, InputIt first, InputIt last) {\n    out << \"[\";\n    WRITE_JOIN_REPR(out, first, last, \", \");\n    out << \"]\";\n    return out;\n}\n\ntemplate<typename T>\nvoid FROM_STR(const string& s, T& x) {\n    istringstream in(s);\n    in >> x;\n}\n\ntemplate<typename T>\nstring TO_STR(const T& x) {\n    ostringstream out;\n    WRITE_STR(out, x);\n    return out.str();\n}\n\ntemplate<typename T>\nstring TO_REPR(const T& x) {\n    ostringstream out;\n    WRITE_REPR(out, x);\n    return out.str();\n}\n\ntemplate<typename InputIt>\nstring RANGE_TO_STR(InputIt first, InputIt last) {\n    ostringstream out;\n    WRITE_RANGE_STR(out, first, last);\n    return out.str();\n}\n\ntemplate<typename InputIt>\nstring RANGE_TO_REPR(InputIt first, InputIt last) {\n    ostringstream out;\n    WRITE_RANGE_REPR(out, first, last);\n    return out.str();\n}\n\ntemplate<typename InputIt>\nstring JOIN(InputIt first, InputIt last, const string& sep) {\n    ostringstream out;\n    WRITE_JOIN_STR(out, first, last, sep);\n    return out.str();\n}\n\ntemplate<>\nstruct Formatter<i64> {\n    static ostream& write_str(ostream& out, i64 x) {\n        return out << x;\n    }\n    static ostream& write_repr(ostream& out, i64 x) {\n        if(x == INF) return out << \"INF\";\n        if(x == -INF) return out << \"-INF\";\n        return out << x;\n    }\n};\n\ntemplate<>\nstruct Formatter<f64> {\n    static ostream& write_str(ostream& out, f64 x) {\n        return out << x;\n    }\n    static ostream& write_repr(ostream& out, f64 x) {\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wfloat-equal\"\n        if(x == FINF) return out << \"FINF\";\n        if(x == -FINF) return out << \"-FINF\";\n#pragma GCC diagnostic pop\n        return out << x;\n    }\n};\n\ntemplate<typename T>\nstruct Formatter<vector<T>> {\n    static ostream& write_str(ostream& out, const vector<T>& v) {\n        return WRITE_RANGE_STR(out, begin(v), end(v));\n    }\n    static ostream& write_repr(ostream& out, const vector<T>& v) {\n        out << \"vector\";\n        return WRITE_RANGE_REPR(out, begin(v), end(v));\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Formatter<pair<T1,T2>> {\n    static ostream& write_str(ostream& out, const pair<T1,T2>& p) {\n        WRITE_STR(out, p.first);\n        out << ' ';\n        WRITE_STR(out, p.second);\n        return out;\n    }\n    static ostream& write_repr(ostream& out, const pair<T1,T2>& p) {\n        out << \"(\";\n        WRITE_REPR(out, p.first);\n        out << \",\";\n        WRITE_REPR(out, p.second);\n        out << \")\";\n        return out;\n    }\n};\n\ntemplate<typename... TS>\nstruct Formatter<tuple<TS...>> {\n    template<size_t I=0, SFINAE(sizeof...(TS) == I)>\n    static ostream& write_str_impl(ostream& out, const tuple<TS...>&) {\n        return out;\n    }\n    template<size_t I=0, SFINAE(sizeof...(TS) > I)>\n    static ostream& write_str_impl(ostream& out, const tuple<TS...>& t) {\n        if(I != 0) out << ' ';\n        WRITE_STR(out, get<I>(t));\n        return write_str_impl<I+1>(out, t);\n    }\n\n    template<size_t I=0, SFINAE(sizeof...(TS) == I)>\n    static ostream& write_repr_impl(ostream& out, const tuple<TS...>&) {\n        if(sizeof...(TS) == 0) out << \"(\";\n        return out << \")\";\n    }\n    template<size_t I=0, SFINAE(sizeof...(TS) > I)>\n    static ostream& write_repr_impl(ostream& out, const tuple<TS...>& t) {\n        if(I == 0)\n            out << \"(\";\n        else\n            out << \",\";\n        WRITE_REPR(out, get<I>(t));\n        return write_repr_impl<I+1>(out, t);\n    }\n\n    static ostream& write_str(ostream& out, const tuple<TS...>& t) {\n        return write_str_impl(out, t);\n    }\n    static ostream& write_repr(ostream& out, const tuple<TS...>& t) {\n        return write_repr_impl(out, t);\n    }\n};\n\ntemplate<typename T>\nvoid RD(T& x) {\n    cin >> x;\n#ifdef PROCON_LOCAL\n    ASSERT(cin);\n#endif\n}\n\ntemplate<typename T>\nvoid RD1(T& x) {\n    RD(x);\n    --x;\n}\n\nvoid PRINT() {}\n\ntemplate<typename T, typename... TS>\nvoid PRINT(const T& x, const TS& ...args) {\n    WRITE_STR(cout, x);\n    if(sizeof...(args)) {\n        cout << ' ';\n        PRINT(args...);\n    }\n}\n\ntemplate<typename... TS>\nvoid PRINTLN(const TS& ...args) {\n    PRINT(args...);\n    cout << '\\n';\n}\n\n[[noreturn]] void EXIT() {\n    cout.flush();\n#ifdef PROCON_LOCAL\n    cerr.flush();\n    exit(0);\n#else\n    _Exit(0);\n#endif\n}\n\ntemplate<typename... TS, SFINAE(sizeof...(TS) == 1)>\nvoid DBG_IMPL(i64 line, const char* expr, const tuple<TS...>& value) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \";\n    WRITE_REPR(cerr, get<0>(value));\n    cerr << \"\\n\";\n}\n\ntemplate<typename... TS, SFINAE(sizeof...(TS) >= 2)>\nvoid DBG_IMPL(i64 line, const char* expr, const tuple<TS...>& value) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << \"(\" << expr << \") = \";\n    WRITE_REPR(cerr, value);\n    cerr << \"\\n\";\n}\n\ntemplate<typename T, size_t N>\nvoid DBG_CARRAY_IMPL(i64 line, const char* expr, const T (&ary)[N]) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \";\n    WRITE_RANGE_REPR(cerr, begin(ary), end(ary));\n    cerr << \"\\n\";\n}\n\ntemplate<typename InputIt>\nvoid DBG_RANGE_IMPL(i64 line, const char* expr1, const char* expr2, InputIt first, InputIt last) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr1 << \",\" << expr2 << \" = \";\n    WRITE_RANGE_REPR(cerr, first, last);\n    cerr << \"\\n\";\n}\n\n#ifdef PROCON_LOCAL\n    #define DBG(args...) DBG_IMPL(__LINE__, CPP_STR_I(args), std::make_tuple(args))\n    #define DBG_CARRAY(expr) DBG_CARRAY_IMPL(__LINE__, CPP_STR(expr), (expr))\n    #define DBG_RANGE(first,last) DBG_RANGE_IMPL(__LINE__, CPP_STR(first), CPP_STR(last), (first), (last))\n#else\n    #define DBG(args...)\n    #define DBG_CARRAY(expr)\n    #define DBG_RANGE(first,last)\n#endif\n\n#define PAIR  make_pair\n#define TUPLE make_tuple\n// }}}\n\n// init {{{\nstruct ProconInit {\n    static constexpr int IOS_PREC = 15;\n    static constexpr bool AUTOFLUSH = false;\n\n    ProconInit() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(IOS_PREC);\n#ifdef PROCON_LOCAL\n        cerr << fixed << setprecision(IOS_PREC);\n#endif\n        if(AUTOFLUSH)\n            cout << unitbuf;\n    }\n} PROCON_INIT;\n// }}}\n\n//--------------------------------------------------------------------\n\n// ノード: v (1-based)\n// 元配列のインデックス: i (0-based)\n\nstruct SegTreeLazy {\n    static constexpr i64 EMPTY() { return INF; }\n\n    i64 n_;\n    vector<i64> data_;  // 1-based, 区間内の総和\n    vector<i64> lazy_;  // 1-based, 区間内の総和\n\n    explicit SegTreeLazy(i64 n) : n_(pow2_ceil(n)), data_(2*n_,0), lazy_(2*n_,EMPTY()) {}\n\n    void update(i64 i, i64 k, i64 x) {\n        update_impl(i, i+k, x, 1, 0, n_);\n    }\n\n    i64 query(i64 i, i64 k) {\n        return query_impl(i, i+k, 1, 0, n_);\n    }\n\nprivate:\n    // [a,b): 要求区間\n    // [l,r): ノード v の区間\n    void update_impl(i64 a, i64 b, i64 x, i64 v, i64 l, i64 r) {\n        // まず現ノードを評価\n        // ここで lazy_[v] が空になる\n        eval(v);\n\n        // [a,b), [l,r) が共通部分を持たなければ何もしない\n        if(b <= l || r <= a) return;\n\n        // [a,b) が [l,r) を完全に被覆するなら lazy_[v] に値を入れた後に評価\n        if(a <= l && r <= b) {\n            lazy_[v] = (r-l) * x;\n            eval(v);\n        }\n        // [a,b) が [l,r) と部分的に交わるなら子ノードを更新\n        // 最後に data_[v] を更新\n        else {\n            update_impl(a, b, x, node_l(v), l, (l+r)/2);\n            update_impl(a, b, x, node_r(v), (l+r)/2, r);\n            data_[v] = data_[node_l(v)] + data_[node_r(v)];\n        }\n    }\n\n    // [a,b): 要求区間\n    // [l,r): ノード v の区間\n    i64 query_impl(i64 a, i64 b, i64 v, i64 l, i64 r) {\n        // [a,b), [l,r) が共通部分を持たなければ単位元を返す\n        if(b <= l || r <= a) return 0;\n\n        // 現ノードを評価\n        eval(v);\n\n        // [a,b) が [l,r) を完全に被覆するなら data_[v] を返す\n        if(a <= l && r <= b) return data_[v];\n\n        // [a,b) が [l,r) と部分的に交わるなら子ノードへクエリして計算\n        i64 xl = query_impl(a, b, node_l(v), l, (l+r)/2);\n        i64 xr = query_impl(a, b, node_r(v), (l+r)/2, r);\n        return xl + xr;\n    }\n\n    void eval(i64 v) {\n        if(lazy_[v] == EMPTY()) return;\n\n        data_[v] = lazy_[v];\n        if(!node_is_leaf(v)) {\n            lazy_[node_l(v)] = lazy_[v] / 2;\n            lazy_[node_r(v)] = lazy_[v] / 2;\n        }\n\n        lazy_[v] = EMPTY();\n    }\n\n    static i64 node_l(i64 v) {\n        return 2*v;\n    }\n\n    static i64 node_r(i64 v) {\n        return 2*v + 1;\n    }\n\n    bool node_is_leaf(i64 v) const {\n        return v >= n_;\n    }\n\n    i64 node_leaf(i64 i) const {\n        return i + n_;\n    }\n};\n\nvoid solve() {\n    i64 N; RD(N);\n    i64 Q; RD(Q);\n\n    SegTreeLazy seg(N);\n    REP(_, Q) {\n        i64 cmd; RD(cmd);\n        if(cmd == 0) {\n            i64 s,t; RD(s); RD(t);\n            i64 x; RD(x);\n            seg.update(s, t-s+1, x);\n        }\n        else if(cmd == 1) {\n            i64 s,t; RD(s); RD(t);\n            i64 ans = seg.query(s, t-s+1);\n            PRINTLN(ans);\n        }\n        else {\n            ASSERT(false);\n        }\n    }\n\n    // * 小さいケースで試した?\n    // * 不可能なケースはチェックした?\n    // * MOD はとった?\n    // * メモ化忘れてない?\n    // * 入出力の 0-based/1-based 確認した?\n    // * 時間/メモリ制限は確認した?\n    // * 違うやつ提出してない?\n    // * 違うやつテストしてない?\n}\n\nsigned main() {\n    \n\n    solve();\n\n    EXIT();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n参考\nhttps://ei1333.github.io/luzhiled/snippets/structure/segment-tree.html\n\nhttps://firiexp.github.io/library/library/lazysegtree.html\n\nhttps://smijake3.hatenablog.com/entry/2018/11/03/100133#%E9%81%85%E5%BB%B6%E8%A9%95%E4%BE%A1%E3%82%BB%E3%82%B0%E3%83%A1%E3%83%B3%E3%83%88%E6%9C%A8%E3%81%AE%E6%A6%82%E8%A6%81\nverify:\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_F\n*/\n\n#pragma GCC optimize(\"Ofast\")\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <limits>\n#include <iostream>\n#include <map>\n#include <set>\n#include <tuple>\n#include <iomanip>\n#include <functional>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<int,ll> pil;\ntypedef pair<ll,int> pli;\ntypedef pair<ll,ll> pll;\n\ntemplate<class T,class U>constexpr bool chmin(T&a,const U b){if(a<=b)return false;a=b;return true;}\ntemplate<class T,class U>constexpr bool chmax(T&a,const U b){if(a>=b)return false;a=b;return true;}\n#define bit(n,k) ( (n>>k)&1 )\n\n//デバッグ\ntemplate<class T>\nvoid Vout(vector<T> &V){\n    cout<<\"\\nstart\\n\";\n    const int sz=V.size();\n    for(int i=0;i<sz;i++){\n        cout<<i<<\" \"<<V[i]<<'\\n';\n    }\n    cout<<\"end\\n\"<<endl;\n}\n\ntemplate<class T>\nvoid VPout(vector<T> &V){\n    cout<<\"\\nstart\\n\";\n    const int sz=V.size();\n    for(int i=0;i<sz;i++){\n        cout<<i<<\" \"<<V[i].first<<\" \"<<V[i].second<<'\\n';\n    }\n    cout<<\"end\\n\"<<endl;\n}\n\n\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n\nconstexpr int MAX=1<<30;\nconstexpr ll INF=1LL<<62;\nconstexpr int MOD=1e9+7;\nint dx[]={1,-1,0,0},dy[]={0,0,-1,1};\n\n//__builtin_popcount(S);\n//#define int ll\n//vector<vector<int>> data(3, vector<int>(4));\n//vector.resize(a,vector<int>(b,-1));\n//vector<vector<vector<要素の型>>> 変数名(要素数1, vector<vector<要素の型>>(要素数2, vector<要素の型>(要素数3, 初期値)));\n\n\ntemplate<typename T,typename L>\nstruct LazySegmentTree{\n    //using\n    using F=function<T(T,T)>;\n    using G=function<T(T,L)>;\n    using H=function<L(L,L)>; //二番目が後に追加されたもの\n\n    //データ\n    int sz;\n    int height;\n    vector<T> seg;\n    vector<L> lazy;\n    const T sut;\n    const L lut;\n    const F f;\n    const G g;\n    const H h;\n\n    LazySegmentTree(int n,const T sut,const L lut,const F &f,const G &g,const H &h):sut(sut),lut(lut),f(f),g(g),h(h){\n        sz=1;\n        height=0;\n        while(sz<n) sz<<=1,height++;\n        seg.assign((sz<<1),sut);\n        lazy.assign((sz<<1),lut);        \n    }\n\n    inline void set(int k,const T &x){\n        seg[k+sz]=x;\n    }\n    inline void build(){\n        for(int k=sz-1;k>0;k--){\n            seg[k]=f(seg[(k<<1)],seg[(k<<1)+1]);\n        }\n    }\n    inline T reflect(int k){\n        return (lazy[k]==lut) ? seg[k]:g(seg[k],lazy[k]);\n    }\n    //子にlazyを伝える(updateで丸々収まる所を更新した尻ぬぐい)\n    //lazy[k]とlazy[2*k]が違った場合,lazy[k]の方が後に更新されたもの\n    inline void propagate(int k){\n        if(lazy[k]!=lut){\n            lazy[(k<<1)]=h(lazy[(k<<1)],lazy[k]);\n            lazy[(k<<1)+1]=h(lazy[(k<<1)+1],lazy[k]);\n            seg[k]=reflect(k);\n            lazy[k]=lut;\n        }\n    }\n    //ボトムアップで更新していく\n    inline void recalc(int k){\n        while(k>>=1) seg[k]=f(reflect((k<<1)),reflect((k<<1)+1));\n    }\n    //トップダウンで更新していく(これでseg[k]が正しい値になる)\n    inline void thrust(int k){\n        for(int i=height;i>0;i--) propagate(k>>i);\n    }\n    void update(int a,int b,const L &x){\n        //トップダウンでlazy[i]!=lutのものを更新\n        thrust(a+=sz);\n        thrust(b+=sz-1);\n        //丸々収まるところを更新\n        for(int l=a,r=b+1;l<r;l>>=1,r>>=1){\n            if(l&1) lazy[l]=h(lazy[l],x),l++;\n            if(r&1) --r,lazy[r]=h(lazy[r],x);\n        }\n        //ボトムアップで新しく更新\n        recalc(a);\n        recalc(b);\n    }\n\n    //[a:b)\n    T query(int a,int b){\n        //トップダウンで関係あってlazy[i]!=lutのものを更新\n        thrust(a+=sz);\n        thrust(b+=sz-1);\n        //更新した後は普通のセグ木と同じ\n        T l=sut,r=sut;\n        for(a,b+=1;a<b;a>>=1,b>>=1){\n\n            if(a&1) l=f(l,reflect(a++));\n            if(b&1) r=f(reflect(--b),r);\n        }\n        return f(l,r);\n    }\n    //セグ木と違い、log(n)かかる\n    T operator[](const int k){\n        return query(k,k+1);\n    }\n\n};\n\n//[](int a,int b){return min(a,b);}\n\nsigned main(){\n    ios::sync_with_stdio(false);\n\tcin.tie(0);\n    int n,q;\n    cin>>n>>q;\n    auto f=[](pii a,pii b){return pii(a.first+b.first,a.second+b.second);};\n    auto g=[](pii a,int b){return pii(a.first,a.first*b);};\n    auto h=[](int a,int b){return b;};\n    LazySegmentTree<pii,int> l(n,pii(0,0),-1100,f,g,h);\n    for(int i=0;i<n;i++){\n        l.set(i,pii(1,0));\n    }\n    l.build();\n    while(q--){\n        int a;\n        cin>>a;\n        if(a==0){\n            int s,t,x;\n            cin>>s>>t>>x;\n            l.update(s,t+1,x);\n        }else{\n            int s,t;\n            cin>>s>>t;\n            cout<<l.query(s,t+1).second<<endl;\n        }\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n/*\n\tUNITY_NODE sumの単位元\n\tUNITY_LAZY updateの単位元\n\tnodeの初期値に注意(init)\n\taddの呼び出し元に注意(区間の長さに比例する)\n\t上の関係でUNITY_LAZY / 2も単位元とみなしている\n*/\ntemplate <class NODE, class LAZY, NODE UNITY_NODE, LAZY UNITY_LAZY>\nstruct LazySegTree {\n// edit start\n\tvoid add(LAZY &a, LAZY b) {\n\t\tif (b == UNITY_LAZY || b == UNITY_LAZY / 2) return;\n\t\ta = b;\n\t}\n\tvoid reflect(NODE& a, LAZY b, int l, int r) {\n\t\tif (b == UNITY_LAZY || b == UNITY_LAZY / 2) return;\n\t\ta = b;\n\t}\n\tNODE merge(NODE a, NODE b) {\n\t\treturn a + b;\n\t}\n// end\n\tint n;\n\tvector<NODE> node;\n\tvector<LAZY> lazy;\n\tLazySegTree(int sz) {\n\t\tinit(sz);\n\t}\n\tvoid init(int sz) {\n\t\tn = 1;\n\t\twhile (n < sz) n *= 2;\n\t\tnode.assign(2*n-1, 0);\n\t\tlazy.assign(2*n-1, UNITY_LAZY);\n\t}\n\tvoid eval(int l, int r, int k) {\n\t\treflect(node[k], lazy[k], l, r);\n\t\tif (r - l > 1) {\n\t\t\tadd(lazy[k*2+1], lazy[k] / 2);\n\t\t\tadd(lazy[k*2+2], lazy[k] / 2);\n\t\t}\n\t\tlazy[k] = UNITY_LAZY;\n\t}\n\tvoid renode(int k) {\n\t\tnode[k] = merge(node[k*2+1], node[k*2+2]);\n\t}\n\tvoid set(int a, int b, LAZY x, int k=0, int l=0, int r=-1) {\n\t\tif (r < 0) r = n;\n\t\tif (b <= l || r <= a) {\n\t\t\teval(l, r, k);\n\t\t} else if (a <= l && r <= b) {\n\t\t\tadd(lazy[k], x * (r - l));\n\t\t\teval(l, r, k);\n\t\t} else {\n\t\t\teval(l, r, k);\n\t\t\tset(a, b, x, k*2+1, l, (l+r) / 2);\n\t\t\tset(a, b, x, k*2+2, (l+r) / 2, r);\n\t\t\trenode(k);\n\t\t}\n\t}\n\tNODE get(int a, int b, int k=0, int l=0, int r=-1) {\n\t\tif (r < 0) r = n;\n\t\teval(l, r, k);\n\t\tif (b <= l || r <= a) {\n\t\t\treturn UNITY_NODE;\n\t\t} else if (a <= l && r <= b) {\n\t\t\treturn node[k];\n\t\t} else {\n\t\t\tNODE t1 = get(a, b, 2*k+1, l, (l+r) / 2);\n\t\t\tNODE t2 = get(a, b, 2*k+2, (l+r) / 2, r);\n\t\t\trenode(k);\n\t\t\treturn merge(t1, t2);\n\t\t}\n\t}\n};\n\nint main(){\n\tint n, q;\n\tcin >> n >> q;\n\tLazySegTree<long long, long long, 0, LLONG_MAX> L(n);\n\twhile (q--) {\n\t\tint a, s, t, x;\n\t\tcin >> a >> s >> t;\n\t\tif (a == 0) {\n\t\t\tcin >> x;\n\t\t\tL.set(s, t+1, x);\n\t\t} else {\n\t\t\tcout << L.get(s, t+1) << endl;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\ntypedef pair<pii,int> ppi;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a/gcd(a,b)*b;\n}\n\nclass LazySegmentTree{\nprivate:\n    int n;\n    vector<long long> node, lazy;\n    long long node_init = 0; // sum, max, update\n    //long long node_init = LINF; // min\n    long long lazy_init = 0; // default\n    //long long lazy_init = LINF; // min\n\n    long long lazy_update(long long a,long long b){\n        //return a+b; // sum query\n        //return max(a,b); // max query\n        //return min(a,b); // min query\n        return b; // update query\n    }\n\n    long long node_update(long long a, long long b, int l, int r){ // lazy を node に反映\n        //return a + b; // min query\n        //return b; // update query\n        return b * (r-l); // sum query\n    }\n\n    long long combine(long long a,long long b){\n        return a+b; // sum query\n        //return max(a,b); // max query\n        //return min(a,b); // min query\n    }\n\npublic:\n    LazySegmentTree(){}\n    LazySegmentTree(vector<long long> in){\n        n = 1;\n        while(n < in.size())n <<= 1;\n        node = vector<long long>(2*n, node_init);\n        lazy = vector<long long>(2*n, lazy_init);\n        for(int i = n-1+in.size()-1; i >= 0; i--){\n            if(n-1 <= i)node[i] = in[i-(n-1)];\n            else node[i] = combine(node[i*2+1], node[i*2+2]);\n        }\n    }\n    void eval(int k, int l, int r){\n        if(lazy[k] != lazy_init){\n            node[k] = node_update(node[k], lazy[k], l, r);\n            if(r - l > 1){\n                lazy[2*k+1] = lazy_update(lazy[2*k+1], lazy[k]);\n                lazy[2*k+2] = lazy_update(lazy[2*k+2], lazy[k]);\n            }\n            lazy[k] = lazy_init;\n        }\n    }\n    void update(int a, int b, long long x, int k = 0, int l = 0, int r = -1){\n        if(r < 0)r = n;\n        eval(k,l,r);\n        if(b <= l || r <= a)return;\n        if(a <= l && r <= b){\n            lazy[k] = x;\n            eval(k,l,r);\n        }else{\n            update(a,b,x,2*k+1,l,(l+r)/2);\n            update(a,b,x,2*k+2,(l+r)/2,r);\n            node[k] = combine(node[2*k+1], node[2*k+2]);\n        }\n    }\n    long long query(int a, int b, int k = 0, int l = 0, int r = -1){\n        if(r < 0)r = n;\n        if(b <= l || r <= a)return node_init;\n        eval(k,l,r);\n        if(a <= l && r <= b)return node[k];\n        return combine(query(a,b,2*k+1,l,(l+r)/2), query(a,b,2*k+2,(l+r)/2,r));\n    }\n    void show(){\n        cout << \"node :\";\n        for(int i = 0; i < 2*n-1; i++){\n            if(i == n-1)cout << \"     \";\n            cout << \" \" << node[i];\n        }\n        cout << endl;\n        cout << \"lazy :\";\n        for(int i = 0; i < 2*n-1; i++){\n            if(i == n-1)cout << \"     \";\n            cout << \" \" << lazy[i];\n        }\n        cout << endl;\n    }\n};\n\nsigned main(void) {\n\n    int n,q;\n    cin >> n >> q;\n    LazySegmentTree lazy = LazySegmentTree(vi(n));\n\n    rep(i,q){\n        int a;\n        cin >> a;\n        if(a == 0){//update\n            int s,t,x;\n            cin >> s >> t >> x;\n            lazy.update(s,t+1,x);\n        }else{//query\n            int s,t;\n            cin >> s >> t;\n            cout << lazy.query(s,t+1) << endl;\n        }\n        //lazy.show();\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\n\nconst int MAXN=1e5+10;\nusing ll=long long int;\n\nstruct Node{\n    int lbound,rbound;\n    bool updated;\n    ll diff;\n    ll sum;\n    Node *left,*right;\n};\n\nNode segtree[MAXN*2];\nNode* next_pos=segtree;\nint n,q;\n\nNode* build(int left,int right){\n    auto* cur=next_pos;\n    next_pos++;\n    cur->lbound=left;\n    cur->rbound=right;\n\n    cur->updated=false;\n    cur->diff=0;\n    \n\n    int mid=(left+right)/2;\n\n    //リーフノードのケース\n    if (right-left==1) {\n        cur->sum=0;\n        return cur;\n    }\n\n    cur->left=build(left,mid);\n    cur->right=build(mid,right);\n    //総和を集計\n    cur->sum=0;\n    return cur;\n}\n\n//シングルノードの更新\nvoid update(Node& self,ll d){\n    self.diff=d;\n    self.sum=d*(self.rbound-self.lbound);\n    self.updated=true;\n}\n\nvoid update(Node& self,int l,int r,int u){\n    int mid=(self.lbound+self.rbound)/2;\n    \n    if (self.rbound-self.lbound!=1&&self.updated){\n        update(*self.left,self.diff);\n        update(*self.right,self.diff);\n        self.diff=0;\n        self.updated=false;\n    }\n\n    if (l==self.lbound&&r==self.rbound){\n        update(self,u);\n    }else if (l>=mid){\n        update(*self.right,l,r,u);\n        self.sum=self.left->sum+self.right->sum;\n    }else if (r<=mid){\n        update(*self.left,l,r,u);\n        self.sum=self.left->sum+self.right->sum;\n    }else{\n        update(*self.left,l,mid,u);\n        update(*self.right,mid,r,u);\n        self.sum=self.left->sum+self.right->sum;\n    }\n}\n\n//シングルポイント\nint query(Node& self,int i){\n    // puts(\"q\");\n    if (self.rbound-self.lbound==1&&self.lbound==i) return self.diff;\n    int mid=(self.lbound+self.rbound)/2;\n    if (i>=mid) return query(*self.right,i)+self.diff;\n    else return query(*self.left,i)+self.diff;\n}\n\n//区間\nll query(Node& self,int l,int r){\n    int mid=(self.lbound+self.rbound)/2;\n\n    //更新があるノードの区間をプッシュボタン\n    if (self.rbound-self.lbound!=1&&self.updated){\n        update(*self.left,self.diff);\n        update(*self.right,self.diff);\n        self.diff=0;\n        self.updated=false;\n    }\n\n    if (l==self.lbound&&r==self.rbound){\n        return self.sum;\n    }else if (l>=mid){\n        return query(*self.right,l,r);\n    }else if (r<=mid){\n        return query(*self.left,l,r);\n    }else{\n        return query(*self.left,l,mid)+query(*self.right,mid,r);\n    }\n}\n\nint main(){\n    scanf(\"%d%d\",&n,&q);\n    build(0,n);\n    // printf(\"%lld\\n\",segtree[0].sum);\n    for(int i=0;i<q;i++){\n        int t;\n        scanf(\"%d\",&t);\n        if (t==0){\n            int s,t,x;\n            scanf(\"%d%d%d\",&s,&t,&x);\n            update(segtree[0],s,t+1,x);\n        }else{\n            int l,r;\n            scanf(\"%d%d\",&l,&r);\n            printf(\"%lld\\n\",query(segtree[0],l,r+1));\n        }\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\n#define FOR(i, a, b) for (int i = a; i <= (b); i++)\n#define ROF(i, a, b) for (int i = a; i >= (b); i--)\n\nusing pii = pair<int, int>; using vpii = vector<pii>;\nusing vi = vector<int>; using vvi = vector<vi>;\nusing ll = long long;\nusing pll = pair<ll, ll>; using vpll = vector<pll>;\nusing vll = vector<ll>; using vvll = vector<vll>;\n\nstruct ruqst{\n    vll t, d, tag;\n\n    ruqst(int len, int init) {\n        t.resize((len + 5) * 4, init);\n        d.resize((len + 5) * 4, 0);\n        tag.resize((len + 5) * 4, 0);\n    }\n\n    ll qry(int p, int l, int r, int tl, int tr) {\n        if (tl <= l && r <= tr) return t[p];\n        int mid = (l + r) / 2;\n        if (tag[p]) {\n            t[p * 2] = d[p] * (mid - l + 1), d[p * 2] = d[p], tag[p * 2] = 1;\n            t[p * 2 + 1] = d[p] * (r - mid), d[p * 2 + 1] = d[p], tag[p * 2 + 1] = 1;\n            d[p] = 0, tag[p] = 0;\n        }\n        ll rt = 0;\n        if (tl <= mid) rt += qry(p * 2, l, mid, tl, tr);\n        if (mid < r && tr > mid) rt += qry(p * 2 + 1, mid + 1, r, tl, tr);\n        return rt;\n    }\n\n    void set(int p, int l, int r, int tl, int tr, ll x) {\n        if (tl <= l && r <= tr) {\n            t[p] = x * (r - l + 1), d[p] = x, tag[p] = 1;\n            return;\n        }\n        int mid = (l + r) / 2;\n        if (tag[p]) {\n            t[p * 2] = d[p] * (mid - l + 1), d[p * 2] = d[p], tag[p * 2] = 1;\n            t[p * 2 + 1] = d[p] * (r - mid), d[p * 2 + 1] = d[p], tag[p * 2 + 1] = 1;\n            d[p] = 0, tag[p] = 0;\n        }\n        if (tl <= mid) set(p * 2, l, mid, tl, tr, x);\n        if (mid < r && tr > mid) set(p * 2 + 1, mid + 1, r, tl, tr, x);\n        t[p] = t[p * 2] + t[p * 2 + 1];\n        return;\n    }\n};\n\nint main() {\n    // freopen(\"n\", \"r\", stdin);\n    // freopen(\"a.out\", \"w\", stdout);\n    int n, q; cin >> n >> q;\n    ruqst st(n, 0);\n    FOR(_, 1, q) {\n        int c; cin >> c;\n        if (c == 0) {\n            int s, t, x; cin >> s >> t >> x;\n            st.set(1, 0, n - 1, s, t, x);\n        }\n        else {\n            int s, t; cin >> s >> t;\n            cout << st.qry(1, 0, n - 1, s, t) << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// stream\n//#include <istream>\n#include <sstream>\n//#include <ostream>\n#include <fstream>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define FORLL(w, a, n) for(ll w=ll(a);w<ll(n);++w)\n#define RFORLL(w, a, n) for(ll w=ll(n)-1;w>=ll(a);--w)\n#define REPLL(w, n) for(ll w=0;w<ll(n);++w)\n#define RREPLL(w, n) for(ll w=ll(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n#define random_shuffle \"USE std::shuffle!\";\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-6;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\n// ------------>8---------- LazySegmentTree ---------->8------------\nnamespace MonoidOfValue {\n\ttemplate <class T> class sum {\n\tpublic:\n\t\tusing value_type = T;\n\t\tinline static T op(const T& a, const T& b) { return a + b; }\n\t\tinline static value_type id() { return T(0); }\n\t};\n\ttemplate <class T> class max {\n\tpublic:\n\t\tusing value_type = T;\n\t\tinline static T op(const T& a, const T& b) { return (a < b) ? b : a; }\n\t\tinline static T id() { return std::numeric_limits<T>::lowest(); }\n\t};\n\ttemplate <class T> class min {\n\tpublic:\n\t\tusing value_type = T;\n\t\tinline static T op(const T& a, const T& b) { return (a < b) ? a : b; }\n\t\tinline static T id() { return std::numeric_limits<T>::max(); }\n\t};\n\n\tclass MONOID {\n\tpublic:\n\t\tstruct S { int x; };\n\t\tusing T = S;\n\t\tusing value_type = T;\n\t\tinline static T op(const T& l, const T& r) { return S{ l.x + r.x }; }\n\t\tinline static T id() { return S{ 0 }; }\n\t};\n}\nnamespace MonoidOfOperator {\n\ttemplate <class T> class add {\n\tpublic:\n\t\tusing value_type = T;\n\t\tinline static T op(const T& a, const T& b) { return a + b; }\n\t\tinline static T id() { return T(0); }\n\t};\n\ttemplate <class T> class upd {\n\tpublic:\n\t\tusing value_type = T;\n\t\tinline static T op(const T& a, const T& b) { return b; }\n\t\tinline static T id() { return T(0); }\n\t};\n}\nnamespace ApplyOperator {\n\ttemplate <class T1, class T2> class RSQRAQ {\n\tpublic:\n\t\tinline static T1 op(const T1& a, const T2& b, int w) { return a + b * w; }\n\t};\n\ttemplate <class T1, class T2> class RSQRUQ {\n\tpublic:\n\t\tinline static T1 op(const T1& a, const T2& b, int w) { return b * w; }\n\t};\n\ttemplate <class T1, class T2> class RMQRAQ {\n\tpublic:\n\t\tinline static T1 op(const T1& a, const T2& b, int w) { return a + b; }\n\t};\n\ttemplate <class T1, class T2> class RMQRUQ {\n\tpublic:\n\t\tinline static T1 op(const T1& a, const T2& b, int w) { return b; }\n\t};\n}\ntemplate<class MonoidOfValue, class MonoidOfOperator, template<class, class> class ApplyOperator>\nclass LazySegmentTree {\nprivate:\n\tusing ValueType = typename MonoidOfValue::value_type;\n\tusing OperatorType = typename MonoidOfOperator::value_type;\n\tusing Applier = ApplyOperator<ValueType, OperatorType>;\n\tstd::vector<ValueType> seg;\n\tstd::vector<OperatorType> laz;\n\tstd::vector<bool> isUpdated;\n\tint HEIGHT;\n\tint ARY_SIZE;\n\n\tvoid push(int k, int w) {\n\t\tif (!isUpdated[k]) {\n\t\t\tseg[k] = Applier::op(seg[k], laz[k], w);\n\t\t\tif (w > 1) {\n\t\t\t\tlaz[(k << 1) + 0] = MonoidOfOperator::op(laz[(k << 1) + 0], laz[k]);\n\t\t\t\tlaz[(k << 1) + 1] = MonoidOfOperator::op(laz[(k << 1) + 1], laz[k]);\n\t\t\t\tisUpdated[(k << 1) + 0] = false;\n\t\t\t\tisUpdated[(k << 1) + 1] = false;\n\t\t\t}\n\t\t\tisUpdated[k] = true;\n\t\t\tlaz[k] = MonoidOfOperator::id();\n\t\t}\n\t}\n\tvoid update(int k, int w) {\n\t\tpush(k, w);\n\t\tif (k < ARY_SIZE) {\n\t\t\tpush((k << 1) + 0, w >> 1);\n\t\t\tpush((k << 1) + 1, w >> 1);\n\t\t\tseg[k] = MonoidOfValue::op(seg[(k << 1) + 0], seg[(k << 1) + 1]);\n\t\t}\n\t}\npublic:\n\tLazySegmentTree(int n) {\n\t\tinit(n);\n\t}\n\tLazySegmentTree(const std::vector<ValueType>& a) {\n\t\tinit(a.size());\n\t\tstd::copy(std::begin(a), std::end(a), std::begin(seg) + ARY_SIZE);\n\t\tfor (int k = ARY_SIZE - 1; k > 0; --k) seg[k] = MonoidOfValue::op(seg[(k << 1) + 0], seg[(k << 1) + 1]);\n\t}\n\tvoid init(int n) {\n\t\tHEIGHT = 0;\n\t\twhile ((1 << HEIGHT) < n) ++HEIGHT;\n\t\tARY_SIZE = 1 << HEIGHT;\n\t\tseg.resize(ARY_SIZE << 1, MonoidOfValue::id());\n\t\tlaz.resize(ARY_SIZE << 1, MonoidOfOperator::id());\n\t\tisUpdated.resize(ARY_SIZE << 1, true);\n\t}\n\t// ## update [l, r) with v\n\tvoid update(int l, int r, OperatorType v) {\n\t\tl += ARY_SIZE; r += ARY_SIZE;\n\t\tint L = l, R = r - 1;\n\t\tfor (int i = HEIGHT; i >= 0; --i) push(L >> i, 1 << i), push(R >> i, 1 << i);\n\t\twhile (l < r) {\n\t\t\tif (l & 1) laz[l] = MonoidOfOperator::op(laz[l], v), isUpdated[l] = false, ++l;\n\t\t\tif (r & 1) --r, laz[r] = MonoidOfOperator::op(laz[r], v), isUpdated[r] = false;\n\t\t\tl >>= 1; r >>= 1;\n\t\t}\n\t\tfor (int i = 1; i <= HEIGHT; ++i) {\n\t\t\tpush(L >> i, 1 << i), push(R >> i, 1 << i);\n\t\t\tupdate(L >> i, 1 << i), update(R >> i, 1 << i);\n\t\t}\n\t}\n\t// ## return SUM/MAX/MIN in [l, r)\n\tValueType query(int l, int r) {\n\t\tl += ARY_SIZE; r += ARY_SIZE - 1;\n\t\tfor (int i = HEIGHT; i >= 0; --i) push(l >> i, 1 << i), push(r >> i, 1 << i);\n\t\t++r;\n\t\tValueType vl = MonoidOfValue::id(), vr = MonoidOfValue::id();\n\t\tint w = 1;\n\t\twhile (l < r) {\n\t\t\tif (l & 1) update(l, w), vl = MonoidOfValue::op(vl, seg[l]), ++l;\n\t\t\tif (r & 1) --r, update(r, w), vr = MonoidOfValue::op(seg[r], vr);\n\t\t\tl >>= 1; r >>= 1; w <<= 1;\n\t\t}\n\t\treturn MonoidOfValue::op(vl, vr);\n\t}\n};\n// ------------>8---------- LazySegmentTree ---------->8------------\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, q);\n\tV<int> a(n, 0);\n\n\tLazySegmentTree<MonoidOfValue::sum<int>, MonoidOfOperator::upd<int>, ApplyOperator::RSQRUQ> lst(a);\n\n\tREP(_, q) {\n\t\tVAR(int, type, l, r); ++r;\n\t\tif (type == 0) {\n\t\t\tVAR(int, x);\n\t\t\tlst.update(l, r, x);\n\t\t}\n\t\telse {\n\t\t\tOUT(lst.query(l, r))BR;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// example:\n// Range Update and Range Min (update val >= 0)\nstruct RURM {\n    using type1 = int; // data type (Monoid)\n    using type2 = int; // lazy\n\n    static type1 id1() {\n        return std::numeric_limits<type1>::max();\n    }\n    static type2 id2() {\n        return -1;\n    }\n    static type1 op1(type1 const& l, type1 const& r) {\n        return std::min(l, r);\n    }\n    static type1 op2(type1 const& l, type2 const& r) {\n        return r != id2() ? r : l;\n    }\n    static type2 op3(type2 const& l, type2 const& r) {\n        return r != id2() ? r : l;\n    }\n};\n\n// Range Update Range Sum\nstruct RURS {\n    struct type1 {\n        int val, size;\n        type1(int v, int s) : val(v), size(s) {}\n    };\n    using type2 = int;\n\n    static type1 id1() { return type1(0, 0); } // initialize: seg<RURS>(n, type1(0, 1))\n    static type2 id2() { return std::numeric_limits<type2>::min() / 2; }\n\n    static type1 op1(type1 const& l, type1 const& r) {\n        return type1(l.val + r.val, l.size + r.size);\n    }\n    static type1 op2(type1 const& l, type2 const& r) {\n        return r != id2() ? type1(r * l.size, l.size) : l;\n    }\n    static type2 op3(type2 const& l, type2 const& r) {\n        return r != id2() ? r : l;\n    }\n};\n\n\ntemplate <typename Monoid>\nclass lazy_segment_tree {\n    using T1 = typename Monoid::type1;\n    using T2 = typename Monoid::type2;\n\npublic:\n    lazy_segment_tree(std::vector<T1> const& init)\n        : sz(init.size()), n(expand(init.size())), h(std::ceil(std::log2(init.size()))),\n          data(n * 2, Monoid::id1()), lazy(n * 2, Monoid::id2())\n    {\n        std::copy(std::begin(init), std::end(init), std::begin(data) + n);\n        for(int i = n - 1; i >= 1; --i) {\n            data[i] = Monoid::op1(data[i * 2], data[i * 2 + 1]);\n        }\n    }\n    lazy_segment_tree(int n_, T1 init = Monoid::id1())\n        : lazy_segment_tree(std::vector<T1>(n_, init))\n    {}\n\n    T1 query(int l, int r) {\n        l += n, r += n;\n        for(int i = h; i > 0; --i) {\n            push(l >> i), push(r >> i);\n        }\n        T1 res1 = Monoid::id1(), res2 = Monoid::id1();\n        while(l < r) {\n            if(l & 1) res1 = Monoid::op1(res1, Monoid::op2(data[l], lazy[l])), ++l;\n            if(r & 1) --r, res2 = Monoid::op1(res2, Monoid::op2(data[r], lazy[r]));\n            l /= 2, r /= 2;\n        }\n        return Monoid::op1(res1, res2);\n    }\n\n    void update(int l, int r, T2 val) {\n        assert(0 <= l && l <= r && r <= sz);\n        l += n, r += n;\n        for(int i = h; i > 0; --i) {\n            push(l >> i), push(r >> i);\n        }\n        int tl = l, tr = r;\n        while(l < r) {\n            if(l & 1) lazy[l] = Monoid::op3(lazy[l], val), ++l;\n            if(r & 1) --r, lazy[r] = Monoid::op3(lazy[r], val);\n            l /= 2, r /= 2;\n        }\n        while(tr /= 2, tl /= 2) {\n            if(lazy[tl] == Monoid::id2()) update(tl);\n            if(lazy[tr] == Monoid::id2()) update(tr);\n        }\n    }\n\nprivate:\n    int expand(int n_) const {\n        int res = 1;\n        while(res < n_) res <<= 1;\n        return res;\n    }\n\n    void push(int node) {\n        if(lazy[node] == Monoid::id2()) return;\n        if(node < n) {\n            lazy[node * 2] = Monoid::op3(lazy[node * 2], lazy[node]);\n            lazy[node * 2 + 1] = Monoid::op3(lazy[node * 2 + 1], lazy[node]);\n        }\n        data[node] = Monoid::op2(data[node], lazy[node]);\n        lazy[node] = Monoid::id2();\n    }\n\n    void update(int node) {\n        if(node * 2 + 1 >= (int)data.size()) return; // for n == max_r\n        data[node] = Monoid::op1(Monoid::op2(data[node * 2], lazy[node * 2]),\n                                 Monoid::op2(data[node * 2 + 1], lazy[node * 2 + 1]));\n    }\n\nprivate:\n    int const sz, n, h;\n    std::vector<T1> data;\n    std::vector<T2> lazy;\n};\n\nint main() {\n    int n, q; cin >> n >> q;\n    lazy_segment_tree<RURS> seg(n, RURS::type1(0, 1));\n    while(q--) {\n        int com; cin >> com;\n        if(com == 0) {\n            int s, t, x; cin >> s >> t >> x;\n            seg.update(s, t + 1, x);\n        } else {\n            int s, t; cin >> s >> t;\n            cout << seg.query(s, t + 1).val << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename Monoid, typename OperatorMonoid> struct LazySegmentTree {\n    using F = function<Monoid(Monoid, Monoid)>;\n    using G = function<Monoid(Monoid, OperatorMonoid)>;\n    using H = function<OperatorMonoid(OperatorMonoid, OperatorMonoid)>;\n\n    int sz, height;\n    vector<Monoid> data;\n    vector<OperatorMonoid> lazy;\n    const F f;\n    const G g;\n    const H h;\n    const Monoid M0;\n    const OperatorMonoid O0;\n\n    constexpr LazySegmentTree(const F &f, const G &g, const H &h,\n                              const Monoid &M0, const OperatorMonoid &O0)\n        : f(f), g(g), h(h), M0(M0), O0(O0) {}\n\n    constexpr void init(const int &n) {\n        sz = 1;\n        height = 0;\n        while(sz < n)\n            sz <<= 1, height++;\n        data.assign(sz << 1, M0);\n        lazy.assign(sz << 1, O0);\n    }\n\n    constexpr void build(const vector<Monoid> &v) {\n        int n = v.size();\n        init(n);\n        for(int i = 0; i < n; i++)\n            data[sz + i] = v[i];\n        for(int i = sz - 1; i; i--)\n            data[i] = f(data[i << 1], data[i << 1 | 1]);\n    }\n\n    constexpr Monoid reflect(const int &k) const {\n        return lazy[k] == O0 ? data[k] : g(data[k], lazy[k]);\n    }\n\n    constexpr void propagate(const int &k) {\n        if(lazy[k] == O0) return;\n        lazy[k << 1] = h(lazy[k << 1], lazy[k]);\n        lazy[k << 1 | 1] = h(lazy[k << 1 | 1], lazy[k]);\n        data[k] = reflect(k);\n        lazy[k] = O0;\n    }\n\n    constexpr void thrust(const int &k) {\n        for(int i = height; i; i--)\n            propagate(k >> i);\n    }\n\n    constexpr void thrust(const int &l, const int &r) {\n        if(l == r) {\n            thrust(l);\n            return;\n        }\n        int Xor = l ^ r, i = height;\n        for(; !(Xor >> i); i--)\n            propagate(l >> i);\n        for(; i; i--) {\n            propagate(l >> i);\n            propagate(r >> i);\n        }\n    }\n\n    constexpr void recalc(int k) {\n        while(k >>= 1)\n            data[k] = f(reflect(k << 1), reflect(k << 1 | 1));\n    }\n\n    constexpr void recalc(int l, int r) {\n        int Xor = l ^ r;\n        while(Xor >>= 1) {\n            l >>= 1;\n            r >>= 1;\n            data[l] = f(reflect(l << 1), reflect(l << 1 | 1));\n            data[r] = f(reflect(r << 1), reflect(r << 1 | 1));\n        }\n        while(l >>= 1)\n            data[l] = f(reflect(l << 1), reflect(l << 1 | 1));\n    }\n\n    constexpr void update(int a, int b, const OperatorMonoid &x) {\n        if(a >= b) return;\n        thrust(a += sz, b += sz - 1);\n        for(int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if(l & 1) lazy[l] = h(lazy[l], x), l++;\n            if(r & 1) --r, lazy[r] = h(lazy[r], x);\n        }\n        recalc(a, b);\n    }\n\n    constexpr void set_val(int a, const Monoid &x) {\n        thrust(a += sz);\n        data[a] = x;\n        lazy[a] = O0;\n        recalc(a);\n    }\n\n    constexpr Monoid query(int a, int b) {\n        if(a >= b) return M0;\n        thrust(a += sz, b += sz - 1);\n        Monoid vl = M0, vr = M0;\n        for(int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if(l & 1) vl = f(vl, reflect(l++));\n            if(r & 1) vr = f(reflect(--r), vr);\n        }\n        return f(vl, vr);\n    }\n\n    template <typename C>\n    constexpr int find(const int &st, const C &check, Monoid &acc, const int &k,\n                       const int &l, const int &r) {\n        if(l + 1 == r) {\n            acc = f(acc, reflect(k));\n            return check(acc) ? k - sz : -1;\n        }\n        propagate(k);\n        int m = (l + r) >> 1;\n        if(m <= st) return find(st, check, acc, k << 1 | 1, m, r);\n        if(st <= l && !check(f(acc, data[k]))) {\n            acc = f(acc, data[k]);\n            return -1;\n        }\n        int vl = find(st, check, acc, k << 1, l, m);\n        if(~vl) return vl;\n        return find(st, check, acc, k << 1 | 1, m, r);\n    }\n\n    template <typename C> constexpr int find(const int &st, const C &check) {\n        Monoid acc = M0;\n        return find(st, check, acc, 1, 0, sz);\n    }\n};\n\n// RMQ + RUQ\nvoid DSL_2_F() {\n    int n, q;\n    cin >> n >> q;\n\n    auto f = [](int a, int b) { return min(a, b); };\n    auto g = [](int a, int b) { return b; };\n    LazySegmentTree<int, int> seg(f, g, g, INT_MAX, -1);\n    seg.init(n);\n\n    for(int _ = 0; _ < q; _++) {\n        int c;\n        cin >> c;\n        if(c == 0) {\n            int s, t, x;\n            cin >> s >> t >> x;\n            seg.update(s, t + 1, x);\n        } else {\n            int s, t;\n            cin >> s >> t;\n            cout << seg.query(s, t + 1) << \"\\n\";\n        }\n    }\n}\n\n// RSQ + RAQ\nvoid DSL_2_G() {\n    int n, q;\n    cin >> n >> q;\n\n    using P = pair<ll, ll>;\n    auto f = [](P a, P b) { return P(a.first + b.first, a.second + b.second); };\n    auto g = [](P a, ll b) { return P(a.first + b * a.second, a.second); };\n    auto h = [](ll a, ll b) { return a + b; };\n    LazySegmentTree<P, ll> seg(f, g, h, P(0, 0), 0);\n    seg.build(vector<P>(n, P(0, 1)));\n\n    for(int _ = 0; _ < q; _++) {\n        int c;\n        cin >> c;\n        if(c == 0) {\n            int s, t, x;\n            cin >> s >> t >> x;\n            seg.update(s - 1, t, x);\n        } else {\n            int s, t;\n            cin >> s >> t;\n            cout << seg.query(s - 1, t).first << \"\\n\";\n        }\n    }\n}\n\n// RMQ + RAQ\nvoid DSL_2_H() {\n    int n, q;\n    cin >> n >> q;\n\n    auto f = [](int a, int b) { return min(a, b); };\n    auto g = [](int a, int b) { return a + b; };\n    LazySegmentTree<int, int> seg(f, g, g, INT_MAX, 0);\n    seg.build(vector<int>(n, 0));\n\n    for(int _ = 0; _ < q; _++) {\n        int c;\n        cin >> c;\n        if(c == 0) {\n            int s, t, x;\n            cin >> s >> t >> x;\n            seg.update(s, t + 1, x);\n        } else {\n            int s, t;\n            cin >> s >> t;\n            cout << seg.query(s, t + 1) << \"\\n\";\n        }\n    }\n}\n\n// RSQ + RUQ\nvoid DSL_2_I() {\n    int n, q;\n    cin >> n >> q;\n\n    using P = pair<int, int>;\n    auto f = [](P a, P b) { return P(a.first + b.first, a.second + b.second); };\n    auto g = [](P a, int b) { return P(a.second * b, a.second); };\n    auto h = [](int a, int b) { return b; };\n    LazySegmentTree<P, int> seg(f, g, h, P(0, 0), -1010);\n    seg.build(vector<P>(n, P(0, 1)));\n\n    for(int _ = 0; _ < q; _++) {\n        int c;\n        cin >> c;\n        if(c == 0) {\n            int s, t, x;\n            cin >> s >> t >> x;\n            seg.update(s, t + 1, x);\n        } else {\n            int s, t;\n            cin >> s >> t;\n            cout << seg.query(s, t + 1).first << \"\\n\";\n        }\n    }\n}\n\nvoid CFR569_C() {\n\n    int n, m;\n    cin >> n >> m;\n    vector<int> as(n), bs(m);\n    for(int i = 0; i < n; i++)\n        cin >> as[i];\n    for(int i = 0; i < m; i++)\n        cin >> bs[i];\n\n    auto f = [](int a, int b) { return max(a, b); };\n    auto g = [](int a, int b) { return a + b; };\n    LazySegmentTree<int, int> seg(f, g, g, 0, 0);\n\n    const int sz = 1 << 20;\n    vector<int> x(sz, 0);\n    for(int i = 0; i < n; i++)\n        x[sz - as[i]]++;\n    for(int i = 0; i < m; i++)\n        x[sz - bs[i]]--;\n    for(int i = 1; i < sz; i++)\n        x[i] += x[i - 1];\n\n    seg.build(x);\n\n    int q;\n    cin >> q;\n    auto check = [](int d) { return d > 0; };\n    for(int i = 0; i < q; i++) {\n        int t, k, v;\n        cin >> t >> k >> v;\n        k--;\n        if(t == 1) {\n            seg.update(sz - as[k], sz, -1);\n            as[k] = v;\n            seg.update(sz - as[k], sz, 1);\n        }\n        if(t == 2) {\n            seg.update(sz - bs[k], sz, 1);\n            bs[k] = v;\n            seg.update(sz - bs[k], sz, -1);\n        }\n        int pos = seg.find(0, check);\n        cout << (pos < 0 ? pos : sz - pos) << \"\\n\";\n    }\n    cout << flush;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    DSL_2_I();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <limits>\n#include <fstream>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\ntypedef long long ll;\nconst ll sqrtN = 512;\nstruct SqrtDecomposition {\n  ll N, K;\n  vector<ll> data;\n  vector<ll> bucketSum;\n  vector<ll> lazyUpdate;\n  SqrtDecomposition(ll n) : N(n) {\n    K = (N + sqrtN - 1) / sqrtN;\n    data.assign(K * sqrtN, 0);\n    bucketSum.assign(K, 0);\n    lazyUpdate.assign(K, 1111);\n  }\n  void eval(ll k) {\n    if (lazyUpdate[k] != 1111) {\n      for (ll i = k * sqrtN; i < (k + 1) * sqrtN; ++i) {\n        data[i] = lazyUpdate[k];\n      }\n      lazyUpdate[k] = 1111;\n    }\n  }\n  // [s, t)\n  void update(ll s, ll t, ll x) {\n    for (ll k = 0; k < K; ++k) {\n      ll l = k * sqrtN, r = (k + 1) * sqrtN;\n      if (r <= s || t <= l)\n        continue;\n      if (s <= l && r <= t) {\n        bucketSum[k] = x * sqrtN;\n        lazyUpdate[k] = x;\n      } else {\n        eval(k);\n        for (ll i = max(s, l); i < min(t, r); ++i) {\n          bucketSum[k] += x - data[i];\n          data[i] = x;\n        }\n      }\n    }\n  }\n  // [s, t)\n  ll find(ll s, ll t) {\n    ll ans = 0;\n    for (ll k = 0; k < K; ++k) {\n      ll l = k * sqrtN, r = (k + 1) * sqrtN;\n      if (r <= s || t <= l)\n        continue;\n      if (s <= l && r <= t) {\n        ans += bucketSum[k];\n      } else {\n        eval(k);\n        for (ll i = max(s, l); i < min(t, r); ++i) {\n          ans += data[i];\n        }\n      }\n    }\n    return ans;\n  }\n};\n\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  ll n, q;\n  cin >> n >> q;\n  SqrtDecomposition sd(n);\n  FOR(i,0,q) {\n    ll f;\n    cin >> f;\n    if(f) {\n      ll s,t;\n      cin >> s >> t;\n      cout << sd.find(s, t+1) << endl;\n    } else {\n      ll s,t,x;\n      cin >> s >> t >> x;\n      sd.update(s,t+1,x);\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\nconst int N=1e5+10;\nlong long int a[N*4];\nint f[N*4];\nbool b[N*4];\nvoid add(int n,int x,int l,int r,int L,int R){\n    if(L<=l&&r<=R){\n        f[n]=x;\n        b[n]=true;\n        a[n]=(long long int)x*(r-l+1);\n    }\n    else if(!(L>r||l>R)){\n        int mid=(l+r)>>1;\n        if(b[n]){\n            f[n*2+1]=f[n*2+2]=f[n];\n            a[n*2+1]=(long long int)f[n]*(mid-l+1);\n            a[n*2+2]=(long long int)f[n]*(r-mid);\n            b[n*2+1]=b[n*2+2]=true;\n            b[n]=false;\n        }\n        add(n*2+1,x,l,mid,L,R);\n        add(n*2+2,x,mid+1,r,L,R);\n        a[n]=a[n*2+1]+a[n*2+2];\n    }\n    return ;\n}\nlong long int sum(int n,int l,int r,int L,int R){\n    if(L<=l&&r<=R)return a[n];\n    else if(L>r||l>R)return 0;\n    int mid=(l+r)>>1;\n    if(b[n]){\n        f[n*2+1]=f[n*2+2]=f[n];\n        a[n*2+1]=(long long int)f[n]*(mid-l+1);\n        a[n*2+2]=(long long int)f[n]*(r-mid);\n        b[n*2+1]=b[n*2+2]=true;\n        b[n]=false;\n    }\n    return sum(n*2+1,l,mid,L,R)+sum(n*2+2,mid+1,r,L,R);\n}\nint main(){\n    int n,q,k,l,r;\n    memset(a,0,sizeof(a));\n    memset(f,0,sizeof(f));\n    memset(b,false,sizeof(b));\n    scanf(\"%d%d\",&n,&q);\n    n--;\n    while(q--){\n        scanf(\"%d\",&k);\n        if(k==0){\n            scanf(\"%d%d%d\",&l,&r,&k);\n            add(0,k,0,n,l,r);\n        }\n        else {\n            scanf(\"%d%d\",&l,&r);\n            printf(\"%lld\\n\",sum(0,0,n,l,r));\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\nconst int INF = 1e9;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = { 0, 1, 0, -1 }, dx4 = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\n\n\ntemplate <typename T> class LazySegmentTree {\nprivate:\n    const int array_size;\n    int n;\n    std::vector<T> data, lazy;\n    const function<T (T, T)> f;     // 要素に適用する演算\n    const function<T (T, T)> g;     // 作用素の適用\n    const function<T (T, T)> h;     // 作用素の合成\n    const function<T (T, int)> p;\n    const T unit;\n    const T lazy_unit;\n\npublic:\n    class Mode {\n    public:\n        function<T (T, T)> f;\n        function<T (T, T)> g;\n        function<T (T, T)> h;\n        function<T (T, int)> p;\n        T unit;\n        T lazy_unit;\n    };\n\n    enum Query {\n        RangeMinimumQuery,\n        RangeMaximumQuery,\n        RangeSummationQuery,\n    };\n\n    enum Operation {\n        Update,\n        Add,\n    };\n\n    LazySegmentTree(const std::vector<LL> &v, const Mode mode) : array_size(v.size()),  f(mode.f), g(mode.g), h(mode.h), p(mode.p), unit(mode.unit), lazy_unit(mode.lazy_unit){\n        n = 1;\n        while (n < array_size) { n *= 2; }\n        data.resize(2 * n - 1, unit);\n        lazy.resize(2 * n - 1, lazy_unit);\n\n        for (int i = 0; i < array_size; ++i) {\n            data[i + n - 1] = v[i];\n        }\n        for (int i = n - 2; i >= 0; i--) {\n            data[i] = f(data[i * 2 + 1], data[i * 2 + 2]);\n        }\n    }\n\n    static Mode getMode(const Query query, const Operation operation) {\n        Mode mode;\n        if (query == RangeMinimumQuery) {\n            mode.unit = INT_MAX;\n\n            mode.f = [](T a, T b) { return std::min(a, b); };\n            if (operation == Update) {\n                mode.lazy_unit = -1;\n                mode.g = [&](T a, T b) { return b == mode.lazy_unit ? a : b; };\n                mode.h = mode.g;\n                mode.p = [&](T a, int len) { return a; };\n            }\n            else if (operation == Add) {\n                mode.lazy_unit = 0;\n                mode.g = [](T a, T b) { return a + b; };\n                mode.h = mode.g;\n                mode.p = [](T a, int len) { return a; };\n            }\n        }\n        else if (query == RangeMaximumQuery) {\n            mode.unit = -INT_MAX;\n\n            mode.f = [](T a, T b) { return std::max(a, b); };\n            if (operation == Update) {\n                mode.lazy_unit = -1;\n                mode.g = [&](T a, T b) { return b == mode.lazy_unit ? a : b; };\n                mode.h = mode.g;\n                mode.p = [](T a, int len) { return a; };\n            }\n            else if (operation == Add) {\n                mode.lazy_unit = 0;\n                mode.g = [](T a, T b) { return a + b; };\n                mode.h = mode.g;\n                mode.p = [](T a, int len) { return a; };\n            }\n        }\n        else if (query == RangeSummationQuery) {\n            mode.unit = 0;\n\n            mode.f = [](T a, T b) { return a + b; };\n            if (operation == Update) {\n                mode.lazy_unit = INT_MAX;\n                mode.g = [&](T a, T b) { return b == mode.lazy_unit ? a : b;};\n                mode.h = mode.g;\n                mode.p = [&](T a, int len) {return a == mode.lazy_unit ? a : a * len;};\n            }\n            else if (operation == Add) {\n                mode.lazy_unit = 0;\n                mode.g = [](T a, T b) { return a + b;};\n                mode.h = [](T a, T b) { return a + b;};\n                mode.p = [](T a, int len) {return a * len;};\n            }\n        }\n        return mode;\n    }\n\n    // array[idx]\n    // log(N)\n    T access(const int idx) {\n        return query(idx, idx + 1, 0, 0, n);\n    }\n\n    // operation(array[idx], x)\n    // log(N)\n    void operation(const int idx, const T x) {\n        operation(idx, idx + 1, x);\n    }\n\n    // operation(array[left, right), x)\n    // log(N)\n    void operation(const int left, const int right, const T x) {\n        assert(0 <= left and left < right and right <= array_size);\n        operation(left, right, x, 0, 0, n);\n    }\n\n    // op(array[a, b))\n    // log(N)\n    T query(const int left, const int right) {\n        return query(left, right, 0, 0, n);\n    }\n\nprivate:\n    T operation(const int a, const int b, const T x, const int k, const int l, const int r) {\n        propagate(k, r - l);\n\n        // 範囲外\n        if (b <= l or r <= a) {\n            return data[k];\n        }\n        // 完全に含む\n        else if (a <= l and r <= b) {\n            lazy[k] = h(lazy[k], x);\n            propagate(k, r - l);\n            return g(data[k], p(lazy[k], r - l));\n        }\n        // 一部含む\n        else {\n            T lv = operation(a, b, x, 2 * k + 1, l, (l + r) / 2);    // 左の子\n            T rv = operation(a, b, x, 2 * k + 2, (l + r) / 2, r);    // 右の子\n            return data[k] = f(lv, rv);\n        }\n    }\n\n    // [a, b)の目的値をノードk（区間[l, r]）から検索\n    T query(const int a, const int b, const int k, const int l, const int r) {\n        propagate(k, r - l);\n\n        // 範囲外\n        if (b <= l or r <= a) {\n            return unit;\n        }\n        // 完全に含む\n        else if (a <= l && r <= b) {\n            return data[k];\n        }\n        // 一部含む\n        else {\n            T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);    // 左の子\n            T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);    // 右の子\n            return f(vl, vr);\n        }\n    }\n\n    void propagate(const int k, const int len) {\n        if (lazy[k] == lazy_unit) {\n            return;\n        }\n\n        if (len > 1) {\n            lazy[k * 2 + 1] = h(lazy[k * 2 + 1], lazy[k]);\n            lazy[k * 2 + 2] = h(lazy[k * 2 + 2], lazy[k]);\n        }\n        data[k] = g(data[k], p(lazy[k], len));\n        lazy[k] = lazy_unit;\n    }\n};\n\n\nusing namespace std;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, Q;\n    cin >> N >> Q;\n\n    vector<LL> v(N + 1 , 0);\n\n    auto mode = LazySegmentTree<LL>::getMode(LazySegmentTree<LL>::Query::RangeSummationQuery, LazySegmentTree<LL>::Operation::Update);\n    LazySegmentTree<LL> lst(v, mode);\n\n    FOR(_, 0, Q) {\n        int query, s, t, x, i;\n        cin >> query;\n        if (query == 0) {\n            cin >> s >> t >> x;\n            lst.operation(s, t + 1, x);\n        }\n        else {\n            cin >> s >> t;\n            print(lst.query(s, t + 1));\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <limits>\n#include <fstream>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\ntypedef long long ll;\nconst ll sqrtN = 512;\nstruct SqrtDecomposition {\n  ll N, K;\n  vector<ll> data;\n  vector<ll> bucketSum;\n  vector<ll> lazyUpdate;\n  SqrtDecomposition(ll n) : N(n) {\n    K = (N + sqrtN - 1) / sqrtN;\n    data.assign(K * sqrtN, 0);\n    bucketSum.assign(K, 0);\n    lazyUpdate.assign(K, 1111);\n  }\n  void eval(ll k) {\n    if (lazyUpdate[k] != 1111) {\n      for (ll i = k * sqrtN; i < (k + 1) * sqrtN; ++i) {\n        data[i] = lazyUpdate[k];\n      }\n      lazyUpdate[k] = 1111;\n    }\n  }\n  // [s, t)\n  void update(ll s, ll t, ll x) {\n    for (ll k = 0; k < K; ++k) {\n      ll l = k * sqrtN, r = (k + 1) * sqrtN;\n      if (r <= s || t <= l)\n        continue;\n      if (s <= l && r <= t) {\n        bucketSum[k] = x * sqrtN;\n        lazyUpdate[k] = x;\n      } else {\n        eval(k);\n        for (ll i = max(s, l); i < min(t, r); ++i) {\n          bucketSum[k] = x - data[i];\n          data[i] = x;\n        }\n      }\n    }\n  }\n  // [s, t)\n  ll find(ll s, ll t) {\n    ll ans = 0;\n    for (ll k = 0; k < K; ++k) {\n      ll l = k * sqrtN, r = (k + 1) * sqrtN;\n      if (r <= s || t <= l)\n        continue;\n      if (s <= l && r <= t) {\n        ans += bucketSum[k];\n      } else {\n        eval(k);\n        for (ll i = max(s, l); i < min(t, r); ++i) {\n          ans += data[i];\n        }\n      }\n    }\n    return ans;\n  }\n};\n\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  ll n, q;\n  cin >> n >> q;\n  SqrtDecomposition sd(n);\n  FOR(i,0,q) {\n    ll f;\n    cin >> f;\n    if(f) {\n      ll s,t;\n      cin >> s >> t;\n      cout << sd.find(s, t+1) << endl;\n    } else {\n      ll s,t,x;\n      cin >> s >> t >> x;\n      sd.update(s,t+1,x);\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <climits>\nusing namespace std;\n\ntemplate <typename MonoidType, typename OperatorType, class SegFunc>\nstruct LazySegmentTree {\n    // node, lazy, update flag (for lazy), identity element\n    int n;\n    vector<MonoidType> node;\n    vector<OperatorType> lazy;\n    vector<bool> need_update;\n    MonoidType E0;\n    OperatorType E1;\n\n    void build(int m, const vector<MonoidType> &v = vector<MonoidType>()) {\n        if(v != vector<MonoidType>()) m = v.size();\n        n = 1; while(n < m) n *= 2;\n\n        node = vector<MonoidType>(2*n-1, E0);\n        lazy = vector<OperatorType>(2*n-1, E1);\n        need_update = vector<bool>(2*n-1, false);\n        if(v != vector<MonoidType>()) {\n            for(int i=0; i<m; i++) {\n                node[n-1+i] = v[i];\n            }\n            for(int i=n-2; i>=0; i--) {\n                node[i] = SegFunc::combine(node[2*i+1], node[2*i+2]);\n            }\n        }\n    }\n\n    // initialize\n    LazySegmentTree() {}\n    LazySegmentTree(int n_, MonoidType E0_, OperatorType E1_,\n                    vector<MonoidType> v = vector<MonoidType>()) :\n        E0(E0_), E1(E1_) {\n        build(n_, v);\n    }\n\n    void eval(int k, int l, int r) {\n        if(!need_update[k]) return;\n        node[k] = SegFunc::update(node[k], SegFunc::accumulate(lazy[k], r - l));\n        if(r - l > 1) {\n            lazy[2*k+1] = SegFunc::lazy_update(lazy[2*k+1], lazy[k]);\n            lazy[2*k+2] = SegFunc::lazy_update(lazy[2*k+2], lazy[k]);\n            need_update[2*k+1] = need_update[2*k+2] = true;\n        }\n        lazy[k] = E1;\n        need_update[k] = false;\n    }\n\n    void update(int a, int b, OperatorType x, int l, int r, int k) {\n        eval(k, l, r);\n        if(b <= l or  r <= a) return;\n        if(a <= l and r <= b) {\n            lazy[k] = SegFunc::lazy_update(lazy[k], x);\n            need_update[k] = true;\n            eval(k, l, r);\n        }\n        else {\n            int mid = (l + r) / 2;\n            update(a, b, x, l, mid, 2*k+1);\n            update(a, b, x, mid, r, 2*k+2);\n            node[k] = SegFunc::combine(node[2*k+1], node[2*k+2]);\n        }\n    }\n\n    MonoidType query(int a, int b, int l, int r, int k) {\n        if(b <= l or  r <= a) return E0;\n        eval(k, l, r);\n        if(a <= l and r <= b) return node[k];\n        int mid = (l + r) / 2;\n        MonoidType vl = query(a, b, l, mid, 2*k+1);\n        MonoidType vr = query(a, b, mid, r, 2*k+2);\n        return SegFunc::combine(vl, vr);\n    }\n\n    // update [a, b)-th element (applied value, x)\n    void update(int a, int b, OperatorType x) {\n        update(a, b, x, 0, n, 0);\n    }\n\n    // range query for [a, b)\n    MonoidType query(int a, int b) {\n        return query(a, b, 0, n, 0);\n    }\n\n    void dump() {\n        fprintf(stderr, \"[lazy]\\n\");\n        for(int i=0; i<2*n-1; i++) {\n            if(i == n-1) fprintf(stderr, \"xxx \");\n            if(lazy[i] == E1) fprintf(stderr, \"  E \");\n            else fprintf(stderr, \"%3d \", lazy[i]);\n        }\n        fprintf(stderr, \"\\n\");\n\n        fprintf(stderr, \"[node]\\n\");\n        for(int i=0; i<2*n-1; i++) {\n            if(i == n-1) fprintf(stderr, \"xxx \");\n            if(node[i] == E0) fprintf(stderr, \"  E \");\n            else fprintf(stderr, \"%3d \", node[i]);\n        }\n        fprintf(stderr, \"\\n\");\n    }\n};\n\n\n// Verified on Apr 27, 2019\nvoid DSL_2_D() {\n    struct SegFunc {\n        static int update(int a, int b) { return b; }\n        static int combine(int a, int b) { return min(a, b); }\n        static int lazy_update(int a, int b) { return b; }\n        static int accumulate(int a, int b) { return a; }\n    };\n    \n    int N, Q; cin >> N >> Q;\n    LazySegmentTree<int, int, SegFunc> seg(N, INT_MAX, INT_MAX);\n    \n    int indexed = 0;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s; cin >> s;\n            s -= indexed;\n            cout << seg.query(s, s+1) << endl;\n        }\n        // seg.dump();\n    }\n}\n\n// Verified on Apr 27, 2019\nvoid DSL_2_E() {\n    struct SegFunc {\n        static int update(int a, int b) { return a + b; }\n        static int combine(int a, int b) { return a + b; }\n        static int lazy_update(int a, int b) { return a + b; }\n        static int accumulate(int a, int x) { return a * x; }\n    };\n\n    int N, Q; cin >> N >> Q;\n    LazySegmentTree<int, int, SegFunc> seg(N, 0, 0);\n    \n    int indexed = 1;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s; cin >> s;\n            s -= indexed;\n            cout << seg.query(s, s+1) << endl;\n        }\n        // seg.dump();\n    }    \n}\n\n// Verified on Apr 27, 2019\nvoid DSL_2_F() {\n    struct SegFunc {\n        static int update(int a, int b) { return b; }\n        static int combine(int a, int b) { return min(a, b); }\n        static int lazy_update(int a, int b) { return b; }\n        static int accumulate(int a, int x) { return a; }\n    };\n    \n    int N, Q; cin >> N >> Q;\n    LazySegmentTree<int, int, SegFunc> seg(N, INT_MAX, 0);\n    \n    int indexed = 0;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s, t; cin >> s >> t; t++;\n            s -= indexed; t -= indexed;\n            cout << seg.query(s, t) << endl;\n        }\n        // seg.dump();\n    }    \n}\n\n// Verified on Apr 27, 2019\nvoid DSL_2_G() {\n    using ll = long long int;\n    struct SegFunc {\n        static ll update(ll a, ll b) { return a + b; }\n        static ll combine(ll a, ll b) { return a + b; }\n        static ll lazy_update(ll a, ll b) { return a + b; }\n        static ll accumulate(ll a, ll x) { return a * x; }\n    };\n\n    int N, Q; cin >> N >> Q;\n    LazySegmentTree<ll, ll, SegFunc> seg(N, 0, 0);\n    \n    int indexed = 1;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s, t; cin >> s >> t; t++;\n            s -= indexed; t -= indexed;\n            cout << seg.query(s, t) << endl;\n        }\n        // seg.dump();\n    }    \n}\n\n// Verified on Apr 27, 2019\nvoid DSL_2_H() {\n    int N, Q; cin >> N >> Q;\n    using ll = long long int;\n\n    struct SegFunc {\n        static ll update(ll a, ll b) { return a + b; }\n        static ll combine(ll a, ll b) { return min(a, b); }\n        static ll lazy_update(ll a, ll b) { return a + b; }\n        static ll accumulate(ll a, ll x) { return a; }\n    };\n    \n    LazySegmentTree<ll, ll, SegFunc> seg(N, INT_MAX, 0, vector<ll>(N));\n    \n    int indexed = 0;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s, t; cin >> s >> t; t++;\n            s -= indexed; t -= indexed;\n            cout << seg.query(s, t) << endl;\n        }\n        // seg.dump();\n    }    \n}\n\n// Verified on Apr 27, 2019\nvoid DSL_2_I() {\n    int N, Q; cin >> N >> Q;\n    using ll = long long int;\n\n    struct SegFunc {\n        static ll update(ll a, ll b) { return b; }\n        static ll combine(ll a, ll b) { return a + b; }\n        static ll lazy_update(ll a, ll b) { return b; }\n        static ll accumulate(ll a, ll x) { return a * x; }\n    };\n\n    LazySegmentTree<ll, ll, SegFunc> seg(N, 0, 0, vector<ll>(N));\n    \n    int indexed = 0;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s, t; cin >> s >> t; t++;\n            s -= indexed; t -= indexed;\n            cout << seg.query(s, t) << endl;\n        }\n        // seg.dump();\n    }    \n}\n\n/*\nvoid yuki_749() {\n    int N, Q; cin >> N >> Q;\n\n    \n    \n}\n*/\n\nint main() {\n    // DSL_2_D();\n    // DSL_2_E();\n    // DSL_2_F();\n    // DSL_2_G();\n    // DSL_2_H();\n    DSL_2_I();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define repr(i, n) REPR(i, n, 0)\n#define REPR(i, s, e) for(int i=(int)(s-1); i>=(int)(e); i--)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\nusing ull = unsigned long long;\n\nconstexpr ll initVal = 0LL;     //TODO: fix type and value\nconstexpr ll initLazy = 1LL<<60;    //TODO: fix type and value\nconstexpr ll RangeOutVal = 0LL; // TODO: fix type and value\ntemplate <typename T>\nstruct Node {\n    T val;\n    T lazy;\n    ull l, r;\n    Node<T>* l_node = nullptr;\n    Node<T>* r_node = nullptr;\n    Node(ull l, ull r, const T& val = initVal) : l(l), r(r), val(val), lazy(initLazy) {}\n    T getVal() {\n        return (lazy == initLazy ? val : lazy*(r-l)); //TODO: fix\n    }\n    T f1(const T& a, const T& b) {\n        return a+b;               //TODO: fix\n    }\n    T f2(const T& a, const T& b) {\n        return b;                       //TODO: fix\n    }\n    void push() {\n        if(r - l > 1) {\n            auto m = (l+r)/2;\n            {\n                if(l_node == nullptr) l_node = new Node(l, m);\n                if(lazy != initLazy) l_node->lazy = f2(l_node->lazy, this->lazy);\n            }\n            {\n                if(r_node == nullptr) r_node = new Node(m, r);\n                if(lazy != initLazy) r_node->lazy = f2(r_node->lazy, this->lazy); \n            }\n        }\n        val = getVal();\n        lazy = initLazy;\n    }\n    void fix() {\n        if(r - l == 1) return;\n        val = f1(l_node->getVal(), r_node->getVal());\n    }\n    T query(ull qL, ull qR) {\n        if(qR <= l || r <= qL) return RangeOutVal;\n        if(qL <= l && r <= qR) return getVal();\n        if(r - l == 1)  return getVal();\n\n        push();\n        T l_val = l_node->query(qL, qR), r_val = r_node->query(qL, qR);\n        return f1(l_val, r_val);\n    }\n    void update(ull uL, ull uR, const T& uVal) {\n        if(uR <= l || r <= uL) return;\n        if(uL <= l && r <= uR) lazy = f2(lazy, uVal);\n        else {\n            push();\n            l_node->update(uL, uR, uVal);\n            r_node->update(uL, uR, uVal);\n            fix();\n        }\n    }\n    void printNode() {\n        cout << \"(\" << l <<\", \" << r << \") -> \" << val << \", \" << lazy << endl;\n        if(l_node != nullptr) l_node->printNode(); \n        if(r_node != nullptr) r_node->printNode(); \n    }\n};\n\ntemplate <typename T>\nstruct DynamicLazySegTree {\n    Node<T> root;\n    DynamicLazySegTree(ull l, ull r, const T& val) : root(l, r, val) {}\n    T query(ull l, ull r) {\n        return root.query(l, r);\n    }\n    void update(ull l, ull r, const T& val) {\n        root.update(l, r, val);\n    }\n};\n\n\n\nint main(){\n    int n, q;\n    cin >> n >> q;\n    {\n        int _n = n;\n        n = 1;\n        while(n < _n) n *= 2;\n    }\n    DynamicLazySegTree<ll> st(0, n, initVal);\n    rep(i, q) {\n        int query;\n        cin >> query;\n        if(query == 0) {\n            int s, t, x;\n            cin >> s >> t >> x;\n            ++t;\n            // cout << s << \" \" << t << \" \" << x << endl;\n            st.update(s, t, x);\n        }\n        else {\n            int s, t;\n            cin >> s >> t;\n            ++t;\n            // cout << s << \" \" << t << endl;\n            cout << st.query(s, t) << endl;\n        }\n        // st.root.printNode();\n        // cout << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define int long long\nusing namespace std;\n\nconst int DEPTH = 17;\n\nstruct SegTree {\n\tint lazyT[1 << DEPTH + 1];\n\tint lazyV[1 << DEPTH + 1];\n\tint segSum[1 << DEPTH + 1];\n\t\n\tSegTree() {\n\t\tfor (int i = 0; i < (1 << DEPTH + 1); i++) {\n\t\t\tlazyT[i] = -1;\n\t\t\tlazyV[i] = 0;\n\t\t\tsegSum[i] = 0;\n\t\t}\n\t}\n\t\n\tvoid lazy_evaluate(int id, int len) {\n\t\tif (lazyT[id] == -1) return;\n\t\t\n\t\tsegSum[id] = lazyV[id] * len;\n\t\tif (id < (1 << DEPTH) - 1) {\n\t\t\tif (lazyT[id * 2 + 1] < lazyT[id]) {\n\t\t\t\tlazyT[id * 2 + 1] = lazyT[id];\n\t\t\t\tlazyV[id * 2 + 1] = lazyV[id];\n\t\t\t}\n\t\t\tif (lazyT[id * 2 + 2] < lazyT[id]) {\n\t\t\t\tlazyT[id * 2 + 2] = lazyT[id];\n\t\t\t\tlazyV[id * 2 + 2] = lazyV[id];\n\t\t\t}\n\t\t}\n\t\tlazyT[id] = -1;\n\t}\n\t\n\tvoid update(int l, int r, int x, int Time, int a = 0, int b = 1 << DEPTH, int id = 0) {\n\t\tlazy_evaluate(id, b - a);\n\t\t\n\t\tif (a >= r || b <= l) return;\n\t\tif (l <= a && b <= r) {\n\t\t\tlazyT[id] = Time;\n\t\t\tlazyV[id] = x;\n\t\t\tlazy_evaluate(id, b - a);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tupdate(l, r, x, Time, a, (a + b) / 2, id * 2 + 1);\n\t\tupdate(l, r, x, Time, (a + b) / 2, b, id * 2 + 2);\n\t\tsegSum[id] = segSum[id * 2 + 1] + segSum[id * 2 + 2];\n\t}\n\t\n\tint getSum(int l, int r, int a = 0, int b = 1 << DEPTH, int id = 0) {\n\t\tif (a >= r || b <= l) return 0;\n\t\t\n\t\tlazy_evaluate(id, b - a);\n\t\tif (l <= a && b <= r) {\n\t\t\treturn segSum[id];\n\t\t}\n\t\t\n\t\tint res1 = getSum(l, r, a, (a + b) / 2, id * 2 + 1);\n\t\tint res2 = getSum(l, r, (a + b) / 2, b, id * 2 + 2);\n\t\treturn res1 + res2;\n\t}\n};\n\nSegTree seg;\n\nsigned main() {\n\tint n, q;\n\tcin >> n >> q;\n\t\n\tfor (int i = 0; i < q; i++) {\n\t\tint type;\n\t\tcin >> type;\n\t\tif (type == 0) {\n\t\t\tint s, t, x;\n\t\t\tcin >> s >> t >> x;\n\t\t\tseg.update(s, t + 1, x, i);\n\t\t}\n\t\telse {\n\t\t\tint s, t;\n\t\t\tcin >> s >> t;\n\t\t\tcout << seg.getSum(s, t + 1) << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define N 100000\n#define MAX (1<<31)-1\nusing namespace std;\nlong long A[N], T[4*N], lazy[4*N];\n\nvoid build(int l, int r, int k) {\n    if (l == r) {\n        T[k] = A[l];\n        return;\n    }\n    int mid = (l + r) / 2;\n    build(l, mid, k * 2);\n    build(mid + 1, r, k * 2 + 1);\n    T[k] = T[2 * k] + T[2 * k + 1];\n}\nvoid pushdown(int k, int l, int r, int mid) {\n    if (lazy[k] != MAX) {\n        lazy[2*k] = lazy[k];\n        lazy[2*k+1] = lazy[k];\n        T[2*k] = lazy[k]*(mid-l+1);\n        T[2*k+1] = lazy[k]*(r-mid);\n        lazy[k] = MAX;\n    }\n}\nvoid updata(int L, int R, int data ,int l, int r ,int k) {\n    if (L <= l && r <= R) {\n        T[k] = data*(r-l+1);\n        lazy[k] = data;\n        return;\n    }\n    int mid = (l + r) / 2;\n    pushdown(k, l, r, mid);\n    if (mid >= L) updata(L, R, data, l, mid, 2*k);\n    if (mid < R) updata(L, R, data, mid+1, r, 2*k+1);\n    T[k] = T[2 * k] + T[2 * k + 1];\n}\nlong long find(int L, int R, int l, int r, int k) {\n    if (L <= l && r <= R) return T[k];\n    int mid = (l + r) / 2;\n    pushdown(k, l, r, mid);\n    long long ans = 0;\n    if (mid >= L) ans = ans + find(L, R, l, mid, k * 2);\n    if (mid < R) ans = ans + find(L, R, mid + 1, r, k * 2 + 1);\n    return ans;\n}\nint main() {\n    int n, q;\n    scanf(\"%d%d\", &n, &q);\n    for (int i = 0; i < n; i++)\n        A[i] = 0;\n    for (int i = 0; i < 4*n; i++)\n        lazy[i] = MAX;\n    build(0, n - 1, 1);\n    int com, s, t, x, y;\n    while (q--) {\n        scanf(\"%d\", &com);\n        if (com == 0) {\n            scanf(\"%d%d%d\", &s, &t, &x);\n            updata(s, t, x, 0, n - 1, 1);\n        }\n        else {\n            scanf(\"%d%d\", &s, &t);\n            printf(\"%ld\\n\", find(s, t, 0, n - 1, 1));\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\ntemplate <typename T,typename E>\nstruct SegmentTree{\n\ttypedef function<T(T,T)> F;\n\ttypedef function<T(T,E)> G;\n\ttypedef function<E(E,E)> H;\n\ttypedef function<E(E,int)> P;\n\tint n;\n\tF f;\n\tG g;\n\tH h;\n\tP p;\n\tT d1;\n\tE d0;\n\tvector<T> dat;\n\tvector<E> laz;\n\n\tSegmentTree(int n_,\n\t\t\t\tF f,//要素と要素をマージする関数\n\t\t\t\tG g,//要素に作用素を作用させる関数\n\t\t\t\tH h,//作用素と作用素をマージする関数\n\t\t\t\tT d1,//要素のモノイド\n\t\t\t\tE d0,//作用素のモノイド\n\t\t\t\tvector<T> v=vector<T>(),\n\t\t\t\tP p=[](E a,int b){return a;})://区間に対する操作が要素数に比例して変化する場合\n\tf(f),g(g),h(h),d1(d1),d0(d0),p(p){\n\t\tinit(n_);\n\t\tif(n_==(int)v.size()) build(n_,v);\n\t}\n\t\n\tvoid init(int n_){\n\t\tn=1;\n\t\twhile(n<n_) n*=2;\n\t\tdat.clear();\n\t\tdat.resize(2*n-1,d1);\n\t\tlaz.clear();\n\t\tlaz.resize(2*n-1,d0);\n\t}\n\t\n\tvoid build(int n_, vector<T> v){\n\t\tfor(int i=0;i<n_;i++) dat[i+n-1]=v[i];\n\t\tfor(int i=n-2;i>=0;i--){\n\t\t\tdat[i]=f(dat[i*2+1],dat[i*2+2]);\n\t\t}\n\t}\n\t\n\tinline void eval(int len,int k){\n\t\tif(laz[k]==d0) return;\n\t\tif(k*2+1<n*2-1){\n\t\t\tlaz[k*2+1]=h(laz[k*2+1],laz[k]);\n\t\t\tlaz[k*2+2]=h(laz[k*2+2],laz[k]);\n\t\t}\n\t\tdat[k]=g(dat[k],p(laz[k],len));\n\t\tlaz[k]=d0;\n\t}\n\t\n\t\n\tT update(int a,int b,E x,int k,int l,int r){\n\t\teval(r-l,k);\n\t\tif(r<=a||b<=l) return dat[k];\n\t\tif(a<=l&&r<=b){\n\t\t\tlaz[k]=h(laz[k],x);\n\t\t\treturn g(dat[k],p(laz[k],r-l));\n\t\t}\n\t\treturn dat[k]=f(update(a,b,x,k*2+1,l,(l+r)/2),\n\t\t\t\tupdate(a,b,x,k*2+2,(l+r)/2,r));\n\t}\n\t\n\tT update(int a,int b,E x){\n\t\treturn update(a,b,x,0,0,n);\n\t}\n\t\n\tT query(int a,int b,int k,int l,int r){\n\t\teval(r-l,k);\n\t\tif(r<=a||b<=l) return d1;\n\t\tif(a<=l&&r<=b) return dat[k];\n\t\tT vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\tT vr=query(a,b,k*2+2,(l+r)/2,r);\n\t\treturn f(vl,vr);\n\t}\n\t\n\tT query(int a,int b){\n\t\treturn query(a,b,0,0,n);\n\t}\n};\n/**\n\tSegmentTree(int n_,\n\t\t\t\tF f,//要素と要素をマージする関数\n\t\t\t\tG g,//要素に作用素を作用させる関数\n\t\t\t\tH h,//作用素と作用素をマージする関数\n\t\t\t\tT d1,//要素のモノイド\n\t\t\t\tE d0,//作用素のモノイド\n\t\t\t\tvector<T> v=vector<T>(),//初期配列\n\t\t\t\tP p=[](E a,int b){return a;})://区間に対する操作が要素数に比例して変化する場合\n\t\t\t\t\n\t区間加算、区間和\n\tSegmentTree<ll,ll> seg(n,\n\t[](ll a,ll b){return a + b;},\n\t[](ll a,ll b){return a + b;},\n\t[](ll a,ll b){return a + b;},\n\t0,\n\t0,\n\tvector<ll>(n,0),\n\t[](ll a,int b){return a * b;});\n\t\n\t区間更新、区間最小\n\tSegmentTree<ll,ll> seg(n,\n\t[](ll a,ll b){return min(a, b);},\n\t[](ll a,ll b){return b;},\n\t[](ll a,ll b){return b;},\n\tINF,\n\tINF,\n\tvector<ll>(n,INF),\n\t[](ll a,int b){return a;});\n\t\n\t区間加算、区間最小\n\t\n\tSegmentTree<ll,ll> seg(n,\n\t[](ll a,ll b){return min(a, b);},\n\t[](ll a,ll b){return a + b;},\n\t[](ll a,ll b){return a + b;},\n\tINF,\n\t0,\n\tvector<ll>(n,0),\n\t[](ll a,int b){return a;});\n\n**/\n\nint main(){\n\t\n\tint n,q;cin >> n >> q;\n\t\n\tSegmentTree<ll,ll> seg(n,\n\t[](ll a,ll b){return a + b;},\n\t[](ll a,ll b){return b;},\n\t[](ll a,ll b){return b;},\n\t0,\n\tINF,\n\tvector<ll>(n,0),\n\t[](ll a,int b){return a * b;});\n\t\n\tREP(i,q){\n\t\tint type;cin >> type;\n\t\tif(type == 0){\n\t\t\tint a,b,c;cin >> a >> b >> c;\n\t\t\tseg.update(a,b+1,c);\n\t\t}\n\t\telse {\n\t\t\tint a,b;cin >> a >> b;\n\t\t\tcout << seg.query(a,b+1) << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long int\n#define MOD(x) ((x % MOD_N) + MOD_N) % MOD_N\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define RFORE(i,a,b) for(int i=(b);i>=(a);--i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define RALL(c) (c).rbegin(),(c).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(c) (int)((c).size())\n#define EACH(i,v) for(auto i=v.begin();i!=v.end();++i)\n#define REACH(i,v) for(auto i=v.rbegin();i!=v.rend();++i)\n#define LB(c,x) distance((c).begin(),lower_bound(ALL(c),x))\n#define UB(c,x) distance((c).begin(),upper_bound(ALL(c),x))\n#define COUNT(c,x) (lower_bound(ALL(c),x)-upper_bound(ALL(c),x))\n#define UNIQUE(c) SORT(c); (c).erase(unique(ALL(c)),(c).end());\n#define COPY(c1,c2) copy(ALL(c1),(c2).begin())\n#define EXIST(s,e) (bool)((s).find(e)!=(s).end())\n#define PB push_back\n#define MP make_pair\n#define DUMP(x)  cerr<<#x<<\" = \"<<(x)<<endl;\n#define NL cerr<<endl;\nusing namespace std;\ntemplate<typename T,typename U> using P=pair<T,U>;\ntemplate<typename T> using V=vector<T>;\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T sum(vector<T>&v){return accumulate(ALL(v),T());}\ntemplate<typename T>T sum(vector<T>&v,int a,int b){return accumulate(v.begin()+a,v.begin()+b,T());}\ntemplate<typename T>T max(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T min(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T max_index(vector<T>&v){return distance((v).begin(),max_element(ALL(v)));}\ntemplate<typename T>T min_index(vector<T>&v){return distance((v).begin(),min_element(ALL(v)));}\n\nstruct edge { int to, cost; };\n\ntemplate<typename T>auto&operator<<(ostream&s,const vector<T>&v){s<<\"[\";bool a=1;for(auto e:v){s<<(a?\"\":\" \")<<e;a=0;}s<<\"]\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const pair<T,U>&p){s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return s;}\ntemplate<typename T>auto&operator<<(ostream&s,const set<T>&st){s<<\"{\";bool a=1;for(auto e:st){s<<(a?\"\":\" \")<<e;a=0;}s<<\"}\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const map<T,U>&m){s<<\"{\";bool a=1;for(auto e:m){s<<(a?\"\":\" \")<<e.first<<\":\"<<e.second;a=0;}s<<\"}\";return s;}\n\nconst int INF = 1e18;\nconst int MOD_N = 1e9+7;\n\ntemplate< typename Monoid, typename OperatorMonoid = Monoid >\nstruct LazySegmentTree {\n   using F = function< Monoid(Monoid, Monoid) >;\n   using G = function< Monoid(Monoid, OperatorMonoid, int) >;\n   using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n   int sz;\n   vector< Monoid > data;\n   vector< OperatorMonoid > lazy;\n   const F f;\n   const G g;\n   const H h;\n   const Monoid M1;\n   const OperatorMonoid OM0;\n   LazySegmentTree(int n, const F f, const G g, const H h,\n                   const Monoid &M1, const OperatorMonoid OM0)\n         : f(f), g(g), h(h), M1(M1), OM0(OM0) {\n      sz = 1;\n      while(sz < n) sz <<= 1;\n      data.assign(2 * sz, M1);\n      lazy.assign(2 * sz, OM0);\n   }\n\n   void set(int k, const Monoid &x) {\n      data[k + sz] = x;\n   }\n   void build() {\n      for(int k = sz - 1; k > 0; k--) {\n         data[k] = f(data[2 * k + 0], data[2 * k + 1]);\n      }\n   }\n   void propagate(int k, int len) {\n      if(lazy[k] != OM0) {\n         if(k < sz) {\n            lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n            lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n         }\n         data[k] = g(data[k], lazy[k], len);\n         lazy[k] = OM0;\n      }\n   }\n   Monoid update(int a, int b, const OperatorMonoid &x, int k, int l, int r) {\n      propagate(k, r - l);\n      if(r <= a || b <= l) {\n         return data[k];\n      } else if(a <= l && r <= b) {\n         lazy[k] = h(lazy[k], x);\n         propagate(k, r - l);\n         return data[k];\n      } else {\n         return data[k] = f(update(a, b, x, 2 * k + 0, l, (l + r) >> 1),\n                            update(a, b, x, 2 * k + 1, (l + r) >> 1, r));\n      }\n   }\n   Monoid update(int a, int b, const OperatorMonoid &x) {\n      return update(a, b, x, 1, 0, sz);\n   }\n   Monoid query(int a, int b, int k, int l, int r) {\n      propagate(k, r - l);\n      if(r <= a || b <= l) {\n         return M1;\n      } else if(a <= l && r <= b) {\n         return data[k];\n      } else {\n         return f(query(a, b, 2 * k + 0, l, (l + r) >> 1),\n                  query(a, b, 2 * k + 1, (l + r) >> 1, r));\n      }\n   }\n   Monoid query(int a, int b) {\n      return query(a, b, 1, 0, sz);\n   }\n   Monoid operator[](const int &k) {\n      return query(k, k + 1);\n   }\n};\ntemplate<typename T> struct RSQ_RUQ {\n   LazySegmentTree<T> lsegt;\n   RSQ_RUQ(int n) : lsegt(n,\n      [](T a,T b){ return a + b; },\n      [](T a,T b,T c){ return b * c; },\n      [](T a,T b){ return b; }, 0, INF){}\n   void update(int a, int b, T x) { lsegt.update(a, b, x); }\n   T query(int a, int b) { lsegt.query(a, b); }\n};\n\nsigned main()\n{\n   int n, q; cin >> n >> q;\n   V<int> c(q), s(q), t(q), x(q);\n   REP(i, q) {\n      cin >> c[i];\n      if (c[i] == 0) {\n         cin >> s[i] >> t[i] >> x[i];\n      } else {\n         cin >> s[i] >> t[i];\n      }\n   }\n   // LazySegmentTree<int> lsegt(n,\n   //       [](int a,int b){ return a + b; },\n   //       [](int a,int b,int c){ return b * c; },\n   //       [](int a,int b){ return b; }, 0, INF);\n   RSQ_RUQ<int> rsqruq(n);\n   REP(i, q) {\n      if (c[i] == 0) {\n         rsqruq.update(s[i], t[i]+1, x[i]);\n      } else {\n         cout << rsqruq.query(s[i], t[i]+1) << endl;\n      }\n   }\n\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int64_t;\nusing vi = vector<i64>;\nusing vvi = vector<vi>;\n\ntemplate <class T, class T2>\nclass LazySegTree {\n    using F = function<T(T, T)>;\n    using G = function<T(T, T2)>;\n    using H = function<T2(T2, T2)>;\n    using P = function<T2(T2, int)>;\n    int n;\n    vector<T> data;\n    vector<T2> lazy;\n    const F f;\n    const G g;\n    const H h;\n    const P p;\n    const T e;\n    const T2 e2;\n\npublic:\n    LazySegTree(const vector<T>& as, const F f, const G g, const H h, const P p, const T& e, const T2 e2) : f(f), g(g), h(h), p(p), e(e), e2(e2) {\n        n = 1;\n        while (n < as.size()) n <<= 1;\n        data.assign(2 * n, e);\n        lazy.assign(2 * n, e2);\n        for (int i = 0; i < as.size(); i++) {\n            data[n + i] = as[i];\n        }\n        for (int i = n - 1; i > 0; i--) {\n            data[i] = f(data[2 * i], data[2 * i + 1]);\n        }\n    }\n\n    void propagate(int k, int len) {\n        if (lazy[k] != e2) {\n            if (k < n) {\n                lazy[2 * k] = h(lazy[2 * k], lazy[k]);\n                lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n            }\n            data[k] = g(data[k], p(lazy[k], len));\n            lazy[k] = e2;\n        }\n    }\n\n    T update(int a, int b, const T2& x, int k, int l, int r) {\n        propagate(k, r - l);\n        if (r <= a || b <= l) {\n            return data[k];\n        } else if (a <= l && r <= b) {\n            lazy[k] = h(lazy[k], x);\n            propagate(k, r - l);\n            return data[k];\n        } else {\n            return data[k] = f(update(a, b, x, 2 * k, l, (l + r) >> 1), update(a, b, x, 2 * k + 1, (l + r) >> 1, r));\n        }\n    }\n\n    T update(int a, int b, const T2& x) {\n        return update(a, b, x, 1, 0, n);\n    }\n\n    T query(int a, int b, int k, int l, int r) {\n        propagate(k, r - l);\n        if (r <= a || b <= l) {\n            return e;\n        } else if (a <= l && r <= b) {\n            return data[k];\n        } else {\n            return f(query(a, b, 2 * k, l, (l + r) >> 1), query(a, b, 2 * k + 1, (l + r) >> 1, r));\n        }\n    }\n\n    T query(int a, int b) {\n        return query(a, b, 1, 0, n);\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    vi as(n);\n\n    // RUQ, RMQ\n    // auto f = [](i64 a, i64 b) {return min(a, b);};\n    // auto g = [](i64 a, i64 b) {return b < 0 ? a : b;};\n    // auto h = [](i64 a, i64 b) {return b < 0 ? a : b;};\n    // auto p = [](i64 a, int b) {return a;};\n    // LazySegTree<i64, i64> tree(as, f, g, h, p, 1e18, -1);\n\n    // RAQ, RMQ\n    // auto f = [](i64 a, i64 b) {return min(a, b);};\n    // auto g = [](i64 a, i64 b) {return a + b;};\n    // auto h = [](i64 a, i64 b) {return a + b;};\n    // auto p = [](i64 a, i64 b) {return a;};\n    // LazySegTree<i64, i64> tree(as, f, g, h, p, 1e18, 0);\n\n    // RUQ, RSQ\n    const i64 INF = 1e18;\n    auto f = [](i64 a, i64 b) {return a + b;};\n    auto g = [](i64 a, i64 b) {return b == INF ? a : b;};\n    auto h = [](i64 a, i64 b) {return b == INF ? a : b;};\n    auto p = [](i64 a, i64 b) {return a == INF ? INF : a * b;};\n    LazySegTree<i64, i64> tree(as, f, g, h, p, 0, INF);\n\n    int q;\n    cin >> q;\n    while (q--) {\n        int c;\n        cin >> c;\n        if (c == 0) {\n            int s, t, x;\n            cin >> s >> t >> x;\n            tree.update(s, t + 1, x);\n        } else {\n            int s, t;\n            cin >> s >> t; \n            cout << tree.query(s, t + 1) << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\ntemplate<typename T, typename E> struct LazySegmentTree;\n\ntemplate<typename T, typename E> struct QueryObject {\n  LazySegmentTree<T, E> *lst;\n  int a, b;\n  E x;\n  int k;\n  int l, r;\n  QueryObject(LazySegmentTree<T, E> *lst_,\n      int a, int b, E x = 0, int k = 0, int l = 0, int r = -1)\n      : a(a), b(b), x(x), k(k), l(l), r(r) {\n    lst = lst_;\n  }\n};\n\ntemplate<typename T, typename E> struct QueryType {\n  virtual int outOfRange(QueryObject<T, E> o) = 0;\n  virtual int cover(QueryObject<T, E> o) = 0;\n  virtual int join(QueryObject<T, E> o, T vl, T vr) = 0;\n  T query(QueryObject<T, E> o) {\n    if (o.r < 0) o.r = o.lst->n;\n    o.lst->eval(o.r - o.l, o.k);\n    if (o.b <= o.l || o.r <= o.a) return outOfRange(o);\n    if (o.a <= o.l && o.r <= o.b) return cover(o);\n    QueryObject<T, E> o1 = o, o2 = o;\n    o1.k = o.k * 2 + 1; o1.r = (o.l + o.r) / 2;\n    o2.k = o.k * 2 + 2; o2.l = (o.l + o.r) / 2;\n    T vl = query(o1);\n    T vr = query(o2);\n    return join(o, vl, vr);\n  }\n};\n\ntemplate<typename T, typename E> struct Setter : QueryType<T, E> {\n  enum setter { RUQ, RAQ };\n  int outOfRange(QueryObject<T, E> o) {\n    return o.lst->data[o.k];\n  }\n  int cover(QueryObject<T, E> o) {\n    o.lst->lazy[o.k] = o.lst->h(o.lst->lazy[o.k], o.x);\n    o.lst->eval(o.r - o.l, o.k);\n    return o.lst->data[o.k];\n  }\n  int join(QueryObject<T, E> o, T vl, T vr) {\n    return o.lst->data[o.k] = o.lst->f(vl, vr);\n  }\n};\n\ntemplate<typename T, typename E> struct Getter : QueryType<T, E> {\n  enum getter { RMQ, RSQ };\n  int outOfRange(QueryObject<T, E> o) {\n    return o.lst->initT;\n  }\n  int cover(QueryObject<T, E> o) {\n    return o.lst->data[o.k];\n  }\n  int join(QueryObject<T, E> o, T vl, T vr) {\n    return o.lst->f(vl, vr);\n  }\n};\n\ntemplate<typename T, typename E> struct LazySegmentTree {\n  using F = function<T(T, T)>;\n  using G = function<T(T, E)>;\n  using H = function<E(E, E)>;\n  using P = function<E(E, int)>;\n\n  F add() {\n    return [&](const T& x, const T& y) -> const T { return x + y; };\n  }\n  F minimum() {\n    return [&](const T& x, const T& y) -> const T { return min(x, y); };\n  }\n  G ex_assign(E initE) {\n    return [&initE](const T& x, const E& y) -> const T { return (y == initE) ? x : y; };\n  }\n  P ex_multiplies(E initE) {\n    return [&initE](const E& x, int y) -> const E { return (x == initE) ? x : x * y; };\n  }\n\n  int n;\n  T initT;\n  E initE;\n  F f;\n  G g;\n  H h;\n  P p;\n  vector<T> data;\n  vector<E> lazy;\n  QueryType<T, E> *type;\n\n  LazySegmentTree() {}\n  LazySegmentTree(QueryType<T, E> *type_) { type = type_; }\n  LazySegmentTree(int n_, int setter, int getter,\n      T initT_ = INT_MAX, E initE_ = INT_MAX, vector<T> v = vector<T>()) {\n    setQuery(setter, getter, initT_, initE_);\n    n = 1;\n    while (n < n_) n *= 2;\n    data.assign(n * 2 - 1, initT);\n    lazy.assign(n * 2 - 1, initE);\n    if (n_ == v.size()) build(v);\n  }\n  void build(vector<T> v) {\n    for (int i = 0; i < v.size(); ++i) data[i + n - 1] = v[i];\n    for (int i = n - 2; i >= 0; --i) {\n      data[i] = f(data[i * 2 + 1], data[i * 2 + 2]);\n    }\n  }\n  void setQuery(int setter, int getter, T initT_, E initE_) {\n    initT = vector<T>{initT_, 0}[getter];\n    initE = vector<E>{initE_, 0}[setter];\n    f = vector<F>{minimum(), add()}[getter];\n    g = vector<G>{ex_assign(initE), add()}[setter];\n    h = vector<H>{ex_assign(initE), add()}[setter];\n    p = ex_multiplies(initE);\n  }\n  inline void eval(int len, int k) {\n    if (lazy[k] == initE) return;\n    if (k * 2 + 1 < n * 2 - 1) {\n      lazy[k * 2 + 1] = h(lazy[k * 2 + 1], lazy[k]);\n      lazy[k * 2 + 2] = h(lazy[k * 2 + 2], lazy[k]);\n    }\n    data[k] = g(data[k], p(lazy[k], len));\n    lazy[k] = initE;\n  }\n  T query(QueryObject<T, E>& obj) {\n    return type->query(obj);\n  }\n  T setData(int a, int b, E x) {\n    LazySegmentTree<T, E> lst(new Setter<T, E>());\n    QueryObject<T, E> obj(this, a, b, x);\n    return lst.query(obj);\n  }\n  T getData(int a, int b) {\n    LazySegmentTree<T, E> lst(new Getter<T, E>());\n    QueryObject<T, E> obj(this, a, b);\n    return lst.query(obj);\n  }\n};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, q; cin >> n >> q;\n  LazySegmentTree<ll, ll> seg(n, Setter<ll, ll>::RUQ, Getter<ll, ll>::RSQ);\n\n  while (q--) {\n    int com; cin >> com;\n    if (com) {\n      int s, t; cin >> s >> t;\n      cout << seg.getData(s, t + 1) << endl;\n    } else {\n      int s, t, x; cin >> s >> t >> x;\n      seg.setData(s, t + 1, x);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\nusing namespace std;\n#define Ma_PI 3.141592653589793\n#define eps 0.00000001\n#define LONG_INF 3000000000000000000\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define REP(i,n) for(long long i = 0;i < n;++i)    \n#define seg_size 524288\n#define int long long\nint seg_tree[seg_size*4];\nint seg_sub[seg_size*4];\nint seg_set(int now,int cnt){\n    if(seg_sub[now*2] != -10000){\n        seg_tree[now*2] = seg_sub[now*2] * cnt;\n        seg_sub[now*2*2] = seg_sub[now*2];\n        seg_sub[now*2*2+1] = seg_sub[now*2];\n        seg_sub[now*2] = -10000;\n    }\n    if(seg_sub[now*2+1] != -10000){\n        seg_tree[(now*2+1)] = seg_sub[(now*2+1)] * cnt;\n        seg_sub[(now*2+1)*2] = seg_sub[(now*2+1)];\n        seg_sub[(now*2+1)*2+1] = seg_sub[(now*2+1)];\n        seg_sub[(now*2+1)] = -10000;\n    }\n    seg_tree[now] = seg_tree[now*2] + seg_tree[now*2+1];\n    if(now > 1){\n        seg_set(now/2,cnt*2);\n    }\n    return 0;\n}\nint seg_find(int now,int n_l,int n_r,int w_l,int w_r){\n    if(seg_sub[now] != -10000){\n        seg_tree[now] = seg_sub[now] * (n_r - n_l);\n        seg_sub[now*2] = seg_sub[now];\n        seg_sub[now*2+1] = seg_sub[now];\n        seg_sub[now] = -10000;\n    }\n    if(w_l <= n_l&&n_r <= w_r) return seg_tree[now];\n    if(n_r <= w_l||w_r <= n_l) return 0;\n    return seg_find(now*2,n_l,(n_l+n_r)/2,w_l,w_r)+seg_find(now*2+1,(n_l+n_r)/2,n_r,w_l,w_r);\n}\nint seg_add(int now,int n_l,int n_r,int w_l,int w_r,int setting){\n    if(seg_sub[now] != -10000){\n        seg_tree[now] = seg_sub[now] * (n_r - n_l);\n        seg_sub[now*2] = seg_sub[now];\n        seg_sub[now*2+1] = seg_sub[now];\n        seg_sub[now] = -10000;\n    }\n    if(w_l <= n_l&&n_r <= w_r){\n        seg_sub[now] = setting;\n        seg_set(now/2,n_r - n_l);\n        return seg_tree[now];\n    }\n    if(n_r <= w_l||w_r <= n_l) return (1LL << 31LL) - 1LL;\n    return min(seg_add(now*2,n_l,(n_l+n_r)/2,w_l,w_r,setting),seg_add(now*2+1,(n_l+n_r)/2,n_r,w_l,w_r,setting));\n}\n#undef int\nint main(){\n#define int long long\n    int n,m;\n    cin >> n >> m;\n    REP(i,seg_size*4){\n        seg_tree[i] = 0;\n        seg_sub[i] = -10000;\n    }\n    REP(i,m){\n        int a;\n        cin >> a;\n        if(a == 0){\n            int b,c,d;\n            cin >> b >> c >> d;\n            seg_add(1,0,seg_size,b,c+1,d);\n        }else{\n            int b,c;\n            cin >> b >> c;\n            cout << seg_find(1,0,seg_size,b,c+1) << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cwchar>\n#include <cwctype>\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <codecvt>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#include <shared_mutex>\n\n#ifdef DEBUG\n#include \"libs/debug.cpp\"\n#define DEBUG 1\n#else\n#define DEBUG 0\n#endif\n\n#define rep(i, n) repr((i), 0, (n))\n#define repr(i, a, t) reps((i), (a), (t), 1)\n#define reps(i, a, t, s) for (long long (i) = (a); (i) < (long long)(t); (i) += (s))\n#define rrep(i, n) rrepr((i), (n), 0)\n#define rrepr(i, a, t) rreps((i), (a), (t), 1)\n#define rreps(i, a, t, s) for (long long (i) = (a) - 1; (i) >= (long long)(t); (i) -= (s))\n#define each(v, c) for (auto &&(v) : (c))\n#define all(c) (c).begin(), (c).end()\n\nusing namespace std;\n\n// コンテナのメンバ関数を使わないと O(N) おぼえたらけす\ntemplate<typename T>\ntypename set<T>::iterator lower_bound(typename set<T>::iterator l, typename set<T>::iterator r, const T &v);\ntemplate<typename T>\ntypename set<T>::iterator upper_bound(typename set<T>::iterator l, typename set<T>::iterator r, const T &v);\ntemplate<typename S, typename T>\ntypename map<S, T>::iterator lower_bound(typename map<S, T>::iterator l, typename map<S, T>::iterator r, const T &v);\ntemplate<typename S, typename T>\ntypename map<S, T>::iterator upper_bound(typename map<S, T>::iterator l, typename map<S, T>::iterator r, const T &v);\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e18;\n\n/**\n * Verify\n * RMQ (Add): http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=4529260\n * RMQ (Update): http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=4529538\n * RSQ (Add): http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=4529573\n * @tparam E\n * @tparam T\n */\ntemplate<typename E, typename T>\nclass LazySegmentTree {\n private:\n  E _e_id;\n  T _t_id;\n  size_t _size;\n  /** E・E */\n  function<E(E, E)> _ee;\n  /** E・T */\n  function<E(E, T)> _et;\n  /** T・T */\n  function<T(T, T)> _tt;\n  /** 区間加算のとき、RSQ なら掛け算、RMQ なら T をそのまま返す関数 */\n  function<T(T, ll)> _t_pow;\n\n  /**\n   * k の部分木の葉に一様に value を適用する\n   * @param k\n   */\n  void _apply_to_subtree(int k, T value) {\n    _tree[k] = _et(_tree[k], _t_pow(value, _leaves_counts[k]));\n    if (k < _size) {\n      _lazy[k] = _tt(_lazy[k], value);\n    }\n  }\n\n  /**\n   * k とその親たちの遅延配列を評価する\n   * @param k\n   */\n  void _eval_parents(int k) {\n    int v = k;\n    int h = 0;\n    while ((v >> h) > 1) h++;\n    for (; h > 0; h--) {\n      k = v >> h;\n      _apply_to_subtree(k << 1, _lazy[k]);\n      _apply_to_subtree(k << 1 | 1, _lazy[k]);\n      _lazy[k] = _t_id;\n    }\n  }\n\n  /**\n   * _tree[k] の親たちを最新化する\n   * @param k\n   */\n  void _update_parents(int k) {\n    k >>= 1;\n    while (k > 0) {\n      _tree[k] = _et(\n          _ee(_tree[k << 1], _tree[k << 1 | 1]),\n          _t_pow(_lazy[k], _leaves_counts[k]));\n      k >>= 1;\n    }\n  }\n\n public:\n  vector<E> _tree;\n  vector<T> _lazy;\n  vector<ll> _leaves_counts;\n\n  LazySegmentTree(\n      const vector<E> &values,\n      E e_id,\n      T t_id,\n      function<E(E, E)> op_ee,\n      function<E(E, T)> op_et,\n      function<T(T, T)> op_tt,\n      function<T(T, ll)> t_pow = [](T e, ll n) { return e; }\n  ) : _e_id(e_id),\n      _t_id(t_id),\n      _ee(std::move(op_ee)),\n      _et(std::move(op_et)),\n      _tt(std::move(op_tt)),\n      _t_pow(std::move(t_pow)) {\n    _size = values.size();\n    _tree.resize(_size * 2, _e_id);\n    _lazy.resize(_size * 2, _t_id);\n    _leaves_counts.resize(_size * 2, 1);\n\n    for (int i = 0; i < _size; i++) {\n      _tree[i + _size] = values[i];\n    }\n    for (int i = _size - 1; i > 0; i--) {\n      _tree[i] = _ee(_tree[i << 1], _tree[i << 1 | 1]);\n      _leaves_counts[i] = _leaves_counts[i << 1] + _leaves_counts[i << 1 | 1];\n    }\n  }\n\n  /**\n   * [l, r) の範囲に value を適用する\n   * @param l\n   * @param r\n   * @param value\n   */\n  void apply(int l, int r, T value) {\n    l += _size;\n    r += _size;\n    int l0 = l;\n    int r0 = r;\n\n    // _et が上書き系の演算のときに、あとから古い値で上書きされないように、\n    // 既存の遅延配列の値を評価して _tree に移しておく\n    // http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=4529538\n    _eval_parents(l);\n    _eval_parents(r - 1);\n    while (l < r) {\n      if (l & 1) {\n        _apply_to_subtree(l++, value);\n      }\n      if (r & 1) {\n        _apply_to_subtree(--r, value);\n      }\n      l >>= 1;\n      r >>= 1;\n    }\n    _update_parents(l0);\n    _update_parents(r0 - 1);\n  }\n\n  /**\n   * [l, r) に op_ee を適用した値を返す\n   * @param l\n   * @param r\n   */\n  auto query(int l, int r) -> E {\n    l += _size;\n    r += _size;\n    _eval_parents(l);\n    _eval_parents(r - 1);\n\n    vector<E> ret, ret_r;\n    while (l < r) {\n      if (l & 1) {\n        ret.push_back(_tree[l++]);\n      }\n      if (r & 1) {\n        ret_r.push_back(_tree[--r]);\n      }\n      l >>= 1;\n      r >>= 1;\n    }\n    reverse(ret_r.begin(), ret_r.end());\n    ret.insert(ret.end(), ret_r.begin(), ret_r.end());\n    return accumulate(ret.begin(), ret.end(), _e_id, _ee);\n  }\n};\n\nauto main() -> int {\n  cout << fixed << setprecision(10);\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  ifstream ifs;\n  if (DEBUG) {\n    ifs.open(\"src/_in.txt\");\n    cin.rdbuf(ifs.rdbuf());\n  }\n\n  ll N, Q;\n  cin >> N >> Q;\n\n  vector<ll> values(N + 1, 0);\n  using E = ll;\n  using T = ll;\n  T t_id = INF;\n  auto ee = [](E a, E b) { return a + b; };\n  auto et = [&](E a, T b) { return b == t_id ? a : b; };\n  auto tt = [&](T a, T b) { return b == t_id ? a : b; };\n  auto tpow = [&](T a, ll b) { return a == t_id ? a : a * b; };\n  auto st = LazySegmentTree<E, T>(values, 0, t_id, ee, et, tt, tpow);\n\n  rep (i, Q) {\n    ll op;\n    cin >> op;\n    if (op == 0) {\n      // update\n      ll s, t, x;\n      cin >> s >> t >> x;\n      st.apply(s, t + 1, x);\n    } else {\n      // sum\n      ll s, t;\n      cin >> s >> t;\n      auto a = st.query(s, t + 1);\n      cout << a << \"\\n\";\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll=long long;\n\n#include <vector>\n#include <functional>\n\ntemplate <typename T,typename E>\nstruct LazySegmentTree{\n   using F=std::function<T(T,T)>;\n   using G=std::function<T(T,E,int,int)>;\n   using H=std::function<E(E,E)>;\n\n   int n;\n   std::vector<T> dat;\n   std::vector<E> laz;\n   const F f;\n   const G g;\n   const H h;\n   const T d1;\n   const E d0;\n\n   LazySegmentTree(int n_,const F f,const G g,const H h,const T d1,const E d0):f(f),g(g),h(h),d1(d1),d0(d0)\n   {\n      n=1;\n      while(n_>n) n<<=1;\n      dat.assign(2*n,d1);\n      laz.assign(2*n,d0);\n   }\n   void set(int k,const T &x){\n      dat[k+n]=x;\n   }\n   void build(){\n      for(int k=n-1;k>0;--k) dat[k]=f(dat[2*k],dat[2*k+1]);\n   }\n   void eval(int k,int l,int r){\n      if(laz[k]==d0) return;\n      dat[k]=g(dat[k],laz[k],l,r);\n      if(k<n){\n         laz[2*k]=h(laz[2*k],laz[k]);\n         laz[2*k+1]=h(laz[2*k+1],laz[k]);\n      }\n      laz[k]=d0;\n   }\n   void update(int a,int b,E x,int k=1,int l=0,int r=-1){\n      if(r<0) r=n;\n      eval(k,l,r);\n      if(r<=a||b<=l) return;\n      if(a<=l&&r<=b){\n         laz[k]=h(laz[k],x);\n         eval(k,l,r);\n      }\n      else{\n         update(a,b,x,2*k,l,(l+r)/2);\n         update(a,b,x,2*k+1,(l+r)/2,r);\n         dat[k]=f(dat[2*k],dat[2*k+1]);\n      }\n   }\n   T query(int a,int b,int k=1,int l=0,int r=-1){\n      if(r<0) r=n;\n      eval(k,l,r);\n      if(r<=a||b<=l) return d1;\n      if(a<=l&&r<=b) return dat[k];\n      T vl=query(a,b,2*k,l,(l+r)/2);\n      T vr=query(a,b,2*k+1,(l+r)/2,r);\n      return f(vl,vr);\n   }\n};\n\n/*\n\n-RMinimumQ and RUpdateQ\nf=[](T x,T y){ return min(x,y); };\ng=[](T x,E y,int l,int r){ return y; };\nh=[](E x,E y){ return y; };\n\n-RSumQ and RAddQ\nf=[](T x,T y){ return x+y; };\ng=[](T x,E y,int l,int r){ return x+(r-l)*y; };\nh=[](E x,E y){ return x+y; };\n\n-RMinimumQ and RAddQ\nf=[](T x,T y){ return min(x,y); };\ng=[](T x,E y,int l,int r){ return x+y; };\nh=[](E x,E y){ return x+y; };\n\n-RSumQ and RUpdateQ\nf=[](T x,T y){ return x+y; };\ng=[](T x,E y,int l,int r){ return (r-l)*y; };\nh=[](E x,E y){ return y; };\n\n*/\n\nint main(){\n   int n,q;\n   cin>>n>>q;\n   using T=ll;\n   using E=ll;\n   auto f=[](T x,T y){ return x+y; };\n   auto g=[](T x,E y,int l,int r){ return (r-l)*y; };\n   auto h=[](E x,E y){ return y; };\n   LazySegmentTree<ll,ll> seg(n,f,g,h,0,INT_MAX);\n   for(int i=0;i<q;++i){\n      int com;\n      cin>>com;\n      int s,t,x;\n      cin>>s>>t;\n      if(com==0){\n         cin>>x;\n         seg.update(s,t+1,x);\n      }\n      else{\n         cout<<seg.query(s,t+1)<<endl;\n      }\n   }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\ntemplate<typename T, typename E> struct LazySegmentTree;\n\ntemplate<typename T, typename E> struct QueryObject {\n  LazySegmentTree<T, E> *lst;\n  int a, b;\n  E x;\n  int k;\n  int l, r;\n  QueryObject(LazySegmentTree<T, E> *lst,\n      int a, int b, E x = 0, int k = 0, int l = 0, int r = -1)\n      : lst(lst), a(a), b(b), x(x), k(k), l(l), r(r) {}\n};\n\ntemplate<typename T, typename E> struct QueryType {\n  virtual int outOfRange(QueryObject<T, E> o) = 0;\n  virtual int cover(QueryObject<T, E> o) = 0;\n  virtual int join(QueryObject<T, E> o, T vl, T vr) = 0;\n  T query(QueryObject<T, E> o) {\n    if (o.r < 0) o.r = o.lst->n;\n    o.lst->eval(o.r - o.l, o.k);\n    if (o.b <= o.l || o.r <= o.a) return outOfRange(o);\n    if (o.a <= o.l && o.r <= o.b) return cover(o);\n    QueryObject<T, E> o1 = o, o2 = o;\n    o1.k = o.k * 2 + 1; o1.r = (o.l + o.r) / 2;\n    o2.k = o.k * 2 + 2; o2.l = (o.l + o.r) / 2;\n    T vl = query(o1);\n    T vr = query(o2);\n    return join(o, vl, vr);\n  }\n};\n\ntemplate<typename T, typename E> struct Setter : QueryType<T, E> {\n  enum setter { RUQ, RAQ };\n  int outOfRange(QueryObject<T, E> o) {\n    return o.lst->data[o.k];\n  }\n  int cover(QueryObject<T, E> o) {\n    o.lst->lazy[o.k] = o.lst->h(o.lst->lazy[o.k], o.x);\n    o.lst->eval(o.r - o.l, o.k);\n    return o.lst->data[o.k];\n  }\n  int join(QueryObject<T, E> o, T vl, T vr) {\n    return o.lst->data[o.k] = o.lst->f(vl, vr);\n  }\n};\n\ntemplate<typename T, typename E> struct Getter : QueryType<T, E> {\n  enum getter { RMQ, RSQ };\n  int outOfRange(QueryObject<T, E> o) {\n    return o.lst->initT;\n  }\n  int cover(QueryObject<T, E> o) {\n    return o.lst->data[o.k];\n  }\n  int join(QueryObject<T, E> o, T vl, T vr) {\n    return o.lst->f(vl, vr);\n  }\n};\n\ntemplate<typename T, typename E> struct LazySegmentTree {\n  using F = function<T(T, T)>;\n  using G = function<T(T, E)>;\n  using H = function<E(E, E)>;\n  using P = function<E(E, int)>;\n  F add() {\n    return [&](const T& x, const T& y) -> const T { return x + y; };\n  }\n  F minimum() {\n    return [&](const T& x, const T& y) -> const T { return min(x, y); };\n  }\n  G ex_assign(E initE) {\n    return [&initE](const T& x, const E& y) -> const T { return (y == initE) ? x : y; };\n  }\n  P ex_multiplies(E initE) {\n    return [&initE](const E& x, int y) -> const E { return (x == initE) ? x : x * y; };\n  }\n\n  int n;\n  T initT;\n  E initE;\n  F f;\n  G g;\n  H h;\n  P p;\n  vector<T> data;\n  vector<E> lazy;\n  QueryType<T, E> *type;\n\n  LazySegmentTree() {}\n  LazySegmentTree(QueryType<T, E> *type_) { type = type_; }\n  LazySegmentTree(int n_, int setter, int getter,\n      T initT_ = INT_MAX, E initE_ = INT_MAX, vector<T> v = vector<T>{}) {\n    setQuery(setter, getter, initT_, initE_);\n    n = 1;\n    while (n < n_) n *= 2;\n    data.assign(n * 2 - 1, initT);\n    lazy.assign(n * 2 - 1, initE);\n    if (n_ == v.size()) build(v);\n  }\n  void build(vector<T> v) {\n    for (int i = 0; i < v.size(); ++i) data[i + n - 1] = v[i];\n    for (int i = n - 2; i >= 0; --i) {\n      data[i] = f(data[i * 2 + 1], data[i * 2 + 2]);\n    }\n  }\n  void setQuery(int setter, int getter, T initT_, E initE_) {\n    initT = vector<T>{initT_, 0}[getter];\n    initE = vector<E>{initE_, 0}[setter];\n    f = vector<F>{minimum(), add()}[getter];\n    g = vector<G>{ex_assign(initE), add()}[setter];\n    h = vector<H>{ex_assign(initE), add()}[setter];\n    p = ex_multiplies(initE);\n  }\n  inline void eval(int len, int k) {\n    if (lazy[k] == initE) return;\n    if (k * 2 + 1 < n * 2 - 1) {\n      lazy[k * 2 + 1] = h(lazy[k * 2 + 1], lazy[k]);\n      lazy[k * 2 + 2] = h(lazy[k * 2 + 2], lazy[k]);\n    }\n    data[k] = g(data[k], p(lazy[k], len));\n    lazy[k] = initE;\n  }\n  T query(QueryObject<T, E> obj) {\n    return type->query(obj);\n  }\n  T setData(int a, int b, E x) {\n    LazySegmentTree<T, E> lst(new Setter<T, E>());\n    QueryObject<T, E> obj(this, a, b, x);\n    return lst.query(obj);\n  }\n  T getData(int a, int b) {\n    LazySegmentTree<T, E> lst(new Getter<T, E>());\n    QueryObject<T, E> obj(this, a, b);\n    return lst.query(obj);\n  }\n};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, q; cin >> n >> q;\n  LazySegmentTree<ll, ll> seg(n, Setter<ll, ll>::RUQ, Getter<ll, ll>::RSQ);\n\n  while (q--) {\n    int com; cin >> com;\n    if (com) {\n      int s, t; cin >> s >> t;\n      cout << seg.getData(s, t + 1) << endl;\n    } else {\n      int s, t, x; cin >> s >> t >> x;\n      seg.setData(s, t + 1, x);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#include \"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long int;\n\n#define debugos clog\n#define debug(v) {printf(\"L%d %s > \",__LINE__,#v);debugos<<(v)<<endl;}\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:(v)){debugos<<e<<\" \";}debugos<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){debugos<<(m)[x]<<\" \";}debugos<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){debugos<<(m)[y][x]<<\" \";}debugos<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(remove_reference<remove_const<decltype(l)>::type>::type cnt=0;(cnt)<(l);++(cnt))\n#define rrepeat(cnt,l) for(auto cnt=(l)-1;0<=(cnt);--(cnt))\n#define iterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);++(cnt))\n#define diterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);--(cnt))\nconst ll MD = 1000000007ll; const long double PI = 3.1415926535897932384626433832795L;\ninline void assert_call(bool assertion, function<void()> f) { if (!assertion) { cerr << \"assertion fault:\" << endl; f(); abort(); } }\ntemplate<typename T1, typename T2> inline ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << '(' << p.first << ':' << p.second << ')'; return o; }\ntemplate<typename Vec> inline ostream& _ostream_vecprint(ostream& os, const Vec& a) {\n    os << '['; for (const auto& e : a) os << ' ' << e << ' '; os << ']'; return os;\n}\ntemplate<typename T> inline ostream& operator<<(ostream& o, const vector<T>& v) { return _ostream_vecprint(o, v); }\ntemplate<typename T, size_t S> inline ostream& operator<<(ostream& o, const array<T, S>& v) { return _ostream_vecprint(o, v); }\ntemplate<typename T> inline T& maxset(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> inline T& minset(T& to, const T& val) { return to = min(to, val); }\nvoid bye(string s, int code = 0) { cout << s << endl; exit(code); }\nmt19937_64 randdev(8901016);\ntemplate<typename T> inline T rand(T l, T h) { return uniform_int_distribution<T>(l, h)(randdev); }\ntemplate<> inline double rand<double>(double l, double h) { return uniform_real_distribution<double>(l, h)(randdev); }\ntemplate<> inline float rand<float>(float l, float h) { return uniform_real_distribution<float>(l, h)(randdev); }\n\n\n#if defined(_WIN32) || defined(_WIN64)\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#elif defined(__GNUC__)\n#else\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) noexcept {\n            var = 0; T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc < '0' || '9' < cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc && cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var * sign;\n        }\n        inline int c() noexcept { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) noexcept { input_integer<int>(var); return *this; }\n        inline MaiScanner& operator>>(long long& var) noexcept { input_integer<long long>(var); return *this; }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n            return *this;\n        }\n        template<typename IT> void in(IT begin, IT end) { for (auto it = begin; it != end; ++it) *this >> *it; }\n    };\n    class MaiPrinter {\n    public:\n        template<typename T>\n        void output_integer(T var) noexcept {\n            if (var == 0) { putchar_unlocked('0'); return; }\n            if (var < 0)\n                putchar_unlocked('-'),\n                var = -var;\n            char stack[32]; int stack_p = 0;\n            while (var)\n                stack[stack_p++] = '0' + (var % 10),\n                var /= 10;\n            while (stack_p)\n                putchar_unlocked(stack[--stack_p]);\n        }\n        inline MaiPrinter& operator<<(char c) noexcept { putchar_unlocked(c); return *this; }\n        inline MaiPrinter& operator<<(int var) noexcept { output_integer<int>(var); return *this; }\n        inline MaiPrinter& operator<<(long long var) noexcept { output_integer<long long>(var); return *this; }\n        inline MaiPrinter& operator<<(char* str_p) noexcept { while (*str_p) putchar_unlocked(*(str_p++)); return *this; }\n        inline MaiPrinter& operator<<(const string& str) {\n            const char* p = str.c_str();\n            const char* l = p + str.size();\n            while (p < l) putchar_unlocked(*p++);\n            return *this;\n        }\n        template<typename IT> void join(IT begin, IT end, char sep = ' ') { for (bool b = 0; begin != end; ++begin, b = 1) b ? *this << sep << *begin : *this << *begin; }\n    };\n}\nMaiScanner scanner;\nMaiPrinter printer;\n\n\ntemplate<typename T>\n//using T = ll;\nclass SegmentTree {\npublic:\n    struct IdxVal {\n        int index;\n        T value;\n        inline IdxVal(int _i = 0, const T& _v = T()) :index(_i), value(_v) { }\n        inline void set(int i, const T& v) { index = i; value = v; }\n        inline bool operator<(const T& t) const { return value < t; }\n        inline bool operator==(const T& t) const { return value == t; }\n        inline bool operator<(const IdxVal& iv) const { return value < iv.value || (value == iv.value && index < iv.index); }\n        inline bool operator==(const IdxVal& iv) const { return index == iv.index && value == iv.value; }\n    };\n\n    enum struct Cmd{\n        None, Add, Flat\n    };\n\n    struct Node {\n        T sum, lazyValue;\n        IdxVal max;\n        Cmd lazyType;\n    };\n\nprivate:\n    const int size_;\n    vector<T> leaf_data_;\n    vector<Node> node_data_;\n    T* leaf_;\n    Node* node_;\n\n    void _resize() {\n        leaf_data_.resize(size_);\n        node_data_.resize(size_ - 1);\n\n        leaf_ = &leaf_data_[0];\n        node_ = &node_data_[0] - 1;\n    }\n\n    void _init() {\n        for (int i = size_ - 1; 0 < i; --i) {\n            int c = i << 1;\n            if (size_ <= c)\n                node_[i].max.set(c - size_, leaf_[c - size_]);\n            else\n                node_[i].max = node_[c].max;\n            node_[i].lazyType = Cmd::None;\n            node_[i].sum = node_[i].lazyValue = 0;\n        }\n    }\npublic:\n\n    inline void fill(T val) {\n        std::fill(leaf_data_.begin(), leaf_data_.end(), val);\n        _init();\n    }\n\n    SegmentTree(int _n) :\n        size_([](int _n) {int s = 8; while (s < _n) s <<= 1; return s; }(_n))\n    {\n        _resize();\n        _init();\n    }\n    SegmentTree(int _n, const T& _fillVal) :\n        size_([](int _n) {int s = 8; while (s < _n) s <<= 1; return s; }(_n))\n    {\n        _resize();\n        fill(_fillVal);\n    }\n\n\nprivate:\n    // lazyを適応する(子を呼ぶ前に呼ぶ)\n    // width: ptrが担当するnodeの範囲の大きさ(ptr = 1 ならば size_)\n    inline void _applyDown(int ptr, int width) {\n        width >>= 1;\n        //if (size_ <= ptr) return;\n        if (node_[ptr].lazyType == Cmd::Add) {\n            int c = ptr << 1;\n\n            if (size_ <= c) {\n                leaf_[c - size_] += node_[ptr].lazyValue;\n                leaf_[c + 1 - size_] += node_[ptr].lazyValue;\n            }\n            else {\n                node_[c].sum += node_[ptr].lazyValue * width;\n                node_[c].max.value += node_[ptr].lazyValue;\n                node_[c].lazyValue += node_[ptr].lazyValue;\n                if (node_[c].lazyType == Cmd::None)\n                    node_[c].lazyType = Cmd::Add;\n\n                node_[c + 1].sum += node_[ptr].lazyValue * width;\n                node_[c + 1].max.value += node_[ptr].lazyValue;\n                node_[c + 1].lazyValue += node_[ptr].lazyValue;\n                if (node_[c + 1].lazyType == Cmd::None)\n                    node_[c + 1].lazyType = Cmd::Add;\n            }\n\n            node_[ptr].lazyType = Cmd::None;\n            node_[ptr].lazyValue = 0;\n        }\n        else if (node_[ptr].lazyType == Cmd::Flat) {\n            node_[ptr].lazyType = Cmd::None;\n            int c = ptr << 1;\n\n            if (size_ <= c) {\n                leaf_[c - size_] = node_[ptr].lazyValue;\n                leaf_[c + 1 - size_] = node_[ptr].lazyValue;\n            }\n            else {\n                node_[c].sum = node_[ptr].lazyValue * width;\n                node_[c].max.value = node_[ptr].lazyValue;\n                node_[c].lazyValue = node_[ptr].lazyValue;\n                node_[c].lazyType = Cmd::Flat;\n\n                node_[c + 1].sum = node_[ptr].lazyValue * width;\n                node_[c + 1].max.value = node_[ptr].lazyValue;\n                node_[c + 1].lazyValue = node_[ptr].lazyValue;\n                node_[c + 1].lazyType = Cmd::Flat;\n            }\n\n            node_[ptr].lazyType = Cmd::None;\n            node_[ptr].lazyValue = 0;\n        }\n    }\n\n    // lazyを適応する(子を呼んだ後に呼ぶ)\n    inline void _applyUp(int ptr) {\n        if (size_ <= ptr << 1) {\n            int i = (ptr << 1) - size_;\n            if (leaf_[i] < leaf_[i + 1])\n                node_[ptr].max.set(i + 1, leaf_[i + 1]);\n            else\n                node_[ptr].max.set(i, leaf_[i]);\n            node_[ptr].sum = leaf_[i] + leaf_[i + 1];\n        }\n        else {\n            if (node_[(ptr << 1)].max.value < node_[(ptr << 1) + 1].max.value)\n                node_[ptr].max = node_[(ptr << 1) + 1].max;\n            else\n                node_[ptr].max = node_[(ptr << 1)].max;\n            node_[ptr].sum = node_[ptr << 1].sum + node_[(ptr << 1) + 1].sum;\n        }\n    }\n\n    // _downward_applyDown(ptr1): leaf[ptr1]の値を正しくする．\n    void _downward_applyDown(int ptr1, int width = 1) {\n        if (1 < ptr1) _downward_applyDown(ptr1 >> 1, width << 1);\n        _applyDown(ptr1, width);\n    }\n\n\n    void _setValueRange(int begin, int end, T val, int ptr, int rangebegin, int rangeend) {\n\n        if (rangeend <= begin || end <= rangebegin) return; // note:範囲外\n        if (begin <= rangebegin && rangeend <= end) {\n            if (size_ <= ptr) {\n                leaf_[rangebegin] = val;\n            }\n            else {\n                node_[ptr].sum = val * (rangeend - rangebegin);\n                node_[ptr].max.value = val;\n                node_[ptr].lazyType = Cmd::Flat;\n                node_[ptr].lazyValue = val;\n            }\n            return;\n        }\n\n        _applyDown(ptr, rangeend - rangebegin);\n\n        _setValueRange(begin, end, val, ptr << 1, rangebegin, (rangebegin + rangeend) >> 1);\n        _setValueRange(begin, end, val, (ptr << 1) + 1, (rangebegin + rangeend) >> 1, rangeend);\n\n        _applyUp(ptr);\n    }\n\n    void _addValueRange(int begin, int end, T val, int ptr, int rangebegin, int rangeend) {\n\n        if (rangeend <= begin || end <= rangebegin) return; // note:範囲外\n        if (begin <= rangebegin && rangeend <= end) {\n            if (size_ <= ptr) {\n                leaf_[rangebegin] += val;\n            }\n            else {\n                node_[ptr].sum += val * (rangeend - rangebegin);\n                node_[ptr].max.value += val;\n                node_[ptr].lazyValue += val;\n                if (node_[ptr].lazyType == Cmd::None)\n                    node_[ptr].lazyType = Cmd::Add;\n            }\n            return;\n        }\n\n        _applyDown(ptr, rangeend - rangebegin);\n\n        _addValueRange(begin, end, val, ptr << 1, rangebegin, (rangebegin + rangeend) >> 1);\n        _addValueRange(begin, end, val, (ptr << 1) + 1, (rangebegin + rangeend) >> 1, rangeend);\n\n        _applyUp(ptr);\n    }\n\n    T _getSumRange(int begin, int end, int ptr, int rangebegin, int rangeend) {\n        if (rangeend <= begin || end <= rangebegin) return 0; // note:範囲外\n        if (begin <= rangebegin && rangeend <= end) {\n            if (size_ <= ptr)\n                return leaf_[rangebegin];\n            else\n                return node_[ptr].sum;\n        }\n\n        _applyDown(ptr, rangeend - rangebegin);\n\n        return _getSumRange(begin, end, ptr << 1, rangebegin, (rangebegin + rangeend) >> 1)\n            + _getSumRange(begin, end, (ptr << 1) + 1, (rangebegin + rangeend) >> 1, rangeend);\n    }\n\n    IdxVal _getMaxRange(int begin, int end, int ptr, int rangebegin, int rangeend) {\n        if (rangeend <= begin || end <= rangebegin) return IdxVal(-1); // note:範囲外\n        if (begin <= rangebegin && rangeend <= end) {\n            if (size_ <= ptr)\n                return IdxVal(rangebegin, leaf_[rangebegin]);\n            else\n                return node_[ptr].max;\n        }\n\n        _applyDown(ptr, rangeend - rangebegin);\n\n        auto l = _getMaxRange(begin, end, ptr << 1, rangebegin, (rangebegin + rangeend) >> 1);\n        auto r = _getMaxRange(begin, end, (ptr << 1) + 1, (rangebegin + rangeend) >> 1, rangeend);\n\n        if (l.index == -1) return move(r);\n        if (r.index == -1) return move(l);\n        return l.value < r.value ? move(r) : move(l);\n    }\n\npublic:\n    // [index] の値を求める\n    inline T getValue(int index) {\n        _downward_applyDown((index + size_) >> 1);\n        return leaf_[index];\n    }\n\n    // [index] の値を書き換える\n    inline T setValue(int index, T val) {\n        _downward_applyDown((index + size_) >> 1);\n        T diff = val - leaf_[index];\n        leaf_[index] = val;\n\n        for (int ptr = (index + size_); 1 < ptr;) {\n            ptr >>= 1;\n            node_[ptr].sum -= diff;\n            _applyUp(ptr);\n        }\n    }\n\n    // [index] の値に加算する\n    inline T addValue(int index, T val) {\n        _downward_applyDown((index + size_) >> 1);\n        leaf_[index] += val;\n\n        for (int ptr = (index + size_); 1 < ptr;) {\n            ptr >>= 1;\n            node_[ptr].sum += val;\n            _applyUp(ptr);\n        }\n    }\n\n    // 区間[begin,end)全てにvalをセットする\n    inline void setValueRange(int begin, int end, T val) {\n        _setValueRange(begin, end, val, 1, 0, size_);\n    }\n\n    // 区間[begin,end)に一様にvalを加算する\n    inline void addValueRange(int begin, int end, T val) {\n        _addValueRange(begin, end, val, 1, 0, size_);\n    }\n\n    // 区間[begin,end)の和を求める\n    inline T getSumRange(int begin, int end) {\n        return _getSumRange(begin, end, 1, 0, size_);\n    }\n\n    // 区間[begin,end)の最大値とその位置を求める\n    inline IdxVal getMaxRange(int begin, int end) {\n        return _getMaxRange(begin, end, 1, 0, size_);\n    }\n};\n\n\nint main_dsl_2_A() {\n    int N, Q;\n    scanner >> N >> Q;\n\n    SegmentTree<ll> segtree(N, -2147483647);\n    repeat(_, Q) {\n        int c, x, y;\n        scanner >> c >> x >> y;\n        if (c == 0) {\n            segtree.setValue(x, -y);\n        }\n        else if (c == 1) {\n            auto a = segtree.getMaxRange(x, y + 1);\n            printer << -a.value << '\\n';\n        }\n    }\n    return 0;\n}\nint main_dsl_2_B() {\n    int N, Q;\n    scanner >> N >> Q;\n\n    SegmentTree<ll> segtree(N, 0);\n    repeat(_, Q) {\n        int c, x, y;\n        scanner >> c >> x >> y;\n        if (c == 0) {\n            segtree.addValue(x - 1, y);\n        }\n        else if (c == 1) {\n            auto a = segtree.getSumRange(x - 1, y);\n            printer << a << '\\n';\n        }\n    }\n    return 0;\n}\nint main_dsl_2_D() {\n    int N, Q;\n    scanner >> N >> Q;\n    SegmentTree<ll> segtree(N, 2147483647);\n\n    repeat(_, Q) {\n        int c, s, t, x;\n        scanner >> c;\n        if (c == 0) {\n            scanner >> s >> t >> x;\n            segtree.setValueRange(s, t + 1, x);\n        }\n        else if (c == 1) {\n            scanner >> s;\n            auto a = segtree.getValue(s);\n            printer << a << '\\n';\n        }\n    }\n    return 0;\n}\nint main_dsl_2_E() {\n    int N, Q;\n    scanner >> N >> Q;\n\n    SegmentTree<ll> segtree(N);\n    repeat(_, Q) {\n        int c, s, t, x;\n        scanner >> c;\n        if (c == 0) {\n            scanner >> s >> t >> x;\n            segtree.addValueRange(s, t + 1, x);\n        }\n        else if (c == 1) {\n            scanner >> s;\n            auto e = segtree.getValue(s);\n            printer << e << '\\n';\n        }\n    }\n    return 0;\n}\nint main_dsl_2_F() {\n    int N, Q;\n    scanner >> N >> Q;\n    SegmentTree<ll> segtree(N, -2147483647);\n\n    repeat(_, Q) {\n        int c, s, t, x;\n        scanner >> c;\n        if (c == 0) {\n            scanner >> s >> t >> x;\n            segtree.setValueRange(s, t + 1, -x);\n        }\n        else if (c == 1) {\n            scanner >> s >> t;\n            auto a = segtree.getMaxRange(s, t + 1);\n            printer << -a.value << '\\n';\n        }\n    }\n    return 0;\n}\nint main_dsl_2_G() {\n    int m, n;\n    int q;\n    scanner >> n >> q;\n\n    SegmentTree<ll> seg(n);\n\n    repeat(_, q) {\n        int t;\n        scanner >> t;\n        if (t == 0) {\n            int s, t, x;\n            scanner >> s >> t >> x;\n            --s; --t;\n            seg.addValueRange(s, t + 1, x);\n        }\n        else {\n            int s, t;\n            scanner >> s >> t;\n            --s; --t;\n            printer << (seg.getSumRange(s, t + 1)) << '\\n';\n        }\n    }\n    return 0;\n}\n\nint main_dsl_2_H() {\n    int N, Q;\n    scanner >> N >> Q;\n\n    SegmentTree<ll> segtree(N);\n    repeat(_, Q) {\n        int q, s, t, x;\n        scanner >> q;\n        if (q == 0) {\n            scanner >> s >> t >> x;\n            segtree.addValueRange(s, t + 1, -x);\n        }\n        else if (q == 1) {\n            scanner >> s >> t;\n            auto a = segtree.getMaxRange(s, t + 1);\n            printer << a.value << '\\n';\n        }\n    }\n    return 0;\n}\nint main_dsl_2_I() {\n    int N, Q;\n    scanner >> N >> Q;\n    SegmentTree<ll> segtree(N);\n\n    repeat(_, Q) {\n        int c, s, t, x;\n        scanner >> c;\n        if (c == 0) {\n            scanner >> s >> t >> x;\n            segtree.setValueRange(s, t + 1, x);\n        }\n        else if (c == 1) {\n            scanner >> s >> t;\n            auto a = segtree.getSumRange(s, t + 1);\n            printer << a << '\\n';\n        }\n    }\n    return 0;\n}\n\nint main() {\n    // main_dsl_2_A();\n    // main_dsl_2_B();\n    // main_dsl_2_D();\n    // main_dsl_2_E();\n    // main_dsl_2_F();\n    // main_dsl_2_G();\n    // main_dsl_2_H();\n    main_dsl_2_I();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\n/*Starry Sky Tree*/\n/*Range Add Min(Max) Query*/\n/*区間加算、区間Min,区間Max*/\n\nclass RSUQ{\npublic: \n  \n  //遅延用の型  \n  struct T{\n    int type; //0 - empty   , 1 - update\n    int value;\n    T():type(0),value(0){}\n    T(int type,int value):type(type),value(value){}\n  };\n\n  //マージ可能な主データ型\n  struct D{\n    int value;\n    D():value(0){} /*適切な値にする!!!!!!*/\n    D(int value):value(value){}\n    bool operator < (D a)const {return value < a.value;} //merge用\n  };\n  \n  int n;\n  vector<D> dat;\n  vector<T> td;\n  D returnD = D(0); // 範囲外の時に返す値。\n  \n  RSUQ(){n=-1;}\n  RSUQ(int n_){\n    n=1;\n    while(n < n_) n *= 2;\n    td.resize(2*n-1,T());\n    dat.resize(2*n-1,D());\n  }\n  \n  D merge(D a,D b){return a.value + b.value;}\n  \n  void delay(int k,int len){\n    if(td[k].type==0) return;\n    int v = td[k].value;\n    td[k].type = 0;\n    td[k].value = 0;\n    \n    len /= 2;\n    int l = k*2+1,r = k*2+2;\n    dat[l].value = v * len; td[l].type = 1; td[l].value = v;\n    dat[r].value = v * len; td[r].type = 1; td[r].value = v;\n  }\n\n  D write(int k,int x, int len){\n    dat[k].value = x * len;\n    td[k].type = 1;\n    td[k].value = x;\n    return dat[k];\n  }\n  \n  //[a,b)の値をx変更　query(a,b,x)\n  D update(int a,int b,int x,bool flg=true,int k=0,int l=0,int r=-1){\n    if(r==-1) r=n, assert(a <= n && b <= n);\n    if(r <= a||b <= l) return flg? dat[k]:returnD;\n    if(a <= l && r <= b) return flg? write(k, x, r - l):dat[k];\n    \n    delay(k, r - l);\n    D vl = update(a,b,x,flg,k*2+1,l,(l+r)/2);\n    D vr = update(a,b,x,flg,k*2+2,(l+r)/2,r);\n    if(flg) dat[k] = merge(vl, vr);\n    return merge(vl, vr);\n  }\n  \n  //[a,b)の合計値を得る　find(a,b);\n  int find(int a,int b){\n    D res = update(a,b,0,false);\n    return res.value;\n  }\n};\n\n\nsigned main(){\n  int n,q;\n  cin>>n>>q;\n  \n  RSUQ rsuq(n);\n\n  while(q--){\n    int cmd;\n    cin>>cmd;\n    if(cmd == 0){\n      int s,t,x;\n      cin>>s>>t>>x;\n      rsuq.update(s,t+1,x);\n    }\n    if(cmd == 1){\n      int s,t;\n      cin>>s>>t;\n      cout<<rsuq.find(s,t+1)<<endl;\n    }\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#include <set>\n#include <tuple>\n#define mkp make_pair\n#define mkt make_tuple\n#define rep(i,n) for(int i = 0; i < (n); ++i)\nusing namespace std;\ntypedef long long ll;\nconst ll MOD=1e9+7;\ntemplate<class T> void chmin(T &a,const T &b){if(a>b) a=b;}\ntemplate<class T> void chmax(T &a,const T &b){if(a<b) a=b;}\n\n#include <functional>\n\ntemplate< typename T, typename S >\nstruct LazySegmentTree{\n    int n;\n    vector<T> data;\n    vector<S> lazy;\n    T te;\n    S se;\n\n    inline void merge_functions(S& lazy,S& val){\n        //lazy+=val;\n        lazy=val;\n    }\n    inline void operate(T& data,S& val,int len){\n        //data+=val*len;\n        data=val*len;\n        //data+=val;\n        //data=val;\n    }\n    inline T merge_values(T& x,T& y){\n        return x+y;\n        //return min(x,y);\n        //return max(x,y);\n    }\n\n    LazySegmentTree(){}\n    LazySegmentTree(int sz,T te,S se):te(te),se(se){\n        n=1;\n        while(n<sz) n*=2;\n        data.resize(2*n-1,te);\n        lazy.resize(2*n-1,se);\n    }\n\n    void build(vector<T> &A){\n        for(int k=0;k<int(A.size());k++) data[k+n-1]=A[k];\n        for(int k=n-2;k>=0;k--) data[k]=merge_values(data[2*k+1],data[2*k+2]);\n    }\n\n    void eval(int k,int l,int r){\n        if(lazy[k]==se) return;\n        operate(data[k],lazy[k],r-l);\n        if(r-l>1){\n            merge_functions(lazy[2*k+1],lazy[k]);\n            merge_functions(lazy[2*k+2],lazy[k]);\n        }\n        lazy[k]=se;\n    }\n\n    void update(int a,int b,S val,int k=0,int l=0,int r=-1){\n        if(r<0) r=n;\n        eval(k,l,r);\n        if(b<=l||r<=a) return;\n        if(a<=l&&r<=b){\n            merge_functions(lazy[k],val);\n            eval(k,l,r);\n        }else{\n            update(a,b,val,2*k+1,l,(l+r)/2);\n            update(a,b,val,2*k+2,(l+r)/2,r);\n            data[k]=merge_values(data[2*k+1],data[2*k+2]);\n        }\n    }\n\n    T query(int a,int b,int k=0,int l=0,int r=-1){\n        if(r<0) r=n;\n        eval(k,l,r);\n        if(b<=l||r<=a) return te;\n        if(a<=l&&r<=b) return data[k];\n\n        T vl=query(a,b,2*k+1,l,(l+r)/2);\n        T vr=query(a,b,2*k+2,(l+r)/2,r);\n        return merge_values(vl,vr);\n    }\n};\n\nconst ll INF=1e18;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int N,Q;\n  cin>>N>>Q;\n\n  LazySegmentTree<ll,ll> seg(N,0,-2*INF);\n\n  vector<ll> init(N,0);\n  seg.build(init);\n\n  for(int q=0;q<Q;q++){\n      int t;cin>>t;\n      if(t==0){\n          int a,b;\n          ll x;\n          cin>>a>>b>>x;\n          seg.update(a,b+1,x);\n      }else{\n          int a,b;\n          cin>>a>>b;\n          cout<<seg.query(a,b+1)<<\"\\n\";\n      }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n \nstruct query{\n  int type;//0=empty, 1=add-sum ,2=set-min\n  ll value;\n  query(int a=0,ll b=0):type(a),value(b) {}\n};\n \n \n#define SIZE (1<<17)\n \nll INF=(1LL<<60);\n \n \nstruct segtree{\n  query s[SIZE*2];\n  ll t[SIZE*2];// sum-add\n  ll u[SIZE*2];// min-set\n   \n  void init(){\n    for(int i=0;i<SIZE*2;i++){\n      s[i]=query();\n      t[i]=0;\n      u[i]=0;\n    }\n  }\n \n  void func(int k,int l,int r,query q){\n    if(q.type==1){\n      if(s[k].type==0)s[k]=q;\n      else s[k].value+=q.value;\n      t[k]+=q.value*(r-l);\n      u[k]+=q.value;\n    }\n    if(q.type==2){\n      s[k]=q;\n      t[k]=q.value*(r-l);\n      u[k]=q.value;\n    }\n  }\n \n  void compute(int k,int l,int r){\n    query q=s[k];\n    s[k]=query();\n    if(q.type==0||r-l==1)return;\n    int m=(l+r)/2;\n    func(k*2+1,l,m,q);\n    func(k*2+2,m,r,q);\n  }\n \n  void Update(int a,int b,query x,int k=0,int l=0,int r=SIZE){\n    if(b<=l || r<=a)return;\n    compute(k,l,r);\n    if(a<=l && r<=b){\n      func(k,l,r,x);\n    }else{\n      int m=(l+r)/2;\n      Update(a,b,x,k*2+1,l,m);\n      Update(a,b,x,k*2+2,m,r);\n      t[k]=t[k*2+1]+t[k*2+2];\n      u[k]=min(u[k*2+1],u[k*2+2]);\n    }\n  }\n \n  ll Dfs(int type,int a,int b,int k=0,int l=0,int r=SIZE){\n    if(b<=l || r<=a){\n      if(type==1)return 0; //add\n      if(type==2)return INF; // min\n    }\n    compute(k,l,r);\n    if(a<=l && r<=b){\n      if(type==1)return t[k];\n      if(type==2)return u[k];\n    }else{\n      int m=(l+r)/2;\n      ll lv=Dfs(type,a,b,k*2+1,l,m);\n      ll rv=Dfs(type,a,b,k*2+2,m,r);\n      if(type==1)return lv+rv; // add\n      if(type==2)return min(lv,rv); // min\n    }\n  }\n \n  ll Getsum(int a,int b){\n    return Dfs(1,a,b);\n  }\n \n  ll Getmin(int a,int b){\n    return Dfs(2,a,b);\n  }\n \n};\n \nsegtree T;\n \nint main(){\n  T.init();\n   \n  int n,q;\n  scanf(\"%d %d\",&n,&q);\n  while(q--){\n    int type,a,b,c;\n    scanf(\"%d %d %d\",&type,&a,&b);\n    if(type==0){\n      scanf(\"%d\",&c);\n      T.Update(a,b+1, query(2,c) );\n    }else{\n      printf(\"%lld\\n\", T.Getsum(a,b+1) );\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\ntemplate<typename T> constexpr function<T(T, T)> ex_assign(T initE) {\n  return [&initE](const T& x, const T& y) -> const T { return (y == initE) ? x : y; };\n}\ntemplate<typename T> constexpr function<T(T, int)> ex_multiplies(T initE) {\n  return [&initE](const T& x, int y) -> const T { return (x == initE) ? x : x * y; };\n}\ntemplate<typename T, typename E> struct LazySegmentTree {\n  using F = function<T(T, T)>;\n  using G = function<T(T, E)>;\n  using H = function<E(E, E)>;\n  using P = function<E(E, int)>;\n\n  int n;\n  T initT;\n  E initE;\n  F f;\n  G g;\n  H h;\n  P p;\n  vector<T> data;\n  vector<E> lazy;\n\n  LazySegmentTree() {}\n  LazySegmentTree(int n_, F f, G g, H h, T initT = INT_MAX, E initE = INT_MAX,\n      vector<T> v = vector<T>(), P p = [](E a, size_t b) { ++b; return a; })\n      : f(f), g(g), h(h), initT(initT), initE(initE), p(p) {\n    n = 1;\n    while (n < n_) n *= 2;\n    data.assign(n * 2 - 1, initT);\n    lazy.assign(n * 2 - 1, initE);\n    if (n_ == v.size()) build(v);\n  }\n  void build(vector<T> v) {\n    for (int i = 0; i < v.size(); ++i) data[i + n - 1] = v[i];\n    for (int i = n - 2; i >= 0; --i) {\n      data[i] = f(data[i * 2 + 1], data[i * 2 + 2]);\n    }\n  }\n  inline void eval(int len, int k) {\n    if (lazy[k] == initE) return;\n    if (k * 2 + 1 < n * 2 - 1) {\n      lazy[k * 2 + 1] = h(lazy[k * 2 + 1], lazy[k]);\n      lazy[k * 2 + 2] = h(lazy[k * 2 + 2], lazy[k]);\n    }\n    data[k] = g(data[k], p(lazy[k], len));\n    lazy[k] = initE;\n  }\n  T update(int a, int b, E x, int k = 0, int l = 0, int r = -1) {\n    if (r < 0) r = n;\n    eval(r - l, k);\n    if (b <= l || r <= a) return data[k];\n    if (a <= l && r <= b) {\n      lazy[k] = h(lazy[k], x);\n      eval(r - l, k);\n      return data[k];\n    }\n    T vl = update(a, b, x, k * 2 + 1, l, (l + r) / 2);\n    T vr = update(a, b, x, k * 2 + 2, (l + r) / 2, r);\n    return data[k] = f(vl, vr);\n  }\n  T query(int a, int b, int k = 0, int l = 0, int r = -1) {\n    if (r < 0) r = n;\n    eval(r - l, k);\n    if (b <= l || r <= a) return initT;\n    if (a <= l && r <= b) return data[k];\n    T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n    T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n    return f(vl, vr);\n  }\n};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  const ll initT = 0;\n  const ll initE = 1e9;\n  const LazySegmentTree<ll, ll>::F f = plus<ll>();\n  const LazySegmentTree<ll, ll>::G g = ex_assign<ll>(initE);\n  const LazySegmentTree<ll, ll>::H h = ex_assign<ll>(initE);\n  const LazySegmentTree<ll, ll>::P p = ex_multiplies<ll>(initE);\n\n  int n, q; cin >> n >> q;\n  LazySegmentTree<ll, ll> seg(n, f, g, h, initT, initE, vector<ll>(), p);\n\n  while (q--) {\n    int com; cin >> com;\n    if (com) {\n      int s, t; cin >> s >> t;\n      cout << seg.query(s, t + 1) << endl;\n    } else {\n      int s, t, x; cin >> s >> t >> x;\n      seg.update(s, t + 1, x);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long int\n#define MOD(x) ((x % MOD_N) + MOD_N) % MOD_N\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define RFORE(i,a,b) for(int i=(b);i>=(a);--i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define RALL(c) (c).rbegin(),(c).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(c) (int)((c).size())\n#define EACH(i,v) for(auto i=v.begin();i!=v.end();++i)\n#define REACH(i,v) for(auto i=v.rbegin();i!=v.rend();++i)\n#define LB(c,x) distance((c).begin(),lower_bound(ALL(c),x))\n#define UB(c,x) distance((c).begin(),upper_bound(ALL(c),x))\n#define COUNT(c,x) (lower_bound(ALL(c),x)-upper_bound(ALL(c),x))\n#define UNIQUE(c) SORT(c); (c).erase(unique(ALL(c)),(c).end());\n#define COPY(c1,c2) copy(ALL(c1),(c2).begin())\n#define EXIST(s,e) (bool)((s).find(e)!=(s).end())\n#define PB push_back\n#define MP make_pair\n#define DUMP(x)  cerr<<#x<<\" = \"<<(x)<<endl;\n#define NL cerr<<endl;\nusing namespace std;\ntemplate<typename T,typename U> using P=pair<T,U>;\ntemplate<typename T> using V=vector<T>;\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T sum(vector<T>&v){return accumulate(ALL(v),T());}\ntemplate<typename T>T sum(vector<T>&v,int a,int b){return accumulate(v.begin()+a,v.begin()+b,T());}\ntemplate<typename T>T max(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T min(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T max_index(vector<T>&v){return distance((v).begin(),max_element(ALL(v)));}\ntemplate<typename T>T min_index(vector<T>&v){return distance((v).begin(),min_element(ALL(v)));}\n\nstruct edge { int to, cost; };\n\ntemplate<typename T>auto&operator<<(ostream&s,const vector<T>&v){s<<\"[\";bool a=1;for(auto e:v){s<<(a?\"\":\" \")<<e;a=0;}s<<\"]\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const pair<T,U>&p){s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return s;}\ntemplate<typename T>auto&operator<<(ostream&s,const set<T>&st){s<<\"{\";bool a=1;for(auto e:st){s<<(a?\"\":\" \")<<e;a=0;}s<<\"}\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const map<T,U>&m){s<<\"{\";bool a=1;for(auto e:m){s<<(a?\"\":\" \")<<e.first<<\":\"<<e.second;a=0;}s<<\"}\";return s;}\n\nconst int INF = 1e18;\nconst int MOD_N = 1e9+7;\n\ntemplate< typename Monoid, typename OperatorMonoid = Monoid >\nstruct LazySegmentTree {\n   using F = function< Monoid(Monoid, Monoid) >;\n   using G = function< Monoid(Monoid, OperatorMonoid, int) >;\n   using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n   int sz;\n   vector< Monoid > data;\n   vector< OperatorMonoid > lazy;\n   const F f;\n   const G g;\n   const H h;\n   const Monoid M1;\n   const OperatorMonoid OM0;\n   LazySegmentTree(int n, const F f, const G g, const H h,\n                   const Monoid &M1, const OperatorMonoid OM0)\n         : f(f), g(g), h(h), M1(M1), OM0(OM0) {\n      sz = 1;\n      while(sz < n) sz <<= 1;\n      data.assign(2 * sz, M1);\n      lazy.assign(2 * sz, OM0);\n   }\n\n   void set(int k, const Monoid &x) {\n      data[k + sz] = x;\n   }\n   void build() {\n      for(int k = sz - 1; k > 0; k--) {\n         data[k] = f(data[2 * k + 0], data[2 * k + 1]);\n      }\n   }\n   void propagate(int k, int len) {\n      if(lazy[k] != OM0) {\n         if(k < sz) {\n            lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n            lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n         }\n         data[k] = g(data[k], lazy[k], len);\n         lazy[k] = OM0;\n      }\n   }\n   Monoid update(int a, int b, const OperatorMonoid &x, int k, int l, int r) {\n      propagate(k, r - l);\n      if(r <= a || b <= l) {\n         return data[k];\n      } else if(a <= l && r <= b) {\n         lazy[k] = h(lazy[k], x);\n         propagate(k, r - l);\n         return data[k];\n      } else {\n         return data[k] = f(update(a, b, x, 2 * k + 0, l, (l + r) >> 1),\n                            update(a, b, x, 2 * k + 1, (l + r) >> 1, r));\n      }\n   }\n   Monoid update(int a, int b, const OperatorMonoid &x) {\n      return update(a, b, x, 1, 0, sz);\n   }\n   Monoid query(int a, int b, int k, int l, int r) {\n      propagate(k, r - l);\n      if(r <= a || b <= l) {\n         return M1;\n      } else if(a <= l && r <= b) {\n         return data[k];\n      } else {\n         return f(query(a, b, 2 * k + 0, l, (l + r) >> 1),\n                  query(a, b, 2 * k + 1, (l + r) >> 1, r));\n      }\n   }\n   Monoid query(int a, int b) {\n      return query(a, b, 1, 0, sz);\n   }\n   Monoid operator[](const int &k) {\n      return query(k, k + 1);\n   }\n};\n\nsigned main()\n{\n   int n, q; cin >> n >> q;\n   V<int> c(q), s(q), t(q), x(q);\n   REP(i, q) {\n      cin >> c[i];\n      if (c[i] == 0) {\n         cin >> s[i] >> t[i] >> x[i];\n      } else {\n         cin >> s[i] >> t[i];\n      }\n   }\n   LazySegmentTree<int> lsegt(n,\n         [](int a,int b){ return a + b; },\n         [](int a,int b,int c){ return b * c; },\n         [](int a,int b){ return b; }, 0, INF);\n   REP(i, q) {\n      if (c[i] == 0) {\n         lsegt.update(s[i], t[i]+1, x[i]);\n      } else {\n         cout << lsegt.query(s[i], t[i]+1) << endl;\n      }\n   }\n\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <functional>\n\ntemplate<typename T>\nstruct segment_tree {\n    long long N; // 木の頂点数\n    long long M; // 葉の数\n    std::vector<T> V; // セグメント木　1-indexed\n\tstd::vector<T> W; // 遅延配列　1-indexed\n\tstd::vector<bool> flag; // true : W[i] の子孫に更新していない遅延配列が存在\n    std::function<T(T, T)> op1; // 二項演算\n\tstd::function<T(T, T, T)> op2; // 遅延伝播用の二項演算\n\tstd::function<T(T, T)> op3; // 遅延配列更新用の二項演算\n    T id1; // 単位元\n\tT id2; // 遅延伝播用の単位元\n\n    // ===============================================================\n\n    segment_tree(\n\t\tstd::vector<T>& a,\n\t\tstd::function<T(T, T)> f,\n\t\tstd::function<T(T, T, T)> g,\n\t\tstd::function<T(T, T)> h,\n\t\tT t1, T t2\n\t) : op1(f), op2(g), op3(h), id1(t1), id2(t2) {\n        M = 1;\n        while (M < a.size()) M *= 2;\n        N = 2 * M;\n        V.resize(N, id1); W.resize(N, id2); flag.resize(N, false);\n        for (long long i = 0; i < a.size(); i++) V[M + i] = a[i];\n        for (long long i = M - 1; i > 0; i--) {\n            V[i] = op1(V[2 * i], V[2 * i + 1]);\n        }\n    }\n\n    segment_tree() {}\n\n    // ===============================================================\n\n    void init(\n\t\tstd::vector<T>& a,\n\t\tstd::function<T(T, T)> f,\n\t\tstd::function<T(T, T, T)> g,\n\t\tstd::function<T(T, T)> h,\n\t\tT t1, T t2\n\t) {\n        op1 = f; op2 = g; op3 = h; id1 = t1; id2 = t2;\n\t\tM = 1;\n        while (M < a.size()) M *= 2;\n        N = 2 * M;\n        V.resize(N, id1); W.resize(N, id2); flag.resize(N, false);\n        for (long long i = 0; i < a.size(); i++) V[M + i] = a[i];\n        for (long long i = M - 1; i > 0; i--) {\n            V[i] = op1(V[2 * i], V[2 * i + 1]);\n        }\n    }\n\n\tvoid laze_eval(long long cur_node, long long width) {\n\t\tif (W[cur_node] != id2) {\n\t\t\tV[cur_node] = op2(V[cur_node], W[cur_node], width);\n\t\t\tif (width > 1) {\n\t\t\t\tW[cur_node * 2] = op3(W[cur_node * 2], W[cur_node]);\n\t\t\t\tW[cur_node * 2 + 1] = op3(W[cur_node * 2 + 1], W[cur_node]);\n\t\t\t}\n\t\t\tW[cur_node] = id2;\n\t\t}\n\t}\n\n\tvoid range_update(\n\t\tlong long l, long long r, T x,\n\t\tlong long cur_node = 1,\n\t\tlong long cur_left = 0, long long cur_right = -1\n\t) {\n\t\tif (cur_right == -1) cur_right = M;\n\t\tlong long width = cur_right - cur_left;\n\t\tif (cur_right <= l || r <= cur_left) return;\n\t\tif (l <= cur_left && cur_right <= r) {\n\t\t\tW[cur_node] = op3(W[cur_node], x);\n\t\t}\n\t\telse {\n\t\t\tlaze_eval(cur_node, width);\n\t\t\tflag[cur_node] = true;\n\t\t\tlong long mid = (cur_left + cur_right) / 2;\n\t\t\trange_update(l, r, x, cur_node * 2, cur_left, mid);\n\t\t\trange_update(l, r, x, cur_node * 2 + 1, mid, cur_right);\n\t\t\tV[cur_node] = op1(V[cur_node * 2], V[cur_node * 2 + 1]);\n\t\t}\n\t}\n\n\tT range_fold(\n\t\tlong long l, long long r,\n\t\tlong long cur_node = 1,\n\t\tlong long cur_left = 0, long long cur_right = -1\n\t) {\n\t\tif (cur_right == -1) cur_right = M;\n\t\tlong long width = cur_right - cur_left;\n\t\tif (cur_right <= l || r <= cur_left) return id1;\n\t\tlaze_eval(cur_node, width);\n\t\tif (width == 1) {\n\t\t\tflag[cur_node] = false;\n\t\t\treturn V[cur_node];\n\t\t}\n\t\tlong long mid = (cur_left + cur_right) / 2;\n\t\tif (l <= cur_left && cur_right <= r && !flag[cur_node]) {\n\t\t\treturn V[cur_node];\n\t\t}\n\t\telse if (l <= cur_left && cur_right <= r) {\n\t\t\tflag[cur_node] = false;\n\t\t\trange_fold(cur_left, mid);\n\t\t\trange_fold(mid, cur_right);\n\t\t\treturn V[cur_node] = op1(V[cur_node * 2], V[cur_node * 2 + 1]);\n\t\t}\n\t\treturn op1(\n\t\t\trange_fold(l, r, cur_node * 2, cur_left, mid),\n\t\t\trange_fold(l, r, cur_node * 2 + 1, mid, cur_right)\n\t\t);\n\t}\n};\n\nint main() {\n\tlong long n, q;\n\tstd::cin >> n >> q;\n\tstd::vector<long long> a(n, 0);\n\n\tauto f = [] (long long x, long long y) {return x + y;};\n\tauto g = [] (long long x, long long y, long long z) {return y * z;};\n\tauto h = [] (long long x, long long y) {return y;};\n\tsegment_tree<long long> sg(a, f, g, h, 0, LLONG_MAX);\n\n\twhile (q--) {\n\t\tlong long z, s, t;\n\t\tstd::cin >> z >> s >> t;\n\t\tif (z == 0) {\n\t\t\tlong long x;\n\t\t\tstd::cin >> x;\n\t\t\tsg.range_update(s, t + 1, x);\n\t\t}\n\t\telse std::cout << sg.range_fold(s, t + 1) << '\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint N,Q;\ntypedef long long ll;\nconst int INF=INT_MAX;\nstruct LazySegmentTree{\n  private:\n  int n;\n  vector<int> node,lazy;\n  vector<bool> lazyFlag;\n  \n  public:\n  LazySegmentTree(vector<int> v){\n    int sz=(int)v.size();\n    n=1;  while(n<sz)n*=2;\n    node.resize(2*n-1);\n    lazy.resize(2*n-1,INF);\n    lazyFlag.resize(2*n-1,false);\n    for(int i=0;i<sz;i++)node[i+n-1]=v[i];\n    for(int i=n-2;i>=0;i--){node[i]=node[2*i+1]+node[2*i+2];}\n  }\n  void lazyEvaluate(int k,int l,int r){\n    if(lazyFlag[k]){\n      node[k]=lazy[k]*(r-l);\n      if(r-l>1){\n        lazy[2*k+1]=lazy[2*k+2]=lazy[k];\n        lazyFlag[2*k+1]=lazyFlag[2*k+2]=true;\n      }\n      lazyFlag[k]=false;\n    }\n  }\n  void update(int a,int b,int x,int k=0,int l=0,int r=-1){\n    if(r<0)r=n;\n    lazyEvaluate(k,l,r);\n    if(b<=l || r<=a)return;\n    if(a<=l && r<=b){\n      lazy[k]=x;\n      lazyFlag[k]=true;\n      lazyEvaluate(k,l,r);\n    }\n    else{\n      update(a,b,x,2*k+1,l,(l+r)/2);\n      update(a,b,x,2*k+2,(l+r)/2,r);\n      node[k]=node[2*k+1]+node[2*k+2];\n    }\n  }\n  ll getsum(int a,int b,int k=0,int l=0,int r=-1){\n    if(r<0)r=n;\n    lazyEvaluate(k,l,r);\n    if(b<=l || r<=a)return 0;\n    if(a<=l && r<=b)return node[k];\n    ll vl=getsum(a,b,2*k+1,l,(l+r)/2);\n    ll vr=getsum(a,b,2*k+2,(l+r)/2,r);\n    return vl+vr;\n  }\n};\n\nint main(){\n  cin >> N >> Q;\n  LazySegmentTree seg(vector<int>(N,0));\n  for(int i=0;i<Q;i++){\n    int q,s,t; cin >> q >> s >> t;\n    if(q==0){\n      int x; cin >> x;\n      seg.update(s,t+1,x);\n    }\n    else{\n      cout << seg.getsum(s,t+1) << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\n// Lazy Segment Tree\ntemplate <class M, class OM> struct LST {\n    int n, lev;\n    vector<M> d;\n    vector<OM> lz;\n    virtual M f(M, M) = 0;\n    virtual M g(M, OM) = 0;\n    virtual OM h(OM, OM) = 0;\n    virtual OM p(OM, int) = 0;\n    const M e1;\n    const OM e0;\n\n    LST(int n_, M e1, OM e0) : e1(e1), e0(e0) {\n        for (n = 1, lev = 0; n < n_; n <<= 1, ++lev);\n        d.assign(n << 1, e1);\n        lz.assign(n << 1, e0);\n    }\n\n    // k: 0-indexed\n    void set(int k, const M& x) {\n        d[k + n] = x;\n    }\n\n    void build() {\n        for (int i = n - 1; i > 0; --i) {\n            d[i] = f(d[(i << 1) | 0], d[(i << 1) | 1]);\n        }\n    }\n\n    inline M reflect(int k, int len) {\n        return lz[k] == e0 ? d[k] : g(d[k], p(lz[k], len));\n    }\n\n    inline void push(int k) {\n        for (int i = lev, len = n; i > 0; --i, len >>= 1) {\n            int j = k >> i;\n            if (lz[j] == e0) continue;\n            lz[(j << 1) | 0] = h(lz[(j << 1) | 0], lz[j]);\n            lz[(j << 1) | 1] = h(lz[(j << 1) | 1], lz[j]);\n            d[j] = reflect(j, len);\n            lz[j] = e0;\n        }\n    }\n\n    inline void recalc(int k) {\n        int len = 1;\n        while (len <<= 1, k >>= 1) {\n            M lhs = reflect((k << 1) | 0, len >> 1);\n            M rhs = reflect((k << 1) | 1, len >> 1);\n            d[k] = f(lhs, rhs);\n        }\n    }\n\n    // [l, r)\n    // l, r: 0-indexed\n    void update(int l, int r, const OM& x) {\n        push(l += n);\n        push(r += n - 1);\n        int l0 = l, r0 = r;\n        for (++r; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) lz[l] = h(lz[l], x), l++;\n            if (r & 1) --r, lz[r] = h(lz[r], x);\n        }\n        recalc(l0);\n        recalc(r0);\n    }\n\n    // [l, r)\n    // l, r: 0-indexed\n    M query(int l, int r) {\n        push(l += n);\n        push(r += n - 1);\n        M L = e1, R = e1;\n        int len;\n        for (++r, len = 1; l < r; l >>= 1, r >>= 1, len <<= 1) {\n            if (l & 1) L = f(L, reflect(l++, len));\n            if (r & 1) R = f(reflect(--r, len), R);\n        }\n        return f(L, R);\n    }\n    \n    void print(int time = -1) {\n        if (~time) cerr << \"time = \" << time << endl;\n        for (int i = 0; i <= lev; ++i) {\n            const int m = 1 << i;\n            for (int j = 0; j < m; ++j) {\n                cerr << \"  (\" << d[j + m] << \", \" << lz[j + m] << \")\";\n            }\n            cerr << endl;\n        }\n        cerr << endl;\n    }\n};\n\n// RmQ and RUQ\ntemplate <class M, class OM> struct RmQRUQ : LST<M, OM> {\n    RmQRUQ(int n, M e1 = numeric_limits<M>::max(), OM e0 = numeric_limits<OM>::max()) : LST<M, OM>(n, e1, e0) {}\n    M f(M a, M b) override { return min(a, b); }\n    M g(M a, OM b) override { return b; }\n    OM h(OM a, OM b) override { return b; }\n    OM p(OM a, int b) override { return a; }\n};\n\n// RSQ and RAQ\ntemplate <class M, class OM> struct RSQRAQ : LST<M, OM> {\n    RSQRAQ(int n, M e1 = 0, OM e0 = 0) : LST<M, OM>(n, e1, e0) {}\n    M f(M a, M b) override { return a + b; }\n    M g(M a, OM b) override { return a + b; }\n    OM h(OM a, OM b) override { return a + b; }\n    OM p(OM a, int b) override { return a * b; }\n};\n\n// RmQ and RAQ\ntemplate <class M, class OM> struct RmQRAQ : LST<M, OM> {\n    RmQRAQ(int n, M e1 = numeric_limits<M>::max(), OM e0 = 0) : LST<M, OM>(n, e1, e0) {\n        for (int i = 0; i < n; ++i) this->set(i, 0);\n        this->build();\n    }\n    M f(M a, M b) override { return min(a, b); }\n    M g(M a, OM b) override { return a + b; }\n    OM h(OM a, OM b) override { return a + b; }\n    OM p(OM a, int b) override { return a; }\n};\n\n// RSQ and RUQ\ntemplate <class M, class OM> struct RSQRUQ : LST<M, OM> {\n    RSQRUQ(int n, M e1 = 0, OM e0 = numeric_limits<OM>::max()) : LST<M, OM>(n, e1, e0) {}\n    M f(M a, M b) override { return a + b; }\n    M g(M a, OM b) override { return b; }\n    OM h(OM a, OM b) override { return b; }\n    OM p(OM a, int b) override { return a * b; }\n};\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, q;\n    cin >> n >> q;\n    RSQRUQ<int, int> r(n);\n    REP (i, q) {\n        int c, s, t;\n        cin >> c >> s >> t;\n        if (c == 0) {\n            int x;\n            cin >> x;\n            r.update(s, t + 1, x);\n        } else {\n            cout << r.query(s, t + 1) << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1e9+7;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 200010;\n\nstruct SegTree_beats{\n    const lint b_INF = 1LL << 60;\n    int sz;\n    vector<lint> MAX_val, sMAX_val, MAX_cnt;\n    vector<lint> min_val, smin_val, min_cnt;\n    vector<lint> len, sum, ladd, lval;\n\n    void init_node(int i, lint x){\n        MAX_val[i] = min_val[i] = sum[i] = x;\n        sMAX_val[i] = -b_INF; smin_val[i] = b_INF;\n        MAX_cnt[i] = min_cnt[i] = 1;\n    }\n\n    void init_empty_node(int i){\n        MAX_val[i] = sMAX_val[i] = -b_INF;\n        min_val[i] = smin_val[i] = b_INF;\n        MAX_cnt[i] = min_cnt[i] = 0;\n    }\n\n    void update_node_max(int i, lint x){\n        sum[i] += (x - MAX_val[i]) * MAX_cnt[i];\n        if(MAX_val[i] == min_val[i]) MAX_val[i] = min_val[i] = x;\n        else if(MAX_val[i] == smin_val[i]) MAX_val[i] = smin_val[i] = x;\n        else MAX_val[i] = x;\n        if(lval[i] != b_INF && lval[i] < x) lval[i] = x;\n    }\n\n    void update_node_min(int i, lint x){\n        sum[i] += (x - min_val[i]) * min_cnt[i];\n        if(min_val[i] == MAX_val[i]) min_val[i] = MAX_val[i] = x;\n        else if(MAX_val[i] == smin_val[i]) min_val[i] = sMAX_val[i] = x;\n        else min_val[i] = x;\n        if(lval[i] != b_INF && x < lval[i]) lval[i] = x;\n    }\n\n    void update_node_add(int i, lint x, int l, int r){\n        MAX_val[i] += x;\n        if(sMAX_val[i] != -b_INF) sMAX_val[i] += x;\n        min_val[i] += x;\n        if(smin_val[i] != b_INF) smin_val[i] += x;\n        sum[i] += x * (r - l);\n        if(lval[i] != b_INF) lval[i] += x;\n        else ladd[i] += x;\n    }\n\n    void update_node_set(int i, lint x, int l, int r){\n        MAX_val[i] = min_val[i] = x;\n        sMAX_val[i] = -b_INF; smin_val[i] = b_INF;\n        MAX_cnt[i] = min_cnt[i] = r - l;\n        sum[i] = x * (r - l);\n        lval[i] = x; ladd[i] = 0;\n    }\n\n    void push(int i, int l, int r){\n        if(lval[i] != b_INF){\n            update_node_set(i*2+1, lval[i], l, (l+r)/2);\n            update_node_set(i*2+2, lval[i], (l+r)/2, r);\n            lval[i] = b_INF;\n            return;\n        }\n        if(ladd[i] != 0){\n            update_node_add(i*2+1, ladd[i], l, (l+r)/2);\n            update_node_add(i*2+2, ladd[i], (l+r)/2, r);\n            ladd[i] = 0;\n        }\n        if(MAX_val[i] < MAX_val[i*2+1]) update_node_max(i*2+1, MAX_val[i]);\n        if(MAX_val[i] < MAX_val[i*2+2]) update_node_max(i*2+2, MAX_val[i]);\n        if(min_val[i] > min_val[i*2+1]) update_node_min(i*2+1, min_val[i]);\n        if(min_val[i] > min_val[i*2+2]) update_node_min(i*2+2, min_val[i]);\n    }\n\n    void pull(int i){\n        int s = i*2+1, t = i*2+2;\n        sum[i] = sum[s] + sum[t];\n\n        \n        if(MAX_val[s] > MAX_val[t]){\n            MAX_val[i] = MAX_val[s];\n            MAX_cnt[i] = MAX_cnt[s];\n            sMAX_val[i] = max(sMAX_val[s], MAX_val[t]);\n        }\n        else if(MAX_val[s] < MAX_val[t]){\n            MAX_val[i] = MAX_val[t];\n            MAX_cnt[i] = MAX_cnt[t];\n            sMAX_val[i] = max(MAX_val[s], sMAX_val[t]);\n        }\n        else{\n            MAX_val[i] = MAX_val[s];\n            MAX_cnt[i] = MAX_cnt[s] + MAX_cnt[t];\n            sMAX_val[i] = max(sMAX_val[s], sMAX_val[t]);\n        }\n\n        if(min_val[s] < min_val[t]){\n            min_val[i] = min_val[s];\n            min_cnt[i] = min_cnt[s];\n            smin_val[i] = min(smin_val[s], min_val[t]);\n        }\n        else if(min_val[s] > min_val[t]){\n            min_val[i] = min_val[t];\n            min_cnt[i] = min_cnt[t];\n            smin_val[i] = min(min_val[s], smin_val[t]);\n        }\n        else{\n            min_val[i] = min_val[s];\n            min_cnt[i] = min_cnt[s] + min_cnt[t];\n            smin_val[i] = min(smin_val[s], smin_val[t]);\n        }\n    }\n\n    SegTree_beats(int sz_, lint x){\n        sz = 1;\n        while(sz < sz_) sz *= 2;\n        MAX_val.resize(sz*2-1); sMAX_val.resize(sz*2-1); MAX_cnt.resize(sz*2-1);\n        min_val.resize(sz*2-1); smin_val.resize(sz*2-1); min_cnt.resize(sz*2-1);\n        sum.resize(sz*2-1); ladd.resize(sz*2-1, 0); lval.resize(sz*2-1, b_INF);\n        \n        rep(i, sz_) init_node(i+sz-1, x);\n        For(i, sz_, sz) init_empty_node(i+sz-1);\n        rrep(i, sz-1) pull(i);\n    }\n\n    SegTree_beats(int sz_, vector<lint> &a){\n        sz = 1;\n        while(sz < sz_) sz *= 2;\n        MAX_val.resize(sz*2-1); sMAX_val.resize(sz*2-1); MAX_cnt.resize(sz*2-1);\n        min_val.resize(sz*2-1); smin_val.resize(sz*2-1); min_cnt.resize(sz*2-1);\n        sum.resize(sz*2-1); ladd.resize(sz*2-1, 0); lval.resize(sz*2-1, b_INF);\n        \n        rep(i, a.size()) init_node(i+sz-1, a[i]);\n        For(i, a.size(), sz) init_empty_node(i+sz-1);\n        rrep(i, sz-1) pull(i);\n    }\n\n    void update_min(int a, int b, lint x, int i=0, int l=0, int r=-1){\n        if(r < 0) r = sz;\n        if(r<=a || b<=l || MAX_val[i] <= x) return;\n        else if(a<=l && r<=b && sMAX_val[i] < x){\n            update_node_max(i, x);\n        }\n        else{\n            push(i, l, r);\n            update_min(a, b, x, i*2+1, l, (l+r)/2);\n            update_min(a, b, x, i*2+2, (l+r)/2, r);\n            pull(i);\n        }\n    }\n\n    void update_max(int a, int b, lint x, int i=0, int l=0, int r=-1){\n        if(r < 0) r = sz;\n        if(r<=a || b<=l || min_val[i] >= x) return;\n        else if(a<=l && r<=b && smin_val[i] > x){\n            update_node_min(i, x);\n        }\n        else{\n            push(i, l, r);\n            update_max(a, b, x, i*2+1, l, (l+r)/2);\n            update_max(a, b, x, i*2+2, (l+r)/2, r);\n            pull(i);\n        }\n    }\n\n    void update_add(int a, int b, lint x, int i=0, int l=0, int r=-1){\n        if(r < 0) r = sz;\n        if(r<=a || b<=l) return;\n        else if(a<=l && r<=b) update_node_add(i, x, l, r);\n        else{\n            push(i, l, r);\n            update_add(a, b, x, i*2+1, l, (l+r)/2);\n            update_add(a, b, x, i*2+2, (l+r)/2, r);\n            pull(i);\n        }\n    }\n\n    void update_set(int a, int b, lint x, int i=0, int l=0, int r=-1){\n        if(r < 0) r = sz;\n        if(r<=a || b<=l) return;\n        else if(a<=l && r<=b) update_node_set(i, x, l, r);\n        else{\n            push(i, l, r);\n            update_set(a, b, x, i*2+1, l, (l+r)/2);\n            update_set(a, b, x, i*2+2, (l+r)/2, r);\n            pull(i);\n        }\n    }\n\n    lint get_max(int a, int b, int i=0, int l=0, int r=-1){\n        if(r < 0) r = sz;\n        if(r<=a || b<=l) return -b_INF;\n        else if(a<=l && r<=b) return MAX_val[i];\n        else{\n            push(i, l, r);\n            lint vl = get_max(a, b, i*2+1, l, (l+r)/2);\n            lint vr = get_max(a, b, i*2+2, (l+r)/2, r);\n            return max(vl, vr);\n        }\n    }\n\n    lint get_min(int a, int b, int i=0, int l=0, int r=-1){\n        if(r < 0) r = sz;\n        if(r<=a || b<=l) return b_INF;\n        else if(a<=l && r<=b) return min_val[i];\n        else{\n            push(i, l, r);\n            lint vl = get_min(a, b, i*2+1, l, (l+r)/2);\n            lint vr = get_min(a, b, i*2+2, (l+r)/2, r);\n            return min(vl, vr);\n        }\n    }\n\n    lint get_sum(int a, int b, int i=0, int l=0, int r=-1){\n        if(r < 0) r = sz;\n        if(r<=a || b<=l) return 0;\n        else if(a<=l && r<=b) return sum[i];\n        else{\n            push(i, l, r);\n            lint vl = get_sum(a, b, i*2+1, l, (l+r)/2);\n            lint vr = get_sum(a, b, i*2+2, (l+r)/2, r);\n            return vl + vr;\n        }\n    }\n\n    void print_node(int i){\n        printf(\"id=%d\\nMAX: (%lld, %lld, %lld)\\nmin: (%lld, %lld, %lld)\\nsum=%lld, ladd=%lld, lval=%lld\\n\\n\", i, MAX_val[i], sMAX_val[i], MAX_cnt[i], min_val[i], smin_val[i], min_cnt[i], sum[i], ladd[i], lval[i]);\n    }\n};\n\nint main(){\n    int n, q;\n    scanf(\"%d%d\", &n, &q);\n    SegTree_beats st(n, 0);\n    rep(_, q){\n        int c, s, t; lint x;\n        scanf(\"%d%d%d\", &c, &s, &t);\n        if(c == 0){\n            scanf(\"%lld\", &x);\n            st.update_set(s, t+1, x);\n        }\n        else printf(\"%lld\\n\", st.get_sum(s, t+1));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define PROBLEM \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_I\"\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define call_from_test\n#ifndef call_from_test\n#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n#endif\n//BEGIN CUT HERE\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n//END CUT HERE\n#ifndef call_from_test\nsigned main(){\n  return 0;\n}\n#endif\n\n#ifndef call_from_test\n#include<bits/stdc++.h>\nusing namespace std;\n#endif\n//BEGIN CUT HERE\ntemplate<typename Node, size_t LIM>\nstruct BBSTBase{\n  using u32 = uint32_t;\n  u32 xor128(){\n    static u32 x = 123456789;\n    static u32 y = 362436069;\n    static u32 z = 521288629;\n    static u32 w = 88675123;\n\n    u32 t = x ^ (x << 11);\n    x = y; y = z; z = w;\n    return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n  }\n\n  static array<Node, LIM> pool;\n  size_t ptr;\n  BBSTBase():ptr(0){}\n\n  size_t count(const Node *a){\n    return a?a->cnt:0;\n  }\n\n  inline Node* create(){\n    return &pool[ptr++];\n  }\n\n  inline Node* create(Node v){\n    return &(pool[ptr++]=v);\n  }\n\n  virtual void toggle(Node *a)=0;\n  virtual Node* eval(Node* a)=0;\n  virtual Node* recalc(Node* a)=0;\n\n  Node* toggle(Node *a,size_t l,size_t r){\n    auto s=split(a,l);\n    auto t=split(s.second,r-l);\n    auto u=eval(t.first);\n    toggle(u);\n    return merge(s.first,merge(u,t.second));\n  }\n\n  Node* merge(Node* a,Node* b){\n    if(a==nullptr) return b;\n    if(b==nullptr) return a;\n    if(xor128()%(count(a)+count(b))<count(a)){\n      a=eval(a);\n      a->r=merge(a->r,b);\n      a->r->p=a;\n      return recalc(a);\n    }\n    b=eval(b);\n    b->l=merge(a,b->l);\n    b->l->p=b;\n    return recalc(b);\n  }\n\n  pair<Node*, Node*> split(Node* a,size_t k){\n    if(a==nullptr) return make_pair(a,a);\n    a=eval(a);\n    if(k<=count(a->l)){\n      if(a->l) a->l->p=nullptr;\n      auto s=split(a->l,k);\n      a->l=s.second;\n      if(a->l) a->l->p=a;\n      return make_pair(s.first,recalc(a));\n    }\n    if(a->r) a->r->p=nullptr;\n    auto s=split(a->r,k-(count(a->l)+1));\n    a->r=s.first;\n    if(a->r) a->r->p=a;\n    return make_pair(recalc(a),s.second);\n  }\n\n  Node* insert(Node *a,size_t pos,Node v){\n    Node* b=create(v);\n    auto s=split(a,pos);\n    return a=merge(merge(s.first,b),s.second);\n  }\n\n  Node* erase(Node *a,size_t pos){\n    auto s=split(a,pos);\n    auto t=split(s.second,1);\n    return merge(s.first,t.second);\n  }\n\n  Node* find_by_order(Node *a,size_t k){\n    assert(k<count(a));\n    a=eval(a);\n    size_t num=count(a->l);\n    if(k<num) return find_by_order(a->l,k);\n    if(k>num) return find_by_order(a->r,k-(num+1));\n    return a;\n  }\n\n  inline bool is_right(Node* a){\n    return a->p&&a->p->r==a;\n  }\n\n  size_t order_of_key(Node* a){\n    size_t res=count(a->l);\n    while(a){\n      if(is_right(a)) res+=count(a->p->l)+1;\n      a=a->p;\n    }\n    return res;\n  }\n\n  Node* build(size_t l,size_t r,const vector<Node> &vs){\n    if(l+1==r) return create(vs[l]);\n    size_t m=(l+r)>>1;\n    return merge(build(l,m,vs),build(m,r,vs));\n  }\n\n  Node* build(const vector<Node> &vs){\n    return build(0,vs.size(),vs);\n  }\n};\ntemplate<typename Node, size_t LIM>\narray<Node, LIM> BBSTBase<Node, LIM>::pool;\n//END CUT HERE\n#ifndef call_from_test\n//INSERT ABOVE HERE\nsigned main(){\n  return 0;\n}\n#endif\n\n#ifndef call_from_test\n#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n#define call_from_test\n#include \"base.cpp\"\n#undef call_from_test\n\n#endif\n//BEGIN CUT HERE\ntemplate<typename Tp, typename Ep>\nstruct NodeBase{\n  using T = Tp;\n  using E = Ep;\n  NodeBase *l,*r,*p;\n  size_t cnt;\n  bool rev;\n  T val,dat;\n  E laz;\n  NodeBase():cnt(0),rev(0){l=r=p=nullptr;}\n  NodeBase(T val,E laz):\n    cnt(1),rev(0),val(val),dat(val),laz(laz){l=r=p=nullptr;}\n};\n\ntemplate<typename Node, size_t LIM>\nstruct Lazy : BBSTBase<Node, LIM>{\n  using super = BBSTBase<Node, LIM>;\n\n  using T = typename Node::T;\n  using E = typename Node::E;\n\n  using F = function<T(T, T)>;\n  using G = function<T(T, E)>;\n  using H = function<E(E, E)>;\n  using S = function<T(T)>;\n\n  F f;\n  G g;\n  H h;\n  S flip;\n  T ti;\n  E ei;\n\n  Lazy(F f,G g,H h,T ti,E ei):\n    super(),f(f),g(g),h(h),ti(ti),ei(ei){\n    flip=[](T a){return a;};\n  }\n\n  Lazy(F f,G g,H h,S flip,T ti,E ei):\n    super(),f(f),g(g),h(h),flip(flip),ti(ti),ei(ei){}\n\n  using super::create;\n  using super::merge;\n  using super::split;\n\n  T query(const Node *a){\n    return a?a->dat:ti;\n  }\n\n  using super::count;\n  Node* recalc(Node *a){\n    a->cnt=count(a->l)+1+count(a->r);\n    a->dat=a->val;\n    if(a->l) a->dat=f(a->l->dat,a->dat);\n    if(a->r) a->dat=f(a->dat,a->r->dat);\n    return a;\n  }\n\n  void propagate(Node *a,E v){\n    a->laz=h(a->laz,v);\n    a->val=g(a->val,v);\n    a->dat=g(a->dat,v);\n  }\n\n  using super::toggle;\n  void toggle(Node *a){\n    swap(a->l,a->r);\n    a->dat=flip(a->dat);\n    a->rev^=1;\n  }\n\n  // remove \"virtual\" for optimization\n  virtual Node* eval(Node* a){\n    if(a->laz!=ei){\n      if(a->l) propagate(a->l,a->laz);\n      if(a->r) propagate(a->r,a->laz);\n      a->laz=ei;\n    }\n    if(a->rev){\n      if(a->l) toggle(a->l);\n      if(a->r) toggle(a->r);\n      a->rev=false;\n    }\n    return recalc(a);\n  }\n\n  T query(Node *&a,size_t l,size_t r){\n    auto s=split(a,l);\n    auto t=split(s.second,r-l);\n    auto u=t.first;\n    T res=query(u);\n    a=merge(s.first,merge(u,t.second));\n    return res;\n  }\n\n  Node* update(Node *a,size_t l,size_t r,E x){\n    auto s=split(a,l);\n    auto t=split(s.second,r-l);\n    auto u=eval(t.first);\n    propagate(u,x);\n    return merge(s.first,merge(u,t.second));\n  }\n\n  Node* set_val(Node *a,size_t k,T val){\n    assert(k<count(a));\n    a=eval(a);\n    size_t num=count(a->l);\n    if(k<num) a->l=set_val(a->l,k,val);\n    if(k>num) a->r=set_val(a->r,k-(num+1),val);\n    if(k==num) a->val=val;\n    return recalc(a);\n  }\n\n  T get_val(Node *a,size_t k){\n    assert(k<count(a));\n    a=eval(a);\n    size_t num=count(a->l);\n    if(k<num) return get_val(a->l,k);\n    if(k>num) return get_val(a->r,k-(num+1));\n    return a->val;\n  }\n\n  void dump(Node* a,typename vector<T>::iterator it){\n    if(!count(a)) return;\n    a=eval(a);\n    dump(a->l,it);\n    *(it+count(a->l))=a->val;\n    dump(a->r,it+count(a->l)+1);\n  }\n\n  vector<T> dump(Node* a){\n    vector<T> vs(count(a));\n    dump(a,vs.begin());\n    return vs;\n  }\n};\n//END CUT HERE\n#ifndef call_from_test\n//INSERT ABOVE HERE\nchar buf[114514];\nsigned CODEFESTIVAL2014EXHIBITION_B(){\n  int Q;\n  scanf(\"%d\",&Q);\n  scanf(\"%s\\n\",buf);\n  string S(buf);\n  using T = tuple<int, int, int>;\n  using P = pair<int, int>;\n  auto f=[](T a,T b){\n           return T(min(get<0>(a),get<0>(b)),min(get<1>(a),get<1>(b)),0);\n         };\n  auto g=[](T a,P b){\n           return T(get<0>(a)+b.first,get<1>(a)+b.second,get<2>(a));\n         };\n  auto h=[](P a,P b){\n           return P(a.first+b.first,a.second+b.second);\n         };\n  const int INF = 1e9;\n\n  using Node = NodeBase<T, P>;\n  constexpr size_t LIM = 1e6;\n  Lazy<Node, LIM> G(f,g,h,T(INF,INF,0),P(0,0));\n\n  vector<T> v(S.size()+2,T(0,0,0));\n  for(int i=0;i<(int)S.size();i++)\n    get<2>(v[i+1])=(S[i]=='('?1:-1);\n\n  auto rt=G.build(v);\n  for(int i=1;i<=(int)S.size();i++){\n    int z=get<2>(G.get_val(rt,i));\n    rt=G.update(rt,i,G.count(rt),P(z,0));\n    rt=G.update(rt,0,i+1,P(0,-z));\n  }\n\n  for(int i=0;i<Q;i++){\n    char x;\n    int y,z;\n    scanf(\"%c %d %d\\n\",&x,&y,&z);\n    z++;\n    if(x=='('||x==')'){\n      z=(x=='('?1:-1);\n      T prev=G.get_val(rt,y-1);\n      T next=G.get_val(rt,y);\n      T curr(get<0>(prev),get<1>(next),z);\n      rt=G.insert(rt,y,Node(curr,P(0,0)));\n      rt=G.update(rt,y,G.count(rt),P(z,0));\n      rt=G.update(rt,0,y+1,P(0,-z));\n    }\n\n    if(x=='D'){\n      z=get<2>(G.get_val(rt,y));\n      rt=G.erase(rt,y);\n      rt=G.update(rt,y,G.count(rt),P(-z,0));\n      rt=G.update(rt,0,y,P(0,z));\n    }\n\n    if(x=='Q'){\n      T prev=G.get_val(rt,y-1);\n      T curr=G.query(rt,y,z);\n      T next=G.get_val(rt,z);\n      int ans=0;\n      if(get<0>(prev)>get<0>(curr)) ans+=get<0>(prev)-get<0>(curr);\n      if(get<1>(next)>get<1>(curr)) ans+=get<1>(next)-get<1>(curr);\n      printf(\"%d\\n\",ans);\n    }\n  }\n\n  return 0;\n}\n/*\n  verified on 2019/10/22\n  https://atcoder.jp/contests/code-festival-2014-exhibition-open/tasks/code_festival_exhibition_b\n*/\n\nsigned main(){\n  CODEFESTIVAL2014EXHIBITION_B();\n  return 0;\n}\n#endif\n\n#undef call_from_test\n\nsigned main(){\n  int n,q;\n  cin>>n>>q;\n\n  using P = pair<int, int>;\n  auto f=[](P a,P b){return P(a.first+b.first,a.second+b.second);};\n  auto g=[](P a,int b){return P(a.second*b,a.second);};\n  auto h=[](int a,int b){(void)a;return b;};\n\n  using Node = NodeBase<P, int>;\n  constexpr size_t LIM = 1e6;\n  Lazy<Node, LIM> G(f,g,h,P(0,0),-1010);\n  auto rt=G.build(vector<Node>(n,Node(P(0,1),-1010)));\n\n  for(int i=0;i<q;i++){\n    int c;\n    cin>>c;\n    if(c==0){\n      int s,t,x;\n      cin>>s>>t>>x;\n      rt=G.update(rt,s,t+1,x);\n    }\n    if(c==1){\n      int s,t;\n      cin>>s>>t;\n      cout<<G.query(rt,s,t+1).first<<\"\\n\";\n    }\n  }\n  cout<<flush;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename T, typename E>\nclass LazySegmentTree {\n    using F = function<T(T, T)>;\n    using G = function<T(T, E)>;\n    using H = function<E(E, E)>;\n    int n, height;\n    F f;\n    G g;\n    H h;\n    T t;\n    E e;\n    vector<T> dat;\n    vector<E> laz;\n\npublic:\n    LazySegmentTree(F f, G g, H h, T t, E e): f(f), g(g), h(h), t(t), e(e) {}\n\n    void init(int n_) {\n        n = 1;\n        height = 0;\n        while (n < n_) { n <<= 1; height++; }\n        dat.assign(2 * n, t);\n        laz.assign(2 * n, e);\n    }\n\n    void build(const vector<T> &v) {\n        auto n_ = (int)v.size();\n        init(n_);\n        for (int i = 0; i < n_; i++) dat[n + i] = v[i];\n        for (int i = n - 1; i > 0; i--) dat[i] = f(dat[(i << 1) | 0], dat[(i << 1) | 1]);\n    }\n\n    inline T reflect(int k) {\n        return laz[k] == e ? dat[k] : g(dat[k], laz[k]);\n    }\n\n    inline void eval(int k) {\n        if (laz[k] == e) return;\n        laz[(k << 1) | 0] = h(laz[(k << 1) | 0], laz[k]);\n        laz[(k << 1) | 1] = h(laz[(k << 1) | 1], laz[k]);\n        dat[k] = reflect(k);\n        laz[k] = e;\n    }\n\n    inline void thrust(int k) {\n        for (int i = height; i > 0; i--) {\n            eval(k >> i);\n        }\n    }\n\n    inline void recalc(int k) {\n        while (k >>= 1) {\n            dat[k] = f(reflect((k << 1) | 0), reflect((k << 1) | 1));\n        }\n    }\n\n    void update(int a, int b, E x) {\n        thrust(a += n);\n        thrust(b += n - 1);\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) laz[l] = h(laz[l], x), l++;\n            if (r & 1) --r, laz[r] = h(laz[r], x);\n        }\n        recalc(a);\n        recalc(b);\n    }\n\n    void set_val(int a, T x) {\n        thrust(a += n);\n        dat[a] = x;\n        laz[a] = e;\n        recalc(a);\n    }\n\n    T query(int a, int b) {\n        thrust(a += n);\n        thrust(b += n - 1);\n        T vl = t, vr = t;\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) vl = f(vl, reflect(l++));\n            if (r & 1) vr = f(reflect(--r), vr);\n        }\n        return f(vl, vr);\n    }\n};\n\n\n// verified\n//  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_G&lang=jp\nvoid AOJ_DSL_2_G() {\n    int n, q, c, s, t, x;\n    cin >> n >> q;\n\n    // 区間add, 区間sum\n    using P = pair<ll, ll>;\n    auto f = [](P a, P b) { return P(a.first + b.first, a.second + b.second); };\n    auto g = [](P a, ll b) { return P(a.first + b * a.second, a.second); };\n    auto h = [](ll a, ll b) { return a + b; };\n\n    LazySegmentTree<P, ll> seg(f, g, h, P(0, 0), 0);\n    seg.build(vector<P>(n, P(0, 1)));\n\n    while (q--) {\n        cin >> c;\n        if (c) {\n            cin >> s >> t;\n            cout << seg.query(s - 1, t).first << '\\n';\n        } else {\n            cin >> s >> t >> x;\n            seg.update(s - 1, t, x);\n        }\n    }\n}\n\n\n// verified\n//  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_I&lang=jp\nvoid AOJ_DSL_2_I() {\n    int n, q, c, s, t, x;\n    cin >> n >> q;\n\n    // 区間update, 区間sum\n    using P = pair<ll, ll>;\n    auto f = [](P a, P b) { return P(a.first + b.first, a.second + b.second); };\n    auto g = [](P a, ll b) { return P(a.second * b, a.second); };\n    auto h = [](ll a, ll b) { return b; };\n\n    LazySegmentTree<P, ll> seg(f, g, h, P(0, 0), -1005);\n    seg.build(vector<P>(n, P(0, 1)));\n\n    while (q--) {\n        cin >> c;\n        if (c) {\n            cin >> s >> t;\n            cout << seg.query(s, t + 1).first << '\\n';\n        } else {\n            cin >> s >> t >> x;\n            seg.update(s, t + 1, x);\n        }\n    }\n}\n\nint main() {\n    // AOJ_DSL_2_G();\n    AOJ_DSL_2_I();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint e = 10000;\ntemplate <typename T>\nstruct range_update_range_sum{\n\tint N;\n\tvector<T> ST;\n\tvector<T> lazy;\n\trange_update_range_sum(int n){\n\t\tN = 1;\n\t\twhile (N < n){\n\t\t\tN *= 2;\n\t\t}\n\t\tST = vector<T>(N * 2 - 1, 0);\n\t\tlazy = vector<T>(N * 2 - 1, e);\n\t}\n\trange_update_range_sum(vector<T> &A){\n\t\tint n = A.size();\n\t\tN = 1;\n\t\twhile (N < n){\n\t\t\tN *= 2;\n\t\t}\n\t\tST = vector<T>(N * 2 - 1, 0);\n\t\tlazy = vector<T>(N * 2 - 1, e);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tST[N - 1 + i] = A[i];\n\t\t}\n\t\tfor (int i = N - 2; i >= 0; i--){\n\t\t\tST[i] = ST[i * 2 + 1] + ST[i * 2 + 2];\n\t\t}\n\t}\n\tvoid eval(int i, int l, int r){\n\t\tif (lazy[i] != e){\n\t\t\tif (i < N - 1){\n\t\t\t\tlazy[i * 2 + 1] = lazy[i];\n\t\t\t\tlazy[i * 2 + 2] = lazy[i];\n\t\t\t}\n\t\t\tST[i] = lazy[i] * (r - l);\n\t\t\tlazy[i] = e;\n\t\t}\n\t}\n\tvoid range_update(int L, int R, T x, int i, int l, int r){\n\t\teval(i, l, r);\n\t\tif (R <= l || r <= L){\n\t\t\treturn;\n\t\t} else if (L <= l && r <= R){\n\t\t\tlazy[i] = x;\n\t\t\teval(i, l, r);\n\t\t} else {\n\t\t\tint m = (l + r) / 2;\n\t\t\trange_update(L, R, x, i * 2 + 1, l, m);\n\t\t\trange_update(L, R, x, i * 2 + 2, m, r);\n\t\t\tST[i] = ST[i * 2 + 1] + ST[i * 2 + 2];\n\t\t}\n\t}\n\tvoid range_update(int L, int R, T x){\n\t\trange_update(L, R, x, 0, 0, N);\n\t}\n\tT range_sum(int L, int R, int i, int l, int r){\n\t\teval(i, l, r);\n\t\tif (R <= l || r <= L){\n\t\t\treturn 0;\n\t\t} else if (L <= l && r <= R){\n\t\t\treturn ST[i];\n\t\t} else {\n\t\t\tint m = (l + r) / 2;\n\t\t\treturn range_sum(L, R, i * 2 + 1, l, m) + range_sum(L, R, i * 2 + 2, m, r);\n\t\t}\n\t}\n\tT range_sum(int L, int R){\n\t\treturn range_sum(L, R, 0, 0, N);\n\t}\n};\nint main(){\n  int n, q;\n  cin >> n >> q;\n  range_update_range_sum<long long> a(n);\n  for (int i = 0; i < q; i++){\n    int T;\n    cin >> T;\n    if (T == 0){\n      int s, t, x;\n      cin >> s >> t >> x;\n      a.range_update(s, t + 1, x);\n    }\n    if (T == 1){\n      int s, t;\n      cin >> s >> t;\n      cout << a.range_sum(s, t + 1) << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int segsize = 19;\n\nll SegTree[1<<segsize],Lazy[1<<segsize];\nbool Flag[1<<segsize];\nvoid denpa(int k,int l,int r)\n{\n\tif(Flag[k])\n\t{\n\t\tSegTree[k]=Lazy[k];\n\t\t//if(Lazy[k]!=INT_MAX)\n\t\tif(r-l>1)\n\t\t{\n\t\t\tLazy[2*k] = Lazy[k]/2;\n\t\t\tLazy[2*k+1] = Lazy[k]/2;\n\t\t\tFlag[k*2] = Flag[k*2+1]=true;\n\t\t}\n\t\tLazy[k]=0;\n\t\tFlag[k] = false;\n\t}\n}\n\nvoid update(int a,int b,ll x,int k=1,int l=0,int r =-1)\n{\n\tif(r<0)r=(1<<(segsize-1));\n\t//cout<<a<<' '<<b<<' '<<x<<' '<<k<<' '<<l<<' '<<r<<endl;\n\tdenpa(k,l,r);\n\tif(b<=l||r<=a)return;\n\tif(a<=l&&r<=b)\n\t{\n\t\tLazy[k] = (1LL)*x*(r-l);\n\t\tFlag[k] = true;\n\t\tdenpa(k,l,r);\n\t}\n\telse\n\t{\n\t\tupdate(a,b,x,k*2,l,(l+r)/2);\n\t\tupdate(a,b,x,k*2+1,(l+r)/2,r);\n\t\tSegTree[k] = SegTree[k*2]+SegTree[k*2+1];\n\t}\n}\n\nll getsum(int a,int b,int k=1,int l=0,int r=-1)\n{\n\tif(r<0)r = 1<<(segsize-1);\n\tdenpa(k,l,r);\n\tif(b<=l||r<=a)return 0;\n\tif(a<=l&&r<=b)return SegTree[k];\n\tll vl = getsum(a,b,k*2,l,(l+r)/2);\n\tll vr = getsum(a,b,2*k+1,(l+r)/2,r);\n\treturn vl+vr;\n}\n\nint main()\n{\n\tfor(int i = 0;i<(1<<segsize);i++)\n\t{\n\t\tSegTree[i]=0;\n\t\tLazy[i] = 0;\n\t}\n\tint n,q;\n\tcin >> n >> q;\n\tfor(int i = 0;i<q;i++)\n\t{\n\t\tint op;\n\t\tcin >> op;\n\t\tif(op)\n\t\t{\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\t\n\t\t\tcout<<getsum(a,b+1)<<endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint a,b,x;\n\t\t\tcin >> a >> b >> x;\n\t\t\t\n\t\t\tupdate(a,b+1,x);\n\t\t}\n\t\t//for (int i = 0; i < (1<<segsize); i++){cout<<SegTree[i]<<' '<<Lazy[i]<<endl;}cout<<endl;\n\t\t\n\t\t\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n \nstruct query{\n  int type;//0=empty, 1=add-sum ,2=set-min\n  ll value;\n  query(int a=0,ll b=0):type(a),value(b) {}\n};\n \n \n#define SIZE (1<<17)\n \nll INF=(1LL<<60);\n \n \nstruct segtree{\n  query s[SIZE*2];\n  ll t[SIZE*2];// sum-add\n  ll u[SIZE*2];// min-set\n   \n  void init(){\n    for(int i=0;i<SIZE*2;i++){\n      s[i]=query();\n      t[i]=0;\n      u[i]=0;\n    }\n  }\n \n  void func(int k,int l,int r,query q){\n    if(q.type==1){\n      if(s[k].type==0)s[k]=q;\n      else s[k].value+=q.value;\n      t[k]+=q.value*(r-l);\n      u[k]+=q.value;\n    }\n    if(q.type==2){\n      s[k]=q;\n      t[k]=q.value*(r-l);\n      u[k]=q.value;\n    }\n  }\n \n  void compute(int k,int l,int r){\n    query q=s[k];\n    s[k]=query();\n    if(q.type==0||r-l==1)return;\n    int m=(l+r)/2;\n    func(k*2+1,l,m,q);\n    func(k*2+2,m,r,q);\n  }\n \n  void Update(int a,int b,query x,int k=0,int l=0,int r=SIZE){\n    if(b<=l || r<=a)return;\n    compute(k,l,r);\n    if(a<=l && r<=b){\n      func(k,l,r,x);\n    }else{\n      int m=(l+r)/2;\n      Update(a,b,x,k*2+1,l,m);\n      Update(a,b,x,k*2+2,m,r);\n      t[k]=t[k*2+1]+t[k*2+2];\n      u[k]=min(u[k*2+1],u[k*2+2]);\n    }\n  }\n \n  ll Dfs(int type,int a,int b,int k=0,int l=0,int r=SIZE){\n    if(b<=l || r<=a){\n      if(type==1)return 0; //add\n      if(type==2)return INF; // min\n    }\n    compute(k,l,r);\n    if(a<=l && r<=b){\n      if(type==1)return t[k];\n      if(type==2)return u[k];\n    }else{\n      int m=(l+r)/2;\n      ll lv=Dfs(type,a,b,k*2+1,l,m);\n      ll rv=Dfs(type,a,b,k*2+2,m,r);\n      if(type==1)return lv+rv; // add\n      if(type==2)return min(lv,rv); // min\n    }\n  }\n \n  ll Getsum(int a,int b){\n    return Dfs(1,a,b);\n  }\n \n  ll Getmin(int a,int b){\n    return Dfs(2,a,b);\n  }\n \n};\n \nsegtree T;\n \nint main(){\n  T.init();\n   \n  int n,q;\n  scanf(\"%d %d\",&n,&q);\n  while(q--){\n    int a,b,c;\n    scanf(\"%d %d\",&a,&b);\n    if(a==0){\n      scanf(\"%d\",&c);\n      T.Update(a,b+1, query(2,c) );\n    }else{\n      printf(\"%lld\\n\", T.Getsum(a,b+1) );\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <limits>\n#include <iostream>\n#include <type_traits>\n#include <vector>\n#include <cstdint>\n#include <cassert>\n#define PROBLEM \"https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/all/DSL_2_I\"\nconstexpr unsigned int mod                  = 1000000007;\ntemplate<typename T> constexpr T inf_v      = std::numeric_limits<T>::max() / 4;\ntemplate<typename Real> constexpr Real pi_v = Real{3.141592653589793238462643383279502884};\ntemplate<typename Element>\nstruct assign\n{\n    using element_type  = Element;\n    using operator_type = element_type;\n    static operator_type compose(const operator_type& f1, const operator_type& f2) { return f1 != id() ? f1 : f2; }\n    assign() = delete;\n    static constexpr operator_type id() { return inf_v<operator_type>; }\n};\ntemplate<typename Element>\nstruct sum\n{\n    using element_type = Element;\n    using value_type   = element_type;\n    sum()              = delete;\n    static value_type merge(const value_type& a, const value_type& b) { return a + b; }\n    static constexpr value_type id() { return value_type{}; }\n};\ntemplate<typename ValueElement, typename OperatorElement>\nstruct sum_assign\n{\n    using value_element_type    = ValueElement;\n    using operator_element_type = OperatorElement;\n    using value_monoid_type     = sum<value_element_type>;\n    using operator_monoid_type  = assign<operator_element_type>;\n    using value_type            = typename value_monoid_type::value_type;\n    using operator_type         = typename operator_monoid_type::operator_type;\n    sum_assign()                = delete;\n    template<typename Ind>\n    static value_type apply(const operator_type& f, const value_type& x, const Ind l) { return f != operator_monoid_type::id() ? static_cast<value_type>(f) * static_cast<value_type>(l) : x; }\n};\n\nusing i32   = int32_t;\nusing i64   = int64_t;\nusing u32   = uint32_t;\nusing u64   = uint64_t;\nusing uint  = unsigned int;\nusing usize = std::size_t;\nusing ll    = long long;\nusing ull   = unsigned long long;\nusing ld    = long double;\ntemplate<typename T, usize n>\nusing arr = T (&)[n];\ntemplate<typename T, usize n>\nusing c_arr = const T (&)[n];\ntemplate<typename T>\nT in()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T, typename Uint, usize n, usize i>\nT in_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type) { return in<T>(); }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto in_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type& szs)\n{\n    const usize s = (usize)szs[i];\n    std::vector<decltype(in_v<T, Uint, n, i + 1>(szs))> ans(s);\n    for (usize j = 0; j < s; j++) { ans[j] = in_v<T, Uint, n, i + 1>(szs); }\n    return ans;\n}\ntemplate<typename T, typename Uint, usize n>\nauto in_v(c_arr<Uint, n> szs) { return in_v<T, Uint, n, 0>(szs); }\ntemplate<typename... Types>\nauto in_t() { return std::tuple<std::decay_t<Types>...>{in<Types>()...}; }\n\ntemplate<typename T>\nvoid out(const T& v) { std::cout << v; }\ntemplate<typename T>\nvoid out(const std::vector<T>& v)\n{\n    for (usize i = 0; i < v.size(); i++) {\n        if (i > 0) { std::cout << ' '; }\n        out(v[i]);\n    }\n    std::cout << \"\\n\";\n}\ntemplate<typename T1, typename T2>\nvoid out(const std::pair<T1, T2>& v) { out(v.first), std::cout << ' ', out(v.second); }\ntemplate<typename T, typename... Args>\nvoid out(const T& v, const Args... args) { out(v), std::cout << ' ', out(args...); }\ntemplate<typename... Args>\nvoid outln(const Args... args) { out(args...), std::cout << '\\n'; }\ntemplate<typename... Args>\nvoid outel(const Args... args) { out(args...), std::cout << std::endl; }\n\ntemplate<typename T> constexpr T popcount(const T u) { return u ? static_cast<T>(__builtin_popcountll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T log2p1(const T u) { return u ? static_cast<T>(64 - __builtin_clzll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T msbp1(const T u) { return log2p1(u); }\ntemplate<typename T> constexpr T lsbp1(const T u) { return __builtin_ffsll(u); }\ntemplate<typename T> constexpr T clog(const T u) { return u ? log2p1(u - 1) : static_cast<T>(u); }\ntemplate<typename T> constexpr bool ispow2(const T u) { return u and (static_cast<u64>(u) & static_cast<u64>(u - 1)) == 0; }\ntemplate<typename T> constexpr T ceil2(const T u) { return static_cast<T>(1) << clog(u); }\ntemplate<typename T> constexpr T floor2(const T u) { return u == 0 ? static_cast<T>(0) : static_cast<T>(1) << (log2p1(u) - 1); }\ntemplate<typename T> constexpr bool btest(const T mask, const usize ind) { return static_cast<bool>((static_cast<u64>(mask) >> ind) & static_cast<u64>(1)); }\ntemplate<typename T> void bset(T& mask, const usize ind) { mask |= (static_cast<T>(1) << ind); }\ntemplate<typename T> void breset(T& mask, const usize ind) { mask &= ~(static_cast<T>(1) << ind); }\ntemplate<typename T> void bflip(T& mask, const usize ind) { mask ^= (static_cast<T>(1) << ind); }\ntemplate<typename T> void bset(T& mask, const usize ind, const bool b) { (b ? bset(mask, ind) : breset(mask, ind)); }\ntemplate<typename T> constexpr T bcut(const T mask, const usize ind) { return ind == 0 ? static_cast<T>(0) : static_cast<T>((static_cast<u64>(mask) << (64 - ind)) >> (64 - ind)); }\ntemplate<typename MonoidAct>\nclass lazyseg\n{\npublic:\n    using monoid_act_type      = MonoidAct;\n    using value_monoid_type    = typename monoid_act_type::value_monoid_type;\n    using operator_monoid_type = typename monoid_act_type::operator_monoid_type;\n    using value_type           = typename value_monoid_type::value_type;\n    using operator_type        = typename operator_monoid_type::operator_type;\n    lazyseg(const usize sz, const value_type initial = value_monoid_type::id()) : sz{sz}, depth{clog(sz)}, half{static_cast<usize>(1) << depth}, val(half << 1, value_monoid_type::id()), op(half << 1, operator_monoid_type::id())\n    {\n        if (initial != value_monoid_type::id()) {\n            std::fill(val.begin() + half, val.end(), initial);\n            for (usize i = half - 1; i >= 1; i--) { up(i); }\n        }\n    }\n    template<typename InIt>\n    lazyseg(const InIt first, const InIt last) : sz{static_cast<usize>(std::distance(first, last))}, depth{clog(sz)}, half{static_cast<usize>(1) << depth}, val(half << 1, value_monoid_type::id()), op(half << 1, operator_monoid_type::id())\n    {\n        std::copy(first, last, val.begin() + half);\n        for (usize i = half - 1; i >= 1; i--) { up(i); }\n    }\n    value_type get(const usize a) { return assert(a < sz), fold(a, a + 1); }\n    void set(usize a, const value_type& v)\n    {\n        assert(a < sz);\n        top_down(a += half), top_down(a + 1), op[a] = operator_monoid_type::id(), val[a] = v;\n        while (a >>= 1) { up(a); }\n    }\n    value_type fold(usize l, usize r)\n    {\n        assert(l < r), assert(r <= sz);\n        top_down(l += half), top_down(r += half);\n        value_type accl = value_monoid_type::id(), accr = value_monoid_type::id();\n        for (; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) { accl = value_monoid_type::merge(accl, val[l++]); }\n            if (r & 1) { accr = value_monoid_type::merge(val[--r], accr); }\n        }\n        return value_monoid_type::merge(accl, accr);\n    }\n    void act(usize l, usize r, const operator_type& f)\n    {\n        assert(l < r), assert(r <= sz);\n        const usize lin = l + half, rin = r + half;\n        top_down(l += half), top_down(r += half);\n        for (usize ls = 1, rs = 1; l < r; l >>= 1, r >>= 1, ls <<= 1, rs <<= 1) {\n            if (l & 1) { update(l++, f, ls); }\n            if (r & 1) { update(--r, f, rs); }\n        }\n        bottom_up(lin), bottom_up(rin);\n    }\n    usize size() const { return sz; }\n    friend std::ostream& operator<<(std::ostream& os, const lazyseg& lseg)\n    {\n        auto lseg2 = lseg;\n        os << \"[\";\n        for (usize i = 0; i < lseg.sz; i++) { os << lseg2.get(i) << (i + 1 == lseg2.sz ? \"\" : \",\"); }\n        return (os << \"]\\n\");\n    }\n\nprivate:\n    void up(const usize i) { val[i] = value_monoid_type::merge(val[i << 1], val[i << 1 | 1]); }\n    void update(const usize a, const operator_type& f, const usize l) { op[a] = operator_monoid_type::compose(f, op[a]), val[a] = monoid_act_type::apply(f, val[a], l); }\n    void down(const usize a, const usize l) { update(a << 1, op[a], l >> 1), update(a << 1 | 1, op[a], l >> 1), op[a] = operator_monoid_type::id(); }\n    void top_down(const usize a)\n    {\n        const usize b = (a / (a & -a)) >> 1;\n        for (usize i = 0, l = half; i < depth; i++, l >>= 1) {\n            const usize v = a >> (depth - i);\n            if (v > b) { break; }\n            down(v, l);\n        }\n    }\n    void bottom_up(usize a)\n    {\n        a = (a / (a & -a)) >> 1;\n        for (; a >= 1; a >>= 1) { up(a); }\n    }\n    const usize sz, depth, half;\n    std::vector<value_type> val;\n    std::vector<operator_type> op;\n};\nint main()\n{\n    const auto n = in<usize>();\n    const auto q = in<usize>();\n    lazyseg<sum_assign<ll, ll>> seg(n, 0LL);\n    for (usize i = 0; i < q; i++) {\n        const auto c = in<usize>();\n        if (c == 0) {\n            const auto l = in<usize>();\n            const auto r = in<usize>() + 1;\n            const auto x = in<ll>();\n            seg.act(l, r, x);\n        } else {\n            const auto l = in<usize>();\n            const auto r = in<usize>() + 1;\n            outln(seg.fold(l, r));\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <iomanip>\n#include <math.h>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <bitset>\n#include <functional>\n#include <assert.h>\nusing ll=long long;\n#define int ll\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define eb emplace_back\n#define all(x) x.begin(),x.end()\n#define SZ(x) x.size()\n#define fi first\n#define se second\nconst int INF = 1e9;\nusing namespace std;\n\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class T>\ninline bool chmax(T &a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>\ninline bool chmin(T &a,T b){if(a>b){a=b;return true;}return false;}\n\ntemplate <typename T,typename E>\nstruct SegmentTree{\n    using F = function<T(T,T)>;\n    using G = function<T(T,E)>;\n    using H = function<E(E,E)>;\n    int n,height;\n    F f;\n    G g;\n    H h;\n    T ti;\n    E ei;\n    vector<T> dat;\n    vector<E> laz;\n    vi len;\n    SegmentTree(F f,G g,H h,T ti,E ei):\n        f(f),g(g),h(h),ti(ti),ei(ei){}\n\n    void init(int n_){\n        n=1;height=0;\n        while(n<n_) n<<=1,height++;\n        dat.assign(2*n,ti);\n        laz.assign(2*n,ei);\n        len.assign(2*n,0ll);\n        for(int i=0;i<n_;i++) len[n+i]=1;\n        for(int i=n-1;i;i--)\n            len[i]=len[(i<<1)|0]+len[(i<<1)|1];\n    }\n    void build(const vector<T> &v){\n        int n_=v.size();\n        init(n_);\n        for(int i=0;i<n_;i++) dat[n+i]=v[i];\n        for(int i=n-1;i;i--)\n            dat[i]=f(dat[(i<<1)|0],dat[(i<<1)|1]);\n    }\n    inline T reflect(int k){\n        return laz[k]==ei?dat[k]:g(dat[k],pi(laz[k].fi,laz[k].se*len[k])); //区間によって変化するときはlen[k]をかける\n    }\n    inline void propagate(int k){\n        if(laz[k]==ei) return;\n        laz[(k<<1)|0]=h(laz[(k<<1)|0],laz[k]);\n        laz[(k<<1)|1]=h(laz[(k<<1)|1],laz[k]);\n        dat[k]=reflect(k);\n        laz[k]=ei;\n    }\n    inline void thrust(int k){\n        for(int i=height;i;i--) propagate(k>>i);\n    }\n    inline void recalc(int k){\n        while(k>>=1)\n            dat[k]=f(reflect((k<<1)|0),reflect((k<<1)|1));\n    }\n    void update(int a,int b,E x){\n        if(a>=b) return;\n        thrust(a+=n);\n        thrust(b+=n-1);\n        for(int l=a,r=b+1;l<r;l>>=1,r>>=1){\n            if(l&1) laz[l]=h(laz[l],x),l++;\n            if(r&1) --r,laz[r]=h(laz[r],x);\n        }\n        recalc(a);\n        recalc(b);\n    }\n    void set_val(int a,T x){\n        thrust(a+=n);\n        dat[a]=x;laz[a]=ei;\n        recalc(a);\n    }\n    T query(int a,int b){\n        if(a>=b) return ti;\n        thrust(a+=n);\n        thrust(b+=n-1);\n        T vl=ti,vr=ti;\n        for(int l=a,r=b+1;l<r;l>>=1,r>>=1) {\n            if(l&1) vl=f(vl,reflect(l++));\n            if(r&1) vr=f(reflect(--r),vr);\n        }\n        return f(vl,vr);\n    }\n\n    template<typename C>\n    int find(int st,C &check,T &acc,int k,int l,int r){\n        if(l+1==r){\n            acc=f(acc,reflect(k));\n            return check(acc)?k-n:-1;\n        }\n        propagate(k);\n        int m=(l+r)>>1;\n        if(m<=st) return find(st,check,acc,(k<<1)|1,m,r);\n        if(st<=l&&!check(f(acc,dat[k]))){\n            acc=f(acc,dat[k]);\n            return -1;\n        }\n        int vl=find(st,check,acc,(k<<1)|0,l,m);\n        if(~vl) return vl;\n        return find(st,check,acc,(k<<1)|1,m,r);\n    }\n    template<typename C>\n    int find(int st,C &check){\n        T acc=ti;\n        return find(st,check,acc,1,0,n);\n    }\n};\n\nsigned main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout<<fixed<<setprecision(20);\n\n    int n,q; cin >> n >> q;\n    auto f=[](pi a,pi b){return pi(a.fi,a.se+b.se);};\n    auto g=[](pi a,pi b){return b;};\n    auto h=[](pi a,pi b){return max(a,b);};\n    SegmentTree<pi,pi> seg(f,g,h,pi(-1,0),pi(-1,0));\n    seg.init(n);\n    rep(i,q){\n        int s; cin >> s;\n        if(s==0){\n            int t,u,v; cin >> t >> u >> v;\n            seg.update(t,u+1,pi(i,v));\n        }\n        else {\n            int t,u; cin >> t >> u;\n            cout << seg.query(t,u+1).second << \"\\n\";\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nstruct SegmentTree {\n  using D = lint;\n\n  using T = struct { D sum, sz; };\n  static T op(const T& a, const T& b) { return {a.sum + b.sum, a.sz + b.sz}; }\n  static constexpr T e() { return {0, 0}; }\n  using U = struct {\n    D p, q;\n    bool operator==(const auto& r) const { return p == r.p and q == r.q; }\n  };\n  static void ap(const U& f, T& a) { a.sum = f.p * a.sum + f.q * a.sz; }\n  static void cp(const U& g, U& f) { f.p *= g.p, f.q = g.p * f.q + g.q; }\n  static constexpr U id() { return {1, 0}; }\n  // ヘルパ関数\n  D sum(int l, int r) { return acc(l, r).sum; }\n  void add(int l, int r, D x) { act(l, r, {1, x}); }\n  void mul(int l, int r, D x) { act(l, r, {x, 0}); }\n  void update(int l, int r, D x) { act(l, r, {0, x}); }\n\n  const int n;\n  V<T> t;\n  V<U> u;\n  SegmentTree(int n) : n(n), t(2 * n, e()), u(n, id()) {}\n  T& operator[](int i) { return t[i + n]; }\n  void build() { for (int i = n - 1; i; --i) t[i] = op(t[2 * i], t[2 * i + 1]); }\n  void push() { for (int i = 1; i < n; ++i) push(i); }\n  void apply(const U& f, int i) {\n    ap(f, t[i]);\n    if (i < n) cp(f, u[i]);\n  }\n  void push(int i) {\n    if (u[i] == id()) return;\n    apply(u[i], 2 * i);\n    apply(u[i], 2 * i + 1);\n    u[i] = id();\n  }\n  void push(int l, int r) {\n    for (int hl = __lg(l + n), hr = __lg(r - 1 + n); hr > 0; --hl, --hr) {\n      int al = l + n >> hl, ar = r - 1 + n >> hr;\n      if (al < n) push(al);\n      if (ar != al) push(ar);\n    }\n  }\n  T acc(int l, int r) {\n    push(l, r);\n    T resl = e(), resr = e();\n    for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n      if (l & 1) resl = op(resl, t[l++]);\n      if (r & 1) resr = op(t[--r], resr);\n    }\n    return op(resl, resr);\n  }\n  T get(int i) { return acc(i, i + 1); }\n  void act(int l, int r, const U& f) {\n    push(l, r);\n    for (int i = l + n, j = r + n; i < j; i >>= 1, j >>= 1) {\n      if (i & 1) apply(f, i++);\n      if (j & 1) apply(f, --j);\n    }\n    l = l + n >> __builtin_ctz(l + n);\n    while (l >>= 1) t[l] = op(t[2 * l], t[2 * l + 1]);\n    r = r + n >> __builtin_ctz(r + n);\n    while (r >>= 1) t[r] = op(t[2 * r], t[2 * r + 1]);\n  }\n  void set(int i, const T& a) {\n    push(i, i + 1);\n    t[i += n] = a;\n    while (i >>= 1) t[i] = op(t[2 * i], t[2 * i + 1]);\n  }\n};\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n, q; cin >> n >> q;\n  SegmentTree st(n);\n  for (int i = 0; i < n; ++i) st.set(i, {0, 1});\n  while (q--) {\n    int tp; cin >> tp;\n    if (!tp) {\n      int l, r, x; cin >> l >> r >> x, ++r;\n      st.update(l, r, x);\n    } else {\n      int l, r; cin >> l >> r, ++r;\n      cout << st.sum(l, r) << '\\n';\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <class T, class E>\nstruct SegmentTreeLaze {\n  // 1-indexed\n  typedef function<T(T, T)> F;\n  typedef function<T(T, E)> G;\n  typedef function<E(E, E)> H;\n  int n, height;\n  F f;\n  G g;\n  H h;\n  T tunit;\n  E eunit;\n  vector<T> dat;\n  vector<E> laz;\n  SegmentTreeLaze(){};\n  SegmentTreeLaze(int newn, F f, G g, H h, T nt, E ne)\n      : f(f), g(g), h(h), tunit(nt), eunit(ne) {\n    init(newn);\n  }\n  void init(int newn) {\n    n = 1, height = 0;\n    while(n < newn) n <<= 1, ++height;\n    dat.assign(n << 1, tunit);\n    laz.assign(n << 1, eunit);\n  }\n\n  inline T reflect(int k) {\n    return laz[k] == eunit ? dat[k] : g(dat[k], laz[k]);\n  }\n\n  inline void eval(int k) {\n    if(laz[k] == eunit) return;\n    laz[k << 1] = h(laz[k << 1], laz[k]);\n    laz[(k << 1) | 1] = h(laz[(k << 1) | 1], laz[k]);\n    dat[k] = reflect(k);\n    laz[k] = eunit;\n  }\n\n  inline void thrust(int k) {\n    for(int i = height; i; --i) eval(k >> i);\n  }\n\n  void recalc(int k) {\n    while(k >>= 1)\n      dat[k] = f(reflect(k << 1), reflect((k << 1) | 1));\n  }\n  // [a,b)\n  void update(int a, int b, E newdata) {\n    thrust(a += n);\n    thrust(b += n - 1);\n    for(int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) laz[l] = h(laz[l], newdata), l++;\n      if(r & 1) --r, laz[r] = h(laz[r], newdata);\n    }\n    recalc(a);\n    recalc(b);\n  }\n\n  void set_val(int k, T newdata) {\n    thrust(k += n);\n    dat[k] = newdata;\n    laz[k] = eunit;\n    recalc(k);\n  }\n\n  // [a,b)\n  T query(int a, int b) {\n    thrust(a += n);\n    thrust(b += n - 1);\n    T vl = tunit, vr = tunit;\n    for(int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) vl = f(vl, reflect(l++));\n      if(r & 1) vr = f(reflect(--r), vr);\n    }\n    return f(vl, vr);\n  }\n};\n\nlong long n, q;\n\nint main() {\n  cin >> n >> q;\n  using P = pair<long long, long long>;\n  auto f = [](P l, P r) {\n    return P(l.first + r.first, l.second + r.second);\n  };\n  auto g = [](P l, long long r) {\n    return P(r * l.second, l.second);\n  };\n  auto h = [](long long l, long long r) { return r; };\n  SegmentTreeLaze<P, long long> seg(n, f, g, h, P(0, 0),\n                                    -100000);\n  for(int i = 0; i < n; ++i) seg.set_val(i, P(0, 1));\n  for(int i = 0; i < q; ++i) {\n    long long c, s, t, x;\n    cin >> c >> s >> t;\n    if(c)\n      cout << seg.query(s, t + 1).first << endl;\n    else {\n      cin >> x;\n      seg.update(s, t + 1, x);\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _MSC_VER\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#define fseek_unlocked fseek\n#endif\n\n//author : beet_aizu\ntemplate <typename T, typename E>\nstruct SegmentTree\n{\n    using F = function<T(T, T)>;\n    using G = function<T(T, E)>;\n    using H = function<E(E, E)>;\n    int n, height;\n    F f;\n    G g;\n    H h;\n    T ti;\n    E ei;\n    vector<T> dat;\n    vector<E> laz;\n    SegmentTree(F f, G g, H h, T ti, E ei) :\n        f(f), g(g), h(h), ti(ti), ei(ei) {}\n\n    void init(int n_) {\n        n = 1; height = 0;\n        while (n < n_) n <<= 1, height++;\n        dat.assign(2 * n, ti);\n        laz.assign(2 * n, ei);\n    }\n    void build(const vector<T>& v) {\n        int n_ = v.size();\n        init(n_);\n        for (int i = 0; i < n_; i++) dat[n + i] = v[i];\n        for (int i = n - 1; i; i--)\n            dat[i] = f(dat[(i << 1) | 0], dat[(i << 1) | 1]);\n    }\n    inline T reflect(int k) {\n        return laz[k] == ei ? dat[k] : g(dat[k], laz[k]);\n    }\n    inline void eval(int k) {\n        if (laz[k] == ei) return;\n        laz[(k << 1) | 0] = h(laz[(k << 1) | 0], laz[k]);\n        laz[(k << 1) | 1] = h(laz[(k << 1) | 1], laz[k]);\n        dat[k] = reflect(k);\n        laz[k] = ei;\n    }\n    inline void thrust(int k) {\n        for (int i = height; i; i--) eval(k >> i);\n    }\n    inline void recalc(int k) {\n        while (k >>= 1)\n            dat[k] = f(reflect((k << 1) | 0), reflect((k << 1) | 1));\n    }\n    inline void recalc(int l, int r) {\n        int Xor = l ^ r;\n        while (Xor > 1) { \n            Xor >>= 1; l >>= 1; r >>= 1; \n            dat[l] = f(reflect((l << 1) | 0), reflect((l << 1) | 1));\n            dat[r] = f(reflect((r << 1) | 0), reflect((r << 1) | 1));\n        }\n        while (l > 1) {\n            l >>= 1;\n            dat[l] = f(reflect((l << 1) | 0), reflect((l << 1) | 1));\n        }\n    }\n    void update(int a, int b, E x) {\n        thrust(a += n);\n        thrust(b += n - 1);\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1)\n        {\n            if (l & 1) laz[l] = h(laz[l], x), l++;\n            if (r & 1) --r, laz[r] = h(laz[r], x);\n        }\n        recalc(a, b);\n    }\n    void set_val(int a, T x) {\n        thrust(a += n);\n        dat[a] = x; laz[a] = ei;\n        recalc(a);\n    }\n    T query(int a, int b) {\n        thrust(a += n);\n        thrust(b += n - 1);\n        T vl = ti, vr = ti;\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1)\n        {\n            if (l & 1) vl = f(vl, reflect(l++));\n            if (r & 1) vr = f(reflect(--r), vr);\n        }\n        return f(vl, vr);\n    }\n\n    template<typename C>\n    int find(int st, C& check, T& acc, int k, int l, int r) {\n        if (l + 1 == r)\n        {\n            acc = f(acc, reflect(k));\n            return check(acc) ? k - n : -1;\n        }\n        eval(k);\n        int m = (l + r) >> 1;\n        if (m <= st) return find(st, check, acc, (k << 1) | 1, m, r);\n        if (st <= l && !check(f(acc, dat[k])))\n        {\n            acc = f(acc, dat[k]);\n            return -1;\n        }\n        int vl = find(st, check, acc, (k << 1) | 0, l, m);\n        if (~vl) return vl;\n        return find(st, check, acc, (k << 1) | 1, m, r);\n    }\n    template<typename C>\n    int find(int st, C& check) {\n        T acc = ti;\n        return find(st, check, acc, 1, 0, n);\n    }\n};\n\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n    using P = pair<int, int>;\n    auto f = [](P a, P b) { return P(a.first + b.first, a.second + b.second); };\n    auto g = [](P a, int b) { return P(a.second * b, a.second); };\n    auto h = [](int a, int b) { (void)a; return b; };\n\n    SegmentTree<P, int> ch(f, g, h, P(0, 0), -1010);\n    ch.build(vector<P>(n, P(0, 1)));\n    for (int i = 0; i < q; i++)\n    {\n        int c, s, t, x;\n        scanf(\"%d\", &c);\n        if (c)\n        {\n            scanf(\"%d %d\", &s, &t);\n            printf(\"%d\\n\", ch.query(s, t + 1).first);\n        }\n        else\n        {\n            scanf(\"%d %d %d\", &s, &t, &x);\n            ch.update(s, t + 1, x);\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#include <boost/multiprecision/cpp_int.hpp>\n//using multiInt = boost::multiprecision::cpp_int;\n\nusing ll = long long int;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\ntemplate <typename Q_type>\nusing smaller_queue = priority_queue<Q_type, vector<Q_type>, greater<Q_type>>;\n\nconst int MOD_TYPE = 2;\nconst ll MOD = (MOD_TYPE == 1 ? (ll)(1e9 + 7) : 998244353);\nconst int INF = (int)1e9;\nconst ll LINF = (ll)4e18;\nconst ld DINF = 1e12;\nconst ld PI = acos(-1.0);\nconst ld EPS = 1e-11;\n\n#define REP(i, m, n) for (ll i = m; i < (ll)(n); ++i)\n#define rep(i, n) REP(i, 0, n)\n#define MP make_pair\n#define MT make_tuple\n#define YES(n) cout << ((n) ? \"YES\" : \"NO\") << endl\n#define Yes(n) cout << ((n) ? \"Yes\" : \"No\") << endl\n#define Possible(n) cout << ((n) ? \"Possible\" : \"Impossible\") << endl\n#define possible(n) cout << ((n) ? \"possible\" : \"impossible\") << endl\n#define Yay(n) cout << ((n) ? \"Yay!\" : \":(\") << endl\n#define all(v) v.begin(), v.end()\n#define NP(v) next_permutation(all(v))\n#define dbg(x) cerr << #x << \":\" << x << endl;\n\nvector<int> Dx = {0, 0, -1, 1, -1, 1, -1, 1, 0};\nvector<int> Dy = {1, -1, 0, 0, -1, -1, 1, 1, 0};\n\ntemplate <typename T, typename E>\nstruct SegmentTree\n{\n  using F = function<T(T, T)>;\n  using G = function<T(T, E)>;\n  using H = function<E(E, E)>;\n  int n, height;\n  F f;\n  G g;\n  H h;\n  T ti;\n  E ei;\n  vector<T> dat;\n  vector<E> laz;\n  SegmentTree(F f, G g, H h, T ti, E ei) : f(f), g(g), h(h), ti(ti), ei(ei) {}\n\n  void init(int n_)\n  {\n    n = 1;\n    height = 0;\n    while (n < n_)\n      n <<= 1, height++;\n    dat.assign(2 * n, ti);\n    laz.assign(2 * n, ei);\n  }\n\n  void build(const vector<T> &v)\n  {\n    int n_ = v.size();\n    init(n_);\n    for (int i = 0; i < n_; i++)\n      dat[n + i] = v[i];\n    for (int i = n - 1; i; i--)\n      dat[i] = f(dat[(i << 1) | 0], dat[(i << 1) | 1]);\n  }\n\n  inline T reflect(int k)\n  {\n    return laz[k] == ei ? dat[k] : g(dat[k], laz[k]);\n  }\n\n  inline void propagate(int k)\n  {\n    if (laz[k] == ei)\n      return;\n    laz[(k << 1) | 0] = h(laz[(k << 1) | 0], laz[k]);\n    laz[(k << 1) | 1] = h(laz[(k << 1) | 1], laz[k]);\n    dat[k] = reflect(k);\n    laz[k] = ei;\n  }\n\n  inline void thrust(int k)\n  {\n    for (int i = height; i; i--)\n      propagate(k >> i);\n  }\n\n  inline void recalc(int k)\n  {\n    while (k >>= 1)\n      dat[k] = f(reflect((k << 1) | 0), reflect((k << 1) | 1));\n  }\n\n  void update(int a, int b, E x)\n  {\n    if (a >= b)\n      return;\n    thrust(a += n);\n    thrust(b += n - 1);\n    for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1)\n    {\n      if (l & 1)\n        laz[l] = h(laz[l], x), l++;\n      if (r & 1)\n        --r, laz[r] = h(laz[r], x);\n    }\n    recalc(a);\n    recalc(b);\n  }\n\n  void set_val(int a, T x)\n  {\n    thrust(a += n);\n    dat[a] = x;\n    laz[a] = ei;\n    recalc(a);\n  }\n\n  T query(int a, int b)\n  {\n    if (a >= b)\n      return ti;\n    thrust(a += n);\n    thrust(b += n - 1);\n    T vl = ti, vr = ti;\n    for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1)\n    {\n      if (l & 1)\n        vl = f(vl, reflect(l++));\n      if (r & 1)\n        vr = f(reflect(--r), vr);\n    }\n    return f(vl, vr);\n  }\n};\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << setprecision(30) << setiosflags(ios::fixed);\n\n  int n, q;\n  cin >> n >> q;\n  auto f = [](pll a, pll b) { return MP(a.first + b.first, a.second + b.second); };\n  auto g = [](pll a, ll b) { return MP(a.second * b, a.second); };\n  auto h = [](ll a, ll b) { return b; };\n  SegmentTree<pll, ll> sg(f, g, h, MP(0, 0), -10000000);\n  sg.build(vector<pll>(n, MP(0, 1)));\n  rep(qi, q)\n  {\n    int type;\n    cin >> type;\n    if (type == 0)\n    {\n      ll s, t, x;\n      cin >> s >> t >> x;\n      sg.update(s, t + 1, x);\n    }\n    else if (type == 1)\n    {\n      ll s, t;\n      cin >> s >> t;\n      cout << sg.query(s, t + 1).first << \"\\n\";\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\ntemplate<typename T, typename E> struct LazySegmentTree {\n  using F = function<T(T, T)>;\n  using G = function<T(T, E)>;\n  using H = function<E(E, E)>;\n  using P = function<E(E, int)>;\n\n  struct QueryObject {\n    int a, b;\n    E x;\n    int k;\n    int l, r;\n    QueryObject(int a, int b, E x = 0, int k = 0, int l = 0, int r = -1)\n        : a(a), b(b), x(x), k(k), l(l), r(r) {}\n  };\n\n  struct QueryType {\n    virtual T outOfRange(LazySegmentTree<T, E>& lst, QueryObject& o) = 0;\n    virtual T cover(LazySegmentTree<T, E>& lst, QueryObject& o) = 0;\n    virtual T join(LazySegmentTree<T, E>& lst, QueryObject& o, T vl, T vr) = 0;\n    T query(LazySegmentTree<T, E>& lst, QueryObject o) {\n      if (o.r < 0) o.r = lst.n;\n      lst.eval(o.r - o.l, o.k);\n      if (o.b <= o.l || o.r <= o.a) return outOfRange(lst, o);\n      if (o.a <= o.l && o.r <= o.b) return cover(lst, o);\n      QueryObject o1 = o, o2 = o;\n      o1.k = o.k * 2 + 1; o1.r = (o.l + o.r) / 2;\n      o2.k = o.k * 2 + 2; o2.l = (o.l + o.r) / 2;\n      T vl = query(lst, o1);\n      T vr = query(lst, o2);\n      return join(lst, o, vl, vr);\n    }\n  };\n\n  struct Setter : QueryType {\n    enum setter { RUQ, RAQ };\n    T outOfRange(LazySegmentTree<T, E>& lst, QueryObject& o) {\n      return lst.data[o.k];\n    }\n    T cover(LazySegmentTree<T, E>& lst, QueryObject& o) {\n      lst.lazy[o.k] = lst.h(lst.lazy[o.k], o.x);\n      lst.eval(o.r - o.l, o.k);\n      return lst.data[o.k];\n    }\n    T join(LazySegmentTree<T, E>& lst, QueryObject& o, T vl, T vr) {\n      return lst.data[o.k] = lst.f(vl, vr);\n    }\n  };\n\n  struct Getter : QueryType {\n    enum getter { RMQ, RSQ };\n    T outOfRange(LazySegmentTree<T, E>& lst, QueryObject& o) {\n      return lst.initT;\n    }\n    T cover(LazySegmentTree<T, E>& lst, QueryObject& o) {\n      return lst.data[o.k];\n    }\n    T join(LazySegmentTree<T, E>& lst, QueryObject& o, T vl, T vr) {\n      return lst.f(vl, vr);\n    }\n  };\n\n  F add() {\n    return [&](const T& x, const T& y) -> const T { return x + y; };\n  }\n  F minimum() {\n    return [&](const T& x, const T& y) -> const T { return min(x, y); };\n  }\n  G ex_assign(E initE) {\n    return [&initE](const T& x, const E& y) -> const T { return (y == initE) ? x : y; };\n  }\n  P ex_multiplies(E initE) {\n    return [&initE](const E& x, int y) -> const E { return (x == initE) ? x : x * y; };\n  }\n\n  int n;\n  T initT;\n  E initE;\n  F f;\n  G g;\n  H h;\n  P p;\n  vector<T> data;\n  vector<E> lazy;\n  QueryType *type;\n\n  LazySegmentTree() {}\n  LazySegmentTree(QueryType *type_) { type = type_; }\n  LazySegmentTree(int n_, int setter, int getter,\n      T initT_ = INT_MAX, E initE_ = INT_MAX, vector<T> v = vector<T>()) {\n    setQuery(setter, getter, initT_, initE_);\n    n = 1;\n    while (n < n_) n *= 2;\n    data.assign(n * 2 - 1, initT);\n    lazy.assign(n * 2 - 1, initE);\n    if (n_ == v.size()) build(v);\n  }\n  void build(vector<T> v) {\n    for (int i = 0; i < v.size(); ++i) data[i + n - 1] = v[i];\n    for (int i = n - 2; i >= 0; --i) {\n      data[i] = f(data[i * 2 + 1], data[i * 2 + 2]);\n    }\n  }\n  void setQuery(int setter, int getter, T initT_, E initE_) {\n    initT = vector<T>{initT_, 0}[getter];\n    initE = vector<E>{initE_, 0}[setter];\n    f = vector<F>{minimum(), add()}[getter];\n    g = vector<G>{ex_assign(initE), add()}[setter];\n    h = vector<H>{ex_assign(initE), add()}[setter];\n    p = ex_multiplies(initE);\n  }\n  inline void eval(int len, int k) {\n    if (lazy[k] == initE) return;\n    if (k * 2 + 1 < n * 2 - 1) {\n      lazy[k * 2 + 1] = h(lazy[k * 2 + 1], lazy[k]);\n      lazy[k * 2 + 2] = h(lazy[k * 2 + 2], lazy[k]);\n    }\n    data[k] = g(data[k], p(lazy[k], len));\n    lazy[k] = initE;\n  }\n  T setData(int a, int b, E x) {\n    LazySegmentTree<T, E> lst(new Setter());\n    QueryObject obj(a, b, x);\n    return lst.type->query(*this, QueryObject{a, b, x});\n  }\n  T getData(int a, int b) {\n    LazySegmentTree<T, E> lst(new Getter());\n    QueryObject obj(a, b);\n    return lst.type->query(*this, QueryObject{a, b});\n  }\n};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, q; cin >> n >> q;\n  LazySegmentTree<ll, ll> seg(n, LazySegmentTree<ll, ll>::Setter::RUQ, LazySegmentTree<ll, ll>::Getter::RSQ);\n\n  while (q--) {\n    int com; cin >> com;\n    if (com) {\n      int s, t; cin >> s >> t;\n      cout << seg.getData(s, t + 1) << endl;\n    } else {\n      int s, t, x; cin >> s >> t >> x;\n      seg.setData(s, t + 1, x);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n \n#define REP(i,n) for(long long i = 0; i < (n); i++)\n#define FOR(i, m, n) for(long long i = (m);i < (n); ++i)\n#define ALL(obj) (obj).begin(),(obj).end()\n#define SPEED cin.tie(0);ios::sync_with_stdio(false);\n \ntemplate<class T> using V = vector<T>;\ntemplate<class T, class U> using P = pair<T, U>;\ntemplate<class T> using PQ = priority_queue<T>;\ntemplate<class T> using PQR = priority_queue<T,vector<T>,greater<T>>;\n \nconstexpr long long MOD = (long long)1e9 + 7;\nconstexpr long long MOD2 = 998244353;\nconstexpr long long HIGHINF = (long long)1e18;\nconstexpr long long LOWINF = (long long)1e15;\nconstexpr long double PI = 3.1415926535897932384626433;\n \ntemplate <class T> vector<T> multivector(size_t N,T init){return vector<T>(N,init);}\ntemplate <class... T> auto multivector(size_t N,T... t){return vector<decltype(multivector(t...))>(N,multivector(t...));}\ntemplate <class T> void corner(bool flg, T hoge) {if (flg) {cout << hoge << endl; exit(0);}}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const map<T, U>&obj) {o << \"{\"; for (auto &x : obj) o << \" {\" << x.first << \" : \" << x.second << \"}\" << \",\"; o << \" }\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const set<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const multiset<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const vector<T>&obj) {o << \"{\"; for (int i = 0; i < (int)obj.size(); ++i)o << (i > 0 ? \", \" : \"\") << obj[i]; o << \"}\"; return o;}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const pair<T, U>&obj) {o << \"{\" << obj.first << \", \" << obj.second << \"}\"; return o;}\ntemplate <template <class tmp>  class T, class U> ostream &operator<<(ostream &o, const T<U> &obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr)o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\nvoid print(void) {cout << endl;}\ntemplate <class Head> void print(Head&& head) {cout << head;print();}\ntemplate <class Head, class... Tail> void print(Head&& head, Tail&&... tail) {cout << head << \" \";print(forward<Tail>(tail)...);}\ntemplate <class T> void chmax(T& a, const T b){a=max(a,b);}\ntemplate <class T> void chmin(T& a, const T b){a=min(a,b);}\nvoid YN(bool flg) {cout << (flg ? \"YES\" : \"NO\") << endl;}\nvoid Yn(bool flg) {cout << (flg ? \"Yes\" : \"No\") << endl;}\nvoid yn(bool flg) {cout << (flg ? \"yes\" : \"no\") << endl;}\n\ntemplate<class Operator> class LazySegmentTree {\n    Operator Op;                                       \n\tusing typeNode = decltype(Op.unitNode);          \n\tusing typeLazy = decltype(Op.unitLazy);          \n\tsize_t length;                                   \n\tsize_t height;                                   \n\tvector<typeNode> node;                           \n\tvector<typeLazy> lazy;                           \n\tvector<pair<size_t,size_t>> range;\npublic:\n\n\t//unitで初期化\n\tLazySegmentTree(const size_t num) {\n\t\tfor (length = 1,height = 0; length < num; length *= 2, height++);\n\t\tnode.resize(2 * length, Op.unitNode);\n\t\tlazy.resize(2 * length, Op.unitLazy);\n\t\tfor (int i = 0; i < num; ++i) node[i + length] = Op.unitNode;\n\t\tfor (int i = length - 1; i >= 0; --i) node[i] = Op.funcNode(node[(i<<1)+0],node[(i<<1)+1]);\n\t\trange.resize(2 * length);\n\t\tfor (int i = 0; i < length; ++i) range[i+length] = make_pair(i,i+1);\n\t\tfor (int i = length - 1; i >= 0; --i) range[i] = make_pair(range[(i<<1)+0].first,range[(i<<1)+1].second);\n\t}\n\n\t// //同じinitで初期化\n\tLazySegmentTree(const size_t num, const typeNode init) {\n\t\tfor (length = 1,height = 0; length < num; length *= 2, height++);\n\t\tnode.resize(2 * length, Op.unitNode);\n\t\tlazy.resize(2 * length, Op.unitLazy);\n\t\tfor (int i = 0; i < num; ++i) node[i + length] = init;\n\t\tfor (int i = length - 1; i >= 0; --i) node[i] = Op.funcNode(node[(i<<1)+0],node[(i<<1)+1]);\n\t\trange.resize(2 * length);\n\t\tfor (int i = 0; i < length; ++i) range[i+length] = make_pair(i,i+1);\n\t\tfor (int i = length - 1; i >= 0; --i) range[i] = make_pair(range[(i<<1)+0].first,range[(i<<1)+1].second);\n\t}\n\n\t//vectorで初期化\n\tLazySegmentTree(const vector<typeNode>& vec) {\n\t\tfor (length = 1,height = 0; length < vec.size(); length *= 2, height++);\n\t\tnode.resize(2 * length, Op.unitNode);\n\t\tlazy.resize(2 * length, Op.unitLazy);\n\t\tfor (int i = 0; i < vec.size(); ++i) node[i + length] = vec[i];\n\t\tfor (int i = length - 1; i >= 0; --i) node[i] = Op.funcNode(node[(i<<1)+0],node[(i<<1)+1]);\n\t\trange.resize(2 * length);\n\t\tfor (int i = 0; i < length; ++i) range[i+length] = make_pair(i,i+1);\n\t\tfor (int i = length - 1; i >= 0; --i) range[i] = make_pair(range[(i<<1)+0].first,range[(i<<1)+1].second);\n\t}\n\n\n\tvoid propagate(int k) {\n\t\tif(lazy[k] == Op.unitLazy) return;\n\t\tnode[k] = Op.funcMerge(node[k],lazy[k],range[k].second-range[k].first);\n\t\tif(k < length) lazy[2*k+0] = Op.funcLazy(lazy[2*k+0],lazy[k]);\n\t\tif(k < length) lazy[2*k+1] = Op.funcLazy(lazy[2*k+1],lazy[k]);\n\t\tlazy[k] = Op.unitLazy;\n    }\n\n\n\t//idx : 0-indexed\n    void update(int a, int b, typeLazy x) {\n\t\tint l = a + length, r = b + length - 1;\n\t\tfor (int i = height; 0 < i; --i) propagate(l >> i), propagate(r >> i);\n\t\tfor(r++; l < r; l >>=1, r >>=1) {\n\t\t\tif(l&1) lazy[l] = Op.funcLazy(lazy[l],x), propagate(l),l++;\n\t\t\tif(r&1) --r,lazy[r] = Op.funcLazy(lazy[r],x), propagate(r);\n\t\t}\n\t\tl = a + length, r = b + length - 1;\n\t\twhile ((l>>=1),(r>>=1),l) {\n\t\t\tif(lazy[l] == Op.unitLazy) node[l] = Op.funcNode(Op.funcMerge(node[(l<<1)+0],lazy[(l<<1)+0],range[(l<<1)+0].second-range[(l<<1)+0].first),Op.funcMerge(node[(l<<1)+1],lazy[(l<<1)+1],range[(l<<1)+1].second-range[(l<<1)+1].first));\n\t\t\tif(lazy[r] == Op.unitLazy) node[r] = Op.funcNode(Op.funcMerge(node[(r<<1)+0],lazy[(r<<1)+0],range[(l<<1)+0].second-range[(l<<1)+0].first),Op.funcMerge(node[(r<<1)+1],lazy[(r<<1)+1],range[(l<<1)+1].second-range[(l<<1)+1].first));\n\t\t}\n    }\n\n\t//[l,r)\n\ttypeNode get(int a, int b) {\n\t\tint l = a + length, r = b + length - 1;\n\t\tfor (int i = height; 0 < i; --i) propagate(l >> i), propagate(r >> i);\n\t\ttypeNode vl = Op.unitNode, vr = Op.unitNode;\n\t\tfor(r++; l < r; l >>=1, r >>=1) {\n\t\t\tif(l&1) vl = Op.funcNode(vl,Op.funcMerge(node[l],lazy[l],range[l].second-range[l].first)),l++;\n\t\t\tif(r&1) r--,vr = Op.funcNode(Op.funcMerge(node[r],lazy[r],range[r].second-range[r].first),vr);\n\t\t}\n\t\treturn Op.funcNode(vl,vr);\n\t}\n\n\tvoid print(){\n\t\t// cout << \"node\" << endl;\n\t\t// for(int i = 1,j = 1; i < 2*length; ++i) {\n\t\t// \tcout << node[i] << \" \";\n\t\t// \tif(i==((1<<j)-1) && ++j) cout << endl;\n\t\t// }\n\t\t// cout << \"lazy\" << endl;\n\t\t// for(int i = 1,j = 1; i < 2*length; ++i) {\n\t\t// \tcout << lazy[i] << \" \";\n\t\t// \tif(i==((1<<j)-1) && ++j) cout << endl;\n\t\t// }\n\t\t// cout << \"width\" << endl;\n\t\t// for(int i = 1,j = 1; i < 2*length; ++i) {\n\t\t// \tcout << width[i] << \" \";\n\t\t// \tif(i==((1<<j)-1) && ++j) cout << endl;\n\t\t// }\n\t\tcout << \"vector\" << endl;\n\t\tcout << \"{ \" << get(0,1);\n\t\tfor(int i = 1; i < length; ++i) cout << \", \" << get(i,i+1);\n\t\tcout << \" }\" << endl;\n\t}\n\n};\n\n//node:総和　lazy:更新\ntemplate<class typeNode, class typeLazy> struct nodeSumLazyUpdate {\n\ttypeNode unitNode = 0;\n\ttypeLazy unitLazy = -2000;\n\ttypeNode funcNode(typeNode l,typeNode r){return l+r;}\n\ttypeLazy funcLazy(typeLazy l,typeLazy r){return r;}\n\ttypeNode funcMerge(typeNode l,typeLazy r,int len){return r!=-2000?r*len:l;}\n\t// LazySegmentTree<ll,ll,nodeSumLazyUpdate<ll,ll>> Seg(N,0,-2000,0);\n    //verify https://onlinejudge.u-aizu.ac.jp/problems/DSL_2_I\n};\n\nint main() {\n\tint N,Q; cin >> N >> Q;\n\tLazySegmentTree<nodeSumLazyUpdate<ll,ll>> Seg(N,0);\n\twhile(Q--) {\n\t\tint q,s,t,x;\n\t\tcin >> q >> s >> t;\n\t\tt++;\n\t\tif(q){\n\t\t\tcout << Seg.get(s,t) << endl;\n\t\t}\n\t\telse {\n\t\t\tcin >> x;\n\t\t\tSeg.update(s,t,x);\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#include <iostream>\n#include <iomanip>\n#include <istream>\n#include <ostream>\n#include <sstream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <bitset>\n#include <utility>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <cctype>\n#include <cstdlib>\n#define IINF 100000000\n//#define INF 300000000000000000\n#define MOD 1000000007\n#define mod 1000000007\n#define INT_MAX_ 2147483647\n#define REP(i, a, n) for (ll i = a; i < (ll)(n); i++)\n#define REPE(i, a, n) for (ll i = a; i <= (ll)(n); i++)\n#define rep(i,n)for (ll i = 0; i < (ll)(n); i++)\n#define Endl endl\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define eb emplace_back\n#define mmax(x,y)(x>y?x:y)\n#define mmin(x,y)(x<y?x:y)\n#define chmax(x,y) x=mmax(x,y)\n#define chmin(x,y) x=mmin(x,y)\n#define all(x) (x).begin(),(x).end()\n#define siz(x) (ll)(x).size()\n#define PI acos(-1.0)\n#define me memset\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\ntypedef long double ld;\ntypedef pair<int,int>Pin;\ntypedef pair<ll,ll>Pll;\ntemplate<class T> using V=vector<T>;\nlong long GCD(long long a, long long b) {return b?GCD(b,a%b):a;}\nlong long LCM(long long a, long long b) {return a/GCD(a,b)*b;}\nint dx[5]={-1,0,1,0,0};\nint dy[5]={0,-1,0,1,0};\nint ddx[8]={-1,0,1,0,1,1,-1,-1};\nint ddy[8]={0,-1,0,1,1,-1,1,-1};\nll cmp1(pair<ll,ll>a,pair<ll,ll> b){\n        if(a.se!=b.se)\n        return a.se<b.se;\n        else\n        return a.fi<b.fi;\n}\n//----------------------------------------------------------------------\n/// RSQ and RUQ\nint num = 1;\nvector<Pll> A;  // first: 値, second: 遅延評価値\nvector<bool> lazyFlag;  // 遅延ありかどうか\nconst long long INF = 1LL << 60;\n\n// ノード番号 k を遅延評価する (A.at(k).first を正しい値に)\nvoid eval(int k, int l, int r) {\n  if (lazyFlag.at(k)) {\n    A.at(k).first = A.at(k).second;\n    if (r - l > 1) {\n      A.at(2*k+1).second = A.at(2*k+2).second = A.at(k).second / 2;\n      lazyFlag.at(2*k+1) = lazyFlag.at(2*k+2) = lazyFlag.at(k);\n    }\n    lazyFlag.at(k) = false;\n  }\n}\n\n// [a, b) の要素を x に更新\n// ノード番号 k は [l, r) に対応している\nvoid update(int a, int b, int x, int k, int l, int r) {\n  eval(k, l, r);\n  // [a, b) と [l, r) が交差していない\n  if (r <= a || b <= l) return;\n  // [a, b) が [l, r) を完全に含む\n  if (a <= l && r <= b) {\n    A.at(k).second = x * (r - l);\n    lazyFlag.at(k) = true;\n    eval(k, l, r);\n  }\n  else {\n    update(a, b, x, 2*k+1, l, (l+r)/2);\n    update(a, b, x, 2*k+2, (l+r)/2, r);\n    A.at(k).first = A.at(2*k+1).first + A.at(2*k+2).first;\n  }\n}\n\n// [a, b) の合計値を返す\nlong long getSum(int a, int b, int k, int l, int r) {\n  eval(k, l, r);\n  if (r <= a || b <= l) return 0;\n  if (a <= l && r <= b) return A.at(k).first;\n  else {\n    long long c1 = getSum(a, b, 2*k+1, l, (l+r)/2);\n    long long c2 = getSum(a, b, 2*k+2, (l+r)/2, r);\n    return c1 + c2;\n  }\n}\n//----------------------------------------------------------------------\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    //-------------------------------  \n    //ll begin_time=clock();\n    //-------------------------------\n    ll n,q;cin>>n>>q;\n    num = 1;\n    while (num < n) num *= 2;  // 要素数は 2 のべき乗にする\n    // 要素数 n のときに必要なノード数は 2*n - 1\n    A = vector<Pll>(2*num - 1, make_pair(0, 0));\n    lazyFlag = vector<bool>(2*num - 1, false);\n    for(ll i=0;i<q;i++){\n        ll co;cin>>co;\n        if(co==1){\n            ll x,y;cin>>x>>y;\n            cout<<getSum(x,y+1,0,0,num)<<endl;\n        }  \n        else{\n            ll x,y,z;cin>>x>>y>>z;\n            update(x,y+1,z,0,0,num);\n        }\n    }\n    //-------------------------------  \n    //ll end_time=clock();cout<<\"time=\"<<end_time-begin_time<<\"ms\"<<endl;\n    //-------------------------------\n    return 0;\n}\n//----------------------------------------------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <string>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cassert>\n#include <cstdint>\n#include <numeric>\n#include <bitset>\n#include <functional>\n\nusing namespace std;\n\nusing ll =  long long;\nusing Pll = pair<ll, ll>;\nusing Pii = pair<int, int>;\n\nconstexpr ll MOD = 1000000007;\nconstexpr long double EPS = 1e-10;\nconstexpr int dyx[4][2] = {\n    { 0, 1}, {-1, 0}, {0,-1}, {1, 0}\n};\n\ntemplate<class T> class LazySegmentTree {\n    public:\n    size_t n;       // 葉の数\n    vector<T> data; // データ\n    vector<T> lazy; // 遅延評価用\n    T unit;         // 単位元\n    T def;          // 初期値\n    T lazy_def;     // 遅延評価用初期値\n    function<T(T, size_t, size_t, T)> update_func;      // 更新で使う処理\n    function<T(T, T)> find_func;        // クエリで使う処理\n    function<T(T, T)> lazy_prop_func;   // 遅延評価用の値を子ノードに伝播させる処理\n\n    LazySegmentTree(\n        size_t _n, T _unit, T _def, T _lazy_def,  \n        function<T(T, size_t, size_t, T)> _update_func, \n        function<T(T, T)> _find_func, \n        function<T(T, T)> _lazy_prop_func\n        ) : unit(_unit), def(_def), lazy_def(_lazy_def), update_func(_update_func), find_func(_find_func), lazy_prop_func(_lazy_prop_func) {\n        // 2のべき乗にする\n        n = 1;\n        while(n < _n) n <<= 1;\n        data = vector<T>(2*n-1, _def);\n        lazy = vector<T>(2*n-1, _lazy_def);\n    }\n\n    void eval(size_t k, size_t kl, size_t kr) {\n        if(lazy[k] == lazy_def) return;\n        data[k] = update_func(data[k], kl, kr, lazy[k]);\n        if(kr - kl > 1){\n            lazy[2*k+1] = lazy_prop_func(lazy[2*k+1], lazy[k]);\n            lazy[2*k+2] = lazy_prop_func(lazy[2*k+1], lazy[k]);\n        }\n        lazy[k] = lazy_def;\n    }\n\n    void _update(size_t s, size_t t, size_t k, size_t kl, size_t kr, T x){\n        eval(k, kl, kr);\n\n        if(t <= kl || kr <= s) return;\n        if(s <= kl && kr <= t) {\n            lazy[k] = lazy_prop_func(lazy[k], x);\n            eval(k, kl, kr);\n        } else {\n            size_t kc = (kl+kr)/2;\n            _update(s, t, 2*k+1, kl, kc, x);\n            _update(s, t, 2*k+2, kc, kr, x);\n            data[k] = find_func(data[2*k+1], data[2*k+2]);\n        }\n    }\n\n    void update(size_t s, size_t t, T x) {\n        return _update(s, t, 0, 0, n, x);\n    }\n\n    T _find(size_t s, size_t t, size_t k, size_t kl, size_t kr){\n        if(kr <= s || t <= kl) return unit;\n\n        eval(k, kl, kr);\n        if(s <= kl && kr <= t) return data[k];\n\n        size_t kc = (kl+kr)/2;\n        T vl = _find(s, t, 2*k+1, kl, kc);\n        T vr = _find(s, t, 2*k+2, kc, kr);\n        return find_func(vl, vr);\n    }\n    \n    T find(size_t s, size_t t) {\n        return _find(s, t, 0, 0, n);\n    }\n};\n\nint main() {\n    unsigned int n, q, com, s, t; \n    ll x;\n    cin >> n >> q;\n    LazySegmentTree<ll> tree(\n        n, 0LL, 0LL, 1LL << 60, \n        [](ll a, size_t l, size_t r, ll b) { return (r-l) * b; }, \n        [](ll a, ll b) { return a+b; }, \n        [](ll a, ll b) { return b; }\n    );\n\n    while(q--) {\n        cin >> com;\n        if(com) {\n            cin >> s >> t;\n            cout << tree.find(s, t+1) << endl;\n        } else {\n            cin >> s >> t >> x;\n            tree.update(s, t+1, x);\n        }\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass segment_tree{\n    vector<int64_t> val;\n    vector<pair<int64_t, int64_t>> op;\n    vector<pair<size_t, size_t>> range;\n\n    size_t N, depth;\n\n    inline void merge(size_t target, int64_t alpha, int64_t beta){\n        op[target] = {op[target].first * alpha, op[target].second * alpha + beta};\n    }\n    inline void propagate(size_t target){\n        // min, max -> width = 1\n        val[target] = op[target].first * val[target] + op[target].second * (range[target].second - range[target].first);\n        if(target  < N){\n            merge(2*target, op[target].first, op[target].second);\n            merge(2*target+1, op[target].first, op[target].second);\n        }\n        op[target] = {1, 0};\n    }\n    \n    inline void eval(int n){\n        stack<size_t> stk;\n        for(;n>0;n>>=1) stk.push(n);\n        while(!stk.empty()){\n            propagate(stk.top());\n            stk.pop();\n        }\n    }\n    inline void get_target(vector<size_t> &target, size_t left, size_t right, stack<size_t> *refresh=nullptr){\n        queue<size_t> partial;\n        \n        if(left <= 0 && right >= N) target.push_back(1);\n        else partial.push(1);\n\n        while(!partial.empty()){\n            size_t i = partial.front();\n            if(refresh != nullptr) refresh->push(i);\n            partial.pop();\n\n            propagate(i);\n\n            if(left <= range[i].first){\n                if(right < range[i*2].second) partial.push(i*2);\n                else{\n                    target.push_back(i*2);\n                    if(range[i*2+1].first < right) partial.push(i*2+1);\n                }\n            }else{\n                if(left < range[i*2].second){\n                    partial.push(i*2);\n                    if(range[i*2+1].second <= right) target.push_back(i*2+1);\n                    else if(range[i*2].second < right) partial.push(i*2+1); \n                }else{\n                    if(left <= range[i*2+1].first && range[i*2+1].second <= right) target.push_back(i*2+1);\n                    else partial.push(i*2+1);\n                }\n            }\n        }\n    }\npublic:\n    segment_tree(size_t n){\n        for(depth=0;(1ULL<<depth)<n;depth++);\n        N = 1ULL<<depth;\n        val.reserve(1ULL<<(++depth));\n        op.reserve(1ULL<<depth);\n        range.reserve(1ULL<<depth);\n        for(size_t i=2*N-1;i>0;i--){\n            if(i>=N) range[i] = {i-N, i-N+1};\n            else range[i] = {range[2*i].first, range[2*i+1].second};\n        }\n    }\n    int64_t operator[](size_t i){\n        eval(N+i);\n        return val[N+i];\n    }\n    void operate(int64_t alpha, int64_t beta, size_t left, size_t right){\n        if(right <= left) return;\n\n        vector<size_t> target;\n        stack<size_t> refresh;\n        get_target(target, left, right, &refresh);\n        for(auto i : target){\n            merge(i, alpha, beta);\n            propagate(i);\n        }\n        while(!refresh.empty()){\n            size_t i = refresh.top();\n            refresh.pop();\n            //min, max -> change\n            propagate(i*2);\n            propagate(i*2+1);\n            val[i] = val[i*2] + val[i*2+1];\n        }\n    }\n    int64_t get_sum(size_t left, size_t right){\n        if(right <= left) return 0;\n        \n        vector<size_t> target;\n        get_target(target, left, right);\n        int64_t ret = 0;\n        for(auto i : target){\n            ret += op[i].first * val[i] + op[i].second * (range[i].second - range[i].first);\n        }\n        return ret;\n    }\n    void update(int64_t val, size_t pos){\n        operate(0, val, pos, pos+1);\n    }\n    void update(int64_t val, size_t left, size_t right){\n        operate(0, val, left, right);\n    }\n    void add(int64_t val, size_t pos){\n        operate(1, val, pos, pos+1);\n    }\n    void add(int64_t val, size_t left, size_t right){\n        operate(1, val, left, right);\n    }\n\n    void dump(){\n        for(int i=1;i<2*N;i++){\n            eval(i);\n            cerr << val[i] << \" \";\n        }\n        cerr << endl;\n    }\n};\n\nint main(){\n    int n, q;\n    cin >> n >> q;\n    segment_tree st(n);\n\n    for(int i=0;i<q;i++){\n        int com;\n        cin >> com;\n        if(com == 0){\n            int s, t, x;\n            cin >> s >> t >> x;\n            st.update(x, s, t+1);\n        }else{\n            int s, t;\n            cin >> s >> t;\n            cout << st.get_sum(s, t+1) << endl;\n        }\n        //st.dump();\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n// Created by Hideaki Imamura on 2020-03-08.\n//\n# include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair <ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n# define EPS (1e-7)\n# define INF (INT_MAX)\n# define PI (acos(-1))\n//const ll mod = 1000000007;\n\ntemplate<class T>\nvoid print_vec(vector <T> v) {\n    for (auto x : v) {\n        cout << x << \" \";\n    }\n    cout << endl;\n}\n\n#ifndef ALGORITHMS_DATASTRUCTURE_LAZYSEGMENTTREE_H\n#define ALGORITHMS_DATASTRUCTURE_LAZYSEGMENTTREE_H\n\n// T0: 元の配列のモノイド\n// T1: T0に対する作用素モノイド\ntemplate <class T0, class T1, class F0, class F1, class G, class P> class LazySegmentTree {\n    // k番目のノードにのlazyを伝搬\n    void eval(int k, int len) {\n        // 定数倍高速化\n        if (lazy[k] == u1) return;\n        // len個分のlazy[k]を評価\n        node[k] = g(node[k], p(lazy[k], len));\n        if (k < N - 1) {\n            // 最下段でなければ下のlazyに伝搬\n            lazy[2 * k + 1] = f1(lazy[2 * k + 1], lazy[k]);\n            lazy[2 * k + 2] = f1(lazy[2 * k + 2], lazy[k]);\n        }\n        lazy[k] = u1;\n    }\n    // k番目のノード[l, r)について、[a, b)の範囲内にxを作用\n    void update(int a, int b, T1 x, int k, int l, int r) {\n        eval(k, r - l);\n        if (b <= l || r <= a) return;\n        if (a <= l && r <= b) {\n            lazy[k] = f1(lazy[k], x);\n            eval(k, r - l);\n        } else {\n            update(a, b, x, 2 * k + 1, l, (l + r) / 2);\n            update(a, b, x, 2 * k + 2, (l + r) / 2, r);\n            node[k] = f0(node[2 * k + 1], node[2 * k + 2]);\n        }\n    }\n    // k番目のノード[l, r)について、[a, b)のクエリを求める\n    T0 query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) return u0;\n        eval(k, r - l);\n        if (a <= l && r <= b) return node[k];\n        T0 vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n        T0 vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n        return f0(vl, vr);\n    }\n\npublic:\n    int sz;  // 元の配列のサイズ\n    int N;\n    vector<T0> node;\n    vector<T1> lazy;\n    // T0上の演算、単位元\n    const F0 f0;\n    const T0 u0;\n    // T1上の演算、単位元\n    const F1 f1;\n    const T1 u1;\n    // T0に対するT1の作用\n    const G g;\n    // 多数のt1(T1)に対するf1の合成\n    const P p;\n\n    LazySegmentTree(F0 f0, T0 u0, F1 f1, T1 u1, G g, P p) : f0(f0), u0(u0), f1(f1), u1(u1), g(g), p(p) {}\n    void set_by_vector(const vector<T0>& a) {\n        sz = a.size();\n        for (N = 1; N < sz; N *= 2)\n            ;\n        node.resize(2 * N - 1, u0);\n        lazy.resize(2 * N - 1, u1);\n        for (int i = 0; i < sz; i++) node[N - 1 + i] = a[i];\n        for (int i = N - 2; i >= 0; i--) node[i] = f0(node[2 * i + 1], node[2 * i + 2]);\n    }\n    void set_by_unit(int n) {\n        sz = n;\n        for (N = 1; N < sz; N *= 2)\n            ;\n        node.resize(2 * N - 1, u0);\n        lazy.resize(2 * N - 1, u1);\n    }\n    // [a, b)にxを作用\n    void update(int a, int b, T1 x) {\n        assert(0 <= a && a < b && b <= sz);\n        update(a, b, x, 0, 0, N);\n    }\n    void update(int a, T1 x) { update(a, a + 1, x); }\n    // [a, b)\n    T0 query(int a, int b) { return query(a, b, 0, 0, N); }\n    T0 query(int a) { return query(a, a + 1); }\n    friend string to_string(LazySegmentTree<T0, T1, F0, F1, G, P>& seg) {\n        for (int i = 0; i < seg.sz; i++) seg.query(i);\n        return to_string(vector<T0>(seg.node.begin() + (seg.N - 1), seg.node.begin() + (seg.N - 1 + seg.sz)));\n    }\n};\ntemplate <class T0, class T1, class F0, class F1, class G, class P>\nauto make_lazy_segment_tree(F0 f0, T0 u0, F1 f1, T1 u1, G g, P p) {\n    return LazySegmentTree<T0, T1, F0, F1, G, P>(f0, u0, f1, u1, g, p);\n}\n// Max && Add\n// constexpr Int INF = 1e18;\n// auto seg = make_lazy_segment_tree<Int, Int>(\n//     [](Int x, Int y) { return max(x, y); }, -INF, [](Int x, Int y) { return x + y; }, 0,\n//     [](Int x, Int y) { return x == -INF ? x : x + y; }, [](Int x, int len) { return x; });\n\n#endif //ALGORITHMS_DATASTRUCTURE_LAZYSEGMENTTREE_H\n\n// DSL_2_A\n//\n//int N, Q;\n//\n//int main() {\n//    cin >> N >> Q;\n//    const ll u0 = INF;\n//    const ll u1 = -INF;\n//    auto seg = make_lazy_segment_tree<ll, ll> (\n//            [](ll x, ll y) { return min(x, y); }, u0,\n//            [](ll x, ll y) { return y == u1 ? x : y; }, u1,\n//            [](ll x, ll y) { return y == u1 ? x : y; },\n//            [](ll x, int len) { return x; });\n//    seg.set_by_unit(N);\n//    for (int q= 0; q < Q; ++q) {\n//        ll com, x, y;\n//        cin >> com >> x >> y;\n//        if (com == 0) {\n//            seg.update(x, y);\n//        } else {\n//            cout << seg.query(x, y + 1) << endl;\n//        }\n//    }\n//    return 0;\n//}\n\n// DSL_2_B\n//\n//int N, Q;\n//\n//int main() {\n//    cin >> N >> Q;\n//    const ll u0 = 0;\n//    const ll u1 = 0;\n//    auto seg = make_lazy_segment_tree<ll, ll> (\n//            [](ll x, ll y) { return x + y; }, u0,\n//            [](ll x, ll y) { return x + y; }, u1,\n//            [](ll x, ll y) { return x + y; },\n//            [](ll x, int len) { return x * len; });\n//    seg.set_by_unit(N);\n//    for (int q= 0; q < Q; ++q) {\n//        ll com, x, y;\n//        cin >> com >> x >> y;\n//        if (com == 0) {\n//            x--;\n//            seg.update(x, y);\n//        } else {\n//            x--;\n//            y--;\n//            cout << seg.query(x, y + 1) << endl;\n//        }\n//    }\n//    return 0;\n//}\n\n// DSL_2_D\n//\n//int N, Q;\n//\n//int main() {\n//    cin >> N >> Q;\n//    const ll u0 = INF;\n//    const ll u1 = -INF;\n//    auto seg = make_lazy_segment_tree<ll, ll> (\n//            [](ll x, ll y) { return y == u0 ? x : y; }, u0,\n//            [](ll x, ll y) { return y == u1 ? x : y; }, u1,\n//            [](ll x, ll y) { return y == u1 ? x : y; },\n//            [](ll x, int len) { return x; });\n//    seg.set_by_unit(N);\n//    for (int q= 0; q < Q; ++q) {\n//        ll query;\n//        cin >> query;\n//        if (query == 0) {\n//            ll s, t, x;\n//            cin >> s >> t >> x;\n//            seg.update(s, t + 1, x);\n//        } else {\n//            ll i;\n//            cin >> i;\n//            cout << seg.query(i, i + 1) << endl;\n//        }\n//    }\n//    return 0;\n//}\n\n// DSL_2_E\n//\n//int N, Q;\n//\n//int main() {\n//    cin >> N >> Q;\n//    const ll u0 = 0;\n//    const ll u1 = 0;\n//    auto seg = make_lazy_segment_tree<ll, ll> (\n//            [](ll x, ll y) { return x + y; }, u0,\n//            [](ll x, ll y) { return x + y; }, u1,\n//            [](ll x, ll y) { return x + y; },\n//            [](ll x, int len) { return x * len; });\n//    seg.set_by_unit(N);\n//    for (int q= 0; q < Q; ++q) {\n//        ll query;\n//        cin >> query;\n//        if (query == 0) {\n//            ll s, t, x;\n//            cin >> s >> t >> x;\n//            s--;\n//            t--;\n//            seg.update(s, t + 1, x);\n//        } else {\n//            ll i;\n//            cin >> i;\n//            i--;\n//            cout << seg.query(i, i + 1) << endl;\n//        }\n//    }\n//    return 0;\n//}\n\n// DSL_2_F\n//\n//int N, Q;\n//\n//int main() {\n//    cin >> N >> Q;\n//    static constexpr ll u0 = INF;\n//    static constexpr ll u1 = - INF;\n//    auto seg = make_lazy_segment_tree<ll, ll> (\n//            [](ll x, ll y) { return min(x, y); }, u0,\n//            [](ll x, ll y) { return y == u1 ? x : y; }, u1,\n//            [](ll x, ll y) { return y == u1 ? x : y; },\n//            [](ll x, int len) { return x; });\n//    seg.set_by_vector(vector<ll>(N, INF));\n//    for (int i = 0; i < Q; ++i) {\n//        int q;\n//        cin >> q;\n//        if (q == 0) {\n//            ll s, t, x;\n//            cin >> s >> t >> x;\n//            seg.update(s, t + 1, x);\n//        } else {\n//            int s, t;\n//            cin >> s >> t;\n//            cout << seg.query(s, t + 1) << endl;\n//        }\n//    }\n//    return 0;\n//}\n\n// DSL_2_G\n//\n//int N, Q;\n//\n//signed main() {\n//    cin >> N >> Q;\n//    auto seg = make_lazy_segment_tree<ll, ll>(\n//            [](ll x, ll y) { return x + y; }, 0,\n//            [](ll x, ll y) { return x + y; }, 0,\n//            [](ll x, ll y) { return x + y; },\n//            [](ll x, int len) { return x * len; });\n//    seg.set_by_unit(N);\n//    for (ll i = 0; i < Q; ++i) {\n//        int q;\n//        cin >> q;\n//        if (q == 0) {\n//            int s, t, x;\n//            cin >> s >> t >> x;\n//            seg.update(s - 1, t, x);\n//        } else {\n//            int s, t;\n//            cin >> s >> t;\n//            cout << seg.query(s - 1, t) << endl;\n//        }\n//    }\n//    return 0;\n//}\n\n// DSL_2_H\n//\n//int N, Q;\n//\n//int main() {\n//    cin >> N >> Q;\n//    const ll u0 = INF;\n//    const ll u1 = 0;\n//    auto seg = make_lazy_segment_tree<ll, ll> (\n//            [](ll x, ll y) { return min(x, y); }, u0,\n//            [](ll x, ll y) { return x + y; }, u1,\n//            [](ll x, ll y) { return x + y; },\n//            [](ll x, int len) { return x; });\n//    seg.set_by_vector(vector<ll>(N, 0));\n//    for (int q= 0; q < Q; ++q) {\n//        ll query;\n//        cin >> query;\n//        if (query == 0) {\n//            ll s, t, x;\n//            cin >> s >> t >> x;\n//            seg.update(s, t + 1, x);\n//        } else {\n//            ll s, t;\n//            cin >> s >> t;\n//            cout << seg.query(s, t + 1) << endl;\n//        }\n//    }\n//    return 0;\n//}\n\n// DSL_2_I\n//\nint N, Q;\n\nint main() {\n    cin >> N >> Q;\n    const ll u0 = 0;\n    const ll u1 = - INF;\n    auto seg = make_lazy_segment_tree<ll, ll> (\n            [](ll x, ll y) { return x + y; }, u0,\n            [](ll x, ll y) { return y == u1 ? x : y; }, u1,\n            [](ll x, ll y) { return y == u1 ? x: y; },\n            [](ll x, int len) { return x == u1 ? u1 : x * len; });\n    seg.set_by_vector(vector<ll>(N, 0));\n    for (int q= 0; q < Q; ++q) {\n        ll query;\n        cin >> query;\n        if (query == 0) {\n            ll s, t, x;\n            cin >> s >> t >> x;\n            seg.update(s, t + 1, x);\n        } else {\n            ll s, t;\n            cin >> s >> t;\n            cout << seg.query(s, t + 1) << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n\nusing T = int;\nT op(T l, T r) { return l + r; }\nT id() { return 0; }\n\nclass assign_segment_tree {\nprivate:\n  class node {\n  public:\n    T sum;\n    T* lazy;\n    node() : sum(id()), lazy(nullptr) {}\n    T get() {\n      if (lazy) {\n        return *lazy;\n      }\n      else {\n        return sum;\n      }\n    }\n  };\n\n  int height;\n  std::vector<node> tree;\n  std::vector<T> table;\n\n  void push(int index) {\n    if (tree[index].lazy) {\n      tree[index * 2].lazy = tree[index].lazy - 1;\n      tree[index * 2 + 1].lazy = tree[index].lazy - 1;\n      tree[index].sum = *tree[index].lazy;\n      tree[index].lazy = nullptr;\n    }\n  }\n\n  T fold(int index, int n_left, int n_right, int q_left, int q_right) {\n    if (q_left <= n_left && n_right <= q_right) {\n      return tree[index].get();\n    }\n    if (n_right <= q_left || q_right <= n_left) {\n      return id();\n    }\n    push(index);\n    int n_mid = (n_left + n_right) / 2;\n    return op(fold(index * 2, n_left, n_mid, q_left, q_right),\n      fold(index * 2 + 1, n_mid, n_right, q_left, q_right));\n  }\n\n  void assign(int index, int n_left, int n_right, int q_left, int q_right,\n    T* lazy) {\n    if (q_left <= n_left && n_right <= q_right) {\n      tree[index].lazy = lazy;\n      return;\n    }\n    if (n_right <= q_left || q_right <= n_left) {\n      return;\n    }\n    push(index);\n    int n_mid = (n_left + n_right) / 2;\n    assign(index * 2, n_left, n_mid, q_left, q_right, lazy - 1);\n    assign(index * 2 + 1, n_mid, n_right, q_left, q_right, lazy - 1);\n    tree[index].sum = op(tree[index * 2].get(), tree[index * 2 + 1].get());\n  }\n\npublic:\n  assign_segment_tree(int n) {\n    height = 1;\n    int s = 1;\n    while (s < n) {\n      s *= 2;\n      ++height;\n    }\n    tree.assign(s * 2, node());\n    table.reserve(s * 2);\n  }\n\n  int size() { return tree.size() / 2; }\n\n  T fold(int first, int last) { return fold(1, 0, size(), first, last); }\n\n  void assign(int first, int last, T value) {\n    for (int i = 0; i < height; ++i) {\n      table.push_back(value);\n      value = op(value, value);\n    }\n    assign(1, 0, size(), first, last, &table.back());\n    if (table.capacity() - table.size() < height) {\n      for (int i = 1; i < size(); ++i) {\n        push(i);\n      }\n      for (int i = size(); i != tree.size(); ++i) {\n        if (tree[i].lazy) {\n          tree[i].sum = *tree[i].lazy;\n          tree[i].lazy = nullptr;\n        }\n      }\n      table.clear();\n    }\n  }\n};\n\n/*\n\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_D&lang=ja\n\n#include <algorithm>\nusing T = int;\nT op(T l, T r) { return std::min(l, r); }\nT id() { return 2147483647; }\n\n*/\n/*\n\n#include <iostream>\n\nint main() {\n  int n, q;\n  std::cin >> n >> q;\n  assign_segment_tree seg(n);\n  for (int j = 0; j < q; ++j) {\n    int c;\n    std::cin >> c;\n    if (c == 0) {\n      int s, t, x;\n      std::cin >> s >> t >> x;\n      seg.assign(s, t + 1, x);\n    } else {\n      int i;\n      std::cin >> i;\n      std::cout << seg.fold(i, i + 1) << std::endl;\n    }\n  }\n}\n\n//*/\n\n/*\n\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_F&lang=ja\n\n#include <algorithm>\nusing T = int;\nT op(T l, T r) { return std::min(l, r); }\nT id() { return 2147483647; }\n\n*/\n/*\n\n#include <iostream>\n\nint main() {\n  int n, q;\n  std::cin >> n >> q;\n  assign_segment_tree seg(n);\n  for (int i = 0; i < q; ++i) {\n    int c;\n    std::cin >> c;\n    if (c == 0) {\n      int s, t, x;\n      std::cin >> s >> t >> x;\n      seg.assign(s, t + 1, x);\n    } else {\n      int s, t;\n      std::cin >> s >> t;\n      std::cout << seg.fold(s, t + 1) << std::endl;\n    }\n  }\n}\n\n//*/\n\n/*\n\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DSL_2_I&lang=ja\n\nusing T = int;\nT op(T l, T r) { return l + r; }\nT id() { return 0; }\n\n*/\n//*\n\n#include <iostream>\n\nint main() {\n  int n, q;\n  std::cin >> n >> q;\n  assign_segment_tree seg(n);\n  for (int i = 0; i < q; ++i) {\n    int c;\n    std::cin >> c;\n    if (c == 0) {\n      int s, t, x;\n      std::cin >> s >> t >> x;\n      seg.assign(s, t + 1, x);\n    } else {\n      int s, t;\n      std::cin >> s >> t;\n      std::cout << seg.fold(s, t + 1) << std::endl;\n    }\n  }\n}\n\n//*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass segment_tree{\n    vector<int64_t> val;\n    vector<pair<int64_t, int64_t>> op;\n    vector<pair<size_t, size_t>> range;\n\n    pair<int64_t, int64_t> ident = {1, 0};\n    size_t N, depth;\n\n    inline void merge(size_t target, int64_t alpha, int64_t beta){\n        op[target] = {op[target].first * alpha, op[target].second * alpha + beta};\n    }\n    inline void propagate(size_t target){\n        // min, max -> width = 1\n        if(op[target] == ident) return;\n        val[target] = op[target].first * val[target] + op[target].second * (range[target].second - range[target].first);\n        if(target  < N){\n            merge(2*target, op[target].first, op[target].second);\n            merge(2*target+1, op[target].first, op[target].second);\n        }\n        op[target] = {1, 0};\n    }\n    \n    inline void eval(int n){\n        stack<size_t> stk;\n        for(;n>0;n>>=1) stk.push(n);\n        while(!stk.empty()){\n            propagate(stk.top());\n            stk.pop();\n        }\n    }\n    inline void get_target(vector<size_t> &target, size_t left, size_t right, stack<size_t> *refresh=nullptr){\n        queue<size_t> partial;\n        \n        if(left <= 0 && right >= N) target.push_back(1);\n        else partial.push(1);\n\n        while(!partial.empty()){\n            size_t i = partial.front();\n            if(refresh != nullptr) refresh->push(i);\n            partial.pop();\n\n            propagate(i);\n\n            if(left <= range[i].first){\n                if(right < range[i*2].second) partial.push(i*2);\n                else{\n                    target.push_back(i*2);\n                    if(range[i*2+1].first < right) partial.push(i*2+1);\n                }\n            }else{\n                if(left < range[i*2].second){\n                    partial.push(i*2);\n                    if(range[i*2+1].second <= right) target.push_back(i*2+1);\n                    else if(range[i*2].second < right) partial.push(i*2+1); \n                }else{\n                    if(left <= range[i*2+1].first && range[i*2+1].second <= right) target.push_back(i*2+1);\n                    else partial.push(i*2+1);\n                }\n            }\n        }\n    }\npublic:\n    segment_tree(size_t n){\n        for(depth=0;(1ULL<<depth)<n;depth++);\n        N = 1ULL<<depth;\n        val.reserve(1ULL<<(++depth));\n        op.reserve(1ULL<<depth);\n        range.reserve(1ULL<<depth);\n        for(size_t i=2*N-1;i>0;i--){\n            if(i>=N) range[i] = {i-N, i-N+1};\n            else range[i] = {range[2*i].first, range[2*i+1].second};\n        }\n    }\n    int64_t operator[](size_t i){\n        eval(N+i);\n        return val[N+i];\n    }\n    void operate(int64_t alpha, int64_t beta, size_t left, size_t right){\n        if(right <= left) return;\n\n        vector<size_t> target;\n        stack<size_t> refresh;\n        get_target(target, left, right, &refresh);\n        for(auto i : target){\n            merge(i, alpha, beta);\n            propagate(i);\n        }\n        while(!refresh.empty()){\n            size_t i = refresh.top();\n            refresh.pop();\n            //min, max -> change\n            propagate(i*2);\n            propagate(i*2+1);\n            val[i] = val[i*2] + val[i*2+1];\n        }\n    }\n    int64_t get_sum(size_t left, size_t right){\n        if(right <= left) return 0;\n        \n        vector<size_t> target;\n        get_target(target, left, right);\n        int64_t ret = 0;\n        for(auto i : target){\n            ret += op[i].first * val[i] + op[i].second * (range[i].second - range[i].first);\n        }\n        return ret;\n    }\n    void update(int64_t val, size_t pos){\n        operate(0, val, pos, pos+1);\n    }\n    void update(int64_t val, size_t left, size_t right){\n        operate(0, val, left, right);\n    }\n    void add(int64_t val, size_t pos){\n        operate(1, val, pos, pos+1);\n    }\n    void add(int64_t val, size_t left, size_t right){\n        operate(1, val, left, right);\n    }\n\n    void dump(){\n        for(int i=1;i<2*N;i++){\n            eval(i);\n            cerr << val[i] << \" \";\n        }\n        cerr << endl;\n    }\n};\n\nint main(){\n    int n, q;\n    cin >> n >> q;\n    segment_tree st(n);\n\n    for(int i=0;i<q;i++){\n        int com;\n        cin >> com;\n        if(com == 0){\n            int s, t, x;\n            cin >> s >> t >> x;\n            st.update(x, s, t+1);\n        }else{\n            int s, t;\n            cin >> s >> t;\n            cout << st.get_sum(s, t+1) << endl;\n        }\n        //st.dump();\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> P3;\ntypedef pair<P ,P> PP;\nconstexpr ll MOD = ll(1e9) + 7;\nconstexpr int IINF = INT_MAX;\nconstexpr ll LLINF = LLONG_MAX;\nconstexpr int MAX_N = int(1e5) + 5;\nconstexpr double EPS = 1e-8;\nconstexpr int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define SORTR(v) sort((v).rbegin(), (v).rend())\n#define ALL(v) (v).begin(), (v).end()\n\ntemplate <typename Monoid, typename OperatorMonoid>\nstruct LazySegmentTree{\nprivate:\n    using F = function<Monoid(Monoid, Monoid)>;\n    using G = function<Monoid(Monoid, OperatorMonoid)>;\n    using H = function<OperatorMonoid(OperatorMonoid, OperatorMonoid)>;\n    using P = function<OperatorMonoid(OperatorMonoid, int)>;\n    int N;\n    vector<Monoid> node;\n    vector<OperatorMonoid> lazy;\n    F f;\n    G g;\n    H h;\n    P p;\n    Monoid e;  // identity element\n    OperatorMonoid oe;  // identity element\n\npublic:\n    LazySegmentTree(){}\n    LazySegmentTree(F f, G g, H h, Monoid e, OperatorMonoid oe, P p=[](OperatorMonoid a, int b){return a;}):f(f), g(g), h(h), e(e), oe(oe), p(p){}\n    void init(int sz){\n        N = 1;\n        while(N < sz) N <<= 1;\n        node.assign(2*N-1, e);\n        lazy.assign(2*N-1, oe);\n    }\n    void build(vector<Monoid>& v){\n        int sz = int(v.size());\n        init(sz);\n        for(int i=0; i<sz; i++){\n            node[i+N-1] = v[i];\n        }\n        for(int i=N-2; i>=0; i--){\n            node[i] = f(node[i*2+1], node[i*2+2]);\n        }\n    }\n    void eval(int k, int len){\n        if(lazy[k] != oe){\n            node[k] = g(node[k], p(lazy[k], len));\n            if(k < N-1){\n                lazy[2*k+1] = h(lazy[2*k+1], lazy[k]);\n                lazy[2*k+2] = h(lazy[2*k+2], lazy[k]);\n            }\n            lazy[k] = oe;\n        }\n    }\n    Monoid update(int a, int b, OperatorMonoid x){return update(a, b, x, 0, 0, N);}\n    Monoid update(int a, int b, OperatorMonoid x, int k, int l, int r){\n        eval(k, r-l);\n        if(b <= l || r <= a) return node[k];\n        if(a <= l && r <= b){\n            lazy[k] = h(lazy[k], x);\n            return g(node[k], p(lazy[k], r-l));\n        }\n        return node[k] = f(update(a,b,x,2*k+1,l,(l+r)/2), update(a,b,x,k*2+2,(l+r)/2,r));\n    }\n    // [a,b)\n    Monoid query(int a, int b){return query(a, b, 0, 0, N);}\n    Monoid query(int a, int b, int k, int l, int r){\n        eval(k, r-l);\n        if(b <= l || r <= a) return e;\n        if(a <= l && r <= b) return node[k];\n        Monoid vl, vr;\n        vl = query(a, b, 2*k+1, l, (l+r)/2);\n        vr = query(a, b, 2*k+2, (l+r)/2, r);\n        return f(vl, vr);\n    }\n};\n\nint main() {\n    int n, q;\n    ll INF = INT_MAX;\n    cin >> n >> q;\n    auto f = [=](ll a, ll b){return a+b;};\n    auto g = [=](ll a, ll b){return (b!=INF?b:a);};\n    auto p = [=](ll a, int b){return a*b;};\n    LazySegmentTree<ll, ll> seg(f,g,g,0,INF,p);\n    seg.init(n);\n    for(int i=0;i<q;i++){\n        int c, s, t;\n        cin >> c >> s >> t;\n        if(c==0){\n            ll x;\n            cin >> x;\n            seg.update(s, t+1, x);\n        }\n        else{\n            cout << seg.query(s,t+1) << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (long long i=0;i<(n);i++)\n#define dump(x)  cerr << #x << \" => \" << (x) << endl;\n#define dump1d_arr(array) REP(i,array.size()) cerr << #array << \"[\" << (i) << \"] ==> \" << (array[i]) << endl;\nusing namespace std;\n/*\nstruct Monoid {\n    using T = _underlying_set_;\n    static  T op(const T& a, const T& b) { return _a_op_b_; }\n    static constexpr T identity() { return _identity_element_; }\n};\n*/\ntemplate <class Monoid,class MonoidAct,typename N>\nclass LazySegmentTree {\nprivate:\n    using T1 = typename Monoid::T;\n    using T2 = typename MonoidAct::T;\n    vector<T1> data;\n    vector<T2> lazy;\n    vector<N> rank; \n    const size_t h, n;\n\n    //オペレータ2 MonoidAct -> Monoid (値がどう変化するか)\n\n    // RUQ -> RMQ\n    //static T1 op2(const T1& l,const T2& r,const N& num) {return r != MonoidAct::id() ? r : l; }\n    // RAQ -> RMQ\n    //static T1 op2(const T1& l,const T2& r,const N& num) {return l + r; }\n    // RAQ -> RSQ \n    //static T1 op2(const T1& l,const T2& r,const N& num) {return l + (r*num); }\n    // RUQ -> RSQ\n    static T1 op2(const T1& l,const T2& r,const N& num) {return r != MonoidAct::id() ? r*num : l; }\n\n\n\nprivate:\n    void eval(size_t node) {\n        if (lazy[node] == MonoidAct::id()) return;\n        if (node < n) {\n            lazy[node * 2] = MonoidAct::op3(lazy[node * 2], lazy[node]);\n            lazy[node * 2 + 1] = MonoidAct::op3(lazy[node * 2 + 1], lazy[node]);\n        }\n        data[node] = op2(data[node],lazy[node],rank[node]);\n        lazy[node] = MonoidAct::id();\n    }\n    void update(size_t node) {\n        data[node] = Monoid::op1(op2(data[node * 2],lazy[node * 2],rank[node*2])\n                        ,op2(data[node * 2 + 1],lazy[node * 2 + 1],rank[node*2+1]));\n    }\n\npublic:\n    LazySegmentTree(size_t n_)\n        : h(ceil(log2(n_))), n(1 << h) {data.resize(n * 2, Monoid::id());lazy.resize(n * 2, MonoidAct::id());rank.resize(n*2);init();}\n    LazySegmentTree(size_t n_, T1 v1)\n        : h(ceil(log2(n_))), n(1 << h) {data.resize(n * 2, v1);lazy.resize(n * 2, MonoidAct::id());rank.resize(n*2);init();}\n    LazySegmentTree(const vector<T1>& data_)\n        : h(ceil(log2(data_.size()))), n(1 << h) {\n            data.resize(n * 2,Monoid::id());\n            lazy.resize(n * 2, MonoidAct::id());\n            rank.resize(n*2);\n            init(data_);\n    }\n    void init() {\n        for (N i = 0;i < n;i++) rank[i+n] = 1;\n        for (N i = n - 1; i >= 1; i--) {\n            data[i] = Monoid::op1(data[i * 2], data[i * 2 + 1]);\n            rank[i] += (rank[i*2] + rank[i*2+1]);\n        }\n    }\n    void init(const vector<T1>& data_) {\n        for (N i = 0; i < (N)data_.size(); i++) {\n            data[i + n] = data_[i];\n        }\n        init();\n    }\n\n    T1 operator[](size_t i) { return find(i,i+1);}\n\n    void update(size_t l, size_t r, T2 val) {\n        l += n, r += n - 1;\n        for (N i = h; i > 0; i--) eval(l >> i), eval(r >> i);\n        size_t tl = l, tr = r;\n        r++;\n        while (l < r) {\n            if (l & 1) lazy[l] = MonoidAct::op3(lazy[l], val), l++;\n            if (r & 1) r--, lazy[r] = MonoidAct::op3(lazy[r],val);\n            l >>= 1; r >>= 1;\n        }\n        while (tl >>= 1, tr >>= 1, tl) {\n            if (lazy[tl] == MonoidAct::id()) update(tl);\n            if (lazy[tr] == MonoidAct::id()) update(tr);\n        }\n    }\n    T1 find(size_t l, size_t r) {\n        l += n, r += n - 1;\n        for (N i = h; i > 0; i--) eval(l >> i), eval(r >> i);\n        r++;\n        T1 res1 = Monoid::id(), res2 = Monoid::id();\n        while (l < r) {\n            if (l & 1) res1 = Monoid::op1(res1, op2(data[l],lazy[l],rank[l])), l++;\n            if (r & 1) r--, res2 = Monoid::op1(op2(data[r],lazy[r],rank[r]),res2);\n            l >>= 1; r >>= 1;\n        }\n        return Monoid::op1(res1, res2);\n    }\n};\n\n\n// findモノイド\nstruct RMQ { // 区間の最小\n    using T = long;\n    static T op1(const T& a, const T& b) { return min(a,b); }\n    static constexpr T id() {return numeric_limits<T>::max();}\n};\nstruct RSQ { // 区間の和\n    using T = long;\n    static T op1(const T& a, const T& b) { return (a+b); }\n    static constexpr T id() {return 0; }\n};\n\n// updateモノイド\nstruct RUQ { // 区間に代入更新\n    using T = int;\n    static T op3(const T& l,const T& r) { return r != id() ? r : l;}\n    static constexpr T id() { return (-1); }\n};\n\nstruct RAQ { // 区間に加算\n    using T = long;\n    static T op3(const T& l,const T& r) { return l+r;}\n    static constexpr T id() { return 0;}\n};\n\n\nint main(void) {\n    int n,q,com,s,t,x;\n    cin >> n >> q;\n    LazySegmentTree<RSQ,RUQ,long> sg(n,0);\n    REP(i,q) {\n        cin >> com;\n        if (!com) {\n            cin >> s >> t >> x;\n            sg.update(s,t+1,x);\n        }\n        else {\n            cin >> s >> t;\n            cout << sg.find(s,t+1) << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * \n */\n\n// header {{{\n#include <bits/stdc++.h>\nusing namespace std;\n\n// C++17 polyfill {{{\ntemplate<bool B>\nusing BoolConstant = integral_constant<bool, B>;\n// }}}\n\n// C++20 polyfill {{{\nstruct IDENTITY {\n    using is_transparent = void;\n    template<typename T>\n    constexpr T&& operator()(T&& x) const noexcept {\n        return forward<T>(x);\n    }\n};\n// }}}\n\n#define CPP_STR(x) CPP_STR_I(x)\n#define CPP_CAT(x,y) CPP_CAT_I(x,y)\n#define CPP_STR_I(args...) #args\n#define CPP_CAT_I(x,y) x ## y\n\n#define SFINAE(pred...) std::enable_if_t<(pred), std::nullptr_t> = nullptr\n\n#define ASSERT(expr...) assert((expr))\n\nusing i8   = int8_t;\nusing u8   = uint8_t;\nusing i16  = int16_t;\nusing u16  = uint16_t;\nusing i32  = int32_t;\nusing u32  = uint32_t;\nusing i64  = int64_t;\nusing u64  = uint64_t;\n#ifdef __SIZEOF_INT128__\nusing i128 = __int128;\nusing u128 = unsigned __int128;\n#endif\n\nusing f32  = float;\nusing f64  = double;\nusing f80  = __float80;\nusing f128 = __float128;\n\nusing complex32 = complex<f32>;\nusing complex64 = complex<f64>;\nusing complex80 = complex<f80>;\n// }}}\n\ntemplate<typename T> constexpr T PROCON_INF();\ntemplate<> constexpr i64 PROCON_INF<i64>() { return 1'010'000'000'000'000'017LL; }\ntemplate<> constexpr f64 PROCON_INF<f64>() { return 1e100; }\n\nconstexpr i64 INF  = PROCON_INF<i64>();\nconstexpr f64 FINF = PROCON_INF<f64>();\n\nconstexpr i64 MOD = 1'000'000'007LL;\n\nconstexpr f64 EPS = 1e-12;\n\nconstexpr f64 PI = 3.14159265358979323846;\n\n// util {{{\n#define FOR(i, start, end) for(i64 i = (start), CPP_CAT(i,xxxx_end)=(end); i < CPP_CAT(i,xxxx_end); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,c,...) (([&](decltype((c)) cccc) { return (f)(std::begin(cccc), std::end(cccc), ## __VA_ARGS__); })(c))\n#define SLICE(f,c,l,r,...) (([&](decltype((c)) cccc, decltype((l)) llll, decltype((r)) rrrr) {\\\n    auto iiii = llll <= rrrr ? std::begin(cccc)+llll : std::end(cccc);\\\n    auto jjjj = llll <= rrrr ? std::begin(cccc)+rrrr : std::end(cccc);\\\n    return (f)(iiii, jjjj, ## __VA_ARGS__);\\\n})(c,l,r))\n\n#define GENERIC(f) ([](auto&&... args) -> decltype(auto) { return (f)(std::forward<decltype(args)>(args)...); })\n\n// ビット演算 {{{\n// 引数は [-INF,INF] のみ想定\n\ni64 BIT_I(i64 i) {\n    return 1LL << i;\n}\n\ni64 BIT_I_1(i64 i) {\n    return BIT_I(i) - 1;\n}\n\ni64 BIT_GET(i64 x, i64 i) {\n    return x & BIT_I(i);\n}\n\nbool BIT_TEST(i64 x, i64 i) {\n    return BIT_GET(x,i) != 0;\n}\n\ni64 BIT_SET(i64 x, i64 i) {\n    return x | BIT_I(i);\n}\n\ni64 BIT_CLEAR(i64 x, i64 i) {\n    return x & ~BIT_I(i);\n}\n\ni64 BIT_FLIP(i64 x, i64 i) {\n    return x ^ BIT_I(i);\n}\n\ni64 BIT_ASSIGN(i64 x, i64 i, bool b) {\n    return b ? BIT_SET(x,i) : BIT_CLEAR(x,i);\n}\n\ni64 BIT_COUNT_LEADING_ZEROS(i64 x) {\n    if(x == 0) return 64;\n    return __builtin_clzll(x);\n}\n\ni64 BIT_COUNT_LEADING_ONES(i64 x) {\n    return BIT_COUNT_LEADING_ZEROS(~x);\n}\n\ni64 BIT_COUNT_TRAILING_ZEROS(i64 x) {\n    if(x == 0) return 64;\n    return __builtin_ctzll(x);\n}\n\ni64 BIT_COUNT_TRAILING_ONES(i64 x) {\n    return BIT_COUNT_TRAILING_ZEROS(~x);\n}\n\n// 末尾へ続く0を識別するマスクを返す (ex. 0b10100 -> 0b00011)\n// x=0 なら -1 を返す\ni64 BIT_MASK_TRAILING_ZEROS(i64 x) {\n    return ~x & (x-1);\n}\n\n// 末尾へ続く1を識別するマスクを返す (ex. 0b10011 -> 0b00011)\n// x=-1 なら -1 を返す\ni64 BIT_MASK_TRAILING_ONES(i64 x) {\n    return x & ~(x+1);\n}\n\ni64 BIT_COUNT_ONES(i64 x) {\n    return __builtin_popcountll(x);\n}\n\ni64 BIT_COUNT_ZEROS(i64 x) {\n    return 64 - BIT_COUNT_ONES(x);\n}\n\n// 先頭から続く冗長な符号ビットを数える (ex. 1 -> 62, -1 -> 63)\ni64 BIT_COUNT_LEADING_REDUNDANT_SIGN_BITS(i64 x) {\n    return __builtin_clrsbll(x);\n}\n\n// 1の個数が奇数なら1, 偶数なら0を返す\ni64 BIT_PARITY(i64 x) {\n    return __builtin_parityll(x);\n}\n\n// 最右の0を分離する (ex. 0b11001 -> 0b00010)\n// x=-1 なら 0 を返す\ni64 BIT_EXTRACT_FIRST_ZERO(i64 x) {\n    return ~x & (x+1);\n}\n\n// 最右の1を分離する (ex. 0b10110 -> 0b00010)\n// x=0 なら 0 を返す\ni64 BIT_EXTRACT_FIRST_ONE(i64 x) {\n    return x & (-x);\n}\n\n// 最右の0を1にする (ex. 0b11001 -> 0b11011)\ni64 BIT_FLIP_FIRST_ZERO(i64 x) {\n    return x | (x+1);\n}\n\n// 最右の1を0にする (ex. 0b10110 -> 0b10100)\ni64 BIT_FLIP_FIRST_ONE(i64 x) {\n    return x & (x-1);\n}\n\n// 最右の1の位置(1-based)を得る\n// x=0 なら 0 を返す\ni64 BIT_FIND_FIRST_ONE(i64 x) {\n    return __builtin_ffsll(x);\n}\n\n// 最右の0の位置(1-based)を得る\n// x=-1 なら 0 を返す\ni64 BIT_FIND_FIRST_ZERO(i64 x) {\n    return BIT_FIND_FIRST_ONE(~x);\n}\n\n// 最右の0をそれより右に伝播する (ex. 0b11011 -> 0b11000)\n// x=-1 なら -1 を返す\ni64 BIT_PROPAGATE_FIRST_ZERO(i64 x) {\n    if(x == -1) return -1;\n    return x & (x+1);\n}\n\n// 最右の1をそれより右に伝播する (ex. 0b10100 -> 0b10111)\n// x=0 なら 0 を返す\ni64 BIT_PROPAGATE_FIRST_ONE(i64 x) {\n    if(x == 0) return 0;\n    return x | (x-1);\n}\n\n// 最右の0および末尾へ続く1を識別するマスクを返す (ex. 0b11011 -> 0b00111)\n// x=-1 なら 0 を返す\ni64 BIT_MASKTO_FIRST_ZERO(i64 x) {\n    if(x == -1) return 0;\n    return x ^ (x+1);\n}\n\n// 最右の1および末尾へ続く0を識別するマスクを返す (ex. 0b10100 -> 0b00111)\n// x=0 なら 0 を返す\ni64 BIT_MASKTO_FIRST_ONE(i64 x) {\n    if(x == 0) return 0;\n    return x ^ (x-1);\n}\n\n// 最右の連続した0を1にする (ex. 0b101001 -> 0b101111)\n// x=-1 なら -1 を返す\ni64 BIT_FLIP_FIRST_ZEROS(i64 x) {\n    return ((x&(x+1))-1) | x;\n}\n\n// 最右の連続した1を0にする (ex. 0b10110 -> 0b10000)\n// x=0 なら 0 を返す\ni64 BIT_FLIP_FIRST_ONES(i64 x) {\n    return ((x|(x-1))+1) & x;\n}\n\n// X ⊆ {0,1,...,n-1}, |X| = k なる部分集合 X を昇順に列挙する\n// comb(n,k) 個\n//\n// ex.\n// ```\n// i64 x = BIT_I_1(3);\n// do {\n//     // ...\n// } while(BIT_NEXT_SET_SIZED(x, 10));\n// ```\nbool BIT_NEXT_SET_SIZED(i64& x, i64 n) {\n    if(x == 0) return false;\n    i64 t = BIT_PROPAGATE_FIRST_ONE(x) + 1;\n    x = t | (BIT_MASK_TRAILING_ZEROS(t) >> (BIT_COUNT_TRAILING_ZEROS(x)+1));\n    return x < BIT_I(n);\n}\n\n// 集合 Y の部分集合 X を昇順に列挙する\n// 2^|Y| 個\n//\n// ex.\n// ```\n// i64 y = 0b10101;\n// i64 x = 0;\n// do {\n//     // ...\n// } while(BIT_NEXT_SUBSET(x, y));\n// ```\nbool BIT_NEXT_SUBSET(i64& x, i64 y) {\n    if(x == y) return false;\n    x = (x-y) & y;\n    return true;\n}\n\n// 集合 Y の部分集合 X を降順に列挙する\n// 2^|Y| 個\n//\n// ex.\n// ```\n// i64 y = 0b10101;\n// i64 x = y;\n// do {\n//     // ...\n// } while(BIT_PREV_SUBSET(x, y));\n// ```\nbool BIT_PREV_SUBSET(i64& x, i64 y) {\n    if(x == 0) return false;\n    x = (x-1) & y;\n    return true;\n}\n\n// 集合 Y を包含する集合 X ⊆ {0,1,...,n-1} を昇順に列挙する\n// 2^(n-|Y|) 個\n//\n// ex.\n// ```\n// i64 y = 0b00010101;\n// i64 x = y;\n// do {\n//     // ...\n// } while(BIT_NEXT_SUPERSET(x, 8, y));\n// ```\nbool BIT_NEXT_SUPERSET(i64& x, i64 n, i64 y) {\n    x = (x+1) | y;\n    return x < BIT_I(n);\n}\n// }}}\n\ntemplate<typename T1, typename T2, typename Comp=less<>,\n         SFINAE(\n             is_integral<T1>::value &&\n             is_integral<T2>::value &&\n             is_signed<T1>::value != is_unsigned<T2>::value\n         )>\ncommon_type_t<T1,T2> MAX(T1 x, T2 y, Comp comp={}) {\n    return max<common_type_t<T1,T2>>(x, y, comp);\n}\n\ntemplate<typename T1, typename T2, typename Comp=less<>,\n         SFINAE(\n             is_floating_point<T1>::value &&\n             is_floating_point<T2>::value\n         )>\ncommon_type_t<T1,T2> MAX(T1 x, T2 y, Comp comp={}) {\n    return max<common_type_t<T1,T2>>(x, y, comp);\n}\n\ntemplate<typename T, typename Comp=less<>>\nconst T& MAX(const T& x, const T& y, Comp comp={}) {\n    return max(x, y, comp);\n}\n\ntemplate<typename T, typename Comp=less<>>\nT MAX(initializer_list<T> ilist, Comp comp={}) {\n    return max(ilist, comp);\n}\n\ntemplate<typename T1, typename T2, typename Comp=less<>,\n         SFINAE(\n             is_integral<T1>::value &&\n             is_integral<T2>::value &&\n             is_signed<T1>::value != is_unsigned<T2>::value\n         )>\ncommon_type_t<T1,T2> MIN(T1 x, T2 y, Comp comp={}) {\n    return min<common_type_t<T1,T2>>(x, y, comp);\n}\n\ntemplate<typename T1, typename T2, typename Comp=less<>,\n         SFINAE(\n             is_floating_point<T1>::value &&\n             is_floating_point<T2>::value\n         )>\ncommon_type_t<T1,T2> MIN(T1 x, T2 y, Comp comp={}) {\n    return min<common_type_t<T1,T2>>(x, y, comp);\n}\n\ntemplate<typename T, typename Comp=less<>>\nconst T& MIN(const T& x, const T& y, Comp comp={}) {\n    return min(x, y, comp);\n}\n\ntemplate<typename T, typename Comp=less<>>\nT MIN(initializer_list<T> ilist, Comp comp={}) {\n    return min(ilist, comp);\n}\n\ntemplate<typename T>\nT ABS(T x) {\n    static_assert(is_signed<T>::value, \"ABS(): argument must be signed\");\n    return x < 0 ? -x : x;\n}\n\nf64 ROUND(f64 x) {\n    return round(x);\n}\n\ni64 IROUND(f64 x) {\n    return llround(x);\n}\n\ntemplate<typename C>\ni64 SIZE(const C& c) { return static_cast<i64>(c.size()); }\n\ntemplate<typename T, size_t N>\ni64 SIZE(const T (&)[N]) { return static_cast<i64>(N); }\n\nbool is_odd (i64 x) { return x % 2 != 0; }\nbool is_even(i64 x) { return x % 2 == 0; }\n\ntemplate<typename T> i64 cmp(T x, T y) { return (y<x) - (x<y); }\ntemplate<typename T> i64 sgn(T x) { return cmp(x, T(0)); }\n\n// 事前条件: a >= 0, b >= 0\ni64 gcd_impl(i64 a, i64 b) {\n    if(b == 0) return a;\n    return gcd_impl(b, a%b);\n}\n\n// GCD(0,0) = 0\ni64 GCD(i64 a, i64 b) {\n    return gcd_impl(ABS(a), ABS(b));\n}\n\n// LCM(0,x) は未定義\ni64 LCM(i64 a, i64 b) {\n    ASSERT(a != 0 && b != 0);\n    a = ABS(a);\n    b = ABS(b);\n    return a / gcd_impl(a,b) * b;\n}\n\n// lo:OK, hi:NG\ntemplate<typename Pred>\ni64 bisect_integer(i64 lo, i64 hi, Pred pred) {\n    ASSERT(lo < hi);\n\n    while(lo+1 < hi) {\n        i64 mid = (lo+hi) / 2;\n        if(pred(mid))\n            lo = mid;\n        else\n            hi = mid;\n    }\n    return lo;\n}\n\ntemplate<typename Pred>\nf64 bisect_real(f64 lo, f64 hi, Pred pred, i64 iter=100) {\n    ASSERT(lo < hi);\n\n    REP(_, iter) {\n        f64 mid = (lo+hi) / 2;\n        if(pred(mid))\n            lo = mid;\n        else\n            hi = mid;\n    }\n    return lo;\n}\n\ni64 ipow(i64 x, i64 e) {\n    ASSERT(e >= 0);\n    i64 res = 1;\n    REP(_, e) {\n        res *= x;\n    }\n    return res;\n}\n\ni64 sqrt_floor(i64 x) {\n    ASSERT(x >= 0);\n\n    i64 lo = 0;\n    i64 hi = MIN(x/2+2, 3037000500LL);\n    return bisect_integer(lo, hi, [x](i64 r) { return r*r <= x; });\n}\n\ni64 sqrt_ceil(i64 x) {\n    i64 r = sqrt_floor(x);\n    return r*r == x ? r : r+1;\n}\n\n// 0 <= log2_ceil(x) <= 63\ni64 log2_ceil(i64 x) {\n    ASSERT(x > 0);\n    return 64 - BIT_COUNT_LEADING_ZEROS(x-1);\n}\n\n// 0 <= log2_floor(x) <= 62\ni64 log2_floor(i64 x) {\n    ASSERT(x > 0);\n    return 63 - BIT_COUNT_LEADING_ZEROS(x);\n}\n\n// 2^n - 1 の形かどうか\nbool is_mersenne(i64 x) {\n    ASSERT(x >= 0);\n    return (x&(x+1)) == 0;\n}\n\nbool is_pow2(i64 x) {\n    ASSERT(x > 0);\n    return (x&(x-1)) == 0;\n}\n\n// x > 0\ni64 pow2_ceil(i64 x) {\n    return BIT_I(log2_ceil(x));\n}\n\n// x > 0\ni64 pow2_floor(i64 x) {\n    return BIT_I(log2_floor(x));\n}\n\n// Haskell の divMod と同じ\npair<i64,i64> divmod(i64 a, i64 b) {\n    i64 q = a / b;\n    i64 r = a % b;\n    if((b>0 && r<0) || (b<0 && r>0)) {\n        --q;\n        r += b;\n    }\n    return {q,r};\n}\n\ni64 div_ceil(i64 a, i64 b) {\n    i64 q = a / b;\n    i64 r = a % b;\n    if((b>0 && r>0) || (b<0 && r<0))\n        ++q;\n    return q;\n}\n\ni64 div_floor(i64 a, i64 b) {\n    return divmod(a,b).first;\n}\n\ni64 modulo(i64 a, i64 b) {\n    return divmod(a,b).second;\n}\n\n// x を align の倍数に切り上げる\ni64 align_ceil(i64 x, i64 align) {\n    ASSERT(align > 0);\n    return div_ceil(x,align) * align;\n}\n\n// x を align の倍数に切り下げる\ni64 align_floor(i64 x, i64 align) {\n    ASSERT(align > 0);\n    return div_floor(x,align) * align;\n}\n\nbool feq(f64 x, f64 y, f64 eps=EPS) {\n    return fabs(x-y) < eps;\n}\n\ntemplate<typename T, typename U, typename Comp=less<>>\nbool chmax(T& xmax, const U& x, Comp comp={}) {\n    if(comp(xmax, x)) {\n        xmax = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T, typename U, typename Comp=less<>>\nbool chmin(T& xmin, const U& x, Comp comp={}) {\n    if(comp(x, xmin)) {\n        xmin = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename InputIt, typename BinaryOp>\nauto FOLD(InputIt first, InputIt last,\n          typename iterator_traits<InputIt>::value_type init,\n          BinaryOp op)\n{\n    for(; first != last; ++first)\n        init = op(move(init), *first);\n    return init;\n}\n\ntemplate<typename InputIt, typename BinaryOp>\nauto FOLD1(InputIt first, InputIt last, BinaryOp op) {\n    auto init = *first++;\n    return FOLD(first, last, init, op);\n}\n\ntemplate<typename InputIt>\nauto SUM(InputIt first, InputIt last) {\n    using T = typename iterator_traits<InputIt>::value_type;\n    return accumulate(first, last, T());\n}\n\ntemplate<typename ForwardIt, typename UnaryOperation>\nForwardIt transform_self(ForwardIt first, ForwardIt last, UnaryOperation op) {\n    return transform(first, last, first, op);\n}\n\ntemplate<typename C>\nvoid UNIQ(C& c) {\n    c.erase(ALL(unique,c), end(c));\n}\n\ntemplate<typename BinaryFunc>\nauto FLIP(BinaryFunc f) {\n    return [f](const auto& x, const auto& y) {\n        return f(y,x);\n    };\n}\n\ntemplate<typename BinaryFunc, typename UnaryFunc>\nauto ON(BinaryFunc bf, UnaryFunc uf) {\n    return [bf,uf](const auto& x, const auto& y) {\n        return bf(uf(x), uf(y));\n    };\n}\n\ntemplate<typename F>\nauto LT_ON(F f) { return ON(less<>(), f); }\n\ntemplate<typename F>\nauto GT_ON(F f) { return ON(greater<>(), f); }\n\ntemplate<typename F>\nauto EQ_ON(F f) { return ON(equal_to<>(), f); }\n\ntemplate<typename F>\nauto NE_ON(F f) { return ON(not_equal_to<>(), f); }\n\ntemplate<typename Comp=less<>>\nauto EQUIV(Comp comp={}) {\n    return [comp](const auto& lhs, const auto& rhs) {\n        return !comp(lhs,rhs) && !comp(rhs,lhs);\n    };\n}\n\ntemplate<typename ForwardIt>\nForwardIt next_bounded(ForwardIt last, ForwardIt it, i64 n=1) {\n    auto bound = distance(it, last);\n    return next(it, MIN(n, bound));\n}\n\ntemplate<typename ForwardIt>\nForwardIt prev_bounded(ForwardIt first, ForwardIt it, i64 n=1) {\n    auto bound = distance(first, it);\n    return prev(it, MIN(n, bound));\n}\n\ntemplate<typename ForwardIt>\nvoid advance_bounded(ForwardIt first, ForwardIt last, ForwardIt& it, i64 n) {\n    if(n > 0) {\n        auto bound = distance(it, last);\n        advance(it, MIN(n, bound));\n    }\n    else if(n < 0) {\n        auto bound = distance(it, first);\n        advance(it, MAX(n, bound));\n    }\n}\n\nchar digit_chr(i64 n) {\n    return static_cast<char>('0' + n);\n}\n\ni64 digit_ord(char c) {\n    return c - '0';\n}\n\nchar lower_chr(i64 n) {\n    return static_cast<char>('a' + n);\n}\n\ni64 lower_ord(char c) {\n    return c - 'a';\n}\n\nchar upper_chr(i64 n) {\n    return static_cast<char>('A' + n);\n}\n\ni64 upper_ord(char c) {\n    return c - 'A';\n}\n\n// 出力は operator<< を直接使わず、このテンプレート経由で行う\n// 提出用出力とデバッグ用出力を分けるため\ntemplate<typename T, typename Enable=void>\nstruct Formatter {\n    static ostream& write_str(ostream& out, const T& x)  { return out << x; }\n    static ostream& write_repr(ostream& out, const T& x) { return out << x; }\n};\n\ntemplate<typename T>\nostream& WRITE_STR(ostream& out, const T& x) {\n    return Formatter<T>::write_str(out, x);\n}\n\ntemplate<typename T>\nostream& WRITE_REPR(ostream& out, const T& x) {\n    return Formatter<T>::write_repr(out, x);\n}\n\ntemplate<typename InputIt>\nostream& WRITE_JOIN_STR(ostream& out, InputIt first, InputIt last, const string& sep) {\n    while(first != last) {\n        WRITE_STR(out, *first++);\n        if(first != last)\n            out << sep;\n    }\n    return out;\n}\n\ntemplate<typename InputIt>\nostream& WRITE_JOIN_REPR(ostream& out, InputIt first, InputIt last, const string& sep) {\n    while(first != last) {\n        WRITE_REPR(out, *first++);\n        if(first != last)\n            out << sep;\n    }\n    return out;\n}\n\ntemplate<typename InputIt>\nostream& WRITE_RANGE_STR(ostream& out, InputIt first, InputIt last) {\n    return WRITE_JOIN_STR(out, first, last, \" \");\n}\n\ntemplate<typename InputIt>\nostream& WRITE_RANGE_REPR(ostream& out, InputIt first, InputIt last) {\n    out << \"[\";\n    WRITE_JOIN_REPR(out, first, last, \", \");\n    out << \"]\";\n    return out;\n}\n\ntemplate<typename T>\nvoid FROM_STR(const string& s, T& x) {\n    istringstream in(s);\n    in >> x;\n}\n\ntemplate<typename T>\nstring TO_STR(const T& x) {\n    ostringstream out;\n    WRITE_STR(out, x);\n    return out.str();\n}\n\ntemplate<typename T>\nstring TO_REPR(const T& x) {\n    ostringstream out;\n    WRITE_REPR(out, x);\n    return out.str();\n}\n\ntemplate<typename InputIt>\nstring RANGE_TO_STR(InputIt first, InputIt last) {\n    ostringstream out;\n    WRITE_RANGE_STR(out, first, last);\n    return out.str();\n}\n\ntemplate<typename InputIt>\nstring RANGE_TO_REPR(InputIt first, InputIt last) {\n    ostringstream out;\n    WRITE_RANGE_REPR(out, first, last);\n    return out.str();\n}\n\ntemplate<typename InputIt>\nstring JOIN(InputIt first, InputIt last, const string& sep) {\n    ostringstream out;\n    WRITE_JOIN_STR(out, first, last, sep);\n    return out.str();\n}\n\ntemplate<>\nstruct Formatter<i64> {\n    static ostream& write_str(ostream& out, i64 x) {\n        return out << x;\n    }\n    static ostream& write_repr(ostream& out, i64 x) {\n        if(x == INF) return out << \"INF\";\n        if(x == -INF) return out << \"-INF\";\n        return out << x;\n    }\n};\n\ntemplate<>\nstruct Formatter<f64> {\n    static ostream& write_str(ostream& out, f64 x) {\n        return out << x;\n    }\n    static ostream& write_repr(ostream& out, f64 x) {\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wfloat-equal\"\n        if(x == FINF) return out << \"FINF\";\n        if(x == -FINF) return out << \"-FINF\";\n#pragma GCC diagnostic pop\n        return out << x;\n    }\n};\n\ntemplate<typename T>\nstruct Formatter<vector<T>> {\n    static ostream& write_str(ostream& out, const vector<T>& v) {\n        return WRITE_RANGE_STR(out, begin(v), end(v));\n    }\n    static ostream& write_repr(ostream& out, const vector<T>& v) {\n        out << \"vector\";\n        return WRITE_RANGE_REPR(out, begin(v), end(v));\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Formatter<pair<T1,T2>> {\n    static ostream& write_str(ostream& out, const pair<T1,T2>& p) {\n        WRITE_STR(out, p.first);\n        out << ' ';\n        WRITE_STR(out, p.second);\n        return out;\n    }\n    static ostream& write_repr(ostream& out, const pair<T1,T2>& p) {\n        out << \"(\";\n        WRITE_REPR(out, p.first);\n        out << \",\";\n        WRITE_REPR(out, p.second);\n        out << \")\";\n        return out;\n    }\n};\n\ntemplate<typename... TS>\nstruct Formatter<tuple<TS...>> {\n    template<size_t I=0, SFINAE(sizeof...(TS) == I)>\n    static ostream& write_str_impl(ostream& out, const tuple<TS...>&) {\n        return out;\n    }\n    template<size_t I=0, SFINAE(sizeof...(TS) > I)>\n    static ostream& write_str_impl(ostream& out, const tuple<TS...>& t) {\n        if(I != 0) out << ' ';\n        WRITE_STR(out, get<I>(t));\n        return write_str_impl<I+1>(out, t);\n    }\n\n    template<size_t I=0, SFINAE(sizeof...(TS) == I)>\n    static ostream& write_repr_impl(ostream& out, const tuple<TS...>&) {\n        if(sizeof...(TS) == 0) out << \"(\";\n        return out << \")\";\n    }\n    template<size_t I=0, SFINAE(sizeof...(TS) > I)>\n    static ostream& write_repr_impl(ostream& out, const tuple<TS...>& t) {\n        if(I == 0)\n            out << \"(\";\n        else\n            out << \",\";\n        WRITE_REPR(out, get<I>(t));\n        return write_repr_impl<I+1>(out, t);\n    }\n\n    static ostream& write_str(ostream& out, const tuple<TS...>& t) {\n        return write_str_impl(out, t);\n    }\n    static ostream& write_repr(ostream& out, const tuple<TS...>& t) {\n        return write_repr_impl(out, t);\n    }\n};\n\ntemplate<typename T>\nvoid RD(T& x) {\n    cin >> x;\n#ifdef PROCON_LOCAL\n    ASSERT(cin);\n#endif\n}\n\ntemplate<typename T>\nvoid RD1(T& x) {\n    RD(x);\n    --x;\n}\n\nvoid PRINT() {}\n\ntemplate<typename T, typename... TS>\nvoid PRINT(const T& x, const TS& ...args) {\n    WRITE_STR(cout, x);\n    if(sizeof...(args)) {\n        cout << ' ';\n        PRINT(args...);\n    }\n}\n\ntemplate<typename... TS>\nvoid PRINTLN(const TS& ...args) {\n    PRINT(args...);\n    cout << '\\n';\n}\n\n[[noreturn]] void EXIT() {\n    cout.flush();\n#ifdef PROCON_LOCAL\n    cerr.flush();\n    exit(0);\n#else\n    _Exit(0);\n#endif\n}\n\ntemplate<typename... TS, SFINAE(sizeof...(TS) == 1)>\nvoid DBG_IMPL(i64 line, const char* expr, const tuple<TS...>& value) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \";\n    WRITE_REPR(cerr, get<0>(value));\n    cerr << \"\\n\";\n}\n\ntemplate<typename... TS, SFINAE(sizeof...(TS) >= 2)>\nvoid DBG_IMPL(i64 line, const char* expr, const tuple<TS...>& value) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << \"(\" << expr << \") = \";\n    WRITE_REPR(cerr, value);\n    cerr << \"\\n\";\n}\n\ntemplate<typename T, size_t N>\nvoid DBG_CARRAY_IMPL(i64 line, const char* expr, const T (&ary)[N]) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \";\n    WRITE_RANGE_REPR(cerr, begin(ary), end(ary));\n    cerr << \"\\n\";\n}\n\ntemplate<typename InputIt>\nvoid DBG_RANGE_IMPL(i64 line, const char* expr1, const char* expr2, InputIt first, InputIt last) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr1 << \",\" << expr2 << \" = \";\n    WRITE_RANGE_REPR(cerr, first, last);\n    cerr << \"\\n\";\n}\n\n#ifdef PROCON_LOCAL\n    #define DBG(args...) DBG_IMPL(__LINE__, CPP_STR_I(args), std::make_tuple(args))\n    #define DBG_CARRAY(expr) DBG_CARRAY_IMPL(__LINE__, CPP_STR(expr), (expr))\n    #define DBG_RANGE(first,last) DBG_RANGE_IMPL(__LINE__, CPP_STR(first), CPP_STR(last), (first), (last))\n#else\n    #define DBG(args...)\n    #define DBG_CARRAY(expr)\n    #define DBG_RANGE(first,last)\n#endif\n\n#define PAIR  make_pair\n#define TUPLE make_tuple\n// }}}\n\n// init {{{\nstruct ProconInit {\n    static constexpr int IOS_PREC = 15;\n    static constexpr bool AUTOFLUSH = false;\n\n    ProconInit() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(IOS_PREC);\n#ifdef PROCON_LOCAL\n        cerr << fixed << setprecision(IOS_PREC);\n#endif\n        if(AUTOFLUSH)\n            cout << unitbuf;\n    }\n} PROCON_INIT;\n// }}}\n\n//--------------------------------------------------------------------\n\n// FST/SND {{{\ntemplate<typename T1, typename T2>\nT1& FST(pair<T1,T2>& p) {\n    return p.first;\n}\n\ntemplate<typename T1, typename T2>\nconst T1& FST(const pair<T1,T2>& p) {\n    return p.first;\n}\n\ntemplate<typename T1, typename T2>\nT2& SND(pair<T1,T2>& p) {\n    return p.second;\n}\n\ntemplate<typename T1, typename T2>\nconst T2& SND(const pair<T1,T2>& p) {\n    return p.second;\n}\n\ntemplate<typename... TS, SFINAE(sizeof...(TS) >= 1)>\nauto& FST(tuple<TS...>& t) {\n    return get<0>(t);\n}\n\ntemplate<typename... TS, SFINAE(sizeof...(TS) >= 1)>\nconst auto& FST(const tuple<TS...>& t) {\n    return get<0>(t);\n}\n\ntemplate<typename... TS, SFINAE(sizeof...(TS) >= 2)>\nauto& SND(tuple<TS...>& t) {\n    return get<1>(t);\n}\n\ntemplate<typename... TS, SFINAE(sizeof...(TS) >= 2)>\nconst auto& SND(const tuple<TS...>& t) {\n    return get<1>(t);\n}\n// }}}\n\n// ノード: v (1-based)\n// 元配列のインデックス: i (0-based)\n\ntemplate<\n    typename Monoid, typename Action,\n    typename FuncMonoid, typename FuncAction, typename FuncLazy\n>\nstruct SegTreeLazy {\n    FuncMonoid fm_;\n    FuncAction fa_;\n    FuncLazy   fl_;\n    Monoid unity_monoid_;\n    Action unity_action_;\n    i64 n_orig_;\n    i64 n_;\n    vector<Monoid> data_;  // 1-based\n    vector<Action> lazy_;  // 1-based\n\n    SegTreeLazy(\n        FuncMonoid&& fm, FuncAction&& fa, FuncLazy&& fl,\n        const Monoid& unity_monoid, const Action& unity_action,\n        i64 n\n    ) :\n        fm_(forward<FuncMonoid>(fm)), fa_(forward<FuncAction>(fa)), fl_(forward<FuncLazy>(fl)),\n        unity_monoid_(unity_monoid), unity_action_(unity_action),\n        n_orig_(n),\n        n_(pow2_ceil(n)), data_(2*n_,unity_monoid_), lazy_(2*n_,unity_action_)\n    {\n        \n    }\n\n    SegTreeLazy(\n        FuncMonoid&& fm, FuncAction&& fa, FuncLazy&& fl,\n        const Monoid& unity_monoid, const Action& unity_action,\n        i64 n, const Monoid& x\n    ) :\n        SegTreeLazy(\n            forward<FuncMonoid>(fm), forward<FuncAction>(fa), forward<FuncLazy>(fl),\n            unity_monoid, unity_action,\n            n\n        )\n    {\n        //SLICE(fill, data_, n_, 2*n_, x);\n        SLICE(fill, data_, n_, n_+n_orig_, x);\n        for(i64 i = n_-1; i >= 1; --i)\n            data_[i] = fm_(data_[node_l(i)], data_[node_r(i)]);\n    }\n\n    void update(i64 i, i64 k, Action x) {\n        update_impl(i, i+k, x, 1, 0, n_);\n    }\n\n    Monoid query(i64 i, i64 k) {\n        return query_impl(i, i+k, 1, 0, n_);\n    }\n\nprivate:\n    // [a,b): 要求区間\n    // [l,r): ノード v の区間\n    void update_impl(i64 a, i64 b, Action x, i64 v, i64 l, i64 r) {\n        // まず現ノードを評価\n        // ここで lazy_[v] が空になる\n        eval(v);\n\n        // [a,b), [l,r) が共通部分を持たなければ何もしない\n        if(b <= l || r <= a) return;\n\n        // [a,b) が [l,r) を完全に被覆するなら lazy_[v] に値を入れた後に評価\n        if(a <= l && r <= b) {\n            lazy_[v] = fl_(lazy_[v], x);\n            eval(v);\n        }\n        // [a,b) が [l,r) と部分的に交わるなら子ノードを更新\n        // 最後に data_[v] を更新\n        else {\n            i64 vl = node_l(v);\n            i64 vr = node_r(v);\n            update_impl(a, b, x, vl, l, (l+r)/2);\n            update_impl(a, b, x, vr, (l+r)/2, r);\n            data_[v] = fm_(data_[vl], data_[vr]);\n        }\n    }\n\n    // [a,b): 要求区間\n    // [l,r): ノード v の区間\n    Monoid query_impl(i64 a, i64 b, i64 v, i64 l, i64 r) {\n        // [a,b), [l,r) が共通部分を持たなければ単位元を返す\n        if(b <= l || r <= a) return unity_monoid_;\n\n        // 現ノードを評価\n        eval(v);\n\n        // [a,b) が [l,r) を完全に被覆するなら data_[v] を返す\n        if(a <= l && r <= b) return data_[v];\n\n        // [a,b) が [l,r) と部分的に交わるなら子ノードの値をマージして返す\n        Monoid ml = query_impl(a, b, node_l(v), l, (l+r)/2);\n        Monoid mr = query_impl(a, b, node_r(v), (l+r)/2, r);\n        return fm_(ml, mr);\n    }\n\n    void eval(i64 v) {\n        if(lazy_[v] == unity_action_) return;\n\n        data_[v] = fa_(data_[v], lazy_[v]);\n        if(!node_is_leaf(v)) {\n            i64 vl = node_l(v);\n            i64 vr = node_r(v);\n            lazy_[vl] = fl_(lazy_[vl], lazy_[v]);\n            lazy_[vr] = fl_(lazy_[vr], lazy_[v]);\n        }\n\n        lazy_[v] = unity_action_;\n    }\n\n    static i64 node_l(i64 v) {\n        return 2*v;\n    }\n\n    static i64 node_r(i64 v) {\n        return 2*v + 1;\n    }\n\n    bool node_is_leaf(i64 v) const {\n        return v >= n_;\n    }\n\n    i64 node_leaf(i64 i) const {\n        return i + n_;\n    }\n};\n\ntemplate<\n    typename Monoid, typename Action,\n    typename FuncMonoid, typename FuncAction, typename FuncLazy,\n    typename T1, typename T2\n>\nauto make_segtree_lazy(\n    FuncMonoid&& fm, FuncAction&& fa, FuncLazy&& fl,\n    const T1& unity_monoid, const T2& unity_action,\n    i64 n\n) {\n    return SegTreeLazy<Monoid,Action,FuncMonoid,FuncAction,FuncLazy>(\n        forward<FuncMonoid>(fm), forward<FuncAction>(fa), forward<FuncLazy>(fl),\n        unity_monoid, unity_action,\n        n\n    );\n}\n\ntemplate<\n    typename Monoid, typename Action,\n    typename FuncMonoid, typename FuncAction, typename FuncLazy,\n    typename T1, typename T2, typename T3\n>\nauto make_segtree_lazy(\n    FuncMonoid&& fm, FuncAction&& fa, FuncLazy&& fl,\n    const T1& unity_monoid, const T2& unity_action,\n    i64 n,\n    const T3& x\n) {\n    return SegTreeLazy<Monoid,Action,FuncMonoid,FuncAction,FuncLazy>(\n        forward<FuncMonoid>(fm), forward<FuncAction>(fa), forward<FuncLazy>(fl),\n        unity_monoid, unity_action,\n        n, x\n    );\n}\n\nvoid solve() {\n    i64 N; RD(N);\n    i64 Q; RD(Q);\n\n    using Monoid = pair<i64,i64>;  // (総和,区間幅)\n    using Action = i64;            // 区間を更新する値\n    auto seg = make_segtree_lazy<Monoid,Action>(\n        /* fm= */ [](const Monoid& m1, const Monoid& m2) {\n            return Monoid(FST(m1)+FST(m2), SND(m1)+SND(m2));\n        },\n        /* fa= */ [](const Monoid& m, Action a) {\n            return Monoid(SND(m)*a, SND(m));\n        },\n        /* fl= */ [](Action, Action a2) { return a2; },\n        /* unity_monoid= */ Monoid { 0, 1 },\n        /* unity_action= */ INF,\n        /* n= */ N,\n        /* x= */ Monoid { 0, 1 }\n    );\n    DBG(seg.data_);\n    DBG(seg.lazy_);\n    REP(_, Q) {\n        i64 cmd; RD(cmd);\n        if(cmd == 0) {\n            i64 s,t; RD(s); RD(t);\n            i64 x; RD(x);\n            seg.update(s, t-s+1, x);\n            //DBG(seg.data_);\n            //DBG(seg.lazy_);\n        }\n        else if(cmd == 1) {\n            i64 s,t; RD(s); RD(t);\n            i64 ans = FST(seg.query(s, t-s+1));\n            PRINTLN(ans);\n            //DBG(seg.data_);\n            //DBG(seg.lazy_);\n        }\n        else {\n            ASSERT(false);\n        }\n    }\n\n    // * 小さいケースで試した?\n    // * 不可能なケースはチェックした?\n    // * MOD はとった?\n    // * メモ化忘れてない?\n    // * 入出力の 0-based/1-based 確認した?\n    // * 時間/メモリ制限は確認した?\n    // * 違うやつ提出してない?\n    // * 違うやつテストしてない?\n}\n\nsigned main() {\n    \n\n    solve();\n\n    EXIT();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _GLIBCXX_DEBUG\nusing namespace std;\nusing ll = long long;\nusing vec = vector<ll>;\nusing vect = vector<double>;\nusing Graph = vector<vector<ll>>;\n#define loop(i, n) for (ll i = 0; i < n; i++)\n#define Loop(i, m, n) for (ll i = m; i < n; i++)\n#define pool(i, n) for (ll i = n; i >= 0; i--)\n#define Pool(i, m, n) for (ll i = n; i >= m; i--)\n#define mod 1000000007ll\n#define setbit bitset<8>\n#define flagcount __builtin_popcount\n#define flag(x) (1 << x)\n#define flagadd(bit, x) bit |= flag(x)\n#define flagpop(bit, x) bit &= ~flag(x)\n#define flagon(bit, i) bit &flag(i)\n#define flagoff(bit, i) !(bit & (1 << i))\n#define all(v) v.begin(), v.end()\n#define low2way(v, x) lower_bound(all(v), x)\n#define high2way(v, x) upper_bound(all(v), x)\n#define count2way(v, x) high2way(v, x) - low2way(v, x)\n#define lower(v, x) low2way(v, x) - v.begin()       //1番左が0、もし見つから無いならｎを出力\n#define higher(v, x) high2way(v, x) - v.begin() - 1 //1番左が0、もし見つからないならn-1を出力（注意）\n#define putout(a) cout << a << endl\n#define putout2(a, b) \\\n    putout(a);        \\\n    putout(b)\n#define putout3(a, b, c) \\\n    putout(a);           \\\n    putout(b);           \\\n    putout(c)\n#define putout4(a, b, c, d) \\\n    putout(a);              \\\n    putout(b);              \\\n    putout(c);              \\\n    putout(d)\n#define putout5(a, b, c, d, e) \\\n    putout(a);                 \\\n    putout(b);                 \\\n    putout(c);                 \\\n    putout(d);                 \\\n    putout(e)\n#define Gput(a, b) G[a].push_back(b)\n#define cin1(a) cin >> a\n#define cin2(a, b) cin >> a >> b\n#define cin3(a, b, c) cin >> a >> b >> c\n#define cin4(a, b, c, d) cin >> a >> b >> c >> d\n#define cin5(a, b, c, d, e) cin >> a >> b >> c >> d >> e\n#define sum(v) accumulate(all(v), 0ll)\n#define gcd(x, y) __gcd(x, y)\nll ctoi(char c)\n{\n    if (c >= '0' && c <= '9')\n    {\n        return c - '0';\n    }\n    return 0;\n}\ntemplate <typename T>\nT lcm(T x, T y)\n{\n    T z = gcd(x, y);\n    return x * y / z;\n}\ntemplate <typename T>\nbool primejudge(T n)\n{\n    if (n < 2)\n        return false;\n    else if (n == 2)\n        return true;\n    else if (n % 2 == 0)\n        return false;\n    double sqrtn = sqrt(n);\n    for (T i = 3; i < sqrtn + 1; i++)\n    {\n        if (n % i == 0)\n        {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\ntemplate <typename T>\nT modinv(T a, T m)\n{\n    T b = m, u = 1, v = 0;\n    while (b)\n    {\n        T t = a / b;\n        a -= t * b;\n        swap(a, b);\n        u -= t * v;\n        swap(u, v);\n    }\n    u %= m;\n    if (u < 0)\n        u += m;\n    return u;\n}\n//場合によって使い分ける\n//const ll dx[4]={1,0,-1,0};\n//const ll dy[4]={0,1,0,-1};\nconst ll dx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst ll dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n//多次元配列の宣言法\n//vector<vector<ll>> field(h, vector<ll>(w));\ntemplate <class T>\ninline void chmax(T &a, T b)\n{\n    if (a < b)\n        a = b;\n}\ntemplate <class T>\ninline void chmin(T &a, T b)\n{\n    if (a > b)\n        a = b;\n}\n/*\nライブラリをここに置いてコメントを削除\n*/\n#define N 100003\nclass segment_tree\n{\n    const ll inf = 1e18;\n    int n, n0;\n    ll max_v[4 * N], smax_v[4 * N], max_c[4 * N];\n    ll min_v[4 * N], smin_v[4 * N], min_c[4 * N];\n    ll sum[4 * N];\n    ll len[4 * N], ladd[4 * N], lval[4 * N];\n\n    void update_node_max(int k, ll x)\n    {\n        sum[k] += (x - max_v[k]) * max_c[k];\n\n        if (max_v[k] == min_v[k])\n        {\n            max_v[k] = min_v[k] = x;\n        }\n        else if (max_v[k] == smin_v[k])\n        {\n            max_v[k] = smin_v[k] = x;\n        }\n        else\n        {\n            max_v[k] = x;\n        }\n\n        if (lval[k] != inf && x < lval[k])\n        {\n            lval[k] = x;\n        }\n    }\n    void update_node_min(int k, ll x)\n    {\n        sum[k] += (x - min_v[k]) * min_c[k];\n\n        if (max_v[k] == min_v[k])\n        {\n            max_v[k] = min_v[k] = x;\n        }\n        else if (smax_v[k] == min_v[k])\n        {\n            min_v[k] = smax_v[k] = x;\n        }\n        else\n        {\n            min_v[k] = x;\n        }\n\n        if (lval[k] != inf && lval[k] < x)\n        {\n            lval[k] = x;\n        }\n    }\n\n    void push(int k)\n    {\n\n        if (n0 - 1 <= k)\n            return;\n\n        if (lval[k] != inf)\n        {\n            updateall(2 * k + 1, lval[k]);\n            updateall(2 * k + 2, lval[k]);\n            lval[k] = inf;\n            return;\n        }\n\n        if (ladd[k] != 0)\n        {\n            addall(2 * k + 1, ladd[k]);\n            addall(2 * k + 2, ladd[k]);\n            ladd[k] = 0;\n        }\n\n        if (max_v[k] < max_v[2 * k + 1])\n        {\n            update_node_max(2 * k + 1, max_v[k]);\n        }\n        if (min_v[2 * k + 1] < min_v[k])\n        {\n            update_node_min(2 * k + 1, min_v[k]);\n        }\n\n        if (max_v[k] < max_v[2 * k + 2])\n        {\n            update_node_max(2 * k + 2, max_v[k]);\n        }\n        if (min_v[2 * k + 2] < min_v[k])\n        {\n            update_node_min(2 * k + 2, min_v[k]);\n        }\n    }\n\n    void update(int k)\n    {\n        sum[k] = sum[2 * k + 1] + sum[2 * k + 2];\n\n        if (max_v[2 * k + 1] < max_v[2 * k + 2])\n        {\n            max_v[k] = max_v[2 * k + 2];\n            max_c[k] = max_c[2 * k + 2];\n            smax_v[k] = max(max_v[2 * k + 1], smax_v[2 * k + 2]);\n        }\n        else if (max_v[2 * k + 1] > max_v[2 * k + 2])\n        {\n            max_v[k] = max_v[2 * k + 1];\n            max_c[k] = max_c[2 * k + 1];\n            smax_v[k] = max(smax_v[2 * k + 1], max_v[2 * k + 2]);\n        }\n        else\n        {\n            max_v[k] = max_v[2 * k + 1];\n            max_c[k] = max_c[2 * k + 1] + max_c[2 * k + 2];\n            smax_v[k] = max(smax_v[2 * k + 1], smax_v[2 * k + 2]);\n        }\n\n        if (min_v[2 * k + 1] < min_v[2 * k + 2])\n        {\n            min_v[k] = min_v[2 * k + 1];\n            min_c[k] = min_c[2 * k + 1];\n            smin_v[k] = min(smin_v[2 * k + 1], min_v[2 * k + 2]);\n        }\n        else if (min_v[2 * k + 1] > min_v[2 * k + 2])\n        {\n            min_v[k] = min_v[2 * k + 2];\n            min_c[k] = min_c[2 * k + 2];\n            smin_v[k] = min(min_v[2 * k + 1], smin_v[2 * k + 2]);\n        }\n        else\n        {\n            min_v[k] = min_v[2 * k + 1];\n            min_c[k] = min_c[2 * k + 1] + min_c[2 * k + 2];\n            smin_v[k] = min(smin_v[2 * k + 1], smin_v[2 * k + 2]);\n        }\n    }\n\n    void _update_min(ll x, int a, int b, int k, int l, int r)\n    {\n        if (b <= l || r <= a || max_v[k] <= x)\n        {\n            return;\n        }\n        if (a <= l && r <= b && smax_v[k] < x)\n        {\n            update_node_max(k, x);\n            return;\n        }\n\n        push(k);\n        _update_min(x, a, b, 2 * k + 1, l, (l + r) / 2);\n        _update_min(x, a, b, 2 * k + 2, (l + r) / 2, r);\n        update(k);\n    }\n\n    void _update_max(ll x, int a, int b, int k, int l, int r)\n    {\n        if (b <= l || r <= a || x <= min_v[k])\n        {\n            return;\n        }\n        if (a <= l && r <= b && x < smin_v[k])\n        {\n            update_node_min(k, x);\n            return;\n        }\n\n        push(k);\n        _update_max(x, a, b, 2 * k + 1, l, (l + r) / 2);\n        _update_max(x, a, b, 2 * k + 2, (l + r) / 2, r);\n        update(k);\n    }\n\n    void addall(int k, ll x)\n    {\n        max_v[k] += x;\n        if (smax_v[k] != -inf)\n            smax_v[k] += x;\n        min_v[k] += x;\n        if (smin_v[k] != inf)\n            smin_v[k] += x;\n\n        sum[k] += len[k] * x;\n        if (lval[k] != inf)\n        {\n            lval[k] += x;\n        }\n        else\n        {\n            ladd[k] += x;\n        }\n    }\n\n    void updateall(int k, ll x)\n    {\n        max_v[k] = x;\n        smax_v[k] = -inf;\n        min_v[k] = x;\n        smin_v[k] = inf;\n        max_c[k] = min_c[k] = len[k];\n\n        sum[k] = x * len[k];\n        lval[k] = x;\n        ladd[k] = 0;\n    }\n\n    void _add_val(ll x, int a, int b, int k, int l, int r)\n    {\n        if (b <= l || r <= a)\n        {\n            return;\n        }\n        if (a <= l && r <= b)\n        {\n            addall(k, x);\n            return;\n        }\n\n        push(k);\n        _add_val(x, a, b, 2 * k + 1, l, (l + r) / 2);\n        _add_val(x, a, b, 2 * k + 2, (l + r) / 2, r);\n        update(k);\n    }\n\n    void _update_val(ll x, int a, int b, int k, int l, int r)\n    {\n        if (b <= l || r <= a)\n        {\n            return;\n        }\n        if (a <= l && r <= b)\n        {\n            updateall(k, x);\n            return;\n        }\n\n        push(k);\n        _update_val(x, a, b, 2 * k + 1, l, (l + r) / 2);\n        _update_val(x, a, b, 2 * k + 2, (l + r) / 2, r);\n        update(k);\n    }\n\n    ll _query_max(int a, int b, int k, int l, int r)\n    {\n        if (b <= l || r <= a)\n        {\n            return -inf;\n        }\n        if (a <= l && r <= b)\n        {\n            return max_v[k];\n        }\n        push(k);\n        ll lv = _query_max(a, b, 2 * k + 1, l, (l + r) / 2);\n        ll rv = _query_max(a, b, 2 * k + 2, (l + r) / 2, r);\n        return max(lv, rv);\n    }\n\n    ll _query_min(int a, int b, int k, int l, int r)\n    {\n        if (b <= l || r <= a)\n        {\n            return inf;\n        }\n        if (a <= l && r <= b)\n        {\n            return min_v[k];\n        }\n        push(k);\n        ll lv = _query_min(a, b, 2 * k + 1, l, (l + r) / 2);\n        ll rv = _query_min(a, b, 2 * k + 2, (l + r) / 2, r);\n        return min(lv, rv);\n    }\n\n    ll _query_sum(int a, int b, int k, int l, int r)\n    {\n        if (b <= l || r <= a)\n        {\n            return 0;\n        }\n        if (a <= l && r <= b)\n        {\n            return sum[k];\n        }\n        push(k);\n        ll lv = _query_sum(a, b, 2 * k + 1, l, (l + r) / 2);\n        ll rv = _query_sum(a, b, 2 * k + 2, (l + r) / 2, r);\n        return lv + rv;\n    }\n\npublic:\n    segment_tree(int n)\n    {\n        segment_tree(n, nullptr);\n    }\n\n    segment_tree(int n, ll *a) : n(n)\n    {\n        n0 = 1;\n        while (n0 < n)\n            n0 <<= 1;\n\n        for (int i = 0; i < 2 * n0; ++i)\n            ladd[i] = 0, lval[i] = inf;\n        len[0] = n0;\n        for (int i = 0; i < n0 - 1; ++i)\n            len[2 * i + 1] = len[2 * i + 2] = (len[i] >> 1);\n\n        for (int i = 0; i < n; ++i)\n        {\n            max_v[n0 - 1 + i] = min_v[n0 - 1 + i] = sum[n0 - 1 + i] = (a != nullptr ? a[i] : 0);\n            smax_v[n0 - 1 + i] = -inf;\n            smin_v[n0 - 1 + i] = inf;\n            max_c[n0 - 1 + i] = min_c[n0 - 1 + i] = 1;\n        }\n\n        for (int i = n; i < n0; ++i)\n        {\n            max_v[n0 - 1 + i] = smax_v[n0 - 1 + i] = -inf;\n            min_v[n0 - 1 + i] = smin_v[n0 - 1 + i] = inf;\n            max_c[n0 - 1 + i] = min_c[n0 - 1 + i] = 0;\n        }\n        for (int i = n0 - 2; i >= 0; i--)\n        {\n            update(i);\n        }\n    }\n\n    // range minimize query\n    void update_min(int a, int b, ll x)\n    {\n        _update_min(x, a, b, 0, 0, n0);\n    }\n\n    // range maximize query\n    void update_max(int a, int b, ll x)\n    {\n        _update_max(x, a, b, 0, 0, n0);\n    }\n\n    // range add query\n    void add_val(int a, int b, ll x)\n    {\n        _add_val(x, a, b, 0, 0, n0);\n    }\n\n    // range update query\n    void update_val(int a, int b, ll x)\n    {\n        _update_val(x, a, b, 0, 0, n0);\n    }\n\n    // range minimum query\n    ll query_max(int a, int b)\n    {\n        return _query_max(a, b, 0, 0, n0);\n    }\n\n    // range maximum query\n    ll query_min(int a, int b)\n    {\n        return _query_min(a, b, 0, 0, n0);\n    }\n\n    // range sum query\n    ll query_sum(int a, int b)\n    {\n        return _query_sum(a, b, 0, 0, n0);\n    }\n};\n/*\n・segment_tree tree(n,a):配列aを持つセグ木を宣言\n・tree.update_min(a,b,x):区間[a,b)のv[i]をmin(v[i],x)に更新\n・tree.update_max(a,b,x):区間[a,b)のv[i]をmax(v[i],x)に更新\n・tree.add_val(a,b,x):区間[a,b)のv[i]にxを加算\n・tree.update_val(a,b,x):区間[a,b)のv[i]をxに更新\n・tree.query_max(a,b):区間[a,b)の最大値を返す\n・tree.query_min(a,b):区間[a,b)の最小値を返す\n・tree.query_sum(a,b):区間[a,b)の総和を返す\n*/\n/*\n代入例\nll a[N];\nloop(i,N)a[i]=2147483647;\n*/\nint main()\n{\n    cout << fixed << setprecision(30);\n    ll n, q;\n    cin >> n >> q;\n    ll a[N];\n    loop(i, N) a[i] = 0;\n    segment_tree tree(n, a);\n    loop(i, q)\n    {\n        ll com, s, t;\n        cin >> com >> s >> t;\n        if (com == 0)\n        {\n            ll x;\n            cin >> x;\n            tree.update_val(s, t + 1, x);\n        }\n        else\n        {\n            putout(tree.query_sum(s, t + 1));\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <climits>\n#include <functional>\nusing namespace std;\n\n// 動的遅延セグメント木 (必要なところだけノードを作る)\n\ntemplate <typename MonoidType, typename OperatorType>\nstruct LazySegNode {\n    MonoidType value;\n    OperatorType lazy_value;\n    bool need_update;\n    LazySegNode *ch[2];\n    \n    LazySegNode() {}\n    LazySegNode(MonoidType value_, OperatorType lazy_value_) :\n        value(value_), lazy_value(lazy_value_) {\n        need_update = false;\n        ch[0] = ch[1] = nullptr;\n    }\n};\n\ntemplate <typename MonoidType, typename OperatorType, class SegFunc, typename IdxType = int>\nstruct DynamicLazySegmentTree {\n    // node, identity element\n    using LNode = LazySegNode<MonoidType, OperatorType>;\n    IdxType n;\n    LNode *root;\n    MonoidType E0;\n    OperatorType E1;\n\n    DynamicLazySegmentTree() {}\n    DynamicLazySegmentTree(IdxType n_, MonoidType E0_, OperatorType E1_) :\n        E0(E0_), E1(E1_) {\n        root = new LNode(E0_, E1_);\n        n = 1; while(n < n_) n *= 2;\n    }\n\n    void eval(LNode *node, IdxType l, IdxType r) {\n        if(!node->need_update) return;\n        node->value = SegFunc::update(node->value, SegFunc::accumulate(node->lazy_value, r - l));\n        if(r - l > 1) {\n            if(!node->ch[0]) node->ch[0] = new LNode(E0, E1);\n            if(!node->ch[1]) node->ch[1] = new LNode(E0, E1);\n            node->ch[0]->lazy_value = SegFunc::lazy_update(node->ch[0]->lazy_value, node->lazy_value);\n            node->ch[1]->lazy_value = SegFunc::lazy_update(node->ch[1]->lazy_value, node->lazy_value);\n            node->ch[0]->need_update = node->ch[1]->need_update = true;\n        }\n        node->lazy_value = E1;\n        node->need_update = false;\n    }\n\n    void update(LNode *node, IdxType a, IdxType b, OperatorType x,\n                IdxType l, IdxType r) {\n        eval(node, l, r);\n        if(b <= l or r <= a) return;\n        if(a <= l and r <= b) {\n            node->lazy_value = SegFunc::lazy_update(node->lazy_value, x);\n            node->need_update = true;\n            eval(node, l, r);\n        }\n        else {\n            IdxType mid = (l + r) / 2;\n\n            if(!(b <= l or mid <= a) or node->ch[0]) {\n                if(!node->ch[0]) node->ch[0] = new LNode(E0, E1);\n                update(node->ch[0], a, b, x, l, mid);\n            }\n            if(!(b <= mid or r <= a) or node->ch[1]) {\n                if(!node->ch[1]) node->ch[1] = new LNode(E0, E1);\n                update(node->ch[1], a, b, x, mid, r);\n            }\n            MonoidType vl = (node->ch[0] ? node->ch[0]->value : E0);\n            MonoidType vr = (node->ch[1] ? node->ch[1]->value : E0);\n            node->value = SegFunc::combine(vl, vr);\n        }\n    }\n\n    MonoidType query(LNode *node, IdxType a, IdxType b, IdxType l, IdxType r) {\n        if(b <= l or r <= a) return E0;\n        eval(node, l, r);\n        if(a <= l and r <= b) return node->value;\n        IdxType mid = (l + r) / 2;\n        MonoidType vl = (node->ch[0] ? query(node->ch[0], a, b, l, mid) : E0);\n        MonoidType vr = (node->ch[1] ? query(node->ch[1], a, b, mid, r) : E0);\n        return SegFunc::combine(vl, vr);\n    }\n\n    // update [a, b)-th element (applied value: x)\n    void update(IdxType a, IdxType b, OperatorType x) {\n        update(root, a, b, x, 0, n);\n    }\n\n    // range query for [a, b)\n    MonoidType query(IdxType a, IdxType b) {\n        return query(root, a, b, 0, n);\n    }\n};\n\n\n// Verified on Apr 27, 2019\nvoid DSL_2_D() {\n    struct SegFunc {\n        static int update(int a, int b) { return b; }\n        static int combine(int a, int b) { return min(a, b); }\n        static int lazy_update(int a, int b) { return b; }\n        static int accumulate(int a, int b) { return a; }\n    };\n    \n    int N, Q; cin >> N >> Q;\n    DynamicLazySegmentTree<int, int, SegFunc> seg(N, INT_MAX, INT_MAX);\n    \n    int indexed = 0;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s; cin >> s;\n            s -= indexed;\n            cout << seg.query(s, s+1) << endl;\n        }\n        // seg.dump();\n    }\n}\n\n// Verified on Apr 27, 2019\nvoid DSL_2_E() {\n    struct SegFunc {\n        static int update(int a, int b) { return a + b; }\n        static int combine(int a, int b) { return a + b; }\n        static int lazy_update(int a, int b) { return a + b; }\n        static int accumulate(int a, int x) { return a * x; }\n    };\n\n    int N, Q; cin >> N >> Q;\n    DynamicLazySegmentTree<int, int, SegFunc> seg(N, 0, 0);\n    \n    int indexed = 1;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s; cin >> s;\n            s -= indexed;\n            cout << seg.query(s, s+1) << endl;\n        }\n        // seg.dump();\n    }    \n}\n\n// Verified on Apr 27, 2019\nvoid DSL_2_F() {\n    struct SegFunc {\n        static int update(int a, int b) { return b; }\n        static int combine(int a, int b) { return min(a, b); }\n        static int lazy_update(int a, int b) { return b; }\n        static int accumulate(int a, int x) { return a; }\n    };\n    \n    int N, Q; cin >> N >> Q;\n    DynamicLazySegmentTree<int, int, SegFunc> seg(N, INT_MAX, 0);\n    \n    int indexed = 0;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s, t; cin >> s >> t; t++;\n            s -= indexed; t -= indexed;\n            cout << seg.query(s, t) << endl;\n        }\n\n        /*\n        for(int k=0; k<N; k++) {\n            int l = k, r = l + 1;\n            fprintf(stderr, \"seg[%d] = %d\\n\", k, seg.query(l, r));\n        }\n        */\n        // seg.dump();\n    }    \n}\n\n// Verified on Apr 27, 2019\nvoid DSL_2_G() {\n    using ll = long long int;\n    struct SegFunc {\n        static ll update(ll a, ll b) { return a + b; }\n        static ll combine(ll a, ll b) { return a + b; }\n        static ll lazy_update(ll a, ll b) { return a + b; }\n        static ll accumulate(ll a, ll x) { return a * x; }\n    };\n\n    int N, Q; cin >> N >> Q;\n    DynamicLazySegmentTree<ll, ll, SegFunc> seg(N, 0, 0);\n    \n    int indexed = 1;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s, t; cin >> s >> t; t++;\n            s -= indexed; t -= indexed;\n            cout << seg.query(s, t) << endl;\n        }\n        // seg.dump();\n    }    \n}\n\n\n// Verified on May 28, 2019\nvoid DSL_2_H() {\n    int N, Q; cin >> N >> Q;\n    using ll = long long int;\n    using Pair = pair<ll, ll>;\n\n    struct SegFunc {\n        static ll update(ll a, Pair b) {\n            return a * b.first + b.second;\n        }\n        static ll combine(ll a, ll b) { return min(a, b); }\n        static Pair lazy_update(Pair a, Pair b) {\n            return make_pair(a.first * b.first, b.first * a.second + b.second);\n        }\n        static Pair accumulate(Pair a, int x) { return a; }\n    };\n    \n    DynamicLazySegmentTree<ll, Pair, SegFunc> seg(N, INT_MAX, make_pair(1, 0));\n    \n    int indexed = 0;\n    for(int i=0; i<N; i++) {\n        seg.update(i, i+1, make_pair(0, 0));\n    }\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, make_pair(1, x));\n        }\n        if(query_type == 1) {\n            int s, t; cin >> s >> t; t++;\n            s -= indexed; t -= indexed;\n            cout << seg.query(s, t) << endl;\n        }\n        // seg.dump();\n    }    \n}\n\n// Verified on May 28, 2019\nvoid DSL_2_I() {\n    int N, Q; cin >> N >> Q;\n    using ll = long long int;\n    struct SegFunc {\n        static ll update(ll a, ll b) { return b; }\n        static ll combine(ll a, ll b) { return a + b; }\n        static ll lazy_update(ll a, ll b) { return b; }\n        static ll accumulate(ll a, int x) { return a * x; }\n    };\n    DynamicLazySegmentTree<ll, ll, SegFunc> seg(N, 0, 0);\n    int indexed = 0;\n    for(int i=0; i<Q; i++) {\n        int query_type; cin >> query_type;\n        if(query_type == 0) {\n            int s, t, x; cin >> s >> t >> x; t++;\n            s -= indexed, t -= indexed;\n            seg.update(s, t, x);\n        }\n        if(query_type == 1) {\n            int s, t; cin >> s >> t; t++;\n            s -= indexed; t -= indexed;\n            cout << seg.query(s, t) << endl;\n        }\n        // seg.dump();\n    }    \n}\n\n/*\n// TLE\nvoid ABC128_E() {\n    const int RANGE = 1 << 30;\n    int N, Q; cin >> N >> Q;\n\n    DynamicLazySegmentTree<int, int> seg(RANGE, INT_MAX, INT_MAX,\n                                         [](int a, int b) { return min(a, b); },\n                                         [](int a, int b) { return min(a, b); },\n                                         [](int a, int b) { return min(a, b); },\n                                         [](int a, int b) { return a; });\n\n    for(int i=0; i<N; i++) {\n        int s, t, x; cin >> s >> t >> x;\n        s = max(0, s-x), t = max(0, t-x);\n        seg.update(s, t, x);\n    }\n    for(int i=0; i<Q; i++) {\n        int x; cin >> x;\n        int res = seg.query(x, x+1);\n        if(res == INT_MAX) cout << -1 << endl;\n        else cout << res << endl;\n    }\n}\n*/\n\nint main() {\n    // DSL_2_D();\n    // DSL_2_E();\n    // DSL_2_F();\n    // DSL_2_G();\n    // DSL_2_H();\n    DSL_2_I();\n    // ABC128_E();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\ntemplate<typename T, typename E> struct LazySegmentTree;\n\ntemplate<typename T, typename E> struct QueryObject {\n  LazySegmentTree<T, E> *lst;\n  int a, b;\n  E x;\n  int k;\n  int l, r;\n  QueryObject(LazySegmentTree<T, E> *lst,\n      int a, int b, E x = 0, int k = 0, int l = 0, int r = -1)\n      : lst(lst), a(a), b(b), x(x), k(k), l(l), r(r) {}\n};\n\ntemplate<typename T, typename E> struct QueryType {\n  virtual int outOfRange(QueryObject<T, E> o) = 0;\n  virtual int cover(QueryObject<T, E> o) = 0;\n  virtual int join(QueryObject<T, E> o, T vl, T vr) = 0;\n  T query(QueryObject<T, E> o) {\n    if (o.r < 0) o.r = o.lst->n;\n    o.lst->eval(o.r - o.l, o.k);\n    if (o.b <= o.l || o.r <= o.a) return outOfRange(o);\n    if (o.a <= o.l && o.r <= o.b) return cover(o);\n    QueryObject<T, E> o1 = o, o2 = o;\n    o1.k = o.k * 2 + 1; o1.r = (o.l + o.r) / 2;\n    o2.k = o.k * 2 + 2; o2.l = (o.l + o.r) / 2;\n    T vl = query(o1);\n    T vr = query(o2);\n    return join(o, vl, vr);\n  }\n};\n\ntemplate<typename T, typename E> struct Setter : QueryType<T, E> {\n  enum setter { RUQ, RAQ };\n  int outOfRange(QueryObject<T, E> o) {\n    return o.lst->data[o.k];\n  }\n  int cover(QueryObject<T, E> o) {\n    o.lst->lazy[o.k] = o.lst->h(o.lst->lazy[o.k], o.x);\n    o.lst->eval(o.r - o.l, o.k);\n    return o.lst->data[o.k];\n  }\n  int join(QueryObject<T, E> o, T vl, T vr) {\n    return o.lst->data[o.k] = o.lst->f(vl, vr);\n  }\n};\n\ntemplate<typename T, typename E> struct Getter : QueryType<T, E> {\n  enum getter { RMQ, RSQ };\n  int outOfRange(QueryObject<T, E> o) {\n    return o.lst->initT;\n  }\n  int cover(QueryObject<T, E> o) {\n    return o.lst->data[o.k];\n  }\n  int join(QueryObject<T, E> o, T vl, T vr) {\n    return o.lst->f(vl, vr);\n  }\n};\n\ntemplate<typename T, typename E> struct LazySegmentTree {\n  using F = function<T(T, T)>;\n  using G = function<T(T, E)>;\n  using H = function<E(E, E)>;\n  using P = function<E(E, int)>;\n  F add() {\n    return [&](const T& x, const T& y) -> const T { return x + y; };\n  }\n  F minimum() {\n    return [&](const T& x, const T& y) -> const T { return min(x, y); };\n  }\n  G ex_assign(E initE) {\n    return [&initE](const T& x, const E& y) -> const T { return (y == initE) ? x : y; };\n  }\n  P ex_multiplies(E initE) {\n    return [&initE](const E& x, int y) -> const E { return (x == initE) ? x : x * y; };\n  }\n\n  int n;\n  T initT;\n  E initE;\n  F f;\n  G g;\n  H h;\n  P p;\n  vector<T> data;\n  vector<E> lazy;\n  QueryType<T, E> *type;\n\n  LazySegmentTree() {}\n  LazySegmentTree(QueryType<T, E> *type_) { type = type_; }\n  LazySegmentTree(int n_, int setter, int getter,\n      T initT_ = INT_MAX, E initE_ = INT_MAX, vector<T> v = vector<T>()) {\n    setQuery(setter, getter, initT_, initE_);\n    n = 1;\n    while (n < n_) n *= 2;\n    data.assign(n * 2 - 1, initT);\n    lazy.assign(n * 2 - 1, initE);\n    if (n_ == v.size()) build(v);\n  }\n  void build(vector<T> v) {\n    for (int i = 0; i < v.size(); ++i) data[i + n - 1] = v[i];\n    for (int i = n - 2; i >= 0; --i) {\n      data[i] = f(data[i * 2 + 1], data[i * 2 + 2]);\n    }\n  }\n  void setQuery(int setter, int getter, T initT_, E initE_) {\n    initT = vector<T>{initT_, 0}[getter];\n    initE = vector<E>{initE_, 0}[setter];\n    f = vector<F>{minimum(), add()}[getter];\n    g = vector<G>{ex_assign(initE), add()}[setter];\n    h = vector<H>{ex_assign(initE), add()}[setter];\n    p = ex_multiplies(initE);\n  }\n  inline void eval(int len, int k) {\n    if (lazy[k] == initE) return;\n    if (k * 2 + 1 < n * 2 - 1) {\n      lazy[k * 2 + 1] = h(lazy[k * 2 + 1], lazy[k]);\n      lazy[k * 2 + 2] = h(lazy[k * 2 + 2], lazy[k]);\n    }\n    data[k] = g(data[k], p(lazy[k], len));\n    lazy[k] = initE;\n  }\n  T query(QueryObject<T, E> obj) {\n    return type->query(obj);\n  }\n  T setData(int a, int b, E x) {\n    LazySegmentTree<T, E> lst(new Setter<T, E>());\n    QueryObject<T, E> obj(this, a, b, x);\n    return lst.query(obj);\n  }\n  T getData(int a, int b) {\n    LazySegmentTree<T, E> lst(new Getter<T, E>());\n    QueryObject<T, E> obj(this, a, b);\n    return lst.query(obj);\n  }\n};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, q; cin >> n >> q;\n  LazySegmentTree<ll, ll> seg(n, Setter<ll, ll>::RUQ, Getter<ll, ll>::RSQ);\n\n  while (q--) {\n    int com; cin >> com;\n    if (com) {\n      int s, t; cin >> s >> t;\n      cout << seg.getData(s, t + 1) << endl;\n    } else {\n      int s, t, x; cin >> s >> t >> x;\n      seg.setData(s, t + 1, x);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<vector>\n#include<functional>\ntemplate<typename T>\nstruct lazysegtree{\n\tfunction<T(T,T)>calcfn,lazycalcfn;\n\tfunction<T(T,T,unsigned int)>updatefn;\n\tint n;\n\tT defvalue,lazydefvalue;\n\tvector<T>dat,lazy;\n\tvector<bool>lazyflag;\n\tlazysegtree(int n_=0,T defvalue_=0,\n\t\tfunction<T(T,T)>calcfn_=[](T a,T b){return a+b;},\n\t\tfunction<T(T,T)>lazycalcfn_=[](T a,T b){return a+b;},\n\t\tfunction<T(T,T,unsigned int)>updatefn_=[](T a,T b,unsigned int width){return a+b*width;},\n\t\tT lazydefvalue_=0\n\t):defvalue(defvalue_),lazydefvalue(lazydefvalue_),\n\t\tcalcfn(calcfn_),lazycalcfn(lazycalcfn_),updatefn(updatefn_)\n\t{\n\t\tn=1;\n\t\twhile(n<n_)n<<=1;\n\t\tdat.assign(2*n-1,defvalue);\n\t\tlazy.assign(2*n-1,lazydefvalue);\n\t\tlazyflag.assign(2*n-1,false);\n\t}\n\tvoid copy(vector<T>v)\n\t{\n\t\tfor(int i=0;i<v.size();i++)dat[i+n-1]=v[i];\n\t\tfor(int i=n-2;i>=0;i--)dat[i]=calcfn(dat[2*i+1],dat[2*i+2]);\n\t}\n\tvoid eval(int i,int l,int r)\n\t{\n\t\tif(lazyflag[i])\n\t\t{\n\t\t\tdat[i]=updatefn(dat[i],lazy[i],r-l);\n\t\t\tif(r-l>1)\n\t\t\t{\n\t\t\t\tlazy[2*i+1]=lazycalcfn(lazy[2*i+1],lazy[i]);\n\t\t\t\tlazy[2*i+2]=lazycalcfn(lazy[2*i+2],lazy[i]);\n\t\t\t\tlazyflag[2*i+1]=lazyflag[2*i+2]=true;\n\t\t\t}\n\t\t\tlazy[i]=lazydefvalue;\n\t\t\tlazyflag[i]=false;\n\t\t}\n\t}\n\tvoid update(int a,int b,T x,int k=0,int l=0,int r=-1)\n\t{\n\t\tif(r<0)r=n;\n\t\teval(k,l,r);\n\t\tif(b<=l||r<=a)return;\n\t\telse if(a<=l&&r<=b)\n\t\t{\n\t\t\tlazy[k]=lazycalcfn(lazy[k],x);\n\t\t\tlazyflag[k]=true;\n\t\t\teval(k,l,r);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tupdate(a,b,x,2*k+1,l,(l+r)/2);\n\t\t\tupdate(a,b,x,2*k+2,(l+r)/2,r);\n\t\t\tdat[k]=calcfn(dat[2*k+1],dat[2*k+2]);\n\t\t}\n\t}\n\tT query(int a,int b,int k=0,int l=0,int r=-1)\n\t{\n\t\tif(r<0)r=n;\n\t\teval(k,l,r);\n\t\tif(b<=l||r<=a)return defvalue;\n\t\telse if(a<=l&&r<=b)return dat[k];\n\t\telse return calcfn(\n\t\t\tquery(a,b,2*k+1,l,(l+r)/2),\n\t\t\tquery(a,b,2*k+2,(l+r)/2,r)\n\t\t);\n\t}\n};\nint n,q;\nmain()\n{\n\tcin>>n>>q;\n\tlazysegtree<int>P(n,0,[](int a,int b){return a+b;},[](int a,int b){return b;},[](int a,int b,int width){return b*width;});\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tint c;cin>>c;\n\t\tif(c)\n\t\t{\n\t\t\tint s,t;cin>>s>>t;\n\t\t\tcout<<P.query(s,t+1)<<endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint s,t,x;cin>>s>>t>>x;\n\t\t\tP.update(s,t+1,x);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef LOCAL_DEBUG\n  #include \"LOCAL_DEBUG.hpp\"\n#endif\n#define int long long\nconst int INF = 1LL << 60;\n\ntemplate <class M, class OM = M>\nstruct DelaySegmentTree{\n  using FX = function<M(M, M)>;\n  using FA = function<M(M, OM)>;\n  using FM = function<OM(OM, OM)>;\n  using FP = function<M(M, int)>;\n  FX fx;\n  FA fa;\n  FM fm;\n  FP fp;\n  int n;\n  M ex;\n  OM em;\n  vector<M> data;\n  vector<OM> delay;\n\n  DelaySegmentTree(int sz, FX fx, FA fa, FM fm, FP fp, M ex, OM em) \n  : fx(fx), fa(fa), fm(fm), fp(fp), ex(ex), em(em), data(sz*4, ex), delay(sz*4, em){\n    n = 1; while(n < sz) n *= 2;\n  }\n\n  void set(int k, M x){ data[k+n-1] = x; }\n  void build(){\n    for(int k = n-2; k >= 0; k--){\n      data[k] = fx(data[2*k+1], data[2*k+2]);\n    }\n  }\n\n  void eval(int k, int len){\n    if(delay[k] == em) return;\n    if(k < n-1){\n      delay[2*k+1] = fm(delay[2*k+1], delay[k]);\n      delay[2*k+2] = fm(delay[2*k+2], delay[k]);\n    }\n    data[k] = fa(data[k], fp(delay[k], len));\n    delay[k] = em;\n  }\n\n  void update(int a, int b, OM x){ update(a, b, x, 0, 0, n); }\n  void update(int a, int b, OM x, int k, int l, int r){\n    eval(k, r - l);\n    if(b <= l || r <= a) return;\n    if(a <= l && r <= b){\n      delay[k] = fm(delay[k], x);\n      eval(k, r - l);\n    }else{\n      update(a, b, x, 2*k+1, l, (l+r)/2);\n      update(a, b, x, 2*k+2, (l+r)/2, r);\n      data[k] = fx(data[2*k+1], data[2*k+2]);\n    }\n  }\n\n  M getval(int a, int b){ return getval(a, b, 0, 0, n); }\n  M getval(int a, int b, int k, int l, int r){\n    eval(k, r - l);\n    if(b <= l || r <= a) return ex;\n    if(a <= l && r <= b) return data[k];\n    M vl = getval(a, b, 2*k+1, l, (l+r)/2);\n    M vr = getval(a, b, 2*k+2, (l+r)/2, r);\n    return fx(vl, vr);\n  }\n\n  void print(int n){\n    cout << \"[\";\n    for(int i = 0; i < n; i++){\n      cout << getval(i, i+1) << \", \";\n    }\n    cout << \"]\" << endl;\n  }\n};\n\n\nsigned main(){\n\n  int n, q; cin >> n >> q;\n  auto fx = [](int a, int b){ return a + b; };\n  auto fa = [](int a, int b){ return b; };\n  auto fm = [](int a, int b){ return b; };\n  auto fp = [](int a, int b){ return a * b; };\n  DelaySegmentTree<int> seg(n, fx, fa, fm, fp, 0, -INF);\n\n  for(int i = 0; i < q; i++){\n    int qt; cin >> qt;\n    if(qt == 0){\n      int s, t, x; cin >> s >> t >> x;\n      seg.update(s, t+1, x);\n    }else{\n      int s, t; cin >> s >> t;\n      cout << seg.getval(s, t+1) << endl;\n    }\n    //seg.print(n);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n    out<<'['; for(T i: a) {out<<i<<',';} out<<']'; return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\ntemplate<class T, class E=T>\nstruct RBST {\n    using F = function<T(T,T)>;\n    using G = function<T(T,E)>;\n    using H = function<E(E,E)>;\n    using P = function<E(E,int)>;\n\n    const F f; const G g; const H h; const P p;\n    const T dt; const E de;\n\n    struct node {\n        node *l, *r;\n        T val, sum;\n        E lazy;\n        bool rev;\n        int sz;\n\n        node(T v, E p) : l(nullptr),r(nullptr),val(v),sum(v),lazy(p),rev(false),sz(1) {}\n    };\n\n    RBST(F f, T dt) :\n        f(f), g(G()), h(H()), p(P()), dt(dt), de(E()) {}\n    RBST(F f, G g, H h, P p, T dt, E de) :\n        f(f), g(g), h(h), p(p), dt(dt), de(de) {}\n\n    // 子を操作したあとに呼ぶ\n    node* fix(node* a) {\n        a->sz = size(a->l) + 1 + size(a->r);\n        a->sum = f(f(sum(a->l), a->val), sum(a->r));\n        return a;\n    }\n    // valとsumを操作したあとに呼ぶ\n    void eval(node* a) {\n        if(a->lazy != de) {\n            a->val = g(a->val, a->lazy);\n            a->sum = g(a->sum, p(a->lazy, a->sz));\n            if(a->l != nullptr) a->l->lazy = h(a->l->lazy, a->lazy);\n            if(a->r != nullptr) a->r->lazy = h(a->r->lazy, a->lazy);\n            a->lazy = de;\n        }\n        if(a->rev) {\n            std::swap(a->l, a->r);\n            if(a->l != nullptr) a->l->rev ^= 1;\n            if(a->r != nullptr) a->r->rev ^= 1;\n            a->rev = false;\n        }\n    }\n    T sum(node* a) { return a == nullptr ? dt : (eval(a), a->sum); }\n    int size(node* a) { return a == nullptr ? 0 : a->sz; }\n\n    inline int xor128() {\n        static int x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n        int t;\n        t = x ^ (x << 11); x = y; y = z; z = w;\n        return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n    }\n\n    node* merge(node* a, node* b) {\n        if(a == nullptr) return b;\n        if(b == nullptr) return a;\n        eval(a); eval(b);\n        if(xor128() % (size(a) + size(b)) < size(a)) {\n            a->r = merge(a->r, b);\n            return fix(a);\n        } else {\n            b->l = merge(a, b->l);\n            return fix(b);\n        }\n    }\n    // [0,k) [k,n)\n    pair<node*, node*> split(node* a, int k) {\n        if(a == nullptr) return pair<node*, node*>(nullptr, nullptr);\n        eval(a);\n        node *sl, *sr;\n        if(k <= size(a->l)) {\n            std::tie(sl, sr) = split(a->l, k);\n            a->l = sr;\n            return pair<node*, node*>(sl, fix(a));\n        } else {\n            std::tie(sl, sr) = split(a->r, k - size(a->l) - 1);\n            a->r = sl;\n            return pair<node*, node*>(fix(a), sr);\n        }\n    }\n    // 要素の挿入/削除\n    void insert(node*& a, int k, const T& x) {\n        node *sl, *sr;\n        std::tie(sl, sr) = split(a, k);\n        a = merge(sl, merge(new node(x, de), sr));\n    }\n    T erase(node*& a, int k) {\n        node *sl, *sr, *tl, *tr;\n        std::tie(sl, sr) = split(a, k + 1);\n        std::tie(tl, tr) = split(sl, k);\n        a = merge(tl, sr);\n        return tr->val;\n    }\n    // 点代入\n    void set_element(node*& a, int k, const T& x) {\n        node *sl, *sr, *tl, *tr;\n        std::tie(sl, sr) = split(a, k + 1);\n        std::tie(tl, tr) = split(sl, k);\n        if(tr != nullptr) tr->val = tr->sum = x;\n        a = merge(merge(tl, tr), sr);\n    }\n    // 区間更新\n    void update(node*& a, int l, int r, const E& m) {\n        node *sl, *sr, *tl, *tr;\n        std::tie(sl, sr) = split(a, r);\n        std::tie(tl, tr) = split(sl, l);\n        if(tr != nullptr) tr->lazy = h(tr->lazy, m);\n        a = merge(merge(tl, tr), sr);\n    }\n    // 点取得\n    T get(node*& a, int k) {\n        node *sl, *sr, *tl, *tr;\n        std::tie(sl, sr) = split(a, k + 1);\n        std::tie(tl, tr) = split(sl, k);\n        T res = tr == nullptr ? dt : tr->val;\n        a = merge(merge(tl, tr), sr);\n        return res;\n    }\n    // 区間クエリ\n    T query(node*& a, int l, int r) {\n        node *sl, *sr, *tl, *tr;\n        std::tie(sl, sr) = split(a, r);\n        std::tie(tl, tr) = split(sl, l);\n        T res = tr == nullptr ? dt : tr->sum;\n        a = merge(merge(tl, tr), sr);\n        return res;\n    }\n    // 区間[l,r)の反転\n    void reverse(node*& a, int l, int r) {\n        node *sl, *sr, *tl, *tr;\n        std::tie(sl, sr) = split(a, r);\n        std::tie(tl, tr) = split(sl, l);\n        if(tr != nullptr) tr->rev ^= 1;\n        a = merge(merge(tl, tr), sr);\n    }\n    // デバッグ用\n    void debug(node* t) {\n        if(t == nullptr) return;\n        cout << \"{\";\n        debug(t->l);\n        cout << \" \" << t->val << \" \";\n        debug(t->r);\n        cout << \"}\";\n    }\n    void dump(node *r, typename vector< T >::iterator &it) {\n        if(!r) return;\n        eval(r);\n        dump(r->l, it);\n        *it = r->val;\n        dump(r->r, ++it);\n    }\n    vector<T> dump(node *r) {\n        vector<T> v((size_t) size(r));\n        auto it = begin(v);\n        dump(r, it);\n        return v;\n    }\n};\n\ntemplate<class T>\nstruct OrderedMultiSet : RBST<T> {\n    using node = typename RBST<T>::node;\n\n    OrderedMultiSet() : RBST<T>([&](T x, T y) { return x; }, T()) {}\n\n    // k番目の要素を求める\n    T kth_element(node *t, int k) {\n        if(k < RBST<T>::size(t->l)) return kth_element(t->l, k);\n        if(k == RBST<T>::size(t->l)) return t->val;\n        return kth_element(t->r, k - RBST<T>::size(t->l) - 1);\n    }\n    // 要素xを追加する\n    virtual void insert_key(node *&t, const T &x) {\n        RBST<T>::insert(t, lower_bound(t, x), x);\n    }\n    // 要素xを消す\n    void erase_key(node *&t, const T &x) {\n        if(!count(t, x)) return;\n        RBST<T>::erase(t, lower_bound(t, x));\n    }\n    // xの個数\n    int count(node *t, const T &x) {\n        return upper_bound(t, x) - lower_bound(t, x);\n    }\n    // x以上の最小の位置\n    int lower_bound(node *t, const T &x) {\n        if(!t) return 0;\n        if(x <= t->val) return lower_bound(t->l, x);\n        return lower_bound(t->r, x) + RBST<T>::size(t->l) + 1;\n    }\n    // xより大きい最小の位置\n    int upper_bound(node *t, const T &x) {\n        if(!t) return 0;\n        if(x < t->val) return upper_bound(t->l, x);\n        return upper_bound(t->r, x) + RBST<T>::size(t->l) + 1;\n    }\n};\ntemplate<class T>\nstruct OrderedSet : OrderedMultiSet<T>  {\n    using SET = OrderedMultiSet<T>;\n    using RBST = typename SET::RBST;\n    using node = typename RBST::node;\n\n    OrderedSet(int sz) : OrderedMultiSet<T>(sz) {}\n\n    void insert_key(node *&t, const T &x) override {\n        if(SET::count(t, x)) return;\n        RBST::insert(t, SET::lower_bound(t, x), x);\n    }\n};\n\n// k-th element\nnamespace ARC033C {\n    void solve() {\n        ll q;\n        cin >> q;\n        OrderedMultiSet<ll> st;\n        OrderedMultiSet<ll>::RBST::node *root = nullptr;\n        while(q--) {\n            ll t, x;\n            cin >> t >> x;\n            if(t == 1) {\n                st.insert_key(root, x);\n            } else {\n                ll val = st.kth_element(root, x-1);\n                cout << val << endl;\n                st.erase_key(root, val);\n            }\n        }\n    }\n}\n\n// 点更新区間最小\nnamespace DSL2A {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        auto f = [](ll l, ll r) { return min(l, r); };\n        RBST<ll> tree(f, INT_MAX);\n\n        RBST<ll,ll>::node* root = nullptr;\n        for(int i = 0; i < n; i++) tree.insert(root, i, INT_MAX);\n        while(q--) {\n            int c, x, y;\n            cin >> c >> x >> y;\n            if(c == 0) {\n                tree.set_element(root, x, y);\n            } else {\n                cout << tree.query(root, x, y+1) << endl;\n            }\n        }\n    }\n}\n\n// 点加算区間和\nnamespace DSL2B {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        auto f = [](ll l, ll r) { return l+r; };\n        RBST<ll> tree(f, 0);\n\n        RBST<ll,ll>::node* root = nullptr;\n        for(int i = 0; i < n; i++) tree.insert(root, i, 0);\n        while(q--) {\n            int c, x, y;\n            cin >> c >> x >> y;\n            if(c == 0) {\n                x--;\n                tree.set_element(root, x, tree.get(root, x) + y);\n            } else {\n                x--, y--;\n                cout << tree.query(root, x, y+1) << endl;\n            }\n        }\n    }\n}\n\n// 区間更新区間最小\nnamespace DSL2F {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        auto f = [](ll l, ll r) { return min(l, r); };\n        auto g = [](ll l, ll r) { return r; };\n        auto p = [](ll l, int r) { return l; };\n        RBST<ll,ll> tree(f, g, g, p, INT_MAX, INT_MAX);\n\n        RBST<ll,ll>::node* root = nullptr;\n        for(int i = 0; i < n; i++) tree.insert(root, i, INT_MAX);\n        while(q--) {\n            int c, s, t;\n            cin >> c >> s >> t;\n            if(c == 0) {\n                int x;\n                cin >> x;\n                tree.update(root, s, t + 1, x);\n            } else {\n                cout << tree.query(root, s, t + 1) << endl;\n            }\n        }\n    }\n}\n\n// 区間加算区間和\nnamespace DSL2G {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        auto f = [](ll l, ll r) { return l+r; };\n        auto p = [](ll l, int r) { return l*r; };\n        RBST<ll,ll> tree(f, f, f, p, 0, 0);\n\n        RBST<ll,ll>::node* root = nullptr;\n        for(int i = 0; i < n; i++) tree.insert(root, i, 0);\n        while(q--) {\n            int c, s, t;\n            cin >> c >> s >> t;\n            s--, t--;\n            if(c == 0) {\n                int x;\n                cin >> x;\n                tree.update(root, s, t + 1, x);\n            } else {\n                cout << tree.query(root, s, t + 1) << endl;\n            }\n        }\n    }\n}\n\n// 区間加算区間最小\nnamespace DSL2H {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        auto f = [](ll l, ll r) { return min(l, r); };\n        auto g = [](ll l, ll r) { return l+r; };\n        auto p = [](ll l, int r) { return l; };\n        RBST<ll,ll> tree(f, g, g, p, INT_MAX, 0);\n\n        RBST<ll,ll>::node* root = nullptr;\n        for(int i = 0; i < n; i++) tree.insert(root, i, 0);\n        while(q--) {\n            int c, s, t;\n            cin >> c >> s >> t;\n            if(c == 0) {\n                int x;\n                cin >> x;\n                tree.update(root, s, t+1, x);\n            } else {\n                cout << tree.query(root, s, t+1) << endl;\n            }\n        }\n    }\n}\n\n// 区間更新区間和\nnamespace DSL2I {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        auto f = [](ll l, ll r) { return l+r; };\n        auto g = [](ll l, ll r) { return r==INT_MAX?l:r; };\n        auto p = [](ll l, int r) { return l*r; };\n        RBST<ll,ll> tree(f, g, g, p, 0, INT_MAX);\n\n        RBST<ll,ll>::node* root = nullptr;\n        for(int i = 0; i < n; i++) tree.insert(root, i, 0);\n        while(q--) {\n            int c, s, t;\n            cin >> c >> s >> t;\n            if(c == 0) {\n                int x;\n                cin >> x;\n                tree.update(root, s, t+1, x);\n            } else {\n                cout << tree.query(root, s, t+1) << endl;\n            }\n            // cout << tree.dump(root) << endl;\n        }\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    // ARC033C::solve();\n    // DSL2A::solve();\n    // DSL2B::solve();\n    // DSL2F::solve();\n    // DSL2G::solve();\n    // DSL2H::solve();\n    DSL2I::solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass segment_tree{\n    vector<int64_t> val;\n    vector<pair<int64_t, int64_t>> op;\n    vector<pair<size_t, size_t>> range;\n\n    pair<int64_t, int64_t> ident = {1, 0};\n    size_t N, depth;\n\n    inline void merge(size_t target, int64_t &alpha, int64_t &beta){\n        op[target] = {op[target].first * alpha, op[target].second * alpha + beta};\n    }\n    inline void propagate(size_t target){\n        // min, max -> width = 1\n        if(op[target] == ident) return;\n        val[target] = op[target].first * val[target] + op[target].second * (range[target].second - range[target].first);\n        if(target  < N){\n            merge(2*target, op[target].first, op[target].second);\n            merge(2*target+1, op[target].first, op[target].second);\n        }\n        op[target] = {1, 0};\n    }\n    \n    inline void eval(int n){\n        stack<size_t> stk;\n        for(;n>0;n>>=1) stk.push(n);\n        while(!stk.empty()){\n            propagate(stk.top());\n            stk.pop();\n        }\n    }\n    inline void get_target(vector<size_t> &target, size_t left, size_t right, stack<size_t> *refresh=nullptr){\n        queue<size_t> partial;\n        \n        if(left <= 0 && right >= N) target.push_back(1);\n        else partial.push(1);\n\n        while(!partial.empty()){\n            size_t i = partial.front();\n            if(refresh != nullptr) refresh->push(i);\n            partial.pop();\n\n            propagate(i);\n\n            if(left <= range[i].first){\n                if(right < range[i*2].second) partial.push(i*2);\n                else{\n                    target.push_back(i*2);\n                    if(range[i*2+1].first < right) partial.push(i*2+1);\n                }\n            }else{\n                if(left < range[i*2].second){\n                    partial.push(i*2);\n                    if(range[i*2+1].second <= right) target.push_back(i*2+1);\n                    else if(range[i*2].second < right) partial.push(i*2+1); \n                }else{\n                    if(left <= range[i*2+1].first && range[i*2+1].second <= right) target.push_back(i*2+1);\n                    else partial.push(i*2+1);\n                }\n            }\n        }\n    }\npublic:\n    segment_tree(size_t n){\n        for(depth=0;(1ULL<<depth)<n;depth++);\n        N = 1ULL<<depth;\n        val.reserve(1ULL<<(++depth));\n        op.reserve(1ULL<<depth);\n        range.reserve(1ULL<<depth);\n        for(size_t i=2*N-1;i>0;i--){\n            op[i] = ident;\n            if(i>=N) range[i] = {i-N, i-N+1};\n            else range[i] = {range[2*i].first, range[2*i+1].second};\n        }\n    }\n    int64_t operator[](size_t i){\n        eval(N+i);\n        return val[N+i];\n    }\n    void operate(int64_t alpha, int64_t beta, size_t left, size_t right){\n        if(right <= left) return;\n\n        vector<size_t> target;\n        stack<size_t> refresh;\n        get_target(target, left, right, &refresh);\n        for(auto i : target){\n            merge(i, alpha, beta);\n            propagate(i);\n        }\n        while(!refresh.empty()){\n            size_t i = refresh.top();\n            refresh.pop();\n            //min, max -> change\n            propagate(i*2);\n            propagate(i*2+1);\n            val[i] = val[i*2] + val[i*2+1];\n        }\n    }\n    int64_t get_sum(size_t left, size_t right){\n        if(right <= left) return 0;\n        \n        vector<size_t> target;\n        get_target(target, left, right);\n        int64_t ret = 0;\n        for(auto i : target){\n            ret += op[i].first * val[i] + op[i].second * (range[i].second - range[i].first);\n        }\n        return ret;\n    }\n    void update(int64_t val, size_t pos){\n        operate(0, val, pos, pos+1);\n    }\n    void update(int64_t val, size_t left, size_t right){\n        operate(0, val, left, right);\n    }\n    void add(int64_t val, size_t pos){\n        operate(1, val, pos, pos+1);\n    }\n    void add(int64_t val, size_t left, size_t right){\n        operate(1, val, left, right);\n    }\n\n    void dump(){\n        for(int i=1;i<2*N;i++){\n            eval(i);\n            cerr << val[i] << \" \";\n        }\n        cerr << endl;\n    }\n};\n\nint main(){\n    int n, q;\n    cin >> n >> q;\n    segment_tree st(n);\n\n    for(int i=0;i<q;i++){\n        int com;\n        cin >> com;\n        if(com == 0){\n            int s, t, x;\n            cin >> s >> t >> x;\n            st.update(x, s, t+1);\n        }else{\n            int s, t;\n            cin >> s >> t;\n            cout << st.get_sum(s, t+1) << endl;\n        }\n        //st.dump();\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\ntemplate<typename T, typename E> struct LazySegmentTree;\n\ntemplate<typename T, typename E> struct QueryObject {\n  LazySegmentTree<T, E> *lst;\n  int a, b;\n  E x;\n  int k;\n  int l, r;\n  QueryObject(LazySegmentTree<T, E> *lst,\n      int a, int b, E x = 0, int k = 0, int l = 0, int r = -1)\n      : lst(lst), a(a), b(b), x(x), k(k), l(l), r(r) {}\n};\n\ntemplate<typename T, typename E> struct QueryType {\n  virtual int outOfRange(QueryObject<T, E> o) = 0;\n  virtual int cover(QueryObject<T, E> o) = 0;\n  virtual int join(QueryObject<T, E> o, T vl, T vr) = 0;\n  T query(QueryObject<T, E> o) {\n    if (o.r < 0) o.r = o.lst->n;\n    o.lst->eval(o.r - o.l, o.k);\n    if (o.b <= o.l || o.r <= o.a) return outOfRange(o);\n    if (o.a <= o.l && o.r <= o.b) return cover(o);\n    QueryObject<T, E> o1 = o, o2 = o;\n    o1.k = o.k * 2 + 1; o1.r = (o.l + o.r) / 2;\n    o2.k = o.k * 2 + 2; o2.l = (o.l + o.r) / 2;\n    T vl = query(o1);\n    T vr = query(o2);\n    return join(o, vl, vr);\n  }\n};\n\ntemplate<typename T, typename E> struct Setter : QueryType<T, E> {\n  enum setter { RUQ, RAQ };\n  int outOfRange(QueryObject<T, E> o) {\n    return o.lst->data[o.k];\n  }\n  int cover(QueryObject<T, E> o) {\n    o.lst->lazy[o.k] = o.lst->h(o.lst->lazy[o.k], o.x);\n    o.lst->eval(o.r - o.l, o.k);\n    return o.lst->data[o.k];\n  }\n  int join(QueryObject<T, E> o, T vl, T vr) {\n    return o.lst->data[o.k] = o.lst->f(vl, vr);\n  }\n};\n\ntemplate<typename T, typename E> struct Getter : QueryType<T, E> {\n  enum getter { RMQ, RSQ };\n  int outOfRange(QueryObject<T, E> o) {\n    return o.lst->initT;\n  }\n  int cover(QueryObject<T, E> o) {\n    return o.lst->data[o.k];\n  }\n  int join(QueryObject<T, E> o, T vl, T vr) {\n    return o.lst->f(vl, vr);\n  }\n};\n\ntemplate<typename T, typename E> struct LazySegmentTree {\n  using F = function<T(T, T)>;\n  using G = function<T(T, E)>;\n  using H = function<E(E, E)>;\n  using P = function<E(E, int)>;\n  F add() {\n    return [&](const T& x, const T& y) -> const T { return x + y; };\n  }\n  F minimum() {\n    return [&](const T& x, const T& y) -> const T { return min(x, y); };\n  }\n  G ex_assign(E initE) {\n    return [&initE](const T& x, const E& y) -> const T { return (y == initE) ? x : y; };\n  }\n  P ex_multiplies(E initE) {\n    return [&initE](const E& x, int y) -> const E { return (x == initE) ? x : x * y; };\n  }\n\n  int n;\n  T initT;\n  E initE;\n  F f;\n  G g;\n  H h;\n  P p;\n  vector<T> data;\n  vector<E> lazy;\n  QueryType<T, E> *type;\n\n  LazySegmentTree() {}\n  LazySegmentTree(QueryType<T, E> *type_) { type = type_; }\n  LazySegmentTree(int n_, int setter, int getter,\n      T initT_ = INT_MAX, E initE_ = INT_MAX, vector<T> v = vector<T>{}) {\n    setQuery(setter, getter, initT_, initE_);\n    n = 1;\n    while (n < n_) n *= 2;\n    data.assign(n * 2 - 1, initT);\n    lazy.assign(n * 2 - 1, initE);\n    if (n_ == v.size()) build(v);\n  }\n  void build(vector<T> v) {\n    for (int i = 0; i < v.size(); ++i) data[i + n - 1] = v[i];\n    for (int i = n - 2; i >= 0; --i) {\n      data[i] = f(data[i * 2 + 1], data[i * 2 + 2]);\n    }\n  }\n  void setQuery(int setter, int getter, T initT_, E initE_) {\n    initT = vector<T>{initT_, 0}[getter];\n    initE = vector<E>{initE_, 0}[setter];\n    f = vector<F>{minimum(), add()}[getter];\n    g = vector<G>{ex_assign(initE), add()}[setter];\n    h = vector<H>{ex_assign(initE), add()}[setter];\n    p = ex_multiplies(initE);\n  }\n  inline void eval(int len, int k) {\n    if (lazy[k] == initE) return;\n    if (k * 2 + 1 < n * 2 - 1) {\n      lazy[k * 2 + 1] = h(lazy[k * 2 + 1], lazy[k]);\n      lazy[k * 2 + 2] = h(lazy[k * 2 + 2], lazy[k]);\n    }\n    data[k] = g(data[k], p(lazy[k], len));\n    lazy[k] = initE;\n  }\n  T query(QueryObject<T, E> obj) {\n    return type->query(obj);\n  }\n  T setData(int a, int b, E x, int k = 0, int l = 0, int r = -1) {\n    LazySegmentTree<T, E> lst(new Setter<T, E>());\n    QueryObject<T, E> obj(this, a, b, x, k, l, r);\n    return lst.query(obj);\n  }\n  T getData(int a, int b, int k = 0, int l = 0, int r = -1) {\n    LazySegmentTree<T, E> lst(new Getter<T, E>());\n    QueryObject<T, E> obj(this, a, b, initE, k, l, r);\n    return lst.query(obj);\n  }\n};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, q; cin >> n >> q;\n  LazySegmentTree<ll, ll> seg(n, Setter<ll, ll>::RUQ, Getter<ll, ll>::RSQ);\n\n  while (q--) {\n    int com; cin >> com;\n    if (com) {\n      int s, t; cin >> s >> t;\n      cout << seg.getData(s, t + 1) << endl;\n    } else {\n      int s, t, x; cin >> s >> t >> x;\n      seg.setData(s, t + 1, x);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\ntemplate<typename LSTTrait> class LazySegTree {\n  using FoldMonoid = typename LSTTrait::FoldMonoid;\n  using ActionMonoid = typename LSTTrait::ActionMonoid;\n  using T = typename FoldMonoid::value_type;\n  using Q = typename ActionMonoid::value_type;\n\n  LSTTrait lstTrait; // apply :: (T, Q) -> T, pow :: (Q, int) -> Q\n  FoldMonoid foldM;\n  ActionMonoid actionM;\n  int size = 1;\n  vector<T> tree; // 1-indexed\n  vector<Q> lazy; // 1-indexed\n\n  void push(int i) {\n    stack<pair<int, int>> s;\n    for (int d = 1; i /= 2; d *= 2) s.emplace(i, d);\n    for (int x, d; s.size(); s.pop()) {\n      tie(x, d) = s.top();\n      update(x * 2, lazy[x], d);\n      update(x * 2 + 1, lazy[x], d);\n      lazy[x] = actionM.id();\n    }\n  }\n\n  void update(const int &i, const Q &x, const int &d) {\n    tree[i] = lstTrait.apply(tree[i], lstTrait.pow(x, d));\n    if (i < size) lazy[i] = actionM(lazy[i], x);\n  }\n\n  void build(int i) {\n    for (int d = 2; i /= 2; d *= 2) tree[i] = lstTrait.apply(foldM(tree[i * 2], tree[i * 2 + 1]), lstTrait.pow(lazy[i], d));\n  }\n\npublic:\n  LazySegTree(const int &n = 0) {\n    while (size < n) size *= 2;\n    tree.assign(size * 2, foldM.id());\n    lazy.assign(size, actionM.id());\n  }\n\n  LazySegTree(const int &n, const T &x) {\n    while (size < n) size *= 2;\n    tree.assign(size * 2, x);\n    lazy.assign(size, actionM.id());\n    for (int i = size - 1; i >= 1; i--) tree[i] = foldM(tree[i * 2], tree[i * 2 + 1]);\n  }\n\n  template<typename InputIterator> LazySegTree(InputIterator first, InputIterator last) {\n    int n = distance(first, last);\n    while (size < n) size *= 2;\n    tree.resize(size * 2, foldM.id());\n    lazy.assign(size, actionM.id());\n    copy(first, last, tree.begin() + size);\n    for (int i = size - 1; i >= 1; i--) tree[i] = foldM(tree[i * 2], tree[i * 2 + 1]);\n  }\n\n  void act(int l, int r, const Q &x) { // [l, r) += x\n    int l0 = l += size, r0 = r += size;\n    push(l0), push(r0 - 1);\n    for (int d = 1; l < r; l /= 2, r /= 2, d *= 2) {\n      if (l & 1) update(l++, x, d);\n      if (r & 1) update(--r, x, d);\n    }\n    build(l0);\n    build(r0 - 1);\n  }\n\n  T fold(int l, int r) { // [l, r)\n    T accl = foldM.id(), accr = foldM.id();\n    for (push(l += size), push((r += size) - 1); l < r; l /= 2, r /= 2) {\n      if (l & 1) accl = foldM(accl, tree[l++]);\n      if (r & 1) accr = foldM(tree[--r], accr);\n    }\n    return foldM(accl, accr);\n  }\n};\n\ntemplate<typename T> struct sumMonoid {\n  using value_type = T;\n  value_type id() { return 0; }\n  value_type operator()(const value_type &a, const value_type &b) { return a + b; }\n};\n\ntemplate<typename T> struct updateMonoid {\n  using value_type = pair<bool, T>;\n  value_type id() { return {false, T()}; }\n  value_type operator()(const value_type &a, const value_type &b) { return b.first ? b : a; }\n};\n\ntemplate<typename T> struct RSQ_RUQ_Trait {\n  using FoldMonoid = sumMonoid<T>;\n  using ActionMonoid = updateMonoid<T>;\n  typename FoldMonoid::value_type apply(typename FoldMonoid::value_type t, typename ActionMonoid::value_type q) { return q.first ? q.second : t; }\n  typename ActionMonoid::value_type pow(typename ActionMonoid::value_type q, const int &d) { return {q.first, q.second * d}; }\n};\n\nmain {\n  int n, q;\n  cin >> n >> q;\n  LazySegTree<RSQ_RUQ_Trait<int>> lst(n, 0);\n  while (q--) {\n    if (in()) {\n      int s, t;\n      cin >> s >> t;\n      cout << lst.fold(s, t + 1) << endl;\n    } else {\n      int s, t, x;\n      cin >> s >> t >> x;\n      lst.act(s, t + 1, {true, x});\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// セグメント木\n//   モノイド (S, fs), 単位元 es で構築する.\n//   半開区間 [l, r) で操作する.\n//   木の実装は 1-indexed.\n//   計算量:\n//     構築       O(n)\n//     一点更新   O(log n)\n//     区間クエリ O(log n)\n#include<functional>\n#include<vector>\ntemplate<typename S> class SegmentTree {\n public:\n  using FS = std::function<S(S, S)>;\n  SegmentTree(int n, FS fs, S es) : n(size(n)), fs(fs), es(es), dat(size(n) << 1, es) {}\n  void update(int k, S x) {\n    dat[k += n] = x;\n    while(k = parent(k)) dat[k] = fs(dat[lchild(k)], dat[rchild(k)]);\n  }\n  S query(int a, int b) const {\n    auto vl = es, vr = es;\n    for(auto l = a + n, r = b + n; l < r; l = parent(l), r = parent(r)) {\n      if(l&1) vl = fs(vl, dat[l++]);\n      if(r&1) vr = fs(dat[--r], vr);\n    }\n    return fs(vl, vr);\n  }\n private:\n  constexpr int size(int n) const {return n & (n - 1) ? size(n + (n & -n)) : n;}\n  inline int parent(int k) const {return (k >> 1);}\n  inline int lchild(int k) const {return (k << 1);}\n  inline int rchild(int k) const {return (k << 1) | 1;}\n  int n;\n  std::vector<S> dat;\n  FS fs;\n  S es;\n};\n\n// 遅延伝播セグメント木\n//   モノイド (S, fs), (E, fe) と作用 fa: S × E → S で構築する.\n//   半開区間 [l, r) で操作する.\n//   木の実装は 1-indexed.\n//   計算量:\n//     構築       O(n)\n//     区間更新   O(log n)\n//     区間クエリ O(log n)\n#include<functional>\n#include<vector>\ntemplate<typename S, typename E = S> class SegmentTreeLP {\n public:\n  using Size = long long;\n  using FS = std::function<S(S, S)>;\n  using FA = std::function<S(S, E)>;\n  using FE = std::function<E(E, E)>;\n  SegmentTreeLP(int n, FS fs, FA fa, FE fe, S es, E ee) : n(size(n)), fs(fs), fa(fa), fe(fe), es(es), ee(ee), dat(size(n) << 1, es), laz(size(n) << 1, ee), height(lsb(size(n))) {}\n  void update(int a, int b, E x) {\n    if(a >= b) return;\n    thrust(a += n);\n    thrust(b += n - 1);\n    for(auto l = a, r = b + 1; l < r; l = parent(l), r = parent(r)) {\n      if(l&1) laz[l] = fe(laz[l], x), ++l;\n      if(r&1) --r, laz[r] = fe(laz[r], x);\n    }\n    recalc(a);\n    recalc(b);\n  }\n  void set(int a, S x) {\n    thrust(a += n);\n    dat[a] = x;\n    laz[a] = ee;\n    recalc(a);\n  }\n  S query(int a, int b) {\n    thrust(a += n);\n    thrust(b += n - 1);\n    auto vl = es, vr = es;\n    for(auto l = a, r = b + 1; l < r; l = parent(l), r = parent(r)) {\n      if(l&1) vl = fs(vl, reflect(l++));\n      if(r&1) vr = fs(reflect(--r), vr);\n    }\n    return fs(vl, vr);\n  }\n private:\n  constexpr int size(int n) const {return n & (n - 1) ? size(n + (n & -n)) : n;}\n  inline int lsb(int n) {return n & 1 ? 0 : 1 + lsb(n >> 1);}\n  inline int parent(int k) const {return (k >> 1);}\n  inline int lchild(int k) const {return (k << 1);}\n  inline int rchild(int k) const {return (k << 1) | 1;}\n  inline S reflect(int k) const {return laz[k]==ee ? dat[k] : fa(dat[k], laz[k]);}\n  inline void propagate(int k) {\n    if(laz[k] == ee) return;\n    laz[lchild(k)] = fe(laz[lchild(k)], laz[k]);\n    laz[rchild(k)] = fe(laz[rchild(k)], laz[k]);\n    dat[k] = reflect(k);\n    laz[k] = ee;\n  }\n  inline void thrust(int k) {for(auto i = height; i; --i) propagate(k >> i);}\n  inline void recalc(int k) {while(k >>= 1) dat[k] = fs(reflect(lchild(k)), reflect(rchild(k)));}\n  int n, height;\n  FS fs;\n  FA fa;\n  FE fe;\n  S es;\n  E ee;\n  std::vector<S> dat;\n  std::vector<E> laz;\n};\n\n// 遅延伝播動的セグメント木\n//   モノイド (S, fs), (E, fe) と作用 fa: S × E → S で構築する.\n//   半開区間 [l, r) で操作する.\n//   計算量:\n//     構築       O(1)\n//     区間更新   O(log n)\n//     区間クエリ O(log n)\n//     二分探索   O(log^2 n)\n#include<functional>\n#include<iostream>\n#include<memory>\ntemplate<typename S, typename E = S> class SegmentTreeDLP {\n public:\n  using Size = long long;\n  using FS = std::function<S(S, S)>;\n  using FA = std::function<S(S, E)>;\n  using FE = std::function<E(E, E)>;\n  SegmentTreeDLP(Size n, FS fs, FA fa, FE fe, S es, E ee) : n(n), fs(fs), fa(fa), fe(fe), es(es), ee(ee), root(std::make_unique<Node>(es,ee)) {}\n  void update(Size a, Size b, E x) {update(a, b, x, root, 0, n);}\n  S query(Size a, Size b) {return query(a, b, root, 0, n);}\n  Size lower_bound(Size a, Size b, const std::function<bool(S)>& check) {return lower_bound(a, b, check, root, 0, n);}\n  void debug() {std::cout << \"segtree: size \" << n << std::endl; traverse(root, 0, 0, n);}\n  void traverse(const auto& node, Size d, Size l, Size r) {\n    if(not node->lchild || not node->rchild) return;\n    propagate(node);\n    auto m = (l + r) / 2;\n    if(l+1!=r) traverse(node->rchild, d + 1, m, r);\n    for(auto i = 0; i < d; ++i) std::cout << \"    \";\n    std::cout << \"[\" << l << \",\" << r << \") \";\n    std::cout << node->val << std::endl;\n    if(l+1!=r) traverse(node->lchild, d + 1, l, m);\n  }\n private:\n  struct Node {\n    S val;\n    E laz;\n    std::unique_ptr<Node> lchild, rchild;\n    Node(S val, E laz) : val(val), laz(laz) {}\n  };\n  inline S reflect(const auto& n) {return n->laz==ee ? n->val : fa(n->val, n->laz);}\n  inline void propagate(const auto& n) {\n    if(not n->lchild) n->lchild = std::make_unique<Node>(es, ee);\n    if(not n->rchild) n->rchild = std::make_unique<Node>(es, ee);\n    if(n->laz == ee) return;\n    n->lchild->laz = fe(n->lchild->laz, n->laz);\n    n->rchild->laz = fe(n->rchild->laz, n->laz);\n    n->val = reflect(n);\n    n->laz = ee;\n  }\n  void update(Size a, Size b, E x, const auto &n, Size l, Size r) {\n    propagate(n);\n    if(b <= l || r <= a) return;\n    if(a <= l && r <= b) {\n      n->laz = fe(n->laz, x);\n      propagate(n);\n      return;\n    }\n    auto m = (l + r) / 2;\n    update(a, b, x, n->lchild, l, m);\n    update(a, b, x, n->rchild, m, r);\n    n->val = fs(n->lchild->val, n->rchild->val);\n  }\n  S query(Size a, Size b, const auto &n, Size l, Size r) {\n    propagate(n);\n    if(b <= l || r <= a) return es;\n    if(a <= l && r <= b) return reflect(n);\n    auto m = (l + r) / 2;\n    auto vl = query(a, b, n->lchild, l, m);\n    auto vr = query(a, b, n->rchild, m, r);\n    return fs(vl, vr);\n  }\n  Size lower_bound(Size a, Size b, const auto& check, const auto& node, Size l, Size r) {\n    propagate(node);\n    if(b <= l || r <= a) return n;\n    if(!check(reflect(node))) return n;\n    if(l + 1 == r) return l;\n    auto m = (l + r) / 2;\n    auto i = lower_bound(a, b, check, node->lchild, l, m);\n    if(i != n) return i;\n    return lower_bound(a, b, check, node->rchild, m, r);\n  }\n  Size n;\n  std::unique_ptr<Node> root;\n  FS fs;\n  FA fa;\n  FE fe;\n  S es;\n  E ee;\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\nstruct S {\n  LL v, size;\n  bool operator==(const S& o) const {return v != o.v;}\n  friend ostream& operator<<(ostream& os, const S& s) {return os << s.v;}\n};\nusing E = LL;\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n\n  auto fs = [&](S l, S r) {return S{l.v + r.v, l.size + r.size};};\n  auto fa = [&](S l, E r) {return S{r * l.size, l.size};};\n  auto fe = [&](E l, E r) {return r;};\n  auto es = S{0, 1};\n  auto ee = 1e18;\n\n  SegmentTreeDLP<S,E> DRSUQ(n+1, fs,fa,fe,es,ee);\n  for(auto i=0; i<n+1; ++i) DRSUQ.update(i, i+1, ee);\n  for(auto i=0; i<q; ++i) {\n    int x, s, t, u;\n    cin >> x >> s >> t;\n    if(!x) cin >> u;\n    if(x) cout << DRSUQ.query(s,t+1) << endl;\n    else  DRSUQ.update(s,t+1,u);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\ntemplate<typename T, typename E> struct LazySegmentTree;\n\ntemplate<typename T, typename E> struct QueryObject {\n  LazySegmentTree<T, E> *lst;\n  int a, b;\n  E x;\n  int k;\n  int l, r;\n  QueryObject(LazySegmentTree<T, E> *lst_,\n      int a, int b, E x = 0, int k = 0, int l = 0, int r = -1)\n      : a(a), b(b), x(x), k(k), l(l), r(r) {\n    lst = lst_;\n  }\n};\n\ntemplate<typename T, typename E> struct QueryType {\n  virtual ~QueryType() {}\n  virtual int outOfRange(QueryObject<T, E> o) = 0;\n  virtual int cover(QueryObject<T, E> o) = 0;\n  virtual int join(QueryObject<T, E> o, T vl, T vr) = 0;\n  T query(QueryObject<T, E> o) {\n    if (o.r < 0) o.r = o.lst->n;\n    o.lst->eval(o.r - o.l, o.k);\n    if (o.b <= o.l || o.r <= o.a) return outOfRange(o);\n    if (o.a <= o.l && o.r <= o.b) return cover(o);\n    QueryObject<T, E> o1 = o, o2 = o;\n    o1.k = o.k * 2 + 1; o1.r = (o.l + o.r) / 2;\n    o2.k = o.k * 2 + 2; o2.l = (o.l + o.r) / 2;\n    T vl = query(o1);\n    T vr = query(o2);\n    return join(o, vl, vr);\n  }\n};\n\ntemplate<typename T, typename E> struct Setter : QueryType<T, E> {\n  enum setter { RUQ, RAQ };\n  int outOfRange(QueryObject<T, E> o) {\n    return o.lst->data[o.k];\n  }\n  int cover(QueryObject<T, E> o) {\n    o.lst->lazy[o.k] = o.lst->h(o.lst->lazy[o.k], o.x);\n    o.lst->eval(o.r - o.l, o.k);\n    return o.lst->data[o.k];\n  }\n  int join(QueryObject<T, E> o, T vl, T vr) {\n    return o.lst->data[o.k] = o.lst->f(vl, vr);\n  }\n};\n\ntemplate<typename T, typename E> struct Getter : QueryType<T, E> {\n  enum getter { RMQ, RSQ };\n  int outOfRange(QueryObject<T, E> o) {\n    return o.lst->initT;\n  }\n  int cover(QueryObject<T, E> o) {\n    return o.lst->data[o.k];\n  }\n  int join(QueryObject<T, E> o, T vl, T vr) {\n    return o.lst->f(vl, vr);\n  }\n};\n\ntemplate<typename T, typename E> struct LazySegmentTree {\n  using F = function<T(T, T)>;\n  using G = function<T(T, E)>;\n  using H = function<E(E, E)>;\n  using P = function<E(E, int)>;\n\n  F add() {\n    return [&](const T& x, const T& y) -> const T { return x + y; };\n  }\n  F minimum() {\n    return [&](const T& x, const T& y) -> const T { return min(x, y); };\n  }\n  G ex_assign(E initE) {\n    return [&initE](const T& x, const E& y) -> const T { return (y == initE) ? x : y; };\n  }\n  P ex_multiplies(E initE) {\n    return [&initE](const E& x, int y) -> const E { return (x == initE) ? x : x * y; };\n  }\n\n  int n;\n  T initT;\n  E initE;\n  F f;\n  G g;\n  H h;\n  P p;\n  vector<T> data;\n  vector<E> lazy;\n  QueryType<T, E> *type;\n\n  LazySegmentTree() {}\n  LazySegmentTree(QueryType<T, E> *type_) { type = type_; }\n  LazySegmentTree(int n_, int setter, int getter,\n      T initT_ = INT_MAX, E initE_ = INT_MAX, vector<T> v = vector<T>()) {\n    setQuery(setter, getter, initT_, initE_);\n    n = 1;\n    while (n < n_) n *= 2;\n    data.assign(n * 2 - 1, initT);\n    lazy.assign(n * 2 - 1, initE);\n    if (n_ == v.size()) build(v);\n  }\n  void build(vector<T> v) {\n    for (int i = 0; i < v.size(); ++i) data[i + n - 1] = v[i];\n    for (int i = n - 2; i >= 0; --i) {\n      data[i] = f(data[i * 2 + 1], data[i * 2 + 2]);\n    }\n  }\n  void setQuery(int setter, int getter, T initT_, E initE_) {\n    initT = vector<T>{initT_, 0}[getter];\n    initE = vector<E>{initE_, 0}[setter];\n    f = vector<F>{minimum(), add()}[getter];\n    g = vector<G>{ex_assign(initE), add()}[setter];\n    h = vector<H>{ex_assign(initE), add()}[setter];\n    p = ex_multiplies(initE);\n  }\n  inline void eval(int len, int k) {\n    if (lazy[k] == initE) return;\n    if (k * 2 + 1 < n * 2 - 1) {\n      lazy[k * 2 + 1] = h(lazy[k * 2 + 1], lazy[k]);\n      lazy[k * 2 + 2] = h(lazy[k * 2 + 2], lazy[k]);\n    }\n    data[k] = g(data[k], p(lazy[k], len));\n    lazy[k] = initE;\n  }\n  T query(QueryObject<T, E>& obj) {\n    return type->query(obj);\n  }\n  T setData(int a, int b, E x) {\n    LazySegmentTree<T, E> lst(new Setter<T, E>());\n    QueryObject<T, E> obj(this, a, b, x);\n    return lst.query(obj);\n  }\n  T getData(int a, int b) {\n    LazySegmentTree<T, E> lst(new Getter<T, E>());\n    QueryObject<T, E> obj(this, a, b);\n    return lst.query(obj);\n  }\n};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, q; cin >> n >> q;\n  LazySegmentTree<ll, ll> seg(n, Setter<ll, ll>::RUQ, Getter<ll, ll>::RSQ);\n\n  while (q--) {\n    int com; cin >> com;\n    if (com) {\n      int s, t; cin >> s >> t;\n      cout << seg.getData(s, t + 1) << endl;\n    } else {\n      int s, t, x; cin >> s >> t >> x;\n      seg.setData(s, t + 1, x);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//sub-BOF\n#define _AOJ_\n        /*vvv>\n        zzzzzI\n .---.  zzuzuI                 .vgggg&,.\n+++++=  dAC:|I  .WbbWo       JMM9^```?TMB`  ..&gNNg,.   gggggggJ,   qgggggggg] (&&&&&&&&[   c+OA&J,   (&&&&&&+J,   .cJeAA&-.  (&&&&&&&&x   .&AA&=-.\n+++++=  dTqk|I  Xpbpbp      JM#`           (M#^   ?MMp  MM|   +TMN. JMF      ' |yk      ` dVY    7Vk,  Vy     XV  cVf     ?Y!  JM         V$      `\n+++++=  dcf:|I  Xppppp      dMN           .MM+     .MM  MM|     MM] JMMMMMM+   |@tqkoh)  ,y0      (V$  yyyyyyyV7  VV           JMWyZWr    TWVVVVW&,\n++++++  d7qk|0  Xppppp      ^HMN,    _.db  WMm,   .MMF  MM|   ..MM` JMF      . |yk       .WV&.   .XW'  yy   4yn.  jyn      +.  JM                #S\n`++++`  ?ZZZX=  ?WWWW=        -THMMMMH9^    (TMMMMM9!   MMMMMMM\"\"   JMMMMMMMME |UU.        ?TUUUUY=    UU.   (UU-  ^7TUUUV7!   JUUUUUUUU  7TUNKO*/\n\n\n//basic\n#pragma GCC target(\"sse4\")\n#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long lint;\ntypedef long double ld;\ntypedef string cs;\n#define all(v) v.begin(),v.end()\n#define pb push_back\n\n//rep\n#define _vcppunko4(tuple) _getname4 tuple\n#define _getname4(_1,_2,_3,_4,name,...) name\n#define _getname3(_1,_2,_3,name,...) name\n#define _trep2(tuple) _rep2 tuple\n#define _trep3(tuple) _rep3 tuple\n#define _trep4(tuple) _rep4 tuple\n#define _rep1(n) for(lint i=0;i<n;++i)\n#define _rep2(i,n) for(lint i=0;i<n;++i)\n#define _rep3(i,a,b) for(lint i=a;i<b;++i)\n#define _rep4(i,a,b,c) for(lint i=a;i<b;i+=c)\n#define _trrep2(tuple) _rrep2 tuple\n#define _trrep3(tuple) _rrep3 tuple\n#define _trrep4(tuple) _rrep4 tuple\n#define _rrep1(n) for(lint i=n-1;i>=0;--i)\n#define _rrep2(i,n) for(lint i=n-1;i>=0;--i)\n#define _rrep3(i,a,b) for(lint i=b-1;i>=a;--i)\n#define _rrep4(i,a,b,c) for(lint i=a+(b-a-1)/c*c;i>=a;i-=c)\n#define rep(...) _vcppunko4((__VA_ARGS__,_trep4,_trep3,_trep2,_rep1))((__VA_ARGS__))\n#define per(...) _vcppunko4((__VA_ARGS__,_trrep4,_trrep3,_trrep2,_rrep1))((__VA_ARGS__))\n#define each(c) for(auto &e:c)\n\n//io\ntemplate<class T>\nistream& operator>>(istream& is,vector<T>& vec);\ntemplate<class T,size_t size>\nistream& operator>>(istream& is,array<T,size>& vec);\ntemplate<class T,class L>\nistream& operator>>(istream& is,pair<T,L>& p);\ntemplate<class T>\nostream& operator<<(ostream& os,vector<T>& vec);\ntemplate<class T,class L>\nostream& operator<<(ostream& os,pair<T,L>& p);\ntemplate<class T>\nistream& operator>>(istream& is,vector<T>& vec){ for(T& x: vec) is>>x;return is; }\ntemplate<class T,class L>\nistream& operator>>(istream& is,pair<T,L>& p){ is>>p.first;is>>p.second;return is; }\ntemplate<class T,class L>\nostream& operator<<(ostream& os,pair<T,L>& p){ os<<p.first<<\" \"<<p.second;return os; }\ntemplate<class T>\nostream& operator<<(ostream& os,vector<T>& vec){ os<<vec[0];rep(i,1,vec.size())os<<' '<<vec[i];return os; }\ntemplate<class T>\nostream& operator<<(ostream& os,deque<T>& deq){ os<<deq[0];rep(i,1,deq.size())os<<' '<<deq[i];return os; }\n\n#ifdef __ENV_TQK__\n#include<Windows.h>\nHANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\ninline void in(){ SetConsoleTextAttribute(hConsole,10); }\ntemplate <class Head,class... Tail>\ninline void in(Head&& head,Tail&&... tail){\n\tSetConsoleTextAttribute(hConsole,15);\n\tcin>>head;in(move(tail)...);\n}\n#else\ninline void in(){}\ntemplate <class Head,class... Tail>\ninline void in(Head&& head,Tail&&... tail){ cin>>head;in(move(tail)...); }\n#endif\n\n\n\ninline bool out(){ return(cout<<'\\n',0); }\ntemplate <class T>\ninline bool out(T t){ return(cout<<t<<'\\n',0); }\ntemplate <class Head,class... Tail>\ninline bool out(Head head,Tail... tail){ cout<<head<<' ';out(move(tail)...);return 0; }\ntemplate <class T>\ninline void alloc(T &c,lint s){ rep(c.size())c[i].resize(s); }\n#define alc alloc\n\n//TA\n#define lin(...) lint __VA_ARGS__;in(__VA_ARGS__)\n#define stin(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define vin(type,name,size) vector<type> name(size);in(name)\n#define vvin(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__));in(name)\n#define fi e.first\n#define se e.second\n#define YES(c) cout<<((c)?\"YES\\n\":\"NO\\n\"),0\n#define Yes(c) cout<<((c)?\"Yes\\n\":\"No\\n\"),0\n#define POSSIBLE(c) cout<<((c)?\"POSSIBLE\\n\":\"IMPOSSIBLE\\n\"),0\n#define Possible(c) cout<<((c)?\"Possible\\n\":\"Impossible\\n\"),0\n#define o(p) cout<<p<<endl,0\n#define sp(p) cout<<p<<\" \"\n#define no(p) cout<<p\ninline constexpr lint gcd(lint a,lint b){ if(!a||!b)return 0;while(b){ lint c=b;b=a%b;a=c; }return a; }\ntemplate<typename T>\ninline constexpr bool chmin(T &mn,const T &cnt){ if(mn>cnt){ mn=cnt;return 1; } else return 0; }\ntemplate<typename T>\ninline constexpr bool chmax(T &mx,const T &cnt){ if(mx<cnt){ mx=cnt;return 1; } else return 0; }\n#define ve(type) vector<type>\n#define fn(ty1,ty2,ex) [](ty1 a,ty2 b){ return(ex); }\n#define lfn(ex) [](lint a,lint b){ return(ex); }\n\n//other\n#ifdef __ENV_TQK__\n#define deb(p) cout<<p<<endl,0\n#else\n#define deb(p) 0\n#endif\nstruct Fastio{\n\tFastio(){\n\t\tcin.tie(0),cout.tie(0);\n\t\tios::sync_with_stdio(0);\n\t\tcout<<fixed<<setprecision(10);\n\t}\n} __fastio;\n\n\n//mint\n#define md_tmp template<uint_fast64_t md=1000000007>\nmd_tmp class mint{\n\tusing u64=uint_fast64_t;\n\npublic:\n\tu64 a;\n\n\tconstexpr mint(const u64 x=0) noexcept: a(x%md){}\n\tconstexpr u64 &value() noexcept{ return a; }\n\tconstexpr const u64 &value() const noexcept{ return a; }\n\tconstexpr mint operator+(const mint rhs) const noexcept{\n\t\treturn mint(*this)+=rhs;\n\t}\n\tconstexpr mint operator-(const mint rhs) const noexcept{\n\t\treturn mint(*this)-=rhs;\n\t}\n\tconstexpr mint operator*(const mint rhs) const noexcept{\n\t\treturn mint(*this)*=rhs;\n\t}\n\tconstexpr mint operator^(const lint rhs) const noexcept{\n\t\treturn mint(*this)^=rhs;\n\t}\n\tconstexpr mint operator/(const mint rhs) const noexcept{\n\t\treturn mint(*this)/=rhs;\n\t}\n\tconstexpr mint &operator+=(const mint rhs) noexcept{\n\t\ta+=rhs.a;\n\t\tif(a>=md)a-=md;\n\t\treturn *this;\n\t}\n\tconstexpr mint &operator-=(const mint rhs) noexcept{\n\t\tif(a<rhs.a)a+=md;\n\t\ta-=rhs.a;\n\t\treturn *this;\n\t}\n\tconstexpr mint &operator*=(const mint rhs) noexcept{\n\t\ta=a*rhs.a%md;\n\t\treturn *this;\n\t}\n\tconstexpr mint &operator^=(const lint rhs) noexcept{\n\t\tif(!rhs)return *this=1;\n\t\tu64 exp=rhs-1;\n\t\tmint base=this->a;\n\t\twhile(exp){\n\t\t\tif(exp&1)*this*=base;\n\t\t\tbase*=base;\n\t\t\texp>>=1;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr mint &operator/=(const mint rhs) noexcept{\n\t\ta=(*this*(rhs^(md-2))).a;\n\t\treturn *this;\n\t}\n};\nmd_tmp istream& operator>>(istream& os,mint<md>& m){\n\tos>>m.a,m.a%=md;\n\treturn os;\n}\nmd_tmp ostream& operator<<(ostream& os,const mint<md>& m){\n\treturn os<<m.a;\n}\nmd_tmp mint<md> ncr(lint n,lint r){\n\tif(n<r||n<0||r<0)return mint<md>(0);\n\tmint<md>ncr_res=1,ncr_div=1;\n\trep(r)ncr_res*=(n-i),ncr_div*=(r-i);\n\treturn ncr_res/ncr_div;\n}\n#ifndef _AOJ_\nmint<> operator\"\"m(const unsigned long long n){ return mint<>(n); }\nmint<998244353> operator\"\"m9(const unsigned long long n){ return mint<998244353>(n); }\nmint<1000003> operator\"\"m3(const unsigned long long n){ return mint<1000003>(n); }\n#endif\n\n\n//const\n#define linf 1152921504606846976\n#define inf linf\n#define MAXN 330\n#define md_1e9_7 1000000007\n#define md_998244353 998244353\n#define pi 3.14159265358979323846\n//#define mod md_1e9_7\nconst int d4[5]={0,1,0,-1,0};\n\n//main------\n\nclass P{ public:lint f,s; P(lint a,lint b):f(a),s(b){}; P():f(0),s(0){}; };\nistream& operator>>(istream& os,P& p){ os>>p.f>>p.s;return os; }\nbool operator<(const P& l,const P& r){ return(l.f-r.f?l.f<r.f:l.s<r.s); }\nbool operator>(const P& l,const P& r){ return(l.f-r.f?l.f>r.f:l.s>r.s); }\n\ntemplate < class M_act >\nstruct Lazy{\npublic:\n\tusing Monoid = typename M_act::Monoid;\n\tusing X = typename Monoid::T;\n\tusing M = typename M_act::M;\n\nprivate:\n\tsize_t n;\n\tint h;\n\tvector< X > data;\n\tvector< M > lazy;\n\tvector< size_t > nodeLength;\n\t// call before use data[i]\n\tvoid eval(size_t i){\n\t\tif(lazy[i] == M_act::identity()) return;\n\t\tdata[i] = M_act::actInto(lazy[i],nodeLength[i],data[i]);\n\t\tif(i < n){\n\t\t\tlazy[i * 2] = M_act::op(lazy[i],lazy[i * 2]);\n\t\t\tlazy[i * 2 + 1] = M_act::op(lazy[i],lazy[i * 2 + 1]);\n\t\t}\n\t\tlazy[i] = M_act::identity();\n\t}\n\t// call before use seg[i] = data[i + n]\n\tvoid evalDown(size_t i){\n\t\ti += n;\n\t\tfor(int j = h - 1; j >= 0; j--) eval(i >> j);\n\t}\n\t// call after touch seg[i] = data[i + n]\n\tvoid propUp(size_t i){\n\t\ti += n;\n\t\twhile(i >>= 1)\n\t\t\teval(i * 2),eval(i * 2 + 1),data[i] = Monoid::op(data[i * 2],data[i * 2 + 1]);\n\t}\n\npublic:\n\tLazy(): n(0){}\n\tLazy(size_t n,X initial = Monoid::identity()): n(n){\n\t\tif(n > 0){\n\t\t\th = 1;\n\t\t\twhile(1u << h < n) h++;\n\t\t\tdata.resize(2 * n,initial);\n\t\t\tlazy.resize(2 * n,M_act::identity());\n\t\t\tnodeLength.resize(2 * n,1);\n\t\t\tfor(size_t i = n - 1; i > 0; i--) // fill from deep\n\t\t\t\tdata[i] = Monoid::op(data[i * 2],data[i * 2 + 1]),\n\t\t\t\tnodeLength[i] = nodeLength[i * 2] + nodeLength[i * 2 + 1];\n\t\t}\n\t}\n\ttemplate < class InputIter,class = typename iterator_traits< InputIter >::value_type >\n\tLazy(InputIter first,InputIter last)\n\t\t: Lazy(distance(first,last)){\n\t\tif(n > 0){\n\t\t\tcopy(first,last,begin(data) + n);\n\t\t\tfor(size_t i = n - 1; i > 0; i--) // fill from deep\n\t\t\t\tdata[i] = Monoid::op(data[i * 2],data[i * 2 + 1]);\n\t\t}\n\t}\n\tLazy(vector< X > v): Lazy(v.begin(),v.end()){}\n\tLazy(initializer_list< X > v): Lazy(v.begin(),v.end()){}\n\tvoid act(int l,int r,const M &m){\n\t\tif(l < 0) l = 0;\n\t\tif(l >= r) return;\n\t\tif(r >(int) n) r = n;\n\t\tevalDown(l);\n\t\tevalDown(r - 1);\n\t\tint tl = l,tr = r;\n\t\tfor(l += n,r += n; l < r; l >>= 1,r >>= 1){\n\t\t\tif(l & 1) eval(l),lazy[l] = m,eval(l),l++;\n\t\t\tif(r & 1) --r,eval(r),lazy[r] = m,eval(r);\n\t\t}\n\t\tpropUp(tl);\n\t\tpropUp(tr - 1);\n\t}\n\tvoid set(size_t i,const X &x){\n\t\tassert(i < n);\n\t\tevalDown(i);\n\t\tdata[i + n] = x;\n\t\tpropUp(i);\n\t}\n\tX get(size_t i){\n\t\tassert(i < n);\n\t\tevalDown(i);\n\t\treturn data[i + n];\n\t}\n\tX fold(int l,int r){\n\t\tif(l < 0) l = 0;\n\t\tif(l >= r) return Monoid::identity();\n\t\tif(r >(int) n) r = n;\n\t\tevalDown(l);\n\t\tevalDown(r - 1);\n\t\tX tmpL = Monoid::identity(),tmpR = Monoid::identity();\n\t\tfor(l += n,r += n; l < r; l >>= 1,r >>= 1){\n\t\t\tif(l & 1) eval(l),tmpL = Monoid::op(tmpL,data[l]),l++;\n\t\t\tif(r & 1) --r,eval(r),tmpR = Monoid::op(data[r],tmpR);\n\t\t}\n\t\treturn Monoid::op(tmpL,tmpR);\n\t}\n\tint size(){ return n; }\n\tinline void dum(int r = -1){\n#ifdef DEBUG\n\t\tif(r < 0) r = n;\n\t\tDEBUG_OUT << \"{\";\n\t\tfor(int i = 0; i < min(r,(int)n); i++) DEBUG_OUT << (i ? \", \" : \"\") << get(i);\n\t\tDEBUG_OUT << \"}\" << endl;\n#endif\n\t}\n};\n\nconstexpr long long inf_monoid = 1e18 + 100;\nstruct Nothing{\n\tusing T = char;\n\tusing Monoid = Nothing;\n\tusing M = T;\n\tstatic constexpr T op(const T &,const T &){ return T(); }\n\tstatic constexpr T identity(){ return T(); }\n\ttemplate < class X >\n\tstatic constexpr X actInto(const M &,long long,const X &x){\n\t\treturn x;\n\t}\n};\n\ntemplate < class U = long long >\nstruct RangeMin{\n\tusing T = U;\n\tstatic T op(const T &a,const T &b){ return std::min< T >(a,b); }\n\tstatic constexpr T identity(){ return T(inf_monoid); }\n};\n\ntemplate < class U = long long >\nstruct RangeMax{\n\tusing T = U;\n\tstatic T op(const T &a,const T &b){ return std::max< T >(a,b); }\n\tstatic constexpr T identity(){ return T(-inf_monoid); }\n};\n\ntemplate < class U = long long >\nstruct RangeSum{\n\tusing T = U;\n\tstatic T op(const T &a,const T &b){ return a + b; }\n\tstatic constexpr T identity(){ return T(0); }\n};\n\ntemplate < class U >\nstruct RangeProd{\n\tusing T = U;\n\tstatic T op(const T &a,const T &b){ return a * b; }\n\tstatic constexpr T identity(){ return T(1); }\n};\n\ntemplate < class U = long long >\nstruct RangeOr{\n\tusing T = U;\n\tstatic T op(const T &a,const T &b){ return a | b; }\n\tstatic constexpr T identity(){ return T(0); }\n};\n\ntemplate < class U = long long >\nstruct RangeAnd{\n\tusing T = U;\n\tstatic T op(const T &a,const T &b){ return a & b; }\n\tstatic constexpr T identity(){ return T(-1); }\n};\n\ntemplate < size_t N >\nstruct RangeAnd< std::bitset< N > >{\n\tusing T = std::bitset< N >;\n\tstatic T op(const T &a,const T &b){ return a & b; }\n\tstatic constexpr T identity(){ return std::bitset< N >().set(); }\n};\n\ntemplate < class U = long long,class V = U >\nstruct RangeMinAdd{\n\tusing X = U;\n\tusing M = V;\n\tusing Monoid = RangeMin< U >;\n\tstatic M op(const M &a,const M &b){ return a + b; }\n\tstatic constexpr M identity(){ return 0; }\n\tstatic X actInto(const M &m,long long,const X &x){ return m + x; }\n};\n\ntemplate < class U = long long,class V = U >\nstruct RangeMaxAdd{\n\tusing X = U;\n\tusing M = V;\n\tusing Monoid = RangeMax< U >;\n\tstatic M op(const M &a,const M &b){ return a + b; }\n\tstatic constexpr M identity(){ return 0; }\n\tstatic X actInto(const M &m,long long,const X &x){ return m + x; }\n};\n\ntemplate < class U = long long,class V = U >\nstruct RangeMinSet{\n\tusing M = U;\n\tusing Monoid = RangeMin< U >;\n\tusing X = typename Monoid::T;\n\tstatic M op(const M &a,const M &){ return a; }\n\tstatic constexpr M identity(){ return M(-inf_monoid); }\n\tstatic X actInto(const M &m,long long,const X &x){ return m == identity() ? x : m; }\n};\n\ntemplate < class U = long long,class V = U >\nstruct RangeMaxSet{\n\tusing M = U;\n\tusing Monoid = RangeMax< U >;\n\tusing X = typename Monoid::T;\n\tstatic M op(const M &a,const M &){ return a; }\n\tstatic constexpr M identity(){ return M(-inf_monoid); }\n\tstatic X actInto(const M &m,long long,const X &x){ return m == identity() ? x : m; }\n};\n\ntemplate < class U = long long,class V = U >\nstruct RangeSumAdd{\n\tusing X = U;\n\tusing M = V;\n\tusing Monoid = RangeSum< U >;\n\tstatic M op(const M &a,const M &b){ return a + b; }\n\tstatic constexpr M identity(){ return 0; }\n\tstatic X actInto(const M &m,long long n,const X &x){ return m * n + x; }\n};\n\ntemplate < class U = long long,class V = U >\nstruct RangeSumSet{\n\tusing X = U;\n\tusing M = V;\n\tusing Monoid = RangeSum< U >;\n\tstatic M op(const M &a,const M &){ return a; }\n\tstatic constexpr M identity(){ return M(-inf_monoid); }\n\tstatic X actInto(const M &m,long long n,const X &x){\n\t\treturn m == identity() ? x : m * n;\n\t}\n};\n\ntemplate < class U,class V = U >\nstruct RangeProdMul{\n\tusing X = U;\n\tusing M = V;\n\tusing Monoid = RangeProd< U >;\n\tstatic M mpow(M a,long long b){\n\t\tX r(1);\n\t\twhile(b){\n\t\t\tif(b & 1) r = r * a;\n\t\t\ta = a * a;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn r;\n\t}\n\tstatic M op(const M &a,const M &b){ return a * b; }\n\tstatic constexpr M identity(){ return M(1); }\n\tstatic X actInto(const M &m,long long n,const X &x){ return x * mpow(m,n); }\n};\n\ntemplate < class U,class V = U >\nstruct RangeProdSet{\n\tusing X = U;\n\tusing M = V;\n\tusing Monoid = RangeProd< U >;\n\tstatic M op(const M &a,const M &){ return a; }\n\tstatic constexpr M identity(){ return V::unused; }\n\tstatic X actInto(const M &m,long long n,const X &){\n\t\tif(m == identity()) return;\n\t\treturn RangeProdMul< U,V >::mpow(m,n);\n\t}\n};\n\ntemplate < class U = long long,class V = U >\nstruct RangeOr2{\n\tusing X = U;\n\tusing M = V;\n\tusing Monoid = RangeOr< U >;\n\tstatic M op(const M &a,const M &b){ return a | b; }\n\tstatic constexpr M identity(){ return M(0); }\n\tstatic X actInto(const M &m,long long,const X &x){ return m | x; }\n};\n\ntemplate < class U = long long,class V = U >\nstruct RangeAnd2{\n\tusing X = U;\n\tusing M = V;\n\tusing Monoid = RangeAnd< U >;\n\tstatic M op(const M &a,const M &b){ return a & b; }\n\tstatic constexpr M identity(){ return M(-1); }\n\tstatic X actInto(const M &m,long long,const X &x){ return m & x; }\n};\n\ntemplate < class U,size_t N >\nstruct RangeAnd2< U,std::bitset< N > >{\n\tusing X = U;\n\tusing M = std::bitset< N >;\n\tusing Monoid = RangeAnd< U >;\n\tstatic M op(const M &a,const M &b){ return a & b; }\n\tstatic constexpr M identity(){ return std::bitset< N >().set(); }\n\tstatic X actInto(const M &m,long long,const X &x){ return m & x; }\n};\n\nint main(){\n\n\tlint n,q;in(n,q);\n\tLazy<RangeSumSet<>>ki(n,0);\n\twhile(q--){\n\t\tlint ty,s,t,x;in(ty);\n\t\tif(ty){\n\t\t\tin(s,t);\n\t\t\tout(ki.fold(s,++t));\n\t\t} else{\n\t\t\tin(s,t,x);\n\t\t\tki.act(s,++t,x);\n\t\t}\n\t}\n}\n\n//sub-EOF\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL=unsigned int;\nusing LL=long long;\nusing ULL=unsigned long long;\n#define rep(i,n) for(UL i=0; i<(n); i++)\n\nstruct RSQ_RUQ{\n UL N;\n struct Node{ LL x; LL s; bool z; };\n vector<Node> V;\n\n void init(UL n){\n  N=1; while(N<n) N<<=1;\n  V.assign(N*2,Node{0,0,true});\n }\n\n void upd(UL l,UL r,LL x,UL a=0,UL b=0,UL i=~0u){\n  if(i==~0u){ a=0; i=1; b=N; }\n  if(r<=a || b<=l) return;\n  if(l<=a && b<=r){ V[i]={x,x*(b-a),true}; return; }\n  if(V[i].z){\n   V[i<<1] = V[(i<<1)+1] = {V[i].x,V[i].s/2,true};\n  }\n  upd(l,r,x,a,(b+a)>>1,i<<1);\n  upd(l,r,x,(b+a)>>1,b,(i<<1)+1);\n  V[i]={0,V[i<<1].s+V[(i<<1)+1].s,false};\n }\n\n LL sum(UL l,UL r,UL a=0,UL b=0,UL i=~0u){\n  if(i==~0u){ a=0; i=1; b=N; }\n  if(r<=a || b<=l) return 0;\n  if(l<=a && b<=r) return V[i].s;\n  if(V[i].z) return V[i].x*(min(r,b)-max(l,a));\n  LL q1=sum(l,r,a,(b+a)>>1,i<<1);\n  LL q2=sum(l,r,(b+a)>>1,b,(i<<1)+1);\n  return q1+q2;\n }\n\n} G;\n\nint main(){\n UL N,Q; scanf(\"%u%u\",&N,&Q);\n G.init(N);\n rep(q,Q){\n  UL c; scanf(\"%u\",&c);\n  if(c==0){\n   UL l,r; LL x; scanf(\"%u%u%lld\",&l,&r,&x);\n   G.upd(l,r+1,x);\n  }\n  if(c==1){\n   UL l,r; scanf(\"%u%u\",&l,&r);\n   printf(\"%lld\\n\",G.sum(l,r+1));\n  }\n }\n return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\nusing namespace std;\n\n// macros\n#define pb emplace_back\n#define mk make_pair\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define whole(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bit(n) (1LL<<(n))\n// functions\ntemplate <typename T> void unique(T& c){c.erase(std::unique(c.begin(), c.end()), c.end());}\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << \"(\" << p.first << \", \" << p.second << \")\"; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << \"(\" << itr->first << \", \" << itr->second << \")\"; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << \"(\" << itr->first << \", \" << itr->second << \")\"; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n//  types\nusing ll = long long int;\nusing P = pair<int, int>;\n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1000000007;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n// io\nstruct fast_io{\n  fast_io(){ios_base::sync_with_stdio(false); cin.tie(nullptr); cout << fixed << setprecision(20);}\n} fast_io_;\n\ntemplate <typename Monoid>\nclass LazySegmentTree{\n  public:\n    using T = typename Monoid::value_type;\n    using E = typename Monoid::lazy_type;\n    int n;\n    T identity;\n    E lazy_def;\n    vector<T> val;\n    vector<E> lazy;\n\n    LazySegmentTree(){}\n    LazySegmentTree(int n_, vector<T> v=vector<T>()){\n      identity = Monoid::identity;\n      lazy_def = Monoid::lazy_def;\n      n = 1;\n      while(n < n_)n *= 2;\n      val.assign(2*n-1, identity);\n      lazy.assign(2*n-1, lazy_def);\n\n      for(size_t i = 0; i < v.size(); i++){\n        val[i+n-1] = v[i];\n      }\n      for(int i = n - 2; i >= 0; i--){\n        val[i] = Monoid::operation(val[2*i+1], val[2*i+2]);\n      }\n    }\n    void eval(int k, int len){\n      if(lazy[k] == lazy_def)return;\n      if(k < n - 1){\n        lazy[2*k+1] = Monoid::lazy_accumulate(lazy[2*k+1], lazy[k]);\n        lazy[2*k+2] = Monoid::lazy_accumulate(lazy[2*k+2], lazy[k]);\n      }\n      val[k] = Monoid::lazy_update(val[k], lazy[k], len);\n      lazy[k] = lazy_def;\n    }\n    T update(int a,int b, E &e, int k, int l, int r){\n      eval(k, r - l);\n      if(r <= a || b <= l)return val[k];\n      else if(a <= l && r <= b){\n        lazy[k] = Monoid::lazy_accumulate(lazy[k], e);\n        eval(k, r - l);\n        return val[k];\n      }else{\n        T lv = update(a, b, e, 2*k+1, l, (l+r)/2);\n        T rv = update(a, b, e, 2*k+2, (l+r)/2, r);\n        return val[k] = Monoid::operation(lv, rv);\n      }\n    }\n    T update(int a, int b, E e){\n      return update(a, b, e, 0, 0, n);\n    }\n    T query(int a, int b, int k, int l, int r){\n      eval(k, r - l);\n      if(r <= a || b <= l)return identity;\n      if(a <= l && r <= b)return val[k];\n      T lv = query(a, b, 2*k+1, l, (l+r)/2);\n      T rv = query(a, b, 2*k+2, (l+r)/2, r);\n      return Monoid::operation(lv, rv);\n    }\n    T query(int a, int b){\n      return query(a, b, 0, 0, n);\n    }\n    T get(int i){\n      return query(i, i + 1);\n    }\n};\n\ntemplate <typename T, typename E>\nclass RSQRUQ{\n  public:\n    using value_type = T;\n    using lazy_type = E;\n    const static T identity = 0;\n    const static E lazy_def = numeric_limits<E>::min();\n    RSQRUQ(){}\n    static T operation(T &l, T &r){\n      return l + r;\n    }\n    static E lazy_accumulate(E &l, E &r){\n      return r;\n    }\n    static T lazy_update(T &t, E &e, int len){\n      return e * len;\n    }\n};\n\n\nint main(int argc, char const* argv[])\n{\n  int n, q; cin >> n >> q;\n  LazySegmentTree<RSQRUQ<ll, ll>> seg(n, vector<ll>(n, 0));\n  rep(i_, q){\n    int c; cin >> c;\n    if(c == 0){\n      int s, t; cin >> s >> t;\n      ll x; cin >> x;\n      seg.update(s, t + 1, x);\n    }else{\n      int s, t; cin >> s >> t;\n      cout << seg.query(s, t + 1) << endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <class T = long long, class U = long long>\nclass LazyST {\n   private:\n\tint n;\n\tint height = -1;\t  //木の高さ\n\tvector<T> data;\t\t  // monoid\n\tvector<U> lazy;\t\t  // operator\n\tT unit_data;\t\t  // monoid単位元\n\tU unit_lazy;\t\t  // operator単位元\n\tfunction<T(T, T)> f;  // monoid同士の演算\n\tfunction<T(T, U)> g;  // monoidとoperatorとの演算\n\tfunction<U(U, U)> h;  // operator同士の演算\n\tvoid propagate(int lef, int rig) {\n\t\t// 遅延させていた作用素を上から伝播させる [lef,rig)に有効な範囲で\n\t\tlef += n;\n\t\trig += n - 1;  //閉区間にする\n\t\tfor(int i = height; i > 0; i--) {\n\t\t\tint l = lef >> i;\n\t\t\tint r = rig >> i;\n\t\t\tlazy[l << 1] = h(lazy[l << 1], lazy[l]);\n\t\t\tlazy[l << 1 | 1] = h(lazy[l << 1 | 1], lazy[l]);\n\t\t\tdata[l] = g(data[l], lazy[l]);\n\t\t\tlazy[l] = unit_lazy;\n\t\t\tlazy[r << 1] = h(lazy[r << 1], lazy[r]);\n\t\t\tlazy[r << 1 | 1] = h(lazy[r << 1 | 1], lazy[r]);\n\t\t\tdata[r] = g(data[r], lazy[r]);\n\t\t\tlazy[r] = unit_lazy;\n\t\t}\n\t}\n\n   public:\n\t// 全て同じmonoid = init_dataで初期化\n\tLazyST(int _n, function<T(T, T)> ope_data_data, function<T(T, U)> ope_data_lazy, function<U(U, U)> ope_lazy_lazy, T _unit_data,\n\t\t   U _unit_lazy, T init_data)\n\t\t: n(_n), f(ope_data_data), g(ope_data_lazy), h(ope_lazy_lazy), unit_data(_unit_data), unit_lazy(_unit_lazy) {\n\t\tdata.assign(n * 2, unit_data);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tdata[i + n] = init_data;\n\t\t}\n\t\tfor(int i = n - 1; i > -1; i--) {\n\t\t\tdata[i] = f(data[i << 1], data[i << 1 | 1]);\n\t\t}\n\t\tlazy.assign(n * 2, unit_lazy);\n\t\tfor(int i = 1; i <= n; i *= 2) height++;\n\t}\n\t// 初期化配列をvectorで渡す\n\tLazyST(int _n, function<T(T, T)> ope_data_data, function<T(T, U)> ope_data_lazy, function<U(U, U)> ope_lazy_lazy, T _unit_data,\n\t\t   U _unit_lazy, vector<T> raw_data)\n\t\t: n(_n), f(ope_data_data), g(ope_data_lazy), h(ope_lazy_lazy), unit_data(_unit_data), unit_lazy(_unit_lazy) {\n\t\tdata.assign(n * 2, unit_data);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tdata[i + n] = raw_data[i];\n\t\t}\n\t\tfor(int i = n - 1; i > -1; i--) {\n\t\t\tdata[i] = f(data[i << 1], data[i << 1 | 1]);\n\t\t}\n\t\tlazy.assign(n * 2, unit_lazy);\n\t\tfor(int i = 1; i <= n; i *= 2) height++;\n\t}\n\n\tvoid update(int lef, int rig, U _operator) {  //[lef,rig)にopeを作用させる\n\t\tpropagate(lef, rig);\n\t\tlef += n;\n\t\trig += n;  //半開区間にする 下から上にdataを更新\n\t\tint L0 = lef / (lef & -lef);\n\t\tint R0 = rig / (rig & -rig);\n\t\twhile(lef < rig) {\n\t\t\tif(lef & 1) {\n\t\t\t\tlazy[lef] = h(lazy[lef], _operator);\n\t\t\t\t// data[lef >> 1] = f(g(data[lef - 1], lazy[lef - 1]), g(data[lef], lazy[lef]));\n\t\t\t\t// lazy[lef >> 1] = unit_lazy;\n\t\t\t\tlef++;\n\t\t\t}\n\t\t\tif(rig & 1) {\n\t\t\t\tlazy[rig - 1] = h(lazy[rig - 1], _operator);\n\t\t\t\t// data[(rig - 1) >> 1] = f(g(data[rig - 1], lazy[rig - 1]), g(data[rig], lazy[rig]));\n\t\t\t\t// lazy[(rig - 1) >> 1] = unit_lazy;\n\t\t\t\trig--;\n\t\t\t}\n\t\t\tlef >>= 1;\n\t\t\trig >>= 1;\n\t\t}\n\t\tlef = L0;\n\t\trig = R0;\n\t\twhile(lef > 1) {\n\t\t\tlef >>= 1;\n\t\t\tdata[lef] = f(g(data[lef << 1], lazy[lef << 1]), g(data[lef << 1 | 1], lazy[lef << 1 | 1]));\n\t\t\tlazy[lef] = unit_lazy;\n\t\t}\n\t\twhile(rig > 1) {\n\t\t\trig >>= 1;\n\t\t\tdata[rig] = f(g(data[rig << 1], lazy[rig << 1]), g(data[rig << 1 | 1], lazy[rig << 1 | 1]));\n\t\t\tlazy[rig] = unit_lazy;\n\t\t}\n\t}\n\n\tT get(int lef, int rig) {  //区間の値取得\n\t\tpropagate(lef, rig);\n\t\tT a = unit_data, b = unit_data;\n\t\tlef += n;\n\t\trig += n;\n\t\twhile(lef < rig) {\n\t\t\tif(lef & 1) a = f(a, g(data[lef], lazy[lef]));\n\t\t\tif(rig & 1) b = f(g(data[rig - 1], lazy[rig - 1]), b);\n\t\t\t(lef += 1) >>= 1;\n\t\t\trig >>= 1;\n\t\t}\n\t\treturn f(a, b);\n\t}\n};\n\n\n#pragma region macros_and_aliases\n#define rep(i, n) for(long long i = 0; i < (n); i++)\n#define rrep(i, n) for(long long i = (n)-1; i > -1; i--)\n#define Rep(i, m, n) for(long long i = (m); i < (n); i++)\n#define rRep(i, m, n) for(long long i = (n)-1; i >= (m); i--)\n#define REP(i, m, n, p) for(long long i = m; i < n; i += p)\n#define foa(s, v) for(auto &s : v)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define pq priority_queue\n#define bcnt(n) __builtin_popcountll(n)\n#define endk endl\n#define ednl endl\n#define enld endl\nusing ll = long long;\nusing ld = long double;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vvvll = vector<vvll>;\nusing vb = vector<bool>;\nusing mll = map<long long, long long>;\nusing pll = pair<long long, long long>;\nusing qll = queue<long long>;\nusing sll = set<long long>;\nusing vpll = vector<pair<long long, long long>>;\ntemplate <class T = ll>\nusing V = vector<T>;\ntemplate <class T = ll>\nusing VV = V<V<T>>;\ntemplate <class T = ll>\nusing VVV = V<V<V<T>>>;\n//昇順pq(小さい方から取り出す)\ntemplate <class T = ll>\nusing pqup = priority_queue<T, vector<T>, greater<T>>;\n//降順pq(大きい方から取り出す)\ntemplate <class T = ll>\nusing pqdn = priority_queue<T>;\n#define debug(var)              \\\n\tstd::cout << #var << \" : \"; \\\n\tview(var)\ntemplate <typename T>\nvoid view(T e) {\n\tstd::cout << e << std::endl;\n}\ntemplate <typename T>\nvoid view(const std::vector<T> &v) {\n\tfor(const auto &e : v) {\n\t\tstd::cout << e << \" \";\n\t}\n\tstd::cout << std::endl;\n}\ntemplate <typename T>\nvoid view(const std::vector<std::vector<T>> &vv) {\n\tfor(const auto &v : vv) {\n\t\tview(v);\n\t}\n}\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n\tos << p.first << \" \" << p.second;\n\treturn os;\n}\ntemplate <typename T1, typename T2>\nistream &operator>>(istream &is, pair<T1, T2> &p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\n#pragma endregion\n\nint main() {\n\tll dekai = 3e16;\n\tll unit_upd = -dekai;  // upd,PairUpdの単位元\n\t// <要素合計,個数>のpairの単位元\n\tpair<long long, long long> unit_pair = {0, 0};\n\t// pairの初期化要素\n\tpair<long long, long long> init_pair = {0, 1};\n\n\t//単位元 = 0\n\tauto add = [](ll a, ll b) { return a + b; };\n\t// 単位元 = dekai\n\tauto mini = [](ll a, ll b) { return min(a, b); };\n\t// 単位元 = -dekai\n\tauto maxi = [](ll a, ll b) { return max(a, b); };\n\n\tauto PairPlusPair = [](pll a, pll b) { return (pll){a.first + b.first, a.second + b.second}; };\n\tauto PairPlusLL = [](pll a, ll b) { return (pll){a.first + b * a.second, a.second}; };\n\tauto PairUpd = [&](pll a, ll b) {\n\t\tif(b != unit_upd) return (pll){b * a.second, a.second};\n\t\treturn a;\n\t};\n\n\tauto upd = [&](ll a, ll b) { return b == unit_upd ? a : b; };\n\n\tll n, q;\n\tcin >> n >> q;\n\tint index = 0;\n\t// pll = <合計値、個数>\n\tvector<pll> vec(n, init_pair);\n\tLazyST<pll, ll> st(n, PairPlusPair, PairUpd, upd, unit_pair, unit_upd, vec);\n\n\tvll ans;\n\trep(i, q) {\n\t\t// debug(st.data);\n\t\t// debug(st.lazy);\n\t\tint kind;\n\t\tcin >> kind;\n\t\tll s, t;\n\t\tcin >> s >> t;\n\t\tif(index == 1)\n\t\t\ts--;\n\t\telse\n\t\t\tt++;\n\t\tif(kind) {\n\t\t\tpll k = st.get(s, t);\n\t\t\tans.push_back(k.first);\n\t\t} else {\n\t\t\tll x;\n\t\t\tcin >> x;\n\t\t\tst.update(s, t, x);\n\t\t}\n\t}\n\t// debug(st.data);\n\t// debug(st.lazy);\n\tfoa(t, ans) cout << t << enld;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\ntemplate<typename T, typename E> struct LazySegmentTree {\n  using F = function<T(T, T)>;\n  using G = function<T(T, E)>;\n  using H = function<E(E, E)>;\n  using P = function<E(E, int)>;\n\n  int n;\n  T ti;\n  E ei;\n  F f;\n  G g;\n  H h;\n  P p;\n  vector<T> data;\n  vector<E> lazy;\n\n  LazySegmentTree(int n_, F f, G g, H h, T ti = INT_MAX, E ei = INT_MAX,\n                  vector<T> v = vector<T>(), P p = [](E a, int b) { return a; })\n      : f(f), g(g), h(h), ti(ti), ei(ei), p(p) {\n    init(n_);\n    if (n_ == (int)v.size()) build(v);\n  }\n  void init(int n_) {\n    n = 1;\n    while (n < n_) n *= 2;\n    data.assign(n * 2 - 1, ti);\n    lazy.assign(n * 2 - 1, ei);\n  }\n  void build(vector<T> v) {\n    for (int i = 0; i < v.size(); ++i) data[i + n - 1] = v[i];\n    for (int i = n - 2; i >= 0; --i) {\n      data[i] = f(data[i * 2 + 1], data[i * 2 + 2]);\n    }\n  }\n  inline void eval(int len, int k) {\n    if (lazy[k] == ei) return;\n    if (k * 2 + 1 < n * 2 - 1) {\n      lazy[k * 2 + 1] = h(lazy[k * 2 + 1], lazy[k]);\n      lazy[k * 2 + 2] = h(lazy[k * 2 + 2], lazy[k]);\n    }\n    data[k] = g(data[k], p(lazy[k], len));\n    lazy[k] = ei;\n  }\n  T update(int a, int b, E x, int k = 0, int l = 0, int r = -1) {\n    if (r < 0) r = n;\n    eval(r - l, k);\n    if (b <= l || r <= a) return data[k];\n    if (a <= l && r <= b) {\n      lazy[k] = h(lazy[k], x);\n      return g(data[k], p(lazy[k], r - l));\n    }\n    T vl = update(a, b, x, k * 2 + 1, l, (l + r) / 2);\n    T vr = update(a, b, x, k * 2 + 2, (l + r) / 2, r);\n    return data[k] = f(vl, vr);\n  }\n  T query(int a, int b, int k = 0, int l = 0, int r = -1) {\n    if (r < 0) r = n;\n    eval(r - l, k);\n    if (b <= l || r <= a) return ti;\n    if (a <= l && r <= b) return data[k];\n    T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n    T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n    return f(vl, vr);\n  }\n};\n\nconst ll INF = 1e12;\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  LazySegmentTree<ll, ll>::F f = plus<ll>();\n  LazySegmentTree<ll, ll>::G g = [](ll a, ll b) { return (b == INF) ? a : b; };\n  LazySegmentTree<ll, ll>::H h = [](ll a, ll b) { return (b == INF) ? a : b; };\n  LazySegmentTree<ll, ll>::P p = [](ll a, int b) { return (a == INF) ? a : a * b; };\n\n  int n, q; cin >> n >> q;\n  LazySegmentTree<ll, ll> seg(n, f, g, h, 0, INF, vector<ll>(), p);\n\n  while (q--) {\n    int com; cin >> com;\n    if (com) {\n      int s, t; cin >> s >> t;\n      cout << seg.query(s, t + 1) << endl;\n    } else {\n      int s, t, x; cin >> s >> t >> x;\n      seg.update(s, t + 1, x);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T> void assign(V<T>& v, int n, const T& a = T()) { v.assign(n, a); }\ntemplate<class T, class... U> void assign(V<T>& v, int n, const U&... u) { v.resize(n); for (auto&& i : v) assign(i, u...); }\n\nstruct M {\n  using T = struct mms { lint min, max, sum; mms(lint a = numeric_limits<lint>::max(), lint b = numeric_limits<lint>::min(), lint c = 0) : min(a), max(b), sum(c) {} };\n  using U = struct lf { lint a, b; lf(lint a = 1, lint b = 0) : a(a), b(b) {} };\n  static T op(const T& a, const T& b) { return T{min(a.min, b.min), max(a.max, b.max), a.sum + b.sum}; }\n  static const T e() { return T(); }\n  static void ap(T& a, const U& g, lint k) {\n    a.min = g.a * a.min + g.b;\n    a.max = g.a * a.max + g.b;\n    if (g.a < 0) swap(a.min, a.max);\n    a.sum = g.a * a.sum + k * g.b;\n  }\n  static void ap(U& f, const U& g) { f.a *= g.a; f.b = g.a * f.b + g.b; }\n  static const U id() { return U(); }\n};\n\ntemplate<class M> struct ST {\n  using T = typename M::T;\n  using U = typename M::U;\n  lint n;\n  unordered_map<lint, T> t;\n  unordered_map<lint, U> u;\n\n  ST(lint n) : n(1LL << 8 * sizeof(lint) - __builtin_clzll(max(n - 1, 1LL))) {}\n\n  void _ap(lint i, const U& f) {\n    M::ap(t[i], f, 1 << __builtin_clzll(i) - __builtin_clzll(n));\n    if (i < n) M::ap(u[i], f);\n  }\n\n  T get(lint l, lint r) {\n    _push(l, r);\n    T resl = M::e(), resr = M::e();\n    for (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n      if (l & 1) resl = M::op(resl, t[l++]);\n      if (r & 1) resr = M::op(t[--r], resr);\n    }\n    return M::op(resl, resr);\n  }\n\n  void _push(lint l, lint r) {\n    for (lint hl = 8 * sizeof(lint) - __builtin_clzll(l + n) - 1, hr = 8 * sizeof(lint) - __builtin_clzll(r - 1 + n) - 1; hr > 0; hl--, hr--) {\n      lint i = r - 1 + n >> hr;\n      _ap(2 * i, u[i]);\n      _ap(2 * i + 1, u[i]);\n      u[i] = M::id();\n      i = l + n >> hl;\n      if (i == r - 1 + n >> hr or i >= n) continue;\n      _ap(2 * i, u[i]);\n      _ap(2 * i + 1, u[i]);\n      u[i] = M::id();\n    }\n  }\n\n  void set(lint l, lint r, const U& f) {\n    _push(l, r);\n    for (lint i = l + n, j = r + n; i < j; i >>= 1, j >>= 1) {\n      if (i & 1) _ap(i++, f);\n      if (j & 1) _ap(--j, f);\n    }\n    for (l += n; !(l & 1);) l >>= 1;\n    while (l >>= 1) t[l] = M::op(t[2 * l], t[2 * l + 1]);\n    for (r += n; !(r & 1);) r >>= 1;\n    while (r >>= 1) t[r] = M::op(t[2 * r], t[2 * r + 1]);\n  }\n};\n\nint main() {\n  cin.tie(NULL); ios::sync_with_stdio(false);\n  int n, q; cin >> n >> q;\n  ST<M> st(n);\n  for (int i = 0; i < q; i++) {\n    int t; cin >> t;\n    if (t) {\n      int l, r; cin >> l >> r;\n      cout << st.get(l, r + 1).sum << '\\n';\n    } else {\n      int l, r, x; cin >> l >> r >> x;\n      st.set(l, r + 1, M::U(0, x));\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass segment_tree{\n    vector<int64_t> val;\n    vector<pair<int64_t, int64_t>> op;\n    vector<pair<size_t, size_t>> range;\n\n    #define f(x,y) ((x)+(y))\n    #define target_width (range[target].second - range[target].first)\n    const int64_t def_value = 0;\n    const pair<int64_t, int64_t> ident = {1, 0};\n\n    size_t N, depth;\n\n    inline void merge(size_t target, int64_t alpha, int64_t beta){\n        op[target] = {op[target].first * alpha, op[target].second * alpha + beta};\n    }\n    inline void propagate(size_t target){\n        if(op[target] == ident) return;\n        val[target] = op[target].first * val[target] + op[target].second * target_width;\n        if(target  < N){\n            merge(2*target, op[target].first, op[target].second);\n            merge(2*target+1, op[target].first, op[target].second);\n        }\n        op[target] = ident;\n    }\n    \n    inline void eval(int n){\n        stack<size_t> stk;\n        for(;n>0;n>>=1) stk.push(n);\n        while(!stk.empty()){\n            propagate(stk.top());\n            stk.pop();\n        }\n    }\n    inline void get_target(vector<size_t> &target, size_t left, size_t right, stack<size_t> *refresh=nullptr){\n        queue<size_t> partial;\n        \n        if(left <= 0 && right >= N) target.push_back(1);\n        else partial.push(1);\n\n        while(!partial.empty()){\n            size_t i = partial.front();\n            if(refresh != nullptr) refresh->push(i);\n            partial.pop();\n\n            propagate(i);\n\n            if(left <= range[i].first){\n                if(right < range[i*2].second) partial.push(i*2);\n                else{\n                    target.push_back(i*2);\n                    if(range[i*2+1].first < right) partial.push(i*2+1);\n                }\n            }else{\n                if(left < range[i*2].second){\n                    partial.push(i*2);\n                    if(range[i*2+1].second <= right) target.push_back(i*2+1);\n                    else if(range[i*2].second < right) partial.push(i*2+1); \n                }else{\n                    if(left <= range[i*2+1].first && range[i*2+1].second <= right) target.push_back(i*2+1);\n                    else partial.push(i*2+1);\n                }\n            }\n        }\n    }\npublic:\n    segment_tree(size_t n){\n        for(depth=0;(1ULL<<depth)<n;depth++);\n        N = 1ULL<<depth;\n        val.reserve(1ULL<<(++depth));\n        op.reserve(1ULL<<depth);\n        range.reserve(1ULL<<depth);\n        for(size_t i=2*N-1;i>0;i--){\n            val[i] = def_value;\n            op[i] = ident;\n            if(i>=N) range[i] = {i-N, i-N+1};\n            else range[i] = {range[2*i].first, range[2*i+1].second};\n        }\n    }\n    int64_t operator[](size_t i){\n        eval(N+i);\n        return val[N+i];\n    }\n    void operate(int64_t alpha, int64_t beta, size_t left, size_t right){\n        if(right <= left) return;\n\n        vector<size_t> target;\n        stack<size_t> refresh;\n        get_target(target, left, right, &refresh);\n        for(auto i : target){\n            merge(i, alpha, beta);\n            propagate(i);\n        }\n        while(!refresh.empty()){\n            size_t i = refresh.top();\n            refresh.pop();\n            propagate(i*2);\n            propagate(i*2+1);\n            val[i] = f(val[i*2], val[i*2+1]);\n        }\n    }\n    int64_t get_sum(size_t left, size_t right){\n        if(right <= left) return 0;\n        \n        vector<size_t> target;\n        get_target(target, left, right);\n        int64_t ret = 0;\n        for(auto i : target){\n            propagate(i);\n            ret = f(ret, val[i]);\n        }\n        return ret;\n    }\n    void update(int64_t val, size_t pos){\n        operate(0, val, pos, pos+1);\n    }\n    void update(int64_t val, size_t left, size_t right){\n        operate(0, val, left, right);\n    }\n    void add(int64_t val, size_t pos){\n        operate(1, val, pos, pos+1);\n    }\n    void add(int64_t val, size_t left, size_t right){\n        operate(1, val, left, right);\n    }\n\n    void dump(){\n        for(int i=1;i<2*N;i++){\n            cerr << val[i] << \"(\" << op[i].first << \",\" << op[i].second << \")\\t\";\n            if(__builtin_popcount(i+1)==1) cerr << endl;\n        }\n    }\n    #undef f\n    #undef target_width\n};\n\nint main(){\n    int n, q;\n    cin >> n >> q;\n    segment_tree st(n);\n\n    for(int i=0;i<q;i++){\n        int com;\n        cin >> com;\n        if(com == 0){\n            int s, t, x;\n            cin >> s >> t >> x;\n            st.update(x, s, t+1);\n        }else{\n            int s, t;\n            cin >> s >> t;\n            cout << st.get_sum(s, t+1) << endl;\n        }\n        //st.dump();\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <functional>\n#include <vector>\n\ntemplate<typename Monoid, typename OperatorMonoid = Monoid>\nclass lazy_segment_tree {\n\tusing value_type = Monoid;\n\tusing operator_type = OperatorMonoid;\n\tusing size_type = size_t;\n\n\tusing F = std::function<value_type (value_type, value_type)>;\n\tusing G = std::function<value_type (value_type, operator_type, int, int)>;\n\tusing H = std::function<operator_type (operator_type, operator_type)>;\n\t\n\tsize_type size_;\n\tsize_type height_;\n\n\tF f;\n\tG g;\n\tH h;\n\tvalue_type id;\n\toperator_type id_op;\n\tstd::vector<value_type> data;\n\tstd::vector<operator_type> lazy;\n\tstd::vector<size_type> depth;\n\t\n\tconst size_type get_height(const size_type& size) const {\n\t\tsize_type height = 1;\n\t\twhile(1 << height < size) height++;\n\t\treturn height;\n\t}\n\tconst size_type base_size() const {\n\t\treturn 1 << height_;\n\t}\n\tconst value_type reflect(const size_type & k) {\n\t\tif(lazy[k] == id_op) return data[k];\n\t\tint l = (k - (1 << depth[k])) * (base_size() >> depth[k]);\n\t\tint r = l + (base_size() >> depth[k]);\n\t\treturn g(data[k], lazy[k], l, r);\n\t}\n\tvoid eval(const size_type & k) {\n\t\tif(lazy[k] == id_op) return;\n\t\tlazy[k << 1 ^ 0] = h(lazy[k << 1 ^ 0], lazy[k]);\n\t\tlazy[k << 1 ^ 1] = h(lazy[k << 1 ^ 1], lazy[k]);\n\t\tdata[k] = reflect(k);\n\t\tlazy[k] = id_op;\n\t}\n\tvoid thrust(const size_type & k) {\n\t\tfor(int i = height_; i; i--) eval(k >> i);\n\t}\n\tvoid recalc(size_type k) {\n\t\twhile(k >>= 1) data[k] = f(reflect(k << 1 ^ 0), reflect(k << 1 ^ 1));\n\t}\n\t\n\tpublic:\n\tlazy_segment_tree() {}\n\tlazy_segment_tree(int n, const F & f, const G & g, const H & h, const value_type & id, const operator_type & id_op) :\n\t\tsize_(n), f(f), g(g), h(h), id(id), id_op(id_op) {\n\t\theight_ = get_height(size_);\n\t\tdata.assign(base_size() << 1, id);\n\t\tlazy.assign(base_size() << 1, id_op);\n\t\tdepth.assign(base_size() << 1, 0);\n\t\tfor(int i = 0; i < height_ + 1; i++)\n\t\t\tfor(int j = (1 << i); j < (1 << (i + 1)); j++)\n\t\t\t\tdepth[j] = i;\n\t}\n\tvoid update(size_type a, size_type b, operator_type x) {\n\t\tthrust(a += base_size());\n\t\tthrust(b += base_size() - 1);\n\t\tfor(size_type l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n\t\t\tif(l & 1) lazy[l] = h(lazy[l], x), l++;\n\t\t\tif(r & 1) --r, lazy[r] = h(lazy[r], x);\n\t\t}\n\t\trecalc(a);\n\t\trecalc(b);\n\t}\n\tvoid change(size_type k, const value_type x) {\n\t\tthrust(k += base_size());\n\t\tdata[k] = x;\n\t\tlazy[k] = id_op;\n\t\trecalc(k);\n\t}\n\tconst value_type fold(size_type a, size_type b) {\n\t\tthrust(a += base_size());\n\t\tthrust(b += base_size() - 1);\n\n\t\tvalue_type left_value = id;\n\t\tvalue_type right_value = id;\n\t\tfor(size_type l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n\t\t\tif(l & 1) left_value = f(left_value, reflect(l++));\n\t\t\tif(r & 1) right_value = f(reflect(--r), right_value);\n\t\t}\n\t\treturn f(left_value, right_value);\n\t}\n\n\tconst value_type operator[](const size_type & k) {\n\t\treturn fold(k, k + 1);\n\t}\n};\n\nusing i64 = long long;\n\nint main() {\n\tint n, q; scanf(\"%d%d\", &n, &q);\n\n\tauto f = [](i64 a, i64 b) { return a + b; };\n\tauto g = [](i64 a, i64 b, int l, int r) { return b * (i64)(r - l); };\n\tauto h = [](i64 a, i64 b) { return b; };\n\tlazy_segment_tree<i64> seg(n, f, g, h, 0, 1 << 30);\n\t\n\twhile(q--) {\n\t\tint type; scanf(\"%d\", &type);\n\n\t\tif(type == 0) {\n\t\t\tint s, t, x; scanf(\"%d%d%d\", &s, &t, &x);\n\n\t\t\tseg.update(s, t + 1, x);\n\t\t} else if(type == 1) {\n\t\t\tint s, t; scanf(\"%d%d\", &s, &t);\n\t\t\t\n\t\t\tprintf(\"%lld\\n\", seg.fold(s, t + 1));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\ntypedef pair<P, long long int> P2;\n\nlong long int INF = 1e18;\nlong long int MOD = 1e9 + 7;\nint const TREE_SIZE = 1 << 20;\nlong long int seg_tree[TREE_SIZE];\nbool is_a[TREE_SIZE];\n\nint getsum(int a, int b, int index, int l, int r){\n\t\n\tif(r <= a || b <= l){\n\t\treturn 0;\n\t}\n\tif(a <= l && r <= b){\n\t\treturn seg_tree[index];\n\t}\n\tif(is_a[index]){\n\t\treturn seg_tree[index] / (r - l) * (min(r, b) - max(l, a));\n\t}\n\tint ret = 0;\n\tret += getsum(a, b, index * 2, l, (l + r) / 2);\n\tret += getsum(a, b, index * 2 + 1, (l + r) / 2, r);\n\treturn ret;\n}\n\nint update(int a, int b, int index, long long int num, int l, int r){\n\t\n\t// [a, b) を num に変更する\n\t\n\tif(r <= a || b <= l){\n\t\treturn seg_tree[index];\n\t}\n\tif(a <= l && r <= b){\n\t\tseg_tree[index] = num * (r - l);\n\t\tis_a[index] = true;\n\t\treturn seg_tree[index];\n\t}\n\tint ret = 0;\n\tif(is_a[index]){\n\t\tis_a[index * 2] = true;\n\t\tseg_tree[index * 2] = seg_tree[index] / 2;\n\t\tis_a[index * 2 + 1] = true;\n\t\tseg_tree[index * 2 + 1] = seg_tree[index] / 2;\n\t\tis_a[index] = false;\n\t}\n\tret += update(a, b, index * 2, num, l, (l + r) / 2);\n\tret += update(a, b, index * 2 + 1, num, (l + r) / 2, r);\n\treturn seg_tree[index] = ret;\n}\n\nint main(){\n\tint n, q;\n\tcin >> n >> q;\n\t\n\tfor(int i = 0; i < q; i++){\n\t\tlong long int num, a, b, c;\n\t\tcin >> num;\n\t\tif(num == 0){\n\t\t\tcin >> a >> b >> c;\n\t\t\tupdate(a, b + 1, 1, c, 0, TREE_SIZE / 2);\n\t\t}else{\n\t\t\tcin >> a >> b;\n\t\t\tcout << getsum(a, b + 1, 1, 0, TREE_SIZE / 2) << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <iomanip>\n\n#define int long long int\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 1e15;\nconst int MOD = 1e9+7;\n\ntemplate <typename T>\nclass lazy_segment_tree{\n    private:\n        static int calc_size(int n){\n            int m = 1;\n            while(m < n){\n                m *= 2;\n            }\n            return m;\n        }\n\n        void eval(int i, int l, int r){\n            if(lazy[i] != INF){\n                node[i] = lazy[i];\n                if(r - l > 1){\n                    lazy[i * 2 + 1] = lazy[i] / 2;\n                    lazy[i * 2 + 2] = lazy[i] / 2;\n                }\n                lazy[i] = INF;\n            }\n        }\n\n        void update(int s, int t, int x, int i, int l, int r){\n            eval(i, l, r);\n\n            if(t <= l || r <= s){\n                return ;\n            }\n\n            if(s <= l && r <= t){\n                lazy[i] = (r - l) * x;\n                eval(i, l, r);\n                return;\n            }\n\n            int m = l + (r - l) / 2;\n            update(s, t, x, 2 * i + 1, l, m);\n            update(s, t, x, 2 * i + 2, m, r);\n            node[i] = f(node[2 * i + 1], node[2 * i + 2]);\n        }\n\n        T query(int s, int t, int i, int l, int r){\n            eval(i, l, r);\n\n            if(t <= l || r <= s){\n                return init;\n            }\n\n            if(s <= l && r <= t){\n                return node[i];\n            }\n\n            int m = l + (r - l) / 2;\n            T vl = query(s, t, i * 2 + 1, l, m);\n            T vr = query(s, t, i * 2 + 2, m, r);\n            return f(vl, vr);\n        }\n\n    public:\n        int n;\n        vector<T> node, lazy;\n        T init;\n        function<T(T, T)> f;\n\n        lazy_segment_tree(int n, T init, function<T(T, T)> f)\n            : n(calc_size(n)), node(calc_size(n) * 2, init) , lazy(calc_size(n) * 2, INF), init(init), f(f) {}\n\n        T query(int s, int t){\n            return query(s, t, 0, 0, n);\n        }\n\n        void update(int s, int t, int x){\n            update(s, t, x, 0, 0, n);\n        }\n};\n\nsigned main(){\n    int n, q;\n    cin >> n >> q;\n\n    lazy_segment_tree<int> lst(n, 0, [](int a, int b){return a+b;});\n\n    rep(i, q){\n        int que, s, t;\n        cin >> que >> s >> t;\n\n        if(que == 0){\n            int x;\n            cin >> x;\n            lst.update(s, t+1, x);\n        }else{\n            cout << lst.query(s, t+1) << endl;\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i = 0; i < n; i++)\ntemplate<typename DATA_TYPE, typename LAZY_TYPE, typename F, typename G, typename H>\nclass SegmentTree {\n  private:\n\tsize_t size;\n\n\tF f;\n\tG g;\n\tH h;\n\n\tstd::vector<DATA_TYPE> data;\n\tstd::vector<LAZY_TYPE> lazy;\n\tDATA_TYPE data_init;\n\tLAZY_TYPE lazy_init;\n\n\tSegmentTree() : size(0) {}\n\n\tvoid eval(int length, size_t index) {\n\t\tif (lazy[index] == lazy_init) return;\n\t\tif (index * 2 + 1 < size * 2 - 1) {\n\t\t\tlazy[index * 2 + 1] = h(lazy[index * 2 + 1], lazy[index]);\n\t\t\tlazy[index * 2 + 2] = h(lazy[index * 2 + 2], lazy[index]);\n\t\t}\n\t\tdata[index] = g(data[index], lazy[index], length);\n\t\tlazy[index] = lazy_init;\n\t}\n\n\tDATA_TYPE update(size_t begin, size_t end, LAZY_TYPE update_value, size_t index, size_t left, size_t right) {\n\t\teval(right - left, index);\n\t\tif (right <= begin || end <= left) return data[index];\n\t\tif (begin <= left && right <= end) {\n\t\t\tlazy[index] = h(lazy[index], update_value);\n\t\t\treturn g(data[index], lazy[index], right - left);\n\t\t}\n\t\treturn data[index] = f(update(begin, end, update_value, index * 2 + 1, left, (left + right) / 2), update(begin, end, update_value, index * 2 + 2, (left + right) / 2, right));\n\t}\n\n\tDATA_TYPE query(size_t begin, size_t end, size_t index, size_t left, size_t right) {\n\t\teval(right - left, index);\n\t\tif (right <= begin || end <= left) return data_init;\n\t\tif (begin <= left && right <= end) return data[index];\n\t\treturn f(query(begin, end, index * 2 + 1, left, (left + right) / 2), query(begin, end, index * 2 + 2, (left + right) / 2, right));\n\t}\n\n  public:\n\tSegmentTree(size_t data_size, F f, G g, H h, DATA_TYPE data_init, LAZY_TYPE lazy_init) : f(f), g(g), h(h), data_init(data_init), lazy_init(lazy_init) {\n\t\tsize = 1;\n\t\twhile (size < data_size) size <<= 1U;\n\t\tdata.resize(2 * size - 1, data_init);\n\t\tlazy.resize(2 * size - 1, lazy_init);\n\t}\n\n\tvoid build(std::vector<DATA_TYPE> input_data) {\n\t\tif (input_data.size() > size) {\n\t\t\tstd::cerr << \"segment tree::build : input oversize data\\n\";\n\t\t\texit(-1);\n\t\t}\n\t\tfor (int i = 0; i < input_data.size(); ++i) {\n\t\t\tdata[i + size - 1] = input_data[i];\n\t\t}\n\t\tfor (int i = size - 2; i >= 0; --i) {\n\t\t\tdata[i] = f(data[i * 2 + 1], data[i * 2 + 2]);\n\t\t}\n\t}\n\n\tvoid update(size_t begin, size_t end, LAZY_TYPE update_value) {\n\t\tupdate(begin, end, update_value, 0, 0, size);\n\t}\n\n\tDATA_TYPE query(size_t begin, size_t end) {\n\t\treturn query(begin, end, 0, 0, size);\n\t}\n};\nsigned main(signed argc, char* argv[]) {\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tauto f = [](int a, int b) { return a + b; };\n    auto g = [](int a, int b, size_t len) { return b == INT_MIN ? a : b * len; };\n\tauto h = [](int a, int b) { return b == INT_MIN ? a : b; };\n\tint n, q;\n\tcin >> n >> q;\n\tSegmentTree<int, int, decltype(f), decltype(g), decltype(h)> segTree(n, f, g, h, 0, INT_MIN);\n\trep(i, q) {\n\t\tint qt;\n\t\tcin >> qt;\n\t\tif (qt) {\n\t\t\tint s, t;\n\t\t\tcin >> s >> t;\n\t\t\tcout << segTree.query(s, t + 1) << endl;\n\t\t}\n\t\telse {\n\t\t\tint s, t, x;\n\t\t\tcin >> s >> t >> x;\n\t\t\tsegTree.update(s, t + 1, x);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n    out<<'['; for(T i: a) {out<<i<<',';} out<<']'; return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\ntemplate<class T, class E=T>\nstruct RBST {\n    using F = function<T(T,T)>;\n    using G = function<T(T,E)>;\n    using H = function<E(E,E)>;\n    using P = function<E(E,int)>;\n\n    const F f; const G g; const H h; const P p;\n    const T dt; const E de;\n\n    struct node {\n        node *l, *r;\n        T val, sum;\n        E lazy;\n        bool rev;\n        int sz;\n\n        node(T v, E p) : l(nullptr),r(nullptr),val(v),sum(v),lazy(p),rev(false),sz(1) {}\n    };\n\n    RBST(F f, T dt) :\n        f(f), g(G()), h(H()), p(P()), dt(dt), de(E()) {}\n    RBST(F f, G g, H h, P p, T dt, E de) :\n        f(f), g(g), h(h), p(p), dt(dt), de(de) {}\n\n    // 子を操作したあとに呼ぶ\n    node* fix(node* a) {\n        a->sz = size(a->l) + 1 + size(a->r);\n        a->sum = f(f(sum(a->l), a->val), sum(a->r));\n        return a;\n    }\n    // valとsumを操作したあとに呼ぶ\n    void eval(node* a) {\n        if(a->lazy != de) {\n            a->val = g(a->val, a->lazy);\n            a->sum = g(a->sum, p(a->lazy, a->sz));\n            if(a->l != nullptr) a->l->lazy = h(a->l->lazy, a->lazy);\n            if(a->r != nullptr) a->r->lazy = h(a->r->lazy, a->lazy);\n            a->lazy = de;\n        }\n        if(a->rev) {\n            std::swap(a->l, a->r);\n            if(a->l != nullptr) a->l->rev ^= 1;\n            if(a->r != nullptr) a->r->rev ^= 1;\n            a->rev = false;\n        }\n    }\n    T sum(node* a) { return a == nullptr ? dt : (eval(a), a->sum); }\n    int size(node* a) { return a == nullptr ? 0 : a->sz; }\n\n    inline int xor128() {\n        static int x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n        int t;\n        t = x ^ (x << 11); x = y; y = z; z = w;\n        return w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n    }\n\n    node* merge(node* a, node* b) {\n        if(a == nullptr) return b;\n        if(b == nullptr) return a;\n        eval(a); eval(b);\n        if(xor128() % (size(a) + size(b)) < size(a)) {\n            a->r = merge(a->r, b);\n            return fix(a);\n        } else {\n            b->l = merge(a, b->l);\n            return fix(b);\n        }\n    }\n    // [0,k) [k,n)\n    pair<node*, node*> split(node* a, int k) {\n        if(a == nullptr) return pair<node*, node*>(nullptr, nullptr);\n        eval(a);\n        node *sl, *sr;\n        if(k <= size(a->l)) {\n            std::tie(sl, sr) = split(a->l, k);\n            a->l = sr;\n            return pair<node*, node*>(sl, fix(a));\n        } else {\n            std::tie(sl, sr) = split(a->r, k - size(a->l) - 1);\n            a->r = sl;\n            return pair<node*, node*>(fix(a), sr);\n        }\n    }\n    // 要素の挿入/削除\n    void insert(node*& a, int k, const T& x) {\n        node *sl, *sr;\n        std::tie(sl, sr) = split(a, k);\n        a = merge(sl, merge(new node(x, de), sr));\n    }\n    T erase(node*& a, int k) {\n        node *sl, *sr, *tl, *tr;\n        std::tie(sl, sr) = split(a, k + 1);\n        std::tie(tl, tr) = split(sl, k);\n        a = merge(tl, sr);\n        return tr->val;\n    }\n    // 点代入\n    void set_element(node*& a, int k, const T& x) {\n        node *sl, *sr, *tl, *tr;\n        std::tie(sl, sr) = split(a, k + 1);\n        std::tie(tl, tr) = split(sl, k);\n        if(tr != nullptr) tr->val = tr->sum = x;\n        a = merge(merge(tl, tr), sr);\n    }\n    // 区間更新\n    void update(node*& a, int l, int r, const E& m) {\n        node *sl, *sr, *tl, *tr;\n        std::tie(sl, sr) = split(a, r);\n        std::tie(tl, tr) = split(sl, l);\n        if(tr != nullptr) tr->lazy = h(tr->lazy, m);\n        a = merge(merge(tl, tr), sr);\n    }\n    // 点取得\n    T get(node*& a, int k) {\n        node *sl, *sr, *tl, *tr;\n        std::tie(sl, sr) = split(a, k + 1);\n        std::tie(tl, tr) = split(sl, k);\n        T res = tr == nullptr ? dt : tr->val;\n        a = merge(merge(tl, tr), sr);\n        return res;\n    }\n    // 区間クエリ\n    T query(node*& a, int l, int r) {\n        node *sl, *sr, *tl, *tr;\n        std::tie(sl, sr) = split(a, r);\n        std::tie(tl, tr) = split(sl, l);\n        T res = tr == nullptr ? dt : tr->sum;\n        a = merge(merge(tl, tr), sr);\n        return res;\n    }\n    // 区間[l,r)の反転\n    void reverse(node*& a, int l, int r) {\n        node *sl, *sr, *tl, *tr;\n        std::tie(sl, sr) = split(a, r);\n        std::tie(tl, tr) = split(sl, l);\n        if(tr != nullptr) tr->rev ^= 1;\n        a = merge(merge(tl, tr), sr);\n    }\n    // デバッグ用\n    void debug(node* t) {\n        if(t == nullptr) return;\n        cout << \"{\";\n        debug(t->l);\n        cout << \" \" << t->val << \" \";\n        debug(t->r);\n        cout << \"}\";\n    }\n    void dump(node *r, typename vector< T >::iterator &it) {\n        if(!r) return;\n        eval(r);\n        dump(r->l, it);\n        *it = r->val;\n        dump(r->r, ++it);\n    }\n    vector<T> dump(node *r) {\n        vector<T> v((size_t) size(r));\n        auto it = begin(v);\n        dump(r, it);\n        return v;\n    }\n};\n\ntemplate<class T>\nstruct OrderedMultiSet : RBST<T> {\n    using node = typename RBST<T>::node;\n\n    OrderedMultiSet() : RBST<T>([&](T x, T y) { return x; }, T()) {}\n\n    // k番目の要素を求める\n    T kth_element(node *t, int k) {\n        if(k < RBST<T>::size(t->l)) return kth_element(t->l, k);\n        if(k == RBST<T>::size(t->l)) return t->val;\n        return kth_element(t->r, k - RBST<T>::size(t->l) - 1);\n    }\n    // 要素xを追加する\n    virtual void insert_key(node *&t, const T &x) {\n        RBST<T>::insert(t, lower_bound(t, x), x);\n    }\n    // 要素xを消す\n    void erase_key(node *&t, const T &x) {\n        if(!count(t, x)) return;\n        RBST<T>::erase(t, lower_bound(t, x));\n    }\n    // xの個数\n    int count(node *t, const T &x) {\n        return upper_bound(t, x) - lower_bound(t, x);\n    }\n    // x以上の最小の位置\n    int lower_bound(node *t, const T &x) {\n        if(!t) return 0;\n        if(x <= t->val) return lower_bound(t->l, x);\n        return lower_bound(t->r, x) + RBST<T>::size(t->l) + 1;\n    }\n    // xより大きい最小の位置\n    int upper_bound(node *t, const T &x) {\n        if(!t) return 0;\n        if(x < t->val) return upper_bound(t->l, x);\n        return upper_bound(t->r, x) + RBST<T>::size(t->l) + 1;\n    }\n};\ntemplate<class T>\nstruct OrderedSet : OrderedMultiSet<T>  {\n    using SET = OrderedMultiSet<T>;\n    using RBST = typename SET::RBST;\n    using node = typename RBST::node;\n\n    OrderedSet(int sz) : OrderedMultiSet<T>(sz) {}\n\n    void insert_key(node *&t, const T &x) override {\n        if(SET::count(t, x)) return;\n        RBST::insert(t, SET::lower_bound(t, x), x);\n    }\n};\n\n// k-th element\nnamespace ARC033C {\n    void solve() {\n        ll q;\n        cin >> q;\n        OrderedMultiSet<ll> st;\n        OrderedMultiSet<ll>::RBST::node *root = nullptr;\n        while(q--) {\n            ll t, x;\n            cin >> t >> x;\n            if(t == 1) {\n                st.insert_key(root, x);\n            } else {\n                ll val = st.kth_element(root, x-1);\n                cout << val << endl;\n                st.erase_key(root, val);\n            }\n        }\n    }\n}\n\n// 点更新区間最小\nnamespace DSL2A {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        auto f = [](ll l, ll r) { return min(l, r); };\n        RBST<ll> tree(f, INT_MAX);\n\n        RBST<ll,ll>::node* root = nullptr;\n        for(int i = 0; i < n; i++) tree.insert(root, i, INT_MAX);\n        while(q--) {\n            int c, x, y;\n            cin >> c >> x >> y;\n            if(c == 0) {\n                tree.set_element(root, x, y);\n            } else {\n                cout << tree.query(root, x, y+1) << endl;\n            }\n        }\n    }\n}\n\n// 点加算区間和\nnamespace DSL2B {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        auto f = [](ll l, ll r) { return l+r; };\n        RBST<ll> tree(f, 0);\n\n        RBST<ll,ll>::node* root = nullptr;\n        for(int i = 0; i < n; i++) tree.insert(root, i, 0);\n        while(q--) {\n            int c, x, y;\n            cin >> c >> x >> y;\n            if(c == 0) {\n                x--;\n                tree.set_element(root, x, tree.get(root, x) + y);\n            } else {\n                x--, y--;\n                cout << tree.query(root, x, y+1) << endl;\n            }\n        }\n    }\n}\n\n// 区間更新区間最小\nnamespace DSL2F {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        auto f = [](ll l, ll r) { return min(l, r); };\n        auto g = [](ll l, ll r) { return r; };\n        auto p = [](ll l, int r) { return l; };\n        RBST<ll,ll> tree(f, g, g, p, INT_MAX, INT_MAX);\n\n        RBST<ll,ll>::node* root = nullptr;\n        for(int i = 0; i < n; i++) tree.insert(root, i, INT_MAX);\n        while(q--) {\n            int c, s, t;\n            cin >> c >> s >> t;\n            if(c == 0) {\n                int x;\n                cin >> x;\n                tree.update(root, s, t + 1, x);\n            } else {\n                cout << tree.query(root, s, t + 1) << endl;\n            }\n        }\n    }\n}\n\n// 区間加算区間和\nnamespace DSL2G {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        auto f = [](ll l, ll r) { return l+r; };\n        auto p = [](ll l, int r) { return l*r; };\n        RBST<ll,ll> tree(f, f, f, p, 0, 0);\n\n        RBST<ll,ll>::node* root = nullptr;\n        for(int i = 0; i < n; i++) tree.insert(root, i, 0);\n        while(q--) {\n            int c, s, t;\n            cin >> c >> s >> t;\n            s--, t--;\n            if(c == 0) {\n                int x;\n                cin >> x;\n                tree.update(root, s, t + 1, x);\n            } else {\n                cout << tree.query(root, s, t + 1) << endl;\n            }\n        }\n    }\n}\n\n// 区間加算区間最小\nnamespace DSL2H {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        auto f = [](ll l, ll r) { return min(l, r); };\n        auto g = [](ll l, ll r) { return l+r; };\n        auto p = [](ll l, int r) { return l; };\n        RBST<ll,ll> tree(f, g, g, p, INT_MAX, 0);\n\n        RBST<ll,ll>::node* root = nullptr;\n        for(int i = 0; i < n; i++) tree.insert(root, i, 0);\n        while(q--) {\n            int c, s, t;\n            cin >> c >> s >> t;\n            if(c == 0) {\n                int x;\n                cin >> x;\n                tree.update(root, s, t+1, x);\n            } else {\n                cout << tree.query(root, s, t+1) << endl;\n            }\n        }\n    }\n}\n\n// 区間更新区間和\nnamespace DSL2I {\n    void solve() {\n        int n, q;\n        cin >> n >> q;\n\n        auto f = [](ll l, ll r) { return l+r; };\n        auto g = [](ll l, ll r) { return r==0?l:r; };\n        auto p = [](ll l, int r) { return l*r; };\n        RBST<ll,ll> tree(f, g, g, p, 0, INT_MAX);\n\n        RBST<ll,ll>::node* root = nullptr;\n        for(int i = 0; i < n; i++) tree.insert(root, i, 0);\n        while(q--) {\n            int c, s, t;\n            cin >> c >> s >> t;\n            if(c == 0) {\n                int x;\n                cin >> x;\n                tree.update(root, s, t+1, x);\n            } else {\n                cout << tree.query(root, s, t+1) << endl;\n            }\n            // cout << tree.dump(root) << endl;\n        }\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    // ARC033C::solve();\n    // DSL2A::solve();\n    // DSL2B::solve();\n    // DSL2F::solve();\n    // DSL2G::solve();\n    // DSL2H::solve();\n    DSL2I::solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\n#define FOR(I,A,B) for(int I=int(A);I<int(B);++I)\n\n// https://onlinejudge.u-aizu.ac.jp/status/users/fullhouse1987/submissions/1/DSL_2_I/judge/4135652/C++14\ntemplate <typename T>\nclass RQ{\npublic:\n\tint n,rn,bn,time=0;\n\tT inicial;\n\tvector<T> a,b_get,b_update;\n\tvector<int> atime,btime;//b_get->buket内全てまとめた値\n\tT updete(T v,T x){return x;}\n\tT unite(T x,T y){return x+y;}\n\tT buket_val(T x){return x*rn;}\n\n\tRQ(int n_,T ini){\n\t\tn = n_; rn =sqrt(n); bn=(n+rn-1)/rn;\n\t\ta.resize(n,ini);\n\t\tb_get.resize(bn,ini);\n\t\tb_update.resize(bn,ini);\n\t\tatime.resize(n,-1);\n\t\tbtime.resize(bn,-1);\n\t\tinicial = ini;\n\t}\n\tT get(int s,int t){ //[s,t]\n\t\tT res = inicial;\n\t\tfor(int i=s;i<=t;i++){\n\t\t\tif(i%rn==0 && (i+rn-1)<=t){\n\t\t\t\tres = unite(res,b_get[i/rn]);\n\t\t\t\ti += rn-1;\n\t\t\t}else{\n\t\t\t\tif(atime[i]<btime[i/rn]){\n\t\t\t\t\ta[i] = updete(a[i],b_update[i/rn]);\n\t\t\t\t\tatime[i] = btime[i/rn];\n\t\t\t\t}\n\t\t\t\tres = unite(res,a[i]);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tvoid updete(int s,int t,T x){ //[s,t]\n\t\ttime++;\n\t\tfor(int i=s;i<=t;i++){\n\t\t\tif(i%rn==0 && (i+rn-1)<=t){\n\t\t\t\tb_update[i/rn] = updete(b_update[i/rn],x);\n\t\t\t\tbtime[i/rn] = time;\n\t\t\t\tb_get[i/rn] = buket_val(x);\n\t\t\t\ti += rn-1;\n\t\t\t}else{\n\t\t\t\ta[i] = updete(a[i],x);\n\t\t\t\tatime[i] = time;\n\t\t\t\tif((i+1)%rn==0 || i==t){\n\t\t\t\t\tint bi = i/rn;\n\t\t\t\t\tb_get[bi] = inicial;\n\t\t\t\t\tfor(int j=bi*rn;j<(bi+1)*rn;j++){\n\t\t\t\t\t\tif(atime[j]<btime[bi]){\n\t\t\t\t\t\t\ta[j] = updete(a[j],b_update[bi]);\n\t\t\t\t\t\t\tatime[j] = btime[bi];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tb_get[bi] = unite(b_get[bi],a[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n\nint main(){ \n\tint n,q,s,t,a;\n\tll x;\n\tcin >> n >> q;\n\tRQ<ll> sg(n+2,0LL);\n\tFOR(Q,0,q){\n\t\tcin >> a;\n\t\tif(a){\n\t\t\tcin >> s >> t;\n\t\t\tcout << sg.get(s,t) << endl;\n\t\t}else{\n\t\t\tcin >> s >> t >> x;\n\t\t\tsg.updete(s,t,x);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <functional>\nusing namespace std;\n\ntemplate <typename T, typename E>\nclass lazy_segtree {\nprivate:\n    using Op = function<T(T, T)>;\n    using Compose = function<E(E, E)>;\n    using Act = function<T(T, E)>;\n    using Power = function<E(E, int)>;\n\n    size_t N;\n    vector<T> data;\n    vector<E> lazy;\n    const T idT;\n    const E idE;\n    const Op op;\n    const Compose compose;\n    const Act act;\n    const Power power;\n\n    void eval(size_t k, size_t len) {\n        if(lazy[k] == idE) return;\n        if(2 * k + 1 < 2 * N) {\n            lazy[2 * k] = compose(lazy[2 * k], lazy[k]);\n            lazy[2 * k + 1] = compose(lazy[2 * k + 1], lazy[k]);\n        }\n        data[k] = act(data[k], power(lazy[k], len));\n        lazy[k] = idE;\n    }\n\n    void update(size_t a, size_t b, size_t k, size_t l, size_t r, E x) {\n        eval(k, r - l);\n        if(r <= a || b <= l) return;\n        if(a <= l && r <= b) {\n            lazy[k] = compose(lazy[k], x);\n            eval(k, r - l);\n            return;\n        }\n        update(a, b, 2 * k, l, (l + r) / 2, x);\n        update(a, b, 2 * k + 1, (l + r) / 2, r, x);\n        data[k] = op(data[2 * k], data[2 * k + 1]);\n    }\n\n    T get(size_t a, size_t b, size_t k, size_t l, size_t r) {\n        eval(k, r - l);\n\n        if(r <= a || b <= l) return idT;\n        if(a <= l && r <= b) return data[k];\n        \n        T vl = get(a, b, 2 * k, l, (l + r) / 2);\n        T vr = get(a, b, 2 * k + 1, (l + r) / 2, r);\n        if(2 * k + 1 < 2 * N) data[k] = op(data[2 * k], data[2 * k + 1]);\n        return op(vl, vr);\n    }\n\npublic:\n    lazy_segtree(size_t n, T idT, E idE,\n    const Op op, const Compose compose,\n    const Act act, const Power power = [](E a, int){ return a; })\n    : idT(idT), idE(idE), op(op), compose(compose), act(act), power(power) {\n        for(N = 1; N < n; N <<= 1);\n        data = vector<T>(2 * N, idT);\n        lazy = vector<E>(2 * N, idE);\n    }\n    \n    lazy_segtree(const vector<T> &init, T idT, E idE,\n    const Op op, const Compose compose,\n    const Act act, const Power power = [](E a, int){ return a; })\n    : idT(idT), idE(idE), op(op), compose(compose), act(act), power(power) {\n        for(N = 1; N < init.size(); N <<= 1);\n        data = vector<T>(2 * N, idT);\n        lazy = vector<E>(2 * N, idE);\n        for(int i = 0; i < init.size(); ++i) data[i + N] = init[i];\n        for(int i = N - 1; i >= 0; --i) data[i] = op(data[2 * i], data[2 * i + 1]);\n    }\n\n    void update(size_t left, size_t right, E x) {\n        update(left, right, 1, 0, N, x);\n    }\n\n    T get(size_t left, size_t right) {\n        return get(left, right, 1, 0, N);\n    }\n\n    T operator[](int k) {\n        return get(k, k + 1);\n    }\n};\n\n\n#include <iostream>\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    lazy_segtree<int, int> st(n, 0, -1001,\n    plus<long long>(), [](int, int b){ return b; },\n    [](int, int b){ return b; }, multiplies<int>());\n\n    while(q--) {\n        int c, s, t; cin >> c >> s >> t;\n        if(c == 0) {\n            long long x; cin >> x;\n            st.update(s, t + 1, x);\n        } else {\n            cout << st.get(s, t + 1) << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma warning(disable : 4267) // \"int n = (unsigned)size\"\n\nusing vi = vector<int>; using vvi = vector<vi>; using vvvi = vector<vvi>;\nusing ll = long long int;\nusing vll = vector<ll>; using vvll = vector<vll>; using vvvll = vector<vvll>;\nusing vd = vector<double>; using vvd = vector<vd>; using vvvd = vector<vvd>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing cdouble = complex<double>;\n\nconst double eps = 1e-7;\nconst double INFD = numeric_limits<double>::infinity();\n#define Loop(i, n) for(int i = 0; i < int(n); i++)\n#define Loopll(i, n) for(ll i = 0; i < ll(n); i++)\n#define Loop1(i, n) for(int i = 1; i <= int(n); i++)\n#define Loopll1(i, n) for(ll i = 1; i <= ll(n); i++)\n#define Loopr(i, n) for(int i = int(n) - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = ll(n) - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = int(n); i >= 1; i--)\n#define Looprll1(i, n) for(ll i = ll(n); i >= 1; i--)\n#define Foreach(buf, container) for(auto buf : container)\n#define Loopdiag(i, j, h, w, sum) for(int i = ((sum) >= (h) ? (h) - 1 : (sum)), j = (sum) - i; i >= 0 && j < (w); i--, j++)\n#define Loopdiagr(i, j, h, w, sum) for(int j = ((sum) >= (w) ? (w) - 1 : (sum)), i = (sum) - j; j >= 0 && i < (h); j--, i++)\n#define Loopdiagsym(i, j, h, w, gap) for (int i = ((gap) >= 0 ? (gap) : 0), j = i - (gap); i < (h) && j < (w); i++, j++)\n#define Loopdiagsymr(i, j, h, w, gap) for (int i = ((gap) > (h) - (w) - 1 ? (h) - 1 : (w) - 1 + (gap)), j = i - (gap); i >= 0 && j >= 0; i--, j--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(ex_i, vector.size()) { cout << vector[ex_i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(ex_i, matrix.size()) { Loop(ex_j, matrix[ex_i].size()) { cout << matrix[ex_i][ex_j] << \" \"; } cout << endl; }\n#define quickio() ios::sync_with_stdio(false); cin.tie(0);\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\n#define Comp(type_t) bool operator<(const type_t &another) const\n#define fst first\n#define snd second\nbool nearlyeq(double x, double y) { return abs(x - y) < eps; }\nbool inrange(ll x, ll t) { return x >= 0 && x < t; }\nbool inrange(vll xs, ll t) { Foreach(x, xs) if (!(x >= 0 && x < t)) return false; return true; }\nint ceillog2(ll x) { int ret = 0;\tx--; while (x > 0) { ret++; x >>= 1; } return ret; }\nll rndf(double x) { return (ll)(x + (x >= 0 ? 0.5 : -0.5)); }\nll floorsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (m * m <= x ? 0 : -1); }\nll ceilsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (x <= m * m ? 0 : 1); }\nll rnddiv(ll a, ll b) { return (a / b + (a % b * 2 >= b ? 1 : 0)); }\nll ceildiv(ll a, ll b) { return (a / b + (a % b == 0 ? 0 : 1)); }\nll gcd(ll m, ll n) { if (n == 0) return m; else return gcd(n, m % n); }\nll lcm(ll m, ll n) { return m * n / gcd(m, n); }\n\n/*******************************************************/\n\ntemplate<class T>\nclass SegTree {\nprotected:\n\tint n, N; // n is the original size, while N is the extended size\n\tint base;\n\tvector<T> nodes;\n\tint left_of(int id) {\n\t\tif (id >= base) return -1;\n\t\telse return id * 2 + 1;\n\t}\n\tint right_of(int id) {\n\t\tif (id >= base) return -1;\n\t\telse return id * 2 + 2;\n\t}\n\tint parent_of(int id) {\n\t\tif (id == 0) return -1;\n\t\telse return (id - 1) >> 1;\n\t}\n\t// initially, (s, t, 0, N, 0, x, EXCEPTION);\n\tvoid update_rec(int s, int t, int l, int r, int id, ll x, ll v) {\n\t\tif (v == LLONG_MIN) {\n\t\t\tv = nodes[id].val;\n\t\t}\n\t\tif (s == l && t == r) {\n\t\t\tif (x != LLONG_MIN) {\n\t\t\t\tnodes[id].val = x;\n\t\t\t\tnodes[id].sum = x * cover_size(id);\n\t\t\t}\n\t\t\telse if (v != LLONG_MIN) {\n\t\t\t\tnodes[id].val = v;\n\t\t\t\tnodes[id].sum = v * cover_size(id);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint m = (l + r) / 2;\n\t\t\tint id_l = left_of(id);\n\t\t\tint id_r = right_of(id);\n\t\t\tif (s < m && m < t) {\n\t\t\t\tupdate_rec(s, m, l, m, id_l, x, v);\n\t\t\t\tupdate_rec(m, t, m, r, id_r, x, v);\n\t\t\t}\n\t\t\telse if (s < m) {\n\t\t\t\tupdate_rec(s, t, l, m, id_l, x, v);\n\t\t\t\tif (v != LLONG_MIN) {\n\t\t\t\t\tnodes[id_r].val = v;\n\t\t\t\t\tnodes[id_r].sum = v * cover_size(id_r);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (m < t) {\n\t\t\t\tif (v != LLONG_MIN) {\n\t\t\t\t\tnodes[id_l].val = v;\n\t\t\t\t\tnodes[id_l].sum = v * cover_size(id_l);\n\t\t\t\t}\n\t\t\t\tupdate_rec(s, t, m, r, id_r, x, v);\n\t\t\t}\n\t\t\tnodes[id].val = LLONG_MIN;\n\t\t\tnodes[id].sum = nodes[id_l].sum + nodes[id_r].sum;\n\t\t}\n\t}\n\t// initially, (s, t, 0, N, 0, x, EXCEPTION);\n\tll solve_rec(int s, int t, int l, int r, int id, ll x, ll v) {\n\t\tif (s == l && t == r) {\n\t\t\treturn nodes[id].sum;\n\t\t}\n\t\telse {\n\t\t\tint m = (l + r) / 2;\n\t\t\tint id_l = left_of(id);\n\t\t\tint id_r = right_of(id);\n\t\t\tll v0 = 0, v1 = 0;\n\t\t\tif (s < m && m < t) {\n\t\t\t\tv0 = solve_rec(s, m, l, m, id_l, x, v);\n\t\t\t\tv1 = solve_rec(m, t, m, r, id_r, x, v);\n\t\t\t}\n\t\t\telse if (s < m) {\n\t\t\t\tv0 = solve_rec(s, t, l, m, id_l, x, v);\n\t\t\t}\n\t\t\telse if (m < t) {\n\t\t\t\tv1 = solve_rec(s, t, m, r, id_r, x, v);\n\t\t\t}\n\t\t\treturn v0 + v1;\n\t\t}\n\t}\npublic:\n\tSegTree(int n, T init) {\n\t\tSegTree::n = n;\n\t\tN = (int)pow(2, ceil(log2(n)));\n\t\tbase = N - 1;\n\t\tnodes = vector<T>(base + N, init);\n\t}\n\tint cover_size(int id) {\n\t\tint cnt = 1;\n\t\twhile (left_of(id) != -1) {\n\t\t\tid = left_of(id);\n\t\t\tcnt *= 2;\n\t\t}\n\t\tint l = id - base;\n\t\tint r = min(l + cnt, n);\n\t\treturn max(0, r - l);\n\t}\n\tvoid update(int s, int t, ll x) {\n\t\tupdate_rec(s, t, 0, N, 0, x, LLONG_MIN);\n\t}\n\tll solve(int s, int t) {\n\t\tupdate_rec(s, t, 0, N, 0, LLONG_MIN, LLONG_MIN);\n\t\treturn solve_rec(s, t, 0, N, 0, LLONG_MIN, LLONG_MIN);\n\t}\n};\n\nstruct val_t {\n\tll val;\n\tll sum;\n};\n\nint main() {\n\tint n; cin >> n;\n\tint q; cin >> q;\n\tSegTree<val_t> st(n, { 0, 0 });\n\tLoop(unused, q) {\n\t\tint op; cin >> op;\n\t\tint s, t; cin >> s >> t; t++;\n\t\tif (op == 0) {\n\t\t\tll x; cin >> x;\n\t\t\tst.update(s, t, x);\n\t\t}\n\t\telse {\n\t\t\tcout << st.solve(s, t) << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<climits>\nusing namespace std;\n\n// F : T x T -> T\n// G : T x E -> T\n// H : E x E -> E\n// R : E x int(length of the range) -> E\ntemplate<typename T, typename E, typename F, typename G, typename H, typename R>\nstruct SegL{\nprivate:\n    vector<T> node;\n    vector<E> lazy;\n    int n;\n    T defVal;\n    E defOp;\n    F f;    // merge elements(T)\n    G g;    // update element(T) \n    H h;    // merge operators(E)\n    R r;    // operator depends on length\n\npublic:\n    SegL(int siz, T defVal, E defOp, F f, G g, H h, R r) : defVal(defVal), defOp(defOp), f(f), g(g), h(h), r(r){\n        n = 1;\n        while(n < siz)  n *= 2;\n        node.resize(2*n-1, defVal);\n        lazy.resize(2*n-1, defOp);\n    }\n    SegL(vector<T> v, T defVal, E defOp, F f, G g, H h, R r) : defVal(defVal), defOp(defOp), f(f), g(g), h(h), r(r){\n        n = 1;\n        while(n < v.size())  n *= 2;\n        node.resize(2*n-1, defVal);\n        for(int i = 0; i < v.size(); i++)   node[n-1+i] = v[i];\n        for(int i = n-2; i >= 0; i--)   node[i] = f(node[2*i+1], node[2*i+2]);\n    }\n\n    void eval(int k, int len){\n        if(lazy[k] == defOp)    return;\n        if(k < n-1){\n            lazy[2*k+1] = h(lazy[2*k+1], lazy[k]);\n            lazy[2*k+2] = h(lazy[2*k+2], lazy[k]);\n        }\n        node[k] = g(node[k], r(lazy[k], len));\n        lazy[k] = defOp;\n    }\n\n    void update(int a, int b, E x, int k=0, int l=0, int r=-1){\n        if(r < 0)   r = n;\n        eval(k, r-l);\n        if(b <= l || r <= a){\n            return;\n        }else if(a <= l && r <= b){\n            lazy[k] = h(lazy[k], x);\n            eval(k, r-l);\n        }else{\n            update(a, b, x, 2*k+1, l, (l+r)/2);\n            update(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k] = f(node[2*k+1], node[2*k+2]);\n        }\n    }\n\n    T query(int a, int b, int k=0, int l=0, int r=-1){\n        if(r < 0)   r = n;\n        eval(k, r-l);\n        if(b <= l || r <= a)    return defVal;\n        if(a <= l && r <= b)    return node[k];\n        T lx = query(a, b, 2*k+1, l, (l+r)/2);\n        T rx = query(a, b, 2*k+2, (l+r)/2, r);\n        return f(lx, rx);\n    }\n};\n\ntypedef long long ll;\n\nint main(){\n    int n, q;\n    cin >> n >> q;\n    auto f = [](ll x, ll y)->ll{return x+y;};\n    auto g = [](ll x, ll y)->ll{return y==1001?x:y;};\n    auto h = [](ll x, ll y)->ll{return y==1001?x:y;};\n    auto r = [](ll x, ll y)->ll{return x*y;};\n    ll defv = 0;\n    ll defop = 1001;\n    SegL<ll, ll, decltype(f), decltype(g), decltype(h), decltype(r)> seg(n, defv, defop, f, g, h, r);\n    while(q--){\n        int op;\n        cin >> op;\n        if(op == 0){\n            int s, t, x;\n            cin >> s >> t >> x;\n            seg.update(s, t+1, x);\n        }else{\n            int s, t;\n            cin >> s >> t;\n            cout << seg.query(s, t+1) << endl;\n        }\n        // for(int i = 0; i < n; i++)  cout << seg.query(i,i+1) << \" \\n\"[i==n-1];\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ DSL_2_I Range Query - RSQ and RUQ\n// 2019.3.28 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n//// 入力の高速化\n#if 1\n#define gc() getchar_unlocked()\n#define pc(c) putchar_unlocked(c)\n#else\n#define gc() getchar()\n#define pc(c) putchar(c)\n#endif\nint in()    // 整数の入力（負数対応）\n{\n\tint n = 0, c = gc();\n\tif (c == '-') {\n\t\tc = gc();\n\t\tdo n = 10 * n + (c & 0xf), c = gc(); while (c >= '0');\n\t\treturn -n;\n\t}\n\tdo n = 10 * n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\nvoid out(long long n)\n{\n\tint i;\n\tchar ob[40];\n\n\tif (!n) pc('0');\n\telse {\n\t\tif (n < 0) pc('-'), n = -n;\n\t\ti = 0; while (n) ob[i++] = n % 10 + '0', n /= 10;\n\t\twhile (i--) pc(ob[i]);\n\t}\n\tpc('\\n');\n}\n\n\n// セグメント木\n#define MAXN (1<<17)      // セグメント木のサイズ。2のべき乗にすべし\n#define INF  0x1f1f1f1f\n\nlong long segVal[2*MAXN];\nint segLazy[2*MAXN];\n\nvoid lazy(int k, int l, int r)\n{\n\tif (segLazy[k] != INF) {\n\t\tsegVal[k] = (long long)(r-l)*segLazy[k];\n\t\tif (l + 1 < r) {\n\t\t\tsegLazy[(k << 1) + 1] = segLazy[k];\n\t\t\tsegLazy[(k << 1) + 2] = segLazy[k];\n\t\t}\n\t\tsegLazy[k] = INF;\n\t}\n}\n\nvoid update(int a, int b, int x, int k, int l, int r)\n{\n\tlazy(k, l, r);\n\tif (r <= a || b <= l) return;\n\tif (a <= l && r <= b) {\n\t\tsegLazy[k] = x;\n\t\tlazy(k, l, r);\n\t\treturn;\n\t}\n\tupdate(a, b, x, (k << 1) + 1, l, (l + r) >> 1);\n\tupdate(a, b, x, (k << 1) + 2, (l + r) >> 1, r);\n\tsegVal[k] = segVal[(k << 1) + 1] + segVal[(k << 1) + 2];\n}\n\nlong long getSum(int a, int b, int k, int l, int r)\n{\n\tlong long ans;\n\n\tif (r <= a || b <= l) return 0;\n\tlazy(k, l, r);\n\tif (a <= l && r <= b) return segVal[k];\n\tans = getSum(a, b, (k << 1) + 1, l, (l + r) >> 1);\n\tans += getSum(a, b, (k << 1) + 2, (l + r) >> 1, r);\n\treturn ans;\n}\n\nint main()\n{\n\tint N, Q;\n\tint cmd, s, t, x;\n\n\tmemset(segLazy, INF, sizeof(segLazy));\n\tN = in(), Q = in();\n\twhile (Q--) {\n\t\tcmd = in(), s = in(), t = in();\n\t\tif (cmd == 0) {\n\t\t\tx = in();\n\t\t\tupdate(s, t+1, x, 0, 0, N);\n\t\t}\n\t\telse out(getSum(s, t+1, 0, 0, N));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define min(p,q)((p)<(q)?(p):(q))\n\n\n\n//*\n//遅延セグ木ここから\n//↓ここを変える\ntypedef struct sayouso{ll a,b;}sayouso;\ntypedef struct atai{ll a;}atai;\n//↑ここを変える\n\ntypedef struct node{sayouso T;atai x;}node;\nnode *lsegN,*lseg;\nll lsegNUM,lsegk;\n\n//↓ここから変える\nsayouso sid={1,0};\natai aid={0};\natai xx(atai x,atai y){\n\tatai ret;\n\tret.a=x.a+y.a;\n\treturn ret;\n}\natai Tx(sayouso T,atai x){\n\tatai ret;\n\tret.a=T.a*x.a+T.b;\n\treturn ret;\n}\nsayouso TT(sayouso S,sayouso T){\n\tsayouso ret;\n\tret.a=S.a*T.a;\n\tret.b=S.b+S.a*T.b;\n\treturn ret;\n}\nsayouso fT(sayouso T,ll k){\n\tsayouso ret;\n\tret.a=T.a;\n\tret.b=T.b<<k;\n\treturn ret;\n}\n//↑ここまで変える\n\n//要素数(2ベキ)でこれを呼ぶ\nvoid lseguse(ll n){\n\tlsegN=(node*)calloc(2*n,sizeof(node));\n\tlsegNUM=n;\n\tlseg=lsegN+lsegNUM;\n\tlsegk=0;while(n/=2)lsegk++;\n\trep(i,1,2*lsegNUM){\n\t\tlsegN[i].x=aid;\n\t\tlsegN[i].T=sid;\n\t}\n}\n//lseg[i].xに値を与えてから初期化\nvoid lseginit(){\n\tfor(ll i=lsegNUM-1;i>0;i--)lsegN[i].x=xx(lsegN[2*i].x,lsegN[2*i+1].x);\n}\nvoid lsegupdatesub(ll l,ll r,sayouso T,ll i,ll cl,ll cr,ll ck){\n\tif(l>=r)return;\n\t//disjointなとき\n\tif(cr<=l||r<=cl)return;\n\t//完全に含むとき\n\tif(l<=cl&&cr<=r){\n\t\tlsegN[i].T=TT(T,lsegN[i].T);\n\t\treturn;\n\t}\n\t//どちらでもないとき\n\t//遅延伝播\n\tlsegN[2*i  ].T=TT(lsegN[i].T,lsegN[2*i  ].T);\n\tlsegN[2*i+1].T=TT(lsegN[i].T,lsegN[2*i+1].T);\n\t//再帰的に更新\n\tll cm=(cl+cr)/2;\n\tlsegupdatesub(l,r,T,2*i  ,cl,cm,ck-1);\n\tlsegupdatesub(l,r,T,2*i+1,cm,cr,ck-1);\n\t//自身のnodeを更新\n\tlsegN[i].x=xx(Tx(fT(lsegN[2*i].T,ck-1),lsegN[2*i].x),Tx(fT(lsegN[2*i+1].T,ck-1),lsegN[2*i+1].x));\n\tlsegN[i].T=sid;\n}\nvoid lsegupdate(ll l,ll r,sayouso T){lsegupdatesub(l,r,T,1,0,lsegNUM,lsegk);}\natai lsegcalcsub(ll l,ll r,ll i,ll cl,ll cr,ll ck){\n\tif(l>=r)return aid;\n\t//完全に含むとき\n\tif(l<=cl&&cr<=r)return Tx(fT(lsegN[i].T,ck),lsegN[i].x);\n\n\tll cm=(cl+cr)/2;\n\t//遅延伝播(変更はないので配るだけで良い)\n\tlsegN[2*i  ].T=TT(lsegN[i].T,lsegN[2*i  ].T);\n\tlsegN[2*i+1].T=TT(lsegN[i].T,lsegN[2*i+1].T);\n\tlsegN[i].x=Tx(fT(lsegN[i].T,ck),lsegN[i].x);\n\tlsegN[i].T=sid;\n\n\t//左側だけ\n\tif(r<=cm)return lsegcalcsub(l,r,2*i  ,cl,cm,ck-1);\n\t//右側だけ\n\tif(cm<=l)return lsegcalcsub(l,r,2*i+1,cm,cr,ck-1);\n\t//両方\n\treturn xx(lsegcalcsub(l,r,2*i,cl,cm,ck-1),lsegcalcsub(l,r,2*i+1,cm,cr,ck-1));\n}\natai lsegcalc(ll l,ll r){return lsegcalcsub(l,r,1,0,lsegNUM,lsegk);}\n//遅延セグ木ここまで\n//*/\n\n\nint main(){\n\tint n,q;\n\tscanf(\"%d%d\",&n,&q);\n\tlseguse(1<<17);\n\twhile(q--){\n\t\tint t;\n\t\tscanf(\"%d\",&t);\n\t\tif(t){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tprintf(\"%lld\\n\",lsegcalc(x,y+1).a);\n\t\t}\n\t\telse{\n\t\t\tint x,y,b;\n\t\t\tscanf(\"%d%d%d\",&x,&y,&b);\n\t\t\tsayouso T={0,b};\n\t\t\tlsegupdate(x,y+1,T);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define EMPTY  -2147483648\n\n#define max(a, b) ((a)>(b)?(a):(b))\n#define min(a, b) ((a)<(b)?(a):(b))\n\nint *a, *b, x;\nunsigned int s, t, n, w;\n\n\nint sum(unsigned int k, unsigned int l, unsigned int r)\n{\n  int ret = 0;\n  if (r<=s || t<=l || k>=w+n)   return 0;\n  if (s<=l && r<=t) { // 一致\n    ret = a[k] * (r-l);\n    if (k<w)   ret += b[k]; \n    return ret;\n  }\n  ret = (min(t, r) - max(s, l)) * a[k];\n  if (k*2+1<w+n && a[k*2+1] != EMPTY) ret += sum(k*2+1, l, (l+r)/2);\n  if (k*2+2<w+n && a[k*2+2] != EMPTY) ret += sum(k*2+2, (l+r)/2, r);\n  return ret;\n}\n\nvoid update(unsigned int k, unsigned int l, unsigned int r)\n{\n  if (r<=s || t<=l || k>=w+n) return;\n  unsigned int pp = (k-1)>>1;\n  unsigned int k1 = (k<<1)+1;\n  unsigned int k2 = k1+1;\n  unsigned int sib;\n\n  if (a[k] == EMPTY) {\n    sib = k%2 ? k+1 : k-1;\n    a[k] = a[pp];\n    if (k<w)     b[k] = 0;\n    if (sib<w+n) a[sib] = a[pp];\n    if (sib<w)   b[sib] = 0;\n    a[pp] = 0;\n\n    if (k1<w+n) a[k1] = EMPTY;\n    if (k2<w+n) a[k2] = EMPTY;\n    unsigned int nep = (sib<<1)+1;\n    if (nep<w+n)   a[nep] = EMPTY;\n    if (nep+1<w+n) a[nep+1] = EMPTY;\n  }\n\n  if (s<=l && r<=t) {\n    a[k] = x;\n    if (k<w)    b[k] = 0;\n    if (k1<w+n) a[k1] = EMPTY;\n    if (k2<w+n) a[k2] = EMPTY;\n    for (int i=k,u=r-l; i>0; u*=2) {\n      sib = i%2 ? i+1 : i-1;\n      int ip = (i-1)/2;\n      if (i>=w) {\n      \tb[ip] = (i<w+n?a[i]:0) + (sib<w+n? a[sib]:0);\n      } else {\n\tb[ip] = (a[i]   ? a[i]*u   : (i<w+n   ? b[i]:0)) +\n     \t        (a[sib] ? a[sib]*u : (sib<w+n ? b[sib]:0));\n      }\n      i = ip;\n    }\n  } else if (r-l>1) {\n    update(k1, l, (l+r)>>1);\n    update(k2, (l+r)>>1, r);\n  }\n}\n\n\nint main()\n{\n  int i, minus;\n  char *p, buf[64] = {0};\n  buf[62] = '\\n';\n  fgets(buf, 64, stdin);\n  for (n=0,p=buf; *p>' '; n=n*10+*(p++)-'0');\n  w = n>1 ? pow(2, (int)ceil(log2(n)))-1 : 0;\n  b = (a = (int*)malloc(sizeof(int)*(w+n+w))) + w+n;\n  if (n>1) a[1] = EMPTY;\n  if (n>2) a[2] = EMPTY;\n  while (fgets(buf, 64, stdin)) {\n    for (s=0,p=buf+2; *p>' '; s=s*10+*(p++)-'0');\n    for (t=0,p++; *p>' '; t=t*10+*(p++)-'0');\n    t++;\n    if (*buf=='0') {\n      minus=0;\n      if (*(++p)=='-') {minus=1;p++;}\n      for (x=0; *p>' '; x=x*10+*(p++)-'0');\n      if (minus) x=-x;\n      update(0, 0, w+1);\n    } else {\n      x = sum(0, 0, w+1);\n      if (x<0) {\n\tputchar('-');\n\tx = -x;\n      }\n      if (x<10) {\n\tputc_unlocked('0'+x, stdout);\n\tputc_unlocked('\\n', stdout);\n      } else {\n\tfor (i=62; x>0; buf[--i]='0'+x%10,x/=10);\n\tfputs(buf+i, stdout);\n      }\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define LBOUND -1001\n#define ST_SIZE ((1 << 18) - 1)\ntypedef long long int LL;\nLL dat[ST_SIZE];\nLL input(void);\nvoid update(LL a, LL b, LL x, LL k, LL l, LL r);\nLL sum(LL a, LL b, LL k, LL l, LL r);\nint main (void) {\n  int command, x;\n  LL i, n, q, s, t;\n  n = input();\n  q = input();\n  for (i = 0; i < q; i++) {\n    command = input();\n    if (!command) {\n      s = input();\n      t = input();\n      x = input();\n      update(s, t + 1, x, 0, 0, n);\n    } else {\n      s = input();\n      t = input();\n      printf(\"%lld\\n\", sum(s, t + 1, 0, 0, n));\n    }\n  }\n}\nLL input(void)\n{\n  LL n = 0;\n  int c = getchar_unlocked();\n  if (c == '-') {\n    c = getchar_unlocked();\n    do {\n      n = 10 * n + c - '0';\n      c = getchar_unlocked();\n    } while (c >= '0' && c <= '9');\n    return -n;\n  } else {\n    do {\n      n = 10 * n + c - '0';\n      c = getchar_unlocked();\n    } while (c >= '0' && c <= '9');\n    return n;\n  }\n}\nvoid update(LL a, LL b, LL x, LL k, LL l, LL r)\n{\n  LL m = (l + r) / 2;\n  if (a >= r || b <= l) return;\n  else if (a <= l && b >= r) dat[k] = x;\n  else {\n    if (dat[k] != LBOUND) {\n      dat[k*2+1] = dat[k*2+2] = dat[k];\n      dat[k] = LBOUND;\n    }\n    update(a, b, x, k * 2 + 1, l ,m);\n    update(a, b, x, k * 2 + 2, m, r);\n  }\n}\nLL sum(LL a, LL b, LL k, LL l, LL r)\n{\n  LL m = (l + r) / 2;\n  if (a >= r || b <= l) return 0;\n  else {\n    if (dat[k] != LBOUND) return ((b < r ? b : r) - (a > l ? a : l)) * dat[k];\n    else {\n      LL vl, vr;\n      vl = sum(a, b, k * 2 + 1, l, m);\n      vr = sum(a, b, k * 2 + 2, m, r);\n      return (vl + vr);\n    }\n  }\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h> // uint64_t\n\n#define max(a,b) ((a) > (b) ? (a) : (b))\n#define min(a,b) ((a) > (b) ? (b) : (a))\n\nint get_int(void) {\n  int num;\n  scanf(\"%d\", &num);\n  return num;\n}\n\nint get_int2(int *a1, int *a2) {\n  scanf(\"%d %d\", a1, a2);\n  return 0;\n}\n\nint get_int3(int *a1, int *a2, int *a3) {\n  scanf(\"%d %d %d\", a1, a2, a3);\n  return 0;\n}\n\nenum type {\n    COMMAND_UPDATE,\n    COMMAND_GET_SUM\n};\n\nstruct range {\n    int start;\n    int end;\n};\n\nstruct pair {\n    int64_t lazy;\n    int64_t val;\n};\n\n#define NUM_MAX 100000\n#define NUM2_MAX (1<<17)\n#define QUERY_MAX 100000\n\nint is_overlap(struct range r1, struct range r2) {\n    return r1.end > r2.start && r2.end > r1.start;\n}\n\nint is_contain(struct range this, struct range box) {\n    return box.start <= this.start && this.end <= box.end;\n}\n\n#define INIT_VAL (2e+9)\n\nvoid unlazy(struct pair *seg, int node, struct range nr) {\n    int64_t lazy = seg[node].lazy;\n    if(lazy == INIT_VAL) return;\n    seg[node].val = lazy; //update\n    seg[node].lazy = INIT_VAL;\n    if(nr.end - nr.start > 1) {\n        seg[node*2].lazy = lazy/2;\n        seg[node*2+1].lazy = lazy/2;\n    }\n    return;\n}\n\n\nvoid update_range(struct pair *seg, int x, struct range r, int node, struct range nr) {\n    unlazy(seg, node, nr);\n    if(!is_overlap(r, nr)) return;\n    if(is_contain(nr, r)) {\n        seg[node].lazy = x * (nr.end - nr.start);\n        unlazy(seg, node, nr);\n        return;\n    }\n    struct range left = { nr.start, (nr.start + nr.end)/2 };\n    struct range right = { (nr.start + nr.end)/2, nr.end };\n    update_range(seg, x, r, node*2, left);\n    update_range(seg, x, r, node*2+1, right);\n    seg[node].val = seg[node*2].val + seg[node*2+1].val;\n}\n\nint64_t get_sum(struct pair *seg, struct range r, int node, struct range nr) {\n    unlazy(seg, node, nr);\n    if(!is_overlap(r, nr)) return 0;\n    if(is_contain(nr, r)) {\n        return seg[node].val;\n    }\n    struct range left = { nr.start, (nr.start + nr.end)/2 };\n    struct range right = { (nr.start + nr.end)/2, nr.end };\n    int64_t ans = 0;\n    ans += get_sum(seg, r, node*2, left);\n    ans += get_sum(seg, r, node*2+1, right);\n    return ans;\n}\n\n\n#define ROOT_NODE 1\nint main(void) {\n    int num, queries;\n    get_int2(&num, &queries);\n    int num2 = 1;\n    static int64_t ans[QUERY_MAX];\n    int aidx = 0;\n    while(num > num2) num2 *= 2;\n    static struct pair seg[NUM2_MAX*2];\n    int i;\n    for(i = ROOT_NODE; i < num2*2; i++) seg[i].lazy = INIT_VAL;\n\n    struct range whole = {0, num2};\n    for(i = 0; i < queries; i++) {\n        int start, end;\n        int type;\n        get_int3(&type, &start, &end);\n        struct range r = {start, end+1};\n        switch(type) {\n            case COMMAND_UPDATE:\n                {\n                    int x = get_int();\n                    update_range(seg, x, r, ROOT_NODE, whole);\n                }\n                break;\n            case COMMAND_GET_SUM:\n                ans[aidx++] = get_sum(seg, r, ROOT_NODE, whole);\n                break;\n            default:\n                break;\n        }\n    }\n\n    for(i = 0; i < aidx; i++) {\n        printf(\"%lld\\n\", ans[i]);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n\ntypedef int32_t i32;\n\ntypedef struct RSQandRUQ_node {\n  i32 val;\n  i32 sum;\n} node;\n\ntypedef struct RSQandRUQ {\n  node *a;\n  i32 bit;\n  i32 size;\n  i32 empty;\n} RSQandRUQ;\n\nRSQandRUQ* new_RSQandRUQ (const i32 n) {\n  i32 k = 0;\n  while ((1 << k) < n) ++k;\n  RSQandRUQ *s = (RSQandRUQ *) calloc (1, sizeof (RSQandRUQ));\n  s->a = (node *) calloc (2 << k, sizeof (node));\n  s->bit = k;\n  s->size = 1 << k;\n  s->empty = 10000;\n  return s;\n}\n\nvoid propagate (RSQandRUQ *s, i32 x) {\n  x += s->size;\n  for (i32 i = s->bit; i > 0; --i) {\n    i32 k = x >> i;\n    if (s->a[k].val == s->empty) continue;\n    s->a[2 * k].val = s->a[2 * k + 1].val = s->a[k].val;\n    s->a[k].sum = s->a[k].val << i;\n    s->a[k].val = s->empty;\n  }\n}\n\nstatic inline i32 eval (RSQandRUQ *s, i32 k, i32 len) {\n  return s->a[k].val == s->empty ? s->a[k].sum : s->a[k].val * len;\n}\n\nvoid save (RSQandRUQ *s, i32 x) {\n  for (i32 k = (x + s->size) >> 1, len = 1; k > 0; k >>= 1, len <<= 1) {\n    s->a[k].sum = eval (s, 2 * k, len) + eval (s, 2 * k + 1, len);\n  }\n}\n\nvoid update (RSQandRUQ *s, i32 l, i32 r, i32 v) {\n  propagate (s, l);\n  propagate (s, r - 1);\n  for (i32 x = l + s->size, y = r + s->size; x < y; x >>= 1, y >>= 1) {\n    if (x & 1) s->a[x++].val = v;\n    if (y & 1) s->a[--y].val = v;\n  }\n  save (s, l);\n  save (s, r - 1);\n}\n\ni32 get_sum (RSQandRUQ *s, i32 l, i32 r) {\n  propagate (s, l);\n  propagate (s, r - 1);\n  i32 sum = 0;\n  for (i32 x = l + s->size, y = r + s->size, len = 1; x < y; x >>=1, y >>= 1, len <<= 1) {\n    if (x & 1) sum += eval (s, x++, len);\n    if (y & 1) sum += eval (s, --y, len);\n  }\n  return sum;\n}\n\nvoid run (void) {\n  i32 n, q;\n  scanf (\"%\" SCNi32 \"%\" SCNi32, &n, &q);\n  RSQandRUQ *s = new_RSQandRUQ (n);\n  while (q--) {\n    i32 t, l, r;\n    scanf (\"%\" SCNi32 \"%\" SCNi32 \"%\" SCNi32, &t,&l, &r);\n    r++;\n    if (t == 0) {\n      i32 v;\n      scanf (\"%\" SCNi32, &v);\n      update (s, l, r, v);\n    } else {\n      printf (\"%\" PRIi32 \"\\n\", get_sum (s, l, r));\n    }\n  }\n}\n\nint main(void){\n  run();\n  return 0;\n}\n\n"
  },
  {
    "language": "Java",
    "code": "/**\n * Created at 22:21 on 2019-07-09\n */\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n  static FastScanner sc = new FastScanner();\n  static PrintStream out = System.out;\n  static PrintWriter pw = new PrintWriter(out);\n\n  static final int[] dx = {0, 1, 0, -1};\n  static final int[] dy = {-1, 0, 1, 0};\n\n  static final long MOD = (long) (1e9 + 7);\n  static final long INF = Long.MAX_VALUE / 2;\n\n  public static class Solver {\n    public Solver() {\n\n      int n = sc.nextInt();\n      int q = sc.nextInt();\n\n      SegmentTree seg = new SegmentTree(new long[n]);\n\n      for (int i=0; i<q; i++) {\n        int com = sc.nextInt();\n        if (com == 0) {\n          seg.put(sc.nextInt(), sc.nextInt()+1, sc.nextLong());\n        } else {\n          out.println(seg.query(sc.nextInt(), sc.nextInt()+1).val);\n        }\n      }\n\n    }\n\n\n    public static class SegmentTree {\n\n      static final long INF = Long.MAX_VALUE / 2;\n\n      Node[] tree;\n      int N = 1; //元配列の要素数以上で最小の2の冪乗\n      int size; //木のサイズ\n      Node initialNode;\n\n      public static class Node {\n        static long initialVal = 0;\n        static long initialLazy = INF;\n        boolean isLazy = false;\n        long val;\n        long lazy;\n\n        public Node() {\n          val = initialVal;\n          lazy = initialLazy;\n        }\n        public Node(long val) {\n          this.val = val;\n          lazy = initialLazy;\n        }\n\n        public Node operation(Node nl, Node nr) {\n          val = nl.val + nr.val;\n          return this;\n        }\n        public void prop(Node par) {\n          if (!par.isLazy) return;\n          lazy = par.lazy/2;\n          isLazy = true;\n        }\n        public void prop(long x, int l, int r) {\n          lazy = x * (r-l);\n          isLazy = true;\n        }\n        public void update() {\n          if (!isLazy) return;\n          val = lazy;\n          lazy = initialLazy;\n          isLazy = false;\n        }\n      }\n\n      public void update(int k, long x) {\n        k += N-1;\n        tree[k] = new Node(x);\n\n        while(k != 0) {\n          k = parent(k);\n          tree[k].operation(tree[childL(k)], tree[childR(k)]);\n        }\n      }\n\n      private void prop(int k) {\n        if (childL(k) < size) { //葉じゃなければ\n          tree[childL(k)].prop(tree[k]);\n          tree[childR(k)].prop(tree[k]);\n        }\n        tree[k].update();\n      }\n\n      public void put(int a, int b, long x) {\n        put(a, b, 0, 0, N, x);\n      }\n\n      private void put(int a, int b, int k, int l, int r, long x) {\n        prop(k);\n\n        if (r <= a || b <= l) return; //区間外\n        if (a <= l && r <= b) { //区間に完全に含まれる\n          tree[k].prop(x, l, r);\n          prop(k);\n        } else { //一部区間外\n          put(a, b, childL(k), l, (l + r) / 2, x);\n          put(a, b, childR(k), (l + r) / 2, r, x);\n          tree[k].operation(tree[childL(k)], tree[childR(k)]);\n        }\n      }\n\n      public SegmentTree(long[] A) {\n        initialNode = new Node();\n\n        //元配列の要素数が2の冪乗でない場合,2の冪乗サイズに拡大して初期値をつめておく\n        while (N < A.length) N *= 2;\n\n        size = N*2-1;\n        tree = new Node[size];\n\n        for (int i=0; i<size; i++) {\n          tree[i] = new Node();\n        }\n\n        for (int i=0; i<A.length; i++) {\n          update(i, A[i]);\n        }\n\n      }\n\n      public Node query(int a, int b) {\n        return query(a, b, 0, 0, N);\n      }\n\n      private Node query(int a, int b, int k, int l, int r) {\n        prop(k);\n\n        if (r <= a || b <= l) return initialNode;\n        if (a <= l && r <= b) return tree[k];\n\n        return new Node().operation(query(a, b, childL(k), l, (l+r)/2), query(a, b, childR(k), (l+r)/2, r));\n      }\n\n      private int parent(int k) {\n        return k % 2 == 0 ? (k-2)/2 : (k-1)/2;\n      }\n\n      private int childL(int k) {\n        return 2*k+1;\n      }\n\n      private int childR(int k) {\n        return 2*k+2;\n      }\n    }\n\n  }\n\n  public static void main(String[] args) {\n    new Solver();\n  }\n\n  static class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int N, boolean oneBased) {\n      if (oneBased) {\n        int[] array = new int[N + 1];\n        for (int i = 1; i <= N; i++) {\n          array[i] = sc.nextInt();\n        }\n        return array;\n      } else {\n        int[] array = new int[N];\n        for (int i = 0; i < N; i++) {\n          array[i] = sc.nextInt();\n        }\n        return array;\n      }\n    }\n\n    public long[] nextLongArray(int N, boolean oneBased) {\n      if (oneBased) {\n        long[] array = new long[N + 1];\n        for (int i = 1; i <= N; i++) {\n          array[i] = sc.nextLong();\n        }\n        return array;\n      } else {\n        long[] array = new long[N];\n        for (int i = 0; i < N; i++) {\n          array[i] = sc.nextLong();\n        }\n        return array;\n      }\n    }\n  }\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.NoSuchElementException;\n\ninterface F1<A> {\n\tA f();\n}\n\ninterface F2<A, B> {\n\tB f(A a);\n}\n\ninterface F3<A, B, C> {\n\tC f(A a, B b);\n}\n\ninterface F4<A, B, C, D> {\n\tD f(A a, B b, C c);\n}\n\nclass U {\n\tstatic <A> ArrayList<A> make(int n, F2<Integer, A> maker) {\n\t\tArrayList<A> res = new ArrayList<A>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tres.add(maker.f(i));\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic <A> ArrayList<A> filter(ArrayList<A> as, F2<A, Boolean> pred) {\n\t\tArrayList<A> res = new ArrayList<A>();\n\t\tfor (A a : as) {\n\t\t\tif (pred.f(a))\n\t\t\t\tres.add(a);\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic <A> ArrayList<A> map(ArrayList<A> as, F2<A, A> f) {\n\t\treturn make(as.size(), (i) -> f.f(as.get(i)));\n\t}\n\n\tstatic <A extends Comparable<A>> A min(A a, A b) {\n\t\treturn a.compareTo(b) < 0 ? a : b;\n\t}\n\n\tstatic <A extends Comparable<A>> A max(A a, A b) {\n\t\treturn a.compareTo(b) > 0 ? a : b;\n\t}\n\n\tstatic <A extends Comparable<A>> A clamp(A a, A min, A max) {\n\t\treturn a.compareTo(min) < 0 ? min : a.compareTo(max) > 0 ? max : a;\n\t}\n}\n\nclass UP<A, B> {\n\tA a;\n\tB b;\n\n\tUP(A a, B b) {\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t}\n\n\tstatic <A, B> UP<A, B> make(A a, B b) {\n\t\treturn new UP<A, B>(a, b);\n\t}\n\n\tpublic UP<A, B> clone() {\n\t\treturn make(a, b);\n\t}\n\n\tpublic boolean equals(Object o) {\n\t\tif (o == this)\n\t\t\treturn true;\n\t\tif (!(o instanceof UP))\n\t\t\treturn false;\n\t\tUP<?, ?> p = (UP<?, ?>) o;\n\t\tboolean aok = a == null ? p.a == null : a.equals(p.a);\n\t\tboolean bok = b == null ? p.b == null : b.equals(p.b);\n\t\treturn aok && bok;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"(\" + a.toString() + \", \" + b.toString() + \")\";\n\t}\n}\n\n//Persistent Lazy Segment Tree\nclass PLST<A, Op> {\n\tprivate class N {\n\t\tfinal A a;\n\t\tfinal Op lazy;\n\t\tfinal N l;\n\t\tfinal N r;\n\n\t\tN(A a, Op lazy, N l, N r) {\n\t\t\tthis.a = a;\n\t\t\tthis.lazy = lazy;\n\t\t\tthis.l = l;\n\t\t\tthis.r = r;\n\t\t}\n\t}\n\n\tprivate ArrayList<N> roots;\n\tprivate F3<A, A, A> merger;\n\tprivate F4<A, Op, Integer, A> applier;\n\tprivate F3<Op, Op, Op> opMerger;\n\tprivate ArrayList<UP<N, A>> pool;\n\tprivate int poolCounter;\n\tprivate A e;\n\tprivate Op id;\n\tprivate int h;\n\tprivate int n;\n\n\tPLST(int num, F3<A, A, A> merger, F4<A, Op, Integer, A> applier, F3<Op, Op, Op> opMerger, A e, Op id) {\n\t\tthis.merger = merger;\n\t\tthis.applier = applier;\n\t\tthis.opMerger = opMerger;\n\t\tthis.e = e;\n\t\tthis.id = id;\n\t\th = 0;\n\t\twhile ((1 << h) < num)\n\t\t\th++;\n\t\tn = 1 << h;\n\t\tN root = init(1, i -> e);\n\t\troots = new ArrayList<N>();\n\t\troots.add(root);\n\t\tpool = U.make(n * 2, i -> UP.make(null, e));\n\t}\n\n\tint init(A[] vals) {\n\t\tN root = init(1, i -> i < vals.length ? vals[i] : e);\n\t\troots.add(root);\n\t\treturn roots.size() - 1;\n\t}\n\n\tA get(int root, int i) {\n\t\treturn query(root, i, i + 1);\n\t}\n\n\tint set(int root, int i, A a) {\n\t\tN newRoot = set(roots.get(root), 0, n, i, a, id);\n\t\troots.add(newRoot);\n\t\treturn roots.size() - 1;\n\t}\n\n\tA query(int root, int from, int until) {\n\t\tUP<N, A> res = query(roots.get(root), from, until, 0, n, id);\n\t\troots.set(root, res.a);\n\t\treturn res.b;\n\t}\n\n\tint apply(int root, int from, int until, Op o) {\n\t\tN newRoot = apply(roots.get(root), from, until, 0, n, id, o);\n\t\troots.add(newRoot);\n\t\treturn roots.size() - 1;\n\t}\n\n\tprivate N init(int k, F2<Integer, A> maker) {\n\t\tif (k >= n) {\n\t\t\treturn new N(maker.f(k - n), id, null, null);\n\t\t}\n\t\tN nl = init(k << 1, maker);\n\t\tN nr = init(k << 1 | 1, maker);\n\t\treturn new N(merge(nl.a, nr.a), id, nl, nr);\n\t}\n\n\tprivate N set(N node, int l, int r, int i, A a, Op lazy) {\n\t\tif (i < l || i >= r) {\n\t\t\tif (lazy == id)\n\t\t\t\treturn node;\n\t\t\treturn new N(node.a, mergeOp(node.lazy, lazy), node.l, node.r);\n\t\t}\n\t\tif (r - l == 1)\n\t\t\treturn new N(a, id, null, null);\n\t\tOp lazyProp = mergeOp(node.lazy, lazy);\n\t\tN nl = set(node.l, l, l + r >> 1, i, a, lazyProp);\n\t\tN nr = set(node.r, l + r >> 1, r, i, a, lazyProp);\n\t\treturn new N(merge(eval(nl, r - l >> 1), eval(nr, r - l >> 1)), id, nl, nr);\n\t}\n\n\tprivate UP<N, A> query(N node, int a, int b, int l, int r, Op lazy) {\n\t\tif (a >= r || b <= l) {\n\t\t\tif (lazy == id)\n\t\t\t\treturn pick(node, e);\n\t\t\treturn pick(new N(node.a, mergeOp(node.lazy, lazy), node.l, node.r), e);\n\t\t}\n\t\tif (a <= l && b >= r) {\n\t\t\tN newNode = new N(node.a, mergeOp(node.lazy, lazy), node.l, node.r);\n\t\t\treturn pick(newNode, eval(newNode, r - l));\n\t\t}\n\t\tOp lazyProp = mergeOp(node.lazy, lazy);\n\t\tUP<N, A> rl = query(node.l, a, b, l, l + r >> 1, lazyProp);\n\t\tUP<N, A> rr = query(node.r, a, b, l + r >> 1, r, lazyProp);\n\t\treturn pick(new N(merge(eval(rl.a, r - l >> 1), eval(rr.a, r - l >> 1)), id, rl.a, rr.a), merge(rl.b, rr.b));\n\t}\n\n\tprivate UP<N, A> pick(N node, A a) {\n\t\tUP<N, A> res = pool.get(poolCounter);\n\t\tpoolCounter = (poolCounter + 1) % pool.size();\n\t\tres.a = node;\n\t\tres.b = a;\n\t\treturn res;\n\t}\n\n\tprivate N apply(N node, int a, int b, int l, int r, Op lazy, Op o) {\n\t\tif (a >= r || b <= l) {\n\t\t\tif (lazy == id)\n\t\t\t\treturn node;\n\t\t\treturn new N(node.a, mergeOp(node.lazy, lazy), node.l, node.r);\n\t\t}\n\t\tif (a <= l && b >= r) {\n\t\t\treturn new N(node.a, mergeOp(mergeOp(node.lazy, lazy), o), node.l, node.r);\n\t\t}\n\t\tOp lazyProp = mergeOp(node.lazy, lazy);\n\t\tN nl = apply(node.l, a, b, l, l + r >> 1, lazyProp, o);\n\t\tN nr = apply(node.r, a, b, l + r >> 1, r, lazyProp, o);\n\t\treturn new N(merge(eval(nl, r - l >> 1), eval(nr, r - l >> 1)), id, nl, nr);\n\t}\n\n\tprivate A merge(A a, A b) {\n\t\treturn a == e ? b : b == e ? a : merger.f(a, b);\n\t}\n\n\tprivate Op mergeOp(Op o, Op p) {\n\t\treturn o == id ? p : p == id ? o : opMerger.f(o, p);\n\t}\n\n\tprivate A apply(A a, Op o, int len) {\n\t\treturn o == id ? a : applier.f(a, o, len);\n\t}\n\n\tprivate A eval(N node, int len) {\n\t\treturn apply(node.a, node.lazy, len);\n\t}\n}\n\npublic class Main {\n\n\t// TODO: solve\n\tprivate static void solve() {\n\t\tint n = nei();\n\t\tint q = nei();\n\t\tPLST<Integer, Integer> lst = new PLST<Integer, Integer>(n, (a, b) -> a + b, (a, f, len) -> f * len,\n\t\t\t\t(f, g) -> g, 0, null);\n\t\tint root = 0;\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tif (nei() == 0) {\n\t\t\t\tint l = nei();\n\t\t\t\tint r = nei() + 1;\n\t\t\t\tint x = nei();\n\t\t\t\troot = lst.apply(root, l, r, x);\n\t\t\t} else {\n\t\t\t\tint l = nei();\n\t\t\t\tint r = nei() + 1;\n\t\t\t\tout(lst.query(root, l, r));\n\t\t\t}\n\t\t}\n\t}\n\n\t// returns (x, y, d) s.t. ax + by = d\n\tstatic long[] exgcd(long a, long b) {\n\t\tint sa = a < 0 ? -1 : 1;\n\t\tint sb = b < 0 ? -1 : 1;\n\t\ta *= sa;\n\t\tb *= sb;\n\t\tlong x = 1;\n\t\tlong y = 0;\n\t\tlong z = 0;\n\t\tlong w = 1;\n\t\twhile (b > 0) {\n\t\t\tlong q = a / b;\n\t\t\tlong t = z;\n\t\t\tz = x - q * z;\n\t\t\tx = t;\n\t\t\tt = w;\n\t\t\tw = y - q * w;\n\t\t\ty = t;\n\t\t\tt = b;\n\t\t\tb = a - q * b;\n\t\t\ta = t;\n\t\t}\n\t\treturn new long[] { x * sa, y * sb, a };\n\t}\n\n\tstatic int[] lis(int[] s) {\n\t\tint n = s.length;\n\t\tint[] dp = new int[n];\n\t\tint[] ids = new int[n];\n\t\tint[] pids = new int[n];\n\t\tdp[0] = s[0];\n\t\tint len = 1;\n\t\tint lidx = 0;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint idx = bs(s[i], dp, 0, len);\n\t\t\tdp[idx] = s[i];\n\t\t\tids[idx] = i;\n\t\t\tif (idx == len) {\n\t\t\t\tlidx = i;\n\t\t\t\tlen++;\n\t\t\t}\n\t\t\tif (idx > 0)\n\t\t\t\tpids[i] = ids[idx - 1];\n\t\t}\n\t\tint[] lis = new int[len];\n\t\tlis[len - 1] = s[lidx];\n\t\tfor (int i = len - 1; i >= 0; i--) {\n\t\t\tlis[i] = s[lidx];\n\t\t\tlidx = pids[lidx];\n\t\t}\n\t\treturn lis;\n\t}\n\n\tstatic int bs(int a, int[] as, int from, int num) {\n\t\tint min = from;\n\t\tint max = from + num - 1;\n\t\twhile (min < max) {\n\t\t\tint mid = min + max >> 1;\n\t\t\tif (as[mid] < a)\n\t\t\t\tmin = mid + 1;\n\t\t\telse if (as[mid] > a)\n\t\t\t\tmax = mid;\n\t\t\telse\n\t\t\t\treturn mid;\n\t\t}\n\t\treturn as[min] < a ? min + 1 : min;\n\t}\n\n\tstatic int gcd(int x, int y) {\n\t\tx = (x ^ x >> 31) - (x >> 31);\n\t\ty = (y ^ y >> 31) - (y >> 31);\n\t\tif (x < y) {\n\t\t\tx ^= y;\n\t\t\ty ^= x;\n\t\t\tx ^= y;\n\t\t}\n\t\tint z = x % y;\n\t\tif (z == 0)\n\t\t\treturn y;\n\t\treturn gcd(y, z);\n\t}\n\n\tstatic long gcd(long x, long y) {\n\t\tx = (x ^ x >> 63) - (x >> 63);\n\t\ty = (y ^ y >> 63) - (y >> 63);\n\t\tif (x < y) {\n\t\t\tx ^= y;\n\t\t\ty ^= x;\n\t\t\tx ^= y;\n\t\t}\n\t\tlong z = x % y;\n\t\tif (z == 0)\n\t\t\treturn y;\n\t\treturn gcd(y, z);\n\t}\n\n\tstatic long modinv(long a, long mod) {\n\t\treturn modpow(a, mod - 2, mod);\n\t}\n\n\tstatic long modpow(long a, long b, long mod) {\n\t\tif (b == 0)\n\t\t\treturn 1;\n\t\tif ((b & 1) == 0) {\n\t\t\tlong sqrt = modpow(a, b >> 1, mod);\n\t\t\treturn sqrt * sqrt % mod;\n\t\t}\n\t\treturn a * modpow(a, b - 1, mod) % mod;\n\t}\n\n\tstatic long fact(long n) {\n\t\tif (n <= 1)\n\t\t\treturn 1;\n\t\tlong res = 2;\n\t\tfor (long i = 3; i <= n; i++) {\n\t\t\tres *= i;\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic long modfact(long n, long mod) {\n\t\tif (n <= 1)\n\t\t\treturn 1 % mod;\n\t\tlong res = 2;\n\t\tfor (long i = 3; i <= n; i++) {\n\t\t\tres *= i;\n\t\t\tres %= mod;\n\t\t}\n\t\treturn res % mod;\n\t}\n\n\t// returns facts([0]) and invfacts([1])\n\tstatic long[][] enumfacts(int n, long mod) {\n\t\tint num = n + 10;\n\t\tlong[][] res = new long[2][num];\n\t\tlong[] facts = res[0];\n\t\tlong[] invfacts = res[1];\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tif (i <= 1) {\n\t\t\t\tfacts[i] = 1;\n\t\t\t\tinvfacts[i] = 1;\n\t\t\t} else {\n\t\t\t\tfacts[i] = facts[i - 1] * i % mod;\n\t\t\t\tinvfacts[i] = modinv(facts[i], mod);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic long modcomb(long n, long m, long mod) {\n\t\tif (m > n)\n\t\t\treturn 0;\n\t\tif (m > n - m) {\n\t\t\tm = n - m;\n\t\t}\n\t\tlong numer = 1;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tnumer = numer * (n - i) % mod;\n\t\t}\n\t\tlong denom = modfact(m, mod);\n\t\treturn numer * modinv(denom, mod) % mod;\n\t}\n\n\tstatic long modcomb(int n, int m, long[] facts, long[] invfacts, long mod) {\n\t\tif (m > n)\n\t\t\treturn 0;\n\t\tlong numer = facts[n];\n\t\tlong denom = invfacts[m] * invfacts[n - m] % mod;\n\t\treturn numer * denom % mod;\n\t}\n\n\t// res[i][0]: prime factor, res[i][1]: exponent\n\tstatic int[][] factorize(int n) {\n\t\tint[][] pfs = new int[32][2];\n\t\tint num = 0;\n\t\tfor (int i = 2; i * i <= n; i++) {\n\t\t\tint count = 0;\n\t\t\twhile (n % i == 0) {\n\t\t\t\tn /= i;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif (count > 0) {\n\t\t\t\tpfs[num][0] = i;\n\t\t\t\tpfs[num][1] = count;\n\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\t\tif (n > 1) {\n\t\t\tpfs[num][0] = n;\n\t\t\tpfs[num][1] = 1;\n\t\t\tnum++;\n\t\t}\n\t\tint[][] res = new int[num][2];\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tres[i][0] = pfs[i][0];\n\t\t\tres[i][1] = pfs[i][1];\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic long lcm(long x, long y) {\n\t\tx = (x ^ x >> 63) - (x >> 63);\n\t\ty = (y ^ y >> 63) - (y >> 63);\n\t\treturn x / gcd(x, y) * y;\n\t}\n\n\tstatic int abs(int x) {\n\t\treturn x < 0 ? -x : x;\n\t}\n\n\tstatic long abs(long x) {\n\t\treturn x < 0 ? -x : x;\n\t}\n\n\tstatic int min(int a, int b) {\n\t\treturn a < b ? a : b;\n\t}\n\n\tstatic long min(long a, long b) {\n\t\treturn a < b ? a : b;\n\t}\n\n\tstatic int max(int a, int b) {\n\t\treturn a > b ? a : b;\n\t}\n\n\tstatic long max(long a, long b) {\n\t\treturn a > b ? a : b;\n\t}\n\n\tstatic int clamp(int a, int min, int max) {\n\t\treturn a < min ? min : a > max ? max : a;\n\t}\n\n\tstatic long clamp(long a, long min, long max) {\n\t\treturn a < min ? min : a > max ? max : a;\n\t}\n\n\tstatic double clamp(double a, double min, double max) {\n\t\treturn a < min ? min : a > max ? max : a;\n\t}\n\n\tstatic void out(String val) {\n\t\tIO.out(val);\n\t}\n\n\tstatic void out(Object val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void out(int val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void out(long val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void out(char val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void out(double val) {\n\t\tIO.out(Double.isFinite(val) ? BigDecimal.valueOf(val).toPlainString() : String.valueOf(val));\n\t}\n\n\tstatic void out(boolean val) {\n\t\tIO.out(val ? \"true\" : \"false\");\n\t}\n\n\tstatic void kil(String val) {\n\t\tIO.out(val);\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(Object val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(int val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(long val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(char val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(double val) {\n\t\tIO.out(Double.isFinite(val) ? BigDecimal.valueOf(val).toPlainString() : String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(boolean val) {\n\t\tIO.out(val ? \"true\" : \"false\");\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic String nes() {\n\t\treturn IO.next();\n\t}\n\n\tstatic int nei() {\n\t\treturn IO.nextInt();\n\t}\n\n\tstatic long nel() {\n\t\treturn IO.nextLong();\n\t}\n\n\tstatic double ned() {\n\t\treturn IO.nextDouble();\n\t}\n\n\tstatic char nec() {\n\t\treturn IO.nextChar();\n\t}\n\n\tstatic String[] nss(int n) {\n\t\tString[] as = new String[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.next();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic int[] nis(int n) {\n\t\tint[] as = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.nextInt();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic long[] nls(int n) {\n\t\tlong[] as = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.nextLong();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic double[] nds(int n) {\n\t\tdouble[] as = new double[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.nextDouble();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic char[] ncs(int n) {\n\t\tchar[] as = new char[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.nextChar();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic String[][] nss2(int n, int m) {\n\t\tString[][] as = new String[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.next();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic int[][] nis2(int n, int m) {\n\t\tint[][] as = new int[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.nextInt();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic long[][] nls2(int n, int m) {\n\t\tlong[][] as = new long[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.nextLong();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic double[][] nds2(int n, int m) {\n\t\tdouble[][] as = new double[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.nextDouble();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic char[][] ncs2(int n, int m) {\n\t\tchar[][] as = new char[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.nextChar();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic int parseInt(String val) {\n\t\treturn Integer.parseInt(val);\n\t}\n\n\tstatic int parseInt(char val) {\n\t\treturn Integer.parseInt(String.valueOf(val));\n\t}\n\n\tstatic long parseLong(String val) {\n\t\treturn Long.parseLong(val);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tsolve();\n\t\t\tIO.flush();\n\t\t} catch (NumberFormatException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n\nfinal class IO {\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out, false);\n\tprivate static final byte[] buffer = new byte[1024];\n\tprivate static int ptr = 0;\n\tprivate static int len = 0;\n\n\tprivate static boolean hasNextByte() {\n\t\tif (ptr < len)\n\t\t\treturn true;\n\t\tptr = 0;\n\t\ttry {\n\t\t\tlen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn len > 0;\n\t}\n\n\tprivate static int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\tstatic boolean hasNext() {\n\t\tbyte c;\n\t\twhile (hasNextByte() && ((c = buffer[ptr]) < '!' || c > '~'))\n\t\t\tptr++;\n\t\treturn hasNextByte();\n\t}\n\n\tstatic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (b >= '!' && b <= '~') {\n\t\t\tsb.append((char) b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic char nextChar() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\treturn (char) readByte();\n\t}\n\n\tstatic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tint sign = 1;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tsign = -1;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b)\n\t\t\tthrow new NumberFormatException();\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9')\n\t\t\t\tn = n * 10 + b - '0';\n\t\t\telse if (b == -1 || b < '!' || b > '~')\n\t\t\t\treturn n * sign;\n\t\t\telse\n\t\t\t\tthrow new NumberFormatException();\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tstatic int nextInt() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tint n = 0;\n\t\tint sign = 1;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tsign = -1;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b)\n\t\t\tthrow new NumberFormatException();\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9')\n\t\t\t\tn = n * 10 + b - '0';\n\t\t\telse if (b == -1 || b < '!' || b > '~')\n\t\t\t\treturn n * sign;\n\t\t\telse\n\t\t\t\tthrow new NumberFormatException();\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tstatic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tstatic void out(String val) {\n\t\tout.println(val);\n\t}\n\n\tstatic void flush() {\n\t\tout.flush();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass LazySegmentTree {\n\n\tint[] nodes;\n\tint[] lazy;\n\tboolean[] isLazy;\n\n\tint n;\n\tint e; // 単位元\n\n\tpublic LazySegmentTree(int size) {\n\t\tn = 1;\n\t\twhile (n < size) {\n\t\t\tn *= 2;\n\t\t}\n\n\t\tnodes = new int[2 * n - 1];\n\t\tlazy = new int[2 * n - 1];\n\t\tisLazy = new boolean[2 * n - 1];\n\n\t\te = 0; // 単位元は0\n\t}\n\n\tprivate void eval(int k, int l, int r) {\n\t\tif (isLazy[k]) {\n\n\t\t\t// 葉でないなら\n\t\t\tif (r - l > 1) {\n\t\t\t\t// 子に伝搬\n\t\t\t\tlazy[2 * k + 1] = lazy[k] / 2;\n\t\t\t\tlazy[2 * k + 2] = lazy[k] / 2;\n\n\t\t\t\tisLazy[2 * k + 1] = true;\n\t\t\t\tisLazy[2 * k + 2] = true;\n\t\t\t}\n\n\t\t\tnodes[k] = lazy[k];\n\n\t\t\tlazy[k] = 0;\n\t\t\tisLazy[k] = false;\n\t\t}\n\t}\n\n\tprivate void update(int a, int b, int val, int k, int l, int r) {\n\t\teval(k, l, r);\n\t\tif (a >= r || b <= l) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (a <= l && r <= b) {\n\t\t\tlazy[k] = (r - l) * val;\n\t\t\tisLazy[k] = true;\n\t\t\teval(k, l, r);\n\t\t\treturn;\n\t\t}\n\n\t\tupdate(a, b, val, 2 * k + 1, l, (l + r) / 2);\n\t\tupdate(a, b, val, 2 * k + 2, (l + r) / 2, r);\n\n\t\tnodes[k] = nodes[2 * k + 1] + nodes[2 * k + 2];\n\n\t}\n\n\tprivate int getSum(int a, int b, int k, int l, int r) {\n\t\tif (a >= r || b <= l) {\n\t\t\treturn e;\n\t\t}\n\n\t\teval(k, l, r);\n\t\tif (a <= l && r <= b) {\n\t\t\treturn nodes[k];\n\t\t}\n\n\t\tint vl = getSum(a, b, 2 * k + 1, l, (l + r) / 2);\n\t\tint vr = getSum(a, b, 2 * k + 2, (l + r) / 2, r);\n\n\t\treturn vl + vr;\n\n\t}\n\n\tpublic void update(int a, int b, int val) {\n\t\tupdate(a, b, val, 0, 0, n);\n\t}\n\n\tpublic int getSum(int a, int b) {\n\t\treturn getSum(a, b, 0, 0, n);\n\t}\n\n\tpublic String debug() {\n\t\tStringBuffer buf = new StringBuffer();\n\t\t\n\t\tfor(int s=0,n=1;s<nodes.length;s+=n,n*=2) {\n\t\t\tbuf.append(_debug(nodes,s,s+n, this.n));\n\t\t\tbuf.append(\"\\n\");\n\t\t}\n\t\t\n\t\tbuf.append(\"--\\n\");\n\t\t\n\t\tfor(int s=0,n=1;s<lazy.length;s+=n,n*=2) {\n\t\t\tbuf.append(_debug(lazy,s,s+n, this.n));\n\t\t\tbuf.append(\"\\n\");\n\t\t}\n\t\treturn buf.toString();\n\t}\n\t\n\tprivate String _debug(int[] a, int s, int e, int x) {\n\t\tStringBuffer buf = new StringBuffer();\n\t\tfor(int i=s;i<e;i++) {\n\t\t\tbuf.append(a[i]);\n\t\t\tfor(int j=0;j<(2*x)/(e-s) -1;j++) \n\t\t\t\tbuf.append(\" \");\n\t\t}\n\t\treturn buf.toString();\n\t}\n\t\n\n\t\n}\n\npublic class Main {\n\tInputStream in = System.in;\n\tPrintStream out = System.out;\n\n\tpublic void _main(String[] args) {\n\t\tScanner sc = new Scanner(in);\n\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\n\t\tLazySegmentTree seg = new LazySegmentTree(n);\n\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint c = sc.nextInt();\n\t\t\tif (c == 0) {\n\t\t\t\tint s = sc.nextInt();\n\t\t\t\tint t = sc.nextInt() + 1;\n\t\t\t\tint x = sc.nextInt();\n\n\t\t\t\tseg.update(s, t, x);\n\n\t\t\t} else {\n\t\t\t\tint s = sc.nextInt();\n\t\t\t\tint t = sc.nextInt() + 1;\n\n\t\t\t\tout.println(seg.getSum(s, t));\n\t\t\t}\n\t\t}\n\n\t\tsc.close();\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main()._main(args);\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.util.function.LongBinaryOperator;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.UncheckedIOException;\nimport java.nio.charset.Charset;\nimport java.util.StringTokenizer;\nimport java.io.Writer;\nimport java.security.AccessControlException;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedReader;\nimport java.util.regex.Pattern;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author mikit\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        LightScanner in = new LightScanner(inputStream);\n        LightWriter out = new LightWriter(outputStream);\n        DSL_2_I solver = new DSL_2_I();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DSL_2_I {\n        public void solve(int testNumber, LightScanner in, LightWriter out) {\n            Debug.autoEnable();\n\n            int n = in.ints(), queries = in.ints();\n            long[] a = new long[n];\n            IntLazySegmentTree st = new IntLazySegmentTree(a, (x, y) -> x + y, 0,\n                    (x, q) -> q, (q1, q2) -> q2, -1001, (q, m) -> q * m);\n            for (int i = 0; i < queries; i++) {\n                int com = in.ints();\n                if (com == 0) {\n                    int s = in.ints(), t = in.ints(), x = in.ints();\n                    st.update(s, t + 1, x);\n                } else {\n                    int s = in.ints(), t = in.ints();\n                    out.ans(st.query(s, t + 1)).ln();\n                }\n            }\n        }\n\n    }\n\n    static class LightWriter implements AutoCloseable {\n        private final Writer out;\n        private boolean autoflush = false;\n        private boolean breaked = true;\n\n        public LightWriter(Writer out) {\n            this.out = out;\n        }\n\n        public LightWriter(OutputStream out) {\n            this(new BufferedWriter(new OutputStreamWriter(out, Charset.defaultCharset())));\n        }\n\n        public LightWriter print(char c) {\n            try {\n                out.write(c);\n                breaked = false;\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            return this;\n        }\n\n        public LightWriter print(String s) {\n            try {\n                out.write(s, 0, s.length());\n                breaked = false;\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            return this;\n        }\n\n        public LightWriter ans(String s) {\n            if (!breaked) {\n                print(' ');\n            }\n            return print(s);\n        }\n\n        public LightWriter ans(long l) {\n            return ans(Long.toString(l));\n        }\n\n        public LightWriter ln() {\n            print(System.lineSeparator());\n            breaked = true;\n            if (autoflush) {\n                try {\n                    out.flush();\n                } catch (IOException ex) {\n                    throw new UncheckedIOException(ex);\n                }\n            }\n            return this;\n        }\n\n        public void close() {\n            try {\n                out.close();\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n        }\n\n    }\n\n    static class Debug {\n        private static final String DEBUG_PROPERTY = \"debug\";\n        private static final String DEBUG_CALL_PATTERN = \"^.+\\\\.debug\\\\((.+)\\\\);.*$\";\n        private static Pattern debugRegex;\n        private static boolean enabled = false;\n        private static String src;\n\n        public static void enable(String s) {\n            enabled = true;\n            src = s;\n            if (debugRegex == null) {\n                debugRegex = Pattern.compile(DEBUG_CALL_PATTERN);\n            }\n        }\n\n        public static boolean autoEnable() {\n            try {\n                String s = System.getProperty(DEBUG_PROPERTY);\n                if (s != null) {\n                    enable(s);\n                    return true;\n                }\n            } catch (AccessControlException ex) {\n                src = null;\n            }\n            return false;\n        }\n\n    }\n\n    static class IntLazySegmentTree {\n        private final int n;\n        private final int m;\n        private final long[] tree;\n        private final long[] lazy;\n        private final LongBinaryOperator op;\n        private final long zero;\n        private final LongBinaryOperator up;\n        private final LongBinaryOperator merge;\n        private final long nop;\n        private final LongIntToLongFunction mul;\n\n        public IntLazySegmentTree(long[] array, LongBinaryOperator op, long zero, LongBinaryOperator up,\n                                  LongBinaryOperator merge, long nop,\n                                  LongIntToLongFunction mul) {\n            this.n = array.length;\n            int msb = BitMath.extractMsb(n);\n            this.m = n == msb ? msb : (msb << 1);\n            this.op = op;\n            this.zero = zero;\n            this.up = up;\n            this.merge = merge;\n            this.nop = nop;\n            this.mul = mul;\n            this.tree = new long[m * 2 - 1];\n            Arrays.fill(tree, zero);\n            System.arraycopy(array, 0, this.tree, m - 1, array.length);\n            this.lazy = new long[m * 2 - 1];\n            Arrays.fill(lazy, nop);\n            for (int i = m - 2; i >= 0; i--) {\n                tree[i] = op.applyAsLong(tree[2 * i + 1], tree[2 * i + 2]);\n            }\n        }\n\n        public IntLazySegmentTree(long[] array, LongBinaryOperator op, long zero, LongBinaryOperator up,\n                                  LongBinaryOperator merge, long nop) {\n            this(array, op, zero, up, merge, nop, (q, n) -> q);\n        }\n\n        private void eval(int len, int k) {\n            if (lazy[k] == nop) {\n                return;\n            } else if (k * 2 + 1 < m * 2 - 1) {\n                lazy[k * 2 + 1] = merge.applyAsLong(lazy[k * 2 + 1], lazy[k]);\n                lazy[k * 2 + 2] = merge.applyAsLong(lazy[k * 2 + 2], lazy[k]);\n            }\n            tree[k] = up.applyAsLong(tree[k], mul.applyAsLong(lazy[k], len));\n            lazy[k] = nop;\n        }\n\n        private long update(int l, int r, long q, int k, int sl, int sr) {\n            if (r <= sl || sr <= l) {\n                eval(sr - sl, k);\n                return tree[k];\n            }\n            if (l <= sl && sr <= r) {\n                lazy[k] = merge.applyAsLong(lazy[k], q);\n                eval(sr - sl, k);\n                return tree[k];\n            } else {\n                eval(sr - sl, k);\n                return tree[k] = op.applyAsLong(\n                        update(l, r, q, k * 2 + 1, sl, (sl + sr) / 2),\n                        update(l, r, q, k * 2 + 2, (sl + sr) / 2, sr)\n                );\n            }\n        }\n\n        public void update(int l, int r, long q) {\n            update(l, r, q, 0, 0, m);\n        }\n\n        private long query(int l, int r, int k, int sl, int sr) {\n            if (r <= sl || sr <= l) {\n                return zero;\n            }\n            eval(sr - sl, k);\n            if (l <= sl && sr <= r) {\n                return tree[k];\n            } else {\n                long left = query(l, r, 2 * k + 1, sl, (sl + sr) / 2);\n                long right = query(l, r, 2 * k + 2, (sl + sr) / 2, sr);\n                return op.applyAsLong(left, right);\n            }\n        }\n\n        public long query(int l, int r) {\n            return query(l, r, 0, 0, m);\n        }\n\n    }\n\n    static interface LongIntToLongFunction<T, R> {\n        long applyAsLong(long x, int y);\n\n    }\n\n    static final class BitMath {\n        private BitMath() {\n        }\n\n        public static int extractMsb(int v) {\n            v = (v & 0xFFFF0000) > 0 ? v & 0xFFFF0000 : v;\n            v = (v & 0xFF00FF00) > 0 ? v & 0xFF00FF00 : v;\n            v = (v & 0xF0F0F0F0) > 0 ? v & 0xF0F0F0F0 : v;\n            v = (v & 0xCCCCCCCC) > 0 ? v & 0xCCCCCCCC : v;\n            v = (v & 0xAAAAAAAA) > 0 ? v & 0xAAAAAAAA : v;\n            return v;\n        }\n\n    }\n\n    static class LightScanner {\n        private BufferedReader reader = null;\n        private StringTokenizer tokenizer = null;\n\n        public LightScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public String string() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new UncheckedIOException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int ints() {\n            return Integer.parseInt(string());\n        }\n\n    }\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.text.DecimalFormat;\nimport java.util.*;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.logging.Logger;\n\nimport javax.sound.midi.MidiMessage;\n \npublic class Main {\n\t  static int MAX = 510000;\n\t\tstatic long[] fac=new long[MAX];\n\t\tstatic long[] finv=new long[MAX];\n\t\tstatic long[] inv=new long[MAX];\n\t\tstatic long MOD=(long) (Math.pow(10, 9)+7);\n\t\tstatic boolean[] visited;\n\tpublic static void main(String[] args){\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tInputReader sc=new InputReader(System.in);\n\t\tint N=sc.nextInt();\n\t\tint q=sc.nextInt();\n\t\tLazysegTreesum lazysegTreesum=new LazysegTreesum(N);\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint c=sc.nextInt();\n\t\t\tif (c==0) {\n\t\t\t\tint s=sc.nextInt();\n\t\t\t\tint t=sc.nextInt()+1;\n\t\t\t\tlong x=sc.nextLong();\n\t\t\t\tlazysegTreesum.update(s, t, x, 0, 0, lazysegTreesum.size);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint s=sc.nextInt();\n\t\t\t\tint t=sc.nextInt()+1;\n\t\t\t\tout.println(lazysegTreesum.getsum(s, t, 0, 0, lazysegTreesum.size));\n\t\t\t}\n\t\t}\n\t\tout.flush();\n\t}\n\tstatic class LazysegTreesum{\n\t\tint size;\n\t\tlong[] dat;\n\t\tlong[] lazy;\n\t\tlong MINF=Long.MIN_VALUE;\n\t\tpublic LazysegTreesum(int n) {\n\t\t\tint n_=1;\n\t\t\twhile (n_<n) {\n\t\t\t\tn_*=2;\n\t\t\t}\n\t\t\tsize=n_;\n\t\t\tdat=new long[2*n_-1];\n\t\t\tlazy=new long[2*n_-1];\n\t\t\tArrays.fill(lazy, MINF);\n\t\t}\n\t\tvoid propagate(int k,int l,int r) {\n\t\t\tif (lazy[k]!=MINF) {\n\t\t\t\tdat[k] = lazy[k];\n\t\t\t\tif(r - l > 1) {\n\t\t            lazy[2*k+1] = lazy[k]/2;\n\t\t            lazy[2*k+2] = lazy[k]/2;\n\t\t        }\n\t\t        lazy[k] = MINF;\n\t\t\t}\n\t\t}\n\t\tvoid update(int a,int b,long x,int k,int l,int r) {//a<=x<b加算　add(...,0,0,seg.size)で呼ぶ\n\t\t\tthis.propagate(k,l,r);\n\t\t\tif (a<=l&&r<=b) {\n\t\t\t\tlazy[k]=(long)(r-l)*x;\n\t\t\t\tthis.propagate(k,l,r);\n\t\t\t}\n\t\t\telse if (l<b&&a<r) {//交わっている場合\n\t\t\t\tthis.update(a, b, x, k*2+1,l,(l+r)/2);\n\t\t\t\tthis.update(a, b, x, k*2+2, (l+r)/2, r);\n\t\t\t\tdat[k] = dat[2*k+1]+dat[2*k+2];\n\t\t\t}\n\t\t}\n\t\tlong getsum(int a,int b,int k,int l,int r) {//kが節点番号,l rがその節点番号の範囲\n\t\t\tif (r<=a||b<=l) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tthis.propagate(k, l, r);\n\t\t\tif (a<=l&&r<=b) {\n\t\t\t\treturn dat[k];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlong vl=this.getsum(a, b, k*2+1,l,(l+r)/2);\n\t\t\t\tlong vr=this.getsum(a, b, k*2+2, (l+r)/2, r);\n\t\t\t\treturn (vl+vr);\n\t\t\t}\n\t\t}//getsum(x, y, 0, 0, size)で呼ぶ\n\t}\n\tstatic class InputReader { \n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n \n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n \n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n \n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n \n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n \n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n \n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n \n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n \n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n \n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n \n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n \n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n \n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.NoSuchElementException;\n\n//Unordered Pair\nclass UP<A, B> {\n\tA a;\n\tB b;\n\n\tUP(A a, B b) {\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t}\n\n\tstatic <A, B> UP<A, B> make(A a, B b) {\n\t\treturn new UP<A, B>(a, b);\n\t}\n\n\tpublic UP<A, B> clone() {\n\t\treturn make(a, b);\n\t}\n\n\tpublic boolean equals(Object o) {\n\t\tif (o == this)\n\t\t\treturn true;\n\t\tif (!(o instanceof UP))\n\t\t\treturn false;\n\t\tUP<?, ?> p = (UP<?, ?>) o;\n\t\tboolean aok = a == null ? p.a == null : a.equals(p.a);\n\t\tboolean bok = b == null ? p.b == null : b.equals(p.b);\n\t\treturn aok && bok;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"(\" + a.toString() + \", \" + b.toString() + \")\";\n\t}\n}\n\ninterface F1<A> {\n\tA f();\n}\n\ninterface F2<A, B> {\n\tB f(A a);\n}\n\ninterface F3<A, B, C> {\n\tC f(A a, B b);\n}\n\ninterface F4<A, B, C, D> {\n\tD f(A a, B b, C c);\n}\n\n// util\nclass U {\n\tstatic <A> ArrayList<A> make(int n, F2<Integer, A> maker) {\n\t\tArrayList<A> res = new ArrayList<A>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tres.add(maker.f(i));\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic <A> ArrayList<A> filter(ArrayList<A> as, F2<A, Boolean> pred) {\n\t\tArrayList<A> res = new ArrayList<A>();\n\t\tfor (A a : as) {\n\t\t\tif (pred.f(a))\n\t\t\t\tres.add(a);\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic <A> ArrayList<A> map(ArrayList<A> as, F2<A, A> f) {\n\t\treturn make(as.size(), (i) -> f.f(as.get(i)));\n\t}\n\n\tstatic <A, B> ArrayList<UP<A, B>> zip(ArrayList<A> as, ArrayList<B> bs) {\n\t\treturn make(min(as.size(), bs.size()), (i) -> UP.make(as.get(i), bs.get(i)));\n\t}\n\n\tstatic <A extends Comparable<A>> A min(A a, A b) {\n\t\treturn a.compareTo(b) < 0 ? a : b;\n\t}\n\n\tstatic <A extends Comparable<A>> A max(A a, A b) {\n\t\treturn a.compareTo(b) > 0 ? a : b;\n\t}\n\n\tstatic <A extends Comparable<A>> A clamp(A a, A min, A max) {\n\t\treturn a.compareTo(min) < 0 ? min : a.compareTo(max) > 0 ? max : a;\n\t}\n}\n\n//Lazy Segment Tree\nclass LST<A, Op> {\n\t// 0: unused, 1: root\n\tprivate ArrayList<A> dat;\n\tprivate ArrayList<Op> lazy;\n\tprivate F3<A, A, A> merger;\n\tprivate F3<A, Op, A> applier;\n\tprivate F3<Op, Op, Op> opMerger;\n\tprivate F3<Op, Integer, Op> multiplier;\n\tprivate A e;\n\tprivate Op id;\n\tprivate int h;\n\tprivate int n;\n\n\tLST(int num, F3<A, A, A> merger, F3<A, Op, A> applier, F3<Op, Op, Op> opMerger, A e, Op id) {\n\t\tthis(num, merger, applier, opMerger, null, e, id);\n\t}\n\n\tLST(int num, F3<A, A, A> merger, F3<A, Op, A> applier, F3<Op, Op, Op> opMerger, F3<Op, Integer, Op> multiplier,\n\t\t\tA e, Op id) {\n\t\tthis.merger = merger;\n\t\tthis.applier = applier;\n\t\tthis.opMerger = opMerger;\n\t\tthis.multiplier = multiplier;\n\t\tthis.e = e;\n\t\tthis.id = id;\n\t\th = 0;\n\t\twhile ((1 << h) < num)\n\t\t\th++;\n\t\tn = 1 << h;\n\t\tint size = n << 1;\n\t\tdat = U.make(size, (i) -> e);\n\t\tlazy = U.make(size, (i) -> id);\n\t}\n\n\tvoid init(A[] as) {\n\t\tfor (int i = 0; i < n << 1; i++) {\n\t\t\tlazy.set(i, id);\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdat.set(n + i, i < as.length ? as[i] : e);\n\t\t}\n\t\tfor (int i = n - 1; i > 0; i--) {\n\t\t\tdat.set(i, merge(dat.get(i << 1), dat.get(i << 1 | 1)));\n\t\t}\n\t}\n\n\tA get(int i) {\n\t\treturn query(i, i + 1);\n\t}\n\n\tvoid set(int i, A a) {\n\t\tquery(i, i + 1);\n\t\ti += n;\n\t\tdat.set(i, a);\n\t\twhile ((i >>= 1) > 0) {\n\t\t\tdat.set(i, merge(dat.get(i << 1), dat.get(i << 1 | 1)));\n\t\t}\n\t}\n\n\tvoid apply(int from, int until, Op o) {\n\t\tapplyImpl(from, until, 1, 0, n, o);\n\t}\n\n\tA query(int from, int until) {\n\t\treturn queryImpl(from, until, 1, 0, n);\n\t}\n\n\tint size() {\n\t\treturn n;\n\t}\n\n\tprivate A merge(A a, A b) {\n\t\treturn a == e ? b : b == e ? a : merger.f(a, b);\n\t}\n\n\tprivate Op mergeOp(Op o, Op p) {\n\t\treturn o == id ? p : p == id ? o : opMerger.f(o, p);\n\t}\n\n\tprivate A apply(A a, Op o) {\n\t\treturn o == id ? a : applier.f(a, o);\n\t}\n\n\tprivate Op multiply(Op o, int num) {\n\t\treturn o == id || multiplier == null || num == 1 ? o : multiplier.f(o, num);\n\t}\n\n\tprivate void eval(int k, int len) {\n\t\tOp o = lazy.get(k);\n\t\tif (o == id)\n\t\t\treturn;\n\t\tif (k < n) {\n\t\t\tlazy.set(k << 1, mergeOp(lazy.get(k << 1), o));\n\t\t\tlazy.set(k << 1 | 1, mergeOp(lazy.get(k << 1 | 1), o));\n\t\t}\n\t\tdat.set(k, apply(dat.get(k), multiply(o, len)));\n\t\tlazy.set(k, id);\n\t}\n\n\tprivate A queryImpl(int a, int b, int k, int l, int r) {\n\t\teval(k, r - l);\n\t\tif (r <= a || b <= l)\n\t\t\treturn e;\n\t\tif (a <= l && r <= b)\n\t\t\treturn dat.get(k);\n\t\tA al = queryImpl(a, b, k << 1, l, l + r >> 1);\n\t\tA ar = queryImpl(a, b, k << 1 | 1, l + r >> 1, r);\n\t\treturn merge(al, ar);\n\t}\n\n\tprivate A applyImpl(int a, int b, int k, int l, int r, Op o) {\n\t\teval(k, r - l);\n\t\tif (r <= a || b <= l)\n\t\t\treturn dat.get(k);\n\t\tif (a <= l && r <= b) {\n\t\t\tlazy.set(k, mergeOp(lazy.get(k), o));\n\t\t\treturn apply(dat.get(k), multiply(lazy.get(k), r - l));\n\t\t}\n\t\tA al = applyImpl(a, b, k << 1, l, l + r >> 1, o);\n\t\tA ar = applyImpl(a, b, k << 1 | 1, l + r >> 1, r, o);\n\t\tA res = merge(al, ar);\n\t\tdat.set(k, res);\n\t\treturn res;\n\t}\n}\n\npublic class Main {\n\n\t// TODO: solve\n\tprivate static void solve() {\n\t\tint n = nei();\n\t\tint q = nei();\n\t\tLST<Integer, Integer> lst = new LST<Integer, Integer>(n,\n\t\t\t\t(a,b)->a+b,\n\t\t\t\t(a,f)->f,\n\t\t\t\t(f,g)->g,\n\t\t\t\t(f,num)->f*num,\n\t\t\t\t0,null);\n\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tif (nei() == 0) {\n\t\t\t\tint s = nei();\n\t\t\t\tint t = nei();\n\t\t\t\tint x = nei();\n\t\t\t\tlst.apply(s, t + 1, x);\n\t\t\t} else {\n\t\t\t\tint s = nei();\n\t\t\t\tint t = nei();\n\t\t\t\tout(lst.query(s, t + 1));\n\t\t\t}\n\t\t}\n\t}\n\n\t// returns (x, y, d) s.t. ax + by = d\n\tstatic long[] exgcd(long a, long b) {\n\t\tint sa = a < 0 ? -1 : 1;\n\t\tint sb = b < 0 ? -1 : 1;\n\t\ta *= sa;\n\t\tb *= sb;\n\t\tlong x = 1;\n\t\tlong y = 0;\n\t\tlong z = 0;\n\t\tlong w = 1;\n\t\twhile (b > 0) {\n\t\t\tlong q = a / b;\n\t\t\tlong t = z;\n\t\t\tz = x - q * z;\n\t\t\tx = t;\n\t\t\tt = w;\n\t\t\tw = y - q * w;\n\t\t\ty = t;\n\t\t\tt = b;\n\t\t\tb = a - q * b;\n\t\t\ta = t;\n\t\t}\n\t\treturn new long[] { x * sa, y * sb, a };\n\t}\n\n\tstatic int[] lis(int[] s) {\n\t\tint n = s.length;\n\t\tint[] dp = new int[n];\n\t\tint[] ids = new int[n];\n\t\tint[] pids = new int[n];\n\t\tdp[0] = s[0];\n\t\tint len = 1;\n\t\tint lidx = 0;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint idx = bs(s[i], dp, 0, len);\n\t\t\tdp[idx] = s[i];\n\t\t\tids[idx] = i;\n\t\t\tif (idx == len) {\n\t\t\t\tlidx = i;\n\t\t\t\tlen++;\n\t\t\t}\n\t\t\tif (idx > 0)\n\t\t\t\tpids[i] = ids[idx - 1];\n\t\t}\n\t\tint[] lis = new int[len];\n\t\tlis[len - 1] = s[lidx];\n\t\tfor (int i = len - 1; i >= 0; i--) {\n\t\t\tlis[i] = s[lidx];\n\t\t\tlidx = pids[lidx];\n\t\t}\n\t\treturn lis;\n\t}\n\n\tstatic int bs(int a, int[] as, int from, int num) {\n\t\tint min = from;\n\t\tint max = from + num - 1;\n\t\twhile (min < max) {\n\t\t\tint mid = min + max >> 1;\n\t\t\tif (as[mid] < a)\n\t\t\t\tmin = mid + 1;\n\t\t\telse if (as[mid] > a)\n\t\t\t\tmax = mid;\n\t\t\telse\n\t\t\t\treturn mid;\n\t\t}\n\t\treturn as[min] < a ? min + 1 : min;\n\t}\n\n\tstatic int gcd(int x, int y) {\n\t\tx = (x ^ x >> 31) - (x >> 31);\n\t\ty = (y ^ y >> 31) - (y >> 31);\n\t\tif (x < y) {\n\t\t\tx ^= y;\n\t\t\ty ^= x;\n\t\t\tx ^= y;\n\t\t}\n\t\tint z = x % y;\n\t\tif (z == 0)\n\t\t\treturn y;\n\t\treturn gcd(y, z);\n\t}\n\n\tstatic long gcd(long x, long y) {\n\t\tx = (x ^ x >> 63) - (x >> 63);\n\t\ty = (y ^ y >> 63) - (y >> 63);\n\t\tif (x < y) {\n\t\t\tx ^= y;\n\t\t\ty ^= x;\n\t\t\tx ^= y;\n\t\t}\n\t\tlong z = x % y;\n\t\tif (z == 0)\n\t\t\treturn y;\n\t\treturn gcd(y, z);\n\t}\n\n\tstatic long modinv(long a, long mod) {\n\t\treturn modpow(a, mod - 2, mod);\n\t}\n\n\tstatic long modpow(long a, long b, long mod) {\n\t\tif (b == 0)\n\t\t\treturn 1;\n\t\tif ((b & 1) == 0) {\n\t\t\tlong sqrt = modpow(a, b >> 1, mod);\n\t\t\treturn sqrt * sqrt % mod;\n\t\t}\n\t\treturn a * modpow(a, b - 1, mod) % mod;\n\t}\n\n\tstatic long fact(long n) {\n\t\tif (n <= 1)\n\t\t\treturn 1;\n\t\tlong res = 2;\n\t\tfor (long i = 3; i <= n; i++) {\n\t\t\tres *= i;\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic long modfact(long n, long mod) {\n\t\tif (n <= 1)\n\t\t\treturn 1 % mod;\n\t\tlong res = 2;\n\t\tfor (long i = 3; i <= n; i++) {\n\t\t\tres *= i;\n\t\t\tres %= mod;\n\t\t}\n\t\treturn res % mod;\n\t}\n\n\t// returns facts([0]) and invfacts([1])\n\tstatic long[][] enumfacts(int n, long mod) {\n\t\tint num = n + 10;\n\t\tlong[][] res = new long[2][num];\n\t\tlong[] facts = res[0];\n\t\tlong[] invfacts = res[1];\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tif (i <= 1) {\n\t\t\t\tfacts[i] = 1;\n\t\t\t\tinvfacts[i] = 1;\n\t\t\t} else {\n\t\t\t\tfacts[i] = facts[i - 1] * i % mod;\n\t\t\t\tinvfacts[i] = modinv(facts[i], mod);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic long modcomb(long n, long m, long mod) {\n\t\tif (m > n)\n\t\t\treturn 0;\n\t\tif (m > n - m) {\n\t\t\tm = n - m;\n\t\t}\n\t\tlong numer = 1;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tnumer = numer * (n - i) % mod;\n\t\t}\n\t\tlong denom = modfact(m, mod);\n\t\treturn numer * modinv(denom, mod) % mod;\n\t}\n\n\tstatic long modcomb(int n, int m, long[] facts, long[] invfacts, long mod) {\n\t\tif (m > n)\n\t\t\treturn 0;\n\t\tlong numer = facts[n];\n\t\tlong denom = invfacts[m] * invfacts[n - m] % mod;\n\t\treturn numer * denom % mod;\n\t}\n\n\t// res[i][0]: prime factor, res[i][1]: exponent\n\tstatic int[][] factorize(int n) {\n\t\tint[][] pfs = new int[32][2];\n\t\tint num = 0;\n\t\tfor (int i = 2; i * i <= n; i++) {\n\t\t\tint count = 0;\n\t\t\twhile (n % i == 0) {\n\t\t\t\tn /= i;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif (count > 0) {\n\t\t\t\tpfs[num][0] = i;\n\t\t\t\tpfs[num][1] = count;\n\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\t\tif (n > 1) {\n\t\t\tpfs[num][0] = n;\n\t\t\tpfs[num][1] = 1;\n\t\t\tnum++;\n\t\t}\n\t\tint[][] res = new int[num][2];\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tres[i][0] = pfs[i][0];\n\t\t\tres[i][1] = pfs[i][1];\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic long lcm(long x, long y) {\n\t\tx = (x ^ x >> 63) - (x >> 63);\n\t\ty = (y ^ y >> 63) - (y >> 63);\n\t\treturn x / gcd(x, y) * y;\n\t}\n\n\tstatic int abs(int x) {\n\t\treturn x < 0 ? -x : x;\n\t}\n\n\tstatic long abs(long x) {\n\t\treturn x < 0 ? -x : x;\n\t}\n\n\tstatic int min(int a, int b) {\n\t\treturn a < b ? a : b;\n\t}\n\n\tstatic long min(long a, long b) {\n\t\treturn a < b ? a : b;\n\t}\n\n\tstatic int max(int a, int b) {\n\t\treturn a > b ? a : b;\n\t}\n\n\tstatic long max(long a, long b) {\n\t\treturn a > b ? a : b;\n\t}\n\n\tstatic int clamp(int a, int min, int max) {\n\t\treturn a < min ? min : a > max ? max : a;\n\t}\n\n\tstatic long clamp(long a, long min, long max) {\n\t\treturn a < min ? min : a > max ? max : a;\n\t}\n\n\tstatic double clamp(double a, double min, double max) {\n\t\treturn a < min ? min : a > max ? max : a;\n\t}\n\n\tstatic void out(String val) {\n\t\tIO.out(val);\n\t}\n\n\tstatic void out(Object val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void out(int val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void out(long val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void out(char val) {\n\t\tIO.out(String.valueOf(val));\n\t}\n\n\tstatic void out(double val) {\n\t\tIO.out(Double.isFinite(val) ? BigDecimal.valueOf(val).toPlainString() : String.valueOf(val));\n\t}\n\n\tstatic void out(boolean val) {\n\t\tIO.out(val ? \"true\" : \"false\");\n\t}\n\n\tstatic void kil(String val) {\n\t\tIO.out(val);\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(Object val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(int val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(long val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(char val) {\n\t\tIO.out(String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(double val) {\n\t\tIO.out(Double.isFinite(val) ? BigDecimal.valueOf(val).toPlainString() : String.valueOf(val));\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic void kil(boolean val) {\n\t\tIO.out(val ? \"true\" : \"false\");\n\t\tIO.flush();\n\t\tSystem.exit(0);\n\t}\n\n\tstatic String nes() {\n\t\treturn IO.next();\n\t}\n\n\tstatic int nei() {\n\t\treturn IO.nextInt();\n\t}\n\n\tstatic long nel() {\n\t\treturn IO.nextLong();\n\t}\n\n\tstatic double ned() {\n\t\treturn IO.nextDouble();\n\t}\n\n\tstatic char nec() {\n\t\treturn IO.nextChar();\n\t}\n\n\tstatic String[] nss(int n) {\n\t\tString[] as = new String[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.next();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic int[] nis(int n) {\n\t\tint[] as = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.nextInt();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic long[] nls(int n) {\n\t\tlong[] as = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.nextLong();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic double[] nds(int n) {\n\t\tdouble[] as = new double[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.nextDouble();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic char[] ncs(int n) {\n\t\tchar[] as = new char[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tas[i] = IO.nextChar();\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic String[][] nss2(int n, int m) {\n\t\tString[][] as = new String[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.next();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic int[][] nis2(int n, int m) {\n\t\tint[][] as = new int[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.nextInt();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic long[][] nls2(int n, int m) {\n\t\tlong[][] as = new long[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.nextLong();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic double[][] nds2(int n, int m) {\n\t\tdouble[][] as = new double[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.nextDouble();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic char[][] ncs2(int n, int m) {\n\t\tchar[][] as = new char[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tas[i][j] = IO.nextChar();\n\t\t\t}\n\t\t}\n\t\treturn as;\n\t}\n\n\tstatic int parseInt(String val) {\n\t\treturn Integer.parseInt(val);\n\t}\n\n\tstatic int parseInt(char val) {\n\t\treturn Integer.parseInt(String.valueOf(val));\n\t}\n\n\tstatic long parseLong(String val) {\n\t\treturn Long.parseLong(val);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tsolve();\n\t\t\tIO.flush();\n\t\t} catch (NumberFormatException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n\nfinal class IO {\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out, false);\n\tprivate static final byte[] buffer = new byte[1024];\n\tprivate static int ptr = 0;\n\tprivate static int len = 0;\n\n\tprivate static boolean hasNextByte() {\n\t\tif (ptr < len)\n\t\t\treturn true;\n\t\tptr = 0;\n\t\ttry {\n\t\t\tlen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn len > 0;\n\t}\n\n\tprivate static int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\tstatic boolean hasNext() {\n\t\tbyte c;\n\t\twhile (hasNextByte() && ((c = buffer[ptr]) < '!' || c > '~'))\n\t\t\tptr++;\n\t\treturn hasNextByte();\n\t}\n\n\tstatic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (b >= '!' && b <= '~') {\n\t\t\tsb.append((char) b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic char nextChar() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\treturn (char) readByte();\n\t}\n\n\tstatic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tint sign = 1;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tsign = -1;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b)\n\t\t\tthrow new NumberFormatException();\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9')\n\t\t\t\tn = n * 10 + b - '0';\n\t\t\telse if (b == -1 || b < '!' || b > '~')\n\t\t\t\treturn n * sign;\n\t\t\telse\n\t\t\t\tthrow new NumberFormatException();\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tstatic int nextInt() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tint n = 0;\n\t\tint sign = 1;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tsign = -1;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b)\n\t\t\tthrow new NumberFormatException();\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9')\n\t\t\t\tn = n * 10 + b - '0';\n\t\t\telse if (b == -1 || b < '!' || b > '~')\n\t\t\t\treturn n * sign;\n\t\t\telse\n\t\t\t\tthrow new NumberFormatException();\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tstatic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tstatic void out(String val) {\n\t\tout.println(val);\n\t}\n\n\tstatic void flush() {\n\t\tout.flush();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.TreeSet;\nimport java.util.function.IntBinaryOperator;\nimport java.util.function.IntUnaryOperator;\nimport java.util.function.LongUnaryOperator;\n\n\npublic class Main {\n    public static void main(String[] args) {\n        StringBuilder out = new StringBuilder();\n        solve(out);\n        PrintWriter pw = new PrintWriter(System.out);\n        pw.print(out);\n        pw.flush();\n        pw.close();\n    }\n\n    public static void solve(StringBuilder out) {\n        int n = In.ni();\n        int q = In.ni();\n        L lst = new L(n, IntAlgebraicStructures.ADD, IntAlgebraicStructures.RW, (u, v) -> v, (v, l) -> v * l);\n        while (q --> 0) {\n            int k = In.ni();\n            int s = In.ni();\n            int t = In.ni() + 1;\n            if (k == 0) {\n                int x = In.ni();\n                lst.apply(s, t, x);\n            } else {\n                out.append(lst.query(s, t)).append('\\n');\n            }\n        }\n    }\n}\n\nclass L {\n    private final int[] dat, laz;\n    private final int n;\n    private final IntMonoid monoid, lazMonoid;\n    private final int e0, e1;\n    private final IntBinaryOperator op;\n    private final IntBinaryOperator lazMerger;\n    public L(int n, IntMonoid monoid, IntMonoid lazMonoid, IntBinaryOperator op, IntBinaryOperator lazMerger) {\n        this.monoid = monoid;\n        this.lazMonoid = lazMonoid;\n        this.e0 = monoid.e;\n        this.e1 = lazMonoid.e;\n        this.op = op;\n        this.lazMerger = lazMerger;\n        int nn = 1; while (nn < n) nn <<= 1;\n        this.n = nn;\n        this.dat = new int[this.n << 1];\n        this.laz = new int[this.n << 1];\n        Arrays.fill(dat, e0);\n        Arrays.fill(laz, e1);\n    }\n    public void build(int[] a) {\n        System.arraycopy(a, 0, dat, n, a.length);\n        for (int i = n - 1; i > 0; i--) dat[i] = monoid.apply(dat[(i << 1) | 0], dat[(i << 1) | 1]);\n    }\n    private final int[] st = new int[64];\n    private int tl = 0;\n    public void apply(int l, int r, int v) {\n        int m = enumerateUpdatingSegments(l, r);\n        propagate();\n        l += n; r += n;\n        int w = 1;\n        for (; l < r; l >>= 1, r >>= 1, w <<= 1) {\n            int merged = lazMerger.applyAsInt(v, w);\n            if ((l & 1) != 0) {\n                dat[l] = op.applyAsInt(dat[l], merged);\n                laz[l] = v;\n                l++;\n            }\n            if ((r & 1) != 0) {\n                r--;\n                dat[r] = op.applyAsInt(dat[r], merged);\n                laz[r] = v;\n            }\n        }\n        for (int si = 0; si < m; si++) {\n            int k = st[si];\n            dat[k] = monoid.apply(dat[(k << 1) | 0], dat[(k << 1) | 1]);\n        }\n    }\n    public int query(int l, int r) {\n        enumerateUpdatingSegments(l, r);\n        propagate();\n        l += n; r += n;\n        int resL = e0, resR = e0;\n        for (; l < r; l >>= 1, r >>= 1) {\n            if ((l & 1) != 0) resL = monoid.apply(resL, dat[l++]);\n            if ((r & 1) != 0) resR = monoid.apply(dat[--r], resR);\n        }\n        return monoid.apply(resL, resR);\n    }\n    int enumerateUpdatingSegments(int l, int r) {\n        if (l >= r) return 0;\n        int kl = l + n, kr = r + n;\n        int i = (kl / (kl & -kl)) >> 1, j = (kr / (kr & -kr)) >> 1;\n        for (; kl < kr; kl >>= 1, kr >>= 1) {\n            if (kr <= j) st[tl++] = kr;\n            if (kl <= i) st[tl++] = kl;\n        }\n        for (; kl > 0; kl >>= 1) st[tl++] = kl;\n        return tl;\n    }\n    void propagate() {\n        while (tl > 0) {\n            int k = st[--tl];\n            int lk = laz[k];\n            if (lk == e1) continue;\n            laz[(k << 1) | 0] = lazMonoid.apply(laz[(k << 1) | 0], lk);\n            laz[(k << 1) | 1] = lazMonoid.apply(laz[(k << 1) | 1], lk);\n            int w = (n / Integer.highestOneBit(k)) >> 1;\n            int merged = lazMerger.applyAsInt(lk, w);\n            dat[(k << 1) | 0] = op.applyAsInt(dat[(k << 1) | 0], merged);\n            dat[(k << 1) | 1] = op.applyAsInt(dat[(k << 1) | 1], merged);\n            laz[k] = e1;\n        }\n    }\n    public void reset() {\n        Arrays.fill(dat, e0);\n        Arrays.fill(laz, e1);\n    }\n}\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class In {\n    public static final FastScanner fsc = new FastScanner();\n    public static int ni() {return fsc.nextInt();}\n    public static int[] ni(final int n) {\n        final int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = fsc.nextInt();\n        return a;\n    }\n    public static int[] ni(final int n, final IntUnaryOperator f) {\n        final int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = f.applyAsInt(fsc.nextInt());\n        return a;\n    }\n    public static int[][] ni(final int n, final int m) {\n        final int[][] a = new int[n][m];\n        for (int i = 0; i < n; i++) a[i] = ni(m);\n        return a;\n    }\n    public static int[][] ni(final int n, final int m, final IntUnaryOperator f) {\n        final int[][] a = new int[n][m];\n        for (int i = 0; i < n; i++) a[i] = ni(m, f);\n        return a;\n    }\n    public static long nl() {return fsc.nextLong();}\n    public static long[] nl(final int n) {\n        final long[] a = new long[n];\n        for (int i = 0; i < n; i++) a[i] = fsc.nextLong();\n        return a;\n    }\n    public static long[] nl(final int n, final LongUnaryOperator f) {\n        final long[] a = new long[n];\n        for (int i = 0; i < n; i++) a[i] = f.applyAsLong(fsc.nextLong());\n        return a;\n    }\n    public static long[][] nl(final int n, final int m) {\n        final long[][] a = new long[n][m];\n        for (int i = 0; i < n; i++) a[i] = nl(m);\n        return a;\n    }\n    public static long[][] nl(final int n, final int m, final LongUnaryOperator f) {\n        final long[][] a = new long[n][m];\n        for (int i = 0; i < n; i++) a[i] = nl(m, f);\n        return a;\n    }\n    public static char[] nc() {return fsc.next().toCharArray();}\n    public static char[][] nc(final int n) {\n        final char[][] c = new char[n][];\n        for (int i = 0; i < n; i++) c[i] = nc();\n        return c;\n    }\n    public static double nd() {return fsc.nextDouble();}\n    public static double[] nd(final int n) {\n        final double[] a = new double[n];\n        for (int i = 0; i < n; i++) a[i] = fsc.nextDouble();\n        return a;\n    }\n    public static double[][] nd(final int n, final int m) {\n        final double[][] a = new double[n][m];\n        for (int i = 0; i < n; i++) a[i] = nd(m);\n        return a;\n    }\n    public static String ns() {return fsc.next();}\n    public static String[] ns(final int n) {\n        final String[] s = new String[n];\n        for (int i = 0; i < n; i++) s[i] = fsc.next();\n        return s;\n    }\n    public static boolean[][] grid(final int h, final int w, final char trueCharacter) {\n        final boolean[][] grid = new boolean[h][w];\n        for (int i = 0; i < h; i++) {\n            final char[] s = fsc.next().toCharArray();\n            for (int j = 0; j < w; j++) grid[i][j] = s[j] == trueCharacter;\n        }\n        return grid;\n    }\n}\n\n\nfinal class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) return true;\n        ptr = 0;\n        try {buflen = in.read(buffer);}\n        catch (final IOException e) {e.printStackTrace();}\n        return buflen > 0;\n    }\n    private int readByte() {return hasNextByte() ? buffer[ptr++] : -1;}\n    public boolean hasNext() {\n        while (hasNextByte() && !(33 <= buffer[ptr] && buffer[ptr] <= 126)) ptr++;\n        return hasNextByte();\n    }\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        final StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (33 <= b && b <= 126) {sb.appendCodePoint(b); b = readByte();}\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {minus = true; b = readByte();}\n        if (b < '0' || '9' < b) throw new NumberFormatException();\n        for (; ; b = readByte()) {\n            if ('0' <= b && b <= '9') n = n * 10 + b - '0';\n            else if (b == -1 || !(33 <= b && b <= 126)) return minus ? -n : n;\n            else throw new NumberFormatException();\n        }\n    }\n    public int nextInt() {return Math.toIntExact(nextLong());}\n    public double nextDouble() {return Double.parseDouble(next());}\n}\n\n\nclass IntRing extends IntSemiRing {\n    private final IntUnaryOperator additiveInverse;\n    public IntRing(final IntAbelianGroup addition, final IntMonoid multiplication) {\n        super(addition, multiplication);\n        this.additiveInverse = addition::inverse;\n    }\n    public final int additiveInverse(final int t) {return additiveInverse.applyAsInt(t);}\n}\n\n\n\nclass IntMonoid extends IntMagma implements IntUnital {\n    public final int e;\n    public IntMonoid(final IntBinaryOperator operator, final int e) {\n        super(operator, TypicalPropertySets.MONOID);\n        this.e = e;\n    }\n    @Override\n    public int identityElement() {return e;}\n    public static <M extends IntMagma & IntUnital> IntMonoid of(M m) {\n        m.requireProperties(TypicalPropertySets.MONOID);\n        return new IntMonoid(m.operator, m.identityElement());\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class MathUtil{\n    private static final long UNDER32_MASK = 0xffff_ffffl;\n    private MathUtil(){}\n    /**\n     * Enumarate primes equal to or less than n.\n     * @param n\n     * @return {@code ArrayList} that holds primes.\n     */\n    public static ArrayList<Integer> eratosthenes(final int n) {\n        final int[] div = eratosthenesDivisors(n);\n        final ArrayList<Integer> result = new ArrayList<>();\n        for (int i = 2; i <= n; i++) if (div[i] == i) result.add(i);\n        return result;\n    }\n    /**\n     * execute eratosthenes's prime-enumerate algorithm. a[i] holds the greatest\n     * divisor of i. if a[i] = i, i is a prime number. This arrary enables you to\n     * prime-factorize in O(log n) time.\n     * @param n\n     * @return divisor array.\n     */\n    public static int[] eratosthenesDivisors(final int n) {\n        final int[] divisors = new int[n + 1];\n        if (n <= 0) return null;\n        for (int i = 1; i <= n; i++) {\n            if ((i & 1) != 0) divisors[i] = i;\n            else divisors[i] = 2;\n        }\n        for (int i = 3; i <= n; i += 2) {\n            if (divisors[i] == i) for (long j = (long) i * i; j <= n; j += i << 1) divisors[(int) j] = i;\n        }\n        return divisors;\n    }\n    /**\n     * Caluculate prime-factorization in O(sqrt(n)) time.\n     * @param n\n     * @return {@code HashMap} of {prime: index}\n     */\n    public static HashMap<Long, Integer> primeFactorization(long n) {\n        final HashMap<Long, Integer> primes = new HashMap<>();\n        for (long p = 2; p * p <= n; p++) {\n            int q = 0;\n            while (n % p == 0) {n /= p; q++;}\n            if (q > 0) primes.put(p, q);\n        }\n        if (n > 1) primes.put(n, 1);\n        return primes;\n    }\n    public static TreeSet<Long> divisors(final long n) {\n        final TreeSet<Long> divisors = new TreeSet<>();\n        for (long i = 1; i * i <= n; i++) if (n % i == 0) {divisors.add(i); divisors.add(n / i);}\n        return divisors;\n    }\n    private static HashMap<Long, Integer> lcmMap(final HashMap<Long, Integer> amap, final HashMap<Long, Integer> bmap) {\n        if (amap.size() < bmap.size()) return lcmMap(bmap, amap);\n        final HashMap<Long, Integer> lcm = amap;\n        for (final Map.Entry<Long, Integer> e : bmap.entrySet()) {\n            final long prime = e.getKey();\n            if (lcm.containsKey(prime)) lcm.put(prime, Math.max(lcm.get(prime), e.getValue()));\n            else lcm.put(prime, e.getValue());\n        }\n        return lcm;\n    }\n    private static HashMap<Long, Integer> lcmMap(final HashMap<Long, Integer> amap, final long b) {\n        final HashMap<Long, Integer> bmap = primeFactorization(b);\n        return lcmMap(amap, bmap);\n    }\n    public static HashMap<Long, Integer> lcmMap(final long... a) {\n        HashMap<Long, Integer> amap = new HashMap<>();\n        for (final long c : a) amap = lcmMap(amap, c);\n        return amap;\n    }\n    /**\n     * calculate lcm(a, b) fast. (NOT considering overflow.)\n     */\n    public static long lcm(final long a, final long b) {return (a / gcd(a, b)) * b;}\n    /**\n     * Caluculate the GCD of (a, b)/\n     * @param a first value\n     * @param b second value\n     * @return GCD(a, b)\n     */\n    public static long gcd(long a, long b) {\n        if (a < b) return gcd(b, a);\n        if (b == 0) return a;\n        if (a == 0) return b;\n        long r = a % b;\n        while (r != 0) {a = b; b = r; r = a % b;}\n        return b;\n    }\n    public static long gcd(final long... a) {\n        long gcd = 0; for (final long c : a) gcd = gcd(gcd, c);\n        return gcd;\n    }\n    /**\n     * Return one of the solutions to {@code ax+by=gcd(a, b)}.\n     * \n     * @return {@code x}, {@code y}, {@code gcd(a, b)}.\n     * @param a a of ax+by=gcd(a, b).\n     * @param b b of ax+by=gcd(a, b).\n     */\n    public static long[] extGCD(final long a, final long b) {\n        final long[] ret = new long[3];\n        final long[] xy = new long[2];\n        ret[2] = extGCD(a, b, xy);\n        ret[0] = xy[0]; ret[1] = xy[1];\n        return ret;\n    }\n    private static long extGCD(final long a, final long b, final long[] xy) {\n        if (b == 0) {xy[0] = 1; xy[1] = 0; return a;}\n        long tmp = xy[0]; xy[0] = xy[1]; xy[1] = tmp;\n        final long d = extGCD(b, a % b, xy);\n        tmp = xy[0]; xy[0] = xy[1]; xy[1] = tmp;\n        xy[1] -= a / b * xy[0];\n        return d;\n    }\n    /**\n     * caluculate a ^ b NOT considering overflow. so if you want to calculate a ^ b\n     * (mod p), use ModUtil.pow(a, b).\n     * @param a base\n     * @param b exponent\n     * @return a ^ b\n     */\n    public static long pow(final int a, long b) {\n        long ret = 1l;\n        for (long c = 1, ac = a; b > 0; ac *= ac, c <<= 1) if ((-b & b) == c) {ret *= ac; b &= ~(-b & b);}\n        return ret;\n    }\n    /**\n     * Caluculate the combination nCr NOT considering overflow.\n     * \n     * @param n left\n     * @param r right\n     * @return nCr\n     */\n    public static long comb(long n, long r) {\n        if (n < r) return 0;\n        r = Math.min(r, n - r);\n        long res = 1; for (long d = 1; d <= r; d++) {res *= n--; res /= d;}\n        return res;\n    }\n    public static long ceilSqrt(final long n) {\n        long l = -1, r = n;\n        while (r - l > 1) {\n            final long m = (r + l) >> 1;\n            if (m * m >= n) r = m;\n            else l = m;\n        }\n        return r;\n    }\n    public static long floorSqrt(final long n) {\n        long l = 0, r = n + 1;\n        while (r - l > 1) {\n            final long m = (r + l) >> 1;\n            if (m * m > n) r = m;\n            else l = m;\n        }\n        return l;\n    }\n    public static long int2ToLong(final int upper, final int lower) {return ((long) upper << Integer.SIZE) | lower;}\n    public static int upper32(final long l) {return (int) (l >>> Integer.SIZE);}\n    public static int lower32(final long l) {return (int) (l & UNDER32_MASK);}\n\n    public static BigInteger chineseRemainderTheorem(long[] mod, long[] remainder) {\n        int n = mod.length;\n        long[] t = new long[n];\n        t[0] = remainder[0];\n        for (int i = 1; i < n; i++) {\n            long c = remainder[i];\n            long m = mod[i];\n            for (int j = 0; j < i; j++) {\n                c -= t[j];\n                c *= inv(mod[j], m);\n                c %= m;\n                if (c < 0) c += m;\n            }\n            t[i] = c;\n        }\n        BigInteger res = BigInteger.valueOf(t[n - 1]);\n        for (int i = n - 2; i >= 0; i--) {\n            res.multiply(BigInteger.valueOf(mod[i])).add(BigInteger.valueOf(t[i]));\n        }\n        return res;\n    }\n\n    public static long inv(long a, final long mod) {\n        long b = mod;\n        long u = 1, v = 0;\n        while (b >= 1) {\n            final long t = a / b;\n            a -= t * b;\n            final long tmp1 = a; a = b; b = tmp1;\n            u -= t * v;\n            final long tmp2 = u; u = v; v = tmp2;\n        }\n        u %= mod;\n        return u < 0 ? u + mod : u;\n    }\n}\n\n\n\nclass IntBoundedSemiLattice extends IntMonoid {\n    public IntBoundedSemiLattice(final IntBinaryOperator operator, final int e) {\n        super(operator, e);\n        addProperties(Property.IDEMPOTENT, Property.COMMUTATIVE);\n    }\n    public static <M extends IntMagma & IntUnital> IntBoundedSemiLattice of(M m) {\n        m.requireProperties(TypicalPropertySets.BOUNDED_SEMI_LATTICE.getProperties());\n        return new IntBoundedSemiLattice(m.operator, m.identityElement());\n    }\n}\n\n\n\nclass IntAlgebraicStructures {\n    private IntAlgebraicStructures(){}\n    public static final IntAbelianGroup ADD = new IntAbelianGroup(Integer::sum, 0, e -> -e);\n    public static final IntAbelianGroup XOR = new IntAbelianGroup((u, v) -> u ^ v, 0, x -> x);\n    public static final IntBoundedSemiLattice MAX = new IntBoundedSemiLattice(Integer::max, -Const.IINF);\n    public static final IntBoundedSemiLattice MIN = new IntBoundedSemiLattice(Integer::min, Const.IINF);\n    public static final IntBoundedSemiLattice AND = new IntBoundedSemiLattice((u, v) -> u & v, 0xffff_ffff);\n    public static final IntBoundedSemiLattice OR = new IntBoundedSemiLattice((u, v) -> u | v, 0);\n    public static final IntBoundedSemiLattice GCD = new IntBoundedSemiLattice((u, v) -> (int) MathUtil.gcd(u, v), 0);\n    public static final IntCommutativeMonoid MUL = new IntCommutativeMonoid((u, v) -> u * v, 1);\n    public static final Rewrite RW = new Rewrite((u, v) -> v, -Const.IINF - 1);\n    public static final IntField ADD_MUL = new IntField(ADD, MUL);\n    public static final IntField XOR_AND = new IntField(XOR, AND);\n    private static final class Rewrite extends IntMonoid {\n        public Rewrite(final IntBinaryOperator operator, final int e) {\n            super(operator, e);\n            addProperties(Property.IDEMPOTENT);\n        }\n    }\n}\n\n\n\nclass IntGroup extends IntMonoid implements IntInversible {\n    private final IntUnaryOperator inverse;\n    public IntGroup(final IntBinaryOperator operator, final int e, final IntUnaryOperator inverse) {\n        super(operator, e);\n        addProperties(Property.CANCELLATIVE);\n        this.inverse = inverse;\n    }\n    @Override\n    public int inverse(final int t) {return inverse.applyAsInt(t);}\n}\n\n\n\nabstract class IntExtendedMagma extends PropertyHolder {\n    public final int e0, e1;\n    private final IntBinaryOperator addition, multiplication;\n    protected final EnumSet<Property> additiveProps, multiplicativeProps;\n    public IntExtendedMagma(IntMonoid addition, IntMonoid multiplication, EnumSet<Property> properties) {\n        super(properties);\n        this.addition = addition.operator;\n        this.multiplication = multiplication.operator;\n        this.e0 = addition.identityElement();\n        this.e1 = multiplication.identityElement();\n        this.additiveProps = addition.getProperties();\n        this.multiplicativeProps = multiplication.getProperties();\n    }\n    public IntExtendedMagma(IntMonoid addition, IntMonoid multiplication, TypicalPropertySets properties) {\n        this(addition, multiplication, properties.getProperties());\n    }\n    public final int add(int t, int u) {return addition.applyAsInt(t, u);}\n    public final int mul(int t, int u) {return multiplication.applyAsInt(t, u);}\n}\n\n\n\nabstract class IntMagma extends PropertyHolder {\n    protected final IntBinaryOperator operator;\n    public IntMagma(final IntBinaryOperator operator, final EnumSet<Property> properties) {\n        super(properties);\n        this.operator = operator;\n    }\n    public IntMagma(final IntBinaryOperator operator, final TypicalPropertySets properties) {\n        super(properties);\n        this.operator = operator;\n    }\n    public final int apply(final int left, final int right) {return operator.applyAsInt(left, right);}\n}\n\n\n\nclass IntSemiRing extends IntExtendedMagma {\n    public IntSemiRing(final IntMonoid addition, final IntMonoid multiplication) {\n        super(addition, multiplication, TypicalPropertySets.SEMI_RING);\n        addition.requireProperties(EnumSet.of(Property.COMMUTATIVE));\n    }\n    public static IntSemiRing of(IntExtendedMagma m) {\n        if (!m.additiveProps.containsAll(TypicalPropertySets.COMMUTATIVE_MONOID.getProperties())) {\n            throw new ClassCastException(\"addition does not meet the conditions of commutative monoid.\");\n        }\n        IntCommutativeMonoid add = new IntCommutativeMonoid(m::add, m.e0);\n        IntMonoid mul = new IntMonoid(m::mul, m.e1);\n        return new IntSemiRing(add, mul);\n    }\n}\n\n\n\nclass IntAbelianGroup extends IntGroup {\n    public IntAbelianGroup(final IntBinaryOperator operator, final int e, final IntUnaryOperator inverse) {\n        super(operator, e, inverse);\n        addProperties(Property.COMMUTATIVE);\n    }\n}\n\ninterface IntInversible {int inverse(int t);}\n\n\n\nclass IntCommutativeMonoid extends IntMonoid {\n    public IntCommutativeMonoid(final IntBinaryOperator operator, final int e) {\n        super(operator, e);\n        addProperties(Property.COMMUTATIVE);\n    }\n    public static <M extends IntMagma & IntUnital> IntCommutativeMonoid of(M m) {\n        m.requireProperties(TypicalPropertySets.COMMUTATIVE_MONOID.getProperties());\n        return new IntCommutativeMonoid(m.operator, m.identityElement());\n    }\n}\n\nenum Property {ANNIHILATED_BY_ZERO, ASSOCIATIVE, CANCELLATIVE, COMMUTATIVE, DISTRIBUTIVE, IDEMPOTENT;}\n\n\nenum TypicalPropertySets {\n    ABELIAN_GROUP(EnumSet.of(Property.ASSOCIATIVE, Property.CANCELLATIVE, Property.COMMUTATIVE)),\n    BOUNDED_SEMI_LATTICE(EnumSet.of(Property.ASSOCIATIVE, Property.COMMUTATIVE, Property.IDEMPOTENT)),\n    COMMUTATIVE_MONOID(EnumSet.of(Property.ASSOCIATIVE, Property.COMMUTATIVE)),\n    GROUP(EnumSet.of(Property.ASSOCIATIVE, Property.CANCELLATIVE)),\n    MONOID(EnumSet.of(Property.ASSOCIATIVE)),\n    SEMI_GROUP(EnumSet.of(Property.ASSOCIATIVE)),\n    SEMI_LATTICE(EnumSet.of(Property.ASSOCIATIVE, Property.IDEMPOTENT, Property.COMMUTATIVE)),\n    SEMI_RING(EnumSet.of(Property.DISTRIBUTIVE, Property.ANNIHILATED_BY_ZERO)),\n    RING(EnumSet.of(Property.DISTRIBUTIVE, Property.ANNIHILATED_BY_ZERO));\n    private final EnumSet<Property> properties;\n    private TypicalPropertySets(EnumSet<Property> properties) {this.properties = properties;}\n    public final EnumSet<Property> getProperties() {return properties.clone();}\n}\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nclass Const {\n    public static final long MOD7 = 1_000_000_007;\n    public static final long MOD9 = 1_000_000_009;\n    public static final long MOD99 = 998_244_353;\n\n    public static final long LINF = Long.MAX_VALUE >> 2;\n    public static final int IINF = Integer.MAX_VALUE >> 1;\n    public static final double DINF = 1e150;\n\n    public static final double SDELTA = 1e-12;\n    public static final double DELTA = 1e-9;\n    public static final double LDELTA = 1e-6;\n\n    public static final int[] dx8 = {1, 0, -1, 0, 1, -1, -1, 1};\n    public static final int[] dy8 = {0, 1, 0, -1, 1, 1, -1, -1};\n    public static final int[] dx4 = {1, 0, -1, 0};\n    public static final int[] dy4 = {0, 1, 0, -1};\n\n    private Const(){}\n}\n\n\n\nclass IntField extends IntRing {\n    public IntField(final IntAbelianGroup addition, final IntMonoid multiplication) {\n        super(addition, multiplication);\n        multiplication.requireProperties(EnumSet.of(Property.COMMUTATIVE));\n    }\n}\n\ninterface IntUnital {int identityElement();}\n\n\nabstract class PropertyHolder {\n    private final EnumSet<Property> properties;\n    public PropertyHolder(final EnumSet<Property> properties) {this.properties = properties;}\n    public PropertyHolder(final TypicalPropertySets typicalSet) {this(typicalSet.getProperties());}\n    public final EnumSet<Property> getProperties() {return properties;}\n    public final void addProperties(final Property... props) {for (Property prop : props) properties.add(prop);}\n    public final void addProperties(final EnumSet<Property> props) {for (Property prop : props) properties.add(prop);}\n    public final void addProperties(final TypicalPropertySets props) {addProperties(props.getProperties());}\n    public final boolean hasProperties(final Property... props) {\n        for (final Property prop : props) if (!properties.contains(prop)) return false;\n        return true;\n    }\n    public final boolean hasProperties(final EnumSet<Property> props) {\n        for (final Property prop : props) if (!properties.contains(prop)) return false;\n        return true;\n    }\n    public final boolean hasProperties(final TypicalPropertySets props) {return hasProperties(props.getProperties());}\n    public final void requireProperties(final EnumSet<Property> props, final Property... ps) {\n        final ArrayList<Property> unmet = new ArrayList<>();\n        for (final Property prop : props) if (!properties.contains(prop)) unmet.add(prop);\n        for (final Property prop : ps) if (!properties.contains(prop)) unmet.add(prop);\n        if (unmet.size() > 0) throw new UnsatisfiedRequiredPropertiesException(unmet);\n    }\n    public final void requireProperties(final TypicalPropertySets props, final Property... ps) {\n        requireProperties(props.getProperties(), ps);\n    }\n    private static final class UnsatisfiedRequiredPropertiesException extends RuntimeException {\n        private static final long serialVersionUID = 1L;\n        private UnsatisfiedRequiredPropertiesException(final Collection<Property> props) {\n            for (final Property prop : props) System.err.println(prop.name() + \"should be satisfied.\");\n        }\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.io.*;\n//import java.io.BufferedReader;\n//import java.io.InputStream;\n//import java.io.InputStreamReader;\n//import java.io.IOException;\n\n\nclass Main {\n    static PrintWriter out = new PrintWriter(System.out);\n    static FastScanner sc = new FastScanner(System.in);\n        \n    static int n, q;\n    static int com, s, t;\n    static long x;\n    \n    public static void main(String[] args) {\n        n = sc.nextInt();\n        q = sc.nextInt();\n\n        RangeQuery rq = new RangeQuery(n, 0l);\n\n        for (int i = 0; i < q; i++) {\n            //rq.debugPrint();\n            \n            com = sc.nextInt();\n\n            if (com == 0) {\n                s = sc.nextInt();\n                t = sc.nextInt();\n                x = sc.nextLong();\n\n                t++;\n\n                rq.update(s, t, x);\n            }\n            else {\n                s = sc.nextInt();\n                t = sc.nextInt();\n\n                t++;\n\n                out.println(rq.query(s, t));\n            }\n        }\n        \n        out.flush();\n    }\n}\n\nclass RangeQuery extends LazySqrtDecomposition<Long> {\n\n    public RangeQuery(int n, Long e) {\n        super(n, e);\n    }\n    \n    @Override\n    protected Long f(Long x, Long y) {\n        return x + y;\n    }\n\n    @Override\n    protected Long g(Long x, Long y, int t) {\n        return y * t;\n    }\n\n    @Override\n    protected Long h(Long x, Long y) {\n        return y;\n    }\n}\n\n/**\n * @author ei1710\n * @version 1.00\n */\n//package toyama.ei1710.DataStructures;\n/**\n * モノイドを乗せられる遅延伝播平方分割の抽象クラス.<br>\n * operatorメソッドをオーバライドすることで二項演算を定義する<br>\n * データの区間更新、区間に対する質問クエリをO(sqrt(N))で行う\n *\n * 更新<br>\n * 更新する区間が、bucket_iの管理する区間を完全に含むなら、lazy_iに値を入れる<br>\n * 交差している場合は、対象部分のデータを更新してから、bucket_iを更新する<br>\n *\n * クエリ<br>\n * 質問の対象区間が、bucket_iを完全に含む場合、bucket_iとlazy_iをマージして返す\n * 交差していて、かつlazy_iに値がある場合、その区間のデータを更新後、bucket_iを更新する\n * すると、通常の平方分割と同じになる\n *\n */\nabstract class LazySqrtDecomposition<T> {\n    /** 生データ */\n    protected ArrayList<T> raw_data;\n    /** バケットごとに事前に演算した結果を保持 */\n    protected ArrayList<T> bucket;\n    /** バケット範囲に一様に作用させる値 */\n    protected ArrayList<T> lazy;\n     \n    /** lazyにデータはあるかな？ */\n    protected boolean[] lazy_flag;\n    /** 単位元 */\n    protected T e;\n    /** データ数 */\n    protected int N;\n \n    protected int sqrtN;\n \n    /** バケットの数 */\n    protected int K;\n     \n    /** 要素と要素の合成 */\n    abstract protected T f(T x, T y);\n    /** 要素と作用素の合成 bucketとlazyのマージに使うよ */\n    abstract protected T g(T x, T y, int t);\n    /** 作用素と作用素の合成 lazyにデータが入ってるときに使うよ*/\n    abstract protected T h(T x, T y);\n     \n    /** 単位元eを初期値として要素数nmembの平方分割 */\n    public LazySqrtDecomposition(int nmemb, T e) {\n        this.e = e;\n        N = nmemb;\n        sqrtN = 1;\n        while (sqrtN * sqrtN < N) sqrtN++;\n         \n        K = (N + sqrtN - 1) / sqrtN;\n         \n        raw_data = new ArrayList<T>(N);\n        bucket = new ArrayList<T>(K);\n        lazy = new ArrayList<T>(K);\n        lazy_flag = new boolean[K];\n         \n        build();\n    }\n     \n    private void build() {\n \n        for (int i = 0; i < N; i++) {\n            raw_data.add(e);\n        }\n \n        for (int i = 0; i < K; i++) {\n            bucket.add(e);\n            lazy.add(e);\n            lazy_flag[i] = false;\n        }\n    }\n     \n    /** bucket[k]の区間に対して、lazy[k]を適用したりbucket[k]を再計算したりする */\n    protected void eval(int k) {\n        \n        T x = e;\n        for (int i = k * sqrtN; i < Math.min(N, (k + 1) * sqrtN); i++) {\n            if (lazy_flag[k]) {\n                raw_data.set(i, g(raw_data.get(i), lazy.get(k), 1));\n            }\n            x = f(x, raw_data.get(i));\n        }\n         \n        lazy_flag[k] = false;\n        bucket.set(k, x);\n    }\n \n     \n    /** [l, r)区間をdatで更新する O(sqrt(N)) */\n    public void update(int l, int r, T dat) {\n        int s = l / sqrtN;\n        int t = (r + sqrtN - 1) / sqrtN;\n \n        int bucket_l, bucket_r;\n         \n        for (int i = s; i < t; i++) {\n            bucket_l = i * sqrtN;\n            bucket_r = (i + 1) * sqrtN;\n             \n            if (l <= bucket_l && bucket_r <= r) {\n                if (lazy_flag[i]) {\n                    lazy.set(i, h(lazy.get(i), dat));\n                }\n                else {\n                    lazy.set(i, dat);\n                }\n                lazy_flag[i] = true;\n            }\n            else {\n                eval(i);\n                for (int j = Math.max(bucket_l, l); j < Math.min(bucket_r, r); j++) {\n                    raw_data.set(j, g(raw_data.get(j), dat, 1));\n                }\n                eval(i);\n            }\n        }\n    }\n \n    /** [l, r)の区間クエリに答える O(sqrt(N)) */\n    public T query(int l, int r) {\n        int s = l / sqrtN;\n        int t = (r + sqrtN - 1) / sqrtN;\n        int bucket_l, bucket_r;\n        T x = e;\n         \n        for (int i = s; i < t; i++) {\n            bucket_l = i * sqrtN;\n            bucket_r = (i + 1) * sqrtN;\n            if (l <= bucket_l && bucket_r <= r) {\n                if (lazy_flag[i]) {\n                    x = f(x, g(bucket.get(i), lazy.get(i), sqrtN));\n                }\n                else {\n                    x = f(x, bucket.get(i));\n                }\n            }\n            else {\n                eval(i);\n                for (int j = Math.max(bucket_l, l); j < Math.min(bucket_r, r); j++) {\n                    x = f(x, raw_data.get(j));\n                }\n            }\n        }\n        return x;\n    }\n     \n    /** デバッグ情報の印字 */\n    public void debugPrint() {\n         \n        System.err.println(\"-lazy-\");\n        for (int i = 0; i < lazy.size(); i++) {\n            if (!lazy_flag[i]) {\n                System.err.print(\" --  \");\n            }\n            else {\n                System.err.print(lazy.get(i));\n                System.err.print(' ');\n            }\n        }\n        System.err.print('\\n');\n         \n        System.err.println(\"-bucket-\");\n        for (T p : bucket) {\n            System.err.print(p);\n            System.err.print(' ');\n        }\n        System.err.print('\\n');\n \n        System.err.println(\"-raw_data-\");\n        for (T q : raw_data) {\n            System.err.print(q);\n            System.err.print(' ');\n        }\n        System.err.print('\\n');\n \n        System.err.println(\"-other data-\");\n        System.err.printf(\"N: %d, sqrtN: %d, K: %d\\n\", N, sqrtN, K);\n    }\n}\n\nclass FastScanner {\n    private int n;\n    private long m;\n    private int minus;\n    \n    private BufferedReader reader = null;\n    private StringTokenizer tokenizer = null;\n\n    public FastScanner(InputStream source) {\n        reader = new BufferedReader(new InputStreamReader(source));\n    }\n\n    public String next() {\n        if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        n = 0;\n        minus = 0;\n        String str = next();\n\n        if (str.charAt(0) == '-') {\n            minus = 1;\n        }\n\n        for (int i = minus; i < str.length(); i++) {\n            n *= 10;\n            n += (int)(str.charAt(i) - '0');\n        }\n\n        if (minus == 1) {\n            n *= -1;\n        }\n\n        return n;\n    }\n\n    public long nextLong() {\n        m = 0;\n        minus = 0;\n        String str = next();\n\n        if (str.charAt(0) == '-') {\n            minus = 1;\n        }\n\n        for (int i = minus; i < str.length(); i++) {\n            m *= 10;\n            m += (int)(str.charAt(i) - '0');\n        }\n\n        if (minus == 1) {\n            m *= -1;\n        }\n\n        return m;\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\nimport java.math.BigInteger;\n \npublic class Main implements Runnable {\n\t\n\tstatic int mod = 1000000007;\n\t\n    public static void main(String[] args) {\n    \tnew Thread(null, new Main(), \"\", 1024 * 1024 * 1024).start();\n    }\n    \n    public void run() {\n    \tPrintWriter out = new PrintWriter(System.out);\n        FastScanner sc = new FastScanner();\n        \n        int n = sc.nextInt();\n        int q = sc.nextInt();\n        \n        LazySegmentTree t = new LazySegmentTree(n);\n        \n        for(int i=0;i<q;i++){\n        \tint c = sc.nextInt();\n        \t\n        \tif(c==0){\n            \tint s = sc.nextInt();\n            \tint e = sc.nextInt();\n            \tint x = sc.nextInt();\n        \t\tt.update(s,e+1, new Action(x,i));\n        \t}\n        \telse{\n        \t\tint x = sc.nextInt();\n        \t\tint y = sc.nextInt();\n        \t\tout.println(t.query(x, y+1).value);\n        \t}\n        }\n        \n        out.flush();\n    }\n\n}\n\nclass LazySegmentTree {\n\t\n\tData[] tree;\n\tAction[] lazy;\n\t\n\t//要素数で初期化\n\tpublic LazySegmentTree(int n){\n\t\tint num = 1;\n\t\twhile(num<n){\n\t\t\tnum = num*2;\n\t\t}\n\t\ttree = new Data[num*2-1];\n\t\tArrays.fill(tree,id_T);\n\t\tlazy = new Action[num*2-1];\n\t\tArrays.fill(lazy,id_E);\n\t}\n\t\n\t//配列で初期化\n\tpublic LazySegmentTree(Data[] start){\n\t\tint num = 1;\n\t\twhile(num<start.length){\n\t\t\tnum = num*2;\n\t\t}\n\t\ttree = new Data[num*2-1];\n\t\tArrays.fill(tree,id_T);\n\t\tlazy = new Action[num*2-1];\n\t\tArrays.fill(lazy,id_E);\n\t\t\n\t\tfor(int i=0;i<start.length;i++){\n\t\t\tupdate(i,start[i]);\n\t\t}\n\t}\n\n\t//演算\n\tData ope(Data x, Data y){\n\t\treturn new Data(x.value + y.value);\n\t}\n\t\n\t//単位元\n\tstatic Data id_T = new Data(0);\n\n\t//sbjのobjへの作用\n\tData g(Action sbj, Data obj){\n\t\treturn new Data(sbj.value);\n\t}\n\t\n\t//作用素のマージ\n\tAction h(Action obj, Action sbj){\n\t\tif(obj.priority < sbj.priority){\n\t\t\treturn sbj;\n\t\t}\n\t\telse{\n\t\t\treturn obj;\n\t\t}\n\t}\n\t\n\t//長さlenの区間にxを作用させるときの作用の変化　例：和の加算なら*len、min/maxならそのまま\n\tAction p(Action x, int len){\n\t\treturn new Action(x.value * len, x.priority);\n\t}\n\t\n\t//作用素の単位元\n\tstatic Action id_E = new Action(0,-1);\n\t\n\t//idがkの木の頂点を遅延伝播 lenはkの区間の長さ\n\tvoid eval(int len, int k){\n\t\t\n\t\tif(!lazy[k].equals(id_E)){\n\t\t\ttree[k] = g(p(lazy[k],len),tree[k]);\n\t\t\t\n\t\t\t//子は親の半分の範囲\n\t\t\tif(k*2+1 < inum()*2-1){ //最下段かチェック\n\t\t\t\tlazy[2*k+1] = h(lazy[2*k+1],lazy[k]);\n\t\t\t\tlazy[2*k+2] = h(lazy[2*k+2],lazy[k]);\n\t\t\t}\n\t\t}\n\t\t//伝播終了\n\t\tlazy[k] = id_E;\n\t}\n\t\n\t//インデックス数\n\tint inum(){\n\t\treturn (tree.length+1)/2;\n\t}\n\t\n\t//区間[a,b)に作用素xを入れる\n\tData update(int a, int b, Action x){\n\t\treturn update(a,b,x,0,0,inum());\n\t}\n\t\n\t//再帰全体の更新範囲[a,b) [l,r)を表すkに作用素xを入れる\n\tData update(int a, int b, Action x, int k, int l, int r){\n\t\teval(r-l,k);\t//遅延伝播\n\t\t\n\t\tif(r<=a || b<=l){\n\t\t\treturn tree[k];\n\t\t}\n\t\tif(a<=l && r<=b){\n\t\t\tlazy[k] = h(lazy[k],x);\n\t\t\treturn g(p(lazy[k],r-l),tree[k]);\n\t\t}\n\t\treturn tree[k] = ope(update(a,b,x,k*2+1,l,(l+r)/2),update(a,b,x,k*2+2,(l+r)/2,r));\n\t}\n\t\n\t//i番目の値をnに更新\n\tvoid update(int i, Data x){\n\t\ti = inum() + i - 1; //単体のa_iが格納されているindex\n\t\ttree[i] = x;\n\t\twhile (i > 0) {\n\t\t\ti = (i - 1) / 2; //1つ上の区間和が格納されているindex\n\t\t\ttree[i] = ope(tree[i * 2 + 1], tree[i * 2 + 2]);\n\t\t}\n\t}\n\t\n\t//O(logN)で[start,end)の区間和\n\tData query(int start, int end) {\n\t\treturn query(start, end, 0, 0, inum());\n\t}\n\n\t//[a,b)の区間和, kは自分のいるセグ木のインデックス、対象範囲は[l,r)\n\tprivate Data query(int a, int b, int k, int l, int r) {\n\t\t\n\t\teval(r-l,k);\n\t\t\n\t\t// 要求区間と対象区間が交わらない -> 適当に返す\n\t\tif(r <= a || b <= l){\n\t\t\treturn id_T;\n\t\t}\n\t\t\t\n\t\t// 要求区間が対象区間を完全に被覆 -> 対象区間を答えの計算に使う\n\t\tif(a<=l && r<=b){\n\t\t\treturn tree[k];\n\t\t}\n\t\telse{\n\t\t\tData lv = query(a, b, 2*k+1, l, (l+r)/2);\n\t\t\tData rb = query(a, b, 2*k+2, (l+r)/2, r);\n\t\t\treturn ope(lv, rb);\n\t\t}\n\t}\n\t\n}\n\n//保持すべき値\nclass Data{\n\tlong value;\n\t\n\t//単位元\n\tstatic Data id_T = new Data(0);\n\t\n\tpublic Data(long value){\n\t\tthis.value = value;\n\t}\n\t\n}\n\n//作用素\nclass Action{\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + priority;\n\t\tresult = prime * result + (int) (value ^ (value >>> 32));\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tAction other = (Action) obj;\n\t\tif (priority != other.priority)\n\t\t\treturn false;\n\t\tif (value != other.value)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tlong value;\n\tint priority;\n\t\n\tpublic Action(long value, int priority){\n\t\tthis.value = value;\n\t\tthis.priority = priority;\n\t}\n\t\n\n}\nclass FastScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t\treturn hasNextByte();\n\t}\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)\n\t\t\tthrow new NumberFormatException();\n\t\treturn (int) nl;\n\t}\n\tpublic int[] nextintArray(int n){\n\t\tint[] a = new int[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic long[] nextlongArray(int n){\n\t\tlong[] a = new long[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextLong();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic Integer[] nextIntegerArray(int n){\n\t\tInteger[] a = new Integer[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        // Your code here!\n        Scanner sc = new Scanner(System.in);\n       int  N = sc.nextInt();\n        int q = sc.nextInt();\n        RUQ seg = new RUQ(N);\n        seg.update(0,N,0);\n        for (int i = 0; i < q; i++) {\n            int t = sc.nextInt();\n            if (t == 0) {\n                seg.update( sc.nextInt(), sc.nextInt()+1, sc.nextInt());\n            } else {\n                System.out.println(seg.sum( sc.nextInt(),  sc.nextInt()+1));\n            }\n        }\n        \n    }\n        \n    static class RUQ {\n        int n;\n        long[] sum, min, max, lazy;\n        int[] couMin, couMax;\n        boolean[] lazyFlag;\n\n        RUQ(int size) {\n            n = 1;\n            while (n < size) n *= 2;\n            sum = new long[2 * n - 1];\n            min = new long[2 * n - 1];\n            max = new long[2 * n - 1];\n            lazy = new long[2 * n - 1];\n            couMin = new int[2 * n - 1];\n            couMax = new int[2 * n - 1];\n            lazyFlag = new boolean[2 * n - 1];\n            Arrays.fill(min, Long.MAX_VALUE);\n            Arrays.fill(max, Long.MIN_VALUE);\n            for (int i = 0; i < n; i++) {\n                couMin[i + n - 1] = 1;\n                couMax[i + n - 1] = 1;\n            }\n            for (int i = 0; i < size; i++) {\n                update(i, 0);\n            }\n        }\n\n        RUQ(int[] a) {\n            this(a.length);\n            for (int i = 0; i < a.length; i++) {\n                update(i, a[i]);\n            }\n        }\n\n        public void update(int i, int x) {\n            i += n - 1;\n            sum[i] = x;\n            min[i] = x;\n            max[i] = x;\n            while (i > 0) {\n                i = (i - 1) / 2;\n                sum[i] = sum[i * 2 + 1] + sum[i * 2 + 2];\n                setMinMax(i);\n            }\n        }\n\n        public void update(int l, int r, int x) {\n            update(l, r, 0, x, 0, n);\n        }\n\n        public void update(int a, int b, int k, int x, int l, int r) {\n            eval(k, l, r);\n            if (r <= a || b <= l) return;\n            else if (a <= l && r <= b) {\n                lazy[k] = x;\n                lazyFlag[k] = true;\n                eval(k, l, r);\n            } else {\n                update(a, b, k * 2 + 1, x, l, (l + r) / 2);\n                update(a, b, k * 2 + 2, x, (l + r) / 2, r);\n                sum[k] = sum[k * 2 + 1] + sum[k * 2 + 2];\n                setMinMax(k);\n            }\n        }\n\n        public long sum(int l, int r) {\n            return sum(l, r, 0, 0, n);\n        }\n\n        public long sum(int a, int b, int k, int l, int r) {\n            eval(k, l, r);\n            if (r <= a || b <= l) return 0;\n            else if (a <= l && r <= b) {\n                return sum[k];\n            } else {\n                long lv = sum(a, b, k * 2 + 1, l, (l + r) / 2);\n                long rv = sum(a, b, k * 2 + 2, (l + r) / 2, r);\n                return lv + rv;\n            }\n        }\n\n        public long min(int l, int r) {\n            return min(l, r, 0, 0, n);\n        }\n\n        public long min(int a, int b, int k, int l, int r) {\n            eval(k, l, r);\n            if (r <= a || b <= l) return Integer.MAX_VALUE;\n            else if (a <= l && r <= b) {\n                return min[k];\n            } else {\n                long lv = min(a, b, k * 2 + 1, l, (l + r) / 2);\n                long rv = min(a, b, k * 2 + 2, (l + r) / 2, r);\n                return Math.min(lv, rv);\n            }\n        }\n\n        public long max(int l, int r) {\n            return max(l, r, 0, 0, n);\n        }\n\n        public long max(int a, int b, int k, int l, int r) {\n            eval(k, l, r);\n            if (r <= a || b <= l) return Integer.MIN_VALUE;\n            else if (a <= l && r <= b) {\n                return max[k];\n            } else {\n                long lv = max(a, b, k * 2 + 1, l, (l + r) / 2);\n                long rv = max(a, b, k * 2 + 2, (l + r) / 2, r);\n                return Math.max(lv, rv);\n            }\n        }\n\n        public long couMin(int l, int r) {\n            return couMin(l, r, 0, 0, n);\n        }\n\n        public long couMin(int a, int b, int k, int l, int r) {\n            eval(k, l, r);\n            if (r <= a || b <= l) return 0;\n            else if (a <= l && r <= b) {\n                return couMin[k];\n            } else {\n                long lv = min(a, b, k * 2 + 1, l, (l + r) / 2);\n                long rv = min(a, b, k * 2 + 2, (l + r) / 2, r);\n                long coul = couMin(a, b, k * 2 + 1, l, (l + r) / 2);\n                long cour = couMin(a, b, k * 2 + 2, (l + r) / 2, r);\n                long cou = 0;\n                if (lv <= rv) cou += coul;\n                if (lv >= rv) cou += cour;\n                return cou;\n            }\n        }\n\n        public long couMax(int l, int r) {\n            return couMax(l, r, 0, 0, n);\n        }\n\n        public long couMax(int a, int b, int k, int l, int r) {\n            eval(k, l, r);\n            if (r <= a || b <= l) return -1;\n            else if (a <= l && r <= b) {\n                return couMax[k];\n            } else {\n                long lv = max(a, b, k * 2 + 1, l, (l + r) / 2);\n                long rv = max(a, b, k * 2 + 2, (l + r) / 2, r);\n                long coul = couMax(a, b, k * 2 + 1, l, (l + r) / 2);\n                long cour = couMax(a, b, k * 2 + 2, (l + r) / 2, r);\n                long cou = 0;\n                if (lv >= rv) cou += coul;\n                if (lv <= rv) cou += cour;\n                return cou;\n            }\n        }\n\n        private void eval(int k, int l, int r) {\n            if (lazyFlag[k]) {\n                sum[k] = lazy[k] * (r - l);\n                min[k] = lazy[k];\n                max[k] = lazy[k];\n                couMin[k] = (r - l);\n                couMax[k] = (r - l);\n                if (r - l > 1) {\n                    lazy[k * 2 + 1] = lazy[k];\n                    lazy[k * 2 + 2] = lazy[k];\n                    lazyFlag[k * 2 + 1] = true;\n                    lazyFlag[k * 2 + 2] = true;\n                }\n                lazyFlag[k] = false;\n            }\n        }\n\n        private void setMinMax(int i) {\n            couMin[i] = couMax[i] = 0;\n            if (min[i * 2 + 1] <= min[i * 2 + 2]) {\n                min[i] = min[i * 2 + 1];\n                couMin[i] += couMin[i * 2 + 1];\n            }\n            if (min[i * 2 + 1] >= min[i * 2 + 2]) {\n                min[i] = min[i * 2 + 2];\n                couMin[i] += couMin[i * 2 + 2];\n            }\n            if (max[i * 2 + 1] >= max[i * 2 + 2]) {\n                max[i] = max[i * 2 + 1];\n                couMax[i] += couMax[i * 2 + 1];\n            }\n            if (max[i * 2 + 1] <= max[i * 2 + 2]) {\n                max[i] = max[i * 2 + 2];\n                couMax[i] += couMax[i * 2 + 2];\n            }\n        }\n    }\n\n    }\n\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\n\tprivate static Scanner sc;\n\tprivate static Printer pr;\n\n\tprivate static void solve() {\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\n\t\tLazySegmentTree rmq = new LazySegmentTree(new long[n]);\n\n\t\tfor (int i = 0; i < q; i++) {\n\t\t\tint cmd = sc.nextInt();\n\n\t\t\tif (cmd == 0) {\n\t\t\t\tint s = sc.nextInt();\n\t\t\t\tint t = sc.nextInt();\n\t\t\t\tint x = sc.nextInt();\n\n\t\t\t\trmq.update(s, t + 1, x);\n\t\t\t} else if (cmd == 1) {\n\t\t\t\tint s = sc.nextInt();\n\t\t\t\tint t = sc.nextInt();\n\n\t\t\t\tpr.println(rmq.query(s, t + 1));\n\t\t\t\tpr.flush();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * 遅延評価 Segment Tree\n\t * 区間更新(update)\n\t */\n\tstatic class LazySegmentTree {\n\t\tlong[] st; // データ用SegmentTree\n\t\tlong[] lazy; // 遅延評価用\n\t\tint n; // dataの要素数(2のべき乗に補正)\n\t\t\n\t\tprivate static final int RSumQ = 0;\n\t\tprivate static final int RMinQ = 1;\n\t\tprivate static final int RMaxQ = 2;\n\n\t\tfinal static int QueryType = RSumQ;\n\n\t\tfinal static long NULL = Long.MIN_VALUE; // 遅延評価不要を表す\n\t\tstatic long INIT; // 初期値\n\n\t\tpublic LazySegmentTree(long[] data) {\n\t\t\tn = 1;\n\t\t\twhile (n < data.length) {\n\t\t\t\tn *= 2;\n\t\t\t}\n\t\t\t\n\t\t\tswitch (QueryType) {\n\t\t\tcase RSumQ:\n\t\t\t\tINIT = 0;\n\t\t\t\tbreak;\n\t\t\tcase RMinQ:\n\t\t\t\tINIT = Long.MAX_VALUE;\n\t\t\t\tbreak;\n\t\t\tcase RMaxQ:\n\t\t\t\tINIT = Long.MIN_VALUE;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlazy = new long[2 * n - 1];\n\t\t\tArrays.fill(lazy, NULL);\n\n\t\t\tst = new long[2 * n - 1];\n\t\t\tfor (int k = 0, size = data.length; k < n; k++) {\n\t\t\t\tif (k < size) {\n\t\t\t\t\tst[n - 1 + k] = data[k];\n\t\t\t\t} else {\n\t\t\t\t\tst[n - 1 + k] = INIT;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = n - 2; k >= 0; k--) {\n\t\t\t\tlong q1 = st[2 * k + 1];\n\t\t\t\tlong q2 = st[2 * k + 2];\n\t\t\t\t\n\t\t\t\tswitch (QueryType) {\n\t\t\t\tcase RSumQ:\n\t\t\t\t\tst[k] = q1 + q2; // RSumQ\n\t\t\t\t\tbreak;\n\t\t\t\tcase RMinQ:\n\t\t\t\t\tst[k] = Math.min(q1, q2); // RMinQ\n\t\t\t\t\tbreak;\n\t\t\t\tcase RMaxQ:\n\t\t\t\t\tst[k] = Math.max(q1, q2); // RMaxQ\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// l,r:0-indexed\n\t\t// [l,r)の値をupdate\n\t\tvoid update(int l, int r, int x) {\n\t\t\tupdate(l, r, x, 0, 0, n);\n\t\t}\n\n\t\tprivate void update(int l, int r, int x, int k, int ll, int rr) {\n\t\t\tif (ll >= l && rr <= r) {\n\t\t\t\tlazy[k] = x;\n\t\t\t\t\n\t\t\t\tswitch (QueryType) {\n\t\t\t\tcase RSumQ:\n\t\t\t\t\tst[k] = x * (rr -ll); // RSumQ\n\t\t\t\t\tbreak;\n\t\t\t\tcase RMinQ:\n\t\t\t\tcase RMaxQ:\n\t\t\t\t\tst[k] = x; // RMinQ, RMaxQ\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (ll >= r || rr <= l) {\n\t\t\t\t// 交差なし\n\t\t\t} else {\n\t\t\t\tint mm = (ll + rr) / 2;\n\n\t\t\t\tpropagate(k, ll, rr);\n\t\t\t\tupdate(l, r, x, 2 * k + 1, ll, mm);\n\t\t\t\tupdate(l, r, x, 2 * k + 2, mm, rr);\n\n\t\t\t\tlong q1 = st[2 * k + 1];\n\t\t\t\tlong q2 = st[2 * k + 2];\n\t\t\t\t\n\t\t\t\tswitch (QueryType) {\n\t\t\t\tcase RSumQ:\n\t\t\t\t\tst[k] = q1 + q2; // RSumQ\n\t\t\t\t\tbreak;\n\t\t\t\tcase RMinQ:\n\t\t\t\t\tst[k] = Math.min(q1, q2); // RMinQ\n\t\t\t\t\tbreak;\n\t\t\t\tcase RMaxQ:\n\t\t\t\t\tst[k] = Math.max(q1, q2); // RMaxQ\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void propagate(int k, int ll, int rr) {\n\t\t\tif (lazy[k] != NULL) {\n\t\t\t\tint mm = (ll + rr) / 2;\n\t\t\t\t\n\t\t\t\tlazy[2 * k + 1] = lazy[k];\n\t\t\t\tlazy[2 * k + 2] = lazy[k];\n\n\t\t\t\tswitch (QueryType) {\n\t\t\t\tcase RSumQ:\n\t\t\t\t\tst[2 * k + 1] = lazy[k] * (mm - ll); // RSumQ\n\t\t\t\t\tst[2 * k + 2] = lazy[k] * (rr - mm); // RSumQ\n\t\t\t\t\tbreak;\n\t\t\t\tcase RMinQ:\n\t\t\t\tcase RMaxQ:\n\t\t\t\t\tst[2 * k + 1] = lazy[k]; // RMinQ, RMaxQ\n\t\t\t\t\tst[2 * k + 2] = lazy[k]; // RMinQ, RMaxQ\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tlazy[k] = NULL;\n\t\t\t}\n\t\t}\n\n\t\t// l,r:0-indexed\n\t\t// [l,r)に対するクエリ\n\t\tlong query(int l, int r) {\n\t\t\treturn query(l, r, 0, 0, n);\n\t\t}\n\n\t\tprivate long query(int l, int r, int k, int ll, int rr) {\n\t\t\tlong ret = 0;\n\n\t\t\tif (ll >= l && rr <= r) {\n\t\t\t\tret = st[k];\n\t\t\t} else if (ll >= r || rr <= l) {\n\t\t\t\t// 交差なし\n\t\t\t\tret = INIT;\n\t\t\t} else {\n\t\t\t\tint mm = (ll + rr) / 2;\n\n\t\t\t\tpropagate(k, ll, rr);\n\t\t\t\tlong q1 = query(l, r, 2 * k + 1, ll, mm);\n\t\t\t\tlong q2 = query(l, r, 2 * k + 2, mm, rr);\n\n\t\t\t\tswitch (QueryType) {\n\t\t\t\tcase RSumQ:\n\t\t\t\t\tret = q1 + q2; // RSumQ\n\t\t\t\t\tbreak;\n\t\t\t\tcase RMinQ:\n\t\t\t\t\tret = Math.min(q1, q2); // RMinQ\n\t\t\t\t\tbreak;\n\t\t\t\tcase RMaxQ:\n\t\t\t\t\tret = Math.max(q1, q2); // RMaxQ\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t// ---------------------------------------------------\n\tpublic static void main(String[] args) {\n\t\tsc = new Scanner(System.in);\n\t\tpr = new Printer(System.out);\n\t\t\t\n\t\tsolve();\n\t\t\t\n\t\tpr.close();\n\t\tsc.close();\n\t}\n\n\tstatic class Scanner {\n\t\tBufferedReader br;\n\n\t\tScanner (InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\n\t\tprivate boolean isPrintable(int ch) {\n\t\t\treturn ch >= '!' && ch <= '~';\n\t\t}\n\n\t\tprivate boolean isCRLF(int ch) {\n\t\t\treturn ch == '\\n' || ch == '\\r' || ch == -1;\n\t\t}\n\n\t\tprivate int nextPrintable() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (!isPrintable(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn ch;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tint ch = nextPrintable();\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\t// parseInt from Integer.parseInt()\n\t\t\t\tboolean negative = false;\n\t\t\t\tint res = 0;\n\t\t\t\tint limit = -Integer.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Integer.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tint multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\ttry {\n\t\t\t\t// parseLong from Long.parseLong()\n\t\t\t\tboolean negative = false;\n\t\t\t\tlong res = 0;\n\t\t\t\tlong limit = -Long.MAX_VALUE;\n\t\t\t\tint radix = 10;\n\n\t\t\t\tint fc = nextPrintable();\n\t\t\t\tif (fc < '0') {\n\t\t\t\t\tif (fc == '-') {\n\t\t\t\t\t\tnegative = true;\n\t\t\t\t\t\tlimit = Long.MIN_VALUE;\n\t\t\t\t\t} else if (fc != '+') {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tfc = br.read();\n\t\t\t\t}\n\t\t\t\tlong multmin = limit / radix;\n\n\t\t\t\tint ch = fc;\n\t\t\t\tdo {\n\t\t\t\t\tint digit = ch - '0';\n\t\t\t\t\tif (digit < 0 || digit >= radix) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tif (res < multmin) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres *= radix;\n\t\t\t\t\tif (res < limit + digit) {\n\t\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t\t}\n\t\t\t\t\tres -= digit;\n\n\t\t\t\t} while (isPrintable(ch = br.read()));\n\n\t\t\t\treturn negative ? res : -res;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\n\t\tfloat nextFloat() {\n\t\t\treturn Float.parseFloat(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\ttry {\n\t\t\t\tint ch;\n\t\t\t\twhile (isCRLF(ch = br.read())) {\n\t\t\t\t\tif (ch == -1) {\n\t\t\t\t\t\tthrow new NoSuchElementException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tdo {\n\t\t\t\t\tsb.appendCodePoint(ch);\n\t\t\t\t} while (!isCRLF(ch = br.read()));\n\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] ret = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tret[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\treturn ret;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] ret = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tret[i] = sc.nextLong();\n\t\t\t}\n\t\t\t\n\t\t\treturn ret;\n\t\t}\n\n\t\tint[][] nextIntArrays(int m, int n) {\n\t\t\tint[][] ret = new int[m][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tret[j][i] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn ret;\n\t\t}\n\n\t\tvoid close() {\n\t\t\ttry {\n\t\t\t\tbr.close();\n\t\t\t} catch (IOException e) {\n//\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Printer extends PrintWriter {\n\t\tPrinter(OutputStream out) {\n\t\t\tsuper(out);\n\t\t}\n\t\t\n\t\tvoid printInts(int... a) {\n\t\t\tStringBuilder sb = new StringBuilder(32);\n\t\t\tfor (int i = 0, size = a.length; i < size; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tsb.append(' ');\n\t\t\t\t}\n\t\t\t\tsb.append(a[i]);\n\t\t\t}\n\n\t\t\tprintln(sb);\n\t\t}\n\t\t\n\t\tvoid printLongs(long... a) {\n\t\t\tStringBuilder sb = new StringBuilder(64);\n\t\t\tfor (int i = 0, size = a.length; i < size; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tsb.append(' ');\n\t\t\t\t}\n\t\t\t\tsb.append(a[i]);\n\t\t\t}\n\n\t\t\tprintln(sb);\n\t\t}\n\t\t\n\t\tvoid printStrings(String... a) {\n\t\t\tStringBuilder sb = new StringBuilder(32);\n\t\t\tfor (int i = 0, size = a.length; i < size; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tsb.append(' ');\n\t\t\t\t}\n\t\t\t\tsb.append(a[i]);\n\t\t\t}\n\n\t\t\tprintln(sb);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n//\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint n = sc.nextInt();\n\t\tint q = sc.nextInt();\n\n\t\tSqrtDecompositionRSQRUQ sq = new SqrtDecompositionRSQRUQ(n);\n\t\tfor(int i = 0; i < q; i++){\n\t\t\tint type = sc.nextInt();\n\n\t\t\tif(type == 0){\n\t\t\t\tint s = sc.nextInt();\n\t\t\t\tint t = sc.nextInt();\n\t\t\t\tint x = sc.nextInt();\n\n\t\t\t\tsq.update(s, t + 1, x);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint s = sc.nextInt();\n\t\t\t\tint t = sc.nextInt();\n\n\t\t\t\tSystem.out.println(sq.getSum(s, t + 1));\n\t\t\t}\n\n\t\t}\n\t}\n\n}\n\nclass SqrtDecompositionRSQRUQ {\n\tint N, K;\n\tlong[] data;\n\tlong[] bucketSum;\n\tlong[] bucketLazyUpdate;\n\tstatic final int sqrtN = 512;\n\tstatic final int NIL = Integer.MIN_VALUE;\n\n\tpublic SqrtDecompositionRSQRUQ(int n) {\n\t\tN = n;\n\t\tK = (N + sqrtN - 1) / sqrtN;\n\t\tdata = new long[K * sqrtN];\n\t\tbucketLazyUpdate = new long[K];\n\t\tArrays.fill(bucketLazyUpdate, NIL);\n\t\tbucketSum = new long[K];\n\t}\n\n\t// [s, t)\n\tvoid update(int s, int t, int x) {\n\t\tfor (int k = 0; k < K; ++k) {\n\t\t\tint l = k * sqrtN, r = (k + 1) * sqrtN;\n\t\t\tif (r <= s || t <= l)\n\t\t\t\tcontinue;\n\t\t\tif (s <= l && r <= t) {\n\t\t\t\tbucketLazyUpdate[k] = x;\n\t\t\t\tbucketSum[k] = x*sqrtN;\n\t\t\t} else {\n\t\t\t\tif(bucketLazyUpdate[k] != NIL){\n\t\t\t\t\tfor(int i = l; i < r; i++){\n\t\t\t\t\t\tdata[i] = bucketLazyUpdate[k];\n\n\t\t\t\t\t}\n\t\t\t\t\tbucketLazyUpdate[k] = NIL;\n\t\t\t\t}\n\t\t\t\tfor (int i = Math.max(s, l); i < Math.min(t, r); ++i) {\n\t\t\t\t\tdata[i] = x;\n\t\t\t\t}\n\t\t\t\tbucketSum[k] = 0;\n\t\t\t\tfor(int i = l; i < r; i++){\n\t\t\t\t\tbucketSum[k] += data[i];\n\t\t\t\t}\n\t\t\t}\n//\t\t\tSystem.out.println(\"from \"+l+\" to \"+r+ \" bucketSum \"+bucketSum[k] );\n\t\t}\n\t}\n\n\t//[s,t)\n\tlong getSum(int s, int t) {\n\t\tlong result = 0;\n\t\tfor (int k = 0; k < K; ++k) {\n\t\t\tint l = k * sqrtN, r = (k + 1) * sqrtN;\n\t\t\tif (r <= s || t <= l)\n\t\t\t\tcontinue;\n\t\t\tif (s <= l && r <= t) {\n\t\t\t\tresult += bucketSum[k];\n//\t\t\t\tSystem.out.println(\"bucket Add \" + result);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i = Math.max(s, l); i < Math.min(t, r); ++i) {\n\t\t\t\t\tif(bucketLazyUpdate[k] != NIL){\n\t\t\t\t\t\tresult += bucketLazyUpdate[k];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tresult += data[i];\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(\"direct Add \" + result);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tlong get(int s) {\n\t\tint k = s / sqrtN;\n\t\tif(bucketLazyUpdate[k] != NIL){\n\t\t\treturn bucketLazyUpdate[k];\n\t\t}\n\t\telse {\n\t\t\treturn data[s];\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Runtime.CompilerServices;\nusing System.Text;\nusing static Template;\nusing static System.Console;\nusing static System.Convert;\nusing static System.Math;\nusing Pi = Pair<int, int>;\nusing Number = System.Int64;\n\nclass Solver\n{\n    public void Solve()\n    {\n        int n, q;\n        Input.Make(out n, out q);\n        var seg = new LazySegmentTree<long, long>(n, 0, int.MinValue, (a, b) => a + b, (a, b) => b, (a, b) => b, (a, b) => a * b);\n        for (var i = 0; i < n; i++)\n            seg[i] = 0;\n        seg.All_Update();\n        while (q-- > 0)\n        {\n            int c = Input.Next<int>();\n            if (c == 0)\n            {\n                int s, t, x;\n                Input.Make(out s, out t, out x);\n                seg.Update(s, t+1, x);\n            }\n            else\n            {\n                int s, t;\n                Input.Make(out s, out t);\n                WriteLine(seg.Query(s, t+1)) ;\n            }\n        }\n    }\n}\n\npublic class LazySegmentTree<T,E>\n    where E : IComparable<E>\n{\n    protected readonly int num;\n    protected readonly T minT;\n    protected readonly T[] item;\n    protected readonly E minE;\n    protected readonly E[] lazy;\n    protected readonly Func<T, T, T> func;\n    protected readonly Func<T, E, T> updateFunc;\n    protected readonly Func<E, E, E> lazyFunc;\n    protected readonly Func<E, int, E> secf;\n\n    public T this[int i]\n    {\n        get { return item[i + num - 1]; }\n        set { item[i + num - 1] = value; }\n    }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    protected int Parent(int index)\n        => (index - 1) >> 1;\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    protected int Left(int index)\n        => (index << 1) + 1;\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    protected int Right(int index)\n        => (index + 1) << 1;\n    public LazySegmentTree(int num, T minT, E minE, Func<T, T, T> func, Func<T, E, T> updateFunc = null, Func<E, E, E> lazyFunc = null, Func<E, int, E> secf = null)\n    {\n        this.func = func;\n        this.num = 1;\n        this.minT = minT;\n        this.minE = minE;\n        this.updateFunc = updateFunc ?? ((a, b) => a);\n        this.lazyFunc = lazyFunc ?? ((a, b) => b);\n        this.secf = secf ?? ((a, b) => a);\n\n        while (this.num <= num)\n            this.num <<= 1;\n        item = new T[2 * this.num - 1];\n        for (var i = 0; i < 2 * this.num - 1; i++)\n            item[i] = minT;\n        lazy = Enumerable.Repeat(0, 2 * this.num + 1).Select(_ => minE).ToArray();\n    }\n    protected void eval(int len, int k)\n    {\n        if (lazy[k].CompareTo(minE) == 0) return;\n        if (Right(k) < num * 2)\n        {\n            lazy[Left(k)] = lazyFunc(lazy[Left(k)], lazy[k]);\n            lazy[Right(k)] = lazyFunc(lazy[Right(k)], lazy[k]);\n        }\n        item[k] = updateFunc(item[k], secf(lazy[k], len));\n        lazy[k] = minE;\n    }\n    public void All_Update()\n    {\n        for (int i = num - 2; i >= 0; i--)\n            item[i] = func(item[Left(i)], item[Right(i)]);\n    }\n    public void Update(int left, int right, E value)\n        => Update(left, right, 0, 0, num, value);\n    protected void Update(int left, int right, int k, int l, int r, E value)\n    {\n        eval(r - l, k);\n        if (r <= left || right <= l) return;\n        if (left <= l && r <= right)\n        {\n            lazy[k] = lazyFunc(lazy[k], value);\n            eval(r - l, k);\n        }\n        else\n        {\n            Update(left, right, Left(k), l, (l + r) >> 1, value);\n            Update(left, right, Right(k), (l + r) >> 1, r, value);\n            item[k] = func(item[Left(k)], item[Right(k)]);\n        }\n    }\n    public T Query(int left, int right)\n        => Query(left, right, 0, 0, num);\n    protected T Query(int left, int right, int k, int l, int r)\n    {\n        if (r <= left || right <= l) return minT;\n        eval(r - l, k);\n        if (left <= l && r <= right) return item[k];\n        else\n            return func(Query(left, right, Left(k), l, (l + r) >> 1), Query(left, right, Right(k), (l + r) >> 1, r));\n    }\n}\n\n#region Template\npublic class Template\n{\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static bool chmin<T>(ref T num, T val) where T : IComparable<T>\n    { if (num.CompareTo(val) == 1) { num = val; return true; } return false; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static bool chmax<T>(ref T num, T val) where T : IComparable<T>\n    { if (num.CompareTo(val) == -1) { num = val; return true; } return false; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static void swap<T>(ref T v1, ref T v2)\n    { var t = v2; v2 = v1; v1 = t; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static T[] Create<T>(int n, Func<T> f)\n        => Enumerable.Repeat(0, n).Select(_ => f()).ToArray();\n    public static void Fail() => Fail(\"No\");\n    public static void Fail<T>(T s) { Console.WriteLine(s); Console.Out.Close(); Environment.Exit(0); }\n    static void Main(string[] args)\n    {\n        var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n        Console.SetOut(sw);\n        var p = new Solver();\n        for (var i = 1; i > 0; --i)\n            p.Solve();\n        Console.Out.Flush();\n    }\n}\n\npublic class Input\n{\n    public static string read => Console.ReadLine().Trim();\n    public static int[] ar => read.Split(' ').Select(int.Parse).ToArray();\n    public static int num => Convert.ToInt32(read);\n    public static long[] arL => read.Split(' ').Select(long.Parse).ToArray();\n    public static long numL => Convert.ToInt64(read);\n    public static char[][] grid(int h)\n        => Create(h, () => read.ToCharArray());\n    public static int[] ar1D(int n)\n        => Create(n, () => num);\n    public static long[] arL1D(int n)\n        => Create(n, () => numL);\n    public static string[] strs(int n)\n        => Create(n, () => read);\n    public static int[][] ar2D(int n)\n        => Create(n, () => ar);\n    public static long[][] arL2D(int n)\n        => Create(n, () => arL);\n    public static List<T>[] edge<T>(int n)\n        => Create(n, () => new List<T>());\n    public static void Make<T1, T2>(out T1 v1, out T2 v2)\n    {\n        v1 = Next<T1>();\n        v2 = Next<T2>();\n    }\n    public static void Make<T1, T2, T3>(out T1 v1, out T2 v2, out T3 v3)\n    {\n        Make(out v1, out v2);\n        v3 = Next<T3>();\n    }\n    public static void Make<T1, T2, T3, T4>(out T1 v1, out T2 v2, out T3 v3, out T4 v4)\n    {\n        Make(out v1, out v2, out v3);\n        v4 = Next<T4>();\n    }\n    public static void Make<T1, T2, T3, T4, T5>(out T1 v1, out T2 v2, out T3 v3, out T4 v4, out T5 v5)\n    {\n        Make(out v1, out v2, out v3, out v4);\n        v5 = Next<T5>();\n    }\n    public static void Make<T1, T2, T3, T4, T5, T6>(out T1 v1, out T2 v2, out T3 v3, out T4 v4, out T5 v5, out T6 v6)\n    {\n        Make(out v1, out v2, out v3, out v4, out v5);\n        v6 = Next<T6>();\n    }\n    static Input()\n    {\n        sc = new Queue<string>();\n        dic = new Dictionary<Type, Func<string, object>>();\n        dic[typeof(int)] = s => int.Parse(s);\n        dic[typeof(long)] = s => long.Parse(s);\n        dic[typeof(char)] = s => char.Parse(s);\n        dic[typeof(double)] = s => double.Parse(s);\n        dic[typeof(uint)] = s => uint.Parse(s);\n        dic[typeof(ulong)] = s => ulong.Parse(s);\n        dic[typeof(string)] = s => s;\n    }\n    private static Dictionary<Type, Func<string, object>> dic;\n    private static Queue<string> sc;\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static T Next<T>() { if (sc.Count == 0) foreach (var item in read.Split(' ')) sc.Enqueue(item); return (T)dic[typeof(T)](sc.Dequeue()); }\n    public const int MOD = 1000000007;\n}\n\npublic class Pair<T1, T2> : IComparable<Pair<T1, T2>>\n{\n    public T1 v1;\n    public T2 v2;\n    public Pair() { v1 = default(T1);v2 = default(T2); }\n    public Pair(T1 v1, T2 v2)\n    { this.v1 = v1; this.v2 = v2; }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public int CompareTo(Pair<T1, T2> p)\n    {\n        var c = Comparer<T1>.Default.Compare(v1, p.v1);\n        if (c == 0)\n            c = Comparer<T2>.Default.Compare(v2, p.v2);\n        return c;\n    }\n    public override string ToString()\n        => $\"{v1.ToString()} {v2.ToString()}\";\n}\n\npublic class Pair<T1, T2, T3> : Pair<T1, T2>, IComparable<Pair<T1, T2, T3>>\n{\n    public T3 v3;\n    public Pair() : base() { v3 = default(T3); }\n    public Pair(T1 v1, T2 v2, T3 v3) : base(v1, v2)\n    { this.v3 = v3; }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public int CompareTo(Pair<T1, T2, T3> p)\n    {\n        var c = base.CompareTo(p);\n        if (c == 0)\n            c = Comparer<T3>.Default.Compare(v3, p.v3);\n        return c;\n    }\n    public override string ToString()\n        => $\"{base.ToString()} {v3.ToString()}\";\n}\n#endregion\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing static System.Math;\n\nnamespace CSharpSpiral {\n\tusing SegmentTree;\n\tclass Program {\n\t\tpublic static void Main(string[] args) {\n\t\t\tvar sw = new StreamWriter(Console.OpenStandardOutput()) {\n\t\t\t\tAutoFlush=\n#if DEBUG\n\t\t\ttrue\n#else\n\t\t\tfalse\n#endif\n\t\t\t};\n\t\t\tConsole.SetOut(sw);\n\t\t\tnew Program().Solve(new ConsoleInput(\n#if DEBUG\n\t\t\tnew StreamReader(\"../../../inputData.txt\")\n#else\n\t\t\tConsole.In\n#endif\n\t\t\t, ' '));\n\t\t\tConsole.Out.Flush();\n\t\t}\n\t\tpublic void Solve(ConsoleInput cin) {\n\t\t\tvar datum = cin.ReadIntArray(2);\n\t\t\tint N = datum[0], Q = datum[1];\n\t\t\tvar X = new LazySegment<long, long?>(N, (i, j) => i+j, 0,\n\t\t\t(x, a) => a??x, (a, b) => b??a, null,\n\t\t\t(x, i) => x!=null ? x*i : null,\n\t\t\tx=>x/2\n\t\t\t);\n\t\t\tfor(int q = 0; q<Q; q++) {\n\t\t\t\tvar query = cin.ReadInt;\n\t\t\t\tvar s0 = cin.ReadInt;\n\t\t\t\tvar s1 = cin.ReadInt+1;\n\t\t\t\tswitch(query) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tvar x = cin.ReadInt;\n\t\t\t\t\t\tX.RangeUpdate(s0, s1, x);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tvar res = X.GetValue(s0, s1);\n\t\t\t\t\t\t//Console.WriteLine(X.Nodes.Join());\n\t\t\t\t\t\t//Console.WriteLine(X.leafs().Join());\n\t\t\t\t\t\tConsole.WriteLine(res);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tstatic class ExtendClass {\n\t\tpublic static string Join<T>(this IEnumerable<T> X, string separator = \" \")\n\t\t\t=> string.Join(separator, X);\n\t}\n\tclass ConsoleInput {\n\t\tprivate readonly TextReader _stream;\n\t\tprivate readonly char _separator = ' ';\n\t\tprivate readonly Queue<string> inputStream;\n\t\tpublic ConsoleInput(TextReader stream, char separator = ' ') {\n\t\t\tthis._separator=separator;\n\t\t\tthis._stream=stream;\n\t\t\tinputStream=new Queue<string>();\n\t\t}\n\t\tpublic string Read {\n\t\t\tget {\n\t\t\t\tif(inputStream.Count!=0) return inputStream.Dequeue();\n\t\t\t\tstring[] tmp = _stream.ReadLine().Split(_separator);\n\t\t\t\tfor(int i = 0; i<tmp.Length; ++i)\n\t\t\t\t\tinputStream.Enqueue(tmp[i]);\n\t\t\t\treturn inputStream.Dequeue();\n\t\t\t}\n\t\t}\n\t\tpublic string ReadLine { get { return _stream.ReadLine(); } }\n\t\tpublic int ReadInt { get { return int.Parse(Read); } }\n\t\tpublic long ReadLong { get { return long.Parse(Read); } }\n\t\tpublic double ReadDouble { get { return double.Parse(Read); } }\n\t\tpublic string[] ReadStrArray(long N) {\n\t\t\tvar ret = new string[N];\n\t\t\tfor(long i = 0; i<N; ++i)\n\t\t\t\tret[i]=Read;\n\t\t\treturn ret;\n\t\t}\n\t\tpublic int[] ReadIntArray(long N) { var ret = new int[N]; for(long i = 0; i<N; ++i) ret[i]=ReadInt; return ret; }\n\t\tpublic long[] ReadLongArray(long N) { var ret = new long[N]; for(long i = 0; i<N; ++i) ret[i]=ReadLong; return ret; }\n\t\tpublic double[] ReadDoubleArray(long N) { var ret = new double[N]; for(long i = 0; i<N; ++i) ret[i]=ReadDouble; return ret; }\n\t\tpublic bool isEOF {\n\t\t\tget { return _stream.Peek()==-1; }\n\t\t}\n\t}\n}\n\nnamespace SegmentTree {\n\tclass SegmentTree<T> {\n\t\t//UI is 0-indexed, internal is 1-indexed\n\t\tpublic readonly int rank;\n\t\tpublic T[] Nodes { get; }\n\t\tpublic Func<T, T, T> OPER { get; }\n\t\tpublic T unit { get; set; }\n\t\tprotected int width { get { return 1<<(rank-1); } }\n\t\tprivate T raise(int c) {\n\t\t\treturn (c&1)==0\n\t\t\t? OPER(Nodes[c-1], Nodes[(c-1)+1]) //$c is even\n\t\t\t: OPER(Nodes[(c-1)-1], Nodes[c-1]); //odd\n\t\t}\n\t\tpublic IEnumerable<T> leafs() => Nodes.Skip(width-1);\n\t\tprotected int leafIndex(int x) => (1<<(rank-1))+(x-1);\n\t\tpublic SegmentTree(int count, Func<T, T, T> _OPER, T _unit) {\n\t\t\tif(count==0) throw new ArgumentNullException();\n\t\t\tvar last = count-1;\n\t\t\trank=0;\n\t\t\tif(last>0) {\n\t\t\t\twhile((last>>rank)>1) rank++;\n\t\t\t\trank+=2;\n\t\t\t} else rank=1;\n\t\t\tNodes=Enumerable.Repeat(_unit, (1<<rank)-1).ToArray();\n\t\t\tOPER=_OPER;\n\t\t\tunit=_unit;\n\t\t}\n\t\tpublic virtual void SetImmediate(int x, T value) {\n\t\t\tvar r = rank-1;\n\t\t\tvar jc = (1<<r)+x;\n\t\t\tNodes[jc-1]=value;\n\t\t\tfor(r--; r>=0; r--) {\n\t\t\t\tvar parentIndex = (jc>>1)-1;\n\t\t\t\tvar oldValue = Nodes[parentIndex];\n\t\t\t\tNodes[parentIndex]=raise(jc);\n\t\t\t\tif(oldValue.Equals(Nodes[parentIndex])) break;\n\t\t\t\tjc>>=1;\n\t\t\t}\n\t\t}\n\t\tpublic virtual void ImmediateOperate<S>(int x, S value, Func<S, T, T> LeftOP) {\n\t\t\tSetImmediate(x, LeftOP(value, Nodes[leafIndex(x)]));\n\t\t}\n\t\tpublic virtual T GetValue(int start, int end) => GV(start, end, 1, 0, width);\n\t\tprivate T GV(int start, int end, int count, int focusStart, int focusEnd) {\n\t\t\tif(focusEnd<=start||end<=focusStart) return unit;\n\t\t\tif(start<=focusStart&&focusEnd<=end) return Nodes[count-1];\n\t\t\tvar mid = focusStart+(focusEnd-focusStart)/2;\n\t\t\treturn OPER(\n\t\t\t\tGV(start, end, count*2, focusStart, mid),\n\t\t\t\tGV(start, end, count*2+1, mid, focusEnd)\n\t\t\t);\n\t\t}\n\t\tpublic IEnumerable<T> GetLayer(int c) => Nodes.Skip((1<<(c-1))-1).Take(1<<(c-1));\n\t\tpublic IEnumerable<T> GetLeaves() => Nodes.Skip((1<<(rank-1))-1).Take(1<<(rank-1));\n\t}\n\t//https://tsutaj.hatenablog.com/entry/2017/03/30/224339\n\t//https://github.com/drken1215/algorithm/blob/master/DataStructure/segment_tree_delay.cpp\n\tclass LazySegment<T,S>: SegmentTree<T> {\n\t\tpublic LazySegment(int _N, Func<T, T, T> _OPER, T _unit,\n\t\t\tFunc<T,S,T> _ACT,Func<S,S,S> _OPER_ACT,S _unit_OPER,\n\t\t\tFunc<S,int,S> _POWERS,Func<S,S> _SQRT\n\t\t) : base(_N, _OPER, _unit) {\n\t\t\tlazy=Enumerable.Repeat(_unit_OPER, Nodes.Length).ToArray();\n\t\t\tFA=_ACT;\n\t\t\tFL=_OPER_ACT;\n\t\t\tuo=_unit_OPER;\n\t\t\tPower=_POWERS;\n\t\t\tSQ=_SQRT;\n\t\t}\n\t\tFunc<T,S,T> FA{ get; }\n\t\tFunc<S,S,S> FL{ get; }\n\t\tFunc<S, int, S> Power { get; }\n\t\tFunc<S, S> SQ { get; }\n\t\tvoid AL(ref S sOld, S sNew) { sOld=FL(sOld, sNew); }\n\t\tvoid AA(ref T t, S s) { t=FA(t, s); }\n\t\tS uo { get; }\n\t\tprivate S[] lazy { get; }\n\t\t//k is 0-indexed\n\t\tprivate void eval(int k, int interval) {\n\t\t\tif(!lazy[k].Equals(uo)) {\n\t\t\t\tif(k+1<width) {\n\t\t\t\t\tAL(ref lazy[2*k+1], SQ(lazy[k]));\n\t\t\t\t\tAL(ref lazy[2*k+2], SQ(lazy[k]));\n\t\t\t\t}\n\t\t\t\tAA(ref Nodes[k], lazy[k]);\n\t\t\t\tlazy[k]=uo;\n\t\t\t}\n\t\t}\n\t\tprivate void RangeUpdate(int start, int end, S value,\n\t\t\tint nodeIdx, int focusStart, int focusEnd) {\n\t\t\tif(focusEnd<0) focusEnd=width;\n\t\t\teval(nodeIdx, focusEnd-focusStart);\n\t\t\tif(end<=focusStart||focusEnd<=start) return;\n\t\t\tif(start<=focusStart&&focusEnd<=end) {\n\t\t\t\tAL(ref lazy[nodeIdx], Power(value,focusEnd-focusStart));\n\t\t\t\teval(nodeIdx, focusEnd-focusStart);\n\t\t\t} else {\n\t\t\t\tvar midFocus = (focusStart+focusEnd)/2;\n\t\t\t\tRangeUpdate(start, end, value, 2*nodeIdx+1, focusStart, midFocus);\n\t\t\t\tRangeUpdate(start, end, value, 2*nodeIdx+2, midFocus, focusEnd);\n\t\t\t\tNodes[nodeIdx]=OPER(Nodes[2*nodeIdx+1], Nodes[2*nodeIdx+2]);\n\t\t\t}\n\t\t}\n\t\tpublic void RangeUpdate(int start, int end, S value) => RangeUpdate(start, end, value, 0, 0, -1);\n\t\tpublic override T GetValue(int start, int end) {\n\t\t\treturn GetValue(start, end, 0, 0, -1);\n\t\t}\n\t\tprivate T GetValue(int start, int end,\n\t\t\tint nodeIdx, int focusStart, int focusEnd) {\n\t\t\tif(focusEnd<0) focusEnd=width;\n\t\t\teval(nodeIdx, focusEnd-focusStart);\n\t\t\tif(end<=focusStart||focusEnd<=start) return unit;\n\t\t\tif(start<=focusStart&&focusEnd<=end)\n\t\t\t\treturn Nodes[nodeIdx];\n\t\t\tvar midFocus = (focusStart+focusEnd)/2;\n\t\t\tvar leftV = GetValue(start, end, 2*nodeIdx+1, focusStart, midFocus);\n\t\t\tvar rightV = GetValue(start, end, 2*nodeIdx+2, midFocus, focusEnd);\n\t\t\treturn OPER(leftV, rightV);\n\t\t}\n\t}\n\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing Debug = System.Diagnostics.Debug;\nusing static System.Math;\nusing MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;\nusing MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;\n\nstatic class P\n{\n    static void Main()\n    {\n        int n = NextInt;\n        var q = NextInt;\n        SegmentTree<SegNode, int> segTree = new SegmentTree<SegNode, int>(Enumerable.Repeat(new SegNode(1, 0), n).ToArray(), new SegNode(0, 0), 1333, SegNode.Add, (x, y) => y == 1333 ? x : y, (x, y) => y == 1333 ? x : new SegNode(x.Length, x.Length * y));\n        StringBuilder builder = new StringBuilder();\n        for (int i = 0; i < q; i++)\n        {\n            if (NextInt == 0)\n                segTree.Update(NextInt, NextInt, NextSInt);\n            else\n                builder.AppendLine(segTree.Query(NextInt, NextInt).Value.ToString());\n        }\n        Console.Write(builder.ToString());\n    }\n\n    static readonly TextReader In = Console.In;\n\n    static int NextInt\n    {\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        get\n        {\n            int res = 0;\n            int next = In.Read();\n            while (45 > next || next > 57) next = In.Read();\n            while (48 <= next && next <= 57)\n            {\n                res = res * 10 + next - 48;\n                next = In.Read();\n            }\n            return res;\n        }\n    }\n    static int NextSInt\n    {\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        get\n        {\n            int res = 0;\n            int next = In.Read();\n            int rev = 1;\n            while (45 > next || next > 57) next = In.Read();\n            if (next == 45) { next = In.Read(); rev = -1; }\n            while (48 <= next && next <= 57)\n            {\n                res = res * 10 + next - 48;\n                next = In.Read();\n            }\n            return res * rev;\n        }\n    }\n}\n\nstruct SegNode\n{\n    public int Length;\n    public int Value;\n    public SegNode(int length, int value)\n    {\n        Length = length;\n        Value = value;\n    }\n\n    public static SegNode Add(SegNode a, SegNode b) => new SegNode(a.Length + b.Length, a.Value + b.Value);\n}\n\n\nclass SegmentTree<DataT, OperatorT>\n{\n    public readonly int Size;\n    DataT DataIdentity;\n    OperatorT OperatorIdentity;\n    Func<DataT, DataT, DataT> MergeData;\n    Func<OperatorT, OperatorT, OperatorT> MergeOperator;\n    Func<DataT, OperatorT, DataT> Operate;\n    int LeafCount;\n    int Height;\n    DataT[] Data;\n    OperatorT[] Operators;\n\n    #region Construct\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public SegmentTree(int size, DataT dataIdentity, OperatorT operatorIdentity, Func<DataT, DataT, DataT> mergeData, Func<OperatorT, OperatorT, OperatorT> mergeOpeator, Func<DataT, OperatorT, DataT> operate)\n        : this(dataIdentity, operatorIdentity, mergeData, mergeOpeator, operate)\n    {\n        Size = size;\n        Build();\n        for (int i = 0; i < Data.Length; i++) Data[i] = DataIdentity;\n    }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public SegmentTree(DataT[] data, DataT dataIdentity, OperatorT operatorIdentity, Func<DataT, DataT, DataT> mergeData, Func<OperatorT, OperatorT, OperatorT> mergeOpeator, Func<DataT, OperatorT, DataT> operate)\n        : this(dataIdentity, operatorIdentity, mergeData, mergeOpeator, operate)\n    {\n        Size = data.Length;\n        Build();\n        for (int i = 0; i < data.Length; i++) Data[i + LeafCount] = data[i];\n        for (int i = data.Length + LeafCount; i < Data.Length; i++) Data[i] = dataIdentity;\n        for (int i = LeafCount - 1; i >= 0; i--) Data[i] = MergeData(Data[i << 1], Data[(i << 1) + 1]);\n    }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    private SegmentTree(DataT dataIdentity, OperatorT operatorIdentity, Func<DataT, DataT, DataT> mergeData, Func<OperatorT, OperatorT, OperatorT> mergeOpeator, Func<DataT, OperatorT, DataT> operate)\n    {\n        DataIdentity = dataIdentity;\n        OperatorIdentity = operatorIdentity;\n        MergeData = mergeData;\n        MergeOperator = mergeOpeator;\n        Operate = operate;\n    }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    private void Build()\n    {\n        Height = 1;\n        LeafCount = 1;\n        while (LeafCount < Size) { Height++; LeafCount <<= 1; }\n        Operators = new OperatorT[LeafCount << 1];\n        for (int i = 0; i < Operators.Length; i++) Operators[i] = OperatorIdentity;\n        Data = new DataT[LeafCount << 1];\n    }\n    #endregion\n\n    public DataT this[int index]\n    {\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        get { Propagate(index + LeafCount); return Reflect(index); }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        set { Propagate(index += LeafCount); Data[index] = value; Operators[index] = OperatorIdentity; Calculate(index, index); }\n    }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public void Update(int l, int r, OperatorT x)\n    {\n        l += LeafCount;\n        r += LeafCount;\n        int origL = l, origR = r;\n        Propagate(l, r);\n        while (l <= r)\n        {\n            if ((l & 1) == 1) Operators[l] = MergeOperator(Operators[l], x);\n            if ((r & 1) == 0) Operators[r] = MergeOperator(Operators[r], x);\n            l = (l + 1) >> 1; r = (r - 1) >> 1;\n        }\n        Calculate(origL, origR);\n    }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public DataT Query(int l, int r)\n    {\n        l += LeafCount;\n        r += LeafCount;\n        DataT lRes = DataIdentity, rRes = DataIdentity;\n        Propagate(l, r);\n        while (l <= r)\n        {\n            if ((l & 1) == 1) lRes = MergeData(lRes, Reflect(l));\n            if ((r & 1) == 0) rRes = MergeData(Reflect(r), rRes);\n            l = (l + 1) >> 1; r = (r - 1) >> 1;\n        }\n        return MergeData(lRes, rRes);\n    }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    private void Propagate(int ind) { for (int i = Height - 1; i >= 1; i--) { Eval(ind >> i); } return; }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    private void Propagate(int l, int r)\n    {\n        if (l == r) { Propagate(l); return; }\n        int xor = l ^ r, i = Height - 1;\n        for (; (xor >> i) == 0; i--) { Eval(l >> i); }\n        for (; i >= 1; i--) { Eval(l >> i); Eval(r >> i); }\n    }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    private DataT Reflect(int ind) { return Operate(Data[ind], Operators[ind]); }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    private void Eval(int ind)\n    {\n        int l = ind << 1, r = ind << 1 | 1;\n        Operators[l] = MergeOperator(Operators[l], Operators[ind]);\n        Operators[r] = MergeOperator(Operators[r], Operators[ind]);\n        Data[ind] = Reflect(ind);\n        Operators[ind] = OperatorIdentity;\n    }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    private void Calculate(int l, int r)\n    {\n        var xor = l ^ r;\n        while (xor > 1) { xor >>= 1; l >>= 1; r >>= 1; Data[l] = MergeData(Reflect(l << 1), Reflect((l << 1) | 1)); Data[r] = MergeData(Reflect(r << 1), Reflect((r << 1) | 1)); }\n        while (l > 1) { l >>= 1; Data[l] = MergeData(Reflect(l << 1), Reflect((l << 1) | 1)); }\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int N = cin.nextint;\n        int Q = cin.nextint;\n        var S = new LazySegtree<int, int>(N, (x, y) => x + y, (x, y, len) => y * len, (x, y) => y, 0);\n        for (int i = 0; i < Q; i++)\n        {\n            int com = cin.nextint;\n            if (com == 0)\n            {\n                S.Update(cin.nextint, cin.nextint, cin.nextint);\n            }\n            else if (com == 1)\n            {\n                WriteLine(S[cin.nextint, cin.nextint]);\n            }\n        }\n    }\n\n}\n\n/// <OriginalAuthor>riantkb</OriginalAuthor>\nclass LazySegtree<T, U>\n{\n    readonly int n;\n    T[] data;\n    U[] lazy;\n    readonly bool[] is_lazy;\n    readonly Func<T, T, T> calc;\n    readonly Func<T, U, int, T> apply;\n    readonly Func<U, U, U> merge;\n    readonly T ex_data;\n\n    /// <summary>\n    /// 遅延セグメントツリーの構築\n    /// </summary>\n    /// <param name=\"m\">要素数</param>\n    /// <param name=\"calc\">要素のマージ</param>\n    /// <param name=\"apply\">要素に作用素を作用</param>\n    /// <param name=\"merge\">作用素のマージ</param>\n    /// <param name=\"ex_data\">単位元</param>\n    public LazySegtree(int m, Func<T, T, T> calc, Func<T, U, int, T> apply, Func<U, U, U> merge, T ex_data)\n    {\n        this.calc = calc;\n        this.apply = apply;\n        this.merge = merge;\n        this.ex_data = ex_data;\n        n = 1;\n        while (n < m) n <<= 1;\n        data = new T[n * 2 - 1];\n        lazy = new U[n * 2 - 1];\n        is_lazy = new bool[n * 2 - 1];\n        for (int i = 0; i < data.Length; i++) data[i] = ex_data;\n    }\n    public LazySegtree(int m, Func<T, T, T> calc, Func<T, U, int, T> apply, Func<U, U, U> merge, T ex_data, T ini) : this(m, calc, apply, merge, ex_data)\n    {\n        for (int i = 0; i < m; i++) data[i + n - 1] = ini;\n        for (int i = n - 2; i >= 0; i--) data[i] = calc(data[i * 2 + 1], data[i * 2 + 2]);\n    }\n    public LazySegtree(int m, Func<T, T, T> calc, Func<T, U, int, T> apply, Func<U, U, U> merge, T ex_data, IList<T> ini) : this(m, calc, apply, merge, ex_data)\n    {\n        for (int i = 0; i < m; i++) data[i + n - 1] = ini[i];\n        for (int i = n - 2; i >= 0; i--) data[i] = calc(data[i * 2 + 1], data[i * 2 + 2]);\n    }\n    void assign_lazy(int k, U x)\n    {\n        if (k >= lazy.Length) return;\n        if (is_lazy[k]) lazy[k] = merge(lazy[k], x);\n        else\n        {\n            is_lazy[k] = true;\n            lazy[k] = x;\n        }\n    }\n    void eval(int k, int len)\n    {\n        if (!is_lazy[k]) return;\n        assign_lazy(k * 2 + 1, lazy[k]);\n        assign_lazy(k * 2 + 2, lazy[k]);\n        data[k] = apply(data[k], lazy[k], len);\n        is_lazy[k] = false;\n    }\n    T update(int s, int t, U x, int k, int l, int r)\n    {\n        eval(k, r - l);\n        if (r <= s || t <= l) return data[k];\n        if (s <= l && r <= t)\n        {\n            assign_lazy(k, x);\n            return apply(data[k], lazy[k], r - l);\n        }\n        return data[k] = calc(update(s, t, x, k * 2 + 1, l, (l + r) / 2),\n                              update(s, t, x, k * 2 + 2, (l + r) / 2, r));\n    }\n    T run(int s, int t, int k, int l, int r)\n    {\n        eval(k, r - l);\n        if (r <= s || t <= l) return ex_data;\n        if (s <= l && r <= t) return data[k];\n        return calc(run(s, t, k * 2 + 1, l, (l + r) / 2),\n                    run(s, t, k * 2 + 2, (l + r) / 2, r));\n    }\n\n    /// <summary>update [s, t]</summary>\n    public void Update(int s, int t, U x) { t++; update(s, t, x, 0, 0, n); }\n    /// <summary>return node[s, t]</summary>\n    public T this[int s, int t] => Run(s, t);\n    T Run(int s, int t) { t++; return run(s, t, 0, 0, n); }\n}\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Numerics;\nusing static System.Console;\nusing static System.Math;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new System.IO.StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        var N = FastIO.Int();\n        var Q = FastIO.Int();\n        var d = new SplayTree<long, int>((x, y) => x + y, (x, y, s) => y == 1001 ? x : y * s, (x, y) => y == 1001 ? x : y, 0, 1001);\n        d.Init(N);\n        for (int i = 0; i < Q; i++)\n        {\n            if (FastIO.Int() == 0)\n            {\n                var s = FastIO.Int();\n                var t = FastIO.Int() + 1;\n                var x = FastIO.Int();\n                d.Update(s, t, x);\n            }\n            else\n            {\n                var s = FastIO.Int();\n                var t = FastIO.Int() + 1;\n                WriteLine(d.Query(s, t));\n            }\n        }\n        Out.Flush();\n    }\n}\n\npublic static class FastIO\n{\n    static System.IO.Stream str = System.Console.OpenStandardInput();\n    const int size = 1024;\n    static byte[] buffer = new byte[size];\n    static int ptr;\n    static int len;\n\n    static byte Read()\n    {\n        if (ptr == len)\n        {\n            len = str.Read(buffer, 0, size);\n            if (len == 0) return 0;\n            ptr = 0;\n        }\n        return buffer[ptr++];\n    }\n\n    public static int Int()\n    {\n        var c = Read();\n        while (c < 0x21)\n        {\n            c = Read();\n        }\n        var n = false;\n        if (c == '-')\n        {\n            n = true;\n            c = Read();\n        }\n        var ret = 0;\n        while (c > 0x20)\n        {\n            ret = ret * 10 + c - '0';\n            c = Read();\n        }\n        return n ? -ret : ret;\n    }\n\n    public static long Long()\n    {\n        var c = Read();\n        while (c < 0x21)\n        {\n            c = Read();\n        }\n        var n = false;\n        if (c == '-')\n        {\n            n = true;\n            c = Read();\n        }\n        var ret = 0L;\n        while (c > 0x20)\n        {\n            ret = ret * 10 + c - '0';\n            c = Read();\n        }\n        return n ? -ret : ret;\n    }\n}\n\npublic class SplayTree<T, E>\n{\n    class Node\n    {\n        public T value;\n        public int size;\n        public T acc;\n        public E lazy;\n        public bool rev;\n        public Node l;\n        public Node r;\n    }\n\n    Node root;\n    Func<T, T, T> F;\n    Func<T, E, int, T> G;\n    Func<E, E, E> H;\n    T TI;\n    E EI;\n    int count;\n    public int Count => count;\n\n    public SplayTree(Func<T, T, T> f, Func<T, E, int, T> g, Func<E, E, E> h, T ti, E ei)\n    {\n        F = f;\n        G = g;\n        H = h;\n        TI = ti;\n        EI = ei;\n    }\n\n    public void Init(int length)\n    {\n        DFSL(ref root, 0, length);\n        count = length;\n    }\n\n    void DFSL(ref Node p, int l, int r)\n    {\n        if (l == r) return;\n        var k = (l + r) / 2;\n        p = new Node { value = TI, size = r - l, acc = TI, lazy = EI };\n        DFSL(ref p.l, l, k);\n        DFSL(ref p.r, k + 1, r);\n    }\n\n    public void Init(int length, T v)\n    {\n        DFSA(ref root, 0, length, v);\n        count = length;\n    }\n\n    void DFSA(ref Node p, int l, int r, T v)\n    {\n        if (l == r) return;\n        var k = (l + r) / 2;\n        p = new Node { value = v, size = r - l, acc = TI, lazy = EI };\n        DFSA(ref p.l, l, k, v);\n        DFSA(ref p.r, k + 1, r, v);\n        UpdateAcc(p);\n    }\n\n    public void Init(T[] array)\n    {\n        DFS(ref root, 0, array.Length, array);\n        count = array.Length;\n    }\n\n    void DFS(ref Node p, int l, int r, T[] a)\n    {\n        if (l == r) return;\n        var k = (l + r) / 2;\n        p = new Node { value = a[k], size = r - l, acc = TI, lazy = EI };\n        DFS(ref p.l, l, k, a);\n        DFS(ref p.r, k + 1, r, a);\n        UpdateAcc(p);\n    }\n\n    int Size(Node t) => t != null ? t.size : 0;\n\n    void UpdateSize(Node t) => t.size = Size(t.l) + Size(t.r) + 1;\n\n    T Acc(Node t) => t != null ? t.acc : TI;\n\n    void UpdateAcc(Node t) => t.acc = F(F(Acc(t.l), t.value), Acc(t.r));\n\n    void PushUp(Node t)\n    {\n        if (t != null)\n        {\n            UpdateAcc(t);\n            UpdateSize(t);\n        }\n    }\n\n    void Swap(ref Node l, ref Node r)\n    {\n        var t = l;\n        l = r;\n        r = t;\n    }\n\n    void PushDown(Node t)\n    {\n        if (t == null) return;\n        if (t.rev)\n        {\n            t.rev = false;\n            Swap(ref t.l, ref t.r);\n            if (t.l != null) t.l.rev = !t.l.rev;\n            if (t.r != null) t.r.rev = !t.r.rev;\n        }\n        //if (t.lazy != EI)\n        {\n            if (t.l != null)\n            {\n                t.l.lazy = H(t.l.lazy, t.lazy);\n                t.l.acc = G(t.l.acc, t.lazy, Size(t.l));\n            }\n            if (t.r != null)\n            {\n                t.r.lazy = H(t.r.lazy, t.lazy);\n                t.r.acc = G(t.r.acc, t.lazy, Size(t.r));\n            }\n            t.value = G(t.value, t.lazy, 1);\n            t.lazy = EI;\n        }\n    }\n\n    void Splay(ref Node n, int k)\n    {\n        Node l = null;\n        Node r = null;\n        var p = n;\n\n        while (true)\n        {\n            PushDown(p);\n            var i = Size(p.l);\n            if (k == i) break;\n            if (k > i)\n            {\n                var pr = p.r;\n                var ii = i + Size(pr.l) + 1;\n                if (ii == k)\n                {\n                    p.r = l;\n                    l = p;\n                    p = pr;\n\n                    k -= i + 1;\n                }\n                else if (k > ii)\n                {\n                    PushDown(pr);\n\n                    p.r = pr.l;\n                    PushUp(p);\n                    pr.l = p;\n                    p = pr.r;\n                    pr.r = l;\n                    l = pr;\n\n                    k -= ii + 1;\n                }\n                else\n                {\n                    PushDown(pr);\n\n                    p.r = l;\n                    l = p;\n                    p = pr.l;\n                    pr.l = r;\n                    r = pr;\n\n                    k -= i + 1;\n                }\n            }\n            else// k < i\n            {\n                var pl = p.l;\n                var ii = i - Size(pl.r) - 1;\n                if (ii == k)\n                {\n                    p.l = r;\n                    r = p;\n                    p = pl;\n                }\n                else if (k > ii)\n                {\n                    PushDown(pl);\n\n                    p.l = r;\n                    r = p;\n                    p = pl.r;\n                    pl.r = l;\n                    l = pl;\n\n                    k -= ii + 1;\n                }\n                else\n                {\n                    PushDown(pl);\n\n                    p.l = pl.r;\n                    PushUp(p);\n                    pl.r = p;\n                    p = pl.l;\n                    pl.l = r;\n                    r = pl;\n                }\n            }\n        }\n\n        var ll = l;\n        var rr = r;\n        {\n            Node s = null;\n            while (l != null)\n            {\n                Node t = l.r;\n                l.r = s;\n                if (s == null)\n                {\n                    //l.acc = F(F(Acc(l.l), l.value), p.l == null ? TI : G(p.l.acc, p.l.lazy, p.l.size));// \n                    l.acc = F(F(Acc(l.l), l.value), p.l == null ? TI : p.l.acc);//\n                    l.size = Size(l.l) + Size(p.l) + 1;\n                }\n                else PushUp(l);\n                s = l;\n                l = t;\n            }\n            l = s;\n        }\n        {\n            Node s = null;\n            while (r != null)\n            {\n                Node t = r.l;\n                r.l = s;\n                if (s == null)\n                {\n                    //r.acc = F(F(p.r == null ? TI : G(p.r.acc, p.r.lazy, p.r.size), r.value), Acc(r.r));//\n                    r.acc = F(F(p.r == null ? TI : p.r.acc, r.value), Acc(r.r));//\n                    r.size = Size(r.r) + Size(p.r) + 1;\n                }\n                else PushUp(r);\n                s = r;\n                r = t;\n            }\n            r = s;\n        }\n        if (ll == null) l = p.l;\n        else ll.r = p.l;\n        if (rr == null) r = p.r;\n        else rr.l = p.r;\n        p.l = l;\n        p.r = r;\n        PushUp(p);\n        n = p;\n    }\n\n    void Merge(out Node t, Node l, Node r)\n    {\n        if (l == null) t = r;\n        else if (r == null) t = l;\n        else\n        {\n            Splay(ref l, l.size - 1);\n            l.r = r;\n            PushUp(l);\n            t = l;\n        }\n    }\n\n    void Split(Node t, int k, out Node l, out Node r)\n    {\n        if (t == null)\n        {\n            l = r = null;\n            return;\n        }\n        if (k == count)\n        {\n            l = t;\n            r = null;\n            return;\n        }\n        Splay(ref t, k);\n        l = t.l;\n        r = t;\n        r.l = null;\n        PushUp(r);\n    }\n\n    public void Insert(int index, T item)\n    {\n        Node l, r;\n        Split(root, index, out l, out r);\n        var n = new Node { value = item, size = 1, acc = TI, lazy = EI };\n        Merge(out l, l, n);\n        Merge(out root, l, r);\n        count++;\n    }\n\n    public void RemoveAt(int index)\n    {\n        Node l, r, _;\n        Split(root, index + 1, out l, out r);\n        Split(l, index, out l, out _);\n        Merge(out root, l, r);\n        count--;\n    }\n\n    public void RemoveRange(int index, int count)\n    {\n        Node l, r, _;\n        Split(root, index + count, out l, out r);\n        Split(l, index, out l, out _);\n        Merge(out root, l, r);\n        this.count -= count;\n    }\n\n    public void Update(int l, int r, E v)\n    {\n        Node t1, t2, t3;\n        Split(root, r, out t2, out t3);\n        Split(t2, l, out t1, out t2);\n        t2.lazy = H(t2.lazy, v);\n        t2.acc = G(t2.acc, v, Size(t2));\n        PushDown(t2);\n        t2.l = t1;\n        PushUp(t2);\n        if (t3 == null)\n        {\n            root = t2;\n        }\n        else\n        {\n            t3.l = t2;\n            PushUp(t3);\n            root = t3;\n        }\n    }\n\n    public T Query(int l, int r)\n    {\n        Node t1, t2, t3;\n        Split(root, r, out t2, out t3);\n        Split(t2, l, out t1, out t2);\n        var ret = t2.acc;\n        t2.l = t1;\n        PushUp(t2);\n        if (t3 == null)\n        {\n            root = t2;\n        }\n        else\n        {\n            t3.l = t2;\n            PushUp(t3);\n            root = t3;\n        }\n        return ret;\n    }\n\n    public void Reverse(int l, int r)\n    {\n        Node t1, t2, t3;\n        Split(root, r, out t2, out t3);\n        Split(t2, l, out t1, out t2);\n        PushDown(t2);\n        t2.l = t1;\n        PushUp(t2);\n        if (t3 == null)\n        {\n            root = t2;\n        }\n        else\n        {\n            t3.l = t2;\n            PushUp(t3);\n            root = t3;\n        }\n    }\n\n    public T Get(int index)\n    {\n        Splay(ref root, index);\n        return root.value;\n    }\n\n    public void Clear()\n    {\n        root = null;\n        count = 0;\n    }\n\n    public void Rotate(int l, int m, int r)\n    {\n        Reverse(l, r);\n        Reverse(l, l + r - m);\n        Reverse(l + r - m, r);\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        int N = cin.nextint;\n        int Q = cin.nextint;\n        var S = new LazySegtree<int, int>(N, (x, y) => x + y, (x, y, len) => y, (x, y) => y, 0);\n        for (int i = 0; i < Q; i++)\n        {\n            int com = cin.nextint;\n            if (com == 0)\n            {\n                S.Update(cin.nextint, cin.nextint, cin.nextint);\n            }\n            else if (com == 1)\n            {\n                WriteLine(S[cin.nextint, cin.nextint]);\n            }\n        }\n    }\n\n}\n\n/// <OriginalAuthor>riantkb</OriginalAuthor>\nclass LazySegtree<T, U>\n{\n    readonly int n;\n    T[] data;\n    U[] lazy;\n    readonly bool[] is_lazy;\n    readonly Func<T, T, T> calc;\n    readonly Func<T, U, int, T> apply;\n    readonly Func<U, U, U> merge;\n    readonly T ex_data;\n\n    /// <summary>\n    /// 遅延セグメントツリーの構築\n    /// </summary>\n    /// <param name=\"m\">要素数</param>\n    /// <param name=\"calc\">要素のマージ</param>\n    /// <param name=\"apply\">要素に作用素を作用</param>\n    /// <param name=\"merge\">作用素のマージ</param>\n    /// <param name=\"ex_data\">単位元</param>\n    public LazySegtree(int m, Func<T, T, T> calc, Func<T, U, int, T> apply, Func<U, U, U> merge, T ex_data)\n    {\n        this.calc = calc;\n        this.apply = apply;\n        this.merge = merge;\n        this.ex_data = ex_data;\n        n = 1;\n        while (n < m) n <<= 1;\n        data = new T[n * 2 - 1];\n        lazy = new U[n * 2 - 1];\n        is_lazy = new bool[n * 2 - 1];\n        for (int i = 0; i < data.Length; i++) data[i] = ex_data;\n    }\n    public LazySegtree(int m, Func<T, T, T> calc, Func<T, U, int, T> apply, Func<U, U, U> merge, T ex_data, T ini) : this(m, calc, apply, merge, ex_data)\n    {\n        for (int i = 0; i < m; i++) data[i + n - 1] = ini;\n        for (int i = n - 2; i >= 0; i--) data[i] = calc(data[i * 2 + 1], data[i * 2 + 2]);\n    }\n    public LazySegtree(int m, Func<T, T, T> calc, Func<T, U, int, T> apply, Func<U, U, U> merge, T ex_data, IList<T> ini) : this(m, calc, apply, merge, ex_data)\n    {\n        for (int i = 0; i < m; i++) data[i + n - 1] = ini[i];\n        for (int i = n - 2; i >= 0; i--) data[i] = calc(data[i * 2 + 1], data[i * 2 + 2]);\n    }\n    void assign_lazy(int k, U x)\n    {\n        if (k >= lazy.Length) return;\n        if (is_lazy[k]) lazy[k] = merge(lazy[k], x);\n        else\n        {\n            is_lazy[k] = true;\n            lazy[k] = x;\n        }\n    }\n    void eval(int k, int len)\n    {\n        if (!is_lazy[k]) return;\n        assign_lazy(k * 2 + 1, lazy[k]);\n        assign_lazy(k * 2 + 2, lazy[k]);\n        data[k] = apply(data[k], lazy[k], len);\n        is_lazy[k] = false;\n    }\n    T update(int s, int t, U x, int k, int l, int r)\n    {\n        eval(k, r - l);\n        if (r <= s || t <= l) return data[k];\n        if (s <= l && r <= t)\n        {\n            assign_lazy(k, x);\n            return apply(data[k], lazy[k], r - l);\n        }\n        return data[k] = calc(update(s, t, x, k * 2 + 1, l, (l + r) / 2),\n                              update(s, t, x, k * 2 + 2, (l + r) / 2, r));\n    }\n    T run(int s, int t, int k, int l, int r)\n    {\n        eval(k, r - l);\n        if (r <= s || t <= l) return ex_data;\n        if (s <= l && r <= t) return data[k];\n        return calc(run(s, t, k * 2 + 1, l, (l + r) / 2),\n                    run(s, t, k * 2 + 2, (l + r) / 2, r));\n    }\n\n    /// <summary>update [s, t]</summary>\n    public void Update(int s, int t, U x) { t++; update(s, t, x, 0, 0, n); }\n    /// <summary>return node[s, t]</summary>\n    public T this[int s, int t] => Run(s, t);\n    T Run(int s, int t) { t++; return run(s, t, 0, 0, n); }\n}\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;//リストの使用\nusing System.Collections.Generic;\nclass Program\n{\nstatic string[] input = Console.ReadLine().Split(' ');\nstatic long n = long.Parse(input[0]);\nstatic long q = long.Parse(input[1]);\nstatic long[] nums = new long[600*600];\nstatic long[] numSets = new long[600];//600*600に分割\nstatic long[] numSetsSub = new long[600];\n\n\tstatic void Main()\n\t{\n    AreaChangeSumGetReady();\n      //区間以上以下の値を全てchangeNumに変更し、区間以上以下の和を求める初期値前処理。\n    //AreaChangeMinGetReady();\n      //区間以上以下の値を全てchangeNumに変更し、区間以上以下の最小値を求める初期値前処理。\n    //AreaChangePointGetReady();\n      //区間以上以下の値を全てchangeNumに変更し、ある１点の値を求める初期値前処理。\n    //AreaAddSumGetReady();\n      //区間以上以下の値に全てchangeNum加算し、区間以上以下の和を求める初期値前処理。\n    //AreaAddMinGetReady();\n      //区間以上以下の値に全てchangeNum加算し、区間以上以下の最小値を求める初期値前処理。\n    for(long question = 0; question < q; question++)\n    {\n      string[] inputq = Console.ReadLine().Split(' ');\n      long howNum = long.Parse(inputq[0]);\n      \n      if(howNum == 0)//書き換え\n      {\n        int leftNum = int.Parse(inputq[1]);\n        int rightNum = int.Parse(inputq[2]);\n        long changeNum = long.Parse(inputq[3]);\n        AreaChangeSumGet(leftNum,rightNum,changeNum);//変更処理の選択\n      }\n      if(howNum == 1)//値を求める\n      {\n        int leftNum = int.Parse(inputq[1]);\n        int rightNum = int.Parse(inputq[2]);\n        Console.WriteLine(AreaChangeSumGetAnswer(leftNum, rightNum));//取得（出力）処理の選択\n      }\n    }\n\t}\n\n  static void AreaChangeSumGetReady()\n  {//区間以上以下の値を全てchangeNumに変更し、区間以上以下の和を求める初期値前処理。\n  for(int i = 0; i < 600*600; i++)\n  {\n    nums[i] = 0;\n  }\n  for(int i = 0; i < 600; i++)\n  {\n    numSetsSub[i] = long.MinValue/2;\n    for(int j = 0; j < 600; j++)\n    {\n      numSets[i] += nums[600*i+j];//区間の和\n    }\n  }\n  }\n\n  static void AreaChangeMinGetReady()\n  {//区間以上以下の値を全てchangeNumに変更し、区間以上以下の最小値を求める初期値前処理。\n    for(int i = 0; i < 600*600; i++)\n    {\n      nums[i] = 2147483647;\n    }\n    for(int i = 0; i < 600; i++)\n    {\n      numSets[i] = 2147483647;\n      numSetsSub[i] = long.MinValue/2;\n    } \n  }\n\n  static void AreaChangePointGetReady()\n  {//区間以上以下の値を全てchangeNumに変更し、ある１点の値を求める初期値前処理。\n    AreaChangeMinGetReady();\n  }\n\n  static void AreaAddSumGetReady()\n  {//区間以上以下の値に全てchangeNum加算し、区間以上以下の和を求める初期値前処理。\n    for(int i = 0; i < 600*600; i++)\n    {\n      nums[i] = 0;\n    }\n    for(int i = 0; i < 600; i++)\n    {\n      numSets[i] = 0;\n      for(int j = 0; j < 600; j++)\n      {\n        numSetsSub[i] += nums[600*i+j];//区間の和\n      }\n    }\n  }\n\n  static void AreaAddMinGetReady()\n  {//区間以上以下の値に全てchangeNum加算し、区間以上以下の最小値を求める初期値前処理。\n    for(int i = 0; i < 600*600; i++)\n    {\n      nums[i] = 0;\n    }\n    for(int i = 0; i < 600; i++)\n    {\n      numSets[i] = 0;\n      long min = long.MaxValue/2;\n      for(int j = 0; j < 600; j++)\n      {\n        min = Math.Min(min, nums[600*i+j]);\n      }\n      numSetsSub[i] = min;//各区間の最小値\n    }\n  }\n\n  static void AreaChangeSumGet(int leftNum, int rightNum, long changeNum)\n  {//区間以上以下の値を全てchangeNumに変更し、区間以上以下の和を求める。入力側\n    int leftPosition = WherePosition(leftNum);\n    int rightPosition = WherePosition(rightNum);\n\n    NumberApply(leftNum, rightNum);\n\n    if(leftPosition == rightPosition)//左右が同じ分類のとき\n    {\n      for(long i = leftNum; i <= rightNum; i++)\n      {\n        nums[i] = changeNum;\n      }\n      long sum = 0;\n      for(long i = 0; i < 600; i++)//区間内全てを見る\n      {\n        sum += nums[leftPosition*600+i];\n      }\n      numSets[leftPosition] = sum;\n    }else\n    {\n      for(long i = leftNum; i < 600*(leftPosition+1); i++)//左区間内（左端より右だけ見る）\n      {\n        nums[i] = changeNum;\n      }\n      for(long i = 600*rightPosition; i <= rightNum; i++)//右区間内\n      {\n        nums[i] = changeNum;\n      }\n      long sumL = 0;\n      long sumR = 0;\n      for(long i = 0; i < 600; i++)//区間内全てを見る\n      {\n        sumL += nums[leftPosition*600+i];\n        sumR += nums[rightPosition*600+i];\n      }\n      numSets[leftPosition] = sumL;\n      numSets[rightPosition] = sumR;\n      \n      for(int i = leftPosition+1; i < rightPosition; i++)//見ていない区間内\n      {\n        numSetsSub[i] = changeNum;\n        numSets[i] = changeNum*600;\n      }\n    }\n  }\n\n  static void AreaChangeMinGet(int leftNum, int rightNum, long changeNum)\n  {//区間以上以下の値を全てchangeNumに変更し、区間以上以下の最小値を求める。入力側\n    int leftPosition = WherePosition(leftNum);\n    int rightPosition = WherePosition(rightNum);\n\n    NumberApply(leftNum, rightNum);\n\n    if(leftPosition == rightPosition)//左右が同じ分類のとき\n    {\n      for(long i = leftNum; i <= rightNum; i++)\n      {\n        nums[i] = changeNum;\n      }\n      long minMemo = long.MaxValue/2;\n      for(long i = 0; i < 600; i++)//区間内全てを見る\n      {\n        minMemo = Math.Min(minMemo, nums[leftPosition*600+i]);\n      }\n      numSets[leftPosition] = minMemo;\n    }else\n    {\n      for(long i = leftNum; i < 600*(leftPosition+1); i++)//左区間内（左端より右だけ見る）\n      {\n        nums[i] = changeNum;\n      }\n      for(long i = 600*rightPosition; i <= rightNum; i++)//右区間内\n      {\n        nums[i] = changeNum;\n      }\n      long minMemoL = long.MaxValue/2;\n      long minMemoR = long.MaxValue/2;\n      for(long i = 0; i < 600; i++)//区間内全てを見る\n      {\n        minMemoL = Math.Min(minMemoL, nums[leftPosition*600+i]);\n        minMemoR = Math.Min(minMemoR, nums[rightPosition*600+i]);\n      }\n      numSets[leftPosition] = minMemoL;\n      numSets[rightPosition] = minMemoR;\n      \n      for(int i = leftPosition+1; i < rightPosition; i++)//見ていない区間内\n      {\n        numSetsSub[i] = changeNum;\n        numSets[i] = changeNum;\n      }\n    }\n  }\n\n  static void AreaChangePointGet(int leftNum, int rightNum, long changeNum)\n  {//区間以上以下の値を全てchangeNumに変更し、ある１点の値を求める。入力側\n    AreaChangeMinGet(leftNum, rightNum, changeNum);\n  }\n\n  static void AreaAddSumGet(int leftNum, int rightNum, long changeNum)\n  {//区間以上以下の値に全てchangeNum加算し、区間以上以下の和を求める。入力側\n    int leftPosition = WherePosition(leftNum);\n    int rightPosition = WherePosition(rightNum);\n\n    if(leftPosition == rightPosition)//左右が同じ分類のとき\n    {\n      for(long i = leftNum; i <= rightNum; i++)\n      {\n        nums[i] += changeNum;\n        numSetsSub[leftPosition] += changeNum;\n      }\n    }else\n    {\n      for(long i = leftNum; i < 600*(leftPosition+1); i++)//左区間内（左端より右だけ見る）\n      {\n        nums[i] += changeNum;\n        numSetsSub[leftPosition] += changeNum;\n      }\n      for(long i = 600*rightPosition; i <= rightNum; i++)//右区間内\n      {\n        nums[i] += changeNum;\n        numSetsSub[rightPosition] += changeNum;\n      }\n      for(int i = leftPosition+1; i < rightPosition; i++)//見ていない区間内\n      {\n        numSetsSub[i] += changeNum*600;\n        numSets[i] += changeNum;\n      }\n    }\n  }\n\n  static void AreaAddMinGet(int leftNum, int rightNum, long changeNum)\n  {//区間以上以下の値に全てchangeNum加算し、区間以上以下の最小値を求める。入力側\n    int leftPosition = WherePosition(leftNum);\n    int rightPosition = WherePosition(rightNum);\n\n    NumberAddMin(leftNum, rightNum);\n\n    if(leftPosition == rightPosition)//左右が同じ分類のとき\n    {\n      for(long i = leftNum; i <= rightNum; i++)\n      {\n        nums[i] += changeNum;\n      }\n    NumberAddMin(leftNum);\n  }else\n  {\n    for(long i = leftNum; i < 600*(leftPosition+1); i++)//左区間内（左端より右だけ見る）\n    {\n      nums[i] += changeNum;\n    }\n    for(long i = 600*rightPosition; i <= rightNum; i++)//右区間内\n    {\n      nums[i] += changeNum;\n    }\n    NumberAddMin(leftNum,rightNum);\n    \n    for(int i = leftPosition+1; i < rightPosition; i++)//見ていない区間内\n    {\n      numSetsSub[i] += changeNum;\n      numSets[i] += changeNum;\n    }\n  }\n    \n  }\n\n  static long AreaChangeSumGetAnswer(int leftNum, int rightNum)\n  {//区間以上以下の値に全てchangeNum加算し、区間以上以下の和を求める。出力側\n    long sum = 0;\n    int leftPosition = WherePosition(leftNum);\n    int rightPosition = WherePosition(rightNum);\n    NumberApply(leftNum, rightNum);\n\n    if(leftPosition == rightPosition)\n    {\n      for(long i = leftNum; i <= rightNum; i++)//左右が同じ分類のとき\n      {\n        sum += nums[i];\n      }\n    }else\n    {\n      for(long i = leftNum; i < 600*(leftPosition+1); i++)//左区間内（左端より右だけ見る）\n      {\n        sum += nums[i];\n      }\n      for(long i = 600*rightPosition; i <= rightNum; i++)//右区間内\n      {\n        sum += nums[i];\n      }\n      for(long i = leftPosition+1; i < rightPosition; i++)//見ていない区間内\n      {\n        sum += numSets[i];\n      }\n    }\n    return sum;\n  }\n\n  static long AreaChangeMinGetAnswer(int leftNum, int rightNum)\n  {//区間以上以下の値を全てchangeNumに変更し、区間以上以下の最小値を求める。出力側\n    long minMemo = long.MaxValue/2;\n    int leftPosition = WherePosition(leftNum);\n    int rightPosition = WherePosition(rightNum);\n\n    NumberApply(leftNum, rightNum);\n\n    if(leftPosition == rightPosition)\n    {\n      for(long i = leftNum; i <= rightNum; i++)//左右が同じ分類のとき\n      {\n        minMemo = Math.Min(minMemo, nums[i]);\n      }\n    }else\n    {\n      for(long i = leftNum; i < 600*(leftPosition+1); i++)//左区間内（左端より右だけ見る）\n      {\n        minMemo = Math.Min(minMemo, nums[i]);\n      }\n      for(long i = 600*rightPosition; i <= rightNum; i++)//右区間内\n      {\n        minMemo = Math.Min(minMemo, nums[i]);\n      }\n      for(long i = leftPosition+1; i < rightPosition; i++)//見ていない区間内\n      {\n        minMemo = Math.Min(minMemo, numSets[i]);\n      }\n    }\n    return minMemo;\n  }\n\n  static long AreaChangePointGetAnswer(int pointNum)\n  {//区間以上以下の値を全てchangeNumに変更し、ある１点の値を求める。出力側\n    int numPosition = WherePosition(pointNum);\n\n    NumberApply(pointNum);\n\n    return nums[pointNum];\n  }\n\n  static long AreaAddSumGetAnswer(int leftNum, int rightNum)\n  {//区間以上以下の値に全てchangeNum加算し、区間以上以下の和を求める。出力側\n    long sum = 0;\n    int leftPosition = WherePosition(leftNum);\n    int rightPosition = WherePosition(rightNum);\n\n    if(leftPosition == rightPosition)\n    {\n      for(long i = leftNum; i <= rightNum; i++)//左右が同じ分類のとき\n      {\n        sum += numSets[leftPosition] + nums[i];\n      }\n    }else\n    {\n      for(long i = leftNum; i < 600*(leftPosition+1); i++)//左区間内（左端より右だけ見る）\n      {\n        sum += numSets[leftPosition] + nums[i];\n      }\n      for(long i = 600*rightPosition; i <= rightNum; i++)//右区間内\n      {\n        sum += numSets[rightPosition] + nums[i];\n      }\n      for(long i = leftPosition+1; i < rightPosition; i++)//見ていない区間内\n      {\n        sum += numSetsSub[i];\n      }\n    }\n    return sum;\n  }\n\n  static long AreaAddMinGetAnswer(int leftNum, int rightNum)\n  {//区間以上以下の値に全てchangeNum加算し、区間以上以下の最小値を求める。出力側\n    int leftPosition = WherePosition(leftNum);\n    int rightPosition = WherePosition(rightNum);\n    long min = long.MaxValue/2;\n    \n    NumberAddMin(leftNum, rightNum);\n\n    if(leftPosition == rightPosition)\n    {\n      for(long i = leftNum; i <= rightNum; i++)//左右が同じ分類のとき\n      {\n        min = Math.Min(min, nums[i]);\n      }\n    }else\n    {\n      for(long i = leftNum; i < 600*(leftPosition+1); i++)//左区間内（左端より右だけ見る）\n      {\n        min = Math.Min(min, nums[i]);\n      }\n      for(long i = 600*rightPosition; i <= rightNum; i++)//右区間内\n      {\n        min = Math.Min(min, nums[i]);\n      }\n      for(long i = leftPosition+1; i < rightPosition; i++)//見ていない区間内\n      {\n        min = Math.Min(min, numSetsSub[i]);\n      }\n    }\n    return min;\n  }\n\n  static void NumberApply(int pointNum)\n  {//控え中の数を個々に割り当てる\n    int numPosition = WherePosition(pointNum);\n\n    if(numSetsSub[numPosition] != long.MinValue/2)\n    {\n      for(int i = 0; i < 600; i++)//区間内全てを見る\n      {\n        nums[numPosition*600+i] = numSetsSub[numPosition];\n      }\n      numSetsSub[numPosition] = long.MinValue/2;\n    }\n  }\n\n  static void NumberApply(int leftNum, int rightNum)\n  {\n    NumberApply(leftNum);\n    NumberApply(rightNum);\n  }\n\n  static void NumberAddMin(int pointNum)\n  {//控え中の数を個々に加算した後、最小値を求める\n    int numPosition = WherePosition(pointNum);\n\n    if(numSets[numPosition] != 0)\n    {\n      for(int i = 0; i < 600; i++)//区間内全てを見る\n      {\n        nums[numPosition*600+i] += numSets[numPosition];\n      }\n      numSets[numPosition] = 0;\n    }\n\n    long min = long.MaxValue/2;\n    for(int i = 0; i < 600; i++)\n    {\n      if(nums[numPosition*600+i] < min) min = nums[numPosition*600+i];\n    }\n\n    numSetsSub[numPosition] = min;\n  }\n\n  static void NumberAddMin(int leftNum, int rightNum)\n  {\n    NumberAddMin(leftNum);\n    NumberAddMin(rightNum);\n  }\n\n  static int WherePosition(int num)//左から何番目の分類に属するか\n  {\n    return num / 600;\n  }\n  \n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\n\nclass Program\n{\n\t/*\n\n・概要\n\t遅延評価を行い、必要なタイミングで一気に値を更新するLazySegmentTree。\n\n\tcf. セグメントツリーとは\n\t「完全二分木（全ての葉の深さが等しい木）によって実装された、区間を扱うのに適したデータ構造\n\t区間に対する操作を対数時間 O(log N) で行える」\n\n・使用法\n\t1. 問題に合わせ、コンストラクタの引数を設定（ラムダ式を使えば良い）\n\t「更新クエリと回答クエリの組み合わせ」によって引数が全く変わってくるので注意。\n\n\t（cf.「RAQ（更新）+ RMQ（回答）」などの基本的組み合わせについては、最下部にテンプレートを用意\n\t　→コピペして使ってね）\n\n\t（e.g.「RAQ（更新）+ RMQ（回答）」の場合\n\t\tFunc<long, long, long> fx = (x1,x2) => x1 + x2;\n\t\tFunc<long, long, long> fa = (x,m) => x + m;\n\t\tFunc<long, long, long> fm = (m1,m2) => m1 + m2;\n\t\tFunc<long, long, long> fp = (m,n) => m * n;\n\t\tlong init = 0;\n\t\tlong lazyInit = 0;）\n\n\t2. LazySegmentTreeクラスのオブジェクトを作成\n\t（e.g. LazySegmentTree st = new LazySegmentTree(N);）\n\n\t2. セグメントツリーの初期化（元の配列を渡す）\n\t（e.g. st.Initialize(arr);）\n\n\t--- 以下は、どの問題でもやることは同じ（更新 or 回答） ---\n\n\t3. 適宜、更新クエリに応答（閉区間[s,t]について、更新クエリに答える）\n\t（e.g. st.Update(s,t,x);）\n\n\t4. 適宜、回答クエリに応答（閉区間[s,t]について、回答クエリに答える）\n\t（e.g. long ans = st.GetAnswer(s,t);）\n\n\t*/\n\n\t//Main\n\tstatic void Main(string[] args)\n\t{\n\t\t//出力準備（AutoFlushを切る）\n\t\tvar sw = new StreamWriter(Console.OpenStandardOutput()){AutoFlush = false};\n\t\tConsole.SetOut(sw);\n\t\t//解答\n\t\tSolve();\n\t\t//出力終了\n\t\tConsole.Out.Flush();\n\t}\n\n\tstatic void Solve()\n\t{\n\t\t//読み込む\n\t\tstring[] S = Console.ReadLine().Split(' ');\n\t\t//要素数\n\t\tint N = int.Parse(S[0]);\n\t\t//クエリ数\n\t\tint Q = int.Parse(S[1]);\n\n\t\t//1. 問題に合わせ、コンストラクタの引数を設定（ラムダ式を使えば良い）\n\t\tFunc<long, long, long> fx = (x1,x2) => x1 + x2;\n\t\tFunc<long, long, long> fa = (x,m) => m;\n\t\tFunc<long, long, long> fm = (m1,m2) => m2;\n\t\tFunc<long, long, long> fp = (m,n) => m * n;\n\t\tlong init = 0;\n\t\tlong lazyInit = long.MaxValue;\n\n\t\t//2. LazySegmentTreeクラスのオブジェクトを作成（RAQ + RSQの場合の例）\n\t\t/*\n\t\t引数は順に、\n\t\t元の配列の要素数、関数4つ、二分木の初期値、遅延評価配列の初期値\n\t\t*/\n\t\tLazySegmentTree st = new LazySegmentTree(N,fx,fa,fm,fp,init,lazyInit);\n\n\t\t//初期状態の配列を作成\n\t\tlong[] arr = new long[N];\n\n\t\t//3. 配列の初期化（元の配列を渡す）\n\t\tst.Initialize(arr);\n\n\t\t//4.入力に応じて、更新 or 回答を行う\n\t\tfor(int i=0; i<Q; i++){\n\t\t\t//読み込む\n\t\t\tstring[] S1 = Console.ReadLine().Split(' ');\n\t\t\t//クエリの種類\n\t\t\tint com = int.Parse(S1[0]);\n\n\t\t\t//更新クエリの場合\n\t\t\tif(com == 0){\n\t\t\t\t//値の取得\n\t\t\t\tint s = int.Parse(S1[1]);\n\t\t\t\tint t = int.Parse(S1[2]);\n\t\t\t\tint x = int.Parse(S1[3]);\n\n\t\t\t\t//閉区間[s,t]について、更新クエリに答える\n\t\t\t\tst.Update(s,t,x);\n\t\t\t}\n\t\t\t//回答クエリの場合\n\t\t\telse{\n\t\t\t\t//値の取得\n\t\t\t\tint s = int.Parse(S1[1]);\n\t\t\t\tint t = int.Parse(S1[2]);\n\n\t\t\t\t//閉区間[s,t]について、回答クエリに答える\n\t\t\t\tlong ans = st.GetAnswer(s,t);\n\t\t\t\t//出力\n\t\t\t\tConsole.WriteLine(ans);\n\t\t\t}\n\n\t\t\t/*cf. debug用の、完全二分木出力メソッド\n\t\t\tst.DebugWrite();\n\t\t\t*/\n\t\t}\n\t}\n}\n\n\n//セグメントツリーのクラス\n/*\n配列の中身はlong確としておく。\n*/\nclass LazySegmentTree\n{\n\t/*\n\tメンバー変数\n\t*/\n\t//更新や取得で使用するメソッド（long引数2つで、long戻り値）\n\tprivate Func<long, long, long> fx;\n\tprivate Func<long, long, long> fa;\n\tprivate Func<long, long, long> fm;\n\tprivate Func<long, long, long> fp;\n\t//完全二分木の初期値（単位元）\n\tprivate long INIT;\n\t//遅延評価配列の初期値（単位元）\n\tprivate long lazyINIT;\n\t//葉の数（※「葉」とは、末端（最下部）のノードのこと。元の配列の各値 or 初期値を保持）\n\tprivate int leaf;\n\t//完全二分木の配列\n\tprivate long[] tree;\n\t//遅延評価用の配列（一時的に値を保存）\n\tprivate long[] lazy;\n\n\t/*\n\t（１）初期化\n\t*/\n\n\t//コンストラクタ\n\t/*\n\t引数は要素数、関数4つ、二分木の初期値、遅延評価配列の初期値\n\t*/\n\tpublic LazySegmentTree(int len, Func<long, long, long> f1, Func<long, long, long> f2,\n\tFunc<long, long, long> f3, Func<long, long, long> f4, long ex, long em){\n\t\t//完全二分木の要素数はn^2である必要\n\t\t/*\n\t\tn^2 >= lenとなるような最小のn^2（=x）を求める\n\t\t*/\n\t\tint x = 1;\n\t\twhile(len > x){\n\t\t\tx *= 2;\n\t\t}\n\t\tthis.leaf = x;\n\n\t\t//関数の設定\n\t\tthis.fx = f1;\n\t\tthis.fa = f2;\n\t\tthis.fm = f3;\n\t\tthis.fp = f4;\n\n\t\t//初期値の設定\n\t\tthis.INIT = ex;\n\t\tthis.lazyINIT = em;\n\n\t\t//treeの初期化\n\t\t//treeの要素数は、葉の数 * 2 - 1となる\n\t\tthis.tree = new long[2*x-1];\n\t\tfor(int i=0; i<2*x-1; i++){\n\t\t\tthis.tree[i] = this.INIT;\n\t\t}\n\n\t\t//lazyの初期化\n\t\tthis.lazy = new long[2*x-1];\n\t\tfor(int i=0; i<2*x-1; i++){\n\t\t\tthis.lazy[i] = this.lazyINIT;\n\t\t}\n\t}\n\n\t//元の配列に合わせ、完全二分木を初期化するメソッド\n\t/*\n\t計算量はO(N)だが、この段階ではまだ回答クエリに応答できないので注意。\n\t*/\n\tpublic void Initialize(long[] arr){\n\t\t//元の配列の値をSet\n\t\tfor(int i=0; i<arr.Length; i++){\n\t\t\tthis.tree[i + this.leaf - 1] = arr[i];\n\t\t}\n\n\t\t//その上で、木構造をBuild\n\t\tfor(int k=this.leaf-2; k>=0; k--){\n\t\t\tthis.tree[k] = this.fx(this.tree[2*k+1],this.tree[2*k+2]);\n\t\t}\n\t}\n\n\t/*\n\t（２）値の更新と、遅延評価（更新クエリへの応答）\n\t*/\n\n\t//更新に使う遅延評価メソッド\n\t/*\n\t引数は、現在の対象要素currentと、問題となる区間の長さlen\n\t*/\n\tvoid Eval(int current, int len){\n\t\t//初期値の場合、更新は不要\n\t\tif(this.lazy[current] == this.lazyINIT){\n\t\t\treturn;\n\t\t}\n\n\t\t//葉でない場合には、子に伝播\n\t\tif(current < this.leaf - 1){\n\t\t\tthis.lazy[current*2+1] = this.fm(this.lazy[current*2+1],this.lazy[current]);\n\t\t\tthis.lazy[current*2+2] = this.fm(this.lazy[current*2+2],this.lazy[current]);\n\t\t}\n\n\t\t//自身を更新\n\t\t//cf. fp関数を使うのはここだけ\n\t\tthis.tree[current] = this.fa(this.tree[current],this.fp(this.lazy[current],len));\n\n\t\t//初期状態に戻す\n\t\tthis.lazy[current] = this.lazyINIT;\n\t}\n\n\n\t//値の追加用のメソッド\n\t/*\n\t引数は、対象たる閉区間[left, right]\n\t*/\n\tpublic void Update(int left, int right, long val){\n\t\t//実装の都合上、半開区間[left, right)に直す\n\t\tright ++;\n\n\t\t//更新を行う\n\t\tUpdateSub(left, right, val, 0, 0, this.leaf);\n\t}\n\n\t//値の追加用のサブメソッド\n\t/*\n\tleft, rightは、元々のクエリの対象区間\n\t（※葉の番号（元の配列のインデックス）であって、treeのインデックスではない）\n\tcurrentは、現在見ているノードのインデックス（現在回答しているノードくん）\n\ttL, tRは、currentノードくんが対象としている最小値区間（半開区間）の範囲\n\t（※tLとtRも葉の番号（treeのインデックスではない））\n\t*/\n\tvoid UpdateSub(int left, int right, long val, int current, int tL, int tR){\n\t\t//現在のノードを評価\n\t\tthis.Eval(current, tR-tL);\n\n\t\t//1. クエリが対象範囲外の場合、何もしない\n\t\tif(tR <= left || right <= tL){\n\t\t\treturn;\n\t\t}\n\t\t//2. 完全に範囲内に含んでいる場合、遅延配列に値を入れた後に評価\n\t\tif(left <= tL && tR <= right){\n\t\t\tthis.lazy[current] = this.fm(this.lazy[current],val);\n\t\t\tEval(current, tR-tL);\n\t\t}\n\t\t//3. 一部区間だけがカブっている場合（左右どちらかがはみ出ている）\n\t\telse{\n\t\t\t//左側の子の更新\n\t\t\tUpdateSub(left, right, val, current*2+1, tL, (tL+tR)/2);\n\t\t\t//右側の子の更新\n\t\t\tUpdateSub(left, right, val, current*2+2, (tL+tR)/2, tR);\n\t\t\t//現在のノードを更新\n\t\t\tthis.tree[current] = this.fx(this.tree[current*2+1],this.tree[current*2+2]);\n\t\t}\n\t}\n\n\t/*\n\t（３）値の取得（回答クエリへの応答）\n\t*/\n\n\t//閉区間[left, right]に於ける答えを返す\n\tpublic long GetAnswer(int left, int right){\n\t\t//実装の都合上、半開区間に直す\n\t\tright ++;\n\n\t\t//実装の都合上、サブタスクに分ける\n\t\t/*\n\t\tまずは根ノード（インデックス0）に問い合わせる。\n\t\t根ノードの対象範囲は、全ての葉（葉番号0 ~ leaf-1まで）\n\t\t*/\n\t\treturn GetAnswerSub(left, right, 0, 0, this.leaf);\n\t}\n\n\t//サブタスク（cf. 引数は、UpdateSubと同じ）\n\tlong GetAnswerSub(int left, int right, int current, int tL, int tR){\n\t\t//まず更新を行う\n\t\tthis.Eval(current, tR-tL);\n\n\t\t//1. クエリが対象範囲外の場合、初期値を返す\n\t\tif(tR <= left || right <= tL){\n\t\t\treturn INIT;\n\t\t}\n\t\t//2. 完全に範囲内に含んでいる場合、自身の値を返す\n\t\telse if(left <= tL && tR <= right){\n\t\t\treturn this.tree[current];\n\t\t}\n\t\t//3. 一部区間だけがカブっている場合（左右どちらかがはみ出ている）\n\t\telse{\n\t\t\t//左側の子の回答\n\t\t\tlong valL = GetAnswerSub(left, right, current*2+1, tL, (tL+tR)/2);\n\t\t\t//右側の子の回答\n\t\t\tlong valR =\tGetAnswerSub(left, right, current*2+2, (tL+tR)/2, tR);\n\t\t\t//両者の回答から自身の回答を決定\n\t\t\treturn this.fx(valL, valR);\n\t\t}\n\t}\n\n\n\t/*\n\t--- ---\n\t*/\n\n\t//debug用の、完全二分木出力メソッド\n\tpublic void DebugWrite(){\n\t\tfor(int i=0; i<this.tree.Length; i++){\n\t\t\tConsole.Write(\"t[{0}]={1}\",i,this.tree[i]);\n\t\t\t//葉に該当する場合、葉の番号iを出力\n\t\t\tif(i >= leaf-1){\n\t\t\t\tConsole.Write(\"(i={0}),\", i-this.leaf+1);\n\t\t\t}\n\t\t\t//それ以外\n\t\t\telse{\n\t\t\t\tConsole.Write(\",\");\n\t\t\t}\n\t\t}\n\t\tConsole.WriteLine(\"\");\n\t}\n}\n\n/*\n--- おまけ ---\n\nよくある問題に対する、コンストラクタの引数のセット\n（引数は上からそれぞれ、\n元の配列の要素数、関数4つ、二分木の初期値、遅延評価配列の初期値）\n\ncf. 区間の長さが関係ない問題の場合、fp関数は実質的には無意味\n　→2つ目の引数が長さであるので、それを無効化すれば良い\n　（Func<long, long, long> fp = (m,n) => m;）\n\n（１）RAQ（更新） + RSQ（回答）の場合\n（Range Add Query と Range Sum Query：区間「加算」と区間「和」）\n\n\tFunc<long, long, long> fx = (x1,x2) => x1 + x2;\n\tFunc<long, long, long> fa = (x,m) => x + m;\n\tFunc<long, long, long> fm = (m1,m2) => m1 + m2;\n\tFunc<long, long, long> fp = (m,n) => m * n;\n\tlong init = 0;\n\tlong lazyInit = 0;\n\n（２）RAQ（更新） + RMQ（回答）の場合\n（Range Add Query と Range Minimum Query：区間「加算」と区間「最小値」）\n\n\tFunc<long, long, long> fx = (x1,x2) => Math.Min(x1,x2);\n\tFunc<long, long, long> fa = (x,m) => x + m;\n\tFunc<long, long, long> fm = (m1,m2) => m1 + m2;\n\tFunc<long, long, long> fp = (m,n) => m;\n\tlong init = long.MaxValue;\n\tlong lazyInit = 0;\n\n（３）RUQ（更新） + RMQ（回答）の場合\n（Range Update Query と Range Minimum Query：区間「上書き」と区間「最小値」）\n\n\tFunc<long, long, long> fx = (x1,x2) => Math.Min(x1,x2);\n\tFunc<long, long, long> fa = (x,m) => m;\n\tFunc<long, long, long> fm = (m1,m2) => m2;\n\tFunc<long, long, long> fp = (m,n) => m;\n\tlong init = long.MaxValue;\n\tlong lazyInit = long.MaxValue;\n\n*/\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\nusing CompLib.DataStructures;\n\npublic class Program\n{\n    public void Solve()\n    {\n        var sc = new Scanner();\n        int n = sc.NextInt();\n        int q = sc.NextInt();\n\n        var st = new LazySegmentTreeRsq(n);\n        var sb = new StringBuilder();\n        for (int i = 0; i < q; i++)\n        {\n            string type = sc.Next();\n            if (type == \"0\")\n            {\n                int s = sc.NextInt();\n                int t = sc.NextInt();\n                int x = sc.NextInt();\n                st.Update(s, t + 1, x);\n            }\n            else\n            {\n                int s = sc.NextInt();\n                int t = sc.NextInt();\n                sb.AppendLine(st.Sum(s, t + 1).ToString());\n            }\n        }\n\n        Console.Write(sb.ToString());\n    }\n\n    public static void Main(string[] args)\n    {\n        new Program().Solve();\n    }\n}\n\nnamespace CompLib.DataStructures\n{\n    #region RangeSumQuery\n\n    using N = Int64;\n\n    /// <summary>\n    /// 遅延セグメント木 (RangeSumQuery)\n    /// 指定した範囲の和を求める、更新 それぞれO(log N)\n    /// </summary>\n    public class LazySegmentTreeRsq\n    {\n        private readonly int _size;\n        private readonly N[] _array;\n        private readonly N[] _add;\n        private readonly N[] _update;\n        private readonly bool[] _updateFlag;\n\n        /// <summary>\n        /// コンストラクタ\n        /// 全て0で初期化\n        /// </summary>\n        /// <param name=\"size\">配列の大きさ = N</param>\n        public LazySegmentTreeRsq(int size)\n        {\n            _size = 1;\n            while (_size < size)\n                _size *= 2;\n            _array = new N[_size * 2];\n            _add = new N[_size * 2];\n            _update = new N[_size * 2];\n            _updateFlag = new bool[_size * 2];\n        }\n\n        /// <summary>\n        /// コンストラクタ\n        /// 配列aをコピー\n        /// </summary>\n        /// <param name=\"a\">配列</param>\n        public LazySegmentTreeRsq(N[] a) : this(a.Length)\n        {\n            for (int i = 0; i < a.Length; i++)\n                _array[i + _size] = a[i];\n            for (int i = _size - 1; i >= 1; i--)\n                _array[i] = _array[i * 2] + _array[i * 2 + 1];\n        }\n\n        private void Eval(int l, int r, int k)\n        {\n            if (_updateFlag[k])\n            {\n                _array[k] = _update[k] * (r - l);\n                if (r - l > 1)\n                {\n                    _update[k * 2] = _update[k];\n                    _update[k * 2 + 1] = _update[k];\n                    _add[k * 2] = 0;\n                    _add[k * 2 + 1] = 0;\n                    _updateFlag[k * 2] = true;\n                    _updateFlag[k * 2 + 1] = true;\n                }\n\n                _updateFlag[k] = false;\n            }\n\n            if (_add[k] != 0)\n            {\n                _array[k] += _add[k] * (r - l);\n                if (r - l > 1)\n                {\n                    _add[k * 2] += _add[k];\n                    _add[k * 2 + 1] += _add[k];\n                }\n\n                _add[k] = 0;\n            }\n        }\n\n        private void Add(int left, int right, int k, int l, int r, N n)\n        {\n            Eval(l, r, k);\n            if (r <= left || right <= l) return;\n            if (left <= l && r <= right)\n            {\n                _add[k] += n;\n                Eval(l, r, k);\n            }\n            else\n            {\n                Add(left, right, k * 2, l, (l + r) / 2, n);\n                Add(left, right, k * 2 + 1, (l + r) / 2, r, n);\n                _array[k] = _array[k * 2] + _array[k * 2 + 1];\n            }\n        }\n\n        /// <summary>\n        /// [left,right)にnを足す O(log N)\n        /// </summary>\n        /// <param name=\"left\">左端</param>\n        /// <param name=\"right\">右端</param>\n        /// <param name=\"n\">増やす値</param>\n        public void Add(int left, int right, N n) => Add(left, right, 1, 0, _size, n);\n\n        /// <summary>\n        /// i番目にnを足す O(log N)\n        /// </summary>\n        /// <param name=\"i\">インデックス</param>\n        /// <param name=\"n\">増やす値</param>\n        public void Add(int i, N n) => Add(i, i + 1, n);\n\n        private void Update(int left, int right, int k, int l, int r, N n)\n        {\n            Eval(l, r, k);\n            if (r <= left || right <= l) return;\n            if (left <= l && r <= right)\n            {\n                _update[k] = n;\n                _updateFlag[k] = true;\n                _add[k] = 0;\n                Eval(l, r, k);\n            }\n            else\n            {\n                Update(left, right, k * 2, l, (l + r) / 2, n);\n                Update(left, right, k * 2 + 1, (l + r) / 2, r, n);\n                _array[k] = _array[k * 2] + _array[k * 2 + 1];\n            }\n        }\n\n        /// <summary>\n        /// [left, right)をnに置き換える\n        /// </summary>\n        /// <param name=\"left\">右端</param>\n        /// <param name=\"right\">左端</param>\n        /// <param name=\"n\">置き換える値</param>\n        public void Update(int left, int right, N n) => Update(left, right, 1, 0, _size, n);\n\n        /// <summary>\n        /// i番目をnに置き換える\n        /// </summary>\n        /// <param name=\"i\">インデックス</param>\n        /// <param name=\"n\">置き換える値</param>\n        public void Update(int i, N n) => Update(i, i + 1, n);\n\n        private N Sum(int left, int right, int k, int l, int r)\n        {\n            Eval(l, r, k);\n            if (r <= left || right <= l) return 0;\n            if (left <= l && r <= right) return _array[k];\n            return Sum(left, right, k * 2, l, (l + r) / 2) + Sum(left, right, k * 2 + 1, (l + r) / 2, r);\n        }\n\n        /// <summary>\n        /// [left, right)の和を求める O(log N)\n        /// </summary>\n        /// <param name=\"left\">左端</param>\n        /// <param name=\"right\">右端</param>\n        /// <returns></returns>\n        public N Sum(int left, int right) => Sum(left, right, 1, 0, _size);\n\n        public N this[int i]\n        {\n            get { return Sum(i, i + 1); }\n            set { Update(i, value); }\n        }\n    }\n\n    #endregion\n}\n\nclass Scanner\n{\n    public Scanner()\n    {\n        _pos = 0;\n        _line = new string[0];\n    }\n\n    const char Separator = ' ';\n    private int _pos;\n    private string[] _line;\n\n    #region スペース区切りで取得\n\n    public string Next()\n    {\n        if (_pos >= _line.Length)\n        {\n            _line = Console.ReadLine().Split(Separator);\n            _pos = 0;\n        }\n\n        return _line[_pos++];\n    }\n\n    public int NextInt()\n    {\n        return int.Parse(Next());\n    }\n\n    public long NextLong()\n    {\n        return long.Parse(Next());\n    }\n\n    public double NextDouble()\n    {\n        return double.Parse(Next());\n    }\n\n    #endregion\n\n    #region 型変換\n\n    private int[] ToIntArray(string[] array)\n    {\n        var result = new int[array.Length];\n        for (int i = 0; i < array.Length; i++)\n        {\n            result[i] = int.Parse(array[i]);\n        }\n\n        return result;\n    }\n\n    private long[] ToLongArray(string[] array)\n    {\n        var result = new long[array.Length];\n        for (int i = 0; i < array.Length; i++)\n        {\n            result[i] = long.Parse(array[i]);\n        }\n\n        return result;\n    }\n\n    private double[] ToDoubleArray(string[] array)\n    {\n        var result = new double[array.Length];\n        for (int i = 0; i < array.Length; i++)\n        {\n            result[i] = double.Parse(array[i]);\n        }\n\n        return result;\n    }\n\n    #endregion\n\n    #region 配列取得\n\n    public string[] Array()\n    {\n        if (_pos >= _line.Length)\n            _line = Console.ReadLine().Split(Separator);\n        _pos = _line.Length;\n        return _line;\n    }\n\n    public int[] IntArray()\n    {\n        return ToIntArray(Array());\n    }\n\n    public long[] LongArray()\n    {\n        return ToLongArray(Array());\n    }\n\n    public double[] DoubleArray()\n    {\n        return ToDoubleArray(Array());\n    }\n\n    #endregion\n}\n"
  },
  {
    "language": "Ruby",
    "code": "class LazySegmentTreeBase\n  def initialize(arr, l = 0, r = arr.size - 1)\n    @l, @r = l, r\n    @lazy = nil\n    if l == r\n      @agg = arr[l]\n    else\n      c = (l + r) / 2\n      @left_child = self.class.new(arr, l, c)\n      @right_child = self.class.new(arr, c + 1, r)\n      @agg = aggregation_of(@left_child.agg, @right_child.agg)\n    end\n  end\n\n  attr_reader :agg, :l, :r\n\n  def update(l, r, x)\n    if l == @l && r == @r\n      defer(x)\n    else\n      force\n      if r <= @left_child.r\n        @left_child.update(l, r, x)\n      elsif @right_child.l <= l\n        @right_child.update(l, r, x)\n      else\n        @left_child.update(l, @left_child.r, x)\n        @right_child.update(@right_child.l, r, x)\n      end\n      @left_child.force\n      @right_child.force\n      @agg = aggregation_of(@left_child.agg, @right_child.agg)\n    end\n  end\n\n  def force\n    return if !@lazy\n    x = @lazy\n    @lazy = nil\n    whole_update(x)\n    @left_child.update(@left_child.l, @left_child.r, x) if @left_child\n    @right_child.update(@right_child.l, @right_child.r, x) if @right_child\n  end\n\n  def query(l, r)\n    force\n    return @agg if l == @l && r == @r\n    if r <= @left_child.r\n      return @left_child.query(l, r)\n    elsif @right_child.l <= l\n      return @right_child.query(l, r)\n    else\n      agg_left = @left_child.query(l, @left_child.r)\n      agg_right = @right_child.query(@right_child.l, r)\n      return aggregation_of(agg_left, agg_right)\n    end\n  end\nend\n\nclass LazySegmentTree < LazySegmentTreeBase\n  def initialize(arr, l = 0, r = arr.size - 1)\n    @n = r - l + 1\n    super(arr, l, r)\n  end\n\n  def defer(x)\n    @lazy = x\n  end\n\n  def whole_update(x)\n    @agg = x * @n\n  end\n\n  def aggregation_of(x, y)\n    x + y\n  end\nend\n\nn, q = gets.split.map(&:to_i)\nseg = LazySegmentTree.new(Array.new(n, 0))\nq.times do\n  c, x, y, z = gets.split.map(&:to_i)\n  if c == 0\n    seg.update(x, y, z)\n  else\n    puts seg.query(x, y)\n  end\nend\n"
  },
  {
    "language": "Ruby",
    "code": "def get_i() #空白区切の入力を数値(整数)の配列で返す\n  return gets.chomp.split(\" \").map(&:to_i)\nend\ndef get_f() #空白区切の入力を数値(実数)の配列で返す\n  return gets.chomp.split(\" \").map(&:to_f)\nend\ndef get() #空白区切の入力を文字列の配列で返す\n  return gets.chomp.split(\" \")\nend\ndef get_nsp() #入力されたものを一文字ずつに区切った文字列の配列で返す\n  return gets.chomp.split(\"\")\nend\ndef yn_judge(bool,y=\"Yes\",n=\"No\") #boolに真偽を投げることで、trueならy、falseならnの値を出力する\n  return bool ? y : n \nend\ndef array(size,n=1,init=nil) #nに配列の次元数、sizeに配列の大きさ、initに初期値を投げることでその配列を返す\n  if n==1\n    return Array.new(size){init}\n  else\n    return Array.new(n).map{Array.new(size){init}}\n  end\nend\n\nclass LazySegTree\n  attr_accessor:node,:lazy,:n,:lazyF\n  def initialize(n)\n    @n=1\n    @n*=2 while @n<n\n    @node=array(2*@n-1,1,0)\n    @lazy=array(2*@n-1,1,0)\n    @lazyF=array(2*@n-1,1,false)\n  end\n\n\n  def lazy_eval(i,l,r)\n    if @lazyF[i]\n      @node[i]=@lazy[i]\n      if r-l>1\n        @lazy[i*2+1]=@lazy[i]/2\n        @lazy[i*2+2]=@lazy[i]/2\n        @lazyF[i*2+1]=true\n        @lazyF[i*2+2]=true\n      end\n      @lazy[i]=0\n      @lazyF[i]=false\n    end\n  end\n  def update(s,t,x,i,l,r)\n    lazy_eval(i,l,r)\n    return if r<=s or t<=l\n    if s<=l and r<=t\n      @lazyF[i]=true\n      @lazy[i]=x*(r-l)\n      lazy_eval(i,l,r)\n    else\n      mid=(l+r)/2\n      update(s,t,x,i*2+1,l,mid)\n      update(s,t,x,i*2+2,mid,r)\n      @node[i]=@node[i*2+1]+@node[i*2+2]\n    end\n  end\n\n  def getSum(s,t,i,l,r)\n    return 0 if r<=s or t<=l\n    lazy_eval(i,l,r)\n    return @node[i] if s<=l and r<=t\n    mid=(l+r)/2\n    leaf_l=getSum(s,t,i*2+1,l,mid)\n    leaf_r=getSum(s,t,i*2+2,mid,r)\n    return leaf_l+leaf_r\n  end\nend\n\nn,q=get_i\nlst=LazySegTree.new(n)\nq.times do\n  qu=get_i\n  if qu[0].zero?\n    lst.update(qu[1],qu[2]+1,qu[3],0,0,lst.n)\n  else\n    puts lst.getSum(qu[1],qu[2]+1,0,0,lst.n)\n  end\nend\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nfunc configure(scanner *bufio.Scanner) {\n\tscanner.Split(bufio.ScanWords)\n\tscanner.Buffer(make([]byte, 1000005), 1000005)\n}\nfunc getNextString(scanner *bufio.Scanner) string {\n\tscanned := scanner.Scan()\n\tif !scanned {\n\t\tpanic(\"scan failed\")\n\t}\n\treturn scanner.Text()\n}\nfunc getNextInt(scanner *bufio.Scanner) int {\n\ti, _ := strconv.Atoi(getNextString(scanner))\n\treturn i\n}\nfunc getNextInt64(scanner *bufio.Scanner) int64 {\n\ti, _ := strconv.ParseInt(getNextString(scanner), 10, 64)\n\treturn i\n}\nfunc getNextFloat64(scanner *bufio.Scanner) float64 {\n\ti, _ := strconv.ParseFloat(getNextString(scanner), 64)\n\treturn i\n}\nfunc main() {\n\tfp := os.Stdin\n\twfp := os.Stdout\n\textra := 0\n\tif os.Getenv(\"I\") == \"IronMan\" {\n\t\tfp, _ = os.Open(os.Getenv(\"END_GAME\"))\n\t\textra = 100\n\t}\n\tscanner := bufio.NewScanner(fp)\n\tconfigure(scanner)\n\twriter := bufio.NewWriter(wfp)\n\tdefer func() {\n\t\tr := recover()\n\t\tif r != nil {\n\t\t\tfmt.Fprintln(writer, r)\n\t\t}\n\t\twriter.Flush()\n\t}()\n\tsolve(scanner, writer)\n\tfor i := 0; i < extra; i++ {\n\t\tfmt.Fprintln(writer, \"-----------------------------------\")\n\t\tsolve(scanner, writer)\n\t}\n}\nfunc solve(scanner *bufio.Scanner, writer *bufio.Writer) {\n\tn := getNextInt(scanner)\n\tq := getNextInt(scanner)\n\tseg := newSegment(n)\n\tfor i := 0; i < n; i++ {\n\t\tseg[0][i].c = 1\n\t}\n\tfor h := 0; h < len(seg)-1; h++ {\n\t\tfor i := 0; i < len(seg[h]); i++ {\n\t\t\tseg[h+1][i>>1].c += seg[h][i].c\n\t\t}\n\t}\n\n\tfor i := 0; i < q; i++ {\n\t\tc := getNextInt(scanner)\n\t\ts := getNextInt(scanner)\n\t\tt := getNextInt(scanner)\n\t\tswitch c {\n\t\tcase 0:\n\t\t\tx := getNextInt(scanner)\n\t\t\tseg.update(s, t+1, x, seg.add)\n\t\tcase 1:\n\t\t\tfmt.Fprintln(writer, seg.query(s, t+1, 0, seg.add))\n\t\t}\n\t}\n}\n\ntype lazy struct {\n\tv, w, c int\n\tp       bool\n}\n\nfunc (l *lazy) hold(w int) {\n\tl.w = w\n\tl.p = true\n}\nfunc (l *lazy) assign() {\n\tl.v = l.w * l.c\n\tl.w = 0\n\tl.p = false\n}\nfunc (l *lazy) eval() int {\n\tif l.p {\n\t\treturn l.w * l.c\n\t}\n\treturn l.v\n}\n\ntype segment [][]lazy\n\nfunc newSegment(n int) segment {\n\tseg := make(segment, 0)\n\tfor n > 1 {\n\t\tseg = append(seg, make([]lazy, n))\n\t\tn = (n + 1) >> 1\n\t}\n\tseg = append(seg, make([]lazy, 1))\n\treturn seg\n}\nfunc (seg segment) push(h, i int, f func(x, y int) int) {\n\tfor h = h + 1; h < len(seg); h++ {\n\t\ti >>= 1\n\t\tif i<<1+1 < len(seg[h-1]) {\n\t\t\tseg[h][i].v = f(seg[h-1][i<<1].eval(), seg[h-1][i<<1+1].eval())\n\t\t\tcontinue\n\t\t}\n\t\tseg[h][i].v = seg[h-1][i<<1].eval()\n\t}\n}\nfunc (seg segment) pull(h, i int) {\n\tif h >= len(seg) {\n\t\treturn\n\t}\n\tseg.pull(h+1, i>>1)\n\tif seg[h][i].p {\n\t\tif h > 0 {\n\t\t\tseg[h-1][i<<1].hold(seg[h][i].w)\n\t\t\tif i<<1+1 < len(seg[h-1]) {\n\t\t\t\tseg[h-1][i<<1+1].hold(seg[h][i].w)\n\t\t\t}\n\t\t}\n\t\tseg[h][i].assign()\n\t}\n}\nfunc (seg segment) update(l, r int, v int, f func(x, y int) int) {\n\tfor h := 0; h < len(seg) && l < r; h++ {\n\t\tif l&1 == 1 {\n\t\t\tseg.pull(h, l)\n\t\t\tseg[h][l].hold(v)\n\t\t\tseg.push(h, l, f)\n\t\t\tl++\n\t\t}\n\t\tl >>= 1\n\t\tif r&1 == 1 {\n\t\t\tseg.pull(h, r-1)\n\t\t\tseg[h][r-1].hold(v)\n\t\t\tseg.push(h, r-1, f)\n\t\t}\n\t\tr >>= 1\n\t}\n}\nfunc (seg segment) query(l, r int, s int, f func(x, y int) int) int {\n\tfor h := 0; h < len(seg) && l < r; h++ {\n\t\tif l&1 == 1 {\n\t\t\tseg.pull(h, l)\n\t\t\ts = f(s, seg[h][l].eval())\n\t\t\tl++\n\t\t}\n\t\tl >>= 1\n\t\tif r&1 == 1 {\n\t\t\tseg.pull(h, r-1)\n\t\t\ts = f(s, seg[h][r-1].eval())\n\t\t}\n\t\tr >>= 1\n\t}\n\treturn s\n}\n\nfunc (seg segment) add(x, y int) int {\n\treturn x + y\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nfunc main() {\n\tdefer writer.Flush()\n\tn, q := ReadInt(), ReadInt()\n\tt := NewLazySegTree(n)\n\tfor ; q > 0; q-- {\n\t\tif ReadInt() == 0 {\n\t\t\tt.Update(ReadInt(), ReadInt()+1, ReadInt())\n\t\t} else {\n\t\t\tPrintln(t.GetSum(ReadInt(), ReadInt()+1))\n\t\t}\n\t}\n}\n\ntype LazySegTree struct {\n\tnodes []int\n\tlazy  []int\n}\n\nconst Inf = 1 << 62\nconst None = -Inf\n\nfunc NewLazySegTree(n_ int) *LazySegTree {\n\tn := 1\n\tfor n < n_ {\n\t\tn <<= 1\n\t}\n\tt := &LazySegTree{\n\t\tnodes: make([]int, n<<1),\n\t\tlazy:  make([]int, n<<1),\n\t}\n\tfor i := 1; i < len(t.lazy); i++ {\n\t\tt.lazy[i] = None\n\t}\n\treturn t\n}\n\nfunc (t *LazySegTree) lazyEval(k, l, r int) {\n\tif t.lazy[k] == None {\n\t\treturn\n\t}\n\tt.nodes[k] = t.lazy[k]\n\tif r-l > 1 {\n\t\tt.lazy[k<<1] = t.lazy[k] >> 1\n\t\tt.lazy[k<<1+1] = t.lazy[k] >> 1\n\t}\n\tt.lazy[k] = None\n}\n\nfunc (t *LazySegTree) Update(a, b, x int) {\n\tt.updateRecur(a, b, x, 1, 0, len(t.nodes)>>1)\n}\nfunc (t *LazySegTree) updateRecur(a, b, x, k, l, r int) {\n\tt.lazyEval(k, l, r)\n\tif b <= l || r <= a {\n\t\treturn\n\t}\n\tif a <= l && r <= b {\n\t\tt.lazy[k] = x * (r - l)\n\t\tt.lazyEval(k, l, r)\n\t} else {\n\t\tt.updateRecur(a, b, x, k<<1, l, (l+r)>>1)\n\t\tt.updateRecur(a, b, x, k<<1+1, (l+r)>>1, r)\n\t\tt.nodes[k] = t.nodes[k<<1] + t.nodes[k<<1+1]\n\t}\n}\n\nfunc (t *LazySegTree) GetSum(a, b int) int {\n\treturn t.getSumRecur(a, b, 1, 0, len(t.nodes)>>1)\n}\nfunc (t *LazySegTree) getSumRecur(a, b, k, l, r int) int {\n\tt.lazyEval(k, l, r)\n\tif b <= l || r <= a {\n\t\treturn 0\n\t}\n\tif a <= l && r <= b {\n\t\treturn t.nodes[k]\n\t} else {\n\t\treturn t.getSumRecur(a, b, k<<1, l, (l+r)>>1) +\n\t\t\tt.getSumRecur(a, b, k<<1+1, (l+r)>>1, r)\n\t}\n}\n\nvar scanner = bufio.NewScanner(os.Stdin)\n\nfunc init() {\n\tscanner.Buffer(make([]byte, 256), 1e9)\n\tscanner.Split(bufio.ScanWords)\n}\nfunc ReadString() string { scanner.Scan(); return scanner.Text() }\nfunc ReadInt() int {\n\ta, err := strconv.Atoi(ReadString())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn a\n}\n\nvar writer = bufio.NewWriter(os.Stdout)\n\nfunc Println(a ...interface{}) { fmt.Fprintln(writer, a...) }\n\n"
  },
  {
    "language": "Go",
    "code": "/*\nURL:\nhttps://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/2/DSL_2_I\n*/\n\npackage main\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"os\"\n\t\"strconv\"\n)\n\n/********** FAU standard libraries **********/\n\n//fmt.Sprintf(\"%b\\n\", 255) \t// binary expression\n\n/********** I/O usage **********/\n\n//str := ReadString()\n//i := ReadInt()\n//X := ReadIntSlice(n)\n//S := ReadRuneSlice()\n//a := ReadFloat64()\n//A := ReadFloat64Slice(n)\n\n//str := ZeroPaddingRuneSlice(num, 32)\n//str := PrintIntsLine(X...)\n\n/*******************************************************************/\n\nconst (\n\t// General purpose\n\tMOD          = 1000000000 + 7\n\tALPHABET_NUM = 26\n\tINF_INT64    = math.MaxInt64\n\tINF_BIT60    = 1 << 60\n\tINF_INT32    = math.MaxInt32\n\tINF_BIT30    = 1 << 30\n\tNIL          = -1\n\n\t// for dijkstra, prim, and so on\n\tWHITE = 0\n\tGRAY  = 1\n\tBLACK = 2\n)\n\nfunc init() {\n\t// bufio.ScanWords <---> bufio.ScanLines\n\tReadString = newReadString(os.Stdin, bufio.ScanWords)\n\tstdout = bufio.NewWriter(os.Stdout)\n}\n\nfunc main() {\n\tn, q := ReadInt2()\n\n\tf := func(lv, rv T) T {\n\t\treturn lv + rv\n\t}\n\tg := func(to T, from E) T {\n\t\treturn T(from)\n\t}\n\th := func(to, from E) E {\n\t\treturn from\n\t}\n\tp := func(e E, length int) E {\n\t\treturn e * E(length)\n\t}\n\tti := T(0)\n\tei := E(1<<31 - 1)\n\tlst := NewLazySegmentTree(n, f, g, h, p, ti, ei)\n\n\tfor i := 0; i < q; i++ {\n\t\tc := ReadInt()\n\t\tif c == 0 {\n\t\t\ts, t, x := ReadInt3()\n\t\t\tlst.Update(s, t+1, E(x))\n\t\t} else {\n\t\t\ts, t := ReadInt2()\n\t\t\tfmt.Println(lst.Query(s, t+1))\n\t\t}\n\t}\n}\n\n// Assumption: T == E\ntype T int // (T, f): Monoid\ntype E int // (E, h): Operator Monoid\n\ntype LazySegmentTree struct {\n\tsz   int\n\tdata []T\n\tlazy []E\n\tf    func(lv, rv T) T        // T <> T -> T\n\tg    func(to T, from E) T    // T <> E -> T (assignment operator)\n\th    func(to, from E) E      // E <> E -> E (assignment operator)\n\tp    func(e E, length int) E // E <> N -> E\n\tti   T\n\tei   E\n}\n\nfunc NewLazySegmentTree(\n\tn int,\n\tf func(lv, rv T) T, g func(to T, from E) T,\n\th func(to, from E) E, p func(e E, length int) E,\n\tti T, ei E,\n) *LazySegmentTree {\n\tlst := new(LazySegmentTree)\n\tlst.f, lst.g, lst.h, lst.p = f, g, h, p\n\tlst.ti, lst.ei = ti, ei\n\n\tlst.sz = 1\n\tfor lst.sz < n {\n\t\tlst.sz *= 2\n\t}\n\n\tlst.data = make([]T, 2*lst.sz-1)\n\tlst.lazy = make([]E, 2*lst.sz-1)\n\tfor i := 0; i < 2*lst.sz-1; i++ {\n\t\tlst.data[i] = lst.ti\n\t\tlst.lazy[i] = lst.ei\n\t}\n\n\treturn lst\n}\n\nfunc (lst *LazySegmentTree) Set(k int, x T) {\n\tlst.data[k+(lst.sz-1)] = x\n}\n\nfunc (lst *LazySegmentTree) Build() {\n\tfor i := lst.sz - 2; i >= 0; i-- {\n\t\tlst.data[i] = lst.f(lst.data[2*i+1], lst.data[2*i+2])\n\t}\n}\n\nfunc (lst *LazySegmentTree) propagate(k, length int) {\n\tif lst.lazy[k] != lst.ei {\n\t\tif k < lst.sz-1 {\n\t\t\tlst.lazy[2*k+1] = lst.h(lst.lazy[2*k+1], lst.lazy[k])\n\t\t\tlst.lazy[2*k+2] = lst.h(lst.lazy[2*k+2], lst.lazy[k])\n\t\t}\n\t\tlst.data[k] = lst.g(lst.data[k], lst.p(lst.lazy[k], length))\n\t\tlst.lazy[k] = lst.ei\n\t}\n}\n\nfunc (lst *LazySegmentTree) Update(a, b int, x E) T {\n\treturn lst.update(a, b, x, 0, 0, lst.sz)\n}\n\nfunc (lst *LazySegmentTree) update(a, b int, x E, k, l, r int) T {\n\tlst.propagate(k, r-l)\n\n\tif r <= a || b <= l {\n\t\treturn lst.data[k]\n\t}\n\n\tif a <= l && r <= b {\n\t\tlst.lazy[k] = lst.h(lst.lazy[k], x)\n\t\tlst.propagate(k, r-l)\n\t\treturn lst.data[k]\n\t}\n\n\tlv := lst.update(a, b, x, 2*k+1, l, (l+r)/2)\n\trv := lst.update(a, b, x, 2*k+2, (l+r)/2, r)\n\tlst.data[k] = lst.f(lv, rv)\n\treturn lst.data[k]\n}\n\nfunc (lst *LazySegmentTree) Query(a, b int) T {\n\treturn lst.query(a, b, 0, 0, lst.sz)\n}\n\nfunc (lst *LazySegmentTree) query(a, b, k, l, r int) T {\n\tlst.propagate(k, r-l)\n\n\tif r <= a || b <= l {\n\t\treturn lst.ti\n\t}\n\n\tif a <= l && r <= b {\n\t\treturn lst.data[k]\n\t}\n\n\tlv := lst.query(a, b, 2*k+1, l, (l+r)/2)\n\trv := lst.query(a, b, 2*k+2, (l+r)/2, r)\n\treturn lst.f(lv, rv)\n}\n\nfunc (lst *LazySegmentTree) Get(k int) T {\n\treturn lst.Query(k, k+1)\n}\n\n/*******************************************************************/\n\n/*********** I/O ***********/\n\nvar (\n\t// ReadString returns a WORD string.\n\tReadString func() string\n\tstdout     *bufio.Writer\n)\n\nfunc newReadString(ior io.Reader, sf bufio.SplitFunc) func() string {\n\tr := bufio.NewScanner(ior)\n\tr.Buffer(make([]byte, 1024), int(1e+9)) // for Codeforces\n\tr.Split(sf)\n\n\treturn func() string {\n\t\tif !r.Scan() {\n\t\t\tpanic(\"Scan failed\")\n\t\t}\n\t\treturn r.Text()\n\t}\n}\n\n// ReadInt returns an integer.\nfunc ReadInt() int {\n\treturn int(readInt64())\n}\nfunc ReadInt2() (int, int) {\n\treturn int(readInt64()), int(readInt64())\n}\nfunc ReadInt3() (int, int, int) {\n\treturn int(readInt64()), int(readInt64()), int(readInt64())\n}\nfunc ReadInt4() (int, int, int, int) {\n\treturn int(readInt64()), int(readInt64()), int(readInt64()), int(readInt64())\n}\n\n// ReadInt64 returns as integer as int64.\nfunc ReadInt64() int64 {\n\treturn readInt64()\n}\nfunc ReadInt64_2() (int64, int64) {\n\treturn readInt64(), readInt64()\n}\nfunc ReadInt64_3() (int64, int64, int64) {\n\treturn readInt64(), readInt64(), readInt64()\n}\nfunc ReadInt64_4() (int64, int64, int64, int64) {\n\treturn readInt64(), readInt64(), readInt64(), readInt64()\n}\n\nfunc readInt64() int64 {\n\ti, err := strconv.ParseInt(ReadString(), 0, 64)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn i\n}\n\n// ReadIntSlice returns an integer slice that has n integers.\nfunc ReadIntSlice(n int) []int {\n\tb := make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tb[i] = ReadInt()\n\t}\n\treturn b\n}\n\n// ReadInt64Slice returns as int64 slice that has n integers.\nfunc ReadInt64Slice(n int) []int64 {\n\tb := make([]int64, n)\n\tfor i := 0; i < n; i++ {\n\t\tb[i] = ReadInt64()\n\t}\n\treturn b\n}\n\n// ReadFloat64 returns an float64.\nfunc ReadFloat64() float64 {\n\treturn float64(readFloat64())\n}\n\nfunc readFloat64() float64 {\n\tf, err := strconv.ParseFloat(ReadString(), 64)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn f\n}\n\n// ReadFloatSlice returns an float64 slice that has n float64.\nfunc ReadFloat64Slice(n int) []float64 {\n\tb := make([]float64, n)\n\tfor i := 0; i < n; i++ {\n\t\tb[i] = ReadFloat64()\n\t}\n\treturn b\n}\n\n// ReadRuneSlice returns a rune slice.\nfunc ReadRuneSlice() []rune {\n\treturn []rune(ReadString())\n}\n\n/*********** Debugging ***********/\n\n// ZeroPaddingRuneSlice returns binary expressions of integer n with zero padding.\n// For debugging use.\nfunc ZeroPaddingRuneSlice(n, digitsNum int) []rune {\n\tsn := fmt.Sprintf(\"%b\", n)\n\n\tresidualLength := digitsNum - len(sn)\n\tif residualLength <= 0 {\n\t\treturn []rune(sn)\n\t}\n\n\tzeros := make([]rune, residualLength)\n\tfor i := 0; i < len(zeros); i++ {\n\t\tzeros[i] = '0'\n\t}\n\n\tres := []rune{}\n\tres = append(res, zeros...)\n\tres = append(res, []rune(sn)...)\n\n\treturn res\n}\n\n// Strtoi is a wrapper of strconv.Atoi().\n// If strconv.Atoi() returns an error, Strtoi calls panic.\nfunc Strtoi(s string) int {\n\tif i, err := strconv.Atoi(s); err != nil {\n\t\tpanic(errors.New(\"[argument error]: Strtoi only accepts integer string\"))\n\t} else {\n\t\treturn i\n\t}\n}\n\n// PrintIntsLine returns integers string delimited by a space.\nfunc PrintIntsLine(A ...int) string {\n\tres := []rune{}\n\n\tfor i := 0; i < len(A); i++ {\n\t\tstr := strconv.Itoa(A[i])\n\t\tres = append(res, []rune(str)...)\n\n\t\tif i != len(A)-1 {\n\t\t\tres = append(res, ' ')\n\t\t}\n\t}\n\n\treturn string(res)\n}\n\n// PrintIntsLine returns integers string delimited by a space.\nfunc PrintInts64Line(A ...int64) string {\n\tres := []rune{}\n\n\tfor i := 0; i < len(A); i++ {\n\t\tstr := strconv.FormatInt(A[i], 10) // 64bit int version\n\t\tres = append(res, []rune(str)...)\n\n\t\tif i != len(A)-1 {\n\t\t\tres = append(res, ' ')\n\t\t}\n\t}\n\n\treturn string(res)\n}\n\n// PrintfDebug is wrapper of fmt.Fprintf(os.Stderr, format, a...)\nfunc PrintfDebug(format string, a ...interface{}) {\n\tfmt.Fprintf(os.Stderr, format, a...)\n}\n\n// PrintfBufStdout is function for output strings to buffered os.Stdout.\n// You may have to call stdout.Flush() finally.\nfunc PrintfBufStdout(format string, a ...interface{}) {\n\tfmt.Fprintf(stdout, format, a...)\n}\n\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, core.stdc.string;\n\nvoid main() {\n    auto s = readln.split.map!(to!int);\n    auto N = s[0];\n    auto Q = s[1];\n    auto st = new LazySegmentTree!(long, long, (a,b)=>a+b, (a,b)=>b, (a,b)=>b, (a,b)=>a*b, 0L, 1L<<59)(N+1);\n\n    while (Q--) {\n        s = readln.split.map!(to!int);\n        int q = s[0];\n        int l = s[1];\n        int r = s[2];\n        if (q == 0) {\n            long v = s[3];\n            st.update(l, r, v);\n        } else {\n            st.query(l, r).writeln;\n        }\n    }\n}\n\n\nclass LazySegmentTree(T, L, alias opTT, alias opTL, alias opLL, alias opPrd, T eT, L eL) {\n    T[] table;\n    L[] lazy_;\n    int n;\n    int size;\n\n    this(int n) {\n        this.n = n;\n        size = 1;\n        while (size <= n) size <<= 1;\n        size <<= 1;\n        table = new T[](size);\n        lazy_ = new T[](size);\n        table[] = eT;\n        lazy_[] = eL;\n    }\n\n    void push(int i, int a, int b) {\n        if (lazy_[i] == eL) return;\n        table[i] = opTL(table[i], opPrd(lazy_[i], b - a + 1));\n        if (i * 2 + 1 < size) {\n            lazy_[i*2] = opLL(lazy_[i*2], lazy_[i]);\n            lazy_[i*2+1] = opLL(lazy_[i*2+1], lazy_[i]);\n        }\n        lazy_[i] = eL;\n    }\n\n    T query(int l, int r) {\n        if (l > r) return eT;\n        return query(l, r, 1, 0, n-1);\n    }\n\n    T query(int l, int r, int i, int a, int b) {\n        if (b < l || r < a) return eT;\n        push(i, a, b);\n        if (l <= a && b <= r) {\n            return table[i];\n        } else {\n            return opTT(query(l, r, i*2, a, (a+b)/2), query(l, r, i*2+1, (a+b)/2+1, b));\n        }\n    }\n\n    void update(int l, int r, L val) {\n        if (l > r) return;\n        update(l, r, 1, 0, n-1, val);\n    }\n\n    void update(int l, int r, int i, int a, int b, L val) {\n        if (b < l || r < a) {\n            push(i, a, b);\n        } else if (l <= a && b <= r) {\n            lazy_[i] = opLL(lazy_[i], val);\n            push(i, a, b);\n        } else {\n            push(i, a, b);\n            update(l, r, i*2, a, (a+b)/2, val);\n            update(l, r, i*2+1, (a+b)/2+1, b, val);\n            table[i] = opTT(table[i*2], table[i*2+1]);\n        }\n    }\n}\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\nimport sys\nsys.setrecursionlimit(10**6)\ninput = sys.stdin.buffer.readline\nINF = 10 ** 9 + 1  # sys.maxsize # float(\"inf\")\nMOD = 10 ** 9 + 7\n\n\ndef debug(*x):\n    print(*x, file=sys.stderr)\n\n\ndef set_depth(depth):\n    global DEPTH, SEGTREE_SIZE, NONLEAF_SIZE\n    DEPTH = depth\n    SEGTREE_SIZE = 1 << DEPTH\n    NONLEAF_SIZE = 1 << (DEPTH - 1)\n\n\ndef set_width(width):\n    set_depth((width - 1).bit_length() + 1)\n\n\ndef get_size(pos):\n    ret = pos.bit_length()\n    return (1 << (DEPTH - ret))\n\n\ndef up(pos):\n    pos += SEGTREE_SIZE // 2\n    return pos // (pos & -pos)\n\n\ndef up_propagate(table, pos, binop):\n    while pos > 1:\n        pos >>= 1\n        table[pos] = binop(\n            table[pos * 2],\n            table[pos * 2 + 1]\n        )\n\n\ndef force_down_propagate(\n    action_table, value_table, pos,\n    action_composite, action_force, action_unity\n):\n    max_level = pos.bit_length() - 1\n    size = NONLEAF_SIZE\n    for level in range(max_level):\n        size //= 2\n        i = pos >> (max_level - level)\n        action = action_table[i]\n        if action != action_unity:\n            action_table[i * 2] = action\n            action_table[i * 2 + 1] = action\n            action_table[i] = action_unity\n            value_table[i * 2] = action * size\n            value_table[i * 2 + 1] = action * size\n\n\ndef force_range_update(\n    value_table, action_table, left, right,\n    action, action_force, action_composite, action_unity\n):\n    \"\"\"\n    action_force: action, value, cell_size => new_value\n    action_composite: new_action, old_action => composite_action\n    \"\"\"\n    left += NONLEAF_SIZE\n    right += NONLEAF_SIZE\n    while left < right:\n        if left & 1:\n            value_table[left] = action_force(\n                action, value_table[left], get_size(left))\n            action_table[left] = action_composite(action, action_table[left])\n            left += 1\n        if right & 1:\n            right -= 1\n            value_table[right] = action_force(\n                action, value_table[right], get_size(right))\n            action_table[right] = action_composite(action, action_table[right])\n\n        left //= 2\n        right //= 2\n\n\ndef range_reduce(table, left, right, binop, unity):\n    ret_left = unity\n    ret_right = unity\n    left += NONLEAF_SIZE\n    right += NONLEAF_SIZE\n    while left < right:\n        if left & 1:\n            ret_left = binop(ret_left, table[left])\n            left += 1\n        if right & 1:\n            right -= 1\n            ret_right = binop(table[right], ret_right)\n\n        left //= 2\n        right //= 2\n    return binop(ret_left, ret_right)\n\n\ndef lazy_range_update(\n        action_table, value_table, start, end,\n        action, action_composite, action_force, action_unity, value_binop):\n    \"update [start, end)\"\n    L = up(start)\n    R = up(end)\n    force_down_propagate(\n        action_table, value_table, L,\n        action_composite, action_force, action_unity)\n    force_down_propagate(\n        action_table, value_table, R,\n        action_composite, action_force, action_unity)\n\n    # print(\"action\", file=sys.stderr)\n    # debugprint(action_table)\n    # print(\"value\", file=sys.stderr)\n    # debugprint(value_table)\n    # print(file=sys.stderr)\n\n    force_range_update(\n        value_table, action_table, start, end,\n        action, action_force, action_composite, action_unity)\n    up_propagate(value_table, L, value_binop)\n    up_propagate(value_table, R, value_binop)\n\n\ndef lazy_range_reduce(\n    action_table, value_table, start, end,\n    action_composite, action_force, action_unity,\n    value_binop, value_unity\n):\n    \"reduce [start, end)\"\n    force_down_propagate(\n        action_table, value_table, up(start),\n        action_composite, action_force,  action_unity)\n    force_down_propagate(\n        action_table, value_table, up(end),\n        action_composite, action_force, action_unity)\n\n    return range_reduce(value_table, start, end, value_binop, value_unity)\n\n\ndef debugprint(xs, minsize=0, maxsize=None):\n    global DEPTH\n    strs = [str(x) for x in xs]\n    if maxsize != None:\n        for i in range(NONLEAF_SIZE, SEGTREE_SIZE):\n            strs[i] = strs[i][:maxsize]\n    s = max(len(s) for s in strs[NONLEAF_SIZE:])\n    if s > minsize:\n        minsize = s\n\n    result = [\"|\"] * DEPTH\n    level = 0\n    next_level = 2\n    for i in range(1, SEGTREE_SIZE):\n        if i == next_level:\n            level += 1\n            next_level *= 2\n        width = ((minsize + 1) << (DEPTH - 1 - level)) - 1\n        result[level] += strs[i].center(width) + \"|\"\n    print(*result, sep=\"\\n\", file=sys.stderr)\n\n\ndef main():\n    # parse input\n    from operator import add\n    N, Q = map(int, input().split())\n    set_width(N)\n\n    value_unity = 0\n    value_table = [0] * SEGTREE_SIZE\n    value_binop = add\n    action_unity = None\n    action_table = [action_unity] * SEGTREE_SIZE\n\n    def force(action, value, size):\n        if action == action_unity:\n            return value\n        return action * size\n\n    def composite(new_action, old_action):\n        if new_action != action_unity:\n            return new_action\n        return old_action\n\n    for _time in range(Q):\n        q, *args = map(int, input().split())\n        # debug(\": q,\", q, args)\n        if q == 0:\n            # update\n            s, t, value = args\n            lazy_range_update(\n                action_table, value_table, s, t + 1,\n                value, composite, force, action_unity, value_binop\n            )\n        else:\n            # getSum\n            s, t = args\n            print(lazy_range_reduce(\n                action_table, value_table, s, t + 1,\n                composite, force, action_unity, value_binop, value_unity))\n\n\n# tests\nT1 = \"\"\"\n6 7\n0 1 3 1\n0 2 4 -2\n1 0 5\n1 0 1\n0 3 5 3\n1 3 4\n1 0 5\n\"\"\"\nTEST_T1 = \"\"\"\n>>> as_input(T1)\n>>> main()\n-5\n1\n6\n8\n\"\"\"\n\n\ndef _test():\n    import doctest\n    doctest.testmod()\n    g = globals()\n    for k in sorted(g):\n        if k.startswith(\"TEST_\"):\n            doctest.run_docstring_examples(g[k], g)\n\n\ndef as_input(s):\n    \"use in test, use given string as input file\"\n    import io\n    global read, input\n    f = io.StringIO(s.strip())\n\n    def input():\n        return bytes(f.readline(), \"ascii\")\n\n    def read():\n        return bytes(f.read(), \"ascii\")\n\n\ninput = sys.stdin.buffer.readline\nread = sys.stdin.buffer.read\n\nif sys.argv[-1] == \"-t\":\n    print(\"testing\")\n    _test()\n    sys.exit()\n\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nN,Q=map(int,input().split())\n\nseg_el=1<<(N.bit_length()) # Segment treeの台の要素数\nseg_height=1+N.bit_length() # Segment treeの高さ\nSEG=[0]*(2*seg_el) # 1-indexedなので、要素数2*seg_el.Segment treeの初期値で初期化\nLAZY=[None]*(2*seg_el) # 1-indexedなので、要素数2*seg_el.Segment treeの初期値で初期化\n\ndef indexes(L,R): # 遅延伝搬すべきノードのリストを返す. （つまり, updateやgetvaluesで見るノードより上にあるノードたち）\n    INDLIST=[]\n\n    R-=1\n    \n    L>>=1\n    R>>=1\n\n    while L!=R:\n        if L>R:\n            INDLIST.append(L)\n            L>>=1\n        else:\n            INDLIST.append(R)\n            R>>=1\n\n    while L!=0:\n        INDLIST.append(L)\n        L>>=1\n\n    return INDLIST\n\ndef updates(l,r,x): # 区間[l,r)をxに更新\n        \n    L=l+seg_el\n    R=r+seg_el\n\n    L//=(L & (-L))\n    R//=(R & (-R))\n\n    UPIND=indexes(L,R)\n    \n    for ind in UPIND[::-1]: # 遅延伝搬\n        if LAZY[ind]!=None:\n            update_lazy = LAZY[ind] *(1<<(seg_height - 1 - (ind.bit_length())))\n            LAZY[ind<<1]=LAZY[1+(ind<<1)]=LAZY[ind]\n            SEG[ind<<1]=SEG[1+(ind<<1)]=update_lazy\n            LAZY[ind]=None\n\n    while L!=R:\n        if L > R:\n            SEG[L]=x * (1<<(seg_height - (L.bit_length())))\n            LAZY[L]=x\n            L+=1\n            L//=(L & (-L))\n\n        else:\n            R-=1\n            SEG[R]=x * (1<<(seg_height - (R.bit_length())))\n            LAZY[R]=x\n            R//=(R & (-R))\n\n    for ind in UPIND:\n        SEG[ind]=SEG[ind<<1]+SEG[1+(ind<<1)]\n\ndef getvalues(l,r): # 区間[l,r)に関するminを調べる\n\n    L=l+seg_el\n    R=r+seg_el\n\n    L//=(L & (-L))\n    R//=(R & (-R))\n\n    UPIND=indexes(L,R)\n    \n    for ind in UPIND[::-1]: # 遅延伝搬\n        if LAZY[ind]!=None:\n            update_lazy = LAZY[ind] *(1<<(seg_height - 1 - (ind.bit_length())))\n            LAZY[ind<<1]=LAZY[1+(ind<<1)]=LAZY[ind]\n            SEG[ind<<1]=SEG[1+(ind<<1)]=update_lazy\n            LAZY[ind]=None\n            \n    ANS=0\n\n    while L!=R:\n        if L > R:\n            ANS+=SEG[L]\n            L+=1\n            L//=(L & (-L))\n\n        else:\n            R-=1\n            ANS+=SEG[R]\n            R//=(R & (-R))\n\n    return ANS\n\nANS=[]\nfor _ in range(Q):\n    query=list(map(int,input().split()))\n\n    if query[0]==0:\n        updates(query[1],query[2]+1,query[3])\n\n    else:\n        ANS.append(getvalues(query[1],query[2]+1))\n    \nprint(\"\\n\".join([str(ans) for ans in ANS]))\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nn, q = map(int, input().split())\n\nLen = (n-1).bit_length()\nsize = 2**Len\ntree = [0]*(2*size)\nlazy = [None]*(2*size)\nh = [None]\nfor i in range(Len+1):\n    v = 2**(Len-i)\n    h += [v]*(2**i)\n\ndef gindex(l,r):\n    L = (l+size)>>1;R=(r+size)>>1\n    lc = 0 if l & 1 else (L&-L).bit_length()\n    rc = 0 if r & 1 else (R&-R).bit_length()\n    for i in range(Len):\n        if rc <= i:\n            yield R\n        if L < R and lc <= i:\n            yield L\n        L >>= 1; R >>= 1\n        \ndef propagates(ids):\n    for i in reversed(ids):\n        v = lazy[i]\n        if v is None:\n            continue\n        lazy[2*i] = tree[2*i] = lazy[2*i+1] = tree[2*i+1] = v//2\n        lazy[i]=None\n\ndef update(l,r,x):\n    *ids, = gindex(l, r)\n    propagates(ids)\n    L = size+l\n    R = size+r\n    while L<R:\n        if R&1:\n            R -= 1\n            lazy[R] = tree[R] = x*h[R]\n        if L&1:\n            lazy[L] = tree[L] = x*h[L]\n            L+=1\n        L>>=1;R>>=1\n    for i in ids:\n        if 2*i+1<size*2:\n            tree[i]= tree[i*2]+tree[i*2+1]\n        \ndef query(l, r):\n    *ids, = gindex(l, r)\n    propagates(ids)\n    L = size + l\n    R = size + r\n    s = 0\n    while L<R:\n        if R&1:\n            R-=1\n            s +=tree[R]\n        if L&1:\n            s +=tree[L]\n            L+=1\n        L>>=1;R>>=1\n    return s\n\nans = []\nfor i in range(q):\n    a, *b = map(int, input().split())\n    if a:\n        ans.append(query(b[0],b[1]+1))\n    else:\n        update(b[0],b[1]+1,b[2])\nprint('\\n'.join(map(str,ans)))\n"
  },
  {
    "language": "Python",
    "code": "class LazySegmentTree:\n    \"\"\"\n    op: 区間取得クエリでreduceする際に使う演算子\n    apply: 更新則の(n回)適用\n    comp: 更新則の合成\n    rep: f(x,m)+f(y,m) != f(x+y,m)となる場合に、m^nを高速に計算する用\n    \n    range_query: reduce(op, (apply(x,m) for x,m in zip(X,M)))\n    \n    満たすべき性質:\n    \n    集合X (要素)\n    op[+]: X,X -> X\n    (X, op)はモノイド\n    \n    集合M (更新則)\n    comp[*]: M,M -> M\n    (M, compose)はモノイド\n    \n    apply[f(x,m,n)]: X,M,Z+ -> X\n    (Z+は区間長)\n    \n    f(x,e_M,n) = x\n    f(x,m*n,p) = f(f(x,m,p),n,p)\n    f(x,m,p)+f(y,m,q) = f(x+y,m,p+q)\n    \n    参考: https://algo-logic.info/segment-tree/#toc_id_3\n    \"\"\"\n    @classmethod\n    def all_identity(cls, op, op_e, comp, comp_e, apply, size):\n        size = 2 << (size-1).bit_length()\n        return cls(\n            op,\n            op_e,\n            comp,\n            comp_e,\n            apply,\n            [op_e]*size,\n            [comp_e]*size\n        )\n\n    @classmethod\n    def from_initial_data(cls, op, op_e, comp, comp_e, apply, data):\n        size = 1 << (len(data)-1).bit_length()\n        temp = [op_e]*(2*size)\n        temp[size:size+len(data)] = data\n\n        for i in reversed(range(size)):\n            temp[i] = op(temp[2*i],temp[2*i+1])\n        return cls(\n            op,\n            op_e,\n            comp,\n            comp_e,\n            apply,\n            temp,\n            [comp_e]*size\n        )\n\n    # これ使わずファクトリーメソッド使いましょうね\n    def __init__(self, op, op_e, comp, comp_e, apply, data, lazy):\n        self.op = op\n        self.op_e = op_e\n        self.comp = comp\n        self.comp_e = comp_e\n        self.apply = apply\n        self.data = data\n        self.lazy = lazy\n        self.size = len(self.data)//2\n        self.depth = self.size.bit_length()-1\n        self._l_indices = [0]*self.depth\n        self._r_indices = [0]*self.depth\n    \n    def _update_indices(self, i, l):\n        m = i//(i&-i)\n        i >>= 1\n        for k in reversed(range(self.depth)):\n            l[k] = i if i < m else 0\n            i >>= 1\n    \n    \n    def _propagate_top_down(self):\n        data = self.data\n        lazy = self.lazy\n        apply = self.apply\n        comp = self.comp\n        comp_e = self.comp_e\n        k = self.size >> 1\n        \n        for i,j in zip(self._l_indices, self._r_indices):\n            if i > 0:\n                temp = self.lazy[i]\n                if temp != comp_e:\n                    lazy[i] = comp_e\n                    a = i << 1\n                    b = (i << 1) | 1\n                    lazy[a] = comp(lazy[a], temp)\n                    data[a] = apply(data[a], temp, k)\n                    lazy[b] = comp(lazy[b], temp)\n                    data[b] = apply(data[b], temp, k)\n            if i < j:\n                temp = self.lazy[j]\n                if temp != comp_e:\n                    lazy[j] = comp_e\n                    a = j << 1\n                    b = (j << 1) | 1\n                    lazy[a] = comp(lazy[a], temp)\n                    data[a] = apply(data[a], temp, k)\n                    lazy[b] = comp(lazy[b], temp)\n                    data[b] = apply(data[b], temp, k)\n            k >>= 1\n            \n    def _propagate_bottom_up(self):\n        data = self.data\n        op = self.op\n        for i,j in zip(reversed(self._l_indices), reversed(self._r_indices)):\n            if i > 0:\n                data[i] = op(data[2*i],data[2*i+1])\n            if i < j:\n                data[j] = op(data[2*j],data[2*j+1])\n    \n    def update_interval(self, l, r, m):\n        lazy = self.lazy\n        data = self.data\n        comp = self.comp\n        apply = self.apply\n        \n        l += self.size\n        r += self.size\n        self._update_indices(l, self._l_indices)\n        self._update_indices(r, self._r_indices)\n        self._propagate_top_down()\n        k = 1\n        while l < r:\n            if l & 1:\n                lazy[l] = comp(lazy[l],m)\n                data[l] = apply(data[l],m,k)\n                l += 1\n            if r & 1:\n                r -= 1\n                lazy[r] = comp(lazy[r],m)\n                data[r] = apply(data[r],m,k)\n            l >>= 1\n            r >>= 1\n            k <<= 1\n        self._propagate_bottom_up()\n    \n    def get_interval(self, l, r):\n        data = self.data\n        op = self.op\n        \n        l += self.size\n        r += self.size\n        self._update_indices(l, self._l_indices)\n        self._update_indices(r, self._r_indices)\n        self._propagate_top_down()\n        \n        lx = self.op_e\n        rx = self.op_e\n        while l < r:\n            if l & 1:\n                lx = op(lx, data[l])\n                l += 1\n            if r & 1:\n                r -= 1\n                rx = op(data[r], rx)\n            l >>= 1\n            r >>= 1\n        return op(lx,rx)\n\n\n\n\nimport sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\n\nfrom operator import add\n\nif __name__ == '__main__':\n    n,q = map(int,readline().split())\n    temp = map(int,read().split())\n\n    seg = LazySegmentTree.all_identity(\n        add,\n        0,\n        lambda x,y: x if y is None else y,\n        None,\n        lambda x,m,l: x if m is None else m*l,\n        n)\n\n    try:\n        while True:\n            mode = next(temp)\n            if mode:\n                l,r = next(temp), next(temp)+1\n                print(seg.get_interval(l,r))\n            else:\n                l,r,x = next(temp), next(temp)+1, next(temp)\n                seg.update_interval(l,r,x)\n    except StopIteration:\n        pass\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\nN, Q = map(int, input().split())\nINF = 2**31-1\n\nLV = (N-1).bit_length()\nN0 = 2**LV\ndata = [0]*(2*N0)\nlazy = [None]*(2*N0)\n\ndef gindex(l, r):\n    L = (l + N0) >> 1; R = (r + N0) >> 1\n    lc = 0 if l & 1 else (L & -L).bit_length()\n    rc = 0 if r & 1 else (R & -R).bit_length()\n    v = 2\n    for i in range(LV):\n        if rc <= i:\n            yield R\n        if L < R and lc <= i:\n            yield L\n        L >>= 1; R >>= 1; v <<= 1\n\ndef propagates(*ids):\n    for i in reversed(ids):\n        v = lazy[i-1]\n        if v is None:\n            continue\n        lazy[2*i-1] = lazy[2*i] = data[2*i-1] = data[2*i] = v >> 1\n        lazy[i-1] = None\n\ndef update(l, r, x):\n    *ids, = gindex(l, r)\n    propagates(*ids)\n\n    L = N0 + l; R = N0 + r\n    v = x\n    while L < R:\n        if R & 1:\n            R -= 1\n            lazy[R-1] = data[R-1] = v\n        if L & 1:\n            lazy[L-1] = data[L-1] = v\n            L += 1\n        L >>= 1; R >>= 1; v <<= 1\n    for i in ids:\n        data[i-1] = data[2*i-1] + data[2*i]\n\ndef query(l, r):\n    propagates(*gindex(l, r))\n    L = N0 + l; R = N0 + r\n\n    s = 0\n    while L < R:\n        if R & 1:\n            R -= 1\n            s += data[R-1]\n        if L & 1:\n            s += data[L-1]\n            L += 1\n        L >>= 1; R >>= 1\n    return s\n\n\nans = []\nfor q in range(Q):\n    t, *cmd = map(int, readline().split())\n    if t:\n        s, t = cmd\n        ans.append(str(query(s, t+1)))\n    else:\n        s, t, x = cmd\n        update(s, t+1, x)\n\nwrite(\"\\n\".join(ans))\nwrite(\"\\n\")\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# DSL_2_I: RSQ and RUQ\n# Range Sum Query and Range Update Query\n\nimport sys\n\n\nclass SegmentTree:\n\n    def __init__(self, n):\n        size = 2 ** (n.bit_length())\n        self.size = 2*size - 1\n        self.data = [0] * self.size\n        self.lazy = [None] * self.size\n\n    def update(self, lo, hi, v):\n        def _update(r, i, j, lz):\n            left, right = r*2 + 1, r*2 + 2\n            if lz is None:\n                lz = lazy[r]\n            lazy[r] = None\n\n            if lo <= i and j <= hi:\n                data[r] = v * (j - i + 1)\n                if i < j:\n                    lazy[left] = v\n                    lazy[right] = v\n            else:\n                mid = (i + j) // 2\n                if mid >= lo:\n                    lv = _update(left, i, mid, lz)\n                else:\n                    if lz is not None:\n                        lazy[left] = lz\n                        lv = lz * (mid - i + 1)\n                    elif lazy[left] is not None:\n                        lv = lazy[left] * (mid - i + 1)\n                    else:\n                        lv = data[left]\n\n                if mid < hi:\n                    rv = _update(right, mid+1, j, lz)\n                else:\n                    if lz is not None:\n                        lazy[right] = lz\n                        rv = lz * (j - mid)\n                    elif lazy[right] is not None:\n                        rv = lazy[right] * (j - mid)\n                    else:\n                        rv = data[right]\n\n                data[r] = lv + rv\n\n            return data[r]\n\n        data = self.data\n        lazy = self.lazy\n        _update(0, 0, self.size//2, None)\n\n    def sum(self, lo, hi):\n        def _sum(r, i, j, lz):\n            if lz is None:\n                lz = lazy[r]\n            lazy[r] = None\n            if lz is not None:\n                data[r] = lz * (j - i + 1)\n\n            left, right = r*2 + 1, r*2 + 2\n            if lo <= i and j <= hi:\n                if lz is not None and i < j:\n                    lazy[left] = lz\n                    lazy[right] = lz\n                return data[r]\n            else:\n                mid = (i + j) // 2\n                lv, rv = 0, 0\n\n                if mid >= lo:\n                    lv = _sum(left, i, mid, lz)\n                else:\n                    if lz is not None:\n                        lazy[left] = lz\n                if mid < hi:\n                    rv = _sum(right, mid+1, j, lz)\n                else:\n                    if lz is not None:\n                        lazy[right] = lz\n                return lv + rv\n\n        data = self.data\n        lazy = self.lazy\n        return _sum(0, 0, self.size//2, None)\n\n\ndef run():\n    n, q = [int(i) for i in input().split()]\n    tree = SegmentTree(n)\n\n    for line in sys.stdin:\n        com, *args = line.split()\n        if com == '0':\n            s, t, x = [int(i) for i in args]\n            tree.update(s, t, x)\n        elif com == '1':\n            s, t = [int(i) for i in args]\n            print(tree.sum(s, t))\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "from typing import Optional\n\n\nclass SegmentTree(object):\n    def __init__(self, n: int) -> None:\n        size = 2 ** (n.bit_length())\n        self.size = 2 * size - 1\n        self.data = [0] * self.size\n        self.lazy = [None] * self.size\n\n    def update(self, lo: int, hi: int, v: int) -> None:\n        def _update(r: int, i: int, j: int, lz: Optional[int]) -> int:\n            left, right = r * 2 + 1, r * 2 + 2\n            if (lz is None):\n                lz = lazy[r]\n            lazy[r] = None\n\n            if (lo <= i and j <= hi):\n                data[r] = v * (j - i + 1)\n                if (i < j):\n                    lazy[left] = v\n                    lazy[right] = v\n            else:\n                mid = (i + j) // 2\n                if (mid >= lo):\n                    lv = _update(left, i, mid, lz)\n                else:\n                    if (lz is not None):\n                        lazy[left] = lz\n                        lv = lz * (mid - i + 1)\n                    elif (lazy[left] is not None):\n                        lv = lazy[left] * (mid - i + 1)\n                    else:\n                        lv = data[left]\n\n                if (mid < hi):\n                    rv = _update(right, mid + 1, j, lz)\n                else:\n                    if (lz is not None):\n                        lazy[right] = lz\n                        rv = lz * (j - mid)\n                    elif (lazy[right] is not None):\n                        rv = lazy[right] * (j - mid)\n                    else:\n                        rv = data[right]\n\n                data[r] = lv + rv\n\n            return data[r]\n\n        data = self.data\n        lazy = self.lazy\n        _update(0, 0, self.size // 2, None)\n\n    def sum(self, lo: int, hi: int) -> int:\n        def _sum(r: int, i: int, j: int, lz: Optional[int]) -> int:\n            if (lz is None):\n                lz = lazy[r]\n            lazy[r] = None\n            if (lz is not None):\n                data[r] = lz * (j - i + 1)\n\n            left, right = r * 2 + 1, r * 2 + 2\n            if (lo <= i and j <= hi):\n                if (lz is not None and i < j):\n                    lazy[left] = lz\n                    lazy[right] = lz\n                return data[r]\n            else:\n                mid = (i + j) // 2\n                lv, rv = 0, 0\n\n                if (mid >= lo):\n                    lv = _sum(left, i, mid, lz)\n                else:\n                    if (lz is not None):\n                        lazy[left] = lz\n                if (mid < hi):\n                    rv = _sum(right, mid + 1, j, lz)\n                else:\n                    if (lz is not None):\n                        lazy[right] = lz\n                return lv + rv\n\n        data = self.data\n        lazy = self.lazy\n        return _sum(0, 0, self.size // 2, None)\n\n\nif __name__ == \"__main__\":\n    n, q = map(lambda x: int(x), input().split())\n    segtree = SegmentTree(n)\n\n    for _ in range(q):\n        com, *v = map(lambda x: int(x), input().split())\n        if (0 == com):\n            segtree.update(v[0], v[1], v[2])\n        else:\n            print(segtree.sum(v[0], v[1]))\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\nclass LazyPropSegmentTree:\n    def __init__(self, lst, op, apply, comp, e, identity):\n        self.n = len(lst)\n        self.depth = (self.n - 1).bit_length()\n        self.N = 1 << self.depth\n        self.op = op # binary operation of elements\n        self.apply = apply # function to apply to an element\n        self.comp = comp # composition of functions\n        self.e = e # identity element w.r.t. op\n        self.identity = identity # identity element w.r.t. comp\n        self.v, self.length = self._build(lst) # self.v is set to be 1-indexed for simplicity\n        self.lazy = [self.identity] * (2 * self.N)\n    \n    def __getitem__(self, i):\n        return self.fold(i, i+1)\n    \n    def _build(self, lst):\n        # construction of a tree\n        # total 2 * self.N elements (tree[0] is not used)\n        e, N, op = self.e, self.N, self.op\n        tree = [e] * N + lst + [e] * (N - self.n)\n        length = [1] * (2 * N)\n        for i in range(N - 1, 0, -1):\n            lc, rc = i << 1, (i << 1)|1\n            tree[i] = op(tree[lc], tree[rc])\n            length[i] = length[lc] + length[rc]\n        return tree, length\n    \n    def _indices(self, l, r):\n        left = l + self.N; right = r + self.N\n        left //= (left & (-left)); right //= (right & (-right))\n        left >>= 1; right >>= 1\n        while left != right:\n            if left > right: yield left; left >>= 1\n            else: yield right; right >>= 1\n        while left > 0: yield left; left >>= 1\n    \n    # propagate self.lazy and self.v in a top-down manner\n    def _propagate_topdown(self, *indices):\n        identity, v, lazy, length, apply, comp = self.identity, self.v, self.lazy, self.length, self.apply, self.comp\n        for k in reversed(indices):\n            x = lazy[k]\n            if x == identity: continue\n            lc, rc = k << 1, (k << 1) | 1\n            v[lc] = apply(v[lc], x, length[lc])\n            lazy[lc] = comp(lazy[lc], x)\n            v[rc] = apply(v[rc], x, length[rc])\n            lazy[rc] = comp(lazy[rc], x)\n            lazy[k] = identity # propagated\n\n    # propagate self.v in a bottom-up manner\n    def _propagate_bottomup(self, indices):\n        v, op = self.v, self.op\n        for k in indices: v[k] = op(v[k << 1], v[(k << 1)|1])\n\n    # update for the query interval [l, r) with function x\n    def update(self, l, r, x):\n        *indices, = self._indices(l, r)\n        self._propagate_topdown(*indices)\n\n        N, v, lazy, length, apply, comp = self.N, self.v, self.lazy, self.length, self.apply, self.comp\n        \n        # update self.v and self.lazy for the query interval [l, r)\n        left = l + N; right = r + N\n        if left & 1: v[left] = apply(v[left], x, length[left]); left += 1\n        if right & 1: right -= 1; v[right] = apply(v[right], x, length[right])\n        left >>= 1; right >>= 1\n        while left < right:\n            if left & 1:\n                v[left] = apply(v[left], x, length[left])\n                lazy[left] = comp(lazy[left], x)\n                left += 1\n            if right & 1:\n                right -= 1\n                v[right] = apply(v[right], x, length[right])\n                lazy[right] = comp(lazy[right], x)\n            left >>= 1; right >>= 1\n        self._propagate_bottomup(indices)\n    \n    # returns answer for the query interval [l, r)\n    def fold(self, l, r):\n        self._propagate_topdown(*self._indices(l, r))\n        \n        e, N, v, op = self.e, self.N, self.v, self.op\n        \n        # calculate the answer for the query interval [l, r)\n        left = l + N; right = r + N\n        L = R = e\n        while left < right:\n            if left & 1: # self.v[left] is the right child\n                L = op(L, v[left])\n                left += 1\n            if right & 1: # self.v[right-1] is the left child\n                right -= 1\n                R = op(v[right], R)\n            left >>= 1; right >>= 1\n        return op(L, R)\n    \nN, Q = map(int, input().split())\nop = lambda x, y: x + y\napply = lambda x, f, l: f * l\ncomp = lambda f, g: g\ne = 0\nidentity = None\nA = [0] * N\nlpsg = LazyPropSegmentTree(A, op, apply, comp, e, identity)\nans = []\nfor _ in range(Q):\n    t, *arg, = map(int, input().split())\n    if t == 0:\n        s, t, x = arg\n        lpsg.update(s, t+1, x)\n    else:\n        s, t = arg\n        ans.append(lpsg.fold(s, t+1))\nprint('\\n'.join(map(str, ans)))\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\nfrom operator import add\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 2 ** 31 - 1\nMOD = 10 ** 9 + 7\n\nclass SegTreeLazy:\n    \"\"\" 遅延評価セグメント木(区間更新、区間合計取得) \"\"\"\n\n    def __init__(self, N, func, intv):\n        self.intv = intv\n        self.func = func\n        self.LV = (N-1).bit_length()\n        self.N0 = 2**self.LV\n        self.data = [intv]*(2*self.N0)\n        self.lazy = [None]*(2*self.N0)\n\n    # 伝搬される区間のインデックス(1-indexed)を全て列挙するgenerator\n    def gindex(self, l, r):\n        L = (l + self.N0) >> 1; R = (r + self.N0) >> 1\n        lc = 0 if l & 1 else (L & -L).bit_length()\n        rc = 0 if r & 1 else (R & -R).bit_length()\n        v = 2\n        for i in range(self.LV):\n            if rc <= i:\n                yield R\n            if L < R and lc <= i:\n                yield L\n            L >>= 1; R >>= 1; v <<= 1\n\n    # 遅延評価の伝搬処理\n    def propagates(self, *ids):\n        # 1-indexedで単調増加のインデックスリスト\n        for i in reversed(ids):\n            v = self.lazy[i-1]\n            if v is None:\n                continue\n            self.lazy[2*i-1] = self.data[2*i-1] = self.lazy[2*i] = self.data[2*i] = v >> 1\n            self.lazy[i-1] = None\n\n    def update(self, l, r, x):\n        \"\"\" 区間[l,r)の値をxに更新 \"\"\"\n\n        *ids, = self.gindex(l, r)\n        # 1. トップダウンにlazyの値を伝搬\n        self.propagates(*ids)\n        # 2. 区間[l,r)のdata, lazyの値を更新\n        L = self.N0 + l; R = self.N0 + r\n        v = x\n        while L < R:\n            if R & 1:\n                R -= 1\n                self.lazy[R-1] = self.data[R-1] = v\n            if L & 1:\n                self.lazy[L-1] = self.data[L-1] = v\n                L += 1\n            L >>= 1; R >>= 1; v <<= 1\n        # 3. 伝搬させた区間について、ボトムアップにdataの値を伝搬する\n        for i in ids:\n            self.data[i-1] = self.func(self.data[2*i-1], self.data[2*i])\n\n    def query(self, l, r):\n        \"\"\" 区間[l,r)の和を取得 \"\"\"\n\n        # 1. トップダウンにlazyの値を伝搬\n        self.propagates(*self.gindex(l, r))\n        L = self.N0 + l; R = self.N0 + r\n\n        # 2. 区間[l, r)の和を求める\n        s = self.intv\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = self.func(s, self.data[R-1])\n            if L & 1:\n                s = self.func(s, self.data[L-1])\n                L += 1\n            L >>= 1; R >>= 1\n        return s\n\nN, Q = MAP()\nstl = SegTreeLazy(N+1, add, 0)\n\nans = []\nfor i in range(Q):\n    cmd, *arg = MAP()\n    if cmd == 0:\n        s, t, x = arg\n        stl.update(s, t+1, x)\n    else:\n        s, t = arg\n        ans.append(str(stl.query(s, t+1)))\nprint('\\n'.join(ans))\n\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(non_snake_case)]\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ( $x:ident [ $i:expr ] ) => {\n        if cfg!(debug_assertions) {\n            println!(\"{}[{}] = {:?}\", stringify!($x), $i, $x[$i]);\n        }\n    };\n    ( $x:ident [ $i:expr ][ $j:expr ] ) => {\n        if cfg!(debug_assertions) {\n            println!(\"{}[{}][{}] = {:?}\", stringify!($x), $i, $j, $x[$i][$j]);\n        }\n    };\n    ( $x:expr ) => {\n        if cfg!(debug_assertions) {\n            println!(\"{}:{} {} = {:?}\", line!(), column!(), stringify!($x), $x);\n        }\n    };\n}\n\n/// Return the smallest power of 2 such that<br>\n/// it is greater than or equal to <code>x</code>.\n/// # Panics\n/// <code>x == 0</code> will cause underflow.\npub fn clp(mut x: usize) -> usize {\n    x -= 1;\n    x = x | (x >>  1);\n    x = x | (x >>  2);\n    x = x | (x >>  4);\n    x = x | (x >>  8);\n    x = x | (x >> 16);\n    x = x | (x >> 32);\n    x + 1\n}\n\nstruct RangeUpdateQuery {\n    n: usize,\n    a: Vec<Option<i64>>,\n}\n\nimpl RangeUpdateQuery {\n    pub fn new(m: usize) -> Self {\n        let n = clp(m);\n        Self {\n            n: n,\n            a: vec![Some(0); 2 * n - 1]\n        }\n    }\n\n    fn _update(&mut self, update_first: usize, update_last: usize, new_value: i64, node: usize, node_first: usize, node_last: usize) {\n        //println!(\"update_first = {}, update_last = {}, node = {}, node_first = {}, node_last = {}\",\n        //    update_first, update_last, node, node_first, node_last);\n        if node_last <= update_first || update_last <= node_first {\n            //println!(\"nothing to do\");\n            return;\n        } else if update_first <= node_first && node_last <= update_last {\n            //println!(\"change all elements\");\n            self.a[node] = Some(new_value);\n        } else {\n            //println!(\"split\");\n            if self.a[node].is_some() {\n                self.a[2 * node + 1] = self.a[node];\n                self.a[2 * node + 2] = self.a[node];\n                self.a[node] = None;\n            }\n            let node_mid: usize = node_first + (node_last - node_first) / 2;\n            self._update(update_first, update_last, new_value, 2 * node + 1, node_first, node_mid);\n            self._update(update_first, update_last, new_value, 2 * node + 2, node_mid, node_last);\n        }\n    }\n\n    pub fn update(&mut self, update_first: usize, update_last: usize, new_value: i64) {\n        let n = self.n;\n        self._update(update_first, update_last, new_value, 0, 0, n);\n    }\n\n    fn _query(&self, query_first: usize, query_last: usize, node: usize, node_first: usize, node_last: usize) -> i64 {\n        //println!(\"query_first = {}, query_last = {}, node = {}, node_first = {}, node_last = {}\",\n            //query_first, query_last, node, node_first, node_last);\n        if node_last <= query_first || query_last <= node_first {\n            //println!(\"out of search scope, return unit\");\n            0\n        } else if self.a[node].is_some() {\n            let ret = self.a[node].unwrap() * (std::cmp::min(query_last, node_last) - std::cmp::max(query_first, node_first)) as i64;\n            //println!(\"already calculated, return {:?}\", ret);\n            ret\n        } else {\n            //println!(\"new calculation start\");\n            let node_mid: usize = node_first + (node_last - node_first) / 2;\n            let left: i64 = self._query(query_first, query_last, node * 2 + 1, node_first, node_mid);\n            let right: i64 = self._query(query_first, query_last, node * 2 + 2, node_mid, node_last);\n            //println!(\"new calculation end. return {:?}\", (self.f)(left, right));\n            left + right\n        }\n    }\n\n    pub fn query(&self, first: usize, last: usize) -> i64 {\n        self._query(first, last, 0, 0, self.n)\n    }\n}\n\nfn main() {\n    use std::io::{Write, BufWriter};\n\n    let stdin = std::io::stdin();\n    let mut stdin = my::io::InputReader::new(stdin.lock());\n    let stdout = std::io::stdout();\n    let mut stdout = BufWriter::new(stdout);\n\n    let n: usize = stdin.read();\n    let q: usize = stdin.read();\n    let mut ruq = RangeUpdateQuery::new(n);\n    for _ in 0..q {\n        let query_type: i32 = stdin.read();\n        if query_type == 0 {\n            let first: usize = stdin.read();\n            let last: usize = stdin.read::<usize>() + 1;\n            let x: i64 = stdin.read();\n            //println!(\"update query [{}, {}) <- {}\", first, last, x);\n            ruq.update(first, last, x);\n        } else if query_type == 1 {\n            let first: usize = stdin.read();\n            let last: usize = stdin.read::<usize>() + 1;\n            //println!(\"search query [{}, {})\", first, last);\n            stdout.write_fmt(format_args!(\"{}\\n\", ruq.query(first, last)));\n        }\n        //println!(\"\");\n    }\n}\n\n#[allow(unused_must_use)]\nmod my {\n    pub mod io {\n        use std::io::{BufRead, ErrorKind, Result};\n        use std::str::{FromStr, from_utf8};\n        use std::fmt::Debug;\n\n        pub fn read_word<R: BufRead>(r: &mut R, buf: &mut Vec<u8>)\n                                              -> Result<usize> {\n            let mut read = 0;\n            loop {\n                let (done, used) = {\n                    let available = match r.fill_buf() {\n                        Ok(n) => n,\n                        Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n                        Err(e) => return Err(e)\n                    };\n                    match available.iter().position(|&x| x == b'\\n' || x == b' ') {\n                        Some(i) => {\n                            buf.extend_from_slice(&available[..i]);\n                            (true, i + 1)\n                        }\n                        None => {\n                            buf.extend_from_slice(available);\n                            (false, available.len())\n                        }\n                    }\n                };\n                r.consume(used);\n                read += used;\n                if done || used == 0 {\n                    return Ok(read);\n                }\n            }\n        }\n\n        pub struct InputReader<R: BufRead> {\n            reader: R,\n            buf: Vec<u8>,\n        }\n\n        impl<R: BufRead> InputReader<R> {\n            pub fn new(reader: R) -> InputReader<R> {\n                InputReader {\n                    reader: reader,\n                    buf: Vec::<u8>::new(),\n                }\n            }\n\n            pub fn read_word(&mut self) {\n                read_word(&mut self.reader, &mut self.buf);\n            }\n            \n            pub fn read<T>(&mut self) -> T\n                where T: FromStr,\n                      T::Err: Debug\n            {\n                self.buf.clear();\n                self.read_word();\n                from_utf8(&self.buf).unwrap().trim().parse().unwrap()\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "// ---------- begin Lazy Segment Tree ----------\nmod segment_tree {\n    pub struct Lazy<T, E, F, G, H> {\n        n: usize,\n        k: usize,\n        a: Vec<(T, E)>,\n        e: T,\n        id: E,\n        f: F,\n        g: G,\n        h: H,\n    }\n    #[allow(dead_code)]\n    impl<T: Clone, E: Clone, F: Fn(T, T) -> T, G: Fn(T, E) -> T, H: Fn(E, E) -> E> Lazy<T, E, F, G, H> {\n        pub fn new(n: usize, e: T, id: E, f: F, g: G, h: H) -> Lazy<T, E, F, G, H> {\n            let mut k = 0;\n            while (1 << k) < n {\n                k += 1;\n            }\n            Lazy {\n                n: 1 << k,\n                k: k,\n                a: vec![(e.clone(), id.clone()); 2 << k],\n                e: e,\n                id: id,\n                f: f,\n                g: g,\n                h: h,\n            }\n        }\n        pub fn build_by(z: &Vec<T>, e: T, id: E, f: F, g: G, h: H) -> Lazy<T, E, F, G, H> {\n            let n = z.len();\n            let mut k = 0;\n            while (1 << k) < n {\n                k += 1;\n            }\n            let mut a = vec![(e.clone(), id.clone()); 2 << k];\n            for i in 0..n {\n                a[(1 << k) + i].0 = z[i].clone();\n            }\n            for i in (1..(1 << k)).rev() {\n                let l = g(a[2 * i].0.clone(), id.clone());\n                let r = g(a[2 * i + 1].0.clone(), id.clone());\n                a[i].0 = f(l, r);\n            }\n            Lazy {\n                n: 1 << k,\n                k: k,\n                a: a,\n                e: e,\n                id: id,\n                f: f,\n                g: g,\n                h: h,\n            }\n        }\n        fn eval (&self, x: usize) -> T {\n            (self.g)(self.a[x].0.clone(), self.a[x].1.clone())\n        }\n        fn propagate (&mut self, mut x: usize) {\n            x += self.n;\n            for k in (1..(self.k + 1)).rev() {\n                let y = x >> k;\n                self.a[2 * y].1 = (self.h)(self.a[2 * y].1.clone(), self.a[y].1.clone());\n                self.a[2 * y + 1].1 = (self.h)(self.a[2 * y + 1].1.clone(), self.a[y].1.clone());\n                self.a[y].1 = self.id.clone();\n                self.a[y].0 = (self.f)(self.eval(2 * y), self.eval(2 * y + 1));\n            }\n        }\n        fn save (&mut self, x: usize) {\n            let mut k = (x + self.n) >> 1;\n            while k > 0 {\n                self.a[k].0 = (self.f)(self.eval(2 * k), self.eval(2 * k + 1));\n                k >>= 1;\n            }\n        }\n        pub fn update (&mut self, l: usize, r: usize, p: E) {\n            self.propagate(l);\n            self.propagate(r - 1);\n            let mut x = l + self.n;\n            let mut y = r + self.n;\n            while x < y {\n                if (x & 1) == 1 {\n                    self.a[x].1 = (self.h)(self.a[x].1.clone(), p.clone());\n                    x += 1;\n                }\n                if (y & 1) == 1 {\n                    y -= 1;\n                    self.a[y].1 = (self.h)(self.a[y].1.clone(), p.clone());\n                }\n                x >>= 1;\n                y >>= 1;\n            }\n            self.save(l);\n            self.save(r - 1);\n        }\n        pub fn find (&mut self, l: usize, r: usize) -> T {\n            self.propagate(l);\n            self.propagate(r - 1);\n            let mut p = self.e.clone();\n            let mut q = self.e.clone();\n            let mut x = l + self.n;\n            let mut y = r + self.n;\n            while x < y {\n                if (x & 1) == 1 {\n                    p = (self.f)(p, self.eval(x));\n                    x += 1;\n                }\n                if (y & 1) == 1 {\n                    y -= 1;\n                    q = (self.f)(self.eval(y), q);\n                }\n                x >>= 1;\n                y >>= 1;\n            }\n            (self.f)(p, q)\n        }\n    }\n}\n\n// ---------- end Lazy Segment Tree ----------\n//---------- begin scannner ----------\n#[allow(dead_code)]\nmod scanner {\n    use std::str::FromStr;\n    use std::str::SplitWhitespace;\n    use std::io::Read;\n    use std;\n    pub struct Scanner<'a> {\n        it: SplitWhitespace<'a>\n    }\n    impl<'a> Scanner<'a> {\n        pub fn new(s: &'a String) -> Scanner<'a> {\n            Scanner {\n                it: s.split_whitespace()\n            }\n        }\n        pub fn next<T: FromStr>(&mut self) -> T {\n            match self.it.next().unwrap().parse::<T>() {\n                Ok(v) => v,\n                _ => panic!(\"Scanner error\")\n            }\n        }\n        pub fn next_vec<T: FromStr>(&mut self, n: usize) -> Vec<T> {\n            (0..n).map(|_| self.next()).collect::<Vec<T>>()\n        }\n        pub fn next_chars(&mut self) -> Vec<char> {\n            self.next::<String>().chars().collect()\n        }\n    }\n    pub fn read_string() -> String {\n        let mut s = String::new();\n        std::io::stdin().read_to_string(&mut s).unwrap();\n        s\n    }\n}\n\n//---------- end scannner ----------\n\nuse std::io::Write;\n\nfn main() {\n    let sc = scanner::read_string();\n    let sc = scanner::Scanner::new(&sc);\n    let out = std::io::stdout();\n    let out = std::io::BufWriter::new(out.lock());\n    run(sc, out);\n}\n\nfn run(mut sc: scanner::Scanner, mut out: std::io::BufWriter<std::io::StdoutLock>) {\n    let n: usize = sc.next();\n    let q: usize = sc.next();\n    let empty = -1000 - 1;\n    let f = |(a, b), (c, d)| (a + c, b + d);\n    let g = |(a, b), x| if x == empty {(a, b)} else {(x * b, b)};\n    let h = |x, y| if y == empty {x} else {y};\n    let mut s = segment_tree::Lazy::build_by(&vec![(0, 1); n], (0, 0), empty, f, g, h);\n    for _ in 0..q {\n        let t: u8 = sc.next();\n        let l: usize = sc.next();\n        let r: usize = sc.next();\n        if t == 0 {\n            let v: i32 = sc.next();\n            s.update(l, r + 1, v);\n        } else {\n            writeln!(out, \"{}\", s.find(l, r + 1).0).unwrap();\n        }\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[macro_export]\nmacro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut parser = Parser :: from_str ( $ s ) ; input_inner ! { parser , $ ( $ r ) * } } ; ( parser = $ parser : ident , $ ( $ r : tt ) * ) => { input_inner ! { $ parser , $ ( $ r ) * } } ; ( new_stdin_parser = $ parser : ident , $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let reader = std :: io :: BufReader :: new ( stdin . lock ( ) ) ; let mut $ parser = Parser :: new ( reader ) ; input_inner ! { $ parser , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { input ! { new_stdin_parser = parser , $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! input_inner { ( $ parser : ident ) => { } ; ( $ parser : ident , ) => { } ; ( $ parser : ident , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ parser , $ t ) ; input_inner ! { $ parser $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! read_value { ( $ parser : ident , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ parser , $ t ) ) ,* ) } ; ( $ parser : ident , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ parser , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ parser : ident , chars ) => { read_value ! ( $ parser , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ parser : ident , usize1 ) => { read_value ! ( $ parser , usize ) - 1 } ; ( $ parser : ident , $ t : ty ) => { $ parser . next ::<$ t > ( ) . expect ( \"Parse error\" ) } ; }\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                if len == 0 {\n                    break;\n                }\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\ntrait SEGImpl {\n    type Monoid: Copy;\n    type OperatorMonoid: Copy + PartialEq;\n    fn m0() -> Self::Monoid;\n    fn om0() -> Self::OperatorMonoid;\n    fn f(x: Self::Monoid, y: Self::Monoid) -> Self::Monoid;\n    fn g(x: Self::Monoid, y: Self::OperatorMonoid, len: usize) -> Self::Monoid;\n    fn h(x: Self::OperatorMonoid, y: Self::OperatorMonoid) -> Self::OperatorMonoid;\n}\nstruct SEG<T: SEGImpl> {\n    n: usize,\n    data: Vec<T::Monoid>,\n    lazy: Vec<T::OperatorMonoid>,\n}\nimpl <T: SEGImpl> SEG<T> {\n    fn new(init: T::Monoid, n: usize) -> SEG<T> {\n        let mut m = 1;\n        while m < n { m *= 2; }\n        SEG {\n            n: m,\n            data: vec![init; m*2],\n            lazy: vec![T::om0(); m*2],\n        }\n    }\n    fn propagate(&mut self, k: usize, len: usize) {\n        if self.lazy[k] != T::om0() {\n            if k < self.n {\n                self.lazy[2*k+0] = T::h(self.lazy[2*k+0], self.lazy[k]);\n                self.lazy[2*k+1] = T::h(self.lazy[2*k+1], self.lazy[k]);\n            }\n            self.data[k] = T::g(self.data[k], self.lazy[k], len);\n            self.lazy[k] = T::om0();\n        }\n    }\n    fn do_update(&mut self, a: usize, b: usize, x: T::OperatorMonoid, k: usize, l: usize, r: usize) -> T::Monoid {\n        self.propagate(k, r-l);\n        if r <= a || b <= l {\n            self.data[k]\n        } else if a <= l && r <= b {\n            self.lazy[k] = T::h(self.lazy[k], x);\n            self.propagate(k, r-l);\n            self.data[k]\n        } else {\n            self.data[k] = T::f(\n                self.do_update(a, b, x, 2*k+0, l, (l+r)>>1),\n                self.do_update(a, b, x, 2*k+1, (l+r)>>1, r)\n            );\n            self.data[k]\n        }\n    }\n    fn update(&mut self, a: usize, b: usize, x: T::OperatorMonoid) -> T::Monoid {\n        let n = self.n;\n        self.do_update(a, b, x, 1, 0, n)\n    }\n    fn do_query(&mut self, a: usize, b: usize, k: usize, l: usize, r: usize) -> T::Monoid {\n        self.propagate(k, r-l);\n        if r <= a || b <= l {\n            T::m0()\n        } else if a <= l && r <= b {\n            self.data[k]\n        } else {\n            T::f(\n                self.do_query(a, b, 2*k+0, l, (l+r)>>1),\n                self.do_query(a, b, 2*k+1, (l+r)>>1, r)\n            )\n        }\n    }\n    fn query(&mut self, a: usize, b: usize) -> T::Monoid {\n        let n = self.n;\n        self.do_query(a, b, 1, 0, n)\n    }\n}\n\nstruct RSQ_RUQ;\nimpl SEGImpl for RSQ_RUQ { \n    type Monoid = i64;\n    type OperatorMonoid = i64;\n    fn m0() -> Self::Monoid {\n        0\n    }\n    fn om0() -> Self::OperatorMonoid {\n        1<<40\n    }\n    fn f(x: Self::Monoid, y: Self::Monoid) -> Self::Monoid {\n        x + y\n    }\n    fn g(x: Self::Monoid, y: Self::OperatorMonoid, len: usize) -> Self::Monoid {\n        len as i64 * y\n    }\n    fn h(x: Self::OperatorMonoid, y: Self::OperatorMonoid) -> Self::OperatorMonoid {\n        y\n    }\n}\nfn solve() {\n    input! {\n        new_stdin_parser = parser,\n        n: usize, q: usize,\n    }\n\n    let mut seg: SEG<RSQ_RUQ> = SEG::new(0, n);\n\n    for _ in 0..q {\n        input! {\n            parser = parser,\n            com: usize,\n        }\n        if com == 0 {\n            input! {\n                parser = parser,\n                s: usize, t: usize, x: i64,\n            }\n            seg.update(s,t+1,x);\n        } else {\n            input! {\n                parser = parser,\n                i: usize, j: usize,\n            }\n            println!(\"{}\", seg.query(i,j+1));\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io;\nuse std::io::prelude::*;\n\nstruct SegTree {\n    n: usize,\n    nodes: Vec<(i32, Option<i32>)>,\n}\n\nimpl SegTree {\n    fn new(n: usize) -> SegTree {\n        let n = 1 << f64::log2(n as f64).ceil() as usize;\n        SegTree {\n            n,\n            nodes: vec![(0, None); 2 * n - 1],\n        }\n    }\n\n    fn update(&mut self, s: usize, t: usize, x: i32, ni: usize, l: usize, r: usize) {\n        self.eval(ni);\n        if r <= s || t <= l {\n            return;\n        }\n        if s <= l && r <= t {\n            self.nodes[ni].1 = Some(x * (r - l) as i32);\n            self.eval(ni);\n            return;\n        }\n        let m = (l + r) / 2;\n        self.update(s, t, x, 2 * ni + 1, l, m);\n        self.update(s, t, x, 2 * ni + 2, m, r);\n        self.nodes[ni].0 = self.nodes[2 * ni + 1].0 + self.nodes[2 * ni + 2].0;\n    }\n\n    fn eval(&mut self, ni: usize) -> i32 {\n        match self.nodes[ni].1.take() {\n            Some(x) => {\n                self.nodes[ni].0 = x;\n                if ni < self.n - 1 {\n                    self.nodes[2 * ni + 1].1 = Some(x / 2);\n                    self.nodes[2 * ni + 2].1 = Some(x / 2);\n                }\n            }\n            None => {}\n        }\n        self.nodes[ni].0\n    }\n\n    fn get_sum(&mut self, s: usize, t: usize, ni: usize, l: usize, r: usize) -> i32 {\n        self.eval(ni);\n        if s <= l && r <= t {\n            self.nodes[ni].0\n        } else if r <= s || t <= l {\n            0\n        } else {\n            let m = (l + r) / 2;\n            self.get_sum(s, t, 2 * ni + 1, l, m) + self.get_sum(s, t, 2 * ni + 2, m, r)\n        }\n    }\n}\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines();\n\n    let line0 = lines.next().unwrap().unwrap();\n    let n = line0.split_whitespace().next().unwrap().parse().unwrap();\n\n    let mut st = SegTree::new(n);\n\n    for l in lines.map(Result::unwrap) {\n        let mut words = l.split_whitespace();\n        let com = words.next().unwrap().parse().unwrap();\n        let s: usize = words.next().unwrap().parse().unwrap();\n        let t: usize = words.next().unwrap().parse().unwrap();\n        let n = st.n;\n        match com {\n            0 => {\n                let x = words.next().unwrap().parse().unwrap();\n                st.update(s, t + 1, x, 0, 0, n);\n            }\n            1 => println!(\"{}\", st.get_sum(s, t + 1, 0, 0, n)),\n            _ => (),\n        }\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp::*;\nuse std::collections::*;\nuse std::io::*;\nuse std::str::*;\nuse std::string::*;\nuse std::f64::consts::PI;\n\n#[derive(Eq, PartialEq, Clone, Debug)]\npub struct Rev<T>(pub T);\n\nimpl<T: PartialOrd> PartialOrd for Rev<T> {\n    fn partial_cmp(&self, other: &Rev<T>) -> Option<std::cmp::Ordering> {\n        other.0.partial_cmp(&self.0)\n    }\n}\n\nimpl<T: Ord> Ord for Rev<T> {\n    fn cmp(&self, other: &Rev<T>) -> std::cmp::Ordering {\n        other.0.cmp(&self.0)\n    }\n}\n\nmacro_rules! read {\n    (($($t:tt),*)) => {\n        ( $(read!($t)),* )\n    };\n    ([[$t:tt; $len1:expr]; $len2:expr]) => {\n        (0..$len2).map(|_| read!([$t; $len1])).collect::<Vec<_>>()\n    };\n\n    ([$t:tt; $len:expr]) => {\n        (0..$len).map(|_| read!($t)).collect::<Vec<_>>()\n    };\n\n    (chars) => {\n        read!(String).chars().collect::<Vec<char>>()\n    };\n\n    (usize1) => {\n        read!(usize) - 1\n    };\n\n    ($t:ty) => {{\n        let stdin = stdin();\n        let stdin = stdin.lock();\n        let token: String = stdin\n            .bytes()\n            .map(|c| c.unwrap() as char)\n            .skip_while(|c| c.is_whitespace())\n            .take_while(|c| !c.is_whitespace())\n            .collect();\n\n        token.parse::<$t>().unwrap()\n    }};\n}\n\nmacro_rules! input {\n    (mut $name:ident: $t:tt, $($r:tt)*) => {\n        let mut $name = read!($t);\n        input!($($r)*);\n    };\n\n    (mut $name:ident: $t:tt) => {\n        let mut $name = read!($t);\n    };\n\n    ($name:ident: $t:tt, $($r:tt)*) => {\n        let $name = read!($t);\n        input!($($r)*);\n    };\n\n    ($name:ident: $t:tt) => {\n        let $name = read!($t);\n    };\n}\n\nfn prime_factorization(n: i64) -> HashMap<i64, i64> {\n    let mut n = n;\n    let mut res = HashMap::new();\n    let mut i = 2;\n    while i * i <= n {\n        while n % i == 0 {\n            n /= i;\n            let count = res.entry(i).or_insert(0);\n            *count += 1;\n        }\n        i += 1;\n    }\n\n    if n > 1 {\n        res.insert(n, 1);\n    }\n\n    return res;\n}\n\n\nstruct Combination {\n    MOD: i64,\n    fac: Vec<i64>,\n    fac_inv: Vec<i64>,\n}\n\nimpl Combination {\n    pub fn new(n: i64) -> Self {\n        let MOD: i64 = 1_000_000_007;\n        let mut fac: Vec<i64> = vec![0; n as usize + 1];\n        let mut fac_inv: Vec<i64> = vec![0; n as usize + 1];\n\n        let get_inverse = |mut n: i64| -> i64 {\n            let (mut res, mut p) = (1, MOD - 2);\n\n            while p != 0 {\n                if p & 1 == 1 {\n                    res = (res * n) % MOD;\n                }\n                n = (n * n) % MOD;\n                p >>= 1;\n            }\n\n            return res;\n        };\n\n        fac[0] = 1;\n\n        for i in 1..n + 1 {\n            fac[i as usize] = (fac[i as usize - 1] * i) % MOD;\n        }\n\n        for i in 0..n + 1 {\n            fac_inv[i as usize] = get_inverse(fac[i as usize]);\n        }\n\n        Combination {\n            MOD: MOD,\n            fac: fac,\n            fac_inv: fac_inv,\n        }\n    }\n\n    fn nCr(&self, n: i64, r: i64) -> i64 {\n        if n < r {\n            return 0;\n        }\n\n        let a: i64 = self.fac[n as usize];\n        let b: i64 = self.fac_inv[(n - r) as usize];\n        let c: i64 = self.fac_inv[r as usize];\n        let bc: i64 = (b * c) % self.MOD;\n\n        return (a * bc) % self.MOD;\n    }\n\n    fn nPr(&self, n: i64, r: i64) -> i64 {\n        if n < r {\n            return 0;\n        }\n\n        let a: i64 = self.fac[n as usize];\n        let b: i64 = self.fac_inv[(n - r) as usize];\n\n        return (a * b) % self.MOD;\n    }\n\n    fn nHr(&self, n: i64, r: i64) -> i64 {\n        if n == 0 && r == 0 {\n            return 1;\n        }\n\n        return self.nCr(n + r - 1, r);\n    }\n}\n\npub trait SliceExt<T>: Iterator + Sized {\n    fn vec(self) -> Vec<Self::Item> {\n        self.collect()\n    }\n}\n\n#[derive(Copy, Clone, Eq, PartialEq)]\nstruct Edge {\n    to: usize,\n    cost: i64,\n}\n\nfn dijkstra(graph: &Vec<Vec<Edge>>, s: &usize) -> Vec<i64> {\n    use std::collections::BinaryHeap;\n    let mut dist = vec![1e18 as i64; graph.len()];\n    let mut heap = BinaryHeap::new();\n    dist[*s] = 0;\n    heap.push(Rev((0, *s)));\n    while let Some(Rev((cost, v))) = heap.pop() {\n        if dist[v] < cost {\n            continue;\n        }\n\n        for e in &graph[v] {\n            if dist[e.to] <= dist[v] + e.cost {\n                continue;\n            }\n            dist[e.to] = dist[v] + e.cost;\n            heap.push(Rev((dist[e.to], e.to)));\n        }\n    }\n    return dist;\n}\n\nstruct LCA {\n    par: Vec<Vec<Option<usize>>>,\n    dist: Vec<i64>,\n}\n\nimpl LCA {\n    pub fn new(graph: &Vec<Vec<usize>>, root: &usize) -> LCA {\n        let V = graph.len();\n        let mut K = 1;\n\n        while (1 << K) < V {\n            K += 1;\n        }\n\n        let mut par = vec![vec![None; V]; K];\n        let mut dist = vec![-1; V];\n        let graph = graph.to_vec();\n\n        fn dfs(\n            v: usize,\n            p: Option<usize>,\n            d: i64,\n            graph: &Vec<Vec<usize>>,\n            par: &mut Vec<Vec<Option<usize>>>,\n            dist: &mut Vec<i64>,\n        ) {\n            par[0][v] = p;\n            dist[v] = d;\n            for &to in &graph[v] {\n                match p {\n                    Some(p) => {\n                        if to != p {\n                            dfs(to, Some(v), d + 1, graph, par, dist)\n                        }\n                    }\n                    None => dfs(to, Some(v), d + 1, graph, par, dist),\n                }\n            }\n        }\n\n        dfs(*root, None, 0, &graph, &mut par, &mut dist);\n\n        for k in 0..K - 1 {\n            for v in 0..V {\n                match par[k][v] {\n                    Some(x) => par[k + 1][v] = par[k][x],\n                    None => (),\n                }\n            }\n        }\n\n        LCA {\n            par: par,\n            dist: dist,\n        }\n    }\n\n    pub fn query(&self, u: usize, v: usize) -> usize {\n        let mut u = u;\n        let mut v = v;\n        if self.dist[u] < self.dist[v] {\n            return self.query(v, u);\n        }\n\n        let K = self.par.len();\n        for k in 0..K {\n            if ((self.dist[u] - self.dist[v]) >> k & 1) == 1 {\n                u = self.par[k][u].unwrap();\n            }\n        }\n\n        if u == v {\n            return u;\n        }\n\n        for k in (0..K - 1).rev() {\n            if self.par[k][u] != self.par[k][v] {\n                u = self.par[k][u].unwrap();\n                v = self.par[k][v].unwrap();\n            }\n        }\n\n        return self.par[0][u].unwrap();\n    }\n}\n\nstruct Doubling {\n    N: usize,\n    LOG: usize,\n    next: Vec<Vec<Option<usize>>>,\n}\n\nimpl Doubling {\n    pub fn new(vec: &Vec<usize>, lim: &usize) -> Doubling {\n        let N = vec.len();\n        let lim = *lim;\n        let mut LOG = 1;\n        while (1 << LOG) < 2 * lim {\n            LOG += 1;\n        }\n\n        let mut next = vec![vec![None; N]; LOG];\n\n        for i in 0..N {\n            next[0][i] = Some(vec[i]);\n        }\n\n        for k in 0..LOG - 1 {\n            for i in 0..N {\n                match next[k][i] {\n                    Some(x) => next[k + 1][i] = next[k][x],\n                    None => (),\n                }\n            }\n        }\n\n        Doubling {\n            N: N,\n            LOG: LOG,\n            next: next,\n        }\n    }\n\n    pub fn query(&self, i: usize, n: usize) -> usize {\n        let mut i = i;\n        for k in (0..self.LOG).rev() {\n            if (n >> k) & 1 == 1 {\n                i = self.next[k][i].unwrap();\n            }\n        }\n        return i;\n    }\n}\n\nmacro_rules! min {\n    ($a:expr $(,)*) => {{\n        $a\n    }};\n    ($a:expr, $b:expr $(,)*) => {{\n        std::cmp::min($a, $b)\n    }};\n    ($a:expr, $($rest:expr),+ $(,)*) => {{\n        std::cmp::min($a, min!($($rest),+))\n    }};\n}\n\nmacro_rules! chmin {\n    ($base:expr, $($cmps:expr),+ $(,)*) => {{\n        let cmp_min = min!($($cmps),+);\n        if $base > cmp_min {\n            $base = cmp_min;\n            true\n        } else {\n            false\n        }\n    }};\n}\n\nmacro_rules! max {\n    ($a:expr $(,)*) => {{\n        $a\n    }};\n    ($a:expr, $b:expr $(,)*) => {{\n        std::cmp::max($a, $b)\n    }};\n    ($a:expr, $($rest:expr),+ $(,)*) => {{\n        std::cmp::max($a, max!($($rest),+))\n    }};\n}\n\nmacro_rules! chmax {\n    ($base:expr, $($cmps:expr),+ $(,)*) => {{\n        let cmp_max = max!($($cmps),+);\n        if $base < cmp_max {\n            $base = cmp_max;\n            true\n        } else {\n            false\n        }\n    }};\n}\n\nstruct UnionFind {\n    par: Vec<i32>,\n}\n\nimpl UnionFind {\n    pub fn new(n: usize) -> UnionFind {\n        UnionFind {\n            par: vec![-1; n],\n        }\n    }\n\n    pub fn root(&mut self, x: usize) -> usize {\n        if self.par[x] < 0 {\n            return x;\n        } else {\n            let a = self.par[x] as usize;\n            self.par[x] = self.root(a) as i32;\n            return self.par[x] as usize;\n        }\n    }\n\n    pub fn is_same(&mut self, x: usize, y: usize) -> bool {\n        self.root(x) == self.root(y)\n    }\n\n    pub fn merge(&mut self, x: usize, y: usize) -> bool {\n        let mut x = self.root(x);\n        let mut y = self.root(y);\n        if x == y {\n            return false;\n        } else {\n            if self.par[x] > self.par[y] {\n                std::mem::swap(&mut x, &mut y);\n            }\n            self.par[x] += self.par[y];\n            self.par[y] = x as i32;\n            return true;\n        }\n    }\n\n    pub fn size(&mut self, x: usize) -> i64 {\n        let a = self.root(x);\n        return -self.par[a] as i64;\n    }\n}\n\ntrait Monoid {\n    fn id() -> Self;\n    fn op(&self, rhs: &Self) -> Self;\n}\n\n#[derive(Clone, Debug)]\nstruct Min(i64);\n\n#[derive(Clone, Debug)]\nstruct RangeUpdate(i64);\n\n#[derive(Clone, Debug)]\nstruct RangeAdd(i64);\n\n#[derive(Clone, Debug)]\nstruct Sum(i64);\n\nimpl Monoid for Sum {\n    fn id() -> Self {\n        Sum(0)\n    }\n\n    fn op(&self, rhs: &Self) -> Self {\n        Sum(self.0 + rhs.0)\n    }\n}\n\nimpl Monoid for Min {\n    fn id() -> Self {\n        Min(std::i32::MAX as i64)\n    }\n\n    fn op(&self, rhs: &Self) -> Self {\n        Min(std::cmp::min(self.0, (*rhs).0))\n    }\n}\n\ntrait Operator {\n    type T;\n    fn id() -> Self;\n    fn op(&self, rhs: &Self) -> Self;\n    fn act(&self, t: &Self::T, x: usize) -> Self::T;\n}\n\nimpl Operator for RangeUpdate {\n    type T = Sum;\n    fn id() -> Self {\n        RangeUpdate(0)\n    }\n\n    fn op(&self, rhs: &Self) -> Self {\n        (*rhs).clone()\n    }\n\n    fn act(&self, t: &Self::T, x: usize) -> Self::T {\n        Sum(self.0 * x as i64)\n    }\n}\n\nimpl Operator for RangeAdd {\n    type T = Min;\n    fn id() -> Self {\n        RangeAdd(0)\n    }\n\n    fn op(&self, rhs: &Self) -> Self {\n        RangeAdd(self.0 + rhs.0)\n    }\n\n    fn act(&self, t: &Self::T, sz: usize) -> Self::T {\n        Min(t.0 + self.0)\n    }\n}\n\nstruct LazySegTree<M: Monoid, O: Operator<T=M>> {\n    dat: Vec<M>,\n    lzy: Vec<O>,\n    need_update: Vec<bool>,\n    size: usize,\n}\n\nimpl<M: Monoid + Clone, O: Operator<T=M> + Clone> LazySegTree<M, O> {\n    pub fn new(vec: Vec<M>) -> LazySegTree<M, O> {\n        let n = vec.len();\n        let mut sz = 1;\n        while sz < n {\n            sz <<= 1;\n        }\n        let mut dat = vec![M::id(); sz << 1];\n        for i in 0..n {\n            dat[i + sz] = vec[i].clone();\n        }\n        for k in (1..sz).rev() {\n            dat[k] = dat[k << 1].op(&dat[(k << 1) + 1]);\n        }\n\n        return LazySegTree {\n            dat: dat,\n            lzy: vec![O::id(); sz << 1],\n            need_update: vec![false; sz << 1],\n            size: sz,\n        };\n    }\n\n    pub fn eval(&mut self, l: usize, r: usize, k: usize) {\n        if !self.need_update[k] {\n            return;\n        }\n        self.dat[k] = self.lzy[k].act(&self.dat[k], r - l);\n        if (k << 1) < self.dat.len() {\n            self.lzy[k << 1] = self.lzy[k << 1].op(&self.lzy[k]);\n            self.lzy[(k << 1) + 1] = self.lzy[(k << 1) + 1].op(&self.lzy[k]);\n            self.need_update[k << 1] = true;\n            self.need_update[(k << 1) + 1] = true;\n        }\n        self.lzy[k] = O::id();\n        self.need_update[k] = false;\n    }\n\n    pub fn update(&mut self, a: usize, b: usize, x: O) {\n        let sz = self.size;\n        self._update(a, b, &x, 0, sz, 1);\n    }\n\n    pub fn _update(&mut self, a: usize, b: usize, x: &O, l: usize, r: usize, k: usize) {\n        self.eval(l, r, k);\n        if b <= l || r <= a {\n            return;\n        } else if a <= l && r <= b {\n            self.lzy[k] = self.lzy[k].op(x);\n            self.need_update[k] = true;\n            self.eval(l, r, k);\n        } else {\n            let mid = (l + r) >> 1;\n            self._update(a, b, x, l, mid, k << 1);\n            self._update(a, b, x, mid, r, (k << 1) + 1);\n            self.dat[k] = self.dat[k << 1].op(&self.dat[(k << 1) + 1]);\n        }\n    }\n\n    pub fn query(&mut self, a: usize, b: usize) -> M {\n        let sz = self.size;\n        return self._query(a, b, 0, sz, 1);\n    }\n\n    pub fn _query(&mut self, a: usize, b: usize, l: usize, r: usize, k: usize) -> M {\n        self.eval(l, r, k);\n        if b <= l || r <= a {\n            return M::id();\n        } else if a <= l && r <= b {\n            return self.dat[k].clone();\n        } else {\n            let mid = (l + r) >> 1;\n            let vl = self._query(a, b, l, mid, k << 1);\n            let vr = self._query(a, b, mid, r, (k << 1) + 1);\n            return vl.op(&vr);\n        }\n    }\n}\n\nstruct SegTree<M: Monoid> {\n    dat: Vec<M>,\n    size: usize,\n}\n\nimpl<M: Monoid + Clone> SegTree<M> {\n    pub fn new(n: usize) -> SegTree<M> {\n        let mut sz = 1;\n        while sz < n {\n            sz <<= 1;\n        }\n\n        SegTree::<M> {\n            dat: vec![M::id(); sz * 2],\n            size: sz,\n        }\n    }\n\n    pub fn update(&mut self, k: usize, val: M) {\n        let mut k = k + self.size;\n        self.dat[k] = val;\n        while k > 0 {\n            k = k >> 1;\n            self.dat[k] = self.dat[k << 1].op(&self.dat[(k << 1) + 1]);\n        }\n    }\n\n    pub fn query(&self, a: usize, b: usize) -> M {\n        let mut lx = M::id();\n        let mut rx = M::id();\n        let mut l = a + self.size;\n        let mut r = b + self.size;\n        while l < r {\n            if (l & 1) == 1 {\n                lx = lx.op(&self.dat[l]);\n                l += 1;\n            }\n\n            if (r & 1) == 1 {\n                r -= 1;\n                rx = self.dat[r].op(&rx);\n            }\n\n            l >>= 1;\n            r >>= 1;\n        }\n\n        return lx.op(&rx);\n    }\n}\n\nfn main() {\n    input!(n: usize, q: usize);\n    let mut seg = LazySegTree::new(vec![Sum(0); n]);\n    for _ in 0..q {\n        input!(c: usize);\n        if c == 0 {\n            input!(s: usize, t: usize, y: i64);\n            seg.update(s, t + 1, RangeUpdate(y));\n        } else {\n            input!(s: usize, t: usize);\n            println!(\"{}\", seg.query(s, t + 1).0);\n        }\n    }\n}\n"
  }
]