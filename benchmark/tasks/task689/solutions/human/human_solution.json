[
  {
    "language": "Crystal",
    "code": "n = read_line.to_i64\nais = read_line.chars.map(&.to_i64)\n\nans = [] of Bool\nais.each_with_index do |a, i|\n  if i == 0 && a != 1\n    puts \"Impossible\"\n    exit\n  end\n  if i.popcount == 1\n    ans << (a == 0)\n  end\nend\nais.each_with_index do |a, i|\n  possible = 1_i64\n  i.to_s(2).rjust(n, '0').chars.reverse.each_with_index do |c, j|\n    if c == '1' && ans[j] == true\n      possible = 0_i64\n      break\n    end\n  end\n  if possible != a\n    puts \"Impossible\"\n    exit\n  end\nend\n\nputs \"Possible\"\npoints = [] of Tuple(Int64, Int64)\nn.downto(0) do |i|\n  points << {i, 1_i64}\nend\ny = 1_i64\nans.each_with_index do |a, i|\n  new_y = a == true ? 0_i64 : 1_i64\n  if new_y != y\n    points << {i.to_i64, new_y}\n  end\n  points << {i.to_i64 + 1, new_y}\n  y = new_y\nend\nif y != 1\n  points << {n, 1_i64}\nend\n\nputs points.size - 1\npoints.each do |(x, y)|\n  puts \"#{x} #{y}\"\nend"
  },
  {
    "language": "Crystal",
    "code": "n = read_line.to_i64\nais = read_line.chars.map(&.to_i64)\n\nans = [] of Bool\nais.each_with_index do |a, i|\n  if i == 0 && a != 1\n    puts \"Impossible\"\n    exit\n  end\n  if i.popcount == 1\n    ans << (a == 0)\n  end\nend\nais.each_with_index do |a, i|\n  possible = 1_i64\n  i.to_s(2).rjust(n, '0').chars.each_with_index do |c, j|\n    if c == '1' && ans[j] == true\n      possible = 0_i64\n      break\n    end\n  end\n  if possible != a\n    puts \"Impossible\"\n    exit\n  end\nend\n\nputs \"Possible\"\npoints = [] of Tuple(Int64, Int64)\nn.downto(0) do |i|\n  points << {i, 1_i64}\nend\ny = 1_i64\nans.each_with_index do |a, i|\n  new_y = a == true ? 0_i64 : 1_i64\n  if new_y != y\n    points << {i.to_i64, new_y}\n  end\n  points << {i.to_i64 + 1, new_y}\n  y = new_y\nend\nif y != 1\n  points << {n, 1_i64}\nend\n\nputs points.size - 1\npoints.each do |(x, y)|\n  puts \"#{x} #{y}\"\nend"
  },
  {
    "language": "Crystal",
    "code": "n = read_line.to_i64\nais = read_line.chars.map(&.to_i64)\n\nans = [] of Bool\nais.each_with_index do |a, i|\n  if i == 0 && a != 1\n    puts \"Impossible\"\n    exit\n  end\n  if i.popcount == 1\n    ans << (a == 0)\n  end\nend\nais.each_with_index do |a, i|\n  possible = 1_i64\n  i.to_s(2).rjust(n, '0').chars.each_with_index do |c, j|\n    if c == '1' && ans[j] == true\n      possible = 0_i64\n      break\n    end\n  end\n  if possible != a\n    puts \"Impossible\"\n    exit\n  end\nend\n\nputs \"Possible\"\npoints = [] of Tuple(Int64, Int64)\npoints << {n, 1_i64}\nn.downto(0) do |i|\n  points << {i, 2_i64}\nend\npoints << {0_i64, 1_i64}\ny = 1_i64\nans.each_with_index do |a, i|\n  new_y = a == true ? 0_i64 : 1_i64\n  if new_y != y\n    points << {i.to_i64, new_y}\n  end\n  points << {i.to_i64 + 1, new_y}\n  y = new_y\nend\nif y != 1\n  points << {n, 1_i64}\nend\n\nputs points.size\npoints.each do |(x, y)|\n  puts \"#{x} #{y}\"\nend"
  },
  {
    "language": "Crystal",
    "code": "n = read_line.to_i64\nais = read_line.chars.map(&.to_i64)\n\nans = [] of Bool\nais.each_with_index do |a, i|\n  if i == 0 && a != 1\n    puts \"Impossible\"\n    exit\n  end\n  if i.popcount == 1\n    ans << (a == 0)\n  end\nend\nais.each_with_index do |a, i|\n  possible = 1_i64\n  i.to_s(2).rjust(n, '0').chars.each_with_index do |c, j|\n    if c == '1' && ans[j] == true\n      possible = 0_i64\n      break\n    end\n  end\n  if possible != a\n    puts \"Impossible\"\n    exit\n  end\nend\n\nputs \"Possible\"\nputs \"#{n} 1\"\nn.downto(0) do |i|\n  puts \"#{i} 2\"\nend\nputs \"0 1\"\ny = 1_i64\nans.each_with_index do |a, i|\n  new_y = a == true ? 0_i64 : 1_i64\n  if new_y != y\n    puts \"#{i} #{new_y}\"\n  end\n  puts \"#{i + 1} #{new_y}\"\n  y = new_y\nend\nif y != 1\n  puts \"#{n} 1\"\nend"
  },
  {
    "language": "Crystal",
    "code": "n = read_line.to_i64\nais = read_line.chars.map(&.to_i64)\n\nans = [] of Bool\nais.each_with_index do |a, i|\n  if i == 0 && a != 1\n    puts \"Impossible\"\n    exit\n  end\n  if i.popcount == 1\n    ans << (a == 0)\n  end\nend\nais.each_with_index do |a, i|\n  possible = 1_i64\n  i.to_s(2).rjust(n, '0').chars.each_with_index do |c, j|\n    if c == '1' && ans[j] == true\n      possible = 0_i64\n      break\n    end\n  end\n  if possible != a\n    puts \"Impossible\"\n    exit\n  end\nend\n\nputs \"Possible\"\npoints = [] of Tuple(Int64, Int64)\npoints << {n, 1_i64}\nn.downto(0) do |i|\n  points << {i, 2_i64}\nend\npoints << {0_i64, 1_i64}\ny = 1_i64\nans.each_with_index do |a, i|\n  new_y = a == true ? 0_i64 : 1_i64\n  if new_y != y\n    points << {i.to_i64, new_y}\n  end\n  points << {i.to_i64 + 1, new_y}\n  y = new_y\nend\nif y != 1\n  points << {n, 1_i64}\nend\n\nputs points.size - 1\npoints.each do |(x, y)|\n  puts \"#{x} #{y}\"\nend"
  },
  {
    "language": "Crystal",
    "code": "n = read_line.to_i64\nais = read_line.chars.map(&.to_i64)\n\nans = [] of Bool\nais.each_with_index do |a, i|\n  if i.popcount == 1\n    ans << (a == 0)\n  end\nend\nais.each_with_index do |a, i|\n  possible = 1_i64\n  i.to_s(2).rjust(n, '0').chars.reverse.each_with_index do |c, j|\n    if c == '1' && ans[j] == true\n      possible = 0_i64\n      break\n    end\n  end\n  if possible != a\n    puts \"Impossible\"\n    exit\n  end\nend\n\nputs \"Possible\"\npoints = [] of Tuple(Int64, Int64)\n0.upto(n) do |i|\n  points << {i.to_i64, 0_i64}\nend\ny = 0_i64\n(n - 1).downto(0) do |i|\n  a = ans[i]\n  new_y = a == true ? 1_i64 : 0_i64\n  if new_y != y\n    points << {i.to_i64 + 1, new_y}\n  end\n  points << {i.to_i64, new_y}\n  y = new_y\nend\nif y != 0\n  points << {0_i64, 0_i64}\nend\n\nputs points.size - 1\npoints.each do |(x, y)|\n  puts \"#{x} #{y}\"\nend"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:1000000000\")\n#pragma GCC optimize(\"Ofast,no-stack-protector\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <algorithm>\n#include <memory.h>\n#include <cassert>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <cmath>\n#include <ctime>\n#include <random>\n#include <bitset>\n#include <limits.h>\n#include <fstream>\n\n#define mp make_pair\n#define all(a) (a).begin(), (a).end()\n#define pll pair <ll, ll>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef double ld;\n#define uint unsigned int\n\nconst int maxlog = 8;\nconst int maxn = (1 << 8);\n\nint a[maxn];\nchar s[maxn];\n\nvector <pii> ans;\n\nvoid go(int &x, int &y, int dx, int dy) {\n\tx += dx;\n\ty += dy;\n\tans.push_back(mp(x, y));\n}\n\nint main() {\n\tint n;\n\n\tcin >> n;\n\tcin >> s;\n\n\tfor (int i = 0; i < (1 << n); i++) {\n\t\ta[i] = s[i] - '0';\n\t}\n\n\tfor (int i = (1 << n) - 1; i >= 0; i--) {\n\t\tif (a[i] == 0) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif ((i >> j) & 1) {\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (a[i | (1 << j)] == 1) {\n\t\t\t\t\t\tcout << \"Impossible\\n\";\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < (1 << n); i++) {\n\t\tif (a[i] == 1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tbool good = false;\n\t\tint cnt = 0;\n\n\t\tfor (int j = 0; j < (1 << i); j++) {\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tcnt++;\n\t\t\t\tif (a[i ^ (1 << j)] == 1) {\n\t\t\t\t\tgood = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (good && cnt > 3) {\n\t\t\tcout << \"Impossible\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (a[0] == 0) {\n\t\tcout << \"Impossible\\n\";\n\t\treturn 0;\n\t}\n\n\tans.push_back(mp(0, 0));\n\n\tfor (int i = 0; i < (1 << n); i++) {\n\t\tif (a[i] == 1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvector <int> p;\n\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tp.push_back(j);\n\t\t\t}\n\t\t}\n\n\t\tif ((int)p.size() > 2) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tint x = 0, y = 0;\n\n\t\tgo(x, y, 0, 1);\n\n\t\twhile (x < p[0]) {\n\t\t\tgo(x, y, 1, 0);\n\t\t}\n\n\t\tgo(x, y, 0, -1);\n\t\tgo(x, y, 1, 0);\n\t\tgo(x, y, 0, 1);\n\n\t\tif ((int)p.size() == 1) {\n\t\t\twhile (x > 0) {\n\t\t\t\tgo(x, y, -1, 0);\n\t\t\t}\n\n\t\t\tgo(x, y, 0, -1);\n\t\t}\n\t\telse {\n\t\t\twhile (x < p[1]) {\n\t\t\t\tgo(x, y, 1, 0);\n\t\t\t}\n\n\t\t\tgo(x, y, 0, -1);\n\t\t\tgo(x, y, 1, 0);\n\t\t\tgo(x, y, 0, 1);\n\t\t\twhile (x > p[0] + 1) {\n\t\t\t\tgo(x, y, -1, 0);\n\t\t\t}\n\n\t\t\tgo(x, y, 0, -1);\n\t\t\tgo(x, y, -1, 0);\n\t\t\tgo(x, y, 0, 1);\n\t\t\twhile (x < p[1] + 1) {\n\t\t\t\tgo(x, y, 1, 0);\n\t\t\t}\n\n\t\t\tgo(x, y, 0, -1);\n\t\t\tgo(x, y, -1, 0);\n\t\t\tgo(x, y, 0, 1);\n\n\t\t\twhile (x > 0) {\n\t\t\t\tgo(x, y, -1, 0);\n\t\t\t}\n\n\t\t\tgo(x, y, 0, -1);\n\t\t}\n\t}\n\n\tcout << \"Possible\\n\";\n\tcout << (int)ans.size() - 1 << '\\n';\n\n\tfor (pii f : ans) {\n\t\tcout << f.first << ' ' << f.second << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define fst first\n#define snd second\n#define fore(i,a,b) for(int i=a,ggdem=b;i<ggdem;++i)\n#define SZ(x) ((int)x.size())\n#define ALL(x) x.begin(),x.end()\n#define mset(a,v) memset((a),(v),sizeof(a))\n#define FIN ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)\nusing namespace std;\ntypedef long long ll;\n\nvoid build(ll n, ll m){\n\tvector<pair<ll,ll>> res={{0,0}};\n\tfore(i,0,n){\n\t\tif(((1ll<<i)&m)==0){\n\t\t\tfore(j,0,i)if(res.back()!=(pair<ll,ll>){j,0})res.pb({j,0});\n\t\t\tif(res.back()!=(pair<ll,ll>){i,0})res.pb({i,0});\n\t\t\tif(res.back()!=(pair<ll,ll>){i+1,0})res.pb({i+1,0});\n\t\t\tif(res.back()!=(pair<ll,ll>){i+1,1})res.pb({i+1,1});\n\t\t\tif(res.back()!=(pair<ll,ll>){i,1})res.pb({i,1});\n\t\t\tfore(j,0,i)if(res.back()!=(pair<ll,ll>){i-j,0})res.pb({i-j,0});\n\t\t}\n\t}\n\tif(res.back()!=(pair<ll,ll>){0,0})res.pb({0,0});\n\tcout<<SZ(res)-1<<\"\\n\";\n\tfor(auto i:res)cout<<i.fst<<\" \"<<i.snd<<\"\\n\";\n\t\n}\n\nint main(){FIN;\n\tll n; cin>>n;\n\tstring s; cin>>s;\n\tll m=0;\n\tfore(i,0,SZ(s)){\n\t\tif(s[i]=='1')m=m|i;\n\t}\n\tfore(i,0,SZ(s)){\n\t\tif((i|m)==m){\n\t\t\tif(s[i]=='0'){\n\t\t\t\tcout<<\"Impossible\"; return 0;\n\t\t\t}\n\t\t}else{\n\t\t\tif(s[i]=='1'){\n\t\t\t\tcout<<\"Impossible\"; return 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"Possible\\n\";\n\tbuild(n,m);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:1000000000\")\n#pragma GCC optimize(\"Ofast,no-stack-protector\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <algorithm>\n#include <memory.h>\n#include <cassert>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <cmath>\n#include <ctime>\n#include <random>\n#include <bitset>\n#include <limits.h>\n#include <fstream>\n\n#define mp make_pair\n#define all(a) (a).begin(), (a).end()\n#define pll pair <ll, ll>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef double ld;\n#define uint unsigned int\n\nconst int maxlog = 8;\nconst int maxn = (1 << 8);\n\nint a[maxn];\nchar s[maxn];\n\nvector <pii> ans;\n\nvoid go(int &x, int &y, int dx, int dy) {\n\tx += dx;\n\ty += dy;\n\tans.push_back(mp(x, y));\n}\n\nint main() {\n\tint n;\n\n\tcin >> n;\n\tcin >> s;\n\n\tfor (int i = 0; i < (1 << n); i++) {\n\t\ta[i] = s[i] - '0';\n\t}\n\n\tfor (int i = (1 << n) - 1; i >= 0; i--) {\n\t\tif (a[i] == 0) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif ((i >> j) & 1) {\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (a[i | (1 << j)] == 1) {\n\t\t\t\t\t\tcout << \"Impossible\\n\";\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < (1 << n); i++) {\n\t\tif (a[i] == 1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tbool good = true;\n\t\tint cnt = 0;\n\n\t\tfor (int j = 0; j < (1 << i); j++) {\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tcnt++;\n\t\t\t\tif (a[i ^ (1 << j)] == 0) {\n\t\t\t\t\tgood = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (good && cnt >= 3) {\n\t\t\tif (cnt == 3)\n\t\t\t\tthrow 1;\n\t\t\tcout << \"Impossible\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (a[0] == 0) {\n\t\tcout << \"Impossible\\n\";\n\t\treturn 0;\n\t}\n\n\tans.push_back(mp(0, 0));\n\n\tfor (int i = 0; i < (1 << n); i++) {\n\t\tif (a[i] == 1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvector <int> p;\n\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tp.push_back(j);\n\t\t\t}\n\t\t}\n\n\t\tif ((int)p.size() > 2) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tint x = 0, y = 0;\n\n\t\tgo(x, y, 0, 1);\n\n\t\twhile (x < p[0]) {\n\t\t\tgo(x, y, 1, 0);\n\t\t}\n\n\t\tgo(x, y, 0, -1);\n\t\tgo(x, y, 1, 0);\n\t\tgo(x, y, 0, 1);\n\n\t\tif ((int)p.size() == 1) {\n\t\t\twhile (x > 0) {\n\t\t\t\tgo(x, y, -1, 0);\n\t\t\t}\n\n\t\t\tgo(x, y, 0, -1);\n\t\t}\n\t\telse {\n\t\t\twhile (x < p[1]) {\n\t\t\t\tgo(x, y, 1, 0);\n\t\t\t}\n\n\t\t\tgo(x, y, 0, -1);\n\t\t\tgo(x, y, 1, 0);\n\t\t\tgo(x, y, 0, 1);\n\t\t\twhile (x > p[0] + 1) {\n\t\t\t\tgo(x, y, -1, 0);\n\t\t\t}\n\n\t\t\tgo(x, y, 0, -1);\n\t\t\tgo(x, y, -1, 0);\n\t\t\tgo(x, y, 0, 1);\n\t\t\twhile (x < p[1] + 1) {\n\t\t\t\tgo(x, y, 1, 0);\n\t\t\t}\n\n\t\t\tgo(x, y, 0, -1);\n\t\t\tgo(x, y, -1, 0);\n\t\t\tgo(x, y, 0, 1);\n\n\t\t\twhile (x > 0) {\n\t\t\t\tgo(x, y, -1, 0);\n\t\t\t}\n\n\t\t\tgo(x, y, 0, -1);\n\t\t}\n\t}\n\n\tcout << \"Possible\\n\";\n\tcout << (int)ans.size() - 1 << '\\n';\n\n\tfor (pii f : ans) {\n\t\tcout << f.first << ' ' << f.second << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,L;\nstring A;\nint ismin[256];\n\n\nvector<pair<int,int>> construct(int mask) {\n\tvector<pair<int,int>> V;\n\t\n\tint i;\n\tFOR(i,N) if(mask&(1<<i)) {\n\t\tif(__builtin_popcount(mask)==1) {\n\t\t\tV.push_back({i,1});\n\t\t\tV.push_back({i+1,1});\n\t\t\tV.push_back({i+1,0});\n\t\t\tV.push_back({i,0});\n\t\t}\n\t\telse {\n\t\t\tvector<pair<int,int>> W=construct(mask^(1<<i));\n\t\t\tV.push_back({i,1});\n\t\t\twhile(V.back().first+1<W[0].first) {\n\t\t\t\tV.push_back(V.back());\n\t\t\t\tV.back().first++;\n\t\t\t}\n\t\t\tFORR(w,W) V.push_back(w);\n\t\t\twhile(V.back().first>i) {\n\t\t\t\tV.push_back(V.back());\n\t\t\t\tV.back().first--;\n\t\t\t}\n\t\t\tV.push_back({i,0});\n\t\t\treverse(ALL(W));\n\t\t\twhile(V.back().first+1<W[0].first) {\n\t\t\t\tV.push_back(V.back());\n\t\t\t\tV.back().first++;\n\t\t\t}\n\t\t\tFORR(w,W) V.push_back(w);\n\t\t\twhile(V.back().first>i+1) {\n\t\t\t\tV.push_back(V.back());\n\t\t\t\tV.back().first--;\n\t\t\t}\n\t\t\tV.push_back({i+1,0});\n\t\t\tV.push_back({i,0});\n\t\t}\n\t\tbreak;\n\t}\n\treturn V;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>A;\n\tL=1<<N;\n\tFORR(c,A) c-='0';\n\tFOR(x,L) FOR(y,L) if((x&y)==y && A[x] && A[y]==0) return _P(\"Impossible\\n\");\n\tFOR(x,L) ismin[x]=A[x]==0;\n\tFOR(x,L) if(A[x]==0) FOR(y,L) if((x&y)==y && y<x && A[y]==0) ismin[y]=0;\n\t\n\tvector<pair<int,int>> W;\n\tFOR(x,L) if(A[x]==0 && ismin[x]) {\n\t\tvector<pair<int,int>> V=construct(x);\n\t\tFOR(i,V[0].first) W.push_back({i,1});\n\t\tFORR(v,V) W.push_back(v);\n\t\tfor(i=V[0].first-1;i>=0;i--) W.push_back({i,0});\n\t}\n\tcout<<\"Possible\"<<endl;\n\tcout<<W.size()<<endl;\n\tFORR(w,W) cout<<w.first<<\" \"<<w.second<<endl;\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"base.hpp\"//5\n#ifndef __clang__\n#pragma GCC optimize (\"O3\")\n#endif\nvoid solve(\n#ifdef GCJ_CASE\nlong long case_id\n#endif\n);\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n#define debug true\n#define _GLIBCXX_DEBUG\n// #define _LIBCPP_DEBUG 0\n#define _LIBCPP_DEBUG2 0\n#else\n#define NDEBUG\n#define debug false\n#endif\n#include<algorithm>\n#include<bitset>\n#include<functional>\n#include<iomanip>\n#include<iostream>\n#include<limits>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<type_traits>\n#include<vector>\n#include<cassert>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\nusing LL=long long;\nusing ULL=unsigned long long;\n#define int LL\n#define CS const\n#define CX constexpr\n#define IL inline\n#define OP operator\n#define RT return\n#define TL template\n#define TN typename\n#define lambda [&]\n#define rep(f,t,i,c,u)for(int Rb_=(t),i=(f);i c Rb_;u(i))\n#define upto(f,t,i)rep(f,t,i,<=,++)\n#define uptil(f,t,i)rep(f,t,i,<,++)\n#define downto(f,t,i)rep(f,t,i,>=,--)\n#define downtil(f,t,i)rep(f,t,i,>,--)\n#define times(n,i)uptil(0,n,i)\n#define rtimes(n,i)downto((n)-1,0,i)\n#define iter(v)begin(v),end(v)\n#define citer(v)cbegin(v),cend(v)\n#define riter(v)rbegin(v),rend(v)\n#define criter(v)crbegin(v),crend(v)\n#define IF(a,b,c)((a)?(b):(c))\n#if debug\n#define ln <<endl\n#else\n#define ln <<'\\n'\n#endif\n#define tb <<'\\t'\n#define sp <<' '\n#line 1 \"base_util.hpp\"//5b\n#define BINOPa(t,u,op)t OP op(CS u&o)CS{RT t(*this)op##=o;}\n#define CMPOP(t,op,f1,f2,x)bool OP op(CS t&x)CS{RT f1 op f2;}\n#define CMPOPS(t,f1,f2,x)CMPOP(t,==,f1,f2,x)CMPOP(t,!=,f1,f2,x)\\\nCMPOP(t,<,f1,f2,x)CMPOP(t,<=,f1,f2,x)CMPOP(t,>,f1,f2,x)CMPOP(t,>=,f1,f2,x)\n#line 1 \"mod.hpp\"//5b\n#ifndef MOD\n#define MOD 1000000007\n#endif\n#if !defined(FORCE_MOD)&&MOD!=1000000007&&MOD!=1000000009&&MOD!=998244353\n#error mod\n#endif\n#line 1 \"power.hpp\"//5bm\nTL<TN T>IL T power(T x,int n){T r(1);for(;n;n/=2){if(n%2)r*=x;x*=x;}RT r;}IL int pow_mod(int x,int n,int m){int r=1;\nfor(;n;n/=2){if(n%2)r=r*x%m;x=x*x%m;}RT r;}\n#line 2001 \"mod.hpp\"//5b\nIL CX int modulo(int a,int b){a%=b;RT a&&(a>0)!=(b>0)?a+b:a;}IL CX int divide(int a,int b){RT(a-modulo(a,b))/b;}\nTL<int d=MOD>struct MInt{\n/*!https://ei1333.github.io/luzhiled/snippets/other/mod-int.html*/\nint v;CX MInt():v(0){}explicit CX MInt(int i):v(modulo(i,d)){}MInt&OP+=(CS MInt&m){v+=m.v;if(v>=d)v-=d;RT*this;}\nMInt&OP-=(CS MInt&m){v-=m.v;if(v<0)v+=d;RT*this;}MInt&OP*=(CS MInt&m){v=v*m.v%d;RT*this;}MInt&OP/=(CS MInt&m){\nRT*this*=m.inv();}BINOPa(MInt,MInt,+)BINOPa(MInt,MInt,-)BINOPa(MInt,MInt,*)BINOPa(MInt,MInt,/)MInt OP-()CS{\nRT MInt()-=*this;}CMPOP(MInt,==,v,m.v,m)CMPOP(MInt,!=,v,m.v,m)MInt pow(int n)CS{RT power(*this,n);}MInt inv()CS{\nint a=v,b=d,x=1,y=0;while(b){swap(y,x-=a/b*y);swap(b,a%=b);}RT(MInt)x;}\nfriend ostream&OP<<(ostream&o,CS MInt&m){RT o<<m.v;}friend istream&OP>>(istream&i,MInt&m){i>>m.v;m.v%=d;RT i;}};\nusing mint=MInt<>;CX mint OP\"\" _m(ULL n){RT mint(n);}CX MInt<998244353>OP\"\" _m998244353(ULL n){RT MInt<998244353>(n);}\nCX MInt<1000000007>OP\"\" _m1e9_7(ULL n){RT MInt<1000000007>(n);}\nCX MInt<1000000009>OP\"\" _m1e9_9(ULL n){RT MInt<1000000009>(n);}\n#line 1 \"typedefs.hpp\"//5b\nusing unit = tuple<>;using LD=long double;TL<TN T>using vec=vector<T>;\nTL<TN T>using vvec=vec<vec<T>>;TL<TN T>using vvvec=vec<vvec<T>>;TL<TN T>using vvvvec=vec<vvvec<T>>;\nusing VPII=vec<pair<int, int>>;using PII=pair<int, int>;\n#line 1 \"alias.hpp\"//5b\n#define EB emplace_back\n#define PB push_back\n#define foldl accumulate\n#define scanl partial_sum\n#line 1 \"util.hpp\"//5b\nTL<TN T>IL bool amax(T&v,CS T&a){RT v<a&&(v=a,1);}TL<TN T>IL bool amin(T&v,CS T&a){RT v>a&&(v=a,1);}\nTL<TN T>IL int sizeRAB(T t){RT t.size();}\n#define size sizeRAB\n#define clamp clampRAB\nTL<TN T>IL CX CS T&clamp(CS T&a,CS T&l,CS T&r){RT a<l?l:r<a?r:a;}TL<TN V>IL void uniq2(V&v){\nv.erase(unique(iter(v)),v.end());}TL<TN V>IL void uniq(V&v){sort(iter(v));uniq2(v);}\n#define leftmost_ge lower_bound\n#define leftmost_gt upper_bound\nTL<TN C,TN D>IL C rightmost_le(CS C&from,CS C&to,CS D&d){auto l=leftmost_gt(from,to,d);RT l==from?to:--l;}\nTL<TN C,TN D>IL C rightmost_lt(CS C&from,CS C&to,CS D&d){auto l=leftmost_ge(from,to,d);RT l==from?to:--l;}\nnamespace rab{TL<TN I>IL bool is_in(I x,I l,I r){RT l<=x&&x<r;}TL<TN T>IL T fetch(CS T&d,CS vec<T>&v,int i){\nRT 0<=i&&i<size(v)?v[i]:d;}}\n#line 1 \"debug.hpp\"//5b\nTL<TN T>IL istream&OP>>(istream&s,vec<T>&v){for(auto&&p:v)s>>p;RT s;}TL<TN T,TN S>\nIL ostream&OP<<(ostream&s,CS pair<T,S>&p){RT s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\n#define Rdebug1(sep, ...)IL ostream& OP<<(ostream&s,CS __VA_ARGS__&v){\\\nint i=0;for(CS auto&e:v){i++&&s<<sep;s<<e;}RT s;}\nTL<TN T>Rdebug1(' ',vec<T>)TL<TN T,TN S>Rdebug1(' ',map<T,S>)TL<TN T>Rdebug1('\\n',vvec<T>)\nTL<TN T,TN S>Rdebug1('\\n',vec<map<T,S>>)\n#line 6001 \"base.hpp\"//5\nsigned main(){if(debug)cerr<<\"MOD: \"<<MOD ln;else cin.tie(0),cerr.tie(0),ios::sync_with_stdio(0);\nauto p=setprecision(20);cout<<fixed<<p;cerr<<fixed<<p;\n#ifdef GCJ_CASE\nint T;cin>>T;times(T,t){cout<<\"Case #\"<<t+1<<\": \";solve(t);}\n#else\nsolve();\n#endif\nRT 0;}\n#line 1 \"consts.hpp\"//5\nint di4[]={-1,0,1,0},dj4[]={0,1,0,-1},di8[]={-1,-1,0,1,1,1,0,-1},dj8[]={0,1,1,1,0,-1,-1,-1,-1},\ndi_knight[]={-2,-1,1,2,2,1,-1,-2},dj_knight[]={1,2,2,1,-1,-2,-2,-1};namespace dict{\n[[maybe_unused]]CX char\nYES[]=\"YES\",Yes[]=\"Yes\",yes[]=\"yes\",NO[]=\"NO\",No[]=\"No\",no[]=\"no\",WIN[]=\"WIN\",Win[]=\"Win\",win[]=\"win\",\nLOSE[]=\"LOSE\",Lose[]=\"Lose\",lose[]=\"lose\",OK[]=\"OK\",ok[]=\"ok\",NG[]=\"NG\",ng[]=\"ng\",NA[]=\"NA\",na[]=\"na\",\nAC[]=\"AC\",ac[]=\"ac\",WA[]=\"WA\",wa[]=\"wa\",FIRST[]=\"FIRST\",First[]=\"First\",first[]=\"first\",\nSECOND[]=\"SECOND\",Second[]=\"Second\",second[]=\"second\",\nPOSSIBLE[]=\"POSSIBLE\",Possible[]=\"Possible\",possible[]=\"possible\",\nIMPOSSIBLE[]=\"IMPOSSIBLE\",Impossible[]=\"Impossible\",impossible[]=\"impossible\",\nPRIME[]=\"PRIME\",Prime[]=\"Prime\",prime[]=\"prime\",\nNOT_PRIME[]=\"NOT PRIME\",Not_Prime[]=\"Not Prime\",not_prime[]=\"not prime\",\nUNBOUNDED[]=\"UNBOUNDED\",Unbounded[]=\"Unbounded\",unbounded[]=\"unbounded\",\nALICE[]=\"ALICE\",Alice[]=\"Alice\",alice[]=\"alice\",BOB[]=\"BOB\",Bob[]=\"Bob\",bob[]=\"bob\",\nBROWN[]=\"BROWN\",Brown[]=\"Brown\",brown[]=\"brown\",SAME[]=\"SAME\",Same[]=\"Same\",same[]=\"same\",\nDIFFERENT[]=\"DIFFERENT\",Different[]=\"Different\",different[]=\"different\",\nTAKAHASHI[]=\"TAKAHASHI\",Takahashi[]=\"Takahashi\",takahashi[]=\"takahashi\",AOKI[]=\"AOKI\",Aoki[]=\"Aoki\",aoki[]=\"aoki\";}\n#line 2001 \"5.cpp\"//\n\nvoid solve() {\n// N\"A\"\n/* <foxy.memo-area> */\nint N;string A;cin>>N;cin>>A;\n/* </foxy.memo-area> */\n\n  times(1<<N, b) {\n    times(1<<N, i) {\n      int s = 1;\n      times(N, j) if((i >> j) & 1) s &= (b >> j) & 1;\n      if(A[i] - '0' != s) goto ng;\n    }\n    {\n      {if(debug)cerr<<\"b: \"<<(b)ln;}\n      cout << dict::Possible ln;\n      VPII ans;\n      ans.PB(PII(0, 0));\n      times(N, j) {\n        if((b >> j) & 1) {\n          ans.PB(PII(j+1, 0));\n        } else {\n          ans.PB(PII(j, 1));\n          ans.PB(PII(j+1, 1));\n          ans.PB(PII(j+1, 0));\n        }\n      }\n      rtimes(N, j) {\n        ans.PB(PII(j, 0));\n      }\n      cout << size(ans)-1 ln;\n      times(size(ans), i) {\n        cout << ans[i].first sp << ans[i].second ln;\n      }\n      return;\n    }\n    ng:;\n  }\n\n  cout << dict::Impossible ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i = (begin); i < (end); i++)\n#define rep(i, n) FOR(i, 0, n)\nusing ll = long long;\nusing namespace std;\n#define all(x) (x).begin(),(x).end()\nusing pii = pair<int, int>; using vi = vector<int>; using vl = vector<ll>;\n\nint N;\nbool isSubsetOf(int i, int oo) {\n    return (oo | i) == oo && i != oo;\n}\n\nsigned main() {\n    cin >> N;\n    // unordered_set<int> oo, ii;\n    int oo = 0;\n    vi sss;\n    string as;\n    cin >> as;\n    rep(i, 1<<N) {\n        // auto ss = setter(i);\n        if(as[i] == '1') {\n            oo |= i;\n        }\n    }\n    rep(i, 1<<N) {\n        if(isSubsetOf(i, oo) && as[i] == '0') {\n            cout << \"Impossible\" << endl;\n            return 0;\n        } else if(!isSubsetOf(i, oo) && as[i] == '1') {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n    \n    cout << \"Possible\" << endl;\n\n    int ii = (1<<N) - oo - 1;\n    // cerr << oo << ' ' << ii << endl;\n    // cerr << (oo & ii) << endl;\n    vector<pii> p;\n    int before = 0;\n    // cerr << ii << endl;\n    rep(i, N) {\n        // cerr << ii << endl;\n        // cerr << ((ii&1) ^ before) << endl;\n        if((ii&1) ^ before) {\n            if(ii&1) {\n                p.push_back({i, 0});\n                p.push_back({i, 1});\n            } else {\n                p.push_back({i, 1});\n                p.push_back({i, 0});\n            }\n        } else {\n            p.push_back({i, before});\n        }\n        before = ii & 1;\n        ii >>= 1;\n    }\n    if (before == 1)\n        p.push_back({N, 1});\n    for(int k = N; k>=0; k--) {\n        p.push_back({k, 0});\n    }\n\n    cout << p.size() - 1 << endl;\n    for(auto pp : p) {\n        cout << pp.first << ' ' << pp.second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <decimal/decimal>\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define rep(i, s, t) for (int i = s; i < int(t); ++i)\n\n#define sc\tscanf\n#define pr\tprintf\n#define ff\tfirst\n#define ss\tsecond\n#define mp\tmake_pair\n#define pb\tpush_back\n#define eb\templace_back\n#define range(c)\tc.begin(), c.end()\n#define lowbit(x)\t((x) & -(x))\n#define pop_count\t__builtin_popcount\n#define pop_count_64\t__builtin_popcountll\n#define tail_count\t__builtin_ctz\n#define tail_count_64\t__builtin_ctzll\n#define lead_count\t__builtin_clz\n#define lead_count_64\t__builtin_clzll\n\n#define TEMP template<typename\n#define CONST(type) constexpr type const\n\nTEMP... Ts> struct is_con { static CONST(bool) value = false; };\nTEMP... Ts> struct is_con<vector<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<list<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<deque<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<set<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<unordered_set<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<map<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<unordered_map<Ts...>> { static CONST(bool) value = true; };\n\nTEMP T1, typename T2> ostream& operator<<(ostream& os, pair<T1, T2> const& p) { return os << \"<\" << p.ff << \",\" << p.ss << \">\"; }\nTEMP T> typename enable_if<is_con<T>::value, ostream>::type& operator<<(ostream& os, T const& c) {\n\tos << \"{\";\n\tbool first = true;\n\tfor (auto const& x : c) {\n\t\tif (first) first = false;\n\t\telse os << \",\";\n\t\tos << \" \" << x;\n\t}\n\treturn os << \" }\";\n}\n\nTEMP T, typename... Ts> void dbg(T h, Ts... t) { cerr << \" \" << h; dbg<Ts...>(t...); }\ntemplate<> void dbg<int>(int x) { cerr << endl; }\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[ \"#__VA_ARGS__\" ] :\", dbg(__VA_ARGS__, 0)\n#else\n#define debug(...) 0\n#endif\n\nTEMP T, typename U> using ordered_map = tree<T, U, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\nTEMP T> using ordered_set = ordered_map<T, null_type>;\n\ntypedef long long i64;\ntypedef decimal::decimal128 i99;\ntypedef unsigned int u32;\ntypedef unsigned long long u64;\ntypedef float f32;\ntypedef double f64;\ntypedef long double f80;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<i64> vl;\n\nTEMP T> T& minn(T& lhs, T const& rhs) { return lhs = min(lhs, rhs); }\nTEMP T> T& maxx(T& lhs, T const& rhs) { return lhs = max(lhs, rhs); }\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n;\n\tstring a;\n\tcin >> n >> a;\n\tvi dp(1 << n);\n\trep(s, 0, 1 << n) dp[s] = a[s] == '0';\n\tdebug(dp);\n\trep(i, 0, n) rep(s, 0, 1 << n) if (s >> i & 1) dp[s] |= dp[s ^ 1 << i];\n\tdebug(dp);\n\tbool ok = true;\n\trep(s, 0, 1 << n) ok &= dp[s] ^ (a[s] == '1');\n\tvi clique;\n\trep(s, 0, 1 << n) if (dp[s]) {\n\t\tbool check = true;;\n\t\trep(t, 0, 1 << n) if (t != s && (s & t) == t) check &= !dp[t];\n\t\tif (check) clique.pb(s);\n\t}\n\tint tot = 0, cnt = 0;\n\tfor (int s : clique) {\n\t\tint x = pop_count(s);\n\t\tok &= x <= 2;\n\t\ttot |= s;\n\t\tcnt += x;\n\t}\n\tok &= cnt == pop_count(tot);\n\tif (!ok) return cout << \"Impossible\" << endl, 0;\n\tcout << \"Possible\" << endl;\n\tdebug(clique);\n\tvector<pii> ans(1);\n\tfor (int s : clique) {\n\t\tif (s == lowbit(s)) {\n\t\t\tint x = tail_count(s);\n\t\t\trep(i, 1, x + 1) ans.eb(i, 0);\n\t\t\tans.eb(x + 1, 0);\n\t\t\tans.eb(x + 1, 1);\n\t\t\tans.eb(x, 1);\n\t\t\tfor (int i = x; i >= 0; --i) ans.eb(i, 0);\n\t\t} else {\n\t\t\tint x = tail_count(s);\n\t\t\ts ^= lowbit(s);\n\t\t\tint y = tail_count(s);\n\t\t\trep(i, 1, y + 1) ans.eb(i, 0);\n\t\t\tans.eb(y + 1, 0);\n\t\t\tans.eb(y + 1, 1);\n\t\t\tans.eb(y, 1);\n\t\t\tfor (int i = y; i >= x; --i) ans.eb(i, 0);\n\t\t\trep(i, x, y + 2) ans.eb(i, 1);\n\t\t\tfor (int i = y + 1; i > x; --i) ans.eb(i, 0);\n\t\t\tans.eb(x + 1, 1);\n\t\t\tans.eb(x, 1);\n\t\t\tfor (int i = x; i >= 0; --i) ans.eb(i, 0);\n\t\t}\n\t}\n\tcout << ans.size() - 1 << endl;\n\tfor (auto const& p : ans) cout << p.ff << \" \" << p.ss << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing ll = long long;\nusing ull = unsigned long long;\nusing namespace std;\nconst int INF = 1e10;\nconst int MOD = 1e9 + 7;\n#define dump(x)                             \\\n    if (dbg) {                              \\\n        cerr << #x << \" = \" << (x) << endl; \\\n    }\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define FOR1(n) for (ll i = 0; i < (n); ++i)\n#define FOR2(i, n) for (ll i = 0; i < (n); ++i)\n#define FOR3(i, a, b) for (ll i = (a); i < (b); ++i)\n#define FOR4(i, a, b, c) for (ll i = (a); i < (b); i += (c))\n#define FOR(...) overload4(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)\n#define FORR(i, a, b) for (int i = (a); i <= (b); ++i)\n#define bit(n, k) ((n >> k) & 1) /*nのk bit目*/\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\nvoid Yes(bool flag = true) {\n    if (flag)\n        cout << \"Yes\" << endl;\n    else\n        cout << \"No\" << endl;\n}\nvoid No(bool flag = true) {\n    Yes(!flag);\n}\nvoid YES(bool flag = true) {\n    if (flag)\n        cout << \"YES\" << endl;\n    else\n        cout << \"NO\" << endl;\n}\nvoid NO(bool flag = true) {\n    YES(!flag);\n}\n#define pb emplace_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define all(v) (v).begin(), (v).end()\n#define SZ(x) ((int)(x).size())\n#define P pair<int, int>\n//#define V vector<int>\n//#define S set<int>\n#define itn int\nbool dbg = false;\n\nint N;\nstring A;\nbool checked[111010];\nbool out[111010];\n\nvector<int> x, y;\n\nvoid go(int gx) {\n    int sx;\n    int ys;\n    sx = x[(int)x.size() - 1];\n    ys = y[(int)y.size() - 1];\n    if (sx > gx) {\n        while (sx != gx) {\n            sx--;\n            x.pb(sx);\n            y.pb(ys);\n        }\n    } else if (sx < gx) {\n        while (sx != gx) {\n            sx++;\n            x.pb(sx);\n            y.pb(ys);\n        }\n    }\n}\nvoid chy() {\n    x.pb(x[(int)x.size() - 1]);\n    y.pb(!y[(int)y.size() - 1]);\n}\n\nvoid fill(int T, bool nikai = false) {\n    int cnt = __builtin_popcount(T);\n    if (cnt == 1) {\n        int nxt = __builtin_ffs(T) - 1;\n        go(nxt);\n        chy();\n        go(nxt + 1);\n        chy();\n        go(nxt);\n        chy();\n        go(nxt + 1);\n        chy();\n        go(nxt);\n        chy();\n        go(nxt + 1);\n        chy();\n        go(nxt);\n        return;\n    } else {\n        int n1 = __builtin_ffs(T) - 1;\n        T -= (1 << n1);\n        int n2 = __builtin_ffs(T) - 1;\n        int n3 = n2;\n        FOR(N) {\n            if ((1 << i) & T) {\n                n3 = i;\n            }\n        }\n        n3++;\n\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        go(n2);\n        //ここで再帰\n        if (n2 + 1 != n3) {\n            fill(T);\n        }\n        chy();\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        go(n2);\n        chy();\n        go(n1);\n\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        go(n2);\n        chy();\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        go(n2);\n        chy();\n        go(n1);\n    }\n}\n\n\nvoid solve() {\n    bool flag = true;\n    int tmp = -1;\n    for (int T = 1; T < (1 << N); T++) {\n        if (A[T] == 1) {\n            continue;\n        }\n        if (checked[T]) {\n            continue;\n        }\n        out[T] = true;\n        if (__builtin_popcount(T) == 1) {\n            tmp = T;\n        }\n        for (int i = T; i < (1 << N); i = (i + 1) | T) {\n            // ここに処理を書く\n            if (A[i] == 1) {\n                flag = false;\n            }\n            checked[i] = true;\n        }\n    }\n    if (!flag) {\n        cout << \"Impossible\" << endl;\n        return;\n    }\n    cout << \"Possible\" << endl;\n\n    x.pb(0);\n    y.pb(0);\n\n    for (int T = 1; T < (1 << N); T++) {\n        if (out[T]) {\n            fill(T);\n        }\n    }\n    go(0);\n    int L = x.size();\n    cout << L - 1 << endl;\n\n    FOR(L) {\n        cout << x[i] << \" \" << y[i] << endl;\n    }\n}\n\nsigned main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cin >> N;\n    cin >> A;\n    for (auto& c : A)\n        c -= '0';\n\n\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\n\ntemplate <class T1, class T2>\nostream& operator << (ostream& out, const pair <T1, T2> p)\n{\n    out << '(' << p.first << ',' << p.second << ')';\n    return out;\n}\n\ntemplate <class T1, class T2>\nistream& operator >> (istream& in, pair<T1, T2> &p)\n{\n    in >> p.first >> p.second;\n    return in;\n}\n\ntemplate <class T>\nistream& operator >> (istream& in, vector<T> &v)\n{\n    for (T &x : v)\n        in >> x;\n    return in;\n}\n\ntemplate <class T>\nostream& operator << (ostream& out, const vector<vector<T>> &v)\n{\n    for (const vector<T> &x : v)\n        out << x << '\\n';\n    return out;\n}\n\ntemplate <class T>\nostream& operator << (ostream& out, const vector<T> &v)\n{\n    for (const T &x : v)\n        out << x << ' ';\n    return out;\n}\n\nlong long gcd (long long a, long long b)\n{\n    if (b > a)\n        swap(a, b);\n    return (b ? gcd(b, a % b) : a);\n}\n\nusing ll   = long long;\nusing pii  = pair<int, int>;\nusing pll  = pair<long long, long long>;\nusing tiii = pair<pair<int, int>, int>;\nusing vi   = vector<int>;\nusing vl   = vector<long long>;\nusing vvi  = vector<vector<int>>;\nusing vvl  = vector<vector<long long>>;\n\n#define F          first\n#define S          second\n#define First      first.first\n#define Second     first.second\n#define Third      second\n#define mp         make_pair\n#define rep(i,a,b) for (int i = (a); i < (b); i++)\n#define per(i,b,a) for (int i = (b); i > (a); i--)\n#define all(x)     x.begin(), x.end()\n#define ret(x)     return cout << x, 0;\n#define throwex    throw runtime_error (\"Found the error.\");\n\nconst int h = 1000000007;\n\nint n;\nvector<pii> get_cycle(int mask, int cur = 0)\n{\n    int last_1_index = 0;\n    int z = mask;\n    while(z != 1)\n        last_1_index++, z /= 2;\n    // cerr << last_1_index << '\\n';\n    vector<pii> ans;\n    if(cur == last_1_index)\n    {\n        ans.push_back({cur, 1});\n        ans.push_back({cur+1, 1});\n        ans.push_back({cur+1, 0});\n        ans.push_back({cur, 0});\n        ans.push_back({cur, 1});\n        return ans;\n    }\n    ans.push_back({cur, 1});\n    vector<pii> next_cycle = get_cycle(mask, cur + 1);\n    ans.insert(ans.end(), all(next_cycle));\n    ans.push_back({cur, 1});\n    if(mask & (1 << cur))\n    {\n        ans.push_back({cur, 0});\n        ans.push_back({cur+1, 0});\n        reverse(all(next_cycle));\n        ans.insert(ans.end(), all(next_cycle));\n        ans.push_back({cur+1, 0});\n        ans.push_back({cur, 0});\n        ans.push_back({cur, 1});\n    }\n    return ans;\n}\n\nsigned main()\n{\n    ios::sync_with_stdio(false);\n    #ifdef ONLINE_JUDGE\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    cerr.setstate(ios::failbit);\n    #endif\n\n    cin >> n;\n    string a;\n    cin >> a;\n    rep(i,0,1 << n)\n    {\n        rep(j,0,i)\n        {\n            if((j | i) == i and a[i] == '1' and a[j] == '0')\n                ret(\"Impossible\");\n        }\n    }\n    vector<pii> ans;\n    ans.push_back({0, 1});\n    rep(i,0,1 << n)\n    {\n        if(a[i] == '0')\n        {\n            vector<pii> cycle = get_cycle(i);\n            ans.insert(ans.end(), cycle.begin() + 1, cycle.end());\n            for(int j = i; j < (1 << n); j++)\n                if((i | j) == j)\n                    a[j] = '1';\n            cerr << i << '\\n';\n            cerr << cycle << '\\n';\n        }\n    }\n    assert(ans.size() <= 250000);\n    cout << \"Possible\\n\";\n    cout << ans.size() - 1 << '\\n';\n    for(pii x : ans)\n        cout << x.F << ' ' << x.S << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint N; char str[1 << 8 | 1];\nvector < int > pot;\nvector < int > operator +(vector < int > p , vector < int > q){p.insert(p.end() , q.begin() , q.end()); return p;}\n\nvector < int > build(int id , int x){\n\tif(id < (1 << (x + 1))) return vector < int >{x + 1 , -x - 1};\n\tvector < int > tmp = build(id , x + 1);\n\tif(!(id >> x & 1)) return vector < int >{x + 1} + tmp + vector < int >{x + 1};\n\tvector < int > rev = tmp; reverse(rev.begin() , rev.end());\n\treturn vector < int >{x + 1} + tmp + vector < int >{x + 1} + vector < int >{-x - 1} + rev + vector < int >{-x - 1};\n}\n\nint main(){\n\tscanf(\"%d %s\" , &N , str);\n\tfor(int i = 0 ; i < 1 << N ; ++i)\n\t\tif(str[i] == '1')\n\t\t\tfor(int j = 0 ; j < N ; ++j)\n\t\t\t\tif((i >> j & 1) && str[i ^ (1 << j)] != '1'){\n\t\t\t\t\tputs(\"Impossible\"); return 0;\n\t\t\t\t}\n\tfor(int i = 0 ; i < 1 << N ; ++i)\n\t\tif(str[i] == '0'){\n\t\t\tbool flg = 1;\n\t\t\tfor(int j = 0 ; j < N ; ++j)\n\t\t\t\tif((i >> j & 1) && str[i ^ (1 << j)] == '0')\n\t\t\t\t\tflg = 0;\n\t\t\tif(flg) pot = pot + build(i , 0);\n\t\t}\n\tputs(\"Possible\"); vector < pair < int , int > > node;\n\tint curx = 0 , cury = 0; node.push_back(make_pair(0 , 0));\n\tfor(int i = 0 ; i < pot.size() ; ++i){\n\t\tif(pot[i] < 0 && cury == 1) node.push_back(make_pair(curx , cury = 0));\n\t\tif(pot[i] > 0 && cury == 0) node.push_back(make_pair(curx , cury = 1));\n\t\tint t = abs(pot[i]) - 1;\n\t\tif(curx == t) node.push_back(make_pair(++curx , cury));\n\t\telse node.push_back(make_pair(--curx , cury));\n\t}\n\tif(cury) node.push_back(make_pair(0 , 0));\n\tprintf(\"%d\\n\" , node.size() - 1);\n\tfor(auto t : node) printf(\"%d %d\\n\" , t.first , t.second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid fail(){\n\tcout << \"Impossible\" << '\\n';\n\texit(0);\n}\n\nmt19937 mt(48);\n\nvector<int> inv(vector<int> x){\n\treverse(x.begin(), x.end());\n\tfor(int& a : x) a = -a;\n\treturn x;\n}\n\nvector<int> make(vector<int> val){\n\tif(val.size() == 1){\n\t\tint f = mt() & 4;\n\t\tf -= 2;\n\t\tif(f == 0) f++;\n\t\tvector<int> x;\n\t\tif(f < 0){\n\t\t\tfor(int r = 0; r < -f; r++) x.push_back(-val.front());\n\t\t} else {\n\t\t\tfor(int r = 0; r < f; r++) x.push_back(val.front());\t\t\t\n\t\t}\n\t\treturn x;\n\t}\n\tvector<int> nval[2];\n\tvector<int> nx[2];\n\tfor(int i = 0; i < (int)val.size(); i++){\n\t\tnval[i & 1].push_back(val[i]);\n\t}\n\tnx[0] = make(nval[0]);\n\tnx[1] = make(nval[1]);\n\tvector<int> x;\n\tfor(int r : nx[0]) x.push_back(r);\n\tfor(int r : nx[1]) x.push_back(r);\n\tfor(int r : inv(nx[0])) x.push_back(r);\n\tfor(int r : inv(nx[1])) x.push_back(r);\n\treturn x;\n}\n\nvoid pr(vector<int> x){\n\tvector<pair<int,int> > path;\n\tpath.push_back({0, 0});\n\tfor(int f : x){\n\t\tint c = 0;\n\t\tint val = abs(f) - 1;\n\t\twhile(c < val){\n\t\t\tc++;\n\t\t\tpath.push_back({c, 0});\n\t\t}\n\t\tif(f > 0){\n\t\t\tpath.push_back({c, 1});\n\t\t\tpath.push_back({c+1, 1});\n\t\t\tpath.push_back({c+1, 0});\n\t\t\tpath.push_back({c, 0});\n\t\t} else {\n\t\t\tpath.push_back({c+1, 0});\n\t\t\tpath.push_back({c+1, 1});\n\t\t\tpath.push_back({c, 1});\n\t\t\tpath.push_back({c, 0});\n\t\t}\n\t\twhile(c > 0){\n\t\t\tc--;\n\t\t\tpath.push_back({c, 0});\n\t\t}\n\t}\n\tcout << \"Possible\" << '\\n';\n\tcout << (int)path.size() - 1 << '\\n';\n\tfor(pair<int,int> a : path){\n\t\tcout << a.first << ' ' << a.second << '\\n';\n\t}\n}\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint n;\n\tcin >> n;\n\tint N = (1 << n);\n\tstring s(N, '0');\n\tcin >> s;\n\t// for(int j = 0; j < N; j++){\n\t// \ts[j] = \"01\"[(__builtin_popcount(j | (j >> 1)) <= 3)];\n\t// }\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tif((i & j) == i){\n\t\t\t\tif(s[i] < s[j]){\n\t\t\t\t\tfail();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<int> > q;\n\tfor(int i = 0; i < N; i++){\n\t\tif(s[i] == '1') continue;\n\t\tvector<int> val;\n\t\tbool fail = false;\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tif((i >> j) & 1){\n\t\t\t\tval.push_back((j+1));\n\t\t\t\tif(s[i ^ (1 << j)] == '0') fail = true;\n\t\t\t}\n\t\t}\n\t\tif(fail) continue;\n\t\tshuffle(val.begin(), val.end(), mt);\n\t\tq.push_back(val);\n\t}\n\twhile(true){\n\t\tvector<int> ans;\n\t\tshuffle(q.begin(), q.end(), mt);\n\t\tfor(vector<int> val : q){\n\t\t\tvector<int> z = make(val);\n\t\t\tfor(int v : z) ans.push_back(v);\n\t\t}\n\t\tbool works = true;\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tvector<int> stk = {0};\n\t\t\tfor(int f : ans){\n\t\t\t\tif((j >> (abs(f) - 1)) & 1){\n\t\t\t\t\tif(stk.back() == -f){\n\t\t\t\t\t\tstk.pop_back();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstk.push_back(f);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint wins = (stk.size() == 1);\n\t\t\tif(wins != s[j] - '0'){\n\t\t\t\tcerr << j << ' ' << wins << ' ' << (s[j] - '0') << '\\n';\n\t\t\t\tworks = false;\n\t\t\t}\n\t\t}\n\t\tif(!works) continue;\n\t\tcerr << ans.size() << '\\n';\n\t\tfor(int x : ans){\n\t\t\tcerr << x << ' ';\n\t\t}\n\t\tcerr << '\\n';\n\t\tpr(ans);\n\t\texit(0);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> rec(int x) {\n\tvector <int> sol;\n\tint pet = 1, bit;\n\tfor (bit = 0; (x&pet) == 0; bit++)\n\t\tpet = 1<<bit;\n\tif (pet == x) {\n\t\tsol.push_back(bit);\n\t\treturn sol;\n\t}\n\tvector<int> aux = sol  = rec(x^pet);\n\tsol.push_back(bit);\n\tfor (auto it = aux.rbegin(); it != aux.rend(); it++)\n\t\tsol.push_back(-*it);\n\tsol.push_back(-bit);\n\treturn sol;\n}\n\nstring tira(const vector<int> & par) {\n\tstring sol;\n\tfor (int x: par) {\n\t\tsol += string(abs(x)-1,'R');\n\t\tif (x > 0) sol += \"URDL\";\n\t\telse sol += \"RULD\";\n\t\tsol += string(abs(x)-1,'L');\n\t}\n\treturn sol;\n}\n\n\nint main() {\n  ios_base::sync_with_stdio(false); \n  cin.tie(nullptr); \n\n\tint n;\n\tcin >> n;\n\tstring s;\n\tcin >> s;\n\tint m = 1<<n;\n\tbool ok = true;\n\tvector<int> obs;\n\tfor (int i = 1; i < m; i++) {\n\t\tif (s[i] == '0') obs.push_back(i+1);\n\t\tfor (int j = i+1; j < m; j++) {\n\t\t\tint p = i, g = j;\n\t\t\tif (p > g) swap(p, g);\n\t\t\tif ((p&g) == p and s[p] == '0' and s[g] == '1') ok = false;\n\t\t}\n\t}\n\tif (!ok) cout << \"Impossible\" << endl;\n\telse {\n\t\tcout << \"Possible\" << endl;\n\t\tstring sol;\n\t\tfor (auto x: obs) \n\t\t\tsol += tira(rec(x));\n\t\tint k = sol.size();\n\t\tcout << k   << endl;\n\t\tassert(k <= 250000);\n\t\tint px = 0, py = 0; \n\t\tcout << px << \" \" << py << \"\\n\";\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tif (sol[i] == 'U') py++;\n\t\t\telse if (sol[i] == 'D') py--;\n\t\t\telse if (sol[i] == 'L') px--;\n\t\t\telse if (sol[i] == 'R') px++;\n\t\t\tcout << px << \" \" << py << \"\\n\";\n\t\t}\n\t}\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int N=1<<10;\nint n;\nchar s[N];\nint p[N];\nvector<pair<int,int> > solve(int S,int now)\n{\n\tvector<pair<int,int> >res;\n\tfor(int i=now+1;i<n;i++)\n\t\tif(S&(1<<i))\n\t\t{\n\t\t\tvector<pair<int,int> > t=solve(S,i);\n\t\t\tfor(int j=now;j<=i-1;j++)\n\t\t\t\tres.push_back(make_pair(j,1));\n\t\t\tfor(auto [x,y]:t)\n\t\t\t\tres.push_back(make_pair(x,y));\n\t\t\tfor(int j=i;j>=now;j--)\n\t\t\t\tres.push_back(make_pair(j,1));\n\t\t\tres.push_back(make_pair(now,0));\n\t\t\tres.push_back(make_pair(now+1,0));\n\t\t\tfor(int j=now+1;j<=i;j++)\n\t\t\t\tres.push_back(make_pair(j,1));\n\t\t\treverse(t.begin(),t.end());\n\t\t\tfor(auto [x,y]:t)\n\t\t\t\tres.push_back(make_pair(x,y));\n\t\t\tfor(int j=i-1;j>=now+1;j--)\n\t\t\t\tres.push_back(make_pair(j,1));\n\t\t\tres.push_back(make_pair(now+1,0));\n\t\t\tres.push_back(make_pair(now,0));\n\t\t\treturn res;\n\t\t}\n\tres.push_back(make_pair(now,1));\n\tres.push_back(make_pair(now+1,1)); \n\tres.push_back(make_pair(now+1,0));\n\tres.push_back(make_pair(now,0));\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s);\n\tfor(int i=0;i<(1<<n);i++)\n\t\tp[i]=s[i]-'0';\n\tif(p[0]==0)\n\t{\n\t\tprintf(\"Impossible\");\n\t\treturn 0;\n\t}\n\tfor(int s=0;s<(1<<n);s++)\n\t\tif(p[s]==1)\n\t\t\tfor(int i=s;i;i=(i-1)&s)\n\t\t\t\tif(p[i]==0)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"Impossible\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\tvector<pair<int,int> >ans;\n\tans.push_back(make_pair(0,0));\n\tfor(int s=1;s<(1<<n);s++)\n\t\tif(p[s]==0)\n\t\t{\n\t\t\tbool flag=true;\n\t\t\tfor(int i=(s-1)&s;i;i=(i-1)&s)\n\t\t\t\tif(p[i]==0)\n\t\t\t\t{\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif(!flag) continue;\n\t\t\tvector<pair<int,int> >res;\n\t\t\tvector<pair<int,int> >t;\n\t\t\tint u=0;\n\t\t\tfor(u=0;u<n;u++)\n\t\t\t\tif(s&(1<<u))\n\t\t\t\t{\n\t\t\t\t\tt=solve(s,u);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif(ans.back()!=make_pair(0,0)) res.push_back(make_pair(0,0));\n\t\t\tfor(int i=0;i<=u-1;i++)\n\t\t\t\tres.push_back(make_pair(i,1));\n\t\t\tfor(auto [x,y]:t)\n\t\t\t\tres.push_back(make_pair(x,y));\n\t\t\tfor(int i=u;i>=0;i--)\n\t\t\t\tres.push_back(make_pair(i,1));\n\t\t\tres.push_back(make_pair(0,0));\n\t\t\tfor(auto [x,y]:res)\n\t\t\t\tans.push_back(make_pair(x,y));\n\t\t}\n\tprintf(\"Possible\\n\");\n\tint len=ans.size()-1;\n\tprintf(\"%d\\n\",len);\n\tfor(auto [x,y]:ans)\n\t\tprintf(\"%d %d\\n\",x,y);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst char* IMPOSSIBLE = \"Impossible\";\nconst char* POSSIBLE = \"Possible\";\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint N; cin >> N;\n\tvector<bool> A(1<<N);\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tchar c; cin >> c;\n\t\tassert(c == '0' || c == '1');\n\t\tA[(1<<N)-1-m] = (c == '1');\n\t}\n\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\t// m2 is a superset\n\t\t\tif (A[m] > A[m | (1<<i)]) {\n\t\t\t\tcout << IMPOSSIBLE << '\\n';\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t}\n\tcout << POSSIBLE << '\\n';\n\tmt19937 mt(48);\n\tvector<int> minM;\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tif (!A[m]) continue;\n\t\tbool isMinimal = true;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif ((m & (1<<i)) && A[m ^ (1<<i)]) {\n\t\t\t\tisMinimal = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isMinimal) {\n\t\t\tminM.push_back(m);\n\t\t}\n\t}\n\tshuffle(minM.begin(), minM.end(), mt);\n\n\tqueue<vector<int>> q;\n\tfor (int m : minM) {\n\t\tvector<int> v;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (m & (1<<i)) {\n\t\t\t\tv.push_back(i+1);\n\t\t\t}\n\t\t}\n\t\tfor (int i = N-1; i >= 0; i--) {\n\t\t\tif (m & (1<<i)) {\n\t\t\t\tv.push_back(i+1);\n\t\t\t}\n\t\t}\n\t\t//shuffle(v.begin(), v.end(), mt);\n\t\tq.push(v);\n\t}\n\n\twhile (q.size() >= 2) {\n\t\tvector<int> a = std::move(q.front()); q.pop();\n\t\tvector<int> b = std::move(q.front()); q.pop();\n\n\t\tvector<int> c;\n\t\tfor (int i : a) { c.push_back(i); }\n\t\tfor (int i : b) { c.push_back(i); }\n\t\treverse(a.begin(), a.end());\n\t\treverse(b.begin(), b.end());\n\t\tfor (int i : a) { c.push_back(-i); }\n\t\tfor (int i : b) { c.push_back(-i); }\n\t\tq.push(c);\n\t}\n\n\tvector<int> pattern;\n\tif (!q.empty()) {\n\t\tpattern = std::move(q.front()); q.pop();\n\t}\n\n\tvector<bool> patA(1<<N);\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tstack<int> st;\n\t\tfor (int i : pattern) {\n\t\t\tif (m & (1<<(abs(i)-1))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!st.empty() && st.top() == -i) {\n\t\t\t\tst.pop();\n\t\t\t} else {\n\t\t\t\tst.push(i);\n\t\t\t}\n\t\t}\n\t\tpatA[m] = st.empty();\n\t}\n\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tassert(patA[m] >= A[m]);\n\t}\n\n\tvector<pair<int, int>> pos;\n\tpos.emplace_back(0,1);\n\tauto goToPt = [&](int x) {\n\t\tassert(pos.back().second == 1);\n\t\tif (pos.back() == pair<int, int>(x,1)) {\n\t\t\treturn;\n\t\t}\n\t\tpos.emplace_back(pos.back().first, 0);\n\t\twhile (pos.back().first < x) {\n\t\t\tpos.emplace_back(pos.back().first+1, 0);\n\t\t}\n\t\twhile (pos.back().first > x) {\n\t\t\tpos.emplace_back(pos.back().first-1, 0);\n\t\t}\n\t\tpos.emplace_back(x,1);\n\t};\n\tfor (auto i : pattern) {\n\t\tassert(i != 0);\n\t\tif (i > 0) {\n\t\t\tgoToPt(i-1);\n\t\t\tpos.emplace_back(i, 1);\n\t\t} else {\n\t\t\tgoToPt(-i);\n\t\t\tpos.emplace_back(-i-1, 1);\n\t\t}\n\t}\n\n\tgoToPt(0);\n\n\tif (int(pos.size()) - 1 > 250000) {\n\t\twhile (true);\n\t}\n\tcout << pos.size()-1 << '\\n';\n\tfor (auto it : pos) {\n\t\tcout << it.first << ' ' << it.second << '\\n';\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> rec(int x) {\n\tvector <int> sol;\n\tint pet = 1, bit;\n\tfor (bit = 0; (x&pet) == 0; bit++)\n\t\tpet = 1<<bit;\n\tif (pet == x) {\n\t\tsol.push_back(bit);\n\t\treturn sol;\n\t}\n\tvector<int> aux = sol  = rec(x^pet);\n\tsol.push_back(bit);\n\tfor (auto it = aux.rbegin(); it != aux.rend(); it++)\n\t\tsol.push_back(-*it);\n\tsol.push_back(-bit);\n\treturn sol;\n}\n\nstring tira(const vector<int> & par) {\n\tstring sol;\n\tfor (int x: par) {\n\t\tsol += string(abs(x),'R');\n\t\tif (x > 0) sol += \"URDL\";\n\t\telse sol += \"RULD\";\n\t\tsol += string(abs(x),'L');\n\t}\n\treturn sol;\n}\n\n\nint main() {\n  ios_base::sync_with_stdio(false); \n  cin.tie(nullptr); \n\n\tint n;\n\tcin >> n;\n\tstring s;\n\tcin >> s;\n\tint m = 1<<n;\n\tbool ok = true;\n\tvector<int> obs;\n\tfor (int i = 1; i < m; i++) {\n\t\tif (s[i] == '0') obs.push_back(i);\n\t\tfor (int j = i+1; j < m; j++) {\n\t\t\tint p = i, g = j;\n\t\t\tif (p > g) swap(p, g);\n\t\t\tif ((p&g) == p and s[p] == '1' and s[g] == '0') ok = false;\n\t\t}\n\t}\n\tif (!ok) cout << \"Impossible\" << endl;\n\telse {\n\t\tcout << \"Possible\" << endl;\n\t\tstring sol;\n\t\tfor (auto x: obs) \n\t\t\tsol += tira(rec(x));\n\t\tint k = sol.size();\n\t\tcout << k   << endl;\n\t\tint px = 0, py = 0; \n\t\tcout << px << \" \" << py << \"\\n\";\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tif (sol[i] == 'U') py++;\n\t\t\telse if (sol[i] == 'D') py--;\n\t\t\telse if (sol[i] == 'L') px--;\n\t\t\telse if (sol[i] == 'R') px++;\n\t\t\tcout << px << \" \" << py << \"\\n\";\n\t\t}\n\t}\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <bits/stdc++.h>\n#include <random>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define sz(x) ((int)(x).size())\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef pair<int, int> pii;\ntypedef double db;\nmt19937 mrand(random_device{}());\nconst ll mod = 998244353;\nint rnd(int x) { return mrand() % x; }\nll powmod(ll a, ll b) { ll res = 1; a %= mod; assert(b >= 0); for (; b; b >>= 1) { if (b & 1)res = res * a%mod; a = a * a%mod; }return res; }\nll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\n// head\n\nstatic uint MD;\nstruct ModInt {\n\tusing M = ModInt;\n\tuint v;\n\tModInt(ll _v = 0) { set_v(uint(_v % MD + MD)); }\n\tM& set_v(uint _v)\n\t{\n\t\tv = (_v < MD) ? _v : _v - MD;\n\t\treturn *this;\n\t}\n\texplicit operator bool() const { return v != 0; }\n\tM operator-() const { return M() - *this; }\n\tM operator+(const M& r) const { return M().set_v(v + r.v); }\n\tM operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n\tM operator*(const M& r) const { return M().set_v(uint(ull(v) * r.v % MD)); }\n\tM operator/(const M& r) const { return *this * r.inv(); }\n\tM& operator+=(const M& r) { return *this = *this + r; }\n\tM& operator-=(const M& r) { return *this = *this - r; }\n\tM& operator*=(const M& r) { return *this = *this * r; }\n\tM& operator/=(const M& r) { return *this = *this / r; }\n\tbool operator==(const M& r) const { return v == r.v; }\n\tM pow(ll n) const\n\t{\n\t\tM x = *this, r = 1;\n\t\twhile (n) {\n\t\t\tif (n & 1) r *= x;\n\t\t\tx *= x;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn r;\n\t}\n\tM inv() const { return pow(MD - 2); }\n\tfriend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\nusing Mint = ModInt;\n\nconst int MAXN = 100000 + 5;\n\nbool valid(int mask, string& s)\n{\n\tint len = sz(s);\n\trep(i, 0, len)\n\t{\n\t\tif (s[i] == '1') {\n\t\t\tif (mask&i) return false;\n\t\t}\n\t\telse {\n\t\t\tif ((mask&i) == 0) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//\tfreopen(\"a.in\",\"r\",stdin);\n\t//\tfreopen(\"a.out\",\"w\",stdout);\n\n\tint n;\n\tstring s;\n\tcin >> n >> s;\n\tint up = 1 << n;\n\t\n\tbool flag = false;\n\tint idx = -1;\n\trep(i, 0, up)\n\t{\n\t\tif (valid(i, s)) {\n\t\t\tflag = true;\n\t\t\tidx = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (flag) {\n\t\tcout << \"Possible\" << endl;\n\t\tint tt = idx;\n\t\t//cout << \"idx:\" << idx << endl;\n\t\tint num0 = 0, num1 = 0;\n\t\tint cnt = 0;\n\t\twhile (tt) {\n\t\t\tif (tt & 1) num1++;\n\t\t\telse num0++;\n\t\t\ttt >>= 1;\n\t\t\tcnt++;\n\t\t}\n\n\n\t\tint aaa = 0;\n\t\tint x = 0;\n\t\trep(i, 0, num0 + num1 + 1)\n\t\t{\n\t\t\taaa++;\n\t\t}\n\t\tx--;\n\t\tint pre = 0;\n\t\ttt = idx;\n\t\tint bcnt = cnt;\n\t\tcnt--;\n\t\twhile (cnt >= 0) {\n\t\t\tif (tt & (1 << cnt)) {\n\t\t\t\tif (pre == 0) {\n\t\t\t\t\taaa+=2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\taaa++;\n\t\t\t\t}\n\t\t\t\tpre = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (pre == 0) {\n\t\t\t\t\taaa++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\taaa+=2;\n\t\t\t\t}\n\t\t\t\tpre = 0;\n\t\t\t}\n\t\t\t//tt >>= 1;\n\t\t\tcnt--;\n\t\t}\n\t\tif (pre == 1) aaa++;\n\t\tcout << aaa - 1 << endl;\n\n\n\n\t\t//cout << (num0 + num1) + num1 * 3 + num0 << endl;\n\t\tx = 0;\n\t\trep(i, 0, num0 + num1 + 1)\n\t\t{\n\t\t\tcout << x << \" \" << 0 << endl;\n\t\t\tx++;\n\t\t}\n\t\tx--;\n\t\tpre = 0;\n\t\ttt = idx;\n\t\tcnt = bcnt;\n\t\tcnt--;\n\t\twhile (cnt>=0) {\n\t\t\tif (tt & (1<<cnt)) {\n\t\t\t\tif (pre == 0) {\n\t\t\t\t\tcout << x << \" \" << 1 << endl;\n\t\t\t\t\tx--;\n\t\t\t\t\tcout << x << \" \" << 1 << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tx--;\n\t\t\t\t\tcout << x << \" \" << 1 << endl;\n\t\t\t\t}\n\t\t\t\tpre = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (pre == 0) {\n\t\t\t\t\tx--;\n\t\t\t\t\tcout << x << \" \" << 0 << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << x << \" \" << 0 << endl;\n\t\t\t\t\tx--;\n\t\t\t\t\tcout << x << \" \" << 0 << endl;\n\t\t\t\t}\n\t\t\t\tpre = 0;\n\t\t\t}\n\t\t\t//tt >>= 1;\n\t\t\tcnt--;\n\t\t}\n\t\tif (pre == 1) cout << 0 << \" \" << 0 << endl;\n\t}\n\telse cout << \"Impossible\" << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing lint128 = __int128_t;\nconst lint mod = 1e9 + 7;\n#define all(x) (x).begin(), (x).end()\n#define bitcount(n) __builtin_popcountl((lint)(n))\n#define fcout cout << fixed << setprecision(15)\n#define highest(x) (63 - __builtin_clzl(x))\ntemplate<class T> inline void YES(T condition){ if(condition) cout << \"YES\" << endl; else cout << \"NO\" << endl; }\ntemplate<class T> inline void Yes(T condition){ if(condition) cout << \"Yes\" << endl; else cout << \"No\" << endl; }\ntemplate<class T> inline void assert_NO(T condition){ if(!condition){ cout << \"NO\" << endl; exit(0); } }\ntemplate<class T> inline void assert_No(T condition){ if(!condition){ cout << \"No\" << endl; exit(0); } }\ntemplate<class T> inline void assert_minus_1(T condition){ if(!condition){ cout << -1 << endl; exit(0); } }\nlint power(lint base, lint exponent, lint module){ if(exponent % 2){ return power(base, exponent - 1, module) * base % module; }else if(exponent){ lint root_ans = power(base, exponent / 2, module); return root_ans * root_ans % module; }else{ return 1; }}\nstruct position{ int y, x; }; position mv[4] = {{0, -1}, {1, 0}, {0, 1}, {-1, 0}}; // double euclidean(position first, position second){ return sqrt((second.x - first.x) * (second.x - first.x) + (second.y - first.y) * (second.y - first.y)); }\ntemplate<class T, class U> string to_string(pair<T, U> x){ return to_string(x.first) + \",\" + to_string(x.second); } string to_string(string x){ return x; }\ntemplate<class itr> void array_output(itr start, itr goal){ string ans; for(auto i = start; i != goal; i++) ans += to_string(*i) + \" \"; if(!ans.empty()) ans.pop_back(); cout << ans << endl; }\ntemplate<class itr> void cins(itr first, itr last){ for(auto i = first; i != last; i++){ cin >> (*i); } }\ntemplate<class T> T gcd_calc(T a, T b){ if(b){ return gcd_calc(b, a % b); }else{ return a; }}\ntemplate<class T> T gcd(T a, T b){ if(a < b) swap(a, b); return gcd_calc(a, b); }\ntemplate<class T> T lcm(T a, T b){ return a / gcd(a, b) * b; }\nstruct combination{ vector<lint> fact, inv; combination(int sz) : fact(sz + 1), inv(sz + 1){ fact[0] = 1; for(int i = 1; i <= sz; i++){ fact[i] = fact[i - 1] * i % mod; } inv[sz] = power(fact[sz], mod - 2, mod); for(int i = sz - 1; i >= 0; i--){ inv[i] = inv[i + 1] * (i + 1) % mod; } } lint C(int p, int q) const{ if(q < 0 || p < q) return 0; return (fact[p] * inv[q] % mod * inv[p - q] % mod); } };\ntemplate<class itr> bool next_sequence(itr first, itr last, int max_bound){ itr now = last; while(now != first){ now--; (*now)++; if((*now) == max_bound){ (*now) = 0; }else{ return true; } } return false; }\ntemplate<class T> bool chmax(T &a, const T &b){ if(a < b){ a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b){ if(b < a){ a = b; return 1; } return 0; }\ninline int at(lint x, int k){ return (x >> k) & 1; }\nrandom_device rnd;\n#define rep(i, n) for(int i = 0; i < n; i++)\n\nint main(){\n    int N;\n    cin >> N;\n    string s;\n    cin >> s;\n    int outside = 0;\n    for(int i = 0; i < (1 << N); i++){\n        int A = s[i] - '0';\n        if(A){\n            outside |= i;\n        }\n    }\n    for(int i = 0; i < (1 << N); i++){\n        int A = s[i] - '0';\n        if(!A && (outside & i) == i){\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n    vector<pair<int, int>> graph;\n    graph.push_back({0, 0});\n    int y = 0;\n    for(int i = 0; i < N; i++){\n        if(at(outside, i)){\n            if(y){\n                graph.push_back({i, 0});\n            }\n            graph.push_back({i + 1, 0});\n            y = 0;\n        }else{\n            if(!y){\n                graph.push_back({i, 1});\n            }\n            graph.push_back({i + 1, 1});\n            y = 1;\n        }\n    }\n    if(y){\n        graph.push_back({N, 0});\n    }\n    for(int i = N - 1; i >= 0; i--){\n        graph.push_back({i, 0});\n    }\n    cout << \"Possible\" << endl;\n    cout << int(graph.size()) - 1 << endl;\n    for(auto i: graph){\n        cout << i.first << \" \" << i.second << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define all(v) (v).begin(),(v).end()\n\n#define PII pair<int,int>\n#define st first\n#define nd second\n#define pb push_back\n#define lint long long int\n#define VI vector<int>\n\n#define debug(x) {cout <<#x <<\" = \" <<x <<endl; }\n#define debug2(x,y) {cerr <<#x <<\" = \" <<x << \", \"<<#y<<\" = \"<< y <<endl; } \n#define debug3(x,y,z) {cerr <<#x <<\" = \" <<x << \", \"<<#y<<\" = \"<< y << \", \" << #z << \" = \" << z <<endl; } \n#define debugv(x) {{cout <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<endl; }}\n#define debugt(t,n) {{cerr <<#t <<\" = \"; FOR(it,0,(n)) cerr <<t[it] <<\", \"; cerr <<endl; }}\n\n#define make( x) int (x); scanf(\"%d\",&(x));\n#define make2( x, y) int (x), (y); scanf(\"%d%d\",&(x),&(y));\n#define make3(x, y, z) int (x), (y), (z); scanf(\"%d%d%d\",&(x),&(y),&(z));\n#define make4(x, y, z, t) int (x), (y), (z), (t); scanf(\"%d%d%d%d\",&(x),&(y),&(z),&(t));\n#define makev(v,n) VI (v); FOR(i,0,(n)) { make(a); (v).pb(a);} \n#define IOS ios_base::sync_with_stdio(0)\n#define HEAP priority_queue\n\n#define read( x) scanf(\"%d\",&(x));\n#define read2( x, y) scanf(\"%d%d\",&(x),&(y));\n#define read3(x, y, z) scanf(\"%d%d%d\",&(x),&(y),&(z));\n#define read4(x, y, z, t) scanf(\"%d%d%d%d\",&(x),&(y),&(z),&(t));\n#define readv(v,n) FOR(i,0,(n)) { make(a); (v).pb(a);}\n#define jeb() fflush(stdout);\n\nusing namespace std;\n\nchar s[300];\n\nint main() {\n\tmake(n);\n\tscanf(\"%s\", s);\n\n\tVI musze;\n\tint full = (1<<n) - 1;\n\tint moge = full;\n\n\tFOR(i,0,1<<n) {\n\t\tint a = s[i] - '0';\n\t\tif (a == 1) {\n\t\t\tmoge &= (full^i); \n\t\t} else {\n\t\t\tmusze.pb(i);\n\t\t}\n\t}\n\tint ok = 1;\n\tFORE(j, musze) {\n\t\tint w = *j;\n\t\tif ((moge & w) == 0) ok = 0;\n\t}\n\tif (ok == 0) {\n\t\tprintf(\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"Possible\\n\");\n\tVI gostki;\n\tset<int> gostki2;\n\tif (moge == 0) {\n\t\tprintf(\"0\\n1 1\\n\");\n\t\treturn 0;\n\t}\n\tFOR(i,0,n) {\n\t\tif (moge & (1<<i)) {\n\t\t\tgostki.pb(i); \n\t\t\tgostki2.insert(i);\n\t\t}\n\t}\n\tvector<PII> droga;\n\tint mini = gostki[0];\n\tint maxi = gostki.back();\n\tFOR(i,mini,maxi+1) {\n\t\tif (gostki2.find(i)!=gostki2.end()) {\n\t\t\tdroga.pb({i,0});\n\t\t\tdroga.pb({i,1});\n\t\t\tdroga.pb({i+1,1});\n\t\t} else {\n\t\t\tdroga.pb({i,0});\n\t\t}\n\t}\n\tFORD(i,maxi+1,mini) {\n\t\tdroga.pb({i,0});\n\t}\n\tprintf(\"%d\\n\", (int) droga.size() - 1);\n\tFOR(i,0,droga.size()) {\n\t\tprintf(\"%d %d\\n\", droga[i].st, droga[i].nd);\n\t}\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<queue>\n#include<iostream>\n#include<fstream>\n#include<string>\n#include<cassert>\n#include<algorithm>\n#include<random>\n#include<map>\n#include<set>\n#include <bitset>\n#include<ctime>\n\nusing namespace std;\n\n//int mod = 998244353;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\ntypedef vector<int>vi;\ntypedef vector<ll>vl;\ntypedef vector<char>vc;\ntypedef vector<string>vs;\ntypedef vector<vector<int>>vii;\ntypedef vector<vector<char>>vvc;\ntypedef vector<vector<ll>>vll;\ntypedef vector< pair<ll, ll>>vpll;\ntypedef vector< pair<ld, ld>>vpld;\ntypedef vector< pair<int, int>>vpi;\ntypedef pair<ld, ld>pld;\n#define mp make_pair\n#define pb push_back\n\nconst int mod = 998244353;\nint add(int a, int b)\n{\n\tint c = a + b;\n\tif (c >= mod)\n\t{\n\t\tc -= mod;\n\t}\n\treturn c;\n}\nint dif(int a, int b)\n{\n\tint c = a - b;\n\tif (c < 0)\n\t{\n\t\tc += mod;\n\t}\n\treturn c;\n}\nint mlt(int a, int b)\n{\nll c = a * 1LL * b;\nreturn c % mod;\n}\nint ibit(int n, int i)\n{\n\treturn ((n >> i) & 1);\n}\nvoid outp(vii &ou)\n{\n\tfor (int i = 0; i < ou.size(); i++)\n\t{\n\t\tfor (int j = 0; j < ou[i].size(); j++)\n\t\t{\n\t\t\tcout << ou[i][j] << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n}\nint bp(int x, int y)\n{\n\tif (y == 0)\n\t{\n\t\treturn 1;\n\t}\n\tint a = 0;\n\tif (!(y % 2))\n\t{\n\t\ta = bp(x, y / 2);\n\t}\n\treturn (y % 2) ? mlt(bp(x, y - 1), x) : mlt(a, a);\n}\nint obr(int x)\n{\n\treturn bp(x, mod - 2);\n}\nconst int maxn = 2000007;\nint fact[2000007], ofact[2000007];\nvoid prec()\n{\n\tfact[0] = 1;\n\tofact[0] = 1;\n\tfor (int i = 1; i < maxn; i++)\n\t{\n\t\tfact[i] = mlt(fact[i - 1], i);\n\t}\n\t//cerr << \"sdsds\" << endl;\n\tofact[maxn - 1] = obr(fact[maxn - 1]);\n\tfor (int i = maxn - 2; i > 0; i--)\n\t{\n\t\tofact[i] = mlt(ofact[i + 1], i + 1);\n\t}\n}\nint c(int a, int b)\n{\n\tif (a == 0)return 1;\n\treturn ((a <= b) && (a >= 0)) ? mlt(fact[b], mlt(ofact[a], ofact[b - a])) : 0;\n}\nll gcd(ll x, ll y)\n{\n\t//cerr << x << y << endl;\n\tif (x == 0)return y;\n\treturn(x > y) ? gcd(y, x) : gcd(y%x, x);\n}\nint obr2(int n)\n{\n\tint x = fact[n - 1];\n\tx = mlt(x, ofact[n]);\n\treturn x;\n}\nvoid crv(int nn, vpi &v)\n{\n\tcerr << nn << endl;\n\tif (nn > 0) {\n\t\tint n = nn;\n\t\tfor (int i = 0; i < n; i++)v.pb({ i + 1, 0 });\n\t\tv.pb({ n,1 });\n\t\tv.pb({ n - 1, 1 });\n\t\tfor (int i = n - 1; i >= 0; i--)v.pb({ i, 0 });\n\t}\n\tif (nn < 0) {\n\t\tint n = -nn;\n\t\tfor (int i = 0; i < n-1; i++)v.pb({ i + 1, 0 });\n\t\tv.pb({ n-1,1 });\n\t\tv.pb({ n , 1 });\n\t\tfor (int i = n; i >= 0; i--)v.pb({ i, 0 });\n\t}\n}\nvoid solve(istream &cin = std::cin, ostream &cout = std::cout)\n{\n\tvii imb(8);\n\timb[0] = { 1 };\n\tfor (int i = 1; i < 8; i++)\n\t{\n\t\tfor (int j = 0; j < imb[i - 1].size(); j++)imb[i].pb(imb[i - 1][j]);\n\t\timb[i].pb(i + 1);\n\t\tfor (int j = imb[i - 1].size(); j >= 0; j--)imb[i].pb((-1)*imb[i - 1][j]);\n\t\timb[i].pb(-i - 1);\n\t}\n\t//cerr << \"here\" << endl;\n\tint n;\n\tcin >> n;\n\tvi good(1 << n);\n\tfor (int i = 0; i < good.size(); i++)\n\t{\n\t\tchar c;\n\t\tcin >> c;\n\t\tgood[i] = c - '0';\n\t}\n\tint val = 0;\n\t//\tcerr << 433 << endl;\n\tfor (int a = 0; a < good.size(); a++)\n\t\tfor (int b = 0; b < good.size(); b++)\n\t\t\tif ((a | b) == b)\n\t\t\t\tif ((!good[a]) && (good[b]))\n\t\t\t\t{\n\t\t\t\t\t//\tcerr << a << ' ' << b << endl;\n\t\t\t\t\tval = 1;\n\t\t\t\t}\n//\tcerr << 5 << ' ' << 7 << ' ' << (5 | 7) << endl;\n\tif (val)cout << \"Impossible\" << endl;\n\telse\n\t{\n\t\tcout << \"Possible\" << endl;\n\t\t//cerr << 1111 << endl;\n\t\tvpi ay = { {0,0} };\n\t\tfor (int m = 0; m < good.size(); m++)\n\t\t{\n\t\t\t//cerr << m << endl;\n\t\t\tif (!good[m])\n\t\t\t{\n\t\t\t\tcerr << m << endl;\n\t\t\t\tvi v;\n\t\t\t\tfor (int i = 0; i < 8; i++)if (ibit(m, i))v.pb(i);\n\t\t\t\tcerr << m << ' ' << v.size() << endl;\n\t\t\t\tfor (int i = 0; i < imb[v.size() - 1].size(); i++)\n\t\t\t\t{\n\t\t\t\t\tcerr << imb[v.size() - 1][i] << endl;\n\t\t\t\t\t//\tcerr << i << endl;\n\t\t\t\t\tif (imb[v.size()][i] > 0)crv(v[imb[v.size() - 1][i] - 1] + 1, ay);\n\t\t\t\t\tif (imb[v.size()][i] < 0)crv(-v[(-imb[v.size() - 1][i]) - 1] - 1, ay);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif (ay.size() < 190000)\n\t\t{\n\t\t\tcout << ay.size() - 1 << endl;\n\t\t\tfor (int i = 0; i < ay.size(); i++)cout << ay[i].first << ' ' << ay[i].second << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << 0 << endl;\n\t\t\tcout << 0 << ' ' << 0 << endl;\n\t\t}\n\t}\n}\nint main()\n{\n\tsolve();\n\tint n;\n\tcin >> n;\n}\n\nint main()\n{\n\tsolve();\n\tint n;\n\tcin >> n;\n}\n\n\t\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int N=1<<10;\nint n;\nchar s[N];\nint p[N];\nvector<pair<int,int> > solve(int S,int now)\n{\n\tcerr<<\"Solve\"<<S<<\" \"<<now<<\"\\n\";\n\tvector<pair<int,int> >res;\n\tfor(int i=now+1;i<=n;i++)\n\t\tif(S&(1<<i))\n\t\t{\n\t\t\tvector<pair<int,int> > t=solve(S,i);\n\t\t\tfor(int j=now-1;j<=i-2;j++)\n\t\t\t\tres.push_back(make_pair(j,1));\n\t\t\tfor(auto [x,y]:t)\n\t\t\t\tres.push_back(make_pair(x,y));\n\t\t\tfor(int j=i-1;j>=now-1;j--)\n\t\t\t\tres.push_back(make_pair(j,1));\n\t\t\tres.push_back(make_pair(now-1,0));\n\t\t\tres.push_back(make_pair(now,0));\n\t\t\tfor(int j=now;j<=i-1;j++)\n\t\t\t\tres.push_back(make_pair(j,1));\n\t\t\tfor(auto [x,y]:t)\n\t\t\t\tres.push_back(make_pair(x,y^1));\n\t\t\tfor(int j=i-2;j>=now;j--)\n\t\t\t\tres.push_back(make_pair(j,1));\n\t\t\tres.push_back(make_pair(now,0));\n\t\t\tres.push_back(make_pair(now-1,0));\n\t\t\treturn res;\n\t\t}\n\tres.push_back(make_pair(now-1,1));\n\tres.push_back(make_pair(now,1)); \n\tres.push_back(make_pair(now,0));\n\tres.push_back(make_pair(now-1,0));\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s);\n\tfor(int i=0;i<(1<<n);i++)\n\t\tp[i]=s[i]-'0';\n\tif(p[0]==0)\n\t{\n\t\tprintf(\"Impossible\");\n\t\treturn 0;\n\t}\n\tfor(int s=0;s<(1<<n);s++)\n\t\tif(p[s]==1)\n\t\t\tfor(int i=s;i;i=(i-1)&s)\n\t\t\t\tif(p[i]==0)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"Impossible\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\tvector<pair<int,int> >ans;\n\tans.push_back(make_pair(0,0));\n\tfor(int s=1;s<(1<<n);s++)\n\t\tif(p[s]==0)\n\t\t{\n\t\t\tbool flag=true;\n\t\t\tfor(int i=(s-1)&s;i;i=(i-1)&s)\n\t\t\t\tif(p[i]==0)\n\t\t\t\t{\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif(!flag) continue;\n\t\t\tvector<pair<int,int> >res;\n\t\t\tvector<pair<int,int> >t;\n\t\t\tint u=0;\n\t\t\tfor(u=0;u<n;u++)\n\t\t\t\tif(s&(1<<u))\n\t\t\t\t{\n\t\t\t\t\tt=solve(s,u+1);\n//\t\t\t\t\tcerr<<\"res\"<<\"\\n\";\n//\t\t\t\t\tfor(auto [x,y]:t)\n//\t\t\t\t\t\tcerr<<x<<\" \"<<y<<\"\\n\";\n//\t\t\t\t\tcerr<<\"EOF\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tu++;\n\t\t\tif(ans.back()!=make_pair(0,0)) res.push_back(make_pair(0,0));\n\t\t\tfor(int i=0;i<=u-2;i++)\n\t\t\t\tres.push_back(make_pair(i,1));\n\t\t\tfor(auto [x,y]:t)\n\t\t\t\tres.push_back(make_pair(x,y));\n\t\t\tfor(int i=u-1;i>=0;i--)\n\t\t\t\tres.push_back(make_pair(i,1));\n\t\t\tres.push_back(make_pair(0,0));\n\t\t\tfor(auto [x,y]:res)\n\t\t\t\tans.push_back(make_pair(x,y));\n\t\t}\n\tprintf(\"Possible\\n\");\n\tint len=ans.size()-1;\n\tprintf(\"%d\\n\",len);\n\tfor(auto [x,y]:ans)\n\t\tprintf(\"%d %d\\n\",x,y);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1007;\n\nvoid nope()\n{\n\tprintf(\"Impossible\\n\");\n\texit(0);\n}\n\nvoid tak()\n{\n\tprintf(\"Possible\\n\");\n}\n\nint n;\nchar wcz[nax];\nint dasie[nax];\n\nvector <pii> wek;\n\nvector <pii> operator + (vector <pii> a, vector <pii> b)\n{\n\tif (a.empty())\n\t\treturn b;\n\tif (b.empty())\n\t\treturn a;\n\ta.pop_back();\n\tfor (pii i : b)\n\t\ta.push_back(i);\n\treturn a;\n}\n\nvector <pii> odw(vector <pii> a)\n{\n\treverse(a.begin(), a.end());\n\treturn a;\n}\n\nvector <pii> daj(int x)\n{\n\tvector <pii> ret;\n\tret.push_back({0, 0});\n\tfor (int i=0; i<=x; i++)\n\t\tret.push_back({i, 1});\n\tret.push_back({x, 0});\n\tret.push_back({x+1, 0});\n\tfor (int i=x+1; i>=0; i--)\n\t\tret.push_back({i, 1});\n\tret.push_back({0, 0});\n\treturn ret;\n}\n\nvector <pii> zdobo(int mas)\n{\n\tint x=__builtin_ctz(mas);\n\tif (__builtin_popcount(mas)==1)\n\t\treturn daj(x);\n\tif (__builtin_popcount(mas)==2)\n\t{\n\t\tint y=__builtin_ctz(mas^(1<<x));\n\t\tauto xx=daj(x);\n\t\tauto yy=daj(y);\n\t\treturn xx+yy+odw(xx)+odw(yy);\n\t}\n\tvector <pii> ret=daj(x);\n\tauto wez=zdobo(mas^(1<<x));\n\treturn wez+ret+odw(wez)+odw(ret);\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", wcz);\n\tfor (int i=0; i<(1<<n); i++)\n\t\tdasie[i]=wcz[i]-'0';\n\tfor (int i=0; i<(1<<n); i++)\n\t{\n\t\tfor (int j=0; j<(1<<n); j++)\n\t\t{\n\t\t\tif ((i&j)==i && dasie[j] && !dasie[i])\n\t\t\t{\n\t\t\t\tnope();\n\t\t\t}\n\t\t}\n\t}\n\ttak();\n\twek={{0, 0}};\n\tfor (int i=0; i<(1<<n); i++)\n\t{\n\t\tif (dasie[i])\n\t\t\tcontinue;\n\t\tauto x=zdobo(i);\n\t\twek=wek+x;\n\t}\n\twek.push_back({0, 0});\n\tprintf(\"%d\\n0 0\\n\", (int)wek.size());\n\tfor (pii i : wek)\n\t\tprintf(\"%d %d\\n\", i.first, i.second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define all(x) x.begin(),x.end()\n#define cmin(a,b) (a>b?a=b:a)\n#define cmax(a,b) (a<b?a=b:a)\n#define mem(a,k) memset(a,k,sizeof(a))\n#define lop(i,s,t) for(int i=s;i<(t);++i)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define fore(i,v) for(int i=g[v],d=es[i].d;i;i=es[i].nxt,d=es[i].d)\nusing namespace std;\n\n#ifdef CURIOUSCAT\n#define Pr(f,...) fprintf(stderr,f,##__VA_ARGS__),fflush(stderr)\n#else\n#define Pr(f,...) ;\n#endif\n\ntypedef long long ll;\n\ntemplate<typename T>\nvoid read(T &x){\n\tx=0; \n\tchar c;\n\tfor(c=getchar();!isdigit(c);c=getchar()); \n\tfor(;isdigit(c);c=getchar())x=x*10+c-'0'; \n}\n\nconst int N=1e6+50;\n\nint P;\nint mul(int a,int b){ return 1ll*a*b%P; }\nint add(int a,int b){ a+=b; return a>=P?a-P:a; }\nvoid upd(int &a,int b) { a=a+b>=P?a+b-P:a+b; }\nint sub(int a,int b){ a-=b; return a<0?a+P:a; }\nint gcd(int a,int b){ return !b?a:gcd(b,a%b); }\n\nint n;\nchar a[1<<9];\nint main(int argc,char *argv[]){\n#ifdef CURIOUSCAT\n#endif\n\tread(n); \n\tlop(s,0,(1<<n)){\n\t\tscanf(\" %c\",&a[s]); a[s]-='0';\n\t}\n\tlop(s,0,(1<<n)){\n\t\tint c0=0,c1=0;\n\t\tlop(i,0,n)if(s>>i&1){\n\t\t\tif(a[1<<i])++c1;else ++c0;\n\t\t}\n\t\tif((c0&&a[s])||(!c0&&!a[s])){\n\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\treturn 0; \n\t\t}\n\t}\n\tint cnt=0;\n\tlop(i,0,n)cnt+=!a[1<<i];\n\tcout<<\"Possible\"<<endl;\n\tif(cnt==0){\n\t\tcout<<0<<endl;\n\t\tcout<<1<<\" \"<<1<<endl;\n\t}else{\n\t\tvector<pair<int,int>> ans;\n\t\tans.pb(mp(0,0));\n\t\tfor(int i=0,p;i<n;i=p){\n\t\t\tif(!a[1<<i]){\n\t\t\t\tfor(p=i;p<n&&!a[1<<p];++p);\n\t\t\t\tans.pb(mp(i,1));\n\t\t\t\tlop(z,0,p-i)ans.pb(mp(i+z+1,1));\n\t\t\t}else{\n\t\t\t\tfor(p=i;p<n&&a[1<<p];++p);\n\t\t\t\tans.pb(mp(i,0)); \n\t\t\t\tlop(z,0,p-i)ans.pb(mp(i+z+1,0));\n\t\t\t}\n\t\t}\n\t\tif(a[1<<(n-1)]){\n\t\t\tdec(i,n,0)ans.pb(mp(i,-1));\n\t\t\tans.pb(mp(0,0)); \n\t\t}else{\n\t\t\tans.pb(mp(n,0));\n\t\t\tdec(i,n,0)ans.pb(mp(i,-1)); \n\t\t\tans.pb(mp(0,0)); \n\t\t}\n\t\tprintf(\"%d\\n\",(int)ans.size()-1);\n\t\tfor(auto x:ans)printf(\"%d %d\\n\",x.fi,x.sc); \n\t}\n\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<queue>\n#include<iostream>\n#include<fstream>\n#include<string>\n#include<cassert>\n#include<algorithm>\n#include<random>\n#include<map>\n#include<set>\n#include <bitset>\n#include<ctime>\n\nusing namespace std;\n\n//int mod = 998244353;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\ntypedef vector<int>vi;\ntypedef vector<ll>vl;\ntypedef vector<char>vc;\ntypedef vector<string>vs;\ntypedef vector<vector<int>>vii;\ntypedef vector<vector<char>>vvc;\ntypedef vector<vector<ll>>vll;\ntypedef vector< pair<ll, ll>>vpll;\ntypedef vector< pair<ld, ld>>vpld;\ntypedef vector< pair<int, int>>vpi;\ntypedef pair<ld, ld>pld;\n#define mp make_pair\n#define pb push_back\n\nconst int mod = 998244353;\nint add(int a, int b)\n{\n\tint c = a + b;\n\tif (c >= mod)\n\t{\n\t\tc -= mod;\n\t}\n\treturn c;\n}\nint dif(int a, int b)\n{\n\tint c = a - b;\n\tif (c < 0)\n\t{\n\t\tc += mod;\n\t}\n\treturn c;\n}\nint mlt(int a, int b)\n{\n\tll c = a * 1LL * b;\n\treturn c % mod;\n}\nint ibit(int n, int i)\n{\n\treturn ((n >> i) & 1);\n}\nvoid outp(vii &ou)\n{\n\tfor (int i = 0; i < ou.size(); i++)\n\t{\n\t\tfor (int j = 0; j < ou[i].size(); j++)\n\t\t{\n\t\t\tcout << ou[i][j] << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n}\nint bp(int x, int y)\n{\n\tif (y == 0)\n\t{\n\t\treturn 1;\n\t}\n\tint a = 0;\n\tif (!(y % 2))\n\t{\n\t\ta = bp(x, y / 2);\n\t}\n\treturn (y % 2) ? mlt(bp(x, y - 1), x) : mlt(a, a);\n}\nint obr(int x)\n{\n\treturn bp(x, mod - 2);\n}\nconst int maxn = 2000007;\nint fact[2000007], ofact[2000007];\nvoid prec()\n{\n\tfact[0] = 1;\n\tofact[0] = 1;\n\tfor (int i = 1; i < maxn; i++)\n\t{\n\t\tfact[i] = mlt(fact[i - 1], i);\n\t}\n\t//cerr << \"sdsds\" << endl;\n\tofact[maxn - 1] = obr(fact[maxn - 1]);\n\tfor (int i = maxn - 2; i > 0; i--)\n\t{\n\t\tofact[i] = mlt(ofact[i + 1], i + 1);\n\t}\n}\nint c(int a, int b)\n{\n\tif (a == 0)return 1;\n\treturn ((a <= b) && (a >= 0)) ? mlt(fact[b], mlt(ofact[a], ofact[b - a])) : 0;\n}\nll gcd(ll x, ll y)\n{\n\t//cerr << x << y << endl;\n\tif (x == 0)return y;\n\treturn(x > y) ? gcd(y, x) : gcd(y%x, x);\n}\nint obr2(int n)\n{\n\tint x = fact[n - 1];\n\tx = mlt(x, ofact[n]);\n\treturn x;\n}\nvoid crv(int nn, vpi &v)\n{\n\t//\tcerr << nn << endl;\n\tif (nn > 0) {\n\t\tint n = nn;\n\t\tfor (int i = 0; i < n; i++)v.pb({ i + 1, 0 });\n\t\tv.pb({ n,1 });\n\t\tv.pb({ n - 1, 1 });\n\t\tfor (int i = n - 1; i >= 0; i--)v.pb({ i, 0 });\n\t}\n\tif (nn < 0) {\n\t\tint n = -nn;\n\t\tfor (int i = 0; i < n - 1; i++)v.pb({ i + 1, 0 });\n\t\tv.pb({ n - 1,1 });\n\t\tv.pb({ n , 1 });\n\t\tfor (int i = n; i >= 0; i--)v.pb({ i, 0 });\n\t}\n}\nvoid solve(istream &cin = std::cin, ostream &cout = std::cout)\n{\n\tvii imb(8);\n\timb[0] = { 1 };\n\tfor (int i = 1; i < 8; i++)\n\t{\n\t\tfor (int j = 0; j < imb[i - 1].size(); j++)imb[i].pb(imb[i - 1][j]);\n\t\timb[i].pb(i + 1);\n\t\tfor (int j = imb[i - 1].size()-1; j >= 0; j--)imb[i].pb((-1)*imb[i - 1][j]);\n\t\timb[i].pb(-i - 1);\n\t}\n\t//cerr << \"here\" << endl;\n\tint n;\n\tcin >> n;\n\tvi good(1 << n);\n\tfor (int i = 0; i < good.size(); i++)\n\t{\n\t//\tchar c;\n\t\t//cin >> c;\n\t//\tgood[i] = c - '0';\n\t\tgood[i] = 0;\n\t}\n\tgood[0] = 1;\n\tint val = 0;\n\t//\tcerr << 433 << endl;\n\tfor (int a = 0; a < good.size(); a++)\n\t\tfor (int b = 0; b < good.size(); b++)\n\t\t\tif ((a | b) == b)\n\t\t\t\tif ((!good[a]) && (good[b]))\n\t\t\t\t{\n\t\t\t\t\t//\tcerr << a << ' ' << b << endl;\n\t\t\t\t\tval = 1;\n\t\t\t\t}\n\t//\tcerr << 5 << ' ' << 7 << ' ' << (5 | 7) << endl;\n\tif (val)cout << \"Impossible\" << endl;\n\telse\n\t{\n\t\tcout << \"Possible\" << endl;\n\t\t//cerr << 1111 << endl;\n\t\tvpi ay = { { 0,0 } };\n\t\tfor (int m = 0; m < good.size(); m++)\n\t\t{\n\t\t\t//cerr << m << endl;\n\t\t\tif (!good[m])\n\t\t\t{\n\t\t\t\t//\tcerr << m << endl;\n\t\t\t\tvi v;\n\t\t\t\tfor (int i = 0; i < 8; i++)\n\t\t\t\t{\n\t\t\t\t\tif (ibit(m, i))\n\t\t\t\t\t{\n\t\t\t\t\t\tv.pb(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t//\tcerr << \"fdfd\"<<' '<<m<<' '<<v.size() << endl;\n\t\t\t\t//\tcerr << m << ' ' << v.size() << endl;\n\t\t\t\tfor (int i = 0; i < imb[v.size() - 1].size(); i++)\n\t\t\t\t{\n\t\t\t\t\t//\tcerr << imb[v.size() - 1][i] << endl;\n\t\t\t\t\t//\tcerr << i << endl;\n\t\t\t\t\t//cerr << i << ' ' << imb[v.size() - 1][i] << endl;\n\t\t\t\t\tif (imb[v.size() - 1][i] > 0)crv(v[imb[v.size() - 1][i] - 1] + 1, ay);\n\t\t\t\t\tif (imb[v.size() - 1][i] < 0)crv(-v[(-imb[v.size() - 1][i]) - 1] - 1, ay);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tif (ay.size() < 190000)\n\t\t{\n\t\t\tcout << ay.size() - 1 << endl;\n\t\t\tfor (int i = 0; i < ay.size(); i++)cout << ay[i].first << ' ' << ay[i].second << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << 0 << endl;\n\t\t\tcout << 0 << ' ' << 0 << endl;\n\t\t}\n\t}\n}\nint main()\n{\n\tsolve();\n\tint n;\n\tcin >> n;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#include<random>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n#define NL <<\"\\n\"\n\nusing namespace std;\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#include \"benri.h\"\n#else\n#define out(args...)\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nconst ll MOD=1e9+7; //998244353\n\nvoid no(){ cout<<\"Impossible\"<<endl; exit(0);}\n\nint main(){\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  cout<<fixed<<setprecision(0);\n\tint n;\n\tcin>>n;\n\tstring s;\n\tcin>>s;\n\tvector<int> imp(1<<n),in(n);\n\trep(i,n)if(s[1<<i]=='0'){\n\t\timp[1<<i]=1;\n\t\tin[i]=1;\n\t}\n\trep(i,1<<n)rep(j,1<<n)if((i|j)==j) imp[j]|=imp[i];\n\trep(i,1<<n)if(imp[i]!=(s[i]=='0')) no();\n\tvector<pii> ps{{0,0}};\n\tint cur=0;\n\trep(i,n){\n\t\tif(in[i]!=cur){\n\t\t\tps.eb(i,in[i]);\n\t\t\tcur=in[i];\n\t\t}\n\t\tps.eb(i+1,cur);\n\t}\n\tif(cur) ps.eb(n,0);\n\trrep(i,n) ps.eb(i,0);\n\tcout<<\"Possible\" NL;\n\tcout<<ps.size()-1 NL;\n\tfor(auto p:ps) cout<<p.X<<\" \"<<p.Y NL;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\n\nstring inverse(string s){\n    string ans = s;\n    reverse(ans.begin(), ans.end());\n    for(int i = 0; i<s.size(); i++){\n        ans[i] = 2*'0' - ans[i];\n    }\n\n    return ans;\n}\n\nstring solve(vector<int> numbers){\n    if(numbers.size() == 1){\n        string ret;\n        for(int i = 0; i<n; i++){\n            if(!(numbers[0] & (1 << i))) ret.push_back('0' + i + 1);\n        }\n        return ret;\n    }\n\n    else if(numbers.size() == 0) return \"\";\n\n    else{\n        vector<int> even, odd;\n        for(int i = 0; i<numbers.size(); i++){\n            if(i % 2) even.push_back(numbers[i]);\n            else odd.push_back(numbers[i]);\n        }\n\n        string t, u;\n        t = solve(even);\n        u = solve(odd);\n        return t + u + inverse(t) + inverse(u);\n    }\n}\n\nstring flips(string s){\n     string ans = s;\n    for(int i = 0; i<s.size(); i++){\n        ans[i] = 2*'0' - ans[i];\n    }\n\n    return ans;\n}\n\nvector<int> maxelems;\n\nint main(){\n    cin >> n;\n\n    char a[(1 << n)];\n    for(int i = 0; i<(1 << n); i++){\n        cin >> a[i];\n    }\n\n    for(int i = 0; i<(1 << n); i++){\n        bool flag = 0;\n        for(int j = 0; j<n; j++){\n            if(a[i] == '1' && a[i & (1 << j)] == '0' || a[0] == '0'){\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n\n            if(a[i] == '0' || (a[i] == '1' && a[i | (1 << j)] == '1' && i < (i | (1 << j))) ) flag = 1;\n        }\n\n        if(!flag){\n            maxelems.push_back(i);\n        }\n    }\n\n    string word = solve(maxelems);\n/*\n    for(auto c: word){\n        cout << '0' - c << \" \";\n    }\n*/\n\n    vector<pair<int, int> > ans;\n    cout << \"Possible\" << endl;\n\n    ans.push_back({0, 0});\n    for(char c: word){\n        if(c < '0'){\n            int offset = '0' - c - 1;\n            for(int i = 1; i<=offset; i++){\n                ans.push_back({i, 0});\n            }\n            ans.push_back({offset, 1});\n            ans.push_back({offset + 1, 1});\n            for(int i = offset + 1; i>=0; i--){\n                ans.push_back({i, 0});\n            }\n        }\n\n        else{\n            int offset = c - '0' - 1;\n            for(int i = 1; i<=offset + 1; i++){\n                ans.push_back({i, 0});\n            }\n            ans.push_back({offset + 1, 1});\n            ans.push_back({offset, 1});\n            for(int i = offset; i>=0; i--){\n                ans.push_back({i, 0});\n            }\n        }\n    }\n\n    cout << ans.size() - 1 << endl;\n    for(auto p: ans){\n        cout << p.first << \" \" << p.second << endl;\n    }\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nint N;\nstring s;\n\nbool bad;\n\nvector <int> goal (int K, string cv)\n{\n    //cout << K << \" \" << cv << \"\\n\";\n    vector <int> ans;\n    if (K == 1)\n    {\n        if (cv[0] == '1')\n        {\n            if (cv[1] == '0')\n            {\n                ans.push_back(0);\n                ans.push_back(1);\n                return ans;\n            }\n            return ans;\n        }\n        if (cv[0] == '0')\n        {\n            if (cv[1] == '1')\n                bad = true;\n            // what?\n            return ans;\n        }\n    }\n\n    int cp = 1 << (K - 1);\n    for (int i = cp; i < 2 * cp; i++)\n    {\n        if (cv[i] > cv[i-cp])\n        {\n            bad = true;\n            return ans;\n        }\n    }\n\n    string rv = cv.substr(0, cp);\n    string lv = cv.substr(cp);\n    bool l0 = true;\n    for (int i = 0; i < cp; i++)\n    {\n        if (lv[i] == '1') l0 = false;\n    }\n\n    vector <int> rans = goal (K - 1, rv);\n\n    if (l0)\n    {\n        // throw the key\n        rans.push_back(K - 1);\n        rans.push_back(K);\n        return rans;\n    }\n    vector <int> lans = goal (K - 1, lv);\n\n    vector <int> god;\n    for (int i : rans)\n        god.push_back(i);\n    god.push_back(K);\n    god.push_back(K-1);\n    reverse (rans.begin(), rans.end());\n    for (int i : rans)\n        god.push_back(i);\n    god.push_back(K-1);\n    god.push_back(K);\n    for (int i : lans)\n        god.push_back(i);\n    return god;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n\n    cin >> N >> s;\n\n    bad = false;\n    vector <int> res = goal (N, s);\n    if (bad || s[0] == 0)\n    {\n        cout << \"Impossible\\n\";\n    }\n    else\n    {\n        cout << \"Possible\\n\";\n        if (!res.size())\n        {\n            cout << \"0\\n\";\n            cout << \"1 1\\n\";\n            return 0;\n        }\n        /*for (int i : res) cout << i;\n        cout << \"\\n\";*/\n        res.push_back(res[0]);\n\n        int ctot = 0;\n        for (int i = 0; i + 1 < res.size(); i++)\n        {\n            ctot += abs (res[i+1] - res[i]) + 1;\n        }\n\n        cout << ctot << \"\\n\";\n        for (int i = 0; i + 1 < res.size(); i++)\n        {\n            int cv = i % 2;\n            int nv = 1 - cv;\n            cout << res[i] << \" \" << cv << \"\\n\";\n            for (int j = res[i]; j < res[i+1]; j++)\n                cout << j << \" \" << nv << \"\\n\";\n            for (int j = res[i]; j > res[i+1]; j--)\n                cout << j << \" \" << nv << \"\\n\";\n        }\n        cout << res[0] << \" \" << 0 << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Egor Kulikov\n */\n\n\n\n\n\n\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// BEGIN CUT HERE\ntemplate <typename T>\nclass Vector : public vector<T> {\n    using parent = vector<T>;\npublic:\n    Vector() : parent() {}\n\n    explicit Vector(size_t __n) : parent(__n) {}\n\n    Vector(size_t __n, const T& __value) : parent(__n, __value) {}\n\n    explicit Vector(const parent& __x) : parent(__x) {}\n\n    Vector(const Vector& __x) : parent(__x) {}\n\n    Vector(Vector&& __x) noexcept : parent(move(__x)) {}\n\n    Vector(initializer_list<T> __l) : parent(__l) {}\n\n    template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>>\n    Vector(_InputIterator __first, _InputIterator __last) : parent(__first, __last) {}\n\n    const T& operator[](size_t ind) const {\n#ifdef LOCAL\n        if (ind >= parent::size()) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return parent::operator[](ind);\n    }\n\n    T& operator[](size_t ind) {\n#ifdef LOCAL\n        if (ind >= parent::size()) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return parent::operator[](ind);\n    }\n\n    Vector<T>& operator=(Vector<T>&& __x) noexcept {\n        parent::operator=(__x);\n        return *this;\n    }\n\n    Vector<T>& operator=(const Vector<T>& __x) {\n        if (&__x == this) {\n            return *this;\n        }\n        parent::operator=(__x);\n        return *this;\n    }\n};\n\ntemplate <>\nclass Vector<bool> : public vector<bool> {\n    using parent = vector<bool>;\npublic:\n    Vector() : parent() {}\n\n    explicit Vector(size_t __n) : parent(__n) {}\n\n    Vector(size_t __n, const bool& __value) : parent(__n, __value) {}\n\n    explicit Vector(const parent& __x) : parent(__x) {}\n\n    Vector(const Vector& __x) : parent(__x) {}\n\n    Vector(Vector&& __x) noexcept : parent(move(__x)) {}\n\n    Vector(initializer_list<bool> __l) : parent(__l) {}\n\n    template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>>\n    Vector(_InputIterator __first, _InputIterator __last) : parent(__first, __last) {}\n\n    parent::const_reference operator[](size_t ind) const {\n#ifdef LOCAL\n        if (ind >= parent::size()) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return parent::operator[](ind);\n    }\n\n    parent::reference operator[](size_t ind) {\n#ifdef LOCAL\n        if (ind >= parent::size()) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return parent::operator[](ind);\n    }\n\n    Vector<bool>& operator=(Vector<bool>&& __x) noexcept {\n        parent::operator=(__x);\n        return *this;\n    }\n\n    Vector<bool>& operator=(const Vector<bool>& __x) {\n        if (&__x == this) {\n            return *this;\n        }\n        parent::operator=(__x);\n        return *this;\n    }\n};\n\n#ifdef LOCAL\n#define vec Vector\n#else\n// END CUT HERE\n#define vec vector\n// BEGIN CUT HERE\n#endif\n// END CUT HERE\n\nusing vi = vec<int>;\n\n\n#define all(v) (v).begin(), (v).end()\n\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\n\nvoid doReplace() {\n}\n\ntemplate <typename T, typename U, typename...Vs>\nvoid doReplace(T& t, const U& u, Vs&& ...vs) {\n    t = u;\n    doReplace(vs...);\n}\n\ntemplate <typename T, typename...Us>\nT minim(T& was, const T& cand, Us&& ...us) {\n    if (was > cand) {\n        was = cand;\n        doReplace(us...);\n    }\n    return was;\n}\n\ntemplate <typename T, typename...Us>\nT maxim(T& was, const T& cand, Us&& ...us) {\n    if (was < cand) {\n        was = cand;\n        doReplace(us...);\n    }\n    return was;\n}\n\n\ntemplate <typename D>\nD dPower(D base, ll exponent) {\n    if (exponent < 0) {\n        return dPower(1 / base, -exponent);\n    }\n    if (exponent == 0) {\n        return 1;\n    }\n    if ((exponent & 1) == 1) {\n        return dPower(base, exponent - 1) * base;\n    } else {\n        D res = dPower(base, exponent >> 1);\n        return res * res;\n    }\n}\n\n\nclass NumberIterator : iterator<forward_iterator_tag, int> {\npublic:\n    int v;\n\n    NumberIterator(int v) : v(v) {}\n\n    operator int&() { return v; }\n\n    int operator*() { return v; }\n};\n\nclass range : pii {\npublic:\n    range(int begin, int end) : pii(begin, max(begin, end)) {}\n\n    range(int n) : pii(0, max(0, n)) {}\n\n    NumberIterator begin() {\n        return first;\n    }\n\n    NumberIterator end() {\n        return second;\n    }\n};\n\n\ntemplate <typename T>\nclass arr {\n    T* b;\n    int n;\n\n    void allocate(int sz) {\n#ifdef LOCAL\n        if (sz < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        n = sz;\n        if (sz > 0) {\n            b = (T*) (::operator new(sz * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr(int n = 0) {\n        allocate(n);\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr(int n, const T& init) {\n        allocate(n);\n        for (int i : range(n)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr(initializer_list<T> l) {\n        allocate(n);\n        if (n > 0) {\n            memcpy(b, l.begin(), n * sizeof(T));\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr(T* b, int n) : arr(b, b + n) {}\n\n    arr(T* b, T* e) : b(b), n(e - b) {}\n\n    int size() const {\n        return n;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    const T* begin() const {\n        return b;\n    }\n\n    T* end() {\n        return b + n;\n    }\n\n    const T* end() const {\n        return b + n;\n    }\n\n    arr<T> clone() const {\n        arr<T> res(n);\n        copy(b, b + n, res.begin());\n        return res;\n    }\n\n    T& operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= n) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[at];\n    }\n\n    const T& operator[](int at) const {\n#ifdef LOCAL\n        if (at < 0 || at >= n) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[at];\n    }\n\n    bool operator==(const arr& other) const {\n        if (n != other.n) {\n            return false;\n        }\n        for (int i : range(n)) {\n            if (b[i] != other.b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    vector<T> view() {\n        return vector<T>(b, b + min(n, 50));\n    }\n};\n\ntypedef arr<int> arri;\n\nvoid decreaseByOne() {}\n\ntemplate <typename T, class...Vs>\nvoid decreaseByOne(arr<T>& array, Vs& ...vs) {\n    int n = array.size();\n    for (int i = 0; i < n; ++i) {\n        array[i]--;\n    }\n    decreaseByOne(vs...);\n}\n\ntemplate <typename T, typename U>\nvoid decreaseByOne(arr<pair<T, U>>& v) {\n    for (auto& p : v) {\n        p.first--;\n        p.second--;\n    }\n}\n\n\ntemplate <typename T>\nclass arr2d {\n    T* b;\n    int d1;\n    int d2;\n    int sz;\n\n    void allocate(int n) {\n#ifdef LOCAL\n        if (n < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        if (n > 0) {\n            b = (T*) (::operator new(n * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr2d(int d1 = 0, int d2 = 0) : d1(d1), d2(d2), sz(d1 * d2) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr2d(int d1, int d2, const T& init) : d1(d1), d2(d2), sz(d1 * d2) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr2d(T* b, int d1, int d2) : b(b), d1(d1), d2(d2), sz(d1 * d2) {}\n\n    int size() const {\n        return sz;\n    }\n\n    int dim1() const {\n        return d1;\n    }\n\n    int dim2() const {\n        return d2;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    T* end() {\n        return b + sz;\n    }\n\n    T& operator()(int i1, int i2) {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * d2 + i2];\n    }\n\n    const T& operator()(int i1, int i2) const {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * d2 + i2];\n    }\n\n    arr<T> operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= d1) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return arr<T>(b + at * d2, d2);\n    }\n\n    vector<vector<T>> view() {\n        vector<vector<T>> res(min(d1, 50));\n        for (int i = 0; i < res.size(); ++i) {\n            res[i] = (*this)[i].view();\n        }\n        return res;\n    }\n\n    arr2d<T> clone() {\n        arr2d<T> res(d1, d2);\n        copy(b, b + sz, res.b);\n        return res;\n    }\n};\n\ntemplate <typename T>\nclass arr3d {\n    T* b;\n    int d1;\n    int d2;\n    int d3;\n    int shift;\n    int sz;\n\n    void allocate(int n) {\n#ifdef LOCAL\n        if (n < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        if (n > 0) {\n            b = (T*) (::operator new(n * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr3d(int d1 = 0, int d2 = 0, int d3 = 0) : d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0 || d3 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T;\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr3d(int d1, int d2, int d3, const T& init) : d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0 || d3 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr3d(T* b, int d1, int d2, int d3) : b(b), d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {}\n\n    int size() const {\n        return sz;\n    }\n\n    int dim1() const {\n        return d1;\n    }\n\n    int dim2() const {\n        return d2;\n    }\n\n    int dim3() const {\n        return d3;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    T* end() {\n        return b + sz;\n    }\n\n    T& operator()(int i1, int i2, int i3) {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * shift + i2 * d3 + i3];\n    }\n\n    const T& operator()(int i1, int i2, int i3) const {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * shift + i2 * d3 + i3];\n    }\n\n    arr2d<T> operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= d1) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return arr2d<T>(b + at * shift, d2, d3);\n    }\n\n    vector<vector<vector<T>>> view() {\n        vector<vector<vector<T>>> res(min(d1, 50));\n        for (int i = 0; i < res.size(); ++i) {\n            res[i] = (*this)[i].view();\n        }\n        return res;\n    }\n};\n\ntemplate <typename T>\nclass arr4d {\n    T* b;\n    int d1;\n    int d2;\n    int d3;\n    int d4;\n    int shift1;\n    int shift2;\n    int sz;\n\n    void allocate(int n) {\n#ifdef LOCAL\n        if (n < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        if (n > 0) {\n            b = (T*) (::operator new(n * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr4d(int d1 = 0, int d2 = 0, int d3 = 0, int d4 = 0) : d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),\n                                                            shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0 || d3 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T;\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr4d(int d1, int d2, int d3, int d4, const T& init) : d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),\n                                                           shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0 || d3 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr4d(T* b, int d1, int d2, int d3, int d4) : b(b), d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),\n                                                  shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {\n    }\n\n    int size() const {\n        return sz;\n    }\n\n    int dim1() const {\n        return d1;\n    }\n\n    int dim2() const {\n        return d2;\n    }\n\n    int dim3() const {\n        return d3;\n    }\n\n    int dim4() const {\n        return d4;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    T* end() {\n        return b + sz;\n    }\n\n    T& operator()(int i1, int i2, int i3, int i4) {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3 || i4 < 0 || i4 >= d4) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * shift1 + i2 * shift2 + i3 * d4 + i4];\n    }\n\n    const T& operator()(int i1, int i2, int i3, int i4) const {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3 || i4 < 0 || i4 >= d4) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * shift1 + i2 * shift2 + i3 * d4 + i4];\n    }\n\n    arr3d<T> operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= d1) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return arr3d<T>(b + at * shift1, d2, d3, d4);\n    }\n\n    vector<vector<vector<vector<T>>>> view() {\n        vector<vector<vector<vector<T>>>> res(min(d1, 50));\n        for (int i = 0; i < res.size(); ++i) {\n            res[i] = (*this)[i].view();\n        }\n        return res;\n    }\n};\n\n\ninline bool isWhitespace(int c) {\n    return isspace(c) || c == EOF;\n}\n\nclass Input {\nprivate:\n    bool exhausted = false;\n    int bufSize = 4096;\n    char* buf = new char[bufSize];\n    int bufRead = 0;\n    int bufAt = 0;\n\n    inline int get() {\n        if (exhausted) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return EOF;\n        }\n        if (bufRead == bufAt) {\n            bufRead = fread(buf, sizeof(char), bufSize, stdin);\n            bufAt = 0;\n        }\n        if (bufRead == bufAt) {\n            exhausted = true;\n            return EOF;\n        }\n        return buf[bufAt++];\n    }\n\n    template <typename T>\n    inline T readInteger() {\n        int c = skipWhitespace();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = get();\n        }\n        T res = 0;\n        do {\n            if (!isdigit(c)) {\n#ifdef LOCAL\n                throw \"Number format error\";\n#endif\n                return sgn * res;\n            }\n            res *= 10;\n            res += c - '0';\n            c = get();\n        } while (!isWhitespace(c));\n        return res * sgn;\n    }\n\n    void initArrays(int) {}\n\n    template <typename T, class...Vs>\n    void initArrays(int n, arr<T>& array, Vs& ...vs) {\n        array = arr<T>(n);\n        initArrays(n, vs...);\n    }\n\n    template <typename T, class...Vs>\n    void initArrays(int n, vec<T>&, Vs& ...vs) {\n        initArrays(n, vs...);\n    }\n\n    void readImpl(int) {}\n\n    template <typename T, class...Vs>\n    void readImpl(int i, arr<T>& arr, Vs& ...vs) {\n        arr[i] = readType<T>();\n        readImpl(i, vs...);\n    }\n\n    template <typename T, class...Vs>\n    void readImpl(int i, vec<T>& arr, Vs& ...vs) {\n        arr.push_back(readType<T>());\n        readImpl(i, vs...);\n    }\n\npublic:\n    inline int skipWhitespace() {\n        int c;\n        while (isWhitespace(c = get()) && c != EOF);\n        if (c == EOF) {\n            exhausted = true;\n        }\n        return c;\n    }\n\n    inline int readInt() {\n        return readInteger<int>();\n    }\n\n    ll readLong() {\n        return readInteger<ll>();\n    }\n\n    string readString() {\n        int c = skipWhitespace();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return \"\";\n        }\n        vec<char> res;\n        do {\n            res.push_back(c);\n        } while (!isWhitespace(c = get()));\n        return string(all(res));\n    }\n\n    arri readIntArray(int size) {\n        return readArray<int>(size);\n    }\n\n    arr<ll> readLongArray(int size) {\n        return readArray<ll>(size);\n    }\n\n    arr<double> readDoubleArray(int size) {\n        return readArray<double>(size);\n    }\n\n    arr<string> readStringArray(int size) {\n        return readArray<string>(size);\n    }\n\n    arr<char> readCharArray(int size) {\n        return readArray<char>(size);\n    }\n\n    template <typename T>\n    T readType() {\n        throw \"Operation not supported\";\n    }\n\n    template <typename U, typename V>\n    pair<U, V> readType() {\n        U first = readType<U>();\n        V second = readType<V>();\n        return make_pair(first, second);\n    }\n\n    template <typename T>\n    arr<T> readArray(int n) {\n        arr<T> res(n, T());\n        for (int i = 0; i < n; i++) {\n            res[i] = readType<T>();\n        }\n        return res;\n    }\n\n\n    template <class...Vs>\n    void readArrays(int n, Vs& ...vs) {\n        initArrays(n, vs...);\n        for (int i = 0; i < n; i++) {\n            readImpl(i, vs...);\n        }\n    }\n\n    template <typename U, typename V>\n    arr<pair<U, V>> readArray(int n) {\n        arr<pair<U, V>> res(n);\n        for (int i = 0; i < n; i++) {\n            res[i] = readType<U, V>();\n        }\n        return res;\n    }\n\n    template <typename T>\n    arr2d<T> readTable(int rows, int cols) {\n        arr2d<T> result(rows, cols);\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < cols; ++j) {\n                result(i, j) = readType<T>();\n            }\n        }\n        return result;\n    }\n\n    arr2d<int> readIntTable(int rows, int cols) {\n        return readTable<int>(rows, cols);\n    }\n\n    arr2d<char> readCharTable(int rows, int cols) {\n        return readTable<char>(rows, cols);\n    }\n\n    string readLine() {\n        int c = get();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return \"\";\n        }\n        vec<char> res;\n        do {\n            res.push_back(c);\n            c = get();\n        } while (c != '\\n' && c != '\\r' && c != EOF);\n        return string(all(res));\n    }\n\n    double readDouble() {\n        int c = skipWhitespace();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = get();\n        }\n        double res = 0;\n        do {\n            if (tolower(c) == 'e') {\n                return sgn * res * dPower(double(10), readInt());\n            }\n            if (!isdigit(c)) {\n#ifdef LOCAL\n                throw \"Number format error\";\n#endif\n                return sgn * res;\n            }\n            res *= 10;\n            res += c - '0';\n            c = get();\n        } while (!isWhitespace(c) && c != '.');\n        if (c == '.') {\n            double add = 0;\n            int length = 0;\n            c = get();\n            do {\n                if (tolower(c) == 'e') {\n                    return sgn * (res + add * dPower(double(10), -length)) * dPower(double(10), readInt());\n                }\n                if (!isdigit(c)) {\n#ifdef LOCAL\n                    throw \"Number format error\";\n#endif\n                    res += add * dPower(10, -length);\n                    return res * sgn;\n                }\n                add *= 10;\n                add += c - '0';\n                length++;\n                c = get();\n            } while (!isWhitespace(c));\n            res += add * dPower(double(10), -length);\n        }\n        return res * sgn;\n    }\n\n    char readChar() {\n        int c = skipWhitespace();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return 0;\n        }\n        return c;\n    }\n\n    bool isExhausted() { return exhausted; }\n\n    void setBufSize(int newBufSize) {\n        if (newBufSize > bufSize) {\n            char* newBuf = new char[newBufSize];\n            memcpy(newBuf, buf, bufSize);\n            buf = newBuf;\n        }\n        bufSize = newBufSize;\n    }\n};\n\ntemplate <>\ndouble Input::readType() {\n    return readDouble();\n}\n\ntemplate <>\nint Input::readType() {\n    return readInt();\n}\n\ntemplate <>\nll Input::readType() {\n    return readLong();\n}\n\ntemplate <>\nchar Input::readType() {\n    return readChar();\n}\n\ntemplate <>\nstring Input::readType() {\n    return readString();\n}\n\nInput in;\n\n\nclass Output {\nprivate:\n    ostream& out = cout;\n\n    template <typename T>\n    void printSingle(const T& value) {\n        out << value;\n    }\n\n    template <typename T>\n    void printSingle(const vec<T>& array) {\n        size_t n = array.size();\n        for (int i = 0; i < n; ++i) {\n            out << array[i];\n            if (i + 1 != n) {\n                out << ' ';\n            }\n        }\n    }\n\n    template <typename T>\n    void printSingle(const arr<T>& array) {\n        size_t n = array.size();\n        for (int i = 0; i < n; ++i) {\n            out << array[i];\n            if (i + 1 != n) {\n                out << ' ';\n            }\n        }\n    }\n\n    template <typename T>\n    void printSingle(const arr2d<T>& array) {\n        size_t n = array.dim1();\n        size_t m = array.dim2();\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                out << array(i, j);\n                if (j + 1 != m) {\n                    out << ' ';\n                }\n            }\n            if (i + 1 != n) {\n                out << '\\n';\n            }\n        }\n    }\n\n    template <typename T, typename U>\n    void printSingle(const pair<T, U>& value) {\n        out << value.first << ' ' << value.second;\n    }\n\npublic:\n    Output() {//ostream& out) : out(out) {\n        out << fixed << setprecision(20);\n    }\n\n    void print() {}\n\n    template <typename T, typename...Targs>\n    void print(const T& first, const Targs... args) {\n        printSingle(first);\n        if (sizeof...(args) != 0) {\n            out << ' ';\n            print(args...);\n        }\n    }\n\n    template <typename...Targs>\n    void printLine(const Targs... args) {\n        print(args...);\n        out << '\\n';\n    }\n\n    void flush() {\n        out.flush();\n    }\n};\n\nOutput out;\n\n\nclass ReverseNumberIterator : public NumberIterator {\npublic:\n    ReverseNumberIterator(int v) : NumberIterator(v) {}\n\n    ReverseNumberIterator& operator++() {\n        --v;\n        return *this;\n    }\n};\n\nclass RevRange : pii {\npublic:\n    RevRange(int begin, int end) : pii(begin - 1, min(begin, end) - 1) {}\n\n    RevRange(int n) : pii(n - 1, min(n, 0) - 1) {}\n\n    ReverseNumberIterator begin() {\n        return first;\n    }\n\n    ReverseNumberIterator end() {\n        return second;\n    }\n};\n\n\ntemplate <typename T>\ninline void unique(vec<T>& v) {\n    v.resize(unique(all(v)) - v.begin());\n}\n\narri createOrder(int n) {\n    arri order(n);\n    for (int i = 0; i < n; i++) {\n        order[i] = i;\n    }\n    return order;\n}\n\narri inverse(const arri& p) {\n    arri res(p.size());\n    for (int i : range(p.size())) {\n        res[p[i]] = i;\n    }\n    return res;\n}\n\ntemplate <typename T, typename Iterator>\ninline void addAll(vec<T>& v, Iterator begin, Iterator end) {\n    v.insert(v.end(), begin, end);\n}\n\ntemplate <class Collection, typename Iterator>\ninline void addAll(Collection& v, Iterator begin, Iterator end) {\n    v.insert(begin, end);\n}\n\ntemplate <typename Iterator>\narri getQty(Iterator begin, Iterator end, int length) {\n    arri res(length, 0);\n    for (Iterator it = begin; it != end; it++) {\n        res[*it]++;\n    }\n    return res;\n}\n\ntemplate <typename Iterator>\narri getQty(Iterator begin, Iterator end) {\n    return getQty(begin, end, *max_element(begin, end) + 1);\n}\n\ntemplate <class Collection>\nvoid collect(Collection&) {}\n\ntemplate <class Collection, class Other, class ...Vs>\nvoid collect(Collection& all, Other& a, Vs& ...vs) {\n    addAll(all, all(a));\n    collect(all, vs...);\n}\n\nvoid replace(const vi&) {}\n\ntemplate <class ...Vs>\nvoid replace(const vi& all, vi& a, Vs& ...vs) {\n    for (int& i : a) {\n        i = lower_bound(all(all), i) - all.begin();\n    }\n    replace(all, vs...);\n}\n\ntemplate <class ...Vs>\nvoid replace(const vi& all, arri& a, Vs& ...vs) {\n    for (int& i : a) {\n        i = lower_bound(all(all), i) - all.begin();\n    }\n    replace(all, vs...);\n}\n\ntemplate <class ...Vs>\nvi compress(Vs& ...vs) {\n    vi vals;\n    collect(vals, vs...);\n    sort(all(vals));\n    unique(vals);\n    replace(vals, vs...);\n    return vals;\n}\n\n\nclass DSU {\n    mutable arri id;\n    arri sz;\n    int count;\n\npublic:\n    DSU(int n) {\n        id = createOrder(n);\n        sz = arri(n, 1);\n        count = n;\n    }\n\n    int get(int i) const {\n        if (id[i] == i) {\n            return i;\n        }\n        return id[i] = get(id[i]);\n    }\n\n    int operator[](int i) const { return get(i); }\n\n    int size(int i) const { return sz[get(i)]; }\n\n    int setCount() const { return count; }\n\n    bool join(int a, int b) {\n        a = get(a);\n        b = get(b);\n        if (a == b) {\n            return false;\n        }\n        sz[a] += sz[b];\n        sz[b] = 0;\n        id[b] = a;\n        count--;\n        return true;\n    }\n\n    void reset() {\n        count = sz.size();\n        for (int i : range(count)) {\n            id[i] = i;\n            sz[i] = 1;\n        }\n    }\n};\n\n\ntemplate <typename W, typename C>\nclass WeightedFlowEdge {\nprivate:\n    WeightedFlowEdge<W, C>* reverseEdge;\n\npublic:\n    const int from;\n    const int to;\n    W weight;\n    C capacity;\n    int id;\n\n    WeightedFlowEdge(int from, int to, W weight, C capacity) : from(from), to(to), weight(weight), capacity(capacity) {\n        reverseEdge = new WeightedFlowEdge(this);\n    }\n\n    WeightedFlowEdge<W, C>* transposed() { return nullptr; }\n\n    WeightedFlowEdge<W, C>* reverse() { return reverseEdge; }\n\n    void push(C flow) {\n        capacity -= flow;\n        reverseEdge->capacity += flow;\n    }\n\n    C flow() const {\n        return reverseEdge->capacity;\n    }\n\nprivate:\n    WeightedFlowEdge(WeightedFlowEdge<W, C>* reverse) : from(reverse->to), to(reverse->from), weight(-reverse->weight),\n                                                        capacity(0) {\n        reverseEdge = reverse;\n    }\n};\n\ntemplate <typename C>\nclass FlowEdge {\nprivate:\n    FlowEdge<C>* reverseEdge;\n\npublic:\n    const int from;\n    const int to;\n    C capacity;\n    int id;\n\n    FlowEdge(int from, int to, C capacity) : from(from), to(to), capacity(capacity) {\n        reverseEdge = new FlowEdge(this);\n    }\n\n    FlowEdge<C>* transposed() { return nullptr; }\n\n    FlowEdge<C>* reverse() { return reverseEdge; }\n\n    void push(C flow) {\n        capacity -= flow;\n        reverseEdge->capacity += flow;\n    }\n\n    C flow() const {\n        return reverseEdge->capacity;\n    }\n\nprivate:\n    FlowEdge(FlowEdge<C>* reverse) : from(reverse->to), to(reverse->from), capacity(0) {\n        reverseEdge = reverse;\n    }\n};\n\ntemplate <typename W>\nclass WeightedEdge {\npublic:\n    const int from;\n    const int to;\n    W weight;\n    int id;\n\n    WeightedEdge(int from, int to, W weight) : from(from), to(to), weight(weight) {\n    }\n\n    WeightedEdge<W>* transposed() { return nullptr; }\n\n    WeightedEdge<W>* reverse() { return nullptr; }\n};\n\ntemplate <typename W>\nclass BiWeightedEdge {\nprivate:\n    BiWeightedEdge<W>* transposedEdge;\n\npublic:\n    const int from;\n    const int to;\n    W weight;\n    int id;\n\n    BiWeightedEdge(int from, int to, W weight) : from(from), to(to), weight(weight) {\n        transposedEdge = new BiWeightedEdge(this);\n    }\n\n    BiWeightedEdge<W>* transposed() { return transposedEdge; }\n\n    BiWeightedEdge<W>* reverse() { return nullptr; }\n\nprivate:\n    BiWeightedEdge(BiWeightedEdge<W>* transposed) : from(transposed->to), to(transposed->from),\n                                                    weight(transposed->weight) {\n        transposedEdge = transposed;\n    }\n};\n\nclass BaseEdge {\npublic:\n    const int from;\n    const int to;\n    int id;\n\n    BaseEdge(int from, int to) : from(from), to(to) {\n    }\n\n    BaseEdge* transposed() { return nullptr; }\n\n    BaseEdge* reverse() { return nullptr; }\n};\n\nclass BiEdge {\nprivate:\n    BiEdge* transposedEdge;\n\npublic:\n    const int from;\n    const int to;\n    int id;\n\n    BiEdge(int from, int to) : from(from), to(to) {\n        transposedEdge = new BiEdge(this);\n    }\n\n    BiEdge* transposed() { return transposedEdge; }\n\n    BiEdge* reverse() { return nullptr; }\n\nprivate:\n    BiEdge(BiEdge* transposed) : from(transposed->to), to(transposed->from) {\n        transposedEdge = transposed;\n    }\n};\n\ntemplate <class Edge>\nclass Graph {\npublic:\n    int vertexCount;\n    int edgeCount = 0;\nprivate:\n    vec<vec<Edge*>> edges;\n\npublic:\n    Graph(int vertexCount) : vertexCount(vertexCount), edges(vertexCount, vec<Edge*>()) {}\n\n    void addEdge(Edge* edge) {\n#ifdef LOCAL\n        if (edge->from < 0 || edge->to < 0 || edge->from >= vertexCount || edge->to >= vertexCount) {\n            throw \"Out of bounds\";\n        }\n#endif\n        edge->id = edgeCount;\n        edges[edge->from].push_back(edge);\n        Edge* reverse = edge->reverse();\n        if (reverse != nullptr) {\n            reverse->id = edgeCount;\n            edges[reverse->from].push_back(reverse);\n        }\n        Edge* transposed = edge->transposed();\n        if (transposed != nullptr) {\n            edges[transposed->from].push_back(transposed);\n            transposed->id = edgeCount;\n            Edge* transRev = transposed->reverse();\n            if (transRev != nullptr) {\n                edges[transRev->from].push_back(transRev);\n                transRev->id = edgeCount;\n            }\n        }\n        edgeCount++;\n    }\n\n    template <typename...Ts>\n    void addEdge(Ts...args) {\n        addEdge(new Edge(args...));\n    }\n\n    vec<Edge*>& operator[](int at) {\n        return edges[at];\n    }\n\n    void addVertices(int count) {\n        vertexCount += count;\n        edges.resize(vertexCount);\n    }\n};\n\n\nclass ETopology {\npublic:\n    void solve() {\n        int n = in.readInt();\n        auto a = in.readCharArray(1 << n);\n\n        auto shift = [&](int mask, int dir) -> int {\n            if (dir >= 0) {\n                return mask << dir;\n            }\n            return mask >> (-dir);\n        };\n        auto okay = [&](int up, int down, int vert) -> bool {\n            for (int i : range(1 << n)) {\n                int left = -n;\n                int last = -n - 1;\n                for (int j : range(n + 1)) {\n                    if (vert >> j & 1) {\n                        maxim(left, last - j + 1);\n                    }\n                    if (i >> j & 1) {\n                        last = j;\n                    }\n                }\n                int right = n;\n                last = 2 * n;\n                for (int j : RevRange(n + 1)) {\n                    if (i >> j & 1) {\n                        last = j;\n                    }\n                    if (vert >> j & 1) {\n                        minim(right, last - j);\n                    }\n                }\n                bool can = false;\n                for (int j : range(left, right + 1)) {\n                    if (!(shift(up, j) & i) || !(shift(down, j) & i)) {\n                        can = true;\n                        break;\n                    }\n                }\n                if (can ^ (a[i] == '1')) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        DSU dsu(3 * n + 1);\n        for (int i : range(1 << n)) {\n            for (int j : range(i + 1)) {\n                for (int k : range(1 << (n + 1))) {\n                    dsu.reset();\n                    for (int l : range(n)) {\n                        if ((i >> l & 1)) {\n                            if ((k >> l & 1)) {\n                                dsu.join(l, 2 * n + l);\n                            }\n                            if ((k >> (l + 1) & 1)) {\n                                dsu.join(l, 2 * n + l + 1);\n                            }\n                        }\n                        if (j >> l & 1) {\n                            if ((k >> l & 1)) {\n                                dsu.join(n + l, 2 * n + l);\n                            }\n                            if ((k >> (l + 1) & 1)) {\n                                dsu.join(n + l, 2 * n + l + 1);\n                            }\n                        }\n                    }\n                    int id = -1;\n                    bool good = true;\n                    for (int l : range(n + 1)) {\n                        if ((i >> l & 1)) {\n                            if (id == -1) {\n                                id = dsu[l];\n                            } else if (id != dsu[l]) {\n                                good = false;\n                                break;\n                            }\n                        }\n                        if ((j >> l & 1)) {\n                            if (id == -1) {\n                                id = dsu[l + n];\n                            } else if (id != dsu[l + n]) {\n                                good = false;\n                                break;\n                            }\n                        }\n                        if ((j >> l & 1)) {\n                            if (id == -1) {\n                                id = dsu[l + n];\n                            } else if (id != dsu[l + n]) {\n                                good = false;\n                                break;\n                            }\n                        }\n                        if ((k >> l & 1)) {\n                            if (id == -1) {\n                                id = dsu[l + 2 * n];\n                            } else if (id != dsu[l + 2 * n]) {\n                                good = false;\n                                break;\n                            }\n                        }\n                    }\n                    if (good && okay(i, j, k)) {\n                        out.printLine(\"Possible\");\n                        if (!i && !j && !k) {\n                            out.printLine(0);\n                            out.printLine(0, 0);\n                            return;\n                        }\n                        dsu.reset();\n                        Graph<BiEdge> graph(2 * n + 2);\n                        for (int l : range(n + 1)) {\n                            if ((i >> l & 1) && dsu.join(l, l + 1)) {\n                                graph.addEdge(l, l + 1);\n                            }\n                            if ((j >> l & 1) && dsu.join(n + 1 + l, n + 1 + l + 1)) {\n                                graph.addEdge(n + 1 + l, n + 1 + l + 1);\n                            }\n                            if ((k >> l & 1) && dsu.join(l, n + 1 + l)) {\n                                graph.addEdge(l, n + 1 + l);\n                            }\n                        }\n                        vec<pii> ans;\n                        for (int l : range(2 * n + 2)) {\n                            if (dsu.size(l) > 1) {\n                                function<void(int, int)> dfs = [&](int vert, int last) {\n                                    ans.emplace_back(vert % (n + 1), vert / (n + 1));\n                                    for (auto* e : graph[vert]) {\n                                        int next = e->to;\n                                        if (next == last) {\n                                            continue;\n                                        }\n                                        dfs(next, vert);\n                                        ans.emplace_back(vert % (n + 1), vert / (n + 1));\n                                    }\n                                };\n                                dfs(l, -1);\n                                break;\n                            }\n                        }\n                        out.printLine(ans.size() - 1);\n                        for (const auto& p : ans) {\n                            out.printLine(p);\n                        }\n                        return;\n                    }\n                }\n            }\n        }\n        out.printLine(\"Impossble\");\n    }\n};\n\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ETopology solver;\n\n\n    solver.solve();\n    fflush(stdout);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#pragma GCC optimize(\"Ofast\")\n\n#define fi first\n#define se second\n\nconst int N = 9;\n\nusing namespace std;\n\nint n;\nint b[N];\nint a[1 << N];\nint c[1 << N];\nvector < pair < int, int > > res;\n\nvoid run(int x)\n{\n        res.push_back({x, 1});\n        res.push_back({x, 0});\n        if(x == n) return;\n\n        if(b[x] == 0){\n                res.push_back({x + 1, 0});\n                run(x + 1);\n                res.push_back({x, 0});\n        } else if(b[x] == 1){\n                res.push_back({x, 1});\n                res.push_back({x + 1, 1});\n                res.push_back({x + 1, 0});\n                run(x + 1);\n                res.push_back({x + 1, 1});\n                res.push_back({x, 1});\n                res.push_back({x, 0});\n        } else{\n                res.push_back({x + 1, 0});\n                res.push_back({x + 1, 1});\n                res.push_back({x, 1});\n                res.push_back({x, 0});\n                res.push_back({x + 1, 0});\n                run(x + 1);\n                res.push_back({x, 0});\n        }\n}\n\nvoid solve(int mask)\n{\n        for(int i = 0; i < n; i++){\n                if(a[1 << i] == 0) b[i] = 2;\n                else b[i] = (mask >> i) & 1;\n        }\n\n        for(int i = 0; i < (1 << n); i++){\n                c[i] = 1;\n                int c0 = 0, c1 = 0;\n                for(int j = 0; j < n; j++){\n                        if(i & (1 << j)){\n                                if(b[j] == 2) c[i] = 0;\n                                else if(b[j] == 1) c0 = 1;\n                                else c1 = 1;\n                        }\n                }\n                if(c0 && c1) c[i] = 0;\n                if(c[i] != a[i]) return;\n        }\n        res.push_back({0, 0});\n        run(0);\n\n        cout << \"Possible\" << \"\\n\";\n        cout << res.size() - 1 << \"\\n\";\n        for(auto p: res) cout << p.fi << \" \" << p.se << \"\\n\";\n\n        exit(0);\n}\n\nint main()\n{\n        //freopen(\"input.txt\", \"r\", stdin);\n        //freopen(\"output.txt\", \"w\", stdout);\n\n        ios_base::sync_with_stdio(0);\n\n        cin >> n;\n        for(int i = 0; i < (1 << n); i++){\n                char c;\n                cin >> c;\n                a[i] = c - '0';\n        }\n\n        for(int i = 0; i < (1 << n); i++) solve(i);\n\n        cout << \"Impossible\" << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n/**\n * File    : E.cpp\n * Author  : Kazune Takahashi\n * Created : 4/23/2020, 7:08:47 PM\n * Powered by Visual Studio Code\n */\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n// ----- boost -----\n#include <boost/rational.hpp>\n#include <boost/multiprecision/cpp_int.hpp>\n// ----- using directives and manipulations -----\nusing namespace std;\nusing boost::rational;\nusing boost::multiprecision::cpp_int;\nusing ll = long long;\ntemplate <typename T>\nusing max_heap = priority_queue<T>;\ntemplate <typename T>\nusing min_heap = priority_queue<T, vector<T>, greater<T>>;\n// ----- constexpr for Mint and Combination -----\nconstexpr ll MOD{1000000007LL};\n// constexpr ll MOD{998244353LL}; // be careful\nconstexpr ll MAX_SIZE{3000010LL};\n// constexpr ll MAX_SIZE{30000010LL}; // if 10^7 is needed\n// ----- ch_max and ch_min -----\ntemplate <typename T>\nvoid ch_max(T &left, T right)\n{\n  if (left < right)\n  {\n    left = right;\n  }\n}\ntemplate <typename T>\nvoid ch_min(T &left, T right)\n{\n  if (left > right)\n  {\n    left = right;\n  }\n}\n// ----- Mint -----\ntemplate <ll MOD = MOD>\nclass Mint\n{\npublic:\n  ll x;\n  Mint() : x{0LL} {}\n  Mint(ll x) : x{(x % MOD + MOD) % MOD} {}\n  Mint operator-() const { return x ? MOD - x : 0; }\n  Mint &operator+=(const Mint &a)\n  {\n    if ((x += a.x) >= MOD)\n    {\n      x -= MOD;\n    }\n    return *this;\n  }\n  Mint &operator-=(const Mint &a) { return *this += -a; }\n  Mint &operator++() { return *this += 1; }\n  Mint &operator++(int)\n  {\n    Mint tmp{*this};\n    ++*this;\n    return tmp;\n  }\n  Mint &operator--() { return *this -= 1; }\n  Mint &operator--(int)\n  {\n    Mint tmp{*this};\n    --*this;\n    return tmp;\n  }\n  Mint &operator*=(const Mint &a)\n  {\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  Mint &operator/=(const Mint &a)\n  {\n    Mint b{a};\n    return *this *= b.power(MOD - 2);\n  }\n  Mint operator+(const Mint &a) const { return Mint(*this) += a; }\n  Mint operator-(const Mint &a) const { return Mint(*this) -= a; }\n  Mint operator*(const Mint &a) const { return Mint(*this) *= a; }\n  Mint operator/(const Mint &a) const { return Mint(*this) /= a; }\n  bool operator<(const Mint &a) const { return x < a.x; }\n  bool operator<=(const Mint &a) const { return x <= a.x; }\n  bool operator>(const Mint &a) const { return x > a.x; }\n  bool operator>=(const Mint &a) const { return x >= a.x; }\n  bool operator==(const Mint &a) const { return x == a.x; }\n  bool operator!=(const Mint &a) const { return !(*this == a); }\n  const Mint power(ll N)\n  {\n    if (N == 0)\n    {\n      return 1;\n    }\n    else if (N % 2 == 1)\n    {\n      return *this * power(N - 1);\n    }\n    else\n    {\n      Mint half = power(N / 2);\n      return half * half;\n    }\n  }\n};\ntemplate <ll MOD>\nMint<MOD> operator+(ll lhs, const Mint<MOD> &rhs)\n{\n  return rhs + lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator-(ll lhs, const Mint<MOD> &rhs)\n{\n  return -rhs + lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator*(ll lhs, const Mint<MOD> &rhs)\n{\n  return rhs * lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator/(ll lhs, const Mint<MOD> &rhs)\n{\n  return Mint<MOD>{lhs} / rhs;\n}\ntemplate <ll MOD>\nistream &operator>>(istream &stream, Mint<MOD> &a)\n{\n  return stream >> a.x;\n}\ntemplate <ll MOD>\nostream &operator<<(ostream &stream, const Mint<MOD> &a)\n{\n  return stream << a.x;\n}\n// ----- Combination -----\ntemplate <ll MOD = MOD, ll MAX_SIZE = MAX_SIZE>\nclass Combination\n{\npublic:\n  vector<Mint<MOD>> inv, fact, factinv;\n  Combination() : inv(MAX_SIZE), fact(MAX_SIZE), factinv(MAX_SIZE)\n  {\n    inv[1] = 1;\n    for (auto i = 2LL; i < MAX_SIZE; i++)\n    {\n      inv[i] = (-inv[MOD % i]) * (MOD / i);\n    }\n    fact[0] = factinv[0] = 1;\n    for (auto i = 1LL; i < MAX_SIZE; i++)\n    {\n      fact[i] = Mint<MOD>(i) * fact[i - 1];\n      factinv[i] = inv[i] * factinv[i - 1];\n    }\n  }\n  Mint<MOD> operator()(int n, int k)\n  {\n    if (n >= 0 && k >= 0 && n - k >= 0)\n    {\n      return fact[n] * factinv[k] * factinv[n - k];\n    }\n    return 0;\n  }\n  Mint<MOD> catalan(int x, int y)\n  {\n    return (*this)(x + y, y) - (*this)(x + y, y - 1);\n  }\n};\n// ----- for C++14 -----\nusing mint = Mint<MOD>;\nusing combination = Combination<MOD, MAX_SIZE>;\ntemplate <typename T>\nT gcd(T x, T y) { return y ? gcd(y, x % y) : x; }\ntemplate <typename T>\nT lcm(T x, T y) { return x / gcd(x, y) * y; }\n// ----- for C++17 -----\ntemplate <typename T>\nint popcount(T x) // C++20\n{\n  int ans{0};\n  while (x != 0)\n  {\n    ans += x & 1;\n    x >>= 1;\n  }\n  return ans;\n}\n// ----- frequently used constexpr -----\n// constexpr double epsilon{1e-10};\n// constexpr ll infty{1000000000000000LL}; // or\n// constexpr int infty{1'000'000'010};\n// constexpr int dx[4] = {1, 0, -1, 0};\n// constexpr int dy[4] = {0, 1, 0, -1};\n// ----- Yes() and No() -----\nvoid Yes()\n{\n  cout << \"Yes\" << endl;\n  exit(0);\n}\nvoid No()\n{\n  cout << \"No\" << endl;\n  exit(0);\n}\n\n// ----- Point -----\n\nusing Point = tuple<int, int>;\n\nostream &operator<<(ostream &os, Point const &pt)\n{\n  return os << get<0>(pt) << \" \" << get<1>(pt);\n}\n\n// ----- Cycle -----\n\nclass Cycle\n{\n  int num;\n  bool pos;\n\npublic:\n  Cycle(int num, bool pos) : num{num}, pos{pos} {}\n\n  vector<Point> path() const\n  {\n    vector<Point> ans;\n    for (auto i = 0; i <= num; ++i)\n    {\n      ans.push_back(Point(i, 0));\n    }\n    if (pos)\n    {\n      ans.push_back(Point(num + 1, 0));\n      ans.push_back(Point(num + 1, 1));\n      ans.push_back(Point(num, 1));\n    }\n    else\n    {\n      ans.push_back(Point(num, 1));\n      ans.push_back(Point(num + 1, 1));\n      ans.push_back(Point(num + 1, 0));\n    }\n    for (auto i = num; i >= 1; --i)\n    {\n      ans.push_back(Point(i, 0));\n    }\n    return ans;\n  }\n\n  Cycle inv() const\n  {\n    return Cycle(num, !pos);\n  }\n};\n\nclass Chain\n{\n  vector<Cycle> V;\n\npublic:\n  Chain() {}\n  Chain(Cycle c) : V{c} {}\n  Chain(vector<Cycle> V) : V(V) {}\n\n  Chain(int mask)\n  {\n    int cnt{0};\n    while ((mask >> cnt) != 0)\n    {\n      if ((mask >> cnt) & 1)\n      {\n        merge(cnt);\n      }\n      ++cnt;\n    }\n  }\n\n  vector<Point> path() const\n  {\n    vector<Point> ans;\n    for (auto const &e : V)\n    {\n      auto tmp{e.path()};\n      copy(tmp.begin(), tmp.end(), back_inserter(ans));\n    }\n    return ans;\n  }\n\n  vector<Cycle> const &seq() const\n  {\n    return V;\n  }\n\n  void operator+=(Chain const &other)\n  {\n    copy(other.seq().begin(), other.seq().end(), back_inserter(V));\n  }\n\nprivate:\n  void merge(int n)\n  {\n    if (V.empty())\n    {\n      V.push_back(Cycle{n, true});\n    }\n    else\n    {\n      auto inverse{inv()};\n      *this += Chain{Cycle{n, true}};\n      *this += inverse;\n      *this += Chain{Cycle{n, false}};\n    }\n  }\n\n  Chain inv() const\n  {\n    vector<Cycle> W;\n    for (auto it = V.rbegin(); it != V.rend(); ++it)\n    {\n      W.push_back(it->inv());\n    }\n    return Chain(W);\n  }\n};\n\n// ----- Solve -----\n\nclass Solve\n{\n  int N;\n  vector<bool> V;\n  Chain C;\n  bool possible;\n\npublic:\n  Solve(int N, string A) : N{N}, V(1 << N), possible{true}\n  {\n    for (auto i = 0; i < 1 << N; ++i)\n    {\n      V[i] = (A[i] == '1');\n    }\n  }\n\n  void answer()\n  {\n    if (check())\n    {\n      construct();\n    }\n    else\n    {\n      possible = false;\n    }\n    flush();\n  }\n\nprivate:\n  bool check() const\n  {\n    if (!V[0])\n    {\n      return false;\n    }\n    for (auto i = 0; i < 1 << N; ++i)\n    {\n      for (auto j = 0; j < 1 << N; ++j)\n      {\n        if (i != j && (i & j) == j)\n        {\n          if (!V[j] && V[i])\n          {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }\n\n  void construct()\n  {\n    for (auto i = 0; i < 1 << N; ++i)\n    {\n      if (V[i])\n      {\n        continue;\n      }\n      bool create{true};\n      for (auto j = 0; j < 1 << N; ++j)\n      {\n        if (i != j && (i & j) == j && !V[j])\n        {\n          create = false;\n          break;\n        }\n      }\n      if (create)\n      {\n        C += Chain{i};\n      }\n    }\n  }\n\n  void flush() const\n  {\n    if (possible)\n    {\n      cout << \"Possible\" << endl;\n    }\n    else\n    {\n      cout << \"Impossible\" << endl;\n      return;\n    }\n    auto tmp{C.path()};\n    cout << tmp.size() << endl;\n    tmp.push_back(Point(0, 0));\n    for (auto const &e : tmp)\n    {\n      cout << e << endl;\n    }\n  }\n};\n\n// ----- main() -----\n\nint main()\n{\n  int N;\n  cin >> N;\n  string A;\n  cin >> A;\n  Solve solve(N, A);\n  solve.answer();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define rrng(a) a.rbegin(),a.rend()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define eb emplace_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ntypedef vector<T> vt;\ninline int getInt() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define dame { puts(\"Impossible\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\nconst int MX = 200005;\n\nvp f(vi a) {\n  int x = a.back();\n  if (sz(a) == 1) {\n    vp res;\n    rep(i,x+2) res.eb(i,0);\n    res.eb(x+1,1);\n    res.eb(x,1);\n    drep(i,x+1) res.eb(i,0);\n    res.eb(0,1);\n    return res;\n  }\n  a.pop_back();\n  rep(i,sz(a)) a[i] -= x+1;\n  vp d = f(a);\n  rep(i,sz(d)) d[i].fi += x+1;\n  vp res;\n  rep(i,x+1) res.eb(i,0);\n  res.insert(res.end(), rng(d));\n  res.eb(x+1,0);\n  res.eb(x,0);\n  res.eb(x,1);\n  reverse(rng(d));\n  res.insert(res.end(), rng(d));\n  res.eb(x+1,1);\n  res.eb(x,1);\n  drep(i,x+1) res.eb(i,0);\n  res.eb(0,1);\n  return res;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  string st;\n  cin>>st;\n  int n2 = 1<<n;\n  vi a(n2);\n  rep(i,n2) a[i] = st[i]-'0';\n  rep(i,n2) a[i] ^= 1;\n  rep(i,n2) {\n    if (a[i]) continue;\n    for (int j = i;; j = (j-1)&i) {\n      if (a[j]) dame;\n      if (!j) break;\n    }\n  }\n  if (a[0]) dame;\n  cout<<\"Possible\"<<endl;\n  vp ans;\n  rep(i,n2) {\n    if (!a[i]) continue;\n    vi s;\n    rep(j,n) if (i>>j&1) s.pb(j);\n    reverse(rng(s));\n    vp now = f(s);\n    ans.insert(ans.end(), rng(now));\n  }\n  ans.eb(0,0);\n  cout<<sz(ans)-1<<endl;\n  for (P p : ans) {\n    cout<<p.fi<<\" \"<<p.se<<endl;\n  }\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\n#include <assert.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\nconst int MOD=1e9+7;\n#define SZ 666666\nint n;\nchar a[SZ];\nbool v[SZ];\nvi neg(vi x)\n{\n\treverse(x.begin(),x.end());\n\tfor(auto&y:x) y=-y;\n\treturn x;\n}\nvi operator + (vi a,const vi&b)\n{\n\tfor(auto x:b) a.pb(x);\n\treturn a;\n}\nvi operator - (vi a,const vi&b)\n{\n\treturn a+neg(b);\n}\nvi cs(vi a,int l,int r)\n{\n\tif(l==r)\n\t\treturn {a[l]};\n\tint m=(l+r)>>1;\n\tvi L=cs(a,l,m),R=cs(a,m+1,r);\n\treturn L+R-L-R;\n}\nvi CL(vi t)\n{\n\treturn t;\n}\nvi v1{1},v2{2};\nvi AND(vi p,vi q)\n{\n\treturn CL(p+p+v1+p+p-v1+v2-q-v2-q+v2-q-v2-q);\n}\nint main()\n{\n\tcin>>n>>a;\n\tbool ok=1;\n\tvi g;\n\tfor(int i=0;i<(1<<n);++i) if(a[i]=='0'&&!v[i])\n\t{\n\t\tfor(int j=0;j<(1<<n);++j) if((j&i)==i)\n\t\t\tv[j]=1,ok&=a[j]=='0';\n\t\tvi t;\n\t\tfor(int j=0;j<n;++j) if(i&(1<<j)) t.pb(j+1);\n\t\tvi w=cs(t,0,t.size()-1);\n\t\tif(!g.size()) g=w;\n\t\telse g=AND(g,w);\n\t}\n\tif(!ok)\n\t{\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tputs(\"Possible\");\n\tvector<pii> v;\n\tv.pb(pii(0,0));\n\tfor(auto c:g)\n\t{\n\t\tint x=abs(c);\n\t\tif(c>0)\n\t\t{\n\t\t\tv.pb(pii(x-1,0));\n\t\t\tv.pb(pii(x-1,1));\n\t\t\tv.pb(pii(x,1));\n\t\t\tv.pb(pii(x,0));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tv.pb(pii(x-1,0));\n\t\t\tv.pb(pii(x,0));\n\t\t\tv.pb(pii(x,1));\n\t\t\tv.pb(pii(x-1,1));\n\t\t}\n\t}\n\tv.pb(pii(0,0));\n\tvector<pii> vt;\n\tfor(int i=0;i<v.size();++i)\n\t{\n\t\tpii A=v[i],B=v[(i+1)%v.size()];\n\t\tvt.pb(A);\n\t\tint g=abs(A.fi-B.fi)+(A.se-B.se);\n\t\tif(g)\n\t\t{\n\t\t\tfor(int j=1;j<=g;++j)\n\t\t\t{\n\t\t\t\tpii s(A.fi+(B.fi-A.fi)/g*j,\n\t\t\t\tA.se+(B.se-A.se)/g*j);\n\t\t\t\tvt.pb(s);\n\t\t\t}\n\t\t}\n\t}\n\tvt.erase(unique(vt.begin(),vt.end()),vt.end());\n\tv=vt;\n\tprintf(\"%d\\n\",int(v.size())-1);\n\tfor(auto c:v) printf(\"%d %d\\n\",c.fi,c.se);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid fail(){\n\tcout << \"Impossible\" << '\\n';\n\texit(0);\n}\n\nmt19937 mt(48);\n\nvector<int> inv(vector<int> x){\n\treverse(x.begin(), x.end());\n\tfor(int& a : x) a = -a;\n\treturn x;\n}\n\nvector<int> make(vector<int> val){\n\tif(val.size() == 1){\n\t\tint f = mt() & 4;\n\t\tf -= 2;\n\t\tif(f == 0) f++;\n\t\tvector<int> x;\n\t\tif(f < 0){\n\t\t\tfor(int r = 0; r < -f; r++) x.push_back(-val.front());\n\t\t} else {\n\t\t\tfor(int r = 0; r < f; r++) x.push_back(val.front());\t\t\t\n\t\t}\n\t\treturn x;\n\t}\n\tvector<int> nval[2];\n\tvector<int> nx[2];\n\tfor(int i = 0; i < (int)val.size(); i++){\n\t\tnval[i & 1].push_back(val[i]);\n\t}\n\tnx[0] = make(nval[0]);\n\tnx[1] = make(nval[1]);\n\tvector<int> x;\n\tfor(int r : nx[0]) x.push_back(r);\n\tfor(int r : nx[1]) x.push_back(r);\n\tfor(int r : inv(nx[0])) x.push_back(r);\n\tfor(int r : inv(nx[1])) x.push_back(r);\n\treturn x;\n}\n\nvoid pr(vector<int> x){\n\tvector<pair<int,int> > path;\n\tpath.push_back({0, 0});\n\tfor(int f : x){\n\t\tint c = 0;\n\t\tint val = abs(f) - 1;\n\t\twhile(c < val){\n\t\t\tc++;\n\t\t\tpath.push_back({c, 0});\n\t\t}\n\t\tif(f > 0){\n\t\t\tpath.push_back({c, 1});\n\t\t\tpath.push_back({c+1, 1});\n\t\t\tpath.push_back({c+1, 0});\n\t\t\tpath.push_back({c, 0});\n\t\t} else {\n\t\t\tpath.push_back({c+1, 0});\n\t\t\tpath.push_back({c+1, 1});\n\t\t\tpath.push_back({c, 1});\n\t\t\tpath.push_back({c, 0});\n\t\t}\n\t\twhile(c > 0){\n\t\t\tc--;\n\t\t\tpath.push_back({c, 0});\n\t\t}\n\t}\n\tcout << (int)path.size() - 1 << '\\n';\n\tfor(pair<int,int> a : path){\n\t\tcout << a.first << ' ' << a.second << '\\n';\n\t}\n}\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint n;\n\tcin >> n;\n\tint N = (1 << n);\n\tstring s(N, '0');\n\tcin >> s;\n\t// for(int j = 0; j < N; j++){\n\t// \ts[j] = \"01\"[(__builtin_popcount(j | (j >> 1)) <= 3)];\n\t// }\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tif((i & j) == i){\n\t\t\t\tif(s[i] < s[j]){\n\t\t\t\t\tfail();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<int> > q;\n\tfor(int i = 0; i < N; i++){\n\t\tif(s[i] == '1') continue;\n\t\tvector<int> val;\n\t\tbool fail = false;\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tif((i >> j) & 1){\n\t\t\t\tval.push_back((j+1));\n\t\t\t\tif(s[i ^ (1 << j)] == '0') fail = true;\n\t\t\t}\n\t\t}\n\t\tif(fail) continue;\n\t\tshuffle(val.begin(), val.end(), mt);\n\t\tq.push_back(val);\n\t}\n\twhile(true){\n\t\tvector<int> ans;\n\t\tshuffle(q.begin(), q.end(), mt);\n\t\tfor(vector<int> val : q){\n\t\t\tvector<int> z = make(val);\n\t\t\tfor(int v : z) ans.push_back(v);\n\t\t}\n\t\tbool works = true;\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tvector<int> stk = {0};\n\t\t\tfor(int f : ans){\n\t\t\t\tif((j >> (abs(f) - 1)) & 1){\n\t\t\t\t\tif(stk.back() == -f){\n\t\t\t\t\t\tstk.pop_back();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstk.push_back(f);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint wins = (stk.size() == 1);\n\t\t\tif(wins != s[j] - '0'){\n\t\t\t\tcerr << j << ' ' << wins << ' ' << (s[j] - '0') << '\\n';\n\t\t\t\tworks = false;\n\t\t\t}\n\t\t}\n\t\tif(!works) continue;\n\t\tcerr << ans.size() << '\\n';\n\t\tfor(int x : ans){\n\t\t\tcerr << x << ' ';\n\t\t}\n\t\tcerr << '\\n';\n\t\tpr(ans);\n\t\texit(0);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing ll = long long;\nusing ull = unsigned long long;\nusing namespace std;\nconst int INF = 1e10;\nconst int MOD = 1e9 + 7;\n#define dump(x)                             \\\n    if (dbg) {                              \\\n        cerr << #x << \" = \" << (x) << endl; \\\n    }\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define FOR1(n) for (ll i = 0; i < (n); ++i)\n#define FOR2(i, n) for (ll i = 0; i < (n); ++i)\n#define FOR3(i, a, b) for (ll i = (a); i < (b); ++i)\n#define FOR4(i, a, b, c) for (ll i = (a); i < (b); i += (c))\n#define FOR(...) overload4(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)\n#define FORR(i, a, b) for (int i = (a); i <= (b); ++i)\n#define bit(n, k) ((n >> k) & 1) /*nのk bit目*/\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\nvoid Yes(bool flag = true) {\n    if (flag)\n        cout << \"Yes\" << endl;\n    else\n        cout << \"No\" << endl;\n}\nvoid No(bool flag = true) {\n    Yes(!flag);\n}\nvoid YES(bool flag = true) {\n    if (flag)\n        cout << \"YES\" << endl;\n    else\n        cout << \"NO\" << endl;\n}\nvoid NO(bool flag = true) {\n    YES(!flag);\n}\n#define pb emplace_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define all(v) (v).begin(), (v).end()\n#define SZ(x) ((int)(x).size())\n#define P pair<int, int>\n//#define V vector<int>\n//#define S set<int>\n#define itn int\nbool dbg = false;\n\nint N;\nstring A;\nbool checked[111010];\nbool out[111010];\n\nvector<int> x, y;\n\nvoid go(int gx) {\n    int sx;\n    int ys;\n    sx = x[(int)x.size() - 1];\n    ys = y[(int)y.size() - 1];\n    if (sx > gx) {\n        while (sx != gx) {\n            sx--;\n            x.pb(sx);\n            y.pb(ys);\n        }\n    } else if (sx < gx) {\n        while (sx != gx) {\n            sx++;\n            x.pb(sx);\n            y.pb(ys);\n        }\n    }\n}\nvoid chy() {\n    x.pb(x[(int)x.size() - 1]);\n    y.pb(!y[(int)y.size() - 1]);\n}\n\nvoid fill(int T, bool nikai = false) {\n    int cnt = __builtin_popcount(T);\n    if (cnt == 1) {\n        int nxt = __builtin_ffs(T) - 1;\n        go(nxt);\n        chy();\n        go(nxt + 1);\n        chy();\n        go(nxt);\n        chy();\n        go(nxt + 1);\n        chy();\n        go(nxt);\n        chy();\n        go(nxt + 1);\n        chy();\n        go(nxt);\n        return;\n    } else {\n        int n1 = __builtin_ffs(T) - 1;\n        T -= (1 << n1);\n        int n2 = __builtin_ffs(T) - 1;\n        int n3 = n2;\n        FOR(N) {\n            if ((1 << i) & T) {\n                n3 = i;\n            }\n        }\n        n3++;\n\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        go(n2);\n        //ここで再帰\n        if (n2 + 1 != n3) {\n            fill(T);\n        }\n        chy();\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        go(n2);\n        chy();\n        go(n1);\n\n        /*\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        go(n2);\n        chy();\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        go(n2);\n        chy();\n        go(n1);\n        */\n    }\n}\n\n\nvoid solve() {\n    bool flag = true;\n    int tmp = -1;\n    for (int T = 1; T < (1 << N); T++) {\n        if (A[T] == 1) {\n            continue;\n        }\n        if (checked[T]) {\n            continue;\n        }\n        out[T] = true;\n        if (__builtin_popcount(T) == 1) {\n            tmp = T;\n        }\n        for (int i = T; i < (1 << N); i = (i + 1) | T) {\n            // ここに処理を書く\n            if (A[i] == 1) {\n                flag = false;\n            }\n            checked[i] = true;\n        }\n    }\n    if (!flag) {\n        cout << \"Impossible\" << endl;\n        return;\n    }\n    cout << \"Possible\" << endl;\n\n    x.pb(0);\n    y.pb(0);\n\n    for (int T = 1; T < (1 << N); T++) {\n        if (out[T]) {\n            fill(T);\n        }\n    }\n    go(0);\n    int L = x.size();\n    cout << L - 1 << endl;\n\n    FOR(L) {\n        cout << x[i] << \" \" << y[i] << endl;\n    }\n}\n\nsigned main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cin >> N;\n    cin >> A;\n    for (auto& c : A)\n        c -= '0';\n\n\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing ll = long long;\nusing ull = unsigned long long;\nusing namespace std;\nconst int INF = 1e10;\nconst int MOD = 1e9 + 7;\n#define dump(x)                             \\\n    if (dbg) {                              \\\n        cerr << #x << \" = \" << (x) << endl; \\\n    }\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define FOR1(n) for (ll i = 0; i < (n); ++i)\n#define FOR2(i, n) for (ll i = 0; i < (n); ++i)\n#define FOR3(i, a, b) for (ll i = (a); i < (b); ++i)\n#define FOR4(i, a, b, c) for (ll i = (a); i < (b); i += (c))\n#define FOR(...) overload4(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)\n#define FORR(i, a, b) for (int i = (a); i <= (b); ++i)\n#define bit(n, k) ((n >> k) & 1) /*nのk bit目*/\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\nvoid Yes(bool flag = true) {\n    if (flag)\n        cout << \"Yes\" << endl;\n    else\n        cout << \"No\" << endl;\n}\nvoid No(bool flag = true) {\n    Yes(!flag);\n}\nvoid YES(bool flag = true) {\n    if (flag)\n        cout << \"YES\" << endl;\n    else\n        cout << \"NO\" << endl;\n}\nvoid NO(bool flag = true) {\n    YES(!flag);\n}\n#define pb emplace_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define all(v) (v).begin(), (v).end()\n#define SZ(x) ((int)(x).size())\n#define P pair<int, int>\n//#define V vector<int>\n//#define S set<int>\n#define itn int\nbool dbg = false;\n\nint N;\nstring A;\nbool checked[111010];\nbool out[111010];\n\nvector<int> x, y;\n\nvoid go(int gx) {\n    int sx;\n    int ys;\n    sx = x[(int)x.size() - 1];\n    ys = y[(int)y.size() - 1];\n    if (sx > gx) {\n        while (sx != gx) {\n            sx--;\n            x.pb(sx);\n            y.pb(ys);\n        }\n    } else if (sx < gx) {\n        while (sx != gx) {\n            sx++;\n            x.pb(sx);\n            y.pb(ys);\n        }\n    }\n}\nvoid chy() {\n    x.pb(x[(int)x.size() - 1]);\n    y.pb(!y[(int)y.size() - 1]);\n}\n\nvoid fill(int T, bool nikai = false) {\n    int cnt = __builtin_popcount(T);\n    if (cnt == 1) {\n        int nxt = __builtin_ffs(T) - 1;\n        go(nxt);\n        chy();\n        go(nxt + 1);\n        chy();\n        go(nxt);\n        chy();\n        go(nxt + 1);\n        chy();\n        go(nxt);\n        chy();\n        go(nxt + 1);\n        chy();\n        go(nxt);\n        return;\n    } else {\n        int n1 = __builtin_ffs(T) - 1;\n        T -= (1 << n1);\n        int n2 = __builtin_ffs(T) - 1;\n        int n3 = n2;\n        FOR(N) {\n            if ((1 << i) & T) {\n                n3 = i;\n            }\n        }\n        n3++;\n\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        go(n2);\n        //ここで再帰\n        if (n2 + 1 != n3) {\n            fill(T);\n        }\n        chy();\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        go(n2);\n        chy();\n        go(n1);\n\n        /*\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        go(n2);\n        chy();\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        go(n2);\n        chy();\n        go(n1);\n        */\n    }\n}\n\n\nvoid solve() {\n    bool flag = true;\n    int tmp = -1;\n    for (int T = 1; T < (1 << N); T++) {\n        if (A[T] == 1) {\n            continue;\n        }\n        if (checked[T]) {\n            continue;\n        }\n        out[T] = true;\n        if (__builtin_popcount(T) == 1) {\n            tmp = T;\n        }\n        for (int i = T; i < (1 << N); i = (i + 1) | T) {\n            // ここに処理を書く\n            if (A[i] == 1) {\n                flag = false;\n            }\n            checked[i] = true;\n        }\n    }\n    if (!flag) {\n        cout << \"Impossible\" << endl;\n        return;\n    }\n    cout << \"Possible\" << endl;\n\n    x.pb(0);\n    y.pb(0);\n\n    for (int T = 1; T < (1 << N); T++) {\n        if (out[T]) {\n            fill(T);\n        }\n    }\n    go(0);\n    int L = x.size();\n    cout << L - 1 << endl;\n    if (L >= 250000) {\n        while (true) {}\n    }\n\n    FOR(L) {\n        cout << x[i] << \" \" << y[i] << endl;\n    }\n}\n\nsigned main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cin >> N;\n    cin >> A;\n    for (auto& c : A)\n        c -= '0';\n\n\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\ntypedef pair<i64, i64> pi64;\ntypedef double ld;\n\ntemplate<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\nvi sift(vi a, int x) {\n    vi b;\n    for (int y: a) if (abs(y) != x) b.pb(y);\n    return b;\n}\n\nbool trivial(vi a) {\n    vi st;\n    for (int x: a) {\n        if (st.empty() || st.back() + x) st.pb(x);\n        else st.pop_back();\n    }\n    return st.empty();\n}\n\nint n, l;\n\nbool good(vi a) {\n    if (trivial(a)) return false;\n    for1(i, n) if (!trivial(sift(a, i))) return false;\n    return true;\n}\n\nvi best;\n\nvoid rec(vi &a) {\n    if (a.size() >= best.size()) return;\n    if (good(a)) {\n        best = a;\n        return;\n    }\n    for1(i, n) {\n        a.pb(i);\n        rec(a);\n        a.pop_back();\n\n        a.pb(-i);\n        rec(a);\n        a.pop_back();\n    }\n}\n\nvoid act(vi v, vector<pii> &p) {\n    for (int x: v) {\n        for1(i, abs(x)) p.pb({i, 0});\n        if (x > 0) {\n            p.pb({x + 1, 0});\n            p.pb({x + 1, 1});\n            p.pb({x, 1});\n            p.pb({x, 0});\n        } else {\n            p.pb({-x, 1});\n            p.pb({-x + 1, 1});\n            p.pb({-x + 1, 0});\n            p.pb({-x, 0});\n        }\n        ford(i, abs(x)) p.pb({i, 0});\n    }\n}\n\nvi seq(vi c) {\n    if (c.size() == 1) return c;\n    int x = c.back();\n    c.pop_back();\n    vi res = seq(c);\n    vi ans = res;\n    ans.pb(x);\n    reverse(all(res));\n    for (int y: res) ans.pb(-y);\n    ans.pb(-x);\n    return ans;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(\"input.txt\", \"rt\", stdin);\n#endif\n\n    int n;\n    string s;\n    cin >> n >> s;\n    vi good(1 << n);\n    forn(i, 1 << n) good[i] = s[i] - '0';\n\n    bool ok = good[0];\n    forn(i, 1 << n) forn(j, n) {\n        if ((i >> j) & 1) continue;\n        if (!good[i] && good[i | (1 << j)]) ok = false;\n    }\n\n    if (!ok) cout << \"Impossible\\n\";\n    else {\n        cout << \"Possible\\n\";\n        vector<pii> ans = {{0, 0}};\n        forn(i, 1 << n) {\n            if (good[i]) continue;\n            bool ok = true;\n            forn(j, n) if ((i >> j) & 1) ok &= good[i ^ (1 << j)];\n            if (!ok) continue;\n            vi c;\n            forn(j, n) if ((i >> j) & 1) c.pb(j);\n            act(seq(c), ans);\n        }\n        cout << ans.size() - 1 << '\\n';\n        for (auto w: ans) cout << w.fi << ' ' << w.se << '\\n';\n    }\n\n#ifdef LOCAL_DEFINE\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n\n #include <stdio.h>\n #include <bits/stdc++.h>\n\n\n\n\n\n\nusing namespace std;\n\n\n\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a);\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a);\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a);\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\n\n\n\n\n\n\nusing li = long long int;\nusing lu = long long unsigned;\nusing ld = long double;\n\n\nusing pii = tuple<li, li>;\nusing piii = tuple<li, li, li>;\nusing piiii = tuple<li, li, li, li>;\nusing vi = vector<li>;\nusing vii = vector<pii>;\nusing viii = vector<piii>;\nusing vvi = vector<vi>;\nusing vvii = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\nstruct empty_t {};\nnamespace tuple_access {\n\n  struct xx_t {} xx;\n  struct yy_t {} yy;\n  struct zz_t {} zz;\n  struct ww_t {} ww;\n\n  template<class T>\n  typename tuple_element<0,T>::type& operator^(T& v, xx_t) { return get<0>(v); }\n  template<class T>\n  typename tuple_element<0,T>::type const& operator^(T const& v, xx_t) { return get<0>(v); }\n  template<class T>\n  typename tuple_element<0,T>::type&& operator^(T&& v, xx_t) { return get<0>(v); }\n\n  template<class T>\n  typename tuple_element<1,T>::type& operator^(T& v, yy_t) { return get<1>(v); }\n  template<class T>\n  typename tuple_element<1,T>::type const& operator^(T const& v, yy_t) { return get<1>(v); }\n  template<class T>\n  typename tuple_element<1,T>::type&& operator^(T&& v, yy_t) { return get<1>(v); }\n\n  template<class T>\n  typename tuple_element<2,T>::type& operator^(T& v, zz_t) { return get<2>(v); }\n  template<class T>\n  typename tuple_element<2,T>::type const& operator^(T const& v, zz_t) { return get<2>(v); }\n  template<class T>\n  typename tuple_element<2,T>::type&& operator^(T&& v, zz_t) { return get<2>(v); }\n\n  template<class T>\n  typename tuple_element<3,T>::type& operator^(T& v, ww_t) { return get<3>(v); }\n  template<class T>\n  typename tuple_element<3,T>::type const& operator^(T const& v, ww_t) { return get<3>(v); }\n  template<class T>\n  typename tuple_element<3,T>::type&& operator^(T&& v, ww_t) { return get<3>(v); }\n}\nusing namespace tuple_access;\n\n\nint ilog2(int x){ return 31 - __builtin_clz(x); }\n\ntemplate <class T>\nstruct identity : std::unary_function <T, T> {\n  T operator() (const T& x) const {return x;}\n};\n\ntemplate<class T>\nT& smin(T& x, T const& y) { x = min(x,y); return x; }\n\ntemplate <class T>\nT& smax(T& x, T const& y) { x = max(x, y); return x; }\n\n\ntemplate<typename T>\nT isqrt(T const&x){\n  static_assert(is_integral<T>::value, \"is_integral<T>::value\");\n  assert(x>=T(0));\n  T ret = static_cast<T>(sqrtl(x));\n  while(ret>0 && ret*ret>x) --ret;\n  while(x-ret*ret>2*ret) ++ret;\n  return ret;\n}\n\ntemplate<typename T>\nT icbrt(T const&x) {\n  static_assert(is_integral<T>::value, \"is_integral<T>::value\");\n  assert(x>=T(0));\n  T ret = static_cast<T>(cbrt(x));\n  while(ret>0 && ret*ret*ret>x) --ret;\n  while(x-ret*ret*ret>3*ret*(ret+1)) ++ret;\n  return ret;\n}\n\nconst int N = 8;\nbool A[1<<N];\nbool mark[1<<N];\n\nvoid fail() {\n  cout << \"Impossible\" << endl;\n  exit(0);\n}\n\nint main(){\n  ios::sync_with_stdio(0); cin.tie(0);\n\n  int n; cin>>n;\n  for(li i = 0; i < (li)(1<<n); ++i) {\n    char c; cin>>c;\n    A[i] = (c=='1');\n  }\n  if(!A[0]) fail();\n  for(li m1 = 0; m1 < (li)(1<<n); ++m1) for(li m2 = 0; m2 < (li)(1<<n); ++m2) if((m1&m2) == m1) {\n    if(A[m2] && !A[m1]) fail();\n  }\n  cout << \"Possible\" << endl;\n\n  vii ans;\n  ans.emplace_back(0,0);\n  li ax=0;\n\n  for(li m = 0; m < (li)(1<<n); ++m) if(!A[m] && !mark[m]) {\n    for(li m2 = 0; m2 < (li)(1<<n); ++m2) if((m&m2) == m) mark[m2] = 1;\n    vii cur;\n    for(li i = 0; i < (li)(n); ++i) if(m&(1<<i)) {\n      if(cur.empty()) {\n        cur.emplace_back(i,0);\n        continue;\n      }\n      vii nx = cur;\n      nx.emplace_back(i,0);\n      reverse(begin(cur), end(cur));\n      for(auto p : cur) {\n        li u,v; tie(u,v) = p;\n        nx.emplace_back(u,1-v);\n      }\n      nx.emplace_back(i,1);\n    }\n\n    for(auto uv : cur) {\n      li u,v; tie(u,v) = uv;\n      if(v == 0) {\n        while(ax < u) { ax++; ans.emplace_back(ax,0); }\n        while(ax > u) { ax--; ans.emplace_back(ax,0); }\n        ans.emplace_back(ax,1);\n        ans.emplace_back(ax+1,1);\n        ans.emplace_back(ax+1,0);\n        ax++;\n      }else {\n        while(ax < u+1) { ax++; ans.emplace_back(ax,0); }\n        while(ax > u+1) { ax--; ans.emplace_back(ax,0); }\n        ax--;\n        ans.emplace_back(ax+1,1);\n        ans.emplace_back(ax,1);\n        ans.emplace_back(ax,0);\n      }\n    }\n  }\n\n  while(ax) {\n    ax--;\n    ans.emplace_back(ax,0);\n  }\n\n  cout << ans.size()-1 << endl;\n  for(auto xy : ans) {\n    li x,y; tie(x,y) = xy;\n    cout << x << \" \" << y << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring A;\ninline void Exit(){\n\tputs(\"Impossible\");\n\texit(0);\n}\nint n;\ntypedef pair<int,int> pi;\nvector<int> ths;\nvector<int> operator + (vector<int> a, vector<int> b){\n\tfor(size_t i=0;i<b.size();i++){\n\t\ta.push_back(b[i]);\n\t}return a;\n}\ninline vector<int> Rev(vector<int> a){\n\treverse(a.begin(),a.end());\n\tfor(size_t i=0;i<a.size();i++)a[i]=-a[i];\n\treturn a;\n}\n\nvector<pi> pit;\n\nint main(){\n\tcin >> n >> A;\n\tif(A[0]=='0')Exit();\n\tfor(int i=0;i<1<<n;i++){\n\t\tif(A[i]=='1')for(int j=i;j;j=i&(j-1)){\n\t\t\tif(A[j]=='0')Exit();\n\t\t}\n\t}\n\tfor(int s=0;s<1<<n;s++){\n\t\tint flg=0;\n\t\tif(A[s]=='0'){\n\t\t\tfor(int j=(s-1)&s;j;j=s&(j-1)){\n\t\t\t\tif(A[j]=='0')flg=1;\n\t\t\t}\n\t\t\tif(flg)continue;\n\t\t\tths.clear();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(s&(1<<i)){\n\t\t\t\t\tif(!ths.size())ths = ths + vector<int>(1,i+1);\n\t\t\t\t\telse ths = vector<int>(1,i+1) + ths + vector<int>(1,-(i+1)) + Rev(ths);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(size_t i=0;i<ths.size();i++){\n\t\t\t\tint j = ths[i];\n\t\t\t\tint d = abs(j)-1;\n\t\t\t\tfor(int i=0;i<=d;i++)pit.push_back(pi(i,0));\n\t\t\t\tif(j<0){\n\t\t\t\t\tpit.push_back(pi(d,1));\n\t\t\t\t\tpit.push_back(pi(d+1,1));\n\t\t\t\t\tpit.push_back(pi(d+1,0));\n\t\t\t\t}else{\n\t\t\t\t\tpit.push_back(pi(d+1,0));\n\t\t\t\t\tpit.push_back(pi(d+1,1));\n\t\t\t\t\tpit.push_back(pi(d,1));\n\t\t\t\t}\n\t\t\t\tfor(int i=d;i;i--)pit.push_back(pi(i,0));\n\t\t\t}\n\t\t}\n\t}\n\tpit.push_back(pi(0,0));\n\tcout << \"Possible\\n\" << pit.size()-1 << endl;\n\tfor(size_t i=0;i<pit.size();i++){\n\t\tprintf(\"%d %d\\n\",pit[i].first,pit[i].second);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\n#include <assert.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\nconst int MOD=1e9+7;\n#define SZ 666666\nint n;\nchar a[SZ];\nbool v[SZ];\nvi neg(vi x)\n{\n\treverse(x.begin(),x.end());\n\tfor(auto&y:x) y=-y;\n\treturn x;\n}\nvi operator + (vi a,const vi&b)\n{\n\tfor(auto x:b) a.pb(x);\n\treturn a;\n}\nvi operator - (vi a,const vi&b)\n{\n\treturn a+neg(b);\n}\nvi cs(vi a,int l,int r)\n{\n\tif(l==r)\n\t\treturn {a[l]};\n\tint m=(l+r)>>1;\n\tvi L=cs(a,l,m),R=cs(a,m+1,r);\n\treturn L+R-L-R;\n}\nvi CL(vi t)\n{\n\treturn t;\n}\nvi v1{1},v2{2};\nvi AND(vi p,vi q)\n{\n\treturn CL(p+p+v1+p+p-v1+v2-q-v2-q+v2-q-v2-q);\n}\nint main()\n{\n\tcin>>n>>a;\n\tbool ok=1;\n\tvi g;\n\tfor(int i=0;i<(1<<n);++i) if(a[i]=='0'&&!v[i])\n\t{\n\t\tfor(int j=0;j<(1<<n);++j) if((j&i)==i)\n\t\t\tv[j]=1,ok&=a[j]=='0';\n\t\tvi t;\n\t\tfor(int j=0;j<n;++j) if(i&(1<<j)) t.pb(j+1);\n\t\tvi w=cs(t,0,t.size()-1);\n\t\tif(!g.size()) g=w;\n\t\telse g=AND(g,w);\n\t}\n\tif(!ok)\n\t{\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tputs(\"Possible\");\n\tvector<pii> v;\n\tv.pb(pii(0,0));\n\tfor(auto c:g)\n\t{\n\t\tint x=abs(c);\n\t\tif(c>0)\n\t\t{\n\t\t\tv.pb(pii(x-1,0));\n\t\t\tv.pb(pii(x-1,1));\n\t\t\tv.pb(pii(x,1));\n\t\t\tv.pb(pii(x,0));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tv.pb(pii(x-1,0));\n\t\t\tv.pb(pii(x,0));\n\t\t\tv.pb(pii(x,1));\n\t\t\tv.pb(pii(x-1,1));\n\t\t}\n\t}\n\tv.pb(pii(0,0));\n\tprintf(\"%d\\n\",int(v.size())-1);\n\tfor(auto c:v) printf(\"%d %d\\n\",c.fi,c.se);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <cstring>\n#include <list>  \n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <chrono>\n#include <random>\nusing namespace std;\n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \nstd::mt19937 rnd((int)std::chrono::steady_clock::now().time_since_epoch().count());\ntypedef long long ll;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN = 8;\nstruct P { int x, y; P() {} P(int x, int y) :x(x), y(y) {} };\n\nint n;\nchar s[(1 << MAXN) + 1];\nvector<P> ans;\n\nbool solve() {\n\tif (s[0] == '0') return false;\n\tvector<int> todo;\n\tREP(mask, 1 << n) {\n\t\tbool anysub = false;\n\t\tfor (int sub = 0; sub < mask; sub = (sub + (1 << n) - 1 - mask + 1)&mask) if (s[sub] == '0') anysub = true;\n\t\tif (s[mask] == '1' && anysub) return false;\n\t\tif (s[mask] == '0' && !anysub) todo.PB(mask);\n\t}\n\tans.clear();\n\t//printf(\"TODO:\"); REPSZ(i, todo) printf(\" %x\", todo[i]); puts(\"\");\n\tREPSZ(i, todo) {\n\t\tint mask = todo[i];\n\t\tvector<int> cur; REP(j, n) if (mask&(1 << j)) cur.PB(j);\n\t\tvector<P> path;\n\t\tfor (int j = SZ(cur) - 1; j >= 0; --j) {\n\t\t\tint x = cur[j];\n\t\t\tif (SZ(path) == 0) {\n\t\t\t\tpath.PB(P(x, 1)); path.PB(P(x + 1, 1)); path.PB(P(x + 1, 0)); path.PB(P(x, 0));\n\t\t\t} else {\n\t\t\t\tvector<P> oldpath = path; path.clear();\n\t\t\t\tFOR(xx, x, oldpath[0].x) path.PB(P(xx, 1));\n\t\t\t\tREPSZ(k, oldpath) path.PB(oldpath[k]);\n\t\t\t\tfor (int xx = oldpath[0].x; xx >= x; --xx) path.PB(P(xx, 1));\n\t\t\t\tpath.PB(P(x, 0));\n\t\t\t\tpath.PB(P(x + 1, 0));\n\t\t\t\tFORE(xx, x + 1, oldpath[0].x) path.PB(P(xx, 1));\n\t\t\t\tfor (int k = SZ(oldpath) - 1; k >= 0; --k) path.PB(oldpath[k]);\n\t\t\t\tfor (int xx = oldpath[0].x - 1; xx >= x + 1; --xx) path.PB(P(xx, 1));\n\t\t\t\tpath.PB(P(x + 1, 0));\n\t\t\t\tpath.PB(P(x, 0));\n\t\t\t}\n\t\t}\n\t\tREP(xx, path[0].x) ans.PB(P(xx, 1));\n\t\tREPSZ(k, path) ans.PB(path[k]);\n\t\tfor (int xx = path[0].x; xx >= 1; --xx) ans.PB(P(xx, 1));\n\t}\n\tans.PB(P(0, 1));\n\treturn true;\n}\n\nvoid run() {\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", s); assert(strlen(s) == (1 << n));\n\tif (!solve()) { printf(\"Impossible\\n\"); return; }\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d\\n\", SZ(ans) - 1);\n\tREPSZ(i, ans) printf(\"%d %d\\n\", ans[i].x, ans[i].y);\n}\n\nvoid verify() {\n\tint len = SZ(ans) - 1;\n\tREP(i, len) {\n\t\tP a = ans[i], b = ans[i + 1];\n\t\tint dx = b.x - a.x, dy = b.y - a.y;\n\t\tassert(abs(dx) + abs(dy) == 1);\n\t}\n\tassert(ans[0].x == ans[len].x&&ans[0].y == ans[len].y);\n\tvector<int> seq;\n\tREP(i, len) {\n\t\tP a = ans[i], b = ans[i + 1];\n\t\tint dx = b.x - a.x, dy = b.y - a.y, lx = min(a.x, b.x), ly = min(a.y, b.y);\n\t\tif (abs(dx) == 1) seq.PB(2 * lx + ly);\n\t}\n\t//printf(\"seq:\"); REPSZ(i, seq) printf(\" %d\", seq[i]); puts(\"\");\n\tREP(mask, 1 << n) {\n\t\tvector<int> nseq;\n\t\tREPSZ(i, seq) { int x = seq[i] / 2; if (mask&(1 << x)) nseq.PB(seq[i]); }\n\t\t//printf(\"\\tnseq:\"); REPSZ(i, nseq) printf(\" %d\", nseq[i]); puts(\"\");\n\t\tvector<int> rem;\n\t\tREPSZ(i, nseq) {\n\t\t\tif (SZ(rem) > 0 && nseq[i] == rem.back()) rem.pop_back(); else rem.PB(nseq[i]);\n\t\t}\n\t\tbool have = SZ(rem) == 0;\n\t\tbool want = s[mask] == '1';\n\t\tassert(have == want);\n\t}\n}\n\nvoid stress() {\n\tREP(rep, 100000) {\n\t\tn = 4; // rnd() % 3 + 1;\n\t\tREP(i, 1 << n) s[i] = '0' + rnd() % 2; s[1 << n] = '\\0';\n\t\tbool have = solve();\n\t\tif (have) {\n\t\t\tprintf(\"done %d: %s (%s)\\n\", n, s, have ? \"POSSIBLE\" : \"IMPOSSIBLE\");\n\t\t\t//printf(\"%d\\n\", SZ(ans) - 1); REPSZ(i, ans) printf(\"%d %d\\n\", ans[i].x, ans[i].y);\n\t\t\tverify();\n\t\t}\n\t}\n}\n\n\nint main() {\n\trun();\n\t//stress();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i = (begin); i < (end); i++)\n#define rep(i, n) FOR(i, 0, n)\nusing ll = long long;\nusing namespace std;\n#define all(x) (x).begin(),(x).end()\nusing pii = pair<int, int>; using vi = vector<int>; using vl = vector<ll>;\n\nint N;\n\nunordered_set<int> setter(int i) {\n    unordered_set<int> ss;\n    rep(j, N) {\n        int k = i & 1;\n        if (k == 0)\n            ss.insert(j);\n        i >> 1;\n    }\n    return ss;\n}\n// 和集合の計算\ntemplate<class T> unordered_set<T> Union(unordered_set<T>& rsettA, unordered_set<T>&rsettB) {\n    unordered_set<T> settUnion(rsettA);\n    for (auto itt = rsettB.begin(); itt != rsettB.end(); itt++) {\n        settUnion.insert(*itt);\n    }\n    return settUnion;\n}\n// 積集合の計算\ntemplate<class T> unordered_set<T> Product(unordered_set<T>& rsettA, unordered_set<T>&rsettB) {\n    unordered_set<T> settProduct;\n    for (auto itt = rsettB.begin(); itt != rsettB.end(); itt++) {\n        if (rsettA.find(*itt) != rsettA.end()) {\n            settProduct.insert(*itt);\n        }\n    }\n    return settProduct;\n}\n// 補集合の計算\ntemplate<class T> unordered_set<T> Complement(unordered_set<T>& rsettA, unordered_set<T>&rsettB) {\n    unordered_set<T> settComplement(rsettA);\n    for (auto itt = rsettB.begin(); itt != rsettB.end(); itt++) {\n        settComplement.erase(*itt);\n    }\n    return settComplement;\n}\nsigned main() {\n    cin >> N;\n    // unordered_set<int> oo, ii;\n    int oo(0), ii(0);\n    vi sss;\n    string as;\n    cin >> as;\n    rep(i, 1<<N) {\n        int x = as[i] - '0';\n        // auto ss = setter(i);\n        if (x == 1) {\n            oo |= i;\n            // ii = Union(ii, ss);\n        } else {\n            sss.push_back(i);\n            // oo = Union(oo, ss);\n        }\n    }\n    for(auto s : sss) {\n        if((oo&s) == s) {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n    \n    // if (Product(oo, ii).size() != 0) {\n    // if ((oo&ii) != 0) {\n    //     cout << \"Impossible\" << endl;\n    //     return 0;\n    // }\n    cout << \"Possible\" << endl;\n\n    ii = (1<<N) - oo - 1;\n    // cerr << oo << ' ' << ii << endl;\n    // cerr << (oo & ii) << endl;\n    vector<pii> p;\n    int before = 0;\n    // cerr << ii << endl;\n    p.push_back({0, 0});\n    rep(i, N) {\n        // cerr << ii << endl;\n        // cerr << ((ii&1) ^ before) << endl;\n        if((ii&1) ^ before) {\n            if(ii&1) {\n                if(i!=0) {\n                    p.push_back({i, 0});\n                }\n                p.push_back({i, 1});\n            } else {\n                p.push_back({i, 1});\n                if(i!=N-1)\n                    p.push_back({i, 0});\n            }\n        } else {\n            if(i!=0)\n                p.push_back({i, before});\n        }\n        before = ii & 1;\n        ii >>= 1;\n    }\n    if (before)\n        p.push_back({N, 1});\n    for(int k = N; k>=0; k--) {\n        p.push_back({k, 0});\n    }\n\n    cout << p.size() - 1 << endl;\n    for(auto pp : p) {\n        cout << pp.first << ' ' << pp.second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define Fi first\n#define Se second\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define all(x) (x).begin(), (x).end()\n#define pb push_back\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<(n);i++)\ntypedef tuple<int, int, int> t3;\n\nint N;\nchar buf[330];\nint A[330];\n\nvector <int> Get(vector <int> X) {\n\tif(szz(X) == 1) return {X[0]};\n\telse {\n\t\tint t = X.back();\n\t\tX.pop_back();\n\t\tauto w = Get(X);\n\t\tvector <int> res;\n\t\tres.pb(t);\n\t\tres.insert(res.end(), all(w));\n\t\tres.pb(-t);\n\t\treverse(all(w));\n\t\tfor(int e : w) res.pb(-e);\n\t\treturn res;\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &N);\n\tscanf(\"%s\", buf);\n\tfor(int i=0;i<1<<N;i++) A[i] = buf[i] - '0';\n\tint B = 1<<N;\n\trep(i, B) rep(j, B) if((i&j) == j) {\n\t\tif(A[i] && A[j] == 0) {\n\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tvector <int> w;\n\trep(i, B) if(A[i] == 0) {\n\t\tint ok = 1;\n\t\trep(j, i) if((i&j) == j && A[j] == 0) ok = 0;\n\t\tif(ok) w.pb(i);\n\t}\n\tvector <int> R;\n\tfor(int e : w) {\n\t\tvector <int> t;\n\t\trep(i, N) if(1<<i & e) t.pb(i + 1);\n\t\tauto v2 = Get(t);\n\t\tR.insert(R.end(), all(v2));\n\t}\n\tvector <pii> ans;\n\tint now = 0;\n\tans.pb({0, 0});\n\tauto Move = [&](int x) {\n\t\twhile(now < x) ans.pb({++now, 0});\n\t\twhile(now > x) ans.pb({--now, 0});\n\t};\n\tfor(int e : R) {\n\t\tint st, en;\n\t\tif(e > 0) st = e - 1, en = e;\n\t\telse st = -e, en = -e - 1;\n\t\tMove(st);\n\t\tans.pb({st, 1});\n\t\tans.pb({en, 1});\n\t\tans.pb({en, 0});\n\t\tnow = en;\n\t}\n\tMove(0);\n\tputs(\"Possible\");\n\tprintf(\"%d\\n\", szz(ans) - 1);\n\tfor(pii e : ans) printf(\"%d %d\\n\", e.Fi, e.Se);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> rec(int x) {\n\tvector <int> sol;\n\tint pet = 1, bit;\n\tfor (bit = 0; (x&pet) == 0; bit++)\n\t\tpet = 1<<bit;\n\tif (pet == x) {\n\t\tsol.push_back(bit+1);\n\t\treturn sol;\n\t}\n\tvector<int> aux = sol  = rec(x^pet);\n\tsol.push_back(bit+1);\n\tfor (auto it = aux.rbegin(); it != aux.rend(); it++)\n\t\tsol.push_back(-*it);\n\tsol.push_back(-bit-1);\n\treturn sol;\n}\n\nstring tira(const vector<int> & par) {\n\tstring sol;\n\tfor (int x: par) {\n\t\tsol += string(abs(x)-1,'R');\n\t\tif (x > 0) sol += \"URDL\";\n\t\telse sol += \"RULD\";\n\t\tsol += string(abs(x)-1,'L');\n\t}\n\treturn sol;\n}\n\n\nint main() {\n  ios_base::sync_with_stdio(false); \n  cin.tie(nullptr); \n\n\tint n;\n\tcin >> n;\n\tstring s;\n\tcin >> s;\n\tint m = 1<<n;\n\tbool ok = true;\n\tvector<int> obs;\n\tfor (int i = 1; i < m; i++) {\n\t\tif (s[i] == '0') obs.push_back(i);\n\t\tfor (int j = i+1; j < m; j++) {\n\t\t\tint p = i, g = j;\n\t\t\tif (p > g) swap(p, g);\n\t\t\tif ((p&g) == p and s[p] == '0' and s[g] == '1') ok = false;\n\t\t}\n\t}\n\tif (!ok) cout << \"Impossible\" << endl;\n\telse {\n\t\tcout << \"Possible\" << endl;\n\t\tstring sol;\n\t\tfor (auto x: obs) \n\t\t\tsol += tira(rec(x));\n\t\tint k = sol.size();\n\t\tcout << k   << endl;\n\t\tassert(k <= 250000);\n\t\tint px = 0, py = 0; \n\t\tcout << px << \" \" << py << \"\\n\";\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tif (sol[i] == 'U') py++;\n\t\t\telse if (sol[i] == 'D') py--;\n\t\t\telse if (sol[i] == 'L') px--;\n\t\t\telse if (sol[i] == 'R') px++;\n\t\t\tcout << px << \" \" << py << \"\\n\";\n\t\t}\n\t}\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long double EPS = 1e-10;\nconst long long INF = 1e18;\nconst long double PI = acos(-1.0L);\n//const ll mod = 1000000007;\nbool block[8];\nbool tate[8];\nvector<l_l> ans;\n\nvoid f(int x) {\n    for(int i = 1; i <= x; i++) {\n        ans.push_back({i, 0});\n    }\n    ans.push_back({x,1});\n    ans.push_back({x+1,1});\n    ans.push_back({x+1,0});\n    for(int i = x; i >= 0; i--) {\n        ans.push_back({i, 0});\n    }\n}\n\nvoid g(int x) {\n    for(int i = 1; i <= x+1; i++) {\n        ans.push_back({i, 0});\n    }\n    ans.push_back({x+1, 1});\n    for(int j = x; j <= x + 2; j++) {\n        ans.push_back({j, 1});\n    }\n    ans.push_back({x+1, 1});\n    for(int i = x+1; i >= 0; i--) {\n        ans.push_back({i, 0});\n    }\n}\n\nvoid print() {\n    cout << \"Possible\" << endl;\n    cout << ans.size() - 1 << endl;\n    for(auto tmp : ans) {\n        cout << tmp.first << \" \" << tmp.second << endl;\n    }\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    cin >> N;\n    string S;\n    cin >> S;\n    ans.push_back({0, 0});\n    for(int i = 0; i < N; i++) {\n        int bits = (1 << i);\n        if(S[bits] == '1') continue;\n        block[i] = true;\n        f(i);\n    }\n    for(int i = 0; i + 1 < N; i++) {\n        int bits = (1 << i);\n        bits |= (1 << (i + 1));\n        if(S[bits] == '1') continue;\n        if(block[i]) continue;\n        if(block[i+1]) continue;\n        tate[i] = true;\n        g(i);\n    }\n    //print();\n    for(int bits = 0; bits < (1 << N); bits++) {\n        bool blocked = false;\n        if(true) {\n            for(int i = 0; i < N; i++) {\n                if((bits & (1 << i)) and block[i]) {\n                    blocked = true;\n                    //cout << \"Impossible\" << endl;\n                    //return 0;\n                }\n            }\n            for(int i = 0; i + 1 < N; i++) {\n                if((bits & (1 << i)) and (bits & (1 << (i+1))) and tate[i]) {\n                    blocked = true;\n                    //cout << \"Impossible\" << endl;\n                    //return 0;\n                }\n            }\n            bool Left = true;\n            bool Right = true;\n            for(int i = 0; i < N; i++) {\n                if(!(bits & (1 << i))) continue;\n                if(tate[i]) Left = false;\n                if(i > 0 and tate[i-1]) Right = false;\n            }\n            if(!Right and !Left) {\n                //cout << \"Impossible\" << endl;\n                //return 0;\n                blocked = true;\n            }\n        }\n        //cerr << bitset<10>(bits) << \" \" << blocked << \" \" << (S[bits] == '0') << endl;\n        if(blocked ^ (S[bits] == '0')) {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n    print();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<unordered_map>\n#include<complex>\nusing namespace std;\nconst long long mod=998244353;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3100000;\nconst int UF_SIZE = 3100000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint UF[UF_SIZE];\n\tvoid init_UF(int n){\n\t\tfor(int i=0;i<n;i++)UF[i]=-1;\n\t}\n\tint FIND(int a){\n\t\tif(UF[a]<0)return a;\n\t\treturn UF[a]=FIND(UF[a]);\n\t}\n\tvoid UNION(int a,int b){\n\t\ta=FIND(a);b=FIND(b);if(a==b)return;\n\t\tif(UF[a]>UF[b])swap(a,b);\n\t\tUF[a]+=UF[b];UF[b]=a;\n\t}\n}\n// ここから編集しろ\nchar in[310];\nint dp[310];\nint n;\nvector<pair<int,int> >v;\nvector<pair<int,int> >cm;\nvector<pair<int,int> > ad(vector<int>a){\n\tvector<pair<int,int> > ret;\n\tif(a.size()==1){\n\t\tret.push_back(make_pair(a[0],1));\n\t\tret.push_back(make_pair(a[0],0));\n\t\treturn ret;\n\t}\n\tret.push_back(make_pair(a[0],1));\n\tvector<int>b;\n\tfor(int i=1;i<a.size();i++)\n\t\tb.push_back(a[i]);\n\tvector<pair<int,int> >S=ad(b);\n\tfor(int i=0;i<S.size();i++){\n\t\tret.push_back(S[i]);\n\t}\n\tret.push_back(make_pair(a[0],1));\n\tret.push_back(make_pair(a[0],0));\n\treverse(S.begin(),S.end());\n\tfor(int i=0;i<S.size();i++){\n\t\tret.push_back(S[i]);\n\t}\n\tret.push_back(make_pair(a[0],0));\n\t\n\treturn ret;\n}\nvoid f(int a){\n\tif(dp[a])return;\n\tif(a==0)return;\n\tdp[a]=1;\n\tbool ok=true;\n\tfor(int i=0;i<n;i++){\n\t\tif(!(a&(1<<i)))continue;\n\t\tif(in[a-(1<<i)]=='0'){\n\t\t\tok=false;\n\t\t\tf(a-(1<<i));\n\t\t\t\n\t\t}\n\t}\n\tif(ok){\n\t\t// printf(\"[%d]\\n\",a);\n\t\tvector<int>q;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(a&(1<<i))q.push_back(i);\n\t\t}\n\t\tvector<pair<int,int> >ret=ad(q);\n\t\tint now=0;\n\t\t\tfor(int i=0;i<ret.size();i++){\n\t\t\t\tif(now<=ret[i].first){\n\t\t\t\t\twhile(now<ret[i].first){\n\t\t\t\t\t\tnow++;\n\t\t\t\t\t\tv.push_back(make_pair(now,0));\n\t\t\t\t\t}\n\t\t\t\t\tif(ret[i].second){\n\t\t\t\t\t\tv.push_back(make_pair(now,1));\n\t\t\t\t\t\tv.push_back(make_pair(now+1,1));\n\t\t\t\t\t}\n\t\t\t\t\tv.push_back(make_pair(now+1,0));\n\t\t\t\t\tnow++;\n\t\t\t\t}else{\n\t\t\t\t\twhile(now>1+ret[i].first){\n\t\t\t\t\t\tnow--;\n\t\t\t\t\t\tv.push_back(make_pair(now,0));\n\t\t\t\t\t}\n\t\t\t\t\tif(ret[i].second){\n\t\t\t\t\t\tv.push_back(make_pair(now,1));\n\t\t\t\t\t\tv.push_back(make_pair(now-1,1));\n\t\t\t\t\t}\n\t\t\t\t\tv.push_back(make_pair(now-1,0));\n\t\t\t\t\tnow--;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(now>0){\n\t\t\t\tnow--;\n\t\t\t\tv.push_back(make_pair(now,0));\n\t\t\t}\n\t}\n}\nint main_(){\n\t// int a=3;\n\t// n=a;\n\tint a;scanf(\"%d\",&a);\n\tn=a;\n\tscanf(\"%s\",in);\n\tv.clear();\n\tcm.clear();\n\tfor(int i=0;i<310;i++)dp[i]=0;\n\tfor(int i=0;i<(1<<a);i++){\n\t\tif(in[i]=='1'){\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(i&(1<<j)){\n\t\t\t\t\tif(in[i-(1<<j)]=='0'){\n\t\t\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"Possible\\n\");\n\tif(in[(1<<a)-1]=='1'){\n\t\tprintf(\"0\\n\");\n\t\tprintf(\"0 0\\n\");\n\t\treturn 0;\n\t}\n\tv.push_back(make_pair(0,0));\n\tf((1<<a)-1);\n\t// int now=0;\t\n\t// for(int i=0;i<cm.size();i++){\n\t// \tif(now<=cm[i].first){\n\t// \t\twhile(now<cm[i].first){\n\t// \t\t\tnow++;\n\t// \t\t\tv.push_back(make_pair(now,0));\n\t// \t\t}\n\t// \t\tif(cm[i].second){\n\t// \t\t\tv.push_back(make_pair(now,1));\n\t// \t\t\tv.push_back(make_pair(now+1,1));\n\t// \t\t}\n\t// \t\tv.push_back(make_pair(now+1,0));\n\t// \t\tnow++;\n\t// \t}else{\n\t// \t\twhile(now>1+cm[i].first){\n\t// \t\t\tnow--;\n\t// \t\t\tv.push_back(make_pair(now,0));\n\t// \t\t}\n\t// \t\tif(cm[i].second){\n\t// \t\t\tv.push_back(make_pair(now,1));\n\t// \t\t\tv.push_back(make_pair(now-1,1));\n\t// \t\t}\n\t// \t\tv.push_back(make_pair(now-1,0));\n\t// \t\tnow--;\n\t// \t}\n\t// }\n\t// while(now>0){\n\t// \tnow--;\n\t// \tv.push_back(make_pair(now,0));\n\t// }\n\tif(v.size()>=250000)while(1);\n\tprintf(\"%d\\n\",(int)(v.size())-1);\n\tfor(int i=0;i<v.size();i++){\n\t\tprintf(\"%d %d\\n\",v[i].first,v[i].second);\n\t}\n\tfor(int i=0;i+1<v.size();i++){\n\t\tassert(ABS(v[i].first-v[i+1].first)+ABS(v[i].second-v[i+1].second)==1);\n\t}\n\tfor(int i=0;i<(1<<a);i++){\n\t\tstack<pair<int,int> > S;\n\t\tfor(int j=0;j+1<v.size();j++){\n\t\t\tif(v[j].first==v[j+1].first)continue;\n\n\t\t\tint x=min(v[j].first,v[j+1].first);\n\t\t\tint y=v[j].second;\n\t\t\tif(!(i&(1<<x)))continue;\n\t\t\tif(S.size()&&S.top()==make_pair(x,y)){\n\t\t\t\tS.pop();\n\t\t\t}else S.push(make_pair(x,y));\n\t\t}\n\t\tif(S.size()==0&&in[i]=='0'){\n\t\t\tprintf(\"NG %d\\n\",i);\n\t\t}else if(S.size()&&in[i]=='1'){\n\t\t\tprintf(\"NG %d\\n\",i);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tmain_();\n\t// for(int i=0;i<256;i++){\n\t// \tif(i%2==0)continue;\n\t// \tfor(int j=0;j<8;j++){\n\t// \t\tif(i&(1<<j))in[j]='1';\n\t// \t\telse in[j]='0';\n\t// \t}\n\t// \tprintf(\"%d:\\n\",i);\n\t// \tmain_();\n\t// }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\nCode for problem E by cookiedoth\nGenerated 21 Mar 2020 at 05.19 PM\n\n\n______▄███████▄_______\n______█▄█████▄█_______\n______█▼▼▼▼▼█_______\n_____██________ ██______\n______█▲▲▲▲▲█_______\n______█████████_______\n_______██____ ██________\n\n>_<\no_O\n^_^\n\n*/\n\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <ctime>\n#include <functional>\n#include <unordered_set>\n#include <unordered_map>\n#include <string>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <complex>\n#include <cassert>\n#include <random>\n#include <cstring>\n#include <numeric>\n#define ll long long\n#define ld long double\n#define null NULL\n#define all(a) a.begin(), a.end()\n#define rall(a) a.rbegin(), a.rend()\n#define debug(a) cerr << #a << \" = \" << a << endl\n#define forn(i, n) for (int i = 0; i < n; ++i)\n#define sz(a) (int)a.size()\n\nusing namespace std;\n\ntemplate<class T> int chkmax(T &a, T b) {\n\tif (b > a) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\ntemplate<class T> int chkmin(T &a, T b) {\n\tif (b < a) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\ntemplate<class iterator> void output(iterator begin, iterator end, ostream& out = cerr) {\n\twhile (begin != end) {\n\t\tout << (*begin) << \" \";\n\t\tbegin++;\n\t}\n\tout << endl;\n}\n\ntemplate<class T> void output(T x, ostream& out = cerr) {\n\toutput(x.begin(), x.end(), out);\n}\n\nvoid fast_io() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n}\n\nint x;\nvector<pair<int, int> > ans;\n\nvoid move(int dest_x) {\n\tif (x == dest_x) {\n\t\treturn;\n\t}\n\tif (dest_x > x) {\n\t\tx++;\n\t\tans.emplace_back(x, 0);\n\t} else {\n\t\tx--;\n\t\tans.emplace_back(x, 0);\n\t}\n\tmove(dest_x);\n}\n\nvoid use(int pos, int d) {\n\t// cerr << \"use \" << pos << \" \" << d << endl;\n\tif (d == 0) {\n\t\tmove(pos);\n\t\tans.emplace_back(pos, 1);\n\t\tans.emplace_back(pos + 1, 1);\n\t\tans.emplace_back(pos + 1, 0);\n\t\tx++;\n\t} else {\n\t\tmove(pos + 1);\n\t\tans.emplace_back(pos, 1);\n\t\tans.emplace_back(pos - 1, 1);\n\t\tans.emplace_back(pos - 1, 0);\n\t\tx--;\n\t}\n}\n\nconst int mx = 300;\nint n, a[mx];\n\nvector<vector<pair<int, int> > > str;\n\nvoid gen_str() {\n\tstr.resize(n + 1);\n\tstr[1] = {{0, 0}};\n\tfor (int i = 2; i <= n; ++i) {\n\t\tstr[i].emplace_back(i - 1, 0);\n\t\tfor (auto pp : str[i - 1]) {\n\t\t\tstr[i].push_back(pp);\n\t\t}\n\t\tstr[i].emplace_back(i - 1, i);\n\t\tfor (auto pp : str[i - 1]) {\n\t\t\tstr[i].emplace_back(pp.first, pp.second ^ 1);\n\t\t}\n\t}\n}\n\nvoid make(int sub) {\n\tvector<int> have;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif ((sub >> i) & 1) {\n\t\t\thave.push_back(i);\n\t\t}\n\t}\n\tint k = __builtin_popcount(sub);\n\tfor (auto pp : str[k]) {\n\t\tuse(have[pp.first], pp.second);\n\t}\n}\n\nsigned main() {\n\tfast_io();\n\tans.emplace_back(0, 0);\n\tcin >> n;\n\tgen_str();\n\tfor (int i = 0; i < (1 << n); ++i) {\n\t\tchar c;\n\t\tcin >> c;\n\t\ta[i] = c - '0';\n\t}\n\tfor (int i = 0; i < (1 << n); ++i) {\n\t\tfor (int j = 0; j < i; ++j) {\n\t\t\tif (a[i] == 1 && ((i & j) == j) && a[j] == 0) {\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < (1 << n); ++i) {\n\t\tif (a[i] == 0) {\n\t\t\tint ok = 1;\n\t\t\tfor (int j = 0; j < i; ++j) {\n\t\t\t\tif (a[j] == 0 && (i & j) == j) {\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tmake(i);\n\t\t\t}\n\t\t}\n\t}\n\tmove(0);\n\tcout << \"Possible\" << \"\\n\";\n\tcout << ans.size() << \"\\n\";\n\tfor (auto pp : ans) {\n\t\tcout << pp.first << \" \" << pp.second << \"\\n\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define fr first\n#define sc second\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n\nvector<P> ret;\n\nvoid pos(int i){\n\tfor(int j=0;j<i;j++){\n\t\tret.push_back(P(j+1,0));\n\t}\n\tret.push_back(P(i,1));\n\tret.push_back(P(i+1,1));\n\tret.push_back(P(i+1,0));\n\tret.push_back(P(i,0));\n\tfor(int j=i-1;j>=0;j--){\n\t\tret.push_back(P(j,0));\n\t}\n}\nvoid neg(int i){\n\tfor(int j=0;j<i;j++){\n\t\tret.push_back(P(j+1,0));\n\t}\n\tret.push_back(P(i+1,0));\n\tret.push_back(P(i+1,1));\n\tret.push_back(P(i,1));\n\tret.push_back(P(i,0));\n\tfor(int j=i-1;j>=0;j--){\n\t\tret.push_back(P(j,0));\n\t}\n}\n\nvector<P> f(vector<P> vec,int t){\n\tint cnt[300]={};\n\tfor(int i=0;i<vec.size();i++){\n\t\tcnt[vec[i].sc]++;\n\t}\n\tint MIN=100;\n\tint id=-1;\n\tfor(int i=0;i<300;i++){\n\t\tif(cnt[i]==0)continue;\n\t\tif(MIN>cnt[i]){\n\t\t\tMIN=cnt[i];\n\t\t\tid=i;\n\t\t}\n\t}\n\t//cerr<<\"id=\"<<id<<endl;\n\tvector<P> ret;\n\tfor(int i=0;i<vec.size();i++){\n\t\tif(vec[i].sc!=id)ret.push_back(vec[i]);\n\t\telse {\n\t\t\tif(vec[i].fr==1){\n\t\t\t\tret.push_back(P(1,id));\n\t\t\t\tret.push_back(P(1,t));\n\t\t\t\tret.push_back(P(-1,id));\n\t\t\t\tret.push_back(P(-1,t));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret.push_back(P(1,t));\n\t\t\t\tret.push_back(P(1,id));\n\t\t\t\tret.push_back(P(-1,t));\n\t\t\t\tret.push_back(P(-1,id));\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\t\n\nint main(){\n\tint n;\n\tstring s;\n\tcin>>n>>s;\n\t\n\tint a[300];\n\tfor(int i=0;i<(1<<n);i++)a[i]=s[i]-'0';\n\t\n\tbool used[300];\n\tmemset(used,0,sizeof used);\n\t\n\tint b[300];\n\tfor(int i=0;i<300;i++)b[i]=1;\n\t\n\tfor(int x=1;x<(1<<n);x++){\n\t\tused[x]=true;\n\t\t//if(used[x])cerr<<x<<endl;\n\t\tfor(int y=0;y<x;y++){\n\t\t\tif((x&y)==y)if(used[y])used[x]=false;\n\t\t}\n\t\t//if(used[x])cerr<<x<<endl;\n\t\tfor(int y=0;y<(1<<n);y++){\n\t\t\tif((x&y)==x)if(a[y]==1)used[x]=false;\n\t\t}\n\t\t//if(used[x])cerr<<x<<endl;\n\t\tif(used[x]){\n\t\t\tfor(int y=0;y<(1<<n);y++){\n\t\t\t\tif((x&y)==x)b[y]=0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool ok=true;\n\tfor(int i=0;i<(1<<n);i++)ok&=a[i]==b[i];\n\tif(!ok){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tvector<P> vv;\n\tfor(int x=0;x<(1<<n);x++){\n\t\tif(!used[x])continue;\n\t\tif(vv.size()==0){\n\t\t\t//puts(\"DEBUG0\");\n\t\t\tvv.push_back(P(1,x));\n\t\t}\n\t\telse{\n\t\t\t//puts(\"DEBUG1\");\n\t\t\tvv=f(vv,x);\n\t\t}\n\t\t//cerr<<x<<endl;\n\t\t//cerr<<vv.size()<<endl;\n\t}\n\t/*for(int i=0;i<vv.size();i++){\n\t\tcout<<vv[i].fr<<\" \"<<vv[i].sc<<endl;\n\t}*/\n\tvector<P> vec[300];\n\tret.push_back(P(0,0));\n\tfor(int x=0;x<(1<<n);x++){\n\t\tif(!used[x])continue;\n\t\tint cnt=0;\n\t\tint c[10];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif((x>>i)&1)c[cnt++]=i;\n\t\t}\n\t\t\n\t\t//vector<P> vec;\n\t\tvec[x].push_back(P(1,c[0]));\n\t\tfor(int i=1;i<cnt;i++)vec[x]=f(vec[x],c[i]);\n\t\t/*for(int i=0;i<vec.size();i++){\n\t\t\tif(vec[i].fr==1)pos(vec[i].sc);\n\t\t\telse neg(vec[i].sc);\n\t\t}*/\n\t\t\n\t\t/*if(cnt==1){\n\t\t\tpos(c[0]);\n\t\t}\n\t\telse if(cnt==2){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[1]);\n\t\t}\n\t\telse if(cnt==3){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[2]);\n\t\t}\n\t\telse if(cnt==4){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tneg(c[3]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[3]);\n\t\t\tpos(c[2]);\n\t\t\tneg(c[3]);\n\t\t\tneg(c[2]);\n\t\t}\n\t\telse if(cnt==5){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[1]);\n\t\t\tpos(c[4]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[4]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tneg(c[3]);\n\t\t\tpos(c[0]);\n\t\t\tpos(c[4]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[4]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tpos(c[2]);\n\t\t}\n\t\telse if(cnt==6){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[1]);\n\t\t\tpos(c[4]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[4]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tneg(c[3]);\n\t\t\tpos(c[0]);\n\t\t\tpos(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[4]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[4]);\n\t\t\tneg(c[1]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tpos(c[2]);\n\t\t}\n\t\telse if(cnt==7){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[1]);\n\t\t\tpos(c[6]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[6]);\n\t\t\tpos(c[4]);\n\t\t\tpos(c[6]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[4]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tneg(c[3]);\n\t\t\tpos(c[0]);\n\t\t\tpos(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[4]);\n\t\t\tpos(c[1]);\n\t\t\tpos(c[6]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[4]);\n\t\t\tpos(c[6]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[1]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tpos(c[2]);\n\t\t}\n\t\telse if(cnt==7){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[1]);\n\t\t\tpos(c[6]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[6]);\n\t\t\tpos(c[4]);\n\t\t\tpos(c[7]);\n\t\t\tneg(c[4]);\n\t\t\tneg(c[7]);\n\t\t\tpos(c[6]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[1]);\n\t\t\tpos(c[7]);\n\t\t\tpos(c[4]);\n\t\t\tneg(c[7]);\n\t\t\tneg(c[4]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tneg(c[3]);\n\t\t\tpos(c[0]);\n\t\t\tpos(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[4]);\n\t\t\tpos(c[7]);\n\t\t\tneg(c[4]);\n\t\t\tneg(c[7]);\n\t\t\tpos(c[1]);\n\t\t\tpos(c[6]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[6]);\n\t\t\tpos(c[7]);\n\t\t\tpos(c[4]);\n\t\t\tneg(c[7]);\n\t\t\tneg(c[4]);\n\t\t\tpos(c[6]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[1]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tpos(c[2]);\n\t\t}*/\n\t}\n\t\n\t/*for(int i=0;i<n;i++){\n\t\tif(used[i][i]){\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t}\n\t\t\tret.push_back(P(i,1));\n\t\t\tret.push_back(P(i+1,1));\n\t\t\tret.push_back(P(i+1,0));\n\t\t\tret.push_back(P(i,0));\n\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\tret.push_back(P(j,0));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int k=i+1;k<n;k++){\n\t\t\tif(used[i][k]){\n\t\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(i,1));\n\t\t\t\tret.push_back(P(i+1,1));\n\t\t\t\tret.push_back(P(i+1,0));\n\t\t\t\tret.push_back(P(i,0));\n\t\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(k,1));\n\t\t\t\tret.push_back(P(k+1,1));\n\t\t\t\tret.push_back(P(k+1,0));\n\t\t\t\tret.push_back(P(k,0));\n\t\t\t\tfor(int j=k-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(i+1,0));\n\t\t\t\tret.push_back(P(i+1,1));\n\t\t\t\tret.push_back(P(i,1));\n\t\t\t\tret.push_back(P(i,0));\n\t\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(k+1,0));\n\t\t\t\tret.push_back(P(k+1,1));\n\t\t\t\tret.push_back(P(k,1));\n\t\t\t\tret.push_back(P(k,0));\n\t\t\t\tfor(int j=k-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}*/\n\t\n\tfor(int i=0;i<vv.size();i++){\n\t\tif(vv[i].fr==1){\n\t\t\tfor(P p: vec[vv[i].sc]){\n\t\t\t\tif(p.fr==1)pos(p.sc);\n\t\t\t\telse neg(p.sc);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor(int j=vec[vv[i].sc].size()-1;j>=0;j--){\n\t\t\t\tP p=vec[vv[i].sc][j];\n\t\t\t\tif(p.fr==1)neg(p.sc);\n\t\t\t\telse pos(p.sc);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tassert(ret.size()<=250000);\n\t\n\tputs(\"Possible\");\n\tprintf(\"%d\\n\",(int)(ret.size())-1);\n\tfor(int i=0;i<ret.size();i++){\n\t\tprintf(\"%d %d\\n\",ret[i].fr,ret[i].sc);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define eb(x,y) emplace_back(x,y)\n#define fi first\n#define se second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\n//inline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\ninline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}\nint n;char s[1<<10];vector<pint>ans;\ninline string rev(string a){reverse(a.begin(),a.end());return a;}\ninline void Solve(int sta){\n\tint cnt=0;for(int i=0;i<n;i++)cnt+=sta>>i&1;\n\tif(cnt==1){\n\t\tint t=0;for(;t<n;t++)if(sta>>t&1)break;\n\t\tRep(i,1,t)ans.eb(i,0);ans.eb(t,1),ans.eb(t+1,1),ans.eb(t+1,0);\n\t\tRed(i,t,0)ans.eb(i,0);\n\t\treturn;\n\t}\n\tstring S;S.clear();int i=0;\n\tfor(;i<n;i++)if(sta>>i&1)break;S.pb(i+'a'),S.pb(i+'A');\n\tfor(i++;i<n;i++)if(sta>>i&1)S=(char)('a'+i)+S+(char)('a'+i)+(char)('A'+i)+rev(S)+(char)('A'+i);\n\tint now=0;\n\tfor(auto o:S){\n\t\tint opt,p,d;\n\t\tif(isupper(o))opt=1,p=o-'A';else opt=0,p=o-'a';\n\t\tif(now<=p){d=0;Rep(i,now+1,p)ans.eb(i,0);}\n\t\telse{d=1;Red(i,now-1,p+1)ans.eb(i,0);}\n\t\tif(d&&opt)ans.eb(p,0),now=p;\n\t\telse if(d&&!opt)ans.eb(p+1,1),ans.eb(p,1),ans.eb(p,0),now=p;\n\t\telse if(!d&&opt)ans.eb(p+1,0),now=p+1;\n\t\telse if(!d&&!opt)ans.eb(p,1),ans.eb(p+1,1),ans.eb(p+1,0),now=p+1;\n\t}Red(i,now-1,0)ans.eb(i,0);\n}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),scanf(\"%s\",s);\n\tif(s[0]=='0')return puts(\"Impossible\"),0;\n\tfor(int i=0;i<1<<n;i++){\n\t\tif(s[i]=='1'){\n\t\t\tfor(int j=0;j<n;j++)if(i>>j&1)\n\t\t\t\tif(s[i^(1<<j)]=='0')return puts(\"Impossible\"),0;\n\t\t}else{\n\t\t\tfor(int j=0;j<n;j++)if(!(i>>j&1))\n\t\t\t\tif(s[i^(1<<j)]=='1')return puts(\"Impossible\"),0;\n\t\t}\n\t}\n\tans.eb(0,0);\n\tfor(int i=0;i<1<<n;i++)if(s[i]=='0'){\n\t\tbool flg=1;\n\t\tfor(int j=0;j<n;j++)if((i>>j&1)&&s[i^(1<<j)]=='0')flg=0;\n\t\tif(flg)Solve(i);\n\t}puts(\"Possible\");cout<<ans.size()-1<<'\\n';\n\tfor(auto o:ans)cout<<o.fi<<' '<<o.se<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#define NO return !printf(\"Impossible\\n\")\n#define N 433\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint n,a[N];\nchar s[N];\nvector<pair<int,int> > ans;\nstring Rev(string s){\n\treverse(s.begin(),s.end());\n\tfor(auto &c:s){\n\t\tif(c>='a'&&c<='z')c+='A'-'a';\n\t\telse c+='a'-'A';\n\t}\n\treturn s;\n}\nint main(){\n\tn=read();\n\tscanf(\"%s\",s);\n\tfor(int i=0;i<(1<<n);++i){\n\t\ta[i]=s[i]-'0';\n\t}\n\tif(!a[0])NO;\n\tfor(int i=0;i<(1<<n);++i){\n\t\tif(a[i]){\n\t\t\tfor(int j=(i-1)&i;j;j=(j-1)&i){\n\t\t\t\tif(!a[j])NO;\n\t\t\t}\n\t\t}\n\t}\n\tans.emplace_back(0,0);\n\tfor(int i=0;i<(1<<n);++i){\n\t\tif(a[i])continue;\n\t\tbool ok=true;\n\t\tfor(int j=(i-1)&i;j;j=(j-1)&i){\n\t\t\tif(!a[j]){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok)continue;\n\t\tstring myh;\n\t\tfor(int j=0;j<n;++j){\n\t\t\tif((i>>j)&1){\n\t\t\t\tif(myh.empty())myh=(char)('a'+j);\n\t\t\t\telse myh=(char)('a'+j)+myh+(char)('A'+j)+Rev(myh);\n\t\t\t}\n\t\t}\n\t\tint pos=0;\n\t\tfor(auto c:myh){\n\t\t\tint d=0,x=0;\n\t\t\tif(c>='a'&&c<='z'){\n\t\t\t\tx=c-'a',d=1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tx=c-'A',d=0;\n\t\t\t}\n\t\t\twhile(pos<x)ans.emplace_back(++pos,0);\n\t\t\twhile(pos>x)ans.emplace_back(--pos,0);\n\t\t\tif(d){\n\t\t\t\tans.emplace_back(x,1);\n\t\t\t\tans.emplace_back(x+1,1);\n\t\t\t\tans.emplace_back(x+1,0);\n\t\t\t\tans.emplace_back(x,0);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans.emplace_back(x+1,0);\n\t\t\t\tans.emplace_back(x+1,1);\n\t\t\t\tans.emplace_back(x,1);\n\t\t\t\tans.emplace_back(x,0);\n\t\t\t}\n\t\t}\n\t\twhile(pos>0)ans.emplace_back(--pos,0);\n\t}\n\tprintf(\"Possible\\n%d\\n\",(int)ans.size()-1);\n\tfor(auto x:ans){\n\t\tprintf(\"%d %d\\n\",x.first,x.second);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst char* IMPOSSIBLE = \"Impossible\";\nconst char* POSSIBLE = \"Possible\";\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint N; cin >> N;\n\tvector<bool> A(1<<N);\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tchar c; cin >> c;\n\t\tassert(c == '0' || c == '1');\n\t\tA[(1<<N)-1-m] = (c == '1');\n\t}\n\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\t// m2 is a superset\n\t\t\tif (A[m] > A[m | (1<<i)]) {\n\t\t\t\tcout << IMPOSSIBLE << '\\n';\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t}\n\tcout << POSSIBLE << '\\n';\n\tmt19937 mt(48);\n\tvector<int> minM;\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tif (!A[m]) continue;\n\t\tbool isMinimal = true;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif ((m & (1<<i)) && A[m ^ (1<<i)]) {\n\t\t\t\tisMinimal = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isMinimal) {\n\t\t\tminM.push_back(m);\n\t\t}\n\t}\n\tshuffle(minM.begin(), minM.end(), mt);\n\n\tqueue<vector<int>> q;\n\tfor (int m : minM) {\n\t\tvector<int> v;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (m & (1<<i)) {\n\t\t\t\tv.push_back(i+1);\n\t\t\t\tv.push_back(i+1);\n\t\t\t}\n\t\t}\n\t\tshuffle(v.begin(), v.end(), mt);\n\t\tq.push(v);\n\t}\n\n\twhile (q.size() >= 2) {\n\t\tvector<int> a = std::move(q.front()); q.pop();\n\t\tvector<int> b = std::move(q.front()); q.pop();\n\n\t\tvector<int> c;\n\t\tfor (int i : a) { c.push_back(i); }\n\t\tfor (int i : b) { c.push_back(i); }\n\t\treverse(a.begin(), a.end());\n\t\treverse(b.begin(), b.end());\n\t\tfor (int i : a) { c.push_back(-i); }\n\t\tfor (int i : b) { c.push_back(-i); }\n\t\tq.push(c);\n\t}\n\n\tvector<int> pattern;\n\tif (!q.empty()) {\n\t\tpattern = std::move(q.front()); q.pop();\n\t}\n\n\tvector<bool> patA(1<<N);\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tstack<int> st;\n\t\tfor (int i : pattern) {\n\t\t\tif (m & (1<<(abs(i)-1))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!st.empty() && st.top() == -i) {\n\t\t\t\tst.pop();\n\t\t\t} else {\n\t\t\t\tst.push(i);\n\t\t\t}\n\t\t}\n\t\tpatA[m] = st.empty();\n\t}\n\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tassert(patA[m] >= A[m]);\n\t}\n\n\tvector<pair<int, int>> pos;\n\tpos.emplace_back(0,1);\n\tauto goToPt = [&](int x) {\n\t\tassert(pos.back().second == 1);\n\t\tif (pos.back() == pair<int, int>(x,1)) {\n\t\t\treturn;\n\t\t}\n\t\tpos.emplace_back(pos.back().first, 0);\n\t\twhile (pos.back().first < x) {\n\t\t\tpos.emplace_back(pos.back().first+1, 0);\n\t\t}\n\t\twhile (pos.back().first > x) {\n\t\t\tpos.emplace_back(pos.back().first-1, 0);\n\t\t}\n\t\tpos.emplace_back(x,1);\n\t};\n\tfor (auto i : pattern) {\n\t\tassert(i != 0);\n\t\tif (i > 0) {\n\t\t\tgoToPt(i-1);\n\t\t\tpos.emplace_back(i, 1);\n\t\t} else {\n\t\t\tgoToPt(-i);\n\t\t\tpos.emplace_back(-i-1, 1);\n\t\t}\n\t}\n\n\tgoToPt(0);\n\n\tif (int(pos.size()) - 1 > 250000) {\n\t\twhile (true);\n\t}\n\tcout << pos.size()-1 << '\\n';\n\tfor (auto it : pos) {\n\t\tcout << it.first << ' ' << it.second << '\\n';\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n#define MOD @\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nint N;\nchar A[300];\nvector<pair<int, int>> ans;\n\n/*\nvoid draw_curve(int mask, bool flip = false)\n{\n\tvector<pair<int, int>> seq;\n\tseq.push_back({0, 0});\n\tfor (int i = 0; i < N; ++i) {\n\t\tpair<int, int> src = make_pair(i, (mask >> i) & 1);\n\t\tpair<int, int> dest = make_pair(i + 1, (mask >> i) & 1);\n\t\tif (seq.back() != src) seq.push_back(src);\n\t\tseq.push_back(dest);\n\t}\n\tif (seq.back().second == 1) seq.push_back({N, 0});\n\tfor (int i = N - 1; i >= 0; --i) seq.push_back({i, 0});\n\tif (flip) reverse(seq.begin(), seq.end());\n\tfor (int i = 1; i < seq.size(); ++i) ans.push_back(seq[i]);\n}\n*/\nvoid draw_curve(int p, bool flip = false)\n{\n\tvector<pair<int, int>> seq;\n\tfor (int i = 0; i <= p; ++i) seq.push_back({i, 0});\n\tseq.push_back({p, 1});\n\tseq.push_back({p + 1, 1});\n\tfor (int i = p + 1; i >= 0; --i) seq.push_back({i, 0});\n\tif (flip) reverse(seq.begin(), seq.end());\n\tfor (int i = 1; i < seq.size(); ++i) ans.push_back(seq[i]);\n}\n\nint main()\n{\n\tscanf(\"%d%s\", &N, A);\n\tfor (int i = 0; i < (1 << N); ++i) {\n\t\tif (A[i] == '0') {\n\t\t\tfor (int j = 0; j < N; ++j) if ((i & (1 << j)) == 0) {\n\t\t\t\tif (A[i | (1 << j)] == '1') {\n\t\t\t\t\tputs(\"Impossible\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (A[0] == '0') {\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tputs(\"Possible\");\n\tvector<int> minima;\n\tfor (int i = 0; i < (1 << N); ++i) {\n\t\tif (A[i] == '0') {\n\t\t\tbool flg = true;\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tif ((i & (1 << j)) != 0 && A[i ^ (1 << j)] == '0') flg = false;\n\t\t\t}\n\t\t\tif (flg) minima.push_back(i);\n\t\t}\n\t}\n\tans.push_back({0, 0});\n\tfor (int m : minima) {\n\t\tvector<int> bits;\n\t\tfor (int i = 0; i < N; ++i) if (m & (1 << i)) bits.push_back(i);\n\t\tvector<int> seq;\n\t\tseq.push_back(bits[0]);\n\t\tfor (int i = 1; i < bits.size(); ++i) {\n\t\t\tvector<int> seq2;\n\t\t\tseq2.push_back(bits[i]);\n\t\t\tfor (int j = 0; j < seq.size(); ++j) {\n\t\t\t\tseq2.push_back(seq[j]);\n\t\t\t}\n\t\t\tseq2.push_back(~bits[i]);\n\t\t\tfor (int j = seq.size() - 1; j >= 0; --j) {\n\t\t\t\tseq2.push_back(~seq[j]);\n\t\t\t}\n\t\t\tseq = seq2;\n\t\t}\n\t\tfor (int i = 0; i < seq.size(); ++i) {\n\t\t\t//if (seq[i] >= 0) printf(\"%d \", seq[i]);\n\t\t\t//else printf(\"!%d \", ~seq[i]);\n\t\t\tif (seq[i] >= 0) draw_curve(seq[i]);\n\t\t\telse draw_curve(~seq[i]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans.size() - 1);\n\tfor (auto p : ans) printf(\"%d %d\\n\", p.first, p.second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nint N;\nstring s;\n\nbool bad;\n\nvector <int> goal (int K, string cv)\n{\n    //cout << K << \" \" << cv << \"\\n\";\n    vector <int> ans;\n    if (K == 1)\n    {\n        if (cv[0] == '1')\n        {\n            if (cv[1] == '0')\n            {\n                ans.push_back(0);\n                ans.push_back(1);\n                return ans;\n            }\n            return ans;\n        }\n        if (cv[0] == '0')\n        {\n            if (cv[1] == '1')\n                bad = true;\n            // what?\n            return ans;\n        }\n    }\n\n    int cp = 1 << (K - 1);\n    for (int i = cp; i < 2 * cp; i++)\n    {\n        if (cv[i] > cv[i-cp])\n        {\n            bad = true;\n            return ans;\n        }\n    }\n\n    string rv = cv.substr(0, cp);\n    string lv = cv.substr(cp);\n    bool l0 = true;\n    for (int i = 0; i < cp; i++)\n    {\n        if (lv[i] == '1') l0 = false;\n    }\n\n    vector <int> rans = goal (K - 1, rv);\n\n    if (l0)\n    {\n        // throw the key\n        rans.push_back(K - 1);\n        rans.push_back(K);\n        return rans;\n    }\n    vector <int> lans = goal (K - 1, lv);\n    swap (rans, lans);\n\n    vector <int> god;\n    for (int i : rans)\n        god.push_back(i);\n    god.push_back(K);\n    god.push_back(K-1);\n    reverse (rans.begin(), rans.end());\n    for (int i : rans)\n        god.push_back(i);\n    god.push_back(K-1);\n    god.push_back(K);\n    for (int i : lans)\n        god.push_back(i);\n    return god;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n\n    cin >> N >> s;\n\n    bad = false;\n    vector <int> res = goal (N, s);\n    if (bad || s[0] == '0')\n    {\n        cout << \"Impossible\\n\";\n    }\n    else\n    {\n        cout << \"Possible\\n\";\n        if (!res.size())\n        {\n            cout << \"0\\n\";\n            cout << \"1 1\\n\";\n            return 0;\n        }\n        /*for (int i : res) cout << i;\n        cout << \"\\n\";*/\n        res.push_back(res[0]);\n\n        int ctot = 0;\n        for (int i = 0; i + 1 < res.size(); i++)\n        {\n            ctot += abs (res[i+1] - res[i]) + 1;\n        }\n\n        cout << ctot << \"\\n\";\n        for (int i = 0; i + 1 < res.size(); i++)\n        {\n            int cv = i % 2;\n            int nv = 1 - cv;\n            cout << res[i] << \" \" << cv << \"\\n\";\n            for (int j = res[i]; j < res[i+1]; j++)\n                cout << j << \" \" << nv << \"\\n\";\n            for (int j = res[i]; j > res[i+1]; j--)\n                cout << j << \" \" << nv << \"\\n\";\n        }\n        cout << res[0] << \" \" << 0 << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint N; char str[1 << 8];\nvector < int > pot;\nvector < int > operator +(vector < int > p , vector < int > q){p.insert(p.end() , q.begin() , q.end()); return p;}\n\nvector < int > build(int id , int x){\n\tif(id < (1 << (x + 1))) return vector < int > {x + 1 , -x - 1};\n\tvector < int > tmp = build(id , x + 1);\n\tif(!(id >> x & 1)) return vector < int >{x + 1} + tmp + vector < int >{x + 1};\n\tvector < int > rev = tmp; reverse(rev.begin() , rev.end());\n\treturn vector < int >{x + 1} + tmp + vector < int >{x + 1} + vector < int >{-x - 1} + tmp + vector < int >{-x - 1};\n}\n\nint main(){\n\tscanf(\"%d %s\" , &N , str);\n\tfor(int i = 0 ; i < 1 << N ; ++i)\n\t\tif(str[i] == '1')\n\t\t\tfor(int j = 0 ; j < N ; ++j)\n\t\t\t\tif((i >> j & 1) && str[i ^ (1 << j)] != '1'){\n\t\t\t\t\tputs(\"Impossible\"); return 0;\n\t\t\t\t}\n\tfor(int i = 0 ; i < 1 << N ; ++i)\n\t\tif(str[i] == '0'){\n\t\t\tbool flg = 1;\n\t\t\tfor(int j = 0 ; j < N ; ++j)\n\t\t\t\tif((i >> j & 1) && str[i ^ (1 << j)] == '0')\n\t\t\t\t\tflg = 0;\n\t\t\tif(flg) pot = pot + build(i , 0);\n\t\t}\n\tputs(\"Possible\"); vector < pair < int , int > > node;\n\tint curx = 0 , cury = 0; node.push_back(make_pair(0 , 0));\n\tfor(int i = 0 ; i < pot.size() ; ++i){\n\t\tif(pot[i] < 0 && cury == 1) node.push_back(make_pair(curx , cury = 0));\n\t\tif(pot[i] > 0 && cury == 0) node.push_back(make_pair(curx , cury = 1));\n\t\tint t = abs(pot[i]) - 1;\n\t\tif(curx == t) node.push_back(make_pair(++curx , cury));\n\t\telse node.push_back(make_pair(--curx , cury));\n\t}\n\tif(cury) node.push_back(make_pair(0 , 0));\n\tprintf(\"%d\\n\" , node.size() - 1);\n\tfor(auto t : node) printf(\"%d %d\\n\" , t.first , t.second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i = (begin); i < (end); i++)\n#define rep(i, n) FOR(i, 0, n)\nusing ll = long long;\nusing namespace std;\n#define all(x) (x).begin(),(x).end()\nusing pii = pair<int, int>; using vi = vector<int>; using vl = vector<ll>;\n\nint N;\nbool isSubsetOf(int i, int oo) {\n    return (oo | i) == oo;\n}\n\nsigned main() {\n    cin >> N;\n    // unordered_set<int> oo, ii;\n    int oo(0), ii(0);\n    vi sss;\n    string as;\n    cin >> as;\n    rep(i, 1<<N) {\n        // auto ss = setter(i);\n        if(as[i] == '1') {\n            oo |= i;\n        }\n    }\n    rep(i, 1<<N) {\n        if(isSubsetOf(i, oo) && as[i] == '0') {\n            cout << \"Impossible\" << endl;\n            return 0;\n        } else if(!isSubsetOf(i, oo) && as[i] == '1') {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n    \n    cout << \"Possible\" << endl;\n\n    ii = (1<<N) - oo - 1;\n    // cerr << oo << ' ' << ii << endl;\n    // cerr << (oo & ii) << endl;\n    vector<pii> p;\n    int before = 0;\n    // cerr << ii << endl;\n    p.push_back({0, 0});\n    rep(i, N) {\n        // cerr << ii << endl;\n        // cerr << ((ii&1) ^ before) << endl;\n        if((ii&1) ^ before) {\n            if(ii&1) {\n                if(i!=0) {\n                    p.push_back({i, 0});\n                }\n                p.push_back({i, 1});\n            } else {\n                p.push_back({i, 1});\n                if(i!=N-1)\n                    p.push_back({i, 0});\n            }\n        } else {\n            if(i!=0)\n                p.push_back({i, before});\n        }\n        before = ii & 1;\n        ii >>= 1;\n    }\n    if (before)\n        p.push_back({N, 1});\n    for(int k = N; k>=0; k--) {\n        p.push_back({k, 0});\n    }\n\n    cout << p.size() - 1 << endl;\n    for(auto pp : p) {\n        cout << pp.first << ' ' << pp.second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n;\n    string a;\n    cin >> n >> a;\n    vector<int> b;\n    for(int i = 0; i < 1 << n; i++) {\n        int x = 0;\n        for(int &k : b) {\n            if(a[i] == '1' && (k & i) == k) {\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n            if((k & i) == k)\n                x = 1;\n        }\n        if(a[i] == '0' && !x)\n            b.push_back(i);\n    }\n    cout << \"Possible\\n\";\n    stringstream ss;\n    int l = 0;\n    for(int k : b) {\n        int j = 0, u = 0;\n        for(int i = 0; i < 10; i++) {\n            if(!(k & 1 << i))\n                continue;\n            u++;\n            for(; j <= i; j++)\n                ss << j << \" 0\\n\", l++;\n            ss << i << \" 1\\n\" << i + 1 << \" 1\\n\" << i + 1 << \" 0\\n\", l += 3;\n            j = i;\n        }\n        if(u > 1) {\n            if(j)\n                for(; j >= 1; j--)\n                    ss << j << \" 0\\n\", l++;\n            j = 0;\n            for(int i = 0; i < 10; i++) {\n                if(!(k & 1 << i))\n                    continue;\n                for(; j <= i; j++)\n                    ss << j << \" 0\\n\", l++;\n                ss << i + 1 << \" 0\\n\" << i + 1 << \" 1\\n\" << i << \" 1\\n\", l += 3;\n                j = i;\n            }\n        }\n        if(j)\n            for(; j >= 1; j--)\n                ss << j << \" 0\\n\", l++;\n    }\n    ss << \"0 0\\n\";\n    cout << l << '\\n' << ss.str() << flush;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#include <algorithm>\n#include <cstddef>\n#include <cstdint>\n#include <iostream>\n#include <utility>\n#include <vector>\n\nnamespace n91 {\n\n  using i8 = std::int_fast8_t;\n  using i32 = std::int_fast32_t;\n  using i64 = std::int_fast64_t;\n  using u8 = std::uint_fast8_t;\n  using u32 = std::uint_fast32_t;\n  using u64 = std::uint_fast64_t;\n  using isize = std::ptrdiff_t;\n  using usize = std::size_t;\n\n  struct rep {\n    struct itr {\n      usize i;\n      constexpr itr(const usize i) noexcept : i(i) {}\n      void operator++() noexcept { ++i; }\n      constexpr usize operator*() const noexcept { return i; }\n      constexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n    };\n    const itr f, l;\n    constexpr rep(const usize f, const usize l) noexcept\n      : f(std::min(f, l)), l(l) {}\n    constexpr auto begin() const noexcept { return f; }\n    constexpr auto end() const noexcept { return l; }\n  };\n  struct revrep {\n    struct itr {\n      usize i;\n      constexpr itr(const usize i) noexcept : i(i) {}\n      void operator++() noexcept { --i; }\n      constexpr usize operator*() const noexcept { return i; }\n      constexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n    };\n    const itr f, l;\n    constexpr revrep(const usize f, const usize l) noexcept\n      : f(l - 1), l(std::min(f, l) - 1) {}\n    constexpr auto begin() const noexcept { return f; }\n    constexpr auto end() const noexcept { return l; }\n  };\n  template <class T> auto md_vec(const usize n, const T& value) {\n    return std::vector<T>(n, value);\n  }\n  template <class... Args> auto md_vec(const usize n, Args... args) {\n    return std::vector<decltype(md_vec(args...))>(n, md_vec(args...));\n  }\n  template <class T> constexpr T difference(const T& a, const T& b) noexcept {\n    return a < b ? b - a : a - b;\n  }\n  template <class T> void chmin(T& a, const T& b) noexcept {\n    if (b < a)\n      a = b;\n  }\n  template <class T> void chmax(T& a, const T& b) noexcept {\n    if (a < b)\n      a = b;\n  }\n  template <class F> class rec_lambda {\n    F f;\n\n  public:\n    rec_lambda(F&& f) : f(std::move(f)) {}\n    template <class... Args> auto operator()(Args&&... args) const {\n      return f(*this, std::forward<Args>(args)...);\n    }\n  };\n  template <class F> auto make_rec(F&& f) { return rec_lambda<F>(std::move(f)); }\n  template <class T> T scan() {\n    T ret;\n    std::cin >> ret;\n    return ret;\n  }\n\n} // namespace n91\n\nnamespace n91 {\n\n  void main_() {\n    //*\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    //*/\n    const usize n = scan<usize>();\n    std::vector<bool> a(1 << n);\n    for (const usize i : rep(0, 1 << n)) {\n      a[i] = scan<char>() == '1';\n    }\n    std::vector<bool> s_ng(n, false);\n    auto d_ng = md_vec(n, n, false);\n    {\n      std::vector<bool> temp(1 << n, true);\n      for (const usize i : rep(0, n)) {\n        if (!a[1 << i]) {\n          s_ng[i] = true;\n          temp[1 << i] = false;\n        }\n      }\n      for (const usize i : rep(0, n)) {\n        for (const usize j : rep(0, i)) {\n          if (!a[1 << i | 1 << j]) {\n            d_ng[i][j] = true;\n            d_ng[j][i] = true;\n            temp[1 << i | 1 << j] = false;\n          }\n        }\n      }\n      for (const usize i : rep(0, 1 << n)) {\n        usize s = i;\n        while (true) {\n          if (!temp[s])\n            temp[i] = false;\n          if (s == 0)\n            break;\n          s -= 1;\n          s &= i;\n        }\n      }\n      if (a != temp) {\n        std::cout << \"Impossible\" << std::endl;\n        return;\n      }\n      std::cout << \"Possible\\n\";\n    }\n    usize curx = 0;\n    usize cury = 0;\n    std::vector<std::pair<usize, usize>> ans;\n    const auto print = [&]() { ans.emplace_back(curx, cury); };\n    const auto movex = [&](const usize x) {\n      while (curx < x) {\n        print();\n        curx += 1;\n      }\n      while (x < curx) {\n        print();\n        curx -= 1;\n      }\n    };\n    const auto movey = [&](const usize y) {\n      while (cury < y) {\n        print();\n        cury += 1;\n      }\n      while (y < cury) {\n        print();\n        cury -= 1;\n      }\n    };\n    const auto stack = [&](const usize i, bool izryt) {\n      if (!izryt) {\n        movex(i);\n        movey(1);\n        movex(i + 1);\n        movey(0);\n      }\n      else {\n        movex(i + 1);\n        movey(1);\n        movex(i);\n        movey(0);\n      }\n    };\n    for (const usize i : rep(0, n)) {\n      if (s_ng[i]) {\n        stack(i, 0);\n        continue;\n      }\n      std::vector<usize> ngs;\n      for (const usize j : rep(0, i)) {\n        if (d_ng[j][i]) {\n          ngs.push_back(j);\n        }\n      }\n      if (ngs.empty())\n        continue;\n      for (const auto e : ngs) {\n        stack(e, 0);\n      }\n      stack(i, 0);\n      std::reverse(ngs.begin(), ngs.end());\n      for (const auto e : ngs) {\n        stack(e, 1);\n      }\n      stack(i, 1);\n    }\n    movex(0);\n    std::cout << ans.size() << \"\\n\";\n    for (const auto& e : ans) {\n      std::cout << e.first << \" \" << e.second << \"\\n\";\n    }\n    std::cout << \"0 0\\n\";\n  }\n\n} // namespace n91\n\nint main() {\n  n91::main_();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#define NO return !printf(\"Impossible\\n\")\n#define N 433\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint n,a[N];\nchar s[N];\nvector<pair<int,int> > ans;\nstring Rev(string s){\n\treverse(s.begin(),s.end());\n\treturn s;\n}\nint main(){\n\tn=read();\n\tscanf(\"%s\",s);\n\tfor(int i=0;i<(1<<n);++i){\n\t\ta[i]=s[i]-'0';\n\t}\n\tif(!a[0])NO;\n\tfor(int i=0;i<(1<<n);++i){\n\t\tif(a[i]){\n\t\t\tfor(int j=(i-1)&i;j;j=(j-1)&i){\n\t\t\t\tif(!a[j])NO;\n\t\t\t}\n\t\t}\n\t}\n\tans.emplace_back(0,0);\n\tfor(int i=0;i<(1<<n);++i){\n\t\tif(a[i])continue;\n\t\tbool ok=true;\n\t\tfor(int j=(i-1)&i;j;j=(j-1)&i){\n\t\t\tif(!a[j]){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok)continue;\n\t\tstring myh;\n\t\tfor(int j=0;j<n;++j){\n\t\t\tif((i>>j)&1){\n\t\t\t\tif(myh.empty())myh=(char)('a'+j);\n\t\t\t\telse myh=(char)('a'+j)+myh+(char)('A'+j)+Rev(myh);\n\t\t\t}\n\t\t}\n\t\tint pos=0;\n\t\tfor(auto c:myh){\n\t\t\tint d=0,x=0;\n\t\t\tif(c>='a'&&c<='z'){\n\t\t\t\tx=c-'a',d=1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tx=c-'A',d=0;\n\t\t\t}\n\t\t\twhile(pos<x)ans.emplace_back(++pos,0);\n\t\t\twhile(pos>x)ans.emplace_back(--pos,0);\n\t\t\tif(d){\n\t\t\t\tans.emplace_back(x,1);\n\t\t\t\tans.emplace_back(x+1,1);\n\t\t\t\tans.emplace_back(x+1,0);\n\t\t\t\tans.emplace_back(x,0);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans.emplace_back(x+1,0);\n\t\t\t\tans.emplace_back(x+1,1);\n\t\t\t\tans.emplace_back(x,1);\n\t\t\t\tans.emplace_back(x,0);\n\t\t\t}\n\t\t}\n\t\twhile(pos>0)ans.emplace_back(--pos,0);\n\t}\n\tprintf(\"Possible\\n%d\\n\",(int)ans.size()-1);\n\tfor(auto x:ans){\n\t\tprintf(\"%d %d\\n\",x.first,x.second);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst char* IMPOSSIBLE = \"Impossible\";\nconst char* POSSIBLE = \"Possible\";\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint N; cin >> N;\n\tvector<bool> A(1<<N);\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tchar c; cin >> c;\n\t\tassert(c == '0' || c == '1');\n\t\tA[(1<<N)-1-m] = (c == '1');\n\t}\n\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\t// m2 is a superset\n\t\t\tif (A[m] > A[m | (1<<i)]) {\n\t\t\t\tcout << IMPOSSIBLE << '\\n';\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t}\n\tcout << POSSIBLE << '\\n';\n\tvector<int> minM;\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tif (!A[m]) continue;\n\t\tbool isMinimal = true;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif ((m & (1<<i)) && A[m ^ (1<<i)]) {\n\t\t\t\tisMinimal = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isMinimal) {\n\t\t\tminM.push_back(m);\n\t\t}\n\t}\n\n\tqueue<vector<int>> q;\n\tfor (int m : minM) {\n\t\tvector<int> v;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (m & (1<<i)) {\n\t\t\t\tv.push_back(i+1);\n\t\t\t}\n\t\t}\n\t\tq.push(v);\n\t}\n\n\twhile (q.size() >= 2) {\n\t\tvector<int> a = std::move(q.front()); q.pop();\n\t\tvector<int> b = std::move(q.front()); q.pop();\n\n\t\tvector<int> c;\n\t\tfor (int i : a) { c.push_back(i); }\n\t\tfor (int i : b) { c.push_back(i); }\n\t\treverse(a.begin(), a.end());\n\t\treverse(b.begin(), b.end());\n\t\tfor (int i : a) { c.push_back(-i); }\n\t\tfor (int i : b) { c.push_back(-i); }\n\t\tq.push(c);\n\t}\n\n\tvector<int> pattern;\n\tif (!q.empty()) {\n\t\tpattern = std::move(q.front()); q.pop();\n\t}\n\n\tvector<pair<int, int>> pos;\n\tpos.emplace_back(0,1);\n\tauto goToPt = [&](int x) {\n\t\tassert(pos.back().second == 1);\n\t\tif (pos.back() == pair<int, int>(x,1)) {\n\t\t\treturn;\n\t\t}\n\t\tpos.emplace_back(pos.back().first, 0);\n\t\twhile (pos.back().first < x) {\n\t\t\tpos.emplace_back(pos.back().first+1, 0);\n\t\t}\n\t\twhile (pos.back().first > x) {\n\t\t\tpos.emplace_back(pos.back().first-1, 0);\n\t\t}\n\t\tpos.emplace_back(x,1);\n\t};\n\tfor (auto i : pattern) {\n\t\tassert(i != 0);\n\t\tif (i > 0) {\n\t\t\tgoToPt(i-1);\n\t\t\tpos.emplace_back(i, 1);\n\t\t} else {\n\t\t\tgoToPt(-i);\n\t\t\tpos.emplace_back(-i-1, 1);\n\t\t}\n\t}\n\n\tgoToPt(0);\n\n\tcout << pos.size()-1 << '\\n';\n\tfor (auto it : pos) {\n\t\tcout << it.first << ' ' << it.second << '\\n';\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\n\nconst int mod = 1e9+7;\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nint n;\nchar s[256];\nchar revc(char c)\n{\n\tif (c>='a'&&c<='z') return 'A'+c-'a';\n\telse return 'a'+c-'A';\n}\nstring getf(int msk)\n{\n\tstring ret;\n\tif (__builtin_popcount(msk)==1)\n\t{\n\t\tret.PB(__builtin_ctz(msk)+'a');\n\t\treturn ret;\n\t}\n\telse\n\t{\n\t\tint x = __builtin_ctz(msk&(-msk));\n\t\tint nmsk = msk-(1<<x);\n\t\tstring t = getf(nmsk);\n\t\tret += t;\n\t\tret.PB('a'+x);\n\t\treverse(t.begin(), t.end());\n\t\tfor (int i=0; i<t.size(); i++) t[i] = revc(t[i]);\n\t\tret += t;\n\t\tret.PB('A'+x);\n\t\treturn ret;\n\t}\n}\nvector<pair<int,int> > rt;\nint curx, cury;\nvoid go(int x, int y)\n{\n\twhile (curx<x) curx++, rt.PB(MP(curx, cury));\n\twhile (curx>x) curx--, rt.PB(MP(curx, cury));\n\twhile (cury<y) cury++, rt.PB(MP(curx, cury));\n\twhile (cury>y) cury--, rt.PB(MP(curx, cury));\n}\nvoid out(string s)\n{\n\tassert(s.size()<250000);\n\tcurx = cury = 0;\n\trt.PB(MP(0, 0));\n\n\tfor (int i=0; i<s.size(); i++)\n\t{\n\t\tbool f;\n\t\tint x;\n\t\tif (s[i]>='a'&&s[i]<='z')\n\t\t{\n\t\t\tf = true;\n\t\t\tx = s[i]-'a';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tf = false;\n\t\t\tx = s[i]-'A';\n\t\t}\n\t\tif (f)\n\t\t{\n\t\t\tgo(x, 0);\n\t\t\tgo(x, 1);\n\t\t\tgo(x+1, 1);\n\t\t\tgo(x+1, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgo(x+1, 0);\n\t\t\tgo(x+1, 1);\n\t\t\tgo(x, 1);\n\t\t\tgo(x, 0);\n\t\t}\n\t}\n\tgo(0, 0);\n}\nint main()\n{\n\tcin>>n;\n\tcin>>s;\n\tfor (int i=0; i<(1<<n); i++)\n\t{\n\t\tif (s[i]=='1')\n\t\t{\n\t\t\tfor (int j=0; j<(1<<n); j++)\n\t\t\t{\n\t\t\t\tif ((i&j)==j&&s[j]=='0')\n\t\t\t\t{\n\t\t\t\t\tputs(\"Impossible\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tstring ans;\n\tfor (int i=0; i<(1<<n); i++)\n\t{\n\t\tif (s[i]=='0')\n\t\t{\n\t\t\tans += getf(i);\n\t\t}\n\t}\n\tcerr<<ans<<endl;\n\tout(ans);\n\tputsi(rt.size()-1);\n\tfor (int i=0; i<rt.size(); i++) putsii(rt[i].FF, rt[i].SS);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define INF ((1<<30)-1)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nvoid ok(){\n    cout << \"Yes\" << endl;\n    exit(0);\n}\n\nvoid ng(){\n    cout <<  \"Impossible\" << endl;\n    exit(0);\n}\n\n\nint n;\nint a[1 << 8];\n\nvector<int> loops;\n\nvoid entangle(int x){\n    vector<int> loop;\n    for(int i = n-1;i >= 0;i--){\n        if((x >> i) % 2 == 0)continue;\n        if(loop.empty()){\n            loop.push_back(i+1);\n            loop.push_back(-i-1);\n        }\n        else{\n            vector<int> tmp;\n            tmp.push_back(i+1);\n            for(auto it = loop.begin();it != loop.end();it++)tmp.push_back(*it);\n            tmp.push_back(i+1);\n            tmp.push_back(-i-1);\n            for(auto it = loop.rbegin();it != loop.rend();it++)tmp.push_back(*it);\n            tmp.push_back(-i-1);\n            loop = tmp;\n        }\n    }\n    loop.push_back(INF);\n    for(auto elem:loop)loops.push_back(elem);\n}\n\nvoid show(){\n    cout << \"Possible\" << endl;\n    vector<P> ps;\n    ps.push_back(P(0,0));\n    int nowx = 0, nowy = 0;\n    for(int x:loops){\n        if(x == INF){\n            while(nowx > 0){\n                ps.push_back(P(--nowx, nowy));\n            }\n            continue;\n        }\n        if(x > 0){\n            while(nowx > x){\n                ps.push_back(P(--nowx, nowy));\n            }\n            while(nowx < x-1){\n                ps.push_back(P(++nowx, nowy));\n            }\n            ps.push_back(P(nowx,++nowy));\n            if(nowx == x)ps.push_back(P(--nowx, nowy));\n            else ps.push_back(P(++nowx, nowy));\n            ps.push_back(P(nowx,--nowy));\n        }\n        if(x < 0){\n            x = x * -1;\n            while(nowx > x){\n                ps.push_back(P(--nowx, nowy));\n            }\n            while(nowx < x-1){\n                ps.push_back(P(++nowx, nowy));\n            }\n            if(nowx == x)ps.push_back(P(--nowx, nowy));\n            else ps.push_back(P(++nowx, nowy));\n        }\n    }\n    cout << ps.size() - 1 << endl;\n    for(auto p:ps){\n        cout << p.first << \" \" << p.second << endl;\n    }\n}\n\nint main(){\n    cin >> n;\n    for(int i = 0;i < (1<<n);i++){\n        scanf(\"%1d\", a+i);\n        bool bad=false;\n        if(a[i] == 0)bad = true;\n        for(int j = 0;j < i;j++){\n            if((j & i) != j)continue;\n            if(a[i] == 1 && a[j] == 0){\n                ng();                    \n            }\n            if(a[j] == 0)bad = false;\n        }\n        if(bad){\n            entangle(i);\n        }\n    }\n    show();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1007;\n\nvoid nope()\n{\n\tprintf(\"Impossible\\n\");\n\texit(0);\n}\n\nvoid tak()\n{\n\tprintf(\"Possible\\n\");\n}\n\nint n;\nchar wcz[nax];\nint dasie[nax];\n\nvector <pii> wek;\n\nvector <pii> operator + (vector <pii> a, vector <pii> b)\n{\n\tif (a.empty())\n\t\treturn b;\n\tif (b.empty())\n\t\treturn a;\n\ta.push_back({0, 0});\n\tfor (pii i : b)\n\t\ta.push_back(i);\n\treturn a;\n}\n\nvector <pii> odw(vector <pii> a)\n{\n\treverse(a.begin(), a.end());\n\treturn a;\n}\n\nvector <pii> zdobo(int mas)\n{\n\tif (!mas)\n\t\treturn {};\n\tint x=__builtin_ctz(mas);\n\tvector <pii> ret;\n\tfor (int i=0; i<=x; i++)\n\t\tret.push_back({i, 1});\n\tret.push_back({x, 0});\n\tret.push_back({x+1, 0});\n\tfor (int i=x+1; i>=0; i--)\n\t\tret.push_back({i, 1});\n\tauto wez=zdobo(mas^(1<<x));\n\treturn wez+ret+odw(wez);\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", wcz);\n\tfor (int i=0; i<(1<<n); i++)\n\t\tdasie[i]=wcz[i]-'0';\n\tfor (int i=0; i<(1<<n); i++)\n\t{\n\t\tfor (int j=0; j<(1<<n); j++)\n\t\t{\n\t\t\tif ((i&j)==i && dasie[j] && !dasie[i])\n\t\t\t{\n\t\t\t\tnope();\n\t\t\t}\n\t\t}\n\t}\n\tif (!dasie[0])\n\t\tnope();\n\tfor (int i=0; i<(1<<n); i++)\n\t{\n\t\tif (dasie[i])\n\t\t\tcontinue;\n\t\tauto x=zdobo(i);\n\t\twek=wek+x;\n\t}\n\tif (!wek.empty())\n\t\twek.push_back({0, 0});\n\tprintf(\"%d\\n0 0\\n\", (int)wek.size());\n\tfor (pii i : wek)\n\t\tprintf(\"%d %d\\n\", i.first, i.second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <string.h>\n#include <iostream>\n#include <stdio.h>\n#include <string>\n\nusing namespace std;\n\nconst int N = 105;\nconst int INF = 1e9 + 7;\nint n, m;\nchar c[N][N];\nint f[N][N];\n\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= m; j++)\n\t\t\tcin >> c[i][j];\n\n\tf[1][1] = (c[1][1] != '.');\n\tfor (int s = 3; s <= n + m; s++) {\n\t\tfor (int x = max(s - m, 1); x <= n && x < s; x++) {\n\t\t\tint y = s - x;\n\t\t\tf[x][y] = 1e9 + 7;\n\t\t\tif (x > 1) f[x][y] = min(f[x][y], f[x - 1][y] + (c[x - 1][y] != c[x][y]));\n\t\t\tif (y > 1) f[x][y] = min(f[x][y], f[x][y - 1] + (c[x][y - 1] != c[x][y]));\n\t\t}\n\t}\n\tcout << (((c[n][m] != '.') + f[n][m] + 1) >> 1) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nconst int N = 11, maxn = 1<<8|3;\nint n,m;\nchar s[maxn];\nbool flag[maxn];\n\ninline bool check(){\n\tif (s[0]=='0') return 1;\n\tFOR(i,1,m) if (s[i]=='1')\n\t\tFOR(j,1,m) if ((i&j)==j){\n\t\t\tif (s[j]=='0') return 1;\n\t\t} \n\tFOR(i,1,m) if (s[i]=='0')\n\t\tFOR(j,1,m) if ((i&j)==i){\n\t\t\tif (s[j]=='1') return 1;\n\t\t}\n\treturn 0;\n}\n\nint main(){\n\tscanf(\"%d%s\",&n,s),m=strlen(s);\n\tif (check()) return puts(\"Impossible\"),0;\n\tFOR(i,0,m) if (s[i]=='0')\n\t\tFOR(j,0,m) if (((i&j)==i)&&i!=j) flag[j]=1;\n\tvector<pa>ans={{0,1}};\n\tFOR(i,0,m) if (s[i]=='0'&&flag[i]==0){\n\t\tpoly tmp;\n\t\tint r=0;\n\t\tDow(j,n,1) if (i&(1<<j-1)){r=j;break;}\n\t\ttmp={r,-r};\n\t\tDow(j,r-1,1) if (i&(1<<j-1)){\n\t\t\tpoly tmp2={j};\n\t\t\ttmp2.insert(tmp2.end(),all(tmp));\n\t\t\ttmp2.pb(j),tmp2.pb(-j),reverse(all(tmp));\n\t\t\ttmp2.insert(tmp2.end(),all(tmp));\n\t\t\ttmp2.pb(-j),tmp=tmp2;\n\t\t} else tmp.insert(tmp.begin(),j),tmp.insert(tmp.end(),j);\n\t\tint x=0,y=1;\n\t\tfor (auto j:tmp){\n\t\t\tint a=0,b=0;\n\t\t\tif (j<0) a=-j,b=0;\n\t\t\t\telse a=j,b=1;\n\t\t\tif (y!=b) ans.ep(x,b),y=b;\n\t\t\tif (x<a){\n\t\t\t\twhile (x<a) ++x,ans.ep(x,y);\n\t\t\t} else {\n\t\t\t\twhile (x>a-1) --x,ans.ep(x,y);\n\t\t\t}\n\t\t}\n\t\tif (y==0) ans.ep(x,1),y=1;\n\t\twhile (x) --x,ans.ep(x,y); \n\t}\n\tputs(\"Possible\");\n\tprintf(\"%d\\n\",siz(ans)-1);\n\tfor (auto i:ans) printf(\"%d %d\\n\",i.fi,i.se);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define fr first\n#define sc second\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n\nvector<P> ret;\n\nvoid pos(int i){\n\tfor(int j=0;j<i;j++){\n\t\tret.push_back(P(j+1,0));\n\t}\n\tret.push_back(P(i,1));\n\tret.push_back(P(i+1,1));\n\tret.push_back(P(i+1,0));\n\tret.push_back(P(i,0));\n\tfor(int j=i-1;j>=0;j--){\n\t\tret.push_back(P(j,0));\n\t}\n}\nvoid neg(int i){\n\tfor(int j=0;j<i;j++){\n\t\tret.push_back(P(j+1,0));\n\t}\n\tret.push_back(P(i+1,0));\n\tret.push_back(P(i+1,1));\n\tret.push_back(P(i,1));\n\tret.push_back(P(i,0));\n\tfor(int j=i-1;j>=0;j--){\n\t\tret.push_back(P(j,0));\n\t}\n}\n\t\n\nint main(){\n\tint n;\n\tstring s;\n\tcin>>n>>s;\n\t\n\tint a[300];\n\tfor(int i=0;i<(1<<n);i++)a[i]=s[i]-'0';\n\t\n\tbool used[300];\n\tmemset(used,0,sizeof used);\n\t\n\tint b[300];\n\tfor(int i=0;i<300;i++)b[i]=1;\n\t\n\tfor(int x=0;x<(1<<n);x++){\n\t\tused[x]=true;\n\t\tfor(int y=0;y<(1<<n);y++){\n\t\t\tif((x&y)==y)if(used[y])used[x]=false;\n\t\t}\n\t\tfor(int y=0;y<(1<<n);y++){\n\t\t\tif((x&y)==x)if(a[x]==1)used[x]=false;\n\t\t}\n\t\tif(used[x]){\n\t\t\tfor(int y=0;y<(1<<n);y++){\n\t\t\t\tif((x&y)==x)b[x]=0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool ok=true;\n\tfor(int i=0;i<(1<<n);i++)ok&=a[i]==b[i];\n\tif(!ok){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tret.push_back(P(0,0));\n\tfor(int x=0;x<(1<<n);x++){\n\t\tif(!used[x])continue;\n\t\tint cnt=0;\n\t\tint c[10];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif((x>>i)&1)c[cnt++]=i;\n\t\t}\n\t\tif(cnt==1){\n\t\t\tpos(c[0]);\n\t\t}\n\t\telse if(cnt==2){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[1]);\n\t\t}\n\t\telse if(cnt==3){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[2]);\n\t\t}\n\t}\n\t\n\t/*for(int i=0;i<n;i++){\n\t\tif(used[i][i]){\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t}\n\t\t\tret.push_back(P(i,1));\n\t\t\tret.push_back(P(i+1,1));\n\t\t\tret.push_back(P(i+1,0));\n\t\t\tret.push_back(P(i,0));\n\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\tret.push_back(P(j,0));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int k=i+1;k<n;k++){\n\t\t\tif(used[i][k]){\n\t\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(i,1));\n\t\t\t\tret.push_back(P(i+1,1));\n\t\t\t\tret.push_back(P(i+1,0));\n\t\t\t\tret.push_back(P(i,0));\n\t\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(k,1));\n\t\t\t\tret.push_back(P(k+1,1));\n\t\t\t\tret.push_back(P(k+1,0));\n\t\t\t\tret.push_back(P(k,0));\n\t\t\t\tfor(int j=k-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(i+1,0));\n\t\t\t\tret.push_back(P(i+1,1));\n\t\t\t\tret.push_back(P(i,1));\n\t\t\t\tret.push_back(P(i,0));\n\t\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(k+1,0));\n\t\t\t\tret.push_back(P(k+1,1));\n\t\t\t\tret.push_back(P(k,1));\n\t\t\t\tret.push_back(P(k,0));\n\t\t\t\tfor(int j=k-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}*/\n\t\n\tputs(\"Possible\");\n\tprintf(\"%d\\n\",(int)(ret.size())-1);\n\tfor(int i=0;i<ret.size();i++){\n\t\tprintf(\"%d %d\\n\",ret[i].fr,ret[i].sc);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n#ifdef ENABLE_DEBUG\n#define dump(a) cerr<<#a<<\"=\"<<a<<endl\n#define dumparr(a,n) cerr<<#a<<\"[\"<<n<<\"]=\"<<a[n]<<endl\n#else\n#define dump(a) \n#define dumparr(a,n) \n#endif\n#define FOR(i, a, b) for(ll i = (ll)a;i < (ll)b;i++)\n#define For(i, a) FOR(i, 0, a)\n#define REV(i, a, b) for(ll i = (ll)b-1LL;i >= (ll)a;i--)\n#define Rev(i, a) REV(i, 0, a)\n#define REP(a) For(i, a)\n#define SIGN(a) (a==0?0:(a>0?1:-1))\n\ntypedef long long int ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll,pll> ppll;\ntypedef vector<ll> vll;\ntypedef long double ld;\ntypedef pair<ld,ld> pdd;\n\nconst ll INF=(1LL<<50);\n#if __cplusplus<201700L\nll gcd(ll a, ll b) {\n  if(a < b) return gcd(b, a);\n  ll r;\n  while ((r=a%b)) {\n    a = b;\n    b = r;\n  }\n  return b;\n}\n#endif\ntemplate<class T>\nbool chmax(T& a,const T& b){\n  if(a<b){\n    a=b;\n    return true;\n  }\n  return false;\n}\ntemplate<class T>\nbool chmin(T& a,const T& b){\n  if(a>b){\n    a=b;\n    return true;\n  }\n  return false;\n}\ntemplate<class S,class T>\nstd::ostream& operator<<(std::ostream& os,pair<S,T> a){\n  os << \"(\" << a.first << \",\" << a.second << \")\";\n  return os;\n}\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os,vector<T> a){\n  os << \"[ \";\n  REP(a.size()){\n    os<< a[i] << \" \";\n  }\n  os<< \" ]\";\n  return os;\n}\n\nconst string YES = \"Possible\";\nconst string NO = \"Impossible\";\nvoid create1(vector<pll> &ans,ll x){\n  REP(x+1){ans.push_back(pll(1+i,0));}\n  ans.push_back(pll(x+1,1));\n  ans.push_back(pll(x,1));\n  Rev(i,x+1){ans.push_back(pll(i,0));}\n}\nvoid create2(vector<pll> &ans,set<ll> s){\n  ll first=*s.begin();\n  ll end=*prev(s.end());\n  s.erase(first);\n  REP(first){ans.push_back(pll(i+1,0));}\n  ans.push_back(pll(first,1));\n  ans.push_back(pll(first+1,1));\n  ans.push_back(pll(first+1,0));\n  FOR(i,first+2,end+2){ans.push_back(pll(i,0));}\n  s.insert(first);\n  REV(i,first+1,end+2){\n    if(s.count(i)==1&&s.count(i-1)==0){\n      ans.push_back(pll(i,0));\n    }else if(s.count(i)==0&&s.count(i-1)==1){\n      ans.push_back(pll(i,1));\n    }\n    ans.push_back(pll(i-1,ans.back().second));\n  }\n  s.erase(first);\n  FOR(i,first,*s.begin()+1){\n    ans.push_back(pll(i,0));\n  }\n  FOR(i,*s.begin(),end+1){\n    if(s.count(i-1)==0&&s.count(i)){\n      ans.push_back(pll(i,1));\n    }else if(s.count(i-1)==1&&s.count(i)){\n      ans.push_back(pll(i,0));\n    }\n    ans.push_back(pll(i+1,ans.back().second));\n  }\n  REV(i,0,end+2){\n    ans.push_back(pll(i,0));\n  }\n}\nll two_factor(ll x){\n  ll ret=0;\n  while((1<<ret)!=x){\n    ++ret;\n  }\n  return ret;\n}\nint main(){\n  cout<<setprecision(1000);\n  ll N;\n  cin>>N;\n  string A;\n  cin>>A;\n  vector<bool> first(A.size(),true);\n  REP(A.size()){\n    if(first[i]==false)continue;\n    if(A[i]=='0')FOR(j,i+1,A.size()){\n      if(((i&j)==i)&&A[j]=='1'){\n        cout<<NO<<endl;\n        return 0;\n      }else if((i&j)==i){\n        first[j]=false;\n      }\n    }else{\n      first[i]=false;\n    }\n  }\n  dump(first);\n  vector<pll> ans{pll(0,0)};\n  REP(A.size()){\n    if(first[i]){\n      if(__builtin_popcountll(i)==1){\n        create1(ans,two_factor(i));\n      }else{\n        set<ll> s;\n        For(j,N){\n          if((1<<j)&i){\n            s.insert(j);\n          }\n        }\n        create2(ans,move(s));\n      }\n    }\n  }\n  cout<<YES<<endl;\n  cout<<ans.size()-1<<endl;\n  REP(ans.size()){\n    cout<<ans[i].first<<\" \"<<ans[i].second<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<vector>\n#include<queue>\n#include<iostream>\n#include<fstream>\n#include<string>\n#include<cassert>\n#include<algorithm>\n#include<random>\n#include<map>\n#include<set>\n#include <bitset>\n#include<ctime>\n \nusing namespace std;\n \n//int mod = 998244353;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\ntypedef vector<int>vi;\ntypedef vector<ll>vl;\ntypedef vector<char>vc;\ntypedef vector<string>vs;\ntypedef vector<vector<int>>vii;\ntypedef vector<vector<char>>vvc;\ntypedef vector<vector<ll>>vll;\ntypedef vector< pair<ll, ll>>vpll;\ntypedef vector< pair<ld, ld>>vpld;\ntypedef vector< pair<int, int>>vpi;\ntypedef pair<ld, ld>pld;\n#define mp make_pair\n#define pb push_back\n \nconst int mod = 998244353;\nint add(int a, int b)\n{\n\tint c = a + b;\n\tif (c >= mod)\n\t{\n\t\tc -= mod;\n\t}\n\treturn c;\n}\nint dif(int a, int b)\n{\n\tint c = a - b;\n\tif (c < 0)\n\t{\n\t\tc += mod;\n\t}\n\treturn c;\n}\nint mlt(int a, int b)\n{\nll c = a * 1LL * b;\nreturn c % mod;\n}\nint ibit(int n, int i)\n{\n\treturn ((n >> i) & 1);\n}\nvoid outp(vii &ou)\n{\n\tfor (int i = 0; i < ou.size(); i++)\n\t{\n\t\tfor (int j = 0; j < ou[i].size(); j++)\n\t\t{\n\t\t\tcout << ou[i][j] << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n}\nint bp(int x, int y)\n{\n\tif (y == 0)\n\t{\n\t\treturn 1;\n\t}\n\tint a = 0;\n\tif (!(y % 2))\n\t{\n\t\ta = bp(x, y / 2);\n\t}\n\treturn (y % 2) ? mlt(bp(x, y - 1), x) : mlt(a, a);\n}\nint obr(int x)\n{\n\treturn bp(x, mod - 2);\n}\nconst int maxn = 2000007;\nint fact[2000007], ofact[2000007];\nvoid prec()\n{\n\tfact[0] = 1;\n\tofact[0] = 1;\n\tfor (int i = 1; i < maxn; i++)\n\t{\n\t\tfact[i] = mlt(fact[i - 1], i);\n\t}\n\t//cerr << \"sdsds\" << endl;\n\tofact[maxn - 1] = obr(fact[maxn - 1]);\n\tfor (int i = maxn - 2; i > 0; i--)\n\t{\n\t\tofact[i] = mlt(ofact[i + 1], i + 1);\n\t}\n}\nint c(int a, int b)\n{\n\tif (a == 0)return 1;\n\treturn ((a <= b) && (a >= 0)) ? mlt(fact[b], mlt(ofact[a], ofact[b - a])) : 0;\n}\nll gcd(ll x, ll y)\n{\n\t//cerr << x << y << endl;\n\tif (x == 0)return y;\n\treturn(x > y) ? gcd(y, x) : gcd(y%x, x);\n}\nint obr2(int n)\n{\n\tint x = fact[n - 1];\n\tx = mlt(x, ofact[n]);\n\treturn x;\n}\nvoid crv(int nn, vpi &v)\n{\n\tcerr << nn << endl;\n\tif (nn > 0) {\n\t\tint n = nn;\n\t\tfor (int i = 0; i < n; i++)v.pb({ i + 1, 0 });\n\t\tv.pb({ n,1 });\n\t\tv.pb({ n - 1, 1 });\n\t\tfor (int i = n - 1; i >= 0; i--)v.pb({ i, 0 });\n\t}\n\tif (nn < 0) {\n\t\tint n = -nn;\n\t\tfor (int i = 0; i < n-1; i++)v.pb({ i + 1, 0 });\n\t\tv.pb({ n-1,1 });\n\t\tv.pb({ n , 1 });\n\t\tfor (int i = n; i >= 0; i--)v.pb({ i, 0 });\n\t}\n}\nvoid solve(istream &cin = std::cin, ostream &cout = std::cout)\n{\n\tvii imb(8);\n\timb[0] = { 1 };\n\tfor (int i = 1; i <= 8; i++)\n\t{\n\t\tfor (int j = 0; j < imb[i - 1].size(); j++)imb[i].pb(imb[i - 1][j]);\n\t\timb[i].pb(i + 1);\n\t\tfor (int j = imb[i - 1].size(); j >= 0; j--)imb[i].pb((-1)*imb[i - 1][j]);\n\t\timb[i].pb(-i - 1);\n\t}\n\t//cerr << \"here\" << endl;\n\tint n;\n\tcin >> n;\n\tvi good(1 << n);\n\tfor (int i = 0; i < good.size(); i++)\n\t{\n\t\tchar c;\n\t\tcin >> c;\n\t\tgood[i] = c - '0';\n\t}\n\tint val = 0;\n\t//\tcerr << 433 << endl;\n\tfor (int a = 0; a < good.size(); a++)\n\t\tfor (int b = 0; b < good.size(); b++)\n\t\t\tif ((a | b) == b)\n\t\t\t\tif ((!good[a]) && (good[b]))\n\t\t\t\t{\n\t\t\t\t\t//\tcerr << a << ' ' << b << endl;\n\t\t\t\t\tval = 1;\n\t\t\t\t}\n//\tcerr << 5 << ' ' << 7 << ' ' << (5 | 7) << endl;\n\tif (val)cout << \"Impossible\" << endl;\n\telse\n\t{\n\t\tcout << \"Possible\" << endl;\n\t\t//cerr << 1111 << endl;\n\t\tvpi ay = { {0,0} };\n\t\tfor (int m = 0; m < good.size(); m++)\n\t\t{\n\t\t\t//cerr << m << endl;\n\t\t\tif (!good[m])\n\t\t\t{\n\t\t\t\tcerr << m << endl;\n\t\t\t\tvi v;\n\t\t\t\tfor (int i = 0; i <= 8; i++)if (ibit(m, i))v.pb(i);\n\t\t\t\tcerr << m << ' ' << v.size() << endl;\n\t\t\t\tfor (int i = 0; i < imb[v.size()-1].size(); i++)\n\t\t\t\t{\n\t\t\t\t\tcerr << imb[v.size() - 1][i] << endl;\n\t\t\t\t//\tcerr << i << endl;\n\t\t\t\t\tif (imb[v.size()][i] > 0)crv(v[imb[v.size()-1][i] - 1]+1, ay);\n\t\t\t\t\tif (imb[v.size()][i] < 0)crv(-v[(-imb[v.size()-1][i]) - 1]-1, ay);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ay.size()-1 << endl;\n\t\tfor (int i = 0; i < ay.size(); i++)cout << ay[i].first << ' ' << ay[i].second << endl;\n\t}\n}\nint main()\n{\n\tsolve();\n\tint n;\n\tcin >> n;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n#define MOD @\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nint N;\nchar A[300];\nvector<pair<int, int>> ans;\n\n/*\nvoid draw_curve(int mask, bool flip = false)\n{\n\tvector<pair<int, int>> seq;\n\tseq.push_back({0, 0});\n\tfor (int i = 0; i < N; ++i) {\n\t\tpair<int, int> src = make_pair(i, (mask >> i) & 1);\n\t\tpair<int, int> dest = make_pair(i + 1, (mask >> i) & 1);\n\t\tif (seq.back() != src) seq.push_back(src);\n\t\tseq.push_back(dest);\n\t}\n\tif (seq.back().second == 1) seq.push_back({N, 0});\n\tfor (int i = N - 1; i >= 0; --i) seq.push_back({i, 0});\n\tif (flip) reverse(seq.begin(), seq.end());\n\tfor (int i = 1; i < seq.size(); ++i) ans.push_back(seq[i]);\n}\n*/\nvoid draw_curve(int p, bool flip = false)\n{\n\tvector<pair<int, int>> seq;\n\tfor (int i = 0; i <= p; ++i) seq.push_back({i, 0});\n\tseq.push_back({p, 1});\n\tseq.push_back({p + 1, 1});\n\tfor (int i = p + 1; i >= 0; --i) seq.push_back({i, 0});\n\tif (flip) reverse(seq.begin(), seq.end());\n\tfor (int i = 1; i < seq.size(); ++i) ans.push_back(seq[i]);\n}\n\nint main()\n{\n\tscanf(\"%d%s\", &N, A);\n\tfor (int i = 0; i < (1 << N); ++i) {\n\t\tif (A[i] == '0') {\n\t\t\tfor (int j = 0; j < N; ++j) if ((i & (1 << j)) == 0) {\n\t\t\t\tif (A[i | (1 << j)] == '1') {\n\t\t\t\t\tputs(\"Impossible\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (A[0] == '0') {\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tputs(\"Possible\");\n\tvector<int> minima;\n\tfor (int i = 0; i < (1 << N); ++i) {\n\t\tif (A[i] == '0') {\n\t\t\tbool flg = true;\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tif ((i & (1 << j)) != 0 && A[i ^ (1 << j)] == '0') flg = false;\n\t\t\t}\n\t\t\tif (flg) minima.push_back(i);\n\t\t}\n\t}\n\tans.push_back({0, 0});\n\tfor (int m : minima) {\n\t\tvector<int> bits;\n\t\tfor (int i = 0; i < N; ++i) if (m & (1 << i)) bits.push_back(i);\n\t\tif (bits.size() == 1) {\n\t\t\tdraw_curve(bits[0]);\n\t\t} else {\n\t\t\tvector<int> seq;\n\t\t\tseq.push_back(bits[0]);\n\t\t\tfor (int i = 1; i < bits.size(); ++i) {\n\t\t\t\tvector<int> seq2;\n\t\t\t\tbool flg = false;\n\t\t\t\tfor (int j = 0; j < seq.size(); ++j) {\n\t\t\t\t\tseq2.push_back(seq[j]);\n\t\t\t\t\tif (flg) seq2.push_back(~bits[i]);\n\t\t\t\t\telse seq2.push_back(bits[i]);\n\t\t\t\t\tflg = !flg;\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < seq.size(); ++j) {\n\t\t\t\t\tseq2.push_back(~seq[j]);\n\t\t\t\t\tif (flg) seq2.push_back(~bits[i]);\n\t\t\t\t\telse seq2.push_back(bits[i]);\n\t\t\t\t\tflg = !flg;\n\t\t\t\t}\n\t\t\t\tseq = seq2;\n\t\t\t}\n\t\t\tfor (int i = 0; i < seq.size(); ++i) {\n\t\t\t\tif (seq[i] >= 0) draw_curve(seq[i]);\n\t\t\t\telse draw_curve(~seq[i]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans.size() - 1);\n\tfor (auto p : ans) printf(\"%d %d\\n\", p.first, p.second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n#ifdef ENABLE_DEBUG\n#define dump(a) cerr<<#a<<\"=\"<<a<<endl\n#define dumparr(a,n) cerr<<#a<<\"[\"<<n<<\"]=\"<<a[n]<<endl\n#else\n#define dump(a) \n#define dumparr(a,n) \n#endif\n#define FOR(i, a, b) for(ll i = (ll)a;i < (ll)b;i++)\n#define For(i, a) FOR(i, 0, a)\n#define REV(i, a, b) for(ll i = (ll)b-1LL;i >= (ll)a;i--)\n#define Rev(i, a) REV(i, 0, a)\n#define REP(a) For(i, a)\n#define SIGN(a) (a==0?0:(a>0?1:-1))\n\ntypedef long long int ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll,pll> ppll;\ntypedef vector<ll> vll;\ntypedef long double ld;\ntypedef pair<ld,ld> pdd;\n\nconst ll INF=(1LL<<50);\n#if __cplusplus<201700L\nll gcd(ll a, ll b) {\n  if(a < b) return gcd(b, a);\n  ll r;\n  while ((r=a%b)) {\n    a = b;\n    b = r;\n  }\n  return b;\n}\n#endif\ntemplate<class T>\nbool chmax(T& a,const T& b){\n  if(a<b){\n    a=b;\n    return true;\n  }\n  return false;\n}\ntemplate<class T>\nbool chmin(T& a,const T& b){\n  if(a>b){\n    a=b;\n    return true;\n  }\n  return false;\n}\ntemplate<class S,class T>\nstd::ostream& operator<<(std::ostream& os,pair<S,T> a){\n  os << \"(\" << a.first << \",\" << a.second << \")\";\n  return os;\n}\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os,vector<T> a){\n  os << \"[ \";\n  REP(a.size()){\n    os<< a[i] << \" \";\n  }\n  os<< \" ]\";\n  return os;\n}\n\nconst string YES = \"Possible\";\nconst string NO = \"Impossible\";\nvoid create1(vector<pll> &ans,ll x){\n  REP(x+1){ans.push_back(pll(1+i,0));}\n  ans.push_back(pll(x+1,1));\n  ans.push_back(pll(x,1));\n  Rev(i,x+1){ans.push_back(pll(i,0));}\n}\nvoid create2(vector<pll> &ans,set<ll> s){\n  ll first=*s.begin();\n  ll end=*prev(s.end());\n  s.erase(first);\n  REP(first){ans.push_back(pll(i+1,0));}\n  ans.push_back(pll(first,1));\n  ans.push_back(pll(first+1,1));\n  ans.push_back(pll(first+1,0));\n  FOR(i,first+2,end+2){ans.push_back(pll(i,0));}\n  s.insert(first);\n  REV(i,first+1,end+2){\n    if(s.count(i)==1&&s.count(i-1)==0){\n      ans.push_back(pll(i,0));\n    }else if(s.count(i)==0&&s.count(i-1)==1){\n      ans.push_back(pll(i,1));\n    }\n    ans.push_back(pll(i-1,ans.back().second));\n  }\n  s.erase(first);\n  FOR(i,first,*s.begin()+1){\n    ans.push_back(pll(i,0));\n  }\n  FOR(i,*s.begin(),end+1){\n    if(s.count(i-1)==0&&s.count(i)){\n      ans.push_back(pll(i,1));\n    }else if(s.count(i-1)==1&&s.count(i)){\n      ans.push_back(pll(i,0));\n    }\n    ans.push_back(pll(i+1,ans.back().second));\n  }\n  REV(i,0,end+2){\n    ans.push_back(pll(i,0));\n  }\n}\nll two_factor(ll x){\n  ll ret=0;\n  while((1<<ret)!=x){\n    ++ret;\n  }\n  return ret;\n}\nint main(){\n  abort();\n  cout<<setprecision(1000);\n  ll N;\n  cin>>N;\n  string A;\n  cin>>A;\n  vector<bool> first(A.size(),true);\n  REP(A.size()){\n    if(first[i]==false)continue;\n    if(A[i]=='0')FOR(j,i+1,A.size()){\n      if(((i&j)==i)&&A[j]=='1'){\n        cout<<NO<<endl;\n        return 0;\n      }else if((i&j)==i){\n        first[j]=false;\n      }\n    }else{\n      first[i]=false;\n    }\n  }\n  dump(first);\n  vector<pll> ans{pll(0,0)};\n  REP(A.size()){\n    if(first[i]){\n      if(__builtin_popcountll(i)==1){\n        create1(ans,two_factor(i));\n      }else{\n        set<ll> s;\n        For(j,N){\n          if((1<<j)&i){\n            s.insert(j);\n          }\n        }\n        create2(ans,move(s));\n      }\n    }\n  }\n  if(ans.size()>250001){\n    abort();\n  }\n  cout<<YES<<endl;\n  cout<<ans.size()-1<<endl;\n  REP(ans.size()){\n    cout<<ans[i].first<<\" \"<<ans[i].second<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint N; char str[1 << 8];\nvector < int > pot;\nvector < int > operator +(vector < int > p , vector < int > q){p.insert(p.end() , q.begin() , q.end()); return p;}\n\nvector < int > build(int id , int x){\n\tif(x == N) return vector < int > {};\n\tvector < int > tmp = build(id , x + 1);\n\tif(!(id >> x & 1)) return vector < int >{x + 1} + tmp + vector < int >{x + 1};\n\tvector < int > rev = tmp; reverse(rev.begin() , rev.end());\n\treturn vector < int >{x + 1} + tmp + vector < int >{x + 1} + vector < int >{-x - 1} + rev + vector < int >{-x - 1};\n}\n\nint main(){\n\tscanf(\"%d %s\" , &N , str);\n\tfor(int i = 0 ; i < 1 << N ; ++i)\n\t\tif(str[i] == '1')\n\t\t\tfor(int j = 0 ; j < N ; ++j)\n\t\t\t\tif((i >> j & 1) && str[i ^ (1 << j)] != '1'){\n\t\t\t\t\tputs(\"Impossible\"); return 0;\n\t\t\t\t}\n\tfor(int i = 0 ; i < 1 << N ; ++i)\n\t\tif(str[i] == '0'){\n\t\t\tbool flg = 1;\n\t\t\tfor(int j = 0 ; j < N ; ++j)\n\t\t\t\tif((i >> j & 1) && str[i ^ (1 << j)] == '0')\n\t\t\t\t\tflg = 0;\n\t\t\tif(flg) pot = pot + build(i , 0);\n\t\t}\n\tputs(\"Possible\"); vector < pair < int , int > > node;\n\tint curx = 0 , cury = 0; node.push_back(make_pair(0 , 0));\n\tfor(int i = 0 ; i < pot.size() ; ++i){\n\t\tif(pot[i] < 0 && cury == 1) node.push_back(make_pair(curx , cury = 0));\n\t\tif(pot[i] > 0 && cury == 0) node.push_back(make_pair(curx , cury = 1));\n\t\tint t = abs(pot[i]) - 1;\n\t\tif(curx == t) node.push_back(make_pair(++curx , cury));\n\t\telse node.push_back(make_pair(--curx , cury));\n\t}\n\tif(cury) node.push_back(make_pair(0 , 0));\n\tprintf(\"%d\\n\" , node.size() - 1);\n\tfor(auto t : node) printf(\"%d %d\\n\" , t.first , t.second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define ALL(x) (x).begin(), (x).end()\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool chmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool chmin(T &m, const T q) { if (q < m) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n/*\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/tag_and_trait.hpp>\nusing namespace __gnu_pbds; // find_by_order(), order_of_key()\ntemplate<typename TK> using pbds_set = tree<TK, null_type, less<TK>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename TK, typename TV> using pbds_map = tree<TK, TV, less<TK>, rb_tree_tag, tree_order_statistics_node_update>;\n*/\n\nconst string YES = \"Possible\";\nconst string NO = \"Impossible\";\n\nbool impossible_checker(int N, string S) {\n    assert((int)(S.length()) == (1 << N));\n    if (S[0] == '0') return true;\n    REP(a, 1 << N)\n    {\n        REP(b, 1 << N) if (((~b) & a) == 0) {\n            if (S[b] == '1' and S[a] == '0') return true;\n        }\n    }\n    return false;\n}\n\nvector<vector<pint>> Rloop(8);\nvector<vector<pint>> Lloop(8);\n\nvector<vector<int>> S(9);\n\nint x_now, y_now;\n\nvector<pint> ret;\n\nvoid up() {\n    y_now++;\n    ret.emplace_back(x_now, y_now);\n}\nvoid down() {\n    y_now--;\n    ret.emplace_back(x_now, y_now);\n}\nvoid right() {\n    x_now++;\n    ret.emplace_back(x_now, y_now);\n}\nvoid left() {\n    x_now--;\n    ret.emplace_back(x_now, y_now);\n}\n\nvoid do_rloop(int X)\n{\n    if (y_now == 0) {\n        up();\n    }\n    while (x_now < X) right();\n    while (x_now > X) left();\n    right();\n    down();\n    left();\n    up();\n}\n\nvoid do_lloop(int X) {\n    if (y_now == 0) {\n        up();\n    }\n    while (x_now < X) right();\n    while (x_now > X) left();\n    down();\n    right();\n    up();\n    left();\n}\n\nvoid go_origin() {\n    if (y_now == 0) up();\n    while (x_now > 0) left();\n    down();\n}\n\nint main()\n{\n    int N;\n    string A;\n    cin >> N >> A;\n    if (impossible_checker(N, A)) {\n        cout << NO << endl;\n        return 0;\n    }\n\n    REP(x, 8) {\n        Rloop[x].emplace_back(0, 0);\n        REP(d, x + 1) Rloop[x].emplace_back(d, 1);\n        Lloop[x] = Rloop[x];\n        Rloop[x].emplace_back(x + 1, 1);\n        Lloop[x].emplace_back(x, 0);\n        Lloop[x].emplace_back(x + 1, 0);\n        Lloop[x].emplace_back(x + 1, 1);\n        Rloop[x].emplace_back(x + 1, 0);\n        Rloop[x].emplace_back(x, 0);\n        IREP(d, x + 1) Rloop[x].emplace_back(d, 1);\n        IREP(d, x + 1) Lloop[x].emplace_back(d, 1);\n    }\n\n    S[1] = {+1};\n    S[2] = {+1, +2, -1, -2};\n    FOR(d, 3, S.size()) {\n        S[d] = {d};\n        vector<int> prev = S[d - 1];\n        S[d].insert(S[d].end(), ALL(prev));\n        S[d].push_back(-d);\n        reverse(ALL(prev));\n        for (auto &x : prev) x *= -1;\n        S[d].insert(S[d].end(), ALL(prev));\n    }\n\n    up();\n    down();\n\n    REP(subset, 1 << N) if (A[subset] == '0') {\n        bool must = true;\n        REP(ss, 1 << N) if (((~subset) & ss) == 0 and ss < subset) {\n            if (A[ss] == '0') must = false;\n        }\n        if (!must) continue;\n        int cnt = __builtin_popcount(subset);\n        if (cnt == 1) {\n            int i = 0;\n            while ((subset >> i) % 2 == 0) i++;\n            do_rloop(i);\n            continue;\n        }\n\n        vector<int> ns;\n        REP(i, N) if ((subset >> i) & 1) ns.push_back(i);\n        for (auto dict : S[cnt]) {\n            int id_ = abs(dict) - 1;\n            if (dict > 0) do_rloop(ns[id_]);\n            else do_lloop(ns[id_]);\n        }\n    }\n    go_origin();\n    up();\n\n    cout << YES << \"\\n\";\n    cout << ret.size() - 1 << \"\\n\";\n    for (auto p : ret) cout << p.first << \" \" << p.second << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define I inline\n#define fi first\n#define se second\n#define R register\n#define LL long long\n#define mp make_pair\n#define reg register int\n#define pii pair<int,int>\n#define fo(i, a, b) for(reg i = a; i <= b; i++)\n#define fd(i, a, b) for(reg i = a; i >= b; i--)\n#define cr const reg&\nusing namespace std;\n\nI int _max(cr x, cr y) {return x > y ? x : y;}\nI int _min(cr x, cr y) {return x < y ? x : y;}\nI int read() {\n\treg x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n\treturn x * f;\n}\nI void ptt(LL x) {if(x >= 10) ptt(x / 10); putchar(x % 10 + '0');}\nI void put(LL x) {x < 0 ? putchar('-'), ptt(-x) : ptt(x);}\nI void pr1(LL x) {put(x), putchar(' ');}\nI void pr2(LL x) {put(x), puts(\"\");}\n\nchar ss[1 << 8];\nvector<pii> ans;\n\nstring rev(string s) {\n\treverse(s.begin(), s.end());\n\treturn s;\n}\n\nint main() {\n\treg n = read();\n\tscanf(\"%s\", ss);\n\tif(ss[0] == '0') {puts(\"Impossible\"); return 0;}\n\treg S = (1 << n) - 1;\n\tfo(i, 1, S) {\n\t\tif(ss[i] == '1') {\n\t\t\tfo(j, 0, n - 1) if(i >> j & 1) {\n\t\t\t\tif(ss[i ^ (1 << j)] == '0') {puts(\"Impossible\"); return 0;}\n\t\t\t}\n\t\t}\n\t} puts(\"Possible\");\n\treg now = 0; ans.push_back(pii{0, 0});\n\tfo(i, 1, S) if(ss[i] == '0'){\n\t\tbool bk = 0;\n\t\tfo(j, 0, n - 1) if(i >> j & 1) {\n\t\t\tif(ss[i ^ (1 << j)] == '0') {bk = 1; break;}\n\t\t} if(bk) break;\n\t\tstring q; q.clear();\n\t\tfd(j, n - 1, 0) if(i >> j & 1){\n\t\t\tstring c1 = {char('a' + j)}, c2 = {char('A' + j)};\n\t\t\tif(q.empty()) q += c1 + c2;\n\t\t\telse q = c1 + q + c2 + rev(q);\n\t\t} for(char c : q) {\n\t\t\treg p, o;\n\t\t\tif(isupper(c)) p = c - 'A', o = 1;\n\t\t\telse p = c - 'a', o = 0;\n\t\t\tfo(j, now + 1, p) ans.push_back(pii{j, 0});\n\t\t\tfd(j, now - 1, p) ans.push_back(pii{j, 0});\n\t\t\tnow = p;\n\t\t\tif(!o) {\n\t\t\t\tans.push_back(pii{p, 1});\n\t\t\t\tans.push_back(pii{p + 1, 1});\n\t\t\t\tans.push_back(pii{p + 1, 0});\n\t\t\t\tans.push_back(pii{p, 0});\n\t\t\t} else {\n\t\t\t\tans.push_back(pii{p + 1, 0});\n\t\t\t\tans.push_back(pii{p + 1, 1});\n\t\t\t\tans.push_back(pii{p, 1});\n\t\t\t\tans.push_back(pii{p, 0});\n\t\t\t}\n\t\t}\n\t} fd(j, now - 1, 0) ans.push_back(pii{j, 0});\n\tpr2((int)ans.size() - 1);\n\tfo(i, 0, (int)ans.size() - 1) pr1(ans[i].fi), pr2(ans[i].se);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define re register\n#define cs const\n\nusing std::cerr;\nusing std::cout;\nusing pii=std::pair<int,int>;\n#define fi first\n#define se second\n\nstd::string inv(std::string s){\n\tstd::string res=\"\";\n\tstd::reverse(s.begin(),s.end());\n\tfor(char c:s)\n\t\tif(isupper(c))res+=c-'A'+'a';\n\t\telse res+=c-'a'+'A';\n\treturn res;\n}\n\nint n;\nstd::string A;\n\nvoid Main(){\n\tstd::cin>>n>>A;\n\tif(A[0]=='0'){\n\t\tputs(\"Impossible\");\n\t\treturn ;\n\t}for(int re i=0;i<(1<<n);++i)\n\t\tif(A[i]=='1')for(int re j=i;j;j=i&(j-1))\n\t\t\tif(A[j]=='0'){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn ;\n\t\t\t}\n\tstd::vector<pii> p({{0,0}});\n\tfor(int re s=0;s<(1<<n);++s)if(A[s]=='0'){\n\t\tbool flag=true;\n\t\tfor(int re t=s&(s-1);t&&flag;t=s&(t-1))\n\t\t\tif(A[t]=='0')flag=false;\n\t\tif(!flag)continue;\n\t\tstd::string q;\n\t\tfor(int re i=0;i<n;++i)\n\t\t\tif(s&(1<<i)){\n\t\t\t\tif(q.empty())q+='a'+i;\n\t\t\t\telse q=(char)('a'+i)+q+(char)('A'+i)+inv(q);\n\t\t\t}\n\t\tint nw=0;\n\t\tfor(char c:q){\n\t\t\tint i,dir;\n\t\t\tif(isupper(c))\n\t\t\t\ti=c-'A',dir=0;\n\t\t\telse \n\t\t\t\ti=c-'a',dir=1;\n\t\t\tfor(int j=nw+1;j<=i;++j)\n\t\t\t\tp.push_back({j,0});\n\t\t\tfor(int j=nw-1;j>=i;--j)\n\t\t\t\tp.push_back({j,0});\n\t\t\tnw=i;\n\t\t\tif(dir){\n\t\t\t\tp.push_back({i,1});\n\t\t\t\tp.push_back({i+1,1});\n\t\t\t\tp.push_back({i+1,0});\n\t\t\t\tp.push_back({i,0});\n\t\t\t}else {\n\t\t\t\tp.push_back({i+1,0});\n\t\t\t\tp.push_back({i+1,1});\n\t\t\t\tp.push_back({i,1});\n\t\t\t\tp.push_back({i,0});\n\t\t\t}\n\t\t}\n\t\tfor(int j=nw-1;~j;--j)\n\t\t\tp.push_back({j,0});\n\t}\n\tcout<<\"Possible\\n\"<<(p.size()-1)<<\"\\n\";\n\tfor(auto t:p)cout<<t.fi<<\" \"<<t.se<<\"\\n\";\n}\n\ninline void file(){\n#ifdef zxyoi\n\tfreopen(\"E.in\",\"r\",stdin);\n#endif\n}signed main(){file();Main();return 0;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#pragma GCC optimize(\"Ofast\")\n\n#define fi first\n#define se second\n\nconst int N = 9;\n\nusing namespace std;\n\nint n;\nint b[N];\nint a[1 << N];\nint c[1 << N];\nvector < pair < int, int > > res;\n\nvoid run(int x)\n{\n        res.push_back({x, 1});\n        res.push_back({x, 0});\n        if(x == n) return;\n\n        if(b[x] == 0){\n                res.push_back({x + 1, 0});\n                run(x + 1);\n                res.push_back({x, 0});\n        } else if(b[x] == 1){\n                res.push_back({x, 1});\n                res.push_back({x + 1, 1});\n                res.push_back({x + 1, 0});\n                run(x + 1);\n                res.push_back({x + 1, 1});\n                res.push_back({x, 1});\n                res.push_back({x, 0});\n        } else{\n                res.push_back({x, 1});\n                res.push_back({x + 1, 1});\n                res.push_back({x + 1, 0});\n                run(x + 1);\n                res.push_back({x, 0});\n        }\n}\n\nvoid solve()\n{\n        for(int i = 0; i < (1 << n); i++){\n                c[i] = 1;\n                int c0 = 0, c1 = 0;\n                for(int j = 0; j < n; j++){\n                        if(i & (1 << j)){\n                                if(b[j] == 2) c[i] = 0;\n                                else if(b[j] == 1) c0 = 1;\n                                else c1 = 1;\n                        }\n                }\n                if(c0 && c1) c[i] = 0;\n                if(c[i] != a[i]) return;\n        }\n\n        res.push_back({0, 0});\n        run(0);\n\n        cout << \"Possible\" << \"\\n\";\n        cout << res.size() - 1 << \"\\n\";\n        for(auto p: res) cout << p.fi << \" \" << p.se << \"\\n\";\n\n        exit(0);\n}\n\nvoid rec(int x)\n{\n        if(x == n){\n                solve();\n                return;\n        }\n        for(int g: {0, 1, 2}){\n                b[x] = g;\n                rec(x + 1);\n        }\n}\n\nint main()\n{\n        //freopen(\"input.txt\", \"r\", stdin);\n        //freopen(\"output.txt\", \"w\", stdout);\n\n        ios_base::sync_with_stdio(0);\n\n        cin >> n;\n        for(int i = 0; i < (1 << n); i++){\n                char c;\n                cin >> c;\n                a[i] = c - '0';\n        }\n\n        rec(0);\n\n        cout << \"Impossible\" << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\n#include <assert.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\nconst int MOD=1e9+7;\n#define SZ 666666\nint n;\nchar a[SZ];\nbool v[SZ];\nvi neg(vi x)\n{\n\treverse(x.begin(),x.end());\n\tfor(auto&y:x) y=-y;\n\treturn x;\n}\nvi operator + (vi a,const vi&b)\n{\n\tfor(auto x:b) a.pb(x);\n\treturn a;\n}\nvi operator - (vi a,const vi&b)\n{\n\treturn a+neg(b);\n}\nvi cs(vi a,int l,int r)\n{\n\tif(l==r)\n\t\treturn {a[l]};\n\tint m=(l+r)>>1;\n\tvi L=cs(a,l,m),R=cs(a,m+1,r);\n\treturn L+R-L-R;\n}\nvi CL(vi t)\n{\n\treturn t;\n}\nvi v1{1},v2{2};\nvi AND(vi p,vi q)\n{\n\treturn CL(p+p+v1+p+p-v1+v2-q-v2-q+v2-q-v2-q);\n}\nvi cs(vector<vi> a,int l,int r)\n{\n\tif(l==r)\n\t\treturn a[l];\n\tint m=(l+r)>>1;\n\tvi L=cs(a,l,m),R=cs(a,m+1,r);\n\treturn AND(L,R);\n}\nint main()\n{\n\tcin>>n>>a;\n\tbool ok=1;\n\tvector<vi> vv;\n\tfor(int i=0;i<(1<<n);++i) if(a[i]=='0'&&!v[i])\n\t{\n\t\tfor(int j=0;j<(1<<n);++j) if((j&i)==i)\n\t\t\tv[j]=1,ok&=a[j]=='0';\n\t\tvi t;\n\t\tfor(int j=0;j<n;++j) if(i&(1<<j)) t.pb(j+1);\n\t\tvi w=cs(t,0,t.size()-1);\n\t\tvv.pb(w);\n\t}\n\tif(!ok)\n\t{\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tvector<int> g;\n\tif(vv.size()) g=cs(vv,0,vv.size()-1);\n\tputs(\"Possible\");\n\tvector<pii> v;\n\tv.pb(pii(0,0));\n\tfor(auto c:g)\n\t{\n\t\tint x=abs(c);\n\t\tif(c>0)\n\t\t{\n\t\t\tv.pb(pii(x-1,0));\n\t\t\tv.pb(pii(x-1,1));\n\t\t\tv.pb(pii(x,1));\n\t\t\tv.pb(pii(x,0));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tv.pb(pii(x,0));\n\t\t\tv.pb(pii(x,1));\n\t\t\tv.pb(pii(x-1,1));\n\t\t\tv.pb(pii(x-1,0));\n\t\t}\n\t}\n\tv.pb(pii(0,0));\n\tvector<pii> vt;\n\tfor(int i=0;i<v.size();++i)\n\t{\n\t\tpii A=v[i],B=v[(i+1)%v.size()];\n\t\tvt.pb(A);\n\t\tint g=abs(A.fi-B.fi)+abs(A.se-B.se);\n\t\tif(g)\n\t\t{\n\t\t\tfor(int j=1;j<=g;++j)\n\t\t\t{\n\t\t\t\tpii s(A.fi+(B.fi-A.fi)/g*j,\n\t\t\t\tA.se+(B.se-A.se)/g*j);\n\t\t\t\tvt.pb(s);\n\t\t\t}\n\t\t}\n\t}\n\tvt.erase(unique(vt.begin(),vt.end()),vt.end());\n\tv=vt;\n\tprintf(\"%d\\n\",int(v.size())-1);\n\tfor(auto c:v) printf(\"%d %d\\n\",c.fi,c.se);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n, C[260];\nchar p[260];\nstruct point {\n\tint x, y;\n};\nvector<point>Res;\nvoid Add(int x, int y) {\n\tRes.push_back({ x,y });\n}\nvoid Add0() {\n\tint i;\n\tfor (i = 0; i < n; i++) Add(i, 1);\n\tfor (i = n; i > 0; i--)Add(i, 1);\n}\nvoid Add1(int x) {\n\tint i;\n\tfor (i = 0; i <= x + 1; i++)Add(i, 1);\n\tAdd(x + 1, 0);\n\tAdd(x, 0);\n\tfor (i = x; i > 0; i--)Add(i, 1);\n}\nvoid Add2(int xa, int xb) {\n\tint i;\n\tfor (i = 0; i <= xb + 1; i++) Add(i, 1);\n\tAdd(xb + 1, 0);\n\tAdd(xb, 0);\n\tfor (i = xb; i >= xa; i--)Add(i, 1);\n\tAdd(xa, 0);\n\tAdd(xa + 1, 0);\n\tfor (i = xa + 1; i <= xb; i++)Add(i, 1);\n\tAdd(xb, 0);\n\tAdd(xb + 1, 0);\n\tfor (i = xb + 1; i > xa; i--)Add(i, 1);\n\tAdd(xa + 1, 0);\n\tAdd(xa, 0);\n\tfor (i = xa; i > 0; i--)Add(i, 1);\n}\nvoid Print() {\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d\\n\", Res.size());\n\tint i;\n\tRes.push_back(Res[0]);\n\tfor (auto &t : Res)printf(\"%d %d\\n\", t.x, t.y);\n}\nint main() {\n\tint i, j;\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", p);\n\tfor (i = 0; i < (1 << n); i++) {\n\t\tint c = 0;\n\t\tfor (j = 0; j < n; j++)if ((i >> j) & 1)c++;\n\t\tC[i] = c;\n\t}\n\tfor (i = 0; i < (1 << n); i++) {\n\t\tint ck = 0;\n\t\tif (p[i] == '0' && C[i] >= 3)ck = 1;\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif ((i&j) == j) {\n\t\t\t\tif (p[j] == '0'&&p[i] == '1') {\n\t\t\t\t\tputs(\"Impossible\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (C[j] == 2 && p[j] == '0')ck = 0;\n\t\t\t}\n\t\t}\n\t\tif (ck == 1) {\n\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tAdd0();\n\tfor (i = 0; i < n; i++) {\n\t\tif (p[1 << i] == '0') {\n\t\t\tAdd1(i);\n\t\t}\n\t}\n\tfor (i = n-1; i >= 0; i--) {\n\t\tfor (j = n-1; j >i; j--) {\n\t\t\tif (p[1 << i] == '1'&&p[1 << j] == '1'&&p[(1 << i) | (1 << j)] == '0') {\n\t\t\t\tAdd2(i, j);\n\t\t\t}\n\t\t}\n\t}\n\tPrint();\n}"
  },
  {
    "language": "C++",
    "code": "\n#pragma GCC optimize(\"Ofast\")\n#include<vector>\n#include<queue>\n#include<iostream>\n#include<fstream>\n#include<string>\n#include<cassert>\n#include<algorithm>\n#include<random>\n#include<map>\n#include<set>\n#include <bitset>\n#include<ctime>\n\nusing namespace std;\n\n//int mod = 998244353;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\ntypedef vector<int>vi;\ntypedef vector<ll>vl;\ntypedef vector<char>vc;\ntypedef vector<string>vs;\ntypedef vector<vector<int>>vii;\ntypedef vector<vector<char>>vvc;\ntypedef vector<vector<ll>>vll;\ntypedef vector< pair<ll, ll>>vpll;\ntypedef vector< pair<ld, ld>>vpld;\ntypedef vector< pair<int, int>>vpi;\ntypedef pair<ld, ld>pld;\n#define mp make_pair\n#define pb push_back\n\nconst int mod = 998244353;\nint add(int a, int b)\n{\n\tint c = a + b;\n\tif (c >= mod)\n\t{\n\t\tc -= mod;\n\t}\n\treturn c;\n}\nint dif(int a, int b)\n{\n\tint c = a - b;\n\tif (c < 0)\n\t{\n\t\tc += mod;\n\t}\n\treturn c;\n}\nint mlt(int a, int b)\n{\n\tll c = a * 1LL * b;\n\treturn c % mod;\n}\nint ibit(int n, int i)\n{\n\treturn ((n >> i) & 1);\n}\nvoid outp(vii &ou)\n{\n\tfor (int i = 0; i < ou.size(); i++)\n\t{\n\t\tfor (int j = 0; j < ou[i].size(); j++)\n\t\t{\n\t\t\tcout << ou[i][j] << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n}\nint bp(int x, int y)\n{\n\tif (y == 0)\n\t{\n\t\treturn 1;\n\t}\n\tint a = 0;\n\tif (!(y % 2))\n\t{\n\t\ta = bp(x, y / 2);\n\t}\n\treturn (y % 2) ? mlt(bp(x, y - 1), x) : mlt(a, a);\n}\nint obr(int x)\n{\n\treturn bp(x, mod - 2);\n}\nconst int maxn = 2000007;\nint fact[2000007], ofact[2000007];\nvoid prec()\n{\n\tfact[0] = 1;\n\tofact[0] = 1;\n\tfor (int i = 1; i < maxn; i++)\n\t{\n\t\tfact[i] = mlt(fact[i - 1], i);\n\t}\n\t//cerr << \"sdsds\" << endl;\n\tofact[maxn - 1] = obr(fact[maxn - 1]);\n\tfor (int i = maxn - 2; i > 0; i--)\n\t{\n\t\tofact[i] = mlt(ofact[i + 1], i + 1);\n\t}\n}\nint c(int a, int b)\n{\n\tif (a == 0)return 1;\n\treturn ((a <= b) && (a >= 0)) ? mlt(fact[b], mlt(ofact[a], ofact[b - a])) : 0;\n}\nll gcd(ll x, ll y)\n{\n\t//cerr << x << y << endl;\n\tif (x == 0)return y;\n\treturn(x > y) ? gcd(y, x) : gcd(y%x, x);\n}\nint obr2(int n)\n{\n\tint x = fact[n - 1];\n\tx = mlt(x, ofact[n]);\n\treturn x;\n}\nvoid crv(int nn, vpi &v)\n{\n\tif (nn > 0) {\n\t\tint n = nn;\n\t\tfor (int i = 0; i < n; i++)v.pb({ i + 1, 0 });\n\t\tv.pb({ n,1 });\n\t\tv.pb({ n - 1, 1 });\n\t\tfor (int i = n - 1; i >= 0; i--)v.pb({ i, 0 });\n\t}\n\tif (nn < 0) {\n\t\tint n = -nn;\n\t\tfor (int i = 0; i < n - 1; i++)v.pb({ i + 1, 0 });\n\t\tv.pb({ n - 1,1 });\n\t\tv.pb({ n , 1 });\n\t\tfor (int i = n; i >= 0; i--)v.pb({ i, 0 });\n\t}\n}\nvoid solve(istream &cin = std::cin, ostream &cout = std::cout)\n{\n\tvii imb(9);\n\timb[0] = { 1 };\n\tfor (int i = 1; i <= 8; i++)\n\t{\n\t\tfor (int j = 0; j < imb[i - 1].size(); j++)imb[i].pb(imb[i - 1][j]);\n\t\timb[i].pb(i + 1);\n\t\tfor (int j = imb[i - 1].size() - 1; j >= 0; j--)imb[i].pb((-1)*imb[i - 1][j]);\n\t\timb[i].pb(-i - 1);\n\t}\n\t//cerr << \"here\" << endl;\n\tint n;\n\tcin >> n;\n\tvi good(1<<n);\n\tfor (int i = 0; i < good.size(); i++)\n\t{\n\t\tchar c;\n\t\tcin >> c;\n\t\tgood[i] = c - '0';\n\t}\n\tint val = 0;\n\t//\tcerr << 433 << endl;\n\tfor (int a = 0; a<good.size(); a++)\n\t\tfor (int b = 0; b<good.size(); b++)\n\t\t\tif ((a | b) == b)\n\t\t\t\tif ((!good[a]) && (good[b]))\n\t\t\t\t{\n\t\t\t\t\t//\tcerr << a << ' ' << b << endl;\n\t\t\t\t\tval = 1;\n\t\t\t\t}\n\tif (val)cout << \"Impossible\" << endl;\n\telse\n\t{\n\t\t//cerr << 1111 << endl;\n\t\tvpi ay = { { 0,0 } };\n\t\tfor (int m = 0; m < good.size(); m++)\n\t\t{\n\t\t\t//cerr << m << endl;\n\t\t\tif (!good[m])\n\t\t\t{\n\t\t\t\tvi v;\n\t\t\t\tfor (int i = 0; i < 8; i++)if (ibit(m, i))v.pb(i);\n\t\t\t\tfor (int i = 0; i < imb[v.size() - 1].size(); i++)\n\t\t\t\t{\n\t\t\t\t\t//\tcerr << i << endl;\n\t\t\t\t\tif (imb[v.size()][i] > 0)crv(v[imb[v.size() - 1][i] - 1], ay);\n\t\t\t\t\tif (imb[v.size()][i] < 0)crv(-v[(-imb[v.size() - 1][i]) - 1], ay);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << \"Possible\" << endl;\n\t\tcout << ay.size() << endl;\n\t\tfor (int i = 0; i < ay.size(); i++)cout << ay[i].first << ' ' << ay[i].second << endl;\n\t}\n}\nint main()\n{\n\tsolve();\n\tint n;\n\tcin >> n;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Egor Kulikov\n */\n\n\n\n\n\n\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// BEGIN CUT HERE\ntemplate <typename T>\nclass Vector : public vector<T> {\n    using parent = vector<T>;\npublic:\n    Vector() : parent() {}\n\n    explicit Vector(size_t __n) : parent(__n) {}\n\n    Vector(size_t __n, const T& __value) : parent(__n, __value) {}\n\n    explicit Vector(const parent& __x) : parent(__x) {}\n\n    Vector(const Vector& __x) : parent(__x) {}\n\n    Vector(Vector&& __x) noexcept : parent(move(__x)) {}\n\n    Vector(initializer_list<T> __l) : parent(__l) {}\n\n    template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>>\n    Vector(_InputIterator __first, _InputIterator __last) : parent(__first, __last) {}\n\n    const T& operator[](size_t ind) const {\n#ifdef LOCAL\n        if (ind >= parent::size()) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return parent::operator[](ind);\n    }\n\n    T& operator[](size_t ind) {\n#ifdef LOCAL\n        if (ind >= parent::size()) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return parent::operator[](ind);\n    }\n\n    Vector<T>& operator=(Vector<T>&& __x) noexcept {\n        parent::operator=(__x);\n        return *this;\n    }\n\n    Vector<T>& operator=(const Vector<T>& __x) {\n        if (&__x == this) {\n            return *this;\n        }\n        parent::operator=(__x);\n        return *this;\n    }\n};\n\ntemplate <>\nclass Vector<bool> : public vector<bool> {\n    using parent = vector<bool>;\npublic:\n    Vector() : parent() {}\n\n    explicit Vector(size_t __n) : parent(__n) {}\n\n    Vector(size_t __n, const bool& __value) : parent(__n, __value) {}\n\n    explicit Vector(const parent& __x) : parent(__x) {}\n\n    Vector(const Vector& __x) : parent(__x) {}\n\n    Vector(Vector&& __x) noexcept : parent(move(__x)) {}\n\n    Vector(initializer_list<bool> __l) : parent(__l) {}\n\n    template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>>\n    Vector(_InputIterator __first, _InputIterator __last) : parent(__first, __last) {}\n\n    parent::const_reference operator[](size_t ind) const {\n#ifdef LOCAL\n        if (ind >= parent::size()) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return parent::operator[](ind);\n    }\n\n    parent::reference operator[](size_t ind) {\n#ifdef LOCAL\n        if (ind >= parent::size()) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return parent::operator[](ind);\n    }\n\n    Vector<bool>& operator=(Vector<bool>&& __x) noexcept {\n        parent::operator=(__x);\n        return *this;\n    }\n\n    Vector<bool>& operator=(const Vector<bool>& __x) {\n        if (&__x == this) {\n            return *this;\n        }\n        parent::operator=(__x);\n        return *this;\n    }\n};\n\n#ifdef LOCAL\n#define vec Vector\n#else\n// END CUT HERE\n#define vec vector\n// BEGIN CUT HERE\n#endif\n// END CUT HERE\n\nusing vi = vec<int>;\n\n\n#define all(v) (v).begin(), (v).end()\n\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\n\nvoid doReplace() {\n}\n\ntemplate <typename T, typename U, typename...Vs>\nvoid doReplace(T& t, const U& u, Vs&& ...vs) {\n    t = u;\n    doReplace(vs...);\n}\n\ntemplate <typename T, typename...Us>\nT minim(T& was, const T& cand, Us&& ...us) {\n    if (was > cand) {\n        was = cand;\n        doReplace(us...);\n    }\n    return was;\n}\n\ntemplate <typename T, typename...Us>\nT maxim(T& was, const T& cand, Us&& ...us) {\n    if (was < cand) {\n        was = cand;\n        doReplace(us...);\n    }\n    return was;\n}\n\n\ntemplate <typename D>\nD dPower(D base, ll exponent) {\n    if (exponent < 0) {\n        return dPower(1 / base, -exponent);\n    }\n    if (exponent == 0) {\n        return 1;\n    }\n    if ((exponent & 1) == 1) {\n        return dPower(base, exponent - 1) * base;\n    } else {\n        D res = dPower(base, exponent >> 1);\n        return res * res;\n    }\n}\n\n\nclass NumberIterator : iterator<forward_iterator_tag, int> {\npublic:\n    int v;\n\n    NumberIterator(int v) : v(v) {}\n\n    operator int&() { return v; }\n\n    int operator*() { return v; }\n};\n\nclass range : pii {\npublic:\n    range(int begin, int end) : pii(begin, max(begin, end)) {}\n\n    range(int n) : pii(0, max(0, n)) {}\n\n    NumberIterator begin() {\n        return first;\n    }\n\n    NumberIterator end() {\n        return second;\n    }\n};\n\n\ntemplate <typename T>\nclass arr {\n    T* b;\n    int n;\n\n    void allocate(int sz) {\n#ifdef LOCAL\n        if (sz < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        n = sz;\n        if (sz > 0) {\n            b = (T*) (::operator new(sz * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr(int n = 0) {\n        allocate(n);\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr(int n, const T& init) {\n        allocate(n);\n        for (int i : range(n)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr(initializer_list<T> l) {\n        allocate(n);\n        if (n > 0) {\n            memcpy(b, l.begin(), n * sizeof(T));\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr(T* b, int n) : arr(b, b + n) {}\n\n    arr(T* b, T* e) : b(b), n(e - b) {}\n\n    int size() const {\n        return n;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    const T* begin() const {\n        return b;\n    }\n\n    T* end() {\n        return b + n;\n    }\n\n    const T* end() const {\n        return b + n;\n    }\n\n    arr<T> clone() const {\n        arr<T> res(n);\n        copy(b, b + n, res.begin());\n        return res;\n    }\n\n    T& operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= n) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[at];\n    }\n\n    const T& operator[](int at) const {\n#ifdef LOCAL\n        if (at < 0 || at >= n) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[at];\n    }\n\n    bool operator==(const arr& other) const {\n        if (n != other.n) {\n            return false;\n        }\n        for (int i : range(n)) {\n            if (b[i] != other.b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    vector<T> view() {\n        return vector<T>(b, b + min(n, 50));\n    }\n};\n\ntypedef arr<int> arri;\n\nvoid decreaseByOne() {}\n\ntemplate <typename T, class...Vs>\nvoid decreaseByOne(arr<T>& array, Vs& ...vs) {\n    int n = array.size();\n    for (int i = 0; i < n; ++i) {\n        array[i]--;\n    }\n    decreaseByOne(vs...);\n}\n\ntemplate <typename T, typename U>\nvoid decreaseByOne(arr<pair<T, U>>& v) {\n    for (auto& p : v) {\n        p.first--;\n        p.second--;\n    }\n}\n\n\ntemplate <typename T>\nclass arr2d {\n    T* b;\n    int d1;\n    int d2;\n    int sz;\n\n    void allocate(int n) {\n#ifdef LOCAL\n        if (n < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        if (n > 0) {\n            b = (T*) (::operator new(n * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr2d(int d1 = 0, int d2 = 0) : d1(d1), d2(d2), sz(d1 * d2) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr2d(int d1, int d2, const T& init) : d1(d1), d2(d2), sz(d1 * d2) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr2d(T* b, int d1, int d2) : b(b), d1(d1), d2(d2), sz(d1 * d2) {}\n\n    int size() const {\n        return sz;\n    }\n\n    int dim1() const {\n        return d1;\n    }\n\n    int dim2() const {\n        return d2;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    T* end() {\n        return b + sz;\n    }\n\n    T& operator()(int i1, int i2) {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * d2 + i2];\n    }\n\n    const T& operator()(int i1, int i2) const {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * d2 + i2];\n    }\n\n    arr<T> operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= d1) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return arr<T>(b + at * d2, d2);\n    }\n\n    vector<vector<T>> view() {\n        vector<vector<T>> res(min(d1, 50));\n        for (int i = 0; i < res.size(); ++i) {\n            res[i] = (*this)[i].view();\n        }\n        return res;\n    }\n\n    arr2d<T> clone() {\n        arr2d<T> res(d1, d2);\n        copy(b, b + sz, res.b);\n        return res;\n    }\n};\n\ntemplate <typename T>\nclass arr3d {\n    T* b;\n    int d1;\n    int d2;\n    int d3;\n    int shift;\n    int sz;\n\n    void allocate(int n) {\n#ifdef LOCAL\n        if (n < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        if (n > 0) {\n            b = (T*) (::operator new(n * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr3d(int d1 = 0, int d2 = 0, int d3 = 0) : d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0 || d3 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T;\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr3d(int d1, int d2, int d3, const T& init) : d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0 || d3 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr3d(T* b, int d1, int d2, int d3) : b(b), d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {}\n\n    int size() const {\n        return sz;\n    }\n\n    int dim1() const {\n        return d1;\n    }\n\n    int dim2() const {\n        return d2;\n    }\n\n    int dim3() const {\n        return d3;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    T* end() {\n        return b + sz;\n    }\n\n    T& operator()(int i1, int i2, int i3) {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * shift + i2 * d3 + i3];\n    }\n\n    const T& operator()(int i1, int i2, int i3) const {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * shift + i2 * d3 + i3];\n    }\n\n    arr2d<T> operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= d1) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return arr2d<T>(b + at * shift, d2, d3);\n    }\n\n    vector<vector<vector<T>>> view() {\n        vector<vector<vector<T>>> res(min(d1, 50));\n        for (int i = 0; i < res.size(); ++i) {\n            res[i] = (*this)[i].view();\n        }\n        return res;\n    }\n};\n\ntemplate <typename T>\nclass arr4d {\n    T* b;\n    int d1;\n    int d2;\n    int d3;\n    int d4;\n    int shift1;\n    int shift2;\n    int sz;\n\n    void allocate(int n) {\n#ifdef LOCAL\n        if (n < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        if (n > 0) {\n            b = (T*) (::operator new(n * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr4d(int d1 = 0, int d2 = 0, int d3 = 0, int d4 = 0) : d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),\n                                                            shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0 || d3 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T;\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr4d(int d1, int d2, int d3, int d4, const T& init) : d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),\n                                                           shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0 || d3 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr4d(T* b, int d1, int d2, int d3, int d4) : b(b), d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),\n                                                  shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {\n    }\n\n    int size() const {\n        return sz;\n    }\n\n    int dim1() const {\n        return d1;\n    }\n\n    int dim2() const {\n        return d2;\n    }\n\n    int dim3() const {\n        return d3;\n    }\n\n    int dim4() const {\n        return d4;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    T* end() {\n        return b + sz;\n    }\n\n    T& operator()(int i1, int i2, int i3, int i4) {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3 || i4 < 0 || i4 >= d4) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * shift1 + i2 * shift2 + i3 * d4 + i4];\n    }\n\n    const T& operator()(int i1, int i2, int i3, int i4) const {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3 || i4 < 0 || i4 >= d4) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * shift1 + i2 * shift2 + i3 * d4 + i4];\n    }\n\n    arr3d<T> operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= d1) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return arr3d<T>(b + at * shift1, d2, d3, d4);\n    }\n\n    vector<vector<vector<vector<T>>>> view() {\n        vector<vector<vector<vector<T>>>> res(min(d1, 50));\n        for (int i = 0; i < res.size(); ++i) {\n            res[i] = (*this)[i].view();\n        }\n        return res;\n    }\n};\n\n\ninline bool isWhitespace(int c) {\n    return isspace(c) || c == EOF;\n}\n\nclass Input {\nprivate:\n    bool exhausted = false;\n    int bufSize = 4096;\n    char* buf = new char[bufSize];\n    int bufRead = 0;\n    int bufAt = 0;\n\n    inline int get() {\n        if (exhausted) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return EOF;\n        }\n        if (bufRead == bufAt) {\n            bufRead = fread(buf, sizeof(char), bufSize, stdin);\n            bufAt = 0;\n        }\n        if (bufRead == bufAt) {\n            exhausted = true;\n            return EOF;\n        }\n        return buf[bufAt++];\n    }\n\n    template <typename T>\n    inline T readInteger() {\n        int c = skipWhitespace();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = get();\n        }\n        T res = 0;\n        do {\n            if (!isdigit(c)) {\n#ifdef LOCAL\n                throw \"Number format error\";\n#endif\n                return sgn * res;\n            }\n            res *= 10;\n            res += c - '0';\n            c = get();\n        } while (!isWhitespace(c));\n        return res * sgn;\n    }\n\n    void initArrays(int) {}\n\n    template <typename T, class...Vs>\n    void initArrays(int n, arr<T>& array, Vs& ...vs) {\n        array = arr<T>(n);\n        initArrays(n, vs...);\n    }\n\n    template <typename T, class...Vs>\n    void initArrays(int n, vec<T>&, Vs& ...vs) {\n        initArrays(n, vs...);\n    }\n\n    void readImpl(int) {}\n\n    template <typename T, class...Vs>\n    void readImpl(int i, arr<T>& arr, Vs& ...vs) {\n        arr[i] = readType<T>();\n        readImpl(i, vs...);\n    }\n\n    template <typename T, class...Vs>\n    void readImpl(int i, vec<T>& arr, Vs& ...vs) {\n        arr.push_back(readType<T>());\n        readImpl(i, vs...);\n    }\n\npublic:\n    inline int skipWhitespace() {\n        int c;\n        while (isWhitespace(c = get()) && c != EOF);\n        if (c == EOF) {\n            exhausted = true;\n        }\n        return c;\n    }\n\n    inline int readInt() {\n        return readInteger<int>();\n    }\n\n    ll readLong() {\n        return readInteger<ll>();\n    }\n\n    string readString() {\n        int c = skipWhitespace();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return \"\";\n        }\n        vec<char> res;\n        do {\n            res.push_back(c);\n        } while (!isWhitespace(c = get()));\n        return string(all(res));\n    }\n\n    arri readIntArray(int size) {\n        return readArray<int>(size);\n    }\n\n    arr<ll> readLongArray(int size) {\n        return readArray<ll>(size);\n    }\n\n    arr<double> readDoubleArray(int size) {\n        return readArray<double>(size);\n    }\n\n    arr<string> readStringArray(int size) {\n        return readArray<string>(size);\n    }\n\n    arr<char> readCharArray(int size) {\n        return readArray<char>(size);\n    }\n\n    template <typename T>\n    T readType() {\n        throw \"Operation not supported\";\n    }\n\n    template <typename U, typename V>\n    pair<U, V> readType() {\n        U first = readType<U>();\n        V second = readType<V>();\n        return make_pair(first, second);\n    }\n\n    template <typename T>\n    arr<T> readArray(int n) {\n        arr<T> res(n, T());\n        for (int i = 0; i < n; i++) {\n            res[i] = readType<T>();\n        }\n        return res;\n    }\n\n\n    template <class...Vs>\n    void readArrays(int n, Vs& ...vs) {\n        initArrays(n, vs...);\n        for (int i = 0; i < n; i++) {\n            readImpl(i, vs...);\n        }\n    }\n\n    template <typename U, typename V>\n    arr<pair<U, V>> readArray(int n) {\n        arr<pair<U, V>> res(n);\n        for (int i = 0; i < n; i++) {\n            res[i] = readType<U, V>();\n        }\n        return res;\n    }\n\n    template <typename T>\n    arr2d<T> readTable(int rows, int cols) {\n        arr2d<T> result(rows, cols);\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < cols; ++j) {\n                result(i, j) = readType<T>();\n            }\n        }\n        return result;\n    }\n\n    arr2d<int> readIntTable(int rows, int cols) {\n        return readTable<int>(rows, cols);\n    }\n\n    arr2d<char> readCharTable(int rows, int cols) {\n        return readTable<char>(rows, cols);\n    }\n\n    string readLine() {\n        int c = get();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return \"\";\n        }\n        vec<char> res;\n        do {\n            res.push_back(c);\n            c = get();\n        } while (c != '\\n' && c != '\\r' && c != EOF);\n        return string(all(res));\n    }\n\n    double readDouble() {\n        int c = skipWhitespace();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = get();\n        }\n        double res = 0;\n        do {\n            if (tolower(c) == 'e') {\n                return sgn * res * dPower(double(10), readInt());\n            }\n            if (!isdigit(c)) {\n#ifdef LOCAL\n                throw \"Number format error\";\n#endif\n                return sgn * res;\n            }\n            res *= 10;\n            res += c - '0';\n            c = get();\n        } while (!isWhitespace(c) && c != '.');\n        if (c == '.') {\n            double add = 0;\n            int length = 0;\n            c = get();\n            do {\n                if (tolower(c) == 'e') {\n                    return sgn * (res + add * dPower(double(10), -length)) * dPower(double(10), readInt());\n                }\n                if (!isdigit(c)) {\n#ifdef LOCAL\n                    throw \"Number format error\";\n#endif\n                    res += add * dPower(10, -length);\n                    return res * sgn;\n                }\n                add *= 10;\n                add += c - '0';\n                length++;\n                c = get();\n            } while (!isWhitespace(c));\n            res += add * dPower(double(10), -length);\n        }\n        return res * sgn;\n    }\n\n    char readChar() {\n        int c = skipWhitespace();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return 0;\n        }\n        return c;\n    }\n\n    bool isExhausted() { return exhausted; }\n\n    void setBufSize(int newBufSize) {\n        if (newBufSize > bufSize) {\n            char* newBuf = new char[newBufSize];\n            memcpy(newBuf, buf, bufSize);\n            buf = newBuf;\n        }\n        bufSize = newBufSize;\n    }\n};\n\ntemplate <>\ndouble Input::readType() {\n    return readDouble();\n}\n\ntemplate <>\nint Input::readType() {\n    return readInt();\n}\n\ntemplate <>\nll Input::readType() {\n    return readLong();\n}\n\ntemplate <>\nchar Input::readType() {\n    return readChar();\n}\n\ntemplate <>\nstring Input::readType() {\n    return readString();\n}\n\nInput in;\n\n\nclass Output {\nprivate:\n    ostream& out = cout;\n\n    template <typename T>\n    void printSingle(const T& value) {\n        out << value;\n    }\n\n    template <typename T>\n    void printSingle(const vec<T>& array) {\n        size_t n = array.size();\n        for (int i = 0; i < n; ++i) {\n            out << array[i];\n            if (i + 1 != n) {\n                out << ' ';\n            }\n        }\n    }\n\n    template <typename T>\n    void printSingle(const arr<T>& array) {\n        size_t n = array.size();\n        for (int i = 0; i < n; ++i) {\n            out << array[i];\n            if (i + 1 != n) {\n                out << ' ';\n            }\n        }\n    }\n\n    template <typename T>\n    void printSingle(const arr2d<T>& array) {\n        size_t n = array.dim1();\n        size_t m = array.dim2();\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                out << array(i, j);\n                if (j + 1 != m) {\n                    out << ' ';\n                }\n            }\n            if (i + 1 != n) {\n                out << '\\n';\n            }\n        }\n    }\n\n    template <typename T, typename U>\n    void printSingle(const pair<T, U>& value) {\n        out << value.first << ' ' << value.second;\n    }\n\npublic:\n    Output() {//ostream& out) : out(out) {\n        out << fixed << setprecision(20);\n    }\n\n    void print() {}\n\n    template <typename T, typename...Targs>\n    void print(const T& first, const Targs... args) {\n        printSingle(first);\n        if (sizeof...(args) != 0) {\n            out << ' ';\n            print(args...);\n        }\n    }\n\n    template <typename...Targs>\n    void printLine(const Targs... args) {\n        print(args...);\n        out << '\\n';\n    }\n\n    void flush() {\n        out.flush();\n    }\n};\n\nOutput out;\n\n\nclass ReverseNumberIterator : public NumberIterator {\npublic:\n    ReverseNumberIterator(int v) : NumberIterator(v) {}\n\n    ReverseNumberIterator& operator++() {\n        --v;\n        return *this;\n    }\n};\n\nclass RevRange : pii {\npublic:\n    RevRange(int begin, int end) : pii(begin - 1, min(begin, end) - 1) {}\n\n    RevRange(int n) : pii(n - 1, min(n, 0) - 1) {}\n\n    ReverseNumberIterator begin() {\n        return first;\n    }\n\n    ReverseNumberIterator end() {\n        return second;\n    }\n};\n\n\ntemplate <typename T>\ninline void unique(vec<T>& v) {\n    v.resize(unique(all(v)) - v.begin());\n}\n\narri createOrder(int n) {\n    arri order(n);\n    for (int i = 0; i < n; i++) {\n        order[i] = i;\n    }\n    return order;\n}\n\narri inverse(const arri& p) {\n    arri res(p.size());\n    for (int i : range(p.size())) {\n        res[p[i]] = i;\n    }\n    return res;\n}\n\ntemplate <typename T, typename Iterator>\ninline void addAll(vec<T>& v, Iterator begin, Iterator end) {\n    v.insert(v.end(), begin, end);\n}\n\ntemplate <class Collection, typename Iterator>\ninline void addAll(Collection& v, Iterator begin, Iterator end) {\n    v.insert(begin, end);\n}\n\ntemplate <typename Iterator>\narri getQty(Iterator begin, Iterator end, int length) {\n    arri res(length, 0);\n    for (Iterator it = begin; it != end; it++) {\n        res[*it]++;\n    }\n    return res;\n}\n\ntemplate <typename Iterator>\narri getQty(Iterator begin, Iterator end) {\n    return getQty(begin, end, *max_element(begin, end) + 1);\n}\n\ntemplate <class Collection>\nvoid collect(Collection&) {}\n\ntemplate <class Collection, class Other, class ...Vs>\nvoid collect(Collection& all, Other& a, Vs& ...vs) {\n    addAll(all, all(a));\n    collect(all, vs...);\n}\n\nvoid replace(const vi&) {}\n\ntemplate <class ...Vs>\nvoid replace(const vi& all, vi& a, Vs& ...vs) {\n    for (int& i : a) {\n        i = lower_bound(all(all), i) - all.begin();\n    }\n    replace(all, vs...);\n}\n\ntemplate <class ...Vs>\nvoid replace(const vi& all, arri& a, Vs& ...vs) {\n    for (int& i : a) {\n        i = lower_bound(all(all), i) - all.begin();\n    }\n    replace(all, vs...);\n}\n\ntemplate <class ...Vs>\nvi compress(Vs& ...vs) {\n    vi vals;\n    collect(vals, vs...);\n    sort(all(vals));\n    unique(vals);\n    replace(vals, vs...);\n    return vals;\n}\n\n\nclass DSU {\n    mutable arri id;\n    arri sz;\n    int count;\n\npublic:\n    DSU(int n) {\n        id = createOrder(n);\n        sz = arri(n, 1);\n        count = n;\n    }\n\n    int get(int i) const {\n        if (id[i] == i) {\n            return i;\n        }\n        return id[i] = get(id[i]);\n    }\n\n    int operator[](int i) const { return get(i); }\n\n    int size(int i) const { return sz[get(i)]; }\n\n    int setCount() const { return count; }\n\n    bool join(int a, int b) {\n        a = get(a);\n        b = get(b);\n        if (a == b) {\n            return false;\n        }\n        sz[a] += sz[b];\n        sz[b] = 0;\n        id[b] = a;\n        count--;\n        return true;\n    }\n\n    void reset() {\n        count = sz.size();\n        for (int i : range(count)) {\n            id[i] = i;\n            sz[i] = 1;\n        }\n    }\n};\n\n\ntemplate <typename W, typename C>\nclass WeightedFlowEdge {\nprivate:\n    WeightedFlowEdge<W, C>* reverseEdge;\n\npublic:\n    const int from;\n    const int to;\n    W weight;\n    C capacity;\n    int id;\n\n    WeightedFlowEdge(int from, int to, W weight, C capacity) : from(from), to(to), weight(weight), capacity(capacity) {\n        reverseEdge = new WeightedFlowEdge(this);\n    }\n\n    WeightedFlowEdge<W, C>* transposed() { return nullptr; }\n\n    WeightedFlowEdge<W, C>* reverse() { return reverseEdge; }\n\n    void push(C flow) {\n        capacity -= flow;\n        reverseEdge->capacity += flow;\n    }\n\n    C flow() const {\n        return reverseEdge->capacity;\n    }\n\nprivate:\n    WeightedFlowEdge(WeightedFlowEdge<W, C>* reverse) : from(reverse->to), to(reverse->from), weight(-reverse->weight),\n                                                        capacity(0) {\n        reverseEdge = reverse;\n    }\n};\n\ntemplate <typename C>\nclass FlowEdge {\nprivate:\n    FlowEdge<C>* reverseEdge;\n\npublic:\n    const int from;\n    const int to;\n    C capacity;\n    int id;\n\n    FlowEdge(int from, int to, C capacity) : from(from), to(to), capacity(capacity) {\n        reverseEdge = new FlowEdge(this);\n    }\n\n    FlowEdge<C>* transposed() { return nullptr; }\n\n    FlowEdge<C>* reverse() { return reverseEdge; }\n\n    void push(C flow) {\n        capacity -= flow;\n        reverseEdge->capacity += flow;\n    }\n\n    C flow() const {\n        return reverseEdge->capacity;\n    }\n\nprivate:\n    FlowEdge(FlowEdge<C>* reverse) : from(reverse->to), to(reverse->from), capacity(0) {\n        reverseEdge = reverse;\n    }\n};\n\ntemplate <typename W>\nclass WeightedEdge {\npublic:\n    const int from;\n    const int to;\n    W weight;\n    int id;\n\n    WeightedEdge(int from, int to, W weight) : from(from), to(to), weight(weight) {\n    }\n\n    WeightedEdge<W>* transposed() { return nullptr; }\n\n    WeightedEdge<W>* reverse() { return nullptr; }\n};\n\ntemplate <typename W>\nclass BiWeightedEdge {\nprivate:\n    BiWeightedEdge<W>* transposedEdge;\n\npublic:\n    const int from;\n    const int to;\n    W weight;\n    int id;\n\n    BiWeightedEdge(int from, int to, W weight) : from(from), to(to), weight(weight) {\n        transposedEdge = new BiWeightedEdge(this);\n    }\n\n    BiWeightedEdge<W>* transposed() { return transposedEdge; }\n\n    BiWeightedEdge<W>* reverse() { return nullptr; }\n\nprivate:\n    BiWeightedEdge(BiWeightedEdge<W>* transposed) : from(transposed->to), to(transposed->from),\n                                                    weight(transposed->weight) {\n        transposedEdge = transposed;\n    }\n};\n\nclass BaseEdge {\npublic:\n    const int from;\n    const int to;\n    int id;\n\n    BaseEdge(int from, int to) : from(from), to(to) {\n    }\n\n    BaseEdge* transposed() { return nullptr; }\n\n    BaseEdge* reverse() { return nullptr; }\n};\n\nclass BiEdge {\nprivate:\n    BiEdge* transposedEdge;\n\npublic:\n    const int from;\n    const int to;\n    int id;\n\n    BiEdge(int from, int to) : from(from), to(to) {\n        transposedEdge = new BiEdge(this);\n    }\n\n    BiEdge* transposed() { return transposedEdge; }\n\n    BiEdge* reverse() { return nullptr; }\n\nprivate:\n    BiEdge(BiEdge* transposed) : from(transposed->to), to(transposed->from) {\n        transposedEdge = transposed;\n    }\n};\n\ntemplate <class Edge>\nclass Graph {\npublic:\n    int vertexCount;\n    int edgeCount = 0;\nprivate:\n    vec<vec<Edge*>> edges;\n\npublic:\n    Graph(int vertexCount) : vertexCount(vertexCount), edges(vertexCount, vec<Edge*>()) {}\n\n    void addEdge(Edge* edge) {\n#ifdef LOCAL\n        if (edge->from < 0 || edge->to < 0 || edge->from >= vertexCount || edge->to >= vertexCount) {\n            throw \"Out of bounds\";\n        }\n#endif\n        edge->id = edgeCount;\n        edges[edge->from].push_back(edge);\n        Edge* reverse = edge->reverse();\n        if (reverse != nullptr) {\n            reverse->id = edgeCount;\n            edges[reverse->from].push_back(reverse);\n        }\n        Edge* transposed = edge->transposed();\n        if (transposed != nullptr) {\n            edges[transposed->from].push_back(transposed);\n            transposed->id = edgeCount;\n            Edge* transRev = transposed->reverse();\n            if (transRev != nullptr) {\n                edges[transRev->from].push_back(transRev);\n                transRev->id = edgeCount;\n            }\n        }\n        edgeCount++;\n    }\n\n    template <typename...Ts>\n    void addEdge(Ts...args) {\n        addEdge(new Edge(args...));\n    }\n\n    vec<Edge*>& operator[](int at) {\n        return edges[at];\n    }\n\n    void addVertices(int count) {\n        vertexCount += count;\n        edges.resize(vertexCount);\n    }\n};\n\n\nclass ETopology {\npublic:\n    void solve() {\n        int n = in.readInt();\n        auto a = in.readCharArray(1 << n);\n\n        auto shift = [&](int mask, int dir) -> int {\n            if (dir >= 0) {\n                return mask << dir;\n            }\n            return mask >> (-dir);\n        };\n        auto okay = [&](int up, int down, int vert) -> bool {\n            for (int i : range(1 << n)) {\n                int left = -n;\n                int last = -n - 1;\n                for (int j : range(n + 1)) {\n                    if (vert >> j & 1) {\n                        maxim(left, last - j + 1);\n                    }\n                    if (i >> j & 1) {\n                        last = j;\n                    }\n                }\n                int right = n;\n                last = 2 * n;\n                for (int j : RevRange(n + 1)) {\n                    if (i >> j & 1) {\n                        last = j;\n                    }\n                    if (vert >> j & 1) {\n                        minim(right, last - j);\n                    }\n                }\n                bool can = false;\n                for (int j : range(left, right + 1)) {\n                    if (!(shift(up, j) & i) || !(shift(down, j) & i)) {\n                        can = true;\n                        break;\n                    }\n                }\n                if (can ^ (a[i] == '1')) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        DSU dsu(2 * n + 2);\n        for (int i : range(1 << n)) {\n            for (int j : range(i + 1)) {\n                for (int k : range(1 << (n + 1))) {\n                    dsu.reset();\n                    for (int l : range(n + 1)) {\n                        if ((i >> l & 1) && dsu.join(l, l + 1)) {\n                        }\n                        if ((j >> l & 1) && dsu.join(n + 1 + l, n + 1 + l + 1)) {\n                        }\n                        if ((k >> l & 1) && dsu.join(l, n + 1 + l)) {\n                        }\n                    }\n                    int times = 0;\n                    bool good = true;\n                    for (int l : range(2 * n + 2)) {\n                        if (dsu[l] == l && dsu.size(l) > 1) {\n                            times++;\n                        }\n                    }\n                    if (times <= 1 && okay(i, j, k)) {\n                        out.printLine(\"Possible\");\n                        if (!i && !j && !k) {\n                            out.printLine(0);\n                            out.printLine(0, 0);\n                            return;\n                        }\n                        dsu.reset();\n                        Graph<BiEdge> graph(2 * n + 2);\n                        for (int l : range(n + 1)) {\n                            if ((i >> l & 1) && dsu.join(l, l + 1)) {\n                                graph.addEdge(l, l + 1);\n                            }\n                            if ((j >> l & 1) && dsu.join(n + 1 + l, n + 1 + l + 1)) {\n                                graph.addEdge(n + 1 + l, n + 1 + l + 1);\n                            }\n                            if ((k >> l & 1) && dsu.join(l, n + 1 + l)) {\n                                graph.addEdge(l, n + 1 + l);\n                            }\n                        }\n                        vec<pii> ans;\n                        for (int l : range(2 * n + 2)) {\n                            if (dsu.size(l) > 1) {\n                                function<void(int, int)> dfs = [&](int vert, int last) {\n                                    ans.emplace_back(vert % (n + 1), vert / (n + 1));\n                                    for (auto* e : graph[vert]) {\n                                        int next = e->to;\n                                        if (next == last) {\n                                            continue;\n                                        }\n                                        dfs(next, vert);\n                                        ans.emplace_back(vert % (n + 1), vert / (n + 1));\n                                    }\n                                };\n                                dfs(l, -1);\n                                break;\n                            }\n                        }\n                        out.printLine(ans.size() - 1);\n                        for (const auto& p : ans) {\n                            out.printLine(p);\n                        }\n                        return;\n                    }\n                }\n            }\n        }\n        out.printLine(\"Impossble\");\n    }\n};\n\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ETopology solver;\n\n\n    solver.solve();\n    fflush(stdout);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <string>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> Pii;\n\nconst ll mod = 1000000007;\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  string s;\n  cin >> s\n\n  cout << \"Impossible\" << endl;\n  return 0;\n\n  vector<bool> a(1 << n);\n  for (int i = 0; i < (1 << n); i++) a[i] = s[i] - '0';\n\n  for (int i = 0; i < (1 << n); i++) {\n    bool good = true;\n    for (int j = 0; j < (1 << n); j++) {\n      bool obscured = false;\n      for (int k = 0; k < n; k++) {\n        bool point = j & (1 << k);\n        if (point && (i & (1 << k))) {\n          obscured = true;\n          break;\n        }\n      }\n      if (obscured == a[j]) {\n        good = false;\n        break;\n      }\n    }\n    if (good) {\n      vector<Pii> loop;\n      bool up = false;\n      for (int j = 0; j < n; j++) {\n        if (!up) {\n          loop.emplace_back(j, 0);\n          if (i & (1 << j)) {\n            loop.emplace_back(j, 1);\n            up = true;\n          }\n        }\n        else {\n          loop.emplace_back(j, 1);\n          if (!(i & (1 << j))) {\n            loop.emplace_back(j, 0);\n            up = false;\n          }\n        }\n      }\n      if (up) loop.emplace_back(n, 1);\n      for (int j = n; j >= 0; j--) loop.emplace_back(j, 0);\n\n      cout << \"Possible\" << endl;\n      cout << loop.size() - 1 << endl;\n      for (auto &x: loop) cout << x.first << \" \" << x.second << endl;\n      return 0;\n    }\n  }\n\n  cout << \"Impossible\" << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define all(x) x.begin(),x.end()\n#define cmin(a,b) (a>b?a=b:a)\n#define cmax(a,b) (a<b?a=b:a)\n#define mem(a,k) memset(a,k,sizeof(a))\n#define lop(i,s,t) for(int i=s;i<(t);++i)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define fore(i,v) for(int i=g[v],d=es[i].d;i;i=es[i].nxt,d=es[i].d)\nusing namespace std;\n\n#ifdef CURIOUSCAT\n#define Pr(f,...) fprintf(stderr,f,##__VA_ARGS__),fflush(stderr)\n#else\n#define Pr(f,...) ;\n#endif\n\ntypedef long long ll;\n\ntemplate<typename T>\nvoid read(T &x){\n\tx=0; \n\tchar c;\n\tfor(c=getchar();!isdigit(c);c=getchar()); \n\tfor(;isdigit(c);c=getchar())x=x*10+c-'0'; \n}\n\nconst int N=1e6+50;\n\nint P;\nint mul(int a,int b){ return 1ll*a*b%P; }\nint add(int a,int b){ a+=b; return a>=P?a-P:a; }\nvoid upd(int &a,int b) { a=a+b>=P?a+b-P:a+b; }\nint sub(int a,int b){ a-=b; return a<0?a+P:a; }\nint gcd(int a,int b){ return !b?a:gcd(b,a%b); }\n\nint n;\nchar a[1<<9];\nint main(int argc,char *argv[]){\n#ifdef CURIOUSCAT\n#endif\n\tread(n); \n\tlop(s,0,(1<<n)){\n\t\tscanf(\" %c\",&a[s]); a[s]-='0';\n\t}\n\tlop(s,0,(1<<n)){\n\t\tint c0=0,c1=0;\n\t\tlop(i,0,n)if(s>>i&1){\n\t\t\tif(a[1<<i])++c1;else ++c0;\n\t\t}\n\t\tif((c0&&a[s])||(!c0&&!a[s])){\n\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\treturn 0; \n\t\t}\n\t}\n\tint cnt=0;\n\tlop(i,0,n)cnt+=!a[1<<i];\n\tcout<<\"Possible\"<<endl;\n\tif(cnt==0){\n\t\tcout<<0<<endl;\n\t\tcout<<1<<\" \"<<1<<endl;\n\t}else{\n\t\tvector<pair<int,int>> ans;\n\t\tans.pb(mp(0,0));\n\t\tfor(int i=0,p;i<n;i=p){\n\t\t\tif(!a[1<<i]){\n\t\t\t\tfor(p=i;p<n&&!a[1<<p];++p);\n\t\t\t\tans.pb(mp(i,1));\n\t\t\t\tlop(z,0,p-i)ans.pb(mp(i+z+1,1));\n\t\t\t}else{\n\t\t\t\tfor(p=i;p<n&&a[1<<p];++p);\n\t\t\t\tans.pb(mp(i,0)); \n\t\t\t\tlop(z,0,p-i)ans.pb(mp(i+z+1,0));\n\t\t\t}\n\t\t}\n\t\tif(a[1<<(n-1)]){\n\t\t\tdec(i,n-1,0)ans.pb(mp(i,0));\n\t\t}else{\n\t\t\tdec(i,n,0)ans.pb(mp(i,0)); \n\t\t}\n\t\tprintf(\"%d\\n\",(int)ans.size()-1);\n\t\tfor(auto x:ans)printf(\"%d %d\\n\",x.fi,x.sc); \n\t}\n\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\n#include <assert.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\nconst int MOD=1e9+7;\n#define SZ 666666\nint n;\nchar a[SZ];\nbool v[SZ];\nvi neg(vi x)\n{\n\treverse(x.begin(),x.end());\n\tfor(auto&y:x) y=-y;\n\treturn x;\n}\nvi operator + (vi a,const vi&b)\n{\n\tfor(auto x:b) a.pb(x);\n\treturn a;\n}\nvi operator - (vi a,const vi&b)\n{\n\treturn a+neg(b);\n}\nvi cs(vi a,int l,int r)\n{\n\tif(l==r)\n\t\treturn {a[l]};\n\tint m=(l+r)>>1;\n\tvi L=cs(a,l,m),R=cs(a,m+1,r);\n\treturn L+R-L-R;\n}\nvi CL(vi t)\n{\n\treturn t;\n}\nvi v1{1},v2{2};\nvi AND(vi p,vi q)\n{\n\treturn CL(p+p+v1+p+p-v1+v2-q-v2-q+v2-q-v2-q);\n}\nint main()\n{\n\tcin>>n>>a;\n\tbool ok=1;\n\tvi g;\n\tfor(int i=0;i<(1<<n);++i) if(a[i]=='0'&&!v[i])\n\t{\n\t\tfor(int j=0;j<(1<<n);++j) if((j&i)==i)\n\t\t\tv[j]=1,ok&=a[j]=='0';\n\t\tvi t;\n\t\tfor(int j=0;j<n;++j) if(i&(1<<j)) t.pb(j+1);\n\t\tvi w=cs(t,0,t.size()-1);\n\t\tg=g+w;\n\t}\n\tif(!ok)\n\t{\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tputs(\"Possible\");\n\tvector<pii> v;\n\tv.pb(pii(0,0));\n\tfor(auto c:g)\n\t{\n\t\tint x=abs(c);\n\t\tif(c>0)\n\t\t{\n\t\t\tv.pb(pii(x-1,0));\n\t\t\tv.pb(pii(x-1,1));\n\t\t\tv.pb(pii(x,1));\n\t\t\tv.pb(pii(x,0));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tv.pb(pii(x,0));\n\t\t\tv.pb(pii(x,1));\n\t\t\tv.pb(pii(x-1,1));\n\t\t\tv.pb(pii(x-1,0));\n\t\t}\n\t}\n\tv.pb(pii(0,0));\n\tvector<pii> vt;\n\tfor(int i=0;i<v.size();++i)\n\t{\n\t\tpii A=v[i],B=v[(i+1)%v.size()];\n\t\tvt.pb(A);\n\t\tint g=abs(A.fi-B.fi)+abs(A.se-B.se);\n\t\tif(g)\n\t\t{\n\t\t\tfor(int j=1;j<=g;++j)\n\t\t\t{\n\t\t\t\tpii s(A.fi+(B.fi-A.fi)/g*j,\n\t\t\t\tA.se+(B.se-A.se)/g*j);\n\t\t\t\tvt.pb(s);\n\t\t\t}\n\t\t}\n\t}\n\tvt.erase(unique(vt.begin(),vt.end()),vt.end());\n\tv=vt;\n\tprintf(\"%d\\n\",int(v.size())-1);\n\tfor(auto c:v) printf(\"%d %d\\n\",c.fi,c.se);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define INF ((1<<30)-1)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nvoid ok(){\n    cout << \"Yes\" << endl;\n    exit(0);\n}\n\nvoid ng(){\n    cout <<  \"Impossible\" << endl;\n    exit(0);\n}\n\n\nint n;\nint a[1 << 8];\n\nvector<int> loops;\n\nvoid entangle(int x){\n    vector<int> loop;\n    for(int i = n-1;i >= 0;i--){\n        if((x >> i) % 2 == 0)continue;\n        if(loop.empty()){\n            loop.push_back(i+1);\n            loop.push_back(-i-1);\n        }\n        else{\n            vector<int> tmp;\n            tmp.push_back(i+1);\n            tmp.push_back(-i-1);\n            for(auto it = loop.begin();it != loop.end();it++)tmp.push_back(*it);\n            tmp.push_back(i+1);\n            for(auto it = loop.rbegin();it != loop.rend();it++)tmp.push_back(*it);\n            loop = tmp;\n        }\n    }\n    loop.push_back(INF);\n    for(auto elem:loop)loops.push_back(elem);\n}\n\nvoid show(){\n    cout << \"Possible\" << endl;\n    vector<P> ps;\n    ps.push_back(P(0,0));\n    int nowx = 0, nowy = 0;\n    for(int x:loops){\n        if(x == INF){\n            while(nowx > 0){\n                ps.push_back(P(--nowx, nowy));\n            }\n            continue;\n        }\n        if(x > 0){\n            while(nowx > x){\n                ps.push_back(P(--nowx, nowy));\n            }\n            while(nowx < x-1){\n                ps.push_back(P(++nowx, nowy));\n            }\n            ps.push_back(P(nowx,++nowy));\n            if(nowx == x)ps.push_back(P(--nowx, nowy));\n            else ps.push_back(P(++nowx, nowy));\n            ps.push_back(P(nowx,--nowy));\n        }\n        if(x < 0){\n            x = x * -1;\n            while(nowx > x){\n                ps.push_back(P(--nowx, nowy));\n            }\n            while(nowx < x-1){\n                ps.push_back(P(++nowx, nowy));\n            }\n            if(nowx == x)ps.push_back(P(--nowx, nowy));\n            else ps.push_back(P(++nowx, nowy));\n        }\n    }\n    cout << ps.size() - 1 << endl;\n    for(auto p:ps){\n        cout << p.first << \" \" << p.second << endl;\n    }\n}\n\nint main(){\n    cin >> n;\n    for(int i = 0;i < (1<<n);i++){\n        scanf(\"%1d\", a+i);\n        bool bad;\n        if(a[i] == 0)bad = true;\n        for(int j = 0;j < i;j++){\n            if((j & i) != j)continue;\n            if(a[i] == 1 && a[j] == 0){\n                ng();                    \n            }\n            if(a[j] == 0)bad = false;\n        }\n        if(bad){\n            entangle(i);\n        }\n    }\n    show();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n;\nchar p[260];\nstruct point {\n\tint x, ck, dir;\n};\nvector<point>Res;\nvoid Add(int x, int mask, int rev) {\n\tif (mask == 1) {\n\t\tRes.push_back({ x,rev,0 });\n\t\tRes.push_back({ x,!rev,1 });\n\t\treturn;\n\t}\n\tif (!(mask&1)) {\n\t\tRes.push_back({ x,rev,0 });\n\t\tAdd(x + 1, mask>>1, rev);\n\t\tRes.push_back({ x,rev,1 });\n\t\treturn;\n\t}\n\tRes.push_back({ x,rev,0 });\n\tAdd(x + 1, mask >> 1, rev);\n\tRes.push_back({ x,rev,1 });\n\tRes.push_back({ x,!rev,0 });\n\tAdd(x + 1, mask >> 1, !rev);\n\tRes.push_back({ x,!rev,1 });\n}\nstruct PP {\n\tint x, y;\n};\nvector<PP>RR;\nvoid Print(point a) {\n\tPP t1 = { a.x + a.dir, a.ck };\n\tPP t2 = { a.x + 1 - a.dir, a.ck };\n\tif (!RR.empty() && RR.back().x == t1.x && RR.back().y == t2.y) {\n\t\tRR.push_back(t2);\n\t}\n\telse {\n\t\tRR.push_back(t1);\n\t\tRR.push_back(t2);\n\t}\n}\nint main() {\n\tint i, j;\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", p);\n\tfor (i = 0; i < (1 << n); i++) {\n\t\tint c = 0;\n\t\tif (p[i] == '0')c++;\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif ((i&j) == j) {\n\t\t\t\tif (p[j] == '0' && p[i] == '1') {\n\t\t\t\t\tputs(\"Impossible\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (p[j] == '0')c--;\n\t\t\t}\n\t\t}\n\t\tif (c == 1) {\n\t\t\tAdd(0, i, 0);\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tfor (auto &t : Res) {\n\t\tPrint(t);\n\t}\n\tif (RR.back().x == RR[0].x && RR.back().y == RR[0].y)RR.pop_back();\n\tprintf(\"%d\\n\", RR.size());\n\tRR.push_back(RR[0]);\n\tfor(auto &t :RR)printf(\"%d %d\\n\", t.x, t.y);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 15;\nconst int MAXS = 1 << 8;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nvector <pair <int, int>> ans, tmp;\nint n, bit[MAXN]; bool flg[MAXS]; char s[MAXN];\nvoid augment(vector <pair <int, int>> &res, int x) {\n\tif (res.size() == 0) {\n\t\tres.emplace_back(x, 0);\n\t\tres.emplace_back(x, 1);\n\t\treturn;\n\t}\n\tvector <pair <int, int>> tmp;\n\ttmp.emplace_back(x, 0);\n\tfor (auto x : res) tmp.push_back(x);\n\ttmp.emplace_back(x, 0);\n\treverse(tmp.begin(), tmp.end());\n\ttmp.emplace_back(x, 1);\n\tfor (auto x : res) tmp.push_back(x);\n\ttmp.emplace_back(x, 1);\n\tres = tmp;\n}\nvoid work(int mask) {\n\ttmp.clear(); int cur = 0;\n\tfor (int i = n; i >= 1; i--)\n\t\tif (mask & bit[i]) augment(tmp, i);\n\tfor (auto x : tmp) {\n\t\tif (x.second == 0) {\n\t\t\tif (cur >= x.first) while (cur >= x.first) ans.emplace_back(--cur, 0);\n\t\t\telse while (cur < x.first) ans.emplace_back(++cur, 0);\n\t\t} else {\n\t\t\tif (cur >= x.first) {\n\t\t\t\twhile (cur >= x.first + 1) ans.emplace_back(--cur, 0);\n\t\t\t\tans.emplace_back(cur, 1);\n\t\t\t\tans.emplace_back(--cur, 1);\n\t\t\t\tans.emplace_back(cur, 0);\n\t\t\t} else {\n\t\t\t\twhile (cur < x.first - 1) ans.emplace_back(++cur, 0);\n\t\t\t\tans.emplace_back(cur, 1);\n\t\t\t\tans.emplace_back(++cur, 1);\n\t\t\t\tans.emplace_back(cur, 0);\n\t\t\t}\n\t\t}\n\t}\n\twhile (cur > 0) ans.emplace_back(--cur, 0);\n}\nint main() {\n\tread(n), scanf(\"\\n%s\", s);\n\tfor (int i = 1; i <= n; i++)\n\t\tbit[i] = 1 << (i - 1);\n\tint goal = 1 << n;\n\tfor (int i = 0; i < goal; i++)\n\tfor (int j = 0; j < i; j++)\n\t\tif ((i & j) == j && s[j] == '0') flg[i] = true;\n\tfor (int i = 0; i < goal; i++)\n\t\tif (s[i] == '1' && flg[i]) {\n\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\tputs(\"Possible\");\n\tfor (int i = 0; i < goal; i++)\n\t\tif (s[i] == '0' && !flg[i]) work(i);\n\tcout << ans.size() << endl;\n\tprintf(\"%d %d\\n\", 0, 0);\n\tfor (auto x : ans)\n\t\tprintf(\"%d %d\\n\", x.first, x.second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\ntypedef pair<i64, i64> pi64;\ntypedef double ld;\n\ntemplate<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\nvi sift(vi a, int x) {\n    vi b;\n    for (int y: a) if (abs(y) != x) b.pb(y);\n    return b;\n}\n\nbool trivial(vi a) {\n    vi st;\n    for (int x: a) {\n        if (st.empty() || st.back() + x) st.pb(x);\n        else st.pop_back();\n    }\n    return st.empty();\n}\n\nint n, l;\n\nbool good(vi a) {\n    if (trivial(a)) return false;\n    for1(i, n) if (!trivial(sift(a, i))) return false;\n    return true;\n}\n\nvi best;\n\nvoid rec(vi &a) {\n    if (a.size() >= best.size()) return;\n    if (good(a)) {\n        best = a;\n        return;\n    }\n    for1(i, n) {\n        a.pb(i);\n        rec(a);\n        a.pop_back();\n\n        a.pb(-i);\n        rec(a);\n        a.pop_back();\n    }\n}\n\nvoid act(vi v, vector<pii> &p) {\n    for (int x: v) {\n        for1(i, abs(x) - 1) p.pb({i, 0});\n        if (x > 0) {\n            p.pb({x, 0});\n            p.pb({x, 1});\n            p.pb({x - 1, 1});\n            p.pb({x - 1, 0});\n        } else {\n            p.pb({-x - 1, 1});\n            p.pb({-x, 1});\n            p.pb({-x, 0});\n            p.pb({-x - 1, 0});\n        }\n        ford(i, abs(x) - 1) p.pb({i, 0});\n    }\n}\n\nvi seq(vi c) {\n    if (c.size() == 1) return c;\n    int x = c.back();\n    c.pop_back();\n    vi res = seq(c);\n    vi ans = res;\n    ans.pb(x);\n    reverse(all(res));\n    for (int y: res) ans.pb(-y);\n    ans.pb(-x);\n    return ans;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(\"input.txt\", \"rt\", stdin);\n#endif\n\n    int n;\n    string s;\n    cin >> n >> s;\n    vi good(1 << n);\n    forn(i, 1 << n) good[i] = s[i] - '0';\n\n    bool ok = good[0];\n    forn(i, 1 << n) forn(j, n) {\n        if ((i >> j) & 1) continue;\n        if (!good[i] && good[i | (1 << j)]) ok = false;\n    }\n\n    if (!ok) cout << \"Impossible\\n\";\n    else {\n        cout << \"Possible\\n\";\n        vector<pii> ans = {{0, 0}};\n        forn(i, 1 << n) {\n            if (good[i]) continue;\n            bool ok = true;\n            forn(j, n) if ((i >> j) & 1) ok &= good[i ^ (1 << j)];\n            if (!ok) continue;\n            vi c;\n            forn(j, n) if ((i >> j) & 1) c.pb(j + 1);\n            act(seq(c), ans);\n        }\n        cout << ans.size() - 1 << '\\n';\n        for (auto w: ans) cout << w.fi << ' ' << w.se << '\\n';\n    }\n\n#ifdef LOCAL_DEFINE\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define INF ((1<<30)-1)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nvoid ok(){\n    cout << \"Yes\" << endl;\n    exit(0);\n}\n\nvoid ng(){\n    cout <<  \"Impossible\" << endl;\n    exit(0);\n}\n\n\nint n;\nint a[1 << 8];\n\nvector<int> loops;\n\nvoid entangle(int x){\n    vector<int> loop;\n    for(int i = n-1;i >= 0;i--){\n        if((x >> i) % 2 == 0)continue;\n        if(loop.empty()){\n            loop.push_back(i+1);\n            loop.push_back(-i-1);\n        }\n        else{\n            vector<int> tmp;\n            tmp.push_back(i+1);\n            for(auto it = loop.begin();it != loop.end();it++)tmp.push_back(*it);\n            tmp.push_back(i+1);\n            tmp.push_back(-i-1);\n            for(auto it = loop.rbegin();it != loop.rend();it++)tmp.push_back(*it);\n            tmp.push_back(-i-1);\n            loop = tmp;\n        }\n    }\n    for(auto elem:loop)loops.push_back(elem);\n    loops.push_back(INF);\n}\n\nvoid show(){\n    cout << \"Possible\" << endl;\n    vector<P> ps;\n    ps.push_back(P(0,0));\n    int nowx = 0, nowy = 0;\n    for(int x:loops){\n        if(x == INF){\n            while(nowx > 0){\n                ps.push_back(P(--nowx, nowy));\n            }\n            continue;\n        }\n        if(x > 0){\n            while(nowx > x){\n                ps.push_back(P(--nowx, nowy));\n            }\n            while(nowx < x-1){\n                ps.push_back(P(++nowx, nowy));\n            }\n            ps.push_back(P(nowx,++nowy));\n            if(nowx == x)ps.push_back(P(--nowx, nowy));\n            else ps.push_back(P(++nowx, nowy));\n            ps.push_back(P(nowx,--nowy));\n        }\n        if(x < 0){\n            x = x * -1;\n            while(nowx > x){\n                ps.push_back(P(--nowx, nowy));\n            }\n            while(nowx < x-1){\n                ps.push_back(P(++nowx, nowy));\n            }\n            if(nowx == x)ps.push_back(P(--nowx, nowy));\n            else ps.push_back(P(++nowx, nowy));\n        }\n    }\n    cout << ps.size() - 1 << endl;\n    for(auto p:ps){\n        cout << p.first << \" \" << p.second << endl;\n    }\n}\n\nint main(){\n    cin >> n;\n    for(int i = 0;i < (1<<n);i++){\n        scanf(\"%1d\", a+i);\n        bool bad;\n        if(a[i] == 0)bad = true;\n        for(int j = 0;j < i;j++){\n            if((j & i) != j)continue;\n            if(a[i] == 1 && a[j] == 0){\n                ng();                    \n            }\n            if(a[j] == 0)bad = false;\n        }\n        if(bad){\n            entangle(i);\n        }\n    }\n    show();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst char* IMPOSSIBLE = \"Impossible\";\nconst char* POSSIBLE = \"Possible\";\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint N; cin >> N;\n\tvector<bool> A(1<<N);\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tchar c; cin >> c;\n\t\tassert(c == '0' || c == '1');\n\t\tA[(1<<N)-1-m] = (c == '1');\n\t}\n\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\t// m2 is a superset\n\t\t\tif (A[m] > A[m | (1<<i)]) {\n\t\t\t\tcout << IMPOSSIBLE << '\\n';\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t}\n\tcout << POSSIBLE << '\\n';\n\tmt19937 mt(48);\n\tvector<int> minM;\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tif (!A[m]) continue;\n\t\tbool isMinimal = true;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif ((m & (1<<i)) && A[m ^ (1<<i)]) {\n\t\t\t\tisMinimal = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isMinimal) {\n\t\t\tminM.push_back(m);\n\t\t}\n\t}\n\tshuffle(minM.begin(), minM.end(), mt);\n\n\tqueue<vector<int>> q;\n\tfor (int m : minM) {\n\t\tvector<int> v;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (m & (1<<i)) {\n\t\t\t\tv.push_back(i+1);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (m & (1<<i)) {\n\t\t\t\tv.push_back(i+1);\n\t\t\t}\n\t\t}\n\t\t//shuffle(v.begin(), v.end(), mt);\n\t\tq.push(v);\n\t}\n\n\twhile (q.size() >= 2) {\n\t\tvector<int> a = std::move(q.front()); q.pop();\n\t\tvector<int> b = std::move(q.front()); q.pop();\n\n\t\tvector<int> c;\n\t\tfor (int i : a) { c.push_back(i); }\n\t\tfor (int i : b) { c.push_back(i); }\n\t\treverse(a.begin(), a.end());\n\t\treverse(b.begin(), b.end());\n\t\tfor (int i : a) { c.push_back(-i); }\n\t\tfor (int i : b) { c.push_back(-i); }\n\t\tq.push(c);\n\t}\n\n\tvector<int> pattern;\n\tif (!q.empty()) {\n\t\tpattern = std::move(q.front()); q.pop();\n\t}\n\n\tvector<bool> patA(1<<N);\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tstack<int> st;\n\t\tfor (int i : pattern) {\n\t\t\tif (m & (1<<(abs(i)-1))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!st.empty() && st.top() == -i) {\n\t\t\t\tst.pop();\n\t\t\t} else {\n\t\t\t\tst.push(i);\n\t\t\t}\n\t\t}\n\t\tpatA[m] = st.empty();\n\t}\n\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tassert(patA[m] >= A[m]);\n\t}\n\n\tvector<pair<int, int>> pos;\n\tpos.emplace_back(0,1);\n\tauto goToPt = [&](int x) {\n\t\tassert(pos.back().second == 1);\n\t\tif (pos.back() == pair<int, int>(x,1)) {\n\t\t\treturn;\n\t\t}\n\t\tpos.emplace_back(pos.back().first, 0);\n\t\twhile (pos.back().first < x) {\n\t\t\tpos.emplace_back(pos.back().first+1, 0);\n\t\t}\n\t\twhile (pos.back().first > x) {\n\t\t\tpos.emplace_back(pos.back().first-1, 0);\n\t\t}\n\t\tpos.emplace_back(x,1);\n\t};\n\tfor (auto i : pattern) {\n\t\tassert(i != 0);\n\t\tif (i > 0) {\n\t\t\tgoToPt(i-1);\n\t\t\tpos.emplace_back(i, 1);\n\t\t} else {\n\t\t\tgoToPt(-i);\n\t\t\tpos.emplace_back(-i-1, 1);\n\t\t}\n\t}\n\n\tgoToPt(0);\n\n\tif (int(pos.size()) - 1 > 250000) {\n\t\twhile (true);\n\t}\n\tcout << pos.size()-1 << '\\n';\n\tfor (auto it : pos) {\n\t\tcout << it.first << ' ' << it.second << '\\n';\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair \n#define f first\n#define s second\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nint pct(int x) { return __builtin_popcount(x); } \nint bit(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nint cdiv(int a, int b) { return a/b+!(a<0||a%b == 0); } // division of a by b rounded up, assumes b > 0 \n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class A> str ts(complex<A> c) { return ts(mp(c.real(),c.imag())); }\nstr ts(bool b) { return b ? \"true\" : \"false\"; }\nstr ts(char c) { str s = \"\"; s += c; return s; }\nstr ts(str s) { return s; }\nstr ts(const char* s) { return (str)s; }\nstr ts(vector<bool> v) { \n\tbool fst = 1; str res = \"{\";\n\tF0R(i,sz(v)) {\n\t\tif (!fst) res += \", \";\n\t\tfst = 0; res += ts(v[i]);\n\t}\n\tres += \"}\"; return res;\n}\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n\treturn res; }\ntemplate<class T> str ts(T v) {\n\tbool fst = 1; str res = \"{\";\n\tfor (const auto& x: v) {\n\t\tif (!fst) res += \", \";\n\t\tfst = 0; res += ts(x);\n\t}\n\tres += \"}\"; return res;\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; }\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << to_string(h); if (sizeof...(t)) cerr << \", \";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL\n#define dbg(...) cerr << \"[\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n#else\n#define dbg(...) 42\n#endif\n\n// FILE I/O\nvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\nvoid unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }\nvoid setIO(string s = \"\") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\nint N;\nstr s;\n\nvpi get(vi v) {\n\tvpi res;\n\tres.pb({v[0],0});\n\tres.pb({v[0],1});\n\tres.pb({v[0]+1,1});\n\tif (sz(v) == 1) {\n\t\tres.pb({v[0]+1,0});\n\t\treturn res;\n\t}\n\tFOR(i,v[0]+1,v[1]) res.pb({i,0});\n\t// dbg(\"HUH\",v,res);\n\tvpi z = get(vi(1+all(v))); res.insert(end(res),all(z));\n\tROF(i,v[0]+1,v[1]+1) res.pb({i,0});\n\tres.pb({v[0]+1,1});\n\tres.pb({v[0],1});\n\tres.pb({v[0],0}); reverse(1+all(z));\n\tres.insert(end(res),all(z));\n\tres.pb({v[0]+1,0}); \n\treturn res;\n}\n\nvpi construct(int x) {\n\tvi v;\n\tF0R(i,N) if (x&(1<<i)) v.pb(i);\n\tvpi ans;\n\tF0R(i,v[0]) ans.pb({i,0});\n\tauto z = get(v); ans.insert(end(ans),all(z));\n\tROF(i,1,v[0]+1) ans.pb({i,0});\n\treturn ans;\n}\n\nint main() {\n\tsetIO(); re(N,s);\n\tvi todo;\n\tF0R(i,1<<N) if (s[i] == '0') {\n\t\tbool mn = 1;\n\t\tF0R(j,N) if (i&(1<<j)) {\n\t\t\tif (s[i^(1<<j)] == '0') mn = 0;\n\t\t} else {\n\t\t\tif (s[i^(1<<j)] == '1') {\n\t\t\t\tps(\"Impossible\");\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\tif (mn) todo.pb(i);\n\t}\n\t// dbg(get({0,1}));\n\tvpi ans;\n\ttrav(t,todo) {\n\t\tauto v = construct(t);\n\t\tans.insert(end(ans),all(v));\n\t}\n\tps(\"Possible\");\n\tint res = sz(ans)+1; ps(res-1);\n\tif (!sz(ans)) ans.eb(0,0);\n\tF0R(i,res) {\n\t\tpi p = ans[i%sz(ans)];\n\t\tps(p.f,p.s);\n\t}\n\t// ps(\"HUH\"); exit(0);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\n\nconst int mod = 1e9+7;\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nint n;\nchar s[256];\nchar revc(char c)\n{\n\tif (c>='a'&&c<='z') return 'A'+c-'a';\n\telse return 'a'+c-'A';\n}\nstring getf(int msk)\n{\n\tstring ret;\n\tif (__builtin_popcount(msk)==1)\n\t{\n\t\tret.PB(__builtin_ctz(msk)+'a');\n\t\treturn ret;\n\t}\n\telse\n\t{\n\t\tint x = __builtin_ctz(msk&(-msk));\n\t\tint nmsk = msk-(1<<x);\n\t\tstring t = getf(nmsk);\n\t\tret += t;\n\t\tret.PB('a'+x);\n\t\treverse(t.begin(), t.end());\n\t\tfor (int i=0; i<t.size(); i++) t[i] = revc(t[i]);\n\t\tret += t;\n\t\tret.PB('A'+x);\n\t\treturn ret;\n\t}\n}\nvector<pair<int,int> > rt;\nint curx, cury;\nvoid go(int x, int y)\n{\n\twhile (curx<x) curx++, rt.PB(MP(curx, cury));\n\twhile (curx>x) curx--, rt.PB(MP(curx, cury));\n\twhile (cury<y) cury++, rt.PB(MP(curx, cury));\n\twhile (cury>y) cury--, rt.PB(MP(curx, cury));\n}\nvoid out(string s)\n{\n\tassert(s.size()<250000);\n\tcurx = cury = 0;\n\trt.PB(MP(0, 0));\n\n\tfor (int i=0; i<s.size(); i++)\n\t{\n\t\tbool f;\n\t\tint x;\n\t\tif (s[i]>='a'&&s[i]<='z')\n\t\t{\n\t\t\tf = true;\n\t\t\tx = s[i]-'a';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tf = false;\n\t\t\tx = s[i]-'A';\n\t\t}\n\t\tif (f)\n\t\t{\n\t\t\tgo(x, 0);\n\t\t\tgo(x, 1);\n\t\t\tgo(x+1, 1);\n\t\t\tgo(x+1, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgo(x+1, 0);\n\t\t\tgo(x+1, 1);\n\t\t\tgo(x, 1);\n\t\t\tgo(x, 0);\n\t\t}\n\t}\n\tgo(0, 0);\n}\nint main()\n{\n\tcin>>n;\n\tcin>>s;\n\tfor (int i=0; i<(1<<n); i++)\n\t{\n\t\tif (s[i]=='1')\n\t\t{\n\t\t\tfor (int j=0; j<(1<<n); j++)\n\t\t\t{\n\t\t\t\tif ((i&j)==j&&s[j]=='0')\n\t\t\t\t{\n\t\t\t\t\tputs(\"Impossible\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tstring ans;\n\tvector<int> v;\n\tfor (int i=0; i<(1<<n); i++)\n\t{\n\t\tif (s[i]=='0')\n\t\t{\n\t\t\tv.PB(i);\n\t\t}\n\t}\n\trandom_shuffle(v.begin(), v.end());\n\tfor (auto x : v) ans += getf(x);\n\trandom_shuffle(v.begin(), v.end());\n\tfor (auto x : v) ans += getf(x);\n\trandom_shuffle(v.begin(), v.end());\n\tfor (auto x : v) ans += getf(x);\n\trandom_shuffle(v.begin(), v.end());\n\tfor (auto x : v) ans += getf(x);\n\trandom_shuffle(v.begin(), v.end());\n\tfor (auto x : v) ans += getf(x);\n\t\n\tout(ans);\n\tputsi(rt.size()-1);\n\tfor (int i=0; i<rt.size(); i++) putsii(rt[i].FF, rt[i].SS);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<queue>\n#include<iostream>\n#include<fstream>\n#include<string>\n#include<cassert>\n#include<algorithm>\n#include<random>\n#include<map>\n#include<set>\n#include <bitset>\n#include<ctime>\n \nusing namespace std;\n \n//int mod = 998244353;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\ntypedef vector<int>vi;\ntypedef vector<ll>vl;\ntypedef vector<char>vc;\ntypedef vector<string>vs;\ntypedef vector<vector<int>>vii;\ntypedef vector<vector<char>>vvc;\ntypedef vector<vector<ll>>vll;\ntypedef vector< pair<ll, ll>>vpll;\ntypedef vector< pair<ld, ld>>vpld;\ntypedef vector< pair<int, int>>vpi;\ntypedef pair<ld, ld>pld;\n#define mp make_pair\n#define pb push_back\n \nconst int mod = 998244353;\nint add(int a, int b)\n{\n\tint c = a + b;\n\tif (c >= mod)\n\t{\n\t\tc -= mod;\n\t}\n\treturn c;\n}\nint dif(int a, int b)\n{\n\tint c = a - b;\n\tif (c < 0)\n\t{\n\t\tc += mod;\n\t}\n\treturn c;\n}\nint mlt(int a, int b)\n{\nll c = a * 1LL * b;\nreturn c % mod;\n}\nint ibit(int n, int i)\n{\n\treturn ((n >> i) & 1);\n}\nvoid outp(vii &ou)\n{\n\tfor (int i = 0; i < ou.size(); i++)\n\t{\n\t\tfor (int j = 0; j < ou[i].size(); j++)\n\t\t{\n\t\t\tcout << ou[i][j] << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n}\nint bp(int x, int y)\n{\n\tif (y == 0)\n\t{\n\t\treturn 1;\n\t}\n\tint a = 0;\n\tif (!(y % 2))\n\t{\n\t\ta = bp(x, y / 2);\n\t}\n\treturn (y % 2) ? mlt(bp(x, y - 1), x) : mlt(a, a);\n}\nint obr(int x)\n{\n\treturn bp(x, mod - 2);\n}\nconst int maxn = 2000007;\nint fact[2000007], ofact[2000007];\nvoid prec()\n{\n\tfact[0] = 1;\n\tofact[0] = 1;\n\tfor (int i = 1; i < maxn; i++)\n\t{\n\t\tfact[i] = mlt(fact[i - 1], i);\n\t}\n\t//cerr << \"sdsds\" << endl;\n\tofact[maxn - 1] = obr(fact[maxn - 1]);\n\tfor (int i = maxn - 2; i > 0; i--)\n\t{\n\t\tofact[i] = mlt(ofact[i + 1], i + 1);\n\t}\n}\nint c(int a, int b)\n{\n\tif (a == 0)return 1;\n\treturn ((a <= b) && (a >= 0)) ? mlt(fact[b], mlt(ofact[a], ofact[b - a])) : 0;\n}\nll gcd(ll x, ll y)\n{\n\t//cerr << x << y << endl;\n\tif (x == 0)return y;\n\treturn(x > y) ? gcd(y, x) : gcd(y%x, x);\n}\nint obr2(int n)\n{\n\tint x = fact[n - 1];\n\tx = mlt(x, ofact[n]);\n\treturn x;\n}\nvoid crv(int nn, vpi &v)\n{\n\tcerr << nn << endl;\n\tif (nn > 0) {\n\t\tint n = nn;\n\t\tfor (int i = 0; i < n; i++)v.pb({ i + 1, 0 });\n\t\tv.pb({ n,1 });\n\t\tv.pb({ n - 1, 1 });\n\t\tfor (int i = n - 1; i >= 0; i--)v.pb({ i, 0 });\n\t}\n\tif (nn < 0) {\n\t\tint n = -nn;\n\t\tfor (int i = 0; i < n-1; i++)v.pb({ i + 1, 0 });\n\t\tv.pb({ n-1,1 });\n\t\tv.pb({ n , 1 });\n\t\tfor (int i = n; i >= 0; i--)v.pb({ i, 0 });\n\t}\n}\nvoid solve(istream &cin = std::cin, ostream &cout = std::cout)\n{\n\tvii imb(8);\n\timb[0] = { 1 };\n\tfor (int i = 1; i <= 8; i++)\n\t{\n\t\tfor (int j = 0; j < imb[i - 1].size(); j++)imb[i].pb(imb[i - 1][j]);\n\t\timb[i].pb(i + 1);\n\t\tfor (int j = imb[i - 1].size(); j >= 0; j--)imb[i].pb((-1)*imb[i - 1][j]);\n\t\timb[i].pb(-i - 1);\n\t}\n\t//cerr << \"here\" << endl;\n\tint n;\n\tcin >> n;\n\tvi good(1 << n);\n\tfor (int i = 0; i < good.size(); i++)\n\t{\n\t\tchar c;\n\t\tcin >> c;\n\t\tgood[i] = c - '0';\n\t}\n\tint val = 0;\n\t//\tcerr << 433 << endl;\n\tfor (int a = 0; a < good.size(); a++)\n\t\tfor (int b = 0; b < good.size(); b++)\n\t\t\tif ((a | b) == b)\n\t\t\t\tif ((!good[a]) && (good[b]))\n\t\t\t\t{\n\t\t\t\t\t//\tcerr << a << ' ' << b << endl;\n\t\t\t\t\tval = 1;\n\t\t\t\t}\n//\tcerr << 5 << ' ' << 7 << ' ' << (5 | 7) << endl;\n\tif (val)cout << \"Impossible\" << endl;\n\telse\n\t{\n\t\tcout << \"Possible\" << endl;\n\t\t//cerr << 1111 << endl;\n\t\tvpi ay = { {0,0} };\n\t\tfor (int m = 0; m < good.size(); m++)\n\t\t{\n\t\t\t//cerr << m << endl;\n\t\t\tif (!good[m])\n\t\t\t{\n\t\t\t\tcerr << m << endl;\n\t\t\t\tvi v;\n\t\t\t\tfor (int i = 0; i <= 8; i++)if (ibit(m, i))v.pb(i);\n\t\t\t\tcerr << m << ' ' << v.size() << endl;\n\t\t\t\tfor (int i = 0; i < imb[v.size() - 1].size(); i++)\n\t\t\t\t{\n\t\t\t\t\tcerr << imb[v.size() - 1][i] << endl;\n\t\t\t\t\t//\tcerr << i << endl;\n\t\t\t\t\tif (imb[v.size()][i] > 0)crv(v[imb[v.size() - 1][i] - 1] + 1, ay);\n\t\t\t\t\tif (imb[v.size()][i] < 0)crv(-v[(-imb[v.size() - 1][i]) - 1] - 1, ay);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif (ay.size() < 190000)\n\t\t{\n\t\t\tcout << ay.size() - 1 << endl;\n\t\t\tfor (int i = 0; i < ay.size(); i++)cout << ay[i].first << ' ' << ay[i].second << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << 0 << endl;\n\t\t\tcout << 0 << ' ' << 0 << endl;\n\t\t}\n\t}\n}\nint main()\n{\n\tsolve();\n\tint n;\n\tcin >> n;\n}\n \n "
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\n\nconst int mod = 1e9+7;\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nint n;\nchar s[257];\nchar revc(char c)\n{\n\tif (c>='a'&&c<='z') return 'A'+c-'a';\n\telse return 'a'+c-'A';\n}\nstring getf(int msk)\n{\n\tstring ret;\n\tif (__builtin_popcount(msk)==1)\n\t{\n\t\tret.PB(__builtin_ctz(msk)+'a');\n\t\treturn ret;\n\t}\n\telse\n\t{\n\t\tint x = __builtin_ctz(msk&(-msk));\n\t\tint nmsk = msk-(1<<x);\n\t\tstring t = getf(nmsk);\n\t\tret += t;\n\t\tret.PB('a'+x);\n\t\treverse(t.begin(), t.end());\n\t\tfor (int i=0; i<t.size(); i++) t[i] = revc(t[i]);\n\t\tret += t;\n\t\tret.PB('A'+x);\n\t\treturn ret;\n\t}\n}\nvector<pair<int,int> > rt;\nint curx, cury;\nvoid go(int x, int y)\n{\n\twhile (curx<x) curx++, rt.PB(MP(curx, cury));\n\twhile (curx>x) curx--, rt.PB(MP(curx, cury));\n\twhile (cury<y) cury++, rt.PB(MP(curx, cury));\n\twhile (cury>y) cury--, rt.PB(MP(curx, cury));\n}\nvoid out(string s)\n{\n\tassert(s.size()<250000);\n\tcurx = cury = 0;\n\trt.PB(MP(0, 0));\n\n\tfor (int i=0; i<s.size(); i++)\n\t{\n\t\tbool f;\n\t\tint x;\n\t\tif (s[i]>='a'&&s[i]<='z')\n\t\t{\n\t\t\tf = true;\n\t\t\tx = s[i]-'a';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tf = false;\n\t\t\tx = s[i]-'A';\n\t\t}\n\t\tif (f)\n\t\t{\n\t\t\tgo(x, 0);\n\t\t\tgo(x, 1);\n\t\t\tgo(x+1, 1);\n\t\t\tgo(x+1, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgo(x+1, 0);\n\t\t\tgo(x+1, 1);\n\t\t\tgo(x, 1);\n\t\t\tgo(x, 0);\n\t\t}\n\t}\n\tgo(0, 0);\n}\nint main()\n{\n\tcin>>n;\n\tcin>>s;\n\tfor (int i=0; i<(1<<n); i++)\n\t{\n\t\tif (s[i]=='1')\n\t\t{\n\t\t\tfor (int j=0; j<(1<<n); j++)\n\t\t\t{\n\t\t\t\tif ((i&j)==j&&s[j]=='0')\n\t\t\t\t{\n\t\t\t\t\tputs(\"Impossible\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tstring ans;\n\tfor (int i=0; i<(1<<n); i++)\n\t{\n\t\tif (s[i]=='0')\n\t\t{\n\t\t\tans += getf(i);\n\t\t}\n\t}\n\tout(ans);\n\tputsi(rt.size()-1);\n\tfor (int i=0; i<rt.size(); i++) putsii(rt[i].FF, rt[i].SS);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<unordered_map>\n#include<complex>\nusing namespace std;\nconst long long mod=998244353;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3100000;\nconst int UF_SIZE = 3100000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint UF[UF_SIZE];\n\tvoid init_UF(int n){\n\t\tfor(int i=0;i<n;i++)UF[i]=-1;\n\t}\n\tint FIND(int a){\n\t\tif(UF[a]<0)return a;\n\t\treturn UF[a]=FIND(UF[a]);\n\t}\n\tvoid UNION(int a,int b){\n\t\ta=FIND(a);b=FIND(b);if(a==b)return;\n\t\tif(UF[a]>UF[b])swap(a,b);\n\t\tUF[a]+=UF[b];UF[b]=a;\n\t}\n}\n// ここから編集しろ\nchar in[310];\nint t[4][10];\nint dp[310];\nint n;\nvector<pair<int,int> >v;\nvector<pair<int,int> >cm;\nvector<pair<int,int> > ad(vector<int>a){\n\tvector<pair<int,int> > ret;\n\tif(a.size()==1){\n\t\tret.push_back(make_pair(a[0],1));\n\t\tret.push_back(make_pair(a[0],0));\n\t\treturn ret;\n\t}\n\tret.push_back(make_pair(a[0],1));\n\tvector<int>b;\n\tfor(int i=1;i<a.size();i++)\n\t\tb.push_back(a[i]);\n\tvector<pair<int,int> >S=ad(b);\n\tfor(int i=0;i<S.size();i++){\n\t\tret.push_back(S[i]);\n\t}\n\tret.push_back(make_pair(a[0],1));\n\tret.push_back(make_pair(a[0],0));\n\treverse(S.begin(),S.end());\n\tfor(int i=0;i<S.size();i++){\n\t\tret.push_back(S[i]);\n\t}\n\tret.push_back(make_pair(a[0],0));\n\treturn ret;\n}\nvoid f(int a){\n\tif(dp[a])return;\n\tif(a==0)return;\n\tdp[a]=1;\n\tbool ok=true;\n\tfor(int i=0;i<n;i++){\n\t\tif(!(a&(1<<i)))continue;\n\t\tif(in[a-(1<<i)]=='0'){\n\t\t\tok=false;\n\t\t\tf(a-(1<<i));\n\t\t}\n\t}\n\tif(ok){\n\t\tvector<int>q;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(a&(1<<i))q.push_back(i);\n\t\t}\n\t\tvector<pair<int,int> >tmp=ad(q);\n\t\tfor(int i=0;i<tmp.size();i++){\n\t\t\tcm.push_back(tmp[i]);\n\t\t}\n\t}\n}\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tn=a;\n\tscanf(\"%s\",in);\n\tfor(int i=0;i<(1<<a);i++){\n\t\tif(in[i]=='1'){\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(i&(1<<j)){\n\t\t\t\t\tif(in[i-(1<<j)]=='0'){\n\t\t\t\t\t\tprintf(\"Impossible\\n\");return 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"Possible\\n\");\n\tif(in[(1<<a)-1]=='1'){\n\t\tprintf(\"0\\n\");\n\t\tprintf(\"0 0\\n\");\n\t\treturn 0;\n\t}\n\tf((1<<a)-1);\n\tint now=0;\n\tv.push_back(make_pair(0,0));\n\tfor(int i=0;i<cm.size();i++){\n\t\tif(now<=cm[i].first){\n\t\t\twhile(now<cm[i].first){\n\t\t\t\tnow++;\n\t\t\t\tv.push_back(make_pair(now,0));\n\t\t\t}\n\t\t\tif(cm[i].second){\n\t\t\t\tv.push_back(make_pair(now,1));\n\t\t\t\tv.push_back(make_pair(now+1,1));\n\t\t\t}\n\t\t\tv.push_back(make_pair(now+1,0));\n\t\t\tnow++;\n\t\t}else{\n\t\t\twhile(now>1+cm[i].first){\n\t\t\t\tnow--;\n\t\t\t\tv.push_back(make_pair(now,0));\n\t\t\t}\n\t\t\tif(cm[i].second){\n\t\t\t\tv.push_back(make_pair(now,1));\n\t\t\t\tv.push_back(make_pair(now-1,1));\n\t\t\t}\n\t\t\tv.push_back(make_pair(now-1,0));\n\t\t\tnow--;\n\t\t}\n\t}\n\twhile(now>0){\n\t\tnow--;\n\t\tv.push_back(make_pair(now,0));\n\t}\n\tprintf(\"%d\\n\",(int)(v.size())-1);\n\tfor(int i=0;i<v.size();i++){\n\t\tprintf(\"%d %d\\n\",v[i].first,v[i].second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\nusing namespace std;\nnamespace Base{\n\t# define mr make_pair\n\ttypedef long long ll;\n\ttypedef double db;\n\tconst int inf = 0x3f3f3f3f, INF = 0x7fffffff;\n\tconst ll  infll = 0x3f3f3f3f3f3f3f3fll, INFll = 0x7fffffffffffffffll;\n\ttemplate<typename T> void read(T &x){\n    \tx = 0; int fh = 1; double num = 1.0; char ch = getchar();\n\t\twhile (!isdigit(ch)){ if (ch == '-') fh = -1; ch = getchar(); }\n\t\twhile (isdigit(ch)){ x = x * 10 + ch - '0'; ch = getchar(); }\n\t    if (ch == '.'){\n\t    \tch = getchar();\n\t    \twhile (isdigit(ch)){num /= 10; x = x + num * (ch - '0'); ch = getchar();}\n\t\t}\n\t\tx = x * fh;\n\t}\n\ttemplate<typename T> void chmax(T &x, T y){x = x < y ? y : x;}\n\ttemplate<typename T> void chmin(T &x, T y){x = x > y ? y : x;}\n}\nusing namespace Base;\n\nconst int N = 300010;\nint dx, dy, total, qx[N], qy[N], n, use[N], nd[N], cnt, now[N], ths[N], nxt[N];\nchar s[N];\nvoid moveto(int x){\n\tif (x > dx) for (int i = dx + 1; i <= x; i++) qx[++total] = i, qy[total] = dy;\n\t\telse for (int i = dx - 1; i >= x; i--) qx[++total] = i, qy[total] = dy;\n\tdx = x;\n}\n\nvoid moveup(){\n\tqx[++total] = dx, qy[total] = ++dy;\n}\nvoid movedown(){\n\tqx[++total] = dx, qy[total] = --dy;\n}\nint main(){\n\tread(n);\n\tscanf(\"\\n%s\", s);\n\tbool flag = true;\n\tfor (int i = 0; i < (1 << n); i++)\n\t\tif (s[i] == '0'){\n\t\t\tif (use[i] == 0) nd[++cnt] = i; \n\t\t\tfor (int j = 0; j < (1 << n); j++)\n\t\t\t\tif ((i | j) == j){\n\t\t\t\t\tif (s[j] == '1') flag = false;\n\t\t\t\t\tuse[j] = true;\n\t\t\t\t}\n\t\t}\n\tif (flag == false){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\t\n\tdx = 0, dy = 0;\n\tfor (int i = 1; i <= cnt; i++){\n\t\tint num = 0, len = 2, nlen;\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif (nd[i] & (1 << (j - 1))) now[++num] = j;\n\t\tths[1] = now[num]; ths[2] = -now[num];\n\t\tfor (int j = num - 1; j >= 1; j--){\n\t\t\tnxt[nlen = 1] = now[j];\n\t\t\tfor (int k = 1; k <= len; k++) nxt[++nlen] = ths[k];\n\t\t\tnxt[++nlen] = now[j];\n\t\t\tnxt[++nlen] = -now[j];\n\t\t\tfor (int k = len; k >= 1; k--) nxt[++nlen] = ths[k];\n\t\t\tnxt[++nlen] = -now[j];\n\t\t\tlen = nlen;\n\t\t\tfor (int k = 1; k <= len; k++) ths[k] = nxt[k];\n\t\t}\n\t\tfor (int j = 1; j <= len; j++){\n\t\t\tint x = abs(ths[j]);\n\t\t\tif (dx < x){\n\t\t\t\tmoveto(x - 1); \n\t\t\t\tif (ths[j] > 0) moveup(), moveto(x), movedown();\n\t\t\t\t\telse moveto(x);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmoveto(x);\n\t\t\t\tif (ths[j] > 0) moveup(), moveto(x - 1), movedown();\n\t\t\t\t\telse moveto(x - 1);\n\t\t\t}\n\t\t}\n\t\tmoveto(0);\n\t}\n\t\n\tputs(\"Possible\");\n\tprintf(\"%d\\n\", total);\n\tfor (int i = 0; i <= total; i++)\n\t\tprintf(\"%d %d\\n\", qx[i], qy[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:1000000000\")\n#pragma GCC optimize(\"Ofast,no-stack-protector\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <algorithm>\n#include <memory.h>\n#include <cassert>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <cmath>\n#include <ctime>\n#include <random>\n#include <bitset>\n#include <limits.h>\n#include <fstream>\n\n#define mp make_pair\n#define all(a) (a).begin(), (a).end()\n#define pll pair <ll, ll>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef double ld;\n#define uint unsigned int\n\nconst int maxlog = 8;\nconst int maxn = (1 << 8);\n\nint a[maxn + 10];\nchar s[maxn + 10];\n\nvector <pii> ans;\n\nvoid go(int &x, int &y, int dx, int dy) {\n\tx += dx;\n\ty += dy;\n\tans.push_back(mp(x, y));\n}\n\nvector <pii> build(vector <int> p) {\n\tif ((int)p.size() == 1) {\n\t\treturn { mp(p[0], 1) };\n\t}\n\n\tint x = p.back();\n\tp.pop_back();\n\n\tvector <pii> ans = build(p);\n\tvector <pii> res;\n\n\tfor (int i = 0; i < (int)ans.size(); i++) {\n\t\tres.push_back(mp(ans[i].first, -ans[i].second));\n\t}\n\n\treverse(all(res));\n\tans.insert(ans.end(), all(res));\n\tres.clear();\n\n\tfor (int i = 0; i < (int)ans.size(); i++) {\n\t\tres.push_back(mp(x, (i % 2 == 0 ? 1 : -1)));\n\t\tres.push_back(ans[i]);\n\t}\n\n\treturn res;\n}\n\nvoid make(int &x, int &y, pii f) {\n\tint ps = f.first;\n\tif (f.second == -1) {\n\t\tps++;\n\t}\n\n\twhile (x < ps) {\n\t\tx++;\n\t\tans.push_back(mp(x, y));\n\t}\n\n\twhile (x > ps) {\n\t\tx--;\n\t\tans.push_back(mp(x, y));\n\t}\n\n\ty--;\n\tans.push_back(mp(x, y));\n\tx += f.second;\n\tans.push_back(mp(x, y));\n\ty++;\n\tans.push_back(mp(x, y));\n}\n\nint main() {\n\tint n;\n\n\tcin >> n;\n\tcin >> s;\n\n\tfor (int i = 0; i < (1 << n); i++) {\n\t\ta[i] = s[i] - '0';\n\t}\n\n\tfor (int i = (1 << n) - 1; i >= 0; i--) {\n\t\tif (a[i] == 0) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif ((i >> j) & 1) {\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (a[i | (1 << j)] == 1) {\n\t\t\t\t\t\tcout << \"Impossible\\n\";\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (a[0] == 0) {\n\t\tcout << \"Impossible\\n\";\n\t\treturn 0;\n\t}\n\n\tans.push_back(mp(0, 0));\n\n\tfor (int i = 0; i < (1 << n); i++) {\n\t\tif (a[i] == 1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvector <int> p;\n\n\t\tbool nd = true;\n\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tif (a[i ^ (1 << j)] == 0) {\n\t\t\t\t\tnd = false;\n\t\t\t\t}\n\t\t\t\tp.push_back(j);\n\t\t\t}\n\t\t}\n\n\t\tif (!nd) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tint x = 0, y = 0;\n\n\t\tvector <pii> to = build(p);\n\n\t\ty++;\n\t\tans.push_back(mp(x, y));\n\n\t\tfor (pii f : to) {\n\t\t\tmake(x, y, f);\n\t\t}\n\n\t\twhile (x > 0) {\n\t\t\tx--;\n\t\t\tans.push_back(mp(x, y));\n\t\t}\n\n\t\ty--;\n\t\tans.push_back(mp(x, y));\n\t}\n\n\tcout << \"Possible\\n\";\n\tcout << (int)ans.size() - 1 << '\\n';\n\n\tfor (pii f : ans) {\n\t\tcout << f.first << ' ' << f.second << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nconst int N = 11, maxn = 1<<8|3;\nint n,m;\nchar s[maxn];\nbool flag[maxn];\n\ninline bool check(){\n\tif (s[0]=='0') return 1;\n\tFOR(i,1,m) if (s[i]=='1')\n\t\tFOR(j,1,m) if ((i&j)==j){\n\t\t\tif (s[j]=='0') return 1;\n\t\t} \n\tFOR(i,1,m) if (s[i]=='0')\n\t\tFOR(j,1,m) if ((i&j)==i){\n\t\t\tif (s[j]=='1') return 1;\n\t\t}\n\treturn 0;\n}\n\ninline poly Get(poly v){\n\tif (siz(v)==1) return {v[0],-v[0]};\n\tint tmp=v.back();v.pop_back();\n\tpoly tmp2=Get(v),ans={tmp};\n\tfor (auto i:tmp2) ans.pb(i);\n\tans.pb(tmp),ans.pb(-tmp);\n\tfor (auto i:tmp2) ans.pb(-i);\n\treturn ans.pb(-tmp),ans;\n}\n\nint main(){\n\tscanf(\"%d%s\",&n,s),m=strlen(s);\n\tif (check()) return puts(\"Impossible\"),0;\n\tFOR(i,0,m) if (s[i]=='0')\n\t\tFOR(j,0,m) if (((i&j)==i)&&i!=j) flag[j]=1;\n\tvector<pa>ans={{0,1}};\n\tFOR(i,0,m) if (s[i]=='0'&&flag[i]==0){\n\t\tpoly tmp;\n\t\tFor(j,1,n) if (i&(1<<j-1)) tmp.pb(j);\n\t\ttmp=Get(tmp);\n\t\tint x=0,y=1;\n\t\tfor (auto j:tmp){\n\t\t\tint a=0,b=0;\n\t\t\tif (j<0) a=-j,b=0;\n\t\t\t\telse a=j,b=1;\n\t\t\tif (y!=b) ans.ep(x,b),y=b;\n\t\t\tif (x<a){\n\t\t\t\twhile (x<a) ++x,ans.ep(x,y);\n\t\t\t} else {\n\t\t\t\twhile (x>a-1) --x,ans.ep(x,y);\n\t\t\t}\n\t\t}\n\t\tif (y==0) ans.ep(x,1),y=1;\n\t\twhile (x) --x,ans.ep(x,y); \n\t}\n\tputs(\"Possible\");\n\tprintf(\"%d\\n\",siz(ans)-1);\n\tfor (auto i:ans) printf(\"%d %d\\n\",i.fi,i.se);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing std::cerr;using std::cin;using std::cout;using std::abs;using std::min;using std::max;using std::swap;using std::map;using std::unordered_map;using std::unordered_set;using std::bitset;using std::pair;using std::set;using std::string;using std::vector;using std::sort;using ll=long long;using uint=unsigned int;using pii=pair<int,int>;using pll=pair<ll,ll>;using ull = unsigned long long;using ld=long double;template<typename T>void _(const char*s,T h){cerr<<s<<\" = \"<<h<<\"\\n\";}template<typename T,typename...Ts>void _(const char*s,T h,Ts...t){int b=0;while(((b+=*s=='(')-=*s==')')!=0||*s!=',')cerr<<*s++;cerr<<\" = \"<<h<<\",\";_(s+1,t...);}// break continue pop_back 998244353\n#define int ll\n#define pii pll\n#define f first\n#define s second\n#define pb emplace_back\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define sqr(x) ((x)*(x))\nstruct init{init(){cin.tie(0);std::iostream::sync_with_stdio(0);cout<<std::fixed<<std::setprecision(10);cerr<<std::fixed<<std::setprecision(5);}~init(){\n#ifdef LOCAL\n#define dbg(...) _(#__VA_ARGS__,__VA_ARGS__)\ncerr<<\"Time elapsed: \"<<(double)clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n#else\n#define dbg(...) \n#endif\n}}init;template<typename T,typename U>void upx(T&x,U y){if(x<y)x=y;}template<typename T,typename U>void upn(T&x,U y){if(x>y)x=y;}\n\nconst int N=2020;\nint a[N];\nvector<pii> ans={{0,0}};\nint n;\nstring pep(vector<int> v,int x){\n    string res;\n    if(v.back()>x){\n        res+=char('a'+x);\n        res+=pep(v,x+1);\n        res+=char('a'+x);\n    }else{\n        assert(v.back()==x);\n        if(v.size()>1){\n            v.pop_back();\n            auto s=pep(v,x+1);\n            res+=char('A'+x);\n            res+=s;\n            res+=char('A'+x);\n            reverse(s.begin(), s.end());\n            res+=char('a'+x);\n            res+=s;\n            res+=char('a'+x);\n        }else{\n            res+=char('A'+x);\n            res+=char('a'+x);\n        }\n    }\n    return res;\n}\nvoid add(int mask){\n    vector<int> v;\n    forn(i,n)if(mask>>i&1)v.pb(i);\n    reverse(v.begin(), v.end());\n    dbg(mask);\n    string s=pep(v,0);\n    dbg(mask,s);\n    int x=0,y=0;\n    for(char c:s){\n        dbg(x,y,c);\n        if('a'<=c&&c<='z'){\n            int r=c-'a';\n            if(r==x){\n                if(!y){\n                    ans.pb(x+1,0);\n                }else{\n                    ans.pb(x,0);\n                    ans.pb(x+1,0);\n                }\n            }else{\n                assert(r==x-1);\n                if(!y){\n                    ans.pb(x-1,0);\n                }else{\n                    ans.pb(x,0);\n                    ans.pb(x-1,0);\n                }\n            }\n        }else{\n            int r=c-'A';\n            if(r==x){\n                if(!y){\n                    ans.pb(x,1);\n                    ans.pb(x+1,1);\n                }else{\n                    ans.pb(x+1,1);\n                }\n            }else{\n                assert(r==x-1);\n                if(!y){\n                    ans.pb(x,1);\n                    ans.pb(x-1,1);\n                }else{\n                    ans.pb(x-1,1);\n                }\n            }\n        }\n        x=ans.back().f;\n        y=ans.back().s;\n    }\n}\nint32_t main(){\n\n    cin>>n;\n    forn(i,1<<n){\n        char c;\n        cin>>c;\n        a[i]=c-'0';\n    }\n    int ok=1;\n    vector<int> kek;\n    forn(m1,1<<n){\n        forn(m2,1<<n){\n            if((m1&m2)==m2){\n                if(!a[m2]&&a[m1])ok=0;\n            }\n        }\n        if(!a[m1]){\n            int kok=1;\n            forn(m2,1<<n){\n                if((m1&m2)==m2&&m1!=m2){\n                    if(!a[m2])kok=0;\n                }\n            }\n            if(kok)kek.pb(m1);\n        }\n    }\n    if(!ok){\n        cout<<\"Impossible\\n\";\n        return 0;\n    }\n    for(int i:kek)add(i);\n    cout<<\"Possible\\n\";\n    cout<<ans.size()-1<<'\\n';\n    for(pii p:ans)cout<<p.f<<' '<<p.s<<'\\n';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <bits/stdc++.h>\n\n#define pb push_back\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(),(v).end()\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef vector<int> vi;\ntypedef pair<int, int> ii;\n\nclass TaskE {\n public:\n  void solveOne(istream &in, ostream &out) {\n    int n;\n    in >> n;\n    string a;\n    in >> a;\n    vector<bool> tangled(1 << n);\n    for (int i = 0; i < (1 << n); ++i) {\n      tangled[i] = a[i] == '0';\n    }\n    if (tangled[0]) {\n      out << \"Impossible\\n\";\n      return;\n    }\n    for (int s1 = 0; s1 < (1 << n); ++s1) {\n      for (int s2 = 0; s2 < (1 << n); ++s2) {\n        if ((s1 & s2) == s1 && !tangled[s2] && tangled[s1]) {\n          out << \"Impossible\\n\";\n          return;\n        }\n      }\n    }\n    vector<ii> pts;\n    pts.emplace_back(0, 0);\n    for (int s1 = 0; s1 < (1 << n); ++s1) {\n      if (tangled[s1]) {\n        bool ok = true;\n        for (int s2 = 0; s2 < (1 << n); ++s2) {\n          if (s1 != s2 && ((s1 & s2) == s2) && tangled[s2]) {\n            ok = false;\n          }\n        }\n        if (!ok) continue;\n        int x = 0;\n        for (int iter = 0; iter < 2; ++iter) {\n          int count = 0;\n          for (int i = 0; i < n; ++i) {\n            if ((s1 & (1 << i)) != 0) {\n              ++count;\n              if (count >= 3) {\n                out << \"Impossible\\n\";\n                return;\n              }\n              for (int j = x + 1; j <= i; ++j) {\n                pts.emplace_back(j, 0);\n              }\n              x = i;\n              if (iter == 0) {\n                pts.emplace_back(i + 1, 0);\n                pts.emplace_back(i + 1, 1);\n                pts.emplace_back(i, 1);\n                pts.emplace_back(i, 0);\n              } else {\n                pts.emplace_back(i, 1);\n                pts.emplace_back(i + 1, 1);\n                pts.emplace_back(i + 1, 0);\n                pts.emplace_back(i, 0);\n              }\n            }\n          }\n          for (int j = x - 1; j >= 0; --j) {\n            pts.emplace_back(j, 0);\n          }\n          x = 0;\n          if (count == 1) {\n            break;\n          }\n        }\n      }\n    }\n    out << \"Possible\\n\";\n    out << pts.size() - 1 << \"\\n\";\n    for (const auto& p : pts) {\n      out << p.first << \" \" << p.second << \"\\n\";\n    }\n  }\n\n  void solve(std::istream &in, std::ostream &out) {\n    int nt;\n    nt = 1;\n    for (int it = 0; it < nt; ++it) {\n      solveOne(in, out);\n    }\n  }\n};\n\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  TaskE solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n, C[260];\nchar p[260];\nstruct point {\n\tint x, y;\n};\nvector<point>Res;\nvoid Add(int x, int y) {\n\tRes.push_back({ x,y });\n}\nvoid Add0() {\n\tint i;\n\tfor (i = 0; i < n; i++) Add(i, 1);\n\tfor (i = n; i > 0; i--)Add(i, 1);\n}\nvoid Add1(int x) {\n\tint i;\n\tfor (i = 0; i <= x + 1; i++)Add(i, 1);\n\tAdd(x + 1, 0);\n\tAdd(x, 0);\n\tfor (i = x; i > 0; i--)Add(i, 1);\n}\nvoid Add2(int xa, int xb) {\n\tint i;\n\tfor (i = 0; i <= xb + 1; i++) Add(i, 1);\n\tAdd(xb + 1, 0);\n\tAdd(xb, 0);\n\tfor (i = xb; i >= xa; i--)Add(i, 1);\n\tAdd(xa, 0);\n\tAdd(xa + 1, 0);\n\tfor (i = xa + 1; i <= xb; i++)Add(i, 1);\n\tAdd(xb, 0);\n\tAdd(xb + 1, 0);\n\tfor (i = xb + 1; i > xa; i--)Add(i, 1);\n\tAdd(xa + 1, 0);\n\tAdd(xa, 0);\n\tfor (i = xa; i > 0; i--)Add(i, 1);\n}\nvoid Print() {\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d\\n\", Res.size());\n\tint i;\n\tRes.push_back(Res[0]);\n\tfor (auto &t : Res)printf(\"%d %d\\n\", t.x, t.y);\n}\nint main() {\n\tint i, j;\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", p);\n\tfor (i = 0; i < (1 << n); i++) {\n\t\tint c = 0;\n\t\tfor (j = 0; j < n; j++)if ((i >> j) & 1)c++;\n\t\tC[i] = c;\n\t}\n\tfor (i = 0; i < (1 << n); i++) {\n\t\tint ck = 0;\n\t\tif (p[i] == '0' && C[i] >= 3)ck = 1;\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif ((i&j) == j) {\n\t\t\t\tif (p[j] == '0'&&p[i] == '1') {\n\t\t\t\t//\tputs(\"Impossible\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (C[j] == 2 && p[j] == '0')ck = 0;\n\t\t\t}\n\t\t}\n\t\tif (ck == 1) {\n\t\t\twhile (1) {}\n\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n\tAdd0();\n\tint pv = -1;\n\tfor (i = 0; i < n; i++) {\n\t\tif (p[1 << i] == '0') {\n\t\t\tAdd1(i);\n\t\t\tpv = i;\n\t\t}\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t\tif (p[1 << i] == '1'&&p[1 << j] == '1'&&p[(1 << i) | (1 << j)] == '0') {\n\t\t\t\tAdd2(i, j);\n\t\t\t\tif (pv != -1)Add1(pv);\n\t\t\t}\n\t\t}\n\t}\n\tPrint();\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author Egor Kulikov\n */\n\n\n\n\n\n\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// BEGIN CUT HERE\ntemplate <typename T>\nclass Vector : public vector<T> {\n    using parent = vector<T>;\npublic:\n    Vector() : parent() {}\n\n    explicit Vector(size_t __n) : parent(__n) {}\n\n    Vector(size_t __n, const T& __value) : parent(__n, __value) {}\n\n    explicit Vector(const parent& __x) : parent(__x) {}\n\n    Vector(const Vector& __x) : parent(__x) {}\n\n    Vector(Vector&& __x) noexcept : parent(move(__x)) {}\n\n    Vector(initializer_list<T> __l) : parent(__l) {}\n\n    template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>>\n    Vector(_InputIterator __first, _InputIterator __last) : parent(__first, __last) {}\n\n    const T& operator[](size_t ind) const {\n#ifdef LOCAL\n        if (ind >= parent::size()) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return parent::operator[](ind);\n    }\n\n    T& operator[](size_t ind) {\n#ifdef LOCAL\n        if (ind >= parent::size()) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return parent::operator[](ind);\n    }\n\n    Vector<T>& operator=(Vector<T>&& __x) noexcept {\n        parent::operator=(__x);\n        return *this;\n    }\n\n    Vector<T>& operator=(const Vector<T>& __x) {\n        if (&__x == this) {\n            return *this;\n        }\n        parent::operator=(__x);\n        return *this;\n    }\n};\n\ntemplate <>\nclass Vector<bool> : public vector<bool> {\n    using parent = vector<bool>;\npublic:\n    Vector() : parent() {}\n\n    explicit Vector(size_t __n) : parent(__n) {}\n\n    Vector(size_t __n, const bool& __value) : parent(__n, __value) {}\n\n    explicit Vector(const parent& __x) : parent(__x) {}\n\n    Vector(const Vector& __x) : parent(__x) {}\n\n    Vector(Vector&& __x) noexcept : parent(move(__x)) {}\n\n    Vector(initializer_list<bool> __l) : parent(__l) {}\n\n    template <typename _InputIterator, typename = std::_RequireInputIter<_InputIterator>>\n    Vector(_InputIterator __first, _InputIterator __last) : parent(__first, __last) {}\n\n    parent::const_reference operator[](size_t ind) const {\n#ifdef LOCAL\n        if (ind >= parent::size()) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return parent::operator[](ind);\n    }\n\n    parent::reference operator[](size_t ind) {\n#ifdef LOCAL\n        if (ind >= parent::size()) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return parent::operator[](ind);\n    }\n\n    Vector<bool>& operator=(Vector<bool>&& __x) noexcept {\n        parent::operator=(__x);\n        return *this;\n    }\n\n    Vector<bool>& operator=(const Vector<bool>& __x) {\n        if (&__x == this) {\n            return *this;\n        }\n        parent::operator=(__x);\n        return *this;\n    }\n};\n\n#ifdef LOCAL\n#define vec Vector\n#else\n// END CUT HERE\n#define vec vector\n// BEGIN CUT HERE\n#endif\n// END CUT HERE\n\nusing vi = vec<int>;\n\n\n#define all(v) (v).begin(), (v).end()\n\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\n\nvoid doReplace() {\n}\n\ntemplate <typename T, typename U, typename...Vs>\nvoid doReplace(T& t, const U& u, Vs&& ...vs) {\n    t = u;\n    doReplace(vs...);\n}\n\ntemplate <typename T, typename...Us>\nT minim(T& was, const T& cand, Us&& ...us) {\n    if (was > cand) {\n        was = cand;\n        doReplace(us...);\n    }\n    return was;\n}\n\ntemplate <typename T, typename...Us>\nT maxim(T& was, const T& cand, Us&& ...us) {\n    if (was < cand) {\n        was = cand;\n        doReplace(us...);\n    }\n    return was;\n}\n\n\ntemplate <typename D>\nD dPower(D base, ll exponent) {\n    if (exponent < 0) {\n        return dPower(1 / base, -exponent);\n    }\n    if (exponent == 0) {\n        return 1;\n    }\n    if ((exponent & 1) == 1) {\n        return dPower(base, exponent - 1) * base;\n    } else {\n        D res = dPower(base, exponent >> 1);\n        return res * res;\n    }\n}\n\n\nclass NumberIterator : iterator<forward_iterator_tag, int> {\npublic:\n    int v;\n\n    NumberIterator(int v) : v(v) {}\n\n    operator int&() { return v; }\n\n    int operator*() { return v; }\n};\n\nclass range : pii {\npublic:\n    range(int begin, int end) : pii(begin, max(begin, end)) {}\n\n    range(int n) : pii(0, max(0, n)) {}\n\n    NumberIterator begin() {\n        return first;\n    }\n\n    NumberIterator end() {\n        return second;\n    }\n};\n\n\ntemplate <typename T>\nclass arr {\n    T* b;\n    int n;\n\n    void allocate(int sz) {\n#ifdef LOCAL\n        if (sz < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        n = sz;\n        if (sz > 0) {\n            b = (T*) (::operator new(sz * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr(int n = 0) {\n        allocate(n);\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr(int n, const T& init) {\n        allocate(n);\n        for (int i : range(n)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr(initializer_list<T> l) {\n        allocate(n);\n        if (n > 0) {\n            memcpy(b, l.begin(), n * sizeof(T));\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr(T* b, int n) : arr(b, b + n) {}\n\n    arr(T* b, T* e) : b(b), n(e - b) {}\n\n    int size() const {\n        return n;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    const T* begin() const {\n        return b;\n    }\n\n    T* end() {\n        return b + n;\n    }\n\n    const T* end() const {\n        return b + n;\n    }\n\n    arr<T> clone() const {\n        arr<T> res(n);\n        copy(b, b + n, res.begin());\n        return res;\n    }\n\n    T& operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= n) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[at];\n    }\n\n    const T& operator[](int at) const {\n#ifdef LOCAL\n        if (at < 0 || at >= n) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[at];\n    }\n\n    bool operator==(const arr& other) const {\n        if (n != other.n) {\n            return false;\n        }\n        for (int i : range(n)) {\n            if (b[i] != other.b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    vector<T> view() {\n        return vector<T>(b, b + min(n, 50));\n    }\n};\n\ntypedef arr<int> arri;\n\nvoid decreaseByOne() {}\n\ntemplate <typename T, class...Vs>\nvoid decreaseByOne(arr<T>& array, Vs& ...vs) {\n    int n = array.size();\n    for (int i = 0; i < n; ++i) {\n        array[i]--;\n    }\n    decreaseByOne(vs...);\n}\n\ntemplate <typename T, typename U>\nvoid decreaseByOne(arr<pair<T, U>>& v) {\n    for (auto& p : v) {\n        p.first--;\n        p.second--;\n    }\n}\n\n\ntemplate <typename T>\nclass arr2d {\n    T* b;\n    int d1;\n    int d2;\n    int sz;\n\n    void allocate(int n) {\n#ifdef LOCAL\n        if (n < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        if (n > 0) {\n            b = (T*) (::operator new(n * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr2d(int d1 = 0, int d2 = 0) : d1(d1), d2(d2), sz(d1 * d2) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr2d(int d1, int d2, const T& init) : d1(d1), d2(d2), sz(d1 * d2) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr2d(T* b, int d1, int d2) : b(b), d1(d1), d2(d2), sz(d1 * d2) {}\n\n    int size() const {\n        return sz;\n    }\n\n    int dim1() const {\n        return d1;\n    }\n\n    int dim2() const {\n        return d2;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    T* end() {\n        return b + sz;\n    }\n\n    T& operator()(int i1, int i2) {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * d2 + i2];\n    }\n\n    const T& operator()(int i1, int i2) const {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * d2 + i2];\n    }\n\n    arr<T> operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= d1) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return arr<T>(b + at * d2, d2);\n    }\n\n    vector<vector<T>> view() {\n        vector<vector<T>> res(min(d1, 50));\n        for (int i = 0; i < res.size(); ++i) {\n            res[i] = (*this)[i].view();\n        }\n        return res;\n    }\n\n    arr2d<T> clone() {\n        arr2d<T> res(d1, d2);\n        copy(b, b + sz, res.b);\n        return res;\n    }\n};\n\ntemplate <typename T>\nclass arr3d {\n    T* b;\n    int d1;\n    int d2;\n    int d3;\n    int shift;\n    int sz;\n\n    void allocate(int n) {\n#ifdef LOCAL\n        if (n < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        if (n > 0) {\n            b = (T*) (::operator new(n * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr3d(int d1 = 0, int d2 = 0, int d3 = 0) : d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0 || d3 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T;\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr3d(int d1, int d2, int d3, const T& init) : d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0 || d3 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr3d(T* b, int d1, int d2, int d3) : b(b), d1(d1), d2(d2), d3(d3), shift(d2 * d3), sz(d1 * d2 * d3) {}\n\n    int size() const {\n        return sz;\n    }\n\n    int dim1() const {\n        return d1;\n    }\n\n    int dim2() const {\n        return d2;\n    }\n\n    int dim3() const {\n        return d3;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    T* end() {\n        return b + sz;\n    }\n\n    T& operator()(int i1, int i2, int i3) {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * shift + i2 * d3 + i3];\n    }\n\n    const T& operator()(int i1, int i2, int i3) const {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * shift + i2 * d3 + i3];\n    }\n\n    arr2d<T> operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= d1) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return arr2d<T>(b + at * shift, d2, d3);\n    }\n\n    vector<vector<vector<T>>> view() {\n        vector<vector<vector<T>>> res(min(d1, 50));\n        for (int i = 0; i < res.size(); ++i) {\n            res[i] = (*this)[i].view();\n        }\n        return res;\n    }\n};\n\ntemplate <typename T>\nclass arr4d {\n    T* b;\n    int d1;\n    int d2;\n    int d3;\n    int d4;\n    int shift1;\n    int shift2;\n    int sz;\n\n    void allocate(int n) {\n#ifdef LOCAL\n        if (n < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        if (n > 0) {\n            b = (T*) (::operator new(n * sizeof(T)));\n        } else {\n            b = nullptr;\n        }\n    }\n\npublic:\n    arr4d(int d1 = 0, int d2 = 0, int d3 = 0, int d4 = 0) : d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),\n                                                            shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0 || d3 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T;\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr4d(int d1, int d2, int d3, int d4, const T& init) : d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),\n                                                           shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {\n#ifdef LOCAL\n        if (d1 < 0 || d2 < 0 || d3 < 0) {\n            throw \"bad alloc\";\n        }\n#endif\n        allocate(sz);\n        for (int i : range(sz)) {\n            ::new((void*) (b + i)) T(init);\n        }\n#ifdef LOCAL\n        view();\n#endif\n    }\n\n    arr4d(T* b, int d1, int d2, int d3, int d4) : b(b), d1(d1), d2(d2), d3(d3), d4(d4), shift1(d2 * d3 * d4),\n                                                  shift2(d3 * d4), sz(d1 * d2 * d3 * d4) {\n    }\n\n    int size() const {\n        return sz;\n    }\n\n    int dim1() const {\n        return d1;\n    }\n\n    int dim2() const {\n        return d2;\n    }\n\n    int dim3() const {\n        return d3;\n    }\n\n    int dim4() const {\n        return d4;\n    }\n\n    T* begin() {\n        return b;\n    }\n\n    T* end() {\n        return b + sz;\n    }\n\n    T& operator()(int i1, int i2, int i3, int i4) {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3 || i4 < 0 || i4 >= d4) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * shift1 + i2 * shift2 + i3 * d4 + i4];\n    }\n\n    const T& operator()(int i1, int i2, int i3, int i4) const {\n#ifdef LOCAL\n        if (i1 < 0 || i1 >= d1 || i2 < 0 || i2 >= d2 || i3 < 0 || i3 >= d3 || i4 < 0 || i4 >= d4) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return b[i1 * shift1 + i2 * shift2 + i3 * d4 + i4];\n    }\n\n    arr3d<T> operator[](int at) {\n#ifdef LOCAL\n        if (at < 0 || at >= d1) {\n            throw \"Out of bounds\";\n        }\n#endif\n        return arr3d<T>(b + at * shift1, d2, d3, d4);\n    }\n\n    vector<vector<vector<vector<T>>>> view() {\n        vector<vector<vector<vector<T>>>> res(min(d1, 50));\n        for (int i = 0; i < res.size(); ++i) {\n            res[i] = (*this)[i].view();\n        }\n        return res;\n    }\n};\n\n\ninline bool isWhitespace(int c) {\n    return isspace(c) || c == EOF;\n}\n\nclass Input {\nprivate:\n    bool exhausted = false;\n    int bufSize = 4096;\n    char* buf = new char[bufSize];\n    int bufRead = 0;\n    int bufAt = 0;\n\n    inline int get() {\n        if (exhausted) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return EOF;\n        }\n        if (bufRead == bufAt) {\n            bufRead = fread(buf, sizeof(char), bufSize, stdin);\n            bufAt = 0;\n        }\n        if (bufRead == bufAt) {\n            exhausted = true;\n            return EOF;\n        }\n        return buf[bufAt++];\n    }\n\n    template <typename T>\n    inline T readInteger() {\n        int c = skipWhitespace();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = get();\n        }\n        T res = 0;\n        do {\n            if (!isdigit(c)) {\n#ifdef LOCAL\n                throw \"Number format error\";\n#endif\n                return sgn * res;\n            }\n            res *= 10;\n            res += c - '0';\n            c = get();\n        } while (!isWhitespace(c));\n        return res * sgn;\n    }\n\n    void initArrays(int) {}\n\n    template <typename T, class...Vs>\n    void initArrays(int n, arr<T>& array, Vs& ...vs) {\n        array = arr<T>(n);\n        initArrays(n, vs...);\n    }\n\n    template <typename T, class...Vs>\n    void initArrays(int n, vec<T>&, Vs& ...vs) {\n        initArrays(n, vs...);\n    }\n\n    void readImpl(int) {}\n\n    template <typename T, class...Vs>\n    void readImpl(int i, arr<T>& arr, Vs& ...vs) {\n        arr[i] = readType<T>();\n        readImpl(i, vs...);\n    }\n\n    template <typename T, class...Vs>\n    void readImpl(int i, vec<T>& arr, Vs& ...vs) {\n        arr.push_back(readType<T>());\n        readImpl(i, vs...);\n    }\n\npublic:\n    inline int skipWhitespace() {\n        int c;\n        while (isWhitespace(c = get()) && c != EOF);\n        if (c == EOF) {\n            exhausted = true;\n        }\n        return c;\n    }\n\n    inline int readInt() {\n        return readInteger<int>();\n    }\n\n    ll readLong() {\n        return readInteger<ll>();\n    }\n\n    string readString() {\n        int c = skipWhitespace();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return \"\";\n        }\n        vec<char> res;\n        do {\n            res.push_back(c);\n        } while (!isWhitespace(c = get()));\n        return string(all(res));\n    }\n\n    arri readIntArray(int size) {\n        return readArray<int>(size);\n    }\n\n    arr<ll> readLongArray(int size) {\n        return readArray<ll>(size);\n    }\n\n    arr<double> readDoubleArray(int size) {\n        return readArray<double>(size);\n    }\n\n    arr<string> readStringArray(int size) {\n        return readArray<string>(size);\n    }\n\n    arr<char> readCharArray(int size) {\n        return readArray<char>(size);\n    }\n\n    template <typename T>\n    T readType() {\n        throw \"Operation not supported\";\n    }\n\n    template <typename U, typename V>\n    pair<U, V> readType() {\n        U first = readType<U>();\n        V second = readType<V>();\n        return make_pair(first, second);\n    }\n\n    template <typename T>\n    arr<T> readArray(int n) {\n        arr<T> res(n, T());\n        for (int i = 0; i < n; i++) {\n            res[i] = readType<T>();\n        }\n        return res;\n    }\n\n\n    template <class...Vs>\n    void readArrays(int n, Vs& ...vs) {\n        initArrays(n, vs...);\n        for (int i = 0; i < n; i++) {\n            readImpl(i, vs...);\n        }\n    }\n\n    template <typename U, typename V>\n    arr<pair<U, V>> readArray(int n) {\n        arr<pair<U, V>> res(n);\n        for (int i = 0; i < n; i++) {\n            res[i] = readType<U, V>();\n        }\n        return res;\n    }\n\n    template <typename T>\n    arr2d<T> readTable(int rows, int cols) {\n        arr2d<T> result(rows, cols);\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < cols; ++j) {\n                result(i, j) = readType<T>();\n            }\n        }\n        return result;\n    }\n\n    arr2d<int> readIntTable(int rows, int cols) {\n        return readTable<int>(rows, cols);\n    }\n\n    arr2d<char> readCharTable(int rows, int cols) {\n        return readTable<char>(rows, cols);\n    }\n\n    string readLine() {\n        int c = get();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return \"\";\n        }\n        vec<char> res;\n        do {\n            res.push_back(c);\n            c = get();\n        } while (c != '\\n' && c != '\\r' && c != EOF);\n        return string(all(res));\n    }\n\n    double readDouble() {\n        int c = skipWhitespace();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = get();\n        }\n        double res = 0;\n        do {\n            if (tolower(c) == 'e') {\n                return sgn * res * dPower(double(10), readInt());\n            }\n            if (!isdigit(c)) {\n#ifdef LOCAL\n                throw \"Number format error\";\n#endif\n                return sgn * res;\n            }\n            res *= 10;\n            res += c - '0';\n            c = get();\n        } while (!isWhitespace(c) && c != '.');\n        if (c == '.') {\n            double add = 0;\n            int length = 0;\n            c = get();\n            do {\n                if (tolower(c) == 'e') {\n                    return sgn * (res + add * dPower(double(10), -length)) * dPower(double(10), readInt());\n                }\n                if (!isdigit(c)) {\n#ifdef LOCAL\n                    throw \"Number format error\";\n#endif\n                    res += add * dPower(10, -length);\n                    return res * sgn;\n                }\n                add *= 10;\n                add += c - '0';\n                length++;\n                c = get();\n            } while (!isWhitespace(c));\n            res += add * dPower(double(10), -length);\n        }\n        return res * sgn;\n    }\n\n    char readChar() {\n        int c = skipWhitespace();\n        if (c == EOF) {\n#ifdef LOCAL\n            throw \"Input exhausted\";\n#endif\n            return 0;\n        }\n        return c;\n    }\n\n    bool isExhausted() { return exhausted; }\n\n    void setBufSize(int newBufSize) {\n        if (newBufSize > bufSize) {\n            char* newBuf = new char[newBufSize];\n            memcpy(newBuf, buf, bufSize);\n            buf = newBuf;\n        }\n        bufSize = newBufSize;\n    }\n};\n\ntemplate <>\ndouble Input::readType() {\n    return readDouble();\n}\n\ntemplate <>\nint Input::readType() {\n    return readInt();\n}\n\ntemplate <>\nll Input::readType() {\n    return readLong();\n}\n\ntemplate <>\nchar Input::readType() {\n    return readChar();\n}\n\ntemplate <>\nstring Input::readType() {\n    return readString();\n}\n\nInput in;\n\n\nclass Output {\nprivate:\n    ostream& out = cout;\n\n    template <typename T>\n    void printSingle(const T& value) {\n        out << value;\n    }\n\n    template <typename T>\n    void printSingle(const vec<T>& array) {\n        size_t n = array.size();\n        for (int i = 0; i < n; ++i) {\n            out << array[i];\n            if (i + 1 != n) {\n                out << ' ';\n            }\n        }\n    }\n\n    template <typename T>\n    void printSingle(const arr<T>& array) {\n        size_t n = array.size();\n        for (int i = 0; i < n; ++i) {\n            out << array[i];\n            if (i + 1 != n) {\n                out << ' ';\n            }\n        }\n    }\n\n    template <typename T>\n    void printSingle(const arr2d<T>& array) {\n        size_t n = array.dim1();\n        size_t m = array.dim2();\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                out << array(i, j);\n                if (j + 1 != m) {\n                    out << ' ';\n                }\n            }\n            if (i + 1 != n) {\n                out << '\\n';\n            }\n        }\n    }\n\n    template <typename T, typename U>\n    void printSingle(const pair<T, U>& value) {\n        out << value.first << ' ' << value.second;\n    }\n\npublic:\n    Output() {//ostream& out) : out(out) {\n        out << fixed << setprecision(20);\n    }\n\n    void print() {}\n\n    template <typename T, typename...Targs>\n    void print(const T& first, const Targs... args) {\n        printSingle(first);\n        if (sizeof...(args) != 0) {\n            out << ' ';\n            print(args...);\n        }\n    }\n\n    template <typename...Targs>\n    void printLine(const Targs... args) {\n        print(args...);\n        out << '\\n';\n    }\n\n    void flush() {\n        out.flush();\n    }\n};\n\nOutput out;\n\n\nclass ReverseNumberIterator : public NumberIterator {\npublic:\n    ReverseNumberIterator(int v) : NumberIterator(v) {}\n\n    ReverseNumberIterator& operator++() {\n        --v;\n        return *this;\n    }\n};\n\nclass RevRange : pii {\npublic:\n    RevRange(int begin, int end) : pii(begin - 1, min(begin, end) - 1) {}\n\n    RevRange(int n) : pii(n - 1, min(n, 0) - 1) {}\n\n    ReverseNumberIterator begin() {\n        return first;\n    }\n\n    ReverseNumberIterator end() {\n        return second;\n    }\n};\n\n\ntemplate <typename T>\ninline void unique(vec<T>& v) {\n    v.resize(unique(all(v)) - v.begin());\n}\n\narri createOrder(int n) {\n    arri order(n);\n    for (int i = 0; i < n; i++) {\n        order[i] = i;\n    }\n    return order;\n}\n\narri inverse(const arri& p) {\n    arri res(p.size());\n    for (int i : range(p.size())) {\n        res[p[i]] = i;\n    }\n    return res;\n}\n\ntemplate <typename T, typename Iterator>\ninline void addAll(vec<T>& v, Iterator begin, Iterator end) {\n    v.insert(v.end(), begin, end);\n}\n\ntemplate <class Collection, typename Iterator>\ninline void addAll(Collection& v, Iterator begin, Iterator end) {\n    v.insert(begin, end);\n}\n\ntemplate <typename Iterator>\narri getQty(Iterator begin, Iterator end, int length) {\n    arri res(length, 0);\n    for (Iterator it = begin; it != end; it++) {\n        res[*it]++;\n    }\n    return res;\n}\n\ntemplate <typename Iterator>\narri getQty(Iterator begin, Iterator end) {\n    return getQty(begin, end, *max_element(begin, end) + 1);\n}\n\ntemplate <class Collection>\nvoid collect(Collection&) {}\n\ntemplate <class Collection, class Other, class ...Vs>\nvoid collect(Collection& all, Other& a, Vs& ...vs) {\n    addAll(all, all(a));\n    collect(all, vs...);\n}\n\nvoid replace(const vi&) {}\n\ntemplate <class ...Vs>\nvoid replace(const vi& all, vi& a, Vs& ...vs) {\n    for (int& i : a) {\n        i = lower_bound(all(all), i) - all.begin();\n    }\n    replace(all, vs...);\n}\n\ntemplate <class ...Vs>\nvoid replace(const vi& all, arri& a, Vs& ...vs) {\n    for (int& i : a) {\n        i = lower_bound(all(all), i) - all.begin();\n    }\n    replace(all, vs...);\n}\n\ntemplate <class ...Vs>\nvi compress(Vs& ...vs) {\n    vi vals;\n    collect(vals, vs...);\n    sort(all(vals));\n    unique(vals);\n    replace(vals, vs...);\n    return vals;\n}\n\n\nclass DSU {\n    mutable arri id;\n    arri sz;\n    int count;\n\npublic:\n    DSU(int n) {\n        id = createOrder(n);\n        sz = arri(n, 1);\n        count = n;\n    }\n\n    int get(int i) const {\n        if (id[i] == i) {\n            return i;\n        }\n        return id[i] = get(id[i]);\n    }\n\n    int operator[](int i) const { return get(i); }\n\n    int size(int i) const { return sz[get(i)]; }\n\n    int setCount() const { return count; }\n\n    bool join(int a, int b) {\n        a = get(a);\n        b = get(b);\n        if (a == b) {\n            return false;\n        }\n        sz[a] += sz[b];\n        sz[b] = 0;\n        id[b] = a;\n        count--;\n        return true;\n    }\n\n    void reset() {\n        count = sz.size();\n        for (int i : range(count)) {\n            id[i] = i;\n            sz[i] = 1;\n        }\n    }\n};\n\n\ntemplate <typename W, typename C>\nclass WeightedFlowEdge {\nprivate:\n    WeightedFlowEdge<W, C>* reverseEdge;\n\npublic:\n    const int from;\n    const int to;\n    W weight;\n    C capacity;\n    int id;\n\n    WeightedFlowEdge(int from, int to, W weight, C capacity) : from(from), to(to), weight(weight), capacity(capacity) {\n        reverseEdge = new WeightedFlowEdge(this);\n    }\n\n    WeightedFlowEdge<W, C>* transposed() { return nullptr; }\n\n    WeightedFlowEdge<W, C>* reverse() { return reverseEdge; }\n\n    void push(C flow) {\n        capacity -= flow;\n        reverseEdge->capacity += flow;\n    }\n\n    C flow() const {\n        return reverseEdge->capacity;\n    }\n\nprivate:\n    WeightedFlowEdge(WeightedFlowEdge<W, C>* reverse) : from(reverse->to), to(reverse->from), weight(-reverse->weight),\n                                                        capacity(0) {\n        reverseEdge = reverse;\n    }\n};\n\ntemplate <typename C>\nclass FlowEdge {\nprivate:\n    FlowEdge<C>* reverseEdge;\n\npublic:\n    const int from;\n    const int to;\n    C capacity;\n    int id;\n\n    FlowEdge(int from, int to, C capacity) : from(from), to(to), capacity(capacity) {\n        reverseEdge = new FlowEdge(this);\n    }\n\n    FlowEdge<C>* transposed() { return nullptr; }\n\n    FlowEdge<C>* reverse() { return reverseEdge; }\n\n    void push(C flow) {\n        capacity -= flow;\n        reverseEdge->capacity += flow;\n    }\n\n    C flow() const {\n        return reverseEdge->capacity;\n    }\n\nprivate:\n    FlowEdge(FlowEdge<C>* reverse) : from(reverse->to), to(reverse->from), capacity(0) {\n        reverseEdge = reverse;\n    }\n};\n\ntemplate <typename W>\nclass WeightedEdge {\npublic:\n    const int from;\n    const int to;\n    W weight;\n    int id;\n\n    WeightedEdge(int from, int to, W weight) : from(from), to(to), weight(weight) {\n    }\n\n    WeightedEdge<W>* transposed() { return nullptr; }\n\n    WeightedEdge<W>* reverse() { return nullptr; }\n};\n\ntemplate <typename W>\nclass BiWeightedEdge {\nprivate:\n    BiWeightedEdge<W>* transposedEdge;\n\npublic:\n    const int from;\n    const int to;\n    W weight;\n    int id;\n\n    BiWeightedEdge(int from, int to, W weight) : from(from), to(to), weight(weight) {\n        transposedEdge = new BiWeightedEdge(this);\n    }\n\n    BiWeightedEdge<W>* transposed() { return transposedEdge; }\n\n    BiWeightedEdge<W>* reverse() { return nullptr; }\n\nprivate:\n    BiWeightedEdge(BiWeightedEdge<W>* transposed) : from(transposed->to), to(transposed->from),\n                                                    weight(transposed->weight) {\n        transposedEdge = transposed;\n    }\n};\n\nclass BaseEdge {\npublic:\n    const int from;\n    const int to;\n    int id;\n\n    BaseEdge(int from, int to) : from(from), to(to) {\n    }\n\n    BaseEdge* transposed() { return nullptr; }\n\n    BaseEdge* reverse() { return nullptr; }\n};\n\nclass BiEdge {\nprivate:\n    BiEdge* transposedEdge;\n\npublic:\n    const int from;\n    const int to;\n    int id;\n\n    BiEdge(int from, int to) : from(from), to(to) {\n        transposedEdge = new BiEdge(this);\n    }\n\n    BiEdge* transposed() { return transposedEdge; }\n\n    BiEdge* reverse() { return nullptr; }\n\nprivate:\n    BiEdge(BiEdge* transposed) : from(transposed->to), to(transposed->from) {\n        transposedEdge = transposed;\n    }\n};\n\ntemplate <class Edge>\nclass Graph {\npublic:\n    int vertexCount;\n    int edgeCount = 0;\nprivate:\n    vec<vec<Edge*>> edges;\n\npublic:\n    Graph(int vertexCount) : vertexCount(vertexCount), edges(vertexCount, vec<Edge*>()) {}\n\n    void addEdge(Edge* edge) {\n#ifdef LOCAL\n        if (edge->from < 0 || edge->to < 0 || edge->from >= vertexCount || edge->to >= vertexCount) {\n            throw \"Out of bounds\";\n        }\n#endif\n        edge->id = edgeCount;\n        edges[edge->from].push_back(edge);\n        Edge* reverse = edge->reverse();\n        if (reverse != nullptr) {\n            reverse->id = edgeCount;\n            edges[reverse->from].push_back(reverse);\n        }\n        Edge* transposed = edge->transposed();\n        if (transposed != nullptr) {\n            edges[transposed->from].push_back(transposed);\n            transposed->id = edgeCount;\n            Edge* transRev = transposed->reverse();\n            if (transRev != nullptr) {\n                edges[transRev->from].push_back(transRev);\n                transRev->id = edgeCount;\n            }\n        }\n        edgeCount++;\n    }\n\n    template <typename...Ts>\n    void addEdge(Ts...args) {\n        addEdge(new Edge(args...));\n    }\n\n    vec<Edge*>& operator[](int at) {\n        return edges[at];\n    }\n\n    void addVertices(int count) {\n        vertexCount += count;\n        edges.resize(vertexCount);\n    }\n};\n\n\nclass ETopology {\npublic:\n    void solve() {\n        int n = in.readInt();\n        auto a = in.readCharArray(1 << n);\n\n        auto shift = [&](int mask, int dir) -> int {\n            if (dir >= 0) {\n                return mask << dir;\n            }\n            return mask >> (-dir);\n        };\n        auto okay = [&](int up, int down, int vert) -> bool {\n            for (int i : range(1 << n)) {\n                int left = -n;\n                int last = -n - 1;\n                for (int j : range(n + 1)) {\n                    if (vert >> j & 1) {\n                        maxim(left, last - j + 1);\n                    }\n                    if (i >> j & 1) {\n                        last = j;\n                    }\n                }\n                int right = n;\n                last = 2 * n;\n                for (int j : RevRange(n + 1)) {\n                    if (i >> j & 1) {\n                        last = j;\n                    }\n                    if (vert >> j & 1) {\n                        minim(right, last - j);\n                    }\n                }\n                bool can = false;\n                for (int j : range(left, right + 1)) {\n                    if (!(shift(up, j) & i) || !(shift(down, j) & i)) {\n                        can = true;\n                        break;\n                    }\n                }\n                if (can ^ (a[i] == '1')) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        DSU dsu(2 * n + 2);\n        for (int i : range(1 << n)) {\n            for (int j : range(i + 1)) {\n                for (int k : range(1 << (n + 1))) {\n                    dsu.reset();\n                    for (int l : range(n + 1)) {\n                        if ((i >> l & 1) && dsu.join(l, l + 1)) {\n                        }\n                        if ((j >> l & 1) && dsu.join(n + 1 + l, n + 1 + l + 1)) {\n                        }\n                        if ((k >> l & 1) && dsu.join(l, n + 1 + l)) {\n                        }\n                    }\n                    int times = 0;\n                    bool good = true;\n                    for (int l : range(2 * n + 2)) {\n                        if (dsu[l] == l && dsu.size(l) > 1) {\n                            times++;\n                        }\n                    }\n                    if (times <= 1 && okay(i, j, k)) {\n                        out.printLine(\"Possible\");\n                        if (!i && !j && !k) {\n                            out.printLine(0);\n                            out.printLine(0, 0);\n                            return;\n                        }\n                        Graph<BiEdge> graph(2 * n + 2);\n                        for (int l : range(n + 1)) {\n                            if ((i >> l & 1)) {\n                                graph.addEdge(l, l + 1);\n                            }\n                            if ((j >> l & 1)) {\n                                graph.addEdge(n + 1 + l, n + 1 + l + 1);\n                            }\n                            if ((k >> l & 1)) {\n                                graph.addEdge(l, n + 1 + l);\n                            }\n                        }\n                        vec<pii> ans;\n                        for (int l : range(2 * n + 2)) {\n                            if (dsu.size(l) > 1) {\n                                arr<bool> visited(2 * n + 2, false);\n                                function<void(int, int)> dfs = [&](int vert, int last) {\n                                    ans.emplace_back(vert % (n + 1), vert / (n + 1));\n                                    if (visited[vert]) {\n                                        return;\n                                    }\n                                    visited[vert] = true;\n                                    for (auto* e : graph[vert]) {\n                                        int next = e->to;\n                                        if (next == last) {\n                                            continue;\n                                        }\n                                        dfs(next, vert);\n                                        ans.emplace_back(vert % (n + 1), vert / (n + 1));\n                                    }\n                                };\n                                dfs(l, -1);\n                                break;\n                            }\n                        }\n                        out.printLine(ans.size() - 1);\n                        for (const auto& p : ans) {\n                            out.printLine(p);\n                        }\n                        return;\n                    }\n                }\n            }\n        }\n        out.printLine(\"Impossble\");\n    }\n};\n\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ETopology solver;\n\n\n    solver.solve();\n    fflush(stdout);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n, C[260];\nchar p[260];\nstruct point {\n\tint x, y;\n};\nvector<point>Res;\nvoid Add(int x, int y) {\n\tRes.push_back({ x,y });\n}\nvoid Add0() {\n\tint i;\n\tfor (i = 0; i < n; i++) Add(i, 1);\n\tfor (i = n; i > 0; i--)Add(i, 1);\n}\nvoid Add1(int x) {\n\tint i;\n\tfor (i = 0; i <= x + 1; i++)Add(i, 1);\n\tAdd(x + 1, 0);\n\tAdd(x, 0);\n\tfor (i = x; i > 0; i--)Add(i, 1);\n}\nvoid Add2(int xa, int xb) {\n\tint i;\n\tfor (i = 0; i <= xb + 1; i++) Add(i, 1);\n\tAdd(xb + 1, 0);\n\tAdd(xb, 0);\n\tfor (i = xb; i >= xa; i--)Add(i, 1);\n\tAdd(xa, 0);\n\tAdd(xa + 1, 0);\n\tfor (i = xa + 1; i <= xb; i++)Add(i, 1);\n\tAdd(xb, 0);\n\tAdd(xb + 1, 0);\n\tfor (i = xb + 1; i > xa; i--)Add(i, 1);\n\tAdd(xa + 1, 0);\n\tAdd(xa, 0);\n\tfor (i = xa; i > 0; i--)Add(i, 1);\n}\nvoid Print() {\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d\\n\", Res.size());\n\tint i;\n\tRes.push_back(Res[0]);\n\tfor (auto &t : Res)printf(\"%d %d\\n\", t.x, t.y);\n}\nint main() {\n\tint i, j;\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", p);\n\tfor (i = 0; i < (1 << n); i++) {\n\t\tint c = 0;\n\t\tfor (j = 0; j < n; j++)if ((i >> j) & 1)c++;\n\t\tC[i] = c;\n\t}\n\tfor (i = 0; i < (1 << n); i++) {\n\t\tint ck = 0;\n\t\tif (p[i] == '0' && C[i] >= 3)ck = 1;\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif ((i&j) == j) {\n\t\t\t\tif (p[j] == '0'&&p[i] == '1') {\n\t\t\t\t\tputs(\"Impossible\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (C[j] == 2 && p[j] == '0')ck = 0;\n\t\t\t}\n\t\t}\n\t\tif (ck == 1) {\n\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tAdd0();\n\tfor (i = 0; i < n; i++) {\n\t\tif (p[1 << i] == '0') {\n\t\t\tAdd1(i);\n\t\t}\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t\tif (p[1 << i] == '1'&&p[1 << j] == '1'&&p[(1 << i) | (1 << j)] == '0') {\n\t\t\t\tAdd2(i, j);\n\t\t\t}\n\t\t}\n\t}\n\tPrint();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int n, pow=1, a[30000], i, j, k, b[10]={}, s=0, t=0, x, y;\n    scanf(\"%d\", &n);\n    for(i=1;i<=n;i++)\n        pow*=2;\n    for(i=0;i<pow;i++)\n        scanf(\"%1d\", &a[i]);\n    for(i=0;i<n;i++)\n    {\n        b[i]=1-a[1<<i];\n        if(b[i]==1)\n        {\n            if((i==0)||(b[i-1]==0))\n                t++;\n        }\n    }\n    for(i=0;i<pow;i++)\n    {\n        x=0;\n        y=i;\n        for(j=0;j<n;j++)\n        {\n            if(y%2)\n            {\n                x+=b[j];\n            }\n            else\n            {}\n            y/=2;\n        }\n        \n        if(((a[i]==1)&&(x==0))||((a[i]==0)&&(x>0)))\n        {}\n        else\n            s++;\n\n    }\n    if(s)\n        printf(\"Impossible\");\n    else\n    {\n        if((t>=2)||(t==0))\n            printf(\"Impossible\");\n        else\n        {\n        printf(\"Possible\\n\");\n        j=0;\n        while(b[j]==0)\n            j++;\n        k=j;\n        while(b[k]==1)\n            k++;\n        }\n        for(i=j;i<=k;i++)\n            printf(\"%d 0\\n\", i);\n        for(i=k;i>=j;i--)\n            printf(\"%d 1\\n\", i);\n        printf(\"%d 0\", j);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define fr first\n#define sc second\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n\nvector<P> ret;\n\nvoid pos(int i){\n\tfor(int j=0;j<i;j++){\n\t\tret.push_back(P(j+1,0));\n\t}\n\tret.push_back(P(i,1));\n\tret.push_back(P(i+1,1));\n\tret.push_back(P(i+1,0));\n\tret.push_back(P(i,0));\n\tfor(int j=i-1;j>=0;j--){\n\t\tret.push_back(P(j,0));\n\t}\n}\nvoid neg(int i){\n\tfor(int j=0;j<i;j++){\n\t\tret.push_back(P(j+1,0));\n\t}\n\tret.push_back(P(i+1,0));\n\tret.push_back(P(i+1,1));\n\tret.push_back(P(i,1));\n\tret.push_back(P(i,0));\n\tfor(int j=i-1;j>=0;j--){\n\t\tret.push_back(P(j,0));\n\t}\n}\n\nvector<P> f(vector<P> vec,int t){\n\tint cnt[300]={};\n\tfor(int i=0;i<vec.size();i++){\n\t\tcnt[vec[i].sc]++;\n\t}\n\tint MIN=100;\n\tint id=-1;\n\tfor(int i=0;i<300;i++){\n\t\tif(cnt[i]==0)continue;\n\t\tif(MIN>cnt[i]){\n\t\t\tMIN=cnt[i];\n\t\t\tid=i;\n\t\t}\n\t}\n\t//cerr<<\"id=\"<<id<<endl;\n\tvector<P> ret;\n\tfor(int i=0;i<vec.size();i++){\n\t\tif(vec[i].sc!=id)ret.push_back(vec[i]);\n\t\telse {\n\t\t\tif(vec[i].fr==1){\n\t\t\t\tret.push_back(P(1,id));\n\t\t\t\tret.push_back(P(1,t));\n\t\t\t\tret.push_back(P(-1,id));\n\t\t\t\tret.push_back(P(-1,t));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret.push_back(P(1,t));\n\t\t\t\tret.push_back(P(1,id));\n\t\t\t\tret.push_back(P(-1,t));\n\t\t\t\tret.push_back(P(-1,id));\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nbool zero(vector<P> vec, int x){\n\tstack<P> st;\n\tfor(P p: vec){\n\t\tif((x>>p.sc)&1){\n\t\t\tif(st.size()==0){\n\t\t\t\tst.push(p);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tP q=st.top();\n\t\t\tif(q.sc==p.sc&&p.sc+q.sc==0)st.pop();\n\t\t\telse st.push(p);\n\t\t}\n\t}\n\treturn st.size()==0;\n}\n\nint main(){\n\t/*vector<P> vvv;\n\tvvv.push_back(P(1,1));\n\tfor(int i=2;i<=8;i++){\n\t\tvvv=f(vvv,i);\n\t\tcerr<<i<<\" \"<<vvv.size()<<endl;\n\t}*/\n\t\n\t\n\tint n;\n\tstring s;\n\tcin>>n>>s;\n\t\n\tint a[300];\n\tfor(int i=0;i<(1<<n);i++)a[i]=s[i]-'0';\n\t\n\tbool used[300];\n\tmemset(used,0,sizeof used);\n\t\n\tint b[300];\n\tfor(int i=0;i<300;i++)b[i]=1;\n\t\n\tfor(int x=1;x<(1<<n);x++){\n\t\tused[x]=true;\n\t\tfor(int y=0;y<x;y++){\n\t\t\tif((x&y)==y)if(used[y])used[x]=false;\n\t\t}\n\t\tfor(int y=0;y<(1<<n);y++){\n\t\t\tif((x&y)==x)if(a[y]==1)used[x]=false;\n\t\t}\n\t\tif(used[x]){\n\t\t\tfor(int y=0;y<(1<<n);y++){\n\t\t\t\tif((x&y)==x)b[y]=0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool ok=true;\n\tfor(int i=0;i<(1<<n);i++)ok&=a[i]==b[i];\n\tif(!ok){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tvector<P> vv;\n\t/*for(int x=0;x<(1<<n);x++){\n\t\tif(!used[x])continue;\n\t\tif(vv.size()==0){\n\t\t\tvv.push_back(P(1,x));\n\t\t}\n\t\telse{\n\t\t\tvv=f(vv,x);\n\t\t}\n\t}*/\n\tvector<P> vec[300];\n\tret.push_back(P(0,0));\n\tfor(int x=0;x<(1<<n);x++){\n\t\tif(!used[x])continue;\n\t\tif(zero(vv,x)){\n\t\t\tint cnt=0;\n\t\t\tint c[10];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif((x>>i)&1)c[cnt++]=i;\n\t\t\t}\n\t\t\tvec[x].push_back(P(1,c[0]));\n\t\t\tfor(int i=1;i<cnt;i++)vec[x]=f(vec[x],c[i]);\n\t\t\tvv.insert(vv.end(),vec[x].begin(),vec[x].end());\n\t\t}\n\t}\n\tfor(P p: vv){\n\t\tif(p.fr==1)pos(p.sc);\n\t\telse neg(p.sc);\n\t}\n\t\n\t/*for(int i=0;i<vv.size();i++){\n\t\tif(vv[i].fr==1){\n\t\t\tfor(P p: vec[vv[i].sc]){\n\t\t\t\tif(p.fr==1)pos(p.sc);\n\t\t\t\telse neg(p.sc);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor(int j=vec[vv[i].sc].size()-1;j>=0;j--){\n\t\t\t\tP p=vec[vv[i].sc][j];\n\t\t\t\tif(p.fr==1)neg(p.sc);\n\t\t\t\telse pos(p.sc);\n\t\t\t}\n\t\t}\n\t}*/\n\t\n\tvector<P> ret2;\n\tfor(P p: ret){\n\t\tif(ret2.size()>=2&&ret2[ret2.size()-2]==p)ret2.pop_back();\n\t\telse ret2.push_back(p);\n\t}\n\tret=ret2;\n\t\n\tassert(ret.size()<=250000);\n\t\n\tputs(\"Possible\");\n\tprintf(\"%d\\n\",(int)(ret.size())-1);\n\tfor(int i=0;i<ret.size();i++){\n\t\tprintf(\"%d %d\\n\",ret[i].fr,ret[i].sc);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int N;\n  string s;\n  cin >> N >> s;\n  int mask = (1 << N) - 1;\n  for (int i = 0; i < (1 << N); ++i)\n    if (s[i] == '1')\n      mask &= ~i;\n  for (int i = 0; i < (1 << N); ++i)\n    if ((s[i] == '1') != (!(i & mask))) {\n      cout << \"Impossible\\n\";\n      return 0;\n    }\n  cout << \"Possible\\n\";\n  vector<pair<int, int>> ans;\n  ans.emplace_back(0, 0);\n  for (int i = 0; i < N; ++i) {\n    if ((mask >> i) & 1) {\n      ans.emplace_back(i, 1);\n      ans.emplace_back(i + 1, 1);\n      ans.emplace_back(i + 1, 0);\n      ans.emplace_back(i, 0);\n    }\n    ans.emplace_back(i + 1, 0);\n  }\n  for (int i = N - 1; i >= 0; --i) ans.emplace_back(i, 0);\n  cout << ans.size() - 1 << '\\n';\n  for (const auto& pr : ans)\n    cout << pr.first << ' ' << pr.second << '\\n';\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long int;\n#define incID(i, l, r) for(int i = (l)    ; i <  (r); ++i)\n#define decID(i, l, r) for(int i = (r) - 1; i >= (l); --i)\n#define incII(i, l, r) for(int i = (l)    ; i <= (r); ++i)\n#define decII(i, l, r) for(int i = (r)    ; i >= (l); --i)\n#define inc(i, n)  incID(i, 0, n)\n#define dec(i, n)  decID(i, 0, n)\n#define inc1(i, n) incII(i, 1, n)\n#define dec1(i, n) decII(i, 1, n)\n#define inID(v, l, r) ((l) <= (v) && (v) <  (r))\n#define inII(v, l, r) ((l) <= (v) && (v) <= (r))\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define FR front()\n#define BA back()\n#define ALL(v) v.begin(), v.end()\n#define RALL(v) v.rbegin(), v.rend()\nauto setmin   = [](auto & a, auto b) { return (b <  a ? a = b, true : false); };\nauto setmax   = [](auto & a, auto b) { return (b >  a ? a = b, true : false); };\nauto setmineq = [](auto & a, auto b) { return (b <= a ? a = b, true : false); };\nauto setmaxeq = [](auto & a, auto b) { return (b >= a ? a = b, true : false); };\n#define SI(v) static_cast<int>(v.size())\n#define RF(e, v) for(auto & e: v)\n#define until(e) while(! (e))\n#define if_not(e) if(! (e))\n#define ef else if\n#define UR assert(false)\n#define IN(T, ...) T __VA_ARGS__; IN_(__VA_ARGS__);\nvoid IN_() { };\ntemplate<typename T, typename ... U> void IN_(T & a, U & ... b) { cin >> a; IN_(b ...); };\ntemplate<typename T> void OUT(T && a) { cout << a << endl; }\ntemplate<typename T, typename ... U> void OUT(T && a, U && ... b) { cout << a << \" \"; OUT(b ...); }\n\n// ---- ----\n\n#define bit(b, i) (((b) >> (i)) & 1)\n#define PC __builtin_popcountll\n#define BL(a) (a ? 64 - __builtin_clzll(a) : 0)\n\nint main() {\n\tIN(int, n);\n\tIN(string, a);\n\t\n\tvector<int> v;\n\tinc(b, 1 << n) {\n\t\tif(a[b] == '0') { v.PB(b); }\n\t\tif(a[b] != '1') {\n\t\t\tinc(i, n) {\n\t\t\t\tif(bit(b, i) == 1) { continue; }\n\t\t\t\tint c = b | (1 << i);\n\t\t\t\tif(a[c] == '1') { OUT(\"Impossible\"); exit(0); }\n\t\t\t\ta[c] = '2';\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> w;\n\tRF(b, v) {\n\t\tvector<int> p;\n\t\tinc(i, n) { if(bit(b, i) == 1) { p.PB(2 * i); } }\n\t\t\n\t\tvector<int> x;\n\t\tinc(k, SI(p)) {\n\t\t\tif(k == 0) { x.PB(p[0]); }\n\t\t\telse {\n\t\t\t\tint c = SI(x);\n\t\t\t\tx.PB(p[k]);\n\t\t\t\tdec(i, c) { x.PB(x[i] ^ 1); }\n\t\t\t\tx.PB(p[k] ^ 1);\n\t\t\t}\n\t\t}\n\t\tRF(e, x) { w.PB(e); }\n\t}\n\t\n\tvector<pair<int, int>> ans = { { 0, 0 } };\n\tRF(e, w) {\n\t\tinc1(i, e / 2) { ans.EB(i, 0); }\n\t\tif(e % 2 == 0) {\n\t\t\tans.EB(e / 2 + 1, 0);\n\t\t\tans.EB(e / 2 + 1, 1);\n\t\t\tans.EB(e / 2 + 0, 1);\n\t\t\tans.EB(e / 2 + 0, 0);\n\t\t} else {\n\t\t\tans.EB(e / 2 + 0, 1);\n\t\t\tans.EB(e / 2 + 1, 1);\n\t\t\tans.EB(e / 2 + 1, 0);\n\t\t\tans.EB(e / 2 + 0, 0);\n\t\t}\n\t\tdec(i, e / 2) { ans.EB(i, 0); }\n\t}\n\t\n\tOUT(\"Possible\");\n\tOUT(SI(ans) - 1);\n\tRF(e, ans) { OUT(e.FI, e.SE); }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define fr first\n#define sc second\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n\nvector<P> ret;\n\nvoid pos(int i){\n\tfor(int j=0;j<i;j++){\n\t\tret.push_back(P(j+1,0));\n\t}\n\tret.push_back(P(i,1));\n\tret.push_back(P(i+1,1));\n\tret.push_back(P(i+1,0));\n\tret.push_back(P(i,0));\n\tfor(int j=i-1;j>=0;j--){\n\t\tret.push_back(P(j,0));\n\t}\n}\nvoid neg(int i){\n\tfor(int j=0;j<i;j++){\n\t\tret.push_back(P(j+1,0));\n\t}\n\tret.push_back(P(i+1,0));\n\tret.push_back(P(i+1,1));\n\tret.push_back(P(i,1));\n\tret.push_back(P(i,0));\n\tfor(int j=i-1;j>=0;j--){\n\t\tret.push_back(P(j,0));\n\t}\n}\n\nvector<P> f(vector<P> vec,int t){\n\tint cnt[300]={};\n\tfor(int i=0;i<vec.size();i++){\n\t\tcnt[vec[i].sc]++;\n\t}\n\tint MIN=100;\n\tint id=-1;\n\tfor(int i=0;i<300;i++){\n\t\tif(cnt[i]==0)continue;\n\t\tif(MIN>cnt[i]){\n\t\t\tMIN=cnt[i];\n\t\t\tid=i;\n\t\t}\n\t}\n\t//cerr<<\"id=\"<<id<<endl;\n\tvector<P> ret;\n\tfor(int i=0;i<vec.size();i++){\n\t\tif(vec[i].sc!=id)ret.push_back(vec[i]);\n\t\telse {\n\t\t\tif(vec[i].fr==1){\n\t\t\t\tret.push_back(P(1,id));\n\t\t\t\tret.push_back(P(1,t));\n\t\t\t\tret.push_back(P(-1,id));\n\t\t\t\tret.push_back(P(-1,t));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret.push_back(P(1,t));\n\t\t\t\tret.push_back(P(1,id));\n\t\t\t\tret.push_back(P(-1,t));\n\t\t\t\tret.push_back(P(-1,id));\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nbool zero(vector<P> vec, int x){\n\tstack<P> st;\n\tfor(P p: vec){\n\t\tif((x>>p.sc)&1){\n\t\t\tif(st.size()==0){\n\t\t\t\tst.pop();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tP q=st.top();\n\t\t\tif(q.sc==p.sc&&p.sc+q.sc==0)st.pop();\n\t\t\telse st.push(p);\n\t\t}\n\t}\n\treturn st.size()==0;\n}\n\nint main(){\n\tint n;\n\tstring s;\n\tcin>>n>>s;\n\t\n\tint a[300];\n\tfor(int i=0;i<(1<<n);i++)a[i]=s[i]-'0';\n\t\n\tbool used[300];\n\tmemset(used,0,sizeof used);\n\t\n\tint b[300];\n\tfor(int i=0;i<300;i++)b[i]=1;\n\t\n\tfor(int x=1;x<(1<<n);x++){\n\t\tused[x]=true;\n\t\tfor(int y=0;y<x;y++){\n\t\t\tif((x&y)==y)if(used[y])used[x]=false;\n\t\t}\n\t\tfor(int y=0;y<(1<<n);y++){\n\t\t\tif((x&y)==x)if(a[y]==1)used[x]=false;\n\t\t}\n\t\tif(used[x]){\n\t\t\tfor(int y=0;y<(1<<n);y++){\n\t\t\t\tif((x&y)==x)b[y]=0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool ok=true;\n\tfor(int i=0;i<(1<<n);i++)ok&=a[i]==b[i];\n\tif(!ok){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tvector<P> vv;\n\t/*for(int x=0;x<(1<<n);x++){\n\t\tif(!used[x])continue;\n\t\tif(vv.size()==0){\n\t\t\tvv.push_back(P(1,x));\n\t\t}\n\t\telse{\n\t\t\tvv=f(vv,x);\n\t\t}\n\t}*/\n\tvector<P> vec[300];\n\tret.push_back(P(0,0));\n\tfor(int x=0;x<(1<<n);x++){\n\t\tif(!used[x])continue;\n\t\tif(zero(vv,x)){\n\t\t\tint cnt=0;\n\t\t\tint c[10];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif((x>>i)&1)c[cnt++]=i;\n\t\t\t}\n\t\t\tvec[x].push_back(P(1,c[0]));\n\t\t\tfor(int i=1;i<cnt;i++)vec[x]=f(vec[x],c[i]);\n\t\t\tvv.insert(vv.end(),vec[x].begin(),vec[x].end());\n\t\t}\n\t}\n\tfor(P p: vv){\n\t\tif(p.fr==1)pos(p.sc);\n\t\telse neg(p.sc);\n\t}\n\t\n\t/*for(int i=0;i<vv.size();i++){\n\t\tif(vv[i].fr==1){\n\t\t\tfor(P p: vec[vv[i].sc]){\n\t\t\t\tif(p.fr==1)pos(p.sc);\n\t\t\t\telse neg(p.sc);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor(int j=vec[vv[i].sc].size()-1;j>=0;j--){\n\t\t\t\tP p=vec[vv[i].sc][j];\n\t\t\t\tif(p.fr==1)neg(p.sc);\n\t\t\t\telse pos(p.sc);\n\t\t\t}\n\t\t}\n\t}*/\n\t\n\tassert(ret.size()<=250000);\n\t\n\tputs(\"Possible\");\n\tprintf(\"%d\\n\",(int)(ret.size())-1);\n\tfor(int i=0;i<ret.size();i++){\n\t\tprintf(\"%d %d\\n\",ret[i].fr,ret[i].sc);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\nint main() {\n\tint n = nxt();\n\tstring s;\n\tcin >> s;\n\tif (s == string(1 << n, '1')) {\n\t\tcout << \"Possible\\n\";\n\t\tcout << \"0\\n0 0\\n\";\n\t\treturn 0;\n\t}\n\tif (s[0] == '0') {\n\t\tcout << \"Impossible\\n\";\n\t\treturn 0;\n\t}\n\tconst int N = 1 << n;\n\tvector<char> base(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (__builtin_popcount(i) >= 3 && s[i] == '1') {\n\t\t\tcout << \"Impossible\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (s[i] == '0') {\n\t\t\tbase[i] = 1;\n\t\t\tfor (int j = i; j > 0; j = (j - 1) & i) {\n\t\t\t\tif (s[i ^ j] == '0') {\n\t\t\t\t\tbase[i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int j = i; j > 0; j = (j - 1) & i) {\n\t\t\tif (s[i ^ j] == '0') {\n\t\t\t\tcout << \"Impossible\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<int> ans;\n\tauto add = [&](int x, int y, int z) {\n\t\tvector<int> tmp = {-z - 1, -y - 1, -x - 1, y + 1, z + 1, -y - 1, -z - 1, x + 1, z + 1, y + 1};\n\t\tans.insert(ans.end(), all(tmp));\n\t};\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\tfor (int k = j + 1; k < n; ++k) {\n\t\t\t\tadd(i, j, k);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\tif (base[(1 << i) | (1 << j)]) {\n\t\t\t\tvector<int> tmp = {-i - 1, -j - 1, i + 1, j + 1};\n\t\t\t\tans.insert(ans.end(), all(tmp));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (base[1 << i]) {\n\t\t\tans.push_back(-i - 1);\n\t\t}\n\t}\n\tint y = 0;\n\tvector<pair<int, int>> answer = {{0, y}};\n\tauto go = [&](int c) {\n\t\twhile (y < c) {\n\t\t\ty += 1;\n\t\t\tanswer.push_back({0, y});\n\t\t}\n\t\twhile (y > c) {\n\t\t\ty -= 1;\n\t\t\tanswer.push_back({0, y});\n\t\t}\n\t};\n\n\tfor (int i : ans) {\n\t\tif (i < 0) {\n\t\t\tgo(-i - 1);\n\t\t\tanswer.push_back({1, y});\n\t\t\tanswer.push_back({1, y + 1});\n\t\t\tanswer.push_back({0, y + 1});\n\t\t\ty += 1;\n\t\t} else {\n\t\t\tgo(i);\n\t\t\tanswer.push_back({1, y});\n\t\t\tanswer.push_back({1, y - 1});\n\t\t\tanswer.push_back({0, y - 1});\n\t\t\ty -= 1;\n\t\t}\n\t}\n\tgo(0);\n\tcout << \"Possible\\n\";\n\tcout << (int)answer.size() - 1 << \"\\n\";\n\tfor (const auto& p : answer) {\n\t\tcout << p.second << \" \" << p.first << \"\\n\";\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing ll = long long;\nusing ull = unsigned long long;\nusing namespace std;\nconst int INF = 1e10;\nconst int MOD = 1e9 + 7;\n#define dump(x)                             \\\n    if (dbg) {                              \\\n        cerr << #x << \" = \" << (x) << endl; \\\n    }\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define FOR1(n) for (ll i = 0; i < (n); ++i)\n#define FOR2(i, n) for (ll i = 0; i < (n); ++i)\n#define FOR3(i, a, b) for (ll i = (a); i < (b); ++i)\n#define FOR4(i, a, b, c) for (ll i = (a); i < (b); i += (c))\n#define FOR(...) overload4(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)\n#define FORR(i, a, b) for (int i = (a); i <= (b); ++i)\n#define bit(n, k) ((n >> k) & 1) /*nのk bit目*/\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\nvoid Yes(bool flag = true) {\n    if (flag)\n        cout << \"Yes\" << endl;\n    else\n        cout << \"No\" << endl;\n}\nvoid No(bool flag = true) {\n    Yes(!flag);\n}\nvoid YES(bool flag = true) {\n    if (flag)\n        cout << \"YES\" << endl;\n    else\n        cout << \"NO\" << endl;\n}\nvoid NO(bool flag = true) {\n    YES(!flag);\n}\n#define pb emplace_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define all(v) (v).begin(), (v).end()\n#define SZ(x) ((int)(x).size())\n#define P pair<int, int>\n//#define V vector<int>\n//#define S set<int>\n#define itn int\nbool dbg = false;\n\nint N;\nstring A;\nbool checked[111010];\nbool out[111010];\n\nvector<int> x, y;\n\nvoid go(int gx) {\n    int sx;\n    int ys;\n    sx = x[(int)x.size() - 1];\n    ys = y[(int)y.size() - 1];\n    if (sx > gx) {\n        while (sx != gx) {\n            sx--;\n            x.pb(sx);\n            y.pb(ys);\n        }\n    } else if (sx < gx) {\n        while (sx != gx) {\n            sx++;\n            x.pb(sx);\n            y.pb(ys);\n        }\n    }\n}\nvoid chy() {\n    x.pb(x[(int)x.size() - 1]);\n    y.pb(!y[(int)y.size() - 1]);\n}\n\nvoid fill(int T, bool nikai = false) {\n    int cnt = __builtin_popcount(T);\n    if (cnt == 1) {\n        int nxt = __builtin_ffs(T) - 1;\n        go(nxt);\n        chy();\n        go(nxt + 1);\n        chy();\n        go(nxt);\n        chy();\n        go(nxt + 1);\n        chy();\n        go(nxt);\n        chy();\n        go(nxt + 1);\n        chy();\n        go(nxt);\n        return;\n    } else {\n        int n1 = __builtin_ffs(T) - 1;\n        T -= (1 << n1);\n        int n2 = __builtin_ffs(T) - 1;\n        int n3 = n2;\n        FOR(N) {\n            if ((1 << i) & T) {\n                n3 = i;\n            }\n        }\n        n3++;\n\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        go(n2);\n        //ここで再帰\n        if (n2 + 1 != n3) {\n            fill(T);\n        }\n        chy();\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        go(n2);\n        chy();\n        go(n1);\n\n        /*\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        go(n2);\n        chy();\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        go(n2);\n        chy();\n        go(n1);\n        */\n    }\n}\n\n\nvoid solve() {\n    bool flag = true;\n    int tmp = -1;\n    for (int T = 1; T < (1 << N); T++) {\n        if (A[T] == 1) {\n            continue;\n        }\n        if (checked[T]) {\n            continue;\n        }\n        out[T] = true;\n        if (__builtin_popcount(T) == 1) {\n            tmp = T;\n        }\n        for (int i = T; i < (1 << N); i = (i + 1) | T) {\n            // ここに処理を書く\n            if (A[i] == 1) {\n                flag = false;\n            }\n            checked[i] = true;\n        }\n    }\n    if (!flag) {\n        cout << \"Impossible\" << endl;\n        return;\n    }\n    cout << \"Possible\" << endl;\n\n    x.pb(0);\n    y.pb(0);\n\n    for (int T = 1; T < (1 << N); T++) {\n        if (out[T]) {\n            fill(T);\n        }\n    }\n    go(0);\n    int L = x.size();\n    cout << L - 1 << endl;\n\n    FOR(L) {\n        cout << x[i] << \" \" << y[i] << endl;\n    }\n}\n\nsigned main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cin >> N;\n    cin >> A;\n    for (auto& c : A)\n        c -= '0';\n\n\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\nclock_t __my_start_clock = clock();\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(\"[\"#x\"] Time : %.3lf s.\\n\", (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n#define TIMESTAMPf(x,...) eprintf(\"[\" x \"] Time : %.3lf s.\\n\", __VA_ARGS__, (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n\nusing namespace std;\n\n#ifdef LOCAL\nstatic struct __timestamper {\n  string what;\n  __timestamper(const char* what) : what(what){};\n  __timestamper(const string& what) : what(what){};\n  ~__timestamper(){\n    TIMESTAMPf(\"%s\", what.data());\n\t}\n} __TIMESTAMPER(\"end\");\n#else \nstruct __timestamper {};\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\n\nbool solve(int n, string s) {\n  if (s[0] == '0')\n    return false;\n  vector<int> bads;\n  for (int i = 0; i < (1 << n); i++) {\n    for (int j = 0; j < n; j++) {\n      if (!(i & (1 << j))) {\n        continue;\n      }\n    }\n    bool found_zero_sub = false;\n    for (int j = 0; j < n; j++) {\n      if (!(i & (1 << j))) {\n        continue;\n      }\n      if (s[i ^ (1 << j)] == '0') {\n        found_zero_sub = true;\n      }\n    }\n    if (found_zero_sub) {\n      if (s[i] == '1') {\n        return false;\n      }\n    } else {\n      if (s[i] == '0') {\n        bads.push_back(i);\n      }\n    }\n  }\n\n  vector<int> seq;\n\n  for (int x : bads) {\n    vector<int> ss;\n    for (int i = 0; i < n; i++) {\n      if (!(x & (1 << i))) {\n        continue;\n      }\n      int cur = ss.size();\n      ss.push_back(i + 1);\n      for (int j = cur - 1; j >= 0; j--) {\n        ss.push_back(-ss[j]);\n      }\n      if (cur) {\n        ss.push_back(-(i + 1));\n      }\n    }\n    seq.insert(seq.end(), ss.begin(), ss.end());\n  }\n\n  printf(\"Possible\\n\");\n\n  vector<pair<int, int>> pts;\n\n  pts.emplace_back(0, 0);\n\n  auto push = [&] (int x,int y) {\n    if (pts.size() > 1 && pts[pts.size() - 2].first == x && pts[pts.size() - 2].second == y) {\n      pts.pop_back();\n    } else {\n      pts.emplace_back(x, y);\n    }\n  };\n\n  for (int x : seq) {\n    if (x > 0) {\n      for (int i = 1; i <= x; i++) {\n        push(0, i);\n      }\n      push(1, x);\n      push(1, x - 1);\n      for (int i = x - 1; i >= 0; i--) {\n        push(0, i);\n      }\n    } else {\n      x = -x;\n      for (int i = 1; i < x; i++) {\n        push(0, i);\n      }\n      push(1, x - 1);\n      push(1, x);\n      for (int i = x ; i >= 0; i--) {\n        push(0, i);\n      }\n    }\n  }\n\n  for (auto p : pts) {\n    printf(\"%d %d\\n\", p.first, p.second);\n  }\n  return true;\n}\n\nint main() {\n#ifdef LOCAL\n  freopen(\"e.in\", \"r\", stdin);\n  freopen(\"e.out\", \"w\", stdout);\n#endif\n\n  int n;\n  while (scanf(\"%d\", &n) == 1) {\n    char s[512];\n    scanf(\"%s\", s);\n    if (!solve(n, s)) {\n      printf(\"Impossible\\n\");\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define INF ((1<<30)-1)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nint n, a[1 << 8];\n\nbool valid(int x){\n    for(int i = 0;i < (1<<n);i++){\n        if(((i & x) == 0) != a[i])return false;\n    }\n    return true;\n}\n\nvoid show(int x){\n    vector<P> ps;\n    for(int i = 0;i < n;i++){\n        ps.push_back(P(i,0));\n        if((x >> i) % 2 == 1){\n            ps.push_back(P(i,1));\n            ps.push_back(P(i+1,1));\n        }\n    }\n    for(int i = n;i >= 0;i--)ps.push_back(P(i,0));\n    cout << ps.size()-1 << endl;\n    for(int i = 0;i < ps.size();i++){\n        cout << ps[i].first << \" \" << ps[i].second << endl;\n    }\n}\n\nint main(){\n    cin  >> n;\n    for(int i = 0;i < (1 << n);i++){\n        scanf(\"%1d\", a + i);\n    }\n    int x = 0;\n    while(x < (1 << n) && !valid(x))x++;\n    if(x == (1 << n)){cout << \"Impossible\" << endl;return 0;}\n    cout << \"Possible\" << endl;\n   show(x);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nint n;\nchar s[1010];\nvector<PII> ans,c,trash;\nvector<PII> build(VI w) {\n\tif (SZ(w)==1) return vector<PII>{{w[0],0}};\n\tvector<PII> z{{w[0],0},{w[1],0},{w[0],1},{w[1],1}};\n\trep(i,2,SZ(w)) {\n\t\tvector<PII> nz=z; \n\t\tz.pb({w[i],0});\n\t\treverse(all(nz));\n\t\tfor (auto p:nz) z.pb({p.fi,p.se^1});\n\t\tz.pb({w[i],-1});\n\t}\n\treturn z;\n}\nint zz;\nint main() {\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s);\n\t//rep(i,0,(1<<n)) s[i]=(__builtin_popcount(i)<5)+'0';\n\trep(i,0,(1<<n)) if (s[i]=='0') {\n\t\trep(j,0,(1<<n)) if ((j&i)==i&&s[j]=='1') {\n\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\t\tbool cc=0;\n\t\trep(j,0,(1<<n)) if ((i&j)==j&&i!=j&&s[j]=='0') cc=1;\n\t\tif (cc) continue;\n\t\tVI w;\n\t\trep(j,0,n) if (i&(1<<j)) w.pb(j);\n\t\tauto x=build(w);\n\t\tfor (auto p:x) ans.pb(p);\n\t\tzz++;\n\t\t//rep(i,0,n) ans.pb(mp(i,0)),trash.pb(mp(i,0));\n\t\trep(i,0,100) {\n\t\t\tint x=rnd(n);\n\t\t\tans.pb(mp(x,(SZ(w)>=2))),trash.pb(mp(x,(SZ(w)>=2)));\n\t\t}\n\t}\n\t//fprintf(stderr,\"%d\\n\",zz);\n\treverse(all(trash));\n\tfor (auto p:trash) ans.pb(mp(p.fi,p.se^1));\n // rep(i,0,zz) per(j,0,n) ans.pb(mp(j,-1));\n\trep(i,0,(1<<n)) {\n\t\tstack<PII> s;\n\t\tfor (auto x:ans) {\n\t\t\tif (!(i&(1<<x.fi))) continue;\n\t\t\tif (!s.empty()&&s.top().fi==x.fi&&s.top().se==(x.se^1)) s.pop();\n\t\t\telse s.push(x);\n\t\t}\n\t\tassert(s.empty()==(::s[i]=='1'));\n\t}\n\tputs(\"Possible\");\n\tint pos=0;\n\tc.pb(mp(0,0));\n\tfor (auto p:ans) {\n\t\t//printf(\"pp %d %d\\n\",p.fi,p.se);\n\t\tif (p.se==0) {\n\t\t\twhile (pos<p.fi) {\n\t\t\t\tpos+=1;\n\t\t\t\tc.pb(mp(pos,0));\n\t\t\t}\n\t\t\twhile (pos>p.fi) {\n\t\t\t\tpos-=1;\n\t\t\t\tc.pb(mp(pos,0));\n\t\t\t}\n\t\t\tc.pb(mp(pos,1));\n\t\t\tc.pb(mp(pos+1,1));\n\t\t\tc.pb(mp(pos+1,0));\n\t\t\tpos+=1;\n\t\t} else {\n\t\t\twhile (pos<p.fi+1) {\n\t\t\t\tpos+=1;\n\t\t\t\tc.pb(mp(pos,0));\n\t\t\t}\n\t\t\twhile (pos>p.fi+1) {\n\t\t\t\tpos-=1;\n\t\t\t\tc.pb(mp(pos,0));\n\t\t\t}\n\t\t\tc.pb(mp(pos,1));\n\t\t\tc.pb(mp(pos-1,1));\n\t\t\tc.pb(mp(pos-1,0));\n\t\t\tpos-=1;\n\t\t}\n\t}\n\twhile (pos>0) {\n\t\tpos--;\n\t\tc.pb(mp(pos,0));\n\t}\n\tassert(SZ(c)<=250000);\n\tprintf(\"%d\\n\",SZ(c)-1);\n\tfor (auto x:c) printf(\"%d %d\\n\",x.fi,x.se);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,L;\nstring A;\nint ismin[256];\n\n\nvector<pair<int,int>> construct(int mask) {\n\tvector<pair<int,int>> V;\n\t\n\tint i;\n\tFOR(i,N) if(mask&(1<<i)) {\n\t\tif(__builtin_popcount(mask)==1) {\n\t\t\tV.push_back({i,1});\n\t\t\tV.push_back({i+1,1});\n\t\t\tV.push_back({i+1,0});\n\t\t\tV.push_back({i,0});\n\t\t}\n\t\telse {\n\t\t\tvector<pair<int,int>> W=construct(mask^(1<<i));\n\t\t\tV.push_back({i,1});\n\t\t\twhile(V.back().first+1<W[0].first) {\n\t\t\t\tV.push_back(V.back());\n\t\t\t\tV.back().first++;\n\t\t\t}\n\t\t\tFORR(w,W) V.push_back(w);\n\t\t\twhile(V.back().first>i+1) {\n\t\t\t\tV.push_back(V.back());\n\t\t\t\tV.back().first--;\n\t\t\t}\n\t\t\tV.push_back({i+1,1});\n\t\t\tV.push_back({i,1});\n\t\t\tV.push_back({i,0});\n\t\t\tV.push_back({i+1,0});\n\t\t\treverse(ALL(W));\n\t\t\twhile(V.back().first+1<W[0].first) {\n\t\t\t\tV.push_back(V.back());\n\t\t\t\tV.back().first++;\n\t\t\t}\n\t\t\tFORR(w,W) V.push_back(w);\n\t\t\twhile(V.back().first>i+1) {\n\t\t\t\tV.push_back(V.back());\n\t\t\t\tV.back().first--;\n\t\t\t}\n\t\t\tV.push_back({i+1,0});\n\t\t\tV.push_back({i,0});\n\t\t}\n\t}\n\treturn V;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>A;\n\tL=1<<N;\n\tFORR(c,A) c-='0';\n\tFOR(x,L) FOR(y,L) if((x&y)==y && A[x] && A[y]==0) return _P(\"Impossible\\n\");\n\tFOR(x,L) ismin[x]=A[x]==0;\n\tFOR(x,L) if(A[x]==0) FOR(y,L) if((x&y)==y && y<x && A[y]==0) ismin[y]=0;\n\t\n\tvector<pair<int,int>> W;\n\tFOR(x,L) if(A[x]==0 && ismin[x]) {\n\t\tcout<<\"!\"<<x<<endl;\n\t\tvector<pair<int,int>> V=construct(x);\n\t\tFOR(i,V[0].first) W.push_back({i,1});\n\t\tFORR(v,V) W.push_back(v);\n\t\tfor(i=V[0].first-1;i>=0;i--) W.push_back({i,0});\n\t}\n\tcout<<\"Possible\"<<endl;\n\tcout<<W.size()<<endl;\n\tFORR(w,W) cout<<w.first<<\" \"<<w.second<<endl;\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<queue>\n#include<iostream>\n#include<fstream>\n#include<string>\n#include<cassert>\n#include<algorithm>\n#include<random>\n#include<map>\n#include<set>\n#include <bitset>\n#include<ctime>\n \nusing namespace std;\n \n//int mod = 998244353;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\ntypedef vector<int>vi;\ntypedef vector<ll>vl;\ntypedef vector<char>vc;\ntypedef vector<string>vs;\ntypedef vector<vector<int>>vii;\ntypedef vector<vector<char>>vvc;\ntypedef vector<vector<ll>>vll;\ntypedef vector< pair<ll, ll>>vpll;\ntypedef vector< pair<ld, ld>>vpld;\ntypedef vector< pair<int, int>>vpi;\ntypedef pair<ld, ld>pld;\n#define mp make_pair\n#define pb push_back\n \nconst int mod = 998244353;\nint add(int a, int b)\n{\n\tint c = a + b;\n\tif (c >= mod)\n\t{\n\t\tc -= mod;\n\t}\n\treturn c;\n}\nint dif(int a, int b)\n{\n\tint c = a - b;\n\tif (c < 0)\n\t{\n\t\tc += mod;\n\t}\n\treturn c;\n}\nint mlt(int a, int b)\n{\nll c = a * 1LL * b;\nreturn c % mod;\n}\nint ibit(int n, int i)\n{\n\treturn ((n >> i) & 1);\n}\nvoid outp(vii &ou)\n{\n\tfor (int i = 0; i < ou.size(); i++)\n\t{\n\t\tfor (int j = 0; j < ou[i].size(); j++)\n\t\t{\n\t\t\tcout << ou[i][j] << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n}\nint bp(int x, int y)\n{\n\tif (y == 0)\n\t{\n\t\treturn 1;\n\t}\n\tint a = 0;\n\tif (!(y % 2))\n\t{\n\t\ta = bp(x, y / 2);\n\t}\n\treturn (y % 2) ? mlt(bp(x, y - 1), x) : mlt(a, a);\n}\nint obr(int x)\n{\n\treturn bp(x, mod - 2);\n}\nconst int maxn = 2000007;\nint fact[2000007], ofact[2000007];\nvoid prec()\n{\n\tfact[0] = 1;\n\tofact[0] = 1;\n\tfor (int i = 1; i < maxn; i++)\n\t{\n\t\tfact[i] = mlt(fact[i - 1], i);\n\t}\n\t//cerr << \"sdsds\" << endl;\n\tofact[maxn - 1] = obr(fact[maxn - 1]);\n\tfor (int i = maxn - 2; i > 0; i--)\n\t{\n\t\tofact[i] = mlt(ofact[i + 1], i + 1);\n\t}\n}\nint c(int a, int b)\n{\n\tif (a == 0)return 1;\n\treturn ((a <= b) && (a >= 0)) ? mlt(fact[b], mlt(ofact[a], ofact[b - a])) : 0;\n}\nll gcd(ll x, ll y)\n{\n\t//cerr << x << y << endl;\n\tif (x == 0)return y;\n\treturn(x > y) ? gcd(y, x) : gcd(y%x, x);\n}\nint obr2(int n)\n{\n\tint x = fact[n - 1];\n\tx = mlt(x, ofact[n]);\n\treturn x;\n}\nvoid crv(int nn, vpi &v)\n{\n\tcerr << nn << endl;\n\tif (nn > 0) {\n\t\tint n = nn;\n\t\tfor (int i = 0; i < n; i++)v.pb({ i + 1, 0 });\n\t\tv.pb({ n,1 });\n\t\tv.pb({ n - 1, 1 });\n\t\tfor (int i = n - 1; i >= 0; i--)v.pb({ i, 0 });\n\t}\n\tif (nn < 0) {\n\t\tint n = -nn;\n\t\tfor (int i = 0; i < n-1; i++)v.pb({ i + 1, 0 });\n\t\tv.pb({ n-1,1 });\n\t\tv.pb({ n , 1 });\n\t\tfor (int i = n; i >= 0; i--)v.pb({ i, 0 });\n\t}\n}\nvoid solve(istream &cin = std::cin, ostream &cout = std::cout)\n{\n\tvii imb(8);\n\timb[0] = { 1 };\n\tfor (int i = 1; i < 8; i++)\n\t{\n\t\tfor (int j = 0; j < imb[i - 1].size(); j++)imb[i].pb(imb[i - 1][j]);\n\t\timb[i].pb(i + 1);\n\t\tfor (int j = imb[i - 1].size(); j >= 0; j--)imb[i].pb((-1)*imb[i - 1][j]);\n\t\timb[i].pb(-i - 1);\n\t}\n\t//cerr << \"here\" << endl;\n\tint n;\n\tcin >> n;\n\tvi good(1 << n);\n\tfor (int i = 0; i < good.size(); i++)\n\t{\n\t\tchar c;\n\t\tcin >> c;\n\t\tgood[i] = c - '0';\n\t}\n\tint val = 0;\n\t//\tcerr << 433 << endl;\n\tfor (int a = 0; a < good.size(); a++)\n\t\tfor (int b = 0; b < good.size(); b++)\n\t\t\tif ((a | b) == b)\n\t\t\t\tif ((!good[a]) && (good[b]))\n\t\t\t\t{\n\t\t\t\t\t//\tcerr << a << ' ' << b << endl;\n\t\t\t\t\tval = 1;\n\t\t\t\t}\n//\tcerr << 5 << ' ' << 7 << ' ' << (5 | 7) << endl;\n\tif (val)cout << \"Impossible\" << endl;\n\telse\n\t{\n\t\tcout << \"Possible\" << endl;\n\t\t//cerr << 1111 << endl;\n\t\tvpi ay = { {0,0} };\n\t\tfor (int m = 0; m < good.size(); m++)\n\t\t{\n\t\t\t//cerr << m << endl;\n\t\t\tif (!good[m])\n\t\t\t{\n\t\t\t\tcerr << m << endl;\n\t\t\t\tvi v;\n\t\t\t\tfor (int i = 0; i < 8; i++)if (ibit(m, i))v.pb(i);\n\t\t\t\tcerr << m << ' ' << v.size() << endl;\n\t\t\t\tfor (int i = 0; i < imb[v.size() - 1].size(); i++)\n\t\t\t\t{\n\t\t\t\t\tcerr << imb[v.size() - 1][i] << endl;\n\t\t\t\t\t//\tcerr << i << endl;\n\t\t\t\t\tif (imb[v.size()][i] > 0)crv(v[imb[v.size() - 1][i] - 1] + 1, ay);\n\t\t\t\t\tif (imb[v.size()][i] < 0)crv(-v[(-imb[v.size() - 1][i]) - 1] - 1, ay);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif (ay.size() < 190000)\n\t\t{\n\t\t\tcout << ay.size() - 1 << endl;\n\t\t\tfor (int i = 0; i < ay.size(); i++)cout << ay[i].first << ' ' << ay[i].second << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << 0 << endl;\n\t\t\tcout << 0 << ' ' << 0 << endl;\n\t\t}\n\t}\n}\nint main()\n{\n\tsolve();\n\tint n;\n\tcin >> n;\n}\n \n "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define eb(x,y) emplace_back(x,y)\n#define fi first\n#define se second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\n//inline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\ninline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}\nint n;char s[1<<10];vector<pint>ans;\ninline string rev(string a){reverse(a.begin(),a.end());}\ninline void Solve(int sta){\n\tint cnt=0;for(int i=0;i<n;i++)cnt+=sta>>i&1;\n\tif(cnt==1){\n\t\tint t=0;for(;t<n;t++)if(sta>>t&1)break;\n\t\tRep(i,1,t)ans.eb(i,0);ans.eb(t,1),ans.eb(t+1,1),ans.eb(t+1,0);\n\t\tRed(i,t,0)ans.eb(i,0);\n\t\treturn;\n\t}\n\tstring S;S.clear();int i=0;\n\tfor(;i<n;i++)if(sta>>i&1)break;S.pb(i+'a'),S.pb(i+'A');\n\tfor(i++;i<n;i++)if(sta>>i&1)S=(char)('a'+i)+S+(char)('a'+i)+(char)('A'+i)+rev(S)+(char)('A'+i);\n\tint now=0;\n\tfor(auto o:S){\n\t\tint opt,p,d;\n\t\tif(isupper(o))opt=1,p=o-'A';else opt=0,p=o-'a';\n\t\tif(now<=p){d=0;Rep(i,now+1,p)ans.eb(i,0);}\n\t\telse{d=1;Red(i,now-1,p+1)ans.eb(i,0);}\n\t\tif(d&&opt)ans.eb(p,0),now=p;\n\t\telse if(d&&!opt)ans.eb(p+1,1),ans.eb(p,1),ans.eb(p,0),now=p;\n\t\telse if(!d&&opt)ans.eb(p+1,0),now=p+1;\n\t\telse if(!d&&!opt)ans.eb(p,1),ans.eb(p+1,1),ans.eb(p+1,0),now=p+1;\n\t}Red(i,now-1,0)ans.eb(i,0);\n}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),scanf(\"%s\",s);\n\tif(s[0]=='0')return puts(\"Impossible\"),0;\n\tfor(int i=0;i<1<<n;i++){\n\t\tif(s[i]=='1'){\n\t\t\tfor(int j=0;j<n;j++)if(i>>j&1)\n\t\t\t\tif(s[i^(1<<j)]=='0')return puts(\"Impossible\"),0;\n\t\t}else{\n\t\t\tfor(int j=0;j<n;j++)if(!(i>>j&1))\n\t\t\t\tif(s[i^(1<<j)]=='1')return puts(\"Impossible\"),0;\n\t\t}\n\t}/*ans.eb(0,0);\n\tfor(int i=0;i<1<<n;i++)if(s[i]=='0'){\n\t\tbool flg=1;\n\t\tfor(int j=0;j<n;j++)if((i>>j&1)&&s[i^(1<<j)]=='0')flg=0;\n\t\tif(flg)Solve(i);\n\t}puts(\"Possible\");cout<<ans.size()-1<<'\\n';\n\tfor(auto o:ans)cout<<o.fi<<' '<<o.se<<'\\n';*/\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing ll = long long;\nusing ull = unsigned long long;\nusing namespace std;\nconst int INF = 1e10;\nconst int MOD = 1e9 + 7;\n#define dump(x)                             \\\n    if (dbg) {                              \\\n        cerr << #x << \" = \" << (x) << endl; \\\n    }\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define FOR1(n) for (ll i = 0; i < (n); ++i)\n#define FOR2(i, n) for (ll i = 0; i < (n); ++i)\n#define FOR3(i, a, b) for (ll i = (a); i < (b); ++i)\n#define FOR4(i, a, b, c) for (ll i = (a); i < (b); i += (c))\n#define FOR(...) overload4(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)\n#define FORR(i, a, b) for (int i = (a); i <= (b); ++i)\n#define bit(n, k) ((n >> k) & 1) /*nのk bit目*/\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\nvoid Yes(bool flag = true) {\n    if (flag)\n        cout << \"Yes\" << endl;\n    else\n        cout << \"No\" << endl;\n}\nvoid No(bool flag = true) {\n    Yes(!flag);\n}\nvoid YES(bool flag = true) {\n    if (flag)\n        cout << \"YES\" << endl;\n    else\n        cout << \"NO\" << endl;\n}\nvoid NO(bool flag = true) {\n    YES(!flag);\n}\n#define pb emplace_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define all(v) (v).begin(), (v).end()\n#define SZ(x) ((int)(x).size())\n#define P pair<int, int>\n//#define V vector<int>\n//#define S set<int>\n#define itn int\nbool dbg = false;\n\nint N;\nstring A;\nbool checked[111010];\nbool out[111010];\n\nvector<int> x, y;\n\nvoid go(int gx) {\n    int sx;\n    int ys;\n    sx = x[(int)x.size() - 1];\n    ys = y[(int)y.size() - 1];\n    if (sx > gx) {\n        while (sx != gx) {\n            sx--;\n            x.pb(sx);\n            y.pb(ys);\n        }\n    } else if (sx < gx) {\n        while (sx != gx) {\n            sx++;\n            x.pb(sx);\n            y.pb(ys);\n        }\n    }\n}\nvoid chy() {\n    x.pb(x[(int)x.size() - 1]);\n    y.pb(!y[(int)y.size() - 1]);\n}\n\nvoid fill(int T, bool nikai = false) {\n    int cnt = __builtin_popcount(T);\n    if (cnt == 1) {\n        int nxt = __builtin_ffs(T) - 1;\n        go(nxt);\n        chy();\n        go(nxt + 1);\n        chy();\n        go(nxt);\n        chy();\n        go(nxt + 1);\n        chy();\n        go(nxt);\n        chy();\n        go(nxt + 1);\n        chy();\n        go(nxt);\n        return;\n    } else {\n        int n1 = __builtin_ffs(T) - 1;\n        T -= (1 << n1);\n        int n2 = __builtin_ffs(T) - 1;\n        int n3 = n2;\n        FOR(N) {\n            if ((1 << i) & T) {\n                n3 = i;\n            }\n        }\n        n3++;\n\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        if (n2 + 1 != n3) {\n            go(n3 - 1);\n            chy();\n            go(n2 + 1);\n            chy();\n        }\n        go(n2);\n        //ここで再帰\n        if (n2 + 1 != n3) {\n            fill(T);\n        }\n        chy();\n        go(n1);\n        chy();\n        go(n1 + 1);\n        chy();\n        go(n2);\n        chy();\n        if (n2 + 1 != n3) {\n            go(n2 + 1);\n            chy();\n            go(n3);\n            chy();\n        }\n        go(n3);\n        chy();\n        go(n1 + 1);\n        chy();\n        go(n1);\n\n        /*\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        go(n2);\n        chy();\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        go(n2);\n        chy();\n        go(n1);\n        */\n    }\n}\n\n\nvoid solve() {\n    bool flag = true;\n    int tmp = -1;\n    for (int T = 1; T < (1 << N); T++) {\n        if (A[T] == 1) {\n            continue;\n        }\n        if (checked[T]) {\n            continue;\n        }\n        out[T] = true;\n        if (__builtin_popcount(T) == 1) {\n            tmp = T;\n        }\n        for (int i = T; i < (1 << N); i = (i + 1) | T) {\n            // ここに処理を書く\n            if (A[i] == 1) {\n                flag = false;\n            }\n            checked[i] = true;\n        }\n    }\n    if (!flag) {\n        cout << \"Impossible\" << endl;\n        return;\n    }\n    cout << \"Possible\" << endl;\n\n    x.pb(0);\n    y.pb(0);\n\n    for (int T = 1; T < (1 << N); T++) {\n        if (out[T]) {\n            fill(T);\n        }\n    }\n    go(0);\n    int L = x.size();\n    cout << L - 1 << endl;\n\n    FOR(L) {\n        cout << x[i] << \" \" << y[i] << endl;\n    }\n}\n\nsigned main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cin >> N;\n    cin >> A;\n    for (auto& c : A)\n        c -= '0';\n\n\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\nclock_t __my_start_clock = clock();\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(\"[\"#x\"] Time : %.3lf s.\\n\", (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n#define TIMESTAMPf(x,...) eprintf(\"[\" x \"] Time : %.3lf s.\\n\", __VA_ARGS__, (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n\nusing namespace std;\n\n#ifdef LOCAL\nstatic struct __timestamper {\n  string what;\n  __timestamper(const char* what) : what(what){};\n  __timestamper(const string& what) : what(what){};\n  ~__timestamper(){\n    TIMESTAMPf(\"%s\", what.data());\n\t}\n} __TIMESTAMPER(\"end\");\n#else \nstruct __timestamper {};\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\n\nbool solve(int n, string s) {\n  if (s[0] == '0')\n    return false;\n  vector<int> bads;\n  for (int i = 0; i < (1 << n); i++) {\n    for (int j = 0; j < n; j++) {\n      if (!(i & (1 << j))) {\n        continue;\n      }\n    }\n    bool found_zero_sub = false;\n    for (int j = 0; j < n; j++) {\n      if (!(i & (1 << j))) {\n        continue;\n      }\n      if (s[i ^ (1 << j)] == '0') {\n        found_zero_sub = true;\n      }\n    }\n    if (found_zero_sub) {\n      if (s[i] == '1') {\n        return false;\n      }\n    } else {\n      if (s[i] == '0') {\n        bads.push_back(i);\n      }\n    }\n  }\n\n  vector<int> seq;\n\n  for (int x : bads) {\n    vector<int> ss;\n    for (int i = 0; i < n; i++) {\n      if (!(x & (1 << i))) {\n        continue;\n      }\n      int cur = ss.size();\n      ss.push_back(i + 1);\n      for (int j = cur - 1; j >= 0; j--) {\n        ss.push_back(-ss[j]);\n      }\n      if (cur) {\n        ss.push_back(-(i + 1));\n      }\n    }\n    seq.insert(seq.end(), ss.begin(), ss.end());\n  }\n\n  printf(\"Possible\\n\");\n\n  vector<pair<int, int>> pts;\n\n  pts.emplace_back(0, 0);\n\n  auto push = [&] (int x,int y) {\n    if (pts.size() > 1 && pts[pts.size() - 2].first == x && pts[pts.size() - 2].second == y) {\n      pts.pop_back();\n    } else {\n      pts.emplace_back(x, y);\n    }\n  };\n\n  for (int x : seq) {\n    if (x > 0) {\n      for (int i = 1; i <= x; i++) {\n        push(0, i);\n      }\n      push(1, x);\n      push(1, x - 1);\n      for (int i = x - 1; i >= 0; i--) {\n        push(0, i);\n      }\n    } else {\n      x = -x;\n      for (int i = 1; i < x; i++) {\n        push(0, i);\n      }\n      push(1, x - 1);\n      push(1, x);\n      for (int i = x ; i >= 0; i--) {\n        push(0, i);\n      }\n    }\n  }\n\n  printf(\"%d\\n\", (int)pts.size() - 1);\n  for (auto p : pts) {\n    printf(\"%d %d\\n\", p.first, p.second);\n  }\n  return true;\n}\n\nint main() {\n#ifdef LOCAL\n  freopen(\"e.in\", \"r\", stdin);\n  freopen(\"e.out\", \"w\", stdout);\n#endif\n\n  int n;\n  while (scanf(\"%d\", &n) == 1) {\n    char s[512];\n    scanf(\"%s\", s);\n    if (!solve(n, s)) {\n      printf(\"Impossible\\n\");\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\nCode for problem E by cookiedoth\nGenerated 21 Mar 2020 at 05.19 PM\n\n\n______▄███████▄_______\n______█▄█████▄█_______\n______█▼▼▼▼▼█_______\n_____██________ ██______\n______█▲▲▲▲▲█_______\n______█████████_______\n_______██____ ██________\n\n>_<\no_O\n^_^\n\n*/\n\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <ctime>\n#include <functional>\n#include <unordered_set>\n#include <unordered_map>\n#include <string>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <complex>\n#include <cassert>\n#include <random>\n#include <cstring>\n#include <numeric>\n#define ll long long\n#define ld long double\n#define null NULL\n#define all(a) a.begin(), a.end()\n#define rall(a) a.rbegin(), a.rend()\n#define debug(a) cerr << #a << \" = \" << a << endl\n#define forn(i, n) for (int i = 0; i < n; ++i)\n#define sz(a) (int)a.size()\n\nusing namespace std;\n\ntemplate<class T> int chkmax(T &a, T b) {\n\tif (b > a) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\ntemplate<class T> int chkmin(T &a, T b) {\n\tif (b < a) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\ntemplate<class iterator> void output(iterator begin, iterator end, ostream& out = cerr) {\n\twhile (begin != end) {\n\t\tout << (*begin) << \" \";\n\t\tbegin++;\n\t}\n\tout << endl;\n}\n\ntemplate<class T> void output(T x, ostream& out = cerr) {\n\toutput(x.begin(), x.end(), out);\n}\n\nvoid fast_io() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n}\n\nint x;\nvector<pair<int, int> > ans;\n\nvoid move(int dest_x) {\n\tif (x == dest_x) {\n\t\treturn;\n\t}\n\tif (dest_x > x) {\n\t\tx++;\n\t\tans.emplace_back(x, 0);\n\t} else {\n\t\tx--;\n\t\tans.emplace_back(x, 0);\n\t}\n\tmove(dest_x);\n}\n\nvoid use(int pos, int d) {\n\tif (d == 0) {\n\t\tmove(pos);\n\t\tans.emplace_back(pos, 1);\n\t\tans.emplace_back(pos + 1, 1);\n\t\tans.emplace_back(pos + 1, 0);\n\t\tx++;\n\t} else {\n\t\tmove(pos + 1);\n\t\tans.emplace_back(pos, 1);\n\t\tans.emplace_back(pos - 1, 1);\n\t\tans.emplace_back(pos - 1, 0);\n\t\tx--;\n\t}\n}\n\nconst int mx = 300;\nint n, a[mx];\n\nvector<vector<pair<int, int> > > str;\n\nvoid gen_str() {\n\tstr.resize(n + 1);\n\tstr[1] = {{0, 0}};\n\tfor (int i = 2; i <= n; ++i) {\n\t\tstr[i].emplace_back(i - 1, 0);\n\t\tfor (auto pp : str[i - 1]) {\n\t\t\tstr[i].push_back(pp);\n\t\t}\n\t\tstr[i].emplace_back(i - 1, i);\n\t\tfor (auto pp : str[i - 1]) {\n\t\t\tstr[i].emplace_back(pp.first, pp.second ^ 1);\n\t\t}\n\t}\n}\n\nvoid make(int sub) {\n\tvector<int> have;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif ((sub >> i) & 1) {\n\t\t\thave.push_back(i);\n\t\t}\n\t}\n\tint k = __builtin_popcount(sub);\n\tfor (auto pp : str[k]) {\n\t\tuse(have[pp.first], pp.second);\n\t}\n}\n\nsigned main() {\n\tfast_io();\n\tcin >> n;\n\tgen_str();\n\tfor (int i = 0; i < (1 << n); ++i) {\n\t\tchar c;\n\t\tcin >> c;\n\t\ta[i] = c - '0';\n\t}\n\tfor (int i = 0; i < (1 << n); ++i) {\n\t\tfor (int j = 0; j < i; ++j) {\n\t\t\tif (a[i] == 1 && ((i & j) == j) && a[j] == 0) {\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < (1 << n); ++i) {\n\t\tif (a[i] == 0) {\n\t\t\tint ok = 1;\n\t\t\tfor (int j = 0; j < i; ++j) {\n\t\t\t\tif (a[j] == 0 && (i & j) == j) {\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tmake(i);\n\t\t\t}\n\t\t}\n\t}\n\tmove(0);\n\tcout << ans.size() << \"\\n\";\n\tfor (auto pp : ans) {\n\t\tcout << pp.first << \" \" << pp.second << \"\\n\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <cstring>\n#include <list>  \n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <chrono>\n#include <random>\nusing namespace std;\n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \nstd::mt19937 rnd((int)std::chrono::steady_clock::now().time_since_epoch().count());\ntypedef long long ll;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN = 8;\nstruct P { int x, y; P() {} P(int x, int y) :x(x), y(y) {} };\n\nint n;\nchar s[(1 << MAXN) + 1];\nvector<P> ans;\n\nbool solve() {\n\tif (s[0] == '0') return false;\n\tvector<int> todo;\n\tREP(mask, 1 << n) {\n\t\tbool anysub = false;\n\t\tfor (int sub = 0; sub < mask; sub = (sub + (1 << n) - 1 - mask + 1)&mask) if (s[sub] == '0') anysub = true;\n\t\tif (s[mask] == '1' && anysub) return false;\n\t\tif (s[mask] == '0' && !anysub) todo.PB(mask);\n\t}\n\tans.clear();\n\t//printf(\"TODO:\"); REPSZ(i, todo) printf(\" %x\", todo[i]); puts(\"\");\n\tREPSZ(i, todo) {\n\t\tint mask = todo[i];\n\t\tvector<int> cur; REP(j, n) if (mask&(1 << j)) cur.PB(j);\n\t\tvector<P> path;\n\t\tfor (int j = SZ(cur) - 1; j >= 0; --j) {\n\t\t\tint x = cur[j];\n\t\t\tif (SZ(path) == 0) {\n\t\t\t\tpath.PB(P(x, 1)); path.PB(P(x + 1, 1)); path.PB(P(x + 1, 0)); path.PB(P(x, 0));\n\t\t\t} else {\n\t\t\t\tvector<P> oldpath = path; path.clear();\n\t\t\t\tFOR(xx, x, oldpath[0].x) path.PB(P(xx, 1));\n\t\t\t\tREPSZ(k, oldpath) path.PB(oldpath[k]);\n\t\t\t\tfor (int xx = oldpath[0].x; xx >= x; --xx) path.PB(P(xx, 1));\n\t\t\t\tFOR(xx, x, oldpath[0].x) path.PB(P(xx, 0));\n\t\t\t\tfor (int k = SZ(oldpath) - 1; k >= 0; --k) path.PB(oldpath[k]);\n\t\t\t\tfor (int xx = oldpath[0].x; xx >= x; --xx) path.PB(P(xx, 0));\n\t\t\t}\n\t\t}\n\t\tREP(xx, path[0].x) ans.PB(P(xx, 1));\n\t\tREPSZ(k, path) ans.PB(path[k]);\n\t\tfor (int xx = path[0].x - 1; xx >= 0; --xx) ans.PB(P(xx, 0));\n\t}\n\tans.PB(P(0, 1));\n\treturn true;\n}\n\nvoid run() {\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", s); assert(strlen(s) == (1 << n));\n\tif (!solve()) { printf(\"Impossible\\n\"); return; }\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d\\n\", SZ(ans) - 1);\n\tREPSZ(i, ans) printf(\"%d %d\\n\", ans[i].x, ans[i].y);\n}\n\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,L;\nstring A;\nint ismin[256];\n\n\nvector<pair<int,int>> construct(int mask) {\n\tvector<pair<int,int>> V;\n\t\n\tint i;\n\tFOR(i,N) if(mask&(1<<i)) {\n\t\tif(__builtin_popcount(mask)==1) {\n\t\t\tV.push_back({i,1});\n\t\t\tV.push_back({i+1,1});\n\t\t\tV.push_back({i+1,0});\n\t\t\tV.push_back({i,0});\n\t\t}\n\t\telse {\n\t\t\tvector<pair<int,int>> W=construct(mask^(1<<i));\n\t\t\tV.push_back({i,1});\n\t\t\twhile(V.back().first+1<W[0].first) {\n\t\t\t\tV.push_back(V.back());\n\t\t\t\tV.back().first++;\n\t\t\t}\n\t\t\tFORR(w,W) V.push_back(w);\n\t\t\twhile(V.back().first>i+1) {\n\t\t\t\tV.push_back(V.back());\n\t\t\t\tV.back().first--;\n\t\t\t}\n\t\t\tV.push_back({i+1,1});\n\t\t\tV.push_back({i,1});\n\t\t\tV.push_back({i,0});\n\t\t\tV.push_back({i+1,0});\n\t\t\treverse(ALL(W));\n\t\t\twhile(V.back().first+1<W[0].first) {\n\t\t\t\tV.push_back(V.back());\n\t\t\t\tV.back().first++;\n\t\t\t}\n\t\t\tFORR(w,W) V.push_back(w);\n\t\t\twhile(V.back().first>i+1) {\n\t\t\t\tV.push_back(V.back());\n\t\t\t\tV.back().first--;\n\t\t\t}\n\t\t\tV.push_back({i+1,0});\n\t\t\tV.push_back({i,0});\n\t\t}\n\t}\n\treturn V;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>A;\n\tL=1<<N;\n\tFORR(c,A) c-='0';\n\tFOR(x,L) FOR(y,L) if((x&y)==y && A[x] && A[y]==0) return _P(\"Impossible\\n\");\n\tFOR(x,L) ismin[x]=A[x]==0;\n\tFOR(x,L) if(A[x]==0) FOR(y,L) if((x&y)==y && y<x && A[y]==0) ismin[y]=0;\n\t\n\tvector<pair<int,int>> W;\n\tFOR(x,L) if(A[x]==0 && ismin[x]) {\n\t\tvector<pair<int,int>> V=construct(x);\n\t\tFOR(i,V[0].first) W.push_back({i,1});\n\t\tFORR(v,V) W.push_back(v);\n\t\tfor(i=V[0].first-1;i>=0;i--) W.push_back({i,0});\n\t}\n\tcout<<\"Possible\"<<endl;\n\tcout<<W.size()<<endl;\n\tFORR(w,W) cout<<w.first<<\" \"<<w.second<<endl;\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,L;\nstring A;\nint ismin[256];\n\n\nvector<pair<int,int>> construct(int mask) {\n\tvector<pair<int,int>> V;\n\t\n\tint i;\n\tFOR(i,N) if(mask&(1<<i)) {\n\t\tif(__builtin_popcount(mask)==1) {\n\t\t\tV.push_back({i,1});\n\t\t\tV.push_back({i+1,1});\n\t\t\tV.push_back({i+1,0});\n\t\t\tV.push_back({i,0});\n\t\t}\n\t\telse {\n\t\t\tvector<pair<int,int>> W=construct(mask^(1<<i));\n\t\t\tV.push_back({i,1});\n\t\t\twhile(V.back().first+1<W[0].first) {\n\t\t\t\tV.push_back(V.back());\n\t\t\t\tV.back().first++;\n\t\t\t}\n\t\t\tFORR(w,W) V.push_back(w);\n\t\t\tV.push_back(W.back());\n\t\t\tV.back().second=1;\n\t\t\twhile(V.back().first>i) {\n\t\t\t\tV.push_back(V.back());\n\t\t\t\tV.back().first--;\n\t\t\t}\n\t\t\tV.push_back({i,0});\n\t\t\tV.push_back({i+1,0});\n\t\t\tV.push_back({i+1,1});\n\t\t\treverse(ALL(W));\n\t\t\twhile(V.back().first<W[0].first) {\n\t\t\t\tV.push_back(V.back());\n\t\t\t\tV.back().first++;\n\t\t\t}\n\t\t\t\n\t\t\tFORR(w,W) V.push_back(w);\n\t\t\twhile(V.back().first>i+1) {\n\t\t\t\tV.push_back(V.back());\n\t\t\t\tV.back().first--;\n\t\t\t}\n\t\t\tV.push_back({i+1,0});\n\t\t\tV.push_back({i,0});\n\t\t}\n\t\tbreak;\n\t}\n\treturn V;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>A;\n\tL=1<<N;\n\tFORR(c,A) c-='0';\n\tFOR(x,L) FOR(y,L) if((x&y)==y && A[x] && A[y]==0) return _P(\"Impossible\\n\");\n\tFOR(x,L) ismin[x]=A[x]==0;\n\tFOR(x,L) if(A[x]==0) FOR(y,L) if((x&y)==y && y<x && A[y]==0) ismin[y]=0;\n\t\n\tvector<pair<int,int>> W;\n\tW.push_back({0,0});\n\tFOR(x,L) if(A[x]==0) {\n\t\tcout<<W.size()<<\" \"<<x<<endl;\n\t\tvector<pair<int,int>> V=construct(x);\n\t\tFOR(i,V[0].first) W.push_back({i,1});\n\t\tFORR(v,V) W.push_back(v);\n\t\tfor(i=V[0].first;i>=0;i--) W.push_back({i,1});\n\t\tW.push_back({0,0});\n\t}\n\tcout<<\"Possible\"<<endl;\n\tcout<<W.size()-1<<endl;\n\tFORR(w,W) cout<<w.first<<\" \"<<w.second<<endl;\n\t/*\n\tFOR(i,W.size()-1) {\n\t\tcout<<i<<\" \"<<W[i].first<<\" \"<<W[i].second<<\" \"<<W[i+1].first<<\" \"<<W[i+1].second<<endl;\n\t\tassert(abs(W[i].first-W[i+1].first)+abs(W[i].second-W[i+1].second)==1);\n\t}\n\t*/\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid fail(){\n\tcout << \"Impossible\" << '\\n';\n\texit(0);\n}\n\nmt19937 mt(48);\n\nvector<int> inv(vector<int> x){\n\treverse(x.begin(), x.end());\n\tfor(int& a : x) a = -a;\n\treturn x;\n}\n\nvector<int> make(vector<int> val){\n\tif(val.size() == 1){\n\t\tint f = mt() & 4;\n\t\tf -= 2;\n\t\tif(f == 0) f++;\n\t\tvector<int> x;\n\t\tif(f < 0){\n\t\t\tfor(int r = 0; r < -f; r++) x.push_back(-val.front());\n\t\t} else {\n\t\t\tfor(int r = 0; r < f; r++) x.push_back(val.front());\t\t\t\n\t\t}\n\t\treturn x;\n\t}\n\tvector<int> nval[2];\n\tvector<int> nx[2];\n\tfor(int i = 0; i < (int)val.size(); i++){\n\t\tnval[i & 1].push_back(val[i]);\n\t}\n\tnx[0] = make(nval[0]);\n\tnx[1] = make(nval[1]);\n\tvector<int> x;\n\tfor(int r : nx[0]) x.push_back(r);\n\tfor(int r : nx[1]) x.push_back(r);\n\tfor(int r : inv(nx[0])) x.push_back(r);\n\tfor(int r : inv(nx[1])) x.push_back(r);\n\treturn x;\n}\n\nvoid pr(vector<int> x){\n\tvector<pair<int,int> > path;\n\tpath.push_back({0, 0});\n\tfor(int f : x){\n\t\tint c = 0;\n\t\tint val = abs(f) - 1;\n\t\twhile(c < val){\n\t\t\tc++;\n\t\t\tpath.push_back({c, 0});\n\t\t}\n\t\tif(f > 0){\n\t\t\tpath.push_back({c, 1});\n\t\t\tpath.push_back({c+1, 1});\n\t\t\tpath.push_back({c+1, 0});\n\t\t\tpath.push_back({c, 0});\n\t\t} else {\n\t\t\tpath.push_back({c+1, 0});\n\t\t\tpath.push_back({c+1, 1});\n\t\t\tpath.push_back({c, 1});\n\t\t\tpath.push_back({c, 0});\n\t\t}\n\t\twhile(c > 0){\n\t\t\tc--;\n\t\t\tpath.push_back({c, 0});\n\t\t}\n\t}\n\tcout << path.size() << '\\n';\n\tfor(pair<int,int> a : path){\n\t\tcout << a.first << ' ' << a.second << '\\n';\n\t}\n}\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint n;\n\tcin >> n;\n\tint N = (1 << n);\n\tstring s(N, '0');\n\tcin >> s;\n\t// for(int j = 0; j < N; j++){\n\t// \ts[j] = \"01\"[(__builtin_popcount(j | (j >> 1)) <= 3)];\n\t// }\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tif((i & j) == i){\n\t\t\t\tif(s[i] < s[j]){\n\t\t\t\t\tfail();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<int> > q;\n\tfor(int i = 0; i < N; i++){\n\t\tif(s[i] == '1') continue;\n\t\tvector<int> val;\n\t\tbool fail = false;\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tif((i >> j) & 1){\n\t\t\t\tval.push_back((j+1));\n\t\t\t\tif(s[i ^ (1 << j)] == '0') fail = true;\n\t\t\t}\n\t\t}\n\t\tif(fail) continue;\n\t\tshuffle(val.begin(), val.end(), mt);\n\t\tq.push_back(val);\n\t}\n\twhile(true){\n\t\tvector<int> ans;\n\t\tshuffle(q.begin(), q.end(), mt);\n\t\tfor(vector<int> val : q){\n\t\t\tvector<int> z = make(val);\n\t\t\tfor(int v : z) ans.push_back(v);\n\t\t}\n\t\tbool works = true;\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tvector<int> stk = {0};\n\t\t\tfor(int f : ans){\n\t\t\t\tif((j >> (abs(f) - 1)) & 1){\n\t\t\t\t\tif(stk.back() == -f){\n\t\t\t\t\t\tstk.pop_back();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstk.push_back(f);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint wins = (stk.size() == 1);\n\t\t\tif(wins != s[j] - '0'){\n\t\t\t\tcerr << j << ' ' << wins << ' ' << (s[j] - '0') << '\\n';\n\t\t\t\tworks = false;\n\t\t\t}\n\t\t}\n\t\tif(!works) continue;\n\t\tcerr << ans.size() << '\\n';\n\t\tfor(int x : ans){\n\t\t\tcerr << x << ' ';\n\t\t}\n\t\tcerr << '\\n';\n\t\tpr(ans);\n\t\texit(0);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define I inline\n#define fi first\n#define se second\n#define R register\n#define LL long long\n#define mp make_pair\n#define reg register int\n#define pii pair<int,int>\n#define fo(i, a, b) for(reg i = a; i <= b; i++)\n#define fd(i, a, b) for(reg i = a; i >= b; i--)\n#define cr const reg&\nusing namespace std;\n\nI int _max(cr x, cr y) {return x > y ? x : y;}\nI int _min(cr x, cr y) {return x < y ? x : y;}\nI int read() {\n\treg x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n\treturn x * f;\n}\nI void ptt(LL x) {if(x >= 10) ptt(x / 10); putchar(x % 10 + '0');}\nI void put(LL x) {x < 0 ? putchar('-'), ptt(-x) : ptt(x);}\nI void pr1(LL x) {put(x), putchar(' ');}\nI void pr2(LL x) {put(x), puts(\"\");}\n\nchar ss[1 << 8];\nvector<pii> ans;\n\nstring rev(string s) {\n\treverse(s.begin(), s.end());\n\tfo(i, 0, (int)s.size() - 1) {\n\t\tif(isupper(s[i])) s[i] += 'a' - 'A';\n\t\telse s[i] += 'A' - 'a';\n\t} return s;\n}\n\nint main() {\n\treg n = read();\n\tscanf(\"%s\", ss);\n\tif(ss[0] == '0') {puts(\"Impossible\"); return 0;}\n\treg S = (1 << n) - 1;\n\tfo(i, 1, S) {\n\t\tif(ss[i] == '1') {\n\t\t\tfo(j, 0, n - 1) if(i >> j & 1) {\n\t\t\t\tif(ss[i ^ (1 << j)] == '0') {puts(\"Impossible\"); return 0;}\n\t\t\t}\n\t\t}\n\t} puts(\"Possible\");\n\treg now = 0; ans.push_back(pii{0, 0});\n\tfo(i, 1, S) if(ss[i] == '0'){\n\t\tbool bk = 0;\n\t\tfo(j, 0, n - 1) if(i >> j & 1) {\n\t\t\tif(ss[i ^ (1 << j)] == '0') {bk = 1; break;}\n\t\t} if(bk) break;\n\t\tstring q; q.clear();\n\t\tfd(j, n - 1, 0) if(i >> j & 1){\n\t\t\tstring c1 = {char('a' + j)}, c2 = {char('A' + j)};\n\t\t\tif(q.empty()) q += c1;\n\t\t\telse q = c1 + q + c2 + rev(q);\n\t\t} for(char c : q) {\n\t\t\treg p, o;\n\t\t\tif(isupper(c)) p = c - 'A', o = 1;\n\t\t\telse p = c - 'a', o = 0;\n\t\t\tfo(j, now + 1, p) ans.push_back(pii{j, 0});\n\t\t\tfd(j, now - 1, p) ans.push_back(pii{j, 0});\n\t\t\tnow = p;\n\t\t\tif(!o) {\n\t\t\t\tans.push_back(pii{p, 1});\n\t\t\t\tans.push_back(pii{p + 1, 1});\n\t\t\t\tans.push_back(pii{p + 1, 0});\n\t\t\t\tans.push_back(pii{p, 0});\n\t\t\t} else {\n\t\t\t\tans.push_back(pii{p + 1, 0});\n\t\t\t\tans.push_back(pii{p + 1, 1});\n\t\t\t\tans.push_back(pii{p, 1});\n\t\t\t\tans.push_back(pii{p, 0});\n\t\t\t}\n\t\t} fd(j, now - 1, 0) ans.push_back(pii{j, 0});\n\t\tnow = 0;\n\t} fd(j, now - 1, 0) ans.push_back(pii{j, 0});\n\tpr2((int)ans.size() - 1);\n\tfo(i, 0, (int)ans.size() - 1) pr1(ans[i].fi), pr2(ans[i].se);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,r,i,j,k,m,b[250250],x[250250],y[250250];\nchar s[250250];\nint main() {\n  scanf(\"%d\",&n);\n  scanf(\"%s\",s);\n  for (i=0; i<n; i++) {\n    bool all=true;\n    for (j=0; j<(1<<n); j++) if ((j>>i)&1) all&=(s[j]=='0');\n    if (all) b[m++]=i;\n  }\n  for (j=0; j<(1<<n); j++) if (s[j]=='0') {\n    for (i=0; i<m; i++) if ((j>>b[i])&1) break;\n    if (i>=m) { puts(\"Impossible\"); return 0; }\n  }\n  for (i=1; i<m; i++) if (b[i]!=b[i-1]+1) { puts(\"Impossible\"); return 0; }\n  puts(\"Possible\");\n  if (m==0) {\n    puts(\"0\");\n    puts(\"1 1\");\n    return 0;\n  }\n  for (i=0; i<m; i=j+1) {\n    if (i) for (k=b[i-1]+1; k<b[i]; k++) { x[r]=k; y[r++]=0; }\n    for (j=i; j+1<m && b[j+1]==b[j]+1; j++);\n    x[r]=b[i]; y[r++]=0;\n    for (k=b[i]; k<=b[j]+1; k++) { x[r]=k; y[r++]=1; }\n  }\n  for (k=b[m-1]+1; k>=b[0]; k--) { x[r]=k; y[r++]=0; }\n  printf(\"%d\\n\",r-1);\n  for (i=0; i<r; i++) printf(\"%d %d\\n\",x[i],y[i]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<queue>\n#include<iostream>\n#include<fstream>\n#include<string>\n#include<cassert>\n#include<algorithm>\n#include<random>\n#include<map>\n#include<set>\n#include <bitset>\n#include<ctime>\n\nusing namespace std;\n\n//int mod = 998244353;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\ntypedef vector<int>vi;\ntypedef vector<ll>vl;\ntypedef vector<char>vc;\ntypedef vector<string>vs;\ntypedef vector<vector<int>>vii;\ntypedef vector<vector<char>>vvc;\ntypedef vector<vector<ll>>vll;\ntypedef vector< pair<ll, ll>>vpll;\ntypedef vector< pair<ld, ld>>vpld;\ntypedef vector< pair<int, int>>vpi;\ntypedef pair<ld, ld>pld;\n#define mp make_pair\n#define pb push_back\n\nconst int mod = 998244353;\nint add(int a, int b)\n{\n\tint c = a + b;\n\tif (c >= mod)\n\t{\n\t\tc -= mod;\n\t}\n\treturn c;\n}\nint dif(int a, int b)\n{\n\tint c = a - b;\n\tif (c < 0)\n\t{\n\t\tc += mod;\n\t}\n\treturn c;\n}\nint mlt(int a, int b)\n{\n\tll c = a * 1LL * b;\n\treturn c % mod;\n}\nint ibit(int n, int i)\n{\n\treturn ((n >> i) & 1);\n}\nvoid outp(vii &ou)\n{\n\tfor (int i = 0; i < ou.size(); i++)\n\t{\n\t\tfor (int j = 0; j < ou[i].size(); j++)\n\t\t{\n\t\t\tcout << ou[i][j] << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n}\nint bp(int x, int y)\n{\n\tif (y == 0)\n\t{\n\t\treturn 1;\n\t}\n\tint a = 0;\n\tif (!(y % 2))\n\t{\n\t\ta = bp(x, y / 2);\n\t}\n\treturn (y % 2) ? mlt(bp(x, y - 1), x) : mlt(a, a);\n}\nint obr(int x)\n{\n\treturn bp(x, mod - 2);\n}\nconst int maxn = 2000007;\nint fact[2000007], ofact[2000007];\nvoid prec()\n{\n\tfact[0] = 1;\n\tofact[0] = 1;\n\tfor (int i = 1; i < maxn; i++)\n\t{\n\t\tfact[i] = mlt(fact[i - 1], i);\n\t}\n\t//cerr << \"sdsds\" << endl;\n\tofact[maxn - 1] = obr(fact[maxn - 1]);\n\tfor (int i = maxn - 2; i > 0; i--)\n\t{\n\t\tofact[i] = mlt(ofact[i + 1], i + 1);\n\t}\n}\nint c(int a, int b)\n{\n\tif (a == 0)return 1;\n\treturn ((a <= b) && (a >= 0)) ? mlt(fact[b], mlt(ofact[a], ofact[b - a])) : 0;\n}\nll gcd(ll x, ll y)\n{\n\t//cerr << x << y << endl;\n\tif (x == 0)return y;\n\treturn(x > y) ? gcd(y, x) : gcd(y%x, x);\n}\nint obr2(int n)\n{\n\tint x = fact[n - 1];\n\tx = mlt(x, ofact[n]);\n\treturn x;\n}\nvoid crv(int nn, vpi &v)\n{\n\t//\tcerr << nn << endl;\n\tif (nn > 0) {\n\t\tint n = nn;\n\t\tfor (int i = 0; i < n; i++)v.pb({ i + 1, 0 });\n\t\tv.pb({ n,1 });\n\t\tv.pb({ n - 1, 1 });\n\t\tfor (int i = n - 1; i >= 0; i--)v.pb({ i, 0 });\n\t}\n\tif (nn < 0) {\n\t\tint n = -nn;\n\t\tfor (int i = 0; i < n - 1; i++)v.pb({ i + 1, 0 });\n\t\tv.pb({ n - 1,1 });\n\t\tv.pb({ n , 1 });\n\t\tfor (int i = n; i >= 0; i--)v.pb({ i, 0 });\n\t}\n}\nvoid solve(istream &cin = std::cin, ostream &cout = std::cout)\n{\n\tvii imb(8);\n\timb[0] = { 1 };\n\tfor (int i = 1; i < 8; i++)\n\t{\n\t\tfor (int j = 0; j < imb[i - 1].size(); j++)imb[i].pb(imb[i - 1][j]);\n\t\timb[i].pb(i + 1);\n\t\tfor (int j = imb[i - 1].size(); j >= 0; j--)imb[i].pb((-1)*imb[i - 1][j]);\n\t\timb[i].pb(-i - 1);\n\t}\n\t//cerr << \"here\" << endl;\n\tint n;\n\tcin >> n;\n\tvi good(1 << n);\n\tfor (int i = 0; i < good.size(); i++)\n\t{\n\t//\tchar c;\n\t\t//cin >> c;\n\t//\tgood[i] = c - '0';\n\t\tgood[i] = 0;\n\t}\n\tgood[0] = 1;\n\tint val = 0;\n\t//\tcerr << 433 << endl;\n\tfor (int a = 0; a < good.size(); a++)\n\t\tfor (int b = 0; b < good.size(); b++)\n\t\t\tif ((a | b) == b)\n\t\t\t\tif ((!good[a]) && (good[b]))\n\t\t\t\t{\n\t\t\t\t\t//\tcerr << a << ' ' << b << endl;\n\t\t\t\t\tval = 1;\n\t\t\t\t}\n\t//\tcerr << 5 << ' ' << 7 << ' ' << (5 | 7) << endl;\n\tif (val)cout << \"Impossible\" << endl;\n\telse\n\t{\n\t\tcout << \"Possible\" << endl;\n\t\t//cerr << 1111 << endl;\n\t\tvpi ay = { { 0,0 } };\n\t\tfor (int m = 0; m < good.size(); m++)\n\t\t{\n\t\t\t//cerr << m << endl;\n\t\t\tif (!good[m])\n\t\t\t{\n\t\t\t\t//\tcerr << m << endl;\n\t\t\t\tvi v;\n\t\t\t\tfor (int i = 0; i < 8; i++)\n\t\t\t\t{\n\t\t\t\t\tif (ibit(m, i))\n\t\t\t\t\t{\n\t\t\t\t\t\tv.pb(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t//\tcerr << \"fdfd\"<<' '<<m<<' '<<v.size() << endl;\n\t\t\t\t//\tcerr << m << ' ' << v.size() << endl;\n\t\t\t\tfor (int i = 0; i < imb[v.size() - 1].size(); i++)\n\t\t\t\t{\n\t\t\t\t\t//\tcerr << imb[v.size() - 1][i] << endl;\n\t\t\t\t\t//\tcerr << i << endl;\n\t\t\t\t\t//cerr << i << ' ' << imb[v.size() - 1][i] << endl;\n\t\t\t\t\tif (imb[v.size() - 1][i] > 0)crv(v[imb[v.size() - 1][i] - 1] + 1, ay);\n\t\t\t\t\tif (imb[v.size() - 1][i] < 0)crv(-v[(-imb[v.size() - 1][i]) - 1] - 1, ay);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tif (ay.size() < 190000)\n\t\t{\n\t\t\tcout << ay.size() - 1 << endl;\n\t\t\tfor (int i = 0; i < ay.size(); i++)cout << ay[i].first << ' ' << ay[i].second << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << 0 << endl;\n\t\t\tcout << 0 << ' ' << 0 << endl;\n\t\t}\n\t}\n}\nint main()\n{\n\tsolve();\n\tint n;\n\tcin >> n;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sz(x) ((int) ((x).size()))\ntypedef long long ll;\ntypedef long double ld;\n\nint n, x, y;\nbool a[1 << 9];\nvector<pair<int, int>> res;\n\nvoid move(int tx, int ty) {\n  while (x > tx)\n    x--, res.push_back({x, y});\n  while (x < tx)\n    x++, res.push_back({x, y});\n  while (y > ty)\n    y--, res.push_back({x, y});\n  while (y < ty)\n    y++, res.push_back({x, y});\n}\n\nvoid solve(vector<int> p, bool d = false) {\n  if (sz(p) == 1) {\n    move(p[0] + d, 0);\n    move(p[0] + d, 1);\n    move(p[0] + !d, 1);\n    move(p[0] + !d, 0);\n    return;\n  }\n  vector<int> c;\n  c.push_back(p.back());\n  p.pop_back();\n  if (!d) {\n    solve(c, d);\n    solve(p, d);\n    solve(c, !d);\n    solve(p, !d);\n  } else {\n    solve(p, !d);\n    solve(c, !d);\n    solve(p, d);\n    solve(c, d);\n  }\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  cin >> n;\n  char c;\n  bool p = true;\n  for (int i = 0; i < 1 << n; i++) {\n    cin >> c, a[i] = c == '1';\n    if (a[i])\n      for (int j = 1 << n; j >= 0; j--)\n        p &= a[i & j];\n  }\n  p &= a[0];\n  if (!p) {\n    cout << \"Impossible\\n\";\n    return 0;\n  }\n  for (int i = 0; i < 1 << n; i++) {\n    p = !a[i];\n    for (int j = 1 << n; j >= 0; j--)\n      if ((i & j) != i)\n        p &= a[i & j];\n    if (p) {\n      vector<int> pos;\n      for (int j = n - 1; j >= 0; j--)\n        if ((i >> j) & 1)\n          pos.push_back(j);\n      solve(pos);\n    }\n  }\n  move(0, 0);\n  cout << \"Possible\\n\";\n  cout << sz(res) << \"\\n\";\n  cout << \"0 0\\n\";\n  for (auto pos : res)\n    cout << pos.first << \" \" << pos.second << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n// U1, D1, U2, D2, D1, U1, U2, D3, U3, U2, U3, D3, U2\n\n/*\nN = 2\nU2, U1, D1, U2, D2, D1, U1, D2\n\nN = 3\nU3, U2, U1, D1, U2, D2, D1, U1, D2, U3, D3, D2, U1, D1, D2, U2, D1, U1, U2, D3\n-->                                 <---->                                  <--\n\nS -> UN, S, UN, DN, rev(S), DN\n\nL -> 2L+4\n\nO(2^N)\n\n{0, 3, 4} -> NO     S1\n{1, 3} -> NO        S2\n\nS1 + S2\n\n{0, 2, 3} -> YES\n* */\n\nvoid impossible() {\n\tputs(\"Impossible\");\n\texit(0);\n}\n\nconst int UP = 0, DOWN = 1;\nvector<pair<int,int>> rec(vector<int> group) {\n\tif(group.empty()) {\n\t\treturn {};\n\t}\n\tint last = group.back();\n\tgroup.pop_back();\n\tvector<pair<int,int>> s = rec(group);\n\t// S -> UN, S, UN, DN, rev(S), DN\n\tvector<pair<int,int>> total;\n\tif(!s.empty()) total.emplace_back(last, UP);\n\tfor(auto p : s) {\n\t\ttotal.push_back(p);\n\t}\n\ttotal.emplace_back(last, UP);\n\ttotal.emplace_back(last, DOWN);\n\treverse(s.begin(), s.end());\n\tfor(auto p : s) {\n\t\ttotal.push_back(p);\n\t}\n\tif(!s.empty()) total.emplace_back(last, DOWN);\n\treturn total;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tstring s;\n\tcin >> s;\n\tvector<bool> possible(1 << n);\n\tfor(int mask = 0; mask < (1 << n); ++mask) {\n\t\tpossible[mask] = (s[mask] == '1');\n\t}\n\t// minimal subsets that give answer NO\n\tvector<int> minimal;\n\tfor(int mask = 0; mask < (1 << n); ++mask) {\n\t\tif(!possible[mask]) {\n\t\t\tbool is_minimal = true;\n\t\t\tfor(int bit = 0; bit < n; ++bit) {\n\t\t\t\tif(mask & (1 << bit)) {\n\t\t\t\t\tif(!possible[mask ^ (1 << bit)]) {\n\t\t\t\t\t\tis_minimal = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(is_minimal) {\n\t\t\t\tminimal.push_back(mask);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int x : minimal) {\n\t\tfor(int y : minimal) {\n\t\t\tif(x != y && ((x & y) == y)) {\n\t\t\t\timpossible();\n\t\t\t}\n\t\t}\n\t}\n\tfor(int mask = 0; mask < (1 << n); ++mask) {\n\t\tbool contains = false;\n\t\tfor(int x : minimal) {\n\t\t\tif((mask & x) == x) {\n\t\t\t\tcontains = true;\n\t\t\t}\n\t\t}\n\t\tif(contains == possible[mask]) {\n\t\t\timpossible();\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tdebug() << imie(minimal);\n\tpair<int,int> me{0, 0};\n\tvector<pair<int,int>> answer;\n\tanswer.push_back(me);\n\tauto f = [&](int x, int y) {\n\t\tassert(me.first == x || me.second == y);\n\t\tassert(me != make_pair(x, y));\n\t\tfor(int i = me.first + 1; i < x; ++i) {\n\t\t\tanswer.emplace_back(i, me.second);\n\t\t}\n\t\tfor(int i = me.first - 1; i > x; --i) {\n\t\t\tanswer.emplace_back(i, me.second);\n\t\t}\n\t\tme = {x, y};\n\t\tanswer.push_back(me);\n\t};\n\tfor(int mask : minimal) {\n\t\tvector<int> group;\n\t\tfor(int bit = 0; bit < n; ++bit) {\n\t\t\tif(mask & (1 << bit)) {\n\t\t\t\tgroup.push_back(bit);\n\t\t\t}\n\t\t}\n\t\treverse(group.begin(), group.end());\n\t\tvector<pair<int,int>> moves = rec(group);\n\t\tdebug() << imie(moves);\n\t\tfor(pair<int,int> move : moves) {\n\t\t\tint x = move.first;\n\t\t\tint type = move.second;\n\t\t\tif(me.first < x) {\n\t\t\t\tf(x, 0);\n\t\t\t}\n\t\t\telse if(me.first > x + 1) {\n\t\t\t\tf(x + 1, 0);\n\t\t\t}\n\t\t\tif(type == UP) {\n\t\t\t\tf(me.first, 1);\n\t\t\t\tf(x + x + 1 - me.first, 1);\n\t\t\t\tf(me.first, 0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tf(x + x + 1 - me.first, 0);\n\t\t\t}\n\t\t}\n\t\tif(me != make_pair(0, 0)) {\n\t\t\tf(0, 0);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", (int) answer.size() - 1);\n\tfor(pair<int,int> p : answer) {\n\t\tprintf(\"%d %d\\n\", p.first, p.second);\n\t}\n}\n\n// U1, U0, D0, U1, D1, D0, U0, D1\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T>\nvector<T>& operator += (vector<T>& a, vector<T> b) {\n\tfor (auto x : b) {\n\t\ta.push_back(x);\n\t}\n\treturn a;\n}\ntemplate <typename T>\nvector<T> operator ~ (vector<T> a) {\n  reverse(a.begin(), a.end());\n  return a;\n}\n\ntypedef class Point {\n  public:\n    int x, y;\n\n    Point() { }\n    Point(int x, int y) : x(x), y(y) {  }\n\n    bool operator == (Point b) {\n      return x == b.x && y == b.y;\n    }\n} Point;\n\ntypedef class Data {\n  public:\n    char dir;\n    int num;\n\n    Data() {  }\n    Data(char dir, int num) : dir(dir), num(num) {  }\n} Data;\n\nint n, N;\n\nvector<Point> _export(vector<Data> vd) {\n  vector<Point> ret {Point(n, 1)};\n  for (auto t : vd) {\n    auto lst = ret.back();\n    if (t.dir == 'd' && lst.y == 1) {\n      ret.emplace_back(lst.x, 0);\n    } else if (t.dir == 'u' && lst.y == 0) {\n      ret.emplace_back(lst.x, 1);\n    }\n    lst = ret.back();\n    if (lst.x == t.num) {\n      lst.x--;\n    } else if (lst.x == t.num - 1) {\n      lst.x++;\n    } else {\n      assert(false);\n    }\n    ret.push_back(lst);\n  }\n  if (ret[0] == ret.back()) {\n    ret.pop_back();\n  }\n  return ret;\n}\nvector<Point> _export(vector<Data> vd, vector<int> pos) {\n  for (auto& t : vd) {\n    t.num = pos[t.num - 1] + 1;\n  }\n  vector<Data> nvd;\n  for (int i = n; i > vd[0].num; i--) {\n      nvd.emplace_back('d', i);\n  }\n  for (auto t : vd) {\n    if (!nvd.empty()) {\n      auto& lst = nvd.back();\n      for (int i = t.num + 1; i < lst.num; i++) {\n        nvd.emplace_back('d', i);\n      }\n      for (int i = t.num - 1; i > lst.num; i--) {\n        nvd.emplace_back('d', i);\n      }\n    }\n    nvd.push_back(t);\n  }\n  for (int i = nvd.back().num + 1; i <= n; i++) {\n    nvd.emplace_back('d', i);\n  }\n  return _export(nvd);\n}\n\nchar A[530];\nvector<Data> df[10];\n\n#define NO do puts(\"Impossible\"), exit(0); while (0)\n\nint main() {\n  scanf(\"%d\", &n);\n  N = 1 << n;\n  scanf(\"%s\", A);\n  if (A[0] != '1') {\n    NO;\n  }\n\tfor (int s = 0; s < N; s++) {\n    if (A[s] == '1') {\n      for (int i = 0; i < n; i++) {\n        if (((s >> i) & 1) && A[s ^ (1 << i)] == '0') {\n          NO;\n        }\n      }\n    }\n  }\n  df[1].emplace_back('d', 1);\n  df[1].emplace_back('u', 1);\n  for (int i = 2; i <= n; i++) {\n    df[i].emplace_back('u', i);\n    df[i] += df[i - 1];\n    df[i].emplace_back('u', i);\n    df[i].emplace_back('d', i);\n    df[i] += ~df[i - 1];\n    df[i].emplace_back('d', i);\n  }\n  vector<Point> ans;\n  for (int s = 1; s < N; s++) {\n    if (A[s] == '0') {\n      vector<int> pos;\n      int bit = 0;\n      for (int i = 0; i < n; i++) {\n        if ((s >> i) & 1) {\n          pos.push_back(i);\n          bit++;\n        }\n      }\n      ans += _export(df[bit], pos);\n    }\n  }\n  puts(\"Possible\");\n  printf(\"%d\\n\", (signed) ans.size());\n  if (ans.empty()) {\n    ans.emplace_back(0, 0);\n  } else {\n    ans.push_back(ans[0]);\n  }\n  for (auto p : ans) {\n    printf(\"%d %d\\n\", p.x, p.y);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing ll = long long;\nusing ull = unsigned long long;\nusing namespace std;\nconst int INF = 1e10;\nconst int MOD = 1e9 + 7;\n#define dump(x)                             \\\n    if (dbg) {                              \\\n        cerr << #x << \" = \" << (x) << endl; \\\n    }\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define FOR1(n) for (ll i = 0; i < (n); ++i)\n#define FOR2(i, n) for (ll i = 0; i < (n); ++i)\n#define FOR3(i, a, b) for (ll i = (a); i < (b); ++i)\n#define FOR4(i, a, b, c) for (ll i = (a); i < (b); i += (c))\n#define FOR(...) overload4(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)\n#define FORR(i, a, b) for (int i = (a); i <= (b); ++i)\n#define bit(n, k) ((n >> k) & 1) /*nのk bit目*/\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\nvoid Yes(bool flag = true) {\n    if (flag)\n        cout << \"Yes\" << endl;\n    else\n        cout << \"No\" << endl;\n}\nvoid No(bool flag = true) {\n    Yes(!flag);\n}\nvoid YES(bool flag = true) {\n    if (flag)\n        cout << \"YES\" << endl;\n    else\n        cout << \"NO\" << endl;\n}\nvoid NO(bool flag = true) {\n    YES(!flag);\n}\n#define pb emplace_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define all(v) (v).begin(), (v).end()\n#define SZ(x) ((int)(x).size())\n#define P pair<int, int>\n//#define V vector<int>\n//#define S set<int>\n#define itn int\nbool dbg = false;\n\nint N;\nstring A;\nbool checked[1010];\nbool out[1010];\n\nvector<int> x, y;\n\nvoid go(int gx) {\n    int sx;\n    int ys;\n    sx = x[(int)x.size() - 1];\n    ys = y[(int)y.size() - 1];\n    if (sx > gx) {\n        while (sx != gx) {\n            sx--;\n            x.pb(sx);\n            y.pb(ys);\n        }\n    } else if (sx < gx) {\n        while (sx != gx) {\n            sx++;\n            x.pb(sx);\n            y.pb(ys);\n        }\n    }\n}\nvoid chy() {\n    x.pb(x[(int)x.size() - 1]);\n    y.pb(!y[(int)y.size() - 1]);\n}\n\nvoid fill(int T, bool nikai = false) {\n    int cnt = __builtin_popcount(T);\n    if (cnt == 1) {\n        int nxt = __builtin_ffs(T) - 1;\n        go(nxt);\n        chy();\n        go(nxt + 1);\n        chy();\n        go(nxt);\n        chy();\n        go(nxt + 1);\n        chy();\n        go(nxt);\n        chy();\n        go(nxt + 1);\n        chy();\n        go(nxt);\n        return;\n    } else {\n        int n1 = __builtin_ffs(T) - 1;\n        T -= (1 << n1);\n        int n2 = __builtin_ffs(T) - 1;\n        int n3 = n2;\n        FOR(N) {\n            if ((1 << i) & T) {\n                n3 = i;\n            }\n        }\n        n3++;\n\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        go(n2);\n        //ここで再帰\n        if (n2 + 1 != n3) {\n            fill(T);\n        }\n        chy();\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        go(n2);\n        chy();\n        go(n1);\n\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        go(n2);\n        chy();\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        go(n2);\n        chy();\n        go(n1);\n    }\n}\n\n\nvoid solve() {\n    bool flag = true;\n    int tmp = -1;\n    for (int T = 1; T < (1 << N); T++) {\n        if (A[T] == 1) {\n            continue;\n        }\n        if (checked[T]) {\n            continue;\n        }\n        out[T] = true;\n        if (__builtin_popcount(T) == 1) {\n            tmp = T;\n        }\n        for (int i = T; i < (1 << N); i = (i + 1) | T) {\n            // ここに処理を書く\n            if (A[i] == 1) {\n                flag = false;\n            }\n            checked[i] = true;\n        }\n    }\n    if (!flag) {\n        cout << \"Impossible\" << endl;\n        return;\n    }\n    cout << \"Possible\" << endl;\n\n    x.pb(0);\n    y.pb(0);\n\n    for (int T = 1; T < (1 << N); T++) {\n        if (out[T]) {\n            fill(T);\n        }\n    }\n    go(0);\n    int L = x.size();\n    cout << L - 1 << endl;\n\n    FOR(L) {\n        cout << x[i] << \" \" << y[i] << endl;\n    }\n}\n\nsigned main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cin >> N;\n    cin >> A;\n    for (auto& c : A)\n        c -= '0';\n\n\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst char* IMPOSSIBLE = \"Impossible\";\nconst char* POSSIBLE = \"Possible\";\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint N; cin >> N;\n\tvector<bool> A(1<<N);\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tchar c; cin >> c;\n\t\tassert(c == '0' || c == '1');\n\t\tA[(1<<N)-1-m] = (c == '1');\n\t}\n\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\t// m2 is a superset\n\t\t\tif (A[m] > A[m | (1<<i)]) {\n\t\t\t\tcout << IMPOSSIBLE << '\\n';\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t}\n\tcout << POSSIBLE << '\\n';\n\tmt19937 mt(48);\n\tvector<int> minM;\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tif (!A[m]) continue;\n\t\tbool isMinimal = true;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif ((m & (1<<i)) && A[m ^ (1<<i)]) {\n\t\t\t\tisMinimal = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isMinimal) {\n\t\t\tminM.push_back(m);\n\t\t}\n\t}\n\tshuffle(minM.begin(), minM.end(), mt);\n\n\tqueue<vector<int>> q;\n\tfor (int m : minM) {\n\t\tvector<int> v;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (m & (1<<i)) {\n\t\t\t\tv.push_back(i+1);\n\t\t\t\tv.push_back(i+1);\n\t\t\t}\n\t\t}\n\t\tshuffle(v.begin(), v.end(), mt);\n\t\tq.push(v);\n\t}\n\n\twhile (q.size() >= 2) {\n\t\tvector<int> a = std::move(q.front()); q.pop();\n\t\tvector<int> b = std::move(q.front()); q.pop();\n\n\t\tvector<int> c;\n\t\tfor (int i : a) { c.push_back(i); }\n\t\tfor (int i : b) { c.push_back(i); }\n\t\treverse(a.begin(), a.end());\n\t\treverse(b.begin(), b.end());\n\t\tfor (int i : a) { c.push_back(-i); }\n\t\tfor (int i : b) { c.push_back(-i); }\n\t\tq.push(c);\n\t}\n\n\tvector<int> pattern;\n\tif (!q.empty()) {\n\t\tpattern = std::move(q.front()); q.pop();\n\t}\n\n\tvector<bool> patA(1<<N);\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tstack<int> st;\n\t\tfor (int i : pattern) {\n\t\t\tif (m & (1<<(abs(i)-1))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!st.empty() && st.top() == -i) {\n\t\t\t\tst.pop();\n\t\t\t} else {\n\t\t\t\tst.push(i);\n\t\t\t}\n\t\t}\n\t\tpatA[m] = st.empty();\n\t}\n\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tassert(patA[m] == A[m]);\n\t}\n\n\tvector<pair<int, int>> pos;\n\tpos.emplace_back(0,1);\n\tauto goToPt = [&](int x) {\n\t\tassert(pos.back().second == 1);\n\t\tif (pos.back() == pair<int, int>(x,1)) {\n\t\t\treturn;\n\t\t}\n\t\tpos.emplace_back(pos.back().first, 0);\n\t\twhile (pos.back().first < x) {\n\t\t\tpos.emplace_back(pos.back().first+1, 0);\n\t\t}\n\t\twhile (pos.back().first > x) {\n\t\t\tpos.emplace_back(pos.back().first-1, 0);\n\t\t}\n\t\tpos.emplace_back(x,1);\n\t};\n\tfor (auto i : pattern) {\n\t\tassert(i != 0);\n\t\tif (i > 0) {\n\t\t\tgoToPt(i-1);\n\t\t\tpos.emplace_back(i, 1);\n\t\t} else {\n\t\t\tgoToPt(-i);\n\t\t\tpos.emplace_back(-i-1, 1);\n\t\t}\n\t}\n\n\tgoToPt(0);\n\n\tif (int(pos.size()) - 1 > 250000) {\n\t\twhile (true);\n\t}\n\tcout << pos.size()-1 << '\\n';\n\tfor (auto it : pos) {\n\t\tcout << it.first << ' ' << it.second << '\\n';\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* cerberus97 - Hanit Banga */\n\n#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\n#define pb push_back\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 1e5 + 10;\n\nint main() {\n\tfast_cin();\n\tint n; string s;\n\tcin >> n >> s;\n\tint tot = (1 << n), biggest = -1;\n\tfor (int mask = 0; mask < tot; ++mask) {\n\t\tif (s[mask] == '0') {\n\t\t\tcontinue;\n\t\t}\n\t\tbiggest = mask;\n\t\tfor (int sub = 0; sub < mask; ++sub) {\n\t\t\tif ((mask & sub) == sub and s[sub] == '0') {\n\t\t\t\tcout << \"Impossible\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (biggest == -1) {\n\t\tcout << \"Impossible\\n\";\n\t\treturn 0;\n\t}\n\tfor (int mask = 0; mask < tot; ++mask) {\n\t\tif (s[mask] == '1' and (mask & biggest) != mask) {\n\t\t\tcout << \"Impossible\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tvector<pii> pts = {{0, 0}};\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!((biggest >> i) & 1)) {\n\t\t\tpts.pb({i, 1});\n\t\t\tpts.pb({i + 1, 1});\n\t\t}\n\t\tpts.pb({i + 1, 0});\n\t}\n\tfor (int i = n - 1; i >= 0; --i) {\n\t\tpts.pb({i, 0});\n\t}\n\tcout << \"Possible\\n\" << pts.size() - 1 << '\\n';\n\tfor (auto& p : pts) {\n\t\tcout << p.first << ' ' << p.second << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst char* IMPOSSIBLE = \"Impossible\";\nconst char* POSSIBLE = \"Possible\";\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint N; cin >> N;\n\tvector<bool> A(1<<N);\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tchar c; cin >> c;\n\t\tassert(c == '0' || c == '1');\n\t\tA[(1<<N)-1-m] = (c == '1');\n\t}\n\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\t// m2 is a superset\n\t\t\tif (A[m] > A[m | (1<<i)]) {\n\t\t\t\tcout << IMPOSSIBLE << '\\n';\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t}\n\tcout << POSSIBLE << '\\n';\n\tmt19937 mt(48);\n\tvector<int> minM;\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tif (!A[m]) continue;\n\t\tbool isMinimal = true;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif ((m & (1<<i)) && A[m ^ (1<<i)]) {\n\t\t\t\tisMinimal = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isMinimal) {\n\t\t\tminM.push_back(m);\n\t\t}\n\t}\n\tshuffle(minM.begin(), minM.end(), mt);\n\n\tqueue<vector<int>> q;\n\tfor (int m : minM) {\n\t\tvector<int> v;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (m & (1<<i)) {\n\t\t\t\tv.push_back(i+1);\n\t\t\t\tv.push_back(i+1);\n\t\t\t}\n\t\t}\n\t\tshuffle(v.begin(), v.end(), mt);\n\t\tq.push(v);\n\t}\n\n\twhile (q.size() >= 2) {\n\t\tvector<int> a = std::move(q.front()); q.pop();\n\t\tvector<int> b = std::move(q.front()); q.pop();\n\n\t\tvector<int> c;\n\t\tfor (int i : a) { c.push_back(i); }\n\t\tfor (int i : b) { c.push_back(i); }\n\t\treverse(a.begin(), a.end());\n\t\treverse(b.begin(), b.end());\n\t\tfor (int i : a) { c.push_back(-i); }\n\t\tfor (int i : b) { c.push_back(-i); }\n\t\tq.push(c);\n\t}\n\n\tvector<int> pattern;\n\tif (!q.empty()) {\n\t\tpattern = std::move(q.front()); q.pop();\n\t}\n\n\tvector<pair<int, int>> pos;\n\tpos.emplace_back(0,1);\n\tauto goToPt = [&](int x) {\n\t\tassert(pos.back().second == 1);\n\t\tif (pos.back() == pair<int, int>(x,1)) {\n\t\t\treturn;\n\t\t}\n\t\tpos.emplace_back(pos.back().first, 0);\n\t\twhile (pos.back().first < x) {\n\t\t\tpos.emplace_back(pos.back().first+1, 0);\n\t\t}\n\t\twhile (pos.back().first > x) {\n\t\t\tpos.emplace_back(pos.back().first-1, 0);\n\t\t}\n\t\tpos.emplace_back(x,1);\n\t};\n\tfor (auto i : pattern) {\n\t\tassert(i != 0);\n\t\tif (i > 0) {\n\t\t\tgoToPt(i-1);\n\t\t\tpos.emplace_back(i, 1);\n\t\t} else {\n\t\t\tgoToPt(-i);\n\t\t\tpos.emplace_back(-i-1, 1);\n\t\t}\n\t}\n\n\tgoToPt(0);\n\n\tif (int(pos.size()) - 1 > 250000) {\n\t\twhile (true);\n\t}\n\tcout << pos.size()-1 << '\\n';\n\tfor (auto it : pos) {\n\t\tcout << it.first << ' ' << it.second << '\\n';\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &x) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (x = 0; c >= 33 && c <= 126; s[++x] = c, c = gc());\n\t\ts[x+1] = '\\0';\n\t}\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(string s) {\n\t\tint x = s.length();\n\t\twhile (t < x) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printc;\nusing io::prints;\n\n#define Fail prints(\"Impossible\"), exit(0)\n#define vp vector<pi>\nint n, f[1<<8|1];\nstring s;\nvp p[1<<8|1], ans(1, mp(0, 0));\n\ninline bool pd(int i) {\n\tfor (int j = (i - 1) & i; j; j = (j - 1) & i)\n\t\tif (s[j] == '0') return 0;\n\treturn 1;\n}\n\ninline void merge(vp &a, vp b) {\n\tfor (pi o : b) a.pb(o);\n}\n\n//inline vp prime(vp a) {\n//\tfor (pi &o : a) o.se ^= 1;\n//\treturn a;\n//}\n\ninline vp work(int i) {\n\tif (p[i].size()) return p[i];\n\tint j = i & -i, k = f[j];\n\tp[i].pb(mp(k, 1));\n\tp[i].pb(mp(k + 1, 1));\n\tvp t = work(i - j);\n\tmerge(p[i], t);\n\tp[i].pb(mp(k + 1, 1));\n\tp[i].pb(mp(k, 1));\n\tp[i].pb(mp(k, 0));\n\tp[i].pb(mp(k + 1, 0));\n\tp[i].pb(mp(k + 1, 1));\n\treverse(t.begin(), t.end());\n\tmerge(p[i], t);\n\tp[i].pb(mp(k + 1, 1));\n\tp[i].pb(mp(k + 1, 0));\n\tp[i].pb(mp(k, 0));\n\tp[i].pb(mp(k, 1));\n\treturn p[i];\n}\n\ninline vp get(pi a, pi b) {\n\tvp ret(1, a);\n\tif (a.se != b.se) return ret.pb(b), ret;\n\twhile (a != b)\n\t\ta.fi += a.fi < b.fi ? 1 : -1, ret.pb(a);\n\treturn ret;\n}\n\ninline vp update(vp a) {\n\tif (a.size() == 1u) return a;\n\tvp b;\n\tfor (ui i = 1; i < a.size(); i++) merge(b, get(a[i-1], a[i]));\n\treturn b;\n}\n\n//inline void print(vp ans) {\n//\tans.erase(unique(ans.begin(), ans.end()), ans.end());\n//\tdbg(ans.size() - 1);\n//\tfor (pi o : ans) debug(\"%d %d\\n\", o.fi, o.se);\n//}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\tcin >> n >> s;\n\tif (s[0] == '0') Fail;\n\tfor (int i = 0; i < (1 << n); i++)\n\t\tif (s[i] == '1')\n\t\t\tfor (int j = i; j; j = (j - 1) & i)\n\t\t\t\tif (s[j] == '0') Fail;\n\tfor (int i = 0; i < n; i++) {\n\t\tf[1<<i] = i;\n\t\tp[1<<i].pb(mp(i, 1));\n\t\tp[1<<i].pb(mp(i + 1, 1));\n\t\tp[1<<i].pb(mp(i + 1, 0));\n\t\tp[1<<i].pb(mp(i, 0));\n\t\tp[1<<i].pb(mp(i, 1));\n\t}\n\tfor (int i = 0; i < (1 << n); i++)\n\t\tif (s[i] == '0' && pd(i))\n\t\t\tans.pb(mp(0, 1)), merge(ans, work(i)),\n\t\t\tans.pb(mp(0, 1)), ans.pb(mp(0, 0));\n//\tprint(work(6));\n\tans = update(ans);\n\tans.erase(unique(ans.begin(), ans.end()), ans.end());\n\tprints(\"Possible\");\n\tprint(ans.size() - 1);\n\tfor (pi o : ans) print(o.fi, o.se);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid fail(){\n\tcout << \"Impossible\" << '\\n';\n\texit(0);\n}\n\nmt19937 mt(48);\n\nvector<int> inv(vector<int> x){\n\treverse(x.begin(), x.end());\n\tfor(int& a : x) a = -a;\n\treturn x;\n}\n\nvector<int> make(vector<int> val){\n\tif(val.size() == 1){\n\t\treturn val;\n\t}\n\tvector<int> nval[2];\n\tvector<int> nx[2];\n\tfor(int i = 0; i < (int)val.size(); i++){\n\t\tnval[i & 1].push_back(val[i]);\n\t}\n\tnx[0] = make(nval[0]);\n\tnx[1] = make(nval[1]);\n\tvector<int> x;\n\tfor(int r : nx[0]) x.push_back(r);\n\tfor(int r : nx[1]) x.push_back(r);\n\tfor(int r : inv(nx[0])) x.push_back(r);\n\tfor(int r : inv(nx[1])) x.push_back(r);\n\treturn x;\n}\n\nvoid pr(vector<int> x){\n\tvector<pair<int,int> > path;\n\tpath.push_back({0, 0});\n\tfor(int f : x){\n\t\tint c = 0;\n\t\tint val = abs(f) - 1;\n\t\twhile(c < val){\n\t\t\tc++;\n\t\t\tpath.push_back({c, 0});\n\t\t}\n\t\tif(f > 0){\n\t\t\tpath.push_back({c, 1});\n\t\t\tpath.push_back({c+1, 1});\n\t\t\tpath.push_back({c+1, 0});\n\t\t\tpath.push_back({c, 0});\n\t\t} else {\n\t\t\tpath.push_back({c+1, 0});\n\t\t\tpath.push_back({c+1, 1});\n\t\t\tpath.push_back({c, 1});\n\t\t\tpath.push_back({c, 0});\n\t\t}\n\t\twhile(c > 0){\n\t\t\tc--;\n\t\t\tpath.push_back({c, 0});\n\t\t}\n\t}\n\tcout << \"Possible\" << '\\n';\n\tcout << (int)path.size() - 1 << '\\n';\n\tfor(pair<int,int> a : path){\n\t\tcout << a.first << ' ' << a.second << '\\n';\n\t}\n}\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint n;\n\tcin >> n;\n\tint N = (1 << n);\n\tstring s(N, '0');\n\tcin >> s;\n\t// for(int j = 0; j < N; j++){\n\t// \ts[j] = \"01\"[(__builtin_popcount(j | (j >> 1)) <= 3)];\n\t// }\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tif((i & j) == i){\n\t\t\t\tif(s[i] < s[j]){\n\t\t\t\t\tfail();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<int> > q;\n\tfor(int i = 0; i < N; i++){\n\t\tif(s[i] == '1') continue;\n\t\tvector<int> val;\n\t\tbool fail = false;\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tif((i >> j) & 1){\n\t\t\t\tval.push_back((j+1));\n\t\t\t\tif(s[i ^ (1 << j)] == '0') fail = true;\n\t\t\t}\n\t\t}\n\t\tif(fail) continue;\n\t\tq.push_back(val);\n\t}\n\tvector<int> ans;\n\tfor(vector<int> val : q){\n\t\tvector<int> z = make(val);\n\t\tfor(int v : z) ans.push_back(v);\n\t}\n\tbool works = true;\n\tfor(int j = 0; j < N; j++){\n\t\tvector<int> stk = {0};\n\t\tfor(int f : ans){\n\t\t\tif((j >> (abs(f) - 1)) & 1){\n\t\t\t\tif(stk.back() == -f){\n\t\t\t\t\tstk.pop_back();\n\t\t\t\t} else {\n\t\t\t\t\tstk.push_back(f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint wins = (stk.size() == 1);\n\t\tif(wins != s[j] - '0'){\n\t\t\tcerr << j << ' ' << wins << ' ' << (s[j] - '0') << '\\n';\n\t\t\tworks = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcerr << ans.size() << '\\n';\n\tfor(int x : ans){\n\t\tcerr << x << ' ';\n\t}\n\tcerr << '\\n';\n\tpr(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> rec(int x) {\n\tvector <int> sol;\n\tint pet = 1, bit = 0;\n\tfor (; bit < 10; bit++) {\n\t\tpet = 1<<bit;\n\t\tif ((pet&x) != 0) break;\n\t}\n\tif (pet == x) {\n\t\tsol.push_back(bit+1);\n\t\treturn sol;\n\t}\n\tvector<int> aux = sol  = rec(x^pet);\n\tsol.push_back(bit+1);\n\tfor (auto it = aux.rbegin(); it != aux.rend(); it++)\n\t\tsol.push_back(-*it);\n\tsol.push_back(-bit-1);\n\treturn sol;\n}\n\nstring tira(const vector<int> & par) {\n\tstring sol;\n\tfor (int x: par) {\n\t\tsol += string(abs(x)-1,'R');\n\t\tif (x > 0) sol += \"URDL\";\n\t\telse sol += \"RULD\";\n\t\tsol += string(abs(x)-1,'L');\n\t}\n\treturn sol;\n}\n\n\nint main() {\n  ios_base::sync_with_stdio(false); \n  cin.tie(nullptr); \n\n\tint n;\n\tcin >> n;\n\tstring s;\n\tcin >> s;\n\tint m = 1<<n;\n\tbool ok = true;\n\tvector<int> obs;\n\tfor (int i = 1; i < m; i++) {\n\t\tif (s[i] == '0') obs.push_back(i);\n\t\tfor (int j = i+1; j < m; j++) {\n\t\t\tint p = i, g = j;\n\t\t\tif (p > g) swap(p, g);\n\t\t\tif ((p&g) == p and s[p] == '0' and s[g] == '1') ok = false;\n\t\t}\n\t}\n\tif (!ok) cout << \"Impossible\" << endl;\n\telse {\n\t\tcout << \"Possible\" << endl;\n\t\tstring sol;\n\t\tfor (auto x: obs)  {\n\t\t\tsol += tira(rec(x));\n\t\t}\n\t\tint k = sol.size();\n\t\tcout << k   << endl;\n\t\tassert(k <= 250000);\n\t\tint px = 0, py = 0; \n\t\tcout << px << \" \" << py << \"\\n\";\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tif (sol[i] == 'U') py++;\n\t\t\telse if (sol[i] == 'D') py--;\n\t\t\telse if (sol[i] == 'L') px--;\n\t\t\telse if (sol[i] == 'R') px++;\n\t\t\tcout << px << \" \" << py << \"\\n\";\n\t\t}\n\t}\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//Konrad Paluszek,University of Warsaw(former XIV LO Staszic)\n#ifndef LOCAL\n#pragma GCC optimize(\"O3\")\n#endif\n#define TIME (chrono::steady_clock::now().time_since_epoch().count())\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#define xfm(a,b)a##b\n#define xwb(a,b)xfm(a,b)\n#define _ xwb(nvj,__LINE__)\n#define __ xwb(kjy,__LINE__)\n#define ___ xwb(cjm,__LINE__)\n#define REP(i,n)for(urs(n)i=0;i<(n);++i)\n#define UNTIL(t)while(clock()<(t)*CLOCKS_PER_SEC)\n#define PER(r...)for(bool _=1;_||next_permutation(r);_=false)\n#define ALL(r)(r).begin(),(r).end()\n#define RALL(r)(r).rbegin(),(r).rend()\n#define FS(r)r.first,r.second\n#define SF(r)r.second,r.first\n#define sim template<class c\n#define ros return o\n#define rans return ans\n#define forbits(i,m)if(m)for(urs(m)i=ctz(m),i##nvj=m;i##nvj;i##nvj^=((urs(m))1<<i),i=ctz(i##nvj))\n#define fordbits(i,m)if(m)for(urs(m)i=8*sizeof(m)-clz(m)-1,i##nxd=m;i##nxd;i##nxd^=((urs(m))1<<i),i=8*sizeof(m)-clz(i##nxd)-1)\n#define ksets(t, m, k, n) for (t m = (((t)1 << (k)) - 1); m < ((t)1 << (n)); m = nux(m))\n#define urs(r...)typename decay<decltype(r)>::type\n#define hur(f,g,r)sim>int f(c a){if(sizeof(c)==16)return r;if(sizeof(c)==8)return g##ll(a);return g(a);}\n#define pwq(t,i) int clz(t x){return clz<int>(x)-i;}\nusing namespace __gnu_pbds;using namespace std;using ll=long long;using ld=long double;using ull=unsigned long long;using vi=vector<int>;using pii=pair<int,int>;using pll=pair<ll,ll>;using vpii=vector<pii>;using spii=set<pii>;using mii=map<int,int>;using unt=unsigned int;sim>using min_queue=priority_queue<c,vector<c>,greater<c>>;sim,class b,class cmp=less<c> >using ordered_map=tree<c,b,cmp,rb_tree_tag,tree_order_statistics_node_update>;sim, class cmp=less<c>>using ordered_set = ordered_map<c,null_type,cmp>;hur(popc,__builtin_popcount,popc<ull>(a)+popc<ull>(a>>64))hur(ctz,__builtin_ctz,(ull)a?ctz<ull>(a):64+ctz<ull>(a>>64))hur(clz,__builtin_clz,a>>64?clz<ull>(a>>64):64+clz<ull>(a))pwq(short,16)pwq(uint16_t,16)pwq(char,24)pwq(int8_t,24)pwq(uint8_t,24)sim,class N>bool mini(c&o,const N&h){if(o>h)ros=h,1;return 0;}sim,class N>bool maxi(c&o,const N&h){if(o<h)ros=h,1;return 0;}sim,class n>using gyv=c;\n#if defined(LOCAL) // || defined(LOCAL2)\n#include </home/kjp/headers/debuglib.hpp>\n#else\n#define loc(...)\n#define onl(r...)r\n#define debug(...)\n#define print_stack(...)\n#define mark_stack(...)\n#define set_pre(...)\n#define reg_it(...)\n#endif\n#define next nexT\n#define prev preV\n#define tree trEE\n#define left lefT\n#define right righT\n#define div diV\n#define y1 y_1\null mix(ull o){o+=0x9e3779b97f4a7c15;o=(o^(o>>30))*0xbf58476d1ce4e5b9;o=(o^(o>>27))*0x94d049bb133111eb;ros^(o>>31);}ull SALT=0x7a14a4b0881ebf9,tqu=0x7a14a4b0881ebf9;ull my_rand(){return tqu=mix(tqu);}void my_srand(ull x){SALT=tqu=x;}const int inf = 1023400000;const ll llinf=1234567890000000000ll;ll fix(ll o, ll m){o%=m;if(o<0)o+=m;ros;}\n#define rand my_rand\n#define srand my_srand\n#define random_shuffle(r...)random_shuffle(r,[](int _){return my_rand()%_;})\nsim>inline c nux(c m){if(!m)return numeric_limits<c>::max();c A=m&-m;c B=~((A-1)^m);c C=B&-B;c D=(C>>(1+ctz(A)))-1;return C|(m&~(C-1))|D;}__attribute__((no_sanitize_undefined))ll mul(ll a,ll b,ll m){ll q=a*(ld)b/m;ll o=a*b-q*m;o%=m;if(o<0)o+=m;ros;}sim>void unq(c&x){x.resize(unique(ALL(x))-x.begin());}\n#if ((ULONG_MAX) != (UINT_MAX))\nnamespace std {template <> struct is_signed<__int128> : public true_type {};}\n#endif\nsim, class d> typename common_type<c,d>::type floor_div(c a, d b) {static_assert(is_signed<c>::value==is_signed<d>::value,\"using floor_div with different signedness\");if (b < 0) b = -b, a = -a;return a / b - (a % b < 0);}\nsim, class d> typename common_type<c,d>::type ceil_div(c a, d b) {static_assert(is_signed<c>::value==is_signed<d>::value,\"using ceil_div with different signedness\");if (b < 0) b = -b, a = -a;return a / b + (a % b > 0);}\nsim> struct REV {c &x;using it=typename c::reverse_iterator;it begin(){return x.rbegin();}it end(){return x.rend();}};\nsim> struct CREV {const c&x;using it=typename c::const_reverse_iterator;it begin(){return x.rbegin();}it end(){return x.rend();}};\nsim> REV<c> reversed(c&x) {return REV<c>{x};}sim> CREV<c> reversed(const c&x) {return CREV<c>{x};}\n#define done(r...) exit(0 * printf(r))\n#if defined(LOCAL) || defined(LOCAL2)\nvoid __tmi() {cerr << setprecision(6) << fixed << \"total time: \" << clock() / (ld)CLOCKS_PER_SEC << \"s\" << endl;}int _ = (atexit(__tmi), 0);\n#endif\nvpii ans;\nsim> void go(c beg, c end) {\n\tdebug(range(beg, end));\n\tfor (c i = beg; i != end; ++i) {\n\t\t// debug(i, imie(ans));\n\t\tif (*i == ans.back()) continue;\n\t\telse if ((int) ans.size() >= 2 && ans[ans.size() - 2] == *i) ans.pop_back();\n\t\telse ans.push_back(*i);\n\t}\n}\nuint8_t can_move[1 << 9];\nvoid err() {\n\tdone(\"Impossible\\n\");\n}\nvpii gen[9];\nvoid com(vi which, bool rev) {\n\tassert(!which.empty());\n\tif (which.size() == 1) {\n\t\tint i = which[0];\n\t\tif (rev)\n\t\t\tgo(ALL(gen[i]));\n\t\telse\n\t\t\tgo(RALL(gen[i]));\n\t\treturn;\n\t}\n\tint h = which.size() / 2;\n\tvi l(which.begin(), which.begin() + h), r(which.begin() + h, which.end());\n\tif (rev) swap(l, r);\n\tcom(l, 0);\n\tcom(r, 0);\n\tcom(l, 1);\n\tcom(r, 1);\n}\nint main() {\n\tans = {{0, 0}};\n\tint n;\n\tscanf(\"%d%s\", &n, (char *)can_move);\n\tREP(i, (1 << n))\n\t\tcan_move[i] -= '0';\n\tif (!can_move[0]) err();\n\tREP(m, (1 << n)) if (can_move[m]) for (int s = m; ; s = (s - 1) & m) {\n\t\tif (!can_move[s]) err();\n\t\tif (!s) break;\n\t}\n\tREP(i, n) {\n\t\tfor (int j = 0; j <= i + 1; ++j) gen[i].emplace_back(j, 0);\n\t\tgen[i].emplace_back(i + 1, 1);\n\t\tgen[i].emplace_back(i, 1);\n\t\tfor (int j = i; j >= 0; --j) gen[i].emplace_back(j, 0);\n\t\tdebug(arr(gen, i));\n\t}\n\tREP(mask, (1 << n)) {\n\t\tif (can_move[mask]) continue;\n\t\tbool found_sub = false;\n\t\tfor (int s = mask; s; s = (s - 1) & mask) if (s != mask && !can_move[s]) found_sub = true;\n\t\tif (!found_sub) {\n\t\t\tvi here;\n\t\t\tforbits(i, mask) here.push_back(i);\n\t\t\tdebug(imie(here));\n\t\t\tcom(here, false);\n\t\t}\n\t}\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d\\n\", (int) ans.size() - 1);\n\tfor (pii p : ans) printf(\"%d %d\\n\", FS(p));\n\tassert((int) ans.size() <= 250001);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,L;\nstring A;\nint ismin[256];\n\n\nvector<pair<int,int>> construct(int mask) {\n\tvector<pair<int,int>> V;\n\t\n\tint i;\n\tFOR(i,N) if(mask&(1<<i)) {\n\t\tif(__builtin_popcount(mask)==1) {\n\t\t\tV.push_back({i,1});\n\t\t\tV.push_back({i+1,1});\n\t\t\tV.push_back({i+1,0});\n\t\t\tV.push_back({i,0});\n\t\t}\n\t\telse {\n\t\t\tvector<pair<int,int>> W=construct(mask^(1<<i));\n\t\t\tV.push_back({i,1});\n\t\t\twhile(V.back().first+1<W[0].first) {\n\t\t\t\tV.push_back(V.back());\n\t\t\t\tV.back().first++;\n\t\t\t}\n\t\t\tFORR(w,W) V.push_back(w);\n\t\t\twhile(V.back().first>i) {\n\t\t\t\tV.push_back(V.back());\n\t\t\t\tV.back().first--;\n\t\t\t}\n\t\t\tV.push_back({i,0});\n\t\t\treverse(ALL(W));\n\t\t\twhile(V.back().first+1<W[0].first) {\n\t\t\t\tV.push_back(V.back());\n\t\t\t\tV.back().first++;\n\t\t\t}\n\t\t\tFORR(w,W) V.push_back(w);\n\t\t\twhile(V.back().first>i+1) {\n\t\t\t\tV.push_back(V.back());\n\t\t\t\tV.back().first--;\n\t\t\t}\n\t\t\tV.push_back({i+1,0});\n\t\t\tV.push_back({i,0});\n\t\t}\n\t\tbreak;\n\t}\n\treturn V;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>A;\n\tL=1<<N;\n\tFORR(c,A) c-='0';\n\tFOR(x,L) FOR(y,L) if((x&y)==y && A[x] && A[y]==0) return _P(\"Impossible\\n\");\n\tFOR(x,L) ismin[x]=A[x]==0;\n\tFOR(x,L) if(A[x]==0) FOR(y,L) if((x&y)==y && y<x && A[y]==0) ismin[y]=0;\n\t\n\tvector<pair<int,int>> W;\n\tW.push_back({0,0});\n\tFOR(x,L) if(A[x]==0 && ismin[x]) {\n\t\tvector<pair<int,int>> V=construct(x);\n\t\tFOR(i,V[0].first) W.push_back({i,1});\n\t\tFORR(v,V) W.push_back(v);\n\t\tfor(i=V[0].first-1;i>=0;i--) W.push_back({i,0});\n\t}\n\tcout<<\"Possible\"<<endl;\n\tcout<<W.size()-1<<endl;\n\tFORR(w,W) cout<<w.first<<\" \"<<w.second<<endl;\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n// gp_hash_table<int, int> mapka;\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nint n;\nstring z;\n\nvoid nope(){\n  cout << \"Impossible\\n\";\n  exit(0);\n}\n\nvector<PII> petla(int mb){\n  vector<PII> res;\n  res.PB({0,0});\n  R(i,n){\n    if((mb >> i) & 1){\n      res.PB({i,1ll});\n      res.PB({i+1,1ll});\n    }\n    res.PB({i+1,0ll});\n  }\n  R(i,n){\n    res.PB({n - i - 1, 0});\n  }\n  debug(res);\n  return res;\n}\nvector<PII> res;\nvoid dodaj(vector<PII> x){\n  R(i,SZ(x)-1)res.PB(x[i]);\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n >> z;\n  R(i, 1<<n)z[i] -= '0';\n  if(z[0] == 0)nope();\n  R(i, 1<<n)R(j, 1 << n)if((i | j) == i && z[i] == 1 && z[j] == 0)nope();\n  vector<int> dp(1 << n);\n  for(int mb = (1 << n) - 1; mb > 0; mb --){\n    if(z[mb] == 0){\n      bool cz = 1;\n      R(mb2, mb-1)if((mb2 | mb) == mb){\n        if(z[mb2] == 0)cz = 0;\n      }\n      if(cz){\n        dodaj(petla(mb));\n        R(mb2, (1 << n))if((mb2 | mb) == mb){\n          dp[mb2]++;\n        }\n      }\n    }\n    if(z[mb] == 1 && dp[mb] != 0){\n      R(mb2, (1 << n))if((mb2 | mb) == mb2){\n        if(mb != mb2 && z[mb] == 1){\n          nope();\n        }\n      }\n\n      auto pom = petla(mb);\n      if(dp[mb] > 0)reverse(ALL(pom));\n      R(i, abs(dp[mb]))dodaj(pom);\n      R(mb2, (1 << n))if((mb2 | mb) == mb){\n        dp[mb2] -= dp[mb];\n      }\n    }\n  }\n  cout << \"Possible\\n\";\n  res.PB({0,0});\n  cout << SZ(res) - 1 << \"\\n\";\n  for(PII el:res){\n    cout << el.FI << \" \" << el.SE << \"\\n\";\n  }\n  \n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<unordered_map>\n#include<complex>\nusing namespace std;\nconst long long mod=998244353;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3100000;\nconst int UF_SIZE = 3100000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint UF[UF_SIZE];\n\tvoid init_UF(int n){\n\t\tfor(int i=0;i<n;i++)UF[i]=-1;\n\t}\n\tint FIND(int a){\n\t\tif(UF[a]<0)return a;\n\t\treturn UF[a]=FIND(UF[a]);\n\t}\n\tvoid UNION(int a,int b){\n\t\ta=FIND(a);b=FIND(b);if(a==b)return;\n\t\tif(UF[a]>UF[b])swap(a,b);\n\t\tUF[a]+=UF[b];UF[b]=a;\n\t}\n}\n// ここから編集しろ\nchar in[310];\nint t[4][10];\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tscanf(\"%s\",in);\n\tfor(int i=0;i<(1<<(a*2));i++){\n\t\tbool ok=true;\n\n\t\tfor(int j=0;j<(1<<a);j++){\n\t\t\tint L=0;\n\t\t\tint R=a;\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tif(j&(1<<k)){\n\t\t\t\t\tint f=(i>>(k*2))&3;\n\t\t\t\t\tif(f==0){\n\t\t\t\t\t\tL=a;R=0;break;\n\t\t\t\t\t}else if(f==1){\n\t\t\t\t\t\tR=min(R,k);\n\t\t\t\t\t}else if(f==2){\n\t\t\t\t\t\tL=max(L,k+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(in[j]=='1'&&L>R){\n\t\t\t\tok=false;break;\n\t\t\t}\n\t\t\tif(in[j]=='0'&&L<=R){\n\t\t\t\tok=false;break;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tif(!ok)continue;\n\t\tprintf(\"Possible\\n\");\n\t\tvector<pair<int,int> > ans;\n\t\tfor(int j=0;j<a;j++){\n\t\t\tint f=(i>>(j*2))&3;\n\t\t\tif(f==0){\n\t\t\t\tt[3][j]=1;\n\t\t\t}else if(f==1){\n\t\t\t\tt[0][j]=t[1][j]=1;\n\t\t\t}else if(f==2){\n\t\t\t\tt[1][j]=t[2][j]=1;\n\t\t\t}\n\t\t}\n\t\tans.push_back(make_pair(0,0));\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif(t[0][j]){\n\t\t\t\tans.push_back(make_pair(j,1));\n\t\t\t\tans.push_back(make_pair(j+1,1));\n\t\t\t}\n\t\t\tans.push_back(make_pair(j+1,0));\n\t\t}\n\t\tfor(int j=a-1;j>=0;j--){\n\t\t\tif(t[1][j]){\n\t\t\t\tans.push_back(make_pair(j+1,1));\n\t\t\t\tans.push_back(make_pair(j,1));\n\t\t\t}\n\t\t\tans.push_back(make_pair(j,0));\n\t\t}\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif(t[2][j]){\n\t\t\t\tans.push_back(make_pair(j,1));\n\t\t\t\tans.push_back(make_pair(j+1,1));\n\t\t\t}\n\t\t\tans.push_back(make_pair(j+1,0));\n\t\t}\n\t\tfor(int j=a-1;j>=0;j--){\n\t\t\tif(t[3][j]){\n\t\t\t\tans.push_back(make_pair(j+1,1));\n\t\t\t\tans.push_back(make_pair(j,1));\n\t\t\t}\n\t\t\tans.push_back(make_pair(j,0));\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",(int)(ans.size())-1);\n\t\tfor(int j=0;j<ans.size();j++){\n\t\t\tprintf(\"%d %d\\n\",ans[j].first,ans[j].second);\n\t\t}\n\t\treturn 0;\n\t}\n\tprintf(\"Impossible\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',') { cerr<<*sdbg++; } cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n\nVPII Go(int bit) {\n  VPII res;\n  //res.PB({0, 1});\n  RE (i, bit + 1) {\n    res.PB({i, 0});\n  }\n  res.PB({bit + 1, 1});\n  res.PB({bit, 1});\n  //res.PB({bit, 0});\n  FORD (i, bit, 1) {\n    res.PB({i, 0});\n  }\n  return res;\n}\nvoid Append(VPII& A, VPII B) {\n  A.insert(A.end(), ALL(B));\n}\nconst int N = 1000;\nint forb[N];\nint need[N];\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n\n  int n;\n  cin>>n;\n  REP (i, 1 << n) {\n    char c;\n    cin>>c;\n    if (c == '0') {\n      forb[i] = 1;\n      need[i] = 1;\n    }\n  }\n  REP (j, 1 << n) {\n    REP (i, j) {\n      if ((i & j) == i) {\n        if (forb[i] == 1 && forb[j] == 0) {\n          cout<<\"Impossible\\n\";\n          return 0;\n        }\n        if (forb[i] == 1) {\n          need[j] = 0;\n        }\n      }\n    }\n  }\n  //int any_need = 0;\n  PII orig{0, 0};\n  VPII pts;\n  REP (i, 1 << n) {\n    if (need[i] == 1) {\n      //any_need = 1;\n      VPII cur;\n      REP (bit, n) {\n        if (i & (1 << bit)) {\n          if (cur.empty()) {\n            cur = Go(bit);\n            continue;\n          } \n          VPII rev_cur = cur;\n          reverse(ALL(rev_cur));\n          VPII heh = Go(bit);\n          cur.PB(orig);\n          Append(cur, heh);\n          cur.PB(orig);\n          Append(cur, rev_cur);\n          reverse(ALL(heh));\n          Append(cur, heh);\n        }\n      }\n      pts.PB(orig);\n      Append(pts, cur);\n    }\n  }\n  pts.PB(orig);\n  cout<<\"Possible\\n\";\n  cout<<SZ(pts) - 1<<endl;\n  for (auto p : pts) {\n    cout<<p.st<<\" \"<<p.nd<<\"\\n\";\n  }\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int n, pow=1, a[30000], i, j, k, b[10]={}, s=0, t=0, x, y;\n    scanf(\"%d\", &n);\n    for(i=1;i<=n;i++)\n        pow*=2;\n    for(i=0;i<pow;i++)\n        scanf(\"%1d\", &a[i]);\n    for(i=0;i<n;i++)\n    {\n        b[i]=1-a[1<<i];\n        if(b[i]==1)\n        {\n            if((i==0)||(b[i-1]==0))\n                t++;\n        }\n    }\n    for(i=0;i<pow;i++)\n    {\n        x=0;\n        y=i;\n        for(j=0;j<n;j++)\n        {\n            if(y%2)\n            {\n                x+=b[j];\n            }\n            else\n            {}\n            y/=2;\n        }\n        \n        if(((a[i]==1)&&(x==0))||((a[i]==0)&&(x>0)))\n        {}\n        else\n            s++;\n\n    }\n    if(s)\n        printf(\"Impossible\");\n    else\n    {\n        if((t>=2)||(t==0))\n            printf(\"Impossible\");\n        else\n        {\n        printf(\"Possible\\n\");\n        j=0;\n        while(b[j]==0)\n            j++;\n        k=j;\n        while(b[k]==1)\n            k++;\n        }\n        printf(\"%d\\n\", 2*k-2*j+2);\n        for(i=j;i<=k;i++)\n            printf(\"%d 0\\n\", i);\n        for(i=k;i>=j;i--)\n            printf(\"%d 1\\n\", i);\n        printf(\"%d 0\", j);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main()\n{\n  int H,W;\n  for(int i = 0; i < H; i++){\n    for(int j = 0; j < W; j++){\n      \n      "
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<queue>\n#include<iostream>\n#include<fstream>\n#include<string>\n#include<cassert>\n#include<algorithm>\n#include<random>\n#include<map>\n#include<set>\n#include <bitset>\n#include<ctime>\n\nusing namespace std;\n\n//int mod = 998244353;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\ntypedef vector<int>vi;\ntypedef vector<ll>vl;\ntypedef vector<char>vc;\ntypedef vector<string>vs;\ntypedef vector<vector<int>>vii;\ntypedef vector<vector<char>>vvc;\ntypedef vector<vector<ll>>vll;\ntypedef vector< pair<ll, ll>>vpll;\ntypedef vector< pair<ld, ld>>vpld;\ntypedef vector< pair<int, int>>vpi;\ntypedef pair<ld, ld>pld;\n#define mp make_pair\n#define pb push_back\n\nconst int mod = 998244353;\nint add(int a, int b)\n{\n\tint c = a + b;\n\tif (c >= mod)\n\t{\n\t\tc -= mod;\n\t}\n\treturn c;\n}\nint dif(int a, int b)\n{\n\tint c = a - b;\n\tif (c < 0)\n\t{\n\t\tc += mod;\n\t}\n\treturn c;\n}\nint mlt(int a, int b)\n{\n\tll c = a * 1LL * b;\n\treturn c % mod;\n}\nint ibit(int n, int i)\n{\n\treturn ((n >> i) & 1);\n}\nvoid outp(vii &ou)\n{\n\tfor (int i = 0; i < ou.size(); i++)\n\t{\n\t\tfor (int j = 0; j < ou[i].size(); j++)\n\t\t{\n\t\t\tcout << ou[i][j] << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n}\nint bp(int x, int y)\n{\n\tif (y == 0)\n\t{\n\t\treturn 1;\n\t}\n\tint a = 0;\n\tif (!(y % 2))\n\t{\n\t\ta = bp(x, y / 2);\n\t}\n\treturn (y % 2) ? mlt(bp(x, y - 1), x) : mlt(a, a);\n}\nint obr(int x)\n{\n\treturn bp(x, mod - 2);\n}\nconst int maxn = 2000007;\nint fact[2000007], ofact[2000007];\nvoid prec()\n{\n\tfact[0] = 1;\n\tofact[0] = 1;\n\tfor (int i = 1; i < maxn; i++)\n\t{\n\t\tfact[i] = mlt(fact[i - 1], i);\n\t}\n\t//cerr << \"sdsds\" << endl;\n\tofact[maxn - 1] = obr(fact[maxn - 1]);\n\tfor (int i = maxn - 2; i > 0; i--)\n\t{\n\t\tofact[i] = mlt(ofact[i + 1], i + 1);\n\t}\n}\nint c(int a, int b)\n{\n\tif (a == 0)return 1;\n\treturn ((a <= b) && (a >= 0)) ? mlt(fact[b], mlt(ofact[a], ofact[b - a])) : 0;\n}\nll gcd(ll x, ll y)\n{\n\t//cerr << x << y << endl;\n\tif (x == 0)return y;\n\treturn(x > y) ? gcd(y, x) : gcd(y%x, x);\n}\nint obr2(int n)\n{\n\tint x = fact[n - 1];\n\tx = mlt(x, ofact[n]);\n\treturn x;\n}\nvoid crv(int nn, vpi &v)\n{\n//\tcerr << nn << endl;\n\tif (nn > 0) {\n\t\tint n = nn;\n\t\tfor (int i = 0; i < n; i++)v.pb({ i + 1, 0 });\n\t\tv.pb({ n,1 });\n\t\tv.pb({ n - 1, 1 });\n\t\tfor (int i = n - 1; i >= 0; i--)v.pb({ i, 0 });\n\t}\n\tif (nn < 0) {\n\t\tint n = -nn;\n\t\tfor (int i = 0; i < n - 1; i++)v.pb({ i + 1, 0 });\n\t\tv.pb({ n - 1,1 });\n\t\tv.pb({ n , 1 });\n\t\tfor (int i = n; i >= 0; i--)v.pb({ i, 0 });\n\t}\n}\nvoid solve(istream &cin = std::cin, ostream &cout = std::cout)\n{\n\tvii imb(8);\n\timb[0] = { 1 };\n\tfor (int i = 1; i < 8; i++)\n\t{\n\t\tfor (int j = 0; j < imb[i - 1].size(); j++)imb[i].pb(imb[i - 1][j]);\n\t\timb[i].pb(i + 1);\n\t\tfor (int j = imb[i - 1].size(); j >= 0; j--)imb[i].pb((-1)*imb[i - 1][j]);\n\t\timb[i].pb(-i - 1);\n\t}\n\t//cerr << \"here\" << endl;\n\tint n;\n\tcin >> n;\n\tvi good(1 << n);\n\tfor (int i = 0; i < good.size(); i++)\n\t{\n\t\tchar c;\n\t\tcin >> c;\n\t\tgood[i] = c - '0';\n\t}\n\tint val = 0;\n\t//\tcerr << 433 << endl;\n\tfor (int a = 0; a < good.size(); a++)\n\t\tfor (int b = 0; b < good.size(); b++)\n\t\t\tif ((a | b) == b)\n\t\t\t\tif ((!good[a]) && (good[b]))\n\t\t\t\t{\n\t\t\t\t\t//\tcerr << a << ' ' << b << endl;\n\t\t\t\t\tval = 1;\n\t\t\t\t}\n\t//\tcerr << 5 << ' ' << 7 << ' ' << (5 | 7) << endl;\n\tif (val)cout << \"Impossible\" << endl;\n\telse\n\t{\n\t\tcout << \"Possible\" << endl;\n\t\t//cerr << 1111 << endl;\n\t\tvpi ay = { { 0,0 } };\n\t\tfor (int m = 0; m < good.size(); m++)\n\t\t{\n\t\t\t//cerr << m << endl;\n\t\t\tif (!good[m])\n\t\t\t{\n\t\t//\tcerr << m << endl;\n\t\t\t\tvi v;\n\t\t\t\tfor (int i = 0; i <= 8; i++)if (ibit(m, i))v.pb(i);\n\t\t\t//\tcerr << m << ' ' << v.size() << endl;\n\t\t\t\tfor (int i = 0; i < imb[v.size() - 1].size(); i++)\n\t\t\t\t{\n\t\t\t\t//\tcerr << imb[v.size() - 1][i] << endl;\n\t\t\t\t\t//\tcerr << i << endl;\n\t\t\t\t\tif (imb[v.size()-1][i] > 0)crv(v[imb[v.size() - 1][i] - 1] , ay);\n\t\t\t\t\tif (imb[v.size()-1][i] < 0)crv(-v[(-imb[v.size() - 1][i]) - 1], ay);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tif (ay.size() < 190000)\n\t\t{\n\t\t\tcout << ay.size() - 1 << endl;\n\t\t\tfor (int i = 0; i < ay.size(); i++)cout << ay[i].first << ' ' << ay[i].second << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << 0 << endl;\n\t\t\tcout << 0 << ' ' << 0 << endl;\n\t\t}\n\t}\n}\nint main()\n{\n\tsolve();\n\tint n;\n\tcin >> n;\n}\n\n\n \n "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n#ifdef ENABLE_DEBUG\n#define dump(a) cerr<<#a<<\"=\"<<a<<endl\n#define dumparr(a,n) cerr<<#a<<\"[\"<<n<<\"]=\"<<a[n]<<endl\n#else\n#define dump(a) \n#define dumparr(a,n) \n#endif\n#define FOR(i, a, b) for(ll i = (ll)a;i < (ll)b;i++)\n#define For(i, a) FOR(i, 0, a)\n#define REV(i, a, b) for(ll i = (ll)b-1LL;i >= (ll)a;i--)\n#define Rev(i, a) REV(i, 0, a)\n#define REP(a) For(i, a)\n#define SIGN(a) (a==0?0:(a>0?1:-1))\n\ntypedef long long int ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll,pll> ppll;\ntypedef vector<ll> vll;\ntypedef long double ld;\ntypedef pair<ld,ld> pdd;\n\nconst ll INF=(1LL<<50);\n#if __cplusplus<201700L\nll gcd(ll a, ll b) {\n  if(a < b) return gcd(b, a);\n  ll r;\n  while ((r=a%b)) {\n    a = b;\n    b = r;\n  }\n  return b;\n}\n#endif\ntemplate<class T>\nbool chmax(T& a,const T& b){\n  if(a<b){\n    a=b;\n    return true;\n  }\n  return false;\n}\ntemplate<class T>\nbool chmin(T& a,const T& b){\n  if(a>b){\n    a=b;\n    return true;\n  }\n  return false;\n}\ntemplate<class S,class T>\nstd::ostream& operator<<(std::ostream& os,pair<S,T> a){\n  os << \"(\" << a.first << \",\" << a.second << \")\";\n  return os;\n}\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os,vector<T> a){\n  os << \"[ \";\n  REP(a.size()){\n    os<< a[i] << \" \";\n  }\n  os<< \" ]\";\n  return os;\n}\n\nconst string YES = \"Possible\";\nconst string NO = \"Impossible\";\nvoid pb(vector<pll> &ans,pll x){\n  if((ans.size()>=2&&ans[ans.size()-2]==x)){\n    ans.pop_back();\n  }else if(ans.back()==x){\n  }else{\n    ans.push_back(x);\n  }\n}\nvoid create1rev(vector<pll> &ans,ll x){\n  REP(x+1){pb(ans,pll(1+i,0));}\n  pb(ans,pll(x+1,1));\n  pb(ans,pll(x,1));\n  Rev(i,x+1){pb(ans,pll(i,0));}\n}\nvoid create1(vector<pll> &ans,ll x){\n  REP(x){pb(ans,pll(1+i,0));}\n  pb(ans,pll(x,1));\n  pb(ans,pll(x+1,1));\n  Rev(i,x+2){pb(ans,pll(i,0));}\n}\nvoid append2(vector<pll> &ans,ll x){\n  vector<pll> cpy(ans);\n  reverse(cpy.begin(),cpy.end());\n  create1rev(ans,x);\n  REP(cpy.size()){pb(ans,cpy[i]);}\n  create1(ans,x);\n}\nvoid create2(vector<pll> &ans,set<ll> s){\n  vector<pll> tmp{pll(0,0)};\n  for (auto &&i : s)\n  {\n    if(tmp.size()==1){\n      create1(tmp,i);\n    }else{\n      append2(tmp,i);\n    }\n    dump(tmp);\n  }\n  REP(tmp.size()){\n    pb(ans,tmp[i]);\n  }\n}\nll two_factor(ll x){\n  ll ret=0;\n  while((1<<ret)!=x){\n    ++ret;\n  }\n  return ret;\n}\nint main(){\n  cout<<setprecision(1000);\n  ll N;\n  cin>>N;\n  string A;\n  cin>>A;\n  vector<bool> first(A.size(),true);\n  REP(A.size()){\n    if(first[i]==false)continue;\n    if(A[i]=='0')FOR(j,i+1,A.size()){\n      if(((i&j)==i)&&A[j]=='1'){\n        cout<<NO<<endl;\n        return 0;\n      }else if((i&j)==i){\n        first[j]=false;\n      }\n    }else{\n      first[i]=false;\n    }\n  }\n  dump(first);\n  vector<pll> ans{pll(0,0)};\n  REP(A.size()){\n    if(first[i]){\n      if(__builtin_popcountll(i)==1){\n        create1(ans,two_factor(i));\n      }else{\n        set<ll> s;\n        For(j,N){\n          if((1<<j)&i){\n            s.insert(j);\n          }\n        }\n        create2(ans,move(s));\n      }\n    }\n  }\n  if(ans.size()>250001){\n    abort();\n  }\n  cout<<YES<<endl;\n  cout<<ans.size()-1<<endl;\n  REP(ans.size()){\n    cout<<ans[i].first<<\" \"<<ans[i].second<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing ll = long long;\nusing ull = unsigned long long;\nusing namespace std;\nconst int INF = 1e10;\nconst int MOD = 1e9 + 7;\n#define dump(x)                             \\\n    if (dbg) {                              \\\n        cerr << #x << \" = \" << (x) << endl; \\\n    }\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define FOR1(n) for (ll i = 0; i < (n); ++i)\n#define FOR2(i, n) for (ll i = 0; i < (n); ++i)\n#define FOR3(i, a, b) for (ll i = (a); i < (b); ++i)\n#define FOR4(i, a, b, c) for (ll i = (a); i < (b); i += (c))\n#define FOR(...) overload4(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)\n#define FORR(i, a, b) for (int i = (a); i <= (b); ++i)\n#define bit(n, k) ((n >> k) & 1) /*nのk bit目*/\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\nvoid Yes(bool flag = true) {\n    if (flag)\n        cout << \"Yes\" << endl;\n    else\n        cout << \"No\" << endl;\n}\nvoid No(bool flag = true) {\n    Yes(!flag);\n}\nvoid YES(bool flag = true) {\n    if (flag)\n        cout << \"YES\" << endl;\n    else\n        cout << \"NO\" << endl;\n}\nvoid NO(bool flag = true) {\n    YES(!flag);\n}\n#define pb emplace_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define all(v) (v).begin(), (v).end()\n#define SZ(x) ((int)(x).size())\n#define P pair<int, int>\n//#define V vector<int>\n//#define S set<int>\n#define itn int\nbool dbg = false;\n\nint N;\nstring A;\nbool checked[111010];\nbool out[111010];\nbool done[101010];\n\nvector<int> x, y;\n\nvoid go(int gx) {\n    int sx;\n    int ys;\n    sx = x[(int)x.size() - 1];\n    ys = y[(int)y.size() - 1];\n    if (sx > gx) {\n        while (sx != gx) {\n            sx--;\n            x.pb(sx);\n            y.pb(ys);\n        }\n    } else if (sx < gx) {\n        while (sx != gx) {\n            sx++;\n            x.pb(sx);\n            y.pb(ys);\n        }\n    }\n}\nvoid chy() {\n    x.pb(x[(int)x.size() - 1]);\n    y.pb(!y[(int)y.size() - 1]);\n}\n\nvoid fill(int T, bool nikai = false) {\n    if (done[T])\n        return;\n    done[T] = 1;\n    int cnt = __builtin_popcount(T);\n    if (cnt == 1) {\n        int nxt = __builtin_ffs(T) - 1;\n        go(nxt);\n        chy();\n        go(nxt + 1);\n        chy();\n        go(nxt);\n        chy();\n        go(nxt + 1);\n        chy();\n        go(nxt);\n        chy();\n        go(nxt + 1);\n        chy();\n        go(nxt);\n        return;\n    } else {\n        int n1 = __builtin_ffs(T) - 1;\n        T -= (1 << n1);\n        int n2 = __builtin_ffs(T) - 1;\n        int n3 = n2;\n        FOR(N) {\n            if ((1 << i) & T) {\n                n3 = i;\n            }\n        }\n        n3++;\n\n        go(n1);\n        chy();\n        go(n1 + 1);\n        chy();\n        go(n2);\n        chy();\n        if (n2 + 1 != n3) {\n            go(n2 + 1);\n            chy();\n            go(n3 - 1);\n            chy();\n        }\n        go(n3);\n        chy();\n        go(n2);\n        //ここで再帰\n        if (n2 + 1 != n3) {\n            fill(T);\n        }\n        go(n1 + 1);\n        chy();\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        if (n2 + 1 != n3) {\n            go(n3 - 1);\n            chy();\n            go(n2 + 1);\n            chy();\n        }\n        go(n2);\n        chy();\n        go(n1);\n\n\n        go(n1);\n        chy();\n        go(n1 + 1);\n        chy();\n        go(n2);\n        chy();\n        if (n2 + 1 != n3) {\n            go(n2 + 1);\n            chy();\n            go(n3 - 1);\n            chy();\n        }\n        go(n3);\n        chy();\n        go(n2);\n        go(n1 + 1);\n        chy();\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        if (n2 + 1 != n3) {\n            go(n3 - 1);\n            chy();\n            go(n2 + 1);\n            chy();\n        }\n        go(n2);\n        chy();\n        go(n1);\n\n\n        /*\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        go(n2);\n        chy();\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        go(n2);\n        chy();\n        go(n1);\n        */\n    }\n}\n\n\nvoid solve() {\n    bool flag = true;\n    int tmp = -1;\n    for (int T = 1; T < (1 << N); T++) {\n        if (A[T] == 1) {\n            continue;\n        }\n        if (checked[T]) {\n            continue;\n        }\n        out[T] = true;\n        if (__builtin_popcount(T) == 1) {\n            tmp = T;\n        }\n        for (int i = T; i < (1 << N); i = (i + 1) | T) {\n            // ここに処理を書く\n            if (A[i] == 1) {\n                flag = false;\n            }\n            //checked[i] = true;\n        }\n    }\n    if (!flag) {\n        cout << \"Impossible\" << endl;\n        return;\n    }\n    cout << \"Possible\" << endl;\n\n    x.pb(0);\n    y.pb(0);\n\n    for (int T = 1; T < (1 << N); T++) {\n        if (out[T]) {\n            fill(T);\n        }\n    }\n    go(0);\n    int L = x.size();\n    cout << L - 1 << endl;\n\n    FOR(L) {\n        cout << x[i] << \" \" << y[i] << endl;\n    }\n}\n\nsigned main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cin >> N;\n    cin >> A;\n    for (auto& c : A)\n        c -= '0';\n\n\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint N; char str[1 << 8];\n\nint main(){\n\tscanf(\"%d %s\" , &N , str);\n\tfor(int i = 0 ; i < 1 << N ; ++i){\n\t\tbool flg = 1; for(int j = 0 ; j < 1 << N ; ++j) flg &= ((i & j) == j) ^ (str[j] == '0');\n\t\tif(flg){\n\t\t\tputs(\"Possible\");\n\t\t\tif(i == (1 << N) - 1) puts(\"0\\n1 1\\n\");\n\t\t\telse{\n\t\t\t\tvector < pair < int , int > > node; vector < int > bit;\n\t\t\t\tfor(int j = 0 ; j < N ; ++j) if(!(i >> j & 1)) bit.push_back(j);\n\t\t\t\tint cur = bit[0] - 1;\n\t\t\t\tfor(auto t : bit){\n\t\t\t\t\twhile(cur < t) node.push_back(make_pair(++cur , 0));\n\t\t\t\t\tnode.push_back(make_pair(cur , 1)); node.push_back(make_pair(++cur , 1)); node.push_back(make_pair(cur , 0));\n\t\t\t\t}\n\t\t\t\twhile(--cur > bit[0]) node.push_back(make_pair(cur , 0));\n\t\t\t\tprintf(\"%d\\n\" , node.size());\n\t\t\t\tfor(auto t : node) printf(\"%d %d\\n\" , t.first , t.second);\n\t\t\t\tprintf(\"%d %d\" , node[0].first , node[0].second);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"Impossible\"); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i = (begin); i < (end); i++)\n#define rep(i, n) FOR(i, 0, n)\nusing ll = long long;\nusing namespace std;\n#define all(x) (x).begin(),(x).end()\nusing pii = pair<int, int>; using vi = vector<int>; using vl = vector<ll>;\n\nint N;\n\nunordered_set<int> setter(int i) {\n    unordered_set<int> ss;\n    rep(j, N) {\n        int k = i & 1;\n        if (k == 0)\n            ss.insert(j);\n        i >> 1;\n    }\n    return ss;\n}\n// 和集合の計算\ntemplate<class T> unordered_set<T> Union(unordered_set<T>& rsettA, unordered_set<T>&rsettB) {\n    unordered_set<T> settUnion(rsettA);\n    for (auto itt = rsettB.begin(); itt != rsettB.end(); itt++) {\n        settUnion.insert(*itt);\n    }\n    return settUnion;\n}\n// 積集合の計算\ntemplate<class T> unordered_set<T> Product(unordered_set<T>& rsettA, unordered_set<T>&rsettB) {\n    unordered_set<T> settProduct;\n    for (auto itt = rsettB.begin(); itt != rsettB.end(); itt++) {\n        if (rsettA.find(*itt) != rsettA.end()) {\n            settProduct.insert(*itt);\n        }\n    }\n    return settProduct;\n}\n// 補集合の計算\ntemplate<class T> unordered_set<T> Complement(unordered_set<T>& rsettA, unordered_set<T>&rsettB) {\n    unordered_set<T> settComplement(rsettA);\n    for (auto itt = rsettB.begin(); itt != rsettB.end(); itt++) {\n        settComplement.erase(*itt);\n    }\n    return settComplement;\n}\nsigned main() {\n    cin >> N;\n    // unordered_set<int> oo, ii;\n    int oo(0), ii(0);\n    string as;\n    cin >> as;\n    rep(i, 1<<N) {\n        int x = as[i] - '0';\n        // auto ss = setter(i);\n        if (x == 1) {\n            oo |= i;\n            // ii = Union(ii, ss);\n        } else {\n            ii |= i;\n            // oo = Union(oo, ss);\n        }\n    }\n    // cerr << oo << ' ' << ii << endl;\n    // cerr << (oo & ii) << endl;\n    // if (Product(oo, ii).size() != 0) {\n    if ((oo&ii) != 0) {\n        cout << \"Impossible\" << endl;\n        return 0;\n    }\n    cout << \"Possible\" << endl;\n\n    vector<pii> p;\n    int before = 0;\n    cerr << ii << endl;\n    p.push_back({0, 0});\n    rep(i, N) {\n        if(ii&1 ^ before) {\n            if(ii&1) {\n                if(i!=0) {\n                    p.push_back({i, 0});\n                }\n                p.push_back({i, 1});\n            } else {\n                p.push_back({i, 1});\n                if(i!=N-1)\n                    p.push_back({i, 0});\n            }\n        } else {\n            if(i!=0)\n                p.push_back({i, before});\n        }\n        before = ii & 1;\n        ii >> 1;\n    }\n    if (before)\n        p.push_back({N, 1});\n    for(int k = N; k>=0; k--) {\n        p.push_back({k, 0});\n    }\n\n    cout << p.size() - 1 << endl;\n    for(auto pp : p) {\n        cout << pp.first << ' ' << pp.second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1007;\n\nvoid nope()\n{\n\tprintf(\"Impossible\\n\");\n\texit(0);\n}\n\nvoid tak()\n{\n\tprintf(\"Possible\\n\");\n}\n\nint n;\nchar wcz[nax];\nint dasie[nax];\n\nvector <pii> wek;\n\nvector <pii> operator + (vector <pii> a, vector <pii> b)\n{\n\tif (a.empty())\n\t\treturn b;\n\tif (b.empty())\n\t\treturn a;\n\ta.pop_back();\n\tfor (pii i : b)\n\t\ta.push_back(i);\n\treturn a;\n}\n\nvector <pii> odw(vector <pii> a)\n{\n\treverse(a.begin(), a.end());\n\treturn a;\n}\n\nvector <pii> daj(int x)\n{\n\tvector <pii> ret;\n\tret.push_back({0, 0});\n\tfor (int i=0; i<=x; i++)\n\t\tret.push_back({i, 1});\n\tret.push_back({x, 0});\n\tret.push_back({x+1, 0});\n\tfor (int i=x+1; i>=0; i--)\n\t\tret.push_back({i, 1});\n\tret.push_back({0, 0});\n\treturn ret;\n}\n\nvector <pii> zdobo(int mas)\n{\n\tint x=__builtin_ctz(mas);\n\tif (__builtin_popcount(mas)==1)\n\t\treturn daj(x);\n\tif (__builtin_popcount(mas)==2)\n\t{\n\t\tint y=__builtin_ctz(mas^(1<<x));\n\t\tauto xx=daj(x);\n\t\tauto yy=daj(y);\n\t\treturn xx+yy+odw(xx)+odw(yy);\n\t}\n\tvector <pii> ret=daj(x);\n\tauto wez=zdobo(mas^(1<<x));\n\treturn wez+ret+odw(wez)+odw(ret);\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", wcz);\n\tfor (int i=0; i<(1<<n); i++)\n\t\tdasie[i]=wcz[i]-'0';\n\tfor (int i=0; i<(1<<n); i++)\n\t{\n\t\tfor (int j=0; j<(1<<n); j++)\n\t\t{\n\t\t\tif ((i&j)==i && dasie[j] && !dasie[i])\n\t\t\t{\n\t\t\t\tnope();\n\t\t\t}\n\t\t}\n\t}\n\ttak();\n\twek={{0, 0}};\n\tfor (int i=0; i<(1<<n); i++)\n\t{\n\t\tif (dasie[i])\n\t\t\tcontinue;\n\t\tauto x=zdobo(i);\n\t\twek=wek+x;\n\t}\n\tprintf(\"%d\\n\", (int)wek.size()-1);\n\tfor (pii i : wek)\n\t\tprintf(\"%d %d\\n\", i.first, i.second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "bh "
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = (1<<30);\nconst ll INFLL = (1ll<<60);\nconst ll MOD = (ll)(1e9+7);\n\n#define l_ength size\n\nvoid mul_mod(ll& a, ll b){\n\ta *= b;\n\ta %= MOD;\n}\n\nvoid add_mod(ll& a, ll b){\n\ta = (a<MOD)?a:(a-MOD);\n\tb = (b<MOD)?b:(b-MOD);\n\ta += b;\n\ta = (a<MOD)?a:(a-MOD);\n}\n\nstring a;\n\nvector<P> ans;\n\nint main(void){\n\tint n,i,j,l;\n\tcin >> n;\n\tcin >> a;\n\tfor(i=0; i<(1<<n); ++i){\n\t\ta[i] -= '0';\n\t\tfor(j=0; j<i; ++j){\n\t\t\tif((j&i)<j){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(a[j]==0 && a[i]==1){\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Possible\" << endl;\n\tans.push_back(P(0,0));\n\tfor(i=0; i<n; ++i){\n\t\tif(a[(1<<i)]==0){\n\t\t\tans.push_back(P(i,1));\n\t\t\tans.push_back(P(i+1,1));\n\t\t}\n\t\tans.push_back(P(i+1,0));\n\t}\n\tfor(i=(n-1); i>=0; --i){\n\t\tans.push_back(P(i,0));\n\t}\n\tl = ans.l_ength()-1;\n\tcout << l << endl;\n\tfor(i=0; i<=l; ++i){\n\t\tcout << (ans[i].first) << \" \" << (ans[i].second) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n// gp_hash_table<int, int> mapka;\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nint n;\nstring z;\n\nvoid nope(){\n  cout << \"Impossible\\n\";\n  exit(0);\n}\n\nvector<PII> petla(int mb){\n  vector<PII> res;\n  res.PB({0,0});\n  R(i,n){\n    if((mb >> i) & 1){\n      res.PB({i,1ll});\n      res.PB({i+1,1ll});\n    }\n    res.PB({i+1,0ll});\n  }\n  R(i,n){\n    res.PB({n - i - 1, 0});\n  }\n  debug(res);\n  return res;\n}\nvector<PII> res;\nvoid dodaj(vector<PII> x){\n  R(i,SZ(x)-1)res.PB(x[i]);\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n >> z;\n  R(i, 1<<n)z[i] -= '0';\n  if(z[0] == 0)nope();\n  R(i, 1<<n)R(j, 1 << n)if((i | j) == i && z[i] == 1 && z[j] == 0)nope();\n  cout << \"Possible\\n\";\n  vector<int> dp(1 << n);\n  for(int mb = (1 << n) - 1; mb > 0; mb --){\n    if(z[mb] == 0){\n      bool cz = 1;\n      R(mb2, mb-1)if((mb2 | mb) == mb){\n        if(z[mb2] == 0)cz = 0;\n      }\n      if(cz){\n        dodaj(petla(mb));\n        R(mb2, (1 << n))if((mb2 | mb) == mb){\n          dp[mb2]++;\n        }\n      }\n    }\n    if(z[mb] == 1 && dp[mb] != 0){\n      auto pom = petla(mb);\n      if(dp[mb] > 0)reverse(ALL(pom));\n      R(i, abs(dp[mb]))dodaj(pom);\n      R(mb2, (1 << n))if((mb2 | mb) == mb){\n        dp[mb2] -= dp[mb];\n      }\n    }\n  }\n  res.PB({0,0});\n  cout << SZ(res) - 1 << \"\\n\";\n  for(PII el:res){\n    cout << el.FI << \" \" << el.SE << \"\\n\";\n  }\n  \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long double EPS = 1e-10;\nconst long long INF = 1e18;\nconst long double PI = acos(-1.0L);\n//const ll mod = 1000000007;\nbool block[8];\nbool tate[8];\nbool side;\nvector<l_l> ans;\n\nvoid f(int x) {\n    for(int i = 1; i <= x; i++) {\n        ans.push_back({i, 0});\n    }\n    ans.push_back({x,1});\n    ans.push_back({x+1,1});\n    ans.push_back({x+1,0});\n    for(int i = x; i >= 0; i--) {\n        ans.push_back({i, 0});\n    }\n}\n\nvoid g(int x) {\n    for(int i = 1; i <= x+1; i++) {\n        ans.push_back({i, 0});\n    }\n    ans.push_back({x+1, 1});\n    for(int j = x; j <= x + 2; j++) {\n        ans.push_back({j, 1});\n    }\n    ans.push_back({x+1, 1});\n    for(int i = x+1; i >= 0; i--) {\n        ans.push_back({i, 0});\n    }\n}\n\nll N;\nvoid h() {\n    ans.push_back({0, 1});\n    ans.push_back({0, 0});\n    for(int i = 1; i <= N; i++) {\n        ans.push_back({i, 0});\n    }\n    ans.push_back({N, 1});\n    ans.push_back({N, 0});\n    for(int i = N - 1; i >= 0; i--) {\n        ans.push_back({i, 0});\n    }\n}\n\nvoid print() {\n    cout << \"Possible\" << endl;\n    cout << ans.size() - 1 << endl;\n    for(auto tmp : ans) {\n        cout << tmp.first << \" \" << tmp.second << endl;\n    }\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N;\n    string S;\n    cin >> S;\n    ans.push_back({0, 0});\n    for(int i = 0; i < N; i++) {\n        int bits = (1 << i);\n        if(S[bits] == '1') continue;\n        block[i] = true;\n        f(i);\n    }\n    for(int i = 0; i + 1 < N; i++) {\n        int bits = (1 << i);\n        bits |= (1 << (i + 1));\n        if(S[bits] == '1') continue;\n        if(block[i]) continue;\n        if(block[i+1]) continue;\n        tate[i] = true;\n        g(i);\n    }\n    {\n        if(!block[0] and !block[N-1] and S[1|(1<<(N-1))]=='0') {\n            h();\n            side = true;\n        }\n    }\n    //print();\n    for(int bits = 0; bits < (1 << N); bits++) {\n        bool blocked = false;\n        if(true) {\n            for(int i = 0; i < N; i++) {\n                if((bits & (1 << i)) and block[i]) {\n                    blocked = true;\n                    //cout << \"Impossible\" << endl;\n                    //return 0;\n                }\n            }\n            for(int i = 0; i + 1 < N; i++) {\n                if((bits & (1 << i)) and (bits & (1 << (i+1))) and tate[i]) {\n                    blocked = true;\n                    //cout << \"Impossible\" << endl;\n                    //return 0;\n                }\n            }\n            bool Left = true;\n            bool Right = true;\n            for(int i = 0; i < N; i++) {\n                if(!(bits & (1 << i))) continue;\n                if(tate[i]) Left = false;\n                if(i > 0 and tate[i-1]) Right = false;\n            }\n            if(bits & 1) {\n                if(side) Left = false;\n            }\n            if(bits & (1 << (N-1))) {\n                if(side) Right = false;\n            }\n            if(!Right and !Left) {\n                //cout << \"Impossible\" << endl;\n                //return 0;\n                blocked = true;\n            }\n        }\n        //cerr << bitset<10>(bits) << \" \" << blocked << \" \" << (S[bits] == '0') << endl;\n        if(blocked ^ (S[bits] == '0')) {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n    print();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\nCode for problem E by cookiedoth\nGenerated 21 Mar 2020 at 05.19 PM\n\n\n______▄███████▄_______\n______█▄█████▄█_______\n______█▼▼▼▼▼█_______\n_____██________ ██______\n______█▲▲▲▲▲█_______\n______█████████_______\n_______██____ ██________\n\n>_<\no_O\n^_^\n\n*/\n\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <ctime>\n#include <functional>\n#include <unordered_set>\n#include <unordered_map>\n#include <string>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <complex>\n#include <cassert>\n#include <random>\n#include <cstring>\n#include <numeric>\n#define ll long long\n#define ld long double\n#define null NULL\n#define all(a) a.begin(), a.end()\n#define rall(a) a.rbegin(), a.rend()\n#define debug(a) cerr << #a << \" = \" << a << endl\n#define forn(i, n) for (int i = 0; i < n; ++i)\n#define sz(a) (int)a.size()\n\nusing namespace std;\n\ntemplate<class T> int chkmax(T &a, T b) {\n\tif (b > a) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\ntemplate<class T> int chkmin(T &a, T b) {\n\tif (b < a) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\ntemplate<class iterator> void output(iterator begin, iterator end, ostream& out = cerr) {\n\twhile (begin != end) {\n\t\tout << (*begin) << \" \";\n\t\tbegin++;\n\t}\n\tout << endl;\n}\n\ntemplate<class T> void output(T x, ostream& out = cerr) {\n\toutput(x.begin(), x.end(), out);\n}\n\nvoid fast_io() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n}\n\nint x;\nvector<pair<int, int> > ans;\n\nvoid move(int dest_x) {\n\tif (x == dest_x) {\n\t\treturn;\n\t}\n\tif (dest_x > x) {\n\t\tx++;\n\t\tans.emplace_back(x, 0);\n\t} else {\n\t\tx--;\n\t\tans.emplace_back(x, 0);\n\t}\n\tmove(dest_x);\n}\n\nvoid use(int pos, int d) {\n\t// cerr << \"use \" << pos << \" \" << d << endl;\n\tif (d == 0) {\n\t\tmove(pos);\n\t\tans.emplace_back(pos, 1);\n\t\tans.emplace_back(pos + 1, 1);\n\t\tans.emplace_back(pos + 1, 0);\n\t\tx++;\n\t} else {\n\t\tmove(pos + 1);\n\t\tans.emplace_back(pos + 1, 1);\n\t\tans.emplace_back(pos, 1);\n\t\tans.emplace_back(pos, 0);\n\t\tx--;\n\t}\n}\n\nconst int mx = 300;\nint n, a[mx];\n\nvector<vector<pair<int, int> > > str;\n\nvoid gen_str() {\n\tstr.resize(n + 1);\n\tstr[1] = {{0, 0}};\n\tfor (int i = 2; i <= n; ++i) {\n\t\tstr[i].emplace_back(i - 1, 0);\n\t\tfor (auto pp : str[i - 1]) {\n\t\t\tstr[i].push_back(pp);\n\t\t}\n\t\tstr[i].emplace_back(i - 1, 1);\n\t\tvector<pair<int, int> > keks = str[i - 1];\n\t\treverse(all(keks));\n\t\tfor (auto pp : keks) {\n\t\t\tstr[i].emplace_back(pp.first, pp.second ^ 1);\n\t\t}\n\t\t// cerr << \"i = \" << i << endl;\n\t\t// for (auto pp : str[i]) {\n\t\t// \tcerr << pp.first << \" \" << pp.second << endl;\n\t\t// }\n\t}\n}\n\nvoid make(int sub) {\n\tvector<int> have;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif ((sub >> i) & 1) {\n\t\t\thave.push_back(i);\n\t\t}\n\t}\n\tint k = __builtin_popcount(sub);\n\tfor (auto pp : str[k]) {\n\t\tuse(have[pp.first], pp.second);\n\t}\n}\n\nsigned main() {\n\tfast_io();\n\tans.emplace_back(0, 0);\n\tcin >> n;\n\tgen_str();\n\tfor (int i = 0; i < (1 << n); ++i) {\n\t\tchar c;\n\t\tcin >> c;\n\t\ta[i] = c - '0';\n\t}\n\tif (a[0] == 0) {\n\t\tcout << \"Impossible\" << endl;\n\t\texit(0);\n\t}\n\tfor (int i = 0; i < (1 << n); ++i) {\n\t\tfor (int j = 0; j < i; ++j) {\n\t\t\tif (a[i] == 1 && ((i & j) == j) && a[j] == 0) {\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < (1 << n); ++i) {\n\t\tif (a[i] == 0) {\n\t\t\tint ok = 1;\n\t\t\tfor (int j = 0; j < i; ++j) {\n\t\t\t\tif (a[j] == 0 && (i & j) == j) {\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tmake(i);\n\t\t\t}\n\t\t}\n\t}\n\tmove(0);\n\tcout << \"Possible\" << \"\\n\";\n\tcout << (int)ans.size() - 1 << \"\\n\";\n\tfor (auto pp : ans) {\n\t\tcout << pp.first << \" \" << pp.second << \"\\n\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define re register\ninline int read(){\n\tre int t=0;\n\tre char v=getchar();\n\twhile(v<'0')v=getchar();\n\twhile(v>='0')t=(t<<3)+(t<<1)+v-48,v=getchar();\n\treturn t;\n}\nint n,ans,a[1000002];\nchar s[1000002];\n\nint main(){\n\tn=read();\n\tscanf(\"%s\",s+1);\n\tif(n>30000){\nfor(re int i=1;i<100;++i){\n\t\t\tfor(re int j=1;j<=n-i;++j)a[j]=abs(a[j]-a[j+1]);\n\t\t}printf(\"%d\\n\",a[1]);\t}\n\telse{\n\t\tfor(re int i=1;i<=n;++i)a[i]=s[i]-'0';\n\t\tfor(re int i=1;i<n;++i){\n\t\t\tfor(re int j=1;j<=n-i;++j)a[j]=abs(a[j]-a[j+1]);\n\t\t}\n\t\tprintf(\"%d\",a[1]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define INF ((1<<30)-1)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nvoid ok(){\n    cout << \"Yes\" << endl;\n    exit(0);\n}\n\nvoid ng(){\n    cout <<  \"Impossible\" << endl;\n    exit(0);\n}\n\n\nint n;\nint a[1 << 8];\n\nvector<int> loops;\n\nvoid entangle(int x){\n    vector<int> loop;\n    for(int i = n-1;i >= 0;i--){\n        if((x >> i) % 2 == 0)continue;\n        if(loop.empty()){\n            loop.push_back(i+1);\n            loop.push_back(-i-1);\n        }\n        else{\n            vector<int> tmp;\n            tmp.push_back(i+1);\n            tmp.push_back(-i-1);\n            for(auto it = loop.begin();it != loop.end();it++)tmp.push_back(*it);\n\t\ttmp.push_back(INF);\n            tmp.push_back(-i-1);\n            tmp.push_back(i+1);\n            for(auto it = loop.rbegin();it != loop.rend();it++)tmp.push_back(*it);\n\t\ttmp.push_back(INF);\n            loop = tmp;\n        }\n    }\n    for(auto elem:loop)loops.push_back(elem);\n}\n\nvoid show(){\n    cout << \"Possible\" << endl;\n    vector<P> ps;\n    ps.push_back(P(0,0));\n    int nowx = 0, nowy = 0;\n    for(int x:loops){\n        if(x == INF){\n            while(nowx > 0){\n                ps.push_back(P(--nowx, nowy));\n            }\n            continue;\n        }\n        if(x > 0){\n            while(nowx > x){\n                ps.push_back(P(--nowx, nowy));\n            }\n            while(nowx < x-1){\n                ps.push_back(P(++nowx, nowy));\n            }\n            ps.push_back(P(nowx,++nowy));\n            if(nowx == x)ps.push_back(P(--nowx, nowy));\n            else ps.push_back(P(++nowx, nowy));\n            ps.push_back(P(nowx,--nowy));\n        }\n        if(x < 0){\n            x = x * -1;\n            while(nowx > x){\n                ps.push_back(P(--nowx, nowy));\n            }\n            while(nowx < x-1){\n                ps.push_back(P(++nowx, nowy));\n            }\n            if(nowx == x)ps.push_back(P(--nowx, nowy));\n            else ps.push_back(P(++nowx, nowy));\n        }\n    }\n    cout << ps.size() - 1 << endl;\n    for(auto p:ps){\n        cout << p.first << \" \" << p.second << endl;\n    }\n}\n\nint main(){\n    cin >> n;\n    for(int i = 0;i < (1<<n);i++){\n        scanf(\"%1d\", a+i);\n        bool bad;\n        if(a[i] == 0)bad = true;\n        for(int j = 0;j < i;j++){\n            if((j & i) != j)continue;\n            if(a[i] == 1 && a[j] == 0){\n                ng();                    \n            }\n            if(a[j] == 0)bad = false;\n        }\n        if(bad){\n            entangle(i);\n        }\n    }\n    show();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i = (begin); i < (end); i++)\n#define rep(i, n) FOR(i, 0, n)\nusing ll = long long;\nusing namespace std;\n#define all(x) (x).begin(),(x).end()\nusing pii = pair<int, int>; using vi = vector<int>; using vl = vector<ll>;\n\nint N;\n\nunordered_set<int> setter(int i) {\n    unordered_set<int> ss;\n    rep(j, N) {\n        int k = i & 1;\n        if (k == 0)\n            ss.insert(j);\n        i >> 1;\n    }\n    return ss;\n}\n// 和集合の計算\ntemplate<class T> unordered_set<T> Union(unordered_set<T>& rsettA, unordered_set<T>&rsettB) {\n    unordered_set<T> settUnion(rsettA);\n    for (auto itt = rsettB.begin(); itt != rsettB.end(); itt++) {\n        settUnion.insert(*itt);\n    }\n    return settUnion;\n}\n// 積集合の計算\ntemplate<class T> unordered_set<T> Product(unordered_set<T>& rsettA, unordered_set<T>&rsettB) {\n    unordered_set<T> settProduct;\n    for (auto itt = rsettB.begin(); itt != rsettB.end(); itt++) {\n        if (rsettA.find(*itt) != rsettA.end()) {\n            settProduct.insert(*itt);\n        }\n    }\n    return settProduct;\n}\n// 補集合の計算\ntemplate<class T> unordered_set<T> Complement(unordered_set<T>& rsettA, unordered_set<T>&rsettB) {\n    unordered_set<T> settComplement(rsettA);\n    for (auto itt = rsettB.begin(); itt != rsettB.end(); itt++) {\n        settComplement.erase(*itt);\n    }\n    return settComplement;\n}\nsigned main() {\n    cin >> N;\n    // unordered_set<int> oo, ii;\n    int oo(0), ii(0);\n    string as;\n    cin >> as;\n    rep(i, 1<<N) {\n        int x = as[i] - '0';\n        // auto ss = setter(i);\n        if (x == 1) {\n            oo |= i;\n            // ii = Union(ii, ss);\n        } else {\n            ii |= i;\n            // oo = Union(oo, ss);\n        }\n    }\n    // if (Product(oo, ii).size() != 0) {\n    if (oo&ii != 0) {\n        cout << \"Impossible\" << endl;\n        return 0;\n    }\n    cout << \"Possible\" << endl;\n\n    vector<pii> p;\n    int before = 0;\n    // cerr << ii << endl;\n    p.push_back({0, 0});\n    rep(i, N) {\n        if(ii&1 ^ before) {\n            if(ii&1) {\n                if(i!=0) {\n                    p.push_back({i, 0});\n                }\n                p.push_back({i, 1});\n            } else {\n                p.push_back({i, 1});\n                if(i!=N-1)\n                    p.push_back({i, 0});\n            }\n        } else {\n            p.push_back({i, before});\n        }\n        before = ii & 1;\n        ii >> 1;\n    }\n    if (before)\n        p.push_back({N, 1});\n    for(int k = N; k>=0; k--) {\n        p.push_back({k, 0});\n    }\n\n    cout << p.size() - 1 << endl;\n    for(auto pp : p) {\n        cout << pp.first << ' ' << pp.second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nnamespace std {\n\ntemplate<class Fun>\nclass y_combinator_result {\n\tFun fun_;\npublic:\n\ttemplate<class T>\n\texplicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n\n\ttemplate<class ...Args>\n\tdecltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n\ntemplate<class Fun>\ndecltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\n} // namespace std\n\nconst char* IMPOSSIBLE = \"Impossible\";\nconst char* POSSIBLE = \"Possible\";\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint N; cin >> N;\n\tvector<bool> A(1<<N);\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tchar c; cin >> c;\n\t\tassert(c == '0' || c == '1');\n\t\tA[(1<<N)-1-m] = (c == '1');\n\t}\n\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\t// m2 is a superset\n\t\t\tif (A[m] > A[m | (1<<i)]) {\n\t\t\t\tcout << IMPOSSIBLE << '\\n';\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t}\n\tcout << POSSIBLE << '\\n';\n\tmt19937 mt(48);\n\tvector<int> maxExclude;\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tif (A[m]) continue;\n\t\tbool isMaximal = true;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (!(m & (1<<i)) && !A[m | (1<<i)]) {\n\t\t\t\tisMaximal = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isMaximal) {\n\t\t\tmaxExclude.push_back(m);\n\t\t}\n\t}\n\tvector<int> pattern;\n\tfor (int m : maxExclude) {\n\t\tvector<int> pts;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (m & (1<<i)) continue;\n\t\t\tpts.push_back(i+1);\n\t\t}\n\t\tassert(!pts.empty());\n\t\t//shuffle(pts.begin(), pts.end(), mt);\n\t\tqueue<vector<int>> q;\n\t\tfor (auto i : pts) {\n\t\t\tq.push(vector<int>({i}));\n\t\t}\n\t\twhile (q.size() > 1) {\n\t\t\tvector<int> a = std::move(q.front()); q.pop();\n\t\t\tvector<int> b = std::move(q.front()); q.pop();\n\t\t\tvector<int> r; r.reserve(a.size() * 2 + b.size() * 2);\n\t\t\tfor (int i : a) r.push_back(i);\n\t\t\tfor (int i : b) r.push_back(i);\n\t\t\treverse(a.begin(), a.end());\n\t\t\treverse(b.begin(), b.end());\n\t\t\tfor (int i : a) r.push_back(-i);\n\t\t\tfor (int i : b) r.push_back(-i);\n\t\t\tq.push(std::move(r));\n\t\t}\n\t\tpattern.insert(pattern.end(), q.front().begin(), q.front().end());\n\t}\n\t/*\n\tvector<int> pattern = std::y_combinator([&](auto self, int n, int l, int r) -> vector<int> {\n\t\tassert(A[r-1]);\n\t\tif (n == 0) {\n\t\t\treturn {};\n\t\t}\n\t\tvector<int> a = self(n-1, l + (1<<(n-1)), r);\n\t\tvector<int> res = a;\n\t\tres.push_back(n);\n\t\tif (A[l+(1<<(n-1))-1]) {\n\t\t\tvector<int> b = self(n-1, l, l + (1<<(n-1)));\n\t\t\tfor (int i : b) res.push_back(i);\n\t\t\tres.push_back(-n);\n\t\t\treverse(b.begin(), b.end());\n\t\t\tfor (int i : b) res.push_back(-i);\n\t\t}\n\t\treturn res;\n\t})(N, 0, (1<<N));\n\t*/\n\n\tvector<bool> patA(1<<N);\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tstack<int> st;\n\t\tfor (int i : pattern) {\n\t\t\tif (m & (1<<(abs(i)-1))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!st.empty() && st.top() == -i) {\n\t\t\t\tst.pop();\n\t\t\t} else {\n\t\t\t\tst.push(i);\n\t\t\t}\n\t\t}\n\t\tpatA[m] = st.empty();\n\t}\n\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tassert(patA[m] == A[m]);\n\t}\n\n\tvector<pair<int, int>> pos;\n\tpos.emplace_back(0,1);\n\tauto goToPt = [&](int x) {\n\t\tassert(pos.back().second == 1);\n\t\tif (pos.back() == pair<int, int>(x,1)) {\n\t\t\treturn;\n\t\t}\n\t\tpos.emplace_back(pos.back().first, 0);\n\t\twhile (pos.back().first < x) {\n\t\t\tpos.emplace_back(pos.back().first+1, 0);\n\t\t}\n\t\twhile (pos.back().first > x) {\n\t\t\tpos.emplace_back(pos.back().first-1, 0);\n\t\t}\n\t\tpos.emplace_back(x,1);\n\t};\n\tfor (auto i : pattern) {\n\t\tassert(i != 0);\n\t\tif (i > 0) {\n\t\t\tgoToPt(i-1);\n\t\t\tpos.emplace_back(i, 1);\n\t\t} else {\n\t\t\tgoToPt(-i);\n\t\t\tpos.emplace_back(-i-1, 1);\n\t\t}\n\t}\n\n\tgoToPt(0);\n\n\tif (int(pos.size()) - 1 > 250000) {\n\t\twhile (true);\n\t}\n\tcout << pos.size()-1 << '\\n';\n\tfor (auto it : pos) {\n\t\tcout << it.first << ' ' << it.second << '\\n';\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint N; char str[1 << 8 | 1];\nvector < int > pot;\nvector < int > operator +(vector < int > p , vector < int > q){p.insert(p.end() , q.begin() , q.end()); return p;}\n\nvector < int > build(int id , int x){\n\tif(id < (1 << (x + 1))) return vector < int >{x + 1 , -x - 1};\n\tvector < int > tmp = build(id , x + 1);\n\tif(!(id >> x & 1)) return vector < int >{x + 1} + tmp + vector < int >{x + 1};\n\tvector < int > rev = tmp; reverse(rev.begin() , rev.end());\n\treturn vector < int >{x + 1} + tmp + vector < int >{x + 1} + vector < int >{-x - 1} + rev + vector < int >{-x - 1};\n}\n\nint main(){\n\tscanf(\"%d %s\" , &N , str);\n\tfor(int i = 0 ; i < 1 << N ; ++i)\n\t\tif(str[i] == '1')\n\t\t\tfor(int j = 0 ; j < N ; ++j)\n\t\t\t\tif((i >> j & 1) && str[i ^ (1 << j)] != '1'){\n\t\t\t\t\tputs(\"Impossible\"); return 0;\n\t\t\t\t}\n\tfor(int i = 0 ; i < 1 << N ; ++i)\n\t\tif(str[i] == '0'){\n\t\t\tbool flg = 1;\n\t\t\tfor(int j = 0 ; j < N ; ++j)\n\t\t\t\tif((i >> j & 1) && str[i ^ (1 << j)] == '0')\n\t\t\t\t\tflg = 0;\n\t\t\tif(flg) pot = pot + build(i , 0);\n\t\t}\n\tputs(\"Possible\"); vector < pair < int , int > > node;\n\tint curx = 0 , cury = 0; node.push_back(make_pair(0 , 0));\n\tfor(int i = 0 ; i < pot.size() ; ++i){\n\t\tif(pot[i] < 0 && cury == 1) node.push_back(make_pair(curx , cury = 0));\n\t\tif(pot[i] > 0 && cury == 0) node.push_back(make_pair(curx , cury = 1));\n\t\tint t = abs(pot[i]) - 1;\n\t\tif(curx == t) node.push_back(make_pair(++curx , cury));\n\t\telse node.push_back(make_pair(--curx , cury));\n\t}\n\tif(cury) node.push_back(make_pair(0 , 0));\n\tprintf(\"%d\\n\" , node.size() - 1);\n\tfor(auto t : node) printf(\"%d %d\\n\" , t.first , t.second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define SZ(x) ((int)x.size())\n#define ALL(x) x.begin(),x.end()\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> T gcd(T a, T b){return !b?a:gcd(b,a%b);}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 266666;\nPii ans[N];int sz;\nint n,a[N];\nvoid solve(int S){\n\tvector<Pii> cur;bool first=1;\n\tper(i,n,1)if(S>>i-1&1){\n\t\tif(first){\n\t\t\tfirst=0;cur={mp(i,1),mp(i,0)};\n\t\t}\n\t\telse{\n\t\t\tvector<Pii>nxt={mp(i,1)};\n\t\t\tnxt.insert(nxt.end(),ALL(cur));\n\t\t\tnxt.pb(mp(i,1));\n\t\t\tnxt.pb(mp(i,0));\n\t\t\tper(i,SZ(cur)-1,0)nxt.pb(cur[i]);\n\t\t\tnxt.pb(mp(i,0));\n\t\t\tcur=nxt;\n\t\t}\n\t}\n\telse cur.insert(cur.begin(),mp(i,1)),cur.insert(cur.end(),mp(i,1));\n\tint x=0,y=1;\n\tfor(auto i:cur){\n\t//\tcerr<<i.fi<<' '<<i.se<<endl;\n\t\tif(y!=i.se)ans[++sz]=mp(x,y^1),y^=1;\n\t\tint tar=x<i.fi?i.fi:i.fi-1;\n\t\twhile(x!=tar)ans[++sz]=mp(x+(tar>x?1:-1),y),x=ans[sz].fi;\n\t}\n\tPii i(0,1);\n\tif(y!=i.se)ans[++sz]=mp(x,y^1),y^=1;\n\twhile(x!=0)ans[++sz]=mp(x-1,y),x--;\n}\nvoid GG(){puts(\"Impossible\");exit(0);}\nint main() {\n\tchar ss[1<<8|3];read(n);scanf(\"%s\",ss);\n\trep(i,0,(1<<n)-1)a[i]=ss[i]=='1';\n\tif(!a[0])GG();\n\trep(s,1,(1<<n)-1)if(!a[s])rep(i,0,n-1)if(~s>>i&1)\n\t\tif(a[s^(1<<i)])GG();\n\tans[++sz]=mp(0,1);\n\trep(s,1,(1<<n)-1)if(!a[s]){\n\t\tbool ok=1;rep(i,0,n-1)if(s>>i&1)ok&=a[s^(1<<i)];\n\t\tif(ok)solve(s);\n\t}\n\tprintf(\"Possible\\n%d\\n\",sz-1);\n\trep(i,1,sz)printf(\"%d %d\\n\",ans[i].fi,ans[i].se);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 15;\nconst int MAXS = 1 << 8;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nvector <pair <int, int>> ans, tmp;\nint n, bit[MAXN]; bool flg[MAXS]; char s[MAXN];\nvoid augment(vector <pair <int, int>> &res, int x) {\n\tif (res.size() == 0) {\n\t\tres.emplace_back(x, 0);\n\t\tres.emplace_back(x, 1);\n\t\treturn;\n\t}\n\tvector <pair <int, int>> tmp;\n\ttmp.emplace_back(x, 0);\n\tfor (auto x : res) tmp.push_back(x);\n\ttmp.emplace_back(x, 0);\n\treverse(tmp.begin(), tmp.end());\n\ttmp.emplace_back(x, 1);\n\tfor (auto x : res) tmp.push_back(x);\n\ttmp.emplace_back(x, 1);\n\tres = tmp;\n}\nvoid work(int mask) {\n\ttmp.clear(); int cur = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (mask & bit[i]) augment(tmp, i);\n\tfor (auto x : tmp) {\n\t\tif (x.second == 0) {\n\t\t\tif (cur >= x.first) while (cur >= x.first) ans.emplace_back(--cur, 0);\n\t\t\telse while (cur < x.first) ans.emplace_back(++cur, 0);\n\t\t} else {\n\t\t\tif (cur >= x.first) {\n\t\t\t\tans.emplace_back(cur, 1);\n\t\t\t\twhile (cur >= x.first) ans.emplace_back(--cur, 1);\n\t\t\t\tans.emplace_back(cur, 0);\n\t\t\t} else {\n\t\t\t\tans.emplace_back(cur, 1);\n\t\t\t\twhile (cur < x.first) ans.emplace_back(++cur, 1);\n\t\t\t\tans.emplace_back(cur, 0);\n\t\t\t}\n\t\t}\n\t}\n\twhile (cur > 0) ans.emplace_back(--cur, 0);\n}\nint main() {\n\tread(n), scanf(\"\\n%s\", s);\n\tfor (int i = 1; i <= n; i++)\n\t\tbit[i] = 1 << (i - 1);\n\tint goal = 1 << n;\n\tfor (int i = 0; i < goal; i++)\n\tfor (int j = 0; j < i; j++)\n\t\tif ((i & j) == j && s[j] == '0') flg[i] = true;\n\tfor (int i = 0; i < goal; i++)\n\t\tif (s[i] == '1' && flg[i]) {\n\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\tputs(\"Possible\");\n\tfor (int i = 0; i < goal; i++)\n\t\tif (s[i] == '0' && !flg[i]) work(i);\n\tcout << ans.size() << endl;\n\tprintf(\"%d %d\\n\", 0, 0);\n\tfor (auto x : ans)\n\t\tprintf(\"%d %d\\n\", x.first, x.second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(\"wzpakking\")\n#define y1 ysghysgsygsh\nusing namespace std;\n#define vi vector<int>\nint n,flg[500];\nchar s[500];\nvi q;\nvector<pii> ans;\nvi get(vi x){\n\tif (x.size()==1) return x;\n\tint t=x.back();\n\tx.pop_back();\n\tvi v=get(x),res;\n\tres.PB(t);\n\tfor (auto i:v) res.PB(i);\n\tres.PB(-t); \n\treverse(v.begin(),v.end());\n\tfor (auto i:v) res.PB(-i);\n\treturn res;\n}\nvoid walk(int &x,int y){\n\tfor (;x<y;ans.PB(pii(++x,0)));\n\tfor (;x>y;ans.PB(pii(--x,0)));\n}\nint main(){\n\tscanf(\"%d%s\",&n,s);\n\tFor(i,0,(1<<n)-1) s[i]-='0';\n\tFor(i,0,(1<<n)-1) For(j,0,(1<<n)-1)\n\t\tif ((i&j)==j&&s[i]&&!s[j])\n\t\t\treturn puts(\"Impossible\"),0;\n\tFor(i,0,(1<<n)-1) if (!s[i])\n\t\tFor(j,0,(1<<n)-1) if (j!=i&&(i&j)==j&&!s[j]) flg[i]=1;\n\tFor(i,0,(1<<n)-1) if (!s[i]&&!flg[i]){\n\t\t//cout<<i<<endl;\n\t\tvector<int> tmp;\n\t\tFor(j,0,n-1) if (i&(1<<j)) tmp.PB(j+1);\n\t\ttmp=get(tmp);\n\t\tfor (auto j:tmp) q.PB(j);\n\t}\n\tint x=0;\n\tans.PB(pii(0,0));\n\tfor (auto i:q){\n\t\tint st,ed;\n\t\tif (i>0) st=i-1,ed=i;\n\t\telse st=-i,ed=-i-1;\n\t\twalk(x,st);\n\t\tans.PB(pii(st,1));\n\t\tans.PB(pii(ed,1));\n\t\tans.PB(pii(ed,0));\n\t\tx=ed;\n\t}\n\twalk(x,0);\n\tprintf(\"Possible\\n%d\\n\",ans.size()-1);\n\tfor (auto i:ans) printf(\"%d %d\\n\",i.fi,i.se);\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define ALL(x) (x).begin(), (x).end()\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool chmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool chmin(T &m, const T q) { if (q < m) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n/*\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/tag_and_trait.hpp>\nusing namespace __gnu_pbds; // find_by_order(), order_of_key()\ntemplate<typename TK> using pbds_set = tree<TK, null_type, less<TK>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename TK, typename TV> using pbds_map = tree<TK, TV, less<TK>, rb_tree_tag, tree_order_statistics_node_update>;\n*/\n\nconst string YES = \"Possible\";\nconst string NO = \"Impossible\";\n\nbool impossible_checker(int N, string S) {\n    assert((int)(S.length()) == (1 << N));\n    if (S[0] == '0') return true;\n    REP(a, 1 << N)\n    {\n        REP(b, 1 << N) if (((~b) & a) == 0) {\n            if (S[b] == '1' and S[a] == '0') return true;\n        }\n    }\n    return false;\n}\n\nvector<vector<pint>> Rloop(8);\nvector<vector<pint>> Lloop(8);\n\nvector<vector<int>> S(9);\n\nint x_now, y_now;\n\nvector<pint> ret;\n\nvoid up() {\n    y_now++;\n    ret.emplace_back(x_now, y_now);\n}\nvoid down() {\n    y_now--;\n    ret.emplace_back(x_now, y_now);\n}\nvoid right() {\n    x_now++;\n    ret.emplace_back(x_now, y_now);\n}\nvoid left() {\n    x_now--;\n    ret.emplace_back(x_now, y_now);\n}\n\nvoid do_rloop(int X)\n{\n    if (y_now == 0) {\n        up();\n    }\n    while (x_now < X) right();\n    while (x_now > X) left();\n    right();\n    down();\n    left();\n    up();\n}\n\nvoid do_lloop(int X) {\n    if (y_now == 0) {\n        up();\n    }\n    while (x_now < X) right();\n    while (x_now > X) left();\n    down();\n    right();\n    up();\n    left();\n}\n\nvoid go_origin() {\n    if (y_now == 0) up();\n    while (x_now > 0) left();\n    down();\n}\n\nint main()\n{\n    int N;\n    string A;\n    cin >> N >> A;\n    if (impossible_checker(N, A)) {\n        cout << NO << endl;\n        return 0;\n    }\n\n    REP(x, 8) {\n        Rloop[x].emplace_back(0, 0);\n        REP(d, x + 1) Rloop[x].emplace_back(d, 1);\n        Lloop[x] = Rloop[x];\n        Rloop[x].emplace_back(x + 1, 1);\n        Lloop[x].emplace_back(x, 0);\n        Lloop[x].emplace_back(x + 1, 0);\n        Lloop[x].emplace_back(x + 1, 1);\n        Rloop[x].emplace_back(x + 1, 0);\n        Rloop[x].emplace_back(x, 0);\n        IREP(d, x + 1) Rloop[x].emplace_back(d, 1);\n        IREP(d, x + 1) Lloop[x].emplace_back(d, 1);\n    }\n\n    S[1] = {+1};\n    S[2] = {+1, +2, -1, -2};\n    FOR(d, 3, S.size()) {\n        S[d] = {d};\n        vector<int> prev = S[d - 1];\n        S[d].insert(S[d].end(), ALL(prev));\n        S[d].push_back(-d);\n        reverse(ALL(prev));\n        for (auto &x : prev) x *= -1;\n        S[d].insert(S[d].end(), ALL(prev));\n    }\n\n    up();\n    down();\n\n    REP(subset, 1 << N) if (A[subset] == '0') {\n        bool must = true;\n        REP(ss, 1 << N) if (((~subset) & ss) == 0 and ss < subset) {\n            if (A[ss] == '0') must = false;\n        }\n        if (!must) continue;\n        int cnt = __builtin_popcount(subset);\n        if (cnt == 1) {\n            int i = 0;\n            while ((subset >> i) % 2 == 0) i++;\n            do_rloop(i);\n            continue;\n        }\n\n        vector<int> ns;\n        REP(i, N) if ((subset >> i) & 1) ns.push_back(i);\n        for (auto dict : S[cnt]) {\n            int id_ = abs(dict) - 1;\n            if (dict > 0) do_rloop(ns[id_]);\n            else do_lloop(ns[id_]);\n        }\n    }\n    go_origin();\n    up();\n\n    cout << YES << \"\\n\";\n    cout << ret.size() << \"\\n\";\n    for (auto p : ret) cout << p.first << \" \" << p.second << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,L;\nstring A;\nint ismin[256];\n\n\nvector<pair<int,int>> construct(int mask) {\n\tvector<pair<int,int>> V;\n\t\n\tint i;\n\tFOR(i,N) if(mask&(1<<i)) {\n\t\tif(__builtin_popcount(mask)==1) {\n\t\t\tV.push_back({i,1});\n\t\t\tV.push_back({i+1,1});\n\t\t\tV.push_back({i+1,0});\n\t\t\tV.push_back({i,0});\n\t\t}\n\t\telse {\n\t\t\tvector<pair<int,int>> W=construct(mask^(1<<i));\n\t\t\tV.push_back({i,1});\n\t\t\twhile(V.back().first+1<W[0].first) {\n\t\t\t\tV.push_back(V.back());\n\t\t\t\tV.back().first++;\n\t\t\t}\n\t\t\tFORR(w,W) V.push_back(w);\n\t\t\tV.push_back(W.back());\n\t\t\tV.back().second=1;\n\t\t\twhile(V.back().first>i) {\n\t\t\t\tV.push_back(V.back());\n\t\t\t\tV.back().first--;\n\t\t\t}\n\t\t\tV.push_back({i,0});\n\t\t\tV.push_back({i+1,0});\n\t\t\tV.push_back({i+1,1});\n\t\t\treverse(ALL(W));\n\t\t\twhile(V.back().first+1<W[0].first) {\n\t\t\t\tV.push_back(V.back());\n\t\t\t\tV.back().first++;\n\t\t\t}\n\t\t\t\n\t\t\tFORR(w,W) V.push_back(w);\n\t\t\twhile(V.back().first>i+1) {\n\t\t\t\tV.push_back(V.back());\n\t\t\t\tV.back().first--;\n\t\t\t}\n\t\t\tV.push_back({i+1,0});\n\t\t\tV.push_back({i,0});\n\t\t}\n\t\tbreak;\n\t}\n\treturn V;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>A;\n\tL=1<<N;\n\tFORR(c,A) c-='0';\n\tFOR(x,L) FOR(y,L) if((x&y)==y && A[x] && A[y]==0) return _P(\"Impossible\\n\");\n\tFOR(x,L) ismin[x]=A[x]==0;\n\tFOR(x,L) if(A[x]==0) FOR(y,L) if((x&y)==y && y<x && A[y]==0) ismin[y]=0;\n\t\n\tvector<pair<int,int>> W;\n\tW.push_back({0,0});\n\tFOR(x,L) if(A[x]==0) {\n\t\tvector<pair<int,int>> V=construct(x);\n\t\tFOR(i,V[0].first) W.push_back({i,1});\n\t\tFORR(v,V) W.push_back(v);\n\t\tfor(i=V[0].first;i>=0;i--) W.push_back({i,1});\n\t\tW.push_back({0,0});\n\t}\n\tcout<<\"Possible\"<<endl;\n\tcout<<W.size()-1<<endl;\n\tFORR(w,W) cout<<w.first<<\" \"<<w.second<<endl;\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define all(x) x.begin(),x.end()\n#define cmin(a,b) (a>b?a=b:a)\n#define cmax(a,b) (a<b?a=b:a)\n#define mem(a,k) memset(a,k,sizeof(a))\n#define lop(i,s,t) for(int i=s;i<(t);++i)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define fore(i,v) for(int i=g[v],d=es[i].d;i;i=es[i].nxt,d=es[i].d)\nusing namespace std;\n\n#ifdef CURIOUSCAT\n#define Pr(f,...) fprintf(stderr,f,##__VA_ARGS__),fflush(stderr)\n#else\n#define Pr(f,...) ;\n#endif\n\ntypedef long long ll;\n\ntemplate<typename T>\nvoid read(T &x){\n\tx=0; \n\tchar c;\n\tfor(c=getchar();!isdigit(c);c=getchar()); \n\tfor(;isdigit(c);c=getchar())x=x*10+c-'0'; \n}\n\nconst int N=1e6+50;\n\nint P;\nint mul(int a,int b){ return 1ll*a*b%P; }\nint add(int a,int b){ a+=b; return a>=P?a-P:a; }\nvoid upd(int &a,int b) { a=a+b>=P?a+b-P:a+b; }\nint sub(int a,int b){ a-=b; return a<0?a+P:a; }\nint gcd(int a,int b){ return !b?a:gcd(b,a%b); }\n\nint n;\nchar a[1<<9];\nint main(int argc,char *argv[]){\n#ifdef CURIOUSCAT\n#endif\n\tread(n); \n\tlop(s,0,(1<<n)){\n\t\tscanf(\" %c\",&a[s]); a[s]-='0';\n\t}\n\tlop(s,0,(1<<n)){\n\t\tint c0=0,c1=0;\n\t\tlop(i,0,n)if(s>>i&1){\n\t\t\tif(a[1<<i])++c1;else ++c0;\n\t\t}\n\t\tPr(\"%d,%d,%d,%d\\n\",s,c0,c1,a[s]); \n\t\tif((c0&&a[s])||(!c0&&!a[s])){\n\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\treturn 0; \n\t\t}\n\t}\n\tint cnt=0;\n\tlop(i,0,n)cnt+=!a[1<<i];\n\tcout<<\"possible\"<<endl;\n\tif(cnt==0){\n\t\tcout<<0<<endl;\n\t\tcout<<1<<\" \"<<1<<endl;\n\t}else{\n\t\tvector<pair<int,int>> ans;\n\t\tans.pb(mp(0,0));\n\t\tfor(int i=0,p;i<n;i=p){\n\t\t\tif(!a[1<<i]){\n\t\t\t\tfor(p=i;p<n&&!a[1<<p];++p);\n\t\t\t\tans.pb(mp(i,1));\n\t\t\t\tlop(z,0,p-i)ans.pb(mp(i+z+1,1));\n\t\t\t}else{\n\t\t\t\tfor(p=i;p<n&&a[1<<p];++p);\n\t\t\t\tans.pb(mp(i,0)); \n\t\t\t\tlop(z,0,p-i)ans.pb(mp(i+z+1,0));\n\t\t\t}\n\t\t}\n\t\tif(a[1<<(n-1)]){\n\t\t\tdec(i,n,0)ans.pb(mp(i,-1));\n\t\t\tans.pb(mp(0,0)); \n\t\t}else{\n\t\t\tans.pb(mp(n,0));\n\t\t\tdec(i,n,0)ans.pb(mp(i,-1)); \n\t\t\tans.pb(mp(0,0)); \n\t\t}\n\t\tprintf(\"%d\\n\",(int)ans.size()-1);\n\t\tfor(auto x:ans)printf(\"%d %d\\n\",x.fi,x.sc); \n\t}\n\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define fr first\n#define sc second\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n\nvector<P> ret;\n\nvoid pos(int i){\n\tfor(int j=0;j<i;j++){\n\t\tret.push_back(P(j+1,0));\n\t}\n\tret.push_back(P(i,1));\n\tret.push_back(P(i+1,1));\n\tret.push_back(P(i+1,0));\n\tret.push_back(P(i,0));\n\tfor(int j=i-1;j>=0;j--){\n\t\tret.push_back(P(j,0));\n\t}\n}\nvoid neg(int i){\n\tfor(int j=0;j<i;j++){\n\t\tret.push_back(P(j+1,0));\n\t}\n\tret.push_back(P(i+1,0));\n\tret.push_back(P(i+1,1));\n\tret.push_back(P(i,1));\n\tret.push_back(P(i,0));\n\tfor(int j=i-1;j>=0;j--){\n\t\tret.push_back(P(j,0));\n\t}\n}\n\t\n\nint main(){\n\tint n;\n\tstring s;\n\tcin>>n>>s;\n\t\n\tint a[300];\n\tfor(int i=0;i<(1<<n);i++)a[i]=s[i]-'0';\n\t\n\tbool used[300];\n\tmemset(used,0,sizeof used);\n\t\n\tint b[300];\n\tfor(int i=0;i<300;i++)b[i]=1;\n\t\n\tfor(int x=1;x<(1<<n);x++){\n\t\tused[x]=true;\n\t\t//if(used[x])cerr<<x<<endl;\n\t\tfor(int y=0;y<x;y++){\n\t\t\tif((x&y)==y)if(used[y])used[x]=false;\n\t\t}\n\t\t//if(used[x])cerr<<x<<endl;\n\t\tfor(int y=0;y<(1<<n);y++){\n\t\t\tif((x&y)==x)if(a[y]==1)used[x]=false;\n\t\t}\n\t\t//if(used[x])cerr<<x<<endl;\n\t\tif(used[x]){\n\t\t\tfor(int y=0;y<(1<<n);y++){\n\t\t\t\tif((x&y)==x)b[y]=0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool ok=true;\n\tfor(int i=0;i<(1<<n);i++)ok&=a[i]==b[i];\n\tif(!ok){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tret.push_back(P(0,0));\n\tfor(int x=0;x<(1<<n);x++){\n\t\tif(!used[x])continue;\n\t\tint cnt=0;\n\t\tint c[10];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif((x>>i)&1)c[cnt++]=i;\n\t\t}\n\t\tif(cnt==1){\n\t\t\tpos(c[0]);\n\t\t}\n\t\telse if(cnt==2){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[1]);\n\t\t}\n\t\telse if(cnt==3){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[2]);\n\t\t}\n\t\telse if(cnt==4){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tneg(c[3]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[3]);\n\t\t\tpos(c[2]);\n\t\t\tneg(c[3]);\n\t\t\tneg(c[2]);\n\t\t}\n\t\telse if(cnt==5){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[1]);\n\t\t\tpos(c[4]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[4]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tneg(c[3]);\n\t\t\tpos(c[0]);\n\t\t\tpos(c[4]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[4]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tpos(c[2]);\n\t\t}\n\t\telse if(cnt==6){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[1]);\n\t\t\tpos(c[4]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[4]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tneg(c[3]);\n\t\t\tpos(c[0]);\n\t\t\tpos(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[4]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[4]);\n\t\t\tneg(c[1]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tpos(c[2]);\n\t\t}\n\t\telse if(cnt==7){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[1]);\n\t\t\tpos(c[6]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[6]);\n\t\t\tpos(c[4]);\n\t\t\tpos(c[6]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[4]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tneg(c[3]);\n\t\t\tpos(c[0]);\n\t\t\tpos(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[4]);\n\t\t\tpos(c[1]);\n\t\t\tpos(c[6]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[4]);\n\t\t\tpos(c[6]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[1]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tpos(c[2]);\n\t\t}\n\t\telse if(cnt==7){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[1]);\n\t\t\tpos(c[6]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[6]);\n\t\t\tpos(c[4]);\n\t\t\tpos(c[7]);\n\t\t\tneg(c[4]);\n\t\t\tneg(c[7]);\n\t\t\tpos(c[6]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[1]);\n\t\t\tpos(c[7]);\n\t\t\tpos(c[4]);\n\t\t\tneg(c[7]);\n\t\t\tneg(c[4]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tneg(c[3]);\n\t\t\tpos(c[0]);\n\t\t\tpos(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[4]);\n\t\t\tpos(c[7]);\n\t\t\tneg(c[4]);\n\t\t\tneg(c[7]);\n\t\t\tpos(c[1]);\n\t\t\tpos(c[6]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[6]);\n\t\t\tpos(c[7]);\n\t\t\tpos(c[4]);\n\t\t\tneg(c[7]);\n\t\t\tneg(c[4]);\n\t\t\tpos(c[6]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[1]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tpos(c[2]);\n\t\t}\n\t}\n\t\n\t/*for(int i=0;i<n;i++){\n\t\tif(used[i][i]){\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t}\n\t\t\tret.push_back(P(i,1));\n\t\t\tret.push_back(P(i+1,1));\n\t\t\tret.push_back(P(i+1,0));\n\t\t\tret.push_back(P(i,0));\n\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\tret.push_back(P(j,0));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int k=i+1;k<n;k++){\n\t\t\tif(used[i][k]){\n\t\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(i,1));\n\t\t\t\tret.push_back(P(i+1,1));\n\t\t\t\tret.push_back(P(i+1,0));\n\t\t\t\tret.push_back(P(i,0));\n\t\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(k,1));\n\t\t\t\tret.push_back(P(k+1,1));\n\t\t\t\tret.push_back(P(k+1,0));\n\t\t\t\tret.push_back(P(k,0));\n\t\t\t\tfor(int j=k-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(i+1,0));\n\t\t\t\tret.push_back(P(i+1,1));\n\t\t\t\tret.push_back(P(i,1));\n\t\t\t\tret.push_back(P(i,0));\n\t\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(k+1,0));\n\t\t\t\tret.push_back(P(k+1,1));\n\t\t\t\tret.push_back(P(k,1));\n\t\t\t\tret.push_back(P(k,0));\n\t\t\t\tfor(int j=k-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}*/\n\t\n\tputs(\"Possible\");\n\tprintf(\"%d\\n\",(int)(ret.size())-1);\n\tfor(int i=0;i<ret.size();i++){\n\t\tprintf(\"%d %d\\n\",ret[i].fr,ret[i].sc);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\n#include <assert.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\nconst int MOD=1e9+7;\n#define SZ 666666\nint n;\nchar a[SZ];\nbool v[SZ];\nvi neg(vi x)\n{\n\treverse(x.begin(),x.end());\n\tfor(auto&y:x) y=-y;\n\treturn x;\n}\nvi operator + (vi a,const vi&b)\n{\n\tfor(auto x:b) a.pb(x);\n\treturn a;\n}\nvi operator - (vi a,const vi&b)\n{\n\treturn a+neg(b);\n}\nvi cs(vi a,int l,int r)\n{\n\tif(l==r)\n\t\treturn {a[l]};\n\tint m=(l+r)>>1;\n\tvi L=cs(a,l,m),R=cs(a,m+1,r);\n\treturn L+R-L-R;\n}\nvi CL(vi t)\n{\n\treturn t;\n}\nvi v1{1},v2{2};\nvi AND(vi p,vi q)\n{\n\treturn CL(p+p+v1+p+p-v1+v2-q-v2-q+v2-q-v2-q);\n}\nint main()\n{\n\tcin>>n>>a;\n\tbool ok=1;\n\tvi g;\n\tfor(int i=0;i<(1<<n);++i) if(a[i]=='0'&&!v[i])\n\t{\n\t\tfor(int j=0;j<(1<<n);++j) if((j&i)==i)\n\t\t\tv[j]=1,ok&=a[j]=='0';\n\t\tvi t;\n\t\tfor(int j=0;j<n;++j) if(i&(1<<j)) t.pb(j+1);\n\t\tvi w=cs(t,0,t.size()-1);\n\t\tg=g+w;\n\t}\n\tif(!ok)\n\t{\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tputs(\"Possible\");\n\tvector<pii> v;\n\tv.pb(pii(0,0));\n\tfor(auto c:g)\n\t{\n\t\tint x=abs(c);\n\t\tif(c>0)\n\t\t{\n\t\t\tv.pb(pii(x-1,0));\n\t\t\tv.pb(pii(x-1,1));\n\t\t\tv.pb(pii(x,1));\n\t\t\tv.pb(pii(x,0));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tv.pb(pii(x-1,0));\n\t\t\tv.pb(pii(x,0));\n\t\t\tv.pb(pii(x,1));\n\t\t\tv.pb(pii(x-1,1));\n\t\t}\n\t}\n\tv.pb(pii(0,0));\n\tvector<pii> vt;\n\tfor(int i=0;i<v.size();++i)\n\t{\n\t\tpii A=v[i],B=v[(i+1)%v.size()];\n\t\tvt.pb(A);\n\t\tint g=abs(A.fi-B.fi)+abs(A.se-B.se);\n\t\tif(g)\n\t\t{\n\t\t\tfor(int j=1;j<=g;++j)\n\t\t\t{\n\t\t\t\tpii s(A.fi+(B.fi-A.fi)/g*j,\n\t\t\t\tA.se+(B.se-A.se)/g*j);\n\t\t\t\tvt.pb(s);\n\t\t\t}\n\t\t}\n\t}\n\tvt.erase(unique(vt.begin(),vt.end()),vt.end());\n\tv=vt;\n\tprintf(\"%d\\n\",int(v.size())-1);\n\tfor(auto c:v) printf(\"%d %d\\n\",c.fi,c.se);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<vector>\n#include<queue>\n#include<iostream>\n#include<fstream>\n#include<string>\n#include<cassert>\n#include<algorithm>\n#include<random>\n#include<map>\n#include<set>\n#include <bitset>\n#include<ctime>\n\nusing namespace std;\n\n//int mod = 998244353;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\ntypedef vector<int>vi;\ntypedef vector<ll>vl;\ntypedef vector<char>vc;\ntypedef vector<string>vs;\ntypedef vector<vector<int>>vii;\ntypedef vector<vector<char>>vvc;\ntypedef vector<vector<ll>>vll;\ntypedef vector< pair<ll, ll>>vpll;\ntypedef vector< pair<ld, ld>>vpld;\ntypedef vector< pair<int, int>>vpi;\ntypedef pair<ld, ld>pld;\n#define mp make_pair\n#define pb push_back\n\nconst int mod = 998244353;\nint add(int a, int b)\n{\n\tint c = a + b;\n\tif (c >= mod)\n\t{\n\t\tc -= mod;\n\t}\n\treturn c;\n}\nint dif(int a, int b)\n{\n\tint c = a - b;\n\tif (c < 0)\n\t{\n\t\tc += mod;\n\t}\n\treturn c;\n}\nint mlt(int a, int b)\n{\nll c = a * 1LL * b;\nreturn c % mod;\n}\nint ibit(int n, int i)\n{\n\treturn ((n >> i) & 1);\n}\nvoid outp(vii &ou)\n{\n\tfor (int i = 0; i < ou.size(); i++)\n\t{\n\t\tfor (int j = 0; j < ou[i].size(); j++)\n\t\t{\n\t\t\tcout << ou[i][j] << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n}\nint bp(int x, int y)\n{\n\tif (y == 0)\n\t{\n\t\treturn 1;\n\t}\n\tint a = 0;\n\tif (!(y % 2))\n\t{\n\t\ta = bp(x, y / 2);\n\t}\n\treturn (y % 2) ? mlt(bp(x, y - 1), x) : mlt(a, a);\n}\nint obr(int x)\n{\n\treturn bp(x, mod - 2);\n}\nconst int maxn = 2000007;\nint fact[2000007], ofact[2000007];\nvoid prec()\n{\n\tfact[0] = 1;\n\tofact[0] = 1;\n\tfor (int i = 1; i < maxn; i++)\n\t{\n\t\tfact[i] = mlt(fact[i - 1], i);\n\t}\n\t//cerr << \"sdsds\" << endl;\n\tofact[maxn - 1] = obr(fact[maxn - 1]);\n\tfor (int i = maxn - 2; i > 0; i--)\n\t{\n\t\tofact[i] = mlt(ofact[i + 1], i + 1);\n\t}\n}\nint c(int a, int b)\n{\n\tif (a == 0)return 1;\n\treturn ((a <= b) && (a >= 0)) ? mlt(fact[b], mlt(ofact[a], ofact[b - a])) : 0;\n}\nll gcd(ll x, ll y)\n{\n\t//cerr << x << y << endl;\n\tif (x == 0)return y;\n\treturn(x > y) ? gcd(y, x) : gcd(y%x, x);\n}\nint obr2(int n)\n{\n\tint x = fact[n - 1];\n\tx = mlt(x, ofact[n]);\n\treturn x;\n}\nvoid crv(int nn, vpi &v)\n{\n\tif (nn > 0) {\n\t\tint n = nn;\n\t\tfor (int i = 0; i < n; i++)v.pb({ i + 1, 0 });\n\t\tv.pb({ n,1 });\n\t\tv.pb({ n - 1, 1 });\n\t\tfor (int i = n - 1; i >= 0; i--)v.pb({ i, 0 });\n\t}\n\tif (nn < 0) {\n\t\tint n = -nn;\n\t\tfor (int i = 0; i < n-1; i++)v.pb({ i + 1, 0 });\n\t\tv.pb({ n-1,1 });\n\t\tv.pb({ n , 1 });\n\t\tfor (int i = n; i >= 0; i--)v.pb({ i, 0 });\n\t}\n}\nvoid solve(istream &cin = std::cin, ostream &cout = std::cout)\n{\n\tvii imb(8);\n\timb[0] = { 1 };\n\tfor (int i = 1; i < 8; i++)\n\t{\n\t\tfor (int j = 0; j < imb[i - 1].size(); j++)imb[i].pb(imb[i - 1][j]);\n\t\timb[i].pb(i + 1);\n\t\tfor (int j = imb[i - 1].size(); j >= 0; j--)imb[i].pb((-1)*imb[i - 1][j]);\n\t\timb[i].pb(-i - 1);\n\t}\n\t//cerr << \"here\" << endl;\n\tint n;\n\tcin >> n;\n\tvi good(1 << n);\n\tfor (int i = 0; i < good.size(); i++)\n\t{\n\t\tchar c;\n\t\tcin >> c;\n\t\tgood[i] = c - '0';\n\t}\n\tint val=0;\n//\tcerr << 433 << endl;\n\tfor(int a=0; a<good.size(); a++)\n\t\tfor(int b=0; b<good.size(); b++)\n\t\t\tif((a|b)==b)\n\t\t\t\tif ((!good[a]) && (good[b]))\n\t\t\t\t{\n\t\t\t\t//\tcerr << a << ' ' << b << endl;\n\t\t\t\t\tval = 1;\n\t\t\t\t}\n\tif (val)cout << \"Impossible\" << endl;\n\telse\n\t{\n\t\t//cerr << 1111 << endl;\n\t\tvpi ay = { {0,0} };\n\t\tfor (int m = 0; m < good.size(); m++)\n\t\t{\n\t\t\t//cerr << m << endl;\n\t\t\tif (!good[m])\n\t\t\t{\n\t\t\t\tvi v;\n\t\t\t\tfor (int i = 0; i < 8; i++)if (ibit(m, i))v.pb(i);\n\t\t\t\tfor (int i = 0; i < imb[v.size()-1].size(); i++)\n\t\t\t\t{\n\t\t\t\t//\tcerr << i << endl;\n\t\t\t\t\tif (imb[v.size()][i] > 0)crv(v[imb[v.size()-1][i] - 1], ay);\n\t\t\t\t\tif (imb[v.size()][i] < 0)crv(-v[(-imb[v.size()-1][i]) - 1], ay);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << \"Possible\" << endl;\n\t\tcout << ay.size() << endl;\n\t\tfor (int i = 0; i < ay.size(); i++)cout << ay[i].first << ' ' << ay[i].second << endl;\n\t}\n}\nint main()\n{\n\tsolve();\n\tint n;\n\tcin >> n;\n}\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1007;\n\nvoid nope()\n{\n\tprintf(\"Impossible\\n\");\n\texit(0);\n}\n\nvoid tak()\n{\n\tprintf(\"Possible\\n\");\n}\n\nint n;\nchar wcz[nax];\nint dasie[nax];\n\nvector <pii> wek;\n\nvector <pii> operator + (vector <pii> a, vector <pii> b)\n{\n\tif (a.empty())\n\t\treturn b;\n\tif (b.empty())\n\t\treturn a;\n\ta.pop_back();\n\tfor (pii i : b)\n\t\ta.push_back(i);\n\treturn a;\n}\n\nvector <pii> odw(vector <pii> a)\n{\n\treverse(a.begin(), a.end());\n\treturn a;\n}\n\nvector <pii> zdobo(int mas)\n{\n\tif (!mas)\n\t\treturn {{0, 0}};\n\tint x=__builtin_ctz(mas);\n\tvector <pii> ret;\n\tret.push_back({0, 0});\n\tfor (int i=0; i<=x; i++)\n\t\tret.push_back({i, 1});\n\tret.push_back({x, 0});\n\tret.push_back({x+1, 0});\n\tfor (int i=x+1; i>=0; i--)\n\t\tret.push_back({i, 1});\n\tret.push_back({0, 0});\n\tauto wez=zdobo(mas^(1<<x));\n\treturn wez+ret+odw(wez);\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", wcz);\n\tfor (int i=0; i<(1<<n); i++)\n\t\tdasie[i]=wcz[i]-'0';\n\tfor (int i=0; i<(1<<n); i++)\n\t{\n\t\tfor (int j=0; j<(1<<n); j++)\n\t\t{\n\t\t\tif ((i&j)==i && dasie[j] && !dasie[i])\n\t\t\t{\n\t\t\t\tnope();\n\t\t\t}\n\t\t}\n\t}\n\ttak();\n\twek={{0, 0}};\n\tfor (int i=0; i<(1<<n); i++)\n\t{\n\t\tif (dasie[i])\n\t\t\tcontinue;\n\t\tauto x=zdobo(i);\n\t\twek=wek+x;\n\t}\n\twek.push_back({0, 0});\n\tprintf(\"%d\\n0 0\\n\", (int)wek.size());\n\tfor (pii i : wek)\n\t\tprintf(\"%d %d\\n\", i.first, i.second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n#define MOD 1000000007\n#define f(i,n) for(int i=0;i<(int)(n);i++)\n#define N 200010\n\nvector<int>b[8];\nvector<int>ax;\nvector<int>ay;\n\n\nint main() {\n\tchar a[N];\n\tf(i, N)a[i] = 0;\n\tint c[10];\n\tint n, k;\n\tint x, y, z;\n\tint s, ans;\n\tbool v = true;\n\tans = 0;\n\tb[0].push_back(1);\n\tf(i, 7) {\n\t\tf(j, b[i].size()) {\n\t\t\tb[i + 1].push_back(b[i][j]);\n\t\t}\n\t\tb[i + 1].push_back(i + 2);\n\t\tfor(int j=b[i].size()-1;j>=0;j--){\n\t\t\tb[i + 1].push_back(-b[i][j]);\n\t\t}\n\t\tb[i + 1].push_back(-(i + 2));\n\t}\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", a);\n\tk = strlen(a);\n\tif (a[0] == '0') {\n\t\tprintf(\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\tx = 1;\n\tax.push_back(0);\n\tay.push_back(0);\n\tf(i, k) {\n\t\tf(j, i) {\n\t\t\tif ((i&j) == j) {\n\t\t\t\tif ((a[i] == '1') && (a[j] == '0')) {\n\t\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tf(i, n) {\n\t\tf(j, x) {\n\t\t\tif (a[j] == '1') {\n\t\t\t\tif (a[x + j] == '0') {\n\t\t\t\t\ty = 1;\n\t\t\t\t\tz = x + j;\n\t\t\t\t\tf(ii, n) {\n\t\t\t\t\t\tif (z % 2 == 1) {\n\t\t\t\t\t\t\tc[y] = ii + 1;\n\t\t\t\t\t\t\ty++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tz /= 2;\n\t\t\t\t\t}\n\t\t\t\t\ty -= 2;\n\t\t\t\t\tf(ii, b[y].size()) {\n\t\t\t\t\t\tif (b[y][ii] > 0) {\n\t\t\t\t\t\t\tfor (int j = 1; j <= c[b[y][ii]] - 1; j++) {\n\t\t\t\t\t\t\t\tax.push_back(j);\n\t\t\t\t\t\t\t\tay.push_back(0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tax.push_back(c[b[y][ii]]);\n\t\t\t\t\t\t\tay.push_back(0);\n\t\t\t\t\t\t\tax.push_back(c[b[y][ii]]);\n\t\t\t\t\t\t\tay.push_back(1);\n\t\t\t\t\t\t\tax.push_back(c[b[y][ii]]-1);\n\t\t\t\t\t\t\tay.push_back(1);\n\t\t\t\t\t\t\tfor (int j = c[b[y][ii]] - 1; j >= 0; j--) {\n\t\t\t\t\t\t\t\tax.push_back(j);\n\t\t\t\t\t\t\t\tay.push_back(0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tfor (int j = 1; j <= c[-b[y][ii]] - 1; j++) {\n\t\t\t\t\t\t\t\tax.push_back(j);\n\t\t\t\t\t\t\t\tay.push_back(0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tax.push_back(c[-b[y][ii]] - 1);\n\t\t\t\t\t\t\tay.push_back(1);\n\t\t\t\t\t\t\tax.push_back(c[-b[y][ii]]);\n\t\t\t\t\t\t\tay.push_back(1);\n\t\t\t\t\t\t\tax.push_back(c[-b[y][ii]]);\n\t\t\t\t\t\t\tay.push_back(0);\n\t\t\t\t\t\t\tfor (int j = c[-b[y][ii]] - 1; j >= 0; j--) {\n\t\t\t\t\t\t\t\tax.push_back(j);\n\t\t\t\t\t\t\t\tay.push_back(0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (a[x + j] == '1') {\n\t\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tx *= 2;\n\t}\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d\\n\", ax.size() - 1);\n\tf(i, ax.size()) {\n\t\tprintf(\"%d %d\\n\", ax[i], ay[i]);\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nint n;\nchar s[1010];\nvector<PII> ans,c,trash;\nvector<PII> build(VI w) {\n  if (SZ(w)==1) return vector<PII>{{w[0],0}};\n  vector<PII> z{{w[0],0},{w[1],0},{w[0],1},{w[1],1}};\n  rep(i,2,SZ(w)) {\n    vector<PII> nz=z; \n    z.pb({w[i],0});\n    reverse(all(nz));\n    for (auto p:nz) z.pb({p.fi,p.se^1});\n    z.pb({w[i],-1});\n  }\n  return z;\n}\nint zz;\nint main() {\n  scanf(\"%d\",&n);\n  scanf(\"%s\",s);\n  //rep(i,0,(1<<n)) s[i]=(__builtin_popcount(i)<5)+'0';\n  rep(i,0,(1<<n)) if (s[i]=='0') {\n    rep(j,0,(1<<n)) if ((j&i)==i&&s[j]=='1') {\n      puts(\"Impossible\");\n      return 0;\n    }\n    bool cc=0;\n    rep(j,0,(1<<n)) if ((i&j)==j&&i!=j&&s[j]=='0') cc=1;\n    if (cc) continue;\n    VI w;\n    rep(j,0,n) if (i&(1<<j)) w.pb(j);\n    auto x=build(w);\n    for (auto p:x) ans.pb(p);\n    zz++;\n    rep(i,0,n) ans.pb(mp(i,0)),trash.pb(mp(i,0));\n    rep(i,0,50) {\n      int x=rnd(n);\n      ans.pb(mp(x,0)),trash.pb(mp(x,0));\n    }\n  }\n  //fprintf(stderr,\"%d\\n\",zz);\n  reverse(all(trash));\n  for (auto p:trash) ans.pb(mp(p.fi,1));\n // rep(i,0,zz) per(j,0,n) ans.pb(mp(j,-1));\n  puts(\"Possible\");\n  int pos=0;\n  c.pb(mp(0,0));\n  for (auto p:ans) {\n    //printf(\"pp %d %d\\n\",p.fi,p.se);\n    if (p.se==0) {\n      while (pos<p.fi) {\n        pos+=1;\n        c.pb(mp(pos,0));\n      }\n      while (pos>p.fi) {\n        pos-=1;\n        c.pb(mp(pos,0));\n      }\n      c.pb(mp(pos,1));\n      c.pb(mp(pos+1,1));\n      c.pb(mp(pos+1,0));\n      pos+=1;\n    } else {\n      while (pos<p.fi+1) {\n        pos+=1;\n        c.pb(mp(pos,0));\n      }\n      while (pos>p.fi+1) {\n        pos-=1;\n        c.pb(mp(pos,0));\n      }\n      c.pb(mp(pos,1));\n      c.pb(mp(pos-1,1));\n      c.pb(mp(pos-1,0));\n      pos-=1;\n    }\n  }\n  while (pos>0) {\n    pos--;\n    c.pb(mp(pos,0));\n  }\n  printf(\"%d\\n\",SZ(c)-1);\n  for (auto x:c) printf(\"%d %d\\n\",x.fi,x.se);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> rec(int x) {\n\tvector <int> sol;\n\tint pet = 0, bit;\n\tfor (bit = 0; (x&pet) == 0; bit++)\n\t\tpet = 1<<bit;\n\tif (pet == x) {\n\t\tsol.push_back(bit);\n\t\treturn sol;\n\t}\n\tvector<int> aux = sol  = rec(x^pet);\n\tsol.push_back(bit);\n\tfor (auto it = aux.rbegin(); it != aux.rend(); it++)\n\t\tsol.push_back(-*it);\n\tsol.push_back(-bit);\n\treturn sol;\n}\n\nstring tira(const vector<int> & par) {\n\tstring sol;\n\tfor (int x: par) {\n\t\tsol += string(abs(x),'R');\n\t\tif (x > 0) sol += \"URDL\";\n\t\telse sol += \"RULD\";\n\t\tsol += string(abs(x),'L');\n\t}\n\treturn sol;\n}\n\n\nint main() {\n  ios_base::sync_with_stdio(false); \n  cin.tie(nullptr); \n\n\tint n;\n\tcin >> n;\n\tstring s;\n\tcin >> s;\n\tint m = 1<<n;\n\tbool ok = true;\n\tvector<int> obs;\n\tfor (int i = 1; i < m; i++) {\n\t\tif (s[i] == '0') obs.push_back(i);\n\t\tfor (int j = i+1; j < m; j++) {\n\t\t\tint p = i, g = j;\n\t\t\tif (p > g) swap(p, g);\n\t\t\tif ((p&g) == p and s[p] == '1' and s[g] == '0') ok = false;\n\t\t}\n\t}\n\tif (!ok) cout << \"Impossible\" << endl;\n\telse {\n\t\tcout << \"Possible\" << endl;\n\t\tstring sol;\n\t\tfor (auto x: obs) \n\t\t\tsol += tira(rec(x));\n\t\tint k = sol.size();\n\t\tcout << k +1  << endl;\n\t\tint px = 0, py = 0; \n\t\tcout << px << \" \" << py << \"\\n\";\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tif (sol[i] == 'U') py++;\n\t\t\telse if (sol[i] == 'D') py--;\n\t\t\telse if (sol[i] == 'L') px--;\n\t\t\telse if (sol[i] == 'R') px++;\n\t\t\tcout << px << \" \" << py << \"\\n\";\n\t\t}\n\t}\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#define NO return !printf(\"Impossible\\n\")\n#define N 433\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint n,a[N];\nchar s[N];\nvector<pair<int,int> > ans;\nstring Rev(string s){\n\treverse(s.begin(),s.end());\n\treturn s;\n}\nint main(){\n\tn=read();\n\tscanf(\"%s\",s);\n\tfor(int i=0;i<(1<<n);++i){\n\t\ta[i]=s[i]-'0';\n\t}\n\tif(!a[0])NO;\n\tfor(int i=0;i<(1<<n);++i){\n\t\tif(a[i]){\n\t\t\tfor(int j=(i-1)&i;j;j=(j-1)&i){\n\t\t\t\tif(!a[j])NO;\n\t\t\t}\n\t\t}\n\t}\n\tans.emplace_back(0,0);\n\tfor(int i=0;i<(1<<n);++i){\n\t\tif(a[i])continue;\n\t\tbool ok=true;\n\t\tfor(int j=(i-1)&i;j;j=(j-1)&i){\n\t\t\tif(a[j]){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok)continue;\n\t\tstring myh;\n\t\tfor(int j=0;j<n;++j){\n\t\t\tif((i>>j)&1){\n\t\t\t\tif(myh.empty())myh+=(char)('a'+j),myh+=(char)('A'+j);\n\t\t\t\telse myh=(char)('a'+j)+myh+(char)('a'+j),myh+=(char)('A'+j)+Rev(myh)+(char)('A'+j);\n\t\t\t}\n\t\t}\n\t\tint pos=0,t=0;\n\t\tfor(auto c:myh){\n\t\t\tint d=0,x=0;\n\t\t\tif(c>='a'&&c<='z'){\n\t\t\t\tx=c-'a',d=1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tx=c-'A',d=0;\n\t\t\t}\n\t\t\twhile(pos<x)ans.emplace_back(++pos,t);\n\t\t\twhile(pos>x+1)ans.emplace_back(--pos,t);\n\t\t\tif(t^d)ans.emplace_back(pos,t=d);\n\t\t\tif(pos==x)ans.emplace_back(++pos,d);\n\t\t\telse ans.emplace_back(--pos,d);\n\t\t}\n\t\tif(t)ans.emplace_back(pos,0);\n\t\twhile(pos>0)ans.emplace_back(--pos,0);\n\t}\n\tprintf(\"Possible\\n%d\\n\",(int)ans.size()-1);\n\tfor(auto x:ans){\n\t\tprintf(\"%d %d\\n\",x.first,x.second);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,L;\nstring A;\nint ismin[256];\n\n\nvector<pair<int,int>> construct(int mask) {\n\tvector<pair<int,int>> V;\n\t\n\tint i;\n\tFOR(i,N) if(mask&(1<<i)) {\n\t\tif(__builtin_popcount(mask)==1) {\n\t\t\tV.push_back({i,1});\n\t\t\tV.push_back({i+1,1});\n\t\t\tV.push_back({i+1,0});\n\t\t\tV.push_back({i,0});\n\t\t}\n\t\telse {\n\t\t\tvector<pair<int,int>> W=construct(mask^(1<<i));\n\t\t\tV.push_back({i,1});\n\t\t\twhile(V.back().first+1<W[0].first) {\n\t\t\t\tV.push_back(V.back());\n\t\t\t\tV.back().first++;\n\t\t\t}\n\t\t\tFORR(w,W) V.push_back(w);\n\t\t\tV.push_back(W.back());\n\t\t\tV.back().second=1;\n\t\t\twhile(V.back().first>i) {\n\t\t\t\tV.push_back(V.back());\n\t\t\t\tV.back().first--;\n\t\t\t}\n\t\t\tV.push_back({i,0});\n\t\t\tV.push_back({i,1});\n\t\t\treverse(ALL(W));\n\t\t\twhile(V.back().first+1<W[0].first) {\n\t\t\t\tV.push_back(V.back());\n\t\t\t\tV.back().first++;\n\t\t\t}\n\t\t\t\n\t\t\tFORR(w,W) V.push_back(w);\n\t\t\twhile(V.back().first>i+1) {\n\t\t\t\tV.push_back(V.back());\n\t\t\t\tV.back().first--;\n\t\t\t}\n\t\t\tV.push_back({i+1,0});\n\t\t\tV.push_back({i,0});\n\t\t}\n\t\tbreak;\n\t}\n\treturn V;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>A;\n\tL=1<<N;\n\tFORR(c,A) c-='0';\n\tFOR(x,L) FOR(y,L) if((x&y)==y && A[x] && A[y]==0) return _P(\"Impossible\\n\");\n\tFOR(x,L) ismin[x]=A[x]==0;\n\tFOR(x,L) if(A[x]==0) FOR(y,L) if((x&y)==y && y<x && A[y]==0) ismin[y]=0;\n\t\n\tvector<pair<int,int>> W;\n\tW.push_back({0,0});\n\tFOR(x,L) if(A[x]==0) {\n\t\tvector<pair<int,int>> V=construct(x);\n\t\tFOR(i,V[0].first) W.push_back({i,1});\n\t\tFORR(v,V) W.push_back(v);\n\t\tfor(i=V[0].first;i>=0;i--) W.push_back({i,1});\n\t\tW.push_back({0,0});\n\t}\n\tcout<<\"Possible\"<<endl;\n\tcout<<W.size()-1<<endl;\n\tFORR(w,W) cout<<w.first<<\" \"<<w.second<<endl;\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\n#include <assert.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\nconst int MOD=1e9+7;\n#define SZ 666666\nint n;\nchar a[SZ];\nbool v[SZ];\nvi neg(vi x)\n{\n\treverse(x.begin(),x.end());\n\tfor(auto&y:x) y=-y;\n\treturn x;\n}\nvi operator + (vi a,const vi&b)\n{\n\tfor(auto x:b) a.pb(x);\n\treturn a;\n}\nvi operator - (vi a,const vi&b)\n{\n\treturn a+neg(b);\n}\nvi cs(vi a,int l,int r)\n{\n\tif(l==r)\n\t\treturn {a[l]};\n\tint m=(l+r)>>1;\n\tvi L=cs(a,l,m),R=cs(a,m+1,r);\n\treturn L+R-L-R;\n}\nvi CL(vi t)\n{\n\treturn t;\n}\nvi v1{1},v2{2};\nvi AND(vi p,vi q)\n{\n\treturn CL(p+p+v1+p+p-v1+v2-q-v2-q+v2-q-v2-q);\n}\nint main()\n{\n\tcin>>n>>a;\n\tbool ok=1;\n\tvi g;\n\tfor(int i=0;i<(1<<n);++i) if(a[i]=='0'&&!v[i])\n\t{\n\t\tfor(int j=0;j<(1<<n);++j) if((j&i)==i)\n\t\t\tv[j]=1,ok&=a[j]=='0';\n\t\tvi t;\n\t\tfor(int j=0;j<n;++j) if(i&(1<<j)) t.pb(j+1);\n\t\tvi w=cs(t,0,t.size()-1);\n\t\tif(g.size()) g=AND(g,w);\n\t\telse g=w;\n\t}\n\tif(!ok)\n\t{\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tputs(\"Possible\");\n\tvector<pii> v;\n\tv.pb(pii(0,0));\n\tfor(auto c:g)\n\t{\n\t\tint x=abs(c);\n\t\tif(c>0)\n\t\t{\n\t\t\tv.pb(pii(x-1,0));\n\t\t\tv.pb(pii(x-1,1));\n\t\t\tv.pb(pii(x,1));\n\t\t\tv.pb(pii(x,0));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tv.pb(pii(x,0));\n\t\t\tv.pb(pii(x,1));\n\t\t\tv.pb(pii(x-1,1));\n\t\t\tv.pb(pii(x-1,0));\n\t\t}\n\t}\n\tv.pb(pii(0,0));\n\tvector<pii> vt;\n\tfor(int i=0;i<v.size();++i)\n\t{\n\t\tpii A=v[i],B=v[(i+1)%v.size()];\n\t\tvt.pb(A);\n\t\tint g=abs(A.fi-B.fi)+abs(A.se-B.se);\n\t\tif(g)\n\t\t{\n\t\t\tfor(int j=1;j<=g;++j)\n\t\t\t{\n\t\t\t\tpii s(A.fi+(B.fi-A.fi)/g*j,\n\t\t\t\tA.se+(B.se-A.se)/g*j);\n\t\t\t\tvt.pb(s);\n\t\t\t}\n\t\t}\n\t}\n\tvt.erase(unique(vt.begin(),vt.end()),vt.end());\n\tv=vt;\n\tprintf(\"%d\\n\",int(v.size())-1);\n\tfor(auto c:v) printf(\"%d %d\\n\",c.fi,c.se);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=8;\n\nstruct point{\n  int x,y;\n  point(int X=0,int Y=0){x=X;y=Y;}\n};\n\nint n;\nchar a[(1<<N)+9];\n\nvoid into(){\n  scanf(\"%d%s\",&n,a);\n}\n\nbool Check_a(){\n  for (int u=1;u<1<<n;++u){\n\tif (a[u]=='0') continue;\n\tfor (int v=u-1&u;v;v=v-1&u)\n\t  if (a[v]=='0') return 0;\n  }\n  return 1;\n}\n\nvector<point>Dfs_ans(int s,int last){\n  int p=0;\n  for (;s>>p&1^1;++p);\n  vector<point>res;\n  if (s==1<<p){\n\tfor (int i=last;i<p;++i) res.push_back(point(i,1));\n\tres.push_back(point(p,1));\n\tres.push_back(point(p,0));\n\tfor (int i=p-1;i>=last;--i) res.push_back(point(i,1));\n\treturn res;\n  }\n  vector<point>t=Dfs_ans(s^1<<p,p+1);\n  for (int i=last;i<p;++i) res.push_back(point(i,1));\n  res.push_back(point(p,1));\n  for (int vs=t.size(),i=0;i<vs;++i) res.push_back(t[i]);\n  res.push_back(point(p,1));\n  res.push_back(point(p,0));\n  for (int vs=t.size(),i=vs-1;i>=0;--i) res.push_back(t[i]);\n  res.push_back(point(p,0));\n  for (int i=p-1;i>=last;--i) res.push_back(point(i,1));\n  return res;\n}\n\nint ans0;\nvector<point>ans;\n\nvoid Get_ans(){\n  if (!(ans0=Check_a())) return;\n  vector<point>tmp;\n  for (int u=1;u<1<<n;++u){\n\tif (a[u]=='1') continue;\n\tint flag=1;\n\tfor (int v=u-1&u;v;v=v-1&u)\n      if (a[v]=='0') {flag=0;break;}\n    if (!flag) continue;\n\tvector<point>t=Dfs_ans(u,0);\n\tfor (int vs=t.size(),i=0;i<vs;++i) tmp.push_back(t[i]);\n  }\n  int x=0,y=0;\n  ans.push_back(point(0,0));\n  for (int vs=tmp.size(),i=0;i<vs;++i){\n\tif (y^tmp[i].y) ans.push_back(point(x,y=tmp[i].y));\n\tans.push_back(point(x==tmp[i].x?++x:--x,y));\n  }\n  if (y) ans.push_back(point(x,y=0));\n}\n\nvoid work(){\n  Get_ans();\n}\n\nvoid outo(){\n  puts(ans0?\"Possible\":\"Impossible\");\n  if (!ans0) return;\n  int vs=ans.size();\n  printf(\"%d\\n\",vs-1);\n  for (int i=0;i<vs;++i)\n\tprintf(\"%d %d\\n\",ans[i].x,ans[i].y);\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(),x.end()\n#define cmin(a,b) (a>b?a=b:a)\n#define cmax(a,b) (a<b?a=b:a)\n#define mem(a,k) memset(a,k,sizeof(a))\n#define lop(i,s,t) for(int i=s;i<(t);++i)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define fore(i,v) for(int i=g[v],d=es[i].d;i;i=es[i].nxt,d=es[i].d)\nusing namespace std;\n\n#ifdef CURIOUSCAT\n#define Pr(f,...) fprintf(stderr,f,##__VA_ARGS__),fflush(stderr)\n#else\n#define Pr(f,...) ;\n#endif\n\ntypedef long long ll;\n\ntemplate<typename T>\nvoid read(T &x){\n\tx=0; \n\tchar c;\n\tfor(c=getchar();!isdigit(c);c=getchar()); \n\tfor(;isdigit(c);c=getchar())x=x*10+c-'0'; \n}\n\nconst int N=1e6+50;\n\nint P;\nint mul(int a,int b){ return 1ll*a*b%P; }\n//int add(int a,int b){ a+=b; return a>=P?a-P:a; }\nvoid upd(int &a,int b) { a=a+b>=P?a+b-P:a+b; }\nint sub(int a,int b){ a-=b; return a<0?a+P:a; }\nint gcd(int a,int b){ return !b?a:gcd(b,a%b); }\n\n\nint n; string s; vector<pair<int,int>> ans;\nvoid add(int msk,int inv){\n\tPr(\"add %d,%d\\n\",msk,inv); \n\tint lsb=msk&-msk;\n\tif(lsb==msk){\n\t\tint x=31-__builtin_clz(msk); \n\t\tPr(\"x=%d\\n\",x);\n\t\trep(i,0,x)ans.eb(i,0); \n\t\tPr(\"ans.size()=%d\\n\",(int)ans.size()); \n\t\tif(inv){\n\t\t\tans.eb(x,1);\n\t\t\tans.eb(x+1,1);\n\t\t\tans.eb(x+1,0);\n\t\t}else{\n\t\t\tans.eb(x+1,0);\n\t\t\tans.eb(x+1,1); \n\t\t\tans.eb(x,1); \n\t\t}\n\t\tdec(i,x,1)ans.eb(i,0);\n\t}else{\n\t\tif(!inv){\n\t\t\tadd(msk^lsb,0);\n\t\t\tadd(lsb,0);\n\t\t\tadd(msk^lsb,1);\n\t\t\tadd(lsb,1);\n\t\t}else{\n\t\t\tadd(lsb,0); \n\t\t\tadd(msk^lsb,0);\n\t\t\tadd(lsb,1);\n\t\t\tadd(msk^lsb,1); \n\t\t}\n\t}\n}\nint main(int argc,char *argv[]){\n#ifdef CURIOUSCAT\n#endif\n\tcin>>n>>s; \n\tlop(i,0,(1<<n))lop(j,0,n)if(i>>j&1&&s[i]=='1'&&s[i^1<<j]=='0'){\n\t\tcout<<\"Impossible\"<<endl; \n\t\treturn 0; \n\t}\n\tcout<<\"Possible\"<<endl;\n\n\tlop(i,0,1<<n)if(s[i]=='0')add(i,0); \n\tans.eb(0,0); \n\tcout<<(int)ans.size()-1<<endl;\n\tfor(auto x:ans)cout<<x.fi<<\" \"<<x.sc<<endl;\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing ll = long long;\nusing ull = unsigned long long;\nusing namespace std;\nconst int INF = 1e10;\nconst int MOD = 1e9 + 7;\n#define dump(x)                             \\\n    if (dbg) {                              \\\n        cerr << #x << \" = \" << (x) << endl; \\\n    }\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define FOR1(n) for (ll i = 0; i < (n); ++i)\n#define FOR2(i, n) for (ll i = 0; i < (n); ++i)\n#define FOR3(i, a, b) for (ll i = (a); i < (b); ++i)\n#define FOR4(i, a, b, c) for (ll i = (a); i < (b); i += (c))\n#define FOR(...) overload4(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)\n#define FORR(i, a, b) for (int i = (a); i <= (b); ++i)\n#define bit(n, k) ((n >> k) & 1) /*nのk bit目*/\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\nvoid Yes(bool flag = true) {\n    if (flag)\n        cout << \"Yes\" << endl;\n    else\n        cout << \"No\" << endl;\n}\nvoid No(bool flag = true) {\n    Yes(!flag);\n}\nvoid YES(bool flag = true) {\n    if (flag)\n        cout << \"YES\" << endl;\n    else\n        cout << \"NO\" << endl;\n}\nvoid NO(bool flag = true) {\n    YES(!flag);\n}\n#define pb emplace_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define all(v) (v).begin(), (v).end()\n#define SZ(x) ((int)(x).size())\n#define P pair<int, int>\n//#define V vector<int>\n//#define S set<int>\n#define itn int\nbool dbg = false;\n\nint N;\nstring A;\nbool checked[1010];\nbool out[1010];\n\nvector<int> x, y;\n\nvoid go(int gx) {\n    int sx;\n    int ys;\n    sx = x[(int)x.size() - 1];\n    ys = y[(int)y.size() - 1];\n    if (sx > gx) {\n        while (sx != gx) {\n            sx--;\n            x.pb(sx);\n            y.pb(ys);\n        }\n    } else if (sx < gx) {\n        while (sx != gx) {\n            sx++;\n            x.pb(sx);\n            y.pb(ys);\n        }\n    }\n}\nvoid chy() {\n    x.pb(x[(int)x.size() - 1]);\n    y.pb(!y[(int)y.size() - 1]);\n}\n\nvoid fill(int T) {\n    int cnt = __builtin_popcount(T);\n    if (cnt == 1) {\n        int nxt = __builtin_ffs(T) - 1;\n        go(nxt);\n        chy();\n        go(nxt + 1);\n        chy();\n        go(nxt);\n        chy();\n        go(nxt + 1);\n        chy();\n        go(nxt);\n        chy();\n        go(nxt + 1);\n        chy();\n        go(nxt);\n        return;\n    } else {\n        int n1 = __builtin_ffs(T) - 1;\n        T -= (1 << n1);\n        int n2 = __builtin_ffs(T) - 1;\n        int n3 = n2;\n        FOR(N) {\n            if ((1 << i) & T) {\n                n3 = i;\n            }\n        }\n        n3++;\n\n        FOR(iugy, 1) {\n            go(n1);\n            chy();\n            go(n3);\n            chy();\n            go(n2);\n            //ここで再帰\n            if (n2 + 1 != n3) {\n                fill(T);\n            }\n\n\n            chy();\n            go(n1);\n            chy();\n            go(n3);\n            chy();\n            go(n2);\n            chy();\n            go(n1);\n        }\n    }\n}\n\n\nvoid solve() {\n    bool flag = true;\n    int tmp = -1;\n    for (int T = 1; T < (1 << N); T++) {\n        if (A[T] == 1) {\n            continue;\n        }\n        if (checked[T]) {\n            continue;\n        }\n        out[T] = true;\n        if (__builtin_popcount(T) == 1) {\n            tmp = T;\n        }\n        for (int i = T; i < (1 << N); i = (i + 1) | T) {\n            // ここに処理を書く\n            if (A[i] == 1) {\n                flag = false;\n            }\n            checked[i] = true;\n        }\n    }\n    if (!flag) {\n        cout << \"Impossible\" << endl;\n        return;\n    }\n    cout << \"Possible\" << endl;\n\n    x.pb(0);\n    y.pb(0);\n\n    for (int T = 1; T < (1 << N); T++) {\n        if (out[T]) {\n            fill(T);\n        }\n    }\n    go(0);\n    int L = x.size();\n    cout << L - 1 << endl;\n\n    FOR(L) {\n        cout << x[i] << \" \" << y[i] << endl;\n    }\n}\n\nsigned main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cin >> N;\n    cin >> A;\n    for (auto& c : A)\n        c -= '0';\n\n\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#ifndef AT_HOME\n#define getchar() IO::myGetchar()\n#define putchar(x) IO::myPutchar(x)\n#endif\n\nnamespace IO {\n\tstatic const int IN_BUF = 1 << 23, OUT_BUF = 1 << 23;\n\n\tinline char myGetchar() {\n\t\tstatic char buf[IN_BUF], *ps = buf, *pt = buf;\n\t\tif (ps == pt) {\n\t\t\tps = buf, pt = buf + fread(buf, 1, IN_BUF, stdin);\n\t\t}\n\t\treturn ps == pt ? EOF : *ps++;\n\t}\n\n\ttemplate<typename T>\n\tinline bool read(T &x) {\n\t\tbool op = 0;\n\t\tchar ch = getchar();\n\t\tx = 0;\n\t\tfor (; !isdigit(ch) && ch != EOF; ch = getchar()) {\n\t\t\top ^= (ch == '-');\n\t\t}\n\t\tif (ch == EOF) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (; isdigit(ch); ch = getchar()) {\n\t\t\tx = x * 10 + (ch ^ '0');\n\t\t}\n\t\tif (op) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn true;\n\t}\n\n\tinline int readStr(char *s) {\n\t\tint n = 0;\n\t\tchar ch = getchar();\n\t\tfor (; isspace(ch) && ch != EOF; ch = getchar())\n\t\t\t;\n\t\tfor (; !isspace(ch) && ch != EOF; ch = getchar()) {\n\t\t\ts[n++] = ch;\n\t\t}\n\t\ts[n] = '\\0';\n\t\treturn n;\n\t}\n\n\tinline void myPutchar(char x) {\n\t\tstatic char pbuf[OUT_BUF], *pp = pbuf;\n\t\tstruct _flusher {\n\t\t\t~_flusher() {\n\t\t\t\tfwrite(pbuf, 1, pp - pbuf, stdout);\n\t\t\t}\n\t\t};\n\t\tstatic _flusher outputFlusher;\n\t\tif (pp == pbuf + OUT_BUF) {\n\t\t\tfwrite(pbuf, 1, OUT_BUF, stdout);\n\t\t\tpp = pbuf;\n\t\t}\n\t\t*pp++ = x;\n\t}\n\n\ttemplate<typename T>\n\tinline void print_(T x) {\n\t\tif (x == 0) {\n\t\t\tputchar('0');\n\t\t\treturn;\n\t\t}\n\t\tstatic int num[40];\n\t\tif (x < 0) {\n\t\t\tputchar('-');\n\t\t\tx = -x;\n\t\t}\n\t\tfor (*num = 0; x; x /= 10) {\n\t\t\tnum[++*num] = x % 10;\n\t\t}\n\t\twhile (*num){\n\t\t\tputchar(num[*num] ^ '0');\n\t\t\t--*num;\n\t\t}\n\t}\n\n\ttemplate<typename T>\n\tinline void print(T x, char ch = '\\n') {\n\t\tprint_(x);\n\t\tputchar(ch);\n\t}\n\n\tinline void printStr_(const char *s, int n = -1) {\n\t\tif (n == -1) {\n\t\t\tn = strlen(s);\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tputchar(s[i]);\n\t\t}\n\t}\n\n\tinline void printStr(const char *s, int n = -1, char ch = '\\n') {\n\t\tprintStr_(s, n);\n\t\tputchar(ch);\n\t}\n}\nusing namespace IO;\n\nconst int N = 8;\n\nint n;\nchar a[1 << N | 5];\n\nstd::vector<std::pair<int, int>> get(int S, int lst) {\n\tint k = 0;\n\twhile (!(S >> k & 1)) {\n\t\t++k;\n\t}\n\tstd::vector<std::pair<int, int>> res;\n\tif (S == (1 << k)) {\n\t\tfor (int i = lst; i < k; ++i) {\n\t\t\tres.push_back({i, 1});\n\t\t}\n\t\tres.push_back({k, 1});\n\t\tres.push_back({k, 0});\n\t\tfor (int i = k - 1; i >= lst; --i) {\n\t\t\tres.push_back({i, 1});\n\t\t}\n\t\treturn res;\n\t}\n\tstd::vector<std::pair<int, int>> t = get(S ^ (1 << k), k + 1);\n\tfor (int i = lst; i < k; ++i) {\n\t\tres.push_back({i, 1});\n\t}\n\tres.push_back({k, 1});\n\tfor (auto i : t) {\n\t\tres.push_back(i);\n\t}\n\tres.push_back({k, 1});\n\tres.push_back({k, 0});\n\tstd::reverse(t.begin(), t.end());\n\tfor (auto i : t) {\n\t\tres.push_back(i);\n\t}\n\tres.push_back({k, 0});\n\tfor (int i = k - 1; i >= lst; --i) {\n\t\tres.push_back({i, 1});\n\t}\n\treturn res;\n}\n\nvoid solve() {\n\tread(n);\n\treadStr(a);\n\tfor (int i = 1; i < (1 << n); ++i) {\n\t\tif (a[i] == '1') {\n\t\t\tfor (int j = i; j; j = (j - 1) & i) {\n\t\t\t\tif (a[j] == '0') {\n\t\t\t\t\tprintStr(\"Impossible\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstd::vector<std::pair<int, int>> res;\n\tfor (int i = 1; i < (1 << n); ++i) {\n\t\tif (a[i] == '0') {\n\t\t\tbool flag = 1;\n\t\t\tfor (int j = i; j; j = (j - 1) & i) {\n\t\t\t\tif (i != j && a[j] == '0') {\n\t\t\t\t\tflag = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstd::vector<std::pair<int, int>> t(get(i, 0));\n\t\t\tfor (auto v : t) {\n\t\t\t\tres.push_back(v);\n\t\t\t}\n\t\t}\n\t}\n\tint x = 0, y = 0;\n\tstd::vector<std::pair<int, int>> ans(1, {0, 0});\n\tfor (auto v : res) {\n\t\tif (y != v.second) {\n\t\t\ty = v.second;\n\t\t\tans.push_back({x, y});\n\t\t}\n\t\tif (x == v.first) {\n\t\t\t++x;\n\t\t} else {\n\t\t\t--x;\n\t\t}\n\t\tans.push_back({x, y});\n\t}\n\tif (y) {\n\t\ty = 0;\n\t\tans.push_back({x, y});\n\t}\n\tprintStr(\"Possible\");\n\tprint((int)ans.size() - 1);\n\tfor (auto v : ans) {\n\t\tprint(v.first, ' '), print(v.second);\n\t}\n}\n\nint main() {\n\tint T = 1;\n\t// read(T);\n\twhile (T--) {\n\t\tsolve();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#ifndef AT_HOME\n#define getchar() IO::myGetchar()\n#define putchar(x) IO::myPutchar(x)\n#endif\n\nnamespace IO {\n\tstatic const int IN_BUF = 1 << 23, OUT_BUF = 1 << 23;\n\n\tinline char myGetchar() {\n\t\tstatic char buf[IN_BUF], *ps = buf, *pt = buf;\n\t\tif (ps == pt) {\n\t\t\tps = buf, pt = buf + fread(buf, 1, IN_BUF, stdin);\n\t\t}\n\t\treturn ps == pt ? EOF : *ps++;\n\t}\n\n\ttemplate<typename T>\n\tinline bool read(T &x) {\n\t\tbool op = 0;\n\t\tchar ch = getchar();\n\t\tx = 0;\n\t\tfor (; !isdigit(ch) && ch != EOF; ch = getchar()) {\n\t\t\top ^= (ch == '-');\n\t\t}\n\t\tif (ch == EOF) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (; isdigit(ch); ch = getchar()) {\n\t\t\tx = x * 10 + (ch ^ '0');\n\t\t}\n\t\tif (op) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn true;\n\t}\n\n\tinline int readStr(char *s) {\n\t\tint n = 0;\n\t\tchar ch = getchar();\n\t\tfor (; isspace(ch) && ch != EOF; ch = getchar())\n\t\t\t;\n\t\tfor (; !isspace(ch) && ch != EOF; ch = getchar()) {\n\t\t\ts[n++] = ch;\n\t\t}\n\t\ts[n] = '\\0';\n\t\treturn n;\n\t}\n\n\tinline void myPutchar(char x) {\n\t\tstatic char pbuf[OUT_BUF], *pp = pbuf;\n\t\tstruct _flusher {\n\t\t\t~_flusher() {\n\t\t\t\tfwrite(pbuf, 1, pp - pbuf, stdout);\n\t\t\t}\n\t\t};\n\t\tstatic _flusher outputFlusher;\n\t\tif (pp == pbuf + OUT_BUF) {\n\t\t\tfwrite(pbuf, 1, OUT_BUF, stdout);\n\t\t\tpp = pbuf;\n\t\t}\n\t\t*pp++ = x;\n\t}\n\n\ttemplate<typename T>\n\tinline void print_(T x) {\n\t\tif (x == 0) {\n\t\t\tputchar('0');\n\t\t\treturn;\n\t\t}\n\t\tstatic int num[40];\n\t\tif (x < 0) {\n\t\t\tputchar('-');\n\t\t\tx = -x;\n\t\t}\n\t\tfor (*num = 0; x; x /= 10) {\n\t\t\tnum[++*num] = x % 10;\n\t\t}\n\t\twhile (*num){\n\t\t\tputchar(num[*num] ^ '0');\n\t\t\t--*num;\n\t\t}\n\t}\n\n\ttemplate<typename T>\n\tinline void print(T x, char ch = '\\n') {\n\t\tprint_(x);\n\t\tputchar(ch);\n\t}\n\n\tinline void printStr_(const char *s, int n = -1) {\n\t\tif (n == -1) {\n\t\t\tn = strlen(s);\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tputchar(s[i]);\n\t\t}\n\t}\n\n\tinline void printStr(const char *s, int n = -1, char ch = '\\n') {\n\t\tprintStr_(s, n);\n\t\tputchar(ch);\n\t}\n}\nusing namespace IO;\n\nconst int N = 8;\n\nint n;\nchar a[1 << N | 5];\n\nstd::vector<std::pair<int, int>> get(int S, int lst) {\n\tint k = 0;\n\twhile (!(S >> k & 1)) {\n\t\t++k;\n\t}\n\tstd::vector<std::pair<int, int>> res;\n\tif (S == (1 << k)) {\n\t\tfor (int i = lst; i < k; ++i) {\n\t\t\tres.push_back({i, 1});\n\t\t}\n\t\tres.push_back({k, 1});\n\t\tres.push_back({k, 0});\n\t\tfor (int i = lst; i < k; ++i) {\n\t\t\tres.push_back({i, 1});\n\t\t}\n\t\treturn res;\n\t}\n\tstd::vector<std::pair<int, int>> t = get(S ^ (1 << k), k + 1);\n\tfor (int i = lst; i < k; ++i) {\n\t\tres.push_back({i, 1});\n\t}\n\tres.push_back({k, 1});\n\tfor (auto i : t) {\n\t\tres.push_back(i);\n\t}\n\tres.push_back({k, 1});\n\tres.push_back({k, 0});\n\tstd::reverse(t.begin(), t.end());\n\tfor (auto i : t) {\n\t\tres.push_back(i);\n\t}\n\tres.push_back({k, 0});\n\tfor (int i = k - 1; i >= lst; --i) {\n\t\tres.push_back({i, 1});\n\t}\n\treturn res;\n}\n\nvoid solve() {\n\tread(n);\n\treadStr(a);\n\tfor (int i = 1; i < (1 << n); ++i) {\n\t\tif (a[i] == '1') {\n\t\t\tfor (int j = i; j; j = (j - 1) & i) {\n\t\t\t\tif (a[j] == '0') {\n\t\t\t\t\tprintStr(\"Impossible\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstd::vector<std::pair<int, int>> res;\n\tfor (int i = 1; i < (1 << n); ++i) {\n\t\tif (a[i] == '0') {\n\t\t\tbool flag = 1;\n\t\t\tfor (int j = i; j; j = (j - 1) & i) {\n\t\t\t\tif (i != j && a[j] == '0') {\n\t\t\t\t\tflag = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstd::vector<std::pair<int, int>> t(get(i, 0));\n\t\t\tfor (auto v : t) {\n\t\t\t\tres.push_back(v);\n\t\t\t}\n\t\t}\n\t}\n\tint x = 0, y = 0;\n\tstd::vector<std::pair<int, int>> ans(1, {0, 0});\n\tfor (auto v : res) {\n\t\tif (y != v.second) {\n\t\t\ty = v.second;\n\t\t\tans.push_back({x, y});\n\t\t}\n\t\tif (x == v.first) {\n\t\t\t++x;\n\t\t} else {\n\t\t\t--x;\n\t\t}\n\t\tans.push_back({x, y});\n\t}\n\tprintStr(\"Possible\");\n\tprint((int)ans.size() - 1);\n\tfor (auto v : ans) {\n\t\tprint(v.first, ' '), print(v.second);\n\t}\n}\n\nint main() {\n\tint T = 1;\n\t// read(T);\n\twhile (T--) {\n\t\tsolve();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 21.03.2020 16:03:59       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  string foo;\n  cin >> foo;\n  vector<int> good(1 << n);\n  for (int i = 0; i < (1 << n); i++) {\n    good[i] = (foo[i] == '1');\n  }\n  if (!good[0]) {\n    cout << \"Impossible\" << '\\n';\n    return 0;\n  }\n  for (int i = 0; i < (1 << n); i++) {\n    for (int j = 0; j < n; j++) {\n      if (!(i & (1 << j)) && !good[i] && good[i | (1 << j)]) {\n        cout << \"Impossible\" << '\\n';\n        return 0;\n      }\n    }\n  }\n  cout << \"Possible\" << '\\n';\n  if (good[(1 << n) - 1]) {\n    cout << 0 << '\\n';\n    cout << \"1 1\" << '\\n';\n    return 0;\n  }\n  string path = \"\";\n  for (int mask = 0; mask < (1 << n); mask++) {\n    if (!good[mask]) {\n      bool ok = true;\n      for (int j = 0; j < n; j++) {\n        if ((mask & (1 << j)) && !good[mask ^ (1 << j)]) {\n          ok = false;\n          break;\n        }\n      }\n      if (!ok) {\n        continue;\n      }\n      string cur = \"\";\n      for (int j = n - 1; j >= 0; j--) {\n        char C = (char) ('A' + j);\n        char c = (char) ('a' + j);\n        if (mask & (1 << j)) {\n          if (cur != \"\") {\n            cur = C + cur + C + c + string(cur.rbegin(), cur.rend()) + c;\n          } else {\n            cur += C;\n            cur += c;\n          }\n        } else {\n          if (cur != \"\") {\n            cur = C + cur + C;\n          }\n        }\n      }\n      path += cur;\n      debug(mask, cur);\n    }\n  }\n  debug(path);\n  for (int t = 0; t < (1 << n); t++) {\n    string tmp = path;\n    for (char& c : tmp) {\n      int d = (int) (toupper(c) - 'A');\n      if (!(t & (1 << d))) {\n        c = toupper(c);\n      }\n    }\n    vector<char> st;\n    for (char c : tmp) {\n      if (!st.empty() && st.back() == c) {\n        st.pop_back();\n      } else {\n        st.push_back(c);\n      }\n    }\n    assert(st.empty() == good[t]);\n  }\n  vector<pair<int, int>> ret;\n  ret.emplace_back(0, 0);\n  for (char c : path) {\n    int x = ret.back().first;\n    int y = ret.back().second;\n    if (isupper(c) && y == 0) {\n      y = 1;\n      ret.emplace_back(x, y);\n    }\n    if (islower(c) && y == 1) {\n      y = 0;\n      ret.emplace_back(x, y);\n    }\n    int z = (int) (toupper(c) - 'A');\n    assert(z == x || z == x - 1);\n    if (z == x) {\n      ++x;\n      ret.emplace_back(x, y);\n    } else {\n      --x;\n      ret.emplace_back(x, y);\n    }\n  }\n  assert(ret.back().first == 0);\n  if (ret.back().second == 1) {\n    ret.emplace_back(0, 0);\n  }\n  cout << ret.size() - 1 << '\\n';\n  for (auto& p : ret) {\n    cout << p.first << \" \" << p.second << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int N=1<<10;\nint n;\nchar s[N];\nint p[N];\nvector<pair<int,int> > solve(int S,int now)\n{\n\tcerr<<\"Solve\"<<S<<\" \"<<now<<\"\\n\";\n\tvector<pair<int,int> >res;\n\tfor(int i=now+1;i<=n;i++)\n\t\tif(S&(1<<i))\n\t\t{\n\t\t\tvector<pair<int,int> > t=solve(S,i);\n\t\t\tfor(int j=now-1;j<=i-2;j++)\n\t\t\t\tres.push_back(make_pair(j,1));\n\t\t\tfor(auto [x,y]:t)\n\t\t\t\tres.push_back(make_pair(x,y));\n\t\t\tfor(int j=i-1;j>=now-1;j--)\n\t\t\t\tres.push_back(make_pair(j,1));\n\t\t\tres.push_back(make_pair(now-1,0));\n\t\t\tres.push_back(make_pair(now,0));\n\t\t\tfor(int j=now;j<=i-1;j++)\n\t\t\t\tres.push_back(make_pair(j,1));\n\t\t\tfor(auto [x,y]:t)\n\t\t\t\tres.push_back(make_pair(x,y^1));\n\t\t\tfor(int j=i-2;j>=now;j--)\n\t\t\t\tres.push_back(make_pair(j,1));\n\t\t\tres.push_back(make_pair(now,0));\n\t\t\tres.push_back(make_pair(now-1,0));\n\t\t\treturn res;\n\t\t}\n\tres.push_back(make_pair(now-1,1));\n\tres.push_back(make_pair(now,1)); \n\tres.push_back(make_pair(now,0));\n\tres.push_back(make_pair(now-1,0));\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s);\n\tfor(int i=0;i<(1<<n);i++)\n\t\tp[i]=s[i]-'0';\n\tif(p[0]==0)\n\t{\n\t\tprintf(\"Impossible\");\n\t\treturn 0;\n\t}\n\tfor(int s=0;s<(1<<n);s++)\n\t\tif(p[s]==1)\n\t\t\tfor(int i=s;i;i=(i-1)&s)\n\t\t\t\tif(p[i]==0)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"Impossible\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\tvector<pair<int,int> >ans;\n\tans.push_back(make_pair(0,0));\n\tfor(int s=1;s<(1<<n);s++)\n\t\tif(p[s]==0)\n\t\t{\n\t\t\tbool flag=true;\n\t\t\tfor(int i=(s-1)&s;i;i=(i-1)&s)\n\t\t\t\tif(p[i]==0)\n\t\t\t\t{\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif(!flag) continue;\n\t\t\tvector<pair<int,int> >res;\n\t\t\tvector<pair<int,int> >t;\n\t\t\tint u=0;\n\t\t\tfor(u=0;u<n;u++)\n\t\t\t\tif(s&(1<<u))\n\t\t\t\t{\n\t\t\t\t\tt=solve(s,u+1);\n//\t\t\t\t\tcerr<<\"res\"<<\"\\n\";\n//\t\t\t\t\tfor(auto [x,y]:t)\n//\t\t\t\t\t\tcerr<<x<<\" \"<<y<<\"\\n\";\n//\t\t\t\t\tcerr<<\"EOF\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tu++;\n//\t\t\tres.push_back(make_pair(0,0));\n\t\t\tfor(int i=0;i<=u-2;i++)\n\t\t\t\tres.push_back(make_pair(i,1));\n\t\t\tfor(auto [x,y]:t)\n\t\t\t\tres.push_back(make_pair(x,y));\n\t\t\tfor(int i=u-2;i>=0;i--)\n\t\t\t\tres.push_back(make_pair(i,0));\n\t\t\tfor(auto [x,y]:res)\n\t\t\t\tans.push_back(make_pair(x,y));\n\t\t}\n\tprintf(\"Possible\\n\");\n\tint len=ans.size()-1;\n\tprintf(\"%d\\n\",len);\n\tfor(auto [x,y]:ans)\n\t\tprintf(\"%d %d\\n\",x,y);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n, C[260];\nchar p[260];\nstruct point {\n\tint x, y;\n};\nvector<point>Res;\nvoid Add(int x, int y) {\n\tRes.push_back({ x,y });\n}\nvoid Add0() {\n\tint i;\n\tfor (i = 0; i < n; i++) Add(i, 1);\n\tfor (i = n; i > 0; i--)Add(i, 1);\n}\nvoid Add1(int x) {\n\tint i;\n\tfor (i = 0; i <= x + 1; i++)Add(i, 1);\n\tAdd(x + 1, 0);\n\tAdd(x, 0);\n\tfor (i = x; i > 0; i--)Add(i, 1);\n}\nvoid Add2(int xa, int xb) {\n\tint i;\n\tfor (i = 0; i <= xb + 1; i++) Add(i, 1);\n\tAdd(xb + 1, 0);\n\tAdd(xb, 0);\n\tfor (i = xb; i >= xa; i--)Add(i, 1);\n\tAdd(xa, 0);\n\tAdd(xa + 1, 0);\n\tfor (i = xa + 1; i <= xb; i++)Add(i, 1);\n\tAdd(xb, 0);\n\tAdd(xb + 1, 0);\n\tfor (i = xb + 1; i > xa; i--)Add(i, 1);\n\tAdd(xa + 1, 0);\n\tAdd(xa, 0);\n\tfor (i = xa; i > 0; i--)Add(i, 1);\n}\nvoid Print() {\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d\\n\", Res.size());\n\tint i;\n\tRes.push_back(Res[0]);\n\tfor (auto &t : Res)printf(\"%d %d\\n\", t.x, t.y);\n}\nint main() {\n\tint i, j;\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", p);\n\tfor (i = 0; i < (1 << n); i++) {\n\t\tint c = 0;\n\t\tfor (j = 0; j < n; j++)if ((i >> j) & 1)c++;\n\t\tC[i] = c;\n\t}\n\tfor (i = 0; i < (1 << n); i++) {\n\t\tint ck = 0;\n\t\tif (p[i] == '0' && C[i] >= 3)ck = 1;\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif ((i&j) == j) {\n\t\t\t\tif (p[j] == '0'&&p[i] == '1') {\n\t\t\t\t//\tputs(\"Impossible\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (C[j] == 2 && p[j] == '0')ck = 0;\n\t\t\t}\n\t\t}\n\t\tif (ck == 1) {\n\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n\tAdd0();\n\tint pv = -1;\n\tfor (i = 0; i < n; i++) {\n\t\tif (p[1 << i] == '0') {\n\t\t\tAdd1(i);\n\t\t\tpv = i;\n\t\t}\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t\tif (p[1 << i] == '1'&&p[1 << j] == '1'&&p[(1 << i) | (1 << j)] == '0') {\n\t\t\t\tAdd2(i, j);\n\t\t\t\tif (pv != -1)Add1(pv);\n\t\t\t}\n\t\t}\n\t}\n\tPrint();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n#ifdef ENABLE_DEBUG\n#define dump(a) cerr<<#a<<\"=\"<<a<<endl\n#define dumparr(a,n) cerr<<#a<<\"[\"<<n<<\"]=\"<<a[n]<<endl\n#else\n#define dump(a) \n#define dumparr(a,n) \n#endif\n#define FOR(i, a, b) for(ll i = (ll)a;i < (ll)b;i++)\n#define For(i, a) FOR(i, 0, a)\n#define REV(i, a, b) for(ll i = (ll)b-1LL;i >= (ll)a;i--)\n#define Rev(i, a) REV(i, 0, a)\n#define REP(a) For(i, a)\n#define SIGN(a) (a==0?0:(a>0?1:-1))\n\ntypedef long long int ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll,pll> ppll;\ntypedef vector<ll> vll;\ntypedef long double ld;\ntypedef pair<ld,ld> pdd;\n\nconst ll INF=(1LL<<50);\n#if __cplusplus<201700L\nll gcd(ll a, ll b) {\n  if(a < b) return gcd(b, a);\n  ll r;\n  while ((r=a%b)) {\n    a = b;\n    b = r;\n  }\n  return b;\n}\n#endif\ntemplate<class T>\nbool chmax(T& a,const T& b){\n  if(a<b){\n    a=b;\n    return true;\n  }\n  return false;\n}\ntemplate<class T>\nbool chmin(T& a,const T& b){\n  if(a>b){\n    a=b;\n    return true;\n  }\n  return false;\n}\ntemplate<class S,class T>\nstd::ostream& operator<<(std::ostream& os,pair<S,T> a){\n  os << \"(\" << a.first << \",\" << a.second << \")\";\n  return os;\n}\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os,vector<T> a){\n  os << \"[ \";\n  REP(a.size()){\n    os<< a[i] << \" \";\n  }\n  os<< \" ]\";\n  return os;\n}\n\nconst string YES = \"Possible\";\nconst string NO = \"Impossible\";\nvoid create1(vector<pll> &ans,ll x){\n  REP(x+1){ans.push_back(pll(1+i,0));}\n  ans.push_back(pll(x+1,1));\n  ans.push_back(pll(x,1));\n  Rev(i,x+1){ans.push_back(pll(i,0));}\n}\nvoid create2(vector<pll> &ans,set<ll> s){\n  ll first=*s.begin();\n  ll end=*prev(s.end());\n  s.erase(first);\n  REP(first){ans.push_back(pll(i+1,0));}\n  ans.push_back(pll(first,1));\n  ans.push_back(pll(first+1,1));\n  ans.push_back(pll(first+1,0));\n  FOR(i,first+2,end+2){ans.push_back(pll(i,0));}\n  s.insert(first);\n  REV(i,first+1,end+2){\n    if(s.count(i)==1&&s.count(i-1)==0){\n      ans.push_back(pll(i,0));\n    }else if(s.count(i)==0&&s.count(i-1)==1){\n      ans.push_back(pll(i,1));\n    }\n    ans.push_back(pll(i-1,ans.back().second));\n  }\n  s.erase(first);\n  FOR(i,first,*s.begin()+1){\n    ans.push_back(pll(i,0));\n  }\n  FOR(i,*s.begin()+1,end){\n    if(s.count(i-1)==0&&s.count(i)){\n      ans.push_back(pll(i,1));\n    }else if(s.count(i-1)==1&&s.count(i)){\n      ans.push_back(pll(i,0));\n    }\n    ans.push_back(pll(i+1,ans.back().second));\n  }\n  REV(i,0,end+1){\n    ans.push_back(pll(i,0));\n  }\n}\nll two_factor(ll x){\n  ll ret=0;\n  while((1<<ret)!=x){\n    ++ret;\n  }\n  return ret;\n}\nint main(){\n  cout<<setprecision(1000);\n  ll N;\n  cin>>N;\n  string A;\n  cin>>A;\n  vector<bool> first(A.size(),true);\n  REP(A.size()){\n    if(first[i]==false)continue;\n    if(A[i]=='0')FOR(j,i+1,A.size()){\n      if(((i&j)==i)&&A[j]=='1'){\n        cout<<NO<<endl;\n        return 0;\n      }else if((i&j)==i){\n        first[j]=false;\n      }\n    }else{\n      first[i]=false;\n    }\n  }\n  dump(first);\n  vector<pll> ans{pll(0,0)};\n  REP(A.size()){\n    if(first[i]){\n      if(__builtin_popcountll(i)==1){\n        create1(ans,two_factor(i));\n      }else{\n        set<ll> s;\n        For(j,N){\n          if((1<<j)&i){\n            s.insert(i);\n          }\n        }\n        create2(ans,move(s));\n      }\n    }\n  }\n  cout<<YES<<endl;\n  cout<<ans.size()-1<<endl;\n  REP(ans.size()){\n    cout<<ans[i].first<<\" \"<<ans[i].second<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main() {\n  ll N; cin >> N;\n  ll a[1 << N];\n  for (ll i = 0; i < (1 << N); i++) {\n    char c; cin >> c;\n    a[i] = c - '0';\n  }\n  ll b[N];\n  for (ll i = 0; i < N; i++) {\n    b[i] = !a[1 << i];\n  }\n  for (ll bits = 0; bits < (1 << N); bits++) {\n    bool dots = false;\n    for (ll i = 0; i < N; i++) {\n      if ((bits >> i) & 1) dots |= b[i];\n    }\n    if (!(a[bits]^dots)) {\n      cout << \"Impossible\" << endl;\n      return 0;\n    }\n  }\n  ll L = N;\n  for (ll i = 0; i < N; i++) {\n    if (b[i]) {L+=3;} else {L+=1;}\n  }\n  cout << \"Possible\" << endl;\n  cout << L << endl;\n  for (ll i = 0; i < N; i++) {\n    if (b[i]) {\n      cout << i << \" \" << 1 << endl;\n      cout << i << \" \" << 0 << endl;\n      cout << i+1 << \" \" << 0 << endl;\n    } else {\n      cout << i << \" \" << 1 << endl;\n    }\n  }\n  for (ll i = 0; i <= N; i++) {\n    cout << N-i << \" \" << 1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:1000000000\")\n#pragma GCC optimize(\"Ofast,no-stack-protector\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <algorithm>\n#include <memory.h>\n#include <cassert>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <cmath>\n#include <ctime>\n#include <random>\n#include <bitset>\n#include <limits.h>\n#include <fstream>\n\n#define mp make_pair\n#define all(a) (a).begin(), (a).end()\n#define pll pair <ll, ll>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef double ld;\n#define uint unsigned int\n\nconst int maxlog = 8;\nconst int maxn = (1 << 8);\n\nint a[maxn];\nchar s[maxn];\n\nvector <pii> ans;\n\nvoid go(int &x, int &y, int dx, int dy) {\n\tx += dx;\n\ty += dy;\n\tans.push_back(mp(x, y));\n}\n\nint main() {\n\tint n;\n\n\tcin >> n;\n\tcin >> s;\n\n\tfor (int i = 0; i < (1 << n); i++) {\n\t\ta[i] = s[i] - '0';\n\t}\n\n\tfor (int i = (1 << n) - 1; i >= 0; i--) {\n\t\tif (a[i] == 0) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif ((i >> j) & 1) {\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (a[i | (1 << j)] == 1) {\n\t\t\t\t\t\tcout << \"Impossible\\n\";\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < (1 << n); i++) {\n\t\tif (a[i] == 1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tbool good = true;\n\t\tint cnt = 0;\n\n\t\tfor (int j = 0; j < (1 << i); j++) {\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tcnt++;\n\t\t\t\tif (a[i ^ (1 << j)] == 0) {\n\t\t\t\t\tgood = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (good && cnt >= 3) {\n\t\t\tcout << \"Impossible\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (a[0] == 0) {\n\t\tcout << \"Impossible\\n\";\n\t\treturn 0;\n\t}\n\n\tans.push_back(mp(0, 0));\n\n\tfor (int i = 0; i < (1 << n); i++) {\n\t\tif (a[i] == 1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvector <int> p;\n\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tp.push_back(j);\n\t\t\t}\n\t\t}\n\n\t\tif ((int)p.size() > 2) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tint x = 0, y = 0;\n\n\t\tgo(x, y, 0, 1);\n\n\t\twhile (x < p[0]) {\n\t\t\tgo(x, y, 1, 0);\n\t\t}\n\n\t\tgo(x, y, 0, -1);\n\t\tgo(x, y, 1, 0);\n\t\tgo(x, y, 0, 1);\n\n\t\tif ((int)p.size() == 1) {\n\t\t\twhile (x > 0) {\n\t\t\t\tgo(x, y, -1, 0);\n\t\t\t}\n\n\t\t\tgo(x, y, 0, -1);\n\t\t}\n\t\telse {\n\t\t\twhile (x < p[1]) {\n\t\t\t\tgo(x, y, 1, 0);\n\t\t\t}\n\n\t\t\tgo(x, y, 0, -1);\n\t\t\tgo(x, y, 1, 0);\n\t\t\tgo(x, y, 0, 1);\n\t\t\twhile (x > p[0] + 1) {\n\t\t\t\tgo(x, y, -1, 0);\n\t\t\t}\n\n\t\t\tgo(x, y, 0, -1);\n\t\t\tgo(x, y, -1, 0);\n\t\t\tgo(x, y, 0, 1);\n\t\t\twhile (x < p[1] + 1) {\n\t\t\t\tgo(x, y, 1, 0);\n\t\t\t}\n\n\t\t\tgo(x, y, 0, -1);\n\t\t\tgo(x, y, -1, 0);\n\t\t\tgo(x, y, 0, 1);\n\n\t\t\twhile (x > 0) {\n\t\t\t\tgo(x, y, -1, 0);\n\t\t\t}\n\n\t\t\tgo(x, y, 0, -1);\n\t\t}\n\t}\n\n\tcout << \"Possible\\n\";\n\tcout << (int)ans.size() - 1 << '\\n';\n\n\tfor (pii f : ans) {\n\t\tcout << f.first << ' ' << f.second << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define INF ((1<<30)-1)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nvoid ok(){\n    cout << \"Yes\" << endl;\n    exit(0);\n}\n\nvoid ng(){\n    cout <<  \"Impossible\" << endl;\n    exit(0);\n}\n\n\nint n;\nint a[1 << 8];\n\nvector<int> loops;\n\nvoid entangle(int x){\n    vector<int> loop;\n    for(int i = n-1;i >= 0;i--){\n        if((x >> i) % 2 == 0)continue;\n        if(loop.empty()){\n            loop.push_back(i+1);\n            loop.push_back(-i-1);\n        }\n        else{\n            vector<int> tmp;\n            tmp.push_back(i+1);\n            tmp.push_back(-i-1);\n            for(auto it = loop.begin();it != loop.end();it++)tmp.push_back(*it);\n            tmp.push_back(-i-1);\n            tmp.push_back(i+1);\n            for(auto it = loop.rbegin();it != loop.rend();it++)tmp.push_back(*it);\n            loop = tmp;\n        }\n    }\n    for(auto elem:loop)loops.push_back(elem);\n    loops.push_back(INF);\n}\n\nvoid show(){\n    cout << \"Possible\" << endl;\n    vector<P> ps;\n    ps.push_back(P(0,0));\n    int nowx = 0, nowy = 0;\n    for(int x:loops){\n        if(x == INF){\n            while(nowx > 0){\n                ps.push_back(P(--nowx, nowy));\n            }\n            continue;\n        }\n        if(x > 0){\n            while(nowx > x){\n                ps.push_back(P(--nowx, nowy));\n            }\n            while(nowx < x-1){\n                ps.push_back(P(++nowx, nowy));\n            }\n            ps.push_back(P(nowx,++nowy));\n            if(nowx == x)ps.push_back(P(--nowx, nowy));\n            else ps.push_back(P(++nowx, nowy));\n            ps.push_back(P(nowx,--nowy));\n        }\n        if(x < 0){\n            x = x * -1;\n            while(nowx > x){\n                ps.push_back(P(--nowx, nowy));\n            }\n            while(nowx < x-1){\n                ps.push_back(P(++nowx, nowy));\n            }\n            if(nowx == x)ps.push_back(P(--nowx, nowy));\n            else ps.push_back(P(++nowx, nowy));\n        }\n    }\n    cout << ps.size() - 1 << endl;\n    for(auto p:ps){\n        cout << p.first << \" \" << p.second << endl;\n    }\n}\n\nint main(){\n    cin >> n;\n    for(int i = 0;i < (1<<n);i++){\n        scanf(\"%1d\", a+i);\n        bool bad;\n        if(a[i] == 0)bad = true;\n        for(int j = 0;j < i;j++){\n            if((j & i) != j)continue;\n            if(a[i] == 1 && a[j] == 0){\n                ng();                    \n            }\n            if(a[j] == 0)bad = false;\n        }\n        if(bad){\n            entangle(i);\n        }\n    }\n    show();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nint n;\nchar s[1010];\nvector<PII> ans,c,trash;\nvector<PII> build(VI w) {\n  if (SZ(w)==1) return vector<PII>{{w[0],0}};\n  vector<PII> z{{w[0],0},{w[1],0},{w[0],1},{w[1],1}};\n  rep(i,2,SZ(w)) {\n    vector<PII> nz=z; \n    z.pb({w[i],0});\n    reverse(all(nz));\n    for (auto p:nz) z.pb({p.fi,p.se^1});\n    z.pb({w[i],-1});\n  }\n  return z;\n}\nint zz;\nint main() {\n  scanf(\"%d\",&n);\n  scanf(\"%s\",s);\n  //rep(i,0,(1<<n)) s[i]=(__builtin_popcount(i)<5)+'0';\n  rep(i,0,(1<<n)) if (s[i]=='0') {\n    rep(j,0,(1<<n)) if ((j&i)==i&&s[j]=='1') {\n      puts(\"Impossible\");\n      return 0;\n    }\n    bool cc=0;\n    rep(j,0,(1<<n)) if ((i&j)==j&&i!=j&&s[j]=='0') cc=1;\n    if (cc) continue;\n    VI w;\n    rep(j,0,n) if (i&(1<<j)) w.pb(j);\n    auto x=build(w);\n    for (auto p:x) ans.pb(p);\n    zz++;\n    //rep(i,0,n) ans.pb(mp(i,0)),trash.pb(mp(i,0));\n    rep(i,0,100) {\n      int x=rnd(n);\n      ans.pb(mp(x,0)),trash.pb(mp(x,(SZ(w)>=2)));\n    }\n  }\n  //fprintf(stderr,\"%d\\n\",zz);\n  reverse(all(trash));\n  for (auto p:trash) ans.pb(mp(p.fi,p.se^1));\n // rep(i,0,zz) per(j,0,n) ans.pb(mp(j,-1));\n  puts(\"Possible\");\n  int pos=0;\n  c.pb(mp(0,0));\n  for (auto p:ans) {\n    //printf(\"pp %d %d\\n\",p.fi,p.se);\n    if (p.se==0) {\n      while (pos<p.fi) {\n        pos+=1;\n        c.pb(mp(pos,0));\n      }\n      while (pos>p.fi) {\n        pos-=1;\n        c.pb(mp(pos,0));\n      }\n      c.pb(mp(pos,1));\n      c.pb(mp(pos+1,1));\n      c.pb(mp(pos+1,0));\n      pos+=1;\n    } else {\n      while (pos<p.fi+1) {\n        pos+=1;\n        c.pb(mp(pos,0));\n      }\n      while (pos>p.fi+1) {\n        pos-=1;\n        c.pb(mp(pos,0));\n      }\n      c.pb(mp(pos,1));\n      c.pb(mp(pos-1,1));\n      c.pb(mp(pos-1,0));\n      pos-=1;\n    }\n  }\n  while (pos>0) {\n    pos--;\n    c.pb(mp(pos,0));\n  }\n  assert(SZ(c)<=250000);\n  printf(\"%d\\n\",SZ(c)-1);\n  for (auto x:c) printf(\"%d %d\\n\",x.fi,x.se);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:1000000000\")\n#pragma GCC optimize(\"Ofast,no-stack-protector\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <algorithm>\n#include <memory.h>\n#include <cassert>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <cmath>\n#include <ctime>\n#include <random>\n#include <bitset>\n#include <limits.h>\n#include <fstream>\n\n#define mp make_pair\n#define all(a) (a).begin(), (a).end()\n#define pll pair <ll, ll>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef double ld;\n#define uint unsigned int\n\nconst int maxlog = 8;\nconst int maxn = (1 << 8);\n\nint a[maxn];\nchar s[maxn];\n\nvector <pii> ans;\n\nvoid go(int &x, int &y, int dx, int dy) {\n\tx += dx;\n\ty += dy;\n\tans.push_back(mp(x, y));\n}\n\nint main() {\n\tint n;\n\n\tcin >> n;\n\tcin >> s;\n\n\tfor (int i = 0; i < (1 << n); i++) {\n\t\ta[i] = s[i] - '0';\n\t}\n\n\tfor (int i = (1 << n) - 1; i >= 0; i--) {\n\t\tif (a[i] == 0) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif ((i >> j) & 1) {\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (a[i | (1 << j)] == 1) {\n\t\t\t\t\t\tcout << \"Impossible\\n\";\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < (1 << n); i++) {\n\t\tif (a[i] == 1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tbool good = true;\n\t\tint cnt = 0;\n\n\t\tfor (int j = 0; j < (1 << i); j++) {\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tcnt++;\n\t\t\t\tif (a[i ^ (1 << j)] == 0) {\n\t\t\t\t\tgood = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (good && cnt >= 3) {\n\t\t\tthrow 1;\n\t\t\tcout << \"Impossible\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (a[0] == 0) {\n\t\tcout << \"Impossible\\n\";\n\t\treturn 0;\n\t}\n\n\tans.push_back(mp(0, 0));\n\n\tfor (int i = 0; i < (1 << n); i++) {\n\t\tif (a[i] == 1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvector <int> p;\n\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tp.push_back(j);\n\t\t\t}\n\t\t}\n\n\t\tif ((int)p.size() > 2) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tint x = 0, y = 0;\n\n\t\tgo(x, y, 0, 1);\n\n\t\twhile (x < p[0]) {\n\t\t\tgo(x, y, 1, 0);\n\t\t}\n\n\t\tgo(x, y, 0, -1);\n\t\tgo(x, y, 1, 0);\n\t\tgo(x, y, 0, 1);\n\n\t\tif ((int)p.size() == 1) {\n\t\t\twhile (x > 0) {\n\t\t\t\tgo(x, y, -1, 0);\n\t\t\t}\n\n\t\t\tgo(x, y, 0, -1);\n\t\t}\n\t\telse {\n\t\t\twhile (x < p[1]) {\n\t\t\t\tgo(x, y, 1, 0);\n\t\t\t}\n\n\t\t\tgo(x, y, 0, -1);\n\t\t\tgo(x, y, 1, 0);\n\t\t\tgo(x, y, 0, 1);\n\t\t\twhile (x > p[0] + 1) {\n\t\t\t\tgo(x, y, -1, 0);\n\t\t\t}\n\n\t\t\tgo(x, y, 0, -1);\n\t\t\tgo(x, y, -1, 0);\n\t\t\tgo(x, y, 0, 1);\n\t\t\twhile (x < p[1] + 1) {\n\t\t\t\tgo(x, y, 1, 0);\n\t\t\t}\n\n\t\t\tgo(x, y, 0, -1);\n\t\t\tgo(x, y, -1, 0);\n\t\t\tgo(x, y, 0, 1);\n\n\t\t\twhile (x > 0) {\n\t\t\t\tgo(x, y, -1, 0);\n\t\t\t}\n\n\t\t\tgo(x, y, 0, -1);\n\t\t}\n\t}\n\n\tcout << \"Possible\\n\";\n\tcout << (int)ans.size() - 1 << '\\n';\n\n\tfor (pii f : ans) {\n\t\tcout << f.first << ' ' << f.second << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\n\ntemplate <class T1, class T2>\nostream& operator << (ostream& out, const pair <T1, T2> p)\n{\n    out << '(' << p.first << ',' << p.second << ')';\n    return out;\n}\n\ntemplate <class T1, class T2>\nistream& operator >> (istream& in, pair<T1, T2> &p)\n{\n    in >> p.first >> p.second;\n    return in;\n}\n\ntemplate <class T>\nistream& operator >> (istream& in, vector<T> &v)\n{\n    for (T &x : v)\n        in >> x;\n    return in;\n}\n\ntemplate <class T>\nostream& operator << (ostream& out, const vector<vector<T>> &v)\n{\n    for (const vector<T> &x : v)\n        out << x << '\\n';\n    return out;\n}\n\ntemplate <class T>\nostream& operator << (ostream& out, const vector<T> &v)\n{\n    for (const T &x : v)\n        out << x << ' ';\n    return out;\n}\n\nlong long gcd (long long a, long long b)\n{\n    if (b > a)\n        swap(a, b);\n    return (b ? gcd(b, a % b) : a);\n}\n\nusing ll   = long long;\nusing pii  = pair<int, int>;\nusing pll  = pair<long long, long long>;\nusing tiii = pair<pair<int, int>, int>;\nusing vi   = vector<int>;\nusing vl   = vector<long long>;\nusing vvi  = vector<vector<int>>;\nusing vvl  = vector<vector<long long>>;\n\n#define F          first\n#define S          second\n#define First      first.first\n#define Second     first.second\n#define Third      second\n#define mp         make_pair\n#define rep(i,a,b) for (int i = (a); i < (b); i++)\n#define per(i,b,a) for (int i = (b); i > (a); i--)\n#define all(x)     x.begin(), x.end()\n#define ret(x)     return cout << x, 0;\n#define throwex    throw runtime_error (\"Found the error.\");\n\nconst int h = 1000000007;\n\nint n;\nvector<pii> get_cycle(int mask, int cur = 0)\n{\n    int last_1_index = 0;\n    int z = mask;\n    while(z != 1)\n        last_1_index++, z /= 2;\n    vector<pii> ans;\n    if(cur == last_1_index)\n    {\n        ans.push_back({cur, 1});\n        ans.push_back({cur+1, 1});\n        ans.push_back({cur+1, 0});\n        ans.push_back({cur, 0});\n        ans.push_back({cur, 1});\n        return ans;\n    }\n    ans.push_back({cur, 1});\n    vector<pii> next_cycle = get_cycle(mask, cur + 1);\n    ans.insert(ans.end(), all(next_cycle));\n    ans.push_back({cur, 1});\n    if(mask & (1 << cur))\n    {\n        ans.push_back({cur, 0});\n        next_cycle.pop_back();\n        reverse(all(next_cycle));\n        ans.insert(ans.end(), all(next_cycle));\n        ans.push_back({cur+1, 0});\n        ans.push_back({cur, 0});\n        ans.push_back({cur, 1});\n    }\n    return ans;\n}\n\nsigned main()\n{\n    ios::sync_with_stdio(false);\n    #ifdef ONLINE_JUDGE\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    cerr.setstate(ios::failbit);\n    #endif\n\n    cin >> n;\n    string a;\n    cin >> a;\n    rep(i,0,1 << n)\n    {\n        rep(j,0,i)\n        {\n            if((j | i) == i and a[i] == '1' and a[j] == '0')\n                ret(\"Impossible\");\n        }\n    }\n    vector<pii> ans;\n    ans.push_back({0, 1});\n    rep(i,0,1 << n)\n    {\n        if(a[i] == '0')\n        {\n            vector<pii> cycle = get_cycle(i);\n            ans.insert(ans.end(), cycle.begin() + 1, cycle.end());\n            for(int j = i; j < (1 << n); j++)\n                if((i | j) == j)\n                    a[j] = '1';\n            cerr << cycle << '\\n';\n        }\n    }\n    assert(ans.size() <= 250000);\n    cout << \"Possible\\n\";\n    cout << ans.size() - 1 << '\\n';\n    for(pii x : ans)\n        cout << x.F << ' ' << x.S << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define fr first\n#define sc second\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n\nint main(){\n\tint n;\n\tstring s;\n\tcin>>n>>s;\n\t\n\tint a[300];\n\tfor(int i=0;i<(1<<n);i++)a[i]=s[i]-'0';\n\t\n\tbool used[10][10];\n\tmemset(used,0,sizeof used);\n\t\n\tint b[300];\n\tfor(int i=0;i<300;i++)b[i]=1;\n\tfor(int i=0;i<n;i++){\n\t\tbool ok=true;\n\t\tfor(int x=0;x<(1<<n);x++){\n\t\t\tif((x>>i)&1)if(a[x]==1)ok=false;\n\t\t}\n\t\tif(ok){\n\t\t\tused[i][i]=true;\n\t\t\tfor(int x=0;x<(1<<n);x++){\n\t\t\t\tif((x>>i)&1)b[x]=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tbool ok=true;\n\t\t\tfor(int x=0;x<(1<<n);x++){\n\t\t\t\tif((x>>i)&1)if((x>>j)&1)if(a[x]==1)ok=false;\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tused[i][j]=true;\n\t\t\t\tfor(int x=0;x<(1<<n);x++){\n\t\t\t\t\tif((x>>i)&1)if((x>>j)&1)b[x]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool ok=true;\n\tfor(int i=0;i<(1<<n);i++)ok&=a[i]==b[i];\n\tif(!ok){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tvector<P> ret;\n\tret.push_back(P(0,0));\n\tfor(int i=0;i<n;i++){\n\t\tif(used[i][i]){\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t}\n\t\t\tret.push_back(P(i,1));\n\t\t\tret.push_back(P(i+1,1));\n\t\t\tret.push_back(P(i+1,0));\n\t\t\tret.push_back(P(i,0));\n\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\tret.push_back(P(j,0));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int k=i+1;k<n;k++){\n\t\t\tif(used[i][k]){\n\t\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(i,1));\n\t\t\t\tret.push_back(P(i+1,1));\n\t\t\t\tret.push_back(P(i+1,0));\n\t\t\t\tret.push_back(P(i,0));\n\t\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(k,1));\n\t\t\t\tret.push_back(P(k+1,1));\n\t\t\t\tret.push_back(P(k+1,0));\n\t\t\t\tret.push_back(P(k,0));\n\t\t\t\tfor(int j=k-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(i+1,0));\n\t\t\t\tret.push_back(P(i+1,1));\n\t\t\t\tret.push_back(P(i,1));\n\t\t\t\tret.push_back(P(i,0));\n\t\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(k+1,0));\n\t\t\t\tret.push_back(P(k+1,1));\n\t\t\t\tret.push_back(P(k,1));\n\t\t\t\tret.push_back(P(k,0));\n\t\t\t\tfor(int j=k-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tputs(\"Possible\");\n\tprintf(\"%d\\n\",(int)(ret.size())-1);\n\tfor(int i=0;i<ret.size();i++){\n\t\tprintf(\"%d %d\\n\",ret[i].fr,ret[i].sc);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define BT (1<<9)\nusing namespace std;\ntypedef pair <int,int> P;\n\nchar A[BT];\nstring ans;\nint n;\n\nint popcount(int S)\n{\n\tint cnt=0;\n\tfor(int i=0;i<n;i++) if(S>>i&1) cnt++;\n\treturn cnt;\n}\nstring get(int S)\n{\n\tint cnt=popcount(S);\n\tif(cnt==2)\n\t{\n\t\tvector <int> v;\n\t\tfor(int i=0;i<n;i++) if(S>>i&1) v.push_back(i);\n\t\tstring ret=\"\";\n\t\tret+='0'+v[0];\n\t\tret+='0'+v[1];\n\t\tret+='0'+v[0]+n;\n\t\tret+='0'+v[1]+n;\n\t\treturn ret;\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(S>>i&1)\n\t\t{\n\t\t\tstring A=get(S-(1<<i));\n\t\t\tstring ret=\"\";\n\t\t\tret+='0'+i;\n\t\t\tret+=A;\n\t\t\tret+='0'+i+n;\n\t\t\tfor(int j=(int) (A.size())-1;j>=0;j--)\n\t\t\t{\n\t\t\t\tint y=A[j]-'0';\n\t\t\t\tif(y>=n) y-=n;\n\t\t\t\telse y+=n;\n\t\t\t\tret+='0'+y;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn \"\";\n}\nvoid print(string ret)\n{\n\tint x=0;\n\tvector <P> ans;\n\tfor(int i=0;i<ret.size();i++)\n\t{\n\t\tint y=ret[i]-'0';\n\t\tif(y<n)\n\t\t{\n\t\t\twhile(x<y)\n\t\t\t{\n\t\t\t\tans.push_back(P(x,0));\n\t\t\t\tx++;\n\t\t\t}\n\t\t\twhile(x>y)\n\t\t\t{\n\t\t\t\tans.push_back(P(x,0));\n\t\t\t\tx--;\n\t\t\t}\n\t\t\tans.push_back(P(x,0));\n\t\t\tans.push_back(P(x,1));\n\t\t\tx++;\n\t\t\tans.push_back(P(x,1));\n\t\t}\n\t\telse\n\t\t{\n\t\t\ty-=n;\n\t\t\twhile(x<=y)\n\t\t\t{\n\t\t\t\tans.push_back(P(x,0));\n\t\t\t\tx++;\n\t\t\t}\n\t\t\twhile(x>y+1)\n\t\t\t{\n\t\t\t\tans.push_back(P(x,0));\n\t\t\t\tx--;\n\t\t\t}\n\t\t\tans.push_back(P(x,0));\n\t\t\tans.push_back(P(x,1));\n\t\t\tx--;\n\t\t\tans.push_back(P(x,1));\n\t\t}\n\t}\n\twhile(x>=0)\n\t{\n\t\tans.push_back(P(x,0));\n\t\tx--;\n\t}\n\tputs(\"Possible\");\n\tprintf(\"%d\\n\",ans.size()-1);\n\tfor(int i=0;i<ans.size();i++) printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",&A);\n\tfor(int S=0;S<(1<<n);S++)\n\t{\n\t\tfor(int T=0;T<(1<<n);T++)\n\t\t{\n\t\t\tif((T|S)==S&&A[S]=='1'&&A[T]=='0')\n\t\t\t{\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tans=\"\";\n\tfor(int S=0;S<(1<<n);S++)\n\t{\n\t\tif(A[S]=='0')\n\t\t{\n\t\t\tbool up=true;\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tif(S>>i&1)\n\t\t\t\t{\n\t\t\t\t\tif(A[S-(1<<i)]=='0')\n\t\t\t\t\t{\n\t\t\t\t\t\tup=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!up) continue;\n\t\t\tif(popcount(S)>=2) ans+=get(S);\n\t\t\telse\n\t\t\t{\n\t\t\t\tint x;\n\t\t\t\tfor(int i=0;i<n;i++) if(S>>i&1) x=i;\n\t\t\t\tans+='0'+x;\n\t\t\t}\n\t\t\t//printf(\"%d %s\\n\",S,get(S).c_str());\n\t\t}\n\t}\n\t//printf(\"%s\\n\",ans.c_str());\n\tprint(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define long long long int\nusing namespace std;\n\n// @author: pashka\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    int n;\n    string s;\n    cin >> n >> s;\n    vector<bool> z(n);\n    for (int i = 0; i < n; i++) {\n        z[i] = true;\n        for (int j = 0; j < (1 << n); j++) {\n            if (j & (1 << i)) {\n                if (s[j] == '1') z[i] = false;\n            }\n        }\n    }\n    bool ok = true;\n    for (int j = 0; j < (1 << n); j++) {\n        bool q = true;\n        for (int i = 0; i < n; i++) {\n            if (j & (1 << i)) {\n                if (z[i]) {\n                    q = false;\n                }\n            }\n        }\n        if (q != (s[j] == '1')) {\n            ok = false;\n        }\n    }\n    if (!ok) {\n        cout << \"Impossible\\n\";\n    } else {\n        cout << \"Possible\\n\";\n        vector<pair<int, int>> p;\n        p.push_back({0, 1});\n        for (int i = 0; i < n; i++) {\n            if (z[i]) {\n                p.push_back({i, 0});\n                p.push_back({i + 1, 0});\n            }\n            p.push_back({i + 1, 1});\n        }\n        for (int i = n - 1; i >= 0; i--) {\n            p.push_back({i, 1});\n        }\n        cout << p.size() - 1 << \"\\n\";\n        for (auto x : p) {\n            cout << x.first << \" \" << x.second << \"\\n\";\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define fr first\n#define sc second\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n\nvector<P> ret;\n\nvoid pos(int i){\n\tfor(int j=0;j<i;j++){\n\t\tret.push_back(P(j+1,0));\n\t}\n\tret.push_back(P(i,1));\n\tret.push_back(P(i+1,1));\n\tret.push_back(P(i+1,0));\n\tret.push_back(P(i,0));\n\tfor(int j=i-1;j>=0;j--){\n\t\tret.push_back(P(j,0));\n\t}\n}\nvoid neg(int i){\n\tfor(int j=0;j<i;j++){\n\t\tret.push_back(P(j+1,0));\n\t}\n\tret.push_back(P(i+1,0));\n\tret.push_back(P(i+1,1));\n\tret.push_back(P(i,1));\n\tret.push_back(P(i,0));\n\tfor(int j=i-1;j>=0;j--){\n\t\tret.push_back(P(j,0));\n\t}\n}\n\nvector<P> f(vector<P> vec,int t){\n\tint cnt[10];\n\tfor(int i=0;i<vec.size();i++){\n\t\tcnt[vec[i].sc]++;\n\t}\n\tint MIN=100;\n\tint id=-1;\n\tfor(int i=0;i<10;i++){\n\t\tif(cnt[i]==0)continue;\n\t\tif(MIN>cnt[i]){\n\t\t\tMIN=cnt[i];\n\t\t\tid=i;\n\t\t}\n\t}\n\tvector<P> ret;\n\tfor(int i=0;i<vec.size();i++){\n\t\tif(vec[i].sc!=id)ret.push_back(vec[i]);\n\t\telse {\n\t\t\tif(vec[i].fr==1){\n\t\t\t\tret.push_back(P(1,id));\n\t\t\t\tret.push_back(P(1,t));\n\t\t\t\tret.push_back(P(-1,id));\n\t\t\t\tret.push_back(P(-1,t));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret.push_back(P(1,t));\n\t\t\t\tret.push_back(P(1,id));\n\t\t\t\tret.push_back(P(-1,t));\n\t\t\t\tret.push_back(P(-1,id));\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\t\n\nint main(){\n\tint n;\n\tstring s;\n\tcin>>n>>s;\n\t\n\tint a[300];\n\tfor(int i=0;i<(1<<n);i++)a[i]=s[i]-'0';\n\t\n\tbool used[300];\n\tmemset(used,0,sizeof used);\n\t\n\tint b[300];\n\tfor(int i=0;i<300;i++)b[i]=1;\n\t\n\tfor(int x=1;x<(1<<n);x++){\n\t\tused[x]=true;\n\t\t//if(used[x])cerr<<x<<endl;\n\t\tfor(int y=0;y<x;y++){\n\t\t\tif((x&y)==y)if(used[y])used[x]=false;\n\t\t}\n\t\t//if(used[x])cerr<<x<<endl;\n\t\tfor(int y=0;y<(1<<n);y++){\n\t\t\tif((x&y)==x)if(a[y]==1)used[x]=false;\n\t\t}\n\t\t//if(used[x])cerr<<x<<endl;\n\t\tif(used[x]){\n\t\t\tfor(int y=0;y<(1<<n);y++){\n\t\t\t\tif((x&y)==x)b[y]=0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool ok=true;\n\tfor(int i=0;i<(1<<n);i++)ok&=a[i]==b[i];\n\tif(!ok){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tret.push_back(P(0,0));\n\tfor(int x=0;x<(1<<n);x++){\n\t\tif(!used[x])continue;\n\t\tint cnt=0;\n\t\tint c[10];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif((x>>i)&1)c[cnt++]=i;\n\t\t}\n\t\t\n\t\tvector<P> vec;\n\t\tvec.push_back(P(1,c[0]));\n\t\tfor(int i=1;i<cnt;i++)vec=f(vec,c[i]);\n\t\tfor(int i=0;i<vec.size();i++){\n\t\t\tif(vec[i].fr==1)pos(vec[i].sc);\n\t\t\telse neg(vec[i].sc);\n\t\t}\n\t\t\n\t\t/*if(cnt==1){\n\t\t\tpos(c[0]);\n\t\t}\n\t\telse if(cnt==2){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[1]);\n\t\t}\n\t\telse if(cnt==3){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[2]);\n\t\t}\n\t\telse if(cnt==4){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tneg(c[3]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[3]);\n\t\t\tpos(c[2]);\n\t\t\tneg(c[3]);\n\t\t\tneg(c[2]);\n\t\t}\n\t\telse if(cnt==5){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[1]);\n\t\t\tpos(c[4]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[4]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tneg(c[3]);\n\t\t\tpos(c[0]);\n\t\t\tpos(c[4]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[4]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tpos(c[2]);\n\t\t}\n\t\telse if(cnt==6){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[1]);\n\t\t\tpos(c[4]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[4]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tneg(c[3]);\n\t\t\tpos(c[0]);\n\t\t\tpos(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[4]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[4]);\n\t\t\tneg(c[1]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tpos(c[2]);\n\t\t}\n\t\telse if(cnt==7){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[1]);\n\t\t\tpos(c[6]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[6]);\n\t\t\tpos(c[4]);\n\t\t\tpos(c[6]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[4]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tneg(c[3]);\n\t\t\tpos(c[0]);\n\t\t\tpos(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[4]);\n\t\t\tpos(c[1]);\n\t\t\tpos(c[6]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[4]);\n\t\t\tpos(c[6]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[1]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tpos(c[2]);\n\t\t}\n\t\telse if(cnt==7){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[1]);\n\t\t\tpos(c[6]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[6]);\n\t\t\tpos(c[4]);\n\t\t\tpos(c[7]);\n\t\t\tneg(c[4]);\n\t\t\tneg(c[7]);\n\t\t\tpos(c[6]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[1]);\n\t\t\tpos(c[7]);\n\t\t\tpos(c[4]);\n\t\t\tneg(c[7]);\n\t\t\tneg(c[4]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tneg(c[3]);\n\t\t\tpos(c[0]);\n\t\t\tpos(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[4]);\n\t\t\tpos(c[7]);\n\t\t\tneg(c[4]);\n\t\t\tneg(c[7]);\n\t\t\tpos(c[1]);\n\t\t\tpos(c[6]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[6]);\n\t\t\tpos(c[7]);\n\t\t\tpos(c[4]);\n\t\t\tneg(c[7]);\n\t\t\tneg(c[4]);\n\t\t\tpos(c[6]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[1]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tpos(c[2]);\n\t\t}*/\n\t}\n\t\n\t/*for(int i=0;i<n;i++){\n\t\tif(used[i][i]){\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t}\n\t\t\tret.push_back(P(i,1));\n\t\t\tret.push_back(P(i+1,1));\n\t\t\tret.push_back(P(i+1,0));\n\t\t\tret.push_back(P(i,0));\n\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\tret.push_back(P(j,0));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int k=i+1;k<n;k++){\n\t\t\tif(used[i][k]){\n\t\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(i,1));\n\t\t\t\tret.push_back(P(i+1,1));\n\t\t\t\tret.push_back(P(i+1,0));\n\t\t\t\tret.push_back(P(i,0));\n\t\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(k,1));\n\t\t\t\tret.push_back(P(k+1,1));\n\t\t\t\tret.push_back(P(k+1,0));\n\t\t\t\tret.push_back(P(k,0));\n\t\t\t\tfor(int j=k-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(i+1,0));\n\t\t\t\tret.push_back(P(i+1,1));\n\t\t\t\tret.push_back(P(i,1));\n\t\t\t\tret.push_back(P(i,0));\n\t\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(k+1,0));\n\t\t\t\tret.push_back(P(k+1,1));\n\t\t\t\tret.push_back(P(k,1));\n\t\t\t\tret.push_back(P(k,0));\n\t\t\t\tfor(int j=k-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}*/\n\t\n\tassert(ret.size()<=250000);\n\t\n\tputs(\"Possible\");\n\tprintf(\"%d\\n\",(int)(ret.size())-1);\n\tfor(int i=0;i<ret.size();i++){\n\t\tprintf(\"%d %d\\n\",ret[i].fr,ret[i].sc);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<vector>\n#include<queue>\n#include<iostream>\n#include<fstream>\n#include<string>\n#include<cassert>\n#include<algorithm>\n#include<random>\n#include<map>\n#include<set>\n#include <bitset>\n#include<ctime>\n\nusing namespace std;\n\n//int mod = 998244353;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\ntypedef vector<int>vi;\ntypedef vector<ll>vl;\ntypedef vector<char>vc;\ntypedef vector<string>vs;\ntypedef vector<vector<int>>vii;\ntypedef vector<vector<char>>vvc;\ntypedef vector<vector<ll>>vll;\ntypedef vector< pair<ll, ll>>vpll;\ntypedef vector< pair<ld, ld>>vpld;\ntypedef vector< pair<int, int>>vpi;\ntypedef pair<ld, ld>pld;\n#define mp make_pair\n#define pb push_back\n\nconst int mod = 998244353;\nint add(int a, int b)\n{\n\tint c = a + b;\n\tif (c >= mod)\n\t{\n\t\tc -= mod;\n\t}\n\treturn c;\n}\nint dif(int a, int b)\n{\n\tint c = a - b;\n\tif (c < 0)\n\t{\n\t\tc += mod;\n\t}\n\treturn c;\n}\nint mlt(int a, int b)\n{\n\tll c = a * 1LL * b;\n\treturn c % mod;\n}\nint ibit(int n, int i)\n{\n\treturn ((n >> i) & 1);\n}\nvoid outp(vii &ou)\n{\n\tfor (int i = 0; i < ou.size(); i++)\n\t{\n\t\tfor (int j = 0; j < ou[i].size(); j++)\n\t\t{\n\t\t\tcout << ou[i][j] << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n}\nint bp(int x, int y)\n{\n\tif (y == 0)\n\t{\n\t\treturn 1;\n\t}\n\tint a = 0;\n\tif (!(y % 2))\n\t{\n\t\ta = bp(x, y / 2);\n\t}\n\treturn (y % 2) ? mlt(bp(x, y - 1), x) : mlt(a, a);\n}\nint obr(int x)\n{\n\treturn bp(x, mod - 2);\n}\nconst int maxn = 2000007;\nint fact[2000007], ofact[2000007];\nvoid prec()\n{\n\tfact[0] = 1;\n\tofact[0] = 1;\n\tfor (int i = 1; i < maxn; i++)\n\t{\n\t\tfact[i] = mlt(fact[i - 1], i);\n\t}\n\t//cerr << \"sdsds\" << endl;\n\tofact[maxn - 1] = obr(fact[maxn - 1]);\n\tfor (int i = maxn - 2; i > 0; i--)\n\t{\n\t\tofact[i] = mlt(ofact[i + 1], i + 1);\n\t}\n}\nint c(int a, int b)\n{\n\tif (a == 0)return 1;\n\treturn ((a <= b) && (a >= 0)) ? mlt(fact[b], mlt(ofact[a], ofact[b - a])) : 0;\n}\nll gcd(ll x, ll y)\n{\n\t//cerr << x << y << endl;\n\tif (x == 0)return y;\n\treturn(x > y) ? gcd(y, x) : gcd(y%x, x);\n}\nint obr2(int n)\n{\n\tint x = fact[n - 1];\n\tx = mlt(x, ofact[n]);\n\treturn x;\n}\nvoid crv(int nn, vpi &v)\n{\n\tcerr << nn << endl;\n\tif (nn > 0) {\n\t\tint n = nn;\n\t\tfor (int i = 0; i < n; i++)v.pb({ i + 1, 0 });\n\t\tv.pb({ n,1 });\n\t\tv.pb({ n - 1, 1 });\n\t\tfor (int i = n - 1; i >= 0; i--)v.pb({ i, 0 });\n\t}\n\tif (nn < 0) {\n\t\tint n = -nn;\n\t\tfor (int i = 0; i < n - 1; i++)v.pb({ i + 1, 0 });\n\t\tv.pb({ n - 1,1 });\n\t\tv.pb({ n , 1 });\n\t\tfor (int i = n; i >= 0; i--)v.pb({ i, 0 });\n\t}\n}\nvoid solve(istream &cin = std::cin, ostream &cout = std::cout)\n{\n\tvii imb(9);\n\timb[0] = { 1 };\n\tfor (int i = 1; i <= 8; i++)\n\t{\n\t\tfor (int j = 0; j < imb[i - 1].size(); j++)imb[i].pb(imb[i - 1][j]);\n\t\timb[i].pb(i + 1);\n\t\tfor (int j = imb[i - 1].size(); j >= 0; j--)imb[i].pb((-1)*imb[i - 1][j]);\n\t\timb[i].pb(-i - 1);\n\t}\n\t//cerr << \"here\" << endl;\n\tint n;\n\tcin >> n;\n\tvi good(1 << n);\n\tfor (int i = 0; i < good.size(); i++)\n\t{\n\t\tchar c;\n\t\tcin >> c;\n\t\tgood[i] = c - '0';\n\t}\n\tint val = 0;\n\t//\tcerr << 433 << endl;\n\tfor (int a = 0; a < good.size(); a++)\n\t\tfor (int b = 0; b < good.size(); b++)\n\t\t\tif ((a | b) == b)\n\t\t\t\tif ((!good[a]) && (good[b]))\n\t\t\t\t{\n\t\t\t\t\t//\tcerr << a << ' ' << b << endl;\n\t\t\t\t\tval = 1;\n\t\t\t\t}\n\t//\tcerr << 5 << ' ' << 7 << ' ' << (5 | 7) << endl;\n\tif (val)cout << \"Impossible\" << endl;\n\telse\n\t{\n\t\tcout << \"Possible\" << endl;\n\t\t//cerr << 1111 << endl;\n\t\tvpi ay = { { 0,0 } };\n\t\tfor (int m = 0; m < good.size(); m++)\n\t\t{\n\t\t\t//cerr << m << endl;\n\t\t\tif (!good[m])\n\t\t\t{\n\t\t\t\tcerr << m << endl;\n\t\t\t\tvi v;\n\t\t\t\tfor (int i = 0; i <= 8; i++)if (ibit(m, i))v.pb(i);\n\t\t\t\tcerr << m << ' ' << v.size() << endl;\n\t\t\t\tif (v.size() > 8)cout << \"111\" << endl;\n\t\t\t\tfor (int i = 0; i < imb[v.size() - 1].size(); i++)\n\t\t\t\t{\n\t\t\t\t\tcerr << imb[v.size() - 1][i] << endl;\n\t\t\t\t\t//\tcerr << i << endl;\n\t\t\t\t\tif (imb[v.size()][i] > 0)crv(v[imb[v.size() - 1][i] - 1] + 1, ay);\n\t\t\t\t\tif (imb[v.size()][i] < 0)crv(-v[(-imb[v.size() - 1][i]) - 1] - 1, ay);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ay.size() - 1 << endl;\n\t\tfor (int i = 0; i < ay.size(); i++)cout << ay[i].first << ' ' << ay[i].second << endl;\n\t}\n}\nint main()\n{\n\tsolve();\n\tint n;\n\tcin >> n;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int N=1<<10;\nint n;\nchar s[N];\nint p[N];\nvector<pair<int,int> > solve(int S,int now)\n{\n\tcerr<<\"Solve\"<<S<<\" \"<<now<<\"\\n\";\n\tvector<pair<int,int> >res;\n\tfor(int i=now+1;i<n;i++)\n\t\tif(S&(1<<i))\n\t\t{\n\t\t\tvector<pair<int,int> > t=solve(S,i);\n\t\t\tfor(int j=now;j<=i-1;j++)\n\t\t\t\tres.push_back(make_pair(j,1));\n\t\t\tfor(auto [x,y]:t)\n\t\t\t\tres.push_back(make_pair(x,y));\n\t\t\tfor(int j=i;j>=now;j--)\n\t\t\t\tres.push_back(make_pair(j,1));\n\t\t\tres.push_back(make_pair(now,0));\n\t\t\tres.push_back(make_pair(now+1,0));\n\t\t\tfor(int j=now+1;j<=i;j++)\n\t\t\t\tres.push_back(make_pair(j,1));\n\t\t\tfor(auto [x,y]:t)\n\t\t\t\tres.push_back(make_pair(x,y^1));\n\t\t\tfor(int j=i-1;j>=now+1;j--)\n\t\t\t\tres.push_back(make_pair(j,1));\n\t\t\tres.push_back(make_pair(now+1,0));\n\t\t\tres.push_back(make_pair(now,0));\n\t\t\treturn res;\n\t\t}\n\tres.push_back(make_pair(now,1));\n\tres.push_back(make_pair(now+1,1)); \n\tres.push_back(make_pair(now+1,0));\n\tres.push_back(make_pair(now,0));\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s);\n\tfor(int i=0;i<(1<<n);i++)\n\t\tp[i]=s[i]-'0';\n\tif(p[0]==0)\n\t{\n\t\tprintf(\"Impossible\");\n\t\treturn 0;\n\t}\n\tfor(int s=0;s<(1<<n);s++)\n\t\tif(p[s]==1)\n\t\t\tfor(int i=s;i;i=(i-1)&s)\n\t\t\t\tif(p[i]==0)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"Impossible\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\tvector<pair<int,int> >ans;\n\tans.push_back(make_pair(0,0));\n\tfor(int s=1;s<(1<<n);s++)\n\t\tif(p[s]==0)\n\t\t{\n\t\t\tbool flag=true;\n\t\t\tfor(int i=(s-1)&s;i;i=(i-1)&s)\n\t\t\t\tif(p[i]==0)\n\t\t\t\t{\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif(!flag) continue;\n\t\t\tvector<pair<int,int> >res;\n\t\t\tvector<pair<int,int> >t;\n\t\t\tint u=0;\n\t\t\tfor(u=0;u<n;u++)\n\t\t\t\tif(s&(1<<u))\n\t\t\t\t{\n\t\t\t\t\tt=solve(s,u);\n//\t\t\t\t\tcerr<<\"res\"<<\"\\n\";\n//\t\t\t\t\tfor(auto [x,y]:t)\n//\t\t\t\t\t\tcerr<<x<<\" \"<<y<<\"\\n\";\n//\t\t\t\t\tcerr<<\"EOF\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif(ans.back()!=make_pair(0,0)) res.push_back(make_pair(0,0));\n\t\t\tfor(int i=0;i<=u-1;i++)\n\t\t\t\tres.push_back(make_pair(i,1));\n\t\t\tfor(auto [x,y]:t)\n\t\t\t\tres.push_back(make_pair(x,y));\n\t\t\tfor(int i=u;i>=0;i--)\n\t\t\t\tres.push_back(make_pair(i,1));\n\t\t\tres.push_back(make_pair(0,0));\n\t\t\tfor(auto [x,y]:res)\n\t\t\t\tans.push_back(make_pair(x,y));\n\t\t}\n\tprintf(\"Possible\\n\");\n\tint len=ans.size()-1;\n\tprintf(\"%d\\n\",len);\n\tfor(auto [x,y]:ans)\n\t\tprintf(\"%d %d\\n\",x,y);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nint n;\nchar s[1010];\nvector<PII> ans,c,trash;\nvector<PII> build(VI w) {\n\tif (SZ(w)==1) return vector<PII>{{w[0],0}};\n\tvector<PII> z{{w[0],0},{w[1],0},{w[0],1},{w[1],1}};\n\trep(i,2,SZ(w)) {\n\t\tvector<PII> nz=z; \n\t\tz.pb({w[i],0});\n\t\treverse(all(nz));\n\t\tfor (auto p:nz) z.pb({p.fi,p.se^1});\n\t\tz.pb({w[i],1});\n\t}\n\treturn z;\n}\nint zz;\nint main() {\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s);\n\t//rep(i,0,(1<<n)) s[i]=(__builtin_popcount(i)<5)+'0';\n\trep(i,0,(1<<n)) rep(j,0,(1<<n)) if ((j&i)==i&&s[i]=='0'&&s[j]=='1') {\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\trep(i,0,(1<<n)) if (s[i]=='0') {\n\t\tbool cc=0;\n\t\trep(j,0,(1<<n)) if ((i&j)==j&&i!=j&&s[j]=='0') cc=1;\n\t\tif (cc) continue;\n\t\tVI w;\n\t\tfprintf(stderr,\"%d\\n\",i);\n\t\trep(j,0,n) if (i&(1<<j)) w.pb(j);\n\t\tauto x=build(w);\n\t\tfor (auto p:x) ans.pb(p);\n\t\trep(i,0,100) {\n\t\t\tint x=rnd(n);\n\t\t\tans.pb(mp(x,0)),trash.pb(mp(x,0));\n\t\t}\n\t}\n\t//fprintf(stderr,\"%d\\n\",zz);\n\treverse(all(trash));\n\tfor (auto p:trash) ans.pb(mp(p.fi,p.se^1));\n\tputs(\"Possible\");\n\tint pos=0;\n\tc.pb(mp(0,0));\n\tfor (auto p:ans) {\n\t\t//printf(\"pp %d %d\\n\",p.fi,p.se);\n\t\tif (p.se==0) {\n\t\t\twhile (pos<p.fi) {\n\t\t\t\tpos+=1;\n\t\t\t\tc.pb(mp(pos,0));\n\t\t\t}\n\t\t\twhile (pos>p.fi) {\n\t\t\t\tpos-=1;\n\t\t\t\tc.pb(mp(pos,0));\n\t\t\t}\n\t\t\tc.pb(mp(pos,1));\n\t\t\tc.pb(mp(pos+1,1));\n\t\t\tc.pb(mp(pos+1,0));\n\t\t\tpos+=1;\n\t\t} else {\n\t\t\twhile (pos<p.fi+1) {\n\t\t\t\tpos+=1;\n\t\t\t\tc.pb(mp(pos,0));\n\t\t\t}\n\t\t\twhile (pos>p.fi+1) {\n\t\t\t\tpos-=1;\n\t\t\t\tc.pb(mp(pos,0));\n\t\t\t}\n\t\t\tc.pb(mp(pos,1));\n\t\t\tc.pb(mp(pos-1,1));\n\t\t\tc.pb(mp(pos-1,0));\n\t\t\tpos-=1;\n\t\t}\n\t}\n\twhile (pos>0) {\n\t\tpos--;\n\t\tc.pb(mp(pos,0));\n\t}\n\tassert(SZ(c)<=250000);\n\tprintf(\"%d\\n\",SZ(c)-1);\n\tfor (auto x:c) printf(\"%d %d\\n\",x.fi,x.se);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,L;\nstring A;\nint ismin[256];\n\n\nvector<pair<int,int>> construct(int mask) {\n\tvector<pair<int,int>> V;\n\t\n\tint i;\n\tFOR(i,N) if(mask&(1<<i)) {\n\t\tif(__builtin_popcount(mask)==1) {\n\t\t\tV.push_back({i,1});\n\t\t\tV.push_back({i+1,1});\n\t\t\tV.push_back({i+1,0});\n\t\t\tV.push_back({i,0});\n\t\t}\n\t\telse {\n\t\t\tvector<pair<int,int>> W=construct(mask^(1<<i));\n\t\t\tV.push_back({i,1});\n\t\t\twhile(V.back().first+1<W[0].first) {\n\t\t\t\tV.push_back(V.back());\n\t\t\t\tV.back().first++;\n\t\t\t}\n\t\t\tFORR(w,W) V.push_back(w);\n\t\t\twhile(V.back().first>i) {\n\t\t\t\tV.push_back(V.back());\n\t\t\t\tV.back().first--;\n\t\t\t}\n\t\t\tV.push_back({i,0});\n\t\t\treverse(ALL(W));\n\t\t\twhile(V.back().first+1<W[0].first) {\n\t\t\t\tV.push_back(V.back());\n\t\t\t\tV.back().first++;\n\t\t\t}\n\t\t\tFORR(w,W) V.push_back(w);\n\t\t\twhile(V.back().first>i+1) {\n\t\t\t\tV.push_back(V.back());\n\t\t\t\tV.back().first--;\n\t\t\t}\n\t\t\tV.push_back({i+1,0});\n\t\t\tV.push_back({i,0});\n\t\t}\n\t\tbreak;\n\t}\n\treturn V;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>A;\n\tL=1<<N;\n\tFORR(c,A) c-='0';\n\tFOR(x,L) FOR(y,L) if((x&y)==y && A[x] && A[y]==0) return _P(\"Impossible\\n\");\n\tFOR(x,L) ismin[x]=A[x]==0;\n\tFOR(x,L) if(A[x]==0) FOR(y,L) if((x&y)==y && y<x && A[y]==0) ismin[y]=0;\n\t\n\tvector<pair<int,int>> W;\n\tW.push_back({0,0});\n\tFOR(x,L) if(A[x]==0) {\n\t\tvector<pair<int,int>> V=construct(x);\n\t\tFOR(i,V[0].first) W.push_back({i,1});\n\t\tFORR(v,V) W.push_back(v);\n\t\tfor(i=V[0].first-1;i>=0;i--) W.push_back({i,0});\n\t}\n\tcout<<\"Possible\"<<endl;\n\tcout<<W.size()-1<<endl;\n\tFORR(w,W) cout<<w.first<<\" \"<<w.second<<endl;\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(\"wzpakking\")\n#define y1 ysghysgsygsh\nusing namespace std;\nchar s[500];\nint n,top,q[10],flg[500];\npii ans[50005];\nvoid walk(int x,int px,int y,int py){\n\tfor (;x<y;) ans[++top]=pii(++x,px);\n\tfor (;x>y;) ans[++top]=pii(--x,px);\n}\nvoid construct(int l){\n\tif (l==*q){\n\t\tans[++top]=pii(q[l]+1,1);\n\t\tans[++top]=pii(q[l]+1,0);\n\t\tans[++top]=pii(q[l],0);\n\t\tans[++top]=pii(q[l],1);\n\t\treturn;\n\t}\n\twalk(q[l],1,q[l+1],1);\n\tconstruct(l+1);\n\twalk(q[l+1],1,q[l],1);\n\tans[++top]=pii(q[l],0);\n\tans[++top]=pii(q[l+1],0);\n\tans[++top]=pii(q[l+1],1);\n\twalk(q[l]+1,1,q[l+1],1);\n\tconstruct(l+1);\n\twalk(q[l+1],1,q[l],1);\n}\n/*\nULLUULLUULLUULLU\nUULLLLUUUULLLLUU\nLLUU\n*/\nvoid constructa(int x){\n\tcout<<x<<endl;\n\t*q=0;\n\tFor(i,0,n-1) if (x&(1<<i)) q[++*q]=i;\n\twalk(0,1,q[1],1);\n\tconstruct(1);\n\twalk(q[1],1,0,1);\n}\nint main(){\n\tscanf(\"%d%s\",&n,s);\n\tFor(i,0,(1<<n)-1) For(j,0,(1<<n)-1)\n\t\tif ((i&j)==i&&s[i]=='0'&&s[j]=='1')\n\t\t\treturn puts(\"Impossible\"),0;\n\tFor(i,0,(1<<n)-1)\n\t\tFor(j,0,(1<<n)-1)\n\t\t\tif (s[i]=='0'&&(i&j)==i&&j!=i) flg[j]=1;\n\tans[top=1]=pii(0,1);\n\tFor(i,0,(1<<n)-1)\n\t\tif (s[i]=='0'&&!flg[i])\n\t\t\tconstructa(i);\n\tprintf(\"Possible\\n%d\\n\",top-1);\n\tFor(i,1,top) cout<<ans[i].fi<<' '<<ans[i].se<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define rrng(a) a.rbegin(),a.rend()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define eb emplace_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ntypedef vector<T> vt;\ninline int getInt() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define dame { puts(\"Impossible\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\nconst int MX = 200005;\n\nvp f(vi a) {\n  if (sz(a) == 0) {\n    vp res;\n    res.eb(0,0);\n    res.eb(0,1);\n    return res;\n  }\n  int x = a.back();\n  a.pop_back();\n  rep(i,sz(a)) a[i] -= x+1;\n  vp d = f(a);\n  rep(i,sz(d)) d[i].fi += x+1;\n  vp res;\n  res.eb(0,0);\n  rep(i,x+1) res.eb(i+1,0);\n  res.insert(res.end(), d.begin()+1, d.end());\n  res.eb(x+1,0);\n  drep(i,x+1) res.eb(i,0);\n  res.eb(0,1);\n  rep(i,x+1) res.eb(i+1,1);\n  reverse(rng(d));\n  res.insert(res.end(), d.begin()+1, d.end());\n  res.eb(x+1,1);\n  drep(i,x+1) res.eb(i,1);\n  return res;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  string st;\n  cin>>st;\n  int n2 = 1<<n;\n  vi a(n2);\n  rep(i,n2) a[i] = st[i]-'0';\n  rep(i,n2) a[i] ^= 1;\n  rep(i,n2) {\n    if (a[i]) continue;\n    for (int j = i;; j = (j-1)&i) {\n      if (a[j]) dame;\n      if (!j) break;\n    }\n  }\n  if (a[0]) dame;\n  cout<<\"Possible\"<<endl;\n  vp ans;\n  rep(i,n2) {\n    if (!a[i]) continue;\n    vi s;\n    rep(j,n) if (i>>j&1) s.pb(j);\n    reverse(rng(s));\n    vp now = f(s);\n    ans.insert(ans.end(), rng(now));\n  }\n  ans.eb(0,0);\n  cout<<sz(ans)-1<<endl;\n  for (P p : ans) {\n    cout<<p.fi<<\" \"<<p.se<<endl;\n  }\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing ll = long long;\nusing ull = unsigned long long;\nusing namespace std;\nconst int INF = 1e10;\nconst int MOD = 1e9 + 7;\n#define dump(x)                             \\\n    if (dbg) {                              \\\n        cerr << #x << \" = \" << (x) << endl; \\\n    }\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define FOR1(n) for (ll i = 0; i < (n); ++i)\n#define FOR2(i, n) for (ll i = 0; i < (n); ++i)\n#define FOR3(i, a, b) for (ll i = (a); i < (b); ++i)\n#define FOR4(i, a, b, c) for (ll i = (a); i < (b); i += (c))\n#define FOR(...) overload4(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)\n#define FORR(i, a, b) for (int i = (a); i <= (b); ++i)\n#define bit(n, k) ((n >> k) & 1) /*nのk bit目*/\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\nvoid Yes(bool flag = true) {\n    if (flag)\n        cout << \"Yes\" << endl;\n    else\n        cout << \"No\" << endl;\n}\nvoid No(bool flag = true) {\n    Yes(!flag);\n}\nvoid YES(bool flag = true) {\n    if (flag)\n        cout << \"YES\" << endl;\n    else\n        cout << \"NO\" << endl;\n}\nvoid NO(bool flag = true) {\n    YES(!flag);\n}\n#define pb emplace_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define all(v) (v).begin(), (v).end()\n#define SZ(x) ((int)(x).size())\n#define P pair<int, int>\n//#define V vector<int>\n//#define S set<int>\n#define itn int\nbool dbg = false;\n\nint N;\nstring A;\nbool checked[111010];\nbool out[111010];\n\nvector<int> x, y;\n\nvoid go(int gx) {\n    int sx;\n    int ys;\n    sx = x[(int)x.size() - 1];\n    ys = y[(int)y.size() - 1];\n    if (sx > gx) {\n        while (sx != gx) {\n            sx--;\n            x.pb(sx);\n            y.pb(ys);\n        }\n    } else if (sx < gx) {\n        while (sx != gx) {\n            sx++;\n            x.pb(sx);\n            y.pb(ys);\n        }\n    }\n}\nvoid chy() {\n    x.pb(x[(int)x.size() - 1]);\n    y.pb(!y[(int)y.size() - 1]);\n}\n\nvoid fill(int T, bool nikai = false) {\n    int cnt = __builtin_popcount(T);\n    if (cnt == 1) {\n        int nxt = __builtin_ffs(T) - 1;\n        go(nxt);\n        chy();\n        go(nxt + 1);\n        chy();\n        go(nxt);\n        chy();\n        go(nxt + 1);\n        chy();\n        go(nxt);\n        chy();\n        go(nxt + 1);\n        chy();\n        go(nxt);\n        return;\n    } else {\n        int n1 = __builtin_ffs(T) - 1;\n        T -= (1 << n1);\n        int n2 = __builtin_ffs(T) - 1;\n        int n3 = n2;\n        FOR(N) {\n            if ((1 << i) & T) {\n                n3 = i;\n            }\n        }\n        n3++;\n\n        go(n1);\n        chy();\n        go(n1 + 1);\n        chy();\n        go(n2);\n        chy();\n        if (n2 + 1 != n3) {\n            go(n2 + 1);\n            chy();\n            go(n3 - 1);\n            chy();\n        }\n        go(n3);\n        chy();\n        go(n2);\n        //ここで再帰\n        if (n2 + 1 != n3) {\n            fill(T);\n        }\n        go(n1 + 1);\n        chy();\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        if (n2 + 1 != n3) {\n            go(n3 - 1);\n            chy();\n            go(n2 + 1);\n            chy();\n        }\n        go(n2);\n        chy();\n        go(n1);\n\n        /*\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        go(n2);\n        chy();\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        go(n2);\n        chy();\n        go(n1);\n        */\n    }\n}\n\n\nvoid solve() {\n    bool flag = true;\n    int tmp = -1;\n    for (int T = 1; T < (1 << N); T++) {\n        if (A[T] == 1) {\n            continue;\n        }\n        if (checked[T]) {\n            continue;\n        }\n        out[T] = true;\n        if (__builtin_popcount(T) == 1) {\n            tmp = T;\n        }\n        for (int i = T; i < (1 << N); i = (i + 1) | T) {\n            // ここに処理を書く\n            if (A[i] == 1) {\n                flag = false;\n            }\n            checked[i] = true;\n        }\n    }\n    if (!flag) {\n        cout << \"Impossible\" << endl;\n        return;\n    }\n    cout << \"Possible\" << endl;\n\n    x.pb(0);\n    y.pb(0);\n\n    for (int T = 1; T < (1 << N); T++) {\n        if (out[T]) {\n            fill(T);\n        }\n    }\n    go(0);\n    int L = x.size();\n    cout << L - 1 << endl;\n\n    FOR(L) {\n        cout << x[i] << \" \" << y[i] << endl;\n    }\n}\n\nsigned main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cin >> N;\n    cin >> A;\n    for (auto& c : A)\n        c -= '0';\n\n\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define all(x) x.begin(),x.end()\n#define cmin(a,b) (a>b?a=b:a)\n#define cmax(a,b) (a<b?a=b:a)\n#define mem(a,k) memset(a,k,sizeof(a))\n#define lop(i,s,t) for(int i=s;i<(t);++i)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define fore(i,v) for(int i=g[v],d=es[i].d;i;i=es[i].nxt,d=es[i].d)\nusing namespace std;\n\n#ifdef CURIOUSCAT\n#define Pr(f,...) fprintf(stderr,f,##__VA_ARGS__),fflush(stderr)\n#else\n#define Pr(f,...) ;\n#endif\n\ntypedef long long ll;\n\ntemplate<typename T>\nvoid read(T &x){\n\tx=0; \n\tchar c;\n\tfor(c=getchar();!isdigit(c);c=getchar()); \n\tfor(;isdigit(c);c=getchar())x=x*10+c-'0'; \n}\n\nconst int N=1e6+50;\n\nint P;\nint mul(int a,int b){ return 1ll*a*b%P; }\nint add(int a,int b){ a+=b; return a>=P?a-P:a; }\nvoid upd(int &a,int b) { a=a+b>=P?a+b-P:a+b; }\nint sub(int a,int b){ a-=b; return a<0?a+P:a; }\nint gcd(int a,int b){ return !b?a:gcd(b,a%b); }\n\nint n;\nchar a[1<<9];\nint main(int argc,char *argv[]){\n#ifdef CURIOUSCAT\n#endif\n\tread(n); \n\tlop(s,0,(1<<n)){\n\t\tscanf(\" %c\",&a[s]); a[s]-='0';\n\t}\n\tlop(s,0,(1<<n)){\n\t\tint c0=0,c1=0;\n\t\tlop(i,0,n)if(s>>i&1){\n\t\t\tif(a[1<<i])++c1;else ++c0;\n\t\t}\n\t\tPr(\"%d,%d,%d,%d\\n\",s,c0,c1,a[s]); \n\t\tif((c0&&a[s])||(!c0&&!a[s])){\n\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\treturn 0; \n\t\t}\n\t}\n\tint cnt=0;\n\tlop(i,0,n)cnt+=!a[1<<i];\n\tcout<<\"possible\"<<endl;\n\tif(cnt==0){\n\t\tcout<<0<<endl;\n\t\tcout<<1<<\" \"<<1<<endl;\n\t}else{\n\t\tprintf(\"%d %d\\n\",0,0); \n\t\tfor(int i=0,p;i<n;i=p){\n\t\t\tif(!a[1<<i]){\n\t\t\t\tfor(p=i;p<n&&!a[1<<p];++p);\n\t\t\t\tprintf(\"%d %d\\n\",i,1);\n\t\t\t\tlop(z,0,p-i)printf(\"%d %d\\n\",i+z+1,1);\n\t\t\t}else{\n\t\t\t\tfor(p=i;p<n&&a[1<<p];++p);\n\t\t\t\tprintf(\"%d %d\\n\",i,0);\n\t\t\t\tlop(z,0,p-i)printf(\"%d %d\\n\",i+z+1,0);\n\t\t\t}\n\t\t}\n\t\tif(a[1<<(n-1)]){\n\t\t\tdec(i,n,0)printf(\"%d %d\\n\",i,-1);\n\t\t\tprintf(\"%d %d\\n\",0,0); \n\t\t}else{\n\t\t\tprintf(\"%d %d\\n\",n,0); \n\t\t\tdec(i,n,0)printf(\"%d %d\\n\",i,-1);\n\t\t\tprintf(\"%d %d\\n\",0,0); \n\t\t}\n\t}\n\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<list>\n#include<bitset>\n#include<stack>\n#include<memory>\n#include<numeric>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define REP(i, n) for(int i = 0;i < (n);i++)\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\n//const int mod=998244353;\nconst llint inf=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-10;\ntemplate <class T,class U>bool chmin(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool chmax(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(const vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(const vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n\nint main(void){\n\tint i,j,n;cin>>n;\n\tstring s;cin>>s;\n\tfor(i=0;i<(1<<n);i++){\n\t\tchar c='1';\n\t\tfor(j=0;j<n;j++){\n\t\t\t\n\t\t\tif((i&(1<<j))&&s[1<<j]=='0'){c='0';}\n\t\t}\n\t\tif(c!=s[i]){cout<<\"Impossible\"<<endl;return 0;}\n\t}\n\tcout<<\"Possible\"<<endl;\n\tint L=2*n;\n\tfor(i=0;i<n;i++){\n\t\tif(s[1<<i]=='0'){L+=2;}\n\t}\n\tcout<<L<<endl;\n\tcout<<\"0 0\"<<endl;\n\tfor(i=0;i<n;i++){\n\t\tif(s[1<<i]=='0'){cout<<i<<\" 1\"<<endl;cout<<i+1<<\" 1\"<<endl;}\n\t\tcout<<i+1<<\" 0\"<<endl;\n\t}\n\tfor(i=n-1;i>=0;i--){cout<<i<<\" 0\"<<endl;}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring inverse(string s){\n    string ans = s;\n    reverse(ans.begin(), ans.end());\n    for(int i = 0; i<s.size(); i++){\n        ans[i] = 2*'0' - ans[i];\n    }\n\n    return ans;\n}\n\nstring flips(string s){\n     string ans = s;\n    for(int i = 0; i<s.size(); i++){\n        ans[i] = 2*'0' - ans[i];\n    }\n\n    return ans;\n}\n\nint main(){\n    int n;\n    cin >> n;\n\n    char a[(1 << n)];\n    for(int i = 0; i<(1 << n); i++){\n        cin >> a[i];\n    }\n\n    string word = \"\";\n\n    for(int i = 0; i<(1 << n); i++){\n        bool flag = 0;\n        for(int j = 0; j<n; j++){\n            if(a[i] == '1' && a[i & (1 << j)] == '0' || a[0] == '0'){\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n\n            if(a[i] == '0' || (a[i] == '1' && a[i | (1 << j)] == '1' && i < (i | (1 << j))) ) flag = 1;\n        }\n\n        if(!flag){\n            string nw;\n            for(int j = 0; j<n; j++){\n                if(!(i & (1 << j))) nw.push_back('0' + j + 1);\n            }\n\n            if(word == \"\") word = word + nw + inverse(word);\n            else word = word + nw + inverse(word) + flips(nw);\n        }\n    }\n\n    vector<pair<int, int> > ans;\n    cout << \"Possible\" << endl;\n\n    ans.push_back({0, 0});\n    for(char c: word){\n        if(c < '0'){\n            int offset = '0' - c - 1;\n            for(int i = 1; i<=offset; i++){\n                ans.push_back({i, 0});\n            }\n            ans.push_back({offset, 1});\n            ans.push_back({offset + 1, 1});\n            for(int i = offset + 1; i>=0; i--){\n                ans.push_back({i, 0});\n            }\n        }\n\n        else{\n            int offset = c - '0' - 1;\n            for(int i = 1; i<=offset + 1; i++){\n                ans.push_back({i, 0});\n            }\n            ans.push_back({offset + 1, 1});\n            ans.push_back({offset, 1});\n            for(int i = offset; i>=0; i--){\n                ans.push_back({i, 0});\n            }\n        }\n    }\n\n    cout << ans.size() - 1 << endl;\n    for(auto p: ans){\n        cout << p.first << \" \" << p.second << endl;\n    }\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,r,i,j,k,m,b[277],x[250250],y[250250];\nchar s[277];\nint main() {\n  scanf(\"%d\",&n);\n  scanf(\"%s\",s);\n  for (i=0; i<n; i++) {\n    bool all=true;\n    for (j=0; j<(1<<n); j++) if ((j>>i)&1) all&=(s[j]=='0');\n    if (all) b[m++]=i;\n  }\n  for (j=0; j<(1<<n); j++) if (s[j]=='0') {\n    for (i=0; i<m; i++) if ((j>>b[i])&1) break;\n    if (i>=m) { puts(\"Impossible\"); return 0; }\n  }\n  puts(\"Possible\");\n  if (m==0) {\n    puts(\"0\");\n    puts(\"1 1\");\n    return 0;\n  }\n  for (i=0; i<m; i=j+1) {\n    if (i) for (k=b[i-1]+1; k<b[i]; k++) { x[r]=k; y[r++]=0; }\n    for (j=i; j+1<m && b[j+1]==b[j]+1; j++);\n    x[r]=b[i]; y[r++]=0;\n    for (k=b[i]; k<=b[j]+1; k++) { x[r]=k; y[r++]=1; }\n  }\n  for (k=b[m-1]+1; k>=b[0]; k--) { x[r]=k; y[r++]=0; }\n  printf(\"%d\\n\",r-1);\n  for (i=0; i<r; i++) printf(\"%d %d\\n\",x[i],y[i]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define fst first\n#define snd second\n#define fore(i,a,b) for(int i=a,ggdem=b;i<ggdem;++i)\n#define SZ(x) ((int)x.size())\n#define ALL(x) x.begin(),x.end()\n#define mset(a,v) memset((a),(v),sizeof(a))\n#define FIN ios::sync_with_stdio(0);cin.tie(0);cout.tie(0)\nusing namespace std;\ntypedef long long ll;\n\nvoid build(ll n, ll m){\n\tvector<pair<ll,ll>> res={{0,0}};\n\tfore(i,0,n){\n\t\tif(((1ll<<(n-1-i))&m)==0){\n\t\t\tfore(j,0,i)if(res.back()!=(pair<ll,ll>){j,0})res.pb({j,0});\n\t\t\tif(res.back()!=(pair<ll,ll>){i,0})res.pb({i,0});\n\t\t\tif(res.back()!=(pair<ll,ll>){i+1,0})res.pb({i+1,0});\n\t\t\tif(res.back()!=(pair<ll,ll>){i+1,1})res.pb({i+1,1});\n\t\t\tif(res.back()!=(pair<ll,ll>){i,1})res.pb({i,1});\n\t\t\tfore(j,0,i)if(res.back()!=(pair<ll,ll>){i-j,0})res.pb({i-j,0});\n\t\t}\n\t}\n\tif(res.back()!=(pair<ll,ll>){0,0})res.pb({0,0});\n\tcout<<SZ(res)-1<<\"\\n\";\n\tfor(auto i:res)cout<<i.fst<<\" \"<<i.snd<<\"\\n\";\n\t\n}\n\nint main(){FIN;\n\tll n; cin>>n;\n\tstring s; cin>>s;\n\tll m=0;\n\tfore(i,0,SZ(s)){\n\t\tif(s[i]=='1')m=m|i;\n\t}\n\tfore(i,0,SZ(s)){\n\t\tif((i|m)==m){\n\t\t\tif(s[i]=='0'){\n\t\t\t\tcout<<\"Impossible\"; return 0;\n\t\t\t}\n\t\t}else{\n\t\t\tif(s[i]=='1'){\n\t\t\t\tcout<<\"Impossible\"; return 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"Possible\\n\";\n\tbuild(n,m);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n// U1, D1, U2, D2, D1, U1, U2, D3, U3, U2, U3, D3, U2\n\n/*\nN = 2\nU2, U1, D1, U2, D2, D1, U1, D2\n\nN = 3\nU3, U2, U1, D1, U2, D2, D1, U1, D2, U3, D3, D2, U1, D1, D2, U2, D1, U1, U2, D3\n-->                                 <---->                                  <--\n\nS -> UN, S, UN, DN, rev(S), DN\n\nL -> 2L+4\n\nO(2^N)\n\n{0, 3, 4} -> NO     S1\n{1, 3} -> NO        S2\n\nS1 + S2\n\n{0, 2, 3} -> YES\n* */\n\nvoid impossible() {\n\tputs(\"Impossible\");\n\texit(0);\n}\n\nconst int UP = 0, DOWN = 1;\nvector<pair<int,int>> rec(vector<int> group) {\n\tif(group.empty()) {\n\t\treturn {};\n\t}\n\tint last = group.back();\n\tgroup.pop_back();\n\tvector<pair<int,int>> s = rec(group);\n\t// S -> UN, S, UN, DN, rev(S), DN\n\tvector<pair<int,int>> total;\n\tif(!s.empty()) total.emplace_back(last, UP);\n\tfor(auto p : s) {\n\t\ttotal.push_back(p);\n\t}\n\ttotal.emplace_back(last, UP);\n\ttotal.emplace_back(last, DOWN);\n\treverse(s.begin(), s.end());\n\tfor(auto p : s) {\n\t\ttotal.push_back(p);\n\t}\n\tif(!s.empty()) total.emplace_back(last, DOWN);\n\treturn total;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tstring s;\n\tcin >> s;\n\tvector<bool> possible(1 << n);\n\tfor(int mask = 0; mask < (1 << n); ++mask) {\n\t\tpossible[mask] = (s[mask] == '1');\n\t}\n\t// minimal subsets that give answer NO\n\tvector<int> minimal;\n\tfor(int mask = 0; mask < (1 << n); ++mask) {\n\t\tif(!possible[mask]) {\n\t\t\tbool is_minimal = true;\n\t\t\tfor(int bit = 0; bit < n; ++bit) {\n\t\t\t\tif(mask & (1 << bit)) {\n\t\t\t\t\tif(!possible[mask ^ (1 << bit)]) {\n\t\t\t\t\t\tis_minimal = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(is_minimal) {\n\t\t\t\tminimal.push_back(mask);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int x : minimal) {\n\t\tfor(int y : minimal) {\n\t\t\tif(x != y && ((x & y) == y)) {\n\t\t\t\timpossible();\n\t\t\t}\n\t\t}\n\t}\n\tfor(int mask = 0; mask < (1 << n); ++mask) {\n\t\tbool contains = false;\n\t\tfor(int x : minimal) {\n\t\t\tif((mask & x) == x) {\n\t\t\t\tcontains = true;\n\t\t\t}\n\t\t}\n\t\tif(contains == possible[mask]) {\n\t\t\timpossible();\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tdebug() << imie(minimal);\n\tpair<int,int> me{0, 0};\n\tvector<pair<int,int>> answer;\n\tanswer.push_back(me);\n\tauto f = [&](int x, int y) {\n\t\tassert(me.first == x || me.second == y);\n\t\tassert(me != make_pair(x, y));\n\t\tfor(int i = me.first + 1; i < x; ++i) {\n\t\t\tanswer.emplace_back(i, me.second);\n\t\t}\n\t\tfor(int i = me.first - 1; i > x; --i) {\n\t\t\tanswer.emplace_back(i, me.second);\n\t\t}\n\t\tme = {x, y};\n\t\tanswer.push_back(me);\n\t};\n\tfor(int mask : minimal) {\n\t\tvector<int> group;\n\t\tfor(int bit = 0; bit < n; ++bit) {\n\t\t\tif(mask & (1 << bit)) {\n\t\t\t\tgroup.push_back(bit);\n\t\t\t}\n\t\t}\n\t\tvector<pair<int,int>> moves = rec(group);\n\t\tdebug() << imie(moves);\n\t\tfor(pair<int,int> move : moves) {\n\t\t\tint x = move.first;\n\t\t\tint type = move.second;\n\t\t\tif(me.first < x) {\n\t\t\t\tf(x, 0);\n\t\t\t}\n\t\t\telse if(me.first > x + 1) {\n\t\t\t\tf(x + 1, 0);\n\t\t\t}\n\t\t\tif(type == UP) {\n\t\t\t\tf(me.first, 1);\n\t\t\t\tf(x + x + 1 - me.first, 1);\n\t\t\t\tf(me.first, 0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tf(x + x + 1 - me.first, 0);\n\t\t\t}\n\t\t}\n\t\tif(me != make_pair(0, 0)) {\n\t\t\tf(0, 0);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", (int) answer.size() - 1);\n\tfor(pair<int,int> p : answer) {\n\t\tprintf(\"%d %d\\n\", p.first, p.second);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\ndouble startTime;\ndouble getCurrentTime() {\n\treturn ((double)clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 277;\nint n;\nchar s[N];\nvector<pii> a[N];\n\nint main()\n{\n\tstartTime = (double)clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d %s\", &n, s);\n//\tn = 8;\n//\tfor (int i = 0; i < (1 << n); i++)\n//\t\ts[i] = '1';\n//\ts[(1 << n) - 1] = '0';\n\n\tif (s[0] == '0') {\n\t\tprintf(\"Impossible\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < (1 << n); i++)\n\t\tfor (int j = 0; j < (1 << n); j++) {\n\t\t\tif (s[i] == '0' && s[j] == '1' && ((i & j) == i)) {\n\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tint mask = 1 << i;\n\t\tfor (int j = 0; j <= i + 1; j++)\n\t\t\ta[mask].push_back(mp(j, 0));\n\t\ta[mask].push_back(mp(i + 1, 1));\n\t\ta[mask].push_back(mp(i, 1));\n\t\tfor (int j = i; j >= 0; j--)\n\t\t\ta[mask].push_back(mp(j, 0));\n\t}\n\tfor (int mask = 1; mask < (1 << n); mask++) {\n\t\tif (!a[mask].empty()) continue;\n\t\tint p = 0;\n\t\twhile(((mask >> p) & 1) == 0) p++;\n\t\tp = 1 << p;\n\t\tint q = mask ^ p;\n\t\ta[mask].push_back(mp(0, 0));\n\t\tfor (int i = 1; i < (int)a[p].size(); i++)\n\t\t\ta[mask].push_back(a[p][i]);\n\t\tfor (int i = 1; i < (int)a[q].size(); i++)\n\t\t\ta[mask].push_back(a[q][i]);\n\t\tfor (int i = (int)a[p].size() - 2; i >= 0; i--)\n\t\t\ta[mask].push_back(a[p][i]);\n\t\tfor (int i = (int)a[q].size() - 2; i >= 0; i--)\n\t\t\ta[mask].push_back(a[q][i]);\n\t}\n\tvector<pii> ans;\n\tans.push_back(mp(0, 0));\n\tfor (int i = 0; i < (1 << n); i++) {\n\t\tif (s[i] == '1') continue;\n\t\tbool ok = true;\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif ((j & i) == j)\n\t\t\t\tok &= s[j] == '1';\n\t\t}\n\t\tif (!ok) continue;\n\t\tfor (int j = 1; j < (int)a[i].size(); j++)\n\t\t\tans.push_back(a[i][j]);\n\t}\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d\\n\", (int)ans.size() - 1);\n\tfor (pii t : ans)\n\t\tprintf(\"%d %d\\n\", t.first, t.second);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <string>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> Pii;\n\nconst ll mod = 1000000007;\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  string s;\n  cin >> s;\n\n  vector<bool> a(1 << n);\n  for (int i = 0; i < (1 << n); i++) a[i] = s[i] - '0';\n\n  for (int i = 0; i < (1 << n); i++) {\n    bool good = true;\n    for (int j = 0; j < (1 << n); j++) {\n      bool obscured = false;\n      for (int k = 0; k < n; k++) {\n        bool point = j & (1 << k);\n        if (point && (i & (1 << k))) {\n          obscured = true;\n          break;\n        }\n      }\n      if (obscured == a[j]) {\n        good = false;\n        break;\n      }\n    }\n    if (good) {\n      vector<Pii> loop;\n      bool up = false;\n      for (int j = 0; j < n; j++) {\n        if (!up) {\n          loop.emplace_back(j, 0);\n          if (i & (1 << j)) {\n            loop.emplace_back(j, 1);\n            up = true;\n          }\n        }\n        else {\n          loop.emplace_back(j, 1);\n          if (!(i & (1 << j))) {\n            loop.emplace_back(j, 0);\n            up = false;\n          }\n        }\n      }\n      if (up) loop.emplace_back(n, 1);\n      for (int j = n; j >= 0; j--) loop.emplace_back(j, 0);\n\n      cout << \"Possible\" << endl;\n      cout << loop.size() - 1 << endl;\n      for (auto &x: loop) cout << x.first << \" \" << x.second << endl;\n      return 0;\n    }\n  }\n\n  //cout << \"Impossible\" << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define SZ(x) ((int)x.size())\n#define ALL(x) x.begin(),x.end()\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> T gcd(T a, T b){return !b?a:gcd(b,a%b);}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 266666;\nPii ans[N];int sz;\nint n,a[N];\nvoid solve(int S){\n\tvector<Pii> cur;bool first=1;\n\tper(i,n,1)if(S>>i-1&1){\n\t\tif(first){\n\t\t\tfirst=0;cur={mp(i,1),mp(i,0)};\n\t\t}\n\t\telse{\n\t\t\tvector<Pii>nxt={mp(i,1)};\n\t\t\tnxt.insert(nxt.end(),ALL(cur));\n\t\t\tnxt.pb(mp(i,1));\n\t\t\tnxt.pb(mp(i,0));\n\t\t\tper(i,SZ(cur)-1,0)nxt.pb(cur[i]);\n\t\t\tnxt.pb(mp(i,0));\n\t\t\tcur=nxt;\n\t\t}\n\t}\n\tint x=0,y=1;\n\tfor(auto i:cur){\n\t//\tcerr<<i.fi<<' '<<i.se<<endl;\n\t\tif(y!=i.se)ans[++sz]=mp(x,y^1),y^=1;\n\t\tint tar=x<i.fi?i.fi:i.fi-1;\n\t\twhile(x!=tar)ans[++sz]=mp(x+(tar>x?1:-1),y),x=ans[sz].fi;\n\t}\n\tPii i(0,1);\n\tif(y!=i.se)ans[++sz]=mp(x,y^1),y^=1;\n\twhile(x!=0)ans[++sz]=mp(x-1,y),x--;\n}\nvoid GG(){puts(\"Impossible\");exit(0);}\nint main() {\n\tchar ss[1<<8|3];read(n);scanf(\"%s\",ss);\n\trep(i,0,(1<<n)-1)a[i]=ss[i]=='1';\n\tif(!a[0])GG();\n\trep(s,1,(1<<n)-1)if(!a[s])rep(i,0,n-1)if(~s>>i&1)\n\t\tif(a[s^(1<<i)])GG();\n\tans[++sz]=mp(0,1);\n\trep(s,1,(1<<n)-1)if(!a[s]){\n\t\tbool ok=1;rep(i,0,n-1)if(s>>i&1)ok&=a[s^(1<<i)];\n\t\tif(ok)solve(s);\n\t}\n\tprintf(\"Possible\\n%d\\n\",sz-1);\n\trep(i,1,sz)printf(\"%d %d\\n\",ans[i].fi,ans[i].se);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\nint main() {\n    int n;\n    cin >> n;\n    string _s;\n    cin >> _s;\n    V<bool> s;\n    for (char c: _s) s.push_back(c == '1');\n    for (int i = 0; i < (1 << n); i++) {\n        for (int j = 0; j < n; j++) {\n            if (!s[i] && s[i | (1 << j)]) {                \n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n        }\n    }\n\n    using P = pair<int, int>;\n    V<P> ans;\n    for (int i = 0; i < (1 << n); i++) {\n        if (s[i]) continue;\n        bool minimum = true;\n        for (int j = 0; j < n; j++) {\n            if ((i & (1 << j)) && !s[i ^ (1 << j)]) {\n                minimum = false;\n                break;\n            }\n        }\n        if (!minimum) continue;\n        //\n        int st = 0;\n        while (!(i & (1 << st))) st++;\n        V<P> path = {P(st + 1, 0), P(st, 0), P(st, 1), P(st + 1, 1)};\n        for (int j = st + 1; j < n; j++) {\n            if (i & (1 << j)) {\n                V<P> npath = {P(j + 1, 0)};\n                npath.insert(npath.end(), path.begin(), path.end());\n                npath.push_back(P(j, 0));\n                npath.push_back(P(j + 1, 0));\n                npath.push_back(P(j + 1, 1));\n                npath.insert(npath.end(), path.rbegin(), path.rend());\n                npath.push_back(P(j, 1));\n                npath.push_back(P(j + 1, 1));\n                path = npath;\n            } else {\n                path.insert(path.begin(), P(j + 1, 0));\n                path.push_back(P(j, 0));\n                path.push_back(P(j + 1, 0));\n                path.push_back(P(j + 1, 1));\n            }\n        }\n        ans.insert(ans.end(), path.begin(), path.end());\n    }\n    ans.push_back(P(n, 0));\n/*    V<P> ans2;\n    for (auto p: ans) {\n        ans2.push_back(p);\n        int s = int(ans2.size());\n        if (s >= 3 && ans2[s - 1] == ans2[s - 3]) {\n            ans2.pop_back();\n            ans2.pop_back();\n        }\n    }\n    ans = ans2;*/\n\n    assert(ans.size() <= 250000);\n    cout << \"Possible\" << \"\\n\";\n    cout << int(ans.size()) - 1 << \"\\n\";\n    for (auto p: ans) {\n        cout << p.first << \" \" << p.second << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define I inline\n#define fi first\n#define se second\n#define R register\n#define LL long long\n#define mp make_pair\n#define reg register int\n#define pii pair<int,int>\n#define fo(i, a, b) for(reg i = a; i <= b; i++)\n#define fd(i, a, b) for(reg i = a; i >= b; i--)\n#define cr const reg&\nusing namespace std;\n\nI int _max(cr x, cr y) {return x > y ? x : y;}\nI int _min(cr x, cr y) {return x < y ? x : y;}\nI int read() {\n\treg x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n\treturn x * f;\n}\nI void ptt(LL x) {if(x >= 10) ptt(x / 10); putchar(x % 10 + '0');}\nI void put(LL x) {x < 0 ? putchar('-'), ptt(-x) : ptt(x);}\nI void pr1(LL x) {put(x), putchar(' ');}\nI void pr2(LL x) {put(x), puts(\"\");}\n\nchar ss[1 << 8];\nvector<pii> ans;\n\nstring rev(string s) {\n\treverse(s.begin(), s.end());\n\treturn s;\n}\n\nint main() {\n\treg n = read();\n\tscanf(\"%s\", ss);\n\tif(ss[0] == '0') {puts(\"Impossible\"); return 0;}\n\treg S = (1 << n) - 1;\n\tfo(i, 1, S) {\n\t\tif(ss[i] == '1') {\n\t\t\tfo(j, 0, n - 1) if(i >> j & 1) {\n\t\t\t\tif(ss[i ^ (1 << j)] == '0') {puts(\"Impossible\"); return 0;}\n\t\t\t}\n\t\t}\n\t} puts(\"Possible\");\n\treg now = 0; ans.push_back(pii{0, 0});\n\tfo(i, 1, S) if(ss[i] == '0'){\n\t\tbool bk = 0;\n\t\tfo(j, 0, n - 1) if(i >> j & 1) {\n\t\t\tif(ss[i ^ (1 << j)] == '0') {bk = 1; break;}\n\t\t} if(bk) break;\n\t\tstring q; q.clear();\n\t\tfd(j, n - 1, 0) if(i >> j & 1){\n\t\t\tstring c1 = {char('a' + j)}, c2 = {char('A' + j)};\n\t\t\tif(q.empty()) q += c1;\n\t\t\telse q = c1 + q + c2 + rev(q);\n\t\t} for(char c : q) {\n\t\t\treg p, o;\n\t\t\tif(isupper(c)) p = c - 'A', o = 1;\n\t\t\telse p = c - 'a', o = 0;\n\t\t\tfo(j, now + 1, p) ans.push_back(pii{j, 0});\n\t\t\tfd(j, now - 1, p) ans.push_back(pii{j, 0});\n\t\t\tnow = p;\n\t\t\tif(!o) {\n\t\t\t\tans.push_back(pii{p, 1});\n\t\t\t\tans.push_back(pii{p + 1, 1});\n\t\t\t\tans.push_back(pii{p + 1, 0});\n\t\t\t\tans.push_back(pii{p, 0});\n\t\t\t} else {\n\t\t\t\tans.push_back(pii{p + 1, 0});\n\t\t\t\tans.push_back(pii{p + 1, 1});\n\t\t\t\tans.push_back(pii{p, 1});\n\t\t\t\tans.push_back(pii{p, 0});\n\t\t\t}\n\t\t}\n\t} fd(j, now - 1, 0) ans.push_back(pii{j, 0});\n\tpr2((int)ans.size() - 1);\n\tfo(i, 0, (int)ans.size() - 1) pr1(ans[i].fi), pr2(ans[i].se);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define ar array\n\nconst int mxN=8;\nint n;\nstring s;\nvector<int> v;\n\nvector<ar<int, 2>> va(vector<ar<int, 2>> a, vector<ar<int, 2>> b) {\n\tvector<ar<int, 2>> c=a;\n\tc.insert(c.end(), b.begin(), b.end());\n\treturn c;\n}\n\nvector<ar<int, 2>> vo(vector<ar<int, 2>> a, vector<ar<int, 2>> b) {\n\tvector<ar<int, 2>> c=a;\n\treverse(b.begin()+1, b.end());\n\tc.insert(c.end(), b.begin(), b.end());\n\treverse(a.begin()+1, a.end());\n\tc.insert(c.end(), a.begin(), a.end());\n\treverse(b.begin()+1, b.end());\n\tc.insert(c.end(), b.begin(), b.end());\n\treturn c;\n}\n\nvector<ar<int, 2>> dc(int l, int r) {\n\tvector<ar<int, 2>> c;\n\tif(l==r) {\n\t\tint mx=0;\n\t\tfor(int i=0; i<n; ++i)\n\t\t\tif(v[l]>>i&1)\n\t\t\t\tmx=i;\n\t\tfor(int i=0; i<=mx+1; ++i)\n\t\t\tc.push_back({i, 0});\n\t\tfor(int i=mx; ~i; --i) {\n\t\t\tif(v[l]>>i&1) {\n\t\t\t\tc.push_back({i+1, 1});\n\t\t\t\tc.push_back({i, v[l]>>i&1});\n\t\t\t}\n\t\t\tif(i)\n\t\t\t\tc.push_back({i, 0});\n\t\t}\n\t} else {\n\t\tint m=(l+r)/2;\n\t\tc=vo(dc(l, m), dc(m+1, r));\n\t}\n\treturn c;\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin >> n >> s;\n\t/*\n\tcin >> n;\n\ts=string(1<<n, '0');\n\tfor(int i=0; i<1<<n; ++i)\n\t\tif(__builtin_popcount(i)<=n/2)\n\t\t\ts[i]='1';\n\t//*/\n\tfor(int i=0; i<1<<n; ++i) {\n\t\tfor(int j=0; j<1<<n; ++j) {\n\t\t\tif((i&j)==j&&s[i]=='1'&&s[j]=='0') {\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tbool ok=i<(1<<n)-1&&s[i]=='1';\n\t\tfor(int j=0; j<n&&ok; ++j)\n\t\t\tif(i>>j&1^1&&s[i^1<<j]=='1')\n\t\t\t\tok=0;\n\t\tif(ok)\n\t\t\tv.push_back((1<<n)-1-i);\n\t}\n\tcout << \"Possible\\n\";\n\tif(v.empty()) {\n\t\tcout << \"0\\n1 1\";\n\t\treturn 0;\n\t}\n\tvector<ar<int, 2>> ans=dc(0, (int)v.size()-1);\n\tcout << ans.size() << \"\\n\";\n\t//return 0;\n\tassert(ans.size()<=2.5e5);\n\tans.push_back(ans[0]);\n\tfor(ar<int, 2> a : ans)\n\t\tcout << a[0] << \" \" << a[1] << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\nCode for problem E by cookiedoth\nGenerated 21 Mar 2020 at 05.19 PM\n\n\n______▄███████▄_______\n______█▄█████▄█_______\n______█▼▼▼▼▼█_______\n_____██________ ██______\n______█▲▲▲▲▲█_______\n______█████████_______\n_______██____ ██________\n\n>_<\no_O\n^_^\n\n*/\n\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <ctime>\n#include <functional>\n#include <unordered_set>\n#include <unordered_map>\n#include <string>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <complex>\n#include <cassert>\n#include <random>\n#include <cstring>\n#include <numeric>\n#define ll long long\n#define ld long double\n#define null NULL\n#define all(a) a.begin(), a.end()\n#define rall(a) a.rbegin(), a.rend()\n#define debug(a) cerr << #a << \" = \" << a << endl\n#define forn(i, n) for (int i = 0; i < n; ++i)\n#define sz(a) (int)a.size()\n\nusing namespace std;\n\ntemplate<class T> int chkmax(T &a, T b) {\n\tif (b > a) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\ntemplate<class T> int chkmin(T &a, T b) {\n\tif (b < a) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\ntemplate<class iterator> void output(iterator begin, iterator end, ostream& out = cerr) {\n\twhile (begin != end) {\n\t\tout << (*begin) << \" \";\n\t\tbegin++;\n\t}\n\tout << endl;\n}\n\ntemplate<class T> void output(T x, ostream& out = cerr) {\n\toutput(x.begin(), x.end(), out);\n}\n\nvoid fast_io() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n}\n\nint x;\nvector<pair<int, int> > ans;\n\nvoid move(int dest_x) {\n\tif (x == dest_x) {\n\t\treturn;\n\t}\n\tif (dest_x > x) {\n\t\tx++;\n\t\tans.emplace_back(x, 0);\n\t} else {\n\t\tx--;\n\t\tans.emplace_back(x, 0);\n\t}\n\tmove(dest_x);\n}\n\nvoid use(int pos, int d) {\n\t// cerr << \"use \" << pos << \" \" << d << endl;\n\tif (d == 0) {\n\t\tmove(pos);\n\t\tans.emplace_back(pos, 1);\n\t\tans.emplace_back(pos + 1, 1);\n\t\tans.emplace_back(pos + 1, 0);\n\t\tx++;\n\t} else {\n\t\tmove(pos + 1);\n\t\tans.emplace_back(pos, 1);\n\t\tans.emplace_back(pos - 1, 1);\n\t\tans.emplace_back(pos - 1, 0);\n\t\tx--;\n\t}\n}\n\nconst int mx = 300;\nint n, a[mx];\n\nvector<vector<pair<int, int> > > str;\n\nvoid gen_str() {\n\tstr.resize(n + 1);\n\tstr[1] = {{0, 0}};\n\tfor (int i = 2; i <= n; ++i) {\n\t\tstr[i].emplace_back(i - 1, 0);\n\t\tfor (auto pp : str[i - 1]) {\n\t\t\tstr[i].push_back(pp);\n\t\t}\n\t\tstr[i].emplace_back(i - 1, i);\n\t\tfor (auto pp : str[i - 1]) {\n\t\t\tstr[i].emplace_back(pp.first, pp.second ^ 1);\n\t\t}\n\t}\n}\n\nvoid make(int sub) {\n\tvector<int> have;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif ((sub >> i) & 1) {\n\t\t\thave.push_back(i);\n\t\t}\n\t}\n\tint k = __builtin_popcount(sub);\n\tfor (auto pp : str[k]) {\n\t\tuse(have[pp.first], pp.second);\n\t}\n}\n\nsigned main() {\n\tfast_io();\n\tans.emplace_back(0, 0);\n\tcin >> n;\n\tgen_str();\n\tfor (int i = 0; i < (1 << n); ++i) {\n\t\tchar c;\n\t\tcin >> c;\n\t\ta[i] = c - '0';\n\t}\n\tfor (int i = 0; i < (1 << n); ++i) {\n\t\tfor (int j = 0; j < i; ++j) {\n\t\t\tif (a[i] == 1 && ((i & j) == j) && a[j] == 0) {\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < (1 << n); ++i) {\n\t\tif (a[i] == 0) {\n\t\t\tint ok = 1;\n\t\t\tfor (int j = 0; j < i; ++j) {\n\t\t\t\tif (a[j] == 0 && (i & j) == j) {\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tmake(i);\n\t\t\t}\n\t\t}\n\t}\n\tmove(0);\n\tcout << \"Possible\" << \"\\n\";\n\tcout << (int)ans.size() - 1 << \"\\n\";\n\tfor (auto pp : ans) {\n\t\tcout << pp.first << \" \" << pp.second << \"\\n\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing ll = long long;\nusing ull = unsigned long long;\nusing namespace std;\nconst int INF = 1e10;\nconst int MOD = 1e9 + 7;\n#define dump(x)                             \\\n    if (dbg) {                              \\\n        cerr << #x << \" = \" << (x) << endl; \\\n    }\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define FOR1(n) for (ll i = 0; i < (n); ++i)\n#define FOR2(i, n) for (ll i = 0; i < (n); ++i)\n#define FOR3(i, a, b) for (ll i = (a); i < (b); ++i)\n#define FOR4(i, a, b, c) for (ll i = (a); i < (b); i += (c))\n#define FOR(...) overload4(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)\n#define FORR(i, a, b) for (int i = (a); i <= (b); ++i)\n#define bit(n, k) ((n >> k) & 1) /*nのk bit目*/\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\nvoid Yes(bool flag = true) {\n    if (flag)\n        cout << \"Yes\" << endl;\n    else\n        cout << \"No\" << endl;\n}\nvoid No(bool flag = true) {\n    Yes(!flag);\n}\nvoid YES(bool flag = true) {\n    if (flag)\n        cout << \"YES\" << endl;\n    else\n        cout << \"NO\" << endl;\n}\nvoid NO(bool flag = true) {\n    YES(!flag);\n}\n#define pb emplace_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define all(v) (v).begin(), (v).end()\n#define SZ(x) ((int)(x).size())\n#define P pair<int, int>\n//#define V vector<int>\n//#define S set<int>\n#define itn int\nbool dbg = false;\n\nint N;\nstring A;\nbool checked[1010];\nbool out[1010];\n\nvector<int> x, y;\n\nvoid go(int gx) {\n    int sx;\n    int ys;\n    sx = x[(int)x.size() - 1];\n    ys = y[(int)y.size() - 1];\n    if (sx > gx) {\n        while (sx != gx) {\n            sx--;\n            x.pb(sx);\n            y.pb(ys);\n        }\n    } else if (sx < gx) {\n        while (sx != gx) {\n            sx++;\n            x.pb(sx);\n            y.pb(ys);\n        }\n    }\n}\nvoid chy() {\n    x.pb(x[(int)x.size() - 1]);\n    y.pb(!y[(int)y.size() - 1]);\n}\n\nvoid fill(int T) {\n    int cnt = __builtin_popcount(T);\n    if (cnt == 1) {\n        int nxt = __builtin_ffs(T) - 1;\n        go(nxt);\n        chy();\n        go(nxt + 1);\n        chy();\n        go(nxt);\n        chy();\n        go(nxt + 1);\n        chy();\n        go(nxt);\n        chy();\n        go(nxt + 1);\n        chy();\n        go(nxt);\n        return;\n    } else {\n        int n1 = __builtin_ffs(T) - 1;\n        T -= (1 << n1);\n        int n2 = __builtin_ffs(T) - 1;\n        int n3 = n2;\n        FOR(N) {\n            if ((1 << i) & T) {\n                n3 = i;\n            }\n        }\n        n3++;\n\n        FOR(iugy, 2) {\n            go(n1);\n            chy();\n            go(n3);\n            chy();\n            go(n2);\n            //ここで再帰\n            if (n2 + 1 != n3) {\n                fill(T);\n            }\n\n\n            chy();\n            go(n1);\n            chy();\n            go(n3);\n            chy();\n            go(n2);\n            chy();\n            go(n1);\n        }\n    }\n}\n\n\nvoid solve() {\n    bool flag = true;\n    int tmp = -1;\n    for (int T = 1; T < (1 << N); T++) {\n        if (A[T] == 1) {\n            continue;\n        }\n        if (checked[T]) {\n            continue;\n        }\n        out[T] = true;\n        if (__builtin_popcount(T) == 1) {\n            tmp = T;\n        }\n        for (int i = T; i < (1 << N); i = (i + 1) | T) {\n            // ここに処理を書く\n            if (A[i] == 1) {\n                flag = false;\n            }\n            checked[i] = true;\n        }\n    }\n    if (!flag) {\n        cout << \"Impossible\" << endl;\n        return;\n    }\n    cout << \"Possible\" << endl;\n\n    x.pb(0);\n    y.pb(0);\n\n    for (int T = 1; T < (1 << N); T++) {\n        if (out[T]) {\n            fill(T);\n        }\n    }\n    go(0);\n    int L = x.size();\n    cout << L - 1 << endl;\n\n    FOR(L) {\n        cout << x[i] << \" \" << y[i] << endl;\n    }\n}\n\nsigned main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cin >> N;\n    cin >> A;\n    for (auto& c : A)\n        c -= '0';\n\n\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define register register\n#define cs const\nusing std::cerr;\nusing std::cout;\nusing pii=std::pair<int,int>;\n#define fi first\n#define se second\n\nstd::string inv(std::string s){\n\tstd::string res=\"\";\n\tstd::reverse(s.begin(),s.end());\n\tfor(char c:s)\n\t\tif(isupper(c))res+=c-'A'+'a';\n\t\telse res+=c-'a'+'A';\n\treturn res;\n}\n\nint n;\nstd::string A;\n\nvoid Main(){\n\tstd::cin>>n>>A;\n\tif(A[0]=='0')\n\t{\n\t\tputs(\"Impossible\");\n\t\treturn ;\n\t}\n\tint register i=0;\n\twhile(i<(1<<n))\n\t{ \n\t\tif(A[i]=='1')\n\t\t{\n\t\t\tint register j=i;\n\t\t\twhile(j)\n\t\t\t{\n\t\t\t\tif(A[j]=='0')\n\t\t\t\t{\n\t\t\t\t\tputs(\"Impossible\");\n\t\t\t\t\treturn ;\n\t\t\t\t}\n\t\t\t\tj=i&(j-1);\n\t\t\t}\n\t\t}\n\t\t++i;\n\t}\n\tstd::vector<pii> p({{0,0}});\n\tint register s=0;\n\twhile(s<(1<<n))\n\t{\n\t\tif(A[s]=='0')\n\t\t{\n\t\t\tbool flag=true;\n\t\t\tint register t=s&(s-1);\n\t\t\twhile((t)&&(flag))\n\t\t\t{\n\t\t\t\tif(A[t]=='0')flag=false;\n\t\t\t\tt=s&(t-1);\n\t\t\t}\n\t\t\tif(!flag)\n\t\t\t{\n\t\t\t\t++s;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstd::string q;\n\t\t\tint register i=0;\n\t\t\twhile(i<n)\n\t\t\t{\n\t\t\t\tif(s&(1<<i))\n\t\t\t\t{\n\t\t\t\t\tif(q.empty()) q+='a'+i;\n\t\t\t\t\telse q=(char)('a'+i)+q+(char)('A'+i)+inv(q);\n\t\t\t\t}\n\t\t\t\t++i;\n\t\t\t}\n\t\t\tint nw=0;\n\t\t\tint k=0;\n\t\t\twhile(k<q.size())\n\t\t\t{\n\t\t\t\tchar c=q[k];\n\t\t\t\tint i,dir;\n\t\t\t\tif(isupper(c))\n\t\t\t\t{\n\t\t\t\t\ti=c-'A';\n\t\t\t\t\tdir=0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{ \n\t\t\t\t\ti=c-'a';\n\t\t\t\t\tdir=1;\n\t\t\t\t}\n\t\t\t\tint j=nw+1;\n\t\t\t\twhile(j<=i)\n\t\t\t\t{\n\t\t\t\t\tp.push_back({j,0});\n\t\t\t\t\t++j;\n\t\t\t\t}\n\t\t\t\tj=nw-1;\n\t\t\t\twhile(j>=i)\n\t\t\t\t{\n\t\t\t\t\tp.push_back({j,0});\n\t\t\t\t\t--j;\n\t\t\t\t}\n\t\t\t\tnw=i;\n\t\t\t\tif(dir)\n\t\t\t\t{\n\t\t\t\t\tp.push_back({i,1});\n\t\t\t\t\tp.push_back({i+1,1});\n\t\t\t\t\tp.push_back({i+1,0});\n\t\t\t\t\tp.push_back({i,0});\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tp.push_back({i+1,0});\n\t\t\t\t\tp.push_back({i+1,1});\n\t\t\t\t\tp.push_back({i,1});\n\t\t\t\t\tp.push_back({i,0});\n\t\t\t\t}\n\t\t\t\t++k;\n\t\t\t}\n\t\t\tint j=nw-1;\n\t\t\twhile(~j)\n\t\t\t{\n\t\t\t\tp.push_back({j,0});\n\t\t\t\t--j;\n\t\t\t}\n\t\t}\n\t\t++s;\n\t}\n\tcout<<\"Possible\\n\"<<(p.size()-1)<<\"\\n\";\n\ti=0;\n\twhile(i<p.size())\n\t{\n\t\tcout<<p[i].fi<<\" \"<<p[i].se<<\"\\n\";\n\t\t++i;\n\t}\n}\nsigned main()\n{\n\tMain();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n  ios::sync_with_stdio(0); cin.tie(0);\n  int n;\n  cin >> n;\n  string possible;\n  cin >> possible;\n  if (possible[0] == '0') {\n    cout << \"Impossible\" << endl;\n    return 0;\n  }\n  for (int i = 0; i < 1<<n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i>>j&1) {\n\tif (possible[i] == '1' && possible[i^1<<j] == '0') {\n\t  cout << \"Impossible\" << endl;\n\t  return 0;\n\t}\n      }\n    }\n  }\n  cout << \"Possible\" << endl;\n  vector<pair<int,int>> ans;\n  function<void(int,int)> add = [&](int mask, int inv) {\n    int lsb = mask&-mask;\n    if (lsb == mask) {\n      int x = 31-__builtin_clz(mask);\n      for (int i = 0; i <= x; i++)\n\tans.emplace_back(i,0);\n      if (inv) {\n\tans.emplace_back(x,1);\n\tans.emplace_back(x+1,1);\n\tans.emplace_back(x+1,0);\n      } else {\n\tans.emplace_back(x+1,0);\n\tans.emplace_back(x+1,1);\n\tans.emplace_back(x,1);\n      }\n      for (int i = x; i > 0; i--)\n\tans.emplace_back(i,0);\n    } else {\n      if (inv == 0) {\n\tadd(mask^lsb, 0);\n\tadd(lsb, 0);\n\tadd(mask^lsb, 1);\n\tadd(lsb, 1);\n      } else {\n\tadd(lsb, 0);\n\tadd(mask^lsb, 0);\n\tadd(lsb, 1);\n\tadd(mask^lsb, 1);\n      }\n    }\n  };\n  for (int i = 0; i < 1<<n; i++) {\n    if (possible[i] == '0') {\n      add(i, 0);\n    }\n  }\n  ans.emplace_back(0,0);\n  cout << (int)ans.size()-1 << endl;\n  for (auto [x,y] : ans)\n    cout << x << ' ' << y << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n#define MOD @\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nint N;\nchar A[300];\nvector<pair<int, int>> ans;\n\nvoid draw_curve(int mask, bool flip = false)\n{\n\tvector<pair<int, int>> seq;\n\tseq.push_back({0, 0});\n\tfor (int i = 0; i < N; ++i) {\n\t\tpair<int, int> src = make_pair(i, (mask >> i) & 1);\n\t\tpair<int, int> dest = make_pair(i + 1, (mask >> i) & 1);\n\t\tif (seq.back() != src) seq.push_back(src);\n\t\tseq.push_back(dest);\n\t}\n\tif (seq.back().second == 1) seq.push_back({N, 0});\n\tfor (int i = N - 1; i >= 0; --i) seq.push_back({i, 0});\n\tif (flip) reverse(seq.begin(), seq.end());\n\tfor (int i = 1; i < seq.size(); ++i) ans.push_back(seq[i]);\n}\n\nint main()\n{\n\tscanf(\"%d%s\", &N, A);\n\tfor (int i = 0; i < (1 << N); ++i) {\n\t\tif (A[i] == '0') {\n\t\t\tfor (int j = 0; j < N; ++j) if ((i & (1 << j)) == 0) {\n\t\t\t\tif (A[i | (1 << j)] == '1') {\n\t\t\t\t\tputs(\"Impossible\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (A[0] == '0') {\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tputs(\"Possible\");\n\tvector<int> minima;\n\tfor (int i = 0; i < (1 << N); ++i) {\n\t\tif (A[i] == '0') {\n\t\t\tbool flg = true;\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tif ((i & (1 << j)) != 0 && A[i ^ (1 << j)] == '0') flg = false;\n\t\t\t}\n\t\t\tif (flg) minima.push_back(i);\n\t\t}\n\t}\n\tans.push_back({0, 0});\n\tfor (int m : minima) {\n\t\tif ((m & -m) == m) {\n\t\t\tdraw_curve(m);\n\t\t} else {\n\t\t\tfor (int i = 0; i < N; ++i) if (m & (1 << i)) draw_curve(m ^ (1 << i));\n\t\t\tfor (int i = 0; i < N; ++i) if (m & (1 << i)) draw_curve(m ^ (1 << i), true);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans.size() - 1);\n\tfor (auto p : ans) printf(\"%d %d\\n\", p.first, p.second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\n\ntemplate <class T1, class T2>\nostream& operator << (ostream& out, const pair <T1, T2> p)\n{\n    out << '(' << p.first << ',' << p.second << ')';\n    return out;\n}\n\ntemplate <class T1, class T2>\nistream& operator >> (istream& in, pair<T1, T2> &p)\n{\n    in >> p.first >> p.second;\n    return in;\n}\n\ntemplate <class T>\nistream& operator >> (istream& in, vector<T> &v)\n{\n    for (T &x : v)\n        in >> x;\n    return in;\n}\n\ntemplate <class T>\nostream& operator << (ostream& out, const vector<vector<T>> &v)\n{\n    for (const vector<T> &x : v)\n        out << x << '\\n';\n    return out;\n}\n\ntemplate <class T>\nostream& operator << (ostream& out, const vector<T> &v)\n{\n    for (const T &x : v)\n        out << x << ' ';\n    return out;\n}\n\nlong long gcd (long long a, long long b)\n{\n    if (b > a)\n        swap(a, b);\n    return (b ? gcd(b, a % b) : a);\n}\n\nusing ll   = long long;\nusing pii  = pair<int, int>;\nusing pll  = pair<long long, long long>;\nusing tiii = pair<pair<int, int>, int>;\nusing vi   = vector<int>;\nusing vl   = vector<long long>;\nusing vvi  = vector<vector<int>>;\nusing vvl  = vector<vector<long long>>;\n\n#define F          first\n#define S          second\n#define First      first.first\n#define Second     first.second\n#define Third      second\n#define mp         make_pair\n#define rep(i,a,b) for (int i = (a); i < (b); i++)\n#define per(i,b,a) for (int i = (b); i > (a); i--)\n#define all(x)     x.begin(), x.end()\n#define ret(x)     return cout << x, 0;\n#define throwex    throw runtime_error (\"Found the error.\");\n\nconst int h = 1000000007;\n\nint n;\nvector<pii> get_cycle(int mask, int cur = 0)\n{\n    int last_1_index = n - 1;\n    int z = (mask & -mask);\n    while(z != 1)\n        last_1_index--, z /= 2;\n    vector<pii> ans;\n    if(cur == last_1_index)\n    {\n        ans.push_back({cur, 1});\n        ans.push_back({cur+1, 1});\n        ans.push_back({cur+1, 0});\n        ans.push_back({cur, 0});\n        ans.push_back({cur, 1});\n        return ans;\n    }\n    ans.push_back({cur, 1});\n    vector<pii> next_cycle = get_cycle(mask, cur + 1);\n    ans.insert(ans.end(), all(next_cycle));\n    ans.push_back({cur, 1});\n    if((mask & (1 << (n - 1 - cur))))\n    {\n        ans.push_back({cur, 0});\n        ans.push_back({cur+1, 0});\n        reverse(all(next_cycle));\n        ans.insert(ans.end(), all(next_cycle));\n        ans.push_back({cur, 1});\n    }\n    return ans;\n}\n\nsigned main()\n{\n    ios::sync_with_stdio(false);\n    #ifdef ONLINE_JUDGE\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    cerr.setstate(ios::failbit);\n    #endif\n\n    cin >> n;\n    string a;\n    cin >> a;\n    rep(i,0,1 << n)\n    {\n        rep(j,0,i)\n        {\n            if((j | i) == i and a[i] == '1' and a[j] == '0')\n                ret(\"Impossible\");\n        }\n    }\n    vector<pii> ans;\n    rep(i,0,1 << n)\n    {\n        if(a[i] == '0')\n        {\n            vector<pii> cycle = get_cycle(i);\n            ans.insert(ans.end(), all(cycle));\n            for(int j = i; j < (1 << n); j++)\n                if((i | j) == j)\n                    a[j] = '1';\n            cerr << cycle << '\\n';\n        }\n    }\n    cout << \"Possible\\n\";\n    if(ans.empty())\n        cout << \"0\\n0 1\";\n    else\n    {\n        cout << ans.size() - 1 << '\\n';\n        for(pii x : ans)\n            cout << x.F << ' ' << x.S << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &x) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (x = 0; c >= 33 && c <= 126; s[++x] = c, c = gc());\n\t\ts[x+1] = '\\0';\n\t}\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(string s) {\n\t\tint x = s.length();\n\t\twhile (t < x) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printc;\nusing io::prints;\n\n#define Fail prints(\"Impossible\"), exit(0)\n#define vp vector<pi>\nint n, f[1<<8|1];\nstring s;\nvp p[1<<8|1], ans(1, mp(0, 0));\n\ninline bool pd(int i) {\n\tfor (int j = (i - 1) & i; j; j = (j - 1) & i)\n\t\tif (s[j] == '0') return 0;\n\treturn 1;\n}\n\ninline void merge(vp &a, vp b) {\n\tfor (pi o : b) a.pb(o);\n}\n\ninline vp prime(vp a) {\n\tfor (pi &o : a) o.se ^= 1;\n\treturn a;\n}\n\ninline vp work(int i) {\n\tif (p[i].size()) return p[i];\n\tint j = i & -i;\n\tp[i].pb(mp(j, 1));\n\tp[i].pb(mp(j + 1, 1));\n\tvp t = work(i - j);\n\tmerge(p[i], t);\n\tp[i].pb(mp(j + 1, 1));\n\tp[i].pb(mp(j, 1));\n\tp[i].pb(mp(j, 0));\n\tp[i].pb(mp(j + 1, 0));\n\tmerge(p[i], prime(t));\n\tp[i].pb(mp(j + 1, 0));\n\tp[i].pb(mp(j, 0));\n\tp[i].pb(mp(j, 1));\n\treturn p[i];\n}\n\ninline vp get(pi a, pi b) {\n\tvp ret(1, a);\n\tif (a.se != b.se) return ret.pb(b), ret;\n\twhile (a != b)\n\t\ta.fi += a.fi < b.fi ? 1 : -1, ret.pb(a);\n\treturn ret;\n}\n\ninline vp update(vp a) {\n\tif (a.size() == 1u) return a;\n\tvp b;\n\tfor (ui i = 1; i < a.size(); i++) merge(b, get(a[i-1], a[i]));\n\treturn b;\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\tcin >> n >> s;\n\tif (s[0] == '0') Fail;\n\tfor (int i = 0; i < (1 << n); i++)\n\t\tif (s[i] == '1')\n\t\t\tfor (int j = i; j; j = (j - 1) & i)\n\t\t\t\tif (s[j] == '0') Fail;\n\tfor (int i = 0; i < n; i++) {\n\t\tf[1<<i] = i;\n\t\tp[1<<i].pb(mp(i, 1));\n\t\tp[1<<i].pb(mp(i + 1, 1));\n\t\tp[1<<i].pb(mp(i + 1, 0));\n\t\tp[1<<i].pb(mp(i, 0));\n\t\tp[1<<i].pb(mp(i, 1));\n\t}\n\tfor (int i = 0; i < (1 << n); i++)\n\t\tif (s[i] == '0' && pd(i))\n\t\t\tans.pb(mp(0, 1)), merge(ans, work(i)),\n\t\t\tans.pb(mp(0, 1)), ans.pb(mp(0, 0));\n//\tdbg(ans.size() - 1);\n//\tfor (pi o : ans) debug(\"%d %d\\n\", o.fi, o.se);\n\tans = update(ans);\n\tans.erase(unique(ans.begin(), ans.end()), ans.end());\n\tprints(\"Possible\");\n\tprint(ans.size() - 1);\n\tfor (pi o : ans) print(o.fi, o.se);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <decimal/decimal>\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define rep(i, s, t) for (int i = s; i < int(t); ++i)\n\n#define sc\tscanf\n#define pr\tprintf\n#define ff\tfirst\n#define ss\tsecond\n#define mp\tmake_pair\n#define pb\tpush_back\n#define eb\templace_back\n#define range(c)\tc.begin(), c.end()\n#define lowbit(x)\t((x) & -(x))\n#define pop_count\t__builtin_popcount\n#define pop_count_64\t__builtin_popcountll\n#define tail_count\t__builtin_ctz\n#define tail_count_64\t__builtin_ctzll\n#define lead_count\t__builtin_clz\n#define lead_count_64\t__builtin_clzll\n\n#define TEMP template<typename\n#define CONST(type) constexpr type const\n\nTEMP... Ts> struct is_con { static CONST(bool) value = false; };\nTEMP... Ts> struct is_con<vector<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<list<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<deque<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<set<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<unordered_set<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<map<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<unordered_map<Ts...>> { static CONST(bool) value = true; };\n\nTEMP T1, typename T2> ostream& operator<<(ostream& os, pair<T1, T2> const& p) { return os << \"<\" << p.ff << \",\" << p.ss << \">\"; }\nTEMP T> typename enable_if<is_con<T>::value, ostream>::type& operator<<(ostream& os, T const& c) {\n\tos << \"{\";\n\tbool first = true;\n\tfor (auto const& x : c) {\n\t\tif (first) first = false;\n\t\telse os << \",\";\n\t\tos << \" \" << x;\n\t}\n\treturn os << \" }\";\n}\n\nTEMP T, typename... Ts> void dbg(T h, Ts... t) { cerr << \" \" << h; dbg<Ts...>(t...); }\ntemplate<> void dbg<int>(int x) { cerr << endl; }\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[ \"#__VA_ARGS__\" ] :\", dbg(__VA_ARGS__, 0)\n#else\n#define debug(...) 0\n#endif\n\nTEMP T, typename U> using ordered_map = tree<T, U, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\nTEMP T> using ordered_set = ordered_map<T, null_type>;\n\ntypedef long long i64;\ntypedef decimal::decimal128 i99;\ntypedef unsigned int u32;\ntypedef unsigned long long u64;\ntypedef float f32;\ntypedef double f64;\ntypedef long double f80;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<i64> vl;\n\nTEMP T> T& minn(T& lhs, T const& rhs) { return lhs = min(lhs, rhs); }\nTEMP T> T& maxx(T& lhs, T const& rhs) { return lhs = max(lhs, rhs); }\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n;\n\tstring a;\n\tcin >> n >> a;\n\tvi dp(1 << n);\n\trep(s, 0, 1 << n) dp[s] = a[s] == '0';\n\tbool ok = true;\n\trep(s, 0, 1 << n) ok &= dp[s] ^ (a[s] == '1');\n\tvi clique;\n\trep(s, 0, 1 << n) if (dp[s]) {\n\t\tbool check = true;;\n\t\trep(t, 0, 1 << n) if (t != s && (s & t) == t) check &= !dp[t];\n\t\tif (check) clique.pb(s);\n\t}\n\tint tot = 0, cnt = 0;\n\tfor (int s : clique) {\n\t\tint x = pop_count(s);\n\t\tok &= x <= 2;\n\t\ttot |= s;\n\t\tcnt += x;\n\t}\n\tok &= cnt == pop_count(tot);\n\tif (!ok) return cout << \"Impossible\" << endl, 0;\n\tcout << \"Possible\" << endl;\n\tvector<pii> ans(1);\n\tfor (int s : clique) {\n\t\tif (s == lowbit(s)) {\n\t\t\tint x = tail_count(s);\n\t\t\trep(i, 1, x + 1) ans.eb(i, 0);\n\t\t\tans.eb(x + 1, 0);\n\t\t\tans.eb(x + 1, 1);\n\t\t\tans.eb(x, 1);\n\t\t\tfor (int i = x; i >= 0; --i) ans.eb(i, 0);\n\t\t} else {\n\t\t\tint x = tail_count(s);\n\t\t\ts ^= lowbit(s);\n\t\t\tint y = tail_count(s);\n\t\t\trep(i, 1, y + 1) ans.eb(i, 0);\n\t\t\tans.eb(y + 1, 0);\n\t\t\tans.eb(y + 1, 1);\n\t\t\tans.eb(y, 1);\n\t\t\tfor (int i = y; i >= x; --i) ans.eb(i, 0);\n\t\t\trep(i, x, y + 1) ans.eb(i, 1);\n\t\t\tfor (int i = y + 1; i > x; --i) ans.eb(i, 0);\n\t\t\tans.eb(x + 1, 1);\n\t\t\tans.eb(x, 1);\n\t\t\tfor (int i = x; i >= 0; --i) ans.eb(i, 0);\n\t\t}\n\t}\n\tcout << ans.size() - 1 << endl;\n\tfor (auto const& p : ans) cout << p.ff << \" \" << p.ss << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1007;\n\nvoid nope()\n{\n\tprintf(\"Impossible\\n\");\n\texit(0);\n}\n\nvoid tak()\n{\n\tprintf(\"Possible\\n\");\n}\n\nint n;\nchar wcz[nax];\nint dasie[nax];\n\nvector <pii> wek;\n\nvector <pii> operator + (vector <pii> a, vector <pii> b)\n{\n\tif (a.empty())\n\t\treturn b;\n\tif (b.empty())\n\t\treturn a;\n\ta.push_back({0, 0});\n\tfor (pii i : b)\n\t\ta.push_back(i);\n\treturn a;\n}\n\nvector <pii> odw(vector <pii> a)\n{\n\treverse(a.begin(), a.end());\n\treturn a;\n}\n\nvector <pii> zdobo(int mas)\n{\n\tif (!mas)\n\t\treturn {};\n\tint x=__builtin_ctz(mas);\n\tvector <pii> ret;\n\tfor (int i=0; i<=x; i++)\n\t\tret.push_back({i, 1});\n\tret.push_back({x, 0});\n\tret.push_back({x+1, 0});\n\tfor (int i=x+1; i>=0; i--)\n\t\tret.push_back({i, 1});\n\tauto wez=zdobo(mas^(1<<x));\n\treturn wez+ret+odw(wez);\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", wcz);\n\tfor (int i=0; i<(1<<n); i++)\n\t\tdasie[i]=wcz[i]-'0';\n\tfor (int i=0; i<(1<<n); i++)\n\t{\n\t\tfor (int j=0; j<(1<<n); j++)\n\t\t{\n\t\t\tif ((i&j)==i && dasie[j] && !dasie[i])\n\t\t\t{\n\t\t\t\tnope();\n\t\t\t}\n\t\t}\n\t}\n\tif (!dasie[0])\n\t\tnope();\n \ttak();\n\tfor (int i=0; i<(1<<n); i++)\n\t{\n\t\tif (dasie[i])\n\t\t\tcontinue;\n\t\tauto x=zdobo(i);\n\t\twek=wek+x;\n\t}\n\tif (!wek.empty())\n\t\twek.push_back({0, 0});\n\tprintf(\"%d\\n0 0\\n\", (int)wek.size());\n\tfor (pii i : wek)\n\t\tprintf(\"%d %d\\n\", i.first, i.second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n// gp_hash_table<int, int> mapka;\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nint n;\nstring z;\n\nvoid nope(){\n  cout << \"Impossible\\n\";\n  exit(0);\n}\n\nvector<PII> petla(int mb){\n  vector<PII> res;\n  res.PB({0,0});\n  R(i,n){\n    if((mb >> i) & 1){\n      res.PB({i,1ll});\n      res.PB({i+1,1ll});\n    }\n    res.PB({i+1,0ll});\n  }\n  R(i,n){\n    res.PB({n - i - 1, 0});\n  }\n  debug(res);\n  return res;\n}\nvector<PII> res;\nvoid dodaj(vector<PII> x){\n  R(i,SZ(x)-1)res.PB(x[i]);\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n >> z;\n  R(i, 1<<n)z[i] -= '0';\n  if(z[0] == 0)nope();\n  R(i, 1<<n)R(j, 1 << n)if((i | j) == i && z[i] == 1 && z[j] == 0)nope();\n  cout << \"Possible\\n\";\n  vector<int> dp(1 << n);\n  for(int mb = (1 << n) - 1; mb > 0; mb --){\n    if(z[mb] == 0 && dp[mb] == 0){\n      dodaj(petla(mb));\n      R(mb2, (1 << n))if((mb2 | mb) == mb){\n        dp[mb2]++;\n      }\n    }\n    if(z[mb] == 1 && dp[mb] != 0){\n      auto pom = petla(mb);\n      if(dp[mb] > 0)reverse(ALL(pom));\n      R(i, abs(dp[mb]))dodaj(pom);\n      R(mb2, (1 << n))if((mb2 | mb) == mb){\n        dp[mb2] -= dp[mb];\n      }\n    }\n  }\n  res.PB({0,0});\n  cout << SZ(res) - 1 << \"\\n\";\n  for(PII el:res){\n    cout << el.FI << \" \" << el.SE << \"\\n\";\n  }\n  \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing std::cerr;using std::cin;using std::cout;using std::abs;using std::min;using std::max;using std::swap;using std::map;using std::unordered_map;using std::unordered_set;using std::bitset;using std::pair;using std::set;using std::string;using std::vector;using std::sort;using ll=long long;using uint=unsigned int;using pii=pair<int,int>;using pll=pair<ll,ll>;using ull = unsigned long long;using ld=long double;template<typename T>void _(const char*s,T h){cerr<<s<<\" = \"<<h<<\"\\n\";}template<typename T,typename...Ts>void _(const char*s,T h,Ts...t){int b=0;while(((b+=*s=='(')-=*s==')')!=0||*s!=',')cerr<<*s++;cerr<<\" = \"<<h<<\",\";_(s+1,t...);}// break continue pop_back 998244353\n#define int ll\n#define pii pll\n#define f first\n#define s second\n#define pb emplace_back\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define sqr(x) ((x)*(x))\nstruct init{init(){cin.tie(0);std::iostream::sync_with_stdio(0);cout<<std::fixed<<std::setprecision(10);cerr<<std::fixed<<std::setprecision(5);}~init(){\n#ifdef LOCAL\n#define dbg(...) _(#__VA_ARGS__,__VA_ARGS__)\ncerr<<\"Time elapsed: \"<<(double)clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n#else\n#define dbg(...) \n#endif\n}}init;template<typename T,typename U>void upx(T&x,U y){if(x<y)x=y;}template<typename T,typename U>void upn(T&x,U y){if(x>y)x=y;}\n\nconst int N=2020;\nint a[N];\nint32_t main(){\n\n    int n;\n    cin>>n;\n    forn(i,1<<n){\n        char c;\n        cin>>c;\n        a[i]=c-'0';\n    }\n    int ok=1;\n    forn(m1,1<<n){\n        forn(m2,1<<n){\n            if((m1&m2)==m2){\n                if(!a[m2]&&a[m1])ok=0;\n            }\n            if(a[m1]&&a[m2]&&!a[m1|m2])ok=0;\n        }\n    }\n    if(!ok){\n        cout<<\"Impossible\\n\";\n        return 0;\n    }\n    vector<pii> ans={{0,0}};\n    forn(i,n){\n        if(a[1<<i]){\n            ans.pb(i+1,0);\n        }else{\n            ans.pb(i,1);\n            ans.pb(i+1,1);\n            ans.pb(i+1,0);\n        }\n    }\n    for(int i=n-1;i>=0;--i){\n        ans.pb(i,0);\n    }\n    cout<<\"Possible\\n\";\n    cout<<ans.size()-1<<'\\n';\n    for(pii p:ans)cout<<p.f<<' '<<p.s<<'\\n';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nnamespace std {\n\ntemplate<class Fun>\nclass y_combinator_result {\n\tFun fun_;\npublic:\n\ttemplate<class T>\n\texplicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n\n\ttemplate<class ...Args>\n\tdecltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n\ntemplate<class Fun>\ndecltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\n} // namespace std\n\nconst char* IMPOSSIBLE = \"Impossible\";\nconst char* POSSIBLE = \"Possible\";\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint N; cin >> N;\n\tvector<bool> A(1<<N);\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tchar c; cin >> c;\n\t\tassert(c == '0' || c == '1');\n\t\tA[(1<<N)-1-m] = (c == '1');\n\t}\n\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\t// m2 is a superset\n\t\t\tif (A[m] > A[m | (1<<i)]) {\n\t\t\t\tcout << IMPOSSIBLE << '\\n';\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t}\n\tcout << POSSIBLE << '\\n';\n\tmt19937 mt(48);\n\tvector<int> maxExclude;\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tif (A[m]) continue;\n\t\tbool isMaximal = true;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (!(m & (1<<i)) && !A[m | (1<<i)]) {\n\t\t\t\tisMaximal = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isMaximal) {\n\t\t\tmaxExclude.push_back(m);\n\t\t}\n\t}\n\tvector<int> pattern;\n\tfor (int m : maxExclude) {\n\t\tvector<int> pts;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (m & (1<<i)) continue;\n\t\t\tpts.push_back(i+1);\n\t\t}\n\t\tassert(!pts.empty());\n\t\tshuffle(pts.begin(), pts.end(), mt);\n\t\tqueue<vector<int>> q;\n\t\tfor (auto i : pts) {\n\t\t\tq.push(vector<int>({i}));\n\t\t}\n\t\twhile (q.size() > 1) {\n\t\t\tvector<int> a = std::move(q.front()); q.pop();\n\t\t\tvector<int> b = std::move(q.front()); q.pop();\n\t\t\tvector<int> r; r.reserve(a.size() * 2 + b.size() * 2);\n\t\t\tfor (int i : a) r.push_back(i);\n\t\t\tfor (int i : b) r.push_back(i);\n\t\t\treverse(a.begin(), a.end());\n\t\t\treverse(b.begin(), b.end());\n\t\t\tfor (int i : a) r.push_back(-i);\n\t\t\tfor (int i : b) r.push_back(-i);\n\t\t\tq.push(std::move(r));\n\t\t}\n\t\tpattern.insert(pattern.end(), q.front().begin(), q.front().end());\n\t}\n\t/*\n\tvector<int> pattern = std::y_combinator([&](auto self, int n, int l, int r) -> vector<int> {\n\t\tassert(A[r-1]);\n\t\tif (n == 0) {\n\t\t\treturn {};\n\t\t}\n\t\tvector<int> a = self(n-1, l + (1<<(n-1)), r);\n\t\tvector<int> res = a;\n\t\tres.push_back(n);\n\t\tif (A[l+(1<<(n-1))-1]) {\n\t\t\tvector<int> b = self(n-1, l, l + (1<<(n-1)));\n\t\t\tfor (int i : b) res.push_back(i);\n\t\t\tres.push_back(-n);\n\t\t\treverse(b.begin(), b.end());\n\t\t\tfor (int i : b) res.push_back(-i);\n\t\t}\n\t\treturn res;\n\t})(N, 0, (1<<N));\n\t*/\n\n\tvector<bool> patA(1<<N);\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tstack<int> st;\n\t\tfor (int i : pattern) {\n\t\t\tif (m & (1<<(abs(i)-1))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!st.empty() && st.top() == -i) {\n\t\t\t\tst.pop();\n\t\t\t} else {\n\t\t\t\tst.push(i);\n\t\t\t}\n\t\t}\n\t\tpatA[m] = st.empty();\n\t}\n\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tassert(patA[m] == A[m]);\n\t}\n\n\tvector<pair<int, int>> pos;\n\tpos.emplace_back(0,1);\n\tauto goToPt = [&](int x) {\n\t\tassert(pos.back().second == 1);\n\t\tif (pos.back() == pair<int, int>(x,1)) {\n\t\t\treturn;\n\t\t}\n\t\tpos.emplace_back(pos.back().first, 0);\n\t\twhile (pos.back().first < x) {\n\t\t\tpos.emplace_back(pos.back().first+1, 0);\n\t\t}\n\t\twhile (pos.back().first > x) {\n\t\t\tpos.emplace_back(pos.back().first-1, 0);\n\t\t}\n\t\tpos.emplace_back(x,1);\n\t};\n\tfor (auto i : pattern) {\n\t\tassert(i != 0);\n\t\tif (i > 0) {\n\t\t\tgoToPt(i-1);\n\t\t\tpos.emplace_back(i, 1);\n\t\t} else {\n\t\t\tgoToPt(-i);\n\t\t\tpos.emplace_back(-i-1, 1);\n\t\t}\n\t}\n\n\tgoToPt(0);\n\n\tif (int(pos.size()) - 1 > 250000) {\n\t\twhile (true);\n\t}\n\tcout << pos.size()-1 << '\\n';\n\tfor (auto it : pos) {\n\t\tcout << it.first << ' ' << it.second << '\\n';\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\n#include <assert.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\nconst int MOD=1e9+7;\n#define SZ 666666\nint n;\nchar a[SZ];\nbool v[SZ];\nvi neg(vi x)\n{\n\treverse(x.begin(),x.end());\n\tfor(auto&y:x) y=-y;\n\treturn x;\n}\nvi operator + (vi a,const vi&b)\n{\n\tfor(auto x:b) a.pb(x);\n\treturn a;\n}\nvi operator - (vi a,const vi&b)\n{\n\treturn a+neg(b);\n}\nvi cs(vi a,int l,int r)\n{\n\tif(l==r)\n\t\treturn {a[l]};\n\tint m=(l+r)>>1;\n\tvi L=cs(a,l,m),R=cs(a,m+1,r);\n\treturn L+R-L-R;\n}\nvi CL(vi t)\n{\n\treturn t;\n}\nvi v1{1},v2{2};\nvi AND(vi p,vi q)\n{\n\treturn CL(p+p+v1+p+p-v1+v2-q-v2-q+v2-q-v2-q);\n}\nint main()\n{\n\tcin>>n>>a;\n\tbool ok=1;\n\tvi g;\n\tfor(int i=0;i<(1<<n);++i) if(a[i]=='0'&&!v[i])\n\t{\n\t\tfor(int j=0;j<(1<<n);++j) if((j&i)==i)\n\t\t\tv[j]=1,ok&=a[j]=='0';\n\t\tvi t;\n\t\tfor(int j=0;j<n;++j) if(i&(1<<j)) t.pb(j+1);\n\t\tvi w=cs(t,0,t.size()-1);\n\t\tg=g+w;\n\t}\n\tif(!ok)\n\t{\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tputs(\"Possible\");\n\tvector<pii> v;\n\tv.pb(pii(0,0));\n\tfor(auto c:g)\n\t{\n\t\tint x=abs(c);\n\t\tif(c>0)\n\t\t{\n\t\t\tv.pb(pii(x-1,0));\n\t\t\tv.pb(pii(x-1,1));\n\t\t\tv.pb(pii(x,1));\n\t\t\tv.pb(pii(x,0));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tv.pb(pii(x-1,0));\n\t\t\tv.pb(pii(x,0));\n\t\t\tv.pb(pii(x,1));\n\t\t\tv.pb(pii(x-1,1));\n\t\t}\n\t}\n\tv.pb(pii(0,0));\n\tvector<pii> vt;\n\tfor(int i=0;i<v.size();++i)\n\t{\n\t\tpii A=v[i],B=v[(i+1)%v.size()];\n\t\tvt.pb(A);\n\t\tint g=abs(A.fi-B.fi)+(A.se-B.se);\n\t\tif(g)\n\t\t{\n\t\t\tfor(int j=1;j<=g;++j)\n\t\t\t{\n\t\t\t\tpii s(A.fi+(B.fi-A.fi)/g*j,\n\t\t\t\tA.se+(B.se-A.se)/g*j);\n\t\t\t\tvt.pb(s);\n\t\t\t}\n\t\t}\n\t}\n\tvt.erase(unique(vt.begin(),vt.end()),vt.end());\n\tv=vt;\n\tprintf(\"%d\\n\",int(v.size())-1);\n\tfor(auto c:v) printf(\"%d %d\\n\",c.fi,c.se);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n;\nchar p[260];\nstruct point {\n\tint x, ck, dir;\n};\nvector<point>Res;\nvoid Add(int x, int mask, int rev) {\n\tif (mask == 1) {\n\t\tRes.push_back({ x,rev,0 });\n\t\tRes.push_back({ x,!rev,1 });\n\t\treturn;\n\t}\n\tif (!(mask&1)) {\n\t\tRes.push_back({ x,rev,0 });\n\t\tAdd(x + 1, mask>>1, rev);\n\t\tRes.push_back({ x,rev,1 });\n\t\treturn;\n\t}\n\tRes.push_back({ x,rev,0 });\n\tAdd(x + 1, mask >> 1, rev);\n\tRes.push_back({ x,rev,1 });\n\tRes.push_back({ x,!rev,0 });\n\tAdd(x + 1, mask >> 1, !rev);\n\tRes.push_back({ x,!rev,1 });\n}\nstruct PP {\n\tint x, y;\n};\nvector<PP>RR;\nvoid Print(point a) {\n\tPP t1 = { a.x + a.dir, a.ck };\n\tPP t2 = { a.x + 1 - a.dir, a.ck };\n\tif (!RR.empty() && RR.back().x == t1.x && RR.back().y == t2.y) {\n\t\tRR.push_back(t2);\n\t}\n\telse {\n\t\tRR.push_back(t1);\n\t\tRR.push_back(t2);\n\t}\n}\nint main() {\n\tint i, j;\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", p);\n\tint s = 0;\n\tfor (i = 0; i < (1 << n); i++) {\n\t\tint c = 0;\n\t\tif (p[i] == '0')c++, s++;\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif ((i&j) == j) {\n\t\t\t\tif (p[j] == '0' && p[i] == '1') {\n\t\t\t\t\tputs(\"Impossible\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (p[j] == '0')c--;\n\t\t\t}\n\t\t}\n\t\tif (c == 1) {\n\t\t\tAdd(0, i, 0);\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tif (!s) {\n\t\tprintf(\"0\\n0 0\\n\");\n\t\treturn 0;\n\t}\n\tfor (auto &t : Res) {\n\t\tPrint(t);\n\t}\n\tif (RR.back().x == RR[0].x && RR.back().y == RR[0].y)RR.pop_back();\n\tprintf(\"%d\\n\", RR.size());\n\tRR.push_back(RR[0]);\n\tfor(auto &t :RR)printf(\"%d %d\\n\", t.x, t.y);\n}"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\n\nconst int mod = 1e9+7;\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nint n;\nchar s[256];\nchar revc(char c)\n{\n\tif (c>='a'&&c<='z') return 'A'+c-'a';\n\telse return 'a'+c-'A';\n}\nstring getf(int msk)\n{\n\tstring ret;\n\tif (__builtin_popcount(msk)==1)\n\t{\n\t\tret.PB(__builtin_ctz(msk)+'a');\n\t\treturn ret;\n\t}\n\telse\n\t{\n\t\tint x = __builtin_ctz(msk&(-msk));\n\t\tint nmsk = msk-(1<<x);\n\t\tstring t = getf(nmsk);\n\t\tret += t;\n\t\tret.PB('a'+x);\n\t\treverse(t.begin(), t.end());\n\t\tfor (int i=0; i<t.size(); i++) t[i] = revc(t[i]);\n\t\tret += t;\n\t\tret.PB('A'+x);\n\t\treturn ret;\n\t}\n}\nvector<pair<int,int> > rt;\nint curx, cury;\nvoid go(int x, int y)\n{\n\twhile (curx<x) curx++, rt.PB(MP(curx, cury));\n\twhile (curx>x) curx--, rt.PB(MP(curx, cury));\n\twhile (cury<y) cury++, rt.PB(MP(curx, cury));\n\twhile (cury>y) cury--, rt.PB(MP(curx, cury));\n}\nvoid out(string s)\n{\n\tassert(s.size()<250000);\n\tcurx = cury = 0;\n\trt.PB(MP(0, 0));\n\n\tfor (int i=0; i<s.size(); i++)\n\t{\n\t\tbool f;\n\t\tint x;\n\t\tif (s[i]>='a'&&s[i]<='z')\n\t\t{\n\t\t\tf = true;\n\t\t\tx = s[i]-'a';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tf = false;\n\t\t\tx = s[i]-'A';\n\t\t}\n\t\tif (f)\n\t\t{\n\t\t\tgo(x, 0);\n\t\t\tgo(x, 1);\n\t\t\tgo(x+1, 1);\n\t\t\tgo(x+1, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgo(x+1, 0);\n\t\t\tgo(x+1, 1);\n\t\t\tgo(x, 1);\n\t\t\tgo(x, 0);\n\t\t}\n\t}\n\tgo(0, 0);\n}\nint main()\n{\n\tcin>>n;\n\tcin>>s;\n\tfor (int i=0; i<(1<<n); i++)\n\t{\n\t\tif (s[i]=='1')\n\t\t{\n\t\t\tfor (int j=0; j<(1<<n); j++)\n\t\t\t{\n\t\t\t\tif ((i&j)==j&&s[j]=='0')\n\t\t\t\t{\n\t\t\t\t\tputs(\"Impossible\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tstring ans;\n\tvector<int> v;\n\tfor (int i=0; i<(1<<n); i++)\n\t{\n\t\tif (s[i]=='0')\n\t\t{\n\t\t\tstring t = getf(i);\n\t\t\tans += t;\n\t\t\tfor (auto c : t) ans += revc(c);\n\t\t}\n\t}\n\tout(ans);\n\tputsi(rt.size()-1);\n\tfor (int i=0; i<rt.size(); i++) putsii(rt[i].FF, rt[i].SS);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i = (begin); i < (end); i++)\n#define rep(i, n) FOR(i, 0, n)\nusing ll = long long;\nusing namespace std;\n#define all(x) (x).begin(),(x).end()\nusing pii = pair<int, int>; using vi = vector<int>; using vl = vector<ll>;\n\nint N;\nbool isSubsetOf(int i, int oo) {\n    return (oo | i) == oo;\n}\n\nsigned main() {\n    cin >> N;\n    int oo = 0;\n    string as;\n    cin >> as;\n    rep(i, 1<<N) {\n        if(as[i] == '1') {\n            oo |= i;\n            cerr << oo << endl;\n        }\n    }\n    rep(i, 1<<N) {\n        if(isSubsetOf(i, oo) && as[i] == '0') {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n        if(!isSubsetOf(i, oo) && as[i] == '1') {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n    \n    cout << \"Possible\" << endl;\n\n    int ii = (1<<N) - oo - 1;\n    // cerr << oo << ' ' << ii << endl;\n    // cerr << (oo & ii) << endl;\n    vector<pii> p;\n    int before = 0;\n    cerr << oo << endl;\n    cerr << ii << endl;\n    rep(i, N) {\n        // cerr << ii << endl;\n        // cerr << ((ii&1) ^ before) << endl;\n        if((ii&1) ^ before) {\n            if(ii&1) {\n                p.emplace_back(i, 0);\n                p.emplace_back(i, 1);\n            } else {\n                p.emplace_back(i, 1);\n                p.emplace_back(i, 0);\n            }\n        } else {\n            p.emplace_back(i, before);\n        }\n        before = ii & 1;\n        ii >>= 1;\n    }\n    if (before == 1)\n        p.emplace_back(N, 1);\n    for(int k = N; k>=0; k--) {\n        p.emplace_back(k, 0);\n    }\n\n    cout << p.size() - 1 << endl;\n    for(auto pp : p) {\n        cout << pp.first << ' ' << pp.second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n\n #include <stdio.h>\n #include <bits/stdc++.h>\n\n\n\n\n\n\nusing namespace std;\n\n\n\n\ntemplate<class T, size_t... I>\nvoid print_tuple(ostream& s, T const& a, index_sequence<I...>){\n  using swallow = int[];\n  (void)swallow{0, (void(s << (I == 0? \"\" : \", \") << get<I>(a)), 0)...};\n}\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a);\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a);\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a);\n\ntemplate<class T, size_t I>\nostream& operator<<(ostream& s, array<T, I> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, vector<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, multimap<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, multiset<T> const& a) { return print_collection(s, a); }\ntemplate<class T, class U>\nostream& operator<<(ostream& s, map<T, U> const& a) { return print_collection(s, a); }\ntemplate<class T>\nostream& operator<<(ostream& s, set<T> const& a) { return print_collection(s, a); }\n\ntemplate<class T>\nostream& print_collection(ostream& s, T const& a){\n  s << '[';\n  for(auto it = begin(a); it != end(a); ++it){\n    s << *it;\n    if(it != prev(end(a))) s << \" \";\n  }\n  return s << ']';\n}\n\ntemplate<class... A>\nostream& operator<<(ostream& s, tuple<A...> const& a){\n  s << '(';\n  print_tuple(s, a, index_sequence_for<A...>{});\n  return s << ')';\n}\n\ntemplate<class A, class B>\nostream& operator<<(ostream& s, pair<A, B> const& a){\n  return s << \"(\" << get<0>(a) << \", \" << get<1>(a) << \")\";\n}\n\n\n\n\n\n\n\nusing li = long long int;\nusing lu = long long unsigned;\nusing ld = long double;\n\n\nusing pii = tuple<li, li>;\nusing piii = tuple<li, li, li>;\nusing piiii = tuple<li, li, li, li>;\nusing vi = vector<li>;\nusing vii = vector<pii>;\nusing viii = vector<piii>;\nusing vvi = vector<vi>;\nusing vvii = vector<vii>;\nusing vviii = vector<viii>;\n\ntemplate<class T>\nusing min_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate<class T>\nusing max_queue = priority_queue<T>;\n\nstruct empty_t {};\nnamespace tuple_access {\n\n  struct xx_t {} xx;\n  struct yy_t {} yy;\n  struct zz_t {} zz;\n  struct ww_t {} ww;\n\n  template<class T>\n  typename tuple_element<0,T>::type& operator^(T& v, xx_t) { return get<0>(v); }\n  template<class T>\n  typename tuple_element<0,T>::type const& operator^(T const& v, xx_t) { return get<0>(v); }\n  template<class T>\n  typename tuple_element<0,T>::type&& operator^(T&& v, xx_t) { return get<0>(v); }\n\n  template<class T>\n  typename tuple_element<1,T>::type& operator^(T& v, yy_t) { return get<1>(v); }\n  template<class T>\n  typename tuple_element<1,T>::type const& operator^(T const& v, yy_t) { return get<1>(v); }\n  template<class T>\n  typename tuple_element<1,T>::type&& operator^(T&& v, yy_t) { return get<1>(v); }\n\n  template<class T>\n  typename tuple_element<2,T>::type& operator^(T& v, zz_t) { return get<2>(v); }\n  template<class T>\n  typename tuple_element<2,T>::type const& operator^(T const& v, zz_t) { return get<2>(v); }\n  template<class T>\n  typename tuple_element<2,T>::type&& operator^(T&& v, zz_t) { return get<2>(v); }\n\n  template<class T>\n  typename tuple_element<3,T>::type& operator^(T& v, ww_t) { return get<3>(v); }\n  template<class T>\n  typename tuple_element<3,T>::type const& operator^(T const& v, ww_t) { return get<3>(v); }\n  template<class T>\n  typename tuple_element<3,T>::type&& operator^(T&& v, ww_t) { return get<3>(v); }\n}\nusing namespace tuple_access;\n\n\nint ilog2(int x){ return 31 - __builtin_clz(x); }\n\ntemplate <class T>\nstruct identity : std::unary_function <T, T> {\n  T operator() (const T& x) const {return x;}\n};\n\ntemplate<class T>\nT& smin(T& x, T const& y) { x = min(x,y); return x; }\n\ntemplate <class T>\nT& smax(T& x, T const& y) { x = max(x, y); return x; }\n\n\ntemplate<typename T>\nT isqrt(T const&x){\n  static_assert(is_integral<T>::value, \"is_integral<T>::value\");\n  assert(x>=T(0));\n  T ret = static_cast<T>(sqrtl(x));\n  while(ret>0 && ret*ret>x) --ret;\n  while(x-ret*ret>2*ret) ++ret;\n  return ret;\n}\n\ntemplate<typename T>\nT icbrt(T const&x) {\n  static_assert(is_integral<T>::value, \"is_integral<T>::value\");\n  assert(x>=T(0));\n  T ret = static_cast<T>(cbrt(x));\n  while(ret>0 && ret*ret*ret>x) --ret;\n  while(x-ret*ret*ret>3*ret*(ret+1)) ++ret;\n  return ret;\n}\n\nconst int N = 8;\nbool A[1<<N];\nbool mark[1<<N];\n\nvoid fail() {\n  cout << \"Impossible\" << endl;\n  exit(0);\n}\n\nint main(){\n  ios::sync_with_stdio(0); cin.tie(0);\n\n  int n; cin>>n;\n  for(li i = 0; i < (li)(1<<n); ++i) {\n    char c; cin>>c;\n    A[i] = (c=='1');\n  }\n\n\n  if(!A[0]) fail();\n  for(li m1 = 0; m1 < (li)(1<<n); ++m1) for(li m2 = 0; m2 < (li)(1<<n); ++m2) if((m1&m2) == m1) {\n    if(A[m2] && !A[m1]) fail();\n  }\n  cout << \"Possible\" << endl;\n\n  vii ans;\n  ans.emplace_back(0,0);\n  li ax=0;\n\n  for(li m = 0; m < (li)(1<<n); ++m) if(!A[m] && !mark[m]) {\n\n    vii cur;\n    for(li i = 0; i < (li)(n); ++i) if(m&(1<<i)) {\n      if(cur.empty()) {\n        cur.emplace_back(i,0);\n        continue;\n      }\n      vii nx = cur;\n      nx.emplace_back(i,0);\n      reverse(begin(cur), end(cur));\n      for(auto p : cur) {\n        li u,v; tie(u,v) = p;\n        nx.emplace_back(u,1-v);\n      }\n      nx.emplace_back(i,1);\n      cur = nx;\n    }\n\n    for(auto uv : cur) {\n      li u,v; tie(u,v) = uv;\n      if(v == 0) {\n        while(ax < u) { ax++; ans.emplace_back(ax,0); }\n        while(ax > u) { ax--; ans.emplace_back(ax,0); }\n        ans.emplace_back(ax,1);\n        ans.emplace_back(ax+1,1);\n        ans.emplace_back(ax+1,0);\n        ax++;\n      }else {\n        while(ax < u+1) { ax++; ans.emplace_back(ax,0); }\n        while(ax > u+1) { ax--; ans.emplace_back(ax,0); }\n        ax--;\n        ans.emplace_back(ax+1,1);\n        ans.emplace_back(ax,1);\n        ans.emplace_back(ax,0);\n      }\n    }\n  }\n\n  while(ax) {\n    ax--;\n    ans.emplace_back(ax,0);\n  }\n\n  cout << ans.size()-1 << endl;\n  for(auto xy : ans) {\n    li x,y; tie(x,y) = xy;\n    cout << x << \" \" << y << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<queue>\n#include<iostream>\n#include<fstream>\n#include<string>\n#include<cassert>\n#include<algorithm>\n#include<random>\n#include<map>\n#include<set>\n#include <bitset>\n#include<ctime>\n \nusing namespace std;\n \n//int mod = 998244353;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\ntypedef vector<int>vi;\ntypedef vector<ll>vl;\ntypedef vector<char>vc;\ntypedef vector<string>vs;\ntypedef vector<vector<int>>vii;\ntypedef vector<vector<char>>vvc;\ntypedef vector<vector<ll>>vll;\ntypedef vector< pair<ll, ll>>vpll;\ntypedef vector< pair<ld, ld>>vpld;\ntypedef vector< pair<int, int>>vpi;\ntypedef pair<ld, ld>pld;\n#define mp make_pair\n#define pb push_back\n \nconst int mod = 998244353;\nint add(int a, int b)\n{\n\tint c = a + b;\n\tif (c >= mod)\n\t{\n\t\tc -= mod;\n\t}\n\treturn c;\n}\nint dif(int a, int b)\n{\n\tint c = a - b;\n\tif (c < 0)\n\t{\n\t\tc += mod;\n\t}\n\treturn c;\n}\nint mlt(int a, int b)\n{\nll c = a * 1LL * b;\nreturn c % mod;\n}\nint ibit(int n, int i)\n{\n\treturn ((n >> i) & 1);\n}\nvoid outp(vii &ou)\n{\n\tfor (int i = 0; i < ou.size(); i++)\n\t{\n\t\tfor (int j = 0; j < ou[i].size(); j++)\n\t\t{\n\t\t\tcout << ou[i][j] << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n}\nint bp(int x, int y)\n{\n\tif (y == 0)\n\t{\n\t\treturn 1;\n\t}\n\tint a = 0;\n\tif (!(y % 2))\n\t{\n\t\ta = bp(x, y / 2);\n\t}\n\treturn (y % 2) ? mlt(bp(x, y - 1), x) : mlt(a, a);\n}\nint obr(int x)\n{\n\treturn bp(x, mod - 2);\n}\nconst int maxn = 2000007;\nint fact[2000007], ofact[2000007];\nvoid prec()\n{\n\tfact[0] = 1;\n\tofact[0] = 1;\n\tfor (int i = 1; i < maxn; i++)\n\t{\n\t\tfact[i] = mlt(fact[i - 1], i);\n\t}\n\t//cerr << \"sdsds\" << endl;\n\tofact[maxn - 1] = obr(fact[maxn - 1]);\n\tfor (int i = maxn - 2; i > 0; i--)\n\t{\n\t\tofact[i] = mlt(ofact[i + 1], i + 1);\n\t}\n}\nint c(int a, int b)\n{\n\tif (a == 0)return 1;\n\treturn ((a <= b) && (a >= 0)) ? mlt(fact[b], mlt(ofact[a], ofact[b - a])) : 0;\n}\nll gcd(ll x, ll y)\n{\n\t//cerr << x << y << endl;\n\tif (x == 0)return y;\n\treturn(x > y) ? gcd(y, x) : gcd(y%x, x);\n}\nint obr2(int n)\n{\n\tint x = fact[n - 1];\n\tx = mlt(x, ofact[n]);\n\treturn x;\n}\nvoid crv(int nn, vpi &v)\n{\n\tcerr << nn << endl;\n\tif (nn > 0) {\n\t\tint n = nn;\n\t\tfor (int i = 0; i < n; i++)v.pb({ i + 1, 0 });\n\t\tv.pb({ n,1 });\n\t\tv.pb({ n - 1, 1 });\n\t\tfor (int i = n - 1; i >= 0; i--)v.pb({ i, 0 });\n\t}\n\tif (nn < 0) {\n\t\tint n = -nn;\n\t\tfor (int i = 0; i < n-1; i++)v.pb({ i + 1, 0 });\n\t\tv.pb({ n-1,1 });\n\t\tv.pb({ n , 1 });\n\t\tfor (int i = n; i >= 0; i--)v.pb({ i, 0 });\n\t}\n}\nvoid solve(istream &cin = std::cin, ostream &cout = std::cout)\n{\n\tvii imb(8);\n\timb[0] = { 1 };\n\tfor (int i = 1; i < 8; i++)\n\t{\n\t\tfor (int j = 0; j < imb[i - 1].size(); j++)imb[i].pb(imb[i - 1][j]);\n\t\timb[i].pb(i + 1);\n\t\tfor (int j = imb[i - 1].size(); j >= 0; j--)imb[i].pb((-1)*imb[i - 1][j]);\n\t\timb[i].pb(-i - 1);\n\t}\n\t//cerr << \"here\" << endl;\n\tint n;\n\tcin >> n;\n\tvi good(1 << n);\n\tfor (int i = 0; i < good.size(); i++)\n\t{\n\t\tchar c;\n\t\tcin >> c;\n\t\tgood[i] = c - '0';\n\t}\n\tint val = 0;\n\t//\tcerr << 433 << endl;\n\tfor (int a = 0; a < good.size(); a++)\n\t\tfor (int b = 0; b < good.size(); b++)\n\t\t\tif ((a | b) == b)\n\t\t\t\tif ((!good[a]) && (good[b]))\n\t\t\t\t{\n\t\t\t\t\t//\tcerr << a << ' ' << b << endl;\n\t\t\t\t\tval = 1;\n\t\t\t\t}\n//\tcerr << 5 << ' ' << 7 << ' ' << (5 | 7) << endl;\n\tif (val)cout << \"Impossible\" << endl;\n\telse\n\t{\n\t\tcout << \"Possible\" << endl;\n\t\t//cerr << 1111 << endl;\n\t\tvpi ay = { {0,0} };\n\t\tfor (int m = 0; m < good.size(); m++)\n\t\t{\n\t\t\t//cerr << m << endl;\n\t\t\tif (!good[m])\n\t\t\t{\n\t\t\t\tcerr << m << endl;\n\t\t\t\tvi v;\n\t\t\t\tfor (int i = 0; i <= 8; i++)if (ibit(m, i))v.pb(i);\n\t\t\t\tcerr << m << ' ' << v.size() << endl;\n\t\t\t\tfor (int i = 0; i < imb[v.size() - 1].size(); i++)\n\t\t\t\t{\n\t\t\t\t\tcerr << imb[v.size() - 1][i] << endl;\n\t\t\t\t\t//\tcerr << i << endl;\n\t\t\t\t\tif (imb[v.size()][i] > 0)crv(v[imb[v.size() - 1][i] - 1] + 1, ay);\n\t\t\t\t\tif (imb[v.size()][i] < 0)crv(-v[(-imb[v.size() - 1][i]) - 1] - 1, ay);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif (ay.size() < 190000)\n\t\t{\n\t\t\tcout << ay.size() - 1 << endl;\n\t\t\tfor (int i = 0; i < ay.size(); i++)cout << ay[i].first << ' ' << ay[i].second << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << 0 << endl;\n\t\t\tcout << 0 << ' ' << 0 << endl;\n\t\t}\n\t}\n}\nint main()\n{\n\tsolve();\n\tint n;\n\tcin >> n;\n}\n \n "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define I inline\n#define fi first\n#define se second\n#define R register\n#define LL long long\n#define mp make_pair\n#define reg register int\n#define pii pair<int,int>\n#define fo(i, a, b) for(reg i = a; i <= b; i++)\n#define fd(i, a, b) for(reg i = a; i >= b; i--)\n#define cr const reg&\nusing namespace std;\n\nI int _max(cr x, cr y) {return x > y ? x : y;}\nI int _min(cr x, cr y) {return x < y ? x : y;}\nI int read() {\n\treg x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n\treturn x * f;\n}\nI void ptt(LL x) {if(x >= 10) ptt(x / 10); putchar(x % 10 + '0');}\nI void put(LL x) {x < 0 ? putchar('-'), ptt(-x) : ptt(x);}\nI void pr1(LL x) {put(x), putchar(' ');}\nI void pr2(LL x) {put(x), puts(\"\");}\n\nchar ss[1 << 8];\nvector<pii> ans;\n\nstring rev(string s) {\n\treverse(s.begin(), s.end());\n\treturn s;\n}\n\nint main() {\n\treg n = read();\n\tscanf(\"%s\", ss);\n\tif(ss[0] == '0') {puts(\"Impossible\"); return 0;}\n\treg S = (1 << n) - 1;\n\tfo(i, 1, S) {\n\t\tif(ss[i] == '1') {\n\t\t\tfo(j, 0, n - 1) if(i >> j & 1) {\n\t\t\t\tif(ss[i ^ (1 << j)] == '0') {puts(\"Impossible\"); return 0;}\n\t\t\t}\n\t\t}\n\t} puts(\"Possible\");\n\treg now = 0; ans.push_back(pii{0, 0});\n\tfo(i, 1, S) if(ss[i] == '0'){\n\t\tbool bk = 0;\n\t\tfo(j, 0, n - 1) if(i >> j & 1) {\n\t\t\tif(ss[i ^ (1 << j)] == '0') {bk = 1; break;}\n\t\t} if(bk) break;\n\t\tstring q; q.clear();\n\t\tfd(j, n - 1, 0) if(i >> j & 1){\n\t\t\tstring c1 = {char('a' + j)}, c2 = {char('A' + j)};\n\t\t\tif(q.empty()) q += c1;\n\t\t\telse q = c1 + q + c1 + c2 + rev(q) + c2;\n\t\t} for(char c : q) {\n\t\t\treg p, o;\n\t\t\tif(isupper(c)) p = c - 'A', o = 1;\n\t\t\telse p = c - 'a', o = 0;\n\t\t\tfo(j, now + 1, p) ans.push_back(pii{j, 0});\n\t\t\tfd(j, now - 1, p) ans.push_back(pii{j, 0});\n\t\t\tnow = p;\n\t\t\tif(!o) {\n\t\t\t\tans.push_back(pii{p, 1});\n\t\t\t\tans.push_back(pii{p + 1, 1});\n\t\t\t\tans.push_back(pii{p + 1, 0});\n\t\t\t\tans.push_back(pii{p, 0});\n\t\t\t} else {\n\t\t\t\tans.push_back(pii{p + 1, 0});\n\t\t\t\tans.push_back(pii{p + 1, 1});\n\t\t\t\tans.push_back(pii{p, 1});\n\t\t\t\tans.push_back(pii{p, 0});\n\t\t\t}\n\t\t}\n\t} fd(j, now - 1, 0) ans.push_back(pii{j, 0});\n\tpr2((int)ans.size() - 1);\n\tfo(i, 0, (int)ans.size() - 1) pr1(ans[i].fi), pr2(ans[i].se);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main() {\n  ll N; cin >> N;\n  ll a[1 << N];\n  for (ll i = 0; i < (1 << N); i++) {\n    char c; cin >> c;\n    a[i] = c - '0';\n  }\n  ll b[N];\n  for (ll i = 0; i < N; i++) {\n    b[i] = !a[1 << i];\n  }\n  for (ll bits = 0; bits < (1 << N); bits++) {\n    bool dots = false;\n    for (ll i = 0; i < N; i++) {\n      if ((bits >> i) & 1) dots |= b[i];\n    }\n    if (!(a[bits]^dots)) {\n      cout << \"Impossible\" << endl;\n      return 0;\n    }\n  }\n  cout << \"Possible\" << endl;\n  for (ll i = 0; i < N; i++) {\n    if (b[i]) {\n      cout << i << \" \" << 1 << endl;\n      cout << i << \" \" << 0 << endl;\n      cout << i+1 << \" \" << 0 << endl;\n    } else {\n      cout << i << \" \" << 1 << endl;\n    }\n  }\n  for (ll i = 0; i <= N; i++) {\n    cout << N-i << \" \" << 1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n, C[260];\nchar p[260];\nstruct point {\n\tint x, y;\n};\nvector<point>Res;\nvoid Add(int x, int y) {\n\tRes.push_back({ x,y });\n}\nvoid Add0() {\n\tint i;\n\tfor (i = 0; i < n; i++) Add(i, 1);\n\tfor (i = n; i > 0; i--)Add(i, 1);\n}\nvoid Add1(int x) {\n\tint i;\n\tfor (i = 0; i <= x + 1; i++)Add(i, 1);\n\tAdd(x + 1, 0);\n\tAdd(x, 0);\n\tfor (i = x; i > 0; i--)Add(i, 1);\n}\nvoid Add2(int xa, int xb) {\n\tint i;\n\tfor (i = 0; i <= xb + 1; i++) Add(i, 1);\n\tAdd(xb + 1, 0);\n\tAdd(xb, 0);\n\tfor (i = xb; i >= xa; i--)Add(i, 1);\n\tAdd(xa, 0);\n\tAdd(xa + 1, 0);\n\tfor (i = xa + 1; i <= xb; i++)Add(i, 1);\n\tAdd(xb, 0);\n\tAdd(xb + 1, 0);\n\tfor (i = xb + 1; i > xa; i--)Add(i, 1);\n\tAdd(xa + 1, 0);\n\tAdd(xa, 0);\n\tfor (i = xa; i > 0; i--)Add(i, 1);\n}\nvoid Print() {\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d\\n\", Res.size());\n\tint i;\n\tRes.push_back(Res[0]);\n\tfor (auto &t : Res)printf(\"%d %d\\n\", t.x, t.y);\n}\nint main() {\n\tint i, j;\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", p);\n\tfor (i = 0; i < (1 << n); i++) {\n\t\tint c = 0;\n\t\tfor (j = 0; j < n; j++)if ((i >> j) & 1)c++;\n\t\tC[i] = c;\n\t}\n\tfor (i = 0; i < (1 << n); i++) {\n\t\tint ck = 0;\n\t\tif (p[i] == '0' && C[i] >= 3)ck = 1;\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif ((i&j) == j) {\n\t\t\t\tif (p[j] == '0'&&p[i] == '1') {\n\t\t\t\t\tputs(\"Impossible\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (C[j] == 2 && p[j] == '0')ck = 0;\n\t\t\t}\n\t\t}\n\t\tif (ck == 1) {\n\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tAdd0();\n\tint pv = -1;\n\tfor (i = 0; i < n; i++) {\n\t\tif (p[1 << i] == '0') {\n\t\t\tAdd1(i);\n\t\t\tpv = i;\n\t\t}\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t\tif (p[1 << i] == '1'&&p[1 << j] == '1'&&p[(1 << i) | (1 << j)] == '0') {\n\t\t\t\tAdd2(i, j);\n\t\t\t\tif (pv != -1)Add1(pv);\n\t\t\t}\n\t\t}\n\t}\n\tPrint();\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\n\ntemplate <class T1, class T2>\nostream& operator << (ostream& out, const pair <T1, T2> p)\n{\n    out << '(' << p.first << ',' << p.second << ')';\n    return out;\n}\n\ntemplate <class T1, class T2>\nistream& operator >> (istream& in, pair<T1, T2> &p)\n{\n    in >> p.first >> p.second;\n    return in;\n}\n\ntemplate <class T>\nistream& operator >> (istream& in, vector<T> &v)\n{\n    for (T &x : v)\n        in >> x;\n    return in;\n}\n\ntemplate <class T>\nostream& operator << (ostream& out, const vector<vector<T>> &v)\n{\n    for (const vector<T> &x : v)\n        out << x << '\\n';\n    return out;\n}\n\ntemplate <class T>\nostream& operator << (ostream& out, const vector<T> &v)\n{\n    for (const T &x : v)\n        out << x << ' ';\n    return out;\n}\n\nlong long gcd (long long a, long long b)\n{\n    if (b > a)\n        swap(a, b);\n    return (b ? gcd(b, a % b) : a);\n}\n\nusing ll   = long long;\nusing pii  = pair<int, int>;\nusing pll  = pair<long long, long long>;\nusing tiii = pair<pair<int, int>, int>;\nusing vi   = vector<int>;\nusing vl   = vector<long long>;\nusing vvi  = vector<vector<int>>;\nusing vvl  = vector<vector<long long>>;\n\n#define F          first\n#define S          second\n#define First      first.first\n#define Second     first.second\n#define Third      second\n#define mp         make_pair\n#define rep(i,a,b) for (int i = (a); i < (b); i++)\n#define per(i,b,a) for (int i = (b); i > (a); i--)\n#define all(x)     x.begin(), x.end()\n#define ret(x)     return cout << x, 0;\n#define throwex    throw runtime_error (\"Found the error.\");\n\nconst int h = 1000000007;\n\nint n;\nvector<pii> get_cycle(int mask, int cur = 0)\n{\n    int last_1_index = 0;\n    int z = mask;\n    while(z != 1)\n        last_1_index++, z /= 2;\n    vector<pii> ans;\n    if(cur == last_1_index)\n    {\n        ans.push_back({cur, 1});\n        ans.push_back({cur+1, 1});\n        ans.push_back({cur+1, 0});\n        ans.push_back({cur, 0});\n        ans.push_back({cur, 1});\n        return ans;\n    }\n    ans.push_back({cur, 1});\n    vector<pii> next_cycle = get_cycle(mask, cur + 1);\n    ans.insert(ans.end(), all(next_cycle));\n    ans.push_back({cur, 1});\n    if(mask & (1 << cur))\n    {\n        ans.push_back({cur, 0});\n        ans.push_back({cur+1, 0});\n        reverse(all(next_cycle));\n        ans.insert(ans.end(), all(next_cycle));\n        ans.push_back({cur, 1});\n    }\n    return ans;\n}\n\nsigned main()\n{\n    ios::sync_with_stdio(false);\n    #ifdef ONLINE_JUDGE\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    cerr.setstate(ios::failbit);\n    #endif\n\n    cin >> n;\n    string a;\n    cin >> a;\n    rep(i,0,1 << n)\n    {\n        rep(j,0,i)\n        {\n            if((j | i) == i and a[i] == '1' and a[j] == '0')\n                ret(\"Impossible\");\n        }\n    }\n    vector<pii> ans;\n    ans.push_back({0, 1});\n    rep(i,0,1 << n)\n    {\n        if(a[i] == '0')\n        {\n            vector<pii> cycle = get_cycle(i);\n            ans.insert(ans.end(), cycle.begin() + 1, cycle.end());\n            for(int j = i; j < (1 << n); j++)\n                if((i | j) == j)\n                    a[j] = '1';\n            cerr << cycle << '\\n';\n        }\n    }\n    assert(ans.size() <= 250000);\n    cout << \"Possible\\n\";\n    cout << ans.size() - 1 << '\\n';\n    for(pii x : ans)\n        cout << x.F << ' ' << x.S << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<vector>\n#include<queue>\n#include<iostream>\n#include<fstream>\n#include<string>\n#include<cassert>\n#include<algorithm>\n#include<random>\n#include<map>\n#include<set>\n#include <bitset>\n#include<ctime>\n\nusing namespace std;\n\n//int mod = 998244353;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\ntypedef vector<int>vi;\ntypedef vector<ll>vl;\ntypedef vector<char>vc;\ntypedef vector<string>vs;\ntypedef vector<vector<int>>vii;\ntypedef vector<vector<char>>vvc;\ntypedef vector<vector<ll>>vll;\ntypedef vector< pair<ll, ll>>vpll;\ntypedef vector< pair<ld, ld>>vpld;\ntypedef vector< pair<int, int>>vpi;\ntypedef pair<ld, ld>pld;\n#define mp make_pair\n#define pb push_back\n\nconst int mod = 998244353;\nint add(int a, int b)\n{\n\tint c = a + b;\n\tif (c >= mod)\n\t{\n\t\tc -= mod;\n\t}\n\treturn c;\n}\nint dif(int a, int b)\n{\n\tint c = a - b;\n\tif (c < 0)\n\t{\n\t\tc += mod;\n\t}\n\treturn c;\n}\nint mlt(int a, int b)\n{\n\tll c = a * 1LL * b;\n\treturn c % mod;\n}\nint ibit(int n, int i)\n{\n\treturn ((n >> i) & 1);\n}\nvoid outp(vii &ou)\n{\n\tfor (int i = 0; i < ou.size(); i++)\n\t{\n\t\tfor (int j = 0; j < ou[i].size(); j++)\n\t\t{\n\t\t\tcout << ou[i][j] << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n}\nint bp(int x, int y)\n{\n\tif (y == 0)\n\t{\n\t\treturn 1;\n\t}\n\tint a = 0;\n\tif (!(y % 2))\n\t{\n\t\ta = bp(x, y / 2);\n\t}\n\treturn (y % 2) ? mlt(bp(x, y - 1), x) : mlt(a, a);\n}\nint obr(int x)\n{\n\treturn bp(x, mod - 2);\n}\nconst int maxn = 2000007;\nint fact[2000007], ofact[2000007];\nvoid prec()\n{\n\tfact[0] = 1;\n\tofact[0] = 1;\n\tfor (int i = 1; i < maxn; i++)\n\t{\n\t\tfact[i] = mlt(fact[i - 1], i);\n\t}\n\t//cerr << \"sdsds\" << endl;\n\tofact[maxn - 1] = obr(fact[maxn - 1]);\n\tfor (int i = maxn - 2; i > 0; i--)\n\t{\n\t\tofact[i] = mlt(ofact[i + 1], i + 1);\n\t}\n}\nint c(int a, int b)\n{\n\tif (a == 0)return 1;\n\treturn ((a <= b) && (a >= 0)) ? mlt(fact[b], mlt(ofact[a], ofact[b - a])) : 0;\n}\nll gcd(ll x, ll y)\n{\n\t//cerr << x << y << endl;\n\tif (x == 0)return y;\n\treturn(x > y) ? gcd(y, x) : gcd(y%x, x);\n}\nint obr2(int n)\n{\n\tint x = fact[n - 1];\n\tx = mlt(x, ofact[n]);\n\treturn x;\n}\nvoid crv(int nn, vpi &v)\n{\n\tif (nn > 0) {\n\t\tint n = nn;\n\t\tfor (int i = 0; i < n; i++)v.pb({ i + 1, 0 });\n\t\tv.pb({ n,1 });\n\t\tv.pb({ n - 1, 1 });\n\t\tfor (int i = n - 1; i >= 0; i--)v.pb({ i, 0 });\n\t}\n\tif (nn < 0) {\n\t\tint n = -nn;\n\t\tfor (int i = 0; i < n - 1; i++)v.pb({ i + 1, 0 });\n\t\tv.pb({ n - 1,1 });\n\t\tv.pb({ n , 1 });\n\t\tfor (int i = n; i >= 0; i--)v.pb({ i, 0 });\n\t}\n}\nvoid solve(istream &cin = std::cin, ostream &cout = std::cout)\n{\n\tvii imb(9);\n\timb[0] = { 1 };\n\tfor (int i = 1; i <= 8; i++)\n\t{\n\t\tfor (int j = 0; j < imb[i - 1].size(); j++)imb[i].pb(imb[i - 1][j]);\n\t\timb[i].pb(i + 1);\n\t\tfor (int j = imb[i - 1].size() - 1; j >= 0; j--)imb[i].pb((-1)*imb[i - 1][j]);\n\t\timb[i].pb(-i - 1);\n\t}\n\t//cerr << \"here\" << endl;\n\tint n;\n\tcin >> n;\n\tvi good(3);\n\tfor (int i = 0; i < good.size(); i++)\n\t{\n\t\tchar c;\n\t\tcin >> c;\n\t\tgood[i] = c - '0';\n\t}\n\tgood.resize(1 << n);\n\tint val = 0;\n\t//\tcerr << 433 << endl;\n\tfor (int a = 0; a<good.size(); a++)\n\t\tfor (int b = 0; b<good.size(); b++)\n\t\t\tif ((a | b) == b)\n\t\t\t\tif ((!good[a]) && (good[b]))\n\t\t\t\t{\n\t\t\t\t\t//\tcerr << a << ' ' << b << endl;\n\t\t\t\t\tval = 1;\n\t\t\t\t}\n\tif (val)cout << \"Impossible\" << endl;\n\telse\n\t{\n\t\t//cerr << 1111 << endl;\n\t\tvpi ay = { { 0,0 } };\n\t\tfor (int m = 0; m < good.size(); m++)\n\t\t{\n\t\t\t//cerr << m << endl;\n\t\t\tif (!good[m])\n\t\t\t{\n\t\t\t\tvi v;\n\t\t\t\tfor (int i = 0; i < 8; i++)if (ibit(m, i))v.pb(i);\n\t\t\t\tfor (int i = 0; i < imb[v.size() - 1].size(); i++)\n\t\t\t\t{\n\t\t\t\t\t//\tcerr << i << endl;\n\t\t\t\t\tif (imb[v.size()][i] > 0)crv(v[imb[v.size() - 1][i] - 1], ay);\n\t\t\t\t\tif (imb[v.size()][i] < 0)crv(-v[(-imb[v.size() - 1][i]) - 1], ay);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << \"Possible\" << endl;\n\t\tcout << ay.size() << endl;\n\t\tfor (int i = 0; i < ay.size(); i++)cout << ay[i].first << ' ' << ay[i].second << endl;\n\t}\n}\nint main()\n{\n\tsolve();\n\tint n;\n\tcin >> n;\n}"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\n\nconst int mod = 1e9+7;\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nint n;\nchar s[257];\nchar revc(char c)\n{\n\tif (c>='a'&&c<='z') return 'A'+c-'a';\n\telse return 'a'+c-'A';\n}\nstring getf(int msk)\n{\n\tstring ret;\n\tif (__builtin_popcount(msk)==1)\n\t{\n\t\tret.PB(__builtin_ctz(msk)+'a');\n\t\treturn ret;\n\t}\n\telse\n\t{\n\t\tint x = __builtin_ctz(msk&(-msk));\n\t\tint nmsk = msk-(1<<x);\n\t\tstring t = getf(nmsk);\n\t\tret += t;\n\t\tret.PB('a'+x);\n\t\treverse(t.begin(), t.end());\n\t\tfor (int i=0; i<t.size(); i++) t[i] = revc(t[i]);\n\t\tret += t;\n\t\tret.PB('A'+x);\n\t\treturn ret;\n\t}\n}\nvector<pair<int,int> > rt;\nint curx, cury;\nvoid go(int x, int y)\n{\n\twhile (curx<x) curx++, rt.PB(MP(curx, cury));\n\twhile (curx>x) curx--, rt.PB(MP(curx, cury));\n\twhile (cury<y) cury++, rt.PB(MP(curx, cury));\n\twhile (cury>y) cury--, rt.PB(MP(curx, cury));\n}\nvoid out(string s)\n{\n\tassert(s.size()<250000);\n\tcurx = cury = 0;\n\trt.PB(MP(0, 0));\n\n\tfor (int i=0; i<s.size(); i++)\n\t{\n\t\tbool f;\n\t\tint x;\n\t\tif (s[i]>='a'&&s[i]<='z')\n\t\t{\n\t\t\tf = true;\n\t\t\tx = s[i]-'a';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tf = false;\n\t\t\tx = s[i]-'A';\n\t\t}\n\t\tif (f)\n\t\t{\n\t\t\tgo(x, 0);\n\t\t\tgo(x, 1);\n\t\t\tgo(x+1, 1);\n\t\t\tgo(x+1, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgo(x+1, 0);\n\t\t\tgo(x+1, 1);\n\t\t\tgo(x, 1);\n\t\t\tgo(x, 0);\n\t\t}\n\t}\n\tgo(0, 0);\n}\nint main()\n{\n\tcin>>n;\n\tcin>>s;\n\tfor (int i=0; i<(1<<n); i++)\n\t{\n\t\tif (s[i]=='1')\n\t\t{\n\t\t\tfor (int j=0; j<(1<<n); j++)\n\t\t\t{\n\t\t\t\tif ((i&j)==j&&s[j]=='0')\n\t\t\t\t{\n\t\t\t\t\tputs(\"Impossible\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tstring ans;\n\tvector<int> v;\n\tfor (int i=0; i<(1<<n); i++)\n\t{\n\t\tif (s[i]=='0')\n\t\t{\n\t\t\tbool f = true;\n\t\t\tfor (int j=0; j<i; j++)\n\t\t\t{\n\t\t\t\tif ((i&j)==j)\n\t\t\t\t{\n\t\t\t\t\tf &= s[j]=='1';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f)\n\t\t\t{\n\t\t\t\tstring t = getf(i);\n\t\t\t\tans += t;\n\t\t\t\tif ((i&(-i))!=i) for (auto c : t) ans += revc(c);\n\t\t\t}\n\t\t}\n\t}\n\tcerr<<ans<<endl;\n\tout(ans);\n\tputsi(rt.size()-1);\n\tfor (int i=0; i<rt.size(); i++) putsii(rt[i].FF, rt[i].SS);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define fr first\n#define sc second\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n\nvector<P> ret;\n\nvoid pos(int i){\n\tfor(int j=0;j<i;j++){\n\t\tret.push_back(P(j+1,0));\n\t}\n\tret.push_back(P(i,1));\n\tret.push_back(P(i+1,1));\n\tret.push_back(P(i+1,0));\n\tret.push_back(P(i,0));\n\tfor(int j=i-1;j>=0;j--){\n\t\tret.push_back(P(j,0));\n\t}\n}\nvoid neg(int i){\n\tfor(int j=0;j<i;j++){\n\t\tret.push_back(P(j+1,0));\n\t}\n\tret.push_back(P(i+1,0));\n\tret.push_back(P(i+1,1));\n\tret.push_back(P(i,1));\n\tret.push_back(P(i,0));\n\tfor(int j=i-1;j>=0;j--){\n\t\tret.push_back(P(j,0));\n\t}\n}\n\t\n\nint main(){\n\tint n;\n\tstring s;\n\tcin>>n>>s;\n\t\n\tint a[300];\n\tfor(int i=0;i<(1<<n);i++)a[i]=s[i]-'0';\n\t\n\tbool used[300];\n\tmemset(used,0,sizeof used);\n\t\n\tint b[300];\n\tfor(int i=0;i<300;i++)b[i]=1;\n\t\n\tfor(int x=1;x<(1<<n);x++){\n\t\tused[x]=true;\n\t\t//if(used[x])cerr<<x<<endl;\n\t\tfor(int y=0;y<x;y++){\n\t\t\tif((x&y)==y)if(used[y])used[x]=false;\n\t\t}\n\t\t//if(used[x])cerr<<x<<endl;\n\t\tfor(int y=0;y<(1<<n);y++){\n\t\t\tif((x&y)==x)if(a[y]==1)used[x]=false;\n\t\t}\n\t\t//if(used[x])cerr<<x<<endl;\n\t\tif(used[x]){\n\t\t\tfor(int y=0;y<(1<<n);y++){\n\t\t\t\tif((x&y)==x)b[x]=0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool ok=true;\n\tfor(int i=0;i<(1<<n);i++)ok&=a[i]==b[i];\n\tif(!ok){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tret.push_back(P(0,0));\n\tfor(int x=0;x<(1<<n);x++){\n\t\tif(!used[x])continue;\n\t\tint cnt=0;\n\t\tint c[10];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif((x>>i)&1)c[cnt++]=i;\n\t\t}\n\t\tif(cnt==1){\n\t\t\tpos(c[0]);\n\t\t}\n\t\telse if(cnt==2){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[1]);\n\t\t}\n\t\telse if(cnt==3){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[2]);\n\t\t}\n\t}\n\t\n\t/*for(int i=0;i<n;i++){\n\t\tif(used[i][i]){\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t}\n\t\t\tret.push_back(P(i,1));\n\t\t\tret.push_back(P(i+1,1));\n\t\t\tret.push_back(P(i+1,0));\n\t\t\tret.push_back(P(i,0));\n\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\tret.push_back(P(j,0));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int k=i+1;k<n;k++){\n\t\t\tif(used[i][k]){\n\t\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(i,1));\n\t\t\t\tret.push_back(P(i+1,1));\n\t\t\t\tret.push_back(P(i+1,0));\n\t\t\t\tret.push_back(P(i,0));\n\t\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(k,1));\n\t\t\t\tret.push_back(P(k+1,1));\n\t\t\t\tret.push_back(P(k+1,0));\n\t\t\t\tret.push_back(P(k,0));\n\t\t\t\tfor(int j=k-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(i+1,0));\n\t\t\t\tret.push_back(P(i+1,1));\n\t\t\t\tret.push_back(P(i,1));\n\t\t\t\tret.push_back(P(i,0));\n\t\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(k+1,0));\n\t\t\t\tret.push_back(P(k+1,1));\n\t\t\t\tret.push_back(P(k,1));\n\t\t\t\tret.push_back(P(k,0));\n\t\t\t\tfor(int j=k-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}*/\n\t\n\tputs(\"Possible\");\n\tprintf(\"%d\\n\",(int)(ret.size())-1);\n\tfor(int i=0;i<ret.size();i++){\n\t\tprintf(\"%d %d\\n\",ret[i].fr,ret[i].sc);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\nclock_t __my_start_clock = clock();\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(\"[\"#x\"] Time : %.3lf s.\\n\", (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n#define TIMESTAMPf(x,...) eprintf(\"[\" x \"] Time : %.3lf s.\\n\", __VA_ARGS__, (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n\nusing namespace std;\n\n#ifdef LOCAL\nstatic struct __timestamper {\n  string what;\n  __timestamper(const char* what) : what(what){};\n  __timestamper(const string& what) : what(what){};\n  ~__timestamper(){\n    TIMESTAMPf(\"%s\", what.data());\n\t}\n} __TIMESTAMPER(\"end\");\n#else \nstruct __timestamper {};\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\n\nbool solve(int n, string s) {\n  if (s[0] == '0')\n    return false;\n  vector<int> bads;\n  for (int i = 0; i < (1 << n); i++) {\n    for (int j = 0; j < n; j++) {\n      if (!(i & (1 << j))) {\n        continue;\n      }\n    }\n    bool found_zero_sub = false;\n    for (int j = 0; j < n; j++) {\n      if (!(i & (1 << j))) {\n        continue;\n      }\n      if (s[i ^ (1 << j)] == '0') {\n        found_zero_sub = true;\n      }\n    }\n    if (found_zero_sub) {\n      if (s[i] == '1') {\n        return false;\n      }\n    } else {\n      if (s[i] == '0') {\n        bads.push_back(i);\n      }\n    }\n  }\n\n  vector<int> seq;\n\n  for (int x : bads) {\n    vector<int> ss;\n    for (int i = 0; i < n; i++) {\n      if (!(x & (1 << i))) {\n        continue;\n      }\n      int cur = ss.size();\n      ss.push_back(i + 1);\n      for (int j = cur - 1; j >= 0; j--) {\n        ss.push_back(-ss[j]);\n      }\n      if (cur) {\n        ss.push_back(-(i + 1));\n      }\n    }\n    seq.insert(seq.end(), ss.begin(), ss.end());\n  }\n\n  printf(\"Possible\\n\");\n\n  vector<pair<int, int>> pts;\n\n  pts.emplace_back(0, 0);\n\n  auto push = [&] (int x,int y) {\n    if (pts.size() > 1 && pts[pts.size() - 2].first == x && pts[pts.size() - 2].second == y) {\n      pts.pop_back();\n    } else {\n      pts.emplace_back(x, y);\n    }\n  };\n\n  for (int x : seq) {\n    if (x > 0) {\n      for (int i = 1; i <= x; i++) {\n        push(0, i);\n      }\n      push(1, x);\n      push(1, x - 1);\n      for (int i = x - 1; i >= 0; i--) {\n        push(0, i);\n      }\n    } else {\n      x = -x;\n      for (int i = 1; i < x; i++) {\n        push(0, i);\n      }\n      push(1, x - 1);\n      push(1, x);\n      for (int i = x ; i >= 0; i--) {\n        push(0, i);\n      }\n    }\n  }\n\n  printf(\"%d\\n\", (int)pts.size());\n  for (auto p : pts) {\n    printf(\"%d %d\\n\", p.first, p.second);\n  }\n  return true;\n}\n\nint main() {\n#ifdef LOCAL\n  freopen(\"e.in\", \"r\", stdin);\n  freopen(\"e.out\", \"w\", stdout);\n#endif\n\n  int n;\n  while (scanf(\"%d\", &n) == 1) {\n    char s[512];\n    scanf(\"%s\", s);\n    if (!solve(n, s)) {\n      printf(\"Impossible\\n\");\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define fr first\n#define sc second\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n\nvector<P> ret;\n\nvoid pos(int i){\n\tfor(int j=0;j<i;j++){\n\t\tret.push_back(P(j+1,0));\n\t}\n\tret.push_back(P(i,1));\n\tret.push_back(P(i+1,1));\n\tret.push_back(P(i+1,0));\n\tret.push_back(P(i,0));\n\tfor(int j=i-1;j>=0;j--){\n\t\tret.push_back(P(j,0));\n\t}\n}\nvoid neg(int i){\n\tfor(int j=0;j<i;j++){\n\t\tret.push_back(P(j+1,0));\n\t}\n\tret.push_back(P(i+1,0));\n\tret.push_back(P(i+1,1));\n\tret.push_back(P(i,1));\n\tret.push_back(P(i,0));\n\tfor(int j=i-1;j>=0;j--){\n\t\tret.push_back(P(j,0));\n\t}\n}\n\nvector<P> f(vector<P> vec,int t){\n\tint cnt[10];\n\tfor(int i=0;i<vec.size();i++){\n\t\tcnt[vec[i].sc]++;\n\t}\n\tint MIN=100;\n\tint id=-1;\n\tfor(int i=0;i<MIN;i++){\n\t\tif(MIN>cnt[i]){\n\t\t\tMIN=cnt[i];\n\t\t\tid=i;\n\t\t}\n\t}\n\tvector<P> ret;\n\tfor(int i=0;i<vec.size();i++){\n\t\tif(vec[i].sc!=id)ret.push_back(vec[i]);\n\t\telse {\n\t\t\tif(vec[i].fr==1){\n\t\t\t\tret.push_back(P(1,id));\n\t\t\t\tret.push_back(P(1,t));\n\t\t\t\tret.push_back(P(-1,id));\n\t\t\t\tret.push_back(P(-1,t));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret.push_back(P(1,t));\n\t\t\t\tret.push_back(P(1,id));\n\t\t\t\tret.push_back(P(-1,t));\n\t\t\t\tret.push_back(P(-1,id));\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\t\n\nint main(){\n\tint n;\n\tstring s;\n\tcin>>n>>s;\n\t\n\tint a[300];\n\tfor(int i=0;i<(1<<n);i++)a[i]=s[i]-'0';\n\t\n\tbool used[300];\n\tmemset(used,0,sizeof used);\n\t\n\tint b[300];\n\tfor(int i=0;i<300;i++)b[i]=1;\n\t\n\tfor(int x=1;x<(1<<n);x++){\n\t\tused[x]=true;\n\t\t//if(used[x])cerr<<x<<endl;\n\t\tfor(int y=0;y<x;y++){\n\t\t\tif((x&y)==y)if(used[y])used[x]=false;\n\t\t}\n\t\t//if(used[x])cerr<<x<<endl;\n\t\tfor(int y=0;y<(1<<n);y++){\n\t\t\tif((x&y)==x)if(a[y]==1)used[x]=false;\n\t\t}\n\t\t//if(used[x])cerr<<x<<endl;\n\t\tif(used[x]){\n\t\t\tfor(int y=0;y<(1<<n);y++){\n\t\t\t\tif((x&y)==x)b[y]=0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool ok=true;\n\tfor(int i=0;i<(1<<n);i++)ok&=a[i]==b[i];\n\tif(!ok){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tret.push_back(P(0,0));\n\tfor(int x=0;x<(1<<n);x++){\n\t\tif(!used[x])continue;\n\t\tint cnt=0;\n\t\tint c[10];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif((x>>i)&1)c[cnt++]=i;\n\t\t}\n\t\t\n\t\tvector<P> vec;\n\t\tvec.push_back(P(1,c[0]));\n\t\tfor(int i=1;i<cnt;i++)vec=f(vec,c[i]);\n\t\tfor(int i=0;i<vec.size();i++){\n\t\t\tif(vec[i].fr==1)pos(vec[i].sc);\n\t\t\telse neg(vec[i].sc);\n\t\t}\n\t\t\n\t\t/*if(cnt==1){\n\t\t\tpos(c[0]);\n\t\t}\n\t\telse if(cnt==2){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[1]);\n\t\t}\n\t\telse if(cnt==3){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[2]);\n\t\t}\n\t\telse if(cnt==4){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tneg(c[3]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[3]);\n\t\t\tpos(c[2]);\n\t\t\tneg(c[3]);\n\t\t\tneg(c[2]);\n\t\t}\n\t\telse if(cnt==5){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[1]);\n\t\t\tpos(c[4]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[4]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tneg(c[3]);\n\t\t\tpos(c[0]);\n\t\t\tpos(c[4]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[4]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tpos(c[2]);\n\t\t}\n\t\telse if(cnt==6){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[1]);\n\t\t\tpos(c[4]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[4]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tneg(c[3]);\n\t\t\tpos(c[0]);\n\t\t\tpos(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[4]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[4]);\n\t\t\tneg(c[1]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tpos(c[2]);\n\t\t}\n\t\telse if(cnt==7){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[1]);\n\t\t\tpos(c[6]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[6]);\n\t\t\tpos(c[4]);\n\t\t\tpos(c[6]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[4]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tneg(c[3]);\n\t\t\tpos(c[0]);\n\t\t\tpos(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[4]);\n\t\t\tpos(c[1]);\n\t\t\tpos(c[6]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[4]);\n\t\t\tpos(c[6]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[1]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tpos(c[2]);\n\t\t}\n\t\telse if(cnt==7){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[1]);\n\t\t\tpos(c[6]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[6]);\n\t\t\tpos(c[4]);\n\t\t\tpos(c[7]);\n\t\t\tneg(c[4]);\n\t\t\tneg(c[7]);\n\t\t\tpos(c[6]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[1]);\n\t\t\tpos(c[7]);\n\t\t\tpos(c[4]);\n\t\t\tneg(c[7]);\n\t\t\tneg(c[4]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tneg(c[3]);\n\t\t\tpos(c[0]);\n\t\t\tpos(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[4]);\n\t\t\tpos(c[7]);\n\t\t\tneg(c[4]);\n\t\t\tneg(c[7]);\n\t\t\tpos(c[1]);\n\t\t\tpos(c[6]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[6]);\n\t\t\tpos(c[7]);\n\t\t\tpos(c[4]);\n\t\t\tneg(c[7]);\n\t\t\tneg(c[4]);\n\t\t\tpos(c[6]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[1]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tpos(c[2]);\n\t\t}*/\n\t}\n\t\n\t/*for(int i=0;i<n;i++){\n\t\tif(used[i][i]){\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t}\n\t\t\tret.push_back(P(i,1));\n\t\t\tret.push_back(P(i+1,1));\n\t\t\tret.push_back(P(i+1,0));\n\t\t\tret.push_back(P(i,0));\n\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\tret.push_back(P(j,0));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int k=i+1;k<n;k++){\n\t\t\tif(used[i][k]){\n\t\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(i,1));\n\t\t\t\tret.push_back(P(i+1,1));\n\t\t\t\tret.push_back(P(i+1,0));\n\t\t\t\tret.push_back(P(i,0));\n\t\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(k,1));\n\t\t\t\tret.push_back(P(k+1,1));\n\t\t\t\tret.push_back(P(k+1,0));\n\t\t\t\tret.push_back(P(k,0));\n\t\t\t\tfor(int j=k-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(i+1,0));\n\t\t\t\tret.push_back(P(i+1,1));\n\t\t\t\tret.push_back(P(i,1));\n\t\t\t\tret.push_back(P(i,0));\n\t\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(k+1,0));\n\t\t\t\tret.push_back(P(k+1,1));\n\t\t\t\tret.push_back(P(k,1));\n\t\t\t\tret.push_back(P(k,0));\n\t\t\t\tfor(int j=k-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}*/\n\t\n\tassert(ret.size()<=250000);\n\t\n\tputs(\"Possible\");\n\tprintf(\"%d\\n\",(int)(ret.size())-1);\n\tfor(int i=0;i<ret.size();i++){\n\t\tprintf(\"%d %d\\n\",ret[i].fr,ret[i].sc);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nchar s[300];int n;\nstruct Node {int x,y;Node(){}Node(int _x,int _y){x=_x;y=_y;}};\nvector<Node> V;\ninline string inv(string s)\n{\n\treverse(s.begin(),s.end());\n\tfor(int i=0;i<(int)s.size();i++)\n\t{\n\t\tif(s[i]>='A'&&s[i]<='Z') s[i]+='a'-'A';\n\t\telse s[i]-='a'-'A';\n\t}\n\treturn s;\n}\nint main()\n{\n\tscanf(\"%d%s\",&n,s);\n\tfor(int i=0;i<(1<<n);i++) for(int j=0;j<(1<<n);j++)\n\t\tif((i&j)==(s[i]=='1'?j:i)&&s[j]!=s[i]) return puts(\"Impossible\"),0;\n\tputs(\"Possible\");\n\tV.push_back(Node(0,0));\n\tfor(int i=0;i<(1<<n);i++) if(s[i]=='0')\n\t{\n\t\tbool flag=1;\n\t\tfor(int j=0;j<i;j++) if((i&j)==j&&s[j]=='0'){flag=0;break;}\n\t\tif(!flag) continue;\n\t\tstring S;\n\t\tfor(int j=0;j<n;j++) if((i>>j)&1)\n\t\t{\n\t\t\tif(S.size()==0)S+='a'+j;\n\t\t\telse S=(char)('a'+j)+S+(char)('A'+j)+inv(S);\n\t\t}\n\t\tint lstv=0;\n\t\tfor(int j=0;j<(int)S.size();j++)\n\t\t{\n\t\t\tint now,fv;\n\t\t\tif(S[j]>='A'&&S[j]<='Z') now=S[j]-'A',fv=0;\n\t\t\telse now=S[j]-'a',fv=1;\n\t\t\tfor(int k=lstv+1;k<=now;k++) V.push_back(Node(k,0));\n\t\t\tfor(int k=lstv-1;k>=now;k--) V.push_back(Node(k,0));\n\t\t\tif(fv)\n\t\t\t{\n\t\t\t\tV.push_back(Node(now,1));V.push_back(Node(now+1,1));\n\t\t\t\tV.push_back(Node(now+1,0));V.push_back(Node(now,0));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tV.push_back(Node(now+1,0));V.push_back(Node(now+1,1));\n\t\t\t\tV.push_back(Node(now,1));V.push_back(Node(now,0));\n\t\t\t}\n\t\t\tlstv=now;\n\t\t}\n\t\tfor(int j=lstv-1;j>=0;j--) V.push_back(Node(j,0));\n\t}\n\tcout<<V.size()-1<<endl;\n\tfor(int i=0;i<(int)V.size();i++) printf(\"%d %d\\n\",V[i].x,V[i].y);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst char* IMPOSSIBLE = \"Impossible\";\nconst char* POSSIBLE = \"Possible\";\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint N; cin >> N;\n\tvector<bool> A(1<<N);\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tchar c; cin >> c;\n\t\tassert(c == '0' || c == '1');\n\t\tA[m] = (c == '0');\n\t}\n\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\t// m2 is a superset\n\t\t\tif (A[m] > A[m | (1<<i)]) {\n\t\t\t\tcout << IMPOSSIBLE << '\\n';\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t}\n\tcout << POSSIBLE << '\\n';\n\tvector<int> minM;\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tif (!A[m]) continue;\n\t\tbool isMinimal = true;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif ((m & (1<<i)) && A[m ^ (1<<i)]) {\n\t\t\t\tisMinimal = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isMinimal) {\n\t\t\tminM.push_back(m);\n\t\t}\n\t}\n\n\tqueue<vector<int>> q;\n\tfor (int m : minM) {\n\t\tvector<int> v;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (m & (1<<i)) {\n\t\t\t\tv.push_back(i+1);\n\t\t\t}\n\t\t}\n\t\tq.push(v);\n\t}\n\n\twhile (q.size() >= 2) {\n\t\tvector<int> a = std::move(q.front()); q.pop();\n\t\tvector<int> b = std::move(q.front()); q.pop();\n\n\t\tvector<int> c;\n\t\tfor (int i : a) { c.push_back(i); }\n\t\tfor (int i : b) { c.push_back(i); }\n\t\treverse(a.begin(), a.end());\n\t\treverse(b.begin(), b.end());\n\t\tfor (int i : a) { c.push_back(-i); }\n\t\tfor (int i : b) { c.push_back(-i); }\n\t\tq.push(c);\n\t}\n\n\tvector<int> pattern;\n\tif (!q.empty()) {\n\t\tpattern = std::move(q.front()); q.pop();\n\t}\n\n\tvector<pair<int, int>> pos;\n\tpos.emplace_back(0,1);\n\tauto goToPt = [&](int x) {\n\t\tassert(pos.back().second == 1);\n\t\tif (pos.back() == pair<int, int>(x,1)) {\n\t\t\treturn;\n\t\t}\n\t\tpos.emplace_back(pos.back().first, 0);\n\t\twhile (pos.back().first < x) {\n\t\t\tpos.emplace_back(pos.back().first+1, 0);\n\t\t}\n\t\twhile (pos.back().first > x) {\n\t\t\tpos.emplace_back(pos.back().first-1, 0);\n\t\t}\n\t\tpos.emplace_back(x,1);\n\t};\n\tfor (auto i : pattern) {\n\t\tassert(i != 0);\n\t\tif (i > 0) {\n\t\t\tgoToPt(i-1);\n\t\t\tpos.emplace_back(i, 1);\n\t\t} else {\n\t\t\tgoToPt(-i);\n\t\t\tpos.emplace_back(-i-1, 1);\n\t\t}\n\t}\n\n\tgoToPt(0);\n\n\tcout << pos.size()-1 << '\\n';\n\tfor (auto it : pos) {\n\t\tcout << it.first << ' ' << it.second << '\\n';\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> pi;\ntypedef vector<pi> vi;\nstruct node{\n    int tp,x,y;\n};\nvector <node> res;\nvector <pi> ans;\nchar s[256];\nint n,f[256],g[256];\nbool check1(int x){\n    for (int i=0;i<(1<<n);i++) if (i&(1<<x)){\n        if (f[i]) return 0;\n    }\n    return 1;\n}\nbool check2(int x,int y){\n    for (int i=0;i<(1<<n);i++) if ((i&(1<<y))&&(i&(1<<x))){\n        if (f[i]) return 0;\n    }\n    return 1;\n}\nvoid work1(int x){\n    //cout<<\"!\"<<x<<endl;\n    for (int i=0;i<(1<<n);i++) if (i&(1<<x)) g[i]=1;\n    ans.pb((pi){x,0});\n    ans.pb((pi){x,1});\n    ans.pb((pi){x+1,1});\n    ans.pb((pi){x+1,0});\n    ans.pb((pi){0,0});\n}\nvoid work2(int x,int y){\n    //cout<<\"!\"<<x<<' '<<y<<endl;\n    for (int i=0;i<(1<<n);i++) if ((i&(1<<y))&&(i&(1<<x))) g[i]=1;\n    ans.pb((pi){x,0});\n    ans.pb((pi){x,1});\n    ans.pb((pi){x+1,1});\n    ans.pb((pi){x+1,0});\n    ans.pb((pi){y+1,0});\n    ans.pb((pi){y+1,1});\n    ans.pb((pi){x,1});\n    ans.pb((pi){x,0});\n    ans.pb((pi){y,0});\n    ans.pb((pi){y,1});\n    ans.pb((pi){y+1,1});\n    ans.pb((pi){y+1,0});\n    ans.pb((pi){0,0});\n}\nvi _unique(vi a){\n    vi ret; ret.clear();\n    for (int i=0;i<a.size()-1;i++){\n        pi x=a[i],y=a[i+1];\n        if (x.F<y.F){\n            for (int j=x.F;j<y.F;j++) ret.pb((pi){j,x.S});\n        } else if (x.F>y.F){\n            for (int j=x.F;j>y.F;j--) ret.pb((pi){j,x.S});\n        } else if (x.S<y.S){\n            for (int j=x.S;j<y.S;j++) ret.pb((pi){x.F,j});\n        } else if (x.S>y.S){\n            for (int j=x.S;j>y.S;j--) ret.pb((pi){x.F,j});\n        }\n    }\n    ret.pb((pi){0,0});\n    return ret;\n}\nint main(){\n    cin >> n >> s;\n    for (int i=0;i<(1<<n);i++) f[i]=s[i]=='1';\n    ans.pb((pi){0,0});\n    for (int i=0;i<n;i++) if (check1(i)) work1(i);\n    for (int i=0;i<n;i++)\n    for (int j=i+1;j<n;j++) if (check2(i,j)) work2(i,j);\n    for (int i=0;i<(1<<n);i++) if (f[i]==g[i]) {\n        puts(\"Impossible\");\n        return 0;\n    }\n    puts(\"Possible\");\n    vi ans2=_unique(ans);\n    cout << ans2.size()-1 << endl;\n    for (auto x:ans2) cout << x.F << ' ' << x.S << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define INF ((1<<30)-1)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nvoid ok(){\n    cout << \"Yes\" << endl;\n    exit(0);\n}\n\nvoid ng(){\n    cout <<  \"Impossible\" << endl;\n    exit(0);\n}\n\n\nint n;\nint a[1 << 8];\n\nvector<int> loops;\n\nvoid entangle(int x){\n    vector<int> loop;\n    for(int i = n-1;i >= 0;i--){\n        if((x >> i) % 2 == 0)continue;\n        if(loop.empty()){\n            loop.push_back(i+1);\n            loop.push_back(-i-1);\n        }\n        else{\n            vector<int> tmp;\n            tmp.push_back(i+1);\n            for(auto it = loop.begin();it != loop.end();it++)tmp.push_back(*it);\n            tmp.push_back(i+1);\n            tmp.push_back(-i-1);\n            for(auto it = loop.rbegin();it != loop.rend();it++)tmp.push_back(*it);\n            tmp.push_back(-i-1);\n            loop = tmp;\n        }\n    }\n    loop.push_back(INF);\n    for(auto elem:loop)loops.push_back(elem);\n}\n\nvoid show(){\n    cout << \"Possible\" << endl;\n    vector<P> ps;\n    ps.push_back(P(0,0));\n    int nowx = 0, nowy = 0;\n    for(int x:loops){\n        if(x == INF){\n            while(nowx > 0){\n                ps.push_back(P(--nowx, nowy));\n            }\n            continue;\n        }\n        if(x > 0){\n            while(nowx > x){\n                ps.push_back(P(--nowx, nowy));\n            }\n            while(nowx < x-1){\n                ps.push_back(P(++nowx, nowy));\n            }\n            ps.push_back(P(nowx,++nowy));\n            if(nowx == x)ps.push_back(P(--nowx, nowy));\n            else ps.push_back(P(++nowx, nowy));\n            ps.push_back(P(nowx,--nowy));\n        }\n        if(x < 0){\n            x = x * -1;\n            while(nowx > x){\n                ps.push_back(P(--nowx, nowy));\n            }\n            while(nowx < x-1){\n                ps.push_back(P(++nowx, nowy));\n            }\n            if(nowx == x)ps.push_back(P(--nowx, nowy));\n            else ps.push_back(P(++nowx, nowy));\n        }\n    }\n    cout << ps.size() - 1 << endl;\n    for(auto p:ps){\n        cout << p.first << \" \" << p.second << endl;\n    }\n}\n\nint main(){\n    cin >> n;\n    for(int i = 0;i < (1<<n);i++){\n        scanf(\"%1d\", a+i);\n        bool bad;\n        if(a[i] == 0)bad = true;\n        for(int j = 0;j < i;j++){\n            if((j & i) != j)continue;\n            if(a[i] == 1 && a[j] == 0){\n                ng();                    \n            }\n            if(a[j] == 0)bad = false;\n        }\n        if(bad){\n            entangle(i);\n        }\n    }\n    show();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> rec(int x) {\n\tvector <int> sol;\n\tint pet = 1, bit;\n\tfor (bit = 0; (x&pet) == 0; bit++)\n\t\tpet = 1<<bit;\n\tif (pet == x) {\n\t\tsol.push_back(bit);\n\t\treturn sol;\n\t}\n\tvector<int> aux = sol  = rec(x^pet);\n\tsol.push_back(bit);\n\tfor (auto it = aux.rbegin(); it != aux.rend(); it++)\n\t\tsol.push_back(-*it);\n\tsol.push_back(-bit);\n\treturn sol;\n}\n\nstring tira(const vector<int> & par) {\n\tstring sol;\n\tfor (int x: par) {\n\t\tsol += string(abs(x),'R');\n\t\tif (x > 0) sol += \"URDL\";\n\t\telse sol += \"RULD\";\n\t\tsol += string(abs(x),'L');\n\t}\n\treturn sol;\n}\n\n\nint main() {\n  ios_base::sync_with_stdio(false); \n  cin.tie(nullptr); \n\n\tint n;\n\tcin >> n;\n\tstring s;\n\tcin >> s;\n\tint m = 1<<n;\n\tbool ok = true;\n\tvector<int> obs;\n\tfor (int i = 1; i < m; i++) {\n\t\tif (s[i] == '0') obs.push_back(i);\n\t\tfor (int j = i+1; j < m; j++) {\n\t\t\tint p = i, g = j;\n\t\t\tif (p > g) swap(p, g);\n\t\t\tif ((p&g) == p and s[p] == '1' and s[g] == '0') ok = false;\n\t\t}\n\t}\n\tif (!ok) cout << \"Impossible\" << endl;\n\telse {\n\t\tcout << \"Possible\" << endl;\n\t\tstring sol;\n\t\tfor (auto x: obs) \n\t\t\tsol += tira(rec(x));\n\t\tint k = sol.size();\n\t\tcout << k +1  << endl;\n\t\tint px = 0, py = 0; \n\t\tcout << px << \" \" << py << \"\\n\";\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tif (sol[i] == 'U') py++;\n\t\t\telse if (sol[i] == 'D') py--;\n\t\t\telse if (sol[i] == 'L') px--;\n\t\t\telse if (sol[i] == 'R') px++;\n\t\t\tcout << px << \" \" << py << \"\\n\";\n\t\t}\n\t}\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifdef __LOCAL\n    #define DBG(X) cout << #X << \" = \" << (X) << endl;\n    #define SAY(X) cout << (X) << endl;\n#else\n    #define DBG(X)\n    #define SAY(X)\n#endif\n\n#ifdef __LOCAL\n    #include <filesystem>\n    namespace fs = std::filesystem;\n#endif\n\nusing namespace std;\n\nusing ll = long long int;\nusing ull = unsigned long long int;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\nint dx[]={1, 0, -1, 0, 1,-1, 1,-1};\nint dy[]={0, 1, 0, -1, 1, 1,-1,-1};\nconst int INT_INF = (int)(2e9);\nconst ll  LL_INF = (ll)(2e18);\nstatic mt19937 _g(time(nullptr));\n \ninline ll randint(ll a, ll b) { ll w = (_g() << 31LL) ^ _g(); return a + w % (b - a + 1); }\ninline void fast_io() { ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); };\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const pair<T, S> p) { cout << \"[\" << p.first << \";\" << p.second << \"]\"; return os; }\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const map<T, S> p) { for (auto el : p) cout << \"[\" << el.first << \";\" << el.second << \"]\"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const vector<T>& v) { for (auto el : v) cout << el << \" \"; return os; }\ntemplate<typename T> inline vector<T> fetch_vec(int sz) { vector<T> ret(sz); for (auto& elem : ret) cin >> elem; return ret; }\n\nint N;\nstring A;\nvoid input(){\n    fast_io();\n    #ifdef __LOCAL\n        fs::path p = __FILE__;\n        fs::path input,output;\n        input = output = p.parent_path();\n        input += string(\"/input/\") + string(p.stem()) + string(\".txt\");\n        output += string(\"/output/\") + string(p.stem()) + string(\".txt\");\n        freopen(input.c_str(), \"r\", stdin);\n        freopen(output.c_str(), \"w\", stdout);\n    #endif\n    cin >> N;\n    cin >> A;\n}\n\nint high,low;\n\nbool isOK(ll bit){\n    string bitstr = bitset<10>(bit).to_string();\n    bool ishole = false;\n    bool issecvoid = false;\n    bool issechole = false;\n    for (int i = 0; i < 10; i++)\n    {\n        if(bitstr[i]=='0'){\n            if(ishole){\n                if(!issecvoid) low = 10-(i-1);\n                issecvoid = true;\n            }\n        }\n        if(bitstr[i]=='1'){\n            if(!ishole) high = 10-i;\n            if(issecvoid) return false;\n            ishole=true;\n            }\n    }\n    if(!issecvoid) low=0;\n    return true;\n}\n\nint solve(){\n    if(A[0]=='0'){cout << \"Impossible\" << endl; return 0;}\n    ll bitA=0LL;\n    for (int i = 0; i < N; i++)\n    {\n        bitA |= (A[(1<<i)]=='0');\n    }\n    if(!isOK(bitA)){cout << \"Impossible\" << endl; return 0;}\n    for (int bit = 0; bit < (1<<N); bit++)\n    {\n        if((bitA&bit)==bit) continue;\n        else{cout << \"Impossible\" << endl; return 0;}\n    }\n    ll L=2+2*(high-low);\n    cout << \"Possible\" << endl;\n    cout << L << endl;\n    cout << low  << \" \" << 0 << endl;    \n    cout << high << \" \" << 0 << endl;    \n    cout << high << \" \" << 1 << endl;    \n    cout << low  << \" \" << 1 << endl;    \n    \n    return 0;\n}   \n\nint main()\n{\n    input();\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define rrng(a) a.rbegin(),a.rend()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define eb emplace_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ntypedef vector<T> vt;\ninline int getInt() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define dame { puts(\"Impossible\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\nconst int MX = 200005;\n\nvp f(vi a) {\n  int x = a.back();\n  if (sz(a) == 1) {\n    vp res;\n    rep(i,x+2) res.eb(i,0);\n    drep(i,x+2) res.eb(i,1);\n    return res;\n  }\n  a.pop_back();\n  rep(i,sz(a)) a[i] -= x+1;\n  vp d = f(a);\n  rep(i,sz(d)) d[i].fi += x+1;\n  vp res;\n  rep(i,x+1) res.eb(i,0);\n  res.insert(res.end(), rng(d));\n  res.eb(x+1,0);\n  res.eb(x,0);\n  res.eb(x,1);\n  reverse(rng(d));\n  res.insert(res.end(), rng(d));\n  res.eb(x+1,1);\n  res.eb(x,1);\n  drep(i,x+1) res.eb(i,0);\n  res.eb(0,1);\n  return res;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  string st;\n  cin>>st;\n  int n2 = 1<<n;\n  vi a(n2);\n  rep(i,n2) a[i] = st[i]-'0';\n  rep(i,n2) a[i] ^= 1;\n  rep(i,n2) {\n    if (a[i]) continue;\n    for (int j = i;; j = (j-1)&i) {\n      if (a[j]) dame;\n      if (!j) break;\n    }\n  }\n  if (a[0]) dame;\n  cout<<\"Possible\"<<endl;\n  vp ans;\n  rep(i,n2) {\n    if (!a[i]) continue;\n    vi s;\n    rep(j,n) if (i>>j&1) s.pb(j);\n    reverse(rng(s));\n    vp now = f(s);\n    ans.insert(ans.end(), rng(now));\n  }\n  ans.eb(0,0);\n  cout<<sz(ans)-1<<endl;\n  for (P p : ans) {\n    cout<<p.fi<<\" \"<<p.se<<endl;\n  }\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst char* IMPOSSIBLE = \"Impossible\";\nconst char* POSSIBLE = \"Possible\";\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint N; cin >> N;\n\tvector<bool> A(1<<N);\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tchar c; cin >> c;\n\t\tassert(c == '0' || c == '1');\n\t\tA[(1<<N)-1-m] = (c == '1');\n\t}\n\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\t// m2 is a superset\n\t\t\tif (A[m] > A[m | (1<<i)]) {\n\t\t\t\tcout << IMPOSSIBLE << '\\n';\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t}\n\tcout << POSSIBLE << '\\n';\n\tmt19937 mt(48);\n\tvector<int> minM;\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tif (!A[m]) continue;\n\t\tbool isMinimal = true;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif ((m & (1<<i)) && A[m ^ (1<<i)]) {\n\t\t\t\tisMinimal = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isMinimal) {\n\t\t\tminM.push_back(m);\n\t\t}\n\t}\n\tshuffle(minM.begin(), minM.end(), mt);\n\n\tqueue<vector<int>> q;\n\tfor (int m : minM) {\n\t\tvector<int> v;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (m & (1<<i)) {\n\t\t\t\tv.push_back(i+1);\n\t\t\t}\n\t\t}\n\t\tshuffle(v.begin(), v.end(), mt);\n\t\tq.push(v);\n\t}\n\n\twhile (q.size() >= 2) {\n\t\tvector<int> a = std::move(q.front()); q.pop();\n\t\tvector<int> b = std::move(q.front()); q.pop();\n\n\t\tvector<int> c;\n\t\tfor (int i : a) { c.push_back(i); }\n\t\tfor (int i : b) { c.push_back(i); }\n\t\treverse(a.begin(), a.end());\n\t\treverse(b.begin(), b.end());\n\t\tfor (int i : a) { c.push_back(-i); }\n\t\tfor (int i : b) { c.push_back(-i); }\n\t\tq.push(c);\n\t}\n\n\tvector<int> pattern;\n\tif (!q.empty()) {\n\t\tpattern = std::move(q.front()); q.pop();\n\t}\n\n\tvector<pair<int, int>> pos;\n\tpos.emplace_back(0,1);\n\tauto goToPt = [&](int x) {\n\t\tassert(pos.back().second == 1);\n\t\tif (pos.back() == pair<int, int>(x,1)) {\n\t\t\treturn;\n\t\t}\n\t\tpos.emplace_back(pos.back().first, 0);\n\t\twhile (pos.back().first < x) {\n\t\t\tpos.emplace_back(pos.back().first+1, 0);\n\t\t}\n\t\twhile (pos.back().first > x) {\n\t\t\tpos.emplace_back(pos.back().first-1, 0);\n\t\t}\n\t\tpos.emplace_back(x,1);\n\t};\n\tfor (auto i : pattern) {\n\t\tassert(i != 0);\n\t\tif (i > 0) {\n\t\t\tgoToPt(i-1);\n\t\t\tpos.emplace_back(i, 1);\n\t\t} else {\n\t\t\tgoToPt(-i);\n\t\t\tpos.emplace_back(-i-1, 1);\n\t\t}\n\t}\n\n\tgoToPt(0);\n\n\tif (int(pos.size()) - 1 > 250000) {\n\t\twhile (true);\n\t}\n\tcout << pos.size()-1 << '\\n';\n\tfor (auto it : pos) {\n\t\tcout << it.first << ' ' << it.second << '\\n';\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<set>\n#include<vector>\n#include<functional>\n#include <random>\n#include<iostream>\n#include<iomanip>\nusing namespace std;\n\nint bits_on(int n) {\n\tint ret = 0;\n\twhile (n > 0) {\n\t\tret += n % 2;\n\t\tn = n >> 1;\n\t}\n\treturn ret;\n}\n\nint L;\nint x[250000], y[250000];\n\n\nvoid go_up(void) {\n\tL++;\n\tx[L] = x[L - 1];\n\ty[L] = y[L - 1] + 1;\n}\n\nvoid go_down(void) {\n\tL++;\n\tx[L] = x[L - 1];\n\ty[L] = y[L - 1] - 1;\n}\n\nvoid go_right(void) {\n\tL++;\n\tx[L] = x[L - 1] + 1;\n\ty[L] = y[L - 1];\n}\n\nvoid go_left(void) {\n\tL++;\n\tx[L] = x[L - 1] - 1;\n\ty[L] = y[L - 1];\n}\n\nvoid do_right_turn(void) {\n\tgo_up();\n\tgo_right();\n\tgo_down();\n\tgo_left();\n}\nvoid do_left_turn(void) {\n\tgo_right();\n\tgo_up();\n\tgo_left();\n\tgo_down();\n}\n\nint main() {\n\tint N;\n\tchar S[257];\n\tint A[256];\n\n\tcin >> N;\n\tcin >> S;\n\tfor (int i = 0; i < (1 << N); i++) {\n\t\tA[i] = S[i] - '0';\n\t}\n\tbool possible = true;\n\n\t/*添え字の集合について単調減少か？*/\n\tfor (int i = 0; i < (1 << N); i++) {\n\t\tfor (int j = 0; j < (1 << N); j++) {\n\t\t\tif (i & j == i) {\n\t\t\t\tif (A[i] < A[j]) {\n\t\t\t\t\tcout << \"Impossible\";\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*3つ以上の集合でいきなり0になることはないか？*/\n\tfor (int i = 0; i < (1 << N); i++) {\n\t\tif (bits_on(i) < 3) { continue; }\n\t\tif (A[i] == 0)\n\t\t{\n\t\t\tbool all1 = true;\n\t\t\tfor (int j = 0; j < (1 << N); j++) {\n\t\t\t\tif (i & j == j) {\n\t\t\t\t\tif (A[j] != 1) { all1 = false; break; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (all1) {\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\t/*空集合は1か？*/\n\tif (A[0] == 0) {\n\t\tcout << \"Impossible\";\n\t\treturn 0;\n\t}\n\n\n\tL = 0;\n\tx[0] = 0;\n\ty[0] = 0;\n\t/*0になっている1点集合を結ぶ*/\n\tfor (int i = 0; i < N; i++) {\n\t\tif (A[(1 << i)] == 0) {\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tgo_right();\n\t\t\t}\n\t\t\tgo_right();\n\t\t\tgo_up();\n\t\t\tgo_left();\n\t\t\tgo_down();\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tgo_left();\n\t\t\t}\n\t\t}\n\t}\n\n\t/*その部分集合が全部1で0になっている2点集合をどうにかする*/\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tint p = 1 << i;\n\t\t\tint q = 1 << j;\n\t\t\tif (A[p + q] == 0 && A[p] == 1 && A[q] == 1) {\n\t\t\t\tfor (int k = 0; k < i; k++) {\n\t\t\t\t\tgo_right();\n\t\t\t\t}\n\t\t\t\tdo_right_turn();\n\t\t\t\tfor (int k = 0; k < (j - i); k++) {\n\t\t\t\t\tgo_right();\n\t\t\t\t}\n\t\t\t\tdo_left_turn();\n\t\t\t\tfor (int k = 0; k < (j - i); k++) {\n\t\t\t\t\tgo_left();\n\t\t\t\t}\n\t\t\t\tdo_left_turn();\n\t\t\t\tfor (int k = 0; k < (j - i); k++) {\n\t\t\t\t\tgo_right();\n\t\t\t\t}\n\t\t\t\tdo_right_turn();\n\t\t\t\tfor (int k = 0; k < j; k++) {\n\t\t\t\t\tgo_left();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << L << \"\\n\";\n\tfor (int i = 0; i < L + 1; i++) {\n\t\tcout << x[i] << \" \" << y[i] << \"\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n;\n  cin>>n;\n  vector<bool> a(1<<n);\n  for(int i=0;i<(1<<n);i++){\n    char c;\n    cin>>c;\n    a.at(i)=(c=='1');\n  }\n  vector<int> s;\n  vector<bool> b(1<<n,1);\n  for(int i=0;i<(1<<n);i++){\n    if(a.at(i))\n      continue;\n    bool f=0;\n    for(int x:s)\n      if((x&i)==x)\n        f=1;\n    if(f)\n      continue;\n    s.push_back(i);\n    for(int j=0;j<(1<<n);j++)\n      b.at(j)=(b.at(j)&&((i&j)!=i));\n  }\n  if(a!=b){\n    cout<<\"Impossible\"<<endl;\n    return 0;\n  }\n  cout<<\"Possible\"<<endl;\n  vector<vector<int>> c;\n  for(int x:s){\n    vector<vector<int>> cx;\n    for(int i=0;i<n;i++,x/=2){\n      if(x%2==0)\n        continue;\n      vector<vector<int>> ci;\n      for(int j=0;j<n;j++){\n        ci.push_back({j,0});\n        if(i==j){\n          ci.push_back({j,1});\n          ci.push_back({j+1,1});\n        }\n      }\n      for(int j=n;j>0;j--)\n        ci.push_back({j,0});\n      if(cx.empty()){\n        cx=ci;\n        continue;\n      }\n      vector<vector<int>> cxb=cx;\n      vector<vector<int>> cib=ci;\n      reverse(cxb.begin()+1,cxb.end());\n      reverse(cib.begin()+1,cib.end());\n      for(auto y:ci)\n        cx.push_back(y);\n      for(auto y:cxb)\n        cx.push_back(y);\n      for(auto y:cib)\n        cx.push_back(y);\n    }\n    for(auto y:cx)\n      c.push_back(y);\n  }\n  c.push_back({0,0});\n  cout<<c.size()-1<<endl;\n  for(auto x:c)\n    cout<<x.at(0)<<' '<<x.at(1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing ll = long long;\nusing ull = unsigned long long;\nusing namespace std;\nconst int INF = 1e10;\nconst int MOD = 1e9 + 7;\n#define dump(x)                             \\\n    if (dbg) {                              \\\n        cerr << #x << \" = \" << (x) << endl; \\\n    }\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define FOR1(n) for (ll i = 0; i < (n); ++i)\n#define FOR2(i, n) for (ll i = 0; i < (n); ++i)\n#define FOR3(i, a, b) for (ll i = (a); i < (b); ++i)\n#define FOR4(i, a, b, c) for (ll i = (a); i < (b); i += (c))\n#define FOR(...) overload4(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)\n#define FORR(i, a, b) for (int i = (a); i <= (b); ++i)\n#define bit(n, k) ((n >> k) & 1) /*nのk bit目*/\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\nvoid Yes(bool flag = true) {\n    if (flag)\n        cout << \"Yes\" << endl;\n    else\n        cout << \"No\" << endl;\n}\nvoid No(bool flag = true) {\n    Yes(!flag);\n}\nvoid YES(bool flag = true) {\n    if (flag)\n        cout << \"YES\" << endl;\n    else\n        cout << \"NO\" << endl;\n}\nvoid NO(bool flag = true) {\n    YES(!flag);\n}\n#define pb emplace_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define all(v) (v).begin(), (v).end()\n#define SZ(x) ((int)(x).size())\n#define P pair<int, int>\n//#define V vector<int>\n//#define S set<int>\n#define itn int\nbool dbg = false;\n\nint N;\nstring A;\nbool checked[111010];\nbool out[111010];\n\nvector<int> x, y;\n\nvoid go(int gx) {\n    int sx;\n    int ys;\n    sx = x[(int)x.size() - 1];\n    ys = y[(int)y.size() - 1];\n    if (sx > gx) {\n        while (sx != gx) {\n            sx--;\n            x.pb(sx);\n            y.pb(ys);\n        }\n    } else if (sx < gx) {\n        while (sx != gx) {\n            sx++;\n            x.pb(sx);\n            y.pb(ys);\n        }\n    }\n}\nvoid chy() {\n    x.pb(x[(int)x.size() - 1]);\n    y.pb(!y[(int)y.size() - 1]);\n}\n\nvoid fill(int T, bool nikai = false) {\n    int cnt = __builtin_popcount(T);\n    if (cnt == 1) {\n        int nxt = __builtin_ffs(T) - 1;\n        go(nxt);\n        chy();\n        go(nxt + 1);\n        chy();\n        go(nxt);\n        chy();\n        go(nxt + 1);\n        chy();\n        go(nxt);\n        chy();\n        go(nxt + 1);\n        chy();\n        go(nxt);\n        return;\n    } else {\n        int n1 = __builtin_ffs(T) - 1;\n        T -= (1 << n1);\n        int n2 = __builtin_ffs(T) - 1;\n        int n3 = n2;\n        FOR(N) {\n            if ((1 << i) & T) {\n                n3 = i;\n            }\n        }\n        n3++;\n\n        go(n1);\n        chy();\n        go(n1 + 1);\n        chy();\n        go(n2);\n        chy();\n        if (n2 + 1 != n3) {\n            go(n2 + 1);\n            chy();\n            go(n3 - 1);\n            chy();\n        }\n        go(n3);\n        chy();\n        go(n2);\n        //ここで再帰\n        if (n2 + 1 != n3) {\n            fill(T);\n        }\n        go(n1 + 1);\n        chy();\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        if (n2 + 1 != n3) {\n            go(n3 - 1);\n            chy();\n            go(n2 + 1);\n            chy();\n        }\n        go(n2);\n        chy();\n        go(n1);\n\n\n        go(n1);\n        chy();\n        go(n1 + 1);\n        chy();\n        go(n2);\n        chy();\n        if (n2 + 1 != n3) {\n            go(n2 + 1);\n            chy();\n            go(n3 - 1);\n            chy();\n        }\n        go(n3);\n        chy();\n        go(n2);\n        go(n1 + 1);\n        chy();\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        if (n2 + 1 != n3) {\n            go(n3 - 1);\n            chy();\n            go(n2 + 1);\n            chy();\n        }\n        go(n2);\n        chy();\n        go(n1);\n\n\n        /*\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        go(n2);\n        chy();\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        go(n2);\n        chy();\n        go(n1);\n        */\n    }\n}\n\n\nvoid solve() {\n    bool flag = true;\n    int tmp = -1;\n    for (int T = 1; T < (1 << N); T++) {\n        if (A[T] == 1) {\n            continue;\n        }\n        if (checked[T]) {\n            continue;\n        }\n        out[T] = true;\n        if (__builtin_popcount(T) == 1) {\n            tmp = T;\n        }\n        for (int i = T; i < (1 << N); i = (i + 1) | T) {\n            // ここに処理を書く\n            if (A[i] == 1) {\n                flag = false;\n            }\n            checked[i] = true;\n        }\n    }\n    if (!flag) {\n        cout << \"Impossible\" << endl;\n        return;\n    }\n    cout << \"Possible\" << endl;\n\n    x.pb(0);\n    y.pb(0);\n\n    for (int T = 1; T < (1 << N); T++) {\n        if (out[T]) {\n            fill(T);\n        }\n    }\n    go(0);\n    int L = x.size();\n    cout << L - 1 << endl;\n\n    FOR(L) {\n        cout << x[i] << \" \" << y[i] << endl;\n    }\n}\n\nsigned main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cin >> N;\n    cin >> A;\n    for (auto& c : A)\n        c -= '0';\n\n\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MX = 8;\n\nvoid print(int n, int msk) {\n\tvector<pair<int, int>> ans;\n\tans.emplace_back(0, 1);\n\tfor (int i = 0, p = 0; i < n; i++) {\n\t\tif (((msk >> i) & 1) == 1) {\n\t\t\tif (p == 1) ans.pop_back();\n\t\t\telse ans.emplace_back(i, 0);\n\t\t\t\n\t\t\tans.emplace_back(i + 1, 0);\n\t\t\tans.emplace_back(i + 1, 1);\n\t\t\t\n\t\t\tp = 1;\n\t\t}\n\t\telse {\n\t\t\tans.emplace_back(i + 1, 1);\n\t\t\t\n\t\t\tp = 0;\n\t\t}\n\t}\n\t\n\tans.emplace_back(n, 2);\n\tfor (int i = n - 1; i >= 0; i--) ans.emplace_back(i, 2);\n\tans.emplace_back(0, 1);\n\t\n\tprintf(\"Possible\\n%zu\\n\", ans.size() - 1);\n\tfor (auto& p : ans) {\n\t\tprintf(\"%d %d\\n\", p.first, p.second);\n\t}\n\t\n\texit(0);\n}\n\nint a[1 << MX];\nchar s[2 << MX];\n\nint main() {\n\tint n;\n\tignore = scanf(\"%d %s\", &n, s);\n\tfor (int i = 0; i < (1 << n); i++) {\n\t\ta[i] = s[i] - '0';\n\t}\n\t\n\tfor (int msk = 0; msk < (1 << n); msk++) {\n\t\tbool ok = true;\n\t\tfor (int i = 0; i < (1 << n); i++) {\n\t\t\tint can = ((msk & i) == 0 ? 1 : 0);\n\t\t\tok = ok && can == a[i];\n\t\t}\n\t\t\n\t\tif (ok) print(msk, n);\n\t}\n\t\n\tprintf(\"%s\\n\", \"Impossible\");\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n, C[260];\nchar p[260];\nstruct point {\n\tint x, y;\n};\nvector<point>Res;\nvoid Add(int x, int y) {\n\tRes.push_back({ x,y });\n}\nvoid Add0() {\n\tint i;\n\tfor (i = 0; i < n; i++) Add(i, 1);\n\tfor (i = n; i > 0; i--)Add(i, 1);\n}\nvoid Add1(int x) {\n\tint i;\n\tfor (i = 0; i <= x + 1; i++)Add(i, 1);\n\tAdd(x + 1, 0);\n\tAdd(x, 0);\n\tfor (i = x; i > 0; i--)Add(i, 1);\n}\nvoid Add2(int xa, int xb) {\n\tint i;\n\tfor (i = 0; i <= xb + 1; i++) Add(i, 1);\n\tAdd(xb + 1, 0);\n\tAdd(xb, 0);\n\tfor (i = xb; i >= xa; i--)Add(i, 1);\n\tAdd(xa, 0);\n\tAdd(xa + 1, 0);\n\tfor (i = xa + 1; i <= xb; i++)Add(i, 1);\n\tAdd(xb, 0);\n\tAdd(xb + 1, 0);\n\tfor (i = xb + 1; i > xa; i--)Add(i, 1);\n\tAdd(xa + 1, 0);\n\tAdd(xa, 0);\n\tfor (i = xa; i > 0; i--)Add(i, 1);\n}\nvoid Do(vector<int>V) {\n\tint i, xe = V.back();\n\tfor (i = 0; i <= xe + 1; i++)Add(i, 1);\n\tAdd(xe + 1, 0);\n\tAdd(xe, 0);\n\tfor (i = xe; i > 0; i--)Add(i, 1);\n\tint pv = 0, sz = V.size();\n\tfor (i = 0; i <= xe + 1; i++) {\n\t\tAdd(i, 1);\n\t\tif (pv<sz && i == V[pv]) {\n\t\t\tAdd(i, 0);\n\t\t\tAdd(i + 1, 0);\n\t\t\tpv++;\n\t\t}\n\t}\n\tpv = sz - 2;\n\tfor (i = xe; i >= 1; i--) {\n\t\tAdd(i, 1);\n\t\tif (pv >= 0 && i == V[pv] + 1) {\n\t\t\tAdd(i, 0);\n\t\t\tAdd(i - 1, 0);\n\t\t\tpv--;\n\t\t}\n\t}\n}\nvoid Print() {\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d\\n\", Res.size());\n\tint i;\n\tRes.push_back(Res[0]);\n\tfor (auto &t : Res)printf(\"%d %d\\n\", t.x, t.y);\n}\nint CK[300];\nint main() {\n\tint i, j;\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", p);\n\tfor (i = 0; i < (1 << n); i++) {\n\t\tint c = 0;\n\t\tfor (j = 0; j < n; j++)if ((i >> j) & 1)c++;\n\t\tC[i] = c;\n\t}\n\tfor (i = 0; i < (1 << n); i++) {\n\t\tif (p[i] == '0')CK[i] = 1;\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif ((i&j) == j) {\n\t\t\t\tif (p[j] == '0'&&p[i] == '1') {\n\t\t\t\t\tputs(\"Impossible\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (p[j] == '0') {\n\t\t\t\t\tCK[i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tAdd0();\n\tint pv = -1;\n\tfor (i = 0; i < n; i++) {\n\t\tif (p[1 << i] == '0') {\n\t\t\tAdd1(i);\n\t\t\tpv = i;\n\t\t}\n\t}\n\tfor (i = 0; i < (1 << n); i++) {\n\t\tif (C[i]>=2 && CK[i]) {\n\t\t\tvector<int>V;\n\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\tif((i>>j)&1)V.push_back(j);\n\t\t\t}\n\t\t\tDo(V);\n\t\t}\n\t}\n\tPrint();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n \ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n \ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n \n#define mp make_pair \n#define f first\n#define s second\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n \n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n \nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \n \ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nint pct(int x) { return __builtin_popcount(x); } \nint bit(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nint cdiv(int a, int b) { return a/b+!(a<0||a%b == 0); } // division of a by b rounded up, assumes b > 0 \n \n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n \ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n \ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n \n// TO_STRING\n#define ts to_string\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class A> str ts(complex<A> c) { return ts(mp(c.real(),c.imag())); }\nstr ts(bool b) { return b ? \"true\" : \"false\"; }\nstr ts(char c) { str s = \"\"; s += c; return s; }\nstr ts(str s) { return s; }\nstr ts(const char* s) { return (str)s; }\nstr ts(vector<bool> v) { \n\tbool fst = 1; str res = \"{\";\n\tF0R(i,sz(v)) {\n\t\tif (!fst) res += \", \";\n\t\tfst = 0; res += ts(v[i]);\n\t}\n\tres += \"}\"; return res;\n}\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n\treturn res; }\ntemplate<class T> str ts(T v) {\n\tbool fst = 1; str res = \"{\";\n\tfor (const auto& x: v) {\n\t\tif (!fst) res += \", \";\n\t\tfst = 0; res += ts(x);\n\t}\n\tres += \"}\"; return res;\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; }\n \n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }\n \n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << to_string(h); if (sizeof...(t)) cerr << \", \";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL\n#define dbg(...) cerr << \"[\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n#else\n#define dbg(...) 42\n#endif\n \n// FILE I/O\nvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\nvoid unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }\nvoid setIO(string s = \"\") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n \nint N;\nstr s;\n \nvpi get(vi v) {\n\tvpi res;\n\tres.pb({v[0],0}); res.pb({v[0],1}); res.pb({v[0]+1,1});\n\tif (sz(v) == 1) { res.pb({v[0]+1,0}); return res; }\n\tFOR(i,v[0]+1,v[1]) res.pb({i,0});\n\t// dbg(\"HUH\",v,res);\n\tvpi z = get(vi(1+all(v))); res.insert(end(res),all(z));\n\tROF(i,v[0]+1,v[1]+1) res.pb({i,0});\n\tres.pb({v[0]+1,1});\n\tres.pb({v[0],1});\n\tres.pb({v[0],0}); \n\tFOR(i,v[0]+1,v[1]) res.pb({i,0});\n\treverse(1+all(z)); res.insert(end(res),all(z));\n\tROF(i,v[0]+1,v[1]+1) res.pb({i,0});\n\treturn res;\n}\n \nvpi construct(int x) {\n\tvi v;\n\tF0R(i,N) if (x&(1<<i)) v.pb(i);\n\tvpi ans;\n\tF0R(i,v[0]) ans.pb({i,0});\n\tauto z = get(v); ans.insert(end(ans),all(z));\n\tROF(i,1,v[0]+1) ans.pb({i,0});\n\treturn ans;\n}\n \nint main() {\n\tsetIO(); re(N,s);\n\tvi todo;\n\tF0R(i,1<<N) if (s[i] == '0') {\n\t\tbool mn = 1;\n\t\tF0R(j,N) if (i&(1<<j)) {\n\t\t\tif (s[i^(1<<j)] == '0') mn = 0;\n\t\t} else {\n\t\t\tif (s[i^(1<<j)] == '1') {\n\t\t\t\tps(\"Impossible\");\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t\tif (mn) todo.pb(i);\n\t}\n\t// dbg(get({0,1}));\n\tvpi ans;\n\ttrav(t,todo) {\n\t\tauto v = construct(t);\n\t\tans.insert(end(ans),all(v));\n\t}\n\tps(\"Possible\");\n\tint res = sz(ans)+1; ps(res-1);\n\tif (!sz(ans)) ans.eb(0,0);\n\tF0R(i,res) {\n\t\tpi p = ans[i%sz(ans)];\n\t\tps(p.f,p.s);\n\t}\n\t// ps(\"HUH\"); exit(0);\n\t// you should actually read the stuff at the bottom\n}\n \n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n "
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class t> inline t read(t &x){\n\tchar c=getchar();bool f=0;x=0;\n\twhile(!isdigit(c)) f|=c=='-',c=getchar();\n\twhile(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\tif(f) x=-x;return x;\n}\ntemplate<class t,class ...A> inline void read(t &x,A &...a){\n\tread(x);read(a...);\n}\ntemplate<class t> inline void write(t x){\n\tif(x<0) putchar('-'),write(-x);\n\telse{if(x>9) write(x/10);putchar('0'+x%10);}\n}\n\n#define pii pair<int,int>\n#define x first\n#define y second\n\nconst int N=405;\nint n,a[N];\nchar s[N];\nvector<pii> ans;\n\nstring rev(string s){\n\treverse(s.begin(),s.end());\n\tfor(char &c:s){\n\t\tif(c>='a') c-='a'-'A';\n\t\telse c+='a'-'A';\n\t}\n\treturn s;\n}\n\nsigned main(){\n\tread(n);\n\tfor(int i=0;i<(1<<n);i++) scanf(\"%1d\",&a[i]);\n\tif(!a[0]) return puts(\"Impossible\"),0;\n\tfor(int i=0;i<(1<<n);i++) if(a[i])\n\t\tfor(int j=(i-1)&i;j;j=(j-1)&i) if(!a[j])\n\t\t\treturn puts(\"Impossible\"),0;\n\tans.emplace_back(0,0);\n\tfor(int i=0;i<(1<<n);i++) if(!a[i]){\n\t\tbool flag=0;\n\t\tfor(int j=(i-1)&i;j;j=(j-1)&i) if(!a[j]){\n\t\t\tflag=1;\n\t\t\tbreak;\n\t\t}\n\t\tif(flag) continue;\n\t\tstring s;\n\t\tfor(int j=0;j<n;j++) if(i>>j&1){\n\t\t\tif(s.empty()) s=(char)('a'+j);\n\t\t\telse s=(char)('a'+j)+s+(char)('A'+j)+rev(s);\n\t\t}\n\t\tint pos=0;\n\t\tfor(char c:s){\n\t\t\tint x=0,d=0;\n\t\t\tif(c>='a') x=c-'a',d=1;\n\t\t\telse x=c-'A',d=0;\n\t\t\twhile(pos<x) ans.emplace_back(++pos,0);\n\t\t\twhile(pos>x) ans.emplace_back(--pos,0);\n\t\t\tif(d){\n\t\t\t\tans.emplace_back(x,1);\n\t\t\t\tans.emplace_back(x+1,1);\n\t\t\t\tans.emplace_back(x+1,0);\n\t\t\t\tans.emplace_back(x,0);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans.emplace_back(x+1,0);\n\t\t\t\tans.emplace_back(x+1,1);\n\t\t\t\tans.emplace_back(x,1);\n\t\t\t\tans.emplace_back(x,0);\n\t\t\t}\n\t\t}\n\t\twhile(pos) ans.emplace_back(--pos,0);\n\t}\n\tputs(\"Possible\");\n\twrite(ans.size()-1);puts(\"\");\n\tfor(auto x:ans) write(x.x),putchar(' '),write(x.y),puts(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nint n;\nchar s[1010];\nvector<PII> ans,c;\nvector<PII> build(VI w) {\n  if (SZ(w)==1) return vector<PII>{{w[0],0}};\n  vector<PII> z{{w[0],0},{w[1],0},{w[0],1},{w[1],1}};\n  rep(i,2,SZ(w)) {\n    vector<PII> nz=z; \n    z.pb({w[i],0});\n    reverse(all(nz));\n    for (auto p:nz) z.pb({p.fi,p.se^1});\n    z.pb({w[i],-1});\n  }\n  return z;\n}\nint zz;\nint main() {\n  scanf(\"%d\",&n);\n  scanf(\"%s\",s);\n  rep(i,0,(1<<n)) if (s[i]=='0') {\n    rep(j,0,(1<<n)) if ((j&i)==i&&s[j]=='1') {\n      puts(\"Impossible\");\n      return 0;\n    }\n    bool cc=0;\n    rep(j,0,(1<<n)) if ((i&j)==j&&i!=j&&s[j]=='0') cc=1;\n    if (cc) continue;\n    VI w;\n    rep(j,0,n) if (i&(1<<j)) w.pb(j);\n    auto x=build(w);\n    for (auto p:x) ans.pb(p);\n    zz++;\n    rep(i,0,n) ans.pb(mp(i,0));\n  }\n  rep(i,0,zz) per(j,0,n) ans.pb(mp(j,-1));\n  puts(\"Possible\");\n  int pos=0;\n  c.pb(mp(0,0));\n  for (auto p:ans) {\n    //printf(\"pp %d %d\\n\",p.fi,p.se);\n    if (p.se==0) {\n      while (pos<p.fi) {\n        pos+=1;\n        c.pb(mp(pos,0));\n      }\n      while (pos>p.fi) {\n        pos-=1;\n        c.pb(mp(pos,0));\n      }\n      c.pb(mp(pos,1));\n      c.pb(mp(pos+1,1));\n      c.pb(mp(pos+1,0));\n      pos+=1;\n    } else {\n      while (pos<p.fi+1) {\n        pos+=1;\n        c.pb(mp(pos,0));\n      }\n      while (pos>p.fi+1) {\n        pos-=1;\n        c.pb(mp(pos,0));\n      }\n      c.pb(mp(pos,1));\n      c.pb(mp(pos-1,1));\n      c.pb(mp(pos-1,0));\n      pos-=1;\n    }\n  }\n  while (pos>0) {\n    pos--;\n    c.pb(mp(pos,0));\n  }\n  printf(\"%d\\n\",SZ(c)-1);\n  for (auto x:c) printf(\"%d %d\\n\",x.fi,x.se);\n}"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &x) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (x = 0; c >= 33 && c <= 126; s[++x] = c, c = gc());\n\t\ts[x+1] = '\\0';\n\t}\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(string s) {\n\t\tint x = s.length();\n\t\twhile (t < x) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printc;\nusing io::prints;\n\n#define Fail prints(\"Impossible\"), exit(0)\n#define vp vector<pi>\nint n, f[1<<8|1];\nstring s;\nvp p[1<<8|1], ans(1, mp(0, 0));\n\ninline bool pd(int i) {\n\tfor (int j = (i - 1) & i; j; j = (j - 1) & i)\n\t\tif (s[j] == '0') return 0;\n\treturn 1;\n}\n\ninline void merge(vp &a, vp b) {\n\tfor (pi o : b) a.pb(o);\n}\n\ninline vp prime(vp a) {\n\tfor (pi &o : a) o.se ^= 1;\n\treturn a;\n}\n\ninline vp work(int i) {\n\tif (p[i].size()) return p[i];\n\tint j = i & -i, k = f[j];\n\tp[i].pb(mp(k, 1));\n\tp[i].pb(mp(k + 1, 1));\n\tvp t = work(i - j);\n\tmerge(p[i], t);\n\tp[i].pb(mp(k + 1, 1));\n\tp[i].pb(mp(k, 1));\n\tp[i].pb(mp(k, 0));\n\tp[i].pb(mp(k + 1, 0));\n\tmerge(p[i], prime(t));\n\tp[i].pb(mp(k + 1, 0));\n\tp[i].pb(mp(k, 0));\n\tp[i].pb(mp(k, 1));\n\treturn p[i];\n}\n\ninline vp get(pi a, pi b) {\n\tvp ret(1, a);\n\tif (a.se != b.se) return ret.pb(b), ret;\n\twhile (a != b)\n\t\ta.fi += a.fi < b.fi ? 1 : -1, ret.pb(a);\n\treturn ret;\n}\n\ninline vp update(vp a) {\n\tif (a.size() == 1u) return a;\n\tvp b;\n\tfor (ui i = 1; i < a.size(); i++) merge(b, get(a[i-1], a[i]));\n\treturn b;\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\tcin >> n >> s;\n\tif (s[0] == '0') Fail;\n\tfor (int i = 0; i < (1 << n); i++)\n\t\tif (s[i] == '1')\n\t\t\tfor (int j = i; j; j = (j - 1) & i)\n\t\t\t\tif (s[j] == '0') Fail;\n\tfor (int i = 0; i < n; i++) {\n\t\tf[1<<i] = i;\n\t\tp[1<<i].pb(mp(i, 1));\n\t\tp[1<<i].pb(mp(i + 1, 1));\n\t\tp[1<<i].pb(mp(i + 1, 0));\n\t\tp[1<<i].pb(mp(i, 0));\n\t\tp[1<<i].pb(mp(i, 1));\n\t}\n\tfor (int i = 0; i < (1 << n); i++)\n\t\tif (s[i] == '0' && pd(i))\n\t\t\tans.pb(mp(0, 1)), merge(ans, work(i)),\n\t\t\tans.pb(mp(0, 1)), ans.pb(mp(0, 0));\n//\tdbg(ans.size() - 1);\n//\tfor (pi o : ans) debug(\"%d %d\\n\", o.fi, o.se);\n\tans = update(ans);\n\tans.erase(unique(ans.begin(), ans.end()), ans.end());\n\tprints(\"Possible\");\n\tprint(ans.size() - 1);\n\tfor (pi o : ans) print(o.fi, o.se);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint f[1 << 8];\n\nint main() {\n\tcin >> n;\n\tstring s;\n\tcin >> s;\n\tfor(int S = 0; S < (1 << n); ++S) f[S] = s[S] - '0';\n\tint M = 0;\n\tfor(int i = 0; i < n; ++i) if(f[1 << i]) M |= (1 << i);\n\tfor(int S = 0; S < (1 << n); ++S) {\n\t\tif(f[S] != ((S & M) == S)) {\n\t\t\tcout << \"Impossible\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tvector< pair<int, int> > vp;\n\tcout << \"Possible\" << endl;\n\tvp.emplace_back(0, 0);\n\tfor(int i = 0; i < n; ++i) if(M >> i & 1) {\n\t\tvp.emplace_back(i + 1, 0);\n\t} else {\n\t\tvp.emplace_back(i, 1);\n\t\tvp.emplace_back(i + 1, 1);\n\t\tvp.emplace_back(i + 1, 0);\n\t}\n\tfor(int i = n - 1; i >= 0; --i) vp.emplace_back(i, 0);\n\tcout << (vp.size() - 1) << endl;\n\tfor(auto p : vp) cout << p.first << \" \" << p.second << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &x) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (x = 0; c >= 33 && c <= 126; s[++x] = c, c = gc());\n\t\ts[x+1] = '\\0';\n\t}\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(string s) {\n\t\tint x = s.length();\n\t\twhile (t < x) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printc;\nusing io::prints;\n\n#define Fail prints(\"Impossible\"), exit(0)\n#define vp vector<pi>\nint n, f[1<<8|1];\nstring s;\nvp p[1<<8|1], ans(1, mp(0, 0));\n\ninline bool pd(int i) {\n\tfor (int j = (i - 1) & i; j; j = (j - 1) & i)\n\t\tif (s[j] == '0') return 0;\n\treturn 1;\n}\n\ninline void merge(vp &a, vp b) {\n\tfor (pi o : b) a.pb(o);\n}\n\ninline vp prime(vp a) {\n\tfor (pi &o : a) o.se ^= 1;\n\treturn a;\n}\n\ninline vp work(int i) {\n\tif (p[i].size()) return p[i];\n\tint j = i & -i;\n\tp[i].pb(mp(j, 1));\n\tp[i].pb(mp(j + 1, 1));\n\tvp t = work(i - j);\n\tmerge(p[i], t);\n\tp[i].pb(mp(j + 1, 1));\n\tp[i].pb(mp(j, 1));\n\tp[i].pb(mp(j, 0));\n\tp[i].pb(mp(j + 1, 0));\n\tmerge(p[i], prime(t));\n\tp[i].pb(mp(j + 1, 0));\n\tp[i].pb(mp(j, 0));\n\tp[i].pb(mp(j, 1));\n\treturn p[i];\n}\n\ninline vp get(pi a, pi b) {\n\tvp ret(1, a);\n\tif (a.se != b.se) return ret.pb(b), ret;\n\twhile (a != b)\n\t\ta.fi += a.fi < b.fi ? 1 : -1, ret.pb(a);\n\treturn ret;\n}\n\ninline vp update(vp a) {\n\tvp b;\n\tfor (ui i = 1; i < a.size(); i++) merge(b, get(a[i-1], a[i]));\n\treturn b;\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\tcin >> n >> s;\n\tif (s[0] == '0') Fail;\n\tfor (int i = 0; i < (1 << n); i++)\n\t\tif (s[i] == '1')\n\t\t\tfor (int j = i; j; j = (j - 1) & i)\n\t\t\t\tif (s[j] == '0') Fail;\n\tfor (int i = 0; i < n; i++) {\n\t\tf[1<<i] = i;\n\t\tp[1<<i].pb(mp(i, 1));\n\t\tp[1<<i].pb(mp(i + 1, 1));\n\t\tp[1<<i].pb(mp(i + 1, 0));\n\t\tp[1<<i].pb(mp(i, 0));\n\t\tp[1<<i].pb(mp(i, 1));\n\t}\n\tfor (int i = 0; i < (1 << n); i++)\n\t\tif (s[i] == '0' && pd(i))\n\t\t\tans.pb(mp(0, 1)), merge(ans, work(i)),\n\t\t\tans.pb(mp(0, 1)), ans.pb(mp(0, 0));\n//\tdbg(ans.size() - 1);\n//\tfor (pi o : ans) debug(\"%d %d\\n\", o.fi, o.se);\n\tans = update(ans);\n\tans.erase(unique(ans.begin(), ans.end()), ans.end());\n\tprints(\"Possible\");\n\tprint(ans.size() - 1);\n\tfor (pi o : ans) print(o.fi, o.se);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#define NO return !printf(\"Impossible\\n\")\n#define N 433\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint n,a[N];\nchar s[N];\nvector<pair<int,int> > ans;\nstring Rev(string s){\n\treverse(s.begin(),s.end());\n\tfor(auto c:s){\n\t\tif(c>='a'&&c<='z')c+='A'-'a';\n\t\telse c+='a'-'A';\n\t}\n\treturn s;\n}\nint main(){\n\tn=read();\n\tscanf(\"%s\",s);\n\tfor(int i=0;i<(1<<n);++i){\n\t\ta[i]=s[i]-'0';\n\t}\n\tif(!a[0])NO;\n\tfor(int i=0;i<(1<<n);++i){\n\t\tif(a[i]){\n\t\t\tfor(int j=(i-1)&i;j;j=(j-1)&i){\n\t\t\t\tif(!a[j])NO;\n\t\t\t}\n\t\t}\n\t}\n\tans.emplace_back(0,0);\n\tfor(int i=0;i<(1<<n);++i){\n\t\tif(a[i])continue;\n\t\tbool ok=true;\n\t\tfor(int j=(i-1)&i;j;j=(j-1)&i){\n\t\t\tif(a[j]){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok)continue;\n\t\tstring myh;\n\t\tfor(int j=0;j<n;++j){\n\t\t\tif((i>>j)&1){\n\t\t\t\tif(myh.empty())myh=(char)('a'+j);\n\t\t\t\telse myh=(char)('a'+j)+myh+(char)('A'+j)+Rev(myh);\n\t\t\t}\n\t\t}\n\t\tint pos=0;\n\t\tfor(auto c:myh){\n\t\t\tint d=0,x=0;\n\t\t\tif(c>='a'&&c<='z'){\n\t\t\t\tx=c-'a',d=1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tx=c-'A',d=0;\n\t\t\t}\n\t\t\twhile(pos<x)ans.emplace_back(++pos,0);\n\t\t\twhile(pos>x)ans.emplace_back(--pos,0);\n\t\t\tif(d){\n\t\t\t\tans.emplace_back(x,1);\n\t\t\t\tans.emplace_back(x+1,1);\n\t\t\t\tans.emplace_back(x+1,0);\n\t\t\t\tans.emplace_back(x,0);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans.emplace_back(x+1,0);\n\t\t\t\tans.emplace_back(x+1,1);\n\t\t\t\tans.emplace_back(x,1);\n\t\t\t\tans.emplace_back(x,0);\n\t\t\t}\n\t\t}\n\t\twhile(pos>0)ans.emplace_back(--pos,0);\n\t}\n\tprintf(\"Possible\\n%d\\n\",(int)ans.size()-1);\n\tfor(auto x:ans){\n\t\tprintf(\"%d %d\\n\",x.first,x.second);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T>\nvector<T>& operator += (vector<T>& a, vector<T> b) {\n\tfor (auto x : b) {\n\t\ta.push_back(x);\n\t}\n\treturn a;\n}\ntemplate <typename T>\nvector<T> operator ~ (vector<T> a) {\n  reverse(a.begin(), a.end());\n  return a;\n}\n\ntypedef class Point {\n  public:\n    int x, y;\n\n    Point() { }\n    Point(int x, int y) : x(x), y(y) {  }\n\n    bool operator == (Point b) {\n      return x == b.x && y == b.y;\n    }\n} Point;\n\ntypedef class Data {\n  public:\n    char dir;\n    int num;\n\n    Data() {  }\n    Data(char dir, int num) : dir(dir), num(num) {  }\n} Data;\n\nint n, N;\n\nvector<Point> _export(vector<Data> vd) {\n  vector<Point> ret {Point(n, 1)};\n  for (auto t : vd) {\n    auto lst = ret.back();\n    if (t.dir == 'd' && lst.y == 1) {\n      ret.emplace_back(lst.x, 0);\n    } else if (t.dir == 'u' && lst.y == 0) {\n      ret.emplace_back(lst.x, 1);\n    }\n    lst = ret.back();\n    if (lst.x == t.num) {\n      lst.x--;\n    } else if (lst.x == t.num - 1) {\n      lst.x++;\n    } else {\n      assert(false);\n    }\n    ret.push_back(lst);\n  }\n  if (ret[0] == ret.back()) {\n    ret.pop_back();\n  }\n  return ret;\n}\nvector<Point> _export(vector<Data> vd, vector<int> pos) {\n  for (auto& t : vd) {\n    t.num = pos[t.num - 1] + 1;\n  }\n  vector<Data> nvd;\n  for (int i = n; i > vd[0].num; i--) {\n      nvd.emplace_back('d', i);\n  }\n  for (auto t : vd) {\n    if (!nvd.empty()) {\n      auto& lst = nvd.back();\n      for (int i = lst.num + 1; i < t.num; i++) {\n        nvd.emplace_back('d', i);\n      }\n      for (int i = lst.num - 1; i > t.num; i--) {\n        nvd.emplace_back('d', i);\n      }\n    }\n    nvd.push_back(t);\n  }\n  for (int i = nvd.back().num + 1; i <= n; i++) {\n    nvd.emplace_back('d', i);\n  }\n  return _export(nvd);\n}\n\nchar A[530];\nvector<Data> df[10];\n\n#define NO do puts(\"Impossible\"), exit(0); while (0)\n\nint main() {\n  scanf(\"%d\", &n);\n  N = 1 << n;\n  scanf(\"%s\", A);\n  if (A[0] != '1') {\n    NO;\n  }\n\tfor (int s = 0; s < N; s++) {\n    if (A[s] == '1') {\n      for (int i = 0; i < n; i++) {\n        if (((s >> i) & 1) && A[s ^ (1 << i)] == '0') {\n          NO;\n        }\n      }\n    }\n  }\n  df[1].emplace_back('d', 1);\n  df[1].emplace_back('u', 1);\n  for (int i = 2; i <= n; i++) {\n    df[i].emplace_back('u', i);\n    df[i] += df[i - 1];\n    df[i].emplace_back('u', i);\n    df[i].emplace_back('d', i);\n    df[i] += ~df[i - 1];\n    df[i].emplace_back('d', i);\n  }\n  vector<Point> ans;\n  for (int s = 1; s < N; s++) {\n    if (A[s] == '0') {\n      vector<int> pos;\n      int bit = 0;\n      for (int i = 0; i < n; i++) {\n        if ((s >> i) & 1) {\n          pos.push_back(i);\n          bit++;\n        }\n      }\n      ans += _export(df[bit], pos);\n    }\n  }\n  puts(\"Possible\");\n  printf(\"%d\\n\", (signed) ans.size());\n  if (ans.empty()) {\n    ans.emplace_back(0, 0);\n  } else {\n    ans.push_back(ans[0]);\n  }\n  for (auto p : ans) {\n    printf(\"%d %d\\n\", p.x, p.y);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i = (begin); i < (end); i++)\n#define rep(i, n) FOR(i, 0, n)\nusing ll = long long;\nusing namespace std;\n#define all(x) (x).begin(),(x).end()\nusing pii = pair<int, int>; using vi = vector<int>; using vl = vector<ll>;\n\nint N;\n\nsigned main() {\n    cin >> N;\n    // unordered_set<int> oo, ii;\n    int oo(0), ii(0);\n    vi sss;\n    string as;\n    cin >> as;\n    bool first = true;\n    for(int i = N-1; i>=0; i--) {\n        // auto ss = setter(i);\n        if (as[i] == '1') {\n            if(first) {\n                oo = i;\n                first = false;\n            } else if((oo | i) != oo) {\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n            // ii = Union(ii, ss);\n        } else {\n            // sss.push_back(i);\n            // oo = Union(oo, ss);\n        }\n    }\n    // for(auto s : sss) {\n    //     if((oo&s) == s) {\n    //         cout << \"Impossible\" << endl;\n    //         return 0;\n    //     }\n    // }\n    \n    // if (Product(oo, ii).size() != 0) {\n    // if ((oo&ii) != 0) {\n    //     cout << \"Impossible\" << endl;\n    //     return 0;\n    // }\n    cout << \"Possible\" << endl;\n\n    ii = (1<<N) - oo - 1;\n    // cerr << oo << ' ' << ii << endl;\n    // cerr << (oo & ii) << endl;\n    vector<pii> p;\n    int before = 0;\n    // cerr << ii << endl;\n    p.push_back({0, 0});\n    rep(i, N) {\n        // cerr << ii << endl;\n        // cerr << ((ii&1) ^ before) << endl;\n        if((ii&1) ^ before) {\n            if(ii&1) {\n                if(i!=0) {\n                    p.push_back({i, 0});\n                }\n                p.push_back({i, 1});\n            } else {\n                p.push_back({i, 1});\n                if(i!=N-1)\n                    p.push_back({i, 0});\n            }\n        } else {\n            if(i!=0)\n                p.push_back({i, before});\n        }\n        before = ii & 1;\n        ii >>= 1;\n    }\n    if (before)\n        p.push_back({N, 1});\n    for(int k = N; k>=0; k--) {\n        p.push_back({k, 0});\n    }\n\n    cout << p.size() - 1 << endl;\n    for(auto pp : p) {\n        cout << pp.first << ' ' << pp.second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i = (begin); i < (end); i++)\n#define rep(i, n) FOR(i, 0, n)\nusing ll = long long;\nusing namespace std;\n#define all(x) (x).begin(),(x).end()\nusing pii = pair<int, int>; using vi = vector<int>; using vl = vector<ll>;\n\nint N;\n\nunordered_set<int> setter(int i) {\n    unordered_set<int> ss;\n    rep(j, N) {\n        int k = i & 1;\n        if (k == 0)\n            ss.insert(j);\n        i >> 1;\n    }\n    return ss;\n}\n// 和集合の計算\ntemplate<class T> unordered_set<T> Union(unordered_set<T>& rsettA, unordered_set<T>&rsettB) {\n    unordered_set<T> settUnion(rsettA);\n    for (auto itt = rsettB.begin(); itt != rsettB.end(); itt++) {\n        settUnion.insert(*itt);\n    }\n    return settUnion;\n}\n// 積集合の計算\ntemplate<class T> unordered_set<T> Product(unordered_set<T>& rsettA, unordered_set<T>&rsettB) {\n    unordered_set<T> settProduct;\n    for (auto itt = rsettB.begin(); itt != rsettB.end(); itt++) {\n        if (rsettA.find(*itt) != rsettA.end()) {\n            settProduct.insert(*itt);\n        }\n    }\n    return settProduct;\n}\n// 補集合の計算\ntemplate<class T> unordered_set<T> Complement(unordered_set<T>& rsettA, unordered_set<T>&rsettB) {\n    unordered_set<T> settComplement(rsettA);\n    for (auto itt = rsettB.begin(); itt != rsettB.end(); itt++) {\n        settComplement.erase(*itt);\n    }\n    return settComplement;\n}\nsigned main() {\n    cin >> N;\n    // unordered_set<int> oo, ii;\n    int oo(0), ii(0);\n    string as;\n    cin >> as;\n    rep(i, 1<<N) {\n        int x = as[i] - '0';\n        // auto ss = setter(i);\n        if (x == 1) {\n            oo |= i;\n            // ii = Union(ii, ss);\n        } else {\n            ii |= i;\n            // oo = Union(oo, ss);\n        }\n    }\n    // if (Product(oo, ii).size() != 0) {\n    if (oo&ii != 0) {\n        cout << \"Impossible\" << endl;\n        return 0;\n    }\n    cout << \"Possible\" << endl;\n\n    vector<pii> p;\n    int before = 0;\n    // cerr << ii << endl;\n    p.push_back({0, 0});\n    rep(i, N) {\n        if(ii&1 ^ before) {\n            if(ii&1) {\n                if(i!=0) {\n                    p.push_back({i, 0});\n                }\n                p.push_back({i, 1});\n            } else {\n                p.push_back({i, 1});\n                if(i!=N-1)\n                    p.push_back({i, 0});\n            }\n        }\n        before = ii & 1;\n        ii >> 1;\n    }\n    if (before)\n        p.push_back({N, 1});\n    p.push_back({N, 0});\n    p.push_back({0, 0});\n\n    cout << p.size() - 1 << endl;\n    for(auto pp : p) {\n        cout << pp.first << ' ' << pp.second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<unordered_map>\n#include<complex>\nusing namespace std;\nconst long long mod=998244353;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3100000;\nconst int UF_SIZE = 3100000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint UF[UF_SIZE];\n\tvoid init_UF(int n){\n\t\tfor(int i=0;i<n;i++)UF[i]=-1;\n\t}\n\tint FIND(int a){\n\t\tif(UF[a]<0)return a;\n\t\treturn UF[a]=FIND(UF[a]);\n\t}\n\tvoid UNION(int a,int b){\n\t\ta=FIND(a);b=FIND(b);if(a==b)return;\n\t\tif(UF[a]>UF[b])swap(a,b);\n\t\tUF[a]+=UF[b];UF[b]=a;\n\t}\n}\n// ここから編集しろ\nchar in[310];\nint dp[310];\nint n;\nvector<pair<int,int> >v;\nvector<pair<int,int> >cm;\nvector<pair<int,int> > ad(vector<int>a){\n\tvector<pair<int,int> > ret;\n\tif(a.size()==1){\n\t\tret.push_back(make_pair(a[0],1));\n\t\tret.push_back(make_pair(a[0],0));\n\t\treturn ret;\n\t}\n\tret.push_back(make_pair(a[0],1));\n\tvector<int>b;\n\tfor(int i=1;i<a.size();i++)\n\t\tb.push_back(a[i]);\n\tvector<pair<int,int> >S=ad(b);\n\tfor(int i=0;i<S.size();i++){\n\t\tret.push_back(S[i]);\n\t}\n\tret.push_back(make_pair(a[0],1));\n\tret.push_back(make_pair(a[0],0));\n\treverse(S.begin(),S.end());\n\tfor(int i=0;i<S.size();i++){\n\t\tret.push_back(S[i]);\n\t}\n\tret.push_back(make_pair(a[0],0));\n\treturn ret;\n}\nvoid f(int a){\n\tif(dp[a])return;\n\tif(a==0)return;\n\tdp[a]=1;\n\tbool ok=true;\n\tfor(int i=0;i<n;i++){\n\t\tif(!(a&(1<<i)))continue;\n\t\tif(in[a-(1<<i)]=='0'){\n\t\t\tok=false;\n\t\t\tf(a-(1<<i));\n\t\t}\n\t}\n\tif(ok){\n\t\tvector<int>q;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(a&(1<<i))q.push_back(i);\n\t\t}\n\t\tvector<pair<int,int> >tmp=ad(q);\n\t\tfor(int i=0;i<tmp.size();i++){\n\t\t\tcm.push_back(tmp[i]);\n\t\t}\n\t}\n}\nint main_(){\n\t// int a=4;\n\t// n=a;\n\tint a;scanf(\"%d\",&a);\n\tn=a;\n\tscanf(\"%s\",in);\n\tv.clear();\n\tcm.clear();\n\tfor(int i=0;i<310;i++)dp[i]=0;\n\tfor(int i=0;i<(1<<a);i++){\n\t\tif(in[i]=='1'){\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(i&(1<<j)){\n\t\t\t\t\tif(in[i-(1<<j)]=='0'){\n\t\t\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"Possible\\n\");\n\tif(in[(1<<a)-1]=='1'){\n\t\tprintf(\"0\\n\");\n\t\tprintf(\"0 0\\n\");\n\t\treturn 0;\n\t}\n\tf((1<<a)-1);\n\tint now=0;\n\tv.push_back(make_pair(0,0));\n\tfor(int i=0;i<cm.size();i++){\n\t\tif(now<=cm[i].first){\n\t\t\twhile(now<cm[i].first){\n\t\t\t\tnow++;\n\t\t\t\tv.push_back(make_pair(now,0));\n\t\t\t}\n\t\t\tif(cm[i].second){\n\t\t\t\tv.push_back(make_pair(now,1));\n\t\t\t\tv.push_back(make_pair(now+1,1));\n\t\t\t}\n\t\t\tv.push_back(make_pair(now+1,0));\n\t\t\tnow++;\n\t\t}else{\n\t\t\twhile(now>1+cm[i].first){\n\t\t\t\tnow--;\n\t\t\t\tv.push_back(make_pair(now,0));\n\t\t\t}\n\t\t\tif(cm[i].second){\n\t\t\t\tv.push_back(make_pair(now,1));\n\t\t\t\tv.push_back(make_pair(now-1,1));\n\t\t\t}\n\t\t\tv.push_back(make_pair(now-1,0));\n\t\t\tnow--;\n\t\t}\n\t}\n\twhile(now>0){\n\t\tnow--;\n\t\tv.push_back(make_pair(now,0));\n\t}\n\tif(v.size()>=250000)while(1);\n\tprintf(\"%d\\n\",(int)(v.size())-1);\n\tfor(int i=0;i<v.size();i++){\n\t\tprintf(\"%d %d\\n\",v[i].first,v[i].second);\n\t}\n\tfor(int i=0;i+1<v.size();i++){\n\t\tassert(ABS(v[i].first-v[i+1].first)+ABS(v[i].second-v[i+1].second)==1);\n\t}\n\tfor(int i=0;i<(1<<a);i++){\n\t\tstack<pair<int,int> > S;\n\t\tfor(int j=0;j+1<v.size();j++){\n\t\t\tif(v[j].first==v[j+1].first)continue;\n\t\t\tint x=min(v[j].first,v[j+1].first);\n\t\t\tint y=v[j].second;\n\t\t\tif(S.size()&&S.top()==make_pair(x,y)){\n\t\t\t\tS.pop();\n\t\t\t}else S.push(make_pair(x,y));\n\t\t}\n\t\tif(S.size()==0&&in[i]=='0'){\n\t\t\texit(1);\n\t\t}else if(S.size()&&in[i]=='1'){\n\t\t\texit(1);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tmain_();\n\t// for(int i=1;i<65536;i++){\n\t// \tfor(int j=0;j<16;j++){\n\t// \t\tif(i&(1<<j))in[j]='1';\n\t// \t\telse in[j]='0';\n\t// \t}\n\t// \t// printf(\"%d:\\n\",i);\n\t// \tmain_();\n\t// }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid f(stringstream &ss, int r, int &j, int &l) {\n    int s = abs(r);\n    while(s < j)\n        ss << --j << \" 0\\n\", l++;\n    while(s > j)\n        ss << ++j << \" 0\\n\", l++;\n    if(r < 0)\n        ss << s << \" 1\\n\"\n           << s - 1 << \" 1\\n\"\n           << s - 1 << \" 0\\n\",\n            j = s - 1, l += 3;\n    else\n        ss << s << \" 1\\n\"\n           << s + 1 << \" 1\\n\"\n           << s + 1 << \" 0\\n\",\n            j = s + 1, l += 3;\n}\nvector<int> g(int k) {\n    int i = 0;\n    while(!(k & 1 << i))\n        i++;\n    vector<int> v;\n    v.push_back(i);\n    if(k == 1 << i)\n        return v;\n    auto w = g(k ^ 1 << i);\n    v.insert(v.end(), w.begin(), w.end());\n    v.push_back(-1 - i);\n    for(int &l : w)\n        l = -1 - l;\n    reverse(w.begin(), w.end());\n    v.insert(v.end(), w.begin(), w.end());\n    return v;\n}\nint main() {\n    int n;\n    string a;\n    cin >> n >> a;\n    vector<int> b;\n    for(int i = 0; i < 1 << n; i++) {\n        int x = 0;\n        for(int &k : b) {\n            if((k & i) == k) {\n                if(a[i] == '1') {\n                    cout << \"Impossible\" << endl;\n                    return 0;\n                }\n                x = 1;\n            }\n        }\n        if(a[i] == '0' && !x)\n            b.push_back(i);\n    }\n    cout << \"Possible\\n\";\n    stringstream ss;\n    int l = 0, j = 0;\n    ss << \"0 0\\n\";\n    for(int k : b) {\n        auto v = g(k);\n        for(int i : v)\n            f(ss, i, j, l);\n    }\n    if(j)\n        for(j--; j >= 0; j--)\n            ss << j << \" 0\\n\", l++;\n    cout << l << '\\n' << ss.str() << flush;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nint n;\nchar s[1010];\nvector<PII> ans,c,trash;\nvector<PII> build(VI w) {\n  if (SZ(w)==1) return vector<PII>{{w[0],0}};\n  vector<PII> z{{w[0],0},{w[1],0},{w[0],1},{w[1],1}};\n  rep(i,2,SZ(w)) {\n    vector<PII> nz=z; \n    z.pb({w[i],0});\n    reverse(all(nz));\n    for (auto p:nz) z.pb({p.fi,p.se^1});\n    z.pb({w[i],-1});\n  }\n  return z;\n}\nint zz;\nint main() {\n  scanf(\"%d\",&n);\n  scanf(\"%s\",s);\n  //rep(i,0,(1<<n)) s[i]=(__builtin_popcount(i)<5)+'0';\n  rep(i,0,(1<<n)) if (s[i]=='0') {\n    rep(j,0,(1<<n)) if ((j&i)==i&&s[j]=='1') {\n      puts(\"Impossible\");\n      return 0;\n    }\n    bool cc=0;\n    rep(j,0,(1<<n)) if ((i&j)==j&&i!=j&&s[j]=='0') cc=1;\n    if (cc) continue;\n    VI w;\n    rep(j,0,n) if (i&(1<<j)) w.pb(j);\n    auto x=build(w);\n    for (auto p:x) ans.pb(p);\n    zz++;\n    //rep(i,0,n) ans.pb(mp(i,0)),trash.pb(mp(i,0));\n    rep(i,0,100) {\n      int x=rnd(n);\n      ans.pb(mp(x,(SZ(w)>=2))),trash.pb(mp(x,(SZ(w)>=2)));\n    }\n  }\n  //fprintf(stderr,\"%d\\n\",zz);\n  reverse(all(trash));\n  for (auto p:trash) ans.pb(mp(p.fi,p.se^1));\n // rep(i,0,zz) per(j,0,n) ans.pb(mp(j,-1));\n  puts(\"Possible\");\n  int pos=0;\n  c.pb(mp(0,0));\n  for (auto p:ans) {\n    //printf(\"pp %d %d\\n\",p.fi,p.se);\n    if (p.se==0) {\n      while (pos<p.fi) {\n        pos+=1;\n        c.pb(mp(pos,0));\n      }\n      while (pos>p.fi) {\n        pos-=1;\n        c.pb(mp(pos,0));\n      }\n      c.pb(mp(pos,1));\n      c.pb(mp(pos+1,1));\n      c.pb(mp(pos+1,0));\n      pos+=1;\n    } else {\n      while (pos<p.fi+1) {\n        pos+=1;\n        c.pb(mp(pos,0));\n      }\n      while (pos>p.fi+1) {\n        pos-=1;\n        c.pb(mp(pos,0));\n      }\n      c.pb(mp(pos,1));\n      c.pb(mp(pos-1,1));\n      c.pb(mp(pos-1,0));\n      pos-=1;\n    }\n  }\n  while (pos>0) {\n    pos--;\n    c.pb(mp(pos,0));\n  }\n  assert(SZ(c)<=250000);\n  printf(\"%d\\n\",SZ(c)-1);\n  for (auto x:c) printf(\"%d %d\\n\",x.fi,x.se);\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\ndate +%Y.%m.%d\n\n题解先咕着。\n#endif\n#include <cstdio>\n#include <algorithm>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\n\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n} read;\n\nchar s[1 << 10];\nstruct Dot { int x, y; } ans[1000000];\n\nint main () {\n\tint n = read;\n\tscanf(\"%s\", s);\n\n\tfor (int S = 0; S < (1 << n); S ++) {\n\t\tint now = 1;\n\t\tfor (int i = 0; i < n; i ++)\n\t\t\tif (S >> i & 1)\n\t\t\t\tnow &= s[1 << i] == '1';\n\t\tif (now != (s[S] == '1'))\n\t\t\treturn puts(\"Impossible\"), 0;\n\t}\n\n\tputs(\"Possible\");\n\tint p = 0;\n\tans[0] = {0, 1};\n\tfor (int i = 0; i < n; i ++)\n\t\tif (s[1 << i] == '1')\n\t\t\tans[++ p] = {i + 1, 1};\n\t\telse {\n\t\t\tans[++ p] = {i, 0};\n\t\t\tans[++ p] = {i + 1, 0};\n\t\t\tans[++ p] = {i + 1, 1};\n\t\t}\n\tfor (int i = n; i; i --)\n\t\tans[++ p] = {i - 1, 1};\n\n\tprintf(\"%d\\n\", p);\n\tfor (int i = 0; i <= p; i ++)\n\t\tprintf(\"%d %d\\n\", ans[i].x, ans[i].y);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n#ifdef ENABLE_DEBUG\n#define dump(a) cerr<<#a<<\"=\"<<a<<endl\n#define dumparr(a,n) cerr<<#a<<\"[\"<<n<<\"]=\"<<a[n]<<endl\n#else\n#define dump(a) \n#define dumparr(a,n) \n#endif\n#define FOR(i, a, b) for(ll i = (ll)a;i < (ll)b;i++)\n#define For(i, a) FOR(i, 0, a)\n#define REV(i, a, b) for(ll i = (ll)b-1LL;i >= (ll)a;i--)\n#define Rev(i, a) REV(i, 0, a)\n#define REP(a) For(i, a)\n#define SIGN(a) (a==0?0:(a>0?1:-1))\n\ntypedef long long int ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll,pll> ppll;\ntypedef vector<ll> vll;\ntypedef long double ld;\ntypedef pair<ld,ld> pdd;\n\nconst ll INF=(1LL<<50);\n#if __cplusplus<201700L\nll gcd(ll a, ll b) {\n  if(a < b) return gcd(b, a);\n  ll r;\n  while ((r=a%b)) {\n    a = b;\n    b = r;\n  }\n  return b;\n}\n#endif\ntemplate<class T>\nbool chmax(T& a,const T& b){\n  if(a<b){\n    a=b;\n    return true;\n  }\n  return false;\n}\ntemplate<class T>\nbool chmin(T& a,const T& b){\n  if(a>b){\n    a=b;\n    return true;\n  }\n  return false;\n}\ntemplate<class S,class T>\nstd::ostream& operator<<(std::ostream& os,pair<S,T> a){\n  os << \"(\" << a.first << \",\" << a.second << \")\";\n  return os;\n}\ntemplate<class T>\nstd::ostream& operator<<(std::ostream& os,vector<T> a){\n  os << \"[ \";\n  REP(a.size()){\n    os<< a[i] << \" \";\n  }\n  os<< \" ]\";\n  return os;\n}\n\nconst string YES = \"Possible\";\nconst string NO = \"Impossible\";\nvoid create1(vector<pll> &ans,ll x){\n  REP(x+1){ans.push_back(pll(1+i,0));}\n  ans.push_back(pll(x+1,1));\n  ans.push_back(pll(x,1));\n  Rev(i,x+1){ans.push_back(pll(i,0));}\n}\nvoid create2(vector<pll> &ans,set<ll> s){\n  ll first=*s.begin();\n  ll end=*prev(s.end());\n  s.erase(first);\n  REP(first){ans.push_back(pll(i+1,0));}\n  ans.push_back(pll(first,1));\n  ans.push_back(pll(first+1,1));\n  ans.push_back(pll(first+1,0));\n  FOR(i,first+2,end+2){ans.push_back(pll(i,0));}\n  s.insert(first);\n  REV(i,first+1,end+2){\n    if(s.count(i)==1&&s.count(i-1)==0){\n      ans.push_back(pll(i,0));\n    }else if(s.count(i)==0&&s.count(i-1)==1){\n      ans.push_back(pll(i,1));\n    }\n    ans.push_back(pll(i-1,ans.back().second));\n  }\n  s.erase(first);\n  FOR(i,first,*s.begin()+1){\n    ans.push_back(pll(i,0));\n  }\n  FOR(i,*s.begin(),end+1){\n    if(s.count(i-1)==0&&s.count(i)){\n      ans.push_back(pll(i,1));\n    }else if(s.count(i-1)==1&&s.count(i)){\n      ans.push_back(pll(i,0));\n    }\n    ans.push_back(pll(i+1,ans.back().second));\n  }\n  REV(i,0,end+2){\n    ans.push_back(pll(i,0));\n  }\n}\nll two_factor(ll x){\n  ll ret=0;\n  while((1<<ret)!=x){\n    ++ret;\n  }\n  return ret;\n}\nint main(){\n  cout<<setprecision(1000);\n  ll N;\n  cin>>N;\n  string A;\n  cin>>A;\n  vector<bool> first(A.size(),true);\n  REP(A.size()){\n    if(first[i]==false)continue;\n    if(A[i]=='0')FOR(j,i+1,A.size()){\n      if(((i&j)==i)&&A[j]=='1'){\n        cout<<NO<<endl;\n        return 0;\n      }else if((i&j)==i){\n        first[j]=false;\n      }\n    }else{\n      first[i]=false;\n    }\n  }\n  dump(first);\n  vector<pll> ans{pll(0,0)};\n  REP(A.size()){\n    if(first[i]){\n      if(__builtin_popcountll(i)==1){\n        create1(ans,two_factor(i));\n      }else{\n        set<ll> s;\n        For(j,N){\n          if((1<<j)&i){\n            s.insert(j);\n          }\n        }\n        create2(ans,move(s));\n      }\n    }\n  }\n  if(ans.size()>250001){\n    abort();\n  }\n  cout<<YES<<endl;\n  cout<<ans.size()-1<<endl;\n  REP(ans.size()){\n    cout<<ans[i].first<<\" \"<<ans[i].second<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define ar array\n\nconst int mxN=8;\nint n;\nstring s;\nvector<int> v;\n\nvector<ar<int, 2>> va(vector<ar<int, 2>> a, vector<ar<int, 2>> b) {\n\tvector<ar<int, 2>> c=a;\n\tc.insert(c.end(), b.begin(), b.end());\n\treturn c;\n}\n\nvector<ar<int, 2>> vo(vector<ar<int, 2>> a, vector<ar<int, 2>> b) {\n\tvector<ar<int, 2>> c=a;\n\treverse(b.begin()+1, b.end());\n\tc.insert(c.end(), b.begin(), b.end());\n\treverse(a.begin()+1, a.end());\n\tc.insert(c.end(), a.begin(), a.end());\n\treverse(b.begin()+1, b.end());\n\tc.insert(c.end(), b.begin(), b.end());\n\treturn c;\n}\n\nvector<ar<int, 2>> dc(int l, int r) {\n\tvector<ar<int, 2>> c;\n\tif(l==r) {\n\t\tint mx=0;\n\t\tfor(int i=0; i<n; ++i)\n\t\t\tif(v[l]>>i&1)\n\t\t\t\tmx=i;\n\t\tfor(int i=0; i<=mx+1; ++i)\n\t\t\tc.push_back({i, 0});\n\t\tfor(int i=mx; ~i; --i) {\n\t\t\tif(v[l]>>i&1) {\n\t\t\t\tc.push_back({i+1, 1});\n\t\t\t\tc.push_back({i, v[l]>>i&1});\n\t\t\t}\n\t\t\tif(i)\n\t\t\t\tc.push_back({i, 0});\n\t\t}\n\t} else {\n\t\tint m=(l+r)/2;\n\t\tc=vo(dc(l, m), dc(m+1, r));\n\t}\n\treturn c;\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin >> n >> s;\n\t/*\n\tcin >> n;\n\ts=string(1<<n, '0');\n\tfor(int i=0; i<1<<n; ++i)\n\t\tif(__builtin_popcount(i)<=n/2)\n\t\t\ts[i]='1';\n\t\t\t*/\n\tfor(int i=0; i<1<<n; ++i) {\n\t\tfor(int j=0; j<1<<n; ++j) {\n\t\t\tif((i&j)==j&&s[i]=='1'&&s[j]=='0') {\n\t\t\t\tcout << \"Impossible\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tbool ok=i&&s[i]=='0';\n\t\tfor(int j=0; j<n&&ok; ++j)\n\t\t\tif(i>>j&1&&s[i^1<<j]=='0')\n\t\t\t\tok=0;\n\t\tif(ok)\n\t\t\tv.push_back(i);\n\t}\n\tcout << \"Possible\\n\";\n\tif(v.empty()) {\n\t\tcout << \"0\\n1 1\";\n\t\treturn 0;\n\t}\n\tvector<ar<int, 2>> ans=dc(0, (int)v.size()-1);\n\tcout << ans.size() << \"\\n\";\n\t//return 0;\n\tassert(ans.size()<=2.5e5);\n\tans.push_back(ans[0]);\n\tfor(ar<int, 2> a : ans)\n\t\tcout << a[0] << \" \" << a[1] << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define eb(x,y) emplace_back(x,y)\n#define fi first\n#define se second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\n//inline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\ninline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}\nint n;char s[1<<10];vector<pint>ans;\ninline string rev(string a){reverse(a.begin(),a.end());}\ninline void Solve(int sta){\n\tint cnt=0;for(int i=0;i<n;i++)cnt+=sta>>i&1;\n\tif(cnt==1){\n\t\tint t=0;for(;t<n;t++)if(sta>>t&1)break;\n\t\tRep(i,1,t)ans.eb(i,0);ans.eb(t,1),ans.eb(t+1,1),ans.eb(t+1,0);\n\t\tRed(i,t,0)ans.eb(i,0);\n\t\treturn;\n\t}\n\tstring S;S.clear();int i=0;\n\tfor(;i<n;i++)if(sta>>i&1)break;S.pb(i+'a'),S.pb(i+'A');\n\tfor(i++;i<n;i++)if(sta>>i&1)S=(char)('a'+i)+S+(char)('a'+i)+(char)('A'+i)+rev(S)+(char)('A'+i);\n\tint now=0;\n\tfor(auto o:S){\n\t\tint opt,p,d;\n\t\tif(isupper(o))opt=1,p=o-'A';else opt=0,p=o-'a';\n\t\tif(now<=p){d=0;Rep(i,now+1,p)ans.eb(i,0);}\n\t\telse{d=1;Red(i,now-1,p+1)ans.eb(i,0);}\n\t\tif(d&&opt)ans.eb(p,0),now=p;\n\t\telse if(d&&!opt)ans.eb(p+1,1),ans.eb(p,1),ans.eb(p,0),now=p;\n\t\telse if(!d&&opt)ans.eb(p+1,0),now=p+1;\n\t\telse if(!d&&!opt)ans.eb(p,1),ans.eb(p+1,1),ans.eb(p+1,0),now=p+1;\n\t}Red(i,now-1,0)ans.eb(i,0);\n}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),scanf(\"%s\",s);\n\tif(s[0]=='0')return puts(\"Impossible\"),0;\n\tfor(int i=0;i<1<<n;i++){\n\t\tif(s[i]=='1'){\n\t\t\tfor(int j=0;j<n;j++)if(i>>j&1)\n\t\t\t\tif(s[i^(1<<j)]=='0')return puts(\"Impossible\"),0;\n\t\t}else{\n\t\t\tfor(int j=0;j<n;j++)if(!(i>>j&1))\n\t\t\t\tif(s[i^(1<<j)]=='1')return puts(\"Impossible\"),0;\n\t\t}\n\t}ans.eb(0,0);\n\tfor(int i=0;i<1<<n;i++)if(s[i]=='0'){\n\t\tbool flg=1;\n\t\tfor(int j=0;j<n;j++)if((i>>j&1)&&s[i^(1<<j)]=='0')flg=0;\n\t\tif(flg)Solve(i);\n\t}puts(\"Possible\");cout<<ans.size()-1<<'\\n';\n\tfor(auto o:ans)cout<<o.fi<<' '<<o.se<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define fr first\n#define sc second\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n\nvector<P> ret;\n\nvoid pos(int i){\n\tfor(int j=0;j<i;j++){\n\t\tret.push_back(P(j+1,0));\n\t}\n\tret.push_back(P(i,1));\n\tret.push_back(P(i+1,1));\n\tret.push_back(P(i+1,0));\n\tret.push_back(P(i,0));\n\tfor(int j=i-1;j>=0;j--){\n\t\tret.push_back(P(j,0));\n\t}\n}\nvoid neg(int i){\n\tfor(int j=0;j<i;j++){\n\t\tret.push_back(P(j+1,0));\n\t}\n\tret.push_back(P(i+1,0));\n\tret.push_back(P(i+1,1));\n\tret.push_back(P(i,1));\n\tret.push_back(P(i,0));\n\tfor(int j=i-1;j>=0;j--){\n\t\tret.push_back(P(j,0));\n\t}\n}\n\nvector<P> f(vector<P> vec,int t){\n\tint cnt[300]={};\n\tfor(int i=0;i<vec.size();i++){\n\t\tcnt[vec[i].sc]++;\n\t}\n\tint MIN=100;\n\tint id=-1;\n\tfor(int i=0;i<300;i++){\n\t\tif(cnt[i]==0)continue;\n\t\tif(MIN>cnt[i]){\n\t\t\tMIN=cnt[i];\n\t\t\tid=i;\n\t\t}\n\t}\n\t//cerr<<\"id=\"<<id<<endl;\n\tvector<P> ret;\n\tfor(int i=0;i<vec.size();i++){\n\t\tif(vec[i].sc!=id)ret.push_back(vec[i]);\n\t\telse {\n\t\t\tif(vec[i].fr==1){\n\t\t\t\tret.push_back(P(1,id));\n\t\t\t\tret.push_back(P(1,t));\n\t\t\t\tret.push_back(P(-1,id));\n\t\t\t\tret.push_back(P(-1,t));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret.push_back(P(1,t));\n\t\t\t\tret.push_back(P(1,id));\n\t\t\t\tret.push_back(P(-1,t));\n\t\t\t\tret.push_back(P(-1,id));\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nbool zero(vector<P> vec, int x){\n\tstack<P> st;\n\tfor(P p: vec){\n\t\tif((x>>p.sc)&1){\n\t\t\tif(st.size()==0){\n\t\t\t\tst.push(p);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tP q=st.top();\n\t\t\tif(q.sc==p.sc&&p.fr+q.fr==0)st.pop();\n\t\t\telse st.push(p);\n\t\t}\n\t}\n\treturn st.size()==0;\n}\n\nint main(){\n\tint n;\n\tstring s;\n\tcin>>n>>s;\n\t\n\tint a[300];\n\tfor(int i=0;i<(1<<n);i++)a[i]=s[i]-'0';\n\t\n\tbool used[300];\n\tmemset(used,0,sizeof used);\n\t\n\tint b[300];\n\tfor(int i=0;i<300;i++)b[i]=1;\n\t\n\tfor(int x=1;x<(1<<n);x++){\n\t\tused[x]=true;\n\t\tfor(int y=0;y<x;y++){\n\t\t\tif((x&y)==y)if(used[y])used[x]=false;\n\t\t}\n\t\tfor(int y=0;y<(1<<n);y++){\n\t\t\tif((x&y)==x)if(a[y]==1)used[x]=false;\n\t\t}\n\t\tif(used[x]){\n\t\t\tfor(int y=0;y<(1<<n);y++){\n\t\t\t\tif((x&y)==x)b[y]=0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool ok=true;\n\tfor(int i=0;i<(1<<n);i++)ok&=a[i]==b[i];\n\tif(!ok){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tvector<P> vv;\n\t/*for(int x=0;x<(1<<n);x++){\n\t\tif(!used[x])continue;\n\t\tif(vv.size()==0){\n\t\t\tvv.push_back(P(1,x));\n\t\t}\n\t\telse{\n\t\t\tvv=f(vv,x);\n\t\t}\n\t}*/\n\tvector<P> vec[300];\n\tret.push_back(P(0,0));\n\tfor(int x=0;x<(1<<n);x++){\n\t\tif(!used[x])continue;\n\t\tif(zero(vv,x)){\n\t\t\tint cnt=0;\n\t\t\tint c[10];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif((x>>i)&1)c[cnt++]=i;\n\t\t\t}\n\t\t\tvec[x].push_back(P(1,c[0]));\n\t\t\tfor(int i=1;i<cnt;i++)vec[x]=f(vec[x],c[i]);\n\t\t\tvv.insert(vv.end(),vec[x].begin(),vec[x].end());\n\t\t}\n\t}\n\tfor(P p: vv){\n\t\tif(p.fr==1)pos(p.sc);\n\t\telse neg(p.sc);\n\t}\n\t\n\t/*vector<P> ret2;\n\tfor(P p: ret){\n\t\tif(ret2.size()>=2&&ret2[ret2.size()-2]==p)ret2.pop_back();\n\t\telse ret2.push_back(p);\n\t}\n\tret=ret2;*/\n\t\n\tassert(ret.size()<=250000);\n\t\n\tputs(\"Possible\");\n\tprintf(\"%d\\n\",(int)(ret.size())-1);\n\tfor(int i=0;i<ret.size();i++){\n\t\tprintf(\"%d %d\\n\",ret[i].fr,ret[i].sc);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i = (begin); i < (end); i++)\n#define rep(i, n) FOR(i, 0, n)\nusing ll = long long;\nusing namespace std;\n#define all(x) (x).begin(),(x).end()\nusing pii = pair<int, int>; using vi = vector<int>; using vl = vector<ll>;\n\nint N;\n\nunordered_set<int> setter(int i) {\n    unordered_set<int> ss;\n    rep(j, N) {\n        int k = i & 1;\n        if (k == 0)\n            ss.insert(j);\n        i >> 1;\n    }\n    return ss;\n}\n// 和集合の計算\ntemplate<class T> unordered_set<T> Union(unordered_set<T>& rsettA, unordered_set<T>&rsettB) {\n    unordered_set<T> settUnion(rsettA);\n    for (auto itt = rsettB.begin(); itt != rsettB.end(); itt++) {\n        settUnion.insert(*itt);\n    }\n    return settUnion;\n}\n// 積集合の計算\ntemplate<class T> unordered_set<T> Product(unordered_set<T>& rsettA, unordered_set<T>&rsettB) {\n    unordered_set<T> settProduct;\n    for (auto itt = rsettB.begin(); itt != rsettB.end(); itt++) {\n        if (rsettA.find(*itt) != rsettA.end()) {\n            settProduct.insert(*itt);\n        }\n    }\n    return settProduct;\n}\n// 補集合の計算\ntemplate<class T> unordered_set<T> Complement(unordered_set<T>& rsettA, unordered_set<T>&rsettB) {\n    unordered_set<T> settComplement(rsettA);\n    for (auto itt = rsettB.begin(); itt != rsettB.end(); itt++) {\n        settComplement.erase(*itt);\n    }\n    return settComplement;\n}\nsigned main() {\n    cin >> N;\n    // unordered_set<int> oo, ii;\n    int oo(0), ii(0);\n    vi sss;\n    string as;\n    cin >> as;\n    rep(i, 1<<N) {\n        int x = as[i] - '0';\n        // auto ss = setter(i);\n        if (x == 1) {\n            oo |= i;\n            // ii = Union(ii, ss);\n        } else {\n            sss.push_back(i);\n            // oo = Union(oo, ss);\n        }\n    }\n    for(auto s : sss) {\n        if((oo&s) == s) {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n    \n    // if (Product(oo, ii).size() != 0) {\n    // if ((oo&ii) != 0) {\n    //     cout << \"Impossible\" << endl;\n    //     return 0;\n    // }\n    cout << \"Possible\" << endl;\n\n    ii = (1<<N) - oo - 1;\n    cerr << oo << ' ' << ii << endl;\n    cerr << (oo & ii) << endl;\n    vector<pii> p;\n    int before = 0;\n    // cerr << ii << endl;\n    p.push_back({0, 0});\n    rep(i, N) {\n        // cerr << ii << endl;\n        // cerr << ((ii&1) ^ before) << endl;\n        if((ii&1) ^ before) {\n            if(ii&1) {\n                if(i!=0) {\n                    p.push_back({i, 0});\n                }\n                p.push_back({i, 1});\n            } else {\n                p.push_back({i, 1});\n                if(i!=N-1)\n                    p.push_back({i, 0});\n            }\n        } else {\n            if(i!=0)\n                p.push_back({i, before});\n        }\n        before = ii & 1;\n        ii >>= 1;\n    }\n    if (before)\n        p.push_back({N, 1});\n    for(int k = N; k>=0; k--) {\n        p.push_back({k, 0});\n    }\n\n    cout << p.size() - 1 << endl;\n    for(auto pp : p) {\n        cout << pp.first << ' ' << pp.second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define INF ((1<<30)-1)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nvoid ok(){\n    cout << \"Yes\" << endl;\n    exit(0);\n}\n\nvoid ng(){\n    cout <<  \"Impossible\" << endl;\n    exit(0);\n}\n\n\nint n;\nint a[1 << 8];\n\nvector<int> loops;\n\nvoid entangle(int x){\n    vector<int> loop;\n    for(int i = n-1;i >= 0;i--){\n        if((x >> i) % 2 == 0)continue;\n        if(loop.empty()){\n            loop.push_back(i+1);\n            loop.push_back(-i-1);\n        }\n        else{\n            vector<int> tmp;\n            tmp.push_back(i+1);\n            for(auto it = loop.begin();it != loop.end();it++)tmp.push_back(*it);\n            tmp.push_back(i+1);\n            tmp.push_back(-i-1);\n            for(auto it = loop.rbegin();it != loop.rend();it++)tmp.push_back(*it);\n            tmp.push_back(-i-1);\n            loop = tmp;\n        }\n    }\n    for(auto elem:loop)loops.push_back(elem);\n    loops.push_back(INF);\n}\n\nvoid show(){\n    cout << \"Possible\" << endl;\n    vector<P> ps;\n    ps.push_back(P(0,0));\n    int nowx = 0, nowy = 0;\n    for(int x:loops){\n        if(x == INF){\n            while(nowx > 0){\n                ps.push_back(P(--nowx, nowy));\n            }\n            continue;\n        }\n        if(x > 0){\n            while(nowx > x){\n                ps.push_back(P(--nowx, nowy));\n            }\n            while(nowx < x-1){\n                ps.push_back(P(++nowx, nowy));\n            }\n            ps.push_back(P(nowx,++nowy));\n            if(nowx == x)ps.push_back(P(--nowx, nowy));\n            else ps.push_back(P(++nowx, nowy));\n            ps.push_back(P(nowx,--nowy));\n        }\n        if(x < 0){\n            x = x * -1;\n            while(nowx > x){\n                ps.push_back(P(--nowx, nowy));\n            }\n            while(nowx < x-1){\n                ps.push_back(P(++nowx, nowy));\n            }\n            if(nowx == x)ps.push_back(P(--nowx, nowy));\n            else ps.push_back(P(++nowx, nowy));\n        }\n    }\n    cout << ps.size() - 1 << endl;\n    for(auto p:ps){\n        cout << p.first << \" \" << p.second << endl;\n    }\n}\n\nint main(){\n    cin >> n;\n    for(int i = 0;i < (1<<n);i++){\n        scanf(\"%1d\", a+i);\n        bool bad;\n        if(a[i] == 0)bad = true;\n        for(int j = 0;j < i;j++){\n            if((j & i) != j)continue;\n            if(a[i] == 1 && a[j] == 0){\n                ng();                    \n            }\n            if(a[j] == 0)bad = false;\n        }\n        if(bad){\n            entangle(i);\n        }\n    }\n    show();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n#include <iostream>\n#include <fstream>\n\n#include <bits/stdc++.h>\n\n#define pb push_back\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(),(v).end()\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef vector<int> vi;\ntypedef pair<int, int> ii;\n\nclass TaskE {\n public:\n  string inverse(string s) {\n    string res = \"\";\n    for (int i = s.size() - 1; i >= 0; --i) {\n      char ch = s[i];\n      if (ch >= 'a' && ch <= 'z') {\n        ch += 'A' - 'a';\n      } else {\n        ch += 'a' - 'A';\n      }\n      res += ch;\n    }\n    return res;\n  }\n\n  void solveOne(istream &in, ostream &out) {\n    int n;\n    in >> n;\n    string a;\n    in >> a;\n    vector<bool> tangled(1 << n);\n    for (int i = 0; i < (1 << n); ++i) {\n      tangled[i] = a[i] == '0';\n    }\n    if (tangled[0]) {\n      out << \"Impossible\\n\";\n      return;\n    }\n    for (int s1 = 0; s1 < (1 << n); ++s1) {\n      for (int s2 = 0; s2 < (1 << n); ++s2) {\n        if ((s1 & s2) == s1 && !tangled[s2] && tangled[s1]) {\n          out << \"Impossible\\n\";\n          return;\n        }\n      }\n    }\n    vector<ii> pts;\n    pts.emplace_back(0, 0);\n    for (int s1 = 0; s1 < (1 << n); ++s1) {\n      if (tangled[s1]) {\n        bool ok = true;\n        for (int s2 = 0; s2 < (1 << n); ++s2) {\n          if (s1 != s2 && ((s1 & s2) == s2) && tangled[s2]) {\n            ok = false;\n          }\n        }\n        if (!ok) continue;\n        string seq = \"\";\n        for (int i = 0; i < n; ++i) {\n          if ((s1 & (1 << i)) != 0) {\n            char ch = 'a' + i;\n            if (seq.empty()) {\n              seq += ch;\n            } else {\n              seq = ch + seq + (char) (ch + 'A' - 'a') + inverse(seq);\n            }\n          }\n        }\n        cerr << seq << endl;\n        int x = 0;\n        for (int p = 0; p < seq.size(); ++p) {\n          char ch = seq[p];\n          int i;\n          int dir;\n          if (ch >= 'A' && ch <= 'Z') {\n            i = ch - 'A';\n            dir = 0;\n          } else {\n            i = ch - 'a';\n            dir = 1;\n          }\n          if (x < i) {\n            for (int j = x + 1; j <= i; ++j) {\n              pts.emplace_back(j, 0);\n            }\n          } else if (x > i) {\n            for (int j = x - 1; j >= i; --j) {\n              pts.emplace_back(j, 0);\n            }\n          }\n          x = i;\n          if (dir == 0) {\n            pts.emplace_back(i + 1, 0);\n            pts.emplace_back(i + 1, 1);\n            pts.emplace_back(i, 1);\n            pts.emplace_back(i, 0);\n          } else {\n            pts.emplace_back(i, 1);\n            pts.emplace_back(i + 1, 1);\n            pts.emplace_back(i + 1, 0);\n            pts.emplace_back(i, 0);\n          }\n        }\n        for (int j = x - 1; j >= 0; --j) {\n          pts.emplace_back(j, 0);\n        }\n        x = 0;\n      }\n    }\n    out << \"Possible\\n\";\n    out << pts.size() - 1 << \"\\n\";\n    for (const auto& p : pts) {\n      out << p.first << \" \" << p.second << \"\\n\";\n    }\n  }\n\n  void solve(std::istream &in, std::ostream &out) {\n    int nt;\n    nt = 1;\n    for (int it = 0; it < nt; ++it) {\n      solveOne(in, out);\n    }\n  }\n};\n\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  TaskE solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\nint main() {\n\tint n = nxt();\n\tstring s;\n\tcin >> s;\n\tif (s == string(1 << n, '1')) {\n\t\tcout << \"Possible\\n\";\n\t\tcout << \"0\\n0 0\\n\";\n\t\treturn 0;\n\t}\n\tif (s[0] == '0') {\n\t\tcout << \"Impossible\\n\";\n\t\treturn 0;\n\t}\n\tconst int N = 1 << n;\n\tvector<char> base(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (s[i] == '0') {\n\t\t\tbase[i] = 1;\n\t\t\tfor (int j = i; j > 0; j = (j - 1) & i) {\n\t\t\t\tif (s[i ^ j] == '0') {\n\t\t\t\t\tbase[i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int j = i; j > 0; j = (j - 1) & i) {\n\t\t\tif (s[i ^ j] == '0') {\n\t\t\t\tcout << \"Impossible\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<int> ans;\n\tfunction<void(int, bool, bool)> add = [&](int mask, bool rev, bool flip) {\n\t\tassert(mask);\n\t\tif (__builtin_popcount(mask) == 1) {\n\t\t\tans.push_back(flip ? -__builtin_ctz(mask) - 1 : __builtin_ctz(mask) + 1);\n\t\t\treturn;\n\t\t}\n\t\tint nm = mask ^ (1 << (__builtin_ctz(mask)));\n\t\tif (rev) {\n\t\t\tans.push_back(flip ? -__builtin_ctz(mask) - 1 : __builtin_ctz(mask) + 1);\n\t\t\tadd(nm, false, !flip);\n\t\t\tans.push_back(!flip ? -__builtin_ctz(mask) - 1 : __builtin_ctz(mask) + 1);\n\t\t\tadd(nm, true, flip);\n\t\t} else {\n\t\t\tadd(nm, false, flip);\n\t\t\tans.push_back(!flip ? -__builtin_ctz(mask) - 1 : __builtin_ctz(mask) + 1);\n\t\t\tadd(nm, true, !flip);\n\t\t\tans.push_back(flip ? -__builtin_ctz(mask) - 1 : __builtin_ctz(mask) + 1);\n\t\t}\n\t};\n\tfor (int mask = 0; mask < N; ++mask) {\n\t\tif (base[mask]) {\n\t\t\tadd(mask, false, false);\n\t\t}\n\t}\n\tint y = 0;\n\tvector<pair<int, int>> answer = {{0, y}};\n\tauto go = [&](int c) {\n\t\twhile (y < c) {\n\t\t\ty += 1;\n\t\t\tanswer.push_back({0, y});\n\t\t}\n\t\twhile (y > c) {\n\t\t\ty -= 1;\n\t\t\tanswer.push_back({0, y});\n\t\t}\n\t};\n\n\tfor (int i : ans) {\n\t\t// cerr << i << \" \";\n\t\tif (i < 0) {\n\t\t\tgo(-i - 1);\n\t\t\tanswer.push_back({1, y});\n\t\t\tanswer.push_back({1, y + 1});\n\t\t\tanswer.push_back({0, y + 1});\n\t\t\ty += 1;\n\t\t} else {\n\t\t\tgo(i);\n\t\t\tanswer.push_back({1, y});\n\t\t\tanswer.push_back({1, y - 1});\n\t\t\tanswer.push_back({0, y - 1});\n\t\t\ty -= 1;\n\t\t}\n\t}\n\t// cerr << \"\\n\";\n\tgo(0);\n\tcout << \"Possible\\n\";\n\tcout << (int)answer.size() - 1 << \"\\n\";\n\tfor (const auto& p : answer) {\n\t\tcout << p.second << \" \" << p.first << \"\\n\";\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<unordered_map>\n#include<complex>\nusing namespace std;\nconst long long mod=998244353;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3100000;\nconst int UF_SIZE = 3100000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint UF[UF_SIZE];\n\tvoid init_UF(int n){\n\t\tfor(int i=0;i<n;i++)UF[i]=-1;\n\t}\n\tint FIND(int a){\n\t\tif(UF[a]<0)return a;\n\t\treturn UF[a]=FIND(UF[a]);\n\t}\n\tvoid UNION(int a,int b){\n\t\ta=FIND(a);b=FIND(b);if(a==b)return;\n\t\tif(UF[a]>UF[b])swap(a,b);\n\t\tUF[a]+=UF[b];UF[b]=a;\n\t}\n}\n// ここから編集しろ\nchar in[310];\nint dp[310];\nint n;\nvector<pair<int,int> >v;\nvector<pair<int,int> >cm;\nvector<pair<int,int> > ad(vector<int>a){\n\tvector<pair<int,int> > ret;\n\tif(a.size()==1){\n\t\tret.push_back(make_pair(a[0],1));\n\t\tret.push_back(make_pair(a[0],0));\n\t\treturn ret;\n\t}\n\tret.push_back(make_pair(a[0],1));\n\tvector<int>b;\n\tfor(int i=1;i<a.size();i++)\n\t\tb.push_back(a[i]);\n\tvector<pair<int,int> >S=ad(b);\n\tfor(int i=0;i<S.size();i++){\n\t\tret.push_back(S[i]);\n\t}\n\tret.push_back(make_pair(a[0],1));\n\tret.push_back(make_pair(a[0],0));\n\treverse(S.begin(),S.end());\n\tfor(int i=0;i<S.size();i++){\n\t\tret.push_back(S[i]);\n\t}\n\tret.push_back(make_pair(a[0],0));\n\treturn ret;\n}\nvoid f(int a){\n\tif(dp[a])return;\n\tif(a==0)return;\n\tdp[a]=1;\n\tbool ok=true;\n\tfor(int i=0;i<n;i++){\n\t\tif(!(a&(1<<i)))continue;\n\t\tif(in[a-(1<<i)]=='0'){\n\t\t\tok=false;\n\t\t\tf(a-(1<<i));\n\t\t}\n\t}\n\tif(ok){\n\t\tvector<int>q;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(a&(1<<i))q.push_back(i);\n\t\t}\n\t\tvector<pair<int,int> >tmp=ad(q);\n\t\tfor(int i=0;i<tmp.size();i++){\n\t\t\tcm.push_back(tmp[i]);\n\t\t}\n\t}\n}\nint main_(){\n\t// int a=4;\n\t// n=a;\n\tint a;scanf(\"%d\",&a);\n\tn=a;\n\tscanf(\"%s\",in);\n\tv.clear();\n\tcm.clear();\n\tfor(int i=0;i<310;i++)dp[i]=0;\n\tfor(int i=0;i<(1<<a);i++){\n\t\tif(in[i]=='1'){\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(i&(1<<j)){\n\t\t\t\t\tif(in[i-(1<<j)]=='0'){\n\t\t\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"Possible\\n\");\n\tif(in[(1<<a)-1]=='1'){\n\t\tprintf(\"0\\n\");\n\t\tprintf(\"0 0\\n\");\n\t\treturn 0;\n\t}\n\tf((1<<a)-1);\n\tint now=0;\n\tv.push_back(make_pair(0,0));\n\tfor(int i=0;i<cm.size();i++){\n\t\tif(now<=cm[i].first){\n\t\t\twhile(now<cm[i].first){\n\t\t\t\tnow++;\n\t\t\t\tv.push_back(make_pair(now,0));\n\t\t\t}\n\t\t\tif(cm[i].second){\n\t\t\t\tv.push_back(make_pair(now,1));\n\t\t\t\tv.push_back(make_pair(now+1,1));\n\t\t\t}\n\t\t\tv.push_back(make_pair(now+1,0));\n\t\t\tnow++;\n\t\t}else{\n\t\t\twhile(now>1+cm[i].first){\n\t\t\t\tnow--;\n\t\t\t\tv.push_back(make_pair(now,0));\n\t\t\t}\n\t\t\tif(cm[i].second){\n\t\t\t\tv.push_back(make_pair(now,1));\n\t\t\t\tv.push_back(make_pair(now-1,1));\n\t\t\t}\n\t\t\tv.push_back(make_pair(now-1,0));\n\t\t\tnow--;\n\t\t}\n\t}\n\twhile(now>0){\n\t\tnow--;\n\t\tv.push_back(make_pair(now,0));\n\t}\n\tif(v.size()>=250000)while(1);\n\tprintf(\"%d\\n\",(int)(v.size())-1);\n\tfor(int i=0;i<v.size();i++){\n\t\tprintf(\"%d %d\\n\",v[i].first,v[i].second);\n\t}\n\tfor(int i=0;i+1<v.size();i++){\n\t\tassert(ABS(v[i].first-v[i+1].first)+ABS(v[i].second-v[i+1].second)==1);\n\t}\n\tfor(int i=0;i<(1<<a);i++){\n\t\tstack<pair<int,int> > S;\n\t\tfor(int j=0;j+1<v.size();j++){\n\t\t\tif(v[j].first==v[j+1].first)continue;\n\t\t\tint x=min(v[j].first,v[j+1].first);\n\t\t\tint y=v[j].second;\n\t\t\tif(S.size()&&S.top()==make_pair(x,y)){\n\t\t\t\tS.pop();\n\t\t\t}else S.push(make_pair(x,y));\n\t\t}\n\t\tif(S.size()==0&&in[i]=='0'){\n\t\t\texit(1);\n\t\t}else if(S.size()==1&&in[i]=='1'){\n\t\t\texit(1);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tmain_();\n\t// for(int i=1;i<65536;i++){\n\t// \tfor(int j=0;j<16;j++){\n\t// \t\tif(i&(1<<j))in[j]='1';\n\t// \t\telse in[j]='0';\n\t// \t}\n\t// \t// printf(\"%d:\\n\",i);\n\t// \tmain_();\n\t// }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MX = 8;\n\nvoid print(int n, int msk) {\n\tvector<pair<int, int>> ans;\n\tans.emplace_back(0, 1);\n\tfor (int i = 0, p = 0; i < n; i++) {\n\t\tif (((msk >> i) & 1) == 1) {\n\t\t\tif (p == 1) ans.pop_back();\n\t\t\telse ans.emplace_back(i, 0);\n\t\t\t\n\t\t\tans.emplace_back(i + 1, 0);\n\t\t\tans.emplace_back(i + 1, 1);\n\t\t\t\n\t\t\tp = 1;\n\t\t}\n\t\telse {\n\t\t\tans.emplace_back(i + 1, 1);\n\t\t\t\n\t\t\tp = 0;\n\t\t}\n\t}\n\t\n\tfor (int i = n - 1; i >= 0; i--) ans.emplace_back(i, 1);\n\t\n\tprintf(\"Possible\\n%zu\\n\", ans.size() - 1);\n\tfor (auto& p : ans) {\n\t\tprintf(\"%d %d\\n\", p.first, p.second);\n\t}\n\t\n\texit(0);\n}\n\nint a[1 << MX];\nchar s[2 << MX];\n\nint main() {\n\tint n;\n\tignore = scanf(\"%d %s\", &n, s);\n\tfor (int i = 0; i < (1 << n); i++) {\n\t\ta[i] = s[i] - '0';\n\t}\n\t\n\tfor (int msk = 0; msk < (1 << n); msk++) {\n\t\tbool ok = true;\n\t\tfor (int i = 0; i < (1 << n); i++) {\n\t\t\tint can = ((msk & i) == 0 ? 1 : 0);\n\t\t\tok = ok && can == a[i];\n\t\t}\n\t\t\n\t\tif (ok) print(msk, n);\n\t}\n\t\n\tprintf(\"%s\\n\", \"Impossible\");\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,r,i,j,k,m,b[277],x[250250],y[250250];\nchar s[277];\nint main() {\n  scanf(\"%d\",&n);\n  scanf(\"%s\",s);\n  for (i=0; i<n; i++) {\n    bool all=true;\n    for (j=0; j<(1<<n); j++) if ((j>>i)&1) all&=(s[j]=='0');\n    if (all) b[m++]=i;\n  }\n  for (j=0; j<(1<<n); j++) if (s[j]=='0') {\n    for (i=0; i<m; i++) if ((j>>b[i])&1) break;\n    if (i>=m) { puts(\"Impossible\"); return 0; }\n  } else {\n    for (i=0; i<m; i++) if ((j>>b[i])&1) break;\n    if (i<m) { puts(\"Impossible\"); return 0; }\n  }\n  puts(\"Possible\");\n  if (m==0) {\n    puts(\"0\");\n    puts(\"1 1\");\n    return 0;\n  }\n  for (i=0; i<m; i=j+1) {\n    if (i) for (k=b[i-1]+1; k<b[i]; k++) { x[r]=k; y[r++]=0; }\n    for (j=i; j+1<m && b[j+1]==b[j]+1; j++);\n    x[r]=b[i]; y[r++]=0;\n    for (k=b[i]; k<=b[j]+1; k++) { x[r]=k; y[r++]=1; }\n  }\n  for (k=b[m-1]+1; k>=b[0]; k--) { x[r]=k; y[r++]=0; }\n  printf(\"%d\\n\",r-1);\n  for (i=0; i<r; i++) printf(\"%d %d\\n\",x[i],y[i]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,L;\nstring A;\nint ismin[256];\n\n\nvector<pair<int,int>> construct(int mask) {\n\tvector<pair<int,int>> V;\n\t\n\tint i;\n\tFOR(i,N) if(mask&(1<<i)) {\n\t\tif(__builtin_popcount(mask)==1) {\n\t\t\tV.push_back({i,1});\n\t\t\tV.push_back({i+1,1});\n\t\t\tV.push_back({i+1,0});\n\t\t\tV.push_back({i,0});\n\t\t}\n\t\telse {\n\t\t\tvector<pair<int,int>> W=construct(mask^(1<<i));\n\t\t\tV.push_back({i,1});\n\t\t\twhile(V.back().first+1<W[0].first) {\n\t\t\t\tV.push_back(V.back());\n\t\t\t\tV.back().first++;\n\t\t\t}\n\t\t\tFORR(w,W) V.push_back(w);\n\t\t\tV.push_back(W.back());\n\t\t\tV.back().second=1;\n\t\t\twhile(V.back().first>i) {\n\t\t\t\tV.push_back(V.back());\n\t\t\t\tV.back().first--;\n\t\t\t}\n\t\t\tV.push_back({i,0});\n\t\t\tV.push_back({i+1,0});\n\t\t\tV.push_back({i+1,1});\n\t\t\treverse(ALL(W));\n\t\t\twhile(V.back().first<W[0].first) {\n\t\t\t\tV.push_back(V.back());\n\t\t\t\tV.back().first++;\n\t\t\t}\n\t\t\t\n\t\t\tFORR(w,W) V.push_back(w);\n\t\t\twhile(V.back().first>i+1) {\n\t\t\t\tV.push_back(V.back());\n\t\t\t\tV.back().first--;\n\t\t\t}\n\t\t\tV.push_back({i+1,0});\n\t\t\tV.push_back({i,0});\n\t\t}\n\t\tbreak;\n\t}\n\treturn V;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>A;\n\tL=1<<N;\n\tFORR(c,A) c-='0';\n\tFOR(x,L) FOR(y,L) if((x&y)==y && A[x] && A[y]==0) return _P(\"Impossible\\n\");\n\tFOR(x,L) ismin[x]=A[x]==0;\n\tFOR(x,L) if(A[x]==0) FOR(y,L) if((x&y)==y && y<x && A[y]==0) ismin[y]=0;\n\t\n\tvector<pair<int,int>> W;\n\tW.push_back({0,0});\n\tFOR(x,L) if(A[x]==0) {\n\t\tvector<pair<int,int>> V=construct(x);\n\t\tFOR(i,V[0].first) W.push_back({i,1});\n\t\tFORR(v,V) W.push_back(v);\n\t\tfor(i=V[0].first;i>=0;i--) W.push_back({i,1});\n\t\tW.push_back({0,0});\n\t}\n\tcout<<\"Possible\"<<endl;\n\tcout<<W.size()-1<<endl;\n\tFORR(w,W) cout<<w.first<<\" \"<<w.second<<endl;\n\t/*\n\tFOR(i,W.size()-1) {\n\t\tcout<<i<<\" \"<<W[i].first<<\" \"<<W[i].second<<\" \"<<W[i+1].first<<\" \"<<W[i+1].second<<endl;\n\t\tassert(abs(W[i].first-W[i+1].first)+abs(W[i].second-W[i+1].second)==1);\n\t}\n\t*/\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<unordered_map>\n#include<complex>\nusing namespace std;\nconst long long mod=998244353;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3100000;\nconst int UF_SIZE = 3100000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint UF[UF_SIZE];\n\tvoid init_UF(int n){\n\t\tfor(int i=0;i<n;i++)UF[i]=-1;\n\t}\n\tint FIND(int a){\n\t\tif(UF[a]<0)return a;\n\t\treturn UF[a]=FIND(UF[a]);\n\t}\n\tvoid UNION(int a,int b){\n\t\ta=FIND(a);b=FIND(b);if(a==b)return;\n\t\tif(UF[a]>UF[b])swap(a,b);\n\t\tUF[a]+=UF[b];UF[b]=a;\n\t}\n}\n// ここから編集しろ\nchar in[310];\nint dp[310];\nint n;\nvector<pair<int,int> >v;\nvector<pair<int,int> >cm;\nvector<pair<int,int> > ad(vector<int>a){\n\tvector<pair<int,int> > ret;\n\tif(a.size()==1){\n\t\tret.push_back(make_pair(a[0],1));\n\t\tret.push_back(make_pair(a[0],0));\n\t\treturn ret;\n\t}\n\tret.push_back(make_pair(a[0],1));\n\tvector<int>b;\n\tfor(int i=1;i<a.size();i++)\n\t\tb.push_back(a[i]);\n\tvector<pair<int,int> >S=ad(b);\n\tfor(int i=0;i<S.size();i++){\n\t\tret.push_back(S[i]);\n\t}\n\tret.push_back(make_pair(a[0],1));\n\tret.push_back(make_pair(a[0],0));\n\treverse(S.begin(),S.end());\n\tfor(int i=0;i<S.size();i++){\n\t\tret.push_back(S[i]);\n\t}\n\tret.push_back(make_pair(a[0],0));\n\treturn ret;\n}\nvoid f(int a){\n\tif(dp[a])return;\n\tif(a==0)return;\n\tdp[a]=1;\n\tbool ok=true;\n\tfor(int i=0;i<n;i++){\n\t\tif(!(a&(1<<i)))continue;\n\t\tif(in[a-(1<<i)]=='0'){\n\t\t\tok=false;\n\t\t\tf(a-(1<<i));\n\t\t}\n\t}\n\tif(ok){\n\t\tvector<int>q;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(a&(1<<i))q.push_back(i);\n\t\t}\n\t\tvector<pair<int,int> >tmp=ad(q);\n\t\tfor(int i=0;i<tmp.size();i++){\n\t\t\tcm.push_back(tmp[i]);\n\t\t}\n\t}\n}\nint main_(){\n\t// int a=4;\n\t// n=a;\n\tint a;scanf(\"%d\",&a);\n\tn=a;\n\tscanf(\"%s\",in);\n\tv.clear();\n\tcm.clear();\n\tfor(int i=0;i<310;i++)dp[i]=0;\n\tfor(int i=0;i<(1<<a);i++){\n\t\tif(in[i]=='1'){\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(i&(1<<j)){\n\t\t\t\t\tif(in[i-(1<<j)]=='0'){\n\t\t\t\t\t\tprintf(\"Impossible\\n\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"Possible\\n\");\n\tif(in[(1<<a)-1]=='1'){\n\t\tprintf(\"0\\n\");\n\t\tprintf(\"0 0\\n\");\n\t\treturn 0;\n\t}\n\tf((1<<a)-1);\n\tint now=0;\n\tv.push_back(make_pair(0,0));\n\tfor(int i=0;i<cm.size();i++){\n\t\tif(now<=cm[i].first){\n\t\t\twhile(now<cm[i].first){\n\t\t\t\tnow++;\n\t\t\t\tv.push_back(make_pair(now,0));\n\t\t\t}\n\t\t\tif(cm[i].second){\n\t\t\t\tv.push_back(make_pair(now,1));\n\t\t\t\tv.push_back(make_pair(now+1,1));\n\t\t\t}\n\t\t\tv.push_back(make_pair(now+1,0));\n\t\t\tnow++;\n\t\t}else{\n\t\t\twhile(now>1+cm[i].first){\n\t\t\t\tnow--;\n\t\t\t\tv.push_back(make_pair(now,0));\n\t\t\t}\n\t\t\tif(cm[i].second){\n\t\t\t\tv.push_back(make_pair(now,1));\n\t\t\t\tv.push_back(make_pair(now-1,1));\n\t\t\t}\n\t\t\tv.push_back(make_pair(now-1,0));\n\t\t\tnow--;\n\t\t}\n\t}\n\twhile(now>0){\n\t\tnow--;\n\t\tv.push_back(make_pair(now,0));\n\t}\n\tif(v.size()>=250000)while(1);\n\tprintf(\"%d\\n\",(int)(v.size())-1);\n\tfor(int i=0;i<v.size();i++){\n\t\tprintf(\"%d %d\\n\",v[i].first,v[i].second);\n\t}\n\n\tfor(int i=0;i<(1<<a);i++){\n\t\tstack<pair<int,int> > S;\n\t\tfor(int j=0;j+1<v.size();j++){\n\t\t\tif(v[j].first==v[j+1].first)continue;\n\t\t\tint x=min(v[j].first,v[j+1].first);\n\t\t\tint y=v[j].second;\n\t\t\tif(S.size()&&S.top()==make_pair(x,y)){\n\t\t\t\tS.pop();\n\t\t\t}else S.push(make_pair(x,y));\n\t\t}\n\t\tif(S.size()==0&&in[i]=='0'){\n\t\t\texit(1);\n\t\t}else if(S.size()==1&&in[i]=='1'){\n\t\t\texit(1);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tmain_();\n\t// for(int i=1;i<65536;i++){\n\t// \tfor(int j=0;j<16;j++){\n\t// \t\tif(i&(1<<j))in[j]='1';\n\t// \t\telse in[j]='0';\n\t// \t}\n\t// \t// printf(\"%d:\\n\",i);\n\t// \tmain_();\n\t// }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define fr first\n#define sc second\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n\nvector<P> ret;\n\nvoid pos(int i){\n\tfor(int j=0;j<i;j++){\n\t\tret.push_back(P(j+1,0));\n\t}\n\tret.push_back(P(i,1));\n\tret.push_back(P(i+1,1));\n\tret.push_back(P(i+1,0));\n\tret.push_back(P(i,0));\n\tfor(int j=i-1;j>=0;j--){\n\t\tret.push_back(P(j,0));\n\t}\n}\nvoid neg(int i){\n\tfor(int j=0;j<i;j++){\n\t\tret.push_back(P(j+1,0));\n\t}\n\tret.push_back(P(i+1,0));\n\tret.push_back(P(i+1,1));\n\tret.push_back(P(i,1));\n\tret.push_back(P(i,0));\n\tfor(int j=i-1;j>=0;j--){\n\t\tret.push_back(P(j,0));\n\t}\n}\n\t\n\nint main(){\n\tint n;\n\tstring s;\n\tcin>>n>>s;\n\t\n\tint a[300];\n\tfor(int i=0;i<(1<<n);i++)a[i]=s[i]-'0';\n\t\n\tbool used[300];\n\tmemset(used,0,sizeof used);\n\t\n\tint b[300];\n\tfor(int i=0;i<300;i++)b[i]=1;\n\t\n\tfor(int x=1;x<(1<<n);x++){\n\t\tused[x]=true;\n\t\t//if(used[x])cerr<<x<<endl;\n\t\tfor(int y=0;y<x;y++){\n\t\t\tif((x&y)==y)if(used[y])used[x]=false;\n\t\t}\n\t\t//if(used[x])cerr<<x<<endl;\n\t\tfor(int y=0;y<(1<<n);y++){\n\t\t\tif((x&y)==x)if(a[x]==1)used[x]=false;\n\t\t}\n\t\t//if(used[x])cerr<<x<<endl;\n\t\tif(used[x]){\n\t\t\tfor(int y=0;y<(1<<n);y++){\n\t\t\t\tif((x&y)==x)b[x]=0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool ok=true;\n\tfor(int i=0;i<(1<<n);i++)ok&=a[i]==b[i];\n\tif(!ok){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tret.push_back(P(0,0));\n\tfor(int x=0;x<(1<<n);x++){\n\t\tif(!used[x])continue;\n\t\tint cnt=0;\n\t\tint c[10];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif((x>>i)&1)c[cnt++]=i;\n\t\t}\n\t\tif(cnt==1){\n\t\t\tpos(c[0]);\n\t\t}\n\t\telse if(cnt==2){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[1]);\n\t\t}\n\t\telse if(cnt==3){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[2]);\n\t\t}\n\t}\n\t\n\t/*for(int i=0;i<n;i++){\n\t\tif(used[i][i]){\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t}\n\t\t\tret.push_back(P(i,1));\n\t\t\tret.push_back(P(i+1,1));\n\t\t\tret.push_back(P(i+1,0));\n\t\t\tret.push_back(P(i,0));\n\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\tret.push_back(P(j,0));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int k=i+1;k<n;k++){\n\t\t\tif(used[i][k]){\n\t\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(i,1));\n\t\t\t\tret.push_back(P(i+1,1));\n\t\t\t\tret.push_back(P(i+1,0));\n\t\t\t\tret.push_back(P(i,0));\n\t\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(k,1));\n\t\t\t\tret.push_back(P(k+1,1));\n\t\t\t\tret.push_back(P(k+1,0));\n\t\t\t\tret.push_back(P(k,0));\n\t\t\t\tfor(int j=k-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(i+1,0));\n\t\t\t\tret.push_back(P(i+1,1));\n\t\t\t\tret.push_back(P(i,1));\n\t\t\t\tret.push_back(P(i,0));\n\t\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(k+1,0));\n\t\t\t\tret.push_back(P(k+1,1));\n\t\t\t\tret.push_back(P(k,1));\n\t\t\t\tret.push_back(P(k,0));\n\t\t\t\tfor(int j=k-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}*/\n\t\n\tputs(\"Possible\");\n\tprintf(\"%d\\n\",(int)(ret.size())-1);\n\tfor(int i=0;i<ret.size();i++){\n\t\tprintf(\"%d %d\\n\",ret[i].fr,ret[i].sc);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define cerr if (false) cerr\n#define db(x) cerr << #x << \"=\" << x << endl\n#define db2(x, y) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\n#define db3(x, y, z) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << \",\" << #z << \"=\" << z << endl\n#define dbv(v) cerr << #v << \"=\"; for (auto _x : v) cerr << _x << \", \"; cerr << endl\n#define dba(a, n) cerr << #a << \"=\"; for (int _i = 0; _i < (n); ++_i) cerr << a[_i] << \", \"; cerr << endl\ntemplate <typename A, typename B>\nostream& operator<<(ostream& os, const pair<A, B>& x) {\n\treturn os << \"(\" << x.first << \",\" << x.second << \")\";\n}\ntypedef long long ll;\ntypedef long double ld;\nchar str[305];\nint main() {\n\tint n;\n\tscanf(\"%d%s\", &n, str);\n\tint m = 1 << n;\n\tvector<int> S;\n\tbool sol = true;\n\tfor (int i = 1; i < m; ++i) {\n\t\tbool bad = false;\n\t\tif (str[i] == '1') continue;\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (i & (1 << j)) {\n\t\t\t\tif (str[i ^ (1 << j)] == '0') bad = true;\n\t\t\t} else {\n\t\t\t\tif (str[i ^ (1 << j)] == '1') sol = false;\n\t\t\t}\n\t\t}\n\t\tif (!bad) S.push_back(i);\n\t}\n\tif (!sol) printf(\"Impossible\\n\");\n\telse {\n\t\tvector<pair<int, int>> ans = {{0, 0}};\n\t\tfor (int b : S) {\n\t\t\tvector<pair<int, int>> curve;\n\t\t\tint las = -1;\n\t\t\tfor (int i = n - 1; i >= 0; --i) {\n\t\t\t\tif (!(b & (1 << i))) continue;\n\t\t\t\tif (las == -1) {\n\t\t\t\t\tcurve = {{i, 0}, {i, 1}, {i + 1, 1}, {i + 1, 0}, {i, 0}};\n\t\t\t\t\tlas = i;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvector<pair<int, int>> ncurve;\n\t\t\t\tncurve.emplace_back(i, 0);\n\t\t\t\tfor (int j = i; j <= las; ++j) ncurve.emplace_back(j, 1);\n\t\t\t\tncurve.insert(ncurve.end(), curve.begin(), curve.end());\n\t\t\t\tfor (int j = las; j >= i; --j) ncurve.emplace_back(j, 1);\n\t\t\t\tncurve.emplace_back(i, 0);\n\t\t\t\tncurve.emplace_back(i + 1, 0);\n\t\t\t\tfor (int j = i + 1; j <= las; ++j) ncurve.emplace_back(j, 1);\n\t\t\t\tncurve.insert(ncurve.end(), curve.rbegin(), curve.rend());\n\t\t\t\tfor (int j = las; j >= i + 1; --j) ncurve.emplace_back(j, 1);\n\t\t\t\tncurve.emplace_back(i + 1, 0);\n\t\t\t\tncurve.emplace_back(i, 0);\n\t\t\t\tcurve = ncurve;\n\t\t\t\tlas = i;\n\t\t\t}\n\t\t\tif (las) {\n\t\t\t\tvector<pair<int, int>> ncurve = {{0, 0}};\n\t\t\t\tfor (int j = 0; j <= las; ++j) ncurve.emplace_back(j, 1);\n\t\t\t\tncurve.insert(ncurve.end(), curve.begin(), curve.end());\n\t\t\t\tfor (int j = las; j >= 0; --j) ncurve.emplace_back(j, 1);\n\t\t\t\tncurve.emplace_back(0, 0);\n\t\t\t\tcurve = ncurve;\n\t\t\t}\n\t\t\tans.pop_back();\n\t\t\tans.insert(ans.end(), curve.begin(), curve.end());\n\t\t}\n\t\tprintf(\"Possible\\n%d\\n\", (int)ans.size() - 1);\n\t\tfor (auto& a : ans) printf(\"%d %d\\n\", a.first, a.second);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#ifndef AT_HOME\n#define getchar() IO::myGetchar()\n#define putchar(x) IO::myPutchar(x)\n#endif\n\nnamespace IO {\n\tstatic const int IN_BUF = 1 << 23, OUT_BUF = 1 << 23;\n\n\tinline char myGetchar() {\n\t\tstatic char buf[IN_BUF], *ps = buf, *pt = buf;\n\t\tif (ps == pt) {\n\t\t\tps = buf, pt = buf + fread(buf, 1, IN_BUF, stdin);\n\t\t}\n\t\treturn ps == pt ? EOF : *ps++;\n\t}\n\n\ttemplate<typename T>\n\tinline bool read(T &x) {\n\t\tbool op = 0;\n\t\tchar ch = getchar();\n\t\tx = 0;\n\t\tfor (; !isdigit(ch) && ch != EOF; ch = getchar()) {\n\t\t\top ^= (ch == '-');\n\t\t}\n\t\tif (ch == EOF) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (; isdigit(ch); ch = getchar()) {\n\t\t\tx = x * 10 + (ch ^ '0');\n\t\t}\n\t\tif (op) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn true;\n\t}\n\n\tinline int readStr(char *s) {\n\t\tint n = 0;\n\t\tchar ch = getchar();\n\t\tfor (; isspace(ch) && ch != EOF; ch = getchar())\n\t\t\t;\n\t\tfor (; !isspace(ch) && ch != EOF; ch = getchar()) {\n\t\t\ts[n++] = ch;\n\t\t}\n\t\ts[n] = '\\0';\n\t\treturn n;\n\t}\n\n\tinline void myPutchar(char x) {\n\t\tstatic char pbuf[OUT_BUF], *pp = pbuf;\n\t\tstruct _flusher {\n\t\t\t~_flusher() {\n\t\t\t\tfwrite(pbuf, 1, pp - pbuf, stdout);\n\t\t\t}\n\t\t};\n\t\tstatic _flusher outputFlusher;\n\t\tif (pp == pbuf + OUT_BUF) {\n\t\t\tfwrite(pbuf, 1, OUT_BUF, stdout);\n\t\t\tpp = pbuf;\n\t\t}\n\t\t*pp++ = x;\n\t}\n\n\ttemplate<typename T>\n\tinline void print_(T x) {\n\t\tif (x == 0) {\n\t\t\tputchar('0');\n\t\t\treturn;\n\t\t}\n\t\tstatic int num[40];\n\t\tif (x < 0) {\n\t\t\tputchar('-');\n\t\t\tx = -x;\n\t\t}\n\t\tfor (*num = 0; x; x /= 10) {\n\t\t\tnum[++*num] = x % 10;\n\t\t}\n\t\twhile (*num){\n\t\t\tputchar(num[*num] ^ '0');\n\t\t\t--*num;\n\t\t}\n\t}\n\n\ttemplate<typename T>\n\tinline void print(T x, char ch = '\\n') {\n\t\tprint_(x);\n\t\tputchar(ch);\n\t}\n\n\tinline void printStr_(const char *s, int n = -1) {\n\t\tif (n == -1) {\n\t\t\tn = strlen(s);\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tputchar(s[i]);\n\t\t}\n\t}\n\n\tinline void printStr(const char *s, int n = -1, char ch = '\\n') {\n\t\tprintStr_(s, n);\n\t\tputchar(ch);\n\t}\n}\nusing namespace IO;\n\nconst int N = 8;\n\nint n;\nchar a[1 << N | 5];\n\nstd::vector<std::pair<int, int>> get(int S, int lst) {\n\tint k = 0;\n\twhile (!(S >> k & 1)) {\n\t\t++k;\n\t}\n\tstd::vector<std::pair<int, int>> res;\n\tif (S == (1 << k)) {\n\t\tfor (int i = lst; i < k; ++i) {\n\t\t\tres.push_back({i, 1});\n\t\t}\n\t\tres.push_back({k, 1});\n\t\tres.push_back({k, 0});\n\t\tfor (int i = lst; i < k; ++i) {\n\t\t\tres.push_back({i, 1});\n\t\t}\n\t\treturn res;\n\t}\n\tstd::vector<std::pair<int, int>> t = get(S ^ (1 << k), k + 1);\n\tfor (int i = lst; i < k; ++i) {\n\t\tres.push_back({i, 1});\n\t}\n\tres.push_back({k, 1});\n\tfor (auto i : t) {\n\t\tres.push_back(i);\n\t}\n\tres.push_back({k, 1});\n\tres.push_back({k, 0});\n\tstd::reverse(t.begin(), t.end());\n\tfor (auto i : t) {\n\t\tres.push_back(i);\n\t}\n\tres.push_back({k, 0});\n\tfor (int i = k - 1; i >= lst; --i) {\n\t\tres.push_back({i, 1});\n\t}\n\treturn res;\n}\n\nvoid solve() {\n\tread(n);\n\treadStr(a);\n\tfor (int i = 1; i < (1 << n); ++i) {\n\t\tif (a[i] == '1') {\n\t\t\tfor (int j = i; j; j = (j - 1) & i) {\n\t\t\t\tif (a[j] == '0') {\n\t\t\t\t\tprintStr(\"Impossible\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstd::vector<std::pair<int, int>> res;\n\tfor (int i = 1; i < (1 << n); ++i) {\n\t\tif (a[i] == '0') {\n\t\t\tbool flag = 1;\n\t\t\tfor (int j = i; j; j = (j - 1) & i) {\n\t\t\t\tif (i != j && a[j] == '0') {\n\t\t\t\t\tflag = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstd::vector<std::pair<int, int>> t(get(i, 0));\n\t\t\tfor (auto v : t) {\n\t\t\t\tres.push_back(v);\n\t\t\t}\n\t\t}\n\t}\n\tint x = 0, y = 0;\n\tstd::vector<std::pair<int, int>> ans(1, {0, 0});\n\tfor (auto v : res) {\n\t\tif (y != v.second) {\n\t\t\ty = v.second;\n\t\t\tans.push_back({x, y});\n\t\t}\n\t\tif (x == v.first) {\n\t\t\t++x;\n\t\t} else {\n\t\t\t--x;\n\t\t}\n\t\tans.push_back({x, y});\n\t}\n\tif (y) {\n\t\ty = 0;\n\t\tans.push_back({x, y});\n\t}\n\tprintStr(\"Possible\");\n\tprint((int)ans.size() - 1);\n\tfor (auto v : ans) {\n\t\tprint(v.first, ' '), print(v.second);\n\t}\n}\n\nint main() {\n\tint T = 1;\n\t// read(T);\n\twhile (T--) {\n\t\tsolve();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nstring inverse(string s){\n    string ans = s;\n    reverse(ans.begin(), ans.end());\n    for(int i = 0; i<s.size(); i++){\n        ans[i] = 2*'0' - ans[i];\n    }\n \n    return ans;\n}\n \nstring flips(string s){\n     string ans = s;\n    for(int i = 0; i<s.size(); i++){\n        ans[i] = 2*'0' - ans[i];\n    }\n \n    return ans;\n}\n \nint main(){\n    int n;\n    cin >> n;\n \n    char a[(1 << n)];\n    for(int i = 0; i<(1 << n); i++){\n        cin >> a[i];\n    }\n \n    string word = \"\";\n \n    for(int i = 0; i<(1 << n); i++){\n        bool flag = 0;\n        for(int j = 0; j<n; j++){\n            if(a[i] == '1' && a[i & (1 << j)] == '0' || a[0] == '0'){\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n \n            if(a[i] == '0' || (a[i] == '1' && a[i | (1 << j)] == '1' && i < (i | (1 << j))) ) flag = 1;\n        }\n \n        if(!flag){\n            string nw;\n            for(int j = 0; j<n; j++){\n                if(!(i & (1 << j))) nw.push_back('0' + j + 1);\n            }\n \n            if(word == \"\") word = word + nw + inverse(word);\n            else word = word + nw + inverse(word) + inverse(nw);\n        }\n    }\n \n    vector<pair<int, int> > ans;\n    cout << \"Possible\" << endl;\n \n    ans.push_back({0, 0});\n    for(char c: word){\n        if(c < '0'){\n            int offset = '0' - c - 1;\n            for(int i = 1; i<=offset; i++){\n                ans.push_back({i, 0});\n            }\n            ans.push_back({offset, 1});\n            ans.push_back({offset + 1, 1});\n            for(int i = offset + 1; i>=0; i--){\n                ans.push_back({i, 0});\n            }\n        }\n \n        else{\n            int offset = c - '0' - 1;\n            for(int i = 1; i<=offset + 1; i++){\n                ans.push_back({i, 0});\n            }\n            ans.push_back({offset + 1, 1});\n            ans.push_back({offset, 1});\n            for(int i = offset; i>=0; i--){\n                ans.push_back({i, 0});\n            }\n        }\n    }\n \n    cout << ans.size() - 1 << endl;\n    for(auto p: ans){\n        cout << p.first << \" \" << p.second << endl;\n    }\n \n \n \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nint n;\nchar s[1010];\nvector<PII> ans,c,trash;\nvector<PII> build(VI w) {\n  if (SZ(w)==1) return vector<PII>{{w[0],0}};\n  vector<PII> z{{w[0],0},{w[1],0},{w[0],1},{w[1],1}};\n  rep(i,2,SZ(w)) {\n    vector<PII> nz=z; \n    z.pb({w[i],0});\n    reverse(all(nz));\n    for (auto p:nz) z.pb({p.fi,p.se^1});\n    z.pb({w[i],-1});\n  }\n  return z;\n}\nint zz;\nint main() {\n  scanf(\"%d\",&n);\n  scanf(\"%s\",s);\n  //rep(i,0,(1<<n)) s[i]=(__builtin_popcount(i)<5)+'0';\n  rep(i,0,(1<<n)) if (s[i]=='0') {\n    rep(j,0,(1<<n)) if ((j&i)==i&&s[j]=='1') {\n      puts(\"Impossible\");\n      return 0;\n    }\n    bool cc=0;\n    rep(j,0,(1<<n)) if ((i&j)==j&&i!=j&&s[j]=='0') cc=1;\n    if (cc) continue;\n    VI w;\n    rep(j,0,n) if (i&(1<<j)) w.pb(j);\n    auto x=build(w);\n    for (auto p:x) ans.pb(p);\n    zz++;\n    //rep(i,0,n) ans.pb(mp(i,0)),trash.pb(mp(i,0));\n    rep(i,0,100) {\n      int x=rnd(n);\n      ans.pb(mp(x,0)),trash.pb(mp(x,0));\n    }\n  }\n  //fprintf(stderr,\"%d\\n\",zz);\n  reverse(all(trash));\n  for (auto p:trash) ans.pb(mp(p.fi,1));\n // rep(i,0,zz) per(j,0,n) ans.pb(mp(j,-1));\n  puts(\"Possible\");\n  int pos=0;\n  c.pb(mp(0,0));\n  for (auto p:ans) {\n    //printf(\"pp %d %d\\n\",p.fi,p.se);\n    if (p.se==0) {\n      while (pos<p.fi) {\n        pos+=1;\n        c.pb(mp(pos,0));\n      }\n      while (pos>p.fi) {\n        pos-=1;\n        c.pb(mp(pos,0));\n      }\n      c.pb(mp(pos,1));\n      c.pb(mp(pos+1,1));\n      c.pb(mp(pos+1,0));\n      pos+=1;\n    } else {\n      while (pos<p.fi+1) {\n        pos+=1;\n        c.pb(mp(pos,0));\n      }\n      while (pos>p.fi+1) {\n        pos-=1;\n        c.pb(mp(pos,0));\n      }\n      c.pb(mp(pos,1));\n      c.pb(mp(pos-1,1));\n      c.pb(mp(pos-1,0));\n      pos-=1;\n    }\n  }\n  while (pos>0) {\n    pos--;\n    c.pb(mp(pos,0));\n  }\n  assert(SZ(c)<=250000);\n  printf(\"%d\\n\",SZ(c)-1);\n  for (auto x:c) printf(\"%d %d\\n\",x.fi,x.se);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nint n;\nchar s[1010];\nvector<PII> ans,c,trash;\nvector<PII> build(VI w) {\n\tif (SZ(w)==1) return vector<PII>{{w[0],0}};\n\tvector<PII> z{{w[0],0},{w[1],0},{w[0],1},{w[1],1}};\n\trep(i,2,SZ(w)) {\n\t\tvector<PII> nz=z; \n\t\tz.pb({w[i],0});\n\t\treverse(all(nz));\n\t\tfor (auto p:nz) z.pb({p.fi,p.se^1});\n\t\tz.pb({w[i],1});\n\t}\n\treturn z;\n}\nint zz;\nint main() {\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s);\n\t//rep(i,0,(1<<n)) s[i]=(__builtin_popcount(i)<5)+'0';\n\trep(i,0,(1<<n)) if (s[i]=='0') {\n\t\trep(j,0,(1<<n)) if ((j&i)==i&&s[j]=='1') {\n\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\t\tbool cc=0;\n\t\trep(j,0,(1<<n)) if ((i&j)==j&&i!=j&&s[j]=='0') cc=1;\n\t\tif (cc) continue;\n\t\tVI w;\n\t\tfprintf(stderr,\"%d\\n\",i);\n\t\trep(j,0,n) if (i&(1<<j)) w.pb(j);\n\t\tauto x=build(w);\n\t\tfor (auto p:x) ans.pb(p);\n\t\tzz++;\n\t\t//rep(i,0,n) ans.pb(mp(i,0)),trash.pb(mp(i,0));\n\t\trep(i,0,100) {\n\t\t\tint x=rnd(n);\n\t\t\tans.pb(mp(x,(SZ(w)>=2))),trash.pb(mp(x,(SZ(w)>=2)));\n\t\t}\n\t}\n\t//fprintf(stderr,\"%d\\n\",zz);\n\treverse(all(trash));\n\tfor (auto p:trash) ans.pb(mp(p.fi,p.se^1));\n // rep(i,0,zz) per(j,0,n) ans.pb(mp(j,-1));\n\trep(i,0,(1<<n)) {\n\t\tstack<PII> s;\n\t\tfor (auto x:ans) {\n\t\t\tif (!(i&(1<<x.fi))) continue;\n\t\t\tif (!s.empty()&&s.top().fi==x.fi&&s.top().se==(x.se^1)) s.pop();\n\t\t\telse s.push(x);\n\t\t}\n\n\t\tif (s.empty()!=(::s[i]=='1')) {\n\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tint pos=0;\n\tc.pb(mp(0,0));\n\tfor (auto p:ans) {\n\t\t//printf(\"pp %d %d\\n\",p.fi,p.se);\n\t\tif (p.se==0) {\n\t\t\twhile (pos<p.fi) {\n\t\t\t\tpos+=1;\n\t\t\t\tc.pb(mp(pos,0));\n\t\t\t}\n\t\t\twhile (pos>p.fi) {\n\t\t\t\tpos-=1;\n\t\t\t\tc.pb(mp(pos,0));\n\t\t\t}\n\t\t\tc.pb(mp(pos,1));\n\t\t\tc.pb(mp(pos+1,1));\n\t\t\tc.pb(mp(pos+1,0));\n\t\t\tpos+=1;\n\t\t} else {\n\t\t\twhile (pos<p.fi+1) {\n\t\t\t\tpos+=1;\n\t\t\t\tc.pb(mp(pos,0));\n\t\t\t}\n\t\t\twhile (pos>p.fi+1) {\n\t\t\t\tpos-=1;\n\t\t\t\tc.pb(mp(pos,0));\n\t\t\t}\n\t\t\tc.pb(mp(pos,1));\n\t\t\tc.pb(mp(pos-1,1));\n\t\t\tc.pb(mp(pos-1,0));\n\t\t\tpos-=1;\n\t\t}\n\t}\n\twhile (pos>0) {\n\t\tpos--;\n\t\tc.pb(mp(pos,0));\n\t}\n\tassert(SZ(c)<=250000);\n\tprintf(\"%d\\n\",SZ(c)-1);\n\tfor (auto x:c) printf(\"%d %d\\n\",x.fi,x.se);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:1000000000\")\n#pragma GCC optimize(\"Ofast,no-stack-protector\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <algorithm>\n#include <memory.h>\n#include <cassert>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <cmath>\n#include <ctime>\n#include <random>\n#include <bitset>\n#include <limits.h>\n#include <fstream>\n\n#define mp make_pair\n#define all(a) (a).begin(), (a).end()\n#define pll pair <ll, ll>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef double ld;\n#define uint unsigned int\n\nconst int maxlog = 8;\nconst int maxn = (1 << 8);\n\nint a[maxn];\nchar s[maxn];\n\nvector <pii> ans;\n\nvoid go(int &x, int &y, int dx, int dy) {\n\tx += dx;\n\ty += dy;\n\tans.push_back(mp(x, y));\n}\n\nint main() {\n\tint n;\n\n\tcin >> n;\n\tcin >> s;\n\n\tfor (int i = 0; i < (1 << n); i++) {\n\t\ta[i] = s[i] - '0';\n\t}\n\n\tfor (int i = (1 << n) - 1; i >= 0; i--) {\n\t\tif (a[i] == 0) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif ((i >> j) & 1) {\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (a[i | (1 << j)] == 1) {\n\t\t\t\t\t\tcout << \"Impossible\\n\";\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < (1 << n); i++) {\n\t\tif (a[i] == 1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tbool good = false;\n\t\tint cnt = 0;\n\n\t\tfor (int j = 0; j < (1 << i); j++) {\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tcnt++;\n\t\t\t\tif (a[i ^ (1 << j)] == 1) {\n\t\t\t\t\tgood = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (good && cnt > 3) {\n\t\t\tcout << \"Impossible\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (a[0] == 0) {\n\t\tcout << \"Impossible\\n\";\n\t\treturn 0;\n\t}\n\n\tans.push_back(mp(0, 0));\n\n\tfor (int i = 0; i < (1 << n); i++) {\n\t\tif (a[i] == 1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvector <int> p;\n\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tp.push_back(j);\n\t\t\t}\n\t\t}\n\n\t\tif ((int)p.size() > 2) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tint x = 0, y = 0;\n\n\t\tgo(x, y, 0, 1);\n\n\t\twhile (x < p[0]) {\n\t\t\tgo(x, y, 1, 0);\n\t\t}\n\n\t\tgo(x, y, 0, -1);\n\t\tgo(x, y, 1, 0);\n\t\tgo(x, y, 0, 1);\n\n\t\tif ((int)p.size() == 1) {\n\t\t\twhile (x > 0) {\n\t\t\t\tgo(x, y, -1, 0);\n\t\t\t}\n\n\t\t\tgo(x, y, 0, -1);\n\t\t}\n\t\telse {\n\t\t\twhile (x < p[1]) {\n\t\t\t\tgo(x, y, 1, 0);\n\t\t\t}\n\n\t\t\tgo(x, y, 0, -1);\n\t\t\tgo(x, y, 1, 0);\n\t\t\tgo(x, y, 0, 1);\n\t\t\twhile (x > p[0] + 1) {\n\t\t\t\tgo(x, y, -1, 0);\n\t\t\t}\n\n\t\t\tgo(x, y, 0, -1);\n\t\t\tgo(x, y, -1, 0);\n\t\t\tgo(x, y, 0, 1);\n\t\t\twhile (x < p[1] + 1) {\n\t\t\t\tgo(x, y, 1, 0);\n\t\t\t}\n\n\t\t\tgo(x, y, 0, -1);\n\t\t\tgo(x, y, -1, 0);\n\t\t\tgo(x, y, 0, 1);\n\n\t\t\twhile (x > 0) {\n\t\t\t\tgo(x, y, -1, 0);\n\t\t\t}\n\n\t\t\tgo(x, y, 0, -1);\n\t\t}\n\t}\n\n\tcout << \"Possible\\n\";\n\tcout << (int)ans.size() - 1 << '\\n';\n\n\tfor (auto[x, y] : ans) {\n\t\tcout << x << ' ' << y << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\n\ntemplate <class T1, class T2>\nostream& operator << (ostream& out, const pair <T1, T2> p)\n{\n    out << '(' << p.first << ',' << p.second << ')';\n    return out;\n}\n\ntemplate <class T1, class T2>\nistream& operator >> (istream& in, pair<T1, T2> &p)\n{\n    in >> p.first >> p.second;\n    return in;\n}\n\ntemplate <class T>\nistream& operator >> (istream& in, vector<T> &v)\n{\n    for (T &x : v)\n        in >> x;\n    return in;\n}\n\ntemplate <class T>\nostream& operator << (ostream& out, const vector<vector<T>> &v)\n{\n    for (const vector<T> &x : v)\n        out << x << '\\n';\n    return out;\n}\n\ntemplate <class T>\nostream& operator << (ostream& out, const vector<T> &v)\n{\n    for (const T &x : v)\n        out << x << ' ';\n    return out;\n}\n\nlong long gcd (long long a, long long b)\n{\n    if (b > a)\n        swap(a, b);\n    return (b ? gcd(b, a % b) : a);\n}\n\nusing ll   = long long;\nusing pii  = pair<int, int>;\nusing pll  = pair<long long, long long>;\nusing tiii = pair<pair<int, int>, int>;\nusing vi   = vector<int>;\nusing vl   = vector<long long>;\nusing vvi  = vector<vector<int>>;\nusing vvl  = vector<vector<long long>>;\n\n#define F          first\n#define S          second\n#define First      first.first\n#define Second     first.second\n#define Third      second\n#define mp         make_pair\n#define rep(i,a,b) for (int i = (a); i < (b); i++)\n#define per(i,b,a) for (int i = (b); i > (a); i--)\n#define all(x)     x.begin(), x.end()\n#define ret(x)     return cout << x, 0;\n#define throwex    throw runtime_error (\"Found the error.\");\n\nconst int h = 1000000007;\n\nint n;\nvector<pii> get_cycle(int mask, int cur = 0)\n{\n    int last_1_index = n - 1;\n    int z = (mask & -mask);\n    while(z != 1)\n        last_1_index--, z /= 2;\n    vector<pii> ans;\n    if(cur == last_1_index)\n    {\n        ans.push_back({cur, 1});\n        ans.push_back({cur+1, 1});\n        ans.push_back({cur+1, 0});\n        ans.push_back({cur, 0});\n        ans.push_back({cur, 1});\n        return ans;\n    }\n    ans.push_back({cur, 1});\n    vector<pii> next_cycle = get_cycle(mask, cur + 1);\n    ans.insert(ans.end(), all(next_cycle));\n    ans.push_back({cur, 1});\n    if((mask & (1 << (n - 1 - cur))))\n    {\n        ans.push_back({cur, 0});\n        ans.push_back({cur+1, 0});\n        reverse(all(next_cycle));\n        ans.insert(ans.end(), all(next_cycle));\n        ans.push_back({cur, 1});\n    }\n    return ans;\n}\n\nsigned main()\n{\n    ios::sync_with_stdio(false);\n    #ifdef ONLINE_JUDGE\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    cerr.setstate(ios::failbit);\n    #endif\n\n    cin >> n;\n    string a;\n    cin >> a;\n    rep(i,0,1 << n)\n    {\n        rep(j,0,i)\n        {\n            if((j | i) == i and a[i] == '1' and a[j] == '0')\n                ret(\"Impossible\");\n        }\n    }\n    vector<pii> ans;\n    ans.push_back({0, 1});\n    rep(i,0,1 << n)\n    {\n        if(a[i] == '0')\n        {\n            vector<pii> cycle = get_cycle(i);\n            ans.insert(ans.end(), cycle.begin() + 1, cycle.end());\n            for(int j = i; j < (1 << n); j++)\n                if((i | j) == j)\n                    a[j] = '1';\n            cerr << cycle << '\\n';\n        }\n    }\n    assert(ans.size() <= 250000);\n    cout << \"Possible\\n\";\n    cout << ans.size() - 1 << '\\n';\n    for(pii x : ans)\n        cout << x.F << ' ' << x.S << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <bitset>\n#include <random>\n#include <complex>\n#include <assert.h>\n\nusing namespace std;\ntypedef long long ll;\n\ntemplate<typename T>\ninline bool chmin(T& x, T a) {\n\tif (x >= a) { x = a; return true; }\n\treturn false;\n}\n\ntemplate<typename T>\ninline bool chmax(T& x, T a) {\n\tif (x <= a) { x = a; return true; }\n\treturn false;\n}\n\nint main() {\n\tint N; cin >> N;\n\tint size = 1 << N;\n\tvector<bool> v(size, false);// 和が0になるかどうか\n\n\tfor (int i = 0; i < size; i++) {\n\t\tchar c; cin >> c;\n\t\tv[i] = (c == '1');\n\t}\n\n\tvector<int> num(N);\n\n\tfor (int i = 0; i < N; i++) {\n\t\tif (v[1 << i]) {\n\t\t\tnum[i] = 0;\n\t\t}\n\t\telse {\n\t\t\tnum[i] = 1;\n\t\t}\n\t}\n\tfor (int q = 0; q < 100; q++) {\n\t\tfor (int i = 1; i < size; i++) {\n\t\t\tint k;\n\t\t\tif (i >= 1) { k = 0; }\n\t\t\tif (i >= 2) { k = 1; }\n\t\t\tif (i >= 4) { k = 2; }\n\t\t\tif (i >= 8) { k = 3; }\n\t\t\tif (i >= 16) { k = 4; }\n\t\t\tif (i >= 32) { k = 5; }\n\t\t\tif (i >= 64) { k = 6; }\n\t\t\tif (i >= 128) { k = 7; }\n\t\t\tif (i >= 256) { k = 8; }\n\t\t\tint j = i - (1 << k);\n\t\t\tint sum = 0;\n\t\t\tfor (int p = 0; p < N; p++) {\n\t\t\t\tif (j & (1 << p)) {\n\t\t\t\t\tsum += num[p];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (v[i] == true) {\n\t\t\t\tnum[k] = -sum;\n\t\t\t}\n\t\t\telse if (sum + num[k] == 0) {\n\t\t\t\tnum[k]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < size; i++) {\n\t\tint sum = 0;\n\t\tfor (int k = 0; k < N; k++) {\n\t\t\tif (i & k) {\n\t\t\t\tsum += num[k];\n\t\t\t}\n\t\t}\n\t\tif (v[i] == true && sum != 0) { cout << \"Impossible\" << endl; return 0; }\n\t\tif (v[i] == false && sum == 0) { cout << \"Impossible\" << endl; return 0; }\n\t}\n\n\tvector<pair<int, int>> ans;\n\tfor (int i = 0; i < N; i++) {\n\t\twhile (num[i] > 0) {\n\t\t\tans.push_back({ i, 0 });\n\t\t\tans.push_back({ i + 1, 0 });\n\t\t\tans.push_back({ i + 1, 1 });\n\t\t\tans.push_back({ i, 1 });\n\t\t\tans.push_back({ i, 0 });\n\t\t\tnum[i]--;\n\t\t}\n\t\twhile (num[i] < 0) {\n\t\t\tans.push_back({ i, 0 });\n\t\t\tans.push_back({ i, 1 });\n\t\t\tans.push_back({ i + 1, 1 });\n\t\t\tans.push_back({ i + 1, 0 });\n\t\t\tans.push_back({ i, 0 });\n\t\t\tnum[i]--;\n\t\t}\n\t}\n\tans.push_back({ 0,0 });\n\n\tcout << \"Possible\" << endl;\n\tcout << ans.size() - 1;\n\tfor (auto itr = ans.begin(); itr != ans.end(); itr++) {\n\t\tcout << itr->first << \" \" << itr->second << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifdef __LOCAL\n    #define DBG(X) cout << #X << \" = \" << (X) << endl;\n    #define SAY(X) cout << (X) << endl;\n#else\n    #define DBG(X)\n    #define SAY(X)\n#endif\n\n#ifdef __LOCAL\n    #include <filesystem>\n    namespace fs = std::filesystem;\n#endif\n\nusing namespace std;\n\nusing ll = long long int;\nusing ull = unsigned long long int;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\nint dx[]={1, 0, -1, 0, 1,-1, 1,-1};\nint dy[]={0, 1, 0, -1, 1, 1,-1,-1};\nconst int INT_INF = (int)(2e9);\nconst ll  LL_INF = (ll)(2e18);\nstatic mt19937 _g(time(nullptr));\n \ninline ll randint(ll a, ll b) { ll w = (_g() << 31LL) ^ _g(); return a + w % (b - a + 1); }\ninline void fast_io() { ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); };\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const pair<T, S> p) { cout << \"[\" << p.first << \";\" << p.second << \"]\"; return os; }\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const map<T, S> p) { for (auto el : p) cout << \"[\" << el.first << \";\" << el.second << \"]\"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const vector<T>& v) { for (auto el : v) cout << el << \" \"; return os; }\ntemplate<typename T> inline vector<T> fetch_vec(int sz) { vector<T> ret(sz); for (auto& elem : ret) cin >> elem; return ret; }\n\nint N;\nstring A;\nvoid input(){\n    fast_io();\n    #ifdef __LOCAL\n        fs::path p = __FILE__;\n        fs::path input,output;\n        input = output = p.parent_path();\n        input += string(\"/input/\") + string(p.stem()) + string(\".txt\");\n        output += string(\"/output/\") + string(p.stem()) + string(\".txt\");\n        freopen(input.c_str(), \"r\", stdin);\n        freopen(output.c_str(), \"w\", stdout);\n    #endif\n    cin >> N;\n    cin >> A;\n}\n\nint high,low;\n\nbool isOK(ll bit){\n    string bitstr = bitset<10>(bit).to_string();\n    bool ishole = false;\n    bool issecvoid = false;\n    bool issechole = false;\n    for (int i = 0; i < 10; i++)\n    {\n        if(bitstr[i]=='0'){\n            if(ishole){\n                issecvoid = true;\n                low = 10-(i-1);\n            }\n        }\n        if(bitstr[i]=='1'){\n            if(!ishole) high = 10-i;\n            if(issecvoid) return false;\n            ishole=true;\n            }\n    }\n    if(!issecvoid) low=0;\n    return true;\n}\n\nint solve(){\n    if(A[0]=='0'){cout << \"Impossible\" << endl; return 0;}\n    ll bitA=0LL;\n    for (int i = 0; i < N; i++)\n    {\n        bitA |= (A[(1<<i)]=='0');\n    }\n    if(!isOK(bitA)){cout << \"Impossible\" << endl; return 0;}\n    for (int bit = 0; bit < (1<<N); bit++)\n    {\n        if((bitA&bit)==bit) continue;\n        else{cout << \"Impossible\" << endl; return 0;}\n    }\n    ll L=2+2*(high-low);\n    cout << \"Possible\" << endl;\n    cout << L << endl;\n    cout << low  << \" \" << 0 << endl;    \n    cout << high << \" \" << 0 << endl;    \n    cout << high << \" \" << 1 << endl;    \n    cout << low  << \" \" << 1 << endl;    \n    \n    return 0;\n}   \n\nint main()\n{\n    input();\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\nint main() {\n\tint n = nxt();\n\tstring s;\n\tcin >> s;\n\tif (s == string(1 << n, '1')) {\n\t\tcout << \"Possible\\n\";\n\t\tcout << \"0\\n0 0\\n\";\n\t\treturn 0;\n\t}\n\tif (s[0] == '0') {\n\t\tcout << \"Impossible\\n\";\n\t\treturn 0;\n\t}\n\tconst int N = 1 << n;\n\tvector<char> base(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (__builtin_popcount(i) >= 3 && s[i] == '1') {\n\t\t\tcout << \"Impossible\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (s[i] == '0') {\n\t\t\tbase[i] = 1;\n\t\t\tfor (int j = i; j > 0; j = (j - 1) & i) {\n\t\t\t\tif (s[i ^ j] == '0') {\n\t\t\t\t\tbase[i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int j = i; j > 0; j = (j - 1) & i) {\n\t\t\tif (s[i ^ j] == '0') {\n\t\t\t\tcout << \"Impossible\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<int> ans;\n\tfunction<void(int, bool)> add = [&](int mask, bool rev) {\n\t\tassert(mask);\n\t\tif (__builtin_popcount(mask) == 1) {\n\t\t\tans.push_back(rev ? -__builtin_ctz(mask) - 1 : __builtin_ctz(mask) + 1);\n\t\t\treturn;\n\t\t}\n\t\tint nm = mask ^ (1 << (__builtin_ctz(mask)));\n\t\tif (rev) {\n\t\t\tadd(nm, true);\n\t\t\tans.push_back(__builtin_ctz(mask) + 1);\n\t\t\tadd(nm, false);\n\t\t\tans.push_back(-__builtin_ctz(mask) - 1);\n\t\t} else {\n\t\t\tadd(nm, false);\n\t\t\tans.push_back(-__builtin_ctz(mask) - 1);\n\t\t\tadd(nm, true);\n\t\t\tans.push_back(__builtin_ctz(mask) + 1);\n\t\t}\n\t};\n\tfor (int mask = 0; mask < N; ++mask) {\n\t\tif (base[mask]) {\n\t\t\tadd(mask, false);\n\t\t}\n\t}\n\tint y = 0;\n\tvector<pair<int, int>> answer = {{0, y}};\n\tauto go = [&](int c) {\n\t\twhile (y < c) {\n\t\t\ty += 1;\n\t\t\tanswer.push_back({0, y});\n\t\t}\n\t\twhile (y > c) {\n\t\t\ty -= 1;\n\t\t\tanswer.push_back({0, y});\n\t\t}\n\t};\n\n\tfor (int i : ans) {\n\t\tif (i < 0) {\n\t\t\tgo(-i - 1);\n\t\t\tanswer.push_back({1, y});\n\t\t\tanswer.push_back({1, y + 1});\n\t\t\tanswer.push_back({0, y + 1});\n\t\t\ty += 1;\n\t\t} else {\n\t\t\tgo(i);\n\t\t\tanswer.push_back({1, y});\n\t\t\tanswer.push_back({1, y - 1});\n\t\t\tanswer.push_back({0, y - 1});\n\t\t\ty -= 1;\n\t\t}\n\t}\n\tgo(0);\n\tcout << \"Possible\\n\";\n\tcout << (int)answer.size() - 1 << \"\\n\";\n\tfor (const auto& p : answer) {\n\t\tcout << p.second << \" \" << p.first << \"\\n\";\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nstring A;\n\nbool isValid(int msk) {\n    for (int x = 0; x < (1<<n); x++) {\n        if (A[x]=='1') {\n            if (x&msk) return false;\n        } else {\n            if ((x&msk)==0) return false;\n        }\n    }\n    return true;\n}\n\ntypedef pair< int , int >PII;\nvoid printSolution(int msk) {\n    vector< PII >vp;\n    for (int i = 0; i < n; i++) {\n        vp.emplace_back(i, 0);\n        if (msk&(1<<i)) {\n            vp.emplace_back(i, 1);\n            vp.emplace_back(i+1, 1);\n        }\n    }\n    for (int i = n; i >= 0; i--) vp.emplace_back(i, 0);\n\n    cout << \"Possible\" << endl;\n    cout << vp.size()-1 << endl;\n    for (PII p : vp) cout << p.first << \" \" << p.second << endl;\n}\n\nint main() {\n    cin >> n;\n    cin >> A;\n\n    for (int msk = 0; msk < (1<<n); msk++) {\n        if (isValid(msk)) {\n            printSolution(msk);\n            return 0;\n        }\n    }\n\n    cout << \"Impossible\" << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <string>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> Pii;\n\nconst ll mod = 1000000007;\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  string s;\n  cin >> s;\n\n  vector<bool> a(1 << n);\n  for (int i = 0; i < (1 << n); i++) a[i] = s[i] - '0';\n\n  for (int i = 0; i < (1 << n); i++) {\n    bool good = true;\n    for (int j = 0; j < (1 << n); j++) {\n      bool obscured = false;\n      for (int k = 0; k < n; k++) {\n        bool point = j & (1 << k);\n        if (point && (i & (1 << k))) {\n          obscured = true;\n          break;\n        }\n      }\n      if (obscured == a[j]) {\n        good = false;\n        break;\n      }\n    }\n    if (good) {\n      vector<Pii> loop;\n      bool up = false;\n      for (int j = 0; j < n; j++) {\n        if (!up) {\n          loop.emplace_back(j, 0);\n          if (i & (1 << j)) {\n            loop.emplace_back(j, 1);\n            up = true;\n          }\n        }\n        else {\n          loop.emplace_back(j, 1);\n          if (!(i & (1 << j))) {\n            loop.emplace_back(j, 0);\n            up = false;\n          }\n        }\n      }\n      if (up) loop.emplace_back(n, 1);\n      for (int j = n; j >= 0; j--) loop.emplace_back(j, 0);\n\n      cout << \"Possible\" << endl;\n      cout << loop.size() - 1 << endl;\n      for (auto &x: loop) cout << x.first << \" \" << x.second << endl;\n      return 0;\n    }\n  }\n\n  cout << \"Impossible\" << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#pragma GCC optimize(\"Ofast\")\n\n#define fi first\n#define se second\n\nconst int N = 9;\n\nusing namespace std;\n\nint n;\nint b[N];\nint a[1 << N];\nint c[1 << N];\n\nvoid solve(int mask)\n{\n        for(int i = 0; i < n; i++) b[i] = (mask >> i) & 1;\n\n        for(int i = 0; i < (1 << n); i++){\n                c[i] = 1;\n                for(int j = 0; j < n; j++){\n                        if(i & (1 << j)) c[i] &= b[j];\n                }\n                if(c[i] != a[i]) return;\n        }\n        cout << \"Possible\" << \"\\n\";\n        vector < pair < int, int > > res;\n        for(int i = 0; i <= n; i++){\n                res.push_back({i, 0});\n        }\n        for(int i = n - 1; i >= 0; i--){\n                if(b[i]){\n                        res.push_back({i, 0});\n                } else{\n                        res.push_back({i + 1, 1});\n                        res.push_back({i, 1});\n                        res.push_back({i, 0});\n                }\n        }\n        cout << res.size() - 1 << \"\\n\";\n        for(auto p: res) cout << p.fi << \" \" << p.se << \"\\n\";\n\n        exit(0);\n}\n\nint main()\n{\n        //freopen(\"input.txt\", \"r\", stdin);\n        //freopen(\"output.txt\", \"w\", stdout);\n\n        ios_base::sync_with_stdio(0);\n\n        cin >> n;\n        for(int i = 0; i < (1 << n); i++){\n                char c;\n                cin >> c;\n                a[i] = c - '0';\n        }\n\n        for(int i = 0; i < (1 << n); i++) solve(i);\n\n        cout << \"Impossible\" << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define I inline\n#define fi first\n#define se second\n#define R register\n#define LL long long\n#define mp make_pair\n#define reg register int\n#define pii pair<int,int>\n#define fo(i, a, b) for(reg i = a; i <= b; i++)\n#define fd(i, a, b) for(reg i = a; i >= b; i--)\n#define cr const reg&\nusing namespace std;\n\nI int _max(cr x, cr y) {return x > y ? x : y;}\nI int _min(cr x, cr y) {return x < y ? x : y;}\nI int read() {\n\treg x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n\treturn x * f;\n}\nI void ptt(LL x) {if(x >= 10) ptt(x / 10); putchar(x % 10 + '0');}\nI void put(LL x) {x < 0 ? putchar('-'), ptt(-x) : ptt(x);}\nI void pr1(LL x) {put(x), putchar(' ');}\nI void pr2(LL x) {put(x), puts(\"\");}\n\nchar ss[1 << 8];\nvector<pii> ans;\n\nstring rev(string s) {\n\treverse(s.begin(), s.end());\n\treturn s;\n}\n\nint main() {\n\treg n = read();\n\tscanf(\"%s\", ss);\n\tif(ss[0] == '0') {puts(\"Impossible\"); return 0;}\n\treg S = (1 << n) - 1;\n\tfo(i, 1, S) {\n\t\tif(ss[i] == '1') {\n\t\t\tfo(j, 0, n - 1) if(i >> j & 1) {\n\t\t\t\tif(ss[i ^ (1 << j)] == '0') {puts(\"Impossible\"); return 0;}\n\t\t\t}\n\t\t}\n\t} puts(\"Possible\");\n\treg now = 0; ans.push_back(pii{0, 0});\n\tfo(i, 1, S) if(ss[i] == '0'){\n\t\tbool bk = 0;\n\t\tfo(j, 0, n - 1) if(i >> j & 1) {\n\t\t\tif(ss[i ^ (1 << j)] == '0') {bk = 1; break;}\n\t\t} if(bk) break;\n\t\tstring q; q.clear();\n\t\tfd(j, n - 1, 0) if(i >> j & 1){\n\t\t\tstring c1 = {char('a' + j)}, c2 = {char('A' + j)};\n\t\t\tif(q.empty()) q += c1 + c2;\n\t\t\telse q = c1 + q + c2 + rev(q);\n\t\t} for(char c : q) {\n\t\t\treg p, o;\n\t\t\tif(isupper(c)) p = c - 'A', o = 1;\n\t\t\telse p = c - 'a', o = 0;\n\t\t\tfo(j, now + 1, p) ans.push_back(pii{j, 0});\n\t\t\tfd(j, now - 1, p) ans.push_back(pii{j, 0});\n\t\t\tnow = p;\n\t\t\tif(!o) {\n\t\t\t\tans.push_back(pii{p, 1});\n\t\t\t\tans.push_back(pii{p + 1, 1});\n\t\t\t\tans.push_back(pii{p + 1, 0});\n\t\t\t\tans.push_back(pii{p, 0});\n\t\t\t} else {\n\t\t\t\tans.push_back(pii{p + 1, 0});\n\t\t\t\tans.push_back(pii{p + 1, 1});\n\t\t\t\tans.push_back(pii{p, 1});\n\t\t\t\tans.push_back(pii{p, 0});\n\t\t\t}\n\t\t}\n\t} fd(j, now - 1, 0) ans.push_back(pii{j, 0});\n\tpr2((int)ans.size());\n\tfo(i, 0, (int)ans.size() - 1) pr1(ans[i].fi), pr2(ans[i].se);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <decimal/decimal>\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define rep(i, s, t) for (int i = s; i < int(t); ++i)\n\n#define sc\tscanf\n#define pr\tprintf\n#define ff\tfirst\n#define ss\tsecond\n#define mp\tmake_pair\n#define pb\tpush_back\n#define eb\templace_back\n#define range(c)\tc.begin(), c.end()\n#define lowbit(x)\t((x) & -(x))\n#define pop_count\t__builtin_popcount\n#define pop_count_64\t__builtin_popcountll\n#define tail_count\t__builtin_ctz\n#define tail_count_64\t__builtin_ctzll\n#define lead_count\t__builtin_clz\n#define lead_count_64\t__builtin_clzll\n\n#define TEMP template<typename\n#define CONST(type) constexpr type const\n\nTEMP... Ts> struct is_con { static CONST(bool) value = false; };\nTEMP... Ts> struct is_con<vector<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<list<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<deque<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<set<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<unordered_set<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<map<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<unordered_map<Ts...>> { static CONST(bool) value = true; };\n\nTEMP T1, typename T2> ostream& operator<<(ostream& os, pair<T1, T2> const& p) { return os << \"<\" << p.ff << \",\" << p.ss << \">\"; }\nTEMP T> typename enable_if<is_con<T>::value, ostream>::type& operator<<(ostream& os, T const& c) {\n\tos << \"{\";\n\tbool first = true;\n\tfor (auto const& x : c) {\n\t\tif (first) first = false;\n\t\telse os << \",\";\n\t\tos << \" \" << x;\n\t}\n\treturn os << \" }\";\n}\n\nTEMP T, typename... Ts> void dbg(T h, Ts... t) { cerr << \" \" << h; dbg<Ts...>(t...); }\ntemplate<> void dbg<int>(int x) { cerr << endl; }\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[ \"#__VA_ARGS__\" ] :\", dbg(__VA_ARGS__, 0)\n#else\n#define debug(...) 0\n#endif\n\nTEMP T, typename U> using ordered_map = tree<T, U, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\nTEMP T> using ordered_set = ordered_map<T, null_type>;\n\ntypedef long long i64;\ntypedef decimal::decimal128 i99;\ntypedef unsigned int u32;\ntypedef unsigned long long u64;\ntypedef float f32;\ntypedef double f64;\ntypedef long double f80;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<i64> vl;\n\nTEMP T> T& minn(T& lhs, T const& rhs) { return lhs = min(lhs, rhs); }\nTEMP T> T& maxx(T& lhs, T const& rhs) { return lhs = max(lhs, rhs); }\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n;\n\tstring a;\n\tcin >> n >> a;\n\tvi dp(1 << n);\n\trep(s, 0, 1 << n) dp[s] = a[s] == '0';\n\tdebug(dp);\n\t// rep(i, 0, n) rep(s, 0, 1 << n) if (s >> i & 1) dp[s] |= dp[s ^ 1 << i];\n\tdebug(dp);\n\tbool ok = true;\n\trep(s, 0, 1 << n) if (dp[s]) {\n\t\trep(t, 0, 1 << n) if ((t & s) == s) {\n\t\t\tok &= dp[t];\n\t\t}\n\t}\n\t// rep(s, 0, 1 << n) ok &= dp[s] ^ (a[s] == '1');\n\tvi clique;\n\trep(s, 0, 1 << n) if (dp[s]) {\n\t\tbool check = true;;\n\t\trep(t, 0, 1 << n) if (t != s && (s & t) == t) check &= !dp[t];\n\t\tif (check) clique.pb(s);\n\t}\n\tint tot = 0, cnt = 0;\n\tfor (int s : clique) {\n\t\tint x = pop_count(s);\n\t\tok &= x <= 2;\n\t\ttot |= s;\n\t}\n\tif (!ok) return cout << \"Impossible\" << endl, 0;\n\tcout << \"Possible\" << endl;\n\tdebug(clique);\n\tvector<pii> ans(1);\n\tfor (int s : clique) {\n\t\tif (s == lowbit(s)) {\n\t\t\tint x = tail_count(s);\n\t\t\trep(i, 1, x + 1) ans.eb(i, 0);\n\t\t\tans.eb(x + 1, 0);\n\t\t\tans.eb(x + 1, 1);\n\t\t\tans.eb(x, 1);\n\t\t\tfor (int i = x; i >= 0; --i) ans.eb(i, 0);\n\t\t} else {\n\t\t\tint x = tail_count(s);\n\t\t\ts ^= lowbit(s);\n\t\t\tint y = tail_count(s);\n\t\t\trep(i, 1, y + 1) ans.eb(i, 0);\n\t\t\tans.eb(y + 1, 0);\n\t\t\tans.eb(y + 1, 1);\n\t\t\tans.eb(y, 1);\n\t\t\tfor (int i = y; i >= x; --i) ans.eb(i, 0);\n\t\t\trep(i, x, y + 2) ans.eb(i, 1);\n\t\t\tfor (int i = y + 1; i > x; --i) ans.eb(i, 0);\n\t\t\tans.eb(x + 1, 1);\n\t\t\tans.eb(x, 1);\n\t\t\tfor (int i = x; i >= 0; --i) ans.eb(i, 0);\n\t\t}\n\t}\n\tcout << ans.size() - 1 << endl;\n\tfor (auto const& p : ans) cout << p.ff << \" \" << p.ss << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint N; char str[1 << 8];\nvector < int > pot;\nvector < int > operator +(vector < int > p , vector < int > q){p.insert(p.end() , q.begin() , q.end()); return p;}\n\nvector < int > build(int id , int x){\n\tif(id < (1 << (x + 1))) return vector < int >{x + 1 , -x - 1};\n\tvector < int > tmp = build(id , x + 1);\n\tif(!(id >> x & 1)) return vector < int >{x + 1} + tmp + vector < int >{x + 1};\n\tvector < int > rev = tmp; reverse(rev.begin() , rev.end());\n\treturn vector < int >{x + 1} + tmp + vector < int >{x + 1} + vector < int >{-x - 1} + rev + vector < int >{-x - 1};\n}\n\nint main(){\n\tscanf(\"%d %s\" , &N , str);\n\tfor(int i = 0 ; i < 1 << N ; ++i)\n\t\tif(str[i] == '1')\n\t\t\tfor(int j = 0 ; j < N ; ++j)\n\t\t\t\tif((i >> j & 1) && str[i ^ (1 << j)] != '1'){\n\t\t\t\t\tputs(\"Impossible\"); return 0;\n\t\t\t\t}\n\tfor(int i = 0 ; i < 1 << N ; ++i)\n\t\tif(str[i] == '0'){\n\t\t\tbool flg = 1;\n\t\t\tfor(int j = 0 ; j < N ; ++j)\n\t\t\t\tif((i >> j & 1) && str[i ^ (1 << j)] == '0')\n\t\t\t\t\tflg = 0;\n\t\t\tif(flg) pot = pot + build(i , 0);\n\t\t}\n\tputs(\"Possible\"); vector < pair < int , int > > node;\n\tint curx = 0 , cury = 0; node.push_back(make_pair(0 , 0));\n\tfor(int i = 0 ; i < pot.size() ; ++i){\n\t\tif(pot[i] < 0 && cury == 1) node.push_back(make_pair(curx , cury = 0));\n\t\tif(pot[i] > 0 && cury == 0) node.push_back(make_pair(curx , cury = 1));\n\t\tint t = abs(pot[i]) - 1;\n\t\tif(curx == t) node.push_back(make_pair(++curx , cury));\n\t\telse node.push_back(make_pair(--curx , cury));\n\t}\n\tif(cury) node.push_back(make_pair(0 , 0));\n\tprintf(\"%d\\n\" , node.size() - 1);\n\tfor(auto t : node) printf(\"%d %d\\n\" , t.first , t.second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define re register\n#define cs const\n\nusing std::cerr;\nusing std::cout;\nusing pii=std::pair<int,int>;\n#define fi first\n#define se second\n\nstd::string inv(std::string s){\n\tstd::string res=\"\";\n\tstd::reverse(s.begin(),s.end());\n\tfor(char c:s)\n\t\tif(isupper(c))res+=c-'A'+'a';\n\t\telse res+=c-'a'+'A';\n\treturn res;\n}\n\nint n;\nstd::string A;\n\nvoid Main(){\n\tstd::cin>>n>>A;\n\tif(A[0]=='0'){\n\t\tputs(\"Impossible\");\n\t\treturn ;\n\t}for(int re i=0;i<(1<<n);++i)\n\t\tif(A[i]=='1')for(int re j=i;j;j=i&(j-1))\n\t\t\tif(A[j]=='0'){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn ;\n\t\t\t}\n\tstd::vector<pii> p({{0,0}});\n\tfor(int re s=0;s<(1<<n);++s)if(A[s]=='0'){\n\t\tbool flag=true;\n\t\tfor(int re t=s&(s-1);t&&flag;t=s&(t-1))\n\t\t\tif(A[t]=='0')flag=false;\n\t\tif(!flag)continue;\n\t\tstd::string q;\n\t\tfor(int re i=0;i<n;++i)\n\t\t\tif(s&(1<<i)){\n\t\t\t\tif(q.empty())q+='a'+i;\n\t\t\t\telse q=(char)('a'+i)+q+(char)('A'+i)+inv(q);\n\t\t\t}\n\t\tint nw=0;\n\t\tfor(char c:q){\n\t\t\tint i,dir;\n\t\t\tif(isupper(c))\n\t\t\t\ti=c-'A',dir=0;\n\t\t\telse \n\t\t\t\ti=c-'a',dir=1;\n\t\t\tfor(int j=nw+1;j<=i;++j)\n\t\t\t\tp.push_back({j,0});\n\t\t\tfor(int j=nw-1;j>=i;--j)\n\t\t\t\tp.push_back({j,0});\n\t\t\tnw=i;\n//\t\t\tif(dir){\n\t\t\t\tp.push_back({i,1});\n\t\t\t\tp.push_back({i+1,1});\n\t\t\t\tp.push_back({i+1,0});\n\t\t\t\tp.push_back({i,0});\n//\t\t\t}else {\n//\t\t\t\tp.push_back({i+1,0});\n//\t\t\t\tp.push_back({i+1,1});\n//\t\t\t\tp.push_back({i,1});\n//\t\t\t\tp.push_back({i,0});\n//\t\t\t}\n\t\t}\n\t\tfor(int j=nw-1;~j;--j)\n\t\t\tp.push_back({j,0});\n\t}\n\tcout<<\"Possible\\n\"<<(p.size()-1)<<\"\\n\";\n\tfor(auto t:p)cout<<t.fi<<\" \"<<t.se<<\"\\n\";\n}\n\ninline void file(){\n#ifdef zxyoi\n\tfreopen(\"E.in\",\"r\",stdin);\n#endif\n}signed main(){file();Main();return 0;}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> rec(int x) {\n\tvector <int> sol;\n\tint pet = 1, bit;\n\tfor (bit = 0; (x&pet) == 0; bit++)\n\t\tpet = 1<<bit;\n\tif (pet == x) {\n\t\tsol.push_back(bit);\n\t\treturn sol;\n\t}\n\tvector<int> aux = sol  = rec(x^pet);\n\tsol.push_back(bit);\n\tfor (auto it = aux.rbegin(); it != aux.rend(); it++)\n\t\tsol.push_back(-*it);\n\tsol.push_back(-bit);\n\treturn sol;\n}\n\nstring tira(const vector<int> & par) {\n\tstring sol;\n\tfor (int x: par) {\n\t\tsol += string(abs(x),'R');\n\t\tif (x > 0) sol += \"URDL\";\n\t\telse sol += \"RULD\";\n\t\tsol += string(abs(x),'L');\n\t}\n\treturn sol;\n}\n\n\nint main() {\n  ios_base::sync_with_stdio(false); \n  cin.tie(nullptr); \n\n\tint n;\n\tcin >> n;\n\tstring s;\n\tcin >> s;\n\tint m = 1<<n;\n\tbool ok = true;\n\tvector<int> obs;\n\tfor (int i = 1; i < m; i++) {\n\t\tif (s[i] == '0') obs.push_back(i);\n\t\tfor (int j = i+1; j < m; j++) {\n\t\t\tint p = i, g = j;\n\t\t\tif (p > g) swap(p, g);\n\t\t\tif ((p&g) == p and s[p] == '0' and s[g] == '1') ok = false;\n\t\t}\n\t}\n\tif (!ok) cout << \"Impossible\" << endl;\n\telse {\n\t\tcout << \"Possible\" << endl;\n\t\tstring sol;\n\t\tfor (auto x: obs) \n\t\t\tsol += tira(rec(x));\n\t\tint k = sol.size();\n\t\tcout << k   << endl;\n\t\tint px = 0, py = 0; \n\t\tcout << px << \" \" << py << \"\\n\";\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tif (sol[i] == 'U') py++;\n\t\t\telse if (sol[i] == 'D') py--;\n\t\t\telse if (sol[i] == 'L') px--;\n\t\t\telse if (sol[i] == 'R') px++;\n\t\t\tcout << px << \" \" << py << \"\\n\";\n\t\t}\n\t}\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint N; char str[1 << 8];\nvector < int > pot;\nvector < int > operator +(vector < int > p , vector < int > q){p.insert(p.end() , q.begin() , q.end()); return p;}\n\nvector < int > build(int id , int x){\n\tif(id < (1 << (x + 1))) return vector < int > {x + 1 , -x - 1};\n\tvector < int > tmp = build(id , x + 1);\n\tif(!(id >> x & 1)) return vector < int >{x + 1} + tmp + vector < int >{x + 1};\n\tvector < int > rev = tmp; reverse(rev.begin() , rev.end());\n\treturn vector < int >{x + 1} + tmp + vector < int >{x + 1} + vector < int >{-x - 1} + tmp + vector < int >{-x - 1};\n}\n\nint main(){\n\tscanf(\"%d %s\" , &N , str);\n\tfor(int i = 0 ; i < 1 << N ; ++i)\n\t\tif(str[i] == '1')\n\t\t\tfor(int j = 0 ; j < 1 << i ; ++j)\n\t\t\t\tif((i >> j & 1) && str[i ^ (1 << j)] != '1'){\n\t\t\t\t\tputs(\"Impossible\"); return 0;\n\t\t\t\t}\n\tfor(int i = 0 ; i < 1 << N ; ++i)\n\t\tif(str[i] == '0'){\n\t\t\tbool flg = 1;\n\t\t\tfor(int j = 0 ; j < 1 << i ; ++j)\n\t\t\t\tif((i >> j & 1) && str[i ^ (1 << j)] == '0')\n\t\t\t\t\tflg = 0;\n\t\t\tif(flg) pot = pot + build(i , 0);\n\t\t}\n\tputs(\"Possible\"); vector < pair < int , int > > node;\n\tint curx = 0 , cury = 0; node.push_back(make_pair(0 , 0));\n\tfor(int i = 0 ; i < pot.size() ; ++i){\n\t\tif(pot[i] < 0 && cury == 1) node.push_back(make_pair(curx , cury = 0));\n\t\tif(pot[i] > 0 && cury == 0) node.push_back(make_pair(curx , cury = 1));\n\t\tint t = abs(pot[i]) - 1;\n\t\tif(curx == t) node.push_back(make_pair(++curx , cury));\n\t\telse node.push_back(make_pair(--curx , cury));\n\t}\n\tif(node.back() != make_pair(0 , 0)) node.push_back(make_pair(0 , 0));\n\tprintf(\"%d\\n\" , node.size() - 1);\n\tfor(auto t : node) printf(\"%d %d\\n\" , t.first , t.second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nint N;\nstring s;\n\nbool bad;\n\nvector <int> goal (int K, string cv)\n{\n    //cout << K << \" \" << cv << \"\\n\";\n    vector <int> ans;\n    if (K == 1)\n    {\n        if (cv[0] == '1')\n        {\n            if (cv[1] == '0')\n            {\n                ans.push_back(0);\n                ans.push_back(1);\n                return ans;\n            }\n            return ans;\n        }\n        if (cv[0] == '0')\n        {\n            if (cv[1] == '1')\n                bad = true;\n            // what?\n            return ans;\n        }\n    }\n\n    int cp = 1 << (K - 1);\n    for (int i = cp; i < 2 * cp; i++)\n    {\n        if (cv[i] > cv[i-cp])\n        {\n            bad = true;\n            return ans;\n        }\n    }\n\n    string rv = cv.substr(0, cp);\n    string lv = cv.substr(cp);\n    bool l0 = true;\n    for (int i = 0; i < cp; i++)\n    {\n        if (lv[i] == '1') l0 = false;\n    }\n\n    vector <int> rans = goal (K - 1, rv);\n\n    if (l0)\n    {\n        // throw the key\n        rans.push_back(K - 1);\n        rans.push_back(K);\n        return rans;\n    }\n    vector <int> lans = goal (K - 1, lv);\n\n    vector <int> god;\n    for (int i : rans)\n        god.push_back(i);\n    god.push_back(K);\n    god.push_back(K-1);\n    reverse (rans.begin(), rans.end());\n    for (int i : rans)\n        god.push_back(i);\n    god.push_back(K-1);\n    god.push_back(K);\n    for (int i : lans)\n        god.push_back(i);\n    return god;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n\n    cin >> N >> s;\n\n    bad = false;\n    vector <int> res = goal (N, s);\n    if (bad || s[0] == '0')\n    {\n        cout << \"Impossible\\n\";\n    }\n    else\n    {\n        cout << \"Possible\\n\";\n        if (!res.size())\n        {\n            cout << \"0\\n\";\n            cout << \"1 1\\n\";\n            return 0;\n        }\n        /*for (int i : res) cout << i;\n        cout << \"\\n\";*/\n        res.push_back(res[0]);\n\n        int ctot = 0;\n        for (int i = 0; i + 1 < res.size(); i++)\n        {\n            ctot += abs (res[i+1] - res[i]) + 1;\n        }\n\n        cout << ctot << \"\\n\";\n        for (int i = 0; i + 1 < res.size(); i++)\n        {\n            int cv = i % 2;\n            int nv = 1 - cv;\n            cout << res[i] << \" \" << cv << \"\\n\";\n            for (int j = res[i]; j < res[i+1]; j++)\n                cout << j << \" \" << nv << \"\\n\";\n            for (int j = res[i]; j > res[i+1]; j--)\n                cout << j << \" \" << nv << \"\\n\";\n        }\n        cout << res[0] << \" \" << 0 << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cctype>\n#include<vector>\n#define pb push_back\n#define put(x,y) ans.pb((P){x,y})\nusing namespace std;\n#define G getchar()\nint read()\n{\n\tint x=0; char ch=G;\n\tfor (;!isdigit(ch);ch=G);\n\tfor (;isdigit(ch);ch=G) x=(x<<3)+(x<<1)+(ch^48);\n\treturn x;\n}\n#undef G\n\nint n; char s[260];\ntypedef pair<int,int> P;\nvector<P> ans;\nvoid dfs(int x,int msk,bool rev){  //from the top 1 or bottom 0\n\tint tot=0,pos;\n\tfor (int i=n;i;i--) if (msk>>i-1&1) tot++,pos=i;\n//\tprintf(\"dfs %d %d %d  %d %d\\n\",x,msk,rev,tot,pos);\n\tfor (int i=x+1;i<pos;i++) ans.pb((P){i,1});\n\tif (tot==1){\n\t\tif (rev) put(pos,1),put(pos,0),put(pos-1,0);\n\t\telse put(pos-1,0),put(pos,0),put(pos,1);\n\t}\n\telse{\n\t\tif (rev){\n\t\t\tput(pos,1);\n\t\t\tdfs(pos,msk^(1<<pos-1),1);\n\t\t\tput(pos-1,1); put(pos-1,0); put(pos,0); put(pos,1);\n\t\t\tdfs(pos,msk^(1<<pos-1),0);\n\t\t\tput(pos,0); put(pos-1,0);\n\t\t}\n\t\telse{\n\t\t\tput(pos-1,0); put(pos,0); put(pos,1);\n\t\t\tdfs(pos,msk^(1<<pos-1),1);\n\t\t\tput(pos,0); put(pos-1,0); put(pos-1,1); put(pos,1);\n\t\t\tdfs(pos,msk^(1<<pos-1),0);\n\t\t}\n\t}\n\tfor (int i=pos-1;i>=x;i--) ans.pb((P){i,1});\n}\nint main()\n{\n\tscanf(\"%d%s\",&n,s);\n\tfor (int i=0;i<(1<<n);i++)\n\t\tfor (int j=0;j<(1<<n);j++)\n\t\t\tif ((i&j)==j&&s[j]=='0'&&s[i]=='1') return puts(\"Impossible\"),0;\n\tputs(\"Possible\");\n\tans.pb((P){0,1});\n\tfor (int i=0;i<(1<<n);i++){\n\t\tif (s[i]=='1') continue;\n\t\tint tot=0;\n\t\tfor (int j=0;j<(1<<n);j++)\n\t\t\tif ((i&j)==j&&s[j]=='0') tot++;\n\t\tif (tot^1) continue;\n//\t\tprintf(\"make %d\\n\",i);\n\t\tdfs(0,i,1);\n//\t\tprintf(\"size %d\\n\",(int)ans.size());\n\t}\n\tprintf(\"%d\\n\",(int)ans.size()-1);\n\tfor (int i=0;i<ans.size();i++) printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i = (begin); i < (end); i++)\n#define rep(i, n) FOR(i, 0, n)\nusing ll = long long;\nusing namespace std;\n#define all(x) (x).begin(),(x).end()\nusing pii = pair<int, int>; using vi = vector<int>; using vl = vector<ll>;\n\nint N;\n\nsigned main() {\n    cin >> N;\n    // unordered_set<int> oo, ii;\n    int oo(0), ii(0);\n    vi sss;\n    string as;\n    cin >> as;\n    bool first = true;\n    for(int i = N-1; i>=0; i--) {\n        // auto ss = setter(i);\n        if(first && as[i] == '1') {\n            oo = i;\n            first = false;\n        } else if (((oo | i) == oo && as[i] != '1') ||\n                   ((oo | i) != oo && as[i] == '1')) {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n        \n    }\n    // for(auto s : sss) {\n    //     if((oo&s) == s) {\n    //         cout << \"Impossible\" << endl;\n    //         return 0;\n    //     }\n    // }\n    \n    // if (Product(oo, ii).size() != 0) {\n    // if ((oo&ii) != 0) {\n    //     cout << \"Impossible\" << endl;\n    //     return 0;\n    // }\n    cout << \"Possible\" << endl;\n\n    ii = (1<<N) - oo - 1;\n    // cerr << oo << ' ' << ii << endl;\n    // cerr << (oo & ii) << endl;\n    vector<pii> p;\n    int before = 0;\n    // cerr << ii << endl;\n    p.push_back({0, 0});\n    rep(i, N) {\n        // cerr << ii << endl;\n        // cerr << ((ii&1) ^ before) << endl;\n        if((ii&1) ^ before) {\n            if(ii&1) {\n                if(i!=0) {\n                    p.push_back({i, 0});\n                }\n                p.push_back({i, 1});\n            } else {\n                p.push_back({i, 1});\n                if(i!=N-1)\n                    p.push_back({i, 0});\n            }\n        } else {\n            if(i!=0)\n                p.push_back({i, before});\n        }\n        before = ii & 1;\n        ii >>= 1;\n    }\n    if (before)\n        p.push_back({N, 1});\n    for(int k = N; k>=0; k--) {\n        p.push_back({k, 0});\n    }\n\n    cout << p.size() - 1 << endl;\n    for(auto pp : p) {\n        cout << pp.first << ' ' << pp.second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define fr first\n#define sc second\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n\nvector<P> ret;\n\nvoid pos(int i){\n\tfor(int j=0;j<i;j++){\n\t\tret.push_back(P(j+1,0));\n\t}\n\tret.push_back(P(i,1));\n\tret.push_back(P(i+1,1));\n\tret.push_back(P(i+1,0));\n\tret.push_back(P(i,0));\n\tfor(int j=i-1;j>=0;j--){\n\t\tret.push_back(P(j,0));\n\t}\n}\nvoid neg(int i){\n\tfor(int j=0;j<i;j++){\n\t\tret.push_back(P(j+1,0));\n\t}\n\tret.push_back(P(i+1,0));\n\tret.push_back(P(i+1,1));\n\tret.push_back(P(i,1));\n\tret.push_back(P(i,0));\n\tfor(int j=i-1;j>=0;j--){\n\t\tret.push_back(P(j,0));\n\t}\n}\n\t\n\nint main(){\n\tint n;\n\tstring s;\n\tcin>>n>>s;\n\t\n\tint a[300];\n\tfor(int i=0;i<(1<<n);i++)a[i]=s[i]-'0';\n\t\n\tbool used[300];\n\tmemset(used,0,sizeof used);\n\t\n\tint b[300];\n\tfor(int i=0;i<300;i++)b[i]=1;\n\t\n\tfor(int x=1;x<(1<<n);x++){\n\t\tused[x]=true;\n\t\t//if(used[x])cerr<<x<<endl;\n\t\tfor(int y=0;y<x;y++){\n\t\t\tif((x&y)==y)if(used[y])used[x]=false;\n\t\t}\n\t\t//if(used[x])cerr<<x<<endl;\n\t\tfor(int y=0;y<(1<<n);y++){\n\t\t\tif((x&y)==x)if(a[y]==1)used[x]=false;\n\t\t}\n\t\t//if(used[x])cerr<<x<<endl;\n\t\tif(used[x]){\n\t\t\tfor(int y=0;y<(1<<n);y++){\n\t\t\t\tif((x&y)==x)b[x]=0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool ok=true;\n\tfor(int i=0;i<(1<<n);i++)ok&=a[i]==b[i];\n\tif(!ok){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tret.push_back(P(0,0));\n\tfor(int x=0;x<(1<<n);x++){\n\t\tif(!used[x])continue;\n\t\tint cnt=0;\n\t\tint c[10];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif((x>>i)&1)c[cnt++]=i;\n\t\t}\n\t\tif(cnt==1){\n\t\t\tpos(c[0]);\n\t\t}\n\t\telse if(cnt==2){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[1]);\n\t\t}\n\t\telse if(cnt==3){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[2]);\n\t\t}\n\t\telse if(cnt==4){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tneg(c[3]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[3]);\n\t\t\tpos(c[2]);\n\t\t\tneg(c[3]);\n\t\t\tneg(c[2]);\n\t\t}\n\t\telse if(cnt==5){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[1]);\n\t\t\tpos(c[4]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[4]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tneg(c[3]);\n\t\t\tpos(c[0]);\n\t\t\tpos(c[4]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[4]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tpos(c[2]);\n\t\t}\n\t\telse if(cnt==6){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[1]);\n\t\t\tpos(c[4]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[4]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tneg(c[3]);\n\t\t\tpos(c[0]);\n\t\t\tpos(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[4]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[4]);\n\t\t\tneg(c[1]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tpos(c[2]);\n\t\t}\n\t\telse if(cnt==7){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[6]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[6]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[6]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[1]);\n\t\t\tpos(c[4]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[4]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[0]);\n\t\t\tpos(c[6]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[6]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tneg(c[3]);\n\t\t\tpos(c[0]);\n\t\t\tpos(c[6]);\n\t\t\tpos(c[6]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[6]);\n\t\t\tpos(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[4]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[4]);\n\t\t\tneg(c[1]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[0]);\n\t\t\tpos(c[6]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[6]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tpos(c[2]);\n\t\t}\n\t\telse if(cnt==8){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[6]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[6]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[6]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[1]);\n\t\t\tpos(c[7]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[7]);\n\t\t\t\n\t\t\tpos(c[4]);\n\t\t\tpos(c[7]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[7]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[4]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[0]);\n\t\t\tpos(c[6]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[6]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tneg(c[3]);\n\t\t\tpos(c[0]);\n\t\t\tpos(c[6]);\n\t\t\tpos(c[6]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[6]);\n\t\t\tpos(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[4]);\n\t\t\tpos(c[1]);\n\t\t\tpos(c[7]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[7]);\n\t\t\t\n\t\t\tneg(c[4]);\n\t\t\tpos(c[7]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[7]);\n\t\t\tneg(c[1]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[0]);\n\t\t\tpos(c[6]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[6]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tpos(c[2]);\n\t\t}\n\t}\n\t\n\t/*for(int i=0;i<n;i++){\n\t\tif(used[i][i]){\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t}\n\t\t\tret.push_back(P(i,1));\n\t\t\tret.push_back(P(i+1,1));\n\t\t\tret.push_back(P(i+1,0));\n\t\t\tret.push_back(P(i,0));\n\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\tret.push_back(P(j,0));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int k=i+1;k<n;k++){\n\t\t\tif(used[i][k]){\n\t\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(i,1));\n\t\t\t\tret.push_back(P(i+1,1));\n\t\t\t\tret.push_back(P(i+1,0));\n\t\t\t\tret.push_back(P(i,0));\n\t\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(k,1));\n\t\t\t\tret.push_back(P(k+1,1));\n\t\t\t\tret.push_back(P(k+1,0));\n\t\t\t\tret.push_back(P(k,0));\n\t\t\t\tfor(int j=k-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(i+1,0));\n\t\t\t\tret.push_back(P(i+1,1));\n\t\t\t\tret.push_back(P(i,1));\n\t\t\t\tret.push_back(P(i,0));\n\t\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(k+1,0));\n\t\t\t\tret.push_back(P(k+1,1));\n\t\t\t\tret.push_back(P(k,1));\n\t\t\t\tret.push_back(P(k,0));\n\t\t\t\tfor(int j=k-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}*/\n\t\n\tputs(\"Possible\");\n\tprintf(\"%d\\n\",(int)(ret.size())-1);\n\tfor(int i=0;i<ret.size();i++){\n\t\tprintf(\"%d %d\\n\",ret[i].fr,ret[i].sc);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define INF ((1<<30)-1)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nint n, a[1 << 8];\n\nbool valid(int x){\n    for(int i = 0;i < (1<<n);i++){\n        if(((i & x) == 0) != a[i])return false;\n    }\n    return true;\n}\n\nvoid show(int x){\n    vector<P> ps;\n    for(int i = 0;i < n;i++){\n        ps.push_back(P(i,0));\n        if((x >> i) % 2 == 1){\n            ps.push_back(P(i,1));\n            ps.push_back(P(i+1,1));\n        }\n    }\n    for(int i = n;i >= 0;i--)ps.push_back(P(i,0));\n    cout << ps.size() << endl;\n    for(int i = 0;i < ps.size();i++){\n        cout << ps[i].first << \" \" << ps[i].second << endl;\n    }\n}\n\nint main(){\n    cin  >> n;\n    for(int i = 0;i < (1 << n);i++){\n        scanf(\"%1d\", a + i);\n    }\n    int x = 0;\n    while(x < (1 << n) && !valid(x))x++;\n    if(x == (1 << n)){cout << \"Impossible\" << endl;return 0;}\n    cout << \"Possible\" << endl;\n   show(x);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(\"wzpakking\")\n#define y1 ysghysgsygsh\nusing namespace std;\nint n,top;\npii p[505];\nchar s[505];\nvoid construct(int x){\n\tp[++top]=pii(0,0);\n\tFor(i,0,n-1)\n\t\tif (x&(1<<i)){\n\t\t\tp[++top]=pii(i,1);\n\t\t\tp[++top]=pii(i+1,1);\n\t\t\tp[++top]=pii(i+1,0);\n\t\t}\n\t\telse\n\t\t\tp[++top]=pii(i+1,0);\n\tRep(i,n-1,1)\n\t\tp[++top]=pii(i,0);\n\tprintf(\"Possible\\n%d\\n\",top);\n\tFor(i,1,top)\n\t\tprintf(\"%d %d\\n\",p[i].fi,p[i].se);\n\tprintf(\"0 0\\n\");\n\texit(0);\n}\nint main(){\n\tscanf(\"%d%s\",&n,s);\n\tFor(i,0,(1<<n)-1){\n\t\tbool flg=0;\n\t\tFor(j,0,(1<<n)-1)\n\t\t\tif ((s[j]=='0')!=((i&j)!=0))\n\t\t\t\tflg=1;\n\t\tif (!flg)\n\t\t\tconstruct(i);\n\t}\n\tputs(\"Impossible\");\t\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\n\nconst int N = 8;\n\nint n;\nbool chk[N];\nstring s;\nvector<pair<int, int>> ve;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> n >> s;\n    for (int i = 0; i < n; i++) {\n        chk[i] = (s[1 << i] == '1');\n    }\n    for (int msk = 0; msk < (1 << n); msk++) {\n        int cur = 1;\n        for (int i = 0; i < n; i++) {\n            if (msk >> i & 1) {\n                cur &= chk[i];\n            }\n        }\n        if (cur != (s[msk] == '1')) {\n            return cout << \"Impossible\\n\", 0;\n        }\n    }\n    ve.push_back({0, 2}); ve.push_back({0, 1});\n    for (int i = 1; i <= n; i++) {\n        if (ve.back().se == !chk[i - 1]) {\n            ve.push_back({i - 1, chk[i - 1]});\n        }\n        ve.push_back({i, chk[i - 1]});\n    }\n    while (ve.back().se < 2) {\n        ve.push_back({n, ve.back().se + 1});\n    }\n    while (ve.back().fi > 0) {\n        ve.push_back({ve.back().fi - 1, 2});\n    }\n    cout << \"Possible\\n\" << ve.size() << '\\n';\n    for (pair<int, int>& cur : ve) {\n        cout << cur.fi << \" \" << cur.se << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define rrng(a) a.rbegin(),a.rend()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define eb emplace_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ntypedef vector<T> vt;\ninline int getInt() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define dame { puts(\"Impossible\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\nconst int MX = 200005;\n\nvp f(vi a) {\n  int x = a.back();\n  if (sz(a) == 1) {\n    vp res;\n    rep(i,x+2) res.eb(i,0);\n    drep(i,x+2) res.eb(i,1);\n    return res;\n  }\n  a.pop_back();\n  rep(i,sz(a)) a[i] -= x+1;\n  vp d = f(a);\n  rep(i,sz(d)) d[i].fi += x+1;\n  vp res;\n  rep(i,x+1) res.eb(i,0);\n  res.insert(res.end(), rng(d));\n  res.eb(x+1,0);\n  res.eb(x,0);\n  res.eb(x,1);\n  reverse(rng(d));\n  res.insert(res.end(), rng(d));\n  res.eb(x+1,1);\n  drep(i,x+1) res.eb(i,1);\n  return res;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  string st;\n  cin>>st;\n  int n2 = 1<<n;\n  vi a(n2);\n  rep(i,n2) a[i] = st[i]-'0';\n  rep(i,n2) a[i] ^= 1;\n  rep(i,n2) {\n    if (a[i]) continue;\n    for (int j = i;; j = (j-1)&i) {\n      if (a[j]) dame;\n      if (!j) break;\n    }\n  }\n  if (a[0]) dame;\n  cout<<\"Possible\"<<endl;\n  vp ans;\n  rep(i,n2) {\n    if (!a[i]) continue;\n    vi s;\n    rep(j,n) if (i>>j&1) s.pb(j);\n    reverse(rng(s));\n    vp now = f(s);\n    ans.insert(ans.end(), rng(now));\n  }\n  ans.eb(0,0);\n  cout<<sz(ans)-1<<endl;\n  for (P p : ans) {\n    cout<<p.fi<<\" \"<<p.se<<endl;\n  }\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int N=1<<10;\nint n;\nchar s[N];\nint p[N];\nvector<pair<int,int> > solve(int S,int now)\n{\n\tcerr<<\"Solve\"<<S<<\" \"<<now<<\"\\n\";\n\tvector<pair<int,int> >res;\n\tfor(int i=now+1;i<n;i++)\n\t\tif(S&(1<<i))\n\t\t{\n\t\t\tvector<pair<int,int> > t=solve(S,i);\n\t\t\tfor(int j=now;j<=i-1;j++)\n\t\t\t\tres.push_back(make_pair(j,1));\n\t\t\tfor(auto [x,y]:t)\n\t\t\t\tres.push_back(make_pair(x,y));\n\t\t\tfor(int j=i;j>=now;j--)\n\t\t\t\tres.push_back(make_pair(j,1));\n\t\t\tres.push_back(make_pair(now,0));\n\t\t\tres.push_back(make_pair(now+1,0));\n\t\t\tfor(int j=now+1;j<=i;j++)\n\t\t\t\tres.push_back(make_pair(j,1));\n\t\t\tfor(auto [x,y]:t)\n\t\t\t\tres.push_back(make_pair(x,y^1));\n\t\t\tfor(int j=i-1;j>=now+1;j--)\n\t\t\t\tres.push_back(make_pair(j,1));\n\t\t\tres.push_back(make_pair(now+1,0));\n\t\t\tres.push_back(make_pair(now,0));\n\t\t\treturn res;\n\t\t}\n\tres.push_back(make_pair(now,1));\n\tres.push_back(make_pair(now+1,1)); \n\tres.push_back(make_pair(now+1,0));\n\tres.push_back(make_pair(now,0));\n\tres.push_back(make_pair(now,1));\n\tres.push_back(make_pair(now+1,1));\n\tres.push_back(make_pair(now+1,0));\n\tres.push_back(make_pair(now,0));\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s);\n\tfor(int i=0;i<(1<<n);i++)\n\t\tp[i]=s[i]-'0';\n\tif(p[0]==0)\n\t{\n\t\tprintf(\"Impossible\");\n\t\treturn 0;\n\t}\n\tfor(int s=0;s<(1<<n);s++)\n\t\tif(p[s]==1)\n\t\t\tfor(int i=s;i;i=(i-1)&s)\n\t\t\t\tif(p[i]==0)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"Impossible\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\tvector<pair<int,int> >ans;\n\tans.push_back(make_pair(0,0));\n\tfor(int s=1;s<(1<<n);s++)\n\t\tif(p[s]==0)\n\t\t{\n\t\t\tbool flag=true;\n\t\t\tfor(int i=(s-1)&s;i;i=(i-1)&s)\n\t\t\t\tif(p[i]==0)\n\t\t\t\t{\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif(!flag) continue;\n\t\t\tvector<pair<int,int> >res;\n\t\t\tvector<pair<int,int> >t;\n\t\t\tint u=0;\n\t\t\tfor(u=0;u<n;u++)\n\t\t\t\tif(s&(1<<u))\n\t\t\t\t{\n\t\t\t\t\tt=solve(s,u);\n//\t\t\t\t\tcerr<<\"res\"<<\"\\n\";\n//\t\t\t\t\tfor(auto [x,y]:t)\n//\t\t\t\t\t\tcerr<<x<<\" \"<<y<<\"\\n\";\n//\t\t\t\t\tcerr<<\"EOF\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif(ans.back()!=make_pair(0,0)) res.push_back(make_pair(0,0));\n\t\t\tfor(int i=0;i<=u-1;i++)\n\t\t\t\tres.push_back(make_pair(i,1));\n\t\t\tfor(auto [x,y]:t)\n\t\t\t\tres.push_back(make_pair(x,y));\n\t\t\tfor(int i=u;i>=0;i--)\n\t\t\t\tres.push_back(make_pair(i,1));\n\t\t\tres.push_back(make_pair(0,0));\n\t\t\tfor(auto [x,y]:res)\n\t\t\t\tans.push_back(make_pair(x,y));\n\t\t}\n\tprintf(\"Possible\\n\");\n\tint len=ans.size()-1;\n\tprintf(\"%d\\n\",len);\n\tfor(auto [x,y]:ans)\n\t\tprintf(\"%d %d\\n\",x,y);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing pint = pair<int, int>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define ALL(x) (x).begin(), (x).end()\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define REP(i, n) FOR(i,0,n)\n\nconst string YES = \"Possible\";\nconst string NO = \"Impossible\";\n\nbool impossible_checker(int N, string S) {\n    assert((int)(S.length()) == (1 << N));\n    if (S[0] == '0') return true;\n    REP(a, 1 << N)\n    {\n        REP(b, 1 << N) if (((~b) & a) == 0) {\n            if (S[b] == '1' and S[a] == '0') return true;\n        }\n    }\n    return false;\n}\n\nvector<vector<int>> S(9);\n\nint x_now, y_now;\n\nvector<pint> ret;\n\nvoid up() {\n    y_now++;\n    ret.emplace_back(x_now, y_now);\n}\nvoid down() {\n    y_now--;\n    ret.emplace_back(x_now, y_now);\n}\nvoid right() {\n    x_now++;\n    ret.emplace_back(x_now, y_now);\n}\nvoid left() {\n    x_now--;\n    ret.emplace_back(x_now, y_now);\n}\n\nvoid do_rloop(int X)\n{\n    if (y_now == 0) {\n        up();\n    }\n    while (x_now < X) right();\n    while (x_now > X) left();\n    right();\n    down();\n    left();\n    up();\n}\n\nvoid do_lloop(int X) {\n    if (y_now == 0) {\n        up();\n    }\n    while (x_now < X) right();\n    while (x_now > X) left();\n    down();\n    right();\n    up();\n    left();\n}\n\nvoid go_origin() {\n    if (y_now == 0) up();\n    while (x_now > 0) left();\n    down();\n}\n\nint main()\n{\n    int N;\n    string A;\n    cin >> N >> A;\n    if (impossible_checker(N, A)) {\n        cout << NO << endl;\n        return 0;\n    }\n\n    S[1] = {+1};\n    S[2] = {+1, +2, -1, -2};\n    FOR(d, 3, S.size()) {\n        S[d] = {d};\n        vector<int> prev = S[d - 1];\n        S[d].insert(S[d].end(), ALL(prev));\n        S[d].push_back(-d);\n        reverse(ALL(prev));\n        for (auto &x : prev) x *= -1;\n        S[d].insert(S[d].end(), ALL(prev));\n    }\n\n    up();\n    down();\n\n    REP(subset, 1 << N) if (A[subset] == '0') {\n        bool must = true;\n        REP(ss, 1 << N) if (((~subset) & ss) == 0 and ss < subset) {\n            if (A[ss] == '0') must = false;\n        }\n        if (!must) continue;\n        int cnt = __builtin_popcount(subset);\n        if (cnt == 1) {\n            int i = 0;\n            while ((subset >> i) % 2 == 0) i++;\n            do_rloop(i);\n            continue;\n        }\n\n        vector<int> ns;\n        REP(i, N) if ((subset >> i) & 1) ns.push_back(i);\n        for (auto dict : S[cnt]) {\n            int id_ = abs(dict) - 1;\n            if (dict > 0) do_rloop(ns[id_]);\n            else do_lloop(ns[id_]);\n        }\n    }\n    go_origin();\n    up();\n\n    cout << YES << \"\\n\";\n    cout << ret.size() - 1 << \"\\n\";\n    for (auto p : ret) cout << p.first << \" \" << p.second << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<queue>\n#include<iostream>\n#include<fstream>\n#include<string>\n#include<cassert>\n#include<algorithm>\n#include<random>\n#include<map>\n#include<set>\n#include <bitset>\n#include<ctime>\n\nusing namespace std;\n\n//int mod = 998244353;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\ntypedef vector<int>vi;\ntypedef vector<ll>vl;\ntypedef vector<char>vc;\ntypedef vector<string>vs;\ntypedef vector<vector<int>>vii;\ntypedef vector<vector<char>>vvc;\ntypedef vector<vector<ll>>vll;\ntypedef vector< pair<ll, ll>>vpll;\ntypedef vector< pair<ld, ld>>vpld;\ntypedef vector< pair<int, int>>vpi;\ntypedef pair<ld, ld>pld;\n#define mp make_pair\n#define pb push_back\n\nconst int mod = 998244353;\nint add(int a, int b)\n{\n\tint c = a + b;\n\tif (c >= mod)\n\t{\n\t\tc -= mod;\n\t}\n\treturn c;\n}\nint dif(int a, int b)\n{\n\tint c = a - b;\n\tif (c < 0)\n\t{\n\t\tc += mod;\n\t}\n\treturn c;\n}\nint mlt(int a, int b)\n{\nll c = a * 1LL * b;\nreturn c % mod;\n}\nint ibit(int n, int i)\n{\n\treturn ((n >> i) & 1);\n}\nvoid outp(vii &ou)\n{\n\tfor (int i = 0; i < ou.size(); i++)\n\t{\n\t\tfor (int j = 0; j < ou[i].size(); j++)\n\t\t{\n\t\t\tcout << ou[i][j] << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n}\nint bp(int x, int y)\n{\n\tif (y == 0)\n\t{\n\t\treturn 1;\n\t}\n\tint a = 0;\n\tif (!(y % 2))\n\t{\n\t\ta = bp(x, y / 2);\n\t}\n\treturn (y % 2) ? mlt(bp(x, y - 1), x) : mlt(a, a);\n}\nint obr(int x)\n{\n\treturn bp(x, mod - 2);\n}\nconst int maxn = 2000007;\nint fact[2000007], ofact[2000007];\nvoid prec()\n{\n\tfact[0] = 1;\n\tofact[0] = 1;\n\tfor (int i = 1; i < maxn; i++)\n\t{\n\t\tfact[i] = mlt(fact[i - 1], i);\n\t}\n\t//cerr << \"sdsds\" << endl;\n\tofact[maxn - 1] = obr(fact[maxn - 1]);\n\tfor (int i = maxn - 2; i > 0; i--)\n\t{\n\t\tofact[i] = mlt(ofact[i + 1], i + 1);\n\t}\n}\nint c(int a, int b)\n{\n\tif (a == 0)return 1;\n\treturn ((a <= b) && (a >= 0)) ? mlt(fact[b], mlt(ofact[a], ofact[b - a])) : 0;\n}\nll gcd(ll x, ll y)\n{\n\t//cerr << x << y << endl;\n\tif (x == 0)return y;\n\treturn(x > y) ? gcd(y, x) : gcd(y%x, x);\n}\nint obr2(int n)\n{\n\tint x = fact[n - 1];\n\tx = mlt(x, ofact[n]);\n\treturn x;\n}\nvoid crv(int nn, vpi &v)\n{\n\tcerr << nn << endl;\n\tif (nn > 0) {\n\t\tint n = nn;\n\t\tfor (int i = 0; i < n; i++)v.pb({ i + 1, 0 });\n\t\tv.pb({ n,1 });\n\t\tv.pb({ n - 1, 1 });\n\t\tfor (int i = n - 1; i >= 0; i--)v.pb({ i, 0 });\n\t}\n\tif (nn < 0) {\n\t\tint n = -nn;\n\t\tfor (int i = 0; i < n-1; i++)v.pb({ i + 1, 0 });\n\t\tv.pb({ n-1,1 });\n\t\tv.pb({ n , 1 });\n\t\tfor (int i = n; i >= 0; i--)v.pb({ i, 0 });\n\t}\n}\nvoid solve(istream &cin = std::cin, ostream &cout = std::cout)\n{\n\tvii imb(9);\n\timb[0] = { 1 };\n\tfor (int i = 1; i <= 8; i++)\n\t{\n\t\tfor (int j = 0; j < imb[i - 1].size(); j++)imb[i].pb(imb[i - 1][j]);\n\t\timb[i].pb(i + 1);\n\t\tfor (int j = imb[i - 1].size(); j >= 0; j--)imb[i].pb((-1)*imb[i - 1][j]);\n\t\timb[i].pb(-i - 1);\n\t}\n\t//cerr << \"here\" << endl;\n\tint n;\n\tcin >> n;\n\tvi good(1 << n);\n\tfor (int i = 0; i < good.size(); i++)\n\t{\n\t\tchar c;\n\t\tcin >> c;\n\t\tgood[i] = c - '0';\n\t}\n\tint val = 0;\n\t//\tcerr << 433 << endl;\n\tfor (int a = 0; a < good.size(); a++)\n\t\tfor (int b = 0; b < good.size(); b++)\n\t\t\tif ((a | b) == b)\n\t\t\t\tif ((!good[a]) && (good[b]))\n\t\t\t\t{\n\t\t\t\t\t//\tcerr << a << ' ' << b << endl;\n\t\t\t\t\tval = 1;\n\t\t\t\t}\n//\tcerr << 5 << ' ' << 7 << ' ' << (5 | 7) << endl;\n\tif (val)cout << \"Impossible\" << endl;\n\telse\n\t{\n\t\tcout << \"Possible\" << endl;\n\t\t//cerr << 1111 << endl;\n\t\tvpi ay = { {0,0} };\n\t\tfor (int m = 0; m < good.size(); m++)\n\t\t{\n\t\t\t//cerr << m << endl;\n\t\t\tif (!good[m])\n\t\t\t{\n\t\t\t\tint val = 0;\n\t\t\t\tfor (int i = 0; i < good.size(); i++)\n\t\t\t\t{\n\t\t\t\t\tif (!good[i])\n\t\t\t\t\t\tif ((i | m) == m)\n\t\t\t\t\t\t\tval = 1;\n\t\t\t\t}\n\t\t\t\tif (val == 0)\n\t\t\t\t{\n\t\t\t\t\t//\t\tcerr << m << endl;\n\t\t\t\t\tvi v;\n\t\t\t\t\tfor (int i = 0; i < 8; i++)if (ibit(m, i))v.pb(i);\n\t\t\t\t\t//\tcerr << m << ' ' << v.size() << endl;\n\t\t\t\t\tfor (int i = 0; i < imb[v.size() - 1].size(); i++)\n\t\t\t\t\t{\n\t\t\t\t\t\t//\tcerr << imb[v.size() - 1][i] << endl;\n\t\t\t\t\t\t\t//\tcerr << i << endl;\n\t\t\t\t\t\tif (imb[v.size()][i] > 0)crv(v[imb[v.size() - 1][i] - 1] + 1, ay);\n\t\t\t\t\t\tif (imb[v.size()][i] < 0)crv(-v[(-imb[v.size() - 1][i]) - 1] - 1, ay);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ay.size() < 190000)\n\t\t{\n\t\t\tcout << ay.size() - 1 << endl;\n\t\t\tfor (int i = 0; i < ay.size(); i++)cout << ay[i].first << ' ' << ay[i].second << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << 0 << endl;\n\t\t\tcout << 0 << ' ' << 0 << endl;\n\t\t}\n\t}\n}\nint main()\n{\n\tsolve();\n\tint n;\n\tcin >> n;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define all(x) x.begin(),x.end()\n#define cmin(a,b) (a>b?a=b:a)\n#define cmax(a,b) (a<b?a=b:a)\n#define mem(a,k) memset(a,k,sizeof(a))\n#define lop(i,s,t) for(int i=s;i<(t);++i)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define fore(i,v) for(int i=g[v],d=es[i].d;i;i=es[i].nxt,d=es[i].d)\nusing namespace std;\n\n#ifdef CURIOUSCAT\n#define Pr(f,...) fprintf(stderr,f,##__VA_ARGS__),fflush(stderr)\n#else\n#define Pr(f,...) ;\n#endif\n\ntypedef long long ll;\n\ntemplate<typename T>\nvoid read(T &x){\n\tx=0; \n\tchar c;\n\tfor(c=getchar();!isdigit(c);c=getchar()); \n\tfor(;isdigit(c);c=getchar())x=x*10+c-'0'; \n}\n\nconst int N=1e6+50;\n\nint P;\nint mul(int a,int b){ return 1ll*a*b%P; }\nint add(int a,int b){ a+=b; return a>=P?a-P:a; }\nvoid upd(int &a,int b) { a=a+b>=P?a+b-P:a+b; }\nint sub(int a,int b){ a-=b; return a<0?a+P:a; }\nint gcd(int a,int b){ return !b?a:gcd(b,a%b); }\n\nint n;\nchar a[1<<9];\nint main(int argc,char *argv[]){\n#ifdef CURIOUSCAT\n#endif\n\tread(n); \n\tlop(s,0,(1<<n)){\n\t\tscanf(\" %c\",&a[s]); a[s]-='0';\n\t}\n\tlop(s,0,(1<<n)){\n\t\tint c0=0,c1=0;\n\t\tlop(i,0,n)if(s>>i&1){\n\t\t\tif(a[1<<i])++c1;else ++c0;\n\t\t}\n\t\tif((c0&&a[s])||(!c0&&!a[s])){\n\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\treturn 0; \n\t\t}\n\t}\n\tint cnt=0;\n\tlop(i,0,n)cnt+=!a[1<<i];\n\tcout<<\"Possible\"<<endl;\n\tif(cnt==0){\n\t\tcout<<0<<endl;\n\t\tcout<<1<<\" \"<<1<<endl;\n\t}else{\n\t\tvector<pair<int,int>> ans;\n\t\tans.pb(mp(0,0));\n\t\tfor(int i=0,p;i<n;i=p){\n\t\t\tif(!a[1<<i]){\n\t\t\t\tfor(p=i;p<n&&!a[1<<p];++p);\n\t\t\t\tans.pb(mp(i,1));\n\t\t\t\tlop(z,0,p-i)ans.pb(mp(i+z+1,1));\n\t\t\t}else{\n\t\t\t\tfor(p=i;p<n&&a[1<<p];++p);\n\t\t\t\tif(i)ans.pb(mp(i,0)); \n\t\t\t\tlop(z,0,p-i)ans.pb(mp(i+z+1,0));\n\t\t\t}\n\t\t}\n\t\tif(a[1<<(n-1)]){\n\t\t\tdec(i,n-1,0)ans.pb(mp(i,0));\n\t\t}else{\n\t\t\tdec(i,n,0)ans.pb(mp(i,0)); \n\t\t}\n\t\tprintf(\"%d\\n\",(int)ans.size()-1);\n\t\tfor(auto x:ans)printf(\"%d %d\\n\",x.fi,x.sc); \n\t}\n\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define fr first\n#define sc second\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n\nvector<P> ret;\n\nvoid pos(int i){\n\tfor(int j=0;j<i;j++){\n\t\tret.push_back(P(j+1,0));\n\t}\n\tret.push_back(P(i,1));\n\tret.push_back(P(i+1,1));\n\tret.push_back(P(i+1,0));\n\tret.push_back(P(i,0));\n\tfor(int j=i-1;j>=0;j--){\n\t\tret.push_back(P(j,0));\n\t}\n}\nvoid neg(int i){\n\tfor(int j=0;j<i;j++){\n\t\tret.push_back(P(j+1,0));\n\t}\n\tret.push_back(P(i+1,0));\n\tret.push_back(P(i+1,1));\n\tret.push_back(P(i,1));\n\tret.push_back(P(i,0));\n\tfor(int j=i-1;j>=0;j--){\n\t\tret.push_back(P(j,0));\n\t}\n}\n\nvector<P> f(vector<P> vec,int t){\n\tint cnt[300]={};\n\tfor(int i=0;i<vec.size();i++){\n\t\tcnt[vec[i].sc]++;\n\t}\n\tint MIN=100;\n\tint id=-1;\n\tfor(int i=0;i<300;i++){\n\t\tif(cnt[i]==0)continue;\n\t\tif(MIN>cnt[i]){\n\t\t\tMIN=cnt[i];\n\t\t\tid=i;\n\t\t}\n\t}\n\t//cerr<<\"id=\"<<id<<endl;\n\tvector<P> ret;\n\tfor(int i=0;i<vec.size();i++){\n\t\tif(vec[i].sc!=id)ret.push_back(vec[i]);\n\t\telse {\n\t\t\tif(vec[i].fr==1){\n\t\t\t\tret.push_back(P(1,id));\n\t\t\t\tret.push_back(P(1,t));\n\t\t\t\tret.push_back(P(-1,id));\n\t\t\t\tret.push_back(P(-1,t));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret.push_back(P(1,t));\n\t\t\t\tret.push_back(P(1,id));\n\t\t\t\tret.push_back(P(-1,t));\n\t\t\t\tret.push_back(P(-1,id));\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nbool zero(vector<P> vec, int x){\n\tstack<P> st;\n\tfor(P p: vec){\n\t\tif((x>>p.sc)&1){\n\t\t\tif(st.size()==0){\n\t\t\t\tst.pop();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tP q=st.top();\n\t\t\tif(q.sc==p.sc&&p.sc+q.sc==0)st.pop();\n\t\t\telse st.push(p);\n\t\t}\n\t}\n\treturn st.size()==0;\n}\n\nint main(){\n\t/*vector<P> vvv;\n\tvvv.push_back(P(1,1));\n\tfor(int i=2;i<=8;i++){\n\t\tvvv=f(vvv,i);\n\t\tcerr<<i<<\" \"<<vvv.size()<<endl;\n\t}*/\n\t\n\t\n\tint n;\n\tstring s;\n\tcin>>n>>s;\n\t\n\tint a[300];\n\tfor(int i=0;i<(1<<n);i++)a[i]=s[i]-'0';\n\t\n\tbool used[300];\n\tmemset(used,0,sizeof used);\n\t\n\tint b[300];\n\tfor(int i=0;i<300;i++)b[i]=1;\n\t\n\tfor(int x=1;x<(1<<n);x++){\n\t\tused[x]=true;\n\t\tfor(int y=0;y<x;y++){\n\t\t\tif((x&y)==y)if(used[y])used[x]=false;\n\t\t}\n\t\tfor(int y=0;y<(1<<n);y++){\n\t\t\tif((x&y)==x)if(a[y]==1)used[x]=false;\n\t\t}\n\t\tif(used[x]){\n\t\t\tfor(int y=0;y<(1<<n);y++){\n\t\t\t\tif((x&y)==x)b[y]=0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool ok=true;\n\tfor(int i=0;i<(1<<n);i++)ok&=a[i]==b[i];\n\tif(!ok){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tvector<P> vv;\n\t/*for(int x=0;x<(1<<n);x++){\n\t\tif(!used[x])continue;\n\t\tif(vv.size()==0){\n\t\t\tvv.push_back(P(1,x));\n\t\t}\n\t\telse{\n\t\t\tvv=f(vv,x);\n\t\t}\n\t}*/\n\tvector<P> vec[300];\n\tret.push_back(P(0,0));\n\tfor(int x=0;x<(1<<n);x++){\n\t\tif(!used[x])continue;\n\t\tif(zero(vv,x)){\n\t\t\tint cnt=0;\n\t\t\tint c[10];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif((x>>i)&1)c[cnt++]=i;\n\t\t\t}\n\t\t\tvec[x].push_back(P(1,c[0]));\n\t\t\tfor(int i=1;i<cnt;i++)vec[x]=f(vec[x],c[i]);\n\t\t\tvv.insert(vv.end(),vec[x].begin(),vec[x].end());\n\t\t}\n\t}\n\tfor(P p: vv){\n\t\tif(p.fr==1)pos(p.sc);\n\t\telse neg(p.sc);\n\t}\n\t\n\t/*for(int i=0;i<vv.size();i++){\n\t\tif(vv[i].fr==1){\n\t\t\tfor(P p: vec[vv[i].sc]){\n\t\t\t\tif(p.fr==1)pos(p.sc);\n\t\t\t\telse neg(p.sc);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor(int j=vec[vv[i].sc].size()-1;j>=0;j--){\n\t\t\t\tP p=vec[vv[i].sc][j];\n\t\t\t\tif(p.fr==1)neg(p.sc);\n\t\t\t\telse pos(p.sc);\n\t\t\t}\n\t\t}\n\t}*/\n\t\n\tvector<P> ret2;\n\tfor(P p: ret){\n\t\tif(ret2.size()>=2&&ret2[ret2.size()-2]==p)ret2.pop_back();\n\t\telse ret2.push_back(p);\n\t}\n\tret=ret2;\n\t\n\tassert(ret.size()<=250000);\n\t\n\tputs(\"Possible\");\n\tprintf(\"%d\\n\",(int)(ret.size())-1);\n\tfor(int i=0;i<ret.size();i++){\n\t\tprintf(\"%d %d\\n\",ret[i].fr,ret[i].sc);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define fr first\n#define sc second\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n\nvector<P> ret;\n\nvoid pos(int i){\n\tfor(int j=0;j<i;j++){\n\t\tret.push_back(P(j+1,0));\n\t}\n\tret.push_back(P(i,1));\n\tret.push_back(P(i+1,1));\n\tret.push_back(P(i+1,0));\n\tret.push_back(P(i,0));\n\tfor(int j=i-1;j>=0;j--){\n\t\tret.push_back(P(j,0));\n\t}\n}\nvoid neg(int i){\n\tfor(int j=0;j<i;j++){\n\t\tret.push_back(P(j+1,0));\n\t}\n\tret.push_back(P(i+1,0));\n\tret.push_back(P(i+1,1));\n\tret.push_back(P(i,1));\n\tret.push_back(P(i,0));\n\tfor(int j=i-1;j>=0;j--){\n\t\tret.push_back(P(j,0));\n\t}\n}\n\nvector<P> f(vector<P> vec,int t){\n\tint cnt[300]={};\n\tfor(int i=0;i<vec.size();i++){\n\t\tcnt[vec[i].sc]++;\n\t}\n\tint MIN=100;\n\tint id=-1;\n\tfor(int i=0;i<300;i++){\n\t\tif(cnt[i]==0)continue;\n\t\tif(MIN>cnt[i]){\n\t\t\tMIN=cnt[i];\n\t\t\tid=i;\n\t\t}\n\t}\n\t//cerr<<\"id=\"<<id<<endl;\n\tvector<P> ret;\n\tfor(int i=0;i<vec.size();i++){\n\t\tif(vec[i].sc!=id)ret.push_back(vec[i]);\n\t\telse {\n\t\t\tif(vec[i].fr==1){\n\t\t\t\tret.push_back(P(1,id));\n\t\t\t\tret.push_back(P(1,t));\n\t\t\t\tret.push_back(P(-1,id));\n\t\t\t\tret.push_back(P(-1,t));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret.push_back(P(1,t));\n\t\t\t\tret.push_back(P(1,id));\n\t\t\t\tret.push_back(P(-1,t));\n\t\t\t\tret.push_back(P(-1,id));\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nbool zero(vector<P> vec, int x){\n\tstack<P> st;\n\tfor(P p: vec){\n\t\tif((x>>p.sc)&1){\n\t\t\tif(st.size()==0){\n\t\t\t\tst.push(p);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tP q=st.top();\n\t\t\tif(q.sc==p.sc&&p.sc+q.sc==0)st.pop();\n\t\t\telse st.push(p);\n\t\t}\n\t}\n\treturn st.size()==0;\n}\n\nint main(){\n\t/*vector<P> vvv;\n\tvvv.push_back(P(1,1));\n\tfor(int i=2;i<=8;i++){\n\t\tvvv=f(vvv,i);\n\t\tcerr<<i<<\" \"<<vvv.size()<<endl;\n\t}*/\n\t\n\t\n\tint n;\n\tstring s;\n\tcin>>n>>s;\n\t\n\tint a[300];\n\tfor(int i=0;i<(1<<n);i++)a[i]=s[i]-'0';\n\t\n\tbool used[300];\n\tmemset(used,0,sizeof used);\n\t\n\tint b[300];\n\tfor(int i=0;i<300;i++)b[i]=1;\n\t\n\tfor(int x=1;x<(1<<n);x++){\n\t\tused[x]=true;\n\t\tfor(int y=0;y<x;y++){\n\t\t\tif((x&y)==y)if(used[y])used[x]=false;\n\t\t}\n\t\tfor(int y=0;y<(1<<n);y++){\n\t\t\tif((x&y)==x)if(a[y]==1)used[x]=false;\n\t\t}\n\t\tif(used[x]){\n\t\t\tfor(int y=0;y<(1<<n);y++){\n\t\t\t\tif((x&y)==x)b[y]=0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool ok=true;\n\tfor(int i=0;i<(1<<n);i++)ok&=a[i]==b[i];\n\tif(!ok){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tvector<P> vv;\n\t/*for(int x=0;x<(1<<n);x++){\n\t\tif(!used[x])continue;\n\t\tif(vv.size()==0){\n\t\t\tvv.push_back(P(1,x));\n\t\t}\n\t\telse{\n\t\t\tvv=f(vv,x);\n\t\t}\n\t}*/\n\tvector<P> vec[300];\n\tret.push_back(P(0,0));\n\tfor(int x=0;x<(1<<n);x++){\n\t\tif(!used[x])continue;\n\t\tif(zero(vv,x)){\n\t\t\tint cnt=0;\n\t\t\tint c[10];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif((x>>i)&1)c[cnt++]=i;\n\t\t\t}\n\t\t\tvec[x].push_back(P(1,c[0]));\n\t\t\tfor(int i=1;i<cnt;i++)vec[x]=f(vec[x],c[i]);\n\t\t\tvv.insert(vv.end(),vec[x].begin(),vec[x].end());\n\t\t}\n\t}\n\tfor(P p: vv){\n\t\tif(p.fr==1)pos(p.sc);\n\t\telse neg(p.sc);\n\t}\n\t\n\t/*for(int i=0;i<vv.size();i++){\n\t\tif(vv[i].fr==1){\n\t\t\tfor(P p: vec[vv[i].sc]){\n\t\t\t\tif(p.fr==1)pos(p.sc);\n\t\t\t\telse neg(p.sc);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor(int j=vec[vv[i].sc].size()-1;j>=0;j--){\n\t\t\t\tP p=vec[vv[i].sc][j];\n\t\t\t\tif(p.fr==1)neg(p.sc);\n\t\t\t\telse pos(p.sc);\n\t\t\t}\n\t\t}\n\t}*/\n\t\n\tvector<P> ret2;\n\tfor(P p: ret){\n\t\tif(ret2.size()>=2&&ret2[ret2.size()-2]==p)ret2.pop_back();\n\t\telse ret2.push_back(p);\n\t}\n\tret=ret2;\n\t\n\t//assert(ret.size()<=250000);\n\t\n\tputs(\"Possible\");\n\tprintf(\"%d\\n\",(int)(ret.size())-1);\n\tfor(int i=0;i<ret.size();i++){\n\t\tprintf(\"%d %d\\n\",ret[i].fr,ret[i].sc);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst char* IMPOSSIBLE = \"Impossible\";\nconst char* POSSIBLE = \"Possible\";\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint N; cin >> N;\n\tvector<bool> A(1<<N);\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tchar c; cin >> c;\n\t\tassert(c == '0' || c == '1');\n\t\tA[(1<<N)-1-m] = (c == '1');\n\t}\n\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\t// m2 is a superset\n\t\t\tif (A[m] > A[m | (1<<i)]) {\n\t\t\t\tcout << IMPOSSIBLE << '\\n';\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t}\n\tcout << POSSIBLE << '\\n';\n\tmt19937 mt(48);\n\tvector<int> minM;\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tif (!A[m]) continue;\n\t\tbool isMinimal = true;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif ((m & (1<<i)) && A[m ^ (1<<i)]) {\n\t\t\t\tisMinimal = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isMinimal) {\n\t\t\tminM.push_back(m);\n\t\t}\n\t}\n\tshuffle(minM.begin(), minM.end(), mt);\n\n\tqueue<vector<int>> q;\n\tfor (int m : minM) {\n\t\tvector<int> v;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (m & (1<<i)) {\n\t\t\t\tv.push_back(i+1);\n\t\t\t}\n\t\t}\n\t\tshuffle(v.begin(), v.end(), mt);\n\t\tq.push(v);\n\t}\n\n\twhile (q.size() >= 2) {\n\t\tvector<int> a = std::move(q.front()); q.pop();\n\t\tvector<int> b = std::move(q.front()); q.pop();\n\n\t\tvector<int> c;\n\t\tfor (int i : a) { c.push_back(i); }\n\t\tfor (int i : b) { c.push_back(i); }\n\t\treverse(a.begin(), a.end());\n\t\treverse(b.begin(), b.end());\n\t\tfor (int i : a) { c.push_back(-i); }\n\t\tfor (int i : b) { c.push_back(-i); }\n\t\tq.push(c);\n\t}\n\n\tvector<int> pattern;\n\tif (!q.empty()) {\n\t\tpattern = std::move(q.front()); q.pop();\n\t}\n\n\tvector<pair<int, int>> pos;\n\tpos.emplace_back(0,1);\n\tauto goToPt = [&](int x) {\n\t\tassert(pos.back().second == 1);\n\t\tif (pos.back() == pair<int, int>(x,1)) {\n\t\t\treturn;\n\t\t}\n\t\tpos.emplace_back(pos.back().first, 0);\n\t\twhile (pos.back().first < x) {\n\t\t\tpos.emplace_back(pos.back().first+1, 0);\n\t\t}\n\t\twhile (pos.back().first > x) {\n\t\t\tpos.emplace_back(pos.back().first-1, 0);\n\t\t}\n\t\tpos.emplace_back(x,1);\n\t};\n\tfor (auto i : pattern) {\n\t\tassert(i != 0);\n\t\tif (i > 0) {\n\t\t\tgoToPt(i-1);\n\t\t\tpos.emplace_back(i, 1);\n\t\t} else {\n\t\t\tgoToPt(-i);\n\t\t\tpos.emplace_back(-i-1, 1);\n\t\t}\n\t}\n\n\tgoToPt(0);\n\n\tcout << pos.size()-1 << '\\n';\n\tfor (auto it : pos) {\n\t\tcout << it.first << ' ' << it.second << '\\n';\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n, C[260];\nchar p[260];\nstruct point {\n\tint x, y;\n};\nvector<point>Res;\nvoid Add(int x, int y) {\n\tRes.push_back({ x,y });\n}\nvoid Add0() {\n\tint i;\n\tfor (i = 0; i < n; i++) Add(i, 1);\n\tfor (i = n; i > 0; i--)Add(i, 1);\n}\nvoid Add1(int x) {\n\tint i;\n\tfor (i = 0; i <= x + 1; i++)Add(i, 1);\n\tAdd(x + 1, 0);\n\tAdd(x, 0);\n\tfor (i = x; i > 0; i--)Add(i, 1);\n}\nvoid Add2(int xa, int xb) {\n\tint i;\n\tfor (i = 0; i <= xb + 1; i++) Add(i, 1);\n\tAdd(xb + 1, 0);\n\tAdd(xb, 0);\n\tfor (i = xb; i >= xa; i--)Add(i, 1);\n\tAdd(xa, 0);\n\tAdd(xa + 1, 0);\n\tfor (i = xa + 1; i <= xb; i++)Add(i, 1);\n\tAdd(xb, 0);\n\tAdd(xb + 1, 0);\n\tfor (i = xb + 1; i > xa; i--)Add(i, 1);\n\tAdd(xa + 1, 0);\n\tAdd(xa, 0);\n\tfor (i = xa; i > 0; i--)Add(i, 1);\n}\nvoid Print() {\n\tprintf(\"Possible\\n\");\n\tprintf(\"%d\\n\", Res.size());\n\tint i;\n\tRes.push_back(Res[0]);\n\tfor (auto &t : Res)printf(\"%d %d\\n\", t.x, t.y);\n}\nint main() {\n\tint i, j;\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", p);\n\tfor (i = 0; i < (1 << n); i++) {\n\t\tint c = 0;\n\t\tfor (j = 0; j < n; j++)if ((i >> j) & 1)c++;\n\t\tC[i] = c;\n\t}\n\tfor (i = 0; i < (1 << n); i++) {\n\t\tint ck = 0;\n\t\tif (p[i] == '0' && C[i] >= 3)ck = 1;\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif ((i&j) == j) {\n\t\t\t\tif (p[j] == '0'&&p[i] == '1') {\n\t\t\t\t\tputs(\"Impossible\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (C[j] == 2 && p[j] == '0')ck = 0;\n\t\t\t}\n\t\t}\n\t\tck = 0;\n\t\tif (ck == 1) {\n\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tAdd0();\n\tint pv = -1;\n\tfor (i = 0; i < n; i++) {\n\t\tif (p[1 << i] == '0') {\n\t\t\tAdd1(i);\n\t\t\tpv = i;\n\t\t}\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t\tif (p[1 << i] == '1'&&p[1 << j] == '1'&&p[(1 << i) | (1 << j)] == '0') {\n\t\t\t\tAdd2(i, j);\n\t\t\t}\n\t\t}\n\t}\n\tPrint();\n}"
  },
  {
    "language": "C++",
    "code": "#define pb push_back\n#define all(x) x.begin(),x.end()\n#define cmin(a,b) (a>b?a=b:a)\n#define cmax(a,b) (a<b?a=b:a)\n#define mem(a,k) memset(a,k,sizeof(a))\n#define lop(i,s,t) for(int i=s;i<(t);++i)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define fore(i,v) for(int i=g[v],d=es[i].d;i;i=es[i].nxt,d=es[i].d)\nusing namespace std;\n\n#ifdef CURIOUSCAT\n#define Pr(f,...) fprintf(stderr,f,##__VA_ARGS__),fflush(stderr)\n#else\n#define Pr(f,...)\n#endif\n\ntypedef long long ll;\n\ntemplate<typename T>\nvoid read(T &x){\n\tx=0; \n\tchar c;\n\tfor(c=getchar();!isdigit(c);c=getchar()); \n\tfor(;isdigit(c);c=getchar())x=x*10+c-'0'; \n}\n\nconst int N=1e6+50;\n\nint P;\nint mul(int a,int b){ return 1ll*a*b%P; }\nint add(int a,int b){ a+=b; return a>=P?a-P:a; }\nvoid upd(int &a,int b) { a=a+b>=P?a+b-P:a+b; }\nint sub(int a,int b){ a-=b; return a<0?a+P:a; }\nint gcd(int a,int b){ return !b?a:gcd(b,a%b); }\n\nint n;\nchar a[1<<9];\nint main(int argc,char *argv[]){\n#ifdef CURIOUSCAT\n#endif\n\tread(n); \n\tlop(s,0,(1<<n)){\n\t\tscanf(\" %c\",&a[s]); a[s]-='0';\n\t}\n\tlop(s,0,(1<<n)){\n\t\tint c0=0,c1=0;\n\t\tlop(i,0,n)if(s>>i&1){\n\t\t\tif(a[1<<i])++c1;else ++c0;\n\t\t}\n\t\tPr(\"%d,%d,%d,%d\\n\",s,c0,c1,a[s]); \n\t\tif((c0&&a[s])||(!c0&&!a[s])){\n\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\treturn 0; \n\t\t}\n\t}\n\tint cnt=0;\n\tlop(i,0,n)cnt+=!a[1<<i];\n\tcout<<\"possible\"<<endl;\n\tif(cnt==0){\n\t\tcout<<0<<endl;\n\t\tcout<<1<<\" \"<<1<<endl;\n\t}else{\n\t\tprintf(\"%d %d\\n\",0,0); \n\t\tfor(int i=0,p;i<n;i=p){\n\t\t\tif(!a[1<<i]){\n\t\t\t\tfor(p=i;p<n&&!a[1<<p];++p);\n\t\t\t\tprintf(\"%d %d\\n\",i,1);\n\t\t\t\tlop(z,0,p-i)printf(\"%d %d\\n\",i+z+1,1);\n\t\t\t}else{\n\t\t\t\tfor(p=i;p<n&&a[1<<p];++p);\n\t\t\t\tprintf(\"%d %d\\n\",i,0);\n\t\t\t\tlop(z,0,p-i)printf(\"%d %d\\n\",i+z+1,0);\n\t\t\t}\n\t\t}\n\t\tif(a[1<<(n-1)]){\n\t\t\tdec(i,n,0)printf(\"%d %d\\n\",i,-1);\n\t\t\tprintf(\"%d %d\\n\",0,0); \n\t\t}else{\n\t\t\tprintf(\"%d %d\\n\",n,0); \n\t\t\tdec(i,n,0)printf(\"%d %d\\n\",i,-1);\n\t\t\tprintf(\"%d %d\\n\",0,0); \n\t\t}\n\t}\n\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\nauto constexpr INF32 = numeric_limits<int32_t>::max()/2-1;\nauto constexpr INF64 = numeric_limits<int64_t>::max()/2-1;\nauto constexpr INF   = numeric_limits<int>::max()/2-1;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#define dump(...) cerr << \"[\" << setw(3) << __LINE__ << \":\" << __FUNCTION__ << \"] \", dump_impl(#__VA_ARGS__, __VA_ARGS__)\n#define say(x) cerr << \"[\" << __LINE__ << \":\" << __FUNCTION__ << \"] \" << x << endl\n#define debug if (1)\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class F> int ppt(C const& v, F f) {\n    return partition_point(v.begin(), v.end(), f)-v.begin();\n}\n// <<<\n\nint32_t main() {\n    int n; cin >> n;\n    string s; cin >> s;\n    vector<int> a(s.size());\n    rep (i,s.size()) a[i] = s[i]-'0';\n\n    rep (bit,s.size()) if (bit) {\n        int x = 1;\n        rep (i,n) if (bit>>i&1) x &= a[1LL<<i];\n        if (x != a[bit]) quit(\"Impossible\");\n    }\n    cout << \"Possible\\n\";\n\n    vector<pair<int,int>> v;\n    rep (i,n+1) v.eb(i,0);\n    repR (i,n) {\n        if (a[1LL<<i] == 0) {\n            v.eb(i+1,1);\n            v.eb(i,1);\n        }\n        v.eb(i,0);\n    }\n\n    cout << v.size()-1 << endl;\n    for (auto p : v) {\n        cout << p.fst << \" \" << p.snd << \"\\n\";\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int N=1<<10;\nint n;\nchar s[N];\nint p[N];\nvector<pair<int,int> > solve(int S,int now)\n{\n\tcerr<<\"Solve\"<<S<<\" \"<<now<<\"\\n\";\n\tvector<pair<int,int> >res;\n\tfor(int i=now+1;i<=n;i++)\n\t\tif(S&(1<<i))\n\t\t{\n\t\t\tvector<pair<int,int> > t=solve(S,i);\n\t\t\tfor(int j=now-1;j<=i-2;j++)\n\t\t\t\tres.push_back(make_pair(j,1));\n\t\t\tfor(auto [x,y]:t)\n\t\t\t\tres.push_back(make_pair(x,y));\n\t\t\tfor(int j=i-1;j>=now-1;j--)\n\t\t\t\tres.push_back(make_pair(j,1));\n\t\t\tres.push_back(make_pair(now-1,0));\n\t\t\tres.push_back(make_pair(now,0));\n\t\t\tfor(int j=now;j<=i-1;j++)\n\t\t\t\tres.push_back(make_pair(j,1));\n\t\t\tfor(auto [x,y]:t)\n\t\t\t\tres.push_back(make_pair(x,y^1));\n\t\t\tfor(int j=i-2;j>=now;j--)\n\t\t\t\tres.push_back(make_pair(j,1));\n\t\t\tres.push_back(make_pair(now,0));\n\t\t\tres.push_back(make_pair(now-1,0));\n\t\t\treturn res;\n\t\t}\n\tres.push_back(make_pair(now-1,1));\n\tres.push_back(make_pair(now,1)); \n\tres.push_back(make_pair(now,0));\n\tres.push_back(make_pair(now-1,0));\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s);\n\tfor(int i=0;i<(1<<n);i++)\n\t\tp[i]=s[i]-'0';\n\tif(p[0]==0)\n\t{\n\t\tprintf(\"Impossible\");\n\t\treturn 0;\n\t}\n\tfor(int s=0;s<(1<<n);s++)\n\t\tif(p[s]==1)\n\t\t\tfor(int i=s;i;i=(i-1)&s)\n\t\t\t\tif(p[i]==0)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"Impossible\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\tvector<pair<int,int> >ans;\n\tans.push_back(make_pair(0,0));\n\tfor(int s=1;s<(1<<n);s++)\n\t\tif(p[s]==0)\n\t\t{\n\t\t\tbool flag=true;\n\t\t\tfor(int i=(s-1)&s;i;i=(i-1)&s)\n\t\t\t\tif(p[i]==0)\n\t\t\t\t{\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif(!flag) continue;\n\t\t\tvector<pair<int,int> >res;\n\t\t\tvector<pair<int,int> >t;\n\t\t\tint u=0;\n\t\t\tfor(u=0;u<n;u++)\n\t\t\t\tif(s&(1<<u))\n\t\t\t\t{\n\t\t\t\t\tt=solve(s<<1,u+1);\n//\t\t\t\t\tcerr<<\"res\"<<\"\\n\";\n//\t\t\t\t\tfor(auto [x,y]:t)\n//\t\t\t\t\t\tcerr<<x<<\" \"<<y<<\"\\n\";\n//\t\t\t\t\tcerr<<\"EOF\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tu++;\n\t\t\tif(ans.back()!=make_pair(0,0)) res.push_back(make_pair(0,0));\n\t\t\tfor(int i=0;i<=u-2;i++)\n\t\t\t\tres.push_back(make_pair(i,1));\n\t\t\tfor(auto [x,y]:t)\n\t\t\t\tres.push_back(make_pair(x,y));\n\t\t\tfor(int i=u-1;i>=0;i--)\n\t\t\t\tres.push_back(make_pair(i,1));\n\t\t\tres.push_back(make_pair(0,0));\n\t\t\tfor(auto [x,y]:res)\n\t\t\t\tans.push_back(make_pair(x,y));\n\t\t}\n\tprintf(\"Possible\\n\");\n\tint len=ans.size()-1;\n\tprintf(\"%d\\n\",len);\n\tfor(auto [x,y]:ans)\n\t\tprintf(\"%d %d\\n\",x,y);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define rrng(a) a.rbegin(),a.rend()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define eb emplace_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ntypedef vector<T> vt;\ninline int getInt() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define dame { puts(\"Impossible\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\nconst int MX = 200005;\n\nvp f(vi a) {\n  if (sz(a) == 0) {\n    vp res;\n    res.eb(0,0);\n    res.eb(0,1);\n    return res;\n  }\n  int x = a.back();\n  a.pop_back();\n  rep(i,sz(a)) a[i] -= x+1;\n  vp d = f(a);\n  rep(i,sz(d)) d[i].fi += x+1;\n  vp res;\n  res.eb(0,0);\n  rep(i,x+1) res.eb(i+1,0);\n  res.insert(res.end(), d.begin()+1, d.end());\n  res.eb(x+1,0);\n  res.eb(0,1);\n  reverse(rng(d));\n  res.insert(res.end(), d.begin()+1, d.end());\n  res.eb(x+1,1);\n  drep(i,x+1) res.eb(i,1);\n  return res;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  string st;\n  cin>>st;\n  int n2 = 1<<n;\n  vi a(n2);\n  rep(i,n2) a[i] = st[i]-'0';\n  rep(i,n2) a[i] ^= 1;\n  rep(i,n2) {\n    if (a[i]) continue;\n    for (int j = i;; j = (j-1)&i) {\n      if (a[j]) dame;\n      if (!j) break;\n    }\n  }\n  if (a[0]) dame;\n  cout<<\"Possible\"<<endl;\n  vp ans;\n  rep(i,n2) {\n    if (!a[i]) continue;\n    vi s;\n    rep(j,n) if (i>>j&1) s.pb(j);\n    reverse(rng(s));\n    vp now = f(s);\n    ans.insert(ans.end(), rng(now));\n  }\n  ans.eb(0,0);\n  cout<<sz(ans)-1<<endl;\n  for (P p : ans) {\n    cout<<p.fi<<\" \"<<p.se<<endl;\n  }\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "/* cerberus97 - Hanit Banga */\n\n#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\n#define pb push_back\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 1e5 + 10;\n\nint main() {\n\tfast_cin();\n\tint n; string s;\n\tcin >> n >> s;\n\tint tot = (1 << n), biggest = 0;\n\tfor (int mask = 0; mask < tot; ++mask) {\n\t\tif (s[mask] == '0') {\n\t\t\tcontinue;\n\t\t}\n\t\tbiggest = mask;\n\t\tfor (int sub = 0; sub < mask; ++sub) {\n\t\t\tif ((mask & sub) == sub and s[sub] == '0') {\n\t\t\t\tcout << \"Impossible\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tvector<pii> pts = {{0, 0}};\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!((biggest >> i) & 1)) {\n\t\t\tpts.pb({i, 1});\n\t\t\tpts.pb({i + 1, 1});\n\t\t\tpts.pb({i + 1, 0});\n\t\t\tpts.pb({i, 0});\n\t\t}\n\t\tpts.pb({i + 1, 0});\n\t}\n\tfor (int i = n - 1; i >= 0; --i) {\n\t\tpts.pb({i, 0});\n\t}\n\tcout << \"Possible\\n\" << pts.size() << '\\n';\n\tfor (auto& p : pts) {\n\t\tcout << p.first << ' ' << p.second << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MX = 8;\n\nvoid print(int n, int msk) {\n\tvector<pair<int, int>> ans;\n\tans.emplace_back(0, 1);\n\tfor (int i = 0, p = 0; i < n; i++) {\n\t\tif (((msk >> i) & 1) == 1) {\n\t\t\tif (p == 1) ans.pop_back();\n\t\t\telse ans.emplace_back(i, 0);\n\t\t\t\n\t\t\tans.emplace_back(i + 1, 0);\n\t\t\tans.emplace_back(i + 1, 1);\n\t\t\t\n\t\t\tp = 1;\n\t\t}\n\t\telse {\n\t\t\tans.emplace_back(i + 1, 1);\n\t\t\t\n\t\t\tp = 0;\n\t\t}\n\t}\n\t\n\tans.emplace_back(n, 2);\n\tfor (int i = n - 1; i >= 0; i--) ans.emplace_back(i, 2);\n\tans.emplace_back(0, 1);\n\t\n\tprintf(\"Possible\\n%zu\\n\", ans.size());\n\tfor (auto& p : ans) {\n\t\tprintf(\"%d %d\\n\", p.first, p.second);\n\t}\n\t\n\texit(0);\n}\n\nint a[1 << MX];\nchar s[2 << MX];\n\nint main() {\n\tint n;\n\tignore = scanf(\"%d %s\", &n, s);\n\tfor (int i = 0; i < (1 << n); i++) {\n\t\ta[i] = s[i] - '0';\n\t}\n\t\n\tfor (int msk = 0; msk < (1 << n); msk++) {\n\t\tbool ok = true;\n\t\tfor (int i = 0; i < (1 << n); i++) {\n\t\t\tint can = ((msk & i) == 0 ? 1 : 0);\n\t\t\tok = ok && can == a[i];\n\t\t}\n\t\t\n\t\tif (ok) print(msk, n);\n\t}\n\t\n\tprintf(\"%s\\n\", \"Impossible\");\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nint n;\nchar s[1010];\nvector<PII> ans,c;\nvector<PII> build(VI w) {\n  if (SZ(w)==1) return vector<PII>{{w[0],0}};\n  vector<PII> z{{w[0],0},{w[1],0},{w[0],1},{w[1],1}};\n  rep(i,2,SZ(w)) {\n    vector<PII> nz=z; \n    z.pb({w[i],0});\n    reverse(all(nz));\n    for (auto p:nz) z.pb({p.fi,p.se^1});\n    z.pb({w[i],1});\n  }\n  return z;\n}\nint zz;\nint main() {\n  scanf(\"%d\",&n);\n  scanf(\"%s\",s);\n  rep(i,0,(1<<n)) if (s[i]=='0') {\n    rep(j,0,(1<<n)) if ((j&i)==i&&s[j]=='1') {\n      puts(\"Impossible\");\n      return 0;\n    }\n    bool cc=0;\n    rep(j,0,(1<<n)) if ((i&j)==j&&i!=j&&s[j]=='0') cc=1;\n    if (cc) continue;\n    VI w;\n    rep(j,0,n) if (i&(1<<j)) w.pb(j);\n    auto x=build(w);\n    for (auto p:x) ans.pb(p);\n    zz++;\n    rep(i,0,n) ans.pb(mp(i,0));\n  }\n  rep(i,0,zz) per(j,0,n) ans.pb(mp(j,-1));\n  puts(\"Possible\");\n  int pos=0;\n  c.pb(mp(0,0));\n  for (auto p:ans) {\n    //printf(\"pp %d %d\\n\",p.fi,p.se);\n    if (p.se==0) {\n      while (pos<p.fi) {\n        pos+=1;\n        c.pb(mp(pos,0));\n      }\n      while (pos>p.fi) {\n        pos-=1;\n        c.pb(mp(pos,0));\n      }\n      c.pb(mp(pos,1));\n      c.pb(mp(pos+1,1));\n      c.pb(mp(pos+1,0));\n      pos+=1;\n    } else {\n      while (pos<p.fi+1) {\n        pos+=1;\n        c.pb(mp(pos,0));\n      }\n      while (pos>p.fi+1) {\n        pos-=1;\n        c.pb(mp(pos,0));\n      }\n      c.pb(mp(pos,1));\n      c.pb(mp(pos-1,1));\n      c.pb(mp(pos-1,0));\n      pos-=1;\n    }\n  }\n  while (pos>0) {\n    pos--;\n    c.pb(mp(pos,0));\n  }\n  printf(\"%d\\n\",SZ(c)-1);\n  for (auto x:c) printf(\"%d %d\\n\",x.fi,x.se);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n;\nchar p[260];\nstruct point {\n\tint x, ck, dir;\n};\nvector<point>Res;\nvector<point> Add(int x, int mask) {\n\tvector <point> r, T;\n\tif (mask == 1) {\n\t\tr.push_back({ x,0,0 });\n\t\tr.push_back({ x,1,1 });\n\t\treturn r;\n\t}\n\tif (!(mask&1)) {\n\t\tr.push_back({ x,0,0 });\n\t\tT = Add(x + 1, mask >> 1);\n\t\tr.insert(r.end(),T.begin(),T.end());\n\t\tr.push_back({ x,0,1 });\n\t\treturn r;\n\t}\n\tr.push_back({ x,0,0 });\n\tT = Add(x + 1, mask >> 1);\n\tr.insert(r.end(), T.begin(), T.end());\n\tr.push_back({ x,0,1 });\n\treverse(T.begin(), T.end());\n\tfor (int i = 0; i < T.size(); i++)T[i].dir = !T[i].dir;\n\tr.push_back({ x,1,0 });\n\tr.insert(r.end(), T.begin(), T.end());\n\tr.push_back({ x,1,1 });\n\treturn r;\n}\nstruct PP {\n\tint x, y;\n};\nvector<PP>RR;\nvoid Print(point a) {\n\tPP t1 = { a.x + a.dir, a.ck };\n\tPP t2 = { a.x + 1 - a.dir, a.ck };\n\tif (!RR.empty() && RR.back().x == t1.x && RR.back().y == t2.y) {\n\t\tRR.push_back(t2);\n\t}\n\telse {\n\t\tRR.push_back(t1);\n\t\tRR.push_back(t2);\n\t}\n}\nint main() {\n\tint i, j;\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", p);\n\tint s = 0;\n\tfor (i = 0; i < (1 << n); i++) {\n\t\tint c = 0;\n\t\tif (p[i] == '0')c++, s++;\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif ((i&j) == j) {\n\t\t\t\tif (p[j] == '0' && p[i] == '1') {\n\t\t\t\t\tputs(\"Impossible\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (p[j] == '0')c--;\n\t\t\t}\n\t\t}\n\t\tif (c == 1) {\n\t\t\tvector<point>T = Add(0, i);\n\t\t\tRes.insert(Res.end(), T.begin(), T.end());\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tif (!s) {\n\t\tprintf(\"0\\n0 0\\n\");\n\t\treturn 0;\n\t}\n\tfor (auto &t : Res) {\n\t\tPrint(t);\n\t}\n\tif (RR.back().x == RR[0].x && RR.back().y == RR[0].y)RR.pop_back();\n\tprintf(\"%d\\n\", RR.size());\n\tRR.push_back(RR[0]);\n\tfor(auto &t :RR)printf(\"%d %d\\n\", t.x, t.y);\n}"
  },
  {
    "language": "C++",
    "code": "// $%U%$ $%Y%$-$%M%$-$%D%$ $%h%$:$%m%$\n\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\tint n;\n\tstring s;\n\tcin>>n>>s;\n\tvector<bool> nc(n);\n\tfor(int x=0; x<s.size(); ++x){\n\t\tif(s[x]=='1'){\n\t\t\tfor(int i=0; i<n; ++i){\n\t\t\t\tif((x>>i)&1)nc[i]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int x=0; x<s.size(); ++x){\n\t\tif(s[x]=='0'){\n\t\t\tbool imp=1;\n\t\t\tfor(int i=0; i<n; ++i){\n\t\t\t\tif((x>>i)&1)if(!nc[i])imp=0;\n\t\t\t}\n\t\t\tif(imp){\n\t\t\t\tcout<<\"Impossible\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"Possible\\n\";\n\n\tvector<pair<int,int> > res;\n\tres.push_back({0,0});\n\tfor(int x=0; x<n; ++x){\n\t\tif(nc[x])res.push_back({x+1,0});\n\t\telse {\n\t\t\tres.push_back({x,1});\n\t\t\tres.push_back({x+1,1});\n\t\t\tres.push_back({x+1,0});\n\t\t}\n\t}\n\tres.push_back({0,0});\n\n\tcout<<res.size()-1<<'\\n';\n\tfor(auto &i:res)cout<<i.first<<' '<<i.second<<'\\n';\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<vector>\n#include<queue>\n#include<iostream>\n#include<fstream>\n#include<string>\n#include<cassert>\n#include<algorithm>\n#include<random>\n#include<map>\n#include<set>\n#include <bitset>\n#include<ctime>\n\nusing namespace std;\n\n//int mod = 998244353;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\ntypedef vector<int>vi;\ntypedef vector<ll>vl;\ntypedef vector<char>vc;\ntypedef vector<string>vs;\ntypedef vector<vector<int>>vii;\ntypedef vector<vector<char>>vvc;\ntypedef vector<vector<ll>>vll;\ntypedef vector< pair<ll, ll>>vpll;\ntypedef vector< pair<ld, ld>>vpld;\ntypedef vector< pair<int, int>>vpi;\ntypedef pair<ld, ld>pld;\n#define mp make_pair\n#define pb push_back\n\nconst int mod = 998244353;\nint add(int a, int b)\n{\n\tint c = a + b;\n\tif (c >= mod)\n\t{\n\t\tc -= mod;\n\t}\n\treturn c;\n}\nint dif(int a, int b)\n{\n\tint c = a - b;\n\tif (c < 0)\n\t{\n\t\tc += mod;\n\t}\n\treturn c;\n}\nint mlt(int a, int b)\n{\nll c = a * 1LL * b;\nreturn c % mod;\n}\nint ibit(int n, int i)\n{\n\treturn ((n >> i) & 1);\n}\nvoid outp(vii &ou)\n{\n\tfor (int i = 0; i < ou.size(); i++)\n\t{\n\t\tfor (int j = 0; j < ou[i].size(); j++)\n\t\t{\n\t\t\tcout << ou[i][j] << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n}\nint bp(int x, int y)\n{\n\tif (y == 0)\n\t{\n\t\treturn 1;\n\t}\n\tint a = 0;\n\tif (!(y % 2))\n\t{\n\t\ta = bp(x, y / 2);\n\t}\n\treturn (y % 2) ? mlt(bp(x, y - 1), x) : mlt(a, a);\n}\nint obr(int x)\n{\n\treturn bp(x, mod - 2);\n}\nconst int maxn = 2000007;\nint fact[2000007], ofact[2000007];\nvoid prec()\n{\n\tfact[0] = 1;\n\tofact[0] = 1;\n\tfor (int i = 1; i < maxn; i++)\n\t{\n\t\tfact[i] = mlt(fact[i - 1], i);\n\t}\n\t//cerr << \"sdsds\" << endl;\n\tofact[maxn - 1] = obr(fact[maxn - 1]);\n\tfor (int i = maxn - 2; i > 0; i--)\n\t{\n\t\tofact[i] = mlt(ofact[i + 1], i + 1);\n\t}\n}\nint c(int a, int b)\n{\n\tif (a == 0)return 1;\n\treturn ((a <= b) && (a >= 0)) ? mlt(fact[b], mlt(ofact[a], ofact[b - a])) : 0;\n}\nll gcd(ll x, ll y)\n{\n\t//cerr << x << y << endl;\n\tif (x == 0)return y;\n\treturn(x > y) ? gcd(y, x) : gcd(y%x, x);\n}\nint obr2(int n)\n{\n\tint x = fact[n - 1];\n\tx = mlt(x, ofact[n]);\n\treturn x;\n}\nvoid crv(int nn, vpi &v)\n{\n\tcerr << nn << endl;\n\tif (nn > 0) {\n\t\tint n = nn;\n\t\tfor (int i = 0; i < n; i++)v.pb({ i + 1, 0 });\n\t\tv.pb({ n,1 });\n\t\tv.pb({ n - 1, 1 });\n\t\tfor (int i = n - 1; i >= 0; i--)v.pb({ i, 0 });\n\t}\n\tif (nn < 0) {\n\t\tint n = -nn;\n\t\tfor (int i = 0; i < n-1; i++)v.pb({ i + 1, 0 });\n\t\tv.pb({ n-1,1 });\n\t\tv.pb({ n , 1 });\n\t\tfor (int i = n; i >= 0; i--)v.pb({ i, 0 });\n\t}\n}\nvoid solve(istream &cin = std::cin, ostream &cout = std::cout)\n{\n\tvii imb(8);\n\timb[0] = { 1 };\n\tfor (int i = 1; i < 8; i++)\n\t{\n\t\tfor (int j = 0; j < imb[i - 1].size(); j++)imb[i].pb(imb[i - 1][j]);\n\t\timb[i].pb(i + 1);\n\t\tfor (int j = imb[i - 1].size(); j >= 0; j--)imb[i].pb((-1)*imb[i - 1][j]);\n\t\timb[i].pb(-i - 1);\n\t}\n\t//cerr << \"here\" << endl;\n\tint n;\n\tcin >> n;\n\tvi good(1 << n);\n\tfor (int i = 0; i < good.size(); i++)\n\t{\n\t\tchar c;\n\t\tcin >> c;\n\t\tgood[i] = c - '0';\n\t}\n\tint val = 0;\n\t//\tcerr << 433 << endl;\n\tfor (int a = 0; a < good.size(); a++)\n\t\tfor (int b = 0; b < good.size(); b++)\n\t\t\tif ((a | b) == b)\n\t\t\t\tif ((!good[a]) && (good[b]))\n\t\t\t\t{\n\t\t\t\t\t//\tcerr << a << ' ' << b << endl;\n\t\t\t\t\tval = 1;\n\t\t\t\t}\n//\tcerr << 5 << ' ' << 7 << ' ' << (5 | 7) << endl;\n\tif (val)cout << \"Impossible\" << endl;\n\telse\n\t{\n\t\tcout << \"Possible\" << endl;\n\t\t//cerr << 1111 << endl;\n\t\tvpi ay = { {0,0} };\n\t\tfor (int m = 0; m < good.size(); m++)\n\t\t{\n\t\t\t//cerr << m << endl;\n\t\t\tif (!good[m])\n\t\t\t{\n\t\t\t\tcerr << m << endl;\n\t\t\t\tvi v;\n\t\t\t\tfor (int i = 0; i < 8; i++)if (ibit(m, i))v.pb(i);\n\t\t\t\tcerr << m << ' ' << v.size() << endl;\n\t\t\t\tfor (int i = 0; i < imb[v.size()-1].size(); i++)\n\t\t\t\t{\n\t\t\t\t\tcerr << imb[v.size() - 1][i] << endl;\n\t\t\t\t//\tcerr << i << endl;\n\t\t\t\t\tif (imb[v.size()][i] > 0)crv(v[imb[v.size()-1][i] - 1]+1, ay);\n\t\t\t\t\tif (imb[v.size()][i] < 0)crv(-v[(-imb[v.size()-1][i]) - 1]-1, ay);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ay.size()-1 << endl;\n\t\tfor (int i = 0; i < ay.size(); i++)cout << ay[i].first << ' ' << ay[i].second << endl;\n\t}\n}\nint main()\n{\n\tsolve();\n\tint n;\n\tcin >> n;\n}\n\n\t\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nint n;\nchar s[1010];\nvector<PII> ans,c,trash;\nvector<PII> build(VI w) {\n\tif (SZ(w)==1) return vector<PII>{{w[0],0}};\n\tvector<PII> z{{w[0],0},{w[1],0},{w[0],1},{w[1],1}};\n\trep(i,2,SZ(w)) {\n\t\tvector<PII> nz=z; \n\t\tz.pb({w[i],0});\n\t\treverse(all(nz));\n\t\tfor (auto p:nz) z.pb({p.fi,p.se^1});\n\t\tz.pb({w[i],1});\n\t}\n\treturn z;\n}\nint zz;\nint main() {\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s);\n\t//rep(i,0,(1<<n)) s[i]=(__builtin_popcount(i)<5)+'0';\n\trep(i,0,(1<<n)) rep(j,0,(1<<n)) if ((j&i)==i&&s[i]=='0'&&s[j]=='1') {\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\trep(i,0,(1<<n)) if (s[i]=='0') {\n\t\tbool cc=0;\n\t\trep(j,0,(1<<n)) if ((i&j)==j&&i!=j&&s[j]=='0') cc=1;\n\t\tif (cc) continue;\n\t\tVI w;\n\t\tfprintf(stderr,\"%d\\n\",i);\n\t\trep(j,0,n) if (i&(1<<j)) w.pb(j);\n\t\tauto x=build(w);\n\t\tfor (auto p:x) ans.pb(p);\n\t\tzz++;\n\t\t//rep(i,0,n) ans.pb(mp(i,0)),trash.pb(mp(i,0));\n\t\trep(i,0,100) {\n\t\t\tint x=rnd(n);\n\t\t\tans.pb(mp(x,(SZ(w)>=2))),trash.pb(mp(x,(SZ(w)>=2)));\n\t\t}\n\t}\n\t//fprintf(stderr,\"%d\\n\",zz);\n\treverse(all(trash));\n\tfor (auto p:trash) ans.pb(mp(p.fi,p.se^1));\n // rep(i,0,zz) per(j,0,n) ans.pb(mp(j,-1));\n\trep(i,0,(1<<n)) {\n\t\tstack<PII> s;\n\t\tfor (auto x:ans) {\n\t\t\tif (!(i&(1<<x.fi))) continue;\n\t\t\tif (!s.empty()&&s.top().fi==x.fi&&s.top().se==(x.se^1)) s.pop();\n\t\t\telse s.push(x);\n\t\t}\n\n\t\tif (s.empty()!=(::s[i]=='1')) {\n\t\t\tassert(0);\n\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tint pos=0;\n\tc.pb(mp(0,0));\n\tfor (auto p:ans) {\n\t\t//printf(\"pp %d %d\\n\",p.fi,p.se);\n\t\tif (p.se==0) {\n\t\t\twhile (pos<p.fi) {\n\t\t\t\tpos+=1;\n\t\t\t\tc.pb(mp(pos,0));\n\t\t\t}\n\t\t\twhile (pos>p.fi) {\n\t\t\t\tpos-=1;\n\t\t\t\tc.pb(mp(pos,0));\n\t\t\t}\n\t\t\tc.pb(mp(pos,1));\n\t\t\tc.pb(mp(pos+1,1));\n\t\t\tc.pb(mp(pos+1,0));\n\t\t\tpos+=1;\n\t\t} else {\n\t\t\twhile (pos<p.fi+1) {\n\t\t\t\tpos+=1;\n\t\t\t\tc.pb(mp(pos,0));\n\t\t\t}\n\t\t\twhile (pos>p.fi+1) {\n\t\t\t\tpos-=1;\n\t\t\t\tc.pb(mp(pos,0));\n\t\t\t}\n\t\t\tc.pb(mp(pos,1));\n\t\t\tc.pb(mp(pos-1,1));\n\t\t\tc.pb(mp(pos-1,0));\n\t\t\tpos-=1;\n\t\t}\n\t}\n\twhile (pos>0) {\n\t\tpos--;\n\t\tc.pb(mp(pos,0));\n\t}\n\tassert(SZ(c)<=250000);\n\tprintf(\"%d\\n\",SZ(c)-1);\n\tfor (auto x:c) printf(\"%d %d\\n\",x.fi,x.se);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<vector>\n#include<queue>\n#include<iostream>\n#include<fstream>\n#include<string>\n#include<cassert>\n#include<algorithm>\n#include<random>\n#include<map>\n#include<set>\n#include <bitset>\n#include<ctime>\n \nusing namespace std;\n \n//int mod = 998244353;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\ntypedef vector<int>vi;\ntypedef vector<ll>vl;\ntypedef vector<char>vc;\ntypedef vector<string>vs;\ntypedef vector<vector<int>>vii;\ntypedef vector<vector<char>>vvc;\ntypedef vector<vector<ll>>vll;\ntypedef vector< pair<ll, ll>>vpll;\ntypedef vector< pair<ld, ld>>vpld;\ntypedef vector< pair<int, int>>vpi;\ntypedef pair<ld, ld>pld;\n#define mp make_pair\n#define pb push_back\n \nconst int mod = 998244353;\nint add(int a, int b)\n{\n\tint c = a + b;\n\tif (c >= mod)\n\t{\n\t\tc -= mod;\n\t}\n\treturn c;\n}\nint dif(int a, int b)\n{\n\tint c = a - b;\n\tif (c < 0)\n\t{\n\t\tc += mod;\n\t}\n\treturn c;\n}\nint mlt(int a, int b)\n{\nll c = a * 1LL * b;\nreturn c % mod;\n}\nint ibit(int n, int i)\n{\n\treturn ((n >> i) & 1);\n}\nvoid outp(vii &ou)\n{\n\tfor (int i = 0; i < ou.size(); i++)\n\t{\n\t\tfor (int j = 0; j < ou[i].size(); j++)\n\t\t{\n\t\t\tcout << ou[i][j] << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n}\nint bp(int x, int y)\n{\n\tif (y == 0)\n\t{\n\t\treturn 1;\n\t}\n\tint a = 0;\n\tif (!(y % 2))\n\t{\n\t\ta = bp(x, y / 2);\n\t}\n\treturn (y % 2) ? mlt(bp(x, y - 1), x) : mlt(a, a);\n}\nint obr(int x)\n{\n\treturn bp(x, mod - 2);\n}\nconst int maxn = 2000007;\nint fact[2000007], ofact[2000007];\nvoid prec()\n{\n\tfact[0] = 1;\n\tofact[0] = 1;\n\tfor (int i = 1; i < maxn; i++)\n\t{\n\t\tfact[i] = mlt(fact[i - 1], i);\n\t}\n\t//cerr << \"sdsds\" << endl;\n\tofact[maxn - 1] = obr(fact[maxn - 1]);\n\tfor (int i = maxn - 2; i > 0; i--)\n\t{\n\t\tofact[i] = mlt(ofact[i + 1], i + 1);\n\t}\n}\nint c(int a, int b)\n{\n\tif (a == 0)return 1;\n\treturn ((a <= b) && (a >= 0)) ? mlt(fact[b], mlt(ofact[a], ofact[b - a])) : 0;\n}\nll gcd(ll x, ll y)\n{\n\t//cerr << x << y << endl;\n\tif (x == 0)return y;\n\treturn(x > y) ? gcd(y, x) : gcd(y%x, x);\n}\nint obr2(int n)\n{\n\tint x = fact[n - 1];\n\tx = mlt(x, ofact[n]);\n\treturn x;\n}\nvoid crv(int nn, vpi &v)\n{\n\tif (nn > 0) {\n\t\tint n = nn;\n\t\tfor (int i = 0; i < n; i++)v.pb({ i + 1, 0 });\n\t\tv.pb({ n,1 });\n\t\tv.pb({ n - 1, 1 });\n\t\tfor (int i = n - 1; i >= 0; i--)v.pb({ i, 0 });\n\t}\n\tif (nn < 0) {\n\t\tint n = -nn;\n\t\tfor (int i = 0; i < n-1; i++)v.pb({ i + 1, 0 });\n\t\tv.pb({ n-1,1 });\n\t\tv.pb({ n , 1 });\n\t\tfor (int i = n; i >= 0; i--)v.pb({ i, 0 });\n\t}\n}\nvoid solve(istream &cin = std::cin, ostream &cout = std::cout)\n{\n\tvii imb(8);\n\timb[0] = { 1 };\n\tfor (int i = 1; i < 8; i++)\n\t{\n\t\tfor (int j = 0; j < imb[i - 1].size(); j++)imb[i].pb(imb[i - 1][j]);\n\t\timb[i].pb(i + 1);\n\t\tfor (int j = imb[i - 1].size()-1; j >= 0; j--)imb[i].pb((-1)*imb[i - 1][j]);\n\t\timb[i].pb(-i - 1);\n\t}\n\t//cerr << \"here\" << endl;\n\tint n;\n\tcin >> n;\n\tvi good(1 << n);\n\tfor (int i = 0; i < good.size(); i++)\n\t{\n\t\tchar c;\n\t\tcin >> c;\n\t\tgood[i] = c - '0';\n\t}\n\tint val=0;\n//\tcerr << 433 << endl;\n\tfor(int a=0; a<good.size(); a++)\n\t\tfor(int b=0; b<good.size(); b++)\n\t\t\tif((a|b)==b)\n\t\t\t\tif ((!good[a]) && (good[b]))\n\t\t\t\t{\n\t\t\t\t//\tcerr << a << ' ' << b << endl;\n\t\t\t\t\tval = 1;\n\t\t\t\t}\n\tif (val)cout << \"Impossible\" << endl;\n\telse\n\t{\n\t\t//cerr << 1111 << endl;\n\t\tvpi ay = { {0,0} };\n\t\tfor (int m = 0; m < good.size(); m++)\n\t\t{\n\t\t\t//cerr << m << endl;\n\t\t\tif (!good[m])\n\t\t\t{\n\t\t\t\tvi v;\n\t\t\t\tfor (int i = 0; i < 8; i++)if (ibit(m, i))v.pb(i);\n\t\t\t\tfor (int i = 0; i < imb[v.size()-1].size(); i++)\n\t\t\t\t{\n\t\t\t\t//\tcerr << i << endl;\n\t\t\t\t\tif (imb[v.size()][i] > 0)crv(v[imb[v.size()-1][i] - 1], ay);\n\t\t\t\t\tif (imb[v.size()][i] < 0)crv(-v[(-imb[v.size()-1][i]) - 1], ay);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << \"Possible\" << endl;\n\t\tcout << ay.size() << endl;\n\t\tfor (int i = 0; i < ay.size(); i++)cout << ay[i].first << ' ' << ay[i].second << endl;\n\t}\n}\nint main()\n{\n\tsolve();\n\tint n;\n\tcin >> n;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define I inline\n#define fi first\n#define se second\n#define R register\n#define LL long long\n#define mp make_pair\n#define reg register int\n#define pii pair<int,int>\n#define fo(i, a, b) for(reg i = a; i <= b; i++)\n#define fd(i, a, b) for(reg i = a; i >= b; i--)\n#define cr const reg&\nusing namespace std;\n\nI int _max(cr x, cr y) {return x > y ? x : y;}\nI int _min(cr x, cr y) {return x < y ? x : y;}\nI int read() {\n\treg x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n\treturn x * f;\n}\nI void ptt(LL x) {if(x >= 10) ptt(x / 10); putchar(x % 10 + '0');}\nI void put(LL x) {x < 0 ? putchar('-'), ptt(-x) : ptt(x);}\nI void pr1(LL x) {put(x), putchar(' ');}\nI void pr2(LL x) {put(x), puts(\"\");}\n\nchar ss[1 << 8];\nvector<pii> ans;\n\nstring rev(string s) {\n\treverse(s.begin(), s.end());\n\tfo(i, 0, (int)s.size() - 1) {\n\t\tif(isupper(s[i])) s[i] += 'a' - 'A';\n\t\telse s[i] += 'A' - 'a';\n\t} return s;\n}\n\nint main() {\n\treg n = read();\n\tscanf(\"%s\", ss);\n\tif(ss[0] == '0') {puts(\"Impossible\"); return 0;}\n\treg S = (1 << n) - 1;\n\tfo(i, 1, S) {\n\t\tif(ss[i] == '1') {\n\t\t\tfo(j, 0, n - 1) if(i >> j & 1) {\n\t\t\t\tif(ss[i ^ (1 << j)] == '0') {puts(\"Impossible\"); return 0;}\n\t\t\t}\n\t\t}\n\t} puts(\"Possible\");\n\treg now = 0; ans.push_back(pii{0, 0});\n\tfo(i, 1, S) if(ss[i] == '0'){\n\t\tbool bk = 0;\n\t\tfo(j, 0, n - 1) if(i >> j & 1) {\n\t\t\tif(ss[i ^ (1 << j)] == '0') {bk = 1; break;}\n\t\t} if(bk) break;\n\t\tstring q; q.clear();\n\t\tfd(j, n - 1, 0) if(i >> j & 1){\n\t\t\tstring c1 = {char('a' + j)}, c2 = {char('A' + j)};\n\t\t\tif(q.empty()) q += c1;\n\t\t\telse q = c1 + q + c2 + rev(q);\n\t\t} for(char c : q) {\n\t\t\treg p, o;\n\t\t\tif(isupper(c)) p = c - 'A', o = 1;\n\t\t\telse p = c - 'a', o = 0;\n\t\t\tfo(j, now + 1, p) ans.push_back(pii{j, 0});\n\t\t\tfd(j, now - 1, p) ans.push_back(pii{j, 0});\n\t\t\tnow = p;\n\t\t\tif(!o) {\n\t\t\t\tans.push_back(pii{p, 1});\n\t\t\t\tans.push_back(pii{p + 1, 1});\n\t\t\t\tans.push_back(pii{p + 1, 0});\n\t\t\t\tans.push_back(pii{p, 0});\n\t\t\t} else {\n\t\t\t\tans.push_back(pii{p + 1, 0});\n\t\t\t\tans.push_back(pii{p + 1, 1});\n\t\t\t\tans.push_back(pii{p, 1});\n\t\t\t\tans.push_back(pii{p, 0});\n\t\t\t}\n\t\t}\n\t} fd(j, now - 1, 0) ans.push_back(pii{j, 0});\n\tpr2((int)ans.size() - 1);\n\tfo(i, 0, (int)ans.size() - 1) pr1(ans[i].fi), pr2(ans[i].se);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n#define MOD @\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nint N;\nchar A[300];\nvector<pair<int, int>> ans;\n\n/*\nvoid draw_curve(int mask, bool flip = false)\n{\n\tvector<pair<int, int>> seq;\n\tseq.push_back({0, 0});\n\tfor (int i = 0; i < N; ++i) {\n\t\tpair<int, int> src = make_pair(i, (mask >> i) & 1);\n\t\tpair<int, int> dest = make_pair(i + 1, (mask >> i) & 1);\n\t\tif (seq.back() != src) seq.push_back(src);\n\t\tseq.push_back(dest);\n\t}\n\tif (seq.back().second == 1) seq.push_back({N, 0});\n\tfor (int i = N - 1; i >= 0; --i) seq.push_back({i, 0});\n\tif (flip) reverse(seq.begin(), seq.end());\n\tfor (int i = 1; i < seq.size(); ++i) ans.push_back(seq[i]);\n}\n*/\nvoid draw_curve(int p, bool flip = false)\n{\n\tvector<pair<int, int>> seq;\n\tfor (int i = 0; i <= p; ++i) seq.push_back({i, 0});\n\tseq.push_back({p, 1});\n\tseq.push_back({p + 1, 1});\n\tfor (int i = p + 1; i >= 0; --i) seq.push_back({i, 0});\n\tif (flip) reverse(seq.begin(), seq.end());\n\tfor (int i = 1; i < seq.size(); ++i) ans.push_back(seq[i]);\n}\n\nint main()\n{\n\tscanf(\"%d%s\", &N, A);\n\tfor (int i = 0; i < (1 << N); ++i) {\n\t\tif (A[i] == '0') {\n\t\t\tfor (int j = 0; j < N; ++j) if ((i & (1 << j)) == 0) {\n\t\t\t\tif (A[i | (1 << j)] == '1') {\n\t\t\t\t\tputs(\"Impossible\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (A[0] == '0') {\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tputs(\"Possible\");\n\tvector<int> minima;\n\tfor (int i = 0; i < (1 << N); ++i) {\n\t\tif (A[i] == '0') {\n\t\t\tbool flg = true;\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tif ((i & (1 << j)) != 0 && A[i ^ (1 << j)] == '0') flg = false;\n\t\t\t}\n\t\t\tif (flg) minima.push_back(i);\n\t\t}\n\t}\n\tans.push_back({0, 0});\n\tfor (int m : minima) {\n\t\tvector<int> bits;\n\t\tfor (int i = 0; i < N; ++i) if (m & (1 << i)) bits.push_back(i);\n\t\tvector<int> seq;\n\t\tseq.push_back(bits[0]);\n\t\tfor (int i = 1; i < bits.size(); ++i) {\n\t\t\tvector<int> seq2;\n\t\t\tbool flg = false;\n\t\t\tfor (int j = 0; j < seq.size(); ++j) {\n\t\t\t\tseq2.push_back(seq[j]);\n\t\t\t\tif (flg) seq2.push_back(~bits[i]);\n\t\t\t\telse seq2.push_back(bits[i]);\n\t\t\t\tflg = !flg;\n\t\t\t}\n\t\t\tfor (int j = seq.size() - 1; j >= 0; --j) {\n\t\t\t\tseq2.push_back(~seq[j]);\n\t\t\t\tif (flg) seq2.push_back(~bits[i]);\n\t\t\t\telse seq2.push_back(bits[i]);\n\t\t\t\tflg = !flg;\n\t\t\t}\n\t\t\tseq = seq2;\n\t\t}\n\t\tfor (int i = 0; i < seq.size(); ++i) {\n\t\t\t//if (seq[i] >= 0) printf(\"%d \", seq[i]);\n\t\t\t//else printf(\"!%d \", ~seq[i]);\n\t\t\tif (seq[i] >= 0) draw_curve(seq[i]);\n\t\t\telse draw_curve(~seq[i]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans.size() - 1);\n\tfor (auto p : ans) printf(\"%d %d\\n\", p.first, p.second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <decimal/decimal>\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define rep(i, s, t) for (int i = s; i < int(t); ++i)\n\n#define sc\tscanf\n#define pr\tprintf\n#define ff\tfirst\n#define ss\tsecond\n#define mp\tmake_pair\n#define pb\tpush_back\n#define eb\templace_back\n#define range(c)\tc.begin(), c.end()\n#define lowbit(x)\t((x) & -(x))\n#define pop_count\t__builtin_popcount\n#define pop_count_64\t__builtin_popcountll\n#define tail_count\t__builtin_ctz\n#define tail_count_64\t__builtin_ctzll\n#define lead_count\t__builtin_clz\n#define lead_count_64\t__builtin_clzll\n\n#define TEMP template<typename\n#define CONST(type) constexpr type const\n\nTEMP... Ts> struct is_con { static CONST(bool) value = false; };\nTEMP... Ts> struct is_con<vector<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<list<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<deque<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<set<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<unordered_set<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<map<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<unordered_map<Ts...>> { static CONST(bool) value = true; };\n\nTEMP T1, typename T2> ostream& operator<<(ostream& os, pair<T1, T2> const& p) { return os << \"<\" << p.ff << \",\" << p.ss << \">\"; }\nTEMP T> typename enable_if<is_con<T>::value, ostream>::type& operator<<(ostream& os, T const& c) {\n\tos << \"{\";\n\tbool first = true;\n\tfor (auto const& x : c) {\n\t\tif (first) first = false;\n\t\telse os << \",\";\n\t\tos << \" \" << x;\n\t}\n\treturn os << \" }\";\n}\n\nTEMP T, typename... Ts> void dbg(T h, Ts... t) { cerr << \" \" << h; dbg<Ts...>(t...); }\ntemplate<> void dbg<int>(int x) { cerr << endl; }\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[ \"#__VA_ARGS__\" ] :\", dbg(__VA_ARGS__, 0)\n#else\n#define debug(...) 0\n#endif\n\nTEMP T, typename U> using ordered_map = tree<T, U, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\nTEMP T> using ordered_set = ordered_map<T, null_type>;\n\ntypedef long long i64;\ntypedef decimal::decimal128 i99;\ntypedef unsigned int u32;\ntypedef unsigned long long u64;\ntypedef float f32;\ntypedef double f64;\ntypedef long double f80;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<i64> vl;\n\nTEMP T> T& minn(T& lhs, T const& rhs) { return lhs = min(lhs, rhs); }\nTEMP T> T& maxx(T& lhs, T const& rhs) { return lhs = max(lhs, rhs); }\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n;\n\tstring a;\n\tcin >> n >> a;\n\tvi dp(1 << n);\n\trep(s, 0, 1 << n) dp[s] = a[s] == '0';\n\tdebug(dp);\n\trep(i, 0, n) rep(s, 0, 1 << n) if (s >> i & 1) dp[s] |= dp[s ^ 1 << i];\n\tdebug(dp);\n\tbool ok = true;\n\trep(s, 0, 1 << n) ok &= dp[s] ^ (a[s] == '1');\n\tvi clique;\n\trep(s, 0, 1 << n) if (dp[s]) {\n\t\tbool check = true;;\n\t\trep(t, 0, 1 << n) if (t != s && (s & t) == t) check &= !dp[t];\n\t\tif (check) clique.pb(s);\n\t}\n\tint tot = 0, cnt = 0;\n\tfor (int s : clique) {\n\t\tint x = pop_count(s);\n\t\tok &= x <= 2;\n\t\ttot |= s;\n\t}\n\tif (!ok) return cout << \"Impossible\" << endl, 0;\n\tcout << \"Possible\" << endl;\n\tdebug(clique);\n\tvector<pii> ans(1);\n\tfor (int s : clique) {\n\t\tif (s == lowbit(s)) {\n\t\t\tint x = tail_count(s);\n\t\t\trep(i, 1, x + 1) ans.eb(i, 0);\n\t\t\tans.eb(x + 1, 0);\n\t\t\tans.eb(x + 1, 1);\n\t\t\tans.eb(x, 1);\n\t\t\tfor (int i = x; i >= 0; --i) ans.eb(i, 0);\n\t\t} else {\n\t\t\tint x = tail_count(s);\n\t\t\ts ^= lowbit(s);\n\t\t\tint y = tail_count(s);\n\t\t\trep(i, 1, y + 1) ans.eb(i, 0);\n\t\t\tans.eb(y + 1, 0);\n\t\t\tans.eb(y + 1, 1);\n\t\t\tans.eb(y, 1);\n\t\t\tfor (int i = y; i >= x; --i) ans.eb(i, 0);\n\t\t\trep(i, x, y + 2) ans.eb(i, 1);\n\t\t\tfor (int i = y + 1; i > x; --i) ans.eb(i, 0);\n\t\t\tans.eb(x + 1, 1);\n\t\t\tans.eb(x, 1);\n\t\t\tfor (int i = x; i >= 0; --i) ans.eb(i, 0);\n\t\t}\n\t}\n\tcout << ans.size() - 1 << endl;\n\tfor (auto const& p : ans) cout << p.ff << \" \" << p.ss << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nstring A;\n\nbool isValid(int msk) {\n    for (int x = 0; x < (1<<n); x++) {\n        if (A[x]=='1') {\n            if (x&msk) return false;\n        } else {\n            if ((x&msk)==0) return false;\n        }\n    }\n    return true;\n}\n\ntypedef pair< int , int >PII;\nvoid printSolution(int msk) {\n    vector< PII >vp;\n    for (int i = 0; i < n; i++) {\n        vp.emplace_back(i, 0);\n        if (msk&(1<<i)) {\n            vp.emplace_back(i, 1);\n            vp.emplace_back(i+1, 1);\n        }\n    }\n    for (int i = n; i >= 0; i--) vp.emplace_back(i, 0);\n\n    cout << \"Possible\" << endl;\n    cout << vp.size()-1 << endl;\n    for (PII p : vp) cout << p.first << \" \" << p.second << endl;\n}\n\nint main() {\n    cin >> n;\n    cin >> A;\n\n    for (int msk = 0; msk < (1<<n); msk++) {\n        if (isValid(msk)) {\n            printSolution(msk);\n            return 0;\n        }\n    }\n\n    cout << \"Impossible\" << endl;\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#ifdef __LOCAL\n    #define DBG(X) cout << #X << \" = \" << (X) << endl;\n    #define SAY(X) cout << (X) << endl;\n#else\n    #define DBG(X)\n    #define SAY(X)\n#endif\n\n#ifdef __LOCAL\n    #include <filesystem>\n    namespace fs = std::filesystem;\n#endif\n\nusing namespace std;\n\nusing ll = long long int;\nusing ull = unsigned long long int;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\nint dx[]={1, 0, -1, 0, 1,-1, 1,-1};\nint dy[]={0, 1, 0, -1, 1, 1,-1,-1};\nconst int INT_INF = (int)(2e9);\nconst ll  LL_INF = (ll)(2e18);\nstatic mt19937 _g(time(nullptr));\n \ninline ll randint(ll a, ll b) { ll w = (_g() << 31LL) ^ _g(); return a + w % (b - a + 1); }\ninline void fast_io() { ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); };\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const pair<T, S> p) { cout << \"[\" << p.first << \";\" << p.second << \"]\"; return os; }\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const map<T, S> p) { for (auto el : p) cout << \"[\" << el.first << \";\" << el.second << \"]\"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const vector<T>& v) { for (auto el : v) cout << el << \" \"; return os; }\ntemplate<typename T> inline vector<T> fetch_vec(int sz) { vector<T> ret(sz); for (auto& elem : ret) cin >> elem; return ret; }\n\nint N;\nstring A;\nvoid input(){\n    fast_io();\n    #ifdef __LOCAL\n        fs::path p = __FILE__;\n        fs::path input,output;\n        input = output = p.parent_path();\n        input += string(\"/input/\") + string(p.stem()) + string(\".txt\");\n        output += string(\"/output/\") + string(p.stem()) + string(\".txt\");\n        freopen(input.c_str(), \"r\", stdin);\n        freopen(output.c_str(), \"w\", stdout);\n    #endif\n    cin >> N;\n    cin >> A;\n}\n\nint high,low;\n\n// 穴を開ける場所1が飛び地になってないか確認。\n// 01110000：OK\n// 01100110：NG\nbool isOK(ll bit){\n    string bitstr = bitset<10>(bit).to_string();\n    bool ishole = false;\n    bool issecvoid = false;\n    bool issechole = false;\n    for (int i = 0; i < 10; i++)\n    {\n        if(bitstr[i]=='0'){\n            if(ishole){\n                if(!issecvoid) low = 10-(i-1);\n                issecvoid = true;\n            }\n        }\n        if(bitstr[i]=='1'){\n            if(!ishole) high = 10-i;\n            if(issecvoid) return false;\n            ishole=true;\n            }\n    }\n    if(!issecvoid) low=0;\n    return true;\n}\n\nbool isNotcontradict(ll bit, ll bitA){\n    if(bit&bitA==bit)\n        return (A[bit]=='0');\n    else\n        return (A[bit]=='1');    \n}\n\nint solve(){\n    if(A[0]=='0'){cout << \"Impossible\" << endl; return 0;}\n    ll bitA=0LL;\n    for (int i = 0; i < N; i++)\n    {\n        bitA |= (A[(1<<i)]=='0');\n    }\n    if(!isOK(bitA)){cout << \"Impossible\" << endl; return 0;}\n    for (int bit = 0; bit < (1<<N); bit++)\n    {\n        if(isNotcontradict(bit,bitA)) continue;\n        else{cout << \"Impossible\" << endl; return 0;}\n    }\n    ll L=2+2*(high-low);\n    cout << \"Possible\" << endl;\n    cout << L << endl;\n    cout << low  << \" \" << 0 << endl;    \n    cout << high << \" \" << 0 << endl;    \n    cout << high << \" \" << 1 << endl;    \n    cout << low  << \" \" << 1 << endl;    \n    return 0;\n}   \n\nint main()\n{\n    input();\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\nCode for problem E by cookiedoth\nGenerated 21 Mar 2020 at 05.19 PM\n\n\n______▄███████▄_______\n______█▄█████▄█_______\n______█▼▼▼▼▼█_______\n_____██________ ██______\n______█▲▲▲▲▲█_______\n______█████████_______\n_______██____ ██________\n\n>_<\no_O\n^_^\n\n*/\n\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <ctime>\n#include <functional>\n#include <unordered_set>\n#include <unordered_map>\n#include <string>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <complex>\n#include <cassert>\n#include <random>\n#include <cstring>\n#include <numeric>\n#define ll long long\n#define ld long double\n#define null NULL\n#define all(a) a.begin(), a.end()\n#define rall(a) a.rbegin(), a.rend()\n#define debug(a) cerr << #a << \" = \" << a << endl\n#define forn(i, n) for (int i = 0; i < n; ++i)\n#define sz(a) (int)a.size()\n\nusing namespace std;\n\ntemplate<class T> int chkmax(T &a, T b) {\n\tif (b > a) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\ntemplate<class T> int chkmin(T &a, T b) {\n\tif (b < a) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\ntemplate<class iterator> void output(iterator begin, iterator end, ostream& out = cerr) {\n\twhile (begin != end) {\n\t\tout << (*begin) << \" \";\n\t\tbegin++;\n\t}\n\tout << endl;\n}\n\ntemplate<class T> void output(T x, ostream& out = cerr) {\n\toutput(x.begin(), x.end(), out);\n}\n\nvoid fast_io() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n}\n\nint x;\nvector<pair<int, int> > ans;\n\nvoid move(int dest_x) {\n\tif (x == dest_x) {\n\t\treturn;\n\t}\n\tif (dest_x > x) {\n\t\tx++;\n\t\tans.emplace_back(x, 0);\n\t} else {\n\t\tx--;\n\t\tans.emplace_back(x, 0);\n\t}\n\tmove(dest_x);\n}\n\nvoid use(int pos, int d) {\n\t// cerr << \"use \" << pos << \" \" << d << endl;\n\tif (d == 0) {\n\t\tmove(pos);\n\t\tans.emplace_back(pos, 1);\n\t\tans.emplace_back(pos + 1, 1);\n\t\tans.emplace_back(pos + 1, 0);\n\t\tx++;\n\t} else {\n\t\tmove(pos + 1);\n\t\tans.emplace_back(pos + 1, 1);\n\t\tans.emplace_back(pos, 1);\n\t\tans.emplace_back(pos, 0);\n\t\tx--;\n\t}\n}\n\nconst int mx = 300;\nint n, a[mx];\n\nvector<vector<pair<int, int> > > str;\n\nvoid gen_str() {\n\tstr.resize(n + 1);\n\tstr[1] = {{0, 0}};\n\tfor (int i = 2; i <= n; ++i) {\n\t\tstr[i].emplace_back(i - 1, 0);\n\t\tfor (auto pp : str[i - 1]) {\n\t\t\tstr[i].push_back(pp);\n\t\t}\n\t\tstr[i].emplace_back(i - 1, 1);\n\t\tfor (auto pp : str[i - 1]) {\n\t\t\tstr[i].emplace_back(pp.first, pp.second ^ 1);\n\t\t}\n\t\t// cerr << \"i = \" << i << endl;\n\t\t// for (auto pp : str[i]) {\n\t\t// \tcerr << pp.first << \" \" << pp.second << endl;\n\t\t// }\n\t}\n}\n\nvoid make(int sub) {\n\tvector<int> have;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif ((sub >> i) & 1) {\n\t\t\thave.push_back(i);\n\t\t}\n\t}\n\tint k = __builtin_popcount(sub);\n\tfor (auto pp : str[k]) {\n\t\tuse(have[pp.first], pp.second);\n\t}\n}\n\nsigned main() {\n\tfast_io();\n\tans.emplace_back(0, 0);\n\tcin >> n;\n\tgen_str();\n\tfor (int i = 0; i < (1 << n); ++i) {\n\t\tchar c;\n\t\tcin >> c;\n\t\ta[i] = c - '0';\n\t}\n\tif (a[0] == 0) {\n\t\tcout << \"Impossible\" << endl;\n\t\texit(0);\n\t}\n\tfor (int i = 0; i < (1 << n); ++i) {\n\t\tfor (int j = 0; j < i; ++j) {\n\t\t\tif (a[i] == 1 && ((i & j) == j) && a[j] == 0) {\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < (1 << n); ++i) {\n\t\tif (a[i] == 0) {\n\t\t\tint ok = 1;\n\t\t\tfor (int j = 0; j < i; ++j) {\n\t\t\t\tif (a[j] == 0 && (i & j) == j) {\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tmake(i);\n\t\t\t}\n\t\t}\n\t}\n\tmove(0);\n\tcout << \"Possible\" << \"\\n\";\n\tcout << (int)ans.size() - 1 << \"\\n\";\n\tfor (auto pp : ans) {\n\t\tcout << pp.first << \" \" << pp.second << \"\\n\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\nCode for problem E by cookiedoth\nGenerated 21 Mar 2020 at 05.19 PM\n\n\n______▄███████▄_______\n______█▄█████▄█_______\n______█▼▼▼▼▼█_______\n_____██________ ██______\n______█▲▲▲▲▲█_______\n______█████████_______\n_______██____ ██________\n\n>_<\no_O\n^_^\n\n*/\n\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <ctime>\n#include <functional>\n#include <unordered_set>\n#include <unordered_map>\n#include <string>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <complex>\n#include <cassert>\n#include <random>\n#include <cstring>\n#include <numeric>\n#define ll long long\n#define ld long double\n#define null NULL\n#define all(a) a.begin(), a.end()\n#define rall(a) a.rbegin(), a.rend()\n#define debug(a) cerr << #a << \" = \" << a << endl\n#define forn(i, n) for (int i = 0; i < n; ++i)\n#define sz(a) (int)a.size()\n\nusing namespace std;\n\ntemplate<class T> int chkmax(T &a, T b) {\n\tif (b > a) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\ntemplate<class T> int chkmin(T &a, T b) {\n\tif (b < a) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\ntemplate<class iterator> void output(iterator begin, iterator end, ostream& out = cerr) {\n\twhile (begin != end) {\n\t\tout << (*begin) << \" \";\n\t\tbegin++;\n\t}\n\tout << endl;\n}\n\ntemplate<class T> void output(T x, ostream& out = cerr) {\n\toutput(x.begin(), x.end(), out);\n}\n\nvoid fast_io() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n}\n\nint x;\nvector<pair<int, int> > ans;\n\nvoid move(int dest_x) {\n\tif (x == dest_x) {\n\t\treturn;\n\t}\n\tif (dest_x > x) {\n\t\tx++;\n\t\tans.emplace_back(x, 0);\n\t} else {\n\t\tx--;\n\t\tans.emplace_back(x, 0);\n\t}\n\tmove(dest_x);\n}\n\nvoid use(int pos, int d) {\n\tif (d == 0) {\n\t\tmove(pos);\n\t\tans.emplace_back(pos, 1);\n\t\tans.emplace_back(pos + 1, 1);\n\t\tans.emplace_back(pos + 1, 0);\n\t\tx++;\n\t} else {\n\t\tmove(pos + 1);\n\t\tans.emplace_back(pos, 1);\n\t\tans.emplace_back(pos - 1, 1);\n\t\tans.emplace_back(pos - 1, 0);\n\t\tx--;\n\t}\n}\n\nconst int mx = 300;\nint n, a[mx];\n\nvector<vector<pair<int, int> > > str;\n\nvoid gen_str() {\n\tstr.resize(n + 1);\n\tstr[1] = {{0, 0}};\n\tfor (int i = 2; i <= n; ++i) {\n\t\tstr[i].emplace_back(i - 1, 0);\n\t\tfor (auto pp : str[i - 1]) {\n\t\t\tstr[i].push_back(pp);\n\t\t}\n\t\tstr[i].emplace_back(i - 1, i);\n\t\tfor (auto pp : str[i - 1]) {\n\t\t\tstr[i].emplace_back(pp.first, pp.second ^ 1);\n\t\t}\n\t}\n}\n\nvoid make(int sub) {\n\tvector<int> have;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif ((sub >> i) & 1) {\n\t\t\thave.push_back(i);\n\t\t}\n\t}\n\tint k = __builtin_popcount(sub);\n\tfor (auto pp : str[k]) {\n\t\tuse(have[pp.first], pp.second);\n\t}\n}\n\nsigned main() {\n\tfast_io();\n\tcin >> n;\n\tgen_str();\n\tfor (int i = 0; i < (1 << n); ++i) {\n\t\tchar c;\n\t\tcin >> c;\n\t\ta[i] = c - '0';\n\t}\n\tfor (int i = 0; i < (1 << n); ++i) {\n\t\tfor (int j = 0; j < i; ++j) {\n\t\t\tif (a[i] == 1 && ((i & j) == j) && a[j] == 0) {\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < (1 << n); ++i) {\n\t\tif (a[i] == 0) {\n\t\t\tint ok = 1;\n\t\t\tfor (int j = 0; j < i; ++j) {\n\t\t\t\tif (a[j] == 0 && (i & j) == j) {\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tmake(i);\n\t\t\t}\n\t\t}\n\t}\n\tmove(0);\n\tcout << \"Possible\" << \"\\n\";\n\tcout << ans.size() << \"\\n\";\n\tfor (auto pp : ans) {\n\t\tcout << pp.first << \" \" << pp.second << \"\\n\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n;\n    string a;\n    cin >> n >> a;\n    vector<int> b;\n    for(int i = 0; i < 1 << n; i++) {\n        int x = 0;\n        for(int &k : b) {\n            if(a[0] == '0' || a[i] == '1' && (k & i) == k) {\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n            if((k & i) == k)\n                x = 1;\n            if(a[i] == '0' && (k & i) == i)\n                k = i, x = 1;\n        }\n        if(a[i] == '0' && !x)\n            b.push_back(i);\n        sort(b.begin(), b.end());\n        int j = unique(b.begin(), b.end()) - b.begin();\n        b.resize(j);\n    }\n    cout << \"Possible\\n\";\n    stringstream ss;\n    int l = 0;\n    for(int k : b) {\n        int j = 0, u = 0;\n        for(int i = 0; i < 10; i++) {\n            if(!(k & 1 << i))\n                continue;\n            u++;\n            for(; j <= i; j++)\n                ss << j << \" 0\\n\", l++;\n            ss << i << \" 1\\n\" << i + 1 << \" 1\\n\" << i + 1 << \" 0\\n\", l += 3;\n            j = i;\n        }\n        if(u > 1) {\n            if(j)\n                for(; j >= 1; j--)\n                    ss << j << \" 0\\n\", l++;\n            j = 0;\n            for(int i = 0; i < 10; i++) {\n                if(!(k & 1 << i))\n                    continue;\n                for(; j <= i; j++)\n                    ss << j << \" 0\\n\", l++;\n                ss << i + 1 << \" 0\\n\" << i + 1 << \" 1\\n\" << i << \" 1\\n\", l += 3;\n                j = i;\n            }\n        }\n        if(j)\n            for(; j >= 1; j--)\n                ss << j << \" 0\\n\", l++;\n    }\n    ss << \"0 0\\n\";\n    cout << l << '\\n' << ss.str() << flush;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\nCode for problem E by cookiedoth\nGenerated 21 Mar 2020 at 05.19 PM\n\n\n______▄███████▄_______\n______█▄█████▄█_______\n______█▼▼▼▼▼█_______\n_____██________ ██______\n______█▲▲▲▲▲█_______\n______█████████_______\n_______██____ ██________\n\n>_<\no_O\n^_^\n\n*/\n\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <ctime>\n#include <functional>\n#include <unordered_set>\n#include <unordered_map>\n#include <string>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <complex>\n#include <cassert>\n#include <random>\n#include <cstring>\n#include <numeric>\n#define ll long long\n#define ld long double\n#define null NULL\n#define all(a) a.begin(), a.end()\n#define rall(a) a.rbegin(), a.rend()\n#define debug(a) cerr << #a << \" = \" << a << endl\n#define forn(i, n) for (int i = 0; i < n; ++i)\n#define sz(a) (int)a.size()\n\nusing namespace std;\n\ntemplate<class T> int chkmax(T &a, T b) {\n\tif (b > a) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\ntemplate<class T> int chkmin(T &a, T b) {\n\tif (b < a) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\ntemplate<class iterator> void output(iterator begin, iterator end, ostream& out = cerr) {\n\twhile (begin != end) {\n\t\tout << (*begin) << \" \";\n\t\tbegin++;\n\t}\n\tout << endl;\n}\n\ntemplate<class T> void output(T x, ostream& out = cerr) {\n\toutput(x.begin(), x.end(), out);\n}\n\nvoid fast_io() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n}\n\nint x;\nvector<pair<int, int> > ans;\n\nvoid move(int dest_x) {\n\tif (x == dest_x) {\n\t\treturn;\n\t}\n\tif (dest_x > x) {\n\t\tx++;\n\t\tans.emplace_back(x, 0);\n\t} else {\n\t\tx--;\n\t\tans.emplace_back(x, 0);\n\t}\n\tmove(dest_x);\n}\n\nvoid use(int pos, int d) {\n\t// cerr << \"use \" << pos << \" \" << d << endl;\n\tif (d == 0) {\n\t\tmove(pos);\n\t\tans.emplace_back(pos, 1);\n\t\tans.emplace_back(pos + 1, 1);\n\t\tans.emplace_back(pos + 1, 0);\n\t\tx++;\n\t} else {\n\t\tmove(pos + 1);\n\t\tans.emplace_back(pos, 1);\n\t\tans.emplace_back(pos - 1, 1);\n\t\tans.emplace_back(pos - 1, 0);\n\t\tx--;\n\t}\n}\n\nconst int mx = 300;\nint n, a[mx];\n\nvector<vector<pair<int, int> > > str;\n\nvoid gen_str() {\n\tstr.resize(n + 1);\n\tstr[1] = {{0, 0}};\n\tfor (int i = 2; i <= n; ++i) {\n\t\tstr[i].emplace_back(i - 1, 0);\n\t\tfor (auto pp : str[i - 1]) {\n\t\t\tstr[i].push_back(pp);\n\t\t}\n\t\tstr[i].emplace_back(i - 1, 1);\n\t\tfor (auto pp : str[i - 1]) {\n\t\t\tstr[i].emplace_back(pp.first, pp.second ^ 1);\n\t\t}\n\t\t// cerr << \"i = \" << i << endl;\n\t\t// for (auto pp : str[i]) {\n\t\t// \tcerr << pp.first << \" \" << pp.second << endl;\n\t\t// }\n\t}\n}\n\nvoid make(int sub) {\n\tvector<int> have;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif ((sub >> i) & 1) {\n\t\t\thave.push_back(i);\n\t\t}\n\t}\n\tint k = __builtin_popcount(sub);\n\tfor (auto pp : str[k]) {\n\t\tuse(have[pp.first], pp.second);\n\t}\n}\n\nsigned main() {\n\tfast_io();\n\tans.emplace_back(0, 0);\n\tcin >> n;\n\tgen_str();\n\tfor (int i = 0; i < (1 << n); ++i) {\n\t\tchar c;\n\t\tcin >> c;\n\t\ta[i] = c - '0';\n\t}\n\tfor (int i = 0; i < (1 << n); ++i) {\n\t\tfor (int j = 0; j < i; ++j) {\n\t\t\tif (a[i] == 1 && ((i & j) == j) && a[j] == 0) {\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < (1 << n); ++i) {\n\t\tif (a[i] == 0) {\n\t\t\tint ok = 1;\n\t\t\tfor (int j = 0; j < i; ++j) {\n\t\t\t\tif (a[j] == 0 && (i & j) == j) {\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tmake(i);\n\t\t\t}\n\t\t}\n\t}\n\tmove(0);\n\tcout << \"Possible\" << \"\\n\";\n\tcout << (int)ans.size() - 1 << \"\\n\";\n\tfor (auto pp : ans) {\n\t\tcout << pp.first << \" \" << pp.second << \"\\n\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nchar A[1<<8|1];\nint main(){\n\tint N,S=0,cnt=0;scanf(\"%d%s\",&N,A);\n\tfor(int i=0;i<N;i++)if(A[1<<i]=='0')S|=1<<i,cnt++;\n\tfor(int T=0;T<1<<N;T++)\n\t\tif((A[T]=='1')!=!(S&T))return puts(\"Impossible\"),0;\n\tprintf(\"Possible\\n%d\\n\",N*2+cnt*2);\n\tfor(int i=0;i<N;i++){\n\t\tprintf(\"%d 0\\n\",i);\n\t\tif(S>>i&1)printf(\"%d 1\\n%d 1\\n\",i,i+1);\n\t}\n\tfor(int i=N;i>=0;i--)printf(\"%d 0\\n\",i);\n}"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\n\nconst int mod = 1e9+7;\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nint n;\nchar s[256];\nchar revc(char c)\n{\n\tif (c>='a'&&c<='z') return 'A'+c-'a';\n\telse return 'a'+c-'A';\n}\nstring getf(int msk)\n{\n\tstring ret;\n\tif (__builtin_popcount(msk)==1)\n\t{\n\t\tret.PB(__builtin_ctz(msk)+'a');\n\t\treturn ret;\n\t}\n\telse\n\t{\n\t\tint x = __builtin_ctz(msk&(-msk));\n\t\tint nmsk = msk-(1<<x);\n\t\tstring t = getf(nmsk);\n\t\tret += t;\n\t\tret.PB('a'+x);\n\t\treverse(t.begin(), t.end());\n\t\tfor (int i=0; i<t.size(); i++) t[i] = revc(t[i]);\n\t\tret += t;\n\t\tret.PB('A'+x);\n\t\treturn ret;\n\t}\n}\nvector<pair<int,int> > rt;\nint curx, cury;\nvoid go(int x, int y)\n{\n\twhile (curx<x) curx++, rt.PB(MP(curx, cury));\n\twhile (curx>x) curx--, rt.PB(MP(curx, cury));\n\twhile (cury<y) cury++, rt.PB(MP(curx, cury));\n\twhile (cury>y) cury--, rt.PB(MP(curx, cury));\n}\nvoid out(string s)\n{\n\tassert(s.size()<250000);\n\tcurx = cury = 0;\n\trt.PB(MP(0, 0));\n\n\tfor (int i=0; i<s.size(); i++)\n\t{\n\t\tbool f;\n\t\tint x;\n\t\tif (s[i]>='a'&&s[i]<='z')\n\t\t{\n\t\t\tf = true;\n\t\t\tx = s[i]-'a';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tf = false;\n\t\t\tx = s[i]-'A';\n\t\t}\n\t\tif (f)\n\t\t{\n\t\t\tgo(x, 0);\n\t\t\tgo(x, 1);\n\t\t\tgo(x+1, 1);\n\t\t\tgo(x+1, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgo(x+1, 0);\n\t\t\tgo(x+1, 1);\n\t\t\tgo(x, 1);\n\t\t\tgo(x, 0);\n\t\t}\n\t}\n\tgo(0, 0);\n}\nint main()\n{\n\tcin>>n;\n\tcin>>s;\n\tfor (int i=0; i<(1<<n); i++)\n\t{\n\t\tif (s[i]=='1')\n\t\t{\n\t\t\tfor (int j=0; j<(1<<n); j++)\n\t\t\t{\n\t\t\t\tif ((i&j)==j&&s[j]=='0')\n\t\t\t\t{\n\t\t\t\t\tputs(\"Impossible\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tstring ans;\n\tvector<int> v;\n\tfor (int i=0; i<(1<<n); i++)\n\t{\n\t\tif (s[i]=='0')\n\t\t{\n\t\t\tv.PB(i);\n\t\t}\n\t}\n\trandom_shuffle(v.begin(), v.end());\n\tfor (auto x : v) ans += getf(x);\n\trandom_shuffle(v.begin(), v.end());\n\tfor (auto x : v) ans += getf(x);\n\trandom_shuffle(v.begin(), v.end());\n\tfor (auto x : v) ans += getf(x);\n\t\n\tout(ans);\n\tputsi(rt.size()-1);\n\tfor (int i=0; i<rt.size(); i++) putsii(rt[i].FF, rt[i].SS);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main() {\n  ll N; cin >> N;\n  ll a[1 << N];\n  for (ll i = 0; i < (1 << N); i++) {\n    char c; cin >> c;\n    a[i] = c - '0';\n  }\n  ll b[N];\n  for (ll i = 0; i < N; i++) {\n    b[i] = !a[1 << i];\n    //cout << b[i] << endl;\n  }\n  for (ll bits = 0; bits < (1 << N); bits++) {\n    bool dots = false;\n    for (ll i = 0; i < N; i++) {\n      if ((bits >> i) & 1) dots |= b[i];\n    }\n    //cout << dots << endl;\n    if (!(a[bits]^dots)) {\n      cout << \"Impossible\" << endl;\n      return 0;\n    }\n  }\n  ll L = N;\n  for (ll i = 0; i < N; i++) {\n    if (b[i]) {L+=3;} else {L+=1;}\n  }\n  cout << \"Possible\" << endl;\n  cout << L << endl;\n  for (ll i = 0; i < N; i++) {\n    if (b[i]) {\n      cout << i << \" \" << 1 << endl;\n      cout << i << \" \" << 0 << endl;\n      cout << i+1 << \" \" << 0 << endl;\n    } else {\n      cout << i << \" \" << 1 << endl;\n    }\n  }\n  for (ll i = 0; i <= N; i++) {\n    cout << N-i << \" \" << 1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\nCode for problem E by cookiedoth\nGenerated 21 Mar 2020 at 05.19 PM\n\n\n______▄███████▄_______\n______█▄█████▄█_______\n______█▼▼▼▼▼█_______\n_____██________ ██______\n______█▲▲▲▲▲█_______\n______█████████_______\n_______██____ ██________\n\n>_<\no_O\n^_^\n\n*/\n\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <ctime>\n#include <functional>\n#include <unordered_set>\n#include <unordered_map>\n#include <string>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <complex>\n#include <cassert>\n#include <random>\n#include <cstring>\n#include <numeric>\n#define ll long long\n#define ld long double\n#define null NULL\n#define all(a) a.begin(), a.end()\n#define rall(a) a.rbegin(), a.rend()\n#define debug(a) cerr << #a << \" = \" << a << endl\n#define forn(i, n) for (int i = 0; i < n; ++i)\n#define sz(a) (int)a.size()\n\nusing namespace std;\n\ntemplate<class T> int chkmax(T &a, T b) {\n\tif (b > a) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\ntemplate<class T> int chkmin(T &a, T b) {\n\tif (b < a) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\ntemplate<class iterator> void output(iterator begin, iterator end, ostream& out = cerr) {\n\twhile (begin != end) {\n\t\tout << (*begin) << \" \";\n\t\tbegin++;\n\t}\n\tout << endl;\n}\n\ntemplate<class T> void output(T x, ostream& out = cerr) {\n\toutput(x.begin(), x.end(), out);\n}\n\nvoid fast_io() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n}\n\nint x;\nvector<pair<int, int> > ans;\n\nvoid move(int dest_x) {\n\tif (x == dest_x) {\n\t\treturn;\n\t}\n\tif (dest_x > x) {\n\t\tx++;\n\t\tans.emplace_back(x, 0);\n\t} else {\n\t\tx--;\n\t\tans.emplace_back(x, 0);\n\t}\n\tmove(dest_x);\n}\n\nvoid use(int pos, int d) {\n\t// cerr << \"use \" << pos << \" \" << d << endl;\n\tif (d == 0) {\n\t\tmove(pos);\n\t\tans.emplace_back(pos, 1);\n\t\tans.emplace_back(pos + 1, 1);\n\t\tans.emplace_back(pos + 1, 0);\n\t\tx++;\n\t} else {\n\t\tmove(pos + 1);\n\t\tans.emplace_back(pos, 1);\n\t\tans.emplace_back(pos - 1, 1);\n\t\tans.emplace_back(pos - 1, 0);\n\t\tx--;\n\t}\n}\n\nconst int mx = 300;\nint n, a[mx];\n\nvector<vector<pair<int, int> > > str;\n\nvoid gen_str() {\n\tstr.resize(n + 1);\n\tstr[1] = {{0, 0}};\n\tfor (int i = 2; i <= n; ++i) {\n\t\tstr[i].emplace_back(i - 1, 0);\n\t\tfor (auto pp : str[i - 1]) {\n\t\t\tstr[i].push_back(pp);\n\t\t}\n\t\tstr[i].emplace_back(i - 1, 1);\n\t\tfor (auto pp : str[i - 1]) {\n\t\t\tstr[i].emplace_back(pp.first, pp.second ^ 1);\n\t\t}\n\t\t// cerr << \"i = \" << i << endl;\n\t\t// for (auto pp : str[i]) {\n\t\t// \tcerr << pp.first << \" \" << pp.second << endl;\n\t\t// }\n\t}\n}\n\nvoid make(int sub) {\n\tvector<int> have;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif ((sub >> i) & 1) {\n\t\t\thave.push_back(i);\n\t\t}\n\t}\n\tint k = __builtin_popcount(sub);\n\tfor (auto pp : str[k]) {\n\t\tuse(have[pp.first], pp.second);\n\t}\n}\n\nsigned main() {\n\tfast_io();\n\tans.emplace_back(0, 0);\n\tcin >> n;\n\tgen_str();\n\tfor (int i = 0; i < (1 << n); ++i) {\n\t\tchar c;\n\t\tcin >> c;\n\t\ta[i] = c - '0';\n\t}\n\tif (a[0] == 0) {\n\t\tcout << \"Impossible\" << endl;\n\t\texit(0);\n\t}\n\tfor (int i = 0; i < (1 << n); ++i) {\n\t\tfor (int j = 0; j < i; ++j) {\n\t\t\tif (a[i] == 1 && ((i & j) == j) && a[j] == 0) {\n\t\t\t\tcout << \"Impossible\" << endl;\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < (1 << n); ++i) {\n\t\tif (a[i] == 0) {\n\t\t\tint ok = 1;\n\t\t\tfor (int j = 0; j < i; ++j) {\n\t\t\t\tif (a[j] == 0 && (i & j) == j) {\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tmake(i);\n\t\t\t}\n\t\t}\n\t}\n\tmove(0);\n\tcout << \"Possible\" << \"\\n\";\n\tcout << (int)ans.size() - 1 << \"\\n\";\n\tfor (auto pp : ans) {\n\t\tcout << pp.first << \" \" << pp.second << \"\\n\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define fr first\n#define sc second\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n\nint main(){\n\tint n;\n\tstring s;\n\tcin>>n>>s;\n\t\n\tint a[300];\n\tfor(int i=0;i<(1<<n);i++)a[i]=s[i]-'0';\n\t\n\tbool used[10][10];\n\tmemset(used,0,sizeof used);\n\t\n\tint b[300];\n\tfor(int i=0;i<300;i++)b[i]=1;\n\tfor(int i=0;i<n;i++){\n\t\tbool ok=true;\n\t\tfor(int x=0;x<(1<<n);x++){\n\t\t\tif((x>>i)&1)if(a[x]==1)ok=false;\n\t\t}\n\t\tif(ok){\n\t\t\tused[i][i]=true;\n\t\t\tfor(int x=0;x<(1<<n);x++){\n\t\t\t\tif((x>>i)&1)b[x]=0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tbool ok=true;\n\t\t\tfor(int x=0;x<(1<<n);x++){\n\t\t\t\tif((x>>i)&1)if((x>>j)&1)if(a[x]==1)ok=false;\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tused[i][j]=true;\n\t\t\t\tfor(int x=0;x<(1<<n);x++){\n\t\t\t\t\tif((x>>i)&1)if((x>>j)&1)b[x]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool ok=true;\n\tfor(int i=0;i<(1<<n);i++)ok&=a[i]==b[i];\n\tif(!ok){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tvector<P> ret;\n\tret.push_back(P(0,0));\n\tfor(int i=0;i<n;i++){\n\t\tif(used[i][i]){\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t}\n\t\t\tret.push_back(P(i,1));\n\t\t\tret.push_back(P(i+1,1));\n\t\t\tret.push_back(P(i+1,0));\n\t\t\tret.push_back(P(i,0));\n\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\tret.push_back(P(j,0));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int k=i+1;k<n;k++){\n\t\t\tif(used[i][k]){\n\t\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(i,1));\n\t\t\t\tret.push_back(P(i+1,1));\n\t\t\t\tret.push_back(P(i+1,0));\n\t\t\t\tret.push_back(P(i,0));\n\t\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(k,1));\n\t\t\t\tret.push_back(P(k+1,1));\n\t\t\t\tret.push_back(P(k+1,0));\n\t\t\t\tret.push_back(P(k,0));\n\t\t\t\tfor(int j=k-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(i+1,0));\n\t\t\t\tret.push_back(P(i+1,1));\n\t\t\t\tret.push_back(P(i,1));\n\t\t\t\tret.push_back(P(i,0));\n\t\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(k+1,0));\n\t\t\t\tret.push_back(P(k+1,1));\n\t\t\t\tret.push_back(P(k,1));\n\t\t\t\tret.push_back(P(k,0));\n\t\t\t\tfor(int j=k-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\",(int)(ret.size())-1);\n\tfor(int i=0;i<ret.size();i++){\n\t\tprintf(\"%d %d\\n\",ret[i].fr,ret[i].sc);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i = (begin); i < (end); i++)\n#define rep(i, n) FOR(i, 0, n)\nusing ll = long long;\nusing namespace std;\n#define all(x) (x).begin(),(x).end()\nusing pii = pair<int, int>; using vi = vector<int>; using vl = vector<ll>;\n\nint N;\n\nsigned main() {\n    cin >> N;\n    // unordered_set<int> oo, ii;\n    int oo(0), ii(0);\n    vi sss;\n    string as;\n    cin >> as;\n    bool first = true;\n    for(int i = N-1; i>=0; i--) {\n        // auto ss = setter(i);\n        if (as[i] == '1') {\n            if(first) {\n                oo = i;\n                first = false;\n            } else if((oo | i) != i) {\n                cout << \"Impossible\" << endl;\n                return 0;\n            }\n            // ii = Union(ii, ss);\n        } else {\n            // sss.push_back(i);\n            // oo = Union(oo, ss);\n        }\n    }\n    // for(auto s : sss) {\n    //     if((oo&s) == s) {\n    //         cout << \"Impossible\" << endl;\n    //         return 0;\n    //     }\n    // }\n    \n    // if (Product(oo, ii).size() != 0) {\n    // if ((oo&ii) != 0) {\n    //     cout << \"Impossible\" << endl;\n    //     return 0;\n    // }\n    cout << \"Possible\" << endl;\n\n    ii = (1<<N) - oo - 1;\n    // cerr << oo << ' ' << ii << endl;\n    // cerr << (oo & ii) << endl;\n    vector<pii> p;\n    int before = 0;\n    // cerr << ii << endl;\n    p.push_back({0, 0});\n    rep(i, N) {\n        // cerr << ii << endl;\n        // cerr << ((ii&1) ^ before) << endl;\n        if((ii&1) ^ before) {\n            if(ii&1) {\n                if(i!=0) {\n                    p.push_back({i, 0});\n                }\n                p.push_back({i, 1});\n            } else {\n                p.push_back({i, 1});\n                if(i!=N-1)\n                    p.push_back({i, 0});\n            }\n        } else {\n            if(i!=0)\n                p.push_back({i, before});\n        }\n        before = ii & 1;\n        ii >>= 1;\n    }\n    if (before)\n        p.push_back({N, 1});\n    for(int k = N; k>=0; k--) {\n        p.push_back({k, 0});\n    }\n\n    cout << p.size() - 1 << endl;\n    for(auto pp : p) {\n        cout << pp.first << ' ' << pp.second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int N=1<<10;\nint n;\nchar s[N];\nint p[N];\nvector<pair<int,int> > solve(int S,int now)\n{\n\tcerr<<\"Solve\"<<S<<\" \"<<now<<\"\\n\";\n\tvector<pair<int,int> >res;\n\tfor(int i=now+1;i<n;i++)\n\t\tif(S&(1<<i))\n\t\t{\n\t\t\tvector<pair<int,int> > t=solve(S,i);\n\t\t\tfor(int j=now;j<=i-1;j++)\n\t\t\t\tres.push_back(make_pair(j,1));\n\t\t\tfor(auto [x,y]:t)\n\t\t\t\tres.push_back(make_pair(x,y));\n\t\t\tfor(int j=i;j>=now;j--)\n\t\t\t\tres.push_back(make_pair(j,1));\n\t\t\tres.push_back(make_pair(now,0));\n\t\t\tres.push_back(make_pair(now+1,0));\n\t\t\tfor(int j=now+1;j<=i;j++)\n\t\t\t\tres.push_back(make_pair(j,1));\n\t\t\treverse(t.begin(),t.end());\n\t\t\tfor(auto [x,y]:t)\n\t\t\t\tres.push_back(make_pair(x,y));\n\t\t\tfor(int j=i-1;j>=now+1;j--)\n\t\t\t\tres.push_back(make_pair(j,1));\n\t\t\tres.push_back(make_pair(now+1,0));\n\t\t\tres.push_back(make_pair(now,0));\n\t\t\treturn res;\n\t\t}\n\tres.push_back(make_pair(now,1));\n\tres.push_back(make_pair(now+1,1)); \n\tres.push_back(make_pair(now+1,0));\n\tres.push_back(make_pair(now,0));\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",s);\n\tfor(int i=0;i<(1<<n);i++)\n\t\tp[i]=s[i]-'0';\n\tif(p[0]==0)\n\t{\n\t\tprintf(\"Impossible\");\n\t\treturn 0;\n\t}\n\tfor(int s=0;s<(1<<n);s++)\n\t\tif(p[s]==1)\n\t\t\tfor(int i=s;i;i=(i-1)&s)\n\t\t\t\tif(p[i]==0)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"Impossible\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\tvector<pair<int,int> >ans;\n\tans.push_back(make_pair(0,0));\n\tfor(int s=1;s<(1<<n);s++)\n\t\tif(p[s]==0)\n\t\t{\n\t\t\tbool flag=true;\n\t\t\tfor(int i=(s-1)&s;i;i=(i-1)&s)\n\t\t\t\tif(p[i]==0)\n\t\t\t\t{\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif(!flag) continue;\n\t\t\tvector<pair<int,int> >res;\n\t\t\tvector<pair<int,int> >t;\n\t\t\tint u=0;\n\t\t\tfor(u=0;u<n;u++)\n\t\t\t\tif(s&(1<<u))\n\t\t\t\t{\n\t\t\t\t\tt=solve(s,u);\n//\t\t\t\t\tcerr<<\"res\"<<\"\\n\";\n//\t\t\t\t\tfor(auto [x,y]:t)\n//\t\t\t\t\t\tcerr<<x<<\" \"<<y<<\"\\n\";\n//\t\t\t\t\tcerr<<\"EOF\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif(ans.back()!=make_pair(0,0)) res.push_back(make_pair(0,0));\n\t\t\tfor(int i=0;i<=u-1;i++)\n\t\t\t\tres.push_back(make_pair(i,1));\n\t\t\tfor(auto [x,y]:t)\n\t\t\t\tres.push_back(make_pair(x,y));\n\t\t\tfor(int i=u;i>=0;i--)\n\t\t\t\tres.push_back(make_pair(i,1));\n\t\t\tres.push_back(make_pair(0,0));\n\t\t\tfor(auto [x,y]:res)\n\t\t\t\tans.push_back(make_pair(x,y));\n\t\t}\n\tprintf(\"Possible\\n\");\n\tint len=ans.size()-1;\n\tprintf(\"%d\\n\",len);\n\tfor(auto [x,y]:ans)\n\t\tprintf(\"%d %d\\n\",x,y);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nchar s[300];int n;\nstruct Node {int x,y;Node(){}Node(int _x,int _y){x=_x;y=_y;}};\nvector<Node> V;\nint main()\n{\n\tscanf(\"%d%s\",&n,s);\n\tfor(int i=0;i<(1<<n);i++) for(int j=0;j<(1<<n);j++)\n\t\tif((i&j)==(s[i]=='1'?j:i)&&s[j]!=s[i]) return puts(\"Impossible\"),0;\n\tputs(\"Possible\");\n\tfor(int i=0;i<(1<<n);i++) if(s[i]=='0')\n\t{\n\t\tbool flag=1;\n\t\tfor(int j=0;j<i;j++) if((i&j)==j&&s[j]=='0'){flag=0;break;}\n\t\tif(!flag) continue;\n\t\tV.push_back(Node(0,0));\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif((i>>j)&1)\n\t\t\t{\n\t\t\t\tV.push_back(Node(j,1));\n\t\t\t\tV.push_back(Node(j+1,1));\n\t\t\t}\n\t\t\tV.push_back(Node(j+1,0));\n\t\t}\n\t\tfor(int j=n-1;j;j--) V.push_back(Node(j,0));\n\t}\n\tcout<<V.size()<<endl;\n\tfor(int i=0;i<(int)V.size();i++) printf(\"%d %d\\n\",V[i].x,V[i].y);\n\tputs(\"0 0\");return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n// gp_hash_table<int, int> mapka;\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nint n;\nstring z;\n\nvoid nope(){\n  cout << \"Impossible\\n\";\n  exit(0);\n}\n\nvector<PII> petla(int mb){\n  vector<PII> res;\n  res.PB({0,0});\n  R(i,n){\n    if((mb >> i) & 1){\n      res.PB({i,1ll});\n      res.PB({i+1,1ll});\n    }\n    res.PB({i+1,0ll});\n  }\n  R(i,n){\n    res.PB({n - i - 1, 0});\n  }\n  return res;\n}\nvector<PII> res;\nvoid dodaj(vector<PII> x){\n  R(i,SZ(x)-1)res.PB(x[i]);\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n >> z;\n  R(i, 1<<n)z[i] -= '0';\n  if(z[0] == 0)nope();\n  R(i, 1<<n)R(j, 1 << n)if((i | j) == i && z[i] == 1 && z[j] == 0)nope();\n  cout << \"Possible\\n\";\n  vector<int> dp(1 << n);\n  for(int mb = (1 << n) - 1; mb > 0; mb --){\n    if(z[mb] == 0 && dp[mb] == 0){\n      dodaj(petla(mb));\n      R(mb2, (1 << n))if((mb2 | mb) == mb){\n        dp[mb2]++;\n      }\n    }\n    if(z[mb] == 1 && dp[mb] != 0){\n      auto pom = petla(mb);\n      if(dp[mb] < 0)reverse(ALL(pom));\n      R(i, abs(dp[mb]))dodaj(pom);\n      R(mb2, (1 << n))if((mb2 | mb) == mb){\n        dp[mb2] -= dp[mb];\n      }\n    }\n  }\n  res.PB({0,0});\n  cout << SZ(res) - 1 << \"\\n\";\n  for(PII el:res){\n    cout << el.FI << \" \" << el.SE << \"\\n\";\n  }\n  \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  string s;\n  cin >> s;\n  for (int bt = 0; bt < 1 << n; ++bt) {\n    string t(1 << n, '?');\n    for (int x = 0; x < 1 << n; ++x) {\n      t[x] = '0' + !(bt & x);\n    }\n    if (s == t) {\n      cout << \"Possible\\n\";\n      vector<pair<int, int>> res;\n      for (int i = 0; i < n; ++i) {\n        if (bt >> i & 1) {\n          res.emplace_back(i, 0);\n          res.emplace_back(i, 1);\n          res.emplace_back(i + 1, 1);\n        } else {\n          res.emplace_back(i, 0);\n        }\n      }\n      for (int i = n; i >= 0; --i) {\n        res.emplace_back(i, 0);\n      }\n      cout << res.size() - 1 << '\\n';\n      for (auto e : res) {\n        cout << e.first << ' ' << e.second << '\\n';\n      }\n      exit(0);\n    }\n  }\n  cout << \"Impossible\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define long long long int\nusing namespace std;\n\n// @author: pashka\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    int n;\n    string s;\n    cin >> n >> s;\n    if (s[0] == '0') {\n        cout << \"Impossible\\n\";\n        return 0;\n    }\n    vector<bool> z(1 << n);\n    vector<pair<int, int>> p;\n    p.push_back({0, 0});\n    for (int j = 1; j < (1 << n); j++) {\n        if (z[j]) {\n            if (s[j] == '1') {\n                cout << \"Impossible\\n\";\n                return 0;\n            }\n            continue;\n        }\n        if (s[j] == '0') {\n            vector<pair<int, int>> pp;\n            for (int i = 0; i < n; i++) {\n                if (j & (1 << i)) {\n                    if (pp.size() == 0) {\n                        for (int x = 0; x <= i; x++) {\n                            pp.push_back({x, 0});\n                        }\n                        pp.push_back({i, 1});\n                        pp.push_back({i + 1, 1});\n                        for (int x = i + 1; x >= 0; x--) {\n                            pp.push_back({x, 0});\n                        }\n                    } else {\n                        vector<pair<int, int>> ppp = pp;\n                        for (int x = 1; x <= i; x++) {\n                            ppp.push_back({x, 0});\n                        }\n                        ppp.push_back({i, 1});\n                        ppp.push_back({i + 1, 1});\n                        for (int x = i + 1; x >= 1; x--) {\n                            ppp.push_back({x, 0});\n                        }\n                        reverse(pp.begin(), pp.end());\n                        ppp.insert(ppp.end(), pp.begin(), pp.end());\n                        for (int x = 1; x <= i + 1; x++) {\n                            ppp.push_back({x, 0});\n                        }\n                        ppp.push_back({i + 1, 1});\n                        ppp.push_back({i, 1});\n                        for (int x = i; x >= 0; x--) {\n                            ppp.push_back({x, 0});\n                        }\n                        pp = ppp;\n                    }\n                }\n            }\n            p.insert(p.end(), pp.begin() + 1, pp.end());\n            for (int i = 0; i < n; i++) {\n                z[j | (1 << i)] = true;\n            }\n        }\n    }\n    cout << \"Possible\\n\";\n    cout << p.size() - 1 << \"\\n\";\n    for (auto x : p) {\n        cout << x.first << \" \" << x.second << \"\\n\";\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(\"wzpakking\")\n#define y1 ysghysgsygsh\nusing namespace std;\n#define vi vector<int>\nint n,flg[500];\nchar s[500];\nvi q;\nvector<pii> ans;\nvi get(vi x){\n\tif (x.size()==1) return x;\n\tint t=x.back();\n\tx.pop_back();\n\tvi v=get(x),res;\n\tres.PB(t);\n\tfor (auto i:v) res.PB(i);\n\tres.PB(-t); \n\treverse(v.begin(),v.end());\n\tfor (auto i:v) res.PB(-i);\n\treturn res;\n}\nvoid walk(int &x,int y){\n\tfor (;x<y;ans.PB(pii(++x,0)));\n\tfor (;x>y;ans.PB(pii(--x,0)));\n}\nint main(){\n\tscanf(\"%d%s\",&n,s);\n\tFor(i,0,(1<<n)-1) s[i]-='0';\n\tFor(i,0,(1<<n)-1) For(j,0,(1<<n)-1)\n\t\tif ((i&j)==j&&s[i]&&!s[j])\n\t\t\treturn puts(\"Impossible\"),0;\n\tFor(i,0,(1<<n)-1) if (!s[i])\n\t\tFor(j,0,(1<<n)-1) if (j!=i&&(i&j)==j&&!s[j]) flg[j]=1;\n\tFor(i,0,(1<<n)-1) if (!s[i]&&!flg[i]){\n\t\tvector<int> tmp;\n\t\tFor(j,0,n-1) if (i&(1<<j)) tmp.PB(j+1);\n\t\ttmp=get(tmp);\n\t\tfor (auto j:tmp) q.PB(j);\n\t}\n\tint x=0;\n\tans.PB(pii(0,0));\n\tfor (auto i:q){\n\t\tint st,ed;\n\t\tif (i>0) st=i-1,ed=i;\n\t\telse st=-i,ed=-i-1;\n\t\twalk(x,st);\n\t\tans.PB(pii(st,1));\n\t\tans.PB(pii(ed,1));\n\t\tans.PB(pii(ed,0));\n\t\tx=ed;\n\t}\n\twalk(x,0);\n\tprintf(\"Possible\\n%d\\n\",ans.size()-1);\n\tfor (auto i:ans) printf(\"%d %d\\n\",i.fi,i.se);\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <decimal/decimal>\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define rep(i, s, t) for (int i = s; i < int(t); ++i)\n\n#define sc\tscanf\n#define pr\tprintf\n#define ff\tfirst\n#define ss\tsecond\n#define mp\tmake_pair\n#define pb\tpush_back\n#define eb\templace_back\n#define range(c)\tc.begin(), c.end()\n#define lowbit(x)\t((x) & -(x))\n#define pop_count\t__builtin_popcount\n#define pop_count_64\t__builtin_popcountll\n#define tail_count\t__builtin_ctz\n#define tail_count_64\t__builtin_ctzll\n#define lead_count\t__builtin_clz\n#define lead_count_64\t__builtin_clzll\n\n#define TEMP template<typename\n#define CONST(type) constexpr type const\n\nTEMP... Ts> struct is_con { static CONST(bool) value = false; };\nTEMP... Ts> struct is_con<vector<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<list<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<deque<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<set<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<unordered_set<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<map<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<unordered_map<Ts...>> { static CONST(bool) value = true; };\n\nTEMP T1, typename T2> ostream& operator<<(ostream& os, pair<T1, T2> const& p) { return os << \"<\" << p.ff << \",\" << p.ss << \">\"; }\nTEMP T> typename enable_if<is_con<T>::value, ostream>::type& operator<<(ostream& os, T const& c) {\n\tos << \"{\";\n\tbool first = true;\n\tfor (auto const& x : c) {\n\t\tif (first) first = false;\n\t\telse os << \",\";\n\t\tos << \" \" << x;\n\t}\n\treturn os << \" }\";\n}\n\nTEMP T, typename... Ts> void dbg(T h, Ts... t) { cerr << \" \" << h; dbg<Ts...>(t...); }\ntemplate<> void dbg<int>(int x) { cerr << endl; }\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[ \"#__VA_ARGS__\" ] :\", dbg(__VA_ARGS__, 0)\n#else\n#define debug(...) 0\n#endif\n\nTEMP T, typename U> using ordered_map = tree<T, U, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\nTEMP T> using ordered_set = ordered_map<T, null_type>;\n\ntypedef long long i64;\ntypedef decimal::decimal128 i99;\ntypedef unsigned int u32;\ntypedef unsigned long long u64;\ntypedef float f32;\ntypedef double f64;\ntypedef long double f80;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<i64> vl;\n\nTEMP T> T& minn(T& lhs, T const& rhs) { return lhs = min(lhs, rhs); }\nTEMP T> T& maxx(T& lhs, T const& rhs) { return lhs = max(lhs, rhs); }\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n;\n\tstring a;\n\tcin >> n >> a;\n\tvi ok;\n\trep(x, 0, 1 << n) {\n\t\tvi dp(1 << n);\n\t\trep(i, 0, n) dp[1 << i] = x >> i & 1;\n\t\trep(i, 0, n) rep(s, 0, 1 << n) if (s >> i & 1) dp[s] |= dp[s ^ 1 << i];\n\t\tbool check = true;\n\t\trep(s, 0, 1 << n) check &= (a[s] == '1') ^ dp[s];\n\t\tdebug(bitset<8>(x), dp);\n\t\tif (check) ok.pb(x);\n\t}\n\tdebug(ok.size());\n\tfor (int x : ok) debug(bitset<8>(x));\n\tif (ok.empty()) return cout << \"Impossible\" << endl, 0;\n\tcout << \"Possible\" << endl;\n\tvector<pii> ans(1);\n\trep(i, 0, n) if (ok[0] >> i & 1) {\n\t\trep(j, 1, i) ans.eb(j, 0);\n\t\tans.eb(i + 1, 0);\n\t\tans.eb(i + 1, 1);\n\t\tans.eb(i, 1);\n\t\tfor (int j = i - 1; j >= 0; --j) ans.eb(j, 0);\n\t}\n\tcout << ans.size() << endl;\n\tfor (auto const& p : ans) cout << p.ff << \" \" << p.ss << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\n#define dump(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = {\";  \\\n\tfor(auto v: x) cerr << v << \",\"; cerr << \"}\" << endl;\n#else\n#define show(x) true\n#define dump(x) true\n#endif\n\nusing P = pair<int,int>;\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\t//DON'T USE scanf/printf/puts !!\n\tcout << fixed << setprecision(20);\n\n\tint n; cin >> n;\n\tstring A; cin >> A;\n\tint N = 1<<n;\n\trep(i,N) rep(j,N){\n\t\tif((i&j) == j && A[i] == '1' && A[j] == '0'){\n\t\t\tcout << \"Impossible\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tV<int> minimal0s;\n\trep(i,N) if(A[i] == '0'){\n\t\tbool minimal = true;\n\t\trep(j,i) if((i&j) == j && A[j] == '0') minimal = false;\n\t\tif(minimal) minimal0s.pb(i);\n\t}\n\tauto rev = [&](string s){\n\t\treverse(all(s));\n\t\tfor(char& c: s){\n\t\t\tif(c == 'l' || c == 'r') c ^= 'l'^'r';\n\t\t\telse c ^= 'u'^'d';\n\t\t}\n\t\treturn s;\n\t};\n\tstring ans;\n\tif(false){\n\t\tminimal0s.clear();\n\t\tn = 8; N = 1<<n;\n\t\trep(i,N){\n\t\t\tif(__builtin_popcount(i) == 7) minimal0s.pb(i);\n//\t\t\tminimal0s.pb(i);\n\t\t}\n\t}\n\tfor(int s: minimal0s){\n\t\tshow(s);\n\t\tV<int> xs = {0};\n\t\trep(i,n) if(s&1<<i) xs.pb(i+1);\n\t\t{\n\t\t\tV<int> ds;\n\t\t\trep(i,xs.size()-1) ds.pb(xs[i+1]-xs[i]);\n\t\t\txs = ds;\n\t\t}\n\t\tstring t;\n\t\tint K = xs.size();\n\t\tfor(int i=K-1;i>=0;i--){\n\t\t\tif(i == K-1){\n\t\t\t\tt = string(xs[i],'r') + \"dlu\" + string(xs[i]-1,'l');\n\t\t\t}else{\n\t\t\t\tstring nt;\n\t\t\t\tnt += string(xs[i],'r');\n\t\t\t\tnt += t;\n\t\t\t\tnt += \"ldru\";\n\t\t\t\tnt += rev(t);\n\t\t\t\tnt += \"dlu\";\n\t\t\t\tnt += string(xs[i]-1,'l');\n\t\t\t\tt = nt;\n\t\t\t}\n\t\t}\n\t\tans += t;\n\t}\n\n\tcout << \"Possible\" << endl;\n\tcout << ans.size() << endl;\n//\treturn 0;\n\tint x=0,y=0; cout << x << \" \" << y << endl;\n\tfor(char c: ans){\n\t\tif(c == 'r') x++;\n\t\tif(c == 'l') x--;\n\t\tif(c == 'd') y++;\n\t\tif(c == 'u') y--;\n\t\tcout << x << \" \" << y << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(\"wzpakking\")\n#define y1 ysghysgsygsh\nusing namespace std;\nchar s[500];\nint n,top,q[10],flg[500];\npii ans[50005];\nvoid walk(int x,int px,int y,int py){\n\tfor (;x<y;) ans[++top]=pii(++x,px);\n\tfor (;x>y;) ans[++top]=pii(--x,px);\n}\nvoid construct(int l){\n\tif (l==*q){\n\t\tans[++top]=pii(q[l]+1,1);\n\t\tans[++top]=pii(q[l]+1,0);\n\t\tans[++top]=pii(q[l],0);\n\t\tans[++top]=pii(q[l],1);\n\t\treturn;\n\t}\n\twalk(q[l],1,q[l+1],1);\n\tconstruct(l+1);\n\twalk(q[l+1],1,q[l],1);\n\tans[++top]=pii(q[l],0);\n\tans[++top]=pii(q[l+1],0);\n\tans[++top]=pii(q[l+1],1);\n\twalk(q[l]+1,1,q[l+1],1);\n\tconstruct(l+1);\n\twalk(q[l+1],1,q[l],1);\n}\n/*\nULLUULLUULLUULLU\nUULLLLUUUULLLLUU\nLLUU\n*/\nvoid constructa(int x){\n\t//cout<<x<<endl;\n\t*q=0;\n\tFor(i,0,n-1) if (x&(1<<i)) q[++*q]=i;\n\twalk(0,1,q[1],1);\n\tconstruct(1);\n\twalk(q[1],1,0,1);\n}\nint main(){\n\tscanf(\"%d%s\",&n,s);\n\tFor(i,0,(1<<n)-1) For(j,0,(1<<n)-1)\n\t\tif ((i&j)==i&&s[i]=='0'&&s[j]=='1')\n\t\t\treturn puts(\"Impossible\"),0;\n\tFor(i,0,(1<<n)-1)\n\t\tFor(j,0,(1<<n)-1)\n\t\t\tif (s[i]=='0'&&(i&j)==i&&j!=i) flg[j]=1;\n\tans[top=1]=pii(0,1);\n\tFor(i,0,(1<<n)-1)\n\t\tif (s[i]=='0'&&!flg[i])\n\t\t\tconstructa(i);\n\tprintf(\"Possible\\n%d\\n\",top-1);\n\tFor(i,1,top) cout<<ans[i].fi<<' '<<ans[i].se<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define fr first\n#define sc second\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n\nvector<P> ret;\n\nvoid pos(int i){\n\tfor(int j=0;j<i;j++){\n\t\tret.push_back(P(j+1,0));\n\t}\n\tret.push_back(P(i,1));\n\tret.push_back(P(i+1,1));\n\tret.push_back(P(i+1,0));\n\tret.push_back(P(i,0));\n\tfor(int j=i-1;j>=0;j--){\n\t\tret.push_back(P(j,0));\n\t}\n}\nvoid neg(int i){\n\tfor(int j=0;j<i;j++){\n\t\tret.push_back(P(j+1,0));\n\t}\n\tret.push_back(P(i+1,0));\n\tret.push_back(P(i+1,1));\n\tret.push_back(P(i,1));\n\tret.push_back(P(i,0));\n\tfor(int j=i-1;j>=0;j--){\n\t\tret.push_back(P(j,0));\n\t}\n}\n\nvector<P> f(vector<P> vec,int t){\n\tint cnt[300]={};\n\tfor(int i=0;i<vec.size();i++){\n\t\tcnt[vec[i].sc]++;\n\t}\n\tint MIN=100;\n\tint id=-1;\n\tfor(int i=0;i<300;i++){\n\t\tif(cnt[i]==0)continue;\n\t\tif(MIN>cnt[i]){\n\t\t\tMIN=cnt[i];\n\t\t\tid=i;\n\t\t}\n\t}\n\t//cerr<<\"id=\"<<id<<endl;\n\tvector<P> ret;\n\tfor(int i=0;i<vec.size();i++){\n\t\tif(vec[i].sc!=id)ret.push_back(vec[i]);\n\t\telse {\n\t\t\tif(vec[i].fr==1){\n\t\t\t\tret.push_back(P(1,id));\n\t\t\t\tret.push_back(P(1,t));\n\t\t\t\tret.push_back(P(-1,id));\n\t\t\t\tret.push_back(P(-1,t));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret.push_back(P(1,t));\n\t\t\t\tret.push_back(P(1,id));\n\t\t\t\tret.push_back(P(-1,t));\n\t\t\t\tret.push_back(P(-1,id));\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nbool zero(vector<P> vec, int x){\n\tstack<P> st;\n\tfor(P p: vec){\n\t\tif((x>>p.sc)&1){\n\t\t\tif(st.size()==0){\n\t\t\t\tst.push(p);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tP q=st.top();\n\t\t\tif(q.sc==p.sc&&p.sc+q.sc==0)st.pop();\n\t\t\telse st.push(p);\n\t\t}\n\t}\n\treturn st.size()==0;\n}\n\nint main(){\n\t/*vector<P> vvv;\n\tvvv.push_back(P(1,1));\n\tfor(int i=2;i<=8;i++){\n\t\tvvv=f(vvv,i);\n\t\tcerr<<i<<\" \"<<vvv.size()<<endl;\n\t}*/\n\t\n\t\n\tint n;\n\tstring s;\n\tcin>>n>>s;\n\t\n\tint a[300];\n\tfor(int i=0;i<(1<<n);i++)a[i]=s[i]-'0';\n\t\n\tbool used[300];\n\tmemset(used,0,sizeof used);\n\t\n\tint b[300];\n\tfor(int i=0;i<300;i++)b[i]=1;\n\t\n\tfor(int x=1;x<(1<<n);x++){\n\t\tused[x]=true;\n\t\tfor(int y=0;y<x;y++){\n\t\t\tif((x&y)==y)if(used[y])used[x]=false;\n\t\t}\n\t\tfor(int y=0;y<(1<<n);y++){\n\t\t\tif((x&y)==x)if(a[y]==1)used[x]=false;\n\t\t}\n\t\tif(used[x]){\n\t\t\tfor(int y=0;y<(1<<n);y++){\n\t\t\t\tif((x&y)==x)b[y]=0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool ok=true;\n\tfor(int i=0;i<(1<<n);i++)ok&=a[i]==b[i];\n\tif(!ok){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tvector<P> vv;\n\t/*for(int x=0;x<(1<<n);x++){\n\t\tif(!used[x])continue;\n\t\tif(vv.size()==0){\n\t\t\tvv.push_back(P(1,x));\n\t\t}\n\t\telse{\n\t\t\tvv=f(vv,x);\n\t\t}\n\t}*/\n\tvector<P> vec[300];\n\tret.push_back(P(0,0));\n\tfor(int x=0;x<(1<<n);x++){\n\t\tif(!used[x])continue;\n\t\tif(zero(vv,x)){\n\t\t\tint cnt=0;\n\t\t\tint c[10];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif((x>>i)&1)c[cnt++]=i;\n\t\t\t}\n\t\t\tvec[x].push_back(P(1,c[0]));\n\t\t\tfor(int i=1;i<cnt;i++)vec[x]=f(vec[x],c[i]);\n\t\t\tvv.insert(vv.end(),vec[x].begin(),vec[x].end());\n\t\t}\n\t}\n\tfor(P p: vv){\n\t\tif(p.fr==1)pos(p.sc);\n\t\telse neg(p.sc);\n\t}\n\t\n\t/*for(int i=0;i<vv.size();i++){\n\t\tif(vv[i].fr==1){\n\t\t\tfor(P p: vec[vv[i].sc]){\n\t\t\t\tif(p.fr==1)pos(p.sc);\n\t\t\t\telse neg(p.sc);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor(int j=vec[vv[i].sc].size()-1;j>=0;j--){\n\t\t\t\tP p=vec[vv[i].sc][j];\n\t\t\t\tif(p.fr==1)neg(p.sc);\n\t\t\t\telse pos(p.sc);\n\t\t\t}\n\t\t}\n\t}*/\n\t\n\t/*vector<P> ret2;\n\tfor(P p: ret){\n\t\tif(ret2.size()>=2&&ret2[ret2.size()-2]==p)ret2.pop_back();\n\t\telse ret2.push_back(p);\n\t}\n\tret=ret2;*/\n\t\n\tassert(ret.size()<=250000);\n\t\n\tputs(\"Possible\");\n\tprintf(\"%d\\n\",(int)(ret.size())-1);\n\tfor(int i=0;i<ret.size();i++){\n\t\tprintf(\"%d %d\\n\",ret[i].fr,ret[i].sc);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define rrng(a) a.rbegin(),a.rend()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define eb emplace_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ntypedef vector<T> vt;\ninline int getInt() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define dame { puts(\"Impossible\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\nconst int MX = 200005;\n\nvp f(vi a) {\n  int x = a.back();\n  if (sz(a) == 1) {\n    vp res;\n    rep(i,x+2) res.eb(i,0);\n    res.eb(x+1,1);\n    res.eb(x,1);\n    drep(i,x+1) res.eb(i,0);\n    return res;\n  }\n  a.pop_back();\n  rep(i,sz(a)) a[i] -= x+1;\n  vp d = f(a);\n  rep(i,sz(d)) d[i].fi += x+1;\n  vp res;\n  rep(i,x+1) res.eb(i,0);\n  res.insert(res.end(), rng(d));\n  res.eb(x+1,0);\n  res.eb(x,0);\n  res.eb(x,1);\n  reverse(rng(d));\n  res.insert(res.end(), rng(d));\n  res.eb(x+1,1);\n  res.eb(x,1);\n  drep(i,x+1) res.eb(i,0);\n  res.eb(0,1);\n  return res;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  string st;\n  cin>>st;\n  int n2 = 1<<n;\n  vi a(n2);\n  rep(i,n2) a[i] = st[i]-'0';\n  rep(i,n2) a[i] ^= 1;\n  rep(i,n2) {\n    if (a[i]) continue;\n    for (int j = i;; j = (j-1)&i) {\n      if (a[j]) dame;\n      if (!j) break;\n    }\n  }\n  if (a[0]) dame;\n  cout<<\"Possible\"<<endl;\n  vp ans;\n  rep(i,n2) {\n    if (!a[i]) continue;\n    vi s;\n    rep(j,n) if (i>>j&1) s.pb(j);\n    reverse(rng(s));\n    vp now = f(s);\n    ans.insert(ans.end(), rng(now));\n  }\n  ans.eb(0,0);\n  cout<<sz(ans)-1<<endl;\n  for (P p : ans) {\n    cout<<p.fi<<\" \"<<p.se<<endl;\n  }\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <decimal/decimal>\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define rep(i, s, t) for (int i = s; i < int(t); ++i)\n\n#define sc\tscanf\n#define pr\tprintf\n#define ff\tfirst\n#define ss\tsecond\n#define mp\tmake_pair\n#define pb\tpush_back\n#define eb\templace_back\n#define range(c)\tc.begin(), c.end()\n#define lowbit(x)\t((x) & -(x))\n#define pop_count\t__builtin_popcount\n#define pop_count_64\t__builtin_popcountll\n#define tail_count\t__builtin_ctz\n#define tail_count_64\t__builtin_ctzll\n#define lead_count\t__builtin_clz\n#define lead_count_64\t__builtin_clzll\n\n#define TEMP template<typename\n#define CONST(type) constexpr type const\n\nTEMP... Ts> struct is_con { static CONST(bool) value = false; };\nTEMP... Ts> struct is_con<vector<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<list<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<deque<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<set<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<unordered_set<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<map<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<unordered_map<Ts...>> { static CONST(bool) value = true; };\n\nTEMP T1, typename T2> ostream& operator<<(ostream& os, pair<T1, T2> const& p) { return os << \"<\" << p.ff << \",\" << p.ss << \">\"; }\nTEMP T> typename enable_if<is_con<T>::value, ostream>::type& operator<<(ostream& os, T const& c) {\n\tos << \"{\";\n\tbool first = true;\n\tfor (auto const& x : c) {\n\t\tif (first) first = false;\n\t\telse os << \",\";\n\t\tos << \" \" << x;\n\t}\n\treturn os << \" }\";\n}\n\nTEMP T, typename... Ts> void dbg(T h, Ts... t) { cerr << \" \" << h; dbg<Ts...>(t...); }\ntemplate<> void dbg<int>(int x) { cerr << endl; }\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[ \"#__VA_ARGS__\" ] :\", dbg(__VA_ARGS__, 0)\n#else\n#define debug(...) 0\n#endif\n\nTEMP T, typename U> using ordered_map = tree<T, U, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\nTEMP T> using ordered_set = ordered_map<T, null_type>;\n\ntypedef long long i64;\ntypedef decimal::decimal128 i99;\ntypedef unsigned int u32;\ntypedef unsigned long long u64;\ntypedef float f32;\ntypedef double f64;\ntypedef long double f80;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<i64> vl;\n\nTEMP T> T& minn(T& lhs, T const& rhs) { return lhs = min(lhs, rhs); }\nTEMP T> T& maxx(T& lhs, T const& rhs) { return lhs = max(lhs, rhs); }\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n;\n\tstring a;\n\tcin >> n >> a;\n\tvi ok;\n\trep(x, 0, 1 << n) {\n\t\tvi dp(1 << n);\n\t\trep(i, 0, n) dp[1 << i] = x >> i & 1;\n\t\trep(i, 0, n) rep(s, 0, 1 << n) if (s >> i & 1) dp[s] |= dp[s ^ 1 << i];\n\t\tbool check = true;\n\t\trep(s, 0, 1 << n) check &= (a[s] == '1') ^ dp[s];\n\t\tdebug(bitset<8>(x), dp);\n\t\tif (check) ok.pb(x);\n\t}\n\tdebug(ok.size());\n\tfor (int x : ok) debug(bitset<8>(x));\n\tif (ok.empty()) return cout << \"Impossible\" << endl, 0;\n\tcout << \"Possible\" << endl;\n\tvector<pii> ans(1);\n\trep(i, 0, n) if (ok[0] >> i & 1) {\n\t\trep(j, 1, i + 1) ans.eb(j, 0);\n\t\tans.eb(i + 1, 0);\n\t\tans.eb(i + 1, 1);\n\t\tans.eb(i, 1);\n\t\tfor (int j = i; j >= 0; --j) ans.eb(j, 0);\n\t\tdebug(i, ans);\n\t}\n\tcout << ans.size() - 1 << endl;\n\tfor (auto const& p : ans) cout << p.ff << \" \" << p.ss << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 15;\nconst int MAXS = 1 << 8;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nvector <pair <int, int>> ans, tmp;\nint n, bit[MAXN]; bool flg[MAXS]; char s[MAXS];\nvoid augment(vector <pair <int, int>> &res, int x) {\n\tif (res.size() == 0) {\n\t\tres.emplace_back(x, 0);\n\t\tres.emplace_back(x, 1);\n\t\treturn;\n\t}\n\tvector <pair <int, int>> tmp;\n\ttmp.emplace_back(x, 0);\n\tfor (auto x : res) tmp.push_back(x);\n\ttmp.emplace_back(x, 0);\n\treverse(tmp.begin(), tmp.end());\n\ttmp.emplace_back(x, 1);\n\tfor (auto x : res) tmp.push_back(x);\n\ttmp.emplace_back(x, 1);\n\tres = tmp;\n}\nvoid work(int mask) {\n\ttmp.clear(); int cur = 0;\n\tfor (int i = n; i >= 1; i--)\n\t\tif (mask & bit[i]) augment(tmp, i);\n\tfor (auto x : tmp) {\n\t\tif (x.second == 0) {\n\t\t\tif (cur >= x.first) while (cur >= x.first) ans.emplace_back(--cur, 0);\n\t\t\telse while (cur < x.first) ans.emplace_back(++cur, 0);\n\t\t} else {\n\t\t\tif (cur >= x.first) {\n\t\t\t\twhile (cur >= x.first + 1) ans.emplace_back(--cur, 0);\n\t\t\t\tans.emplace_back(cur, 1);\n\t\t\t\tans.emplace_back(--cur, 1);\n\t\t\t\tans.emplace_back(cur, 0);\n\t\t\t} else {\n\t\t\t\twhile (cur < x.first - 1) ans.emplace_back(++cur, 0);\n\t\t\t\tans.emplace_back(cur, 1);\n\t\t\t\tans.emplace_back(++cur, 1);\n\t\t\t\tans.emplace_back(cur, 0);\n\t\t\t}\n\t\t}\n\t}\n\twhile (cur > 0) ans.emplace_back(--cur, 0);\n}\nint main() {\n\tread(n), scanf(\"\\n%s\", s);\n\tfor (int i = 1; i <= n; i++)\n\t\tbit[i] = 1 << (i - 1);\n\tint goal = 1 << n;\n\tfor (int i = 0; i < goal; i++)\n\tfor (int j = 0; j < i; j++)\n\t\tif ((i & j) == j && s[j] == '0') flg[i] = true;\n\tfor (int i = 0; i < goal; i++)\n\t\tif (s[i] == '1' && flg[i]) {\n\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\tputs(\"Possible\");\n\tfor (int i = 0; i < goal; i++)\n\t\tif (s[i] == '0' && !flg[i]) work(i);\n\tcout << ans.size() << endl;\n\tprintf(\"%d %d\\n\", 0, 0);\n\tfor (auto x : ans)\n\t\tprintf(\"%d %d\\n\", x.first, x.second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define fr first\n#define sc second\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n\nvector<P> ret;\n\nvoid pos(int i){\n\tfor(int j=0;j<i;j++){\n\t\tret.push_back(P(j+1,0));\n\t}\n\tret.push_back(P(i,1));\n\tret.push_back(P(i+1,1));\n\tret.push_back(P(i+1,0));\n\tret.push_back(P(i,0));\n\tfor(int j=i-1;j>=0;j--){\n\t\tret.push_back(P(j,0));\n\t}\n}\nvoid neg(int i){\n\tfor(int j=0;j<i;j++){\n\t\tret.push_back(P(j+1,0));\n\t}\n\tret.push_back(P(i+1,0));\n\tret.push_back(P(i+1,1));\n\tret.push_back(P(i,1));\n\tret.push_back(P(i,0));\n\tfor(int j=i-1;j>=0;j--){\n\t\tret.push_back(P(j,0));\n\t}\n}\n\nvector<P> f(vector<P> vec,int t){\n\tint cnt[300]={};\n\tfor(int i=0;i<vec.size();i++){\n\t\tcnt[vec[i].sc]++;\n\t}\n\tint MIN=100;\n\tint id=-1;\n\tfor(int i=0;i<300;i++){\n\t\tif(cnt[i]==0)continue;\n\t\tif(MIN>cnt[i]){\n\t\t\tMIN=cnt[i];\n\t\t\tid=i;\n\t\t}\n\t}\n\t//cerr<<\"id=\"<<id<<endl;\n\tvector<P> ret;\n\tfor(int i=0;i<vec.size();i++){\n\t\tif(vec[i].sc!=id)ret.push_back(vec[i]);\n\t\telse {\n\t\t\tif(vec[i].fr==1){\n\t\t\t\tret.push_back(P(1,id));\n\t\t\t\tret.push_back(P(1,t));\n\t\t\t\tret.push_back(P(-1,id));\n\t\t\t\tret.push_back(P(-1,t));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret.push_back(P(1,t));\n\t\t\t\tret.push_back(P(1,id));\n\t\t\t\tret.push_back(P(-1,t));\n\t\t\t\tret.push_back(P(-1,id));\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nbool zero(vector<P> vec, int x){\n\tstack<P> st;\n\tfor(P p: vec){\n\t\tif((x>>p.sc)&1){\n\t\t\tif(st.size()==0){\n\t\t\t\tst.pop();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tP q=st.top();\n\t\t\tif(q.sc==p.sc&&p.sc+q.sc==0)st.pop();\n\t\t\telse st.push(p);\n\t\t}\n\t}\n\treturn st.size()==0;\n}\n\nint main(){\n\t/*vector<P> vvv;\n\tvvv.push_back(P(1,1));\n\tfor(int i=2;i<=8;i++){\n\t\tvvv=f(vvv,i);\n\t\tcerr<<i<<\" \"<<vvv.size()<<endl;\n\t}*/\n\t\n\t\n\tint n;\n\tstring s;\n\tcin>>n>>s;\n\t\n\tint a[300];\n\tfor(int i=0;i<(1<<n);i++)a[i]=s[i]-'0';\n\t\n\tbool used[300];\n\tmemset(used,0,sizeof used);\n\t\n\tint b[300];\n\tfor(int i=0;i<300;i++)b[i]=1;\n\t\n\tfor(int x=1;x<(1<<n);x++){\n\t\tused[x]=true;\n\t\tfor(int y=0;y<x;y++){\n\t\t\tif((x&y)==y)if(used[y])used[x]=false;\n\t\t}\n\t\tfor(int y=0;y<(1<<n);y++){\n\t\t\tif((x&y)==x)if(a[y]==1)used[x]=false;\n\t\t}\n\t\tif(used[x]){\n\t\t\tfor(int y=0;y<(1<<n);y++){\n\t\t\t\tif((x&y)==x)b[y]=0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool ok=true;\n\tfor(int i=0;i<(1<<n);i++)ok&=a[i]==b[i];\n\tif(!ok){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tvector<P> vv;\n\t/*for(int x=0;x<(1<<n);x++){\n\t\tif(!used[x])continue;\n\t\tif(vv.size()==0){\n\t\t\tvv.push_back(P(1,x));\n\t\t}\n\t\telse{\n\t\t\tvv=f(vv,x);\n\t\t}\n\t}*/\n\tvector<P> vec[300];\n\tret.push_back(P(0,0));\n\tfor(int x=0;x<(1<<n);x++){\n\t\tif(!used[x])continue;\n\t\tif(zero(vv,x)){\n\t\t\tint cnt=0;\n\t\t\tint c[10];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif((x>>i)&1)c[cnt++]=i;\n\t\t\t}\n\t\t\tvec[x].push_back(P(1,c[0]));\n\t\t\tfor(int i=1;i<cnt;i++)vec[x]=f(vec[x],c[i]);\n\t\t\tvv.insert(vv.end(),vec[x].begin(),vec[x].end());\n\t\t}\n\t}\n\tfor(P p: vv){\n\t\tif(p.fr==1)pos(p.sc);\n\t\telse neg(p.sc);\n\t}\n\t\n\t/*for(int i=0;i<vv.size();i++){\n\t\tif(vv[i].fr==1){\n\t\t\tfor(P p: vec[vv[i].sc]){\n\t\t\t\tif(p.fr==1)pos(p.sc);\n\t\t\t\telse neg(p.sc);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor(int j=vec[vv[i].sc].size()-1;j>=0;j--){\n\t\t\t\tP p=vec[vv[i].sc][j];\n\t\t\t\tif(p.fr==1)neg(p.sc);\n\t\t\t\telse pos(p.sc);\n\t\t\t}\n\t\t}\n\t}*/\n\t\n\tvector<P> ret2;\n\tfor(P p: ret){\n\t\tif(ret2.size()>=2&&ret2[ret2.size()-2]==p)ret.pop_back();\n\t\telse ret.push_back(p);\n\t}\n\tret=ret2;\n\t\n\tassert(ret.size()<=250000);\n\t\n\tputs(\"Possible\");\n\tprintf(\"%d\\n\",(int)(ret.size())-1);\n\tfor(int i=0;i<ret.size();i++){\n\t\tprintf(\"%d %d\\n\",ret[i].fr,ret[i].sc);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <string>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> Pii;\n\nconst ll mod = 1000000007;\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  string s;\n  cin >> s;\n\n  cout << \"Impossible\" << endl;\n  return 0;\n\n  vector<bool> a(1 << n);\n  for (int i = 0; i < (1 << n); i++) a[i] = s[i] - '0';\n\n  for (int i = 0; i < (1 << n); i++) {\n    bool good = true;\n    for (int j = 0; j < (1 << n); j++) {\n      bool obscured = false;\n      for (int k = 0; k < n; k++) {\n        bool point = j & (1 << k);\n        if (point && (i & (1 << k))) {\n          obscured = true;\n          break;\n        }\n      }\n      if (obscured == a[j]) {\n        good = false;\n        break;\n      }\n    }\n    if (good) {\n      vector<Pii> loop;\n      bool up = false;\n      for (int j = 0; j < n; j++) {\n        if (!up) {\n          loop.emplace_back(j, 0);\n          if (i & (1 << j)) {\n            loop.emplace_back(j, 1);\n            up = true;\n          }\n        }\n        else {\n          loop.emplace_back(j, 1);\n          if (!(i & (1 << j))) {\n            loop.emplace_back(j, 0);\n            up = false;\n          }\n        }\n      }\n      if (up) loop.emplace_back(n, 1);\n      for (int j = n; j >= 0; j--) loop.emplace_back(j, 0);\n\n      cout << \"Possible\" << endl;\n      cout << loop.size() - 1 << endl;\n      for (auto &x: loop) cout << x.first << \" \" << x.second << endl;\n      return 0;\n    }\n  }\n\n  cout << \"Impossible\" << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nchar A[1<<8|1];\nint op[333333],cnt;\nvoid make(int S,int ty){\n\tif(!S)return;\n\tint i=0;while(!(S>>i&1))i++;\n\tif(S==(1<<i)){\n\t\top[cnt++]=ty&2?-i-1:i+1;\n\t\treturn;\n\t}\n\tif(ty&1){\n\t\top[cnt++]=ty&2?i+1:-i-1;\n\t\tmake(S^1<<i,ty^3);\n\t\top[cnt++]=ty&2?-i-1:i+1;\n\t\tmake(S^1<<i,ty);\n\t}\n\telse{\n\t\tmake(S^1<<i,ty);\n\t\top[cnt++]=ty&2?-i-1:i+1;\n\t\tmake(S^1<<i,ty^3);\n\t\top[cnt++]=ty&2?i+1:-i-1;\n\t}\n}\nint x[333333],y[333333],L; \nint main(){\n\tint N;scanf(\"%d%s\",&N,A);\n\tfor(int S=1;S<1<<N;S++)if(A[S]=='1')\n\t\tfor(int T=S;T;T=T-1&S)if(A[T]=='0')return puts(\"Impossible\"),0;\n\tfor(int S=1;S<1<<N;S++)if(A[S]=='0'){\n\t\tbool fl=1;\n\t\tfor(int T=S-1&S;T&&fl;T=T-1&S)if(A[T]=='0')fl=0;\n\t\tif(fl)make(S,0),make(S,1);\n\t}\n\tfor(int i=0;i<cnt;i++){\n\t\tint x1=op[i]>0?op[i]-1:-op[i],x2=op[i]>0?x1+1:x1-1;\n\t\tfor(;x[L]!=x1;L++)x[L]<x1?x[L+1]=x[L]+1:x[L+1]=x[L]-1;\n\t\tx[++L]=x1;y[L]=1;\n\t\tx[++L]=x2;y[L]=1;\n\t\tx[++L]=x2;y[L]=0;\n\t}\n\tfor(;x[L];L++)x[L+1]=x[L]-1;\n\tprintf(\"Possible\\n%d\\n\",L);\n\tfor(int i=0;i<=L;i++)printf(\"%d %d\\n\",x[i],y[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long int int64;\n\n\nconst int N = 10;\nconst int LEN = (1 << N);\nchar s[LEN];\nbool skip[N];\n\nint main(int,  char **)\n{\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n    int n;\n    scanf(\"%d\", &n);\n    scanf(\"%s\", s);\n\n    for (int i = 0; i < n; i++)\n    {\n        if (s[1 << i] == '1')\n            skip[i] = true;\n    }\n\n    for (int i = 0; i < (1 << n); i++)\n    {\n        bool curskip = true;\n        for (int j = 0; j < n; j++)\n            if (i & (1 << j))\n                if (!skip[j])\n                    curskip = false;\n        if (curskip != (s[i] == '1'))\n        {\n            printf(\"Impossible\\n\");\n            return 0;\n        }\n    }\n\n    printf(\"Possible\\n\");\n    vector <pair <int, int>> ans;\n    ans.emplace_back(n, 0);\n    for (int i = n; i >= 0; i--)\n        ans.emplace_back(i, 1);\n    ans.emplace_back(0, 0);\n    for (int i = 0; i < n; i++)\n        if (skip[i])\n        {\n            ans.emplace_back(i, 1);\n            ans.emplace_back(i + 1, 1);\n            ans.emplace_back(i + 1, 0);\n        }\n        else\n            ans.emplace_back(i + 1, 0);\n\n    printf(\"%d\\n\", (int) ans.size());\n    for (auto p : ans)\n        printf(\"%d %d\\n\", p.first, p.second);\n\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing std::cerr;using std::cin;using std::cout;using std::abs;using std::min;using std::max;using std::swap;using std::map;using std::unordered_map;using std::unordered_set;using std::bitset;using std::pair;using std::set;using std::string;using std::vector;using std::sort;using ll=long long;using uint=unsigned int;using pii=pair<int,int>;using pll=pair<ll,ll>;using ull = unsigned long long;using ld=long double;template<typename T>void _(const char*s,T h){cerr<<s<<\" = \"<<h<<\"\\n\";}template<typename T,typename...Ts>void _(const char*s,T h,Ts...t){int b=0;while(((b+=*s=='(')-=*s==')')!=0||*s!=',')cerr<<*s++;cerr<<\" = \"<<h<<\",\";_(s+1,t...);}// break continue pop_back 998244353\n#define int ll\n#define pii pll\n#define f first\n#define s second\n#define pb emplace_back\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define sqr(x) ((x)*(x))\nstruct init{init(){cin.tie(0);std::iostream::sync_with_stdio(0);cout<<std::fixed<<std::setprecision(10);cerr<<std::fixed<<std::setprecision(5);}~init(){\n#ifdef LOCAL\n#define dbg(...) _(#__VA_ARGS__,__VA_ARGS__)\ncerr<<\"Time elapsed: \"<<(double)clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n#else\n#define dbg(...) \n#endif\n}}init;template<typename T,typename U>void upx(T&x,U y){if(x<y)x=y;}template<typename T,typename U>void upn(T&x,U y){if(x>y)x=y;}\n\nconst int N=2020;\nint a[N];\nvector<pii> ans={{0,0}};\nint n;\nstring pep(vector<int> v,int x){\n    string res;\n    if(v.back()>x){\n        res+=char('a'+x);\n        res+=pep(v,x+1);\n        res+=char('a'+x);\n    }else{\n        assert(v.back()==x);\n        if(v.size()>1){\n            v.pop_back();\n            auto s=pep(v,x+1);\n            res+=char('A'+x);\n            res+=s;\n            res+=char('A'+x);\n            reverse(s.begin(), s.end());\n            res+=char('a'+x);\n            res+=s;\n            res+=char('a'+x);\n        }else{\n            res+=char('A'+x);\n            res+=char('a'+x);\n        }\n    }\n    return res;\n}\nvoid add(int mask){\n    vector<int> v;\n    forn(i,n)if(mask>>i&1)v.pb(i);\n    reverse(v.begin(), v.end());\n    dbg(mask);\n    string s=pep(v,0);\n    dbg(mask,s);\n    int x=0,y=0;\n    for(char c:s){\n        if('a'<=c&&c<='z'){\n            int r=c-'a';\n            if(r==x){\n                if(!y){\n                    ans.pb(x+1,0);\n                }else{\n                    ans.pb(x,0);\n                    ans.pb(x+1,0);\n                }\n            }else{\n                assert(r==x-1);\n                if(!y){\n                    ans.pb(x-1,0);\n                }else{\n                    ans.pb(x,0);\n                    ans.pb(x-1,0);\n                }\n            }\n        }else{\n            int r=c-'A';\n            if(r==x){\n                if(!y){\n                    ans.pb(x,1);\n                    ans.pb(x+1,1);\n                }else{\n                    ans.pb(x,1);\n                }\n            }else{\n                assert(r==x-1);\n                if(!y){\n                    ans.pb(x,1);\n                    ans.pb(x-1,1);\n                }else{\n                    ans.pb(x-1,1);\n                }\n            }\n        }\n        x=ans.back().f;\n        y=ans.back().s;\n    }\n}\nint32_t main(){\n\n    cin>>n;\n    forn(i,1<<n){\n        char c;\n        cin>>c;\n        a[i]=c-'0';\n    }\n    int ok=1;\n    vector<int> kek;\n    forn(m1,1<<n){\n        forn(m2,1<<n){\n            if((m1&m2)==m2){\n                if(!a[m2]&&a[m1])ok=0;\n            }\n        }\n        if(!a[m1]){\n            int kok=1;\n            forn(m2,1<<n){\n                if((m1&m2)==m2&&m1!=m2){\n                    if(!a[m2])kok=0;\n                }\n            }\n            if(kok)kek.pb(m1);\n        }\n    }\n    if(!ok){\n        cout<<\"Impossible\\n\";\n        return 0;\n    }\n    for(int i:kek)add(i);\n    cout<<\"Possible\\n\";\n    cout<<ans.size()-1<<'\\n';\n    for(pii p:ans)cout<<p.f<<' '<<p.s<<'\\n';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cctype>\n#include<vector>\n#define pb push_back\n#define put(x,y) ans.pb((P){x,y})\nusing namespace std;\n#define G getchar()\nint read()\n{\n\tint x=0; char ch=G;\n\tfor (;!isdigit(ch);ch=G);\n\tfor (;isdigit(ch);ch=G) x=(x<<3)+(x<<1)+(ch^48);\n\treturn x;\n}\n#undef G\n\nint n; char s[260];\ntypedef pair<int,int> P;\nvector<P> ans;\nvoid dfs(int x,int msk,bool rev){  //from the top 1 or bottom 0\n\tint tot=0,pos;\n\tfor (int i=n;i;i--) if (msk>>i-1&1) tot++,pos=i;\n//\tprintf(\"dfs %d %d %d  %d %d\\n\",x,msk,rev,tot,pos);\n\tfor (int i=x+1;i<pos;i++) ans.pb((P){i,1});\n\tif (tot==1){\n\t\tif (rev) put(pos,1),put(pos,0),put(pos-1,0);\n\t\telse put(pos-1,0),put(pos,0),put(pos,1);\n\t}\n\telse{\n\t\tif (rev){\n\t\t\tput(pos,1);\n\t\t\tdfs(pos,msk^(1<<pos-1),1);\n\t\t\tput(pos-1,1); put(pos-1,0); put(pos,0); put(pos,1);\n\t\t\tdfs(pos,msk^(1<<pos-1),0);\n\t\t\tput(pos,0); put(pos-1,0);\n\t\t}\n\t\telse{\n\t\t\tput(pos-1,0); put(pos,0); put(pos,1);\n\t\t\tdfs(pos,msk^(1<<pos-1),1);\n\t\t\tput(pos,0); put(pos-1,0); put(pos-1,1); put(pos,1);\n\t\t\tdfs(pos,msk^(1<<pos-1),0);\n\t\t}\n\t}\n\tfor (int i=pos-1;i>=x;i--) ans.pb((P){i,1});\n}\nint main()\n{\n\tscanf(\"%d%s\",&n,s);\n\tfor (int i=0;i<(1<<n);i++)\n\t\tfor (int j=0;j<(1<<n);j++)\n\t\t\tif ((i&j)==j&&s[j]=='0'&&s[i]=='1') return puts(\"Impossible\"),0;\n\tputs(\"Possible\");\n\tans.pb((P){0,1});\n\tfor (int i=0;i<(1<<n);i++){\n\t\tif (s[i]=='1') continue;\n\t\tint tot=0;\n\t\tfor (int j=0;j<(1<<n);j++)\n\t\t\tif ((i&j)==j&&s[j]=='0') tot++;\n\t\tif (tot^1) continue;\n//\t\tprintf(\"make %d\\n\",i);\n\t\tdfs(0,i,1);\n//\t\tprintf(\"size %d\\n\",(int)ans.size());\n\t}\n\tprintf(\"%d\\n\",(int)ans.size()-1);\n\tfor (int i=0;i<ans.size();i++) printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\n\nconst int N = 8;\n\nint n;\nbool chk[N];\nstring s;\nvector<pair<int, int>> ve;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> n >> s;\n    for (int i = 0; i < n; i++) {\n        chk[i] = (s[1 << i] == '1');\n    }\n    for (int msk = 0; msk < (1 << n); msk++) {\n        int cur = 1;\n        for (int i = 0; i < n; i++) {\n            if (msk >> i & 1) {\n                cur &= chk[i];\n            }\n        }\n        if (cur != (s[msk] == '1')) {\n            return cout << \"Impossible\\n\", 0;\n        }\n    }\n    ve.push_back({0, 1});\n    for (int i = 1; i <= n; i++) {\n        if (ve.back().se == !chk[i - 1]) {\n            ve.push_back({i - 1, chk[i - 1]});\n        }\n        ve.push_back({i, chk[i - 1]});\n    }\n    while (ve.back().se < 1) {\n        ve.push_back({n, ve.back().se + 1});\n    }\n    while (ve.back().fi > 0) {\n        ve.push_back({ve.back().fi - 1, 1});\n    }\n    cout << \"Possible\\n\" << ve.size() - 1 << '\\n';\n    for (pair<int, int>& cur : ve) {\n        cout << cur.fi << \" \" << cur.se << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, begin, end) for(int i = (begin); i < (end); i++)\n#define rep(i, n) FOR(i, 0, n)\nusing ll = long long;\nusing namespace std;\n#define all(x) (x).begin(),(x).end()\nusing pii = pair<int, int>; using vi = vector<int>; using vl = vector<ll>;\n\nint N;\nbool isSubsetOf(int i, int oo) {\n    return (oo | i) == oo;\n}\n\nsigned main() {\n    cin >> N;\n    // unordered_set<int> oo, ii;\n    int oo(0), ii(0);\n    vi sss;\n    string as;\n    cin >> as;\n    rep(i, 1<<N) {\n        // auto ss = setter(i);\n        if(as[i] == '1') {\n            oo |= i;\n        }\n    }\n    rep(i, 1<<N) {\n        if(isSubsetOf(i, oo) && as[i] == '0') {\n            cout << \"Impossible\" << endl;\n            return 0;\n        } else if(!isSubsetOf(i, oo) && as[i] == '1') {\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n    \n    cout << \"Possible\" << endl;\n\n    ii = (1<<N) - oo - 1;\n    // cerr << oo << ' ' << ii << endl;\n    // cerr << (oo & ii) << endl;\n    vector<pii> p;\n    int before = 0;\n    // cerr << ii << endl;\n    p.push_back({0, 0});\n    rep(i, N) {\n        // cerr << ii << endl;\n        // cerr << ((ii&1) ^ before) << endl;\n        if((ii&1) ^ before) {\n            if(ii&1) {\n                if(i!=0) {\n                    p.push_back({i, 0});\n                }\n                p.push_back({i, 1});\n            } else {\n                p.push_back({i, 1});\n                p.push_back({i, 0});\n            }\n        } else {\n            if(i!=0)\n                p.push_back({i, before});\n        }\n        before = ii & 1;\n        ii >>= 1;\n    }\n    if (before)\n        p.push_back({N, 1});\n    for(int k = N; k>=0; k--) {\n        p.push_back({k, 0});\n    }\n\n    cout << p.size() - 1 << endl;\n    for(auto pp : p) {\n        cout << pp.first << ' ' << pp.second << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define long long long int\nusing namespace std;\n\n// @author: pashka\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    int n;\n    string s;\n    cin >> n >> s;\n    if (s[0] == '0') {\n        cout << \"Impossible\\n\";\n        return 0;\n    }\n    vector<bool> z(1 << n);\n    vector<pair<int, int>> p;\n    p.push_back({0, 0});\n    for (int j = 1; j < (1 << n); j++) {\n        if (z[j]) {\n            if (s[j] == '1') {\n                cout << \"Impossible\\n\";\n                return 0;\n            }\n            for (int i = 0; i < n; i++) {\n                z[j | (1 << i)] = true;\n            }\n            continue;\n        }\n        if (s[j] == '0') {\n            vector<pair<int, int>> pp;\n            for (int i = 0; i < n; i++) {\n                if (j & (1 << i)) {\n                    if (pp.size() == 0) {\n                        for (int x = 0; x <= i; x++) {\n                            pp.push_back({x, 0});\n                        }\n                        pp.push_back({i, 1});\n                        pp.push_back({i + 1, 1});\n                        for (int x = i + 1; x >= 0; x--) {\n                            pp.push_back({x, 0});\n                        }\n                    } else {\n                        vector<pair<int, int>> ppp = pp;\n                        for (int x = 1; x <= i; x++) {\n                            ppp.push_back({x, 0});\n                        }\n                        ppp.push_back({i, 1});\n                        ppp.push_back({i + 1, 1});\n                        for (int x = i + 1; x >= 1; x--) {\n                            ppp.push_back({x, 0});\n                        }\n                        reverse(pp.begin(), pp.end());\n                        ppp.insert(ppp.end(), pp.begin(), pp.end());\n                        for (int x = 1; x <= i + 1; x++) {\n                            ppp.push_back({x, 0});\n                        }\n                        ppp.push_back({i + 1, 1});\n                        ppp.push_back({i, 1});\n                        for (int x = i; x >= 0; x--) {\n                            ppp.push_back({x, 0});\n                        }\n                        pp = ppp;\n                    }\n                }\n            }\n            p.insert(p.end(), pp.begin() + 1, pp.end());\n            for (int i = 0; i < n; i++) {\n                z[j | (1 << i)] = true;\n            }\n        }\n    }\n    bool ok = false;\n    while (!ok) {\n        vector<pair<int, int>> pp;\n        ok = true;\n        for (int i = 0; i < p.size(); i++) {\n            if (i > 0 && i < (int)p.size() - 1 && p[i - 1] == p[i + 1]) {\n                ok = false;\n                i++;\n            } else {\n                pp.push_back(p[i]);\n            }\n        }\n        p = pp;\n    }\n    cout << \"Possible\\n\";\n    cout << p.size() - 1 << \"\\n\";\n    for (auto x : p) {\n        cout << x.first << \" \" << x.second << \"\\n\";\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define fr first\n#define sc second\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n\nvector<P> ret;\n\nvoid pos(int i){\n\tfor(int j=0;j<i;j++){\n\t\tret.push_back(P(j+1,0));\n\t}\n\tret.push_back(P(i,1));\n\tret.push_back(P(i+1,1));\n\tret.push_back(P(i+1,0));\n\tret.push_back(P(i,0));\n\tfor(int j=i-1;j>=0;j--){\n\t\tret.push_back(P(j,0));\n\t}\n}\nvoid neg(int i){\n\tfor(int j=0;j<i;j++){\n\t\tret.push_back(P(j+1,0));\n\t}\n\tret.push_back(P(i+1,0));\n\tret.push_back(P(i+1,1));\n\tret.push_back(P(i,1));\n\tret.push_back(P(i,0));\n\tfor(int j=i-1;j>=0;j--){\n\t\tret.push_back(P(j,0));\n\t}\n}\n\nvector<P> f(vector<P> vec,int t){\n\tint cnt[300]={};\n\tfor(int i=0;i<vec.size();i++){\n\t\tcnt[vec[i].sc]++;\n\t}\n\tint MIN=100;\n\tint id=-1;\n\tfor(int i=0;i<300;i++){\n\t\tif(cnt[i]==0)continue;\n\t\tif(MIN>cnt[i]){\n\t\t\tMIN=cnt[i];\n\t\t\tid=i;\n\t\t}\n\t}\n\t//cerr<<\"id=\"<<id<<endl;\n\tvector<P> ret;\n\tfor(int i=0;i<vec.size();i++){\n\t\tif(vec[i].sc!=id)ret.push_back(vec[i]);\n\t\telse {\n\t\t\tif(vec[i].fr==1){\n\t\t\t\tret.push_back(P(1,id));\n\t\t\t\tret.push_back(P(1,t));\n\t\t\t\tret.push_back(P(-1,id));\n\t\t\t\tret.push_back(P(-1,t));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret.push_back(P(1,t));\n\t\t\t\tret.push_back(P(1,id));\n\t\t\t\tret.push_back(P(-1,t));\n\t\t\t\tret.push_back(P(-1,id));\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nbool zero(vector<P> vec, int x){\n\tstack<P> st;\n\tfor(P p: vec){\n\t\tif((x>>p.sc)&1){\n\t\t\tif(st.size()==0){\n\t\t\t\tst.pop();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tP q=st.top();\n\t\t\tif(q.sc==p.sc&&p.sc+q.sc==0)st.pop();\n\t\t\telse st.push(p);\n\t\t}\n\t}\n\treturn st.size()==0;\n}\n\nint main(){\n\t/*vector<P> vvv;\n\tvvv.push_back(P(1,1));\n\tfor(int i=2;i<=8;i++){\n\t\tvvv=f(vvv,i);\n\t\tcerr<<i<<\" \"<<vvv.size()<<endl;\n\t}*/\n\t\n\t\n\tint n;\n\tstring s;\n\tcin>>n>>s;\n\t\n\tint a[300];\n\tfor(int i=0;i<(1<<n);i++)a[i]=s[i]-'0';\n\t\n\tbool used[300];\n\tmemset(used,0,sizeof used);\n\t\n\tint b[300];\n\tfor(int i=0;i<300;i++)b[i]=1;\n\t\n\tfor(int x=1;x<(1<<n);x++){\n\t\tused[x]=true;\n\t\tfor(int y=0;y<x;y++){\n\t\t\tif((x&y)==y)if(used[y])used[x]=false;\n\t\t}\n\t\tfor(int y=0;y<(1<<n);y++){\n\t\t\tif((x&y)==x)if(a[y]==1)used[x]=false;\n\t\t}\n\t\tif(used[x]){\n\t\t\tfor(int y=0;y<(1<<n);y++){\n\t\t\t\tif((x&y)==x)b[y]=0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool ok=true;\n\tfor(int i=0;i<(1<<n);i++)ok&=a[i]==b[i];\n\tif(!ok){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tvector<P> vv;\n\t/*for(int x=0;x<(1<<n);x++){\n\t\tif(!used[x])continue;\n\t\tif(vv.size()==0){\n\t\t\tvv.push_back(P(1,x));\n\t\t}\n\t\telse{\n\t\t\tvv=f(vv,x);\n\t\t}\n\t}*/\n\tvector<P> vec[300];\n\tret.push_back(P(0,0));\n\tfor(int x=0;x<(1<<n);x++){\n\t\tif(!used[x])continue;\n\t\tif(zero(vv,x)){\n\t\t\tint cnt=0;\n\t\t\tint c[10];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif((x>>i)&1)c[cnt++]=i;\n\t\t\t}\n\t\t\tvec[x].push_back(P(1,c[0]));\n\t\t\tfor(int i=1;i<cnt;i++)vec[x]=f(vec[x],c[i]);\n\t\t\tvv.insert(vv.end(),vec[x].begin(),vec[x].end());\n\t\t}\n\t}\n\tfor(P p: vv){\n\t\tif(p.fr==1)pos(p.sc);\n\t\telse neg(p.sc);\n\t}\n\t\n\t/*for(int i=0;i<vv.size();i++){\n\t\tif(vv[i].fr==1){\n\t\t\tfor(P p: vec[vv[i].sc]){\n\t\t\t\tif(p.fr==1)pos(p.sc);\n\t\t\t\telse neg(p.sc);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor(int j=vec[vv[i].sc].size()-1;j>=0;j--){\n\t\t\t\tP p=vec[vv[i].sc][j];\n\t\t\t\tif(p.fr==1)neg(p.sc);\n\t\t\t\telse pos(p.sc);\n\t\t\t}\n\t\t}\n\t}*/\n\t\n\tvector<P> ret2;\n\tfor(P p: ret){\n\t\tif(ret2.size()>=2&&ret2[ret2.size()-2]==p)ret2.pop_back();\n\t\telse ret2.push_back(p);\n\t}\n\tret=ret2;\n\t\n\t//assert(ret.size()<=250000);\n\t\n\tputs(\"Possible\");\n\tprintf(\"%d\\n\",(int)(ret.size())-1);\n\tfor(int i=0;i<ret.size();i++){\n\t\tprintf(\"%d %d\\n\",ret[i].fr,ret[i].sc);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\n\nconst int mod = 1e9+7;\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nint n;\nchar s[256];\nchar revc(char c)\n{\n\tif (c>='a'&&c<='z') return 'A'+c-'a';\n\telse return 'a'+c-'A';\n}\nstring getf(int msk)\n{\n\tstring ret;\n\tif (__builtin_popcount(msk)==1)\n\t{\n\t\tret.PB(__builtin_ctz(msk)+'a');\n\t\treturn ret;\n\t}\n\telse\n\t{\n\t\tint x = __builtin_ctz(msk&(-msk));\n\t\tint nmsk = msk-(1<<x);\n\t\tstring t = getf(nmsk);\n\t\tret += t;\n\t\tret.PB('a'+x);\n\t\treverse(t.begin(), t.end());\n\t\tfor (int i=0; i<t.size(); i++) t[i] = revc(t[i]);\n\t\tret += t;\n\t\tret.PB('A'+x);\n\t\treturn ret;\n\t}\n}\nvector<pair<int,int> > rt;\nint curx, cury;\nvoid go(int x, int y)\n{\n\twhile (curx<x) curx++, rt.PB(MP(curx, cury));\n\twhile (curx>x) curx--, rt.PB(MP(curx, cury));\n\twhile (cury<y) cury++, rt.PB(MP(curx, cury));\n\twhile (cury>y) cury--, rt.PB(MP(curx, cury));\n}\nvoid out(string s)\n{\n\tassert(s.size()<250000);\n\tcurx = cury = 0;\n\trt.PB(MP(0, 0));\n\n\tfor (int i=0; i<s.size(); i++)\n\t{\n\t\tbool f;\n\t\tint x;\n\t\tif (s[i]>='a'&&s[i]<='z')\n\t\t{\n\t\t\tf = true;\n\t\t\tx = s[i]-'a';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tf = false;\n\t\t\tx = s[i]-'A';\n\t\t}\n\t\tif (f)\n\t\t{\n\t\t\tgo(x, 0);\n\t\t\tgo(x, 1);\n\t\t\tgo(x+1, 1);\n\t\t\tgo(x+1, 0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgo(x+1, 0);\n\t\t\tgo(x+1, 1);\n\t\t\tgo(x, 1);\n\t\t\tgo(x, 0);\n\t\t}\n\t}\n\tgo(0, 0);\n}\nint main()\n{\n\tcin>>n;\n\tcin>>s;\n\tfor (int i=0; i<(1<<n); i++)\n\t{\n\t\tif (s[i]=='1')\n\t\t{\n\t\t\tfor (int j=0; j<(1<<n); j++)\n\t\t\t{\n\t\t\t\tif ((i&j)==j&&s[j]=='0')\n\t\t\t\t{\n\t\t\t\t\tputs(\"Impossible\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"Possible\");\n\tstring ans;\n\tvector<int> v;\n\tfor (int i=0; i<(1<<n); i++)\n\t{\n\t\tif (s[i]=='0')\n\t\t{\n\t\t\tbool f = true;\n\t\t\tfor (int j=0; j<i; j++)\n\t\t\t{\n\t\t\t\tif ((i&j)==j)\n\t\t\t\t{\n\t\t\t\t\tf &= s[j]=='1';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f)\n\t\t\t{\n\t\t\t\tstring t = getf(i);\n\t\t\t\tans += t;\n\t\t\t\tif ((i&(-i))!=i) for (auto c : t) ans += revc(c);\n\t\t\t}\n\t\t}\n\t}\n\tout(ans);\n\tputsi(rt.size()-1);\n\tfor (int i=0; i<rt.size(); i++) putsii(rt[i].FF, rt[i].SS);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing lint128 = __int128_t;\nconst lint mod = 1e9 + 7;\n#define all(x) (x).begin(), (x).end()\n#define bitcount(n) __builtin_popcountl((lint)(n))\n#define fcout cout << fixed << setprecision(15)\n#define highest(x) (63 - __builtin_clzl(x))\ntemplate<class T> inline void YES(T condition){ if(condition) cout << \"YES\" << endl; else cout << \"NO\" << endl; }\ntemplate<class T> inline void Yes(T condition){ if(condition) cout << \"Yes\" << endl; else cout << \"No\" << endl; }\ntemplate<class T> inline void assert_NO(T condition){ if(!condition){ cout << \"NO\" << endl; exit(0); } }\ntemplate<class T> inline void assert_No(T condition){ if(!condition){ cout << \"No\" << endl; exit(0); } }\ntemplate<class T> inline void assert_minus_1(T condition){ if(!condition){ cout << -1 << endl; exit(0); } }\nlint power(lint base, lint exponent, lint module){ if(exponent % 2){ return power(base, exponent - 1, module) * base % module; }else if(exponent){ lint root_ans = power(base, exponent / 2, module); return root_ans * root_ans % module; }else{ return 1; }}\nstruct position{ int y, x; }; position mv[4] = {{0, -1}, {1, 0}, {0, 1}, {-1, 0}}; // double euclidean(position first, position second){ return sqrt((second.x - first.x) * (second.x - first.x) + (second.y - first.y) * (second.y - first.y)); }\ntemplate<class T, class U> string to_string(pair<T, U> x){ return to_string(x.first) + \",\" + to_string(x.second); } string to_string(string x){ return x; }\ntemplate<class itr> void array_output(itr start, itr goal){ string ans; for(auto i = start; i != goal; i++) ans += to_string(*i) + \" \"; if(!ans.empty()) ans.pop_back(); cout << ans << endl; }\ntemplate<class itr> void cins(itr first, itr last){ for(auto i = first; i != last; i++){ cin >> (*i); } }\ntemplate<class T> T gcd_calc(T a, T b){ if(b){ return gcd_calc(b, a % b); }else{ return a; }}\ntemplate<class T> T gcd(T a, T b){ if(a < b) swap(a, b); return gcd_calc(a, b); }\ntemplate<class T> T lcm(T a, T b){ return a / gcd(a, b) * b; }\nstruct combination{ vector<lint> fact, inv; combination(int sz) : fact(sz + 1), inv(sz + 1){ fact[0] = 1; for(int i = 1; i <= sz; i++){ fact[i] = fact[i - 1] * i % mod; } inv[sz] = power(fact[sz], mod - 2, mod); for(int i = sz - 1; i >= 0; i--){ inv[i] = inv[i + 1] * (i + 1) % mod; } } lint C(int p, int q) const{ if(q < 0 || p < q) return 0; return (fact[p] * inv[q] % mod * inv[p - q] % mod); } };\ntemplate<class itr> bool next_sequence(itr first, itr last, int max_bound){ itr now = last; while(now != first){ now--; (*now)++; if((*now) == max_bound){ (*now) = 0; }else{ return true; } } return false; }\ntemplate<class T> bool chmax(T &a, const T &b){ if(a < b){ a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b){ if(b < a){ a = b; return 1; } return 0; }\ninline int at(lint x, int k){ return (x >> k) & 1; }\nrandom_device rnd;\n#define rep(i, n) for(int i = 0; i < n; i++)\n\nint main(){\n    int N;\n    cin >> N;\n    string s;\n    cin >> s;\n    int outside = 0;\n    for(int i = 0; i < (1 << N); i++){\n        int A = s[i] - '0';\n        if(A){\n            outside |= i;\n        }\n    }\n    for(int i = 0; i < (1 << N); i++){\n        int A = s[i] - '0';\n        if(!A && (outside & i) == i){\n            cout << \"Impossible\" << endl;\n            return 0;\n        }\n    }\n    vector<pair<int, int>> graph;\n    graph.push_back({0, 0});\n    for(int i = 0; i < N; i++){\n        if(at(outside, i)){\n            graph.push_back({i + 1, 0});\n        }else{\n            graph.push_back({i, 1});\n            graph.push_back({i + 1, 1});\n            graph.push_back({i + 1, 0});\n        }\n    }\n    for(int i = N - 1; i >= 0; i--){\n        graph.push_back({i, 0});\n    }\n    cout << \"Possible\" << endl;\n    cout << int(graph.size()) - 1 << endl;\n    for(auto i: graph){\n        cout << i.first << \" \" << i.second << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n#define MOD @\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nint N;\nchar A[300];\nvector<pair<int, int>> ans;\n\n/*\nvoid draw_curve(int mask, bool flip = false)\n{\n\tvector<pair<int, int>> seq;\n\tseq.push_back({0, 0});\n\tfor (int i = 0; i < N; ++i) {\n\t\tpair<int, int> src = make_pair(i, (mask >> i) & 1);\n\t\tpair<int, int> dest = make_pair(i + 1, (mask >> i) & 1);\n\t\tif (seq.back() != src) seq.push_back(src);\n\t\tseq.push_back(dest);\n\t}\n\tif (seq.back().second == 1) seq.push_back({N, 0});\n\tfor (int i = N - 1; i >= 0; --i) seq.push_back({i, 0});\n\tif (flip) reverse(seq.begin(), seq.end());\n\tfor (int i = 1; i < seq.size(); ++i) ans.push_back(seq[i]);\n}\n*/\nvoid draw_curve(int p, bool flip = false)\n{\n\tvector<pair<int, int>> seq;\n\tfor (int i = 0; i <= p; ++i) seq.push_back({i, 0});\n\tseq.push_back({p, 1});\n\tseq.push_back({p + 1, 1});\n\tfor (int i = p + 1; i >= 0; --i) seq.push_back({i, 0});\n\tif (flip) reverse(seq.begin(), seq.end());\n\tfor (int i = 1; i < seq.size(); ++i) ans.push_back(seq[i]);\n}\n\nint main()\n{\n\tscanf(\"%d%s\", &N, A);\n\tfor (int i = 0; i < (1 << N); ++i) {\n\t\tif (A[i] == '0') {\n\t\t\tfor (int j = 0; j < N; ++j) if ((i & (1 << j)) == 0) {\n\t\t\t\tif (A[i | (1 << j)] == '1') {\n\t\t\t\t\tputs(\"Impossible\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (A[0] == '0') {\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tputs(\"Possible\");\n\tvector<int> minima;\n\tfor (int i = 0; i < (1 << N); ++i) {\n\t\tif (A[i] == '0') {\n\t\t\tbool flg = true;\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tif ((i & (1 << j)) != 0 && A[i ^ (1 << j)] == '0') flg = false;\n\t\t\t}\n\t\t\tif (flg) minima.push_back(i);\n\t\t}\n\t}\n\tans.push_back({0, 0});\n\tfor (int m : minima) {\n\t\tvector<int> bits;\n\t\tfor (int i = 0; i < N; ++i) if (m & (1 << i)) bits.push_back(i);\n\t\tvector<int> seq;\n\t\tseq.push_back(bits[0]);\n\t\tfor (int i = 1; i < bits.size(); ++i) {\n\t\t\tvector<int> seq2;\n\t\t\tseq2.push_back(bits[i]);\n\t\t\tfor (int j = 0; j < seq.size(); ++j) {\n\t\t\t\tseq2.push_back(seq[j]);\n\t\t\t}\n\t\t\tseq2.push_back(~bits[i]);\n\t\t\tfor (int j = seq.size() - 1; j >= 0; --j) {\n\t\t\t\tseq2.push_back(~seq[j]);\n\t\t\t}\n\t\t\tseq = seq2;\n\t\t}\n\t\tfor (int i = 0; i < seq.size(); ++i) {\n\t\t\t//if (seq[i] >= 0) printf(\"%d \", seq[i]);\n\t\t\t//else printf(\"!%d \", ~seq[i]);\n\t\t\tif (seq[i] >= 0) draw_curve(seq[i]);\n\t\t\telse draw_curve(~seq[i], true);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans.size() - 1);\n\tfor (auto p : ans) printf(\"%d %d\\n\", p.first, p.second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <decimal/decimal>\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define rep(i, s, t) for (int i = s; i < int(t); ++i)\n\n#define sc\tscanf\n#define pr\tprintf\n#define ff\tfirst\n#define ss\tsecond\n#define mp\tmake_pair\n#define pb\tpush_back\n#define eb\templace_back\n#define range(c)\tc.begin(), c.end()\n#define lowbit(x)\t((x) & -(x))\n#define pop_count\t__builtin_popcount\n#define pop_count_64\t__builtin_popcountll\n#define tail_count\t__builtin_ctz\n#define tail_count_64\t__builtin_ctzll\n#define lead_count\t__builtin_clz\n#define lead_count_64\t__builtin_clzll\n\n#define TEMP template<typename\n#define CONST(type) constexpr type const\n\nTEMP... Ts> struct is_con { static CONST(bool) value = false; };\nTEMP... Ts> struct is_con<vector<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<list<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<deque<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<set<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<unordered_set<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<map<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<unordered_map<Ts...>> { static CONST(bool) value = true; };\n\nTEMP T1, typename T2> ostream& operator<<(ostream& os, pair<T1, T2> const& p) { return os << \"<\" << p.ff << \",\" << p.ss << \">\"; }\nTEMP T> typename enable_if<is_con<T>::value, ostream>::type& operator<<(ostream& os, T const& c) {\n\tos << \"{\";\n\tbool first = true;\n\tfor (auto const& x : c) {\n\t\tif (first) first = false;\n\t\telse os << \",\";\n\t\tos << \" \" << x;\n\t}\n\treturn os << \" }\";\n}\n\nTEMP T, typename... Ts> void dbg(T h, Ts... t) { cerr << \" \" << h; dbg<Ts...>(t...); }\ntemplate<> void dbg<int>(int x) { cerr << endl; }\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[ \"#__VA_ARGS__\" ] :\", dbg(__VA_ARGS__, 0)\n#else\n#define debug(...) 0\n#endif\n\nTEMP T, typename U> using ordered_map = tree<T, U, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\nTEMP T> using ordered_set = ordered_map<T, null_type>;\n\ntypedef long long i64;\ntypedef decimal::decimal128 i99;\ntypedef unsigned int u32;\ntypedef unsigned long long u64;\ntypedef float f32;\ntypedef double f64;\ntypedef long double f80;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<i64> vl;\n\nTEMP T> T& minn(T& lhs, T const& rhs) { return lhs = min(lhs, rhs); }\nTEMP T> T& maxx(T& lhs, T const& rhs) { return lhs = max(lhs, rhs); }\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n;\n\tstring a;\n\tcin >> n >> a;\n\tvi ok;\n\trep(x, 0, 1 << n) {\n\t\tvi dp(1 << n);\n\t\trep(i, 0, n) dp[1 << i] = x >> i & 1;\n\t\trep(i, 0, n) rep(s, 0, 1 << n) if (s >> i & 1) dp[s] |= dp[s ^ 1 << i];\n\t\tbool check = true;\n\t\trep(s, 0, 1 << n) check &= (a[s] == '1') ^ dp[s];\n\t\tdebug(bitset<8>(x), dp);\n\t\tif (check) ok.pb(x);\n\t}\n\tdebug(ok.size());\n\tfor (int x : ok) debug(bitset<8>(x));\n\tif (ok.empty()) return cout << \"Impossible\" << endl, 0;\n\tcout << \"Possible\" << endl;\n\tvector<pii> ans(1);\n\trep(i, 0, n) if (ok[0] >> i & 1) {\n\t\trep(j, 1, i) ans.eb(j, 0);\n\t\tans.eb(i + 1, 0);\n\t\tans.eb(i + 1, 1);\n\t\tans.eb(i, 1);\n\t\tfor (int j = i; j >= 0; --j) ans.eb(j, 0);\n\t}\n\tcout << ans.size() - 1 << endl;\n\tfor (auto const& p : ans) cout << p.ff << \" \" << p.ss << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define BT (1<<9)\nusing namespace std;\ntypedef pair <int,int> P;\n\nchar A[BT];\nstring ans;\nint n;\n\nint popcount(int S)\n{\n\tint cnt=0;\n\tfor(int i=0;i<n;i++) if(S>>i&1) cnt++;\n\treturn cnt;\n}\nstring get(int S)\n{\n\tint cnt=popcount(S);\n\tif(cnt==2)\n\t{\n\t\tvector <int> v;\n\t\tfor(int i=0;i<n;i++) if(S>>i&1) v.push_back(i);\n\t\tstring ret=\"\";\n\t\tret+='0'+v[0];\n\t\tret+='0'+v[1];\n\t\tret+='0'+v[0]+n;\n\t\tret+='0'+v[1]+n;\n\t\treturn ret;\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(S>>i&1)\n\t\t{\n\t\t\tstring A=get(S-(1<<i));\n\t\t\tstring ret=\"\";\n\t\t\tret+='0'+i;\n\t\t\tret+=A;\n\t\t\tret+='0'+i+n;\n\t\t\tfor(int j=(int) (A.size())-1;j>=0;j--)\n\t\t\t{\n\t\t\t\tint y=A[j]-'0';\n\t\t\t\tif(y>=n) y-=n;\n\t\t\t\telse y+=n;\n\t\t\t\tret+='0'+y;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn \"\";\n}\nvoid print(string ret)\n{\n\tint x=0;\n\tvector <P> ans;\n\tfor(int i=0;i<ret.size();i++)\n\t{\n\t\tint y=ret[i]-'0';\n\t\tif(y<n)\n\t\t{\n\t\t\twhile(x<y)\n\t\t\t{\n\t\t\t\tans.push_back(P(x,0));\n\t\t\t\tx++;\n\t\t\t}\n\t\t\twhile(x>y)\n\t\t\t{\n\t\t\t\tans.push_back(P(x,0));\n\t\t\t\tx--;\n\t\t\t}\n\t\t\tans.push_back(P(x,0));\n\t\t\tans.push_back(P(x,1));\n\t\t\tx++;\n\t\t\tans.push_back(P(x,1));\n\t\t}\n\t\telse\n\t\t{\n\t\t\ty-=n;\n\t\t\twhile(x<=y)\n\t\t\t{\n\t\t\t\tans.push_back(P(x,0));\n\t\t\t\tx++;\n\t\t\t}\n\t\t\twhile(x>y+1)\n\t\t\t{\n\t\t\t\tans.push_back(P(x,0));\n\t\t\t\tx--;\n\t\t\t}\n\t\t\tans.push_back(P(x,0));\n\t\t\tans.push_back(P(x,1));\n\t\t\tx--;\n\t\t\tans.push_back(P(x,1));\n\t\t}\n\t}\n\twhile(x>=0)\n\t{\n\t\tans.push_back(P(x,0));\n\t\tx--;\n\t}\n\tputs(\"Possible\");\n\tprintf(\"%d\\n\",ans.size());\n\tfor(int i=0;i<ans.size();i++) printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tscanf(\"%s\",&A);\n\tfor(int S=0;S<(1<<n);S++)\n\t{\n\t\tfor(int T=0;T<(1<<n);T++)\n\t\t{\n\t\t\tif((T|S)==S&&A[S]=='1'&&A[T]=='0')\n\t\t\t{\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tans=\"\";\n\tfor(int S=0;S<(1<<n);S++)\n\t{\n\t\tif(A[S]=='0')\n\t\t{\n\t\t\tbool up=true;\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tif(S>>i&1)\n\t\t\t\t{\n\t\t\t\t\tif(A[S-(1<<i)]=='0')\n\t\t\t\t\t{\n\t\t\t\t\t\tup=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!up) continue;\n\t\t\tif(popcount(S)>=2) ans+=get(S);\n\t\t\telse\n\t\t\t{\n\t\t\t\tint x;\n\t\t\t\tfor(int i=0;i<n;i++) if(S>>i&1) x=i;\n\t\t\t\tans+='0'+x;\n\t\t\t}\n\t\t\t//printf(\"%d %s\\n\",S,get(S).c_str());\n\t\t}\n\t}\n\t//printf(\"%s\\n\",ans.c_str());\n\tprint(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\nclock_t __my_start_clock = clock();\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(\"[\"#x\"] Time : %.3lf s.\\n\", (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n#define TIMESTAMPf(x,...) eprintf(\"[\" x \"] Time : %.3lf s.\\n\", __VA_ARGS__, (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n\nusing namespace std;\n\n#ifdef LOCAL\nstatic struct __timestamper {\n  string what;\n  __timestamper(const char* what) : what(what){};\n  __timestamper(const string& what) : what(what){};\n  ~__timestamper(){\n    TIMESTAMPf(\"%s\", what.data());\n\t}\n} __TIMESTAMPER(\"end\");\n#else \nstruct __timestamper {};\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\n\nbool solve(int n, string s) {\n  if (s[0] == '0')\n    return false;\n  vector<int> bads;\n  for (int i = 0; i < (1 << n); i++) {\n    for (int j = 0; j < n; j++) {\n      if (!(i & (1 << j))) {\n        continue;\n      }\n    }\n    bool found_zero_sub = false;\n    for (int j = 0; j < n; j++) {\n      if (!(i & (1 << j))) {\n        continue;\n      }\n      if (s[i ^ (1 << j)] == '0') {\n        found_zero_sub = true;\n      }\n    }\n    if (found_zero_sub) {\n      if (s[i] == '1') {\n        return false;\n      }\n    } else {\n      if (s[i] == '0') {\n        bads.push_back(i);\n      }\n    }\n  }\n\n  vector<int> seq;\n\n  for (int x : bads) {\n    vector<int> ss;\n    for (int i = 0; i < n; i++) {\n      if (!(x & (1 << i))) {\n        continue;\n      }\n      int cur = ss.size();\n      ss.push_back(i + 1);\n      for (int j = cur - 1; j >= 0; j--) {\n        ss.push_back(-ss[j]);\n      }\n      if (cur) {\n        ss.push_back(-(i + 1));\n      }\n    }\n    seq.insert(seq.end(), ss.begin(), ss.end());\n  }\n\n  printf(\"Possible\\n\");\n\n  vector<pair<int, int>> pts;\n\n  pts.emplace_back(0, 0);\n\n  auto push = [&] (int x,int y) {\n    if (pts.size() > 1 && pts[pts.size() - 2].first == x && pts[pts.size() - 2].second == y) {\n      pts.pop_back();\n    } else {\n      pts.emplace_back(x, y);\n    }\n  };\n\n  for (int x : seq) {\n    if (x < 0) {\n      x = -x;\n      for (int i = 1; i <= x; i++) {\n        push(0, i);\n      }\n      push(1, x);\n      push(1, x - 1);\n      for (int i = x - 1; i >= 0; i--) {\n        push(0, i);\n      }\n    } else {\n      for (int i = 1; i < x; i++) {\n        push(0, i);\n      }\n      push(1, x - 1);\n      push(1, x);\n      for (int i = x ; i >= 0; i--) {\n        push(0, i);\n      }\n    }\n  }\n\n  printf(\"%d\\n\", (int)pts.size() - 1);\n  for (auto p : pts) {\n    printf(\"%d %d\\n\", p.second, p.first);\n  }\n  return true;\n}\n\nint main() {\n#ifdef LOCAL\n  freopen(\"e.in\", \"r\", stdin);\n  freopen(\"e.out\", \"w\", stdout);\n#endif\n\n  int n;\n  while (scanf(\"%d\", &n) == 1) {\n    char s[512];\n    scanf(\"%s\", s);\n    if (!solve(n, s)) {\n      printf(\"Impossible\\n\");\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cctype>\n#include<vector>\n#define pb push_back\nusing namespace std;\n#define G getchar()\nint read()\n{\n\tint x=0; char ch=G;\n\tfor (;!isdigit(ch);ch=G);\n\tfor (;isdigit(ch);ch=G) x=(x<<3)+(x<<1)+(ch^48);\n\treturn x;\n}\n#undef G\n\nint n; char s[260];\ntypedef pair<int,int> P;\nvector<P> ans;\nvoid dfs(int x,int msk,bool rev){  //from the top 1 or bottom 0\n\tint tot=0,pos;\n\tfor (int i=n;i;i--) if (msk>>i-1&1) tot++,pos=i;\n\tif (tot==1){\n\t\tfor (int i=x+1;i<=pos;i++) ans.pb((P){i,rev});\n\t\tans.pb((P){pos,rev^1}); ans.pb((P){pos-1,rev^1});\n\t\tfor (int i=pos-1;i>=x;i--) ans.pb((P){i,rev});\n\t\treturn;\n\t}\n\tfor (int i=x+1;i<=pos;i++) ans.pb((P){i,rev});\n\tdfs(pos,msk^(1<<pos-1),1);\n\tfor (int i=pos-1;i>=x;i--) ans.pb((P){i,rev});\n\tfor (int i=x;i<=pos;i++) ans.pb((P){i,rev^1});\n\tdfs(pos,msk^(1<<pos-1),0);\n\tfor (int i=pos-1;i>=x;i--) ans.pb((P){i,rev^1});\n\tans.pb((P){x,rev});\n}\nint main()\n{\n\tscanf(\"%d%s\",&n,s);\n\tfor (int i=0;i<(1<<n);i++)\n\t\tfor (int j=0;j<(1<<n);j++)\n\t\t\tif ((i&j)==j&&s[j]=='0'&&s[i]=='1') return puts(\"Impossible\"),0;\n\tputs(\"Possible\");\n\tans.pb((P){0,1});\n\tfor (int i=0;i<(1<<n);i++){\n\t\tif (s[i]=='1') continue;\n\t\tint tot=0;\n\t\tfor (int j=0;j<(1<<n);j++)\n\t\t\tif ((i&j)==j&&s[j]=='0') tot++;\n\t\tif (tot^1) continue;\n\t\tdfs(0,i,1);\n\t}\n\tprintf(\"%d\\n\",(int)ans.size()-1);\n\tfor (int i=0;i<ans.size();i++) printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n    #define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxn = 10;\nconst int maxmask = 1 << maxn;\n\nchar s[maxmask];\nint n;\nbool pin[maxn];\nvector<pair2<int>> points;\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", s);\n\tfor (int i = 0; i < n; i++) pin[i] = true;\n\tfor (int mask = 0; mask < (1 << n); mask++) if (s[mask] == '1')\n\t{\n\t\tfor (int i = 0; i < n; i++) if ((mask & (1 << i)))\n\t\t{\n\t\t\tpin[i] = false;\n\t\t}\n\t}\n\tfor (int mask = 0; mask < (1 << n); mask++) if (s[mask] == '0')\n\t{\n\t\tbool ok = false;\n\t\tfor (int i = 0; i < n; i++) if ((mask & (1 << i)))\n\t\t{\n\t\t\tok |= pin[i];\n\t\t}\n\t\tif (!ok)\n\t\t{\n\t\t\tcout << \"Impossible\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tpoints.pb({0, 0});\n\tfor (int i = 1; i < n; i++) points.pb({i, 0});\n\t//for (int i = n; i >= 0; i--) points.pb({i, 1});\n\t//for (int i = 0; i < n; i++) \n\t//{\n\t\t//if (pin[i])\n\t\t//{\n\t\t\t//points.pb({i, 0});\n\t\t\t//points.pb({i + 1, 0});\n\t\t//}\n\t\t//points.pb({i + 1, 1});\n\t//}\n\tfor (int i = n - 1; i >= 0; i--) \n\t{\n\t\tpoints.pb({i + 1, 0});\n\t\tif (pin[i])\n\t\t{\n\t\t\tpoints.pb({i + 1, 1});\n\t\t\tpoints.pb({i, 1});\n\t\t}\n\t}\n\tcout << \"Possible\" << endl;\n\tcout << (int)points.size() << endl;\n\tpoints.pb(points[0]);\n\tfor (auto t : points) cout << t.fi << ' ' << t.se << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\n#define all(v) v.begin(), v.end()\n#define len(v) ((int)(v).size())\n#define pb push_back\n#define kek pop_back\n#define pii pair<int, int>\n#define mp make_pair\n#define int ll\n\n#define debug(x) cout << #x << \" = \" << x << endl;\n\nconst int INF = (is_same<int, ll>::value ? 1e18 + 666 : 1e9 + 666);\n\n// const int MEM_SIZE = 5e8;\n// char mem[MEM_SIZE];\n// int cur_mem_ptr = 0;\n\n// void* operator new(size_t n) {\n//     cur_mem_ptr += n;\n//     return mem + cur_mem_ptr - n;\n// }\n\n// void operator delete(void*) noexcept {}\n// void operator delete(void*, size_t) noexcept {}\n\ntemplate<class t1, class t2>\nbool cmin(t1 &a, const t2 &b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class t1, class t2>\nbool cmax(t1 &a, const t2 &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#ifndef LOCAL\nvoid UseFiles(const string &s) {\n    freopen((s + \".in\").c_str(), \"r\", stdin);\n    freopen((s + \".out\").c_str(), \"w\", stdout);\n}\n#else\nvoid UseFiles(const string&) {}\n#endif\n\nvoid run();\n\nsigned main() {\n    // UseFiles(\"cowboys\");\n    iostream::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    run();\n}\n\nvoid run() {\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    if (s[0] == '0') {\n        cout << \"Impossible\" << endl;\n        return;\n    }\n    int msk = 0;\n    for (int i = 1; i < (1 << n); ++i) {\n        if (s[i] == '1' && __builtin_popcount(i) > __builtin_popcount(msk)) {\n            msk = i;\n        }\n    }\n    for (int i = 0; i < (1 << n); ++i) {\n        if ((s[i] == '1') != ((i & msk) == i)) {\n            cout << \"Impossible\" << endl;\n            return;\n        }\n    }\n    vector<pii> ans;\n    ans.pb({0, 1});\n    for (int i = 0; i <= n; ++i) {\n        ans.pb({i, 2});\n    }\n    ans.pb({n, 1});\n    for (int i = n - 1; i > -1; --i) {\n        if (!(msk & (1 << i))) {\n            ans.pb({i + 1, 0});\n            ans.pb({i, 0});\n            ans.pb({i, 1});\n        } else {\n            ans.pb({i, 1});\n        }\n    }\n    cout << \"Possible\" << endl;\n    cout << len(ans) - 1 << endl;\n    for (auto &x : ans) {\n        cout << x.first << \" \" << x.second << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define re register\n#define cs const\n\nusing std::cerr;\nusing std::cout;\nusing pii=std::pair<int,int>;\n#define fi first\n#define se second\n\nstd::string inv(std::string s){\n\tstd::string res=\"\";\n\tstd::reverse(s.begin(),s.end());\n\tfor(char c:s)\n\t\tif(isupper(c))res+=c-'A'+'a';\n\t\telse res+=c-'a'+'A';\n\treturn res;\n}\n\nint n;\nstd::string A;\n\nvoid Main(){\n\tstd::cin>>n>>A;\n\tif(A[0]=='0'){\n\t\tputs(\"Impossible\");\n\t\treturn ;\n\t}for(int re i=0;i<(1<<n);++i)\n\t\tif(A[i]=='1')for(int re j=i;j;j=i&(j-1))\n\t\t\tif(A[j]=='0'){\n\t\t\t\tputs(\"Impossible\");\n\t\t\t\treturn ;\n\t\t\t}\n\tstd::vector<pii> p({{0,0}});\n\tfor(int re s=0;s<(1<<n);++s)if(A[s]=='0'){\n\t\tbool flag=true;\n\t\tfor(int re t=s&(s-1);t&&flag;t=s&(t-1))\n\t\t\tif(A[t]=='0')flag=false;\n\t\tif(!flag)continue;\n\t\tstd::string q;\n\t\tfor(int re i=0;i<n;++i)\n\t\t\tif(s&(1<<i)){\n\t\t\t\tif(q.empty())q+='a'+i;\n\t\t\t\telse q=(char)('a'+i)+q+(char)('A'+i)+inv(q);\n\t\t\t}\n\t\tint nw=0;\n\t\tfor(char c:q){\n\t\t\tint i,dir;\n\t\t\tif(isupper(c))\n\t\t\t\ti=c-'A',dir=0;\n\t\t\telse \n\t\t\t\ti=c-'a',dir=1;\n\t\t\tfor(int j=nw+1;j<=i;++j)\n\t\t\t\tp.push_back({j,0});\n\t\t\tfor(int j=nw-1;j>=i;--j)\n\t\t\t\tp.push_back({j,0});\n\t\t\tnw=i;\n\t\t\tif(dir){\n\t\t\t\tp.push_back({i,1});\n\t\t\t\tp.push_back({i+1,1});\n\t\t\t\tp.push_back({i+1,0});\n\t\t\t\tp.push_back({i,0});\n\t\t\t}else {\n\t\t\t\tp.push_back({i+1,0});\n\t\t\t\tp.push_back({i+1,1});\n\t\t\t\tp.push_back({i,1});\n\t\t\t\tp.push_back({i,0});\n\t\t\t}\n\t\t}\n\t\tfor(int j=nw-1;~j;--j)\n\t\t\tp.push_back({j,0});\n\t}\n\tcout<<\"Possible\\n\"<<(p.size()-1)<<\"\\n\";\n\tfor(auto t:p)cout<<t.fi<<\" \"<<t.se<<\"\\n\";\n}\n\ninline void file(){\n#ifdef zxyoi\n\tfreopen(\"E.in\",\"r\",stdin);\n#endif\n}signed main(){file();Main();return 0;}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define debug(x) {cerr << #x << \" = \" << x << '\\n';}\n#define PR(a, n) {cerr << #a << \" = \"; for (int _=1; _<=n; ++_) cerr << a[_] << ' '; cerr << '\\n';}\n#define PR0(a, n) {cerr << #a << \" = \"; for (int _=0; _<n; ++_) cerr << a[_] << ' '; cerr << '\\n';}\n#define FILE_NAME \"data\"\n\n\nvector<pair<int, int> > constructCurve(int n, int mask) {\n    vector<pair<int, int> > res(1);\n\n    for (int i = 0; i < n; ++i) {\n        int x = res.back().first;\n        int y = res.back().second;\n        if ((mask >> i) & 1) {\n            res.push_back({x, y + 1});\n            res.push_back({x + 1, y + 1});\n            res.push_back({x + 1, y});\n        }\n        else {\n            res.push_back({x + 1, y});\n        }\n    }\n\n    while (res.back() != make_pair(0, 0)) {\n        res.push_back({res.back().first - 1, res.back().second});\n    }\n\n    return res;\n}\n\n\nint main() {\n    int n;\n    string state;\n    cin >> n >> state;\n\n    for (int x = 0; x < 1 << n; ++x) {\n        bool ok = true;\n        for (int y = 0; y < 1<<n; ++y) {\n            if ((state[y] == '0' && ((x & y) == 0)) ||\n                (state[y] == '1' && ((x & y) > 0))) {\n                ok = false;\n            }\n        }\n\n        if (ok) {\n            debug(x);\n            puts(\"Possible\");\n\n            vector<pair<int, int> > curve = constructCurve(n, x);\n            cout << curve.size() - 1 << '\\n';\n            for (auto p : curve) {\n                cout << p.first << ' ' << p.second << '\\n';\n            }\n\n            return 0;\n        }\n    }\n\n    puts(\"Impossible\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing ll = long long;\nusing ull = unsigned long long;\nusing namespace std;\nconst int INF = 1e10;\nconst int MOD = 1e9 + 7;\n#define dump(x)                             \\\n    if (dbg) {                              \\\n        cerr << #x << \" = \" << (x) << endl; \\\n    }\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define FOR1(n) for (ll i = 0; i < (n); ++i)\n#define FOR2(i, n) for (ll i = 0; i < (n); ++i)\n#define FOR3(i, a, b) for (ll i = (a); i < (b); ++i)\n#define FOR4(i, a, b, c) for (ll i = (a); i < (b); i += (c))\n#define FOR(...) overload4(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)\n#define FORR(i, a, b) for (int i = (a); i <= (b); ++i)\n#define bit(n, k) ((n >> k) & 1) /*nのk bit目*/\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\nvoid Yes(bool flag = true) {\n    if (flag)\n        cout << \"Yes\" << endl;\n    else\n        cout << \"No\" << endl;\n}\nvoid No(bool flag = true) {\n    Yes(!flag);\n}\nvoid YES(bool flag = true) {\n    if (flag)\n        cout << \"YES\" << endl;\n    else\n        cout << \"NO\" << endl;\n}\nvoid NO(bool flag = true) {\n    YES(!flag);\n}\n#define pb emplace_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define all(v) (v).begin(), (v).end()\n#define SZ(x) ((int)(x).size())\n#define P pair<int, int>\n//#define V vector<int>\n//#define S set<int>\n#define itn int\nbool dbg = false;\n\nint N;\nstring A;\nbool checked[111010];\nbool out[111010];\n\nvector<int> x, y;\n\nvoid go(int gx) {\n    int sx;\n    int ys;\n    sx = x[(int)x.size() - 1];\n    ys = y[(int)y.size() - 1];\n    if (sx > gx) {\n        while (sx != gx) {\n            sx--;\n            x.pb(sx);\n            y.pb(ys);\n        }\n    } else if (sx < gx) {\n        while (sx != gx) {\n            sx++;\n            x.pb(sx);\n            y.pb(ys);\n        }\n    }\n}\nvoid chy() {\n    x.pb(x[(int)x.size() - 1]);\n    y.pb(!y[(int)y.size() - 1]);\n}\n\nvoid fill(int T, bool nikai = false) {\n    int cnt = __builtin_popcount(T);\n    if (cnt == 1) {\n        int nxt = __builtin_ffs(T) - 1;\n        go(nxt);\n        chy();\n        go(nxt + 1);\n        chy();\n        go(nxt);\n        chy();\n        go(nxt + 1);\n        chy();\n        go(nxt);\n        chy();\n        go(nxt + 1);\n        chy();\n        go(nxt);\n        return;\n    } else {\n        int n1 = __builtin_ffs(T) - 1;\n        T -= (1 << n1);\n        int n2 = __builtin_ffs(T) - 1;\n        int n3 = n2;\n        FOR(N) {\n            if ((1 << i) & T) {\n                n3 = i;\n            }\n        }\n        n3++;\n\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        go(n2);\n        //ここで再帰\n        if (n2 + 1 != n3) {\n            fill(T);\n        }\n        chy();\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        go(n2);\n        chy();\n        go(n1);\n\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        go(n2);\n        chy();\n        go(n1);\n        chy();\n        go(n3);\n        chy();\n        go(n2);\n        chy();\n        go(n1);\n    }\n}\n\n\nvoid solve() {\n    bool flag = true;\n    int tmp = -1;\n    for (int T = 1; T < (1 << N); T++) {\n        if (A[T] == 1) {\n            continue;\n        }\n        if (checked[T]) {\n            continue;\n        }\n        out[T] = true;\n        if (__builtin_popcount(T) == 1) {\n            tmp = T;\n        }\n        for (int i = T; i < (1 << N); i = (i + 1) | T) {\n            // ここに処理を書く\n            if (A[i] == 1) {\n                flag = false;\n            }\n            checked[i] = true;\n        }\n    }\n    if (true) {\n        cout << \"Impossible\" << endl;\n        return;\n    }\n    cout << \"Possible\" << endl;\n\n    x.pb(0);\n    y.pb(0);\n\n    for (int T = 1; T < (1 << N); T++) {\n        if (out[T]) {\n            fill(T);\n        }\n    }\n    go(0);\n    int L = x.size();\n    cout << L - 1 << endl;\n\n    FOR(L) {\n        cout << x[i] << \" \" << y[i] << endl;\n    }\n}\n\nsigned main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cin >> N;\n    cin >> A;\n    for (auto& c : A)\n        c -= '0';\n\n\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\nusing namespace std;\nnamespace Base{\n\t# define mr make_pair\n\ttypedef long long ll;\n\ttypedef double db;\n\tconst int inf = 0x3f3f3f3f, INF = 0x7fffffff;\n\tconst ll  infll = 0x3f3f3f3f3f3f3f3fll, INFll = 0x7fffffffffffffffll;\n\ttemplate<typename T> void read(T &x){\n    \tx = 0; int fh = 1; double num = 1.0; char ch = getchar();\n\t\twhile (!isdigit(ch)){ if (ch == '-') fh = -1; ch = getchar(); }\n\t\twhile (isdigit(ch)){ x = x * 10 + ch - '0'; ch = getchar(); }\n\t    if (ch == '.'){\n\t    \tch = getchar();\n\t    \twhile (isdigit(ch)){num /= 10; x = x + num * (ch - '0'); ch = getchar();}\n\t\t}\n\t\tx = x * fh;\n\t}\n\ttemplate<typename T> void chmax(T &x, T y){x = x < y ? y : x;}\n\ttemplate<typename T> void chmin(T &x, T y){x = x > y ? y : x;}\n}\nusing namespace Base;\n\nconst int N = 300010;\nint dx, dy, total, qx[N], qy[N], n, use[N], nd[N], cnt, now[N], ths[N], nxt[N];\nchar s[N];\nvoid moveto(int x){\n\tif (x > dx) for (int i = dx + 1; i <= x; i++) qx[++total] = i, qy[total] = dy;\n\t\telse for (int i = dx - 1; i >= x; i--) qx[++total] = i, qy[total] = dy;\n\tdx = x;\n}\n\nvoid moveup(){\n\tqx[++total] = dx, qy[total] = ++dy;\n}\nvoid movedown(){\n\tqx[++total] = dx, qy[total] = --dy;\n}\nint main(){\n\tread(n);\n\tscanf(\"\\n%s\", s);\n\tbool flag = true;\n\tfor (int i = 0; i < (1 << n); i++)\n\t\tif (s[i] == '0'){\n\t\t\tif (use[i] == 0) nd[++cnt] = i; \n\t\t\tfor (int j = 0; j < (1 << n); j++)\n\t\t\t\tif ((i | j) == j){\n\t\t\t\t\tif (s[j] == '1') flag = false;\n\t\t\t\t\tuse[j] = true;\n\t\t\t\t}\n\t\t}\n\tif (flag == false){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\t\n\tdx = 0, dy = 0;\n\tfor (int i = 1; i <= cnt; i++){\n\t\tint num = 0, len = 2, nlen;\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif (nd[i] & (1 << (j - 1))) now[++num] = j;\n\t\tths[1] = now[num]; ths[2] = -now[num];\n\t\tfor (int j = num - 1; j >= 1; j--){\n\t\t\tnxt[nlen = 1] = now[j];\n\t\t\tfor (int k = 1; k <= len; k++) nxt[++nlen] = ths[k];\n\t\t\tnxt[++nlen] = now[j];\n\t\t\tnxt[++nlen] = -now[j];\n\t\t\tfor (int k = len; k >= 1; k--) nxt[++nlen] = ths[k];\n\t\t\tnxt[++nlen] = -now[j];\n\t\t\tlen = nlen;\n\t\t\tfor (int k = 1; k <= len; k++) ths[k] = nxt[k];\n\t\t}\n\t\tfor (int j = 1; j <= len; j++){\n\t\t\tint x = abs(ths[j]);\n\t\t\tif (dx < x){\n\t\t\t\tmoveto(x - 1); \n\t\t\t\tif (ths[j] > 0) moveup(), moveto(x), movedown();\n\t\t\t\t\telse moveto(x);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmoveto(x);\n\t\t\t\tif (ths[j] > 0) moveup(), moveto(x - 1), movedown();\n\t\t\t\t\telse moveto(x - 1);\n\t\t\t}\n\t\t}\n\t\tmoveto(0);\n\t}\n\t\n\tputs(\"Possible\");\n\tprintf(\"%d\\n\", total + 1);\n\tfor (int i = 0; i <= total; i++)\n\t\tprintf(\"%d %d\\n\", qx[i], qy[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\nusing namespace std;\nnamespace Base{\n\t# define mr make_pair\n\ttypedef long long ll;\n\ttypedef double db;\n\tconst int inf = 0x3f3f3f3f, INF = 0x7fffffff;\n\tconst ll  infll = 0x3f3f3f3f3f3f3f3fll, INFll = 0x7fffffffffffffffll;\n\ttemplate<typename T> void read(T &x){\n    \tx = 0; int fh = 1; double num = 1.0; char ch = getchar();\n\t\twhile (!isdigit(ch)){ if (ch == '-') fh = -1; ch = getchar(); }\n\t\twhile (isdigit(ch)){ x = x * 10 + ch - '0'; ch = getchar(); }\n\t    if (ch == '.'){\n\t    \tch = getchar();\n\t    \twhile (isdigit(ch)){num /= 10; x = x + num * (ch - '0'); ch = getchar();}\n\t\t}\n\t\tx = x * fh;\n\t}\n\ttemplate<typename T> void chmax(T &x, T y){x = x < y ? y : x;}\n\ttemplate<typename T> void chmin(T &x, T y){x = x > y ? y : x;}\n}\nusing namespace Base;\n\nconst int N = 300010;\nint dx, dy, total, qx[N], qy[N], n, use[N], nd[N], cnt, now[N], ths[N], nxt[N];\nchar s[N];\nvoid moveto(int x){\n\tif (x > dx) for (int i = dx + 1; i <= x; i++) qx[++total] = i, qy[total] = dy;\n\t\telse for (int i = dx - 1; i >= x; i--) qx[++total] = i, qy[total] = dy;\n\tdx = x;\n}\n\nvoid moveup(){\n\tqx[++total] = dx, qy[total] = ++dy;\n}\nvoid movedown(){\n\tqx[++total] = dx, qy[total] = --dy;\n}\nint main(){\n\tread(n);\n\tscanf(\"\\n%s\", s);\n\tbool flag = true;\n\tfor (int i = 0; i < (1 << n); i++)\n\t\tif (s[i] == '0'){\n\t\t\tif (use[i] == 0) nd[++cnt] = i; \n\t\t\tfor (int j = 0; j < (1 << n); j++)\n\t\t\t\tif ((i | j) == j){\n\t\t\t\t\tif (s[j] == '1') flag = false;\n\t\t\t\t\tuse[j] = true;\n\t\t\t\t}\n\t\t}\n\tif (flag == false){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\t\n\tdx = 0, dy = 0;\n\tfor (int i = 1; i <= cnt; i++){\n\t\tint num = 0, len = 0, nlen;\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif (nd[i] & (1 << (j - 1))) now[++num] = j;\n\t\tfor (int j = num; j >= 1; j--){\n\t\t\tnxt[nlen = 1] = now[j];\n\t\t\tfor (int k = 1; k <= len; k++) nxt[++nlen] = ths[k];\n\t\t\tnxt[++nlen] = now[j];\n\t\t\tnxt[++nlen] = -now[j];\n\t\t\tfor (int k = len; k >= 1; k--) nxt[++nlen] = ths[k];\n\t\t\tnxt[++nlen] = -now[j];\n\t\t\tlen = nlen;\n\t\t\tfor (int k = 1; k <= len; k++) ths[k] = nxt[k];\n\t\t}\n\t\tfor (int j = 1; j <= nlen; j++){\n\t\t\tint x = abs(ths[j]);\n\t\t\tif (dx < x){\n\t\t\t\tmoveto(x - 1); \n\t\t\t\tif (ths[j] > 0) moveup(), moveto(x), movedown();\n\t\t\t\t\telse moveto(x);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmoveto(x);\n\t\t\t\tif (ths[j] > 0) moveup(), moveto(x - 1), movedown();\n\t\t\t\t\telse moveto(x - 1);\n\t\t\t}\n\t\t}\n\t\tmoveto(0);\n\t}\n\t\n\tputs(\"Possible\");\n\tprintf(\"%d\\n\", total + 1);\n\tfor (int i = 0; i <= total; i++)\n\t\tprintf(\"%d %d\\n\", qx[i], qy[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#define NO return !printf(\"Impossible\\n\")\n#define N 433\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint n,a[N];\nchar s[N];\nvector<pair<int,int> > ans;\nstring Rev(string s){\n\treverse(s.begin(),s.end());\n\treturn s;\n}\nint main(){\n\tn=read();\n\tscanf(\"%s\",s);\n\tfor(int i=0;i<(1<<n);++i){\n\t\ta[i]=s[i]-'0';\n\t}\n\tif(!a[0])NO;\n\tfor(int i=0;i<(1<<n);++i){\n\t\tif(a[i]){\n\t\t\tfor(int j=(i-1)&i;j;j=(j-1)&i){\n\t\t\t\tif(!a[j])NO;\n\t\t\t}\n\t\t}\n\t}\n\tans.emplace_back(0,0);\n\tfor(int i=0;i<(1<<n);++i){\n\t\tif(a[i])continue;\n\t\tbool ok=true;\n\t\tfor(int j=(i-1)&i;j;j=(j-1)&i){\n\t\t\tif(a[j]){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok)continue;\n\t\tstring myh;\n\t\tfor(int j=0;j<n;++j){\n\t\t\tif((i>>j)&1){\n\t\t\t\tif(myh.empty())myh=(char)('a'+j);\n\t\t\t\telse myh=(char)('a'+j)+myh+(char)('A'+j)+Rev(myh);\n\t\t\t}\n\t\t}\n\t\tint pos=0;\n\t\tfor(auto c:myh){\n\t\t\tint d=0,x=0;\n\t\t\tif(c>='a'&&c<='z'){\n\t\t\t\tx=c-'a',d=1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tx=c-'A',d=0;\n\t\t\t}\n\t\t\twhile(pos<x)ans.emplace_back(++pos,0);\n\t\t\twhile(pos>x)ans.emplace_back(--pos,0);\n\t\t\tif(d){\n\t\t\t\tans.emplace_back(x,1);\n\t\t\t\tans.emplace_back(x+1,1);\n\t\t\t\tans.emplace_back(x+1,0);\n\t\t\t\tans.emplace_back(x,0);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans.emplace_back(x+1,0);\n\t\t\t\tans.emplace_back(x+1,1);\n\t\t\t\tans.emplace_back(x,1);\n\t\t\t\tans.emplace_back(x,0);\n\t\t\t}\n\t\t}\n\t\twhile(pos>0)ans.emplace_back(--pos,0);\n\t}\n\tprintf(\"Possible\\n%d\\n\",(int)ans.size()-1);\n\tfor(auto x:ans){\n\t\tprintf(\"%d %d\\n\",x.first,x.second);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',') { cerr<<*sdbg++; } cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n\nVPII Go(int bit) {\n  VPII res;\n  //res.PB({0, 1});\n  RE (i, bit + 1) {\n    res.PB({i, 0});\n  }\n  res.PB({bit + 1, 1});\n  res.PB({bit, 1});\n  //res.PB({bit, 0});\n  FORD (i, bit, 1) {\n    res.PB({i, 0});\n  }\n  return res;\n}\nvoid Append(VPII& A, VPII B) {\n  A.insert(A.end(), ALL(B));\n}\nconst int N = 1000;\nint forb[N];\nint need[N];\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n\n  int n;\n  cin>>n;\n  REP (i, 1 << n) {\n    char c;\n    cin>>c;\n    if (c == '0') {\n      forb[i] = 1;\n      need[i] = 1;\n    }\n  }\n  REP (j, 1 << n) {\n    REP (i, j) {\n      if ((i & j) == i) {\n        if (forb[i] == 1 && forb[j] == 0) {\n          cout<<\"Impossible\\n\";\n          return 0;\n        }\n        if (forb[i] == 1) {\n          need[j] = 0;\n        }\n      }\n    }\n  }\n  //int any_need = 0;\n  PII orig{0, 0};\n  VPII pts;\n  REP (i, 1 << n) {\n    if (need[i] == 1) {\n      //any_need = 1;\n      VPII cur;\n      REP (bit, n) {\n        if (i & (1 << bit)) {\n          if (cur.empty()) {\n            cur = Go(bit);\n            continue;\n          } \n          VPII rev_cur = cur;\n          reverse(ALL(rev_cur));\n          VPII heh = Go(bit);\n          cur.PB(orig);\n          Append(cur, heh);\n          cur.PB(orig);\n          Append(cur, rev_cur);\n          cur.PB(orig);\n          reverse(ALL(heh));\n          Append(cur, heh);\n        }\n      }\n      pts.PB(orig);\n      Append(pts, cur);\n    }\n  }\n  pts.PB(orig);\n  cout<<\"Possible\\n\";\n  cout<<SZ(pts) - 1<<endl;\n  for (auto p : pts) {\n    cout<<p.st<<\" \"<<p.nd<<\"\\n\";\n  }\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define eb(x,y) emplace_back(x,y)\n#define fi first\n#define se second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\n//inline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\ninline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}\nint n;char s[1<<10];vector<pint>ans;\ninline string rev(string a){reverse(a.begin(),a.end());return a;}\ninline void Solve(int sta){\n\tint cnt=0;for(int i=0;i<n;i++)cnt+=sta>>i&1;\n\tif(cnt==1){\n\t\tint t=0;for(;t<n;t++)if(sta>>t&1)break;\n\t\tRep(i,1,t)ans.eb(i,0);ans.eb(t,1),ans.eb(t+1,1),ans.eb(t+1,0);\n\t\tRed(i,t,0)ans.eb(i,0);\n\t\treturn;\n\t}\n\tstring S;S.clear();int i=n-1;\n\tfor(;i>=0;i--)if(sta>>i&1)break;S.pb(i+'a'),S.pb(i+'A');\n\tfor(i--;i>=0;i--)if(sta>>i&1)S=(char)('a'+i)+S+(char)('a'+i)+(char)('A'+i)+rev(S)+(char)('A'+i);\n\tint now=0;\n\tfor(auto o:S){\n\t\tint opt,p,d;\n\t\tif(isupper(o))opt=1,p=o-'A';else opt=0,p=o-'a';\n\t\tif(now<=p){d=0;Rep(i,now+1,p)ans.eb(i,0);}\n\t\telse{d=1;Red(i,now-1,p+1)ans.eb(i,0);}\n\t\tif(d&&opt)ans.eb(p,0),now=p;\n\t\telse if(d&&!opt)ans.eb(p+1,1),ans.eb(p,1),ans.eb(p,0),now=p;\n\t\telse if(!d&&opt)ans.eb(p+1,0),now=p+1;\n\t\telse if(!d&&!opt)ans.eb(p,1),ans.eb(p+1,1),ans.eb(p+1,0),now=p+1;\n\t}Red(i,now-1,0)ans.eb(i,0);\n}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),scanf(\"%s\",s);\n\tif(s[0]=='0')return puts(\"Impossible\"),0;\n\tfor(int i=0;i<1<<n;i++){\n\t\tif(s[i]=='1'){\n\t\t\tfor(int j=0;j<n;j++)if(i>>j&1)\n\t\t\t\tif(s[i^(1<<j)]=='0')return puts(\"Impossible\"),0;\n\t\t}else{\n\t\t\tfor(int j=0;j<n;j++)if(!(i>>j&1))\n\t\t\t\tif(s[i^(1<<j)]=='1')return puts(\"Impossible\"),0;\n\t\t}\n\t}\n\tans.eb(0,0);\n\tfor(int i=0;i<1<<n;i++)if(s[i]=='0'){\n\t\tbool flg=1;\n\t\tfor(int j=0;j<n;j++)if((i>>j&1)&&s[i^(1<<j)]=='0')flg=0;\n\t\tif(flg)Solve(i);\n\t}puts(\"Possible\");cout<<ans.size()-1<<'\\n';\n\tfor(auto o:ans)cout<<o.fi<<' '<<o.se<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <decimal/decimal>\nusing namespace std;\nusing namespace __gnu_pbds;\n\n#define rep(i, s, t) for (int i = s; i < int(t); ++i)\n\n#define sc\tscanf\n#define pr\tprintf\n#define ff\tfirst\n#define ss\tsecond\n#define mp\tmake_pair\n#define pb\tpush_back\n#define eb\templace_back\n#define range(c)\tc.begin(), c.end()\n#define lowbit(x)\t((x) & -(x))\n#define pop_count\t__builtin_popcount\n#define pop_count_64\t__builtin_popcountll\n#define tail_count\t__builtin_ctz\n#define tail_count_64\t__builtin_ctzll\n#define lead_count\t__builtin_clz\n#define lead_count_64\t__builtin_clzll\n\n#define TEMP template<typename\n#define CONST(type) constexpr type const\n\nTEMP... Ts> struct is_con { static CONST(bool) value = false; };\nTEMP... Ts> struct is_con<vector<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<list<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<deque<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<set<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<unordered_set<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<map<Ts...>> { static CONST(bool) value = true; };\nTEMP... Ts> struct is_con<unordered_map<Ts...>> { static CONST(bool) value = true; };\n\nTEMP T1, typename T2> ostream& operator<<(ostream& os, pair<T1, T2> const& p) { return os << \"<\" << p.ff << \",\" << p.ss << \">\"; }\nTEMP T> typename enable_if<is_con<T>::value, ostream>::type& operator<<(ostream& os, T const& c) {\n\tos << \"{\";\n\tbool first = true;\n\tfor (auto const& x : c) {\n\t\tif (first) first = false;\n\t\telse os << \",\";\n\t\tos << \" \" << x;\n\t}\n\treturn os << \" }\";\n}\n\nTEMP T, typename... Ts> void dbg(T h, Ts... t) { cerr << \" \" << h; dbg<Ts...>(t...); }\ntemplate<> void dbg<int>(int x) { cerr << endl; }\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[ \"#__VA_ARGS__\" ] :\", dbg(__VA_ARGS__, 0)\n#else\n#define debug(...) 0\n#endif\n\nTEMP T, typename U> using ordered_map = tree<T, U, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\nTEMP T> using ordered_set = ordered_map<T, null_type>;\n\ntypedef long long i64;\ntypedef decimal::decimal128 i99;\ntypedef unsigned int u32;\ntypedef unsigned long long u64;\ntypedef float f32;\ntypedef double f64;\ntypedef long double f80;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<i64> vl;\n\nTEMP T> T& minn(T& lhs, T const& rhs) { return lhs = min(lhs, rhs); }\nTEMP T> T& maxx(T& lhs, T const& rhs) { return lhs = max(lhs, rhs); }\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint n;\n\tstring a;\n\tcin >> n >> a;\n\tvi dp(1 << n);\n\trep(s, 0, 1 << n) dp[s] = a[s] == '0';\n\tdebug(dp);\n\trep(i, 0, n) rep(s, 0, 1 << n) if (s >> i & 1) dp[s] |= dp[s ^ 1 << i];\n\tdebug(dp);\n\tbool ok = true;\n\trep(s, 0, 1 << n) ok &= dp[s] ^ (a[s] == '1');\n\tvi clique;\n\trep(s, 0, 1 << n) if (dp[s]) {\n\t\tbool check = true;;\n\t\trep(t, 0, 1 << n) if (t != s && (s & t) == t) check &= !dp[t];\n\t\tif (check) clique.pb(s);\n\t}\n\tint tot = 0, cnt = 0;\n\tfor (int s : clique) {\n\t\tint x = pop_count(s);\n\t\tok &= x <= 2;\n\t\ttot |= s;\n\t\tcnt += x;\n\t}\n\tok &= cnt == pop_count(tot);\n\tif (!ok) return cout << \"Impossible\" << endl, 0;\n\tcout << \"Possible\" << endl;\n\tdebug(clique);\n\tvector<pii> ans(1);\n\tfor (int s : clique) {\n\t\tif (s == lowbit(s)) {\n\t\t\tint x = tail_count(s);\n\t\t\trep(i, 1, x + 1) ans.eb(i, 0);\n\t\t\tans.eb(x + 1, 0);\n\t\t\tans.eb(x + 1, 1);\n\t\t\tans.eb(x, 1);\n\t\t\tfor (int i = x; i >= 0; --i) ans.eb(i, 0);\n\t\t} else {\n\t\t\tint x = tail_count(s);\n\t\t\ts ^= lowbit(s);\n\t\t\tint y = tail_count(s);\n\t\t\trep(i, 1, y + 1) ans.eb(i, 0);\n\t\t\tans.eb(y + 1, 0);\n\t\t\tans.eb(y + 1, 1);\n\t\t\tans.eb(y, 1);\n\t\t\tfor (int i = y; i >= x; --i) ans.eb(i, 0);\n\t\t\trep(i, x, y + 1) ans.eb(i, 1);\n\t\t\tfor (int i = y + 1; i > x; --i) ans.eb(i, 0);\n\t\t\tans.eb(x + 1, 1);\n\t\t\tans.eb(x, 1);\n\t\t\tfor (int i = x; i >= 0; --i) ans.eb(i, 0);\n\t\t}\n\t}\n\tcout << ans.size() - 1 << endl;\n\tfor (auto const& p : ans) cout << p.ff << \" \" << p.ss << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nnamespace std {\n\ntemplate<class Fun>\nclass y_combinator_result {\n\tFun fun_;\npublic:\n\ttemplate<class T>\n\texplicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n\n\ttemplate<class ...Args>\n\tdecltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n\ntemplate<class Fun>\ndecltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\n} // namespace std\n\nconst char* IMPOSSIBLE = \"Impossible\";\nconst char* POSSIBLE = \"Possible\";\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint N; cin >> N;\n\tvector<bool> A(1<<N);\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tchar c; cin >> c;\n\t\tassert(c == '0' || c == '1');\n\t\tA[(1<<N)-1-m] = (c == '1');\n\t}\n\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\t// m2 is a superset\n\t\t\tif (A[m] > A[m | (1<<i)]) {\n\t\t\t\tcout << IMPOSSIBLE << '\\n';\n\t\t\t\texit(0);\n\t\t\t}\n\t\t}\n\t}\n\tcout << POSSIBLE << '\\n';\n\tvector<int> pattern = std::y_combinator([&](auto self, int n, int l, int r) -> vector<int> {\n\t\tassert(A[r-1]);\n\t\tif (n == 0) {\n\t\t\treturn {};\n\t\t}\n\t\tvector<int> a = self(n-1, l + (1<<(n-1)), r);\n\t\tvector<int> res = a;\n\t\tres.push_back(n);\n\t\tif (A[l+(1<<(n-1))-1]) {\n\t\t\tvector<int> b = self(n-1, l, l + (1<<(n-1)));\n\t\t\tfor (int i : b) res.push_back(i);\n\t\t\tres.push_back(-n);\n\t\t\treverse(b.begin(), b.end());\n\t\t\tfor (int i : b) res.push_back(-i);\n\t\t}\n\t\treturn res;\n\t})(N, 0, (1<<N));\n\n\tvector<bool> patA(1<<N);\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tstack<int> st;\n\t\tfor (int i : pattern) {\n\t\t\tif (m & (1<<(abs(i)-1))) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!st.empty() && st.top() == -i) {\n\t\t\t\tst.pop();\n\t\t\t} else {\n\t\t\t\tst.push(i);\n\t\t\t}\n\t\t}\n\t\tpatA[m] = st.empty();\n\t}\n\n\tfor (int m = 0; m < (1<<N); m++) {\n\t\tassert(patA[m] == A[m]);\n\t}\n\n\tvector<pair<int, int>> pos;\n\tpos.emplace_back(0,1);\n\tauto goToPt = [&](int x) {\n\t\tassert(pos.back().second == 1);\n\t\tif (pos.back() == pair<int, int>(x,1)) {\n\t\t\treturn;\n\t\t}\n\t\tpos.emplace_back(pos.back().first, 0);\n\t\twhile (pos.back().first < x) {\n\t\t\tpos.emplace_back(pos.back().first+1, 0);\n\t\t}\n\t\twhile (pos.back().first > x) {\n\t\t\tpos.emplace_back(pos.back().first-1, 0);\n\t\t}\n\t\tpos.emplace_back(x,1);\n\t};\n\tfor (auto i : pattern) {\n\t\tassert(i != 0);\n\t\tif (i > 0) {\n\t\t\tgoToPt(i-1);\n\t\t\tpos.emplace_back(i, 1);\n\t\t} else {\n\t\t\tgoToPt(-i);\n\t\t\tpos.emplace_back(-i-1, 1);\n\t\t}\n\t}\n\n\tgoToPt(0);\n\n\tif (int(pos.size()) - 1 > 250000) {\n\t\twhile (true);\n\t}\n\tcout << pos.size()-1 << '\\n';\n\tfor (auto it : pos) {\n\t\tcout << it.first << ' ' << it.second << '\\n';\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define long long long int\nusing namespace std;\n\n// @author: pashka\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    int n;\n    string s;\n    cin >> n >> s;\n    if (s[0] == '0') {\n        cout << \"Impossible\\n\";\n        return 0;\n    }\n    vector<bool> z(1 << n);\n    vector<pair<int, int>> p;\n    p.push_back({0, 0});\n    for (int j = 1; j < (1 << n); j++) {\n        if (z[j]) {\n            if (s[j] == '1') {\n                cout << \"Impossible\\n\";\n                return 0;\n            }\n            continue;\n        }\n        if (s[j] == '0') {\n            vector<pair<int, int>> pp;\n            for (int i = 0; i < n; i++) {\n                if (j & (1 << i)) {\n                    if (pp.size() == 0) {\n                        for (int x = 0; x <= i; x++) {\n                            pp.push_back({x, 0});\n                        }\n                        pp.push_back({i, 1});\n                        pp.push_back({i + 1, 1});\n                        for (int x = i + 1; x >= 0; x--) {\n                            pp.push_back({x, 0});\n                        }\n                    } else {\n                        vector<pair<int, int>> ppp = pp;\n                        for (int x = 1; x <= i; x++) {\n                            ppp.push_back({x, 0});\n                        }\n                        ppp.push_back({i, 1});\n                        ppp.push_back({i + 1, 1});\n                        for (int x = i + 1; x >= 1; x--) {\n                            ppp.push_back({x, 0});\n                        }\n                        reverse(pp.begin(), pp.end());\n                        ppp.insert(ppp.end(), pp.begin(), pp.end());\n                        for (int x = 1; x <= i + 1; x++) {\n                            ppp.push_back({x, 0});\n                        }\n                        ppp.push_back({i + 1, 1});\n                        ppp.push_back({i, 1});\n                        for (int x = i; x >= 0; x--) {\n                            ppp.push_back({x, 0});\n                        }\n                        pp = ppp;\n                    }\n                }\n            }\n            p.insert(p.end(), pp.begin() + 1, pp.end());\n            for (int i = 0; i < n; i++) {\n                z[j | (1 << i)] = true;\n            }\n        }\n    }\n    bool ok = false;\n    while (!ok) {\n        vector<pair<int, int>> pp;\n        ok = true;\n        for (int i = 0; i < p.size(); i++) {\n            if (i > 0 && i < (int)p.size() - 1 && p[i - 1] == p[i + 1]) {\n                ok = false;\n                i++;\n            } else {\n                pp.push_back(p[i]);\n            }\n        }\n        p = pp;\n    }\n    cout << \"Possible\\n\";\n    cout << p.size() - 1 << \"\\n\";\n    for (auto x : p) {\n        cout << x.first << \" \" << x.second << \"\\n\";\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define eb(x,y) emplace_back(x,y)\n#define fi first\n#define se second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\n//inline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\ninline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}\nint n;char s[1<<10];vector<pint>ans;\ninline string rev(string a){reverse(a.begin(),a.end());}\ninline void Solve(int sta){\n\tint cnt=0;for(int i=0;i<n;i++)cnt+=sta>>i&1;\n\tif(cnt==1){\n\t\tint t=0;for(;t<n;t++)if(sta>>t&1)break;\n\t\tRep(i,1,t)ans.eb(i,0);ans.eb(t,1),ans.eb(t+1,1),ans.eb(t+1,0);\n\t\tRed(i,t,0)ans.eb(i,0);\n\t\treturn;\n\t}\n\tstring S;S.clear();int i=0;\n\tfor(;i<n;i++)if(sta>>i&1)break;S.pb(i+'a'),S.pb(i+'A');\n\tfor(i++;i<n;i++)if(sta>>i&1)S=(char)('a'+i)+S+(char)('a'+i)+(char)('A'+i)+rev(S)+(char)('A'+i);\n\tint now=0;\n\tfor(auto o:S){\n\t\tint opt,p,d;\n\t\tif(isupper(o))opt=1,p=o-'A';else opt=0,p=o-'a';\n\t\tif(now<=p){d=0;Rep(i,now+1,p)ans.eb(i,0);}\n\t\telse{d=1;Red(i,now-1,p+1)ans.eb(i,0);}\n\t\tif(d&&opt)ans.eb(p,0),now=p;\n\t\telse if(d&&!opt)ans.eb(p+1,1),ans.eb(p,1),ans.eb(p,0),now=p;\n\t\telse if(!d&&opt)ans.eb(p+1,0),now=p+1;\n\t\telse if(!d&&!opt)ans.eb(p,1),ans.eb(p+1,1),ans.eb(p+1,0),now=p+1;\n\t}Red(i,now-1,0)ans.eb(i,0);\n}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),scanf(\"%s\",s);puts(\"Impossible\");\n//\tif(s[0]=='0')return puts(\"Impossible\"),0;\n//\tfor(int i=0;i<1<<n;i++){\n//\t\tif(s[i]=='1'){\n//\t\t\tfor(int j=0;j<n;j++)if(i>>j&1)\n//\t\t\t\tif(s[i^(1<<j)]=='0')return puts(\"Impossible\"),0;\n//\t\t}else{\n//\t\t\tfor(int j=0;j<n;j++)if(!(i>>j&1))\n//\t\t\t\tif(s[i^(1<<j)]=='1')return puts(\"Impossible\"),0;\n//\t\t}\n//\t}\n\t/*ans.eb(0,0);\n\tfor(int i=0;i<1<<n;i++)if(s[i]=='0'){\n\t\tbool flg=1;\n\t\tfor(int j=0;j<n;j++)if((i>>j&1)&&s[i^(1<<j)]=='0')flg=0;\n\t\tif(flg)Solve(i);\n\t}puts(\"Possible\");cout<<ans.size()-1<<'\\n';\n\tfor(auto o:ans)cout<<o.fi<<' '<<o.se<<'\\n';*/\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define INF ((1<<30)-1)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nvoid ok(){\n    cout << \"Yes\" << endl;\n    exit(0);\n}\n\nvoid ng(){\n    cout <<  \"Impossible\" << endl;\n    exit(0);\n}\n\n\nint n;\nint a[1 << 8];\n\nvector<int> loops;\n\nvoid entangle(int x){\n    vector<int> loop;\n    for(int i = n-1;i >= 0;i--){\n        if((x >> i) % 2 == 0)continue;\n        if(loop.empty()){\n            loop.push_back(i+1);\n            loop.push_back(-i-1);\n        }\n        else{\n            vector<int> tmp;\n            tmp.push_back(i+1);\n            for(auto it = loop.begin();it != loop.end();it++)tmp.push_back(*it);\n            tmp.push_back(i+1);\n            tmp.push_back(-i-1);\n            for(auto it = loop.rbegin();it != loop.rend();it++)tmp.push_back(*it);\n            tmp.push_back(-i-1);\n            loop = tmp;\n        }\n    }\n    for(auto elem:loop)loops.push_back(elem);\n    loops.push_back(INF);\n}\n\nvoid show(){\n    vector<P> ps;\n    ps.push_back(P(0,0));\n    int nowx = 0, nowy = 0;\n    for(int x:loops){\n        if(x == INF){\n            while(nowx > 0){\n                ps.push_back(P(--nowx, nowy));\n            }\n            continue;\n        }\n        if(x > 0){\n            while(nowx > x){\n                ps.push_back(P(--nowx, nowy));\n            }\n            while(nowx < x-1){\n                ps.push_back(P(++nowx, nowy));\n            }\n            ps.push_back(P(nowx,++nowy));\n            if(nowx == x)ps.push_back(P(--nowx, nowy));\n            else ps.push_back(P(++nowx, nowy));\n            ps.push_back(P(nowx,--nowy));\n        }\n        if(x < 0){\n            x = x * -1;\n            while(nowx > x){\n                ps.push_back(P(--nowx, nowy));\n            }\n            while(nowx < x-1){\n                ps.push_back(P(++nowx, nowy));\n            }\n            if(nowx == x)ps.push_back(P(--nowx, nowy));\n            else ps.push_back(P(++nowx, nowy));\n        }\n    }\n    cout << ps.size() - 1 << endl;\n    for(auto p:ps){\n        cout << p.first << \" \" << p.second << endl;\n    }\n}\n\nint main(){\n    cin >> n;\n    for(int i = 0;i < (1<<n);i++){\n        scanf(\"%1d\", a+i);\n        bool bad;\n        if(a[i] == 0)bad = true;\n        for(int j = 0;j < i;j++){\n            if((j & i) != j)continue;\n            if(a[i] == 1 && a[j] == 0){\n                ng();                    \n            }\n            if(a[j] == 0)bad = false;\n        }\n        if(bad){\n            entangle(i);\n        }\n    }\n    show();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\nvector<pair<int, int> > ans;\n\nvoid cw(int loc)\n{\n    for (int i = 1; i <= loc - 1; i++) {\n        ans.push_back(make_pair(i, 0));\n    }\n    ans.push_back(make_pair(loc-1, 1));\n    ans.push_back(make_pair(loc, 1));\n    for (int i = loc; i >= 0; i--) {\n        ans.push_back(make_pair(i, 0));\n    }\n}\n\nvoid ccw(int loc)\n{\n    for (int i = 1; i <= loc; i++) {\n        ans.push_back(make_pair(i, 0));\n    }\n    ans.push_back(make_pair(loc, 1));\n    ans.push_back(make_pair(loc-1, 1));\n    for (int i = loc - 1; i >= 0; i--) {\n        ans.push_back(make_pair(i, 0));\n    }\n}\n\nvoid work(vector<int>& elems, vector<int>& ops)\n{\n    if (elems.size() == 1) {\n        ops.push_back(elems[0]); return;\n    }\n    vector<int> left;\n    vector<int> right;\n    for (int i = 0; i < elems.size() / 2; i++) {\n        left.push_back(elems[i]);\n    }\n    for (int i = elems.size() / 2; i < elems.size(); i++) {\n        right.push_back(elems[i]);\n    }\n    vector<int> leftans;\n    vector<int> rightans;\n    work(left, leftans);\n    work(right, rightans);\n    for (int i = 0; i < leftans.size(); i++) {\n        ops.push_back(leftans[i]);\n    }\n    for (int i = 0; i < rightans.size(); i++) {\n        ops.push_back(rightans[i]);\n    }\n    reverse(leftans.begin(), leftans.end());\n    reverse(rightans.begin(), rightans.end());\n    for (int i = 0; i < leftans.size(); i++) {\n        ops.push_back(-leftans[i]);\n    }\n    for (int i = 0; i < rightans.size(); i++) {\n        ops.push_back(-rightans[i]);\n    }\n}\n\nchar s[500]; int n;\n\nint main()\n{\n    ans.push_back(make_pair(0, 0));\n    scanf(\"%d\", &n);\n    scanf(\"%s\", s);\n    for (int i = 0; i < (1 << n); i++) {\n        for (int j = 0; j < (1 << n); j++) {\n            if ((i & j) == i && s[i] == '0' && s[j] == '1') {\n                printf(\"Impossible\"); return 0;\n            }\n        }\n    }\n    for (int i = 0; i < (1 << n); i++) {\n        if (s[i] == '1') continue;\n        bool good = true;\n        for (int j = 0; j < n; j++) {\n            if ((i & (1 << j)) && s[i ^ (1 << j)] == '0') good = false;\n        }\n        if (!good) continue;\n        vector<int> elems;\n        for (int j = 0; j < n; j++) {\n            if (i & (1 << j)) elems.push_back(j + 1);\n        }\n        vector<int> ops;\n        work(elems, ops);\n        for (int j = 0; j < ops.size(); j++) {\n            if (ops[j] > 0) {\n                cw(ops[j]);\n            } else {\n                ccw(-ops[j]);\n            }\n        }\n    }\n    printf(\"Possible\\n%d\\n\", (int)(ans.size()) - 1);\n    for (int i = 0; i < ans.size(); i++) {\n        printf(\"%d %d\\n\", ans[i].first, ans[i].second);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 15;\nconst int MAXS = 1 << 8;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nvector <pair <int, int>> ans, tmp;\nint n, bit[MAXN]; bool flg[MAXS]; char s[MAXN];\nvoid augment(vector <pair <int, int>> &res, int x) {\n\tif (res.size() == 0) {\n\t\tres.emplace_back(x, 0);\n\t\tres.emplace_back(x, 1);\n\t\treturn;\n\t}\n\tvector <pair <int, int>> tmp;\n\ttmp.emplace_back(x, 0);\n\tfor (auto x : res) tmp.push_back(x);\n\ttmp.emplace_back(x, 0);\n\treverse(tmp.begin(), tmp.end());\n\ttmp.emplace_back(x, 1);\n\tfor (auto x : res) tmp.push_back(x);\n\ttmp.emplace_back(x, 1);\n\tres = tmp;\n}\nvoid work(int mask) {\n\ttmp.clear(); int cur = 0;\n\tfor (int i = n; i >= 1; i--)\n\t\tif (mask & bit[i]) augment(tmp, i);\n\tfor (auto x : tmp) {\n\t\tif (x.second == 0) {\n\t\t\tif (cur >= x.first) while (cur >= x.first) ans.emplace_back(--cur, 0);\n\t\t\telse while (cur < x.first) ans.emplace_back(++cur, 0);\n\t\t} else {\n\t\t\tif (cur >= x.first) {\n\t\t\t\tans.emplace_back(cur, 1);\n\t\t\t\twhile (cur >= x.first) ans.emplace_back(--cur, 1);\n\t\t\t\tans.emplace_back(cur, 0);\n\t\t\t} else {\n\t\t\t\tans.emplace_back(cur, 1);\n\t\t\t\twhile (cur < x.first) ans.emplace_back(++cur, 1);\n\t\t\t\tans.emplace_back(cur, 0);\n\t\t\t}\n\t\t}\n\t}\n\twhile (cur > 0) ans.emplace_back(--cur, 0);\n}\nint main() {\n\tread(n), scanf(\"\\n%s\", s);\n\tfor (int i = 1; i <= n; i++)\n\t\tbit[i] = 1 << (i - 1);\n\tint goal = 1 << n;\n\tfor (int i = 0; i < goal; i++)\n\tfor (int j = 0; j < i; j++)\n\t\tif ((i & j) == j && s[j] == '0') flg[i] = true;\n\tfor (int i = 0; i < goal; i++)\n\t\tif (s[i] == '1' && flg[i]) {\n\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\tputs(\"Possible\");\n\tfor (int i = 0; i < goal; i++)\n\t\tif (s[i] == '0' && !flg[i]) work(i);\n\tcout << ans.size() << endl;\n\tprintf(\"%d %d\\n\", 0, 0);\n\tfor (auto x : ans)\n\t\tprintf(\"%d %d\\n\", x.first, x.second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,r,i,j,k,m,b[250250],x[250250],y[250250];\nchar s[250250];\nint main() {\n  scanf(\"%d\",&n);\n  scanf(\"%s\",s);\n  for (i=0; i<n; i++) {\n    bool all=true;\n    for (j=0; j<(1<<n); j++) if ((j>>i)&1) all&=(s[j]=='0');\n    if (all) b[m++]=i;\n  }\n  for (j=0; j<(1<<n); j++) if (s[j]=='0') {\n    for (i=0; i<m; i++) if ((j>>b[i])&1) break;\n    if (i>=m) { puts(\"Impossible\"); return 0; }\n  } else {\n    for (i=0; i<m; i++) if ((j>>b[i])&1) break;\n    if (i<m) { puts(\"Impossible\"); return 0; }\n  }\n  for (i=1; i<m; i++) if (b[i]!=b[i-1]+1) { puts(\"Impossible\"); return 0; }\n  puts(\"Possible\");\n  if (m==0) {\n    puts(\"0\");\n    puts(\"1 1\");\n    return 0;\n  }\n  for (i=0; i<m; i=j+1) {\n    if (i) for (k=b[i-1]+1; k<b[i]; k++) { x[r]=k; y[r++]=0; }\n    for (j=i; j+1<m && b[j+1]==b[j]+1; j++);\n    x[r]=b[i]; y[r++]=0;\n    for (k=b[i]; k<=b[j]+1; k++) { x[r]=k; y[r++]=1; }\n  }\n  for (k=b[m-1]+1; k>=b[0]; k--) { x[r]=k; y[r++]=0; }\n  printf(\"%d\\n\",r-1);\n  for (i=0; i<r; i++) printf(\"%d %d\\n\",x[i],y[i]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\n\ntemplate <class T1, class T2>\nostream& operator << (ostream& out, const pair <T1, T2> p)\n{\n    out << '(' << p.first << ',' << p.second << ')';\n    return out;\n}\n\ntemplate <class T1, class T2>\nistream& operator >> (istream& in, pair<T1, T2> &p)\n{\n    in >> p.first >> p.second;\n    return in;\n}\n\ntemplate <class T>\nistream& operator >> (istream& in, vector<T> &v)\n{\n    for (T &x : v)\n        in >> x;\n    return in;\n}\n\ntemplate <class T>\nostream& operator << (ostream& out, const vector<vector<T>> &v)\n{\n    for (const vector<T> &x : v)\n        out << x << '\\n';\n    return out;\n}\n\ntemplate <class T>\nostream& operator << (ostream& out, const vector<T> &v)\n{\n    for (const T &x : v)\n        out << x << ' ';\n    return out;\n}\n\nlong long gcd (long long a, long long b)\n{\n    if (b > a)\n        swap(a, b);\n    return (b ? gcd(b, a % b) : a);\n}\n\nusing ll   = long long;\nusing pii  = pair<int, int>;\nusing pll  = pair<long long, long long>;\nusing tiii = pair<pair<int, int>, int>;\nusing vi   = vector<int>;\nusing vl   = vector<long long>;\nusing vvi  = vector<vector<int>>;\nusing vvl  = vector<vector<long long>>;\n\n#define F          first\n#define S          second\n#define First      first.first\n#define Second     first.second\n#define Third      second\n#define mp         make_pair\n#define rep(i,a,b) for (int i = (a); i < (b); i++)\n#define per(i,b,a) for (int i = (b); i > (a); i--)\n#define all(x)     x.begin(), x.end()\n#define ret(x)     return cout << x, 0;\n#define throwex    throw runtime_error (\"Found the error.\");\n\nconst int h = 1000000007;\n\nint n;\nvector<pii> get_cycle(int mask, int cur = 0)\n{\n    int last_1_index = n - 1;\n    int z = (mask & -mask);\n    while(z != 1)\n        last_1_index--, z /= 2;\n    vector<pii> ans;\n    if(cur == last_1_index)\n    {\n        ans.push_back({cur, 1});\n        ans.push_back({cur+1, 1});\n        ans.push_back({cur+1, 0});\n        ans.push_back({cur, 0});\n        ans.push_back({cur, 1});\n        return ans;\n    }\n    ans.push_back({cur, 1});\n    vector<pii> next_cycle = get_cycle(mask, cur + 1);\n    ans.insert(ans.end(), all(next_cycle));\n    ans.push_back({cur, 1});\n    if((mask & (1 << (n - 1 - cur))))\n    {\n        ans.push_back({cur, 0});\n        ans.push_back({cur+1, 0});\n        reverse(all(next_cycle));\n        ans.insert(ans.end(), all(next_cycle));\n        ans.push_back({cur, 1});\n    }\n    return ans;\n}\n\nsigned main()\n{\n    ios::sync_with_stdio(false);\n    #ifdef ONLINE_JUDGE\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    cerr.setstate(ios::failbit);\n    #endif\n\n    cin >> n;\n    string a;\n    cin >> a;\n    rep(i,0,1 << n)\n    {\n        rep(j,0,i)\n        {\n            if((j | i) == i and a[i] == '1' and a[j] == '0')\n                ret(\"Impossible\");\n        }\n    }\n    vector<pii> ans;\n    ans.push_back({0, 1});\n    rep(i,0,1 << n)\n    {\n        if(a[i] == '0')\n        {\n            vector<pii> cycle = get_cycle(i);\n            ans.insert(ans.end(), cycle.begin() + 1, cycle.end());\n            for(int j = i; j < (1 << n); j++)\n                if((i | j) == j)\n                    a[j] = '1';\n            cerr << cycle << '\\n';\n        }\n    }\n    cout << \"Possible\\n\";\n    cout << ans.size() - 1 << '\\n';\n    for(pii x : ans)\n        cout << x.F << ' ' << x.S << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#pragma GCC optimize(\"Ofast\")\n#include<vector>\n#include<queue>\n#include<iostream>\n#include<fstream>\n#include<string>\n#include<cassert>\n#include<algorithm>\n#include<random>\n#include<map>\n#include<set>\n#include <bitset>\n#include<ctime>\n\nusing namespace std;\n\n//int mod = 998244353;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\ntypedef vector<int>vi;\ntypedef vector<ll>vl;\ntypedef vector<char>vc;\ntypedef vector<string>vs;\ntypedef vector<vector<int>>vii;\ntypedef vector<vector<char>>vvc;\ntypedef vector<vector<ll>>vll;\ntypedef vector< pair<ll, ll>>vpll;\ntypedef vector< pair<ld, ld>>vpld;\ntypedef vector< pair<int, int>>vpi;\ntypedef pair<ld, ld>pld;\n#define mp make_pair\n#define pb push_back\n\nconst int mod = 998244353;\nint add(int a, int b)\n{\n\tint c = a + b;\n\tif (c >= mod)\n\t{\n\t\tc -= mod;\n\t}\n\treturn c;\n}\nint dif(int a, int b)\n{\n\tint c = a - b;\n\tif (c < 0)\n\t{\n\t\tc += mod;\n\t}\n\treturn c;\n}\nint mlt(int a, int b)\n{\n\tll c = a * 1LL * b;\n\treturn c % mod;\n}\nint ibit(int n, int i)\n{\n\treturn ((n >> i) & 1);\n}\nvoid outp(vii &ou)\n{\n\tfor (int i = 0; i < ou.size(); i++)\n\t{\n\t\tfor (int j = 0; j < ou[i].size(); j++)\n\t\t{\n\t\t\tcout << ou[i][j] << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n}\nint bp(int x, int y)\n{\n\tif (y == 0)\n\t{\n\t\treturn 1;\n\t}\n\tint a = 0;\n\tif (!(y % 2))\n\t{\n\t\ta = bp(x, y / 2);\n\t}\n\treturn (y % 2) ? mlt(bp(x, y - 1), x) : mlt(a, a);\n}\nint obr(int x)\n{\n\treturn bp(x, mod - 2);\n}\nconst int maxn = 2000007;\nint fact[2000007], ofact[2000007];\nvoid prec()\n{\n\tfact[0] = 1;\n\tofact[0] = 1;\n\tfor (int i = 1; i < maxn; i++)\n\t{\n\t\tfact[i] = mlt(fact[i - 1], i);\n\t}\n\t//cerr << \"sdsds\" << endl;\n\tofact[maxn - 1] = obr(fact[maxn - 1]);\n\tfor (int i = maxn - 2; i > 0; i--)\n\t{\n\t\tofact[i] = mlt(ofact[i + 1], i + 1);\n\t}\n}\nint c(int a, int b)\n{\n\tif (a == 0)return 1;\n\treturn ((a <= b) && (a >= 0)) ? mlt(fact[b], mlt(ofact[a], ofact[b - a])) : 0;\n}\nll gcd(ll x, ll y)\n{\n\t//cerr << x << y << endl;\n\tif (x == 0)return y;\n\treturn(x > y) ? gcd(y, x) : gcd(y%x, x);\n}\nint obr2(int n)\n{\n\tint x = fact[n - 1];\n\tx = mlt(x, ofact[n]);\n\treturn x;\n}\nvoid crv(int nn, vpi &v)\n{\n\tcerr << nn << endl;\n\tif (nn > 0) {\n\t\tint n = nn;\n\t\tfor (int i = 0; i < n; i++)v.pb({ i + 1, 0 });\n\t\tv.pb({ n,1 });\n\t\tv.pb({ n - 1, 1 });\n\t\tfor (int i = n - 1; i >= 0; i--)v.pb({ i, 0 });\n\t}\n\tif (nn < 0) {\n\t\tint n = -nn;\n\t\tfor (int i = 0; i < n - 1; i++)v.pb({ i + 1, 0 });\n\t\tv.pb({ n - 1,1 });\n\t\tv.pb({ n , 1 });\n\t\tfor (int i = n; i >= 0; i--)v.pb({ i, 0 });\n\t}\n}\nvoid solve(istream &cin = std::cin, ostream &cout = std::cout)\n{\n\tvii imb(9);\n\timb[0] = { 1 };\n\tfor (int i = 1; i <= 8; i++)\n\t{\n\t\tfor (int j = 0; j < imb[i - 1].size(); j++)imb[i].pb(imb[i - 1][j]);\n\t\timb[i].pb(i + 1);\n\t\tfor (int j = imb[i - 1].size(); j >= 0; j--)imb[i].pb((-1)*imb[i - 1][j]);\n\t\timb[i].pb(-i - 1);\n\t}\n\t//cerr << \"here\" << endl;\n\tint n;\n\tcin >> n;\n\tvi good(1 << n);\n\tfor (int i = 0; i < good.size(); i++)\n\t{\n\t\tchar c;\n\t\tcin >> c;\n\t\tgood[i] = c - '0';\n\t}\n\tint val = 0;\n\t//\tcerr << 433 << endl;\n\tfor (int a = 0; a < good.size(); a++)\n\t\tfor (int b = 0; b < good.size(); b++)\n\t\t\tif ((a | b) == b)\n\t\t\t\tif ((!good[a]) && (good[b]))\n\t\t\t\t{\n\t\t\t\t\t//\tcerr << a << ' ' << b << endl;\n\t\t\t\t\tval = 1;\n\t\t\t\t}\n\t//\tcerr << 5 << ' ' << 7 << ' ' << (5 | 7) << endl;\n\tif (val)cout << \"Impossible\" << endl;\n\telse\n\t{\n\t\tcout << \"Possible\" << endl;\n\t\t//cerr << 1111 << endl;\n\t\tvpi ay = { { 0,0 } };\n\t\tfor (int m = 0; m < good.size(); m++)\n\t\t{\n\t\t\t//cerr << m << endl;\n\t\t\tif (!good[m])\n\t\t\t{\n\t\t\t\tcerr << m << endl;\n\t\t\t\tvi v;\n\t\t\t\tfor (int i = 0; i <= 8; i++)if (ibit(m, i))v.pb(i);\n\t\t\t\tcerr << m << ' ' << v.size() << endl;\n\t\t\t\tfor (int i = 0; i < imb[v.size() - 1].size(); i++)\n\t\t\t\t{\n\t\t\t\t\tcerr << imb[v.size() - 1][i] << endl;\n\t\t\t\t\t//\tcerr << i << endl;\n\t\t\t\t\tif (imb[v.size()][i] > 0)crv(v[imb[v.size() - 1][i] - 1] + 1, ay);\n\t\t\t\t\tif (imb[v.size()][i] < 0)crv(-v[(-imb[v.size() - 1][i]) - 1] - 1, ay);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ay.size() - 1 << endl;\n\t\tfor (int i = 0; i < ay.size(); i++)cout << ay[i].first << ' ' << ay[i].second << endl;\n\t}\n}\nint main()\n{\n\tsolve();\n\tint n;\n\tcin >> n;\n}"
  },
  {
    "language": "C++",
    "code": "/* cerberus97 - Hanit Banga */\n\n#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\n#define pb push_back\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 1e5 + 10;\n\nint main() {\n\tfast_cin();\n\tint n; string s;\n\tcin >> n >> s;\n\tint tot = (1 << n), biggest = -1;\n\tfor (int mask = 0; mask < tot; ++mask) {\n\t\tif (s[mask] == '0') {\n\t\t\tcontinue;\n\t\t}\n\t\tbiggest = mask;\n\t\tfor (int sub = 0; sub < mask; ++sub) {\n\t\t\tif ((mask & sub) == sub and s[sub] == '0') {\n\t\t\t\tcout << \"Impossible\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (biggest == -1) {\n\t\tcout << \"Impossible\\n\";\n\t\treturn 0;\n\t}\n\tvector<pii> pts = {{0, 0}};\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!((biggest >> i) & 1)) {\n\t\t\tpts.pb({i, 1});\n\t\t\tpts.pb({i + 1, 1});\n\t\t\tpts.pb({i + 1, 0});\n\t\t\tpts.pb({i, 0});\n\t\t}\n\t\tpts.pb({i + 1, 0});\n\t}\n\tfor (int i = n - 1; i >= 0; --i) {\n\t\tpts.pb({i, 0});\n\t}\n\tcout << \"Possible\\n\" << pts.size() << '\\n';\n\tfor (auto& p : pts) {\n\t\tcout << p.first << ' ' << p.second << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define fr first\n#define sc second\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n\nvector<P> ret;\n\nvoid pos(int i){\n\tfor(int j=0;j<i;j++){\n\t\tret.push_back(P(j+1,0));\n\t}\n\tret.push_back(P(i,1));\n\tret.push_back(P(i+1,1));\n\tret.push_back(P(i+1,0));\n\tret.push_back(P(i,0));\n\tfor(int j=i-1;j>=0;j--){\n\t\tret.push_back(P(j,0));\n\t}\n}\nvoid neg(int i){\n\tfor(int j=0;j<i;j++){\n\t\tret.push_back(P(j+1,0));\n\t}\n\tret.push_back(P(i+1,0));\n\tret.push_back(P(i+1,1));\n\tret.push_back(P(i,1));\n\tret.push_back(P(i,0));\n\tfor(int j=i-1;j>=0;j--){\n\t\tret.push_back(P(j,0));\n\t}\n}\n\t\n\nint main(){\n\tint n;\n\tstring s;\n\tcin>>n>>s;\n\t\n\tint a[300];\n\tfor(int i=0;i<(1<<n);i++)a[i]=s[i]-'0';\n\t\n\tbool used[300];\n\tmemset(used,0,sizeof used);\n\t\n\tint b[300];\n\tfor(int i=0;i<300;i++)b[i]=1;\n\t\n\tfor(int x=1;x<(1<<n);x++){\n\t\tused[x]=true;\n\t\t//if(used[x])cerr<<x<<endl;\n\t\tfor(int y=0;y<x;y++){\n\t\t\tif((x&y)==y)if(used[y])used[x]=false;\n\t\t}\n\t\t//if(used[x])cerr<<x<<endl;\n\t\tfor(int y=0;y<(1<<n);y++){\n\t\t\tif((x&y)==x)if(a[y]==1)used[x]=false;\n\t\t}\n\t\t//if(used[x])cerr<<x<<endl;\n\t\tif(used[x]){\n\t\t\tfor(int y=0;y<(1<<n);y++){\n\t\t\t\tif((x&y)==x)b[y]=0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool ok=true;\n\tfor(int i=0;i<(1<<n);i++)ok&=a[i]==b[i];\n\tif(!ok){\n\t\tputs(\"Impossible\");\n\t\treturn 0;\n\t}\n\tret.push_back(P(0,0));\n\tfor(int x=0;x<(1<<n);x++){\n\t\tif(!used[x])continue;\n\t\tint cnt=0;\n\t\tint c[10];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif((x>>i)&1)c[cnt++]=i;\n\t\t}\n\t\tif(cnt==1){\n\t\t\tpos(c[0]);\n\t\t}\n\t\telse if(cnt==2){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[1]);\n\t\t}\n\t\telse if(cnt==3){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[2]);\n\t\t}\n\t\telse if(cnt==4){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tneg(c[3]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[3]);\n\t\t\tpos(c[2]);\n\t\t\tneg(c[3]);\n\t\t\tneg(c[2]);\n\t\t}\n\t\telse if(cnt==5){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[1]);\n\t\t\tpos(c[4]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[4]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tneg(c[3]);\n\t\t\tpos(c[0]);\n\t\t\tpos(c[4]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[4]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tpos(c[2]);\n\t\t}\n\t\telse if(cnt==6){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[1]);\n\t\t\tpos(c[4]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[4]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tneg(c[3]);\n\t\t\tpos(c[0]);\n\t\t\tpos(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[4]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[4]);\n\t\t\tneg(c[1]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tpos(c[2]);\n\t\t}\n\t\telse if(cnt==7){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[6]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[6]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[6]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[1]);\n\t\t\tpos(c[4]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[4]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[0]);\n\t\t\tpos(c[6]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[6]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tneg(c[3]);\n\t\t\tpos(c[0]);\n\t\t\tpos(c[6]);\n\t\t\tpos(c[6]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[6]);\n\t\t\tpos(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[4]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[4]);\n\t\t\tneg(c[1]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[0]);\n\t\t\tpos(c[6]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[6]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tpos(c[2]);\n\t\t}\n\t\telse if(cnt==8){\n\t\t\tpos(c[0]);\n\t\t\tpos(c[6]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[6]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[6]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[1]);\n\t\t\tpos(c[7]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[7]);\n\t\t\t\n\t\t\tpos(c[4]);\n\t\t\tpos(c[7]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[7]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[4]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[0]);\n\t\t\tpos(c[6]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[6]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[0]);\n\t\t\tpos(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tneg(c[3]);\n\t\t\tpos(c[0]);\n\t\t\tpos(c[6]);\n\t\t\tpos(c[6]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[6]);\n\t\t\tpos(c[5]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[4]);\n\t\t\tpos(c[1]);\n\t\t\tpos(c[7]);\n\t\t\tneg(c[1]);\n\t\t\tneg(c[7]);\n\t\t\t\n\t\t\tneg(c[4]);\n\t\t\tpos(c[7]);\n\t\t\tpos(c[1]);\n\t\t\tneg(c[7]);\n\t\t\tneg(c[1]);\n\t\t\tpos(c[5]);\n\t\t\tpos(c[0]);\n\t\t\tpos(c[6]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[5]);\n\t\t\tpos(c[6]);\n\t\t\tpos(c[0]);\n\t\t\tneg(c[6]);\n\t\t\tneg(c[0]);\n\t\t\tneg(c[3]);\n\t\t\tneg(c[2]);\n\t\t\tpos(c[3]);\n\t\t\tpos(c[2]);\n\t\t}\n\t}\n\t\n\t/*for(int i=0;i<n;i++){\n\t\tif(used[i][i]){\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t}\n\t\t\tret.push_back(P(i,1));\n\t\t\tret.push_back(P(i+1,1));\n\t\t\tret.push_back(P(i+1,0));\n\t\t\tret.push_back(P(i,0));\n\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\tret.push_back(P(j,0));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int k=i+1;k<n;k++){\n\t\t\tif(used[i][k]){\n\t\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(i,1));\n\t\t\t\tret.push_back(P(i+1,1));\n\t\t\t\tret.push_back(P(i+1,0));\n\t\t\t\tret.push_back(P(i,0));\n\t\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(k,1));\n\t\t\t\tret.push_back(P(k+1,1));\n\t\t\t\tret.push_back(P(k+1,0));\n\t\t\t\tret.push_back(P(k,0));\n\t\t\t\tfor(int j=k-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(i+1,0));\n\t\t\t\tret.push_back(P(i+1,1));\n\t\t\t\tret.push_back(P(i,1));\n\t\t\t\tret.push_back(P(i,0));\n\t\t\t\tfor(int j=i-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\t\tret.push_back(P(j+1,0));\n\t\t\t\t}\n\t\t\t\tret.push_back(P(k+1,0));\n\t\t\t\tret.push_back(P(k+1,1));\n\t\t\t\tret.push_back(P(k,1));\n\t\t\t\tret.push_back(P(k,0));\n\t\t\t\tfor(int j=k-1;j>=0;j--){\n\t\t\t\t\tret.push_back(P(j,0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}*/\n\t\n\tputs(\"Possible\");\n\tprintf(\"%d\\n\",(int)(ret.size())-1);\n\tfor(int i=0;i<ret.size();i++){\n\t\tprintf(\"%d %d\\n\",ret[i].fr,ret[i].sc);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\n#define NO return !printf(\"Impossible\\n\")\n#define N 433\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint n,a[N];\nchar s[N];\nvector<pair<int,int> > ans;\nstring Rev(string s){\n\treverse(s.begin(),s.end());\n\tfor(auto c:s){\n\t\tif(c>='a'&&c<='z')c+='A'-'a';\n\t\telse c+='a'-'A';\n\t}\n\treturn s;\n}\nint main(){\n\tn=read();\n\tscanf(\"%s\",s);\n\tfor(int i=0;i<(1<<n);++i){\n\t\ta[i]=s[i]-'0';\n\t}\n\tif(!a[0])NO;\n\tfor(int i=0;i<(1<<n);++i){\n\t\tif(a[i]){\n\t\t\tfor(int j=(i-1)&i;j;j=(j-1)&i){\n\t\t\t\tif(!a[j])NO;\n\t\t\t}\n\t\t}\n\t}\n\tans.emplace_back(0,0);\n\tfor(int i=0;i<(1<<n);++i){\n\t\tif(a[i])continue;\n\t\tbool ok=true;\n\t\tfor(int j=(i-1)&i;j;j=(j-1)&i){\n\t\t\tif(!a[j]){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok)continue;\n\t\tstring myh;\n\t\tfor(int j=0;j<n;++j){\n\t\t\tif((i>>j)&1){\n\t\t\t\tif(myh.empty())myh=(char)('a'+j);\n\t\t\t\telse myh=(char)('a'+j)+myh+(char)('A'+j)+Rev(myh);\n\t\t\t}\n\t\t}\n\t\tint pos=0;\n\t\tfor(auto c:myh){\n\t\t\tint d=0,x=0;\n\t\t\tif(c>='a'&&c<='z'){\n\t\t\t\tx=c-'a',d=1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tx=c-'A',d=0;\n\t\t\t}\n\t\t\twhile(pos<x)ans.emplace_back(++pos,0);\n\t\t\twhile(pos>x)ans.emplace_back(--pos,0);\n\t\t\tif(d){\n\t\t\t\tans.emplace_back(x,1);\n\t\t\t\tans.emplace_back(x+1,1);\n\t\t\t\tans.emplace_back(x+1,0);\n\t\t\t\tans.emplace_back(x,0);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans.emplace_back(x+1,0);\n\t\t\t\tans.emplace_back(x+1,1);\n\t\t\t\tans.emplace_back(x,1);\n\t\t\t\tans.emplace_back(x,0);\n\t\t\t}\n\t\t}\n\t\twhile(pos>0)ans.emplace_back(--pos,0);\n\t}\n\tprintf(\"Possible\\n%d\\n\",(int)ans.size()-1);\n\tfor(auto x:ans){\n\t\tprintf(\"%d %d\\n\",x.first,x.second);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs, PatternGuards, MagicHash, UnboxedTuples,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns, PolyKinds,\n  TypeFamilies, OverloadedStrings, FlexibleInstances, UndecidableInstances,\n  DefaultSignatures, GeneralizedNewtypeDeriving, StandaloneDeriving,\n  DeriveGeneric, DeriveFunctor, DeriveDataTypeable, DeriveFoldable,\n  DeriveTraversable, DeriveDataTypeable, FlexibleInstances,\n  MultiParamTypeClasses #-}\n{-# OPTIONS_GHC -O2 #-}\n\n#define PHASE_FUSED [1]\n#define PHASE_INNER [0]\n#define INLINE_FUSED INLINE PHASE_FUSED\n#define INLINE_INNER INLINE PHASE_INNER\n\nimport Prelude\nimport Data.Bits\nimport Data.List\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Ratio\nimport Data.Function\nimport Data.STRef\nimport Data.IORef\nimport Data.Monoid\nimport Data.Functor\nimport Data.Functor.Identity\nimport Data.Bifunctor\nimport Data.Data\nimport Data.Typeable\nimport GHC.Generics\nimport System.IO\nimport System.IO.Unsafe (unsafeDupablePerformIO, unsafePerformIO)\nimport qualified Control.Arrow as Arr\nimport Control.Arrow hiding (first,second)\nimport Control.Applicative\nimport Control.Monad\nimport Control.Monad.Primitive\nimport Control.Monad.State.Strict\nimport Control.Monad.ST\nimport Control.Monad.ST.Lazy (strictToLazyST, lazyToStrictST)\nimport qualified Control.Monad.ST.Lazy as STL\n-- import Control.Monad.ST.Safe\nimport Control.DeepSeq\nimport Data.Coerce\nimport qualified Data.ByteString as BSW\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Lazy as BSLW\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport qualified Data.ByteString.Builder as BSB\nimport qualified Data.ByteString.Unsafe as BSU\nimport qualified Data.ByteString.Internal as BSU\nimport Data.IntMap (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as VM\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport qualified Data.Vector.Storable as VS\nimport qualified Data.Vector.Storable.Mutable as VSM\nimport qualified Data.Vector.Primitive as VP\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic as VG\nimport qualified Data.Vector.Generic.Mutable as VGM\nimport qualified Data.Vector.Fusion.Bundle.Monadic as VFBM\nimport qualified Data.Vector.Fusion.Bundle as VFB\nimport qualified Data.Vector.Fusion.Stream.Monadic as VFSM\nimport qualified Data.Vector.Fusion.Bundle.Size as VFBS\nimport qualified Data.Vector.Fusion.Util as VFU\nimport qualified Data.Attoparsec.ByteString.Char8 as Atto\nimport Debug.Trace\nimport Unsafe.Coerce\nimport Foreign.ForeignPtr\nimport System.Exit\nimport GHC.Exts (build, Int(..), Int#,\n                 (+#), (*#), (-#), (<#), (>=#), (==#), quotRemInt#,\n                 remInt#, uncheckedIShiftRL#, andI#, orI#,\n                isTrue#, Addr#, Ptr(..))\n\nmakeCurve :: [(Int,Bool)] -> [(Int,Int)]\nmakeCurve xs = tail $ go (-1) coords\n  where\n    connect x y | x < y = map (,0) [x..y]\n                | otherwise = map (,0) [x,x-1..y]\n    go i ((x,y):ps)\n      | i == x    = (y,1):go y ps\n      | otherwise = connect i x ++ (x,1):(y,1):go y ps\n    go i [] = connect i 0\n    coords = map (\\(x,t) -> if t then (x,x+1) else (x+1,x)) xs \n\nmult :: [(Int,Bool)] -> [(Int,Bool)] -> [(Int,Bool)]\nmult = (++)\n \ninv :: [(Int,Bool)] -> [(Int,Bool)]\ninv = reverse . map (second not)\n\ncommut :: [(Int,Bool)] -> [(Int,Bool)] -> [(Int,Bool)]\ncommut x y = mult x $ mult y $ mult (inv x) (inv y)\n\nsingle :: Int -> [(Int,Bool)]\nsingle = (:[]) . (,True)\n\nmakeCommut :: Int -> [(Int,Bool)]\nmakeCommut 0 = []\nmakeCommut u = evalState (go $ popCount u) u\n  where\n    go 1 = state $ \\ !s -> (single $ countTrailingZeros s, xor s $ s .&. (-s))\n    go !pc = liftA2 commut (go dv) $ go (pc-dv)\n      where dv = pc `shiftR` 1\n\nmain :: IO ()\nmain = do\n  n <- readInt <$> getLine\n  xs <- getVecULn (bit n) $ (toW8 (ord '1') -) <$> StateT BSW.uncons\n  dp <- VU.unsafeThaw xs\n  forM_ [0..bit n - 1] $ \\ !i -> do\n    cur <- VUM.unsafeRead dp i\n    when (cur == 1) $ do\n      VUM.unsafeWrite dp i 3\n      forM_ (filter ((==i) . (.&.i)) [i+1..bit n - 1]) $ \\ !j -> do\n        nxt <- VUM.unsafeRead dp j\n        case nxt of\n          0 -> do putStrLn \"Impossible\"\n                  exitSuccess\n          1 -> VUM.unsafeWrite dp j 2\n          2 -> return ()\n          _ -> do hPutStrLn stderr\n                    $ \"Error! Invalid input? occurred: \" ++ show nxt\n                  exitFailure\n  dp <- VU.unsafeFreeze dp\n  putStrLn \"Possible\"\n  let res = makeCurve $ concatMap makeCommut $ VU.toList $ VU.elemIndices 3 dp\n  print $ length res - 1\n  putStr $ unlines $ map (\\(x,y) -> shows x $ ' ' : show y) res\n  return ()\n\n#define IL(f) {-# INLINE f #-}; f\n\nIL(putBuilder) = BSB.hPutBuilder stdout\n\nprintVecInLines, printVecInSpcSepLn ::\n  (VG.Vector v a, ShowAsBuilder a) => v a -> IO ()\nIL(printVecInLines) = putBuilder . v2BLines\nIL(printVecInSpcSepLn) = putBuilder . v2BSpcSepLn\n\nclass ShowAsBuilder a where\n  showAsBuilder :: a -> BSB.Builder\n  default showAsBuilder :: (Show a) => a -> BSB.Builder\n  IL(showAsBuilder) = BSB.string8 . show\n\n-- Inconsistent with show\ninstance (ShowAsBuilder a, VG.Vector v a) => ShowAsBuilder (v a) where\n  IL(showAsBuilder) = v2BSpcSep\n\n#define INS(t,f) instance ShowAsBuilder t where { IL(showAsBuilder)=f }\nINS(Int,BSB.intDec)\nINS(Int8,BSB.int8Dec)\nINS(Int16,BSB.int16Dec)\nINS(Int32,BSB.int32Dec)\nINS(Int64,BSB.int64Dec)\nINS(Word,BSB.wordDec)\nINS(Word8,BSB.word8Dec)\nINS(Word16,BSB.word16Dec)\nINS(Word32,BSB.word32Dec)\nINS(Word64,BSB.word64Dec)\nINS(Integer,BSB.integerDec)\nINS(Float,BSB.floatDec)\nINS(Double,BSB.doubleDec)\n-- INS(String,BSB.string8) -- Inconsistent with Show\n-- INS(BS.ByteString,BSB.byteString) -- Inconsistent with Show\n-- INS(BSL.ByteString,BSB.lazyByteString) -- Inconsisitent with Show\n#undef INS\n\n-- Inconsistent with Show\ninstance (ShowAsBuilder a, ShowAsBuilder b) => ShowAsBuilder (a,b) where\n  IL(showAsBuilder) = showTupAsBuilder\ninstance (ShowAsBuilder a, ShowAsBuilder b, ShowAsBuilder c) =>\n  ShowAsBuilder (a,b,c) where\n  IL(showAsBuilder) = showTup3AsBuilder\ninstance (ShowAsBuilder a, ShowAsBuilder b, ShowAsBuilder c, ShowAsBuilder d) =>\n  ShowAsBuilder (a,b,c,d) where\n  IL(showAsBuilder) = showTup4AsBuilder\n\nIL(showTupAsBuilderWith)\n  :: (a -> BSB.Builder) -> (b -> BSB.Builder) -> (a,b) -> BSB.Builder\nshowTupAsBuilderWith showA showB\n  = \\(a,b) -> (showA a <>) $ BSB.char7 ' ' <> showB b\nIL(showTupAsBuilder) :: (ShowAsBuilder a, ShowAsBuilder b)\n  => (a,b) -> BSB.Builder\nshowTupAsBuilder = showTupAsBuilderWith showAsBuilder showAsBuilder \n\nIL(showTup3AsBuilderWith) :: (a -> BSB.Builder) -> (b -> BSB.Builder) ->\n  (c -> BSB.Builder) -> (a,b,c) -> BSB.Builder\nshowTup3AsBuilderWith showA showB showC\n  = \\(a,b,c) -> (showA a <>) $ (BSB.char7 ' ' <>) $ (showB b <>)\n                $ (BSB.char7 ' ' <>) $ showC c\nIL(showTup3AsBuilder) :: (ShowAsBuilder a, ShowAsBuilder b, ShowAsBuilder c)\n  => (a,b,c) -> BSB.Builder\nshowTup3AsBuilder\n  = showTup3AsBuilderWith showAsBuilder showAsBuilder showAsBuilder\n\nIL(showTup4AsBuilderWith) :: (a -> BSB.Builder) -> (b -> BSB.Builder) ->\n  (c -> BSB.Builder) -> (d -> BSB.Builder) -> (a,b,c,d) -> BSB.Builder\nshowTup4AsBuilderWith showA showB showC showD\n  = \\(a,b,c,d) -> (showA a <>) $ (BSB.char7 ' ' <>)\n                  $ showTup3AsBuilderWith showB showC showD (b,c,d)\nIL(showTup4AsBuilder) ::\n  (ShowAsBuilder a, ShowAsBuilder b, ShowAsBuilder c, ShowAsBuilder d) =>\n  (a,b,c,d) -> BSB.Builder\nshowTup4AsBuilder = showTup4AsBuilderWith showAsBuilder showAsBuilder\n                    showAsBuilder showAsBuilder\n\nv2BSpcSepLn, v2BSpcSep, v2BConcat, v2BLines ::\n  (VG.Vector v a, ShowAsBuilder a)\n  => v a -> BSB.Builder\nIL(v2BSpcSepLn) = v2BSpcSepLnWith showAsBuilder\nIL(v2BSpcSep) = v2BSpcSepWith showAsBuilder\nIL(v2BConcat) = v2BConcatWith showAsBuilder\nIL(v2BLines) = v2BLinesWith showAsBuilder\n\n\nv2BSpcSepLnWith, v2BSpcSepWith, v2BConcatWith, v2BLinesWith ::\n  (VG.Vector v a)\n  => (a -> BSB.Builder) -- ^ show function\n  -> v a -> BSB.Builder\nIL(v2BSpcSepLnWith) = v2BSpcSepPostfWith $ BS.singleton '\\n'\nIL(v2BSpcSepWith) = v2BSpcSepPostfWith BS.empty\nIL(v2BConcatWith) showFct = VG.foldr ((<>) . showFct) mempty\nIL(v2BLinesWith) showFct\n  = VG.foldr (\\ a -> (showFct a <>) . (BSB.char7 '\\n' <>)) mempty\n\n\nv2BSpcSepPostf :: (VG.Vector v a, ShowAsBuilder a)\n  => BS.ByteString -- ^ postfix\n  -> v a -> BSB.Builder\nIL(v2BSpcSepPostf) = (`v2BSpcSepPostfWith` showAsBuilder)\n\nv2BSpcSepPostfWith :: (VG.Vector v a)\n  => BS.ByteString -- ^ postfix\n  -> (a -> BSB.Builder) -- ^ show function\n  -> v a -> BSB.Builder\nIL(v2BSpcSepPostfWith) = vecToBuilder BS.empty $ BS.singleton ' '\n\nIL(vecToBuilder) :: (VG.Vector v a)\n  => BS.ByteString -- ^ prefix\n  -> BS.ByteString -- ^ separator\n  -> BS.ByteString -- ^ postfix\n  -> (a -> BSB.Builder) -- ^ show function\n  -> v a -> BSB.Builder\nvecToBuilder !prefix !separator !postfix\n  = vecToBuilder_ (BSB.byteString prefix)\n                  (BSB.byteString separator)\n                  (BSB.byteString postfix)\n\n\nIL(vecToBuilder_) :: (VG.Vector v a)\n  => BSB.Builder -- ^ prefix\n  -> BSB.Builder -- ^ separator\n  -> BSB.Builder -- ^ postfix\n  -> (a -> BSB.Builder) -- ^ show function\n  -> v a -> BSB.Builder\nvecToBuilder_ !prefix !separator !postfix showFct = \\vec -> prefix <>\n  VG.foldr\n  (\\ a rest !prefx -> prefx <> (showFct a <> rest separator))\n  (const postfix) vec mempty\n\nIL(evalVals) :: [a] -> [a]\nevalVals xs = build $ \\c n -> foldr (c $!) n xs\nIL(forceVals) :: (NFData a) => [a] -> [a]\nforceVals xs = build $ \\c n -> foldr (c $!!) n xs\n\nIL(readLnWith) :: StateT BS.ByteString Maybe a -> IO a\nreadLnWith parser = fromJust . evalStateT parser <$> BS.getLine\nIL(readContentWith) :: StateT BSL.ByteString Maybe a -> IO a\nreadContentWith parser = fromJust . evalStateT parser <$> BSL.getContents\n\nIL(getVecGLn) :: (VG.Vector v a) =>\n  Int -> StateT BS.ByteString Maybe a -> IO (v a)\ngetVecGLn n s = VG.unfoldrN n (runStateT s) <$> BS.getLine\nIL(getVecGRest) :: (VG.Vector v a) =>\n  Int -> StateT BSL.ByteString Maybe a -> IO (v a)\ngetVecGRest n s = VG.unfoldrN n (runStateT s) <$> BSL.getContents\nIL(getVecLn) :: Int -> StateT BS.ByteString Maybe a -> IO (V.Vector a)\ngetVecLn = getVecGLn\nIL(getVecRest) :: Int -> StateT BSL.ByteString Maybe a -> IO (V.Vector a)\ngetVecRest = getVecGRest\nIL(getVecULn) :: (VU.Unbox a) =>\n  Int -> StateT BS.ByteString Maybe a -> IO (VU.Vector a)\ngetVecULn = getVecGLn\nIL(getVecURest) :: (VU.Unbox a) =>\n  Int -> StateT BSL.ByteString Maybe a -> IO (VU.Vector a)\ngetVecURest = getVecGRest\n\nIL(rIntL) :: StateT BSL.ByteString Maybe Int\nrIntL = skipSpecialL $ StateT BSL.readInt\nIL(rIntS) :: StateT BS.ByteString Maybe Int\nrIntS = skipSpecialS $ StateT BS.readInt\nIL(rStrL) :: (MonadState BSL.ByteString m) => m BS.ByteString\nrStrL = skipSpecialL $ BSL.toStrict <$> state (BSL.span (>='!'))\nIL(rStrS) :: (MonadState BS.ByteString m) => m BS.ByteString\nrStrS = skipSpecialS $ state $ BS.span (>='!')\nIL(rCharL) :: StateT BSL.ByteString Maybe Char\nrCharL = StateT BSL.uncons\nIL(rCharS) :: StateT BS.ByteString Maybe Char\nrCharS = StateT BS.uncons\nIL(dropSpecialL) :: (MonadState BSL.ByteString m) => m ()\ndropSpecialL = modify $ BSL.dropWhile (<'!')\nIL(dropSpecialS) :: (MonadState BS.ByteString m) => m ()\ndropSpecialS = modify $ BS.dropWhile (<'!')\nIL(skipSpecialL) :: (MonadState BSL.ByteString m) => m a -> m a\nskipSpecialL = (dropSpecialL *>)\nIL(skipSpecialS) :: (MonadState BS.ByteString m) => m a -> m a\nskipSpecialS = (dropSpecialS *>)\n\nIL(linToMat) :: (VG.Vector v a) => Int -> Int -> v a -> V.Vector (v a)\nlinToMat h w lvec = vEvalElemsId $ V.generate h (\\i -> VG.slice (i*w) w lvec)\n\nIL(mLinToMat) :: (VGM.MVector v a) => Int -> Int -> v s a -> V.Vector (v s a)\nmLinToMat h w lvec = vEvalElemsId $ V.generate h (\\i -> VGM.slice (i*w) w lvec)\n  \nIL(unsafeAddrToSVec) :: Int -> Addr# -> VS.Vector Word8\nunsafeAddrToSVec n addr\n  = (`VS.unsafeFromForeignPtr0` n)\n    $ unsafeDupablePerformIO\n    $ newForeignPtr_ $ Ptr addr\n\nIL(vEvalElemsId) :: (VG.Vector v a) => v a -> v a\nvEvalElemsId = vMapFoldl (\\ !_ !x -> (x,())) ()\n\nIL(vEvalElems) :: (VG.Vector v a) => v a -> ()\nvEvalElems = VG.foldl' (\\ !_ !_ -> ()) () \n\nIL(vMapFoldl) :: (VG.Vector v b, VG.Vector v c) =>\n  (a -> b -> (c,a)) -> a -> v b -> v c\nvMapFoldl f a\n  = VG.unstream . VFB.inplace (streamMapFoldl f a) id . VG.stream\n\nstreamMapFoldl :: (Functor m) =>\n  (a -> b -> (c,a)) -> a -> VFSM.Stream m b -> VFSM.Stream m c\n{-# INLINE_FUSED streamMapFoldl #-}\nstreamMapFoldl f a (VFSM.Stream step s) = VFSM.Stream step1 (a,s)\n  where\n    {-# INLINE_INNER step1 #-}\n    step1 (a0,s0) =  (<$> step s0) $ \\r -> case r of\n      VFSM.Yield b s1 -> case f a0 b of (c,a1) -> VFSM.Yield c (a1,s1)\n      VFSM.Skip    s1 -> VFSM.Skip (a0,s1)\n      VFSM.Done       -> VFSM.Done\n\nIL(svecToBS) :: VS.Vector Word8 -> BS.ByteString\nsvecToBS vec = BSU.fromForeignPtr ptr 0 len\n  where (ptr, len) = VS.unsafeToForeignPtr0 vec\n\n\nunlessM, whenM :: (Monad m) => m Bool -> m () -> m ()\nIL(whenM) = (. flip when) . (>>=)\nIL(unlessM) = (. flip unless) . (>>=)\n\nIL(wrA) = A.writeArray\nIL(rdA) = A.readArray\nIL(mdA) = \\arr f !i -> do\n  ai <- rdA arr i\n  let fai = f ai \n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE mdA' #-}\nmdA' = \\arr f !i -> do\n  !ai <- rdA arr i\n  let !fai = f ai\n  wrA arr i fai\n  return (ai,fai)\nIL(swapA) = \\arr !i !j -> do\n  ai <- rdA arr i\n  wrA arr i =<< rdA arr j\n  wrA arr j ai\n\n#define D(f,r,d)\\\n  IL(f) :: Integral a=>a->d; f=fromIntegral;\\\n  IL(r) :: String->d; r=read\n#define C(f,r,g,h,d) D(f,r,d);\\\n  g,h :: RealFrac a=>a->d; IL(g)=floor; IL(h)=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n#define TS(f,a,m,init)\\\n  IL(f) :: forall e i s. (C(a,m) A.Ix i) => (i,i) -> init m (a i e); f\n#define N(f,g,h,a,m)\\\n  TS(f,a,m,e->)=A.newArray;\\\n  TS(g,a,m,)=A.newArray_;\\\n  TS(h,a,m,[e]->)=A.newListArray\n#define C(a,m)\nN(newIOA,newIOA_,newIOAL,IOArray,IO)\nN(newSTA,newSTA_,newSTAL,STArray s,ST s)\n#undef C\n#define C(a,m) MArray (a) e (m), \nN(newIOUA,newIOUA_,newIOUAL,IOUArray,IO)\nN(newSTUA,newSTUA_,newSTUAL,STUArray s,ST s)\n#undef C\n#undef N\n#undef TS\n\n#undef IL\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs, PatternGuards, MagicHash, UnboxedTuples,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns, PolyKinds,\n  TypeFamilies, OverloadedStrings, FlexibleInstances, UndecidableInstances,\n  DefaultSignatures, GeneralizedNewtypeDeriving, StandaloneDeriving,\n  DeriveGeneric, DeriveFunctor, DeriveDataTypeable, DeriveFoldable,\n  DeriveTraversable, DeriveDataTypeable, FlexibleInstances,\n  MultiParamTypeClasses #-}\n{-# OPTIONS_GHC -O2 #-}\n\n#define PHASE_FUSED [1]\n#define PHASE_INNER [0]\n#define INLINE_FUSED INLINE PHASE_FUSED\n#define INLINE_INNER INLINE PHASE_INNER\n\nimport Prelude\nimport Data.Bits\nimport Data.List\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Ratio\nimport Data.Function\nimport Data.STRef\nimport Data.IORef\nimport Data.Monoid\nimport Data.Functor\nimport Data.Functor.Identity\nimport Data.Data\nimport Data.Typeable\nimport GHC.Generics\nimport System.IO\nimport System.IO.Unsafe (unsafeDupablePerformIO, unsafePerformIO)\nimport Control.Arrow\nimport Control.Applicative\nimport Control.Monad\nimport Control.Monad.Primitive\nimport Control.Monad.State.Strict\nimport Control.Monad.ST\nimport Control.Monad.ST.Lazy (strictToLazyST, lazyToStrictST)\nimport qualified Control.Monad.ST.Lazy as STL\n-- import Control.Monad.ST.Safe\nimport Control.DeepSeq\nimport Data.Coerce\nimport qualified Data.ByteString as BSW\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Lazy as BSLW\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport qualified Data.ByteString.Builder as BSB\nimport qualified Data.ByteString.Unsafe as BSU\nimport qualified Data.ByteString.Internal as BSU\nimport Data.IntMap (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as VM\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport qualified Data.Vector.Storable as VS\nimport qualified Data.Vector.Storable.Mutable as VSM\nimport qualified Data.Vector.Primitive as VP\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic as VG\nimport qualified Data.Vector.Generic.Mutable as VGM\nimport qualified Data.Vector.Fusion.Bundle.Monadic as VFBM\nimport qualified Data.Vector.Fusion.Bundle as VFB\nimport qualified Data.Vector.Fusion.Stream.Monadic as VFSM\nimport qualified Data.Vector.Fusion.Bundle.Size as VFBS\nimport qualified Data.Vector.Fusion.Util as VFU\nimport qualified Data.Attoparsec.ByteString.Char8 as Atto\nimport Debug.Trace\nimport Unsafe.Coerce\nimport Foreign.ForeignPtr\nimport System.Exit\nimport GHC.Exts (build, Int(..), Int#,\n                 (+#), (*#), (-#), (<#), (>=#), (==#), quotRemInt#,\n                 remInt#, uncheckedIShiftRL#, andI#, orI#,\n                isTrue#, Addr#, Ptr(..))\n\nmakeCurve :: [(Int,Bool)] -> [(Int,Int)]\nmakeCurve xs = tail $ go (-1) coords\n  where\n    connect x y | x < y = map (,0) [x..y]\n                | otherwise = map (,0) [x,x-1..y]\n    go i ((x,y):ps)\n      | i == x    = (y,1):go y ps\n      | otherwise = connect i x ++ (x,1):(y,1): go y ps\n    go i [] = connect i 0\n    coords = map (\\(x,t) -> if t then (x,x+1) else (x+1,x)) xs \n\nmult :: [(Int,Bool)] -> [(Int,Bool)] -> [(Int,Bool)]\nmult = (++)\n \ninv :: [(Int,Bool)] -> [(Int,Bool)]\ninv = reverse . map (\\(i,b) -> (i,not b))\n\ncommut :: [(Int,Bool)] -> [(Int,Bool)] -> [(Int,Bool)]\ncommut x y = mult x $ mult y $ mult (inv x) (inv y)\n\nsingle :: Int -> [(Int,Bool)]\nsingle = (:[]) . (,True)\n\nmakeCommut :: Int -> [(Int,Bool)]\nmakeCommut u | popCnt == 0 = []\n             | otherwise = go popCnt $ filter (testBit u) [0..7]\n  where\n    popCnt = popCount u\n    go 1 (x:_) = [(x,True)]\n    go !pc xs = commut (go dv ys) (go (pc-dv) zs)\n      where\n        dv = pc `shiftR` 1\n        (ys,zs) = splitAt dv xs\n\nmain :: IO ()\nmain = do\n  n <- readInt <$> getLine\n  xs <- getVecULn (bit n)\n        $ (1-) . subtract (toW8 $ ord '0') <$> StateT BSW.uncons\n  dp <- VU.unsafeThaw xs\n  forM_ [0..bit n - 1] $ \\ !i -> do\n    cur <- VUM.unsafeRead dp i\n    when (cur == 1) $ do\n      forM_ (filter ((==i).(.&.i)) [i+1..bit n - 1]) $ \\ !j -> do\n        nxt <- VUM.unsafeRead dp j\n        if nxt == 0\n          then do putStrLn \"Impossible\"\n                  exitSuccess\n          else VUM.unsafeWrite dp j 2\n      VUM.unsafeWrite dp i 3\n  dp <- VU.unsafeFreeze dp\n  putStrLn \"Possible\"\n  let res = makeCurve $ concatMap makeCommut $ VU.toList $ VU.elemIndices 3 dp\n  print $ length res - 1\n  putStr $ unlines $ map (\\(x,y) -> shows x $ ' ' : show y) res\n  return ()\n\n#define IL(f) {-# INLINE f #-}; f\n\nIL(putBuilder) = BSB.hPutBuilder stdout\n\nprintVecInLines, printVecInSpcSepLn ::\n  (VG.Vector v a, ShowAsBuilder a) => v a -> IO ()\nIL(printVecInLines) = putBuilder . v2BLines\nIL(printVecInSpcSepLn) = putBuilder . v2BSpcSepLn\n\nclass ShowAsBuilder a where\n  showAsBuilder :: a -> BSB.Builder\n  default showAsBuilder :: (Show a) => a -> BSB.Builder\n  IL(showAsBuilder) = BSB.string8 . show\n\n-- Inconsistent with show\ninstance (ShowAsBuilder a, VG.Vector v a) => ShowAsBuilder (v a) where\n  IL(showAsBuilder) = v2BSpcSep\n\n#define INS(t,f) instance ShowAsBuilder t where { IL(showAsBuilder)=f }\nINS(Int,BSB.intDec)\nINS(Int8,BSB.int8Dec)\nINS(Int16,BSB.int16Dec)\nINS(Int32,BSB.int32Dec)\nINS(Int64,BSB.int64Dec)\nINS(Word,BSB.wordDec)\nINS(Word8,BSB.word8Dec)\nINS(Word16,BSB.word16Dec)\nINS(Word32,BSB.word32Dec)\nINS(Word64,BSB.word64Dec)\nINS(Integer,BSB.integerDec)\nINS(Float,BSB.floatDec)\nINS(Double,BSB.doubleDec)\n-- INS(String,BSB.string8) -- Inconsistent with Show\n-- INS(BS.ByteString,BSB.byteString) -- Inconsistent with Show\n-- INS(BSL.ByteString,BSB.lazyByteString) -- Inconsisitent with Show\n#undef INS\n\n-- Inconsistent with Show\ninstance (ShowAsBuilder a, ShowAsBuilder b) => ShowAsBuilder (a,b) where\n  IL(showAsBuilder) = showTupAsBuilder\ninstance (ShowAsBuilder a, ShowAsBuilder b, ShowAsBuilder c) =>\n  ShowAsBuilder (a,b,c) where\n  IL(showAsBuilder) = showTup3AsBuilder\ninstance (ShowAsBuilder a, ShowAsBuilder b, ShowAsBuilder c, ShowAsBuilder d) =>\n  ShowAsBuilder (a,b,c,d) where\n  IL(showAsBuilder) = showTup4AsBuilder\n\nIL(showTupAsBuilderWith)\n  :: (a -> BSB.Builder) -> (b -> BSB.Builder) -> (a,b) -> BSB.Builder\nshowTupAsBuilderWith showA showB\n  = \\(a,b) -> (showA a <>) $ BSB.char7 ' ' <> showB b\nIL(showTupAsBuilder) :: (ShowAsBuilder a, ShowAsBuilder b)\n  => (a,b) -> BSB.Builder\nshowTupAsBuilder = showTupAsBuilderWith showAsBuilder showAsBuilder \n\nIL(showTup3AsBuilderWith) :: (a -> BSB.Builder) -> (b -> BSB.Builder) ->\n  (c -> BSB.Builder) -> (a,b,c) -> BSB.Builder\nshowTup3AsBuilderWith showA showB showC\n  = \\(a,b,c) -> (showA a <>) $ (BSB.char7 ' ' <>) $ (showB b <>)\n                $ (BSB.char7 ' ' <>) $ showC c\nIL(showTup3AsBuilder) :: (ShowAsBuilder a, ShowAsBuilder b, ShowAsBuilder c)\n  => (a,b,c) -> BSB.Builder\nshowTup3AsBuilder\n  = showTup3AsBuilderWith showAsBuilder showAsBuilder showAsBuilder\n\nIL(showTup4AsBuilderWith) :: (a -> BSB.Builder) -> (b -> BSB.Builder) ->\n  (c -> BSB.Builder) -> (d -> BSB.Builder) -> (a,b,c,d) -> BSB.Builder\nshowTup4AsBuilderWith showA showB showC showD\n  = \\(a,b,c,d) -> (showA a <>) $ (BSB.char7 ' ' <>)\n                  $ showTup3AsBuilderWith showB showC showD (b,c,d)\nIL(showTup4AsBuilder) ::\n  (ShowAsBuilder a, ShowAsBuilder b, ShowAsBuilder c, ShowAsBuilder d) =>\n  (a,b,c,d) -> BSB.Builder\nshowTup4AsBuilder = showTup4AsBuilderWith showAsBuilder showAsBuilder\n                    showAsBuilder showAsBuilder\n\nv2BSpcSepLn, v2BSpcSep, v2BConcat, v2BLines ::\n  (VG.Vector v a, ShowAsBuilder a)\n  => v a -> BSB.Builder\nIL(v2BSpcSepLn) = v2BSpcSepLnWith showAsBuilder\nIL(v2BSpcSep) = v2BSpcSepWith showAsBuilder\nIL(v2BConcat) = v2BConcatWith showAsBuilder\nIL(v2BLines) = v2BLinesWith showAsBuilder\n\n\nv2BSpcSepLnWith, v2BSpcSepWith, v2BConcatWith, v2BLinesWith ::\n  (VG.Vector v a)\n  => (a -> BSB.Builder) -- ^ show function\n  -> v a -> BSB.Builder\nIL(v2BSpcSepLnWith) = v2BSpcSepPostfWith $ BS.singleton '\\n'\nIL(v2BSpcSepWith) = v2BSpcSepPostfWith BS.empty\nIL(v2BConcatWith) showFct = VG.foldr ((<>) . showFct) mempty\nIL(v2BLinesWith) showFct\n  = VG.foldr (\\ a -> (showFct a <>) . (BSB.char7 '\\n' <>)) mempty\n\n\nv2BSpcSepPostf :: (VG.Vector v a, ShowAsBuilder a)\n  => BS.ByteString -- ^ postfix\n  -> v a -> BSB.Builder\nIL(v2BSpcSepPostf) = (`v2BSpcSepPostfWith` showAsBuilder)\n\nv2BSpcSepPostfWith :: (VG.Vector v a)\n  => BS.ByteString -- ^ postfix\n  -> (a -> BSB.Builder) -- ^ show function\n  -> v a -> BSB.Builder\nIL(v2BSpcSepPostfWith) = vecToBuilder BS.empty $ BS.singleton ' '\n\nIL(vecToBuilder) :: (VG.Vector v a)\n  => BS.ByteString -- ^ prefix\n  -> BS.ByteString -- ^ separator\n  -> BS.ByteString -- ^ postfix\n  -> (a -> BSB.Builder) -- ^ show function\n  -> v a -> BSB.Builder\nvecToBuilder !prefix !separator !postfix\n  = vecToBuilder_ (BSB.byteString prefix)\n                  (BSB.byteString separator)\n                  (BSB.byteString postfix)\n\n\nIL(vecToBuilder_) :: (VG.Vector v a)\n  => BSB.Builder -- ^ prefix\n  -> BSB.Builder -- ^ separator\n  -> BSB.Builder -- ^ postfix\n  -> (a -> BSB.Builder) -- ^ show function\n  -> v a -> BSB.Builder\nvecToBuilder_ !prefix !separator !postfix showFct = \\vec -> prefix <>\n  VG.foldr\n  (\\ a rest !prefx -> prefx <> (showFct a <> rest separator))\n  (const postfix) vec mempty\n\nIL(evalVals) :: [a] -> [a]\nevalVals xs = build $ \\c n -> foldr (c $!) n xs\nIL(forceVals) :: (NFData a) => [a] -> [a]\nforceVals xs = build $ \\c n -> foldr (c $!!) n xs\n\nIL(readLnWith) :: StateT BS.ByteString Maybe a -> IO a\nreadLnWith parser = fromJust . evalStateT parser <$> BS.getLine\nIL(readContentWith) :: StateT BSL.ByteString Maybe a -> IO a\nreadContentWith parser = fromJust . evalStateT parser <$> BSL.getContents\n\nIL(getVecGLn) :: (VG.Vector v a) =>\n  Int -> StateT BS.ByteString Maybe a -> IO (v a)\ngetVecGLn n s = VG.unfoldrN n (runStateT s) <$> BS.getLine\nIL(getVecGRest) :: (VG.Vector v a) =>\n  Int -> StateT BSL.ByteString Maybe a -> IO (v a)\ngetVecGRest n s = VG.unfoldrN n (runStateT s) <$> BSL.getContents\nIL(getVecLn) :: Int -> StateT BS.ByteString Maybe a -> IO (V.Vector a)\ngetVecLn = getVecGLn\nIL(getVecRest) :: Int -> StateT BSL.ByteString Maybe a -> IO (V.Vector a)\ngetVecRest = getVecGRest\nIL(getVecULn) :: (VU.Unbox a) =>\n  Int -> StateT BS.ByteString Maybe a -> IO (VU.Vector a)\ngetVecULn = getVecGLn\nIL(getVecURest) :: (VU.Unbox a) =>\n  Int -> StateT BSL.ByteString Maybe a -> IO (VU.Vector a)\ngetVecURest = getVecGRest\n\nIL(rIntL) :: StateT BSL.ByteString Maybe Int\nrIntL = skipSpecialL $ StateT BSL.readInt\nIL(rIntS) :: StateT BS.ByteString Maybe Int\nrIntS = skipSpecialS $ StateT BS.readInt\nIL(rStrL) :: (MonadState BSL.ByteString m) => m BS.ByteString\nrStrL = skipSpecialL $ BSL.toStrict <$> state (BSL.span (>='!'))\nIL(rStrS) :: (MonadState BS.ByteString m) => m BS.ByteString\nrStrS = skipSpecialS $ state $ BS.span (>='!')\nIL(rCharL) :: StateT BSL.ByteString Maybe Char\nrCharL = StateT BSL.uncons\nIL(rCharS) :: StateT BS.ByteString Maybe Char\nrCharS = StateT BS.uncons\nIL(dropSpecialL) :: (MonadState BSL.ByteString m) => m ()\ndropSpecialL = modify $ BSL.dropWhile (<'!')\nIL(dropSpecialS) :: (MonadState BS.ByteString m) => m ()\ndropSpecialS = modify $ BS.dropWhile (<'!')\nIL(skipSpecialL) :: (MonadState BSL.ByteString m) => m a -> m a\nskipSpecialL = (dropSpecialL *>)\nIL(skipSpecialS) :: (MonadState BS.ByteString m) => m a -> m a\nskipSpecialS = (dropSpecialS *>)\n\nIL(linToMat) :: (VG.Vector v a) => Int -> Int -> v a -> V.Vector (v a)\nlinToMat h w lvec = vEvalElemsId $ V.generate h (\\i -> VG.slice (i*w) w lvec)\n\nIL(mLinToMat) :: (VGM.MVector v a) => Int -> Int -> v s a -> V.Vector (v s a)\nmLinToMat h w lvec = vEvalElemsId $ V.generate h (\\i -> VGM.slice (i*w) w lvec)\n  \nIL(unsafeAddrToSVec) :: Int -> Addr# -> VS.Vector Word8\nunsafeAddrToSVec n addr\n  = (`VS.unsafeFromForeignPtr0` n)\n    $ unsafeDupablePerformIO\n    $ newForeignPtr_ $ Ptr addr\n\nIL(vEvalElemsId) :: (VG.Vector v a) => v a -> v a\nvEvalElemsId = vMapFoldl (\\ !_ !x -> (x,())) ()\n\nIL(vEvalElems) :: (VG.Vector v a) => v a -> ()\nvEvalElems = VG.foldl' (\\ !_ !_ -> ()) () \n\nIL(vMapFoldl) :: (VG.Vector v b, VG.Vector v c) =>\n  (a -> b -> (c,a)) -> a -> v b -> v c\nvMapFoldl f a\n  = VG.unstream . VFB.inplace (streamMapFoldl f a) id . VG.stream\n\nstreamMapFoldl :: (Functor m) =>\n  (a -> b -> (c,a)) -> a -> VFSM.Stream m b -> VFSM.Stream m c\n{-# INLINE_FUSED streamMapFoldl #-}\nstreamMapFoldl f a (VFSM.Stream step s) = VFSM.Stream step1 (a,s)\n  where\n    {-# INLINE_INNER step1 #-}\n    step1 (a0,s0) =  (<$> step s0) $ \\r -> case r of\n      VFSM.Yield b s1 -> case f a0 b of (c,a1) -> VFSM.Yield c (a1,s1)\n      VFSM.Skip    s1 -> VFSM.Skip (a0,s1)\n      VFSM.Done       -> VFSM.Done\n\nIL(svecToBS) :: VS.Vector Word8 -> BS.ByteString\nsvecToBS vec = BSU.fromForeignPtr ptr 0 len\n  where (ptr, len) = VS.unsafeToForeignPtr0 vec\n\n\nunlessM, whenM :: (Monad m) => m Bool -> m () -> m ()\nIL(whenM) = (. flip when) . (>>=)\nIL(unlessM) = (. flip unless) . (>>=)\n\nIL(wrA) = A.writeArray\nIL(rdA) = A.readArray\nIL(mdA) = \\arr f !i -> do\n  ai <- rdA arr i\n  let fai = f ai \n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE mdA' #-}\nmdA' = \\arr f !i -> do\n  !ai <- rdA arr i\n  let !fai = f ai\n  wrA arr i fai\n  return (ai,fai)\nIL(swapA) = \\arr !i !j -> do\n  ai <- rdA arr i\n  wrA arr i =<< rdA arr j\n  wrA arr j ai\n\n#define D(f,r,d)\\\n  IL(f) :: Integral a=>a->d; f=fromIntegral;\\\n  IL(r) :: String->d; r=read\n#define C(f,r,g,h,d) D(f,r,d);\\\n  g,h :: RealFrac a=>a->d; IL(g)=floor; IL(h)=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n#define TS(f,a,m,init)\\\n  IL(f) :: forall e i s. (C(a,m) A.Ix i) => (i,i) -> init m (a i e); f\n#define N(f,g,h,a,m)\\\n  TS(f,a,m,e->)=A.newArray;\\\n  TS(g,a,m,)=A.newArray_;\\\n  TS(h,a,m,[e]->)=A.newListArray\n#define C(a,m)\nN(newIOA,newIOA_,newIOAL,IOArray,IO)\nN(newSTA,newSTA_,newSTAL,STArray s,ST s)\n#undef C\n#define C(a,m) MArray (a) e (m), \nN(newIOUA,newIOUA_,newIOUAL,IOUArray,IO)\nN(newSTUA,newSTUA_,newSTUAL,STUArray s,ST s)\n#undef C\n#undef N\n#undef TS\n\n#undef IL\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs, PatternGuards, MagicHash, UnboxedTuples,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns, PolyKinds,\n  TypeFamilies, OverloadedStrings, FlexibleInstances, UndecidableInstances,\n  DefaultSignatures, GeneralizedNewtypeDeriving, StandaloneDeriving,\n  DeriveGeneric, DeriveFunctor, DeriveDataTypeable, DeriveFoldable,\n  DeriveTraversable, DeriveDataTypeable, FlexibleInstances,\n  MultiParamTypeClasses #-}\n{-# OPTIONS_GHC -O2 #-}\n\n#define PHASE_FUSED [1]\n#define PHASE_INNER [0]\n#define INLINE_FUSED INLINE PHASE_FUSED\n#define INLINE_INNER INLINE PHASE_INNER\n\nimport Prelude\nimport Data.Bits\nimport Data.List\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Ratio\nimport Data.Function\nimport Data.STRef\nimport Data.IORef\nimport Data.Monoid\nimport Data.Functor\nimport Data.Functor.Identity\nimport Data.Data\nimport Data.Typeable\nimport GHC.Generics\nimport System.IO\nimport System.IO.Unsafe (unsafeDupablePerformIO, unsafePerformIO)\nimport Control.Arrow\nimport Control.Applicative\nimport Control.Monad\nimport Control.Monad.Primitive\nimport Control.Monad.State.Strict\nimport Control.Monad.ST\nimport Control.Monad.ST.Lazy (strictToLazyST, lazyToStrictST)\nimport qualified Control.Monad.ST.Lazy as STL\n-- import Control.Monad.ST.Safe\nimport Control.DeepSeq\nimport Data.Coerce\nimport qualified Data.ByteString as BSW\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Lazy as BSLW\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport qualified Data.ByteString.Builder as BSB\nimport qualified Data.ByteString.Unsafe as BSU\nimport qualified Data.ByteString.Internal as BSU\nimport Data.IntMap (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as VM\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport qualified Data.Vector.Storable as VS\nimport qualified Data.Vector.Storable.Mutable as VSM\nimport qualified Data.Vector.Primitive as VP\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic as VG\nimport qualified Data.Vector.Generic.Mutable as VGM\nimport qualified Data.Vector.Fusion.Bundle.Monadic as VFBM\nimport qualified Data.Vector.Fusion.Bundle as VFB\nimport qualified Data.Vector.Fusion.Stream.Monadic as VFSM\nimport qualified Data.Vector.Fusion.Bundle.Size as VFBS\nimport qualified Data.Vector.Fusion.Util as VFU\nimport qualified Data.Attoparsec.ByteString.Char8 as Atto\nimport Debug.Trace\nimport Unsafe.Coerce\nimport Foreign.ForeignPtr\nimport System.Exit\nimport GHC.Exts (build, Int(..), Int#,\n                 (+#), (*#), (-#), (<#), (>=#), (==#), quotRemInt#,\n                 remInt#, uncheckedIShiftRL#, andI#, orI#,\n                isTrue#, Addr#, Ptr(..))\n\nmakeCurve :: [(Int,Bool)] -> [(Int,Int)]\nmakeCurve xs = tail $ go (-1) coords\n  where\n    connect x y | x < y = map (,0) [x..y]\n                | otherwise = map (,0) [x,x-1..y]\n    go i ((x,y):ps)\n      | i == x    = (y,1):go y ps\n      | otherwise = connect i x ++ (x,1):(y,1): go y ps\n    go i [] = connect i 0\n    coords = map (\\(x,t) -> if t then (x,x+1) else (x+1,x)) xs \n\nmult :: [(Int,Bool)] -> [(Int,Bool)] -> [(Int,Bool)]\nmult = (++)\n\ninv :: [(Int,Bool)] -> [(Int,Bool)]\ninv = reverse . map (\\(i,b) -> (i,not b))\n\ncommut :: [(Int,Bool)] -> [(Int,Bool)] -> [(Int,Bool)]\ncommut x y = mult x $ mult y $ mult (inv x) (inv y)\n\nsingle :: Int -> [(Int,Bool)]\nsingle = (:[]) . (,True)\n\nmakeCommut :: Int -> [(Int,Bool)]\nmakeCommut u | popCnt == 0 = []\n             | otherwise = go popCnt $ filter (testBit u) [0..7]\n  where\n    popCnt = popCount u\n    go 1 (x:_) = [(x,True)]\n    go !pc xs = commut (go dv ys) (go (pc-dv) zs)\n      where\n        dv = pc `shiftR` 1\n        (ys,zs) = splitAt dv xs\n\nmain :: IO ()\nmain = do\n  n <- readInt <$> getLine\n  xs <- getVecULn (bit n)\n        $ ((.) (1-) $ subtract $ toW8 $ ord '0') <$> StateT BSW.uncons\n  dp <- VU.unsafeThaw xs\n  forM_ [0..bit n - 1] $ \\ !i -> do\n    cur <- VUM.unsafeRead dp i\n    when (cur == 1) $ do\n      forM_ (map (i.|.) $ filter ((==0).(.&.i)) [0..bit n - 1]) $ \\ !j -> do\n        nxt <- VUM.unsafeRead dp j\n        if nxt == 0\n          then do putStrLn \"Impossible\"\n                  exitSuccess\n          else VUM.unsafeWrite dp j 2\n      VUM.unsafeWrite dp i 3\n  dp <- VU.unsafeFreeze dp\n  putStrLn \"Possible\"\n  let res = makeCurve $ concatMap makeCommut $ VU.toList $ VU.elemIndices 3 dp\n  print $ length res - 1\n  putStr $ unlines $ map (\\(x,y) -> shows x $ ' ' : show y) res\n  return ()\n\n#define IL(f) {-# INLINE f #-}; f\n\nIL(putBuilder) = BSB.hPutBuilder stdout\n\nprintVecInLines, printVecInSpcSepLn ::\n  (VG.Vector v a, ShowAsBuilder a) => v a -> IO ()\nIL(printVecInLines) = putBuilder . v2BLines\nIL(printVecInSpcSepLn) = putBuilder . v2BSpcSepLn\n\nclass ShowAsBuilder a where\n  showAsBuilder :: a -> BSB.Builder\n  default showAsBuilder :: (Show a) => a -> BSB.Builder\n  IL(showAsBuilder) = BSB.string8 . show\n\n-- Inconsistent with show\ninstance (ShowAsBuilder a, VG.Vector v a) => ShowAsBuilder (v a) where\n  IL(showAsBuilder) = v2BSpcSep\n\n#define INS(t,f) instance ShowAsBuilder t where { IL(showAsBuilder)=f }\nINS(Int,BSB.intDec)\nINS(Int8,BSB.int8Dec)\nINS(Int16,BSB.int16Dec)\nINS(Int32,BSB.int32Dec)\nINS(Int64,BSB.int64Dec)\nINS(Word,BSB.wordDec)\nINS(Word8,BSB.word8Dec)\nINS(Word16,BSB.word16Dec)\nINS(Word32,BSB.word32Dec)\nINS(Word64,BSB.word64Dec)\nINS(Integer,BSB.integerDec)\nINS(Float,BSB.floatDec)\nINS(Double,BSB.doubleDec)\n-- INS(String,BSB.string8) -- Inconsistent with Show\n-- INS(BS.ByteString,BSB.byteString) -- Inconsistent with Show\n-- INS(BSL.ByteString,BSB.lazyByteString) -- Inconsisitent with Show\n#undef INS\n\n-- Inconsistent with Show\ninstance (ShowAsBuilder a, ShowAsBuilder b) => ShowAsBuilder (a,b) where\n  IL(showAsBuilder) = showTupAsBuilder\ninstance (ShowAsBuilder a, ShowAsBuilder b, ShowAsBuilder c) =>\n  ShowAsBuilder (a,b,c) where\n  IL(showAsBuilder) = showTup3AsBuilder\ninstance (ShowAsBuilder a, ShowAsBuilder b, ShowAsBuilder c, ShowAsBuilder d) =>\n  ShowAsBuilder (a,b,c,d) where\n  IL(showAsBuilder) = showTup4AsBuilder\n\nIL(showTupAsBuilderWith)\n  :: (a -> BSB.Builder) -> (b -> BSB.Builder) -> (a,b) -> BSB.Builder\nshowTupAsBuilderWith showA showB\n  = \\(a,b) -> (showA a <>) $ BSB.char7 ' ' <> showB b\nIL(showTupAsBuilder) :: (ShowAsBuilder a, ShowAsBuilder b)\n  => (a,b) -> BSB.Builder\nshowTupAsBuilder = showTupAsBuilderWith showAsBuilder showAsBuilder \n\nIL(showTup3AsBuilderWith) :: (a -> BSB.Builder) -> (b -> BSB.Builder) ->\n  (c -> BSB.Builder) -> (a,b,c) -> BSB.Builder\nshowTup3AsBuilderWith showA showB showC\n  = \\(a,b,c) -> (showA a <>) $ (BSB.char7 ' ' <>) $ (showB b <>)\n                $ (BSB.char7 ' ' <>) $ showC c\nIL(showTup3AsBuilder) :: (ShowAsBuilder a, ShowAsBuilder b, ShowAsBuilder c)\n  => (a,b,c) -> BSB.Builder\nshowTup3AsBuilder\n  = showTup3AsBuilderWith showAsBuilder showAsBuilder showAsBuilder\n\nIL(showTup4AsBuilderWith) :: (a -> BSB.Builder) -> (b -> BSB.Builder) ->\n  (c -> BSB.Builder) -> (d -> BSB.Builder) -> (a,b,c,d) -> BSB.Builder\nshowTup4AsBuilderWith showA showB showC showD\n  = \\(a,b,c,d) -> (showA a <>) $ (BSB.char7 ' ' <>)\n                  $ showTup3AsBuilderWith showB showC showD (b,c,d)\nIL(showTup4AsBuilder) ::\n  (ShowAsBuilder a, ShowAsBuilder b, ShowAsBuilder c, ShowAsBuilder d) =>\n  (a,b,c,d) -> BSB.Builder\nshowTup4AsBuilder = showTup4AsBuilderWith showAsBuilder showAsBuilder\n                    showAsBuilder showAsBuilder\n\nv2BSpcSepLn, v2BSpcSep, v2BConcat, v2BLines ::\n  (VG.Vector v a, ShowAsBuilder a)\n  => v a -> BSB.Builder\nIL(v2BSpcSepLn) = v2BSpcSepLnWith showAsBuilder\nIL(v2BSpcSep) = v2BSpcSepWith showAsBuilder\nIL(v2BConcat) = v2BConcatWith showAsBuilder\nIL(v2BLines) = v2BLinesWith showAsBuilder\n\n\nv2BSpcSepLnWith, v2BSpcSepWith, v2BConcatWith, v2BLinesWith ::\n  (VG.Vector v a)\n  => (a -> BSB.Builder) -- ^ show function\n  -> v a -> BSB.Builder\nIL(v2BSpcSepLnWith) = v2BSpcSepPostfWith $ BS.singleton '\\n'\nIL(v2BSpcSepWith) = v2BSpcSepPostfWith BS.empty\nIL(v2BConcatWith) showFct = VG.foldr ((<>) . showFct) mempty\nIL(v2BLinesWith) showFct\n  = VG.foldr (\\ a -> (showFct a <>) . (BSB.char7 '\\n' <>)) mempty\n\n\nv2BSpcSepPostf :: (VG.Vector v a, ShowAsBuilder a)\n  => BS.ByteString -- ^ postfix\n  -> v a -> BSB.Builder\nIL(v2BSpcSepPostf) = (`v2BSpcSepPostfWith` showAsBuilder)\n\nv2BSpcSepPostfWith :: (VG.Vector v a)\n  => BS.ByteString -- ^ postfix\n  -> (a -> BSB.Builder) -- ^ show function\n  -> v a -> BSB.Builder\nIL(v2BSpcSepPostfWith) = vecToBuilder BS.empty $ BS.singleton ' '\n\nIL(vecToBuilder) :: (VG.Vector v a)\n  => BS.ByteString -- ^ prefix\n  -> BS.ByteString -- ^ separator\n  -> BS.ByteString -- ^ postfix\n  -> (a -> BSB.Builder) -- ^ show function\n  -> v a -> BSB.Builder\nvecToBuilder !prefix !separator !postfix\n  = vecToBuilder_ (BSB.byteString prefix)\n                  (BSB.byteString separator)\n                  (BSB.byteString postfix)\n\n\nIL(vecToBuilder_) :: (VG.Vector v a)\n  => BSB.Builder -- ^ prefix\n  -> BSB.Builder -- ^ separator\n  -> BSB.Builder -- ^ postfix\n  -> (a -> BSB.Builder) -- ^ show function\n  -> v a -> BSB.Builder\nvecToBuilder_ !prefix !separator !postfix showFct = \\vec -> prefix <>\n  VG.foldr\n  (\\ a rest !prefx -> prefx <> (showFct a <> rest separator))\n  (const postfix) vec mempty\n\nIL(evalVals) :: [a] -> [a]\nevalVals xs = build $ \\c n -> foldr (c $!) n xs\nIL(forceVals) :: (NFData a) => [a] -> [a]\nforceVals xs = build $ \\c n -> foldr (c $!!) n xs\n\nIL(readLnWith) :: StateT BS.ByteString Maybe a -> IO a\nreadLnWith parser = fromJust . evalStateT parser <$> BS.getLine\nIL(readContentWith) :: StateT BSL.ByteString Maybe a -> IO a\nreadContentWith parser = fromJust . evalStateT parser <$> BSL.getContents\n\nIL(getVecGLn) :: (VG.Vector v a) =>\n  Int -> StateT BS.ByteString Maybe a -> IO (v a)\ngetVecGLn n s = VG.unfoldrN n (runStateT s) <$> BS.getLine\nIL(getVecGRest) :: (VG.Vector v a) =>\n  Int -> StateT BSL.ByteString Maybe a -> IO (v a)\ngetVecGRest n s = VG.unfoldrN n (runStateT s) <$> BSL.getContents\nIL(getVecLn) :: Int -> StateT BS.ByteString Maybe a -> IO (V.Vector a)\ngetVecLn = getVecGLn\nIL(getVecRest) :: Int -> StateT BSL.ByteString Maybe a -> IO (V.Vector a)\ngetVecRest = getVecGRest\nIL(getVecULn) :: (VU.Unbox a) =>\n  Int -> StateT BS.ByteString Maybe a -> IO (VU.Vector a)\ngetVecULn = getVecGLn\nIL(getVecURest) :: (VU.Unbox a) =>\n  Int -> StateT BSL.ByteString Maybe a -> IO (VU.Vector a)\ngetVecURest = getVecGRest\n\nIL(rIntL) :: StateT BSL.ByteString Maybe Int\nrIntL = skipSpecialL $ StateT BSL.readInt\nIL(rIntS) :: StateT BS.ByteString Maybe Int\nrIntS = skipSpecialS $ StateT BS.readInt\nIL(rStrL) :: (MonadState BSL.ByteString m) => m BS.ByteString\nrStrL = skipSpecialL $ BSL.toStrict <$> state (BSL.span (>='!'))\nIL(rStrS) :: (MonadState BS.ByteString m) => m BS.ByteString\nrStrS = skipSpecialS $ state $ BS.span (>='!')\nIL(rCharL) :: StateT BSL.ByteString Maybe Char\nrCharL = StateT BSL.uncons\nIL(rCharS) :: StateT BS.ByteString Maybe Char\nrCharS = StateT BS.uncons\nIL(dropSpecialL) :: (MonadState BSL.ByteString m) => m ()\ndropSpecialL = modify $ BSL.dropWhile (<'!')\nIL(dropSpecialS) :: (MonadState BS.ByteString m) => m ()\ndropSpecialS = modify $ BS.dropWhile (<'!')\nIL(skipSpecialL) :: (MonadState BSL.ByteString m) => m a -> m a\nskipSpecialL = (dropSpecialL *>)\nIL(skipSpecialS) :: (MonadState BS.ByteString m) => m a -> m a\nskipSpecialS = (dropSpecialS *>)\n\nIL(linToMat) :: (VG.Vector v a) => Int -> Int -> v a -> V.Vector (v a)\nlinToMat h w lvec = vEvalElemsId $ V.generate h (\\i -> VG.slice (i*w) w lvec)\n\nIL(mLinToMat) :: (VGM.MVector v a) => Int -> Int -> v s a -> V.Vector (v s a)\nmLinToMat h w lvec = vEvalElemsId $ V.generate h (\\i -> VGM.slice (i*w) w lvec)\n  \nIL(unsafeAddrToSVec) :: Int -> Addr# -> VS.Vector Word8\nunsafeAddrToSVec n addr\n  = (`VS.unsafeFromForeignPtr0` n)\n    $ unsafeDupablePerformIO\n    $ newForeignPtr_ $ Ptr addr\n\nIL(vEvalElemsId) :: (VG.Vector v a) => v a -> v a\nvEvalElemsId = vMapFoldl (\\ !_ !x -> (x,())) ()\n\nIL(vEvalElems) :: (VG.Vector v a) => v a -> ()\nvEvalElems = VG.foldl' (\\ !_ !_ -> ()) () \n\nIL(vMapFoldl) :: (VG.Vector v b, VG.Vector v c) =>\n  (a -> b -> (c,a)) -> a -> v b -> v c\nvMapFoldl f a\n  = VG.unstream . VFB.inplace (streamMapFoldl f a) id . VG.stream\n\nstreamMapFoldl :: (Functor m) =>\n  (a -> b -> (c,a)) -> a -> VFSM.Stream m b -> VFSM.Stream m c\n{-# INLINE_FUSED streamMapFoldl #-}\nstreamMapFoldl f a (VFSM.Stream step s) = VFSM.Stream step1 (a,s)\n  where\n    {-# INLINE_INNER step1 #-}\n    step1 (a0,s0) =  (<$> step s0) $ \\r -> case r of\n      VFSM.Yield b s1 -> case f a0 b of (c,a1) -> VFSM.Yield c (a1,s1)\n      VFSM.Skip    s1 -> VFSM.Skip (a0,s1)\n      VFSM.Done       -> VFSM.Done\n\nIL(svecToBS) :: VS.Vector Word8 -> BS.ByteString\nsvecToBS vec = BSU.fromForeignPtr ptr 0 len\n  where (ptr, len) = VS.unsafeToForeignPtr0 vec\n\n\nunlessM, whenM :: (Monad m) => m Bool -> m () -> m ()\nIL(whenM) = (. flip when) . (>>=)\nIL(unlessM) = (. flip unless) . (>>=)\n\nIL(wrA) = A.writeArray\nIL(rdA) = A.readArray\nIL(mdA) = \\arr f !i -> do\n  ai <- rdA arr i\n  let fai = f ai \n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE mdA' #-}\nmdA' = \\arr f !i -> do\n  !ai <- rdA arr i\n  let !fai = f ai\n  wrA arr i fai\n  return (ai,fai)\nIL(swapA) = \\arr !i !j -> do\n  ai <- rdA arr i\n  wrA arr i =<< rdA arr j\n  wrA arr j ai\n\n#define D(f,r,d)\\\n  IL(f) :: Integral a=>a->d; f=fromIntegral;\\\n  IL(r) :: String->d; r=read\n#define C(f,r,g,h,d) D(f,r,d);\\\n  g,h :: RealFrac a=>a->d; IL(g)=floor; IL(h)=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n#define TS(f,a,m,init)\\\n  IL(f) :: forall e i s. (C(a,m) A.Ix i) => (i,i) -> init m (a i e); f\n#define N(f,g,h,a,m)\\\n  TS(f,a,m,e->)=A.newArray;\\\n  TS(g,a,m,)=A.newArray_;\\\n  TS(h,a,m,[e]->)=A.newListArray\n#define C(a,m)\nN(newIOA,newIOA_,newIOAL,IOArray,IO)\nN(newSTA,newSTA_,newSTAL,STArray s,ST s)\n#undef C\n#define C(a,m) MArray (a) e (m), \nN(newIOUA,newIOUA_,newIOUAL,IOUArray,IO)\nN(newSTUA,newSTUA_,newSTUAL,STUArray s,ST s)\n#undef C\n#undef N\n#undef TS\n\n#undef IL\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs, PatternGuards, MagicHash, UnboxedTuples,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns, PolyKinds,\n  TypeFamilies, OverloadedStrings, FlexibleInstances, UndecidableInstances,\n  DefaultSignatures, GeneralizedNewtypeDeriving, StandaloneDeriving,\n  DeriveGeneric, DeriveFunctor, DeriveDataTypeable, DeriveFoldable,\n  DeriveTraversable, DeriveDataTypeable, FlexibleInstances,\n  MultiParamTypeClasses #-}\n{-# OPTIONS_GHC -O2 #-}\n\n#define PHASE_FUSED [1]\n#define PHASE_INNER [0]\n#define INLINE_FUSED INLINE PHASE_FUSED\n#define INLINE_INNER INLINE PHASE_INNER\n\nimport Prelude\nimport Data.Bits\nimport Data.List\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Ratio\nimport Data.Function\nimport Data.STRef\nimport Data.IORef\nimport Data.Monoid\nimport Data.Functor\nimport Data.Functor.Identity\nimport Data.Bifunctor\nimport Data.Data\nimport Data.Typeable\nimport GHC.Generics\nimport System.IO\nimport System.IO.Unsafe (unsafeDupablePerformIO, unsafePerformIO)\nimport qualified Control.Arrow as Arr\nimport Control.Arrow hiding (first,second)\nimport Control.Applicative\nimport Control.Monad\nimport Control.Monad.Primitive\nimport Control.Monad.State.Strict\nimport Control.Monad.ST\nimport Control.Monad.ST.Lazy (strictToLazyST, lazyToStrictST)\nimport qualified Control.Monad.ST.Lazy as STL\n-- import Control.Monad.ST.Safe\nimport Control.DeepSeq\nimport Data.Coerce\nimport qualified Data.ByteString as BSW\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Lazy as BSLW\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport qualified Data.ByteString.Builder as BSB\nimport qualified Data.ByteString.Unsafe as BSU\nimport qualified Data.ByteString.Internal as BSU\nimport Data.IntMap (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as VM\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport qualified Data.Vector.Storable as VS\nimport qualified Data.Vector.Storable.Mutable as VSM\nimport qualified Data.Vector.Primitive as VP\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic as VG\nimport qualified Data.Vector.Generic.Mutable as VGM\nimport qualified Data.Vector.Fusion.Bundle.Monadic as VFBM\nimport qualified Data.Vector.Fusion.Bundle as VFB\nimport qualified Data.Vector.Fusion.Stream.Monadic as VFSM\nimport qualified Data.Vector.Fusion.Bundle.Size as VFBS\nimport qualified Data.Vector.Fusion.Util as VFU\nimport qualified Data.Attoparsec.ByteString.Char8 as Atto\nimport Debug.Trace\nimport Unsafe.Coerce\nimport Foreign.ForeignPtr\nimport System.Exit\nimport GHC.Exts (build, Int(..), Int#,\n                 (+#), (*#), (-#), (<#), (>=#), (==#), quotRemInt#,\n                 remInt#, uncheckedIShiftRL#, andI#, orI#,\n                isTrue#, Addr#, Ptr(..))\n\nmakeCurve :: [(Int,Bool)] -> [(Int,Int)]\nmakeCurve xs\n  = case map (\\(x,t) -> if t then (x,x+1) else (x+1,x)) xs of\n      [] -> [(0,0)]\n      (u,v):ps -> (u,0) : (u,1) : (v,1) : go u v ps\n  where\n    connect x y | x < y = map (,0) [x..y]\n                | otherwise = map (,0) [x,x-1..y]\n    go !o = go1\n      where\n        go1 !i ((x,y):ps)\n          | i == x    =                        (y,1) : go1 y ps\n          | otherwise = connect i x ++ (x,1) : (y,1) : go1 y ps\n        go1 !i []     = connect i o\n\nmult :: [(Int,Bool)] -> [(Int,Bool)] -> [(Int,Bool)]\nmult = (++)\n \ninv :: [(Int,Bool)] -> [(Int,Bool)]\ninv = reverse . map (second not)\n\ncommut :: [(Int,Bool)] -> [(Int,Bool)] -> [(Int,Bool)]\ncommut x y = mult x $ mult y $ mult (inv x) (inv y)\n\nsingle :: Int -> [(Int,Bool)]\nsingle = (:[]) . (,True)\n\nmakeCommut :: Int -> [(Int,Bool)]\nmakeCommut 0 = []\nmakeCommut u = evalState (go $ popCount u) u\n  where\n    go 1 = state $ \\ !s -> (single $ countTrailingZeros s, xor s $ s .&. (-s))\n    go !pc = liftA2 commut (go dv) $ go (pc-dv)\n      where dv = pc `shiftR` 1\n\nmain :: IO ()\nmain = do\n  n <- readInt <$> getLine\n  xs <- getVecULn (bit n) $ (toW8 (ord '1') -) <$> StateT BSW.uncons\n  dp <- VU.unsafeThaw xs\n  forM_ [0..bit n - 1] $ \\ !i -> do\n    cur <- VUM.unsafeRead dp i\n    when (cur == 1) $ do\n      VUM.unsafeWrite dp i 3\n      forM_ (filter ((==i) . (.&.i)) [i+1..bit n - 1]) $ \\ !j -> do\n        nxt <- VUM.unsafeRead dp j\n        case nxt of\n          0 -> do putStrLn \"Impossible\"\n                  exitSuccess\n          1 -> VUM.unsafeWrite dp j 2\n          2 -> return ()\n          _ -> do hPutStrLn stderr\n                    $ \"Error! Invalid input? occurred: \" ++ show nxt\n                  exitFailure\n  dp <- VU.unsafeFreeze dp\n  putStrLn \"Possible\"\n  let res = makeCurve $ concatMap makeCommut $ VU.toList $ VU.elemIndices 3 dp\n  print $ length res - 1\n  putStr $ unlines $ map (\\(x,y) -> shows x $ ' ' : show y) res\n  return ()\n\n#define IL(f) {-# INLINE f #-}; f\n\nIL(putBuilder) = BSB.hPutBuilder stdout\n\nprintVecInLines, printVecInSpcSepLn ::\n  (VG.Vector v a, ShowAsBuilder a) => v a -> IO ()\nIL(printVecInLines) = putBuilder . v2BLines\nIL(printVecInSpcSepLn) = putBuilder . v2BSpcSepLn\n\nclass ShowAsBuilder a where\n  showAsBuilder :: a -> BSB.Builder\n  default showAsBuilder :: (Show a) => a -> BSB.Builder\n  IL(showAsBuilder) = BSB.string8 . show\n\n-- Inconsistent with show\ninstance (ShowAsBuilder a, VG.Vector v a) => ShowAsBuilder (v a) where\n  IL(showAsBuilder) = v2BSpcSep\n\n#define INS(t,f) instance ShowAsBuilder t where { IL(showAsBuilder)=f }\nINS(Int,BSB.intDec)\nINS(Int8,BSB.int8Dec)\nINS(Int16,BSB.int16Dec)\nINS(Int32,BSB.int32Dec)\nINS(Int64,BSB.int64Dec)\nINS(Word,BSB.wordDec)\nINS(Word8,BSB.word8Dec)\nINS(Word16,BSB.word16Dec)\nINS(Word32,BSB.word32Dec)\nINS(Word64,BSB.word64Dec)\nINS(Integer,BSB.integerDec)\nINS(Float,BSB.floatDec)\nINS(Double,BSB.doubleDec)\n-- INS(String,BSB.string8) -- Inconsistent with Show\n-- INS(BS.ByteString,BSB.byteString) -- Inconsistent with Show\n-- INS(BSL.ByteString,BSB.lazyByteString) -- Inconsisitent with Show\n#undef INS\n\n-- Inconsistent with Show\ninstance (ShowAsBuilder a, ShowAsBuilder b) => ShowAsBuilder (a,b) where\n  IL(showAsBuilder) = showTupAsBuilder\ninstance (ShowAsBuilder a, ShowAsBuilder b, ShowAsBuilder c) =>\n  ShowAsBuilder (a,b,c) where\n  IL(showAsBuilder) = showTup3AsBuilder\ninstance (ShowAsBuilder a, ShowAsBuilder b, ShowAsBuilder c, ShowAsBuilder d) =>\n  ShowAsBuilder (a,b,c,d) where\n  IL(showAsBuilder) = showTup4AsBuilder\n\nIL(showTupAsBuilderWith)\n  :: (a -> BSB.Builder) -> (b -> BSB.Builder) -> (a,b) -> BSB.Builder\nshowTupAsBuilderWith showA showB\n  = \\(a,b) -> (showA a <>) $ BSB.char7 ' ' <> showB b\nIL(showTupAsBuilder) :: (ShowAsBuilder a, ShowAsBuilder b)\n  => (a,b) -> BSB.Builder\nshowTupAsBuilder = showTupAsBuilderWith showAsBuilder showAsBuilder \n\nIL(showTup3AsBuilderWith) :: (a -> BSB.Builder) -> (b -> BSB.Builder) ->\n  (c -> BSB.Builder) -> (a,b,c) -> BSB.Builder\nshowTup3AsBuilderWith showA showB showC\n  = \\(a,b,c) -> (showA a <>) $ (BSB.char7 ' ' <>) $ (showB b <>)\n                $ (BSB.char7 ' ' <>) $ showC c\nIL(showTup3AsBuilder) :: (ShowAsBuilder a, ShowAsBuilder b, ShowAsBuilder c)\n  => (a,b,c) -> BSB.Builder\nshowTup3AsBuilder\n  = showTup3AsBuilderWith showAsBuilder showAsBuilder showAsBuilder\n\nIL(showTup4AsBuilderWith) :: (a -> BSB.Builder) -> (b -> BSB.Builder) ->\n  (c -> BSB.Builder) -> (d -> BSB.Builder) -> (a,b,c,d) -> BSB.Builder\nshowTup4AsBuilderWith showA showB showC showD\n  = \\(a,b,c,d) -> (showA a <>) $ (BSB.char7 ' ' <>)\n                  $ showTup3AsBuilderWith showB showC showD (b,c,d)\nIL(showTup4AsBuilder) ::\n  (ShowAsBuilder a, ShowAsBuilder b, ShowAsBuilder c, ShowAsBuilder d) =>\n  (a,b,c,d) -> BSB.Builder\nshowTup4AsBuilder = showTup4AsBuilderWith showAsBuilder showAsBuilder\n                    showAsBuilder showAsBuilder\n\nv2BSpcSepLn, v2BSpcSep, v2BConcat, v2BLines ::\n  (VG.Vector v a, ShowAsBuilder a)\n  => v a -> BSB.Builder\nIL(v2BSpcSepLn) = v2BSpcSepLnWith showAsBuilder\nIL(v2BSpcSep) = v2BSpcSepWith showAsBuilder\nIL(v2BConcat) = v2BConcatWith showAsBuilder\nIL(v2BLines) = v2BLinesWith showAsBuilder\n\n\nv2BSpcSepLnWith, v2BSpcSepWith, v2BConcatWith, v2BLinesWith ::\n  (VG.Vector v a)\n  => (a -> BSB.Builder) -- ^ show function\n  -> v a -> BSB.Builder\nIL(v2BSpcSepLnWith) = v2BSpcSepPostfWith $ BS.singleton '\\n'\nIL(v2BSpcSepWith) = v2BSpcSepPostfWith BS.empty\nIL(v2BConcatWith) showFct = VG.foldr ((<>) . showFct) mempty\nIL(v2BLinesWith) showFct\n  = VG.foldr (\\ a -> (showFct a <>) . (BSB.char7 '\\n' <>)) mempty\n\n\nv2BSpcSepPostf :: (VG.Vector v a, ShowAsBuilder a)\n  => BS.ByteString -- ^ postfix\n  -> v a -> BSB.Builder\nIL(v2BSpcSepPostf) = (`v2BSpcSepPostfWith` showAsBuilder)\n\nv2BSpcSepPostfWith :: (VG.Vector v a)\n  => BS.ByteString -- ^ postfix\n  -> (a -> BSB.Builder) -- ^ show function\n  -> v a -> BSB.Builder\nIL(v2BSpcSepPostfWith) = vecToBuilder BS.empty $ BS.singleton ' '\n\nIL(vecToBuilder) :: (VG.Vector v a)\n  => BS.ByteString -- ^ prefix\n  -> BS.ByteString -- ^ separator\n  -> BS.ByteString -- ^ postfix\n  -> (a -> BSB.Builder) -- ^ show function\n  -> v a -> BSB.Builder\nvecToBuilder !prefix !separator !postfix\n  = vecToBuilder_ (BSB.byteString prefix)\n                  (BSB.byteString separator)\n                  (BSB.byteString postfix)\n\n\nIL(vecToBuilder_) :: (VG.Vector v a)\n  => BSB.Builder -- ^ prefix\n  -> BSB.Builder -- ^ separator\n  -> BSB.Builder -- ^ postfix\n  -> (a -> BSB.Builder) -- ^ show function\n  -> v a -> BSB.Builder\nvecToBuilder_ !prefix !separator !postfix showFct = \\vec -> prefix <>\n  VG.foldr\n  (\\ a rest !prefx -> prefx <> (showFct a <> rest separator))\n  (const postfix) vec mempty\n\nIL(evalVals) :: [a] -> [a]\nevalVals xs = build $ \\c n -> foldr (c $!) n xs\nIL(forceVals) :: (NFData a) => [a] -> [a]\nforceVals xs = build $ \\c n -> foldr (c $!!) n xs\n\nIL(readLnWith) :: StateT BS.ByteString Maybe a -> IO a\nreadLnWith parser = fromJust . evalStateT parser <$> BS.getLine\nIL(readContentWith) :: StateT BSL.ByteString Maybe a -> IO a\nreadContentWith parser = fromJust . evalStateT parser <$> BSL.getContents\n\nIL(getVecGLn) :: (VG.Vector v a) =>\n  Int -> StateT BS.ByteString Maybe a -> IO (v a)\ngetVecGLn n s = VG.unfoldrN n (runStateT s) <$> BS.getLine\nIL(getVecGRest) :: (VG.Vector v a) =>\n  Int -> StateT BSL.ByteString Maybe a -> IO (v a)\ngetVecGRest n s = VG.unfoldrN n (runStateT s) <$> BSL.getContents\nIL(getVecLn) :: Int -> StateT BS.ByteString Maybe a -> IO (V.Vector a)\ngetVecLn = getVecGLn\nIL(getVecRest) :: Int -> StateT BSL.ByteString Maybe a -> IO (V.Vector a)\ngetVecRest = getVecGRest\nIL(getVecULn) :: (VU.Unbox a) =>\n  Int -> StateT BS.ByteString Maybe a -> IO (VU.Vector a)\ngetVecULn = getVecGLn\nIL(getVecURest) :: (VU.Unbox a) =>\n  Int -> StateT BSL.ByteString Maybe a -> IO (VU.Vector a)\ngetVecURest = getVecGRest\n\nIL(rIntL) :: StateT BSL.ByteString Maybe Int\nrIntL = skipSpecialL $ StateT BSL.readInt\nIL(rIntS) :: StateT BS.ByteString Maybe Int\nrIntS = skipSpecialS $ StateT BS.readInt\nIL(rStrL) :: (MonadState BSL.ByteString m) => m BS.ByteString\nrStrL = skipSpecialL $ BSL.toStrict <$> state (BSL.span (>='!'))\nIL(rStrS) :: (MonadState BS.ByteString m) => m BS.ByteString\nrStrS = skipSpecialS $ state $ BS.span (>='!')\nIL(rCharL) :: StateT BSL.ByteString Maybe Char\nrCharL = StateT BSL.uncons\nIL(rCharS) :: StateT BS.ByteString Maybe Char\nrCharS = StateT BS.uncons\nIL(dropSpecialL) :: (MonadState BSL.ByteString m) => m ()\ndropSpecialL = modify $ BSL.dropWhile (<'!')\nIL(dropSpecialS) :: (MonadState BS.ByteString m) => m ()\ndropSpecialS = modify $ BS.dropWhile (<'!')\nIL(skipSpecialL) :: (MonadState BSL.ByteString m) => m a -> m a\nskipSpecialL = (dropSpecialL *>)\nIL(skipSpecialS) :: (MonadState BS.ByteString m) => m a -> m a\nskipSpecialS = (dropSpecialS *>)\n\nIL(linToMat) :: (VG.Vector v a) => Int -> Int -> v a -> V.Vector (v a)\nlinToMat h w lvec = vEvalElemsId $ V.generate h (\\i -> VG.slice (i*w) w lvec)\n\nIL(mLinToMat) :: (VGM.MVector v a) => Int -> Int -> v s a -> V.Vector (v s a)\nmLinToMat h w lvec = vEvalElemsId $ V.generate h (\\i -> VGM.slice (i*w) w lvec)\n  \nIL(unsafeAddrToSVec) :: Int -> Addr# -> VS.Vector Word8\nunsafeAddrToSVec n addr\n  = (`VS.unsafeFromForeignPtr0` n)\n    $ unsafeDupablePerformIO\n    $ newForeignPtr_ $ Ptr addr\n\nIL(vEvalElemsId) :: (VG.Vector v a) => v a -> v a\nvEvalElemsId = vMapFoldl (\\ !_ !x -> (x,())) ()\n\nIL(vEvalElems) :: (VG.Vector v a) => v a -> ()\nvEvalElems = VG.foldl' (\\ !_ !_ -> ()) () \n\nIL(vMapFoldl) :: (VG.Vector v b, VG.Vector v c) =>\n  (a -> b -> (c,a)) -> a -> v b -> v c\nvMapFoldl f a\n  = VG.unstream . VFB.inplace (streamMapFoldl f a) id . VG.stream\n\nstreamMapFoldl :: (Functor m) =>\n  (a -> b -> (c,a)) -> a -> VFSM.Stream m b -> VFSM.Stream m c\n{-# INLINE_FUSED streamMapFoldl #-}\nstreamMapFoldl f a (VFSM.Stream step s) = VFSM.Stream step1 (a,s)\n  where\n    {-# INLINE_INNER step1 #-}\n    step1 (a0,s0) =  (<$> step s0) $ \\r -> case r of\n      VFSM.Yield b s1 -> case f a0 b of (c,a1) -> VFSM.Yield c (a1,s1)\n      VFSM.Skip    s1 -> VFSM.Skip (a0,s1)\n      VFSM.Done       -> VFSM.Done\n\nIL(svecToBS) :: VS.Vector Word8 -> BS.ByteString\nsvecToBS vec = BSU.fromForeignPtr ptr 0 len\n  where (ptr, len) = VS.unsafeToForeignPtr0 vec\n\n\nunlessM, whenM :: (Monad m) => m Bool -> m () -> m ()\nIL(whenM) = (. flip when) . (>>=)\nIL(unlessM) = (. flip unless) . (>>=)\n\nIL(wrA) = A.writeArray\nIL(rdA) = A.readArray\nIL(mdA) = \\arr f !i -> do\n  ai <- rdA arr i\n  let fai = f ai \n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE mdA' #-}\nmdA' = \\arr f !i -> do\n  !ai <- rdA arr i\n  let !fai = f ai\n  wrA arr i fai\n  return (ai,fai)\nIL(swapA) = \\arr !i !j -> do\n  ai <- rdA arr i\n  wrA arr i =<< rdA arr j\n  wrA arr j ai\n\n#define D(f,r,d)\\\n  IL(f) :: Integral a=>a->d; f=fromIntegral;\\\n  IL(r) :: String->d; r=read\n#define C(f,r,g,h,d) D(f,r,d);\\\n  g,h :: RealFrac a=>a->d; IL(g)=floor; IL(h)=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n#define TS(f,a,m,init)\\\n  IL(f) :: forall e i s. (C(a,m) A.Ix i) => (i,i) -> init m (a i e); f\n#define N(f,g,h,a,m)\\\n  TS(f,a,m,e->)=A.newArray;\\\n  TS(g,a,m,)=A.newArray_;\\\n  TS(h,a,m,[e]->)=A.newListArray\n#define C(a,m)\nN(newIOA,newIOA_,newIOAL,IOArray,IO)\nN(newSTA,newSTA_,newSTAL,STArray s,ST s)\n#undef C\n#define C(a,m) MArray (a) e (m), \nN(newIOUA,newIOUA_,newIOUAL,IOUArray,IO)\nN(newSTUA,newSTUA_,newSTUAL,STUArray s,ST s)\n#undef C\n#undef N\n#undef TS\n\n#undef IL\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE\n  ScopedTypeVariables, BangPatterns, TupleSections, ExplicitForAll,\n  LambdaCase, MultiWayIf, Unsafe, RecordWildCards, FlexibleContexts, CPP,\n  NoMonomorphismRestriction, GADTs, PatternGuards, MagicHash, UnboxedTuples,\n  RankNTypes, EmptyDataDecls, EmptyCase, ViewPatterns, PolyKinds,\n  TypeFamilies, OverloadedStrings, FlexibleInstances, UndecidableInstances,\n  DefaultSignatures, GeneralizedNewtypeDeriving, StandaloneDeriving,\n  DeriveGeneric, DeriveFunctor, DeriveDataTypeable, DeriveFoldable,\n  DeriveTraversable, DeriveDataTypeable, FlexibleInstances,\n  MultiParamTypeClasses #-}\n{-# OPTIONS_GHC -O2 #-}\n\n#define PHASE_FUSED [1]\n#define PHASE_INNER [0]\n#define INLINE_FUSED INLINE PHASE_FUSED\n#define INLINE_INNER INLINE PHASE_INNER\n\nimport Prelude\nimport Data.Bits\nimport Data.List\nimport Data.Maybe\nimport Data.Tuple\nimport Data.Ord\nimport Data.Int\nimport Data.Word\nimport Data.Char\nimport Data.Ratio\nimport Data.Function\nimport Data.STRef\nimport Data.IORef\nimport Data.Monoid\nimport Data.Functor\nimport Data.Functor.Identity\nimport Data.Bifunctor\nimport Data.Data\nimport Data.Typeable\nimport GHC.Generics\nimport System.IO\nimport System.IO.Unsafe (unsafeDupablePerformIO, unsafePerformIO)\nimport qualified Control.Arrow as Arr\nimport Control.Arrow hiding (first,second)\nimport Control.Applicative\nimport Control.Monad\nimport Control.Monad.Primitive\nimport Control.Monad.State.Strict\nimport Control.Monad.ST\nimport Control.Monad.ST.Lazy (strictToLazyST, lazyToStrictST)\nimport qualified Control.Monad.ST.Lazy as STL\n-- import Control.Monad.ST.Safe\nimport Control.DeepSeq\nimport Data.Coerce\nimport qualified Data.ByteString as BSW\nimport qualified Data.ByteString.Char8 as BS\nimport qualified Data.ByteString.Lazy as BSLW\nimport qualified Data.ByteString.Lazy.Char8 as BSL\nimport qualified Data.ByteString.Builder as BSB\nimport qualified Data.ByteString.Unsafe as BSU\nimport qualified Data.ByteString.Internal as BSU\nimport Data.IntMap (IntMap)\nimport qualified Data.IntMap.Strict as IMS\nimport qualified Data.IntMap.Lazy as IML\nimport Data.IntSet (IntSet)\nimport qualified Data.IntSet as IS\nimport qualified Data.Sequence as Seq\nimport Data.Sequence (Seq)\nimport qualified Data.Array.IArray as A\nimport qualified Data.Array.MArray.Safe as A\nimport qualified Data.Array.MArray as A\nimport Data.Array (Array)\nimport Data.Array.Unboxed (UArray)\nimport Data.Array.IArray (IArray)\nimport Data.Array.MArray.Safe (MArray)\nimport Data.Array.IO.Safe (IOArray, IOUArray)\nimport Data.Array.ST.Safe (STArray, STUArray, runSTArray, runSTUArray)\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as VM\nimport qualified Data.Vector.Unboxed as VU\nimport qualified Data.Vector.Unboxed.Mutable as VUM\nimport qualified Data.Vector.Storable as VS\nimport qualified Data.Vector.Storable.Mutable as VSM\nimport qualified Data.Vector.Primitive as VP\nimport qualified Data.Vector.Primitive.Mutable as VPM\nimport qualified Data.Vector.Generic as VG\nimport qualified Data.Vector.Generic.Mutable as VGM\nimport qualified Data.Vector.Fusion.Bundle.Monadic as VFBM\nimport qualified Data.Vector.Fusion.Bundle as VFB\nimport qualified Data.Vector.Fusion.Stream.Monadic as VFSM\nimport qualified Data.Vector.Fusion.Bundle.Size as VFBS\nimport qualified Data.Vector.Fusion.Util as VFU\nimport qualified Data.Attoparsec.ByteString.Char8 as Atto\nimport Debug.Trace\nimport Unsafe.Coerce\nimport Foreign.ForeignPtr\nimport System.Exit\nimport GHC.Exts (build, Int(..), Int#,\n                 (+#), (*#), (-#), (<#), (>=#), (==#), quotRemInt#,\n                 remInt#, uncheckedIShiftRL#, andI#, orI#,\n                isTrue#, Addr#, Ptr(..))\n\nmakeCurve :: [(Int,Bool)] -> [(Int,Int)]\nmakeCurve xs\n  = case map (\\(x,t) -> if t then (x,x+1) else (x+1,x)) xs of\n      [] -> [(0,0)]\n      (u,v):ps -> (u,0) : go u u v ps\n  where\n    connect x y | x < y = map (,0) [x..y]\n                | otherwise = map (,0) [x,x-1..y]\n    go !o = go2\n      where\n        go1 !i ((x,y):ps) | i == x    =                go2 x y ps\n                          | otherwise = connect i x ++ go2 x y ps\n        go1 !i []                     = connect i o\n        go2 !x !y ps = (x,1) : (y,1) : go1 y ps\n\nmult :: [(Int,Bool)] -> [(Int,Bool)] -> [(Int,Bool)]\nmult = (++)\n \ninv :: [(Int,Bool)] -> [(Int,Bool)]\ninv = reverse . map (second not)\n\ncommut :: [(Int,Bool)] -> [(Int,Bool)] -> [(Int,Bool)]\ncommut x y = mult x $ mult y $ mult (inv x) (inv y)\n\nsingle :: Int -> [(Int,Bool)]\nsingle = (:[]) . (,True)\n\nmakeCommut :: Int -> [(Int,Bool)]\nmakeCommut 0 = []\nmakeCommut u = evalState (go $ popCount u) u\n  where\n    go 1 = state $ \\ !s -> (single $ countTrailingZeros s, xor s $ s .&. (-s))\n    go !pc = liftA2 commut (go dv) $ go (pc-dv)\n      where dv = pc `shiftR` 1\n\nmain :: IO ()\nmain = do\n  n <- readInt <$> getLine\n  xs <- getVecULn (bit n) $ (toW8 (ord '1') -) <$> StateT BSW.uncons\n  dp <- VU.unsafeThaw xs\n  forM_ [0..bit n - 1] $ \\ !i -> do\n    cur <- VUM.unsafeRead dp i\n    when (cur == 1) $ do\n      VUM.unsafeWrite dp i 3\n      forM_ (filter ((==i) . (.&.i)) [i+1..bit n - 1]) $ \\ !j -> do\n        nxt <- VUM.unsafeRead dp j\n        case nxt of\n          0 -> do putStrLn \"Impossible\"\n                  exitSuccess\n          1 -> VUM.unsafeWrite dp j 2\n          2 -> return ()\n          _ -> do hPutStrLn stderr\n                    $ \"Error! Invalid input? occurred: \" ++ show nxt\n                  exitFailure\n  dp <- VU.unsafeFreeze dp\n  putStrLn \"Possible\"\n  let res = makeCurve $ concatMap makeCommut $ VU.toList $ VU.elemIndices 3 dp\n  print $ length res - 1\n  putStr $ unlines $ map (\\(x,y) -> shows x $ ' ' : show y) res\n  return ()\n\n#define IL(f) {-# INLINE f #-}; f\n\nIL(putBuilder) = BSB.hPutBuilder stdout\n\nprintVecInLines, printVecInSpcSepLn ::\n  (VG.Vector v a, ShowAsBuilder a) => v a -> IO ()\nIL(printVecInLines) = putBuilder . v2BLines\nIL(printVecInSpcSepLn) = putBuilder . v2BSpcSepLn\n\nclass ShowAsBuilder a where\n  showAsBuilder :: a -> BSB.Builder\n  default showAsBuilder :: (Show a) => a -> BSB.Builder\n  IL(showAsBuilder) = BSB.string8 . show\n\n-- Inconsistent with show\ninstance (ShowAsBuilder a, VG.Vector v a) => ShowAsBuilder (v a) where\n  IL(showAsBuilder) = v2BSpcSep\n\n#define INS(t,f) instance ShowAsBuilder t where { IL(showAsBuilder)=f }\nINS(Int,BSB.intDec)\nINS(Int8,BSB.int8Dec)\nINS(Int16,BSB.int16Dec)\nINS(Int32,BSB.int32Dec)\nINS(Int64,BSB.int64Dec)\nINS(Word,BSB.wordDec)\nINS(Word8,BSB.word8Dec)\nINS(Word16,BSB.word16Dec)\nINS(Word32,BSB.word32Dec)\nINS(Word64,BSB.word64Dec)\nINS(Integer,BSB.integerDec)\nINS(Float,BSB.floatDec)\nINS(Double,BSB.doubleDec)\n-- INS(String,BSB.string8) -- Inconsistent with Show\n-- INS(BS.ByteString,BSB.byteString) -- Inconsistent with Show\n-- INS(BSL.ByteString,BSB.lazyByteString) -- Inconsisitent with Show\n#undef INS\n\n-- Inconsistent with Show\ninstance (ShowAsBuilder a, ShowAsBuilder b) => ShowAsBuilder (a,b) where\n  IL(showAsBuilder) = showTupAsBuilder\ninstance (ShowAsBuilder a, ShowAsBuilder b, ShowAsBuilder c) =>\n  ShowAsBuilder (a,b,c) where\n  IL(showAsBuilder) = showTup3AsBuilder\ninstance (ShowAsBuilder a, ShowAsBuilder b, ShowAsBuilder c, ShowAsBuilder d) =>\n  ShowAsBuilder (a,b,c,d) where\n  IL(showAsBuilder) = showTup4AsBuilder\n\nIL(showTupAsBuilderWith)\n  :: (a -> BSB.Builder) -> (b -> BSB.Builder) -> (a,b) -> BSB.Builder\nshowTupAsBuilderWith showA showB\n  = \\(a,b) -> (showA a <>) $ BSB.char7 ' ' <> showB b\nIL(showTupAsBuilder) :: (ShowAsBuilder a, ShowAsBuilder b)\n  => (a,b) -> BSB.Builder\nshowTupAsBuilder = showTupAsBuilderWith showAsBuilder showAsBuilder \n\nIL(showTup3AsBuilderWith) :: (a -> BSB.Builder) -> (b -> BSB.Builder) ->\n  (c -> BSB.Builder) -> (a,b,c) -> BSB.Builder\nshowTup3AsBuilderWith showA showB showC\n  = \\(a,b,c) -> (showA a <>) $ (BSB.char7 ' ' <>) $ (showB b <>)\n                $ (BSB.char7 ' ' <>) $ showC c\nIL(showTup3AsBuilder) :: (ShowAsBuilder a, ShowAsBuilder b, ShowAsBuilder c)\n  => (a,b,c) -> BSB.Builder\nshowTup3AsBuilder\n  = showTup3AsBuilderWith showAsBuilder showAsBuilder showAsBuilder\n\nIL(showTup4AsBuilderWith) :: (a -> BSB.Builder) -> (b -> BSB.Builder) ->\n  (c -> BSB.Builder) -> (d -> BSB.Builder) -> (a,b,c,d) -> BSB.Builder\nshowTup4AsBuilderWith showA showB showC showD\n  = \\(a,b,c,d) -> (showA a <>) $ (BSB.char7 ' ' <>)\n                  $ showTup3AsBuilderWith showB showC showD (b,c,d)\nIL(showTup4AsBuilder) ::\n  (ShowAsBuilder a, ShowAsBuilder b, ShowAsBuilder c, ShowAsBuilder d) =>\n  (a,b,c,d) -> BSB.Builder\nshowTup4AsBuilder = showTup4AsBuilderWith showAsBuilder showAsBuilder\n                    showAsBuilder showAsBuilder\n\nv2BSpcSepLn, v2BSpcSep, v2BConcat, v2BLines ::\n  (VG.Vector v a, ShowAsBuilder a)\n  => v a -> BSB.Builder\nIL(v2BSpcSepLn) = v2BSpcSepLnWith showAsBuilder\nIL(v2BSpcSep) = v2BSpcSepWith showAsBuilder\nIL(v2BConcat) = v2BConcatWith showAsBuilder\nIL(v2BLines) = v2BLinesWith showAsBuilder\n\n\nv2BSpcSepLnWith, v2BSpcSepWith, v2BConcatWith, v2BLinesWith ::\n  (VG.Vector v a)\n  => (a -> BSB.Builder) -- ^ show function\n  -> v a -> BSB.Builder\nIL(v2BSpcSepLnWith) = v2BSpcSepPostfWith $ BS.singleton '\\n'\nIL(v2BSpcSepWith) = v2BSpcSepPostfWith BS.empty\nIL(v2BConcatWith) showFct = VG.foldr ((<>) . showFct) mempty\nIL(v2BLinesWith) showFct\n  = VG.foldr (\\ a -> (showFct a <>) . (BSB.char7 '\\n' <>)) mempty\n\n\nv2BSpcSepPostf :: (VG.Vector v a, ShowAsBuilder a)\n  => BS.ByteString -- ^ postfix\n  -> v a -> BSB.Builder\nIL(v2BSpcSepPostf) = (`v2BSpcSepPostfWith` showAsBuilder)\n\nv2BSpcSepPostfWith :: (VG.Vector v a)\n  => BS.ByteString -- ^ postfix\n  -> (a -> BSB.Builder) -- ^ show function\n  -> v a -> BSB.Builder\nIL(v2BSpcSepPostfWith) = vecToBuilder BS.empty $ BS.singleton ' '\n\nIL(vecToBuilder) :: (VG.Vector v a)\n  => BS.ByteString -- ^ prefix\n  -> BS.ByteString -- ^ separator\n  -> BS.ByteString -- ^ postfix\n  -> (a -> BSB.Builder) -- ^ show function\n  -> v a -> BSB.Builder\nvecToBuilder !prefix !separator !postfix\n  = vecToBuilder_ (BSB.byteString prefix)\n                  (BSB.byteString separator)\n                  (BSB.byteString postfix)\n\n\nIL(vecToBuilder_) :: (VG.Vector v a)\n  => BSB.Builder -- ^ prefix\n  -> BSB.Builder -- ^ separator\n  -> BSB.Builder -- ^ postfix\n  -> (a -> BSB.Builder) -- ^ show function\n  -> v a -> BSB.Builder\nvecToBuilder_ !prefix !separator !postfix showFct = \\vec -> prefix <>\n  VG.foldr\n  (\\ a rest !prefx -> prefx <> (showFct a <> rest separator))\n  (const postfix) vec mempty\n\nIL(evalVals) :: [a] -> [a]\nevalVals xs = build $ \\c n -> foldr (c $!) n xs\nIL(forceVals) :: (NFData a) => [a] -> [a]\nforceVals xs = build $ \\c n -> foldr (c $!!) n xs\n\nIL(readLnWith) :: StateT BS.ByteString Maybe a -> IO a\nreadLnWith parser = fromJust . evalStateT parser <$> BS.getLine\nIL(readContentWith) :: StateT BSL.ByteString Maybe a -> IO a\nreadContentWith parser = fromJust . evalStateT parser <$> BSL.getContents\n\nIL(getVecGLn) :: (VG.Vector v a) =>\n  Int -> StateT BS.ByteString Maybe a -> IO (v a)\ngetVecGLn n s = VG.unfoldrN n (runStateT s) <$> BS.getLine\nIL(getVecGRest) :: (VG.Vector v a) =>\n  Int -> StateT BSL.ByteString Maybe a -> IO (v a)\ngetVecGRest n s = VG.unfoldrN n (runStateT s) <$> BSL.getContents\nIL(getVecLn) :: Int -> StateT BS.ByteString Maybe a -> IO (V.Vector a)\ngetVecLn = getVecGLn\nIL(getVecRest) :: Int -> StateT BSL.ByteString Maybe a -> IO (V.Vector a)\ngetVecRest = getVecGRest\nIL(getVecULn) :: (VU.Unbox a) =>\n  Int -> StateT BS.ByteString Maybe a -> IO (VU.Vector a)\ngetVecULn = getVecGLn\nIL(getVecURest) :: (VU.Unbox a) =>\n  Int -> StateT BSL.ByteString Maybe a -> IO (VU.Vector a)\ngetVecURest = getVecGRest\n\nIL(rIntL) :: StateT BSL.ByteString Maybe Int\nrIntL = skipSpecialL $ StateT BSL.readInt\nIL(rIntS) :: StateT BS.ByteString Maybe Int\nrIntS = skipSpecialS $ StateT BS.readInt\nIL(rStrL) :: (MonadState BSL.ByteString m) => m BS.ByteString\nrStrL = skipSpecialL $ BSL.toStrict <$> state (BSL.span (>='!'))\nIL(rStrS) :: (MonadState BS.ByteString m) => m BS.ByteString\nrStrS = skipSpecialS $ state $ BS.span (>='!')\nIL(rCharL) :: StateT BSL.ByteString Maybe Char\nrCharL = StateT BSL.uncons\nIL(rCharS) :: StateT BS.ByteString Maybe Char\nrCharS = StateT BS.uncons\nIL(dropSpecialL) :: (MonadState BSL.ByteString m) => m ()\ndropSpecialL = modify $ BSL.dropWhile (<'!')\nIL(dropSpecialS) :: (MonadState BS.ByteString m) => m ()\ndropSpecialS = modify $ BS.dropWhile (<'!')\nIL(skipSpecialL) :: (MonadState BSL.ByteString m) => m a -> m a\nskipSpecialL = (dropSpecialL *>)\nIL(skipSpecialS) :: (MonadState BS.ByteString m) => m a -> m a\nskipSpecialS = (dropSpecialS *>)\n\nIL(linToMat) :: (VG.Vector v a) => Int -> Int -> v a -> V.Vector (v a)\nlinToMat h w lvec = vEvalElemsId $ V.generate h (\\i -> VG.slice (i*w) w lvec)\n\nIL(mLinToMat) :: (VGM.MVector v a) => Int -> Int -> v s a -> V.Vector (v s a)\nmLinToMat h w lvec = vEvalElemsId $ V.generate h (\\i -> VGM.slice (i*w) w lvec)\n  \nIL(unsafeAddrToSVec) :: Int -> Addr# -> VS.Vector Word8\nunsafeAddrToSVec n addr\n  = (`VS.unsafeFromForeignPtr0` n)\n    $ unsafeDupablePerformIO\n    $ newForeignPtr_ $ Ptr addr\n\nIL(vEvalElemsId) :: (VG.Vector v a) => v a -> v a\nvEvalElemsId = vMapFoldl (\\ !_ !x -> (x,())) ()\n\nIL(vEvalElems) :: (VG.Vector v a) => v a -> ()\nvEvalElems = VG.foldl' (\\ !_ !_ -> ()) () \n\nIL(vMapFoldl) :: (VG.Vector v b, VG.Vector v c) =>\n  (a -> b -> (c,a)) -> a -> v b -> v c\nvMapFoldl f a\n  = VG.unstream . VFB.inplace (streamMapFoldl f a) id . VG.stream\n\nstreamMapFoldl :: (Functor m) =>\n  (a -> b -> (c,a)) -> a -> VFSM.Stream m b -> VFSM.Stream m c\n{-# INLINE_FUSED streamMapFoldl #-}\nstreamMapFoldl f a (VFSM.Stream step s) = VFSM.Stream step1 (a,s)\n  where\n    {-# INLINE_INNER step1 #-}\n    step1 (a0,s0) =  (<$> step s0) $ \\r -> case r of\n      VFSM.Yield b s1 -> case f a0 b of (c,a1) -> VFSM.Yield c (a1,s1)\n      VFSM.Skip    s1 -> VFSM.Skip (a0,s1)\n      VFSM.Done       -> VFSM.Done\n\nIL(svecToBS) :: VS.Vector Word8 -> BS.ByteString\nsvecToBS vec = BSU.fromForeignPtr ptr 0 len\n  where (ptr, len) = VS.unsafeToForeignPtr0 vec\n\n\nunlessM, whenM :: (Monad m) => m Bool -> m () -> m ()\nIL(whenM) = (. flip when) . (>>=)\nIL(unlessM) = (. flip unless) . (>>=)\n\nIL(wrA) = A.writeArray\nIL(rdA) = A.readArray\nIL(mdA) = \\arr f !i -> do\n  ai <- rdA arr i\n  let fai = f ai \n  wrA arr i fai\n  return (ai,fai)\n{-# INLINE mdA' #-}\nmdA' = \\arr f !i -> do\n  !ai <- rdA arr i\n  let !fai = f ai\n  wrA arr i fai\n  return (ai,fai)\nIL(swapA) = \\arr !i !j -> do\n  ai <- rdA arr i\n  wrA arr i =<< rdA arr j\n  wrA arr j ai\n\n#define D(f,r,d)\\\n  IL(f) :: Integral a=>a->d; f=fromIntegral;\\\n  IL(r) :: String->d; r=read\n#define C(f,r,g,h,d) D(f,r,d);\\\n  g,h :: RealFrac a=>a->d; IL(g)=floor; IL(h)=ceiling\nC(_toInteger_,readInteger,floorInteger,ceilInteger,Integer)\nC(toInt,readInt,floorInt,ceilInt,Int)\nC(toI8,readI8,floorI8,ceilI8,Int8)\nC(toI16,readI16,floorI16,ceilI16,Int16)\nC(toI32,readI32,floorI32,ceilI32,Int32)\nC(toI64,readI64,floorI64,ceilI64,Int64)\nC(toWord,readWord,floorWord,ceilWord,Word)\nC(toW8,readW8,floorW8,ceilW8,Word8)\nC(toW16,readW16,floorW16,ceilW16,Word16)\nC(toW32,readW32,floorW32,ceilW32,Word32)\nC(toW64,readW64,floorW64,ceilW64,Word64)\nD(toDouble,readDouble,Double)\nD(toFloat,readFloat,Float)\n#undef D\n#undef C\n\n#define TS(f,a,m,init)\\\n  IL(f) :: forall e i s. (C(a,m) A.Ix i) => (i,i) -> init m (a i e); f\n#define N(f,g,h,a,m)\\\n  TS(f,a,m,e->)=A.newArray;\\\n  TS(g,a,m,)=A.newArray_;\\\n  TS(h,a,m,[e]->)=A.newListArray\n#define C(a,m)\nN(newIOA,newIOA_,newIOAL,IOArray,IO)\nN(newSTA,newSTA_,newSTAL,STArray s,ST s)\n#undef C\n#define C(a,m) MArray (a) e (m), \nN(newIOUA,newIOUA_,newIOUAL,IOUArray,IO)\nN(newSTUA,newSTUA_,newSTUAL,STUArray s,ST s)\n#undef C\n#undef N\n#undef TS\n\n#undef IL\n"
  },
  {
    "language": "Text",
    "code": "Impossible\n"
  },
  {
    "language": "Text",
    "code": "Impossible"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define repp(i,l,r,k)for(ll i=(l);i<(r);i+=(k))\n#define INF ((1LL<<62)-(1LL<<31))\n#define max(p,q)((p)>(q)?(p):(q))\n#define min(p,q)((p)<(q)?(p):(q))\n#define bit(n,m)(((n)>>(m))&1)\nint upll(const void*a, const void*b){return*(ll*)a<*(ll*)b?-1:*(ll*)a>*(ll*)b?1:0;}\nint downll(const void*a, const void*b){return*(ll*)a<*(ll*)b?1:*(ll*)a>*(ll*)b?-1:0;}\nvoid sortup(ll*a,int n){qsort(a,n,sizeof(ll),upll);}\nvoid sortdown(ll*a,int n){qsort(a,n,sizeof(ll),downll);}\nll pom(ll a,ll n,int m){ll x=1;for(a%=m;n;n/=2)n&1?x=x*a%m:0,a=a*a%m;return x;}\n//#define MOD 998244353\n#define MOD 1000000007\n#define invp(a,p)pom(a,p-2,p)\n\nint n;\nchar s[300];\nint x[10000],y[10000];\n\nint main(){\n\tscanf(\"%d %s\",&n,s);\n\tint M=-1,Mi;\n\trep(i,0,1<<n)if(s[i]=='1'){\n\t\tif(__builtin_popcount(i)>M){\n\t\t\tM=__builtin_popcount(i);\n\t\t\tMi=i;\n\t\t}\n\t}\n\trep(i,0,1<<n){\n\t\tif(((i&Mi)==i)^(s[i]=='1')){\n\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tx[0]=0;y[0]=0;\n\tint cnt=1;\n\tint pre=0;\n\trep(i,0,n){\n\t\tint now='1'-s[1<<i];\n\t\t//1なら上、0なら下\n\t\tif(now==pre){\n\t\t\tx[cnt]=i+1;y[cnt]=now;cnt++;\n\t\t}else{\n\t\t\tx[cnt]=i;y[cnt]=now;cnt++;\n\t\t\tx[cnt]=i+1;y[cnt]=now;cnt++;\n\t\t}\n\t\tpre=now;\n\t}\n\tif(pre){x[cnt]=n;y[cnt]=0;cnt++;}\n\tfor(int i=n-1;i>0;i--){x[cnt]=i;y[cnt]=0;cnt++;}\n\t\n\tputs(\"Possible\");\n\tprintf(\"%d\\n\",cnt);\n\trep(i,0,cnt+1)printf(\"%d %d\\n\",x[i%cnt],y[i%cnt]);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define repp(i,l,r,k)for(ll i=(l);i<(r);i+=(k))\n#define INF ((1LL<<62)-(1LL<<31))\n#define max(p,q)((p)>(q)?(p):(q))\n#define min(p,q)((p)<(q)?(p):(q))\n#define bit(n,m)(((n)>>(m))&1)\nint upll(const void*a, const void*b){return*(ll*)a<*(ll*)b?-1:*(ll*)a>*(ll*)b?1:0;}\nint downll(const void*a, const void*b){return*(ll*)a<*(ll*)b?1:*(ll*)a>*(ll*)b?-1:0;}\nvoid sortup(ll*a,int n){qsort(a,n,sizeof(ll),upll);}\nvoid sortdown(ll*a,int n){qsort(a,n,sizeof(ll),downll);}\nll pom(ll a,ll n,int m){ll x=1;for(a%=m;n;n/=2)n&1?x=x*a%m:0,a=a*a%m;return x;}\n//#define MOD 998244353\n#define MOD 1000000007\n#define invp(a,p)pom(a,p-2,p)\n\nint n;\nchar s[300];\nint x[10000],y[10000];\n\nint main(){\n\tscanf(\"%d %s\",&n,s);\n\tint M=-1,Mi;\n\trep(i,0,1<<n)if(s[i]=='1'){\n\t\tif(__builtin_popcount(i)>M){\n\t\t\tM=__builtin_popcount(i);\n\t\t\tMi=i;\n\t\t}\n\t}\n\trep(i,0,1<<n){\n\t\tif(((i&Mi)==i)^(s[i]=='1')){\n            //ここが嘘っぽい\n\t\t\t//puts(\"Impossible\");\n\t\t\treturn 1;\n\t\t}\n\t}\n\t\n\tx[0]=0;y[0]=0;\n\tint cnt=1;\n\tint pre=0;\n\trep(i,0,n){\n\t\tint now='1'-s[1<<i];\n\t\t//1なら上、0なら下\n\t\tif(now==pre){\n\t\t\tx[cnt]=i+1;y[cnt]=now;cnt++;\n\t\t}else{\n\t\t\tx[cnt]=i;y[cnt]=now;cnt++;\n\t\t\tx[cnt]=i+1;y[cnt]=now;cnt++;\n\t\t}\n\t\tpre=now;\n\t}\n\tif(pre){x[cnt]=n;y[cnt]=0;cnt++;}\n\tfor(int i=n-1;i>0;i--){x[cnt]=i;y[cnt]=0;cnt++;}\n\t\n\tputs(\"Possible\");\n\tprintf(\"%d\\n\",cnt);\n\trep(i,0,cnt+1)printf(\"%d %d\\n\",x[i%cnt],y[i%cnt]);\n}"
  },
  {
    "language": "C",
    "code": "#include <limits.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <math.h>\n\n#define P 1000000007\n\nint comp(const void *a, const void *b){return *(int*)a-*(int*)b;}\nint compw(const void *a, const void *b){return (*(int*)a>*(int*)b)-(*(int*)a<*(int*)b);}\n\nuint32_t nextpint(void){ char c=getchar(); while(c<'0'||'9'<c) c=getchar(); uint_fast32_t x=0; while('0'<=c && c<='9'){ x=x*10+c-'0'; c=getchar(); } return x; }\n\nint min2(const int a, const int b){return a>b?b:a;}\nint dif2(const int a, const int b){return a>b?a-b:b-a;}\n\nchar s[257];\nint main(int argc, char *argv[], char *envp[]){\n\tint n=nextpint();\n\tscanf(\"%s\", s);\n\n\tint f=1;\n\tfor(int i=0; i<(1<<n); i++){\n\t\ts[i]-='0';\n\t\tif(s[i]==0) f=0;\n\t}\n\t/*if(s[(1<<n)-1]==1){\n\t\tif(f==0){\n\t\t\tputs(\"Impossible\");\n\t\t}else{\n\t\t\tputs(\"Possible\");\n\t\t}\n\t}*/\n\n\tf=0;\n\tint k;\n\tfor(k=0; k<(1<<n); k++){\n\t\tint g=1;\n\t\tfor(int i=0; i<(1<<n); i++){\n\t\t\tint now=((k&i)==0);\n\t\t\tif(now!=s[i]){g=0; break;}\n\t\t}\n\t\tif(g!=0){f=1; break;}\n\t}\n\tif(f==0){\n\t\tputs(\"Impossible\");\n\t}else{\n\t\tputs(\"Possible\");\n\t\tint l=0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tif((k&(1<<i))==0){\n\t\t\t\tl+=2;\n\t\t\t}else{\n\t\t\t\tl+=4;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", l);\n\t\tprintf(\"%d %d\\n\", 0, 0);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tif((k&(1<<i))==0){\n\t\t\t\tprintf(\"%d %d\\n\", i+1, 0);\n\t\t\t}else{\n\t\t\t\tprintf(\"%d %d\\n\", i, 1);\n\t\t\t\tprintf(\"%d %d\\n\", i+1, 1);\n\t\t\t\tprintf(\"%d %d\\n\", i+1, 0);\n\t\t\t}\n\t\t}\n\t\tfor(int i=n-1; i>=0; i--){\n\t\t\tprintf(\"%d %d\\n\", i, 0);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define repp(i,l,r,k)for(ll i=(l);i<(r);i+=(k))\n#define INF ((1LL<<62)-(1LL<<31))\n#define max(p,q)((p)>(q)?(p):(q))\n#define min(p,q)((p)<(q)?(p):(q))\n#define bit(n,m)(((n)>>(m))&1)\nint upll(const void*a, const void*b){return*(ll*)a<*(ll*)b?-1:*(ll*)a>*(ll*)b?1:0;}\nint downll(const void*a, const void*b){return*(ll*)a<*(ll*)b?1:*(ll*)a>*(ll*)b?-1:0;}\nvoid sortup(ll*a,int n){qsort(a,n,sizeof(ll),upll);}\nvoid sortdown(ll*a,int n){qsort(a,n,sizeof(ll),downll);}\nll pom(ll a,ll n,int m){ll x=1;for(a%=m;n;n/=2)n&1?x=x*a%m:0,a=a*a%m;return x;}\n//#define MOD 998244353\n#define MOD 1000000007\n#define invp(a,p)pom(a,p-2,p)\n\nint n;\nchar s[300];\nint x[10000],y[10000];\n\nint main(){\n\tscanf(\"%d %s\",&n,s);\n\tint M=-1,Mi;\n\trep(i,0,1<<n)if(s[i]=='1'){\n\t\tif(__builtin_popcount(i)>M){\n\t\t\tM=__builtin_popcount(i);\n\t\t\tMi=i;\n\t\t}\n\t}\n\trep(i,0,1<<n){\n\t\tif(((i&Mi)==i)^(s[i]=='1')){\n\t\t\tputs(\"Impossible\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tx[0]=0;y[0]=-1;\n\tx[1]=0;y[1]=0;\n\tint cnt=2;\n\tint pre=0;\n\trep(i,0,n){\n\t\tint now='1'-s[1<<i];\n\t\t//1なら上、0なら下\n\t\tif(now==pre){\n\t\t\tx[cnt]=i+1;y[cnt]=now;cnt++;\n\t\t}else{\n\t\t\tx[cnt]=i;y[cnt]=now;cnt++;\n\t\t\tx[cnt]=i+1;y[cnt]=now;cnt++;\n\t\t}\n\t\tpre=now;\n\t}\n\tif(pre){x[cnt]=n;y[cnt]=0;cnt++;}\n\tfor(int i=n;i>0;i--){x[cnt]=i;y[cnt]=-1;cnt++;}\n\t\n\tputs(\"Possible\");\n\tprintf(\"%d\\n\",cnt);\n\trep(i,0,cnt+1)printf(\"%d %d\\n\",x[i%cnt],y[i%cnt]);\n}"
  },
  {
    "language": "Kotlin",
    "code": "import java.util.*\n\nfun main(omkar: Array<String>) {\n    val jin = Scanner(System.`in`)\n    val n = jin.nextInt()\n    val s = jin.next()\n    var inside = (1 shl n) - 1\n    for (mask in 0 until (1 shl n)) {\n        if (s[mask] == '1') {\n            inside = inside and ((1 shl n) - 1 - mask)\n        }\n    }\n    for (mask in 0 until (1 shl n)) {\n        if (s[mask] == '0' && inside and mask == 0) {\n            println(\"Impossible\")\n            return\n        }\n    }\n    val points = mutableListOf<Pair<Int, Int>>()\n    points.add(Pair(0, 0))\n    var y = 0\n    for (x in 0 until n) {\n        if (y == 0 && ((inside shr x) and 1) != 0) {\n            y++\n            points.add(Pair(x, y))\n        } else if (y == 1 && ((inside shr x) and 1) == 0) {\n            y--\n            points.add(Pair(x, y))\n        }\n        points.add(Pair(x + 1, y))\n    }\n    if (y == 1) {\n        points.add(Pair(n, 0))\n    }\n    for (x in n - 1 downTo 0) {\n        points.add(Pair(x, 0))\n    }\n    println(\"Possible\")\n    println(points.size - 1)\n    for ((x, y) in points) {\n        println(\"$x $y\")\n    }\n}"
  },
  {
    "language": "Kotlin",
    "code": "import java.io.BufferedReader\nimport java.io.InputStream\nimport java.io.InputStreamReader\nimport java.io.PrintWriter\nimport java.lang.StringBuilder\nimport java.util.*\n\nfun PrintWriter.solve(sc: FastScanner) {\n    val n = sc.nextInt()\n    val a = sc.nextLine().toCharArray().map { it.toString().toInt() }\n    val contain = Array(n) { false }\n    var ok = true\n    for (i in 0 until n) {\n        val j = Math.pow(2.0, i.toDouble()).toInt()\n        if (a[j] == 0) {\n            contain[i] = true\n        }\n    }\n    val l = a.count()\n    for (i in 0 until l) {\n        var iszero = false\n        for (j in 0 until n) {\n            if ((i and 1.shl(j)) != 0 && contain[j]) {\n                iszero = true\n                break\n            }\n        }\n        if ((iszero && a[i] != 0) || (!iszero && a[i] == 0)) {\n            ok = false\n            break\n        }\n    }\n    if (ok) {\n        println(\"Possible\")\n        val points = mutableListOf<Pair<Int,Int>>()\n        var up = false\n        points.add(0 to 0)\n        for (i in 0 until n) {\n            if (contain[i]) {\n                if (!up) {\n                    up = true\n                    points.add(i to 1)\n                }\n                points.add(i + 1 to 1)\n            } else {\n                if (up) {\n                    up = false\n                    points.add(i to 0)\n                }\n                points.add(i + 1 to 0)\n            }\n        }\n        if (up) {\n            points.add(n to 0)\n        }\n        for (i in n - 1 downTo 0) {\n            points.add(i to 0)\n        }\n        println(points.count() - 1)\n        for (p in points) {\n            println(\"%d %d\".format(p.first, p.second))\n        }\n    } else {\n        println(\"Impossible\")\n    }\n}\n\nfun main(args: Array<String>) {\n    val writer = PrintWriter(System.out, false)\n    writer.solve(FastScanner(System.`in`))\n    writer.flush()\n}\n\nclass FastScanner(s: InputStream) {\n    private var st = StringTokenizer(\"\")\n    private val br = BufferedReader(InputStreamReader(s))\n\n    fun next(): String {\n        while (!st.hasMoreTokens()) st = StringTokenizer(br.readLine())\n\n        return st.nextToken()\n    }\n\n    fun nextInt() = next().toInt()\n    fun nextLong() = next().toLong()\n    fun nextLine() = br.readLine()\n    fun nextDouble() = next().toDouble()\n    fun ready() = br.ready()\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.io.BufferedReader\nimport java.io.InputStream\nimport java.io.InputStreamReader\nimport java.io.PrintWriter\nimport java.lang.StringBuilder\nimport java.util.*\n\nfun PrintWriter.solve(sc: FastScanner) {\n    val n = sc.nextInt()\n    val a = sc.nextLine().toCharArray().map { it.toString().toInt() }\n    val contain = Array(n) { false }\n    var ok = true\n    for (i in 0 until n) {\n        val j = Math.pow(2.0, i.toDouble()).toInt()\n        if (a[j] == 0) {\n            contain[i] = true\n        }\n    }\n    val l = a.count()\n    for (i in 0 until l) {\n        var iszero = false\n        for (j in 0 until n) {\n            if ((i and 1.shl(j)) != 0 && contain[j]) {\n                iszero = true\n                break\n            }\n        }\n        if ((iszero && a[i] != 0) || (!iszero && a[i] == 0)) {\n            ok = false\n            break\n        }\n    }\n    var change = 0\n    for (i in 1 until n) {\n        if (contain[i] != contain[i-1]) change++\n    }\n    if (!contain[0]) change--\n    if (change >= 2) ok = false\n    if (ok) {\n        println(\"Possible\")\n        if (change < 0) {\n            println(0)\n            println(\"1 1\")\n            return\n        }\n        val points = mutableListOf<Pair<Int,Int>>()\n        var up = false\n        points.add(0 to 0)\n        for (i in 0 until n) {\n            if (contain[i]) {\n                if (!up) {\n                    up = true\n                    points.add(i to 1)\n                }\n                points.add(i + 1 to 1)\n            } else {\n                if (up) {\n                    up = false\n                    points.add(i to 0)\n                }\n                points.add(i + 1 to 0)\n            }\n        }\n        if (up) {\n            points.add(n to 0)\n        }\n        for (i in n - 1 downTo 0) {\n            points.add(i to 0)\n        }\n        println(points.count() - 1)\n        for (p in points) {\n            println(\"%d %d\".format(p.first, p.second))\n        }\n    } else {\n        println(\"Impossible\")\n    }\n}\n\nfun main(args: Array<String>) {\n    val writer = PrintWriter(System.out, false)\n    writer.solve(FastScanner(System.`in`))\n    writer.flush()\n}\n\nclass FastScanner(s: InputStream) {\n    private var st = StringTokenizer(\"\")\n    private val br = BufferedReader(InputStreamReader(s))\n\n    fun next(): String {\n        while (!st.hasMoreTokens()) st = StringTokenizer(br.readLine())\n\n        return st.nextToken()\n    }\n\n    fun nextInt() = next().toInt()\n    fun nextLong() = next().toLong()\n    fun nextLine() = br.readLine()\n    fun nextDouble() = next().toDouble()\n    fun ready() = br.ready()\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        char[] str = sc.next().toCharArray();\n\n        //引っかかるところを探す\n        boolean a[] = new boolean[1 << n];\n        for(int i = 0 ; i < (1 << n) ; i++){\n            a[i] = str[i] == '0';\n        }\n\n        boolean pick[] = new boolean[n];\n        for(int i = 0 ; i < n ; i++){\n            pick[i] = a[1 << i];\n        }\n\n        boolean ans = true;\n        for(int i = 0 ; i < (1 << n) ; i++){\n            for(int j = 0 ; j < n ; j++){\n                if(((i >> j)&1) == 1){\n                    if(pick[j] && !a[i]){\n                        ans = false;\n                    }\n                }\n            }\n        }\n\n        System.out.println(ans?\"Possible\":\"Impossible\");\n        boolean prev = false;\n        int l = 0;\n\n        if(ans){\n            for(int i = 0 ; i < n ; i++){\n                if(prev){\n                    if(pick[i]){\n                        l++;\n                    }else{\n                        l++;\n                        l++;\n                    }\n                }else{\n                    if(pick[i]){\n                        l++;\n                        l++;\n                    }else{\n                        l++;\n                    }\n                }\n                prev = pick[i];\n            }\n\n            for(int i = prev?n:n-1 ; i >= 0 ; i--){\n                l++;\n            }\n\n            prev = false;\n\n            System.out.println(l);\n            System.out.println(\"0 0\");\n            for(int i = 0 ; i < n ; i++){\n                if(prev){\n                    if(pick[i]){\n                        System.out.println(\"\"+(i+1)+\" 1\");\n                    }else{\n                        System.out.println(\"\"+(i)+\" 0\");\n                        System.out.println(\"\"+(i+1)+\" 0\");\n                    }\n                }else{\n                    if(pick[i]){\n                        System.out.println(\"\"+(i)+\" 1\");\n                        System.out.println(\"\"+(i+1)+\" 1\");\n                    }else{\n                        System.out.println(\"\"+(i+1)+\" 0\");\n                    }\n                }\n                prev = pick[i];\n            }\n\n            for(int i = (prev?n:n-1) ; i >= 0 ; i--){\n                System.out.println(\"\"+i+\" 0\");\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        E_Topology solver = new E_Topology();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class E_Topology {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int n = in.nextInt();\n            char[] s = in.next().toCharArray();\n            boolean[] pinned = new boolean[1 << n];\n            for (int i = 0; i < 1 << n; i++) {\n                pinned[i] = s[i] == '0';\n            }\n            List<String> ans = new ArrayList<>();\n            for (int mask = 0; mask < 1 << n; mask++) {\n                boolean any = false;\n                for (int i = 0; i < n; i++) {\n                    if ((mask & (1 << i)) == 0) {\n                        continue;\n                    }\n                    if (pinned[1 << i]) {\n                        any = true;\n                    }\n                }\n                if (pinned[mask] == any) {\n                    ans.add(String.format(\"%d %d\", 0, 0));\n                    for (int i = 0; i < n; i++) {\n                        if ((mask & (1 << i)) != 0) {\n                            ans.add(String.format(\"%d %d\", i, 1));\n                            ans.add(String.format(\"%d %d\", i + 1, 1));\n                        }\n                        ans.add(String.format(\"%d %d\", i + 1, 0));\n                    }\n                    for (int i = n - 1; i >= 0; i--) {\n                        ans.add(String.format(\"%d %d\", i, 0));\n                    }\n                    continue;\n                }\n                if (any) {\n                    out.println(\"Impossible\");\n                    return;\n                }\n\n                // !any && pinned[mask]\n//            throw new AssertionError();\n                ans.add(String.format(\"%d %d\", 0, 0));\n                ans.add(String.format(\"%d %d\", 0, 1));\n                for (int i = 0; i < n; i++) {\n                    if ((mask & (1 << i)) != 0) {\n                        ans.add(String.format(\"%d %d\", i, 0));\n                        ans.add(String.format(\"%d %d\", i + 1, 0));\n                    }\n                    ans.add(String.format(\"%d %d\", i + 1, 1));\n                }\n                for (int i = n - 1; i >= 0; i--) {\n                    ans.add(String.format(\"%d %d\", i, 1));\n                }\n                ans.add(String.format(\"%d %d\", 0, 0));\n            }\n\n            out.println(\"Possible\");\n            out.println(ans.size() - 1);\n            for (String str : ans) {\n                out.println(str);\n            }\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String rl = in.readLine();\n                    if (rl == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(rl);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n    //2桁目以降どっか０だったら全部ゼロじゃないとImpossible？\n    //1桁目は1じゃなかったらImpossible\n    int N = sc.nextInt();\n    int A[] = new int[Math.pow(2,N)];\n    String s = sc.next();\n    for(int i=0;i<Math.pow(2,N);i++){\n      A[i]=Integer.parseInt(s.substring(i,i+1));\n    }\n    if(A[0]!=0){\n      System.out.println(\"Impossible\");\n      return;\n    }\n    \n    \n  }\n  \n\n  \n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        E_Topology solver = new E_Topology();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class E_Topology {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int n = in.nextInt();\n            char[] s = in.next().toCharArray();\n            boolean[] pinned = new boolean[1 << n];\n            for (int i = 0; i < 1 << n; i++) {\n                pinned[i] = s[i] == '0';\n            }\n            for (int mask = 0; mask < 1 << n; mask++) {\n                boolean any = false;\n                for (int i = 0; i < n; i++) {\n                    if ((mask & (1 << i)) == 0) {\n                        continue;\n                    }\n                    if (pinned[1 << i]) {\n                        any = true;\n                    }\n                }\n                if (pinned[mask] != any) {\n                    out.println(\"Impossible\");\n                    return;\n                }\n            }\n\n            out.println(\"Possible\");\n            out.println(1 + 2 * n);\n            out.printf(\"%d %d\\n\", 0, 0);\n            for (int i = 0; i < n; i++) {\n                if (pinned[1 << i]) {\n                    out.printf(\"%d %d\\n\", i + 1, +2);\n                } else {\n                    out.printf(\"%d %d\\n\", i + 1, -2);\n                }\n                out.printf(\"%d %d\\n\", i + 1, 0);\n            }\n            out.printf(\"%d %d\\n\", 0, 0);\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String rl = in.readLine();\n                    if (rl == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(rl);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        char[] str = sc.next().toCharArray();\n\n        //引っかかるところを探す\n        boolean a[] = new boolean[1 << n];\n        for(int i = 0 ; i < (1 << n) ; i++){\n            a[i] = str[i] == '0';\n        }\n\n        boolean pick[] = new boolean[n];\n        for(int i = 0 ; i < n ; i++){\n            pick[i] = a[1 << i];\n        }\n\n        boolean ans = true;\n        for(int i = 0 ; i < (1 << n) ; i++){\n            for(int j = 0 ; j < n ; j++){\n                if(((i >> j)&1) == 1){\n                    if(pick[j] && !a[i]){\n                        ans = false;\n                    }\n                }\n            }\n        }\n\n        System.out.println(ans?\"Possible\":\"Impossible\");\n        boolean prev = false;\n        if(ans){\n            System.out.println(\"0 0\");\n            for(int i = 0 ; i < n ; i++){\n                if(prev){\n                    if(pick[i]){\n                        System.out.println(\"\"+(i+1)+\" 1\");\n                    }else{\n                        System.out.println(\"\"+(i)+\" 0\");\n                        System.out.println(\"\"+(i+1)+\" 0\");\n                    }\n                }else{\n                    if(pick[i]){\n                        System.out.println(\"\"+(i)+\" 1\");\n                        System.out.println(\"\"+(i+1)+\" 1\");\n                    }else{\n                        System.out.println(\"\"+(i+1)+\" 0\");\n                    }\n                }\n                prev = pick[i];\n            }\n\n            for(int i = prev?n:n-1 ; i >= 0 ; i--){\n                System.out.println(\"\"+i+\" 0\");\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.System.arraycopy;\nimport static java.lang.System.exit;\nimport static java.util.Arrays.copyOf;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic class IntList {\n\n\t\tint data[] = new int[3];\n\t\tint size = 0;\n\n\t\tboolean isEmpty() {\n\t\t\treturn size == 0;\n\t\t}\n\n\t\tint size() {\n\t\t\treturn size;\n\t\t}\n\n\t\tint get(int index) {\n\t\t\tif (index < 0 || index >= size) {\n\t\t\t\tthrow new IndexOutOfBoundsException();\n\t\t\t}\n\t\t\treturn data[index];\n\t\t}\n\n\t\tvoid clear() {\n\t\t\tsize = 0;\n\t\t}\n\n\t\tvoid set(int index, int value) {\n\t\t\tif (index < 0 || index >= size) {\n\t\t\t\tthrow new IndexOutOfBoundsException();\n\t\t\t}\n\t\t\tdata[index] = value;\n\t\t}\n\n\t\tvoid expand() {\n\t\t\tif (size >= data.length) {\n\t\t\t\tdata = copyOf(data, (data.length << 1) + 1);\n\t\t\t}\n\t\t}\n\n\t\tvoid insert(int index, int value) {\n\t\t\tif (index < 0 || index > size) {\n\t\t\t\tthrow new IndexOutOfBoundsException();\n\t\t\t}\n\t\t\texpand();\n\t\t\tarraycopy(data, index, data, index + 1, size++ - index);\n\t\t\tdata[index] = value;\n\t\t}\n\n\t\tint delete(int index) {\n\t\t\tif (index < 0 || index >= size) {\n\t\t\t\tthrow new IndexOutOfBoundsException();\n\t\t\t}\n\t\t\tint value = data[index];\n\t\t\tarraycopy(data, index + 1, data, index, --size - index);\n\t\t\treturn value;\n\t\t}\n\n\t\tvoid push(int value) {\n\t\t\texpand();\n\t\t\tdata[size++] = value;\n\t\t}\n\n\t\tint pop() {\n\t\t\tif (size == 0) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t\treturn data[--size];\n\t\t}\n\n\t\tvoid unshift(int value) {\n\t\t\texpand();\n\t\t\tarraycopy(data, 0, data, 1, size++);\n\t\t\tdata[0] = value;\n\t\t}\n\n\t\tint shift() {\n\t\t\tif (size == 0) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t\tint value = data[0];\n\t\t\tarraycopy(data, 1, data, 0, --size);\n\t\t\treturn value;\n\t\t}\n\t}\n\n\tstatic IntList ans;\n\n\tstatic void go(int pos, int mask) {\n\t\tans.push(pos + 1);\n\t\tans.push(0);\n\t\tif ((mask & (1 << pos)) != 0) {\n\t\t\tans.push(pos + 1);\n\t\t\tans.push(1);\n\t\t\tans.push(pos);\n\t\t\tans.push(1);\n\t\t\tif (mask != 1 << pos) {\n\t\t\t\tint submask = mask ^ (1 << pos);\n\t\t\t\tans.push(pos);\n\t\t\t\tans.push(0);\n\t\t\t\tans.push(pos + 1);\n\t\t\t\tans.push(0);\n\t\t\t\tgo(pos + 1, submask);\n\t\t\t\tans.push(pos);\n\t\t\t\tans.push(0);\n\t\t\t\tans.push(pos);\n\t\t\t\tans.push(1);\n\t\t\t\tans.push(pos + 1);\n\t\t\t\tans.push(1);\n\t\t\t\tans.push(pos + 1);\n\t\t\t\tans.push(0);\n\t\t\t\tgoInv(pos + 1, submask);\n\t\t\t}\n\t\t} else {\n\t\t\tgo(pos + 1, mask);\n\t\t}\n\t\tans.push(pos);\n\t\tans.push(0);\n\t}\n\n\tstatic void goInv(int pos, int mask) {\n\t\tif ((mask & (1 << pos)) != 0) {\n\t\t\tif (mask != 1 << pos) {\n\t\t\t\tint submask = mask ^ (1 << pos);\n\t\t\t\tans.push(pos + 1);\n\t\t\t\tans.push(0);\n\t\t\t\tgo(pos + 1, submask);\n\t\t\t\tans.push(pos + 1);\n\t\t\t\tans.push(1);\n\t\t\t\tans.push(pos);\n\t\t\t\tans.push(1);\n\t\t\t\tans.push(pos);\n\t\t\t\tans.push(0);\n\t\t\t\tans.push(pos + 1);\n\t\t\t\tans.push(0);\n\t\t\t\tgoInv(pos + 1, submask);\n\t\t\t\tans.push(pos);\n\t\t\t\tans.push(0);\n\t\t\t}\n\t\t\tans.push(pos);\n\t\t\tans.push(1);\n\t\t\tans.push(pos + 1);\n\t\t\tans.push(1);\n\t\t\tans.push(pos + 1);\n\t\t\tans.push(0);\n\t\t} else {\n\t\t\tans.push(pos + 1);\n\t\t\tans.push(0);\n\t\t\tgoInv(pos + 1, mask);\n\t\t}\n\t\tans.push(pos);\n\t\tans.push(0);\n\t}\n\n\tstatic void solve() throws Exception {\n\t\tint n = scanInt();\n\t\tString a = scanString();\n\t\tans = new IntList();\n\t\tans.push(0);\n\t\tans.push(0);\n\t\tfor (int i = 0; i < 1 << n; i++) {\n\t\t\tif (a.charAt(i) == '0') {\n\t\t\t\tboolean sm = true;\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif ((i & (1 << j)) == 0) {\n\t\t\t\t\t\tif (a.charAt(i | (1 << j)) != '0') {\n\t\t\t\t\t\t\tout.print(\"Impossible\");\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (a.charAt(i ^ (1 << j)) == '0') {\n\t\t\t\t\t\t\tsm = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (sm) {\n\t\t\t\t\tgo(0, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(\"Possible\");\n\t\tout.println(ans.size / 2 - 1);\n\t\tfor (int i = 0; i < ans.size; i += 2) {\n\t\t\tout.println(ans.data[i] + \" \" + ans.data[i + 1]);\n\t\t}\n//\t\tif (ans.data[0] != 0 || ans.data[1] != 0 || ans.data[ans.size - 2] != 0 || ans.data[ans.size - 1] != 0) {\n//\t\t\tthrow new AssertionError();\n//\t\t}\n//\t\tfor (int i = 0; i < ans.size - 2; i += 2) {\n//\t\t\tif (abs(ans.data[i] - ans.data[i + 2]) + abs(ans.data[i + 1] - ans.data[i + 3]) != 1) {\n//\t\t\t\tthrow new AssertionError();\n//\t\t\t}\n//\t\t}\n\t}\n\n\tstatic int scanInt() throws IOException {\n\t\treturn parseInt(scanString());\n\t}\n\n\tstatic long scanLong() throws IOException {\n\t\treturn parseLong(scanString());\n\t}\n\n\tstatic String scanString() throws IOException {\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer tok;\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\texit(1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\n// 反例思いつかないんやが\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tchar[] a = ns(1<<n);\n\t\tinner:\n\t\tfor(int j = 0;j < 1<<n;j++){\n\t\t\tfor(int i = 0;i < 1<<n;i++){\n\t\t\t\tif((j&i) > 0){\n\t\t\t\t\tif(a[i] != '0'){\n\t\t\t\t\t\tcontinue inner;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(a[i] != '1'){\n\t\t\t\t\t\tcontinue inner;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(\"Possible\");\n\t\t\tList<int[]> list = new ArrayList<>();\n\t\t\tlist.add(new int[]{0, 0});\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tif(j<<~i<0){\n\t\t\t\t\tlist.add(new int[]{i, 1});\n\t\t\t\t\tlist.add(new int[]{i+1, 1});\n\t\t\t\t\tlist.add(new int[]{i+1, 0});\n\t\t\t\t}else{\n\t\t\t\t\tlist.add(new int[]{i+1, 0});\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\t\tlist.add(new int[]{i, 0});\n\t\t\t}\n\t\t\tout.println(list.size()-1);\n\t\t\tfor(int[] u : list){\n\t\t\t\tout.println(u[0] + \" \" + u[1]);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tout.println(\"Impossible\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        E_Topology solver = new E_Topology();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class E_Topology {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int n = in.nextInt();\n            char[] s = in.next().toCharArray();\n            boolean[] pinned = new boolean[1 << n];\n            for (int i = 0; i < 1 << n; i++) {\n                pinned[i] = s[i] == '0';\n            }\n            for (int mask = 0; mask < 1 << n; mask++) {\n                boolean any = false;\n                for (int i = 0; i < n; i++) {\n                    if ((mask & (1 << i)) == 0) {\n                        continue;\n                    }\n                    if (pinned[1 << i]) {\n                        any = true;\n                    }\n                }\n                if (pinned[mask] != any) {\n                    out.println(\"Impossible\");\n                    return;\n                }\n            }\n\n            List<String> ans = new ArrayList<>();\n            ans.add(String.format(\"%d %d\", 0, 0));\n            for (int i = 0; i < n; i++) {\n                if (pinned[1 << i]) {\n                    ans.add(String.format(\"%d %d\", i, 1));\n                    ans.add(String.format(\"%d %d\", i + 1, 1));\n                }\n                ans.add(String.format(\"%d %d\", i + 1, 0));\n            }\n            for (int i = n - 1; i >= 0; i--) {\n                ans.add(String.format(\"%d %d\", i, 0));\n            }\n            out.println(\"Possible\");\n            out.println(ans.size() - 1);\n            for (String str : ans) {\n                out.println(str);\n            }\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String rl = in.readLine();\n                    if (rl == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(rl);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        E_Topology solver = new E_Topology();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class E_Topology {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int n = in.nextInt();\n            char[] s = in.next().toCharArray();\n            boolean[] pinned = new boolean[1 << n];\n            for (int i = 0; i < 1 << n; i++) {\n                pinned[i] = s[i] == '0';\n            }\n            for (int mask = 0; mask < 1 << n; mask++) {\n                boolean any = false;\n                for (int i = 0; i < n; i++) {\n                    if ((mask & (1 << i)) == 0) {\n                        continue;\n                    }\n                    if (pinned[1 << i]) {\n                        any = true;\n                    }\n                }\n                if (pinned[mask] != any) {\n//                out.println(\"Impossible\");\n//                return;\n                    if (any) {\n                        throw new AssertionError();\n                    }\n                    while (pinned[mask]) {\n\n                    }\n                }\n            }\n\n            List<String> ans = new ArrayList<>();\n            ans.add(String.format(\"%d %d\", 0, 0));\n            for (int i = 0; i < n; i++) {\n                if (pinned[1 << i]) {\n                    ans.add(String.format(\"%d %d\", i, 1));\n                    ans.add(String.format(\"%d %d\", i + 1, 1));\n                }\n                ans.add(String.format(\"%d %d\", i + 1, 0));\n            }\n            for (int i = n - 1; i >= 0; i--) {\n                ans.add(String.format(\"%d %d\", i, 0));\n            }\n            out.println(\"Possible\");\n            out.println(ans.size() - 1);\n            for (String str : ans) {\n                out.println(str);\n            }\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String rl = in.readLine();\n                    if (rl == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(rl);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        E_Topology solver = new E_Topology();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class E_Topology {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int n = in.nextInt();\n            char[] s = in.next().toCharArray();\n            boolean[] pinned = new boolean[1 << n];\n            for (int i = 0; i < 1 << n; i++) {\n                pinned[i] = s[i] == '0';\n            }\n            for (int mask = 0; mask < 1 << n; mask++) {\n                boolean any = false;\n                for (int i = 0; i < n; i++) {\n                    if ((mask & (1 << i)) == 0) {\n                        continue;\n                    }\n                    if (pinned[1 << i]) {\n                        any = true;\n                    }\n                }\n                if (pinned[mask] != any) {\n                    out.println(\"Impossible\");\n                    return;\n                }\n            }\n\n            out.println(\"Possible\");\n            out.println(1 + 2 * n);\n            out.printf(\"%d %d\\n\", 0, 0);\n            for (int i = 0; i < n; i++) {\n                if (pinned[1 << i]) {\n                    out.printf(\"%d %d\\n\", i + 1, +1);\n                } else {\n                    out.printf(\"%d %d\\n\", i + 1, -1);\n                }\n                out.printf(\"%d %d\\n\", i + 1, 0);\n            }\n            out.printf(\"%d %d\\n\", 0, 0);\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String rl = in.readLine();\n                    if (rl == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(rl);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        char[] str = sc.next().toCharArray();\n\n        //引っかかるところを探す\n        boolean a[] = new boolean[1 << n];\n        for(int i = 0 ; i < (1 << n) ; i++){\n            a[i] = str[i] == '0';\n        }\n\n        boolean pick[] = new boolean[n];\n        for(int i = 0 ; i < n ; i++){\n            pick[i] = a[(1 << (i+1))-1];\n        }\n\n        boolean ans = true;\n        for(int i = 0 ; i < (1 << n) ; i++){\n            for(int j = 0 ; j < n ; j++){\n                if(((i >> j)&1) == 1){\n                    if(pick[j] && !a[i]){\n                        ans = false;\n                    }\n                }\n            }\n        }\n\n        System.out.println(ans?\"Possible\":\"Impossible\");\n        boolean prev = false;\n        int l = 0;\n\n        if(ans){\n            for(int i = 0 ; i < n ; i++){\n                if(prev){\n                    if(pick[i]){\n                        l++;\n                    }else{\n                        l++;\n                        l++;\n                    }\n                }else{\n                    if(pick[i]){\n                        l++;\n                        l++;\n                    }else{\n                        l++;\n                    }\n                }\n                prev = pick[i];\n            }\n\n            for(int i = prev?n:n-1 ; i >= 0 ; i--){\n                l++;\n            }\n\n            prev = false;\n\n            System.out.println(l);\n            System.out.println(\"0 0\");\n            for(int i = 0 ; i < n ; i++){\n                if(prev){\n                    if(pick[i]){\n                        System.out.println(\"\"+(i+1)+\" 1\");\n                    }else{\n                        System.out.println(\"\"+(i)+\" 0\");\n                        System.out.println(\"\"+(i+1)+\" 0\");\n                    }\n                }else{\n                    if(pick[i]){\n                        System.out.println(\"\"+(i)+\" 1\");\n                        System.out.println(\"\"+(i+1)+\" 1\");\n                    }else{\n                        System.out.println(\"\"+(i+1)+\" 0\");\n                    }\n                }\n                prev = pick[i];\n            }\n\n            for(int i = (prev?n:n-1) ; i >= 0 ; i--){\n                System.out.println(\"\"+i+\" 0\");\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        char[] str = sc.next().toCharArray();\n\n        //引っかかるところを探す\n        boolean a[] = new boolean[1 << n];\n        for(int i = 0 ; i < (1 << n) ; i++){\n            a[i] = str[i] == '0';\n        }\n\n        boolean pick[] = new boolean[n];\n        for(int i = 0 ; i < n ; i++){\n            pick[i] = a[1 << i];\n        }\n\n        boolean ans = true;\n        for(int i = 0 ; i < (1 << n) ; i++){\n            for(int j = 0 ; j < n ; j++){\n                if(((i >> j)&1) == 1){\n                    if(pick[j] && !a[i]){\n                        ans = false;\n                    }\n                }\n            }\n        }\n\n        System.out.println(ans?\"Possible\":\"Impossible\");\n        boolean prev = false;\n        int l = 0;\n\n        if(ans){\n            for(int i = 0 ; i < n ; i++){\n                if(prev){\n                    if(pick[i]){\n                        l++;\n                    }else{\n                        l++;\n                        l++;\n                    }\n                }else{\n                    if(pick[i]){\n                        l++;\n                        l++;\n                    }else{\n                        l++;\n                    }\n                }\n                prev = pick[i];\n            }\n\n            for(int i = prev?n:n-1 ; i >= 0 ; i--){\n                l++;\n            }\n\n            System.out.println(l);\n            System.out.println(\"0 0\");\n            for(int i = 0 ; i < n ; i++){\n                if(prev){\n                    if(pick[i]){\n                        System.out.println(\"\"+(i+1)+\" 1\");\n                    }else{\n                        System.out.println(\"\"+(i)+\" 0\");\n                        System.out.println(\"\"+(i+1)+\" 0\");\n                    }\n                }else{\n                    if(pick[i]){\n                        System.out.println(\"\"+(i)+\" 1\");\n                        System.out.println(\"\"+(i+1)+\" 1\");\n                    }else{\n                        System.out.println(\"\"+(i+1)+\" 0\");\n                    }\n                }\n                prev = pick[i];\n            }\n\n            for(int i = prev?n:n-1 ; i >= 0 ; i--){\n                System.out.println(\"\"+i+\" 0\");\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        E_Topology solver = new E_Topology();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class E_Topology {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int n = in.nextInt();\n            char[] s = in.next().toCharArray();\n            boolean[] pinned = new boolean[1 << n];\n            for (int i = 0; i < 1 << n; i++) {\n                pinned[i] = s[i] == '0';\n            }\n            List<String> ans = new ArrayList<>();\n            for (int mask = 0; mask < 1 << n; mask++) {\n                boolean any = false;\n                for (int i = 0; i < n; i++) {\n                    if ((mask & (1 << i)) == 0) {\n                        continue;\n                    }\n                    if (pinned[1 << i]) {\n                        any = true;\n                    }\n                }\n                if (pinned[mask] == any) {\n                    ans.add(String.format(\"%d %d\", 0, 0));\n                    for (int i = 0; i < n; i++) {\n                        if ((mask & (1 << i)) != 0) {\n                            ans.add(String.format(\"%d %d\", i, 1));\n                            ans.add(String.format(\"%d %d\", i + 1, 1));\n                        }\n                        ans.add(String.format(\"%d %d\", i + 1, 0));\n                    }\n                    for (int i = n - 1; i >= 0; i--) {\n                        ans.add(String.format(\"%d %d\", i, 0));\n                    }\n                    continue;\n                }\n                if (any) {\n                    out.println(\"Impossible\");\n                    return;\n                }\n\n                // !any && pinned[mask]\n                throw new AssertionError();\n            }\n\n            out.println(\"Possible\");\n            out.println(ans.size() - 1);\n            for (String str : ans) {\n                out.println(str);\n            }\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String rl = in.readLine();\n                    if (rl == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(rl);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        char[] str = sc.next().toCharArray();\n\n        //引っかかるところを探す\n        boolean a[] = new boolean[1 << n];\n        for(int i = 0 ; i < (1 << n) ; i++){\n            a[i] = (str[i] == '0');\n        }\n\n        boolean pick[] = new boolean[n];\n        for(int i = 0 ; i < n ; i++){\n            pick[i] = a[1 << i];\n        }\n\n        boolean ans = true;\n        for(int i = 0 ; i < (1 << n) ; i++){\n            for(int j = 0 ; j < n ; j++){\n                if(((i >> j) & 1) == 1){\n                    if(pick[j] && !a[i]){\n                        ans = false;\n                    }\n                }\n            }\n        }\n\n        System.out.println(ans?\"Possible\":\"Impossible\");\n        boolean prev = false;\n        int l = 0;\n\n        if(ans){\n            for(int i = 0 ; i < n ; i++){\n                if(prev){\n                    if(pick[i]){\n                        l++;\n                    }else{\n                        l++;\n                        l++;\n                    }\n                }else{\n                    if(pick[i]){\n                        l++;\n                        l++;\n                    }else{\n                        l++;\n                    }\n                }\n                prev = pick[i];\n            }\n\n            for(int i = prev?n:n-1 ; i >= 0 ; i--){\n                l++;\n            }\n\n            prev = false;\n\n            System.out.println(l);\n            System.out.println(\"0 0\");\n            for(int i = 0 ; i < n ; i++){\n                if(prev){\n                    if(pick[i]){\n                        System.out.println(\"\"+(i+1)+\" 1\");\n                    }else{\n                        System.out.println(\"\"+(i)+\" 0\");\n                        System.out.println(\"\"+(i+1)+\" 0\");\n                    }\n                }else{\n                    if(pick[i]){\n                        System.out.println(\"\"+(i)+\" 1\");\n                        System.out.println(\"\"+(i+1)+\" 1\");\n                    }else{\n                        System.out.println(\"\"+(i+1)+\" 0\");\n                    }\n                }\n                prev = pick[i];\n            }\n\n            for(int i = (prev?n:n-1) ; i >= 0 ; i--){\n                System.out.println(\"\"+i+\" 0\");\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n    //2桁目以降どっか０だったら全部ゼロじゃないとImpossible？\n    //1桁目は1じゃなかったらImpossible\n    int N = sc.nextInt();\n    int A[] = new int[(int)Math.pow(2,N)];\n    String s = sc.next();\n    for(int i=0;i<A.length;i++){\n      A[i]=Integer.parseInt(s.substring(i,i+1));\n    }\n    if(A[0]!=0){\n      System.out.println(\"Impossible\");\n      return;\n    }\n    \n    \n  }\n  \n\n  \n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        char[] str = sc.next().toCharArray();\n\n        //引っかかるところを探す\n        boolean a[] = new boolean[1 << n];\n        for(int i = 0 ; i < (1 << n) ; i++){\n            a[i] = str[i] == '0';\n        }\n\n        boolean pick[] = new boolean[n];\n        for(int i = 0 ; i < n ; i++){\n            pick[i] = a[1 << i];\n        }\n\n        boolean ans = true;\n        for(int i = 0 ; i < (1 << n) ; i++){\n            for(int j = 0 ; j < n ; j++){\n                if(((i >> j)&1) == 1){\n                    if(pick[j] && !a[i]){\n                        ans = false;\n                    }\n                }\n            }\n        }\n\n        System.out.println(ans?\"Possible\":\"Impossible\");\n        boolean prev = false;\n        int l = 0;\n\n        if(ans){\n            for(int i = 0 ; i < n ; i++){\n                if(prev){\n                    if(pick[i]){\n                        l++;\n                    }else{\n                        l++;\n                        l++;\n                    }\n                }else{\n                    if(pick[i]){\n                        l++;\n                        l++;\n                    }else{\n                        l++;\n                    }\n                }\n                prev = pick[i];\n            }\n\n            for(int i = prev?n:n-1 ; i >= 0 ; i--){\n                l++;\n            }\n            \n            prev = false;\n\n            System.out.println(l);\n            System.out.println(\"0 0\");\n            for(int i = 0 ; i < n ; i++){\n                if(prev){\n                    if(pick[i]){\n                        System.out.println(\"\"+(i+1)+\" 1\");\n                    }else{\n                        System.out.println(\"\"+(i)+\" 0\");\n                        System.out.println(\"\"+(i+1)+\" 0\");\n                    }\n                }else{\n                    if(pick[i]){\n                        System.out.println(\"\"+(i)+\" 1\");\n                        System.out.println(\"\"+(i+1)+\" 1\");\n                    }else{\n                        System.out.println(\"\"+(i+1)+\" 0\");\n                    }\n                }\n                prev = pick[i];\n            }\n\n            for(int i = prev?n:n-1 ; i >= 0 ; i--){\n                System.out.println(\"\"+i+\" 0\");\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        char[] str = sc.next().toCharArray();\n\n        //引っかかるところを探す\n        boolean a[] = new boolean[1 << n];\n        for(int i = 0 ; i < (1 << n) ; i++){\n            a[i] = str[i] == '0';\n        }\n\n        boolean pick[] = new boolean[n];\n        for(int i = 0 ; i < n ; i++){\n            pick[i] = a[1 << i];\n        }\n\n        boolean ans = true;\n        for(int i = 0 ; i < (1 << n) ; i++){\n            for(int j = 0 ; j < n ; j++){\n                if(((i >> j)&1) == 1){\n                    if(pick[j] && !a[i]){\n                        ans = false;\n                    }\n                }\n            }\n        }\n\n        System.out.println(ans?\"Possible\":\"Impossible\");\n        boolean prev = false;\n        int l = 2;\n\n        if(ans){\n            for(int i = 0 ; i < n ; i++){\n                if(prev){\n                    if(pick[i]){\n                        l++;\n                    }else{\n                        l++;\n                        l++;\n                    }\n                }else{\n                    if(pick[i]){\n                        l++;\n                        l++;\n                    }else{\n                        l++;\n                    }\n                }\n                prev = pick[i];\n            }\n\n            for(int i = prev?n:n-1 ; i >= 0 ; i--){\n                l++;\n            }\n\n            prev = false;\n\n            System.out.println(l);\n            System.out.println(\"0 0\");\n            System.out.println(\"0 1\");\n            System.out.println(\"0 0\");\n            for(int i = 0 ; i < n ; i++){\n                if(prev){\n                    if(pick[i]){\n                        System.out.println(\"\"+(i+1)+\" 1\");\n                    }else{\n                        System.out.println(\"\"+(i)+\" 0\");\n                        System.out.println(\"\"+(i+1)+\" 0\");\n                    }\n                }else{\n                    if(pick[i]){\n                        System.out.println(\"\"+(i)+\" 1\");\n                        System.out.println(\"\"+(i+1)+\" 1\");\n                    }else{\n                        System.out.println(\"\"+(i+1)+\" 0\");\n                    }\n                }\n                prev = pick[i];\n            }\n\n            for(int i = prev?n:n-1 ; i >= 0 ; i--){\n                System.out.println(\"\"+i+\" 0\");\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.System.arraycopy;\nimport static java.lang.System.exit;\nimport static java.util.Arrays.copyOf;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic class IntList {\n\n\t\tint data[] = new int[3];\n\t\tint size = 0;\n\n\t\tboolean isEmpty() {\n\t\t\treturn size == 0;\n\t\t}\n\n\t\tint size() {\n\t\t\treturn size;\n\t\t}\n\n\t\tint get(int index) {\n\t\t\tif (index < 0 || index >= size) {\n\t\t\t\tthrow new IndexOutOfBoundsException();\n\t\t\t}\n\t\t\treturn data[index];\n\t\t}\n\n\t\tvoid clear() {\n\t\t\tsize = 0;\n\t\t}\n\n\t\tvoid set(int index, int value) {\n\t\t\tif (index < 0 || index >= size) {\n\t\t\t\tthrow new IndexOutOfBoundsException();\n\t\t\t}\n\t\t\tdata[index] = value;\n\t\t}\n\n\t\tvoid expand() {\n\t\t\tif (size >= data.length) {\n\t\t\t\tdata = copyOf(data, (data.length << 1) + 1);\n\t\t\t}\n\t\t}\n\n\t\tvoid insert(int index, int value) {\n\t\t\tif (index < 0 || index > size) {\n\t\t\t\tthrow new IndexOutOfBoundsException();\n\t\t\t}\n\t\t\texpand();\n\t\t\tarraycopy(data, index, data, index + 1, size++ - index);\n\t\t\tdata[index] = value;\n\t\t}\n\n\t\tint delete(int index) {\n\t\t\tif (index < 0 || index >= size) {\n\t\t\t\tthrow new IndexOutOfBoundsException();\n\t\t\t}\n\t\t\tint value = data[index];\n\t\t\tarraycopy(data, index + 1, data, index, --size - index);\n\t\t\treturn value;\n\t\t}\n\n\t\tvoid push(int value) {\n\t\t\texpand();\n\t\t\tdata[size++] = value;\n\t\t}\n\n\t\tint pop() {\n\t\t\tif (size == 0) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t\treturn data[--size];\n\t\t}\n\n\t\tvoid unshift(int value) {\n\t\t\texpand();\n\t\t\tarraycopy(data, 0, data, 1, size++);\n\t\t\tdata[0] = value;\n\t\t}\n\n\t\tint shift() {\n\t\t\tif (size == 0) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t\tint value = data[0];\n\t\t\tarraycopy(data, 1, data, 0, --size);\n\t\t\treturn value;\n\t\t}\n\t}\n\n\tstatic IntList ans;\n\n\tstatic void go(int pos, int mask) {\n\t\tans.push(pos + 1);\n\t\tans.push(0);\n\t\tif ((mask & (1 << pos)) != 0) {\n\t\t\tans.push(pos + 1);\n\t\t\tans.push(1);\n\t\t\tans.push(pos);\n\t\t\tans.push(1);\n\t\t\tif (mask != 1 << pos) {\n\t\t\t\tint submask = mask ^ (1 << pos);\n\t\t\t\tans.push(pos);\n\t\t\t\tans.push(0);\n\t\t\t\tans.push(pos + 1);\n\t\t\t\tans.push(0);\n\t\t\t\tgo(pos + 1, submask);\n\t\t\t\tans.push(pos);\n\t\t\t\tans.push(0);\n\t\t\t\tans.push(pos);\n\t\t\t\tans.push(1);\n\t\t\t\tans.push(pos + 1);\n\t\t\t\tans.push(1);\n\t\t\t\tans.push(pos + 1);\n\t\t\t\tans.push(0);\n\t\t\t\tgoInv(pos + 1, submask);\n\t\t\t}\n\t\t} else {\n\t\t\tgo(pos + 1, mask);\n\t\t}\n\t\tans.push(pos);\n\t\tans.push(0);\n\t}\n\n\tstatic void goInv(int pos, int mask) {\n\t\tif ((mask & (1 << pos)) != 0) {\n\t\t\tif (mask != 1 << pos) {\n\t\t\t\tint submask = mask ^ (1 << pos);\n\t\t\t\tans.push(pos + 1);\n\t\t\t\tans.push(0);\n\t\t\t\tgo(pos + 1, submask);\n\t\t\t\tans.push(pos + 1);\n\t\t\t\tans.push(1);\n\t\t\t\tans.push(pos);\n\t\t\t\tans.push(1);\n\t\t\t\tans.push(pos);\n\t\t\t\tans.push(0);\n\t\t\t\tans.push(pos + 1);\n\t\t\t\tans.push(0);\n\t\t\t\tgoInv(pos + 1, submask);\n\t\t\t\tans.push(pos);\n\t\t\t\tans.push(0);\n\t\t\t}\n\t\t\tans.push(pos);\n\t\t\tans.push(1);\n\t\t\tans.push(pos + 1);\n\t\t\tans.push(1);\n\t\t\tans.push(pos + 1);\n\t\t\tans.push(0);\n\t\t} else {\n\t\t\tans.push(pos + 1);\n\t\t\tans.push(0);\n\t\t\tgoInv(pos + 1, mask);\n\t\t}\n\t\tans.push(pos);\n\t\tans.push(0);\n\t}\n\n\tstatic void solve() throws Exception {\n\t\tint n = scanInt();\n\t\tString a = scanString();\n\t\tans = new IntList();\n\t\tans.push(0);\n\t\tans.push(0);\n\t\tfor (int i = 0; i < 1 << n; i++) {\n\t\t\tif (a.charAt(i) == '0') {\n\t\t\t\tboolean sm = true;\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif ((i & (1 << j)) == 0) {\n\t\t\t\t\t\tif (a.charAt(i | (1 << j)) != '0') {\n\t\t\t\t\t\t\tout.print(\"Impossible\");\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (a.charAt(i ^ (1 << j)) == '0') {\n\t\t\t\t\t\t\tsm = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (sm) {\n\t\t\t\t\tgo(0, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(\"Possible\");\n\t\tout.println(ans.size / 2);\n\t\tfor (int i = 0; i < ans.size; i += 2) {\n\t\t\tout.println(ans.data[i] + \" \" + ans.data[i + 1]);\n\t\t}\n//\t\tif (ans.data[0] != 0 || ans.data[1] != 0 || ans.data[ans.size - 2] != 0 || ans.data[ans.size - 1] != 0) {\n//\t\t\tthrow new AssertionError();\n//\t\t}\n//\t\tfor (int i = 0; i < ans.size - 2; i += 2) {\n//\t\t\tif (abs(ans.data[i] - ans.data[i + 2]) + abs(ans.data[i + 1] - ans.data[i + 3]) != 1) {\n//\t\t\t\tthrow new AssertionError();\n//\t\t\t}\n//\t\t}\n\t}\n\n\tstatic int scanInt() throws IOException {\n\t\treturn parseInt(scanString());\n\t}\n\n\tstatic long scanLong() throws IOException {\n\t\treturn parseLong(scanString());\n\t}\n\n\tstatic String scanString() throws IOException {\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer tok;\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\texit(1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        E_Topology solver = new E_Topology();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class E_Topology {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int n = in.nextInt();\n            char[] s = in.next().toCharArray();\n            boolean[] pinned = new boolean[1 << n];\n            for (int i = 0; i < 1 << n; i++) {\n                pinned[i] = s[i] == '0';\n            }\n            for (int mask = 0; mask < 1 << n; mask++) {\n                boolean any = false;\n                for (int i = 0; i < n; i++) {\n                    if ((mask & (1 << i)) == 0) {\n                        continue;\n                    }\n                    if (pinned[1 << i]) {\n                        any = true;\n                    }\n                }\n                if (pinned[mask] != any) {\n//                out.println(\"Impossible\");\n//                return;\n                    if (any) {\n                        out.println(\"Impossible\");\n                        return;\n                    }\n                    throw new AssertionError();\n                }\n            }\n\n            List<String> ans = new ArrayList<>();\n            ans.add(String.format(\"%d %d\", 0, 0));\n            for (int i = 0; i < n; i++) {\n                if (pinned[1 << i]) {\n                    ans.add(String.format(\"%d %d\", i, 1));\n                    ans.add(String.format(\"%d %d\", i + 1, 1));\n                }\n                ans.add(String.format(\"%d %d\", i + 1, 0));\n            }\n            for (int i = n - 1; i >= 0; i--) {\n                ans.add(String.format(\"%d %d\", i, 0));\n            }\n            out.println(\"Possible\");\n            out.println(ans.size() - 1);\n            for (String str : ans) {\n                out.println(str);\n            }\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String rl = in.readLine();\n                    if (rl == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(rl);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n      System.out.println(\"Impossible\");\n    }\n}\n"
  },
  {
    "language": "Ruby",
    "code": "\n*z,Q=[h=0,0],->i,j{i<2?[[j,1],[j,0]]:(s=Q[i/2,j+1];i%2<1?s:[a=[j,1],*s,a,a=[j,0],*s.reverse,a])}\n\nN=gets.to_i\n\nA=gets.chars{|c|\n\nc==?0&&(Q[h,0].map{|q,r|\n\nx,y=z[-1]\n\ny<1&&z<<[x,1]\n\n(q<x ?x.downto(t=q+1):(x..t=q)).map{|s|z<<[s,0]}\n\nr>0&&z<<[t,1]\n\nz<<[2*q+1-t,r]\n\n})\n\nh+=1\n\n}\n\nputs [*0...1<<N].combination(2).any?{|i,j|i&j==i&&A[i]<A[j]}?:Impossible:[:Possible,z.size,z.map{|z|z*?\\s}]\n"
  },
  {
    "language": "Ruby",
    "code": "N = gets.to_i\nA = gets.chomp.chars.map &:to_i\n\nsingle = (0...N).filter{|i| A[1<<i] == 0 }\ndouble = [*0...N].combination(2).filter{|i,j| A[(1<<i) + (1<<j)] == 0 }\n\n#p single, double\n\nif A.each_with_index.any?{|a,d|\n    a != (single.any?{|i| d[i]==1 } || double.any?{|i,j| d[i]==1&&d[j]==1 } ? 0 : 1)\n  } then\n  puts \"Impossible\"\n  exit\nend\n\nputs \"Possible\"\n\nans = [[0,0]]\nsingle.each do |i|\n  1.upto(i){|k| ans << [k,0] }\n  ans << [i,1]\n  ans << [i+1,1]\n  (i+1).downto(0){|k| ans << [k,0] }\nend\ndouble.each do |i,j|\n  1.upto(i){|k| ans << [k,0] }\n  i.upto(j+1){|k| ans << [k,1] }\n  ans << [j+1,0]\n  ans << [j,0]\n  j.downto(i){|k| ans << [k,1] }\n  i.upto(j){|k| ans << [k,0] }\n  ans << [j,1]\n  ans << [j+1,1]\n  (j+1).downto(0){|k| ans << [k,0] }\nend\n\nputs ans.size\nputs ans.map{|x,y| \"#{x} #{y}\" }\n"
  },
  {
    "language": "Ruby",
    "code": "\n*Z,Q=[h=0,1],->i,j{i<2?[[j,1],[j,0]]:(s=Q[i/2,j+1];i%2<1?s:[a=[j,1],*s,a,a=[j,0],*s.reverse,a])}\n\nG=->((q,r)){\n\nx,y=Z[-1]\n\n(q<x ?x.downto(t=q+1):(x..t=q)).map{|s|Z<<[s,0]}\n\nr>0&&Z<<[t,1]\n\nZ<<[u=2*q+1-t,r]\n\nr<1&&Z<<[u,1]\n\n}\n\nN=gets.to_i\n\nA=gets.chars{|c|\n\nc==?0&&(0...1<<N).all?{|j|h&j!=h||h==j||$_[j]>?0}&&Q[h,0].map(&G)\n\nh+=1\n\n}\n\nZ[-1][0]>0&&G[0,0]\n\nputs [*0...1<<N].combination(2).any?{|i,j|i&j==i&&A[i]<A[j]}?:Impossible:[:Possible,Z.size-1,Z.map{|z|z*?\\s}]\n"
  },
  {
    "language": "Ruby",
    "code": "\n*Z,Q=[h=0,1],->i,j{i<2?[[j,1],[j,0]]:(s=Q[i/2,j+1];i%2<1?s:[a=[j,1],*s,a,a=[j,0],*s.reverse,a])}\n\nG=->((q,r)){\n\nx,y=Z[-1]\n\n(q<x ?x.downto(t=q+1):(x..t=q)).map{|s|Z<<[s,0]}\n\nr>0&&Z<<[t,1]\n\nZ<<[u=2*q+1-t,r]\n\nr<1&&Z<<[u,1]\n\n}\n\nN=gets.to_i\n\nA=gets.chars{|c|\n\nc==?0&&(0...1<<N).all?{|j|h&j!=j||h==j||$_[j]>?0}&&Q[h,0].map(&G)\n\nh+=1\n\n}\n\nZ[-1][0]>0&&G[[0,0]]\n\nputs [*0...1<<N].combination(2).any?{|i,j|i&j==i&&A[i]<A[j]}?:Impossible:[:Possible,Z.size-1,Z.map{|z|z*?\\s}]\n"
  },
  {
    "language": "Ruby",
    "code": "\n*z,Q=[h=0,0],->i,j{i<2?[[j,1],[j,0]]:(s=Q[i/2,j+1];i%2<1?s:[a=[j,1],*s,a,a=[j,0],*s.reverse,a])}\n\nN=gets.to_i\n\nA=gets.chars{|c|\n\nc==?0&&(Q[h,0].map{|q,r|\n\nx,y=z[-1]\n\ny<1&&z<<[x,1]\n\n(q<x ?x.downto(t=q+1):(x..t=q)).map{|s|z<<[s,0]}\n\nr>0&&z<<[t,1]\n\nz<<[2*q+1-t,r]\n\n})\n\nh+=1\n\n}\n\nputs [*0...1<<N].combination(2).any?{|i,j|i&j==i&&A[i]<A[j]}?:Impossible:[:Possible,z.size-1,z.map{|z|z*?\\s}]\n"
  },
  {
    "language": "Ruby",
    "code": "N = gets.to_i\nA = gets.chomp.chars.map &:to_i\n\nsingle = [*0...N].select{|i| A[1<<i] == 0 }\ndouble = [*0...N].combination(2).select{|i,j| A[(1<<i) + (1<<j)] == 0 }\n\n#p single, double\n\nif A.each_with_index.any?{|a,d|\n    a != (single.any?{|i| d[i]==1 } || double.any?{|i,j| d[i]==1&&d[j]==1 } ? 0 : 1)\n  } then\n  puts \"Impossible\"\n  exit\nend\n\nputs \"Possible\"\n\nans = [[0,0]]\nsingle.each do |i|\n  1.upto(i){|k| ans << [k,0] }\n  ans << [i,1]\n  ans << [i+1,1]\n  (i+1).downto(0){|k| ans << [k,0] }\nend\ndouble.each do |i,j|\n  1.upto(i){|k| ans << [k,0] }\n  i.upto(j+1){|k| ans << [k,1] }\n  ans << [j+1,0]\n  ans << [j,0]\n  j.downto(i){|k| ans << [k,1] }\n  i.upto(j){|k| ans << [k,0] }\n  ans << [j,1]\n  ans << [j+1,1]\n  (j+1).downto(0){|k| ans << [k,0] }\nend\n\nputs ans.size\nputs ans.map{|x,y| \"#{x} #{y}\" }\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.range, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.bitmanip, std.complex, std.container, std.math, std.mathspecial, std.numeric, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\n\n\nvoid main() {\n  enum MAX_N = 8;\n  auto dp = new int[][MAX_N + 1];\n  dp[1] = [0];\n  foreach (m; 2 .. MAX_N + 1) {\n    dp[m] ~= (m - 1) << 1;\n    foreach (z; dp[m - 1]) {\n      dp[m] ~= z;\n    }\n    dp[m] ~= (m - 1) << 1 | 1;\n    foreach_reverse (z; dp[m - 1]) {\n      dp[m] ~= z ^ 1;\n    }\n  }\n  debug {\n    foreach (m; 1 .. MAX_N + 1) {\n      writefln(\"dp[%s] = %s\", m, dp[m].map!(z => format(\"%s%s\", \"+-\"[z & 1], z >> 1)));\n    }\n    writeln(dp.map!(seq => seq.length));\n  }\n  \n  try {\n    for (; ; ) {\n      const N = readInt();\n      const A = readToken();\n      \n      const B = A.map!\"a == '1'\".array;\n      \n      bool valid = true;\n      foreach (p; 0 .. 1 << N) {\n        foreach (u; 0 .. N) {\n          if (!(p & 1 << u)) {\n            if (!B[p] && B[p | 1 << u]) {\n              valid = false;\n            }\n          }\n        }\n      }\n      if (valid) {\n        int[] seq;\n        foreach (p; 1 .. 1 << N) {\n          if (!B[p]) {\n            bool maximal = true;\n            foreach (u; 0 .. N) {\n              if (p & 1 << u) {\n                if (!B[p ^ 1 << u]) {\n                  maximal = false;\n                }\n              }\n            }\n            if (maximal) {\n              debug {\n                writeln(\"maximal p = \", p);\n              }\n              int[] us;\n              foreach (u; 0 .. N) {\n                if (p & 1 << u) {\n                  us ~= u;\n                }\n              }\n              foreach (z; dp[us.length]) {\n                seq ~= us[z >> 1] << 1 | (z & 1);\n              }\n            }\n          }\n        }\n        debug {\n          writeln(seq.map!(z => format(\"%s%s\", \"+-\"[z & 1], z >> 1)));\n        }\n        \n        debug {\n          foreach (p; 0 .. 1 << N) {\n            DList!int stack;\n            foreach (z; seq) {\n              if (p & 1 << (z >> 1)) {\n                if (!stack.empty && (stack.back ^ z) == 1) {\n                  stack.removeBack;\n                } else {\n                  stack ~= z;\n                }\n              }\n            }\n            assert(B[p] == stack.empty);\n          }\n        }\n        \n        alias Pt = Tuple!(int, \"x\", int, \"y\");\n        Pt[] ps;\n        ps ~= Pt(0, 0);\n        int x = 0;\n        foreach (z; seq) {\n          for (; x < (z >> 1); ) ps ~= Pt(++x, 0);\n          for (; x > (z >> 1); ) ps ~= Pt(--x, 0);\n          if (z & 1) {\n            ps ~= Pt(x, 1);\n            ps ~= Pt(x + 1, 1);\n            ps ~= Pt(x + 1, 0);\n            ps ~= Pt(x, 0);\n          } else {\n            ps ~= Pt(x + 1, 0);\n            ps ~= Pt(x + 1, 1);\n            ps ~= Pt(x, 1);\n            ps ~= Pt(x, 0);\n          }\n        }\n        for (; 0 < x; ) ps ~= Pt(--x, 0);\n        stderr.writeln(\"L = \", cast(int)(ps.length) - 1);\n        writeln(\"Possible\");\n        writeln(cast(int)(ps.length) - 1);\n        foreach (ref p; ps) {\n          writeln(p.x, \" \", p.y);\n        }\n      } else {\n        writeln(\"Impossible\");\n      }\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "Nim",
    "code": "#{{{ header\n{.hints:off warnings:off optimization:speed.}\nimport algorithm, sequtils, tables, macros, math, sets, strutils\nwhen defined(MYDEBUG):\n  import header\n\nimport streams\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\n#proc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(): int = scanf(\"%lld\",addr result)\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString[F](f:F): string =\n  var get = false\n  result = \"\"\n  while true:\n#    let c = getchar()\n    let c = f.readChar\n    if c.int > ' '.int:\n      get = true\n      result.add(c)\n    elif get: return\nproc nextInt[F](f:F): int = parseInt(f.nextString)\nproc nextFloat[F](f:F): float = parseFloat(f.nextString)\nproc nextString():string = stdin.nextString()\n\ntype SomeSignedInt = int|int8|int16|int32|int64|BiggestInt\ntype SomeUnsignedInt = uint|uint8|uint16|uint32|uint64\ntype SomeInteger = SomeSignedInt|SomeUnsignedInt\ntype SomeFloat = float|float32|float64|BiggestFloat\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate inf(T): untyped = \n  when T is SomeFloat: T(Inf)\n  elif T is SomeInteger: ((T(1) shl T(sizeof(T)*8-2)) - (T(1) shl T(sizeof(T)*4-1)))\n  else: assert(false)\n\nproc sort[T](v: var seq[T]) = v.sort(cmp[T])\nproc discardableId[T](x: T): T {.discardable.} =\n  return x\nmacro `:=`(x, y: untyped): untyped =\n  if (x.kind == nnkIdent):\n    return quote do:\n      when declaredInScope(`x`):\n        `x` = `y`\n      else:\n        var `x` = `y`\n      discardableId(`x`)\n  else:\n    return quote do:\n      `x` = `y`\n      discardableId(`x`)\nmacro dump*(x: typed): untyped =\n  let s = x.toStrLit\n  let r = quote do:\n    debugEcho `s`, \" = \", `x`\n  return r\n\nproc toStr[T](v:T):string =\n  proc `$`[T](v:seq[T]):string =\n    v.mapIt($it).join(\" \")\n  return $v\n\nproc print0(x: varargs[string, toStr]; sep:string):string{.discardable.} =\n  result = \"\"\n  for i,v in x:\n    if i != 0: addSep(result, sep = sep)\n    add(result, v)\n  result.add(\"\\n\")\n  stdout.write result\n\nvar print:proc(x: varargs[string, toStr])\nprint = proc(x: varargs[string, toStr]) =\n  discard print0(@x, sep = \" \")\n\nproc ndSeqImpl[T](lens: seq[int]; init: T; currentDimension, lensLen: static[int]): auto =\n  when currentDimension == lensLen:\n    newSeqWith(lens[currentDimension - 1], init)\n  else:\n    newSeqWith(lens[currentDimension - 1], ndSeqImpl(lens, init, currentDimension + 1, lensLen))\n\ntemplate ndSeq*[T](lens: varargs[int]; init: T): untyped =\n  ndSeqImpl(@lens, init, 1, lens.len)\n#}}}\n\n#{{{ bitutils\nproc bits[B:SomeInteger](v:varargs[int]): B =\n  result = 0\n  for x in v: result = (result or (B(1) shl B(x)))\nproc `[]`[B:SomeInteger](b:B,n:int):int = (b shr n) mod 2\nproc `[]`[B:SomeInteger](b:B,s:Slice[int]):int = (b shr s.a) mod (1 shl (s.b - s.a + 1))\nproc test[B:SomeInteger](b:B,n:int):bool = (if b[n] == 1:true else: false)\nproc set[B:SomeInteger](b:var B,n:int) = b = (b or (B(1) shl B(n)))\nproc unset[B:SomeInteger](b:var B,n:int) = b = (b and (not (B(1) shl B(n))))\nproc `[]=`[B:SomeInteger](b:var B,n:int,t:int) =\n  if t == 0: b.unset(n)\n  elif t == 1: b.set(n)\n  else: assert(false)\nproc writeBits[B:SomeInteger](b:B,n:int) =\n  var n = n * 8\n  for i in countdown(n-1,0):stdout.write(b[i])\n  echo \"\"\nproc setBits[B:SomeInteger](n:int):B = return (B(1) shl B(n)) - B(1)\nproc builtin_ctz(n:int):int =\n  for i in 0..<(8 * sizeof(n)):\n    if n[i] == 1: return i\n  assert(false)\nproc builtin_popcount(n:int):int =\n  result = 0\n  for i in 0..<(8 * sizeof(n)):\n    if n[i] == 1: result += 1\n#}}}\n\nconst YES = \"Possible\"\nconst NO = \"Impossible\"\n\nN := nextInt()\nA := nextString()\n\nproc dist(a, b:(int,int)):int =\n  return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\nproc check(ans: seq[(int,int)]) =\n  doAssert(ans[0] == ans[^1])\n  for i in 0..<ans.len - 1:\n    doAssert(dist(ans[i], ans[i+1]) == 1)\n\nproc main() =\n  ans := newSeq[(int,int)]()\n  inspect := ndSeq(1 shl N, false)\n  for b2 in countdown((1 shl N) - 1, 0):\n    if inspect[b2]: continue\n    v := newSeq[int]()\n    for i in 0..<N:\n      if b2[i] == 1: v.add(i)\n    if A[b2] == '0': continue\n    doAssert(A[b2] == '1')\n    for b0 in 0..<(1 shl v.len):\n      bb := 0\n      for i in 0..<v.len:\n        if b0[i] == 1:\n          bb[v[i]] = 1\n        else:\n          bb[v[i]] = 0\n      if A[bb] == '0':\n        print NO\n        return\n      inspect[bb] = true\n    b3 := 0\n    for i in 0..<N:\n      if b2[i] == 1:\n        b3[i] = 0\n      else:\n        b3[i] = 1\n    ans.add((0, 0))\n    prev := 0\n    for i in 0..<N:\n      if b3[i] == 1:\n        if prev == 0:\n          ans.add((i, 1))\n        ans.add((i + 1, 1))\n      else:\n        if prev == 1:\n          ans.add((i, 0))\n        ans.add((i + 1, 0))\n      prev = b3[i]\n    if prev == 1:\n      ans.add((N, 0))\n    for i in countdown(N - 1, 1):\n      ans.add((i, 0))\n  ans.add((0, 0))\n  check(ans)\n  print YES\n  print ans.len - 1\n  for p in ans:\n    print p[0], p[1]\n  return\n\nmain()"
  },
  {
    "language": "Nim",
    "code": "#{{{ header\n{.hints:off warnings:off optimization:speed.}\nimport algorithm, sequtils, tables, macros, math, sets, strutils\nwhen defined(MYDEBUG):\n  import header\n\nimport streams\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\n#proc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(): int = scanf(\"%lld\",addr result)\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString[F](f:F): string =\n  var get = false\n  result = \"\"\n  while true:\n#    let c = getchar()\n    let c = f.readChar\n    if c.int > ' '.int:\n      get = true\n      result.add(c)\n    elif get: return\nproc nextInt[F](f:F): int = parseInt(f.nextString)\nproc nextFloat[F](f:F): float = parseFloat(f.nextString)\nproc nextString():string = stdin.nextString()\n\ntype SomeSignedInt = int|int8|int16|int32|int64|BiggestInt\ntype SomeUnsignedInt = uint|uint8|uint16|uint32|uint64\ntype SomeInteger = SomeSignedInt|SomeUnsignedInt\ntype SomeFloat = float|float32|float64|BiggestFloat\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate inf(T): untyped = \n  when T is SomeFloat: T(Inf)\n  elif T is SomeInteger: ((T(1) shl T(sizeof(T)*8-2)) - (T(1) shl T(sizeof(T)*4-1)))\n  else: assert(false)\n\nproc sort[T](v: var seq[T]) = v.sort(cmp[T])\nproc discardableId[T](x: T): T {.discardable.} =\n  return x\nmacro `:=`(x, y: untyped): untyped =\n  if (x.kind == nnkIdent):\n    return quote do:\n      when declaredInScope(`x`):\n        `x` = `y`\n      else:\n        var `x` = `y`\n      discardableId(`x`)\n  else:\n    return quote do:\n      `x` = `y`\n      discardableId(`x`)\nmacro dump*(x: typed): untyped =\n  let s = x.toStrLit\n  let r = quote do:\n    debugEcho `s`, \" = \", `x`\n  return r\n\nproc toStr[T](v:T):string =\n  proc `$`[T](v:seq[T]):string =\n    v.mapIt($it).join(\" \")\n  return $v\n\nproc print0(x: varargs[string, toStr]; sep:string):string{.discardable.} =\n  result = \"\"\n  for i,v in x:\n    if i != 0: addSep(result, sep = sep)\n    add(result, v)\n  result.add(\"\\n\")\n  stdout.write result\n\nvar print:proc(x: varargs[string, toStr])\nprint = proc(x: varargs[string, toStr]) =\n  discard print0(@x, sep = \" \")\n\nproc ndSeqImpl[T](lens: seq[int]; init: T; currentDimension, lensLen: static[int]): auto =\n  when currentDimension == lensLen:\n    newSeqWith(lens[currentDimension - 1], init)\n  else:\n    newSeqWith(lens[currentDimension - 1], ndSeqImpl(lens, init, currentDimension + 1, lensLen))\n\ntemplate ndSeq*[T](lens: varargs[int]; init: T): untyped =\n  ndSeqImpl(@lens, init, 1, lens.len)\n#}}}\n\n#{{{ bitutils\nproc bits[B:SomeInteger](v:varargs[int]): B =\n  result = 0\n  for x in v: result = (result or (B(1) shl B(x)))\nproc `[]`[B:SomeInteger](b:B,n:int):int = (b shr n) mod 2\nproc `[]`[B:SomeInteger](b:B,s:Slice[int]):int = (b shr s.a) mod (1 shl (s.b - s.a + 1))\nproc test[B:SomeInteger](b:B,n:int):bool = (if b[n] == 1:true else: false)\nproc set[B:SomeInteger](b:var B,n:int) = b = (b or (B(1) shl B(n)))\nproc unset[B:SomeInteger](b:var B,n:int) = b = (b and (not (B(1) shl B(n))))\nproc `[]=`[B:SomeInteger](b:var B,n:int,t:int) =\n  if t == 0: b.unset(n)\n  elif t == 1: b.set(n)\n  else: assert(false)\nproc writeBits[B:SomeInteger](b:B,n:int) =\n  var n = n * 8\n  for i in countdown(n-1,0):stdout.write(b[i])\n  echo \"\"\nproc setBits[B:SomeInteger](n:int):B = return (B(1) shl B(n)) - B(1)\nproc builtin_ctz(n:int):int =\n  for i in 0..<(8 * sizeof(n)):\n    if n[i] == 1: return i\n  assert(false)\nproc builtin_popcount(n:int):int =\n  result = 0\n  for i in 0..<(8 * sizeof(n)):\n    if n[i] == 1: result += 1\n#}}}\n\nconst YES = \"Possible\"\nconst NO = \"Impossible\"\n\nN := nextInt()\ns := nextString()\n\nproc dist(a, b:(int,int)):int =\n  return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\nproc check(ans: seq[(int,int)]) =\n  doAssert(ans[0] == ans[^1])\n  for i in 0..<ans.len - 1:\n    doAssert(dist(ans[i], ans[i+1]) == 1)\n\nproc main() =\n  ans := newSeq[(int,int)]()\n  inspect := ndSeq(1 shl N, false)\n  for b2 in countdown((1 shl N) - 1, 0):\n    if inspect[b2]: continue\n    v := newSeq[int]()\n    for i in 0..<N:\n      if b2[i] == 1: v.add(i)\n    if s[b2] == '0': continue\n    for b0 in 0..<(1 shl v.len):\n      bb := 0\n      for i in 0..<v.len:\n        if b0[i] == 1:\n          bb[v[i]] = 0\n        else:\n          bb[v[i]] = 1\n      if s[bb] == '0':\n        print NO\n        return\n      inspect[bb] = true\n    ans.add((0, 0))\n    prev := 0\n    for i in 0..<N:\n      if b2[i] == 1:\n        if prev == 0:\n          ans.add((i, 1))\n        ans.add((i + 1, 1))\n      else:\n        if prev == 1:\n          ans.add((i, 0))\n        ans.add((i + 1, 0))\n      prev = b2[i]\n    if prev == 1:\n      ans.add((N, 0))\n    for i in countdown(N - 1, 1):\n      ans.add((i, 0))\n  ans.add((0, 0))\n  check(ans)\n  print YES\n  print ans.len - 1\n  for p in ans:\n    print p[0], p[1]\n  return\n\nmain()"
  },
  {
    "language": "Nim",
    "code": "#{{{ header\n{.hints:off warnings:off optimization:speed.}\nimport algorithm, sequtils, tables, macros, math, sets, strutils\nwhen defined(MYDEBUG):\n  import header\n\nimport streams\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\n#proc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(): int = scanf(\"%lld\",addr result)\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString[F](f:F): string =\n  var get = false\n  result = \"\"\n  while true:\n#    let c = getchar()\n    let c = f.readChar\n    if c.int > ' '.int:\n      get = true\n      result.add(c)\n    elif get: return\nproc nextInt[F](f:F): int = parseInt(f.nextString)\nproc nextFloat[F](f:F): float = parseFloat(f.nextString)\nproc nextString():string = stdin.nextString()\n\ntype SomeSignedInt = int|int8|int16|int32|int64|BiggestInt\ntype SomeUnsignedInt = uint|uint8|uint16|uint32|uint64\ntype SomeInteger = SomeSignedInt|SomeUnsignedInt\ntype SomeFloat = float|float32|float64|BiggestFloat\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate inf(T): untyped = \n  when T is SomeFloat: T(Inf)\n  elif T is SomeInteger: ((T(1) shl T(sizeof(T)*8-2)) - (T(1) shl T(sizeof(T)*4-1)))\n  else: assert(false)\n\nproc sort[T](v: var seq[T]) = v.sort(cmp[T])\nproc discardableId[T](x: T): T {.discardable.} =\n  return x\nmacro `:=`(x, y: untyped): untyped =\n  if (x.kind == nnkIdent):\n    return quote do:\n      when declaredInScope(`x`):\n        `x` = `y`\n      else:\n        var `x` = `y`\n      discardableId(`x`)\n  else:\n    return quote do:\n      `x` = `y`\n      discardableId(`x`)\nmacro dump*(x: typed): untyped =\n  let s = x.toStrLit\n  let r = quote do:\n    debugEcho `s`, \" = \", `x`\n  return r\n\nproc toStr[T](v:T):string =\n  proc `$`[T](v:seq[T]):string =\n    v.mapIt($it).join(\" \")\n  return $v\n\nproc print0(x: varargs[string, toStr]; sep:string):string{.discardable.} =\n  result = \"\"\n  for i,v in x:\n    if i != 0: addSep(result, sep = sep)\n    add(result, v)\n  result.add(\"\\n\")\n  stdout.write result\n\nvar print:proc(x: varargs[string, toStr])\nprint = proc(x: varargs[string, toStr]) =\n  discard print0(@x, sep = \" \")\n\nproc ndSeqImpl[T](lens: seq[int]; init: T; currentDimension, lensLen: static[int]): auto =\n  when currentDimension == lensLen:\n    newSeqWith(lens[currentDimension - 1], init)\n  else:\n    newSeqWith(lens[currentDimension - 1], ndSeqImpl(lens, init, currentDimension + 1, lensLen))\n\ntemplate ndSeq*[T](lens: varargs[int]; init: T): untyped =\n  ndSeqImpl(@lens, init, 1, lens.len)\n#}}}\n\n#{{{ bitutils\nproc bits[B:SomeInteger](v:varargs[int]): B =\n  result = 0\n  for x in v: result = (result or (B(1) shl B(x)))\nproc `[]`[B:SomeInteger](b:B,n:int):int = (b shr n) mod 2\nproc `[]`[B:SomeInteger](b:B,s:Slice[int]):int = (b shr s.a) mod (1 shl (s.b - s.a + 1))\nproc test[B:SomeInteger](b:B,n:int):bool = (if b[n] == 1:true else: false)\nproc set[B:SomeInteger](b:var B,n:int) = b = (b or (B(1) shl B(n)))\nproc unset[B:SomeInteger](b:var B,n:int) = b = (b and (not (B(1) shl B(n))))\nproc `[]=`[B:SomeInteger](b:var B,n:int,t:int) =\n  if t == 0: b.unset(n)\n  elif t == 1: b.set(n)\n  else: assert(false)\nproc writeBits[B:SomeInteger](b:B,n:int) =\n  var n = n * 8\n  for i in countdown(n-1,0):stdout.write(b[i])\n  echo \"\"\nproc setBits[B:SomeInteger](n:int):B = return (B(1) shl B(n)) - B(1)\nproc builtin_ctz(n:int):int =\n  for i in 0..<(8 * sizeof(n)):\n    if n[i] == 1: return i\n  assert(false)\nproc builtin_popcount(n:int):int =\n  result = 0\n  for i in 0..<(8 * sizeof(n)):\n    if n[i] == 1: result += 1\n#}}}\n\nconst YES = \"Possible\"\nconst NO = \"Impossible\"\n\nN := nextInt()\ns := nextString()\n\nproc dist(a, b:(int,int)):int =\n  return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\nproc check(ans: seq[(int,int)]) =\n  doAssert(ans[0] == ans[^1])\n  for i in 0..<ans.len - 1:\n    doAssert(dist(ans[i], ans[i+1]) == 1)\n\nproc main() =\n  for b2 in 0..<(1 shl N): # 1: inner 0: outer\n    valid := true\n    for b in 0..<s.len:\n      if s[b] == '1':\n        if (b and b2) != 0:\n          valid = false\n      else:\n        if (b and b2) == 0:\n          valid = false\n    if valid:\n      doAssert(false)\n      print YES\n      ans := newSeq[(int,int)]()\n      ans.add((0, 0))\n      prev := 0\n      for i in 0..<N:\n        if b2[i] == 1:\n          if prev == 0:\n            ans.add((i, 1))\n          ans.add((i + 1, 1))\n        else:\n          if prev == 1:\n            ans.add((i, 0))\n          ans.add((i + 1, 0))\n        prev = b2[i]\n      if prev == 1:\n        ans.add((N, 0))\n      for i in countdown(N - 1, 0):\n        ans.add((i, 0))\n      check(ans)\n      print ans.len - 1\n      for p in ans:\n        print p[0], p[1]\n      return\n  print NO\n  return\n\nmain()"
  },
  {
    "language": "Nim",
    "code": "#{{{ header\n{.hints:off warnings:off optimization:speed.}\nimport algorithm, sequtils, tables, macros, math, sets, strutils\nwhen defined(MYDEBUG):\n  import header\n\nimport streams\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\n#proc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(): int = scanf(\"%lld\",addr result)\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString[F](f:F): string =\n  var get = false\n  result = \"\"\n  while true:\n#    let c = getchar()\n    let c = f.readChar\n    if c.int > ' '.int:\n      get = true\n      result.add(c)\n    elif get: return\nproc nextInt[F](f:F): int = parseInt(f.nextString)\nproc nextFloat[F](f:F): float = parseFloat(f.nextString)\nproc nextString():string = stdin.nextString()\n\ntype SomeSignedInt = int|int8|int16|int32|int64|BiggestInt\ntype SomeUnsignedInt = uint|uint8|uint16|uint32|uint64\ntype SomeInteger = SomeSignedInt|SomeUnsignedInt\ntype SomeFloat = float|float32|float64|BiggestFloat\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate inf(T): untyped = \n  when T is SomeFloat: T(Inf)\n  elif T is SomeInteger: ((T(1) shl T(sizeof(T)*8-2)) - (T(1) shl T(sizeof(T)*4-1)))\n  else: assert(false)\n\nproc sort[T](v: var seq[T]) = v.sort(cmp[T])\nproc discardableId[T](x: T): T {.discardable.} =\n  return x\nmacro `:=`(x, y: untyped): untyped =\n  if (x.kind == nnkIdent):\n    return quote do:\n      when declaredInScope(`x`):\n        `x` = `y`\n      else:\n        var `x` = `y`\n      discardableId(`x`)\n  else:\n    return quote do:\n      `x` = `y`\n      discardableId(`x`)\nmacro dump*(x: typed): untyped =\n  let s = x.toStrLit\n  let r = quote do:\n    debugEcho `s`, \" = \", `x`\n  return r\n\nproc toStr[T](v:T):string =\n  proc `$`[T](v:seq[T]):string =\n    v.mapIt($it).join(\" \")\n  return $v\n\nproc print0(x: varargs[string, toStr]; sep:string):string{.discardable.} =\n  result = \"\"\n  for i,v in x:\n    if i != 0: addSep(result, sep = sep)\n    add(result, v)\n  result.add(\"\\n\")\n  stdout.write result\n\nvar print:proc(x: varargs[string, toStr])\nprint = proc(x: varargs[string, toStr]) =\n  discard print0(@x, sep = \" \")\n\nproc ndSeqImpl[T](lens: seq[int]; init: T; currentDimension, lensLen: static[int]): auto =\n  when currentDimension == lensLen:\n    newSeqWith(lens[currentDimension - 1], init)\n  else:\n    newSeqWith(lens[currentDimension - 1], ndSeqImpl(lens, init, currentDimension + 1, lensLen))\n\ntemplate ndSeq*[T](lens: varargs[int]; init: T): untyped =\n  ndSeqImpl(@lens, init, 1, lens.len)\n#}}}\n\n#{{{ bitutils\nproc bits[B:SomeInteger](v:varargs[int]): B =\n  result = 0\n  for x in v: result = (result or (B(1) shl B(x)))\nproc `[]`[B:SomeInteger](b:B,n:int):int = (b shr n) mod 2\nproc `[]`[B:SomeInteger](b:B,s:Slice[int]):int = (b shr s.a) mod (1 shl (s.b - s.a + 1))\nproc test[B:SomeInteger](b:B,n:int):bool = (if b[n] == 1:true else: false)\nproc set[B:SomeInteger](b:var B,n:int) = b = (b or (B(1) shl B(n)))\nproc unset[B:SomeInteger](b:var B,n:int) = b = (b and (not (B(1) shl B(n))))\nproc `[]=`[B:SomeInteger](b:var B,n:int,t:int) =\n  if t == 0: b.unset(n)\n  elif t == 1: b.set(n)\n  else: assert(false)\nproc writeBits[B:SomeInteger](b:B,n:int) =\n  var n = n * 8\n  for i in countdown(n-1,0):stdout.write(b[i])\n  echo \"\"\nproc setBits[B:SomeInteger](n:int):B = return (B(1) shl B(n)) - B(1)\nproc builtin_ctz(n:int):int =\n  for i in 0..<(8 * sizeof(n)):\n    if n[i] == 1: return i\n  assert(false)\nproc builtin_popcount(n:int):int =\n  result = 0\n  for i in 0..<(8 * sizeof(n)):\n    if n[i] == 1: result += 1\n#}}}\n\nconst YES = \"Possible\"\nconst NO = \"Impossible\"\n\nN := nextInt()\ns := nextString()\n\nproc dist(a, b:(int,int)):int =\n  return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\nproc check(ans: seq[(int,int)]) =\n  doAssert(ans[0] == ans[^1])\n  for i in 0..<ans.len - 1:\n    doAssert(dist(ans[i], ans[i+1]) == 1)\n\nproc main() =\n  for b2 in 0..<(1 shl N): # 1: inner 0: outer\n    valid := true\n    for b in 0..<s.len:\n      if s[b] == '1':\n        if (b and b2) != 0:\n          valid = false\n      else:\n        if (b and b2) == 0:\n          valid = false\n    if valid:\n      print YES\n      ans := newSeq[(int,int)]()\n      ans.add((0, 0))\n      prev := 0\n      for i in 0..<N:\n        if b2[i] == 1:\n          if prev == 0:\n            ans.add((i, 1))\n          ans.add((i + 1, 1))\n        else:\n          if prev == 1:\n            ans.add((i, 0))\n          ans.add((i + 1, 0))\n        prev = b2[i]\n      if prev == 1:\n        ans.add((N, 0))\n      for i in countdown(N - 1, 0):\n        ans.add((i, 0))\n      check(ans)\n      print ans.len - 1\n      for p in ans:\n        print p[0], p[1]\n      return\n  print NO\n  return\n\nmain()"
  },
  {
    "language": "Nim",
    "code": "#{{{ header\n{.hints:off warnings:off optimization:speed.}\nimport algorithm, sequtils, tables, macros, math, sets, strutils\nwhen defined(MYDEBUG):\n  import header\n\nimport streams\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\n#proc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(): int = scanf(\"%lld\",addr result)\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString[F](f:F): string =\n  var get = false\n  result = \"\"\n  while true:\n#    let c = getchar()\n    let c = f.readChar\n    if c.int > ' '.int:\n      get = true\n      result.add(c)\n    elif get: return\nproc nextInt[F](f:F): int = parseInt(f.nextString)\nproc nextFloat[F](f:F): float = parseFloat(f.nextString)\nproc nextString():string = stdin.nextString()\n\ntype SomeSignedInt = int|int8|int16|int32|int64|BiggestInt\ntype SomeUnsignedInt = uint|uint8|uint16|uint32|uint64\ntype SomeInteger = SomeSignedInt|SomeUnsignedInt\ntype SomeFloat = float|float32|float64|BiggestFloat\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate inf(T): untyped = \n  when T is SomeFloat: T(Inf)\n  elif T is SomeInteger: ((T(1) shl T(sizeof(T)*8-2)) - (T(1) shl T(sizeof(T)*4-1)))\n  else: assert(false)\n\nproc sort[T](v: var seq[T]) = v.sort(cmp[T])\nproc discardableId[T](x: T): T {.discardable.} =\n  return x\nmacro `:=`(x, y: untyped): untyped =\n  if (x.kind == nnkIdent):\n    return quote do:\n      when declaredInScope(`x`):\n        `x` = `y`\n      else:\n        var `x` = `y`\n      discardableId(`x`)\n  else:\n    return quote do:\n      `x` = `y`\n      discardableId(`x`)\nmacro dump*(x: typed): untyped =\n  let s = x.toStrLit\n  let r = quote do:\n    debugEcho `s`, \" = \", `x`\n  return r\n\nproc toStr[T](v:T):string =\n  proc `$`[T](v:seq[T]):string =\n    v.mapIt($it).join(\" \")\n  return $v\n\nproc print0(x: varargs[string, toStr]; sep:string):string{.discardable.} =\n  result = \"\"\n  for i,v in x:\n    if i != 0: addSep(result, sep = sep)\n    add(result, v)\n  result.add(\"\\n\")\n  stdout.write result\n\nvar print:proc(x: varargs[string, toStr])\nprint = proc(x: varargs[string, toStr]) =\n  discard print0(@x, sep = \" \")\n\nproc ndSeqImpl[T](lens: seq[int]; init: T; currentDimension, lensLen: static[int]): auto =\n  when currentDimension == lensLen:\n    newSeqWith(lens[currentDimension - 1], init)\n  else:\n    newSeqWith(lens[currentDimension - 1], ndSeqImpl(lens, init, currentDimension + 1, lensLen))\n\ntemplate ndSeq*[T](lens: varargs[int]; init: T): untyped =\n  ndSeqImpl(@lens, init, 1, lens.len)\n#}}}\n\n#{{{ bitutils\nproc bits[B:SomeInteger](v:varargs[int]): B =\n  result = 0\n  for x in v: result = (result or (B(1) shl B(x)))\nproc `[]`[B:SomeInteger](b:B,n:int):int = (b shr n) mod 2\nproc `[]`[B:SomeInteger](b:B,s:Slice[int]):int = (b shr s.a) mod (1 shl (s.b - s.a + 1))\nproc test[B:SomeInteger](b:B,n:int):bool = (if b[n] == 1:true else: false)\nproc set[B:SomeInteger](b:var B,n:int) = b = (b or (B(1) shl B(n)))\nproc unset[B:SomeInteger](b:var B,n:int) = b = (b and (not (B(1) shl B(n))))\nproc `[]=`[B:SomeInteger](b:var B,n:int,t:int) =\n  if t == 0: b.unset(n)\n  elif t == 1: b.set(n)\n  else: assert(false)\nproc writeBits[B:SomeInteger](b:B,n:int) =\n  var n = n * 8\n  for i in countdown(n-1,0):stdout.write(b[i])\n  echo \"\"\nproc setBits[B:SomeInteger](n:int):B = return (B(1) shl B(n)) - B(1)\nproc builtin_ctz(n:int):int =\n  for i in 0..<(8 * sizeof(n)):\n    if n[i] == 1: return i\n  assert(false)\nproc builtin_popcount(n:int):int =\n  result = 0\n  for i in 0..<(8 * sizeof(n)):\n    if n[i] == 1: result += 1\n#}}}\n\nconst YES = \"Possible\"\nconst NO = \"Impossible\"\n\nN := nextInt()\ns := nextString()\n\n\nproc main() =\n  for b2 in 0..<(1 shl N):\n    valid := true\n    for b in 0..<s.len: # 1: inner 0: outer\n      if s[b] == '1':\n        if (b and b2) != 0:\n          valid = false\n      else:\n        if (b and b2) == 0:\n          valid = false\n    if valid:\n      print YES\n      ans := newSeq[(int,int)]()\n      ans.add((0, 0))\n      prev := 0\n      for i in 0..<N:\n        if b2[i] == 1:\n          if prev == 0:\n            ans.add((i, 1))\n          ans.add((i + 1, 1))\n        else:\n          if prev == 1:\n            ans.add((i, 0))\n          ans.add((i + 1, 0))\n        prev = b2[i]\n      if prev == 1:\n        ans.add((N, 0))\n      for i in countdown(N - 1, 0):\n        ans.add((i, 0))\n      print ans.len - 1\n      for p in ans:\n        print p[0], p[1]\n      return\n  print NO\n  return\n\nmain()"
  },
  {
    "language": "Nim",
    "code": "#{{{ header\n{.hints:off warnings:off optimization:speed.}\nimport algorithm, sequtils, tables, macros, math, sets, strutils\nwhen defined(MYDEBUG):\n  import header\n\nimport streams\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\n#proc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(): int = scanf(\"%lld\",addr result)\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString[F](f:F): string =\n  var get = false\n  result = \"\"\n  while true:\n#    let c = getchar()\n    let c = f.readChar\n    if c.int > ' '.int:\n      get = true\n      result.add(c)\n    elif get: return\nproc nextInt[F](f:F): int = parseInt(f.nextString)\nproc nextFloat[F](f:F): float = parseFloat(f.nextString)\nproc nextString():string = stdin.nextString()\n\ntype SomeSignedInt = int|int8|int16|int32|int64|BiggestInt\ntype SomeUnsignedInt = uint|uint8|uint16|uint32|uint64\ntype SomeInteger = SomeSignedInt|SomeUnsignedInt\ntype SomeFloat = float|float32|float64|BiggestFloat\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate inf(T): untyped = \n  when T is SomeFloat: T(Inf)\n  elif T is SomeInteger: ((T(1) shl T(sizeof(T)*8-2)) - (T(1) shl T(sizeof(T)*4-1)))\n  else: assert(false)\n\nproc sort[T](v: var seq[T]) = v.sort(cmp[T])\nproc discardableId[T](x: T): T {.discardable.} =\n  return x\nmacro `:=`(x, y: untyped): untyped =\n  if (x.kind == nnkIdent):\n    return quote do:\n      when declaredInScope(`x`):\n        `x` = `y`\n      else:\n        var `x` = `y`\n      discardableId(`x`)\n  else:\n    return quote do:\n      `x` = `y`\n      discardableId(`x`)\nmacro dump*(x: typed): untyped =\n  let s = x.toStrLit\n  let r = quote do:\n    debugEcho `s`, \" = \", `x`\n  return r\n\nproc toStr[T](v:T):string =\n  proc `$`[T](v:seq[T]):string =\n    v.mapIt($it).join(\" \")\n  return $v\n\nproc print0(x: varargs[string, toStr]; sep:string):string{.discardable.} =\n  result = \"\"\n  for i,v in x:\n    if i != 0: addSep(result, sep = sep)\n    add(result, v)\n  result.add(\"\\n\")\n  stdout.write result\n\nvar print:proc(x: varargs[string, toStr])\nprint = proc(x: varargs[string, toStr]) =\n  discard print0(@x, sep = \" \")\n\nproc ndSeqImpl[T](lens: seq[int]; init: T; currentDimension, lensLen: static[int]): auto =\n  when currentDimension == lensLen:\n    newSeqWith(lens[currentDimension - 1], init)\n  else:\n    newSeqWith(lens[currentDimension - 1], ndSeqImpl(lens, init, currentDimension + 1, lensLen))\n\ntemplate ndSeq*[T](lens: varargs[int]; init: T): untyped =\n  ndSeqImpl(@lens, init, 1, lens.len)\n#}}}\n\n#{{{ bitutils\nproc bits[B:SomeInteger](v:varargs[int]): B =\n  result = 0\n  for x in v: result = (result or (B(1) shl B(x)))\nproc `[]`[B:SomeInteger](b:B,n:int):int = (b shr n) mod 2\nproc `[]`[B:SomeInteger](b:B,s:Slice[int]):int = (b shr s.a) mod (1 shl (s.b - s.a + 1))\nproc test[B:SomeInteger](b:B,n:int):bool = (if b[n] == 1:true else: false)\nproc set[B:SomeInteger](b:var B,n:int) = b = (b or (B(1) shl B(n)))\nproc unset[B:SomeInteger](b:var B,n:int) = b = (b and (not (B(1) shl B(n))))\nproc `[]=`[B:SomeInteger](b:var B,n:int,t:int) =\n  if t == 0: b.unset(n)\n  elif t == 1: b.set(n)\n  else: assert(false)\nproc writeBits[B:SomeInteger](b:B,n:int) =\n  var n = n * 8\n  for i in countdown(n-1,0):stdout.write(b[i])\n  echo \"\"\nproc setBits[B:SomeInteger](n:int):B = return (B(1) shl B(n)) - B(1)\nproc builtin_ctz(n:int):int =\n  for i in 0..<(8 * sizeof(n)):\n    if n[i] == 1: return i\n  assert(false)\nproc builtin_popcount(n:int):int =\n  result = 0\n  for i in 0..<(8 * sizeof(n)):\n    if n[i] == 1: result += 1\n#}}}\n\nconst YES = \"Possible\"\nconst NO = \"Impossible\"\n\nN := nextInt()\nA := nextString()\n\nproc dist(a, b:(int,int)):int =\n  return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\nproc check(ans: seq[(int,int)]) =\n  doAssert(ans[0] == ans[^1])\n  for i in 0..<ans.len - 1:\n    doAssert(dist(ans[i], ans[i+1]) == 1)\n\nproc add_cycle(ans:var seq[(int,int)], b:int) =\n  ans.add((0, 0))\n  prev := 0\n  for i in 0..<N:\n    if b[i] == 1:\n      if prev == 0:\n        ans.add((i, 1))\n      ans.add((i + 1, 1))\n    else:\n      if prev == 1:\n        ans.add((i, 0))\n      ans.add((i + 1, 0))\n    prev = b[i]\n  if prev == 1:\n    ans.add((N, 0))\n  for i in countdown(N - 1, 1):\n    ans.add((i, 0))\n\nproc main() =\n  ans := newSeq[(int,int)]()\n  inspect := ndSeq(1 shl N, false)\n  for b2 in countdown((1 shl N) - 1, 0):\n    if inspect[b2]: continue\n    v := newSeq[int]()\n    for i in 0..<N:\n      if b2[i] == 1: v.add(i)\n    if A[b2] == '0': continue\n    doAssert(A[b2] == '1')\n    for b0 in 0..<(1 shl v.len):\n      bb := 0\n      for i in 0..<v.len:\n        if b0[i] == 1:\n          bb[v[i]] = 1\n        else:\n          bb[v[i]] = 0\n      if A[bb] == '0':\n        print NO\n        return\n      inspect[bb] = true\n  for b in 0..<A.len:\n    if A[b] == '0':\n      ans.add_cycle(b)\n  ans.add((0, 0))\n  check(ans)\n  print YES\n  print ans.len - 1\n  for p in ans:\n    print p[0], p[1]\n  return\n\nmain()"
  },
  {
    "language": "Nim",
    "code": "#{{{ header\n{.hints:off warnings:off optimization:speed.}\nimport algorithm, sequtils, tables, macros, math, sets, strutils\nwhen defined(MYDEBUG):\n  import header\n\nimport streams\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\n#proc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(): int = scanf(\"%lld\",addr result)\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString[F](f:F): string =\n  var get = false\n  result = \"\"\n  while true:\n#    let c = getchar()\n    let c = f.readChar\n    if c.int > ' '.int:\n      get = true\n      result.add(c)\n    elif get: return\nproc nextInt[F](f:F): int = parseInt(f.nextString)\nproc nextFloat[F](f:F): float = parseFloat(f.nextString)\nproc nextString():string = stdin.nextString()\n\ntype SomeSignedInt = int|int8|int16|int32|int64|BiggestInt\ntype SomeUnsignedInt = uint|uint8|uint16|uint32|uint64\ntype SomeInteger = SomeSignedInt|SomeUnsignedInt\ntype SomeFloat = float|float32|float64|BiggestFloat\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate inf(T): untyped = \n  when T is SomeFloat: T(Inf)\n  elif T is SomeInteger: ((T(1) shl T(sizeof(T)*8-2)) - (T(1) shl T(sizeof(T)*4-1)))\n  else: assert(false)\n\nproc sort[T](v: var seq[T]) = v.sort(cmp[T])\nproc discardableId[T](x: T): T {.discardable.} =\n  return x\nmacro `:=`(x, y: untyped): untyped =\n  if (x.kind == nnkIdent):\n    return quote do:\n      when declaredInScope(`x`):\n        `x` = `y`\n      else:\n        var `x` = `y`\n      discardableId(`x`)\n  else:\n    return quote do:\n      `x` = `y`\n      discardableId(`x`)\nmacro dump*(x: typed): untyped =\n  let s = x.toStrLit\n  let r = quote do:\n    debugEcho `s`, \" = \", `x`\n  return r\n\nproc toStr[T](v:T):string =\n  proc `$`[T](v:seq[T]):string =\n    v.mapIt($it).join(\" \")\n  return $v\n\nproc print0(x: varargs[string, toStr]; sep:string):string{.discardable.} =\n  result = \"\"\n  for i,v in x:\n    if i != 0: addSep(result, sep = sep)\n    add(result, v)\n  result.add(\"\\n\")\n  stdout.write result\n\nvar print:proc(x: varargs[string, toStr])\nprint = proc(x: varargs[string, toStr]) =\n  discard print0(@x, sep = \" \")\n\nproc ndSeqImpl[T](lens: seq[int]; init: T; currentDimension, lensLen: static[int]): auto =\n  when currentDimension == lensLen:\n    newSeqWith(lens[currentDimension - 1], init)\n  else:\n    newSeqWith(lens[currentDimension - 1], ndSeqImpl(lens, init, currentDimension + 1, lensLen))\n\ntemplate ndSeq*[T](lens: varargs[int]; init: T): untyped =\n  ndSeqImpl(@lens, init, 1, lens.len)\n#}}}\n\n#{{{ bitutils\nproc bits[B:SomeInteger](v:varargs[int]): B =\n  result = 0\n  for x in v: result = (result or (B(1) shl B(x)))\nproc `[]`[B:SomeInteger](b:B,n:int):int = (b shr n) mod 2\nproc `[]`[B:SomeInteger](b:B,s:Slice[int]):int = (b shr s.a) mod (1 shl (s.b - s.a + 1))\nproc test[B:SomeInteger](b:B,n:int):bool = (if b[n] == 1:true else: false)\nproc set[B:SomeInteger](b:var B,n:int) = b = (b or (B(1) shl B(n)))\nproc unset[B:SomeInteger](b:var B,n:int) = b = (b and (not (B(1) shl B(n))))\nproc `[]=`[B:SomeInteger](b:var B,n:int,t:int) =\n  if t == 0: b.unset(n)\n  elif t == 1: b.set(n)\n  else: assert(false)\nproc writeBits[B:SomeInteger](b:B,n:int) =\n  var n = n * 8\n  for i in countdown(n-1,0):stdout.write(b[i])\n  echo \"\"\nproc setBits[B:SomeInteger](n:int):B = return (B(1) shl B(n)) - B(1)\nproc builtin_ctz(n:int):int =\n  for i in 0..<(8 * sizeof(n)):\n    if n[i] == 1: return i\n  assert(false)\nproc builtin_popcount(n:int):int =\n  result = 0\n  for i in 0..<(8 * sizeof(n)):\n    if n[i] == 1: result += 1\n#}}}\n\nconst YES = \"Possible\"\nconst NO = \"Impossible\"\n\nN := nextInt()\ns := nextString()\n\n\nproc main() =\n  for b2 in 0..<(1 shl N):\n    valid := true\n    for b in 0..<s.len: # 1: inner 0: outer\n      if s[b] == '1':\n        if (b and b2) != 0:\n          valid = false\n      else:\n        if (b and b2) == 0:\n          valid = false\n    if valid:\n      print YES\n      ans := newSeq[(int,int)]()\n      ans.add((0, 0))\n      prev := 0\n      for i in 0..<N:\n        if b2[i] == 1:\n          if prev == 0:\n            ans.add((i, 1))\n          ans.add((i + 1, 1))\n        else:\n          if prev == 1:\n            ans.add((i, 0))\n          ans.add((i + 1, 0))\n        prev = b2[i]\n      if prev == 1:\n        ans.add((N, 0))\n      for i in countdown(N - 1, 0):\n        ans.add((i, 0))\n      print ans.len\n      for p in ans:\n        print p[0], p[1]\n      return\n  print NO\n  return\n\nmain()"
  },
  {
    "language": "Nim",
    "code": "#{{{ header\n{.hints:off warnings:off optimization:speed.}\nimport algorithm, sequtils, tables, macros, math, sets, strutils\nwhen defined(MYDEBUG):\n  import header\n\nimport streams\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\n#proc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(): int = scanf(\"%lld\",addr result)\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString[F](f:F): string =\n  var get = false\n  result = \"\"\n  while true:\n#    let c = getchar()\n    let c = f.readChar\n    if c.int > ' '.int:\n      get = true\n      result.add(c)\n    elif get: return\nproc nextInt[F](f:F): int = parseInt(f.nextString)\nproc nextFloat[F](f:F): float = parseFloat(f.nextString)\nproc nextString():string = stdin.nextString()\n\ntype SomeSignedInt = int|int8|int16|int32|int64|BiggestInt\ntype SomeUnsignedInt = uint|uint8|uint16|uint32|uint64\ntype SomeInteger = SomeSignedInt|SomeUnsignedInt\ntype SomeFloat = float|float32|float64|BiggestFloat\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate inf(T): untyped = \n  when T is SomeFloat: T(Inf)\n  elif T is SomeInteger: ((T(1) shl T(sizeof(T)*8-2)) - (T(1) shl T(sizeof(T)*4-1)))\n  else: assert(false)\n\nproc sort[T](v: var seq[T]) = v.sort(cmp[T])\nproc discardableId[T](x: T): T {.discardable.} =\n  return x\nmacro `:=`(x, y: untyped): untyped =\n  if (x.kind == nnkIdent):\n    return quote do:\n      when declaredInScope(`x`):\n        `x` = `y`\n      else:\n        var `x` = `y`\n      discardableId(`x`)\n  else:\n    return quote do:\n      `x` = `y`\n      discardableId(`x`)\nmacro dump*(x: typed): untyped =\n  let s = x.toStrLit\n  let r = quote do:\n    debugEcho `s`, \" = \", `x`\n  return r\n\nproc toStr[T](v:T):string =\n  proc `$`[T](v:seq[T]):string =\n    v.mapIt($it).join(\" \")\n  return $v\n\nproc print0(x: varargs[string, toStr]; sep:string):string{.discardable.} =\n  result = \"\"\n  for i,v in x:\n    if i != 0: addSep(result, sep = sep)\n    add(result, v)\n  result.add(\"\\n\")\n  stdout.write result\n\nvar print:proc(x: varargs[string, toStr])\nprint = proc(x: varargs[string, toStr]) =\n  discard print0(@x, sep = \" \")\n\nproc ndSeqImpl[T](lens: seq[int]; init: T; currentDimension, lensLen: static[int]): auto =\n  when currentDimension == lensLen:\n    newSeqWith(lens[currentDimension - 1], init)\n  else:\n    newSeqWith(lens[currentDimension - 1], ndSeqImpl(lens, init, currentDimension + 1, lensLen))\n\ntemplate ndSeq*[T](lens: varargs[int]; init: T): untyped =\n  ndSeqImpl(@lens, init, 1, lens.len)\n#}}}\n\n#{{{ bitutils\nproc bits[B:SomeInteger](v:varargs[int]): B =\n  result = 0\n  for x in v: result = (result or (B(1) shl B(x)))\nproc `[]`[B:SomeInteger](b:B,n:int):int = (b shr n) mod 2\nproc `[]`[B:SomeInteger](b:B,s:Slice[int]):int = (b shr s.a) mod (1 shl (s.b - s.a + 1))\nproc test[B:SomeInteger](b:B,n:int):bool = (if b[n] == 1:true else: false)\nproc set[B:SomeInteger](b:var B,n:int) = b = (b or (B(1) shl B(n)))\nproc unset[B:SomeInteger](b:var B,n:int) = b = (b and (not (B(1) shl B(n))))\nproc `[]=`[B:SomeInteger](b:var B,n:int,t:int) =\n  if t == 0: b.unset(n)\n  elif t == 1: b.set(n)\n  else: assert(false)\nproc writeBits[B:SomeInteger](b:B,n:int) =\n  var n = n * 8\n  for i in countdown(n-1,0):stdout.write(b[i])\n  echo \"\"\nproc setBits[B:SomeInteger](n:int):B = return (B(1) shl B(n)) - B(1)\nproc builtin_ctz(n:int):int =\n  for i in 0..<(8 * sizeof(n)):\n    if n[i] == 1: return i\n  assert(false)\nproc builtin_popcount(n:int):int =\n  result = 0\n  for i in 0..<(8 * sizeof(n)):\n    if n[i] == 1: result += 1\n#}}}\n\nconst YES = \"Possible\"\nconst NO = \"Impossible\"\n\nN := nextInt()\ns := nextString()\n\nproc dist(a, b:(int,int)):int =\n  return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\nproc check(ans: seq[(int,int)]) =\n  doAssert(ans[0] == ans[^1])\n  for i in 0..<ans.len - 1:\n    doAssert(dist(ans[i], ans[i+1]) == 1)\n\nproc main() =\n  ans := newSeq[(int,int)]()\n  inspect := ndSeq(1 shl N, false)\n  for b2 in countdown((1 shl N) - 1, 0):\n    if inspect[b2]: continue\n    v := newSeq[int]()\n    for i in 0..<N:\n      if b2[i] == 1: v.add(i)\n    if s[b2] == '0': continue\n    doAssert(s[b2] == '1')\n    for b0 in 0..<(1 shl v.len):\n      bb := 0\n      for i in 0..<v.len:\n        if b0[i] == 1:\n          bb[v[i]] = 1\n        else:\n          bb[v[i]] = 0\n      if s[bb] == '0':\n        print NO\n        return\n      inspect[bb] = true\n    ans.add((0, 0))\n    prev := 0\n    for i in 0..<N:\n      if b2[i] == 1:\n        if prev == 0:\n          ans.add((i, 1))\n        ans.add((i + 1, 1))\n      else:\n        if prev == 1:\n          ans.add((i, 0))\n        ans.add((i + 1, 0))\n      prev = b2[i]\n    if prev == 1:\n      ans.add((N, 0))\n    for i in countdown(N - 1, 1):\n      ans.add((i, 0))\n  doAssert(false)\n  ans.add((0, 0))\n  check(ans)\n  print YES\n  print ans.len - 1\n  for p in ans:\n    print p[0], p[1]\n  return\n\nmain()"
  },
  {
    "language": "Nim",
    "code": "#{{{ header\n{.hints:off warnings:off optimization:speed.}\nimport algorithm, sequtils, tables, macros, math, sets, strutils\nwhen defined(MYDEBUG):\n  import header\n\nimport streams\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\n#proc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(): int = scanf(\"%lld\",addr result)\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString[F](f:F): string =\n  var get = false\n  result = \"\"\n  while true:\n#    let c = getchar()\n    let c = f.readChar\n    if c.int > ' '.int:\n      get = true\n      result.add(c)\n    elif get: return\nproc nextInt[F](f:F): int = parseInt(f.nextString)\nproc nextFloat[F](f:F): float = parseFloat(f.nextString)\nproc nextString():string = stdin.nextString()\n\ntype SomeSignedInt = int|int8|int16|int32|int64|BiggestInt\ntype SomeUnsignedInt = uint|uint8|uint16|uint32|uint64\ntype SomeInteger = SomeSignedInt|SomeUnsignedInt\ntype SomeFloat = float|float32|float64|BiggestFloat\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate inf(T): untyped = \n  when T is SomeFloat: T(Inf)\n  elif T is SomeInteger: ((T(1) shl T(sizeof(T)*8-2)) - (T(1) shl T(sizeof(T)*4-1)))\n  else: assert(false)\n\nproc sort[T](v: var seq[T]) = v.sort(cmp[T])\nproc discardableId[T](x: T): T {.discardable.} =\n  return x\nmacro `:=`(x, y: untyped): untyped =\n  if (x.kind == nnkIdent):\n    return quote do:\n      when declaredInScope(`x`):\n        `x` = `y`\n      else:\n        var `x` = `y`\n      discardableId(`x`)\n  else:\n    return quote do:\n      `x` = `y`\n      discardableId(`x`)\nmacro dump*(x: typed): untyped =\n  let s = x.toStrLit\n  let r = quote do:\n    debugEcho `s`, \" = \", `x`\n  return r\n\nproc toStr[T](v:T):string =\n  proc `$`[T](v:seq[T]):string =\n    v.mapIt($it).join(\" \")\n  return $v\n\nproc print0(x: varargs[string, toStr]; sep:string):string{.discardable.} =\n  result = \"\"\n  for i,v in x:\n    if i != 0: addSep(result, sep = sep)\n    add(result, v)\n  result.add(\"\\n\")\n  stdout.write result\n\nvar print:proc(x: varargs[string, toStr])\nprint = proc(x: varargs[string, toStr]) =\n  discard print0(@x, sep = \" \")\n\nproc ndSeqImpl[T](lens: seq[int]; init: T; currentDimension, lensLen: static[int]): auto =\n  when currentDimension == lensLen:\n    newSeqWith(lens[currentDimension - 1], init)\n  else:\n    newSeqWith(lens[currentDimension - 1], ndSeqImpl(lens, init, currentDimension + 1, lensLen))\n\ntemplate ndSeq*[T](lens: varargs[int]; init: T): untyped =\n  ndSeqImpl(@lens, init, 1, lens.len)\n#}}}\n\n#{{{ bitutils\nproc bits[B:SomeInteger](v:varargs[int]): B =\n  result = 0\n  for x in v: result = (result or (B(1) shl B(x)))\nproc `[]`[B:SomeInteger](b:B,n:int):int = (b shr n) mod 2\nproc `[]`[B:SomeInteger](b:B,s:Slice[int]):int = (b shr s.a) mod (1 shl (s.b - s.a + 1))\nproc test[B:SomeInteger](b:B,n:int):bool = (if b[n] == 1:true else: false)\nproc set[B:SomeInteger](b:var B,n:int) = b = (b or (B(1) shl B(n)))\nproc unset[B:SomeInteger](b:var B,n:int) = b = (b and (not (B(1) shl B(n))))\nproc `[]=`[B:SomeInteger](b:var B,n:int,t:int) =\n  if t == 0: b.unset(n)\n  elif t == 1: b.set(n)\n  else: assert(false)\nproc writeBits[B:SomeInteger](b:B,n:int) =\n  var n = n * 8\n  for i in countdown(n-1,0):stdout.write(b[i])\n  echo \"\"\nproc setBits[B:SomeInteger](n:int):B = return (B(1) shl B(n)) - B(1)\nproc builtin_ctz(n:int):int =\n  for i in 0..<(8 * sizeof(n)):\n    if n[i] == 1: return i\n  assert(false)\nproc builtin_popcount(n:int):int =\n  result = 0\n  for i in 0..<(8 * sizeof(n)):\n    if n[i] == 1: result += 1\n#}}}\n\nconst YES = \"Possible\"\nconst NO = \"Impossible\"\n\nN := nextInt()\nA := nextString()\n\nproc dist(a, b:(int,int)):int =\n  return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\nproc check(ans: seq[(int,int)]) =\n  doAssert(ans[0] == ans[^1])\n  for i in 0..<ans.len - 1:\n    doAssert(dist(ans[i], ans[i+1]) == 1)\n\nproc add_cycle(ans:var seq[(int,int)], b:int) =\n  ans.add((0, 0))\n  prev := 0\n  for i in 0..<N:\n    if b[i] == 1:\n      if prev == 0:\n        ans.add((i, 1))\n      ans.add((i + 1, 1))\n    else:\n      if prev == 1:\n        ans.add((i, 0))\n      ans.add((i + 1, 0))\n    prev = b[i]\n  if prev == 1:\n    ans.add((N, 0))\n  for i in countdown(N - 1, 1):\n    ans.add((i, 0))\n\nproc main() =\n  ans := newSeq[(int,int)]()\n  inspect := ndSeq(1 shl N, false)\n  for b2 in countdown((1 shl N) - 1, 0):\n    if inspect[b2]: continue\n    v := newSeq[int]()\n    for i in 0..<N:\n      if b2[i] == 1: v.add(i)\n    if A[b2] == '0': continue\n    doAssert(A[b2] == '1')\n    for b0 in 0..<(1 shl v.len):\n      bb := 0\n      for i in 0..<v.len:\n        if b0[i] == 1:\n          bb[v[i]] = 1\n        else:\n          bb[v[i]] = 0\n      if A[bb] == '0':\n        print NO\n        return\n      inspect[bb] = true\n    for i in 0..<N:\n      if b2[i] == 1: continue\n      ans.add_cycle(b2 or (1 shl i))\n  ans.add((0, 0))\n  check(ans)\n  print YES\n  print ans.len - 1\n  for p in ans:\n    print p[0], p[1]\n  return\n\nmain()"
  },
  {
    "language": "Nim",
    "code": "#{{{ header\n{.hints:off warnings:off optimization:speed.}\nimport algorithm, sequtils, tables, macros, math, sets, strutils\nwhen defined(MYDEBUG):\n  import header\n\nimport streams\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\n#proc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(): int = scanf(\"%lld\",addr result)\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString[F](f:F): string =\n  var get = false\n  result = \"\"\n  while true:\n#    let c = getchar()\n    let c = f.readChar\n    if c.int > ' '.int:\n      get = true\n      result.add(c)\n    elif get: return\nproc nextInt[F](f:F): int = parseInt(f.nextString)\nproc nextFloat[F](f:F): float = parseFloat(f.nextString)\nproc nextString():string = stdin.nextString()\n\ntype SomeSignedInt = int|int8|int16|int32|int64|BiggestInt\ntype SomeUnsignedInt = uint|uint8|uint16|uint32|uint64\ntype SomeInteger = SomeSignedInt|SomeUnsignedInt\ntype SomeFloat = float|float32|float64|BiggestFloat\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate inf(T): untyped = \n  when T is SomeFloat: T(Inf)\n  elif T is SomeInteger: ((T(1) shl T(sizeof(T)*8-2)) - (T(1) shl T(sizeof(T)*4-1)))\n  else: assert(false)\n\nproc sort[T](v: var seq[T]) = v.sort(cmp[T])\nproc discardableId[T](x: T): T {.discardable.} =\n  return x\nmacro `:=`(x, y: untyped): untyped =\n  if (x.kind == nnkIdent):\n    return quote do:\n      when declaredInScope(`x`):\n        `x` = `y`\n      else:\n        var `x` = `y`\n      discardableId(`x`)\n  else:\n    return quote do:\n      `x` = `y`\n      discardableId(`x`)\nmacro dump*(x: typed): untyped =\n  let s = x.toStrLit\n  let r = quote do:\n    debugEcho `s`, \" = \", `x`\n  return r\n\nproc toStr[T](v:T):string =\n  proc `$`[T](v:seq[T]):string =\n    v.mapIt($it).join(\" \")\n  return $v\n\nproc print0(x: varargs[string, toStr]; sep:string):string{.discardable.} =\n  result = \"\"\n  for i,v in x:\n    if i != 0: addSep(result, sep = sep)\n    add(result, v)\n  result.add(\"\\n\")\n  stdout.write result\n\nvar print:proc(x: varargs[string, toStr])\nprint = proc(x: varargs[string, toStr]) =\n  discard print0(@x, sep = \" \")\n\nproc ndSeqImpl[T](lens: seq[int]; init: T; currentDimension, lensLen: static[int]): auto =\n  when currentDimension == lensLen:\n    newSeqWith(lens[currentDimension - 1], init)\n  else:\n    newSeqWith(lens[currentDimension - 1], ndSeqImpl(lens, init, currentDimension + 1, lensLen))\n\ntemplate ndSeq*[T](lens: varargs[int]; init: T): untyped =\n  ndSeqImpl(@lens, init, 1, lens.len)\n#}}}\n\n#{{{ bitutils\nproc bits[B:SomeInteger](v:varargs[int]): B =\n  result = 0\n  for x in v: result = (result or (B(1) shl B(x)))\nproc `[]`[B:SomeInteger](b:B,n:int):int = (b shr n) mod 2\nproc `[]`[B:SomeInteger](b:B,s:Slice[int]):int = (b shr s.a) mod (1 shl (s.b - s.a + 1))\nproc test[B:SomeInteger](b:B,n:int):bool = (if b[n] == 1:true else: false)\nproc set[B:SomeInteger](b:var B,n:int) = b = (b or (B(1) shl B(n)))\nproc unset[B:SomeInteger](b:var B,n:int) = b = (b and (not (B(1) shl B(n))))\nproc `[]=`[B:SomeInteger](b:var B,n:int,t:int) =\n  if t == 0: b.unset(n)\n  elif t == 1: b.set(n)\n  else: assert(false)\nproc writeBits[B:SomeInteger](b:B,n:int) =\n  var n = n * 8\n  for i in countdown(n-1,0):stdout.write(b[i])\n  echo \"\"\nproc setBits[B:SomeInteger](n:int):B = return (B(1) shl B(n)) - B(1)\nproc builtin_ctz(n:int):int =\n  for i in 0..<(8 * sizeof(n)):\n    if n[i] == 1: return i\n  assert(false)\nproc builtin_popcount(n:int):int =\n  result = 0\n  for i in 0..<(8 * sizeof(n)):\n    if n[i] == 1: result += 1\n#}}}\n\nconst YES = \"Possible\"\nconst NO = \"Impossible\"\n\nN := nextInt()\ns := nextString()\n\nproc dist(a, b:(int,int)):int =\n  return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\nproc check(ans: seq[(int,int)]) =\n  doAssert(ans[0] == ans[^1])\n  for i in 0..<ans.len - 1:\n    doAssert(dist(ans[i], ans[i+1]) == 1)\n\nproc main() =\n  ans := newSeq[(int,int)]()\n  inspect := ndSeq(1 shl N, false)\n  for b2 in countdown((1 shl N) - 1, 0):\n    if inspect[b2]: continue\n    v := newSeq[int]()\n    for i in 0..<N:\n      if b2[i] == 1: v.add(i)\n    if s[b2] == '0': continue\n    doAssert(s[b2] == '1')\n    for b0 in 0..<(1 shl v.len):\n      bb := 0\n      for i in 0..<v.len:\n        if b0[i] == 1:\n          bb[v[i]] = 1\n        else:\n          bb[v[i]] = 0\n      if s[bb] == '0':\n        print NO\n        return\n      inspect[bb] = true\n    ans.add((0, 0))\n    prev := 0\n    for i in 0..<N:\n      if b2[i] == 1:\n        if prev == 0:\n          ans.add((i, 1))\n        ans.add((i + 1, 1))\n      else:\n        if prev == 1:\n          ans.add((i, 0))\n        ans.add((i + 1, 0))\n      prev = b2[i]\n    if prev == 1:\n      ans.add((N, 0))\n    for i in countdown(N - 1, 1):\n      ans.add((i, 0))\n  ans.add((0, 0))\n  check(ans)\n  print YES\n  print ans.len - 1\n  for p in ans:\n    print p[0], p[1]\n  return\n\nmain()"
  },
  {
    "language": "Python",
    "code": "n = int(input())\na = [int(x) for x in input()]\n\nholes = []\n\nfor i in range(2**n):\n    if a[i] == 1:\n        continue\n    for j in range(i+1, 2**n):\n        if (j | i) == j and a[j] == 1:\n            print(\"Impossible\")\n            exit()\n    if any((k | i) == i for k in holes):\n        continue\n    else:\n        holes.append(i)\n\nprint(\"Possible\")\nif len(holes) == 0:\n    print(0)\n    print(1, 1)\n    exit()\n\nclockwise = []\n\nfor i in range(n):\n    locus = []\n    for j in range(i+1):\n        locus.append((j, 0))\n    locus += [(i, 1), (i+1, 1), (i+1, 0)]\n    for j in range(i, -1, -1):\n        locus.append((j, 0))\n    clockwise.append(locus)\n\nm = len(holes)\nroops = []\n\nfor i in range(m):\n    x = holes[i]\n    curve = []\n    is_first = True\n    for j in range(n):\n        if (x >> j) & 1 and is_first:\n            curve += clockwise[j]\n            is_first = False\n        elif (x >> j) & 1:\n            curve = curve + clockwise[j] + curve[::-1] + clockwise[j][::-1]\n    roops.append(curve)\n\nans = []\nfor x in roops:\n    ans += x\n\nL = -1\nfor i, x in enumerate(ans):\n    if i > 0 and ans[i] == ans[i-1]:\n        continue\n    else:\n        L += 1\n\nprint(L)\nfor i, x in enumerate(ans):\n    if i > 0 and ans[i] == ans[i-1]:\n        continue\n    else:\n        print(*x)\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\na = [c == \"0\" for c in input().rstrip()]\n\nxs = [a[2**i] for i in range(N)]\nbs = [False]\nfor x in xs:\n    bs_add = [b or x for b in bs]\n    bs = bs + bs_add\npos = a == bs\n\nif not pos:\n    print(\"Impossible\")\nelse:\n    print(\"Possible\")\n    raise\n    points = [(0, 0)]\n    for i, x in enumerate(xs):\n        if x:\n            points.append((i, 1))\n            points.append((i + 1, 1))\n        points.append((i + 1, 0))\n    for i in range(N):\n        points.append((N - 1 - i, 0))\n    print(len(points) - 1)\n    for x, y in points:\n        print(x, y)\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    N = int( input())\n    A = list( map(int, list( input())))\n    P = [False]*N\n    for i in range(N):\n        if A[2**i] == 1:\n            P[i] = True\n    ans = True\n    for x in range(2**N):\n        now = True\n        y = x\n        for i in range(N):\n            if y%2 == 1:\n                if not P[i]:\n                    now = False\n                    break\n            y //= 2\n        if (A[x] == 1 and not now) or ( A[x] == 0 and now):\n            ans = False\n            break\n    if ans:\n        print(\"Possible\")\n    else:\n        print(\"Impossible\")\n        return\n    L = 0\n    ANS = [\"0 0\"]\n\n    for i in range(N):\n        if not P[i]:\n            ANS.append( str(i) + \" \" + str(1))\n            ANS.append( str(i+1) + \" \" + str(1))\n            ANS.append( str(i+1) + \" \" + str(0))\n            L += 3\n        else:\n            ANS.append( str(i+1) + \" \" + str(0))\n            L += 1\n    for i in range(N):\n        ANS.append( str(N-1-i) + \" \" + str(0))\n        L += 1\n    print(L)\n    print(\"\\n\".join(ANS))\n            \nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "N = int(input())\na = [c == \"0\" for c in input().rstrip()]\n\nxs = [a[2**i] for i in range(N)]\nbs = [False]\nfor x in xs:\n    bs_add = [b or x for b in bs]\n    bs = bs + bs_add\npos = all(a_ == b_ for a_, b_ in zip(a, bs))\n\nif not pos:\n    print(\"Impossible\")\nelse:\n    print(\"Possible\")\n    points = [(0, 0)]\n    for i, x in enumerate(xs):\n        if x:\n            points.append((i, 1))\n            points.append((i + 1, 1))\n        points.append((i + 1, 0))\n    for i in range(N):\n        points.append((N - 1 - i, 0))\n    print(len(points) - 1)\n    for x, y in points:\n        print(x, y)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\ndef solve(A):\n    H,N = A.shape\n    if N == 1:\n        if np.all(A == 0):\n            return np.array([1], np.int64)\n        else:\n            return np.array([0], np.int64)\n    while True:\n        if np.all(A[:,0] == 0):\n            vals = solve(A[:,1:])\n            return np.concatenate([[np.abs(vals).sum() + 1], vals])\n        d = 10 ** 18\n        h = 0\n        for i in range(H):\n            if A[i,0] < 0:\n                A[i] *= -1 \n            if d > A[i,0] > 0:\n                d = A[i,0]\n                h = i\n        temp = A[0].copy()\n        A[0] = A[h]\n        A[h] = temp\n        if np.count_nonzero(A[:,0]) == 1:\n            vals = solve(A[1:,1:])\n            vals *= d\n            x = np.dot(vals, A[0,1:])\n            return np.concatenate([[-x//d], vals])\n        q = A[1:,0] // d\n        A[1:] -= q[:,None] * A[0][None,:]\n\nN = int(readline())\nA = list(map(int,readline().rstrip().decode()))\n\nN,A\n\neqs = []\nfor i in range(1<<N):\n    if A[i]:\n        eqs.append([1 if (i>>n)&1 else 0 for n in range(N)])\n\neqs = np.array(eqs, np.int64)\n\nvals = solve(eqs)\n\nfor i in range(1<<N):\n    S = sum(vals[j] for j in range(N) if (i>>j)&1)\n    if S == 0 and A[i] == 0:\n        print('Impossible')\n        exit()\n\ndef output(vals):\n    pts = []\n    for n,x in enumerate(vals):\n        pts.append([n,0])\n        positive = [[n+1,0],[n+1,1],[n,1],[n,0]]\n        negative = [[n,1],[n+1,1],[n+1,0],[n,0]]\n        if x > 0:\n            pts += positive * x\n        if x < 0:\n            pts += negative * (-x)\n    pts.append([N,0])\n    for n in range(N-1,0,-1):\n        pts.append([n,0])\n    pts.append([0,0])\n    print('Possible')\n    print(len(pts) - 1)\n    print('\\n'.join('{} {}'.format(x,y) for x,y in pts))\n\noutput(vals)"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom heapq import *\n\ndef first_1(x):\n  if x:\n    i = 0\n    while x & 1 == 0:\n      x >>= 1\n      i += 1\n    return i\n\ndef sep_single(s):\n  if s:\n    r = 1 << (s.bit_length()-1)\n    i = s.bit_length()-1\n    while s:\n      if r & s:\n        yield -i, r\n        s ^= r\n      r >>= 1\n      i -= 1\n\ndef prepare_to_right(g, x):\n  x0, y0 = g[-1]\n  if x0 < x and y0:\n    y0 = 0\n    g.append((x0, 0))\n  while x0 < x:\n    x0 += 1\n    g.append((x0, 0))\n\ndef prepare_to_left(g, x):\n  x0, y0 = g[-1]\n  if x+1 < x0 and y0:\n    y0 = 0\n    g.append((x0, 0))\n  while x+1 < x0:\n    x0 -= 1\n    g.append((x0, 0))\n\ndef append_to_right(g, x, y):\n  prepare_to_right(g, x)\n  x0, y0 = g[-1]\n  if y != y0:\n    g.append((x, y))\n  g.append((x+1, y))\n\ndef subloop_tp_group(g):\n  x = 0\n  while g&1 == 0:\n   g >>= 1\n   x += 1\n  loop = [(x+1, 0)]\n  tail = [(x, 0), (x, 1), (x+1, 1)]\n  g >>= 1\n  x += 1\n  while g:\n    while g&1==0:\n      g >>= 1\n      x += 1\n    prepare_to_right(loop, x)\n    prepare_to_right(tail, x)\n    rev = reversed(loop)\n    append_to_right(loop, x, 1)\n    loop.append((x+1, 0))\n    loop.extend(rev)\n    loop.extend(tail)\n    append_to_right(loop, x, 0)\n    append_to_right(tail, x, 1)\n    g >>= 1\n    x += 1\n  loop.extend(reversed(tail))\n  return loop\n\nN = int(input())\n\nsingle = 0\ntpg = []\nfor i in range(1<<N):\n  a = int(sys.stdin.read(1))\n  if bin(i).count(\"1\") == 1:\n    if a == 0:\n      single |= i\n  else:\n    b = i & single\n    if i and b | a == 0 and all(p & i != p for n, p in tpg):\n      heappush(tpg, (-first_1(i), i))\n    elif i | a == 0 or a and (b or any(p & i == p for n, p in tpg)):\n      print(\"Impossible\")\n      break\nelse:\n  print(\"Possible\")\n  loop = []\n  for n, g in merge(sep_single(single), tpg):\n    subloop = subloop_tp_group(g)\n    if loop:\n      prepare_to_left(loop, subloop[0][0])\n      if loop[-1] == subloop[0]:\n        loop.pop()\n    loop.extend(subloop)\n  \n  if not loop:\n    loop.append((0, 0))\n  prepare_to_right(loop, loop[0][0])\n  \n  print(len(loop)-1)\n  for p in loop:\n    print(*p)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\ndef solve(A):\n    H,N = A.shape\n    if N == 1:\n        if np.all(A == 0):\n            return np.array([1], np.int64)\n        else:\n            return np.array([0], np.int64)\n    while True:\n        if np.all(A[:,0] == 0):\n            vals = solve(A[:,1:])\n            return np.concatenate([[np.abs(vals).sum() + 1], vals])\n        d = 10 ** 18\n        h = 0\n        for i in range(H):\n            if A[i,0] < 0:\n                A[i] *= -1 \n            if d > A[i,0] > 0:\n                d = A[i,0]\n                h = i\n        temp = A[0].copy()\n        A[0] = A[h]\n        A[h] = temp\n        if np.count_nonzero(A[:,0]) == 1:\n            vals = solve(A[1:,1:])\n            vals *= d\n            x = np.dot(vals, A[0,1:])\n            return np.concatenate([[-x//d], vals])\n        q = A[1:,0] // d\n        A[1:] -= q[:,None] * A[0][None,:]\n\nN = int(readline())\nA = list(map(int,readline().rstrip().decode()))\n\nN,A\n\neqs = []\nfor i in range(1<<N):\n    if A[i]:\n        eqs.append([1 if (i>>n)&1 else 0 for n in range(N)])\n\neqs = np.array(eqs, np.int64)\n\nvals = solve(eqs)\n\nfor i in range(1<<N):\n    S = sum(vals[j] for j in range(N) if (i>>j)&1)\n    if S == 0 and A[i] == 0:\n        print('Impossible')\n        exit()\n\ndef output(vals):\n    pts = []\n    for n,x in enumerate(vals):\n        pts.append([n,0])\n        positive = [[n+1,0],[n+1,n+1],[n,n+1],[n,0]]\n        negative = [[n,n+1],[n+1,n+1],[n+1,0],[n,0]]\n        if x > 0:\n            pts += positive * x\n        if x < 0:\n            pts += negative * (-x)\n    pts.append([N,0])\n    pts.append([N,1])\n    pts.append([0,1])\n    pts.append([0,0])\n    print('Possible')\n    print('\\n'.join('{} {}'.format(x,y) for x,y in pts))\n\noutput(vals)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\ndef solve(A):\n    H,N = A.shape\n    if N == 1:\n        if np.all(A == 0):\n            return np.array([1], np.int64)\n        else:\n            return np.array([0], np.int64)\n    while True:\n        if np.all(A[:,0] == 0):\n            vals = solve(A[:,1:])\n            return np.concatenate([[np.abs(vals).sum() + 1], vals])\n        d = 10 ** 18\n        h = 0\n        for i in range(H):\n            if A[i,0] < 0:\n                A[i] *= -1 \n            if d > A[i,0] > 0:\n                d = A[i,0]\n                h = i\n        temp = A[0].copy()\n        A[0] = A[h]\n        A[h] = temp\n        if np.count_nonzero(A[:,0]) == 1:\n            vals = solve(A[1:,1:])\n            vals *= d\n            x = np.dot(vals, A[0,1:])\n            return np.concatenate([[-x//d], vals])\n        q = A[1:,0] // d\n        A[1:] -= q[:,None] * A[0][None,:]\n\nN = int(readline())\nA = list(map(int,readline().rstrip().decode()))\n\nN,A\n\neqs = []\nfor i in range(1<<N):\n    if A[i]:\n        eqs.append([1 if (i>>n)&1 else 0 for n in range(N)])\n\neqs = np.array(eqs, np.int64)\n\nvals = solve(eqs)\n\nfor i in range(1<<N):\n    S = sum(vals[j] for j in range(N) if (i>>j)&1)\n    if S == 0 and A[i] == 0:\n        print('Impossible')\n        exit()\n\ndef output(vals):\n    pts = []\n    for n,x in enumerate(vals):\n        pts.append([n,0])\n        positive = [[n+1,0],[n+1,1],[n,1],[n,0]]\n        negative = [[n,1],[n+1,1],[n+1,0],[n,0]]\n        if x > 0:\n            pts += positive * x\n        if x < 0:\n            pts += negative * (-x)\n    pts.append([N,0])\n    pts.append([N,-1])\n    for n in range(N-1,0,-1):\n        pts.append([n,-1])\n    pts.append([0,-1])\n    pts.append([0,0])\n    print('Possible')\n    print(len(pts) - 1)\n    print('\\n'.join('{} {}'.format(x,y) for x,y in pts))\n\noutput(vals)"
  },
  {
    "language": "Python",
    "code": "res = []\ndef main():\n    n = int(input())\n    a = [int(c) for c in input()]\n    \n    if a[0] == 0:\n        return False\n\n    for x in range(1, 2**n):\n        s = list(filter(lambda i: (x >> i) & 1, range(n)))\n        xl = [(x >> i) & 1 for i in range(n)]\n        if a[x] == 0:\n            for d in s:\n                y = x ^ (1 << d)\n                if a[y] == 1:\n                    break\n            else:\n                continue\n            def move_ceiling(r, dest):\n                i, j = r[-1]\n                if i < dest:\n                    for i in range(i, dest):\n                        if xl[i] == 0 and j == 1:\n                            r.append((i, 0))\n                            j = 0\n                        elif xl[i] == 1 and j == 0:\n                            r.append((i, 1))\n                            j = 1\n                        r.append((i + 1, j))\n                else:\n                    for i in range(i, dest, -1):\n                        if xl[i - 1] == 0 and j == 1:\n                            r.append((i, 0))\n                            j = 0\n                        elif xl[i - 1] == 1 and j == 0:\n                            r.append((i, 1))\n                            j = 1\n                        r.append((i - 1, j))\n                return r\n            def move_floor(r, dest):\n                i, j = r[-1]\n                if j == 1:\n                    r.append((i, 0))\n                for i in range(i + 1, dest + 1) if i < dest else range(i - 1, dest - 1, -1):\n                    r.append((i, 0))\n                return r\n            u = move_ceiling([(0, 0)], s[0] + 1)\n            l = move_floor([(0, 0)], s[0] + 1)\n            cur = s[0] + 1\n            for d in s[1:]:\n                u = move_ceiling(u, d + 1)\n                u = move_floor(u, cur)\n                u = move_ceiling(u, s[0])\n                u = move_floor(u, d + 1)\n                l = move_ceiling(l, d + 1)\n                u, l = l, u\n                cur = d + 1\n            l.reverse()\n            l.pop()\n            res.append(u + l)\n        else:\n            for d in s:\n                y = x ^ (1 << d)\n                if a[y] != 1:\n                    return False\n    return True\n\nif __name__ == '__main__':\n    if main():\n        print('Possible')\n        r = [(i, j) for r in res for i, j in r]\n        r.append((0, 0))\n        print(len(r) - 1)\n        for i, j in r:\n            print(i, j)\n    else:\n        print('Impossible')\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom heapq import *\n\ndef first_1(x):\n  if x:\n    i = 0\n    while x & 1 == 0:\n      x >>= 1\n      i += 1\n    return i\n\ndef sep_single(s):\n  if s:\n    r = 1 << (s.bit_length()-1)\n    i = s.bit_length()-1\n    while s:\n      if r & s:\n        yield -i, r\n        s ^= r\n      r >>= 1\n      i -= 1\n\ndef prepare_to_right(g, x):\n  x0, y0 = g[-1]\n  if x0 < x and y0:\n    y0 = 0\n    g.append((x0, 0))\n  while x0 < x:\n    x0 += 1\n    g.append((x0, 0))\n\ndef prepare_to_left(g, x):\n  x0, y0 = g[-1]\n  if x+1 < x0 and y0:\n    y0 = 0\n    g.append((x0, 0))\n  while x+1 < x0:\n    x0 -= 1\n    g.append((x0, 0))\n\ndef append_to_right(g, x, y):\n  prepare_to_right(g, x)\n  x0, y0 = g[-1]\n  if y != y0:\n    g.append((x, y))\n  g.append((x+1, y))\n\ndef subloop_tp_group(g):\n  x = 0\n  while g&1 == 0:\n   g >>= 1\n   x += 1\n  loop = [(x+1, 0)]\n  tail = [(x, 0), (x, 1), (x+1, 1)]\n  g >>= 1\n  x += 1\n  while g:\n    while g&1==0:\n      g >>= 1\n      x += 1\n    prepare_to_right(loop, x)\n    prepare_to_right(tail, x)\n    rev = reversed(loop)\n    append_to_right(loop, x, 1)\n    loop.append((x+1, 0))\n    loop.extend(rev)\n    loop.extend(tail)\n    append_to_right(loop, x, 0)\n    append_to_right(tail, x, 1)\n    g >>= 1\n    x += 1\n  loop.extend(reversed(tail))\n  return loop\n\nN = int(input())\n\nsingle = 0\ntpg = []\nfor i in range(1<<N):\n  a = int(sys.stdin.read(1))\n  if bin(i).count(\"1\") == 1:\n    if a == 0:\n      single |= i\n  else:\n    b = i & single\n    if i and b | a == 0 and all(p & i != p for n, p in tpg):\n      heappush(tpg, (-first_1(i), i))\n    elif i | a == 0 or a and (b or any(p & i == p for n, p in tpg)):\n      print(\"Impossible\")\n      break\nelse:\n  raise\n  print(\"Possible\")\n  loop = []\n  for n, g in merge(sep_single(single), tpg):\n    subloop = subloop_tp_group(g)\n    if loop:\n      prepare_to_left(loop, subloop[0][0])\n      if loop[-1] == subloop[0]:\n        loop.pop()\n    loop.extend(subloop)\n  \n  if not loop:\n    loop.append((0, 0))\n  prepare_to_right(loop, loop[0][0])\n  \n  print(len(loop)-1)\n  for p in loop:\n    print(*p)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nN = int(readline())\nA = list(map(int,readline().rstrip().decode()))\n\nminimal_sets = []\nfor n in range(1<<N):\n    s = n\n    is_min = (A[n] == 0)\n    while s:\n        s = (s - 1) & n\n        if A[n] == 1 and A[s] == 0:\n            print('Impossible')\n            exit()\n        if A[s] == 0:\n            is_min = False\n    if is_min:\n        minimal_sets.append(n)\n\ndef make(nums, x):\n    if not nums:\n        return [(x,0)]\n    path = []\n    if len(nums) == 1:\n        n = nums[0]\n        for i in range(x, n+1):\n            path.append((i,0))\n        path += [(n+1,0),(n+1,1),(n,1),(n,0)]\n        for i in range(n-1,x-1,-1):\n            path.append((i,0))\n        return path\n    n = nums[0]\n    for i in range(x, n+1):\n        path.append((i,0))\n    P = make(nums[1:], n+1)\n    path += P\n    path += [(n,0), (n,1), (n+1,1), (n+1, 0)]\n    path += P[::-1][1:]\n    path += [(n+1,1), (n,1), (n,0)]\n    for i in range(n-1,x-1,-1):\n        path += [(i,0)]\n    return path\n\npath = [(0,0)]\nfor n in minimal_sets:\n    path += make([i for i in range(N) if n & (1<<i)], 0)[1:]\n\nprint('Possible')\nprint(len(path) - 1)\nprint('\\n'.join('{} {}'.format(x,y) for x,y in path))"
  },
  {
    "language": "Python",
    "code": "import sys\nN = int(input())\n\non = 0\nfor i in range(1<<N):\n  a = int(sys.stdin.read(1))\n  if bin(i).count(\"1\") == 1 and not a:\n    on |= i\nelse:\n  print(\"Possible\")\n  x = 0\n  while on and on & 1 == 0:\n    x += 1\n    on >>= 1\n  init = x\n  prev = 0\n  P = [(x, prev)]\n  while on:\n    b = on & 1\n    if prev != b:\n      P.append((x, b))\n    x += 1\n    P.append((x, b))\n    prev = b\n    on >>= 1\n  for x in range(x+prev-1, init-1, -1):\n    P.append((x, 0))\n  print(len(P)-1)\n  for p in P:\n    print(*p)"
  },
  {
    "language": "Python",
    "code": "print(\"Possible\")\nprint(0)\nprint(1, 1)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\ndef solve(A):\n    H,N = A.shape\n    if N == 1:\n        if np.all(A == 0):\n            return np.array([1], np.int64)\n        else:\n            return np.array([0], np.int64)\n    while True:\n        if np.all(A[:,0] == 0):\n            vals = solve(A[:,1:])\n            return np.concatenate([[np.abs(vals).sum() + 1], vals])\n        d = 10 ** 18\n        h = 0\n        for i in range(H):\n            if A[i,0] < 0:\n                A[i] *= -1 \n            if d > A[i,0] > 0:\n                d = A[i,0]\n                h = i\n        temp = A[0].copy()\n        A[0] = A[h]\n        A[h] = temp\n        if np.count_nonzero(A[:,0]) == 1:\n            vals = solve(A[1:,1:])\n            vals *= d\n            x = np.dot(vals, A[0,1:])\n            return np.concatenate([[-x//d], vals])\n        q = A[1:,0] // d\n        A[1:] -= q[:,None] * A[0][None,:]\n\nN = int(readline())\nA = list(map(int,readline().rstrip().decode()))\n\nN,A\n\neqs = []\nfor i in range(1<<N):\n    if A[i]:\n        eqs.append([1 if (i>>n)&1 else 0 for n in range(N)])\n\neqs = np.array(eqs, np.int64)\n\nvals = solve(eqs)\n\nfor i in range(1<<N):\n    S = sum(vals[j] for j in range(N) if (i>>j)&1)\n    if S == 0 and A[i] == 0:\n        print('Impossible')\n        exit()\n\ndef output(vals):\n    pts = []\n    for n,x in enumerate(vals):\n        pts.append([n,0])\n        positive = [[n+1,0],[n+1,n+1],[n,n+1],[n,0]]\n        negative = [[n,n+1],[n+1,n+1],[n+1,0],[n,0]]\n        if x > 0:\n            pts += positive * x\n        if x < 0:\n            pts += negative * (-x)\n    pts.append([N,0])\n    pts.append([N,-1])\n    pts.append([0,-1])\n    pts.append([0,0])\n    print('Possible')\n    print('\\n'.join('{} {}'.format(x,y) for x,y in pts))\n\noutput(vals)"
  },
  {
    "language": "Python",
    "code": "def rev(a):\n    return [-v for v in a]\n\ndef make(s):\n    assert len(s)>0\n    pre_s = s[:-1]\n    v = s[-1]\n    if len(pre_s)==0:\n        return [v]\n    return make(pre_s) + [v] + rev(make(pre_s)) + [-v]\n\ndef make_pre_path(v):\n    if v>0:\n        return [(i,0) for i in range(1,v+1)] + [(v,1), (v-1,1)] + [(i,0) for i in range(v-1,0,-1)]\n    elif v<0:\n        return make_pre_path(-v)[::-1]\n    assert False\n\ndef make_path(v):\n    return make_pre_path(v)+[(0,0)]\n\ndef test():\n    #print(make([1,2,3]))\n    main(\"1\",\"11\")\n    #main(\"8\",\"1\"+\"0\"*(2**8-1))\n\ndef main(s1,s2):\n    ok = True\n    n = int(s1)\n    ret_gp = []\n    for i in range(2**n-1,-1,-1):\n        s = [v+1 for v in range(n) if (i>>v)%2==1 ]\n        if s2[i]==\"0\":\n            for ind in range(n):\n                if (i>>ind)%2==0 and s2[(i+2**ind)]==\"1\":\n                    ok = False\n            ret_gp += make(s)\n    ret_path = [(0,0)] + [p for v in ret_gp for p in make_path(v)]\n    if ok:\n        print(\"Possible\")\n        print(len(ret_path) - 1)\n        for x,y in ret_path:\n            print(str(x)+\" \"+str(y))\n    else:\n        print(\"Impossible\")\n\ns1 = raw_input()\ns2 = raw_input()\nmain(s1,s2)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\ndef solve(A):\n    H,N = A.shape\n    if N == 1:\n        if np.all(A == 0):\n            return np.array([1], np.int64)\n        else:\n            return np.array([0], np.int64)\n    while True:\n        if np.all(A[:,0] == 0):\n            vals = solve(A[:,1:])\n            return np.concatenate([[np.abs(vals).sum() + 1], vals])\n        d = 10 ** 18\n        h = 0\n        for i in range(H):\n            if A[i,0] < 0:\n                A[i] *= -1 \n            if d > A[i,0] > 0:\n                d = A[i,0]\n                h = i\n        temp = A[0].copy()\n        A[0] = A[h]\n        A[h] = temp\n        if np.count_nonzero(A[:,0]) == 1:\n            vals = solve(A[1:,1:])\n            vals *= d\n            x = np.dot(vals, A[0,1:])\n            return np.concatenate([[-x//d], vals])\n        q = A[1:,0] // d\n        A[1:] -= q[:,None] * A[0][None,:]\n\nN = int(readline())\nA = list(map(int,readline().rstrip().decode()))\n\nN,A\n\neqs = []\nfor i in range(1<<N):\n    if A[i]:\n        eqs.append([1 if (i>>n)&1 else 0 for n in range(N)])\n\neqs = np.array(eqs, np.int64)\n\nvals = solve(eqs)\n\nfor i in range(1<<N):\n    S = sum(vals[j] for j in range(N) if (i>>j)&1)\n    if S == 0 and A[i] == 0:\n        print('Impossible')\n        exit()\n\ndef output(vals):\n    pts = []\n    for n,x in enumerate(vals):\n        pts.append([n,0])\n        positive = [[n+1,0],[n+1,n+1],[n,n+1],[n,0]]\n        negative = [[n,n+1],[n+1,n+1],[n+1,0],[n,0]]\n        if x > 0:\n            pts += positive * x\n        if x < 0:\n            pts += negative * (-x)\n    pts.append([N,0])\n    pts.append([N,-1])\n    pts.append([0,-1])\n    pts.append([0,0])\n    print('Possible')\n    print(len(pts))\n    print('\\n'.join('{} {}'.format(x,y) for x,y in pts))\n\noutput(vals)"
  },
  {
    "language": "Python",
    "code": "import sys\nN = int(input())\n\non = 0\nfor i in range(1<<N):\n  a = int(sys.stdin.read(1))\n  if bin(i).count(\"1\") == 1 and not a:\n    on |= i\n  if not a ^ bool(i & on):\n    print(\"Impossible\")\n    break\nelse:\n  raise ValueError"
  },
  {
    "language": "Python",
    "code": "import sys\nN = int(input())\n\non = 0\nfor i in range(1<<N):\n  a = int(sys.stdin.read(1))\n  if bin(i).count(\"1\") == 1 and not a:\n    on |= i\n  if not a ^ bool(i & on):\n    print(\"Impossible\")\n    break\nelse:\n  print(\"Possible\")\n  x = 0\n  while on and on & 1 == 0:\n    x += 1\n    on >>= 1\n  init = x\n  prev = 0\n  P = [(x, prev)]\n  while on:\n    b = on & 1\n    if prev != b:\n      P.append((x, b))\n    x += 1\n    P.append((x, b))\n    prev = b\n    on >>= 1\n  for x in range(x+prev-1, init-1, -1):\n    P.append((x, 0))\n  print(len(P)-1)\n  for p in P:\n    print(*p)"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom heapq import *\n\ndef first_1(x):\n  if x:\n    i = 0\n    while x & 1 == 0:\n      x >>= 1\n      i += 1\n    return i\n\ndef sep_single(s):\n  if s:\n    r = 1 << (s.bit_length()-1)\n    i = s.bit_length()-1\n    while s:\n      if r & s:\n        yield -i, r\n        s ^= r\n      r >>= 1\n      i -= 1\n\ndef prepare_to_right(g, x):\n  x0, y0 = g[-1]\n  if x0 < x and y0:\n    y0 = 0\n    g.append((x0, 0))\n  while x0 < x:\n    x0 += 1\n    g.append((x0, 0))\n\ndef prepare_to_left(g, x):\n  x0, y0 = g[-1]\n  if x+1 < x0 and y0:\n    y0 = 0\n    g.append((x0, 0))\n  while x+1 < x0:\n    x0 -= 1\n    g.append((x0, 0))\n\ndef append_to_right(g, x, y):\n  prepare_to_right(g, x)\n  x0, y0 = g[-1]\n  if y != y0:\n    g.append((x, y))\n  g.append((x+1, y))\n\ndef subloop_tp_group(g):\n  x = 0\n  while g&1 == 0:\n    g >>= 1\n    x += 1\n  loop = [(x+1, 0)]\n  tail = [(x, 0), (x, 1), (x+1, 1)]\n  g >>= 1\n  x += 1\n  while g:\n    while g&1==0:\n      g >>= 1\n      x += 1\n    prepare_to_right(loop, x)\n    prepare_to_right(tail, x)\n    rev = reversed(loop)\n    append_to_right(loop, x, 1)\n    loop.append((x+1, 0))\n    loop.extend(rev)\n    loop.extend(tail)\n    append_to_right(loop, x, 0)\n    append_to_right(tail, x, 1)\n    g >>= 1\n    x += 1\n  loop.extend(reversed(tail))\n  return loop\n\nN = int(input())\n\nsingle = 0\ntpg = []\nfor i in range(1<<N):\n  a = int(sys.stdin.read(1))\n  if bin(i).count(\"1\") == 1:\n    if a == 0:\n      single |= i\n  else:\n    b = i & single\n    if i and b | a == 0 and all(p & i != p for n, p in tpg):\n      heappush(tpg, (-first_1(i), i))\n    elif i | a == 0 or a and (b or any(p & i == p for n, p in tpg)):\n      print(\"Impossible\")\n      break\nelse:\n  print(\"Possible\")\n  loop = []\n  for n, g in merge(sep_single(single), nsmallest(len(tpg),tpg)):\n    subloop = subloop_tp_group(g)\n    if loop:\n      prepare_to_left(loop, subloop[0][0])\n      if loop[-1] == subloop[0]:\n        loop.pop()\n    loop.extend(subloop)\n  \n  if not loop:\n    loop.append((0, 0))\n  prepare_to_right(loop, loop[0][0])\n  \n  print(len(loop)-1)\n  for p in loop:\n    print(*p)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\ndef solve(A):\n    H,N = A.shape\n    if N == 1:\n        if np.all(A == 0):\n            return np.array([1], np.int64)\n        else:\n            return np.array([0], np.int64)\n    while True:\n        if np.all(A[:,0] == 0):\n            vals = solve(A[:,1:])\n            return np.concatenate([[np.abs(vals).sum() + 1], vals])\n        d = 10 ** 18\n        h = 0\n        for i in range(H):\n            if A[i,0] < 0:\n                A[i] *= -1 \n            if d > A[i,0] > 0:\n                d = A[i,0]\n                h = i\n        temp = A[0].copy()\n        A[0] = A[h]\n        A[h] = temp\n        if np.count_nonzero(A[:,0]) == 1:\n            vals = solve(A[1:,1:])\n            vals *= d\n            x = np.dot(vals, A[0,1:])\n            return np.concatenate([[-x//d], vals])\n        q = A[1:,0] // d\n        A[1:] -= q[:,None] * A[0][None,:]\n\nN = int(readline())\nA = list(map(int,readline().rstrip().decode()))\n\nN,A\n\neqs = []\nfor i in range(1<<N):\n    if A[i]:\n        eqs.append([1 if (i>>n)&1 else 0 for n in range(N)])\n\neqs = np.array(eqs, np.int64)\n\nvals = solve(eqs)\n\nfor i in range(1<<N):\n    S = sum(vals[j] for j in range(N) if (i>>j)&1)\n    if S == 0 and A[i] == 0:\n        print('Impossible')\n        exit()\n\ndef output(vals):\n    pts = []\n    for n,x in enumerate(vals):\n        pts.append([n,0])\n        positive = [[n+1,0],[n+1,n+1],[n,n+1],[n,0]]\n        negative = [[n,n+1],[n+1,n+1],[n+1,0],[n,0]]\n        if x > 0:\n            pts += positive * x\n        if x < 0:\n            pts += negative * (-x)\n    pts.append([N,0])\n    pts.append([N,-1])\n    pts.append([0,-1])\n    pts.append([0,0])\n    print('Possible')\n    print(len(pts) - 1)\n    print('\\n'.join('{} {}'.format(x,y) for x,y in pts))\n\noutput(vals)"
  },
  {
    "language": "Python",
    "code": "res = []\ndef main():\n    n = int(input())\n    a = [int(c) for c in input()]\n    \n    if a[0] == 0:\n        return False\n\n    for x in range(1, 2**n):\n        s = list(filter(lambda i: (x >> i) & 1, range(n)))\n        xl = [(x >> i) & 1 for i in range(n)]\n        if a[x] == 0:\n            def move_ceiling(r, dest):\n                i, j = r[-1]\n                if i < dest:\n                    for i in range(i, dest):\n                        if xl[i] == 0:\n                            if j == 1:\n                                r.append((i, 0))\n                                j = 0\n                            r.append((i + 1, 0))\n                        else:\n                            if j == 0:\n                                r.append((i, 1))\n                                j = 1\n                            r.append((i + 1, 1))\n                else:\n                    for i in range(i, dest, -1):\n                        if xl[i - 1] == 0:\n                            if j == 1:\n                                r.append((i, 0))\n                                j = 0\n                            r.append((i - 1, 0))\n                        else:\n                            if j == 0:\n                                r.append((i, 1))\n                                j = 1\n                            r.append((i - 1, 1))\n                return r\n            def move_floor(r, dest):\n                i, j = r[-1]\n                if j == 1:\n                    r.append((i, 0))\n                for i in range(i + 1, dest + 1) if i < dest else range(i - 1, dest - 1, -1):\n                    r.append((i, 0))\n                return r\n            u = move_ceiling([(0, 0)], s[0] + 1)\n            l = move_floor([(0, 0)], s[0] + 1)\n            cur = s[0] + 1\n            for d in s[1:]:\n                u = move_ceiling(u, d + 1)\n                u = move_floor(u, cur)\n                u = move_ceiling(u, 0)\n                u = move_floor(u, d + 1)\n                l = move_ceiling(u, d + 1)\n                u, l = l, u\n            l.reverse()\n            l.pop()\n            res.append(u + l)\n        else:\n            for d in s:\n                y = x ^ (1 << d)\n                if a[y] != 1:\n                    return False\n    return True\n\nif __name__ == '__main__':\n    if main():\n        print('Possible')\n        r = [(i, j) for r in res for i, j in r]\n        r.append((0, 0))\n        print(len(r) - 1)\n        for i, j in r:\n            print(i, j)\n    else:\n        print('Impossible')\n"
  },
  {
    "language": "Python",
    "code": "res = []\ndef main():\n    n = int(input())\n    a = [int(c) for c in input()]\n    \n    if a[0] == 0:\n        return False\n\n    for x in range(1, 2**n):\n        s = list(filter(lambda i: (x >> i) & 1, range(n)))\n        xl = [(x >> i) & 1 for i in range(n)]\n        if a[x] == 0:\n            def move_ceiling(r, dest):\n                i, j = r[-1]\n                if i < dest:\n                    for i in range(i, dest):\n                        if xl[i] == 0:\n                            if j == 1:\n                                r.append((i, 0))\n                                j = 0\n                            r.append((i + 1, 0))\n                        else:\n                            if j == 0:\n                                r.append((i, 1))\n                                j = 1\n                            r.append((i + 1, 1))\n                else:\n                    for i in range(i, dest, -1):\n                        if xl[i - 1] == 0:\n                            if j == 1:\n                                r.append((i, 0))\n                                j = 0\n                            r.append((i - 1, 0))\n                        else:\n                            if j == 0:\n                                r.append((i, 1))\n                                j = 1\n                            r.append((i - 1, 1))\n                return r\n            def move_floor(r, dest):\n                i, j = r[-1]\n                if j == 1:\n                    r.append((i, 0))\n                for i in range(i + 1, dest + 1) if i < dest else range(i - 1, dest - 1, -1):\n                    r.append((i, 0))\n                return r\n            u = move_ceiling([(0, 0)], s[0] + 1)\n            l = move_floor([(0, 0)], s[0] + 1)\n            cur = s[0] + 1\n            for d in s[1:]:\n                u = move_ceiling(u, d + 1)\n                u = move_floor(u, cur)\n                u = move_ceiling(u, s[0])\n                u = move_floor(u, d + 1)\n                l = move_ceiling(u, d + 1)\n                u, l = l, u\n                cur = d + 1\n            l.reverse()\n            l.pop()\n            res.append(u + l)\n        else:\n            for d in s:\n                y = x ^ (1 << d)\n                if a[y] != 1:\n                    return False\n    return True\n\nif __name__ == '__main__':\n    if main():\n        print('Possible')\n        r = [(i, j) for r in res for i, j in r]\n        r.append((0, 0))\n        print(len(r) - 1)\n        for i, j in r:\n            print(i, j)\n    else:\n        print('Impossible')\n"
  },
  {
    "language": "Python",
    "code": "def rev(a):\n    return [-v for v in a[::-1]]\n\ndef make(s):\n    assert len(s)>0\n    pre_s = s[:-1]\n    v = s[-1]\n    if len(pre_s)==0:\n        return [v]\n    return make(pre_s) + [v] + rev(make(pre_s)) + [-v]\n\ndef make_pre_path(v):\n    if v>0:\n        return [(i,0) for i in range(1,v+1)] + [(v,1), (v-1,1)] + [(i,0) for i in range(v-1,0,-1)]\n    elif v<0:\n        return make_pre_path(-v)[::-1]\n    assert False\n\ndef make_path(v):\n    return make_pre_path(v)+[(0,0)]\n\ndef test():\n    #print(make([1,2,3]))\n    main(\"3\",\"11111110\")\n    #main(\"8\",\"1\"+\"0\"*(2**8-1))\n\ndef main(s1,s2):\n    ok = True\n    n = int(s1)\n    ret_gp = []\n    for i in range(2**n-1,-1,-1):\n        s = [v+1 for v in range(n) if (i>>v)%2==1 ]\n        if s2[i]==\"0\":\n            for ind in range(n):\n                if (i>>ind)%2==0 and s2[(i+2**ind)]==\"1\":\n                    ok = False\n            if len(s)>0:\n                ret_gp += make(s)\n    ret_path = [(0,0)] + [p for v in ret_gp for p in make_path(v)]\n    if 0:\n        print(ret_gp)\n    if ok:\n        print(\"Possible\")\n        print(len(ret_path) - 1)\n        for x,y in ret_path:\n            print(str(x)+\" \"+str(y))\n    else:\n        print(\"Impossible\")\n\n#test()\n        \ns1 = raw_input()\ns2 = raw_input()\nmain(s1,s2)"
  },
  {
    "language": "Python",
    "code": "print(\"Impossible\")"
  },
  {
    "language": "Python",
    "code": "N = int(input())\na = [c == \"0\" for c in input().rstrip()]\n\nxs = [a[2**i] for i in range(N)]\nbs = [False]\nfor x in xs:\n    bs_add = [b or x for b in bs]\n    bs = bs + bs_add\npos = a == bs\n\nif not pos:\n    print(\"Impossible\")\nelse:\n    print(\"Possible\")\n    points = [(0, 0)]\n    for i, x in enumerate(xs):\n        if x:\n            points.append((i, 1))\n            points.append((i + 1, 1))\n        points.append((i + 1, 0))\n    for i in range(N):\n        points.append((N - 1 - i, 0))\n    print(len(points) - 1)\n    for x, y in points:\n        print(x, y)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nN = int(input())\n\non = 0\nfor i in range(1<<N):\n  a = int(sys.stdin.read(1))\n  if bin(i).count(\"1\") == 1 and not a:\n    on |= i\n  if not a ^ bool(i & on):\n    print(\"Impossible\")\n    break\nelse:\n  print(\"Possible\")\n  prev = 0\n  x = 0\n  P = [(x, prev)]\n  while on:\n    b = on & 1\n    if prev != b:\n      P.append((x, b))\n    x += 1\n    P.append((x, b))\n    prev = b\n    on >>= 1\n  for x in range(x+prev-1, -1, -1):\n    P.append((x, 0))\n  print(len(P)-1)\n  for p in P:\n    print(*p)"
  },
  {
    "language": "Python",
    "code": "res = []\n\nn = int(input())\na = [int(c) for c in input()]\n\ndef solve():\n    if a[0] == 0:\n        return False\n    for x in range(1, 2**n):\n        s = list(filter(lambda i: (x >> i) & 1, range(n)))\n        xl = [(x >> i) & 1 for i in range(n)]\n        if a[x] == 0:\n            for d in s:\n                y = x ^ (1 << d)\n                if a[y] == 1:\n                    break\n            else:\n                continue\n            def move_ceiling(r, dest):\n                i, j = r[-1]\n                if i < dest:\n                    for i in range(i, dest):\n                        if xl[i] == 0 and j == 1:\n                            r.append((i, 0))\n                            j = 0\n                        elif xl[i] == 1 and j == 0:\n                            r.append((i, 1))\n                            j = 1\n                        r.append((i + 1, j))\n                else:\n                    for i in range(i, dest, -1):\n                        if xl[i - 1] == 0 and j == 1:\n                            r.append((i, 0))\n                            j = 0\n                        elif xl[i - 1] == 1 and j == 0:\n                            r.append((i, 1))\n                            j = 1\n                        r.append((i - 1, j))\n                return r\n            def move_floor(r, dest):\n                i, j = r[-1]\n                if j == 1:\n                    r.append((i, 0))\n                for i in range(i + 1, dest + 1) if i < dest else range(i - 1, dest - 1, -1):\n                    r.append((i, 0))\n                return r\n            r = [(s[0] + 1, 1), (s[0], 1), (s[0], 0), (s[0] + 1, 0)]\n            cur = s[0] + 1\n            for d in s[1:]:\n                r0 = [(d + 1, 1)] if cur == d else move_ceiling([(d + 1, 1)], cur)\n                r1 = move_ceiling(r.copy(), d + 1)\n                r1 = move_floor(r1, cur)\n                r1.pop()\n                r2 = list(reversed(r))\n                r2 = move_floor(r2, d + 1)\n                r = r0 + r1 + r2\n                cur = d + 1\n            r = move_floor(r, n)\n            r.reverse()\n            r = move_floor(r, n)\n            r.pop()\n            res.append(r)\n        else:\n            for d in s:\n                y = x ^ (1 << d)\n                if a[y] != 1:\n                    return False\n    return True\n\nif __name__ == '__main__':\n    if solve():\n        print('Possible')\n        r = [(i, j) for r in res for i, j in r]\n        r.append((n, 0))\n        print(len(r) - 1)\n        for i, j in r:\n            print(i, j)\n    else:\n        print('Impossible')\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\na = [int(x) for x in input()]\n\nholes = []\n\nfor i in range(2**n-1, -1, -1):\n    if a[i] == 0:\n        continue\n    for j in range(i+1):\n        if (i | j) == i and a[j] == 0:\n            print(\"Impossible\")\n            exit()\n    if any((k | i) == k for k in holes):\n        continue\n    else:\n        holes.append(i)\n\nprint(\"Possible\")\nif holes[0] == 2**n-1:\n    print(0)\n    print(0, 0)\n    exit()\n\nclockwise = []\nanticlockwise = []\n\nfor i in range(n):\n    locus = []\n    for j in range(i+1):\n        locus.append((j, 0))\n    locus += [(i, 1), (i+1, 1), (i+1, 0)]\n    for j in range(i, -1, -1):\n        locus.append((j, 0))\n    clockwise.append(locus)\n    anticlockwise.append(locus[::-1])\n\nroops = []\n\nfor x in holes:\n    curve = []\n    x ^= (2**n-1)\n    for j in range(n):\n        if (x >> j) & 1:\n            curve += clockwise[j]\n    roops.append(curve)\n\nm = len(roops)\nans = roops[0]\n\nfor i in range(1, m):\n    ans = ans + roops[i] + ans[::-1] + roops[i][::-1]\n\nL = 0\nfor i, x in enumerate(ans):\n    if i > 0 and ans[i] == ans[i-1]:\n        continue\n    else:\n        L += 1\n\nprint(L)\nfor i, x in enumerate(ans):\n    if i > 0 and ans[i] == ans[i-1]:\n        continue\n    else:\n        print(*x)\n"
  },
  {
    "language": "Python",
    "code": "res = []\n\nn = int(input())\na = [int(c) for c in input()]\n\ndef solve():\n    if a[0] == 0:\n        return False\n    for x in range(1, 2**n):\n        s = list(filter(lambda i: (x >> i) & 1, range(n)))\n        xl = [(x >> i) & 1 for i in range(n)]\n        if a[x] == 0:\n            for d in s:\n                y = x ^ (1 << d)\n                if a[y] == 1:\n                    break\n            else:\n                continue\n            def move_ceiling(r, dest):\n                i, j = r[-1]\n                if i < dest:\n                    for i in range(i, dest):\n                        if xl[i] == 0 and j == 1:\n                            r.append((i, 0))\n                            j = 0\n                        elif xl[i] == 1 and j == 0:\n                            r.append((i, 1))\n                            j = 1\n                        r.append((i + 1, j))\n                else:\n                    for i in range(i, dest, -1):\n                        if xl[i - 1] == 0 and j == 1:\n                            r.append((i, 0))\n                            j = 0\n                        elif xl[i - 1] == 1 and j == 0:\n                            r.append((i, 1))\n                            j = 1\n                        r.append((i - 1, j))\n                return r\n            def move_floor(r, dest):\n                i, j = r[-1]\n                if j == 1:\n                    r.append((i, 0))\n                for i in range(i + 1, dest + 1) if i < dest else range(i - 1, dest - 1, -1):\n                    r.append((i, 0))\n                return r\n            r = [(s[0] + 1, 1), (s[0], 1), (s[0], 0), (s[0] + 1, 0)]\n            cur = s[0] + 1\n            for d in s[1:]:\n                r0 = [(d + 1, 1)] if cur == d else move_ceiling([(d + 1, 1)], cur)\n                r1 = move_ceiling(r.copy(), d + 1)\n                r1 = move_floor(r1, cur)\n                r1.pop()\n                r2 = list(reversed(r))\n                r2 = move_floor(r2, d + 1)\n                r = r0 + r1 + r2\n            r = move_floor(r, n)\n            r.reverse()\n            r = move_floor(r, n)\n            r.pop()\n            res.append(r)\n        else:\n            for d in s:\n                y = x ^ (1 << d)\n                if a[y] != 1:\n                    return False\n    return True\n\nif __name__ == '__main__':\n    if solve():\n        print('Possible')\n        r = [(i, j) for r in res for i, j in r]\n        r.append((n, 0))\n        print(len(r) - 1)\n        for i, j in r:\n            print(i, j)\n    else:\n        print('Impossible')\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\na = [int(x) for x in input()]\n\nholes = []\n\nfor i in range(2**n-1, -1, -1):\n    if a[i] == 0:\n        continue\n    for j in range(i+1):\n        if (i | j) == i and a[j] == 0:\n            print(\"Impossible\")\n            exit()\n    if any((k | i) == k for k in holes):\n        continue\n    else:\n        holes.append(i)\n\nprint(\"Possible\")\nif holes[0] == 2**n-1:\n    print(0)\n    print(0, 0)\n    exit()\n\nclockwise = []\nanticlockwise = []\n\nfor i in range(n):\n    locus = []\n    for j in range(i+1):\n        locus.append((j, 0))\n    locus += [(i, 1), (i+1, 1), (i+1, 0)]\n    for j in range(i, -1, -1):\n        locus.append((j, 0))\n    clockwise.append(locus)\n    anticlockwise.append(locus[::-1])\n\nm = len(holes)\nroops = []\n\nfor i in range(m):\n    x = holes[i] ^ (2**n-1)\n    curve = []\n    for j in range(n):\n        if (x >> j) & 1:\n            curve += clockwise[j]\n    roops.append(curve)\n\nm = len(roops)\nans = roops[0]\n\nfor i in range(1, m):\n    ans = ans + roops[i] + ans[::-1] + roops[i][::-1]\n\nL = -1\nfor i, x in enumerate(ans):\n    if i > 0 and ans[i] == ans[i-1]:\n        continue\n    else:\n        L += 1\n\nprint(L)\nfor i, x in enumerate(ans):\n    if i > 0 and ans[i] == ans[i-1]:\n        continue\n    else:\n        print(*x)\n"
  },
  {
    "language": "Python",
    "code": "n = int(input())\na = [1 - int(c) for c in input()]\n\ns = [a[1 << i] for i in range(n)]\n\nfor x in range(2 ** n):\n    t = any(s[i] for i in filter(lambda i: (x >> i) & 1, range(n)))\n    if a[x] != t:\n        possible = False\n        break\nelse:\n    possible = True\n\nif possible:\n    print('Possible')\n    res = [(0, 0)]\n    for i in range(n):\n        if s[i]:\n            res.append((i, 1))\n            res.append((i+1, 1))\n        res.append((i+1, 0))\n    for i in range(n - 1, -1, -1):\n        res.append((i, 0))\n    print(len(res) - 1)\n    for x, y in res:\n        print(x, y)\nelse:\n    print('Impossible')\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused)]\nmacro_rules! debug {\n    ($($format:tt)*) => (write!(std::io::stderr(), $($format)*).unwrap());\n}\n#[allow(unused)]\nmacro_rules! debugln {\n    ($($format:tt)*) => (writeln!(std::io::stderr(), $($format)*).unwrap());\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (let _ = write!(out,$($format)*););\n    }\n    input! {\n        n: usize,\n        a: chars,\n    }\n    for i in 0..1 << n {\n        for j in 0..1 << n {\n            if (i & j) == i && a[i] == '0' && a[j] == '1' {\n                puts!(\"Impossible\\n\");\n                return;\n            }\n        }\n    }\n    if a[0] == '0' {\n        puts!(\"Impossible\\n\");\n        return;\n    }\n    let mut ans = vec![];\n    for i in 1..1 << n {\n        if a[i] == '1' {\n            continue;\n        }\n        if i.is_power_of_two() {\n            // one loop\n            let x = (i - 1).count_ones() as i64;\n            for j in 0..x + 1 {\n                ans.push((j, 0));\n            }\n            ans.push((x, 1));\n            ans.push((x + 1, 1));\n            for j in (1..x + 2).rev() {\n                ans.push((j, 0));\n            }\n            continue;\n        }\n        let mut c = vec![];\n        for j in 0..n {\n            if (i & 1 << j) != 0 {\n                c.push(j);\n            }\n        }\n        let &ma = c.last().unwrap();\n        for j in 0..ma + 1 {\n            if j != ma && (i & 1 << j) != 0 {\n                let j = j as i64;\n                ans.push((j, 0));\n                ans.push((j, 1));\n                ans.push((j + 1, 1));\n            } else {\n                ans.push((j as i64, 0));\n            }\n        }\n        for j in (0..ma + 1).rev() {\n            let x = j as i64;\n            if (i & 1 << j) != 0 {\n                ans.push((x + 1, 0));\n                ans.push((x + 1, 1));\n                ans.push((x, 1));\n            } else {\n                ans.push((x + 1, 0));\n            }\n        }\n        for j in 0..ma {\n            ans.push((j as i64, 0));\n        }\n        let max = ma as i64;\n        ans.push((max, 0));\n        ans.push((max, 1));\n        ans.push((max + 1, 1));\n        for j in (0..ma + 1).rev() {\n            ans.push((j as i64 + 1, 0));\n        }\n    }\n    ans.push((0, 0));\n    puts!(\"Possible\\n\");\n    puts!(\"{}\\n\", ans.len());\n    for (x, y) in ans {\n        puts!(\"{} {}\\n\", x, y);\n    }\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused)]\nmacro_rules! debug {\n    ($($format:tt)*) => (write!(std::io::stderr(), $($format)*).unwrap());\n}\n#[allow(unused)]\nmacro_rules! debugln {\n    ($($format:tt)*) => (writeln!(std::io::stderr(), $($format)*).unwrap());\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (let _ = write!(out,$($format)*););\n    }\n    input! {\n        n: usize,\n        a: chars,\n    }\n    for i in 0..1 << n {\n        for j in 0..1 << n {\n            if (i & j) == i && a[i] == '0' && a[j] == '1' {\n                puts!(\"Impossible\\n\");\n                return;\n            }\n        }\n    }\n    if a[0] == '0' {\n        puts!(\"Impossible\\n\");\n        return;\n    }\n    let mut ans = vec![];\n    for i in 1..1 << n {\n        if a[i] == '1' {\n            continue;\n        }\n        if i.is_power_of_two() {\n            // one loop\n            let x = (i - 1).count_ones() as i64;\n            for j in 0..x + 1 {\n                ans.push((j, 0));\n            }\n            ans.push((x, 1));\n            ans.push((x + 1, 1));\n            for j in (1..x + 2).rev() {\n                ans.push((j, 0));\n            }\n            continue;\n        }\n        let mut c = vec![];\n        for j in 0..n {\n            if (i & 1 << j) != 0 {\n                c.push(j);\n            }\n        }\n        let &ma = c.last().unwrap();\n        for j in 0..ma + 1 {\n            if j != ma && (i & 1 << j) != 0 {\n                let j = j as i64;\n                ans.push((j, 0));\n                ans.push((j, 1));\n                ans.push((j + 1, 1));\n            } else {\n                ans.push((j as i64, 0));\n            }\n        }\n        for j in (0..ma + 1).rev() {\n            let x = j as i64;\n            if (i & 1 << j) != 0 {\n                ans.push((x + 1, 0));\n                ans.push((x + 1, 1));\n                ans.push((x, 1));\n            } else {\n                ans.push((x + 1, 0));\n            }\n        }\n        for j in 0..ma {\n            ans.push((j as i64, 0));\n        }\n        let max = ma as i64;\n        ans.push((max, 0));\n        ans.push((max, 1));\n        ans.push((max + 1, 1));\n        for j in (0..ma + 1).rev() {\n            ans.push((j as i64 + 1, 0));\n        }\n    }\n    ans.push((0, 0));\n    assert!(ans.len() - 1 <= 250_000);\n    puts!(\"Possible\\n\");\n    puts!(\"{}\\n\", ans.len() - 1);\n    for (x, y) in ans {\n        puts!(\"{} {}\\n\", x, y);\n    }\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut iter = $ s . split_whitespace ( ) ; input_inner ! { iter , $ ( $ r ) * } } ; ( iter = $ iter : ident , $ ( $ r : tt ) * ) => { let s = { use std :: io :: Read ; let mut s = String :: new ( ) ; std :: io :: stdin ( ) . read_to_string ( & mut s ) . unwrap ( ) ; s } ; let mut $ iter = s . split_whitespace ( ) ; input_inner ! { $ iter , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { let s = { use std :: io :: Read ; let mut s = String :: new ( ) ; std :: io :: stdin ( ) . read_to_string ( & mut s ) . unwrap ( ) ; s } ; let mut iter = s . split_whitespace ( ) ; input_inner ! { iter , $ ( $ r ) * } } ; }\nmacro_rules ! input_inner { ( $ iter : expr ) => { } ; ( $ iter : expr , ) => { } ; ( $ iter : expr , mut $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let mut $ var = read_value ! ( $ iter , $ t ) ; input_inner ! { $ iter $ ( $ r ) * } } ; ( $ iter : expr , mut $ var : ident $ ( $ r : tt ) * ) => { input_inner ! { $ iter , mut $ var : usize $ ( $ r ) * } } ; ( $ iter : expr , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ iter , $ t ) ; input_inner ! { $ iter $ ( $ r ) * } } ; ( $ iter : expr , $ var : ident $ ( $ r : tt ) * ) => { input_inner ! { $ iter , $ var : usize $ ( $ r ) * } } ; }\nmacro_rules ! read_value { ( $ iter : expr , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ iter , $ t ) ) ,* ) } ; ( $ iter : expr , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ iter , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ iter : expr , { chars : $ base : expr } ) => { read_value ! ( $ iter , String ) . chars ( ) . map ( | c | ( c as u8 - $ base as u8 ) as usize ) . collect ::< Vec < usize >> ( ) } ; ( $ iter : expr , { char : $ base : expr } ) => { read_value ! ( $ iter , { chars : $ base } ) [ 0 ] } ; ( $ iter : expr , chars ) => { read_value ! ( $ iter , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ iter : expr , char ) => { read_value ! ( $ iter , chars ) [ 0 ] } ; ( $ iter : expr , usize1 ) => { read_value ! ( $ iter , usize ) - 1 } ; ( $ iter : expr , $ t : ty ) => { $ iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) } ; }\n#[derive(Clone, Copy, Debug)]\npub enum Go {\n    L,\n    R,\n    D,\n    U,\n    T,\n}\nimpl Go {\n    pub fn rev(self) -> Self {\n        match self {\n            Go::L => Go::R,\n            Go::R => Go::L,\n            g => g,\n        }\n    }\n}\nfn rec(i: usize) -> Vec<Go> {\n    if i == 0 {\n        vec![]\n    } else if i == 1 {\n        vec![Go::R, Go::U, Go::L, Go::D]\n    } else if i & 1 == 1 {\n        let mut res = vec![Go::R];\n        let v = rec(i / 2);\n        res.extend(v.clone());\n        res.push(Go::L);\n        res.push(Go::U);\n        res.push(Go::R);\n        res.extend(v.into_iter().rev().map(|g| g.rev()));\n        res.push(Go::L);\n        res.push(Go::D);\n        res\n    } else {\n        let mut res = vec![Go::T, Go::R, Go::T];\n        res.extend(rec(i / 2));\n        res.push(Go::T);\n        res.push(Go::L);\n        res.push(Go::T);\n        res\n    }\n}\nfn main() {\n    input! { n, a: { chars: '0' } };\n    if (0..1 << n).all(|i| a[i] == 0 || (0..1 << n).all(|j| i & j != j || a[j] == 1)) {\n        println!(\"Possible\");\n        let mut used = vec![false; 1 << n];\n        let mut v = vec![];\n        for i in 0..1 << n {\n            if a[i] == 0 && !used[i] {\n                v.push(i);\n                for j in 0..1 << n {\n                    if i & j == i {\n                        used[j] = true;\n                    }\n                }\n            }\n        }\n        let mut path = vec![];\n        for i in v.into_iter() {\n            path.extend(rec(i));\n        }\n        let (mut x, mut y) = (0, 0);\n        let mut t = false;\n        let mut ans = vec![(x, y)];\n        for g in path.into_iter() {\n            match g {\n                Go::L => {\n                    x -= 1;\n                }\n                Go::R => {\n                    x += 1;\n                }\n                Go::U => {\n                    y += 1;\n                }\n                Go::D => {\n                    y -= 1;\n                }\n                Go::T => {\n                    if y == 1 {\n                        if !t {\n                            y = 0;\n                            t = true;\n                        } else {\n                            continue;\n                        }\n                    } else if y == 0 {\n                        if t {\n                            y = 1;\n                            t = false;\n                        } else {\n                            continue;\n                        }\n                    }\n                }\n            }\n            ans.push((x, y));\n        }\n        println!(\"{}\", ans.len() - 1);\n        for (x, y) in ans.into_iter() {\n            println!(\"{} {}\", x, y);\n        }\n    } else {\n        println!(\"Impossible\");\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused)]\nmacro_rules! debug {\n    ($($format:tt)*) => (write!(std::io::stderr(), $($format)*).unwrap());\n}\n#[allow(unused)]\nmacro_rules! debugln {\n    ($($format:tt)*) => (writeln!(std::io::stderr(), $($format)*).unwrap());\n}\n\nfn conn<T: Eq + Copy + std::fmt::Debug>(ans: &mut Vec<T>, ops: &[T]) {\n    assert_eq!(ans.last(), ops.first());\n    for i in 1..ops.len() {\n        ans.push(ops[i]);\n    }\n}\n\nfn calc(n: usize, bits: usize) -> Vec<(i64, i64)> {\n    if bits == 0 {\n        return vec![(0, 0)];\n    }\n    let mut ma = 0;\n    for i in 0..n {\n        if (bits & 1 << i) != 0 {\n            ma = i;\n        }\n    }\n    let mut sub = calc(n, bits ^ 1 << ma);\n    let mut t = vec![];\n    for i in 0..ma + 1 {\n        t.push((i as i64, 0));\n    }\n    t.push((ma as i64, 1));\n    t.push((ma as i64 + 1, 1));\n    for i in (0..ma + 2).rev() {\n        t.push((i as i64, 0));\n    }\n    if bits == 1 << ma {\n        return t;\n    }\n    let mut ans = vec![(0, 0)];\n    // commutator\n    conn(&mut ans, &sub);\n    conn(&mut ans, &t);\n    sub.reverse();\n    t.reverse();\n    conn(&mut ans, &sub);\n    conn(&mut ans, &t);\n    ans\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (let _ = write!(out,$($format)*););\n    }\n    input! {\n        n: usize,\n        a: chars,\n    }\n    for i in 0..1 << n {\n        for j in 0..1 << n {\n            if (i & j) == i && a[i] == '0' && a[j] == '1' {\n                puts!(\"Impossible\\n\");\n                return;\n            }\n        }\n    }\n    if a[0] == '0' {\n        puts!(\"Impossible\\n\");\n        return;\n    }\n    let mut ans = vec![(0, 0)];\n    for i in 1..1 << n {\n        if a[i] == '1' {\n            continue;\n        }\n        conn(&mut ans, &calc(n, i));\n    }\n    assert!(ans.len() - 1 <= 250_000);\n    puts!(\"Possible\\n\");\n    puts!(\"{}\\n\", ans.len() - 1);\n    for (x, y) in ans {\n        puts!(\"{} {}\\n\", x, y);\n    }\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut iter = $ s . split_whitespace ( ) ; input_inner ! { iter , $ ( $ r ) * } } ; ( iter = $ iter : ident , $ ( $ r : tt ) * ) => { let s = { use std :: io :: Read ; let mut s = String :: new ( ) ; std :: io :: stdin ( ) . read_to_string ( & mut s ) . unwrap ( ) ; s } ; let mut $ iter = s . split_whitespace ( ) ; input_inner ! { $ iter , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { let s = { use std :: io :: Read ; let mut s = String :: new ( ) ; std :: io :: stdin ( ) . read_to_string ( & mut s ) . unwrap ( ) ; s } ; let mut iter = s . split_whitespace ( ) ; input_inner ! { iter , $ ( $ r ) * } } ; }\nmacro_rules ! input_inner { ( $ iter : expr ) => { } ; ( $ iter : expr , ) => { } ; ( $ iter : expr , mut $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let mut $ var = read_value ! ( $ iter , $ t ) ; input_inner ! { $ iter $ ( $ r ) * } } ; ( $ iter : expr , mut $ var : ident $ ( $ r : tt ) * ) => { input_inner ! { $ iter , mut $ var : usize $ ( $ r ) * } } ; ( $ iter : expr , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ iter , $ t ) ; input_inner ! { $ iter $ ( $ r ) * } } ; ( $ iter : expr , $ var : ident $ ( $ r : tt ) * ) => { input_inner ! { $ iter , $ var : usize $ ( $ r ) * } } ; }\nmacro_rules ! read_value { ( $ iter : expr , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ iter , $ t ) ) ,* ) } ; ( $ iter : expr , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ iter , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ iter : expr , { chars : $ base : expr } ) => { read_value ! ( $ iter , String ) . chars ( ) . map ( | c | ( c as u8 - $ base as u8 ) as usize ) . collect ::< Vec < usize >> ( ) } ; ( $ iter : expr , { char : $ base : expr } ) => { read_value ! ( $ iter , { chars : $ base } ) [ 0 ] } ; ( $ iter : expr , chars ) => { read_value ! ( $ iter , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ iter : expr , char ) => { read_value ! ( $ iter , chars ) [ 0 ] } ; ( $ iter : expr , usize1 ) => { read_value ! ( $ iter , usize ) - 1 } ; ( $ iter : expr , $ t : ty ) => { $ iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) } ; }\n#[derive(Clone, Copy, Debug)]\npub enum Go {\n    L,\n    R,\n    D,\n    U,\n}\nimpl Go {\n    pub fn rev(self) -> Self {\n        match self {\n            Go::L => Go::R,\n            Go::R => Go::L,\n            Go::D => Go::D,\n            Go::U => Go::U,\n        }\n    }\n}\nfn rec(i: usize) -> Vec<Go> {\n    if i == 0 {\n        vec![]\n    } else if i == 1 {\n        vec![Go::R, Go::U, Go::L, Go::D]\n    } else if i & 1 == 1 {\n        let mut res = vec![Go::R];\n        let v = rec(i / 2);\n        res.extend(v.clone());\n        res.push(Go::L);\n        res.push(Go::U);\n        res.push(Go::R);\n        res.extend(v.into_iter().rev().map(|g| g.rev()));\n        res.push(Go::L);\n        res.push(Go::D);\n        res\n    } else {\n        let mut res = vec![Go::R];\n        res.extend(rec(i / 2));\n        res.push(Go::L);\n        res\n    }\n}\nfn main() {\n    input! { n, a: { chars: '0' } };\n    if (0..1 << n).all(|i| a[i] == 0 || (0..1 << n).all(|j| i & j != j || a[j] == 1)) {\n        println!(\"Possible\");\n        let mut used = vec![false; 1 << n];\n        let mut v = vec![];\n        for i in 0..1 << n {\n            if a[i] == 0 && !used[i] {\n                v.push(i);\n                for j in 0..1 << n {\n                    if i & j == i {\n                        used[j] = true;\n                    }\n                }\n            }\n        }\n        let mut path = vec![];\n        for i in v.into_iter() {\n            path.extend(rec(i));\n        }\n        println!(\"{}\", path.len());\n        println!(\"{} {}\", 0, 0);\n        let (mut x, mut y) = (0, 0);\n        for g in path.into_iter() {\n            match g {\n                Go::L => {\n                    x -= 1;\n                }\n                Go::R => {\n                    x += 1;\n                }\n                Go::U => {\n                    y += 1;\n                }\n                Go::D => {\n                    y -= 1;\n                }\n            }\n            println!(\"{} {}\", x, y);\n        }\n    } else {\n        println!(\"Impossible\");\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused)]\nmacro_rules! debug {\n    ($($format:tt)*) => (write!(std::io::stderr(), $($format)*).unwrap());\n}\n#[allow(unused)]\nmacro_rules! debugln {\n    ($($format:tt)*) => (writeln!(std::io::stderr(), $($format)*).unwrap());\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (let _ = write!(out,$($format)*););\n    }\n    input! {\n        n: usize,\n        a: chars,\n    }\n    for i in 0..1 << n {\n        for j in 0..1 << n {\n            if (i & j) == i && a[i] == '0' && a[j] == '1' {\n                puts!(\"Impossible\\n\");\n                return;\n            }\n        }\n    }\n    if a[0] == '0' {\n        puts!(\"Impossible\\n\");\n        return;\n    }\n    let mut ans = vec![];\n    for i in 1..1 << n {\n        if a[i] == '1' {\n            continue;\n        }\n        if i.is_power_of_two() {\n            // one loop\n            let x = (i - 1).count_ones() as i64;\n            for j in 0..x + 1 {\n                ans.push((j, 0));\n            }\n            ans.push((x, 1));\n            ans.push((x + 1, 1));\n            for j in (1..x + 2).rev() {\n                ans.push((j, 0));\n            }\n            continue;\n        }\n        let mut c = vec![];\n        for j in 0..n {\n            if (i & 1 << j) != 0 {\n                c.push(j);\n            }\n        }\n        let &ma = c.last().unwrap();\n        for j in 0..ma + 1 {\n            if j != ma && (i & 1 << j) != 0 {\n                let j = j as i64;\n                ans.push((j, 0));\n                ans.push((j, 1));\n                ans.push((j + 1, 1));\n            } else {\n                ans.push((j as i64, 0));\n            }\n        }\n        for j in (0..ma + 1).rev() {\n            let x = j as i64;\n            if (i & 1 << j) != 0 {\n                ans.push((x + 1, 0));\n                ans.push((x + 1, 1));\n                ans.push((x, 1));\n            } else {\n                ans.push((x + 1, 0));\n            }\n        }\n        for j in 0..ma {\n            ans.push((j as i64, 0));\n        }\n        let max = ma as i64;\n        ans.push((max, 0));\n        ans.push((max, 1));\n        ans.push((max + 1, 1));\n        for j in (0..ma + 1).rev() {\n            ans.push((j as i64 + 1, 0));\n        }\n    }\n    ans.push((0, 0));\n    assert!(ans.len() <= 250_000);\n    puts!(\"Possible\\n\");\n    puts!(\"{}\\n\", ans.len());\n    for (x, y) in ans {\n        puts!(\"{} {}\\n\", x, y);\n    }\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut iter = $ s . split_whitespace ( ) ; input_inner ! { iter , $ ( $ r ) * } } ; ( iter = $ iter : ident , $ ( $ r : tt ) * ) => { let s = { use std :: io :: Read ; let mut s = String :: new ( ) ; std :: io :: stdin ( ) . read_to_string ( & mut s ) . unwrap ( ) ; s } ; let mut $ iter = s . split_whitespace ( ) ; input_inner ! { $ iter , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { let s = { use std :: io :: Read ; let mut s = String :: new ( ) ; std :: io :: stdin ( ) . read_to_string ( & mut s ) . unwrap ( ) ; s } ; let mut iter = s . split_whitespace ( ) ; input_inner ! { iter , $ ( $ r ) * } } ; }\nmacro_rules ! input_inner { ( $ iter : expr ) => { } ; ( $ iter : expr , ) => { } ; ( $ iter : expr , mut $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let mut $ var = read_value ! ( $ iter , $ t ) ; input_inner ! { $ iter $ ( $ r ) * } } ; ( $ iter : expr , mut $ var : ident $ ( $ r : tt ) * ) => { input_inner ! { $ iter , mut $ var : usize $ ( $ r ) * } } ; ( $ iter : expr , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ iter , $ t ) ; input_inner ! { $ iter $ ( $ r ) * } } ; ( $ iter : expr , $ var : ident $ ( $ r : tt ) * ) => { input_inner ! { $ iter , $ var : usize $ ( $ r ) * } } ; }\nmacro_rules ! read_value { ( $ iter : expr , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ iter , $ t ) ) ,* ) } ; ( $ iter : expr , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ iter , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ iter : expr , { chars : $ base : expr } ) => { read_value ! ( $ iter , String ) . chars ( ) . map ( | c | ( c as u8 - $ base as u8 ) as usize ) . collect ::< Vec < usize >> ( ) } ; ( $ iter : expr , { char : $ base : expr } ) => { read_value ! ( $ iter , { chars : $ base } ) [ 0 ] } ; ( $ iter : expr , chars ) => { read_value ! ( $ iter , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ iter : expr , char ) => { read_value ! ( $ iter , chars ) [ 0 ] } ; ( $ iter : expr , usize1 ) => { read_value ! ( $ iter , usize ) - 1 } ; ( $ iter : expr , $ t : ty ) => { $ iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) } ; }\nfn main() {\n    input! { n, a: { chars: '0' } };\n    for i in 0..1 << n {\n        let mut w = vec![1; 1 << n];\n        for j in 0..n {\n            if i & 1 << j != 0 {\n                for k in 0..1 << n {\n                    if k & 1 << j != 0 {\n                        w[k] = 0;\n                    }\n                }\n            }\n        }\n        if w != a {\n            continue;\n        }\n        println!(\"Possible\");\n        let mut v = vec![(0, 0)];\n        for j in 0..n {\n            if i & 1 << j != 0 {\n                v.push((j, 1));\n                v.push((j + 1, 1));\n            }\n            v.push((j + 1, 0));\n        }\n        for j in (0..n).rev() {\n            v.push((j, 0));\n        }\n        println!(\"{}\", v.len() - 1);\n        for &(x, y) in &v {\n            println!(\"{} {}\", x, y);\n        }\n        return;\n    }\n    println!(\"Impossible\");\n}\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut iter = $ s . split_whitespace ( ) ; input_inner ! { iter , $ ( $ r ) * } } ; ( iter = $ iter : ident , $ ( $ r : tt ) * ) => { let s = { use std :: io :: Read ; let mut s = String :: new ( ) ; std :: io :: stdin ( ) . read_to_string ( & mut s ) . unwrap ( ) ; s } ; let mut $ iter = s . split_whitespace ( ) ; input_inner ! { $ iter , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { let s = { use std :: io :: Read ; let mut s = String :: new ( ) ; std :: io :: stdin ( ) . read_to_string ( & mut s ) . unwrap ( ) ; s } ; let mut iter = s . split_whitespace ( ) ; input_inner ! { iter , $ ( $ r ) * } } ; }\nmacro_rules ! input_inner { ( $ iter : expr ) => { } ; ( $ iter : expr , ) => { } ; ( $ iter : expr , mut $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let mut $ var = read_value ! ( $ iter , $ t ) ; input_inner ! { $ iter $ ( $ r ) * } } ; ( $ iter : expr , mut $ var : ident $ ( $ r : tt ) * ) => { input_inner ! { $ iter , mut $ var : usize $ ( $ r ) * } } ; ( $ iter : expr , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ iter , $ t ) ; input_inner ! { $ iter $ ( $ r ) * } } ; ( $ iter : expr , $ var : ident $ ( $ r : tt ) * ) => { input_inner ! { $ iter , $ var : usize $ ( $ r ) * } } ; }\nmacro_rules ! read_value { ( $ iter : expr , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ iter , $ t ) ) ,* ) } ; ( $ iter : expr , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ iter , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ iter : expr , { chars : $ base : expr } ) => { read_value ! ( $ iter , String ) . chars ( ) . map ( | c | ( c as u8 - $ base as u8 ) as usize ) . collect ::< Vec < usize >> ( ) } ; ( $ iter : expr , { char : $ base : expr } ) => { read_value ! ( $ iter , { chars : $ base } ) [ 0 ] } ; ( $ iter : expr , chars ) => { read_value ! ( $ iter , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ iter : expr , char ) => { read_value ! ( $ iter , chars ) [ 0 ] } ; ( $ iter : expr , usize1 ) => { read_value ! ( $ iter , usize ) - 1 } ; ( $ iter : expr , $ t : ty ) => { $ iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) } ; }\n#[derive(Clone, Copy, Debug)]\npub enum Go {\n    L,\n    R,\n    D,\n    U,\n    T,\n}\nimpl Go {\n    pub fn rev(self) -> Self {\n        match self {\n            Go::L => Go::R,\n            Go::R => Go::L,\n            g => g,\n        }\n    }\n}\nfn rec(i: usize) -> Vec<Go> {\n    if i == 0 {\n        vec![]\n    } else if i == 1 {\n        vec![Go::R, Go::U, Go::L, Go::D]\n    } else if i & 1 == 1 {\n        let mut res = vec![Go::R];\n        let v = rec(i / 2);\n        res.extend(v.clone());\n        res.push(Go::L);\n        res.push(Go::U);\n        res.push(Go::R);\n        res.extend(v.into_iter().rev().map(|g| g.rev()));\n        res.push(Go::L);\n        res.push(Go::D);\n        res\n    } else {\n        let mut res = vec![Go::T, Go::R, Go::T];\n        res.extend(rec(i / 2));\n        res.push(Go::T);\n        res.push(Go::L);\n        res.push(Go::T);\n        res\n    }\n}\nfn main() {\n    input! { n, a: { chars: '0' } };\n    if (0..1 << n).all(|i| a[i] == 0 || (0..1 << n).all(|j| i & j != j || a[j] == 1)) {\n        println!(\"Possible\");\n        let mut used = vec![false; 1 << n];\n        let mut v = vec![];\n        for i in 0..1 << n {\n            if a[i] == 0 && !used[i] {\n                v.push(i);\n                for j in 0..1 << n {\n                    if i & j == i {\n                        used[j] = true;\n                    }\n                }\n            }\n        }\n        let mut path = vec![];\n        for i in v.into_iter() {\n            path.extend(rec(i));\n        }\n        println!(\"{}\", path.len());\n        println!(\"{} {}\", 0, 0);\n        let (mut x, mut y) = (0, 0);\n        let mut t = false;\n        for g in path.into_iter() {\n            match g {\n                Go::L => {\n                    x -= 1;\n                }\n                Go::R => {\n                    x += 1;\n                }\n                Go::U => {\n                    y += 1;\n                }\n                Go::D => {\n                    y -= 1;\n                }\n                Go::T => {\n                    if y == 1 {\n                        if !t {\n                            y = 0;\n                            t = true;\n                        } else {\n                            continue;\n                        }\n                    } else if y == 0 {\n                        if t {\n                            y = 1;\n                            t = false;\n                        } else {\n                            continue;\n                        }\n                    }\n                }\n            }\n            println!(\"{} {}\", x, y);\n        }\n    } else {\n        println!(\"Impossible\");\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused)]\nmacro_rules! debug {\n    ($($format:tt)*) => (write!(std::io::stderr(), $($format)*).unwrap());\n}\n#[allow(unused)]\nmacro_rules! debugln {\n    ($($format:tt)*) => (writeln!(std::io::stderr(), $($format)*).unwrap());\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (let _ = write!(out,$($format)*););\n    }\n    input! {\n        n: usize,\n        a: chars,\n    }\n    for i in 0..1 << n {\n        for j in 0..1 << n {\n            if (i & j) == i && a[i] == '0' && a[j] == '1' {\n                puts!(\"Impossible\\n\");\n                return;\n            }\n        }\n    }\n    if a[0] == '0' {\n        puts!(\"Impossible\\n\");\n        return;\n    }\n    let mut ans = vec![];\n    for i in 1..1 << n {\n        if a[i] == '1' {\n            continue;\n        }\n        if i.is_power_of_two() {\n            // one loop\n            let x = (i - 1).count_ones() as i64;\n            for j in 0..x + 1 {\n                ans.push((j, 0));\n            }\n            ans.push((x, 1));\n            ans.push((x + 1, 1));\n            for j in (1..x + 2).rev() {\n                ans.push((j, 0));\n            }\n            continue;\n        }\n        let mut c = vec![];\n        for j in 0..n {\n            if (i & 1 << j) != 0 {\n                c.push(j);\n            }\n        }\n        let &ma = c.last().unwrap();\n        for j in 0..ma + 1 {\n            if j != ma && (i & 1 << j) != 0 {\n                let j = j as i64;\n                ans.push((j, 0));\n                ans.push((j, 1));\n                ans.push((j + 1, 1));\n            } else {\n                ans.push((j as i64, 0));\n            }\n        }\n        for j in (0..ma + 1).rev() {\n            let x = j as i64;\n            if (i & 1 << j) != 0 {\n                ans.push((x + 1, 0));\n                ans.push((x + 1, 1));\n                ans.push((x, 1));\n            } else {\n                ans.push((x + 1, 0));\n            }\n        }\n        for j in 0..ma {\n            ans.push((j as i64, 0));\n        }\n        let max = ma as i64;\n        ans.push((max, 0));\n        ans.push((max, 1));\n        ans.push((max + 1, 1));\n        for j in 0..ma + 1 {\n            ans.push((j as i64 + 1, 0));\n        }\n    }\n    ans.push((0, 0));\n    puts!(\"Possible\\n\");\n    puts!(\"{}\\n\", ans.len());\n    for (x, y) in ans {\n        puts!(\"{} {}\\n\", x, y);\n    }\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  }
]