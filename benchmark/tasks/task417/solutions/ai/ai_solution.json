[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct {\n    int u, v;\n} Edge;\n\nint *parent, *rank;\n\nint find(int u) {\n    if (parent[u] != u)\n        parent[u] = find(parent[u]);\n    return parent[u];\n}\n\nvoid union_sets(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u == v) return;\n    if (rank[u] < rank[v]) {\n        parent[u] = v;\n    } else {\n        parent[v] = u;\n        if (rank[u] == rank[v])\n            rank[u]++;\n    }\n}\n\ndouble calculate_probability(int n, Edge *edges, int m, double p) {\n    double total = 0.0;\n    int total_subsets = 1 << m;\n\n    for (int mask = 0; mask < total_subsets; mask++) {\n        parent = (int *)malloc(n * sizeof(int));\n        rank = (int *)malloc(n * sizeof(int));\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n\n        double prob = 1.0;\n        int k = 0;\n\n        for (int i = 0; i < m; i++) {\n            if (mask & (1 << i)) {\n                union_sets(edges[i].u, edges[i].v);\n                prob *= (1 - p);\n            } else {\n                prob *= p;\n            }\n        }\n\n        int root = find(0);\n        int connected = 1;\n        for (int i = 1; i < n; i++) {\n            if (find(i) != root) {\n                connected = 0;\n                break;\n            }\n        }\n\n        if (connected) {\n            total += prob;\n        }\n\n        free(parent);\n        free(rank);\n    }\n\n    return total;\n}\n\nint main() {\n    int n, m;\n    double p;\n    scanf(\"%d %d %lf\", &n, &m, &p);\n\n    Edge *edges = (Edge *)malloc(m * sizeof(Edge));\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d\", &edges[i].u, &edges[i].v);\n    }\n\n    double prob = calculate_probability(n, edges, m, p);\n    printf(\"%.9lf\\n\", prob);\n\n    free(edges);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:27:41"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nvector<int> parent;\n\nint find(int u) {\n    if (parent[u] != u) {\n        parent[u] = find(parent[u]);\n    }\n    return parent[u];\n}\n\nvoid unite(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u != v) {\n        parent[v] = u;\n    }\n}\n\ndouble calculateProbability(int n, vector<pair<int, int>>& edges, double p) {\n    parent.resize(n);\n    for (int i = 0; i < n; ++i) {\n        parent[i] = i;\n    }\n\n    for (auto& edge : edges) {\n        int u = edge.first;\n        int v = edge.second;\n        if (find(u) != find(v)) {\n            unite(u, v);\n        }\n    }\n\n    int components = 0;\n    for (int i = 0; i < n; ++i) {\n        if (find(i) == i) {\n            components++;\n        }\n    }\n\n    if (components != 1) {\n        return 0.0;\n    }\n\n    int m = edges.size();\n    return pow(p, m);\n}\n\nint main() {\n    int n, m;\n    double p;\n    cin >> n >> m >> p;\n\n    vector<pair<int, int>> edges(m);\n    for (int i = 0; i < m; ++i) {\n        cin >> edges[i].first >> edges[i].second;\n    }\n\n    double prob = calculateProbability(n, edges, p);\n    cout << prob << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:27:56"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class GraphConnectivityProbability {\n    private int[] parent;\n    private int[] rank;\n\n    public double calculateProbability(int n, int[][] edges, double p) {\n        parent = new int[n];\n        rank = new int[n];\n        double totalProbability = 0.0;\n\n        for (int mask = 0; mask < (1 << edges.length); mask++) {\n            double prob = 1.0;\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n                rank[i] = 0;\n            }\n\n            int edgeCount = 0;\n            for (int i = 0; i < edges.length; i++) {\n                int u = edges[i][0];\n                int v = edges[i][1];\n                if ((mask & (1 << i)) != 0) {\n                    prob *= (1 - p);\n                    union(u, v);\n                } else {\n                    prob *= p;\n                    edgeCount++;\n                }\n            }\n\n            int root = find(0);\n            boolean isConnected = true;\n            for (int i = 1; i < n; i++) {\n                if (find(i) != root) {\n                    isConnected = false;\n                    break;\n                }\n            }\n\n            if (isConnected) {\n                totalProbability += prob;\n            }\n        }\n\n        return totalProbability;\n    }\n\n    private int find(int u) {\n        if (parent[u] != u) {\n            parent[u] = find(parent[u]);\n        }\n        return parent[u];\n    }\n\n    private void union(int u, int v) {\n        int rootU = find(u);\n        int rootV = find(v);\n        if (rootU != rootV) {\n            if (rank[rootU] > rank[rootV]) {\n                parent[rootV] = rootU;\n            } else if (rank[rootU] < rank[rootV]) {\n                parent[rootU] = rootV;\n            } else {\n                parent[rootV] = rootU;\n                rank[rootU]++;\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:28:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class GraphConnectivityProbability {\n    private int n;\n    private List<List<Integer>> graph;\n    private double[] edgeProb;\n\n    public GraphConnectivityProbability(int n) {\n        this.n = n;\n        this.graph = new ArrayList<>(n);\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        this.edgeProb = new double[n * (n - 1) / 2];\n    }\n\n    public void addEdge(int u, int v, double prob) {\n        graph.get(u).add(v);\n        graph.get(v).add(u);\n        int edgeIndex = getEdgeIndex(u, v);\n        edgeProb[edgeIndex] = prob;\n    }\n\n    private int getEdgeIndex(int u, int v) {\n        return u < v ? u * (2 * n - u - 1) / 2 + v - u - 1 : v * (2 * n - v - 1) / 2 + u - v - 1;\n    }\n\n    public double calculateConnectivityProbability() {\n        double totalProb = 0.0;\n        int totalEdges = n * (n - 1) / 2;\n\n        for (int removedEdge = 0; removedEdge < totalEdges; removedEdge++) {\n            double currProb = 1.0;\n            for (int i = 0; i < totalEdges; i++) {\n                if (i == removedEdge) {\n                    currProb *= (1 - edgeProb[i]);\n                } else {\n                    currProb *= edgeProb[i];\n                }\n            }\n\n            if (isConnectedAfterRemoval(removedEdge)) {\n                totalProb += currProb;\n            }\n        }\n\n        return totalProb;\n    }\n\n    private boolean isConnectedAfterRemoval(int removedEdge) {\n        boolean[] visited = new boolean[n];\n        int[] u_v = findEdgeVertices(removedEdge);\n        int u = u_v[0], v = u_v[1];\n\n        dfs(0, visited, u, v);\n\n        for (boolean visit : visited) {\n            if (!visit) return false;\n        }\n        return true;\n    }\n\n    private void dfs(int node, boolean[] visited, int u, int v) {\n        visited[node] = true;\n        for (int neighbor : graph.get(node)) {\n            if (!visited[neighbor] && !((node == u && neighbor == v) || (node == v && neighbor == u))) {\n                dfs(neighbor, visited, u, v);\n            }\n        }\n    }\n\n    private int[] findEdgeVertices(int edgeIndex) {\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (getEdgeIndex(i, j) == edgeIndex) {\n                    return new int[]{i, j};\n                }\n            }\n        }\n        return new int[]{-1, -1};\n    }\n\n    public static void main(String[] args) {\n        GraphConnectivityProbability graph = new GraphConnectivityProbability(4);\n        graph.addEdge(0, 1, 0.5);\n        graph.addEdge(0, 2, 0.7);\n        graph.addEdge(0, 3, 0.6);\n        graph.addEdge(1, 2, 0.8);\n        graph.addEdge(1, 3, 0.4);\n        graph.addEdge(2, 3, 0.9);\n\n        double connectedProb = graph.calculateConnectivityProbability();\n        System.out.println(\"Probability of remaining connected: \" + connectedProb);\n    }\n}",
    "timestamp": "2025-08-05 21:28:28"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_NODES 1000\n\ntypedef struct {\n    int parent;\n    int rank;\n} DisjointSet;\n\nvoid initDisjointSet(DisjointSet* ds, int n) {\n    for (int i = 0; i < n; i++) {\n        ds[i].parent = i;\n        ds[i].rank = 0;\n    }\n}\n\nint findSet(DisjointSet* ds, int x) {\n    if (ds[x].parent != x)\n        ds[x].parent = findSet(ds, ds[x].parent);\n    return ds[x].parent;\n}\n\nvoid unionSets(DisjointSet* ds, int x, int y) {\n    int rootX = findSet(ds, x);\n    int rootY = findSet(ds, y);\n\n    if (rootX == rootY)\n        return;\n\n    if (ds[rootX].rank < ds[rootY].rank)\n        ds[rootX].parent = rootY;\n    else if (ds[rootX].rank > ds[rootY].rank)\n        ds[rootY].parent = rootX;\n    else {\n        ds[rootY].parent = rootX;\n        ds[rootX].rank++;\n    }\n}\n\ndouble calculateConnectivityProbability(int n, int** edges, int edgeCount, double p) {\n    double totalProbability = 0.0;\n    int combinations = 1 << edgeCount;\n\n    for (int mask = 0; mask < combinations; mask++) {\n        DisjointSet ds[MAX_NODES];\n        initDisjointSet(ds, n);\n        double probability = 1.0;\n\n        for (int i = 0; i < edgeCount; i++) {\n            bool include = (mask & (1 << i)) != 0;\n            \n            if (include) {\n                probability *= p;\n                unionSets(ds, edges[i][0], edges[i][1]);\n            } else {\n                probability *= (1 - p);\n            }\n        }\n\n        int connectedComponents = 0;\n        for (int i = 0; i < n; i++) {\n            if (findSet(ds, i) == i)\n                connectedComponents++;\n        }\n\n        if (connectedComponents == 1)\n            totalProbability += probability;\n    }\n\n    return totalProbability;\n}\n\nint main() {\n    int n, m;\n    double p;\n    scanf(\"%d %d %lf\", &n, &m, &p);\n\n    int** edges = malloc(m * sizeof(int*));\n    for (int i = 0; i < m; i++) {\n        edges[i] = malloc(2 * sizeof(int));\n        scanf(\"%d %d\", &edges[i][0], &edges[i][1]);\n    }\n\n    double result = calculateConnectivityProbability(n, edges, m, p);\n    printf(\"%.6lf\\n\", result);\n\n    for (int i = 0; i < m; i++)\n        free(edges[i]);\n    free(edges);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:28:38"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass DisjointSet {\nprivate:\n    vector<int> parent, rank;\n\npublic:\n    DisjointSet(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        for (int i = 0; i < n; i++) \n            parent[i] = i;\n    }\n\n    int find(int x) {\n        if (parent[x] != x) \n            parent[x] = find(parent[x]);\n        return parent[x];\n    }\n\n    void unite(int x, int y) {\n        int px = find(x), py = find(y);\n        if (px == py) return;\n        \n        if (rank[px] < rank[py])\n            swap(px, py);\n        \n        parent[py] = px;\n        if (rank[px] == rank[py])\n            rank[px]++;\n    }\n};\n\ndouble calculateConnectivityProbability(int n, vector<pair<int, int>>& edges, double p) {\n    int m = edges.size();\n    double totalProb = 0;\n\n    for (int mask = 0; mask < (1 << m); mask++) {\n        DisjointSet ds(n);\n        double probability = 1.0;\n\n        for (int i = 0; i < m; i++) {\n            if (!(mask & (1 << i))) {\n                ds.unite(edges[i].first, edges[i].second);\n                probability *= (1 - p);\n            } else {\n                probability *= p;\n            }\n        }\n\n        bool connected = true;\n        int root = ds.find(0);\n        for (int i = 1; i < n; i++) {\n            if (ds.find(i) != root) {\n                connected = false;\n                break;\n            }\n        }\n\n        if (connected) {\n            totalProb += probability;\n        }\n    }\n\n    return totalProb;\n}\n\nint main() {\n    int n, m;\n    double p;\n    cin >> n >> m >> p;\n\n    vector<pair<int, int>> edges(m);\n    for (int i = 0; i < m; i++) {\n        cin >> edges[i].first >> edges[i].second;\n        edges[i].first--;\n        edges[i].second--;\n    }\n\n    double result = calculateConnectivityProbability(n, edges, p);\n    cout << fixed << setprecision(6) << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:28:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import networkx as nx\nfrom itertools import combinations\n\ndef is_connected_remained_graph(num_nodes, edge_prob_disappear, num_samples):\n    total_connected = 0\n\n    for _ in range(num_samples):\n        # Create a complete graph\n        graph = nx.complete_graph(num_nodes)\n        \n        # Consider all edges in the complete graph\n        edges = list(graph.edges)\n\n        # Remove each edge with given probability\n        edges_remained = [(u, v) for (u, v) in edges if random.random() > edge_prob_disappear]\n\n        # Create the remained graph\n        remained_graph = nx.Graph()\n        remained_graph.add_edges_from(edges_remained)\n\n        # Check if the remained graph is connected\n        if nx.is_connected(remained_graph):\n            total_connected += 1\n\n    # Calculate and return the probability\n    return total_connected / num_samples\n\n# Example usage:\nnum_nodes = 5\nedge_prob_disappear = 0.1\nnum_samples = 1000\nprobability_connected = is_connected_remained_graph(num_nodes, edge_prob_disappear, num_samples)\nprint(probability_connected)",
    "timestamp": "2025-08-13 06:35:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class GraphConnectedProbability {\n    \n    public static void main(String[] args) {\n        int n = 5; // Number of vertices\n        double p = 0.5; // Probability of each edge disappearing\n        \n        double connectedProbability = calculateConnectedProbability(n, p);\n        System.out.println(\"Probability the graph remains connected: \" + connectedProbability);\n    }\n    \n    public static double calculateConnectedProbability(int n, double p) {\n        if (n <= 1) return 1.0;\n\n        int totalPossibleEdges = (n * (n - 1)) / 2;\n        int[] degreeSequence = new int[n];\n        return probabilityDFS(totalPossibleEdges, degreeSequence, 0, n, p);\n    }\n    \n    private static double probabilityDFS(int totalEdges, int[] degreeSequence, int idx, int n, double p) {\n        if (idx == n) {\n            if (isValidDegreeSequence(degreeSequence, totalEdges)) {\n                return Math.pow(p, totalEdges) * Math.pow(1 - p, calculateEdgesFromDegreeSequence(degreeSequence));\n            }\n            return 0.0;\n        }\n\n        double probability = 0.0;\n        for (int d = 0; d <= totalEdges && d <= n - 1; d++) {\n            degreeSequence[idx] = d;\n            probability += probabilityDFS(totalEdges - d, degreeSequence, idx + 1, n, p);\n        }\n        \n        return probability;\n    }\n\n    private static boolean isValidDegreeSequence(int[] degreeSequence, int totalEdges) {\n        int sum = 0;\n        for (int d : degreeSequence) {\n            sum += d;\n        }\n        return sum == 2 * totalEdges;\n    }\n\n    private static int calculateEdgesFromDegreeSequence(int[] degreeSequence) {\n        int edgeCount = 0;\n        for (int d : degreeSequence) {\n            edgeCount += d;\n        }\n        return edgeCount / 2;\n    }\n}",
    "timestamp": "2025-08-13 06:35:34"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n\n#define MAX_NODES 100\n\ntypedef struct {\n    int u;\n    int v;\n} Edge;\n\nvoid dfs(int node, bool *visited, bool **adj_matrix, int n) {\n    visited[node] = true;\n    for (int i = 0; i < n; i++) {\n        if (adj_matrix[node][i] && !visited[i]) {\n            dfs(i, visited, adj_matrix, n);\n        }\n    }\n}\n\nbool is_connected(bool **adj_matrix, int n) {\n    bool visited[MAX_NODES] = {false};\n    dfs(0, visited, adj_matrix, n);\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\ndouble calculate_probability(int n, int m, Edge *edges, double p) {\n    int total_states = 1 << m;\n    int connected_states = 0;\n\n    for (int state = 0; state < total_states; state++) {\n        bool **adj_matrix = (bool **)malloc(n * sizeof(bool *));\n        for (int i = 0; i < n; i++) {\n            adj_matrix[i] = (bool *)malloc(n * sizeof(bool));\n            for (int j = 0; j < n; j++) {\n                adj_matrix[i][j] = false;\n            }\n        }\n\n        for (int i = 0; i < m; i++) {\n            if (state & (1 << i)) {\n                int u = edges[i].u;\n                int v = edges[i].v;\n                adj_matrix[u][v] = true;\n                adj_matrix[v][u] = true;\n            }\n        }\n\n        if (is_connected(adj_matrix, n)) {\n            connected_states++;\n        }\n\n        for (int i = 0; i < n; i++) {\n            free(adj_matrix[i]);\n        }\n        free(adj_matrix);\n    }\n\n    return connected_states / pow(2, m);\n}\n\nint main() {\n    int n = 5;\n    int m = 6;\n    Edge edges[] = {{0, 1}, {0, 2}, {1, 2}, {1, 3}, {2, 4}, {3, 4}};\n    double p = 0.5;\n\n    double probability = calculate_probability(n, m, edges, p);\n    printf(\"Probability of connectivity: %.6f\\n\", probability);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 06:35:38"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import networkx as nx\nimport numpy as np\nfrom itertools import combinations\n\ndef connectivity_probability(G):\n    n = G.number_of_nodes()\n    m = G.number_of_edges()\n    probabilities = []\n\n    for edge in list(G.edges()):\n        H = G.copy()\n        H.remove_edge(*edge)\n        \n        connectivity_count = 0\n        num_simulations = 10000\n        \n        for _ in range(num_simulations):\n            surviving_edges = [e for e in H.edges() if np.random.random() > 0.5]\n            temp_graph = nx.Graph()\n            temp_graph.add_nodes_from(H.nodes())\n            temp_graph.add_edges_from(surviving_edges)\n            \n            if nx.is_connected(temp_graph):\n                connectivity_count += 1\n        \n        prob = connectivity_count / num_simulations\n        probabilities.append((edge, prob))\n    \n    return probabilities\n\n# Example usage\nG = nx.erdos_renyi_graph(10, 0.5)\nresults = connectivity_probability(G)\nfor edge, prob in results:\n    print(f\"Edge {edge}: Connectivity Probability = {prob}\")",
    "timestamp": "2025-08-13 06:35:47"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom itertools import combinations\n\ndef solve():\n    sys.setrecursionlimit(1 << 25)\n    N, M, P = map(int, sys.stdin.readline().split())\n    edges = []\n    for _ in range(M):\n        a, b = map(int, sys.stdin.readline().split())\n        edges.append((a-1, b-1))  # converting to 0-based\n    \n    total = 0\n    # Iterate all possible subsets of edges that form a spanning tree\n    parent = list(range(N))\n    def find(u):\n        while parent[u] != u:\n            parent[u] = parent[parent[u]]\n            u = parent[u]\n        return u\n    def union(u, v):\n        u_root = find(u)\n        v_root = find(v)\n        if u_root == v_root:\n            return False\n        parent[v_root] = u_root\n        return True\n    \n    # We need to find all possible subsets S of edges such that the graph (V, S) is connected\n    # Then for each such S, the probability is (P/100)^(M - |S|) * (1 - P/100)^|S|\n    # Sum this over all S\n    \n    # But enumerating all possible S is infeasible for large M, so we need a better approach\n    # This problem is known to be #P-Hard, so for exact solution, we need to use inclusion-exclusion or matrix tree theorem with probabilities\n    \n    # Here's a dynamic programming approach for small N (N <= 20)\n    if N > 20:\n        print(\"This approach is not feasible for large N\")\n        return\n    \n    # dp[mask][S] = sum over all subsets of edges S that connect the components in mask, the product (1 - p)^|S| * p^(edges not in S)\n    # But this is still O(4^N * M), which is feasible for N=16\n    \n    # Using the inclusion-exclusion approach:\n    # The probability is equal to sum_{S spanning all vertices} (-1)^{|S|} * (P/100)^{crossing edges between S and V-S}\n    # But implementing this is non-trivial\n    \n    # Alternative: Kirchhoff's matrix tree theorem with probabilities\n    # The probability is equal to the determinant of the Laplacian matrix (with adjusted probabilities) divided by something\n    \n    # Given the complexity, here's a Monte Carlo simulation approach for estimation\n    # Not exact, but practical for large N\n    \n    # Since exact solution is non-trivial, here's a brute-force for very small N and M\n    if M > 20:\n        print(\"Brute-force is not feasible for large M\")\n        return\n    \n    total_prob = 0.0\n    p = P / 100.0\n    for survive in range(0, 1 << M):\n        # Check if the survived edges form a connected graph\n        parent = list(range(N))\n        def find(u):\n            while parent[u] != u:\n                parent[u] = parent[parent[u]]\n                u = parent[u]\n            return u\n        \n        edge_count = 0\n        for i in range(M):\n            if survive & (1 << i):\n                a, b = edges[i]\n                if find(a) != find(b):\n                    parent[find(a)] = find(b)\n                    edge_count += 1\n        \n        # Check if all nodes are connected\n        root = find(0)\n        connected = True\n        for u in range(1, N):\n            if find(u) != root:\n                connected = False\n                break\n        \n        if connected:\n            prob = (1.0 - p) ** bin(survive).count('1') * p ** (M - bin(survive).count('1'))\n            total_prob += prob\n    \n    print(\"{0:.10f}\".format(total_prob))\n\nsolve()",
    "timestamp": "2025-08-13 06:36:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <random>\n\nusing namespace std;\n\nconst int MAX_NODES = 100;\n\nclass UnionFind {\npublic:\n    UnionFind(int n) : parent(n), rank(n, 0) {\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i;\n        }\n    }\n  \n    int find(int u) {\n        if (parent[u] != u) {\n            parent[u] = find(parent[u]);\n        }\n        return parent[u];\n    }\n  \n    void unite(int u, int v) {\n        int pu = find(u);\n        int pv = find(v);\n        if (pu != pv) {\n            if (rank[pu] < rank[pv]) {\n                parent[pu] = pv;\n            } else if (rank[pu] > rank[pv]) {\n                parent[pv] = pu;\n            } else {\n                parent[pv] = pu;\n                ++rank[pu];\n            }\n        }\n    }\n  \nprivate:\n    vector<int> parent, rank;\n};\n\nbool isConnected(const vector<pair<int, int>>& edges, int n) {\n    UnionFind uf(n);\n    for (const auto& edge : edges) {\n        uf.unite(edge.first, edge.second);\n    }\n\n    int representative = uf.find(0);\n    for (int i = 1; i < n; ++i) {\n        if (uf.find(i) != representative) {\n            return false;\n        }\n    }\n    return true;\n}\n\ndouble estimateConnectedProbability(const vector<pair<int, int>>& edges, int n, double p, int trials) {\n    int connectedCount = 0;\n    random_device rd;\n    mt19937 gen(rd());\n    bernoulli_distribution dist(p);\n\n    for (int i = 0; i < trials; ++i) {\n        vector<pair<int, int>> remainingEdges;\n        for (const auto& edge : edges) {\n            if (dist(gen)) {\n                remainingEdges.push_back(edge);\n            }\n        }\n        if (isConnected(remainingEdges, n)) {\n            ++connectedCount;\n        }\n    }\n    return connectedCount / static_cast<double>(trials);\n}\n\nint main() {\n    int n, m;\n    double p;\n    int trials = 10000;\n\n    cin >> n >> m >> p;\n    vector<pair<int, int>> edges(m);\n    for (int i = 0; i < m; ++i) {\n        cin >> edges[i].first >> edges[i].second;\n    }\n\n    double probability = estimateConnectedProbability(edges, n, p, trials);\n\n    cout << probability << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:32:56"
  }
]