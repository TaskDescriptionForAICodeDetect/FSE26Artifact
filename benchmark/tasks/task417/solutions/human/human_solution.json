[
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\n\tint n, m;\n\tdouble p;\n\tcin >> n >> m >> p;\n\tp /= 100;\n\n\tvector<vector<int>> G(n);\n\tfor(int i = 0; i < m; ++i) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\t--u; --v;\n\t\tG[u].emplace_back(v);\n\t\tG[v].emplace_back(u);\n\t}\n\n\tvector<double> dp(1 << n, 0.0);\n\n\tfor(int bit = 0; bit < 1 << (n - 1); ++bit) {\n\t\tconst int V = (bit << 1) | 1;\n\n\t\tdouble sum = 0.0;\n\t\tfor(int S = V; S > 0; S = (S - 1) & V) {\n\t\t\tif(!(S & 1)) continue;\n\n\t\t\tconst int T = V ^ S;\n\t\t\tdouble q = 1.0;\n\t\t\tfor(int v = 0; v < n; ++v) {\n\t\t\t\tif(!(S >> v & 1)) continue;\n\n\t\t\t\tfor(const auto &u : G[v]) {\n\t\t\t\t\tif(!(T >> u & 1)) continue;\n\t\t\t\t\tq *= p;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum += dp[S] * q;\n\t\t}\n\t\tdp[V] = 1.0 - sum;\n\t}\n\n\tcout << dp[(1 << n) - 1] << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\nconst int MAXN = 14;\nconst int MAXS = 1 << MAXN;\n\nint n, m;\nbool adj[MAXN][MAXN];\ndouble p, f[MAXS];\n\nint lowbit(int x) {\n\n    return x & -x;\n}\n\nint main() {\n\n    freopen(\"in\", \"r\", stdin);\n    scanf(\"%d %d %lf\", &n, &m, &p);\n    p /= 100;\n    int u, v;\n    for (int i = 0; i < m; i++)\n    {\n        scanf(\"%d %d\", &u, &v);\n        u--, v--;\n        adj[u][v] = adj[v][u] = true;\n    }\n\n    int range = 1 << n;\n    for (int i = 0; i < range; i++)\n    {\n        if (!(i & (i - 1))) f[i] = 0;\n        else\n        {\n            f[i] = 0;\n            int t = i, cnt = 0;\n            while (t) ++cnt, t -= lowbit(t);\n            for (int j = 0; j < n; j++)\n                if ((i >> j) & 1) { u = j; break; }\n            int range_j = 1 << (cnt - 1);\n            for (int j = 0; j < range_j - 1; j++)\n            {\n                t = i - lowbit(i);\n                int subset = 0, lb;\n                double val = 1;\n                for (int k = 0; k < cnt - 1; k++)\n                {\n                    lb = lowbit(t);\n                    if ((j >> k) & 1) subset |= lb;\n                    t -= lb;\n                }\n                subset |= 1 << u;\n                int not_subset = i ^ subset;\n                for (int x = 0; x < n; x++)\n                    if ((subset >> x) & 1)\n                        for (int v = 0; v < n; v++)\n                            if (((not_subset >> v) & 1) && adj[x][v]) val *=p;\n                val *= 1 - f[subset];\n                f[i] += val;\n            }\n          //  f[i] /= range_j;\n        }\n    }\n/*\n    for (int i = 0; i < range; i++)\n    {\n        printf(\"f[%d] = %lf\\n\", i, f[i]);\n    }\n    */\n    printf(\"%.10f\\n\", 1 - f[range - 1]);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n#include <bitset>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n\n/**\n * hash???????????????UnionFind ????´???°???16????????????????????¨??????????????????\n */\ntemplate<int N>\nstruct SUnionFind {\n    int i2g[N];\n    SUnionFind() {\n        for (int i = 0; i < N; i++) {\n            i2g[i] = i;\n        }\n    }\n    SUnionFind(ull hs) {\n        for (int i = 0; i < N; i++) {\n            i2g[i] = hs & 0xf;\n            hs >>= 4;\n        }\n    }\n\n    void merge(int x, int y) {\n        int xg = i2g[x], yg = i2g[y];\n        for (int i = 0; i < N; i++) {\n            if (i2g[i] == yg) i2g[i] = xg;\n        }\n    }\n\n    bool same(int x, int y) {\n        return i2g[x] == i2g[y];\n    }\n\n    ull hash() {\n        int b[N];\n        memset(b, -1, sizeof(b));\n        int c = 0;\n        ull hs = 0;\n        for (int i = N-1; i >= 0; i--) {\n            hs <<= 4;\n            if (b[i2g[i]] == -1) {\n                b[i2g[i]] = c;\n                c++;\n            }\n            hs += b[i2g[i]];\n        }\n        return hs;\n    }\n};\n\ntypedef SUnionFind<14> UF;\ntypedef pair<ull, double> P;\nint main() {\n    int n, m, pp;\n    cin >> n >> m >> pp;\n    double p = pp / 100.0;\n\n    int g[14]= {};\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b; a--; b--;\n        if (a > b) swap(a, b);\n        g[a] |= (1<<b);\n    }\n\n    vector<P> mp;\n    mp.push_back(P(UF().hash(), 1.0));\n    for (int i = 0; i < n-1; i++) {\n        for (int j = i+1; j < n; j++) {\n            if (!(g[i] & (1<<j))) continue;\n//            cout << i << \" \" << j << \" \" << mp.size() << endl;\n            vector<P> mp2;\n            for (auto pa : mp) {\n                ull d; double r;\n                tie(d, r) = pa;\n                UF uf(d);\n                uf.merge(i, j);\n                mp2.push_back(P(d, r*p));\n                mp2.push_back(P(uf.hash(), r*(1-p)));\n            }\n            mp = mp2;\n            sort(mp.begin(), mp.end());\n            int l = 0;\n            for (int k = 1; k < (int)mp.size(); k++) {\n                if (mp[l].first != mp[k].first) {\n                    l++;\n                    mp[l] = mp[k];\n                } else {\n                    mp[l].second += mp[k].second;\n                }\n            }\n            l++;\n            mp.erase(mp.begin()+l, mp.end());\n        }\n\n        vector<P> mp2;\n        for (auto p : mp) {\n            UF uf(p.first);\n            bool f = false;\n            for (int j = i+1; j < n; j++) {\n                if (uf.same(i, j)) {\n                    f = true;\n                    break;\n                }\n            }\n            if (!f) continue;\n\n            UF uf2;\n            for (int j = i+1; j < n; j++) {\n                for (int k = j+1; k < n; k++) {\n                    if (uf.same(j, k)) uf2.merge(j, k);\n                }\n            }\n            mp2.push_back(P(uf2.hash(), p.second));\n        }\n        mp = mp2;\n        sort(mp.begin(), mp.end());\n        int l = 0;\n        for (int k = 1; k < (int)mp.size(); k++) {\n            if (mp[l].first != mp[k].first) {\n                l++;\n                mp[l] = mp[k];\n            } else {\n                mp[l].second += mp[k].second;\n            }\n        }\n        l++;\n        mp.erase(mp.begin()+l, mp.end());\n    }\n    double res = 0;\n    for (auto p : mp) {\n        res += p.second;\n    }\n    printf(\"%.20lf\\n\", res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n#include <cassert>\n#include <cstdio>\n#include <iostream>\n#include <unordered_map>\n\nusing namespace std;\ntypedef long long ll;\n\n\nint nlz(int x) {\n    if (x == 0) return 32;\n    return __builtin_clz(x);\n}\nstruct RadixHeap {\n    typedef pair<int, int> P;\n    vector<P> v[32];\n    bool f;\n    int mi, sz;\n    RadixHeap() {\n        mi = sz = 0;\n        f = false;\n    }\n    void first(int x, int p) {\n        sz = 1;\n        mi = x;\n        v[0].push_back(P(x, p));\n    }\n    void push(int x, int p) {\n        if (!f) {\n            f = true;\n            first(x, p);\n            return;\n        }\n        assert(mi <= x);\n        sz++;\n        v[32-nlz(x^mi)].push_back(P(x, p));\n    }\n    void push(P p) {\n        push(p.first, p.second);\n    }\n    void renew() {\n        assert(!v[0].size());\n        int i = 1;\n        while (!v[i].size()) i++;\n        mi = v[i][0].first;\n        for (P &d: v[i]) {\n            mi = min(mi, d.first);\n        }\n        for (P &p: v[i]) {\n            v[32-nlz(mi^p.first)].push_back(p);\n        }\n        v[i].clear();\n    }\n    P top() {\n        if (!v[0].size()) {\n            renew();\n        }\n        assert(v[0].size());\n        return v[0].back();\n    }\n    P pop() {\n        sz--;\n        if (!v[0].size()) {\n            renew();\n        }\n        P r = v[0].back();\n        v[0].pop_back();\n        return r;\n    }\n    int size() {\n        return sz;\n    }\n    bool empty() {\n        return sz == 0;\n    }\n    void clear() {\n        mi = sz = 0;\n        for (int i = 0; i < 32; i++) {\n            v[i].clear();\n        }\n    }\n};\n\nconst int INF = 1<<27;\ntemplate<int V>\nstruct MinCostFlowOptimize {\n    typedef int T;\n    typedef pair<T, int> P;\n//    using T = int;\n//    using P = pair<T, int>;\n    struct Edge {\n        int to, rev;\n        int cap;\n        T cost;\n    };\n    vector<Edge> g[V];\n    void init() {\n        for (int i = 0; i < V; i++) {\n            g[i].clear();\n        }\n    }\n    void add(int from, int to, int cap, T cost) {\n        g[from].push_back(Edge{to, (int)g[to].size(), cap, cost});\n        g[to].push_back(Edge{from, (int)g[from].size()-1, 0, (T)(-cost)});\n    }\n\n    T h[V], dist[V];\n    bool used[V];\n    Edge *prev[V];\n    T exec(int s, int t, int &f) {\n        T res = 0;\n        fill_n(h, V, 0);\n        while (f > 0) {\n            fill_n(dist, V, INF);\n            fill_n(used, V, false);\n            dist[s] = 0;\n            RadixHeap que;\n//            priority_queue<P, vector<P>, greater<P>> que;\n            que.push(P(0, s));\n            while (!que.empty()) {\n                P p = que.top(); que.pop();\n                int v = p.second;\n                if (v == t) break;\n                if (used[v]) continue;\n                used[v] = true;\n                int hv = h[v], distv = dist[v];                \n                for (Edge &e: g[v]) {\n                    if (!e.cap) continue;\n                    T ee = e.cost-hv+h[e.to];\n                    if (dist[e.to] > distv+ee) {\n                        dist[e.to] = distv+ee;\n                        prev[e.to] = &e;\n                        que.push(P(dist[e.to], e.to));\n                    }\n                }\n            }\n            if (dist[t] == INF) {\n                return res;\n            }\n            for (int v = 0; v < V; v++) {\n                if (dist[v] >= dist[t]) continue;\n                h[v] += dist[t]-dist[v];\n            }\n            T d = f;\n            for (int v = t; v != s; v = g[v][prev[v]->rev].to) {\n                d = min(d, prev[v]->cap);\n            }\n            f -= d;\n            res += d * (h[s]-h[t]);\n            for (int v = t; v != s; v = g[v][prev[v]->rev].to) {\n                prev[v]->cap -= d;\n                g[v][prev[v]->rev].cap += d;\n            }\n        }\n        return res;\n    }\n};\n\nconst int MN = 110;\nconst int MM = 6;\nint n, m, b, k;\nint ax[MN], ay[MN];\nint bx[MM], by[MM], c[MM], f[MM];\n\nMinCostFlowOptimize<130> mf;\n\nint calc(int md) {\n//    printf(\"startcalc:%d\\n\", md);\n    mf.init();\n    /**\n     * 0..MN p\n     * MN..MN+MM k\n     * 120:s 121:t\n     */\n    int sv = 120, tv = 121;\n    for (int i = 0; i < n; i++) {\n        mf.add(sv, i, 1, 0);\n    }\n    for (int i = 0; i < m; i++) {\n        if (!(k & (1<<i))) continue;\n        mf.add(MN+i, tv, c[i], 0);\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!(k & (1<<j))) continue;\n            mf.add(i, MN+j, 1, max(0, abs(ax[i]-bx[j])+abs(ay[i]-by[j])-md));\n        }\n    }\n    int u = n;\n    int res = mf.exec(sv, tv, u);\n    return __builtin_popcount(k)*b*md+res;\n}\n\nint solve() {\n//    printf(\"solve n:%d\\n\", n);\n    /**\n     * 0..MN human\n     * MN..MN+MM pos\n     * s:120 t:121 S:122 T:123\n     */\n\n    int res = 2*1e9;\n//    for (k = 0; k < (1<<m); k++) {\n    for (k = 1; k < (1<<m); k++) {\n        int fr = 0;\n        int cc = 0;\n        for (int i = 0; i < m; i++) {\n            if (!(k & (1<<i))) continue;\n            fr += f[i];\n            cc += c[i];\n        }\n        if (cc < n) continue;\n        int l = 0, r = 10000;        \n        while (r - l > 2) {\n            int mdl = (l+l+r)/3, mdr = (l+r+r)/3;\n            int dl = calc(mdl), dr = calc(mdr);\n//            printf(\"l:%d dl:%d r:%d dr:%d\\n\", mdl, dl, mdr, dr);\n            if (dl > dr) {\n                l = mdl;\n            } else {\n                r = mdr;\n            }\n        }\n        res = min(res, fr+min(calc(l), calc(r-1)));\n    }\n    return res;\n}\n\nint main() {\n    while (true) {\n        cin >> n >> m >> b;\n        if (!n && !m && !b) break;\n        for (int i = 0; i < n; i++) {\n            cin >> ax[i] >> ay[i];\n        }\n        for (int i = 0; i < m; i++) {\n            cin >> bx[i] >> by[i] >> c[i] >> f[i];\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint N,M;\ndouble P;\nint u[111],v[111];\ndouble dp[1<<14];\n\nstruct timer{\n\ttime_t start;\n\ttimer(){\n\t\tstart=clock();\n\t}\n\t~timer(){\n\t\tcout<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;\n\t}\n};\n\nint main(){\n\t//timer TIMER;\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>N>>M>>P;\n\tP/=100;\n\trep(i,M)cin>>u[i]>>v[i],u[i]--,v[i]--;\n\t\n\trep2(mask,1,1<<N){\n\t\t\n\t\tif(__builtin_popcount(mask)==1){\n\t\t\tdp[mask]=1;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tdp[mask]=1;\n\t\tint par=N-1;\n\t\twhile(!(mask>>par&1))par--;\n\t\tint sub=mask,e;\n\t\t\n\t\twhile(1){\n\t\t\tsub=(sub-1)&mask;\n\t\t\te=0;\n\t\t\trep(i,M){\n\t\t\t\tif((mask>>v[i]&1) && (mask>>u[i]&1) && (sub>>u[i]&1)^(sub>>v[i]&1))e++;\n\t\t\t}\n\t\t\t//cout<<mask<<\" - \"<<dp[sub]<<\" * \"<<pow(P,e)<<endl;\n\t\t\tdp[mask]-=dp[sub]*pow(P,e);\n\t\t\tif(sub==(1<<par))break;\n\t\t}\n\t\t\n\t\t//cout<<mask<<\" \"<<dp[mask]<<endl;\n\t}\n\t//cout<<setprecision(16)<<dp[(1<<N)-1]<<endl;\n\tprintf(\"%.16f\\n\",dp[(1<<N)-1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint n, m;\nld p;\nvector<vi> g;\nvector<ld> dp;\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tcin >> n >> m >> p;\n\tg.resize(n, vi(n));\n\tdp.resize(1 << n);\n\tp /= 100.0;\n\tREP(i, m)\n\t{\n\t\tint a, b; cin >> a >> b;\n\t\ta--; b--;\n\t\tg[a][b]++;\n\t\tg[b][a]++;\n\t}\n\tREP(s, 1 << n)\n\t{\n\t\tint v = s&~s;\n\t\tdp[s] = 1.0;\n\t\tfor (int t = (s - 1) & s; t > 0; t = (t - 1)&s)\n\t\t{\n\t\t\tif (!(t&(1 << v))) continue;\n\t\t\tint edge = 0;\n\t\t\tint u = s^t;\n\t\t\tREP(i, n)\n\t\t\t{\n\t\t\t\tif (!((t >> i) & 1)) continue;\n\t\t\t\tREP(j, n)\n\t\t\t\t{\n\t\t\t\t\tif (((u >> j) & 1) && g[i][j]) edge++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[s] -= dp[t] * pow(p, edge);\n\t\t}\n\t}\n\tcout << dp[(1 << n) - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint main(){\n  int N, M, P;\n  while(cin >> N >> M >> P){\n    vector<int> start(N);\n    vector<int> goal(N);\n    REP(i, N) start[i] = i;\n    REP(i, N) goal[i] = 0;\n    map< vector<int>, double > dp;\n    dp[start] = 1.0;\n    REP(i, M){\n      int u, v; cin >> u >> v;\n      u--; v--;\n      if(u > v) swap(u, v);\n      map< vector<int>, double > next_dp;\n      FORIT(it, dp){\n        vector<int> tr = it->first;\n        next_dp[tr] += it->second * P / 100.0;\n        int From = max(tr[v], tr[u]);\n        int To = min(tr[v], tr[u]);\n        for(int i = 0; i < N; i++)if(tr[i] == From) tr[i] = To;\n        next_dp[tr] += it->second * (100.0 - P) / 100.0;\n      }\n      /*\n      FORIT(it, next_dp){\n        printf(\"%.6lf : \", it->second);\n        debug(it->first.begin(), it->first.end());\n      }\n      cout << endl;\n      */\n      dp = next_dp;\n    }\n    printf(\"%.16lf\\n\", dp[goal]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <bitset>\nusing namespace std;\n\nclass UnionFindTree{\n\ttypedef struct {\n\t\tint parent;\n\t\tint rank;\n\t}base_node;\n\t\n\tvector<base_node> node;\npublic:\n\tUnionFindTree(int n){\n\t\tnode.resize(n);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tnode[i].parent=i;\n\t\t\tnode[i].rank=0;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(node[x].parent == x) return x;\n\t\telse{\n\t\t\treturn node[x].parent = find(node[x].parent);\n\t\t}\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(node[x].parent);\n\t\ty = find(node[y].parent);\n\t\tif(x==y) return;\n\t\tif(node[x].rank < node[y].rank){\n\t\t\tnode[x].parent = y;\n\t\t}else if(node[x].rank > node[y].rank){\n\t\t\tnode[y].parent = x;\n\t\t}else{\n\t\t\tnode[x].rank++;\n\t\t\tunite(x,y);\n\t\t}\n\t}\n};\n\nint main_(){\n\tint n,m,p;\n\tcin >> n >> m >> p;\n\n\tUnionFindTree uft(n);\n\n\tvector<int> u(m),v(m);\n\tvector<int> e(m);\n\tvector<vector<int>> g(n);\n\t//vector<int> g(n);\n\tfor(int i=0; i<m; i++){\n\t\tcin >> u[i] >> v[i];\n\t\tu[i]--; v[i]--;\n\t\t//g[u[i]] |= 1<<v[i];\n\t\t//g[v[i]] |= 1<<u[i];\n\t\tg[u[i]].push_back(v[i]);\n\t\tg[v[i]].push_back(u[i]);\n\t\t//e[i] = (1<<u[i]) | (1<<v[i]);\n\t\tuft.unite(u[i], v[i]);\n\t}\n\tbool connected = true;\n\tfor(int i=1; i<n; i++){\n\t\tconnected = connected && uft.same(0,i);\n\t}\n\tif(connected == false){\n\t\tprintf(\"0.000000000000000000\\n\");\n\t\treturn 0;\n\t}\n\n\tvector<int> edge_cnt(1<<n, 0);\n\tfor(int i=0; i<(1<<n); i++){\n\t\tfor(int j=0; j<m; j++){\n\t\t\tif((i>>u[j])&(i>>v[j])&1){\n\t\t\t\tedge_cnt[i]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<double> prob(1<<n, -1);\n\tprob[1] = 1;\n\n\tfunction<double(int)> dfs = [&](int s){\n\t\tif(prob[s] != -1) return prob[s];\n\t\tdouble res = 1.0;\n\t\tint s_ = s-1;\n\t\tfor(int x=s_; x>=0; x=(x-1)&s_){\n\t\t\tint y = x|1;\n\t\t\tif(y==s) continue;\n\t\t\tdouble q = dfs(y);\n\t\t\tdouble tmp = 1.0;\n\t\t\t/*\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tif( (((1<<u[i])&y) && ((1<<v[i])&(s^y))) or (((1<<v[i])&y) and ((1<<u[i])&(s^y))) ){\n\t\t\t\t\ttmp *= 0.01 * p;\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\t\t\t\n\t\t\ttmp = pow(0.01*p, edge_cnt[s] - edge_cnt[y] - edge_cnt[s^y]);\n\n\t\t\tres -= q * tmp;\n\n\t\t\tif(x==0) break;\n\t\t}\n\t\treturn prob[s] = res;\n\t};\n\n\tdouble ans = dfs((1<<n)-1);\n\tprintf(\"%.18f\\n\", ans);\n\treturn 0;\n}\n\n\nint main(){\n\tauto start = clock();\n\tmain_();\n\t//cerr << clock()-start << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int n,m;\n  double p;\n  cin >> n >> m >> p;\n  p/=100;\n  int c[1<<n];\n  double d[1<<n];\n  memset(c,0,sizeof(c));\n  for(int i=0; i<m; i++) {\n    int x,y;\n    cin >> x >> y;\n    x--;y--;\n    for(int t=1; t<(1<<n); t++) {\n      if((t&(1<<x)) && (t&(1<<y))) c[t]++;\n    }\n  }\n  fill(d,d+(1<<n),1);\n  for(int t=(1<<(n-1)); t<(1<<n); t++) {\n    for(int s=(1<<(n-1)); s<t; s++) {\n      bool ck=true;\n      int r=0;\n      for(int i=0; i<n; i++) {\n\tif(!(t&(1<<i)) && (s&(1<<i))) ck=false;\n\tif((t&(1<<i)) && !(s&(1<<i))) r|=(1<<i);\n      }\n      if(!ck) continue;\n      double q=1;\n      for(int i=0; i<c[t]-c[s]-c[r]; i++) q*=p;\n      d[t]-=d[s]*q;\n    }\n  }\n  printf(\"%.10f\\n\",d[(1<<n)-1]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n#define bit(x) (1<<(x))\nusing namespace std;\n\nint n,m,p;\nint a[15][15];\n\nusing R=long double;\nR dp[1<<14];\n\nint main(void){\n\tcin >> n >> m >> p;\n\trep(i,m){\n\t\tint u,v;\n\t\tcin >> u >> v;\n\t\ta[u-1][v-1]++;\n\t\ta[v-1][u-1]++;\n\t}\n\n\trep(mask,1,1<<n){\n\t\tif(__builtin_popcount(mask)==1){\n\t\t\tdp[mask]=1.0;\n\t\t\tcontinue;\n\t\t}\n\t\tdp[mask]=1.0;\n\t\tint limit=bit(31-__builtin_clz(mask));\n\t\tfor(int add=(mask-1)&mask;add>=limit;add=(add-1)&mask){\n\t\t\tint root=limit^mask;\n\t\t\tdouble cur=dp[add];\n\t\t\trep(i,n)rep(j,n) if(root&bit(i)) if(limit&bit(j)) rep(loop,a[i][j]) cur*=1.0*p/100.0; \n\t\t\tdp[mask]-=cur;\t\n\t\t}\n\t}\n\tcout.precision(20);\n\tcout << fixed << dp[(1<<n)-1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <bitset>\nusing namespace std;\n\nclass UnionFindTree{\n\ttypedef struct {\n\t\tint parent;\n\t\tint rank;\n\t}base_node;\n\t\n\tvector<base_node> node;\npublic:\n\tUnionFindTree(int n){\n\t\tnode.resize(n);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tnode[i].parent=i;\n\t\t\tnode[i].rank=0;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(node[x].parent == x) return x;\n\t\telse{\n\t\t\treturn node[x].parent = find(node[x].parent);\n\t\t}\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(node[x].parent);\n\t\ty = find(node[y].parent);\n\t\tif(x==y) return;\n\t\tif(node[x].rank < node[y].rank){\n\t\t\tnode[x].parent = y;\n\t\t}else if(node[x].rank > node[y].rank){\n\t\t\tnode[y].parent = x;\n\t\t}else{\n\t\t\tnode[x].rank++;\n\t\t\tunite(x,y);\n\t\t}\n\t}\n};\n\nint main_(){\n\tint n,m,p;\n\t//cin >> n >> m >> p;\n\tscanf(\"%d%d%d\", &n,&m,&p);\n\n\tUnionFindTree uft(n);\n\n\tvector<int> u(m),v(m);\n\tvector<int> e(m);\n\tvector<vector<int>> g(n);\n\t//vector<int> g(n);\n\tfor(int i=0; i<m; i++){\n\t\t//cin >> u[i] >> v[i];\n\t\tscanf(\"%d%d\", &u[i],&v[i]);\n\t\tu[i]--; v[i]--;\n\t\t//g[u[i]] |= 1<<v[i];\n\t\t//g[v[i]] |= 1<<u[i];\n\t\tg[u[i]].push_back(v[i]);\n\t\tg[v[i]].push_back(u[i]);\n\t\t//e[i] = (1<<u[i]) | (1<<v[i]);\n\t\tuft.unite(u[i], v[i]);\n\t}\n\tbool connected = true;\n\tfor(int i=1; i<n; i++){\n\t\tconnected = connected && uft.same(0,i);\n\t}\n\tif(connected == false){\n\t\tprintf(\"0.000000000000000000\\n\");\n\t\treturn 0;\n\t}\n\n\tvector<int> edge_cnt(1<<n, 0);\n\tfor(int i=0; i<(1<<n); i++){\n\t\tfor(int j=0; j<m; j++){\n\t\t\tif((i>>u[j])&(i>>v[j])&1){\n\t\t\t\tedge_cnt[i]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<double> prob(1<<n, -1);\n\tprob[1] = 1;\n\n\tfunction<double(int)> dfs = [&](int s){\n\t\tif(prob[s] != -1) return prob[s];\n\t\tdouble res = 1.0;\n\t\tint s_ = s-1;\n\t\tfor(int x=s_; x>=0; x=(x-1)&s_){\n\t\t\tint y = x|1;\n\t\t\tif(y==s) continue;\n\t\t\tdouble q = dfs(y);\n\n\t\t\tdouble tmp = 1.0;\n\t\t\t/*\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tif( (((1<<u[i])&y) && ((1<<v[i])&(s^y))) or (((1<<v[i])&y) and ((1<<u[i])&(s^y))) ){\n\t\t\t\t\ttmp *= 0.01 * p;\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\t\t\t\n\t\t\ttmp = pow(0.01*p, edge_cnt[s] - edge_cnt[y] - edge_cnt[s^y]);\n\n\t\t\tres -= q * tmp;\n\n\t\t\tif(x==0) break;\n\t\t}\n\t\treturn prob[s] = res;\n\t};\n\n\tdouble ans = dfs((1<<n)-1);\n\tprintf(\"%.18f\\n\", ans);\n\treturn 0;\n}\n\n\nint main(){\n\tauto start = clock();\n\tmain_();\n\t//cerr << clock()-start << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const set<T>& a){\n\tos<<'{';\n\tfor(auto i=begin(a);i!=end(a);++i)\n\t\tos<<(i==begin(a)?\"\":\" \")<<*i;\n\treturn os<<'}';\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tdouble p; cin>>p; p*=0.01;\n\t\tvector<pii> es;\n\t\trep(i,m){\n\t\t\tint u,v; cin>>u>>v; u--,v--;\n\t\t\tes.emplace_back(u,v);\n\t\t}\n\t\tsort(all(es));\n\t\t\n\t\tmap<vector<int>,double> f1; // {連結成分} => 確率\n\t\t{\n\t\t\tvector<int> tmp;\n\t\t\trep(i,n) tmp.push_back(1<<i);\n\t\t\tf1[tmp]=1;\n\t\t}\n\t\t\n\t\tfor(auto e:es){\n\t\t\t//dump(f1.size());\n\t\t\tint u,v; tie(u,v)=e;\n\t\t\tdecltype(f1) f2;\n\t\t\tfor(auto t:f1){\n\t\t\t\tvector<int> cs=t.first;\n\t\t\t\tdouble cp=t.second;\n\t\t\t\tif(cp<1e-14) continue;\n\t\t\t\tvector<int> ns;\n\t\t\t\tint tmp=0;\n\t\t\t\tfor(auto s:cs){\n\t\t\t\t\tif((s>>u&1) || (s>>v&1))\n\t\t\t\t\t\ttmp|=s;\n\t\t\t\t\telse\n\t\t\t\t\t\tns.push_back(s);\n\t\t\t\t}\n\t\t\t\tif(tmp) ns.push_back(tmp);\n\t\t\t\tsort(all(ns));\n\t\t\t\t\n\t\t\t\tf2[ns]+=cp*(1-p);\n\t\t\t\tf2[cs]+=cp*p;\n\t\t\t}\n\t\t\tswap(f1,f2);\n\t\t}\n\t\t\n\t\tdouble res=0;\n\t\tfor(auto p:f1) if(p.first.size()==1) res=p.second;\n\t\tprintf(\"%.12f\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n#define bit(x) (1<<(x))\nusing namespace std;\n\nint n,m,p;\nint a[15][15];\n\nusing R=long double;\nR dp[1<<14];\n\nint main(void){\n\tcin >> n >> m >> p;\n\trep(i,m){\n\t\tint u,v;\n\t\tcin >> u >> v;\n\t\ta[u-1][v-1]++;\n\t\ta[v-1][u-1]++;\n\t}\n\n\trep(mask,1,1<<n){\n\t\tdp[mask]=1.0;\t\t\n\t\tif(__builtin_popcount(mask)==1) continue;\n\t\tfor(int add=(mask-1)&mask;add>=1;add=(add-1)&mask){\n\t\t\tint root=add^mask;\n\t\t\tif(add<root) break;\n\t\t\tdouble cur=dp[add];\n\t\t\trep(i,n)rep(j,n) if(root&bit(i)) if(add&bit(j)) rep(loop,a[i][j]) cur*=1.0*p/100.0; \n\t\t\tdp[mask]-=cur;\t\n\t\t}\n\t}\n\n\tcout.precision(20);\n\tcout << fixed << dp[bit(n)-1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const set<T>& a){\n\tos<<'{';\n\tfor(auto i=begin(a);i!=end(a);++i)\n\t\tos<<(i==begin(a)?\"\":\" \")<<*i;\n\treturn os<<'}';\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tdouble p; cin>>p; p*=0.01;\n\t\tvector<pii> es;\n\t\trep(i,m){\n\t\t\tint u,v; cin>>u>>v; u--,v--;\n\t\t\tes.emplace_back(u,v);\n\t\t}\n\t\t\n\t\tmap<set<set<int>>,double> f1; // {連結成分} => 確率\n\t\t{\n\t\t\tset<set<int>> tmp;\n\t\t\trep(i,n) tmp.insert(set<int>({i}));\n\t\t\tf1[tmp]=1;\n\t\t}\n\t\t\n\t\tfor(auto e:es){\n\t\t\tint u,v; tie(u,v)=e;\n\t\t\tdecltype(f1) f2;\n\t\t\tfor(auto t:f1){\n\t\t\t\tset<set<int>> cs=t.first;\n\t\t\t\tdouble cp=t.second;\n\t\t\t\tset<set<int>> ns;\n\t\t\t\tset<int> tmp;\n\t\t\t\tfor(auto s:cs){\n\t\t\t\t\tif(s.count(u) || s.count(v))\n\t\t\t\t\t\ttmp.insert(all(s));\n\t\t\t\t\telse\n\t\t\t\t\t\tns.insert(s);\n\t\t\t\t}\n\t\t\t\tif(tmp.size()) ns.insert(tmp);\n\t\t\t\t\n\t\t\t\tf2[ns]+=cp*(1-p);\n\t\t\t\tf2[cs]+=cp*p;\n\t\t\t}\n\t\t\tswap(f1,f2);\n\t\t}\n\t\t\n\t\tdouble res=0;\n\t\tfor(auto p:f1) if(p.first.size()==1) res=p.second;\n\t\tprintf(\"%.12f\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<string>\n#include<algorithm>\nusing namespace std;\ndouble dp[100010];\nint N,M;\ndouble p;\nint g[20][20];\n#define eps 1e-6\nbool jud[20];\nvoid dfs(int n)\n{\n    jud[n]=true;\n    for(int i=0;i<N;i++)\n    {\n        if(g[n][i]&&!jud[i])\n        {\n            dfs(i);\n        }\n    }\n}\nint main()\n{\n    int i,j,k;\n    int n,m,t;\n    int a,b,s;\n    scanf(\"%d%d%lf\",&N,&M,&p);\n    for(i=0;i<M;i++)\n    {\n        scanf(\"%d%d\",&a,&b);\n        a--;b--;\n        if(a==b)\n        {\n            i--;M--;\n            continue;\n        }\n        g[a][b]=g[b][a]=1;\n    }\n    p/=100.0;\n    if(p<eps)\n    {\n        dfs(0);\n        for(i=0;i<N;i++) if(!jud[i]) break;\n        if(i==N) printf(\"1.000000000000\\n\");\n        else printf(\"0.000000000000\\n\");\n        return 0;\n    }\n\n    if(p>1.0-eps)\n    {\n        if(N>1) printf(\"0.000000000000\\n\");\n        else printf(\"1.000000000000\\n\");\n        return 0;\n    }\n\n    for(i=0;i<N;i++) dp[(1<<i)]=1.0;\n    double pp;\n    for(n=1;n<(1<<N);n++)\n    {\n        //cout<<n<<endl;\n        for(i=0;i<N;i++) if(n==(1<<i)) break;\n        if(i<N) continue;\n        for(a=0;a<N;a++) if(n&(1<<a)) break;\n        for(b=0;b<N;b++) if((n&(1<<b))&&b!=a) break;\n        for(m=n&(n-1);m;m=n&(m-1))\n        {\n            if(m&(1<<a)) continue;\n            if(!(m&(1<<b))) continue;\n            t=n&(~m);pp=1.0;\n            for(i=0;i<N;i++)\n                if(((1<<i)&m)&&g[a][i]) pp*=p;\n            pp=1.0/pp-1.0;\n            dp[n]+=dp[m]*dp[t]*pp;\n            //cout<<n<<\"  \"<<m<<\"   \"<<dp[n]<<endl;\n        }\n        //cout<<n<<\"  \"<<dp[n]<<endl;\n    }\n    for(i=0;i<M;i++) dp[(1<<N)-1]*=p;\n    printf(\"%.12f\\n\",dp[(1<<N)-1]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include<cmath>\n#include<set>\n#include<stack>\n#include <string.h>\n\nusing namespace std;\n\nint V;                      //????????°\nvector<int>G[10000];       //??°???)(){????????£??\\????????¨???\nvector<int>rG[10000];\nvector<int> vs;             //??°?????????????????????\nbool used[10000];           //?????§???????????????\nint cmp[10000];             //?±????????????£????????????????????????????????????\nint P;\n\nvoid add_edge(int from, int to){\n    G[from].push_back(to);\n    rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n    used[v] = true;\n    for(int i=0;i<G[v].size();i++){\n        if(!used[G[v][i]]) dfs(G[v][i]);\n    }\n    vs.push_back(v);\n}\nint rdfs(int v,int k){\n    used[v] = true;\n    cmp[v] = k;\n    int ret=0;\n    for(int i=0;i<rG[v].size();i++){\n        if(!used[rG[v][i]]) {\n            ret+=rdfs(rG[v][i], k);\n        }\n    }\n    return ret;\n}\n\ndouble scc(){\n    memset(used, 0, sizeof(used));\n    vs.clear();\n    for(int v=0;v<V;v++){\n        if(!used[v]) dfs(v);\n    }\n    memset(used,0,sizeof(used));\n    int k=0;\n    double ans=0;\n    for(int i=vs.size()-1;i>=0;i--){\n        if(!used[vs[i]]) {\n            int nu=rdfs(vs[i], k++);\n            if(nu>1){\n                double du=(nu*(nu-1)*1.0)/2*P*P;\n                ans+=du;\n            } else {\n                ans+=P;\n            }\n        }\n    }\n    return ans;\n}\n\nint N,M;\nint A[50000], B[50000];\n\nvoid solve(){\n    cin>>N>>M>>P;\n    V=N;\n    for(int i=0;i<M;i++){\n        cin>>A[i]>>B[i];\n    }\n    for(int i=0;i<M;i++){\n        add_edge(A[i]-1,B[i]-1);\n    }\n    printf(\"%.9f\\n\",scc()/100);\n}\nint main()\n{\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <bitset>\nusing namespace std;\n\nclass UnionFindTree{\n\ttypedef struct {\n\t\tint parent;\n\t\tint rank;\n\t}base_node;\n\t\n\tvector<base_node> node;\npublic:\n\tUnionFindTree(int n){\n\t\tnode.resize(n);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tnode[i].parent=i;\n\t\t\tnode[i].rank=0;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(node[x].parent == x) return x;\n\t\telse{\n\t\t\treturn node[x].parent = find(node[x].parent);\n\t\t}\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(node[x].parent);\n\t\ty = find(node[y].parent);\n\t\tif(x==y) return;\n\t\tif(node[x].rank < node[y].rank){\n\t\t\tnode[x].parent = y;\n\t\t}else if(node[x].rank > node[y].rank){\n\t\t\tnode[y].parent = x;\n\t\t}else{\n\t\t\tnode[x].rank++;\n\t\t\tunite(x,y);\n\t\t}\n\t}\n};\n\nint main_(){\n\tint n,m,p;\n\tcin >> n >> m >> p;\n\n\tUnionFindTree uft(n);\n\n\tvector<int> u(m),v(m);\n\tvector<int> e(m);\n\tvector<vector<int>> g(n);\n\t//vector<int> g(n);\n\tfor(int i=0; i<m; i++){\n\t\tcin >> u[i] >> v[i];\n\t\tu[i]--; v[i]--;\n\t\t//g[u[i]] |= 1<<v[i];\n\t\t//g[v[i]] |= 1<<u[i];\n\t\tg[u[i]].push_back(v[i]);\n\t\tg[v[i]].push_back(u[i]);\n\t\t//e[i] = (1<<u[i]) | (1<<v[i]);\n\t\tuft.unite(u[i], v[i]);\n\t}\n\tbool connected = true;\n\tfor(int i=1; i<n; i++){\n\t\tconnected = connected && uft.same(0,i);\n\t}\n\tif(connected == false){\n\t\tprintf(\"0.000000000000000000\\n\");\n\t\treturn 0;\n\t}\n\n\tvector<int> edge_cnt(1<<n, 0);\n\tfor(int i=0; i<(1<<n); i++){\n\t\tfor(int j=0; j<m; j++){\n\t\t\tif((i>>u[j])&(i>>v[j])&1){\n\t\t\t\tedge_cnt[i]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<double> prob(1<<n, -1);\n\tprob[1] = 1;\n\n\tfunction<double(int)> dfs = [&](int s){\n\t\tif(prob[s] != -1) return prob[s];\n\t\tdouble res = 1.0;\n\t\tint s_ = s-1;\n\t\tfor(int x=s_; x>=0; x=(x-1)&s_){\n\t\t\tint y = x|1;\n\t\t\tif(y==s) continue;\n\t\t\tdouble q = dfs(y);\n\t\t\tif(q<1e-13) continue;\n\t\t\tdouble tmp = 1.0;\n\t\t\t/*\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tif( (((1<<u[i])&y) && ((1<<v[i])&(s^y))) or (((1<<v[i])&y) and ((1<<u[i])&(s^y))) ){\n\t\t\t\t\ttmp *= 0.01 * p;\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\t\t\t\n\t\t\ttmp = pow(0.01*p, edge_cnt[s] - edge_cnt[y] - edge_cnt[s^y]);\n\n\t\t\tres -= q * tmp;\n\n\t\t\tif(x==0) break;\n\t\t}\n\t\treturn prob[s] = res;\n\t};\n\n\tdouble ans = dfs((1<<n)-1);\n\tprintf(\"%.18f\\n\", ans);\n\treturn 0;\n}\n\n\nint main(){\n\tauto start = clock();\n\tmain_();\n\t//cerr << clock()-start << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tdouble p; cin>>p; p/=100;\n\t\tvector<pii> es;\n\t\trep(i,m){\n\t\t\tint u,v; cin>>u>>v; u--,v--;\n\t\t\tes.emplace_back(u,v);\n\t\t\tes.emplace_back(v,u);\n\t\t}\n\t\t\n\t\tvd dp(1<<n,1);\n\t\trepi(i,1,1<<n){\n\t\t\tint k=31-__builtin_clz(i);\n\t\t\tfor(int j=(i-1)&i;j&1<<k;j=(j-1)&i){\n\t\t\t\tdouble q=dp[j];\n\t\t\t\tfor(auto t:es){\n\t\t\t\t\tint u,v; tie(u,v)=t;\n\t\t\t\t\tif((j>>u&1) && ((i-j)>>v&1))\n\t\t\t\t\t\tq*=p;\n\t\t\t\t}\n\t\t\t\tdp[i]-=q;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.12f\\n\",dp.back());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint main() {\n\tint N, M, P;\n\tcin >> N >> M >> P;\n\tdouble p = P / 100.0;\n\tvector<int> a(M), b(M);\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> a[i] >> b[i];\n\t\ta[i]--; b[i]--;\n\t}\n\tvector<double> dp(1<<(N - 1), 1);\n\tfor (int S = 0; S < 1<<(N - 1); S++) {\n\t\tint _S = (S<<1) + 1;\n\t\tfor (int T = S; T;) {\n\t\t\tT = (T - 1) & S;\n\t\t\tint _T = (T<<1) + 1;\n\t\t\tdouble x = 1;\n\t\t\tfor (int i = 0; i < M; i++)\n\t\t\t\tif ((_S>>a[i] & 1) && (_S>>b[i] & 1) && ((_T>>a[i] & 1) ^ (_T>>b[i] & 1)))\n\t\t\t\t\tx *= p;\n\t\t\tdp[S] -= dp[T] * x;\n\t\t}\n\t}\n\tprintf(\"%.15f\\n\", dp[(1<<(N - 1)) - 1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#define bitcount __builtin_popcount\n#define bitctz __builtin_ctz\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nint main()\n{\n\tint n, m; double p;\n\tcin>>n>>m>>p; p/=100;\n\tint a[100], b[100];\n\tfor(int i=0; i<m; i++){\n\t\tcin>>a[i]>>b[i]; a[i]--; b[i]--;\n\t}\n\tint ct[1<<14]={};\n\tfor(int i=0; i<(1<<n); i++){\n\t\tfor(int j=0; j<m; j++){\n\t\t\tif((i&(1<<a[j])) && (i&(1<<b[j]))) ct[i]++;\n\t\t}\n\t}\n\tdouble dp[1<<14]={};\n\tfor(int i=1; i<(1<<n); i++){\n\t\tint t=bitctz(i);\n\t\tif(i==(1<<t)) continue;\n\t\tfor(int j=i; j>0; j=(j-1)&i){\n\t\t\tif(j==i) continue;\n\t\t\tif((j&(1<<t))==0) continue;\n\t\t\tdp[i]+=((1-dp[j])*pow(p, (double)(ct[i]-ct[j]-ct[i-j])));\n\t\t\t\n\t\t}\n\t}\n\tprintf(\"%.10lf\\n\", 1-dp[(1<<n)-1]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ld=double;\n\nint n,m;\nld p;\nusing Edge=int;\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\nGraph g;\nint tpow[15];\narray<ld,15000000> table;\narray<ld,1000000> dp;\nld solve(int st);\nld dfs(int inde,int mc,int st,int stt,array<int,14>& sts,array<int,14> &sttv){\n    if(inde==n){\n        if(mc==1) return 0;\n        ld res=1.0;\n        for(int i=0;i<mc;i++){\n            if(i==0) res*=solve(sts[i])*table[sttv[i]+stt];\n        }\n        return res;\n    }\n    if(!((st>>inde)&1)) return dfs(inde+1,mc,st,stt,sts,sttv);\n    ld res=0;\n    \n    for(int i=0;i<mc;i++){\n        sts[i]|=(1<<inde);\n        sttv[i]+=tpow[inde];\n        res+=dfs(inde+1,mc,st,stt,sts,sttv);\n        sttv[i]-=tpow[inde];\n        sts[i]^=(1<<inde);\n    }\n    if(mc<=1){\n    sts[mc]=(1<<inde);\n    sttv[mc]+=tpow[inde];\n    res+=dfs(inde+1,mc+1,st,stt,sts,sttv);\n    \n    sttv[mc]=0;\n    sts[mc]=0;\n    }\n    return res;\n}\nld solve(int st){\n    if(dp[st]>-0.5) return dp[st];\n    if(__builtin_popcount(st)<=1) return dp[st]=1.0;\n    int stt=0;\n    for(int i=0;i<n;i++){\n        if((st>>i)&1) stt+=tpow[i];\n    }\n    array<int,14> sts;\n    fill(sts.begin(),sts.end(),0);\n    array<int,14> sttv;\n    fill(sttv.begin(),sttv.end(),0);\n    ld res=1.0-dfs(0,0,st,stt,sts,sttv);\n    return dp[st]=res;\n}\nint main(){\n    tpow[0]=1;\n    for(int i=0;i<14;i++) tpow[i+1]=tpow[i]*3;\n    fill(dp.begin(),dp.end(),-1);\n    cin>>n>>m>>p;\n    p/=100.;\n    g.assign(n,Edges());\n    for(int i=0;i<m;i++){\n        int u,v;\n        cin>>u>>v;\n        u--,v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    \n    for(int i=0;i<(1<<n);i++){\n        int sub=i;\n        int it=0;\n        for(int k=0;k<n;k++){\n            if((i>>k)&1){\n                it+=tpow[k];\n            }\n        }\n        do{\n            ld pc=1;\n            for(int j=0;j<n;j++){\n                if((sub>>j)&1){\n                    for(int k=0;k<g[j].size();k++){\n                        if(((i>>g[j][k])&1)&&(!((sub>>g[j][k])&1))){\n                            pc*=p;\n                        }\n                    }\n                }\n            }\n            int subt=0;\n            for(int k=0;k<n;k++){\n                if((sub>>k)&1){\n                    subt+=tpow[k];\n                }\n            }\n            table[it+subt]=pc;\n            sub=(sub-1)&i;\n        }while(sub!=i);\n    }\n    cout<<setprecision(15)<<fixed;\n    cout<<solve((1<<n)-1)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n#include <bitset>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n/**\n * hash???????????????UnionFind ????´???°???16????????????????????¨??????????????????\n */\ntemplate<int N>\nstruct SUnionFind {\n    int i2g[N];\n    SUnionFind() {\n        for (int i = 0; i < N; i++) {\n            i2g[i] = i;\n        }\n    }\n    SUnionFind(ull hs) {\n        for (int i = 0; i < N; i++) {\n            i2g[i] = hs & 0xf;\n            hs >>= 4;\n        }\n    }\n\n    void merge(int x, int y) {\n        int xg = i2g[x], yg = i2g[y];\n        for (int i = 0; i < N; i++) {\n            if (i2g[i] == yg) i2g[i] = xg;\n        }\n    }\n\n    bool same(int x, int y) {\n        return i2g[x] == i2g[y];\n    }\n\n    ull hash() {\n        int b[N];\n        memset(b, -1, sizeof(b));\n        int c = 0;\n        ull hs = 0;\n        for (int i = N-1; i >= 0; i--) {\n            hs <<= 4;\n            if (b[i2g[i]] == -1) {\n                b[i2g[i]] = c;\n                c++;\n            }\n            hs += b[i2g[i]];\n        }\n        return hs;\n    }\n};\n\ntypedef SUnionFind<14> UF;\ntypedef pair<ull, double> P;\n\n\nstruct MyCmp {\n    bool operator()(const P &l, const P &r) const {\n        return l.first < r.first;\n    }\n};\n\nint main() {\n    int n, m, pp;\n    cin >> n >> m >> pp;\n    double p = pp / 100.0;\n\n    int g[14]= {};\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b; a--; b--;\n        if (a > b) swap(a, b);\n        g[a] |= (1<<b);\n    }\n\n    vector<P> mp;\n    mp.push_back(P(UF().hash(), 1.0));\n    for (int i = 0; i < n-1; i++) {\n        for (int j = i+1; j < n; j++) {\n            if (!(g[i] & (1<<j))) continue;\n            mp.reserve(mp.size()*2);\n            int S = (int)mp.size();\n            for (int k = 0; k < S; k++) {\n                ull d; double r;\n                tie(d, r) = mp[k];\n                UF uf(d);\n                uf.merge(i, j);\n                mp[k].second *= p;\n                mp.push_back(P(uf.hash(), r*(1-p)));\n            }\n            if (!mp.size()) continue;\n            sort(mp.begin(), mp.end(), MyCmp());\n            int l = 0;\n            for (int k = 1; k < (int)mp.size(); k++) {\n                if (mp[l].first != mp[k].first) {\n                    l++;\n                    mp[l] = mp[k];\n                } else {\n                    mp[l].second += mp[k].second;\n                }\n            }\n            l++;\n            mp.resize(l);\n        }\n\n        int nn = 0;\n        int S = (int)mp.size();\n        for (int k = 0; k < S; k++) {\n            P p = mp[k];\n            UF uf(p.first);\n            bool f = false;\n            for (int j = i+1; j < n; j++) {\n                if (uf.same(i, j)) {\n                    f = true;\n                    break;\n                }\n            }\n            if (!f) continue;\n\n            UF uf2;\n            for (int j = i+1; j < n; j++) {\n                for (int k = j+1; k < n; k++) {\n                    if (uf.same(j, k)) uf2.merge(j, k);\n                }\n            }\n            mp[nn] = P(uf2.hash(), p.second);\n            nn++;\n        }\n        mp.resize(nn);\n        if (!mp.size()) continue;\n        sort(mp.begin(), mp.end(), MyCmp());\n        int l = 0;\n        for (int k = 1; k < (int)mp.size(); k++) {\n            if (mp[l].first != mp[k].first) {\n                l++;\n                mp[l] = mp[k];\n            } else {\n                mp[l].second += mp[k].second;\n            }\n        }\n        l++;\n        mp.resize(l);\n    }\n    double res = 0;\n    for (auto p : mp) {\n        res += p.second;\n    }\n    printf(\"%.20lf\\n\", res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <bitset>\nusing namespace std;\n\nclass UnionFindTree{\n\ttypedef struct {\n\t\tint parent;\n\t\tint rank;\n\t}base_node;\n\t\n\tvector<base_node> node;\npublic:\n\tUnionFindTree(int n){\n\t\tnode.resize(n);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tnode[i].parent=i;\n\t\t\tnode[i].rank=0;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(node[x].parent == x) return x;\n\t\telse{\n\t\t\treturn node[x].parent = find(node[x].parent);\n\t\t}\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(node[x].parent);\n\t\ty = find(node[y].parent);\n\t\tif(x==y) return;\n\t\tif(node[x].rank < node[y].rank){\n\t\t\tnode[x].parent = y;\n\t\t}else if(node[x].rank > node[y].rank){\n\t\t\tnode[y].parent = x;\n\t\t}else{\n\t\t\tnode[x].rank++;\n\t\t\tunite(x,y);\n\t\t}\n\t}\n};\n\nint main_(){\n\tint n,m,p;\n\tcin >> n >> m >> p;\n\n\tUnionFindTree uft(n);\n\n\tvector<int> u(m),v(m);\n\tvector<int> e(m);\n\tvector<vector<int>> g(n);\n\t//vector<int> g(n);\n\tfor(int i=0; i<m; i++){\n\t\tcin >> u[i] >> v[i];\n\t\tu[i]--; v[i]--;\n\t\t//g[u[i]] |= 1<<v[i];\n\t\t//g[v[i]] |= 1<<u[i];\n\t\tg[u[i]].push_back(v[i]);\n\t\tg[v[i]].push_back(u[i]);\n\t\t//e[i] = (1<<u[i]) | (1<<v[i]);\n\t\tuft.unite(u[i], v[i]);\n\t}\n\tbool connected = true;\n\tfor(int i=1; i<n; i++){\n\t\tconnected = connected && uft.same(0,i);\n\t}\n\tif(connected == false){\n\t\tprintf(\"0.000000000000000000\\n\");\n\t\treturn 0;\n\t}\n\n\tvector<int> edge_cnt(1<<n, 0);\n\tfor(int i=0; i<(1<<n); i++){\n\t\tfor(int j=0; j<m; j++){\n\t\t\tif((i>>u[j])&(i>>v[j])&1){\n\t\t\t\tedge_cnt[i]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<double> prob(1<<n, -1);\n\tprob[1] = 1;\n\n\tfunction<double(int)> dfs = [&](int s){\n\t\tif(prob[s] != -1) return prob[s];\n\t\tdouble res = 1.0;\n\t\tint s_ = s-1;\n\t\tfor(int x=s_; x>=0; x=(x-1)&s_){\n\t\t\tint y = x|1;\n\t\t\tif(y==s) continue;\n\t\t\tdouble q = dfs(y);\n\t\t\tdouble tmp = 1.0;\n\t\t\t/*\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tif( (((1<<u[i])&y) && ((1<<v[i])&(s^y))) or (((1<<v[i])&y) and ((1<<u[i])&(s^y))) ){\n\t\t\t\t\ttmp *= 0.01 * p;\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\t\t\t\n\t\t\ttmp = pow(0.01*p, edge_cnt[s] - edge_cnt[y] - edge_cnt[s^y]);\n\n\t\t\tres -= q * tmp;\n\n\t\t\tif(x==0) break;\n\t\t}\n\t\treturn prob[s] = res;\n\t};\n\n\tdouble ans = dfs((1<<n)-1);\n\tprintf(\"%.18f\\n\", ans);\n\treturn 0;\n}\n\n\nint main(){\n\tauto start = clock();\n\tmain_();\n\t//cerr << clock()-start << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#define bitcount __builtin_popcount\n#define bitctz __builtin_ctz\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nint main()\n{\n\tint n, m; double p;\n\tcin>>n>>m>>p; p/=100;\n\tint a[100], b[100];\n\tfor(int i=0; i<m; i++){\n\t\tcin>>a[i]>>b[i]; a[i]--; b[i]--;\n\t}\n\tint ct[1<<14]={};\n\tfor(int i=0; i<(1<<n); i++){\n\t\tfor(int j=0; j<m; j++){\n\t\t\tif((i&(1<<a[j])) && (i&(1<<b[j]))) ct[i]++;\n\t\t}\n\t}\n\tdouble dp[15][1<<14]={};\n\tfor(int i=0; i<n; i++) dp[1][1<<i]=1;\n\tfor(int i=1; i<(1<<n); i++){\n\t\tif(bitcount(i)==1) continue;\n\t\tint t=bitctz(i);\n\t\tfor(int j=i; j>0; j=(j-1)&i){\n\t\t\tif((j&(1<<t))==0) continue;\n\t\t\tif(j==i) continue;\n\t\t\tfor(int k=1; k<n; k++){\n\t\t\t\tdp[k+1][i]+=(dp[k][i-j]*dp[1][j]*pow(p, (double)(ct[i]-ct[j]-ct[i-j])));\n\t\t\t}\n\t\t}\n\t\tdp[1][i]=1;\n\t\tfor(int k=2; k<=n; k++){\n\t\t\tdp[1][i]-=dp[k][i];\n\t\t}\n\t}\n\tprintf(\"%.10lf\\n\", dp[1][(1<<n)-1]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint n,m;\nvector<P> es;\ndouble p;\ndouble dp[1<<14];\n\nint main(){\n  cin>>n>>m>>p;\n  p/=100.0;\n  rep(i,m){\n    int a,b;\n    cin>>a>>b;a--;b--;\n    es.push_back(P(a,b));\n  }\n  repl(S,1,1<<n){\n    dp[S]=1.0;\n    ll v=0;\n    for(;!((S>>v)&1);v++);\n    for(ll T=S-1;T>=0;T--){\n      T&=S;\n      if(!((T>>v)&1))continue;\n      ll _T=S-T;\n      double pp=dp[T];\n      rep(i,m){\n        if((((T>>es[i].fi)&1)&&((_T>>es[i].se)&1))||(((_T>>es[i].fi)&1)&&((T>>es[i].se)&1)))pp*=p;\n      }\n      dp[S]-=pp;\n    }\n  }\n  printf(\"%.10f\\n\", dp[(1<<n)-1]);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint main(){\n  int N, M, P;\n  while(cin >> N >> M >> P){\n    vector<int> start(N);\n    vector<int> goal(N);\n    REP(i, N) start[i] = i;\n    REP(i, N) goal[i] = 0;\n    map< vector<int>, double > dp;\n    dp[start] = 1.0;\n    REP(i, M){\n      int u, v; cin >> u >> v;\n      u--; v--;\n      if(u > v) swap(u, v);\n      map< vector<int>, double > next_dp;\n      FORIT(it, dp){\n        vector<int> tr = it->first;\n        next_dp[tr] += it->second * P / 100.0;\n        int F = tr[v];\n        for(int i = 0; i < N; i++)if(tr[i] == F) tr[i] = tr[u];\n        next_dp[tr] += it->second * (100.0 - P) / 100.0;\n      }\n      /*\n      FORIT(it, next_dp){\n        printf(\"%.6lf : \", it->second);\n        debug(it->first.begin(), it->first.end());\n      }\n      cout << endl;\n      */\n      dp = next_dp;\n    }\n    printf(\"%.16lf\\n\", dp[goal]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\ntemplate <unsigned T>\nbool prevSubset(bitset<T>& bs, const bitset<T>& mask)\n{\n    if(bs.none())\n        return false;\n    bs = bs.to_ulong() - 1ull;\n    bs &= mask;\n    return true;\n}\n\nint main()\n{\n    int n, m, p;\n    cin >> n >> m >> p;\n\n    vector<vector<int> > edge(n, vector<int>(n, 0));\n    for(int i=0; i<m; ++i){\n        int u, v;\n        cin >> u >> v;\n        -- u;\n        -- v;\n        ++ edge[u][v];\n        ++ edge[v][u];\n    }\n\n    // 頂点0と連結な頂点をビットで保持\n    vector<double> dp(1<<n, 1.0);\n\n    for(int i=0; i<(1<<n); ++i){\n        bitset<14> bs(i);\n        if(!bs[0])\n            continue;\n\n        bitset<14> bs1 = bs;\n        while(prevSubset(bs1, bs)){\n            if(!bs1[0])\n                continue;\n\n            bitset<14> bs2 = bs ^ bs1;\n            int e = 0;\n            for(int j=0; j<n; ++j){\n                for(int k=0; k<n; ++k){\n                    if(bs1[j] && bs2[k])\n                        e += edge[j][k];\n                }\n            }\n\n            dp[i] -= dp[bs1.to_ulong()] * pow(p / 100.0, e);\n        }\n    }\n\n    printf(\"%.10f\\n\", dp[(1<<n)-1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m; vector<int>edge[15];\ndouble dp[(1<<14)],p;\nint main(){\n\tcin >> n >> m >> p; p/=100.;\n\tfor(int i=0;i<m;i++){\n\t\tint a,b; cin >> a >> b; a--; b--;\n\t\tedge[a].push_back(b);\n\t\tedge[b].push_back(a);\n\t}\n\tfor(int i=0;i<n;i++) dp[(1<<i)] = 1.0;\n\tfor(int i=1;i<(1<<n);i+=2){\n\t\tif(__builtin_popcount(i) <= 1) continue;\n\t\tfor(int j=i;j>=0;j--){\n\t\t\tj&=i;\n\t\t\tif(j==i||j%2==0) continue;\n\t\t\tdouble add = 1.0;\n\t\t\tfor(int x=0;x<n;x++){\n\t\t\t\tif(!((j>>x)&1)) continue;\n\t\t\t\tfor(int y=0;y<edge[x].size();y++){\n\t\t\t\t\tif(!((i>>edge[x][y])&1)) continue;\n\t\t\t\t\tif(((j>>edge[x][y])&1)) continue;\n\t\t\t\t\tadd *= p;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i] += dp[j]*add;\n\t\t}\n\t\tdp[i] = 1.0-dp[i];\n\t}\n\tprintf(\"%.12f\\n\",dp[(1<<n)-1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint V,E;\ndouble P,Q;\nvector<int> G[15];\n \n \nvoid printbit(int S){\n  for(int i=0;i<V;i++){\n    cout<<(S>>i&1)<<' ';\n  }\n  cout<<endl;\n}\n \ndouble func(int S,int U){\n \n  double res=1;\n  for(int i=0;i<V;i++){\n    if(S>>i&1){\n      for(int j=0;j<(int)G[i].size();j++){\n        int w=G[i][j];\n        if(S>>w&1)continue;\n        if(U>>w&1)        res*=P;\n      }\n    }\n  }\n \n \n \n  return res;\n}\n \ndouble dp[(1<<14)];\n \ndouble rec(int S){\n \n  if(dp[S]!=-1)return dp[S];\n  if(S==1)return 1.0;\n \n  double res=0;\n  int sup=S;\n  int sub=sup;\n  \n \n  do{\n    if(sub&1){\n      if(sub!=S){\n        double A=rec(sub);\n        double B=func(sub,S);\n        res+=A*B;\n      }\n    }\n    sub=(sub-1)⊃\n  }while(sub!=sup);\n \n  res=1.0-res;\n \n  return dp[S]=res;\n}\n \nvoid init(){\n  for(int i=0;i<15;i++)G[i].clear();\n  for(int i=0;i<(1<<14);i++){\n    dp[i]=-1;\n  }\n}\n \n \nbool check(){\n  bool visited[15]={};\n  visited[0]=true;\n  queue<int> que;\n  que.push(0);\n \n  while(!que.empty()){\n    int pos=que.front();que.pop();\n    for(int i=0;i<(int)G[pos].size();i++){\n      int w=G[pos][i];\n      if(visited[w])continue;\n      visited[w]=true;\n      que.push(w);\n    }\n  }\n \n  for(int i=0;i<V;i++)\n    if(!visited[i])return false;\n \n  return true;\n}\n \nint main(){\n  while(cin>>V>>E>>P){\n    init();\n    P/=100.0;\n    Q=1.0-P;\n    for(int i=0;i<E;i++){\n      int a,b;\n      cin>>a>>b;\n      a--;b--;\n      G[a].push_back(b);\n      G[b].push_back(a);\n    }\n \n    if(!check()){\n      printf(\"0.0\\n\");\n      continue;\n    }\n    printf(\"%.10f\\n\",rec((1<<V)-1));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\nint N,M,Pe;\ndouble p;\nvector<P> edges;\nint num[1<<15];\ndouble dp[1<<15];\ndouble pow(int x)\n{\n\tdouble res = 1.0;\n\tdouble r = p;\n\twhile(x)\n\t{\n\t\tif(x&1)res*=r;\n\t\tr=r*r;\n\t\tx>>=1;\n\t}\n\treturn res;\n}\ndouble rec(int S)\n{\n\tif(dp[S]!=-1.0)return dp[S];\n\tif(S==0)return 0.0;\n\tdouble ret = 1.0;\n\tvector<int> v;\n\tfor(int i=0;i<N;i++)if(S&(1<<i))v.pb(i);\n\tint sz = v.size();\n\tfor(int i=1;i<(1<<sz);i++)\n\t{\n\t\tint T = S;\n\t\tfor(int j=0;j<sz;j++)if(i&(1<<j))T-=(1<<v[j]);\n\t\tif(!(T&1))continue;\n\t\tret -= rec(T)*pow((num[T]+num[S^T]-num[((1<<N)-1)^S])/2);\n\t\t//if(S==(1<<N)-1)cout << T << endl;\n\t}\n\treturn dp[S]=ret;\n}\nint main()\n{\n\tscanf(\"%d %d %d\",&N,&M,&Pe);\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d %d\",&u,&v);\n\t\tu--;v--;\n\t\tedges.pb(P(u,v));\n\t}\n\tfor(int i=0;i<(1<<N);i++)\n\t{\n\t\tfor(int j=0;j<M;j++)\n\t\t{\n\t\t\tint u = edges[j].fi;\n\t\t\tint v = edges[j].sec;\n\t\t\tif(i&(1<<u) && !(i&(1<<v)))num[i]++;\n\t\t\tif(i&(1<<v) && !(i&(1<<u)))num[i]++;\n\t\t}\n\t}\n\tp = Pe/100.0;\n\tfor(int i=0;i<(1<<N);i++)dp[i]=-1.0;\n\t//for(int i=1;i<(1<<N);i++)printf(\"%.12f\\n\",rec(i));\n\tprintf(\"%.12f\\n\",rec((1<<N)-1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nint N,M,a[100],b[100];\ndouble p,dp[1<<14];\nint main(){\n\tcin>>N>>M>>p;\n\tp/=100;\n\trep(i,M) cin>>a[i]>>b[i],a[i]--,b[i]--;\n\trep1(i,(1<<N)-1){\n\t\tdp[i]=1;\n\t\tint s=i&-i;\n\t\tint c=i-s;\n\t\twhile(c>0){\n\t\t\tc=(c-1)&(i-s);\n\t\t\tint x=c+s;\n\t\t\tdouble d=dp[x];\n\t\t\trep(j,M){\n\t\t\t\tif( ((x>>a[j])&1) && !((x>>b[j])&1) && ((i>>b[j])&1) ) d*=p;\n\t\t\t\tif( ((x>>b[j])&1) && !((x>>a[j])&1) && ((i>>a[j])&1) ) d*=p;\n\t\t\t}\n\t\t\tdp[i]-=d;\n\t\t}\n\t}\n\tprintf(\"%.12f\\n\",dp[(1<<N)-1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint N,M;\ndouble P;\nint u[111],v[111];\ndouble dp[1<<14];\n\nstruct timer{\n\ttime_t start;\n\ttimer(){\n\t\tstart=clock();\n\t}\n\t~timer(){\n\t\tcout<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;\n\t}\n};\n\nint main(){\n\t\n#ifndef ONLINE_JUDGE\n\ttimer TIMER;\n#endif\n\t\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>N>>M>>P;\n\tP/=100;\n\trep(i,M)cin>>u[i]>>v[i],u[i]--,v[i]--;\n\t\n\trep2(mask,1,1<<N){\n\t\t\n\t\tif(__builtin_popcount(mask)==1){\n\t\t\tdp[mask]=1;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tdp[mask]=1;\n\t\tint par=N-1;\n\t\twhile(!(mask>>par&1))par--;\n\t\tint sub=mask,e;\n\t\t\n\t\twhile(1){\n\t\t\tsub=(sub-1)&mask;\n\t\t\te=0;\n\t\t\trep(i,M){\n\t\t\t\tif((mask>>v[i]&1) && (mask>>u[i]&1) && (sub>>u[i]&1)^(sub>>v[i]&1))e++;\n\t\t\t}\n\t\t\t//cout<<mask<<\" - \"<<dp[sub]<<\" * \"<<pow(P,e)<<endl;\n\t\t\tdp[mask]-=dp[sub]*pow(P,e);\n\t\t\tif(sub==(1<<par))break;\n\t\t}\n\t\t\n\t\t//cout<<mask<<\" \"<<dp[mask]<<endl;\n\t}\n\t//cout<<setprecision(16)<<dp[(1<<N)-1]<<endl;\n\tprintf(\"%.16f\\n\",dp[(1<<N)-1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n#define bit(x) (1<<(x))\nusing namespace std;\n\nint n,m,p;\nint a[15][15];\n\nusing R=long double;\nR dp[1<<14];\n\nint main(void){\n\tcin >> n >> m >> p;\n\trep(i,m){\n\t\tint u,v;\n\t\tcin >> u >> v;\n\t\ta[u-1][v-1]++;\n\t\ta[v-1][u-1]++;\n\t}\n\n\trep(mask,1,1<<n){\n\t\tdp[mask]=1.0;\t\t\n\t\tif(__builtin_popcount(mask)==1) continue;\n\t\tint limit=bit(31-__builtin_clz(mask));\n\t\tfor(int add=(mask-1)&mask;add>=1;add=(add-1)&mask){\n\t\t\tint root=add^mask;\n\t\t\tif(add<root) break;\n\t\t\tdouble cur=dp[add];\n\t\t\trep(i,n)rep(j,n) if(root&bit(i)) if(add&bit(j)) rep(loop,a[i][j]) cur*=1.0*p/100.0; \n\t\t\tdp[mask]-=cur;\t\n\t\t}\n\t}\n\n\tcout.precision(20);\n\tcout << fixed << dp[bit(n)-1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <bitset>\nusing namespace std;\n\nint N, M, P, adj[20][20], fullbit;\n\n// dp[S] := S が連結になる確率\ndouble prob, dp[1 << 15], sum = 0;\n\ndouble rec(int bit) {\n    double &res = dp[bit];\n    if(res >= 0) return res;\n    \n    int LSB = bit & (-bit);\n    res = 0;\n    for(int A=bit; A>0; A=(A-1)&bit) {\n        int B = bit - A;\n        if(A == 0 || B == 0 || !(A & LSB)) continue;\n        int edges = 0;\n        for(int i=0; i<N; i++) {\n            for(int j=0; j<N; j++) {\n                if( (A >> i & 1) && (B >> j & 1) ) edges += adj[i][j];\n            }\n        }\n        res += rec(A) * pow(prob, edges);\n    }\n    return res = 1 - res;\n}\n\nint main() {\n    cin >> N >> M >> P;\n    prob = 1.0 * P / 100;\n    for(int i=0; i<M; i++) {\n        int u, v; cin >> u >> v;\n        u--; v--;\n        adj[u][v]++;\n        adj[v][u]++;\n    }\n\n    fullbit = (1 << N) - 1;\n    fill(dp, dp + fullbit + 1, -1);\n    cout << fixed << setprecision(12) << rec(fullbit) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <bitset>\nusing namespace std;\n\nclass UnionFindTree{\n\ttypedef struct {\n\t\tint parent;\n\t\tint rank;\n\t}base_node;\n\t\n\tvector<base_node> node;\npublic:\n\tUnionFindTree(int n){\n\t\tnode.resize(n);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tnode[i].parent=i;\n\t\t\tnode[i].rank=0;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(node[x].parent == x) return x;\n\t\telse{\n\t\t\treturn node[x].parent = find(node[x].parent);\n\t\t}\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(node[x].parent);\n\t\ty = find(node[y].parent);\n\t\tif(x==y) return;\n\t\tif(node[x].rank < node[y].rank){\n\t\t\tnode[x].parent = y;\n\t\t}else if(node[x].rank > node[y].rank){\n\t\t\tnode[y].parent = x;\n\t\t}else{\n\t\t\tnode[x].rank++;\n\t\t\tunite(x,y);\n\t\t}\n\t}\n};\n\nint main_(){\n\tint n,m,p;\n\tcin >> n >> m >> p;\n\n\tUnionFindTree uft(n);\n\n\tvector<int> u(m),v(m);\n\tvector<int> e(m);\n\tvector<vector<int>> g(n);\n\t//vector<int> g(n);\n\tfor(int i=0; i<m; i++){\n\t\tcin >> u[i] >> v[i];\n\t\tu[i]--; v[i]--;\n\t\t//g[u[i]] |= 1<<v[i];\n\t\t//g[v[i]] |= 1<<u[i];\n\t\tg[u[i]].push_back(v[i]);\n\t\tg[v[i]].push_back(u[i]);\n\t\t//e[i] = (1<<u[i]) | (1<<v[i]);\n\t\tuft.unite(u[i], v[i]);\n\t}\n\tbool connected = true;\n\tfor(int i=1; i<n; i++){\n\t\tconnected = connected && uft.same(0,i);\n\t}\n\tif(connected == false){\n\t\tprintf(\"0.000000000000000000\\n\");\n\t\treturn 0;\n\t}\n/*\n\tvector<int> edge_cnt(1<<n, 0);\n\tfor(int i=0; i<(1<<n); i++){\n\t\tfor(int j=0; j<m; j++){\n\t\t\tif((i>>u[j])&(i>>v[j])&1){\n\t\t\t\tedge_cnt[i]++;\n\t\t\t}\n\t\t}\n\t}\n*/\n\tvector<double> prob(1<<n, -1);\n\tprob[1] = 1;\n\n\tfunction<double(int)> dfs = [&](int s){\n\t\tif(prob[s] != -1) return prob[s];\n\t\tdouble res = 1.0;\n\t\tint s_ = s-1;\n\t\tfor(int x=s_; x>=0; x=(x-1)&s_){\n\t\t\tint y = x|1;\n\t\t\tif(y==s) continue;\n\t\t\tdouble q = dfs(y);\n\t\t\tdouble tmp = 1.0;\n\t\t\t\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tif( (((1<<u[i])&y) && ((1<<v[i])&(s^y))) or (((1<<v[i])&y) and ((1<<u[i])&(s^y))) ){\n\t\t\t\t\ttmp *= 0.01 * p;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//tmp = pow(0.01*p, edge_cnt[s] - edge_cnt[y] - edge_cnt[s^y]);\n\n\t\t\tres -= q * tmp;\n\n\t\t\tif(x==0) break;\n\t\t}\n\t\treturn prob[s] = res;\n\t};\n\n\tdouble ans = dfs((1<<n)-1);\n\tprintf(\"%.18f\\n\", ans);\n\treturn 0;\n}\n\n\nint main(){\n\tauto start = clock();\n\tmain_();\n\t//cerr << clock()-start << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n\nint main(){\n    int n,m;\n    double p;\n    cin >>n >>m >>p;\n\n    vector<int> u(m),v(m);\n    rep(i,m){\n        cin >>u[i] >>v[i];\n        --u[i];\n        --v[i];\n    }\n\n    p /= 100.0;\n\n    vector<double> pw(m+1);\n    pw[0] = 1;\n    rep(i,m) pw[i+1] = pw[i]*p;\n\n    vector<double> dp(1<<n);\n    rep(mask,1<<n){\n        dp[mask] = 1;\n\n        int sub = mask;\n        while(1){\n            sub = (sub-1)&mask;\n            if(sub == 0) break;\n            if(sub%2!=1) continue;\n\n            int o_mask = mask^sub;\n\n            int ct = 0;\n            rep(i,m){\n                if(sub>>u[i]&1){\n                    if(o_mask>>v[i]&1) ++ct;\n                }\n                if(sub>>v[i]&1){\n                    if(o_mask>>u[i]&1) ++ct;\n                }\n            }\n\n            dp[mask] -= dp[sub]*pw[ct];\n        }\n    }\n\n    cout << setprecision(15) << dp[(1<<n)-1] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\nint main()\n{\n  int N, M;\n  double P;\n  int g[14][14] = {{}};\n  double dp[1 << 14] = {};\n\n  cin >> N >> M >> P;\n  P /= 100.0;\n  for(int i = 0; i < M; i++) {\n    int a, b;\n    cin >> a >> b;\n    ++g[--a][--b];\n    ++g[b][a];\n  }\n\n  for(int i = 1; i < 1 << N; i++) {\n    dp[i] = 1.0;\n    if(__builtin_popcount(i) == 1) continue;\n    for(int latte = (i - 1) & i; latte >= 1; latte = (latte - 1) & i) {\n      int malta = i ^latte;\n      if(latte < malta) continue;\n      double ret = dp[latte];\n      for(int j = 0; j < N; j++) {\n        for(int k = 0; k < N; k++) {\n          if((latte >> j) & 1 && (malta >> k) & 1) {\n            for(int l = 0; l < g[j][k]; l++) ret *= P;\n          }\n        }\n      }\n      dp[i] -= ret;\n    }\n  }\n  cout << fixed << setprecision(10) << dp[(1 << N) - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define FOREACH(i, c) for(auto i = (c).begin(); i != (c).end(); ++i)\n#define BIT(n, m) (((n) >> (m)) & 1)\n\ntypedef long long ll;\ntypedef pair<int, int> PI;\n\nconst ll inf = 1e15;\nconst ll mod = 1000 * 1000 * 1000 + 7;\nconst double eps = 1e-9;\n\ntemplate <typename S, typename T> ostream &operator<<(ostream &out, const pair<S, T> &p) {\n  out << \"(\" << p.first << \", \" << p.second << \")\";\n  return out;\n}\n\ntemplate <typename T> ostream &operator<<(ostream &out, const vector<T> &v) {\n  out << \"[\";\n  REP(i, v.size()){\n    if (i > 0) out << \", \";\n    out << v[i];\n  }\n  out << \"]\";\n  return out;\n}\n\ndouble memo[1 << 20];\ndouble prob;\ndouble rec(int mask, const vector<vector<int> > &G){\n  if (mask == 0){\n    return 1;\n  } else if (memo[mask] > -eps){\n    return memo[mask];\n  } else {\n    double &res = memo[mask] = 1.0;\n    for (int submask = mask; submask > 0;){\n      submask = (submask - 1) & mask;\n      double p = 1.0;\n      // cout << submask << \" \" << mask << endl;\n      REP(i, G.size()) if ((submask & (1 << i)) || i + 1 == int(G.size())){\n        REP(j, G.size()) if ((mask ^ submask) & (1 << j)){\n          if (G[i][j]) p *= prob;\n          // cout <<\"POYO: \" <<  i << \" \" << j << \" \" << mask << \" \" << submask << endl;\n        }\n      }\n      // cout << mask << \" \"<< submask << \" \" << p << \" \" << rec(submask, G) << \" \" << endl;\n      // cout << p << endl;\n      res -= p * rec(submask, G);\n      // cout << res << endl;\n    }\n    // cout << mask << \" \" << res << endl;\n    return res;\n  }\n}\n\n\nint main(){\n  int N, M;\n  double P;\n  while (cin >> N >> M >> P){\n    vector<vector<int> > G(N, vector<int>(N));\n    REP(i, M){\n      int a, b;\n      cin >> a >> b; a--, b--;\n      G[a][b] = G[b][a] = 1;\n    }\n    memset(memo, 0xff, sizeof(memo));\n    prob = P * 0.01;\n    cout << fixed << setprecision(20) << rec((1 << (N - 1)) - 1, G) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nsigned main(){\n  int n,m,p;\n  cin>>n>>m>>p;\n  double dp2[101];\n  dp2[0]=1.0;\n  for(int i=1;i<101;i++) dp2[i]=dp2[i-1]*(p/100.0);\n  int e[15][15]={};\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin>>a>>b;\n    a--;b--;\n    e[a][b]++;\n    e[b][a]++;\n  }\n  double dp[1<<15]={};\n  int look[1<<15]={};\n  for(int i=0;i<(1<<n);i++){\n    look[i]=0;\n    for(int j=0;j<n;j++){\n      for(int k=0;k<j;k++){\n\tif((i>>j)&1 && (i>>k)&1){\n\t  //look[i]*=1.0-get(e[j][k]);\n\t  look[i]+=e[j][k];\n\t}\n      }\n    }\n    //look[i]=1.0-look[i];\n    //cout<<i<<\":\"<<look[i]<<endl;\n  }\n  int used[1<<15]={};\n  function<double(int)> dfs=[&](int b){\n    //cout<<b<<\" \"<<used[b]<<\" \"<<dp[b]<<endl;\n    if(used[b]) return dp[b];\n    used[b]=1;\n    if(b==0) return 0.0;\n    double res=1;\n    //double res=look[b];\n    for(int i=b;i>0;i=(i-1)&b){\n      if((i^b)&1){\n\t//cout<<(i^b)<<\":\"<<dfs(i^b)*look[i^b]<<endl;\n\tres-=dfs(i^b)*dp2[look[b]-(look[i]+look[i^b])];\n      }\n    }\n    //cout<<b<<\" \"<<res<<endl;\n    return dp[b]=res;\n  };\n  cout<<fixed<<setprecision(12)<<dfs((1<<n)-1)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <iomanip>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\ndouble dp[1<<15];\n\nint main(){\n\tint n,m;\n\tdouble p;\n\tcin >> n >> m >> p;\n\tvector<pair<int,int> >g;\n\tp /=100.0;\n\tfor(int i=0;i<m;i++){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\ta--;\n\t\tb--;\n\t\tg.PB(MP(a,b));\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tdp[1<<i]=1.0;\n\t}\n\tfor(int i=1;i<(1<<n);i++){\n\t\tdp[i]=1.0;\n\t\tfor(int S=(1<<n)-1;S>=0;S--){\n\t\t\tdouble tmp = 1.0;\n\t\t\tS &= i;\n\t\t\tint T = i-S;\n\t\t\tif(S<T)break;\n\t\t\tif(S==0||T==0)continue;\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tif(S>>g[j].first&1&&T>>g[j].second&1){\n\t\t\t\t\ttmp*=p;\n\t\t\t\t}\n\t\t\t\tif(T>>g[j].first&1&&S>>g[j].second&1){\n\t\t\t\t\ttmp*=p;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i] -= dp[S]*tmp;\n\t\t}\n\t}\n\tcout << fixed << setprecision(20) << dp[(1<<n)-1] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 14;\n\nint sm[(1 << MAX_N)];\ndouble dp[(1 << MAX_N)];\ndouble pp[101];\n\nint main()\n{\n    int n,m,p;\n    scanf(\"%d%d%d\",&n,&m,&p);\n    pp[0] = 1;\n    vp edge(m);\n    rep(i,m){\n        pp[i+1] = pp[i] * (p / 100.0);\n        scanf(\"%d%d\",&edge[i].fi,&edge[i].se);\n    }\n    rep(i,(1 << n)){\n        int res = 0;\n        rep(j,m){\n            int u = edge[j].fi - 1,v = edge[j].se - 1;\n            if((i >> u) & (i >> v) & 1){\n                res++;\n            }\n        }\n        sm[i] = res;\n    }\n    rep(S,(1 << n)){\n        if(!(S & 1)){\n            continue;\n        }\n        double res = 0;\n        for(int T=S;T>0;T=(T-1)&S){\n            res += dp[T]*pp[sm[S]-sm[T]-sm[S^T]];\n        }\n        dp[S] = 1.0 - res;\n    }\n    printf(\"%.12lf\\n\",dp[(1 << n)-1]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\ndouble dp[1<<15];\n\nint main(){\n\tint n,m;\n\tdouble p;\n\tcin >> n >> m >> p;\n\tvector<pair<int,int> >g;\n\tp /=100.0;\n\tfor(int i=0;i<m;i++){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\ta--;\n\t\tb--;\n\t\tg.PB(MP(a,b));\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tdp[1<<i]=1.0;\n\t}\n\tfor(int i=1;i<(1<<n);i++){\n\t\tdp[i]=1.0;\n\t\tfor(int S=(1<<n)-1;S>=0;S--){\n\t\t\tdouble tmp = 1.0;\n\t\t\tS &= i;\n\t\t\tint T = i-S;\n\t\t\tif(S<T)break;\n\t\t\tif(S==0||T==0)continue;\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tif(S>>g[j].first&1&&T>>g[j].second&1){\n\t\t\t\t\ttmp*=p;\n\t\t\t\t}\n\t\t\t\tif(T>>g[j].first&1&&S>>g[j].second&1){\n\t\t\t\t\ttmp*=p;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i] -= dp[S]*tmp;\n\t\t}\n\t}\n\tcout.precision(10);\n\tcout << dp[(1<<n)-1] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\nint main()\n{\n  int N, M;\n  double P;\n  int g[14][14] = {{}};\n  double dp[1 << 14] = {};\n\n  cin >> N >> M >> P;\n  P /= 100.0;\n  for(int i = 0; i < M; i++) {\n    int a, b;\n    cin >> a >> b;\n    ++g[--a][--b];\n    ++g[b][a];\n  }\n\n  double mat[14][14];\n  for(int i = 0; i < N; i++) {\n    for(int j = 0; j < N; j++) {\n      mat[i][j] = 1.0;\n      for(int k = 0; k < g[i][j]; k++) mat[i][j] *= P;\n    }\n  }\n  for(int i = 1; i < 1 << N; i++) {\n    dp[i] = 1.0;\n    for(int latte = (i - 1) & i; latte >= 1; latte = (latte - 1) & i) {\n      int malta = i ^latte;\n      if(latte < malta) break;\n      double ret = dp[latte];\n      for(int j = 0; j < N; j++) {\n        if(~(latte >> j) & 1) continue;\n        for(int k = 0; k < N; k++) {\n          if((malta >> k) & 1) ret *= mat[j][k];\n        }\n      }\n      dp[i] -= ret;\n    }\n  }\n  cout << fixed << setprecision(10) << dp[(1 << N) - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\nusing namespace std;\n\nint n,m,p;\nbool a[15][15];\n\ndouble dp[1<<14];\ndouble tmp[1<<14];\n\nint main(void){\n\tcin >> n >> m >> p;\n\trep(i,m){\n\t\tint u,v;\n\t\tcin >> u >> v;\n\t\ta[u-1][v-1]=a[v-1][u-1]=true;\n\t}\n\n\trep(i,n){\n\t\trep(mask,1<<i) tmp[mask]=0.0;\n\t\trep(mask,1<<i){\n\t\t\tdouble cur=1.0;\n\t\t\trep(j,i) if((mask&(1<<j))&&a[j][i]) cur*=1.0*p/100.0; \n\t\t\ttmp[mask]=(1.0-cur)*dp[mask];\n\t\t}\n\t\t\n\t\tcerr << i << endl;\n\t\t// rep(mask,1<<i) cerr << mask << \" \" << tmp[mask] << endl;\n\n\t\trep(mask,1<<i){\n\t\t\tfor(int smask=(mask-1)&mask;smask>0;smask=(smask-1)&mask){\n\t\t\t\tint tmask=mask^smask;\n\t\t\t\tif(tmask>smask) break;\n\t\t\t\tdouble cur=1.0;\n\t\t\t\trep(j,i)rep(k,i) if((smask&(1<<j))&&(tmask&(1<<k))&&a[j][k]) cur*=1.0*p/100.0;\n\t\t\t\ttmp[mask]+=cur*tmp[smask]*tmp[tmask];\n\t\t\t}\n\t\t}\n\t\ttmp[0]=1.0;\n\t\trep(mask,1<<i) dp[mask|(1<<i)]=tmp[mask];\n\t}\n\tcout.precision(20);\n\tcout << fixed << dp[(1<<n)-1] << endl;\n\n\t// rep(i,1<<n) cerr << i << \" \" << dp[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define double long double\n#define N 14\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nint G[N][N];\nint n;\ndouble p;\n \ndouble calc(int b,int c){\n  double res = 1;\n  for(int i=0;i<n;i++) \n    for(int j=i+1;j<n;j++)\n      if(((b>>i&1) && (c>>j&1) && G[i][j]) ||\n         ((b>>j&1) && (c>>i&1) && G[i][j])) res *= p;\n      return res;\n}\n \n \ndouble mem[1<<N],used[1<<N];\ndouble dfs(int bit){\n  if(bit == 0) return 0;\n  if((bit&-bit) == bit) return 1;\n  if(used[bit]++) return mem[bit];\n \n  double res = 1;\n  for(int i = (i-1)&bit;i > 0;i=(i-1)&bit){\n    if(i % 2 == 0) continue;\n    int j = bit ^ i;\n    double p = dfs(i);    \n    res -= p * calc(i,j); \n  } \n  return mem[bit] = res;\n}\n \n \nsigned main(){\n  int m;\n  cin>>n>>m>>p; p/=100;\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;\n    G[a-1][b-1] = G[b-1][a-1] = 1;\n  }\n   \n  printf(\"%.10Lf\\n\",dfs((1<<n)-1));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\ndouble dp[1<<14];\nint g[20][20];\nint main(){\n\tint a,b,c;scanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<b;i++){\n\t\tint p,q;scanf(\"%d%d\",&p,&q);p--;q--;\n\t\tg[p][q]=g[q][p]=1;\n\t}\n\tfor(int i=0;i<(1<<a);i++){\n\t\tdp[i]=1.0;\n\t\tif(i==0)continue;\n\t\tint at=0;\n\t\tfor(int j=0;j<a;j++)if(i&(1<<j)){at=j;continue;}\n\t\tfor(int j=i;j>=1;j=((j-1)&i)){\n\t\t\tif(j==i||!(j&(1<<at)))continue;\n\t\t\tdouble ks=dp[j];\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tif(!(j&(1<<k)))continue;\n\t\t\t\tfor(int l=0;l<a;l++){\n\t\t\t\t\tif(!(i&(1<<l))||(j&(1<<l)))continue;\n\t\t\t\t\tif(g[k][l])ks*=(double)c/100;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i]-=ks;\n\t\t}\n\t}\n\tprintf(\"%.12f\",dp[(1<<a)-1]);\n\tfor(int i=0;i<1000;i++)printf(\"%d\",rand()%1000000000);\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint V,E;\ndouble P,Q;\nvector<int> G[15];\n\n\nvoid printbit(int S){\n  for(int i=0;i<V;i++){\n    cout<<(S>>i&1)<<' ';\n  }\n  cout<<endl;\n}\n\ndouble func(int S,int U){\n\n  double res=1;\n  for(int i=0;i<V;i++){\n    if(S>>i&1){\n      for(int j=0;j<(int)G[i].size();j++){\n        int w=G[i][j];\n        if(S>>w&1)continue;\n        if(U>>w&1)        res*=P;\n      }\n    }\n  }\n\n\n\n  return res;\n}\n\ndouble dp[(1<<14)];\n\ndouble rec(int S){\n\n  if(dp[S]!=-1)return dp[S];\n  if(S==1)return 1.0;\n\n  double res=0;\n  int sup=S;\n  int sub=sup;\n \n\n  do{\n    if(sub&1){\n      if(sub!=S){\n        double A=rec(sub);\n        double B=func(sub,S);\n        res+=A*B;\n      }\n    }\n    sub=(sub-1)&sup;\n  }while(sub!=sup);\n\n  res=1.0-res;\n  /*\n        printbit(S);\n        cout<<res<<endl;\n  */\n\n  return dp[S]=res;\n}\n\nvoid init(){\n  for(int i=0;i<15;i++)G[i].clear();\n  for(int i=0;i<(1<<14);i++){\n    dp[i]=-1;\n  }\n}\n\n\nbool check(){\n  bool visited[15]={};\n  visited[0]=true;\n  queue<int> que;\n  que.push(0);\n\n  while(!que.empty()){\n    int pos=que.front();que.pop();\n    for(int i=0;i<(int)G[pos].size();i++){\n      int w=G[pos][i];\n      if(visited[w])continue;\n      visited[w]=true;\n      que.push(w);\n    }\n  }\n\n  for(int i=0;i<V;i++)\n    if(!visited[i])return false;\n\n  return true;\n}\n\nint main(){\n  while(cin>>V>>E>>P){\n    init();\n    P/=100.0;\n    Q=1.0-P;\n    for(int i=0;i<E;i++){\n      int a,b;\n      cin>>a>>b;\n      a--;b--;\n      G[a].push_back(b);\n      G[b].push_back(a);\n    }\n\n    if(!check()){\n      printf(\"0.0\\n\");\n      continue;\n    }\n    printf(\"%.8f\\n\",rec((1<<V)-1));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<iostream>\nusing namespace std;\nint n,m,p;\nint num[20000+10];\ndouble dp[20000+10];\nstruct E\n{\n\tint u,v;\n}e[100+10];\ndouble qpow(double d,int c)\n{\n\tif(c==0)return 1;\n\tif(c==1)return d;\n\tdouble ret=qpow(d,c/2);\n\tret=ret*ret;\n\tif(c&1)ret=ret*d;\n\treturn ret;\n}\nint main()\n{\n\twhile(scanf(\"%d%d%d\",&n,&m,&p)!=EOF)\n\t{\n\t\tmemset(num,0,sizeof(num));\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&e[i].u,&e[i].v);\n\t\t}\n\t\tfor(int i=1;i<(1<<n);i++)\n\t\t{\n\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t{\n\t\t\t\tif(i&(1<<(e[j].u-1))&&i&(1<<(e[j].v-1)))num[i]++;\n\t\t\t}\n\t\t}\n\t//\tfor(int i=1;i<=n;i++)dp[1<<(i-1)]=1;\n\t\tfor(int i=1;i<(1<<n);i++)\n\t\t{\n\t\t\tfor(int j=i&(i-1);j;j=i&(j-1))\n\t\t\t{\n\t\t\t\tif(j&(i&(-i)))\n\t\t\t\tdp[i]+=(1-dp[j])*qpow(p*1.0/100,num[i]-num[j]-num[i&(~j)]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.12f\\n\",1-dp[(1<<n)-1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (1e+18) + 7;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\n//typedef vector<vector<ll>> mat;\ntypedef vector<int> vec;\n\nll mod_pow(ll a, ll n) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%mod;\n\t\ta = a * a%mod; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\n//const int max_n = 1 << 22;\n//modint fact[max_n], factinv[max_n];\n//void init_f() {\n//\tfact[0] = modint(1);\n//\tfor (int i = 0; i < max_n - 1; i++) {\n//\t\tfact[i + 1] = fact[i] * modint(i + 1);\n//\t}\n//\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n//\tfor (int i = max_n - 2; i >= 0; i--) {\n//\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n//\t}\n//}\n//modint comb(int a, int b) {\n//\tif (a < 0 || b < 0 || a < b)return 0;\n//\treturn fact[a] * factinv[b] * factinv[a - b];\n//}\n\nint num[14][14];\nint n, m; ld p;\n\nld dp[1 << 14];\n\nld pro[101];\nint cnt[14][1 << 14];\nvoid solve() {\n\tcin >> n >> m >> p; p /= 100.0;\n\trep(i, 101) {\n\t\tpro[i] = 1;\n\t\trep(j, i)pro[i] *= p;\n\t}\n\trep(i, m) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tnum[a][b]++;\n\t\tnum[b][a]++;\n\t}\n\trep(i, n) {\n\t\trep(j, (1 << n)) {\n\t\t\trep(k, n)if (j&(1 << k))cnt[i][j] += num[i][k];\n\t\t}\n\t}\n\tdp[1] = 1;\n\trep1(i, n-1) {\n\t\tvector<ld> cdp(1 << i,0);\n\t\tcdp[0] = 1;\n\t\trep1(j, (1 << i)-1) {\n\t\t\tvector<int> b;\n\t\t\tint le = 0;\n\t\t\tper(k, i) {\n\t\t\t\tif ((j&(1 << k)) == 0)b.push_back(k);\n\t\t\t\telse le = k;\n\t\t\t}\n\t\t\tint len = b.size();\n\t\t\trep(x, (1 << len)) {\n\t\t\t\tint le2 = 0;\n\t\t\t\tint pre = 0;\n\t\t\t\tper(y, len) {\n\t\t\t\t\tif (x&(1 << y)) {\n\t\t\t\t\t\tle2 = b[y]; pre |= (1 << b[y]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//if (le2 <= le) {\n\t\t\t\t\tint sum = 0;\n\t\t\t\t\trep(y, len)if (x&(1 << y))sum += cnt[b[y]][j];\n\t\t\t\t\tcdp[pre | j] += cdp[pre] * dp[j] * pro[sum] * (1 - pro[cnt[i][j]]);\n\t\t\t\t//}\n\t\t\t}\n\t\t}\n\t\trep(j, (1 << i)) {\n\t\t\tdp[j ^ (1 << i)] = cdp[j];\n\t\t}\n\t}\n\tcout << dp[(1 << n) - 1] << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(12);\n\t//init_f();\n\t//int t; cin >> t; rep(i, t)solve();\n\t//while (cin >>n>>m>>s>>t, n)solve();\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>  \n#include<cstdio>  \n#include<cstdlib>  \n#include<cstring>  \n#include<ctime>  \n#include<cmath>  \n#include<algorithm>  \n#include<queue>  \n#include<string>  \n#include<set>  \n#include<map>  \n#include<stack>  \n  \nusing namespace std;  \nconst int inf=0x3fffffff;  \nconst double eps=1e-6;  \ntypedef long long ll;  \n  \nstruct node{  \n    int s,e;  \n    double w;  \n}rec[1000];  \nint n,m;  \ndouble dp[1<<18];  \ndouble dfs(int c){  \n    if(dp[c]>=0) return dp[c];  \n    dp[c]=0;  \n    int num=0,j,a,b,tt,i,pos,state,cur;  \n    double temp;  \n    for(i=0;i<n;i++){  \n        if(c&(1<<i)) pos=i,num++;  \n    }  \n    if(num==1) return dp[c]=1;  \n    state=c-(1<<pos);  \n    for(j=(state-1)&state;;j=(j-1)&state){  \n        cur=j+(1<<pos);  \n        tt=c-cur;  \n        temp=1;  \n        for(i=1;i<=m;i++){  \n            a=rec[i].s,b=rec[i].e;  \n            if((cur&(1<<a))&&(tt&(1<<b))) temp*=rec[i].w;  \n            if((cur&(1<<b))&&(tt&(1<<a))) temp*=rec[i].w;  \n        }  \n        dp[c]+=temp*dfs(cur);  \n        if(j==0) break;  \n    }  \n    return dp[c]=1-dp[c];  \n}  \nint main(){  \n    int t,i,S; \n\tdouble p; \n    t=1;\n    while(t--){  \n        scanf(\"%d%d%lf\",&n,&m,&p);  \n        for(i=1;i<=m;i++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&rec[i].s,&rec[i].e),rec[i].s--,rec[i].e--; \n\t\t\trec[i].w=p/100;\n\t\t}\n        S=1<<n;  \n        for(i=0;i<S;i++) dp[i]=-1;  \n        printf(\"%.13lf\\n\",dfs(S-1));  \n    }  \n    return 0;  \n}  "
  },
  {
    "language": "C++",
    "code": "\nn, m, q = gets.split.map(&:to_i)\n\nprob = {}\n(1..m).each do\n    i, j = gets.split.map(&:to_i) \n    (prob[i] ||= Hash.new(1.0))[j] = q / 100.0\n    (prob[j] ||= Hash.new(1.0))[i] = q / 100.0\nend\n\nrequire 'set'\n\ndef f(prob)\n    return 1.0 if prob.size == 1\n\n    if prob.size == 1 + prob.values.map(&:size).inject(:+) / 2\n        return prob.keys.combination(2).map {|i, j| prob[i].key?(j) ? 1 - prob[i][j] : 1}.inject(:*)\n    end\n\n    i = prob.keys.min_by{|i| prob[i].size}\n    j = prob[i].keys.min_by{|j| prob[j].size}\n\n    new_prob = {}\n    prob.each {|k, h| new_prob[k] = h.dup}\n    new_prob[i].delete(j)\n    new_prob[j].delete(i)\n\n    \n    reached = disconnected?(new_prob)\n    if reached\n        g1 = {}\n        new_prob.each {|k, h| g1[k] = new_prob[k].dup if reached.include?(k)}\n        g2 = {}\n        new_prob.each {|k, h| g2[k] = new_prob[k].dup if !reached.include?(k)}\n        return (1.0 - prob[i][j]) * f(g1) * f(g2)\n    else\n        return prob[i][j] * f(new_prob) + (1.0 - prob[i][j]) * f(contract(prob, i, j))\n    end\nend\n\ndef contract(prob, i, j)\n    new_prob = {}\n    new_prob[j] = prob[j].dup\n    new_prob[j].delete(i)\n    prob.each do |k, h|\n        next if k == i or k == j\n        new_prob[k] = h.dup\n        q = h[i]\n        new_prob[k].delete(i)\n        new_prob[k][j] *= q\n        new_prob[j][k] = new_prob[k][j]\n    end\n    new_prob\nend\n\nrequire 'set'\ndef disconnected?(prob)\n    i = prob.keys[0]\n    reached = Set[i]\n    queue = [i]\n    until queue.empty?\n        i = queue.shift\n        prob[i].each do |j, _|\n            next if reached.include?(j)\n            reached << j\n            queue << j\n        end\n    end\n    return reached.size == prob.size ? nil : reached\nend\n\nif disconnected?(prob)\n    puts '0'\nelse\n    printf(\"%.12f\\n\", f(prob))\nend\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nusing R = long double;\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    R p, q;\n    int n, m; cin >> n >> m >> p;\n    p /= 100.; q = 1 - p;\n\n    vi as(m), bs(m);\n    rep(i, m){\n        int a, b; cin >> a >> b; a--, b--;\n        as[i] = a, bs[i] = b;\n    }\n\n    vector<R> dp(1 << n, (R)0);\n\n    rep(sup, 1, 1 << n){\n        int l = 0;\n        while(not ((sup >> l) & 1)) l++;\n        \n        R& cur = dp[sup] = (R)1;\n        \n        for(int sub = ((sup - 1) & sup); sub != sup; sub = ((sub - 1) & sup)){\n            if(not ((sub >> l) & 1)) continue;\n\n            int subc = (~sub) & sup;\n            R diff = dp[sub];\n            rep(i, m){\n                int a = as[i], b = bs[i];\n                if((((sub >> a) & 1) and ((subc >> b) & 1)) or\n                   (((sub >> b) & 1) and ((subc >> a) & 1))){\n                    diff *= p;\n                }\n            }\n            cur -= diff;\n        }\n    }\n\n    cout.precision(20);\n    cout << fixed << dp.back() << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"cstring\"\n#include \"cstdio\"\n#include \"vector\"\n#define PB push_back\n#define MP make_pair\nusing namespace std;\ndouble p, q;\nconst int N = 15;\ndouble dp[N][1 << N];\nint vis[N][1 << N];\ndouble g[N][1 << N];\nint v[1 << N];\ndouble getdp(int x, int y);\ndouble gao(int x)\n{\n\tif(__builtin_popcount(x) == 0) return 1.0;\n\tint s = __builtin_ffs(x) - 1;\n\treturn getdp(s, x ^ (1 << s));\n}\ndouble qpow(double x, int y)\n{\n\tdouble ans = 1.0;\n\twhile(y != 0){\n\t\tif(y & 1) ans = ans * x;\n\t\tx = x * x;\n\t\ty >>= 1;\n\t}\n\treturn ans;\n}\ndouble getdp(int x, int state)\n{\n\tif(vis[x][state]) return dp[x][state];\n\tvis[x][state] = 1;\n\tif(state == 0) return dp[x][state] = 1.0;\n\tint f = __builtin_ffs(state) - 1;\n\tint s = state ^ (1 << f);\n\tdouble sum = 0.0;\n\tfor(int i = s; ; i = (i - 1) & s){\n\t\tint tmp = i ^ (1 << f);\n\t\tsum += getdp(x, tmp ^ state) * gao(tmp) * g[x][tmp] * qpow(q, v[state] - v[tmp] - v[state ^ tmp]);\n\t\tif(i == 0) break;\n\t}\n\treturn dp[x][state] = sum;\n}\nvector<int> edge[N];\n\nint main(void)\n{\n\tint n, m, val;\n\tscanf(\"%d %d %d\", &n, &m, &val);\n\tq = (double)val / 100.0;\n\tp = 1.0 - q;\n\tint x, y;\n\tfor(int i = 1; i <= m; ++ i){\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tx --;\n\t\ty --;\n\t\tedge[x].PB(y);\n\t\tedge[y].PB(x);\n\t}\n\tfor(int i = 1; i < (1 << n); ++ i){\n\t\tint k = __builtin_ffs(i) - 1;\n\t\tv[i] = v[i ^ (1 << k)];\n\t\tfor(int j = 0; j < edge[k].size(); ++ j){\n\t\t\tint u = edge[k][j];\n\t\t\tif(i & (1 << u)){\n\t\t\t\tv[i] ++;\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < n; ++ j){\t\n\t\t\tif(i & (1 << j)) continue;\n\t\t\tint sum = 0;\n\t\t\tfor(int k = 0; k < edge[j].size(); ++ k){\n\t\t\t\tint u = edge[j][k];\n\t\t\t\tif(i & (1 << u)){\n\t\t\t\t\tsum ++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tg[j][i] = 1.0 - qpow(q, sum);\n\t\t}\n\t}\n\tprintf(\"%.12f\\n\", gao((1 << n) - 1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const set<T>& a){\n\tos<<'{';\n\tfor(auto i=begin(a);i!=end(a);++i)\n\t\tos<<(i==begin(a)?\"\":\" \")<<*i;\n\treturn os<<'}';\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tdouble p; cin>>p; p*=0.01;\n\t\tvector<pii> es;\n\t\trep(i,m){\n\t\t\tint u,v; cin>>u>>v; u--,v--;\n\t\t\tes.emplace_back(u,v);\n\t\t}\n\t\t\n\t\tmap<set<int>,double> f1; // {連結成分} => 確率\n\t\t{\n\t\t\tset<int> tmp;\n\t\t\trep(i,n) tmp.insert(1<<i);\n\t\t\tf1[tmp]=1;\n\t\t}\n\t\t\n\t\tfor(auto e:es){\n\t\t\tint u,v; tie(u,v)=e;\n\t\t\tdecltype(f1) f2;\n\t\t\tfor(auto t:f1){\n\t\t\t\tset<int> cs=t.first;\n\t\t\t\tdouble cp=t.second;\n\t\t\t\tset<int> ns;\n\t\t\t\tint tmp=0;\n\t\t\t\tfor(auto s:cs){\n\t\t\t\t\tif((s>>u&1) || (s>>v&1))\n\t\t\t\t\t\ttmp|=s;\n\t\t\t\t\telse\n\t\t\t\t\t\tns.insert(s);\n\t\t\t\t}\n\t\t\t\tif(tmp) ns.insert(tmp);\n\t\t\t\t\n\t\t\t\tf2[ns]+=cp*(1-p);\n\t\t\t\tf2[cs]+=cp*p;\n\t\t\t}\n\t\t\tswap(f1,f2);\n\t\t}\n\t\t\n\t\tdouble res=0;\n\t\tfor(auto p:f1) if(p.first.size()==1) res=p.second;\n\t\tprintf(\"%.12f\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n#include <bitset>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n\n/**\n * hash???????????????UnionFind ????´???°???16????????????????????¨??????????????????\n */\ntemplate<int N>\nstruct SUnionFind {\n    int i2g[N];\n    SUnionFind() {\n        for (int i = 0; i < N; i++) {\n            i2g[i] = i;\n        }\n    }\n    SUnionFind(ull hs) {\n        for (int i = 0; i < N; i++) {\n            i2g[i] = hs & 0xf;\n            hs >>= 4;\n        }\n    }\n\n    void merge(int x, int y) {\n        int xg = i2g[x], yg = i2g[y];\n        for (int i = 0; i < N; i++) {\n            if (i2g[i] == yg) i2g[i] = xg;\n        }\n    }\n\n    bool same(int x, int y) {\n        return i2g[x] == i2g[y];\n    }\n\n    ull hash() {\n        int b[N];\n        memset(b, -1, sizeof(b));\n        int c = 0;\n        ull hs = 0;\n        for (int i = N-1; i >= 0; i--) {\n            hs <<= 4;\n            if (b[i2g[i]] == -1) {\n                b[i2g[i]] = c;\n                c++;\n            }\n            hs += b[i2g[i]];\n        }\n        return hs;\n    }\n};\n\ntypedef SUnionFind<14> UF;\ntypedef pair<ull, double> P;\nint main() {\n    int n, m, pp;\n    cin >> n >> m >> pp;\n    double p = pp / 100.0;\n\n    int g[14]= {};\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b; a--; b--;\n        if (a > b) swap(a, b);\n        g[a] |= (1<<b);\n    }\n\n    vector<P> mp;\n    mp.push_back(P(UF().hash(), 1.0));\n    for (int i = 0; i < n-1; i++) {\n        for (int j = i+1; j < n; j++) {\n            if (!(g[i] & (1<<j))) continue;\n//            cout << i << \" \" << j << \" \" << mp.size() << endl;\n            vector<P> mp2;\n            for (auto pa : mp) {\n                ull d; double r;\n                tie(d, r) = pa;\n                UF uf(d);\n                uf.merge(i, j);\n                mp2.push_back(P(d, r*p));\n                mp2.push_back(P(uf.hash(), r*(1-p)));\n            }\n            mp = mp2;\n            if (!mp.size()) continue;\n            sort(mp.begin(), mp.end());\n            int l = 0;\n            for (int k = 1; k < (int)mp.size(); k++) {\n                if (mp[l].first != mp[k].first) {\n                    l++;\n                    mp[l] = mp[k];\n                } else {\n                    mp[l].second += mp[k].second;\n                }\n            }\n            l++;\n            mp.erase(mp.begin()+l, mp.end());\n        }\n\n        vector<P> mp2;\n        for (auto p : mp) {\n            UF uf(p.first);\n            bool f = false;\n            for (int j = i+1; j < n; j++) {\n                if (uf.same(i, j)) {\n                    f = true;\n                    break;\n                }\n            }\n            if (!f) continue;\n\n            UF uf2;\n            for (int j = i+1; j < n; j++) {\n                for (int k = j+1; k < n; k++) {\n                    if (uf.same(j, k)) uf2.merge(j, k);\n                }\n            }\n            mp2.push_back(P(uf2.hash(), p.second));\n        }\n        mp = mp2;\n        if (!mp.size()) continue;\n        sort(mp.begin(), mp.end());\n        int l = 0;\n        for (int k = 1; k < (int)mp.size(); k++) {\n            if (mp[l].first != mp[k].first) {\n                l++;\n                mp[l] = mp[k];\n            } else {\n                mp[l].second += mp[k].second;\n            }\n        }\n        l++;\n        mp.erase(mp.begin()+l, mp.end());\n    }\n    double res = 0;\n    for (auto p : mp) {\n        res += p.second;\n    }\n    printf(\"%.20lf\\n\", res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nvector<int> g[14];\ndouble dp[1<<14];\n\nint main() {\n  int n,m,P;\n  while(cin>>n>>m>>P) {\n    REP(i,n) g[i].clear();\n    REP(i,m) {\n      int a, b;\n      cin >> a >> b;\n      a--;b--;\n      g[a].push_back(b);\n      g[b].push_back(a);\n    }\n    REP(S,1<<n) dp[S] = 1;\n    REP(S,1<<n) {\n      if (!(S&1)) continue;\n      vector<int> v;\n      REP(i,n) if (S>>i&1) v.push_back(i);\n      REP(Q,1<<v.size()) {\n        int T = 0;\n        REP(i,v.size())\n          if (Q>>i&1)\n            T |= 1<<v[i];\n        if (!(T&1)) continue;\n        if (S==T) continue;\n        double p = 1;\n        REP(i,n) {\n          if (T>>i&1) {\n            FOR(it, g[i]) {\n              if ((S^T)>>*it&1) {\n                p = p*P/100;\n              }\n            }\n          }\n        }\n        dp[S] -= dp[T] * p;\n        // cout << bitset<4>(S) << \" \" << bitset<4>(T) << \" \" << p << endl;\n      }\n    }\n    printf(\"%.10f\\n\", dp[(1<<n)-1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\nstruct Edge {\n    int src, dst;\n};\nusing Graph = vector<vector<Edge>>;\n\nvoid print_float(double x, int precision=15) {\n    cout.setf(ios::fixed);\n    cout.precision(precision);\n    cout << x << '\\n';\n}\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n\n    int N, M, P;\n    while (cin >> N >> M >> P) {\n        double p = P/100.0;\n        Graph graph(N);\n        vector<Edge> edges;\n        REP(i, M) {\n            int u, v; cin >> u >> v; --u; --v;\n            edges.push_back((Edge){u, v});\n        }\n\n        vector<double> dp(1<<N);\n        REP(S, 1<<N) {\n            double q = 0;\n            for (int T = (S-1)&S; T; T = (T-1)&S) {\n                if ((T&-T) != (S&-S)) continue;\n                int k = 0;\n                REP(i, M) {\n                    int x = 1 << edges[i].src;\n                    int y = 1 << edges[i].dst;\n                    if ((x&S) && (y&S) && !(x&T) != !(y&T))\n                        ++k;\n                }\n                q += dp[T] * pow(p, k);\n            }\n            dp[S] = 1 - q;\n        }\n        print_float(dp[(1<<N)-1]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n,m;\ndouble p;\nvector<int> G[15];\ndouble dp[1<<14];\ndouble po[101];\n\nint main(void){\n\tscanf(\"%d%d%lf\",&n,&m,&p);\n\tp/=100.0;\n\tpo[0]=1.0;\n\tfor(int i=1;i<100;i++){\n\t\tpo[i]=po[i-1]*p;\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tfor(int i=1;i<(1<<n);i++){\n\t\tdouble val=1.0;\n\t\tint j=i-1;\n\t\tj=j&i;\n\t\twhile(j>0){\n\t\t\tint di=i-j;\n\t\t\tif(di<j){\n\t\t\t\tint cnt=0;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(di>>k & 1){\n\t\t\t\t\t\tfor(int l=0;l<G[k].size();l++){\n\t\t\t\t\t\t\tint v=G[k][l];\n\t\t\t\t\t\t\tif(j>>v & 1)cnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tval-=dp[j]*po[cnt];\n\t\t\t}\n\t\t\tj=j-1;\n\t\t\tj=j&i;\n\t\t}\n\t\tdp[i]=val;\n\t\t//printf(\"%d %.2f\\n\",i,dp[i]);\n\t}\n\tprintf(\"%.9f\\n\",dp[(1<<n)-1]);\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n#include \"dump.hpp\"\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\n\tint n, m;\n\tdouble p;\n\tcin >> n >> m >> p;\n\tp /= 100;\n\n\tvector<vector<int>> G(n);\n\tfor(int i = 0; i < m; ++i) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\t--u; --v;\n\t\tG[u].emplace_back(v);\n\t\tG[v].emplace_back(u);\n\t}\n\n\tvector<double> dp(1 << n, 0.0);\n\n\tfor(int bit = 0; bit < 1 << (n - 1); ++bit) {\n\t\tconst int V = (bit << 1) | 1;\n\n\t\tdouble sum = 0.0;\n\t\tfor(int S = V; S > 0; S = (S - 1) & V) {\n\t\t\tif(!(S & 1)) continue;\n\n\t\t\tconst int T = V ^ S;\n\t\t\tdouble q = 1.0;\n\t\t\tfor(int v = 0; v < n; ++v) {\n\t\t\t\tif(!(S >> v & 1)) continue;\n\n\t\t\t\tfor(const auto &u : G[v]) {\n\t\t\t\t\tif(!(T >> u & 1)) continue;\n\t\t\t\t\tq *= p;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum += dp[S] * q;\n\t\t}\n\t\tdp[V] = 1.0 - sum;\n\t}\n\n\tdump(dp);\n\n\tcout << dp[(1 << n) - 1] << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint V,E;\ndouble P,Q;\nvector<int> G[15];\n\n\nvoid printbit(int S){\n  for(int i=0;i<V;i++){\n    cout<<(S>>i&1)<<' ';\n  }\n  cout<<endl;\n}\n\ndouble func(int S,int U){\n\n  double res=1;\n  for(int i=0;i<V;i++){\n    if(S>>i&1){\n      for(int j=0;j<(int)G[i].size();j++){\n        int w=G[i][j];\n        if(S>>w&1)continue;\n        if(U>>w&1)        res*=P;\n      }\n    }\n  }\n\n\n\n  return res;\n}\n\ndouble dp[(1<<14)];\n\ndouble rec(int S){\n\n  if(dp[S]!=-1)return dp[S];\n  if(S==1)return 1.0;\n\n  double res=0;\n  int sup=S;\n  int sub=sup;\n \n\n  do{\n    if(sub&1){\n      if(sub!=S){\n        double A=rec(sub);\n        double B=func(sub,S);\n        res+=A*B;\n      }\n    }\n    sub=(sub-1)&sup;\n  }while(sub!=sup);\n\n  res=1.0-res;\n\n  return dp[S]=res;\n}\n\nvoid init(){\n  for(int i=0;i<15;i++)G[i].clear();\n  for(int i=0;i<(1<<14);i++){\n    dp[i]=-1;\n  }\n}\n\n\nbool check(){\n  bool visited[15]={};\n  visited[0]=true;\n  queue<int> que;\n  que.push(0);\n\n  while(!que.empty()){\n    int pos=que.front();que.pop();\n    for(int i=0;i<(int)G[pos].size();i++){\n      int w=G[pos][i];\n      if(visited[w])continue;\n      visited[w]=true;\n      que.push(w);\n    }\n  }\n\n  for(int i=0;i<V;i++)\n    if(!visited[i])return false;\n\n  return true;\n}\n\nint main(){\n  while(cin>>V>>E>>P){\n    init();\n    P/=100.0;\n    Q=1.0-P;\n    for(int i=0;i<E;i++){\n      int a,b;\n      cin>>a>>b;\n      a--;b--;\n      G[a].push_back(b);\n      G[b].push_back(a);\n    }\n\n    if(!check()){\n      printf(\"0.0\\n\");\n      continue;\n    }\n    printf(\"%.10f\\n\",rec((1<<V)-1));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint V,E;\ndouble P,Q;\nvector<int> G[15];\n \n \nvoid printbit(int S){\n  for(int i=0;i<V;i++){\n    cout<<(S>>i&1)<<' ';\n  }\n  cout<<endl;\n}\n \ndouble func(int S,int U){\n \n  double res=1;\n  for(int i=0;i<V;i++){\n    if(S>>i&1){\n      for(int j=0;j<(int)G[i].size();j++){\n        int w=G[i][j];\n        if(S>>w&1)continue;\n        if(U>>w&1)        res*=P;\n      }\n    }\n  }\n \n \n \n  return res;\n}\n \ndouble dp[(1<<14)];\n \ndouble rec(int S){\n \n  if(dp[S]!=-1)return dp[S];\n  if(S==1)return 1.0;\n \n  double res=0;\n  int sup=S;\n  int sub=sup;\n  \n \n  do{\n    if(sub&1){\n      if(sub!=S){\n        double A=rec(sub);\n        double B=func(sub,S);\n        res+=A*B;\n      }\n    }\n    sub=(sub-1)⊃\n  }while(sub!=sup);\n \n  res=1.0-res;\n \n  return dp[S]=res;\n}\n \nvoid init(){\n  for(int i=0;i<15;i++)G[i].clear();\n  for(int i=0;i<(1<<14);i++){\n    dp[i]=-1;\n  }\n}\n \n \nbool check(){\n  bool visited[15]={};\n  visited[0]=true;\n  queue<int> que;\n  que.push(0);\n \n  while(!que.empty()){\n    int pos=que.front();que.pop();\n    for(int i=0;i<(int)G[pos].size();i++){\n      int w=G[pos][i];\n      if(visited[w])continue;\n      visited[w]=true;\n      que.push(w);\n    }\n  }\n \n  for(int i=0;i<V;i++)\n    if(!visited[i])return false;\n \n  return true;\n}\n \nint main(){\n  while(cin>>V>>E>>P){\n    init();\n    P/=100.0;\n    Q=1.0-P;\n    for(int i=0;i<E;i++){\n      int a,b;\n      cin>>a>>b;\n      a--;b--;\n      G[a].push_back(b);\n      G[b].push_back(a);\n    }\n \n    if(!check()){\n      printf(\"0.0\\n\");\n      continue;\n    }\n    printf(\"%.10f\\n\",rec((1<<V)-1));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#define maxst 1<<20\nusing namespace std ;\nint n , m , p , u , v ;\nint r[maxst] ;\ndouble f[maxst] ;\n\nint main() {\n\tscanf(\"%d%d%d\",&n,&m,&p) ;\n\tconst int maxs = 1 << n;\n\tfor(int i = 0 ; i < m ; i++) {\n\t\tscanf(\"%d%d\",&u,&v) ; \n\t\tu-- ; v-- ;\n\t\tfor(int j = 0 ; j < maxs ; j++) if((j&(1<<u)) && (j&(1<<v)))\n\t\tr[j]++ ;\n\t}\n\tfor(int i = 1 ; i < maxs ; i++) if(i&1){\n\t\tf[i] = 1.0 ;\n\t\tfor(int j = i&(i-1) ; j ; j = i&(j-1)) if(j&1)\n\t\t\tf[i] -= f[j] * pow(p*0.01 , r[i]-r[j]-r[(~j)&i]) ;\n\t}\n\tprintf(\"%.9f\\n\",f[maxs-1]) ;\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n#include <bitset>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n/**\n * hash???????????????UnionFind ????´???°???16????????????????????¨??????????????????\n */\ntemplate<int N>\nstruct SUnionFind {\n    int i2g[N];\n    SUnionFind() {\n        for (int i = 0; i < N; i++) {\n            i2g[i] = i;\n        }\n    }\n    SUnionFind(ull hs) {\n        for (int i = 0; i < N; i++) {\n            i2g[i] = hs & 0xf;\n            hs >>= 4;\n        }\n    }\n\n    void merge(int x, int y) {\n        int xg = i2g[x], yg = i2g[y];\n        for (int i = 0; i < N; i++) {\n            if (i2g[i] == yg) i2g[i] = xg;\n        }\n    }\n\n    bool same(int x, int y) {\n        return i2g[x] == i2g[y];\n    }\n\n    ull hash() {\n        int b[N];\n        memset(b, -1, sizeof(b));\n        int c = 0;\n        ull hs = 0;\n        for (int i = N-1; i >= 0; i--) {\n            hs <<= 4;\n            if (b[i2g[i]] == -1) {\n                b[i2g[i]] = c;\n                c++;\n            }\n            hs += b[i2g[i]];\n        }\n        return hs;\n    }\n};\n\ntypedef SUnionFind<14> UF;\nint main() {\n    int n, m, pp;\n    cin >> n >> m >> pp;\n    double p = pp / 100.0;\n    unordered_map<ull, double> mp;\n    mp[UF().hash()] = 1.0;\n    int g[14][14] = {};\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b; a--; b--;\n        if (a > b) swap(a, b);\n        g[a][b]++;\n    }\n    for (int i = 0; i < n-1; i++) {\n        for (int j = i+1; j < n; j++) {\n            for (int c = 0; c < g[i][j]; c++) {\n                unordered_map<ull, double> mp2;\n                for (auto pa : mp) {\n                    ull d; double r;\n                    tie(d, r) = pa;\n                    UF uf(d);\n                    uf.merge(i, j);\n                    mp2[d] += r * p;\n                    mp2[uf.hash()] += r * (1-p);\n                }\n                mp = mp2;\n            }\n        }\n        unordered_map<ull, double> mp2;\n        for (auto p : mp) {\n            UF uf(p.first);\n            bool f = false;\n            for (int j = i+1; j < n; j++) {\n                if (uf.same(i, j)) {\n                    f = true;\n                    break;\n                }\n            }\n\n            if (!f) continue;\n            UF uf2;\n            for (int j = i+1; j < n; j++) {\n                for (int k = j+1; k < n; k++) {\n                    if (uf.same(j, k)) uf2.merge(j, k);\n                }\n            }\n            mp2[uf2.hash()] += p.second;\n        }\n        mp = mp2;\n    }\n    double res = 0;\n    for (auto p : mp) {\n        res += p.second;\n    }\n    printf(\"%.20lf\\n\", res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<58;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint n,m;\ndouble p;\nvvi g;\n\nint main(){\n\tcin>>n>>m>>p;\n\tg=vvi(n,vi(n));\n\tp/=100;\n\tint S=1<<n;\n\tvi DP(S);\n\tvd dp(S,1),a(m+1);\n\ta[0]=1;\n\tfor(int i=1;i<=m;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;v--;\n\t\tg[u][v]++;\n\t\tg[v][u]++;\n\t\ta[i]=a[i-1]*p;\n\t}\n\tfor(int i=1;i<S;i++){\n\t\tint I=0;\n\t\twhile(!(i&1<<I)) I++;\n\t\tint T=i-(1<<I);\n\t\tDP[i]=DP[T];\n\t\tfor(int j=0;j<n;j++) if(g[I][j]&&(i&1<<j)) DP[i]++;\n\t\tint J=T&(T-1);\n\t\twhile(J!=T){\n\t\t\tint U=J+(1<<I);\n\t\t\tdp[i]-=dp[U]*a[DP[i]-DP[U]-DP[i-U]];\n\t\t\tJ=T&(J-1);\n\t\t}\n\t}\n\tcout<<syosu(11)<<dp[S-1]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include<cmath>\n#include<set>\n#include<stack>\n#include <string.h>\n\nusing namespace std;\n\nint V;                      //????????°\nvector<int>G[10000];       //??°???)(){????????£??\\????????¨???\nvector<int>rG[10000];\nvector<int> vs;             //??°?????????????????????\nbool used[10000];           //?????§???????????????\nint cmp[10000];             //?±????????????£????????????????????????????????????\nint P;\n\nvoid add_edge(int from, int to){\n    G[from].push_back(to);\n    rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n    used[v] = true;\n    for(int i=0;i<G[v].size();i++){\n        if(!used[G[v][i]]) dfs(G[v][i]);\n    }\n    vs.push_back(v);\n}\nint rdfs(int v,int k){\n    used[v] = true;\n    cmp[v] = k;\n    int ret=0;\n    for(int i=0;i<rG[v].size();i++){\n        if(!used[rG[v][i]]) {\n            ret+=rdfs(rG[v][i], k);\n        }\n    }\n    return ret;\n}\n\ndouble scc(){\n    memset(used, 0, sizeof(used));\n    vs.clear();\n    for(int v=0;v<V;v++){\n        if(!used[v]) dfs(v);\n    }\n    memset(used,0,sizeof(used));\n    int k=0;\n    double ans=0;\n    for(int i=vs.size()-1;i>=0;i--){\n        if(!used[vs[i]]) {\n            int nu=rdfs(vs[i], k++);\n            if(nu>1){\n                double du=(nu*(nu-1)*1.0)/2*P*P;\n                ans+=du;\n            } else {\n                ans+=P;\n            }\n        }\n    }\n    return ans;\n}\n\nint N,M;\nint A[50000], B[50000];\n\nvoid solve(){\n    cin>>N>>M>>P;\n    V=N;\n    for(int i=0;i<M;i++){\n        cin>>A[i]>>B[i];\n    }\n    for(int i=0;i<M;i++){\n        add_edge(A[i]-1,B[i]-1);\n    }\n    printf(\"%.9f\\n\",scc());\n}\nint main()\n{\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n#include <bitset>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n\n/**\n * hash???????????????UnionFind ????´???°???16????????????????????¨??????????????????\n */\ntemplate<int N>\nstruct SUnionFind {\n    int i2g[N];\n    SUnionFind() {\n        for (int i = 0; i < N; i++) {\n            i2g[i] = i;\n        }\n    }\n    SUnionFind(ull hs) {\n        for (int i = 0; i < N; i++) {\n            i2g[i] = hs & 0xf;\n            hs >>= 4;\n        }\n    }\n\n    void merge(int x, int y) {\n        int xg = i2g[x], yg = i2g[y];\n        for (int i = 0; i < N; i++) {\n            if (i2g[i] == yg) i2g[i] = xg;\n        }\n    }\n\n    bool same(int x, int y) {\n        return i2g[x] == i2g[y];\n    }\n\n    ull hash() {\n        int b[N];\n        memset(b, -1, sizeof(b));\n        int c = 0;\n        ull hs = 0;\n        for (int i = N-1; i >= 0; i--) {\n            hs <<= 4;\n            if (b[i2g[i]] == -1) {\n                b[i2g[i]] = c;\n                c++;\n            }\n            hs += b[i2g[i]];\n        }\n        return hs;\n    }\n};\n\ntypedef SUnionFind<14> UF;\ntypedef pair<ull, double> P;\nint main() {\n    int n, m, pp;\n    cin >> n >> m >> pp;\n    double p = pp / 100.0;\n\n    int g[14]= {};\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b; a--; b--;\n        if (a > b) swap(a, b);\n        g[a] |= (1<<b);\n    }\n\n    vector<P> mp;\n    mp.push_back(P(UF().hash(), 1.0));\n    for (int i = 0; i < n-1; i++) {\n        for (int j = i+1; j < n; j++) {\n            if (!(g[i] & (1<<j))) continue;\n//            cout << i << \" \" << j << \" \" << mp.size() << endl;\n//            cout << mp.capacity() << \" \" << mp2.capacity() << endl;\n            int S = (int)mp.size();\n            for (int k = 0; k < S; k++) {\n                ull d; double r;\n                tie(d, r) = mp[k];\n                UF uf(d);\n                uf.merge(i, j);\n                mp[k].second *= p;\n                mp.push_back(P(uf.hash(), r*(1-p)));\n            }\n            if (!mp.size()) continue;\n            sort(mp.begin(), mp.end());\n            int l = 0;\n            for (int k = 1; k < (int)mp.size(); k++) {\n                if (mp[l].first != mp[k].first) {\n                    l++;\n                    mp[l] = mp[k];\n                } else {\n                    mp[l].second += mp[k].second;\n                }\n            }\n            l++;\n            mp.resize(l);\n        }\n\n        int nn = 0;\n        int S = (int)mp.size();\n        for (int k = 0; k < S; k++) {\n            P p = mp[k];\n            UF uf(p.first);\n            bool f = false;\n            for (int j = i+1; j < n; j++) {\n                if (uf.same(i, j)) {\n                    f = true;\n                    break;\n                }\n            }\n            if (!f) continue;\n\n            UF uf2;\n            for (int j = i+1; j < n; j++) {\n                for (int k = j+1; k < n; k++) {\n                    if (uf.same(j, k)) uf2.merge(j, k);\n                }\n            }\n            mp[nn] = P(uf2.hash(), p.second);\n            nn++;\n        }\n        mp.resize(nn);\n        if (!mp.size()) continue;\n        sort(mp.begin(), mp.end());\n        int l = 0;\n        for (int k = 1; k < (int)mp.size(); k++) {\n            if (mp[l].first != mp[k].first) {\n                l++;\n                mp[l] = mp[k];\n            } else {\n                mp[l].second += mp[k].second;\n            }\n        }\n        l++;\n        mp.resize(l);\n    }\n    double res = 0;\n    for (auto p : mp) {\n        res += p.second;\n    }\n    printf(\"%.20lf\\n\", res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define fr(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n#define all(c) c.begin(),c.end()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef long long ll;\nconst int inf=(int)1e9;\nconst double EPS=1e-9, INF=1e12;\n\nint n,m,a[100],b[100];\ndouble dp[1<<14],p;\nint main(){\n\tcin>>n>>m>>p;\n\tp/=100;\n\trep(i,m)cin>>a[i]>>b[i], a[i]--, b[i]--;\n\t\n\trep(i,1<<n)if(i){\n\t\tint l=0;\n\t\tfor(;!(l&i);l++);\n\t\tdp[i]=1;\n\t\tfor(int s=i;s;s=s-1&i){\n\t\t\tif(s==i||!(s&l))continue;\n\t\t\tdouble tmp=dp[s];\n\t\t\trep(j,m)if((i&1<<a[j])&&(i&1<<b[j])&&(s>>a[j]&1)!=(s>>b[j]&1))tmp*=p;\n\t\t\tdp[i]-=tmp;\n\t\t}\n\t}\n\tprintf(\"%.12f\\n\",dp[(1<<n)-1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint n, m;\nld p;\nvector<vi> g;\nvector<ld> dp;\n\nint getbit(vi v)\n{\n\tint res = 0;\n\tfor (auto i : v)\n\t{\n\t\tres |= 1 << i;\n\t}\n\treturn res;\n}/*\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tcin >> n >> m >> p;\n\tg.resize(n, vi(n));\n\tdp.resize(1 << n);\n\tp /= 100.0;\n\tREP(i, m)\n\t{\n\t\tint a, b; cin >> a >> b;\n\t\ta--; b--;\n\t\tg[a][b]++;\n\t\tg[b][a]++;\n\t}\n\tdp[0] = 1.0;\n\tREP(i, n) dp[1 << i] = 1.0;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tREP(bit, 1 << n)\n\t\t{\n\t\t\tif (__popcnt(bit) != i) continue;\n\t\t\tvi s;\n\t\t\tREP(j, n)\n\t\t\t{\n\t\t\t\tif ((bit >> j) & 1) s.push_back(j);\n\t\t\t}\n\t\t\tld sum = 0;\n\t\t\tREP(j, 1 << i)\n\t\t\t{\n\t\t\t\tvi s1, s2;\n\t\t\t\tREP(k, i)\n\t\t\t\t{\n\t\t\t\t\tif ((j >> k) & 1) s1.push_back(s[k]);\n\t\t\t\t\telse s2.push_back(s[k]);\n\t\t\t\t}\n\t\t\t\tif (s1.size() == 0 || s2.size() == 0) continue;\n\t\t\t\tint edge = 0;\n\t\t\t\tfor (auto a : s1)\n\t\t\t\t{\n\t\t\t\t\tfor (auto b : s2)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (g[a][b]) edge++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsum += dp[getbit(s1)] * pow(p, edge);\n\t\t\t}\n\t\t\tdp[bit] = 1.0 - sum;\n\t\t}\n\t}\n\tcout << dp[(1 << n) - 1] << endl;\n\treturn 0;\n}*/\n\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tcin >> n >> m >> p;\n\tg.resize(n, vi(n));\n\tdp.resize(1 << n);\n\tp /= 100.0;\n\tREP(i, m)\n\t{\n\t\tint a, b; cin >> a >> b;\n\t\ta--; b--;\n\t\tg[a][b]++;\n\t\tg[b][a]++;\n\t}\n\tREP(s, 1 << n)\n\t{\n\t\tint v = s&~s;\n\t\tdp[s] = 1.0;\n\t\tfor (int t = (s - 1) & s; t > 0; t = (t - 1)&s)\n\t\t{\n\t\t\tif (!(t&(1 << v))) continue;\n\t\t\tint edge = 0;\n\t\t\tint u = s^t;\n\t\t\tREP(i, n)\n\t\t\t{\n\t\t\t\tif (!((t >> i) & 1)) continue;\n\t\t\t\tREP(j, n)\n\t\t\t\t{\n\t\t\t\t\tif (((u >> j) & 1) && g[i][j]) edge++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[s] -= dp[t] * pow(p, edge);\n\t\t}\n\t}\n\tcout << dp[(1 << n) - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint main(){\n  int N,M,P;\n  cin>>N>>M>>P;\n  int u[123],v[123];\n  for(int i=0;i<M;i++){\n    cin>>u[i]>>v[i];\n    u[i]--;\n    v[i]--;\n  }\n  double dp[1<<14]={0,1};\n  for(int i=2;i<1<<N;i++){\n    if(!(i&1))continue;\n    dp[i]=1;\n    for(int j=1;j<i;j=(j+1+~i)&i){\n      double d=dp[j];\n      for(int k=0;k<M;k++){\n\tif(i>>u[k]&1&&i>>v[k]&1&&j>>u[k]&1^j>>v[k]&1){\n\t  d*=P/100.;\n\t}\n      }\n      dp[i]-=d;\n    }\n  }\n  cout.precision(9);\n  cout<<fixed<<dp[(1<<N)-1]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const set<T>& a){\n\tos<<'{';\n\tfor(auto i=begin(a);i!=end(a);++i)\n\t\tos<<(i==begin(a)?\"\":\" \")<<*i;\n\treturn os<<'}';\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tdouble p; cin>>p; p*=0.01;\n\t\tvector<pii> es;\n\t\trep(i,m){\n\t\t\tint u,v; cin>>u>>v; u--,v--;\n\t\t\tes.emplace_back(u,v);\n\t\t}\n\t\tsort(all(es));\n\t\t\n\t\tmap<vector<int>,double> f1; // {連結成分} => 確率\n\t\t{\n\t\t\tvector<int> tmp;\n\t\t\trep(i,n) tmp.push_back(1<<i);\n\t\t\tf1[tmp]=1;\n\t\t}\n\t\t\n\t\tfor(auto e:es){\n\t\t\t//dump(f1.size());\n\t\t\tint u,v; tie(u,v)=e;\n\t\t\tdecltype(f1) f2;\n\t\t\tfor(auto t:f1){\n\t\t\t\tvector<int> cs=t.first;\n\t\t\t\tdouble cp=t.second;\n\t\t\t\tif(cp<1e-16) continue;\n\t\t\t\tvector<int> ns;\n\t\t\t\tint tmp=0;\n\t\t\t\tfor(auto s:cs){\n\t\t\t\t\tif((s>>u&1) || (s>>v&1))\n\t\t\t\t\t\ttmp|=s;\n\t\t\t\t\telse\n\t\t\t\t\t\tns.push_back(s);\n\t\t\t\t}\n\t\t\t\tif(tmp) ns.push_back(tmp);\n\t\t\t\tsort(all(ns));\n\t\t\t\t\n\t\t\t\tf2[ns]+=cp*(1-p);\n\t\t\t\tf2[cs]+=cp*p;\n\t\t\t}\n\t\t\tswap(f1,f2);\n\t\t}\n\t\t\n\t\tdouble res=0;\n\t\tfor(auto p:f1) if(p.first.size()==1) res=p.second;\n\t\tprintf(\"%.12f\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n#define bit(x) (1<<(x))\nusing namespace std;\n\nint n,m,p;\nint a[15][15];\n\nusing R=long double;\nR dp[1<<14];\n\nint main(void){\n\tcin >> n >> m >> p;\n\trep(i,m){\n\t\tint u,v;\n\t\tcin >> u >> v;\n\t\ta[u-1][v-1]++;\n\t\ta[v-1][u-1]++;\n\t}\n\n\trep(mask,1,1<<n){\n\t\tdp[mask]=1.0;\t\t\n\t\tif(__builtin_popcount(mask)==1) continue;\n\t\tint limit=bit(31-__builtin_clz(mask));\n\t\tfor(int add=(mask-1)&mask;add>=limit;add=(add-1)&mask){\n\t\t\tint root=add^mask;\n\t\t\tdouble cur=dp[add];\n\t\t\trep(i,n)rep(j,n) if(root&bit(i)) if(add&bit(j)) rep(loop,a[i][j]) cur*=1.0*p/100.0; \n\t\t\tdp[mask]-=cur;\t\n\t\t}\n\t}\n\tcout.precision(20);\n\tcout << fixed << dp[(1<<n)-1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 14;\n\nint sm[(1 << MAX_N)];\ndouble dp[(1 << MAX_N)];\ndouble pp[101];\n\nint main()\n{\n    int n,m,p;\n    scanf(\"%d%d%d\",&n,&m,&p);\n    pp[0] = 1;\n    vp edge(m);\n    rep(i,m){\n        pp[i+1] = pp[i] * (p / 100.0);\n        scanf(\"%d%d\",&edge[i].fi,&edge[i].se);\n    }\n    rep(i,(1 << n)){\n        int res = 0;\n        rep(j,m){\n            int u = edge[j].fi - 1,v = edge[j].se - 1;\n            if((i >> u) & (i >> v) & 1){\n                res++;\n            }\n        }\n        sm[i] = res;\n    }\n    for(int S=1;S<(1 << n);S=(S+1)|1){\n        double res = 0;\n        for(int T=S;T>0;T=(T-1)&S){\n            res += dp[T]*pp[sm[S]-sm[T]-sm[S^T]];\n        }\n        dp[S] = 1.0 - res;\n    }\n    printf(\"%.12lf\\n\",dp[(1 << n)-1]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<string>\n#include<cmath>\n#include<set>\n#include<stack>\n\nusing namespace std;\n\nint V;                      //????????°\nvector<int>G[10000];       //??°???)(){????????£??\\????????¨???\nvector<int>rG[10000];\nvector<int> vs;             //??°?????????????????????\nbool used[10000];           //?????§???????????????\nint cmp[10000];             //?±????????????£????????????????????????????????????\nint P;\n\nvoid add_edge(int from, int to){\n    G[from].push_back(to);\n    rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n    used[v] = true;\n    for(int i=0;i<G[v].size();i++){\n        if(!used[G[v][i]]) dfs(G[v][i]);\n    }\n    vs.push_back(v);\n}\nint rdfs(int v,int k){\n    used[v] = true;\n    cmp[v] = k;\n    int ret=0;\n    for(int i=0;i<rG[v].size();i++){\n        if(!used[rG[v][i]]) {\n            ret+=rdfs(rG[v][i], k);\n        }\n    }\n    return ret;\n}\n\ndouble scc(){\n    memset(used, 0, sizeof(used));\n    vs.clear();\n    for(int v=0;v<V;v++){\n        if(!used[v]) dfs(v);\n    }\n    memset(used,0,sizeof(used));\n    int k=0;\n    double ans=0;\n    for(int i=vs.size()-1;i>=0;i--){\n        if(!used[vs[i]]) {\n            int nu=rdfs(vs[i], k++);\n            if(nu>1){\n                double du=(nu*(nu-1)*1.0)/2*P*P;\n                ans+=du;\n            } else {\n                ans+=P;\n            }\n        }\n    }\n    return ans;\n}\n\nint N,M;\nint A[50000], B[50000];\n\nvoid solve(){\n    cin>>N>>M>>P;\n    V=N;\n    for(int i=0;i<M;i++){\n        cin>>A[i]>>B[i];\n    }\n    for(int i=0;i<M;i++){\n        add_edge(A[i]-1,B[i]-1);\n    }\n    printf(\"%.9f\\n\",scc());\n}\nint main()\n{\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\nvoid print_float(double x, int precision=15) {\n    cout.setf(ios::fixed);\n    cout.precision(precision);\n    cout << x << '\\n';\n}\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n\n    int N, M, P;\n    while (cin >> N >> M >> P) {\n        double p = P/100.0;\n        vector<vector<int>> adj(N, vector<int>(N));\n        REP(i, M) {\n            int u, v; cin >> u >> v; --u; --v;\n            ++adj[u][v]; ++adj[v][u];\n        }\n\n        vector<int> outedge(1<<N);\n        REP(S, 1<<N) {\n            int k = 0;\n            REP(u, N) if (S & (1<<u))\n                REP(v, N) if (~S & (1<<v))\n                    k += adj[u][v];\n            outedge[S] = k;\n        }\n\n        int U = (1<<N)-1;\n        vector<double> dp(1<<N);\n        REP(S, 1<<N) {\n            double q = 0;\n            for (int T = (S-1)&S; T; T = (T-1)&S) {\n                if ((T&-T) != (S&-S)) continue;\n                int k = (outedge[T] + outedge[S^T] - outedge[U^S]) / 2;\n                q += dp[T] * pow(p, k);\n            }\n            dp[S] = 1 - q;\n        }\n        print_float(dp[U]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// haaaaaaaaaaaaard\n\n#include<cmath>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint main(){\n\tint n,m;\n\tdouble p; scanf(\"%d%d%lf\",&n,&m,&p);\n\tp/=100;\n\n\tint e[1<<14]={}; // e[S] := ( S から V\\S へ出ている辺の本数 )\n\trep(i,m){\n\t\tint u,v; scanf(\"%d%d\",&u,&v); u--; v--;\n\t\trep(S,1<<n){\n\t\t\tif(S&1<<u && (S&1<<v)==0) e[S]++;\n\t\t\tif(S&1<<v && (S&1<<u)==0) e[S]++;\n\t\t}\n\t}\n\n\t// dp[S] := ( V の部分集合 S が連結になる確率 )\n\t// ここで、S と V-S のつながり方については気にしていない\n\tdouble dp[1<<14];\n\tdp[0]=1;\n\trep(S,1<<n) if(S!=0) {\n\t\t// S に含まれる頂点(どれでもいい)を一つ固定する\n\t\tint u0;\n\t\trep(u,n) if(S&1<<u) u0=u;\n\n\t\t// S を頂点集合とみた部分グラフに制限して考える。\n\t\t//   dp[S] = ( u0 を含む連結成分が S である確率 )\n\t\t// と\n\t\t//   Σ_{T \\subset S, u0 \\in T} ( u0 を含む連結成分が T である確率 ) = 1\n\t\t// より、移項して dp[S] についての漸化式\n\t\t//   dp[S] = 1 - Σ_{T \\subset S, u0 \\in T, T!=S} ( u0 を含む連結成分が T である確率 )\n\t\t// を得る。\n\t\t// さらに\n\t\t//   ( u0 を含む連結成分が T である確率 )\n\t\t// = ( T が連結になる確率 ) * p^k\n\t\t// = dp[T] * p^k, ( k は T と S\\T の間にある辺の本数 )\n\t\t// なので\n\t\t//   dp[S] = 1 - Σ_{T \\subset S, u0 \\in T, T!=S} dp[T] * p^k\n\t\t// となる。\n\t\tdp[S]=1;\n\t\tfor(int T=(S-1)&S;T>0;T=(T-1)&S) if(T&1<<u0) {\n\t\t\tdp[S]-=dp[T]*pow(p,(e[T]+e[S-T]-e[S])/2);\n\t\t}\n\t}\n\n\tprintf(\"%.15f\\n\",dp[(1<<n)-1]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const set<T>& a){\n\tos<<'{';\n\tfor(auto i=begin(a);i!=end(a);++i)\n\t\tos<<(i==begin(a)?\"\":\" \")<<*i;\n\treturn os<<'}';\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tdouble p; cin>>p; p*=0.01;\n\t\tvector<pii> es;\n\t\trep(i,m){\n\t\t\tint u,v; cin>>u>>v; u--,v--;\n\t\t\tes.emplace_back(u,v);\n\t\t}\n\t\t\n\t\tmap<set<set<int>>,double> f1; // {連結成分} => 確率\n\t\t{\n\t\t\tset<set<int>> tmp;\n\t\t\trep(i,n) tmp.insert(set<int>({i}));\n\t\t\tf1[tmp]=1;\n\t\t}\n\t\t\n\t\tfor(auto e:es){\n\t\t\tint u,v; tie(u,v)=e;\n\t\t\tdecltype(f1) f2;\n\t\t\tfor(auto t:f1){\n\t\t\t\tset<set<int>> cs=t.first;\n\t\t\t\tdouble cp=t.second;\n\t\t\t\tset<set<int>> ns;\n\t\t\t\tset<int> tmp;\n\t\t\t\tfor(auto s:cs){\n\t\t\t\t\tif(s.count(u) || s.count(v))\n\t\t\t\t\t\ttmp.insert(all(s));\n\t\t\t\t\telse\n\t\t\t\t\t\tns.insert(s);\n\t\t\t\t}\n\t\t\t\tif(tmp.size()) ns.insert(tmp);\n\t\t\t\t\n\t\t\t\tf2[ns]+=cp*(1-p);\n\t\t\t\tf2[cs]+=cp*p;\n\t\t\t}\n\t\t\tswap(f1,f2);\n\t\t}\n\t\t\n\t\tfor(auto p:f1) if(p.first.size()==1)\n\t\t\tprintf(\"%.12f\\n\",p.second);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint V,E;\ndouble P,Q;\nvector<int> G[15];\n \n \nvoid printbit(int S){\n  for(int i=0;i<V;i++){\n    cout<<(S>>i&1)<<' ';\n  }\n  cout<<endl;\n}\n \ndouble func(int S,int U){\n \n  double res=1;\n  for(int i=0;i<V;i++){\n    if(S>>i&1){\n      for(int j=0;j<(int)G[i].size();j++){\n        int w=G[i][j];\n        if(S>>w&1)continue;\n        if(U>>w&1)        res*=P;\n      }\n    }\n  }\n \n \n \n  return res;\n}\n \ndouble dp[(1<<14)];\n \ndouble rec(int S){\n \n  if(dp[S]!=-1)return dp[S];\n  if(S==1)return 1.0;\n \n  double res=0;\n  int sup=S;\n  int sub=sup;\n  \n \n  do{\n    if(sub&1){\n      if(sub!=S){\n        double A=rec(sub);\n        double B=func(sub,S);\n        res+=A*B;\n      }\n    }\n    sub=(sub-1);\n  }while(sub!=sup);\n \n  res=1.0-res;\n \n  return dp[S]=res;\n}\n \nvoid init(){\n  for(int i=0;i<15;i++)G[i].clear();\n  for(int i=0;i<(1<<14);i++){\n    dp[i]=-1;\n  }\n}\n \n \nbool check(){\n  bool visited[15]={};\n  visited[0]=true;\n  queue<int> que;\n  que.push(0);\n \n  while(!que.empty()){\n    int pos=que.front();que.pop();\n    for(int i=0;i<(int)G[pos].size();i++){\n      int w=G[pos][i];\n      if(visited[w])continue;\n      visited[w]=true;\n      que.push(w);\n    }\n  }\n \n  for(int i=0;i<V;i++)\n    if(!visited[i])return false;\n \n  return true;\n}\n \nint main(){\n  while(cin>>V>>E>>P){\n    init();\n    P/=100.0;\n    Q=1.0-P;\n    for(int i=0;i<E;i++){\n      int a,b;\n      cin>>a>>b;\n      a--;b--;\n      G[a].push_back(b);\n      G[b].push_back(a);\n    }\n \n    if(!check()){\n      printf(\"0.0\\n\");\n      continue;\n    }\n    printf(\"%.10f\\n\",rec((1<<V)-1));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\ninline unsigned nextSubset(unsigned S, unsigned U)\n{\n  return (S - U) & U;\n}\n\nint n, m, p;\nint g[100][100];\ndouble memo[1 << 14];\nint cnt[1 << 14];\ndouble P[200];\n\ndouble calc(int use) {\n  assert(use != 0);\n  if (!isnan(memo[use])) { return memo[use]; }\n  double ret = 1;\n  for (int divide = use & -use; divide != use; divide = nextSubset(divide, use)) {\n    if ((divide & 1) != 1) { continue; }\n    int c = cnt[divide] + cnt[use ^ divide] - cnt[((1 << n) - 1) ^ use];\n    c /= 2;\n    ret -= calc(divide) * P[c];\n  }\n  //cout << use << \" \" << ret << endl;\n  return memo[use] = ret;\n}\n\nint main() {\n  while (scanf(\"%d %d %d\", &n, &m, &p) > 0) {\n    P[0] = 1.0;\n    REP(i, 110) { P[i + 1] = P[i] * p / 100.0; }\n    MEMSET(memo, -1);\n    MEMSET(g, 0);\n    MEMSET(cnt, 0);\n    REP(i, m) {\n      int f, t;\n      scanf(\"%d %d\", &f, &t);\n      f--; t--;\n      g[f][t]++; g[t][f]++;\n    }\n    REP(use, 1 << n) {\n      REP(f, n) {\n        if (!((use >> f) & 1)) { continue; }\n        REP(t, n) {\n          if ((use >> t) & 1) { continue; }\n          cnt[use] += g[f][t];\n        }\n      }\n    }\n    double ans = calc((1 << n) - 1);\n    printf(\"%.10f\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define double long double\n#define N 14\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nint G[N][N];\nint n;\ndouble p;\n\n\ndouble calc(int b,int c){\n  static unordered_map<int,double> mem[1<<N];\n  if(mem[b].count(c)) return mem[b][c];\n  double res = 1;\n  for(int i=0;i<n;i++) \n    for(int j=i+1;j<n;j++)\n      if(((b>>i&1) && (c>>j&1) && G[i][j]) ||\n         ((b>>j&1) && (c>>i&1) && G[i][j])) res *= p;\n      return mem[b][c] = res;\n}\n\n\ndouble mem[1<<N],used[1<<N];\ndouble dfs(int bit){\n  if(bit == 0) return 0;\n  if((bit&-bit) == bit) return 1;\n  if(used[bit]++) return mem[bit];\n\n  double res = 1;\n  for(int i = (i-1)&bit;i > 0;i=(i-1)&bit){\n    if(i % 2 == 0) continue;\n    int j = bit ^ i;\n    double p = dfs(i);    \n    res -= p * calc(i,j); \n  } \n  return mem[bit] = res;\n}\n\n\nsigned main(){\n  int m;\n  cin>>n>>m>>p; p/=100;\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;\n    G[a-1][b-1] = G[b-1][a-1] = 1;\n  }\n  \n  printf(\"%.10Lf\\n\",dfs((1<<n)-1));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define double long double\n#define N 14\nusing namespace std;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nint G[N][N];\nint n;\ndouble p;\n\ndouble calc(int b,int c){\n  double res = 1;\n  for(int i=0;i<n;i++) \n    for(int j=i+1;j<n;j++)\n      if(((b>>i&1) && (c>>j&1) && G[i][j]) ||\n         ((b>>j&1) && (c>>i&1) && G[i][j])) res *= p;\n      return res;\n}\n\n\ndouble mem[1<<N],used[1<<N];\ndouble dfs(int bit){\n  if(bit == 0) return 0;\n  if((bit&-bit) == bit) return 1;\n  if(used[bit]++) return mem[bit];\n\n  double res = 1;\n  for(int i = (i-1)&bit;i > 0;i=(i-1)&bit){\n    if(i % 2 == 0) continue;\n    int j = bit ^ i;\n    double p = dfs(i);    \n    res -= p * calc(i,j); \n  } \n  return mem[bit] = res;\n}\n\n\nsigned main(){\n  int m;\n  cin>>n>>m>>p; p/=100;\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;\n    G[a-1][b-1] = G[b-1][a-1] = 1;\n  }\n  \n  printf(\"%.10Lf\\n\",dfs((1<<n)-1));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n#include <bitset>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n\n/**\n * hash???????????????UnionFind ????´???°???16????????????????????¨??????????????????\n */\ntemplate<int N>\nstruct SUnionFind {\n    int i2g[N];\n    SUnionFind() {\n        for (int i = 0; i < N; i++) {\n            i2g[i] = i;\n        }\n    }\n    SUnionFind(ull hs) {\n        for (int i = 0; i < N; i++) {\n            i2g[i] = hs & 0xf;\n            hs >>= 4;\n        }\n    }\n\n    void merge(int x, int y) {\n        int xg = i2g[x], yg = i2g[y];\n        for (int i = 0; i < N; i++) {\n            if (i2g[i] == yg) i2g[i] = xg;\n        }\n    }\n\n    bool same(int x, int y) {\n        return i2g[x] == i2g[y];\n    }\n\n    ull hash() {\n        int b[N];\n        memset(b, -1, sizeof(b));\n        int c = 0;\n        ull hs = 0;\n        for (int i = N-1; i >= 0; i--) {\n            hs <<= 4;\n            if (b[i2g[i]] == -1) {\n                b[i2g[i]] = c;\n                c++;\n            }\n            hs += b[i2g[i]];\n        }\n        return hs;\n    }\n};\n\ntypedef SUnionFind<14> UF;\ntypedef pair<ull, double> P;\nint main() {\n    int n, m, pp;\n    cin >> n >> m >> pp;\n    double p = pp / 100.0;\n\n    int g[14]= {};\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b; a--; b--;\n        if (a > b) swap(a, b);\n        g[a] |= (1<<b);\n    }\n\n    vector<P> mp;\n    mp.push_back(P(UF().hash(), 1.0));\n    for (int i = 0; i < n-1; i++) {\n        for (int j = i+1; j < n; j++) {\n            if (!(g[i] & (1<<j))) continue;\n//            cout << i << \" \" << j << \" \" << mp.size() << endl;\n//            cout << mp.capacity() << \" \" << mp2.capacity() << endl;\n            mp.reserve(mp.size()*2);\n            int S = (int)mp.size();\n            for (int k = 0; k < S; k++) {\n                ull d; double r;\n                tie(d, r) = mp[k];\n                UF uf(d);\n                uf.merge(i, j);\n                mp[k].second *= p;\n                mp.push_back(P(uf.hash(), r*(1-p)));\n            }\n            if (!mp.size()) continue;\n            sort(mp.begin(), mp.end());\n            int l = 0;\n            for (int k = 1; k < (int)mp.size(); k++) {\n                if (mp[l].first != mp[k].first) {\n                    l++;\n                    mp[l] = mp[k];\n                } else {\n                    mp[l].second += mp[k].second;\n                }\n            }\n            l++;\n            mp.resize(l);\n        }\n\n        int nn = 0;\n        int S = (int)mp.size();\n        for (int k = 0; k < S; k++) {\n            P p = mp[k];\n            UF uf(p.first);\n            bool f = false;\n            for (int j = i+1; j < n; j++) {\n                if (uf.same(i, j)) {\n                    f = true;\n                    break;\n                }\n            }\n            if (!f) continue;\n\n            UF uf2;\n            for (int j = i+1; j < n; j++) {\n                for (int k = j+1; k < n; k++) {\n                    if (uf.same(j, k)) uf2.merge(j, k);\n                }\n            }\n            mp[nn] = P(uf2.hash(), p.second);\n            nn++;\n        }\n        mp.resize(nn);\n        if (!mp.size()) continue;\n        sort(mp.begin(), mp.end());\n        int l = 0;\n        for (int k = 1; k < (int)mp.size(); k++) {\n            if (mp[l].first != mp[k].first) {\n                l++;\n                mp[l] = mp[k];\n            } else {\n                mp[l].second += mp[k].second;\n            }\n        }\n        l++;\n        mp.resize(l);\n    }\n    double res = 0;\n    for (auto p : mp) {\n        res += p.second;\n    }\n//    cout << mp.capacity() << endl;\n    printf(\"%.20lf\\n\", res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<vector<int> > Graph;\n\nconst int MAXN = 15;\nconst int MAXM = 101;\n\nint N, M;\ndouble P;\nvector<int> U, V;\ndouble dp[1<<MAXN];\n\nint main() {\n  cin >> N >> M >> P;\n  P /= 100.0;\n  for(int i = 0; i < M; ++i) {\n    int a, b;\n    cin >> a >> b;\n    --a; --b;\n    U.push_back(a);\n    V.push_back(b);\n  }\n\n  for(int i = 1; i < (1<<N); ++i) {\n    dp[i] = 1.0;\n    int v0 = 1;\n    while(!(i & v0)) v0 <<= 1;\n    for(int j = i; j; j = (j-1) & i) {\n      if(j == i) continue;\n      if(!(j & v0)) continue;\n      double q = 1.0;\n      for(int k = 0; k < M; ++k) {\n        if(i >> U[k] & 1 && i >> V[k] & 1 &&\n           (j >> U[k] & 1) ^ (j >> V[k] & 1)) {\n          q *= P;\n        }\n      }\n      dp[i] -= dp[j] * q;\n    }\n  }\n  printf(\"%.12f\\n\", dp[(1<<N) - 1]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\nusing ld = long double;\n\nint main()\n{\n    int N, M;\n    ld P;\n    cin >> N >> M >> P;\n    P /= 100;\n    vector<pair<int, int>> edge(M);\n    for (int i = 0; i < M; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        edge[i] = {u, v};\n    }\n    const int maximum = 1 << N;\n    vector<ld> dp(maximum, 0);\n    for (int i = 1; i < maximum; i++) {\n        int ind = 0;\n        for (; ind < N; ind++) {\n            if (i & (1 << ind)) {\n                break;\n            }\n        }\n        dp[i] = 1;\n        int num = 0;\n        while (num < i) {\n            if (num & (1 << ind)) {\n                const int res = i - num;\n                int cnt = 0;\n                for (const auto& e : edge) {\n                    const int u = e.first;\n                    const int v = e.second;\n                    if ((num & (1 << u) and res & (1 << v)) or (num & (1 << v) and res & (1 << u))) {\n                        cnt++;\n                    }\n                }\n                dp[i] -= dp[num] * pow(P, cnt);\n            }\n            num = (num - i) & i;\n        }\n    }\n    cout << fixed << setprecision(15) << dp[maximum - 1] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n\nint main(){\n    int n,m;\n    double p;\n    cin >>n >>m >>p;\n\n    vector<int> u(m),v(m);\n    rep(i,m){\n        cin >>u[i] >>v[i];\n        --u[i];\n        --v[i];\n    }\n\n    p /= 100.0;\n\n    vector<double> pw(m+1);\n    pw[0] = 1;\n    rep(i,m) pw[i+1] = pw[i]*p;\n\n    vector<double> dp(1<<n);\n    rep(mask,1<<n){\n        dp[mask] = 1;\n\n        int sub = mask;\n        while(1){\n            sub = (sub-1)&mask;\n            if(sub == 0) break;\n            if(sub%2!=1) continue;\n\n            int o_mask = mask^sub;\n\n            int ct = 0;\n            rep(i,m){\n                if(sub>>u[i]&1){\n                    if(o_mask>>v[i]&1) ++ct;\n                }\n                if(sub>>v[i]&1){\n                    if(o_mask>>u[i]&1) ++ct;\n                }\n            }\n\n            dp[mask] -= dp[sub]*pw[ct];\n        }\n    }\n\n    cout << fixed << setprecision(15) << dp[(1<<n)-1] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\nint N,M,Pe;\ndouble p;\nvector<P> edges;\nint num[1<<15];\ndouble dp[1<<15];\ndouble pow(int x)\n{\n    double res = 1.0;\n    double r = p;\n    while(x)\n    {\n        if(x&1)res*=r;\n        r=r*r;\n        x>>=1;\n    }\n    return res;\n}\ndouble rec(int S)\n{\n    if(dp[S]!=-1.0)return dp[S];\n    if(S==0)return 0.0;\n    double ret = 1.0;\n    vector<int> v;\n    for(int i=0;i<N;i++)if(S&(1<<i))v.pb(i);\n    int sz = v.size();\n    for(int i=1;i<(1<<sz);i++)\n    {\n        int T = S;\n        for(int j=0;j<sz;j++)if(i&(1<<j))T-=(1<<v[j]);\n        if(!(T&1))continue;\n        ret -= rec(T)*pow((num[T]+num[S-T]-num[(1<<N)-1-S])/2);\n        //if(S==(1<<N)-1)cout << T << endl;\n    }\n    return dp[S]=ret;\n}\nint main()\n{\n    scanf(\"%d %d %d\",&N,&M,&Pe);\n    for(int i=0;i<M;i++)\n    {\n        int u,v;\n        scanf(\"%d %d\",&u,&v);\n        u--;v--;\n        edges.pb(P(u,v));\n    }\n    for(int i=0;i<(1<<N);i++)\n    {\n        for(int j=0;j<M;j++)\n        {\n            int u = edges[j].fi;\n            int v = edges[j].sec;\n            if(i&(1<<u) && !(i&(1<<v)))num[i]++;\n            if(i&(1<<v) && !(i&(1<<u)))num[i]++;\n        }\n    }\n    p = Pe/100.0;\n    for(int i=0;i<(1<<N);i++)dp[i]=-1.0;\n    //for(int i=1;i<(1<<N);i++)printf(\"%.12f\\n\",rec(i));\n    printf(\"%.12f\\n\",rec((1<<N)-1));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n#include <bitset>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n/**\n * hash???????????????UnionFind ????´???°???16????????????????????¨??????????????????\n */\ntemplate<int N>\nstruct SUnionFind {\n    int i2g[N];\n    SUnionFind() {\n        for (int i = 0; i < N; i++) {\n            i2g[i] = i;\n        }\n    }\n    SUnionFind(ull hs) {\n        for (int i = 0; i < N; i++) {\n            i2g[i] = hs & 0xf;\n            hs >>= 4;\n        }\n    }\n\n    void merge(int x, int y) {\n        int xg = i2g[x], yg = i2g[y];\n        for (int i = 0; i < N; i++) {\n            if (i2g[i] == yg) i2g[i] = xg;\n        }\n    }\n\n    bool same(int x, int y) {\n        return i2g[x] == i2g[y];\n    }\n\n    ull hash() {\n        int b[N];\n        memset(b, -1, sizeof(b));\n        int c = 0;\n        ull hs = 0;\n        for (int i = N-1; i >= 0; i--) {\n            hs <<= 4;\n            if (b[i2g[i]] == -1) {\n                b[i2g[i]] = c;\n                c++;\n            }\n            hs += b[i2g[i]];\n        }\n        return hs;\n    }\n};\n\ntypedef SUnionFind<14> UF;\nint main() {\n    int n, m, pp;\n    cin >> n >> m >> pp;\n    double p = pp / 100.0;\n    unordered_map<ull, double> mp;\n    mp[UF().hash()] = 1.0;\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b; a--; b--;\n        unordered_map<ull, double> mp2;\n        for (auto pa : mp) {\n            ull d; double r;\n            tie(d, r) = pa;\n            UF uf(d);\n            uf.merge(a, b);\n            mp2[d] += r * p;\n            mp2[uf.hash()] += r * (1-p);\n        }\n        mp = mp2;\n    }\n    double res = 0;\n    for (auto p : mp) {\n        UF uf(p.first);\n        bool f = true;\n        for (int i = 1; i < n; i++) {\n            if (!uf.same(0, i)) {\n                f = false;\n                break;\n            }\n        }\n        if (!f) continue;\n        res += p.second;\n    }\n    printf(\"%.20lf\\n\", res);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint V,E;\ndouble P,Q;\nvector<int> G[15];\n \n \nvoid printbit(int S){\n  for(int i=0;i<V;i++){\n    cout<<(S>>i&1)<<' ';\n  }\n  cout<<endl;\n}\n \ndouble func(int S,int U){\n \n  double res=1;\n  for(int i=0;i<V;i++){\n    if(S>>i&1){\n      for(int j=0;j<(int)G[i].size();j++){\n        int w=G[i][j];\n        if(S>>w&1)continue;\n        if(U>>w&1)        res*=P;\n      }\n    }\n  }\n \n \n \n  return res;\n}\n \ndouble dp[(1<<14)];\n \ndouble rec(int S){\n \n  if(dp[S]!=-1)return dp[S];\n  if(S==1)return 1.0;\n \n  double res=0;\n  int sup=S;\n  int sub=sup;\n  \n \n  do{\n    if(sub&1){\n      if(sub!=S){\n        double A=rec(sub);\n        double B=func(sub,S);\n        res+=A*B;\n      }\n    }\n    sub=(sub-1)⊃\n  }while(sub!=sup);\n \n  res=1.0-res;\n \n  return dp[S]=res;\n}\n \nvoid init(){\n  for(int i=0;i<15;i++)G[i].clear();\n  for(int i=0;i<(1<<14);i++){\n    dp[i]=-1;\n  }\n}\n \n \nbool check(){\n  bool visited[15]={};\n  visited[0]=true;\n  queue<int> que;\n  que.push(0);\n \n  while(!que.empty()){\n    int pos=que.front();que.pop();\n    for(int i=0;i<(int)G[pos].size();i++){\n      int w=G[pos][i];\n      if(visited[w])continue;\n      visited[w]=true;\n      que.push(w);\n    }\n  }\n \n  for(int i=0;i<V;i++)\n    if(!visited[i])return false;\n \n  return true;\n}\n \nint main(){\n  while(cin>>V>>E>>P){\n    init();\n    P/=100.0;\n    Q=1.0-P;\n    for(int i=0;i<E;i++){\n      int a,b;\n      cin>>a>>b;\n      a--;b--;\n      G[a].push_back(b);\n      G[b].push_back(a);\n    }\n \n    if(!check()){\n      printf(\"0.0\\n\");\n      continue;\n    }\n    printf(\"%.10f\\n\",rec((1<<V)-1));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\nconst int maxm=200;\n\nint n,m,u,v;\ndouble p;\nint begin[14],end[maxm],next[maxm],k;\ndouble dp[1<<14],x;\nint maxn;\nbool vis[1<<14];\nbool dis[14][14];\n\ndouble dfs(int s)\n{\n    if(vis[s])return dp[s];\n    vis[s]=1;\n    dp[s]=0;\n    for(int i=(s-1)&s;i;i=(i-1)&s)\n    {\n        if((i&(-i))!=(s&(-s)))continue;\n        double x=1;\n        for(u=0;u<n;u++)\n            if(i&(1<<u))\n            {\n                for(v=0;v<n;v++)\n                {\n                    if(!dis[u][v])continue;\n                    if((1<<v)&(s^i))\n                    {\n                        x=x*p;\n                    }\n                }\n            }\n        dp[s]+=dfs(i)*x;\n        //printf(\"%d,%d:%.10f %.10f\\n\",s,i,x,dp[s]);\n    }\n    //printf(\"%d:%.10f\\n\",s,dp[s]);\n    dp[s]=1-dp[s];\n    return dp[s];\n}\n\nvoid insert(const int &u,const int &v)\n{\n    end[k]=v;\n    next[k]=begin[u];\n    begin[u]=k++;\n}\n\nint main()\n{\n    while(scanf(\"%d%d%lf\",&n,&m,&p)==3)\n    {\n        memset(begin,-1,sizeof(begin));\n        p=p/100.0;\n        maxn=(1<<n);\n        for(int i=0;i<maxn;i++)\n            dp[i]=0.0;\n        k=0;\n        memset(dis,0,sizeof(dis));\n        for(int i=0;i<m;i++)\n        {\n            scanf(\"%d%d\",&u,&v);\n            u--;\n            v--;\n            dis[u][v]=dis[v][u]=1;\n            insert(u,v);\n            insert(v,u);\n        }\n        memset(vis,0,sizeof(vis));\n        for(int i=0;i<n;i++)\n            dp[1<<i]=1.0,vis[1<<i]=1;\n        printf(\"%.10f\\n\",dfs(maxn-1));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2345.cc: Network Reliability\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 14;\nconst int NBITS = 1 << MAX_N;\n\n/* typedef */\n\ntypedef pair<int,int> pii;\n\n/* global variables */\n\npii es[MAX_N];\ndouble dp[NBITS];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int n, m;\n  double p;\n  cin >> n >> m >> p;\n\n  int nbits = 1 << n;\n  p /= 100;\n  memset(es, false, sizeof(es));\n\n  for (int i = 0; i < m; i++) {\n    cin >> es[i].first >> es[i].second;\n    es[i].first--, es[i].second--;\n  }\n\n  for (int bits = 0; bits < nbits; bits++) dp[bits] = 0.0;\n  \n  for (int bits = 1; bits < nbits; bits++) {\n    int b0 = 1;\n    for (; ! (bits & b0); b0 <<= 1);\n    dp[bits] = 1.0;\n    \n    for (int s0 = (bits - 1) & bits; s0 != 0; s0 = (s0 - 1) & bits)\n      if (s0 & b0) {\n\tint s1 = bits & ~s0;\n\tdouble pp = dp[s0];\n\tfor (int j = 0; j < m; j++) {\n\t  int &u = es[j].first, &v = es[j].second;\n\t  int bu = 1 << u, bv = 1 << v;\n\t  if ((bits & bu) && (bits & bv) &&\n\t      (((s0 & bu) && ! (s0 & bv)) || ((! (s0 & bu) && (s0 & bv)))))\n\t    pp *= p;\n\t}\n\tdp[bits] -= pp;\n      }\n  }\n\n  printf(\"%.12lf\\n\", dp[nbits - 1]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\nstruct Edge {\n    int src, dst;\n};\nusing Graph = vector<vector<Edge>>;\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n\n    int N, M, P;\n    while (cin >> N >> M >> P) {\n        double p = P/100.0;\n        Graph graph(N);\n        vector<Edge> edges;\n        REP(i, M) {\n            int u, v; cin >> u >> v; --u; --v;\n            edges.push_back((Edge){u, v});\n        }\n\n        vector<double> dp(1<<N);\n        REP(S, 1<<N) {\n            double q = 0;\n            for (int T = (S-1)&S; T; T = (T-1)&S) {\n                if ((T&-T) != (S&-S)) continue;\n                int k = 0;\n                REP(i, M) {\n                    int x = 1 << edges[i].src;\n                    int y = 1 << edges[i].dst;\n                    if ((x&S) && (y&S) && !(x&T) != !(y&T))\n                        ++k;\n                }\n                q += dp[T] * pow(p, k);\n            }\n            dp[S] = 1 - q;\n        }\n        cout << setprecision(12) << dp[(1<<N)-1] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\nusing namespace std;\n\nint n,m,p;\nint a[15][15];\n\nlong double dp[1<<14];\nlong double tmp[1<<14][14];\n\nlong double fact[1<<14][14];\n\n\n\nint main(void){\n\tcin >> n >> m >> p;\n\trep(i,m){\n\t\tint u,v;\n\t\tcin >> u >> v;\n\t\ta[u-1][v-1]++;\n\t\ta[v-1][u-1]++;\n\t}\n\n\trep(i,n) fact[1<<i][0]=1.0;\n\tfor(int mask=1;mask<(1<<n);++mask){\n\t\tfor(int smask=(mask-1)&mask;;smask=(smask-1)&mask){\n\t\t\tint tmask=mask^smask;\n\t\t\tif(tmask>smask) break;\n\t\t\trep(snum,n)rep(tnum,n) if(snum+tnum<n) fact[mask][snum+tnum+1]+=fact[smask][snum]*fact[tmask][tnum];\n\t\t}\n\t}\n\t\n\t// cerr << fact[3][1] << endl;\n\t// cerr << fact[7][2] << endl;\n\t// cerr << fact[15][3] << endl;\n\n\t/*\n\tfor(int i=2;i<n;++i){\n\t\tfact[i]=1.0*(i+1)*i/2.0*fact[i-1]; \n\t\tcerr << fact[i] << endl;\n\t}\n\t*/\n\n\trep(i,n){\n\t\trep(mask,1<<i)rep(j,i+1) tmp[mask][j]=0.0;\n\n\t\tfor(int mask=1;mask<(1<<i);++mask){\n\t\t\tdouble cur=1.0;\n\t\t\trep(j,i) if(mask&(1<<j)) rep(loop,a[j][i]) cur*=1.0*p/100.0; \n\t\t\ttmp[mask][0]=(1.0-cur)*dp[mask];\n\t\t}\n\t\t\n\t\t\n\t\tfor(int mask=1;mask<(1<<i);++mask){\n\t\t\tfor(int smask=(mask-1)&mask;;smask=(smask-1)&mask){\n\t\t\t\tint tmask=mask^smask;\n\t\t\t\tif(tmask>smask) break;\n\t\t\t\tdouble cur=1.0;\n\t\t\t\trep(j,i)rep(k,i) if((smask&(1<<j))&&(tmask&(1<<k))) rep(loop,a[j][k]) cur*=1.0*p/100.0;\n\t\t\t\trep(snum,i+1)rep(tnum,i+1) if(snum+tnum<=i) tmp[mask][snum+tnum+1]+=cur*tmp[smask][snum]*tmp[tmask][tnum];\n\t\t\t}\n\t\t}\n\n\t\ttmp[0][0]=1.0;\n\t\trep(mask,1<<i){\n\t\t\tfor(int num=0;num<=i;++num){\n\t\t\t\t// cerr << mask << \" \" << num << \" \" << tmp[mask][num] << endl;\n \t\t\t\tdp[mask|(1<<i)]+=tmp[mask][num]/fact[(1<<(num+1))-1][num];\n\t\t\t}\n\t\t}\n\n\t}\n\tcout.precision(20);\n\tcout << fixed << dp[(1<<n)-1] << endl;\n\t// rep(mask,1<<n) cerr << mask << \" \" << dp[mask] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int M = 101;\n\nint n,m,p;\nint u[M],v[M];\n\ndouble pp;\n\nmap<vector<int>,double> dp[M];\ndouble dfs(int e, const vector<int> &cc){\n    bool ok = true;\n    rep(i,n)if(cc[i] != 0) ok = false;\n    if(ok) return 1;\n\n    if(e==m) return 0;\n\n    if(dp[e].count(cc)) return dp[e][cc];\n\n    double ret = 0;\n    ret += pp * dfs(e+1,cc);\n\n    vector<int> nc(cc);\n    if(cc[u[e]] != cc[v[e]]){\n        int val = min(cc[u[e]], cc[v[e]]);\n        rep(i,n){\n            if(nc[i] == cc[u[e]] || nc[i] == cc[v[e]]) nc[i] = val;\n        }\n    }\n    ret += (1-pp) * dfs(e+1,nc);\n\n    return dp[e][cc] = ret;\n}\n\nint main(){\n    cin >>n >>m >>p;\n    rep(i,m){\n        cin >>u[i] >>v[i];\n        --u[i];\n        --v[i];\n    }\n\n    pp = p/100.0;\n\n    vector<int> s(n);\n    rep(i,n) s[i] = i;\n    printf(\"%.15f\\n\", dfs(0,s));\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 14;\n\nint sm[(1 << MAX_N)];\ndouble dp[(1 << MAX_N)];\ndouble pp[101];\n\nint main()\n{\n    int n,m,p;\n    scanf(\"%d%d%d\",&n,&m,&p);\n    pp[0] = 1;\n    vp edge(m);\n    rep(i,m){\n        pp[i+1] = pp[i] * (p / 100.0);\n        scanf(\"%d%d\",&edge[i].fi,&edge[i].se);\n    }\n    rep(i,(1 << n)){\n        int res = 0;\n        rep(j,m){\n            int u = edge[j].fi - 1,v = edge[j].se - 1;\n            if((i >> u) & (i >> v) & 1){\n                res++;\n            }\n        }\n        sm[i] = res;\n    }\n    for(int S=1;S<(1 << n);S=(S+1)|1){\n        double res = 0;\n        for(int T=S;T>0;T=(T-1)&S){\n            res += dp[T]*pp[sm[S]-sm[T]-sm[S^T]];\n        }\n        dp[S] = 1.0 - res;\n    }\n    printf(\"%.12lf\\n\",dp[(1 << n)-1]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <cassert>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <string>\n#include <algorithm>\n#include <utility>\n#define llint long long\n#define inf 1e18\n#define rep(x, s, t) for(llint (x) = (s); (x) < (t); (x)++)\n#define Rep(x, s, t) for(llint (x) = (s); (x) <= (t); (x)++)\n#define chmin(x, y) (x) = min((x), (y))\n#define chmax(x, y) (x) = max((x), (y))\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nllint n, m;\ndouble p;\nvector<llint> G[20];\nllint in[1<<14];\ndouble dp[1<<14];\n\nint main(void)\n{\n\t//ios::sync_with_stdio(0);\n\t//cin.tie(0);\n\t\n\tcin >> n >> m >> p;\n\tp /= 100;\n\t\n\tllint u, v;\n\tfor(int i = 0; i < m; i++){\n\t\tcin >> u >> v;\n\t\tu--, v--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\t\n\tllint N = 1<<n;\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tif((i & (1<<j)) == 0) continue;\n\t\t\tfor(int k = 0; k < G[j].size(); k++){\n\t\t\t\tif(i & (1<<G[j][k])) in[i]++;\n\t\t\t}\n\t\t}\n\t\tin[i] /= 2;\n\t}\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tif((i & 1) == 0) continue;\n\t\tdp[i] = 1;\n\t\tfor(int j = (i-1)&i; j > 0; j = (j-1)&i){\n\t\t\tif((j & 1) == 0) continue;\n\t\t\tdp[i] -= dp[j]*pow(p, in[i]-(in[i-j]+in[j]));\n\t\t}\n\t}\n\tprintf(\"%.11f\\n\", dp[N-1]);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 15\n\nint V,E;\nint POW[NUM];\nint num_edge[NUM][NUM];\ndouble dp[16384];\ndouble P,P_POW[101];\n\nint main(){\n\n\tfor(int i = 0; i < NUM; i++)POW[i] = pow(2,i);\n\n\tscanf(\"%d %d %lf\",&V,&E,&P);\n\n\tP /= 100.0;\n\n\tP_POW[0] = 1.0;\n\tfor(int i = 1; i <= 100; i++)P_POW[i] = P*P_POW[i-1];\n\n\tfor(int i = 0; i < V; i++){\n\t\tfor(int k = 0; k < V; k++)num_edge[i][k] = 0;\n\t}\n\n\tint from,to;\n\tfor(int loop = 0; loop < E; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tfrom--;\n\t\tto--;\n\t\tnum_edge[from][to]++;\n\t\tnum_edge[to][from]++;\n\t}\n\n\tint num_node,sub_state,num_del_edge,base_node;\n\tvector<int> G,sub_G;\n\n\tfor(int state = 1; state < POW[V]; state++){\n\t\tnum_node = 0;\n\t\tG.clear();\n\n\t\tdp[state] = 1.0;\n\n\t\tfor(int loop = 0; loop < V; loop++){\n\t\t\tif(state & (1 << loop)){\n\t\t\t\tG.push_back(loop);\n\t\t\t\tbase_node = loop;\n\t\t\t\tnum_node++;\n\t\t\t}\n\t\t}\n\t\tif(num_node == 1){\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(int i = 1; i < POW[num_node]-1; i++){\n\n\t\t\tsub_state = 0;\n\t\t\tsub_G.clear();\n\n\t\t\tfor(int loop = 0; loop < num_node; loop++){\n\t\t\t\tif(i & (1 << loop)){\n\t\t\t\t\tsub_state += POW[G[loop]];\n\t\t\t\t\tsub_G.push_back(G[loop]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif((sub_state & (POW[base_node]))  == 0)continue;\n\n\t\t\tnum_del_edge = 0;\n\n\t\t\tfor(int k = 0; k < sub_G.size(); k++){\n\t\t\t\tfor(int a = 0; a < G.size(); a++){\n\t\t\t\t\tif(POW[G[a]] & sub_state)continue;\n\n\t\t\t\t\tnum_del_edge += num_edge[sub_G[k]][G[a]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[state] -= dp[sub_state]*P_POW[num_del_edge];\n\t\t}\n\t}\n\n\tprintf(\"%.10lf\\n\",dp[POW[V]-1]);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n, m;\n    double p;\n    cin >> n >> m >> p;\n    p /= 100;\n    vector<int> cnt(1 << n);\n    for(int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        for(int S = 0; S < (1 << n); ++S) {\n            if((S & (1 << a)) && (S & (1 << b))) {\n                cnt[S]++;\n            }\n        }\n    }\n    vector<double> dp(1 << n, 1);\n    for(int S = 1; S < (1 << n); ++S) {\n        if(!(S & 1)) continue;\n        for(int T = S & (S - 1); T > 0; T = (T - 1) & S) {\n            if(!(T & 1)) continue;\n            dp[S] -= dp[T] * pow(p, cnt[S] - cnt[T] - cnt[(~T) & S]);\n        }\n    }\n    cout << fixed << setprecision(10) << dp.back() << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n#define bit(x) (1<<(x))\nusing namespace std;\n\nint n,m,p;\nint a[15][15];\n\nusing R=long double;\nR dp[1<<14];\n\nint main(void){\n\tcin >> n >> m >> p;\n\trep(i,m){\n\t\tint u,v;\n\t\tcin >> u >> v;\n\t\ta[u-1][v-1]++;\n\t\ta[v-1][u-1]++;\n\t}\n\n\trep(mask,1,1<<n){\n\t\tdp[mask]=1.0;\t\t\n\t\tif(__builtin_popcount(mask)==1) continue;\n\t\tfor(int add=(mask-1)&mask;add>=limit;add=(add-1)&mask){\n\t\t\tint root=add^mask;\n\t\t\tif(add<root) break;\n\t\t\tdouble cur=dp[add];\n\t\t\trep(i,n)rep(j,n) if(root&bit(i)) if(add&bit(j)) rep(loop,a[i][j]) cur*=1.0*p/100.0; \n\t\t\tdp[mask]-=cur;\t\n\t\t}\n\t}\n\n\tcout.precision(20);\n\tcout << fixed << dp[bit(n)-1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef long long ll;\n\nconst int    INF = 1000000000;\nconst int    MOD = 1000000007;\nconst double EPS = 1e-8;\nstruct UF{\n    vector<int> data;\n    UF(int N) : data(N) { iota(data.begin(), data.end(), 0); }\n    int root(int x){\n        if(data[x] == x) return x;\n        return data[x] = root(data[x]);\n    }\n    void uni(int x, int y){\n        x = root(x);\n        y = root(y);\n        if(x > y) swap(x, y);\n        data[y] = x;\n        normalize();\n    }\n    void normalize(){\n        for(int i = 0; i < data.size(); i++){\n            root(i);\n        }\n    }\n    bool operator < (const UF& u) const {\n        for(int i = 0; i < data.size(); i++){\n            if(data[i] != u.data[i]) return data[i] < u.data[i];\n        }\n        return false;\n    }\n};\n\nint main(){\n    int N, M, P;\n    while(cin >> N >> M >> P){\n        double prob = (100.0 - P) / 100.0; // connect\n        map<UF, double> dp;\n        dp[ UF(N) ] = 1.0;\n        REP(_, M){\n            int x, y;\n            cin >> x >> y;\n            x--; y--;\n            map<UF, double>  next;\n            for(auto& p : dp){\n                next[ p.first ] += p.second * (1.0 - prob);\n                UF uf = p.first;\n                uf.uni(x, y);\n                next[ uf ] += p.second * prob;\n            }\n            dp.swap(next);\n        }\n        UF goal(N);\n        for(int i = 1; i < N; i++) goal.uni(0, i);\n        printf(\"%.12f\\n\", dp[ goal ]);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nint N, M;\ndouble P;\nint A[100];\nint B[100];\nint hit(int k) {\n    return 1 << k;\n}\n\nconst double None = 1e-100;\n\ndouble prob(int s, int V);\n\n// sが連結になる確率\ndouble memo[1 << 14];\ndouble calc(int s) {\n    double& res = memo[s];\n    if(res != None) return res;\n    res = 1.0;\n    int sub = s;\n    do{\n        //if(sub != s) printf(\"s = %d sub = %d prob = %f\\n\", s, sub, prob(sub, s));\n        if(sub != s) res -= prob(sub, s);\n        // do something here\n        sub = (sub - 1) & s;\n    } while(sub != s);\n    //printf(\"calc(%d) -> %f\\n\", s, res);\n    return res;\n}\n\n// V(v0) が s になる確率\nmap<int, double> memo2[1 << 14];\ndouble prob(int s, int V) {\n    if(!(s >> 0 & 1)) return 0.0;\n\n    if(memo2[V].count(s)) return memo2[V][s];\n\n    double res = calc(s);\n\n    for(int i = 0; i < M; i++) {\n        if(!(V & hit(A[i]))) continue;\n        if(!(V & hit(B[i]))) continue;\n        int fa = (s & hit(A[i]) ? 1 : 0);\n        int fb = (s & hit(B[i]) ? 1 : 0);\n        if(fa != fb) {\n            res *= P;\n        }\n    }\n\n    return memo2[V][s] = res;\n}\n\nint main(){\n    while(cin >> N >> M >> P && N > 0) {\n        REP(i, 1 << N) memo[i] = None;\n        REP(i, 1 << N) memo2[i].clear();\n\n        P /= 100.0;\n\n        REP(i, M) cin >> A[i] >> B[i];\n        REP(i, M) A[i] --;\n        REP(i, M) B[i] --;\n\n        printf(\"%.12f\\n\", calc((1 << N) - 1));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\nusing namespace std;\n\nint n,m,p;\nbool a[15][15];\n\ndouble dp[1<<14];\ndouble tmp[1<<14];\n\nint main(void){\n\tcin >> n >> m >> p;\n\trep(i,m){\n\t\tint u,v;\n\t\tcin >> u >> v;\n\t\ta[u-1][v-1]=a[v-1][u-1]=true;\n\t}\n\n\trep(i,n){\n\t\trep(mask,1<<i) tmp[mask]=0.0;\n\t\trep(mask,1<<i){\n\t\t\tdouble cur=1.0;\n\t\t\trep(j,i) if((mask&(1<<j))&&a[j][i]) cur*=1.0*p/100.0; \n\t\t\ttmp[mask]=(1.0-cur)*dp[mask];\n\t\t}\n\t\t\n\t\trep(mask,1<<i){\n\t\t\tfor(int smask=(mask-1)&mask;smask>0;smask=(smask-1)&mask){\n\t\t\t\tint tmask=mask^smask;\n\t\t\t\tif(tmask>smask) break;\n\t\t\t\tdouble cur=1.0;\n\t\t\t\trep(j,i)rep(k,i) if((smask&(1<<j))&&(tmask&(1<<k))&&a[j][k]) cur*=1.0*p/100.0;\n\t\t\t\ttmp[mask]+=cur*tmp[smask]*tmp[tmask];\n\t\t\t}\n\t\t}\n\t\ttmp[0]=1.0;\n\t\trep(mask,1<<i) dp[mask|(1<<i)]=tmp[mask];\n\t}\n\tcout.precision(20);\n\tcout << fixed << dp[(1<<n)-1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nint N, M; double P;\nint U[109], V[109], K[1 << 14]; vector<int> X[109];\ndouble dp[1 << 14], power[1 << 14];\n\nvoid init() {\n\tfor (int i = 0; i < (1 << N); i++) {\n\t\tint cnts = 0;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tif ((i / (1 << U[j])) % 2 == 1 && (i / (1 << V[j])) % 2 == 1) cnts++;\n\t\t}\n\t\tK[i] = cnts;\n\t}\n\tfor (int i = 0; i < 109; i++) power[i] = pow(P, 1.0 * i);\n}\n\nint main() {\n\tcin >> N >> M >> P; P = 0.01 * P;\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> U[i] >> V[i]; U[i]--; V[i]--;\n\t\tX[U[i]].push_back(V[i]);\n\t\tX[V[i]].push_back(U[i]);\n\t}\n\n\tinit();\n\n\tfor (int i = 1; i < (1 << N); i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tif ((i & j) != 0) continue;\n\n\t\t\tdouble prob1 = (1.0 - dp[i]);\n\t\t\tint s2 = K[i + j] - K[i] - K[j];\n\t\t\tdouble prob2 = power[s2];\n\t\t\t\n\t\t\tdp[i + j] += prob1 * prob2;\n\t\t}\n\t}\n\tprintf(\"%.12lf\\n\", 1.0 - dp[(1 << N) - 1]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// haaaaaaaaaaaaard\n\n#include<cmath>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint main(){\n\tint n,m;\n\tdouble p; scanf(\"%d%d%lf\",&n,&m,&p);\n\tp/=100;\n\n\tint e[1<<14]={}; // e[S] := ( S から V\\S へ出ている辺の本数 )\n\trep(i,m){\n\t\tint u,v; scanf(\"%d%d\",&u,&v); u--; v--;\n\t\trep(S,1<<n){\n\t\t\tif(S&1<<u && (S&1<<v)==0) e[S]++;\n\t\t\tif(S&1<<v && (S&1<<u)==0) e[S]++;\n\t\t}\n\t}\n\n\t// dp[S] := ( V の部分集合 S が連結になる確率 )\n\t// ここで、S と V-S のつながり方については気にしていない\n\tdouble dp[1<<14];\n\trep(S,1<<n){\n\t\t// S に含まれる頂点(どれでもいい)を一つ固定する\n\t\tint u0;\n\t\trep(u,n) if(S&1<<u) u0=u;\n\n\t\t// S を頂点集合とみた部分グラフに制限して考える。\n\t\t//   dp[S] = ( u0 を含む連結成分が S である確率 )\n\t\t// と\n\t\t//   Σ_{T \\subset S, u0 \\in T} ( u0 を含む連結成分が T である確率 ) = 1\n\t\t// より、移項して dp[S] についての漸化式\n\t\t//   dp[S] = 1 - Σ_{T \\subset S, u0 \\in T, T!=S} ( u0 を含む連結成分が T である確率 )\n\t\t// を得る。\n\t\t// さらに\n\t\t//   ( u0 を含む連結成分が T である確率 )\n\t\t// = ( T が連結になる確率 ) * p^k\n\t\t// = dp[T] * p^k, ( k は T と S\\T の間にある辺の本数 )\n\t\t// なので\n\t\t//   dp[S] = 1 - Σ_{T \\subset S, u0 \\in T, T!=S} dp[T] * p^k\n\t\t// となる。\n\t\tdp[S]=1;\n\t\tfor(int T=(S-1)&S;T>0;T=(T-1)&S) if(T&1<<u0) {\n\t\t\tdp[S]-=dp[T]*pow(p,(e[T]+e[S-T]-e[S])/2);\n\t\t}\n\t}\n\n\tprintf(\"%.15f\\n\",dp[(1<<n)-1]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\nconst int MAXN = 14;\nconst int MAXS = 1 << MAXN;\n\nint n, m;\nbool adj[MAXN][MAXN];\ndouble p, f[MAXS];\n\nint lowbit(int x) {\n\n    return x & -x;\n}\n\nint main() {\n\n    //freopen(\"in\", \"r\", stdin);\n    scanf(\"%d %d %lf\", &n, &m, &p);\n    p /= 100;\n    int u, v;\n    for (int i = 0; i < m; i++)\n    {\n        scanf(\"%d %d\", &u, &v);\n        u--, v--;\n        adj[u][v] = adj[v][u] = true;\n    }\n\n    int range = 1 << n;\n    for (int i = 0; i < range; i++)\n    {\n        if (!(i & (i - 1))) f[i] = 0;\n        else\n        {\n            f[i] = 0;\n            int t = i, cnt = 0;\n            while (t) ++cnt, t -= lowbit(t);\n            for (int j = 0; j < n; j++)\n                if ((i >> j) & 1) { u = j; break; }\n            int range_j = 1 << (cnt - 1);\n            for (int j = 0; j < range_j - 1; j++)\n            {\n                t = i - lowbit(i);\n                int subset = 0, lb;\n                double val = 1;\n                for (int k = 0; k < cnt - 1; k++)\n                {\n                    lb = lowbit(t);\n                    if ((j >> k) & 1) subset |= lb;\n                    t -= lb;\n                }\n                subset |= 1 << u;\n                int not_subset = i ^ subset;\n                for (int x = 0; x < n; x++)\n                    if ((subset >> x) & 1)\n                        for (int v = 0; v < n; v++)\n                            if (((not_subset >> v) & 1) && adj[x][v]) val *=p;\n                val *= 1 - f[subset];\n                f[i] += val;\n            }\n          //  f[i] /= range_j;\n        }\n    }\n/*\n    for (int i = 0; i < range; i++)\n    {\n        printf(\"f[%d] = %lf\\n\", i, f[i]);\n    }\n    */\n    printf(\"%.10f\\n\", 1 - f[range - 1]);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nint N, M;\ndouble P;\nint A[100];\nint B[100];\nint hit(int k) {\n    return 1 << k;\n}\n\nconst double None = 1e-100;\n\ndouble prob(int s, int V);\n\n// sが連結になる確率\ndouble memo[1 << 14];\ndouble calc(int s) {\n    double& res = memo[s];\n    if(res != None) return res;\n    res = 1.0;\n    int sub = s;\n    do{\n        //if(sub != s) printf(\"s = %d sub = %d prob = %f\\n\", s, sub, prob(sub, s));\n        if(sub != s) res -= prob(sub, s);\n        // do something here\n        sub = (sub - 1) & s;\n    } while(sub != s);\n    //printf(\"calc(%d) -> %f\\n\", s, res);\n    return res;\n}\n\n// V(v0) が s になる確率\n//map<int, double> memo2[1 << 14];\ndouble prob(int s, int V) {\n    if(!(s >> 0 & 1)) return 0.0;\n\n    //if(memo2[V].count(s)) return memo2[V][s];\n\n    double res = calc(s);\n\n    for(int i = 0; i < M; i++) {\n        if(!(V & hit(A[i]))) continue;\n        if(!(V & hit(B[i]))) continue;\n        int fa = (s & hit(A[i]) ? 1 : 0);\n        int fb = (s & hit(B[i]) ? 1 : 0);\n        if(fa != fb) {\n            res *= P;\n        }\n    }\n\n    return res;\n}\n\nint main(){\n    while(cin >> N >> M >> P && N > 0) {\n        REP(i, 1 << N) memo[i] = None;\n       // REP(i, 1 << N) memo2[i].clear();\n\n        P /= 100.0;\n\n        REP(i, M) cin >> A[i] >> B[i];\n        REP(i, M) A[i] --;\n        REP(i, M) B[i] --;\n\n        printf(\"%.12f\\n\", calc((1 << N) - 1));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint N,M;\ndouble P;\nint u[111],v[111];\ndouble dp[1<<14];\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>N>>M>>P;\n\tP/=100;\n\trep(i,M)cin>>u[i]>>v[i],u[i]--,v[i]--;\n\t\n\trep2(mask,1,1<<N){\n\t\t\n\t\tif(__builtin_popcount(mask)==1){\n\t\t\tdp[mask]=1;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tdp[mask]=1;\n\t\tint par=N-1;\n\t\twhile(!(mask>>par&1))par--;\n\t\tint sub=mask,e;\n\t\t\n\t\twhile(1){\n\t\t\tsub=(sub-1)&mask;\n\t\t\te=0;\n\t\t\trep(i,M){\n\t\t\t\tif((sub>>u[i]&1) && !(sub>>v[i]&1) && (mask>>v[i]&1)\n\t\t\t\t|| (sub>>v[i]&1) && !(sub>>u[i]&1) && (mask>>u[i]&1))e++;\n\t\t\t}\n\t\t\t//cout<<mask<<\" - \"<<dp[sub]<<\" * \"<<pow(P,e)<<endl;\n\t\t\tdp[mask]-=dp[sub]*pow(P,e);\n\t\t\tif(sub==(1<<par))break;\n\t\t}\n\t\t\n\t\t//cout<<mask<<\" \"<<dp[mask]<<endl;\n\t}\n\t//cout<<setprecision(16)<<dp[(1<<N)-1]<<endl;\n\tprintf(\"%.16f\\n\",dp[(1<<N)-1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint V,E;\ndouble P,Q;\nvector<int> G[15];\n \n \nvoid printbit(int S){\n  for(int i=0;i<V;i++){\n    cout<<(S>>i&1)<<' ';\n  }\n  cout<<endl;\n}\n \ndouble func(int S,int U){\n \n  double res=1;\n  for(int i=0;i<V;i++){\n    if(S>>i&1){\n      for(int j=0;j<(int)G[i].size();j++){\n        int w=G[i][j];\n        if(S>>w&1)continue;\n        if(U>>w&1)        res*=P;\n      }\n    }\n  }\n \n \n \n  return res;\n}\n \ndouble dp[(1<<14)];\n \ndouble rec(int S){\n \n  if(dp[S]!=-1)return dp[S];\n  if(S==1)return 1.0;\n \n  double res=0;\n  int sup=S;\n  int sub=sup;\n  \n \n  do{\n    if(sub&1){\n      if(sub!=S){\n        double A=rec(sub);\n        double B=func(sub,S);\n        res+=A*B;\n      }\n    }\n    sub=(sub-1)&sup;\n  }while(sub!=sup);\n \n  res=1.0-res;\n \n  return dp[S]=res;\n}\n \nvoid init(){\n  for(int i=0;i<15;i++)G[i].clear();\n  for(int i=0;i<(1<<14);i++){\n    dp[i]=-1;\n  }\n}\n \n \nbool check(){\n  bool visited[15]={};\n  visited[0]=true;\n  queue<int> que;\n  que.push(0);\n \n  while(!que.empty()){\n    int pos=que.front();que.pop();\n    for(int i=0;i<(int)G[pos].size();i++){\n      int w=G[pos][i];\n      if(visited[w])continue;\n      visited[w]=true;\n      que.push(w);\n    }\n  }\n \n  for(int i=0;i<V;i++)\n    if(!visited[i])return false;\n \n  return true;\n}\n \nint main(){\n  while(cin>>V>>E>>P){\n    init();\n    P/=100.0;\n    Q=1.0-P;\n    for(int i=0;i<E;i++){\n      int a,b;\n      cin>>a>>b;\n      a--;b--;\n      G[a].push_back(b);\n      G[b].push_back(a);\n    }\n \n    if(!check()){\n      printf(\"0.0\\n\");\n      continue;\n    }\n    printf(\"%.10f\\n\",rec((1<<V)-1));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nint N,M;\ndouble P;\nint u[111],v[111];\ndouble dp[1<<14];\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>N>>M>>P;\n\tP/=100;\n\trep(i,M)cin>>u[i]>>v[i],u[i]--,v[i]--;\n\t\n\trep2(mask,1,1<<N){\n\t\t\n\t\tif(__builtin_popcount(mask)==1){\n\t\t\tdp[mask]=1;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tdp[mask]=1;\n\t\tint par=N-1;\n\t\twhile(!(mask>>par&1))par--;\n\t\tint sub=mask,e;\n\t\t\n\t\twhile(1){\n\t\t\tsub=(sub-1)&mask;\n\t\t\te=0;\n\t\t\trep(i,M){\n\t\t\t\tif((sub>>u[i]&1) && !(sub>>v[i]&1) && (mask>>v[i]&1)\n\t\t\t\t|| (sub>>v[i]&1) && !(sub>>u[i]&1) && (mask>>u[i]&1))e++;\n\t\t\t}\n\t\t\t//cout<<mask<<\" - \"<<dp[sub]<<\" * \"<<pow(P,e)<<endl;\n\t\t\tdp[mask]-=dp[sub]*pow(P,e);\n\t\t\tif(sub==(1<<par))break;\n\t\t}\n\t\t\n\t\t//cout<<mask<<\" \"<<dp[mask]<<endl;\n\t}\n\tcout<<setprecision(16)<<dp[(1<<N)-1]<<endl;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2345: Network Reliability\n// 2017.10.24 bal4u@uu\n\n#include <stdio.h>\n\nint u[102], v[102];\ndouble dp[16500];\n\nint main()\n{\n\tint n, m, i, j, k, l, lim;\n\tdouble p, t;\n\n\tscanf(\"%d%d%lf\", &n, &m, &p); p /= 100;\n\tfor (i = 0; i < m; i++) scanf(\"%d%d\", u+i, v+i), u[i]--, v[i]--;\n\tlim = 1 << n;\n\tfor (i = 1; i < lim; i++) {\n\t\tfor (l = 1; !(l & i); l<<=1);\n\t\tdp[i] = 1;\n\t\tfor (k = i; k; k = (k - 1) & i) {\n\t\t\tif (k == i || !(k & l)) continue;\n\t\t\tt = dp[k];\n\t\t\tfor (j = 0; j < m; j++) {\n\t\t\t\tif ((i & (1<<u[j])) && (i & (1<<v[j])) && ((k>>u[j]) & 1) != ((k>>v[j]) & 1))\n\t\t\t\t\tt *= p;\n\t\t\t}\n\t\t\tdp[i] -= t;\n\t\t}\n\t}\n\tprintf(\"%.12f\\n\",dp[lim - 1]);\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tvoid solver() {\n\t\tint N = ni();\n\t\tint M = ni();\n\t\tint P = ni();\n\t\tint[] u = new int[M];\n\t\tint[] v = new int[M];\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tu[i] = ni() - 1;\n\t\t\tv[i] = ni() - 1;\n\t\t}\n\t\tdouble[] dp = new double[1 << N];\n\t\tdp[0] = 0;\n\t\tfor (int i = 1; i < (1 << N); i++) {\n\t\t\tdp[i] = 1;\n\t\t\tif (Integer.bitCount(i) == 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint g = 0;\n\t\t\twhile (((i >> g) & 1) != 1)\n\t\t\t\tg++;\n\t\t\tfor (int s = (i - 1) & i; s > 0; s = ((s - 1) & i)) {\n\t\t\t\tif (((s >> g) & 1) == 1) {\n\t\t\t\t\tint t = s ^ i;\n\t\t\t\t\tint q = 0;\n\t\t\t\t\tfor (int j = 0; j < M; j++) {\n\t\t\t\t\t\tif ((((s >> u[j]) & 1) == 1) && ((t >> v[j]) & 1) == 1) {\n\t\t\t\t\t\t\tq++;\n\t\t\t\t\t\t} else if ((((s >> v[j]) & 1) == 1) && ((t >> u[j]) & 1) == 1) {\n\t\t\t\t\t\t\tq++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[i] -= Math.pow((double) P / 100, q) * dp[s];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(dp[(1 << N) - 1]);\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tvoid solver() {\n\t\tint N = ni();\n\t\tint M = ni();\n\t\tint P = ni();\n\t\tint[] u = new int[M];\n\t\tint[] v = new int[M];\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tu[i] = ni() - 1;\n\t\t\tv[i] = ni() - 1;\n\t\t}\n\t\tdouble[] dp = new double[1 << N];\n\t\tdp[0] = 0;\n\t\tfor (int i = 1; i < (1 << N); i++) {\n\t\t\tdp[i] = 1;\n\t\t\tif (Integer.bitCount(i) == 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint g = 0;\n\t\t\twhile (((i >> g) & 1) != 1)\n\t\t\t\tg++;\n\t\t\tfor (int s = (i - 1) & i; s > 0; s = ((s - 1) & i)) {\n\t\t\t\tif (((s >> g) & 1) == 1) {\n\t\t\t\t\tint t = s ^ i;\n\t\t\t\t\tint q = 0;\n\t\t\t\t\tfor (int j = 0; j < M; j++) {\n\t\t\t\t\t\tif ((((s >> u[j]) & 1) == 1) && ((t >> v[j]) & 1) == 1) {\n\t\t\t\t\t\t\tq++;\n\t\t\t\t\t\t} else if ((((s >> v[j]) & 1) == 1) && ((t >> u[j]) & 1) == 1) {\n\t\t\t\t\t\t\tq++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[i] -= Math.pow((double) P / 100, q) * dp[s];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.printf(\"%.20f\", dp[(1<<N)-1]);\n//\t\tout.println(dp[(1 << N) - 1]);\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tvoid solver() {\n\t\tint N = ni();\n\t\tint M = ni();\n\t\tint P = ni();\n\t\tint[] u = new int[M];\n\t\tint[] v = new int[M];\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tu[i] = ni() - 1;\n\t\t\tv[i] = ni() - 1;\n\t\t}\n\t\tdouble[] dp = new double[1 << N];\n\t\tdp[0] = 0;\n\t\tfor (int i = 1; i < (1 << N); i++) {\n\t\t\tdp[i] = 1;\n\t\t\tif (Integer.bitCount(i) == 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint g = 0;\n\t\t\twhile (((i >> g) & 1) != 1)\n\t\t\t\tg++;\n\t\t\tfor (int s = (i - 1) & i; s > 0; s = ((s - 1) & i)) {\n\t\t\t\tif (((s >> g) & 1) == 1) {\n\t\t\t\t\tint t = s ^ i;\n\t\t\t\t\tint q = 0;\n\t\t\t\t\tfor (int j = 0; j < M; j++) {\n\t\t\t\t\t\tif ((((s >> u[j]) & 1) == 1) && ((t >> v[j]) & 1) == 1) {\n\t\t\t\t\t\t\tq++;\n\t\t\t\t\t\t} else if ((((s >> v[j]) & 1) == 1) && ((t >> u[j]) & 1) == 1) {\n\t\t\t\t\t\t\tq++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdp[i] -= Math.pow((double) P / 100, q) * dp[s];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.printf(\"%.20f\", dp[(1<<N)-1]);\n//\t\tout.println(dp[(1 << N) - 1]);\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing StringBuilder = System.Text.StringBuilder;\n//using System.Numerics;\n//using Point = System.Numerics.Complex;\nusing Number = System.Int64;\nnamespace Program\n{\n    public class Solver\n    {\n        public void Solve()\n        {\n            var n = sc.Integer();\n            var m = sc.Integer();\n            var p = sc.Integer() / 100.0;\n            var a = new int[m];\n            var b = new int[m];\n            var E = new int[1 << n];\n            for (int i = 0; i < m; i++)\n            {\n                a[i] = sc.Integer() - 1;\n                b[i] = sc.Integer() - 1;\n                for (int j = 0; j < 1 << n; j++)\n                    if (((j >> a[i]) & 1) == 1 && ((j >> b[i] & 1) == 1)) E[j]++;\n            }\n            var dp = new double[1 << n];\n            for (int i = 0; i < 1 << n; i++)\n                dp[i] = -1;\n            Func<int, double> dfs = null;\n            dfs = s =>\n              {\n                  if (dp[s] > -0.5) return dp[s];\n                  var ret = 1.0;\n                  var min = s & -s;\n                  for (int sub = (s - 1) & s; sub > 0; sub = (sub - 1) & s)\n                  {\n                      if (min != (sub & -sub)) continue;\n                      ret -= dfs(sub) * Math.Pow(p, E[s] - E[sub] - E[s ^ sub]);\n                  }\n                  return dp[s] = ret;\n              };\n            IO.Printer.Out.WriteLine(\"{0:0.000000000000}\", dfs((1 << n) - 1));\n        }\n\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex\n{\n    //static public string AsString(this IEnumerable<char> ie) { return new string(System.Linq.Enumerable.ToArray(ie)); }\n    //static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") { return string.Join(st, ie); }\n    static public void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer: StreamWriter\n    {\n        static Printer() { Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false }; }\n        public static Printer Out { get; set; }\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, T[] source) { base.Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, T[] source) { base.WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        public int Integer() { return (isEof) ? int.MinValue : (int)Long(); }\n        public double Double() { var s = Scan(); return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN; }\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n) { return enumerate(n, Char); }\n        public string[] Scan(int n) { return enumerate(n, Scan); }\n        public double[] Double(int n) { return enumerate(n, Double); }\n        public int[] Integer(int n) { return enumerate(n, Integer); }\n        public long[] Long(int n) { return enumerate(n, Long); }\n    }\n}\n#endregion\n"
  },
  {
    "language": "Ruby",
    "code": "n, m, q = gets.split.map(&:to_i)\n\nprob = {}\n(1..m).each do\n    i, j = gets.split.map(&:to_i) \n    prob[[i, j]] = q / 100.0\nend\n\ndef f(n, prob)\n    return 1 if n == 1\n    return 0 if disconnected?(n, prob)\n    i, j = prob.keys[0]\n\n    new_prob = prob.dup\n    new_prob.delete([i, j])\n    ans = prob[[i, j]] * f(n, new_prob)\n\n    new_prob = Hash.new(1.0)\n    prob.each do |key, q|\n        u, v = key\n        next if key == [i, j]\n        u = j if key[0] == i\n        v = j if key[1] == i\n        new_prob[[u, v].sort] *= prob[key]\n    end\n\n    ans += (1.0 - prob[[i,j]]) * f(n-1, new_prob)\nend\n\ndef disconnected?(n, prob)\n    vs = prob.keys.flatten.uniq\n    cc = Hash[*vs.zip(vs).flatten]\n    return true if cc.size != n\n    prob.keys.each do |i, j|\n        cc1 = cc[i]\n        cc2 = cc[j]\n        cc.each do |k, c|\n            cc[k] = cc2 if c == cc1\n        end\n    end\n    cc.values.uniq.size > 1\nend\n\nprintf(\"%.12f\\n\", f(n, prob))\n\n"
  },
  {
    "language": "Ruby",
    "code": "n, m, q = gets.split.map(&:to_i)\n\nprob = {}\n(1..m).each do\n    i, j = gets.split.map(&:to_i) \n    prob[[i, j]] = q / 100.0\nend\n\ndef f(n, prob)\n    return 1 if n == 1\n    return 0 if disconnected?(n, prob)\n    i, j = prob.keys[0]\n\n    new_prob = prob.dup\n    new_prob.delete([i, j])\n    ans = prob[[i, j]] * f(n, new_prob)\n\n    new_prob = Hash.new(1.0)\n    prob.each do |key, q|\n        u, v = key\n        x, y = key\n        next if key == [i, j]\n        x = j if u == i\n        y = j if v == i\n        new_prob[[x, y]] *= prob[[u, v]]\n    end\n\n    ans += (1.0 - prob[[i,j]]) * f(n-1, new_prob)\nend\n\ndef disconnected?(n, prob)\n    vs = prob.keys.flatten.uniq\n    cc = Hash[*vs.zip(vs).flatten]\n    return true if cc.size != n\n    prob.keys.each do |i, j|\n        cc1 = cc[i]\n        cc2 = cc[j]\n        cc.each do |k, c|\n            cc[k] = cc2 if c == cc1\n        end\n    end\n    cc.values.uniq.size > 1\nend\n\np f(n, prob)\n\n"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nn, m, P = gets.split.map(&:to_i)\n\nedges = Hash.new(1)\nm.times do\n    u, v = gets.split.map(&:to_i)\n    key = Set[u, v]\n    edges[key] *= P / 100.0\nend\n\n\ndef f(edges, n)\n    return 1.0 if n == 1\n    return 0.0 if ! connected(edges, n)\n    e = edges.keys[0]\n    u0, v0 = e.to_a\n    q = edges[e]\n\n    deleted = edges.dup\n    deleted.delete(e)\n\n    contracted = Hash.new(1)\n    edges.each do |f, prob|\n        next if f == e\n        u, v = f.to_a\n        u = u0 if u == v0\n        v = u0 if v == v0\n        key = Set[u, v]\n        contracted[key] *= prob\n    end\n\n    return q * f(deleted, n) + (1-q) * f(contracted, n-1)\nend\n\n\ndef connected(edges, n)\n    return true if n == 1\n    return false if edges.size < n - 1\n    components = []\n    edges.each_key do |key|\n        u, v = key.to_a\n        cc1 = components.find {|cc| cc.include?(u)}\n        cc2 = components.find {|cc| cc.include?(v)}\n        if !cc1 && !cc2\n            components << Set[u, v]\n        elsif cc1 && cc2\n            if cc1 != cc2\n                cc2.each {|w| cc1 << w}\n                components.delete(cc2)\n            end\n        elsif cc1\n            cc1 << v\n        else\n            cc2 << u\n        end\n    end\n    !components.empty? && components[0].size == n\nend\n\nprintf(\"%.10f\\n\", f(edges, n).to_f)"
  },
  {
    "language": "Ruby",
    "code": "n, m, q = gets.split.map(&:to_i)\n\nprob = {}\n(1..m).each do\n    i, j = gets.split.map(&:to_i) \n    i, j = [i, j].sort\n    prob[(i << 4) + j] = q / 100.0\nend\n\ndef f(n, prob)\n    return 1.0 if n == 1\n    return 0.0 if disconnected?(n, prob)\n\n    key = prob.keys[0]\n    i, j = key >> 4, key & 15\n\n    ans = 0\n\n    new_prob = prob.dup\n    new_prob.delete(key)\n    ans += prob[key] * f(n, new_prob)\n\n    new_prob = Hash.new(1.0)\n    prob.each do |k, q|\n        u, v = k >> 4, k & 15\n        next if k == key\n        u = j if k >> 4 == i\n        v = j if k & 15 == i\n        u, v = [u, v].sort\n        new_prob[(u << 4) + v] *= prob[k]\n    end\n\n    ans += (1.0 - prob[key]) * f(n-1, new_prob)\nend\n\ndef disconnected?(n, prob)\n    vs = prob.keys.map {|key| [key >> 4, key & 15]}.flatten.uniq\n    return true if vs.size != n\n    cc = {}\n    vs.each {|i| cc[i] = i}\n    prob.keys.each do |key|\n        i, j = key >> 4, key & 15\n        cc1 = cc[i]\n        cc2 = cc[j]\n        cc.each do |k, c|\n           cc[k] = cc2 if c == cc1\n        end\n    end\n\n    cc.values.uniq.size > 1\nend\n\nprintf(\"%.12f\\n\", f(n, prob))\n\n"
  },
  {
    "language": "Ruby",
    "code": "n, m, q = gets.split.map(&:to_i)\n\nprob = {}\n(1..m).each do\n    i, j = gets.split.map(&:to_i) \n    prob[[i, j]] = q / 100.0\nend\n\ndef f(n, prob)\n    return 1 if n == 1\n    return 0 if disconnected?(n, prob)\n    i, j = prob.keys[0]\n\n    new_prob = prob.dup\n    new_prob.delete([i, j])\n    ans = prob[[i, j]] * f(n, new_prob)\n\n    new_prob = Hash.new(1.0)\n    prob.each do |key, q|\n        u, v = key\n        next if key == [i, j]\n        u = j if key[0] == i\n        v = j if key[1] == i\n        new_prob[[u, v].sort] *= prob[key]\n    end\n\n    ans += (1.0 - prob[[i,j]]) * f(n-1, new_prob)\nend\n\ndef disconnected?(n, prob)\n    vs = prob.keys.flatten.uniq\n    cc = Hash[*vs.zip(vs).flatten]\n    return true if cc.size != n\n    prob.keys.each do |i, j|\n        cc1 = cc[i]\n        cc2 = cc[j]\n        cc.each do |k, c|\n            cc[k] = cc2 if c == cc1\n        end\n    end\n    cc.values.uniq.size > 1\nend\n\np f(n, prob)\n\n"
  },
  {
    "language": "Ruby",
    "code": "\nn, m, q = gets.split.map(&:to_i)\n\nprob = {}\n(1..m).each do\n    i, j = gets.split.map(&:to_i) \n    (prob[i] ||= Hash.new(1.0))[j] = q / 100.0\n    (prob[j] ||= Hash.new(1.0))[i] = q / 100.0\nend\n\nrequire 'set'\n\ndef f(prob)\n    return 1.0 if prob.size == 1\n\n    if prob.size == 1 + prob.values.map(&:size).inject(:+) / 2\n        return prob.keys.combination(2).map {|i, j| prob[i].key?(j) ? 1 - prob[i][j] : 1}.inject(:*)\n    end\n\n    i = prob.keys.min_by{|i| prob[i].size}\n    j = prob[i].keys.min_by{|j| prob[j].size}\n\n    new_prob = {}\n    prob.each {|k, h| new_prob[k] = h.dup}\n    new_prob[i].delete(j)\n    new_prob[j].delete(i)\n\n    \n    reached = disconnected?(new_prob)\n    if reached\n        g1 = {}\n        new_prob.each {|k, h| g1[k] = new_prob[k].dup if reached.include?(k)}\n        g2 = {}\n        new_prob.each {|k, h| g2[k] = new_prob[k].dup if !reached.include?(k)}\n        return (1.0 - prob[i][j]) * f(g1) * f(g2)\n    else\n        return prob[i][j] * f(new_prob) + (1.0 - prob[i][j]) * f(contract(prob, i, j))\n    end\nend\n\ndef contract(prob, i, j)\n    new_prob = {}\n    new_prob[j] = prob[j].dup\n    new_prob[j].delete(i)\n    prob.each do |k, h|\n        next if k == i or k == j\n        new_prob[k] = h.dup\n        q = h[i]\n        new_prob[k].delete(i)\n        new_prob[k][j] *= q\n        new_prob[j][k] = new_prob[k][j]\n    end\n    new_prob\nend\n\nrequire 'set'\ndef disconnected?(prob)\n    i = prob.keys[0]\n    reached = Set[i]\n    queue = [i]\n    until queue.empty?\n        i = queue.shift\n        prob[i].each do |j, _|\n            next if reached.include?(j)\n            reached << j\n            queue << j\n        end\n    end\n    return reached.size == prob.size ? nil : reached\nend\n\nprintf(\"%.12f\\n\", f(prob))\n\n"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nn, m, P = gets.split.map(&:to_i)\n\nedges = Hash.new(1)\nm.times do\n    u, v = gets.split.map(&:to_i)\n    key = Set[u, v]\n    edges[key] *= P / 100.0\nend\n\ndef f(edges, n)\n    return 1 if n == 1\n    return 0 if ! connected(edges, n)\n    e = edges.keys[0]\n    u0, v0 = e.to_a\n    q = edges[e]\n\n    deleted = edges.dup\n    deleted.delete(e)\n\n    contracted = Hash.new(1)\n    edges.each do |f, prob|\n        next if f == e\n        u, v = f.to_a\n        u = u0 if u == v0\n        v = u0 if v == v0\n        key = Set[u, v]\n        contracted[key] *= prob\n    end\n\n    return q * f(deleted, n) + (1 - q) * f(contracted, n-1)\nend\n\ndef connected(edges, n)\n    components = []\n    edges.each_key do |key|\n        u, v = key.to_a\n        cc1 = components.find {|cc| cc.include?(u)}\n        cc2 = components.find {|cc| cc.include?(v)}\n        if !cc1 && !cc2\n            components << Set[u, v]\n        elsif cc1 && cc2\n            if cc1 != cc2\n                components.delete(cc2)\n                cc1 += cc2\n            end\n        elsif cc1\n            cc1 << v\n        else\n            cc2 << u\n        end\n    end\n    !components.empty? && components[0].size == n\nend\n\np f(edges, n)"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nn, m, percent = gets.split.map(&:to_i)\n$prob = percent / 100.0\n\nif n == 1\n\tputs 1\n\texit\nend\n\n$edges = (1..m).map { gets.split.map(&:to_i) }\n$cuts = []\n\n(1..2**(n-1)-1).each do |bits|\n\tus = Set[*(1..n-1).select {|i| bits[i-1] == 1}]\n\tvs = Set[*(1..n).to_a] - us\n\n\tcut = 0\n\t$edges.each_with_index do |(i, j), k|\n\t\tcut |= (1 << k) if us.include?(i) ^ us.include?(j)\n\tend\n\tif cut == 0\n\t\tputs 0\n\t\texit\n\tend\n\n\t$cuts << cut\nend\n\n$n = n\n\ndef check_cut(disconnected)\n\t$cuts.any? {|cut| cut & disconnected == cut}\nend\n\ndef check_all_connected(connected)\n\troot = (0..$n-1).to_a\t\n\t(0..$edges.size-1).each do |i|\n\t\tif connected[i] == 1\n\t\t\tu, v = $edges[i]\n\t\t\tu, v = v, u if v < u\n\t\t\troot[u-1] = root[v-1]\n\t\tend\n\tend\n\t(0..$n-1).each do |i|\n\t\tj = i\n\t\tj = root[j] until j == root[j]\n\t\troot[i] = j\n\tend\n\troot.uniq.size == 1\nend\n\ndef f(k, disconnected)\n\treturn 1 if k == $edges.size\n\n\tp1 = p2 = nil\n\n\tnew_disconnected = disconnected | (1 << k)\n\tif check_cut(new_disconnected)\n\t\tp1 = 0\n\telse\n\t\tp1 = $prob * f(k+1, disconnected | (1 << k))\n\tend\n\n\tconnected = ((1 << k + 1) - 1) - disconnected\n\tif check_all_connected(connected)\n\t\tp2 = (1 - $prob)\n\telse\n\t\tp2 = (1 - $prob) * f(k+1, disconnected)\n\tend\n\n\tp1 + p2\nend\n\np f(0, 0)"
  },
  {
    "language": "Ruby",
    "code": "module SimpleUndirectedGraphic\n    require 'set'\n\n    def connected?\n        reached = Set.new\n        dfs(each_node.to_a[0], :WHEN_VISIT => -> u {reached << u})\n        reached.size == size\n    end\n\n    def each_connected_component(&block)\n        return enum_for(__method__) unless block_given?\n        reached = Set.new\n        each_node do |s|\n            next if reached.include?(s)\n            cc = Set[s]\n            queue = [s]\n            until queue.empty?\n                u = queue.shift\n                each_neighbour(u) do |v|\n                    next if cc.include?(v)\n                    cc << v\n                    queue << v\n                end\n            end\n            block.call(cc)\n            reached += cc\n        end\n    end\n\n    def connected_components\n        each_connected_component.to_a\n    end\n\n    def dfs(root, callback = Hash.new())\n        known = Set[\n            :WHEN_VISIT,\n            :WHEN_CHECK,\n            :WHEN_MOVE,\n            :WHEN_RETURN,\n            :WHEN_LEAVE,\n        ]\n        callback.keys.each do |name|\n            raise \"unknown callback: #{name}\" if ! known.include?(name)\n        end\n\n        f = nil\n        f.call(root) if f = callback[:WHEN_VISIT]\n        stack = [[root, to_enum(:each_neighbour, root)]]\n        parent = { root => root }\n        until stack.empty?\n            u, itr = stack[-1]\n            begin\n                v = itr.next\n                f.call(u, v) if f = callback[:WHEN_CHECK]\n                next if v == parent[u]|| parent[v]\n\n                stack << [v, to_enum(:each_neighbour, v)]\n                parent[v] = u\n                f.call(u, v) if f = callback[:WHEN_MOVE]\n\n                f.call(v) if f = callback[:WHEN_VISIT]\n            rescue StopIteration\n                stack.pop\n                f.call(u) if f = callback[:WHEN_LEAVE]\n                if ! stack.empty?\n                    f.call(stack[-1][0], u) if f = callback[:WHEN_RETURN]\n                end\n            end\n        end\n    end\n\n    def each_biconnected_component(root = each_node.to_a[0])\n        return to_enum(__method__) unless block_given?\n\n        visit_order = {}\n        backtrack = {}\n        parent = {}\n        edge_stack = []\n\n        callback = {\n            :WHEN_VISIT => -> u {\n                backtrack[u] = visit_order[u] = visit_order.size\n            },\n            :WHEN_CHECK => -> u, v {\n                if v != parent[u] && o = visit_order[v]\n                    backtrack[u] = o if o < backtrack[u]\n                end\n            },\n            :WHEN_MOVE => -> u, v {\n                edge_stack << [u, v]\n                parent[v] = u\n            },\n            :WHEN_RETURN => -> u, v {\n                l = backtrack[v]\n                if visit_order[u] <= l\n                    bcc = Set[u]\n                    loop do\n                       x, y = edge_stack.pop\n                       bcc << y\n                       break if x == u\n                    end\n                    yield(bcc)\n                end\n                backtrack[u] = l if l < backtrack[u]\n            },\n        }\n\n        dfs(root, callback)\n    end\n\n    def biconnected_components\n        each_biconnected_component.to_a\n    end\n\n    def cut_points\n        appearance = Hash.new(0)\n        each_biconnected_component do |s|\n            s.each {|u| appearance[u] += 1}\n        end\n        Set[*appearance.keys.select{|u| appearance[u] > 1}]\n    end\nend\n\nclass Graph\n    include SimpleUndirectedGraphic\n\n    def size\n        @adj.size\n    end\n\n    def initialize(nodes)\n        @adj = {}\n        nodes.each {|u| @adj[u] = Set.new}\n        @vanish_prob = Hash.new(1)\n    end\n\n    def add_edge(u, v, q)\n        @adj[u] << v\n        @adj[v] << u\n        @vanish_prob[Set[u, v]] *= q\n    end\n\n    def each_node\n        return enum_for(__method__) unless block_given?\n        @adj.each_key do |v|\n            yield v\n        end\n    end\n\n    def each_neighbour(u)\n        return enum_for(__method__) unless block_given?\n        @adj[u].each do |v|\n            yield v\n        end\n    end\n\n    def subgraph(nodes)\n        g = Graph.new(nodes)\n        @vanish_prob.each do |e, q|\n            u, v = e.to_a\n            g.add_edge(u, v, q) if nodes.include?(u) && nodes.include?(v)\n        end\n        g\n    end\n\n    def get_some_edge\n        @vanish_prob.keys[0]\n    end\n\n    def delete_edge(e)\n        u, v = e.to_a\n        @adj[u].delete(v)\n        @adj[v].delete(u)\n        @vanish_prob.delete(e)\n    end\n\n    def contract_edge(e)\n        u, v = e.to_a\n        @adj.delete(v)\n        @adj.each do |w, list|\n            if w == u\n                list.delete(v)\n            elsif list.include?(v)\n                list.delete(v)\n                list << u\n            end\n        end\n        new_prob = Hash.new(1)\n        @vanish_prob.each do |f, q|\n            next if f == e\n            x, y = f.to_a\n            x = u if x == v\n            y = u if y == v\n            new_prob[Set[x, y]] *= q\n        end\n        @vanish_prob = new_prob\n    end\n\n    def single?\n        @vanish_prob == {}\n    end\n\n    attr_reader :vanish_prob\nend\n\nn, m, P = gets.split.map(&:to_i)\n\ng = Graph.new((1..n).to_a)\n\nedges = Hash.new(1)\nm.times do\n    u, v = gets.split.map(&:to_i)\n    g.add_edge(u, v, P / 100.0)\nend\n\ndef f1(graph)\n    return 0 if ! graph.connected?\n    return 1 if graph.single?\n    prob = 1.0\n    graph.each_biconnected_component do |bcc|\n        if bcc.size == 2\n            prob *= 1 - graph.vanish_prob[bcc]\n        else\n            prob *= f2(graph.subgraph(bcc))\n        end\n    end\n    prob\nend\n\ndef f2(graph)\n    return 0 if ! graph.connected?\n    return 1 if graph.single?\n    e = graph.get_some_edge\n    deleted = Marshal.load(Marshal.dump(graph))\n    deleted.delete_edge(e)\n\n    contracted = Marshal.load(Marshal.dump(graph))\n    contracted.contract_edge(e)\n\n    q = graph.vanish_prob[e]\n    q * f1(deleted) + (1 - q) * f1(contracted)\nend\n\n#p g\n#g.each_biconnected_component {|bcc| p bcc}\np f1(g)"
  },
  {
    "language": "Ruby",
    "code": "n, m, q = gets.split.map(&:to_i)\n\nprob = {}\n(1..m).each do\n    i, j = gets.split.map(&:to_i) \n    i, j = [i, j].sort\n    prob[(i << 4) + j] = q / 100.0\nend\n\ndef f(n, prob)\n    return 1.0 if n == 1\n    return 0.0 if disconnected?(n, prob)\n    return 1.0 - prob.values[0] if n == 2\n\n    key = prob.keys[0]\n    i, j = key >> 4, key & 15\n\n    ans = 0\n\n    if prob[key] >= 1e-11\n        new_prob = prob.dup\n        new_prob.delete(key)\n        ans += prob[key] * f(n, new_prob)\n    end\n\n    if 1.0 - prob[key] >= 1e-11\n        new_prob = Hash.new(1.0)\n        prob.each do |k, q|\n            u, v = k >> 4, k & 15\n            next if k == key\n            u = j if k >> 4 == i\n            v = j if k & 15 == i\n            u, v = [u, v].sort\n            new_prob[(u << 4) + v] *= prob[k]\n        end\n        ans += (1.0 - prob[key]) * f(n-1, new_prob)\n    end\n    ans\nend\n\nrequire 'set'\ndef disconnected?(n, prob)\n    return true if n > prob.size + 1\n    neighbour = {}\n    prob.each_key do |key|\n        i, j = key >> 4, key & 15\n        (neighbour[i] ||= []) << j\n        (neighbour[j] ||= []) << i\n    end\n    i = neighbour.keys.min\n    reached = Set[i]\n    queue = [i]\n    until queue.empty?\n        i = queue.shift\n        neighbour[i].each do |j|\n            next if reached.include?(j)\n            reached << j\n            queue << j\n        end\n    end\n    reached.size != n\nend\n\nprintf(\"%.12f\\n\", f(n, prob))\n\n"
  },
  {
    "language": "Ruby",
    "code": "\nn, m, q = gets.split.map(&:to_i)\n\nprob = {}\n(1..m).each do\n    i, j = gets.split.map(&:to_i) \n    (prob[i] ||= Hash.new(1.0))[j] = q / 100.0\n    (prob[j] ||= Hash.new(1.0))[i] = q / 100.0\nend\n\nrequire 'set'\n\ndef f(prob)\n    return 1.0 if prob.size == 1\n\n    if prob.size == 1 + prob.values.map(&:size).inject(:+) / 2\n        return prob.keys.combination(2).map {|i, j| prob[i].key?(j) ? 1 - prob[i][j] : 1}.inject(:*)\n    end\n\n    i = prob.keys.min_by{|i| prob[i].size}\n    j = prob[i].keys.min_by{|j| prob[j].size}\n\n    new_prob = {}\n    prob.each {|k, h| new_prob[k] = h.dup}\n    new_prob[i].delete(j)\n    new_prob[j].delete(i)\n\n    \n    reached = disconnected?(new_prob)\n    if reached\n        g1 = {}\n        new_prob.each {|k, h| g1[k] = new_prob[k].dup if reached.include?(k)}\n        g2 = {}\n        new_prob.each {|k, h| g2[k] = new_prob[k].dup if !reached.include?(k)}\n        return (1.0 - prob[i][j]) * f(g1) * f(g2)\n    else\n        return prob[i][j] * f(new_prob) + (1.0 - prob[i][j]) * f(contract(prob, i, j))\n    end\nend\n\ndef contract(prob, i, j)\n    new_prob = {}\n    new_prob[j] = prob[j].dup\n    new_prob[j].delete(i)\n    prob.each do |k, h|\n        next if k == i or k == j\n        new_prob[k] = h.dup\n        q = h[i]\n        new_prob[k].delete(i)\n        new_prob[k][j] *= q\n        new_prob[j][k] = new_prob[k][j]\n    end\n    new_prob\nend\n\nrequire 'set'\ndef disconnected?(prob)\n    i = prob.keys[0]\n    reached = Set[i]\n    queue = [i]\n    until queue.empty?\n        i = queue.shift\n        prob[i].each do |j, _|\n            next if reached.include?(j)\n            reached << j\n            queue << j\n        end\n    end\n    return reached.size == prob.size ? nil : reached\nend\n\nif m < n - 1\n    puts '0'\nelse\n    printf(\"%.12f\\n\", f(prob))\nend\n\n"
  },
  {
    "language": "Ruby",
    "code": "n, m, q = gets.split.map(&:to_i)\n\nprob = {}\n(1..m).each do\n    i, j = gets.split.map(&:to_i) \n    prob[[i, j]] = q / 100.0\nend\n\ndef f(n, prob)\n    return 1 if n == 1\n    return 0 if disconnected?(n, prob)\n    i, j = prob.keys[0]\n\n    new_prob = prob.dup\n    new_prob.delete([i, j])\n    ans = prob[[i, j]] * f(n, new_prob)\n\n    new_prob = Hash.new(1.0)\n    prob.each do |key, q|\n        u, v = key\n        x, y = key\n        next if key == [i, j]\n        x = j if u == i\n        y = j if v == i\n        new_prob[[x, y]] *= prob[[u, v]]\n    end\n\n    ans += (1.0 - prob[[i,j]]) * f(n-1, new_prob)\nend\n\ndef disconnected?(n, prob)\n    vs = prob.keys.flatten.uniq\n    cc = Hash[*vs.zip(vs).flatten]\n    return true if cc.size != n\n    prob.keys.each do |i, j|\n        cc1 = cc[i]\n        cc2 = cc[j]\n        cc.each do |k, c|\n            cc[k] = cc2 if c == cc1\n        end\n    end\n    cc.values.uniq.size > 1\nend\n\np f(n, prob)\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef solve():\n    N, M, P = map(int, readline().split())\n    G = [[] for i in range(N)]\n    for i in range(M):\n        u, v = map(int, readline().split())\n        G[u-1].append(v-1)\n        G[v-1].append(u-1)\n    N1 = 1 << N\n    bc = [0]*N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ (i & -i)] + 1\n    ec = [0]*N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if (state & (1 << v)) == 0:\n                continue\n            for w in G[v]:\n                if (state & (1 << w)) == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << (N-1)\n    dp = [0]*N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = (s0 << 1) | 1\n        state1 = (state0-1) & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P/100)**k\n            state1 = (state1 - 1) & state0\n        dp[state0] = 1 - v\n    write(\"%.16f\\n\" % dp[N1-1])\nsolve()\n"
  }
]