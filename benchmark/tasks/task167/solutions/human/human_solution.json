[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned int;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i,n) for(UL i=0; i<(n); i++)\n\nUL J[3001][3001]={};\nUL O[3001][3001]={};\nUL I[3001][3001]={};\n\nint main(){\n UL H,W; scanf(\"%u%u\",&H,&W);\n rep(y,H){\n  scanf(\" \");\n  rep(x,W){\n   char c; scanf(\"%c\",&c);\n   if(c=='J') J[y][x]++;\n   if(c=='O') O[y][x]++;\n   if(c=='I') I[y][x]++;\n  }\n }\n\n ULL ans=0;\n for(UL y=H-1; y!=~0u; y--) for(UL x=W-1; x!=~0u; x--){\n  O[y][x]+=O[y][x+1];\n  I[y][x]+=I[y+1][x];\n  if(J[y][x]) ans+=O[y][x]*I[y][x];\n }\n\n printf(\"%llu\\n\",ans);\n\n return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long int;\n\nint solve(){\n    int h, w;\n    cin >> h >> w;\n    vector<string> s(h);\n    for(int i=0;i<h;i++){\n        cin >> s[i];\n    }\n    vector<vector<ll> > ocnt(h, vector<ll>(w+1)), icnt(h+1, vector<ll>(w));\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(s[i][j] == 'O'){\n                ocnt[i][j+1]++;\n            }\n            if(s[i][j] == 'I'){\n                icnt[i+1][j]++;\n            }\n            ocnt[i][j+1] += ocnt[i][j];\n            icnt[i+1][j] += icnt[i][j];\n        }\n    }\n    ll ans = 0;\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(s[i][j] == 'J'){\n                ans += (ocnt[i][w]-ocnt[i][j])*(icnt[h][j]-icnt[i][j]);\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n\nint main(){\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing ll = long long;\nusing namespace std;\n#define _overload3(_1, _2, _3, name, ...) name\n#define _rep(i, n) repi(i, 0, n)\n#define repi(i, a, b) for(int i = int(a); i < int(b); ++i)\n#define rep(...) _overload3(__VA_ARGS__, repi, _rep, )(__VA_ARGS__)\nconst long long INFLL = 1LL << 60;\nconst int INFINT = 1 << 30;\nconst long long MOD = 1e9 + 7;\n\ntemplate <class T> void vecout(T V) {\n    auto t = V.begin();\n    while(t != V.end()) {\n        cout << *t++;\n        if(t != V.end()) cout << \" \";\n    }\n    cout << endl;\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    char c;\n    int h, w;\n    cin >> h >> w;\n    vector<vector<char>> S(h, vector<char>(w));\n    vector<vector<int>> JO(h, vector<int>(w, 0));\n    vector<vector<int>> JI(h, vector<int>(w, 0));\n    rep(i, h) rep(j, w) {\n        cin >> c;\n        S[i][j] = c;\n    };\n    rep(i, h) {\n        JO[i][w - 1] = (S[i][w - 1] == 'O');\n        for(int j = w - 2; j >= 0; j--) {\n            JO[i][j] = JO[i][j + 1] + (S[i][j] == 'O');\n        }\n    }\n    rep(j, w) {\n        JI[h - 1][j] = (S[h - 1][j] == 'I');\n        for(int i = h - 2; i >= 0; i--) {\n            JI[i][j] = JI[i + 1][j] + (S[i][j] == 'I');\n        }\n    }\n    ll ans = 0;\n    rep(i, h) rep(j, w) if(S[i][j] == 'J') ans += JO[i][j] * JI[i][j];\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\nint T[3100];\nchar in[3010][3010];\nint main(void){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",in[i]);\n\tlong long ret=0;\n\tfor(int i=a-1;i>=0;i--){\n\t\tint tmp=0;\n\t\tfor(int j=b-1;j>=0;j--){\n\t\t\tif(in[i][j]=='O')tmp++;\n\t\t\tif(in[i][j]=='I')T[j]++;\n\t\t\tif(in[i][j]=='J')\n\t\t\t\tret+=tmp*T[j];\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ret);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int h, w;\n    cin >> h >> w;\n    vector<string> field(h);\n    for (int i = 0; i < h; ++i)\n    {\n        cin >> field[i];\n    }\n    vector<int> count_I(w), count_O(h);\n    long long ans = 0;\n    for (int i = h - 1; i >= 0; --i)\n    {\n        for (int j = w - 1; j >= 0; --j)\n        {\n            if (field[i][j] == 'J')\n            {\n                ans += count_I[j] * count_O[i];\n            }\n            else if (field[i][j] == 'O')\n            {\n                ++count_O[i];\n            }\n            else\n            {\n                ++count_I[j];\n            }\n        }\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream> // cout, endl, cin\n#include <string> // string, to_string, stoi\n#include <vector> // vector\n#include <algorithm> // min, max, swap, sort, reverse, lower_bound, upper_bound\n#include <utility> // pair, make_pair\n#include <tuple> // tuple, make_tuple\n#include <cstdint> // int64_t, int*_t\n#include <cstdio> // printf\n#include <map> // map\n#include <queue> // queue, priority_queue\n#include <set> // set\n#include <stack> // stack\n#include <deque> // deque\n#include <unordered_map> // unordered_map\n#include <unordered_set> // unordered_set\n#include <bitset> // bitset\n#include <cctype> // isupper, islower, isdigit, toupper, tolower\n#include <iomanip> // setprecision\n#include <complex> // complex\n#include <functional>\n#include <math.h> \n#define enld '\\n'\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\nconstexpr ll INF = 1e18;\nconstexpr int inf = 1e9;\nconstexpr ll mod = 1000000007;\nconstexpr ll mod2 = 998244353;\nconst int dx[8] = {1, 0, -1, 0,1,1,-1,-1};\nconst int dy[8] = {0, 1, 0, -1,1,-1,1,-1};\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n// ---------------------------------------------------------------------------\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int H,W;\n  cin >> H >> W;\n  vector<string> G(H);\n  for(int i=0; i<H; i++){\n    cin >> G[i];\n  }\n  vector<vector<ll>> O(H,vector<ll> (W+1,0));\n  vector<vector<ll>> I(H+1,vector<ll> (W,0));\n  for(int i=0; i<H; i++){\n    for(int j=0; j<W; j++){\n      O[i][j+1] += O[i][j] + (G[i][j] == 'O');\n      I[i+1][j] += I[i][j] + (G[i][j] == 'I');\n    }\n  }\n  ll ans = 0;\n  for(int i=0; i<H; i++){\n    for(int j=0; j<W; j++){\n      if(G[i][j] == 'J'){\n        ans += (O[i][W] - O[i][j]) * (I[H][j] - I[i][j]);\n      }\n    }\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v==0) return b;\n                                \tif(b==0) return v;\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[10000100];\n                int inv[10000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n      \n\nint a[3020][3020]={},b[3010][3010]={};\nstring s[3030];\nsigned main(){\n\t\n\t\n   cin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint h,w;\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++)cin>>s[i];\n\tint ans=0;\n\tfor(int i=h-1;i>=0;i--)for(int j=w-1;j>=0;j--){\n\t\tif(i==h-1){\n\t\t\ta[i][j]=s[i][j]=='I';\n\t\t}\n\t\telse a[i][j]=a[i+1][j]+(s[i][j]=='I');\n\t\t\n\t\tif(j==w-1){\n\t\t\tb[i][j]=s[i][j]=='O';\n\t\t}\n\t\telse b[i][j]=b[i][j+1]+(s[i][j]=='O');\n\t\tif(s[i][j]=='J')ans+=a[i][j]*b[i][j];\n\t}\n\tcout<<ans<<endl;\n\t\n\t\n\t\n\treturn 0;\n\t\n\n \n }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint H, W;\nchar MapData[3000][3000];\nint DpCountO[3001][3001];\nint DpCountI[3001][3001];\n\nvoid solve() {\n\tunsigned long long int total;\n\t\n\tmemset(DpCountO, 0, sizeof(DpCountO));\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = W - 1; j >= 0; --j) {\n\t\t\tDpCountO[i][j] += DpCountO[i][j + 1];\n\t\t\tif (MapData[i][j] == 'O') {\n\t\t\t\t++DpCountO[i][j];\n\t\t\t}\n\t\t}\n\t}\n\n\tmemset(DpCountI, 0, sizeof(DpCountI));\n\tfor (int j = 0; j < W; ++j) {\n\t\tfor (int i = H - 1; i >= 0; --i) {\n\t\t\tDpCountI[i][j] += DpCountI[i + 1][j];\n\t\t\tif (MapData[i][j] == 'I') {\n\t\t\t\t++DpCountI[i][j];\n\t\t\t}\n\t\t}\n\t}\n\n\ttotal = 0;\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tif (MapData[i][j] == 'J') {\n\t\t\t\ttotal += DpCountO[i][j + 1] * DpCountI[i + 1][j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << total << endl;\n}\n\nint main() {\n\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tcin >> MapData[i][j];\n\t\t}\n\t}\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef long long ll;\n\nchar mat[3001][3001];\nint bot[3001][3001] = {}, rig[3001][3001] = {};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int h, w;\n    cin >> h >> w;\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            cin >> mat[i][j];\n        }\n    }\n    for(int i = h-1; i >= 0; i--){\n        for(int j = 0; j < w; j++){\n            bot[i][j] = bot[i+1][j]+(mat[i][j]=='I');\n        }\n    }\n    for(int j = w-1; j >= 0; j--){\n        for(int i = 0; i < h; i++){\n            rig[i][j] = rig[i][j+1]+(mat[i][j]=='O');\n        }\n    }\n    ll ans = 0;\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            if(mat[i][j]=='J')  ans += bot[i][j]*rig[i][j];\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 3005\n\nstruct LOC{\n\tLOC(int arg_row,int arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tint row,col;\n};\n\nint H,W;\nll num_O[NUM][NUM],num_I[NUM][NUM];\nchar table[NUM][NUM];\nvector<LOC> V;\n\n\nint main(){\n\n\tscanf(\"%d %d\",&H,&W);\n\n\tfor(int row = 0; row < H; row++){\n\n\t\tscanf(\"%s\",table[row]);\n\n\t\tfor(int col = 0; col < W; col++){\n\n\t\t\tif(table[row][col] == 'J'){\n\t\t\t\tV.push_back(LOC(row,col));\n\t\t\t}\n\t\t}\n\n\t\t//右→左にOの数を数える\n\t\tif(table[row][W-1] == 'O'){\n\n\t\t\tnum_O[row][W-1] = 1;\n\n\t\t}else{\n\n\t\t\tnum_O[row][W-1] = 0;\n\t\t}\n\n\t\tfor(int col = W-2; col >= 0; col--){\n\n\t\t\tif(table[row][col] == 'O'){\n\n\t\t\t\tnum_O[row][col] = num_O[row][col+1]+1;\n\n\t\t\t}else{\n\n\t\t\t\tnum_O[row][col] = num_O[row][col+1];\n\t\t\t}\n\t\t}\n\t}\n\n\t//下→上にIの数を数える\n\tfor(int col = 0; col <= W-1; col++){\n\n\t\tif(table[H-1][col] == 'I'){\n\n\t\t\tnum_I[H-1][col] = 1;\n\t\t}else{\n\n\t\t\tnum_I[H-1][col] = 0;\n\t\t}\n\n\t\tfor(int row = H-2; row >= 0; row--){\n\n\t\t\tif(table[row][col] == 'I'){\n\n\t\t\t\tnum_I[row][col] = num_I[row+1][col]+1;\n\t\t\t}else{\n\n\t\t\t\tnum_I[row][col] = num_I[row+1][col];\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 0;\n\n\tfor(int i = 0; i < V.size(); i++){\n\n\t\tans += num_O[V[i].row][V[i].col]*num_I[V[i].row][V[i].col];\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <map>\nusing namespace std;\nchar test[3001][3001]; int O[3001][3001], I[3001][3001];\nint main() {\n\tlong long n, w, ans = 0; char a; cin >> n >> w;\n\tfor (int h = 1; h <= n; h++) {\n\t\tfor (int i = 1; i <= w; i++) {\n\t\t\tcin >> a; test[h][i] = a;\n\t\t}\n\t}\n\tfor (int h = 1; h <= n; h++) {\n\t\tint s = 0;\n\t\tfor (int i = w; i > 0; i--) {\n\t\t\tif (test[h][i] == 'O') {\n\t\t\t\ts++; O[h][i] = s;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tO[h][i] = s;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int h = 1; h <= w; h++) {\n\t\tint t = 0;\n\t\tfor (int i = n; i > 0; i--) {\n\t\t\tif (test[i][h] == 'I') {\n\t\t\t\tt++; I[i][h] = t;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tI[i][h] = t;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int h = 1; h <= n; h++) {\n\t\tfor (int i = 1; i <= w; i++) {\n\t\t\tif (test[h][i] == 'J') {\n\t\t\t\tans += O[h][i] * I[h][i];\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\tcin >> n;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n//int N,M,K,L,R,H,W;\nlong long int N,M,K,L,R,H,W;\n\nconstexpr long long int MOD=1000000007;\n//constexpr  int MOD=1000000007;\n//constexpr int MOD=998244353;\n//constexpr long long int MOD=998244353;\n\nconstexpr long double EPS=1e-8;\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t\n\tcin>>H>>W;\n\tvector<string>s(H);\n\tfor(auto &i:s)cin>>i;\n\tvector<vector<int>>O(H,vector<int>(W));\n\tvector<vector<int>>I(H,vector<int>(W));\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tif(s[i][j]=='O')O[i][j]++;\n\t\t\telse if(s[i][j]=='I')I[i][j]++;\n\t\t}\n\t}\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=W-2;j>=0;j--)O[i][j]+=O[i][j+1];\n\t}\n\tfor(int i=H-2;i>=0;i--){\n\t\tfor(int j=0;j<W;j++)I[i][j]+=I[i+1][j];\n\t}\n\tlong long int ans=0;\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tif(s[i][j]=='J')ans+=O[i][j]*I[i][j];\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<functional>\n#include<algorithm>\nusing namespace std;\nchar s[3000][3001];\nint osum[3000][3000],isum[3000][3000];\nint main(void)\n{\n\tint h,w,i,j,x;\n\tlong long sum;\n\tscanf(\"%d %d\",&h,&w);\n\tfor(i=0;i<h;i++)\tscanf(\"%s\",s[i]);\n\tfor(i=0;i<h;i++)\t{\n\t\tx=0;\n\t\tfor(j=w-1;j>=0;j--)\t{\n\t\t\tif(s[i][j]=='O')\tx++;\n\t\t\tosum[i][j]=x;\n\t\t}\n\t}\n\tfor(j=0;j<w;j++)\t{\n\t\tx=0;\n\t\tfor(i=h-1;i>=0;i--)\t{\n\t\t\tif(s[i][j]=='I')\tx++;\n\t\t\tisum[i][j]=x;\n\t\t}\n\t}\n\tsum=0;\n\tfor(i=0;i<h;i++)\t{\n\t\tfor(j=0;j<w;j++)\t{\n\t\t\tif(s[i][j]=='J')\t{\n\t\t\t\tsum+=osum[i][j]*isum[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",sum);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n\nstatic const int MOD = 1000000007;\nusing ll = int64_t;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\ntemplate <class T, class U>\nvector<T> make_v(U size, const T& init){ return vector<T>(static_cast<size_t>(size), init); }\n\ntemplate<class... Ts, class U>\nauto make_v(U size, Ts... rest) { return vector<decltype(make_v(rest...))>(static_cast<size_t>(size), make_v(rest...)); }\n\ntemplate<class T> void chmin(T &a, const T &b){ a = (a < b ? a : b); }\ntemplate<class T> void chmax(T &a, const T &b){ a = (a > b ? a : b); }\n\nint main() {\n    int h, w;\n    cin >> h >> w;\n    vector<string> v(h);\n    for (auto &&i : v) cin >> i;\n    ll ans = 0;\n    auto O = make_v(h, w, 0); auto I = O;\n    for (int i = 0; i < h; ++i) {\n        for (int j = w-1; j >= 0; --j) {\n            if(j != w-1) O[i][j] += O[i][j+1];\n            O[i][j] += v[i][j] == 'O';\n        }\n\n    }\n    for (int i = h-1; i >= 0; --i) {\n        for (int j = 0; j < w; ++j) {\n            if(i != h-1) I[i][j] += I[i+1][j];\n            I[i][j] += v[i][j] == 'I';\n        }\n    }\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            if(v[i][j] == 'J') ans += O[i][j] * I[i][j];\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a/gcd(a,b)*b;\n}\n\n\nsigned main(void) {\n    int h,w;\n    cin >> h >> w;\n    vs s(h);\n    rep(i,h)cin >> s[i];\n    vector<vi> a(h),b(w);\n    rep(i,h)rep(j,w){\n        if(s[i][j] == 'O')a[i].push_back(j);\n        if(s[i][j] == 'I')b[j].push_back(i);\n    }\n    int ans = 0;\n    rep(i,h)rep(j,w)if(s[i][j] == 'J'){\n        int x = a[i].end() - lower_bound(all(a[i]),j);\n        int y = b[j].end() - lower_bound(all(b[j]),i);\n        //cout << i << \" \" << j << \" \" << x << \" \" << y << endl;\n        ans += x*y;\n    }\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n\nstring s[3030];\n\nll orb[3030][3030],ingot[3030][3030];\n\nint main(void){\n\tint h,w,i,j;\n\tll ans=0ll;\n\tcin >> h >> w;\n\tfor(i=0; i<h; ++i){\n\t\tcin >> s[i];\n\t}\n\tfor(i=(h-1); i>=0; --i){\n\t\tfor(j=(w-1); j>=0; --j){\n\t\t\torb[i][j] = orb[i][j+1];\n\t\t\tif(s[i][j]=='O'){\n\t\t\t\t++orb[i][j];\n\t\t\t}\n\t\t\tingot[i][j] = ingot[i+1][j];\n\t\t\tif(s[i][j]=='I'){\n\t\t\t\t++ingot[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0; i<h; ++i){\n\t\tfor(j=0; j<w; ++j){\n\t\t\tif(s[i][j]=='J'){\n\t\t\t\tans += orb[i][j]*ingot[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<string>\n#include<set>\n#include<vector>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\n\n#define LL long long\n#define MOD 1000000007\n\nLL h, w, O[3003][3003] = {}, I[3003][3003] = {}, ans = 0;\nchar cell[3003][3003];\n\nint main() {\n\tcin >> h >> w;\n\tfor (int i = 0; i < h; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tcell[i][j] = s[j];\n\t\t}\n\t}\n\tfor (int i = h - 1; i >= 0; i--) {\n\t\tfor (int j = w - 1; j >= 0; j--) {\n\t\t\tO[i][j] = O[i][j + 1];\n\t\t\tif (cell[i][j] == 'O')O[i][j]++;\n\t\t\tI[i][j] = I[i + 1][j];\n\t\t\tif (cell[i][j] == 'I')I[i][j]++;\n\t\t\tif (cell[i][j] == 'J')\n\t\t\t\tans += O[i][j] * I[i][j];\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n#include <queue>\n#include <functional>\n#include <algorithm>\n#include <random>\n#include <cmath>\n#include <climits>\n#include <iomanip>\n#include <cfloat>\n#include <set>\n#include <map>\n#include <tuple>\n#include <numeric>\nlong long int solve(const std::vector<std::string> &state) {\n\tstd::vector<std::vector<int>> ingot(state.size(), std::vector<int>(state.front().size(), 0));\n\tstd::vector<std::vector<int>> orb(state.size(), std::vector<int>(state.front().size(), 0));\n\tlong long int result = 0;\n\tfor (int y = state.size() - 1; y >= 0; --y) {\n\t\tfor (int x = state[y].size() - 1; x >= 0; --x) {\n\t\t\tif (state[y][x] == 'I') ingot[y][x] = 1;\n\t\t\telse if (state[y][x] == 'O') orb[y][x] = 1;\n\t\t\tif (y + 1 < state.size()) ingot[y][x] += ingot[y + 1][x];\n\t\t\tif (x + 1 < state[y].size()) orb[y][x] += orb[y][x + 1];\n\t\t\tif (state[y][x] == 'J') result += ingot[y][x] * orb[y][x];\n\t\t}\n\t}\n\treturn result;\n}\nint main() {\n\tint h, w; std::cin >> h >> w;\n\tstd::vector<std::string> state(h);\n\tfor (auto& line : state) std::cin >> line;\n\tstd::cout << solve(state) << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#pragma warning (disable: 4996)\n\nchar c[3009][3009];\nlong long H, W;\nlong long V1[3009][3009];\nlong long V2[3009][3009];\n\nint main() {\n\tscanf(\"%lld%lld\", &H, &W);\n\tfor (int i = 0; i < H; i++) {\n\t\tscanf(\"%s\", &c[i]);\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (c[i][j] == 'O') V1[i][j]++;\n\t\t\tif (c[i][j] == 'I') V2[i][j]++;\n\t\t}\n\t}\n\n\tfor (int i = H - 1; i >= 0; i--) {\n\t\tfor (int j = W - 1; j >= 0; j--) V1[i][j] += V1[i][j + 1];\n\t}\n\tfor (int i = H - 1; i >= 0; i--) {\n\t\tfor (int j = W - 1; j >= 0; j--) V2[i][j] += V2[i + 1][j];\n\t}\n\n\tlong long ans = 0;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (c[i][j] == 'J') ans += V1[i][j] * V2[i][j];\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define FOR(i,x,n) for(int i=x; i<(n); i++)\n#define ALL(n) begin(n),end(n)\n#define MOD (1000000007)\n#define INF (1e9)\n#define INFL (1e18)\n \ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntemplate<class T>using arr=vector<vector<T>>;\ntemplate<class T>void pr(T x){cout << x << endl;}\ntemplate<class T>void prvec(vector<T>& a){rep(i, a.size()-1){cout << a[i] << \" \";} cout << a[a.size()-1] << endl;}\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\ntemplate<class T>void prarr(vector<vector<T>>& a){\nrep(i, a.size()){\nrep(j, a[i].size()){\ncout << a[i][j]; printf(\" \");}\nprintf(\"\\n\");} printf(\"\\n\");}\n\nint main()\n{\n    int h, w; cin >> h >> w;\n    vector<string> p(h);\n    rep(i, h) cin >> p[i];\n\n    //行iにあるOrbの累積和\n    arr<ll> orb(h, vector<ll>(w, 0)); \n    //列jにあるIngotの累積和\n    arr<ll> ingot(h, vector<ll>(w, 0));\n\n    rep(i, h){\n        if(p[i][0]=='O') orb[i][0]++;\n    } \n    FOR(i, 0, h) FOR(j, 1 ,w){\n        orb[i][j] += orb[i][j-1];\n        if(p[i][j]=='O') orb[i][j]++;\n    }\n\n    rep(i, w){\n        if(p[0][i]=='I') ingot[0][i]++;\n    } \n    FOR(i, 1, h) FOR(j, 0 ,w){\n        ingot[i][j] += ingot[i-1][j];\n        if(p[i][j]=='I') ingot[i][j]++;\n    }\n\n    // prarr(orb);\n    // prarr(ingot);\n\n    ll ans = 0;\n    rep(i, h) rep(j, w){\n        // printf(\"%d, %d, %lld\\n\", i, j, ans);\n        if(p[i][j]!='J') continue;\n        ans += (orb[i][w-1] - orb[i][j]) * (ingot[h-1][j] - ingot[i][j]);\n    }\n    pr(ans);\n    return 0;}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 3010;\n\nint n, m;\nchar s[N][N];\nint jc[N][N], oc[N][N];\n\nint main() {\n#ifdef LBT\n    freopen(\"test.in\", \"r\", stdin);\n    int nol_cl = clock();\n#endif\n\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; ++i) scanf(\"%s\", s[i] + 1);\n    for (int i = 1; i <= n; ++i)\n        for (int j = m; j; --j) oc[i][j] = oc[i][j + 1] + (s[i][j] == 'O');\n    for (int j = 1; j <= m; ++j)\n        for (int i = n; i; --i) jc[i][j] = jc[i + 1][j] + (s[i][j] == 'I');\n    ll ans = 0;\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= m; ++j)\n            if (s[i][j] == 'J')\n                ans += oc[i][j] * jc[i][j];\n    printf(\"%lld\\n\", ans);\n\n#ifdef LBT\n    LOG(\"Time: %dms\\n\", int((clock() - nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main()\n{\n    int H, W;\n    cin >> H >> W;\n    vector<string> S(H);\n    for(int i = 0;i < H;i++){\n        cin >> S[i];\n    }\n    vector<vector<int>> cntO(H, vector<int>(W + 1)), cntI(H + 1, vector<int>(W));\n    for(int i = 0;i < H;i++){\n        for(int j = W - 1;j >= 0;j--){\n            cntO[i][j] = cntO[i][j + 1] + (S[i][j] == 'O');\n        }\n    }\n    for(int i = H - 1;i >= 0;i--){\n        for(int j = 0;j < W;j++){\n            cntI[i][j] = cntI[i + 1][j] + (S[i][j] == 'I');\n        }\n    }\n    ll res = 0;\n    for(int i = 0;i < H;i++){\n        for(int j = 0;j < W;j++){\n            if (S[i][j] == 'J') res += cntO[i][j] * cntI[i][j];\n        }\n    }\n    cout << res << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing vi = vector<int>;\n\nint main(){\n    int h,w;\n    cin >>h >>w;\n    vector<string> s(h);\n    rep(i,h) cin >>s[i];\n\n    vector<vi> O(h, vi(w+1)), I(w, vi(h+1));\n    rep(i,h){\n        for(int j=w-1; j>=0; --j){\n            O[i][j] = O[i][j+1];\n            if(s[i][j] == 'O') ++O[i][j];\n        }\n    }\n\n    rep(i,w){\n        for(int j=h-1; j>=0; --j){\n            I[i][j] = I[i][j+1];\n            if(s[j][i]=='I') ++I[i][j];\n        }\n    }\n\n    ll ans = 0;\n    rep(i,h)rep(j,w)if(s[i][j] == 'J') ans += O[i][j+1]*I[j][i+1];\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\nusing LL = long long;\n\nint J[3001][3001]{};\nint O[3001][3001]{};\nint I[3001][3001]{};\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n\n    string s;\n    for (int i = 1; i <= H; i++) {\n        cin >> s;\n        for (int j = 1; j <= W; j++) {\n            switch (s[j - 1]) {\n                case 'J':\n                    J[i][j] = 1;\n                    break;\n                case 'O':\n                    O[i][j] = 1;\n                    break;\n                case 'I':\n                    I[i][j] = 1;\n                    break;\n            }\n        }\n    }\n\n    for (int i = 1; i <= H; i++) {\n        for (int j = 1; j <= W; j++) {\n            O[i][j] += O[i][j - 1];\n            I[i][j] += I[i - 1][j];\n        }\n    }\n\n    LL ans = 0;\n\n    for (int i = 1; i <= H; i++) {\n        for (int j = 1; j <= W; j++) {\n            if (J[i][j]) {\n                ans += (O[i][W] - O[i][j]) * (I[H][j] - I[i][j]);\n            }\n        }\n    }\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define err(args...) {}\n#ifdef DEBUG\n#include \"_debug.cpp\"\n#endif\nusing namespace std;\nusing ll = long long;\nconst int N = 3000;\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int h, w;\n    cin >> h >> w;\n    vector<string> g(h);\n    vector<vector<int>> o_count(h, vector<int>(w));\n    vector<vector<int>> i_count(w, vector<int>(h));\n    for(int i = 0; i < h; i++) {\n        cin >> g[i];\n        for(int j = 0; j < w; j++) {\n            o_count[i][j] = (j ? o_count[i][j - 1] : 0) + (g[i][j] == 'O');\n            i_count[j][i] = (i ? i_count[j][i - 1] : 0) + (g[i][j] == 'I');\n        }\n    }\n    ll ans = 0;\n    for(int i = 0; i < h; i++) {\n        for(int j = 0; j < w; j++) {\n            if(g[i][j] == 'J') {\n                ans += (o_count[i][w - 1] - o_count[i][j]) * (i_count[j][h - 1] - i_count[j][i]);\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(void){\n\n    int H,W;\n    cin >> H >> W;\n    string S[H];\n\n    for(int i=0;i<H;i++){\n        cin >> S[i];\n    }\n\n    long score=0;\n\n    int o_c[H];\n    int i_c[W];\n    for(int i=0;i<H;i++) o_c[i]=0;\n    for(int i=0;i<W;i++) i_c[i]=0;\n    \n    for(int i=H-1;i>=0;i--){\n        for(int j=S[i].size()-1;j>=0;j--){\n\n            if(S[i][j]=='J'){\n                score+=o_c[i]*i_c[j];\n            }else{\n                if(S[i][j]=='O') o_c[i]++;\n                if(S[i][j]=='I') i_c[j]++;\n            }\n        }\n    }\n    \n    cout << score << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<math.h>\n#include<queue>\n#include<set>\n#include<map>\n#include<random>\n#include<functional>\n#include<utility>\n\ntypedef long long ll;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define pb push_back\n#define P pair<int, int>\n#define PLI pair<ll, int>\n#define PLL pair<ll, ll>\n#define VI vector<int>\n#define VII vector<VI>\n\nusing namespace std;\n\n\nint H, W;\nstring S[3005];\nint cntO[3005][3005] = {}, cntI[3005][3005] = {}; //OI\nvector<P> jewel;\nint main() {\n\tcin >> H >> W;\n\trep(i, H) {\n\t\tcin >> S[i];\n\t}\n\trep(i, H) rep(j, W) {\n\t\tif (S[i][j] == 'J') jewel.emplace_back(i, j);\n\t\tif (S[i][j] == 'O') {\n\t\t\tcntO[i][j]++;\n\t\t}\n\t\tif (S[i][j] == 'I'){\n\t\t\tcntI[i][j]++;\n\t\t}\n\t}\n\tfor (int i = H - 1; i >= 0; i--) {\n\t\tfor (int j = W - 1; j >= 0; j--) {\n\t\t\tcntO[i][j] += cntO[i][j + 1];\n\t\t\tcntI[i][j] += cntI[i + 1][j];\n\t\t}\n\t}\n\tll ans = 0;\n\trep(i, jewel.size()) {\n\t\tint x = jewel[i].first, y = jewel[i].second;\n\t\tans += cntO[x][y] * cntI[x][y];\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint T[3100];\nchar in[3100][3100];\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",in[i]);\n\tlong long ret=0;\n\tfor(int i=a-1;i>=0;i--){\n\t\tint tmp=0;\n\t\tfor(int j=b-1;j>=0;j--){\n\t\t\tif(in[i][j]=='O')tmp++;\n\t\t\tif(in[i][j]=='I')T[j]++;\n\t\t\tif(in[i][j]=='J'){\n\t\t\t\tret+=tmp*T[j];\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ret<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <algorithm>\n#include <cstdlib>\n#include<string>\nusing namespace std;\nint main(){\n  int H;\n  int W;\n  cin >> H;\n  cin >> W;\n  int Orb[H];//行ごとのオーブの数\n  int Gold[W];//列ごとの金塊の数\n  for(int n=0;n<H;n++){\n    Orb[n]=0;\n  }\n  for(int m=0;m<W;m++){\n    Gold[m]=0;\n  }\n  string map[H];\n  for(int n=0;n<H;n++){\n    cin >> map[n];\n    for(int m=0;m<W;m++){\n      if(map[n][m]=='O'){\n        Orb[n]++;\n      }\n      if(map[n][m]=='I'){\n        Gold[m]++;\n      }\n    }\n  }\n  long long int point = 0;\n\n  for(int n=0;n<H;n++){\n    for(int m=0;m<W;m++){\n      if(map[n][m]=='J'){\n        point+=Orb[n]*Gold[m];\n      }\n      if(map[n][m]=='O'){\n        Orb[n]--;\n      }\n      if(map[n][m]=='I'){\n        Gold[m]--;\n      }\n    }\n  }\n  cout << point <<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int M = 3030;\nchar C[M][M];\nlong long I[M][M]; // 'I'の縦累積和\nlong long O[M][M]; // 'I'の横累積和\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    int h, w;\n    cin >> h >> w;\n    \n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            cin >> C[i][j];\n            if(C[i][j] == 'I') I[i + 1][j] = 1;\n            if(C[i][j] == 'O') O[i][j + 1] = 1;\n        }\n    }\n\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            I[i + 1][j] += I[i][j];\n            O[i][j + 1] += O[i][j];\n        }\n    }\n\n    long long ans = 0;\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            if(C[i][j] == 'J') ans += (I[h][j] - I[i + 1][j]) * (O[i][w] - O[i][j + 1]);\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint ocnt[3001][3001]={0},kcnt[3001][3001]={0};\nchar s[3000][3001];\nint main(void)\n{\n\tint h,w,i,j,cnto,cntk;\n\tlong long sum;\n\tscanf(\"%d %d\",&h,&w);\n\tfor(i=0;i<h;i++){\n\t\tscanf(\"%s\",s[i]);\n\t}\n\tfor(i=0;i<h;i++){\n\t\tcnto=0;\n\t\tfor(j=w-1;j>0;j--){\n\t\t\tif(s[i][j]=='O'){\n\t\t\t\tcnto++;\n\t\t\t}\n\t\t\tocnt[i][j-1]+=cnto;\n\t\t}\n\t}\n\tfor(i=0;i<w;i++){\n\t\tcntk=0;\n\t\tfor(j=h-1;j>0;j--){\n\t\t\tif(s[j][i]=='I'){\n\t\t\t\tcntk++;\n\t\t\t}\n\t\t\tkcnt[j-1][i]+=cntk;\n\t\t}\n\t}\n\tsum=0;\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tif(s[i][j]=='J'){\n\t\t\t\tsum+=(long long)kcnt[i][j]*ocnt[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",sum);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 11192019.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n#include <iostream>\nusing namespace std;\n\nchar a[3005][3005];\nlong long dpo[3005][3005] = { 0 };\nlong long dpi[3005][3005] = { 0 };\n\nint main()\n{\n\tint h, w;\n\tcin >> h >> w;\n\tfor (int i = 0; i < h; i++)\n\t\tfor (int j = 0; j < w; j++) cin >> a[i][j];\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (a[i][j] == 'O') dpo[i][j]++;\n\t\t\tif(j>=1) dpo[i][j] += dpo[i][j - 1];\n\t\t}\n\t}\n\tfor (int j = 0; j < w; j++) {\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tif (a[i][j] == 'I') dpi[i][j]++;\n\t\t\tif (i >= 1) dpi[i][j] += dpi[i - 1][j];\n\t\t}\n\t}\n\tlong long ans = 0;\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (a[i][j] == 'J') {\n\t\t\t\tans += (dpi[h - 1][j] - dpi[i][j]) * (dpo[i][w - 1] - dpo[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n// Run program: Ctrl + F5 or Debug > Start Without Debugging menu\n// Debug program: F5 or Debug > Start Debugging menu\n\n// Tips for Getting Started: \n//   1. Use the Solution Explorer window to add/manage files\n//   2. Use the Team Explorer window to connect to source control\n//   3. Use the Output window to see build output and other messages\n//   4. Use the Error List window to view errors\n//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project\n//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nlong long onum[3100][3100];\nlong long inum[3100][3100];\n\nint main() {\n    int N, M; cin >> N >> M;\n    vector<string> fi(N);\n    for (int i = 0; i < N; ++i) cin >> fi[i];\n\n    // O\n    for (int i = 0; i < N; ++i) {\n        vector<long long> sum(M+1, 0);\n        for (int j = 0; j < M; ++j) {\n            int add = 0;\n            if (fi[i][j] == 'O') ++add;\n            sum[j+1] = sum[j] + add;\n        }\n        for (int j = 0; j < M; ++j) {\n            onum[i][j] = sum[M] - sum[j+1];\n        }\n    }\n\n    // I\n    for (int j = 0; j < M; ++j) {\n        vector<long long> sum(N+1, 0);\n        for (int i = 0; i < N; ++i) {\n            int add = 0;\n            if (fi[i][j] == 'I') ++add;\n            sum[i+1] = sum[i] + add;\n        }\n        for (int i = 0; i < N; ++i) {\n            inum[i][j] = sum[N] - sum[i+1];\n        }\n    }\n\n    long long res = 0;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < M; ++j) {\n            if (fi[i][j] != 'J') continue;\n            res += onum[i][j] * inum[i][j];\n        }\n    }\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define MP(a,b) make_pair(a,b)\nint H,W;\nstring S[3000];\nint waO[3000][3000];\nint waI[3000][3000];\nint main(){\n\tcin >> H >> W;\n\tfor(int i=0; i<H; i++){\n\t\tcin >> S[i];\n\t}\n\tfor(int i=0; i<H; i++){\n\t\tfor(int j=0; j<W; j++){\n\t\t\twaO[i][j] = (j!=0?waO[i][j-1]:0);\n\t\t\tif(S[i][j] == 'O') waO[i][j]++;\n\t\t\t//cout << waO[i][j] << \" \";\n\t\t}\n\t\t//cout << endl;\n\t}\n\tfor(int i=0; i<W; i++){\n\t\tfor(int j=0; j<H; j++){\n\t\t\twaI[i][j] = (j!=0?waI[i][j-1]:0);\n\t\t\tif(S[j][i] == 'I') waI[i][j]++;\n\t\t\t//cout << waI[i][j] << \" \";\n\t\t}\n\t\t//cout << endl;\n\t}\n\tLL ans = 0;\n\tfor(int i=0; i<H; i++){\n\t\tfor(int j=0; j<W; j++){\n\t\t\tif(S[i][j] == 'J'){\n\t\t\t\tans += (waO[i][W-1]-waO[i][j]) * (waI[j][H-1]-waI[j][i]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#include <string>\nchar s[3001][3001];\nint n[2][3001][3001];\nint main(){\n  int h,w;\n  cin >> h >> w;\n  for(int i = 0; i < h; i++){\n    cin >> s[i];\n  }\n  for(int i = 0; i < h;i++){\n    for(int j = w-1;j>=0;j--){\n      int temp = 0;\n      if(s[i][j] == 'O'){\n        temp++;\n      }\n      n[0][i][j] = n[0][i][j+1]+temp;\n    }\n  }\n  for(int i = 0; i < w; i++){\n    for(int j = h-1; j>=0;j--){\n      int temp = 0;\n      if(s[j][i] == 'I')temp ++;\n      n[1][j][i] = n[1][j+1][i] + temp;\n    }\n  }\n  long long int ans = 0;\n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++){\n      if(s[i][j] == 'J'){\n        ans +=n[0][i][j+1]*n[1][i+1][j];\n      }\n    }\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\nint H, W;\nstring S[3010];\nint cntO[3010][3010];\nint cntI[3010][3010];\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> H >> W;\n    REP(i, H) {\n        cin >> S[i];\n        REP(j, W) {\n            if (S[i][j] == 'O') cntO[i][j]++;\n            if (S[i][j] == 'I') cntI[i][j]++;\n        }\n    }\n    REP(i, H) for (int j = W - 1; j >= 0; --j) cntO[i][j] += cntO[i][j + 1];\n    REP(j, W) for (int i = H - 1; i >= 0; --i) cntI[i][j] += cntI[i + 1][j];\n    int ans = 0;\n    REP(i, H) REP(j, W) if (S[i][j] == 'J') ans += cntO[i][j] * cntI[i][j];\n    cout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define eps LDBL_EPSILON\n#define moder 1000000007\n#define int long long\n#define double long double\n#define ll long long\n#define INF LLONG_MAX/3\n#define P pair<int,int>\n#define prique priority_queue<int,vector<int>,greater<int>>\n#define ggr getchar();getchar();return 0\nusing namespace std;\nint h,w;\nchar s[3010][3010];\nint r1[3010][3010],r2[3010][3010];\nsigned main(){\n\tcin>>h>>w;\n\trep(i,h){\n\t\trep(j,w)cin>>s[i][j];\n\t}\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tif(j)r1[i][j]=r1[i][j-1];\n\t\t\tif(s[i][j]=='O')r1[i][j]++;\n\t\t\tif(i)r2[i][j]=r2[i-1][j];\n\t\t\tif(s[i][j]=='I')r2[i][j]++;\n\t\t}\n\t}\n\tint ans=0;\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tif(s[i][j]=='J'){\n\t\t\t\tif(i){\n\t\t\t\t\tif(j){\n\t\t\t\t\t\tans+=(r1[i][w-1]-r1[i][j-1])*(r2[h-1][j]-r2[i-1][j]);\n\t\t\t\t\t}\n\t\t\t\t\telse ans+=r1[i][w-1]*(r2[h-1][j]-r2[i-1][j]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(j){\n\t\t\t\t\t\tans+=(r1[i][w-1]-r1[i][j-1])*r2[h-1][j];\n\t\t\t\t\t}\n\t\t\t\t\telse ans+=r1[i][w-1]*r2[h-1][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\tggr;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n#include <queue>\n#include <stack>\n#include <iomanip>\n\nusing namespace std;\n\n#define REP(i, n) for(ll i = 0;i < n;i++)\n#define REPR(i, n) for(ll i = n;i >= 0;i--)\n#define FOR(i, m, n) for(ll i = m;i < n;i++)\n#define FORR(i, m, n) for(ll i = m;i >= n;i--)\n#define REPO(i, n) for(ll i = 1;i <= n;i++)\n#define ll long long\n#define INF (ll)1 << 60\n#define MINF (-1 * INF)\n#define ALL(n) n.begin(),n.end()\n#define MOD 1000000007\n#define P pair<ll, ll>\n\n\nll h, w, O[3100][3100], I[3100][3100], ans;\nstring s[4100];\nint main() {\n\tcin >> h >> w;\n\tREP(i, h)cin >> s[i];\n\tREP(i, h) {\n\t\tREP(j, w) {\n\t\t\tif (s[i][j] == 'O')O[i][j]++;\n\t\t\telse if (s[i][j] == 'I')I[i][j]++;\n\t\t}\n\t}\n\tREP(i, h) {\n\t\tREPR(j, w - 2) {\n\t\t\tO[i][j] += O[i][j + 1];\n\t\t}\n\t}\n\tREPR(i, h - 2) {\n\t\tREP(j, w) {\n\t\t\tI[i][j] += I[i + 1][j];\n\t\t}\n\t}\n\tREP(i, h) {\n\t\tREP(j, w) {\n\t\t\tif (s[i][j] == 'J')ans += O[i][j] * I[i][j];\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//typedef\n//-------------------------#include <bits/stdc++.h>\n \nconst double pi = 3.141592653589793238462643383279;\n \n \nusing namespace std;\n \n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ninline int readInt() { int x; scanf(\"%d\", &x); return x; }\n \n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n \n \n//container util\n \n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \n \n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n \n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst double EPS = 1E-8;\n \n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n \nclass UnionFind {\npublic:\n    vector <int> par; \n    vector <int> siz; \n\n    UnionFind(int sz_): par(sz_), siz(sz_, 1) {\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    void init(int sz_) {\n        par.resize(sz_);\n        siz.assign(sz_, 1LL);\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n \n    int root(int x) { \n        while (par[x] != x) {\n            x = par[x] = par[par[x]];\n        }\n        return x;\n    }\n \n    bool merge(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (siz[x] < siz[y]) swap(x, y);\n        siz[x] += siz[y];\n        par[y] = x;\n        return true;\n    }\n \n    bool issame(int x, int y) { \n        return root(x) == root(y);\n    }\n \n    int size(int x) { \n        return siz[root(x)];\n    }\n};\n \n \nll modPow(ll x, ll n, ll mod = MOD){\n    ll res = 1;\n    while(n){\n        if(n&1) res = (res * x)%mod;\n \n        res %= mod;\n        x = x * x %mod;\n        n >>= 1;\n    }\n    return res;\n}\n \n#define SIEVE_SIZE 5000000+10\nbool sieve[SIEVE_SIZE];\nvoid makeSieve(){\n    for(int i=0; i<SIEVE_SIZE; ++i) sieve[i] = true;\n    sieve[0] = sieve[1] = false;\n    for(int i=2; i*i<SIEVE_SIZE; ++i) if(sieve[i]) for(int j=2; i*j<SIEVE_SIZE; ++j) sieve[i*j] = false;\n}\n \nbool isprime(ll n){\n    if(n == 0 || n == 1) return false;\n    for(ll i=2; i*i<=n; ++i) if(n%i==0) return false;\n    return true;\n}\n \nconst int MAX = 2000010;\nlong long fac[MAX], finv[MAX], inv[MAX];\n \n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n \n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n \nlong long extGCD(long long a, long long b, long long &x, long long &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long d = extGCD(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n// 負の数にも対応した mod (a = -11 とかでも OK) \ninline long long mod(long long a, long long m) {\n    return (a % m + m) % m;\n}\n \n// 逆元計算 (ここでは a と m が互いに素であることが必要)\nlong long modinv(long long a, long long m) {\n    long long x, y;\n    extGCD(a, m, x, y);\n    return mod(x, m); // 気持ち的には x % m だが、x が負かもしれないので\n}\nll GCD(ll a, ll b){\n    \n    if(b == 0) return a;\n    return GCD(b, a%b);\n}\n\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n\nmat mul(mat &A, mat &B) {\n    mat C(A.size(), vec((int)B[0].size()));\n    for(int i=0; i<A.size(); ++i){\n        for(int k=0; k<B.size(); ++k){\n            for(int j=0; j<B[0].size(); ++j){\n                C[i][j] = (C[i][j] + A[i][k] * B[k][j] %MOD) % MOD;\n            }\n        }\n    }\n    return C;\n}\nmat matPow(mat A, ll n) {\n    mat B(A.size(), vec((int)A.size()));\n \n    for(int i=0; i<A.size(); ++i){\n        B[i][i] = 1;\n    }\n \n    while(n > 0) {\n        if(n & 1) B = mul(B, A);\n        A = mul(A, A);\n        n >>= 1;\n    }\n    return B;\n}\n\nll ci[3010][3010];\nll co[3010][3010];\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n\n    int H,W; cin>>H>>W;\n\n    vector<string> s;\n    REP(i,H){\n        string t; cin >> t;\n        s.push_back(t);\n    }\n\n    REP(i,H){\n        int ct = 0;\n        for(int j=0; j<W; j++){\n            if(s[i][j] == 'O') ct++;\n\n            co[i][j] = ct;\n        }\n    }\n\n    REP(j,W){\n        int ct = 0;\n        for(int i=0; i<H; i++){\n            if(s[i][j] == 'I') ct++;\n\n            ci[i][j] = ct;\n        }\n    }\n\n    ll ans = 0;\n\n    for(int i=0; i<H; i++){\n        for(int j=0; j<W; j++){\n            if(s[i][j] == 'J'){\n                ans += (co[i][W-1]-co[i][j])*(ci[H-1][j]-ci[i][j]);\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for (int i=0;i<(n);++i)\n#define RREP(i,n) for (int i=(n)-1;i>=0;--i)\n\nusing namespace std;\n\nusing ll = long long;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int H, W;\n    cin >> H >> W;\n    vector<string> S(H);\n    REP(i, H) cin >> S[i];\n\n    ll result = 0;\n\n    vector<ll> a(W, 0);\n\n    REP(i, H) {\n        int n_orbs = 0;\n        RREP(j, W) {\n            if (S[i][j] == 'J') {\n                a[j] += n_orbs;\n            } else if (S[i][j] == 'O') {\n                ++n_orbs;\n            } else if (S[i][j] == 'I') {\n                result += a[j];\n            }\n        }\n\n    }\n\n    cout << result << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n  int h, w;\n  cin >> h >> w;\n  char s[h][w];\n  int i, j;\n  for (i = 0; i < h; i++) {\n    for (j = 0; j < w; j++) {\n      cin >> s[i][j];\n    }\n  }\n  vector<vector<int>> orb(h, vector<int>(w, 0)), ing(h, vector<int>(w, 0));\n  for (i = h - 1; i >= 0; i--) {\n    for (j = w - 1; j >= 0; j--) {\n      if (j == w - 1) {\n        orb[i][j] = (s[i][j] == 'O');\n      } else {\n        orb[i][j] = orb[i][j + 1] + (s[i][j] == 'O');\n      }\n    }\n  }\n  for (i = h - 1; i >= 0; i--) {\n    for (j = w - 1; j >= 0; j--) {\n      if (i == h - 1) {\n        ing[i][j] = (s[i][j] == 'I');\n      } else {\n        ing[i][j] = ing[i + 1][j] + (s[i][j] == 'I');\n      }\n    }\n  }\n\n  long long result = 0;\n  for (i = 0; i < h; i++) {\n    for (j = 0; j < w; j++) {\n      if (s[i][j] == 'J') {\n        result += orb[i][j] * ing[i][j];\n      }\n    }\n  }\n\n  cout << result << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconstexpr size_t MAX_H = 3001;\nconstexpr size_t MAX_W = 3001;\n\nchar S[MAX_H][MAX_W];\nint I_count[MAX_H][MAX_W];\nint O_count[MAX_H][MAX_W];\nint H;\nint W;\n\nusing namespace std;\n\nint main() {\n  \n  cin >> H >> W;\n  char s;\n\n  for (int x=0; x<H; x++) {\n    for (int y=0; y<W; y++) {\n      cin >> s;\n      assert(s == 'J' || s == 'O' || s == 'I');\n      S[H-1-x][W-1-y] = s;\n    }\n  }\n\n  for (int y=0; y<W; y++) {\n    int count=0;\n    for (int x=0; x<H; x++) {\n      if (S[x][y] == 'I') count += 1;\n      I_count[x][y] = count;\n    }\n  }\n\n  for (int x=0; x<H; x++) {\n    int count=0;\n    for (int y=0; y<W; y++) {\n      if (S[x][y] == 'O') count += 1;\n      O_count[x][y] = count;\n    }\n  }\n\n  // for (int x=0; x<H; x++) {\n  //   for (int y=0; y<W; y++) {\n  //     cout << I_count[x][y];\n  //   }\n  //   cout << endl;\n  // }\n\n\n  long long ans = 0;\n\n  for (int x=0; x<H; x++) {\n    for (int y=0; y<W; y++) {\n      if (S[x][y] == 'J') {\n        ans += O_count[x][y] * I_count[x][y];\n      }\n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<utility>\n#include<vector>\n#include<queue>\n#include<functional>\n#include<map>\n#include<set>\n#include<cstring>\n#include<string>\n#include<stack>\n#include<malloc.h>\n#include<math.h>\nusing namespace std;\n//#define int long long\ntypedef pair<int, int> pii;\ntypedef pair<int, char> pic;\ntypedef priority_queue<pii, vector<pii>, greater<pii> > RPQ;\n#define mk make_pair\n#define INF (1 << 30)\n#define INFL (1ll << 60ll)\n#define mod 1000000007\n\nint H, W;\nchar fld[3030][3030];\nint sum[3030][3030][3];\n\nsigned main(){\n    cin >> H >> W;\n    for(int i = 0; i < H; i++){\n        cin >> fld[i];\n    }\n    for(int i = 0; i < H; i++){\n        for(int j = 0; j < W; j++){\n            if(fld[i][j] == 'J'){\n                sum[i][j][0]++;\n            }\n            else if(fld[i][j] == 'O'){\n                sum[i][j][1]++;\n            }\n            else {\n                sum[i][j][2]++;\n            }\n        }\n    }\n    for(int i = 0; i < H; i++){\n        for(int j = 1; j < W; j++){\n            sum[i][j][1] += sum[i][j - 1][1];\n        }\n    }\n    for(int i = 1; i < H; i++){\n        for(int j = 0; j < W; j++){\n            sum[i][j][2] += sum[i - 1][j][2];\n        }\n    }\n    long long ans = 0;\n    for(int i = 0; i < H; i++){\n        for(int j = 0; j < W; j++){\n            if(fld[i][j] == 'J'){\n                ans += (long long)(sum[i][W - 1][1] - sum[i][j][1]) * (long long)(sum[H - 1][j][2] - sum[i][j][2]);\n            }\n        }\n    }\n    cout << ans << endl;\n    \n\n\n    return 0;\n}\n\n/*\n\n\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long int ll;\n\nll cnto[3010][3010];\nll cnti[3010][3010];\nchar fi[3010][3010];\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tint h,w; cin >> h >> w;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin >> fi[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=w-1;j>0;j--){\n\t\t\tif(fi[i][j]=='O'){\n\t\t\t\tcnto[i][j-1]=cnto[i][j]+1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcnto[i][j-1]=cnto[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<w;i++){\n\t\tfor(int j=h-1;j>0;j--){\n\t\t\tif(fi[j][i]=='I'){\n\t\t\t\tcnti[j-1][i]=cnti[j][i]+1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcnti[j-1][i]=cnti[j][i];\n\t\t\t}\n\t\t}\n\t}\n\tll ans=0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(fi[i][j]=='J'){\n\t\t\t\tans+=cnto[i][j]*cnti[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cfloat>\n#include<climits>\n#include<cmath>\n#include<deque>\n#include<functional>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<string>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<vector>\n\nusing namespace std;\n\nusing lint = long long;\nusing P = pair<int, int>;\nusing LLP = pair<long long, long long>;\n\n#define REP(i, x, n) for(int i = (x), i##_len = (int)(n) ; i < i##_len ; ++i)\n#define rep(i, n) for(int i = 0, i##_len = (int)(n) ; i < i##_len ; ++i)\n#define reps(i, n) for(int i = 1, i##_len = (int)(n) ; i <= i##_len ; ++i)\n#define rrep(i, n) for(int i = (int)(n) - 1 ; i >= 0 ; --i)\n#define rreps(i, n) for(int i = (int)(n) ; i > 0 ; --i)\n#define SORT(x) sort((x).begin(), (x).end())\n#define SORT_INV(x) sort((x).rbegin(), (x).rend())\n#define REVERSE(x) reverse((x).begin(), (x).end())\n#define TWINS(x) cout << ((x) ? \"Yay!\" : \":(\") << '\\n'\n\nconstexpr int IINF = (1 << 30) - 1;\nconstexpr long long LLINF = 1LL << 61;\nconstexpr double EPS = 1e-10;\n\nconstexpr int dx4[] = {1, 0, -1, 0}, dy4[] = {0, 1, 0, -1};\nconstexpr int dx8[] = {1, 1, 0, -1, -1, -1, 0, 1}, dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ntemplate<typename T>\nbool chmax(T& a, T b){\n    if(a < b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T>\nbool chmin(T& a, T b){\n    if(b < a){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    int h, w;\n    cin >> h >> w;\n\n    vector<string> s(h);\n    rep(i, h){\n        cin >> s[i];\n    }\n\n    vector< vector<int> > co(h, vector<int>(w, 0));\n    vector< vector<int> > ci(h, vector<int>(w, 0));\n\n    rrep(i, h){\n        rrep(j, w){\n            if(j < w - 1){\n                co[i][j] += co[i][j + 1];\n            }\n            if(s[i][j] == 'O'){\n                ++co[i][j];\n            }\n\n            if(i < h - 1){\n                ci[i][j] += ci[i + 1][j];\n            }\n            if(s[i][j] == 'I'){\n                ++ci[i][j];\n            }\n        }\n    }\n\n    lint ans = 0;\n    rep(i, h){\n        rep(j, w){\n            if(s[i][j] == 'J'){\n                ans += co[i][j] * ci[i][j];\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    cout << flush;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define int long long\nusing namespace std;\nint h, w;\nstring map[3456];\nint a[3456][3456], b[3456][3456];\nsigned main() {\n\tcin >> h >> w;\n\tfor (int i = 0; i < h; i++)cin >> map[i];\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = w - 1; j >= 0; j--) {\n\t\t\ta[i][j] = a[i][j + 1];\n\t\t\tif (map[i][j] == 'O')a[i][j]++;\n\t\t}\n\t}\n\tfor (int i = h - 1; i >= 0; i--) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tb[i][j] = b[i + 1][j];\n\t\t\tif (map[i][j] == 'I')b[i][j]++;\n\t\t}\n\t}\n\tint ans = 0; for (int i = 0; i < h; i++)for (int j = 0; j < w; j++)if (map[i][j] == 'J')ans += a[i][j] * b[i][j];\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\n#define ll long long\nusing namespace std;\n\nint main() {\n    int h, w;\n    cin >> h >> w;\n    vector<string> ban(h);\n    for (int i = 0; i < h; i++)cin >> ban[i];\n\n    vector<vector<ll>> O(h, vector<ll>(w + 1));\n    for (int i = 0; i < h; i++) {\n        for (int j = w; j > 0; j--) {\n            O[i][j - 1] = O[i][j] + (ban[i][j - 1] == 'O');\n        }\n    }\n    vector<vector<ll>> I(h + 1, vector<ll>(w));\n    for (int i = h; i > 0; i--) {\n        for (int j = 0; j < w; j++) {\n            I[i - 1][j] = I[i][j] + (ban[i - 1][j] == 'I');\n        }\n    }\n\n    ll ret = 0;\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            if (ban[i][j] == 'J')ret += O[i][j] * I[i][j];\n        }\n    }\n\n    cout << ret << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <inttypes.h>\n\nint H, W;\nchar S[3333][3333];\n\nint O[3333][3333], I[3333][3333];\n\nint main(void) {\n\tint i, j;\n\tuint64_t horieyui = 0;\n\tif (scanf(\"%d%d\", &H, &W) != 2) return 1;\n\tfor (i = 0; i < H; i++) {\n\t\tif (scanf(\"%3332s\", S[i]) != 1) return 1;\n\t}\n\tfor (i = 0; i < H; i++) {\n\t\tfor (j = 0; j < W; j++) {\n\t\t\tif (S[i][j] == 'O') O[i][j]++;\n\t\t\tif (S[i][j] == 'I') I[i][j]++;\n\t\t}\n\t}\n\tfor (i = 0; i < H; i++) {\n\t\tfor (j = 1; j < W; j++) {\n\t\t\tO[i][j] += O[i][j - 1];\n\t\t}\n\t}\n\tfor (i = 1; i < H; i++) {\n\t\tfor (j = 0; j < W; j++) {\n\t\t\tI[i][j] += I[i - 1][j];\n\t\t}\n\t}\n\tfor (i = 0; i < H; i++) {\n\t\tfor (j = 0; j < W; j++) {\n\t\t\tif (S[i][j] == 'J') {\n\t\t\t\thorieyui += (uint64_t)(O[i][W - 1] - O[i][j]) * (I[H - 1][j] - I[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%\" PRIu64 \"\\n\", horieyui);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 0658 Bitaro the Brave\n// 2019.3.28 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n\n//// 入力の高速化\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\nint in()    // 整数の入力（負数非対応）\n{\n\tint n = 0, c = gc();\n\tdo n = 10 * n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\nvoid ins(char *s)  // 文字列の入力　スペース以下の文字で入力終了\n{\n\tdo *s = gc();\n\twhile (*s++ > ' ');\n\t*(s - 1) = 0;\n}\n\n#define MAX 3005\nint H, W;\nchar map[MAX][MAX];\nshort sO[MAX][MAX];\nint   sI[MAX];\n\nint main()\n{\n\tint r, c;\n\tlong long ans;\n\n\tH = in(), W = in();\n\tfor (r = 0; r < H; r++) {\n\t\tins(map[r]);\n\t\tfor (c = W - 1; c >= 0; c--) sO[r][c] = sO[r][c + 1] + (map[r][c] == 'O');\n\t}\n\tans = 0;\n\tfor (c = 0; c < W; c++) {\n\t\tfor (r = H - 1; r >= 0; r--) sI[r] = sI[r + 1] + (map[r][c] == 'I');\n\t\tfor (r = 0; r < H; r++) if (sI[r]) {\n\t\t\tif (map[r][c] == 'J') ans += sO[r][c] * sI[r];\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "//29#04.34s\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Jewelly {\n\tprivate int x;\n\tprivate int y;\n\tprivate int orb;  //自分より右のOの数\n\tprivate int ingot;  //自分より下のIの数\n\n\tpublic Jewelly(int xx,int yy){\n\t\tx = xx;\n\t\ty = yy;\n\t\torb = 0;\n\t\tingot = 0;\n\t}\n\n\tpublic int getX() {return x;}\n\tpublic int getY() {return y;}\n\tpublic int getO() {return orb;}\n\tpublic int getI() {return ingot;}\n\n\tpublic void plusO() { orb++; }\n\tpublic void plusI() { ingot++; }\n\n}\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tList<List<Jewelly>> jList = new LinkedList<List<Jewelly>>();\n\t\t\tList<Jewelly> jewelly = new LinkedList<Jewelly>();\n\t\t\tint[] j_h = new int[h];\n\t\t\tint[] j_w = new int[w];\n\t\t\tfor (int i=0; i<h; i++) j_h[i] = -1;\n\t\t\tfor (int i=0; i<w; i++) j_w[i] = -1;\n\n\t\t\tfor (int i=0; i<h; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tchar[] c = s.toCharArray();\n\t\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\t\tswitch(c[j]) {\n\t\t\t\t\tcase 'J':\n\t\t\t\t\t\tJewelly je = new Jewelly(i,j);\n\t\t\t\t\t\tjewelly.add(je);\n\t\t\t\t\t\t//縦配列に記録-------------------\n\t\t\t\t\t\tif (j_h[i] == -1) {  //なにも入ってなかったら\n\t\t\t\t\t\t\tjList.add(new LinkedList<Jewelly>());\n\t\t\t\t\t\t\tj_h[i] = jList.size()-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tjList.get(j_h[i]).add(je);\n\n\t\t\t\t\t\t//横配列に記録-------------------\n\t\t\t\t\t\tif (j_w[j] == -1) {  //なにも入ってなかったら\n\t\t\t\t\t\t\tjList.add(new LinkedList<Jewelly>());\n\t\t\t\t\t\t\tj_w[j] = jList.size()-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tjList.get(j_w[j]).add(je);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'O':\n\t\t\t\t\t\tif (j>0) {\n\t\t\t\t\t\t\tif (j_h[i] != -1) {  //その横列にJがあったら\n\t\t\t\t\t\t\t\tfor (Jewelly jew : jList.get(j_h[i])) {\n\t\t\t\t\t\t\t\t\tif (jew.getY()<j) jew.plusO();\n\t\t\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'I':\n\t\t\t\t\t\tif (i>0) {\n\t\t\t\t\t\t\tif (j_w[j] != -1) {  //その縦列にJがあったら\n\t\t\t\t\t\t\t\tfor (Jewelly jew : jList.get(j_w[j])) {\n\t\t\t\t\t\t\t\t\tif (jew.getX()<i) jew.plusI();\n\t\t\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong sum = 0;\n\t\t\tfor (Jewelly jew : jewelly) {\n\t\t\t\tsum += jew.getI()*jew.getO();\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Jewelly {\n\tprivate int x;\n\tprivate int y;\n\tprivate int orb;  //自分より右のOの数\n\tprivate int ingot;  //自分より下のIの数\n\n\tpublic Jewelly(int xx,int yy){\n\t\tx = xx;\n\t\ty = yy;\n\t\torb = 0;\n\t\tingot = 0;\n\t}\n\n\tpublic int GetX() {return x;}\n\tpublic int GetY() {return y;}\n\tpublic int GetO() {return orb;}\n\tpublic int GetI() {return ingot;}\n\n\tpublic void PlusO() { orb++; }\n\tpublic void PlusI() { ingot++; }\n\n}\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tList<List<Jewelly>> jList = new LinkedList<List<Jewelly>>();\n\t\t\tList<Jewelly> jewelly = new LinkedList<Jewelly>();\n\t\t\tint[] j_h = new int[h];\n\t\t\tint[] j_w = new int[w];\n\t\t\tfor (int i=0; i<h; i++) j_h[i] = -1;\n\t\t\tfor (int i=0; i<w; i++) j_w[i] = -1;\n\n\t\t\tfor (int i=0; i<h; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tchar[] c = s.toCharArray();\n\t\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\t\tswitch(c[j]) {\n\t\t\t\t\tcase 'J':\n\t\t\t\t\t\tJewelly je = new Jewelly(i,j);\n\t\t\t\t\t\tjewelly.add(je);\n\t\t\t\t\t\t//縦配列に記録-------------------\n\t\t\t\t\t\tif (j_h[i] == -1) {  //なにも入ってなかったら\n\t\t\t\t\t\t\tjList.add(new LinkedList<Jewelly>());\n\t\t\t\t\t\t\tj_h[i] = jList.size()-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tjList.get(j_h[i]).add(je);\n\t\t\t\t\t\t\n\t\t\t\t\t\t//横配列に記録-------------------\n\t\t\t\t\t\tif (j_w[j] == -1) {  //なにも入ってなかったら\n\t\t\t\t\t\t\tjList.add(new LinkedList<Jewelly>());\n\t\t\t\t\t\t\tj_w[j] = jList.size()-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tjList.get(j_w[j]).add(je);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'O':\n\t\t\t\t\t\tif (j>0) {\n\t\t\t\t\t\t\tif (j_h[i] != -1) {  //その横列にJがあったら\n\t\t\t\t\t\t\t\tfor (Jewelly jew : jList.get(j_h[i])) {\n\t\t\t\t\t\t\t\t\tif (jew.GetY()<j) jew.PlusO();\n\t\t\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'I':\n\t\t\t\t\t\tif (i>0) {\n\t\t\t\t\t\t\tif (j_w[j] != -1) {  //その縦列にJがあったら\n\t\t\t\t\t\t\t\tfor (Jewelly jew : jList.get(j_w[j])) {\n\t\t\t\t\t\t\t\t\tif (jew.GetX()<i) jew.PlusI();\n\t\t\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong sum = 0;\n\t\t\tfor (Jewelly jew : jewelly) {\n\t\t\t\tsum += jew.GetI()*jew.GetO();\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Jewelly {\n\tprivate int x;\n\tprivate int y;\n\tprivate int orb;  //自分より右のOの数\n\tprivate int ingot;  //自分より下のIの数\n\n\tpublic Jewelly(int xx,int yy){\n\t\tx = xx;\n\t\ty = yy;\n\t\torb = 0;\n\t\tingot = 0;\n\t}\n\n\tpublic int GetX() {return x;}\n\tpublic int GetY() {return y;}\n\tpublic int GetO() {return orb;}\n\tpublic int GetI() {return ingot;}\n\n\tpublic void PlusO() { orb++; }\n\tpublic void PlusI() { ingot++; }\n\n}\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tList<List<Jewelly>> jList = new LinkedList<List<Jewelly>>();\n\t\t\tList<Jewelly> jewelly = new LinkedList<Jewelly>();\n\t\t\tint[] j_h = new int[h];\n\t\t\tint[] j_w = new int[w];\n\t\t\tfor (int i=0; i<h; i++) j_h[i] = -1;\n\t\t\tfor (int i=0; i<w; i++) j_w[i] = -1;\n\n\t\t\tfor (int i=0; i<h; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tchar[] c = s.toCharArray();\n\t\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\t\tswitch(c[j]) {\n\t\t\t\t\tcase 'J':\n\t\t\t\t\t\tJewelly je = new Jewelly(i,j);\n\t\t\t\t\t\tjewelly.add(je);\n\t\t\t\t\t\t//縦配列に記録-------------------\n\t\t\t\t\t\tif (j_h[i] == -1) {  //なにも入ってなかったら\n\t\t\t\t\t\t\tjList.add(new LinkedList<Jewelly>());\n\t\t\t\t\t\t\tj_h[i] = jList.size()-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tjList.get(j_h[i]).add(je);\n\t\t\t\t\t\t\n\t\t\t\t\t\t//横配列に記録-------------------\n\t\t\t\t\t\tif (j_w[j] == -1) {  //なにも入ってなかったら\n\t\t\t\t\t\t\tjList.add(new LinkedList<Jewelly>());\n\t\t\t\t\t\t\tj_w[j] = jList.size()-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tjList.get(j_w[j]).add(je);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'O':\n\t\t\t\t\t\tif (j>0) {\n\t\t\t\t\t\t\tif (j_h[i] != -1) {  //その横列にJがあったら\n\t\t\t\t\t\t\t\tfor (Jewelly jew : jList.get(j_h[i])) {\n\t\t\t\t\t\t\t\t\tif (jew.GetY()<j) jew.PlusO();\n\t\t\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'I':\n\t\t\t\t\t\tif (i>0) {\n\t\t\t\t\t\t\tif (j_w[j] != -1) {  //その縦列にJがあったら\n\t\t\t\t\t\t\t\tfor (Jewelly jew : jList.get(j_w[j])) {\n\t\t\t\t\t\t\t\t\tif (jew.GetX()<i) jew.PlusI();\n\t\t\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sum = 0;\n\t\t\tfor (Jewelly jew : jewelly) {\n\t\t\t\tsum += jew.GetI()*jew.GetO();\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Jewelly {\n\tprivate int x;\n\tprivate int y;\n\tprivate int orb;  //自分より右のOの数\n\tprivate int ingot;  //自分より下のIの数\n\n\tpublic Jewelly(int xx,int yy){\n\t\tx = xx;\n\t\ty = yy;\n\t\torb = 0;\n\t\tingot = 0;\n\t}\n\n\tpublic int getX() {return x;}\n\tpublic int getY() {return y;}\n\tpublic int getO() {return orb;}\n\tpublic int getI() {return ingot;}\n\n\tpublic void plusO() { orb++; }\n\tpublic void plusI() { ingot++; }\n\t\n\tpublic void update(int xx, int yy,int type) {\n\t\tif (type == 0) {\n\t\t\tif ((xx==x)&&(y<yy)) orb++;\n\t\t} else if (type == 1) {\n\t\t\tif ((yy==y)&&(x<xx)) ingot++;\n\t\t}\t\t\n\t}\n}\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tList<List<Jewelly>> jList = new LinkedList<List<Jewelly>>();\n\t\t\tList<Jewelly> jewelly = new LinkedList<Jewelly>();\n\t\t\tint[] j_h = new int[h];\n\t\t\tint[] j_w = new int[w];\n\t\t\tfor (int i=0; i<h; i++) j_h[i] = -1;\n\t\t\tfor (int i=0; i<w; i++) j_w[i] = -1;\n\t\t\t\n\t\t\tString s;\n\t\t\tchar[] c;\n\t\t\tfor (int i=0; i<h; i++) {\n\t\t\t\ts = sc.next();\n\t\t\t\tc = s.toCharArray();\n\t\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\t\tif (c[j] == 'J') {\n\t\t\t\t\t\tJewelly je = new Jewelly(i,j);\n\t\t\t\t\t\tjewelly.add(je);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tJewelly[] jew = new Jewelly[jewelly.size()];\n\t\t\t\t\t\tjewelly.toArray(jew);\n\t\t\t\t\t\tfor (int k=0; k<jew.length; k++) {\n\t\t\t\t\t\t\tif (c[j] == 'O')jew[k].update(i, j, 0);\n\t\t\t\t\t\t\telse jew[k].update(i, j, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong sum = 0;\n\t\t\tfor (Jewelly jew : jewelly) {\n\t\t\t\tsum += jew.getI()*jew.getO();\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tint pointer = 0;\n\t\t\tint[][] map_J = new int[h*w][2];\n\t\t\tint[] map_O = new int[h*w];\n\t\t\tint[] map_I = new int[h*w];\n\n\t\t\tString s;\n\t\t\tchar[] c;\n\t\t\tfor (int i=0; i<h; i++) {\n\t\t\t\ts = sc.next();\n\t\t\t\tc = s.toCharArray();\n\t\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\t\tswitch(c[j]) {\n\t\t\t\t\tcase 'J':\n\t\t\t\t\t\tmap_J[pointer][0] = i;\n\t\t\t\t\t\tmap_J[pointer][1] = j;\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'O':\n\t\t\t\t\t\tif (j>0) {\n\t\t\t\t\t\t\tmap_O[i*w+j] = 1;\n\t\t\t\t\t\t\tfor (int k=i*w; k<i*w+j; k++) map_O[k]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'I':\n\t\t\t\t\t\tif (i>0) {\n\t\t\t\t\t\t\tmap_I[i*w+j] = 1;\n\t\t\t\t\t\t\tfor (int k=0; k<i; k++) map_I[k*w+j]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong sum = 0;\n\t\t\tfor (int i=0; i<pointer; i++) {\n\t\t\t\tint posit = map_J[i][0]*w+map_J[i][1];\n\t\t\t\tsum += map_O[posit]*map_I[posit];\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Jewelly {\n\tprivate int x;\n\tprivate int y;\n\tprivate int orb;  //自分より右のOの数\n\tprivate int ingot;  //自分より下のIの数\n\n\tpublic Jewelly(int xx,int yy){\n\t\tx = xx;\n\t\ty = yy;\n\t\torb = 0;\n\t\tingot = 0;\n\t}\n\n\tpublic int getX() {return x;}\n\tpublic int getY() {return y;}\n\tpublic int getO() {return orb;}\n\tpublic int getI() {return ingot;}\n\n\tpublic void plusO() { orb++; }\n\tpublic void plusI() { ingot++; }\n\t\n\tpublic void update(int xx, int yy,int type) {\n\t\tif (type == 0) {\n\t\t\tif ((xx==x)&&(y<yy)) orb++;\n\t\t} else if (type == 1) {\n\t\t\tif ((yy==y)&&(x<xx)) ingot++;\n\t\t}\t\t\n\t}\n}\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tList<List<Jewelly>> jList = new LinkedList<List<Jewelly>>();\n\t\t\tList<Jewelly> jewelly = new LinkedList<Jewelly>();\n\t\t\tint[] j_h = new int[h];\n\t\t\tint[] j_w = new int[w];\n\t\t\tfor (int i=0; i<h; i++) j_h[i] = -1;\n\t\t\tfor (int i=0; i<w; i++) j_w[i] = -1;\n\t\t\t\n\t\t\tString s;\n\t\t\tchar[] c;\n\t\t\tfor (int i=0; i<h; i++) {\n\t\t\t\ts = sc.next();\n\t\t\t\tc = s.toCharArray();\n\t\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\t\tif (c[j] == 'J') {\n\t\t\t\t\t\tJewelly je = new Jewelly(i,j);\n\t\t\t\t\t\tjewelly.add(je);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tJewelly[] jew = new Jewelly[jewelly.size()];\n\t\t\t\t\t\tjewelly.toArray(jew);\n\t\t\t\t\t\tfor (int k=0; k<jew.length; k++) {\n\t\t\t\t\t\t\tif (c[j] == 'O')jew[k].update(i, j, 0);\n\t\t\t\t\t\t\telse jew[k].update(i, j, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong sum = 0;\n\t\t\tfor (Jewelly jew : jewelly) {\n\t\t\t\tsum += jew.getI()*jew.getO();\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int h = sc.nextInt();\n        int w = sc.nextInt();\n        char[][] field = new char[h][];\n        int[][] orbs = new int[h + 1][w + 1];\n        int[][] ingots = new int[h + 1][w + 1];\n        for (int i = 0; i < h; i++) {\n            field[i] = sc.next().toCharArray();\n            for (int j = w - 1; j >= 0; j--) {\n                orbs[i][j] = orbs[i][j + 1];\n                if (field[i][j] == 'O') {\n                    orbs[i][j]++;\n                }\n            }\n        }\n        for (int j = 0; j < w; j++) {\n            for (int i = h - 1; i >= 0; i--) {\n                ingots[i][j] = ingots[i + 1][j];\n                if (field[i][j] == 'I') {\n                    ingots[i][j]++;\n                }\n            }\n        }\n        long total = 0;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (field[i][j] == 'J') {\n                    total += orbs[i][j] * ingots[i][j];\n                }\n            }\n        }\n        System.out.println(total);\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Jewelly {\n\tprivate int x;\n\tprivate int y;\n\tprivate int orb;  //自分より右のOの数\n\tprivate int ingot;  //自分より下のIの数\n\n\tpublic Jewelly(int xx,int yy){\n\t\tx = xx;\n\t\ty = yy;\n\t\torb = 0;\n\t\tingot = 0;\n\t}\n\n\tpublic int GetX() {return x;}\n\tpublic int GetY() {return y;}\n\tpublic int GetO() {return orb;}\n\tpublic int GetI() {return ingot;}\n\n\tpublic void PlusO() { orb++; }\n\tpublic void PlusI() { ingot++; }\n\n}\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tList<List<Jewelly>> jList = new LinkedList<List<Jewelly>>();\n\t\t\tList<Jewelly> jewelly = new LinkedList<Jewelly>();\n\t\t\tint[] j_h = new int[h];\n\t\t\tint[] j_w = new int[w];\n\t\t\tfor (int i=0; i<h; i++) j_h[i] = -1;\n\t\t\tfor (int i=0; i<w; i++) j_w[i] = -1;\n\n\t\t\tString s;\n\t\t\tchar[] c;\n\t\t\tJewelly je;\n\t\t\tJewelly[] jew;\n\t\t\tfor (int i=0; i<h; i++) {\n\t\t\t\ts = sc.next();\n\t\t\t\tc = s.toCharArray();\n\t\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\t\tswitch(c[j]) {\n\t\t\t\t\tcase 'J':\n\t\t\t\t\t\tje = new Jewelly(i,j);\n\t\t\t\t\t\tjewelly.add(je);\n\t\t\t\t\t\t//縦配列に記録-------------------\n\t\t\t\t\t\tif (j_h[i] == -1) {  //なにも入ってなかったら\n\t\t\t\t\t\t\tjList.add(new LinkedList<Jewelly>());\n\t\t\t\t\t\t\tj_h[i] = jList.size()-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tjList.get(j_h[i]).add(je);\n\n\t\t\t\t\t\t//横配列に記録-------------------\n\t\t\t\t\t\tif (j_w[j] == -1) {  //なにも入ってなかったら\n\t\t\t\t\t\t\tjList.add(new LinkedList<Jewelly>());\n\t\t\t\t\t\t\tj_w[j] = jList.size()-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tjList.get(j_w[j]).add(je);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'O':\n\t\t\t\t\t\tif (j>0) {\n\t\t\t\t\t\t\tif (j_h[i] != -1) {  //その横列にJがあったら\n\t\t\t\t\t\t\t\tjew = new Jewelly[jList.get(j_h[i]).size()];\n\t\t\t\t\t\t\t\tjList.get(j_h[i]).toArray(jew);\n\t\t\t\t\t\t\t\tfor (int k=0; k<jew.length; k++) {\n\t\t\t\t\t\t\t\t\tif (jew[k].GetY()<j) jew[k].PlusO();\n\t\t\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'I':\n\t\t\t\t\t\tif (i>0) {\n\t\t\t\t\t\t\tif (j_w[j] != -1) {  //その縦列にJがあったら\n\t\t\t\t\t\t\t\tjew = new Jewelly[jList.get(j_w[j]).size()];\n\t\t\t\t\t\t\t\tjList.get(j_w[j]).toArray(jew);\n\t\t\t\t\t\t\t\tfor (int k=0; k<jew.length; k++) {\n\t\t\t\t\t\t\t\t\tif (jew[k].GetX()<i) jew[k].PlusI();\n\t\t\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong sum = 0;\n\t\t\tjew = new Jewelly[jewelly.size()];\n\t\t\tjewelly.toArray(jew);\n\t\t\tfor (int i=0; i<jew.length; i++) {\n\t\t\t\tsum += jew[i].GetI()*jew[i].GetO();\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Jewelly {\n\tprivate int x;\n\tprivate int y;\n\tprivate int orb;  //自分より右のOの数\n\tprivate int ingot;  //自分より下のIの数\n\n\tpublic Jewelly(int xx,int yy){\n\t\tx = xx;\n\t\ty = yy;\n\t\torb = 0;\n\t\tingot = 0;\n\t}\n\n\tpublic int GetX() {return x;}\n\tpublic int GetY() {return y;}\n\tpublic int GetO() {return orb;}\n\tpublic int GetI() {return ingot;}\n\n\tpublic void PlusO() { orb++; }\n\tpublic void PlusI() { ingot++; }\n\n}\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tList<List<Jewelly>> jList = new LinkedList<List<Jewelly>>();\n\t\t\tList<Jewelly> jewelly = new LinkedList<Jewelly>();\n\t\t\tint[] j_h = new int[h];\n\t\t\tint[] j_w = new int[w];\n\t\t\tfor (int i=0; i<h; i++) j_h[i] = -1;\n\t\t\tfor (int i=0; i<w; i++) j_w[i] = -1;\n\n\t\t\tfor (int i=0; i<h; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tchar[] c = s.toCharArray();\n\t\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\t\tswitch(c[j]) {\n\t\t\t\t\tcase 'J':\n\t\t\t\t\t\tJewelly je = new Jewelly(i,j);\n\t\t\t\t\t\tjewelly.add(je);\n\t\t\t\t\t\t//縦配列に記録-------------------\n\t\t\t\t\t\tif (j_h[i] == -1) {  //なにも入ってなかったら\n\t\t\t\t\t\t\tjList.add(new LinkedList<Jewelly>());\n\t\t\t\t\t\t\tj_h[i] = jList.size()-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tjList.get(j_h[i]).add(je);\n\t\t\t\t\t\t\n\t\t\t\t\t\t//横配列に記録-------------------\n\t\t\t\t\t\tif (j_w[j] == -1) {  //なにも入ってなかったら\n\t\t\t\t\t\t\tjList.add(new LinkedList<Jewelly>());\n\t\t\t\t\t\t\tj_w[j] = jList.size()-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tjList.get(j_w[j]).add(je);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'O':\n\t\t\t\t\t\tif (j>0) {\n\t\t\t\t\t\t\tif (j_h[i] != -1) {  //その横列にJがあったら\n\t\t\t\t\t\t\t\tfor (Jewelly jew : jList.get(j_h[i])) {\n\t\t\t\t\t\t\t\t\tif (jew.GetY()<j) jew.PlusO();\n\t\t\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'I':\n\t\t\t\t\t\tif (i>0) {\n\t\t\t\t\t\t\tif (j_w[j] != -1) {  //その縦列にJがあったら\n\t\t\t\t\t\t\t\tfor (Jewelly jew : jList.get(j_w[j])) {\n\t\t\t\t\t\t\t\t\tif (jew.GetX()<i) jew.PlusI();\n\t\t\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sum = 0;\n\t\t\tfor (Jewelly jew : jewelly) {\n\t\t\t\tsum += jew.GetI()*jew.GetO();\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Jewelly {\n\tprivate int x;\n\tprivate int y;\n\tprivate int orb;  //自分より右のOの数\n\tprivate int ingot;  //自分より下のIの数\n\n\tpublic Jewelly(int xx,int yy){\n\t\tx = xx;\n\t\ty = yy;\n\t\torb = 0;\n\t\tingot = 0;\n\t}\n\n\tpublic int GetX() {return x;}\n\tpublic int GetY() {return y;}\n\tpublic int GetO() {return orb;}\n\tpublic int GetI() {return ingot;}\n\n\tpublic void PlusO() { orb++; }\n\tpublic void PlusI() { ingot++; }\n\n}\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tList<List<Jewelly>> jList = new LinkedList<List<Jewelly>>();\n\t\t\tList<Jewelly> jewelly = new LinkedList<Jewelly>();\n\t\t\tint[] j_h = new int[h];\n\t\t\tint[] j_w = new int[w];\n\t\t\tfor (int i=0; i<h; i++) j_h[i] = -1;\n\t\t\tfor (int i=0; i<w; i++) j_w[i] = -1;\n\n\t\t\tString s;\n\t\t\tchar[] c;\n\t\t\tJewelly je;\n\t\t\tfor (int i=0; i<h; i++) {\n\t\t\t\ts = sc.next();\n\t\t\t\tc = s.toCharArray();\n\t\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\t\tswitch(c[j]) {\n\t\t\t\t\tcase 'J':\n\t\t\t\t\t\tje = new Jewelly(i,j);\n\t\t\t\t\t\tjewelly.add(je);\n\t\t\t\t\t\t//縦配列に記録-------------------\n\t\t\t\t\t\tif (j_h[i] == -1) {  //なにも入ってなかったら\n\t\t\t\t\t\t\tjList.add(new LinkedList<Jewelly>());\n\t\t\t\t\t\t\tj_h[i] = jList.size()-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tjList.get(j_h[i]).add(je);\n\n\t\t\t\t\t\t//横配列に記録-------------------\n\t\t\t\t\t\tif (j_w[j] == -1) {  //なにも入ってなかったら\n\t\t\t\t\t\t\tjList.add(new LinkedList<Jewelly>());\n\t\t\t\t\t\t\tj_w[j] = jList.size()-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tjList.get(j_w[j]).add(je);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'O':\n\t\t\t\t\t\tif (j>0) {\n\t\t\t\t\t\t\tif (j_h[i] != -1) {  //その横列にJがあったら\n\t\t\t\t\t\t\t\tfor (Jewelly jew : jList.get(j_h[i])) {\n\t\t\t\t\t\t\t\t\tif (jew.GetY()<j) jew.PlusO();\n\t\t\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'I':\n\t\t\t\t\t\tif (i>0) {\n\t\t\t\t\t\t\tif (j_w[j] != -1) {  //その縦列にJがあったら\n\t\t\t\t\t\t\t\tfor (Jewelly jew : jList.get(j_w[j])) {\n\t\t\t\t\t\t\t\t\tif (jew.GetX()<i) jew.PlusI();\n\t\t\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong sum = 0;\n\t\t\tJewelly[] jew = new Jewelly[jewelly.size()];\n\t\t\tjewelly.toArray(jew);\n\t\t\tfor (int i=0; i<jew.length; i++) {\n\t\t\t\tsum += jew[i].GetI()*jew[i].GetO();\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Jewelly {\n\tprivate int x;\n\tprivate int y;\n\tprivate int orb;  //自分より右のOの数\n\tprivate int ingot;  //自分より下のIの数\n\n\tpublic Jewelly(int xx,int yy){\n\t\tx = xx;\n\t\ty = yy;\n\t\torb = 0;\n\t\tingot = 0;\n\t}\n\n\tpublic int getX() {return x;}\n\tpublic int getY() {return y;}\n\tpublic int getO() {return orb;}\n\tpublic int getI() {return ingot;}\n\n\tpublic void plusO() { orb++; }\n\tpublic void plusI() { ingot++; }\n\t\n\tpublic void update(int xx, int yy,int type) {\n\t\tif (type == 0) {\n\t\t\tif ((xx==x)&&(y<yy)) orb++;\n\t\t} else if (type == 1) {\n\t\t\tif ((yy==y)&&(x<xx)) ingot++;\n\t\t}\t\t\n\t}\n}\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tList<List<Jewelly>> jList = new LinkedList<List<Jewelly>>();\n\t\t\tList<Jewelly> jewelly = new LinkedList<Jewelly>();\n\t\t\tint[] j_h = new int[h];\n\t\t\tint[] j_w = new int[w];\n\t\t\tfor (int i=0; i<h; i++) j_h[i] = -1;\n\t\t\tfor (int i=0; i<w; i++) j_w[i] = -1;\n\t\t\t\n\t\t\tString s;\n\t\t\tchar[] c;\n\t\t\tfor (int i=0; i<h; i++) {\n\t\t\t\ts = sc.next();\n\t\t\t\tc = s.toCharArray();\n\t\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\t\tif (c[j] == 'J') {\n\t\t\t\t\t\tJewelly je = new Jewelly(i,j);\n\t\t\t\t\t\tjewelly.add(je);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (Jewelly jew : jewelly) {\n\t\t\t\t\t\t\tif (c[j] == 'O')jew.update(i, j, 0);\n\t\t\t\t\t\t\telse jew.update(i, j, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong sum = 0;\n\t\t\tfor (Jewelly jew : jewelly) {\n\t\t\t\tsum += jew.getI()*jew.getO();\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Jewelly {\n\tprivate int x;\n\tprivate int y;\n\tprivate int orb;  //自分より右のOの数\n\tprivate int ingot;  //自分より下のIの数\n\n\tpublic Jewelly(int xx,int yy){\n\t\tx = xx;\n\t\ty = yy;\n\t\torb = 0;\n\t\tingot = 0;\n\t}\n\n\tpublic int getX() {return x;}\n\tpublic int getY() {return y;}\n\tpublic int getO() {return orb;}\n\tpublic int getI() {return ingot;}\n\n\tpublic void plusO() { orb++; }\n\tpublic void plusI() { ingot++; }\n\t\n\tpublic void update(int xx, int yy,int type) {\n\t\tif (type == 0) {\n\t\t\tif ((xx==x)&&(y<yy)) orb++;\n\t\t} else if (type == 1) {\n\t\t\tif ((yy==y)&&(x<xx)) ingot++;\n\t\t}\t\t\n\t}\n}\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tList<List<Jewelly>> jList = new LinkedList<List<Jewelly>>();\n\t\t\tList<Jewelly> jewelly = new LinkedList<Jewelly>();\n\t\t\tint[] j_h = new int[h];\n\t\t\tint[] j_w = new int[w];\n\t\t\tfor (int i=0; i<h; i++) j_h[i] = -1;\n\t\t\tfor (int i=0; i<w; i++) j_w[i] = -1;\n\t\t\t\n\t\t\tString s;\n\t\t\tchar[] c;\n\t\t\tfor (int i=0; i<h; i++) {\n\t\t\t\ts = sc.next();\n\t\t\t\tc = s.toCharArray();\n\t\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\t\tif (c[j] == 'J') {\n\t\t\t\t\t\tJewelly je = new Jewelly(i,j);\n\t\t\t\t\t\tjewelly.add(je);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (Jewelly jew : jewelly) {\n\t\t\t\t\t\t\tif (c[j] == 'O')jew.update(i, j, 0);\n\t\t\t\t\t\t\telse jew.update(i, j, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong sum = 0;\n\t\t\tfor (Jewelly jew : jewelly) {\n\t\t\t\tsum += jew.getI()*jew.getO();\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Jewelly {\n\tprivate int x;\n\tprivate int y;\n\tprivate int orb;  //自分より右のOの数\n\tprivate int ingot;  //自分より下のIの数\n\n\tpublic Jewelly(int xx,int yy){\n\t\tx = xx;\n\t\ty = yy;\n\t\torb = 0;\n\t\tingot = 0;\n\t}\n\n\tpublic int GetX() {return x;}\n\tpublic int GetY() {return y;}\n\tpublic int GetO() {return orb;}\n\tpublic int GetI() {return ingot;}\n\n\tpublic void PlusO() { orb++; }\n\tpublic void PlusI() { ingot++; }\n\n}\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tList<List<Jewelly>> jList = new LinkedList<List<Jewelly>>();\n\t\t\tList<Jewelly> jewelly = new LinkedList<Jewelly>();\n\t\t\tint[] j_h = new int[h];\n\t\t\tint[] j_w = new int[w];\n\t\t\tfor (int i=0; i<h; i++) j_h[i] = -1;\n\t\t\tfor (int i=0; i<w; i++) j_w[i] = -1;\n\n\t\t\tfor (int i=0; i<h; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tchar[] c = s.toCharArray();\n\t\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\t\tswitch(c[j]) {\n\t\t\t\t\tcase 'J':\n\t\t\t\t\t\tJewelly je = new Jewelly(i,j);\n\t\t\t\t\t\tjewelly.add(je);\n\t\t\t\t\t\t//縦配列に記録-------------------\n\t\t\t\t\t\tif (j_h[i] == -1) {  //なにも入ってなかったら\n\t\t\t\t\t\t\tjList.add(new LinkedList<Jewelly>());\n\t\t\t\t\t\t\tj_h[i] = jList.size()-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tjList.get(j_h[i]).add(je);\n\t\t\t\t\t\t\n\t\t\t\t\t\t//横配列に記録-------------------\n\t\t\t\t\t\tif (j_w[j] == -1) {  //なにも入ってなかったら\n\t\t\t\t\t\t\tjList.add(new LinkedList<Jewelly>());\n\t\t\t\t\t\t\tj_w[j] = jList.size()-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tjList.get(j_w[j]).add(je);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'O':\n\t\t\t\t\t\tif (j>0) {\n\t\t\t\t\t\t\tif (j_h[i] != -1) {  //その横列にJがあったら\n\t\t\t\t\t\t\t\tfor (Jewelly jew : jList.get(j_h[i])) {\n\t\t\t\t\t\t\t\t\tif (jew.GetY()<j) jew.PlusO();\n\t\t\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'I':\n\t\t\t\t\t\tif (i>0) {\n\t\t\t\t\t\t\tif (j_w[j] != -1) {  //その縦列にJがあったら\n\t\t\t\t\t\t\t\tfor (Jewelly jew : jList.get(j_w[j])) {\n\t\t\t\t\t\t\t\t\tif (jew.GetX()<i) jew.PlusI();\n\t\t\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sum = 0;\n\t\t\tfor (Jewelly jew : jewelly) {\n\t\t\t\tsum += jew.GetI()*jew.GetO();\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Jewelly {\n\tprivate int x;\n\tprivate int y;\n\tprivate int orb;  //自分より右のOの数\n\tprivate int ingot;  //自分より下のIの数\n\n\tpublic Jewelly(int xx,int yy){\n\t\tx = xx;\n\t\ty = yy;\n\t\torb = 0;\n\t\tingot = 0;\n\t}\n\n\tpublic int GetX() {return x;}\n\tpublic int GetY() {return y;}\n\tpublic int GetO() {return orb;}\n\tpublic int GetI() {return ingot;}\n\n\tpublic void PlusO() { orb++; }\n\tpublic void PlusI() { ingot++; }\n\n}\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tList<List<Jewelly>> jList = new LinkedList<List<Jewelly>>();\n\t\t\tList<Jewelly> jewelly = new LinkedList<Jewelly>();\n\t\t\tint[] j_h = new int[h];\n\t\t\tint[] j_w = new int[w];\n\t\t\tfor (int i=0; i<h; i++) j_h[i] = -1;\n\t\t\tfor (int i=0; i<w; i++) j_w[i] = -1;\n\n\t\t\tfor (int i=0; i<h; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tchar[] c = s.toCharArray();\n\t\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\t\tswitch(c[j]) {\n\t\t\t\t\tcase 'J':\n\t\t\t\t\t\tJewelly je = new Jewelly(i,j);\n\t\t\t\t\t\tjewelly.add(je);\n\t\t\t\t\t\t//縦配列に記録-------------------\n\t\t\t\t\t\tif (j_h[i] == -1) {  //なにも入ってなかったら\n\t\t\t\t\t\t\tjList.add(new LinkedList<Jewelly>());\n\t\t\t\t\t\t\tj_h[i] = jList.size()-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tjList.get(j_h[i]).add(je);\n\t\t\t\t\t\t\n\t\t\t\t\t\t//横配列に記録-------------------\n\t\t\t\t\t\tif (j_w[j] == -1) {  //なにも入ってなかったら\n\t\t\t\t\t\t\tjList.add(new LinkedList<Jewelly>());\n\t\t\t\t\t\t\tj_w[j] = jList.size()-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tjList.get(j_w[j]).add(je);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'O':\n\t\t\t\t\t\tif (j>0) {\n\t\t\t\t\t\t\tif (j_h[i] != -1) {  //その横列にJがあったら\n\t\t\t\t\t\t\t\tfor (Jewelly jew : jList.get(j_h[i])) {\n\t\t\t\t\t\t\t\t\tif (jew.GetY()<j) jew.PlusO();\n\t\t\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'I':\n\t\t\t\t\t\tif (i>0) {\n\t\t\t\t\t\t\tif (j_w[j] != -1) {  //その縦列にJがあったら\n\t\t\t\t\t\t\t\tfor (Jewelly jew : jList.get(j_w[j])) {\n\t\t\t\t\t\t\t\t\tif (jew.GetX()<i) jew.PlusI();\n\t\t\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong sum = 0;\n\t\t\tfor (Jewelly jew : jewelly) {\n\t\t\t\tsum += jew.GetI()*jew.GetO();\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Jewelly {\n\tprivate int x;\n\tprivate int y;\n\tprivate int orb;  //自分より右のOの数\n\tprivate int ingot;  //自分より下のIの数\n\n\tpublic Jewelly(int xx,int yy){\n\t\tx = xx;\n\t\ty = yy;\n\t\torb = 0;\n\t\tingot = 0;\n\t}\n\n\tpublic int GetX() {return x;}\n\tpublic int GetY() {return y;}\n\tpublic int GetO() {return orb;}\n\tpublic int GetI() {return ingot;}\n\n\tpublic void PlusO() { orb++; }\n\tpublic void PlusI() { ingot++; }\n\n}\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tList<List<Jewelly>> jList = new LinkedList<List<Jewelly>>();\n\t\t\tList<Jewelly> jewelly = new LinkedList<Jewelly>();\n\t\t\tint[] j_h = new int[h];\n\t\t\tint[] j_w = new int[w];\n\t\t\tfor (int i=0; i<h; i++) j_h[i] = -1;\n\t\t\tfor (int i=0; i<w; i++) j_w[i] = -1;\n\n\t\t\tfor (int i=0; i<h; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tchar[] c = s.toCharArray();\n\t\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\t\tswitch(c[j]) {\n\t\t\t\t\tcase 'J':\n\t\t\t\t\t\tJewelly je = new Jewelly(i,j);\n\t\t\t\t\t\tjewelly.add(je);\n\t\t\t\t\t\t//縦配列に記録-------------------\n\t\t\t\t\t\tif (j_h[i] == -1) {  //なにも入ってなかったら\n\t\t\t\t\t\t\tjList.add(new LinkedList<Jewelly>());\n\t\t\t\t\t\t\tj_h[i] = jList.size()-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tjList.get(j_h[i]).add(je);\n\n\t\t\t\t\t\t//横配列に記録-------------------\n\t\t\t\t\t\tif (j_w[j] == -1) {  //なにも入ってなかったら\n\t\t\t\t\t\t\tjList.add(new LinkedList<Jewelly>());\n\t\t\t\t\t\t\tj_w[j] = jList.size()-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tjList.get(j_w[j]).add(je);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'O':\n\t\t\t\t\t\tif (j>0) {\n\t\t\t\t\t\t\tif (j_h[i] != -1) {  //その横列にJがあったら\n\t\t\t\t\t\t\t\tfor (Jewelly jew : jList.get(j_h[i])) {\n\t\t\t\t\t\t\t\t\tif (jew.GetY()<j) jew.PlusO();\n\t\t\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'I':\n\t\t\t\t\t\tif (i>0) {\n\t\t\t\t\t\t\tif (j_w[j] != -1) {  //その縦列にJがあったら\n\t\t\t\t\t\t\t\tfor (Jewelly jew : jList.get(j_w[j])) {\n\t\t\t\t\t\t\t\t\tif (jew.GetX()<i) jew.PlusI();\n\t\t\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong sum = 0;\n\t\t\tJewelly[] jew = new Jewelly[jewelly.size()];\n\t\t\tjewelly.toArray(jew);\n\t\t\tfor (int i=0; i<jew.length; i++) {\n\t\t\t\tsum += jew[i].GetI()*jew[i].GetO();\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Jewelly {\n\tprivate int x;\n\tprivate int y;\n\tprivate int orb;  //自分より右のOの数\n\tprivate int ingot;  //自分より下のIの数\n\n\tpublic Jewelly(int xx,int yy){\n\t\tx = xx;\n\t\ty = yy;\n\t\torb = 0;\n\t\tingot = 0;\n\t}\n\n\tpublic int getX() {return x;}\n\tpublic int getY() {return y;}\n\tpublic int getO() {return orb;}\n\tpublic int getI() {return ingot;}\n\n\tpublic void plusO() { orb++; }\n\tpublic void plusI() { ingot++; }\n\t\n\tpublic void update(int xx, int yy,int type) {\n\t\tif (type == 0) {\n\t\t\tif ((xx==x)&&(y<yy)) orb++;\n\t\t} else if (type == 1) {\n\t\t\tif ((yy==y)&&(x<xx)) ingot++;\n\t\t}\t\t\n\t}\n}\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tList<List<Jewelly>> jList = new LinkedList<List<Jewelly>>();\n\t\t\tList<Jewelly> jewelly = new LinkedList<Jewelly>();\n\t\t\tint[] j_h = new int[h];\n\t\t\tint[] j_w = new int[w];\n\t\t\tfor (int i=0; i<h; i++) j_h[i] = -1;\n\t\t\tfor (int i=0; i<w; i++) j_w[i] = -1;\n\t\t\t\n\t\t\tString s;\n\t\t\tchar[] c;\n\t\t\tfor (int i=0; i<h; i++) {\n\t\t\t\ts = sc.next();\n\t\t\t\tc = s.toCharArray();\n\t\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\t\tif (c[j] == 'J') {\n\t\t\t\t\t\tJewelly je = new Jewelly(i,j);\n\t\t\t\t\t\tjewelly.add(je);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (Jewelly jew : jewelly) {\n\t\t\t\t\t\t\tif (c[j] == 'O')jew.update(i, j, 0);\n\t\t\t\t\t\t\telse jew.update(i, j, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong sum = 0;\n\t\t\tfor (Jewelly jew : jewelly) {\n\t\t\t\tsum += jew.getI()*jew.getO();\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Jewelly {\n\tprivate int x;\n\tprivate int y;\n\tprivate int orb;  //自分より右のOの数\n\tprivate int ingot;  //自分より下のIの数\n\n\tpublic Jewelly(int xx,int yy){\n\t\tx = xx;\n\t\ty = yy;\n\t\torb = 0;\n\t\tingot = 0;\n\t}\n\n\tpublic int getX() {return x;}\n\tpublic int getY() {return y;}\n\tpublic int getO() {return orb;}\n\tpublic int getI() {return ingot;}\n\n\tpublic void plusO() { orb++; }\n\tpublic void plusI() { ingot++; }\n\t\n\tpublic void update(int xx, int yy,int type) {\n\t\tif (type == 0) {\n\t\t\tif ((xx==x)&&(y<yy)) orb++;\n\t\t} else if (type == 1) {\n\t\t\tif ((yy==y)&&(x<xx)) ingot++;\n\t\t}\t\t\n\t}\n}\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\ttry (Scanner sc = new Scanner(System.in)) {\n\t\t\tint h = sc.nextInt();\n\t\t\tint w = sc.nextInt();\n\t\t\tList<List<Jewelly>> jList = new LinkedList<List<Jewelly>>();\n\t\t\tList<Jewelly> jewelly = new LinkedList<Jewelly>();\n\t\t\tint[] j_h = new int[h];\n\t\t\tint[] j_w = new int[w];\n\t\t\tfor (int i=0; i<h; i++) j_h[i] = -1;\n\t\t\tfor (int i=0; i<w; i++) j_w[i] = -1;\n\t\t\t\n\t\t\tString s;\n\t\t\tchar[] c;\n\t\t\tfor (int i=0; i<h; i++) {\n\t\t\t\ts = sc.next();\n\t\t\t\tc = s.toCharArray();\n\t\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\t\tif (c[j] == 'J') {\n\t\t\t\t\t\tJewelly je = new Jewelly(i,j);\n\t\t\t\t\t\tjewelly.add(je);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tJewelly[] jew = new Jewelly[jewelly.size()];\n\t\t\t\t\t\tjewelly.toArray(jew);\n\t\t\t\t\t\tfor (int k=0; k<jew.length; k++) {\n\t\t\t\t\t\t\tif (c[j] == 'O')jew[k].update(i, j, 0);\n\t\t\t\t\t\t\telse jew[k].update(i, j, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong sum = 0;\n\t\t\tfor (Jewelly jew : jewelly) {\n\t\t\t\tsum += jew.getI()*jew.getO();\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class hello\n{\n    public static void Main()\n    {\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        var h = int.Parse(line[0]);\n        var w = int.Parse(line[1]);\n        var map = new char[h, w];\n        var mapo = new int[h, w];\n        var mapi = new int[h, w];\n        for (int i = 0; i < h; i++)\n        {\n            var s = Console.ReadLine().Trim();\n            for (int j = 0; j < w; j++) map[i, j] = s[j];\n        }\n        for (int i = 0; i < h; i++) if (map[i, w - 1] == 'O') mapo[i, w - 1] = 1;\n        for (int i = 0; i < w; i++) if (map[h - 1, i] == 'I') mapi[h - 1, i] = 1;\n        for (int i = 0; i < h; i++)\n            for (int j = w - 2; j >= 0; j--)\n            {\n                mapo[i, j] = mapo[i, j + 1];\n                if (map[i, j] == 'O') mapo[i, j]++;\n            }\n        for (int i = 0; i < w; i++)\n            for (int j = h - 2; j >= 0; j--)\n            {\n                mapi[j, i] = mapi[j + 1, i];\n                if (map[j, i] == 'I') mapi[j, i]++;\n            }\n        var count = 0L;\n        for (int i = 0; i < h - 1; i++)\n            for (int j = 0; j < w - 1; j++)\n                if (map[i, j] == 'J') count += mapo[i, j] * mapi[i, j];\n        Console.WriteLine(count);\n    }\n}\n"
  },
  {
    "language": "Ruby",
    "code": "h, w = gets.chomp.split.map(&:to_i)\nmap = []\nh.times{map << gets.chomp}\narr = Array.new(h+1){Array.new(w+1){[0,0]}}\n\nsum = 0\n(h-1).downto(0){|j|\n    (w-1).downto(0){|i|\n        arr[j][i][0] = arr[j][i+1][0]\n        arr[j][i][1] = arr[j+1][i][1]\n        case map[j][i]\n        when \"J\"\n            sum += arr[j][i][0] * arr[j][i][1]\n        when \"O\"\n            arr[j][i][0] += 1\n        when \"I\"\n            arr[j][i][1] += 1\n        end\n    }\n}\nputs sum\n"
  },
  {
    "language": "Python",
    "code": "h, w = map(int, input().split())\ns = [list(input()) for _ in range(h)]\n\nans = 0\nci = [0 for _ in range(w)]\nfor i in range(h - 1, -1, -1):\n    co = 0\n    for j in range(w - 1, -1, -1):\n        if s[i][j] == 'J':\n            ans += co * ci[j]\n        elif s[i][j] == 'O':\n            co += 1\n        elif s[i][j] == 'I':\n            ci[j] += 1\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\nH, W = map(int, readline().split())\nS = [readline().strip() for i in range(H)]\n\nans = 0\nD = [0]*W\nfor i in range(H-1, -1, -1):\n    Si = S[i]\n    cur = 0\n    for j in range(W-1, -1, -1):\n        c = Si[j]\n        if c == 'J':\n            ans += D[j]*cur\n        elif c == 'O':\n            cur += 1\n        else:\n            D[j] += 1\nwrite(\"%d\\n\" % ans)\n"
  },
  {
    "language": "Python",
    "code": "h, w = [int(i) for i in input().split()]\nsquares = [list(input()) for _ in range(h)]\n\nans = 0\nh_cnts = [0] * w\nfor i in reversed(range(0, h)):\n    o_cnt = 0\n    for j in reversed(range(0, w)):\n        if squares[i][j] == 'I':\n            h_cnts[j] += 1\n        elif squares[i][j] == 'O':\n            o_cnt += 1\n        else:\n            ans += h_cnts[j] * o_cnt\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    h, w = map(int, input().split())\n    mp = [input() for _ in range(h)]\n    \n    i_cnt = [[0] * w for _ in range(h)]\n    o_cnt = [[0] * w for _ in range(h)]\n    \n    for x in range(w):\n        if mp[h - 1][x] == \"I\":\n            i_cnt[h - 1][x] = 1\n    \n    for y in range(h):\n        if mp[y][w - 1] == \"O\":\n            o_cnt[y][w - 1] = 1\n    \n    ans = 0\n    for y in range(h - 2, -1, -1):\n        for x in range(w - 2, -1, -1):\n            if mp[y][x] == \"I\":\n                i_cnt[y][x] = i_cnt[y + 1][x] + 1\n                o_cnt[y][x] = o_cnt[y][x + 1]\n            elif mp[y][x] == \"O\":\n                i_cnt[y][x] = i_cnt[y + 1][x]\n                o_cnt[y][x] = o_cnt[y][x + 1] + 1\n            else:\n                i_cnt[y][x] = i_cnt[y + 1][x]\n                o_cnt[y][x] = o_cnt[y][x + 1]\n                ans += i_cnt[y][x] * o_cnt[y][x]\n    \n    print(ans)\n\nmain()\n\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/python3\n\nimport array\nfrom fractions import Fraction\nimport functools\nimport itertools\nimport math\nimport os\nimport sys\n\n\ndef main():\n    H, W = read_ints()\n    S = [inp() for _ in range(H)]\n    print(solve(H, W, S))\n\n\ndef solve(H, W, S):\n    o_table = [[0] * W for _ in range(H)]\n    for y in range(H):\n        c = 0\n        for x in range(W - 1, -1, -1):\n            if S[y][x] == 'O':\n                c += 1\n            o_table[y][x] = c\n\n    i_table = [[0] * W for _ in range(H)]\n    for x in range(W):\n        c = 0\n        for y in range(H - 1, -1, -1):\n            if S[y][x] == 'I':\n                c += 1\n            i_table[y][x] = c\n\n    ans = 0\n    for y in range(H):\n        for x in range(W):\n            if S[y][x] == 'J':\n                ans += o_table[y][x] * i_table[y][x]\n\n    return ans\n\n\n###############################################################################\n# AUXILIARY FUNCTIONS\n\nDEBUG = 'DEBUG' in os.environ\n\n\ndef inp():\n    return sys.stdin.readline().rstrip()\n\n\ndef read_int():\n    return int(inp())\n\n\ndef read_ints():\n    return [int(e) for e in inp().split()]\n\n\ndef dprint(*value, sep=' ', end='\\n'):\n    if DEBUG:\n        print(*value, sep=sep, end=end)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    h, w = map(int, input().split())\n    mp = [input() for _ in range(h)]\n    \n    i_cnt = [[0] * w for _ in range(h)]\n    o_cnt = [[0] * w for _ in range(h)]\n    \n    for x in range(w):\n        if mp[h - 1][x] == \"I\":\n            i_cnt[h - 1][x] = 1\n    \n    for y in range(h):\n        if mp[y][w - 1] == \"O\":\n            o_cnt[y][w - 1] = 1\n    \n    ans = 0\n    for y in range(h - 2, -1, -1):\n        for x in range(w - 2, -1, -1):\n            if mp[y][x] == \"I\":\n                i_cnt[y][x] = i_cnt[y + 1][x] + 1\n                o_cnt[y][x] = o_cnt[y][x + 1]\n            elif mp[y][x] == \"O\":\n                i_cnt[y][x] = i_cnt[y + 1][x]\n                o_cnt[y][x] = o_cnt[y][x + 1] + 1\n            else:\n                i_cnt[y][x] = i_cnt[y + 1][x]\n                o_cnt[y][x] = o_cnt[y][x + 1]\n                ans += i_cnt[y][x] * o_cnt[y][x]\n    \n    print(ans)\n\nmain()\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nfn read(s: &mut StdinLock, num: usize) -> Vec<usize> {\n    let stdin_iter = &mut s.by_ref().bytes().map(|c| c.unwrap() as char);\n    (0..num).map(|_| \n        stdin_iter\n            .take_while(|c| !c.is_whitespace())\n            .skip_while(|c| c.is_whitespace())\n            .fold(0, |a, x| (x as u8 - b'0') as usize + a * 10)\n    ).collect()\n}\n\nfn main() {\n    let s = stdin();\n    let mut s = s.lock();\n    let hw: Vec<usize> = read(&mut s, 2);\n    let h = hw[0];\n    let w = hw[1];\n    let squares: Vec<Vec<char>> = {\n        let mut squares: Vec<Vec<char>> = Vec::new();\n        for _ in 0..h {\n            squares.push(\n                s.by_ref().bytes().map(|c| c.unwrap() as char)\n                    .take_while(|c| !c.is_whitespace())\n                    .skip_while(|c| c.is_whitespace())\n                    .collect::<Vec<char>>());\n        }\n        squares\n    };\n    let mut ans: u64 = 0;\n    let mut h_cnts: Vec<u64> = vec![0; w];\n    for i in (0..h).rev() {\n        let mut o_cnt: u64 = 0;\n        for j in (0..w).rev() {\n            if squares[i][j] == 'I' {\n                h_cnts[j] += 1;\n            } else if squares[i][j] == 'O' {\n                o_cnt += 1;\n            } else {\n                ans += h_cnts[j] * o_cnt;\n            }\n        }\n    }\n    println!(\"{}\", ans);\n}\n"
  }
]