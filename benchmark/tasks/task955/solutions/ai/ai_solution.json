[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_CITIES 100005\n\nint parent_road[MAX_CITIES];\nint parent_rail[MAX_CITIES];\nint road_rank[MAX_CITIES];\nint rail_rank[MAX_CITIES];\n\nint find_road(int x) {\n    if (parent_road[x] != x)\n        parent_road[x] = find_road(parent_road[x]);\n    return parent_road[x];\n}\n\nint find_rail(int x) {\n    if (parent_rail[x] != x)\n        parent_rail[x] = find_rail(parent_rail[x]);\n    return parent_rail[x];\n}\n\nvoid union_road(int x, int y) {\n    int px = find_road(x);\n    int py = find_road(y);\n    \n    if (px == py) return;\n    \n    if (road_rank[px] < road_rank[py])\n        parent_road[px] = py;\n    else if (road_rank[px] > road_rank[py])\n        parent_road[py] = px;\n    else {\n        parent_road[py] = px;\n        road_rank[px]++;\n    }\n}\n\nvoid union_rail(int x, int y) {\n    int px = find_rail(x);\n    int py = find_rail(y);\n    \n    if (px == py) return;\n    \n    if (rail_rank[px] < rail_rank[py])\n        parent_rail[px] = py;\n    else if (rail_rank[px] > rail_rank[py])\n        parent_rail[py] = px;\n    else {\n        parent_rail[py] = px;\n        rail_rank[px]++;\n    }\n}\n\nint main() {\n    int N, K, L;\n    scanf(\"%d %d %d\", &N, &K, &L);\n    \n    for (int i = 1; i <= N; i++) {\n        parent_road[i] = i;\n        parent_rail[i] = i;\n        road_rank[i] = 0;\n        rail_rank[i] = 0;\n    }\n    \n    for (int i = 0; i < K; i++) {\n        int p, q;\n        scanf(\"%d %d\", &p, &q);\n        union_road(p, q);\n    }\n    \n    for (int i = 0; i < L; i++) {\n        int r, s;\n        scanf(\"%d %d\", &r, &s);\n        union_rail(r, s);\n    }\n    \n    int count[MAX_CITIES] = {0};\n    for (int i = 1; i <= N; i++) {\n        count[find_road(i) * N + find_rail(i)]++;\n    }\n    \n    for (int i = 1; i <= N; i++) {\n        printf(\"%d \", count[find_road(i) * N + find_rail(i)]);\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:27:43"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int parent;\n    int rank;\n} Node;\n\ntypedef struct {\n    Node *nodes;\n    int size;\n} UnionFind;\n\nUnionFind* createUnionFind(int size) {\n    UnionFind *uf = (UnionFind*)malloc(sizeof(UnionFind));\n    uf->size = size;\n    uf->nodes = (Node*)malloc(size * sizeof(Node));\n    for (int i = 0; i < size; i++) {\n        uf->nodes[i].parent = i;\n        uf->nodes[i].rank = 0;\n    }\n    return uf;\n}\n\nint find(UnionFind *uf, int x) {\n    if (uf->nodes[x].parent != x) {\n        uf->nodes[x].parent = find(uf, uf->nodes[x].parent);\n    }\n    return uf->nodes[x].parent;\n}\n\nvoid unite(UnionFind *uf, int x, int y) {\n    int rootX = find(uf, x);\n    int rootY = find(uf, y);\n    if (rootX != rootY) {\n        if (uf->nodes[rootX].rank < uf->nodes[rootY].rank) {\n            uf->nodes[rootX].parent = rootY;\n        } else if (uf->nodes[rootX].rank > uf->nodes[rootY].rank) {\n            uf->nodes[rootY].parent = rootX;\n        } else {\n            uf->nodes[rootY].parent = rootX;\n            uf->nodes[rootX].rank++;\n        }\n    }\n}\n\nvoid freeUnionFind(UnionFind *uf) {\n    free(uf->nodes);\n    free(uf);\n}\n\nint main() {\n    int N, K, L;\n    scanf(\"%d %d %d\", &N, &K, &L);\n\n    UnionFind *roadUF = createUnionFind(N);\n    UnionFind *railwayUF = createUnionFind(N);\n\n    for (int i = 0; i < K; i++) {\n        int p, q;\n        scanf(\"%d %d\", &p, &q);\n        unite(roadUF, p-1, q-1);\n    }\n\n    for (int i = 0; i < L; i++) {\n        int r, s;\n        scanf(\"%d %d\", &r, &s);\n        unite(railwayUF, r-1, s-1);\n    }\n\n    int *roadRoot = (int*)malloc(N * sizeof(int));\n    int *railwayRoot = (int*)malloc(N * sizeof(int));\n\n    for (int i = 0; i < N; i++) {\n        roadRoot[i] = find(roadUF, i);\n        railwayRoot[i] = find(railwayUF, i);\n    }\n\n    int *count = (int*)calloc(N, sizeof(int));\n    int *result = (int*)malloc(N * sizeof(int));\n\n    for (int i = 0; i < N; i++) {\n        result[i] = 0;\n    }\n\n    for (int i = 0; i < N; i++) {\n        for (int j = i+1; j < N; j++) {\n            if (roadRoot[i] == roadRoot[j] && railwayRoot[i] == railwayRoot[j]) {\n                result[i]++;\n                result[j]++;\n            }\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        printf(\"%d \", result[i] + 1);\n    }\n    printf(\"\\n\");\n\n    free(roadRoot);\n    free(railwayRoot);\n    free(count);\n    free(result);\n    freeUnionFind(roadUF);\n    freeUnionFind(railwayUF);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:28:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <unordered_map>\nusing namespace std;\n\nstruct UnionFind {\n    vector<int> parent;\n    UnionFind(int n) : parent(n) {\n        for (int i = 0; i < n; ++i) parent[i] = i;\n    }\n    int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x != y) parent[y] = x;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N, K, L;\n    cin >> N >> K >> L;\n\n    UnionFind road(N), rail(N);\n    for (int i = 0; i < K; ++i) {\n        int p, q;\n        cin >> p >> q;\n        road.unite(p-1, q-1);\n    }\n    for (int i = 0; i < L; ++i) {\n        int r, s;\n        cin >> r >> s;\n        rail.unite(r-1, s-1);\n    }\n\n    map<pair<int, int>, int> count;\n    for (int i = 0; i < N; ++i) {\n        int r = road.find(i);\n        int l = rail.find(i);\n        count[{r, l}]++;\n    }\n\n    for (int i = 0; i < N; ++i) {\n        int r = road.find(i);\n        int l = rail.find(i);\n        cout << count[{r, l}] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:29:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static class UnionFind {\n        private int[] parent;\n        private int[] rank;\n\n        public UnionFind(int size) {\n            parent = new int[size + 1];\n            rank = new int[size + 1];\n            for (int i = 1; i <= size; i++) {\n                parent[i] = i;\n                rank[i] = 1;\n            }\n        }\n\n        public int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n\n        public void union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n            if (rootX != rootY) {\n                if (rank[rootX] > rank[rootY]) {\n                    parent[rootY] = rootX;\n                    rank[rootX] += rank[rootY];\n                } else {\n                    parent[rootX] = rootY;\n                    rank[rootY] += rank[rootX];\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] parts = br.readLine().split(\" \");\n        int N = Integer.parseInt(parts[0]);\n        int K = Integer.parseInt(parts[1]);\n        int L = Integer.parseInt(parts[2]);\n\n        UnionFind roadUF = new UnionFind(N);\n        UnionFind railUF = new UnionFind(N);\n\n        for (int i = 0; i < K; i++) {\n            parts = br.readLine().split(\" \");\n            int p = Integer.parseInt(parts[0]);\n            int q = Integer.parseInt(parts[1]);\n            roadUF.union(p, q);\n        }\n\n        for (int i = 0; i < L; i++) {\n            parts = br.readLine().split(\" \");\n            int r = Integer.parseInt(parts[0]);\n            int s = Integer.parseInt(parts[1]);\n            railUF.union(r, s);\n        }\n\n        Map<String, Integer> countMap = new HashMap<>();\n        for (int i = 1; i <= N; i++) {\n            int roadRoot = roadUF.find(i);\n            int railRoot = railUF.find(i);\n            String key = roadRoot + \" \" + railRoot;\n            countMap.put(key, countMap.getOrDefault(key, 0) + 1);\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = 1; i <= N; i++) {\n            int roadRoot = roadUF.find(i);\n            int railRoot = railUF.find(i);\n            String key = roadRoot + \" \" + railRoot;\n            sb.append(countMap.get(key)).append(\" \");\n        }\n        System.out.println(sb.toString().trim());\n    }\n}",
    "timestamp": "2025-08-05 23:29:33"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    public static int[] findConnectedCities(int N, int K, int L, int[] roads, int[] railways) {\n        UnionFind roadUnion = new UnionFind(N + 1);\n        UnionFind railUnion = new UnionFind(N + 1);\n        \n        // Process roads\n        for (int i = 0; i < K * 2; i += 2) {\n            roadUnion.union(roads[i], roads[i+1]);\n        }\n        \n        // Process railways\n        for (int i = 0; i < L * 2; i += 2) {\n            railUnion.union(railways[i], railways[i+1]);\n        }\n        \n        int[] result = new int[N + 1];\n        \n        // Count connections for each city\n        for (int i = 1; i <= N; i++) {\n            int connectedCount = 0;\n            Set<Integer> uniqueRoadGroups = new HashSet<>();\n            Set<Integer> uniqueRailGroups = new HashSet<>();\n            \n            for (int j = 1; j <= N; j++) {\n                if (roadUnion.find(i) == roadUnion.find(j)) {\n                    uniqueRoadGroups.add(roadUnion.find(j));\n                }\n                if (railUnion.find(i) == railUnion.find(j)) {\n                    uniqueRailGroups.add(railUnion.find(j));\n                }\n            }\n            \n            // Find cities connected by both road and rail\n            for (int roadGroup : uniqueRoadGroups) {\n                for (int railGroup : uniqueRailGroups) {\n                    if (roadGroup == railGroup) {\n                        connectedCount++;\n                    }\n                }\n            }\n            \n            result[i] = connectedCount - 1; // Exclude itself\n        }\n        \n        return Arrays.copyOfRange(result, 1, result.length);\n    }\n    \n    static class UnionFind {\n        private int[] parent;\n        private int[] rank;\n        \n        public UnionFind(int size) {\n            parent = new int[size];\n            rank = new int[size];\n            for (int i = 0; i < size; i++) {\n                parent[i] = i;\n            }\n        }\n        \n        public int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n        \n        public void union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n            \n            if (rootX == rootY) return;\n            \n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:29:43"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\nclass UnionFind {\nprivate:\n    vector<int> parent, rank;\n\npublic:\n    UnionFind(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    void unionSet(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            if (rank[rootX] < rank[rootY]) {\n                swap(rootX, rootY);\n            }\n            parent[rootY] = rootX;\n            if (rank[rootX] == rank[rootY]) {\n                rank[rootX]++;\n            }\n        }\n    }\n};\n\nint main() {\n    int N, K, L;\n    cin >> N >> K >> L;\n\n    UnionFind roadUnionFind(N);\n    UnionFind railUnionFind(N);\n\n    for (int i = 0; i < K; i++) {\n        int p, q;\n        cin >> p >> q;\n        roadUnionFind.unionSet(p - 1, q - 1);\n    }\n\n    for (int i = 0; i < L; i++) {\n        int r, s;\n        cin >> r >> s;\n        railUnionFind.unionSet(r - 1, s - 1);\n    }\n\n    vector<pair<int, int>> connections;\n    for (int i = 0; i < N; i++) {\n        connections.push_back({roadUnionFind.find(i), railUnionFind.find(i)});\n    }\n\n    unordered_map<pair<int, int>, int, pair_hash> connectionCount;\n    for (const auto& conn : connections) {\n        connectionCount[conn]++;\n    }\n\n    for (int i = 0; i < N; i++) {\n        cout << connectionCount[connections[i]] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n\nstruct pair_hash {\n    template <class T1, class T2>\n    size_t operator () (const pair<T1, T2>& p) const {\n        auto h1 = hash<T1>{}(p.first);\n        auto h2 = hash<T2>{}(p.second);\n        return h1 ^ h2;\n    }\n};",
    "timestamp": "2025-08-05 23:29:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find(parent, x):\n    if parent[x] == x:\n        return x\n    parent[x] = find(parent, parent[x])\n    return parent[x]\n\ndef union(parent, rank, x, y):\n    rootX = find(parent, x)\n    rootY = find(parent, y)\n    if rootX != rootY:\n        if rank[rootX] > rank[rootY]:\n            parent[rootY] = rootX\n        elif rank[rootX] < rank[rootY]:\n            parent[rootX] = rootY\n        else:\n            parent[rootY] = rootX\n            rank[rootX] += 1\n\ndef solve(N, roads, railways):\n    road_parent = list(range(N))\n    road_rank = [0] * N\n    rail_parent = list(range(N))\n    rail_rank = [0] * N\n\n    for p, q in roads:\n        union(road_parent, road_rank, p - 1, q - 1)\n    \n    for r, s in railways:\n        union(rail_parent, rail_rank, r - 1, s - 1)\n    \n    road_group = [find(road_parent, i) for i in range(N)]\n    rail_group = [find(rail_parent, i) for i in range(N)]\n\n    pair_count = {}\n    for i in range(N):\n        pair = (road_group[i], rail_group[i])\n        if pair not in pair_count:\n            pair_count[pair] = 0\n        pair_count[pair] += 1\n    \n    result = [0] * N\n    for i in range(N):\n        pair = (road_group[i], rail_group[i])\n        result[i] = pair_count[pair] - 1\n    \n    return result\n\n# Example Usage:\n# N = number of cities\n# roads = list of tuples (p_i, q_i), 1-indexed\n# railways = list of tuples (r_i, s_i), 1-indexed\n# print(solve(N, roads, railways))",
    "timestamp": "2025-08-13 15:27:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class CityConnections {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int N = sc.nextInt();\n        int K = sc.nextInt();\n        int L = sc.nextInt();\n        \n        // Road connections\n        List<List<Integer>> roadAdjList = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            roadAdjList.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < K; i++) {\n            int p = sc.nextInt() - 1;\n            int q = sc.nextInt() - 1;\n            roadAdjList.get(p).add(q);\n            roadAdjList.get(q).add(p);\n        }\n        \n        // Railway connections\n        List<List<Integer>> railAdjList = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            railAdjList.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < L; i++) {\n            int r = sc.nextInt() - 1;\n            int s = sc.nextInt() - 1;\n            railAdjList.get(r).add(s);\n            railAdjList.get(s).add(r);\n        }\n\n        int[] roadConnComponent = new int[N];\n        int[] railConnComponent = new int[N];\n        \n        Arrays.fill(roadConnComponent, -1);\n        Arrays.fill(railConnComponent, -1);\n        \n        // Fill road connectivity components\n        for (int i = 0; i < N; i++) {\n            if (roadConnComponent[i] == -1) {\n                bfsComponent(i, roadAdjList, roadConnComponent);\n            }\n        }\n        \n        // Fill railway connectivity components\n        for (int i = 0; i < N; i++) {\n            if (railConnComponent[i] == -1) {\n                bfsComponent(i, railAdjList, railConnComponent);\n            }\n        }\n        \n        Map<String, Integer> pairCountMap = new HashMap<>();\n        \n        for (int i = 0; i < N; i++) {\n            String key = roadConnComponent[i] + \",\" + railConnComponent[i];\n            pairCountMap.put(key, pairCountMap.getOrDefault(key, 0) + 1);\n        }\n        \n        for (int i = 0; i < N; i++) {\n            String key = roadConnComponent[i] + \",\" + railConnComponent[i];\n            System.out.print(pairCountMap.get(key) - 1 + \" \");\n        }\n    }\n    \n    private static void bfsComponent(int start, List<List<Integer>> adjList, int[] component) {\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(start);\n        component[start] = start;\n        \n        while (!queue.isEmpty()) {\n            int city = queue.poll();\n            for (int neighbor : adjList.get(city)) {\n                if (component[neighbor] == -1) {\n                    component[neighbor] = start;\n                    queue.offer(neighbor);\n                }\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-13 15:27:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAXN 100000\n\nint parentRoad[MAXN + 1], parentRail[MAXN + 1];\nint rankRoad[MAXN + 1], rankRail[MAXN + 1];\n\ntypedef struct {\n    int city1;\n    int city2;\n} Connection;\n\nvoid initialize(int n) {\n    for (int i = 1; i <= n; ++i) {\n        parentRoad[i] = parentRail[i] = i;\n        rankRoad[i] = rankRail[i] = 0;\n    }\n}\n\nint findParent(int parent[], int x) {\n    if (parent[x] != x)\n        parent[x] = findParent(parent, parent[x]);\n    return parent[x];\n}\n\nvoid unionSets(int parent[], int rank[], int x, int y) {\n    int rootX = findParent(parent, x);\n    int rootY = findParent(parent, y);\n    if (rootX != rootY) {\n        if (rank[rootX] > rank[rootY]) {\n            parent[rootY] = rootX;\n        } else if (rank[rootX] < rank[rootY]) {\n            parent[rootX] = rootY;\n        } else {\n            parent[rootY] = rootX;\n            ++rank[rootX];\n        }\n    }\n}\n\nint main() {\n    int n, k, l;\n    scanf(\"%d %d %d\", &n, &k, &l);\n    \n    Connection roads[k];\n    Connection railways[l];\n    \n    for (int i = 0; i < k; ++i)\n        scanf(\"%d %d\", &roads[i].city1, &roads[i].city2);\n\n    for (int i = 0; i < l; ++i)\n        scanf(\"%d %d\", &railways[i].city1, &railways[i].city2);\n    \n    initialize(n);\n\n    for (int i = 0; i < k; ++i)\n        unionSets(parentRoad, rankRoad, roads[i].city1, roads[i].city2);\n\n    for (int i = 0; i < l; ++i)\n        unionSets(parentRail, rankRail, railways[i].city1, railways[i].city2);\n\n    int *roadRailCount = (int*)malloc((n + 1) * sizeof(int));\n    for (int i = 1; i <= n; ++i)\n        roadRailCount[i] = 0;\n    \n    for (int i = 1; i <= n; ++i)\n        ++roadRailCount[findParent(parentRoad, i) * MAXN + findParent(parentRail, i)];\n    \n    for (int i = 1; i <= n; ++i) {\n        int roadParent = findParent(parentRoad, i);\n        int railParent = findParent(parentRail, i);\n        printf(\"%d \", roadRailCount[roadParent * MAXN + railParent]);\n    }\n    \n    free(roadRailCount);\n    return 0;\n}",
    "timestamp": "2025-08-13 15:27:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\n\nclass UnionFind {\npublic:\n    vector<int> parent;\n    vector<int> size;\n    \n    UnionFind(int n) : parent(n), size(n, 1) {\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i;\n        }\n    }\n    \n    int find(int x) {\n        if (parent[x] == x) {\n            return x;\n        }\n        return parent[x] = find(parent[x]);\n    }\n\n    void unite(int x, int y) {\n        int px = find(x);\n        int py = find(y);\n        if (px != py) {\n            if (size[px] < size[py]) {\n                swap(px, py);\n            }\n            parent[py] = px;\n            size[px] += size[py];\n        }\n    }\n};\n\nint main() {\n    int N, K, L;\n    cin >> N >> K >> L;\n    \n    UnionFind roadUF(N);\n    UnionFind railUF(N);\n\n    for (int i = 0; i < K; ++i) {\n        int p, q;\n        cin >> p >> q;\n        p--; q--; // zero-based indexing\n        roadUF.unite(p, q);\n    }\n\n    for (int i = 0; i < L; ++i) {\n        int r, s;\n        cin >> r >> s;\n        r--; s--; // zero-based indexing\n        railUF.unite(r, s);\n    }\n\n    map<pair<int, int>, int> combinedConnectivity;\n    \n    for (int i = 0; i < N; ++i) {\n        int roadRoot = roadUF.find(i);\n        int railRoot = railUF.find(i);\n        combinedConnectivity[{roadRoot, railRoot}]++;\n    }\n    \n    for (int i = 0; i < N; ++i) {\n        int roadRoot = roadUF.find(i);\n        int railRoot = railUF.find(i);\n        cout << combinedConnectivity[{roadRoot, railRoot}] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 15:27:37"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_city_connections(N, roads, railways):\n    road_graph = [set() for _ in range(N + 1)]\n    railway_graph = [set() for _ in range(N + 1)]\n    \n    for p, q in roads:\n        road_graph[p].add(q)\n        road_graph[q].add(p)\n    \n    for r, s in railways:\n        railway_graph[r].add(s)\n        railway_graph[s].add(r)\n    \n    road_connections = [set() for _ in range(N + 1)]\n    railway_connections = [set() for _ in range(N + 1)]\n    \n    def dfs(graph, start, connections):\n        visited = [False] * (N + 1)\n        stack = [start]\n        visited[start] = True\n        \n        while stack:\n            current = stack.pop()\n            connections[start].add(current)\n            \n            for neighbor in graph[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    stack.append(neighbor)\n    \n    for city in range(1, N + 1):\n        dfs(road_graph, city, road_connections)\n        dfs(railway_graph, city, railway_connections)\n    \n    result = [len(road_connections[city] & railway_connections[city]) - 1 for city in range(1, N + 1)]\n    return result\n\ndef main():\n    N, K, L = map(int, input().split())\n    roads = [tuple(map(int, input().split())) for _ in range(K)]\n    railways = [tuple(map(int, input().split())) for _ in range(L)]\n    \n    result = solve_city_connections(N, roads, railways)\n    print(*result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 15:27:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    K = int(input[ptr])\n    ptr += 1\n    L = int(input[ptr])\n    ptr += 1\n\n    # Road DSU\n    parent_road = [i for i in range(N+1)]\n    rank_road = [0]*(N+1)\n\n    def find_road(u):\n        while parent_road[u] != u:\n            parent_road[u] = parent_road[parent_road[u]]\n            u = parent_road[u]\n        return u\n\n    def union_road(u, v):\n        u_root = find_road(u)\n        v_root = find_road(v)\n        if u_root == v_root:\n            return\n        if rank_road[u_root] > rank_road[v_root]:\n            parent_road[v_root] = u_root\n        else:\n            parent_road[u_root] = v_root\n            if rank_road[u_root] == rank_road[v_root]:\n                rank_road[v_root] += 1\n\n    for _ in range(K):\n        p = int(input[ptr])\n        q = int(input[ptr+1])\n        ptr += 2\n        union_road(p, q)\n\n    # Railway DSU\n    parent_rail = [i for i in range(N+1)]\n    rank_rail = [0]*(N+1)\n\n    def find_rail(u):\n        while parent_rail[u] != u:\n            parent_rail[u] = parent_rail[parent_rail[u]]\n            u = parent_rail[u]\n        return u\n\n    def union_rail(u, v):\n        u_root = find_rail(u)\n        v_root = find_rail(v)\n        if u_root == v_root:\n            return\n        if rank_rail[u_root] > rank_rail[v_root]:\n            parent_rail[v_root] = u_root\n        else:\n            parent_rail[u_root] = v_root\n            if rank_rail[u_root] == rank_rail[v_root]:\n                rank_rail[v_root] += 1\n\n    for _ in range(L):\n        r = int(input[ptr])\n        s = int(input[ptr+1])\n        ptr += 2\n        union_rail(r, s)\n\n    # Count the number of cities in each (road, rail) component\n    count = defaultdict(int)\n    road_components = [0]*(N+1)\n    rail_components = [0]*(N+1)\n    for i in range(1, N+1):\n        road_root = find_road(i)\n        rail_root = find_rail(i)\n        road_components[i] = road_root\n        rail_components[i] = rail_root\n        count[(road_root, rail_root)] += 1\n\n    # Output the result\n    res = []\n    for i in range(1, N+1):\n        res.append(str(count[(road_components[i], rail_components[i])]))\n    print(' '.join(res))\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 15:28:02"
  }
]