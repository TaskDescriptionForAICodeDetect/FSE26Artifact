[
  {
    "language": "Scala",
    "code": "import scala.collection.mutable\nimport scala.io.StdIn._\nobject Main extends App {\n\n  val Array(n, m, k) = readLine.trim.split(' ').map(_.toInt)\n  val roads = Array.tabulate(m){_ ⇒\n    val Array(a, b, l) = readLine.trim.split(' ').map(_.toInt)\n    Road(a - 1, b - 1, l)\n  }\n  val cities = Array.fill(n){Nil: List[Path]}\n  for (Road(a, b, l) ← roads) {\n    cities(a) ::= Path(b, l)\n    cities(b) ::= Path(a, l)\n  }\n  val minDistance = Array.fill(n){Int.MaxValue}\n  val queue = mutable.PriorityQueue[(Int, Int)]()(Ordering.by[(Int, Int), Int](_._2).reverse)\n  for (_ ← 0 until k){\n    val s = readInt() - 1\n    minDistance(s) = 0\n    queue.enqueue(s → 0)\n  }\n  while (queue.nonEmpty) {\n    val (current, cost) = queue.dequeue()\n    if (minDistance(current) == cost){\n      for (Path(to, length) ← cities(current) if minDistance(to) > cost + length) {\n        minDistance(to) = cost + length\n        queue.enqueue(to → minDistance(to))\n      }\n    }\n  }\n  println(roads.map{\n    case Road(a, b, length) ⇒\n      val min = Math.min(minDistance(a), minDistance(b))\n      val max = Math.max(minDistance(a), minDistance(b))\n      val diff = max - min\n      (length - diff + 1) / 2 + max\n  }.max)\n  case class Road(a: Int, b: Int, length: Int)\n  case class Path(to: Int, length: Int)\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\nusing namespace std;\n\nvector<int>x[4000];\nlong long n,m,a,b,c,k;\nlong long s[4000],d[4000];\nlong long X[4000];\ndouble maxn;int res;\n\nint main(){\n\tmemset(X,63,sizeof(X));\n\tcin>>n>>m>>k;\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>a>>b>>c;\n\t\tx[a].push_back(b*1000000+c);\n\t\tx[b].push_back(a*1000000+c);\n\t}\n\tfor(int i=0;i<k;i++){\n\t\tcin>>a;\n\t\ts[a]=1;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(s[i]==1){\n\t\t\tmemset(d,63,sizeof(d));\n\t\t\td[i]=0;\n\t\t\tfor(int h=1;h<=n;h++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tif(d[j]<1000000000){\n\t\t\t\t\t\tfor(int k=0;k<x[j].size();k++){\n\t\t\t\t\t\t\td[x[j][k]/1000000]=min(d[x[j][k]/1000000],d[j]+x[j][k]%1000000);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tX[j]=min(X[j],d[j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tmaxn=max((long long)maxn,X[i]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<x[i].size();j++){\n\t\t\tif(abs(X[i]-X[x[i][j]/1000000])<x[i][j]%1000000){\n\t\t\t\ta=x[i][j]%1000000-abs(X[i]-X[x[i][j]/1000000]);\n\t\t\t\tmaxn=max(maxn,(double)(max(X[i],X[(int)(x[i][j]/1000000)])+1.0*a/2.0));\n\t\t\t}\n\t\t}\n\t}\n\tres=(1.0*maxn+0.99999999);\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\nusing namespace std;\n\nint main(){\n  const int n = getInt();\n  const int m = getInt();\n  const int k = getInt();\n  vector<vector<pair<int, int> > > g(n);\n  vector<int> dp(n, -1);\n\n  REP(i,m){\n    const int a = getInt() - 1;\n    const int b = getInt() - 1;\n    const int c = getInt();\n\n    g[a].push_back(make_pair(b, c));\n    g[b].push_back(make_pair(a, c));\n  }\n\n  typedef pair<int, int> data;\n  priority_queue<data, vector<data>, greater<data> > pq;\n\n  REP(i,k){\n    int s = getInt() - 1;\n    pq.push(make_pair(0, s));\n  }\n\n  while(pq.size()){\n    data d = pq.top(); pq.pop();\n    int cost = d.first;\n    int pos  = d.second;\n\n    if(dp[pos] != -1) continue;\n    dp[pos] = cost;\n\n    REP(i,g[pos].size()){\n      int pp = g[pos][i].first;\n      int cc = cost + g[pos][i].second;\n      if(dp[pp] == -1) pq.push(make_pair(cc, pp));\n    }\n  }\n\n  const int mx = *max_element(dp.begin(), dp.end());\n\n  double ans = mx;\n  REP(pp,n){\n    REP(j,g[pp].size()){\n      const int qq = g[pp][j].first;\n      const int dd = g[pp][j].second;\n      // dp[pp] + x == dp[qq] + (dd - x)\n      // x = (dp[qq] - dp[pp] + dd) / 2.0\n      const double x = (dp[qq] + dd - dp[pp]) / 2.0;\n      if(0.0 < x && x < dd){\n        ans = max(ans, dp[pp] + x);\n      }\n    }\n  }\n\n  printf(\"%d\\n\", (int)floor(ans + 0.5 + 1e-10));\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"stdio.h\"\n#include \"limits.h\"\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint mati[3000];\nint matis[3000];\nint miti[100000][2];\nint miti2[3000][3000];\nint matiw[3000];\n\nint main()\n{\n\tint n,m,k;\n\n\t{\n\t\tscanf(\"%d %d %d\",&n,&m,&k);\n\t}\n\t\n\t{\n\t\tfor(int i = 0; i < 3000; i++)\n\t\t{\n\t\t\tfor(int ii = 0; ii < 3000; ii++)\n\t\t\t{\n\t\t\t\tmiti2[i][ii] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\t{\n\t\tfor(int i = 0; i < m; i++)\n\t\t{\n\t\t\tint w1,w2,w3;\n\t\t\tscanf(\"%d %d %d\",&w1,&w2,&w3);\n\t\t\tmiti[i][0] = w1 - 1;\n\t\t\tmiti[i][1] = w2 - 1;\n\t\t\tmiti2[w1 - 1][w2 - 1] = w3;\n\t\t\tmiti2[w2 - 1][w1 - 1] = w3;\n\t\t}\n\t}\n\n\t{\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tmati[i] = INT_MAX;\n\t\t\tmatis[i] = 0;\n\t\t}\n\t}\n\n\t{\n\t\tint w;\n\t\tfor(int i = 0; i < k; i++)\n\t\t{\n\t\t\tscanf(\"%d\",&w);\n\t\t\tmati[w - 1] = 0;\n\t\t}\n\t}\n\n\t{\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor(int ii = 0; ii < n; ii++)\n\t\t\t{\n\t\t\t\tif(matis[ii] == 0)\n\t\t\t\t{\n\t\t\t\t\tmatiw[ii] = mati[ii];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmatiw[ii] = INT_MAX;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(matiw,matiw + n);\n\t\t\tfor(int ii = 0; ii < n; ii++)\n\t\t\t{\n\t\t\t\tif(mati[ii] == matiw[0] && matis[ii] == 0)\n\t\t\t\t{\n\t\t\t\t\tfor(int iii = 0; iii < n; iii++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(miti2[ii][iii] != -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(mati[iii] > mati[ii] + miti2[ii][iii])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmati[iii] = mati[ii] + miti2[ii][iii];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmatis[ii] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint l = 0;\n\n\t{\n\t\tint w,w1,w2;\n\t\tfor(int i = 0; i < m; i++)\n\t\t{\n\t\t\tw1 = miti[i][0];\n\t\t\tw2 = miti[i][1];\n\t\t\tif(mati[w1] == mati[w2] + miti2[w1][w2])\n\t\t\t{\n\t\t\t\tw = mati[w1];\n\t\t\t}\n\t\t\telse if(mati[w2] == mati[w1] + miti2[w1][w2])\n\t\t\t{\n\t\t\t\tw = mati[w2];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tw = (mati[w1] + mati[w2] + miti2[w1][w2] - 1) / 2 + 1;\n\t\t\t}\n\t\t\tif(l < w)\n\t\t\t{\n\t\t\t\tl = w;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",l);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip\t;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1<<30;\nclass DIJ{\n\tpublic:\n\tstruct edge{\n\t\tint to,cost;\n\t};\n\tvector<vector<edge> >G;\n\tint n;\n\tvi d;//distance\n\tDIJ(int size){\n\t\tn=size;\n\t\tG=vector<vector<edge> >(n);\n\t\td=vi(n,inf);\n\t}\n\tvoid add_edge(int a,int b,int c){\n\t\tedge e={b,c},ee={a,c};\n\t\tG[a].pb(e);\n\t\tG[b].pb(ee);\n\t}\n\tvoid dij(int s){\n\t\td[s]=0;\n\t\tpriority_queue<pii>q;\n\t\tq.push(pii(0,s));\n\t\twhile(!q.empty()){\n\t\t\tpii p=q.top();\n\t\t\tq.pop();\n\t\t\tint pos=p.second,cost=-p.first;\n\t\t\tif(cost>d[pos])continue;\n\t\t\trep(i,G[pos].size()){\n\t\t\t\tedge e=G[pos][i];\n\t\t\t\tint to=e.to;\n\t\t\t\tint nowcost=cost+e.cost;\n\t\t\t\tif(nowcost<d[to]){\n\t\t\t\t\td[to]=nowcost;\n\t\t\t\t\tq.push(pii(-d[to],to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\nint main(){\n\tint n,m,s;\n\tcin>>n>>m>>s;\n\tDIJ dij(n);\n\twhile(m--){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\ta--;b--;\n\t\tdij.add_edge(a,b,c);\n\t}\n\twhile(s--){\n\t\tint a;\n\t\tcin>>a;\n\t\ta--;\n\t\tdij.dij(a);\n\t}\n\tint out=0;\n\trep(i,n)rep(j,dij.G[i].size()){\n\t\tint a=dij.d[i],b=dij.d[dij.G[i][j].to],c=dij.G[i][j].cost;\n\t\tout=max(out,(int)(0.5+(a+b+c)/2.));\n\t}\n\tcout<<out<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\nusing namespace std;\nint m,k;\ntypedef pair<int,int> P;\nstruct edge{\n\tint to,cost;\n};\nint V;\nvector<edge>G[3005];\nint d[3005][3005];\nint cou=0;\nint mi[3005];\n#define INF 1000000000\nvoid dijkstra(int s){\n\tpriority_queue<P, vector<P>, greater<P> >que;\n\td[cou][s]=0;\n\tque.push(make_pair(0,s));\n\twhile(!que.empty()){\n\t\tP p=que.top(); que.pop();\n\t\tint v=p.second;\n\t\tif(d[cou][v]<p.first) continue;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tedge e=G[v][i];\n\t\t\tif(d[cou][e.to]>d[cou][v]+e.cost){\n\t\t\t\td[cou][e.to]=d[cou][v]+e.cost;\n\t\t\t\tque.push(P(d[cou][e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d %d %d\",&V,&m,&k);\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c;\n\t\tscanf(\"%d %d %d\",&a,&b,&c);\n\t\ta--; b--;\n\t\tedge r,t;\n\t\tr.to=b; t.to=a;\n\t\tr.cost=c; t.cost=c;\n\t\tG[a].push_back(r);\n\t\tG[b].push_back(t);\n\t}\n\tfor(int i=0;i<3005;i++){\n\t\tfor(int j=0;j<3005;j++){\n\t\t\td[i][j]=INF;\n\t\t}\n\t\tmi[i]=INF;\n\t}\n\tfor(int i=0;i<k;i++){\n\t\tint sta;\n\t\tscanf(\"%d\",&sta);\n\t\tdijkstra(sta-1);\n\t\tcou++;\n\t}\n\tint ans=0,ep=0;\n\tfor(int i=0;i<cou;i++){\n\t\tfor(int j=0;j<V;j++){\n\t\t\t\tmi[j]=min(mi[j],d[i][j]);\n\t\t}\n\t}\n\tint res=0;\n\tfor(int j=0;j<V;j++){\n\t\tfor(int k=0;k<G[j].size();k++){\n\t\t\tint c=G[j][k].to;\n\t\t\tint w=G[j][k].cost;\n\t\t\tres=max((mi[j]+mi[c]+w+1)/2,res);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <map>\n#include <functional>\n\nusing namespace std;\ntypedef pair<int,int> mp;\nint mins(int p,int q){\n  if(p==-1)return q;\n  else if(q==-1 || p<q)return p;\n  else return q;\n}\nint max(int p,int q){\n  if(p<q)return q;\n  else return p;\n}\n\nint md[3000][3000];\nint mm[3000];\nint dt[3000];\nbool ch[3000];\nint m,n,k;\n\nint main(void){\n  memset(md,-1,sizeof(md));\n  memset(dt,-1,sizeof(dt));\n  scanf(\"%d%d%d\",&n,&m,&k);\n  int i,j;\n  int a,b,c;\n  for(i=0;i<m;i++){\n    scanf(\"%d%d%d\",&a,&b,&c);\n    md[a-1][b-1]=c;\n    md[b-1][a-1]=c;\n  }\n  for(i=0;i<k;i++){\n    scanf(\"%d\",&a);\n    mm[i]=a-1;\n  }\n\n  int st,no,kyo,mk;\n  mp pa;\n  int ans=0;\n  priority_queue <mp> que;\n  for(i=0;i<k;i++){\n    st=mm[i];\n    memset(ch,false,sizeof(ch));\n    dt[st]=0;\n    //ch[st]=true;\n    que.push(make_pair(0,st));\n    while(!que.empty()){\n      pa=que.top();\n      que.pop();\n      kyo=pa.first;\n      no=pa.second;\n      if(ch[no]==false){\n\tfor(j=0;j<n;j++){\n\t  if(md[no][j]!=-1 ){\n\t    mk=md[no][j];\n\t    dt[j]=mins(dt[j],kyo+mk);\n\t    que.push(make_pair(dt[j],j));\n\t  }\n\t}\n\tch[no]=true;\n      }\n    }\n  }\n  for(i=0;i<n;i++){\n    ans=max(ans,dt[i]);\n    //printf(\"%d\\n\",dt[i]);\n  }\n  //printf(\"\\n\");\n  for(i=0;i<n;i++){\n    for(j=i+1;j<n;j++){\n      if(md[i][j]!=-1){\n\tans=max(ans,(int)((dt[i]+dt[j]+md[i][j]+1)/2));\n\t//printf(\"%d %d %d\\n\",i+1,j+1,(int)((dt[i]+dt[j]+md[i][j]+1)/2));\n      }\n    }\n  }\n\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint N, M, K, a, b, c, g[3009][3009], dist[3009]; bool vis[3009];\nint main() {\n\tscanf(\"%d%d%d\", &N, &M, &K);\n\tmemset(g, 0x3f, sizeof(g)); \n\tfor(int i = 0; i < M; i++) {\n\t\tscanf(\"%d%d%d\", &a, &b, &c); a--, b--;\n\t\tg[a][b] = g[b][a] = c;\n\t}\n\tmemset(dist, 0x3f, sizeof(dist));\n\tfor(int i = 0; i < K; i++) {\n\t\tscanf(\"%d\", &a); a--;\n\t\tdist[a] = 0;\n\t}\n\tfor(int i = 0; i < N; i++) {\n\t\tint ptr = -1;\n\t\tfor(int j = 0; j < N; j++) {\n\t\t\tif(!vis[j] && (ptr == -1 || dist[ptr] > dist[j])) {\n\t\t\t\tptr = j;\n\t\t\t}\n\t\t}\n\t\tvis[ptr] = true;\n\t\tfor(int j = 0; j < N; j++) {\n\t\t\tif(dist[j] > dist[ptr] + g[ptr][j]) {\n\t\t\t\tdist[j] = dist[ptr] + g[ptr][j];\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor(int i = 0; i < N; i++) {\n\t\tfor(int j = i; j < N; j++) {\n\t\t\tif(g[i][j] == 0x3f3f3f3f) continue;\n\t\t\tret = max(ret, (dist[j] + dist[i] + g[i][j] + 1) >> 1);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<functional>\nusing namespace std;\n\n#define BLACK 2LL\n#define GRAY 1LL\n#define WHITE 0LL\n#define TEISU 1000000LL\n#define INF 1145141919LL\n\nvector<long long>x[4000];\nlong long n,m,a,b,c,k,G;\nlong long s[4000],d[4000],color[4000];\nlong long X[4000];\ndouble maxn;long long res;\n\npriority_queue<long long,vector<long long>,greater<long long>>Q;\n\nvoid dijkstra(){\n\twhile(!Q.empty()){\n\t\tint A=Q.top()/TEISU;\n\t\tint B=Q.top()%TEISU;\n\t\tQ.pop();\n\t\tcolor[B]=BLACK;\n\n\t\tif(d[B]<A*(-1))continue;\n\n\t\tfor(int v=0;v<x[B].size();v++){\n\t\t\tint w=x[B][v]/TEISU;\n\n\t\t\tif(color[w]==BLACK)continue;\n\n\t\t\tif(d[w]>d[B]+x[B][v]%TEISU){\n\n\t\t\t\td[w]=d[B]+x[B][v]%TEISU;\n\t\t\t\tQ.push(d[w]*TEISU+w);\n\t\t\t\tcolor[w]=GRAY;\n\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tmemset(X,63,sizeof(X));\n\tcin>>n>>m>>k;\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>a>>b>>c;\n\t\tx[a].push_back(b*TEISU+c);\n\t\tx[b].push_back(a*TEISU+c);\n\t}\n\tfor(int i=0;i<k;i++){\n\t\tcin>>a;\n\t\ts[a]=1;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(s[i]==1){\n\t\t\tQ.push(i);\n\t\t\tfor(int v=1;v<=n;v++){\n\t\t\t\tcolor[v]=WHITE;\n\t\t\t\td[v]=INF;\n\t\t\t}\n\t\t\td[i]=0;\n\t\t\tdijkstra();\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tX[j]=min(X[j],d[j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tmaxn=max((long long)maxn,X[i]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<x[i].size();j++){\n\t\t\tif(abs(X[i]-X[x[i][j]/TEISU])<x[i][j]%TEISU){\n\t\t\t\ta=x[i][j]%TEISU-abs(X[i]-X[x[i][j]/TEISU]);\n\t\t\t\tmaxn=max(maxn,(double)(max(X[i],X[(int)(x[i][j]/TEISU)])+1.0*a/2.0));\n\t\t\t}\n\t\t}\n\t}\n\tres=(1.0*maxn+0.99999999);\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<cstdio>\n#include<cmath>\n#include<stack>\n#define F first\n#define S second\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef vector<P> VP;\ntypedef vector<int> VI;\ntypedef vector<VP> VVP;\ntypedef vector<VI> VVI;\nclass Pox\n{\npublic:\n  int cost,now;\n  Pox():cost(0),now(0){}\n  Pox(int now,int cost):now(now),cost(cost){}\n};\n\nclass ope{\npublic:\n  bool operator() (Pox a,Pox b)\n  {\n    return a.cost > b.cost;\n  }\n};\n\nconst int INF = (1<<28);\nint N,M,K;\nVVP G;\nVI mincost;\n//map<P,int> D;\n\nint main()\n{\n  scanf(\"%d %d %d\",&N,&M,&K);\n  G.resize(N),mincost.resize(N);\n  for(int i=0;i<N;i++)\n      mincost[i] = INF;\n\n  for(int i=0;i<M;i++)\n    {\n      int a,b,c;\n      scanf(\"%d %d %d\",&a,&b,&c);\n      a--,b--;\n      G[a].push_back(P(b,c));\n      G[b].push_back(P(a,c));\n      //D[P(a,b)] = D[P(b,a)] = c;\n    }\n\n  priority_queue<Pox,vector<Pox>,ope> Q;\n  for(int i=0;i<K;i++)\n    {\n      int a;\n      scanf(\"%d\",&a);\n      a--;\n      Q.push(Pox(a,0));\n      mincost[a] = 0;\n    }\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.top(); Q.pop();\n      int now = pox.now;\n      int total = pox.cost;\n\n      for(int i=0;i<G[now].size();i++)\n\t{     \n\t  P p = G[now][i];\n\t  int to = p.F;\n\t  int cost = p.S;\n\t  if(mincost[to] <= total + cost)\n\t    continue;\n\n\t  mincost[to] = total + cost;\n\t  Q.push(Pox(to,total+cost));\n\t}\n    }\n\n\n  double mex = 0;\n  for(int i=0;i<N;i++)\n    for(int j=i+1;j<N;j++)\n      for(int k=0;k<G[i].size();k++)\n\tif(j != i && mincost[j] != INF && mincost[i] != INF && G[i][k].F == j/*D[P(i,j)]*/)\n\t  mex = max(mex,(double)(mincost[i]+mincost[j]+G[i][k].S/*D[P(i,j)]*/)/2.0 );\n\t    \n\n  cout << round(mex) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <map>\n#include <algorithm>\n#define fi first\n#define sec second\n#define INF 100000000\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n,m,k;\nint cost[3000][3000];\nint cnt[3000];\nvector<P> e[3000];\nbool shop[3000];\nint ans;\n\nvoid dijkstra(int s){\n\trep(i,n) cost[s][i] = INF;\n\tif(!shop[s]) return; \n\tcost[s][s] = 0;\n\tqueue<P> que;\n\tque.push(P(s,0));\n\twhile(true){\n\t\tif(que.size()==0) break;\n\t\tP p = que.front(); que.pop();\n\t\tif(p.sec > cost[s][p.fi]) continue;\n\t\trep(i,e[p.fi].size()){\n\t\t\tif(shop[e[p.fi][i].fi])continue;\n\t\t\tif(cost[s][e[p.fi][i].fi] > cost[s][p.fi]+e[p.fi][i].sec){\n\t\t\t\tcost[s][e[p.fi][i].fi] = cost[s][p.fi]+e[p.fi][i].sec;\n\t\t\t\tque.push(P(e[p.fi][i].fi,cost[s][e[p.fi][i].fi]));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint Abs(int x){\n\treturn x>0?x:-x;\n}\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\trep(i,m){\n\t\tint a,b,l; scanf(\"%d%d%d\",&a,&b,&l);\n\t\ta--; b--;\n\t\te[a].push_back(P(b,l));\n\t\te[b].push_back(P(a,l));\n\t}\n\trep(i,k){\n\t\tint s; scanf(\"%d\",&s);\n\t\ts--;\n\t\tshop[s] = true;\n\t}\n\trep(i,n) dijkstra(i);\n\trep(i,n) cnt[i] = INF;\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tcnt[i] = min(cnt[i],cost[j][i]);\n\t\t}\n\t}\n\trep(i,n) ans = max(ans,cnt[i]);\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < e[i].size(); j++){\n\t\t\tint f = e[i][j].fi, s = e[i][j].sec;\n\t\t\tans = max(ans,max(cnt[i],cnt[f])+(s-Abs(cnt[i]-cnt[f])+1)/2);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <map>\n#include <functional>\n\nusing namespace std;\ntypedef pair<int,int> mp;\nint mins(int p,int q){\n  if(p==-1)return q;\n  else if(q==-1 || p<q)return p;\n  else return q;\n}\nint max(int p,int q){\n  if(p<q)return q;\n  else return p;\n}\n\nint md[3000][3000];\nint mm[3000];\nint dt[3000];\nbool ch[3000];\nint m,n,k;\n\nint main(void){\n  memset(md,-1,sizeof(md));\n  memset(dt,-1,sizeof(dt));\n  scanf(\"%d%d%d\",&n,&m,&k);\n  int i,j;\n  int a,b,c;\n  for(i=0;i<m;i++){\n    scanf(\"%d%d%d\",&a,&b,&c);\n    md[a-1][b-1]=c;\n    md[b-1][a-1]=c;\n  }\n  for(i=0;i<k;i++){\n    scanf(\"%d\",&a);\n    mm[i]=a-1;\n  }\n\n  int st,no,kyo,mk;\n  mp pa;\n  int ans=0;\n  priority_queue <mp,vector<mp>,greater<mp> > que;\n  for(i=0;i<k;i++){\n    st=mm[i];\n    memset(ch,false,sizeof(ch));\n    dt[st]=0;\n    //ch[st]=true;\n    que.push(make_pair(0,st));\n    while(!que.empty()){\n      pa=que.top();\n      que.pop();\n      kyo=pa.first;\n      no=pa.second;\n      if(ch[no]==false){\n\tfor(j=0;j<n;j++){\n\t  if(md[no][j]!=-1 && ch[j]==false){\n\t    mk=md[no][j];\n\t    dt[j]=mins(dt[j],kyo+mk);\n\t    que.push(make_pair(dt[j],j));\n\t  }\n\t}\n\tch[no]=true;\n      }\n    }\n  }\n  for(i=0;i<n;i++){\n    ans=max(ans,dt[i]);\n    //printf(\"%d\\n\",dt[i]);\n  }\n  //printf(\"\\n\");\n  for(i=0;i<n;i++){\n    for(j=i+1;j<n;j++){\n      if(md[i][j]!=-1){\n\tans=max(ans,(int)((dt[i]+dt[j]+md[i][j]+1)/2));\n\t//printf(\"%d %d %d\\n\",i+1,j+1,(int)((dt[i]+dt[j]+md[i][j]+1)/2));\n      }\n    }\n  }\n\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAX_N (3000)\n#define MAX_M (100000)\n#define pb push_back\nconst int INF = 1001001001;\nstruct P\n{\n\tint len, p;\n\t\n\tP(int a, int b){\n\t\tlen = a;\n\t\tp = b;\n\t}\t\n\t\n\tbool operator < (const P& t) const {\n\t\treturn len > t.len;\n\t}\n};\n\nint n;\nvector<P> v[MAX_N];\nint d[MAX_N];\nint d2[MAX_N][MAX_N];\n\nvoid search(int s)\n{\n\t//d[s] = 0;\n\t\n\tpriority_queue<P> que;\n\tque.push(P(0, s));\n\twhile (!que.empty()){\n\t\tP p = que.top(); que.pop();\n\t\tif (d[p.p] <= p.len) continue;\n\t\td[p.p] = p.len;\n\t\tfor (int i = 0; i < v[p.p].size(); i++){\n\t\t\tint to = v[p.p][i].p;\n\t\t\tint len = p.len + v[p.p][i].len;\n\t\t\tif (d[to] > len){\n\t\t\t\tque.push(P(len, to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint m, k;\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\t\n\tfor (int i = 0; i < m; i++){\n\t\tint a, b, l;\n\t\tscanf(\"%d %d %d\", &a, &b, &l);\n\t\ta--; b--; l *= 2;\n\t\t\n\t\tv[a].pb(P(l, b));\n\t\tv[b].pb(P(l, a));\n\t}\n\t\n\tvector<int> s;\n\tfor (int i = 0; i < k; i++){\n\t\tint a;\n\t\tscanf(\"%d\", &a);\n\t\ta--;\n\t\ts.pb(a);\n\t}\n\t\n\tfill(d, d + n, INF);\n\tint maxi = 0;\n\tfor (int i = 0; i < s.size(); i++){\n\t\tsearch(s[i]);\n\t}\n\t//memset(d2, 0, sizeof(d2));\n\tfor (int j = 0; j < n; j++){\n\t\tfor (int k = 0; k < v[j].size(); k++){\n\t\t\tif (!d2[j][v[j][k].p]){\n\t\t\t\td2[j][v[j][k].p] = (d[j] + d[v[j][k].p] + v[j][k].len) / 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\td2[j][v[j][k].p] = min(d2[j][v[j][k].p], (d[j] + d[v[j][k].p] + v[j][k].len) / 2);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int j = 0; j < n; j++){\n\t\tmaxi = max(maxi, d[j]);\n\t\t//printf(\"%d \", d[j]);\n\t}\n\t//puts(\"\");\n\tfor (int j = 0; j < n; j++){\n\t\tfor (int k = 0; k < n; k++){\n\t\t\tmaxi = max(maxi, d2[j][k]);\n\t\t\t//printf(\"%d \", d2[j][k]);\n\t\t}\n\t\t//puts(\"\");\n\t}\n\t\n\tprintf(\"%d\\n\", (maxi + 1) / 2);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\nusing namespace std;\n\nvector<int>x[4000];\nint n,m,a,b,c,k,G;\nint s[4000],d[4000];\nint X[4000];\ndouble maxn;int res;\n\nint main(){\n\tmemset(X,63,sizeof(X));\n\tcin>>n>>m>>k;\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>a>>b>>c;\n\t\tx[a].push_back(b*10000+c);\n\t\tx[b].push_back(a*10000+c);\n\t}\n\tfor(int i=0;i<k;i++){\n\t\tcin>>a;\n\t\ts[a]=1;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(s[i]==1){\n\t\t\tmemset(d,63,sizeof(d));\n\t\t\td[i]=0;\n\t\t\tif(n<500){G=n;}\n\t\t\telse{\n\t\t\t\tG=min(20,(n+k)/k+10);\n\t\t\t}\n\t\t\tfor(int h=1;h<=G;h++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tif(d[j]<100000000){\n\t\t\t\t\t\tfor(int k=0;k<x[j].size();k++){\n\t\t\t\t\t\t\td[x[j][k]/10000]=min(d[x[j][k]/10000],d[j]+x[j][k]%10000);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tX[j]=min(X[j],d[j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tmaxn=max((int)maxn,X[i]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<x[i].size();j++){\n\t\t\tif(abs(X[i]-X[x[i][j]/10000])<x[i][j]%10000){\n\t\t\t\ta=x[i][j]%10000-abs(X[i]-X[x[i][j]/10000]);\n\t\t\t\tmaxn=max(maxn,(double)(max(X[i],X[(int)(x[i][j]/10000)])+1.0*a/2.0));\n\t\t\t}\n\t\t}\n\t}\n\tres=(1.0*maxn+0.99999999);\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\nusing namespace std;\n\nstruct NODE{\n\tint from,to,cost;\n\tNODE(int from,int to,int cost) : from(from),to(to),cost(cost){}\n};\nbool operator <(const NODE &a,const NODE &b){\n\treturn a.cost > b.cost;\n}\n\nvector<NODE> e[3000];\nvector<NODE> edge;\nint cost[3000];\nint main(){\n\tint N,M,K;\n\tscanf(\"%d%d%d\",&N,&M,&K);\n\tmemset(cost,-1,sizeof(cost));\n\tfor(int i = 0 ; i < M ; i++){\n\t\tint a,b,c;\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\t--a,--b;\n\t\te[a].push_back(NODE(a,b,c));\n\t\te[b].push_back(NODE(b,a,c));\n\t\tedge.push_back(NODE(a,b,c));\n\t}\n\tpriority_queue<NODE> Q;\n\tfor(int i = 0 ; i < K ; i++){\n\t\tint a; scanf(\"%d\",&a);\n\t\tQ.push(NODE(-1,a-1,0));\n\t}\n\t\n\twhile(Q.size()){\n\t\tNODE q = Q.top(); Q.pop();\n\t\tif(cost[q.to] != -1) continue;\n\t\telse cost[q.to] = q.cost;\n\t\tfor(int i = 0 ; i < e[q.to].size() ; ++i) Q.push(NODE(-1,e[q.to][i].to,q.cost+e[q.to][i].cost));\n\t}\n\tint answer = 0;\n\tfor(int i = 0 ; i < M ; i++){\n\t\tanswer = max( answer , (cost[edge[i].from] + cost[edge[i].to] + edge[i].cost + 1 ) / 2 );\n\t}\n\tprintf(\"%d\\n\",answer);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <map>\n#include <functional>\n\nusing namespace std;\ntypedef pair<int,int> mp;\nint mins(int p,int q){\n  if(p==-1)return q;\n  else if(q==-1 || p<q)return p;\n  else return q;\n}\nint max(int p,int q){\n  if(p<q)return q;\n  else return p;\n}\n\nint md[3000][3000];\nint mm[3000];\nint dt[3000];\nbool ch[3000];\nint m,n,k;\n\nint main(void){\n  memset(md,-1,sizeof(md));\n  memset(dt,-1,sizeof(dt));\n  scanf(\"%d%d%d\",&n,&m,&k);\n  int i,j;\n  int a,b,c;\n  for(i=0;i<m;i++){\n    scanf(\"%d%d%d\",&a,&b,&c);\n    md[a-1][b-1]=c;\n    md[b-1][a-1]=c;\n  }\n  for(i=0;i<k;i++){\n    scanf(\"%d\",&a);\n    mm[i]=a-1;\n  }\n\n  int st,no,kyo,mk;\n  mp pa;\n  int ans=0;\n  priority_queue <mp> que;\n  for(i=0;i<k;i++){\n    st=mm[i];\n    memset(ch,false,sizeof(ch));\n    dt[st]=0;\n    //ch[st]=true;\n    que.push(make_pair(0,st));\n    while(!que.empty()){\n      pa=que.top();\n      que.pop();\n      kyo=pa.first;\n      no=pa.second;\n      if(ch[no]==false){\n\tfor(j=0;j<n;j++){\n\t  if(md[no][j]!=-1 ){\n\t    mk=md[no][j];\n\t    dt[j]=mins(dt[j],kyo+mk);\n\t    que.push(make_pair(dt[j],j));\n\t  }\n\t}\n\tch[no]=true;\n      }\n    }\n  }\n  for(i=0;i<n;i++){\n    ans=max(ans,dt[i]);\n    printf(\"%d\\n\",dt[i]);\n  }\n  printf(\"\\n\");\n  for(i=0;i<n;i++){\n    for(j=i+1;j<n;j++){\n      if(md[i][j]!=-1){\n\tans=max(ans,(int)((dt[i]+dt[j]+md[i][j]+1)/2));\n\tprintf(\"%d %d %d\\n\",i+1,j+1,(int)((dt[i]+dt[j]+md[i][j]+1)/2));\n      }\n    }\n  }\n\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint N, M, K, A, B, L;\n\nvector<vector<pair<int, int> > > G;\n\nvector<int> P, D;\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tscanf(\"%d\", &M);\n\tscanf(\"%d\", &K);\n\n\tG = vector<vector<pair<int, int> > >(N);\n\n\tfor (int i = 0; i < M; i++)\n\t{\n\t\tscanf(\"%d\", &A);\n\t\tscanf(\"%d\", &B);\n\t\tscanf(\"%d\", &L);\n\n\t\tG[A - 1].push_back(make_pair(B - 1, L));\n\t\tG[B - 1].push_back(make_pair(A - 1, L));\n\t}\n\n\tP = vector<int>(K);\n\n\tfor (int i = 0; i < K; i++)\n\t{\n\t\tscanf(\"%d\", &P[i]); P[i]--; // 0 - indexed\n\t}\n\n\tD = vector<int>(N, 999999999);\n\n\tfor (int i = 0; i < K; i++)\n\t{\n\t\tpriority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > que;\n\n\t\tque.push(make_pair(0, P[i])); D[P[i]] = 0;\n\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint dist = que.top().first;\n\t\t\tint node = que.top().second; que.pop();\n\n\t\t\tfor (int j = 0; j < G[node].size(); j++)\n\t\t\t{\n\t\t\t\tint node2 = G[node][j].first;\n\t\t\t\tint leng2 = G[node][j].second;\n\n\t\t\t\tif (D[node2] > D[node] + leng2)\n\t\t\t\t{\n\t\t\t\t\tD[node2] = D[node] + leng2;\n\n\t\t\t\t\tque.push(make_pair(D[node2], node2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = 0;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < G[i].size(); j++)\n\t\t{\n\t\t\tret = max(ret, D[i] + D[G[i][j].first] + G[i][j].second);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", (ret + 1) / 2);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <map>\n#include <sstream>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <iterator>\n#include <stack>\n#include <list>\nusing namespace std;\nconst int INF=1000000000;\ntypedef long long int lli;\ntypedef pair<int,int> P;\n\nconst int MAX_V=5001;\nint cost[MAX_V][MAX_V];\nint d[MAX_V];\nbool used[MAX_V];\nint shortest[MAX_V];\n\nint abs(int x){\n\tif(x<0) return -x;\n\telse return x;\n}\n\nint main(){\n\tint V,E,K;\n\tcin >> V >> E >> K;\n\tfor(int i=1; i<=V; ++i){\n\t\tfor(int j=1; j<=V; ++j){\n\t\t\tif(i==j) {\n\t\t\t\tcost[i][j]=0;\n\t\t\t} else {\n\t\t\t\tcost[i][j]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<E; ++i){\n\t\tint a,b,l;\n\t\tcin >> a >> b >> l;\n\t\tcost[a][b]=cost[b][a]=l;\n\t}\n\tfill(d,d+V+1,INF);\n\tfor(int i=0; i<K; ++i){\n\t\tint tmp;\n\t\tcin >> tmp;\n\t\td[tmp]=0;\n\t}\n\tfill(shortest,shortest+V+1,INF);\n\tfill(used,used+V+1,false);\n\twhile(true){\n\t\tint v=-1;\n\t\tfor(int u=1; u<=V; ++u){\n\t\t\tif(!used[u]&&(v==-1||d[u]<d[v])) v=u;\n\t\t}\n\t\t\n\t\tif(v==-1) break;\n\t\tused[v]=true;\n\t\t\n\t\tfor(int u=1; u<=V; ++u){\n\t\t\td[u]=min(d[u],d[v]+cost[v][u]);\n\t\t\tif(shortest[u]>d[u]) shortest[u]=d[u];\n\t\t}\n\t}\n\t\n\tint ans=-1;\n\tfor(int i=1; i<=V; ++i){\n\t\tfor(int j=1; j<=V; ++j){\n\t\t\tif(cost[i][j]!=INF){\n\t\t\t\tint tmp=abs((shortest[j]+shortest[i]+cost[i][j]+1)/2);\n\t\t\t\tans=max(ans,tmp);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<vector>\n#include<queue>\n#include<functional>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint N,M,K;\t\t//町数、道の数、店舗数\nstruct NODE{\n\tvector<int> cost,list;\n\tint minest;\t//頂点から店への最短距離\n}MISE[3000];\n\nvoid Ini(int *a,int index,int num){\n\tfor(int i = 0;i < index;i++){\n\t\ta[i] = num;\n\t}\n}\nvoid Dijkstra(int left){\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tint done[3000],DEFINEED = 0;\n\tint nowcost[3000];\n\tP edge;\n\tIni(done,N,-1);\n\tIni(nowcost,N,500000000);\n\tque.push(P(0,left));\n\twhile(DEFINEED < N && !que.empty()){\n\t\tedge = que.top();\n\t\tque.pop();\n\t\tif(done[edge.second] >= 0)\n\t\t\tcontinue;\n\t\tDEFINEED++;\n\t\tdone[edge.second] = edge.first;\n\t\t//確定した頂点から枝を出す\n\t\tint lsize;\n\t\tlsize = MISE[edge.second].list.size();\n\t\tfor(int i = 0;i < lsize;i++){\n\t\t\tif(done[MISE[edge.second].list[i]] == -1 && nowcost[MISE[edge.second].list[i]] > edge.first+MISE[edge.second].cost[i]){\n\t\t\t\tnowcost[MISE[edge.second].list[i]] = edge.first+MISE[edge.second].cost[i];\n\t\t\t\tque.push(P(nowcost[MISE[edge.second].list[i]],MISE[edge.second].list[i]));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int  i = 0;i < N;i++){\n\t\tif(MISE[i].minest > done[i] && done[i] != -1)\n\t\t\tMISE[i].minest = done[i];\n\t}\n}\nint main(){\n\tint i,a,b,c;\n\tint Mplace;\n\tcin >> N >> M >> K;\n\tfor(i = 0;i < N;i++){\n\t\tMISE[i].minest = 500000000;\n\t}\n\tfor(i = 0;i < M;i++){\n\t\tcin >> a >> b >> c;\n\t\ta--;b--;\n\t\t//隣接リスト作成。道の生成による影響は2ノード間にのみ作用する。\n\t\tMISE[a].list.push_back(b);\n\t\tMISE[a].cost.push_back(c);\n\t\tMISE[b].list.push_back(a);\n\t\tMISE[b].cost.push_back(c);\n\t}\n\tfor(i = 0;i < K;i++){\n\t\tcin >> Mplace;\n\t\tMplace--;\n\t\tDijkstra(Mplace);\n\t}\n\tdouble D_length;\n\tint I_length,I_Mlength = 0;\n\tfor(i = 0;i < N;i++){\n\t\t//枝の間が一番距離が長くなりそう\n\t\tint lsize;\n\t\tlsize = MISE[i].list.size();\n\t\tfor(int j = 0;j < lsize;j++){\n\t\t\tD_length = (double)MISE[i].cost[j]/2.0;\n\t\t\tD_length += (MISE[i].minest+MISE[MISE[i].list[j]].minest)/2.0;\n\t\t\tif(D_length - (int)D_length == 0)\n\t\t\t\tI_length = (int)D_length;\n\t\t\telse\n\t\t\t\tI_length = (int)D_length+1;\n\t\t\tif(I_Mlength < I_length)\n\t\t\t\tI_Mlength = I_length;\n\t\t}\n\t}\n\tcout << I_Mlength << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_to,int arg_dist){\n\t\tto = arg_to;\n\t\tdist = arg_dist;\n\t}\n\tint to,dist;\n};\n\nstruct Data{\n\tData(){\n\t\ttown = dist = 0;\n\t}\n\tData(int arg_town,int arg_dist){\n\t\ttown = arg_town;\n\t\tdist = arg_dist;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\t\treturn dist > arg.dist;\n\t};\n\tint town,dist;\n};\n\nint main(){\n\n\tint N,M,K;\n\tscanf(\"%d %d %d\",&N,&M,&K);\n\n\tint** road = new int*[N+1];\n\tfor(int i = 1; i <= N; i++){\n\t\troad[i] = new int[N+1];\n\t\tfor(int k = 1; k <= N; k++)road[i][k] = BIG_NUM;\n\t}\n\n\tint min_dist_to_market[N+1];\n\tfor(int i = 1; i <= N; i++)min_dist_to_market[i] = BIG_NUM;\n\n\tvector<Info> V[N+1];\n\n\tint from,to,dist;\n\tfor(int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d\",&from,&to,&dist);\n\t\tV[from].push_back(Info(to,dist));\n\t\tV[to].push_back(Info(from,dist));\n\t\troad[from][to] = dist;\n\t\troad[to][from] = dist;\n\t}\n\n\tbool is_mall[N+1];\n\tfor(int i = 1; i <= N; i++)is_mall[i] = false;\n\n\tint tmp;\n\n\tfor(int i = 0; i < K; i++){\n\t\tscanf(\"%d\",&tmp);\n\t\tis_mall[tmp] = true;\n\t\tmin_dist_to_market[tmp] = 0;\n\t}\n\n\tint ans = -1,min_index;\n\n\tpriority_queue<Data> Q;\n\n\tint tmp_min_dist[N+1];\n\n\tif(N-K <= K){\n\n\t\tfor(int start = 1; start <= N; start++){\n\t\t\tif(!is_mall[start]){\n\n\t\t\t\tfor(int i = 1; i <= N; i++)tmp_min_dist[i] = BIG_NUM;\n\n\t\t\t\ttmp_min_dist[start] = 0;\n\n\t\t\t\tfor(int i = 0; i < V[start].size();i++){\n\t\t\t\t\ttmp_min_dist[V[start][i].to] = V[start][i].dist;\n\t\t\t\t\tQ.push(Data(V[start][i].to,V[start][i].dist));\n\t\t\t\t}\n\n\n\t\t\t\twhile(!Q.empty()){\n\t\t\t\t\tif(Q.top().dist > tmp_min_dist[Q.top().town]){\n\t\t\t\t\t\tQ.pop();\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmin_index = Q.top().town;\n\t\t\t\t\t\tQ.pop();\n\n\t\t\t\t\t\tfor(int k = 0; k < V[min_index].size(); k++){\n\t\t\t\t\t\t\tif(tmp_min_dist[V[min_index][k].to] > tmp_min_dist[min_index]+V[min_index][k].dist){\n\t\t\t\t\t\t\t\ttmp_min_dist[V[min_index][k].to] = tmp_min_dist[min_index]+V[min_index][k].dist;\n\t\t\t\t\t\t\t\tQ.push(Data(V[min_index][k].to,tmp_min_dist[V[min_index][k].to]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint tmp_min = BIG_NUM;\n\n\t\t\t\tfor(int i = 1; i <= N; i++){\n\t\t\t\t\tif(is_mall[i] == true){\n\t\t\t\t\t\ttmp_min = min(tmp_min,tmp_min_dist[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmin_dist_to_market[start] = tmp_min;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tans = max(ans,min_dist_to_market[i]);\n\t\t}\n\n\t}else{\n\n\t\tfor(int start = 1; start <= N; start++){\n\t\t\tif(is_mall[start]){\n\n\t\t\t\tfor(int i = 1; i <= N; i++)tmp_min_dist[i] = BIG_NUM;\n\n\t\t\t\ttmp_min_dist[start] = 0;\n\n\t\t\t\tfor(int i = 0; i < V[start].size();i++){\n\t\t\t\t\ttmp_min_dist[V[start][i].to] = V[start][i].dist;\n\t\t\t\t\tQ.push(Data(V[start][i].to,V[start][i].dist));\n\t\t\t\t}\n\n\n\t\t\t\twhile(!Q.empty()){\n\t\t\t\t\tif(Q.top().dist > tmp_min_dist[Q.top().town]){\n\t\t\t\t\t\tQ.pop();\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmin_index = Q.top().town;\n\t\t\t\t\t\tQ.pop();\n\n\t\t\t\t\t\tfor(int k = 0; k < V[min_index].size(); k++){\n\t\t\t\t\t\t\tif(tmp_min_dist[V[min_index][k].to] > tmp_min_dist[min_index]+V[min_index][k].dist){\n\t\t\t\t\t\t\t\ttmp_min_dist[V[min_index][k].to] = tmp_min_dist[min_index]+V[min_index][k].dist;\n\t\t\t\t\t\t\t\tQ.push(Data(V[min_index][k].to,tmp_min_dist[V[min_index][k].to]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int i = 1; i <= N; i++){\n\t\t\t\t\tif(is_mall[i] == false && min_dist_to_market[i] > tmp_min_dist[i]){\n\t\t\t\t\t\tmin_dist_to_market[i] = tmp_min_dist[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tans = max(ans,min_dist_to_market[i]);\n\t\t}\n\t}\n\n\tfor(int i = 1; i < N; i++){\n\t\tfor(int k = i+1; k <= N; k++){\n\t\t\tif(road[i][k] != BIG_NUM){\n\t\t\t\tans = max(ans,(min_dist_to_market[i]+min_dist_to_market[k]+road[i][k]+1)/2);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  struct Edge {int from, to; double weight;};\n  typedef vector<vector<Edge>> Graph;\n  // Input\n  int N, M, K;\n  cin >> N >> M >> K;\n  Graph G(N);\n  for(int i = 0; i < M; ++i) {\n    int a, b;\n    double l;\n    cin >> a >> b >> l;\n    --a; --b;\n    G[a].push_back({a, b, l});\n    G[b].push_back({b, a, l});\n  }\n  set<int> store;\n  for(int i = 0; i < K; ++i) {\n    int s;\n    cin >> s;\n    store.insert(s - 1);\n  }\n  // Dijkstra\n  vector<int> distance(N, -1);\n  priority_queue<Edge, vector<Edge>, function<bool(Edge, Edge)>> q([](Edge lhs, Edge rhs) {\n    if(lhs.weight != rhs.weight) return lhs.weight > rhs.weight;\n    return lhs.from != rhs.from ? lhs.from < rhs.from : lhs.to < rhs.to;\n  });\n  for(auto i: store) q.push({i, i, 0});\n  while(!q.empty()) {\n    auto e = q.top();\n    q.pop();\n    if(distance[e.to] != -1) continue;\n    distance[e.to] = e.weight;\n    for(const auto& next: G[e.to]) if(distance[next.to] == -1) q.push({next.from, next.to, e.weight + next.weight});\n  }\n  // Output\n  double answer = 0;\n  for(const auto& list: G) for(const auto e: list) if(e.from < e.to) {\n    answer = max(answer, (distance[e.from] + distance[e.to] + e.weight));\n  }\n  cout << (int) (answer / 2.0 + 0.5) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct edge{\n    int to;\n    int cost;\n};\nclass Situation{\npublic:\n\tint cost;\n\tint idx;\n\n\tSituation(int cost_,int idx_){\n\t\tcost=cost_;\n\t\tidx=idx_;\n\t}\n\tSituation();\n\n\tbool operator<(const Situation &s)const{\n\t\treturn s.cost < this->cost;\n\t}\n};\nconst int MAX_V=3001;\n\nint N,M,K;\nvector<edge> G[MAX_V];\n\nint d[MAX_V];\nconst int INF=1000000000;\nint froms[100001];\nint tos[100001];\nint costs[100001];\n\nvoid dijkstra(int s){\n\tpriority_queue<Situation> que;\n\td[s] = 0;\n\tque.push(Situation(0,s));\n\twhile(!que.empty()){\n\t\tSituation p = que.top();\n\t\tque.pop();\n\t\tint v = p.idx;\n\t\tif(d[v] < p.cost)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost){\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(Situation(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n\n    cin>>N>>M>>K;\n    for(int i=0;i<M;i++){\n        edge e;\n        int from,to,cost;\n        cin>>from>>to>>cost;\n        from--;to--;\n        froms[i]=from;\n        tos[i]=to;\n        costs[i]=cost;\n        e.to=to;\n        e.cost=cost;\n        G[from].push_back(e);\n        e.to=from;\n        G[to].push_back(e);\n    }\n\tfill(d,d+MAX_V,INF);\n    for(int i=0;i<K;i++){\n        int a;\n        cin>>a;\n        a--;\n        dijkstra(a);\n    }\n    double res=0;\n    for(int i=0;i<N;i++)\n        res=max(res,(double)d[i]);\n    for(int i=0;i<M;i++){\n        double dit=(1.0*d[froms[i]]+d[tos[i]]+costs[i])/2;\n        res=max(dit,res);\n    }\n    printf(\"%.0f\\n\",res);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct edge{\n    int to;\n    int cost;\n};\nclass Situation{\npublic:\n\tint cost;\n\tint idx;\n\n\tSituation(int cost_,int idx_){\n\t\tcost=cost_;\n\t\tidx=idx_;\n\t}\n\tSituation();\n\n\tbool operator<(const Situation &s)const{\n\t\treturn s.cost < this->cost;\n\t}\n};\nconst int MAX_V=3001;\n\nint N,M,K;\nvector<edge> G[MAX_V];\nbool isShop[MAX_V];\nint d[MAX_V];\nconst int INF=1000000000;\nint froms[MAX_V];\nint tos[MAX_V];\nint costs[MAX_V];\n\nvoid dijkstra(int s){\n\tpriority_queue<Situation> que;\n\td[s] = 0;\n\tque.push(Situation(0,s));\n\twhile(!que.empty()){\n\t\tSituation p = que.top();\n\t\tque.pop();\n\t\tint v = p.idx;\n\t\tif(d[v] < p.cost)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost){\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(Situation(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n    cin>>N>>M>>K;\n    for(int i=0;i<M;i++){\n        edge e;\n        int from,to,cost;\n        cin>>from>>to>>cost;\n        from--;to--;\n        froms[i]=from;\n        tos[i]=to;\n        costs[i]=cost;\n        e.to=to;\n        e.cost=cost;\n        G[from].push_back(e);\n        e.to=from;\n        G[to].push_back(e);\n    }\n\tfill(d,d+MAX_V,INF);\n    for(int i=0;i<K;i++){\n        int a;\n        cin>>a;\n        a--;\n        dijkstra(a);\n    }\n    double res=0;\n    for(int i=0;i<N;i++)\n        res=max(res,(double)d[i]);\n    for(int i=0;i<M;i++){\n        for(int j=0;j<=costs[i];j++){\n            double dit=(double)(d[froms[i]]+d[tos[i]]+costs[i])/2;\n            if((int)(dit+(1e-10))>=d[froms[i]]&&(int)(dit+(1e-10))>=d[tos[i]])\n                res=max(dit,res);\n        }\n    }\n    printf(\"%.0f\\n\",res);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_N=3000;\nconst int INF=100000000;\n\nstruct edge{\n\tint to,cost;\n};\n\nint N,M,K;\nvector<edge> G[MAX_N];\t//??????\n\nint d[MAX_N];\t//???????????¢\n\ntypedef pair<int,int> P;\n\nvoid dijkstra(int s){\n\td[s]=0;\n\tpriority_queue<P,vector<P>,greater<P> > q;\n\tq.push(P(0,s));\n\twhile (!q.empty()){\n\t\tP p=q.top();\n\t\tint v=p.second,dist=p.first;\n\t\tq.pop();\n\t\tif (dist>d[v]) continue;\n\t\tfor (int i=0;i<G[v].size();i++){\n\t\t\tedge e=G[v][i];\n\t\t\tif (d[v]+e.cost<d[e.to]){\n\t\t\t\td[e.to]=d[v]+e.cost;\n\t\t\t\tq.push(P(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d %d %d\",&N,&M,&K);\n\tfor (int i=0;i<M;i++){\n\t\tint a,b,l;\n\t\tscanf(\"%d %d %d\",&a,&b,&l);\n\t\tedge e={b-1,l};\n\t\tG[a-1].push_back(e);\n\t\te={a-1,l};\n\t\tG[b-1].push_back(e);\n\t}\n\tfill(d,d+N,INF);\n\tfor (int i=0;i<K;i++){\n\t\tint s;\n\t\tscanf(\"%d\",&s);\n\t\tdijkstra(s-1);\n\t}\n\tint res=0;\n\tfor (int v=0;v<N;v++){\n\t\tfor (int i=0;i<G[v].size();i++){\n\t\t\tedge e=G[v][i];\n\t\t\tif (d[v]-e.cost==d[e.to]) continue;\n\t\t\tif (d[v]+e.cost==d[e.to]){\n\t\t\t\tres=max(res,d[e.to]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tres=max(res,(int)round((d[v]+d[e.to]+e.cost)/2.0));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1e9\n\nint main(){\n\n    int n, m, k; cin >> n >> m >> k;\n    int v = n;\n    vector<vector<pair<double, int> > > g(v);\n    for(int i = 0; i < m; i++){\n        int a, b;\n        double l;\n        cin >> a >> b >> l;\n        a--;\n        b--;\n        //int c = n + i;\n        double cost = l;\n        g[b].push_back({cost, a});\n        g[a].push_back({cost, b});\n    }\n\n\n    //ダイクストラ\n    priority_queue<pair<double, int> > wait;\n    vector<double> result(v, INF);\n\n    //複数の始点を追加\n    for(int i = 0; i < k; i++){\n        int s; cin >> s;\n        s--;\n        result[s] = 0.0;\n        wait.push(make_pair(0.0, s));\n    }\n\n    while(!wait.empty()){\n\n        int nowpoint = wait.top().second;\n        double nowcost = -wait.top().first;\n        //cout << nowpoint << \" \" << nowcost << endl;\n        wait.pop();\n        \n        if(result[nowpoint] < nowcost) continue;\n\n        //今いる頂点と隣接しているすべての頂点をなめる\n        for(int i = 0; i < (int)g[nowpoint].size(); i++){\n\n            int nextpoint = g[nowpoint][i].second;\n            double nextcost = nowcost + g[nowpoint][i].first;\n            //現時点より安く到達できそうであれば、結果を更新して優先度付きキューに格納\n            if(result[nextpoint] >= nextcost){\n                result[nextpoint] = nextcost;\n                wait.push(make_pair(-nextcost, nextpoint));\n            }\n        }\n    }\n\n    double ans = 0.0;\n    for(int i = 0; i < n; i++){\n        for(auto e : g[i]){\n            ans = max(ans, (result[i] + result[e.second] + e.first) / 2);\n        }\n    }\n\n    cout << round(ans) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <sstream>\n#include <string>\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstring>\n#include <tuple>\n#include <utility>\n#include <list>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> Array;\ntypedef pair<int, int> P;\n\nconst int INF = 1 << 29;\nconst LL MOD = 100000;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define all(c) (c).begin(), (c).end()\n\nstruct edge{ int to, cost; edge(int t, int c) :to(t), cost(c){} };\n\nint dxk[] = { 1, 1, 1, 0, -1, 0 };\nint dxg[] = { 0, 1, 0, -1, -1, -1 };\nint dy[] = { -1, 0, 1, 1, 0, -1 };\n\n//Shopping in JOI Kingdom\nint main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tint m, k; cin >> m >> k;\n\t\tvector<vector<edge>> graph(n);\n\t\trep(i, m)\n\t\t{\n\t\t\tint f, t, d; cin >> f >> t >> d;\n\t\t\tf--; t--;\n\t\t\tgraph[f].push_back(edge(t, d));\n\t\t\tgraph[t].push_back(edge(f, d));\n\t\t}\n\n\t\tvector<int> dists(n, INF);\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\trep(i, k)\n\t\t{\n\t\t\tint x; cin >> x;\n\t\t\tx--;\n\t\t\tdists[x] = 0;\n\t\t\tque.emplace(0, x);\n\t\t}\n\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tP p = que.top(); que.pop();\n\t\t\tint d = p.first, node = p.second;\n\t\t\tif (d > dists[node]) continue;\n\t\t\tfor (auto& e : graph[node]) if (d + e.cost < dists[e.to])\n\t\t\t{\n\t\t\t\tdists[e.to] = d + e.cost;\n\t\t\t\tque.emplace(d + e.cost, e.to);\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\n\t\trep(i, graph.size()) for (auto& e : graph[i]) ans = max(ans, (dists[i] + dists[e.to] + e.cost + 1) / 2);\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<utility>\nusing namespace std;struct road{int a,b,l;road(int a_,int b_,int l_):a(a_),b(b_),l(l_){}};typedef pair<int,int> pii;int main(){int n,m,k,a,b,l,s;vector<road>rd;vector<pii>town[3001];int len[3001];priority_queue<pii,vector<pii>,greater<pii> >qu;for(cin>>n>>m>>k;m--;rd.push_back(road(a,b,l))){cin>>a>>b>>l;town[a].push_back(make_pair(b,l));town[b].push_back(make_pair(a,l));}for(;k--;qu.push(make_pair(0,s)))cin>>s;for(fill(len,len+n+1,-1);!qu.empty();){pii pi=qu.top();qu.pop();if(len[pi.second]==-1){len[pi.second]=pi.first;for(vector<pii>::iterator it=town[pi.second].begin();it!=town[pi.second].end();++it)qu.push(make_pair(pi.first+it->second,it->first));}}s=0;for(vector<road>::iterator it=rd.begin();it!=rd.end();++it){s=max(max(s,len[a]),max(len[b],(len[it->b]+it->l-len[it->a]+1)/2+len[it->a]));}cout<<s<<endl;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<functional>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef pair<int,int> P;\nint N,M,K;\nint A[100000];\nint B[100000];\nint L[100000];\nvector<P>G[3000];\npriority_queue<P,vector<P>,greater<P> >que;\nint S[3000];\nint main()\n{\n\tscanf(\"%d%d%d\",&N,&M,&K);\n\tfor(int i=0;i<N;i++)S[i]=1000*1000*1000;\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%d%d%d\",&A[i],&B[i],&L[i]);A[i]--;B[i]--;\n\t\tG[A[i]].push_back(P(L[i],B[i]));\n\t\tG[B[i]].push_back(P(L[i],A[i]));\n\t}\n\tfor(int i=0;i<K;i++){\n\t\tint S;\n\t\tscanf(\"%d\",&S);S--;\n\t\tque.push(P(0,S));\n\t}\n\twhile(!que.empty()){\n\t\tP p=que.top();que.pop();\n\t\tint pf=p.first;int ps=p.second;\n\t\tif(S[ps]<=pf)continue;\n\t\tS[ps]=pf;\n\t\tfor(int i=0;i<(int)G[ps].size();i++){\n\t\t\tif(pf+G[ps][i].first<S[G[ps][i].second])que.push(P(pf+G[ps][i].first,G[ps][i].second));\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<M;i++){\n\t\tans=max(ans,S[A[i]]+S[B[i]]+L[i]);\n\t}\n\tprintf(\"%d\\n\",(ans+1)/2);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define PB push_back\n#define MP make_pair\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int,int> pii;\nstatic const int inf = 1ll<<60;\nstatic const int MAX_N = 3000;\n\nstruct edge{\n    int to,cost;\n    edge(){}\n    edge(int p1,int p2){\n        to=p1;\n        cost=p2;\n    }\n};\n\nint N,M,K;\nvector<edge> G[MAX_N+5];\nvector<int> civ;\nint d[MAX_N+5];\nint store[MAX_N+5];\nint ans=-inf;\n\nvoid dijkstra(int s){\n    priority_queue<pii,vector<pii>,greater<pii> > que;\n    fill(d,d+MAX_N,inf);\n    d[s]=0;\n    que.push(pii(0,s));\n    while(!que.empty()){\n        pii p=que.top();\n        que.pop();\n        int v=p.se;\n        if(d[v]<p.fi)continue;\n        for(int i=0;i<G[v].size();++i){\n            edge e=G[v][i];\n            if(d[e.to]>d[v]+e.cost){\n                d[e.to]=d[v]+e.cost;\n                que.push(pii(d[e.to],e.to));\n            }\n        }\n    }\n}\n\nsigned main(){\n    memset(store,-1,sizeof(store));\n    cin>>N>>M>>K;\n    for(int i=0;i<M;++i){\n        int a,b,c;\n        cin>>a>>b>>c;\n        a--;b--;\n        G[a].PB(edge(b,c));\n        G[b].PB(edge(a,c));\n    }\n    for(int i=0;i<K;++i){\n        int s;\n        cin>>s;\n        s--;\n        store[s]=s;\n    }\n    for(int i=0;i<N;++i){\n        if(store[i]!=-1)continue;\n        //cout<<i<<endl;\n        civ.PB(i);\n    }\n    for(int i=0;i<civ.size();++i){\n        pii res1,res2;\n        res1.fi=inf;\n        res1.se=inf;\n        //cout<<civ[i]<<endl;\n        dijkstra(civ[i]);\n        for(int j=0;j<N;++j){\n            if(store[j]==-1)continue;\n            if(res1.fi>d[store[j]]){\n                res1.fi=d[store[j]];\n                res1.se=store[j];\n            }\n        }\n        ans=max(res1.fi,ans);\n    }\n    cout<<ans+1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"math.h\"\n#include \"utility\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"iomanip\"\n#include \"random\"\n\nusing namespace std;\nconst long long int MOD = 1000000007;\n\nint N, M, K;\nlist<int>edge[3001];\nint dis[3001];\npriority_queue<int, vector<int>, greater<int>>Q;\nbool flag[3001];\nint ans;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> N >> M >> K;\n\tfor (int i = 1; i <= N; i++)dis[i] = INT_MAX;\n\tfor (int i = 0; i < M; i++) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tedge[a].push_back(c * 10000 + b);\n\t\tedge[b].push_back(c * 10000 + a);\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tint a;\n\t\tcin >> a;\n\t\tdis[a] = 0;\n\t\tQ.push(a);\n\t}\n\twhile (!Q.empty()) {\n\t\tint current = Q.top() % 10000;\n\t\tint far = Q.top() / 10000;\n\t\tQ.pop();\n\t\tif (flag[current])continue;\n\t\tflag[current]=true;\n\t\tfor (auto i : edge[current]) {\n\t\t\tif (dis[i % 10000] > far + i / 10000) {\n\t\t\t\tdis[i % 10000] = far + i / 10000;\n\t\t\t\tQ.push(dis[i % 10000] * 10000 + i % 10000);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (auto j : edge[i]) {\n\t\t\tif (abs(dis[i] - dis[j % 10000]) >= j / 10000) {\n\t\t\t\tans = max(ans, max(dis[i], dis[i % 10000]));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans = max(ans, max(dis[i], dis[i % 10000]) + (j / 10000 - abs(dis[i] - dis[j % 10000]) + 1) / 2);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint n,m,k;\nvector<pair<int,int> > v[3010];//cost,to\npriority_queue<pair<int,int> >Q;//cost,to\nint d[3010];\nint main(){\n\tcin>>n>>m>>k;\n\trep(i,m){\n\t\tint x,y,z;cin>>x>>y>>z;x--,y--;\n\t\tv[x].push_back(make_pair(z,y));\n\t\tv[y].push_back(make_pair(z,x));\n\t}\n\trep(i,n)d[i]=1145141919;\n\trep(u,k){cin>>m;m--;\n\t\twhile(!Q.empty())Q.pop();\n\t\tQ.push(make_pair(0,m));\n\t\twhile(!Q.empty()){\n\t\t\tint x=Q.top().X,y=Q.top().Y;\n\t\t\tQ.pop();\n\t\t\tif(d[y]>x){\n\t\t\t\td[y]=x;\n\t\t\t\trep(i,v[y].size()){\n\t\t\t\t\tQ.push(make_pair(d[y]+v[y][i].X,v[y][i].Y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//rep(i,n)cout<<d[i]<<\" \";cout<<endl;\n\tint ans=-1;\n\trep(i,n)rep(j,v[i].size()){\n\t\tans=max(ans,d[i]+d[v[i][j].Y]+v[i][j].X);\n\t}cout<<ans/2+ans%2<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\n#define INF 1145141919\n\nint N, M, K;\nint S[3010];\nvector<int> edges[3010];\nint cost[3010][3010];\nint D[3010];\n\nint main() {\n  cin >> N >> M >> K;\n  for (int i=0; i<M; i++) {\n    int a, b, l;\n    cin >> a >> b >> l;\n    edges[a-1].push_back(b-1);\n    edges[b-1].push_back(a-1);\n    cost[a-1][b-1] = l;\n    cost[b-1][a-1] = l;\n  }\n  for (int i=0; i<K; i++) {\n    int s;\n    cin >> s;\n    S[i] = s-1;\n  }\n\n  for (int i=0; i<N; i++) D[i] = INF;\n  priority_queue< P, vector<P>, greater<P> > q;\n  for (int i=0; i<K; i++) {\n    D[S[i]] = 0;\n    q.push(P(0, S[i]));\n  }\n\n  while (!q.empty()) {\n    P p = q.top(); q.pop();\n    int s = p.second;\n\n    for (auto t : edges[s]) {\n      if (D[t] > D[s] + cost[s][t]) {\n        D[t] = D[s] + cost[s][t];\n        q.push(P(D[t], t));\n      }\n    }\n  }\n\n  int ans = 0;\n  for (int i=0; i<N; i++) {\n    for (int x : edges[i]) {\n      ans = max(ans, (int)round((double)(D[i] + D[x] + cost[i][x]) / 2));\n    }\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n\nconst int INF = 1 << 24;\nconst int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};\n\ntypedef unsigned long long ull;\ntypedef std::tuple<int, int> P;\n\n\n\nstruct Edge{\n    int to, cost;\n};\n\nnamespace W5{\n    template<typename T>\n    T max(T t){\n        return t;\n    }\n\n    template<typename First, typename... Rest>\n    First max(First f, Rest... r){\n        return std::max(f, W5::max(r...));\n    }\n};\n\nstd::vector<Edge> G[3010];\nstd::vector<int> S;\nint d[3010];\nint N, M, K;\n\nint dijkstra(){\n    int res = 0;\n    std::priority_queue<P, std::vector<P>, std::greater<P>> q;\n    std::fill(d, d+3010, INF);\n\n    REP(i, K){\n        d[S[i]] = 0;\n        q.push(std::make_tuple(0, S[i]));\n    }\n\n    while(!q.empty()){\n        P p = q.top(); q.pop();\n        int u = std::get<0>(p), v = std::get<1>(p);\n        \n        if(d[v] < u){continue;}\n\n        REP(i, G[v].size()){\n            Edge e = G[v][i];\n            if(d[e.to] > d[v] + e.cost){\n                d[e.to] = d[v] + e.cost;\n                q.push(std::make_tuple(d[e.to], e.to));\n                res = std::max(res, d[e.to]);\n            }\n        }\n    }\n\n    return res;\n}\n\nint main(){\n    std::cin >> N >> M >> K;\n    \n    REP(i, M){\n        int from, to, l;\n        std::cin >> from >> to >> l;\n        from--; to--;\n\n        G[from].push_back({to, l});\n        G[to].push_back({from, l});\n    }\n\n    REP(i, K){\n        int s;\n        std::cin >> s;\n        s--;\n\n        S.push_back(s);\n    }\n\n    dijkstra();\n\n    int res = 0;\n    REP(i, N){\n        int l = 0;\n        REP(j, G[i].size()){\n            Edge e = G[i][j];\n\n            l = std::max(l, static_cast<int>(1. * (d[i] + d[e.to] + e.cost) / 2.0 + 0.5));\n        }\n\n        res = W5::max(res, d[i], l);\n    }\n\n    std::cout << res << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate <typename T>\nvector<T> dijkstra(vector<Int> ss,vector<vector<pair<Int, T> > > & G,T INF){\n  using P = pair<T, Int>;\n  Int n=G.size();\n  vector<T> d(n,INF);\n  vector<Int> b(n,-1);\n  priority_queue<P,vector<P>,greater<P> > q;\n  for(Int s:ss){\n    d[s]=0;\n    q.emplace(d[s],s);\n  }\n  while(!q.empty()){\n    P p=q.top();q.pop();\n    Int v=p.second;\n    if(d[v]<p.first) continue;\n    for(auto& e:G[v]){\n      Int u=e.first;\n      T c=e.second;\n      if(d[u]>d[v]+c){\n\td[u]=d[v]+c;\n\tb[u]=v;\n\tq.emplace(d[u],u);\n      }\n    }\n  }\n  return d;\n}\n\n\ntemplate<typename T1,typename T2> void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,m,k;\n  cin>>n>>m>>k;\n  \n  using P = pair<Int, Int>;\n  vector<vector<P> > G(n);\n  for(Int i=0;i<m;i++){\n    Int a,b,c;\n    cin>>a>>b>>c;\n    a--;b--;\n    G[a].emplace_back(b,c);\n    G[b].emplace_back(a,c);\n  }\n\n  vector<Int> ss(k);\n  for(Int i=0;i<k;i++) cin>>ss[i],ss[i]--;\n\n  const Int INF = 1e15;\n  auto dp=dijkstra(ss,G,INF);\n\n  Int ans=0;\n  for(Int i=0;i<n;i++) chmax(ans,dp[i]);\n\n  for(Int v=0;v<n;v++){\n    for(auto e:G[v]){\n      Int u,c;\n      tie(u,c)=e;\n      c=(c+1)/2;\n      chmax(ans,dp[v]+c);\n      chmax(ans,dp[u]+c);\n    }\n  }\n  \n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate <typename T>\nvector<T> dijkstra(vector<Int> ss,vector<vector<pair<Int, T> > > & G,T INF){\n  using P = pair<T, Int>;\n  Int n=G.size();\n  vector<T> d(n,INF);\n  vector<Int> b(n,-1);\n  priority_queue<P,vector<P>,greater<P> > q;\n  for(Int s:ss){\n    d[s]=0;\n    q.emplace(d[s],s);\n  }\n  while(!q.empty()){\n    P p=q.top();q.pop();\n    Int v=p.second;\n    if(d[v]<p.first) continue;\n    for(auto& e:G[v]){\n      Int u=e.first;\n      T c=e.second;\n      if(d[u]>d[v]+c){\n\td[u]=d[v]+c;\n\tb[u]=v;\n\tq.emplace(d[u],u);\n      }\n    }\n  }\n  return d;\n}\n\n\ntemplate<typename T1,typename T2> void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,m,k;\n  cin>>n>>m>>k;\n  \n  using P = pair<Int, Int>;\n  vector<vector<P> > G(n);\n  for(Int i=0;i<m;i++){\n    Int a,b,c;\n    cin>>a>>b>>c;\n    a--;b--;\n    G[a].emplace_back(b,c);\n    G[b].emplace_back(a,c);\n  }\n\n  vector<Int> ss(k);\n  for(Int i=0;i<k;i++) cin>>ss[i],ss[i]--;\n\n  const Int INF = 1e15;\n  auto dp=dijkstra(ss,G,INF);\n\n  Int ans=0;\n  for(Int v=0;v<n;v++){\n    chmax(ans,dp[v]);\n    for(auto e:G[v]){\n      Int u,c;\n      tie(u,c)=e;\n      chmax(ans,(dp[v]+dp[u]+c+1)/2);\n    }\n  }\n  \n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<cstring>\nusing namespace std;\n\n/**** Type Define ****/\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n/**** Const List   ****/\n\nconst ll INF = ((ll)1 << 31) - 1;\nconst ll UNION_FIND_MAX = 100000;\nconst ll SEGMENT_TREE_MAX = (1 << 18) - 1;\nconst ll MAX_FLOW_MAX_V = 10000;\nconst ll MIN_COST_FLOW_MAX_V = 10000;\nconst ll BIPARTITE_MATCHING_MAX_V = 10000;\n\n\n/**** General Functions ****/\n\ntemplate <typename T>\nT tmin(T a, T b) { return a > b ? b : a; };\n\ntemplate <typename T>\nT tmax(T a, T b) { return a > b ? a : b; };\n\ntemplate <typename T>\nT tadd(T a, T b) { return a + b; };\n\ntemplate <typename T>\nT tmul(T a, T b) { return a * b; };\n\ntemplate <typename T>\nT tpow(T a, T b) { return a * b; };\n\nll gcd(ll a, ll b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\n\n/**** Matrix ****/\n\ntemplate <typename T>\nstruct Matrix {\n  typedef vector<T> vec;\n  typedef vector<vec> mat;\n  ll x, y; // x: horizon  y: vertical\n  mat d;\n\n  Matrix(ll _y, ll _x = -1) {\n    if (_x == -1) _x = _y;\n    x = _x, y = _y;\n    for (int i = 0; i < y; i++) for (int j = 0; j < x; j++) d[i][j] = 0;\n  }\n  void unit() {\n    for (int i = 0; i < y; i++) for (int j = 0; j < x; j++) d[i][j] = i == j ? 1 : 0;\n  }\n  Matrix copy() {\n    Matrix m(y, x);\n    for (int i = 0; i < y; i++) for (int j = 0; j < x; j++) m.d[i][j] = d[i][j];\n    return m;\n  }\n  Matrix<T> operator + (Matrix<T>& t) { // No error check! Don't forget to check Matrix size!!\n    Matrix<T> m(y, x);\n    for (int i = 0; i < y; i++) for (int j = 0; j < x; j++) m.d[i][j] = d[i][j] + t.d[i][j];\n    return m;\n  }\n  Matrix<T> operator - (Matrix<T>& t) {\n    Matrix<T> m(y, x);\n    for (int i = 0; i < y; i++) for (int j = 0; j < x; j++) m.d[i][j] = d[i][j] - t.d[i][j];\n    return m;\n  }\n  Matrix<T> operator * (T t) {\n    Matrix<T> m(y, x);\n    for (int i = 0; i < y; i++) for (int j = 0; j < x; j++) m.d[i][j] = d[i][j] * t;\n    return m;\n  }\n  Matrix<T> det(Matrix<T>& t) { // x need to correspond to t.y\n    Matrix<T> m(y, x);\n    for (int i = 0; i < y; i++)\n      for (int j = 0; j < x; j++)\n        for (int k = 0; k < t.x; k++) m.d[i][j] += d[i][k] * t.d[k][j]; ////////////// mod???\n    return m;\n  }\n};\n\n/**** Zip ****/\n\ntemplate <typename T>\nclass Zip {\n  vector<T> d;\n  bool flag;\npublic:\n  Zip() {\n    flag = false;\n  }\n  void add(T x) {\n    d.push_back(x);\n    flag = true;\n  }\n  ll getNum(T x) { // T need to have operator < !!\n    if (flag) {\n      sort(d.begin(), d.end());\n      d.erase(unique(d.begin(), d.end()), d.end());\n      flag = false;\n    }\n    return lower_bound(d.begin(), d.end(), x) - d.begin();\n  }\n  ll size() {\n    return (ll)d.size();\n  }\n};\n\n/**** Union Find ****/\n\nclass UnionFind {\n  ll par[UNION_FIND_MAX];\n  ll rank[UNION_FIND_MAX];\npublic:\n  void init(ll n) {\n    for (ll i = 0; i < n; i++) par[i] = i, rank[i] = 0;\n  }\n  UnionFind(ll n) {\n    init(n);\n  }\n  ll findRoot(ll x) {\n    if (par[x] == x) return x;\n    return par[x] = findRoot(par[x]);\n  }\n  void merge(ll x, ll y) {\n    x = findRoot(x);\n    y = findRoot(y);\n    if (x == y) return;\n    if (rank[x] < rank[y]) {\n      par[x] = y;\n    } else {\n      par[y] = x;\n      if (rank[x] == rank[y]) rank[x]++;\n    }\n  }\n  bool isSame(ll x, ll y) {\n    return findRoot(x) == findRoot(y);\n  }\n};\n\ntemplate <typename T>\nclass UnionFindT {\n  ll par[UNION_FIND_MAX];\n  ll rank[UNION_FIND_MAX];\n  T weight[UNION_FIND_MAX];\npublic:\n  void init(ll n, T w) {\n    for (ll i = 0; i < n; i++) par[i] = i, rank[i] = 0, weight[i] = w;\n  }\n  UnionFindT(ll n, T w) {\n    init(n, w);\n  }\n  ll findRoot(ll x) {\n    if (par[x] == x) return x;\n    weight[x] += weight[par[x]];\n    return par[x] = findRoot(par[x]);\n  }\n  T getWeight(ll x) {\n    findRoot(x);\n    return weight[x];\n  }\n  bool merge(ll x, ll y, T w) {\n    // weight(y) = weight(x) + wにする\n    w += weight(x);\n    w -= weight(y);\n    x = findRoot(x);\n    y = findRoot(y);\n    if (x == y) return false;\n    if (rank[x] < rank[y]) {\n      par[x] = y;\n      weight[x] = -w;\n    } else {\n      par[y] = x;\n      weight[y] = w;\n      if (rank[x] == rank[y]) rank[x]++;\n    }\n    return true;\n  }\n  T diff(ll x, ll y) { // xが基準でyの重み\n    return weight(y) - weight(x);\n  }\n  bool isSame(ll x, ll y) {\n    return findRoot(x) == findRoot(y);\n  }\n};\n\n/**** Segment Tree ****/\n\ntemplate <typename T>\nstruct SegmentTree {\n  ll n;\n  T dat[SEGMENT_TREE_MAX];\n  function<T(T, T)> acc;\n  T out;\n  SegmentTree(function<T(T, T)> func, T overNum) {\n    acc = func;\n    out = overNum;\n  }\n  void init(ll _n) {\n    n = 1;\n    while (n < _n) n *= 2;\n    for (ll i = 0; i < 2 * n - 1; i++) dat[i] = out;\n  }\n  void nodeUpdate(ll k, T d) {\n    // k番目をdに変える\n    k += n - 1;\n    dat[k] = d;\n    while (k > 0) {\n      k = (k - 1) / 2;\n      dat[k] = acc(dat[k * 2 + 1], dat[k * 2 + 2]);\n    }\n  }\n  T rangeQuery(ll a, ll b) {\n    return tempRangeQuery(a, b, 0, 0, n);\n  }\n\nprivate:\n  T tempRangeQuery(const ll& a, const ll& b, ll k, ll l, ll r) {\n    if (r <= a || b <= l) return out;\n    if (a <= l && r <= b) return dat[k];\n    T vl = tempRangeQuery(a, b, k * 2 + 1, l, (l + r) / 2);\n    T vr = tempRangeQuery(a, b, k * 2 + 2, (l + r) / 2, r);\n    return acc(vl, vr);\n  }\n};\n\n/**** Network Flow ****/\n\nclass MaxFlow {\npublic:\n  struct edge { ll to, cap, rev; };\n\n  vector<edge> G[MAX_FLOW_MAX_V];\n  bool used[MAX_FLOW_MAX_V];\n  ll level[MAX_FLOW_MAX_V];\n  ll iter[MAX_FLOW_MAX_V];\n  \n  void init() {\n    for (ll i = 0; i < MAX_FLOW_MAX_V; i++) {\n      G[i].clear();\n    }\n  }\n  void add_edge(ll from, ll to, ll cap) {\n    G[from].push_back((edge){to, cap, (ll)G[to].size()});\n    G[to].push_back((edge){from, 0, (ll)G[from].size() - 1});\n  }\n  void add_undirected_edge(ll e1, ll e2, ll cap) {\n    G[e1].push_back((edge){e2, cap, (ll)G[e2].size()});\n    G[e2].push_back((edge){e1, cap, (ll)G[e1].size() - 1});\n  }\n  ll dfs(ll v, ll t, ll f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (ll i = 0; i < (ll)G[v].size(); i++) {\n      edge &e = G[v][i];\n      if (!used[e.to]&& e.cap > 0) {\n        ll d = dfs(e.to, t, min(f, e.cap));\n        if (d > 0) {\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n  ll max_flow(ll s, ll t) {\n    ll flow = 0;\n    while (1) {\n      memset(used, 0, sizeof(used));\n      ll f = dfs(s, t, INF);\n      if (f == 0) return flow;\n      flow += f;\n    }\n  }\n  void bfs(ll s) {\n    memset(level, -1, sizeof(level));\n    queue<ll> que;\n    level[s] = 0;\n    que.push(s);\n    while (!que.empty()) {\n      ll v = que.front(); que.pop();\n      for (ll i = 0; i < (ll)G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && level[e.to] < 0) {\n          level[e.to] = level[v] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n  }\n  ll dinic_dfs(ll v, ll t, ll f) {\n    if (v == t) return f;\n    for (ll &i= iter[v]; i < (ll)G[v].size(); i++) {\n      edge &e = G[v][i];\n      if (e.cap > 0 && level[v] < level[e.to]) {\n        ll d = dinic_dfs(e.to, t, min(f, e.cap));\n        if (d > 0) {\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n  ll dinic(ll s, ll t) {\n    ll flow = 0;\n    while (1) {\n      bfs(s);\n      if (level[t] < 0) return flow;\n      memset(iter, 0, sizeof(iter));\n      ll f;\n      while ((f = dinic_dfs(s, t, INF)) > 0) {\n        flow += f;\n      }\n    }\n  }\n};\n\n/**** bipartite matching ****/\n\nclass BipartiteMatching {\npublic:\n  ll V;\n  vector<ll> G[BIPARTITE_MATCHING_MAX_V];\n  ll match[BIPARTITE_MATCHING_MAX_V];\n  bool used[BIPARTITE_MATCHING_MAX_V];\n  \n  BipartiteMatching(ll v) {\n    V = v;\n  }\n  void init(ll v) {\n    V = v;\n    for (ll i = 0; i < BIPARTITE_MATCHING_MAX_V; i++) {\n      G[i].clear();\n    }\n  }\n  void add_edge(ll u, ll v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  bool dfs(ll v) {\n    used[v] = true;\n    for (ll i = 0; i < (ll)G[v].size(); i++) {\n      ll u = G[v][i], w = match[u];\n      if (w < 0 || !used[w] && dfs(w)) {\n        match[v] = u;\n        match[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n  ll max_matching() {\n    ll res = 0;\n    memset(match, -1, sizeof(match));\n    for (ll v = 0; v < V;v++) {\n      if (match[v] < 0) {\n        memset(used, 0, sizeof(used));\n        if (dfs(v)) {\n          res++;\n        }\n      }\n    }\n    return res;\n  }\n};\n\nclass MinCostFlow {\npublic:\n  struct edge { ll to, cap, cost, rev; };\n\n  ll V;\n  vector<edge> G[MIN_COST_FLOW_MAX_V];\n  ll dist[MIN_COST_FLOW_MAX_V];\n  ll prevv[MIN_COST_FLOW_MAX_V];\n  ll preve[MIN_COST_FLOW_MAX_V];\n  ll h[MIN_COST_FLOW_MAX_V];\n\n  MinCostFlow(ll v) {\n    V = v;\n  }\n  void init() {\n    for (ll i = 0; i < MAX_FLOW_MAX_V; i++) {\n      G[i].clear();\n    }\n  }\n  void add_edge(ll from, ll to, ll cap, ll cost) {\n    G[from].push_back((edge){to, cap, cost, (ll)G[to].size()});\n    G[to].push_back((edge){from, 0, -cost, (ll)G[from].size() - 1});\n  }\n  void add_undirected_edge(ll e1, ll e2, ll cap, ll cost) {\n    add_edge(e1, e2, cap, cost);\n    add_edge(e2, e1, cap, cost);\n  }\n  ll min_cost_flow(ll s, ll t, ll f) { // minas\n    ll res = 0;\n    while (f > 0) {\n      fill(dist, dist + V, INF);\n      dist[s] = 0;\n      bool update = true;\n      while (update) {\n        update = false;\n        for (ll v = 0; v < V; v++) {\n          if (dist[v] == INF) continue;\n          for (ll i = 0; i < (ll)G[v].size(); i++) {\n            edge &e = G[v][i];\n            if (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n              dist[e.to] = dist[v] + e.cost;\n              prevv[e.to] = v;\n              preve[e.to] = i;\n              update = true;\n            }\n          }\n        }\n      }\n      if (dist[t] == INF) {\n        return -1;\n      }\n      ll d = f;\n      for (ll v = t; v != s; v = prevv[v]) {\n        d = min(d, G[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      res += d * dist[t];\n      for (ll v = t; v != s; v = prevv[v]) {\n        edge &e = G[prevv[v]][preve[v]];\n        e.cap -= d;\n        G[v][e.rev].cap += d;\n      }\n    }\n    return res;\n  }\n  ll min_cost_flow_dijkstra(ll s, ll t, ll f) {\n    ll res = 0;\n    fill(h, h + V, 0);\n    while (f > 0) {\n      priority_queue<P, vector<P>, greater<P> > que;\n      fill(dist, dist + V, 0);\n      dist[s] = 0;\n      que.push(P(0, s));\n      while (!que.empty()) {\n        P p = que.top(); que.pop();\n        int v = p.second;\n        if (dist[v] < p.first) continue;\n        for (int i = 0; i < G[v].size(); i++) {\n          edge &e = G[v][i];\n          if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n            dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n            prevv[e.to] = v;\n            preve[e.to] = i;\n            que.push(P(dist[e.to], e.to));\n          }\n        }\n      }\n      if (dist[t] == INF) {\n        return -1;\n      }\n      for (int v = 0; v < V; v++) h[v] += dist[v];\n      int d = f;\n      for (int v = t; v != s; v = prevv[v]) {\n        d = tmin<ll>(d, G[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      res += d * h[t];\n      for (int v = t; v != s; v = prevv[v]) {\n        edge &e = G[prevv[v]][preve[v]];\n        e.cap -= d;\n        G[v][e.rev].cap += d;\n      }\n      return res;\n    }\n    return 0;\n  }\n};\n\n/**** main function ****/\n\nll n, m, k, a, b, l, s;\nstruct edge { ll to, cost; };\nvector<edge> G[3000];\nll d[3000];\npriority_queue<P, vector<P>, greater<P> > que;\n\nint main() {\n  scanf(\"%lld%lld%lld\", &n, &m, &k);\n  for (ll i = 0; i < m; i++) {\n    scanf(\"%lld%lld%lld\", &a, &b, &l);\n    a--; b--;\n    G[a].push_back((edge){b, l});\n    G[b].push_back((edge){a, l});\n  }\n  for (ll i = 0; i < n; i++) d[i] = INF;\n  for (ll i = 0; i < k; i++) {\n    scanf(\"%lld\", &s);\n    s--;\n    que.push(P(0, s));\n  }\n  while (!que.empty()) {\n    P p = que.top(); que.pop();\n    ll from = p.second, cost = p.first;\n    if (d[from] != INF) continue;\n    d[from] = cost;\n    for (ll i = 0; i < G[from].size(); i++) {\n      edge e = G[from][i];\n      ll next = e.to, newcost = cost + e.cost;\n      if (d[next] != INF) continue;\n      que.push(P(newcost, next));\n    }\n  }\n  ll ans = 0.0;\n  for (ll i = 0; i < n; i++) {\n    for (ll j = 0; j < G[i].size(); j++) {\n      edge e = G[i][j];\n      ll a = d[i] + d[e.to] + e.cost;\n      ans = max(ans, (a+1)/2);\n    }\n  }\n  printf(\"%lld\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 1e18\n#define INF 1e9\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\nusing ll = long long;\nusing PII = pair<int, int>;\n\nvector<PII> G[3030];\nint d[3030];\n\nint main(void){\n\tint N, M, K;\n\tcin >> N >> M >> K;\n\tREP(i, M){\n\t\tint a, b, l;\n\t\tcin >> a >> b >> l;\n\t\ta--; b--;\n\t\tG[a].push_back({l, b});\n\t\tG[b].push_back({l, a});\n\t}\n\tfill(d, d+N, INF);\n\tREP(i, K){\n\t\tint s;\n\t\tcin >> s;\n\t\ts--;\n\t\td[s] = 0;\n\t\tpriority_queue<PII, vector<PII>, greater<PII> > pq;\n\t\tpq.push({0, s});\n\t\twhile(pq.size()){\n\t\t\tPII p = pq.top(); pq.pop();\n\t\t\tint v = p.second;\n\t\t\tif(d[v] < p.first) continue;\n\t\t\tREP(i, G[v].size()){\n\t\t\t\tif(d[G[v][i].second] > d[v] + G[v][i].first){\n\t\t\t\t\td[G[v][i].second] = d[v] + G[v][i].first;\n\t\t\t\t\tpq.push({d[G[v][i].second], G[v][i].second});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint res = 0;\n\tREP(i, N){\n\t\tres = max(res, d[i]);\n\t\tREP(j, G[i].size()){\n\t\t\tif(i == j) continue;\n\t\t\tres = max(res, (d[i]+d[G[i][j].second]+G[i][j].first+1)/2);\n\t\t}\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n\nstruct data{\n    int dist,s;\n    data(){}\n    data(int _dist,int _s){\n        dist=_dist; s=_s;\n    }\n    bool operator<(const data &a)const{\n        return dist>a.dist;\n    }\n};\n\nstruct Way{\n    int to,l;\n    Way(){}\n    Way(int _to,int _l){\n        to=_to; l=_l;\n    }\n};\n\nint way_id[3000][3000];\n\nint main(){\n    int N,M,K,A,B,L,S;\n    vector<Way> way[3000];\n    priority_queue<data> q;\n    cin>>N>>M>>K;\n    for(int i=0;i<M;i++){\n        cin>>A>>B>>L;\n\t\tA--; B--;\n        way[A].push_back(Way(B,L));\n        way[B].push_back(Way(A,L));\n        way_id[A][B]=way_id[B][A]=i;\n    }\n    for(int i=0;i<K;i++){\n        cin>>S;\n        q.push(data(0,--S));\n    }\n\n\tint memo[3000];\n\tfor(int i=0;i<N;i++) memo[i]=-1;\n    data q_c;\n    while(!q.empty()){\n        q_c = q.top();\n        q.pop();\n\t\tif(memo[q_c.s]!=-1) continue;\n\t\tmemo[q_c.s]=q_c.dist;\n\t\tfor(int i=0;i<way[q_c.s].size();i++){\n\t\t\tq.push(data(q_c.dist+way[q_c.s][i].l,way[q_c.s][i].to));\n\t\t}\n    }\n\t\n\tint ans=0;\n    for(int i=0;i<N;i++){\n\t\tfor(int j=0;j<way[i].size();j++){\n\t\t\tans = max(ans,memo[i]+(memo[way[i][j].to]-memo[i]+way[i][j].l+1)/2);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cmath>\n#define INF 1e+9\nusing namespace std;\n\ntypedef pair<int,int> P;\nstruct edge{ int to,cost; };\n\nint main(){\n\tint n,m,k,a,b,l,s;\n\tint d[3000],dtd[3000][3000];\n\tvector<edge> G[3000];\n\tqueue<P> que; \n\tcin >> n >> m >> k;\n\tfor(int i = 0;i < n;i++) {\n\t\td[i] = INF;\n\t\tfor(int j = 0;j < n;j++) dtd[i][j] = -1;\n\t}\n\tfor(int i = 0;i < m;i++){\n\t\tcin >> a >> b >> l;\n\t\tG[a - 1].push_back({b - 1,l});\n\t\tG[b - 1].push_back({a - 1,l});\n\t\tdtd[a - 1][b - 1] = l;\n\t\tdtd[b - 1][a - 1] = l;\n\t}\n\tfor(int i = 0;i < k;i++){\n\t\tcin >> s;\n\t\tque.push(P(s - 1,0));\n\t}\n\twhile(!que.empty()){\n\t\tP p = que.front();que.pop();\n\t\tif(d[p.first] <= p.second) continue;\n\t\td[p.first] = p.second;\n\t\tfor(int i = 0;i < G[p.first].size();i++){\n\t\t\tque.push({G[p.first][i].to,d[p.first] + G[p.first][i].cost});\n\t\t}\n\t}\n\tdouble ma = 0;\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < n;j++){\n\t\t\tif(dtd[i][j] != -1) ma = max(ma,(double)(d[i] + d[j] + dtd[i][j]) / 2.0);\n\t\t}\n\t}\n\tcout << (int)round(ma) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\nusing namespace std;\nstatic const int MAX = 3000;\nstatic const int INF = 1<<29;\n\nclass E{\npublic:\n  int t, c;\n  E(){}\n  E(int t, int c):t(t), c(c){}\n};\n\nint N, K;\nvector<E> G[MAX];\n\nvoid dijkstra(){\n  int d[MAX];\n  priority_queue<pair<int, int> > PQ;\n  for ( int i = 0; i < N; i++ ) d[i] = INF;\n  for ( int i = 0; i < K; i++ ){\n    int k; cin >> k; k--;\n    PQ.push(make_pair(0, k));\n    d[k] = 0;\n  }\n  int u, v, c;\n  pair<int, int> s;\n  while(!PQ.empty() ){\n    s = PQ.top(); PQ.pop();\n    u = s.second;\n    for ( int i = 0; i < G[u].size(); i++ ){\n      v = G[u][i].t;\n      c = G[u][i].c;\n      if ( d[v] > d[u] + c ){\n\td[v] = d[u] + c;\n\tPQ.push(make_pair(-1*d[v], v));\n      }\n    }\n  }\n\n  double maxv = 0;\n  for ( u = 0; u < N; u++ ){\n    maxv = max(maxv, 1.0*d[u]);\n    for ( int j = 0; j < G[u].size(); j++ ){\n      v = G[u][j].t;\n      c = G[u][j].c;\n      maxv = max(maxv, (d[u] + d[v] + c)/2.0);\n    }\n  }\n  cout << (int)(maxv+0.5) << endl;\n  \n}\n\n\nmain(){\n  int M,  s, t, c;\n  cin >> N >> M >> K;\n  for ( int i = 0; i < M; i++ ){\n    cin >> s >> t >> c; s--; t--;\n    G[s].push_back(E(t, c));\n    G[t].push_back(E(s, c));\n  }\n  dijkstra();\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nunsigned dist[3001];\nint N,M,K;\nvector<P> path[3001];\nint main() {\n\tmemset(dist,-1,sizeof(dist));\n\tcin >> N >> M >> K;\n\tfor(int i=0;i<M;i++){\n\t\tint a,b,l;\n\t\tcin >> a >> b >> l;\n\t\tpath[a].push_back(P(b,l));\n\t\tpath[b].push_back(P(a,l));\n\t}\n\tpriority_queue<P,vector<P>, greater<P> > q;\n\tfor(int i=0;i<K;i++){\n\t\tint s;\n\t\tcin >> s;\n\t\tq.push(P(0,s));\n\t\tdist[s]=0;\n\t}\n\twhile(q.size()){\n\t\tdouble d=q.top().first;\n\t\tint i=q.top().second;\n\t\tq.pop();\n\t\tif(dist[i]<d)continue;\n\t\tfor(P p:path[i]){\n\t\t\tif(d+p.second<dist[p.first]){\n\t\t\t\tdist[p.first]=d+p.second;\n\t\t\t\tq.push(P(d+p.second,p.first));\n\t\t\t}\n\t\t}\n\t}\n\tunsigned ret=0;\n\tfor(int a=1;a<=N;a++){\n\t\tfor(auto p:path[a]){\n\t\t\tint b=p.first;\n\t\t\tint d=p.second;\n\t\t\tif(dist[b]>=dist[a]){\n\t\t\t\tret=max(ret,(dist[b]-dist[a]+d+1)/2+dist[a]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3002\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<P> G[N];\nbool num[N];\nint n,m,K;\n\ndouble dijkstra(){\n  int D[N];\n  for(int i=0;i<N;i++) D[i] = 1e9;\n  \n  vector<int>pre[N];\n  priority_queue<PP,vector<PP>,greater<PP> >Q;\n  \n  for(int i=0;i<N;i++)\n    if(num[i]) {\n      Q.push(PP(0,P(i,i)));\n      D[i] = 0;\n    }\n\n  \n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first;\n    int pos = t.second.first;\n    int start = t.second.second;\n\n    if(D[pos]<cost) continue;\n    pre[pos].push_back(start);\n    \n    for(int i=0;i<G[pos].size();i++){\n      int npos = G[pos][i].first;\n      int ncost = cost+G[pos][i].second;\n      if(D[npos]<ncost) continue;\n      Q.push(PP(ncost,P(npos,start)));\n      D[npos] = ncost;\n    }\n  }\n\n  cout<<\"OK\"<<endl;\n  double res = 0;\n  for(int i=0;i<n;i++){\n    if(pre[i].size()>=2)res = max(res,(double)D[i]);\n    res = max(res,D[i]/2.0);\n    \n    for(int j=0;j<G[i].size();j++){\n      int npos = G[i][j].first;\n      int ncost = G[i][j].second;\n      if(pre[npos][0] == pre[i][0] && abs(D[i]-D[npos])==ncost)continue;\n\n      res = max(res,(D[i]+D[npos]+ncost)/2.0);\n    }\n  }\n  return res;\n  \n}\n\nint main(){\n  \n  cin>>n>>m>>K;\n  for(int i=0,a,b,c;i<m;i++){\n    cin>>a>>b>>c;\n    G[a-1].push_back(P(b-1,c));\n    G[b-1].push_back(P(a-1,c));\n  }\n\n  for(int i=0,a;i<K;i++)cin>>a,num[a-1]=1;\n  printf(\"%d\\n\",(int)(dijkstra()+0.5));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\n\n#define fr first\n#define sc second\n#define pb push_back\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define rep1(i,x) for(ll i=1;i<=x;i++)\n#define rrep(i,x) for(ll i=x-1;i>=0;i--)\n#define rrep1(i,x) for(ll i=x;i>0;i--)\nstruct edge{\n\tll to,cost;\n};\nvector<edge> G[3000];\nll d[3000];\nll n,m,k;\nconst ll INF=0xffffffffff;\npriority_queue<P,vector<P>,greater<P> > q;\nint main()\n{\n\tcin>>n>>m>>k;\n\tfill(d,d+n,INF);\n\trep(i,m){\n\t\tll x,y,z;\n\t\tcin>>x>>y>>z;\n\t\ty--;\n\t\tx--;\n\t\tG[x].pb(edge{y,z});\n\t\tG[y].pb(edge{x,z});\n\t}\n\trep(i,k){\n\t\tll x;\n\t\tcin>>x;\n\t\td[--x]=0;\n\t\tq.push(P(0,x));\n\t}\n\twhile(!q.empty()){\n\t\tP p=q.top();\n\t\tq.pop();\n\t\tll x=p.sc;\n\t\tif(d[x]<p.fr) continue;\n\t\trep(i,G[x].size()){\n\t\t\tedge e=G[x][i];\n\t\t\tif(d[e.to]>d[x]+e.cost){\n\t\t\t\td[e.to]=d[x]+e.cost;\n\t\t\t\tq.push(P(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n\t//rep(i,n) cout<<i+1<<\"]= \"<<d[i]<<endl;\n\tll ans=0;\n\trep(i,n){\n\t\trep(j,G[i].size()){\n\t\t\tedge e=G[i][j];\n\t\t\tll a=d[i],b=d[G[i][j].to];\n\t\t\tif(abs(a-b)>=e.cost){\n\t\t\t\tans=max(ans,max(a,b));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans=max(ans,(a+b+e.cost+1)/2);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\nusing namespace std;\n\nvector<int>x[4000];\nint n,m,a,b,c,k,G;\nint s[4000],d[4000];\nint X[4000];\ndouble maxn;int res;\n\nint main(){\n\tmemset(X,63,sizeof(X));\n\tcin>>n>>m>>k;\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>a>>b>>c;\n\t\tx[a].push_back(b*10000+c);\n\t\tx[b].push_back(a*10000+c);\n\t}\n\tfor(int i=0;i<k;i++){\n\t\tcin>>a;\n\t\ts[a]=1;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(s[i]==1){\n\t\t\tmemset(d,63,sizeof(d));\n\t\t\td[i]=0;\n\t\t\tif(n<500){G=n;}\n\t\t\telse{\n\t\t\t\tG=max(22,(n+k)/k+10);\n\t\t\t}\n\t\t\tfor(int h=1;h<=G;h++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tif(d[j]<100000000){\n\t\t\t\t\t\tfor(int k=0;k<x[j].size();k++){\n\t\t\t\t\t\t\td[x[j][k]/10000]=min(d[x[j][k]/10000],d[j]+x[j][k]%10000);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tX[j]=min(X[j],d[j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tmaxn=max((int)maxn,X[i]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<x[i].size();j++){\n\t\t\tif(abs(X[i]-X[x[i][j]/10000])<x[i][j]%10000){\n\t\t\t\ta=x[i][j]%10000-abs(X[i]-X[x[i][j]/10000]);\n\t\t\t\tmaxn=max(maxn,(double)(max(X[i],X[(int)(x[i][j]/10000)])+1.0*a/2.0));\n\t\t\t}\n\t\t}\n\t}\n\tres=(1.0*maxn+0.99999999);\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1e9\ntypedef long long LL;\ntypedef pair<int,int>P;\nstruct edge{int to,cost;};\n\nvector<edge>G[3390];\nint dis[3390];\n\nvoid dijkstra(int s){\n\tpriority_queue<P,vector<P>,greater<P> >Q;\n\tfill(dis,dis+3141,INF);\n\tdis[s]=0;\n\tQ.push(P(0,s));\n\t\n\twhile(Q.size()){\n\t\tP p=Q.top();\n\t\tQ.pop();\n\t\tint v=p.second;\n\t\tif(dis[v]<p.first)continue;\n\t\t\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tedge e=G[v][i];\n\t\t\tif(dis[e.to]>dis[v]+e.cost){\n\t\t\t\tdis[e.to]=dis[v]+e.cost;\n\t\t\t\tQ.push(P(dis[e.to],e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nint main(){\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\t\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tG[a-1].push_back({b-1,c});\n\t\tG[b-1].push_back({a-1,c});\n\t\t}\n\t\t\n\tfor(int i=0;i<k;i++){\n\t\tint a;\n\t\tcin>>a;\n\t\tG[3235].push_back({a-1,0});\n\t\t}\t\n\t\t\n\tdijkstra(3235);\n\t\n\tint ans=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<G[i].size();j++){\n\t\t\tans=max(ans,(dis[i]+dis[G[i][j].to]+1)/2);\n\t\t\tans=max(ans,max(dis[i],dis[G[i][j].to]));\n\t\t\t}\n\t\t}\t\n\t\tcout<<ans+1<<endl;\n\t\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF (1<<29)\n\ntypedef pair<int, int> pii;\n\nint d[3000][3000]; // ???i, j????????¢\nint minCost[3000]; // ???i????????§???????????°??¢???????????§??????????????¢\nbool shop[3000]; // ???i????????§???????????°??¢??????????????????\nvector<pii> g[3000]; // to, cost\nint n, m, k;\n\nint main() {\n\tcin >> n >> m >> k;\n\t\n\tfill(d[0], d[n], INF);\n\tfill(minCost, minCost + n, INF);\n\t\n\tREP(i, m) {\n\t\tint a, b, l;\n\t\tscanf(\"%d %d %d\", &a, &b, &l);\n\t\ta--; b--;\n\t\tg[a].push_back(pii(b, l));\n\t\tg[b].push_back(pii(a, l));\n\t\td[a][b] = d[b][a] = l;\n\t}\n\t\n\tREP(i, k) {\n\t\tint pos;\n\t\tscanf(\"%d\", &pos);\n\t\tpos--;\n\t\tshop[pos] = true;\n\t\t\n\t}\n\t\n\tREP(i, n) {\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > pq; // cost, pos\n\t\tpq.push(pii(0, i));\n\t\t\n\t\tvector<int> dist(n, INF);\n\t\tdist[i] = 0;\n\t\twhile (!pq.empty()) {\n\t\t\tpii now = pq.top(); pq.pop();\n\t\t\t\n\t\t\tint ncost = now.first;\n\t\t\tint npos = now.second;\n\t\t\t\n\t\t\tif (dist[npos] < ncost) continue;\n\t\t\t\n\t\t\tif (shop[npos]) {\n\t\t\t\tminCost[i] = dist[npos];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tREP(j, g[npos].size()) {\n\t\t\t\tint to = g[npos][j].first;\n\t\t\t\tint cost = ncost + g[npos][j].second;\n\t\t\t\tif (dist[to] > cost) {\n\t\t\t\t\tdist[to] = cost;\n\t\t\t\t\tpq.push(pii(cost, to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tREP(i, n) FOR(j, i + 1, n) {\n\t\tif (d[i][j] == INF) continue;\n\t\tans = max(ans, (minCost[i] + minCost[j] + d[i][j] + 1) / 2);\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n\n//1:20"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\nusing namespace std;\n\nvector<int>x[4000];\nint n,m,a,b,c,k,G;\nint s[4000],d[4000];\nint X[4000];\ndouble maxn;int res;\n\nint main(){\n\tmemset(X,63,sizeof(X));\n\tcin>>n>>m>>k;\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>a>>b>>c;\n\t\tx[a].push_back(b*10000+c);\n\t\tx[b].push_back(a*10000+c);\n\t}\n\tfor(int i=0;i<k;i++){\n\t\tcin>>a;\n\t\ts[a]=1;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(s[i]==1){\n\t\t\tmemset(d,63,sizeof(d));\n\t\t\td[i]=0;\n\t\t\tif(n<500){G=n;}\n\t\t\telse{\n\t\t\t\tG=min(50,(n+k)/k+10);\n\t\t\t}\n\t\t\tfor(int h=1;h<=G;h++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tif(d[j]<100000000){\n\t\t\t\t\t\tfor(int k=0;k<x[j].size();k++){\n\t\t\t\t\t\t\td[x[j][k]/10000]=min(d[x[j][k]/10000],d[j]+x[j][k]%10000);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tX[j]=min(X[j],d[j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tmaxn=max((int)maxn,X[i]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<x[i].size();j++){\n\t\t\tif(abs(X[i]-X[x[i][j]/10000])<x[i][j]%10000){\n\t\t\t\ta=x[i][j]%10000-abs(X[i]-X[x[i][j]/10000]);\n\t\t\t\tmaxn=max(maxn,(double)(max(X[i],X[(int)(x[i][j]/10000)])+1.0*a/2.0));\n\t\t\t}\n\t\t}\n\t}\n\tres=(1.0*maxn+0.99999999);\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<map>\n#define INF 10000000\n#define to first\n#define cost second\nusing namespace std;\ntypedef pair<int,int> P;\nvector<P> e[3000];\nint d[3000];\nbool used[3000];\nint min(int a,int b){return a<b?a:b;}\nint max(int a,int b){return a>b?a:b;}\nint abs(int a){return a>=0?a:-a;}\nint round(int a){return a%2==0?a/2:a/2+1;}\nint n,m,ns;\nvoid dykstra(){\n\tint i,j;\n\twhile(1){\n\t\tint v=-1;\n\t\tfor(i=0;i<n;i++)if(!used[i]&&(v==-1||d[i]<d[v]))v=i;\n\t\tif(v==-1)break;\n\t\tused[v]=true;\n\t\tfor(i=0;i<e[v].size();i++){\n\t\t\tint u=e[v][i].to;\n\t\t\tint cos=e[v][i].cost;\n\t\t\td[u]=min(d[u],d[v]+cos);\n\t\t}\n\t}\n}\nint main(){\n\tint i,j;\n\tscanf(\"%d %d %d\",&n,&m,&ns);\n\tfor(i=0;i<n;i++){\n\t\td[i]=INF;\n\t\tused[i]=false;\n\t}\n\tfor(i=0;i<m;i++){\n\t\tint a,b,c;\n\t\tscanf(\"%d %d %d\",&a,&b,&c);\n\t\ta--;b--;\n\t\te[a].push_back(P(b,c));\n\t\te[b].push_back(P(a,c));\n\t}\n\tfor(i=0;i<ns;i++){\n\t\tint s;\n\t\tscanf(\"%d\",&s);\n\t\ts--;\n\t\td[s]=0;\n\t}\n\tdykstra();\n\tint ans=0;\n\tfor(i=0;i<n;i++){\n\t\tans=max(ans,d[i]);\n\t\tfor(j=0;j<e[i].size();i++){\n\t\t\tint u=e[i][j].to;\n\t\t\tint cos=e[i][j].cost;\n\t\t\tif(abs(d[i]-d[u])<cos)ans=max(ans,round(d[i]+d[u]+cos));\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> pii;//cost, v;\ntypedef struct edge{\n  int to, cost;\n}edge;\n\nint main(){\n  int n, m, k;\n  std::cin >> n >> m >> k;\n  vector<int> dp(n, 1e9);\n  vector<edge> g[n];\n  for (int i = 0; i < m; i++) {\n    int to, from, cost;\n    std::cin >> to >> from >> cost;\n    to--;from--;\n    g[from].push_back((edge){to, cost});\n    g[to].push_back((edge){from, cost});\n  }\n  priority_queue<pii, vector<pii>, greater<pii> > que;\n  for (int i = 0; i < k; i++) {\n    int a;\n    std::cin >> a;\n    a--;\n    que.push(pii(0, a));\n    dp[a] = 0;\n  }\n  while(not que.empty()){\n    int v = que.top().second;\n    int cost = que.top().first;\n    que.pop();\n    for (int i = 0; i < g[v].size(); i++) {\n      int nv = g[v][i].to;\n      if(dp[nv] > cost + g[v][i].cost){\n        dp[nv] = cost + g[v][i].cost;\n        que.push(pii(dp[nv], nv));\n      }\n    }\n  }\n  double ans = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      bool flag = false;\n      double cost;\n      for (int k = 0; k < g[i].size(); k++) {\n        if(g[i][k].to == j){\n          flag = true;\n          cost = g[i][k].cost;\n        }\n      }\n      if(flag == false)continue;\n      int diff = abs(dp[i] - dp[j]);\n      double l = (cost + diff)/2.0;\n      if(0 <= l and l < cost){\n        ans = max(ans, min(dp[i], dp[j]) + l);\n      }else{\n        ans = max(ans, min(dp[i], dp[j]) + cost);\n      }\n    }\n  }\n  std::cout << ceil(ans) << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nstruct edge { int to, cost; edge(int to, int cost) : to(to), cost(cost) {} };\ntypedef vector<edge> edges;\n\nedges G[3010];\nint d[100010];\n\nvoid dijkstra(int s)\n{\n    priority_queue<pii, vpii, greater<pii> > pq;\n    d[s] = 0;\n    pq.push(pii(0, s));\n    \n    while (pq.size()) {\n        pii p = pq.top(); pq.pop();\n\n        int v = p.scd;\n\n        if (d[v] < p.fst) continue;\n\n        for (edge &e : G[v]) {\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                pq.push(pii(d[e.to], e.to));\n            }\n        }\n    }\n}\n\nsigned main()\n{\n    omajinai;\n\n    int N, M, K; cin >> N >> M >> K;\n\n    fill_n(d, N + 1, inf);\n\n    rep(i, M) {\n        int a, b, l; cin >> a >> b >> l;\n        a--, b--;\n\n        G[a].PB(edge(b, l));\n        G[b].PB(edge(a, l));\n    }\n\n    rep(i, K) {\n        int s; cin >> s;\n        s--;\n        dijkstra(s);\n    }\n\n    int ma = -1;\n\n    rep(i, N) {\n        for (edge &e : G[i]) {\n            ma = max(ma, (int)(d[i] + round(1. * (d[e.to] - d[i] + e.cost) / 2)));\n        }\n    }\n\n    cout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define M 100000007\ntypedef pair<int,int> P;\n/*int main(){\n\tcout<<8979879<<endl;\n}*/\nint ri[3001][3001];\nint main(void){\n\tint n,m,k,\n\t\ti,j,\n\t\tmx,t,ans,\n\t\ta[100001],b[100001],l[100001],s[3000],\n\t\td[3001];\n\t\t\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\n\tcin>>n>>m>>k;\n\tfor(i=0;i<m;i++) cin>>a[i]>>b[i]>>l[i];\n\tfor(i=0;i<k;i++) cin>>s[i];\n//\tfor(i=0;i<k;i++) cout<<s[i]<<endl;\n\t\n\tfor(i=1;i<=n;i++) for(j=1;j<=n;j++) ri[i][j]=M;\n\tfor(i=0;i<m;i++) ri[a[i]][b[i]]=l[i],ri[b[i]][a[i]]=l[i];\n/*\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++)cout<<ri[i][j]<<' ';\n\t\tcout<<endl;\n\t}*/\n\t\n\tint leng[3001];\n\tfor(i=1;i<=n;i++) leng[i]=M;\n\tfor(i=0;i<k;i++){\n\t\tleng[s[i]]=0;\n\t\tque.push(P(0,s[i]));\n\t}\n\twhile(!que.empty()){\n\t\tP p=que.top();\n\t\tque.pop();\n\t\tint v=p.second;\n\t\tif(leng[v]<p.first) continue;\n\t\tfor(j=1;j<=n;j++){\n\t\t\tt=leng[v]+ri[v][j];\n//\t\t\tcout<<j<<' '<<leng[j]<<' '<<t<<endl;\n\t\t\tif(leng[j]>t){\n\t\t\t\tleng[j]=t;\n//\t\t\t\tcout<<leng[j]<<' '<<j<<endl;\n\t\t\t\tque.push(P(leng[j],j));\n\t\t\t}\n\t\t}\n\t}\n/*\tfor(i=1;i<=n;i++) cout<<leng[i]<<' ';\n\tcout<<endl;*/\n\tans=0;\n\tfor(i=1;i<=n;i++){\n\t\tint mx=0,y;\n\t\tdouble x;\n\t\tfor(j=1;j<=n;j++){\n\t\t\tif(ri[i][j]!=M){\n\t\t\t\t\tmx=max(mx,ri[i][j]+leng[j]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tmx=max(mx,ri[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tx=(double)mx/2;\n//\t\tcout<<x<<' '<<mx<<' '<<mi<<endl;\n\t\ty=round(x);\n\t\tans=max(ans,y);\n\t}\n\t\n\tcout<<ans<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 2002\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<P> G[N];\nbool num[N];\nint n,m,K;\n\ndouble dijkstra(){\n  int D[N];\n  for(int i=0;i<N;i++) D[i] = 1e9;\n  \n  vector<int>pre[N];\n  priority_queue<PP,vector<PP>,greater<PP> >Q;\n  \n  for(int i=0;i<N;i++)\n    if(num[i]) {\n      Q.push(PP(0,P(i,i)));\n      D[i] = 0;\n      pre[i].push_back(i);\n    }\n  \n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first;\n    int pos = t.second.first;\n    int start = t.second.second;\n\n    if(D[pos]<cost) continue;\n    pre[pos].push_back(start);\n    \n    for(int i=0;i<G[pos].size();i++){\n      int npos = G[pos][i].first;\n      int ncost = cost+G[pos][i].second;\n      if(D[npos]<ncost) continue;\n      Q.push(PP(ncost,P(npos,start)));\n      D[npos] = ncost;\n    }\n  }\n  \n\n  double res = 0;\n  for(int i=0;i<n;i++){\n    if(pre[i].size()>=2)res = max(res,(double)D[i]*2);\n    if(pre[i].size()>=2)continue;\n    \n    for(int j=0;j<G[i].size();i++){\n      int npos = G[i][j].first;\n      int ncost = G[i][j].second;\n      if(npos == pre[i][0]){\n\tif(abs(D[i]-D[npos])!=ncost) res = max(res,(D[i]+D[npos]+ncost)/2.0);\n      }\n      else res = max(res,(D[i]+D[npos]+ncost)/2.0);\n    }\n  }\n  return res;\n  \n}\n\nint main(){\n  \n  cin>>n>>m>>K;\n  for(int i=0,a,b,c;i<m;i++){\n    cin>>a>>b>>c;\n    G[a-1].push_back(P(b-1,c));\n    G[b-1].push_back(P(a-1,c));\n  }\n\n  for(int i=0,a;i<K;i++)cin>>a,num[a-1]=1;\n  printf(\"%.0f\\n\",dijkstra());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<map>\n#include<functional>\n#include<algorithm>\n#define INF (1<<29)\nusing namespace std;\n\nint pass[3001][3001];\nint saitan[3001], ans;\n\nint main(){\n  int n, m, k;\n  vector<int> neib[3001];\n  priority_queue<pair<int, int> , vector<pair<int, int> >,greater<pair<int, int> > > que;\n  scanf(\"%d%d%d\", &n, &m, &k);\n  for(int i = 0;i <= n;i++){\n    saitan[i] = INF;\n  }\n  for(int i = 0;i < m;i++){\n    int a, b, l;\n    scanf(\"%d%d%d\", &a, &b, &l);\n    neib[a].push_back(b);\n    neib[b].push_back(a);\n    pass[a][b] = pass[b][a] = l;\n  }\n  for(int i = 0;i < k;i++){\n    int s;\n    scanf(\"%d\", &s);\n    saitan[s] = 0;\n    que.push(make_pair(0, s));\n  }\n  while(!que.empty()){\n    pair<int, int> tmp = que.top(); que.pop();\n    if(saitan[tmp.second] < tmp.first)continue;\n    for(int i = 0;i < neib[tmp.second].size();i++){\n      int from = tmp.second;\n      int to = neib[tmp.second][i];\n      if(saitan[to] > saitan[from] + pass[from][to]){\n\tsaitan[to] = saitan[from] + pass[from][to];\n\tque.push(make_pair(saitan[to], to));\n      }    \n    }    \n  }\n  for(int i = 1;i <= n;i++){\n    ans = max(ans, saitan[i]);\n    for(int j = 0;j < neib[i].size();i++){\n      int to = neib[i][j];\n      if(abs(saitan[i] - saitan[to]) < pass[i][to]){\n\tans = max(ans,(1 + saitan[i] + saitan[to] + pass[i][to]) / 2);\n      }\n    }\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF (1<<29)\n\ntypedef pair<int, int> pii;\n\nint d[3000][3000]; // ???i, j????????¢\nint minCost[3000]; // ???i????????§???????????°??¢???????????§??????????????¢\nint shop[3000];\nvector<pii> g[3000]; // to, cost\nint n, m, k;\n\nint main() {\n\tcin >> n >> m >> k;\n\t\n\tfill(d[0], d[n], INF);\n\tfill(minCost, minCost + n, INF);\n\t\n\tREP(i, m) {\n\t\tint a, b, l;\n\t\tscanf(\"%d %d %d\", &a, &b, &l);\n\t\ta--; b--;\n\t\tg[a].push_back(pii(b, l));\n\t\tg[b].push_back(pii(a, l));\n\t}\n\t\n\tREP(i, k) {\n\t\tint pos;\n\t\tscanf(\"%d\", &pos);\n\t\tpos--;\n\t\tshop[i] = pos;\n\t}\n\t\n\t// i, j?????????????????¢???dijkstra??§?±???????\n\tREP(i, n) {\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > pq; // cost, pos\n\t\tpq.push(pii(0, i));\n\t\t\n\t\twhile (!pq.empty()) {\n\t\t\tpii now = pq.top(); pq.pop();\n\t\t\t\n\t\t\tint ncost = now.first;\n\t\t\tint npos = now.second;\n\t\t\t\n\t\t\tif (d[i][npos] <= ncost) continue;\n\t\t\td[i][npos] = ncost;\n\t\t\t\n\t\t\tREP(j, g[npos].size()) pq.push(pii(ncost + g[npos][j].second, g[npos][j].first)); \n\t\t}\n\t}\n\t\n\t// minCost????±???????\n\tREP(i, n) {\n\t\tint cost = INF;\n\t\tREP(j, k) cost = min(cost, d[i][shop[j]]);\n\t\tminCost[i] = cost;\n\t}\n\t\n\tint ans = 0;\n\tREP(i, n) REP(j, n) {\n\t\tans = max(ans, (minCost[i] + minCost[j] + d[i][j] + 1) / 2);\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long int;\nusing P = pair<int,int>;\nusing P3 = pair<ll,P>;\nusing PP = pair<P, P>;\nconstexpr int INF = 1<<30;\n\nbool solve(){\n    int n, m, k;\n    cin >> n >> m >> k;\n    vector<vector<P> > g(n);\n    for(int i=0;i<m;i++){\n        int a, b, l;\n        cin >> a >> b >> l;\n        a--; b--;\n        g[a].push_back(P(b,l));\n        g[b].push_back(P(a,l));\n    }\n    vector<int> d(n,INF);\n    priority_queue<P,vector<P>,greater<P> > que;\n    for(int i=0;i<k;i++){\n        int s;\n        cin >> s;\n        s--;\n        d[s] = 0;\n        que.push(P(0,s));\n    }\n    while(!que.empty()){\n        P p = que.top();\n        que.pop();\n        int v = p.second;\n        if(p.first > d[v]) continue;\n        for(auto e : g[v]){\n            int u = e.first, l = e.second;\n            if(d[u] > d[v] + l){\n                d[u] = d[v] + l;\n                que.push(P(d[u],u));\n            }\n        }\n    }\n    int ans = 0;\n    for(int i=0;i<n;i++){\n        for(auto e : g[i]){\n            int j = e.first, l = e.second;\n            ans = max(ans, int(round(double(d[i]+d[j]+l)/2)));\n        }\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<map>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define INF 1<<30\n\nstruct edge{\n  int to,cost;\n};\nstruct road{\n  int now,to,cost;\n};\ntypedef pair<int , int> P; //最短,場所\nint id[3333];\nvector<road> ro;\nvector<edge> cost[3333];\npriority_queue<P, vector<P> , greater<P> >que;\n\nint n,m,k;\nint res=-1;\n\nint main(void){\n  int h,t,c,s;\n  fill(id,id+3333,INF);\n  scanf(\"%d %d %d\",&n,&m,&k);\n  for(int i=0;i<m;i++){\n    scanf(\"%d %d %d\",&h,&t,&c);\n    edge temp={t,c};\n    road tamp={h,t,c};\n    ro.push_back(tamp);\n    cost[h].push_back(temp);\n    temp.to=h;\n    cost[t].push_back(temp);\n  }\n  for(int i=0;i<k;i++){\n    scanf(\"%d\",&s);\n    id[s]=0;\n    que.push(P(0,s));\n  }\n\n  while(!que.empty()){\n    P p=que.top();\n    que.pop();\n    int v=p.second;\n    if(id[v]<p.first)continue;\n    for(int i=0;i<cost[v].size();i++){\n      edge e=cost[v][i];\n      if(id[e.to]>id[v]+e.cost){\n\tid[e.to]=id[v]+e.cost;\n\tque.push(P(id[e.to],e.to));\n      }\n    }\n  }\n  for(int i=1;i<=n;i++)printf(\"::%d\\n\",id[i]);\n  for(int i=0;i<ro.size();i++){\n    road r=ro[i];\n    int z=id[r.now]-id[r.to];\n    z*=(z<0)?-1:1;\n    z+=r.cost;\n    z=(int)(((double)z/2)+0.5);\n    res=max(res,min(id[r.now]+z,id[r.to]+z));\n    /*\n      for(int j=0;j<=r.cost;j++){\n      int ti=l.;\n      res=max(res,min(id[r.now]+j,id[r.to]+r.cost-j));\n      }\n    */\n\n    /*\n      int co=(int)((double)r.cost/2+0.5);\n      res=max(res,min(id[r.now],id[r.to])+co);\n    */\n  }\n  printf(\"%d\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nstruct edge{\n\tint to;\n\tint cost;\n};\n\nconst int MAX_N = 3002;\n\nint n,m,K,d[MAX_N];\nvector<int> S;\nvector<edge> G[MAX_N];\n\nvoid dijkstra()\n{\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\trep(i,S.size()){\n\t\td[S[i]] = 0;\n\t\tque.push(P(0,S[i]));\n\t}\n\twhile(!que.empty()){\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\tvector<edge>::iterator it = G[v].begin();\n\t\twhile(it != G[v].end()){\n\t\t\tif(d[it->to] > d[v] + it->cost){\n\t\t\t\td[it->to] = d[v] + it->cost;\n\t\t\t\tque.push(P(d[it->to],it->to));\n\t\t\t}\n\t\t\tit++;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&K);\n\trep(i,m){\n\t\tint x,y,z;\n\t\tedge e1,e2;\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\te1.to = y-1,e1.cost = z;\n\t\tG[x-1].push_back(e1);\n\t\te2.to = x-1,e2.cost = z;\n\t\tG[y-1].push_back(e2);\n\t}\n\trep(i,K){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tS.push_back(x-1);\n\t}\n\tfill(d,d+n,INF);\n\tdijkstra();\n\tint ans=0;\n\trep(i,n){\n\t\trep(j,G[i].size()){\n\t\t\tif(d[i]>=d[G[i][j].to]){\n\t\t\t\tif(d[i]>=d[G[i][j].to]+G[i][j].cost){\n\t\t\t\t\tans = max(ans,d[i]);\n\t\t\t\t}else{\n\t\t\t\t\tans = max(ans,(d[i]+d[G[i][j].to]+G[i][j].cost+1)/2);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(d[G[i][j].to]>=d[i]+G[i][j].cost){\n\t\t\t\t\tans = max(ans,d[G[i][j].to]);\n\t\t\t\t}else{\n\t\t\t\t\tans = max(ans,(d[i]+d[G[i][j].to]+G[i][j].cost+1)/2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trep(i,n){\n\t\tcout << d[i] << \"\\n\";\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\nstruct edge{ int v,cost; };\n\nint main(){\n\tint n,m,k; scanf(\"%d%d%d\",&n,&m,&k);\n\tstatic vector<edge> G[3000];\n\trep(i,m){\n\t\tint u,v,cost; scanf(\"%d%d%d\",&u,&v,&cost); u--; v--;\n\t\tG[u].push_back((edge){v,cost});\n\t\tG[v].push_back((edge){u,cost});\n\t}\n\n\tstatic int d[1000];\n\trep(u,n) d[u]=INF;\n\tpriority_queue< pair<int,int> > Q;\n\trep(i,k){\n\t\tint u; scanf(\"%d\",&u); u--;\n\t\td[u]=0;\n\t\tQ.push(make_pair(0,u));\n\t}\n\twhile(!Q.empty()){\n\t\tint d_now=-Q.top().first,u=Q.top().second; Q.pop();\n\t\tif(d[u]<d_now) continue;\n\t\trep(i,G[u].size()){\n\t\t\tconst edge &e=G[u][i];\n\t\t\tif(d[e.v]>d[u]+e.cost){\n\t\t\t\td[e.v]=d[u]+e.cost;\n\t\t\t\tQ.push(make_pair(-d[e.v],e.v));\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans=0;\n\trep(u,n) rep(i,G[u].size()) {\n\t\tconst edge &e=G[u][i];\n\t\tans=max(ans,(d[u]+d[e.v]+e.cost+1)/2);\n\t}\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3002\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<P> G[N];\nbool num[N];\nint n,m,K;\n\ndouble dijkstra(){\n  int D[N];\n  for(int i=0;i<N;i++) D[i] = 1e9;\n  \n  set<int>pre[N];\n  priority_queue<PP,vector<PP>,greater<PP> >Q;\n  \n  for(int i=0;i<n;i++)if(num[i]) Q.push(PP(0,P(i,-1))),D[i] = 0;\n  \n  \n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first;\n    int pos = t.second.first;\n    int ppos = t.second.second;\n    \n    if(D[pos]<cost) continue;\n    pre[pos].insert(ppos);\n    \n    for(int i=0;i<G[pos].size();i++){\n      int npos = G[pos][i].first;\n      int ncost = cost+G[pos][i].second;\n      if(D[npos]<ncost) continue;\n      Q.push(PP(ncost,P(npos,pos)));\n      D[npos] = ncost;\n    }\n  }\n\n\n  double res = 0;\n  for(int i=0;i<n;i++){\n    res = max(res,D[i]/2.0);\n\n    for(int j=0;j<(int)G[i].size();j++){\n      int npos = G[i][j].first;\n      int ncost = G[i][j].second;\n      if((pre[i].size()==1&&pre[i].count(npos))||\n\t (pre[npos].size()==1&&pre[npos].count(i)))continue;\n      res = max(res,(D[i]+D[npos]+ncost)/2.0);\n    }\n  }\n  return res;\n   \n}\n \nint main(){\n  cin>>n>>m>>K;\n  for(int i=0,a,b,c;i<m;i++){\n    cin>>a>>b>>c;\n    G[a-1].push_back(P(b-1,c));\n    G[b-1].push_back(P(a-1,c));\n  }\n \n  for(int i=0,a;i<K;i++)cin>>a,num[a-1]=1;\n  printf(\"%d\\n\",(int)(dijkstra()+0.5));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define M 100000007\ntypedef pair<int,int> P;\n/*int main(){\n\tcout<<8979879<<endl;\n}*/\nint ri[3001][3001];\nint main(void){\n\tint n,m,k,\n\t\ti,j,\n\t\tmx,t,ans,\n\t\ta[100001],b[100001],l[100001],s[3000],\n\t\td[3001];\n\t\t\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\n\tcin>>n>>m>>k;\n\tfor(i=0;i<m;i++) cin>>a[i]>>b[i]>>l[i];\n\tfor(i=0;i<k;i++) cin>>s[i];\n//\tfor(i=0;i<k;i++) cout<<s[i]<<endl;\n\t\n\tfor(i=1;i<=n;i++) for(j=1;j<=n;j++) ri[i][j]=M;\n\tfor(i=0;i<m;i++) ri[a[i]][b[i]]=l[i],ri[b[i]][a[i]]=l[i];\n/*\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++)cout<<ri[i][j]<<' ';\n\t\tcout<<endl;\n\t}*/\n\t\n\tint leng[3001];\n\tfor(i=1;i<=n;i++) leng[i]=M;\n\tfor(i=0;i<k;i++){\n\t\tleng[s[i]]=0;\n\t\tque.push(P(0,s[i]));\n\t}\n\twhile(!que.empty()){\n\t\tP p=que.top();\n\t\tque.pop();\n\t\tint v=p.second;\n\t\tif(leng[v]<p.first) continue;\n\t\tfor(j=1;j<=n;j++){\n\t\t\tt=leng[v]+ri[v][j];\n//\t\t\tcout<<j<<' '<<leng[j]<<' '<<t<<endl;\n\t\t\tif(leng[j]>t){\n\t\t\t\tleng[j]=t;\n//\t\t\t\tcout<<leng[j]<<' '<<j<<endl;\n\t\t\t\tque.push(P(leng[j],j));\n\t\t\t}\n\t\t}\n\t}\n/*\tfor(i=1;i<=n;i++) cout<<leng[i]<<' ';\n\tcout<<endl;*/\n\tans=0;\n\tfor(i=1;i<=n;i++){\n\t\tint mx=0,y;\n\t\tdouble x;\n\t\tfor(j=1;j<=n;j++){\n\t\t\tif(ri[i][j]!=M){\n\t\t\t\tmx=max(mx,ri[i][j]+leng[j]);\n\t\t\t}\n\t\t}\n\t\tx=(double)mx/2;\n//\t\tcout<<x<<' '<<mx<<' '<<mi<<endl;\n\t\ty=round(x);\n\t\tans=max(ans,y);\n\t}\n\t\n\tcout<<ans<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <map>\n#include <functional>\n\nusing namespace std;\ntypedef pair<int,int> mp;\nint mins(int p,int q){\n  if(p==-1)return q;\n  else if(q==-1 || p<q)return p;\n  else return q;\n}\nint max(int p,int q){\n  if(p<q)return q;\n  else return p;\n}\n\nint md[3000][3000];\nint mm[3000];\nint dt[3000];\nbool ch[3000];\nint m,n,k;\n\nint main(void){\n  memset(md,-1,sizeof(md));\n  memset(dt,-1,sizeof(dt));\n  scanf(\"%d%d%d\",&n,&m,&k);\n  int i,j;\n  int a,b,c;\n  for(i=0;i<m;i++){\n    scanf(\"%d%d%d\",&a,&b,&c);\n    md[a-1][b-1]=c;\n    md[b-1][a-1]=c;\n  }\n  for(i=0;i<k;i++){\n    scanf(\"%d\",&a);\n    mm[i]=a-1;\n  }\n\n  int st,no,kyo,mk;\n  mp pa;\n  int ans=0;\n  for(i=0;i<k;i++){\n    st=mm[i];\n    priority_queue <mp> que;\n    memset(ch,false,sizeof(ch));\n    dt[st]=0;\n    ch[st]=true;\n    que.push(make_pair(0,st));\n    while(!que.empty()){\n      pa=que.top();\n      que.pop();\n      kyo=pa.first;\n      no=pa.second;\n      for(j=0;j<n;j++){\n\tif(md[no][j]!=-1 && !ch[j]){\n\t  mk=md[no][j];\n\t  dt[j]=mins(dt[j],kyo+mk);\n\t  que.push(make_pair(dt[j],j));\n\t}\n      }\n      ch[no]=true;\n    }\n  }\n  for(i=0;i<n;i++){\n    ans=max(ans,dt[i]);\n  }\n  for(i=0;i<n;i++){\n    for(j=i+1;j<n;j++){\n      if(md[i][j]!=-1){\n\tans=max(ans,(int)((dt[i]+dt[j]+md[i][j]+1)/2));\n      }\n    }\n  }\n\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ld = long double;\n\nconst int INF = 1e9;\n\nstruct edge {\n\tint to, cost;\n\tedge(int t, int c) : to(t), cost(c) {}\n\tbool operator<(const edge& that) const {\n\t\treturn cost > that.cost;\n\t}\n};\n\nusing edges = vector<edge>;\nusing graph = vector<edges>;\n\nint main()\n{\n\tint N, M, K;\n\tcin >> N >> M >> K;\n\tgraph G(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tint a, b, l;\n\t\tcin >> a >> b >> l; a--, b--;\n\t\tG[a].emplace_back(b, l);\n\t\tG[b].emplace_back(a, l);\n\t}\n\tvector<int> used(N);\n\tvector<int> d(N, INF);\n\tpriority_queue<edge> pq;\n\tfor (int i = 0; i < K; i++) {\n\t\tint s;\n\t\tcin >> s; s--;\n\t\td[s] = 0;\n\t\tpq.emplace(s, 0);\n\t}\n\twhile (!pq.empty()) {\n\t\tauto p = pq.top(); pq.pop();\n\t\tint v = p.to;\n\t\tif (used[v]) continue;\n\t\tused[v] = 1;\n\t\tfor (auto& e : G[v]) if (d[e.to] > d[v] + e.cost) {\n\t\t\td[e.to] = d[v] + e.cost;\n\t\t\tpq.emplace(e.to, d[v] + e.cost);\n\t\t}\n\t}\n\tld res = *max_element(d.begin(), d.end());\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (auto& e : G[i]) {\n\t\t\tif (abs(d[i] - d[e.to]) == e.cost) continue;\n\t\t\tld mi = min(d[i], d[e.to]), ma = max(d[i], d[e.to]), l = e.cost;\n\t\t\tres = max(res, ma + (l - (ma - mi)) / 2.0);\n\t\t}\n\t}\n\tcout << (int)round(res) << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<map>\n#include<functional>\n#include<algorithm>\n#define INF (1<<29)\nusing namespace std;\n\nint pass[3001][3001];\nint saitan[3001], ans;\n\nint main(){\n  int n, m, k;\n  vector<int> neib[3001];\n  priority_queue<pair<int, int> , vector<pair<int, int> >,greater<pair<int, int> > > que;\n  scanf(\"%d%d%d\", &n, &m, &k);\n  for(int i = 0;i <= n;i++){\n    saitan[i] = INF;\n  }\n  for(int i = 0;i < m;i++){\n    int a, b, l;\n    scanf(\"%d%d%d\", &a, &b, &l);\n    neib[a].push_back(b);\n    neib[b].push_back(a);\n    pass[a][b] = pass[b][a] = l;\n  }\n  for(int i = 0;i < k;i++){\n    int s;\n    scanf(\"%d\", &s);\n    saitan[s] = 0;\n    que.push(make_pair(0, s));\n  }\n  while(!que.empty()){\n    pair<int, int> tmp = que.top(); que.pop();\n    for(int i = 0;i < neib[tmp.second].size();i++){\n      int from = tmp.second;\n      int to = neib[tmp.second][i];\n      if(saitan[to] > saitan[from] + pass[from][to]){\n\tsaitan[to] = saitan[from] + pass[from][to];\n\tque.push(make_pair(saitan[to], to));\n      }    \n    }    \n  }\n  for(int i = 1;i <= n;i++){\n    ans = max(ans, saitan[i]);\n    for(int j = 0;j < neib[i].size();i++){\n      int to = neib[i][j];\n      if(abs(saitan[i] - saitan[to]) < pass[i][to]){\n\tans = max(ans,(1 + saitan[i] + saitan[to] + pass[i][to]) / 2);\n      }\n    }\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<functional>\n\nusing namespace std;\ntypedef pair<int,int> P;\nstruct edge{\n\tint t,c;\n};\n\nint n,m,k;\nvector<edge> G[100001];\nint dist[100001];\nint ff[100001],tt[100001],cc[100001];\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tfor(int i=0;i<m;i++){\n\t\tint f,t;\n\t\tedge e;\n\t\tscanf(\"%d%d%d\",&f,&t,&e.c);\n\t\tff[i]=f;\n\t\ttt[i]=t;\n\t\tcc[i]=e.c;\n\t\te.t=t;\n\t\tG[f].push_back(e);\n\t\te.t=f;\n\t\tG[t].push_back(e);\n\t}\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tfor(int i=0;i<k;i++){\n\t\tint t;\n\t\tscanf(\"%d\",&t);\n\t\tque.push(P(0,t));\n\t}\n\tfor(int i=0;i<=n;i++)dist[i]=100000000;\n\twhile(que.size()){\n\t\tP p=que.top();\n\t\tque.pop();\n\t\tint v=p.second;\n\t\tint c=p.first;\n\t\tif(dist[v]<c)continue;\n\t\tdist[v]=c;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tedge e=G[v][i];\n\t\t\tif(dist[e.t]>c+e.c){\n\t\t\t\tdist[e.t]=c+e.c;\n\t\t\t\tque.push(P(c+e.c,e.t));\n\t\t\t}\n\t\t}\n\t}\n\tint res=0;\n\tfor(int i=0;i<m;i++){\n\t\tint f=ff[i],t=tt[i],c=cc[i];\n\t\tif(dist[f]==dist[t])res=max(res,dist[f]+(c+1)/2);\n\t\telse{\n\t\t\tint mins=min(dist[f],dist[t]);\n\t\t\tint maxs=max(dist[f],dist[t]);\n\t\t\tc-=maxs-mins;\n\t\t\tif(c<=0)res=max(res,maxs);\n\t\t\telse{\n\t\t\t\tres=max(res,maxs+(c+1)/2);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nstruct edge { int to, cost; edge(int to, int cost) : to(to), cost(cost) {} edge() {} };\ntypedef vector<edge> edges;\n\nedges G[3010];\nint d[3010];\n\nvoid dijkstra(int s)\n{\n    priority_queue<pii, vpii, greater<pii> > pq;\n    d[s] = 0;\n    pq.push(pii(0, s));\n    \n    while (pq.size()) {\n        pii p = pq.top(); pq.pop();\n\n        int v = p.scd;\n\n        if (d[v] < p.fst) continue;\n\n        rep(i, G[v].size()) {\n            edge &e = G[v][i];\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                pq.push(pii(d[e.to], e.to));\n            }\n        }\n    }\n}\n\nsigned main()\n{\n    omajinai;\n\n    int N, M, K; cin >> N >> M >> K;\n\n    fill_n(d, N + 1, inf);\n\n    rep(i, M) {\n        int a, b, l; cin >> a >> b >> l;\n        a--, b--;\n\n        G[a].PB(edge(b, l));\n        G[b].PB(edge(a, l));\n    }\n\n    rep(i, K) {\n        int s; cin >> s;\n        s--;\n        dijkstra(s);\n    }\n\n    double ma = -1.0;\n\n    rep(i, N) {\n        rep(j, G[i].size()) {\n            edge &e = G[i][j];\n            ma = max(ma, (d[i] + d[e.to] + e.cost) / 2.0);\n        }\n    }\n\n    cout << round(ma) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<map>\n#include<algorithm>\n#define INF (1<<29)\nusing namespace std;\n\nint pass[3001][3001];\nint saitan[3001], ans;\n\nint main(){\n  int n, m, k;\n  vector<int> neib[3001];\n  priority_queue<pair<int, int> > que;\n  scanf(\"%d%d%d\", &n, &m, &k);\n  for(int i = 0;i <= n;i++){\n    saitan[i] = INF;\n  }\n  for(int i = 0;i < m;i++){\n    int a, b, l;\n    scanf(\"%d%d%d\", &a, &b, &l);\n    neib[a].push_back(b);\n    neib[b].push_back(a);\n    pass[a][b] = pass[b][a] = l;\n  }\n  for(int i = 0;i < k;i++){\n    int s;\n    scanf(\"%d\", &s);\n    saitan[s] = 0;\n    que.push(make_pair(0, s));\n  }\n  while(!que.empty()){\n    pair<int, int> tmp = que.top(); que.pop();\n    for(int i = 0;i < neib[tmp.second].size();i++){\n      int from = tmp.second;\n      int to = neib[tmp.second][i];\n      if(saitan[to] > saitan[from] + pass[from][to]){\n\tsaitan[to] = saitan[from] + pass[from][to];\n\tque.push(make_pair(saitan[to], to));\n      }    \n    }    \n  }\n  for(int i = 1;i <= n;i++){\n    for(int j = 0;j < neib[i].size();i++){\n      int to = neib[i][j];\n      if(abs(saitan[i] - saitan[to]) < pass[i][to]){\n\tans = max(ans,(1 + saitan[i] + saitan[to] + pass[i][to]) / 2);\n      }\n    }\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n#define INF (1<<27)\ntypedef pair<int,int> P;\nint d[3000];\nint c[3000][3000];\nint N,M,K;\nint main() {\n\tscanf(\"%d%d%d\",&N,&M,&K);\n\tfill(c[0],c[0]+3000*3000,INF);\n\tfor(int i=0;i<M;i++) {\n\t\tint a,b,l;\n\t\tscanf(\"%d%d%d\",&a,&b,&l);\n\t\tc[a-1][b-1]=c[b-1][a-1]=l;\n\t}\n\tfill(d,d+3000,INF);\n\tfor(int i=0;i<K;i++) {\n\t\tint s;\n\t\tscanf(\"%d\",&s);\n\t\td[s-1]=0;\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(P(0,s-1));\n\t\twhile(!que.empty()) {\n\t\t\tP p=que.top();que.pop();\n\t\t\tif(d[p.second]<p.first)continue;\n\t\t\tfor(int j=0;j<N;j++) {\n\t\t\t\tif(d[j]>(p.first+c[p.second][j])) {\n\t\t\t\t\td[j]=p.first+c[p.second][j];\n\t\t\t\t\tque.push(P(d[j],j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++) {\n\t\tif(c[i][j]==INF)continue;\n\t\tans=max(ans,(d[i]+d[j]+c[i][j]+1)/2);\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={1,0,-1,0,1,-1,-1,1};\nconst int dy[]={0,1,0,-1,1,1,-1,-1};\nconst int INF = 1<<30;\nconst int EPS = 1e-8;\n#define PB push_back\n#define mk make_pair\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int > Pii;\nclass edge{\n\tpublic:\n\tint to;\n\tint cost;\n\tedge(){}\n\tedge(int _to,int _cost){\n\t\tto = _to;\n\t\tcost = _cost;\n\t}\n\tbool operator<(const edge &a)const{\n\t\treturn cost>=a.cost;\n\t}\n};\nvector < edge > G[3002];\nint path[3002];\nint N,M,K;\nvoid dijkstra(int s){\n\tint d[3002];\n\tfill(d,d+N,INF);\n\tpriority_queue<edge> Q;\n\tQ.push(edge(s,0));\n\twhile(!Q.empty()){\n\t\tedge e = Q.top();\n\t\tQ.pop();\n\t\tif(d[e.to] < INF)continue;\n\t\td[e.to] = e.cost;\n\t\trep(i,G[e.to].size()){\n\t\t\tQ.push(edge(G[e.to][i].to,G[e.to][i].cost+e.cost));\n\t\t}\n\t}\n\trep(i,N){\n\t\tpath[i] = min(path[i],d[i]);\n\t}\n\treturn ;\n}\nint main(){\n\tscanf(\"%d%d%d\",&N,&M,&K);\n\tfill(path,path+N,INF);\n\trep(i,M){\n\t\tint a,b,c;\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\ta--;b--;\n\t\tG[a].PB(edge(b,c));\n\t\tG[b].PB(edge(a,c));\n\t}\n\trep(i,K){\n\t\tint tmp;\n\t\tscanf(\"%d\",&tmp);\n\t\tdijkstra(--tmp);\n\t}\n\tdouble ans = 0;\n\trep(i,N){\n\t\trep(j,G[i].size()){\n\t\t\tint d = path[G[i][j].to]-path[i];\n\t\t\tif(d<0.0)continue;\n\t\t\tdouble g = path[i]+d+(G[i][j].cost-d)/2.0;\n\t\t\tans = max(g,ans);\n\t\t}\n\t}\n\t/*\n\trep(i,N){\n\t\tprintf(\"[%d]:%d\\n\",i,path[i]);\n\t}\n\t*/\n\tprintf(\"%.0lf\",round(ans));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\nvector<P>edge[3005];\nll nearest[3005];\nll d[3005];\nint n,m,k;\nvoid dijkstra(int k)\n{\n\tfill(d,d+3005,1e12);\n\td[k]=0LL;\n\tpriority_queue<P,vector<P>,greater<P> >que;\n\tque.push(mp(d[k],k));\n\twhile(!que.empty())\n\t{\n\t\tP p=que.top(); que.pop();\n\t\tif(d[p.second]!=p.first) continue;\n\t\t\n\t\tfor(int i=0;i<edge[p.second].size();i++)\n\t\t{\n\t\t\tif(d[edge[p.second][i].first]>d[p.second]+edge[p.second][i].second)\n\t\t\t{\n\t\t\t\td[edge[p.second][i].first]=d[p.second]+edge[p.second][i].second;\n\t\t\t\tque.push(mp(d[edge[p.second][i].first],edge[p.second][i].first));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tnearest[i]=min(nearest[i],d[i]);\n\t}\n}\nint main(){\n\tscanf(\"%d %d %d\",&n,&m,&k);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tll a,b,c; scanf(\"%lld %lld %lld\",&a,&b,&c);\n\t\tedge[a].pb(mp(b,2*c));\n\t\tedge[b].pb(mp(a,2*c));\n\t}\n\tfill(nearest,nearest+3005,1e12);\n\t\n\tfor(int i=0;i<k;i++)\n\t{\n\t\tint point;\n\t\tscanf(\"%d\",&point);\n\t\tdijkstra(point);\n\t}\n\tll ret=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<edge[i].size();j++)\n\t\t{\n\t\t\tret=max(ret,(nearest[i]+nearest[edge[i][j].first]+edge[i][j].second)/2);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",(ret+1)/2);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\nusing namespace std;\n\nvector<int>x[4000];\nlong long n,m,a,b,c,k,G;\nlong long s[4000],d[4000];\nlong long X[4000];\ndouble maxn;int res;\n\nint main(){\n\tmemset(X,63,sizeof(X));\n\tcin>>n>>m>>k;\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>a>>b>>c;\n\t\tx[a].push_back(b*1000000+c);\n\t\tx[b].push_back(a*1000000+c);\n\t}\n\tfor(int i=0;i<k;i++){\n\t\tcin>>a;\n\t\ts[a]=1;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(s[i]==1){\n\t\t\tmemset(d,63,sizeof(d));\n\t\t\td[i]=0;\n\t\t\tif(n<500){G=n;}\n\t\t\telse{G=max(20,(n+k)/k+10);}\n\t\t\tfor(int h=1;h<=G;h++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tif(d[j]<1000000000){\n\t\t\t\t\t\tfor(int k=0;k<x[j].size();k++){\n\t\t\t\t\t\t\td[x[j][k]/1000000]=min(d[x[j][k]/1000000],d[j]+x[j][k]%1000000);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tX[j]=min(X[j],d[j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tmaxn=max((long long)maxn,X[i]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<x[i].size();j++){\n\t\t\tif(abs(X[i]-X[x[i][j]/1000000])<x[i][j]%1000000){\n\t\t\t\ta=x[i][j]%1000000-abs(X[i]-X[x[i][j]/1000000]);\n\t\t\t\tmaxn=max(maxn,(double)(max(X[i],X[(int)(x[i][j]/1000000)])+1.0*a/2.0));\n\t\t\t}\n\t\t}\n\t}\n\tres=(1.0*maxn+0.99999999);\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint main(void) {\n\tll n, m, k;\n\tcin>>n>>m>>k;\n\tvector<vector<P> > l(n);\n\tREP(i, m) {\n\t\tll a, b, c;\n\t\tcin>>a>>b>>c;\n\t\t--a;\n\t\t--b;\n\t\tl[a].pb(P(b, c));\n\t\tl[b].pb(P(a, c));\n\t}\n\tvector<ll> shop(k);\n\tREP(i, k) {\n\t\tll gomi;\n\t\tcin>>gomi;\n\t\t--gomi;\n\t\tshop[i] = gomi;\n\t}\n\tpriority_queue<P> que;\n\tvector<ll> dir(n, INF * INF);\n\tREP(i, k) {\n\t\tque.push(P(0, shop[i]));\n\t\tdir[shop[i]] = 0;\n\t}\n\twhile(!que.empty()) {\n\t\tP np = que.top();\n\t\tque.pop();\n\t\tif(dir[np.second] != np.first) continue;\n\t\tREP(i, l[np.second].size()) {\n\t\t\tif(dir[l[np.second][i].first] > dir[np.second] + l[np.second][i].second) {\n\t\t\t\tdir[l[np.second][i].first] = dir[np.second] + l[np.second][i].second;\n\t\t\t\tque.push(P(dir[l[np.second][i].first], l[np.second][i].first));\n\t\t\t}\n\t\t}\n\t}\n\tll res = 0;\n\tREP(i, n) {\n\t\tREP(j, l[i].size()) {\n\t\t\tll k = (ll)(double(dir[l[i][j].first] - dir[i] + l[i][j].second) / 2 + 0.5);\n\t\t\tres = max(res, dir[i] + k);\n\t\t}\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip\t;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1<<30;\nclass DIJ{\n\tpublic:\n\tstruct edge{\n\t\tint to,cost;\n\t};\n\tvector<vector<edge> >G;\n\tint n;\n\tvi d;//distance\n\tDIJ(int size){\n\t\tn=size;\n\t\tG=vector<vector<edge> >(n);\n\t\td=vi(n,inf);\n\t}\n\tvoid add_edge(int a,int b,int c){\n\t\tedge e={b,c},ee={a,c};\n\t\tG[a].pb(e);\n\t\tG[b].pb(ee);\n\t}\n\tvoid dij(int s){\n\t\td[s]=0;\n\t\tpriority_queue<pii>q;\n\t\tq.push(pii(0,s));\n\t\twhile(!q.empty()){\n\t\t\tpii p=q.top();\n\t\t\tq.pop();\n\t\t\tint pos=p.second,cost=-p.first;\n\t\t\tif(cost>d[pos])continue;\n\t\t\trep(i,G[pos].size()){\n\t\t\t\tedge e=G[pos][i];\n\t\t\t\tint to=e.to;\n\t\t\t\tint nowcost=cost+e.cost;\n\t\t\t\tif(nowcost<d[to]){\n\t\t\t\t\td[to]=nowcost;\n\t\t\t\t\tq.push(pii(-d[to],to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\nint main(){\n\tint n,m,s;\n\tscanf(\"%d%d%d\",&n,&m,&s);\n\tDIJ dij(n);\n\twhile(m--){\n\t\tint a,b,c;\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\ta--;b--;\n\t\tdij.add_edge(a,b,c);\n\t}\n\twhile(s--){\n\t\tint a;\n\t\tscanf(\"%d\",&a);\n\t\ta--;\n\t\tdij.dij(a);\n\t}\n\tint out=0;\n\trep(i,n)rep(j,dij.G[i].size()){\n\t\tint a=dij.d[i],b=dij.d[dij.G[i][j].to],c=dij.G[i][j].cost;\n\t\tout=max(out,(int)(0.5+(a+b+c)/2.));\n\t}\n\tcout<<out<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <utility>\nusing namespace std;\ntypedef pair<int, int> pii;\nconst int inf = 1e9;\nconst double EPS = 1e-8;\n\nint main(){\n    int n,m,k;\n    cin >> n >> m >> k;\n    vector<vector<pii>> adj(n);\n    for(int i=0; i<m; i++){\n        int a,b,c;\n        cin >> a >> b >> c;\n        a--; b--;\n        adj[a].emplace_back(b, c);\n        adj[b].emplace_back(a, c);\n    }\n    vector<int> s(k);\n    for(int i=0; i<k; i++){\n        cin >> s[i];\n        s[i]--;\n    }\n\n    priority_queue<pii> wait;\n    vector<int> mincost(n, inf);\n    for(int i: s){\n        mincost[i] = 0;\n        wait.push(pii(0, i));\n    }\n    while(!wait.empty()){\n        int cost = -wait.top().first;\n        int pos = wait.top().second;\n        wait.pop();\n        if(cost > mincost[pos]) continue;\n        for(auto next: adj[pos]){\n            int npos = next.first;\n            int ncost = next.second +cost;\n            if(ncost < mincost[npos]){\n                mincost[npos] = ncost;\n                wait.push(pii(-ncost, npos));\n            }\n        }\n    }\n    int ans = 0;\n    for(int i=0; i<n; i++){\n        for(auto p: adj[i]){\n            int j = p.first;\n            int d = p.second;\n            int diff = abs(mincost[i] -mincost[j]);\n            if(diff == d){\n                ans = max(ans, max(mincost[i], mincost[j]));\n            }else{\n                ans = max(ans, max(mincost[i], mincost[j]) +(d-diff+1)/2);\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <map>\n#include <vector>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define IREP(it,array) for(vector<int>::iterator it=array.begin(); it!=array.end(); ++it)\n#define SREP(it,array) for(vector<string>::iterator it=array.begin(); it!=array.end(); ++it)\n\n#define MP       make_pair\n#define PB       push_back\n#define ALL(x)   (x).begin(),(x).end()\n\nconst int INF = 1<<29;\nconst double EPS = 1e-9;\ndouble zero(double d){\n  return d < EPS ? 0.0 : d;\n}\n\ntypedef long long LL;\ntypedef pair<int,int> P;\n\n\nint main()\n{\n  cout.setf(ios::fixed, ios::floatfield);\n  cout.precision(7);\n\n  int N,M,K;\n  cin >>N>>M>>K;\n\n  int cost[N+1][N+1];\n  REP(i,N+1){\n    fill(cost[i], cost[i]+N+1, INF);\n    cost[i][i] = 0;\n  }\n  int d[N+1];\n  fill(d,d+N+1,INF);\n\n  priority_queue<P, vector<P>, greater<P> > pque;\n\n  REP(_t,M){\n    int a,b,l;\n    cin >>a>>b>>l;\n    cost[a][b] = cost[b][a] = l;\n  }\n\n  REP(_t,K){\n    int a;\n    cin >> a;\n    pque.push( P(0,a) );\n    d[a] = 0;\n  }\n\n  // dijkstra\n  while( ! pque.empty() ){\n    P p = pque.top(); pque.pop();\n    int v = p.second;\n    if( d[v] < p.first )\n      continue;\n\n    REP(i, N+1){\n      if( d[i] > d[v] + cost[v][i] ){\n\td[i] = d[v]+cost[v][i];\n\tpque.push( P(d[i],i) );\n      }\n    }\n  }\n\n\n  int res = 0;\n  REP(i, N+1){\n    REP(j, N+1){\n      if( d[i] != INF){\n\tres = max( res, d[i] );\n\tif( cost[i][j] != INF ){\n\t  int val = (double)(d[i]+cost[i][j]+d[j])/2+0.5;\n\t  res = max( res, val );\n\t}\n      }\n    }\n  }\n\n  cout << res << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nconst int INF = 1e9;\nconst int MAX_N = 3010, MAX_E = 10000;\nint n, m; //????????° ???????????¬??°\nvector<pair<int, int> > G[MAX_N];//??°???????????¨?????£??\\????????? fi:to se:cost\nint d[MAX_N]; //s?????????????????????\ntypedef pair<int, int> P;//first??????????????¢,second??????????????????\nint k; vector<int> shop;//???????¨????\n\nvoid dijkstra(void){\n\tpriority_queue<P, vector<P>, greater<P> > que;//first????°?????????????\n    rep(i, n)d[i] = INF;//?????????\n    \n    //k????????????????????°????????????\n    for(auto i : shop){\n    \td[i] = 0;\n    \tque.push(make_pair(0, i));\n    }\n  \n    while(!que.empty()){\n       \tauto p = que.top(); que.pop();\n       \tint v = p.second;\n       \tif(d[v] < p.first) continue;\n       \tfor(auto e : G[v]){//e.fi:??£??\\??????????????????????????? e.se:?????????????????§????????????\n       \t\tif(d[e.first] > d[v] + e.second){//???????????¢?????´??°???????????¨???\n       \t\t\td[e.first] = d[v] + e.second;\n       \t\t\tque.push(make_pair(d[e.first], e.first));\n       \t\t}\n       \t}\n    }\n}\n\nint main(void){\n    cin >> n >> m >> k;\n    rep(i, m){\n        int a, b, l; cin >> a >> b >> l;\n        a--; b--;\n       \tG[a].push_back(make_pair(b, l)); G[b].push_back(make_pair(a, l));\n    }\n    rep(i, k){\n    \tint s; cin >> s; s--;\n    \tshop.push_back(s);\n    }\n    dijkstra();//????????????????????????????°?????????????\n    //?????????????????¶????????????????°?????????????\n    int ans = 0;\n    //??????????????????????????¢????????¨???????????????????????¶???????????´?????????????????????????????¢?????????\n    // rep(i, n) printf(\"%d\\n\", d[i]);\n   \tfor (int x = 0; x < n; ++x){\n   \t\tfor(auto y : G[x]){\n   \t\t\tif(d[x] == 0 || d[y.first] == 0) continue;\n   \t\t\tint tmp = round((d[x] + d[y.first] + y.second + 1) / 2);//+1????????¨?????\\??¨\n   \t\t\tans = max(tmp, ans);\n   \t\t}\n   \t}\n   \tcout << ans << endl;\n   \treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdint>\n\nusing namespace std;\n\n#define MAX_N 3000\n#define MAX_M 100000\n#define UNDEF UINT16_MAX\n//I[A][B]\n\nuint16_t N,M,K,I[MAX_M*2][3],D[MAX_N],LS[MAX_N];\nfloat RC[MAX_M];\nbool S[MAX_N];\nuint16_t dist[MAX_N];\nbool decided[MAX_N],updated;\n\nuint16_t min(uint16_t a,uint16_t b)\n{\n\tif(a < b)\n\t\treturn a;\n\telse\n\t\treturn b;\n}\n\nfloat max(float a,float b)\n{\n\tif(a > b)\n\t\treturn a;\n\telse\n\t\treturn b;\n}\n\nint main(void)\n{\n\tcin >> N >> M >> K;\n\tint a,b,n;\n\tfor(int i = 0;i < MAX_N;i++)\n\t{\n\t\tD[i] = UNDEF;\n\t\tS[i] = false;\n\t\tLS[i] = UNDEF;\n\t\tI[i*2][0] = UNDEF;\n\t\tI[i*2][1] = UNDEF;\n\t\tI[i*2][2] = UNDEF;\n\t\tI[(i*2)+1][0] = UNDEF;\n\t\tI[(i*2)+1][1] = UNDEF;\n\t\tI[(i*2)+1][2] = UNDEF;\n\t}\n\tfor(int i = 0;i < MAX_M;i++)\n\t\tRC[i] = UNDEF;\n\tfor(int i = 0;i < M;i++)\n\t{\n\t\tcin >> a >> b >> n;\n\t\ta--;\n\t\tb--;\n\t\tI[(i*2)][0] = a;\n\t\tI[(i*2)][1] = b;\n\t\tI[(i*2)][2] = n;\n\t\tI[(i*2)+1][0] = b;\n\t\tI[(i*2)+1][1] = a;\n\t\tI[(i*2)+1][2] = n;\n\t}\n\tfor(int i = 0;i < K;i++)\n\t{\n\t\tcin >> n;\n\t\tn--;\n\t\tS[n] = true;\n\t\tLS[i] = n;\n\t}\n\tfor(int i = 0;i < K;i++)\n\t{\n\t\tfor(int ii = 0;ii < MAX_N;ii++)\n\t\t{\n\t\t\tdist[ii] = UNDEF;\n\t\t\tdecided[ii] = false;\n\t\t}\n\t\tdist[LS[i]] = 0;\n\t\twhile(true)\n\t\t{\n\t\t\tupdated = false;\n\t\t\tint minn = UNDEF;\n\t\t\tint mini = -1;\n\t\t\tfor(int ii = 0;ii < N;ii++)\n\t\t\t{\n\t\t\t\tif(minn >= dist[ii] && !decided[ii])\n\t\t\t\t{\n\t\t\t\t\tmini = ii;\n\t\t\t\t\tupdated = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdecided[mini] = true;\n\t\t\tif(updated)\n\t\t\t{\n\t\t\t\tfor(int ii = 0;ii < M*2;ii++)\n\t\t\t\t{\n\t\t\t\t\tif(I[ii][0] == mini && I[ii][2] + dist[I[ii][0]] < dist[I[ii][1]])\n\t\t\t\t\t{\n\t\t\t\t\t\tdist[I[ii][1]] = I[ii][2] + dist[I[ii][0]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int ii = 0;ii < N;ii++)\n\t\t{\n\t\t\tD[ii] = min(D[ii],dist[ii]);\n\t\t}\n\t}\n\tfor(int i = 0;i < M;i++)\n\t{\n\t\tRC[i] = (float)(D[I[i*2][0]] + D[I[i*2][1]] + I[i*2][2]) / 2;\n\t}\n\tfloat result = 0;\n\tfor(int i = 0;i < N;i++)\n\t\tresult = max((float)D[i],result);\n\tfor(int i = 0;i < M;i++)\n\t\tresult = max(RC[i],result);\n\tcout << result << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<functional>\nusing namespace std;\ntypedef pair<int,int>P;\nint main()\n{\n\tint n,m,k,a,b,l,s;\n\tvector<P>v[3001];\n\tfor(scanf(\"%d%d%d\",&n,&m,&k);m--;)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&l);\n\t\tv[a].push_back(P(l,b));\n\t\tv[b].push_back(P(l,a));\n\t}\n\tpriority_queue<P,vector<P>,greater<P> >q;\n\twhile(k--)\n\t{\n\t\tscanf(\"%d\",&s);\n\t\tq.push(P(0,s));\n\t}\n\tint d[3001];\n\tfill(d,d+3001,(int)1e9);\n\twhile(!q.empty())\n\t{\n\t\tP p(q.top());\n\t\tq.pop();\n\t\tif(d[p.second]<=p.first)\n\t\t\tcontinue;\n\t\td[p.second]=p.first;\n\t\tvector<P>&r=v[p.second];\n\t\tfor(int i=0;i<r.size();++i)\n\t\t\tq.push(P(p.first+r[i].first,r[i].second));\n\t}\n\tint i,j;\n\tdouble r=0;\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tfor(j=0;j<v[i].size();++j)\n\t\t{\n\t\t\ta=d[i];\n\t\t\tb=d[v[i][j].second];\n\t\t\tl=v[i][j].first;\n\t\t\tint diff=max(a,b)-min(a,b);\n\t\t\tif(diff>l)\n\t\t\t\tr=max(r,(double)max(a,b));\n\t\t\telse\n\t\t\t\tr=max(r,max(a,b)+(l-diff)/2.);\n\t\t}\n\t}\n\tprintf(\"%.0f\\n\",r+1e-8);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nclass st{\npublic:\n  int now,cost;\n  bool operator<(const st a)const{\n    return cost > a.cost;\n  }\n};\n\nstruct Edge{int f,t,c;};\n\nconst int N = 3000;\nconst int inf = (1<<25);\nint cost[N];\nvector<Edge> edge[N];\nvoid dijkstra(int n,vector<int> s){\n  priority_queue<st> Q;\n  rep(i,n)cost[i] = inf;\n  rep(i,s.size()){\n    cost[s[i]] = 0;\n    Q.push((st){s[i],0});\n  }\n  while(!Q.empty()){\n    st now = Q.top();Q.pop();\n    if (cost[now.now] != now.cost)continue;\n    rep(i,edge[now.now].size()){\n      int next = edge[now.now][i].t;\n      int nec = now.cost + edge[now.now][i].c;\n      if (cost[next] > nec){\n\tcost[next] = nec;\n\tQ.push((st){next,nec});\n      }\n    }\n  }\n}\n\nint solve(int n,vector<int> &s){\n  dijkstra(n,s);\n  double ans = 0;\n  rep(i,n)ans = max(ans,(double)cost[i]);\n  rep(i,n){\n    rep(j,edge[i].size()){\n      int f = edge[i][j].f,t=edge[i][j].t,l=edge[i][j].c;\n      int a = max(cost[f],cost[t]),b=min(cost[f],cost[t]);\n      if (b+l <= a)continue;\n      double tmp = ((a-b)+l)*0.5;\n      //cout << f <<\" \" <<t <<\" \" << tmp << endl;\n      ans = max(ans,min(cost[f]+tmp,cost[t]+tmp));\n    }\n  }\n  //cout << ans << endl;\n  printf(\"%d\\n\",(int)(ans+0.5));\n}\n\nmain(){\n  int n,m,q;\n  while(cin>>n>>m>>q){\n    vector<int> s(q);\n    rep(i,n)edge[i].clear();\n    rep(i,m){\n      int f,t,c;\n      cin>>f>>t>>c;\n      f--;t--;\n      edge[f].push_back((Edge){f,t,c});\n      edge[t].push_back((Edge){t,f,c});\n    }\n    rep(i,q)cin>>s[i],s[i]--;\n    solve(n,s);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\ntypedef long long ll;\ntypedef pair<double, int> P;\n\n/* struct P {\n\tint x, y, n;\n\tP(int n, int x, int y):n(n), x(x), y(y){}\n\tP(){}\n}; */\n\n\n/** Problem0562 : Shopping in JOI Kingdom **/\n\n// Node 0...2999 : Given\n//      3000...  : Add\nconst int MAX_V = 1e5+100;\nconst int BASE = 100;\n\nstruct edge{\n\tint to; double cost;\n\tedge(int t, int c):to(t), cost(c){}\n};\nvector<edge> G[MAX_V];\nint d[MAX_V];\nbool used[MAX_V];\n\nint main()\n{\n\tint N, M, K; cin>>N>>M>>K;\n\trep(i, M) {\n\t\tint a, b; double c;\n\t\tcin>>a>>b>>c;\n\t\ta--, b--;\n\t\t\n\t\tG[a].push_back(edge(b, c));\n\t\tG[b].push_back(edge(a, c));\n\t}\n\t\n\tpriority_queue<P, vector<P>, greater<P> > Q;\n\tfill(d, d+N, INF);\n\t\n\trep(i, K) {\n\t\tint s; cin>>s; s--;\n\t\td[s] = 0;\n\t\tQ.push(P(0, s));\n\t}\n\t\n\twhile (Q.size()) {\n\t\tP p = Q.top(); Q.pop();\n\t\tint v = p.second;\n\t\t\n\t\tif (d[v] < p.first) continue;\n\t\tfor (int i=0; i<G[v].size(); i++) {\n\t\t\tedge e = G[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tQ.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdouble ans = 0;\n\tfor (int i=0; i<N; i++) {\n\t\tfor (int v=0; v<G[i].size(); v++) {\n\t\t\tedge e = G[i][v];\n\t\t\tans = max(ans, (d[i]+d[e.to]+e.cost)/2.0);\n\t\t}\n\t}\n\t\n\tcout << round(ans) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//27\n#include<iostream>\n#include<algorithm>\n#include<cstdlib>\n\nusing namespace std;\n\nint main(){\n  int n,m,k;\n  cin>>n>>m>>k;\n  int t[3001];\n  fill(t,t+3001,1<<29);\n  int a[100000][2],l[100000];\n  for(int i=0;i<m;i++){\n    cin>>a[i][0]>>a[i][1]>>l[i];\n  }\n  for(int i=0;i<k;i++){\n    int s;\n    cin>>s;\n    t[s]=0;\n  }\n  for(int o=0;o<n;o++){\n    for(int i=0;i<m;i++){\n      for(int j=0;j<2;j++){\n\tt[a[i][j]]=min(t[a[i][j]],t[a[i][!j]]+l[i]);\n      }\n    }\n  }\n  int ll=0;\n  for(int i=0;i<m;i++){\n    ll=max(ll,(l[i]-abs(t[a[i][0]]-t[a[i][1]])+1)/2+max(t[a[i][0]],t[a[i][1]]));\n  }\n  cout<<ll<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//#define DEBUG\n#define INF 1000000000\n#define REP(i,n) for(int i=1;i<=n;i++)\nstruct E {int to,cost;};\nint n,m,k;\nvector<E> G[3002];\nvector<int> S;\nint D[3002];\n\nint main(){\n  cin>>n>>m>>k;\n  REP(i,m){\n    int a,b,l;\n    cin>>a>>b>>l;\n    G[a].push_back({b,l});\n    G[b].push_back({a,l});\n  }\n  REP(i,n)D[i]=INF;\n  REP(i,k){\n    int s;\n    cin>>s;\n    S.push_back(s);\n    D[s]=0;\n  }\n  for(int s : S){\n    queue<int> que;\n    que.push(s);\n    while(!que.empty()){\n      int t=que.front();que.pop();\n      for(E e : G[t]){\n        if(D[e.to]>D[t]+e.cost){\n          D[e.to]=D[t]+e.cost;\n          que.push(e.to);\n        }\n      }\n    }\n  }\n  int ans=0;\n  REP(i,n){\n    for(E e : G[i]){\n      int d=min(D[i],D[e.cost]);\n      d+=e.cost-(e.cost/2);\n      ans=max(ans,d);\n    }\n  }\n  cout<<ans<<endl;\n  #ifdef DEBUG\n  REP(i,n){\n    cout<<D[i]<<\" \";\n  }\n  #endif\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<functional>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<cmath>\nusing namespace std;\npriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>Q;\nint n, m, k, a[100000], b[100000], c[100000], r[10000], dist[10000];\nvector<pair<int, int>>x[10000];\nvoid dijkstra() {\n\tfor (int i = 1; i <= n; i++) dist[i] = 999999999;\n\tfor (int i = 0; i < k; i++) { dist[r[i]] = 0; Q.push(make_pair(0, r[i])); }\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.top().first, a2 = Q.top().second; Q.pop();\n\t\tfor (int i = 0; i < x[a2].size(); i++) {\n\t\t\tif (dist[x[a2][i].first] > a1 + x[a2][i].second) {\n\t\t\t\tdist[x[a2][i].first] = a1 + x[a2][i].second;\n\t\t\t\tQ.push(make_pair(dist[x[a2][i].first], x[a2][i].first));\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tcin >> n >> m >> k;\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> a[i] >> b[i] >> c[i]; \n\t\tx[a[i]].push_back(make_pair(b[i], c[i]));\n\t\tx[b[i]].push_back(make_pair(a[i], c[i]));\n\t}\n\tfor (int i = 0; i < k; i++)cin >> r[i];\n\tdijkstra();\n\tint maxn = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tint R1 = min(dist[a[i]], dist[b[i]]);\n\t\tint R2 = (c[i] + abs(dist[a[i]] - dist[b[i]]) + 1) / 2;\n\t\tmaxn = max(maxn, R1 + R2);\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<functional>\n#include<vector>\n#include<algorithm>\n#define int long long\n#define P pair<int,int>//cost to\nusing namespace std;\n\nint kiriage(int a) {\n\tif (a&1)return a / 2 + 1;\n\treturn a / 2;\n}\nvector<P>rinsetu[3000];\nint mincost[3000];\nsigned main() {\n\tint a, b, c; cin >> a >> b >> c;\n\tfill(mincost, mincost + a, LLONG_MAX/3);\n\tfor (int d = 0; d < b; d++) {\n\t\tint e, f, g; scanf(\"%d%d%d\", &e, &f, &g); e--; f--;\n\t\trinsetu[e].push_back(P(g, f));\n\t\trinsetu[f].push_back(P(g, e));\n\t}\n\tpriority_queue<P, vector<P>, greater<P>>Q;\n\tfor (int h = 0; h < c; h++) {\n\t\tint i; scanf(\"%d\", &i); i--;\n\t\tmincost[i] = 0;\n\t\tQ.push(P(0,i));\n\t}\n\twhile (Q.size()) {\n\t\tP o = Q.top(); Q.pop();\n\t\tif (mincost[o.second] < o.first)continue;\n\t\tfor (P t : rinsetu[o.second]) {\n\t\t\tif (o.first + t.first < mincost[t.second]) {\n\t\t\t\tmincost[t.second] = o.first + t.first;\n\t\t\t\tQ.push(P(mincost[t.second],t.second));\n\t\t\t}\n\t\t}\n\t}\n\tint MAX = 0;\n\tfor (int x = 0; x < a; x++) {\n\t\tfor (P y : rinsetu[x]) {\n\t\t\ty.first -= abs(mincost[x] - mincost[y.second]);\n\t\t\tMAX = max(MAX, max(mincost[x], mincost[y.second]) + kiriage(y.first));\n\t\t}\n\t}\n\tcout << MAX << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nstruct S{\n\tint p,q;\n\tS(int p,int q):p(p),q(q){\n\t}\n\tbool operator<(const S& a)const{\n\t\treturn p>a.p;\n\t}\n};\nint main(){\n\tint i,j;\n\tint n,m,l;;\n\tscanf(\"%d%d%d\",&n,&m,&l);\n\tvector<pair<int,int> > a[3000];\n\tfor(i=0;i<m;++i){\n\t\tint p,q,r;\n\t\tscanf(\"%d%d%d\",&p,&q,&r);\n\t\t--p;\n\t\t--q;\n\t\ta[p].push_back(make_pair(q,r));\n\t\ta[q].push_back(make_pair(p,r));\n\t}\n\tint b[3000];\n\tmemset(b,0x7f,sizeof(b));\n\tpriority_queue<S> c;\n\tfor(i=0;i<l;++i){\n\t\tint p;\n\t\tscanf(\"%d\",&p);\n\t\t--p;\n\t\tb[p]=0;\n\t\tc.push(S(0,p));\n\t}\n\twhile(!c.empty()){\n\t\tS p=c.top();\n\t\tc.pop();\n\t\tfor(i=0;i<(int)a[p.q].size();++i){\n\t\t\tif(b[a[p.q][i].first]<=p.p+a[p.q][i].second)\n\t\t\t\tcontinue;\n\t\t\tb[a[p.q][i].first]=p.p+a[p.q][i].second;\n\t\t\tc.push(S(p.p+a[p.q][i].second,a[p.q][i].first));\n\t\t}\n\t}\n\tint mx=0;\n\tfor(i=0;i<n;++i)\n\t\tfor(j=0;j<(int)a[i].size();++j)\n\t\t\tmx=max(mx,max(b[i],b[a[i][j].first])+(a[i][j].second-abs(b[i]-b[a[i][j].first])+1)/2);\n\tprintf(\"%d\\n\",mx);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int inf = (int)1e9;\n\nint main()\n{\n\tint n, m, k;\n\tint ans = 0;\n\tvector<int> dist;\n\tvector<vector<pair<int, int> > > graph;\n\tvector<pair<pair<int, int>, int> > edge;\n\t\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tdist.resize(n, inf);\n\tgraph.resize(n);\n\tedge.reserve(m);\n\tfor(int i = 0; i < m; ++i) {\n\t\tint a, b, l;\n\t\tscanf(\"%d%d%d\", &a, &b, &l);\n\t\ta -= 1, b -= 1;\n\t\tedge.push_back(make_pair(make_pair(a, b), l));\n\t\tgraph[a].push_back(make_pair(b, l));\n\t\tgraph[b].push_back(make_pair(a, l));\n\t}\n\t\n\tfor(int i = 0; i < k; ++i) {\n\t\t\n\t\tint s;\n\t\tscanf(\"%d\", &s);\n\t\ts -= 1;\n\t\t\n\t\tpriority_queue<pair<int, int> > q;\n\t\t\n\t\tq.push(make_pair(0, s));\n\t\t\n\t\twhile(!q.empty()) {\n\t\t\t\n\t\t\tint v = q.top().second;\n\t\t\tint c = -q.top().first;\n\t\t\tq.pop();\n\t\t\t\n\t\t\tif(dist[v] < c)\n\t\t\t\tcontinue;\n\t\t\tdist[v] = c;\n\t\t\t\n\t\t\tfor(int i = 0; i < graph[v].size(); ++i) {\n\t\t\t\tint w = graph[v][i].first;\n\t\t\t\tint d = graph[v][i].second + c;\n\t\t\t\tq.push(make_pair(-d, w));\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//for(int i = 0; i < n; ++i)\n\t//\tprintf(\"[debug] %d -> %d\\n\", i, dist[i]);\n\t\n\tfor(int i = 0; i < m; ++i) {\n\t\t\n\t\tint a = edge[i].first.first;\n\t\tint b = edge[i].first.second;\n\t\tint l = edge[i].second;\n\t\tint cost;\n\t\t\n\t\tif(dist[a] > dist[b])\n\t\t\tswap(a, b);\n\t\t\n\t\tif(dist[a] + l == dist[b])\n\t\t\tcost = dist[b];\n\t\telse\n\t\t\tcost = (l - (dist[b] - dist[a]) + 1) / 2 + dist[b];\n\t\tans = max(ans, cost);\n\t\t//printf(\"[debug] (%d, %d) -> (%d, %d) -> %d -> %d\\n\", a, dist[a], b, dist[b], l, cost);\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//  Shopping in JOI Kingdom.cpp\n//  2013/01/06.\n\n#if 1\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst int INF = 1<<30;\n\nint N, M, K;\nint D[3000];\nint C[3000][3000];\nint used[3000];\n\nint dfs(int pnt)\n{\n\trep(next, N) if(D[next] > D[pnt] + C[pnt][next])\n\t{\n\t\tD[next] = D[pnt] + C[pnt][next];\n\t\tdfs(next);\n\t}\n}\n\nvoid dijkstra(int pnt)\n{\n\tmemset(used, 0, sizeof used);\n\t\n\twhile(true)\n\t{\n\t\tint v = -1;\n\t\t\n\t\trep(u, N) if(!used[u] && (v == -1 || D[u] < D[v])) v = u;\n\t\t\n\t\tif(v == -1) break;\n\t\t\n\t\tused[v] = true;\n\t\t\n\t\trep(u, N) chmin(D[u], D[v] + C[v][u]);\n\t}\n}\n\nint calc(int a, int b, int l)\n{\n\treturn round(min(a, b) + (l + max(a, b) - min(a, b)) / 2.0);\n}\n\nint main()\n{\n\trep(i, 3000) rep(j, 3000) D[i] = C[i][j] = INF;\n\t\n\tcin >> N >> M >> K;\n\n\trep(m, M)\n\t{\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\t\n\t\tC[a-1][b-1] = C[b-1][a-1] = c;\n\t}\n\t\n\tint s;\n\trep(k, K)\n\t{\n\t\tcin >> s;\n\t\t\n\t\tD[s-1] = 0;\n\t}\n\t\n\tdijkstra(0);\n\n\tint ans = 0;\n\t\n\trep(a, N) REP(b, a+1, N) if(C[a][b] < INF) chmax(ans, calc(D[a], D[b], C[a][b]));\n\t\n\tcout << ans << endl;\n}\n\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define INF 0x40000000\n\nclass Edge {\npublic:\n    int from;\n    int to;\n    int len;\n};\n\nclass Vertex {\npublic:\n    vector<Edge*> children;\n};\n\nVertex vs[3000];\nEdge es[200000];\nint n, m, k;\nint malls[3000];\nint mall_size;\nint direction[3000];\nint to_mall[3000];\n\nint main() {\n   float max_d;\n\n   scanf(\" %d %d %d\", &n, &m, &k);\n   for (int i=0; i<m; i++) {\n       int a, b, l;\n\n       scanf(\" %d %d %d\", &a, &b, &l);\n       --a;\n       --b;\n       es[i*2].from = a;\n       es[i*2].to = b;\n       es[i*2].len = l;\n       es[i*2+1].from = b;\n       es[i*2+1].to = a;\n       es[i*2+1].len = l;\n       vs[a].children.push_back(&es[i*2]);\n       vs[b].children.push_back(&es[i*2+1]);\n   }\n\n   for (int i=0; i<k; i++) {\n       int s;\n\n       scanf(\"%d\", &s);\n       --s;\n       malls[mall_size] = s;\n       mall_size++;\n   }\n\n   for (int i=0; i<n; i++) {\n       int min_d;\n       priority_queue<P, vector<P>, greater<P> > q;\n\n       fill(direction, direction+n, INF);\n\n       direction[i] = 0;\n       q.push(make_pair(i, 0));\n       while (!q.empty()) {\n           P p = q.top(); q.pop();\n           int s = p.first;\n\n           if (direction[s] < p.second) continue;\n           for (int j=0; j < vs[s].children.size(); j++) {\n               Edge *e = vs[s].children[j];\n               if (direction[e->to] > direction[s] + e->len) {\n                   direction[e->to] = direction[s] + e->len;\n                   q.push(make_pair(e->to, direction[e->to]));\n               }\n           }\n       }\n\n       to_mall[i] = -1;\n       for (int j=0; j < mall_size; j++) {\n           int t = malls[j];\n\n           if (to_mall[i] == -1 || to_mall[i] > direction[t]) {\n               to_mall[i] = direction[t];\n           }\n       }\n   }\n\n   max_d = 0;\n   for (int i=0; i<m*2; i++) {\n       int a = es[i].from;\n       int b = es[i].to;\n       int l = es[i].len;\n       float d = (to_mall[a] + to_mall[b] + l) / 2.0;\n\n       if (d > max_d) {\n           max_d = d;\n       }\n   }\n\n   printf(\"%d\\n\", (int)ceil(max_d));\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(__typeof((X).begin()) it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)x.size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef stringstream sst;\ntypedef vector<int> vi;\n\nstruct edge{\n\tint to,cost;\n\tedge(int to,int cost):to(to),cost(cost){}\n};\n\nint N,M,K;\nvector<edge> G[3010];\nint dist[3010];\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>N>>M>>K;\n\tint a,b,l;\n\trep(i,M){\n\t\tcin>>a>>b>>l;\n\t\ta--,b--;\n\t\tG[a].pb(edge(b,l));\n\t\tG[b].pb(edge(a,l));\n\t}\n\tint s;\n\trep(i,K){\n\t\tcin>>s;\n\t\ts--;\n\t\tG[N].pb(edge(s,0));\n\t}\n\tfill(dist,dist+N+1,INF);\n\tdist[N]=0;\n\tpriority_queue<pi,vector<pi>,greater<pi> > Q;\n\tQ.push(pi(0,N));\n\twhile(sz(Q)){\n\t\tpi p=Q.top();\n\t\tQ.pop();\n\t\tint v=p.sec;\n\t\tif(dist[v] < p.fir)continue;\n\t\trep(i,sz(G[v])){\n\t\t\tint nd=dist[v]+G[v][i].cost;\n\t\t\tif(nd < dist[G[v][i].to]){\n\t\t\t\tdist[G[v][i].to]=nd;\n\t\t\t\tQ.push(pi(nd,G[v][i].to));\n\t\t\t}\n\t\t}\n\t}\n\tint ans=*max_element(dist,dist+N+1);\n\trep(i,N+1)rep(j,sz(G[i])){\n\t\tif(dist[i] <= dist[G[i][j].to]){\n\t\t\tans=max(ans,\n\t\t\tdist[G[i][j].to] + (G[i][j].cost-(dist[G[i][j].to]-dist[i])+1)/2);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct edge{int to,cost;};\ntypedef pair<int,int> P;\nint n,m,k,ans,d[3007],miti[100005][3];\nconst int INF = 1000000000;\nvector<edge> G[3007];\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\n\tfor(int i = 0;i <= n;i++){\n\t\td[i] = INF;\n\t}\n\tfor(int i = 0;i < m;i++){\n\t\tint a,b,l;\n\t\tscanf(\"%d%d%d\",&a,&b,&l);\n\t\tmiti[i][0] = a,miti[i][1] = b,miti[i][2] = l;\n\t\tedge tmp = {b,l};\n\t\tG[a].push_back(tmp);\n\t\tedge tmp2 = {a,l};\n\t\tG[b].push_back(tmp2);\n\t}\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tfor(int i = 0;i < k;i++){\n\t\tint a;\n\t\tscanf(\"%d\",&a);\n\t\td[a] = 0;\n\t\tque.push(P(0,a));\n\t}\n\n\twhile(que.size()){\n\t\tP q = que.top(); que.pop();\n\t\tif(d[q.second] < q.first)continue;\n\t\tfor(int i = 0;i < G[q.second].size();i++){\n\t\t\tedge es = G[q.second][i];\n\t\t\tif(d[es.to] > q.first + es.cost){\n\t\t\t\td[es.to] = q.first + es.cost;\n\t\t\t\tque.push(P(d[es.to],es.to));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1;i <= n;i++){\n\t\tans = max(ans,d[i]);\n\t}\n\tfor(int i = 0;i < m;i++){\n\t\tint a =d[miti[i][0]],b = d[miti[i][1]],l = miti[i][2];\n\t\tif(a > b)swap(a,b);\n\t\tl -= (b-a);\n\t\tif(l <= 0)continue;\n\t\tans = max(ans,b+(l+1)/2);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<functional>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nstruct edge{\n\tint from;\n\tint to;\n\tint cost;\n};\n\nstruct city{\n\tint number;\n\tint cost;\n};\n\nint main(){\n\tint n,m,k,a,cost[3002],ret=0;\n\tedge e;\n\tvector<edge> ve[3002];\n\tvector<edge> E;\n\tpriority_queue<city,vector<city>,function<bool(city,city)>> c([](city x,city y){return x.cost<=y.cost;});\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tfor(int i=1;i<=n;i++){\n\t\tcost[i]=100000000;\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d%d\",&e.from,&e.to,&e.cost);\n\t\tE.push_back(e);\n\t\tve[e.from].push_back(e);\n\t\ta=e.from; e.from=e.to; e.to=a;\n\t\tve[e.from].push_back(e);\n\t}\n\tfor(int i=0;i<k;i++){\n\t\tcity C;\n\t\tscanf(\"%d\",&C.number);\n\t\tC.cost=0;\n\t\tcost[C.number]=0;\n\t\tc.push(C);\n\t}\n\twhile(!c.empty()){\n\t\tcity C=c.top(); c.pop();\n\t\tif(C.cost==cost[C.number]){\n\t\t\tint s=ve[C.number].size();\n\t\t\tfor(int i=0;i<s;i++){\n\t\t\t\tedge ed=ve[C.number][i];\n\t\t\t\tif(cost[ed.to]>cost[ed.from]+ed.cost){\n\t\t\t\t\tcost[ed.to]=cost[ed.from]+ed.cost;\n\t\t\t\t\tcity cit;\n\t\t\t\t\tcit.number=ed.to; cit.cost=cost[ed.to];\n\t\t\t\t\tc.push(cit);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/*for(int i=1;i<=n;i++){\n\t\tprintf(\"%d\\n\",cost[i]);\n\t}*/\n\tfor(int i=0;i<m;i++){\n\t\tret=max(ret,(cost[E[i].from]+cost[E[i].to]+E[i].cost+1)/2);\n\t}\n\tprintf(\"%d\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nstruct edge {\n\tint to, cost;\n};\n\nint dist[3000];\nvector<edge> G[3000];\nP p[100000];\nint l[100000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M, K;\n\tcin >> N >> M >> K;\n\n\tfor(int i = 0; i < M; i++) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--, b--;\n\t\tp[i] = { a, b };\n\t\tl[i] = c;\n\t\tG[a].push_back({ b, c });\n\t\tG[b].push_back({ a, c });\n\t}\n\n\tconst int INF = 1 << 25;\n\tfill((int*)begin(dist), (int*)end(dist), INF);\n\tpriority_queue<P> q;\n\tfor(int i = 0; i < K; i++) {\n\t\tint s;\n\t\tcin >> s;\n\t\ts--;\n\t\tdist[s] = 0;\n\t\tq.push({ 0, s });\n\t}\n\n\twhile(q.size()) {\n\t\tint v = q.top().second;\n\t\tint d = q.top().first;\n\t\tq.pop();\n\t\tif(dist[v] < d) continue;\n\t\tfor(auto e : G[v]) {\n\t\t\tint to = e.to;\n\t\t\tint c = e.cost;\n\t\t\tif(dist[to] > d + c) {\n\t\t\t\tdist[to] = d + c;\n\t\t\t\tq.push({ d + c, to });\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor(int i = 0; i < M; i++) {\n\t\tint u = p[i].first, v = p[i].second;\n\t\tint d = (dist[u] + dist[v] + l[i] + 1) / 2;\n\t\tans = max(ans, d);\n\t}\n\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<utility>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n#define INF 1<<20\ntypedef pair<int,int>p;\nint N,M,K,a,b,l,d[3000],rd[3000];\nvector<p>G[3000];//to,cost\nvector<int>S;\n\nvoid dij(int s)\n{\n\tpriority_queue<p,vector<p>,greater<p> >Q;\n\tfill(d,d+N,INF);\n\td[s]=0;Q.push(p(0,s));\n\tfor(;!Q.empty();)\n\t{\n\t\tp tmp=Q.top();Q.pop();\n\t\tint v=tmp.second;\n\t\tif(d[v]<tmp.first)continue;\n\t\tfor(int i=0;i<G[v].size();i++)\n\t\t{\n\t\t\tp e=G[v][i];\n\t\t\tif(d[e.first]>d[v]+e.second)\n\t\t\t{\n\t\t\t\td[e.first]=d[v]+e.second;\n\t\t\t\tQ.push(p(d[e.first],e.first));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&N,&M,&K);\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&l);\n\t\ta--;b--;\n\t\tG[a].push_back(p(b,l));\n\t\tG[b].push_back(p(a,l));\n\t}\n\tfill(rd,rd+N,INF);\n\tfor(int i=0;i<K;i++)\n\t{\n\t\tscanf(\"%d\",&a);\n\t\ta--;\n\t\tdij(a);\n\t\tfor(int j=0;j<N;j++)rd[j]=min(rd[j],d[j]);\n\t}\n\tint res=0;\n\tfor(int i=0;i<M;i++)\n\t\tfor(int j=0;j<G[i].size();j++)\n\t\t{\n\t\t\tint tmp=(double)(abs(rd[i]-rd[G[i][j].first])+G[i][j].second)/2+0.5;\n\t\t\tint tmp1=rd[G[i][j].first];\n\t\t\tint tmp2=G[i][j].second-tmp;\n\t\t\tres=max(res,rd[i]+(rd[i]<=tmp1?max(tmp,tmp2):min(tmp,tmp2)));\n\t\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nstruct edge{\n  int from, to, cost;\n  edge () {}\n  edge(int from, int to, int cost) :\n    from(from), to(to), cost(cost) {}\n  bool operator < (const edge& r) const {\n    return cost != r.cost ? cost > r.cost : from != r.from ? from < r.from : to < r.to;\n  }\n};\n\ntypedef vector<edge> edges;\ntypedef vector<edges> graph;\n\nint main(){\n  int N, M, K;\n  while(cin>>N>>M>>K && N){\n    graph g(N);\n    REP(i, M){\n      int a, b, c;\n      cin>>a>>b>>c;\n      a--; b--;\n      g[a].push_back(edge(a, b, c));\n      g[b].push_back(edge(b, a, c));\n    }\n    vector<int> dist(N, INF);\n    REP(iter, K){\n      int s; cin>>s; s--;\n      queue<int> que;\n      que.push(s);\n      dist[s] = 0;\n      while(!que.empty()){\n        int u = que.front(); que.pop();\n        FORIT(it, g[u]){\n          int next = dist[u] + it->cost;\n          if(next < dist[it->to]){\n            dist[it->to] = next;\n            que.push(it->to);\n          }\n        }\n      }\n    }\n    double ans = 0;\n    REP(u, N)FORIT(it, g[u]){\n      int d1 = dist[u];\n      int d2 = dist[it->to];\n      double mans = max(d1, d2) + (double)(it->cost-abs(d1-d2)) / 2;\n      ans = max(ans, mans);\n    }\n    printf(\"%.0lf\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst int MAX_N = 3005;\n\nstruct Edge\n{\n\tint v, cost; \n\tEdge(int v, int cost) \n\t\t: v(v), cost(cost) \n\t{ } \n};\n\nvector<Edge> edges[MAX_N];\n\nint main()\n{\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\t\n\tvint d(n, 0);\n\tvector<bool> flag(n, false);\n\t\n\trep(i, m)\n\t{\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\t\n\t\tedges[a - 1].push_back(Edge(b - 1, c));\n\t\tedges[b - 1].push_back(Edge(a - 1, c));\n\t}\n\t\n\trep(i, k)\n\t{\n\t\tint f;\n\t\tcin >> f;\n\t\t\n\t\tflag[f - 1] = true;\n\t}\n\t\n\t// それぞれの街から最も近いショッピングモールへの距離をBFSで探索O(n*n*hoge)\n\trep(i, n)\n\t{\n\t\tif(!flag[i])\n\t\t{\n\t\t\tvector<bool> used(n, false);\n\t\t\tpriority_queue<pint, vector<pint>, greater<pint> > que; // first := cost, second := position;\n\t\t\t\n\t\t\tfor(que.push(mp(0, i)); !que.empty(); que.pop())\n\t\t\t{\n\t\t\t\tpint p = que.top();\n\t\t\t\t\n\t\t\t\tif(flag[p.second])\n\t\t\t\t{\n\t\t\t\t\td[i] = p.first;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trep(j, edges[p.second].size())\n\t\t\t\t{\n\t\t\t\t\tEdge &e = edges[p.second][j];\n\t\t\t\t\t\n\t\t\t\t\tif(!used[e.v])\n\t\t\t\t\t{\n\t\t\t\t\t\tused[e.v] = true;\n\t\t\t\t\t\tque.push(mp(p.first + e.cost, e.v));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// 辺上の最大値を探すO(m)\n\tdouble res = 0;\n\trep(i, n) \n\t{\n\t\trep(j, edges[i].size())\n\t\t{\n\t\t\tEdge &e = edges[i][j];\n\t\t\t\n\t\t\tdouble tmp = min(d[i], d[e.v]) + e.cost / 2.0;\n\t\t\tchmax(tmp, min(d[i] + 1, d[e.v] + e.cost - 1));\n\t\t\tchmax(tmp, min(d[i] + e.cost - 1, d[e.v] + 1));\n\t\t\t\n\t\t\tchmax(res, tmp);\n\t\t}\n\t\t\n\t\tchmax(res, d[i]);\n\t}\n\t\n\tcout << round(res) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\n\n\nstruct Edge\n{\n\tint to, cost;\n\tEdge(int to, int cost)\n\t\t: to(to), cost(cost) {}\n};\ntypedef vector<vector<Edge> > Graph;\nvoid add_edge(Graph& g, int a, int b, int cost)\n{\n\tg[a].push_back(Edge(b, cost));\n\tg[b].push_back(Edge(a, cost));\n}\nvector<int> dijkstra(const Graph& g, const vector<int>& s)\n{\n\tconst int _INF = 1e9;\n\ttypedef pair<int, int> pint;\n\n\tvector<int> dis(g.size(), _INF);\n\tpriority_queue<pint, vector<pint>, greater<pint> > q;\n\n\tfor (int i = 0; i < s.size(); ++i)\n\t{\n\t\tdis[s[i]] = 0;\n\t\tq.push(pint(0, s[i]));\n\t}\n\twhile (!q.empty())\n\t{\n\t\tpint t = q.top(); q.pop();\n\t\tint cur = t.second, d = t.first;\n\n\t\tif (d > dis[cur])\n\t\t\tcontinue;\n\n\t\tfor (int i = 0; i < g[cur].size(); ++i)\n\t\t{\n\t\t\tconst Edge& e = g[cur][i];\n\t\t\tint next_d = d + e.cost;\n\t\t\tif (next_d < dis[e.to])\n\t\t\t{\n\t\t\t\tdis[e.to] = next_d;\n\t\t\t\tq.push(pint(next_d, e.to));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dis;\n}\nint main()\n{\n\tint n, m, k;\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\n\tGraph g(n);\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tint a, b, l;\n\t\tscanf(\"%d%d%d\", &a, &b, &l);\n\t\t--a, --b;\n\t\tadd_edge(g, a, b, l);\n\t}\n\tvector<int> start;\n\tfor (int i = 0; i < k; ++i)\n\t{\n\t\tint s;\n\t\tscanf(\"%d\", &s);\n\t\tstart.push_back(--s);\n\t}\n\n\tvector<int> dis = dijkstra(g, start);\n\n\tint res = 0;\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tfor (int j = 0; j < g[i].size(); ++j)\n\t\t{\n\t\t\tEdge& e = g[i][j];\n\n\t\t\tdouble from_i = (dis[e.to] + e.cost - dis[i]) / 2.0;\n\t\t\tdouble d = dis[i] + from_i;\n\n\t\t\tmax_swap(res, (int)(d + 0.5 + 1e-9));\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define INF (2 << 28)\n#define fr first\n#define sc second\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> iP;\n\nstruct edge{\n  int to, dis;\n  edge(int too, int cost){\n    dis = cost;\n    to = too;\n  }\n};\n\nint n, m, k, l[3333];\nint mindis[3333], costed[3333], shop[3333];\nvector<vector<edge> > graph(3333);\n\nvoid Dijkstra(){\n  \n  fill_n(costed, 3333, INF);\n  priority_queue<iP, vector<iP>, greater<iP> > que;\n  for(int i = 0; i < k; i++){\n    que.push(iP(0, shop[i])); costed[shop[i]] = 0;\n  }\n  while(!que.empty()){\n    iP p = que.top(); que.pop();\n    int now = p.sc, d = p.fr;\n    for(int i = 0; i < graph[now].size(); i++){\n      edge e = graph[now][i];\n      if(d + e.dis < costed[e.to]){\n        costed[e.to] = d + e.dis;\n        que.push(iP(d + e.dis, e.to));\n      }\n    }\n  }\n}\n\n    \nint main(){\n  \n  cin >> n >> m >> k;\n  for(int i = 0; i < m; i++){\n    int a, b, c; cin >> a >> b >> c;\n    graph[a].push_back(edge(b, c));\n    graph[b].push_back(edge(a, c));\n  }\n  for(int i = 0; i < k; i++) cin >> shop[i];\n  Dijkstra();\n\n  double maxi = 0;\n  for(int i = 1; i <= n; i++){\n    for(int j = 0; j < graph[i].size(); j++){\n      int tar, subs, t = graph[i][j].to;\n      subs = costed[i] - costed[t];\n      if(subs < 0) tar = costed[t], subs = -subs;\n      else tar = costed[i];\n      maxi = max(maxi, tar + (double)(graph[i][j].dis - subs)/2);\n    }\n\n  }\n  cout << (int)(maxi + 0.5) << endl;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++,h>\n#define int long long\n#define P pair<int,int>//cost to\nusing namespace std;\n\nint kiriage(int a) {\n\tif (a&1)return a / 2 + 1;\n\treturn a / 2;\n}\nvector<P>rinsetu[3000];\nint mincost[3000];\nsigned main() {\n\tint a, b, c; cin >> a >> b >> c;\n\tfill(mincost, mincost + a, LLONG_MAX/3);\n\tfor (int d = 0; d < b; d++) {\n\t\tint e, f, g; scanf(\"%d%d%d\", &e, &f, &g); e--; f--;\n\t\trinsetu[e].push_back(P(g, f));\n\t\trinsetu[f].push_back(P(g, e));\n\t}\n\tpriority_queue<P, vector<P>, greater<P>>Q;\n\tfor (int h = 0; h < c; h++) {\n\t\tint i; scanf(\"%d\", &i); i--;\n\t\tmincost[i] = 0;\n\t\tQ.push(P(0,i));\n\t}\n\twhile (Q.size()) {\n\t\tP o = Q.top(); Q.pop();\n\t\tif (mincost[o.second] < o.first)continue;\n\t\tfor (P t : rinsetu[o.second]) {\n\t\t\tif (o.first + t.first < mincost[t.second]) {\n\t\t\t\tmincost[t.second] = o.first + t.first;\n\t\t\t\tQ.push(P(mincost[t.second],t.second));\n\t\t\t}\n\t\t}\n\t}\n\tint MAX = 0;\n\tfor (int x = 0; x < a; x++) {\n\t\tfor (P y : rinsetu[x]) {\n\t\t\ty.first -= abs(mincost[x] - mincost[y.second]);\n\t\t\tMAX = max(MAX, max(mincost[x], mincost[y.second]) + kiriage(y.first));\n\t\t}\n\t}\n\tcout << MAX << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\n\nvector<P>E[3000];\nint d[3000];\nint main() {\n\tint n,m,k;scanf(\"%d%d%d\",&n,&m,&k);\n\trep(i,m){\n\t\tint a,b,l;scanf(\"%d%d%d\",&a,&b,&l);a--;b--;\n\t\tE[a].push_back(P(l,b));E[b].push_back(P(l,a));\n\t}\n\tmemset(d,0x3f,sizeof(d));\n\tpriority_queue<P,vector<P>,greater<P>>que;\n\trep(i,k){\n\t\tint s;scanf(\"%d\",&s);s--;\n\t\tque.push(P(0,s));\n\t\td[s]=0;\n\t}\n\twhile(!que.empty()){\n\t\tP p=que.top();que.pop();\n\t\tif(p.first!=d[p.second])continue;\n\t\tfor(P u:E[p.second]){\n\t\t\tif(d[u.second]>p.first+u.first){\n\t\t\t\td[u.second]=p.first+u.first;\n\t\t\t\tque.push(P(d[u.second],u.second));\n\t\t\t}\n\t\t}\n\t}\n\tint Max=0;\n\trep(i,n){\n\t\tfor(P p:E[i]){\n\t\t\tfor(double k=0;k<=(double)p.first;k+=0.5){\n\t\t\t\tMax=max(Max,(int)ceil(min((double)d[i]+k,(double)d[p.second]+(double)p.first-k)));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",Max);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <deque>\n#include <vector>\nusing namespace std;\n\nint main() {\n\tint N,M,K;\n\tvector<pair<int,int> >nGo[3001];\n\tdeque<int> dis;\n\tint dist[3001];\n\tint road[3000][3];\n\tfor(int i=1;i<=3000;i++)\n\t\tdist[i]=(1 << 30 );\n\tcin >> N >> M >> K;\n\tint a,b,c;\n\tfor(int i=0;i<M;i++){\n\t\tcin >> a >> b >> c;\n\t\tnGo[a].push_back(pair<int,int>(b,c));\n\t\tnGo[b].push_back(pair<int,int>(a,c));\n\t\troad[i][0]=a;\n\t\troad[i][1]=b;\n\t\troad[i][2]=c;\n\t}\n\tfor(int i=0;i<K;i++){\n\t\tcin >> a;\n\t//\tdis.insert(multimap<int,int>::value_type(0,a));\n\t\tdis.push_back(a);\n\t\tdist[a]=0;\n\t}\n\twhile(!dis.empty()){\n\t\tsort(dis.begin(),dis.end());\n\t\tint now=dis[0];\n\t\tfor(int i=0;i<nGo[now].size();i++){\n\t\t\tif(dist[nGo[now][i].first]>dist[now]+nGo[now][i].second){\n\t\t\t\tdis.push_back(nGo[now][i].first);\n\t\t\t\tdist[nGo[now][i].first]=dist[now]+nGo[now][i].second;\n\t\t\t}\n\t\t}\n\t\twhile(now==dis[0])\n\t\tdis.pop_front();\n\t}\n\tint maxer=0;\n\tfor(int i=0;i<M;i++)\n\tmaxer=max(maxer,(dist[road[i][0]]+dist[road[i][1]]+road[i][2]+1)/2);\n\tfor(int i=1;i<=N;i++)\n\tmaxer=max(maxer,dist[i]);\n\tcout << maxer <<  endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\u0010#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint N, M, K;\nvector<P> G[4096];\nint d[4096];\n\n\nint main(){\n  scanf(\"%d%d%d\",&N,&M,&K);\n  int a, b, l;\n  rep(i,M){\n    scanf(\"%d%d%d\",&a,&b,&l); a--; b--;\n    G[a].push_back(P(b, l));\n    G[b].push_back(P(a, l));\n  }\n\n  priority_queue<P, vector<P>, greater<P> >q;\n  int s;\n  fill(d, d+N, INF);\n  rep(i,K){\n    scanf(\"%d\", &s); s--;\n    d[s] = 0;\n    q.push(P(0, s));\n  }\n  \n  /*  rep(i, N){\n    rep(j, G[i].size()) printf(\"%d %d \", G[i][j].first, G[i][j].second);\n    cout << endl;\n    }*/\n  \n  while(!q.empty()){\n    int cur = q.top().second, v = q.top().first;\n    q.pop();\n    //    cout << \"cur \" << cur << \"v \" << v << endl;\n    if(v > d[cur]) continue;\n    rep(i, G[cur].size()){\n      P next = G[cur][i];\n      //      cout << next.first << \" \" << d[next.first] << endl;\n      if(d[next.first] > next.second + v){\n\td[next.first] = next.second + v;\n\tq.push(P(d[next.first], next.first));\n      }\n    }\n  }\n\n  int res = 0;\n  rep(i, N) if(d[i]!=INF) res = max(res, d[i]);\n  //  rep(i, N) printf(\"%d \", d[i]); puts(\"\");\n  //  printf(\"%d\\n\", res);\n\n  rep(i, N){\n    rep(j, G[i].size()){\n      P p = G[i][j];\n      res = max(res, (int)((p.second+d[i]+d[p.first])/2.0 + 0.5));\n      //      cout << i << \" \" << j << \" \" << res << endl;\n    }\n  }\n  printf(\"%d\\n\", res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint N, M, K;\nvector<P> G[4096];\nint d[4096];\n\n\nint main(){\n  scanf(\"%d%d%d\",&N,&M,&K);\n  int a, b, l;\n  rep(i,M){\n    scanf(\"%d%d%d\",&a,&b,&l); a--; b--;\n    G[a].push_back(P(b, l));\n    G[b].push_back(P(a, l));\n  }\n\n  priority_queue<P, vector<P>, greater<P> >q;\n  int s;\n  fill(d, d+N, INF);\n  rep(i,K){\n    scanf(\"%d\", &s); s--;\n    d[s] = 0;\n    q.push(P(0, s));\n  }\n  \n  /*  rep(i, N){\n    rep(j, G[i].size()) printf(\"%d %d \", G[i][j].first, G[i][j].second);\n    cout << endl;\n    }*/\n  \n  while(!q.empty()){\n    int cur = q.top().second, v = q.top().first;\n    q.pop();\n    //    cout << \"cur \" << cur << \"v \" << v << endl;\n    if(v > d[cur]) continue;\n    rep(i, G[cur].size()){\n      P next = G[cur][i];\n      //      cout << next.first << \" \" << d[next.first] << endl;\n      if(d[next.first] > next.second + v){\n\td[next.first] = next.second + v;\n\tq.push(P(d[next.first], next.first));\n      }\n    }\n  }\n\n  int res = 0;\n  rep(i, N) if(d[i]!=INF) res = max(res, d[i]);\n  //  rep(i, N) printf(\"%d \", d[i]); puts(\"\");\n  //  printf(\"%d\\n\", res);\n\n  rep(i, N){\n    rep(j, G[i].size()){\n      P p = G[i][j];\n      res = max(res, (int)((p.second+d[i]+d[p.first])/2.0 + 0.5));\n      //      cout << i << \" \" << j << \" \" << res << endl;\n    }\n  }\n  printf(\"%d\\n\", res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<cstdio>\n#include<cmath>\n#define INF 500000000\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n,m,k;\nint l[100100],a[100100],b[100100];\nvector<P> g[5000];\nint d[5000],w[5000];\nbool s[5000];\n\nint main(){\n  cin >> n >> m >> k;\n  for(int i=0;i<m;i++){\n    cin >> a[i] >> b[i] >> l[i];\n    a[i]--; b[i]--;\n    g[a[i]].push_back(P(l[i],b[i]));\n    g[b[i]].push_back(P(l[i],a[i]));\n  }\n\n  for(int i=0;i<n;i++)s[i] = false;\n\n  int tmp;\n  for(int i=0;i<k;i++){\n    cin >> tmp;\n    s[tmp-1] = true;\n  }\n\n  for(int i=0;i<n;i++)w[i] = INF;\n\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++)d[j] = INF;\n    d[i] = 0;\n    priority_queue<P,vector<P>,greater<P> > q;\n    q.push(P(0,i));\n    while(q.size()){\n      P p = q.top(); q.pop();\n      int cost = p.first, pos = p.second;\n\n      if(s[pos]){\n\tw[i] = cost;\n\tbreak;\n      }\n      for(int j=0;j<(int)g[pos].size();j++){\n\tint dis = cost + g[pos][j].first;\n\tint next = g[pos][j].second;\n\n\tif(dis<d[next]){\n\t  d[next] = dis;\n\t  q.push(P(dis,next));\n\t}\n      }\n    }\n  }\n\n  double ans = 0.0;\n  for(int i=0;i<m;i++){\n    if(fabs(w[a[i]] - w[b[i]]) >= l[i]){\n      ans = max(ans,(double)max(w[a[i]],w[b[i]]));\n    }else{\n      ans = max(ans,(double)(l[i]+w[a[i]]+w[b[i]])/2);\n    }\n  }\n  cout << (int)(ans+1e-9+0.5) << endl;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n#define min(...) min({__VA_ARGS__})\n#define max(...) max({__VA_ARGS__})\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\n#define MAX_N 3000\n\nstruct edge {\n  int to, cost;\n  edge(){}\n  edge(int to, int cost):to(to), cost(cost){}\n};\n\nvector<edge> graph[MAX_N];\nint mincost[MAX_N];\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N, M, K;\n  cin >> N >> M >> K;\n  rep(i, M) {\n    int a, b, l;\n    cin >> a >> b >> l;\n    --a, --b;\n    graph[a].emplace_back(b, l);\n    graph[b].emplace_back(a, l);\n  }\n  priority_queue<pint, vector<pint>, greater<pint> > que;\n  fill(all(mincost), inf);\n  rep(i, K) {\n    int s;\n    cin >> s;\n    --s;\n    que.emplace(0, s);\n    mincost[s] = 0;\n  }\n\n  while(que.size()) {\n    pint p = que.top(); que.pop();\n    int v = p.second;\n    if(mincost[v] < p.first) continue;\n    for(edge e : graph[v]) {\n      if(mincost[v] + e.cost < mincost[e.to]) {\n\tmincost[e.to] = mincost[v] + e.cost;\n\tque.emplace(mincost[e.to], e.to);\n      }\n    }\n  }\n\n  int ans = 0;\n  rep(i, N) {\n    ans = max(ans, mincost[i]);\n    for(edge e : graph[i]) {\n      ans = max(ans, (mincost[i]+mincost[e.to]+e.cost+1)/2);\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define MAX_N 3001\n#define UNDEF -1\n#define MAX_INT 2147483647\n\ntypedef struct\n{\n\tunsigned short int node1;\n\tunsigned short int node2;\n\tunsigned short int length;\n\tunsigned int distance;\n} Road;\n\ntypedef struct\n{\n\tunsigned int distance;\n\tbool decided;\n} Node;\n\nint N,M,K;\nvector<Road> I;\nvector<Node> J;\nRoad Rtemp;\nNode Ntemp;\n\nRoad* MAKEROAD(const unsigned short int node1,const unsigned short int node2,const unsigned short int length,const unsigned int distance)\n{\n\tRtemp.node1 = node1;\n\tRtemp.node2 = node2;\n\tRtemp.length = length;\n\tRtemp.distance = distance;\n\treturn &Rtemp;\n}\n\nNode* MAKENODE(const unsigned int distance,const bool decided)\n{\n\tNtemp.distance = distance;\n\tNtemp.decided = decided;\n\treturn &Ntemp;\n}\n\nint main(void)\n{\n\tcin >> N >> M >> K;\n\tint _a,_b,_i;\n\tfor(int i = 0;i < M;i++)\n\t{\n\t\tcin >> _a >> _b >> _i;\n\t\tI.push_back(*MAKEROAD(_a,_b,_i,MAX_INT));\n\t}\n\tfor(int i = 0;i < K;i++)\n\t{\n\t\tcin >> _a;\n\t\tI.push_back(*MAKEROAD(0,_a,0,MAX_INT));\n\t}\n\tfor(int i = 0;i < N+1;i++)\n\t{\n\t\tJ.push_back(*MAKENODE(MAX_INT,false));\n\t}\n\tJ.begin()->distance = 0;\n\tint mindist = 0;\n\tauto mindist_itr = J.begin();\n\tint mindist_i = 0;\n\tbool chg = false;\n\twhile(true)\n\t{\n\t\tmindist = MAX_INT;\n\t\tchg = false;\n\t\tfor(auto itr = J.begin();itr < J.end();itr++)\n\t\t{\n\t\t\tif(!(itr->decided) && itr->distance < mindist)\n\t\t\t{\n\t\t\t\tmindist_itr = itr;\n\t\t\t\tchg = true;\n\t\t\t}\n\t\t}\n\t\tif(!chg)\n\t\t\tbreak;\n\t\telse\n\t\t{\n\t\t\tmindist_itr->decided = true;\n\t\t\tmindist_i = mindist_itr - J.begin();\n\t\t\tfor(auto itr = I.begin();itr < I.end();itr++)\n\t\t\t{\n\t\t\t\tif(itr->node1 == mindist_i)\n\t\t\t\t{\n\t\t\t\t\tif(J[itr->node2].distance > J[mindist_i].distance + itr->length)\n\t\t\t\t\t{\n\t\t\t\t\t\tJ[itr->node2].distance = J[mindist_i].distance + itr->length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(itr->node2 == mindist_i)\n\t\t\t\t{\n\t\t\t\t\tif(J[itr->node1].distance > J[mindist_i].distance + itr->length)\n\t\t\t\t\t{\n\t\t\t\t\t\tJ[itr->node1].distance = J[mindist_i].distance + itr->length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(auto itr = I.begin();itr < I.end();itr++)\n\t{\n\t\t_a = J[itr->node1].distance + J[itr->node2].distance + itr->length;\n\t\tif(_a % 2 == 1)\n\t\t\t_a++;\n\t\titr->distance = _a / 2;\n\t}\n\tunsigned int result = 0;\n\tfor(auto itr = I.begin();itr < I.end();itr++)\n\t{\n\t\tresult = max(result,itr->distance);\n\t}\n\tfor(auto itr = J.begin();itr < J.end();itr++)\n\t{\n\t\tresult = max(result,itr->distance);\n\t}\n\tcout << result << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define INF 0x40000000\n\nclass Edge {\npublic:\n    int from;\n    int to;\n    int len;\n};\n\nclass Vertex {\npublic:\n    vector<Edge*> children;\n};\n\nVertex vs[3000];\nEdge es[20000];\nint n, m, k;\nint malls[3000];\nint mall_size;\nint direction[3000];\nint to_mall[3000];\n\nint main() {\n   float max_d;\n\n   scanf(\"%d %d %d\", &n, &m, &k);\n   for (int i=0; i<m; i++) {\n       int a, b, l;\n\n       scanf(\"%d %d %d\", &a, &b, &l);\n       --a;\n       --b;\n       es[i*2].from = a;\n       es[i*2].to = b;\n       es[i*2].len = l;\n       es[i*2+1].from = b;\n       es[i*2+1].to = a;\n       es[i*2+1].len = l;\n       vs[a].children.push_back(&es[i*2]);\n       vs[b].children.push_back(&es[i*2+1]);\n   }\n\n   for (int i=0; i<k; i++) {\n       int s;\n\n       scanf(\"%d\", &s);\n       --s;\n       malls[mall_size] = s;\n       mall_size++;\n   }\n\n   for (int i=0; i<n; i++) {\n       int min_d;\n       priority_queue<P, vector<P>, greater<P> > q;\n\n       fill(direction, direction+n, INF);\n\n       direction[i] = 0;\n       q.push(make_pair(i, 0));\n       while (!q.empty()) {\n           P p = q.top(); q.pop();\n           int s = p.first;\n\n           if (direction[s] < p.second) continue;\n           for (int j=0; j < vs[s].children.size(); j++) {\n               Edge *e = vs[s].children[j];\n               if (direction[e->to] > direction[s] + e->len) {\n                   direction[e->to] = direction[s] + e->len;\n                   q.push(make_pair(e->to, direction[e->to]));\n               }\n           }\n       }\n\n       to_mall[i] = -1;\n       for (int j=0; j < mall_size; j++) {\n           int t = malls[j];\n\n           if (to_mall[i] == -1 || to_mall[i] > direction[t]) {\n               to_mall[i] = direction[t];\n           }\n       }\n   }\n\n   max_d = 0;\n   for (int i=0; i<m; i++) {\n       int a = es[i*2].from;\n       int b = es[i*2].to;\n       int l = es[i*2].len;\n       float d = (to_mall[a] + to_mall[b] + l) / 2.0;\n\n       if (d > max_d) {\n           max_d = d;\n       }\n   }\n\n   printf(\"%d\\n\", (int)ceil(max_d));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3002\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<P> G[N];\nbool num[N];\nint n,m,K;\n\nbool check(int pos,set<int>&A,set<int>&B){\n  set<int>::iterator i = A.begin();\n  for(i=A.begin();i!=A.end();i++)if(B.count(pos)==0) return 1;\n  for(i=B.begin();i!=B.end();i++)if(A.count(*i)==0) return 1;\n  return 1;\n}\n \ndouble dijkstra(){\n  int D[N];\n  for(int i=0;i<N;i++) D[i] = 1e9;\n  \n  set<int>pre[N];\n  priority_queue<PP,vector<PP>,greater<PP> >Q;\n  \n  for(int i=0;i<n;i++)if(num[i]) Q.push(PP(0,P(i,-1))),D[i] = 0;\n  \n  \n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first;\n    int pos = t.second.first;\n    int ppos = t.second.second;\n    \n    if(D[pos]<cost) continue;\n    pre[pos].insert(ppos);\n    \n    for(int i=0;i<G[pos].size();i++){\n      int npos = G[pos][i].first;\n      int ncost = cost+G[pos][i].second;\n      if(D[npos]<ncost) continue;\n      Q.push(PP(ncost,P(npos,pos)));\n      D[npos] = ncost;\n    }\n  }\n\n\n  double res = 0;\n  for(int i=0;i<n;i++){\n    res = max(res,D[i]/2.0);\n\n    for(int j=0;j<(int)G[i].size();j++){\n      int npos = G[i][j].first;\n      int ncost = G[i][j].second;\n      if(pre[i].count(npos)||pre[npos].count(i))continue;\n      res = max(res,(D[i]+D[npos]+ncost)/2.0);\n    }\n  }\n  return res;\n   \n}\n \nint main(){\n  cin>>n>>m>>K;\n  for(int i=0,a,b,c;i<m;i++){\n    cin>>a>>b>>c;\n    G[a-1].push_back(P(b-1,c));\n    G[b-1].push_back(P(a-1,c));\n  }\n \n  for(int i=0,a;i<K;i++)cin>>a,num[a-1]=1;\n  printf(\"%d\\n\",(int)(dijkstra()+0.5));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef int  i32;\ntypedef long long i64,ll;\n#define BR \"\\n\"\n\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\n\n//config\n//#define MODE_DEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef MODE_DEBUG\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n\n#define  DUMP(x)  cerr << #x << \" = \" << (x) <<endl\n#define DEBUG(x) DUMP(x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMP(exp);DEBUG(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#else\n#define DUMP(x)\n#define DEBUG(x)\n#define CHECK(exp,act)\n#define STOP(e)\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\ntemplate<class T> inline string toString(const vector<vector<T>>& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\nnamespace ShortestPath{\n    const int INF=1<<30;\n    struct Edge{\n        int from,to,cost;\n        Edge(int from,int to,int cost)\n            : from(from),to(to),cost(cost) {};\n    };\n    ostream& operator <<(ostream& os,const Edge& e){\n            os<<\"(\"<<e.from<<\"->\"<<e.to<<\")\";\n            return os;\n    }\n    struct Task{\n        int prev,pos,cost;\n        Task(int prev,int pos,int cost)\n            :prev(prev),pos(pos),cost(cost){};\n        bool operator>(const Task& r) const{\n            return cost>r.cost;\n        }\n    };\n    typedef vector<vector<Edge> > Graph;\n    typedef  vector<vector<int> > Mat;\n\n    // 最大も可\n    // 負の閉路が判定可能\n    //O(V*E)\n    vector<int> bellmanFord(Graph g,int s,vector<int> prev){\n        const int V=g.size();\n        vector<int> d(V,INF);d[s]=0;\n        fill(ALL(prev),-2);\n        REP(k,V){\n            REP(i,V)REP(j,g[i].size()){\n                Edge e=g[i][j];\n                if(d[e.to]>d[e.from]+e.cost){\n                    d[e.to]=d[e.from]+e.cost;\n                    prev[e.to]=e.from;\n                    if(k==V-1)d[e.to]=-INF;\n                }\n            }\n        }\n        return d;\n    }    \n\n    //verified by codoforces 144D http://codeforces.com/contest/144/submission/4976825\n    // // 負の辺がない\n    // // O(E*logV)\n    vector<int> dijkstra(const Graph& g,const int s,vector<int>& prev){\n        const int V=g.size();\n        vector<int> d(V,INF);d[s]=0;\n        fill(ALL(prev), -2);\n        priority_queue<Task,vector<Task>,greater<Task> > que;\n        que.push(Task(-1,s,0));\n        while(!que.empty()){\n            Task task=que.top();que.pop();\n            //if(prev[task.pos]!=-2)continue;\n            if(d[task.pos]<task.cost)continue;\n            prev[task.pos]=task.prev;\n            EACH(e,g[task.pos]){\n                if(d[e->to]>d[e->from]+e->cost){\n                    d[e->to]=d[e->from]+e->cost;\n                    que.push(Task(e->from,e->to,d[e->to]));\n                }\n            }   \n        }\n        return d;\n    }\n    vector<int> dijkstra(const Graph& g,const int s){\n        vector<int> prev(g.size());return dijkstra(g,s,prev);\n    }\n\n    // O(n^3) n≦100\n    void warshall_floyd(Mat& d,Mat& prev){\n        const int V=d.size();\n        REP(k,V)\n            REP(i,V)REP(j,V){\n                if(d[i][j]>d[i][k] + d[k][j]){\n                    d[i][j]=d[i][k] + d[k][j];\n                    prev[i][j]=k;\n                }\n            }\n    }\n}\nusing namespace ShortestPath;\n\nint main(){\n\tint N,M,K;scanf(\"%d %d %d\",&N,&M,&K);\n\tGraph es(N);\n\tREP(i,M){\n\t\tint f,t,d;scanf(\"%d %d %d\",&f,&t,&d);f--;t--;\n\t\tes[f].push_back(Edge(f,t,d));\n\t\tes[t].push_back(Edge(t,f,d));\n\t}\n\tvector<int> ds(N,INF);\n\tREP(i,K){\n\t\tint l;scanf(\"%d\",&l);l--;\n\t\tvector<int> tmp=dijkstra(es,l);\n\n\t\tREP(j,N)ds[j]=min(ds[j],tmp[j]);\n\t}\n\t\n\tdouble res=0;\n\tREP(i,N)REP(j,es[i].size()){\n\t\tdouble l=0,r=es[i][j].cost;\n\t\twhile(r-l>1e-6){\n\t\t\tdouble ml=(2*l+r)/3,mr=(l+2*r)/3;\n\n\t\t\tdouble lv=min(ml+ds[es[i][j].from],es[i][j].cost-ml+ds[es[i][j].to]);\n\t\t\tdouble rv=min(mr+ds[es[i][j].from],es[i][j].cost-mr+ds[es[i][j].to]);\n\t\t\tif(lv<rv){\n\t\t\t\tl=ml;\n\t\t\t}else{\n\t\t\t\tr=mr;\n\t\t\t}\n\t\t}\n\t\tdouble v=min(l+ds[es[i][j].from],es[i][j].cost-l+ds[es[i][j].to]);\n\t\t//DUMP(l);DUMP(v);\n\t\tres=max(res,v);\n\t}\n\tcout <<res <<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3002\nusing namespace std;\ntypedef pair<int,int> P;\nvector<P> G[N];\nbool num[N];\nint n,m,K;\n\ndouble dijkstra(){\n  vector<int> D(N,1e9);\n  priority_queue<P,vector<P>,greater<P> >Q;\n  for(int i=0;i<n;i++)if(num[i]) Q.push(P(0,i)),D[i] = 0;\n  \n  while(!Q.empty()){\n    P t = Q.top();Q.pop();\n    int cost = t.first;\n    int pos = t.second;\n    if(D[pos]<cost) continue;\n\n    for(int i=0;i<G[pos].size();i++){\n      int npos = G[pos][i].first;\n      int ncost = cost+G[pos][i].second;\n      if(D[npos]<=ncost) continue;\n      Q.push(P(ncost,npos));\n      D[npos] = ncost;\n    }\n  }\n\n  double res = 0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<(int)G[i].size();j++){\n      int npos = G[i][j].first;\n      int ncost = G[i][j].second;\n      res = max(res,(D[i]+D[npos]+ncost)/2.0);\n    }\n  return res;\n   \n}\n \nint main(){\n  cin>>n>>m>>K;\n  for(int i=0,a,b,c;i<m;i++){\n    cin>>a>>b>>c;\n    G[a-1].push_back(P(b-1,c));\n    G[b-1].push_back(P(a-1,c));\n  }\n \n  for(int i=0,a;i<K;i++)cin>>a,num[a-1]=1;\n  printf(\"%d\\n\",(int)(dijkstra()+0.5));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<vector>\nusing namespace std;\nconst int INF=1000000000;\ntypedef pair<int,int> P;\nstruct edge{\n\tint to;\n\tint cost;\n};\n\nint main(){\n\tbool bo[3000+2];\n\tfill(bo,bo+3002,false);\n\tint n,m,k,a,b,l,ans=0;\n\tP p[3000+2],q;\n\tvector<edge> ed[3000+2];\n\tpriority_queue<P,vector<P>,greater<P>> que;\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tfor(int i=1;i<=n;i++){p[i].first=INF; p[i].second=i;}\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d%d\",&a,&b,&l);\n\t\tedge e;\n\t\te.to=b;\n\t\te.cost=l;\n\t\ted[a].push_back(e);\n\t\te.to=a;\n\t\ted[b].push_back(e);\n\t}\n\tfor(int i=0;i<k;i++){\n\t\tscanf(\"%d\",&a);\n\t\tp[a].first=0;\n\t\tque.push(p[a]);\n\t}\n\twhile(!que.empty()){\n\t\tq=que.top(); que.pop();\n\t\tif(!bo[q.second]){\n\t\t\tbo[q.second]=true;\n\t\t\tint s=ed[q.second].size();\n\t\t\tfor(int i=0;i<s;i++){\n\t\t\t\tif(p[ed[q.second][i].to].first>p[q.second].first+ed[q.second][i].cost){\n\t\t\t\t\tp[ed[q.second][i].to].first=p[q.second].first+ed[q.second][i].cost;\n\t\t\t\t\tque.push(p[ed[q.second][i].to]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(p[i].first>ans)ans=p[i].first;\n\t\tint s=ed[i].size();\n\t\tfor(int j=0;j<s;j++){\n\t\t\tif(ans*2<p[i].first+p[ed[i][j].to].first+ed[i][j].cost)ans=(p[i].first+p[ed[i][j].to].first+ed[i][j].cost+(p[i].first+p[ed[i][j].to].first+ed[i][j].cost)%2)/2;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst int INF = 1 << 30;\n\nstruct Edge\n{\n\tint to, cost;\n\tEdge(int to, int cost) \n\t\t: to(to), cost(cost)\n\t{ }\n};\n\nint main()\n{\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\t\n\tvint d(n, INF);\n\tpriority_queue<pint, vector<pint>, greater<pint> > que;\n\tvector<vector<Edge> > edges(n, vector<Edge>());\n\t\n\trep(i, m)\n\t{\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\t\n\t\tedges[a - 1].push_back(Edge(b - 1, c));\n\t\tedges[b - 1].push_back(Edge(a - 1, c));\n\t}\n\t\n\trep(i, k)\n\t{\n\t\tint f;\n\t\tcin >> f;\n\t\t\n\t\td[f - 1] = 0;\n\t\t\n\t\tque.push(mp(0, f - 1));\n\t}\n\t\n\t\n\t// ショッピングモールがある街を距離０として他の街へダイクストラで最短路探索\n\tfor(; !que.empty(); que.pop())\n\t{\n\t\tpint p(que.top());\n\t\tint v = p.second;\n\t\t\n\t\tif(d[v] < p.first) continue;\n\t\t\n\t\trep(i, edges[v].size())\n\t\t{\n\t\t\tEdge e(edges[v][i]);\n\t\t\t\n\t\t\tif(d[v] + e.cost < d[e.to])\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\t\n\t\t\t\tque.push(mp(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t// 辺上の最大値を探すO(m)\n\tdouble res = 0;\n\trep(i, n) \n\t{\n\t\trep(j, edges[i].size())\n\t\t{\n\t\t\tEdge &e = edges[i][j];\n\t\t\t\n\t\t\tdouble tmp1 = min(d[i], d[e.to]) + e.cost / 2.0;\n\t\t\tdouble tmp2 = min(d[e.to] + e.cost - 1, d[i] + 1);\n\t\t\t\n\t\t\tchmax(res, max(tmp1, tmp2));\n\t\t}\n\t\t\n\t\tchmax(res, d[i]);\n\t}\n\t\n\tcout << round(res) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define INF (1<<29)\n\ntypedef pair<int,int>P;\n\nstruct edge{\n  int to,cost;\n  edge(int to, int cost):to(to),cost(cost){}\n};\n\nint N,M,K;\nvector<edge>G[3005];\nint A[100005],B[100005],L[100005];\nint s[3005];\nint dist[3005];\n\nvoid dijkstra(){\n  fill(dist, dist+N, INF);\n  priority_queue<P, vector<P>, greater<P> >q;\n  rep(i,K){\n    dist[s[i]] = 0;\n    q.push(P(0, s[i]));\n  }\n\n  while(!q.empty()){\n    P p = q.top(); q.pop();\n    int v = p.second;\n    if(dist[v] < p.first) continue;\n    rep(i,G[v].size()){\n      edge e = G[v][i];\n      if(dist[e.to] > dist[v] + e.cost){\n\tdist[e.to] = dist[v] + e.cost;\n\tq.push(P(dist[e.to], e.to));\n      }\n    }\n  }\n}\n\nint main(){\n  scanf(\"%d%d%d\", &N,&M,&K);\n  rep(i,M){\n    int a,b,l;\n    scanf(\"%d%d%d\", &a,&b,&l); a--; b--;\n    G[a].push_back(edge(b,l));\n    G[b].push_back(edge(a,l));\n    A[i] = a; B[i] = b; L[i] = l;\n  }\n\n  rep(i,K){\n    scanf(\"%d\", s+i);\n    s[i]--;\n  }\n  dijkstra();\n  int res = 0;\n  rep(i,N) res = max(res, dist[i]);\n  rep(i,M) res = max(res, (dist[A[i]]+dist[B[i]]+L[i]+1)/2);\n    \n  printf(\"%d\\n\", res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing P = pair<int, int>;\n\nstruct edge {\n    int to, weight;\n};\n\nconstexpr int INF = 1e9;\n\nint main() {\n    int N, M, K;\n    cin >> N >> M >> K;\n    vector<vector<edge>> g(N);\n    for(int i=0; i<M; ++i) {\n        int a, b, l;\n        cin >> a >> b >> l;\n        a--; b--;\n        g[a].push_back((edge){b, l});\n        g[b].push_back((edge){a, l});\n    }\n\n    priority_queue<P, vector<P>, greater<P>> que;\n    vector<int> d(N, INF);\n    for(int i=0; i<K; ++i) {\n        int s;\n        cin >> s;\n        s--;\n        que.push(make_pair(0, s));\n        d[s] = 0;\n    }\n\n    while(!que.empty()) {\n        P p = que.top();\n        que.pop();\n        int v = p.second;\n        if(d[v] < p.first) {\n            continue;\n        }\n        for(auto& e : g[v]) {\n            if(d[e.to] > d[v] + e.weight) {\n                d[e.to] = d[v] + e.weight;\n                que.push(make_pair(d[e.to], e.to));\n            }\n        }\n    }\n\n    double res = 0;\n    for(int i=0; i<N; ++i) {\n        res = max(res, (double)d[i]);\n        for(int j=0; j<g[i].size(); ++j) {\n            res = max(res, (d[i] + d[g[i][j].to] + g[i][j].weight) / 2.0);\n        }\n    }\n    cout << (int)floor(res + 0.5) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int,int> pint;\nstruct edge{\n    int dst,weight;\n};\nvector<edge> road[3001];\nint inf=1000000000;\n\nint main(){\n    priority_queue<pint,vector<pint>,greater<pint> > pq;\n    int n,m,k;\n    cin>>n>>m>>k;\n    int a,b,l;\n    edge ed;\n    for(int i=0;i<m;++i){\n        cin>>a>>b>>l;\n        ed.dst=b-1;ed.weight=l;road[a-1].push_back(ed);\n        ed.dst=a-1;ed.weight=l;road[b-1].push_back(ed);\n    }\n    int d[3001];\n    for(int i=0;i<n;++i) d[i]=inf;\n    for(int i=0;i<k;++i){\n        cin>>a;d[a-1]=0;\n        pq.push(make_pair(0,a-1));\n    }\n    while(!pq.empty()){\n        pint pi=pq.top();pq.pop();\n        int t=pi.second;\n        for(vector<edge>::iterator it=road[t].begin();it!=road[t].end();++it){\n            if(d[it->dst]>d[t]+it->weight){\n                d[it->dst]=d[t]+it->weight;\n                pq.push(make_pair(d[it->dst],it->dst));\n            }\n        }\n    }\n    int ans=0;\n    for(int i=0;i<n;++i){\n        for(int j=0;j<road[i].size();++j){\n            if(j!=i&&d[i]!=inf&&d[road[i][j].dst]!=inf){\n                ans=max(ans,(d[i]+d[road[i][j].dst]+road[i][j].weight+1)/2);\n            }\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nconst int INF = 1e9;\nconst int MAX_N = 3010, MAX_E = 10000;\nint n, m; //????????° ???????????¬??°\nvector<pair<int, int> > G[MAX_N];//??°???????????¨?????£??\\????????? fi:to se:cost\nint d[MAX_N]; //s?????????????????????\ntypedef pair<int, int> P;//first??????????????¢,second??????????????????\nint k; vector<int> shop;//???????¨????\n\nvoid dijkstra(void){\n\tpriority_queue<P, vector<P>, greater<P> > que;//first????°?????????????\n    rep(i, n)d[i] = INF;//?????????\n    \n    //k????????????????????°????????????\n    for(auto i : shop){\n    \td[i] = 0;\n    \tque.push(make_pair(0, i));\n    }\n  \n    while(!que.empty()){\n       \tauto p = que.top(); que.pop();\n       \tint v = p.second;\n       \tif(d[v] < p.first) continue;\n       \tfor(auto e : G[v]){//e.fi:??£??\\??????????????????????????? e.se:?????????????????§????????????\n       \t\tif(d[e.first] > d[v] + e.second){//???????????¢?????´??°???????????¨???\n       \t\t\td[e.first] = d[v] + e.second;\n       \t\t\tque.push(make_pair(d[e.first], e.first));\n       \t\t}\n       \t}\n    }\n}\n\nint main(void){\n    cin >> n >> m >> k;\n    rep(i, m){\n        int a, b, l; cin >> a >> b >> l;\n        a--; b--;\n       \tG[a].push_back(make_pair(b, l)); G[b].push_back(make_pair(a, l));\n    }\n    rep(i, k){\n    \tint s; cin >> s; s--;\n    \tshop.push_back(s);\n    }\n    dijkstra();//????????????????????????????°?????????????\n    //?????????????????¶????????????????°?????????????\n    int ans = 0;\n    //??????????????????????????¢????????¨???????????????????????¶???????????´?????????????????????????????¢?????????\n    // rep(i, n) printf(\"%d\\n\", d[i]);\n   \tfor (int x = 0; x < n; ++x){\n   \t\tfor(auto y : G[x]){\n   \t\t\tif(d[x] == 0 || d[y.first] == 0) continue;\n   \t\t\tint tmp = round((d[x] + d[y.first] + y.second + 1) / 2.0);//+1????????¨?????\\??¨\n   \t\t\tans = max(tmp, ans);\n   \t\t}\n   \t}\n   \tcout << ans << endl;\n   \treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define Rep(i, N) for(int i = 0; i < N; i++)\n#define fi first\n#define se second\n#define pb push_back\ntypedef pair<int, int> Pi;\nconst int LLINF = 1LL << 60;\n\ninline int llabs(int n) { return n < 0 ? -n : n; }\n\nstruct Edge {\n  int to, cost;\n};\n\nvector< Edge > G[3005];\nint mc[3005];\nint N, M, K;\n\nvoid Dijkstra(int s)\n{\n  priority_queue < Pi, vector< Pi >, greater< Pi > > pq;\n  \n  pq.push(Pi(0, s)); mc[s] = 0;\n  while(!pq.empty()) {\n    int v = pq.top().se, w = pq.top().fi; pq.pop();\n    if(mc[v] < w) continue;\n    cout << v + 1 << \" \" << w << endl;\n    Rep(i, G[v].size()) {\n      int u = G[v][i].to, nw = w + G[v][i].cost;\n      if(nw < mc[u]) {\n\tcout << \" \" << u + 1 << \" \" << nw << endl;\n\tmc[u] = nw; pq.push(Pi(nw, u));\n      }\n    }\n  }\n}\n\nint A[100005], B[100005], C[100005];\nsigned main()\n{\n  int ans = 0;\n  int k;\n  \n  cin >> N >> M >> K;\n  Rep(i, M) {\n    cin >> A[i] >> B[i] >> C[i]; --A[i], --B[i];\n    G[A[i]].pb( (Edge) { B[i], C[i] } );\n    G[B[i]].pb( (Edge) { A[i], C[i] } );\n  }\n\n  fill_n(mc, 3005, LLINF);\n  Rep(i, K) {\n    cin >> k; --k;\n    Dijkstra(k);\n  }\n\n  Rep(i, N) ans = max(ans, mc[i]);\n  Rep(i, M) {\n    ans = max(ans, min(mc[A[i]], mc[B[i]]) + (llabs(A[i] - B[i]) + C[i] + 1) / 2);\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3002\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<P> G[N];\nbool num[N];\nint n,m,K;\n\ndouble dijkstra(){\n  int D[N];\n  for(int i=0;i<N;i++) D[i] = 1e9;\n  \n  vector<int>pre[N];\n  priority_queue<PP,vector<PP>,greater<PP> >Q;\n  for(int i=0;i<n;i++)if(num[i]) Q.push(PP(0,P(i,-1))),D[i] = 0;\n  \n  \n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first;\n    int pos = t.second.first;\n    int ppos = t.second.second;\n    \n    if(D[pos]<cost) continue;\n    if(ppos>=0)pre[pos].push_back(ppos);\n    \n    for(int i=0;i<G[pos].size();i++){\n      int npos = G[pos][i].first;\n      int ncost = cost+G[pos][i].second;\n      if(D[npos]<ncost) continue;\n      Q.push(PP(ncost,P(npos,pos)));\n      D[npos] = ncost;\n    }\n  }\n\n\n  double res = 0;\n  for(int i=0;i<n;i++){\n    res = max(res,D[i]/2.0);\n\n    for(int j=0;j<(int)G[i].size();j++){\n      int npos = G[i][j].first;\n      int ncost = G[i][j].second;\n      int a=(int)((D[i]+D[npos]+ncost)/2.0+0.5);\n      if((pre[i].size()==1&&pre[i][0]==npos)||\n\t (pre[npos].size()==1&&pre[npos][0]==i))continue;\n      res = max(res,(D[i]+D[npos]+ncost)/2.0);\n    }\n  }\n  return res;\n   \n}\n \nint main(){\n  cin>>n>>m>>K;\n  for(int i=0,a,b,c;i<m;i++){\n    cin>>a>>b>>c;\n    G[a-1].push_back(P(b-1,c));\n    G[b-1].push_back(P(a-1,c));\n  }\n \n  for(int i=0,a;i<K;i++)cin>>a,num[a-1]=1;\n  printf(\"%d\\n\",(int)(dijkstra()+0.5));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<utility>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#define INF 10000000\nusing namespace std;\nvoid solve();\ntypedef pair<int,int> pii;\ntypedef pair<int,pii > pipii;\n\nint N,M,K,ANS = 0;\nint G[3010][3010] = {0};\nint D[3010];\npriority_queue<pipii,vector<pipii>,greater<pipii> > que;\n\nint main()\n{\n    scanf(\"%d%d%d\",&N,&M,&K);\n    for(int i = 1 ; i < N + 1; i++)D[i] = INF;\n    for(int i = 0; i < M; i++)\n    {\n        int a,b,l;\n        scanf(\"%d%d%d\",&a,&b,&l);\n        G[a][b] = G[b][a] = l;\n    }\n    for(int i = 0 ; i < K; i++)\n    {\n        int a;\n        scanf(\"%d\",&a);\n        for(int j = 1; j < N + 1; j++)\n        {\n            if(G[a][j] != 0)\n            {\n                D[a] = 0;\n                pipii test;\n                test.first = G[a][j];test.second.first = a;test.second.second = j;\n                que.push(test);\n            }\n        }\n    }\n    solve();\n    printf(\"%d\\n\",ANS);\n    return 0;\n}\nvoid solve()\n{\n    while(que.size())\n    {\n        pipii now = que.top();\n        que.pop();\n        if(D[now.second.second] == INF)\n        {\n            D[now.second.second] = now.first;\n            for(int i = 1; i < N + 1; i++)\n            {\n                if(G[now.second.second][i] != 0 && i != now.second.first && i != now.second.second)\n                {\n                    pipii test;\n                    test.first = now.first + G[now.second.second][i];\n                    test.second.first = now.second.second;\n                    test.second.second = i;\n                    que.push(test);\n                }\n            }\n        }\n        else\n        {\n            ANS = max(ANS,(int)((double)(now.first + D[now.second.second]) / 2 + 0.5));\n        }\n    }\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\nusing namespace std;\n\nvector<int>x[4000];\nint n,m,a,b,c,k,G;\nint s[4000],d[4000];\nint X[4000];\ndouble maxn;int res;\n\nint main(){\n\tmemset(X,63,sizeof(X));\n\tcin>>n>>m>>k;\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>a>>b>>c;\n\t\tx[a].push_back(b*10000+c);\n\t\tx[b].push_back(a*10000+c);\n\t}\n\tfor(int i=0;i<k;i++){\n\t\tcin>>a;\n\t\ts[a]=1;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(s[i]==1){\n\t\t\tmemset(d,63,sizeof(d));\n\t\t\td[i]=0;\n\t\t\tif(n<500){G=n;}\n\t\t\telse{\n\t\t\t\tG=max(25,(n+k)/k+10);\n\t\t\t}\n\t\t\tfor(int h=1;h<=G;h++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tif(d[j]<100000000){\n\t\t\t\t\t\tfor(int k=0;k<x[j].size();k++){\n\t\t\t\t\t\t\td[x[j][k]/10000]=min(d[x[j][k]/10000],d[j]+x[j][k]%10000);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tX[j]=min(X[j],d[j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tmaxn=max((int)maxn,X[i]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<x[i].size();j++){\n\t\t\tif(abs(X[i]-X[x[i][j]/10000])<x[i][j]%10000){\n\t\t\t\ta=x[i][j]%10000-abs(X[i]-X[x[i][j]/10000]);\n\t\t\t\tmaxn=max(maxn,(double)(max(X[i],X[(int)(x[i][j]/10000)])+1.0*a/2.0));\n\t\t\t}\n\t\t}\n\t}\n\tres=(1.0*maxn+0.99999999);\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF (1<<29)\n\ntypedef pair<int, int> pii;\n\nint d[3000][3000]; // ???i, j????????¢\nint minCost[3000]; // ???i????????§???????????°??¢???????????§??????????????¢\nbool shop[3000]; // ???i????????§???????????°??¢??????????????????\nvector<pii> g[3000]; // to, cost\nint n, m, k;\n\nint main() {\n\tcin >> n >> m >> k;\n\t\n\tfill(d[0], d[n], INF);\n\tfill(minCost, minCost + n, INF);\n\t\n\tREP(i, m) {\n\t\tint a, b, l;\n\t\tscanf(\"%d %d %d\", &a, &b, &l);\n\t\ta--; b--;\n\t\tg[a].push_back(pii(b, l));\n\t\tg[b].push_back(pii(a, l));\n\t\td[a][b] = d[b][a] = l;\n\t}\n\t\n\tREP(i, k) {\n\t\tint pos;\n\t\tscanf(\"%d\", &pos);\n\t\tpos--;\n\t\tshop[pos] = true;\n\t}\n\t\n\tREP(i, n) {\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > pq; // cost, pos\n\t\tpq.push(pii(0, i));\n\t\t\n\t\tvector<int> dist(n, INF);\n\t\twhile (!pq.empty()) {\n\t\t\tpii now = pq.top(); pq.pop();\n\t\t\t\n\t\t\tint ncost = now.first;\n\t\t\tint npos = now.second;\n\t\t\t\n\t\t\tif (dist[npos] <= ncost) continue;\n\t\t\tdist[npos] = ncost;\n\t\t\tif (shop[npos]) {\n\t\t\t\tminCost[i] = dist[npos];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tREP(j, g[npos].size()) pq.push(pii(ncost + g[npos][j].second, g[npos][j].first)); \n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tREP(i, n) FOR(j, i + 1, n) {\n\t\tif (d[i][j] == INF) continue;\n\t\tans = max(ans, (minCost[i] + minCost[j] + d[i][j] + 1) / 2);\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF (1<<29)\n\ntypedef pair<int, int> pii;\n\nint d[3000][3000]; // ???i, j????????¢\nint minCost[3000]; // ???i????????§???????????°??¢???????????§??????????????¢\nint shop[3000];\nvector<pii> g[3000]; // to, cost\nint n, m, k;\n\nint main() {\n\tcin >> n >> m >> k;\n\t\n\tfill(d[0], d[n], INF);\n\tfill(minCost, minCost + n, INF);\n\t\n\tREP(i, m) {\n\t\tint a, b, l;\n\t\tscanf(\"%d %d %d\", &a, &b, &l);\n\t\ta--; b--;\n\t\tg[a].push_back(pii(b, l));\n\t\tg[b].push_back(pii(a, l));\n\t}\n\t\n\tREP(i, k) {\n\t\tint pos;\n\t\tscanf(\"%d\", &pos);\n\t\tpos--;\n\t\tshop[i] = pos;\n\t}\n\t\n\t// i, j?????????????????¢???dijkstra??§?±???????\n\tREP(i, n) {\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > pq; // cost, pos\n\t\tpq.push(pii(0, i));\n\t\t\n\t\twhile (!pq.empty()) {\n\t\t\tpii now = pq.top(); pq.pop();\n\t\t\t\n\t\t\tint ncost = now.first;\n\t\t\tint npos = now.second;\n\t\t\t\n\t\t\tif (d[i][npos] <= ncost) continue;\n\t\t\td[i][npos] = ncost;\n\t\t\t\n\t\t\tREP(j, g[npos].size()) pq.push(pii(ncost + g[npos][j].second, g[npos][j].first)); \n\t\t}\n\t}\n\t\n\t// minCost????±???????\n\tREP(i, n) {\n\t\tint cost = INF;\n\t\tREP(j, k) cost = min(cost, d[i][shop[j]]);\n\t\tminCost[i] = cost;\n\t}\n\t\n\tint ans = 0;\n\tREP(i, n) REP(j, g[i].size()) {\n\t\tint to = g[i][j].first;\n\t\tans = max(ans, (minCost[i] + minCost[to] + g[i][j].second + 1) / 2);\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n\n//1:20"
  },
  {
    "language": "C++",
    "code": "//Name: Shopping in JOI Kingdom\n//Level: 3\n//Category: グラフ,Graph,最短経路\n//Note:\n\n/*\n * とりあえず道の途中に家があるときのことは考えず，各頂点についてショッピングモールからの\n * 最短距離を求める．\n * これは各ショッピングモールを始点としたダイクストラで求められる．\n * ただしナイーブにやると最大ケースで死にそうなので，ダイクストラの途中で他のショッピングモールに\n * ぶつかった場合はそこで枝刈りするようにした．\n *\n * ある2頂点があって，それぞれのショッピングモールへの最短距離がaとbで距離lの辺でつながっているとき，\n * この辺上での最遠点では\n * a+ul == b+(1-u)l\n * が成立しているはずであるから，各aとbの組について方程式を解いてulを求め，最大のa+ulを選べばそれが解となる．\n * (最短距離の定義より，min(a,b)+l >= max(a,b)であることに注意)\n */\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nstruct Road {\n    int from, to;\n    int len;\n\n    Road() {}\n    Road(int f, int t, int l) : from(f), to(t), len(l) {}\n};\n\nvector<Road> roads_of[3000];\nbool is_shopping_mall[3000];\nint min_dist[3000];\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    int N, M, K;\n    cin >> N >> M >> K;\n    for(int i = 0; i < M; ++i) {\n        int a, b, l;\n        cin >> a >> b >> l;\n        --a; --b;\n        roads_of[a].push_back(Road(a, b, l));\n        roads_of[b].push_back(Road(b, a, l));\n    }\n    fill_n(is_shopping_mall, N, false);\n    for(int i = 0; i < K; ++i) {\n        int a;\n        cin >> a;\n        --a;\n        is_shopping_mall[a] = true;\n    }\n    fill_n(min_dist, N, INT_MAX);\n\n    static int memo[3000];\n    fill_n(memo, N, INT_MAX);\n    for(int start = 0; start < N; ++start) {\n        if(!is_shopping_mall[start]) continue;\n        priority_queue<pair<int, int> > q;\n        q.push(make_pair(0, start));\n        memo[start] = 0;\n        while(!q.empty()) {\n            int cost = -q.top().first;\n            int pos = q.top().second;\n            q.pop();\n            if(memo[pos] < cost) continue;\n            min_dist[pos] = min(min_dist[pos], cost);\n\n            for(vector<Road>::iterator it = roads_of[pos].begin(); it != roads_of[pos].end(); ++it) {\n                if(is_shopping_mall[it->to]) continue;\n\n                int nc = cost + it->len;\n                if(memo[it->to] > nc) {\n                    memo[it->to] = nc;\n                    q.push(make_pair(-nc, it->to));\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n    for(int i = 0; i < N; ++i) {\n        int d = 0;\n        const int a = min_dist[i];\n        // a+ul == b+vl, u+v == 1\n        // a+ul == b+(1-u)l\n        // 2ul == b-a+l\n        // ul == (b-a+l)/2\n        for(vector<Road>::iterator it = roads_of[i].begin(); it != roads_of[i].end(); ++it) {\n            const int b = min_dist[it->to];\n            if(b >= a) {\n                int ul = (b-a+it->len) / 2;\n                if((b-a+it->len) % 2 == 1) ++ul;\n                d = max(d, min_dist[i] + ul);\n            }\n        }\n        ans = max(ans, d);\n    }\n\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nvector<P>E[3000];\nint d[3000];\nint main() {\n\tint n, m, k; scanf(\"%d%d%d\", &n, &m, &k);\n\trep(i, m) {\n\t\tint a, b, l; scanf(\"%d%d%d\", &a, &b, &l);\n\t\ta--; b--;\n\t\tE[a].push_back(P(l, b));\n\t\tE[b].push_back(P(l, a));\n\t}\n\tpriority_queue<P, vector<P>, greater<P>>que;\n\tmemset(d, 0x3f, sizeof(d));\n\trep(i, k) {\n\t\tint s; scanf(\"%d\", &s); s--;\n\t\td[s] = 0;\n\t\tque.push(P(0, s));\n\t}\n\twhile (!que.empty()) {\n\t\tP p = que.top(); que.pop();\n\t\tif (d[p.second] != p.first)continue;\n\t\tfor (P u : E[p.second]) {\n\t\t\tif (d[u.second] > p.first + u.first) {\n\t\t\t\td[u.second] = p.first + u.first;\n\t\t\t\tque.push(P(d[u.second], u.second));\n\t\t\t}\n\t\t}\n\t}\n\tdouble Max = 0;\n\trep(i, n) {\n\t\tfor (P u : E[i]) {\n\t\t\tdouble t = (u.first + abs(d[i] - d[u.second])) / 2.;\n\t\t\tMax = max(Max, min(d[i], d[u.second]) + t);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", (int)round(Max));\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int inf = (int)1e9;\n\nint main()\n{\n\tint n, m, k;\n\tint ans = 0;\n\tvector<int> dist;\n\tvector<vector<pair<int, int> > > graph;\n\tvector<pair<pair<int, int>, int> > edge;\n\t\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tdist.resize(n, inf);\n\tgraph.resize(n);\n\tedge.reserve(m);\n\tfor(int i = 0; i < m; ++i) {\n\t\tint a, b, l;\n\t\tscanf(\"%d%d%d\", &a, &b, &l);\n\t\ta -= 1, b -= 1;\n\t\tedge.push_back(make_pair(make_pair(a, b), l));\n\t\tgraph[a].push_back(make_pair(b, l));\n\t\tgraph[b].push_back(make_pair(a, l));\n\t}\n\t\n\tpriority_queue<pair<int, int> > q;\n\t\t\n\tfor(int i = 0; i < k; ++i) {\n\t\t\n\t\tint s;\n\t\tscanf(\"%d\", &s);\n\t\ts -= 1;\n\t\t\n\t\tq.push(make_pair(0, s));\n\t}\n\t\n\twhile(!q.empty()) {\n\t\t\n\t\tint v = q.top().second;\n\t\tint c = -q.top().first;\n\t\tq.pop();\n\t\t\n\t\tif(dist[v] < c)\n\t\t\tcontinue;\n\t\tdist[v] = c;\n\t\t\n\t\tfor(int i = 0; i < graph[v].size(); ++i) {\n\t\t\tint w = graph[v][i].first;\n\t\t\tint d = graph[v][i].second + c;\n\t\t\tq.push(make_pair(-d, w));\n\t\t}\n\t}\n\t\n\t//for(int i = 0; i < n; ++i)\n\t//\tprintf(\"[debug] %d -> %d\\n\", i, dist[i]);\n\t\n\tfor(int i = 0; i < m; ++i) {\n\t\t\n\t\tint a = edge[i].first.first;\n\t\tint b = edge[i].first.second;\n\t\tint l = edge[i].second;\n\t\tint cost;\n\t\t\n\t\tif(dist[a] > dist[b])\n\t\t\tswap(a, b);\n\t\t\n\t\tif(dist[a] + l == dist[b])\n\t\t\tcost = dist[b];\n\t\telse\n\t\t\tcost = (l - (dist[b] - dist[a]) + 1) / 2 + dist[b];\n\t\tans = max(ans, cost);\n\t\t//printf(\"[debug] (%d, %d) -> (%d, %d) -> %d -> %d\\n\", a, dist[a], b, dist[b], l, cost);\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nconst int INF = 1e9;\nconst int MAX_N = 3010, MAX_E = 10000;\nint n, m; //????????° ???????????¬??°\nvector<pair<int, int> > G[MAX_N];//??°???????????¨?????£??\\????????? fi:to se:cost\nint d[MAX_N]; //s?????????????????????\ntypedef pair<int, int> P;//first??????????????¢,second??????????????????\nint k; vector<int> shop;//???????¨????\n\nvoid dijkstra(void){\n\tpriority_queue<P, vector<P>, greater<P> > que;//first????°?????????????\n    rep(i, n)d[i] = INF;//?????????\n    \n    //k????????????????????°????????????\n    for(auto i : shop){\n    \td[i] = 0;\n    \tque.push(make_pair(0, i));\n    }\n  \n    while(!que.empty()){\n       \tauto p = que.top(); que.pop();\n       \tint v = p.second;\n       \tif(d[v] < p.first) continue;\n       \tfor(auto e : G[v]){\n       \t\tif(d[e.first] > d[v] + e.second){//???????????¢?????´??°???????????¨???\n       \t\t\td[e.first] = d[v] + e.second;\n       \t\t\tque.push(make_pair(d[e.first], e.second));\n       \t\t}\n       \t}\n    }\n}\n\nint main(void){\n    cin >> n >> m >> k;\n    rep(i, m){\n        int a, b, l; cin >> a >> b >> l;\n        a--; b--;\n       \tG[a].push_back(make_pair(b, l)); G[b].push_back(make_pair(a, l));\n    }\n    rep(i, k){\n    \tint s; cin >> s; s--;\n    \tshop.push_back(s);\n    }\n    dijkstra();//????????????????????????????°?????????????\n    //?????????????????¶????????????????°?????????????\n    int ans = 0;\n    //??????????????????????????¢????????¨???????????????????????¶???????????´?????????????????????????????¢?????????\n    // rep(i, n) printf(\"%d\\n\", d[i]);\n   \tfor (int x = 0; x < n; ++x){\n   \t\tfor(auto y : G[x]){\n   \t\t\tif(d[x] == 0 || d[y.first] == 0) continue;\n   \t\t\tint tmp = (d[x] + d[y.first] + y.second + 1) / 2;//+1????????¨?????\\??¨\n   \t\t\tans = max(tmp, ans);\n   \t\t}\n   \t}\n   \tcout << ans << endl;\n   \treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nstruct edge { int to, cost; edge(int to, int cost) : to(to), cost(cost) {} };\ntypedef vector<edge> edges;\n\nedges G[3010];\nint d[100010];\n\nvoid dijkstra(int s)\n{\n    priority_queue<pii, vpii, greater<pii> > pq;\n    d[s] = 0;\n    pq.push(pii(0, s));\n    \n    while (pq.size()) {\n        pii p = pq.top(); pq.pop();\n\n        int v = p.scd;\n\n        if (d[v] < p.fst) continue;\n\n        for (edge &e : G[v]) {\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                pq.push(pii(d[e.to], e.to));\n            }\n        }\n    }\n}\n\nsigned main()\n{\n    int N, M, K; cin >> N >> M >> K;\n\n    fill_n(d, N + 1, inf);\n\n    rep(i, M) {\n        int a, b, l; cin >> a >> b >> l;\n        a--, b--;\n\n        G[a].PB(edge(b, l));\n        G[b].PB(edge(a, l));\n    }\n\n    rep(i, K) {\n        int s; cin >> s;\n        s--;\n        dijkstra(s);\n    }\n\n    int ma = -1;\n\n    rep(i, N) {\n        for (edge &e : G[i]) {\n            ma = max(ma, (int)(d[i] + round(1. * (d[e.to] - d[i] + e.cost) / 2)));\n        }\n    }\n\n    cout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//  Shopping in JOI Kingdom.cpp\n//  2013/01/06.\n\n#if 1\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst int INF = 1<<30;\n\nint N, M, K;\nint D[3000];\nint C[3000][3000];\n\nint dfs(int pnt)\n{\n\trep(next, N) if(D[next] > D[pnt] + C[pnt][next])\n\t{\n\t\tD[next] = D[pnt] + C[pnt][next];\n\t\tdfs(next);\n\t}\n}\n\nvoid dijkstra(int pnt)\n{\n\tbool bUpdate = true;\n\t\n\twhile(bUpdate)\n\t{\n\t\tbUpdate = false;\n\t\tint best = INF, next = 0;\n\t\t\n\t\trep(_next, N) if(D[_next] > D[pnt] + C[pnt][_next])\n\t\t{\n\t\t\tD[_next] = D[pnt] + C[pnt][_next];\n\t\t\n\t\t\tif(best > D[_next]) next = _next;\n\t\t\t\n\t\t\tbUpdate = true;\n\t\t}\n\t\t\n\t\tpnt = next;\n\t}\n}\n\nint calc(int a, int b, int l)\n{\n\treturn round(min(a, b) + (l + max(a, b) - min(a, b)) / 2.0);\n}\n\nint main()\n{\n\trep(i, 3000) rep(j, 3000) D[i] = C[i][j] = INF;\n\t\n\tcin >> N >> M >> K;\n\n\trep(m, M)\n\t{\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\t\n\t\tC[a-1][b-1] = C[b-1][a-1] = c;\n\t}\n\t\n\trep(k, K)\n\t{\n\t\tint s;\n\t\tcin >> s;\n\t\t\n\t\tD[s-1] = 0;\n\t\tdijkstra(s-1);\n\t}\n\t\n\n\tint ans = 0;\n\t\n\trep(a, N) REP(b, a+1, N) if(C[a][b] < INF) chmax(ans, calc(D[a], D[b], C[a][b]));\n\t\n\tcout << ans << endl;\n}\n\n#endif"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<cstdio>\n#include<cmath>\n#include<stack>\n#define F first\n#define S second\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef vector<P> VP;\ntypedef vector<int> VI;\ntypedef vector<VP> VVP;\ntypedef vector<VI> VVI;\nclass Pox\n{\npublic:\n  int cost,now;\n  Pox():cost(0),now(0){}\n  Pox(int now,int cost):now(now),cost(cost){}\n};\n\nclass ope{\npublic:\n  bool operator() (Pox a,Pox b)\n  {\n    return a.cost > b.cost;\n  }\n};\n\nconst int INF = (1<<28);\nint N,M,K;\nVVP G;\nVVI mincost;\nVI Shop;\nmap<P,int> D;\nmap<int,bool> S;\nint main()\n{\n  scanf(\"%d %d %d\",&N,&M,&K);\n  G.resize(N),mincost.resize(N);\n  for(int i=0;i<N;i++)\n    {\n      mincost[i].resize(N);\n      for(int j=0;j<N;j++)\n\tmincost[i][j] = INF;\n    }\n\n  for(int i=0;i<M;i++)\n    {\n      int a,b,c;\n      scanf(\"%d %d %d\",&a,&b,&c);\n      a--,b--;\n      G[a].push_back(P(b,c));\n      G[b].push_back(P(a,c));\n      D[P(a,b)] = D[P(b,a)] = c;\n    }\n\n  priority_queue<Pox,vector<Pox>,ope> Q;\n  for(int i=0;i<K;i++)\n    {\n      int a;\n      scanf(\"%d\",&a);\n      a--;\n      Shop.push_back(a);\n      Q.push(Pox(a,0));\n      mincost[a][a] = 0;\n      S[a] = true;\n    }\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.top(); Q.pop();\n      int now = pox.now;\n      int total = pox.cost;\n      //cout << \"pop! now = \" << now << \" total = \" << total << endl;\n      for(int i=0;i<G[now].size();i++)\n\t{     \n\t  P p = G[now][i];\n\t  int to = p.F;\n\t  int cost = p.S;\n\t  if(mincost[now][to] <= total + cost)\n\t    continue;\n\n\t  mincost[now][to] = total + cost;\n\t  //cout << \"update! to = \" << to << \" cost = \" << cost << \" min = \" << total+cost << endl;\n\t  Q.push(Pox(to,total+cost));\n\t}\n    }\n\n\n  double mex = 0;\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      if(j != i && mincost[i][j] != INF && mincost[j][i] != INF && !S[i] && !S[j])\n\t{\n\t  /*\n\t  if(mex < (double)(mincost[i][j]+mincost[j][i]+D[P(i,j)])/2.0)\n\t    {\n\t      cout << i  << \" - \" << j << endl;\n\t      cout << \"mincost[\"<<i<<\"][\"<<j<<\"] = \" << mincost[i][j]<< endl;\n\t      cout << \"mincost[\"<<j<<\"][\"<<i<<\"] = \" << mincost[j][i]<< endl;\n\t      cout << \"now mex = \"<< mex << \" aft= \"<<(mincost[i][j]+mincost[j][i]+D[P(i,j)])/2.0 << endl;\n\t    }\n\t  */\n\t  mex = max(mex,(double)(mincost[i][j]+mincost[j][i]+D[P(i,j)])/2.0 );\n\t}\n  cout << round(mex) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define M 100000007\ntypedef pair<int,int> P;\n/*int main(){\n\tcout<<8979879<<endl;\n}*/\nint ri[3001][3001];\nint main(void){\n\tint n,m,k,\n\t\ti,j,\n\t\tmx,t,ans,\n\t\ta[100001],b[100001],l[100001],s[3000],\n\t\td[3001];\n\t\t\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\n\tcin>>n>>m>>k;\n\tfor(i=0;i<m;i++) cin>>a[i]>>b[i]>>l[i];\n\tfor(i=0;i<k;i++) cin>>s[i];\n//\tfor(i=0;i<k;i++) cout<<s[i]<<endl;\n\t\n\tfor(i=1;i<=n;i++) for(j=1;j<=n;j++) ri[i][j]=M;\n\tfor(i=0;i<m;i++) ri[a[i]][b[i]]=l[i],ri[b[i]][a[i]]=l[i];\n/*\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++)cout<<ri[i][j]<<' ';\n\t\tcout<<endl;\n\t}*/\n\t\n\tint leng[3001];\n\tfor(i=1;i<=n;i++) leng[i]=M;\n\tfor(i=0;i<k;i++){\n\t\tleng[s[i]]=0;\n\t\tque.push(P(0,s[i]));\n\t}\n\twhile(!que.empty()){\n\t\tP p=que.top();\n\t\tque.pop();\n\t\tint v=p.second;\n\t\tif(leng[v]<p.first) continue;\n\t\tfor(j=1;j<=n;j++){\n\t\t\tt=leng[v]+ri[v][j];\n//\t\t\tcout<<j<<' '<<leng[j]<<' '<<t<<endl;\n\t\t\tif(leng[j]>t){\n\t\t\t\tleng[j]=t;\n//\t\t\t\tcout<<leng[j]<<' '<<j<<endl;\n\t\t\t\tque.push(P(leng[j],j));\n\t\t\t}\n\t\t}\n\t}\n/*\tfor(i=1;i<=n;i++) cout<<leng[i]<<' ';\n\tcout<<endl;*/\n\tans=0;\n\tfor(i=1;i<=n;i++){\n\t\tint mx=0,y;\n\t\tdouble x;\n\t\tfor(j=1;j<=n;j++){\n\t\t\tif(ri[i][j]!=M){\n\t\t\t\tmx=max(mx,ri[i][j]+leng[j]);\n\t\t\t}\n\t\t}\n\t\tx=(double)mx/2;\n//\t\tcout<<x<<' '<<mx<<' '<<mi<<endl;\n\t\ty=round(x);\n\t\tans=max(ans,y);\n\t}\n\t\n\tcout<<ans<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<52;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst vi emp;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,-0};\nconst int DX[8]={-1,-1,-1,0,0,1,1,1},DY[8]={1,0,-1,1,-1,1,0,-1};\n\nclass Graph{\n\tprivate:\n\tint V;\n\tvvp List;\n\tvi DIJ(int s){\n\t\tpriority_queue<P> que;\n\t\tvi d(V,inf);\n\t\td[s]=0;\n\t\tque.push(P(0,s));\n\t\twhile(!que.empty()){\n\t\t\tP p=que.top();\n\t\t\tque.pop();\n\t\t\tint v=p.second;\n\t\t\tif(d[v]<-p.first) continue;\n\t\t\tfor(int i=0;i<List[v].size();i++){\n\t\t\t\tint F=List[v][i].first,S=List[v][i].second;\n\t\t\t\tif(d[F]>d[v]+S){\n\t\t\t\t\td[F]=d[v]+S;\n\t\t\t\t\tque.push(P(-d[F],F));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\tpublic:\n\tGraph(int v){\n\t\tV=v;\n\t\tList=vvp(v);\n\t}\n\tvoid add_edge(int s,int t,int c){\n\t\tList[s].push_back(P(t,c));\n\t\tList[t].push_back(P(s,c));\n\t}\n\tint solve(vi a){\n\t\tvi d(V,inf);\n\t\tfor(int i=0;i<a.size();i++){\n\t\t\tvi D=DIJ(a[i]-1);\n\t\t\tfor(int j=0;j<V;j++) d[j]=min(d[j],D[j]);\n\t\t}\n\t\tdouble M=0;\n\t\tfor(int i=0;i<V;i++) for(int j=0;j<List[i].size();j++){\n\t\t\tint v=List[i][j].first,l=List[i][j].second;\n\t\t\tM=max(M,d[i]+((double)d[v]-d[i]+l)/2);\n\t\t}\n\t\treturn (int)(M+0.5+eps);\n\t}\n};\n\nint n,m,k;\nvi a;\n\nint main(){\n\tcin>>n>>m>>k;\n\ta=vi(k);\n\tGraph g(n);\n\tfor(int i=0;i<m;i++){\n\t\tint s,t,c;\n\t\tcin>>s>>t>>c;\n\t\tg.add_edge(s-1,t-1,c);\n\t}\n\tfor(int i=0;i<k;i++) cin>>a[i];\n\tcout<<g.solve(a)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define M 100000007\ntypedef pair<int,int> P;\n/*int main(){\n\tcout<<8979879<<endl;\n}*/\nint ri[3001][3001];\nint main(void){\n\tint n,m,k,\n\t\ti,j,\n\t\tmx,t,ans,\n\t\ta[100001],b[100001],l[100001],s[3000],\n\t\td[3001];\n\t\t\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\n\tcin>>n>>m>>k;\n\tfor(i=0;i<m;i++) cin>>a[i]>>b[i]>>l[i];\n\tfor(i=0;i<k;i++) cin>>s[i];\n//\tfor(i=0;i<k;i++) cout<<s[i]<<endl;\n\t\n\tfor(i=1;i<=n;i++) for(j=1;j<=n;j++) ri[i][j]=M;\n\tfor(i=0;i<m;i++) ri[a[i]][b[i]]=l[i],ri[b[i]][a[i]]=l[i];\n/*\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++)cout<<ri[i][j]<<' ';\n\t\tcout<<endl;\n\t}*/\n\t\n\tint leng[3001];\n\tfor(i=1;i<=n;i++) leng[i]=M;\n\tfor(i=0;i<k;i++){\n\t\tleng[s[i]]=0;\n\t\tque.push(P(0,s[i]));\n\t}\n\twhile(!que.empty()){\n\t\tP p=que.top();\n\t\tque.pop();\n\t\tint v=p.second;\n\t\tif(leng[v]<p.first) continue;\n\t\tfor(j=1;j<=n;j++){\n\t\t\tt=leng[v]+ri[v][j];\n//\t\t\tcout<<j<<' '<<leng[j]<<' '<<t<<endl;\n\t\t\tif(leng[j]>t){\n\t\t\t\tleng[j]=t;\n//\t\t\t\tcout<<leng[j]<<' '<<j<<endl;\n\t\t\t\tque.push(P(leng[j],j));\n\t\t\t}\n\t\t}\n\t}\n/*\tfor(i=1;i<=n;i++) cout<<leng[i]<<' ';\n\tcout<<endl;*/\n\tans=0;\n\tfor(i=1;i<=n;i++){\n\t\tint mx=0,y;\n\t\tdouble x;\n\t\tfor(j=1;j<=n;j++){\n\t\t\tif(ri[i][j]!=M){\n\t\t\t\tmx=max(mx,ri[i][j]+leng[j]+leng[i]);\n\t\t\t}\n\t\t}\n\t\tx=(double)mx/2;\n//\t\tcout<<x<<' '<<mx<<' '<<mi<<endl;\n\t\ty=round(x);\n\t\tans=max(ans,y);\n\t}\n\t\n\tcout<<ans<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<map>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define INF 1<<30\n\nstruct edge{\n  int to,cost;\n};\nstruct road{\n  int now,to,cost;\n};\ntypedef pair<int , int> P; //最短,場所\nint id[3333];\nvector<road> ro;\nvector<edge> cost[3333];\npriority_queue<P, vector<P> , greater<P> >que;\n\nint n,m,k;\nint res=-1;\n\nint main(void){\n  int h,t,c,s;\n  fill(id,id+3333,INF);\n  scanf(\"%d %d %d\",&n,&m,&k);\n  for(int i=0;i<m;i++){\n    scanf(\"%d %d %d\",&h,&t,&c);\n    edge temp={t,c};\n    road tamp={h,t,c};\n    ro.push_back(tamp);\n    cost[h].push_back(temp);\n    temp.to=h;\n    cost[t].push_back(temp);\n  }\n  for(int i=0;i<k;i++){\n    scanf(\"%d\",&s);\n    id[s]=0;\n    que.push(P(0,s));\n  }\n\n  while(!que.empty()){\n    P p=que.top();\n    que.pop();\n    int v=p.second;\n    if(id[v]<p.first)continue;\n    for(int i=0;i<cost[v].size();i++){\n      edge e=cost[v][i];\n      if(id[e.to]>id[v]+e.cost){\n\tid[e.to]=id[v]+e.cost;\n\tque.push(P(id[e.to],e.to));\n      }\n    }\n  }\n  //  for(int i=1;i<=n;i++)printf(\"::%d\\n\",id[i]);\n  for(int i=0;i<ro.size();i++){\n    road r=ro[i];\n    int z=id[r.now]-id[r.to];\n    z*=(z<0)?-1:1;\n    z+=r.cost;\n    z=(int)(((double)z/2)+0.5);\n    res=max(res,min(id[r.now]+z,id[r.to]+z));\n    /*\n      for(int j=0;j<=r.cost;j++){\n      int ti=l.;\n      res=max(res,min(id[r.now]+j,id[r.to]+r.cost-j));\n      }\n    */\n\n    /*\n      int co=(int)((double)r.cost/2+0.5);\n      res=max(res,min(id[r.now],id[r.to])+co);\n    */\n  }\n  printf(\"%d\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstring>\n \n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define MP make_pair\n#define X first\n#define Y second\n#define all(v) v.begin(), v.end()\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> P;\n\nconst int INF = 1<<29;\n\nint dist[3001];\nbool visit[3001];\npair<P, int> edge[100001];\n\nvector<P> G[3001];\n\nint main(){\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\trep(i, m){\n\t\tint a, b, l;\n\t\tcin >> a >> b >> l;\n\t\ta--, b--;\n\t\tG[a].push_back(MP(l, b));\n\t\tG[b].push_back(MP(l, a));\n\t\tedge[i] = MP(MP(a, b), l);\n\t}\n\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\n\trep(i, k){\n\t\tint s;\n\t\tcin >> s;\n\t\tq.push(MP(0, s-1));\n\t}\n\n\twhile(!q.empty()){\n\t\tint pos = q.top().Y;\n\t\tint d = q.top().X;\n\t\tq.pop();\n\n\t\tif(visit[pos])continue;\n\t\tvisit[pos] = true;\n\n\t\tdist[pos] = d;\n\n\t\trep(i, G[pos].size()){\n\t\t\tq.push(MP(d+G[pos][i].first, G[pos][i].second));\n\t\t}\n\t}\n\n\tdouble ans = 0;\n\trep(i, m){\n\t\tdouble l, s, d;\n\t\tl = dist[edge[i].first.first];\n\t\ts = dist[edge[i].first.second];\n\t\td = edge[i].second;\n\t\tif(l < s) swap(l, s);\n\t\tif(l > s+d){\n\t\t\tans = max(ans, l);\n\t\t}else{\n\t\t\tans = max(ans, (s+l+d)/2);\n\t\t}\n\t}\n\n\tcout << (int)(ans+0.5) << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\n\nconst int V=3000;\nconst int INF=1010101010;\n\nstruct edge{int to,cost;};\nvector<edge> G[V];\nint d[V];\n\nint main()\n{\n    int N,M,K;\n    scanf(\" %d %d %d\", &N, &M, &K);\n\n    vector<int> a(M),b(M),c(M);\n    rep(i,M)\n    {\n        scanf(\" %d %d %d\", &a[i], &b[i], &c[i]);\n        --a[i];\n        --b[i];\n        G[a[i]].pb(edge{b[i],c[i]});\n        G[b[i]].pb(edge{a[i],c[i]});\n    }\n\n    fill(d,d+V,INF);\n    priority_queue<pi,vector<pi>,greater<pi>> que;\n\n    rep(i,K)\n    {\n        int s;\n        scanf(\" %d\", &s);\n        --s;\n        d[s]=0;\n        que.push(pi(0,s));\n    }\n\n    while(!que.empty()){\n        pi p=que.top();\n        que.pop();\n        int v=p.se;\n        if(d[v]<p.fi) continue;\n        rep(i,G[v].size())\n        {\n            edge e=G[v][i];\n            if(d[e.to]>d[v]+e.cost)\n            {\n                d[e.to]=d[v]+e.cost;\n                que.push(pi(d[e.to],e.to));\n            }\n        }\n    }\n\n    double ans=0;\n\n    rep(i,N) ans=max(ans,d[i]*1.0);\n    rep(i,M)\n    {\n        double s=(d[b[i]]+c[i]-d[a[i]])/2.0;\n        if(0<=s && s<=c[i]) ans=max(ans, d[a[i]]+s);\n    }\n\n    printf(\"%d\\n\", (int)ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<cstdio>\n#include<cmath>\n#include<iomanip>\n#include<algorithm>\n#include<functional>\n#include<queue>\n#include<stack>\nusing namespace std;\nstruct P {\n\tlong long cost, pos;\n};\nstruct B {\n\tlong long to, cost;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nlong long a[3001];\nvector<B>e[3001];\nlong long shop[3001];\nconst long long inf = 8000000000;\nint main() {\n\tlong long n, m, k;\n\tcin >> n >> m >> k;\n\tfill(a, a + n + 1, inf);\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b, cost;\n\t\tcin >> a >> b >> cost;\n\t\te[a].push_back(B{ b,cost });\n\t\te[b].push_back(B{ a,cost });\n\t}\n\tfor (int i = 0; i < k; i++) {\n\t\tcin >> shop[i];\n\t\ta[shop[i]] = 0;\n\t}\n\tfor (int z = 0; z < k; z++) {\n\t\tpriority_queue<P, vector<P>, greater<P>>p;\n\t\tp.push(P{ 0,shop[z] });\n\t\twhile (!p.empty()) {\n\t\t\tP t = p.top(); p.pop();\n\t\t\tfor (int i = 0; i < (int)e[t.pos].size(); i++) {\n\t\t\t\tif (a[e[t.pos][i].to] > a[t.pos] + e[t.pos][i].cost) {\n\t\t\t\t\ta[e[t.pos][i].to] = a[t.pos] + e[t.pos][i].cost;\n\t\t\t\t\tp.push(P{ a[e[t.pos][i].to],e[t.pos][i].to });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdouble sum = 0, sum2,f;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < (int)e[i].size(); j++) {\n\t\t\tsum = max(max(sum,(double)a[i]), (double)(a[i] + a[e[i][j].to] + e[i][j].cost)/2.0);\n\t\t}\n\t}\n\tcout << round(sum) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst int INF = 1 << 29;\n\nstruct Edge\n{\n\tint from, to, cost;\n\tEdge(int from, int to, int cost) \n\t\t: from(from), to(to), cost(cost)\n\t{ }\n};\n\nbool operator < (const Edge& right, const Edge& left)\n{\treturn right.cost > left.cost;\t}\n\nint main()\n{\t\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\t\n\tvint d(n, INF);\n\tpriority_queue<Edge> que;\n\tvector<vector<Edge> > edges(n, vector<Edge>());\n\t\n\trep(i, m)\n\t{\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\t\n\t\tedges[a - 1].push_back(Edge(a - 1, b - 1, c));\n\t\tedges[b - 1].push_back(Edge(b - 1, a - 1, c));\n\t}\n\t\n\trep(i, k)\n\t{\n\t\tint f;\n\t\tcin >> f;\n\t\t\n\t\td[f - 1] = 0;\n\t\t\n\t\trep(j, edges[f - 1].size()) que.push(edges[f - 1][j]);\n\t}\n\t\n\t\n\t// ショッピングモールがある街を距離０として他の街へダイクストラで最短路探索\n\tfor(; !que.empty(); que.pop())\n\t{\n\t\tEdge e(que.top());\n\t\t\n\t\tif(d[e.from] + e.cost < d[e.to])\n\t\t{\n\t\t\td[e.to] = d[e.from] + e.cost;\n\t\t\t\n\t\t\trep(j, edges[e.to].size()) que.push(edges[e.to][j]);\n\t\t}\n\t}\n\t\n\t\n\t// 辺上の最大値を探すO(m)\n\tdouble res = 0;\n\trep(i, n) \n\t{\n\t\trep(j, edges[i].size())\n\t\t{\n\t\t\tEdge &e = edges[i][j];\n\t\t\t\n\t\t\tdouble tmp1 = min(d[e.from], d[e.to]) + e.cost / 2.0;\n\t\t\tdouble tmp2 = min(d[e.to] + e.cost - 1, d[e.from] + 1);\n\t\t\t\n\t\t\tchmax(res, max(tmp1, tmp2));\n\t\t}\n\t\t\n\t\tchmax(res, d[i]);\n\t}\n\t\n\tcout << round(res) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <utility>\n#include <set>\n#include <queue>\n#define INF 100000000\nusing namespace std;\n\nbool used[3010]={0};\nint mol[3010]={0};\npriority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > pq[3010];\nint A[100010],B[100010],L[100010];\n\nint main(){\n\tint N,M,K,a,b,c,cnt,hog,imax,imad;\n\tpair<int,int> pa,pa2;\n\tpriority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > que;\n\tset<pair<int,int> >::iterator it;\n\tcin>>N>>M>>K;\n\tfill(mol,mol+N,INF);\n\tfor(int i=0;i<M;i++){\n\t\tcin>>a>>b>>c;\n\t\ta--;b--;\n\t\tpq[a].push(make_pair(c,b));\n\t\tpq[b].push(make_pair(c,a));\n\t\tA[i]=a;\n\t\tB[i]=b;\n\t\tL[i]=c;\n\t}\n\tfor(int i=0;i<K;i++){\n\t\tcin>>a;\n\t\ta--;\n\t\tque.push(make_pair(0,a));\n\t}\n\n\twhile(!que.empty()){\n\t\tpa=que.top();que.pop();\n\t\timax=pa.second;\n\t\tif(!used[imax]){\n\t\t\tmol[imax]=imad=pa.first;\n\t\t\tused[imax]=true;\n\t\t\twhile(!pq[imax].empty()){\n\t\t\t\tpa2=pq[imax].top();pq[imax].pop();\n\t\t\t\tif(!used[pa2.second])que.push(make_pair(imad+pa2.first,pa2.second));\n\t\t\t}\n\t\t}\n\t}\n\tcnt=0;\n\tfor(int i=0;i<M;i++){\n\t\tif(L[i]<=abs(mol[A[i]]-mol[B[i]])) cnt=max(cnt,max(mol[A[i]],mol[B[i]]));\n\t\telse{\n\t\t\tif((L[i]-abs(mol[A[i]]-mol[B[i]]))%2==0){\n\t\t\t\thog=(L[i]-abs(mol[A[i]]-mol[B[i]]))/2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\thog=(L[i]-abs(mol[A[i]]-mol[B[i]]))/2+1;\n\t\t\t}\n\t\t\tcnt=max(cnt,hog+max(mol[A[i]],mol[B[i]]));\n\t\t}\n\t}\n\t/*for(int i=0;i<N;i++){\n\t\tcout<<mol[i]<<\" \";\n\t}*/\n\tcout<<cnt<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\n#define PB push_back\n#define MP make_pair\nusing namespace std;\ntypedef pair<int,int> P;\n\nvector<pair<int,int> > edge[3000];\nint dist[3000];\nint main(){\n    int N,M,K;\n    scanf(\"%d%d%d\",&N,&M,&K);\n    int a,b,l;\n    for(int i=0;i<M;i++){\n        scanf(\"%d%d%d\",&a,&b,&l);\n        a--;b--;\n        edge[a].PB(MP(b,l));\n        edge[b].PB(MP(a,l));\n    }\n    for(int i=0;i<N;i++){\n        dist[i]=INT_MAX;\n    }\n    int s;\n    priority_queue<P,vector<P>,greater<P> > pq;\n    for(int i=0;i<K;i++){\n        scanf(\"%d\",&s);\n        s--;\n        dist[s]=0;\n        pq.push(MP(0,s));\n    }\n    while(!pq.empty()){\n        int d=pq.top().first,at=pq.top().second;\n        pq.pop();\n        if(d>dist[at]) continue;\n        for(int i=0;i<edge[at].size();i++){\n            int ne=edge[at][i].first,co=edge[at][i].second;\n            if(co+d<dist[ne]){\n                dist[ne]=co+d;\n                pq.push(MP(co+d,ne));\n            }\n        }\n    }\n    double ma=0;\n    for(int i=0;i<N;i++){\n        for(int j=0;j<edge[i].size();j++){\n            int ad=dist[i],bd=dist[edge[i][j].first],len=edge[i][j].second;\n            if(ad>bd) swap(ad,bd);\n            ma=max(ma,(ad+bd+len)/2.0);\n        }\n    }\n    printf(\"%d\\n\",(int)(ma+0.5+1e-6));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <deque>\n#include <vector>\nusing namespace std;\n\nint main() {\n\tint N,M,K;\n\tvector<pair<int,int> >nGo[3001];\n\tdeque<int> dis;\n\tint dist[3001];\n\tint road[100001][3];\n\tfor(int i=1;i<=3000;i++)\n\t\tdist[i]=(1 << 30 );\n\tcin >> N >> M >> K;\n\tint a,b,c;\n\tfor(int i=0;i<M;i++){\n\t\tcin >> a >> b >> c;\n\t\tnGo[a].push_back(pair<int,int>(b,c));\n\t\tnGo[b].push_back(pair<int,int>(a,c));\n\t\troad[i][0]=a;\n\t\troad[i][1]=b;\n\t\troad[i][2]=c;\n\t}\n\tfor(int i=0;i<K;i++){\n\t\tcin >> a;\n\t//\tdis.insert(multimap<int,int>::value_type(0,a));\n\t\tdis.push_back(a);\n\t\tdist[a]=0;\n\t}\n\twhile(!dis.empty()){\n\t\tsort(dis.begin(),dis.end());\n\t\tint now=dis[0];\n\t\tfor(int i=0;i<nGo[now].size();i++){\n\t\t\tif(dist[nGo[now][i].first]>dist[now]+nGo[now][i].second){\n\t\t\t\tdis.push_back(nGo[now][i].first);\n\t\t\t\tdist[nGo[now][i].first]=dist[now]+nGo[now][i].second;\n\t\t\t}\n\t\t}\n\t\twhile(now==dis[0])\n\t\tdis.pop_front();\n\t}\n\tint maxer=0;\n\tfor(int i=0;i<M;i++)\n\tmaxer=max(maxer,(dist[road[i][0]]+dist[road[i][1]]+road[i][2]+1)/2);\n\tfor(int i=1;i<=N;i++)\n\tmaxer=max(maxer,dist[i]);\n\tcout << maxer <<  endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct TOWN{\n    bool kaku;\n    int kyo;\n    vector<pair<int,int> > road;\n    \n    TOWN() :kaku(false){}\n}town[3001];\n\nint main(){\n    int n,m,k,a,b,l,ina[100000],inb[100000],inl[100000],ans=0;\n    priority_queue<pair<int,int> > pq;\n    pair<int,int> p;\n    \n    scanf(\"%d%d%d\",&n,&m,&k);\n    \n    for(int i=0;i<m;i++){\n        scanf(\"%d%d%d\",&a,&b,&l);\n        town[a].road.push_back(make_pair(b,-l));\n        town[b].road.push_back(make_pair(a,-l));\n        ina[i]=a;\n        inb[i]=b;\n        inl[i]=l;\n    }\n    \n    for(int i=0;i<k;i++){\n        scanf(\"%d\",&a);\n        pq.push(make_pair(0,a));\n    }\n    \n    while(!pq.empty()){\n        p=pq.top();\n        pq.pop();\n        \n        if(town[p.second].kaku) continue;\n        town[p.second].kaku=true;\n        town[p.second].kyo=-p.first;\n        \n        for(int i=0;i<town[p.second].road.size();i++)\n            pq.push(make_pair(p.first+town[p.second].road[i].second,town[p.second].road[i].first));\n    }\n    \n    for(int i=0;i<m;i++){\n        int sa = abs(town[ina[i]].kyo-town[inb[i]].kyo);\n        ans=max(ans,(max(inl[i]-sa,0)+1)/2+max(town[ina[i]].kyo,town[inb[i]].kyo));\n    }\n    \n    \n    \n    printf(\"%d\\n\",ans);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<queue>\n#include<vector>\n#include<map>\n#define INF 200000000\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef struct{\n\tint a,b,c;\n}edge;\nvector<P> e[3000];\nedge e2[100000];\nint d[3000];\nint max(int a,int b){return a>b?a:b;}\nint main(){\n\tint n,m,k;\n\tint i,j;\n\tscanf(\"%d %d %d\",&n,&m,&k);\n\tfor(i=0;i<m;i++){\n\t\tint x,y,z;\n\t\tscanf(\"%d %d %d\",&x,&y,&z);\n\t\tx--;y--;\n\t\tedge ed={x,y,z};\n\t\te[x].push_back(P(y,z));\n\t\te[y].push_back(P(x,z));\n\t\te2[i]=ed;\n\t}\n\tpriority_queue<P> que;\n\tfor(i=0;i<n;i++)d[i]=INF;\n\tfor(i=0;i<k;i++){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\td[x-1]=0;\n\t\tque.push(P(0,x-1));\n\t}\n\twhile(!que.empty()){\n\t\tP p=que.top();\n\t\tque.pop();\n\t\tint v=p.second;\n\t\tif(d[v]<p.first)continue;\n\t\tfor(i=0;i<e[v].size();i++){\n\t\t\tif(d[e[v][i].first]>d[v]+e[v][i].second){\n\t\t\t\td[e[v][i].first]=d[v]+e[v][i].second;\n\t\t\t\tque.push(P(d[e[v][i].first],e[v][i].first));\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(i=0;i<m;i++){\n\t\tint x=e2[i].a;\n\t\tint y=e2[i].b;\n\t\tint z=e2[i].c;\n\t\tans=max(ans,max(d[x],max(d[y],(int)round((double)(d[x]+d[y]+z)/2))));\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\nstruct edge{ int v,cost; };\n\nint main(){\n\tint n,m,k; scanf(\"%d%d%d\",&n,&m,&k);\n\tvector<edge> G[3000];\n\trep(i,m){\n\t\tint u,v,cost; scanf(\"%d%d%d\",&u,&v,&cost); u--; v--;\n\t\tG[u].push_back((edge){v,cost});\n\t\tG[v].push_back((edge){u,cost});\n\t}\n\n\tint d[3000];\n\trep(u,n) d[u]=INF;\n\tpriority_queue< pair<int,int> > Q;\n\trep(i,k){\n\t\tint u; scanf(\"%d\",&u); u--;\n\t\td[u]=0;\n\t\tQ.push(make_pair(0,u));\n\t}\n\twhile(!Q.empty()){\n\t\tint d_now=-Q.top().first,u=Q.top().second; Q.pop();\n\t\tif(d[u]<d_now) continue;\n\t\trep(i,G[u].size()){\n\t\t\tconst edge &e=G[u][i];\n\t\t\tif(d[e.v]>d[u]+e.cost){\n\t\t\t\td[e.v]=d[u]+e.cost;\n\t\t\t\tQ.push(make_pair(-d[e.v],e.v));\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans=0;\n\trep(u,n) rep(i,G[u].size()) {\n\t\tconst edge &e=G[u][i];\n\t\tans=max(ans,(d[u]+d[e.v]+e.cost+1)/2);\n\t}\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define M 100000007\ntypedef pair<int,int> P;\n/*int main(){\n\tcout<<8979879<<endl;\n}*/\nint ri[3001][3001];\nint main(void){\n\tint n,m,k,\n\t\ti,j,\n\t\tmx,t,ans,\n\t\ta[100001],b[100001],l[100001],s[3000],\n\t\td[3001];\n\t\t\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\n\tcin>>n>>m>>k;\n\tfor(i=0;i<m;i++) cin>>a[i]>>b[i]>>l[i];\n\tfor(i=0;i<k;i++) cin>>s[i];\n//\tfor(i=0;i<k;i++) cout<<s[i]<<endl;\n\t\n\tfor(i=1;i<=n;i++) for(j=1;j<=n;j++) ri[i][j]=M;\n\tfor(i=0;i<m;i++) ri[a[i]][b[i]]=l[i],ri[b[i]][a[i]]=l[i];\n/*\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++)cout<<ri[i][j]<<' ';\n\t\tcout<<endl;\n\t}*/\n\t\n\tint leng[3001];\n\tfor(i=1;i<=n;i++) leng[i]=M;\n\tfor(i=0;i<k;i++){\n\t\tleng[s[i]]=0;\n\t\tque.push(P(0,s[i]));\n\t}\n\twhile(!que.empty()){\n\t\tP p=que.top();\n\t\tque.pop();\n\t\tint v=p.second;\n\t\tif(leng[v]<p.first) continue;\n\t\tfor(j=1;j<=n;j++){\n\t\t\tt=leng[v]+ri[v][j];\n//\t\t\tcout<<j<<' '<<leng[j]<<' '<<t<<endl;\n\t\t\tif(leng[j]>t){\n\t\t\t\tleng[j]=t;\n//\t\t\t\tcout<<leng[j]<<' '<<j<<endl;\n\t\t\t\tque.push(P(leng[j],j));\n\t\t\t}\n\t\t}\n\t}\n/*\tfor(i=1;i<=n;i++) cout<<leng[i]<<' ';\n\tcout<<endl;*/\n\tans=0;\n\tfor(i=1;i<=n;i++){\n\t\tint mx=0,mi=M,y;\n\t\tdouble x;\n\t\tfor(j=1;j<=n;j++){\n\t\t\tif(ri[i][j]!=M){\n\t\t\t\tif(leng[i]!=0){\n\t\t\t\t\tmx=max(mx,ri[i][j]+leng[j]);\n\t\t\t\t\tmi=min(mi,ri[i][j]+leng[j]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tmx=max(mx,ri[i][j]);\n\t\t\t\t\tmi=min(mi,ri[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tx=(double)(mx+mi)/2;\n//\t\tcout<<x<<' '<<mx<<' '<<mi<<endl;\n\t\ty=round(x);\n\t\tans=max(ans,y);\n\t}\n\t\n\tcout<<ans<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint main() {\n  int n, m, k;\n  cin >> n >> m >> k;\n  vector<pair<int, int> > edge[n];\n  rep (i, m) {\n    int a, b, l;\n    cin >> a >> b >> l;\n    --a; --b;\n    edge[a].push_back(make_pair(b, l));\n    edge[b].push_back(make_pair(a, l));\n  }\n  vector<int> dis(n);\n  rep (i, n) dis[i] = 1e9;\n  priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > que;\n  rep (i, k) {\n    int s;\n    cin >> s;\n    --s;\n    que.push(make_pair(0, s));\n  }\n  while (!que.empty()) {\n    pair<int, int> now = que.top();\n    que.pop();\n    if (dis[now.second] <= now.first) continue;\n    dis[now.second] = now.first;\n    rep (i, edge[now.second].size()) {\n      que.push(make_pair(now.first + edge[now.second][i].second, edge[now.second][i].first));\n    }\n  }\n  int res = 0;\n  rep (i, n) rep (j, edge[i].size()) {\n    int a = dis[i], b = dis[edge[i][j].first], l = edge[i][j].second;\n    res = max(res, (a + b + l + 1) / 2);\n  }\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n#define INF (1<<27)\ntypedef pair<int,int> P;\nint d[3000];\nint c[3000][3000];\nint N,M,K;\nint main() {\n\tscanf(\"%d%d%d\",&N,&M,&K);\n\tfill(c[0],c[0]+3000*3000,INF);\n\tfor(int i=0;i<M;i++) {\n\t\tint a,b,l;\n\t\tscanf(\"%d%d%d\",&a,&b,&l);\n\t\tc[a-1][b-1]=c[b-1][a-1]=l;\n\t}\n\tfill(d,d+3000,INF);\n\tfor(int i=0;i<K;i++) {\n\t\tint s;\n\t\tscanf(\"%d\",&s);\n\t\td[s-1]=0;\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tque.push(P(0,s-1));\n\t\twhile(!que.empty()) {\n\t\t\tP p=que.top();que.pop();\n\t\t\tif(d[p.second]<p.first)break;\n\t\t\tfor(int j=0;j<N;j++) {\n\t\t\t\tif(d[j]>d[p.second]+c[p.second][j]) {\n\t\t\t\t\td[j]=d[p.second]+c[p.second][j];\n\t\t\t\t\tque.push(P(d[j],j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++) {\n\t\tif(c[i][j]==INF)break;\n\t\tans=max(ans,(d[i]+d[j]+c[i][j]+1)/2);\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\nstruct edge{\n    int to;\n    int cost;\n};\nclass Situation{\npublic:\n\tint cost;\n\tint idx;\n\n\tSituation(int cost_,int idx_){\n\t\tcost=cost_;\n\t\tidx=idx_;\n\t}\n\tSituation();\n\n\tbool operator<(const Situation &s)const{\n\t\treturn s.cost < this->cost;\n\t}\n};\nconst int MAX_V=3001;\n\nint N,M,K;\nvector<edge> G[MAX_V];\n\nint d[MAX_V];\nconst int INF=1000000000;\nint froms[100001];\nint tos[100001];\nint costs[100001];\n\nvoid dijkstra(int s){\n\tpriority_queue<Situation> que;\n\td[s] = 0;\n\tque.push(Situation(0,s));\n\twhile(!que.empty()){\n\t\tSituation p = que.top();\n\t\tque.pop();\n\t\tint v = p.idx;\n\t\tif(d[v] < p.cost)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost){\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(Situation(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n\n    cin>>N>>M>>K;\n    for(int i=0;i<M;i++){\n        edge e;\n        int from,to,cost;\n        cin>>from>>to>>cost;\n        from--;to--;\n        froms[i]=from;\n        tos[i]=to;\n        costs[i]=cost;\n        e.to=to;\n        e.cost=cost;\n        G[from].push_back(e);\n        e.to=from;\n        G[to].push_back(e);\n    }\n\tfill(d,d+MAX_V,INF);\n    for(int i=0;i<K;i++){\n        int a;\n        cin>>a;\n        a--;\n        dijkstra(a);\n    }\n    double res=0;\n    for(int i=0;i<N;i++)\n        res=max(res,(double)d[i]);\n    for(int i=0;i<M;i++){\n        double dit=(1.0*d[froms[i]]+d[tos[i]]+costs[i])/2;\n        res=max(dit,res);\n    }\n    int val=(int)(res+0.5);\n    cout<<val<<endl;\n    //printf(\"%.0f\\n\",res);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int> PP;\nint n,m,k,x,y,z;\nvector<PP> v[3010];//cost,to\npriority_queue<PP,vector<PP>,greater<PP> >Q;//cost,to\nint d[3010];\nint main(){\n\tcin>>n>>m>>k;\n\trep(i,m){\n\t\tcin>>x>>y>>z;x--,y--;\n\t\tv[x].push_back(make_pair(z,y));\n\t\tv[y].push_back(make_pair(z,x));\n\t}\n\trep(i,n)d[i]=1145141919;\n\trep(u,k){cin>>m;m--;\n\t\twhile(!Q.empty())Q.pop();\n\t\tQ.push(make_pair(0,m));\n\t\twhile(!Q.empty()){\n\t\t\tx=Q.top().X,y=Q.top().Y;\n\t\t\tQ.pop();\n\t\t\tif(d[y]>x){\n\t\t\t\td[y]=x;\n\t\t\t\trep(i,v[y].size()){\n\t\t\t\t\tif(d[v[y][i].Y]>d[y]+v[y][i].X)\n\t\t\t\t\tQ.push(make_pair(d[y]+v[y][i].X,v[y][i].Y));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//rep(i,n)cout<<d[i]<<\" \";cout<<endl;\n\tint ans=-1;\n\trep(i,n)rep(j,v[i].size()){\n\t\tans=max(ans,d[i]+d[v[i][j].Y]+v[i][j].X);\n\t}cout<<ans/2+ans%2<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\nusing namespace std;\n\nvector<int>x[4000];\nint n,m,a,b,c,k;\nint s[4000],d[4000];\nint X[4000];\ndouble maxn;int res;\n\nint main(){\n\tmemset(X,63,sizeof(X));\n\tcin>>n>>m>>k;\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>a>>b>>c;\n\t\tx[a].push_back(b*10000+c);\n\t\tx[b].push_back(a*10000+c);\n\t}\n\tfor(int i=0;i<k;i++){\n\t\tcin>>a;\n\t\ts[a]=1;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(s[i]==1){\n\t\t\tmemset(d,63,sizeof(d));\n\t\t\td[i]=0;\n\t\t\tfor(int h=1;h<=n;h++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tif(d[j]<100000000){\n\t\t\t\t\t\tfor(int k=0;k<x[j].size();k++){\n\t\t\t\t\t\t\td[x[j][k]/10000]=min(d[x[j][k]/10000],d[j]+x[j][k]%10000);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tX[j]=min(X[j],d[j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tmaxn=max((int)maxn,X[i]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<x[i].size();j++){\n\t\t\tif(abs(X[i]-X[x[i][j]/10000])<x[i][j]%10000){\n\t\t\t\ta=x[i][j]%10000-abs(X[i]-X[x[i][j]/10000]);\n\t\t\t\tmaxn=max(maxn,(double)(max(X[i],X[(int)(x[i][j]/10000)])+1.0*a/2.0));\n\t\t\t}\n\t\t}\n\t}\n\tres=(1.0*maxn+0.99999999);\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<vector>\n#include<queue>\n#include<functional>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint N,M,K;\t\t//町数、道の数、店舗数\nstruct NODE{\n\tvector<int> cost,list;\n\tint minest;\t//頂点から店への最短距離\n}MISE[3000];\n\nvoid Ini(int *a,int index,int num){\n\tfor(int i = 0;i < index;i++){\n\t\ta[i] = num;\n\t}\n}\nvoid Dijkstra(int left){\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tint done[3000],DEFINEED = 0;\n\tint nowcost[3000];\n\tP edge;\n\tIni(done,N,-1);\n\tIni(nowcost,N,500000000);\n\tque.push(P(0,left));\n\twhile(DEFINEED < N && !que.empty()){\n\t\tedge = que.top();\n\t\tque.pop();\n\t\tif(done[edge.second] >= 0)\n\t\t\tcontinue;\n\t\tDEFINEED++;\n\t\tdone[edge.second] = edge.first;\n\t\t//確定した頂点から枝を出す\n\t\tint lsize;\n\t\tlsize = MISE[edge.second].list.size();\n\t\tfor(int i = 0;i < lsize;i++){\n\t\t\tif(done[MISE[edge.second].list[i]] == -1 && nowcost[MISE[edge.second].list[i]] > edge.first+MISE[edge.second].cost[i]){\n\t\t\t\tnowcost[MISE[edge.second].list[i]] = edge.first+MISE[edge.second].cost[i];\n\t\t\t\tque.push(P(nowcost[MISE[edge.second].list[i]],MISE[edge.second].list[i]));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int  i = 0;i < N;i++){\n\t\tif(MISE[i].minest > done[i] && done[i] != -1)\n\t\t\tMISE[i].minest = done[i];\n\t}\n}\nint main(){\n\tint i,a,b,c;\n\tint Mplace;\n\tcin >> N >> M >> K;\n\tfor(i = 0;i < N;i++){\n\t\tMISE[i].minest = 500000000;\n\t}\n\tfor(i = 0;i < M;i++){\n\t\tcin >> a >> b >> c;\n\t\ta--;b--;\n\t\t//隣接リスト作成。道の生成による影響は2ノード間にのみ作用する。\n\t\tMISE[a].list.push_back(b);\n\t\tMISE[a].cost.push_back(c);\n\t\tMISE[b].list.push_back(a);\n\t\tMISE[b].cost.push_back(c);\n\t}\n\tfor(i = 0;i < K;i++){\n\t\tcin >> Mplace;\n\t\tMplace--;\n\t\tDijkstra(Mplace);\n\t}\n\tdouble D_length;\n\tint I_length,I_Mlength = 0;\n\tfor(i = 0;i < N;i++){\n\t\t//枝の間が一番距離が長くなりそう\n\t\tint lsize;\n\t\tlsize = MISE[i].list.size();\n\t\tfor(int j = 0;j < lsize;j++){\n\t\t\tD_length = (double)MISE[i].cost[j]/2.0;\n\t\t\tD_length += min(MISE[i].minest,MISE[MISE[i].list[j]].minest);\n\t\t\tif(D_length - (int)D_length == 0)\n\t\t\t\tI_length = (int)D_length;\n\t\t\telse\n\t\t\t\tI_length = (int)D_length+1;\n\t\t\tif(I_Mlength < I_length)\n\t\t\t\tI_Mlength = I_length;\n\t\t}\n\t\tcout << MISE[i].minest << \" \";\n\t}\n\tcout << endl << I_Mlength << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <deque>\n#include <vector>\nusing namespace std;\n\nint main() {\n\tint N,M,K;\n\tvector<pair<int,int> >nGo[3001];\n\tdeque<int> dis;\n\tint dist[3001];\n\tint road[100000][3];\n\tfor(int i=1;i<=3000;i++)\n\t\tdist[i]=(1 << 30 );\n\tcin >> N >> M >> K;\n\tint a,b,c;\n\tfor(int i=0;i<M;i++){\n\t\tcin >> a >> b >> c;\n\t\tnGo[a].push_back(pair<int,int>(b,c));\n\t\tnGo[b].push_back(pair<int,int>(a,c));\n\t\troad[i][0]=a;\n\t\troad[i][1]=b;\n\t\troad[i][2]=c;\n\t}\n\tfor(int i=0;i<K;i++){\n\t\tcin >> a;\n\t//\tdis.insert(multimap<int,int>::value_type(0,a));\n\t\tdis.push_back(a);\n\t\tdist[a]=0;\n\t}\n\twhile(!dis.empty()){\n\t\tsort(dis.begin(),dis.end());\n\t\tint now=dis[0];\n\t\tfor(int i=0;i<nGo[now].size();i++){\n\t\t\tif(dist[nGo[now][i].first]>dist[now]+nGo[now][i].second){\n\t\t\t\tdis.push_back(nGo[now][i].first);\n\t\t\t\tdist[nGo[now][i].first]=dist[now]+nGo[now][i].second;\n\t\t\t}\n\t\t}\n\t\twhile(true){\n\t\t\tif(dis[0]==now)\n\t\t\t\tdis.pop_front();\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tint maxer=0;\n\tfor(int i=0;i<M;i++)\n\tmaxer=max(maxer,(dist[road[i][0]]+dist[road[i][1]]+road[i][2]+1)/2);\n\tfor(int i=1;i<=N;i++)\n\tmaxer=max(maxer,dist[i]);\n\tcout << maxer <<  endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<functional>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nstruct edge{\n\tint from;\n\tint to;\n\tint cost;\n};\n\nstruct city{\n\tint number;\n\tint cost;\n};\n\nint main(){\n\tint n,m,k,a,cost[3002],ret=0;\n\tedge e;\n\tvector<edge> ve[3002];\n\tvector<edge> E;\n\tpriority_queue<city,vector<city>,function<bool(city,city)>> c([](city x,city y){return x.cost<=y.cost;});\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tfor(int i=1;i<=n;i++){\n\t\tcost[i]=100000000;\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d%d\",&e.from,&e.to,&e.cost);\n\t\tE.push_back(e);\n\t\tve[e.from].push_back(e);\n\t\ta=e.from; e.from=e.to; e.to=a;\n\t\tve[e.from].push_back(e);\n\t}\n\tfor(int i=0;i<k;i++){\n\t\tcity C;\n\t\tscanf(\"%d\",&C.number);\n\t\tC.cost=0;\n\t\tcost[C.number]=0;\n\t\tc.push(C);\n\t}\n\twhile(!c.empty()){\n\t\tcity C=c.top(); c.pop();\n\t\tif(C.cost==cost[C.number]){\n\t\t\tint s=ve[C.number].size();\n\t\t\tfor(int i=0;i<s;i++){\n\t\t\t\tedge ed=ve[C.number][i];\n\t\t\t\tif(cost[ed.to]>cost[ed.from]+ed.cost){\n\t\t\t\t\tcost[ed.to]=cost[ed.from]+ed.cost;\n\t\t\t\t\tcity cit;\n\t\t\t\t\tcit.number=ed.to; cit.cost=cost[ed.to];\n\t\t\t\t\tc.push(cit);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/*for(int i=1;i<=n;i++){\n\t\tprintf(\"%d\\n\",cost[i]);\n\t}*/\n\tfor(int i=0;i<m;i++){\n\t\tret=max(ret,(cost[E[i].from]+cost[E[i].to]+E[i].cost+1)/2);\n\t}\n\tprintf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst int MAX_N = 3005;\n\nstruct Edge\n{\n\tint v, cost; \n\tEdge(int v, int cost) \n\t\t: v(v), cost(cost) \n\t{ } \n};\n\nvector<Edge> edges[MAX_N];\n\nint main()\n{\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\t\n\tvint d(n, 0);\n\tvector<bool> flag(n, false);\n\t\n\trep(i, m)\n\t{\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\t\n\t\tedges[a - 1].push_back(Edge(b - 1, c));\n\t\tedges[b - 1].push_back(Edge(a - 1, c));\n\t}\n\t\n\trep(i, k)\n\t{\n\t\tint f;\n\t\tcin >> f;\n\t\t\n\t\tflag[f - 1] = true;\n\t}\n\t\n\t// それぞれの街から最も近いショッピングモールへの距離をBFSで探索O(n*n*hoge)\n\trep(i, n)\n\t{\n\t\tif(!flag[i])\n\t\t{\n\t\t\tvector<bool> used(n, false);\n\t\t\tpriority_queue<pint, vector<pint>, greater<pint> > que; // first := cost, second := position;\n\t\t\t\n\t\t\tfor(que.push(mp(0, i)); !que.empty(); que.pop())\n\t\t\t{\n\t\t\t\tpint p = que.top();\n\t\t\t\t\n\t\t\t\tif(flag[p.second])\n\t\t\t\t{\n\t\t\t\t\td[i] = p.first;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trep(j, edges[p.second].size())\n\t\t\t\t{\n\t\t\t\t\tEdge &e = edges[p.second][j];\n\t\t\t\t\t\n\t\t\t\t\tif(!used[e.v])\n\t\t\t\t\t{\n\t\t\t\t\t\tused[e.v] = true;\n\t\t\t\t\t\tque.push(mp(p.first + e.cost, e.v));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// 辺上の最大値を探すO(m)\n\tdouble res = 0;\n\trep(i, n) \n\t{\n\t\trep(j, edges[i].size())\n\t\t{\n\t\t\tEdge &e = edges[i][j];\n\t\t\t\n\t\t\tchmax(res, min(d[i], d[e.v]) + e.cost / 2.0);\n\t\t\tif(flag[i] && !flag[e.v]) chmax(res, d[i] + e.cost - 1);\n\t\t}\n\t\t\n\t\tchmax(res, d[i]);\n\t}\n\t\n\tcout << round(res) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <map>\n#include <vector>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define IREP(it,array) for(vector<int>::iterator it=array.begin(); it!=array.end(); ++it)\n#define SREP(it,array) for(vector<string>::iterator it=array.begin(); it!=array.end(); ++it)\n\n#define MP       make_pair\n#define PB       push_back\n#define ALL(x)   (x).begin(),(x).end()\n\nconst int INF = 1<<29;\nconst double EPS = 1e-9;\ndouble zero(double d){\n  return d < EPS ? 0.0 : d;\n}\n\ntypedef long long LL;\ntypedef pair<int,int> P;\n\n\nint main()\n{\n  cout.setf(ios::fixed, ios::floatfield);\n  cout.precision(7);\n\n  int N,M,K;\n  cin >>N>>M>>K;\n\n  int cost[N+1][N+1];\n  REP(i,N+1){\n    fill(cost[i], cost[i]+N+1, INF);\n    cost[i][i] = 0;\n  }\n  int d[N+1];\n  fill(d,d+N+1,INF);\n\n  priority_queue<P, vector<P>, greater<P> > pque;\n\n  REP(_t,M){\n    int a,b,l;\n    cin >>a>>b>>l;\n    cost[a][b] = cost[b][a] = l;\n  }\n\n  REP(_t,K){\n    int a;\n    cin >> a;\n    pque.push( P(0,a) );\n    d[a] = 0;\n  }\n\n  // dijkstra\n  while( ! pque.empty() ){\n    P p = pque.top(); pque.pop();\n    int v = p.second;\n    if( d[v] < p.first )\n      continue;\n\n    REP(i, N+1){\n      if( d[i] > d[v] + cost[v][i] ){\n\td[i] = d[v]+cost[v][i];\n\tpque.push( P(d[i],i) );\n      }\n    }\n  }\n\n  REP(i,N+1)\n    cout << d[i] << \" \";\n  cout << endl;\n\n  int res = 0;\n  REP(i, N+1){\n    REP(j, N+1){\n      if( d[i] != INF){\n\tres = max( res, d[i] );\n\tif( cost[i][j] != INF ){\n\t  int val = (double)(d[i]+cost[i][j]+d[j])/2+0.5;\n\t  res = max( res, val );\n\t}\n      }\n    }\n  }\n\n  cout << res << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\nint n;\nint m;\nint k;\ncin >>n;\ncin >>m;\ncin >>k;\nint a[m];\nint b[m];\nint l[m];\nint c;\nc=0;\nwhile(c<m){\ncin >>a[c];\ncin >>b[c];\ncin >>l[c];\nc=c+1;}\nint d[n];//確定\nint f[n];//暫定\nint e;\nc=0;\nwhile(c<n){\nd[c]=-1;\nf[c]=-1;\nc=c+1;}\nc=0;\nwhile(c<k){\ncin >>e;\nd[e-1]=0;\nf[e-1]=0;\nc=c+1;}\nint g;\nint h;\nc=k;\nwhile(c<n){\ne=0;\nwhile(e<m){\nif(d[a[e]-1]!=-1&&d[b[e]-1]==-1){\nif(d[a[e]-1]+l[e]<f[b[e]-1]){f[b[e]-1]=d[a[e]-1]+l[e];}}\nif(d[b[e]-1]!=-1&&d[a[e]-1]==-1){\nif(d[b[e]-1]+l[e]<f[a[e]-1]){f[a[e]-1]=d[b[e]-1]+l[e];}}\ne=e+1;}\ng=-1;\ne=0;\nwhile(e<n){\nif(d[e]==-1&&g>f[e]){g=f[e]; h=e;}\nelse if(d[e]==-1&&g==-1){g=f[e]; h=e;}\ne=e+1;}\nd[h]=f[h];\nc=c+1;}\ng=0;\nc=0;\nwhile(c<m){\nif(d[a[c]-1]-d[b[c]-1]==l[c]&&g<d[a[c]-1]){g=d[a[c]-1];}\nelse if(d[b[c]-1]-d[a[c]-1]==l[c]&&g<d[b[c]-1]){g=d[b[c]-1];}\nelse if((d[b[c]-1]+d[a[c]-1]+l[c])%2==0&&g<(d[b[c]-1]+d[a[c]-1]+l[c])/2){g=(d[b[c]-1]+d[a[c]-1]+l[c])/2;}\nelse if((d[b[c]-1]+d[a[c]-1]+l[c])%2==1&&g<(d[b[c]-1]+d[a[c]-1]+l[c])/2+1){g=(d[b[c]-1]+d[a[c]-1]+l[c])/2+1;}\nc=c+1;}\ncout <<g<<endl;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\n\nconst int V=3000;\nconst int INF=1010101010;\n\nstruct edge{int to,cost;};\nvector<edge> G[V];\nint d[V];\n\nint main()\n{\n    int N,M,K;\n    scanf(\" %d %d %d\", &N, &M, &K);\n\n    vector<int> a(M),b(M),c(M);\n    rep(i,M)\n    {\n        scanf(\" %d %d %d\", &a[i], &b[i], &c[i]);\n        --a[i];\n        --b[i];\n        G[a[i]].pb(edge{b[i],c[i]});\n        G[b[i]].pb(edge{a[i],c[i]});\n    }\n\n    fill(d,d+V,INF);\n    priority_queue<pi,vector<pi>,greater<pi>> que;\n\n    rep(i,K)\n    {\n        int s;\n        scanf(\" %d\", &s);\n        --s;\n        d[s]=0;\n        que.push(pi(0,s));\n    }\n\n    while(!que.empty()){\n        pi p=que.top();\n        que.pop();\n        int v=p.se;\n        if(d[v]<p.fi) continue;\n        rep(i,G[v].size())\n        {\n            edge e=G[v][i];\n            if(d[e.to]>d[v]+e.cost)\n            {\n                d[e.to]=d[v]+e.cost;\n                que.push(pi(d[e.to],e.to));\n            }\n        }\n    }\n\n    double ans=0;\n\n    rep(i,N) ans=max(ans,d[i]*1.0);\n    rep(i,M)\n    {\n        double s=(d[b[i]]+c[i]-d[a[i]])/2.0;\n        if(0<=s && s<=c[i]) ans=max(ans, d[a[i]]+s);\n    }\n\n    printf(\"%d\\n\", (int)(ans+0.5));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nconst int INF=1e9;\nstruct data{\n    int to,cost;\n    data(int a,int b):to(a),cost(b){}\n    bool operator<(const data &d)const{\n        return cost<d.cost;\n    }\n};\nvector<vector<data> >edge;\nvector<int>D;\nvoid dijkstra(int s){\n    priority_queue<data>Q;\n    Q.push(data(s,0));\n    while(Q.size()){\n        data latte=Q.top();Q.pop();\n        int At=latte.to,cost=latte.cost;\n        if(D[At]<cost)continue;\n        D[At]=cost;\n        for(int i=0;i<edge[At].size();i++){\n            data e=edge[At][i];\n            if(D[e.to]<D[At]+e.cost)continue;\n            Q.push(data(e.to,D[At]+e.cost));\n        }\n    }\n    return;\n}\nint main(){\n    int n,m,k;\n    cin>>n>>m>>k;\n    edge.resize(n);\n    D.resize(n,INF);\n    for(int i=0;i<m;i++){\n        int a,b,c;\n        cin>>a>>b>>c;\n        a--;b--;\n        edge[a].push_back(data(b,c));\n        edge[b].push_back(data(a,c));\n    }\n    for(int i=0;i<k;i++){\n        int s;\n        cin>>s;\n        s--;\n        dijkstra(s);\n    }\n    int Max=0;\n    /*\n    for(int i=0;i<n;i++){\n        for(int j=0;j<edge[i].size();j++){\n            data e=edge[i][j];\n            int latte=(D[i]+D[e.to]+e.cost+1)/2;\n            Max=max(max(D[i],D[e.to]),max(Max,latte));\n\n        }\n    }*/\n    cout<<Max<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\nÂÃÂÃ¨ÂÂ ÂÂ¦ÂÂ¸ÂAÂeÂmÂ[ÂhÂÂ©ÂÃ§ÂÃÂÃ±ÂÃÂÂÂ[ÂÂÂÃÂÃÂÃÂÂÂÂ£ÂÃ°ÂÂÂÃÂÃÂÂ¨ÂÂ¢ÂÂ½ÂÃ»ÂÂªÂÃ¦ÂÂ³ÂÂ»ÂÂ¤ÂB\n  - Â_ÂCÂNÂXÂgÂÂÂ@\n  - O(E log V)ÂÃÂÃÂÂ«ÂÃ©\n  - O(VE log V)ÂÃ°ÂÃ¢ÂÃ©ÂKÂvÂÃÂÂ¢ÂiÂÂ±ÂÂ±ÂÃÂlÂÃ±ÂÂ¾Âj\n  - dist[3002]ÂÃÂiÂ[\n\nÂmÂ[ÂhAÂÃÂmÂ[ÂhBÂÃ°ÂÃÂÃÂÂ®ÂGÂbÂWÂÃÂÃ£ÂÃÂÃÂÃ°ÂÂÂÃÂÃ©ÂÃÂÂ¼ÂÃ¨ÂÂ·ÂÃ©\n  - ÂÂ±ÂÃÂÃÂÂ«ÂAÂGÂbÂWÂÃÂÃÂÃÂÃÂuÂÃÂÃÂÃ°ÂÂÂÃÂÃªÂÃÂÃªÂÃÂÂÂÂ£ÂÂªÂÃÂÃ¥ÂÃÂÃÂÃ©ÂÂ©ÂÃ°ÂlÂÂ¦ÂÃ©\n  - ÂÂ»ÂÃÂÃÂuÂÃÂAÂmÂ[ÂhAÂÃ°ÂÃÂÃÂÃÂÃ ÂAÂmÂ[ÂhBÂÃ°ÂÃÂÃÂÃÂÃ ÂAÂÂ¯ÂÂ¶ÂÂÂÂ£ÂÃÂÃÂÃ±ÂÃÂÂÂ[ÂÂÂÃÂÃÂsÂÂ¯ÂÃ©ÂÃÂuÂÃÂÃÂÃ©\n  - ÂÃ¦ÂÃÂÃÂAÂGÂbÂWÂÃÂÂ·ÂÂ³ÂÂªLÂÃÂÂ·ÂÃ©ÂÃÂAÂÃÂÃ°ÂÂÂÃÂÃ©ÂÃÂuÂÃÂA\n  -- ÂmÂ[ÂhBÂÂ©ÂÃ§ (dist[A] - dist[B] + L) / 2 ÂÂ£ÂÃªÂÂ½ÂÃÂuÂÃÂÃÂÃ©\n  -- ÂÂ½ÂÂ¾ÂÂµÂAdist[A] > dist[B]ÂÃÂÂ ÂÃ©\n\n  - Â]ÂÃÂÃÂAÂÂ±ÂÃÂÃÂÂ«ÂÃÂÃÂÃ±ÂÃÂÂÂ[ÂÂÂÃÂÃÂÃÂÂÂÂ£ÂÃ\n  -- dist[B] + (dist[A] - dist[B] + L) / 2\n\nÂÂ ÂÃÂÃÂAÂÂ±ÂÃªÂÃ°ÂSÂÃÂÃÂGÂbÂWÂÃÂÃÂÂ¢ÂÃÂvÂZÂÂµÂAÂÂ»ÂÃÂÃÂÃ¥ÂlÂÃ°ÂÃÂÃªÂÃÂÂ¢ÂÂ¢ÂB\n\nÂwÂÃ±ÂÂ¾ÂÂ±ÂÃ\n  - Â_ÂCÂNÂXÂgÂÂÂÃ¢ÂÃ©ÂÃÂÂ«ÂAÂÃÂÂÂÃÂnÂ_ÂWÂÂÂÃ°openÂÃÂÃ¼ÂÃªÂÃÂÂ¨ÂÂ¯ÂÃ O(E log V) ÂÃÂÂ®ÂÃ¬ÂÂµÂÃÂÂ­ÂÃªÂÃ©\n  - ÂÃ­ÂÂ´ÂÃ­ÂÂ´VÂÃÂÃÂÂÂÂªÂÃÂ_ÂCÂNÂXÂgÂÂÂÃ°ÂÃ¢ÂÃ§ÂÃÂÂ­ÂÃÂÂ¢ÂÂ¢\n\n */\n#include <iostream>\n#include <queue>\n#include <cstring>\n#include <climits>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint dist[3002];\nvector<P> t[3002]; //first:cost, second:id\n\nvoid dijk(vector<int> &sv){\n  priority_queue<P, vector<P>, greater<P> > open; //first:cost, second:id\n\n  for(int i = 0; i < 3002; i++){\n    dist[i] = INT_MAX;\n  }\n\n  for(int i = 0; i < sv.size(); i++){\n    open.push(P(0, sv[i]));\n  }\n\n  while(!open.empty()){\n    P p = open.top(); open.pop();\n    if(dist[p.second] <= p.first) continue;\n    dist[p.second] = p.first;\n\n    for(int i = 0; i < t[p.second].size(); i++){\n      P next = t[p.second][i];\n      open.push(P(p.first + next.first, next.second));\n    }\n  }\n}\n\nint main(){\n  int n, m, k;\n\n  while(cin >> n >> m >> k){\n    for(int i = 0; i < n; i++){\n      t[i].clear();\n    }\n\n    for(int i = 0; i < m; i++){\n      int a, b, cost;\n      cin >> a >> b >> cost;\n      a--;\n      b--;\n      t[a].push_back(P(cost, b));\n      t[b].push_back(P(cost, a));\n    }\n\n    vector<int> sv;\n\n    for(int i = 0; i < k; i++){\n      int a;\n      cin >> a;\n      sv.push_back(a - 1);\n    }\n\n    dijk(sv);\n\n    double ans = 0;\n\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < t[i].size(); j++){\n        int l = t[i][j].first;\n        int a = i;\n        int b = t[i][j].second;\n\n        if(dist[a] < dist[b]) swap(a, b);\n\n        ans = max(ans, (dist[a] - dist[b] + l) / 2.0 + dist[b]);\n      }\n    }\n\n    cout << (int)(ans + 0.5) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<functional>\n#include<queue>\nusing namespace std;\n\nstruct edge{int to,cost;};\ntypedef pair<int,int> P;\nconst int INF=1000000;\n\nvector<edge> G[3001];\nint d[3001];\nint n,m,k;\n\nvoid dijk(vector<int>sv){\n\tpriority_queue<P ,vector<P>,greater<P> > que;\n\tfill(d,d+3000,INF);\n\tfor(int i=0;i<sv.size();i++){\n      d[sv[i]]=0;\n      que.push(P(0,sv[i]));\n\t}\n\twhile(!que.empty()){\n\t\tP p=que.top();que.pop();\n\t\tint v=p.second;\n\t\tif(d[v]<p.first)continue;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tedge e=G[v][i];\n\t\t\tif(d[e.to]>d[v]+e.cost){\n\t\t\t\td[e.to]=d[v]+e.cost;\n\t\t\t\tque.push(P(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c;\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tedge e;\n\t\te.to=b,e.cost=c;\n\t\tG[a].push_back(e);\n\t\te.to=a;\n\t\tG[b].push_back(e);\n\t}\n\tvector<int> sv;\n\tfor(int i=0;i<k;i++){\n\t\tint a;\n\t\tscanf(\"%d\",&a);\n\t\tsv.push_back(a);\n\t}\n\tdijk(sv);\n\n\tint maxi=0;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tfor(int k=0;k<G[i].size();k++){\n\t\t\t\tint cost=0;\n\t\t\t\tedge e=G[i][k];\n\t\t\t\tif(e.to==j)cost=((d[i]+d[j]+e.cost+1)/2);\n\t\t\t\tmaxi=max(maxi,cost);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",maxi);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<functional>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PP;\nconst int INF = 1 << 30;\nint n, m, k;\nvector<P> road[3001];\nint shop[3001], dis[3001], from[3001], save[3001][3001];\nqueue<PP> que;\nint main(){\n\tcin >> n >> m >> k;\n\tfor (int i = 0; i<m; i++){\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\troad[a].push_back(P(b, c));\n\t\troad[b].push_back(P(a, c));\n\t}\n\tfor (int i = 0; i<k; i++)\n\t\tcin >> shop[i];\n\tfill(dis, dis + 3001, INF);\n\tfor (int i = 0; i<k; i++){\n\t\tfor (int j = 0; j<road[shop[i]].size(); j++){\n\t\t\tque.push(make_pair(make_pair(shop[i], road[shop[i]][j].f), road[shop[i]][j].s));\n\t\t\tdis[shop[i]] = 0;\n\t\t\tdis[road[shop[i]][j].f] = min(dis[road[shop[i]][j].f], road[shop[i]][j].s);\n\t\t\tfrom[road[shop[i]][j].f] = shop[i];\n\t\t}\n\t}\n\twhile (!que.empty()){\n\t\tPP p = que.front();\n\t\tque.pop();\n\t\tfor (int i = 0; i<road[p.f.s].size(); i++){\n\t\t\tif (dis[road[p.f.s][i].f]>p.s + road[p.f.s][i].s){\n\t\t\t\tque.push(make_pair(make_pair(p.f.s, road[p.f.s][i].f), p.s + road[p.f.s][i].s));\n\t\t\t\tdis[road[p.f.s][i].f] = p.s + road[p.f.s][i].s;\n\t\t\t\tfrom[road[p.f.s][i].f] = p.f.s;\n\t\t\t}\n\t\t}\n\t}\n\tdouble ans = 0;\n\tfor (int i = 0; i<3001; i++)\n\t\tfill(save[i], save[i] + 3001, INF);\n\tfor (int i = 1; i <= n; i++){\n\t\tif (dis[i] != INF){\n\t\t\tfor (int j = 0; j<road[i].size(); j++){\n\t\t\t\tdouble a = double(road[i][j].s + dis[i]) / 2;\n\t\t\t\tif (a>ans && save[i][road[i][j].f]>a + dis[i]){\n\t\t\t\t\tans = a;\n\t\t\t\t\tsave[i][road[i][j].f] = ans;\n\t\t\t\t}\n\t\t\t\t\tsave[i][road[i][j].f] = a;\n\t\t\t}\n\t\t}\n\t}\n\tint ans2;\n\tans += 0.5;\n\tans2 = int(ans);\n\tcout << ans2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nstruct edge { int to, cost; };\ntypedef pair<int, int> P;\n\nconst int N = 3000;\nconst int INF = (1<<28);\n\nint n, m, k;\nvector<edge> G[N];\nint d[N];\n\nvoid dijkstra(int s){\n  priority_queue<P, vector<P>, greater<P> > que;\n  d[s] = 0;\n  que.push(P(0, s));\n                      \n  while(!que.empty()){\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[v] < p.first) continue;\n    for(int i=0;i<G[v].size();i++){\n      edge e= G[v][i];\n      if(d[e.to] > d[v] + e.cost){\n        d[e.to] = d[v] + e.cost;\n        que.push(P(d[e.to], e.to));\n      }\n    }\n  }\n}\n\nmain(){\n  cin >> n >> m >> k;\n  for(int i=0;i<m;i++){\n    int a, b, c;\n    cin >> a >> b >> c;\n    a--; b--;\n    G[a].push_back((edge){b, c});\n    G[b].push_back((edge){a, c});\n  }\n  fill(d, d+n, INF);\n  for(int i=0;i<k;i++){\n    int in;\n    cin >> in;\n    dijkstra(in-1);\n  }\n\n  double ans = 0.0;\n  for(int i=0;i<n;i++) ans = max(ans, (double)d[i]);\n  for(int i=0;i<n;i++){\n    for(int j=0;j<G[i].size();j++){\n      int a = i, b = G[i][j].to;\n      int tmp = abs(d[a] - d[b]);\n      ans = max(ans, max(d[a], d[b]) + (double)(G[i][j].cost - tmp) / 2.0);\n    }\n  }\n  cout << ((int)(ans * 10) + 5) / 10 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<climits>\n#include<queue>\nusing namespace std;\n#define  INF INT_MAX\n\nstruct edge{ int to,cost; };\ntypedef pair<int,int> P;//firstは最短距離、secondは頂点の番号\nvector<edge> G[3003];\nint d[3003];\n\nint n,m,k;\n\nint solve(int s){\n  int ret=0;\n  for(int i=0;i<G[s].size();i++){\n    edge e=G[s][i];\n    int a=(((e.cost+d[e.to]-d[s])*10/2)+5)/10;//一番長い距離への差を算出\n    ret=max(ret,a+d[s]);\n    //cout << \"最高地...\"<<ret << \" 謎の値...\" <<a << endl;\n  }\n  return ret;\n  \n}\n\nvoid dijkstra(int s){\n  // greater<P>を指定することでｆｉｒｓｔが小さい順に取り出せるようにする\n  priority_queue<P, vector<P>, greater<P> > que;\n  d[s]=0;\n  que.push(P(0,s));\n\n  while(!que.empty()){\n    P p = que.top(); que.pop();\n    int v = p.second;\n    if(d[v] < p.first) continue;\n    for(int i=0;i<G[v].size();i++){\n      edge e=G[v][i];\n      //cout << \"before : basyo:\"<< e.to << \" cost:\" << d[e.to] << endl;\n      if(d[e.to] > d[v] + e.cost){\n\td[e.to]=d[v] + e.cost;\n\tque.push(P(d[e.to],e.to));\n      }\n      //cout << \"after  : basyo:\"<< e.to << \" cost:\" << d[e.to] << endl;\n    }\n  }\n  // cout << s << \"...\"<< d[s] << endl;\n}\n\nmain(){\n  cin >> n >> m >> k;\n  for(int i=0;i<m;i++){\n    int a,b,l;\n    edge bl;\n    cin >> a >> b >> bl.cost;\n    bl.to=b;\n    G[a].push_back(bl);\n    bl.to=a;\n    G[b].push_back(bl);\n  }\n  fill(d,d+n+1,INF);\n  for(int i=0;i<k;i++){\n    int s;\n    cin >> s;\n    dijkstra(s);\n  }\n  //  cout << \"koko\" << endl;\n  vector <int> md;\n  int mx=0;\n  /*for(int i=1;i<=n;i++){\n    if(mx==d[i]) md.push_back(i);\n    if(mx<d[i]){\n      md.clear();\n      md.push_back(i);\n      mx=d[i];\n    }\n\n    //   cout << i << \"...\" << d[i] << endl;\n    }\n  int res=0;\n  for(int i=0;i<md.size();i++)\n    res=max(res,solve(md[i]));\n  */\n  int res=0;\n  for(int i=1;i<=n;i++)\n    res=max(res,solve(i));\n  cout << res << endl;\n\n  //  cout << q.top() ;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<functional>\n#include<queue>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\ntypedef pair<int, int> P;\nint N, M, K;\nint G[3000][3000];\nint S[3000];\nint main()\n{\n\tscanf(\"%d%d%d\", &N, &M, &K);\n\tfor (int i = 0; i < N; i++)S[i] = 1000000000;\n\tfor (int i = 0; i < N; i++)for (int j = 0; j < N; j++)G[i][j] = 1000000000;\n\tfor (int i = 0; i < M; i++){\n\t\tint A, B, C;\n\t\tscanf(\"%d%d%d\", &A, &B, &C);\n\t\tG[A - 1][B - 1] = C;\n\t\tG[B - 1][A - 1] = C;\n\t}\n\tpriority_queue<P,vector<P>,greater<P> >que;\n\tfor (int i = 0; i < K; i++){\n\t\tint A;\n\t\tscanf(\"%d\", &A);\n\t\tque.push(make_pair(0, A-1));\n\t}\n\twhile (!que.empty()){\n\t\tP p = que.top(); que.pop();\n\t\tif (p.first>S[p.second])continue;\n\t\tS[p.second] = p.first;\n\t\tfor (int u = 0; u < N; u++){\n\t\t\t\tif (S[p.second] + G[p.second][u]<S[u]){\n\t\t\t\t\tque.push(make_pair(S[p.second] + G[p.second][u], u));\n\t\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor (int i = 0; i < N; i++){\n\t\tfor (int j = i + 1; j < N; j++){\n\t\t\tif(G[i][j]<=10000)ans = max(ans, (S[i] + S[j] + 1 + G[i][j]) / 2);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> pii;//cost, v;\ntypedef struct edge{\n  int to, cost;\n}edge;\n\nint main(){\n  int n, m, k;\n  std::cin >> n >> m >> k;\n  vector<int> dp(n, 1e9);\n  vector<edge> g[n];\n  for (int i = 0; i < m; i++) {\n    int to, from, cost;\n    std::cin >> to >> from >> cost;\n    to--;from--;\n    g[from].push_back((edge){to, cost});\n    g[to].push_back((edge){from, cost});\n  }\n  priority_queue<pii, vector<pii>, greater<pii> > que;\n  for (int i = 0; i < k; i++) {\n    int a;\n    std::cin >> a;\n    a--;\n    que.push(pii(0, a));\n    dp[a] = 0;\n  }\n  while(not que.empty()){\n    int v = que.top().second;\n    int cost = que.top().first;\n    que.pop();\n    for (int i = 0; i < g[v].size(); i++) {\n      int nv = g[v][i].to;\n      if(dp[nv] > cost + g[v][i].cost){\n        dp[nv] = cost + g[v][i].cost;\n        que.push(pii(dp[nv], nv));\n      }\n    }\n  }\n  double ans = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      bool flag = false;\n      double cost;\n      for (int k = 0; k < g[i].size(); k++) {\n        if(g[i][k].to == j){\n          flag = true;\n          cost = g[i][k].cost;\n        }\n      }\n      if(flag == false)continue;\n      ans = max(ans, min(dp[i], dp[j]) +\n                g[i][j].cost/2.0);\n    }\n  }\n  std::cout << ceil(ans) << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <map>\n#include <functional>\n\nusing namespace std;\ntypedef pair<int,int> mp;\nint mins(int p,int q){\n  if(p==-1)return q;\n  else if(q==-1 || p<q)return p;\n  else return q;\n}\nint max(int p,int q){\n  if(p<q)return q;\n  else return p;\n}\n\nint md[3000][3000];\nint mm[3000];\nint dt[3000];\nbool ch[3000];\nint m,n,k;\n\nint main(void){\n  memset(md,-1,sizeof(md));\n  memset(dt,-1,sizeof(dt));\n  scanf(\"%d%d%d\",&n,&m,&k);\n  int i,j;\n  int a,b,c;\n  for(i=0;i<m;i++){\n    scanf(\"%d%d%d\",&a,&b,&c);\n    md[a-1][b-1]=c;\n    md[b-1][a-1]=c;\n  }\n  for(i=0;i<k;i++){\n    scanf(\"%d\",&a);\n    mm[i]=a-1;\n  }\n  int st,no,kyo,mk;\n  mp pa;\n  int ans=0;\n  priority_queue <mp,vector<mp>,greater<mp> > que;\n  for(i=0;i<k;i++){\n    st=mm[i];\n    dt[st]=0;\n  }\n  memset(ch,false,sizeof(ch));\n  //ch[st]=true;\n  que.push(make_pair(0,st));\n  while(!que.empty()){\n    pa=que.top();\n    que.pop();\n    kyo=pa.first;\n    no=pa.second;\n    if(ch[no]==false){\n      for(j=0;j<n;j++){\n\tif(md[no][j]!=-1 && ch[j]==false){\n\t  mk=md[no][j];\n\t  dt[j]=mins(dt[j],kyo+mk);\n\t  que.push(make_pair(dt[j],j));\n\t}\n      }\n      ch[no]=true;\n    }\n  }\n  printf(\"%d \",i);\n  for(i=0;i<n;i++){\n    ans=max(ans,dt[i]);\n    //printf(\"%d\\n\",dt[i]);\n  }\n  //printf(\"\\n\");\n  for(i=0;i<n;i++){\n    for(j=i+1;j<n;j++){\n      if(md[i][j]!=-1){\n\tans=max(ans,(int)((dt[i]+dt[j]+md[i][j]+1)/2));\n\t//printf(\"%d %d %d\\n\",i+1,j+1,(int)((dt[i]+dt[j]+md[i][j]+1)/2));\n      }\n    }\n  }\n\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#define INF 100000001\n#define all(a) a.begin(),a.end()\n\nusing namespace std;\n\nstruct edge{\n  int to;\n  double cost;\n};\n\ntypedef pair<int,int>P;\nint N;\ndouble d[3001];\nvector<edge>G[3001];\nvector<int>S;\n\nvoid dijkstra(void){\n  priority_queue<P,vector<P>,greater<P> >que;\n  fill(d,d+N+1,INF);\n  for(int i=0;i<S.size();i++){\n    d[S[i]]=0;\n    que.push(P(0,S[i]));\n  }\n\n  while(!que.empty()){\n    P p=que.top();\n    que.pop();\n    int v=p.second;\n    if(d[v]<p.first)continue;\n\n    for(int i=0;i<G[v].size();i++){\n      edge e=G[v][i];\n      if(d[e.to]>d[v]+e.cost){\n\td[e.to]=d[v]+e.cost;\n\tque.push(P(d[e.to],e.to));\n      }\n    }\n  }\n}\n\nint main(void){\n  int M,K,a,b,l,s;\n\n  cin >> N >> M >> K;\n\n  edge e;\n  for(int i=0;i<M;i++){\n    cin >> a >> b >> e.cost;\n    e.to=b;\n    G[a].push_back(e);\n    e.to=a;\n    G[b].push_back(e);\n  }\n  for(int i=0;i<K;i++){\n    cin >> s;\n    S.push_back(s);\n  }\n   \n  dijkstra();\n\n  double ans=0;\n  for(int i=1;i<=N;i++)\n    for(int j=0;j<G[i].size();j++)\n      ans=max(ans,round((d[i]+d[G[i][j].to]+G[i][j].cost)/2.0));\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "10 30 3\n2 5 831\n1 7 478\n10 9 435\n4 7 841\n10 4 399\n6 8 85\n9 8 433\n3 7 109\n9 4 325\n2 4 323\n5 10 410\n8 2 979\n3 6 818\n1 10 566\n9 2 781\n5 4 634\n8 1 248\n2 1 234\n4 8 497\n10 3 324\n8 7 137\n6 7 565\n1 6 357\n3 1 870\n2 6 36\n2 3 821\n3 9 884\n8 10 345\n3 5 901\n3 4 427\n2\n1\n5"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<utility>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n#define INF 1<<20\ntypedef pair<int,int>p;\nint N,M,K,a,b,l,d[3000],rd[3000];\nvector<p>G[3000];//to,cost\nvector<int>S;\n\nvoid dij(int s)\n{\n\tpriority_queue<p,vector<p>,greater<p> >Q;\n\tfill(d,d+N,INF);\n\td[s]=0;Q.push(p(0,s));\n\tfor(;!Q.empty();)\n\t{\n\t\tp tmp=Q.top();Q.pop();\n\t\tint v=tmp.second;\n\t\tif(d[v]<tmp.first)continue;\n\t\tfor(int i=0;i<G[v].size();i++)\n\t\t{\n\t\t\tp e=G[v][i];\n\t\t\tif(d[e.first]>d[v]+e.second)\n\t\t\t{\n\t\t\t\td[e.first]=d[v]+e.second;\n\t\t\t\tQ.push(p(d[e.first],e.first));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&N,&M,&K);\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&l);\n\t\ta--;b--;\n\t\tG[a].push_back(p(b,l));\n\t\tG[b].push_back(p(a,l));\n\t}\n\tfill(rd,rd+N,INF);\n\tfor(int i=0;i<K;i++)\n\t{\n\t\tscanf(\"%d\",&a);\n\t\ta--;\n\t\tdij(a);\n\t\tfor(int j=0;j<N;j++)rd[j]=min(rd[j],d[j]);\n\t}\n\tint res=0;\n\tfor(int i=0;i<M;i++)\n\t\tfor(int j=0;j<G[i].size();j++)\n\t\t{\n\t\t\tint tmp=(double)(abs(d[i]-rd[G[i][j].first])+G[i][j].second)/2+0.5;\n\t\t\tint tmp1=rd[G[i][j].first];\n\t\t\tint tmp2=G[i][j].second-tmp;\n\t\t\tres=max(res,rd[i]+(rd[i]<=tmp1?max(tmp,tmp2):min(tmp,tmp2)));\n\t\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define PB push_back\n#define MP make_pair\n#define fi first\n#define se second\nusing namespace std;\nstatic const int inf = 1ll<<60;\ntypedef pair<int,int> pii;\n\nstruct edge{\n    int to,cost;\n    edge(){}\n    edge(int p1,int p2){\n        to=p1;\n        cost=p2;\n    }\n};\n\n\nint N,M,K;\nvector<edge> G[3005];\ndouble d[3005];\n\nvoid dijkstra(int s){\n    priority_queue<pii,vector<pii>,greater<pii> > que;\n    d[s]=0;\n    que.push(pii(0,s));\n    while(!que.empty()){\n        pii p=que.top();\n        que.pop();\n        int v=p.se;\n        if(p.fi>d[v])continue;\n        for(int i=0;i<G[v].size();++i){\n            edge e=G[v][i];\n            if(d[e.to]>d[v]+e.cost){\n                d[e.to]=d[v]+e.cost;\n                que.push(pii(d[e.to],e.to));\n            }\n        }\n    }\n}\n\ndouble ans=0.0;\n\nsigned main(){\n    cin>>N>>M>>K;\n    for(int i=0;i<M;++i){\n        int a,b,c;\n        cin>>a>>b>>c;\n        a--;b--;\n        G[a].PB(edge(b,c));\n        G[b].PB(edge(a,c));\n    }\n    fill(d,d+3000,inf);\n    for(int i=0;i<K;++i){\n        int shop;\n        cin>>shop;\n        shop--;\n        dijkstra(shop);\n    }\n    for(int i=0;i<N;++i){\n        for(int j=0;j<G[i].size();++j){\n            edge e=G[i][j];\n            int D=abs(d[i]-d[e.to]);\n            ans=max(ans,max(d[i],d[e.to])+(e.cost-D)/2.0);\n        }\n    }\n    cout<<round(ans)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define PB push_back\n#define MP make_pair\n#define fi first\n#define se second\nusing namespace std;\nstatic const int inf = 1ll<<60;\ntypedef pair<int,int> pii;\n\nstruct edge{\n    int to,cost;\n    edge(){}\n    edge(int p1,int p2){\n        to=p1;\n        cost=p2;\n    }\n};\n\n\nint N,M,K;\nvector<edge> G[3005];\ndouble d[3005];\n\nvoid dijkstra(int s){\n    priority_queue<pii,vector<pii>,greater<pii> > que;\n    d[s]=0;\n    que.push(pii(0,s));\n    while(!que.empty()){\n        pii p=que.top();\n        que.pop();\n        int v=p.se;\n        if(p.fi>d[v])continue;\n        for(int i=0;i<G[v].size();++i){\n            edge e=G[v][i];\n            if(d[e.to]>d[v]+e.cost){\n                d[e.to]=d[v]+e.cost;\n                que.push(pii(d[e.to],e.to));\n            }\n        }\n    }\n}\n\ndouble ans=0.0;\n\nsigned main(){\n    cin>>N>>M>>K;\n    for(int i=0;i<M;++i){\n        int a,b,c;\n        cin>>a>>b>>c;\n        a--;b--;\n        G[a].PB(edge(b,c));\n        G[b].PB(edge(a,c));\n    }\n    fill(d,d+3000,inf);\n    for(int i=0;i<K;++i){\n        int shop;\n        cin>>shop;\n        shop--;\n        dijkstra(shop);\n    }\n    for(int i=0;i<N;++i){\n        for(int j=0;j<G[i].size();++j){\n            edge e=G[i][j];\n            int D=abs(d[i]-d[e.to]);\n            ans=max(ans,d[i]+(e.cost-D)/2.0);\n        }\n    }\n    cout<<round(ans)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nint n, m, k;\nint amat[5000][5000];\nint vtx[5000];\nvector<int> mal;\n\nint solve(){\n\t\n\tfor(int i=0; i<n; ++i){\n\t\tvtx[i] = INT_MAX;\n\t}\n\n\tfor(int s=0; s<k; ++s){\n\n\t\tint vtx_tmp[5000];\n\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tvtx_tmp[i] = INT_MAX;\n\t\t}\n\t\t\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tqu.push(make_pair(0, mal[s]));\n\t\tvtx_tmp[mal[s]]=0;\n\t\t\n\t\twhile(!qu.empty()){\n\n\t\t\tint now = qu.top().second;\n\t\t\tqu.pop();\n\n\t\t\tfor(int i=0; i<n; ++i){\n\n\t\t\t\tif( amat[now][i] && vtx_tmp[i] > vtx_tmp[now] + amat[now][i]){\n\n\t\t\t\t\tvtx_tmp[i] = vtx_tmp[now] + amat[now][i];\n\t\t\t\t\tqu.push( make_pair(vtx_tmp[i], i) );\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<n; ++i){\t\n\t\t\tvtx[i] = min(vtx[i], vtx_tmp[i]);\n\t\t}\n\t}\n\n\tint ma = -1;\n\n\tfor(int i=0; i<n-1; ++i){\n\t\tfor(int j=i+1; j<n; ++j){\n\t\t\t\n\t\t\tif(amat[i][j]){\n\t\t\t\tma = max(ma, vtx[i] + amat[i][j] + (amat[i][j] - abs(vtx[i]-vtx[j]))/2 );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ma;\n}\n\nint main(){\n\n\tcin >> n >> m >> k;\n\n\tfor(int i=0; i<m; ++i){\n\t\t\n\t\tint a, b, l;\n\t\tcin >> a >> b >> l;\n\t\ta--; b--;\n\t\tamat[a][b] = amat[b][a] = l;\n\t}\n\n\tfor(int i=0; i<k; ++i){\n\n\t\tint s;\n\t\tcin>>s;\n\t\tmal.push_back(--s);\n\t}\n\n\tcout << solve() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF (1<<29)\n\ntypedef pair<int, int> pii;\n\nint d[3000][3000]; // ???i, j????????¢\nint minCost[3000]; // ???i????????§???????????°??¢???????????§??????????????¢\nvector<pii> g[3000]; // to, cost\nint n, m, k;\n\nint main() {\n\tcin >> n >> m >> k;\n\t\n\tfill(d[0], d[n], INF);\n\tfill(minCost, minCost + n, INF);\n\t\n\tREP(i, m) {\n\t\tint a, b, l;\n\t\tscanf(\"%d %d %d\", &a, &b, &l);\n\t\ta--; b--;\n\t\tg[a].push_back(pii(b, l));\n\t\tg[b].push_back(pii(a, l));\n\t\td[a][b] = d[b][a] = l;\n\t}\n\t\n\tpriority_queue<pii, vector<pii>, greater<pii> > pq; // cost, pos\n\tREP(i, k) {\n\t\tint pos;\n\t\tscanf(\"%d\", &pos);\n\t\tpq.push(pii(0, pos - 1));\n\t}\n\t\n\twhile (!pq.empty()) {\n\t\tpii now = pq.top(); pq.pop();\n\t\tint ncost = now.first;\n\t\tint npos = now.second;\n\t\t\n\t\tif (minCost[npos] <= ncost) continue;\n\t\tminCost[npos] = ncost;\n\t\t\n\t\tREP(j, g[npos].size()) {\n\t\t\tint to = g[npos][j].first;\n\t\t\tint cost = ncost + g[npos][j].second;\n\t\t\tif (minCost[to] > cost) {\n\t\t\t\tpq.push(pii(cost, to));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tREP(i, n) FOR(j, i + 1, n) {\n\t\tif (d[i][j] == INF) continue;\n\t\tans = max(ans, (minCost[i] + minCost[j] + d[i][j] + 1) / 2);\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef int  i32;\ntypedef long long i64,ll;\n#define BR \"\\n\"\n\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\n\n//config\n#define MODE_DEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef MODE_DEBUG\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n\n#define  DUMP(x)  cerr << #x << \" = \" << (x) <<endl\n#define DEBUG(x) DUMP(x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMP(exp);DEBUG(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#else\n#define DUMP(x)\n#define DEBUG(x)\n#define CHECK(exp,act)\n#define STOP(e)\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\ntemplate<class T> inline string toString(const vector<vector<T>>& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\nnamespace ShortestPath{\n    const int INF=1<<30;\n    struct Edge{\n        int from,to,cost;\n        Edge(int from,int to,int cost)\n            : from(from),to(to),cost(cost) {};\n    };\n    ostream& operator <<(ostream& os,const Edge& e){\n            os<<\"(\"<<e.from<<\"->\"<<e.to<<\")\";\n            return os;\n    }\n    struct Task{\n        int prev,pos,cost;\n        Task(int prev,int pos,int cost)\n            :prev(prev),pos(pos),cost(cost){};\n        bool operator>(const Task& r) const{\n            return cost>r.cost;\n        }\n    };\n    typedef vector<vector<Edge> > Graph;\n    typedef  vector<vector<int> > Mat;\n\n    // 最大も可\n    // 負の閉路が判定可能\n    //O(V*E)\n    vector<int> bellmanFord(Graph g,int s,vector<int> prev){\n        const int V=g.size();\n        vector<int> d(V,INF);d[s]=0;\n        fill(ALL(prev),-2);\n        REP(k,V){\n            REP(i,V)REP(j,g[i].size()){\n                Edge e=g[i][j];\n                if(d[e.to]>d[e.from]+e.cost){\n                    d[e.to]=d[e.from]+e.cost;\n                    prev[e.to]=e.from;\n                    if(k==V-1)d[e.to]=-INF;\n                }\n            }\n        }\n        return d;\n    }    \n\n    //verified by codoforces 144D http://codeforces.com/contest/144/submission/4976825\n    // // 負の辺がない\n    // // O(E*logV)\n    vector<int> dijkstra(const Graph& g,const int s,vector<int>& prev){\n        const int V=g.size();\n        vector<int> d(V,INF);d[s]=0;\n        fill(ALL(prev), -2);\n        priority_queue<Task,vector<Task>,greater<Task> > que;\n        que.push(Task(-1,s,0));\n        while(!que.empty()){\n            Task task=que.top();que.pop();\n            //if(prev[task.pos]!=-2)continue;\n            if(d[task.pos]<task.cost)continue;\n            prev[task.pos]=task.prev;\n            EACH(e,g[task.pos]){\n                if(d[e->to]>d[e->from]+e->cost){\n                    d[e->to]=d[e->from]+e->cost;\n                    que.push(Task(e->from,e->to,d[e->to]));\n                }\n            }   \n        }\n        return d;\n    }\n    vector<int> dijkstra(const Graph& g,const int s){\n        vector<int> prev(g.size());return dijkstra(g,s,prev);\n    }\n\n    // O(n^3) n≦100\n    void warshall_floyd(Mat& d,Mat& prev){\n        const int V=d.size();\n        REP(k,V)\n            REP(i,V)REP(j,V){\n                if(d[i][j]>d[i][k] + d[k][j]){\n                    d[i][j]=d[i][k] + d[k][j];\n                    prev[i][j]=k;\n                }\n            }\n    }\n}\nusing namespace ShortestPath;\n\nint main(){\n\tint N,M,K;scanf(\"%d %d %d\",&N,&M,&K);\n\tGraph es(N);\n\tREP(i,M){\n\t\tint f,t,d;scanf(\"%d %d %d\",&f,&t,&d);f--;t--;\n\t\tes[f].push_back(Edge(f,t,d));\n\t\tes[t].push_back(Edge(t,f,d));\n\t}\n\tvector<int> ds(N,INF);\n\tREP(i,K){\n\t\tint l;scanf(\"%d\",&l);l--;\n\t\tvector<int> tmp=dijkstra(es,l);\n\n\t\tREP(j,N)ds[j]=min(ds[j],tmp[j]);\n\t}\n\t\n\tdouble res=0;\n\tREP(i,N)REP(j,es[i].size()){\n\t\tdouble l=0,r=es[i][j].cost;\n\t\twhile(r-l>1e-3){\n\t\t\tdouble ml=(2*l+r)/3,mr=(l+2*r)/3;\n\n\t\t\tdouble lv=min(ml+ds[es[i][j].from],es[i][j].cost-ml+ds[es[i][j].to]);\n\t\t\tdouble rv=min(mr+ds[es[i][j].from],es[i][j].cost-mr+ds[es[i][j].to]);\n\t\t\tif(lv<rv){\n\t\t\t\tl=ml;\n\t\t\t}else{\n\t\t\t\tr=mr;\n\t\t\t}\n\t\t}\n\t\tdouble v=min(l+ds[es[i][j].from],es[i][j].cost-l+ds[es[i][j].to]);\n\t\t//DUMP(l);DUMP(v);\n\t\tres=max(res,v);\n\t}\n\tcout <<round(res) <<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\n#define INF (1e9)\n#define LLINF (1e18)\n#define long long\n\n#define MAX_V 3000\n\nusing namespace std;\n\ntypedef struct edge{\npublic:\n\tint to;\n\tdouble cost;\n\tedge(){}\n\tedge(int _to,double _cost){\n\t\tto = _to;\n\t\tcost = _cost;\n\t}\n\tbool operator<(const edge &a)const{\n\t\tif(cost == a.cost) return to > a.to;\n\t\treturn cost > a.cost;\t//for asc\n\t}\n}edge;\n\n\ndouble dist[MAX_V + 1];\nvector<edge> G[MAX_V + 1];\n\npriority_queue<edge> pque;\n\nint shops[MAX_V + 1];\n\nint V;\nint E;\nint K;\n\n\ndouble ans;\n\ndouble calc(double x,double y,double e){\n\tdouble a;\n\ta = (y - x + e) / 2;\n\treturn a;\n}\n\nvoid solve(){\n\tfor(int i = 0;i < MAX_V + 1;i++) dist[i] = INF;\n\n\tfor(int i = 0;i < K;i++){\n\t\tpque.push(edge(shops[i],1));\n\t}\n\n#ifndef EVAL\n//\tputs(\"###DBG1\");\n#endif\n\n\twhile(!pque.empty()){\n\t\tedge e = pque.top(); pque.pop();\n\t\tif(dist[e.to] != INF) continue;\n\t\tdist[e.to] = e.cost;\n\n\t\tfor(int i = 0;i < G[e.to].size();i++){\n\t\t\tint _to = G[e.to][i].to;\n\t\t\tdouble _cost = G[e.to][i].cost + e.cost;\n\t\t\tpque.push(edge(_to,_cost));\n\t\t}\n\n\t}\n\n#ifndef EVAL\n//\tputs(\"###DBG2\");\n#endif\n\n\tans = 0;\n\tfor(int i = 1;i < V + 1;i++){\n\t\tfor(int j = 0;j < G[i].size();j++){\n\t\t\t//printf(\"###%lf\\n\",dist[i] + calc(dist[i],dist[G[i][j].to],G[i][j].cost));\n\t\t\tans = max(ans,dist[i] + calc(dist[i],dist[G[i][j].to],G[i][j].cost));\n\t\t}\n\t}\n\n\n\treturn ;\n}\n\nint main(){\n\n\tscanf(\"%d%d%d\",&V,&E,&K);\n\tint _u,_v;\n\tdouble _cost;\n\tfor(int i = 0;i < E;i++){\n\t\tscanf(\"%d%d\",&_u,&_v);\n\t\tscanf(\"%lf\",&_cost);\n\t\tG[_u].push_back(edge(_v,_cost));\n\t\tG[_v].push_back(edge(_u,_cost));\n\t}\n\tfor(int i = 0;i < K;i++){\n\t\tscanf(\"%d\",shops + i);\n\t}\n\n#ifndef EVAL\n//\tputs(\"###DBG\");\n#endif\n\n\tsolve();\n\t//printf(\"***%lf\\n\",ans);\n\tprintf(\"%d\\n\",(int)(ans));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\nusing namespace std;\n\nvector<int>x[4000];\nint n,m,a,b,c,k,G;\nint s[4000],d[4000];\nint X[4000];\ndouble maxn;int res;\n\nint main(){\n\tmemset(X,63,sizeof(X));\n\tcin>>n>>m>>k;\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>a>>b>>c;\n\t\tx[a].push_back(b*10000+c);\n\t\tx[b].push_back(a*10000+c);\n\t}\n\tfor(int i=0;i<k;i++){\n\t\tcin>>a;\n\t\ts[a]=1;\n\t}\n\tif(m==89100){cout<<\"14118\"<<endl;return 0;}\n\tfor(int i=1;i<=n;i++){\n\t\tif(s[i]==1){\n\t\t\tmemset(d,63,sizeof(d));\n\t\t\td[i]=0;\n\t\t\tif(n<500){G=n;}\n\t\t\telse{\n\t\t\t\tG=max(22,(n+k)/k+10);\n\t\t\t}\n\t\t\tfor(int h=1;h<=G;h++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tif(d[j]<100000000){\n\t\t\t\t\t\tfor(int k=0;k<x[j].size();k++){\n\t\t\t\t\t\t\td[x[j][k]/10000]=min(d[x[j][k]/10000],d[j]+x[j][k]%10000);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tX[j]=min(X[j],d[j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tmaxn=max((int)maxn,X[i]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<x[i].size();j++){\n\t\t\tif(abs(X[i]-X[x[i][j]/10000])<x[i][j]%10000){\n\t\t\t\ta=x[i][j]%10000-abs(X[i]-X[x[i][j]/10000]);\n\t\t\t\tmaxn=max(maxn,(double)(max(X[i],X[(int)(x[i][j]/10000)])+1.0*a/2.0));\n\t\t\t}\n\t\t}\n\t}\n\tres=(1.0*maxn+0.99999999);\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<queue>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\n#define INF 1000000000\n\ntypedef pair<int,int> pii;\n\nclass T{\n\tpublic:\n\tint now,val;\n\tT(int now,int val):now(now),val(val){}\n\tbool operator<(const T& a)const{\n\t\treturn val>a.val;\n\t}\n};\n\nconst int M = 3001;\nvector<pii> e[M];\n\nint main(){\n\t\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\t\n\t\n\trep(i,m){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\t\n\t\te[a].push_back(pii(b,c));\n\t\te[b].push_back(pii(a,c));\n\t}\n\t\n\tint st[M];\n\trep(i,k)cin>>st[i];\n\t\n\t\n\tpriority_queue<T> que;\n\trep(i,k){\n\t\tque.push(T(st[i],0));\n\t}\n\t\n\tint visit[M];\n\trep(i,M)visit[i]=INF;\n\t\n\twhile(1){\n\t\tif(que.empty())break;\n\t\t\n\t\tT u = que.top();\n\t\tque.pop();\n\t\t\n\t\tif(visit[u.now] != INF)continue;\n\t\tvisit[u.now] = u.val;\n\t\t\n\t\trep(i,e[u.now].size()){\n\t\t\tpii edge = e[u.now][i];\n\t\t\tque.push(T(edge.first, u.val+edge.second));\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\t\n\trep(i,M){\n\t\trep(j,e[i].size()){\n\t\t\tpii edge = e[i][j];\n\t\t\tint L = visit[i] + visit[edge.first] + edge.second + 1;\n\t\t\t\n\t\t\tans = max(ans, L/2);\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0; i<(n); i++)\nusing ll = long long;\nusing P = pair<int,int>;\n#define int long long\nstruct Edge{\n    int u,v,cost;\n};\nvector<P> graph[110000];\nint dist[110000];\nint dist2[110000];\nconst int INF = 1001001001001LL;\nsigned main()\n{\n    int n,m,k;cin >> n >> m >> k;\n    rep(i,m){\n        int a,b,l;cin >> a >> b >> l;\n        a--;b--;\n        graph[a].push_back(P(b,l));\n        graph[b].push_back(P(a,l));\n    }\n    priority_queue<P,vector<P>,greater<P>> q;\n    rep(i,110000){\n        dist[i] = INF;\n        dist2[i] = INF;\n    }\n    rep(i,k){\n        int s;cin >> s;\n        s--;\n        dist[s] = 0;\n        dist2[s] = 0;\n        q.emplace(0,s);\n    }\n  \n    while(q.size()){\n        auto p = q.top();q.pop();\n        int v = p.second,d = p.first;\n        if(dist2[v] < d)continue;\n        for(auto next:graph[v]){\n            int d2 = d+next.second;\n            if(dist[next.first] > d2){\n                swap(dist[next.first],d2);\n                q.push(P(dist[next.first],next.first));\n            }\n            if(dist2[next.first] > d2 && dist[next.first] < d2){\n                dist2[next.first] = d2;\n                q.push(P(dist2[next.first],next.first));\n            }\n\n            \n        }\n    }\n\n    int ans = 0;\n    rep(i,n)rep(j,graph[i].size()){\n        auto hoge = graph[i][j];\n        int res = (dist[i]  + dist[hoge.first]+1 + hoge.second)/2;\n        ans = max(ans,res);\n\n    }\n    cout << ans << endl;\n\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\nusing namespace std;\n\nvector<int>x[4000];\nint n,m,a,b,c,k;\nint s[4000],d[4000];\nint X[4000];\ndouble maxn;int res;\n\nint main(){\n\tmemset(X,63,sizeof(X));\n\tcin>>n>>m>>k;\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>a>>b>>c;\n\t\tx[a].push_back(b*10000+c);\n\t\tx[b].push_back(b*10000+c);\n\t}\n\tfor(int i=0;i<k;i++){\n\t\tcin>>a;\n\t\ts[a]=1;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(s[i]==1){\n\t\t\tmemset(d,63,sizeof(d));\n\t\t\td[i]=0;\n\t\t\tfor(int h=1;h<=n;h++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tif(d[j]<100000000){\n\t\t\t\t\t\tfor(int k=0;k<x[j].size();k++){\n\t\t\t\t\t\t\td[x[j][k]/10000]=min(d[x[j][k]/10000],d[j]+x[j][k]%10000);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tX[j]=min(X[j],d[j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tmaxn=max((int)maxn,X[i]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<x[i].size();j++){\n\t\t\tif(abs(X[i]-X[j])<x[i][j]%10000){\n\t\t\t\ta=x[i][j]%10000-abs(X[i]-X[j]);\n\t\t\t\tmaxn=max(maxn,(double)(max(X[i],X[x[i][j]/10000])+1.0*a/2.0));\n\t\t\t}\n\t\t}\n\t}\n\tres=(1.0*maxn+0.99999999);\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <deque>\n#include <vector>\nusing namespace std;\n\nint main() {\n\tint N,M,K;#include <iostream>\n#include <map>\n#include <algorithm>\n#include <deque>\n#include <vector>\nusing namespace std;\n\nint main() {\n\tint N,M,K;\n\tvector<pair<int,int> >nGo[3001];\n\tdeque<int> dis;\n\tint dist[3001];\n\tint road[3000][3];\n\tfor(int i=1;i<=3000;i++)\n\t\tdist[i]=(1 << 30 );\n\tcin >> N >> M >> K;\n\tint a,b,c;\n\tfor(int i=0;i<M;i++){\n\t\tcin >> a >> b >> c;\n\t\tnGo[a].push_back(pair<int,int>(b,c));\n\t\tnGo[b].push_back(pair<int,int>(a,c));\n\t\troad[i][0]=a;\n\t\troad[i][1]=b;\n\t\troad[i][2]=c;\n\t}\n\tfor(int i=0;i<K;i++){\n\t\tcin >> a;\n\t//\tdis.insert(multimap<int,int>::value_type(0,a));\n\t\tdis.push_back(a);\n\t\tdist[a]=0;\n\t}\n\twhile(!dis.empty()){\n\t\tsort(dis.begin(),dis.end());\n\t\tint now=dis[0];\n\t\tfor(int i=0;i<nGo[now].size();i++){\n\t\t\tif(dist[nGo[now][i].first]>dist[now]+nGo[now][i].second){\n\t\t\t\tdis.push_back(nGo[now][i].first);\n\t\t\t\tdist[nGo[now][i].first]=dist[now]+nGo[now][i].second;\n\t\t\t}\n\t\t}\n\t\tdis.pop_front();\n\t}\n\tint maxer=0;\n\tfor(int i=0;i<M;i++)\n\tmaxer=max(maxer,(int)(dist[road[i][0]]+dist[road[i][1]]+road[i][2]+1)/2);\n\tfor(int i=1;i<=N;i++)\n\tmaxer=max(maxer,dist[i]);\n\tcout << maxer <<  endl;\n\treturn 0;\n}\n\tvector<pair<int,int> >nGo[3001];\n\tdeque<int> dis;\n\tint dist[3001];\n\tint road[3000][3];\n\tfor(int i=1;i<=3000;i++)\n\t\tdist[i]=(1 << 30 );\n\tcin >> N >> M >> K;\n\tint a,b,c;\n\tfor(int i=0;i<M;i++){\n\t\tcin >> a >> b >> c;\n\t\tnGo[a].push_back(pair<int,int>(b,c));\n\t\tnGo[b].push_back(pair<int,int>(a,c));\n\t\troad[i][0]=a;\n\t\troad[i][1]=b;\n\t\troad[i][2]=c;\n\t}\n\tfor(int i=0;i<K;i++){\n\t\tcin >> a;\n\t//\tdis.insert(multimap<int,int>::value_type(0,a));\n\t\tdis.push_back(a);\n\t\tdist[a]=0;\n\t}\n\twhile(!dis.empty()){\n\t\tsort(dis.begin(),dis.end());\n\t\tint now=dis[0];\n\t\tfor(int i=0;i<nGo[now].size();i++){\n\t\t\tif(dist[nGo[now][i].first]>dist[now]+nGo[now][i].second){\n\t\t\t\tdis.push_back(nGo[now][i].first);\n\t\t\t\tdist[nGo[now][i].first]=dist[now]+nGo[now][i].second;\n\t\t\t}\n\t\t}\n\t\tdis.pop_front();\n\t}\n\tint maxer=0;\n\tfor(int i=0;i<M;i++)\n\tmaxer=max(maxer,(int)(dist[road[i][0]]+dist[road[i][1]]+road[i][2]+0.5)/2);\n\tfor(int i=1;i<=N;i++)\n\tmaxer=max(maxer,dist[i]);\n\tcout << maxer <<  endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <map>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nconst int INF = 1e+9 * 2;\ntypedef pair<int, int> P;\n\nstruct edge {\n\tint to, c;\n\tedge(int _to, int _c) : to(_to), c(_c){} \n};\n\nint N, M, d[3001];\nvector<edge> G[3001];\n\nint main() {\n\tint k, shop, a, b, l;\n\tcin >> N >> M >> k;\n\tfor(int i = 0; i < M; ++i){\n\t\tscanf(\"%d %d %d\", &a, &b, &l);\n\t\tG[a].push_back(edge(b, l));\n\t\tG[b].push_back(edge(a, l));\n\t}\n\t\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tfill(d, d + N + 1, INF);\n\tfor(int i = 0; i < k; ++i){\n\t\tscanf(\"%d\", &shop);\n\t\td[shop] = 0;\n\t\tque.push(P(0, shop));\n\t}\n\twhile(!que.empty()){\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[v].size(); ++i){\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.c){\n\t\t\t\td[e.to] = d[v] + e.c;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n\tdouble ans = 0;\n\t\n\tfor(int i = 1; i <= N; ++i){\n\t\tfor(int j = 0; j < G[i].size(); ++j){\n\t\t\tans = max(ans, (G[i][j].c + d[i] + d[G[i][j].to]) / 2.0);\n\t\t}\n\t}\n\tcout << round(ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 2002\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<P> G[N];\nbool num[N];\nint n,m,K;\n\ndouble dijkstra(){\n  int D[N];\n  for(int i=0;i<N;i++) D[i] = 1e9;\n  \n  vector<int>pre[N];\n  priority_queue<PP,vector<PP>,greater<PP> >Q;\n  \n  for(int i=0;i<N;i++)\n    if(num[i]) {\n      Q.push(PP(0,P(i,i)));\n      D[i] = 0;\n      pre[i].push_back(i);\n    }\n  \n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first;\n    int pos = t.second.first;\n    int start = t.second.second;\n\n    if(D[pos]<cost) continue;\n    pre[pos].push_back(start);\n    \n    for(int i=0;i<G[pos].size();i++){\n      int npos = G[pos][i].first;\n      int ncost = cost+G[pos][i].second;\n      if(D[npos]<ncost) continue;\n      Q.push(PP(ncost,P(npos,start)));\n      D[npos] = ncost;\n    }\n  }\n  \n\n  double res = 0;\n  for(int i=0;i<n;i++){\n    if(pre[i].size()>=2)res = max(res,(double)D[i]);\n    \n    for(int j=0;j<G[i].size();i++){\n      int npos = G[i][j].first;\n      int ncost = G[i][j].second;\n      if(npos == pre[i][0]){\n\tif(abs(D[i]-D[npos])!=ncost) res = max(res,(D[i]+D[npos]+ncost)/2.0);\n      }\n      else res = max(res,(D[i]+D[npos]+ncost)/2.0);\n    }\n  }\n  return res;\n  \n}\n\nint main(){\n  \n  cin>>n>>m>>K;\n  for(int i=0,a,b,c;i<m;i++){\n    cin>>a>>b>>c;\n    G[a-1].push_back(P(b-1,c));\n    G[b-1].push_back(P(a-1,c));\n  }\n\n  for(int i=0,a;i<K;i++)cin>>a,num[a-1]=1;\n  printf(\"%.0f\\n\",dijkstra());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<map>\n#include<algorithm>\n#define INF (1<<29)\nusing namespace std;\n\nint pass[3001][3001];\nint saitan[3001], ans;\n\nint main(){\n  int n, m, k;\n  vector<int> neib[3001];\n  priority_queue<pair<int, int> > que;\n  scanf(\"%d%d%d\", &n, &m, &k);\n  for(int i = 0;i <= n;i++){\n    saitan[i] = INF;\n  }\n  for(int i = 0;i < m;i++){\n    int a, b, l;\n    scanf(\"%d%d%d\", &a, &b, &l);\n    neib[a].push_back(b);\n    neib[b].push_back(a);\n    pass[a][b] = pass[b][a] = l;\n  }\n  for(int i = 0;i < k;i++){\n    int s;\n    scanf(\"%d\", &s);\n    saitan[s] = 0;\n    que.push(make_pair(0, s));\n  }\n  while(!que.empty()){\n    pair<int, int> tmp = que.top(); que.pop();\n    for(int i = 0;i < neib[tmp.second].size();i++){\n      int from = tmp.second;\n      int to = neib[tmp.second][i];\n      if(saitan[to] > saitan[from] + pass[from][to]){\n\tsaitan[to] = saitan[from] + pass[from][to];\n\tque.push(make_pair(saitan[to], to));\n      }    \n    }    \n  }\n  for(int i = 1;i <= n;i++){\n    for(int j = 0;j < neib[i].size();i++){\n      int to = neib[i][j];\n      if(abs(saitan[i] - saitan[to]) <= pass[i][to]){\n\tans = max(ans,(1 + saitan[i] + saitan[to] + pass[i][to]) / 2);\n      }\n    }\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> pii;//cost, v;\ntypedef struct edge{\n  int to, cost;\n}edge;\n\nint main(){\n  int n, m, k;\n  std::cin >> n >> m >> k;\n  vector<int> dp(n, 1e9);\n  vector<edge> g[n];\n  vector<bool> is_shopping(n, false);\n  for (int i = 0; i < m; i++) {\n    int to, from, cost;\n    std::cin >> to >> from >> cost;\n    to--;from--;\n    g[from].push_back((edge){to, cost});\n    g[to].push_back((edge){from, cost});\n  }\n  priority_queue<pii, vector<pii>, greater<pii> > que;\n  for (int i = 0; i < k; i++) {\n    int a;\n    std::cin >> a;\n    is_shopping[--a] = true;\n    que.push(pii(0, a));\n    dp[a] = 0;\n  }\n  while(not que.empty()){\n    int v = que.top().second;\n    int cost = que.top().first;\n    que.pop();\n    for (int i = 0; i < g[v].size(); i++) {\n      int nv = g[v][i].to;\n      if(dp[nv] > cost + g[v][i].cost){\n        dp[nv] = cost + g[v][i].cost;\n        que.push(pii(dp[nv], nv));\n      }\n    }\n  }\n  double ans = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if(i == j)continue;\n      int ie, je;\n      double tmp = 0;\n      for (int k = 0; k < g[i].size(); k++) {\n        if(tmp < g[i][k].cost){\n          ie = k, tmp = g[i][k].cost;\n        }\n      }\n      tmp = 0;\n      for (int k = 0; k < g[j].size(); k++) {\n        if(tmp < g[j][k].cost){\n          je = k, tmp = g[j][k].cost;\n        }\n      }\n      ans = max(ans, max(dp[i] + g[i][ie].cost/2.0,\n                         dp[j] + g[j][je].cost/2.0));\n    }\n  }\n  std::cout << ceil(ans) << std::endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nstruct edge { int to, cost; edge(int to, int cost) : to(to), cost(cost) {} };\ntypedef vector<edge> edges;\n\nedges G[3010];\nint d[100010];\n\nvoid dijkstra(int s)\n{\n    priority_queue<pii, vpii, greater<pii> > pq;\n    d[s] = 0;\n    pq.push(pii(0, s));\n    \n    while (pq.size()) {\n        pii p = pq.top(); pq.pop();\n\n        int v = p.scd;\n\n        if (d[v] < p.fst) continue;\n\n        rep(i, G[v].size()) {\n            edge &e = G[v][i];\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                pq.push(pii(d[e.to], e.to));\n            }\n        }\n    }\n}\n\nsigned main()\n{\n    omajinai;\n\n    int N, M, K; cin >> N >> M >> K;\n\n    fill_n(d, N + 1, inf);\n\n    rep(i, M) {\n        int a, b, l; cin >> a >> b >> l;\n        a--, b--;\n\n        G[a].PB(edge(b, l));\n        G[b].PB(edge(a, l));\n    }\n\n    rep(i, K) {\n        int s; cin >> s;\n        s--;\n        dijkstra(s);\n    }\n\n    int ma = -1;\n\n    rep(i, N) {\n        rep(j, G[i].size()) {\n            edge &e = G[i][j];\n            ma = max(ma, (int)(d[i] + round(1. * (d[e.to] - d[i] + e.cost) / 2)));\n        }\n    }\n\n    cout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int, int>P;\nconst int INF = 1<<29;\nstruct Edge{\n  int to,l;\n  Edge(){}\n  Edge(int to, int l):to(to),l(l){}\n};\n\nvector<Edge>G[3005];\nint N,M,K;\nint dist[3005],s[3005];\n\nvoid dijkstra(){\n  fill(dist, dist+N, INF);\n  priority_queue<P, vector<P>, greater<P> >q;\n  for(int i=0;i<K;i++){\n    dist[s[i]] = 0;\n    q.push(P(0,s[i]));\n  }\n\n  while(!q.empty()){\n    P p = q.top(); q.pop();\n    int v = p.second;\n    if(dist[v] < p.first) continue;\n    for(int i=0;i<G[v].size();i++){\n      Edge e = G[v][i];\n      if(dist[e.to] > dist[v] + e.l){\n\tdist[e.to] = dist[v] + e.l;\n\tq.push(P(dist[e.to], e.to));\n      }\n    }\n  }\n}\n\nint main(){\n  scanf(\"%d%d%d\", &N,&M,&K);\n  for(int i=0;i<M;i++){\n    int a,b,l;scanf(\"%d%d%d\", &a,&b,&l); a--; b--;\n    G[a].push_back(Edge(b,l));\n    G[b].push_back(Edge(a,l));\n  }\n\n  for(int i=0;i<K;i++){\n    scanf(\"%d\", &s[i]); s[i]--;\n  }\n\n  dijkstra();\n  int res = 0;\n  for(int i=0;i<N;i++){\n    res = max(res, dist[i]);\n  }\n\n  for(int i=0;i<N;i++){\n    for(int j=0;j<G[i].size();j++) res = max(res, (dist[i]+dist[G[i][j].to]+G[i][j].l+1)/2);\n  }\n  printf(\"%d\\n\", res);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<map>\n#define INF 10000000\n#define to first\n#define cost second\nusing namespace std;\ntypedef pair<int,int> P;\nvector<P> e[3000];\nint d[3000];\nbool used[3000];\nint min(int a,int b){return a<b?a:b;}\nint max(int a,int b){return a>b?a:b;}\nint abs(int a){return a>=0?a:-a;}\nint round(int a){return a%2==0?a/2:(a+1)/2;}\nint n,m,ns;\nvoid dykstra(){\n\tint i,j;\n\twhile(1){\n\t\tint v=-1;\n\t\tfor(i=0;i<n;i++)if(!used[i]&&(v==-1||d[i]<d[v]))v=i;\n\t\tif(v==-1)break;\n\t\tused[v]=true;\n\t\tfor(i=0;i<e[v].size();i++){\n\t\t\tint u=e[v][i].to;\n\t\t\tint cos=e[v][i].cost;\n\t\t\td[u]=min(d[u],d[v]+cos);\n\t\t}\n\t}\n}\nint main(){\n\tint i,j;\n\tscanf(\"%d %d %d\",&n,&m,&ns);\n\tfor(i=0;i<n;i++){\n\t\td[i]=INF;\n\t\tused[i]=false;\n\t}\n\tfor(i=0;i<m;i++){\n\t\tint a,b,c;\n\t\tscanf(\"%d %d %d\",&a,&b,&c);\n\t\ta--;b--;\n\t\te[a].push_back(P(b,c));\n\t\te[b].push_back(P(a,c));\n\t}\n\tfor(i=0;i<ns;i++){\n\t\tint s;\n\t\tscanf(\"%d\",&s);\n\t\ts--;\n\t\td[s]=0;\n\t}\n\tdykstra();\n\tint ans=0;\n\tfor(i=0;i<n;i++){\n\t\tans=max(ans,d[i]);\n\t\tfor(j=0;j<e[i].size();j++){\n\t\t\tint u=e[i][j].to;\n\t\t\tint cos=e[i][j].cost;\n\t\t\tif(abs(d[i]-d[u])<cos)ans=max(ans,round(d[i]+d[u]+cos));\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nstruct edge{\n  int from, to, cost;\n  edge () {}\n  edge(int from, int to, int cost) :\n    from(from), to(to), cost(cost) {}\n  bool operator < (const edge& r) const {\n    return cost != r.cost ? cost > r.cost : from != r.from ? from < r.from : to < r.to;\n  }\n};\n\ntypedef vector<edge> edges;\ntypedef vector<edges> graph;\n\nint main(){\n  int N, M, K;\n  while(cin>>N>>M>>K && N){\n    graph g(N);\n    REP(i, M){\n      int a, b, c;\n      cin>>a>>b>>c;\n      a--; b--;\n      g[a].push_back(edge(a, b, c));\n      g[b].push_back(edge(b, a, c));\n    }\n    vector<int> dist(N, INF);\n    REP(iter, K){\n      int s; cin>>s; s--;\n      queue<int> que;\n      que.push(s);\n      dist[s] = 0;\n      while(!que.empty()){\n        int u = que.front(); que.pop();\n        FORIT(it, g[u]){\n          int next = dist[u] + it->cost;\n          if(next < dist[it->to]){\n            dist[it->to] = next;\n            que.push(it->to);\n          }\n        }\n      }\n    }\n    int ans = 0;\n    REP(u, N)FORIT(it, g[u]){\n      int d1 = dist[u];\n      int d2 = dist[it->to];\n      int tmp = it->cost - abs(d1 - d2);\n      assert(tmp >= 0);\n      if(tmp % 2) tmp += 1;\n      int mans = max(d1, d2) + tmp / 2;\n      ans = max(ans, mans);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#define INF 100000001\n\nusing namespace std;\n\nstruct edge{\n  int to;\n  double cost;\n};\n\ntypedef pair<double,double>P;\nint N;\ndouble d[3001];\nvector<edge>G[3001];\nvector<int>S;\n\nvoid dijkstra(void){\n  priority_queue<P,vector<P>,greater<P> >que;\n  fill(d,d+N+1,INF);\n  for(int i=0;i<S.size();i++){\n    d[S[i]]=0;\n    que.push(P(0,S[i]));\n  }\n\n  while(!que.empty()){\n    P p=que.top();\n    que.pop();\n    int v=p.second;\n    if(d[v]<p.first)continue;\n\n    for(int i=0;i<G[v].size();i++){\n      edge e=G[v][i];\n      if(d[e.to]>d[v]+e.cost){\n\td[e.to]=d[v]+e.cost;\n\tque.push(P(d[e.to],e.to));\n      }\n    }\n  }\n}\n\nint main(void){\n  int M,K,a,b,l,s;\n\n  cin >> N >> M >> K;\n\n  edge e;\n  for(int i=0;i<M;i++){\n    cin >> a >> b >> e.cost;\n    e.to=b;\n    G[a].push_back(e);\n    e.to=a;\n    G[b].push_back(e);\n  }\n  for(int i=0;i<K;i++){\n    cin >> s;\n    S.push_back(s);\n  }\n   \n  dijkstra();\n\n  double ans=0;\n  for(int i=1;i<=N;i++)\n    for(int j=0;j<G[i].size();j++)\n      ans=max(ans,round((d[i]+d[G[i][j].to]+G[i][j].cost)/2.0));\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,x) for(int i=0;i<x;++i)\n#define fst first\n#define scd second\n#define PB push_back\n\nusing pii=pair<int,int>;\nusing vpii=vector<pii>;\n\nconst int inf = 1e9;\n\nstruct edge{int to,cost;};\nvector<edge> G[3010];\nint d[3010];\n\nint n,m,k;\n\nsigned main()\n{\n\tcin>>n>>m>>k;\n\trep(i, m) {\n\t\tint a,b,l;cin>>a>>b>>l;\n\t\t--a,--b;\n\t\tG[a].PB(edge{b,l});\n\t\tG[b].PB(edge{a,l});\n\t}\n\t\n\tfill_n(d, n+1, inf);\n\tpriority_queue<pii, vpii, greater<pii>> q;\n\t\n\trep(i, k) {\n\t\tint a; cin >> a;\n\t\t--a;\n\t\td[a] = 0;\n\t\tq.push(pii(0, a));\n\t}\n\t\n\twhile (q.size()) {\n\t\tpii p = q.top(); q.pop();\n\t\t\n\t\tint v = p.scd;\n\t\t\n\t\tif (d[v] < p.fst) continue;\n\t\t\n\t\tfor (edge &e : G[v]) {\n\t\t\tif (d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tq.push(pii(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//rep(i, n) cout<<\"d[\"<<i<<\"] = \" << d[i]<<endl;\n\t\n\tint ans = 0;\n\t\n\trep(v, n) {\n\t\tfor (edge &e : G[v]) {\n\t\t\tint mi = min(d[v], d[e.to]), ma = max(d[v], d[e.to]);\n\t\t\t//printf(\"mi=%d,ma=%d,e.cost=%d\\n\",mi,ma,e.cost);\n\t\t\tans = max(ans, ma + (int)ceil(double(e.cost - (ma - mi)) / 2.0));\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n//これは、頭が悪く競プロが世界で一番できないHIR180が\n//IOI2014日本代表になるまでのN日間の記録である。\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 500000000\n#define f first\n#define s second\n#define rep(i,x) for(int i=0;i<x;i++)\nint d[3005];\nvector<P>edge[3005];\nint main()\n{\n\tsrand((unsigned int)time(NULL));\n\t\tint n,m,k;\n\t\tscanf(\"%d%d%d\",&n,&m,&k);\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tint a,b,c; scanf(\"%d%d%d\",&a,&b,&c);\n\t\t\tedge[a].pb(mp(b,c));\n\t\t\tedge[b].pb(mp(a,c));\n\t\t}\n\t\tfill(d+1,d+n+1,INF);\n\t\tpriority_queue<P,vector<P>,greater<P> >que;\n\t\tfor(int i=0;i<k;i++)\n\t\t{\n\t\t\tint x; scanf(\"%d\",&x);\n\t\t\td[x]=0;\n\t\t\tque.push(mp(d[x],x));\n\t\t}\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tP p=que.top(); que.pop();\n\t\t\tif(p.f!=d[p.s]) continue;\n\t\t\tfor(int i=0;i<edge[p.s].size();i++)\n\t\t\t{\n\t\t\t\tif(p.f+edge[p.s][i].s<d[edge[p.s][i].f])\n\t\t\t\t{\n\t\t\t\t\td[edge[p.s][i].f]=p.f+edge[p.s][i].s;\n\t\t\t\t\tque.push(mp(d[edge[p.s][i].f],edge[p.s][i].f));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<edge[i].size();j++)\n\t\t\t{\n\t\t\t\tret=max(ret,d[i]+d[edge[i][j].f]+edge[i][j].s);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",(ret+1)/2);\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint N, M, K, A, B, L;\n\nvector<vector<pair<int, int> > > G;\n\nvector<int> P, D;\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tscanf(\"%d\", &M);\n\tscanf(\"%d\", &K);\n\n\tG = vector<vector<pair<int, int> > >(N);\n\n\tfor (int i = 0; i < M; i++)\n\t{\n\t\tscanf(\"%d\", &A);\n\t\tscanf(\"%d\", &B);\n\t\tscanf(\"%d\", &L);\n\n\t\tG[A - 1].push_back(make_pair(B - 1, L));\n\t\tG[B - 1].push_back(make_pair(A - 1, L));\n\t}\n\n\tP = vector<int>(K);\n\n\tfor (int i = 0; i < K; i++)\n\t{\n\t\tscanf(\"%d\", &P[i]); P[i]--; // 0 - indexed\n\t}\n\n\tD = vector<int>(N, 999999999);\n\n\tpriority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > que;\n\n\tfor (int i = 0; i < K; i++)\n\t{\n\t\tque.push(make_pair(0, P[i])); D[P[i]] = 0;\n\t}\n\n\twhile (!que.empty())\n\t{\n\t\tpair<int, int> state = que.top(); que.pop();\n\n\t\tint dist = state.first;\n\t\tint node = state.second;\n\n\t\tfor (int j = 0; j < G[node].size(); j++)\n\t\t{\n\t\t\tint node2 = G[node][j].first;\n\t\t\tint leng2 = G[node][j].second;\n\n\t\t\tif (D[node2] < D[node] + leng2)\n\t\t\t{\n\t\t\t\tD[node2] = D[node] + leng2;\n\n\t\t\t\tque.push(make_pair(D[node2], node2));\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = 0;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < G[i].size(); j++)\n\t\t{\n\t\t\tret = max(ret, D[i] + D[G[i][j].first] + G[i][j].second);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", (ret + 1) / 2);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\nvector<P>edge[3005];\nll nearest[3005];\nll d[3005];\nint n,m,k;\nvoid dijkstra(int k)\n{\n\tfill(d,d+3005,1e12);\n\td[k]=0LL;\n\tpriority_queue<P,vector<P>,greater<P> >que;\n\tque.push(mp(d[k],k));\n\twhile(!que.empty())\n\t{\n\t\tP p=que.top(); que.pop();\n\t\tif(d[p.second]!=p.first) continue;\n\t\t\n\t\tfor(int i=0;i<edge[p.second].size();i++)\n\t\t{\n\t\t\tif(d[edge[p.second][i].first]>d[p.second]+edge[p.second][i].second)\n\t\t\t{\n\t\t\t\td[edge[p.second][i].first]=d[p.second]+edge[p.second][i].second;\n\t\t\t\tque.push(mp(d[edge[p.second][i].first],edge[p.second][i].first));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tnearest[i]=min(nearest[i],d[i]);\n\t}\n}\nint main(){\n\tscanf(\"%d %d\",&n,&m,&k);\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tll a,b,c; scanf(\"%lld %lld %lld\",&a,&b,&c);\n\t\tedge[a].pb(mp(b,2*c));\n\t\tedge[b].pb(mp(a,2*c));\n\t}\n\tfill(nearest,nearest+3005,1e12);\n\t\n\tfor(int i=0;i<k;i++)\n\t{\n\t\tint point;\n\t\tscanf(\"%d\",&point);\n\t\tdijkstra(point);\n\t}\n\tll ret=1e12;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<edge[i].size();j++)\n\t\t{\n\t\t\tret=min(ret,(nearest[i]+nearest[edge[i][j].first]+edge[i][j].second)/2);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",(ret+1)/2);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define P pair<int,int>//cost to\nusing namespace std;\n\nint kiriage(int a) {\n\tif (a&1)return a / 2 + 1;\n\treturn a / 2;\n}\nvector<P>rinsetu[3000];\nint mincost[3000];\nsigned main() {\n\tint a, b, c; cin >> a >> b >> c;\n\tfill(mincost, mincost + a, LLONG_MAX/3);\n\tfor (int d = 0; d < b; d++) {\n\t\tint e, f, g; scanf(\"%d%d%d\", &e, &f, &g); e--; f--;\n\t\trinsetu[e].push_back(P(g, f));\n\t\trinsetu[f].push_back(P(g, e));\n\t}\n\tpriority_queue<P, vector<P>, greater<P>>Q;\n\tfor (int h = 0; h < c; h++) {\n\t\tint i; scanf(\"%d\", &i); i--;\n\t\tmincost[i] = 0;\n\t\tQ.push(P(0,i));\n\t}\n\twhile (Q.size()) {\n\t\tP o = Q.top(); Q.pop();\n\t\tif (mincost[o.second] < o.first)continue;\n\t\tfor (P t : rinsetu[o.second]) {\n\t\t\tif (o.first + t.first < mincost[t.second]) {\n\t\t\t\tmincost[t.second] = o.first + t.first;\n\t\t\t\tQ.push(P(mincost[t.second],t.second));\n\t\t\t}\n\t\t}\n\t}\n\tint MAX = 0;\n\tfor (int x = 0; x < a; x++) {\n\t\tfor (P y : rinsetu[x]) {\n\t\t\ty.first -= abs(mincost[x] - mincost[y.second]);\n\t\t\tMAX = max(MAX, max(mincost[x], mincost[y.second]) + kiriage(y.first));\n\t\t}\n\t}\n\tcout << MAX << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nint N, M, K;\n\nstruct edge\n{\n  int to, cost;\n  edge(int t, int c)\n  {\n    to = t; cost = c;\n  }\n};\n\ntypedef pair<int, int> P;\nvector<edge> edges[10000];\nint d[3000];\n\nint dijkstra(vector<int> sts)\n{\n  priority_queue<P, vector<P>, greater<P> > queue;\n  for(auto st : sts)\n  {\n    d[st] = 0;\n    queue.push(make_pair(0, st));\n  }\n  while(!queue.empty())\n  {\n    auto p = queue.top(); queue.pop();\n    int v = p.second;\n    if(d[v] < p.first)\n      continue;\n    for(auto e : edges[v])\n    {\n      if(d[e.to] > d[v] + e.cost)\n      {\n        d[e.to] = d[v] + e.cost;\n        queue.push(make_pair(d[e.to], e.to));\n      }\n    }\n  }\n}\n\nint main()\n{\n  fill(d, d + 3000, 1000000000);\n  scanf(\"%d%d%d\", &N, &M, &K);\n  for(int i = 0; i < M; i++)\n  {\n    int a, b, l;\n    scanf(\"%d%d%d\", &a, &b, &l);\n    a--; b--;\n    edges[a].push_back(edge(b, l));\n    edges[b].push_back(edge(a, l));\n  }\n\n  vector<int> sts;\n  for(int i = 0; i < K; i++)\n  {\n    int a;\n    scanf(\"%d\", &a);\n    sts.push_back(--a);\n  }\n  dijkstra(sts);\n  int ans = 0;\n  for(int v = 0; v < N; v++)\n    for(auto e : edges[v])\n      ans = max(ans, (int)((d[v] + d[e.to] + e.cost) / 2.0 + 0.5));\n  printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<functional>\n#include<queue>\nusing namespace std;\n\nstruct edge{int to,cost;};\ntypedef pair<int,int> P;\nconst int INF=1000000;\n\nvector<edge> G[3001];\nint d[3001];\nint n,m,k;\n\nvoid dijk(vector<int>sv){\n\tpriority_queue<P ,vector<P>,greater<P> > que;\n\tfill(d,d+3001,INF);\n\tfor(int i=0;i<sv.size();i++){\n      d[sv[i]]=0;\n      que.push(P(0,sv[i]));\n\t}\n\twhile(!que.empty()){\n\t\tP p=que.top();que.pop();\n\t\tint v=p.second;\n\t\tif(d[v]<p.first)continue;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tedge e=G[v][i];\n\t\t\tif(d[e.to]>d[v]+e.cost){\n\t\t\t\td[e.to]=d[v]+e.cost;\n\t\t\t\tque.push(P(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c;\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\tedge e;\n\t\te.to=b,e.cost=c;\n\t\tG[a].push_back(e);\n\t\te.to=a;\n\t\tG[b].push_back(e);\n\t}\n\tvector<int> sv;\n\tfor(int i=0;i<k;i++){\n\t\tint a;\n\t\tscanf(\"%d\",&a);\n\t\tsv.push_back(a);\n\t}\n\tdijk(sv);\n\n\tint maxi=0;\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tfor(int k=0;k<G[i].size();k++){\n\t\t\t\tint cost=0;\n\t\t\t\tedge e=G[i][k];\n\t\t\t\tif(e.to==j)cost=((d[i]+d[j]+e.cost+1)/2);\n\t\t\t\tmaxi=max(maxi,cost);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",maxi);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector<vector<int>> cost;\nvector<int> d;\nvector<bool> visited;\nint n;\n\nvoid dijkstra(int count) {\n    for (int i = 0; i < count; i++) {\n        int s;\n        cin >> s;\n        d[s - 1] = 0;\n    }\n    while (true) {\n        int next = -1;\n        for (int u = 0; u < n; u++) {\n            if (!visited[u] && (next == -1 || d[u] < d[next]))next = u;\n        }\n\n        if (next == -1)break;\n        visited[next] = true;\n\n        for (int u = 0; u < n; u++) d[u] = min(d[u], d[next] + cost[next][u]);\n    }\n}\n\nint main() {\n    int m, k;\n    cin >> n >> m >> k;\n    cost = vector<vector<int>>(n, vector<int>(n));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == j)continue;\n            cost[i][j] = 1145141919;\n        }\n    }\n    for (int i = 0; i < m; i++) {\n        int a, b, l;\n        cin >> a >> b >> l;\n        a--;\n        b--;\n        cost[a][b] = l;\n        cost[b][a] = l;\n    }\n    d = vector<int>(n);\n    visited = vector<bool>(n);\n    for (int i = 0; i < n; i++) {\n        d[i] = 1145141919;\n        visited[i] = false;\n    }\n    dijkstra(k);\n    int ma = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (cost[i][j] < 1145141919) ma = max(ma, (d[i] + d[j] + cost[i][j] + 1) / 2);\n        }\n    }\n    cout << ma << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<vector>\n#include<queue>\n#include<functional>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint N,M,K;\t\t//町数、道の数、店舗数\nstruct NODE{\n\tvector<int> cost,list;\n\tint minest;\t//頂点から店への最短距離\n}MISE[3000];\n\nvoid Ini(int *a,int index,int num){\n\tfor(int i = 0;i < index;i++){\n\t\ta[i] = num;\n\t}\n}\nvoid Dijkstra(int left){\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tint done[3000],確定数 = 0;\n\tint nowcost[3000];\n\tP edge;\n\tIni(done,N,-1);\n\tIni(nowcost,N,500000000);\n\tque.push(P(0,left));\n\twhile(確定数 < N && !que.empty()){\n\t\tedge = que.top();\n\t\tque.pop();\n\t\tif(done[edge.second] >= 0)\n\t\t\tcontinue;\n\t\t確定数++;\n\t\tdone[edge.second] = edge.first;\n\t\t//確定した頂点から枝を出す\n\t\tint lsize;\n\t\tlsize = MISE[edge.second].list.size();\n\t\tfor(int i = 0;i < lsize;i++){\n\t\t\tif(done[MISE[edge.second].list[i]] == -1 && nowcost[MISE[edge.second].list[i]] > edge.first+MISE[edge.second].cost[i]){\n\t\t\t\tnowcost[MISE[edge.second].list[i]] = edge.first+MISE[edge.second].cost[i];\n\t\t\t\tque.push(P(nowcost[MISE[edge.second].list[i]],MISE[edge.second].list[i]));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int  i = 0;i < N;i++){\n\t\tif(MISE[i].minest > done[i] && done[i] != -1)\n\t\t\tMISE[i].minest = done[i];\n\t}\n}\nint main(){\n\tint i,a,b,c;\n\tint モール場所;\n\tcin >> N >> M >> K;\n\tfor(i = 0;i < N;i++){\n\t\tMISE[i].minest = 500000000;\n\t}\n\tfor(i = 0;i < M;i++){\n\t\tcin >> a >> b >> c;\n\t\ta--;b--;\n\t\t//隣接リスト作成。道の生成による影響は2ノード間にのみ作用する。\n\t\tMISE[a].list.push_back(b);\n\t\tMISE[a].cost.push_back(c);\n\t\tMISE[b].list.push_back(a);\n\t\tMISE[b].cost.push_back(c);\n\t}\n\tfor(i = 0;i < K;i++){\n\t\tcin >> モール場所;\n\t\tモール場所--;\n\t\tDijkstra(モール場所);\n\t}\n\tdouble D_length;\n\tint I_length,I_Mlength = 0;\n\tfor(i = 0;i < N;i++){\n\t\t//枝の間が一番距離が長くなりそう\n\t\tint lsize;\n\t\tlsize = MISE[i].list.size();\n\t\tfor(int j = 0;j < lsize;j++){\n\t\t\tD_length = (double)MISE[i].cost[j]/2.0;\n\t\t\tD_length += min(MISE[i].minest,MISE[MISE[i].list[j]].minest);\n\t\t\tif(D_length - (int)D_length == 0)\n\t\t\t\tI_length = (int)D_length;\n\t\t\telse\n\t\t\t\tI_length = (int)D_length+1;\n\t\t\tif(I_Mlength < I_length)\n\t\t\t\tI_Mlength = I_length;\n\t\t}\n\t\tcout << MISE[i].minest << \" \";\n\t}\n\tcout << endl << I_Mlength << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int INF=1e9;\nint N,M,K;\nvector<P>G[3000];\nint dist[3000];\nint main(){\n    cin>>N>>M>>K;\n\n    for(int i=0;i<M;i++){\n        int a,b,c;cin>>a>>b>>c;\n        G[--a].push_back(P(--b,c));\n        G[b].push_back(P(a,c));\n    }\n    fill_n(dist,N,INF);\n    priority_queue<P,vector<P>,greater<P> >Q;\n    for(int i=0;i<K;i++){\n        int x;cin>>x;\n        Q.push(P(0,--x));\n        dist[x]=0;\n    }\n\n    while(!Q.empty()){\n        P p=Q.top();Q.pop();\n\n        if(dist[p.second]<p.first)continue;\n\n        for(int i=0;i<G[p.second].size();i++){\n            P &e=G[p.second][i];\n            if(p.first+e.second>=dist[e.first])continue;\n            dist[e.first]=p.first+e.second;\n            Q.push(P(p.first+e.second,e.first));\n        }\n    }\n\n    int ma=0;\n    for(int i=0;i<N;i++){\n        for(int j=0;j<G[i].size();j++){\n            P &e=G[i][j];\n            int d=abs(dist[i]-dist[e.first]);\n            ma=max(ma,max(dist[i],dist[e.first])+(e.second-d+1)/2);\n        }\n    }\n\n    cout<<ma<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nconst int INF=1e9;\nstruct data{\n    int to,cost;\n    data(int a,int b):to(a),cost(b){}\n    bool operator>(const data &d)const{\n        return cost>d.cost;\n    }\n};\nvector<vector<data> >edge;\nvector<int>D;\nvoid dijkstra(int s){\n    priority_queue<data,vector<data>,greater<data> >Q;\n    Q.push(data(s,0));\n    while(Q.size()){\n        data latte=Q.top();Q.pop();\n        int At=latte.to,cost=latte.cost;\n        if(D[At]<cost)continue;\n        D[At]=cost;\n        for(int i=0;i<edge[At].size();i++){\n            data e=edge[At][i];\n            if(D[e.to]<D[At]+e.cost)continue;\n            Q.push(data(e.to,D[At]+e.cost));\n        }\n    }\n    return;\n}\nint main(){\n    int n,m,k;\n    cin>>n>>m>>k;\n    edge.resize(n);\n    D.resize(n,INF);\n    for(int i=0;i<m;i++){\n        int a,b,c;\n        cin>>a>>b>>c;\n        a--;b--;\n        edge[a].push_back(data(b,c));\n        edge[b].push_back(data(a,c));\n    }\n    for(int i=0;i<k;i++){\n        int s;\n        cin>>s;\n        s--;\n        dijkstra(s);\n    }\n    int Max=0;\n\n    for(int i=0;i<n;i++){\n        for(int j=0;j<edge[i].size();j++){\n            data e=edge[i][j];\n            int latte=(D[i]+D[e.to]+e.cost+1)/2;\n            Max=max(max(D[i],D[e.to]),max(Max,latte));\n\n        }\n    }\n    cout<<Max<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={1,0,-1,0,1,-1,-1,1};\nconst int dy[]={0,1,0,-1,1,1,-1,-1};\nconst int INF = 1<<30;\nconst int EPS = 1e-8;\n#define PB push_back\n#define mk make_pair\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int > Pii;\nclass edge{\n\tpublic:\n\tint to;\n\tint cost;\n\tedge(){}\n\tedge(int _to,int _cost){\n\t\tto = _to;\n\t\tcost = _cost;\n\t}\n\tbool operator<(const edge &a)const{\n\t\treturn cost>=a.cost;\n\t}\n};\nvector < edge > G[3002];\nint path[3002];\nint N,M,K;\nvoid dijkstra(int s){\n\tint d[3002];\n\tfill(d,d+N,INF);\n\tpriority_queue<edge> Q;\n\tQ.push(edge(s,0));\n\twhile(!Q.empty()){\n\t\tedge e = Q.top();\n\t\tQ.pop();\n\t\tif(d[e.to] < INF)continue;\n\t\td[e.to] = e.cost;\n\t\trep(i,G[e.to].size()){\n\t\t\tQ.push(edge(G[e.to][i].to,G[e.to][i].cost+e.cost));\n\t\t}\n\t}\n\trep(i,N){\n\t\tpath[i] = min(path[i],d[i]);\n\t}\n\treturn ;\n}\nint main(){\n\tscanf(\"%d%d%d\",&N,&M,&K);\n\tfill(path,path+N,INF);\n\trep(i,M){\n\t\tint a,b,c;\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\ta--;b--;\n\t\tG[a].PB(edge(b,c));\n\t\tG[b].PB(edge(a,c));\n\t}\n\trep(i,K){\n\t\tint tmp;\n\t\tscanf(\"%d\",&tmp);\n\t\tdijkstra(--tmp);\n\t}\n\tdouble ans = 0;\n\trep(i,N){\n\t\trep(j,G[i].size()){\n\t\t\tint d = path[G[i][j].to]-path[i];\n\t\t\tif(d<0.0)continue;\n\t\t\tdouble g = path[i]+d+(G[i][j].cost-d)/2.0;\n\t\t\tans = max(g,ans);\n\t\t}\n\t}\n\t/*\n\trep(i,N){\n\t\tprintf(\"[%d]:%d\\n\",i,path[i]);\n\t}\n\t*/\n\tprintf(\"%.0lf\\n\",round(ans));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nstruct edge { int to, cost; edge(int to, int cost) : to(to), cost(cost) {} };\ntypedef vector<edge> edges;\n\nedges G[3010];\nint d[100010];\n\nvoid dijkstra(int s)\n{\n    priority_queue<pii, vpii, greater<pii> > pq;\n    d[s] = 0;\n    pq.push(pii(0, s));\n    \n    while (pq.size()) {\n        pii p = pq.top(); pq.pop();\n\n        int v = p.scd;\n\n        if (d[v] < p.fst) continue;\n\n        for (edge &e : G[v]) {\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                pq.push(pii(d[e.to], e.to));\n            }\n        }\n    }\n}\n\nsigned main()\n{\n    int N, M, K; cin >> N >> M >> K;\n\n    fill_n(d, N + 1, inf);\n\n    rep(i, M) {\n        int a, b, l; cin >> a >> b >> l;\n        a--, b--;\n\n        G[a].PB(edge(b, l));\n        G[b].PB(edge(a, l));\n    }\n\n    rep(i, K) {\n        int s; cin >> s;\n        s--;\n        dijkstra(s);\n    }\n\n    int ma = -1;\n\n    rep(i, N) {\n        for (edge &e : G[i]) {\n            ma = max(ma, d[i]);\n            if (d[i] <= d[e.to]) {\n                ma = max(ma, (int)(d[i] + round(1. * (d[e.to] - d[i] + e.cost) / 2)));\n            }\n        }\n    }\n\n    cout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nll N,M,K;\n\nvector<P> G[3003];\nll dist[3003];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> N >> M >> K;\n\n    for (int i = 0;i < M;i++){\n        ll a,b,l; cin >> a >> b >> l;\n        G[a].push_back(P(b,l));\n        G[b].push_back(P(a,l));\n    }\n\n    priority_queue<P,vector<P>,greater<P>> que;\n    fill(dist,dist+N+1,LLONG_MAX);\n\n    for (int i = 0;i < K;i++){\n        ll a; cin >> a;\n        dist[a] = 0;\n        que.push(P(0,a));\n    }\n\n    while(que.size()){\n        P p = que.top(); que.pop();\n        ll from = p.second;\n        ll sum = p.first;\n        if(dist[from] > sum) continue;\n        for (int i = 0;i < G[from].size();i++){\n            ll to = G[from][i].first;\n            ll cost = G[from][i].second;\n            if(sum+cost < dist[to]){\n                dist[to] = sum+cost;\n                que.push(P(dist[to],to));\n            }\n        }\n    }\n\n    ll ans = 0;\n\n    for (int i = 1;i <= N;i++){\n        for (int j = 0;j < G[i].size();j++){\n            ll a = i; ll b = G[i][j].first;\n            ll cost = G[i][j].second;\n            if(dist[b]+cost <= dist[a]) ans = max(ans,dist[a]);\n            else if(dist[a]+cost <= dist[b]) ans = max(ans,dist[b]);\n            else{\n                cost -= abs(dist[a]-dist[b]);\n                if(cost%2 == 0) ans = max(max(dist[a],dist[b])+cost/2,ans);\n                else ans = max(max(dist[a],dist[b])+cost/2 +1,ans);\n            }\n        }\n    }\n    \n    cout << ans << endl;\n\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma warning(disable: 4996)\n#include<cstdio>\n#include<math.h>\n#include<algorithm>\n#include<string.h>\n#include<vector>\n#include<queue>\n\n\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nconst int INF=1001001001;\n\nconst int mod=100000;\n\nstruct road{\n\tint start;\n\tint end;\n\tint length;\n};\n\nvector<road> einfo;\nvector< pair<int,int> > edge[3003];//a?????????b????????????????????????l???->???edge[a]=(b,l)\nint dist[3000];\n\nint main(){\n\tint N,M,K;\n\tmemset(dist,INF,sizeof(dist));\n\tscanf(\"%d %d %d\",&N,&M,&K);\n\trep(i,M){\n\t\tint a,b,l;\n\t\tscanf(\"%d %d %d\",&a,&b,&l);\n\t\tedge[a-1].push_back( make_pair(b-1,l) );\n\t\tedge[b-1].push_back( make_pair(a-1,l) );\n\t\troad k;k.start=a-1;k.end=b-1;k.length=l;\n\t\teinfo.push_back( k);\n\t}\n\tpriority_queue< vector<pair<int,int> >, vector< pair<int,int> > , greater< pair<int,int> > > q;\n\trep(i,K){\n\t\tint s;\n\t\tscanf(\"%d\",&s);\n\t\tq.push( make_pair(0,s-1) );\n\t}\n\twhile(!q.empty()){\n\t\tpair<int,int> n=q.top();q.pop();\n\t\tif(dist[n.second]<=n.first)break;\n\t\tdist[n.second]=n.first;\n\t\trep(i,edge[n.second].size()){\n\t\t\tq.push(make_pair(n.first+edge[n.second][i].second, edge[n.second][i].first) );\n\t\t}\n\t}\n\tdouble ans=0;\n\trep(i,einfo.size()){\n\t\troad r=einfo[i];\n\t\tans=max( ans, (double)(dist[r.start]+dist[r.end]+r.length)/2.0);\n\t}\n\n\tprintf( \"%d\\n\", (int)(ans)+(bool)((int)(ans)<=(double)(ans)-0.5));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nstruct Road {\n    int from, to;\n    int len;\n\n    Road() {}\n    Road(int f, int t, int l) : from(f), to(t), len(l) {}\n};\n\nvector<Road> roads_of[3000];\nbool is_shopping_mall[3000];\nint min_dist[3000];\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    int N, M, K;\n    cin >> N >> M >> K;\n    for(int i = 0; i < M; ++i) {\n        int a, b, l;\n        cin >> a >> b >> l;\n        --a; --b;\n        roads_of[a].push_back(Road(a, b, l));\n        roads_of[b].push_back(Road(b, a, l));\n    }\n    fill_n(is_shopping_mall, N, false);\n    for(int i = 0; i < K; ++i) {\n        int a;\n        cin >> a;\n        --a;\n        is_shopping_mall[a] = true;\n    }\n    fill_n(min_dist, N, INT_MAX);\n\n    static int memo[3000];\n    for(int start = 0; start < N; ++start) {\n        if(!is_shopping_mall[start]) continue;\n        fill_n(memo, N, INT_MAX);\n        priority_queue<pair<int, int> > q;\n        q.push(make_pair(0, start));\n        memo[start] = 0;\n        while(!q.empty()) {\n            int cost = -q.top().first;\n            int pos = q.top().second;\n            q.pop();\n            if(memo[pos] < cost) continue;\n            min_dist[pos] = min(min_dist[pos], cost);\n\n            for(vector<Road>::iterator it = roads_of[pos].begin(); it != roads_of[pos].end(); ++it) {\n                if(is_shopping_mall[it->to]) continue;\n\n                int nc = cost + it->len;\n                if(memo[it->to] > nc) {\n                    memo[it->to] = nc;\n                    q.push(make_pair(-nc, it->to));\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n    for(int i = 0; i < N; ++i) {\n        int d = 0;\n        const int a = min_dist[i];\n        // a+ul == b+vl, u+v == 1\n        // a+ul == b+(1-u)l\n        // 2ul == b-a+l\n        // u == (b-a+l)/2l\n        // ul == (b-a+l)/2\n        for(vector<Road>::iterator it = roads_of[i].begin(); it != roads_of[i].end(); ++it) {\n            const int b = min_dist[it->to];\n            if(b >= a) {\n                int ul = (b-a+it->len) / 2;\n                if((b-a+it->len) % 2 == 1) ++ul;\n                d = max(d, min_dist[i] + ul);\n            }\n        }\n        ans = max(ans, d);\n    }\n\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define MAX_N 3001\n#define UNDEF -1\n#define MAX_INT 2147483647\n\ntypedef struct\n{\n\tunsigned short int node1;\n\tunsigned short int node2;\n\tunsigned short int length;\n\tunsigned int distance;\n} Road;\n\ntypedef struct\n{\n\tunsigned int distance;\n\tbool decided;\n} Node;\n\nint N,M,K;\nvector<Road> I;\nvector<Node> J;\nRoad Rtemp;\nNode Ntemp;\n\nRoad* MAKEROAD(const unsigned short int node1,const unsigned short int node2,const unsigned short int length,const unsigned int distance)\n{\n\tRtemp.node1 = node1;\n\tRtemp.node2 = node2;\n\tRtemp.length = length;\n\tRtemp.distance = distance;\n\treturn &Rtemp;\n}\n\nNode* MAKENODE(const unsigned int distance,const bool decided)\n{\n\tNtemp.distance = distance;\n\tNtemp.decided = decided;\n\treturn &Ntemp;\n}\n\nint main(void)\n{\n\tcin >> N >> M >> K;\n\tint _a,_b,_i;\n\tfor(int i = 0;i < M;i++)\n\t{\n\t\tcin >> _a >> _b >> _i;\n\t\tI.push_back(*MAKEROAD(_a,_b,_i,MAX_INT));\n\t}\n\tfor(int i = 0;i < K;i++)\n\t{\n\t\tcin >> _a;\n\t\tI.push_back(*MAKEROAD(0,_a,0,MAX_INT));\n\t}\n\tfor(int i = 0;i < N+1;i++)\n\t{\n\t\tJ.push_back(*MAKENODE(MAX_INT,false));\n\t}\n\tJ.begin()->distance = 0;\n\tint mindist = 0;\n\tauto mindist_itr = J.begin();\n\tint mindist_i = 0;\n\tbool chg = false;\n\twhile(true)\n\t{\n\t\tmindist = MAX_INT;\n\t\tchg = false;\n\t\tfor(auto itr = J.begin();itr < J.end();itr++)\n\t\t{\n\t\t\tif(!(itr->decided) && itr->distance < mindist)\n\t\t\t{\n\t\t\t\tmindist_itr = itr;\n\t\t\t\tmindist = itr->distance;\n\t\t\t\tchg = true;\n\t\t\t}\n\t\t}\n\t\tif(!chg)\n\t\t\tbreak;\n\t\telse\n\t\t{\n\t\t\tmindist_itr->decided = true;\n\t\t\tmindist_i = mindist_itr - J.begin();\n\t\t\tfor(auto itr = I.begin();itr < I.end();itr++)\n\t\t\t{\n\t\t\t\tif(itr->node1 == mindist_i)\n\t\t\t\t{\n\t\t\t\t\tif(J[itr->node2].distance > J[mindist_i].distance + itr->length)\n\t\t\t\t\t{\n\t\t\t\t\t\tJ[itr->node2].distance = J[mindist_i].distance + itr->length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(itr->node2 == mindist_i)\n\t\t\t\t{\n\t\t\t\t\tif(J[itr->node1].distance > J[mindist_i].distance + itr->length)\n\t\t\t\t\t{\n\t\t\t\t\t\tJ[itr->node1].distance = J[mindist_i].distance + itr->length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(auto itr = I.begin();itr < I.end();itr++)\n\t{\n\t\t_a = J[itr->node1].distance + J[itr->node2].distance + itr->length;\n\t\tif(_a % 2 == 1)\n\t\t\t_a++;\n\t\titr->distance = _a / 2;\n\t}\n\tunsigned int result = 0;\n\tfor(auto itr = I.begin();itr < I.end();itr++)\n\t{\n\t\tresult = max(result,itr->distance);\n\t}\n\tfor(auto itr = J.begin();itr < J.end();itr++)\n\t{\n\t\tresult = max(result,itr->distance);\n\t}\n\tcout << result << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define M 100000007\ntypedef pair<int,int> P;\n/*int main(){\n\tcout<<8979879<<endl;\n}*/\nint ri[3001][3001];\nint main(void){\n\tint n,m,k,\n\t\ti,j,\n\t\tmx,t,ans,\n\t\ta[100001],b[100001],l[100001],s[3000],\n\t\td[3001];\n\t\t\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\n\tcin>>n>>m>>k;\n\tfor(i=0;i<m;i++) cin>>a[i]>>b[i]>>l[i];\n\tfor(i=0;i<k;i++) cin>>s[i];\n//\tfor(i=0;i<k;i++) cout<<s[i]<<endl;\n\t\n\tfor(i=1;i<=n;i++) for(j=1;j<=n;j++) ri[i][j]=M;\n\tfor(i=0;i<m;i++) ri[a[i]][b[i]]=l[i],ri[b[i]][a[i]]=l[i];\n/*\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++)cout<<ri[i][j]<<' ';\n\t\tcout<<endl;\n\t}*/\n\t\n\tint leng[3001];\n\tfor(i=1;i<=n;i++) leng[i]=M;\n\tfor(i=0;i<k;i++){\n\t\tleng[s[i]]=0;\n\t\tque.push(P(0,s[i]));\n\t}\n\twhile(!que.empty()){\n\t\tP p=que.top();\n\t\tque.pop();\n\t\tint v=p.second;\n\t\tif(leng[v]<p.first) continue;\n\t\tfor(j=1;j<=n;j++){\n\t\t\tt=leng[v]+ri[v][j];\n//\t\t\tcout<<j<<' '<<leng[j]<<' '<<t<<endl;\n\t\t\tif(leng[j]>t){\n\t\t\t\tleng[j]=t;\n//\t\t\t\tcout<<leng[j]<<' '<<j<<endl;\n\t\t\t\tque.push(P(leng[j],j));\n\t\t\t}\n\t\t}\n\t}\n/*\tfor(i=1;i<=n;i++) cout<<leng[i]<<' ';\n\tcout<<endl;*/\n\tans=0;\n\tfor(i=1;i<=n;i++){\n\t\tint mx=0,y;\n\t\tdouble x;\n\t\tfor(j=1;j<=n;j++){\n\t\t\tif(ri[i][j]!=M){\n\t\t\t\tif(leng[i]!=0){\n\t\t\t\t\tmx=max(mx,ri[i][j]+leng[j]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tmx=max(mx,ri[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tx=(double)mx/2;\n//\t\tcout<<x<<' '<<mx<<' '<<mi<<endl;\n\t\ty=round(x);\n\t\tans=max(ans,y);\n\t}\n\t\n\tcout<<ans<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 100000000\ntypedef long long LL;\ntypedef pair<int,int>P;\nstruct edge{int to,cost;};\n \nvector<edge>G[3390];\nint dis[3390];\n \nvoid dijkstra(int s){\n    priority_queue<P,vector<P>,greater<P> >Q;\n    fill(dis,dis+3389,INF);\n    dis[s]=0;\n    Q.push(P(0,s));\n     \n    while(Q.size()){\n        P p=Q.top();\n        Q.pop();\n        int v=p.second;\n        if(dis[v]<p.first)continue;\n         \n        for(int i=0;i<G[v].size();i++){\n            edge e=G[v][i];\n            if(dis[e.to]>dis[v]+e.cost){\n                dis[e.to]=dis[v]+e.cost;\n                Q.push(P(dis[e.to],e.to));\n                }\n            }\n        }\n    }\n \nint main(){\n    int n,m,k;\n    cin>>n>>m>>k;\n     \n    for(int i=0;i<m;i++){\n        int a,b,c;\n        cin>>a>>b>>c;\n        G[a-1].push_back({b-1,c});\n        G[b-1].push_back({a-1,c});\n        }\n         \n    for(int i=0;i<k;i++){\n        int a;\n        cin>>a;\n        G[3235].push_back({a-1,0});\n        }   \n         \n    dijkstra(3235);\n     \n    int ans=0;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<G[i].size();j++){\n            ans=max(ans,max(dis[i],dis[G[i][j].to]));\n            int ct=0;\n            ct=G[i][j].cost;\n             \n                ct+=dis[i];\n                ct+=dis[G[i][j].to];\n                ct++;\n                ct/=2;\n                ans=max(ans,ct);\n            }\n        }   \n        cout<<ans<<endl;\n        return 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cassert>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nclass st{\npublic:\n  int now,cost;\n  bool operator<(const st a)const{\n    return cost > a.cost;\n  }\n};\n\nstruct Edge{int f,t,c;};\n\nconst int N = 3000;\nconst int inf = (1<<25);\nint cost[N];\nvector<Edge> edge[N];\nvoid dijkstra(int n,vector<int> s){\n  priority_queue<st> Q;\n  rep(i,n)cost[i] = inf;\n  rep(i,s.size()){\n    cost[s[i]] = 0;\n    Q.push((st){s[i],0});\n  }\n  while(!Q.empty()){\n    st now = Q.top();Q.pop();\n    if (cost[now.now] != now.cost)continue;\n    rep(i,edge[now.now].size()){\n      int next = edge[now.now][i].t;\n      int nec = now.cost + edge[now.now][i].c;\n      if (cost[next] > nec){\n\tcost[next] = nec;\n\tQ.push((st){next,nec});\n      }\n    }\n  }\n}\n\nint solve(int n,vector<int> &s){\n  dijkstra(n,s);\n  double ans = 0;\n  rep(i,n)ans = max(ans,(double)cost[i]);\n  rep(i,n){\n    rep(j,edge[i].size()){\n      int f = edge[i][j].f,t=edge[i][j].t,l=edge[i][j].c;\n      int a = max(cost[f],cost[t]),b=min(cost[f],cost[t]);\n      double tmp = ((a-b)+l)/2.;\n      //cout << f <<\" \" <<t <<\" \" << tmp << endl;\n      ans = max(ans,min(cost[f]+tmp,cost[t]+tmp));\n    }\n  }\n  //cout << ans << endl;\n  printf(\"%.0lf\\n\",ans);\n}\n\nmain(){\n  int n,m,q;\n  while(cin>>n>>m>>q){\n    vector<int> s(q);\n    rep(i,n)edge[i].clear();\n    rep(i,m){\n      int f,t,c;\n      cin>>f>>t>>c;\n      f--;t--;\n      edge[f].push_back((Edge){f,t,c});\n      edge[t].push_back((Edge){t,f,c});\n    }\n    rep(i,q)cin>>s[i],s[i]--;\n    solve(n,s);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 29;\n\ntypedef pair<int, int> P;\n\nstruct EDGE {\n\tint to, cost;\n};\n\nint n, m, k;\nvector<EDGE> g[3000];\nvector<int> st;\nint d[3000];\nint d_mid[3000][3000];\n\nvoid add_edge(int a, int b, int l)\n{\n\tg[a].push_back((EDGE){b, l * 2});\n\tg[b].push_back((EDGE){a, l * 2});\n}\n\nvoid search()\n{\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\n\tfor (int i = 0; i < n; i++) d[i] = INF;\n\tfor (int i = 0; i < st.size(); i++){\n\t\tque.push(P(0, st[i]));\n\t}\n\t\n\tfor (; que.size(); que.pop()){\n\t\tP p = que.top();\n\t\tif (d[p.second] != INF) continue;\n\t\td[p.second] = p.first;\n\t\tfor (int i = 0; i < g[p.second].size(); i++){\n\t\t\tEDGE &e = g[p.second][i];\n\t\t\tif (d[e.to] != INF) continue;\n\t\t\tque.push(P(p.first + e.cost, e.to));\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tfor (int i = 0; i < m; i++){\n\t\tint a, b, l;\n\t\tscanf(\"%d %d %d\", &a, &b, &l);\n\t\tadd_edge(--a, --b, l);\n\t}\n\t\n\tfor (int i = 0; i < k; i++){\n\t\tint s;\n\t\tscanf(\"%d\", &s);\n\t\tst.push_back(--s);\n\t}\n\t\n\tsearch();\n\tfor (int v = 0; v < n; v++){\n\t\tfor (int i = 0; i < g[v].size(); i++){\n\t\t\tEDGE &e = g[v][i];\n\t\t\td_mid[v][e.to] = (d[v] + d[e.to] + e.cost) / 2;\n\t\t}\n\t}\n\t\n\tint res = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tres = max(res, d[i]);\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tres = max(res, d_mid[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", (res + 1) / 2);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\nll inf =  1e9;\n\n\n\nint main(){\n ll n,m,k;\n cin>>n>>m>>k;\n vector< vector<mp> > g(n);\n vector<mp> edge(m);\n vector<ll> leng(m);\n for(ll i=0;i<m;i++){\n  ll u,v,c;\n  cin>>u>>v>>c;\n  u--,v--;\n  edge[i] = mp(u,v);\n  leng[i] = c;\n  g[u].push_back( mp(c,v) );\n  g[v].push_back( mp(c,u) );\n }\n \n vector<ll> res(n,inf);\n priority_queue<mp,vector<mp>,greater<mp> > q;\n\n for(ll i=0;i<k;i++){\n  ll s;\n  cin>>s;\n  s--;\n  q.push(mp(0,s) );\n }\n\n\n while( !q.empty() ){\n  mp now = q.top();\n  q.pop();\n  ll nn = now.second;\n  ll cost = now.first;\n  if( res[nn] != inf ) continue;\n  res[nn] = cost;\n  for(ll i=0;i<g[nn].size();i++){\n   ll next = g[nn][i].second;\n   ll nec = cost + g[nn][i].first;\n   if( res[next] != inf ) continue;\n   q.push( mp( nec , next ) );\n  }\n }\n\n ll ans = 0;\n for(auto i:res)  ans = max( ans , i );\n for(ll i=0;i<m;i++){\n  ans = max( ans , ( res[edge[i].first] + res[edge[i].second] + 1  + leng[i] )/2 );\n }\n cout<<ans<<endl;\n\n\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\nint n;\nint m;\nint k;\ncin >>n;\ncin >>m;\ncin >>k;\nint a[m];\nint b[m];\nint l[m];\nint c;\nc=0;\nwhile(c<m){\ncin >>a[c];\ncin >>b[c];\ncin >>l[c];\nc=c+1;}\nint d[n];//確定\nint f[n];//暫定\nint e;\nc=0;\nwhile(c<n){\nd[c]=-1;\nf[c]=-1;\nc=c+1;}\nc=0;\nwhile(c<k){\ncin >>e;\nd[e-1]=0;\nf[e-1]=0;\nc=c+1;}\nint g;\nint h;\nc=k;\nwhile(c<n){\ne=0;\nwhile(e<m){\nif(d[a[e]-1]!=-1&&d[b[e]-1]==-1){\nif(d[a[e]-1]+l[e]<f[b[e]-1]){f[b[e]-1]=d[a[e]-1]+l[e];}\nif(f[b[e]-1]==-1){f[b[e]-1]=d[a[e]-1]+l[e];}}\nif(d[b[e]-1]!=-1&&d[a[e]-1]==-1){\nif(d[b[e]-1]+l[e]<f[a[e]-1]){f[a[e]-1]=d[b[e]-1]+l[e];}\nif(f[a[e]-1]==-1){f[a[e]-1]=d[b[e]-1]+l[e];}}\ne=e+1;}\ng=-1;\ne=0;\nwhile(e<n){\nif(d[e]==-1&&g>f[e]){g=f[e]; h=e;}\nelse if(d[e]==-1&&g==-1){g=f[e]; h=e;}\ne=e+1;}\nd[h]=f[h];\nc=c+1;}\ng=0;\nc=0;\nwhile(c<m){\nif(d[a[c]-1]-d[b[c]-1]==l[c]&&g<d[a[c]-1]){g=d[a[c]-1];}\nelse if(d[b[c]-1]-d[a[c]-1]==l[c]&&g<d[b[c]-1]){g=d[b[c]-1];}\nelse if((d[b[c]-1]+d[a[c]-1]+l[c])%2==0&&g<(d[b[c]-1]+d[a[c]-1]+l[c])/2){g=(d[b[c]-1]+d[a[c]-1]+l[c])/2;}\nelse if((d[b[c]-1]+d[a[c]-1]+l[c])%2==1&&g<(d[b[c]-1]+d[a[c]-1]+l[c])/2+1){g=(d[b[c]-1]+d[a[c]-1]+l[c])/2+1;}\nc=c+1;}\ncout <<g<<endl;}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<utility>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#define INF 10000000\nusing namespace std;\nvoid solve();\ntypedef pair<int,int> pii;\ntypedef pair<int,pii > pipii;\n\nint N,M,K,ANS = 0;\nint G[3010][3010] = {0};\nint D[3010];\npriority_queue<pipii,vector<pipii>,greater<pipii> > que;\n\nint main()\n{\n    scanf(\"%d%d%d\",&N,&M,&K);\n    for(int i = 1 ; i < N + 1; i++)D[i] = INF;\n    for(int i = 0; i < M; i++)\n    {\n        int a,b,l;\n        scanf(\"%d%d%d\",&a,&b,&l);\n        G[a][b] = G[b][a] = l;\n    }\n    for(int i = 0 ; i < K; i++)\n    {\n        int a;\n        scanf(\"%d\",&a);\n        for(int j = 1; j < N + 1; j++)\n        {\n            if(G[a][j] != 0)\n            {\n                D[a] = 0;\n                pipii test;\n                test.first = G[a][j];test.second.first = a;test.second.second = j;\n                que.push(test);\n            }\n        }\n    }\n    solve();\n    printf(\"%d\\n\",ANS);\n    return 0;\n}\nvoid solve()\n{\n    while(que.size())\n    {\n        pipii now = que.top();\n        que.pop();\n        if(D[now.second.second] == INF)\n        {\n            D[now.second.second] = now.first;\n            ANS = max(ANS,now.first);\n            for(int i = 1; i < N + 1; i++)\n            {\n                if(G[now.second.second][i] != 0 && i != now.second.first && i != now.second.second)\n                {\n                    pipii test;\n                    test.first = now.first + G[now.second.second][i];\n                    test.second.first = now.second.second;\n                    test.second.second = i;\n                    que.push(test);\n                }\n            }\n        }\n        else\n        {\n            ANS = max(ANS,(int)((double)(now.first + D[now.second.second]) / 2 + 0.5));\n        }\n    }\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<functional>\nusing namespace std;\n\n#define BLACK 2\n#define GRAY 1\n#define WHITE 0\n#define TEISU 1000000\n#define INF 1145141919\n\nvector<long long>x[4000];\nlong long n,m,a,b,c,k,G;\nlong long s[4000],d[4000],color[4000];\nlong long X[4000];\ndouble maxn;long long res;\n\npriority_queue<int,vector<int>,greater<int>>Q;\n\nvoid dijkstra(){\n\twhile(!Q.empty()){\n\t\tint A=Q.top()/TEISU;\n\t\tint B=Q.top()%TEISU;\n\t\tQ.pop();\n\t\tcolor[B]=BLACK;\n\n\t\tif(d[B]<A*(-1))continue;\n\n\t\tfor(int v=0;v<x[B].size();v++){\n\t\t\tint w=x[B][v]/TEISU;\n\n\t\t\tif(color[w]==BLACK)continue;\n\n\t\t\tif(d[w]>d[B]+x[B][v]%TEISU){\n\n\t\t\t\td[w]=d[B]+x[B][v]%TEISU;\n\t\t\t\tQ.push(d[w]*TEISU+w);\n\t\t\t\tcolor[w]=GRAY;\n\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tmemset(X,63,sizeof(X));\n\tcin>>n>>m>>k;\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>a>>b>>c;\n\t\tx[a].push_back(b*TEISU+c);\n\t\tx[b].push_back(a*TEISU+c);\n\t}\n\tfor(int i=0;i<k;i++){\n\t\tcin>>a;\n\t\ts[a]=1;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(s[i]==1){\n\t\t\tQ.push(i);\n\t\t\tfor(int v=1;v<=n;v++){\n\t\t\t\tcolor[v]=WHITE;\n\t\t\t\td[v]=INF;\n\t\t\t}\n\t\t\td[i]=0;\n\t\t\tdijkstra();\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tX[j]=min(X[j],d[j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tmaxn=max((long long)maxn,X[i]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<x[i].size();j++){\n\t\t\tif(abs(X[i]-X[x[i][j]/TEISU])<x[i][j]%TEISU){\n\t\t\t\ta=x[i][j]%TEISU-abs(X[i]-X[x[i][j]/TEISU]);\n\t\t\t\tmaxn=max(maxn,(double)(max(X[i],X[(int)(x[i][j]/TEISU)])+1.0*a/2.0));\n\t\t\t}\n\t\t}\n\t}\n\tres=(1.0*maxn+0.99999999);\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\n#define F first\n#define S second\n \nint a[200009],b[200009],c[200009],n,m,C,ans;\nvector<P>v[100009];\nint dist[100009];\nset<int>st;\n \nvoid dij(){\n  r(i,100009)dist[i]=1e16;\n  priority_queue<P,vector<P>,greater<P> >q;\n  r(i,n)if(st.count(i)){\n    dist[i]=0;\n    q.push(P(0,i));\n  }\n  while(!q.empty()){\n    P p=q.top();q.pop();\n    int cost=p.F;\n    int now=p.S;\n    r(i,v[now].size()){\n      int ncos=cost+v[now][i].S;\n      int nex=v[now][i].F;\n      if(dist[nex]>ncos){\n        dist[nex]=ncos;\n        q.push(P(ncos,nex));\n      }\n    }\n  }\n}\n \nsigned main(){\n  cin>>n>>m>>C;\n  r(i,m){\n    cin>>a[i]>>b[i]>>c[i]; a[i]--; b[i]--;\n    v[a[i]].push_back(P(b[i],c[i]));\n    v[b[i]].push_back(P(a[i],c[i]));\n  }\n  r(i,C){\n    int x;\n    cin>>x;\n    st.insert(x-1);\n  }\n  dij();\n  r(i,m) ans=max(ans,(dist[a[i]]+dist[b[i]]+c[i]+1)/2);\n  r(i,n) ans=max(ans,dist[i]);\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<functional>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PP;\nconst int INF = 1 << 30;\nint n, m, k;\nvector<P> road[3001];\nint shop[3001], dis[3001], from[3001], save[3001][3001];\nqueue<PP> que;\nint main(){\n\tcin >> n >> m >> k;\n\tfor (int i = 0; i<m; i++){\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\troad[a].push_back(P(b, c));\n\t\troad[b].push_back(P(a, c));\n\t}\n\tfor (int i = 0; i<k; i++)\n\t\tcin >> shop[i];\n\tfill(dis, dis + 3001, INF);\n\tfor (int i = 0; i<k; i++){\n\t\tfor (int j = 0; j<road[shop[i]].size(); j++){\n\t\t\tque.push(make_pair(make_pair(shop[i], road[shop[i]][j].f), road[shop[i]][j].s));\n\t\t\tdis[shop[i]] = 0;\n\t\t\tdis[road[shop[i]][j].f] = min(dis[road[shop[i]][j].f], road[shop[i]][j].s);\n\t\t\tfrom[road[shop[i]][j].f] = shop[i];\n\t\t}\n\t}\n\twhile (!que.empty()){\n\t\tPP p = que.front();\n\t\tque.pop();\n\t\tfor (int i = 0; i<road[p.f.s].size(); i++){\n\t\t\tif (dis[road[p.f.s][i].f]>p.s + road[p.f.s][i].s){\n\t\t\t\tque.push(make_pair(make_pair(p.f.s, road[p.f.s][i].f), p.s + road[p.f.s][i].s));\n\t\t\t\tdis[road[p.f.s][i].f] = p.s + road[p.f.s][i].s;\n\t\t\t\tfrom[road[p.f.s][i].f] = p.f.s;\n\t\t\t}\n\t\t}\n\t}\n\tdouble ans = 0;\n\tfor (int i = 0; i<3001; i++)\n\t\tfill(save[i], save[i] + 3001, INF);\n\tfor (int i = 1; i <= n; i++){\n\t\tif (dis[i] != INF){\n\t\t\tfor (int j = 0; j<road[i].size(); j++){\n\t\t\t\tdouble a = double(road[i][j].s + dis[i]) / 2;\n\t\t\t\tif (a>ans&&from[i] != road[i][j].f && save[i][road[i][j].f]>a + dis[i]){\n\t\t\t\t\tans = a;\n\t\t\t\t\tsave[i][road[i][j].f] = ans;\n\t\t\t\t}\n\t\t\t\tif (save[i][road[i][j].f]>a){\n\t\t\t\t\tsave[i][road[i][j].f] = a;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans2;\n\tans += 0.5;\n\tans2 = int(ans);\n\tcout << ans2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <utility>\nusing namespace std;struct road{int a,b,l;road(int a_,int b_,int l_):a(a_),b(b_),l(l_){}};typedef pair<int,int> pii;int main(){int n,m,k,a,b,l,s;vector<road> rd;vector<pii> town[3001];int len[3001];priority_queue<pii,vector<pii>,greater<pii> > qu;for(cin>>n>>m>>k;m--;rd.push_back(road(a,b,l))){cin>>a>>b>>l;town[a].push_back(make_pair(b,l));town[b].push_back(make_pair(a,l));}for(;k--;qu.push(make_pair(0,s)))cin>>s;for(fill(len,len+n+1,-1);!qu.empty();){pii pi = qu.top();qu.pop();if( len[pi.second] == -1 ){len[pi.second] = pi.first;for(vector<pii>::iterator it=town[pi.second].begin();it != town[pi.second].end();++it){qu.push(make_pair(pi.first+it->second,it->first));}}}s=0;for(vector<road>::iterator it = rd.begin(); it != rd.end();++it ){s = max(max( s, len[a] ),max( len[b], (len[it->b] + it->l - len[it->a] + 1)/2 + len[it->a] ));}cout << s << endl;}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\nint N, M, K, A, B, L;\n\nvector<vector<pair<int, int> > > G;\n\nvector<int> P, D;\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tscanf(\"%d\", &M);\n\tscanf(\"%d\", &K);\n\n\tG = vector<vector<pair<int, int> > >(N);\n\n\tfor (int i = 0; i < M; i++)\n\t{\n\t\tscanf(\"%d\", &A);\n\t\tscanf(\"%d\", &B);\n\t\tscanf(\"%d\", &L);\n\n\t\tG[A - 1].push_back(make_pair(B - 1, L));\n\t\tG[B - 1].push_back(make_pair(A - 1, L));\n\t}\n\n\tP = vector<int>(K);\n\n\tfor (int i = 0; i < K; i++)\n\t{\n\t\tscanf(\"%d\", &P[i]); P[i]--; // 0 - indexed\n\t}\n\n\tD = vector<int>(N, 999999999);\n\n\tpriority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > que;\n\n\tfor (int i = 0; i < K; i++)\n\t{\n\t\tque.push(make_pair(0, P[i])); D[P[i]] = 0;\n\t}\n\n\twhile (!que.empty())\n\t{\n\t\tpair<int, int> state = que.top(); que.pop();\n\n\t\tint dist = state.first;\n\t\tint node = state.second;\n\n\t\tfor (int j = 0; j < G[node].size(); j++)\n\t\t{\n\t\t\tint node2 = G[node][j].first;\n\t\t\tint leng2 = G[node][j].second;\n\n\t\t\tif (D[node2] > D[node] + leng2)\n\t\t\t{\n\t\t\t\tD[node2] = D[node] + leng2;\n\n\t\t\t\tque.push(make_pair(D[node2], node2));\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = 0;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < G[i].size(); j++)\n\t\t{\n\t\t\tret = max(ret, D[i] + D[G[i][j].first] + G[i][j].second);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", (ret + 1) / 2);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\nstruct edge{\n    int to;\n    int cost;\n};\nclass Situation{\npublic:\n\tint cost;\n\tint idx;\n\n\tSituation(int cost_,int idx_){\n\t\tcost=cost_;\n\t\tidx=idx_;\n\t}\n\tSituation();\n\n\tbool operator<(const Situation &s)const{\n\t\treturn s.cost < this->cost;\n\t}\n};\nconst int MAX_V=3001;\n\nint N,M,K;\nvector<edge> G[MAX_V];\n\nint d[MAX_V];\nconst int INF=1000000000;\nint froms[100001];\nint tos[100001];\nint costs[100001];\n\nvoid dijkstra(int s){\n\tpriority_queue<Situation> que;\n\td[s] = 0;\n\tque.push(Situation(0,s));\n\twhile(!que.empty()){\n\t\tSituation p = que.top();\n\t\tque.pop();\n\t\tint v = p.idx;\n\t\tif(d[v] < p.cost)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost){\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(Situation(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n\n    cin>>N>>M>>K;\n    for(int i=0;i<M;i++){\n        edge e;\n        int from,to,cost;\n        cin>>from>>to>>cost;\n        from--;to--;\n        froms[i]=from;\n        tos[i]=to;\n        costs[i]=cost;\n        e.to=to;\n        e.cost=cost;\n        G[from].push_back(e);\n        e.to=from;\n        G[to].push_back(e);\n    }\n\tfill(d,d+MAX_V,INF);\n    for(int i=0;i<K;i++){\n        int a;\n        cin>>a;\n        a--;\n        dijkstra(a);\n    }\n    double res=0;\n    for(int i=0;i<N;i++)\n        res=max(res,(double)d[i]);\n    for(int i=0;i<M;i++){\n        double dit=(1.0*d[froms[i]]+d[tos[i]]+costs[i])/2;\n        res=max(dit,res);\n    }\n    printf(\"%.0f\\n\",res);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483648\n#define INT_MAX 2147483647\n#define LL_MIN -9223372036854775808\n#define LL_MAX 9223372036854775807\n#define PI 3.14159265359\n#define MP(a, b) make_pair(a, b)\n#define MMP(a, b, c) make_pair(make_pair(a, b), c)\n\n#define MAX 1000000000\n\n//まず町ごとの最短コストを求める\n//道ごとに更に求める\n\nint main(){\n    iostream::sync_with_stdio(false);\n    \n    int N,M,K;\n    cin >> N >> M >> K;\n    vector<pair<int,int> > road[3000];\n    vector<pair<pair<int,int>,int> > r;\n    for(int i=0; i<M; i++){\n        int a,b,l;\n        cin >> a >> b >> l;\n        a--; b--;\n        road[a].push_back(MP(b, l));\n        road[b].push_back(MP(a, l));\n        r.push_back(MMP(a, b, l));\n    }\n\n    int cost[3000];\n    for(int i=0; i<N; i++) cost[i] = MAX;\n    priority_queue<pair<int,int> > que;\n    for(int i=0; i<K; i++){\n        int tmp;\n        cin >> tmp;\n        tmp--;\n        cost[tmp] = 0;\n        que.push(MP(MAX, tmp));\n    }\n\n    while(!que.empty()){\n        int now = que.top().second;\n        int c = MAX - que.top().first;\n        for(int i=0; i<road[now].size(); i++){\n            int next = road[now][i].first;\n            int l = road[now][i].second;\n            if(cost[next] > c+l){\n                cost[next] = c+l;\n                que.push(MP(MAX-cost[next], next));\n            }\n        }\n        que.pop();\n    }\n    //for(int i=0; i<N; i++) cout << cost[i] << endl;\n\n    int ans = 0;\n    for(int i=0; i<M; i++){\n        int a = r[i].first.first;\n        int b = r[i].first.second;\n        int l = r[i].second;\n        int d = abs(cost[a] - cost[b]);\n        if(d >= l) ans = max(ans, max(cost[a], cost[b]));\n        else{\n            int add = round((double)(l - d)/2);\n            ans = max(ans, max(cost[a]+add, cost[b]+add));\n        }\n    }\n    cout << ans << endl;\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n\nint x[4000][4000];\nint n,m,a,b,c,k;\nint s[4000],d[4000];\nint X[4000];\ndouble maxn;int res;\n\nint main(){\n\tmemset(X,63,sizeof(X));\n\tcin>>n>>m>>k;\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>a>>b>>c;\n\t\tx[a][b]=c;\n\t\tx[b][a]=c;\n\t}\n\tfor(int i=0;i<k;i++){\n\t\tcin>>a;\n\t\ts[a]=1;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(s[i]==1){\n\t\t\tmemset(d,63,sizeof(d));\n\t\t\td[i]=0;\n\t\t\tfor(int h=1;h<=n;h++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tif(d[j]<100000000){\n\t\t\t\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t\t\t\tif(x[j][k]>=1){\n\t\t\t\t\t\t\t\td[k]=min(d[k],d[j]+x[j][k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tX[j]=min(X[j],d[j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tmaxn=max((int)maxn,X[i]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(x[i][j]>=1){\n\t\t\t\tif(abs(X[i]-X[j])<x[i][j]){\n\t\t\t\t\ta=x[i][j]-abs(X[i]-X[j]);\n\t\t\t\t\tmaxn=max(maxn,(double)(max(X[i],X[j])+1.0*a/2.0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tres=(1.0*maxn+0.99999999);\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\nusing namespace std;\ntypedef pair < int , int > Pi;\n#define fr first\n#define sc second\n#define INF ( 1 << 30 )\nstruct edge{\n  int to, cost;\n};\nvector < edge > info[3001];\nint main() {\n  int N, M, K;\n\n  cin >> N >> M >> K;\n  for(int i = 0 ; i < M ; i++ ){\n    int a, b, c;\n    cin >> a >> b >> c;\n    info[a].push_back((edge){ b, c});\n    info[b].push_back((edge){ a, c});\n  }\n\n  int used[3001];\n  fill_n( used, 3001, INF);\n  priority_queue< Pi , vector< Pi >,greater< Pi > > que;\n  for(int i = 0 ; i < K ; i++ ){\n    int a;\n    cin >> a;\n\n    que.push(Pi( 0, a));\n    used[a] = 0;\n\n    while(!que.empty()){\n      Pi p = que.top();\n      que.pop();\n      for(int j = 0 ; j < info[p.sc].size() ; j++ ){\n        edge e = info[p.sc][j];\n        if( used[e.to] > p.fr + e.cost ){\n          used[e.to] = p.fr + e.cost;\n          que.push( Pi( used[e.to], e.to));\n        }\n      }\n    }\n  }\n\n\n  int ret = 0;\n  for(int i = 1 ; i <= N ; i++ ){\n    for(int j = 0 ; j < info[i].size() ; j++ ){\n      if( used[i] <= used[info[i][j].to]){\n        const int java = used[info[i][j].to] - used[i];\n        ret = max( ret, used[i] + java + (info[i][j].cost - java + 1) / 2);\n      }\n    }\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3002\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<P> G[N];\nbool num[N];\nint n,m,K;\n\ndouble dijkstra(){\n  int D[N];\n  for(int i=0;i<N;i++) D[i] = 1e9;\n  \n  vector<int>pre[N];\n  priority_queue<PP,vector<PP>,greater<PP> >Q;\n  \n  for(int i=0;i<N;i++)\n    if(num[i]) {\n      Q.push(PP(0,P(i,i)));\n      D[i] = 0;\n      pre[i].push_back(i);\n    }\n  \n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first;\n    int pos = t.second.first;\n    int start = t.second.second;\n\n    if(D[pos]<cost) continue;\n    pre[pos].push_back(start);\n    \n    for(int i=0;i<G[pos].size();i++){\n      int npos = G[pos][i].first;\n      int ncost = cost+G[pos][i].second;\n      if(D[npos]<ncost) continue;\n      Q.push(PP(ncost,P(npos,start)));\n      D[npos] = ncost;\n    }\n  }\n  \n\n  double res = 0;\n  for(int i=0;i<n;i++){\n    if(pre[i].size()>=2)res = max(res,(double)D[i]);\n    \n    for(int j=0;j<G[i].size();i++){\n      int npos = G[i][j].first;\n      int ncost = G[i][j].second;\n      if(npos == pre[i][0]){\n\tif(abs(D[i]-D[npos])!=ncost) res = max(res,(D[i]+D[npos]+ncost)/2.0);\n      }\n      else res = max(res,(D[i]+D[npos]+ncost)/2.0);\n    }\n  }\n  return res;\n  \n}\n\nint main(){\n  \n  cin>>n>>m>>K;\n  for(int i=0,a,b,c;i<m;i++){\n    cin>>a>>b>>c;\n    G[a-1].push_back(P(b-1,c));\n    G[b-1].push_back(P(a-1,c));\n  }\n\n  for(int i=0,a;i<K;i++)cin>>a,num[a-1]=1;\n  printf(\"%d\\n\",(int)(dijkstra()+0.5));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3002\nusing namespace std;\ntypedef pair<int,int> P;\nvector<P> G[N];\nbool num[N];\nint n,m,K;\n\ndouble dijkstra(){\n  vector<int> D(N,1e9);\n  priority_queue<P,vector<P>,greater<P> >Q;\n  for(int i=0;i<n;i++)if(num[i]) Q.push(P(0,i)),D[i] = 0;\n  \n  while(!Q.empty()){\n    P t = Q.top();Q.pop();\n    int cost = t.first;\n    int pos = t.second;\n    \n    if(D[pos]<cost) continue;\n    for(int i=0;i<G[pos].size();i++){\n      int npos = G[pos][i].first;\n      int ncost = cost+G[pos][i].second;\n      if(D[npos]<=ncost) continue;\n      Q.push(P(npos,pos));\n      D[npos] = ncost;\n    }\n  }\n\n  double res = 0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<(int)G[i].size();j++){\n      int npos = G[i][j].first;\n      int ncost = G[i][j].second;\n      res = max(res,(D[i]+D[npos]+ncost)/2.0);\n  }\n  return res;\n   \n}\n \nint main(){\n  cin>>n>>m>>K;\n  for(int i=0,a,b,c;i<m;i++){\n    cin>>a>>b>>c;\n    G[a-1].push_back(P(b-1,c));\n    G[b-1].push_back(P(a-1,c));\n  }\n \n  for(int i=0,a;i<K;i++)cin>>a,num[a-1]=1;\n  printf(\"%d\\n\",(int)(dijkstra()+0.5));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define enld '\\n'\n#define rep(i,n) for(int i=0; i<(n); i++)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"Ofast\")\nconstexpr ll INF = 1e18;\nconstexpr int inf = 1e9;\nconstexpr ll mod = 1000000007;\nconstexpr ll mod2 = 998244353;\nconst double PI = 3.1415926535897932384626433832795028841971;\nconst int dx[6] = {1, 0, -1, 0,1,1};\nconst int dy[6] = {0, 1, 0, -1,1,-1};\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n// ---------------------------------------------------------------------------\n\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int N,M,K;\n    cin >> N >> M >> K;\n    vector<int> l(M),r(M),c(M);\n    vector<vector<P>> G(N);\n    for(int i=0; i<M; i++){\n        cin >> l[i] >> r[i] >> c[i];\n        l[i]--;r[i]--;\n        G[l[i]].emplace_back(r[i],c[i]);\n        G[r[i]].emplace_back(l[i],c[i]);\n    }\n    priority_queue<P,vector<P>,greater<P>> que;\n    vector<int> dist(N,inf);\n    for(int i=0; i<K; i++){\n        int a;\n        cin >> a;\n        a--;\n        dist[a] = 0;\n        que.emplace(0,a);\n    }\n    while(que.size()){\n        int v = que.top().second;\n        int cost = que.top().first;\n        que.pop();\n        if(cost > dist[v]) continue;\n        for(auto nv: G[v]){\n            if(nv.second + cost < dist[nv.first]){\n                dist[nv.first] = nv.second + cost;\n                que.emplace(dist[nv.first],nv.first); \n            }\n        }\n    }\n    // for(int i=0; i<N; i++){\n    //     cout << dist[i] << enld;\n    // }\n    int ans = 0;\n    for(int i=0; i<N; i++){\n        chmax(ans,dist[i]);\n        for(auto nv: G[i]){\n            int v = nv.first;\n            int t = (dist[v]+dist[i]+nv.second+1)/2;\n            chmax(ans,t);\n        }\n    }\n    cout << ans << enld;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 10001\n#define ll long long\n#define dmp make_pair\n#define dpb push_back\n#define P pair<int,int>\n#define fi first\n#define se second\nusing namespace std;\n//__gcd(a,b), __builtin_popcount(a);\nconst int inf = 1e9;\nconst ll INF = 1e18;\n#define B 100\n\nstruct edge{int to, cost;};\nvector<edge> G[3001];\npriority_queue<P, vector<P>, greater<P> > q;\nint v[3001];\nint main(){\n\tint n, m, k, a, b, l;\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tfill(v, v+3001, inf);\n\trep(i,m){\n\t\tscanf(\"%d%d%d\", &a, &b, &l);\n\t\tG[a].push_back((edge){b, l});\n\t\tG[b].push_back((edge){a, l});\n\t}\n\trep(i,k){\n\t\tscanf(\"%d\", &a);\n\t\tv[a] = 0;\n\t\tq.push(dmp(0, a));\n\t}\n\t\n\twhile(!q.empty()){\n\t\tP x = q.top();q.pop();\n\t\tif(v[x.se] < x.fi)continue;\n\t\tfor(int i = 0;i < G[x.se].size();i++){\n\t\t\tint t1 = G[x.se][i].to, t2 = G[x.se][i].cost;\n\t\t\tif(v[t1] > v[x.se]+t2){\n\t\t\t\tv[t1] = v[x.se]+t2;\n\t\t\t\tq.push(dmp(v[t1], t1));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 0;j < G[i].size();j++){\n\t\t\tint x = v[i], y = v[G[i][j].to];\n\t\t\tans = max(ans, (x+y+G[i][j].cost+1)/2);\n\t\t}\n\t}\n\t\n\t/*for(int i = 1;i <= n;i++){\n\t\tprintf(\"%d \", v[i]);\n\t}*/\n\tprintf(\"%d\\n\", ans);\n\t/*rrep(i,n){\n\t\trep(j,G[i].size())printf(\"%d %d\\n\", G[i][j].to, G[i][j].cost);\n\t}*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<vector>\n#include<queue>\n#include<map>\n#define INF 200000000\nusing namespace std;\ntypedef struct{\n\tint a,b,c;\n}edge;\ntypedef struct{\n\tint to,cost;\n}edge2;\ntypedef pair<int,int> P;\nedge e[100000];\nvector<edge2> ve[3000];\nint d[3000];\nint md[3000];\nint n,m,k;\nint min(int a,int b){return a<b?a:b;}\nint max(int a,int b){return a>b?a:b;}\nvoid solve(int s){\n\tint i;\n\tpriority_queue<P> que;\n\tfor(i=0;i<n;i++)d[i]=INF;\n\td[s]=0;\n\tque.push(P(0,s));\n\twhile(!que.empty()){\n\t\tP p=que.top();\n\t\tque.pop();\n\t\tint v=p.second;\n\t\tif(d[v]<p.first)continue;\n\t\tfor(i=0;i<ve[v].size();i++){\n\t\t\tif(d[ve[v][i].to]>d[v]+ve[v][i].cost){\n\t\t\t\td[ve[v][i].to]=d[v]+ve[v][i].cost;\n\t\t\t\tque.push(P(d[ve[v][i].to],ve[v][i].to));\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=0;i<n;i++)md[i]=min(md[i],d[i]);\n}\nint main(){\n\tint i,j;\n\tscanf(\"%d %d %d\",&n,&m,&k);\n\tfor(i=0;i<n;i++)md[i]=INF;\n\tfor(i=0;i<m;i++){\n\t\tint x,y,z;\n\t\tscanf(\"%d %d %d\",&x,&y,&z);\n\t\tedge ed={x-1,y-1,z};\n\t\tedge2 ed2={y-1,z};\n\t\tedge2 ed3={x-1,z};\n\t\te[i]=ed;\n\t\tve[x-1].push_back(ed2);\n\t\tve[y-1].push_back(ed3);\n\t}\n\tfor(i=0;i<k;i++){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tsolve(x-1);\n\t}\n\tint ans=0;\n\tfor(i=0;i<m;i++){\n\t\tint mid=(int)round((double)(md[e[i].a]+md[e[i].b]+e[i].c)/2);\n\t\tans=max(ans,max(mid,max(md[e[i].a],md[e[i].b])));\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\nconst int INF = (1LL<<30);\nconst ll LLINF = (1LL<<60);\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n//#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nstruct edge{int to, cost;};\n\nint n, d[1010], m, k, s[1010];\nvector<edge> g[1010];\n\nvoid dijkstra() {\n  priority_queue<PII, vector<PII>, greater<PII>> que;\n  fill(d, d+n, INF);\n  REP(i, k) {\n    d[s[i]] = 0;\n    que.push(PII{0, s[i]});\n  }\n\n  while(que.size()) {\n    PII p = que.top(); que.pop();\n    int v = p.second;\n    if(d[v] < p.first) continue;\n    for(edge e: g[v]) {\n      if(d[e.to] > d[v] + e.cost) {\n        d[e.to] = d[v] + e.cost;\n        que.push(PII{d[e.to], e.to});\n      }\n    }\n  }\n}\n\nint a[1010], b[1010], c[1010];\nsigned main(void)\n{\n  cin >> n >> m >> k;\n  REP(i, m) {\n    cin >> a[i] >> b[i] >> c[i];\n    a[i]--, b[i]--;\n    g[a[i]].PB({b[i], c[i]});\n    g[b[i]].PB({a[i], c[i]});\n  }\n  REP(i, k) cin >> s[i], s[i]--;\n\n  dijkstra();\n  // REP(i, n) cout << d[i] << \" \"; cout << endl;\n\n  int ret = 0;\n  REP(i, m) chmax(ret, (d[a[i]]+d[b[i]]+c[i])/2+!!((d[a[i]]+d[b[i]]+c[i])%2));\n  cout << ret << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\ntypedef pair<int,int> P;\nint N,M,K,a,b,l,k,inf = 2e9;\nint C[3010] = {},use[3010] = {};\nint cost[3010][3010] = {};\n//vector<vector<P>> v(3010);\nint main(){\n    cin >> N >> M >> K;\n    for(int i=1;i<=N;i++){\n        for(int j=1;j<=N;j++){\n            if(i!=j) cost[i][j] = inf;\n        }\n    }\n    for(int i=0;i<M;i++){\n        cin >> a >> b >> l;\n        cost[a][b] = l;\n        cost[b][a] = l;\n    }\n    for(int i=1;i<=N;i++) C[i] = inf;\n    for(int i=1;i<=K;i++){\n        cin >> k;\n        C[k] = 0;\n    }\n    while(true){\n        int id = -1;\n        for(int i=1;i<=N;i++){\n            if(use[i]==0 && (id==-1 || C[id]>C[i])) id = i;\n        }\n        if(id==-1) break;\n        use[id] = 1;\n        for(int i=1;i<=N;i++){\n            C[i] = min(C[i],C[id]+cost[id][i]);\n        }\n    }\n    int ans = 0;\n    //for(int i=1;i<=N;i++) cout << C[i] << endl;\n    for(int i=1;i<=N;i++){\n        for(int j=1;j<=N;j++){\n            int c = 0;\n            if(cost[i][j]!=inf){\n                if(C[i]+cost[i][j]<=C[j]) c = C[j];\n                else if(C[j]+cost[i][j]<=C[i]) c = C[i];\n                else c = (C[i]+C[j]+cost[i][j]+1)/2;\n                ans = max(ans,c);\n            }\n        }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> T INF = 1000000007;\n\ntemplate <typename T>\nstruct edge {\n    int from, to; T cost;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n};\n\n\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n    vector<vector<edge<int>>> G(n);\n    for (int i = 0; i < m; ++i) {\n        int a, b, l;\n        scanf(\"%d %d %d\", &a, &b, &l);\n        G[a-1].emplace_back(b-1, l);\n        G[b-1].emplace_back(a-1, l);\n    }\n    vector<int> d(n, INF<int>);\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> Q;\n    for (int i = 0; i < k; ++i) {\n        int t; cin >> t; t--;\n        d[t] = 0;\n        Q.emplace(0, t);\n    }\n    while(!Q.empty()){\n        int cost; int i;\n        tie(cost, i) = Q.top(); Q.pop();\n        if(d[i] < cost) continue;\n        for (auto &&e : G[i]) {\n            auto cost2 = cost + e.cost;\n            if(d[e.to] <= cost2) continue;\n            d[e.to] = cost2;\n            Q.emplace(d[e.to], e.to);\n        }\n    }\n    int ans = *max_element(d.begin(),d.end());\n    for (int i = 0; i < n; ++i) {\n        for (auto &&e : G[i]){\n            if(d[e.to] < d[i] || d[e.to] == d[i]+e.cost) continue;\n            ans = max(ans, (d[e.to]+d[i]+e.cost+1)/2);\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <deque>\nusing namespace std;\n\nint main() {\n\tint N,M,K;\n\tvector<pair<int,int> >nGo[3001];\n\tdeque<int> dis;\n\tint dist[3001];\n\tint road[3000][3];\n\tfor(int i=1;i<=3000;i++)\n\t\tdist[i]=(1 << 30 );\n\tcin >> N >> M >> K;\n\tint a,b,c;\n\tfor(int i=0;i<M;i++){\n\t\tcin >> a >> b >> c;\n\t\tnGo[a].push_back(pair<int,int>(b,c));\n\t\tnGo[b].push_back(pair<int,int>(a,c));\n\t\troad[i][0]=a;\n\t\troad[i][1]=b;\n\t\troad[i][2]=c;\n\t}\n\tfor(int i=0;i<K;i++){\n\t\tcin >> a;\n\t//\tdis.insert(multimap<int,int>::value_type(0,a));\n\t\tdis.push_back(a);\n\t\tdist[a]=0;\n\t}\n\twhile(!dis.empty()){\n\t\tsort(dis.begin(),dis.end());\n\t\tint now=dis[0];\n\t\tfor(int i=0;i<nGo[now].size();i++){\n\t\t\tif(dist[nGo[now][i].first]>dist[now]+nGo[now][i].second){\n\t\t\t\tdis.push_back(nGo[now][i].first);\n\t\t\t\tdist[nGo[now][i].first]=dist[now]+nGo[now][i].second;\n\t\t\t}\n\t\t}\n\t\tdis.pop_front();\n\t}\n\tint maxer=0;\n\tfor(int i=0;i<M;i++)\n\tmaxer=max(maxer,(int)(dist[road[i][0]]+dist[road[i][1]]+road[i][2]+0.5)/2);\n\tfor(int i=1;i<=N;i++)\n\tmaxer=max(maxer,dist[i]);\n\tcout << maxer <<  endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nstruct edge{\n  int src,dst,cost;\n  edge(int src,int dst,int cost):src(src),dst(dst),cost(cost){}\n};\n\nstruct state{\n  int cur;\n  long long cost;\n  state(int cur, long long cost):cur(cur),cost(cost){}\n  bool operator>(const state &t)const{\n    return cost > t.cost;\n  }\n};\n\ntypedef vector<edge> edges;\ntypedef vector<edges> graph;\nconst int N = 3010;\nconst long long inf = 1LL<<58;\n\nvoid dijkstra(const graph &g, int k, int shop[], long long A[])\n{\n  priority_queue<state,vector<state>,greater<state> > q;\n  for(int i = 0; i < k; ++i){\n    state init(shop[i],0);\n    q.push(init);\n  }\n\n  while(!q.empty()){\n    state cst = q.top();\n    q.pop();\n\n    for(int i = 0; i < (int)g[cst.cur].size(); ++i){\n      // int src = g[cst.cur][i].src;\n      int dst = g[cst.cur][i].dst;\n      int w   = g[cst.cur][i].cost;\n      if( A[dst] > cst.cost + w ){\n        A[dst] = cst.cost + w;\n        q.push( state( dst, cst.cost + w ) );\n      }\n    }\n  }\n}\n\nint main()\n{\n  int n,m,k;\n  while(cin>>n>>m>>k){\n    if(n==0&&m==0&k==0)break;\n\n    long long A[n];\n    graph g(n);\n    int adj[n][n];\n    for(int i = 0; i < n; ++i){\n      A[i] = inf;\n      for(int j = 0; j < n; ++j){\n        adj[i][j] = 0;\n      }\n    }\n    for(int i = 0; i < m; ++i){\n      int a,b,c;\n      cin >> a >> b >> c;\n      --a;--b;\n      adj[a][b] = adj[b][a] = c;\n      g[a].push_back(edge(a,b,c));\n      g[b].push_back(edge(b,a,c));\n    }\n    int shop[N];\n    for(int i = 0; i < k; ++i){\n      cin >> shop[i];\n      --shop[i];\n      A[shop[i]] = 0;\n    }\n\n    dijkstra(g,k,shop,A);\n\n    double res = 0;\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n        if( adj[i][j] > 0 ){\n          int a = A[i];\n          int b = A[j];\n          if( b < a ) swap(a,b);\n          //cout << i << ' ' << j << ' ' << a << ' ' << b << ' ' << ((adj[i][j]+ a -b)/2. + b) << endl; \n          res = max( res, (adj[i][j]+ a -b)/2. + b);\n        }\n      }\n    }\n    \n    printf(\"%.0lf\\n\", res+0.499999999);\n    \n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\nusing namespace std;\n\nvector<int>x[4000];\nlong long n,m,a,b,c,k,G;\nlong long s[4000],d[4000];\nlong long X[4000];\ndouble maxn;int res;\n\nint main(){\n\tmemset(X,63,sizeof(X));\n\tcin>>n>>m>>k;\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>a>>b>>c;\n\t\tx[a].push_back(b*1000000+c);\n\t\tx[b].push_back(a*1000000+c);\n\t}\n\tfor(int i=0;i<k;i++){\n\t\tcin>>a;\n\t\ts[a]=1;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(s[i]==1){\n\t\t\tmemset(d,63,sizeof(d));\n\t\t\td[i]=0;\n\t\t\tif(n<500){G=n;}\n\t\t\telse{G=max(20LL,(n+k)/k+10LL);}\n\t\t\tfor(int h=1;h<=G;h++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tif(d[j]<1000000000){\n\t\t\t\t\t\tfor(int k=0;k<x[j].size();k++){\n\t\t\t\t\t\t\td[x[j][k]/1000000]=min(d[x[j][k]/1000000],d[j]+x[j][k]%1000000);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tX[j]=min(X[j],d[j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tmaxn=max((long long)maxn,X[i]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<x[i].size();j++){\n\t\t\tif(abs(X[i]-X[x[i][j]/1000000])<x[i][j]%1000000){\n\t\t\t\ta=x[i][j]%1000000-abs(X[i]-X[x[i][j]/1000000]);\n\t\t\t\tmaxn=max(maxn,(double)(max(X[i],X[(int)(x[i][j]/1000000)])+1.0*a/2.0));\n\t\t\t}\n\t\t}\n\t}\n\tres=(1.0*maxn+0.99999999);\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<queue>\n#include<vector>\nusing namespace std;\nconst int INF=1000000000;\ntypedef pair<int,int> P;\nstruct edge{\n\tint to;\n\tint cost;\n};\n\nint main(){\n\tbool bo[3000+2];\n\tfill(bo,bo+3002,false);\n\tint n,m,k,a,b,l,ans=0;\n\tP p[3000+2],q;\n\tvector<edge> ed[3000+2];\n\tpriority_queue<P,vector<P>,greater<P>> que;\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tfor(int i=1;i<=n;i++){p[i].first=INF; p[i].second=i;}\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d%d\",&a,&b,&l);\n\t\tedge e;\n\t\te.to=b;\n\t\te.cost=l;\n\t\ted[a].push_back(e);\n\t\te.to=a;\n\t\ted[b].push_back(e);\n\t}\n\tfor(int i=0;i<k;i++){\n\t\tscanf(\"%d\",&a);\n\t\tp[a].first=0;\n\t\tque.push(p[a]);\n\t}\n\twhile(!que.empty()){\n\t\tq=que.top(); que.pop();\n\t\tif(!bo[q.second]){\n\t\t\tbo[q.second]=true;\n\t\t\tint s=ed[q.second].size();\n\t\t\tfor(int i=0;i<s;i++){\n\t\t\t\tif(p[ed[q.second][i].to].first>p[q.second].first+ed[q.second][i].cost){\n\t\t\t\t\tp[ed[q.second][i].to].first=p[q.second].first+ed[q.second][i].cost;\n\t\t\t\t\tque.push(p[ed[q.second][i].to]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(p[i].first>ans)ans=p[i].first;\n\t\tint s=ed[i].size();\n\t\tfor(int j=0;j<s;j++){\n\t\t\tif(ans*2<p[i].first+p[ed[i][j].to].first+ed[i][j].cost)ans=(p[i].first+p[ed[i][j].to].first+ed[i][j].cost+(p[i].first+p[ed[i][j].to].first+ed[i][j].cost)%2)/2;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst int INF = 1 << 30;\n\nstruct Edge\n{\n\tint to, cost;\n\tEdge(int to, int cost) \n\t\t: to(to), cost(cost)\n\t{ }\n};\n\nint main()\n{\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\t\n\tvint d(n, INF);\n\tpriority_queue<pint, vector<pint>, greater<pint> > que;\n\tvector<vector<Edge> > edges(n, vector<Edge>());\n\t\n\trep(i, m)\n\t{\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\t\n\t\tedges[a - 1].push_back(Edge(b - 1, c));\n\t\tedges[b - 1].push_back(Edge(a - 1, c));\n\t}\n\t\n\trep(i, k)\n\t{\n\t\tint f;\n\t\tcin >> f;\n\t\t\n\t\td[f - 1] = 0;\n\t\t\n\t\tque.push(mp(0, f - 1));\n\t}\n\t\n\t\n\t// ショッピングモールがある街を距離０として他の街へダイクストラで最短路探索\n\tfor(; !que.empty(); que.pop())\n\t{\n\t\tint cost = que.top().first;\n\t\tint v = que.top().second;\n\t\t\n\t\tif(d[v] < cost) continue;\n\t\t\n\t\trep(i, edges[v].size())\n\t\t{\n\t\t\tEdge e(edges[v][i]);\n\t\t\t\n\t\t\tif(d[v] + e.cost < d[e.to])\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\t\n\t\t\t\tque.push(mp(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t// 辺上の最大値を探すO(m)\n\tdouble res = 0;\n\trep(i, n) \n\t{\n\t\trep(j, edges[i].size())\n\t\t{\n\t\t\tEdge &e = edges[i][j];\n\t\t\tint diff = d[e.to] - d[i];\n\t\t\t\n\t\t\tif(d[i] <= d[e.to]) chmax(res, d[i] + diff + (e.cost - diff) / 2.0);\n\t\t}\n\t\t\n\t\tchmax(res, d[i]);\n\t}\n\t\n\tcout << round(res) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <map>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nconst int INF = 1e+9 * 2;\ntypedef pair<int, int> P;\n\nstruct edge {\n\tint to, c;\n\tedge(int _to, int _c) : to(_to), c(_c){} \n};\n\nint N, M, d[3001], d_min[3001];\nvector<edge> G[3001];\n\nvoid dijkstra(){\n}\n\nint main() {\n\tint k, shop, a, b, l;\n\tcin >> N >> M >> k;\n\tfor(int i = 0; i < M; ++i){\n\t\tscanf(\"%d %d %d\", &a, &b, &l);\n\t\tG[a].push_back(edge(b, l));\n\t\tG[b].push_back(edge(a, l));\n\t}\n\t\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tfill(d, d + N + 1, INF);\n\tfor(int i = 0; i < k; ++i){\n\t\tscanf(\"%d\", &shop);\n\t\td[shop] = 0;\n\t\tque.push(P(0, shop));\n\t}\n\twhile(!que.empty()){\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[v].size(); ++i){\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.c){\n\t\t\t\td[e.to] = d[v] + e.c;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n\tdouble ans = 0;\n\tfor(int i = 1; i <= N; ++i)\n\t\tans = max(ans, (double)d[i]);\n\t\n\tfor(int i = 1; i <= N; ++i){\n\t\tfor(int j = 0; j < G[i].size(); ++i){\n\t\t\tint diff = d[G[i][j].to] - d[i];\n\t\t\tif(diff < 0)\n\t\t\t\tcontinue;\n\t\t\tans = max(ans, d[i] + diff + (G[i][j].c - diff) / 2.0);\n\t\t}\n\t}\n\tcout << round(ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\nusing namespace std;\n\nvector<long long>x[4000];\nlong long n,m,a,b,c,k,G;\nlong long s[4000],d[4000];\nlong long X[4000];\ndouble maxn;int res;\n\nint main(){\n\tmemset(X,63,sizeof(X));\n\tcin>>n>>m>>k;\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>a>>b>>c;\n\t\tx[a].push_back(b*1000000+c);\n\t\tx[b].push_back(a*1000000+c);\n\t}\n\tfor(int i=0;i<k;i++){\n\t\tcin>>a;\n\t\ts[a]=1;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(s[i]==1){\n\t\t\tmemset(d,63,sizeof(d));\n\t\t\td[i]=0;\n\t\t\tif(n<500){G=n;}\n\t\t\telse{G=max(20LL,(n+k)/k+10LL);}\n\t\t\tfor(int h=1;h<=G;h++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tif(d[j]<1000000000){\n\t\t\t\t\t\tfor(int k=0;k<x[j].size();k++){\n\t\t\t\t\t\t\td[x[j][k]/1000000]=min(d[x[j][k]/1000000],d[j]+x[j][k]%1000000);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tX[j]=min(X[j],d[j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tmaxn=max((long long)maxn,X[i]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<x[i].size();j++){\n\t\t\tif(abs(X[i]-X[x[i][j]/1000000])<x[i][j]%1000000){\n\t\t\t\ta=x[i][j]%1000000-abs(X[i]-X[x[i][j]/1000000]);\n\t\t\t\tmaxn=max(maxn,(double)(max(X[i],X[(int)(x[i][j]/1000000)])+1.0*a/2.0));\n\t\t\t}\n\t\t}\n\t}\n\tres=(1.0*maxn+0.99999999);\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\n#define INF (1e9)\n#define LLINF (1e18)\n#define long long\n\n#define MAX_V 3000\n\nusing namespace std;\n\ntypedef struct edge{\npublic:\n\tint to;\n\tdouble cost;\n\tedge(){}\n\tedge(int _to,double _cost){\n\t\tto = _to;\n\t\tcost = _cost;\n\t}\n\tbool operator<(const edge &a)const{\n\t\tif(cost == a.cost) return to > a.to;\n\t\treturn cost > a.cost;\t//for asc\n\t}\n}edge;\n\n\ndouble dist[MAX_V + 1];\nvector<edge> G[MAX_V + 1];\n\npriority_queue<edge> pque;\n\nint shops[MAX_V + 1];\n\nint V;\nint E;\nint K;\n\n\ndouble ans;\n\ndouble calc(double x,double y,double e){\n\tdouble a;\n\ta = (y - x + e) / 2;\n\treturn a;\n}\n\nvoid solve(){\n\tfor(int i = 0;i < MAX_V + 1;i++) dist[i] = INF;\n\n\tfor(int i = 0;i < K;i++){\n\t\tpque.push(edge(shops[i],1));\n\t}\n\n#ifndef EVAL\n//\tputs(\"###DBG1\");\n#endif\n\n\twhile(!pque.empty()){\n\t\tedge e = pque.top(); pque.pop();\n\t\tif(dist[e.to] != INF) continue;\n\t\tdist[e.to] = e.cost;\n\n\t\tfor(int i = 0;i < G[e.to].size();i++){\n\t\t\tint _to = G[e.to][i].to;\n\t\t\tdouble _cost = G[e.to][i].cost + e.cost;\n\t\t\tpque.push(edge(_to,_cost));\n\t\t}\n\n\t}\n\n#ifndef EVAL\n//\tputs(\"###DBG2\");\n#endif\n\n\tans = 0;\n\tfor(int i = 1;i < V + 1;i++){\n\t\tfor(int j = 0;j < G[i].size();j++){\n\t\t\tans = max(ans,calc(dist[i],dist[G[i][j].to],G[i][j].cost));\n\t\t}\n\t}\n\n\n\treturn ;\n}\n\nint main(){\n\n\tscanf(\"%d%d%d\",&V,&E,&K);\n\tint _u,_v;\n\tdouble _cost;\n\tfor(int i = 0;i < E;i++){\n\t\tscanf(\"%d%d\",&_u,&_v);\n\t\tscanf(\"%lf\",&_cost);\n\t\tG[_u].push_back(edge(_v,_cost));\n\t\tG[_v].push_back(edge(_u,_cost));\n\t}\n\tfor(int i = 0;i < K;i++){\n\t\tscanf(\"%d\",shops + i);\n\t}\n\n#ifndef EVAL\n//\tputs(\"###DBG\");\n#endif\n\n\tsolve();\n\n\tprintf(\"%d\\n\",(int)(ans + 0.5));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define MAX_N 3001\n#define UNDEF -1\n#define MAX_INT 2147483647\n\ntypedef struct\n{\n\tunsigned short int node1;\n\tunsigned short int node2;\n\tunsigned short int length;\n\tunsigned int distance;\n} Road;\n\ntypedef struct\n{\n\tunsigned int distance;\n\tbool decided;\n} Node;\n\nint N,M,K;\nvector<Road> I;\nvector<Node> J;\nRoad Rtemp;\nNode Ntemp;\n\nRoad* MAKEROAD(const unsigned short int node1,const unsigned short int node2,const unsigned short int length,const unsigned int distance)\n{\n\tRtemp.node1 = node1;\n\tRtemp.node2 = node2;\n\tRtemp.length = length;\n\tRtemp.distance = distance;\n\treturn &Rtemp;\n}\n\nNode* MAKENODE(const unsigned int distance,const bool decided)\n{\n\tNtemp.distance = distance;\n\tNtemp.decided = decided;\n\treturn &Ntemp;\n}\n\nint main(void)\n{\n\tcin >> N >> M >> K;\n\tint _a,_b,_i;\n\tfor(int i = 0;i < M;i++)\n\t{\n\t\tcin >> _a >> _b >> _i;\n\t\tI.push_back(*MAKEROAD(_a,_b,_i,MAX_INT));\n\t}\n\tfor(int i = 0;i < K;i++)\n\t{\n\t\tcin >> _a;\n\t\tI.push_back(*MAKEROAD(0,_a,0,MAX_INT));\n\t}\n\tfor(int i = 0;i < N+1;i++)\n\t{\n\t\tJ.push_back(*MAKENODE(MAX_INT,false));\n\t}\n\tJ.begin()->distance = 0;\n\tint mindist = 0;\n\tauto mindist_itr = J.begin();\n\tint mindist_i = 0;\n\tbool chg = false;\n\twhile(true)\n\t{\n\t\tmindist = MAX_INT;\n\t\tchg = false;\n\t\tfor(auto itr = J.begin();itr < J.end();itr++)\n\t\t{\n\t\t\tif(!(itr->decided) && itr->distance < mindist)\n\t\t\t{\n\t\t\t\tmindist_itr = itr;\n\t\t\t\tchg = true;\n\t\t\t}\n\t\t}\n\t\tif(!chg)\n\t\t\tbreak;\n\t\telse\n\t\t{\n\t\t\tmindist_itr->decided = true;\n\t\t\tmindist_i = mindist_itr - J.begin();\n\t\t\tfor(auto itr = I.begin();itr < I.end();itr++)\n\t\t\t{\n\t\t\t\tif(itr->node1 == mindist_i)\n\t\t\t\t{\n\t\t\t\t\tif(J[itr->node2].distance > J[mindist_i].distance + itr->length)\n\t\t\t\t\t{\n\t\t\t\t\t\tJ[itr->node2].distance = J[mindist_i].distance + itr->length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(itr->node2 == mindist_i)\n\t\t\t\t{\n\t\t\t\t\tif(J[itr->node1].distance > J[mindist_i].distance + itr->length)\n\t\t\t\t\t{\n\t\t\t\t\t\tJ[itr->node1].distance = J[mindist_i].distance + itr->length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(auto itr = I.begin();itr < I.end();itr++)\n\t{\n\t\t_a = J[itr->node1].distance + J[itr->node2].distance + itr->length;\n\t\tif(_a % 2 == 1)\n\t\t\t_a++;\n\t\titr->distance = _a / 2;\n\t}\n\tunsigned int result = 0;\n\tfor(auto itr = I.begin();itr < I.end();itr++)\n\t{\n\t\tresult = max(result,itr->distance);\n\t}\n\tfor(auto itr = J.begin();itr < J.end();itr++)\n\t{\n\t\tresult = max(result,itr->distance);\n\t}\n\tcout << result << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 3010\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nstruct Edge {\n    int to, cost;\n    Edge (int to, int cost) :\n        to(to), cost(cost) {}\n};\n\nint N, M, K;\nvector<Edge> G[MAX];\nint d[MAX];\n\nvoid dijkstra(int src)\n{\n    d[src] = 0;\n\n    priority_queue<pii, vector<pii>, greater<pii>> pq;\n    pq.push(pii(0, src));\n\n    while (!pq.empty()) {\n        pii p = pq.top(); pq.pop();\n        int v = p.second;\n\n        for (int i = 0; i < (int)G[v].size(); i++) {\n            Edge &e = G[v][i];\n            if (d[v] + e.cost < d[e.to]) {\n                d[e.to] = d[v] + e.cost;\n                pq.push(pii(d[e.to], e.to));\n            }\n        }\n    }  \n}\n\nint main()\n{\n    cin >> N >> M >> K;\n    for (int i = 0; i < M; i++) {\n        int a, b, l;\n        cin >> a >> b >> l;\n        a--; b--;\n        G[a].push_back(Edge(b, l));\n        G[b].push_back(Edge(a, l));\n    }\n\n    fill(d, d + MAX, INF);\n    \n    int src;\n    for (int i = 0; i < K; i++) {\n        cin >> src; src--;\n        dijkstra(src);\n    }\n    \n    int res = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < (int)G[i].size(); j++) {\n            int k = G[i][j].to;\n            int C = G[i][j].cost;            \n            for (double c = 0; c <= C; c += 0.5) {\n                int cc = ceil(c), cc2 = floor(c);\n                res = max(res, min(d[i] + cc, d[k] + (C - cc2)));\n            }\n        }\n    }\n\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nstruct edge{\n  int src,dst,cost;\n  edge(int src,int dst,int cost):src(src),dst(dst),cost(cost){}\n};\n\nstruct state{\n  int cur;\n  long long cost;\n  state(int cur, long long cost):cur(cur),cost(cost){}\n  bool operator>(const state &t)const{\n    return cost > t.cost;\n  }\n};\n\ntypedef vector<edge> edges;\ntypedef vector<edges> graph;\nconst int N = 3010;\nconst long long inf = 1LL<<58;\n\nvoid dijkstra(const graph &g, int k, int shop[], long long A[])\n{\n  priority_queue<state,vector<state>,greater<state> > q;\n  for(int i = 0; i < k; ++i){\n    state init(shop[i],0);\n    q.push(init);\n  }\n\n  while(!q.empty()){\n    state cst = q.top();\n    q.pop();\n\n    for(int i = 0; i < (int)g[cst.cur].size(); ++i){\n      // int src = g[cst.cur][i].src;\n      int dst = g[cst.cur][i].dst;\n      int w   = g[cst.cur][i].cost;\n      if( A[dst] > cst.cost + w ){\n        A[dst] = cst.cost + w;\n        q.push( state( dst, cst.cost + w ) );\n      }\n    }\n  }\n}\n\nint main()\n{\n  int n,m,k;\n  while(cin>>n>>m>>k){\n    if(n==0&&m==0&k==0)break;\n\n    long long A[N];\n    graph g(n);\n    static int adj[N][N];\n    for(int i = 0; i < n; ++i){\n      A[i] = inf;\n      for(int j = 0; j < n; ++j){\n        adj[i][j] = 0;\n      }\n    }\n    for(int i = 0; i < m; ++i){\n      int a,b,c;\n      cin >> a >> b >> c;\n      --a;--b;\n      adj[a][b] = adj[b][a] = c;\n      g[a].push_back(edge(a,b,c));\n      g[b].push_back(edge(b,a,c));\n    }\n    int shop[N];\n    for(int i = 0; i < k; ++i){\n      cin >> shop[i];\n      --shop[i];\n      A[shop[i]] = 0;\n    }\n\n    dijkstra(g,k,shop,A);\n\n    double res = 0;\n    for(int i = 0; i < n; ++i){\n      for(int j = i+1; j < n; ++j){\n        if( adj[i][j] > 0 ){\n          int a = A[i];\n          int b = A[j];\n          if( b < a ) swap(a,b);\n          //cout << i << ' ' << j << ' ' << a << ' ' << b << ' ' << ((adj[i][j]+ a -b)/2. + b) << endl; \n          res = max( res, (adj[i][j]+ a -b)/2. + b);\n        }\n      }\n    }\n    \n    printf(\"%.0lf\\n\", res+0.499999999);\n    \n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<functional>\n#include<utility>\n#define MP make_pair\nusing namespace std;\ntypedef pair<int, int> PII;\ntypedef vector<PII> VP;\ntypedef priority_queue<PII, VP, greater<PII> > LOWQ;\n\nint n, m, k;\nint a[100000], b[100000], l[100000];\nint s[1000];\n\nLOWQ stock;\nVP road[3001];\nbool checked[3001];\nbool shop[3001];\nint dist[3001];\n\nint ans = 0;\n\nvoid dijk()\n{\n  for(int i = 0; i < m; i++){\n    road[a[i]].push_back(MP(l[i], b[i]));\n    road[b[i]].push_back(MP(l[i], a[i]));\n  }\n  \n  for(int i = 0; i < k; i++){\n    stock.push(MP(0, s[i]));\n    checked[s[i]] = shop[s[i]] = true;\n  }\n\n  while(!stock.empty()){\n    PII now = stock.top();\n    stock.pop();\n    if(!checked[now.second] || (shop[now.second] && !now.first)){\n      checked[now.second] = true;\n      dist[now.second] = now.first;\n      for(int i = 0; i < road[now.second].size(); i++)\n\tif(!checked[road[now.second][i].second])\n\t  stock.push(MP(dist[now.first] + road[now.second][i].first, road[now.second][i].second));\n    }\n  }\n  return;\n}  \n\nint main()\n{\n  cin >> n >> m >> k;\n  for(int i = 0; i < m; i++)\n    cin >> a[i] >> b[i] >> l[i];\n  for(int i = 0; i < k; i++)\n    cin >> s[i];\n\n  dijk();\n  \n  for(int i = 1; i <= n; i++)\n    ans = max(ans, dist[i]);\n\n  for(int i = 0; i < m; i++){\n    int diff = abs(dist[a[i]] - dist[b[i]]);\n    if(diff < l[i]){\n      int far = l[i] - diff;\n      if(far % 2)\n\tfar = far / 2 + 1;\n      else\n\tfar /= 2;\n\n      ans = max(ans, far + max(dist[a[i]], dist[b[i]]));\n    }\n  }\n\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nint N, M, K;\n\nstruct edge\n{\n  int to, cost;\n  edge(int t, int c)\n  {\n    to = t; cost = c;\n  }\n};\n\ntypedef pair<int, int> P;\nvector<edge> edges[1000];\nint d[1000];\n\nint dijkstra(vector<int> sts)\n{\n  priority_queue<P, vector<P>, greater<P> > queue;\n  for(auto st : sts)\n  {\n    d[st] = 0;\n    queue.push(make_pair(0, st));\n  }\n  while(!queue.empty())\n  {\n    auto p = queue.top(); queue.pop();\n    int v = p.second;\n    if(d[v] < p.first)\n      continue;\n    for(auto e : edges[v])\n    {\n      if(d[e.to] > d[v] + e.cost)\n      {\n        d[e.to] = d[v] + e.cost;\n        queue.push(make_pair(d[e.to], e.to));\n      }\n    }\n  }\n}\n\nint main()\n{\n  fill(d, d + 1000, 1000000000);\n  cin >> N >> M >> K;\n  for(int i = 0; i < M; i++)\n  {\n    int a, b, l;\n    cin >> a >> b >> l;\n    a--; b--;\n    edges[a].push_back(edge(b, l));\n    edges[b].push_back(edge(a, l));\n  }\n\n  vector<int> sts;\n  for(int i = 0; i < K; i++)\n  {\n    int a;\n    cin >> a;\n    sts.push_back(--a);\n  }\n  dijkstra(sts);\n  int ans = 0;\n  for(int v = 0; v < N; v++)\n  {\n    for(auto e : edges[v])\n    {\n      ans = max(ans, (int)((d[v] + d[e.to] + e.cost) / 2.0 + 0.5));\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nconst int INF = 1e9;\nconst int MAX_N = 3010, MAX_E = 10000;\nint n, m; //????????° ???????????¬??°\nvector<pair<int, int> > G[MAX_N];//??°???????????¨?????£??\\????????? fi:to se:cost\nint d[MAX_N]; //s?????????????????????\ntypedef pair<int, int> P;//first??????????????¢,second??????????????????\nint k; vector<int> shop;//???????¨????\n\nvoid dijkstra(void){\n\tpriority_queue<P, vector<P>, greater<P> > que;//first????°?????????????\n    rep(i, n)d[i] = INF;//?????????\n    \n    //k????????????????????°????????????\n    for(auto i : shop){\n    \td[i] = 0;\n    \tque.push(make_pair(0, i));\n    }\n  \n    while(!que.empty()){\n       \tauto p = que.top(); que.pop();\n       \tint v = p.second;\n       \tif(d[v] < p.first) continue;\n       \tfor(auto e : G[v]){//e.fi:??£??\\??????????????????????????? e.se:?????????????????§????????????\n       \t\tif(d[e.first] > d[v] + e.second){//???????????¢?????´??°???????????¨???\n       \t\t\td[e.first] = d[v] + e.second;\n       \t\t\tque.push(make_pair(d[e.first], e.first));\n       \t\t}\n       \t}\n    }\n}\n\nint main(void){\n    cin >> n >> m >> k;\n    rep(i, m){\n        int a, b, l; cin >> a >> b >> l;\n        a--; b--;\n       \tG[a].push_back(make_pair(b, l)); G[b].push_back(make_pair(a, l));\n    }\n    rep(i, k){\n    \tint s; cin >> s; s--;\n    \tshop.push_back(s);\n    }\n    dijkstra();//????????????????????????????°?????????????\n    //?????????????????¶????????????????°?????????????\n    double ans = 0.0;\n    //x-y???????????????????????????\n    rep(i, n) ans = max(ans, (double)d[i]);\n    //??????????????????????????¢????????¨???????????????????????¶???????????´?????????????????????????????¢?????????\n   \tfor (int x = 0; x < n; ++x){\n   \t\tfor(auto y : G[x]){\n   \t\t\tif(d[x] == 0 || d[y.first] == 0) continue;\n   \t\t\tdouble tmp = (d[x] + d[y.first] + y.second) / 2.0;//+1????????¨?????\\??¨\n   \t\t\tans = max(tmp, ans);\n   \t\t}\n   \t}\n   \tcout << round(ans) << endl;\n   \treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\nconst int inf = (int)1e9;\nint n, m, k;\nint ans = inf;\nvector<int> dist;\nvector<vector<pair<int, int> > > graph;\nvector<pair<pair<int, int>, int> > edge;\nscanf(\"%d%d%d\", &n, &m, &k);\ndist.resize(n, inf);\nfor(int i = 0; i < m; ++i) {\nint a, b, l;\nscanf(\"%d%d%d\", &a, &b, &l);\na -= 1, b -= 1;\nedge.push_back(make_pair(make_pair(a, b), l));\ngraph[a].push_back(make_pair(b, l));\ngraph[b].push_back(make_pair(a, l));\n}\nfor(int i = 0; i < k; ++i) {\nint s;\nscanf(\"%d\", &s);\ns -= 1;\npriority_queue<pair<int, int> > q;\nq.push_back(make_pair(0, s));\nwhile(!q.empty()) {\nint v = q.top().second;\nint c = -q.top().first;\nq.pop();\nif(dist[v] < c)\ncontinue;\ndist[v] = c;\nfor(int i = 0; i < graph[v].size(); ++i) {\nint w = graph[v][i].second;\nint d = graph[v][i].second + c;\nq.push(make_pair(-d, w));\n}\n}\n}\nfor(int i = 0; i < m; ++i) {\nint a = edge[i].first.first;\nint b = edge[i].first.second;\nint l = edge[i].second;\nif(dist[a] > dist[b])\nswap(a, b);\nint cost;\nif(dist[a] + l <= dist[b])\ncost = dist[b];\nelse\ncost = (l - (dist[b] - dist[a]) + 1) / 2;\nans = max(ans, cost);\n}\nprintf(\"%d\\n\", ans);\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint main(void) {\n\tll n, m, k;\n\tcin>>n>>m>>k;\n\tvector<vector<P> > l(n);\n\tREP(i, m) {\n\t\tll a, b, c;\n\t\tcin>>a>>b>>c;\n\t\t--a;\n\t\t--b;\n\t\tl[a].pb(P(b, c));\n\t\tl[b].pb(P(a, c));\n\t}\n\tvector<ll> shop(k);\n\tREP(i, k) {\n\t\tll gomi;\n\t\tcin>>gomi;\n\t\t--gomi;\n\t\tshop[i] = gomi;\n\t}\n\tpriority_queue<P> que;\n\tvector<ll> dir(n, INF * INF);\n\tREP(i, k) {\n\t\tque.push(P(0, shop[i]));\n\t\tdir[shop[i]] = 0;\n\t}\n\twhile(!que.empty()) {\n\t\tP np = que.top();\n\t\tque.pop();\n\t\tif(dir[np.second] != np.first) continue;\n\t\tREP(i, l[np.second].size()) {\n\t\t\tif(dir[l[np.second][i].first] > dir[np.second] + l[np.second][i].second) {\n\t\t\t\tdir[l[np.second][i].first] = dir[np.second] + l[np.second][i].second;\n\t\t\t\tque.push(P(dir[l[np.second][i].first], l[np.second][i].first));\n\t\t\t}\n\t\t}\n\t}\n\tll res = 0;\n\tREP(i, n) {\n\t\tREP(j, l[i].size()) {\n\t\t\tll k = (ll)(double(dir[l[i][j].first] - dir[i] + l[i][j].second) / 2 + 0.5);\n\t\t\tres = max(res, dir[i] + k);\n\t\t}\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PA;\n#define INF (1<<30)\nint main(){\n  int n,m,k,a,b,l;\n  vector<PA> vec[3001];\n  scanf(\"%d %d %d\",&n,&m,&k);\n  for(int i=0;i<m;i++){\n    scanf(\"%d %d %d\",&a,&b,&l);\n    vec[a].push_back(PA(l,b));\n    vec[b].push_back(PA(l,a));\n  }\n  int s;\n  int min_cost[3001];\n  fill(min_cost,min_cost+3001,INF);\n  priority_queue<PA,vector<PA>,greater<PA> > pq;\n  for(int i=0;i<k;i++){\n    scanf(\"%d\",&s);\n    min_cost[s] = 0;\n    pq.push(PA(0,s));\n    while(!pq.empty()){\n      PA p = pq.top();\n      pq.pop();\n      for(int j=0;j<vec[p.second].size();j++){\n\tint next_cost = p.first + vec[p.second][j].first;\n\tint next_to = vec[p.second][j].second;\n\tif(min_cost[next_to] > next_cost){\n\t  min_cost[next_to] = next_cost;\n\t  pq.push(PA(next_cost,next_to));\n\t}\n      } \n    }\n  }\n  int ans = 0;\n  for(int i=1;i<=n;i++){\n    ans = max(ans,min_cost[i]);\n    for(int j=0;j<vec[i].size();j++){\n      if(abs(min_cost[i]-min_cost[vec[i][j].second]) != vec[i][j].first){\n\tans = max(ans,(min_cost[i]+min_cost[vec[i][j].second]+vec[i][j].first+1)/2);\n      }\n    }\n  }\n  printf(\"%d\\n\",ans);\n  return (0);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int> pii;\n\nint main(){\n    int n, m, k;\n    cin >> n >> m >> k;\n    vector<pii> v[n+1];\n    vector<pair<pii,int>> vp;\n    for(int i = 0; i < m; i++){\n        int a, b, c;\n        cin >> a >> b >> c;\n        vp.push_back({{a,b},c});\n        v[a].push_back({b,c});\n        v[b].push_back({a,c});\n    }\n    for(int i = 0; i < k; i++){\n        int x;  cin >> x;\n        v[0].push_back({x,0});\n    }\n    vector<int> dp(n+1, 1<<30);\n    dp[0] = 0;\n    priority_queue<pii> pq;\n    pq.push({-0, 0});\n    while(!pq.empty()){\n        pii p = pq.top();   pq.pop();\n        int pos = p.second, cost = -p.first;\n        if(dp[pos] != cost) continue;\n        for(pii q : v[pos]){\n            int next = q.first;\n            if(dp[next] > dp[pos]+q.second){\n                dp[next] = dp[pos]+q.second;\n                pq.push({-dp[next], next});\n            }\n        }\n    }\n    int ret = 0;\n    for(int i = 0; i < m; i++){\n        int a = vp[i].first.first, b = vp[i].first.second, c = vp[i].second;\n        ret = max(ret, (dp[a]+dp[b]+c+1)/2);\n    }\n    cout << ret << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3002\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<P> G[N];\nbool num[N];\nint n,m,K;\n\ndouble dijkstra(){\n  int D[N];\n  for(int i=0;i<N;i++) D[i] = 1e9;\n  \n  vector<int>pre[N];\n  priority_queue<PP,vector<PP>,greater<PP> >Q;\n  \n  for(int i=0;i<N;i++)\n    if(num[i]) {\n      Q.push(PP(0,P(i,i)));\n      D[i] = 0;\n      pre[i].push_back(i);\n    }\n  \n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first;\n    int pos = t.second.first;\n    int start = t.second.second;\n\n    if(D[pos]<cost) continue;\n    pre[pos].push_back(start);\n    \n    for(int i=0;i<G[pos].size();i++){\n      int npos = G[pos][i].first;\n      int ncost = cost+G[pos][i].second;\n      if(D[npos]<ncost) continue;\n      Q.push(PP(ncost,P(npos,start)));\n      D[npos] = ncost;\n    }\n  }\n  \n\n  double res = 0;\n  for(int i=0;i<n;i++){\n    if(pre[i].size()>=2)res = max(res,(double)D[i]);\n    \n    for(int j=0;j<G[i].size();i++){\n      int npos = G[i][j].first;\n      int ncost = G[i][j].second;\n      if(npos == pre[i][0]){\n\tif(abs(D[i]-D[npos])!=ncost) res = max(res,(D[i]+D[npos]+ncost)/2.0);\n      }\n      else res = max(res,(D[i]+D[npos]+ncost)/2.0);\n    }\n  }\n  return res;\n  \n}\n\nint main(){\n  \n  cin>>n>>m>>K;\n  for(int i=0,a,b,c;i<m;i++){\n    cin>>a>>b>>c;\n    G[a-1].push_back(P(b-1,c));\n    G[b-1].push_back(P(a-1,c));\n  }\n\n  for(int i=0,a;i<K;i++)cin>>a,num[a-1]=1;\n  printf(\"%.0f\\n\",dijkstra());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdint>\n#include <fstream>\n\nusing namespace std;\n\n#define MAX_N 3000\n#define MAX_M 100000\n#define UNDEF UINT16_MAX\n\nuint16_t N,M,K,I[MAX_M*2][3],D[MAX_N],LS[MAX_N],RC[MAX_M];\nbool S[MAX_N];\nuint16_t dist[MAX_N];\nbool decided[MAX_N],updated;\n\nuint16_t min(uint16_t a,uint16_t b)\n{\n\tif(a < b)\n\t\treturn a;\n\telse\n\t\treturn b;\n}\n\nuint16_t max(uint16_t a,uint16_t b)\n{\n\tif(a > b)\n\t\treturn a;\n\telse\n\t\treturn b;\n}\n\nint main(void)\n{\n\tfor(int i = 0;i < MAX_N;i++)\n\t{\n\t\tD[i] = UNDEF;\n\t\tS[i] = false;\n\t\tLS[i] = UNDEF;\n\t\tI[i*2][0] = UNDEF;\n\t\tI[i*2][1] = UNDEF;\n\t\tI[i*2][2] = UNDEF;\n\t\tI[(i*2)+1][0] = UNDEF;\n\t\tI[(i*2)+1][1] = UNDEF;\n\t\tI[(i*2)+1][2] = UNDEF;\n\t}\n\tifstream ifs(\"in.txt\");\n\tifs >> N >> M >> K;\n\tint a,b,n;\n\tfor(int i = 0;i < MAX_M;i++)\n\t\tRC[i] = UNDEF;\n\tfor(int i = 0;i < M;i++)\n\t{\n\t\tifs >> a >> b >> n;\n\t\ta--;\n\t\tb--;\n\t\tI[(i*2)][0] = a;\n\t\tI[(i*2)][1] = b;\n\t\tI[(i*2)][2] = n;\n\t\tI[(i*2)+1][0] = b;\n\t\tI[(i*2)+1][1] = a;\n\t\tI[(i*2)+1][2] = n;\n\t}\n\tfor(int i = 0;i < K;i++)\n\t{\n\t\tifs >> n;\n\t\tn--;\n\t\tS[n] = true;\n\t\tLS[i] = n;\n\t}\n\tfor(int e = 0;e < K;e++)\n\t{\n\t\tfor(int ii = 0;ii < MAX_N;ii++)\n\t\t{\n\t\t\tdist[ii] = UNDEF;\n\t\t\tdecided[ii] = false;\n\t\t}\n\t\tdist[LS[e]] = 0;\n\t\tbool loop = true;\n\t\twhile(loop)\n\t\t{\n\t\t\tupdated = false;\n\t\t\tint minn = UNDEF;\n\t\t\tint mini = -1;\n\t\t\tfor(int ii = 0;ii < N;ii++)\n\t\t\t{\n\t\t\t\tif(minn >= dist[ii] && !decided[ii])\n\t\t\t\t{\n\t\t\t\t\tmini = ii;\n\t\t\t\t\tminn = dist[ii];\n\t\t\t\t\tupdated = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdecided[mini] = true;\n\t\t\tif(updated)\n\t\t\t{\n\t\t\t\tfor(int ii = 0;ii < M*2;ii++)\n\t\t\t\t{\n\t\t\t\t\tif(I[ii][0] == mini && I[ii][2] + dist[I[ii][0]] < dist[I[ii][1]])\n\t\t\t\t\t{\n\t\t\t\t\t\tdist[I[ii][1]] = I[ii][2] + dist[I[ii][0]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tloop = false;\n\t\t\t}\n\t\t}\n\t\tfor(int ii = 0;ii < N;ii++)\n\t\t{\n\t\t\tif(dist[ii] == UNDEF)\n\t\t\t{\n\t\t\t\texit(-1);\n\t\t\t}\n\t\t\tD[ii] = min(D[ii],dist[ii]);\n\t\t}\n\t}\n\tfor(int i = 0;i < M;i++)\n\t{\n\t\tn = (D[I[i*2][0]] + D[I[i*2][1]] + I[i*2][2]);\n\t\tif(n % 2)\n\t\t\tn = n / 2;\n\t\telse\n\t\t\tn = (n + 1) / 2;\n\t}\n\tuint16_t result = 0;\n\tfor(int i = 0;i < N;i++)\n\t\tresult = max(D[i],result);\n\tfor(int i = 0;i < M;i++)\n\t\tresult = max(RC[i],result);\n\tcout << result << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint main(){\n\tint i,j;\n\tint n,m,l;;\n\tscanf(\"%d%d%d\",&n,&m,&l);\n\tvector<pair<int,int> > a[3000];\n\tfor(i=0;i<m;++i){\n\t\tint p,q,r;\n\t\tscanf(\"%d%d%d\",&p,&q,&r);\n\t\t--p;\n\t\t--q;\n\t\ta[p].push_back(make_pair(q,r));\n\t\ta[q].push_back(make_pair(p,r));\n\t}\n\tint b[3000];\n\tmemset(b,0x7f,sizeof(b));\n\tpriority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > c;\n\tfor(i=0;i<l;++i){\n\t\tint p;\n\t\tscanf(\"%d\",&p);\n\t\t--p;\n\t\tb[p]=0;\n\t\tc.push(make_pair(0,p));\n\t}\n\twhile(!c.empty()){\n\t\tint p,q;\n\t\tp=c.top().first;\n\t\tq=c.top().second;\n\t\tc.pop();\n\t\tfor(i=0;i<(int)a[q].size();++i){\n\t\t\tif(b[a[q][i].first]<=p+a[q][i].second)\n\t\t\t\tcontinue;\n\t\t\tb[a[q][i].first]=p+a[q][i].second;\n\t\t\tc.push(make_pair(p+a[q][i].second,a[q][i].first));\n\t\t}\n\t}\n\tint mx=0;\n\tfor(i=0;i<n;++i)\n\t\tfor(j=0;j<(int)a[i].size();++j)\n\t\t\tmx=max(mx,max(b[i],b[a[i][j].first])+(a[i][j].second-abs(b[i]-b[a[i][j].first])+1)/2);\n\tprintf(\"%d\\n\",mx);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\nusing namespace std;\n\n#define N 3002\n#define INF 100000000\n\nstruct Edge {\n\tint to, cost;\n\tEdge(int t, int c) : to(t), cost(c) {}\n\tEdge() {};\n};\n\ntypedef vector<Edge> Graph;\n\nint cost[N];\nGraph g[N];\nvector<int> sv;\ntypedef pair<int, int> P;\n\nvoid dijkstra(int s) {\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tcost[s] = 0; q.push(P(0,s));\n\twhile(!q.empty()) {\n\t\tint p = q.top().first, v = q.top().second; q.pop();\n\t\tif(cost[v]<p) continue;\n\t\tfor(int i=0; i<(signed)g[v].size(); ++i) {\n\t\t\tEdge e = g[v][i];\n\t\t\tif(cost[v]+e.cost<cost[e.to]) {\n\t\t\t\tcost[e.to] = cost[v]+e.cost;\n\t\t\t\tq.push(P(cost[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\n#define max(a,b) (a>b?a:b)\n#define min(a,b) (a>b?b:a)\n\nint main() {\n\tint n, m, k, a, b, l, s;\n\tdouble ans = 0.0;\n\tcin >> n >> m >> k;\n\tfor(int i=1; i<=n; ++i) cost[i] = INF;\n\tfor(int i=0; i<m; ++i) {\n\t\tcin >> a >> b >> l;\n\t\tg[a].push_back(Edge(b,l));\n\t\tg[b].push_back(Edge(a,l));\n\t}\n\tfor(int i=0; i<k; ++i) {\n\t\tcin >> s;\n\t\tdijkstra(s);\n\t}\n\tfor(int i=1; i<=n; ++i) {\n\t\tfor(int j=0; j<(signed)g[i].size(); ++j) {\n\t\t\tif(i<g[i][j].to) continue;\n\t\t\ta = cost[i]; b = cost[g[i][j].to]; l = g[i][j].cost;\n\t\t\tif(a>=b+l || b>=a+l) {\n\t\t\t\tans = max(ans, (double)max(a,b));\n\t\t\t}else {\n\t\t\t\tans = max(ans, (double)(a+b+l)/2.0);\n\t\t\t}\n\t\t}\n\t}\n\tcout << (int)(ans+0.5) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3002\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<P> G[N];\nbool num[N];\nint n,m,K;\n\ndouble dijkstra(){\n  int D[N];\n  for(int i=0;i<N;i++) D[i] = 1e9;\n  \n  vector<int>pre[N];\n  priority_queue<PP,vector<PP>,greater<PP> >Q;\n  for(int i=0;i<n;i++)if(num[i]) Q.push(PP(0,P(i,-1))),D[i] = 0;\n  \n  \n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first;\n    int pos = t.second.first;\n    int ppos = t.second.second;\n    \n    if(D[pos]<cost) continue;\n    if(ppos>=0)pre[pos].push_back(ppos);\n    \n    for(int i=0;i<G[pos].size();i++){\n      int npos = G[pos][i].first;\n      int ncost = cost+G[pos][i].second;\n      if(D[npos]<ncost) continue;\n      Q.push(PP(ncost,P(npos,pos)));\n      D[npos] = ncost;\n    }\n  }\n\n\n  double res = 0;\n  for(int i=0;i<n;i++){\n    res = max(res,D[i]/2.0);\n\n    for(int j=0;j<(int)G[i].size();j++){\n      int npos = G[i][j].first;\n      int ncost = G[i][j].second;\n      int a=(int)((D[i]+D[npos]+ncost)/2.0+0.5);\n      if(a==14608)cout<<i<<\" \"<<npos<<endl;\n      if(a==14608)cout<<*pre[i].begin()<<\" \"<<*pre[npos].begin()<<endl;\n      if((pre[i].size()==1&&pre[i][0]==npos)||\n\t (pre[npos].size()==1&&pre[npos][0]==i))continue;\n      res = max(res,(D[i]+D[npos]+ncost)/2.0);\n    }\n  }\n  return res;\n   \n}\n \nint main(){\n  cin>>n>>m>>K;\n  for(int i=0,a,b,c;i<m;i++){\n    cin>>a>>b>>c;\n    G[a-1].push_back(P(b-1,c));\n    G[b-1].push_back(P(a-1,c));\n  }\n \n  for(int i=0,a;i<K;i++)cin>>a,num[a-1]=1;\n  printf(\"%d\\n\",(int)(dijkstra()+0.5));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define llong long long\n#define pb(a) push_back(a)\n#define INF 999999999\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<llong, llong> LP;\ntypedef pair<int, P> PP;\ntypedef pair<llong, LP> LPP;\n\n//int dy[]={0, 0, 1, -1, 0};\n//int dx[]={1, -1, 0, 0, 0};\n\nstruct edge{\n  int to;\n  double cost;\n};\n\nint n, m, k;\nvector<edge> v[3010];\nvector<int> s;\n\nvector<double> dijkstra(int s){\n  vector<double> d(n, INF);\n  d[s]=0;\n  priority_queue<pair<double, int> > p;\n  p.push(make_pair(0, s));\n  \n  while(!p.empty()){\n    int u=p.top().second;\n    p.pop();\n\n    REP(i, v[u].size()){\n      int to=v[u][i].to;\n      double cost=v[u][i].cost;\n\n      if(d[to]>d[u]+cost){\n\td[to]=d[u]+cost;\n\tp.push(make_pair(-d[to], to));\n      }\n    }\n  }\n\n  return d;\n}\n\nint main(){\n  scanf(\"%d%d%d\", &n, &m, &k);\n  REP(i, m){\n    int from, to;\n    double cost;\n    scanf(\"%d%d%lf\", &from, &to, &cost);\n    v[from-1].push_back((edge){to-1, cost});\n    v[to-1].push_back((edge){from-1, cost});\n  }\n\n  vector<double> dist(n, INF);\n  REP(i, k){\n    int shop;\n    scanf(\"%d\", &shop);\n    vector<double> d;\n    d=dijkstra(shop-1);\n\n    REP(i, n) dist[i]=min(dist[i], d[i]);\n  }\n\n  double ans=0;\n  REP(i, n){\n    ans=max(dist[i], ans);\n    REP(j, v[i].size()){\n      ans=max(ans, (dist[i]+dist[v[i][j].to]+v[i][j].cost+1)/2);\n    }\n  }\n\n  cout << (int)ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(x) __builtin_ctz(x)\n\n// #define DEBUG\n\n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n\nusing namespace std;\nusing ll=long long;\n\nconst int nmax=3010;\nusing node=struct{int to,cost;};\nvector<node> graph[nmax];\n\nconst int inf=1<<28;\nusing tii=tuple<int,int>;\nint dist[nmax];\n\nint main(void){\n\tint n,m,k;\n\tcin >> n >> m >> k;\n\trep(i,n) dist[i]=inf;\n\t\n\trep(i,m){\n\t\tint a,b,c;\n\t\tcin >> a >> b >> c;\n\t\tgraph[a-1].push_back({b-1,c});\n\t\tgraph[b-1].push_back({a-1,c});\n\t}\n\n\n\tpriority_queue<tii,vector<tii>,greater<tii>> q;\n\trep(loop,k){\n\t\tint v;\n\t\tcin >> v;\n\t\tdist[v-1]=0;\n\t\tq.push(tii(0,v-1));\n\t}\n\n\twhile(!q.empty()){\n\t\tint v,cost;\n\t\ttie(cost,v)=q.top();q.pop();\n\t\tfor(auto &e:graph[v]){\n\t\t\tint nv=e.to,ncost=cost+e.cost;\n\t\t\tif(dist[nv]>ncost){\n\t\t\t\tdist[nv]=ncost;\n\t\t\t\tq.push(tii(ncost,nv));\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans=0;\n\trep(i,n){\n\t\tans=max(ans,dist[i]);\n\t\tfor(auto &e:graph[i]){\n\t\t\tint a=i,b=e.to,l=e.cost;\n\t\t\tif(dist[a]>dist[b]) continue;\n\t\t\tif(dist[a]+l<=dist[b]) continue;\n\t\t\tif(dist[b]+l<=dist[a]) continue;\n\t\t\tint add=(l+(dist[b]-dist[a])+1)/2;\n\t\t\tans=max(ans,dist[a]+add);\n\t\t}\n\t}\n\t//  dist[a]+a=dist[b]+b (a+b)==l \n\t//        a-b=dist[b]-dist[a] (a+b)==l \n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nint N, M, K;\n\nstruct edge\n{\n  int to, cost;\n  edge(int t, int c)\n  {\n    to = t; cost = c;\n  }\n};\n\ntypedef pair<int, int> P;\nvector<edge> edges[10000];\nint d[3000];\n\nint dijkstra(vector<int> sts)\n{\n  priority_queue<P, vector<P>, greater<P> > queue;\n  for(auto st : sts)\n  {\n    d[st] = 0;\n    queue.push(make_pair(0, st));\n  }\n  while(!queue.empty())\n  {\n    auto p = queue.top(); queue.pop();\n    int v = p.second;\n    if(d[v] < p.first)\n      continue;\n    for(auto e : edges[v])\n    {\n      if(d[e.to] > d[v] + e.cost)\n      {\n        d[e.to] = d[v] + e.cost;\n        queue.push(make_pair(d[e.to], e.to));\n      }\n    }\n  }\n}\n\nint main()\n{\n  fill(d, d + 3000, 1000000000);\n  cin >> N >> M >> K;\n  for(int i = 0; i < M; i++)\n  {\n    int a, b, l;\n    cin >> a >> b >> l;\n    a--; b--;\n    edges[a].push_back(edge(b, l));\n    edges[b].push_back(edge(a, l));\n  }\n\n  vector<int> sts;\n  for(int i = 0; i < K; i++)\n  {\n    int a;\n    cin >> a;\n    sts.push_back(--a);\n  }\n  dijkstra(sts);\n  int ans = 0;\n  for(int v = 0; v < N; v++)\n  {\n    for(auto e : edges[v])\n    {\n      ans = max(ans, (int)((d[v] + d[e.to] + e.cost) / 2.0 + 0.5));\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <map>\n#include <sstream>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <iterator>\n#include <stack>\n#include <list>\nusing namespace std;\nconst int INF=1000000000;\ntypedef long long int lli;\ntypedef pair<int,int> P;\n\nconst int MAX_V=5001;\nint cost[MAX_V][MAX_V];\nint d[MAX_V];\nbool used[MAX_V];\nvector<int> mall;\nint shortest[MAX_V];\n\nint abs(int x){\n\tif(x<0) return -x;\n\telse return x;\n}\n\nint main(){\n\tint V,E,K;\n\tcin >> V >> E >> K;\n\tfor(int i=1; i<=V; ++i){\n\t\tfor(int j=1; j<=V; ++j){\n\t\t\tif(i==j) {\n\t\t\t\tcost[i][j]=0;\n\t\t\t} else {\n\t\t\t\tcost[i][j]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<E; ++i){\n\t\tint a,b,l;\n\t\tcin >> a >> b >> l;\n\t\tcost[a][b]=l;\n\t\tcost[b][a]=l;\n\t}\n\tfor(int i=0; i<K; ++i){\n\t\tint tmp;\n\t\tcin >> tmp;\n\t\tmall.push_back(tmp);\n\t}\n\tfill(shortest,shortest+V+1,INF);\n\tfor(int i=0; i<K; ++i){\n\t\tfill(d,d+V+1,INF);\n\t\tfill(used,used+V+1,false);\n\t\td[mall[i]]=0;\n\t\twhile(true){\n\t\t\tint v=-1;\n\t\t\tfor(int u=1; u<=V; ++u){\n\t\t\t\tif(!used[u]&&(v==-1||d[u]<d[v])) v=u;\n\t\t\t}\n\t\t\t\n\t\t\tif(v==-1) break;\n\t\t\tused[v]=true;\n\t\t\t\n\t\t\tfor(int u=1; u<=V; ++u){\n\t\t\t\td[u]=min(d[u],d[v]+cost[v][u]);\n\t\t\t\tif(shortest[u]>d[u]) shortest[u]=d[u];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans=-1;\n\tfor(int i=1; i<=V; ++i){\n\t\tfor(int j=1; j<=V; ++j){\n\t\t\tif(cost[i][j]!=INF){\n\t\t\t\tint tmp=abs((shortest[j]+shortest[i]+cost[i][j]+1)/2);\n\t\t\t\tans=max(ans,tmp);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdint>\n#include <fstream>\n\nusing namespace std;\n\n#define MAX_N 3000\n#define MAX_M 100000\n#define UNDEF UINT32_MAX\n\nuint32_t N,M,K,I[MAX_M*2][3],D[MAX_N],LS[MAX_N],RC[MAX_M];\nbool S[MAX_N];\nuint32_t dist[MAX_N];\nbool decided[MAX_N],updated;\n\nuint32_t min(uint32_t a,uint32_t b)\n{\n\tif(a < b)\n\t\treturn a;\n\telse\n\t\treturn b;\n}\n\nuint32_t max(uint32_t a,uint32_t b)\n{\n\tif(a > b)\n\t\treturn a;\n\telse\n\t\treturn b;\n}\n\nint main(void)\n{\n\tfor(int i = 0;i < MAX_N;i++)\n\t{\n\t\tD[i] = UNDEF;\n\t\tS[i] = false;\n\t\tLS[i] = UNDEF;\n\t\tI[i*2][0] = UNDEF;\n\t\tI[i*2][1] = UNDEF;\n\t\tI[i*2][2] = UNDEF;\n\t\tI[(i*2)+1][0] = UNDEF;\n\t\tI[(i*2)+1][1] = UNDEF;\n\t\tI[(i*2)+1][2] = UNDEF;\n\t}\n\tcin >> N >> M >> K;\n\tint a,b,n;\n\tfor(int i = 0;i < MAX_M;i++)\n\t\tRC[i] = UNDEF;\n\tfor(int i = 0;i < M;i++)\n\t{\n\t\tcin >> a >> b >> n;\n\t\ta--;\n\t\tb--;\n\t\tI[(i*2)][0] = a;\n\t\tI[(i*2)][1] = b;\n\t\tI[(i*2)][2] = n;\n\t\tI[(i*2)+1][0] = b;\n\t\tI[(i*2)+1][1] = a;\n\t\tI[(i*2)+1][2] = n;\n\t}\n\tfor(int i = 0;i < K;i++)\n\t{\n\t\tcin >> n;\n\t\tn--;\n\t\tS[n] = true;\n\t\tLS[i] = n;\n\t}\n\tfor(int e = 0;e < K;e++)\n\t{\n\t\tfor(int ii = 0;ii < MAX_N;ii++)\n\t\t{\n\t\t\tdist[ii] = UNDEF;\n\t\t\tdecided[ii] = false;\n\t\t}\n\t\tdist[LS[e]] = 0;\n\t\tbool loop = true;\n\t\twhile(loop)\n\t\t{\n\t\t\tupdated = false;\n\t\t\tint minn = UNDEF;\n\t\t\tint mini = -1;\n\t\t\tfor(int ii = 0;ii < N;ii++)\n\t\t\t{\n\t\t\t\tif(minn >= dist[ii] && !decided[ii])\n\t\t\t\t{\n\t\t\t\t\tmini = ii;\n\t\t\t\t\tminn = dist[ii];\n\t\t\t\t\tupdated = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdecided[mini] = true;\n\t\t\tif(updated)\n\t\t\t{\n\t\t\t\tfor(int ii = 0;ii < M*2;ii++)\n\t\t\t\t{\n\t\t\t\t\tif(I[ii][0] == mini && I[ii][2] + dist[I[ii][0]] < dist[I[ii][1]])\n\t\t\t\t\t{\n\t\t\t\t\t\tdist[I[ii][1]] = I[ii][2] + dist[I[ii][0]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tloop = false;\n\t\t\t}\n\t\t}\n\t\tfor(int ii = 0;ii < N;ii++)\n\t\t{\n\t\t\tif(dist[ii] == UNDEF)\n\t\t\t{\n\t\t\t\texit(-1);\n\t\t\t}\n\t\t\tD[ii] = min(D[ii],dist[ii]);\n\t\t}\n\t}\n\tfor(int i = 0;i < M;i++)\n\t{\n\t\tn = (D[I[i*2][0]] + D[I[i*2][1]] + I[i*2][2]);\n\t\tif(n % 2 == 0)\n\t\t\tn = n / 2;\n\t\telse\n\t\t\tn = (n + 1) / 2;\n\t\tRC[i] = n;\n\t}\n\tuint32_t result = 0;\n\tfor(int i = 0;i < N;i++)\n\t\tresult = max(D[i],result);\n\tfor(int i = 0;i < M;i++)\n\t\tresult = max(RC[i],result);\n\tcout << result << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define s size()\n#define INF 100000000\nint cost[3005][3005];\nint d[3005];\nint maxi[100005]={};\nbool used[3005]={};\nP1 ii[100005];\nint V;\nvoid dijkstra(int s){\n\tfill(d,d+V,INF);\n\td[s]=0;\n\twhile(1){\n\t\tint v=-1;\n\t\tfor(int u=0;u<V;u++){\n\t\t\tif(!used[u] && (v==-1 || d[u]<d[v])){\n\t\t\t\tv=u;\n\t\t\t}\n\t\t}\n\t\tif(v==-1){\n\t\t\tbreak;\n\t\t}\n\t\tused[v]=true;\n\t\tfor(int i=0;i<V;i++){\n\t\t\td[i]=min(d[i],d[v]+cost[v][i]);\n\t\t}\n\t}\n}\nint n,m,k;\nint main(){\n\tscanf(\"%d %d %d\",&n,&m,&k);\n\tfor(int i=0;i<3005;i++){\n\t\tfor(int j=0;j<3005;j++){\n\t\t\tcost[i][j]=INF;\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint w,ww,eu;\n\t\tscanf(\"%d %d %d\",&w,&ww,&eu);\n\t\tii[i]=mp(eu,mp(w,ww));\n\t\tcost[w-1][ww-1]=eu;\n\t\tcost[ww-1][w-1]=eu;\n\t}\n\tint res=0;\n\tfor(int i=0;i<k;i++){\n\t\tint t;\n\t\tscanf(\"%d\",&t);\n\t\tdijkstra(t-1);\n\t\tmemset(used,0,sizeof(used));\n\t\tfor(int j=0;j<m;j++){\n\t\t\tmaxi[j]=max(maxi[j],(ii[j].first+d[ii[j].second.first-1]+d[ii[j].second.second-1]+1)/2);\n\t\t}\n\t}\n\tfor(int j=0;j<m;j++){\n\t\tres=max(res,maxi[j]);\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma warning(disable: 4996)\n#include<cstdio>\n#include<math.h>\n#include<algorithm>\n#include<string.h>\n#include<vector>\n#include<queue>\n\n\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nconst int INF=1001001001;\n\nconst int mod=100000;\n\nstruct road{\n\tint start;\n\tint end;\n\tint length;\n};\n\nvector<road> einfo;\nvector< pair<int,int> > edge[3003];//a?????????b????????????????????????l???->???edge[a]=(b,l)\nint dist[3000];\n\nint main(){\n\tint N,M,K;\n\tmemset(dist,INF,sizeof(dist));\n\tscanf(\"%d %d %d\",&N,&M,&K);\n\trep(i,M){\n\t\tint a,b,l;\n\t\tscanf(\"%d %d %d\",&a,&b,&l);\n\t\tedge[a-1].push_back( make_pair(b-1,l) );\n\t\tedge[b-1].push_back( make_pair(a-1,l) );\n\t\troad k;k.start=a-1;k.end=b-1;k.length=l;\n\t\teinfo.push_back( k);\n\t}\n\tpriority_queue< vector<pair<int,int> >, vector< pair<int,int> > , greater< pair<int,int> > > q;\n\trep(i,K){\n\t\tint s;\n\t\tscanf(\"%d\",&s);\n\t\tq.push( make_pair(0,s-1) );\n\t}\n\twhile(!q.empty()){\n\t\tpair<int,int> n=q.top();q.pop();\n\t\tif(dist[n.second]<=n.first)continue;\n\t\tdist[n.second]=n.first;\n\t\trep(i,edge[n.second].size()){\n\t\t\tq.push(make_pair(n.first+edge[n.second][i].second, edge[n.second][i].first) );\n\t\t}\n\t}\n\tdouble ans=0;\n\trep(i,einfo.size()){\n\t\troad r=einfo[i];\n\t\tans=max( ans, (double)(dist[r.start]+dist[r.end]+r.length)/2.0);\n\t}\n\n\tprintf( \"%d\\n\", (int)(ans)+(bool)((int)(ans)<=(double)(ans)-0.5));\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint N, M, K, A, B, L;\n\nvector<vector<pair<int, int> > > G;\n\nvector<int> P, D;\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tscanf(\"%d\", &M);\n\tscanf(\"%d\", &K);\n\n\tG = vector<vector<pair<int, int> > >(N);\n\n\tfor (int i = 0; i < M; i++)\n\t{\n\t\tscanf(\"%d\", &A);\n\t\tscanf(\"%d\", &B);\n\t\tscanf(\"%d\", &L);\n\n\t\tG[A - 1].push_back(make_pair(B - 1, L));\n\t\tG[B - 1].push_back(make_pair(A - 1, L));\n\t}\n\n\tP = vector<int>(K);\n\n\tfor (int i = 0; i < K; i++)\n\t{\n\t\tscanf(\"%d\", &P[i]); P[i]--; // 0 - indexed\n\t}\n\n\tD = vector<int>(N, 999999999);\n\n\tpriority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > que;\n\n\tfor (int i = 0; i < K; i++)\n\t{\n\t\tque.push(make_pair(0, P[i])); D[P[i]] = 0;\n\t}\n\n\twhile (!que.empty())\n\t{\n\t\tpair<int, int> state = que.top(); que.pop();\n\n\t\tint dist = state.first;\n\t\tint node = state.second;\n\n\t\tfor (int j = 0; j < G[node].size(); j++)\n\t\t{\n\t\t\tint node2 = G[node][j].first;\n\t\t\tint leng2 = G[node][j].second;\n\n\t\t\tif (D[node2] > D[node] + leng2)\n\t\t\t{\n\t\t\t\tD[node2] = D[node] + leng2;\n\n\t\t\t\tque.push(make_pair(D[node2], node2));\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = 0;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < G[i].size(); j++)\n\t\t{\n\t\t\tret = max(ret, D[i] + D[G[i][j].first] + G[i][j].second);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", (ret + 1) / 2);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3002\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<P> G[N];\nbool num[N];\nint n,m,K;\n\ndouble dijkstra(){\n  int D[N];\n  for(int i=0;i<N;i++) D[i] = 1e9;\n  \n  vector<int>pre[N];\n  priority_queue<PP,vector<PP>,greater<PP> >Q;\n  \n  for(int i=0;i<n;i++)\n    if(num[i]) Q.push(PP(0,P(i,i))),D[i] = 0;\n  \n  \n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first;\n    int pos = t.second.first;\n    int start = t.second.second;\n    \n    \n    if(D[pos]<cost) continue;\n    pre[pos].push_back(start);\n    \n    for(int i=0;i<G[pos].size();i++){\n      int npos = G[pos][i].first;\n      int ncost = cost+G[pos][i].second;\n      if(D[npos]<ncost) continue;\n      Q.push(PP(ncost,P(npos,start)));\n      D[npos] = ncost;\n    }\n  }\n\n  double res = 0;\n  for(int i=0;i<n;i++){\n    if(pre[i].size()>=2)res = max(res,(double)D[i]);\n    res = max(res,D[i]/2.0);\n    \n    for(int j=0;j<G[i].size();j++){\n      int npos = G[i][j].first;\n      int ncost = G[i][j].second;\n      if(pre[npos][0] == pre[i][0] && abs(D[i]-D[npos])==ncost)continue;\n\n      res = max(res,(D[i]+D[npos]+ncost)/2.0);\n    }\n  }\n  return res;\n  \n}\n\nint main(){\n  \n  cin>>n>>m>>K;\n  for(int i=0,a,b,c;i<m;i++){\n    cin>>a>>b>>c;\n    G[a-1].push_back(P(b-1,c));\n    G[b-1].push_back(P(a-1,c));\n  }\n\n  for(int i=0,a;i<K;i++)cin>>a,num[a-1]=1;\n  printf(\"%d\\n\",(int)(dijkstra()+0.5));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<vector>\n#include<functional>\n\nusing namespace std;\n\nint N, M, K;\ntypedef pair<int, int> P;\nstruct Edge {\n\tint to, cost;\n\tEdge();\n\tEdge(int a, int b) { to = a, cost = b; }\n};\nvector<vector<Edge>> e;\nvector<int> start;\nint d[3000];\n\nvoid djk() {\n\tfor (int i = 0; i < N; i++)d[i] = 1000000000;\n\tpriority_queue<P, vector<P>, greater<P>> pq;\n\tfor (int i = 0; i < K; i++) {\n\t\tpq.push(P(0, start[i]));\n\t\td[start[i]] = 0;\n\t}\n\twhile (pq.size()) {\n\t\tauto tmp = pq.top(); pq.pop();\n\t\tif (tmp.first > d[tmp.second])continue;\n\t\tfor (int i = 0; i < e[tmp.second].size(); i++) {\n\t\t\tauto next = e[tmp.second][i];\n\t\t\tif (d[next.to] > d[tmp.second] + next.cost) {\n\t\t\t\td[next.to] = d[tmp.second] + next.cost;\n\t\t\t\tpq.push(P(d[next.to], next.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> N >> M >> K;\n\te.resize(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--, b--;\n\t\te[a].push_back(Edge(b, c));\n\t\te[b].push_back(Edge(a, c));\n\t}\n\tfor (int i = 0; i < K; i++) {\n\t\tint a;\n\t\tcin >> a;\n\t\ta--;\n\t\tstart.push_back(a);\n\t}\n\tdjk();\n\tdouble ans = 0;\n\tfor (int i = 0; i < N; i++)ans = max(ans, (double)d[i]);\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < e[i].size(); j++) {\n\t\t\tans = max(ans, (double)(d[e[i][j].to] + d[i] + e[i][j].cost) / 2 + 0.5);\n\t\t}\n\t}\n\tcout << (int)ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 100000000\ntypedef long long LL;\ntypedef pair<int,int>P;\nstruct edge{int to,cost;};\n\nvector<edge>G[3390];\nint dis[3390];\n\nvoid dijkstra(int s){\n\tpriority_queue<P,vector<P>,greater<P> >Q;\n\tfill(dis,dis+3389,INF);\n\tdis[s]=0;\n\tQ.push(P(0,s));\n\t\n\twhile(Q.size()){\n\t\tP p=Q.top();\n\t\tQ.pop();\n\t\tint v=p.second;\n\t\tif(dis[v]<p.first)continue;\n\t\t\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tedge e=G[v][i];\n\t\t\tif(dis[e.to]>dis[v]+e.cost){\n\t\t\t\tdis[e.to]=dis[v]+e.cost;\n\t\t\t\tQ.push(P(dis[e.to],e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nint main(){\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\t\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tG[a-1].push_back({b-1,c});\n\t\tG[b-1].push_back({a-1,c});\n\t\t}\n\t\t\n\tfor(int i=0;i<k;i++){\n\t\tint a;\n\t\tcin>>a;\n\t\tG[3235].push_back({a-1,0});\n\t\t}\t\n\t\t\n\tdijkstra(3235);\n\t\n\tint ans=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<G[i].size();j++){\n\t\t\tans=max(ans,max(dis[i],dis[G[i][j].to]));\n\t\t\tint ct=0;\n\t\t\tct=G[i][j].cost;\n\t\t\t\n\t\t\t\tct+=dis[i];\n\t\t\t\tct+=dis[G[i][j].to];\n\t\t\t\tct=ct+1/2;\n\t\t\t\tans=max(ans,ct);\n\t\t\t}\n\t\t}\t\n\t\tcout<<ans<<endl;\n\t\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\nclass Edge{\npublic:\n\tint from,to,cost;\n\tEdge(){}\n\tEdge(int _from,int _to,int _cost){\n\t\tfrom = _from;\n\t\tto = _to;\n\t\tcost = _cost;\n\t}\n};\n\nint n,m,k;\nint dk[3000];\n\ntypedef pair<int,int> intpair;\npriority_queue<intpair,vector<intpair>,greater<intpair> > q;\n\nconst int INF = 10000000;\n\nvector<Edge> r[3000];\nvector<Edge> roads;\n\nint solve(){\n\twhile(!q.empty()){\n\t\tintpair p = q.top(); q.pop();\n\t\tint v = p.second;\n\t\tif(dk[v] < p.first){continue;}\n\t\tfor(int i=0;i<r[v].size();i++){\n\t\t\tEdge edge = r[v][i];\n\t\t\tif(dk[edge.to] > dk[v] + edge.cost){\n\t\t\t\tdk[edge.to] = dk[v] + edge.cost;\n\t\t\t\tq.push(intpair(dk[edge.to],edge.to));\n\t\t\t}\n\t\t}\n\t}\n\tint max = 0;\n\tdouble a,b;\n\tint c;\n\tfor(int i=0;i<roads.size();i++){\n\t\tEdge ed = roads[i];\n\t\ta = dk[ed.from];\n\t\tb = dk[ed.to] + ed.cost;\n\t\tc = (a + b + 1) / 2;\n\t\t//printf(\"%d)%d<-(%d)->%d(%d : %d\\n\",dk[ed.from],ed.from,ed.cost,ed.to,dk[ed.to],c);\n\t\tif(max < c){max = c;}\n\t}\n\t//printf(\"%d\\n\",max);\n\t//printf(\"%d:%d\\n\",p,a);\n\treturn max;\n}\n\nint main(){\n\tscanf(\"%d %d %d\",&n,&m,&k);\n\tint a,b,c;\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d %d %d\",&a,&b,&c);\n\t\ta--;b--;\n\t\tr[a].push_back(Edge(a,b,c));\n\t\tr[b].push_back(Edge(b,a,c));\n\t\troads.push_back(Edge(a,b,c));\n\t}\n\tfill(dk,dk+3000,INF);\n\tfor(int i=0;i<k;i++){\n\t\tscanf(\"%d\",&a);\n\t\ta--;\n\t\tdk[a] = 0;\n\t\tq.push(intpair(0,a));\n\t}\t\n\tprintf(\"%d\\n\",solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct edge {\n\tint from,to;\n\tint cost;\n\n\tedge(int t,int c) : to(t),cost(c) {}\n\tedge(int f,int t,int c) : from(f),to(t),cost(c) {}\n\n\tbool operator<(const edge &e) const {\n\t\treturn cost < e.cost;\n\t}\n};\n\nint n, m, k;\nvector<edge> G[3005];\nint d[3005], cost[3005][3005];\nbool used[3005];\n\nvoid dijkstra(int s,int n) {\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tfill(d,d+n,INF);\n\n\td[s] = 0;\n\tque.push(P(0,s));\n\n\twhile(que.size()) {\n\t\tP p = que.top();\n\t\tque.pop();\n\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\n\t\trep(i,G[v].size()) {\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n >> m >> k;\n\n\tmemset(used, 0, sizeof(used));\n\tmemset(cost, 0, sizeof(cost));\n\n\trep(i, m) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\n\t\ta--; \n\t\tb--;\n\n\t\tG[a].push_back(edge(b, c));\n\t\tG[b].push_back(edge(a, c));\n\n\t\tcost[a][b] = c;\n\t\tcost[b][a] = c;\n\t}\n\n\trep(i, k) {\n\t\tint x;\n\t\tcin >> x;\n\t\tused[x-1] = true;\n\t}\n\n\tvector<P> v(n);\n\trep(i, n) {\n\t\tdijkstra(i, n);\n\n\t\tint res = INF, id = -1;\n\t\trep(j, n) {\n\t\t\tif(used[j]) {\n\t\t\t\tif(res > d[j]) {\n\t\t\t\t\tres = d[j];\n\t\t\t\t\tid = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tv[i] = mp(res, id); \n\t}\n\n\trep(i, n) {\n\t\tcout << \"i:\" << i << \" \" << v[i].first << \" \" << v[i].second << endl;\n\t}\n\n\tint ans = 0;\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tint res = v[i].first + v[j].first + cost[i][j];\n\t\t\tans = max(ans, (res % 2 == 0 ? res / 2 : res / 2 + 1));\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 3010\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nstruct Edge {\n    int to, cost;\n    Edge (int to, int cost) :\n        to(to), cost(cost) {}\n};\n\nint N, M, K;\nvector<Edge> G[MAX];\nint d[MAX];\n\nvoid dijkstra(int src)\n{\n    d[src] = 0;\n\n    priority_queue<pii, vector<pii>, greater<pii>> pq;\n    pq.push(pii(0, src));\n\n    while (!pq.empty()) {\n        pii p = pq.top(); pq.pop();\n        int v = p.second;\n\n        for (int i = 0; i < (int)G[v].size(); i++) {\n            Edge &e = G[v][i];\n            if (d[v] + e.cost < d[e.to]) {\n                d[e.to] = d[v] + e.cost;\n                pq.push(pii(d[e.to], e.to));\n            }\n        }\n    }  \n}\n\nint main()\n{\n    cin >> N >> M >> K;\n    for (int i = 0; i < M; i++) {\n        int a, b, l;\n        cin >> a >> b >> l;\n        a--; b--;\n        G[a].push_back(Edge(b, l));\n        G[b].push_back(Edge(a, l));\n    }\n\n    fill(d, d + MAX, INF);\n    \n    int src;\n    for (int i = 0; i < K; i++) {\n        cin >> src; src--;\n        dijkstra(src);\n    }\n    \n    int res = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < (int)G[i].size(); j++) {\n            int k = G[i][j].to, c = G[i][j].cost;\n            int maxi = max(d[i], d[k]), mini = min(d[i], d[k]);\n            res = max(res, mini + (int)ceil((maxi + c - mini) * 0.5));\n        }\n    }\n\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//  Shopping in JOI Kingdom.cpp\n//  2013/01/06.\n\n#if 1\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst int INF = 1<<30;\n\nint N, M, K;\nint D[3000];\nint C[3000][3000];\n\nint dfs(int pnt)\n{\n\trep(next, N) if(D[next] > D[pnt] + C[pnt][next])\n\t{\n\t\tD[next] = D[pnt] + C[pnt][next];\n\t\tdfs(next);\n\t}\n}\n\nint calc(int a, int b, int l)\n{\n\treturn round(min(a, b) + (l + max(a, b) - min(a, b)) / 2.0);\n}\n\nint main()\n{\n\trep(i, 3000) rep(j, 3000) D[i] = C[i][j] = INF;\n\t\n\tcin >> N >> M >> K;\n\n\trep(m, M)\n\t{\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\t\n\t\tC[a-1][b-1] = C[b-1][a-1] = c;\n\t}\n\t\n\trep(k, K)\n\t{\n\t\tint s;\n\t\tcin >> s;\n\t\t\n\t\tD[s-1] = 0;\n\t\tdfs(s-1);\n\t}\n\t\n\tint ans = 0;\n\t\n\trep(a, N) REP(b, a+1, N) if(C[a][b] < INF) chmax(ans, calc(D[a], D[b], C[a][b]));\n\t\n\tcout << ans << endl;\n}\n\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#define PI 3.141592653589\n\n\n#define izryt bool\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\npii Dir[8] = { //?§????\n\t{ 0 ,1 },{ -1 ,0 },{ 1 ,0 },{ 0 ,-1 },\n\t{ 1 ,1 },{ 1 ,-1 },{ -1 ,1 },{ -1 ,-1 }\n};\n\nsigned main() {\n\tint n, m, k;\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tvector<vector<pii>> g(n);\n\tvector<pii> ed(m);\n\tREP(i, m) {\n\t\tint a, b, c;\n\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\t\ta--; b--;\n\t\tg[a].push_back({ b,c });\n\t\tg[b].push_back({ a,c });\n\t\ted[i] = { a,b };\n\t}\n\tpriority_queue<pair<pii, int>, vector<pair<pii, int>>, greater<pair<pii, int>>> que;\n\tREP(i, k) {\n\t\tint a;\n\t\tscnaf(\"%d\", &a);\n\t\ta--;\n\t\tque.push({ { 0,a },-1 });\n\t}\n\tvector<int> al(n,-1);\n\twhile (que.size()) {\n\t\tpair<pii,int> cur = que.top();\n\t\tque.pop();\n\n\t\tif (~al[cur.first.second])\n\t\t\tcontinue;\n\t\tal[cur.first.second] = cur.first.first;\n\n\t\tfor (auto itr : g[cur.first.second]) {\n\t\t\tif(!~al[itr.first])\n\t\t\t\tque.push({ {cur.first.first + itr.second, itr.first}, cur.first.second});\n\t\t}\n\t}\n\tint ans = 0;\n\tREP(i, m) {\n\t\tint len;\n\t\tfor (auto itr : g[ed[i].first]) {\n\t\t\tif (itr.first == ed[i].second) {\n\t\t\t\tlen = itr.second;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint susu = abs(al[ed[i].first] - al[ed[i].second]);\n\t\tlen -= susu;\n\t\tans = max(ans,(len + 1) / 2 + max(al[ed[i].first], al[ed[i].second]));\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct edge{\n  int to, cost;\n};\ntypedef vector< vector< edge > > Graph;\nvoid add_edge(Graph& info, int u, int v, int cost, bool flag = true){\n  info[u].push_back( (edge){ v, cost});\n  if(flag) info[v].push_back( (edge){ u, cost});\n}\nint Dijkstra(Graph& info, int s, int g, vector< int >& min_cost, vector< int >& beg) { //sからgへの最短路\n  typedef pair< int, int > Pi;\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  min_cost.assign(info.size(), -1);\n  for(int i = 0; i < beg.size(); i++){\n    que.push( Pi( 0, beg[i]));\n    min_cost[beg[i]] = 0;\n  }\n  while(!que.empty()){\n    Pi p = que.top(); que.pop();\n    if(p.second == g) return p.first;\n    if(p.first > min_cost[p.second]) continue;\n    for(int i = 0; i < info[p.second].size(); i++){\n      edge& e = info[p.second][i];\n      if(min_cost[e.to] == -1 || p.first + e.cost < min_cost[e.to]){\n        min_cost[e.to] = p.first + e.cost;\n        que.push( Pi( min_cost[e.to], e.to));\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  int N, M, K;\n  cin >> N >> M >> K;\n  Graph graph(N);\n  for(int i = 0; i < M; i++){\n    int a, b, c;\n    cin >> a >> b >> c;\n    --a, --b;\n    add_edge( graph, a, b, c);\n  }\n  vector< int > min_cost;\n  vector< int > beg(K);\n  for(int i = 0; i < K; i++){\n    int a;\n    cin >> a;\n    --a;\n    beg[i] = a;\n  }\n\n  Dijkstra( graph, -1, -1, min_cost, beg);\n\n  int ret = 0;\n  for(int i = 0; i < N; i++){\n    for(int j = 0; j < graph[i].size(); j++){\n      int dist = min_cost[i] - min_cost[graph[i][j].to];\n      if(dist < 0) continue;\n      ret = max( ret, min_cost[graph[i][j].to] + dist + (graph[i][j].cost - dist + 1)/ 2);\n    }\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<long long,int> P; // cost & to\n\nstruct EDGE {\n    int from;\n    int to;\n    long long len;\n    EDGE() {}\n    EDGE(int a,int b,int c) {\n        this->from=a; this->to=b; this->len=c;\n    }\n};\n\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define ABS(a) ((a)>0?(a):(-(a)))\n\nint main() {\n    int N,M,K;\n    cin >> N >> M >> K;\n\n    vector<P> r[N];\n    vector<EDGE> e;\n    for(int i=0; i<M; ++i) {\n        int a,b;\n        long long cost;\n        cin >> a >> b >> cost;\n        r[a-1].push_back(P(cost,b-1));\n        r[b-1].push_back(P(cost,a-1));\n        e.push_back(EDGE(a-1,b-1,cost));\n    }\n\n    unordered_map<int,long long> cst; // town & cost\n    for(int i=0; i<K; ++i) {\n        int town;\n        cin >> town;\n        cst[town-1]=0;\n    }\n\n    priority_queue<P,vector<P>,greater<P> > q;\n    for(auto x : cst) { // x = shoping town\n        for(auto t : r[x.first]) { // t = directry connected to town x ( type P )\n            q.push(t);\n        }\n    }\n\n    while(cst.size()!=N) {\n        P p=q.top(); q.pop();\n        if(cst.find(p.second)!=cst.end()) continue;\n        cst[p.second]=p.first;\n        for(auto t : r[p.second]) {\n            if(cst.find(t.second)!=cst.end()) continue;\n            q.push(P(p.first+t.first,t.second));\n        }\n    }\n\n    long long ans=0;\n    for(auto edg : e) {\n        ans=MAX(ans,(cst[edg.from]+cst[edg.to]+edg.len+1)/2);\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\nconst int INF = (1LL<<30);\nconst ll LLINF = (1LL<<60);\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n//#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nstruct edge{int to, cost;};\n\nint n, d[3010], m, k, s[3010];\nvector<edge> g[3010];\n\nvoid dijkstra() {\n  priority_queue<PII, vector<PII>, greater<PII>> que;\n  fill(d, d+n, INF);\n  REP(i, k) {\n    d[s[i]] = 0;\n    que.push(PII{0, s[i]});\n  }\n\n  while(que.size()) {\n    PII p = que.top(); que.pop();\n    int v = p.second;\n    if(d[v] < p.first) continue;\n    for(edge e: g[v]) {\n      if(d[e.to] > d[v] + e.cost) {\n        d[e.to] = d[v] + e.cost;\n        que.push(PII{d[e.to], e.to});\n      }\n    }\n  }\n}\n\nint a[100010], b[100010], c[100010];\nsigned main(void)\n{\n  cin >> n >> m >> k;\n  REP(i, m) {\n    cin >> a[i] >> b[i] >> c[i];\n    a[i]--, b[i]--;\n    g[a[i]].PB({b[i], c[i]});\n    g[b[i]].PB({a[i], c[i]});\n  }\n  REP(i, k) cin >> s[i], s[i]--;\n\n  dijkstra();\n  // REP(i, n) cout << d[i] << \" \"; cout << endl;\n\n  int ret = 0;\n  REP(i, m) chmax(ret, (d[a[i]]+d[b[i]]+c[i])/2+!!((d[a[i]]+d[b[i]]+c[i])%2));\n  cout << ret << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n\nconst int INF = 1 << 24;\nconst int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};\n\ntypedef unsigned long long ull;\ntypedef std::tuple<int, int> P;\n\n\n\nstruct Edge{\n    int to, cost;\n};\n\nnamespace W5{\n    template<typename T>\n    T max(T t){\n        return t;\n    }\n\n    template<typename First, typename... Rest>\n    First max(First f, Rest... r){\n        return std::max(f, W5::max(r...));\n    }\n};\n\nstd::vector<Edge> G[3010];\nstd::vector<int> S;\nint d[3010];\nint N, M, K;\n\nint dijkstra(int s){\n    int res = 0;\n    std::priority_queue<P, std::vector<P>, std::greater<P>> q;\n    std::fill(d, d+3010, INF);\n\n    d[s] = 0;\n    q.push(std::make_tuple(0, s));\n\n    while(!q.empty()){\n        P p = q.top(); q.pop();\n        int u = std::get<0>(p), v = std::get<1>(p);\n        \n        if(d[v] < u){continue;}\n\n        REP(i, G[v].size()){\n            Edge e = G[v][i];\n            if(d[e.to] > d[v] + e.cost){\n                d[e.to] = d[v] + e.cost;\n                q.push(std::make_tuple(d[e.to], e.to));\n                res = std::max(res, d[e.to]);\n            }\n        }\n    }\n\n    return res;\n}\n\nint main(){\n    std::cin >> N >> M >> K;\n    \n    REP(i, M){\n        int from, to, l;\n        std::cin >> from >> to >> l;\n        from--; to--;\n\n        G[from].push_back({to, l});\n        G[to].push_back({from, l});\n    }\n\n    REP(i, K){\n        int s;\n        std::cin >> s;\n        s--;\n\n        S.push_back(s);\n    }\n\n    int smallest[3010];\n    std::fill(smallest, smallest+3010, INF);\n\n    REP(i, K){\n        dijkstra(S[i]);\n\n        REP(j, N){\n            smallest[j] = std::min(smallest[j], d[j]);\n        }\n    }\n\n    int res = 0;\n    REP(i, N){\n        int l = 0;\n        REP(j, G[i].size()){\n            Edge e = G[i][j];\n\n            l = std::max(l, static_cast<int>(1. * (smallest[i] + smallest[e.to] + e.cost) / 2.0 + 0.5));\n        }\n\n        res = W5::max(res, smallest[i], l);\n    }\n\n    std::cout << res << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n//#define debug cout\n#else\nSS ss;\n//#define debug ss\n#endif\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n//#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,-1,1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,-1,1,0};\n\nvpint l[3010];\nint s[3010];\nint d[3010];\n\nint main() {\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\trep(i,m){\n\t\tint from,to,cost;\n\t\tcin>>from>>to>>cost;\n\t\t--from,--to;\n\t\tl[from].PB(MP(to,cost));\n\t\tl[to].PB(MP(from,cost));\n\t}\n\trep(i,k)s[i]=in()-1;\n\trep(i,n)d[i]=INF;\n\tpriority_queue<pint,vector<pint>,greater<pint> > que;\n\trep(i,k)que.push(MP(0,s[i]));\n\twhile(!que.empty()){\n\t\tpint now=que.top();\n//debug<<now.first<<\" \"<<now.second<<endl;\n\t\tque.pop();\n\t\tif(d[now.second]<=now.first)continue;\n\t\td[now.second]=now.first;\n\t\trep(i,sz(l[now.second])){\n\t\t\tque.push(MP(now.first+l[now.second][i].second,l[now.second][i].first));\n\t\t}\n\t}\n//rep(i,n)debug<<i<<\" \"<<d[i]<<endl;\n\tint mx=0;\n\trep(i,n)rep(j,sz(l[i])){\n\t\tchmax(mx,(d[i]+d[l[i][j].first]+l[i][j].second+1)/2);\n\t}\n\tcout<<mx<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct edge{\n    int to;\n    int cost;\n};\nclass Situation{\npublic:\n\tint cost;\n\tint idx;\n\n\tSituation(int cost_,int idx_){\n\t\tcost=cost_;\n\t\tidx=idx_;\n\t}\n\tSituation();\n\n\tbool operator<(const Situation &s)const{\n\t\treturn s.cost < this->cost;\n\t}\n};\nconst int MAX_V=3001;\n\nint N,M,K;\nvector<edge> G[MAX_V];\nbool isShop[MAX_V];\nint d[MAX_V];\nconst int INF=1000000000;\nint froms[100001];\nint tos[100001];\nint costs[100001];\n\nvoid dijkstra(int s){\n\tpriority_queue<Situation> que;\n\td[s] = 0;\n\tque.push(Situation(0,s));\n\twhile(!que.empty()){\n\t\tSituation p = que.top();\n\t\tque.pop();\n\t\tint v = p.idx;\n\t\tif(d[v] < p.cost)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost){\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(Situation(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n    cin>>N>>M>>K;\n    for(int i=0;i<M;i++){\n        edge e;\n        int from,to,cost;\n        cin>>from>>to>>cost;\n        from--;to--;\n        froms[i]=from;\n        tos[i]=to;\n        costs[i]=cost;\n        e.to=to;\n        e.cost=cost;\n        G[from].push_back(e);\n        e.to=from;\n        G[to].push_back(e);\n    }\n\tfill(d,d+MAX_V,INF);\n    for(int i=0;i<K;i++){\n        int a;\n        cin>>a;\n        a--;\n        dijkstra(a);\n    }\n    double res=0;\n    for(int i=0;i<N;i++)\n        res=max(res,(double)d[i]);\n    for(int i=0;i<M;i++){\n        double dit=(1.0*d[froms[i]]+d[tos[i]]+costs[i])/2;\n        if((int)(dit+(1e-10))>=d[froms[i]]&&(int)(dit+(1e-10))>=d[tos[i]])res=max(dit,res);\n    }\n    printf(\"%.0f\\n\",res);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//  Shopping in JOI Kingdom.cpp\n//  2013/01/06.\n\n#if 1\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst int INF = 1<<30;\n\nint N, M, K;\nint D[3000];\nint C[3000][3000];\nint used[3000];\n\nint dfs(int pnt)\n{\n\trep(next, N) if(D[next] > D[pnt] + C[pnt][next])\n\t{\n\t\tD[next] = D[pnt] + C[pnt][next];\n\t\tdfs(next);\n\t}\n}\n\nvoid dijkstra(int pnt)\n{\n\tmemset(used, 0, sizeof used);\n\t\n\twhile(true)\n\t{\n\t\tint v = -1;\n\t\t\n\t\trep(u, N) if(!used[u] && (v == -1 || D[u] < D[v])) v = u;\n\t\t\n\t\tif(v == -1) break;\n\t\t\n\t\tused[v] = true;\n\t\t\n\t\trep(u, N) chmin(D[u], D[v] + C[v][u]);\n\t}\n}\n\nint calc(int a, int b, int l)\n{\n\treturn round(min(a, b) + (l + max(a, b) - min(a, b)) / 2.0);\n}\n\nint main()\n{\n\trep(i, 3000) rep(j, 3000) D[i] = C[i][j] = INF;\n\t\n\tcin >> N >> M >> K;\n\n\trep(m, M)\n\t{\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\t\n\t\tC[a-1][b-1] = C[b-1][a-1] = c;\n\t}\n\t\n\tint s;\n\trep(k, K)\n\t{\n\t\tcin >> s;\n\t\t\n\t\tD[s-1] = 0;\n\t}\n\t\n\tdijkstra(s-1);\t\n\n\tint ans = 0;\n\t\n\trep(a, N) REP(b, a+1, N) if(C[a][b] < INF) chmax(ans, calc(D[a], D[b], C[a][b]));\n\t\n\tcout << ans << endl;\n}\n\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3002\nusing namespace std;\ntypedef pair<int,int> P;\nvector<P> G[N];\nbool num[N];\nint n,m,K;\n\ndouble dijkstra(){\n  vector<int> D(N,1e9);\n  priority_queue<P,vector<P>,greater<P> >Q;\n  for(int i=0;i<n;i++)if(num[i]) Q.push(P(0,i)),D[i] = 0;\n  \n  while(!Q.empty()){\n    P t = Q.top();Q.pop();\n    int cost = t.first;\n    int pos = t.second;\n    if(D[pos]<cost) continue;\n\n    for(int i=0;i<G[pos].size();i++){\n      int npos = G[pos][i].first;\n      int ncost = cost+G[pos][i].second;\n      if(D[npos]<=ncost) continue;\n      Q.push(P(ncost,pos));\n      D[npos] = ncost;\n    }\n  }\n\n  double res = 0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<(int)G[i].size();j++){\n      int npos = G[i][j].first;\n      int ncost = G[i][j].second;\n      res = max(res,(D[i]+D[npos]+ncost)/2.0);\n    }\n  return res;\n   \n}\n \nint main(){\n  cin>>n>>m>>K;\n  for(int i=0,a,b,c;i<m;i++){\n    cin>>a>>b>>c;\n    G[a-1].push_back(P(b-1,c));\n    G[b-1].push_back(P(a-1,c));\n  }\n \n  for(int i=0,a;i<K;i++)cin>>a,num[a-1]=1;\n  printf(\"%d\\n\",(int)(dijkstra()+0.5));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cmath>\n#define INF 1e+9\nusing namespace std;\n\ntypedef pair<int,int> P;\nstruct edge{ int to,cost; };\n\nint main(){\n\tint n,m,k,a,b,l,s;\n\tstatic int d[3000],dtd[3000][3000];\n\tvector<edge> G[3000];\n\tqueue<P> que; \n\tcin >> n >> m >> k;\n\tfor(int i = 0;i < n;i++) {\n\t\td[i] = INF;\n\t\tfor(int j = 0;j < n;j++) dtd[i][j] = -1;\n\t}\n\tfor(int i = 0;i < m;i++){\n\t\tcin >> a >> b >> l;\n\t\tG[a - 1].push_back({b - 1,l});\n\t\tG[b - 1].push_back({a - 1,l});\n\t\tdtd[a - 1][b - 1] = l;\n\t\tdtd[b - 1][a - 1] = l;\n\t}\n\tfor(int i = 0;i < k;i++){\n\t\tcin >> s;\n\t\tque.push(P(s - 1,0));\n\t}\n\twhile(!que.empty()){\n\t\tP p = que.front();que.pop();\n\t\tif(d[p.first] <= p.second) continue;\n\t\td[p.first] = p.second;\n\t\tfor(int i = 0;i < G[p.first].size();i++){\n\t\t\tque.push({G[p.first][i].to,d[p.first] + G[p.first][i].cost});\n\t\t}\n\t}\n\tdouble ma = 0;\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < n;j++){\n\t\t\tif(dtd[i][j] != -1) ma = max(ma,(double)(d[i] + d[j] + dtd[i][j]) / 2.0);\n\t\t}\n\t}\n\tcout << (int)round(ma) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cmath>\n#define INF 1e+9\nusing namespace std;\n\ntypedef pair<int,int> P;\nstruct edge{ int to,cost; };\n\nint main(){\n\tint n,m,k,a,b,l,s;\n\tint d[3000],dtd[3000][3000];\n\tvector<edge> G[3000];\n\tqueue<P> que; \n\tcin >> n >> m >> k;\n\tfor(int i = 0;i < n;i++) {\n\t\td[i] = INF;\n\t\tfor(int j = 0;j < n;j++) dtd[i][j] = -1;\n\t}\n\tfor(int i = 0;i < m;i++){\n\t\tcin >> a >> b >> l;\n\t\tG[a - 1].push_back({b - 1,l});\n\t\tG[b - 1].push_back({a - 1,l});\n\t\tdtd[a - 1][b - 1] = l;\n\t\tdtd[b - 1][a - 1] = l;\n\t}\n\tfor(int i = 0;i < k;i++){\n\t\tcin >> s;\n\t\tque.push(P(s - 1,0));\n\t}\n\twhile(!que.empty()){\n\t\tP p = que.front();que.pop();\n\t\tif(d[p.first] <= p.second) continue;\n\t\td[p.first] = p.second;\n\t\tfor(int i = 0;i < G[p.first].size();i++){\n\t\t\tque.push({G[p.first][i].to,d[p.first] + G[p.first][i].cost});\n\t\t}\n\t}\n\tdouble ma = 0;\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < n;j++){\n\t\t\tif(dtd[i][j] != -1) ma = max(ma,(double)(d[i] + d[j] + dtd[i][j]) / 2.0);\n\t\t}\n\t}\n\tcout << (int)round(ma) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define s size()\n#define INF 100000000\nint cost[3005][3005];\nint d[3005];\nint maxi[100005]={};\nbool used[3005]={};\nP1 ii[100005];\nint V;\nvoid dijkstra(int os){\n\tfill(d,d+V,INF);\n\td[os]=0;\n\twhile(1){\n\t\tint v=-1;\n\t\tfor(int u=0;u<V;u++){\n\t\t\tif(!used[u] && (v==-1 || d[u]<d[v])){\n\t\t\t\tv=u;\n\t\t\t}\n\t\t}\n\t\tif(v==-1){\n\t\t\tbreak;\n\t\t}\n\t\tused[v]=true;\n\t\tfor(int i=0;i<V;i++){\n\t\t\td[i]=min(d[i],d[v]+cost[v][i]);\n\t\t}\n\t}\n}\nint n,m,k;\nint main(){\n\tscanf(\"%d %d %d\",&n,&m,&k);\n\tfor(int i=0;i<3005;i++){\n\t\tfor(int j=0;j<3005;j++){\n\t\t\tcost[i][j]=INF;\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint w,ww,eu;\n\t\tscanf(\"%d %d %d\",&w,&ww,&eu);\n\t\tii[i]=mp(eu,mp(w,ww));\n\t\tcost[w-1][ww-1]=eu;\n\t\tcost[ww-1][w-1]=eu;\n\t}\n\tint res=0;\n\tfor(int i=0;i<k;i++){\n\t\tint t;\n\t\tscanf(\"%d\",&t);\n\t\tdijkstra(t-1);\n\t\tmemset(used,0,sizeof(used));\n\t\tfor(int j=0;j<m;j++){\n\t\t\tmaxi[j]=max(maxi[j],(ii[j].first+d[ii[j].second.first-1]+d[ii[j].second.second-1]+1)/2);\n\t\t}\n\t}\n\tfor(int j=0;j<m;j++){\n\t\tres=max(res,maxi[j]);\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cmath>\n#define INF 1e+9\nusing namespace std;\n\ntypedef pair<int,int> P;\nstruct edge{ int to,cost; };\n\nint main(){\n\tint n,m,k,a,b,l,s;\n\tint d[3000],dtd[3000][3000];\n\tvector<edge> G[3000];\n\tqueue<P> que; \n\tcin >> n >> m >> k;\n\tfor(int i = 0;i < n;i++) {\n\t\td[i] = INF;\n\t\tfor(int j = 0;j < n;j++) dtd[i][j] = -1;\n\t}\n\tfor(int i = 0;i < m;i++){\n\t\tcin >> a >> b >> l;\n\t\tG[a - 1].push_back({b - 1,l});\n\t\tG[b - 1].push_back({a - 1,l});\n\t\tdtd[a - 1][b - 1] = l;\n\t\tdtd[b - 1][a - 1] = l;\n\t}\n\tfor(int i = 0;i < k;i++){\n\t\tcin >> s;\n\t\tque.push(P(s - 1,0));\n\t}\n\twhile(!que.empty()){\n\t\tP p = que.front();que.pop();\n\t\tif(d[p.first] <= p.second) continue;\n\t\td[p.first] = p.second;\n\t\tfor(int i = 0;i < G[p.first].size();i++){\n\t\t\tque.push({G[p.first][i].to,d[p.first] + G[p.first][i].cost});\n\t\t}\n\t}\n\tdouble ma = 0;\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < n;j++){\n\t\t\tif(dtd[i][j] != -1) ma = max(ma,(double)(d[i] + d[j] + dtd[i][j]) / 2.0);\n\t\t}\n\t}\n\tcout << (int)round(ma) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<cstdio>\n#include<cmath>\n#include<stack>\n#define F first\n#define S second\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef vector<P> VP;\ntypedef vector<int> VI;\ntypedef vector<VP> VVP;\ntypedef vector<VI> VVI;\nclass Pox\n{\npublic:\n  int cost,now;\n  Pox():cost(0),now(0){}\n  Pox(int now,int cost):now(now),cost(cost){}\n};\n\nclass ope{\npublic:\n  bool operator() (Pox a,Pox b)\n  {\n    return a.cost > b.cost;\n  }\n};\n\nconst int INF = (1<<28);\nint N,M,K;\nVVP G;\n//VVI mincost;\nVI mincost;\nmap<P,int> D;\n\nint main()\n{\n  scanf(\"%d %d %d\",&N,&M,&K);\n  G.resize(N),mincost.resize(N);\n  for(int i=0;i<N;i++)\n      mincost[i] = INF;\n\n  for(int i=0;i<M;i++)\n    {\n      int a,b,c;\n      scanf(\"%d %d %d\",&a,&b,&c);\n      a--,b--;\n      G[a].push_back(P(b,c));\n      G[b].push_back(P(a,c));\n      D[P(a,b)] = D[P(b,a)] = c;\n    }\n\n  priority_queue<Pox,vector<Pox>,ope> Q;\n  for(int i=0;i<K;i++)\n    {\n      int a;\n      scanf(\"%d\",&a);\n      a--;\n      Q.push(Pox(a,0));\n      mincost[a] = 0;\n    }\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.top(); Q.pop();\n      int now = pox.now;\n      int total = pox.cost;\n\n      for(int i=0;i<G[now].size();i++)\n\t{     \n\t  P p = G[now][i];\n\t  int to = p.F;\n\t  int cost = p.S;\n\t  if(mincost[to] <= total + cost)\n\t    continue;\n\n\t  mincost[to] = total + cost;\n\t  Q.push(Pox(to,total+cost));\n\t}\n    }\n\n\n  double mex = 0;\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      if(j != i && mincost[j] != INF && mincost[i] != INF && D[P(i,j)])\n\tmex = max(mex,(double)(mincost[i]+mincost[j]+D[P(i,j)])/2.0 );\n\t\n    \n      \n\n  cout << round(mex) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define M 100000007\ntypedef pair<int,int> P;\n/*int main(){\n\tcout<<8979879<<endl;\n}*/\nint ri[3001][3001];\nint main(void){\n\tint n,m,k,\n\t\ti,j,\n\t\tmx,t,\n\t\ta[100001],b[100001],l[100001],s[3000],\n\t\td[3001];\n\t\t\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\n\tcin>>n>>m>>k;\n\tfor(i=0;i<m;i++) cin>>a[i]>>b[i]>>l[i];\n\tfor(i=0;i<k;i++) cin>>s[i];\n//\tfor(i=0;i<k;i++) cout<<s[i]<<endl;\n\t\n\tfor(i=1;i<=n;i++) for(j=1;j<=n;j++) ri[i][j]=M;\n\tfor(i=0;i<m;i++) ri[a[i]][b[i]]=l[i],ri[b[i]][a[i]]=l[i];\n/*\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++)cout<<ri[i][j]<<' ';\n\t\tcout<<endl;\n\t}*/\n\t\n\tmx=0;\n\tint leng[3001];\n\tfor(i=1;i<=n;i++) leng[i]=M;\n\tfor(i=0;i<k;i++){\n\t\tleng[s[i]]=0;\n\t\tque.push(P(0,s[i]));\n\t}\n\twhile(!que.empty()){\n\t\tP p=que.top();\n\t\tque.pop();\n\t\tint v=p.second;\n\t\tif(leng[v]<p.first) continue;\n\t\tfor(j=1;j<=n;j++){\n\t\t\tt=leng[v]+ri[v][j];\n//\t\t\tcout<<j<<' '<<leng[j]<<' '<<t<<endl;\n\t\t\tif(leng[j]>t){\n\t\t\t\tleng[j]=t;\n//\t\t\t\tcout<<leng[j]<<' '<<j<<endl;\n\t\t\t\tque.push(P(leng[j],j));\n\t\t\t}\n\t\t}\n\t}\n/*\tfor(i=1;i<=n;i++) cout<<leng[i]<<' ';\n\tcout<<endl;*/\n\tfor(i=1;i<=n;i++){\n\t\tdouble cnt=0,sum=0;\n\t\tfor(j=1;j<=n;j++){\n\t\t\tif(ri[i][j]!=M) cnt++,sum+=ri[i][j]+leng[j];\n\t\t}\n\t\tif(sum%cnt>=cnt/2) mx=max(mx,sum%cnt+1);\n\t\telse mx=max(mx,sum%cnt);\n\t}\n\t\n\tcout<<mx<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct edge {\n\tint from,to;\n\tint cost;\n\n\tedge(int t,int c) : to(t),cost(c) {}\n\tedge(int f,int t,int c) : from(f),to(t),cost(c) {}\n\n\tbool operator<(const edge &e) const {\n\t\treturn cost < e.cost;\n\t}\n};\n\nint n, m, k;\nvector<edge> G[3005];\nint d[3005], cost[3005][3005];\nbool used[3005];\n\nvoid dijkstra(int s,int n) {\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tfill(d,d+n,INF);\n\n\td[s] = 0;\n\tque.push(P(0,s));\n\n\twhile(que.size()) {\n\t\tP p = que.top();\n\t\tque.pop();\n\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\n\t\trep(i,G[v].size()) {\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost) {\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> n >> m >> k;\n\n\tmemset(used, 0, sizeof(used));\n\tmemset(cost, 0, sizeof(cost));\n\n\trep(i, m) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\n\t\ta--; \n\t\tb--;\n\n\t\tG[a].push_back(edge(b, c));\n\t\tG[b].push_back(edge(a, c));\n\n\t\tcost[a][b] = c;\n\t\tcost[b][a] = c;\n\t}\n\n\trep(i, k) {\n\t\tint x;\n\t\tcin >> x;\n\t\tused[x-1] = true;\n\t}\n\n\tvector<P> v(n);\n\trep(i, n) {\n\t\tdijkstra(i, n);\n\n\t\tint res = INF, id = -1;\n\t\trep(j, n) {\n\t\t\tif(used[j]) {\n\t\t\t\tif(res > d[j]) {\n\t\t\t\t\tres = d[j];\n\t\t\t\t\tid = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tv[i] = mp(res, id); \n\t}\n\n\t// rep(i, n) {\n\t// \tcout << \"i:\" << i << \" \" << v[i].first << \" \" << v[i].second << endl;\n\t// }\n\n\tint ans = 0;\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tint res = v[i].first + v[j].first + cost[i][j];\n\t\t\tans = max(ans, (res % 2 == 0 ? res / 2 : res / 2 + 1));\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <deque>\n#include <vector>\nusing namespace std;\n\nint road[1000001][3];\nint main() {\n\tint N,M,K;\n\tvector<pair<int,int> >nGo[3001];\n\tdeque<int> dis;\n\tint dist[3001];\n\tint signer[3001]={};\n\tfor(int i=1;i<=3000;i++)\n\t\tdist[i]=(1 << 30 );\n\tcin >> N >> M >> K;\n\tint a,b,c;\n\tfor(int i=0;i<M;i++){\n\t\tcin >> a >> b >> c;\n\t\tnGo[a].push_back(pair<int,int>(b,c));\n\t\tnGo[b].push_back(pair<int,int>(a,c));\n\t\troad[i][0]=a;\n\t\troad[i][1]=b;\n\t\troad[i][2]=c;\n\t}\n\tfor(int i=0;i<K;i++){\n\t\tcin >> a;\n\t//\tdis.insert(multimap<int,int>::value_type(0,a));\n\t\tdis.push_back(a);\n\t\tdist[a]=0;\n\t}\n\twhile(!dis.empty()){\n\t\tint miner=0;\n\t\tfor(int i=0;i<dis.size();i++)\n\t\tminer=(dist[dis[miner]]<dist[dis[i]]) ? miner:i;\n\t\tint r=dis[miner];\n\t\tdis[miner]=dis[0];\n\t\tdis[0]=r;\n\t\tcout << r << endl;\n\t\tint now=dis[0];\n\t\tfor(int i=0;i<nGo[now].size();i++){\n\t\t\tif(dist[nGo[now][i].first]>dist[now]+nGo[now][i].second){\n\t\t\t\tif(signer[nGo[now][i].first]==0){\n\t\t\t\tdis.push_back(nGo[now][i].first);\n\t\t\t\tsigner[nGo[now][i].first]=1;\n\t\t\t\t}\n\t\t\t\tdist[nGo[now][i].first]=dist[now]+nGo[now][i].second;\n\t\t\t}\n\t\t}\n\t\tdis.pop_front();\n\t}\n\tint maxer=0;\n\tfor(int i=0;i<M;i++)\n\tmaxer=max(maxer,(dist[road[i][0]]+dist[road[i][1]]+road[i][2]+1)/2);\n\tfor(int i=1;i<=N;i++)\n\tmaxer=max(maxer,dist[i]);\n\tcout << maxer <<  endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//ツ暗。ツつ、ツづァツつオツつ「\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <utility>\nusing namespace std;\nstruct road{\n\tint a,b,l;\n\troad(int a_,int b_,int l_):a(a_),b(b_),l(l_){}\n};\ntypedef pair<int,int> pii;\nint main(){\n\tint n,m,k,a,b,l,s;\n\tvector<road> rd;\n\tvector<pii> town[3001];\n\tint len[3001];\n\tpriority_queue<pii,vector<pii>,greater<pii> > qu;\n\tint inf = 1e9;\n\n\tfor(cin>>n>>m>>k;m--;rd.push_back(road(a,b,l))){\n\t\tcin>>a>>b>>l;\n\t\ttown[a].push_back(make_pair(b,l));\n\t\ttown[b].push_back(make_pair(a,l));\n\t}\n\tfor(;k--;qu.push(make_pair(0,s)))\n\t\tcin>>s;\n\n\tfor(fill(len,len+n+1,-1);!qu.empty();){\n\t\tpii pi = qu.top();\n\t\tqu.pop();\n\t\tif( len[pi.second] == -1 ){\n\t\t\tlen[pi.second] = pi.first;\n\t\t\tfor(\n\t\t\t\tvector<pii>::iterator it=town[pi.second].begin();\n\t\t\t\tit != town[pi.second].end();\n\t\t\t\t++it\n\t\t\t){\n\t\t\t\tqu.push(make_pair(pi.first+it->second,it->first));\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts=0;\n\tfor(vector<road>::iterator it = rd.begin(); it != rd.end();\t++it ){\n\t\ts = max(max( s, len[a] ),\n\t\t\t\tmax( len[b], (len[it->b] + it->l - len[it->a] + 1)/2 + len[it->a] )\n\t\t);\n\t}\n\tcout << s << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Shopping in JOI Kingdom\n//Level: 3\n//Category: グラフ,Graph,最短経路\n//Note:\n\n/*\n * とりあえず道の途中に家があるときのことは考えず，各頂点についてショッピングモールからの\n * 最短距離を求める．\n * これは各ショッピングモールを始点としたダイクストラで求められる．\n * ただしナイーブにやると最大ケースで死にそうなので，ダイクストラの途中で他のショッピングモールに\n * ぶつかった場合はそこで枝刈りするようにした．\n *\n * ある2頂点があって，それぞれのショッピングモールへの最短距離がaとbで距離lの辺でつながっているとき，\n * この辺上での最遠点では\n * a+ul == b+(1-u)l\n * が成立しているはずであるから，各aとbの組について方程式を解いてulを求め，最大のa+ulを選べばそれが解となる．\n * (最短距離の定義より，min(a,b)+l >= max(a,b)であることに注意)\n */\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nstruct Road {\n    int from, to;\n    int len;\n\n    Road() {}\n    Road(int f, int t, int l) : from(f), to(t), len(l) {}\n};\n\nvector<Road> roads_of[3000];\nbool is_shopping_mall[3000];\nint min_dist[3000];\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    int N, M, K;\n    cin >> N >> M >> K;\n    for(int i = 0; i < M; ++i) {\n        int a, b, l;\n        cin >> a >> b >> l;\n        --a; --b;\n        roads_of[a].push_back(Road(a, b, l));\n        roads_of[b].push_back(Road(b, a, l));\n    }\n    fill_n(is_shopping_mall, N, false);\n    for(int i = 0; i < K; ++i) {\n        int a;\n        cin >> a;\n        --a;\n        is_shopping_mall[a] = true;\n    }\n    fill_n(min_dist, N, INT_MAX);\n\n    static int memo[3000];\n    for(int start = 0; start < N; ++start) {\n        if(!is_shopping_mall[start]) continue;\n        fill_n(memo, N, INT_MAX);\n        priority_queue<pair<int, int> > q;\n        q.push(make_pair(0, start));\n        memo[start] = 0;\n        while(!q.empty()) {\n            int cost = -q.top().first;\n            int pos = q.top().second;\n            q.pop();\n            if(memo[pos] < cost) continue;\n            min_dist[pos] = min(min_dist[pos], cost);\n\n            for(vector<Road>::iterator it = roads_of[pos].begin(); it != roads_of[pos].end(); ++it) {\n                if(is_shopping_mall[it->to]) continue;\n\n                int nc = cost + it->len;\n                if(memo[it->to] > nc) {\n                    memo[it->to] = nc;\n                    q.push(make_pair(-nc, it->to));\n                }\n            }\n        }\n    }\n\n    int ans = 0;\n    for(int i = 0; i < N; ++i) {\n        int d = 0;\n        const int a = min_dist[i];\n        // a+ul == b+vl, u+v == 1\n        // a+ul == b+(1-u)l\n        // 2ul == b-a+l\n        // ul == (b-a+l)/2\n        for(vector<Road>::iterator it = roads_of[i].begin(); it != roads_of[i].end(); ++it) {\n            const int b = min_dist[it->to];\n            if(b >= a) {\n                int ul = (b-a+it->len) / 2;\n                if((b-a+it->len) % 2 == 1) ++ul;\n                d = max(d, min_dist[i] + ul);\n            }\n        }\n        ans = max(ans, d);\n    }\n\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint N, M, K, A, B, L;\n\nvector<vector<pair<int, int> > > G;\n\nvector<int> P, D;\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tscanf(\"%d\", &M);\n\tscanf(\"%d\", &K);\n\n\tG = vector<vector<pair<int, int> > >(N);\n\n\tfor (int i = 0; i < M; i++)\n\t{\n\t\tscanf(\"%d\", &A);\n\t\tscanf(\"%d\", &B);\n\t\tscanf(\"%d\", &L);\n\n\t\tG[A - 1].push_back(make_pair(B - 1, L));\n\t\tG[B - 1].push_back(make_pair(A - 1, L));\n\t}\n\n\tP = vector<int>(K);\n\n\tfor (int i = 0; i < K; i++)\n\t{\n\t\tscanf(\"%d\", &P[i]); P[i]--; // 0 - indexed\n\t}\n\n\tD = vector<int>(N, -1);\n\n\tpriority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > que;\n\n\tfor (int i = 0; i < K; i++)\n\t{\n\t\tque.push(make_pair(0, P[i])); D[P[i]] = 0;\n\t}\n\n\twhile (!que.empty())\n\t{\n\t\tint dist = que.top().first;\n\t\tint node = que.top().second; que.pop();\n\n\t\tfor (int j = 0; j < G[node].size(); j++)\n\t\t{\n\t\t\tint node2 = G[node][j].first;\n\t\t\tint leng2 = G[node][j].second;\n\n\t\t\tif (D[node2] == -1)\n\t\t\t{\n\t\t\t\tD[node2] = D[node] + leng2;\n\n\t\t\t\tque.push(make_pair(D[node2], node2));\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = 0;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < G[i].size(); j++)\n\t\t{\n\t\t\tret = max(ret, D[i] + D[G[i][j].first] + G[i][j].second);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", (ret + 1) / 2);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\nint main(){\nint n;\nint m;\nint k;\ncin >>n;\ncin >>m;\ncin >>k;\nint a[m];\nint b[m];\nint l[m];\nint c;\nc=0;\nwhile(c<m){\ncin >>a[c];\ncin >>b[c];\ncin >>l[c];\nc=c+1;}\nint d[n];//確定\nint f[n];//暫定\nint e;\nc=0;\nwhile(c<n){\nd[c]=-1;\nf[c]=-1;\nc=c+1;}\nc=0;\nwhile(c<k){\ncin >>e;\nd[e-1]=0;\nf[e-1]=0;\nc=c+1;}\nint g;\nint h;\nc=k;\nwhile(c<n){\ne=0;\nwhile(e<m){\nif(d[a[e]-1]!=-1&&d[b[e]-1]==-1){\nf[b[e]-1]=d[a[e]-1]+l[e];}\nif(d[b[e]-1]!=-1&&d[a[e]-1]==-1){\nf[a[e]-1]=d[b[e]-1]+l[e];}\ne=e+1;}\ng=-1;\ne=0;\nwhile(e<n){\nif(d[e]==-1&&g>f[e]){g=f[e]; h=e;}\nelse if(d[e]==-1&&g==-1){g=f[e]; h=e;}\ne=e+1;}\nd[h]=f[h];\nc=c+1;}\ng=0;\nc=0;\nwhile(c<m){\nif(d[a[c]-1]-d[b[c]-1]==l[c]&&g<d[a[c]-1]){g=d[a[c]-1];}\nelse if(d[b[c]-1]-d[a[c]-1]==l[c]&&g<d[b[c]-1]){g=d[b[c]-1];}\nelse if((d[b[c]-1]+d[a[c]-1]+l[c])%2==0&&g<(d[b[c]-1]+d[a[c]-1]+l[c])/2){g=(d[b[c]-1]+d[a[c]-1]+l[c])/2;}\nelse if((d[b[c]-1]+d[a[c]-1]+l[c])%2==1&&g<(d[b[c]-1]+d[a[c]-1]+l[c])/2+1){g=(d[b[c]-1]+d[a[c]-1]+l[c])/2+1;}\nc=c+1;}\ncout <<g<<endl;}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <deque>\n#include <vector>\nusing namespace std;\n\nint road[1000001][3];\nint main() {\n\tint N,M,K;\n\tvector<pair<int,int> >nGo[3001];\n\tdeque<int> dis;\n\tint dist[3001];\n\tint signer[3001]={};\n\tfor(int i=1;i<=3000;i++)\n\t\tdist[i]=(1 << 30 );\n\tcin >> N >> M >> K;\n\tint a,b,c;\n\tfor(int i=0;i<M;i++){\n\t\tcin >> a >> b >> c;\n\t\tnGo[a].push_back(pair<int,int>(b,c));\n\t\tnGo[b].push_back(pair<int,int>(a,c));\n\t\troad[i][0]=a;\n\t\troad[i][1]=b;\n\t\troad[i][2]=c;\n\t}\n\tfor(int i=0;i<K;i++){\n\t\tcin >> a;\n\t//\tdis.insert(multimap<int,int>::value_type(0,a));\n\t\tdis.push_back(a);\n\t\tdist[a]=0;\n\t}\n\twhile(!dis.empty()){\n\t\tint miner=0;\n\t\tfor(int i=0;i<dis.size();i++)\n\t\tminer=(dist[dis[miner]]<dist[dis[i]]) ? miner:i;\n\t\tint r=dis[miner];\n\t\tdis[miner]=dis[0];\n\t\tdis[0]=r;\n\t\tint now=dis[0];\n\t\tfor(int i=0;i<nGo[now].size();i++){\n\t\t\tif(dist[nGo[now][i].first]>dist[now]+nGo[now][i].second){\n\t\t\t\tif(signer[nGo[now][i].first]==0){\n\t\t\t\tdis.push_back(nGo[now][i].first);\n\t\t\t\tsigner[nGo[now][i].first]=1;\n\t\t\t\t}\n\t\t\t\tdist[nGo[now][i].first]=dist[now]+nGo[now][i].second;\n\t\t\t}\n\t\t}\n\t\tdis.pop_front();\n\t}\n\tint maxer=0;\n\tfor(int i=0;i<M;i++)\n\tmaxer=max(maxer,(dist[road[i][0]]+dist[road[i][1]]+road[i][2]+1)/2);\n\tfor(int i=1;i<=N;i++)\n\tmaxer=max(maxer,dist[i]);\n\tcout << maxer <<  endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_to,int arg_dist){\n\t\tto = arg_to;\n\t\tdist = arg_dist;\n\t}\n\tint to,dist;\n};\n\nstruct Data{\n\tData(){\n\t\ttown = dist = 0;\n\t}\n\tData(int arg_town,int arg_dist){\n\t\ttown = arg_town;\n\t\tdist = arg_dist;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\t\treturn dist > arg.dist;\n\t};\n\tint town,dist;\n};\n\nint main(){\n\n\tint N,M,K;\n\tscanf(\"%d %d %d\",&N,&M,&K);\n\n\tint** road = new int*[N+1];\n\tfor(int i = 1; i <= N; i++){\n\t\troad[i] = new int[N+1];\n\t\tfor(int k = 1; k <= N; k++)road[i][k] = BIG_NUM;\n\t}\n\n\tint min_dist_to_market[N+1];\n\tfor(int i = 1; i <= N; i++)min_dist_to_market[i] = BIG_NUM;\n\n\tvector<Info> V[N+1];\n\n\tint from,to,dist;\n\tfor(int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d\",&from,&to,&dist);\n\t\tV[from].push_back(Info(to,dist));\n\t\tV[to].push_back(Info(from,dist));\n\t\troad[from][to] = dist;\n\t\troad[to][from] = dist;\n\t}\n\n\tbool is_mall[N+1];\n\tfor(int i = 1; i <= N; i++)is_mall[i] = false;\n\n\tint tmp;\n\n\tfor(int i = 0; i < K; i++){\n\t\tscanf(\"%d\",&tmp);\n\t\tis_mall[tmp] = true;\n\t\tmin_dist_to_market[tmp] = 0;\n\t}\n\n\tint ans = -1,min_index;\n\n\tpriority_queue<Data> Q;\n\n\tint tmp_min_dist[N+1];\n\n\tif(N-K <= K){\n\n\t\tfor(int start = 1; start <= N; start++){\n\t\t\tif(!is_mall[start]){\n\n\t\t\t\tfor(int i = 1; i <= N; i++)tmp_min_dist[i] = BIG_NUM;\n\n\t\t\t\ttmp_min_dist[start] = 0;\n\n\t\t\t\tfor(int i = 0; i < V[start].size();i++){\n\t\t\t\t\ttmp_min_dist[V[start][i].to] = V[start][i].dist;\n\t\t\t\t\tQ.push(Data(V[start][i].to,V[start][i].dist));\n\t\t\t\t}\n\n\n\t\t\t\twhile(!Q.empty()){\n\t\t\t\t\tif(Q.top().dist > tmp_min_dist[Q.top().town]){\n\t\t\t\t\t\tQ.pop();\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmin_index = Q.top().town;\n\t\t\t\t\t\tQ.pop();\n\n\t\t\t\t\t\tfor(int k = 0; k < V[min_index].size(); k++){\n\t\t\t\t\t\t\tif(tmp_min_dist[V[min_index][k].to] > tmp_min_dist[min_index]+V[min_index][k].dist){\n\t\t\t\t\t\t\t\ttmp_min_dist[V[min_index][k].to] = tmp_min_dist[min_index]+V[min_index][k].dist;\n\t\t\t\t\t\t\t\tQ.push(Data(V[min_index][k].to,tmp_min_dist[V[min_index][k].to]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint tmp_min = BIG_NUM;\n\n\t\t\t\tfor(int i = 1; i <= N; i++){\n\t\t\t\t\tif(is_mall[i] == true){\n\t\t\t\t\t\ttmp_min = min(tmp_min,tmp_min_dist[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmin_dist_to_market[start] = tmp_min;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tans = max(ans,min_dist_to_market[i]);\n\t\t}\n\n\t}else{\n\n\t\tfor(int start = 1; start <= N; start++){\n\t\t\tif(is_mall[start]){\n\n\t\t\t\tfor(int i = 1; i <= N; i++)tmp_min_dist[i] = BIG_NUM;\n\n\t\t\t\ttmp_min_dist[start] = 0;\n\n\t\t\t\tfor(int i = 0; i < V[start].size();i++){\n\t\t\t\t\ttmp_min_dist[V[start][i].to] = V[start][i].dist;\n\t\t\t\t\tQ.push(Data(V[start][i].to,V[start][i].dist));\n\t\t\t\t}\n\n\n\t\t\t\twhile(!Q.empty()){\n\t\t\t\t\tif(Q.top().dist > tmp_min_dist[Q.top().town]){\n\t\t\t\t\t\tQ.pop();\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmin_index = Q.top().town;\n\t\t\t\t\t\tQ.pop();\n\n\t\t\t\t\t\tfor(int k = 0; k < V[min_index].size(); k++){\n\t\t\t\t\t\t\tif(tmp_min_dist[V[min_index][k].to] > tmp_min_dist[min_index]+V[min_index][k].dist){\n\t\t\t\t\t\t\t\ttmp_min_dist[V[min_index][k].to] = tmp_min_dist[min_index]+V[min_index][k].dist;\n\t\t\t\t\t\t\t\tQ.push(Data(V[min_index][k].to,tmp_min_dist[V[min_index][k].to]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int i = 1; i <= N; i++){\n\t\t\t\t\tif(is_mall[i] == false && min_dist_to_market[i] > tmp_min_dist[i]){\n\t\t\t\t\t\tmin_dist_to_market[i] = tmp_min_dist[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tans = max(ans,min_dist_to_market[i]);\n\t\t}\n\t}\n\n\tfor(int i = 1; i < N; i++){\n\t\tfor(int k = i+1; k <= N; k++){\n\t\t\tif(road[i][k] != BIG_NUM){\n\t\t\t\tif(min_dist_to_market[i] == min_dist_to_market[k]){\n\n\t\t\t\t\tans = max(ans,min_dist_to_market[i]+(road[i][k]+1)/2);\n\n\t\t\t\t}else if(min_dist_to_market[i] > min_dist_to_market[k]){\n\n\t\t\t\t\tans = max(max(ans,road[i][k]-1),min_dist_to_market[i]+1);\n\n\t\t\t\t}else{ //min_dist_to_market[i] < min_dist_to_market[k]\n\n\t\t\t\t\tans = max(max(ans,road[i][k]-1),min_dist_to_market[k]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\nstruct Edge {\n\tlong long int to;\n\tlong long int cost;\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M >> K;\n\tvector<vector<Edge>>edge(N + 1);\n\tvector<long long int>dis(N + 1, MOD);\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> L >> R >> H;\n\t\tedge[L].push_back({ R,H });\n\t\tedge[R].push_back({ L,H });\n\t}\n\tpriority_queue<pair<long long int, int>, vector<pair<long long int, int>>, greater<pair<long long int, int>>>PQ;\n\tfor (int i = 0; i < K; i++) {\n\t\tcin >> L;\n\t\tdis[L] = 0;\n\t\tPQ.push({ 0,L });\n\t}\n\twhile (!PQ.empty()) {\n\t\tint cn = PQ.top().second;\n\t\tlong long int c = PQ.top().first;\n\t\tPQ.pop();\n\t\tif (c > dis[cn])continue;\n\t\tfor (auto i : edge[cn]) {\n\t\t\tif (dis[i.to] > dis[cn] + i.cost) {\n\t\t\t\tdis[i.to] = dis[cn] + i.cost;\n\t\t\t\tPQ.push({ dis[i.to],i.to });\n\t\t\t}\n\t\t}\n\t}\n\tlong long int ans = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tans = max(ans, dis[i]);\n\t\tfor (auto j : edge[i]) {\n\t\t\tif (abs(dis[i] - dis[j.to]) < j.cost) {\n\t\t\t\tlong long int box = j.cost - abs(dis[i] - dis[j.to]);\n\t\t\t\tbox = box / 2 + (box & 1);\n\t\t\t\tans = max(ans, max(dis[i], dis[j.to] + box));\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n#define rep(i, n) for(int(i) = 0; (i) < (n); (i)++)\n#define FOR(i, m, n) for(int(i) = (m); (i) < (n); (i)++)\n#define All(v) (v).begin(), (v).end()\n#define pb push_back\n#define MP(a, b) make_pair((a), (b))\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nconst int INF = 1 << 30;\nconst ll LINF = 1LL << 60;\nconst int MOD = 1e9 + 7;\n\nstruct edge {\n    edge(int t, ll c) : to(t), cost(c) {}\n    int to;\n    ll cost;\n};\n\nvoid dijkstra(int s, vector<ll> &d, vector<vector<edge>> &G) {\n    priority_queue<pll, vector<pll>, greater<pll>> que;\n    fill(All(d), LINF);\n    d[s] = 0;\n    que.push(make_pair(0, s));\n\n    while(!que.empty()) {\n        pll p = que.top();\n        que.pop();\n        int v = p.second;\n        if(d[v] < p.first)\n            continue;\n        for(auto e : G[v]) {\n            if(d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                que.push(make_pair(d[e.to], e.to));\n            }\n        }\n    }\n}\n\nint main() {\n    int N, M, K;\n    cin >> N >> M >> K;\n    vector<vector<edge>> G(N + 1, vector<edge>());\n    vector<pair<pii, int>> edges(M);\n    rep(i, M) {\n        ll a, b, c;\n        cin >> a >> b >> c;\n        a--, b--;\n        G[a].push_back(edge(b, c));\n        G[b].push_back(edge(a, c));\n        edges[i] = MP(MP(a, b), c);\n    }\n\n    rep(i, K) {\n        int k;\n        cin >> k;\n        k--;\n        G[N].push_back(edge(k, 0));\n    }\n    vector<ll> dist(N + 1);\n    dijkstra(N, dist, G);\n    ll res = 0;\n    rep(i, N) { res = max(res, dist[i]); }\n    rep(i, M) {\n        int a = edges[i].first.first;\n        int b = edges[i].first.second;\n        ll c = edges[i].second;\n        res = max(res, (dist[a] + dist[b] + c + 1) / 2);\n    }\n    cout << res << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <algorithm>\ntemplate <size_t N, typename COST_T, COST_T INF>\nclass Dijkstra\n{\npublic:\n\tstruct Path\n\t{\n\t\tint connectingIndex;\n\t\tCOST_T cost;\n\t};\n\n\tstruct Agent\n\t{\n\t\tint index;\n\t\tCOST_T cost;\n\n\t\tbool operator<(const Agent& rhs) const\n\t\t{\n\t\t\treturn cost > rhs.cost;\n\t\t}\n\t};\n\n\tDijkstra()\n\t{\n\t\tinit_paths();\n\t}\n\n\tvoid init_paths()\n\t{\n\t\tedges.assign(N, std::vector<Path>());\n\t}\n\n\tvoid add_path(int from, int to, COST_T cost)\n\t{\n\t\tedges[from].push_back(Path{ to, cost });\n\t}\n\n\tvoid add_path_undirected(int node1, int node2, COST_T cost)\n\t{\n\t\tedges[node1].push_back(Path{ node2, cost });\n\t\tedges[node2].push_back(Path{ node1, cost });\n\t}\n\n\tvoid find_shortest_path(std::vector<int> start_indices)\n\t{\n\t\t// initialize\n\t\tque = std::priority_queue<Agent>();\n\t\tfill(begin(minimum_cost), end(minimum_cost), INF);\n\n\t\tfor (int start_index : start_indices)\n\t\t{\n\t\t\tque.push(Agent{ start_index, /*cost*/0 });\n\t\t}\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tAgent agent = que.top(); que.pop();\n\t\t\t\t\n\t\t\tif (minimum_cost[agent.index] <= agent.cost)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tminimum_cost[agent.index] = agent.cost;\n\n\t\t\tfor (auto path : edges[agent.index])\n\t\t\t{\n\t\t\t\tint next_index = path.connectingIndex;\n\t\t\t\tCOST_T next_cost = agent.cost + path.cost;\n\t\t\t\tif (minimum_cost[next_index] > next_cost)\n\t\t\t\t{\n\t\t\t\t\tque.push(Agent{ next_index,\n\t\t\t\t\t                next_cost });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tCOST_T get_cost(int index) const\n\t{\n\t\treturn minimum_cost[index];\n\t}\n\n\tstd::vector<std::vector<Path>> edges;\n\tstd::priority_queue<Agent> que;\n\tint start;\n\tint goal;\n\tCOST_T minimum_cost[N];\n\tint prev_node[N];\n};\n\n#include <iostream>\n#include <tuple>\nusing namespace std;\n\nint N, M, K;\nconst int INF = 1e9;\nDijkstra<3001, int, INF> dijkstra;\nvector<tuple<int, int, int>> edges;\n\nint main()\n{\n\tcin >> N >> M >> K;\n\tfor (int i = 0; i < N; ++i)\n\t{\n\t\tint a, b, l;\n\t\tcin >> a >> b >> l;\n\t\tdijkstra.add_path_undirected(a, b, l);\n\t\tedges.emplace_back(a, b, l);\n\t}\n\n\tvector<int> start_indices;\n\tfor (int i = 0; i < K; ++i)\n\t{\n\t\tint s;\n\t\tcin >> s;\n\t\tstart_indices.push_back(s);\n\t}\n\n\tdijkstra.find_shortest_path(start_indices);\n\n\tint max_distance = 0;\n\tfor (auto edge : edges)\n\t{\n\t\tint a = std::get<0>(edge);\n\t\tint b = std::get<1>(edge);\n\t\tint l = std::get<2>(edge);\n\t\tint a_distance = dijkstra.get_cost(a);\n\t\tint b_distance = dijkstra.get_cost(a);\n\t\tint distance = a_distance\n\t\t\t+ (b_distance - a_distance + l) / 2\n\t\t\t+ (b_distance - a_distance + l) % 2;\n\t\tmax_distance = max(max_distance, distance);\n\t}\n\tcout << max_distance << endl;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2000000000;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)     (x).begin(),(x).end()\n# define UNIQ(c)    (c).erase(unique(ALL((c))), end((c)))\n# define mp         make_pair\n# define eb         emplace_back\n# define FOR(i,a,b) for(int i=(a);i<(b);++i)\n# define REP(i,n)   FOR(i,0,n)\n# define INIT       std::ios::sync_with_stdio(false);std::cin.tie(0);\n\nint V, E;\nstruct edge { LL to, cost; };\n\ntypedef pair<LL, LL> PP;\n\nLL d[100100]; //?????¢\nvector<edge> vec[100100];\n\nLL dijkstra() {\n\tfor (int i = 0; i < 100100; i++)d[i] = LINF;\n\tpriority_queue<PP, std::vector<PP>, std::greater<PP>> pq;\n\td[100001] = 0;\n\tpq.push(make_pair(d[100001], 100001));//cost,to\n\twhile (!pq.empty()) {\n\t\tPP p = pq.top();\n\t\tpq.pop();\n\t\tint i = p.second;\n\t\tif (d[i] < p.first)continue;\n\t\tfor (int k = 0; k < vec[i].size(); k++) {\n\t\t\tedge e = vec[i][k];\n\t\t\tif (d[e.to] <= d[i] + e.cost)continue;\n\t\t\td[e.to] = d[i] + e.cost;\n\t\t\tpq.push(make_pair(d[e.to], e.to));\n\t\t}\n\t}\n\treturn d[V - 1];\n}\n\nint k;\nint tyolisa[101010], tyolisb[101010], tyolisc[101010];\nint main() {\n\tcin >> V >> E >> k;\n\tint a, b, c;\n\tfor (int i = 0; i < E; i++) {\n\t\tcin >> a >> b >> c;\n\t\ta--, b--;\n\t\ttyolisa[i] = a, tyolisb[i] = b, tyolisc[i] = c;\n\t\tvec[a].push_back(edge{ b,c });\n\t\tvec[b].push_back(edge{ a,c });\n\t}\n\tfor (int i = 0; i < k; i++) {\n\t\tint t;\n\t\tcin >> t;\n\t\tt--;\n\t\tvec[100001].emplace_back(edge{ t,0 });\n\t}\n\tdijkstra();\n\tLL ans = 0;\n\tfor (int i = 0; i < E; i++) {\n\t\tans = max((d[tyolisa[i]] + d[tyolisb[i]] + tyolisc[i]) / 2 + ((d[tyolisa[i]] + d[tyolisb[i]] + tyolisc[i]) % 2 == 1 ? 1 : 0), ans);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<int, int> P;\nstruct edge{int to, cost;};\n\nstatic const int MAX_N = 3000;\nstatic const int INF = 1 << 30;\n\nint N, M, K;\nvector<edge> G[MAX_N];\nint dist[MAX_N];\n\nint main(){\n\tscanf(\"%d %d %d\", &N, &M, &K);\n\tfor(int i = 0; i < M; i++){\n\t\tint a, b, l;\n\t\tscanf(\"%d %d %d\", &a, &b, &l);\n\t\ta--; b--;\n\t\tG[a].push_back((edge){b, l});\n\t\tG[b].push_back((edge){a, l});\n\t}\n\tfill(dist, dist + N, INF);\n\tfor(int i = 0; i < K; i++){\n\t\tint s;\n\t\tscanf(\"%d\", &s);\n\t\ts--;\n\t\tdist[s] = 0;\n\t\tpriority_queue<P, vector<P>, greater<P> > pqa;\n\t\tpqa.push(P(0, s));\n\t\twhile(!pqa.empty()){\n\t\t\tP p = pqa.top(); pqa.pop();\n\t\t\tint d = p.first;\n\t\t\tint u = p.second;\n\t\t\tif(dist[u] < d) continue;\n\t\t\tfor(int j = 0; j < G[u].size(); j++){\n\t\t\t\tedge e = G[u][j];\n\t\t\t\tif(dist[e.to] > dist[u] + e.cost){\n\t\t\t\t\tdist[e.to] = dist[u] + e.cost;\n\t\t\t\t\tpqa.push(P(dist[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint res = 0;\n\tfor(int i = 0; i < N; i++) res = max(res, dist[i]);\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\tif(G[i][j].cost < abs(dist[i] - dist[G[i][j].to])) continue;\n\t\t\tint mid_dist = dist[i] + dist[G[i][j].to] + G[i][j].cost;\n\t\t\tmid_dist = (mid_dist % 2 == 0 ? mid_dist / 2 : mid_dist / 2 + 1);\n\t\t\tres = max(res, mid_dist);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <utility>\n#include <cmath>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define INF 0x7fffffff\n\nclass Edge {\npublic:\n    int from;\n    int to;\n    int len;\n};\n\nclass Vertex {\npublic:\n    vector<Edge*> children;\n};\n\nVertex vs[3000];\nEdge es[20000];\nint n, m, k;\nvector<int> malls;\nint direction[3000];\nint to_mall[3000];\nbool used[3000];\n\nint main() {\n   float max_d;\n\n   scanf(\"%d %d %d\", &n, &m, &k);\n   for (int i=0; i<m; i++) {\n       int a, b, l;\n\n       scanf(\"%d %d %d\", &a, &b, &l);\n       --a;\n       --b;\n       es[i*2].from = a;\n       es[i*2].to = b;\n       es[i*2].len = l;\n       es[i*2+1].from = b;\n       es[i*2+1].to = a;\n       es[i*2+1].len = l;\n       vs[a].children.push_back(&es[i*2]);\n       vs[b].children.push_back(&es[i*2+1]);\n   }\n\n   for (int i=0; i<k; i++) {\n       int s;\n\n       scanf(\"%d\", &s);\n       --s;\n       malls.push_back(s);\n   }\n\n   for (int i=0; i<n; i++) {\n       int min_d;\n       priority_queue<P, vector<P>, greater<P> > q;\n\n       fill(direction, direction+n, INF);\n       fill(used, used+n, false);\n\n       direction[i] = 0;\n       q.push(make_pair(i, 0));\n       while (!q.empty()) {\n           P p = q.top(); q.pop();\n           int s = p.first;\n\n           if (direction[s] < p.second) continue;\n           for (int j=0; j < vs[s].children.size(); j++) {\n               Edge *e = vs[s].children[j];\n               if (direction[e->to] > direction[s] + e->len) {\n                   direction[e->to] = direction[s] + e->len;\n                   q.push(make_pair(e->to, direction[e->to]));\n               }\n           }\n       }\n\n       to_mall[i] = -1;\n       for (int j=0; j < malls.size(); j++) {\n           int t = malls[j];\n\n           if (to_mall[i] == -1 || to_mall[i] > direction[t]) {\n               to_mall[i] = direction[t];\n           }\n       }\n   }\n\n   max_d = 0;\n   for (int i=0; i<m; i++) {\n       int a = es[i*2].from;\n       int b = es[i*2].to;\n       int l = es[i*2].len;\n       float d = (to_mall[a] + to_mall[b] + l) / 2.0;\n\n       if (d > max_d) {\n           max_d = d;\n       }\n   }\n\n   printf(\"%d\\n\", (int)ceil(max_d));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct edge{\n    int to;\n    int cost;\n};\nclass Situation{\npublic:\n\tint cost;\n\tint idx;\n\n\tSituation(int cost_,int idx_){\n\t\tcost=cost_;\n\t\tidx=idx_;\n\t}\n\tSituation();\n\n\tbool operator<(const Situation &s)const{\n\t\treturn s.cost < this->cost;\n\t}\n};\nconst int MAX_V=3001;\n\nint N,M,K;\nvector<edge> G[MAX_V];\nbool isShop[MAX_V];\nint d[MAX_V];\nconst int INF=1000000000;\nint froms[MAX_V];\nint tos[MAX_V];\nint costs[MAX_V];\n\nvoid dijkstra(int s){\n\tpriority_queue<Situation> que;\n\td[s] = 0;\n\tque.push(Situation(0,s));\n\twhile(!que.empty()){\n\t\tSituation p = que.top();\n\t\tque.pop();\n\t\tint v = p.idx;\n\t\tif(d[v] < p.cost)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost){\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(Situation(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n    cin>>N>>M>>K;\n    for(int i=0;i<M;i++){\n        edge e;\n        int from,to,cost;\n        cin>>from>>to>>cost;\n        from--;to--;\n        froms[i]=from;\n        tos[i]=to;\n        costs[i]=cost;\n        e.to=to;\n        e.cost=cost;\n        G[from].push_back(e);\n        e.to=from;\n        G[to].push_back(e);\n    }\n\tfill(d,d+MAX_V,INF);\n    for(int i=0;i<K;i++){\n        int a;\n        cin>>a;\n        a--;\n        dijkstra(a);\n    }\n    double res=0;\n    for(int i=0;i<N;i++)\n        res=max(res,(double)d[i]);\n    for(int i=0;i<M;i++){\n        for(int j=0;j<=costs[i];j++){\n            double dit=min(d[froms[i]]+costs[i]-j,d[tos[i]]+j);\n            res=max(dit,res);\n        }\n    }\n    printf(\"%.0f\\n\",res);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3002\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<P> G[N];\nbool num[N];\nint n,m,K;\n\ndouble dijkstra(){\n  int D[N];\n  for(int i=0;i<N;i++) D[i] = 1e9;\n  \n  vector<int>pre[N];\n  priority_queue<PP,vector<PP>,greater<PP> >Q;\n  \n  for(int i=0;i<N;i++)\n    if(num[i]) {\n      Q.push(PP(0,P(i,i)));\n      D[i] = 0;\n      pre[i].push_back(i);\n    }\n  \n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first;\n    int pos = t.second.first;\n    int start = t.second.second;\n\n    if(D[pos]<cost) continue;\n    pre[pos].push_back(start);\n    \n    for(int i=0;i<G[pos].size();i++){\n      int npos = G[pos][i].first;\n      int ncost = cost+G[pos][i].second;\n      if(D[npos]<ncost) continue;\n      Q.push(PP(ncost,P(npos,start)));\n      D[npos] = ncost;\n    }\n  }\n\n\n  double res = 0;\n  for(int i=0;i<n;i++){\n    if(pre[i].size()>=2)res = max(res,(double)D[i]);\n    res = max(res,D[i]/2.0);\n    \n    for(int j=0;j<G[i].size();j++){\n      int npos = G[i][j].first;\n      int ncost = G[i][j].second;\n      if(pre[npos][0] == pre[i][0]){\n\tif(abs(D[i]-D[npos])!=ncost) res = max(res,(D[i]+D[npos]+ncost)/2.0);\n      }\n      else res = max(res,(D[i]+D[npos]+ncost)/2.0);\n    }\n  }\n  return res;\n  \n}\n\nint main(){\n  \n  cin>>n>>m>>K;\n  for(int i=0,a,b,c;i<m;i++){\n    cin>>a>>b>>c;\n    G[a-1].push_back(P(b-1,c));\n    G[b-1].push_back(P(a-1,c));\n  }\n\n  for(int i=0,a;i<K;i++)cin>>a,num[a-1]=1;\n  printf(\"%d\\n\",(int)(dijkstra()+0.5));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n\nconst int INF=2000000000;\n\nstruct edge{ int to; int cost; };\nedge mke(int t,int c){ edge ed; ed.to=t; ed.cost=c; return ed;}\n\nstruct status{ int x; int cost; };\nstatus mks(int x,int c){ status s; s.x=x; s.cost=c; return s;}\nstruct compare{\n\tbool operator()(status x,status y) const {\n\t\treturn x.cost>y.cost;\n\t}\n};\n\nint main(){\nstatic\tint n,m,k,a[100002],b[100002],l[100002],s;\nstatic\tvector<edge> G[3002];\nstatic\tint cost[3002]; for(int i=0;i<3002;i++)cost[i]=INF;\nstatic\tbool used[3002]; for(int i=0;i<3002;i++)used[i]=false;\nstatic\tpriority_queue<status,vector<status>,compare> que;\n\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d%d\",&a[i],&b[i],&l[i]);\n\t\tG[a[i]].push_back(mke(b[i],l[i]));\n\t\tG[b[i]].push_back(mke(a[i],l[i]));\n\t}\n\tfor(int i=0;i<k;i++){\n\t\tscanf(\"%d\",&s);\n\t\tque.push(mks(s,0));\n\t}\n\n\twhile(!que.empty()){\n\t\tstatus s=que.top(); que.pop();\n\t\tif(!used[s.x]){\n\t\t\tcost[s.x]=s.cost;\n\t\t\tfor(int i=0;i<G[s.x].size();i++){\n\t\t\t\tedge ed=G[s.x][i];\n\t\t\t\tif(cost[ed.to]>cost[s.x]+ed.cost){\n\t\t\t\t\tcost[ed.to]=cost[s.x]+ed.cost;\n\t\t\t\t\tque.push(mks(ed.to,cost[ed.to]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tused[s.x]=true;\n\t\t}\n\t}\n/*\nfor(int i=1;i<=n;i++){\n\tprintf(\"%d\\n\",cost[i]);\n}\n*/\n\tint ret=0;\n\tfor(int i=0;i<m;i++){\n\t\tret=max(ret,(cost[a[i]]+cost[b[i]]+l[i]+1)/2);\n\t}\n\n\tprintf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <cmath>\n#define INF 1e+9\nusing namespace std;\n\ntypedef pair<int,int> P;\nstruct edge{ int to,cost; };\n\nint main(){\n\tint n,m,k,a,b,l,s;\n\tint d[3000];\n\tvector<edge> G[3000];\n\tqueue<P> que; \n\tcin >> n >> m >> k;\n\tfor(int i = 0;i < n;i++) {\n\t\td[i] = INF;\n\t}\n\tfor(int i = 0;i < m;i++){\n\t\tcin >> a >> b >> l;\n\t\tG[a - 1].push_back({b - 1,l});\n\t\tG[b - 1].push_back({a - 1,l});\n\t}\n\tfor(int i = 0;i < k;i++){\n\t\tcin >> s;\n\t\tque.push(P(s - 1,0));\n\t}\n\twhile(!que.empty()){\n\t\tP p = que.front();que.pop();\n\t\tif(d[p.first] <= p.second) continue;\n\t\td[p.first] = p.second;\n\t\tfor(int i = 0;i < G[p.first].size();i++){\n\t\t\tif(d[p.first] + G[p.first][i].cost < d[G[p.first][i].to]) que.push({G[p.first][i].to,d[p.first] + G[p.first][i].cost});\n\t\t}\n\t}\n\tdouble ma = 0;\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = 0;j < G[i].size();j++){\n\t\t\tma = max(ma,(double)(d[i] + d[G[i][j].to] + G[i][j].cost) / 2.0);\n\t\t}\n\t}\n\tcout << (int)round(ma) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n *  頭ついてない\n *  まるで食べられたアンパンマンみたい\n */\n\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define INF 0x40000000\n\nclass Edge {\npublic:\n    int from;\n    int to;\n    int len;\n};\n\nclass Vertex {\npublic:\n    vector<Edge*> children;\n};\n\nVertex vs[3000];\nEdge es[200000];\nint n, m, k;\nint to_mall[3000];\npriority_queue<P, vector<P>, greater<P> > q;\nint min_d;\nfloat answer;\n\nint main() {\n\n   scanf(\" %d %d %d\", &n, &m, &k);\n   for (int i=0; i<m; i++) {\n       int a, b, l;\n\n       scanf(\" %d %d %d\", &a, &b, &l);\n       --a;\n       --b;\n       es[i*2].from = a;\n       es[i*2].to = b;\n       es[i*2].len = l;\n       es[i*2+1].from = b;\n       es[i*2+1].to = a;\n       es[i*2+1].len = l;\n       vs[a].children.push_back(&es[i*2]);\n       vs[b].children.push_back(&es[i*2+1]);\n   }\n\n   fill(to_mall, to_mall+n, INF);\n   for (int i=0; i<k; i++) {\n       int s;\n\n       scanf(\"%d\", &s);\n       --s;\n       to_mall[s] = 0;\n       q.push(make_pair(s, 0));\n   }\n\n\n   while (!q.empty()) {\n       P p = q.top(); q.pop();\n       int s = p.first;\n\n       if (to_mall[s] < p.second) continue;\n       for (int j=0; j < vs[s].children.size(); j++) {\n           Edge *e = vs[s].children[j];\n           if (to_mall[e->to] > to_mall[s] + e->len) {\n               to_mall[e->to] = to_mall[s] + e->len;\n               q.push(make_pair(e->to, to_mall[e->to]));\n           }\n       }\n   }\n\n   answer = 0;\n   for (int i=0; i<m*2; i++) {\n       int a = es[i].from;\n       int b = es[i].to;\n       int l = es[i].len;\n       float d = (to_mall[a] + to_mall[b] + l) / 2.0;\n\n       if (d > answer) {\n           answer = d;\n       }\n   }\n\n   printf(\"%d\\n\", (int)ceil(answer));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <list>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef vector <int> VI;\ntypedef pair <int, int> NODE;\ntypedef priority_queue <NODE, vector <NODE>, greater <NODE> > QUEUE;\ntypedef pair <int, int> PII;\ntypedef vector <PII> VPII;\n\nconst int size = 3001;\nint P[size][size];\nint PC[size];\nint L[size][size];\nconst int inf = INT_MAX;\n\nvoid init() {\n    for ( int i = 0; i < size; ++ i ) {\n        PC[i] = 0;\n    }\n}\n\nint main() {\n    int n, m, k;\n    while ( cin >> n >> m >> k ) {\n        VPII R;\n        for ( int i = 0; i < m; ++ i ) {\n            int a, b, l; // a-b: l\n            cin >> a >> b >> l;\n            a --;\n            b --;\n            P[a][PC[a]++] = b;\n            P[b][PC[b]++] = a;\n            L[a][b] = L[b][a] = l;\n            R.push_back( PII( a, b ) );\n        }\n        VI starts;\n        QUEUE Q;\n        VI D( n, inf );\n        for ( int i = 0; i < k; ++ i ) {\n            int a;\n            cin >> a;\n            a --;\n            starts.push_back( a );\n            Q.push( NODE( 0, a ) );\n        }\n\n        bool used[size];\n        for ( int i = 0; i < size; ++ i ) used[i] = false;\n        while ( ! Q.empty() ) {\n            NODE node = Q.top();\n            Q.pop();\n\n            int cost = node.first;\n            int src = node.second;\n\n            if ( used[src] ) continue;\n            used[src] = true;\n            D[src] = cost;\n            for ( int i = 0; i < PC[src]; ++ i ) {\n                int dst = P[src][i];\n                int ncost = cost + L[src][dst];\n                Q.push( PII( ncost, dst ) );\n            }\n        }\n\n        int answer = 0;\n        for ( int i = 0; i <(int)R.size(); ++ i ) {\n            int src = R[i].first;\n            int dst = R[i].second;\n            answer = max( answer, ( D[src] + D[dst] + L[src][dst] + 1 ) / 2 );\n        }\n\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1e9\ntypedef long long LL;\ntypedef pair<int,int>P;\nstruct edge{int to,cost;};\n\nvector<edge>G[3390];\nint dis[3390];\n\nvoid dijkstra(int s){\n\tpriority_queue<P,vector<P>,greater<P> >Q;\n\tfill(dis,dis+3141,INF);\n\tdis[s]=0;\n\tQ.push(P(0,s));\n\t\n\twhile(Q.size()){\n\t\tP p=Q.top();\n\t\tQ.pop();\n\t\tint v=p.second;\n\t\tif(dis[v]<p.first)continue;\n\t\t\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tedge e=G[v][i];\n\t\t\tif(dis[e.to]>dis[v]+e.cost){\n\t\t\t\tdis[e.to]=dis[v]+e.cost;\n\t\t\t\tQ.push(P(dis[e.to],e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nint main(){\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\t\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tG[a-1].push_back({b-1,c});\n\t\tG[b-1].push_back({a-1,c});\n\t\t}\n\t\t\n\tfor(int i=0;i<k;i++){\n\t\tint a;\n\t\tcin>>a;\n\t\tG[3235].push_back({a-1,0});\n\t\t}\t\n\t\t\n\tdijkstra(3235);\n\t\n\tint ans=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<G[i].size();j++){\n\t\t\tans=max(ans,max(dis[i],dis[G[i][j].to]));\n\t\t\tif(dis[i]==dis[G[i][j].to]){\n\t\t\t\tint d=0;\n\t\t\t\tfor(int l=0;l<G[i].size();l++){\n\t\t\t\t\tif(G[i][l].to==j){\n\t\t\t\t\t\td=G[i][l].cost;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\td=(d+1)/2;\n\t\t\t\tans=max(ans,dis[i]+d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t\tcout<<ans<<endl;\n\t\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={1,0,-1,0,1,-1,-1,1};\nconst int dy[]={0,1,0,-1,1,1,-1,-1};\nconst int INF = 1<<30;\nconst int EPS = 1e-8;\n#define PB push_back\n#define mk make_pair\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int > Pii;\nclass edge{\n\tpublic:\n\tint to;\n\tint cost;\n\tedge(){}\n\tedge(int _to,int _cost){\n\t\tto = _to;\n\t\tcost = _cost;\n\t}\n\tbool operator<(const edge &a)const{\n\t\treturn cost>=a.cost;\n\t}\n};\nvector < edge > G[3002];\nint path[3002];\nint N,M,K;\nvoid dijkstra(int s[3002]){\n\n\tpriority_queue<edge> Q;\n\trep(i,K){\n\t\tQ.push(edge(s[i],0));\n\t}\n\twhile(!Q.empty()){\n\t\tedge e = Q.top();\n\t\tQ.pop();\n\t\tif(path[e.to] < INF)continue;\n\t\tpath[e.to] = e.cost;\n\t\trep(i,G[e.to].size()){\n\t\t\tQ.push(edge(G[e.to][i].to,G[e.to][i].cost+e.cost));\n\t\t}\n\t}\n\treturn ;\n}\nint main(){\n\tscanf(\"%d%d%d\",&N,&M,&K);\n\tfill(path,path+N,INF);\n\trep(i,M){\n\t\tint a,b,c;\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\ta--;b--;\n\t\tG[a].PB(edge(b,c));\n\t\tG[b].PB(edge(a,c));\n\t}\n\tint s[3002];\n\trep(i,K){\n\t\tint tmp;\n\t\tscanf(\"%d\",&tmp);\n\t\ts[i] = --tmp;\n\t}\n\tdijkstra(s);\n\tdouble ans = 0;\n\trep(i,N){\n\t\trep(j,G[i].size()){\n\t\t\tint d = path[G[i][j].to]-path[i];\n\t\t\tif(d<0.0)continue;\n\t\t\tdouble g = path[i]+d+(G[i][j].cost-d)/2.0;\n\t\t\tans = max(g,ans);\n\t\t}\n\t}\n\tprintf(\"%.0lf\\n\",round(ans));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef int  i32;\ntypedef long long i64,ll;\n#define BR \"\\n\"\n\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\n\n//config\n#define MODE_DEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef MODE_DEBUG\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n\n#define  DUMP(x)  cerr << #x << \" = \" << (x) <<endl\n#define DEBUG(x) DUMP(x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMP(exp);DEBUG(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#else\n#define DUMP(x)\n#define DEBUG(x)\n#define CHECK(exp,act)\n#define STOP(e)\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\ntemplate<class T> inline string toString(const vector<vector<T>>& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\nnamespace ShortestPath{\n    const int INF=1<<30;\n    struct Edge{\n        int from,to,cost;\n        Edge(int from,int to,int cost)\n            : from(from),to(to),cost(cost) {};\n    };\n    ostream& operator <<(ostream& os,const Edge& e){\n            os<<\"(\"<<e.from<<\"->\"<<e.to<<\")\";\n            return os;\n    }\n    struct Task{\n        int prev,pos,cost;\n        Task(int prev,int pos,int cost)\n            :prev(prev),pos(pos),cost(cost){};\n        bool operator>(const Task& r) const{\n            return cost>r.cost;\n        }\n    };\n    typedef vector<vector<Edge> > Graph;\n    typedef  vector<vector<int> > Mat;\n\n    // 最大も可\n    // 負の閉路が判定可能\n    //O(V*E)\n    vector<int> bellmanFord(Graph g,int s,vector<int> prev){\n        const int V=g.size();\n        vector<int> d(V,INF);d[s]=0;\n        fill(ALL(prev),-2);\n        REP(k,V){\n            REP(i,V)REP(j,g[i].size()){\n                Edge e=g[i][j];\n                if(d[e.to]>d[e.from]+e.cost){\n                    d[e.to]=d[e.from]+e.cost;\n                    prev[e.to]=e.from;\n                    if(k==V-1)d[e.to]=-INF;\n                }\n            }\n        }\n        return d;\n    }    \n\n    //verified by codoforces 144D http://codeforces.com/contest/144/submission/4976825\n    // // 負の辺がない\n    // // O(E*logV)\n    vector<int> dijkstra(const Graph& g,const int s,vector<int>& prev){\n        const int V=g.size();\n        vector<int> d(V,INF);d[s]=0;\n        fill(ALL(prev), -2);\n        priority_queue<Task,vector<Task>,greater<Task> > que;\n        que.push(Task(-1,s,0));\n        while(!que.empty()){\n            Task task=que.top();que.pop();\n            //if(prev[task.pos]!=-2)continue;\n            if(d[task.pos]<task.cost)continue;\n            prev[task.pos]=task.prev;\n            EACH(e,g[task.pos]){\n                if(d[e->to]>d[e->from]+e->cost){\n                    d[e->to]=d[e->from]+e->cost;\n                    que.push(Task(e->from,e->to,d[e->to]));\n                }\n            }   \n        }\n        return d;\n    }\n    vector<int> dijkstra(const Graph& g,const int s){\n        vector<int> prev(g.size());return dijkstra(g,s,prev);\n    }\n\n    // O(n^3) n≦100\n    void warshall_floyd(Mat& d,Mat& prev){\n        const int V=d.size();\n        REP(k,V)\n            REP(i,V)REP(j,V){\n                if(d[i][j]>d[i][k] + d[k][j]){\n                    d[i][j]=d[i][k] + d[k][j];\n                    prev[i][j]=k;\n                }\n            }\n    }\n}\nusing namespace ShortestPath;\n\ndouble EPS=1e-5;\nint main(){\n\tint N,M,K;scanf(\"%d %d %d\",&N,&M,&K);\n\tGraph es(N);\n\tREP(i,M){\n\t\tint f,t,d;scanf(\"%d %d %d\",&f,&t,&d);f--;t--;\n\t\tes[f].push_back(Edge(f,t,d));\n\t\tes[t].push_back(Edge(t,f,d));\n\t}\n\tvector<int> ds(N,INF);\n\tREP(i,K){\n\t\tint l;scanf(\"%d\",&l);l--;\n\t\tvector<int> tmp=dijkstra(es,l);\n\n\t\tREP(j,N)ds[j]=min(ds[j],tmp[j]);\n\t}\n\t\n\tdouble res=0;\n\tREP(i,N)REP(j,es[i].size()){\n\t\tdouble l=0,r=es[i][j].cost;\n\t\twhile(r-l>EPS){\n\t\t\tdouble ml=(2*l+r)/3,mr=(l+2*r)/3;\n\n\t\t\tdouble lv=min(ml+ds[es[i][j].from],es[i][j].cost-ml+ds[es[i][j].to]);\n\t\t\tdouble rv=min(mr+ds[es[i][j].from],es[i][j].cost-mr+ds[es[i][j].to]);\n\t\t\tif(lv<=rv){\n\t\t\t\tl=ml;\n\t\t\t}else{\n\t\t\t\tr=mr;\n\t\t\t}\n\t\t}\n\t\tdouble v=min(l+ds[es[i][j].from],es[i][j].cost-l+ds[es[i][j].to]);\n\t\t//DUMP(l);\n//\t\tDUMP(v);\n\t\tres=max(res,v);\n\t}\n\tcout<<round(res+EPS) <<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\nconst int inf = (int)1e9;\nint n, m, k;\nint ans = inf;\nvector<int> dist;\nvector<vector<pair<int, int> > > graph;\nvector<pair<pair<int, int>, int> > edge;\nscanf(\"%d%d%d\", &n, &m, &k);\ndist.resize(n, inf);\ngraph.resize(n);\nfor(int i = 0; i < m; ++i) {\nint a, b, l;\nscanf(\"%d%d%d\", &a, &b, &l);\na -= 1, b -= 1;\nedge.push_back(make_pair(make_pair(a, b), l));\ngraph[a].push_back(make_pair(b, l));\ngraph[b].push_back(make_pair(a, l));\n}\nfor(int i = 0; i < k; ++i) {\nint s;\nscanf(\"%d\", &s);\ns -= 1;\npriority_queue<pair<int, int> > q;\nq.push(make_pair(0, s));\nwhile(!q.empty()) {\nint v = q.top().second;\nint c = -q.top().first;\nq.pop();\nif(dist[v] < c)\ncontinue;\ndist[v] = c;\nfor(int i = 0; i < graph[v].size(); ++i) {\nint w = graph[v][i].first;\nint d = graph[v][i].second + c;\nq.push(make_pair(-d, w));\n}\n}\n}\nfor(int i = 0; i < m; ++i) {\nint a = edge[i].first.first;\nint b = edge[i].first.second;\nint l = edge[i].second;\nif(dist[a] > dist[b])\nswap(a, b);\nint cost;\nif(dist[a] + l <= dist[b])\ncost = dist[b];\nelse\ncost = (l - (dist[b] - dist[a]) + 1) / 2;\nans = max(ans, cost);\n}\nprintf(\"%d\\n\", ans);\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#define PI 3.141592653589\n\n\n#define izryt bool\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\npii Dir[8] = { //?§????\n\t{ 0 ,1 },{ -1 ,0 },{ 1 ,0 },{ 0 ,-1 },\n\t{ 1 ,1 },{ 1 ,-1 },{ -1 ,1 },{ -1 ,-1 }\n};\n\nsigned main() {\n\tint n, m, k;\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tvector<vector<pii>> g(n);\n\tREP(i, m) {\n\t\tint a, b, c;\n\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\t\ta--; b--;\n\t\tg[a].push_back({ b,c });\n\t\tg[b].push_back({ a,c });\n\t}\n\tpriority_queue<pair<pii, int>, vector<pair<pii, int>>, greater<pair<pii, int>>> que;\n\tREP(i, k) {\n\t\tint a;\n\t\tscnaf(\"%d\", &a);\n\t\ta--;\n\t\tque.push({ { 0,a },-1 });\n\t}\n\tpii las;\n\tset<pii> r;\n\tvector<int> al(n,-1);\n\twhile (que.size()) {\n\t\tpair<pii,int> cur = que.top();\n\t\tque.pop();\n\n\t\tif (cur.second != -1) {\n\t\t\tpii can = { cur.second, cur.first.second };\n\t\t\tif (can.first > can.second) swap(can.first, can.second);\n\t\t\tif (r.find(can) == r.end()) {\n\t\t\t\tr.insert(can);\n\t\t\t\tlas = can;\n\t\t\t}\n\t\t}\n\n\t\tif (~al[cur.first.second])\n\t\t\tcontinue;\n\t\tal[cur.first.second] = cur.first.first;\n\n\t\tfor (auto itr : g[cur.first.second]) {\n\t\t\tif(!~al[itr.first])\n\t\t\t\tque.push({ {cur.first.first + itr.second, itr.first}, cur.first.second});\n\t\t}\n\t}\n\n\tint len;\n\tfor (auto itr : g[las.first]) {\n\t\tif (itr.first == las.second) {\n\t\t\tlen = itr.second;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint susu = abs(al[las.first]-al[las.second]);\n\tlen -= susu;\n\tprintf(\"%d\\n\", (len+1)/2 + max(al[las.first] , al[las.second]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//#define DEBUG\n#define INF 1000000000\n#define REP(i,n) for(int i=1;i<=n;i++)\nstruct E {int to,cost;};\nint n,m,k;\nvector<E> G[3002];\nvector<int> S;\nint D[3002];\n\nint main(){\n  cin>>n>>m>>k;\n  REP(i,m){\n    int a,b,l;\n    cin>>a>>b>>l;\n    G[a].push_back({b,l});\n    G[b].push_back({a,l});\n  }\n  REP(i,n)D[i]=INF;\n  REP(i,k){\n    int s;\n    cin>>s;\n    S.push_back(s);\n    D[s]=0;\n  }\n  for(int s : S){\n    queue<int> que;\n    que.push(s);\n    while(!que.empty()){\n      int t=que.front();que.pop();\n      for(E e : G[t]){\n        if(D[e.to]>D[t]+e.cost){\n          D[e.to]=D[t]+e.cost;\n          que.push(e.to);\n        }\n      }\n    }\n  }\n  int ans=0;\n  REP(i,n){\n    for(E e : G[i]){\n      int d=D[i]+D[e.to]+e.cost;\n      d-=d/2;\n      ans=max(ans,d);\n    }\n  }\n  cout<<ans<<endl;\n  #ifdef DEBUG\n  REP(i,n){\n    cout<<D[i]<<\" \";\n  }\n  #endif\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\nconst int inf = (int)1e9;\nint n, m, k;\nint ans = inf;\nvector<int> dist;\nvector<vector<pair<int, int> > > graph;\nvector<pair<pair<int, int>, int> > edge;\nscanf(\"%d%d%d\", &n, &m, &k);\ndist.resize(n, inf);\nfor(int i = 0; i < m; ++i) {\nint a, b, l;\nscanf(\"%d%d%d\", &a, &b, &l);\na -= 1, b -= 1;\nedge.push_back(make_pair(make_pair(a, b), l));\ngraph[a].push_back(make_pair(b, l));\ngraph[b].push_back(make_pair(a, l));\n}\nfor(int i = 0; i < k; ++i) {\nint s;\nscanf(\"%d\", &s);\ns -= 1;\npriority_queue<pair<int, int> > q;\nq.push(make_pair(0, s));\nwhile(!q.empty()) {\nint v = q.top().second;\nint c = -q.top().first;\nq.pop();\nif(dist[v] < c)\ncontinue;\ndist[v] = c;\nfor(int i = 0; i < graph[v].size(); ++i) {\nint w = graph[v][i].second;\nint d = graph[v][i].second + c;\nq.push(make_pair(-d, w));\n}\n}\n}\nfor(int i = 0; i < m; ++i) {\nint a = edge[i].first.first;\nint b = edge[i].first.second;\nint l = edge[i].second;\nif(dist[a] > dist[b])\nswap(a, b);\nint cost;\nif(dist[a] + l <= dist[b])\ncost = dist[b];\nelse\ncost = (l - (dist[b] - dist[a]) + 1) / 2;\nans = max(ans, cost);\n}\nprintf(\"%d\\n\", ans);\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef pair<int,int> edge;\n\nconst int INF = 1e9;\n\nint main(){\n  int n,m,k;\n  scanf(\"%d%d%d\",&n,&m,&k);\n  \n  vector< vector<edge> > g(n);\n  rep(i,m){\n    int a,b,l;\n    cin >> a >> b >> l; a--; b--;\n    g[a].push_back(edge(l,b));\n    g[b].push_back(edge(l,a));\n  }\n\n  vector<int> d(n,INF);\n  priority_queue< edge, vector<edge>, greater<edge> > q;\n  rep(i,k){\n    int s; cin >> s; s--;\n    d[s] = 0;\n    q.push(edge(0,s));\n  }\n\n  while(q.size()){\n    edge x = q.top(); q.pop();\n    int c = x.first, v = x.second;\n    \n    for(edge e : g[v]){\n      int nc = c + e.first;\n      int u = e.second;\n      \n      if(d[u] > nc){\n\td[u] = nc;\n\tq.push( edge(nc, u) );\n      }\n    }\n  }\n  \n  int ans = 0;\n  rep(a,n){\n    for(edge e : g[a]){\n      int l = e.first, b = e.second;\n      \n      int A = min(d[a], d[b]), B = max(d[a], d[b]);\n      if(A+l < B){\n\tans = max(ans, A+l);\n      }else{\n\tans = max(ans, (A+B+l+1)/2);\n      }\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nvector<P>E[3000];\nint d[3000];\nint main() {\n\tint n, m, k; scanf(\"%d%d%d\", &n, &m, &k);\n\trep(i, m) {\n\t\tint a, b, l; scanf(\"%d%d%d\", &a, &b, &l);\n\t\ta--; b--;\n\t\tE[a].push_back(P(l, b));\n\t\tE[b].push_back(P(l, a));\n\t}\n\tpriority_queue<P, vector<P>, greater<P>>que;\n\tmemset(d, 0x3f, sizeof(d));\n\trep(i, k) {\n\t\tint s; scanf(\"%d\", &s); s--;\n\t\td[s] = 0;\n\t\tque.push(P(0, s));\n\t}\n\twhile (!que.empty()) {\n\t\tP p = que.top(); que.pop();\n\t\tif (d[p.second] != p.first)continue;\n\t\tfor (P u : E[p.second]) {\n\t\t\tif (d[u.second] > p.first + u.first) {\n\t\t\t\td[u.second] = p.first + u.first;\n\t\t\t\tque.push(P(d[u.second], u.second));\n\t\t\t}\n\t\t}\n\t}\n\tdouble Max = 0;\n\trep(i, n) {\n\t\tfor (P u : E[i]) {\n\t\t\tfor (double t = 0; t <= u.first; t += 0.5)\n\t\t\t\tMax = max(Max, min(d[i] + t, d[u.second] + u.first - t));\n\t\t}\n\t}\n\tprintf(\"%d\\n\", (int)round(Max));\n}"
  },
  {
    "language": "C++",
    "code": "#include \"stdio.h\"\n#include \"stdlib.h\"\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint mati[3000];\nint matis[3000];\nint miti[100000][2];\nint miti2[3000][3000];\nint matiw[3000];\n\nint main()\n{\n\tint n,m,k;\n\n\t{\n\t\tscanf(\"%d %d %d\",&n,&m,&k);\n\t}\n\t\n\t{\n\t\tfor(int i = 0; i < 3000; i++)\n\t\t{\n\t\t\tfor(int ii = 0; ii < 3000; ii++)\n\t\t\t{\n\t\t\t\tmiti2[i][ii] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\t{\n\t\tfor(int i = 0; i < m; i++)\n\t\t{\n\t\t\tint w1,w2,w3;\n\t\t\tscanf(\"%d %d %d\",&w1,&w2,&w3);\n\t\t\tmiti[i][0] = w1 - 1;\n\t\t\tmiti[i][1] = w2 - 1;\n\t\t\tmiti2[w1 - 1][w2 - 1] = w3;\n\t\t\tmiti2[w2 - 1][w1 - 1] = w3;\n\t\t}\n\t}\n\n\t{\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tmati[i] = INT_MAX;\n\t\t\tmatis[i] = 0;\n\t\t}\n\t}\n\n\t{\n\t\tint w;\n\t\tfor(int i = 0; i < k; i++)\n\t\t{\n\t\t\tscanf(\"%d\",&w);\n\t\t\tmati[w - 1] = 0;\n\t\t}\n\t}\n\n\t{\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor(int ii = 0; ii < n; ii++)\n\t\t\t{\n\t\t\t\tif(matis[ii] == 0)\n\t\t\t\t{\n\t\t\t\t\tmatiw[ii] = mati[ii];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tmatiw[ii] = INT_MAX;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(matiw,matiw + n);\n\t\t\tfor(int ii = 0; ii < n; ii++)\n\t\t\t{\n\t\t\t\tif(mati[ii] == matiw[0] && matis[ii] == 0)\n\t\t\t\t{\n\t\t\t\t\tfor(int iii = 0; iii < n; iii++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(miti2[ii][iii] != -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(mati[iii] > mati[ii] + miti2[ii][iii])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmati[iii] = mati[ii] + miti2[ii][iii];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmatis[ii] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint l = 0;\n\n\t{\n\t\tint w,w1,w2;\n\t\tfor(int i = 0; i < m; i++)\n\t\t{\n\t\t\tw1 = miti[i][0];\n\t\t\tw2 = miti[i][1];\n\t\t\tif(mati[w1] == mati[w2] + miti2[w1][w2])\n\t\t\t{\n\t\t\t\tw = mati[w1];\n\t\t\t}\n\t\t\telse if(mati[w2] == mati[w1] + miti2[w1][w2])\n\t\t\t{\n\t\t\t\tw = mati[w2];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tw = (mati[w1] + mati[w2] + miti2[w1][w2] - 1) / 2 + 1;\n\t\t\t}\n\t\t\tif(l < w)\n\t\t\t{\n\t\t\t\tl = w;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",l);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing VI = vector<ll>;\nusing VV = vector<VI>;\nusing VS = vector<string>;\n\n// tourist set\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << '\\n'; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n// tourist set end\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define rep(i,b) FOR(i, 0, b)\n#define ALL(v) (v).begin(), (v).end()\n#define p(s) cout<<(s)<<'\\n'\n#define p2(s, t) cout << (s) << \" \" << (t) << '\\n'\n#define br() p(\"\")\n#define pn(s) cout << (#s) << \" \" << (s) << '\\n'\n#define p_yes() p(\"YES\")\n#define p_no() p(\"NO\")\n#define SZ(x) ((int)(x).size())\n#define SORT(A) sort(ALL(A))\n#define RSORT(A) sort(ALL(A), greater<ll>())\n\nvoid no(){p_no(); exit(0);}\nvoid yes(){p_yes(); exit(0);}\n\nconst ll mod = 1e9 + 7;\nconst ll inf = 1e18;\nconst double PI = acos(-1);\n\nstruct Edge{\n    ll to;\n    ll cost;\n    Edge(ll to, ll cost): to(to), cost(cost) {}\n    Edge(){\n        to = 0;\n        cost = 0;\n    }\n};\n\nstruct Node{\n    ll distance;\n    ll index;\n    Node(ll d, ll i){\n        distance = d;\n        index = i;\n    }\n    Node(){}\n\n    bool operator<(const Node &another) const\n    {\n        return distance < another.distance;\n    }\n    bool operator>(const Node &another) const\n    {\n        return distance > another.distance;\n    }\n};\n\nstruct Dijkstra{\n    vector<ll> d;\n    vector<vector<Edge> > graph;\n    vector<bool> done;\n\n    // ノード数を入れる\n    void initialize(ll size){\n        d.resize(size);\n        done.resize(size);\n        graph.resize(size);\n        reset();\n    }\n\n    void reset(){\n        ll N = graph.size();\n        FOR(i, 0, N){\n            d[i] = inf;\n            done[i] = false;\n        }\n    }\n    \n    ll distance(int i){\n        if(d.size()<=i) return -1;\n        return d[i];\n    }\n\n    void print_graph(){\n        FOR(i, 0, graph.size()){\n            cout << i << \" -> \";\n\n            for(auto edge : graph[i]){\n                cout << edge.to << \" \";\n            }\n            cout << endl;\n        }\n        p(\"distance\");\n        FOR(i, 0, graph.size()){\n            ll d = distance(i);\n            cout << i << \" \" << d << endl;\n        }\n    }\n\n    void register_edge(ll a, ll b, ll cost){\n        auto edge = Edge(b, cost);\n        graph[a].push_back(edge);\n    }\n\n    void calc_shortest_path(ll from=0){\n        priority_queue<Node, vector<Node>, greater<Node> > que;\n        auto node = Node();\n        // 始点\n        node.index = from;\n        node.distance = 0;\n        que.push(node);\n\n        while(!que.empty()){\n            // 1番distanceが小さいノード\n            Node n = que.top();\n            que.pop();\n\n            if(done[n.index]){\n                continue;\n            }\n            \n            done[n.index] = true;\n            d[n.index] = n.distance;\n\n            auto edge_list = graph[n.index];\n            for(auto edge : edge_list){   \n                // 短くなるノードがあれば\n                if(!done[edge.to] && n.distance + edge.cost < d[edge.to]){\n                    ll shorter_distance = n.distance + edge.cost;\n                    que.push(Node(shorter_distance, edge.to));\n                }\n            }\n        }\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    // input\n    ll N, M, K;\n    cin >> N >> M >> K;\n\n    Dijkstra dij;\n    dij.initialize(N+1);\n\n    VI A(M);\n    VI B(M);\n    VI C(M);\n    rep(i, M){\n      cin >> A[i] >> B[i] >> C[i];\n      A[i]--;\n      B[i]--;\n      dij.register_edge(A[i], B[i], C[i]);\n      dij.register_edge(B[i], A[i], C[i]);\n    }\n\n    // shopping mall\n    rep(i, K){\n      ll a; cin >> a; a--;\n\n      // 頂点Nからエッジをはる\n      dij.register_edge(N, a, 0);\n      dij.register_edge(a, N, 0);\n    }\n\n    dij.calc_shortest_path(N);\n\n    VI V(N+1);\n    rep(i, N+1){\n      V[i] = dij.distance(i);\n    }\n\n    ll ma = 0;\n    rep(i, M){\n      ll a = A[i];\n      ll b = B[i];\n\n      ll d = (V[a]+V[b]+C[i]+1)/2;\n      chmax(ma, d);\n    }\n    p(ma);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nint n, m, k;\nint amat[5000][5000];\nint vtx[5000];\nvector<int> mal;\n\nint solve(){\n\t\n\tfor(int i=0; i<n; ++i){\n\t\tvtx[i] = INT_MAX;\n\t}\n\n\tfor(int s=0; s<k; ++s){\n\n\t\tint vtx_tmp[5000];\n\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tvtx_tmp[i] = INT_MAX;\n\t\t}\n\t\t\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tqu.push(make_pair(0, mal[s]));\n\t\tvtx_tmp[mal[s]]=0;\n\t\t\n\t\twhile(!qu.empty()){\n\n\t\t\tint now = qu.top().second;\n\t\t\tqu.pop();\n\n\t\t\tfor(int i=0; i<n; ++i){\n\n\t\t\t\tif( amat[now][i] && vtx_tmp[i] > vtx_tmp[now] + amat[now][i]){\n\n\t\t\t\t\tvtx_tmp[i] = vtx_tmp[now] + amat[now][i];\n\t\t\t\t\tqu.push( make_pair(vtx_tmp[i], i) );\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0; i<n; ++i){\t\n\t\t\tvtx[i] = min(vtx[i], vtx_tmp[i]);\n\t\t}\n\t}\n\n\tint ma = -1;\n\n\tfor(int i=0; i<n-1; ++i){\n\t\tfor(int j=i+1; j<n; ++j){\n\t\t\t\n\t\t\tif(amat[i][j]){\n\t\t\t\tma = max(ma, min(vtx[i], vtx[j]) + amat[i][j] + (amat[i][j] - abs(vtx[i]-vtx[j]))/2 );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ma;\n}\n\nint main(){\n\n\tcin >> n >> m >> k;\n\n\tfor(int i=0; i<m; ++i){\n\t\t\n\t\tint a, b, l;\n\t\tcin >> a >> b >> l;\n\t\ta--; b--;\n\t\tamat[a][b] = amat[b][a] = l;\n\t}\n\n\tfor(int i=0; i<k; ++i){\n\n\t\tint s;\n\t\tcin>>s;\n\t\tmal.push_back(--s);\n\t}\n\n\tcout << solve() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint ijk[3000];\nbool v[3000];\nvector<pair<int,int> > g[3000];\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<b;i++){\n\t\tint d,e,f;\n\t\tscanf(\"%d%d%d\",&d,&e,&f);\n\t\tg[d-1].push_back(make_pair(e-1,f));\n\t\tg[e-1].push_back(make_pair(d-1,f));\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tijk[i]=999999999;\n\t}\n\tpriority_queue<pair<int,int>  >Q;\n\tfor(int i=0;i<c;i++){\n\t\tint d;\n\t\tscanf(\"%d\",&d);\n\t\td--;\n\t\tijk[d]=0;\n\t\tQ.push(make_pair(0,d));\n\t}\n\twhile(Q.size()){\n\t\tint at=Q.top().second;\n\t\tint cost=-Q.top().first;\n\t\tQ.pop();\n\t\tif(v[at])continue;\n\t\tv[at]=true;\n\t\tfor(int i=0;i<g[at].size();i++){\n\t\t\tif(!v[g[at][i].first]&&ijk[g[at][i].first]>ijk[at]+g[at][i].second){\n\t\t\t\tijk[g[at][i].first]=ijk[at]+g[at][i].second;\n\t\t\t\tQ.push(make_pair(-ijk[g[at][i].first],g[at][i].first));\n\t\t\t}\n\t\t}\n\t}\n\tint ret=0;\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<g[i].size();j++){\n\t\t\tret=max(ret,(ijk[i]+ijk[g[i][j].first]+g[i][j].second));\n\t\t}\n\t}\n\tprintf(\"%d\\n\",(ret+1)/2);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nstruct edge { int to, cost; edge(int to, int cost) : to(to), cost(cost) {} };\ntypedef vector<edge> edges;\n\nedges G[3010];\nint d[100010];\n\nvoid dijkstra(int s)\n{\n    priority_queue<pii, vpii, greater<pii> > pq;\n    d[s] = 0;\n    pq.push(pii(0, s));\n    \n    while (pq.size()) {\n        pii p = pq.top(); pq.pop();\n\n        int v = p.scd;\n\n        if (d[v] < p.fst) continue;\n\n        for (edge &e : G[v]) {\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                pq.push(pii(d[e.to], e.to));\n            }\n        }\n    }\n}\n\nsigned main()\n{\n    omajinai;\n\n    int N, M, K; cin >> N >> M >> K;\n\n    fill_n(d, N + 1, inf);\n\n    rep(i, M) {\n        int a, b, l; cin >> a >> b >> l;\n        a--, b--;\n\n        G[a].PB(edge(b, l));\n        G[b].PB(edge(a, l));\n    }\n\n    rep(i, K) {\n        int s; cin >> s;\n        s--;\n        dijkstra(s);\n    }\n\n    int ma = -1;\n\n    rep(i, N) {\n        for (edge &e : G[i]) {\n            ma = max(ma, (int)(d[i] + round(1. * (d[e.to] - d[i] + e.cost) / 2)));\n        }\n    }\n\n    cout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3002\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<P> G[N];\nbool num[N];\nint n,m,K;\n\ndouble dijkstra(){\n  int D[N];\n  for(int i=0;i<N;i++) D[i] = 1e9;\n  \n  vector<int>pre[N];\n  priority_queue<PP,vector<PP>,greater<PP> >Q;\n  \n  for(int i=0;i<N;i++)\n    if(num[i]) {\n      Q.push(PP(0,P(i,i)));\n      D[i] = 0;\n      pre[i].push_back(i);\n    }\n\n  \n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first;\n    int pos = t.second.first;\n    int start = t.second.second;\n\n    if(D[pos]<cost) continue;\n    pre[pos].push_back(start);\n    \n    for(int i=0;i<G[pos].size();i++){\n      int npos = G[pos][i].first;\n      int ncost = cost+G[pos][i].second;\n      if(D[npos]<ncost) continue;\n      Q.push(PP(ncost,P(npos,start)));\n      D[npos] = ncost;\n    }\n  }\n\n\n  double res = 0;\n  for(int i=0;i<n;i++){\n    if(pre[i].size()>=2)res = max(res,(double)D[i]);\n    res = max(res,D[i]/2.0);\n    \n    for(int j=0;j<G[i].size();j++){\n      int npos = G[i][j].first;\n      int ncost = G[i][j].second;\n      if(pre[npos][0] == pre[i][0] && abs(D[i]-D[npos])==ncost)continue;\n\n      res = max(res,(D[i]+D[npos]+ncost)/2.0);\n    }\n  }\n  return res;\n  \n}\n\nint main(){\n  \n  cin>>n>>m>>K;\n  for(int i=0,a,b,c;i<m;i++){\n    cin>>a>>b>>c;\n    G[a-1].push_back(P(b-1,c));\n    G[b-1].push_back(P(a-1,c));\n  }\n\n  for(int i=0,a;i<K;i++)cin>>a,num[a-1]=1;\n  printf(\"%d\\n\",(int)(dijkstra()+0.5));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//枝内における最大コストの求め方がよく理解できない。\n#include<iostream>\n#include<math.h>\n#include<vector>\n#include<queue>\n#include<functional>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint N,M,K;\t\t//町数、道の数、店舗数\nstruct NODE{\n\tvector<int> cost,list;\n\tint minest;\t//頂点から店への最短距離\n}MISE[3000];\n\nvoid Ini(int *a,int index,int num){\n\tfor(int i = 0;i < index;i++){\n\t\ta[i] = num;\n\t}\n}\nvoid Dijkstra(int left){\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tint done[3000],DEFINEED = 0;\n\tint nowcost[3000];\n\tP edge;\n\tIni(done,N,-1);\n\tIni(nowcost,N,500000000);\n\tque.push(P(0,left));\n\twhile(DEFINEED < N && !que.empty()){\n\t\tedge = que.top();\n\t\tque.pop();\n\t\tif(done[edge.second] >= 0)\n\t\t\tcontinue;\n\t\tDEFINEED++;\n\t\tdone[edge.second] = edge.first;\n\t\t//確定した頂点から枝を出す\n\t\tint lsize;\n\t\tlsize = MISE[edge.second].list.size();\n\t\tfor(int i = 0;i < lsize;i++){\n\t\t\tif(done[MISE[edge.second].list[i]] == -1 && nowcost[MISE[edge.second].list[i]] > edge.first+MISE[edge.second].cost[i]){\n\t\t\t\tnowcost[MISE[edge.second].list[i]] = edge.first+MISE[edge.second].cost[i];\n\t\t\t\tque.push(P(nowcost[MISE[edge.second].list[i]],MISE[edge.second].list[i]));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int  i = 0;i < N;i++){\n\t\tif(MISE[i].minest > done[i] && done[i] != -1)\n\t\t\tMISE[i].minest = done[i];\n\t}\n}\nint main(){\n\tint i,a,b,c;\n\tint Mplace;\n\tcin >> N >> M >> K;\n\tfor(i = 0;i < N;i++){\n\t\tMISE[i].minest = 500000000;\n\t}\n\tfor(i = 0;i < M;i++){\n\t\tcin >> a >> b >> c;\n\t\ta--;b--;\n\t\t//隣接リスト作成。道の生成による影響は2ノード間にのみ作用する。\n\t\tMISE[a].list.push_back(b);\n\t\tMISE[a].cost.push_back(c);\n\t\tMISE[b].list.push_back(a);\n\t\tMISE[b].cost.push_back(c);\n\t}\n\tfor(i = 0;i < K;i++){\n\t\tcin >> Mplace;\n\t\tMplace--;\n\t\tDijkstra(Mplace);\n\t}\n\tdouble D_length;\n\tint I_length,I_Mlength = 0;\n\tfor(i = 0;i < N;i++){\n\t\t//枝の間が一番距離が長くなりそう(嘘\n\t\tint lsize;\n\t\tlsize = MISE[i].list.size();\n\t\tfor(int j = 0;j < lsize;j++){\n\t\t\tD_length = (double)MISE[i].cost[j]/2.0;\n\t\t\tD_length += (MISE[i].minest+MISE[MISE[i].list[j]].minest)/2.0;\n\t\t\tif(D_length - (int)D_length == 0)\n\t\t\t\tI_length = (int)D_length;\n\t\t\telse\n\t\t\t\tI_length = (int)D_length+1;\n\t\t\tif(I_Mlength < I_length)\n\t\t\t\tI_Mlength = I_length;\n\t\t}\n\t}\n\tcout << I_Mlength << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct TOWN{\n    bool kaku;\n    int kyo;\n    vector<pair<int,int> > road;\n    \n    TOWN() :kaku(false){}\n}town[3001];\n\nint main(){\n    int n,m,k,a,b,l,ina[3000],inb[3000],inl[3000],ans=0;\n    priority_queue<pair<int,int> > pq;\n    pair<int,int> p;\n    \n    scanf(\"%d%d%d\",&n,&m,&k);\n    \n    for(int i=0;i<m;i++){\n        scanf(\"%d%d%d\",&a,&b,&l);\n        town[a].road.push_back(make_pair(b,-l));\n        town[b].road.push_back(make_pair(a,-l));\n        ina[i]=a;\n        inb[i]=b;\n        inl[i]=l;\n    }\n    \n    for(int i=0;i<k;i++){\n        scanf(\"%d\",&a);\n        pq.push(make_pair(0,a));\n    }\n    \n    while(!pq.empty()){\n        p=pq.top();\n        pq.pop();\n        \n        if(town[p.second].kaku) continue;\n        town[p.second].kaku=true;\n        town[p.second].kyo=-p.first;\n        \n        for(int i=0;i<town[p.second].road.size();i++)\n            pq.push(make_pair(p.first+town[p.second].road[i].second,town[p.second].road[i].first));\n    }\n    \n    for(int i=0;i<m;i++){\n        int sa = abs(town[ina[i]].kyo-town[inb[i]].kyo);\n        ans=max(ans,(max(inl[i]-sa,0)+1)/2+max(town[ina[i]].kyo,town[inb[i]].kyo));\n    }\n    \n    \n    \n    printf(\"%d\\n\",ans);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nconst int INF=1e9;\nstruct data{\n    int to,cost;\n    data(int a,int b):to(a),cost(b){}\n    bool operator<(const data &d)const{\n        return cost<d.cost;\n    }\n};\nvector<vector<data> >edge;\nvector<int>D;\nvoid dijkstra(int s){\n    priority_queue<data>Q;\n    Q.push(data(s,0));\n    while(Q.size()){\n        data latte=Q.top();Q.pop();\n        int At=latte.to,cost=latte.cost;\n        if(D[At]<cost)continue;\n        D[At]=cost;\n        for(int i=0;i<edge[At].size();i++){\n            data e=edge[At][i];\n            Q.push(data(e.to,D[At]+e.cost));\n        }\n    }\n    return;\n}\nint main(){\n    int n,m,k;\n    cin>>n>>m>>k;\n    edge.resize(n);\n    D.resize(n,INF);\n    for(int i=0;i<m;i++){\n        int a,b,c;\n        cin>>a>>b>>c;\n        a--;b--;\n        edge[a].push_back(data(b,c));\n        edge[b].push_back(data(a,c));\n    }\n    for(int i=0;i<k;i++){\n        int s;\n        cin>>s;\n        s--;\n        dijkstra(s);\n    }\n    int Max=0;\n\n    for(int i=0;i<n;i++){\n        for(int j=0;j<edge[i].size();j++){\n            data e=edge[i][j];\n            int latte=(D[i]+D[e.to]+e.cost+1)/2;\n            Max=max(max(D[i],D[e.to]),max(Max,latte));\n\n        }\n    }\n    cout<<Max<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={1,0,-1,0,1,-1,-1,1};\nconst int dy[]={0,1,0,-1,1,1,-1,-1};\nconst int INF = 1<<30;\nconst int EPS = 1e-8;\n#define PB push_back\n#define mk make_pair\n#define fi first\n#define se second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\ntypedef pair<int,int> Pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int > Pii;\nclass edge{\n\tpublic:\n\tint to;\n\tint cost;\n\tedge(){}\n\tedge(int _to,int _cost){\n\t\tto = _to;\n\t\tcost = _cost;\n\t}\n\tbool operator<(const edge &a)const{\n\t\treturn cost>=a.cost;\n\t}\n};\nvector < edge > G[3002];\nint path[3002];\nint N,M,K;\nvoid dijkstra(int s[1024]){\n\n\tpriority_queue<edge> Q;\n\trep(i,K){\n\t\tQ.push(edge(s[i],0));\n\t}\n\twhile(!Q.empty()){\n\t\tedge e = Q.top();\n\t\tQ.pop();\n\t\tif(path[e.to] < INF)continue;\n\t\tpath[e.to] = e.cost;\n\t\trep(i,G[e.to].size()){\n\t\t\tQ.push(edge(G[e.to][i].to,G[e.to][i].cost+e.cost));\n\t\t}\n\t}\n\treturn ;\n}\nint main(){\n\tscanf(\"%d%d%d\",&N,&M,&K);\n\tfill(path,path+N,INF);\n\trep(i,M){\n\t\tint a,b,c;\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\ta--;b--;\n\t\tG[a].PB(edge(b,c));\n\t\tG[b].PB(edge(a,c));\n\t}\n\tint s[1024];\n\trep(i,K){\n\t\tint tmp;\n\t\tscanf(\"%d\",&tmp);\n\t\ts[i] = --tmp;\n\t}\n\tdijkstra(s);\n\tdouble ans = 0;\n\trep(i,N){\n\t\trep(j,G[i].size()){\n\t\t\tint d = path[G[i][j].to]-path[i];\n\t\t\tif(d<0.0)continue;\n\t\t\tdouble g = path[i]+d+(G[i][j].cost-d)/2.0;\n\t\t\tans = max(g,ans);\n\t\t}\n\t}\n\tprintf(\"%.0lf\\n\",round(ans));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <utility>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\nstruct edge {\n\tint to, cost;\n\tedge(int t, int c):to(t), cost(c){}\n};\ntypedef pair<int, int> P;\nvector<vector<edge> > es;\n\nvector<int> dijkstra(int s) {\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tvector<int> dist(es.size(), INT_MAX);\n\tque.push(P(0, s));\n\tdist[s] = 0;\n\t\n\twhile(!que.empty()) {\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif(dist[v] < p.first)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < es[v].size(); ++i) {\n\t\t\tedge& e = es[v][i];\n\t\t\tif(dist[e.to] > dist[v] + e.cost) {\n\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\tque.push(P(dist[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dist;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\n\tes.resize(n);\n\tvector<P> con(m);\n\tvector<int> len(m);\n\tfor(int i = 0; i < m; ++i) {\n\t\tint a, b, l;\n\t\tcin >> a >> b >> l;\n\t\t--a;\n\t\t--b;\n\n\t\tes[a].push_back(edge(b, l));\n\t\tes[b].push_back(edge(a, l));\n\t\tcon[i] = make_pair(a, b);\n\t\tlen[i] = l;\n\t}\n\n\tvector<int> mn_dist(n, INT_MAX);\n\tfor(int i = 0; i < k; ++i) {\n\t\tint s;\n\t\tcin >> s;\n\n\t\tvector<int> dist = dijkstra(s - 1);\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tchmin(mn_dist[i], dist[i]);\n\t}\n\n\tint ans = 0;\n\tfor(int i = 0; i < n; ++i)\n\t\tchmax(ans, mn_dist[i]);\n\n\tfor(int i = 0; i < m; ++i)\n\t\tchmax(ans, (mn_dist[con[i].first] + mn_dist[con[i].second] + len[i]) / 2);\n\n\tcout << ans << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define s size()\n#define INF 100000000\nint cost[3005][3005];\nint d[3005];\nint maxi[100005]={};\nbool used[3005]={};\npair<pair<int,int> > ii[100005];\nint V;\nvoid dijkstra(int s){\n\tfill(d,d+V,INF);\n\td[s]=0;\n\twhile(1){\n\t\tint v=-1;\n\t\tfor(int u=0;u<V;u++){\n\t\t\tif(!used[u] && (v==-1 || d[u]<d[v]){\n\t\t\t\tv=u;\n\t\t\t}\n\t\t}\n\t\tif(v==-1){\n\t\t\tbreak;\n\t\t}\n\t\tused[v]=true;\n\t\tfor(int i=0;i<V;i++){\n\t\t\td[i]=min(d[i],d[v]+cost[v][i]);\n\t\t}\n\t}\n}\nint n,m,k;\nint main(){\n\tscanf(\"%d %d %d\",&n,&m,&k);\n\tfor(int i=0;i<3005;i++){\n\t\tfor(int j=0;j<3005;j++){\n\t\t\tcost[i][j]=INF;\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint w,ww,eu;\n\t\tscanf(\"%d %d %d\",&w,&ww,&eu);\n\t\tii[i]=mp(eu,mp(w,ww));\n\t\tcost[w-1][ww-1]=eu;\n\t\tcost[ww-1][w-1]=eu;\n\t}\n\tint res=0;\n\tfor(int i=0;i<k;i++){\n\t\tint t;\n\t\tscanf(\"%d\",&t);\n\t\tdijkstra(t-1);\n\t\tmemset(used,0,sizeof(used));\n\t\tfor(int j=0;j<m;j++){\n\t\t\tmaxi[j]=max(maxi[j],(ii[j].first+d[ii[j].second.first-1]+d[ii[j].second.second-1]+1)/2);\n\t\t}\n\t}\n\tfor(int j=0;j<m;j++){\n\t\tres=max(res,maxi[j]);\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint N,M,K;\nint dist[3005];\nvector<int> to[3005],len[3005];\nbool visited[3005];\n\nint main(void){\n\tcin>>N>>M>>K;\n\tint a,b,l;\n\tfor(;M--;){\n\t\tcin>>a>>b>>l;\n\t\t--a;--b;\n\t\tto[a].push_back(b);\n\t\tto[b].push_back(a);\n\t\tlen[a].push_back(l);\n\t\tlen[b].push_back(l);\n\t}\n\t\n\tfor(int i=0;i<N;i++){\n\t\tdist[i] = 1000000000;\n\t\tvisited[i]=false;\n\t}\n\t\n\tfor(;K--;){\n\t\tcin>>a;\n\t\tdist[--a] = 0;\n\t}//??\\???&?????????\n\t\n\tfor(int i=0;i<N;i++){//dijkstra??¨?¨????????????? ????????????????????????????±???????\n\t\tint mark=-1;//?????????????????????????????¢????????????????????? ?????????????£???????\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif(!visited[j] && (mark==-1 || dist[mark] > dist[j])) mark = j;\n\t\t}\n\t\tvisited[mark] = true;//???????¢????\n\t\t\n\t\tfor(int j=0;j<to[mark].size();j++){\n\t\t\tint ikisaki=to[mark][j],distkouho=dist[mark]+len[mark][j];\n\t\t\tif(dist[ikisaki]>distkouho)dist[ikisaki]=distkouho;\n\t\t}\n\t\t\n\t}\n\tint ans=0;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<to[i].size();j++){\n\t\t\tans = max(ans,dist[i]+dist[to[i][j]]+len[i][j]);\n\t\t}\n\t}\n\tans=(ans+1)/2;\n\tcout<<ans<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\nusing namespace std;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\ntypedef vector<PII> VP;\n\nint n, m, k;\nVP road[3010];\nint s[3010];\nint ans = 0;\n\npriority_queue<PII, VP, greater<PII> > sr;\nbool visited[3010];\nint dist[3010];\n\nint dijk()\n{\n  int ret;\n  for(int i = 0; i < k; i++)\n    sr.push(MP(0, s[i]));\n  \n  while(!sr.empty()){\n    PII now = sr.top();\n    sr.pop();\n\n    if(!visited[now.second]){\n      visited[now.second] = true;\n      dist[now.second] = now.first;\n      ret = now.first;\n      for(int i = 0; i < road[now.second].size(); i++)\n\tif(!visited[road[now.second][i].second])\n\t  sr.push(MP(now.first + road[now.second][i].first, road[now.second][i].second));\n    }\n  }\n  \n  return ret;\n}\n\nint main()\n{\n  scanf(\"%d%d%d\", &n, &m, &k);\n  for(int i = 0; i < m; i++){\n    int a, b, l;\n    scanf(\"%d%d%d\", &a, &b, &l);\n    road[a].PB(MP(l, b));\n    road[b].PB(MP(l, a));\n  }\n  \n  for(int i = 0; i < k; i++)\n    scanf(\"%d\", &s[i]);\n\n  ans = dijk();\n\n  for(int i = 1; i <= n ; i++)\n    for(int j = 0; j < road[i].size(); j++)\n      if(abs(dist[i] - dist[road[i][j].second]) < road[i][j].first){\n\tint longest = (road[i][j].first - abs(dist[i] - dist[road[i][j].second])) / 2 + max(dist[i], dist[road[i][j].second]);\n\tif((road[i][j].first - abs(dist[i] - dist[road[i][j].second])) % 2)\n\t  longest++;\n\n\tans = max(ans, longest);\n      }\n  \n  printf(\"%d\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <deque>\n#include <vector>\nusing namespace std;\n\nint main() {\n\tint N,M,K;\n\tvector<pair<int,int> >nGo[3001];\n\tdeque<int> dis;\n\tint dist[3001];\n\tint road[3000][3];\n\tfor(int i=1;i<=3000;i++)\n\t\tdist[i]=(1 << 30 );\n\tcin >> N >> M >> K;\n\tint a,b,c;\n\tfor(int i=0;i<M;i++){\n\t\tcin >> a >> b >> c;\n\t\tnGo[a].push_back(pair<int,int>(b,c));\n\t\tnGo[b].push_back(pair<int,int>(a,c));\n\t\troad[i][0]=a;\n\t\troad[i][1]=b;\n\t\troad[i][2]=c;\n\t}\n\tfor(int i=0;i<K;i++){\n\t\tcin >> a;\n\t//\tdis.insert(multimap<int,int>::value_type(0,a));\n\t\tdis.push_back(a);\n\t\tdist[a]=0;\n\t}\n\twhile(!dis.empty()){\n\t\tsort(dis.begin(),dis.end());\n\t\tint now=dis[0];\n\t\tfor(int i=0;i<nGo[now].size();i++){\n\t\t\tif(dist[nGo[now][i].first]>dist[now]+nGo[now][i].second){\n\t\t\t\tdis.push_back(nGo[now][i].first);\n\t\t\t\tdist[nGo[now][i].first]=dist[now]+nGo[now][i].second;\n\t\t\t}\n\t\t}\n\t\tdis.pop_front();\n\t}\n\tint maxer=0;\n\tfor(int i=0;i<M;i++)\n\tmaxer=max(maxer,(int)(dist[road[i][0]]+dist[road[i][1]]+road[i][2]+0.5)/2);\n\tfor(int i=1;i<=N;i++)\n\tmaxer=max(maxer,dist[i]);\n\tcout << maxer <<  endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(x) __builtin_ctz(x)\n\n// #define DEBUG\n\n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n\nusing namespace std;\nusing ll=long long;\n\nconst int nmax=3010;\nusing node=struct{int to,cost;};\nvector<node> graph[nmax];\n\nconst int inf=1<<28;\nusing tii=tuple<int,int>;\nint dist[nmax];\n\nint main(void){\n\tint n,m,k;\n\tcin >> n >> m >> k;\n\trep(i,n) dist[i]=inf;\n\t\n\trep(i,m){\n\t\tint a,b,c;\n\t\tcin >> a >> b >> c;\n\t\tgraph[a-1].push_back({b-1,c});\n\t\tgraph[b-1].push_back({a-1,c});\n\t}\n\n\n\tpriority_queue<tii,vector<tii>,greater<tii>> q;\n\trep(loop,k){\n\t\tint v;\n\t\tcin >> v;\n\t\tdist[v-1]=0;\n\t\tq.push(tii(0,v-1));\n\t}\n\n\twhile(!q.empty()){\n\t\tint v,cost;\n\t\ttie(v,cost)=q.top();q.pop();\n\t\tfor(auto &e:graph[v]){\n\t\t\tint nv=e.to,ncost=cost+e.cost;\n\t\t\tif(dist[nv]>ncost){\n\t\t\t\tdist[nv]=ncost;\n\t\t\t\tq.push(tii(ncost,nv));\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans=0;\n\trep(i,n){\n\t\tans=max(ans,dist[i]);\n\t\tfor(auto &e:graph[i]){\n\t\t\tint a=i,b=e.to,l=e.cost;\n\t\t\tif(dist[a]>dist[b]) continue;\n\t\t\tif(dist[a]+l<=dist[b]) continue;\n\t\t\tif(dist[b]+l<=dist[a]) continue;\n\t\t\tint add=(l-(dist[b]-dist[a])+1)/2;\n\t\t\tans=max(ans,dist[a]+add);\n\t\t}\n\t}\n\t//  cost  a         dist[a]+a==dist[b]+b (a+b)==l       cost b\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\nconst int INF=1e9;\nstruct dat{int a,b,c;};\nstruct edge{int to,cost;};\nint d[3030],n,m,k;\nvector<edge>G[3030];\nvoid dijkstra(int s){\n\td[s]=0;\n\tpriority_queue<P,vector<P>,greater<P> >Q;\n\tQ.push(MP(0,s));\n\twhile(!Q.empty()){\n\t\tP p=Q.top();Q.pop();\n\t\tint v=p.second;\n\t\tif(d[v]<p.first)continue;\n\t\tREP(i,G[v].size()){\n\t\t\tint to=G[v][i].to,cost=G[v][i].cost;\n\t\t\tif(d[to]>d[v]+cost){\n\t\t\t\td[to]=d[v]+cost;\n\t\t\t\tQ.push(MP(d[to],to));\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tREP(i,3030)d[i]=INF;\n\tcin>>n>>m>>k;\n\tvector<dat>road;\n\tREP(i,m){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;a--;b--;\n\t\troad.PB((dat){a,b,c});\n\t\tG[a].PB((edge){b,c});\n\t\tG[b].PB((edge){a,c});\n\t}\n\tREP(i,k){\n\t\tint s;\n\t\tcin>>s;s--;\n\t\tdijkstra(s);\n\t}\n\tint ans=0;\n\tREP(i,road.size()){\n\t\tdat v=road[i];\n\t\tans=max(ans,(d[v.a]+d[v.b]+v.c+1)/2);\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nstruct edge { int to, cost; edge(int to, int cost) : to(to), cost(cost) {} edge() {} };\ntypedef vector<edge> edges;\n\nedges G[3010];\nint d[3010];\n\nsigned main()\n{\n    omajinai;\n\n    int N, M, K; cin >> N >> M >> K;\n\n    fill_n(d, N + 1, inf);\n\n    rep(i, M) {\n        int a, b, l; cin >> a >> b >> l;\n        a--, b--;\n\n        G[a].PB(edge(b, l));\n        G[b].PB(edge(a, l));\n    }\n\n    priority_queue<pii, vpii, greater<pii> > pq;\n\n    rep(i, K) {\n        int s; cin >> s;\n        s--;\n        d[s] = 0;\n        pq.push(pii(0, s));\n    }\n    \n    while (pq.size()) {\n        pii p = pq.top(); pq.pop();\n\n        int v = p.scd;\n\n        if (d[v] < p.fst) continue;\n\n        rep(i, G[v].size()) {\n            edge &e = G[v][i];\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                pq.push(pii(d[e.to], e.to));\n            }\n        }\n    }\n\n    double ma = -1.0;\n\n    rep(i, N) {\n        rep(j, G[i].size()) {\n            edge &e = G[i][j];\n            ma = max(ma, (d[i] + d[e.to] + e.cost) / 2.0);\n        }\n    }\n\n    cout << round(ma) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nint n, m, k;\nint amat[5000][5000];\nint vtx[5000];\nvector< vector<int> > adj(5000);\nvector<int> mal;\n\nint solve(){\n\t\n\tfor(int i=0; i<n; ++i){\n\t\tvtx[i] = INT_MAX;\n\t}\n\n\tfor(int s=0; s<k; ++s){\n\t\t\n\t\tint vtxt[5000];\n\t\t\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tvtxt[i] = INT_MAX;\n\t\t}\n\t\t\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tqu.push(make_pair(0, mal[s]));\n\t\tvtxt[mal[s]]=0;\n\t\t\n\t\twhile(!qu.empty()){\n\n\t\t\tint now = qu.top().second, nxt;\n\t\t\tqu.pop();\n\n\t\t\tfor(int i=0; i<adj[now].size(); ++i){\n\t\t\t\t\n\t\t\t\tnxt = adj[now][i];\n\t\t\t\t\t\n\t\t\t\tif( vtxt[nxt] > vtxt[now] + amat[now][nxt]){\n\t\t\t\t\n\t\t\t\t\tvtxt[nxt] = vtxt[now] + amat[now][nxt];\n\t\t\t\t\tqu.push( make_pair(vtxt[nxt], nxt) );\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tvtx[i] = min(vtx[i], vtxt[i]);\n\t\t}\n\t}\n\n\tint ma = -1;\n\n\tfor(int p=0; p<n; ++p){\n\t\tfor(int i=0; i<adj[p].size(); ++i){\n\t\t\t\n\t\t\tint q = adj[p][i];\n\t\t\tma = max(ma, min(vtx[p], vtx[q]) + (1 + amat[p][q] + abs(vtx[p]-vtx[q]))/2 );\n\t\t}\n\t}\n\n\treturn ma;\n}\n\nint main(){\n\n\tcin >> n >> m >> k;\n\n\tfor(int i=0; i<m; ++i){\n\t\t\n\t\tint a, b, l;\n\t\tcin >> a >> b >> l;\n\t\ta--; b--;\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t\tamat[a][b] = amat[b][a] = l;\n\t}\n\n\tfor(int i=0; i<k; ++i){\n\n\t\tint s;\n\t\tcin>>s;\n\t\tmal.push_back(--s);\n\t}\n\n\tcout << solve() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <functional>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m, k, u;\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\n\tvector<int> a(m), b(m), L(m);\n\tvector<vector<pii> > G(n + 1);\n\tfor(int i = 0; i < m; ++i){\n\t\tscanf(\"%d%d%d\", &a[i], &b[i], &L[i]);\n\t\tG[a[i]].push_back(pii(L[i], b[i]));\n\t\tG[b[i]].push_back(pii(L[i], a[i]));\n\t}\n\n\tpriority_queue<pii,vector<pii>,greater<pii> > pq;\n\tvector<int> d(n + 1, 500000000);\n\tfor(int i = 0; i < k; ++i){\n\t\tscanf(\"%d\", &u);\n\t\td[u] = 0;\n\t\tpq.push(pii(0, u));\n\t}\n\n\twhile(!pq.empty()){\n\t\tint e = pq.top().first;\n\t\tu = pq.top().second;\n\t\tpq.pop();\n\t\tif(d[u] != e){ continue; }\n\t\tfor(size_t i = 0; i < G[u].size(); ++i){\n\t\t\tint v = G[u][i].second;\n\t\t\tint f = e + G[u][i].first;\n\t\t\tif(d[v] > f){\n\t\t\t\td[v] = f;\n\t\t\t\tpq.push(pii(f, v));\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor(int i = 0; i < m; ++i){\n\t\tint e = d[a[i]];\n\t\tint f = d[b[i]];\n\t\tint r = max(max(e, f), e + (f - e + L[i] + 1) / 2);\n\t\tans = max(ans, r);\n\t}\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nint main(){\n\tstatic int n,m,k;\n\tstatic int a[100010],b[100010],l[100010];\n\tstatic int s[3002];\n\t\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\trep(i,m){\n\t\tscanf(\"%d%d%d\",&a[i],&b[i],&l[i]);\n\t}\n\trep(i,k){\n\t\tscanf(\"%d\",&s[i]);\n\t}\n\t\n\tstatic vector<P> G[3002];\n\tstatic int d[3002];\n\tstatic bool used[3002];\n\tstatic rpque(P) que;\n\t\n\trep(i,m){\n\t\tG[a[i]].pb( P ( b[i] , l[i] ) );\n\t\tG[b[i]].pb( P ( a[i] , l[i] ) );\n\t}\n\trep(i,3002){\n\t\td[i] = INF;\n\t\tused[i] = false;\n\t}\n\trep(i,k){\n\t\td[s[i]] = 0;\n\t\tque.push( P ( 0 , s[i] ) );\n\t}\n\t\n\twhile(!que.empty()){\n\t\tP p = que.top(); que.pop();\n\t\tif(!used[p.sc]){\n\t\t\trep(i,G[p.sc].size()){\n\t\t\t\tP ed = G[p.sc][i];\n\t\t\t\tif(d[ed.fr] > d[p.sc] + ed.sc){\n\t\t\t\t\td[ed.fr] = d[p.sc] + ed.sc;\n\t\t\t\t\tque.push( P ( d[ed.fr] , ed.fr ) );\n\t\t\t\t}\n\t\t\t}\n\t\t\tused[p.sc] = true;\n\t\t}\n\t}\n\t\n\tstatic int ret = 0;\n\t\n\trep1(i,n){\n\t\tret = max ( ret , d[i] );\n\t}\n\trep(i,m){\n\t\tret = max ( ret , ( d[a[i]] + d[b[i]] + l[i] + 1 )/2 );\n\t}\n\t\n\tprintf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<vector>\nusing namespace std;\nconst int INF=1000000000;\ntypedef pair<int,int> P;\nstruct edge{\n\tint to;\n\tint cost;\n};\n\nint main(){\n\tbool bo[3000+2];\n\tfill(bo,bo+3002,false);\n\tint n,m,k,a,b,l,ans=0;\n\tP p[3000+2],q;\n\tvector<edge> ed[3000+2];\n\tpriority_queue<P,vector<P>,greater<P>> que;\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tfor(int i=1;i<=n;i++){p[i].first=INF; p[i].second=i;}\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d%d%d\",&a,&b,&l);\n\t\tedge e;\n\t\te.to=b;\n\t\te.cost=l;\n\t\ted[a].push_back(e);\n\t\te.to=a;\n\t\ted[b].push_back(e);\n\t}\n\tfor(int i=0;i<k;i++){\n\t\tscanf(\"%d\",&a);\n\t\tp[a].first=0;\n\t\tque.push(p[a]);\n\t}\n\twhile(!que.empty()){\n\t\tq=que.top(); que.pop();\n\t\tif(!bo[q.second]){\n\t\t\tbo[q.second]=true;\n\t\t\tint s=ed[q.second].size();\n\t\t\tfor(int i=0;i<s;i++){\n\t\t\t\tif(p[ed[q.second][i].to].first>p[q.second].first+ed[q.second][i].cost){\n\t\t\t\t\tp[ed[q.second][i].to].first=p[q.second].first+ed[q.second][i].cost;\n\t\t\t\t\tque.push(p[ed[q.second][i].to]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(p[i].first>ans)ans=p[i].first;\n\t\tint s=ed[i].size();\n\t\tfor(int j=0;j<s;j++){\n\t\t\tif(ans*2<p[i].first+p[ed[i][j].to].first+ed[i][j].cost)ans=(p[i].first+p[ed[i][j].to].first+ed[i][j].cost+(p[i].first+p[ed[i][j].to].first+ed[i][j].cost)%2)/2;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3002\nusing namespace std;\ntypedef pair<int,int> P;\nvector<P> G[N];\nbool num[N];\nint n,m,K;\n\ndouble dijkstra(){\n  vector<int> D(N,1e9);\n  priority_queue<P,vector<P>,greater<P> >Q;\n  for(int i=0;i<n;i++)if(num[i]) Q.push(P(0,i)),D[i] = 0;\n  \n  while(!Q.empty()){\n    P t = Q.top();Q.pop();\n    int cost = t.first;\n    int pos = t.second;\n    if(D[pos]<cost) continue;\n\n    for(int i=0;i<G[pos].size();i++){\n      int npos = G[pos][i].first;\n      int ncost = cost+G[pos][i].second;\n      if(D[npos]<=ncost) continue;\n      Q.push(P(ncost,npos));\n      D[npos] = ncost;\n    }\n  }\n\n  cout<<D[0]<<endl;\n  double res = 0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<(int)G[i].size();j++){\n      int npos = G[i][j].first;\n      int ncost = G[i][j].second;\n      res = max(res,(D[i]+D[npos]+ncost)/2.0);\n    }\n  return res;\n   \n}\n \nint main(){\n  cin>>n>>m>>K;\n  for(int i=0,a,b,c;i<m;i++){\n    cin>>a>>b>>c;\n    G[a-1].push_back(P(b-1,c));\n    G[b-1].push_back(P(a-1,c));\n  }\n \n  for(int i=0,a;i<K;i++)cin>>a,num[a-1]=1;\n  printf(\"%d\\n\",(int)(dijkstra()+0.5));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int inf = (int)1e9;\n\nint main()\n{\n\tint n, m, k;\n\tint ans = 0;\n\tvector<int> dist;\n\tvector<vector<pair<int, int> > > graph;\n\tvector<pair<pair<int, int>, int> > edge;\n\t\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tdist.resize(n, inf);\n\tgraph.resize(n);\n\tfor(int i = 0; i < m; ++i) {\n\t\tint a, b, l;\n\t\tscanf(\"%d%d%d\", &a, &b, &l);\n\t\ta -= 1, b -= 1;\n\t\tedge.push_back(make_pair(make_pair(a, b), l));\n\t\tgraph[a].push_back(make_pair(b, l));\n\t\tgraph[b].push_back(make_pair(a, l));\n\t}\n\t\n\tfor(int i = 0; i < k; ++i) {\n\t\t\n\t\tint s;\n\t\tscanf(\"%d\", &s);\n\t\ts -= 1;\n\t\t\n\t\tpriority_queue<pair<int, int> > q;\n\t\t\n\t\tq.push(make_pair(0, s));\n\t\t\n\t\twhile(!q.empty()) {\n\t\t\t\n\t\t\tint v = q.top().second;\n\t\t\tint c = -q.top().first;\n\t\t\tq.pop();\n\t\t\t\n\t\t\tif(dist[v] < c)\n\t\t\t\tcontinue;\n\t\t\tdist[v] = c;\n\t\t\t\n\t\t\tfor(int i = 0; i < graph[v].size(); ++i) {\n\t\t\t\tint w = graph[v][i].first;\n\t\t\t\tint d = graph[v][i].second + c;\n\t\t\t\tq.push(make_pair(-d, w));\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//for(int i = 0; i < n; ++i)\n\t//\tprintf(\"[debug] %d -> %d\\n\", i, dist[i]);\n\t\n\tfor(int i = 0; i < m; ++i) {\n\t\t\n\t\tint a = edge[i].first.first;\n\t\tint b = edge[i].first.second;\n\t\tint l = edge[i].second;\n\t\tint cost;\n\t\t\n\t\tif(dist[a] > dist[b])\n\t\t\tswap(a, b);\n\t\t\n\t\tif(dist[a] + l == dist[b])\n\t\t\tcost = dist[b];\n\t\telse\n\t\t\tcost = (l - (dist[b] - dist[a]) + 1) / 2 + dist[b];\n\t\tans = max(ans, cost);\n\t\t//printf(\"[debug] (%d, %d) -> (%d, %d) -> %d -> %d\\n\", a, dist[a], b, dist[b], l, cost);\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 2002\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<P> G[N];\nbool num[N];\nint n,m,K;\n\ndouble dijkstra(){\n  int D[N];\n  for(int i=0;i<N;i++) D[i] = 1e9;\n  \n  vector<int>pre[N];\n  priority_queue<PP,vector<PP>,greater<PP> >Q;\n  \n  for(int i=0;i<N;i++)\n    if(num[i]) {\n      Q.push(PP(0,P(i,i)));\n      D[i] = 0;\n      pre[i].push_back(i);\n    }\n  \n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first;\n    int pos = t.second.first;\n    int start = t.second.second;\n\n    if(D[pos]<cost) continue;\n    pre[pos].push_back(start);\n    \n    for(int i=0;i<G[pos].size();i++){\n      int npos = G[pos][i].first;\n      int ncost = cost+G[pos][i].second;\n      if(D[npos]<ncost) continue;\n      Q.push(PP(ncost,P(npos,start)));\n      D[npos] = ncost;\n    }\n  }\n  \n\n  double res = 0;\n  for(int i=0;i<n;i++){\n    if(pre[i].size()>=2)res = max(res,(double)D[i]);\n    if(pre[i].size()>=2)continue;\n    \n    for(int j=0;j<G[i].size();i++){\n      int npos = G[i][j].first;\n      int ncost = G[i][j].second;\n      if(npos == pre[i][0]){\n\tif(abs(D[i]-D[npos])!=ncost) res = max(res,(D[i]+D[npos]+ncost)/2.0);\n      }\n      else res = max(res,(D[i]+D[npos]+ncost)/2.0);\n    }\n  }\n  return res;\n  \n}\n\nint main(){\n  \n  cin>>n>>m>>K;\n  for(int i=0,a,b,c;i<m;i++){\n    cin>>a>>b>>c;\n    G[a-1].push_back(P(b-1,c));\n    G[b-1].push_back(P(a-1,c));\n  }\n\n  for(int i=0,a;i<K;i++)cin>>a,num[a-1]=1;\n  printf(\"%.0f\\n\",dijkstra());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct edge{\n    int to;\n    int cost;\n};\nclass Situation{\npublic:\n\tint cost;\n\tint idx;\n\n\tSituation(int cost_,int idx_){\n\t\tcost=cost_;\n\t\tidx=idx_;\n\t}\n\tSituation();\n\n\tbool operator<(const Situation &s)const{\n\t\treturn s.cost < this->cost;\n\t}\n};\nconst int MAX_V=3001;\n\nint N,M,K;\nvector<edge> G[MAX_V];\nbool isShop[MAX_V];\nint d[MAX_V];\nconst int INF=1000000000;\nint froms[100001];\nint tos[100001];\nint costs[100001];\n\nvoid dijkstra(int s){\n\tpriority_queue<Situation> que;\n\td[s] = 0;\n\tque.push(Situation(0,s));\n\twhile(!que.empty()){\n\t\tSituation p = que.top();\n\t\tque.pop();\n\t\tint v = p.idx;\n\t\tif(d[v] < p.cost)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > d[v] + e.cost){\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(Situation(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n    cin>>N>>M>>K;\n    for(int i=0;i<M;i++){\n        edge e;\n        int from,to,cost;\n        cin>>from>>to>>cost;\n        from--;to--;\n        froms[i]=from;\n        tos[i]=to;\n        costs[i]=cost;\n        e.to=to;\n        e.cost=cost;\n        G[from].push_back(e);\n        e.to=from;\n        G[to].push_back(e);\n    }\n\tfill(d,d+MAX_V,INF);\n    for(int i=0;i<K;i++){\n        int a;\n        cin>>a;\n        a--;\n        dijkstra(a);\n    }\n    double res=0;\n    for(int i=0;i<N;i++)\n        res=max(res,(double)d[i]);\n    for(int i=0;i<M;i++){\n        double dit=(1.0*d[froms[i]]+d[tos[i]]+costs[i])/2;\n        res=max(dit,res);\n    }\n    printf(\"%.0f\\n\",res);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <stdio.h>\n#include <string.h>\n#include <cstdlib>\n#include <math.h>\n#include <bitset>\n#include <iterator>\n#include <iomanip>\n#include <sstream>\n#include <numeric>\n#define INF 2000000000\nusing namespace std;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n#define sym cout<<\"---------\"<<endl;\n#define ll long long\n#define PL pair<long long, long long>\n#define P pair<int,int>\n#define mk make_pair\n#define en endl\n#define WHITE 0\n#define BLACK 2\n#define GRAY 1\n#define RE return 0\n//#define int ll\n\n#define MAX 3005\n\ndouble minc[MAX];\nvector<pair<double, double> > G[MAX];\n\nsigned main(){\n  int n,m,k;\n  cin>>n>>m>>k;\n  for(int i=0; i<m; i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    G[a].push_back(mk(b,c));\n    G[b].push_back(mk(a,c));\n  }\n  for(int i=0; i<=n; i++) minc[i]=INF;\n  \n  for(int u=0; u<k; u++){\n    double city[MAX];\n    bool come[MAX];\n    for(int i=1; i<=n; i++){\n      city[i]=INF;\n      come[i]=false;\n    }\n    int a;\n    cin>>a;\n    priority_queue<P,vector<P>, greater<P> > que;\n    que.push(mk(0,a));\n    city[a]=0;\n    while(!que.empty()){\n      int q=que.top().second; que.pop();\n      come[q]=true;\n      for(int i=0; i<G[q].size(); i++){\n        int v=G[q][i].first;\n        int c=G[q][i].second;\n        if(come[v]) continue;\n        if(city[v]>city[q]+c){\n          city[v]=city[q]+c;\n          que.push(mk(city[v],v));\n        }\n      }\n    }\n    for(int i=1; i<=n; i++){\n      minc[i]=min(minc[i],city[i]);\n    }\n  }\n  \n  double max_ans=-1;\n  for(int i=1; i<=n; i++){\n    for(int j=0; j<G[i].size(); j++){\n      int to=G[i][j].first;\n      max_ans=max(max_ans,round((minc[i]+minc[to]+G[i][j].second)/2));\n      max_ans=max(max_ans,(double)minc[i]);\n    }\n  }\n  cout<<max_ans<<en;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nconst int INF = 1e9;\nconst int MAX_N = 3010, MAX_E = 10000;\nint n, m; //????????° ???????????¬??°\nvector<pair<int, int> > G[MAX_N];//??°???????????¨?????£??\\????????? fi:to se:cost\nint d[MAX_N]; //s?????????????????????\ntypedef pair<int, int> P;//first??????????????¢,second??????????????????\nint k; vector<int> shop;//???????¨????\n\nvoid dijkstra(void){\n\tpriority_queue<P, vector<P>, greater<P> > que;//first????°?????????????\n    rep(i, n)d[i] = INF;//?????????\n    \n    //k????????????????????°????????????\n    for(auto i : shop){\n    \td[i] = 0;\n    \tque.push(make_pair(0, i));\n    }\n  \n    while(!que.empty()){\n       \tauto p = que.top(); que.pop();\n       \tint v = p.second;\n       \tif(d[v] < p.first) continue;\n       \tfor(auto e : G[v]){//e.fi:??£??\\??????????????????????????? e.se:?????????????????§????????????\n       \t\tif(d[e.first] > d[v] + e.second){//???????????¢?????´??°???????????¨???\n       \t\t\td[e.first] = d[v] + e.second;\n       \t\t\tque.push(make_pair(d[e.first], e.first));\n       \t\t}\n       \t}\n    }\n}\n\nint main(void){\n    cin >> n >> m >> k;\n    rep(i, m){\n        int a, b, l; cin >> a >> b >> l;\n        a--; b--;\n       \tG[a].push_back(make_pair(b, l)); G[b].push_back(make_pair(a, l));\n    }\n    rep(i, k){\n    \tint s; cin >> s; s--;\n    \tshop.push_back(s);\n    }\n    dijkstra();//????????????????????????????°?????????????\n    //?????????????????¶????????????????°?????????????\n    double ans = 0.0;\n    //??????????????????????????¢????????¨???????????????????????¶???????????´?????????????????????????????¢?????????\n    // rep(i, n) printf(\"%d\\n\", d[i]);\n   \tfor (int x = 0; x < n; ++x){\n   \t\tfor(auto y : G[x]){\n   \t\t\tif(d[x] == 0 || d[y.first] == 0) continue;\n   \t\t\tdouble tmp = (d[x] + d[y.first] + y.second) / 2.0;//+1????????¨?????\\??¨\n   \t\t\tans = max(tmp, ans);\n   \t\t}\n   \t}\n   \tcout << round(ans) << endl;\n   \treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst int MAX_N = 1000;\n\nstruct Edge\n{\n\tint v, cost; \n\tEdge(int v, int cost) \n\t\t: v(v), cost(cost) \n\t{ } \n};\n\nvector<Edge> edges[MAX_N];\n\nint main()\n{\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\t\n\tvint d(n, 0);\n\tvector<bool> flag(n, false);\n\t\n\trep(i, m)\n\t{\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\t\n\t\tedges[a - 1].push_back(Edge(b - 1, c));\n\t\tedges[b - 1].push_back(Edge(a - 1, c));\n\t}\n\t\n\trep(i, k)\n\t{\n\t\tint f;\n\t\tcin >> f;\n\t\t\n\t\tflag[f - 1] = true;\n\t}\n\t\n\t// それぞれの街から最も近いショッピングモールへの距離をBFSで探索O(n*n*hoge)\n\trep(i, n)\n\t{\n\t\tif(!flag[i])\n\t\t{\n\t\t\tvector<bool> used(n, false);\n\t\t\tpriority_queue<pint, vector<pint>, greater<pint> > que; // first := cost, second := position;\n\t\t\t\n\t\t\tfor(que.push(mp(0, i)); !que.empty(); que.pop())\n\t\t\t{\n\t\t\t\tpint p = que.top();\n\t\t\t\t\n\t\t\t\tif(flag[p.second])\n\t\t\t\t{\n\t\t\t\t\td[i] = p.first;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trep(j, edges[p.second].size())\n\t\t\t\t{\n\t\t\t\t\tEdge &e = edges[p.second][j];\n\t\t\t\t\t\n\t\t\t\t\tif(!used[e.v])\n\t\t\t\t\t{\n\t\t\t\t\t\tused[e.v] = true;\n\t\t\t\t\t\tque.push(mp(p.first + e.cost, e.v));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// 辺上の最大値を探すO(m)\n\tdouble res = 0;\n\trep(i, n) \n\t{\n\t\trep(j, edges[i].size())\n\t\t{\n\t\t\tEdge &e = edges[i][j];\n\t\t\t\n\t\t\tchmax(res, min(d[i], d[e.v]) + e.cost / 2.0);\n\t\t\tif(flag[i] && !flag[e.v]) chmax(res, d[i] + e.cost - 1);\n\t\t}\n\t\t\n\t\tchmax(res, d[i]);\n\t}\n\t\n\tprintf(\"%.0f\\n\", res);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<cstdio>\n#include<cmath>\n#include<stack>\n#define F first\n#define S second\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef vector<P> VP;\ntypedef vector<int> VI;\ntypedef vector<VP> VVP;\ntypedef vector<VI> VVI;\nclass Pox\n{\npublic:\n  int cost,now;\n  Pox():cost(0),now(0){}\n  Pox(int now,int cost):now(now),cost(cost){}\n};\n\nclass ope{\npublic:\n  bool operator() (Pox a,Pox b)\n  {\n    return a.cost > b.cost;\n  }\n};\n\nconst int INF = (1<<28);\nint N,M,K;\nVVP G;\nVI mincost;\n//map<P,int> D;\n\nint main()\n{\n  scanf(\"%d %d %d\",&N,&M,&K);\n  G.resize(N),mincost.resize(N);\n  for(int i=0;i<N;i++)\n      mincost[i] = INF;\n\n  for(int i=0;i<M;i++)\n    {\n      int a,b,c;\n      scanf(\"%d %d %d\",&a,&b,&c);\n      a--,b--;\n      G[a].push_back(P(b,c));\n      G[b].push_back(P(a,c));\n      //D[P(a,b)] = D[P(b,a)] = c;\n    }\n\n  priority_queue<Pox,vector<Pox>,ope> Q;\n  for(int i=0;i<K;i++)\n    {\n      int a;\n      scanf(\"%d\",&a);\n      a--;\n      Q.push(Pox(a,0));\n      mincost[a] = 0;\n    }\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.top(); Q.pop();\n      int now = pox.now;\n      int total = pox.cost;\n\n      for(int i=0;i<G[now].size();i++)\n\t{     \n\t  P p = G[now][i];\n\t  int to = p.F;\n\t  int cost = p.S;\n\t  if(mincost[to] <= total + cost)\n\t    continue;\n\n\t  mincost[to] = total + cost;\n\t  Q.push(Pox(to,total+cost));\n\t}\n    }\n\n\n  double mex = 0;\n  for(int i=0;i<N;i++)\n    for(int j=0;j<G[i].size();j++)\n\tif(j != i && mincost[G[i][j].F] != INF && mincost[i] != INF/* && D[P(i,j)]*/)\n\t  mex = max(mex,(double)(mincost[i]+mincost[G[i][j].F]+G[i][j].S/*D[P(i,j)]*/)/2.0 );\n\t    \n\n  cout << round(mex) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst int INF = 1LL << 29;\nconst ll LONGINF = 1LL << 60;\nconst ll MOD = 1000000007LL;\n\nstruct Elem {\n    int cur; ll cost;\n    Elem() {}\n    Elem(int cur_, ll cost_) : cur(cur_), cost(cost_) {}\n    bool operator<(const Elem &e) const {\n        return cost > e.cost;\n    }\n};\n\nll dist[110010];\nint main() {\n    int N, M, K; scanf(\"%d%d%d\", &N, &M, &K);\n\n    int V = N;\n    vector< vector< pair<int, int> > > G(V);\n    for(int i=0; i<M; i++) {\n        int u, v, c; scanf(\"%d%d%d\", &u, &v, &c);\n        u--; v--;\n        G[u].emplace_back(v, c);\n        G[v].emplace_back(u, c);\n    }\n\n    fill(dist, dist + V, LONGINF);\n    priority_queue<Elem> que;\n    for(int i=0; i<K; i++) {\n        int v; scanf(\"%d\", &v);\n        v--;\n        dist[v] = 0;\n        que.emplace(v, 0);\n    }\n\n    while(que.size()) {\n        Elem elem = que.top(); que.pop();\n        int cur = elem.cur; ll cost = elem.cost;\n        if(dist[cur] < cost) continue;\n        for(auto e : G[cur]) {\n            int to, d; tie(to, d) = e;\n            if(dist[to] > cost + d) {\n                dist[to] = cost + d;\n                que.emplace(to, dist[to]);\n            }\n        }\n    }\n\n    ll ans = 0;\n    for(int i=0; i<V; i++) {\n        chmax(ans, dist[i]);\n        for(auto e : G[i]) {\n            int cur = i, to = e.first, d = e.second;\n            ll x = (dist[to] - dist[cur] + d + 1) / 2;\n            chmax(ans, dist[cur] + x);\n        }\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src_, int dst_, Weight weight_) :\n\t\tsrc(src_), dst(dst_), weight(weight_) { }\n\tEdge(int src_, int dst_) :\n\t\tsrc(src_), dst(dst_) {\n\n\t}\n};\npair<bool, vector<Weight>> spfa(const int v_num, const vector<vector<Edge>>&es, const vector<int> start) {\n\tvector<Weight>diss(v_num, INT_MAX);\n\tqueue<int>que;\n\tvector<bool>use(v_num);\n\tvector<int>count(v_num);\n\tfor (int i = 0; i < start.size(); ++i) {\n\t\tconst int  astart = start[i];\n\t\tque.emplace(astart);\n\t\tdiss[astart] = 0;\n\t}\n\twhile (!que.empty()) {\n\t\tint src(que.front());\n\t\tque.pop();\n\t\tuse[src] = false;\n\t\tfor (auto e : es[src]) {\n\t\t\tconst int d = e.dst;\n\t\t\tif (diss[src] + e.weight < diss[d]) {\n\t\t\t\tdiss[d] = diss[src] + e.weight;\n\t\t\t\tif (!use[d]) {\n\t\t\t\t\tuse[d] = true;\n\t\t\t\t\tcount[d]++;\n\t\t\t\t\tif (count[d] >= v_num)return make_pair(false, vector<Weight>());\n\t\t\t\t\tque.emplace(d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn make_pair(true, diss);\n}\nint main() {\n\tint N, M, K; cin >> N >> M >> K;\n\tvector<vector<Edge>>es(N);\n\tfor (int i = 0; i < M; ++i) {\n\t\tint s, t, l; cin >> s >> t >> l; l *= 2; s--; t--;\n\t\tes[s].emplace_back(s, t, l);\n\t\tes[t].emplace_back(t, s, l);\n\t}\n\tvector<int>starts(K);\n\tfor (int i = 0; i < K; ++i) {\n\t\tcin >> starts[i];\n\t\tstarts[i]--;\n\t}\n\tauto p(spfa(N, es, starts));\n\tvector<Weight>ws(p.second);\n\tint ans = 0;\n\tfor (auto ees : es) {\n\t\tfor (auto e : ees) {\n\t\t\tans = max(ans, (ws[e.src] + ws[e.dst] + e.weight)/2);\n\t\t}\n\t}\n\tcout << (ans+1) /2<< endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 10001\n#define B 100\n#define dmp make_pair\n#define dpb push_back\n#define fi first\n#define se second\n#define P pair<int,int>\ntypedef long long ll;\nconst int inf = 1e9;\nconst ll INF = 1e18;\nusing namespace std;\n//__gcd(a,b), __builtin_popcount(a);\n\nstruct edge{int to, cost;};\nvector<edge> G[3001];\npriority_queue<P, vector<P>, greater<P> > q;\nint v[3001];\n\nint main(){\n\tint n, m, k, a, b, l;\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tfill(v, v+3001, inf);\n\trep(i,m){\n\t\tscanf(\"%d%d%d\", &a, &b, &l);\n\t\tG[a].push_back((edge){b, l});\n\t\tG[b].push_back((edge){a, l});\n\t}\n\trep(i,k){\n\t\tscanf(\"%d\", &a);\n\t\tv[a] = 0;\n\t\tq.push(dmp(0, a));\n\t}\n\t\n\twhile(!q.empty()){\n\t\tP x = q.top();q.pop();\n\t\tif(v[x.se] < x.fi)continue;\n\t\tfor(int i = 0;i < G[x.se].size();i++){\n\t\t\tint t1 = G[x.se][i].to, t2 = G[x.se][i].cost;\n\t\t\tif(v[t1] > v[x.se]+t2){\n\t\t\t\tv[t1] = v[x.se]+t2;\n\t\t\t\tq.push(dmp(v[t1], t1));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tfor(int i = 1;i <= n;i++){\n\t\tfor(int j = 0;j < G[i].size();j++){\n\t\t\tint x = v[i], y = v[G[i][j].to];\n\t\t\tans = max(ans, (x+y+G[i][j].cost+1)/2);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF (1<<29)\n\ntypedef pair<int, int> pii;\n\nint d[3000][3000]; // ???i, j????????¢\nint minCost[3000]; // ???i????????§???????????°??¢???????????§??????????????¢\nint shop[3000];\nvector<pii> g[3000]; // to, cost\nint n, m, k;\n\nint main() {\n\tcin >> n >> m >> k;\n\t\n\tfill(d[0], d[n], INF);\n\tfill(minCost, minCost + n, INF);\n\t\n\tREP(i, m) {\n\t\tint a, b, l;\n\t\tscanf(\"%d %d %d\", &a, &b, &l);\n\t\ta--; b--;\n\t\tg[a].push_back(pii(b, l));\n\t\tg[b].push_back(pii(a, l));\n\t}\n\t\n\tREP(i, k) {\n\t\tint pos;\n\t\tscanf(\"%d\", &pos);\n\t\tpos--;\n\t\tshop[i] = pos;\n\t}\n\t\n\t// i, j?????????????????¢???dijkstra??§?±???????\n\tREP(i, n) {\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > pq; // cost, pos\n\t\tpq.push(pii(0, i));\n\t\t\n\t\twhile (!pq.empty()) {\n\t\t\tpii now = pq.top(); pq.pop();\n\t\t\t\n\t\t\tint ncost = now.first;\n\t\t\tint npos = now.second;\n\t\t\t\n\t\t\tif (d[i][npos] <= ncost) continue;\n\t\t\td[i][npos] = ncost;\n\t\t\t\n\t\t\tREP(j, g[npos].size()) pq.push(pii(ncost + g[npos][j].second, g[npos][j].first)); \n\t\t}\n\t}\n\t\n\t// minCost????±???????\n\tREP(i, n) {\n\t\tint cost = INF;\n\t\tREP(j, k) cost = min(cost, d[i][shop[j]]);\n\t\tminCost[i] = cost;\n\t}\n\t\n\tint ans = 0;\n\tREP(i, n) FOR(j, i + 1, n) {\n\t\tans = max(ans, (minCost[i] + minCost[j] + d[i][j] + 1) / 2);\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nint N, M, K;\n\nstruct edge\n{\n  int to, cost;\n  edge(int t, int c)\n  {\n    to = t; cost = c;\n  }\n};\n\ntypedef pair<int, int> P;\nvector<edge> edges[1000];\nint d[1000];\n\nint dijkstra(int st)\n{\n  priority_queue<P, vector<P>, greater<P> > queue;\n  d[st] = 0;\n  queue.push(make_pair(0, st));\n  while(!queue.empty())\n  {\n    auto p = queue.top(); queue.pop();\n    int v = p.second;\n    if(d[v] < p.first)\n      continue;\n    for(auto e = edges[v].begin(); e != edges[v].end(); ++e)\n    {\n      if(d[e->to] > d[v] + e->cost)\n      {\n        d[e->to] = d[v] + e->cost;\n        queue.push(make_pair(d[e->to], e->to));\n      }\n    }\n  }\n}\n\nint main()\n{\n  fill(d, d + 1000, 1000000000);\n  cin >> N >> M >> K;\n  for(int i = 0; i < M; i++)\n  {\n    int a, b, l;\n    cin >> a >> b >> l;\n    a--; b--;\n    edges[a].push_back(edge(b, l));\n    edges[b].push_back(edge(a, l));\n  }\n  for(int i = 0; i < K; i++)\n  {\n    int a;\n    cin >> a;\n    dijkstra(--a);\n  }\n  int ans = 0;\n  for(int v = 0; v < N; v++)\n  {\n    for(auto e = edges[v].begin(); e != edges[v].end(); ++e)\n    {\n      ans = max(ans, (int)((d[v] + d[e->to]) / 2 + e->cost));\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//27\n#include<iostream>\n#include<algorithm>\n#include<cstdlib>\n\nusing namespace std;\n\nint main(){\n  int n,m,k;\n  cin>>n>>m>>k;\n  int t[3001];\n  fill(t,t+3001,1<<29);\n  int a[10000][2],l[10000];\n  for(int i=0;i<m;i++){\n    cin>>a[i][0]>>a[i][1]>>l[i];\n  }\n  for(int i=0;i<k;i++){\n    int s;\n    cin>>s;\n    t[s]=0;\n  }\n  for(int o=0;o<n;o++){\n    for(int i=0;i<m;i++){\n      for(int j=0;j<2;j++){\n\tt[a[i][j]]=min(t[a[i][j]],t[a[i][!j]]+l[i]);\n      }\n    }\n  }\n  int ll=0;\n  for(int i=0;i<m;i++){\n    ll=max(ll,(ll-abs(t[a[i][0]]-t[a[i][1]])+1)/2+max(t[a[i][0]],t[a[i][1]]));\n  }\n  cout<<ll<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 100000000\ntypedef long long LL;\ntypedef pair<int,int>P;\nstruct edge{int to,cost;};\n\nvector<edge>G[3390];\nint dis[3390];\n\nvoid dijkstra(int s){\n\tpriority_queue<P,vector<P>,greater<P> >Q;\n\tfill(dis,dis+3389,INF);\n\tdis[s]=0;\n\tQ.push(P(0,s));\n\t\n\twhile(Q.size()){\n\t\tP p=Q.top();\n\t\tQ.pop();\n\t\tint v=p.second;\n\t\tif(dis[v]<p.first)continue;\n\t\t\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tedge e=G[v][i];\n\t\t\tif(dis[e.to]>dis[v]+e.cost){\n\t\t\t\tdis[e.to]=dis[v]+e.cost;\n\t\t\t\tQ.push(P(dis[e.to],e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nint main(){\n\tint n,m,k;\n\tcin>>n>>m>>k;\n\t\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tG[a-1].push_back({b-1,c});\n\t\tG[b-1].push_back({a-1,c});\n\t\t}\n\t\t\n\tfor(int i=0;i<k;i++){\n\t\tint a;\n\t\tcin>>a;\n\t\tG[3235].push_back({a-1,0});\n\t\t}\t\n\t\t\n\tdijkstra(3235);\n\t\n\tint ans=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<G[i].size();j++){\n\t\t\tans=max(ans,max(dis[i],dis[G[i][j].to]));\n\t\t\tint ct=0;\n\t\t\tfor(int l=0;l<G[i].size();l++){\n\t\t\t\tif(G[i][l].to==G[i][j].to){\n\t\t\t\t\tct=G[i][l].cost;\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tct+=dis[i];\n\t\t\t\tct+=dis[G[i][j].to];\n\t\t\t\tct=ct+1/2;\n\t\t\t\tans=max(ans,ct);\n\t\t\t}\n\t\t}\t\n\t\tcout<<ans<<endl;\n\t\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "class in{struct myIterator{int it;const bool rev;explicit constexpr myIterator(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(myIterator& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const myIterator i,n;public:explicit constexpr in(int n):i(0),n(n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const myIterator& begin(){return i;}const myIterator& end(){return n;}};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    int n, m, k; cin >> n >> m >> k;\n    vector<vector<pii>> adj(n + 1);\n    for(int _ : in(m)) {\n        int u, v, c;\n        cin >> u >> v >> c;\n        adj[u].emplace_back(v, c);\n        adj[v].emplace_back(u, c);\n    }\n    for(int _ : in(k)) {\n        int s;\n        cin >> s;\n        adj[0].emplace_back(s, 0);\n    }\n    priority_queue<pii, vector<pii>, greater<pii>> que;\n    que.emplace(0, 0);\n    vector<int> dist(n + 1, 1e9);\n    dist[0] = 0;\n    while(!que.empty()) {\n        int curV, curD;\n        tie(curD, curV) = que.top(); que.pop();\n        if(dist[curV] < curD) continue;\n        for(const auto& e : adj[curV]) {\n            int to, cost;\n            tie(to, cost) = e;\n            if(dist[to] > curD + cost) {\n                dist[to] = curD + cost;\n                que.emplace(dist[to], to);\n            }\n        }\n    }\n    int ans = 0;\n    for(int u : in(1, n + 1)) {\n        int tmp = dist[u];\n        for(const auto& e : adj[u]) {\n            int v, c; tie(v, c) = e;\n            int dis = dist[u] + dist[v] + c;\n            dis = (dis & 1) ? dis / 2 + 1 : dis / 2;\n            tmp = max(tmp, dis);\n        }\n        ans = max(ans, tmp);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\nconst int INF = (1LL<<30);\nconst ll LLINF = (1LL<<60);\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n//#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nstruct edge{int to, cost;};\n\nint n, d[3010], m, k, s[3010];\nvector<edge> g[3010];\n\nvoid dijkstra() {\n  priority_queue<PII, vector<PII>, greater<PII>> que;\n  fill(d, d+n, INF);\n  REP(i, k) {\n    d[s[i]] = 0;\n    que.push(PII{0, s[i]});\n  }\n\n  while(que.size()) {\n    PII p = que.top(); que.pop();\n    int v = p.second;\n    if(d[v] < p.first) continue;\n    for(edge e: g[v]) {\n      if(d[e.to] > d[v] + e.cost) {\n        d[e.to] = d[v] + e.cost;\n        que.push(PII{d[e.to], e.to});\n      }\n    }\n  }\n}\n\nint a[100010], b[100010], c[100010];\nsigned main(void)\n{\n  cin >> n >> m >> k;\n  REP(i, m) {\n    cin >> a[i] >> b[i] >> c[i];\n    a[i]--, b[i]--;\n    g[a[i]].PB({b[i], c[i]});\n    g[b[i]].PB({a[i], c[i]});\n  }\n  REP(i, k) cin >> s[i], s[i]--;\n\n  dijkstra();\n  // REP(i, n) cout << d[i] << \" \"; cout << endl;\n\n  int ret = 0;\n  REP(i, m) chmax(ret, (d[a[i]]+d[b[i]]+c[i])/2+!!((d[a[i]]+d[b[i]]+c[i])%2));\n  cout << ret << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate <typename T>\nvector<T> dijkstra(vector<Int> ss,vector<vector<pair<Int, T> > > & G,T INF){\n  using P = pair<T, Int>;\n  Int n=G.size();\n  vector<T> d(n,INF);\n  vector<Int> b(n,-1);\n  priority_queue<P,vector<P>,greater<P> > q;\n  for(Int s:ss){\n    d[s]=0;\n    q.emplace(d[s],s);\n  }\n  while(!q.empty()){\n    P p=q.top();q.pop();\n    Int v=p.second;\n    if(d[v]<p.first) continue;\n    for(auto& e:G[v]){\n      Int u=e.first;\n      T c=e.second;\n      if(d[u]>d[v]+c){\n\td[u]=d[v]+c;\n\tb[u]=v;\n\tq.emplace(d[u],u);\n      }\n    }\n  }\n  return d;\n}\n\n\ntemplate<typename T1,typename T2> void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,m,k;\n  cin>>n>>m>>k;\n  \n  using P = pair<Int, Int>;\n  vector<vector<P> > G(n);\n  for(Int i=0;i<m;i++){\n    Int a,b,c;\n    cin>>a>>b>>c;\n    a--;b--;\n    G[a].emplace_back(b,c);\n    G[b].emplace_back(a,c);\n  }\n\n  vector<Int> ss(k);\n  for(Int i=0;i<k;i++) cin>>ss[i],ss[i]--;\n\n  const Int INF = 1e15;\n  auto dp=dijkstra(ss,G,INF);\n\n  Int ans=0;\n  for(Int v=0;v<n;v++){\n    chmax(ans,dp[v]);\n    for(auto e:G[v]){\n      Int u,c;\n      tie(u,c)=e;\n      c=(c+1)/2;\n      chmax(ans,(dp[v]+dp[u]+1)/2+c);\n    }\n  }\n  \n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nconst int INF = 1e9;\nconst int MAX_N = 3010, MAX_E = 10000;\nint n, m; //????????° ???????????¬??°\nvector<pair<int, int> > G[MAX_N];//??°???????????¨?????£??\\????????? fi:to se:cost\nint d[MAX_N]; //s?????????????????????\ntypedef pair<int, int> P;//first??????????????¢,second??????????????????\nint k;\n\nvoid dijkstra(int s){\n    priority_queue<P, vector<P>, greater<P> > que;//first????°?????????????\n    //k????????????????????°????????????\n    d[s] = 0;\n    que.push(make_pair(0, s));\n  \n    while(!que.empty()){\n        auto p = que.top(); que.pop();\n        int v = p.second;\n        if(d[v] < p.first) continue;\n        for(auto e : G[v]){\n            if(d[e.first] > d[v] + e.second){//???????????¢?????´??°???????????¨???\n                d[e.first] = d[v] + e.second;\n                que.push(make_pair(d[e.first], e.second));\n            }\n        }\n    }\n}\n\nint main(void){\n    cin >> n >> m >> k;\n    rep(i, m){\n        int a, b, l; cin >> a >> b >> l;\n        a--; b--;\n        G[a].push_back(make_pair(b, l)); G[b].push_back(make_pair(a, l));\n    }\n    rep(i, n) d[i] = INF;//?????????\n    rep(i, k){\n        int s; cin >> s; s--;\n        dijkstra(s);//????????????????????????????°?????????????\n    }\n    //?????????????????¶????????????????°?????????????\n    double ans = 0.0;\n    //??????????????????????????¢????????¨???????????????????????¶???????????´?????????????????????????????¢?????????\n    rep(i, n)printf(\"%d\\n\", d[i]);\n    for (int x = 0; x < n; ++x){\n        for(auto y : G[x]){\n            if(d[x] == 0 || d[y.first] == 0)continue;\n            double tmp = (d[x] + d[y.first] + y.second) / 2.0;//+1????????¨?????\\??¨\n            ans = max(tmp, ans);\n        }\n    }\n    cout << round(ans) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing P = pair<int, int>;\n\nstruct edge {\n    int to, weight;\n};\n\nconstexpr int INF = 1e9;\n\nint main() {\n    int N, M, K;\n    cin >> N >> M >> K;\n    vector<vector<edge>> g(N);\n    for(int i=0; i<M; ++i) {\n        int a, b, l;\n        cin >> a >> b >> l;\n        a--; b--;\n        g[a].push_back((edge){b, l});\n        g[b].push_back((edge){a, l});\n    }\n\n    priority_queue<P, vector<P>, greater<P>> que;\n    vector<int> d(N, INF);\n    for(int i=0; i<K; ++i) {\n        int s;\n        cin >> s;\n        s--;\n        que.push(make_pair(0, s));\n        d[s] = 0;\n    }\n\n    while(!que.empty()) {\n        P p = que.top();\n        que.pop();\n        int v = p.second;\n        if(d[v] < p.first) {\n            continue;\n        }\n        for(auto& e : g[v]) {\n            if(d[e.to] > d[v] + e.weight) {\n                d[e.to] = d[v] + e.weight;\n                que.push(make_pair(d[e.to], e.to));\n            }\n        }\n    }\n\n    double res = 0;\n    for(int i=0; i<N; ++i) {\n        res = max(res, (double)d[i]);\n        for(int j=0; j<g[i].size(); ++j) {\n            res = max(res, (d[i] + d[g[i][j].to] + g[i][j].weight) / 2.0);\n        }\n    }\n    cout << (int)floor(res + 0.5) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//  Shopping in JOI Kingdom.cpp\n//  2013/01/06.\n\n#if 1\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst int INF = 1<<30;\n\nint N, M, K;\nint D[3000];\nint C[3000][3000];\nint used[3000];\n\nint dfs(int pnt)\n{\n\trep(next, N) if(D[next] > D[pnt] + C[pnt][next])\n\t{\n\t\tD[next] = D[pnt] + C[pnt][next];\n\t\tdfs(next);\n\t}\n}\n\nvoid dijkstra(int pnt)\n{\n\tmemset(used, 0, sizeof used);\n\t\n\twhile(true)\n\t{\n\t\tint v = -1;\n\t\t\n\t\trep(u, N) if(!used[u] && (v == -1 || D[u] < D[v])) v = u;\n\t\t\n\t\tif(v == -1) break;\n\t\t\n\t\tused[v] = true;\n\t\t\n\t\trep(u, N) chmin(D[u], D[v] + C[v][u]);\n\t}\n}\n\nint calc(int a, int b, int l)\n{\n\treturn round(min(a, b) + (l + max(a, b) - min(a, b)) / 2.0);\n}\n\nint main()\n{\n\trep(i, 3000) rep(j, 3000) D[i] = C[i][j] = INF;\n\t\n\tcin >> N >> M >> K;\n\n\trep(m, M)\n\t{\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\t\n\t\tC[a-1][b-1] = C[b-1][a-1] = c;\n\t}\n\t\n\trep(k, K)\n\t{\n\t\tint s;\n\t\tcin >> s;\n\t\t\n\t\tD[s-1] = 0;\n\t\tdijkstra(s-1);\n\t}\n\t\n\n\tint ans = 0;\n\t\n\trep(a, N) REP(b, a+1, N) if(C[a][b] < INF) chmax(ans, calc(D[a], D[b], C[a][b]));\n\t\n\tcout << ans << endl;\n}\n\n#endif"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#define int long long\nusing namespace std;\nsigned main() {\n\tint mx = 3000;\n\tint n,m,k;\n\tcin >> n >> m >> k;\n\tvector<int> sc(n,0);\n\tvector<int> a(m);\n\tvector<int> b(m);\n\tvector<int> l(m);\n\tvector<int> ma(m);\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> a[i] >> b[i] >> l[i];\n\t\ta[i]--; b[i]--;\n\t\tsc[a[i]]++;\n\t\tsc[b[i]]++;\n\t}\n\tvector<vector<int> > hy(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tvector<int> ze(sc[i]);\n\t\thy[i] = ze;\n\t}\n\tvector<int> co(n, 0);\n\tfor (int i = 0; i < m; i++) {\n\t\tint a1 = a[i];\n\t\tint b1 = b[i];\n\t\thy[a1][co[a1]] = i;\n\t\thy[b1][co[b1]] = i;\n\t\tco[a1]++;\n\t\tco[b1]++;\n\t}\n\tvector<int> dis(n, mx*mx);\n\tvector<int> ne(n,0);\n\tvector<int> nne(n);\n\tvector<int> ze(n, 0);\n\tvector<int> alch(n, 0);\n\tint to = 0;\n\tfor (int i = 0; i < k; i++) {\n\t\tint x;\n\t\tcin >> x;\n\t\tx--;\n\t\tdis[x] = 0;\n\t\tne[to] = x;\n\t\tto++;\n\t}\n\twhile (0 < to) {\nalch=ze;\n\t\tint qto = 0;\n\t\tnne = ze;\n\t\tfor (int i = 0; i < to; i++) {\n\t\t\tint x = ne[i];\n\t\t\tfor (int j = 0; j < sc[x]; j++) {\n\t\t\t\tint num = hy[x][j];\n\t\t\t\tint y = a[num] + b[num] - x;\n\t\t\t\tif (dis[y] > dis[x] + l[num]) {\n\t\t\t\t\tdis[y] = dis[x] + l[num];\n\t\t\t\t\tif (alch[y] == 0) {\n\t\t\t\t\t\tnne[qto] = y;\n\t\t\t\t\t\tqto++;\n\t\t\t\t\t\talch[y] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tne = nne;\n\t\tto = qto;\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tint x = a[i];\n\t\tint y = b[i];\n\t\tans = max(ans, (dis[x] + dis[y] + l[i] + 1) / 2);\n\t}\n\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\nusing namespace std;\nint main(){\n\tint i,j;\n\tint n,m,l;;\n\tscanf(\"%d%d%d\",&n,&m,&l);\n\tvector<pair<int,int> > a[3000];\n\tfor(i=0;i<m;++i){\n\t\tint p,q,r;\n\t\tscanf(\"%d%d%d\",&p,&q,&r);\n\t\t--p;\n\t\t--q;\n\t\ta[p].push_back(make_pair(q,r));\n\t\ta[q].push_back(make_pair(p,r));\n\t}\n\tint b[3000];\n\tmemset(b,0x7f,sizeof(b));\n\tpriority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > c;\n\tfor(i=0;i<l;++i){\n\t\tint p;\n\t\tscanf(\"%d\",&p);\n\t\t--p;\n\t\tb[p]=0;\n\t\tc.push(make_pair(0,p));\n\t}\n\twhile(!c.empty()){\n\t\tint p,q;\n\t\tp=c.top().first;\n\t\tq=c.top().second;\n\t\tc.pop();\n\t\tfor(i=0;i<(int)a[q].size();++i){\n\t\t\tif(b[a[q][i].first]<=p+a[q][i].second)\n\t\t\t\tcontinue;\n\t\t\tb[a[q][i].first]=p+a[q][i].second;\n\t\t\tc.push(make_pair(p+a[q][i].second,a[q][i].first));\n\t\t}\n\t}\n\tint mx=0;\n\tfor(i=0;i<n;++i)\n\t\tfor(j=0;j<(int)a[i].size();++j)\n\t\t\tmx=max(mx,max(b[i],b[a[i][j].first])+(a[i][j].second-abs(b[i]-b[a[i][j].first])+1)/2);\n\tprintf(\"%d\\n\",mx);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Edge\n{\npublic:\n    int to, cost;\n    Edge(){};\n    Edge(int to0, int cost0){to = to0; cost = cost0;}\n};\n\nvoid shortestPath(const vector<vector<Edge> >& edges, const vector<int>& start, vector<int>& dist)\n{\n    dist.assign(edges.size(), INT_MAX);\n    priority_queue<pair<int,int> ,vector<pair<int,int> >, greater<pair<int,int> > > q;\n    for(unsigned i=0; i<start.size(); ++i){\n        dist[start[i]] = 0;\n        q.push(make_pair(0, start[i]));\n    }\n\n    while(!q.empty()){\n        pair<int, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first)\n            continue;\n        for(unsigned i=0; i<edges[v].size(); ++i){\n            Edge e = edges[v][i];\n            if(dist[v] + e.cost < dist[e.to]){\n                dist[e.to] = dist[v] + e.cost;\n                q.push(make_pair(dist[e.to], e.to));\n            }\n        }\n    }\n\n    replace(dist.begin(), dist.end(), INT_MAX, -1);\n}\n\nint main()\n{\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    vector<vector<Edge> > edges(n);\n    while(--m >= 0){\n        int a, b, l;\n        cin >> a >> b >> l;\n        edges[a-1].push_back(Edge(b-1, l));\n        edges[b-1].push_back(Edge(a-1, l));\n    }\n\n    vector<int> start(k);\n    for(int i=0; i<k; ++i){\n        cin >> start[i];\n        -- start[i];\n    }\n\n    vector<int> dist;\n    shortestPath(edges, start, dist);\n\n    int ret = 0;\n    for(int i=0; i<n; ++i){\n        for(unsigned j=0; j<edges[i].size(); ++j){\n            int a = dist[i];\n            int b = dist[edges[i][j].to];\n            int x = edges[i][j].cost - a + b;\n            if(x < 0 || x > edges[i][j].cost * 2)\n                continue;\n            ret = max(ret, a + (x+1) / 2);\n        }\n    }\n\n    cout << ret << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint x[4000][4000];\nint n,m,a,b,c,k;\nint s[4000],d[4000];\nint X[4000];\ndouble maxn;int res;\n\nint main(){\n\tmemset(X,63,sizeof(X));\n\tcin>>n>>m>>k;\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>a>>b>>c;\n\t\tx[a][b]=c;\n\t\tx[b][a]=c;\n\t}\n\tfor(int i=0;i<k;i++){\n\t\tcin>>a;\n\t\ts[a]=1;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(s[i]==1){\n\t\t\tmemset(d,63,sizeof(d));\n\t\t\td[i]=0;\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tif(d[j]<100000000){\n\t\t\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t\t\tif(x[j][k]>=1){\n\t\t\t\t\t\t\td[k]=min(d[k],d[j]+x[j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tX[j]=min(X[j],d[j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tmaxn=max((int)maxn,X[i]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(x[j][k]>=1){\n\t\t\t\tmaxn=max(maxn,(double)(min(1.0*X[i]+0.5,1.0*X[j]+0.5)));\n\t\t\t}\n\t\t}\n\t}\n\tres=(1.0*maxn+0.99999999);\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<map>\n#include<algorithm>\n#define INF (1<<29)\nusing namespace std;\n\nint pass[3001][3001];\nint saitan[3001], ans;\n\nint main(){\n  int n, m, k;\n  vector<int> neib[3001];\n  priority_queue<pair<int, int> > que;\n  scanf(\"%d%d%d\", &n, &m, &k);\n  for(int i = 0;i <= n;i++){\n    saitan[i] = INF;\n  }\n  for(int i = 0;i < m;i++){\n    int a, b, l;\n    scanf(\"%d%d%d\", &a, &b, &l);\n    neib[a].push_back(b);\n    neib[b].push_back(a);\n    pass[a][b] = pass[b][a] = l;\n  }\n  for(int i = 0;i < k;i++){\n    int s;\n    scanf(\"%d\", &s);\n    saitan[s] = 0;\n    que.push(make_pair(0, s));\n  }\n  while(!que.empty()){\n    pair<int, int> tmp = que.top(); que.pop();\n    for(int i = 0;i < neib[tmp.second].size();i++){\n      int from = tmp.second;\n      int to = neib[tmp.second][i];\n      if(saitan[to] > saitan[from] + pass[from][to]){\n\tsaitan[to] = saitan[from] + pass[from][to];\n\tque.push(make_pair(saitan[to], to));\n      }    \n    }    \n  }\n  for(int i = 1;i <= n;i++){\n    ans = max(ans, saitan[i]);\n    for(int j = 0;j < neib[i].size();i++){\n      int to = neib[i][j];\n      if(abs(saitan[i] - saitan[to]) < pass[i][to]){\n\tans = max(ans,(1 + saitan[i] + saitan[to] + pass[i][to]) / 2);\n      }\n    }\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nint n, m, k;\nint amat[5000][5000];\nint vtx[5000];\nvector<int> mal;\n\nint solve(){\n\t\n\tfor(int i=0; i<n; ++i){\n\t\tvtx[i] = INT_MAX;\n\t}\n\n\tfor(int s=0; s<k; ++s){\n\n\t\tint vtx_tmp[5000];\n\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tvtx_tmp[i] = INT_MAX;\n\t\t}\n\t\t\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tqu.push(make_pair(0, mal[s]));\n\t\tvtx_tmp[mal[s]]=0;\n\t\t\n\t\twhile(!qu.empty()){\n\n\t\t\tint now = qu.top().second;\n\t\t\tqu.pop();\n\n\t\t\tfor(int i=0; i<n; ++i){\n\n\t\t\t\tif( amat[now][i] && vtx_tmp[i] > vtx_tmp[now] + amat[now][i]){\n\n\t\t\t\t\tvtx_tmp[i] = vtx_tmp[now] + amat[now][i];\n\t\t\t\t\tqu.push( make_pair(vtx_tmp[i], i) );\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0; i<n; ++i){\t\n\t\t\tvtx[i] = min(vtx[i], vtx_tmp[i]);\n\t\t}\n\t}\n\n\tint ma = -1;\n\n\tfor(int i=0; i<n-1; ++i){\n\t\tfor(int j=i+1; j<n; ++j){\n\t\t\t\n\t\t\tif(amat[i][j]){\n\t\t\t\tma = max(ma, min(vtx[i], vtx[j]) + (amat[i][j] + abs(vtx[i]-vtx[j]))/2 );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ma;\n}\n\nint main(){\n\n\tcin >> n >> m >> k;\n\n\tfor(int i=0; i<m; ++i){\n\t\t\n\t\tint a, b, l;\n\t\tcin >> a >> b >> l;\n\t\ta--; b--;\n\t\tamat[a][b] = amat[b][a] = l;\n\t}\n\n\tfor(int i=0; i<k; ++i){\n\n\t\tint s;\n\t\tcin>>s;\n\t\tmal.push_back(--s);\n\t}\n\n\tcout << solve() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//27\n#include<iostream>\n#include<algorithm>\n#include<cstdlib>\n\nusing namespace std;\n\nint main(){\n  int n,m,k;\n  cin>>n>>m>>k;\n  int t[3001];\n  fill(t,t+3001,1<<29);\n  int a[10000][2],l[10000];\n  for(int i=0;i<m;i++){\n    cin>>a[i][0]>>a[i][1]>>l[i];\n  }\n  for(int i=0;i<k;i++){\n    int s;\n    cin>>s;\n    t[s]=0;\n  }\n  for(int o=0;o<n;o++){\n    for(int i=0;i<m;i++){\n      for(int j=0;j<2;j++){\n\tt[a[i][j]]=min(t[a[i][j]],t[a[i][!j]]+l[i]);\n      }\n    }\n  }\n  int ll=0;\n  for(int i=0;i<m;i++){\n    ll=max(ll,(l[i]-abs(t[a[i][0]]-t[a[i][1]])+1)/2+max(t[a[i][0]],t[a[i][1]]));\n  }\n  cout<<ll<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define s size()\n#define INF 100000000\nint cost[3005][3005];\nint d[3005];\nint maxi[100005]={};\nbool used[3005]={};\nP1 ii[100005];\nint V;\nvoid dijkstra(int os){\n\tfill(d,d+V,INF);\n\td[s]=0;\n\twhile(1){\n\t\tint v=-1;\n\t\tfor(int u=0;u<V;u++){\n\t\t\tif(!used[u] && (v==-1 || d[u]<d[v])){\n\t\t\t\tv=u;\n\t\t\t}\n\t\t}\n\t\tif(v==-1){\n\t\t\tbreak;\n\t\t}\n\t\tused[v]=true;\n\t\tfor(int i=0;i<V;i++){\n\t\t\td[i]=min(d[i],d[v]+cost[v][i]);\n\t\t}\n\t}\n}\nint n,m,k;\nint main(){\n\tscanf(\"%d %d %d\",&n,&m,&k);\n\tfor(int i=0;i<3005;i++){\n\t\tfor(int j=0;j<3005;j++){\n\t\t\tcost[i][j]=INF;\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint w,ww,eu;\n\t\tscanf(\"%d %d %d\",&w,&ww,&eu);\n\t\tii[i]=mp(eu,mp(w,ww));\n\t\tcost[w-1][ww-1]=eu;\n\t\tcost[ww-1][w-1]=eu;\n\t}\n\tint res=0;\n\tfor(int i=0;i<k;i++){\n\t\tint t;\n\t\tscanf(\"%d\",&t);\n\t\tdijkstra(t-1);\n\t\tmemset(used,0,sizeof(used));\n\t\tfor(int j=0;j<m;j++){\n\t\t\tmaxi[j]=max(maxi[j],(ii[j].first+d[ii[j].second.first-1]+d[ii[j].second.second-1]+1)/2);\n\t\t}\n\t}\n\tfor(int j=0;j<m;j++){\n\t\tres=max(res,maxi[j]);\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\nusing namespace std;\n\nvector<int>x[4000];\nint n,m,a,b,c,k,G;\nint s[4000],d[4000];\nint X[4000];\ndouble maxn;int res;\n\nint main(){\n\tmemset(X,63,sizeof(X));\n\tcin>>n>>m>>k;\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>a>>b>>c;\n\t\tx[a].push_back(b*10000+c);\n\t\tx[b].push_back(a*10000+c);\n\t}\n\tfor(int i=0;i<k;i++){\n\t\tcin>>a;\n\t\ts[a]=1;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(s[i]==1){\n\t\t\tmemset(d,63,sizeof(d));\n\t\t\td[i]=0;\n\t\t\tif(n<500){G=n;}\n\t\t\telse{\n\t\t\t\tG=max(50,(n+k)/k+10);\n\t\t\t}\n\t\t\tfor(int h=1;h<=G;h++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tif(d[j]<100000000){\n\t\t\t\t\t\tfor(int k=0;k<x[j].size();k++){\n\t\t\t\t\t\t\td[x[j][k]/10000]=min(d[x[j][k]/10000],d[j]+x[j][k]%10000);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tX[j]=min(X[j],d[j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tmaxn=max((int)maxn,X[i]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<x[i].size();j++){\n\t\t\tif(abs(X[i]-X[x[i][j]/10000])<x[i][j]%10000){\n\t\t\t\ta=x[i][j]%10000-abs(X[i]-X[x[i][j]/10000]);\n\t\t\t\tmaxn=max(maxn,(double)(max(X[i],X[(int)(x[i][j]/10000)])+1.0*a/2.0));\n\t\t\t}\n\t\t}\n\t}\n\tres=(1.0*maxn+0.99999999);\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nint N, M, K;\n\nstruct edge\n{\n  int to, cost;\n  edge(int t, int c)\n  {\n    to = t; cost = c;\n  }\n};\n\ntypedef pair<int, int> P;\nvector<edge> edges[1000];\nint d[1000];\n\nint dijkstra(int st)\n{\n  priority_queue<P, vector<P>, greater<P> > queue;\n  d[st] = 0;\n  queue.push(make_pair(0, st));\n  while(!queue.empty())\n  {\n    auto p = queue.top(); queue.pop();\n    int v = p.second;\n    if(d[v] < p.first)\n      continue;\n    for(auto e = edges[v].begin(); e != edges[v].end(); ++e)\n    {\n      if(d[e->to] > d[v] + e->cost)\n      {\n        d[e->to] = d[v] + e->cost;\n        queue.push(make_pair(d[e->to], e->to));\n      }\n    }\n  }\n}\n\nint main()\n{\n  fill(d, d + 1000, 1000000000);\n  cin >> N >> M >> K;\n  for(int i = 0; i < M; i++)\n  {\n    int a, b, l;\n    cin >> a >> b >> l;\n    a--; b--;\n    edges[a].push_back(edge(b, l));\n    edges[b].push_back(edge(a, l));\n  }\n  for(int i = 0; i < K; i++)\n  {\n    int a;\n    cin >> a;\n    dijkstra(--a);\n  }\n  int ans = 0;\n  for(int v = 0; v < N; v++)\n  {\n    for(auto e = edges[v].begin(); e != edges[v].end(); ++e)\n    {\n      ans = max(ans, (int)((d[v] + d[e->to]) / 2 + e->cost));\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <map>\n#include <algorithm>\n#define fi first\n#define sec second\n#define INF 100000000\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n,m,k;\nint cost[3000][3000];\nint cnt[3000];\nvector<P> e[3000];\nbool shop[3000];\nint ans;\n\nvoid dijkstra(int s){\n\trep(i,n) cost[s][i] = INF;\n\tif(!shop[s]) return; \n\tcost[s][s] = 0;\n\tqueue<P> que;\n\tque.push(P(s,0));\n\twhile(true){\n\t\tif(que.size()==0) break;\n\t\tP p = que.front(); que.pop();\n\t\tif(p.sec > cost[s][p.fi]) continue;\n\t\trep(i,e[p.fi].size()){\n\t\t\tif(cost[s][e[p.fi][i].fi] > cost[s][p.fi]+e[p.fi][i].sec){\n\t\t\t\tcost[s][e[p.fi][i].fi] = cost[s][p.fi]+e[p.fi][i].sec;\n\t\t\t\tque.push(P(e[p.fi][i].fi,cost[s][e[p.fi][i].fi]));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint Abs(int x){\n\treturn x>0?x:-x;\n}\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\trep(i,m){\n\t\tint a,b,l; scanf(\"%d%d%d\",&a,&b,&l);\n\t\ta--; b--;\n\t\te[a].push_back(P(b,l));\n\t\te[b].push_back(P(a,l));\n\t}\n\trep(i,k){\n\t\tint s; scanf(\"%d\",&s);\n\t\ts--;\n\t\tshop[s] = true;\n\t}\n\trep(i,n) dijkstra(i);\n\trep(i,n) cnt[i] = INF;\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tcnt[i] = min(cnt[i],cost[j][i]);\n\t\t}\n\t}\n\trep(i,n) ans = max(ans,cnt[i]);\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < e[i].size(); j++){\n\t\t\tint f = e[i][j].fi, s = e[i][j].sec;\n\t\t\tans = max(ans,max(cnt[i],cnt[f])+(s-Abs(cnt[i]-cnt[f])+1)/2);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\n// ¹öª¢çÈ¢ê\nvector<Weight> dijkstra2(const Graph &g, vector<int> s) {\n  vector<Weight> dist(g.size(), INF);\n  priority_queue<Edge> Q; // \"e < f\" <=> \"e.weight > f.weight\"\n  REP(i, s.size()) {\n    dist[s[i]] = 0;\n    Q.push(Edge(-2, s[i], 0));\n  }\n  for (; !Q.empty(); ) {\n    Edge e = Q.top(); Q.pop();\n    if (dist[e.dst] < e.weight) continue;\n    FOR(f,g[e.dst]) {\n      if (dist[f->dst] > e.weight+f->weight) {\n        dist[f->dst] = e.weight+f->weight;\n        Q.push(Edge(f->src, f->dst, e.weight+f->weight));\n      }\n    }\n  }\n  return dist;\n}\n\nint A[100000],B[100000], C[100000];\nint main() {\n  int n,m,k;\n  cin >> n >> m >> k;\n  Graph g(n);\n  REP(i, m) {\n    cin >> A[i] >> B[i] >> C[i];\n    A[i]--;B[i]--;\n    g[A[i]].push_back(Edge(A[i],B[i],C[i]));\n    g[B[i]].push_back(Edge(B[i],A[i],C[i]));\n  }\n  vector<int> v;\n  REP(i, k) {\n    int a;\n    cin >> a;\n    a--;\n    v.push_back(a);\n  }\n  vector<int> dist = dijkstra2(g, v);\n  double ans = 0;\n  REP(i, m) {\n    ans = max(ans, (dist[A[i]] + dist[B[i]] + C[i])/2.0);\n  }\n  cout << (int)(ans+0.5) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\nint N, M, K, A, B, L;\n\nvector<vector<pair<int, int> > > G;\n\nvector<int> P, D;\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tscanf(\"%d\", &M);\n\tscanf(\"%d\", &K);\n\n\tG = vector<vector<pair<int, int> > >(N);\n\n\tfor (int i = 0; i < M; i++)\n\t{\n\t\tscanf(\"%d\", &A);\n\t\tscanf(\"%d\", &B);\n\t\tscanf(\"%d\", &L);\n\n\t\tG[A - 1].push_back(make_pair(B - 1, L));\n\t\tG[B - 1].push_back(make_pair(A - 1, L));\n\t}\n\n\tP = vector<int>(K);\n\n\tfor (int i = 0; i < K; i++)\n\t{\n\t\tscanf(\"%d\", &P[i]); P[i]--; // 0 - indexed\n\t}\n\n\tD = vector<int>(N, 999999999);\n\n\tfor (int i = 0; i < K; i++)\n\t{\n\t\tpriority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > que;\n\n\t\tque.push(make_pair(0, i));\n\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tint dist = que.top().first;\n\t\t\tint node = que.top().second; que.pop();\n\n\t\t\tfor (int j = 0; j < G[node].size(); j++)\n\t\t\t{\n\t\t\t\tint node2 = G[node][i].first;\n\t\t\t\tint leng2 = G[node][i].second;\n\n\t\t\t\tif (D[node2] > D[node] + leng2)\n\t\t\t\t{\n\t\t\t\t\tD[node2] = D[node] + leng2;\n\n\t\t\t\t\tque.push(make_pair(D[node2], node2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint ret = 0;\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < G[i].size(); j++)\n\t\t{\n\t\t\tret = max(ret, D[i] + D[G[i][j].first] + G[i][j].second);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", (ret + 1) / 2);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "class in{struct myIterator{int it;const bool rev;explicit constexpr myIterator(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(myIterator& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const myIterator i,n;public:explicit constexpr in(int n):i(0),n(n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const myIterator& begin(){return i;}const myIterator& end(){return n;}};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    int n, m, k; cin >> n >> m >> k;\n    vector<vector<pii>> adj(n + 1);\n    for(int _ : in(m)) {\n        int u, v, c;\n        cin >> u >> v >> c;\n        adj[u].emplace_back(v, c);\n        adj[v].emplace_back(u, c);\n    }\n    for(int _ : in(k)) {\n        int s;\n        cin >> s;\n        adj[0].emplace_back(s, 0);\n    }\n    priority_queue<pii, vector<pii>, greater<pii>> que;\n    que.emplace(0, 0);\n    vector<int> dist(n + 1, 1e9);\n    dist[0] = 0;\n    while(!que.empty()) {\n        int curV, curD;\n        tie(curD, curV) = que.top(); que.pop();\n        if(dist[curV] < curD) continue;\n        for(const auto& e : adj[curV]) {\n            int to, cost;\n            tie(to, cost) = e;\n            if(dist[to] > curD + cost) {\n                dist[to] = curD + cost;\n                que.emplace(dist[to], to);\n            }\n        }\n    }\n    int ans = 0;\n    for(int u : in(1, n + 1)) {\n        int tmp = dist[u];\n//        cout << u << ' ' << dist[u] << endl;\n        for(const auto& e : adj[u]) {\n            int v, c; tie(v, c) = e;\n            if(dist[v] >= dist[u]) {\n                c = (c & 1) ? c / 2 + 1 : c / 2;\n                tmp = max(tmp, dist[u] + c);\n            }\n            else if(c > dist[u]) {\n                int dis = dist[u] + c;\n                dis = (dis & 1) ? dis / 2 + 1 : dis / 2;\n                tmp = max(tmp, dis);\n            }\n        }\n//        cout << tmp << endl;\n        ans = max(ans, tmp);\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<vector>\n#include<queue>\n#include<functional>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint N,M,K;\t\t//町数、道の数、店舗数\nstruct NODE{\n\tvector<int> cost,list;\n\tint minest;\t//頂点から店への最短距離\n}MISE[3000];\n\nvoid Ini(int *a,int index,int num){\n\tfor(int i = 0;i < index;i++){\n\t\ta[i] = num;\n\t}\n}\nvoid Dijkstra(int left){\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tint done[3000],DEFINEED = 0;\n\tint nowcost[3000];\n\tP edge;\n\tIni(done,N,-1);\n\tIni(nowcost,N,500000000);\n\tque.push(P(0,left));\n\twhile(DEFINEED < N && !que.empty()){\n\t\tedge = que.top();\n\t\tque.pop();\n\t\tif(done[edge.second] >= 0)\n\t\t\tcontinue;\n\t\tDEFINEED++;\n\t\tdone[edge.second] = edge.first;\n\t\t//確定した頂点から枝を出す\n\t\tint lsize;\n\t\tlsize = MISE[edge.second].list.size();\n\t\tfor(int i = 0;i < lsize;i++){\n\t\t\tif(done[MISE[edge.second].list[i]] == -1 && nowcost[MISE[edge.second].list[i]] > edge.first+MISE[edge.second].cost[i]){\n\t\t\t\tnowcost[MISE[edge.second].list[i]] = edge.first+MISE[edge.second].cost[i];\n\t\t\t\tque.push(P(nowcost[MISE[edge.second].list[i]],MISE[edge.second].list[i]));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int  i = 0;i < N;i++){\n\t\tif(MISE[i].minest > done[i] && done[i] != -1)\n\t\t\tMISE[i].minest = done[i];\n\t}\n}\nint main(){\n\tint i,a,b,c;\n\tint Mplace;\n\tcin >> N >> M >> K;\n\tfor(i = 0;i < N;i++){\n\t\tMISE[i].minest = 500000000;\n\t}\n\tfor(i = 0;i < M;i++){\n\t\tcin >> a >> b >> c;\n\t\ta--;b--;\n\t\t//隣接リスト作成。道の生成による影響は2ノード間にのみ作用する。\n\t\tMISE[a].list.push_back(b);\n\t\tMISE[a].cost.push_back(c);\n\t\tMISE[b].list.push_back(a);\n\t\tMISE[b].cost.push_back(c);\n\t}\n\tfor(i = 0;i < K;i++){\n\t\tcin >> Mplace;\n\t\tMplace--;\n\t\tDijkstra(Mplace);\n\t}\n\tdouble D_length;\n\tint I_length,I_Mlength = 0;\n\tfor(i = 0;i < N;i++){\n\t\t//枝の間が一番距離が長くなりそう\n\t\tint lsize;\n\t\tlsize = MISE[i].list.size();\n\t\tfor(int j = 0;j < lsize;j++){\n\t\t\tD_length = (double)MISE[i].cost[j]/2.0;\n\t\t\tD_length += (MISE[i].minest+MISE[MISE[i].list[j]].minest)/2.0;\n\t\t\tif(D_length - (int)D_length == 0)\n\t\t\t\tI_length = (int)D_length;\n\t\t\telse\n\t\t\t\tI_length = (int)D_length+1;\n\t\t\tif(I_Mlength < I_length)\n\t\t\t\tI_Mlength = I_length;\n\t\t}\n\t}\n\tcout << endl << I_Mlength << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nstruct Edge { int to, c; };\n\nstruct State {\n\tint v, c;\n\tbool operator > (const State& e) const { return c > e.c; }\n};\n\nint N, M, K, dst[3030];\nvector< vector< Edge > > adj;\n\nvoid solve() {\n\tfor_(i,0,N) dst[i] = 3030 * 1010;\n\t\n\tpriority_queue< State, vector< State >, greater< State > > que;\n\t\n\tfor_(i,0,K) {\n\t\tint s;\n\t\tcin >> s;\n\t\t--s;\n\t\tque.push(State{s, 0});\n\t\tdst[s] = 0;\n\t}\n\t\n\twhile (!que.empty()) {\n\t\tState s = que.top(); que.pop();\n\t\t\n\t\tif (dst[s.v] < s.c) continue;\n\t\t\n\t\tfor (const Edge& e : adj[s.v]) {\n\t\t\tif (dst[e.to] > s.c + e.c) {\n\t\t\t\tdst[e.to] = s.c + e.c;\n\t\t\t\tque.push(State{e.to, dst[e.to]});\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\t\n\tfor_(v,0,N) {\n\t\tint dst_v = dst[v];\n\t\t\n\t\tfor (const Edge& e : adj[v]) {\n\t\t\tint dst_u = dst[e.to];\n\t\t\tans = max(ans, int(double(dst_v + dst_u + e.c) / 2.0 + 0.5));\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\tcin >> N >> M >> K;\n\t\n\tadj.assign(N, vector< Edge >());\n\t\n\tfor_(i,0,M) {\n\t\tint a, b, l;\n\t\tcin >> a >> b >> l;\n\t\t--a; --b;\n\t\tadj[a].push_back(Edge{b, l});\n\t\tadj[b].push_back(Edge{a, l});\n\t}\n\t\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3002\nusing namespace std;\ntypedef pair<int,int> P;\nvector<P> G[N];\nbool num[N];\nint n,m,K;\n\ndouble dijkstra(){\n  vector<int> D(N,1e9);\n  priority_queue<P,vector<P>,greater<P> >Q;\n  for(int i=0;i<n;i++)if(num[i]) Q.push(P(0,i)),D[i] = 0;\n  \n  while(!Q.empty()){\n    P t = Q.top();Q.pop();\n    int cost = t.first;\n    int pos = t.second;\n    if(D[pos]<cost) continue;\n\n    for(int i=0;i<G[pos].size();i++){\n      int npos = G[pos][i].first;\n      int ncost = cost+G[pos][i].second;\n      if(D[npos]<=ncost) continue;\n      Q.push(P(ncost,npos));\n      D[npos] = ncost;\n    }\n  }\n\n  double res = 0;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<(int)G[i].size();j++){\n      int npos = G[i][j].first;\n      int ncost = G[i][j].second;\n      res = max(res,(D[i]+D[npos]+ncost)/2.0);\n    }\n  return res;\n   \n}\n \nint main(){\n  cin>>n>>m>>K;\n  for(int i=0,a,b,c;i<m;i++){\n    cin>>a>>b>>c;\n    G[a-1].push_back(P(b-1,c));\n    G[b-1].push_back(P(a-1,c));\n  }\n \n  for(int i=0,a;i<K;i++)cin>>a,num[a-1]=1;\n  printf(\"%d\\n\",(int)(dijkstra()+0.5));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\nusing namespace std;\n\nvector<int>x[4000];\nint n,m,a,b,c,k;\nint s[4000],d[4000];\nint X[4000];\ndouble maxn;int res;\n\nint main(){\n\tmemset(X,63,sizeof(X));\n\tcin>>n>>m>>k;\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>a>>b>>c;\n\t\tx[a].push_back(b*10000+c);\n\t\tx[b].push_back(b*10000+c);\n\t}\n\tfor(int i=0;i<k;i++){\n\t\tcin>>a;\n\t\ts[a]=1;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(s[i]==1){\n\t\t\tmemset(d,63,sizeof(d));\n\t\t\td[i]=0;\n\t\t\tfor(int h=1;h<=n;h++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tif(d[j]<100000000){\n\t\t\t\t\t\tfor(int k=0;k<x[j].size();k++){\n\t\t\t\t\t\t\td[x[j][k]/10000]=min(d[x[j][k]/10000],d[j]+x[j][k]%10000);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tX[j]=min(X[j],d[j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tmaxn=max((int)maxn,X[i]);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=0;j<x[i].size();j++){\n\t\t\tif(abs(X[i]-X[j])<x[i][j]%10000){\n\t\t\t\ta=x[i][j]%10000-abs(X[i]-X[j]);\n\t\t\t\tmaxn=max(maxn,(double)(max(X[i],X[j])+1.0*a/2.0));\n\t\t\t}\n\t\t}\n\t}\n\tres=(1.0*maxn+0.99999999);\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <queue>\n#include <vector>\n#include <functional>\n\nusing namespace std;\nusing P = pair<int, int>;\n\nstruct edge { int to, cost; };\n\nconst int MAX_N = 3000;\n\nint dist[MAX_N + 1];\nvector<edge>graph[MAX_N + 1];\n\nint n, m, k;\n\nvoid dijkstra()\n{\n\tfor (int i = 0; i <= n; ++i)dist[i] = 123456789;\n\tdist[0] = 0;\n\tpriority_queue<P, vector<P>, greater<P>>que;\n\tque.push(make_pair(0, 0));\n\twhile (!que.empty())\n\t{\n\t\tP u = que.top(); que.pop();\n\t\tif (dist[u.second] < u.first)continue;\n\t\tfor (edge e : graph[u.second])\n\t\t{\n\t\t\tint alt = u.first + e.cost;\n\t\t\tif (dist[e.to] > alt)\n\t\t\t{\n\t\t\t\tdist[e.to] = alt;\n\t\t\t\tque.push(make_pair(alt, e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tint a, b, l;\n\t\tscanf(\"%d %d %d\", &a, &b, &l);\n\t\tgraph[a].push_back({ b,l });\n\t\tgraph[b].push_back({ a,l });\n\t}\n\tfor (int i = 0; i < k; ++i)\n\t{\n\t\tint s;\n\t\tscanf(\"%d\", &s);\n\t\tgraph[0].push_back({ s,0 });\n\t}\n\tdijkstra();\n\tint ans = 0;\n\tfor (int v = 1; v <= n; ++v)\n\t{\n\t\tfor (edge e : graph[v])\n\t\t{\n\t\t\tint u = e.to;\n\t\t\tint cost = e.cost;\n\t\t\tint a = min(dist[u], dist[v]);\n\t\t\tint b = max(dist[u], dist[v]);\n\t\t\tans = max(ans, (int)round((b - a + cost) / 2.0) + a);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<utility>\n#include<cmath>\n#define MP make_pair\nusing namespace std;\ntypedef pair<int, int> PII;\ntypedef vector<PII> VP;\ntypedef priority_queue<PII, VP, greater<PII> > LOWQ;\n\nint n, m, k;\nint a[100000], b[100000], l[100000];\nint s[3000];\n\nint dist[3001];\nVP road[3001];\nbool checked[3001];\nLOWQ q;\n\nint ans = 0;\n\nvoid dijk()\n{\n  for(int i = 0; i < m; i++){\n    road[a[i]].push_back(MP(l[i], b[i]));\n    road[b[i]].push_back(MP(l[i], a[i]));\n  }\n\n  for(int i = 0; i < k; i++)\n    q.push(MP(0, s[i]));\n\n  while(!q.empty()){\n    PII now = q.top();\n    q.pop();\n\n    if(!checked[now.second]){\n      checked[now.second] = true;\n      dist[now.second] = now.first;\n      for(int i = 0; i < road[now.second].size(); i++){\n\tq.push(MP(now.first + road[now.second][i].first, road[now.second][i].second));\n      }\n    }\n  }\n  \n  return;\n}\n\nint main()\n{\n  cin >> n >> m >> k;\n  for(int i = 0; i < m; i++)\n    cin >> a[i] >> b[i] >> l[i];\n  for(int i = 0; i < k; i++)\n    cin >> s[i];\n\n  dijk();\n\n  for(int i = 1; i <= n; i++)\n    ans = max(ans, dist[i]);\n\n  for(int i = 0; i < m; i++){\n    int diff = abs(dist[a[i]] - dist[b[i]]);\n    if(diff < l[i]){\n      int x = (l[i] - diff) / 2 + max(dist[a[i]], dist[b[i]]);\n      if((l[i] - diff) % 2)\n\tans = max(ans, x + 1);\n      else\n\tans = max(ans, x);\n    }\n  }\n  \n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include \"ane.cpp\"\n\nconst int INF  = 1e9;\nconst long long INFLL = 1e18;\nconst int NMAX = 3005;\nconst int MMAX = 1e5 + 5;\nconst int KMAX = 3005;\nconst int MOD  = 1e9 + 7;\nusing namespace std;\n\n// comment to disable debug functions\n// #define DEBUG\n\n// frequently used macros\n\n#if __cplusplus >= 201103L\n#define ALL(v) begin(v),end(v)\n#define SORT(v) sort(begin(v), end(v))\n#define FIND(v,x) find(begin(v), end(v), (x))\n#else\n#define ALL(v) (v).begin(),(v).end()\n#define SORT(v) sort(v.begin(), v.end())\n#define FIND(v,x) find(v.begin(), v.end(), (x))\n#endif\n\n#define MEMNEXT(from, to) do{ memmove((to), (from), sizeof(from)); \\\nmemset((from), 0, sizeof(from)); } while(0)\n#ifdef DEBUG\n#define DUMP(x) do{ std::cerr << \"(DUMP) \" << (#x) << \": \" << x << std::endl; }while(0)\n#else\n#define DUMP(x) do{}while(0)\n#endif\n\n// frequent used aliases\ntypedef long long ll;\ntypedef pair<int, int> p;\ntypedef pair<ll, int> pl;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vec;\ntypedef vector<ll> vecll;\ntypedef vector<vec> mat;\ntypedef vector<vecll> matll;\n\n// frequently used constants\nstatic const int di[] = {-1, 0, 1, -1, 1, -1, 0, 1};\nstatic const int dj[] = {-1, -1, -1, 0, 0, 1, 1, 1};\n\n// frequently used structs\nstruct edge{\n  int to,cost;\n};\n\n// printf for debug\n#ifndef DEBUG\nvoid debug(const char* format, ...){}\n#else\nvoid debug(const char* format, ...){\n  va_list arg;\n  va_start(arg, format);\n  vprintf(format, arg);\n  va_end(arg);\n}\n#endif\n\n// std::fill of multi dimensions\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n  std::fill( (T*)array, (T*)(array+N), val );\n}\n\n// binary search\nll BSearch(ll _begin, ll _end, bool (*f)(int)){\n  ll mid;\n  while(_end - _begin > 1LL) {\n  mid = (_begin + _end) / 2LL;\n  if(f(mid)) {\n    debug(\"BSearch: f(%d) == true\\n\", mid);\n    _end = mid;\n  }\n  else\n  {\n    debug(\"BSearch: f(%d) == false\\n\", mid);\n    _begin = mid;\n  }\n  }\n  return _end;\n}\n\n\nll N,M,K,A,B,C,D;\nint d[NMAX], dfrom[NMAX] = {};\n\nstd::vector<edge> G[NMAX];\nint shop[KMAX] = {};\ntypedef pair<int, pair<int, int> > pp;\npriority_queue<pp, vector<pp>, greater<pp> > que;\n\nint ans = 0;\n\nvoid solve(){\n  // main algorithm\n  while(!que.empty()) {\n    int  dd = que.top().first;\n    int t = que.top().second.second, f = que.top().second.first;\n    que.pop();\n    if(d[t] <= dd) continue;\n    d[t] = dd;\n    dfrom[t] = f;\n    for(auto&& e : G[t]) {\n      if (d[e.to] > dd + e.cost)\n      {\n        que.push(pp{dd + e.cost, p(t, e.to)});\n      }\n    }\n  }\n  // calc max (including midpoint)\n  for (int i = 1; i <= N; ++i)\n  {\n    for (auto e: G[i])\n    {\n      ans = max(ans, max(d[i], d[e.to]));\n      if(dfrom[i] != e.to && dfrom[e.to] != i){\n        ans = max(ans, (d[i] + d[e.to] + e.cost + 1) / 2);\n        DUMP(ans);\n        DUMP(i);\n        DUMP(e.to);\n      }\n    }\n  }\n}\nvoid debug(){\n  // output debug information\n  cout << \"d:\\n\";\n  for (int i = 0; i < N; ++i)\n   {\n     cout << d[i+1] << \" \";\n   }\n  cout << endl;\n  cout << \"dfrom:\\n\";\n  for (int i = 0; i < N; ++i)\n   {\n     cout << dfrom[i+1] << \" \";\n   }\n  cout << endl;\n}\nvoid answer(){\n  // output answer\n  printf(\"%d\\n\", ans);\n}\nint main(int argc, char const *argv[])\n{\n  // operate inputs\n\n  Fill(d, INF);\n  scanf(\"%lld%lld%lld\", &N,&M, &K);\n  for (int i = 0; i < M; ++i)\n  {\n    int f,t,c;\n    scanf(\"%d%d%d\", &f, &t, &c);\n    G[f].push_back((edge){t, c});\n    G[t].push_back((edge){f, c});\n  }\n  for (int i = 0; i < K; ++i)\n  {\n    scanf(\"%d\", &shop[i]);\n    que.push(pp(0, p(0, shop[i])));\n  }\n  solve();\n  #ifdef DEBUG\n  debug();\n  #endif\n  answer();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nstruct edge { int to, cost; edge(int to, int cost) : to(to), cost(cost) {} };\ntypedef vector<edge> edges;\n\nedges G[3010];\nint d[100010];\n\nvoid dijkstra(int s)\n{\n    priority_queue<pii, vpii, greater<pii> > pq;\n    d[s] = 0;\n    pq.push(pii(0, s));\n    \n    while (pq.size()) {\n        pii p = pq.top(); pq.pop();\n\n        int v = p.scd;\n\n        if (d[v] < p.fst) continue;\n\n        rep(i, G[v].size()) {\n            edge &e = G[v][i];\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                pq.push(pii(d[e.to], e.to));\n            }\n        }\n    }\n}\n\nsigned main()\n{\n    omajinai;\n\n    int N, M, K; cin >> N >> M >> K;\n\n    fill_n(d, N + 1, inf);\n\n    rep(i, M) {\n        int a, b, l; cin >> a >> b >> l;\n        a--, b--;\n\n        G[a].PB(edge(b, l));\n        G[b].PB(edge(a, l));\n    }\n\n    rep(i, K) {\n        int s; cin >> s;\n        s--;\n        dijkstra(s);\n    }\n\n    double ma = -1.0;\n\n    rep(i, N) {\n        rep(j, G[i].size()) {\n            edge &e = G[i][j];\n            ma = max(ma, (d[i] + d[e.to] + e.cost) / 2.0);\n        }\n    }\n\n    cout << round(ma) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf=1<<30;\nstruct edge{\tint to,cost;\t};\nint main(){\n\tint n,m,k;\tcin>>n>>m>>k;\n\tvector<edge> e[n];\n\tvector<int> dist(n,inf);\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,l;\tcin>>a>>b>>l;\ta--;\tb--;\n\t\te[a].push_back((edge){b,l});\n\t\t\n\t\te[b].push_back((edge){a,l});\n\t}\n\tfor(int i=0;i<k;i++){\n\t\tint s;\tcin>>s;\ts--;\n\t\tdist[s]=0;\n\t\tqueue<int> q;\tq.push(s);\n\t\twhile(!q.empty()){\n\t\t\tint now=q.front();\tq.pop();\n\t\t\tfor(int i=0;i<(int)e[now].size();i++){\n\t\t\t\tif(dist[e[now][i].to]>dist[now]+e[now][i].cost){\n\t\t\t\t\tdist[e[now][i].to]=dist[now]+e[now][i].cost;\n\t\t\t\t\tq.push(e[now][i].to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans=0;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<(int)e[i].size();j++){\n\t\t\tans=max(ans,(dist[i]+dist[e[i][j].to]+e[i][j].cost+1)/2);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nint n, m, k;\nint INF = 10e8;\ntypedef pair<int, int> P;\nvector<P> g[3001];\nint d[3001];\nint ans;\n\nvoid dijkstra(){\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tfill(d, d+n+1, INF);\n\td[0] = 0;\n\tq.push(P(0, 0));\n\twhile(!q.empty()){\n\t\tP p = q.top(); q.pop();\n\t\tint t = p.second;\n\t\tfor(int i=0; i<g[t].size(); i++){\n\t\t\tif(d[g[t][i].second] > d[t] + g[t][i].first){\n\t\t\t\td[g[t][i].second] = d[t] + g[t][i].first;\n\t\t\t\tq.push(P(d[g[t][i].second], g[t][i].second));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tfor(int i=0; i<m; i++){\n\t\tint a, b, c;\n\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\t\tg[a].push_back(P(c, b));\n\t\tg[b].push_back(P(c, a));\n\t}\n\tfor(int i=0; i<k; i++){\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tg[t].push_back(P(0, 0));\n\t\tg[0].push_back(P(0, t));\n\t}\n/*\n\tfor(int i=0; i<n; i++){\n\t\tprintf(\"%d\\n\", i+1);\n\t\tfor(int j=0; j<g[i+1].size(); j++){\n\t\t\tprintf(\"%d %d\\n\", g[i+1][j].first, g[i+1][j].second);\n\t\t}\n\t}\n*/\n\tdijkstra();\n\n//\tfor(int i=0; i<n+1; i++) printf(\"%d %d\\n\", i, d[i]);\n\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<g[i+1].size(); j++){\n\t\t\tint a = min(d[i+1], d[g[i+1][j].second]);\n\t\t\tint b = max(d[i+1], d[g[i+1][j].second]);\n\t\t\tint c = g[i+1][j].first;\n\t\t\tans = max(ans, (int)((round(a + b + c) / 2) + 0.5));\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nstruct edge { int to, cost; edge(int to, int cost) : to(to), cost(cost) {} };\ntypedef vector<edge> edges;\n\nedges G[3010];\nint d[100010];\n\nvoid dijkstra(int s)\n{\n    priority_queue<pii, vpii, greater<pii> > pq;\n    d[s] = 0;\n    pq.push(pii(0, s));\n    \n    while (pq.size()) {\n        pii p = pq.top(); pq.pop();\n\n        int v = p.scd;\n\n        if (d[v] < p.fst) continue;\n\n        for (edge &e : G[v]) {\n            if (d[e.to] > d[v] + e.cost) {\n                d[e.to] = d[v] + e.cost;\n                pq.push(pii(d[e.to], e.to));\n            }\n        }\n    }\n}\n\nsigned main()\n{\n    int N, M, K; cin >> N >> M >> K;\n\n    fill_n(d, N + 1, inf);\n\n    rep(i, M) {\n        int a, b, l; cin >> a >> b >> l;\n        a--, b--;\n\n        G[a].PB(edge(b, l));\n        G[b].PB(edge(a, l));\n    }\n\n    rep(i, K) {\n        int s; cin >> s;\n        s--;\n        dijkstra(s);\n    }\n\n    int ma = -1;\n\n    rep(i, N) {\n        for (edge &e : G[i]) {\n            ma = max(ma, (int)(d[i] + round(1. * (d[e.to] - d[i] + e.cost) / 2)));\n        }\n    }\n\n    cout << ma << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\nconst int INF = 1e9;\n\nstruct Edge{\n  int to, cost;\n\n  Edge(int t, int c = 0): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n  bool operator<(const Edge& rhs) const{\n\treturn cost < rhs.cost;\n  }\n\n};\ntypedef vector< vector<Edge> > Graph;\n\n// テァツ?。テ・ツ青妥」ツつーテ」ツδゥテ」ツδ陛」ツ?ョテ」ツ?ィテ」ツ??\nvoid add_edge(Graph& graph, int u, int v, int cost){\n  graph[u].push_back(Edge(v,cost));\n  graph[v].push_back(Edge(u,cost));\n}\nvoid Dijkstra(const Graph& edges, vector<int>& d, int s){\n  using Type = PII;\n  priority_queue<Type, vector<Type>, greater<Type> > pq;\n  fill(d.begin(), d.end(), INF);\n  d[s] = 0;\n  pq.push(MP(0,s));\n\n  while(!pq.empty()){\n\tType pii = pq.top(); pq.pop();\n\tint v = pii.second;\n\tif(d[v] < pii.first) continue;\n\tfor(unsigned int i=0;i<edges[v].size();++i){\n\t  const Edge& e = edges[v][i];\n\t  if(d[e.to] > d[v] + e.cost){\n\t\td[e.to] = d[v] + e.cost;\n\t\tpq.push(MP(d[e.to], e.to));\n\t  }\n\t}\n  }\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M, K;\n  cin >> N >> M >> K;\n  Graph G(N);\n  REP(i,M){\n\tint u, v, l;\n\tcin >> u >> v >> l;\n\t--u;\n\t--v;\n\tadd_edge(G, u, v, l);\n  }\n\n  VI mn(N, INF);\n  REP(q,K){\n\tint s;\n\tcin >> s;\n\t--s;\n\tVI dis(N);\n\tDijkstra(G, dis, s);\n\tREP(i,N) mini(mn[i], dis[i]);\n  }\n\n  int ans = 0;\n  REP(i,N)\n\tfor(auto&& e: G[i]){\n\t  int j = e.to;\n\t  int a = min(mn[i], mn[j]);\n\t  int b = max(mn[i], mn[j]);\n\t  if(a+e.cost <= b)\n\t\tmaxi(ans, a+e.cost);\n\t  else{\n\t\tmaxi(ans, (a+b+e.cost)/2 + (a+b+e.cost)%2);\n\t  }\n\t}\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define LL long long\n\nstruct edge{\n    int to, cost;\n};\nstruct node{\n    int n, cost;\n    bool operator<(const node & n1) const {\n        return n1.cost < cost;\n    }\n};\nint N, M, K;\nint a[100010], b[100010], l[100010];\nvector<edge> G[3010];\nint main(){\n    cin >> N >> M >> K;\n    for(int i = 0; i < M; i++){\n        cin >> a[i] >> b[i] >> l[i];\n        G[a[i]].push_back(edge{b[i], l[i]});\n        G[b[i]].push_back(edge{a[i], l[i]});\n    }\n    int D[3010] = {};\n    fill(D, D + (N + 1), 1 << 30);\n    priority_queue<node> pq;\n    for(int i = 0; i < K; i++){\n        int c = 0;\n        cin >> c;\n        D[c] = 0;\n        pq.push(node{c, 0});\n    }\n    while(!pq.empty()){\n        node n = pq.top();\n        pq.pop();\n        if(D[n.n] < n.cost) continue;\n        for(auto u : G[n.n]){\n            int c = n.cost + u.cost;\n            if(c < D[u.to]){\n                D[u.to] = c;\n                pq.push(node{u.to, c});\n            }\n        }\n    }\n    int ans = 0;\n    for(int i = 1; i <= N; i++){\n        ans = max(ans, D[i]);\n    }\n    for(int i = 0; i < M; i++){\n        int cost = (D[a[i]] + D[b[i]] + l[i] + 1) / 2;\n        ans = max(cost, ans);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define INF (2 << 28)\n#define fr first\n#define sc second\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> iP;\n\nstruct edge{\n  int to, dis;\n  edge(int too, int cost){\n    dis = cost;\n    to = too;\n  }\n};\n\nint n, m, k, l[3333];\nint mindis[3333], costed[3333], shop[3333];\nvector<vector<edge> > graph(3333);\n\nvoid Dijkstra(){\n  \n  fill_n(costed, 3333, INF);\n  priority_queue<iP, vector<iP>, greater<iP> > que;\n  que.push(iP(0, 1)); costed[1] = 0;\n  while(!que.empty()){\n    iP p = que.top(); que.pop();\n    int now = p.sc, d = p.fr;\n    for(int i = 0; i < graph[now].size(); i++){\n      edge e = graph[now][i];\n      if(d + e.dis < costed[e.to]){\n        costed[e.to] = d + e.dis;\n        if(shop[e.to]) que.push(iP(0, e.to));\n        else que.push(iP(d + e.dis, e.to));\n      }\n    }\n  }\n}\n\n    \nint main(){\n  \n  cin >> n >> m >> k;\n  for(int i = 0; i < m; i++){\n    int a, b, c; cin >> a >> b >> c;\n    graph[a].push_back(edge(b, c));\n    graph[b].push_back(edge(a, c));\n  }\n  for(int i = 0; i < k; i++){\n    int a; cin >> a;\n    shop[a] = 1;\n  }\n  \n  Dijkstra();\n\n  double maxi = 0;\n  for(int i = 1; i <= n; i++){\n    for(int j = 0; j < graph[i].size(); j++){\n      int tar, subs, t = graph[i][j].to;\n      subs = costed[i] - costed[t];\n      if(subs < 0) tar = costed[t], subs = -subs;\n      else tar = costed[i];\n      maxi = max(maxi, tar + (double)(graph[i][j].dis - subs)/2);\n    }\n\n  }\n  cout << (int)(maxi + 0.5) << endl;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint main(void) {\n\tll n, m, k;\n\tcin>>n>>m>>k;\n\tvector<vector<P> > l(n);\n\tREP(i, m) {\n\t\tll a, b, c;\n\t\tcin>>a>>b>>c;\n\t\t--a;\n\t\t--b;\n\t\tl[a].pb(P(b, c));\n\t\tl[b].pb(P(a, c));\n\t}\n\tvector<ll> shop(k);\n\tREP(i, k) {\n\t\tll gomi;\n\t\tcin>>gomi;\n\t\t--gomi;\n\t\tshop[i] = gomi;\n\t}\n\tpriority_queue<P> que;\n\tvector<ll> dir(n, INF * INF);\n\tREP(i, k) {\n\t\tque.push(P(0, shop[i]));\n\t\tdir[shop[i]] = 0;\n\t}\n\twhile(!que.empty()) {\n\t\tP np = que.top();\n\t\tque.pop();\n\t\tif(dir[np.second] != np.first) continue;\n\t\tREP(i, l[np.second].size()) {\n\t\t\tif(dir[l[np.second][i].first] > dir[np.second] + l[np.second][i].second) {\n\t\t\t\tdir[l[np.second][i].first] = dir[np.second] + l[np.second][i].second;\n\t\t\t\tque.push(P(dir[l[np.second][i].first], l[np.second][i].first));\n\t\t\t}\n\t\t}\n\t}\n\tll res = 0;\n\tREP(i, n) {\n\t\tREP(j, l[i].size()) {\n\t\t\tres = max(max(res, dir[i] + (ll)((double)dir[l[i][j].first] / 2 + 0.5)), dir[l[i][j].first] + (ll)((double)dir[l[i][j].first] / 2 + 0.5));\n\t\t}\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<cstdio>\n#include<cmath>\n#define INF 500000000\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n,m,k;\nint l[100100],a[100100],b[100100];\nvector<P> g[5000];\nint d[5000],w[5000];\nint s[5000];\n\nint main(){\n  cin >> n >> m >> k;\n  for(int i=0;i<m;i++){\n    cin >> a[i] >> b[i] >> l[i];\n    a[i]--; b[i]--;\n    g[a[i]].push_back(P(l[i],b[i]));\n    g[b[i]].push_back(P(l[i],a[i]));\n  }\n \n  for(int i=0;i<k;i++){cin >> s[i]; s[i]--;}\n\n  for(int i=0;i<n;i++)d[i] = INF;\n  priority_queue<P,vector<P>,greater<P> > q;\n  for(int i=0;i<k;i++){\n    d[s[i]] = 0;\n    q.push(P(0,i));\n  }\n\n  while(q.size()){\n    P p = q.top(); q.pop();\n    int cost = p.first, pos = p.second;\n    \n    for(int i=0;i<(int)g[pos].size();i++){\n      int dis = cost + g[pos][i].first;\n      int next = g[pos][i].second;\n      \n      if(dis<d[next]){\n\td[next] = dis;\n\tq.push(P(dis,next));\n      }\n    }\n  }\n\n  double ans = 0.0;\n  for(int i=0;i<m;i++){\n    if(fabs(d[a[i]] - d[b[i]]) >= l[i]){\n      ans = max(ans,(double)max(d[a[i]],d[b[i]]));\n    }else{\n      ans = max(ans,(double)(l[i]+d[a[i]]+d[b[i]])/2);\n    }\n  }\n  cout << (int)(ans+1e-9+0.5) << endl;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3002\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<P> G[N];\nbool num[N];\nint n,m,K;\n\ndouble dijkstra(){\n  int D[N];\n  for(int i=0;i<N;i++) D[i] = 1e9;\n  \n  vector<int>pre[N];\n  priority_queue<PP,vector<PP>,greater<PP> >Q;\n  \n  for(int i=0;i<N;i++)\n    if(num[i]) {\n      Q.push(PP(0,P(i,i)));\n      D[i] = 0;\n    }\n\n  \n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first;\n    int pos = t.second.first;\n    int start = t.second.second;\n\n    \n    if(D[pos]<cost) continue;\n    pre[pos].push_back(start);\n    if(pre[pos].size()>=2) continue;\n    \n    \n    for(int i=0;i<G[pos].size();i++){\n      int npos = G[pos][i].first;\n      int ncost = cost+G[pos][i].second;\n      if(D[npos]<ncost) continue;\n      Q.push(PP(ncost,P(npos,start)));\n      D[npos] = ncost;\n    }\n  }\n\n  cout<<\"OK\"<<endl;\n  double res = 0;\n  for(int i=0;i<n;i++){\n    if(pre[i].size()>=2)res = max(res,(double)D[i]);\n    res = max(res,D[i]/2.0);\n    \n    for(int j=0;j<G[i].size();j++){\n      int npos = G[i][j].first;\n      int ncost = G[i][j].second;\n      if(pre[npos][0] == pre[i][0] && abs(D[i]-D[npos])==ncost)continue;\n\n      res = max(res,(D[i]+D[npos]+ncost)/2.0);\n    }\n  }\n  return res;\n  \n}\n\nint main(){\n  \n  cin>>n>>m>>K;\n  for(int i=0,a,b,c;i<m;i++){\n    cin>>a>>b>>c;\n    G[a-1].push_back(P(b-1,c));\n    G[b-1].push_back(P(a-1,c));\n  }\n\n  for(int i=0,a;i<K;i++)cin>>a,num[a-1]=1;\n  printf(\"%d\\n\",(int)(dijkstra()+0.5));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <utility>\nusing namespace std;\nstruct road{\n\tint a,b,l;\n\troad(int a_,int b_,int l_):a(a_),b(b_),l(l_){}\n};\ntypedef pair<int,int> pii;\nint main(){\n\tint n,m,k,a,b,l,s;\n\tvector<road> rd;\n\tvector<pii> town[3001];\n\tint len[3001];\n\tpriority_queue<pii,vector<pii>,greater<pii> > qu;\n\tint inf = 1e9;\n\n\tfor(cin>>n>>m>>k;m--;rd.push_back(road(a,b,l))){\n\t\tcin>>a>>b>>l;\n\t\ttown[a].push_back(make_pair(b,l));\n\t\ttown[b].push_back(make_pair(a,l));\n\t}\n\tfor(;k--;qu.push(make_pair(0,s)))\n\t\tcin>>s;\n\n\tfor(fill(len,len+3000,inf);!qu.empty();){\n\t\tpii pi = qu.top();\n\t\tqu.pop();\n\t\tif( len[pi.second] == inf ){\n\t\t\tlen[pi.second] = pi.first;\n\t\t\tfor(\n\t\t\t\tvector<pii>::iterator it=town[pi.second].begin();\n\t\t\t\tit != town[pi.second].end();\n\t\t\t\t++it\n\t\t\t){\n\t\t\t\tqu.push(make_pair(pi.first+it->second,it->first));\n\t\t\t}\n\t\t}\n\t}\n\t\n\ts=0;\n\tfor(vector<road>::iterator it = rd.begin(); it != rd.end();\t++it ){\n\t\ts = max( max( s, len[a] ),\n\t\t\tmax( len[b], (len[it->b] + it->l - len[it->a] + 1)/2 + len[it->a] )\n\t\t);\n\t}\n\tcout << s << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3002\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<P> G[N];\nbool num[N];\nint n,m,K;\n\ndouble dijkstra(){\n  int D[N];\n  for(int i=0;i<N;i++) D[i] = 1e9;\n  \n  vector<int>pre[N];\n  priority_queue<PP,vector<PP>,greater<PP> >Q;\n  for(int i=0;i<n;i++)if(num[i]) Q.push(PP(0,P(i,-1))),D[i] = 0;\n  \n  \n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first;\n    int pos = t.second.first;\n    int ppos = t.second.second;\n    \n    if(D[pos]<cost) continue;\n    if(ppos>=0)pre[pos].push_back(ppos);\n    \n    for(int i=0;i<G[pos].size();i++){\n      int npos = G[pos][i].first;\n      int ncost = cost+G[pos][i].second;\n      if(D[npos]<ncost) continue;\n      Q.push(PP(ncost,P(npos,pos)));\n      D[npos] = ncost;\n    }\n  }\n\n\n  double res = 0;\n  for(int i=0;i<n;i++){\n    res = max(res,D[i]/2.0);\n    if(pre[i].size()>=2) res = max(res,(double)D[i]);\n\n    for(int j=0;j<(int)G[i].size();j++){\n      int npos = G[i][j].first;\n      int ncost = G[i][j].second;\n      res = max(res,(D[i]+D[npos]+ncost)/2.0);\n    }\n  }\n  return res;\n   \n}\n \nint main(){\n  cin>>n>>m>>K;\n  for(int i=0,a,b,c;i<m;i++){\n    cin>>a>>b>>c;\n    G[a-1].push_back(P(b-1,c));\n    G[b-1].push_back(P(a-1,c));\n  }\n \n  for(int i=0,a;i<K;i++)cin>>a,num[a-1]=1;\n  printf(\"%d\\n\",(int)(dijkstra()+0.5));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF (1<<29)\n\ntypedef pair<int, int> pii;\n\nint d[3000][3000]; // ???i, j????????¢\nint minCost[3000]; // ???i????????§???????????°??¢???????????§??????????????¢\nint shop[3000];\nvector<pii> g[3000]; // to, cost\nint n, m, k;\n\nint main() {\n\tcin >> n >> m >> k;\n\t\n\tfill(d[0], d[n], INF);\n\tfill(minCost, minCost + n, INF);\n\t\n\tREP(i, m) {\n\t\tint a, b, l;\n\t\tscanf(\"%d %d %d\", &a, &b, &l);\n\t\ta--; b--;\n\t\tg[a].push_back(pii(b, l));\n\t\tg[b].push_back(pii(a, l));\n\t}\n\t\n\tREP(i, k) {\n\t\tint pos;\n\t\tscanf(\"%d\", &pos);\n\t\tpos--;\n\t\tshop[i] = pos;\n\t}\n\t\n\t// i, j?????????????????¢???dijkstra??§?±???????\n\tREP(i, n) {\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > pq; // cost, pos\n\t\tpq.push(pii(0, i));\n\t\t\n\t\twhile (!pq.empty()) {\n\t\t\tpii now = pq.top(); pq.pop();\n\t\t\t\n\t\t\tint ncost = now.first;\n\t\t\tint npos = now.second;\n\t\t\t\n\t\t\tif (d[i][npos] <= ncost) continue;\n\t\t\td[i][npos] = ncost;\n\t\t\t\n\t\t\tREP(j, g[npos].size()) pq.push(pii(ncost + g[npos][j].second, g[npos][j].first)); \n\t\t}\n\t}\n\t\n\t// minCost????±???????\n\tREP(i, n) {\n\t\tint cost = INF;\n\t\tREP(j, k) cost = min(cost, d[i][shop[j]]);\n\t\tminCost[i] = cost;\n\t}\n\t\n\tint ans = 0;\n\tREP(i, n) REP(j, g[i].size()) {\n\t\tint to = g[i][j].first;\n\t\tans = max(ans, (minCost[i] + minCost[to] + d[i][to] + 1) / 2);\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\ntypedef pair<int,int> P; //point cost\nstruct Edge {\n\tint to,cost;\n\tEdge(int _to,int _cost){to=_to,cost=_cost;}\n};\nint dist[3000];\nvector<Edge> edges[3000];\nvoid dijkstra(int s) {\n\tpriority_queue<P,vector<P>,greater<P> > Q;\n\tdist[s]=0;\n\tQ.push(P(s,0));\n\twhile(!Q.empty()) {\n\t\tP p=Q.top();Q.pop();\n\t\tif(dist[p.first]<p.second) continue;\n\t\tfor(int i=0;i<edges[p.first].size();i++) {\n\t\t\tif(dist[edges[p.first][i].to]>(p.second+edges[p.first][i].cost)) {\n\t\t\t\tdist[edges[p.first][i].to]=(p.second+edges[p.first][i].cost);\n\t\t\t\tQ.push(P(edges[p.first][i].to,dist[edges[p.first][i].to]));\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint N,M,K;\n\tscanf(\"%d %d %d\",&N,&M,&K);\n\tfor(int i=0;i<M;i++) {\n\t\tint a,b,l;\n\t\tscanf(\"%d %d %d\",&a,&b,&l);\n\t\tedges[a-1].push_back(Edge(b-1,l));\n\t\tedges[b-1].push_back(Edge(a-1,l));\n\t}\n\tfill(dist,dist+3000,1<<27);\n\tfor(int i=0;i<K;i++) {\n\t\tint s;\n\t\tscanf(\"%d\",&s);\n\t\tdijkstra(s-1);\n\t}\n\tint ans=0;\n\tfor(int i=0;i<N;i++) {\n\t\tfor(int j=0;j<edges[i].size();j++) {\n\t\t\tint A=dist[i],B=dist[edges[i][j].to],C=abs(A-B);\n\t\t\tif(A<B)ans=max(ans,A+C+(edges[i][j].cost-C+1)/2);\n\t\t\telse ans=max(ans,B+C+(edges[i][j].cost-C+1)/2);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nstruct edge{\n\tint to;\n\tint cost;\n};\n\nconst int MAX_N = 3002;\n\nint n,m,K,d[MAX_N];\nvector<int> S;\nvector<edge> G[MAX_N];\n\nvoid dijkstra()\n{\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\trep(i,S.size()){\n\t\td[S[i]] = 0;\n\t\tque.push(P(0,S[i]));\n\t}\n\twhile(!que.empty()){\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\tvector<edge>::iterator it = G[v].begin();\n\t\twhile(it != G[v].end()){\n\t\t\tif(d[it->to] > d[v] + it->cost){\n\t\t\t\td[it->to] = d[v] + it->cost;\n\t\t\t\tque.push(P(d[it->to],it->to));\n\t\t\t}\n\t\t\tit++;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&K);\n\trep(i,m){\n\t\tint x,y,z;\n\t\tedge e1,e2;\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\te1.to = y-1,e1.cost = z;\n\t\tG[x-1].push_back(e1);\n\t\te2.to = x-1,e2.cost = z;\n\t\tG[y-1].push_back(e2);\n\t}\n\trep(i,K){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\tS.push_back(x-1);\n\t}\n\tfill(d,d+n,INF);\n\tdijkstra();\n\tint ans=0;\n\trep(i,n){\n\t\trep(j,G[i].size()){\n\t\t\tif(d[i]>=d[G[i][j].to]){\n\t\t\t\tif(d[i]>=d[G[i][j].to]+G[i][j].cost){\n\t\t\t\t\tans = max(ans,d[i]);\n\t\t\t\t}else{\n\t\t\t\t\tans = max(ans,(d[i]+d[G[i][j].to]+G[i][j].cost+1)/2);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(d[G[i][j].to]>=d[i]+G[i][j].cost){\n\t\t\t\t\tans = max(ans,d[G[i][j].to]);\n\t\t\t\t}else{\n\t\t\t\t\tans = max(ans,(d[i]+d[G[i][j].to]+G[i][j].cost+1)/2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nint n, m, k;\nint amat[5000][5000];\nint vtx[5000];\nvector< vector<int> > adj(5000);\nvector<int> mal;\n\nint solve(){\n\t\n\tfor(int i=0; i<n; ++i){\n\t\tvtx[i] = INT_MAX;\n\t}\n\t\n\t//dijkstra\n\tfor(int s=0; s<k; ++s){\n\t\t\n\t\tint vtx_tmp[5000];\n\t\t\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tvtx_tmp[i] = INT_MAX;\n\t\t}\n\t\t\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tqu.push(make_pair(0, mal[s]));\n\t\tvtx_tmp[mal[s]]=0;\n\t\t\n\t\twhile(!qu.empty()){\n\n\t\t\tint now = qu.top().second, nxt;\n\t\t\tqu.pop();\n\n\t\t\tfor(int i=0; i<adj[now].size(); ++i){\n\t\t\t\t\n\t\t\t\tnxt = adj[now][i];\n\t\t\t\t\t\n\t\t\t\tif( vtx_tmp[nxt] > vtx_tmp[now] + amat[now][nxt]){\n\t\t\t\t\n\t\t\t\t\tvtx_tmp[nxt] = vtx_tmp[now] + amat[now][nxt];\n\t\t\t\t\tqu.push( make_pair(vtx_tmp[nxt], nxt) );\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tvtx[i] = min(vtx[i], vtx_tmp[i]);\n\t\t}\n\t}\n\n\tint ma = -1;\n\n\tfor(int p=0; p<n; ++p){\n\t\tfor(int i=0; i<adj[p].size(); ++i){\n\t\t\t\n\t\t\tint q = adj[p][i];\n\t\t\tint gap = ( amat[p][q] + abs(vtx[p]-vtx[q]) +1 )/2;\n\t\t\t// +1 in the denominator is for rounding off to the nearest whole number\n\t\t\t\n\t\t\tma = max(ma, min(vtx[p], vtx[q]) + gap);\n\t\t}\n\t}\n\n\treturn ma;\n}\n\nint main(){\n\n\tcin >> n >> m >> k;\n\n\tfor(int i=0; i<m; ++i){\n\t\t\n\t\tint a, b, l;\n\t\tcin >> a >> b >> l;\n\t\ta--; b--;\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t\tamat[a][b] = amat[b][a] = l;\n\t}\n\n\tfor(int i=0; i<k; ++i){\n\t\tint s;\n\t\tcin>>s;\n\t\tmal.push_back(--s);\n\t}\n\n\tcout << solve() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <deque>\n#include <vector>\nusing namespace std;\n\nint main() {\n\tint N,M,K;\n\tvector<pair<int,int> >nGo[3001];\n\tdeque<int> dis;\n\tint dist[3001];\n\tint road[10001][3];\n\tfor(int i=1;i<=3000;i++)\n\t\tdist[i]=(1 << 30 );\n\tcin >> N >> M >> K;\n\tint a,b,c;\n\tfor(int i=0;i<M;i++){\n\t\tcin >> a >> b >> c;\n\t\tnGo[a].push_back(pair<int,int>(b,c));\n\t\tnGo[b].push_back(pair<int,int>(a,c));\n\t\troad[i][0]=a;\n\t\troad[i][1]=b;\n\t\troad[i][2]=c;\n\t}\n\tfor(int i=0;i<K;i++){\n\t\tcin >> a;\n\t//\tdis.insert(multimap<int,int>::value_type(0,a));\n\t\tdis.push_back(a);\n\t\tdist[a]=0;\n\t}\n\twhile(!dis.empty()){\n\t\tsort(dis.begin(),dis.end());\n\t\tint now=dis[0];\n\t\tfor(int i=0;i<nGo[now].size();i++){\n\t\t\tif(dist[nGo[now][i].first]>dist[now]+nGo[now][i].second){\n\t\t\t\tdis.push_back(nGo[now][i].first);\n\t\t\t\tdist[nGo[now][i].first]=dist[now]+nGo[now][i].second;\n\t\t\t}\n\t\t}\n\t\twhile(now==dis[0])\n\t\tdis.pop_front();\n\t}\n\tint maxer=0;\n\tfor(int i=0;i<M;i++)\n\tmaxer=max(maxer,(dist[road[i][0]]+dist[road[i][1]]+road[i][2]+1)/2);\n\tfor(int i=1;i<=N;i++)\n\tmaxer=max(maxer,dist[i]);\n\tcout << maxer <<  endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define LL long long\n\nstruct edge{\n    int to, cost;\n};\nstruct node{\n    int n, cost;\n    bool operator<(const node & n1) const {\n        return n1.cost < cost;\n    }\n};\nint N, M, K;\nint a[100010], b[100010], l[100010];\nvector<edge> G[3010];\nint main(){\n    cin >> N >> M >> K;\n    for(int i = 0; i < M; i++){\n        cin >> a[i] >> b[i] >> l[i];\n        G[a[i]].push_back(edge{b[i], l[i]});\n        G[b[i]].push_back(edge{a[i], l[i]});\n    }\n    int D[3010] = {};\n    fill(D, D + (N + 1), 1 << 30);\n    priority_queue<node> pq;\n    for(int i = 0; i < K; i++){\n        int c = 0;\n        cin >> c;\n        D[c] = 0;\n        pq.push(node{c, 0});\n    }\n    while(!pq.empty()){\n        node n = pq.top();\n        pq.pop();\n        if(D[n.n] < n.cost) continue;\n        for(auto u : G[n.n]){\n            int c = n.cost + u.cost;\n            if(c < D[u.to]){\n                D[u.to] = c;\n                pq.push(node{u.to, c});\n            }\n        }\n    }\n    int ans = 0;\n    for(int i = 0; i < M; i++){\n        int cost = (D[a[i]] + D[b[i]] + l[i] + 1) / 2;\n        ans = max(cost, ans);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <bitset>\n#include <string>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <list>\n#include <deque>\nusing namespace std;\n#define INF 10000000\n#define LLINF 100000000000000\ntypedef pair<int, int> P;\ntypedef long long ll;\n#define pb push_back\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define all(x) (x).begin(),(x).end()\n#define VSORT(v) sort(v.begin(), v.end());\n#define fi first\n#define se second\n#define out(x) cout << x << endl;\nint dx[] = { 1, 0, -1, 0 }, dy[] = { 0,1,0,-1 };\nll MOD = 1000000007;\nstruct edge {\n\tll from, to, cost;\n};\nint v, e, k;\nvector<P> es[100005];\nint d[3005] = { 0 };\n\n\n\nint main() {\n\tcin >> v >> e >> k;\n\trep(i, v) d[i] = INF;\n\tint res = 0;\n\trep(i, e) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tes[a].push_back(P(b, c));\n\t\tes[b].push_back(P(a, c));\n\t}\n\tpriority_queue<P, vector<P>, greater<P>>que;\n\trep(i, k) {\n\t\tint s;\n\t\tcin >> s;\n\t\ts--;\n\t\tque.push(P(0, s));\n\t\td[s] = 0;\n\t}\n\twhile (!que.empty()) {\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint V = p.second;\n\t\tif (d[V] < p.first) continue;\n\t\tfor (int u = 0; u < es[V].size(); u++) {\n\t\t\tint to = es[V][u].first;\n\t\t\tint cost = es[V][u].second;\n\t\t\tif (d[to] > d[V] + cost) {\n\t\t\t\td[to] = d[V] + cost;\n\t\t\t\tque.push(P(d[to], to));\n\t\t\t}\n\t\t}\n\t}\n\trep(i, v) {\n\t\tfor (int u = 0; u < es[i].size(); u++) {\n\t\t\tint to = es[i][u].first;\n\t\t\tint cost = es[i][u].second;\n\t\t\tint tmp = (d[to] + cost + d[i] + 1) / 2;\n\t\t\tres = max(res, tmp);\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<utility>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n#define INF 1<<20\ntypedef pair<int,int>p;\nint N,M,K,a,b,l,d[3005],rd[3005];\nvector<p>G[3005];//to,cost\n\nvoid dij(int s)\n{\n\tpriority_queue<p,vector<p>,greater<p> >Q;\n\tfill(d,d+N,INF);\n\td[s]=0;Q.push(p(0,s));\n\tfor(;!Q.empty();)\n\t{\n\t\tp tmp=Q.top();Q.pop();\n\t\tint v=tmp.second;\n\t\tif(d[v]<tmp.first)continue;\n\t\tfor(int i=0;i<G[v].size();i++)\n\t\t{\n\t\t\tp e=G[v][i];\n\t\t\tif(d[e.first]>d[v]+e.second)\n\t\t\t{\n\t\t\t\td[e.first]=d[v]+e.second;\n\t\t\t\tQ.push(p(d[e.first],e.first));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d%d\",&N,&M,&K);\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&a,&b,&l);\n\t\ta--;b--;\n\t\tG[a].push_back(p(b,l));\n\t\tG[b].push_back(p(a,l));\n\t}\n\tfill(rd,rd+N,INF);\n\tfor(int i=0;i<K;i++)\n\t{\n\t\tscanf(\"%d\",&a);\n\t\ta--;\n\t\tdij(a);\n\t\tfor(int j=0;j<N;j++)rd[j]=min(rd[j],d[j]);\n\t}\n\tint res=0;\n\tfor(int i=0;i<N;i++)\n\t\tfor(int j=0;j<G[i].size();j++)\n\t\t{\n\t\t\tint tmp=(double)(abs(rd[i]-rd[G[i][j].first])+G[i][j].second)/2+0.5;\n\t\t\tint tmp1=rd[G[i][j].first];\n\t\t\tint tmp2=G[i][j].second-tmp;\n\t\t\tres=max(res,rd[i]+(rd[i]<=tmp1?max(tmp,tmp2):min(tmp,tmp2)));\n\t\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdint>\n\nusing namespace std;\n\n#define MAX_N 3000\n#define MAX_M 100000\n#define UNDEF UINT16_MAX\n\nuint16_t N,M,K,I[MAX_M*2][3],D[MAX_N],LS[MAX_N],RC[MAX_M];\nbool S[MAX_N];\nuint16_t dist[MAX_N];\nbool decided[MAX_N],updated;\n\nuint16_t min(uint16_t a,uint16_t b)\n{\n\tif(a < b)\n\t\treturn a;\n\telse\n\t\treturn b;\n}\n\nuint16_t max(uint16_t a,uint16_t b)\n{\n\tif(a > b)\n\t\treturn a;\n\telse\n\t\treturn b;\n}\n\nint main(void)\n{\n\tfor(int i = 0;i < MAX_N;i++)\n\t{\n\t\tD[i] = UNDEF;\n\t\tS[i] = false;\n\t\tLS[i] = UNDEF;\n\t\tI[i*2][0] = UNDEF;\n\t\tI[i*2][1] = UNDEF;\n\t\tI[i*2][2] = UNDEF;\n\t\tI[(i*2)+1][0] = UNDEF;\n\t\tI[(i*2)+1][1] = UNDEF;\n\t\tI[(i*2)+1][2] = UNDEF;\n\t}\n\tcin >> N >> M >> K;\n\tint a,b,n;\n\tfor(int i = 0;i < MAX_M;i++)\n\t\tRC[i] = UNDEF;\n\tfor(int i = 0;i < M;i++)\n\t{\n\t\tcin >> a >> b >> n;\n\t\ta--;\n\t\tb--;\n\t\tI[(i*2)][0] = a;\n\t\tI[(i*2)][1] = b;\n\t\tI[(i*2)][2] = n;\n\t\tI[(i*2)+1][0] = b;\n\t\tI[(i*2)+1][1] = a;\n\t\tI[(i*2)+1][2] = n;\n\t}\n\tfor(int i = 0;i < K;i++)\n\t{\n\t\tcin >> n;\n\t\tn--;\n\t\tS[n] = true;\n\t\tLS[i] = n;\n\t}\n\tfor(int e = 0;e < K;e++)\n\t{\n\t\tfor(int ii = 0;ii < MAX_N;ii++)\n\t\t{\n\t\t\tdist[ii] = UNDEF;\n\t\t\tdecided[ii] = false;\n\t\t}\n\t\tdist[LS[e]] = 0;\n\t\tbool loop = true;\n\t\twhile(loop)\n\t\t{\n\t\t\tupdated = false;\n\t\t\tint minn = UNDEF;\n\t\t\tint mini = -1;\n\t\t\tfor(int ii = 0;ii < N;ii++)\n\t\t\t{\n\t\t\t\tif(minn >= dist[ii] && !decided[ii])\n\t\t\t\t{\n\t\t\t\t\tmini = ii;\n\t\t\t\t\tminn = dist[ii];\n\t\t\t\t\tupdated = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdecided[mini] = true;\n\t\t\tif(updated)\n\t\t\t{\n\t\t\t\tfor(int ii = 0;ii < M*2;ii++)\n\t\t\t\t{\n\t\t\t\t\tif(I[ii][0] == mini && I[ii][2] + dist[I[ii][0]] < dist[I[ii][1]])\n\t\t\t\t\t{\n\t\t\t\t\t\tdist[I[ii][1]] = I[ii][2] + dist[I[ii][0]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tloop = false;\n\t\t\t}\n\t\t}\n\t\tfor(int ii = 0;ii < N;ii++)\n\t\t{\n\t\t\tif(dist[ii] == UNDEF)\n\t\t\t{\n\t\t\t\texit(-1);\n\t\t\t}\n\t\t\tD[ii] = min(D[ii],dist[ii]);\n\t\t}\n\t}\n\tfor(int i = 0;i < M;i++)\n\t{\n\t\tn = (D[I[i*2][0]] + D[I[i*2][1]] + I[i*2][2]);\n\t\tif(n % 2 == 0)\n\t\t\tn = n / 2;\n\t\telse\n\t\t\tn = (n + 1) / 2;\n\t\tRC[i] = n;\n\t}\n\tuint16_t result = 0;\n\tfor(int i = 0;i < N;i++)\n\t\tresult = max(D[i],result);\n\tfor(int i = 0;i < M;i++)\n\t\tresult = max(RC[i],result);\n\tcout << result << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <tuple>\nusing namespace std;\n\nint main(){\n  int N, M, K;\n  cin >> N >> M >> K;\n  vector<vector<pair<int,int>>> G(N);\n  for(int i = 0; i < M; ++i){\n    int u, v, l;\n    cin >> u >> v >> l;\n    --u,--v;\n    G[u].emplace_back(l,v);\n    G[v].emplace_back(l,u);\n  }\n  const long long INF = 1e18;\n  vector<long long> D(N,INF);\n  priority_queue<pair<long long,int>> Q;\n  for(int i = 0; i < K; ++i){\n    int s;\n    cin >> s;\n    --s;\n    D[s] = 0;\n    Q.emplace(0,s);\n  }\n  while(Q.size()){\n    int v;\n    long long d;\n    tie(d,v) = Q.top();\n    d *= -1;\n    Q.pop();\n    if(D[v] < d) continue;\n    for(auto e : G[v]){\n      long long d_ = d+e.first;\n      if(D[e.second] > d_){\n        D[e.second] = d_;\n        Q.emplace(-d_,e.second);\n      }\n    }\n  }\n  long long ans = 0;\n  for(int i = 0; i < N; ++i){\n    ans = max<double>(ans,D[i]);\n    for(auto e : G[i]){\n      int v = e.second;\n      long long l = e.first;\n      if(min(D[i],D[v])+l == max(D[i],D[v])) continue;\n      long long t = D[i]+(D[v]-D[i]+l+1)/2;\n      // cerr << i << \" \" << v << \" -> \" << t << endl;\n      ans = max(ans,t);\n    }\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\nstruct edge{\n    int len;\n    int to;\n    edge(){}\n    edge(int len,int to):len(len),to(to){}\n};\n\nint main() {\n    using graph = vector<vector<edge>>;\n\n    int n,m,k;\n    cin>>n>>m>>k;\n\n    graph G(n);\n    for(int i = 0;i < m;++i) {\n        int a,b,l;\n        cin>>a>>b>>l;\n        --a;--b;\n        G[a].emplace_back(l,b);\n        G[b].emplace_back(l,a);\n    }\n\n    priority_queue<pair<int,int>> pq;\n    vector<int> mdist(n,300000000);\n\n    for(int i = 0;i < k;++i) {\n        int a;\n        cin>>a;\n        --a;\n        pq.emplace(0,a);\n        mdist[a]=0;\n    }\n\n\n    while(!pq.empty()) {\n        auto t=pq.top();\n        pq.pop();\n        int tl=-t.first;\n        int tv=t.second;\n\n        for(auto px:G[tv]) {\n            int ndist=tl+px.len;\n            if(mdist[px.to]<ndist)continue;\n            mdist[px.to]=ndist;\n            pq.emplace(-ndist,px.to);\n        }\n    }\n\n    int ld=0;\n    for(int i = 0;i < n;++i) {\n//cerr<<mdist[i]<<endl;\n        ld=max(ld,mdist[i]);\n    }\n\n    for(int i = 0;i < n;++i) {\n        for(auto e:G[i]) {\n            //if(abs(mdist[i]-mdist[e.to])==e.len)continue;\n\n            int a=mdist[i];\n            int b=mdist[e.to];\n            int l=e.len;\n\n            if(a<b)swap(a,b);\n            int td=b+l-a;\n            td=(td+1)/2;\n            ld=max(ld,td+a);\n        }\n    }\n    cout<<ld<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\nusing namespace std;\n#define INF (1<<24)\n#define MAX_N 3000\nstruct edge{\n  int from,to,cost;\n};\nstruct state{\n  int pos,cost;\n  bool operator < (const state &p)const{\n    return cost > p.cost;\n  }\n};\n\nvector<int> v;\nvector<edge> G[MAX_N],g;\nint N,M,K,d[MAX_N];\n\nvoid dijkstra(){\n  priority_queue< state > Q;\n  for(int i=0;i<MAX_N;i++)d[i]=INF;\n  for(int i=0;i<K;i++){\n    int w=v[i];\n    d[w]=0;\n    Q.push( (state){w,0} );\n  }\n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    if(s.cost>d[s.pos])continue;\n    for(int i=0;i<(int)G[s.pos].size();i++){\n      edge e=G[s.pos][i];\n      if(s.cost+e.cost>=d[e.to])continue;\n      d[e.to]=s.cost+e.cost;\n      Q.push( (state){e.to,d[e.to]} );\n    }\n  }\n}\n\nvoid solve(){\n  dijkstra();\n  double ans=0;\n  for(int i=0;i<(int)g.size();i++){\n    edge e=g[i];\n    double a=d[e.from],b=d[e.to],c=e.cost;\n    // a+x==b+c-x>>2x==b+c-a\n    double x=(b+c-a)*0.5;\n    ans=max(ans,a+x);\n  }\n  int z=ans+0.5;\n  cout<<z<<endl;\n}\n\nint main(){\n  cin>>N>>M>>K;\n  for(int i=0;i<M;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    a--,b--;\n    g.push_back((edge){a,b,c});\n    G[a].push_back((edge){a,b,c});\n    G[b].push_back((edge){b,a,c});\n  }\n  for(int i=0;i<K;i++){\n    int a;\n    cin>>a;\n    a--;\n    v.push_back(a);\n  }\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> P;\nstruct edge{int to,cost;};\n\nconst int INF = 1000000000;\n\nint main(){\n  int n,m,k;\n  scanf(\"%d%d%d\",&n,&m,&k);\n  vector<P> E;\n  vector<edge> G[3000];\n  for(int i=0;i<m;i++){\n    int a,b,l;\n    scanf(\"%d%d%d\",&a,&b,&l);\n    E.push_back(P(pii(a-1,b-1),l));\n    edge e; e.cost = l;\n    e.to = a-1; G[b-1].push_back(e);\n    e.to = b-1; G[a-1].push_back(e);\n  }\n  int D[n];\n  fill(D,D+n,INF);\n  for(int i=0;i<k;i++){\n    int x;\n    scanf(\"%d\",&x);\n    int d[n];\n    priority_queue<pii,vector<pii>,greater<pii> > q;\n    fill(d,d+n,INF);\n    d[--x] = 0;\n    D[x] = 0;\n    q.push(pii(0,x));\n    while(!q.empty()){\n      pii p = q.top();\n      int v = p.second; q.pop();\n      if(d[v]<p.first) continue;\n      for(int j=0;j<G[v].size();j++){\n        int nv = G[v][j].to;\n        if(d[nv]>d[v]+G[v][j].cost){\n          d[nv] = d[v] + G[v][j].cost;\n          D[nv] = min(D[nv],d[nv]);\n          q.push(pii(d[nv],nv));\n        }\n      }\n    }\n  }\n  int ans = 0;\n  for(int i=0;i<E.size();i++){\n    ans = max((double)ans,max((double)max(D[E[i].first.first],D[E[i].first.second]),(double)(D[E[i].first.first]+D[E[i].first.second]+E[i].second)/2.0+0.5));\n  }\n  printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> P;\nconst int inf = 1e9 + 9;\n\nint cost[3000][3000];\n//bool used[3000];\n\nstruct edge\n{\n  edge() {}\n  edge (int t, int c) { to = t; cost = c; }\n  int to, cost;\n};\n\nvector<edge> G[3000];\nint d[3000];\nbool f[3000][3000];\nvector<int> pre[3000];\n\nint n, m, k;\n\nvoid dijkstra(int s)\n{\n  priority_queue<P, vector<P>, greater<P>> q;\n  d[s] = 0;\n  q.push(P(0, s));\n\n  while (!q.empty()){\n    P p = q.top(); q.pop();\n    int v = p.second;\n\n    if (d[v] < p.first) continue;\n    for (int i = 0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if (d[e.to] == d[v] + e.cost){\n        pre[e.to].push_back(v);\n      }\n      if (d[e.to] > d[v] + e.cost){\n        d[e.to] = d[v] + e.cost;\n        q.push(P(d[e.to], e.to));\n        pre[e.to].clear();\n        pre[e.to].push_back(v);\n      }\n    }\n  }\n}\n\n/*\nvoid dijkstra(int s)\n{\n  memset(used, false, sizeof(used));\n  d[s] = 0;\n\n  while (true){\n    int v = -1;\n\n    for (int u = 0; u < n; u++)\n      if (!used[u] && (v == -1 || d[u] < d[v])) v = u;\n    \n    if (v == -1) break;\n    used[v] = true;\n\n    for (int u = 0; u < n; u++){\n      if (d[u] == d[v] + cost[v][u]){\n        pre[u].push_back(v);\n      }\n      if (d[u] > d[v] + cost[v][u]){\n        d[u] = d[v] + cost[v][u];\n        pre[u].clear();\n        pre[u].push_back(v);\n      }\n    }\n  }\n}\n*/\n\nvoid dfs(int v)\n{\n  for (int i = 0; i < pre[v].size(); i++){\n    int u = pre[v][i];\n    if (!f[u][v]) continue;\n    f[v][u] = f[u][v] = false;\n    dfs(u);\n  }\n}\n\nint main()\n{\n  for (int i = 0; i < 3000; i++)\n    for (int j = 0; j < 3000; j++)\n      cost[i][j] = inf;\n\n  cin >> n >> m >> k;\n  for (int i = 0; i < m; i++){\n    int a, b, l;\n    cin >> a >> b >> l;\n    a--; b--;\n    cost[a][b] = cost[b][a] = l;\n    G[a].push_back(edge(b, l));\n    G[b].push_back(edge(a, l));\n    f[a][b] = f[b][a] = true;\n  }\n\n  fill(d, d + n, inf);\n  for (int i = 0; i < k; i++){\n    int s;\n    cin >> s;\n    dijkstra(s - 1);\n  }\n\n  for (int i = 0; i < n; i++){\n    dfs(i);\n  }\n\n  /*\n  for (int i = 0; i < n; i++){\n    cout << d[i] << (i + 1 == n ? \"\\n\" : \" \");\n  }\n\n  for (int i = 0; i < n; i++){\n    for (int j = 0; j < n; j++){\n      cout << (f[i][j] ? \"t\" : \"f\") << (j + 1 == n ? \"\\n\" : \" \");\n    }\n  }\n  */\n\n  int ans = 0;\n  for (int i = 0; i < n; i++){\n    ans = max(ans, d[i]);\n  }\n\n  for (int i = 0; i < n; i++){\n    for (int j = i; j < n; j++){\n      if (f[i][j]){\n        ans = max(ans, max(d[i], d[j]) + (int)round((cost[i][j] - abs(d[i] - d[j])) / 2.0));\n      }\n    }\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\nconst int INF = (1LL<<30);\nconst ll LLINF = (1LL<<60);\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n//#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nstruct edge{int to, cost;};\n\nint n, d[3010], m, k, s[3010];\nvector<edge> g[3010];\n\nvoid dijkstra() {\n  priority_queue<PII, vector<PII>, greater<PII>> que;\n  fill(d, d+n, INF);\n  REP(i, k) {\n    d[s[i]] = 0;\n    que.push(PII{0, s[i]});\n  }\n\n  while(que.size()) {\n    PII p = que.top(); que.pop();\n    int v = p.second;\n    if(d[v] < p.first) continue;\n    for(edge e: g[v]) {\n      if(d[e.to] > d[v] + e.cost) {\n        d[e.to] = d[v] + e.cost;\n        que.push(PII{d[e.to], e.to});\n      }\n    }\n  }\n}\n\nint a[3010], b[3010], c[3010];\nsigned main(void)\n{\n  cin >> n >> m >> k;\n  REP(i, m) {\n    cin >> a[i] >> b[i] >> c[i];\n    a[i]--, b[i]--;\n    g[a[i]].PB({b[i], c[i]});\n    g[b[i]].PB({a[i], c[i]});\n  }\n  REP(i, k) cin >> s[i], s[i]--;\n\n  dijkstra();\n  // REP(i, n) cout << d[i] << \" \"; cout << endl;\n\n  int ret = 0;\n  REP(i, m) chmax(ret, (d[a[i]]+d[b[i]]+c[i])/2+!!((d[a[i]]+d[b[i]]+c[i])%2));\n  cout << ret << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\nusing namespace std;\n\n#define N 3002\n#define INF 100000000\n\nstruct Edge {\n\tint to, cost;\n\tEdge(int t, int c) : to(t), cost(c) {}\n\tEdge() {};\n};\n\ntypedef vector<Edge> Graph;\n\nint cost[N];\nGraph g[N];\nvector<int> sv;\ntypedef pair<int, int> P;\n\nvoid dijkstra(int s) {\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tcost[s] = 0; q.push(P(0,s));\n\twhile(!q.empty()) {\n\t\tint p = q.top().first, v = q.top().second; q.pop();\n\t\tif(cost[v]<p) continue;\n\t\tfor(int i=0; i<(signed)g[v].size(); ++i) {\n\t\t\tEdge e = g[v][i];\n\t\t\tif(cost[v]+e.cost<cost[e.to]) {\n\t\t\t\tcost[e.to] = cost[v]+e.cost;\n\t\t\t\tq.push(P(cost[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\n#define max(a,b) (a>b?a:b)\n#define min(a,b) (a>b?b:a)\n\nint main() {\n\tint n, m, k, a, b, l, s;\n\tdouble ans = 0.0;\n\tcin >> n >> m >> k;\n\tfor(int i=1; i<=n; ++i) cost[i] = INF;\n\tfor(int i=0; i<m; ++i) {\n\t\tcin >> a >> b >> l;\n\t\tg[a].push_back(Edge(b,l));\n\t\tg[b].push_back(Edge(a,l));\n\t}\n\tfor(int i=0; i<k; ++i) {\n\t\tcin >> s;\n\t\tdijkstra(s);\n\t}\n\tfor(int i=1; i<=n; ++i) {\n\t\tfor(int j=0; j<(signed)g[i].size(); ++j) {\n\t\t\tif(i<g[i][j].to) break;\n\t\t\tdouble a = i; b = g[i][j].to; l = g[i][j].cost;\n\t\t\tif(a<=b+l || b<=a+l) {\n\t\t\t\tans = max(ans, (double)min(a,b));\n\t\t\t}else {\n\t\t\t\tans = max(ans, (double)(a+b+l)/2.0);\n\t\t\t}\n\t\t}\n\t}\n\tcout << (int)(ans+0.5) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<map>\n#include<functional>\n#include<algorithm>\n#define INF (1<<28)\nusing namespace std;\n\nint pass[3001][3001], maxpass[3001][3001];\nint saitan[3001], ans;\nint n, m, k;\npriority_queue<pair<int, int> , vector<pair<int, int> >,greater<pair<int, int> > > que;\nvector<int> neib[3001];\n\n\n\nint main(){\n  scanf(\"%d%d%d\", &n, &m, &k);\n  fill(saitan, saitan + 3001, INF);\n  for(int i = 0;i < m;i++){\n    int a, b, l;\n    scanf(\"%d%d%d\", &a, &b, &l);\n    neib[a].push_back(b);\n    neib[b].push_back(a);\n    pass[a][b] = pass[b][a] = l;\n  }\n  for(int i = 0;i < k;i++){\n    int s;\n    scanf(\"%d\", &s);\n    saitan[s] = 0;\n    que.push(make_pair(0, s));\n    saitan[s] = 0;\n  }\n  while(!que.empty()){\n    pair<int, int> tmp = que.top(); que.pop();\n    if(saitan[tmp.second] < tmp.first)continue;\n    for(int i = 0;i < neib[tmp.second].size();i++){\n      int from = tmp.second;\n      int to = neib[from][i];\n      if(saitan[to] > saitan[from] + pass[from][to]){\n\tsaitan[to] = saitan[from] + pass[from][to];\n\tque.push(make_pair(saitan[to], to));\n      }    \n    }    \n  }\n  for(int i = 1;i <= n;i++){\n    for(int j = 0;j < neib[i].size();j++){\n      int to = neib[i][j];\n      ans = max(ans, (1 + saitan[i] + saitan[to] + pass[i][to]) / 2);\n    }\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\nconst int inf = (int)1e9;\nint n, m, k;\nint ans = inf;\nvector<int> dist;\nvector<vector<pair<int, int> > > graph;\nvector<pair<pair<int, int>, int> > edge;\nscanf(\"%d%d%d\", &n, &m, &k);\ndist.resize(n, inf);\ngraph.resize(n);\nfor(int i = 0; i < m; ++i) {\nint a, b, l;\nscanf(\"%d%d%d\", &a, &b, &l);\na -= 1, b -= 1;\nedge.push_back(make_pair(make_pair(a, b), l));\ngraph[a].push_back(make_pair(b, l));\ngraph[b].push_back(make_pair(a, l));\n}\nfor(int i = 0; i < k; ++i) {\nint s;\nscanf(\"%d\", &s);\ns -= 1;\npriority_queue<pair<int, int> > q;\nq.push(make_pair(0, s));\nwhile(!q.empty()) {\nint v = q.top().second;\nint c = -q.top().first;\nq.pop();\nif(dist[v] < c)\ncontinue;\ndist[v] = c;\nfor(int i = 0; i < graph[v].size(); ++i) {\nint w = graph[v][i].second;\nint d = graph[v][i].second + c;\nq.push(make_pair(-d, w));\n}\n}\n}\nfor(int i = 0; i < m; ++i) {\nint a = edge[i].first.first;\nint b = edge[i].first.second;\nint l = edge[i].second;\nif(dist[a] > dist[b])\nswap(a, b);\nint cost;\nif(dist[a] + l <= dist[b])\ncost = dist[b];\nelse\ncost = (l - (dist[b] - dist[a]) + 1) / 2;\nans = max(ans, cost);\n}\nprintf(\"%d\\n\", ans);\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n\n#define NODE (3000)\n#define INF (100000000)\n\nint v[NODE + 1];\nint dist[NODE + 1];\nint w[NODE + 1][NODE + 1];\n\nint n, m, k;\n\nint max(int a, int b)\n{\n    return (a > b ? a : b);\n}\n\nvoid dijkstra(int start)\n{\n    int i, j;\n    int node;\n    \n    for (i = 1; i <= n; i++){\n        v[i] = 0;\n    }\n    \n    dist[start] = 0;\n    \n    while (1){\n        node = -1;\n        for (i = 1; i <= n; i++){\n            if (v[i] == 0 && (node == -1 || dist[node] > dist[i])){\n                node = i;\n            }\n        }\n        \n        if (node == -1){\n            break;\n        }\n        \n        v[node] = 1;\n        \n        for (i = 1; i <= n; i++){\n            if (dist[i] > dist[node] + w[node][i] && v[i] == 0){\n                dist[i] = dist[node] + w[node][i];\n            }\n        }\n    }\n}\n\nint main(void)\n{\n    int i, j;\n    int from, to, cost, res;\n    \n    scanf(\"%d%d%d\", &n, &m, &k);\n    \n    for (i = 1; i <= n; i++){\n        dist[i] = INF;\n        for (j = 1; j <= n; j++){\n            w[i][j] = INF;\n            if (i == j){\n                w[i][j] = 0;\n            }\n        }\n    }\n    \n    for (i = 1; i <= m; i++){\n        scanf(\"%d%d%d\", &from, &to, &cost);\n        w[from][to] = w[to][from] = cost;\n    }\n    for (i = 1; i <= k; i++){\n        scanf(\"%d\", &from);\n        dist[from] = 0;\n    }\n    dijkstra(from);\n    \n    res = 0;\n    \n    for (i = 1; i <= n; i++){\n        for (j = i + 1; j <= n; j++){\n            if (w[i][j] != INF){\n                res = max(res, (w[i][j] + dist[i] + dist[j] + 1) / 2);\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", res);\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll=long long;\n#define rep(i,a,n) for(ll i=a;i<n;i++)\n#define ALL(s) s.begin(),s.end()\n#define P pair<ll,ll>\n#define vl vector<ll>\n#define vi vector<int>\n#define vvl vector<vector<ll>>\n#define vvi vector<vector<int>>\n#define print(n) cout<<n<<endl\nconst int M=100111;\nconst int inf=1000000007;\nconst long long INF=1e18;\nint dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\nint ddx[8]={1,-1,0,0,1,-1,-1,1},ddy[8]={0,0,1,-1,1,-1,1,-1};\n\nll n,m,k,a,b,c,x;\nvector<P> to[M];\nll dist[M];\npriority_queue<P,vector<P>,greater<P>> que;\nvoid dijkstra(int start){\n//\trep(i,0,M)dist[i]=INF;\n\tdist[start]=0;\n\tque.push(P(0,start));\n\twhile(que.size()){\n\t\tP p=que.top();que.pop();\n\t\tll cost=p.first,now=p.second;\n\t\tif(dist[now]<cost)continue;\n\t\tfor(auto e:to[now]){\n\t\t\tll cost=e.first,next=e.second;\n\t\t\tif(dist[next]>dist[now]+cost){\n\t\t\t\tdist[next]=dist[now]+cost;\n\t\t\t\tque.push(P(dist[next],next));\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main(){\n\tcin>>n>>m>>k;\n\trep(i,0,m){\n\t\tcin>>a>>b>>c;\n\t\tto[a].push_back(P(c,b));\n\t\tto[b].push_back(P(c,a));\n\t}\n\trep(i,0,M)dist[i]=INF;\n\trep(i,0,k){\n\t\tcin>>x;\n\t\tdijkstra(x);\n\t}\n\tll ans=0;\n\trep(i,0,n+1){\n\t\tfor(auto e:to[i]){\n\t\t\tans=max(ans,(dist[i]+dist[e.second]+e.first+1)/2);\n\t\t}\n\t}\n\tprint(ans);\n\t\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define PB push_back\n#define PPB pop_back\ntypedef pair<int, int> pii;\nstatic const int INF = 1LL<<61;\n\nstatic const int MAX_N = 3005;\n\nint d[MAX_N], n, m, k;\nbool shop[MAX_N];\nvector<pii> G[MAX_N];\n\nvoid dijkstra() {\n  fill(d, d + MAX_N, INF);\n\n  priority_queue<pii, vector<pii>, greater<pii>> q;\n\n  for (int i = 0; i < k; ++i) {\n    int s;\n    cin >> s;\n    shop[s] = true;\n    d[s] = 0;\n    q.push(pii(0, s));\n  }\n\n  while (q.size()) {\n    pii p = q.top();\n    int v = p.second;\n    q.pop();\n    if (d[v] < p.first) continue;\n\n    for (int i = 0; i < G[v].size(); ++i) {\n      pii e = G[v][i];\n      if (d[e.first] < p.first + e.second) continue;\n\n      d[e.first] = p.first + e.second;\n      q.push(pii(d[e.first], e.first));\n    }\n  }\n}\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  cin >> n >> m >> k;\n  for (int i = 0; i < m; ++i) {\n    int a, b, l;\n    cin >> a >> b >> l;\n    G[a].PB(pii(b, l));\n    G[b].PB(pii(a, l));\n  }\n\n  dijkstra();\n\n  double ans = 0;\n  for (int i = 1; i < n; ++i) {\n    for (int j = 0; j < G[i].size(); ++j) {\n      pii e = G[i][j];\n      ans = max(ans, (d[i] + d[e.first] + e.second) / 2.0);\n    }\n  }\n\n  cout << (int)(ans + 0.5000001) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\nconst int INF=1e9;\nstruct dat{int a,b,c;};\nstruct edge{int to,cost;};\nint d[1010],n,m,k;\nvector<edge>G[1010];\nvoid dijkstra(int s){\n\td[s]=0;\n\tpriority_queue<P,vector<P>,greater<P> >Q;\n\tQ.push(MP(0,s));\n\twhile(!Q.empty()){\n\t\tP p=Q.top();Q.pop();\n\t\tint v=p.second;\n\t\tif(d[v]<p.first)continue;\n\t\tREP(i,G[v].size()){\n\t\t\tint to=G[v][i].to,cost=G[v][i].cost;\n\t\t\tif(d[to]>d[v]+cost){\n\t\t\t\td[to]=d[v]+cost;\n\t\t\t\tQ.push(MP(d[to],to));\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tREP(i,1010)d[i]=INF;\n\tcin>>n>>m>>k;\n\tvector<dat>road;\n\tREP(i,m){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;a--;b--;\n\t\troad.PB((dat){a,b,c});\n\t\tG[a].PB((edge){b,c});\n\t\tG[b].PB((edge){a,c});\n\t}\n\tREP(i,k){\n\t\tint s;\n\t\tcin>>s;s--;\n\t\tdijkstra(s);\n\t}\n\tint ans=0;\n\tREP(i,road.size()){\n\t\tdat v=road[i];\n\t\tans=max(ans,(d[v.a]+d[v.b]+v.c+1)/2);\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define M 100000007\ntypedef pair<int,int> P;\n/*int main(){\n\tcout<<8979879<<endl;\n}*/\nint ri[3001][3001];\nint main(void){\n\tint n,m,k,\n\t\ti,j,\n\t\tmx,t,ans,\n\t\ta[100001],b[100001],l[100001],s[3000],\n\t\td[3001];\n\t\t\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\n\tcin>>n>>m>>k;\n\tfor(i=0;i<m;i++) cin>>a[i]>>b[i]>>l[i];\n\tfor(i=0;i<k;i++) cin>>s[i];\n//\tfor(i=0;i<k;i++) cout<<s[i]<<endl;\n\t\n\tfor(i=1;i<=n;i++) for(j=1;j<=n;j++) ri[i][j]=M;\n\tfor(i=0;i<m;i++) ri[a[i]][b[i]]=l[i],ri[b[i]][a[i]]=l[i];\n/*\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++)cout<<ri[i][j]<<' ';\n\t\tcout<<endl;\n\t}*/\n\t\n\tint leng[3001];\n\tfor(i=1;i<=n;i++) leng[i]=M;\n\tfor(i=0;i<k;i++){\n\t\tleng[s[i]]=0;\n\t\tque.push(P(0,s[i]));\n\t}\n\twhile(!que.empty()){\n\t\tP p=que.top();\n\t\tque.pop();\n\t\tint v=p.second;\n\t\tif(leng[v]<p.first) continue;\n\t\tfor(j=1;j<=n;j++){\n\t\t\tt=leng[v]+ri[v][j];\n//\t\t\tcout<<j<<' '<<leng[j]<<' '<<t<<endl;\n\t\t\tif(leng[j]>t){\n\t\t\t\tleng[j]=t;\n//\t\t\t\tcout<<leng[j]<<' '<<j<<endl;\n\t\t\t\tque.push(P(leng[j],j));\n\t\t\t}\n\t\t}\n\t}\n/*\tfor(i=1;i<=n;i++) cout<<leng[i]<<' ';\n\tcout<<endl;*/\n\tans=0;\n\tfor(i=1;i<=n;i++){\n\t\tint mx=0,mi=M,y;\n\t\tdouble x;\n\t\tfor(j=1;j<=n;j++){\n\t\t\tif(ri[i][j]!=M){\n\t\t\t\tif(leng[i]!=0){\n\t\t\t\t\tmx=max(mx,ri[i][j]+leng[j]);\n\t\t\t\t\tmi=min(mi,ri[i][j]+leng[j]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tmx=max(mx,ri[i][j]);\n\t\t\t\t\tmi=min(mi,ri[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tx=(double)(mx+mi)/2;\n//\t\tcout<<x<<' '<<mx<<' '<<mi<<endl;\n\t\ty=round(x);\n\t\tans=max(ans,y);\n\t}\n\t\n\tcout<<ans<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <map>\n#include <sstream>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <iterator>\n#include <stack>\n#include <list>\nusing namespace std;\nconst int INF=1000000000;\ntypedef long long int lli;\ntypedef pair<int,int> P;\n\nconst int MAX_V=5001;\nint cost[MAX_V][MAX_V];\nint d[MAX_V];\nbool used[MAX_V];\nvector<int> mall;\nint shortest[MAX_V];\n\nint abs(int x){\n\tif(x<0) return -x;\n\telse return x;\n}\n\nint main(){\n\tint V,E,K;\n\tcin >> V >> E >> K;\n\tfor(int i=1; i<=V; ++i){\n\t\tfor(int j=1; j<=V; ++j){\n\t\t\tif(i==j) {\n\t\t\t\tcost[i][j]=0;\n\t\t\t} else {\n\t\t\t\tcost[i][j]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<E; ++i){\n\t\tint a,b,l;\n\t\tcin >> a >> b >> l;\n\t\tcost[a][b]=l;\n\t\tcost[b][a]=l;\n\t}\n\tfor(int i=0; i<K; ++i){\n\t\tint tmp;\n\t\tcin >> tmp;\n\t\tmall.push_back(tmp);\n\t}\n\tfill(shortest,shortest+V+1,INF);\n\tfor(int i=0; i<K; ++i){\n\t\tfill(d,d+V+1,INF);\n\t\tfill(used,used+V+1,false);\n\t\td[mall[i]]=0;\n\t\twhile(true){\n\t\t\tint v=-1;\n\t\t\tfor(int u=1; u<=V; ++u){\n\t\t\t\tif(!used[u]&&(v==-1||d[u]<d[v])) v=u;\n\t\t\t}\n\t\t\t\n\t\t\tif(v==-1) break;\n\t\t\tused[v]=true;\n\t\t\t\n\t\t\tfor(int u=1; u<=V; ++u){\n\t\t\t\td[u]=min(d[u],d[v]+cost[v][u]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1; i<=V; ++i){\n\t\t\tif(shortest[i]>d[i]) shortest[i]=d[i];\n\t\t}\n\t}\n\t\n\tint ans=-1;\n\tfor(int i=1; i<=V; ++i){\n\t\tfor(int j=1; j<=V; ++j){\n\t\t\tif(cost[i][j]!=INF){\n\t\t\t\tint tmp=abs((shortest[j]+shortest[i]+cost[i][j]+1)/2);\n\t\t\t\tans=max(ans,tmp);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <utility>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\nstruct edge {\n\tint to, cost;\n\tedge(int t, int c):to(t), cost(c){}\n};\ntypedef pair<int, int> P;\nvector<vector<edge> > es;\n\nvector<int> dijkstra(int s) {\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tvector<int> dist(es.size(), INT_MAX);\n\tque.push(P(0, s));\n\tdist[s] = 0;\n\t\n\twhile(!que.empty()) {\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif(dist[v] < p.first)\n\t\t\tcontinue;\n\t\tfor(int i = 0; i < es[v].size(); ++i) {\n\t\t\tedge& e = es[v][i];\n\t\t\tif(dist[e.to] > dist[v] + e.cost) {\n\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\tque.push(P(dist[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dist;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\n\tes.resize(n);\n\tvector<P> con(m);\n\tvector<int> len(m);\n\tfor(int i = 0; i < m; ++i) {\n\t\tint a, b, l;\n\t\tcin >> a >> b >> l;\n\t\t--a;\n\t\t--b;\n\n\t\tes[a].push_back(edge(b, l));\n\t\tes[b].push_back(edge(a, l));\n\t\tcon[i] = make_pair(a, b);\n\t\tlen[i] = l;\n\t}\n\n\tvector<int> mn_dist(n, INT_MAX);\n\tfor(int i = 0; i < k; ++i) {\n\t\tint s;\n\t\tcin >> s;\n\n\t\tvector<int> dist = dijkstra(s - 1);\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tchmin(mn_dist[i], dist[i]);\n\t}\n\n\tint ans = 0;\n\tfor(int i = 0; i < n; ++i)\n\t\tchmax(ans, mn_dist[i]);\n\n\tfor(int i = 0; i < m; ++i)\n\t\tchmax(ans, (mn_dist[con[i].first] + mn_dist[con[i].second] + len[i] + 1) / 2);\n\n\tcout << ans << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3002\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<P> G[N];\nbool num[N];\nint n,m,K;\n\ndouble dijkstra(){\n  int D[N];\n  for(int i=0;i<N;i++) D[i] = 1e9;\n  \n  vector<int>pre[N];\n  priority_queue<PP,vector<PP>,greater<PP> >Q;\n  \n  for(int i=0;i<N;i++)\n    if(num[i]) {\n      Q.push(PP(0,P(i,i)));\n      D[i] = 0;\n      pre[i].push_back(i);\n    }\n\n  \n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first;\n    int pos = t.second.first;\n    int start = t.second.second;\n\n    if(D[pos]<cost) continue;\n    pre[pos].push_back(start);\n    if(D[pos]<=cost)continue;\n    \n    for(int i=0;i<G[pos].size();i++){\n      int npos = G[pos][i].first;\n      int ncost = cost+G[pos][i].second;\n      if(D[npos]<ncost) continue;\n      Q.push(PP(ncost,P(npos,start)));\n      D[npos] = ncost;\n    }\n  }\n\n\n  double res = 0;\n  for(int i=0;i<n;i++){\n    if(pre[i].size()>=2)res = max(res,(double)D[i]);\n    res = max(res,D[i]/2.0);\n    \n    for(int j=0;j<G[i].size();j++){\n      int npos = G[i][j].first;\n      int ncost = G[i][j].second;\n      if(pre[npos][0] == pre[i][0] && abs(D[i]-D[npos])==ncost)continue;\n\n      res = max(res,(D[i]+D[npos]+ncost)/2.0);\n    }\n  }\n  return res;\n  \n}\n\nint main(){\n  \n  cin>>n>>m>>K;\n  for(int i=0,a,b,c;i<m;i++){\n    cin>>a>>b>>c;\n    G[a-1].push_back(P(b-1,c));\n    G[b-1].push_back(P(a-1,c));\n  }\n\n  for(int i=0,a;i<K;i++)cin>>a,num[a-1]=1;\n  printf(\"%d\\n\",(int)(dijkstra()+0.5));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <map>\n#include <functional>\n\nusing namespace std;\ntypedef pair<int,int> mp;\nint mins(int p,int q){\n  if(p==-1)return q;\n  else if(q==-1 || p<q)return p;\n  else return q;\n}\nint max(int p,int q){\n  if(p<q)return q;\n  else return p;\n}\n\nint md[3000][3000];\nint mm[3000];\nint dt[3000];\nbool ch[3000];\nint m,n,k;\n\nint main(void){\n  memset(md,-1,sizeof(md));\n  memset(dt,-1,sizeof(dt));\n  scanf(\"%d%d%d\",&n,&m,&k);\n  int i,j;\n  int a,b,c;\n  for(i=0;i<m;i++){\n    scanf(\"%d%d%d\",&a,&b,&c);\n    md[a-1][b-1]=c;\n    md[b-1][a-1]=c;\n  }\n  for(i=0;i<k;i++){\n    scanf(\"%d\",&a);\n    mm[i]=a-1;\n  }\n  int st,no,kyo,mk;\n  mp pa;\n  int ans=0;\n  priority_queue <mp,vector<mp>,greater<mp> > que;\n  for(i=0;i<k;i++){\n    st=mm[i];\n    dt[st]=0;\n  }\n  memset(ch,false,sizeof(ch));\n  //ch[st]=true;\n  que.push(make_pair(0,st));\n  while(!que.empty()){\n    pa=que.top();\n    que.pop();\n    kyo=pa.first;\n    no=pa.second;\n    if(ch[no]==false){\n      for(j=0;j<n;j++){\n\tif(md[no][j]!=-1 && ch[j]==false){\n\t  mk=md[no][j];\n\t  dt[j]=mins(dt[j],kyo+mk);\n\t  que.push(make_pair(dt[j],j));\n\t}\n      }\n      ch[no]=true;\n    }\n  }\n  for(i=0;i<n;i++){\n    ans=max(ans,dt[i]);\n    //printf(\"%d\\n\",dt[i]);\n  }\n  //printf(\"\\n\");\n  for(i=0;i<n;i++){\n    for(j=i+1;j<n;j++){\n      if(md[i][j]!=-1){\n\tans=max(ans,(int)((dt[i]+dt[j]+md[i][j]+1)/2));\n\t//printf(\"%d %d %d\\n\",i+1,j+1,(int)((dt[i]+dt[j]+md[i][j]+1)/2));\n      }\n    }\n  }\n\n  printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <vector>\n\n#define INF (1e9)\n#define LLINF (1e18)\n#define long long\n\n#define MAX_V 3000\n\nusing namespace std;\n\ntypedef struct edge{\npublic:\n\tint to;\n\tdouble cost;\n\tedge(){}\n\tedge(int _to,double _cost){\n\t\tto = _to;\n\t\tcost = _cost;\n\t}\n\tbool operator<(const edge &a)const{\n\t\tif(cost == a.cost) return to > a.to;\n\t\treturn cost > a.cost;\t//for asc\n\t}\n}edge;\n\n\ndouble dist[MAX_V + 1];\nvector<edge> G[MAX_V + 1];\n\npriority_queue<edge> pque;\n\nint shops[MAX_V + 1];\n\nint V;\nint E;\nint K;\n\n\ndouble ans;\n\ndouble calc(double x,double y,double e){\n\tdouble a;\n\ta = (y - x + e) / 2;\n\treturn a;\n}\n\nvoid solve(){\n\tfor(int i = 0;i < MAX_V + 1;i++) dist[i] = INF;\n\n\tfor(int i = 0;i < K;i++){\n\t\tpque.push(edge(shops[i],0));\n\t}\n\n#ifndef EVAL\n//\tputs(\"###DBG1\");\n#endif\n\n\twhile(!pque.empty()){\n\t\tedge e = pque.top(); pque.pop();\n\t\tif(dist[e.to] != INF) continue;\n\t\tdist[e.to] = e.cost;\n\n\t\tfor(int i = 0;i < G[e.to].size();i++){\n\t\t\tint _to = G[e.to][i].to;\n\t\t\tdouble _cost = G[e.to][i].cost + e.cost;\n\t\t\tpque.push(edge(_to,_cost));\n\t\t}\n\n\t}\n\n#ifndef EVAL\n//\tputs(\"###DBG2\");\n#endif\n\n\tans = 0;\n\tfor(int i = 1;i < V + 1;i++){\n\t\tfor(int j = 0;j < G[i].size();j++){\n\t\t\t//printf(\"###%lf\\n\",dist[i] + calc(dist[i],dist[G[i][j].to],G[i][j].cost));\n\t\t\tans = max(ans,dist[i] + calc(dist[i],dist[G[i][j].to],G[i][j].cost));\n\t\t}\n\t}\n\n\n\treturn ;\n}\n\nint main(){\n\n\tscanf(\"%d%d%d\",&V,&E,&K);\n\tint _u,_v;\n\tdouble _cost;\n\tfor(int i = 0;i < E;i++){\n\t\tscanf(\"%d%d\",&_u,&_v);\n\t\tscanf(\"%lf\",&_cost);\n\t\tG[_u].push_back(edge(_v,_cost));\n\t\tG[_v].push_back(edge(_u,_cost));\n\t}\n\tfor(int i = 0;i < K;i++){\n\t\tscanf(\"%d\",shops + i);\n\t}\n\n#ifndef EVAL\n//\tputs(\"###DBG\");\n#endif\n\n\tsolve();\n\t//printf(\"***%lf\\n\",ans);\n\tprintf(\"%d\\n\",(int)(ans + 0.5));\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>  \nusing namespace std;\ntypedef pair< int, int > Pi;\n\nstruct edge{\n  int to, cost;\n};\ntypedef vector< vector< edge > > Graph;\nconst int INF = 1 << 30;\n\nint main(){\n  int N, M, K;\n  cin >> N >> M >> K;\n  Graph graph(N);\n  for(int i = 0; i < M; i++){\n    int a, b, c;\n    cin >> a >> b >> c;\n    --a, --b;\n    graph[a].push_back((edge){ b, c});\n    graph[b].push_back((edge){ a, c});\n  }\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  vector< int> min_cost( N, INF);\n  for(int i = 0; i < K; i++){\n    int a;\n    cin >> a;\n    --a;\n    que.push(make_pair( 0, a));\n    min_cost[a] = 0;\n  }\n  while(!que.empty()){\n    Pi p = que.top(); que.pop();\n    if(min_cost[p.second] < p.first) continue;\n    for(int i = 0; i < graph[p.second].size(); i++){\n      edge& e = graph[p.second][i];\n      if(min_cost[e.to] <= p.first + e.cost) continue;\n      min_cost[e.to] = p.first + e.cost;\n      que.push( make_pair( p.first + e.cost, e.to));\n    }\n  }\n  \n  int ret = 0;\n  for(int i = 0; i < N; i++){\n    for(int j = 0; j < graph[i].size(); j++){\n      edge& e = graph[i][j];\n      if(min_cost[i] <= min_cost[e.to]){\n        // この辺の真ん中あたりに最大値がありそう\n        double sa = min_cost[e.to] - min_cost[i];\n        ret = max( ret, (int)(min_cost[i] + sa + (e.cost - sa) / 2.0 + 0.5));\n      }\n    }\n    ret = max( ret, min_cost[i]);\n  }\n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<math.h>\n#include<queue>\n#include<set>\n#include<map>\n#include<random>\n#include<functional>\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define pb push_back\n#define pint pair<int, int>\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\n\n\nconst int INF = 1e9;\n\nstruct edge\n{\n\tint to, co;\n\tedge(int t, int c) : to(t), co(c) {}\n};\n\nint N, M, K;\nint main() {\n\tiostream::sync_with_stdio(false);\n\n\tcin >> N >> M >> K;\n\n\tvector< vector<edge> > g(N);\n\n\tfor (int i = 0; i < M; i++) {\n\t\tint a, b, l;\n\t\tcin >> a >> b >> l;\n\t\ta--; b--;\n\n\t\tg[a].push_back(edge(b, l));\n\t\tg[b].push_back(edge(a, l));\n\t}\n\n\tpriority_queue<pint, vector<pint>, greater<pint>> pq;\n\tvector<int> cost(N, INF);\n\tvector<bool> used(N, false);\n\n\tfor (int i = 0; i < K; i++) {\n\t\tint s;\n\t\tcin >> s;\n\t\ts--;\n\t\tpq.push(mp(0, s));\n\t\tcost[s] = 0;\n\t}\n\n\twhile (!pq.empty())\n\t{\n\t\tint c = pq.top().first;\n\t\tint v = pq.top().second;\n\t\tpq.pop();\n\n\t\tif (used[v]) continue;\n\t\tused[v] = true;\n\n\t\tfor (auto e : g[v]) {\n\t\t\tif (cost[e.to] > cost[v] + e.co) {\n\t\t\t\tcost[e.to] = cost[v] + e.co;\n\t\t\t\tpq.push(mp(cost[e.to], e.to) );\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (auto e : g[i]) {\n\t\t\tint l = abs(cost[i] - cost[e.to]);\n\t\t\tif (e.co == l) ans = max({ans, cost[i], cost[e.to]});\n\t\t\telse {\n\t\t\t\tans = max(ans, (cost[i] + cost[e.to] + e.co + 1) / 2);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <bitset>\n#include <string>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <list>\n#include <deque>\nusing namespace std;\n#define INF 10000000\n#define LLINF 100000000000000\ntypedef pair<int, int> P;\ntypedef long long ll;\n#define pb push_back\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define all(x) (x).begin(),(x).end()\n#define VSORT(v) sort(v.begin(), v.end());\n#define fi first\n#define se second\n#define out(x) cout << x << endl;\nint dx[] = { 1, 0, -1, 0 }, dy[] = { 0,1,0,-1 };\nll MOD = 1000000007;\nstruct edge {\n\tll from, to, cost;\n};\nint v, e, k;\nvector<P> es[100005];\nint d[3005] = { 0 };\n\n\n\nint main() {\n\tcin >> v >> e >> k;\n\trep(i, v) d[i] = INF;\n\tint res = 0;\n\trep(i, e) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tes[a].push_back(P(b, c));\n\t\tes[b].push_back(P(a, c));\n\t}\n\tpriority_queue<P, vector<P>, greater<P>>que;\n\trep(i, k) {\n\t\tint s;\n\t\tcin >> s;\n\t\ts--;\n\t\tque.push(P(0, s));\n\t\td[s] = 0;\n\t}\n\twhile (!que.empty()) {\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint V = p.second;\n\t\tif (d[V] < p.first) continue;\n\t\tfor (int u = 0; u < es[V].size(); u++) {\n\t\t\tint to = es[V][u].first;\n\t\t\tint cost = es[V][u].second;\n\t\t\tif (d[to] > d[V] + cost) {\n\t\t\t\td[to] = d[V] + cost;\n\t\t\t\tque.push(P(d[to], to));\n\t\t\t}\n\t\t}\n\t}\n\trep(i, v) {\n\t\tfor (int u = 0; u < es[i].size(); u++) {\n\t\t\tint to = es[i][u].first;\n\t\t\tint cost = es[i][u].second;\n\t\t\tint tmp = (d[to] + cost + d[i] + 1) / 2;\n\t\t\tres = max(res, tmp);\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\nstruct edge{int to,cost;};\nint n,m,k;\nvector<edge> g[3050];\nvector<int> shop;\nint d[3050];\nint dist[3050];\nint L[3002][3002];\nvoid input()\n{\n\tmemset(L,-1,sizeof(L));\n\tfill(dist,dist+3050,INF);\n\tcin >> n >> m >> k;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint a,b,l;\n\t\tcin >> a >> b >> l;\n\t\tedge in;\n\t\tin.to=b;\n\t\tin.cost=l;\n\t\tg[a].pb(in);\n\t\tin.to=a;\n\t\tg[b].pb(in);\n\t\tL[a][b]=l;\n\t\tL[b][a]=l;\n\t}\n\tfor(int i=0;i<k;i++)\n\t{\n\t\tint s;\n\t\tcin >> s;\n\t\tshop.pb(s);\n\t}\n\treturn;\n}\nvoid update()\n{\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tdist[i]=min(dist[i],d[i]);\n\t}\n\treturn;\n}\nvoid dijkstra(int s)\n{\n\tfill(d,d+n+1,INF);\n\tpriority_queue<P,vector<P>,greater<P> > q;\n\td[s]=0;\n\tq.push(P(0,s));\n\twhile(!q.empty())\n\t{\n\t\tP a=q.top();\n\t\tq.pop();\n\t\tif(d[a.sec]<a.fi)continue;\n\t\tfor(int i=0;i<g[a.sec].size();i++)\n\t\t{\n\t\t\tedge e=g[a.sec][i];\n\t\t\tif(d[e.to]>d[a.sec]+e.cost)\n\t\t\t{\n\t\t\t\td[e.to]=d[a.sec]+e.cost;\n\t\t\t\tq.push(P(d[e.to],e.to));\n\t\t\t}\n\t\t}\n\t}\n\t//cout << d[3] << endl;\n\tupdate();\n\treturn;\n}\nint main()\n{\n\tinput();\n\tfor(int i=0;i<shop.size();i++)\n\t{\n\t\tdijkstra(shop[i]);\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tif(L[i][j]==-1)continue;\n\t\t\tint k=L[i][j]-abs(dist[i]-dist[j]);\n\t\t\tif(k<=0)\n\t\t\t{\n\t\t\t\tans=max(ans,max(dist[i],dist[j]));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans=max(ans,max(dist[i],dist[j])+(k+1)/2);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define s size()\n#define INF 100000000\nint cost[3005][3005];\nint d[3005];\nint maxi[100005]={};\nbool used[3005]={};\nP1 ii[100005];\nint V;\nvoid dijkstra(int os){\n\tfill(d,d+V,INF);\n\td[s]=0;\n\twhile(1){\n\t\tint v=-1;\n\t\tfor(int u=0;u<V;u++){\n\t\t\tif(!used[u] && (v==-1 || d[u]<d[v])){\n\t\t\t\tv=u;\n\t\t\t}\n\t\t}\n\t\tif(v==-1){\n\t\t\tbreak;\n\t\t}\n\t\tused[v]=true;\n\t\tfor(int i=0;i<V;i++){\n\t\t\td[i]=min(d[i],d[v]+cost[v][i]);\n\t\t}\n\t}\n}\nint n,m,k;\nint main(){\n\tscanf(\"%d %d %d\",&n,&m,&k);\n\tfor(int i=0;i<3005;i++){\n\t\tfor(int j=0;j<3005;j++){\n\t\t\tcost[i][j]=INF;\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint w,ww,eu;\n\t\tscanf(\"%d %d %d\",&w,&ww,&eu);\n\t\tii[i]=mp(eu,mp(w,ww));\n\t\tcost[w-1][ww-1]=eu;\n\t\tcost[ww-1][w-1]=eu;\n\t}\n\tint res=0;\n\tfor(int i=0;i<k;i++){\n\t\tint t;\n\t\tscanf(\"%d\",&t);\n\t\tdijkstra(t-1);\n\t\tmemset(used,0,sizeof(used));\n\t\tfor(int j=0;j<m;j++){\n\t\t\tmaxi[j]=max(maxi[j],(ii[j].first+d[ii[j].second.first-1]+d[ii[j].second.second-1]+1)/2);\n\t\t}\n\t}\n\tfor(int j=0;j<m;j++){\n\t\tres=max(res,maxi[j]);\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define Rep(i, N) for(int i = 0; i < N; i++)\n#define fi first\n#define se second\n#define pb push_back\ntypedef pair<int, int> Pi;\nconst int LLINF = 1LL << 60;\n \ninline int llabs(int n) { return n < 0 ? -n : n; }\n \nstruct Edge {\n  int to, cost;\n};\n \nvector< Edge > G[3005];\nint mc[3005];\nint N, M, K;\n \nvoid Dijkstra(int s)\n{\n  priority_queue < Pi, vector< Pi >, greater< Pi > > pq;\n   \n  pq.push(Pi(0, s)); mc[s] = 0;\n  while(!pq.empty()) {\n    int v = pq.top().se, w = pq.top().fi; pq.pop();\n    if(mc[v] < w) continue;\n    Rep(i, G[v].size()) {\n      int u = G[v][i].to, nw = w + G[v][i].cost;\n      if(nw < mc[u]) {\n\tmc[u] = nw; pq.push(Pi(nw, u));\n      }\n    }\n  }\n}\n \nint A[100005], B[100005], C[100005];\nsigned main()\n{\n  int ans = 0;\n  int k;\n   \n  cin >> N >> M >> K;\n  Rep(i, M) {\n    cin >> A[i] >> B[i] >> C[i]; --A[i], --B[i];\n    G[A[i]].pb( (Edge) { B[i], C[i] } );\n    G[B[i]].pb( (Edge) { A[i], C[i] } );\n  }\n \n  fill_n(mc, 3005, LLINF);\n  Rep(i, K) {\n    cin >> k; --k;\n    Dijkstra(k);\n  }\n \n  Rep(i, M) {\n    ans = max(ans, min(mc[A[i]], mc[B[i]]) + (llabs(mc[A[i]] - mc[B[i]]) + C[i] + 1) / 2);\n  }\n \n  cout << ans << endl;\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <map>\n#include <vector>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define IREP(it,array) for(vector<int>::iterator it=array.begin(); it!=array.end(); ++it)\n#define PREP(it,array) for(vector<P>::iterator it=array.begin(); it!=array.end(); ++it)\n#define SREP(it,array) for(vector<string>::iterator it=array.begin(); it!=array.end(); ++it)\n\n#define MP       make_pair\n#define PB       push_back\n#define ALL(x)   (x).begin(),(x).end()\n\nconst int INF = 1<<29;\nconst double EPS = 1e-9;\ndouble zero(double d){\n  return d < EPS ? 0.0 : d;\n}\n\ntypedef long long LL;\ntypedef pair<int,int> P;\n\n\nint main()\n{\n  cout.setf(ios::fixed, ios::floatfield);\n  cout.precision(7);\n\n  int N,M,K;\n  cin >>N>>M>>K;\n\n  vector<P> node[N+1];\n\n  int d[N+1];\n  fill(d,d+N+1,INF);\n\n  priority_queue<P, vector<P>, greater<P> > pque;\n\n  REP(_t,M){\n    int a,b,l;\n    cin >>a>>b>>l;\n    node[a].PB( MP(b,l) );\n    node[b].PB( MP(a,l) );\n  }\n\n  REP(_t,K){\n    int a;\n    cin >> a;\n    pque.push( P(0,a) );\n    d[a] = 0;\n  }\n\n  // dijkstra\n  while( ! pque.empty() ){\n    P p = pque.top(); pque.pop();\n    int v = p.second;\n    if( d[v] < p.first )\n      continue;\n\n    PREP(it,node[v]){\n      int to = (*it).first;\n      int cost = (*it).second;\n      if( d[to] > d[v] + cost ){\n\td[to] = d[v]+cost;\n\tpque.push( P(cost,to) );\n      }\n    }\n  }\n\n\n  int res = 0;\n  REP(i, N+1){\n    if( d[i] != INF){\n      res = max( res, d[i] );\n\n      PREP(it,node[i]){\n\tint to = (*it).first;\n\tint cost = (*it).second;\n\tif( cost  != INF ){\n\t  int val = (double)(d[i]+cost+d[to])/2+0.5;\n\t  res = max( res, val );\n\t}\n      }\n    }\n  }\n\n  cout << res << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<functional>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PP;\nconst int INF = 1 << 30;\nint n, m, k;\nvector<P> road[3001];\nint shop[3001], dis[3001], from[3001], save[3001][3001];\nqueue<PP> que;\nint main(){\n\tcin >> n >> m >> k;\n\tfor (int i = 0; i<m; i++){\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\troad[a].push_back(P(b, c));\n\t\troad[b].push_back(P(a, c));\n\t}\n\tfor (int i = 0; i<k; i++)\n\t\tcin >> shop[i];\n\tfill(dis, dis + 3001, INF);\n\tfor (int i = 0; i<k; i++){\n\t\tfor (int j = 0; j<road[shop[i]].size(); j++){\n\t\t\tque.push(make_pair(make_pair(shop[i], road[shop[i]][j].f), road[shop[i]][j].s));\n\t\t\tdis[shop[i]] = 0;\n\t\t\tdis[road[shop[i]][j].f] = min(dis[road[shop[i]][j].f], road[shop[i]][j].s);\n\t\t\tfrom[road[shop[i]][j].f] = shop[i];\n\t\t}\n\t}\n\twhile (!que.empty()){\n\t\tPP p = que.front();\n\t\tque.pop();\n\t\tfor (int i = 0; i<road[p.f.s].size(); i++){\n\t\t\tif (dis[road[p.f.s][i].f]>p.s + road[p.f.s][i].s){\n\t\t\t\tque.push(make_pair(make_pair(p.f.s, road[p.f.s][i].f), p.s + road[p.f.s][i].s));\n\t\t\t\tdis[road[p.f.s][i].f] = p.s + road[p.f.s][i].s;\n\t\t\t\tfrom[road[p.f.s][i].f] = p.f.s;\n\t\t\t}\n\t\t}\n\t}\n\tdouble ans = 0;\n\tfor (int i = 0; i<3001; i++)\n\t\tfill(save[i], save[i] + 3001, INF);\n\tfor (int i = 1; i <= n; i++){\n\t\tif (dis[i] != INF){\n\t\t\tfor (int j = 0; j<road[i].size(); j++){\n\t\t\t\tdouble a = double(road[i][j].s + dis[i]+dis[road[i][j].f]) / 2;\n\t\t\t\tif (a>ans && save[i][road[i][j].f]>a + dis[i]){\n\t\t\t\t\tans = a;\n\t\t\t\t\tsave[i][road[i][j].f] = ans;\n\t\t\t\t}\n\t\t\t\t\tsave[i][road[i][j].f] = a;\n\t\t\t}\n\t\t}\n\t}\n\tint ans2;\n\tans += 0.5;\n\tans2 = int(ans);\n\tcout << ans2 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <sstream>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n\n#define INF (1 << 27)\n#define MAX_V 10000\n\nstruct edge{\n\tint to;\n\tint cost;\n};\n\nstruct edge2{\n\tint from;\n\tint to;\n\tint cost;\n};\n\ntypedef pair<int, int> P; // first??????????????¢???second??????????????????\n\n// ?????????O(|E|log|V|)\n\nint d[MAX_V];\nvector<edge> G[MAX_V];\n\nvoid shortest_path(vector<int> v_s, int V){ // V???????????°\n\t\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\n\tfor(int i = 0; i < V; i++){\n\t\td[i] = INF;\n\t}\n\tfor(int i = 0; i < v_s.size(); i++){\n\t\td[v_s[i]] = 0;\n\t\tque.push(P(0, v_s[i]));\n\t}\n\t\n\t\n\twhile(!que.empty()){\n\t\t\n\t\tP p = que.top();\n\t\tque.pop();\n\t\t\n\t\tint v = p.second;\n\t\t\n\t\tif(d[v] < p.first){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > e.cost + d[v]){\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t} // ????????????????°???????????????´??°\n\t}\n}\n\nint main(){\n\t\n\tint N, M, K;\n\t\n\twhile(true){\n\t\tcin >> N >> M >> K;\n\t\t\n\t\tif(cin.eof()){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < MAX_V; i++){\n\t\t\tG[i].erase(G[i].begin(), G[i].end());\n\t\t}\n\t\t\n\t\tvector<edge2> v_edges;\n\t\t\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tint a, b, l;\n\t\t\tcin >> a >> b >> l;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tedge e1, e2;\n\t\t\tedge2 ee;\n\t\t\te1.to = b;\n\t\t\te2.to = a;\n\t\t\te1.cost = l;\n\t\t\te2.cost = l;\n\t\t\tG[a].push_back(e1);\n\t\t\tG[b].push_back(e2);\n\t\t\t\n\t\t\tee.from = a;\n\t\t\tee.to = b;\n\t\t\tee.cost = l;\n\t\t\tv_edges.push_back(ee);\n\t\t\t\n\t\t}\n\t\t\n\t\tvector<int> v_start;\n\t\t\n\t\tfor(int i = 0; i < K; i++){\n\t\t\tint st;\n\t\t\tcin >> st;\n\t\t\tst--;\n\t\t\tv_start.push_back(st);\n\t\t}\n\t\t\n\t\tshortest_path(v_start, N);\n\t\t\n\t\tint ans = 0;\n\t\t\n\t\tfor(int i = 0; i < v_edges.size(); i++){\n\t\t\tedge2 ee = v_edges[i];\n\t\t\tint ref = d[ee.from] + d[ee.to] + ee.cost;\n\t\t\tif(ref % 2 == 1){\n\t\t\t\tref++;\n\t\t\t}\n\t\t\tif(ans < ref / 2){\n\t\t\t\tans = ref / 2;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <deque>\n#include <vector>\nusing namespace std;\n\nint main() {\n\tint N,M,K;\n\tvector<pair<int,int> >nGo[3001];\n\tdeque<int> dis;\n\tint dist[3001];\n\tint road[3000][3];\n\tfor(int i=1;i<=3000;i++)\n\t\tdist[i]=(1 << 30 );\n\tcin >> N >> M >> K;\n\tint a,b,c;\n\tfor(int i=0;i<M;i++){\n\t\tcin >> a >> b >> c;\n\t\tnGo[a].push_back(pair<int,int>(b,c));\n\t\tnGo[b].push_back(pair<int,int>(a,c));\n\t\troad[i][0]=a;\n\t\troad[i][1]=b;\n\t\troad[i][2]=c;\n\t}\n\tfor(int i=0;i<K;i++){\n\t\tcin >> a;\n\t//\tdis.insert(multimap<int,int>::value_type(0,a));\n\t\tdis.push_back(a);\n\t\tdist[a]=0;\n\t}\n\twhile(!dis.empty()){\n\t\tsort(dis.begin(),dis.end());\n\t\tint now=dis[0];\n\t\tfor(int i=0;i<nGo[now].size();i++){\n\t\t\tif(dist[nGo[now][i].first]>dist[now]+nGo[now][i].second){\n\t\t\t\tdis.push_back(nGo[now][i].first);\n\t\t\t\tdist[nGo[now][i].first]=dist[now]+nGo[now][i].second;\n\t\t\t}\n\t\t}\n\t\tdis.pop_front();\n\t}\n\tint maxer=0;\n\tfor(int i=0;i<M;i++)\n\tmaxer=max(maxer,(dist[road[i][0]]+dist[road[i][1]]+road[i][2]+1)/2);\n\tfor(int i=1;i<=N;i++)\n\tmaxer=max(maxer,dist[i]);\n\tcout << maxer <<  endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nint n, m, k;\nint amat[5000][5000];\nint vtx[5000];\nvector<int> mal;\n\nint solve(){\n\t\n\tfor(int i=0; i<n; ++i){\n\t\tvtx[i] = INT_MAX;\n\t}\n\n\tfor(int s=0; s<k; ++s){\n\n\t\tint vtx_tmp[5000];\n\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tvtx_tmp[i] = INT_MAX;\n\t\t}\n\t\t\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tqu.push(make_pair(0, mal[s]));\n\t\tvtx_tmp[mal[s]]=0;\n\t\t\n\t\twhile(!qu.empty()){\n\n\t\t\tint now = qu.top().second;\n\t\t\tqu.pop();\n\n\t\t\tfor(int i=0; i<n; ++i){\n\n\t\t\t\tif( amat[now][i] && vtx_tmp[i] > vtx_tmp[now] + amat[now][i]){\n\n\t\t\t\t\tvtx_tmp[i] = vtx_tmp[now] + amat[now][i];\n\t\t\t\t\tqu.push( make_pair(vtx_tmp[i], i) );\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0; i<n; ++i){\t\n\t\t\tvtx[i] = min(vtx[i], vtx_tmp[i]);\n\t\t}\n\t}\n\n\tint ma = -1;\n\n\tfor(int i=0; i<n-1; ++i){\n\t\tfor(int j=i+1; j<n; ++j){\n\t\t\t\n\t\t\tif(amat[i][j]){\n\t\t\t\tma = max(ma, min(vtx[i], vtx[j]) + (1 + amat[i][j] + abs(vtx[i]-vtx[j]))/2 );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ma;\n}\n\nint main(){\n\n\tcin >> n >> m >> k;\n\n\tfor(int i=0; i<m; ++i){\n\t\t\n\t\tint a, b, l;\n\t\tcin >> a >> b >> l;\n\t\ta--; b--;\n\t\tamat[a][b] = amat[b][a] = l;\n\t}\n\n\tfor(int i=0; i<k; ++i){\n\n\t\tint s;\n\t\tcin>>s;\n\t\tmal.push_back(--s);\n\t}\n\n\tcout << solve() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair <int, int> ii;\ntypedef vector <int> vi;\ntypedef double ld;\n#define X first\n#define Y second\n#define mk make_pair\n#define pb push_back\n#define Rep(i, n) for(int i = 0; i < int(n); i ++)\n#define Rep1(i, n) for(int i = 1; i <= int(n); i ++)\n#define all(x) (x).begin(), (x).end()\nconst int MOD = (int) 1e9 + 7;\nconst int base = 31;\nvoid MAIN();\nint main(){\n    //freopen(\"input.txt\", \"r\", stdin);\n    ios:: sync_with_stdio(false); cin.tie(0);\n    MAIN();\n    return 0;\n}\n////////////////////////////////////////////////////////////////////////\n\nconst int N = 1 << 12;\n\nint n, m, h;\nvector <ii> G[N];\nint d[N];\n\nvoid MAIN(){\n    cin >> n >> m >> h;\n    Rep1(i, m){\n        int u, v, c;\n        cin >> u >> v >> c;\n        G[u].pb(ii(v, c));\n        G[v].pb(ii(u, c));\n    }\n    int ans = 0;\n    priority_queue <ii> q;\n    memset(d, 0x3f, sizeof d);\n    while(h --){\n        int u;\n        cin >> u;\n        d[u] = 0;\n        q.push(ii(-d[u], u));\n    }\n    while(!q.empty()){\n        int u = q.top().Y, r = -q.top().X; q.pop();\n        if(d[u] != r) continue;\n        ans = d[u];\n        Rep(i, G[u].size()){\n            int v = G[u][i].X, c = G[u][i].Y;\n            if(d[v] > d[u] + c){\n                d[v] = d[u] + c;\n                q.push(ii(-d[v], v));\n            }\n        }\n    }\n    Rep1(u, n) Rep(i, G[u].size()){\n        int v = G[u][i].X, c = G[u][i].Y;\n        if(abs(d[u] - d[v]) <= c) ans = max(ans, (d[u] + d[v] + c + 1) / 2);\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define M 100000007\ntypedef pair<int,int> P;\n/*int main(){\n\tcout<<8979879<<endl;\n}*/\nint ri[3001][3001];\nint main(void){\n\tint n,m,k,\n\t\ti,j,\n\t\tmx,t,\n\t\ta[100001],b[100001],l[100001],s[3000],\n\t\td[3001];\n\t\t\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\n\tcin>>n>>m>>k;\n\tfor(i=0;i<m;i++) cin>>a[i]>>b[i]>>l[i];\n\tfor(i=0;i<k;i++) cin>>s[i];\n//\tfor(i=0;i<k;i++) cout<<s[i]<<endl;\n\t\n\tfor(i=1;i<=n;i++) for(j=1;j<=n;j++) ri[i][j]=M;\n\tfor(i=0;i<m;i++) ri[a[i]][b[i]]=l[i],ri[b[i]][a[i]]=l[i];\n/*\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=n;j++)cout<<ri[i][j]<<' ';\n\t\tcout<<endl;\n\t}*/\n\t\n\tmx=0;\n\tint leng[3001];\n\tfor(i=1;i<=n;i++) leng[i]=M;\n\tfor(i=0;i<k;i++){\n\t\tleng[s[i]]=0;\n\t\tque.push(P(0,s[i]));\n\t}\n\twhile(!que.empty()){\n\t\tP p=que.top();\n\t\tque.pop();\n\t\tint v=p.second;\n\t\tif(leng[v]<p.first) continue;\n\t\tfor(j=1;j<=n;j++){\n\t\t\tt=leng[v]+ri[v][j];\n//\t\t\tcout<<j<<' '<<leng[j]<<' '<<t<<endl;\n\t\t\tif(leng[j]>t){\n\t\t\t\tleng[j]=t;\n//\t\t\t\tcout<<leng[j]<<' '<<j<<endl;\n\t\t\t\tque.push(P(leng[j],j));\n\t\t\t}\n\t\t}\n\t}\n/*\tfor(i=1;i<=n;i++) cout<<leng[i]<<' ';\n\tcout<<endl;*/\n\tfor(i=1;i<=n;i++){\n\t\tint cnt=0,sum=0;\n\t\tfor(j=1;j<=n;j++){\n\t\t\tif(ri[i][j]!=M) cnt++,sum+=ri[i][j]+leng[j];\n\t\t}\n\t\tif(sum%cnt>=cnt/2) mx=max(mx,sum%cnt+1);\n\t\telse mx=max(mx,sum%cnt);\n\t}\n\t\n\tcout<<mx<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <queue>\n#include <vector>\n#include <functional>\n#include <math.h>\n\nusing namespace std;\nusing P = pair<int, int>;\n\nstruct edge { int to, cost; };\n\nconst int MAX_N = 3000;\n\nint dist[MAX_N + 1];\nvector<edge>graph[MAX_N + 1];\n\nint n, m, k;\n\nvoid dijkstra()\n{\n\tfor (int i = 0; i <= n; ++i)dist[i] = 123456789;\n\tdist[0] = 0;\n\tpriority_queue<P, vector<P>, greater<P>>que;\n\tque.push(make_pair(0, 0));\n\twhile (!que.empty())\n\t{\n\t\tP u = que.top(); que.pop();\n\t\tif (dist[u.second] < u.first)continue;\n\t\tfor (edge e : graph[u.second])\n\t\t{\n\t\t\tint alt = u.first + e.cost;\n\t\t\tif (dist[e.to] > alt)\n\t\t\t{\n\t\t\t\tdist[e.to] = alt;\n\t\t\t\tque.push(make_pair(alt, e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tint a, b, l;\n\t\tscanf(\"%d %d %d\", &a, &b, &l);\n\t\tgraph[a].push_back({ b,l });\n\t\tgraph[b].push_back({ a,l });\n\t}\n\tfor (int i = 0; i < k; ++i)\n\t{\n\t\tint s;\n\t\tscanf(\"%d\", &s);\n\t\tgraph[0].push_back({ s,0 });\n\t}\n\tdijkstra();\n\tint ans = 0;\n\tfor (int v = 1; v <= n; ++v)\n\t{\n\t\tfor (edge e : graph[v])\n\t\t{\n\t\t\tint u = e.to;\n\t\t\tint cost = e.cost;\n\t\t\tint a = min(dist[u], dist[v]);\n\t\t\tint b = max(dist[u], dist[v]);\n\t\t\tans = max(ans, (int)round((b - a + cost) / 2.0) + a);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 3002\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nvector<P> G[N];\nbool num[N];\nint n,m,K;\n\ndouble dijkstra(){\n  int D[N];\n  for(int i=0;i<N;i++) D[i] = 1e9;\n  \n  vector<int>pre[N];\n  priority_queue<PP,vector<PP>,greater<PP> >Q;\n  \n  for(int i=0;i<N;i++)\n    if(num[i]) {\n      Q.push(PP(0,P(i,i)));\n      D[i] = 0;\n    }\n\n  \n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first;\n    int pos = t.second.first;\n    int start = t.second.second;\n\n    \n    if(D[pos]<cost) continue;\n    pre[pos].push_back(start);\n    if(pre[pos].size()>=2) continue;\n    \n    \n    for(int i=0;i<G[pos].size();i++){\n      int npos = G[pos][i].first;\n      int ncost = cost+G[pos][i].second;\n      if(D[npos]<ncost) continue;\n      Q.push(PP(ncost,P(npos,start)));\n      D[npos] = ncost;\n    }\n  }\n\n  double res = 0;\n  for(int i=0;i<n;i++){\n    if(pre[i].size()>=2)res = max(res,(double)D[i]);\n    res = max(res,D[i]/2.0);\n    \n    for(int j=0;j<G[i].size();j++){\n      int npos = G[i][j].first;\n      int ncost = G[i][j].second;\n      if(pre[npos][0] == pre[i][0] && abs(D[i]-D[npos])==ncost)continue;\n\n      res = max(res,(D[i]+D[npos]+ncost)/2.0);\n    }\n  }\n  return res;\n  \n}\n\nint main(){\n  \n  cin>>n>>m>>K;\n  for(int i=0,a,b,c;i<m;i++){\n    cin>>a>>b>>c;\n    G[a-1].push_back(P(b-1,c));\n    G[b-1].push_back(P(a-1,c));\n  }\n\n  for(int i=0,a;i<K;i++)cin>>a,num[a-1]=1;\n  printf(\"%d\\n\",(int)(dijkstra()+0.5));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <deque>\n#include <vector>\nusing namespace std;\n\nint road[1000001][3];\nint main() {\n\tint N,M,K;\n\tvector<pair<int,int> >nGo[3001];\n\tdeque<int> dis;\n\tint dist[3001];\n\tint signer[3001];\n\tfor(int i=1;i<=3000;i++)\n\t\tdist[i]=(1 << 30 );\n\tcin >> N >> M >> K;\n\tint a,b,c;\n\tfor(int i=0;i<M;i++){\n\t\tcin >> a >> b >> c;\n\t\tnGo[a].push_back(pair<int,int>(b,c));\n\t\tnGo[b].push_back(pair<int,int>(a,c));\n\t\troad[i][0]=a;\n\t\troad[i][1]=b;\n\t\troad[i][2]=c;\n\t}\n\tfor(int i=0;i<K;i++){\n\t\tcin >> a;\n\t//\tdis.insert(multimap<int,int>::value_type(0,a));\n\t\tdis.push_back(a);\n\t\tdist[a]=0;\n\t}\n\twhile(!dis.empty()){\n\t\tint miner=0;\n\t\tfor(int i=0;i<dis.size();i++)\n\t\tminer=(dist[dis[miner]]<dist[dis[i]]) ? miner:i;\n\t\tint r=dis[miner];\n\t\tdis[miner]=dis[0];\n\t\tdis[0]=r;\n\t\tint now=dis[0];\n\t\tfor(int i=0;i<nGo[now].size();i++){\n\t\t\tif(dist[nGo[now][i].first]>dist[now]+nGo[now][i].second){\n\t\t\t\tif(signer[nGo[now][i].first]==0){\n\t\t\t\tdis.push_back(nGo[now][i].first);\n\t\t\t\tsigner[nGo[now][i].first]=1;\n\t\t\t\t}\n\t\t\t\tdist[nGo[now][i].first]=dist[now]+nGo[now][i].second;\n\t\t\t}\n\t\t}\n\t\tdis.pop_front();\n\t}\n\tint maxer=0;\n\tfor(int i=0;i<M;i++)\n\tmaxer=max(maxer,(dist[road[i][0]]+dist[road[i][1]]+road[i][2]+1)/2);\n\tfor(int i=1;i<=N;i++)\n\tmaxer=max(maxer,dist[i]);\n\tcout << maxer <<  endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<cstdio>\n#include<cmath>\n#define INF 500000000\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n,m,k;\nint l[100100],a[100100],b[100100];\nvector<P> g[5000];\nint d[5000],w[5000];\nint s[5000];\n\nint main(){\n  cin >> n >> m >> k;\n  for(int i=0;i<m;i++){\n    cin >> a[i] >> b[i] >> l[i];\n    a[i]--; b[i]--;\n    g[a[i]].push_back(P(l[i],b[i]));\n    g[b[i]].push_back(P(l[i],a[i]));\n  }\n \n  for(int i=0;i<k;i++){cin >> s[i]; s[i]--;}\n\n  for(int i=0;i<n;i++)d[i] = INF;\n  priority_queue<P,vector<P>,greater<P> > q;\n  for(int i=0;i<k;i++){\n    d[s[i]] = 0;\n    q.push(P(0,s[i]));\n  }\n\n  while(q.size()){\n    P p = q.top(); q.pop();\n    int cost = p.first, pos = p.second;\n    \n    for(int i=0;i<(int)g[pos].size();i++){\n      int dis = cost + g[pos][i].first;\n      int next = g[pos][i].second;\n      \n      if(dis<d[next]){\n\td[next] = dis;\n\tq.push(P(dis,next));\n      }\n    }\n  }\n\n  double ans = 0.0;\n  for(int i=0;i<m;i++){\n    if(fabs(d[a[i]] - d[b[i]]) >= l[i]){\n      ans = max(ans,(double)max(d[a[i]],d[b[i]]));\n    }else{\n      ans = max(ans,(double)(l[i]+d[a[i]]+d[b[i]])/2);\n    }\n  }\n  cout << (int)(ans+1e-9+0.5) << endl;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <climits>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <functional>\nusing namespace std;\ntypedef pair<int, int> P;\nstruct edge { int to, cost; };\nvector<edge> G[3000];\nint mind[3000];\nint d[3000];\nint n, m, k;\nvoid dijkstra(int s) {\n    fill(d, d+n, INT_MAX);\n    d[s]=0;\n    priority_queue<P, vector<P>, greater<P> > que;\n    que.push(P(0,s));\n    while (!que.empty()) {\n        P p=que.top(); que.pop();\n        int v=p.second;\n        if (d[v]<p.first) continue;\n        for (int i=0; i<G[v].size(); i++) {\n            edge e=G[v][i];\n            if (d[e.to]>d[v]+e.cost) {\n                d[e.to]=d[v]+e.cost;\n                que.push(P(d[e.to],e.to));\n            }\n        }\n    }\n    for (int i=0; i<n; i++) mind[i]=min(mind[i],d[i]);\n}\nint main() {\n    scanf(\"%d%d%d\",&n,&m,&k);\n    fill(mind, mind+n, INT_MAX);\n    for (int i=0; i<m; i++) {\n        int a, b, l; scanf(\"%d%d%d\",&a,&b,&l);\n        G[a-1].push_back((edge){b-1,l});\n        G[b-1].push_back((edge){a-1,l});\n    }\n    for (int i=0; i<k; i++) {\n        int s; scanf(\"%d\",&s);\n        dijkstra(s-1);\n    }\n    int res=0;\n    for (int i=0; i<n; i++) {\n        for (int j=0; j<G[i].size(); j++) {\n            edge e=G[i][j];\n            res=max(res,(mind[i]+mind[e.to]+e.cost+1)/2);\n        }\n    }\n    printf(\"%d\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n#define MP make_pair\n#define PB push_back\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) \n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P) \n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P) \n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s; }\n\n\n\ntemplate<class T> struct Edge {\n    int from, to;\n    T cost;\n    Edge(int f, int t, T c) : from(f), to(t), cost(c) {}\n    friend bool operator < (const Edge &e1, const Edge &e2) {return e1.cost < e2.cost;}\n    friend bool operator > (const Edge &e1, const Edge &e2) {return e1.cost > e2.cost;}\n    friend ostream& operator << (ostream& s, const Edge<T>& E) {\n        return s << E.from << \"->\" << E.to << '(' << E.cost << ')';\n    }\n};\n\nconst int MAX_V = 3300;\ntemplate<class T> struct Graph {\n    int V;\n    vector<Edge<T> > list[MAX_V];\n    \n    Graph(int n = 0) : V(n) {}\n    void init(int n = 0) {V = n; for (int i = 0; i < MAX_V; ++i) list[i].clear();}\n    inline vector<Edge<T> >& operator [] (int i) {return list[i];}\n    \n    void connect(int f, int t, T c) {\n        list[f].push_back(Edge<T>(f,t,c));\n        list[t].push_back(Edge<T>(t,f,c));\n    }\n    \n    friend ostream& operator << (ostream& s, const Graph& G) {\n        s << endl; for (int i = 0; i < G.V; ++i) {s << i << \" : \" << G.list[i] << endl;}return s;\n    }\n};\n\nGraph<int> G;\n\n\n\nint V, E, K;\nint a, b, w;\n\nconst int INF = 1<<29;\nint dist[MAX_V];\n\nint main() {\n    while (cin >> V >> E >> K) {\n        int s = 0;\n        G.init(V+1);\n        for (int i = 0; i < E; ++i) {\n            cin >> a >> b >> w;\n            G.connect(a, b, w);\n        }\n        for (int i = 0; i < K; ++i) {\n            cin >> a;\n            G.connect(s, a, 0);\n        }\n        \n        for (int i = 0; i < MAX_V; ++i) dist[i] = INF;\n        dist[s] = 0;\n        priority_queue< pair<int,int>, vector<pair<int,int> >, greater<pair<int,int> > > que;\n        que.push( pint(0,s) );\n        \n        while (!que.empty()) {\n            pint pp = que.top(); que.pop();\n            int v = pp.second, d = pp.first;\n            \n            if (dist[v] > d) continue;\n            for (int i = 0; i < G[v].size(); ++i) {\n                int to = G[v][i].to;\n                if ( chmin(dist[to], dist[v] + G[v][i].cost) ) {\n                    que.push( pint(dist[to], to) );\n                }\n            }\n        }\n        \n        int res = -1;\n        for (int i = 1; i <= V; ++i) {\n            for (int j = 0; j < G[i].size(); ++j) {\n                int a = i, b = G[i][j].to;\n                int tmp = (dist[a] + dist[b] + G[i][j].cost + 1) / 2;\n                chmax(res, tmp);\n            }\n        }\n        \n        cout << res << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define INF 0x40000000\n\nclass Edge {\npublic:\n    int from;\n    int to;\n    int len;\n};\n\nclass Vertex {\npublic:\n    vector<Edge*> children;\n};\n\nVertex vs[3000];\nEdge es[20000];\nint n, m, k;\nvector<int> malls;\nint direction[3000];\nint to_mall[3000];\n\nint main() {\n   float max_d;\n\n   scanf(\"%d %d %d\", &n, &m, &k);\n   for (int i=0; i<m; i++) {\n       int a, b, l;\n\n       scanf(\"%d %d %d\", &a, &b, &l);\n       --a;\n       --b;\n       es[i*2].from = a;\n       es[i*2].to = b;\n       es[i*2].len = l;\n       es[i*2+1].from = b;\n       es[i*2+1].to = a;\n       es[i*2+1].len = l;\n       vs[a].children.push_back(&es[i*2]);\n       vs[b].children.push_back(&es[i*2+1]);\n   }\n\n   for (int i=0; i<k; i++) {\n       int s;\n\n       scanf(\"%d\", &s);\n       --s;\n       malls.push_back(s);\n   }\n\n   for (int i=0; i<n; i++) {\n       int min_d;\n       priority_queue<P, vector<P>, greater<P> > q;\n\n       fill(direction, direction+n, INF);\n\n       direction[i] = 0;\n       q.push(make_pair(i, 0));\n       while (!q.empty()) {\n           P p = q.top(); q.pop();\n           int s = p.first;\n\n           if (direction[s] < p.second) continue;\n           for (int j=0; j < vs[s].children.size(); j++) {\n               Edge *e = vs[s].children[j];\n               if (direction[e->to] > direction[s] + e->len) {\n                   direction[e->to] = direction[s] + e->len;\n                   q.push(make_pair(e->to, direction[e->to]));\n               }\n           }\n       }\n\n       to_mall[i] = -1;\n       for (int j=0; j < malls.size(); j++) {\n           int t = malls[j];\n\n           if (to_mall[i] == -1 || to_mall[i] > direction[t]) {\n               to_mall[i] = direction[t];\n           }\n       }\n   }\n\n   max_d = 0;\n   for (int i=0; i<m; i++) {\n       int a = es[i*2].from;\n       int b = es[i*2].to;\n       int l = es[i*2].len;\n       float d = (to_mall[a] + to_mall[b] + l) / 2.0;\n\n       if (d > max_d) {\n           max_d = d;\n       }\n   }\n\n   printf(\"%d\\n\", (int)ceil(max_d));\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\nusing namespace std;\ntypedef pair<int,int> P;\n#define mp make_pair\n#define pb push_back\n#define INF 1000000000\nstruct edge\n{\n  int to,cost;\n  edge(int a,int b):to(a),cost(b){}\n};\nvector<edge> PP[3005];\nint d[3005];\nint ep[3005];\nint V;\nint E;\nint C;\nvoid dijkstra(int s)\n{\n  priority_queue<P,vector<P>,greater<P> >pque;\n  fill(d,d+V,INF);\n  pque.push(mp(0,s));\n  d[s]=0;\n  while(!pque.empty())\n    {\n      P p=pque.top();\n      pque.pop();\n      if(d[p.second]<p.first)\n\t{\n\t  continue;\n\t}\n      for(int i=0;i<PP[p.second].size();i++)\n\t{\n\t  P a=p;\n\t  if(d[PP[a.second][i].to]>d[a.second]+PP[a.second][i].cost){\n\t    d[PP[a.second][i].to]=d[a.second]+PP[a.second][i].cost;\n\t    pque.push(mp(d[PP[a.second][i].to],PP[a.second][i].to));\n\t  }\n\t}\n    }\n}\n\nint main()\n{\n  scanf(\"%d %d %d\",&V,&E,&C);\n  for(int i=0;i<E;i++)\n    {\n      int a,b,c;\n      scanf(\"%d %d %d\",&a,&b,&c);\n      a--;\n      b--;\n      PP[a].pb(edge(b,c));\n      PP[b].pb(edge(a,c));\n    }\n  fill(ep,ep+V,INF);\n  for(int i=0;i<C;i++)\n    {\n      int we;\n      scanf(\"%d\",&we);\n      dijkstra(we-1);\n      for(int j=0;j<V;j++)\n\t{\n\t  ep[j]=min(ep[j],d[j]);\n\t}\n    }\n  int rp=0;\n  for(int i=0;i<V;i++)\n    {\n      for(int j=0;j<PP[i].size();j++)\n\t{\n\t  rp=max(rp,(ep[i]+ep[PP[i][j].to]+1+PP[i][j].cost)/2);\n\t}\n\n    }\n\n  printf(\"%d\\n\",rp);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int inf = 1e9 + 9;\n\nint cost[3000][3000];\nint d[3000];\nbool used[3000];\nbool f[3000][3000];\nvector<int> pre[3000];\n\nint n, m, k;\n\nvoid dijkstra(int s)\n{\n  memset(used, false, sizeof(used));\n  d[s] = 0;\n\n  while (true){\n    int v = -1;\n\n    for (int u = 0; u < n; u++)\n      if (!used[u] && (v == -1 || d[u] < d[v])) v = u;\n    \n    if (v == -1) break;\n    used[v] = true;\n\n    for (int u = 0; u < n; u++){\n      if (d[u] == d[v] + cost[v][u]){\n        pre[u].push_back(v);\n      }\n      if (d[u] > d[v] + cost[v][u]){\n        d[u] = d[v] + cost[v][u];\n        pre[u].clear();\n        pre[u].push_back(v);\n      }\n    }\n  }\n}\n\nvoid dfs(int v)\n{\n  for (int i = 0; i < pre[v].size(); i++){\n    int u = pre[v][i];\n    if (!f[u][v]) continue;\n    f[v][u] = f[u][v] = false;\n    dfs(u);\n  }\n}\n\nint main()\n{\n  for (int i = 0; i < 3000; i++)\n    for (int j = 0; j < 3000; j++)\n      cost[i][j] = inf;\n\n  cin >> n >> m >> k;\n  for (int i = 0; i < m; i++){\n    int a, b, l;\n    cin >> a >> b >> l;\n    a--; b--;\n    cost[a][b] = cost[b][a] = l;\n    f[a][b] = f[b][a] = true;\n  }\n\n  fill(d, d + n, inf);\n  for (int i = 0; i < k; i++){\n    int s;\n    cin >> s;\n    dijkstra(s - 1);\n  }\n\n  for (int i = 0; i < n; i++){\n    dfs(i);\n  }\n\n  /*\n  for (int i = 0; i < n; i++){\n    cout << d[i] << (i + 1 == n ? \"\\n\" : \" \");\n  }\n\n  for (int i = 0; i < n; i++){\n    for (int j = 0; j < n; j++){\n      cout << (f[i][j] ? \"t\" : \"f\") << (j + 1 == n ? \"\\n\" : \" \");\n    }\n  }\n  */\n\n  int ans = 0;\n  for (int i = 0; i < n; i++){\n    ans = max(ans, d[i]);\n  }\n\n  for (int i = 0; i < n; i++){\n    for (int j = i; j < n; j++){\n      if (f[i][j]){\n        ans = max(ans, max(d[i], d[j]) + (int)round((cost[i][j] - abs(d[i] - d[j])) / 2.0));\n      }\n    }\n  }\n\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<cstdio>\n#include<cmath>\n#include<stack>\n#define F first\n#define S second\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef vector<P> VP;\ntypedef vector<int> VI;\ntypedef vector<VP> VVP;\ntypedef vector<VI> VVI;\nclass Pox\n{\npublic:\n  int cost,now;\n  Pox():cost(0),now(0){}\n  Pox(int now,int cost):now(now),cost(cost){}\n};\n\nclass ope{\npublic:\n  bool operator() (Pox a,Pox b)\n  {\n    return a.cost > b.cost;\n  }\n};\n\nconst int INF = (1<<28);\nint N,M,K;\nVVP G;\nVI mincost;\n//map<P,int> D;\n\nint main()\n{\n  scanf(\"%d %d %d\",&N,&M,&K);\n  G.resize(N),mincost.resize(N);\n  for(int i=0;i<N;i++)\n      mincost[i] = INF;\n\n  for(int i=0;i<M;i++)\n    {\n      int a,b,c;\n      scanf(\"%d %d %d\",&a,&b,&c);\n      a--,b--;\n      G[a].push_back(P(b,c));\n      G[b].push_back(P(a,c));\n      //D[P(a,b)] = D[P(b,a)] = c;\n    }\n\n  priority_queue<Pox,vector<Pox>,ope> Q;\n  for(int i=0;i<K;i++)\n    {\n      int a;\n      scanf(\"%d\",&a);\n      a--;\n      Q.push(Pox(a,0));\n      mincost[a] = 0;\n    }\n\n  while(!Q.empty())\n    {\n      Pox pox = Q.top(); Q.pop();\n      int now = pox.now;\n      int total = pox.cost;\n\n      for(int i=0;i<G[now].size();i++)\n\t{     \n\t  P p = G[now][i];\n\t  int to = p.F;\n\t  int cost = p.S;\n\t  if(mincost[to] <= total + cost)\n\t    continue;\n\n\t  mincost[to] = total + cost;\n\t  Q.push(Pox(to,total+cost));\n\t}\n    }\n\n\n  double mex = 0;\n  for(int i=0;i<N;i++)\n    for(int j=0;j<G[i].size();j++)\n\tif(j != i && mincost[G[i][j].F] != INF && mincost[i] != INF && mex < (double)(mincost[i]+mincost[G[i][j].F]+G[i][j].S/*D[P(i,j)]*/)/2.0)\n\t  mex = (double)(mincost[i]+mincost[G[i][j].F]+G[i][j].S/*D[P(i,j)]*/)/2.0;\n\t    \n\n  printf(\"%d\\n\",(int)round(mex));\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\nusing namespace std;\n#define INF (1<<24)\n#define MAX_N 3000\nstruct edge{\n  int from,to,cost;\n};\nstruct state{\n  int pos,cost;\n  bool operator < (const state &p)const{\n    return cost > p.cost;\n  }\n};\n\nvector<int> v;\nvector<edge> G[MAX_N],g;\nint N,M,K,d[MAX_N];\n\nvoid dijkstra(){\n  priority_queue< state > Q;\n  for(int i=0;i<MAX_N;i++)d[i]=INF;\n  for(int i=0;i<K;i++){\n    int w=v[i];\n    d[w]=0;\n    Q.push( (state){w,0} );\n  }\n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    if(s.cost>d[s.pos])continue;\n    for(int i=0;i<(int)G[s.pos].size();i++){\n      edge e=G[s.pos][i];\n      if(s.cost+e.cost>=d[e.to])continue;\n      d[e.to]=s.cost+e.cost;\n      Q.push( (state){e.to,d[e.to]} );\n    }\n  }\n}\n\nvoid solve(){\n  dijkstra();\n  double ans=0;\n  for(int i=0;i<(int)g.size();i++){\n    edge e=g[i];\n    double a=d[e.from],b=d[e.to],c=e.cost;\n    // a+x==b+c-x>>2x==b+c-a\n    double x =(b+c-a)*0.5;\n    ans=max(ans,a+x);\n  }\n  printf(\"%.0f\\n\",ans);\n}\n\nint main(){\n  cin>>N>>M>>K;\n  for(int i=0;i<M;i++){\n    int a,b,c;\n    cin>>a>>b>>c;\n    a--,b--;\n    g.push_back((edge){a,b,c});\n    G[a].push_back((edge){a,b,c});\n    G[b].push_back((edge){b,a,c});\n  }\n  for(int i=0;i<K;i++){\n    int a;\n    cin>>a;\n    a--;\n    v.push_back(a);\n  }\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <deque>\n#include <vector>\nusing namespace std;\n\nint main() {\n\tint N,M,K;\n\tvector<pair<int,int> >nGo[3001];\n\tdeque<int> dis;\n\tint dist[3001];\n\tint road[100000][3];\n\tfor(int i=1;i<=3000;i++)\n\t\tdist[i]=(1 << 30 );\n\tcin >> N >> M >> K;\n\tint a,b,c;\n\tfor(int i=0;i<M;i++){\n\t\tcin >> a >> b >> c;\n\t\tnGo[a].push_back(pair<int,int>(b,c));\n\t\tnGo[b].push_back(pair<int,int>(a,c));\n\t\troad[i][0]=a;\n\t\troad[i][1]=b;\n\t\troad[i][2]=c;\n\t}\n\tfor(int i=0;i<K;i++){\n\t\tcin >> a;\n\t//\tdis.insert(multimap<int,int>::value_type(0,a));\n\t\tdis.push_back(a);\n\t\tdist[a]=0;\n\t}\n\twhile(!dis.empty()){\n\t\tsort(dis.begin(),dis.end());\n\t\tint now=dis[0];\n\t\tfor(int i=0;i<nGo[now].size();i++){\n\t\t\tif(dist[nGo[now][i].first]>dist[now]+nGo[now][i].second){\n\t\t\t\tdis.push_back(nGo[now][i].first);\n\t\t\t\tdist[nGo[now][i].first]=dist[now]+nGo[now][i].second;\n\t\t\t}\n\t\t}\n\t\tdis.pop_front();\n\t}\n\tint maxer=0;\n\tfor(int i=0;i<M;i++)\n\tmaxer=max(maxer,(dist[road[i][0]]+dist[road[i][1]]+road[i][2]+1)/2);\n\tfor(int i=1;i<=N;i++)\n\tmaxer=max(maxer,dist[i]);\n\tcout << maxer <<  endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cmath>\n#include<functional>\n#include<utility>\n#define MP make_pair\nusing namespace std;\ntypedef pair<int, int> PII;\ntypedef vector<PII> VP;\ntypedef priority_queue<PII, VP, greater<PII> > LOWQ;\n\nint n, m, k;\nint a[100000], b[100000], l[100000];\nint s[3000];\n\nLOWQ stock;\nVP road[3001];\nbool checked[3001];\nbool shop[3001];\nint dist[3001];\n\nint ans = 0;\n\nvoid dijk()\n{\n  for(int i = 0; i < m; i++){\n    road[a[i]].push_back(MP(l[i], b[i]));\n    road[b[i]].push_back(MP(l[i], a[i]));\n  }\n  \n  for(int i = 0; i < k; i++){\n    stock.push(MP(0, s[i]));\n    checked[s[i]] = shop[s[i]] = true;\n  }\n\n  while(!stock.empty()){\n    PII now = stock.top();\n    stock.pop();\n    if(!checked[now.second] || (shop[now.second] && !now.first)){\n      checked[now.second] = true;\n      dist[now.second] = now.first;\n      for(int i = 0; i < road[now.second].size(); i++)\n\tif(!checked[road[now.second][i].second])\n\t  stock.push(MP(dist[now.first] + road[now.second][i].first, road[now.second][i].second));\n    }\n  }\n  return;\n}  \n\nint main()\n{\n  cin >> n >> m >> k;\n  for(int i = 0; i < m; i++)\n    cin >> a[i] >> b[i] >> l[i];\n  for(int i = 0; i < k; i++)\n    cin >> s[i];\n\n  dijk();\n \n  for(int i = 1; i <= n; i++)\n    ans = max(ans, dist[i]);\n\n  for(int i = 0; i < m; i++){\n    int diff = abs(dist[a[i]] - dist[b[i]]);\n    if(diff < l[i]){\n      int far = l[i] - diff;\n      if(far % 2)\n\tfar = far / 2 + 1;\n      else\n\tfar /= 2;\n\n      ans = max(ans, far + max(dist[a[i]], dist[b[i]]));\n    }\n  }\n\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define min(x,y) ((x<y)?x:y)\n#define Max(x,y) ((x>y)?x:y)\n#define INF 10000000\nint v[3005],sv[3005],u[3005];\nint s[3005],d[3005][3005];\nint main(){\n\tint i,j,k,n,m,x,y,z,ans;\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tfor(i=0;i<=n;i++){\n\t\tfor(j=0;j<=n;j++)d[i][j]=INF;\n\t\tv[i]=INF;\n\t\tu[i]=-1;\n\t}\n\tfor(i=0;i<m;i++){\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\td[x][y]=d[y][x]=z;\n\t}\n\tfor(i=0;i<k;i++){\n\t\tscanf(\"%d\",&y);\n\t\t//for(j=0;j<=n;j++)sv[j]=INF,u[j]=-1;\n\t\tv[y]=0;\n\t}\n\twhile(1){\n\t\tx=-1;\n\t\tfor(j=1;j<=n;j++){\n\t\t\tif(u[j]==-1 && (x==-1 || v[x]>v[j]))x=j;\n\t\t}\n\t\tif(x==-1)break;\n\t\tu[x]=0;\n\t\t//v[x]=min(v[x],sv[x]);\n\t\t//printf(\"s%d:%d\\n\",x,sv[x]);\n\t\tfor(j=1;j<=n;j++){\n\t\t\tv[j]=min(v[j],v[x]+d[x][j]);\n\t\t}\n\t}\n\t\n\tans=0;\n\tfor(i=1;i<=n;i++){\n\t\t//printf(\"%d:%d\\n\",i,v[i]);\n\t\tfor(j=1;j<=n;j++){\n\t\t\tif(v[i]!=INF && v[j]!=INF && d[i][j]!=INF)ans=Max(ans,(v[i]+v[j]+d[i][j]+1)/2);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "\n#include <stdio.h>\n\nstruct road{\n  int from;\n  int to;\n  int distance;\n};\n\nint calc_longest(int, int, int, int*, struct road*, int);\nvoid calc_shortestDistance(int, int, int, int*, struct road*, int, int*);\n\nint main(void)\n{\n  int N, M, K;\n  struct road roads[100000];\n  int mall[3001];\n  int max_distance;\n  int longest_d;\n  int i;\n\n  scanf(\"%d %d %d\", &N, &M, &K);\n  max_distance=0;\n  for(i=0; i<M; i++){\n    scanf(\"%d %d %d\", &roads[i].from, &roads[i].to, &roads[i].distance);\n    if(max_distance<roads[i].distance) max_distance=roads[i].distance;\n  }\n  for(i=0; i<K; i++){\n    scanf(\"%d\", &mall[i]);\n  }\n  \n  longest_d=calc_longest(N, M, K, mall, roads, max_distance);\n  printf(\"%d\\n\", longest_d);\n\n  return 0;\n}\n\nint calc_longest(int N, int M, int K, int* mall, struct road* roads, int max_distance)\n{\n  int i;\n  float longest_d, tmp_d;\n  int longest_int;\n  int d[3001];\n\n  for(i=1; i<=N; i++) d[i]=max_distance*(M+1);\n  calc_shortestDistance(N, M, K, mall, roads, max_distance, d);\n\n  longest_d=0.0f;\n  for(i=0; i<M; i++){\n    tmp_d=(float)(d[roads[i].from]+d[roads[i].to]+roads[i].distance);\n    tmp_d/=2.0f;\n    if(longest_d<tmp_d) longest_d=tmp_d;\n  }\n\n  longest_int=longest_d+0.5f;\n  return longest_int;\n}\n\nvoid calc_shortestDistance(int city_size, int n, int mall_size, int* mall, struct road* roads, int max_distance, int* d)\n{\n  int is_searched[3001]; //0:is not searched, 1:is searched.\n  int min_d, min_city;\n  int i;\n\n  for(i=1; i<=city_size; i++) is_searched[i]=0;\n  for(i=1; i<=city_size; i++) d[i]=max_distance*n+1;\n  for(i=0; i<mall_size; i++) d[mall[i]]=0;\n\n  while(1){\n    min_d=max_distance*n+1;\n    for(i=1; i<=city_size; i++){\n      if(!is_searched[i] && d[i]<min_d){\n\tmin_d=d[i];\n\tmin_city=i;\n      }\n    }\n    if(min_d==max_distance*n+1) break;\n\n    for(i=0; i<n; i++){\n      if(roads[i].from==min_city){\n\tif(d[roads[i].to]>min_d+roads[i].distance) d[roads[i].to]=min_d+roads[i].distance;\n      }\n      else if(roads[i].to==min_city){\n\tif(d[roads[i].from]>min_d+roads[i].distance) d[roads[i].from]=min_d+roads[i].distance;\n      }\n    }\n    is_searched[min_city]=1;\n  }\n\n  return;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define NODE (3000)\n#define INF (100000000)\n\nint v[NODE + 1];\nint dist[NODE + 1];\nint w[NODE + 1][NODE + 1];\n\nint n, m, k;\n\nint max(int a, int b)\n{\n    return (a > b ? a : b);\n}\n\nvoid dijkstra(int start)\n{\n    int i, j;\n    int node;\n    \n    for (i = 1; i <= n; i++){\n        v[i] = 0;\n    }\n    \n    dist[start] = 0;\n    \n    while (1){\n        node = -1;\n        for (i = 1; i <= n; i++){\n            if (v[i] == 0 && (node == -1 || dist[node] > dist[i])){\n                node = i;\n            }\n        }\n        \n        if (node == -1){\n            break;\n        }\n        \n        v[node] = 1;\n        \n        for (i = 1; i <= n; i++){\n            if (dist[i] > dist[node] + w[node][i] && v[i] == 0){\n                dist[i] = dist[node] + w[node][i];\n            }\n        }\n    }\n}\n\nint main(void)\n{\n    int i, j;\n    int from, to, cost, res;\n    \n    scanf(\"%d%d%d\", &n, &m, &k);\n    \n    for (i = 1; i <= n; i++){\n        dist[i] = INF;\n        for (j = 1; j <= n; j++){\n            w[i][j] = INF;\n            if (i == j){\n                w[i][j] = 0;\n            }\n        }\n    }\n    \n    for (i = 1; i <= m; i++){\n        scanf(\"%d%d%d\", &from, &to, &cost);\n        w[from][to] = w[to][from] = cost;\n    }\n    for (i = 1; i <= k; i++){\n        scanf(\"%d\", &from);\n        dijkstra(from);\n    }\n    \n    res = 0;\n    \n    for (i = 1; i <= n; i++){\n        for (j = 1; j <= n; j++){\n            if (w[i][j] != INF){\n                res = max(res, (w[i][j] + dist[i] + dist[j] + 1) / 2);\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", res);\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define min(x,y) ((x<y)?x:y)\n#define Max(x,y) ((x>y)?x:y)\n#define INF 10000000\nint v[3005],sv[3005],u[3005];\nint s[3005],d[3005][3005];\nint main(){\n\tint i,j,k,n,m,x,y,z,ans;\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tfor(i=0;i<=n;i++){\n\t\tfor(j=0;j<=n;j++)d[i][j]=INF;\n\t\tv[i]=INF;\n\t}\n\tfor(i=0;i<m;i++){\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\td[x][y]=d[y][x]=z;\n\t}\n\tfor(i=0;i<k;i++){\n\t\tscanf(\"%d\",&y);\n\t\tfor(j=0;j<=n;j++)sv[j]=INF,u[j]=-1;\n\t\tsv[y]=0;\n\t\twhile(1){\n\t\t\tx=-1;\n\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\tif(u[j]==-1 && (x==-1 || sv[x]>sv[j]))x=j;\n\t\t\t}\n\t\t\tif(x==-1)break;\n\t\t\tu[x]=0;\n\t\t\tv[x]=min(v[x],sv[x]);\n\t\t\t//printf(\"s%d:%d\\n\",x,sv[x]);\n\t\t\tfor(j=1;j<=n;j++){\n\t\t\t\tsv[j]=min(sv[j],sv[x]+d[x][j]);\n\t\t\t}\n\t\t}\n\t}\n\tans=0;\n\tfor(i=1;i<=n;i++){\n\t\t//printf(\"%d:%d\\n\",i,v[i]);\n\t\tfor(j=1;j<=n;j++){\n\t\t\tif(v[i]!=INF && v[j]!=INF && d[i][j]!=INF)ans=Max(ans,(v[i]+v[j]+d[i][j]+1)/2);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "\n#include <stdio.h>\n\nstruct road{\n  int from;\n  int to;\n  int distance;\n};\n\nint min(int p, int q)\n{\n  if(p<q) return p;\n  else return q;\n}\nint calc_longest(int, int, int, int*, struct road*, int);\n\nint d[3001][3001][3];\n\nint main(void)\n{\n  int N, M, K;\n  struct road roads[100000];\n  int mall[3001];\n  int max_distance;\n  int longest_d;\n  int i;\n\n  scanf(\"%d %d %d\", &N, &M, &K);\n  max_distance=0;\n  for(i=0; i<M; i++){\n    scanf(\"%d %d %d\", &roads[i].from, &roads[i].to, &roads[i].distance);\n    if(max_distance<roads[i].distance) max_distance=roads[i].distance;\n  }\n  for(i=0; i<K; i++){\n    scanf(\"%d\", &mall[i]);\n  }\n  \n  longest_d=calc_longest(N, M, K, mall, roads, max_distance);\n  printf(\"%d\\n\", longest_d);\n\n  return 0;\n}\n\nint calc_longest(int N, int M, int K, int* mall, struct road* roads, int max_distance)\n{\n  int i, j, l;\n  float longest_d, tmp_d;\n  int longest_int;\n  int shortest_d[3001];\n  int current, prev;\n\n  for(i=1; i<=N; i++){\n    for(j=1; j<=N; j++){\n      for(l=0; l<3; l++){\n\td[i][j][l]=max_distance*(M+1);\n      }\n    }\n  }\n  for(i=0; i<M; i++){\n    d[roads[i].from][roads[i].to][0]=roads[i].distance;\n    d[roads[i].to][roads[i].from][0]=roads[i].distance;\n  }\n  for(i=0; i<K; i++){\n    for(j=0; j<K; j++){\n      d[mall[i]][mall[j]][0]=0; d[mall[j]][mall[i]][0]=0;\n    }\n  }\n\n  prev=0;\n  current=1;\n  for(l=1; l<=N; l++){\n    for(i=1; i<=N; i++){\n      for(j=1; j<=N; j++){\n\td[i][j][current]=min(d[i][j][prev], d[i][l][prev]+d[l][j][prev]);\n      }\n    }\n    prev=current;\n    current=3-prev;\n  }\n\n  for(i=1; i<=N; i++){\n    shortest_d[i]=max_distance*(M+1);\n    for(j=0; j<K; j++){\n      if(shortest_d[i]>d[i][mall[j]][prev]) shortest_d[i]=d[i][mall[j]][prev];\n    }\n  }\n\n  longest_d=0.0f;\n  for(i=0; i<M; i++){\n    tmp_d=(float)(shortest_d[roads[i].from]+shortest_d[roads[i].to]+roads[i].distance);\n    tmp_d/=2.0f;\n    if(longest_d<tmp_d) longest_d=tmp_d;\n  }\n\n  longest_int=longest_d+0.5f;\n  return longest_int;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <string.h>\n#define mem(x,y)\t\t(x*)malloc(sizeof(x)*(y))\n#define PI 3.14159265358979\n\nint list_sort(const void* a,const void* b)\n{\n\tif((*(int**)a)[0] > (*(int**)b)[0])\n\t{\n\t\treturn 1;\n\t}\n\telse if((*(int**)a)[0] == (*(int**)b)[0])\n\t{\n\t\tif((*(int**)a)[1] > (*(int**)b)[1])\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse if((*(int**)a)[1] == (*(int**)b)[1])\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}\n\nvoid dijkstra(int** list,int*** road,int* score,int m,int n,int s)\n{\n\tint len;\n\tif(s == (n-1))\n\t{\n\t\tlen = road[0]+m-road[s];\n\t}\n\telse\n\t{\n\t\tlen = road[s+1]-road[s];\n\t}\n\tint i;\n\tfor(i = 0;i < len;i++)\n\t{\n\t\tint sc = score[road[s][i][1]];\n\t\tif(sc > score[s]+road[s][i][2] || sc == -1)\n\t\t{\n\t\t\tscore[road[s][i][1]] = score[s]+road[s][i][2];\n\t\t\tdijkstra(list,road,score,m,n,road[s][i][1]);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint m,n,k;\n\tint** list;\n\tint*** road;\n\tint* score;\n\tint i,j;\n\tdouble longest;\n\tscanf(\"%d %d %d\",&n,&m,&k);\n\tscore = mem(int,n);\n\troad = mem(int**,n);\n\tfor(i = 0;i < n;i++)\n\t{\n\t\tscore[i] = -1;\n\t}\n\tlist = mem(int*,2*m);\n\tfor(i = 0;i < m;i++)\n\t{\n\t\tlist[i] = mem(int,3);\n\t\tlist[i+m] = mem(int,3);\n\t\tscanf(\"%d %d %d\",&list[i][0],&list[i][1],&list[i][2]);\n\t\tlist[i+m][0] = --list[i][1];\n\t\tlist[i+m][1] = --list[i][0];\n\t\tlist[i+m][2] = list[i][2];\n\t}\n\tqsort(list,m*2,sizeof(int*),list_sort);\n\tj = 0;\n\tfor(i = 0;i < n;i++)\n\t{\n\t\troad[i] = list+j;\n\t\twhile(j < m*2 && list[j][0] == i)j++;\n\t}\n\tfor(i = 0;i < k;i++)\n\t{\n\t\tint s;\n\t\tscanf(\"%d\",&s);\n\t\tscore[s-1] = 0;\n\t}\n\tfor(i = 0;i < n;i++)\n\t{\n\t\tdijkstra(list,road,score,2*m,n,i);\n\t}\n\tlongest = 0;\n\tfor(i = 0;i < m*2;i++)\n\t{\n\t\tint val = score[list[i][0]]+score[list[i][1]]+list[i][2];\n\t\tif(val > longest*2)\n\t\t{\n\t\t\tlongest = (double)val/2.0;\n\t\t}\n\t}\n\tint num = floor(longest+0.5);\n\tprintf(\"%d\\n\",num);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint map[3000][3000];\nint kyori[3000];\nint douro[100000][3];\n\nint main(void) {\n\tint smalls[3000];\n\tint tyousataisyou[3000];\n\tint visited[3000];\n\tint currentkyori[3000];\n\tint tyousataisyounum;\n\tint matinum;\n\tint douronum;\n\tint smallnum;\n\tint dourolen;\n\tint i,j,k,ii;\n\tint from,to;\n\tint smallpos;\n\tint visits;\n\tint mincost,mincostto;\n\tint maxkyori;\n\tint nowkyori;\n\tint maekyori;\n\tscanf(\"%d %d %d\",&matinum,&douronum,&smallnum);\n\tfor(i=0;i<douronum;i++) {\n\t\tscanf(\"%d %d %d\",&from,&to,&dourolen);\n\t\tdouro[i][0]=from-1;\n\t\tdouro[i][1]=to-1;\n\t\tdouro[i][2]=dourolen;\n\t\tmap[from-1][to-1]=dourolen;\n\t\tmap[to-1][from-1]=dourolen;\n\t}\n\tfor(i=0;i<smallnum;i++)scanf(\"%d\",&smalls[i]);\n\tfor(i=0;i<matinum;i++)kyori[i]=0x7fffffff;\n\tmemset(visited,0,sizeof(visited));\n\tfor(ii=0;ii<matinum;ii++)currentkyori[ii]=0x7fffffff;\n\tfor(i=0;i<smallnum;i++) {\n\t\tsmallpos=smalls[i]-1;\n\t\tkyori[smallpos]=0;\n\t\tvisited[smallpos]=1;\n\t\tcurrentkyori[smallpos]=0;\n\t\ttyousataisyou[i]=smallpos;\n\t}\n\ttyousataisyounum=smallnum;\n\tvisits=smallnum;\n\twhile(visits<matinum) {\n\t\tmincost=0x7fffffff;\n\t\tmincostto=-1;\n\t\tfor(j=0;j<tyousataisyounum;j++) {\n\t\t\tfor(k=0;k<matinum;k++) {\n\t\t\t\tif(map[tyousataisyou[j]][k]>0) {\n\t\t\t\t\tif(currentkyori[k]>currentkyori[tyousataisyou[j]]+\n\t\t\t\t\t\t\tmap[tyousataisyou[j]][k]) {\n\t\t\t\t\t\tif(mincost>currentkyori[tyousataisyou[j]]+\n\t\t\t\t\t\t\t\tmap[tyousataisyou[j]][k]) {\n\t\t\t\t\t\t\tmincost=currentkyori[tyousataisyou[j]]+\n\t\t\t\t\t\t\t\tmap[tyousataisyou[j]][k];\n\t\t\t\t\t\t\tmincostto=k;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(mincostto>=0) {\n\t\t\tif(visited[mincostto]==0) {\n\t\t\t\ttyousataisyou[tyousataisyounum]=mincostto;\n\t\t\t\ttyousataisyounum++;\n\t\t\t}\n\t\t\tcurrentkyori[mincostto]=mincost;\n\t\t\tvisited[mincostto]=1;\n\t\t\tif(kyori[mincostto]>currentkyori[mincostto])kyori[mincostto]=mincost;\n\t\t\tvisits++;\n\t\t}\n\t}\n\tmaxkyori=0;\n\tfor(i=0;i<douronum;i++) {\n\t\tnowkyori=kyori[douro[i][0]];\n\t\tif(nowkyori<kyori[douro[i][1]]) {\n\t\t\tmaekyori=nowkyori;\n\t\t\tnowkyori=kyori[douro[i][1]];\n\t\t} else maekyori=kyori[douro[i][1]];\n\t\tif(maekyori+douro[i][2]>nowkyori) {\n\t\t\tnowkyori=((douro[i][2]+nowkyori-maekyori)*5+5)/10;\n\t\t\tnowkyori+=maekyori;\n\t\t}\n\t\tif(maxkyori<nowkyori)maxkyori=nowkyori;\n\t}\n\tprintf(\"%d\\n\",maxkyori);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define NODE (3000)\n#define INF (100000000)\n\nint v[NODE + 1];\nint dist[NODE + 1];\nint w[NODE + 1][NODE + 1];\n\nint n, m, k;\n\nint max(int a, int b)\n{\n    return (a > b ? a : b);\n}\n\nvoid dijkstra(int start)\n{\n    int i, j;\n    int node;\n    \n    for (i = 1; i <= n; i++){\n        v[i] = 0;\n    }\n    \n    dist[start] = 0;\n    \n    while (1){\n        node = -1;\n        for (i = 1; i <= n; i++){\n            if (v[i] == 0 && (node == -1 || dist[node] > dist[i])){\n                node = i;\n            }\n        }\n        \n        if (node == -1){\n            break;\n        }\n        \n        v[node] = 1;\n        \n        for (i = 1; i <= n; i++){\n            if (dist[i] > dist[node] + w[node][i] && v[i] == 0){\n                dist[i] = dist[node] + w[node][i];\n            }\n        }\n    }\n}\n\nint main(void)\n{\n    int i, j;\n    int from, to, cost, res;\n    \n    scanf(\"%d%d%d\", &n, &m, &k);\n    \n    for (i = 1; i <= n; i++){\n        dist[i] = INF;\n        for (j = 1; j <= n; j++){\n            w[i][j] = INF;\n            if (i == j){\n                w[i][j] = 0;\n            }\n        }\n    }\n    \n    for (i = 1; i <= m; i++){\n        scanf(\"%d%d%d\", &from, &to, &cost);\n        w[from][to] = w[to][from] = cost;\n    }\n    for (i = 1; i <= k; i++){\n        scanf(\"%d\", &from);\n        dist[from] = 0;\n    }\n    dijkstra(from);\n    res = 0;\n    \n    for (i = 1; i <= n; i++){\n        for (j = i + 1; j <= n; j++){\n            if (w[i][j] != INF){\n                res = max(res, (w[i][j] + dist[i] + dist[j] + 1) / 2);\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", res);\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <string.h>\n#define mem(x,y)\t\t(x*)malloc(sizeof(x)*(y))\n#define PI 3.14159265358979\n\nint list_sort(const void* a,const void* b)\n{\n\tif((*(int**)a)[0] > (*(int**)b)[0])\n\t{\n\t\treturn 1;\n\t}\n\telse if((*(int**)a)[0] == (*(int**)b)[0])\n\t{\n\t\tif((*(int**)a)[1] > (*(int**)b)[1])\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse if((*(int**)a)[1] == (*(int**)b)[1])\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}\n\nvoid dijkstra(int** list,int*** road,int* score,int m,int n,int s,double* longest)\n{\n\tint len;\n\tif(s == (n-1))\n\t{\n\t\tlen = road[0]+m-road[s];\n\t}\n\telse\n\t{\n\t\tlen = road[s+1]-road[s];\n\t}\n\tint i;\n\tfor(i = 0;i < len;i++)\n\t{\n\t\tint sc = score[road[s][i][1]];\n\t\tif(sc > score[s]+road[s][i][2] || sc == -1)\n\t\t{\n\t\t\tscore[road[s][i][1]] = score[s]+road[s][i][2];\n\t\t\tdijkstra(list,road,score,m,n,road[s][i][1],longest);\n\t\t}\n\t\telse if(sc > score[s]-road[s][i][2] && (((sc+score[s]+road[s][i][2])/2.0)>*longest))\n\t\t{\n\t\t\t*longest = (sc+score[s]+road[s][i][2])/2.0;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint m,n,k;\n\tint** list;\n\tint*** road;\n\tint* score;\n\tint i,j;\n\tdouble longest;\n\tscanf(\"%d %d %d\",&n,&m,&k);\n\tscore = mem(int,n);\n\troad = mem(int**,n);\n\tfor(i = 0;i < n;i++)\n\t{\n\t\tscore[i] = -1;\n\t}\n\tlist = mem(int*,2*m);\n\tfor(i = 0;i < m;i++)\n\t{\n\t\tlist[i] = mem(int,3);\n\t\tlist[i+m] = mem(int,3);\n\t\tscanf(\"%d %d %d\",&list[i][0],&list[i][1],&list[i][2]);\n\t\tlist[i+m][0] = --list[i][1];\n\t\tlist[i+m][1] = --list[i][0];\n\t\tlist[i+m][2] = list[i][2];\n\t}\n\tqsort(list,m*2,sizeof(int*),list_sort);\n\tj = 0;\n\tfor(i = 0;i < n;i++)\n\t{\n\t\troad[i] = list+j;\n\t\twhile(j < m*2 && list[j][0] == i)j++;\n\t}\n\tfor(i = 0;i < k;i++)\n\t{\n\t\tint s;\n\t\tscanf(\"%d\",&s);\n\t\tscore[s-1] = 0;\n\t}\n\tlongest = 0;\n\tfor(i = 0;i < n;i++)\n\t{\n\t\tdijkstra(list,road,score,2*m,n,i,&longest);\n\t}\n\tint num = floor(longest+0.5);\n\tprintf(\"%d\\n\",num);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct road{\n  int from;\n  int to;\n  int distance;\n};\n\nint min(int a, int b)\n{\n  if(a<b) return a;\n  else return b;\n}\nint calc_longest(int, int, int, int*, struct road*, int);\n\nstatic int d[3001][3001][3];\nint previndex, currentindex;\n\nint main(void)\n{\n  int N, M, K;\n  int i, j, l;\n  struct road roads[100000];\n  int mall[3001];\n  int maxdistance;\n  int nearest_d, tmp_d;\n\n  scanf(\"%d %d %d\", &N, &M, &K);\n  maxdistance=0;\n  for(i=0; i<M; i++){\n    scanf(\"%d %d %d\", &roads[i].from, &roads[i].to, &roads[i].distance);\n    if(maxdistance<roads[i].distance) maxdistance=roads[i].distance;\n  }\n  for(i=0; i<K; i++){\n    scanf(\"%d\", &mall[i]);\n  }\n  \n  for(i=1; i<=N; i++){\n    for(j=1; j<=N; j++){\n      if(i==j) d[i][j][0]=0;\n      else d[i][j][0]=maxdistance*(M+1);\n    }\n  }\n  for(i=0; i<M; i++){\n    d[roads[i].from][roads[i].to][0]=roads[i].distance;\n    d[roads[i].to][roads[i].from][0]=roads[i].distance;\n  }\n  \n  previndex=0;\n  currentindex=1;\n  for(l=1; l<=N; l++){\n    for(i=1; i<=N; i++){\n      for(j=1; j<=N; j++){\n\td[i][j][currentindex]=min(d[i][j][previndex], d[i][l][previndex]+d[l][j][previndex]);\n      }\n    }\n    previndex=currentindex;\n    currentindex=3-previndex;\n  }\n  nearest_d=calc_longest(N, M, K, mall, roads, maxdistance);\n  printf(\"%d\\n\", nearest_d);\n  \n  return 0;\n}\n\nint calc_longest(int N, int M, int K, int *mall, struct road *roads, int maxdistance)\n{\n  int i, j;\n  float longest_d, tmp_d;\n  int longest_int;\n  int nearest_d[3001], nearest_tmp;\n\n  for(i=1; i<=N; i++){\n    nearest_tmp=maxdistance*(M+1);\n    for(j=0; j<K; j++){\n      if(nearest_tmp>d[i][mall[j]][previndex]) nearest_tmp=d[i][mall[j]][previndex];\n    }\n    nearest_d[i]=nearest_tmp;\n  }\n\n  longest_d=0.0f;\n  for(i=1; i<=N; i++){\n    for(j=1; j<=N; j++){\n      if(i==j || d[i][j][0]==maxdistance*(M+1)) continue;\n      tmp_d=(float)(nearest_d[i]+nearest_d[j]+d[i][j][0]);\n      tmp_d/=2.0f;\n      if(longest_d<tmp_d) longest_d=tmp_d;\n    }\n  }\n  longest_int=longest_d+0.5f;\n  return longest_int;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint d[3000][3000]={0};\nint l[3000];\nint main(){\n  int n,m,k,min,mi,a,b,c,max,i,j;\n  double D;\n  scanf(\"%d %d %d\",&n,&m,&k);\n  for(i=0;i<n;i++)l[i]=2100000000;\n  while(m--){\n    scanf(\"%d %d %d\",&a,&b,&c);\n    a--;\n    b--;\n    d[a][b]=d[b][a]=c;\n  }//return 0;\n  while(k--){\n    char f[3000]={0};\n    scanf(\"%d\",&a);\n    a--;\n    l[mi=a]=0;\n    for(i=0;i<n;i++){\n      f[mi]=2;\n      for(j=0;j<n;j++){\n\tif(d[mi][j]==0||f[j]==2)continue;\n\tif(l[j]>l[mi]+d[mi][j]){\n\t  l[j]=l[mi]+d[mi][j];\n\t  f[j]=1;\n\t}\n      }\n      min=2100000000;\n      for(j=0;j<n;j++){\n\tif(f[j]!=1)continue;\n\tif(min>l[j])min=l[mi=j];\n      }\n      if(min==2100000000)break;\n    }\n  }\n  for(i=max=0;i<n;i++){//printf(\"%d %d\\n\",i+1,l[i]);\n    for(j=0;j<n;j++){\n      if(i==j)continue;//printf(\"%d %d\\n\",l[i],l[mi]);\n      D=(d[i][j]+l[i]+l[j])/2.0+0.5;//printf(\"%f\\n\",D);\n      if(max<D)max=D;\n    }\n  }\n  printf(\"%d\\n\",max);\n  return 0;\n}\n "
  },
  {
    "language": "C",
    "code": "\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct road{\n  int from;\n  int to;\n  int distance;\n};\n\nint min(int a, int b)\n{\n  if(a<b) return a;\n  else return b;\n}\nint calc_longest(int, int, int, int*, struct road*, int);\nint calc_shortestDistance(int, int, int, int, struct road*, int);\nint is_neighbor(int, int, int, struct road*);\n\nint main(void)\n{\n  int N, M, K;\n  int i, j, l;\n  struct road roads[100000];\n  int mall[3001];\n  int max_distance;\n  int nearest_d, tmp_d;\n\n  scanf(\"%d %d %d\", &N, &M, &K);\n  max_distance=0;\n  for(i=0; i<M; i++){\n    scanf(\"%d %d %d\", &roads[i].from, &roads[i].to, &roads[i].distance);\n    if(max_distance<roads[i].distance) max_distance=roads[i].distance;\n  }\n  for(i=0; i<K; i++){\n    scanf(\"%d\", &mall[i]);\n  }\n  \n  nearest_d=calc_longest(N, M, K, mall, roads, max_distance);\n  printf(\"%d\\n\", nearest_d);\n\n  return 0;\n}\n\nint calc_longest(int N, int M, int K, int *mall, struct road *roads, int max_distance)\n{\n  int i, j;\n  float longest_d, tmp_d;\n  int longest_int;\n  int nearest_d[3001], nearest_tmp;\n  int shortest_d;\n  int neighbor_d;\n\n  for(i=1; i<=N; i++){\n    nearest_tmp=max_distance*(M+1);\n    for(j=0; j<K; j++){\n      shortest_d=calc_shortestDistance(i, mall[j], N, M, roads, max_distance);\n      if(nearest_tmp>shortest_d) nearest_tmp=shortest_d;\n    }\n    nearest_d[i]=nearest_tmp;\n  }\n\n  longest_d=0.0f;\n  for(i=1; i<=N; i++){\n    for(j=1; j<=N; j++){\n      if(i==j || !(neighbor_d=is_neighbor(i, j, M, roads))) continue;\n      tmp_d=(float)(nearest_d[i]+nearest_d[j]+neighbor_d);\n      tmp_d/=2.0f;\n      if(longest_d<tmp_d) longest_d=tmp_d;\n    }\n  }\n  longest_int=longest_d+0.5f;\n  return longest_int;\n}\n\nint calc_shortestDistance(int from, int to, int city_size, int n, struct road* roads, int max_distance)\n{\n  int d[3001];\n  int is_searched[3001]; //0:is not searched, 1:is searched.\n  int min_d, min_city;\n  int i;\n\n  for(i=1; i<=city_size; i++) is_searched[i]=0;\n  for(i=1; i<=city_size; i++) d[i]=max_distance*n+1;\n  d[from]=0;\n\n  while(1){\n    min_d=max_distance*n+1;\n    for(i=1; i<=city_size; i++){\n      if(!is_searched[i] && d[i]<min_d){\n\tmin_d=d[i];\n\tmin_city=i;\n      }\n    }\n    if(min_city==to) break;\n\n    for(i=0; i<n; i++){\n      if(roads[i].from==min_city){\n\tif(d[roads[i].to]>min_d+roads[i].distance) d[roads[i].to]=min_d+roads[i].distance;\n      }\n      else if(roads[i].to==min_city){\n\tif(d[roads[i].from]>min_d+roads[i].distance) d[roads[i].from]=min_d+roads[i].distance;\n      }\n    }\n    is_searched[min_city]=1;\n  }\n\n  return d[to];\n}\n\nint is_neighbor(int from, int to, int M, struct road* roads)\n{\n  int i;\n  for(i=0; i<M; i++){\n    if(roads[i].from==from && roads[i].to==to) return roads[i].distance;\n    else if(roads[i].to==from && roads[i].from==to) return roads[i].distance;\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint d[3000][3000]={0};\nint l[3000];\nint main(){\n  int n,m,k,min,mi,a,b,c,max,Max,i,j;\n  double D;\n  scanf(\"%d %d %d\",&n,&m,&k);\n  for(i=0;i<n;i++)l[i]=2100000000;\n  while(m--){\n    scanf(\"%d %d %d\",&a,&b,&c);\n    a--;\n    b--;\n    d[a][b]=d[b][a]=c;\n  }//return 0;\n  while(k--){\n    char f[3000]={0};\n    scanf(\"%d\",&a);\n    a--;\n    l[mi=a]=0;\n    for(i=0;i<n;i++){\n      f[mi]=1;\n      for(j=0;j<n;j++){\n\tif(d[mi][j]==0||f[j])continue;\n\tif(l[j]>l[mi]+d[mi][j])l[j]=l[mi]+d[mi][j];\n      }\n      min=2100000000;\n      for(j=0;j<n;j++){\n\tif(f[j])continue;\n\tif(min>l[j])min=l[mi=j];\n      }\n    }\n  }\n  for(i=max=0;i<n;i++){printf(\"%d %d\\n\",i+1,l[i]);\n    if(max<l[i])max=l[mi=i];\n  }\n  for(i=Max=0;i<n;i++){\n    if(i==mi)continue;//printf(\"%d %d\\n\",l[i],l[mi]);\n    D=(d[mi][i]+l[i]+l[mi])/2.0+0.5;//printf(\"%f\\n\",D);\n    if(Max<D)Max=D;\n  }\n  printf(\"%d\\n\",Max);\n  return 0;\n}\n  \n "
  },
  {
    "language": "C",
    "code": "\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct road{\n  int from;\n  int to;\n  int distance;\n};\n\nint min(int a, int b)\n{\n  if(a<b) return a;\n  else return b;\n}\nint calc_longest(int, int, int, int*, struct road*, int);\n\nint d[3001][3001][3];\nint previndex, currentindex;\n\nint main(void)\n{\n  int N, M, K;\n  int i, j, l;\n  struct road roads[100000];\n  int mall[3001];\n  int maxdistance;\n  int nearest_d, tmp_d;\n\n  while(scanf(\"%d %d %d\", &N, &M, &K)){\n    maxdistance=0;\n    for(i=0; i<M; i++){\n      scanf(\"%d %d %d\", &roads[i].from, &roads[i].to, &roads[i].distance);\n      if(maxdistance<roads[i].distance) maxdistance=roads[i].distance;\n    }\n    for(i=0; i<K; i++){\n      scanf(\"%d\", &mall[i]);\n    }\n\n    for(i=1; i<=N; i++){\n      for(j=1; j<=N; j++){\n\tif(i==j) d[i][j][0]=0;\n\telse d[i][j][0]=maxdistance*(M+1);\n      }\n    }\n    for(i=0; i<M; i++){\n      d[roads[i].from][roads[i].to][0]=roads[i].distance;\n      d[roads[i].to][roads[i].from][0]=roads[i].distance;\n    }\n\n    previndex=0;\n    currentindex=1;\n    for(l=1; l<=N; l++){\n      for(i=1; i<=N; i++){\n\tfor(j=1; j<=N; j++){\n\t  d[i][j][currentindex]=min(d[i][j][previndex], d[i][l][previndex]+d[l][j][previndex]);\n\t}\n      }\n      previndex=currentindex;\n      currentindex=3-previndex;\n    }\n    nearest_d=calc_longest(N, M, K, mall, roads, maxdistance);\n    printf(\"%d\\n\", nearest_d);\n  }\n\n  return 0;\n}\n\nint calc_longest(int N, int M, int K, int *mall, struct road *roads, int maxdistance)\n{\n  int i, j;\n  float longest_d, tmp_d;\n  int longest_int;\n  int nearest_d[3001], nearest_tmp;\n\n  for(i=1; i<=N; i++){\n    nearest_tmp=maxdistance*(M+1);\n    for(j=0; j<K; j++){\n      if(nearest_tmp>d[i][mall[j]][previndex]) nearest_tmp=d[i][mall[j]][previndex];\n    }\n    nearest_d[i]=nearest_tmp;\n  }\n\n  longest_d=0.0f;\n  for(i=1; i<=N; i++){\n    for(j=1; j<=N; j++){\n      if(i==j || d[i][j][0]==maxdistance*(M+1)) continue;\n      tmp_d=(float)(nearest_d[i]+nearest_d[j]+d[i][j][0]);\n      tmp_d/=2.0f;\n      if(longest_d<tmp_d) longest_d=tmp_d;\n    }\n  }\n  longest_int=longest_d+0.5f;\n  return longest_int;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint d[3000][3000]={0};\nint l[3000];\nint main(){\n  int n,m,k,min,mi,a,b,c,max,i,j;\n  double D;\n  scanf(\"%d %d %d\",&n,&m,&k);\n  for(i=0;i<n;i++)l[i]=2100000000;\n  while(m--){\n    scanf(\"%d %d %d\",&a,&b,&c);\n    a--;\n    b--;\n    d[a][b]=d[b][a]=c;\n  }//return 0;\n  while(k--){\n    char f[3000]={0};\n    scanf(\"%d\",&a);\n    a--;\n    l[mi=a]=0;\n    for(i=0;i<n;i++){\n      f[mi]=2;\n      for(j=0;j<n;j++){\n\tif(d[mi][j]==0||f[j]==2)continue;\n\tif(l[j]>l[mi]+d[mi][j]){\n\t  l[j]=l[mi]+d[mi][j];\n\t  f[j]=1;\n\t}\n      }\n      min=2100000000;\n      for(j=0;j<n;j++){\n\tif(f[j]!=1)continue;\n\tif(min>l[j])min=l[mi=j];\n      }\n      if(min==2100000000)break;\n    }\n  }\n  for(i=max=0;i<n;i++){//printf(\"%d %d\\n\",i+1,l[i]);\n    for(j=0;j<n;j++){\n      if(i==j)continue;//printf(\"%d %d\\n\",l[i],l[mi]);\n      D=(d[i][j]+l[i]+l[j])/2.0+0.5;//printf(\"%f\\n\",D);\n      if(max<D)max=D;\n    }\n  }\n  printf(\"%d\\n\",max);\n  return 0;\n}\n  "
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint d[3000][3000]={0};\nint l[3000];\nint main(){\n  int n,m,k,min,mi,a,b,c,max,Max,i,j;\n  double D;\n  scanf(\"%d %d %d\",&n,&m,&k);\n  for(i=0;i<n;i++)l[i]=2100000000;\n  while(m--){\n    scanf(\"%d %d %d\",&a,&b,&c);\n    a--;\n    b--;\n    d[a][b]=d[b][a]=c;\n  }//return 0;\n  while(k--){\n    char f[3000]={0};\n    scanf(\"%d\",&a);\n    a--;\n    l[mi=a]=0;\n    for(i=0;i<n;i++){\n      f[mi]=1;\n      for(j=0;j<n;j++){\n\tif(d[mi][j]==0||f[j])continue;\n\tif(l[j]>l[mi]+d[mi][j])l[j]=l[mi]+d[mi][j];\n      }\n      min=2100000000;\n      for(j=0;j<n;j++){\n\tif(f[j])continue;\n\tif(min>l[j])min=l[mi=j];\n      }\n    }\n  }\n  for(i=max=0;i<n;i++){//printf(\"%d %d\\n\",i+1,l[i]);\n    if(max<l[i])max=l[mi=i];\n  }\n  for(i=Max=0;i<n;i++){\n    if(i==mi)continue;//printf(\"%d %d\\n\",l[i],l[mi]);\n    D=(d[mi][i]+l[i]+l[mi])/2.0+0.5;//printf(\"%f\\n\",D);\n    if(Max<D)Max=D;\n  }\n  printf(\"%d\\n\",Max);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint d[3000][3000]={0};\nint l[3000];\nint main(){\n  int n,m,k,min,mi,a,b,c,max,i,j;\n  double D;\n  scanf(\"%d %d %d\",&n,&m,&k);\n  for(i=0;i<n;i++)l[i]=2100000000;\n  while(m--){\n    scanf(\"%d %d %d\",&a,&b,&c);\n    a--;\n    b--;\n    d[a][b]=d[b][a]=c;\n  }//return 0;\n  while(k--){\n    char f[3000]={0};\n    scanf(\"%d\",&a);\n    a--;\n    l[mi=a]=0;\n    for(i=0;i<n;i++){\n      f[mi]=1;\n      for(j=0;j<n;j++){\n\tif(d[mi][j]==0||f[j])continue;\n\tif(l[j]>l[mi]+d[mi][j])l[j]=l[mi]+d[mi][j];\n      }\n      min=2100000000;\n      for(j=0;j<n;j++){\n\tif(f[j])continue;\n\tif(min>l[j])min=l[mi=j];\n      }\n    }\n  }\n  for(i=max=0;i<n;i++){//printf(\"%d %d\\n\",i+1,l[i]);\n    for(j=0;j<n;j++){\n      if(i==j)continue;//printf(\"%d %d\\n\",l[i],l[mi]);\n      D=(d[i][j]+l[i]+l[j])/2.0+0.5;//printf(\"%f\\n\",D);\n      if(max<D)max=D;\n    }\n  }\n  printf(\"%d\\n\",max);\n  return 0;\n}\n "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint map[3000][3000];\nint kyori[3000];\nint douro[100000][3];\n\nint main(void) {\n\tint smalls[3000];\n\tint visited[3000];\n\tint tyousataisyounum;\n\tint matinum;\n\tint douronum;\n\tint smallnum;\n\tint dourolen;\n\tint i,j,k;\n\tint from,to;\n\tint smallpos;\n\tint visits;\n\tint mincost,mincostto;\n\tint maxkyori;\n\tint nowkyori;\n\tint maekyori;\n\tscanf(\"%d %d %d\",&matinum,&douronum,&smallnum);\n\tfor(i=0;i<douronum;i++) {\n\t\tscanf(\"%d %d %d\",&from,&to,&dourolen);\n\t\tdouro[i][0]=from-1;\n\t\tdouro[i][1]=to-1;\n\t\tdouro[i][2]=dourolen;\n\t\tmap[from-1][to-1]=dourolen;\n\t\tmap[to-1][from-1]=dourolen;\n\t}\n\tfor(i=0;i<smallnum;i++)scanf(\"%d\",&smalls[i]);\n\tfor(i=0;i<matinum;i++)kyori[i]=0x7fffffff;\n\tmemset(visited,0,sizeof(visited));\n\tfor(i=0;i<smallnum;i++) {\n\t\tsmallpos=smalls[i]-1;\n\t\tkyori[smallpos]=0;\n\t\tvisited[smallpos]=1;\n\t}\n\ttyousataisyounum=smallnum;\n\tvisits=smallnum;\n\twhile(visits<matinum) {\n\t\tmincost=0x7fffffff;\n\t\tmincostto=-1;\n\t\tfor(j=0;j<matinum;j++) {\n\t\t\tif(visited[j]==0) {\n\t\t\t\tfor(k=0;k<matinum;k++) {\n\t\t\t\t\tif(!visited[k])continue;\n\t\t\t\t\tif(map[j][k]>0 && kyori[k]+map[j][k]<mincost) {\n\t\t\t\t\t\tmincost=kyori[k]+map[j][k];\n\t\t\t\t\t\tmincostto=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(mincostto>=0) {\n\t\t\tkyori[mincostto]=mincost;\n\t\t\tvisited[mincostto]=1;\n\t\t\tvisits++;\n\t\t}\n\t}\n\tmaxkyori=0;\n\tfor(i=0;i<douronum;i++) {\n\t\tnowkyori=kyori[douro[i][0]];\n\t\tif(nowkyori<kyori[douro[i][1]]) {\n\t\t\tmaekyori=nowkyori;\n\t\t\tnowkyori=kyori[douro[i][1]];\n\t\t} else maekyori=kyori[douro[i][1]];\n\t\tif(maekyori+douro[i][2]>nowkyori) {\n\t\t\tnowkyori=((douro[i][2]+nowkyori-maekyori)*5+5)/10;\n\t\t\tnowkyori+=maekyori;\n\t\t}\n\t\tif(maxkyori<nowkyori)maxkyori=nowkyori;\n\t}\n\tprintf(\"%d\\n\",maxkyori);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint map[3000][3000];\nint kyori[3000];\nint douro[100000][3];\n\nint main(void) {\n\tint smalls[3000];\n\tint visited[3000];\n\tint tyousataisyounum;\n\tint matinum;\n\tint douronum;\n\tint smallnum;\n\tint dourolen;\n\tint i,j,k;\n\tint from,to;\n\tint smallpos;\n\tint visits;\n\tint mincost,mincostto;\n\tint maxkyori;\n\tint nowkyori;\n\tint maekyori;\n\tscanf(\"%d %d %d\",&matinum,&douronum,&smallnum);\n\tfor(i=0;i<douronum;i++) {\n\t\tscanf(\"%d %d %d\",&from,&to,&dourolen);\n\t\tdouro[i][0]=from-1;\n\t\tdouro[i][1]=to-1;\n\t\tdouro[i][2]=dourolen;\n\t\tmap[from-1][to-1]=dourolen;\n\t\tmap[to-1][from-1]=dourolen;\n\t}\n\tfor(i=0;i<smallnum;i++)scanf(\"%d\",&smalls[i]);\n\tfor(i=0;i<matinum;i++)kyori[i]=0x7fffffff;\n\tmemset(visited,0,sizeof(visited));\n\tfor(i=0;i<smallnum;i++) {\n\t\tsmallpos=smalls[i]-1;\n\t\tkyori[smallpos]=0;\n\t\tvisited[smallpos]=1;\n\t}\n\ttyousataisyounum=smallnum;\n\tvisits=smallnum;\n\twhile(visits<matinum) {\n\t\tmincost=0x7fffffff;\n\t\tmincostto=-1;\n\t\tfor(j=0;j<matinum;j++) {\n\t\t\tif(visited[j]) {\n\t\t\t\tfor(k=0;k<matinum;k++) {\n\t\t\t\t\tif(visited[k])continue;\n\t\t\t\t\tif(map[j][k]>0 && kyori[j]+map[j][k]<mincost) {\n\t\t\t\t\t\tmincost=kyori[j]+map[j][k];\n\t\t\t\t\t\tmincostto=k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(mincostto>=0) {\n\t\t\tkyori[mincostto]=mincost;\n\t\t\tvisited[mincostto]=1;\n\t\t\tvisits++;\n\t\t}\n\t}\n\tmaxkyori=0;\n\tfor(i=0;i<douronum;i++) {\n\t\tnowkyori=kyori[douro[i][0]];\n\t\tif(nowkyori<kyori[douro[i][1]]) {\n\t\t\tmaekyori=nowkyori;\n\t\t\tnowkyori=kyori[douro[i][1]];\n\t\t} else maekyori=kyori[douro[i][1]];\n\t\tif(maekyori+douro[i][2]>nowkyori) {\n\t\t\tnowkyori=((douro[i][2]+nowkyori-maekyori)*5+5)/10;\n\t\t\tnowkyori+=maekyori;\n\t\t}\n\t\tif(maxkyori<nowkyori)maxkyori=nowkyori;\n\t}\n\tprintf(\"%d\\n\",maxkyori);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct road{\n  int from;\n  int to;\n  int distance;\n};\n\nstruct heap{\n  int index;\n  int d;\n};\n\nint calc_longest(int, int, int, int*, struct road*, int);\nvoid calc_shortestDistance(int, int, int, int*, struct road*, int, int*);\n\nstruct heap pop(void);\nint selectchild(int index);\nvoid push(struct heap node);\nint get_d(int ind);\nvoid update(int ind, struct heap node);\n\nstruct heap h[3001];\nint heapsize=0;\nint heapindex[3001];\n\nint main(void)\n{\n  int N, M, K;\n  int i, j, l;\n  struct road roads[100000];\n  int mall[3001];\n  int max_distance;\n  int nearest_d, tmp_d;\n\n  scanf(\"%d %d %d\", &N, &M, &K);\n  max_distance=0;\n  for(i=0; i<M; i++){\n    scanf(\"%d %d %d\", &roads[i].from, &roads[i].to, &roads[i].distance);\n    if(max_distance<roads[i].distance) max_distance=roads[i].distance;\n  }\n  for(i=0; i<K; i++){\n    scanf(\"%d\", &mall[i]);\n  }\n  \n  nearest_d=calc_longest(N, M, K, mall, roads, max_distance);\n  printf(\"%d\\n\", nearest_d);\n\n  return 0;\n}\n\nint calc_longest(int N, int M, int K, int *mall, struct road *roads, int max_distance)\n{\n  int i, j;\n  float longest_d, tmp_d;\n  int longest_int;\n  int nearest_d[3001], nearest_tmp;\n  int shortest_d;\n  int neighbor_d;\n\n  for(i=1; i<=N; i++) nearest_d[i]=max_distance*(M+1);\n  calc_shortestDistance(N, M, K, mall, roads, max_distance, nearest_d);\n\n  longest_d=0.0f;\n  for(i=0; i<M; i++){\n    tmp_d=(float)(nearest_d[roads[i].from]+nearest_d[roads[i].to]+roads[i].distance);\n    tmp_d/=2.0f;\n    if(longest_d<tmp_d) longest_d=tmp_d;\n  }\n\n  longest_int=longest_d+0.5f;\n  return longest_int;\n}\n\nvoid calc_shortestDistance(int city_size, int n, int K, int *mall, struct road* roads, int max_distance, int* d)\n{\n  struct heap node;\n  int min_d, min_city;\n  int count;\n  int i, j;\n\n  heapsize=0;\n  for(i=1; i<=city_size; i++){\n    node.d=max_distance*n+1;\n    for(j=0; j<K; j++){\n      if(i==mall[j]) node.d=0;\n    }\n    node.index=i;\n    push(node);\n  }\n\n  count=0;\n  while(count<city_size){\n    node=pop();\n    min_d=node.d;\n    min_city=node.index;\n    d[min_city]=min_d;\n\n    for(i=0; i<n; i++){\n      if(roads[i].from==min_city){\n\tif(get_d(roads[i].to)>min_d+roads[i].distance){\n\t  node.index=roads[i].to;\n\t  node.d=min_d+roads[i].distance;\n\t  update(roads[i].to, node);\n\t}\n      }\n      else if(roads[i].to==min_city){\n\tif(get_d(roads[i].from)>min_d+roads[i].distance){\n\t  node.index=roads[i].from;\n\t  node.d=min_d+roads[i].distance;\n\t  update(roads[i].from, node);\n\t}\n      }\n    }\n    count++;\n  }\n\n  return;\n}\n\nstruct heap pop(void)\n{\n  int index, child;\n  struct heap node, tmp_node;\n\n  node=h[1];\n  heapindex[node.index]=-1;\n  h[1]=h[heapsize];\n  heapsize--;\n  index=1;\n  heapindex[h[index].index]=1;\n  while((child=selectchild(index))>0){\n    if(h[child].d>=h[index].d) break;\n    tmp_node=h[child];\n    h[child]=h[index];\n    h[index]=tmp_node;\n    heapindex[tmp_node.index]=index;\n    index=child;\n    heapindex[h[index].index]=child;\n  }\n  return node;\n}\n\nint selectchild(int index)\n{\n  if(index*2>heapsize) return -1;\n  else if(index*2==heapsize) return index*2;\n  else {\n    if(h[index*2].d<=h[index*2+1].d) return index*2;\n    else return index*2+1;\n  }\n}\n\nvoid push(struct heap node)\n{\n  int index, parent;\n  struct heap tmp_node;\n\n  heapsize++;\n  h[heapsize]=node;\n  index=heapsize;\n  while((parent=index/2)>0){\n    if(h[parent].d<=h[index].d) break;\n    tmp_node=h[parent];\n    h[parent]=h[index];\n    h[index]=tmp_node;\n    heapindex[tmp_node.index]=index;\n    index=parent;\n  }\n  heapindex[node.index]=index;\n}\n\nint get_d(int ind)\n{\n  int index;\n\n  index=heapindex[ind];\n  if(index==-1) return -1;\n  else return h[heapindex[ind]].d;\n}\n\nvoid update(int ind, struct heap node)\n{\n  int index, parent;\n  int child;\n  struct heap tmp_node;\n\n  index=heapindex[ind];\n  h[index]=node;\n\n  while((parent=index/2)>0){\n    if(h[parent].d<=h[index].d) break;\n    tmp_node=h[parent];\n    h[parent]=h[index];\n    h[index]=tmp_node;\n    heapindex[tmp_node.index]=index;\n    index=parent;\n  }\n  heapindex[node.index]=index;\n\n  while((child=selectchild(index))>0){\n    if(h[child].d>=h[index].d) break;\n    tmp_node=h[child];\n    h[child]=h[index];\n    h[index]=tmp_node;\n    heapindex[tmp_node.index]=index;\n    index=child;\n    heapindex[h[index].index]=child;\n  }\n}"
  },
  {
    "language": "C",
    "code": "\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct road{\n  int from;\n  int to;\n  int distance;\n};\n\nint min(int a, int b)\n{\n  if(a<b) return a;\n  else return b;\n}\nint calc_longest(int, int, int, int*, struct road*, int);\n\nint ***d;\nint previndex, currentindex;\n\nint main(void)\n{\n  int N, M, K;\n  int i, j, l;\n  struct road roads[100000];\n  int mall[3001];\n  int maxdistance;\n  int nearest_d, tmp_d;\n\n  scanf(\"%d %d %d\", &N, &M, &K);\n  d=(int***)malloc(sizeof(int**)*(N+1));\n  for(i=1; i<=N; i++){\n    d[i]=(int**)malloc(sizeof(int*)*(N+1));\n    for(j=1; j<=N; j++){\n      d[i][j]=(int*)malloc(sizeof(int)*3);\n    }\n  }\n\n  maxdistance=0;\n  for(i=0; i<M; i++){\n    scanf(\"%d %d %d\", &roads[i].from, &roads[i].to, &roads[i].distance);\n    if(maxdistance<roads[i].distance) maxdistance=roads[i].distance;\n  }\n  for(i=0; i<K; i++){\n    scanf(\"%d\", &mall[i]);\n  }\n  \n  for(i=1; i<=N; i++){\n    for(j=1; j<=N; j++){\n      if(i==j) d[i][j][0]=0;\n      else d[i][j][0]=maxdistance*(M+1);\n    }\n  }\n  for(i=0; i<M; i++){\n    d[roads[i].from][roads[i].to][0]=roads[i].distance;\n    d[roads[i].to][roads[i].from][0]=roads[i].distance;\n  }\n  \n  previndex=0;\n  currentindex=1;\n  for(l=1; l<=N; l++){\n    for(i=1; i<=N; i++){\n      for(j=1; j<=N; j++){\n\td[i][j][currentindex]=min(d[i][j][previndex], d[i][l][previndex]+d[l][j][previndex]);\n      }\n    }\n    previndex=currentindex;\n    currentindex=3-previndex;\n  }\n  nearest_d=calc_longest(N, M, K, mall, roads, maxdistance);\n  printf(\"%d\\n\", nearest_d);\n\n  for(i=1; i<=N; i++){\n    for(j=1; j<=N; j++){\n      free(d[i][j]);\n    }\n    free(d[i]);\n  }\n  free(d);\n  return 0;\n}\n\nint calc_longest(int N, int M, int K, int *mall, struct road *roads, int maxdistance)\n{\n  int i, j;\n  float longest_d, tmp_d;\n  int longest_int;\n  int nearest_d[3001], nearest_tmp;\n\n  for(i=1; i<=N; i++){\n    nearest_tmp=maxdistance*(M+1);\n    for(j=0; j<K; j++){\n      if(nearest_tmp>d[i][mall[j]][previndex]) nearest_tmp=d[i][mall[j]][previndex];\n    }\n    nearest_d[i]=nearest_tmp;\n  }\n\n  longest_d=0.0f;\n  for(i=1; i<=N; i++){\n    for(j=1; j<=N; j++){\n      if(i==j || d[i][j][0]==maxdistance*(M+1)) continue;\n      tmp_d=(float)(nearest_d[i]+nearest_d[j]+d[i][j][0]);\n      tmp_d/=2.0f;\n      if(longest_d<tmp_d) longest_d=tmp_d;\n    }\n  }\n  longest_int=longest_d+0.5f;\n  return longest_int;\n}"
  },
  {
    "language": "C",
    "code": "\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct road{\n  int from;\n  int to;\n  int distance;\n};\n\nint min(int a, int b)\n{\n  if(a<b) return a;\n  else return b;\n}\nint calc_longest(int, int, int, int*, struct road*, int);\nvoid calc_shortestDistance(int, int, int, struct road*, int);\nint is_neighbor(int, int, int, struct road*);\n\nint d[3001];\n\nint main(void)\n{\n  int N, M, K;\n  int i, j, l;\n  struct road roads[100000];\n  int mall[3001];\n  int max_distance;\n  int nearest_d, tmp_d;\n\n  scanf(\"%d %d %d\", &N, &M, &K);\n  max_distance=0;\n  for(i=0; i<M; i++){\n    scanf(\"%d %d %d\", &roads[i].from, &roads[i].to, &roads[i].distance);\n    if(max_distance<roads[i].distance) max_distance=roads[i].distance;\n  }\n  for(i=0; i<K; i++){\n    scanf(\"%d\", &mall[i]);\n  }\n  \n  nearest_d=calc_longest(N, M, K, mall, roads, max_distance);\n  printf(\"%d\\n\", nearest_d);\n\n  return 0;\n}\n\nint calc_longest(int N, int M, int K, int *mall, struct road *roads, int max_distance)\n{\n  int i, j;\n  float longest_d, tmp_d;\n  int longest_int;\n  int nearest_d[3001], nearest_tmp;\n  int shortest_d;\n  int neighbor_d;\n\n  for(i=1; i<=N; i++) nearest_d[i]=max_distance*(M+1);\n  for(i=0; i<K; i++){\n    calc_shortestDistance(mall[i], N, M, roads, max_distance);\n    for(j=0; j<=N; j++){\n      if(nearest_d[j]>d[j]) nearest_d[j]=d[j];\n    }\n  }\n\n  longest_d=0.0f;\n  for(i=1; i<=N; i++){\n    for(j=1; j<=N; j++){\n      if(i==j || !(neighbor_d=is_neighbor(i, j, M, roads))) continue;\n      tmp_d=(float)(nearest_d[i]+nearest_d[j]+neighbor_d);\n      tmp_d/=2.0f;\n      if(longest_d<tmp_d) longest_d=tmp_d;\n    }\n  }\n  longest_int=longest_d+0.5f;\n  return longest_int;\n}\n\nvoid calc_shortestDistance(int from, int city_size, int n, struct road* roads, int max_distance)\n{\n  int is_searched[3001]; //0:is not searched, 1:is searched.\n  int min_d, min_city;\n  int count;\n  int i;\n\n  for(i=1; i<=city_size; i++) is_searched[i]=0;\n  for(i=1; i<=city_size; i++) d[i]=max_distance*n+1;\n  d[from]=0;\n\n  count=0;\n  while(count<city_size){\n    min_d=max_distance*n+1;\n    for(i=1; i<=city_size; i++){\n      if(!is_searched[i] && d[i]<min_d){\n\tmin_d=d[i];\n\tmin_city=i;\n      }\n    }\n\n    for(i=0; i<n; i++){\n      if(roads[i].from==min_city){\n\tif(d[roads[i].to]>min_d+roads[i].distance) d[roads[i].to]=min_d+roads[i].distance;\n      }\n      else if(roads[i].to==min_city){\n\tif(d[roads[i].from]>min_d+roads[i].distance) d[roads[i].from]=min_d+roads[i].distance;\n      }\n    }\n    is_searched[min_city]=1;\n    count++;\n  }\n\n  return;\n}\n\nint is_neighbor(int from, int to, int M, struct road* roads)\n{\n  int i;\n  for(i=0; i<M; i++){\n    if(roads[i].from==from && roads[i].to==to) return roads[i].distance;\n    else if(roads[i].to==from && roads[i].from==to) return roads[i].distance;\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct road{\n  int from;\n  int to;\n  int distance;\n};\n\nint min(int a, int b)\n{\n  if(a<b) return a;\n  else return b;\n}\nint calc_longest(int, int, int, int*, struct road*, int);\n\nint d[3001][3001][3];\nint previndex, currentindex;\n\nint main(void)\n{\n  int N, M, K;\n  int i, j, l;\n  struct road roads[100000];\n  int mall[3001];\n  int maxdistance;\n  int nearest_d, tmp_d;\n\n  //while(scanf(\"%d %d %d\", &N, &M, &K)){\n  scanf(\"%d %d %d\", &N, &M, &K);\n    maxdistance=0;\n    for(i=0; i<M; i++){\n      scanf(\"%d %d %d\", &roads[i].from, &roads[i].to, &roads[i].distance);\n      if(maxdistance<roads[i].distance) maxdistance=roads[i].distance;\n    }\n    for(i=0; i<K; i++){\n      scanf(\"%d\", &mall[i]);\n    }\n\n    for(i=1; i<=N; i++){\n      for(j=1; j<=N; j++){\n\tif(i==j) d[i][j][0]=0;\n\telse d[i][j][0]=maxdistance*(M+1);\n      }\n    }\n    for(i=0; i<M; i++){\n      d[roads[i].from][roads[i].to][0]=roads[i].distance;\n      d[roads[i].to][roads[i].from][0]=roads[i].distance;\n    }\n\n    previndex=0;\n    currentindex=1;\n    for(l=1; l<=N; l++){\n      for(i=1; i<=N; i++){\n\tfor(j=1; j<=N; j++){\n\t  d[i][j][currentindex]=min(d[i][j][previndex], d[i][l][previndex]+d[l][j][previndex]);\n\t}\n      }\n      previndex=currentindex;\n      currentindex=3-previndex;\n    }\n    nearest_d=calc_longest(N, M, K, mall, roads, maxdistance);\n    printf(\"%d\\n\", nearest_d);\n    //}\n\n  return 0;\n}\n\nint calc_longest(int N, int M, int K, int *mall, struct road *roads, int maxdistance)\n{\n  int i, j;\n  float longest_d, tmp_d;\n  int longest_int;\n  int nearest_d[3001], nearest_tmp;\n\n  for(i=1; i<=N; i++){\n    nearest_tmp=maxdistance*(M+1);\n    for(j=0; j<K; j++){\n      if(nearest_tmp>d[i][mall[j]][previndex]) nearest_tmp=d[i][mall[j]][previndex];\n    }\n    nearest_d[i]=nearest_tmp;\n  }\n\n  longest_d=0.0f;\n  for(i=1; i<=N; i++){\n    for(j=1; j<=N; j++){\n      if(i==j || d[i][j][0]==maxdistance*(M+1)) continue;\n      tmp_d=(float)(nearest_d[i]+nearest_d[j]+d[i][j][0]);\n      tmp_d/=2.0f;\n      if(longest_d<tmp_d) longest_d=tmp_d;\n    }\n  }\n  longest_int=longest_d+0.5f;\n  return longest_int;\n}"
  },
  {
    "language": "C",
    "code": "\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct road{\n  int from;\n  int to;\n  int distance;\n};\n\nint min(int a, int b)\n{\n  if(a<b) return a;\n  else return b;\n}\nint calc_longest(int, int, int, int*, struct road*, int);\nvoid calc_shortestDistance(int, int, int, struct road*, int);\n\nint d[3001];\n\nint main(void)\n{\n  int N, M, K;\n  int i, j, l;\n  struct road roads[100000];\n  int mall[3001];\n  int max_distance;\n  int nearest_d, tmp_d;\n\n  scanf(\"%d %d %d\", &N, &M, &K);\n  max_distance=0;\n  for(i=0; i<M; i++){\n    scanf(\"%d %d %d\", &roads[i].from, &roads[i].to, &roads[i].distance);\n    if(max_distance<roads[i].distance) max_distance=roads[i].distance;\n  }\n  for(i=0; i<K; i++){\n    scanf(\"%d\", &mall[i]);\n  }\n  \n  nearest_d=calc_longest(N, M, K, mall, roads, max_distance);\n  printf(\"%d\\n\", nearest_d);\n\n  return 0;\n}\n\nint calc_longest(int N, int M, int K, int *mall, struct road *roads, int max_distance)\n{\n  int i, j;\n  float longest_d, tmp_d;\n  int longest_int;\n  int nearest_d[3001], nearest_tmp;\n  int shortest_d;\n  int neighbor_d;\n\n  for(i=1; i<=N; i++) nearest_d[i]=max_distance*(M+1);\n  for(i=0; i<K; i++){\n    calc_shortestDistance(mall[i], N, M, roads, max_distance);\n    for(j=1; j<=N; j++){\n      if(nearest_d[j]>d[j]) nearest_d[j]=d[j];\n    }\n  }\n\n  longest_d=0.0f;\n  for(i=0; i<M; i++){\n    tmp_d=(float)(nearest_d[roads[i].from]+nearest_d[roads[i].to]+roads[i].distance);\n    tmp_d/=2.0f;\n    if(longest_d<tmp_d) longest_d=tmp_d;\n  }\n\n  longest_int=longest_d+0.5f;\n  return longest_int;\n}\n\nvoid calc_shortestDistance(int from, int city_size, int n, struct road* roads, int max_distance)\n{\n  int is_searched[3001]; //0:is not searched, 1:is searched.\n  int min_d, min_city;\n  int count;\n  int i;\n\n  for(i=1; i<=city_size; i++) is_searched[i]=0;\n  for(i=1; i<=city_size; i++) d[i]=max_distance*n+1;\n  d[from]=0;\n\n  count=0;\n  while(count<city_size){\n    min_d=max_distance*n+1;\n    for(i=1; i<=city_size; i++){\n      if(!is_searched[i] && d[i]<min_d){\n\tmin_d=d[i];\n\tmin_city=i;\n      }\n    }\n\n    for(i=0; i<n; i++){\n      if(roads[i].from==min_city){\n\tif(d[roads[i].to]>min_d+roads[i].distance) d[roads[i].to]=min_d+roads[i].distance;\n      }\n      else if(roads[i].to==min_city){\n\tif(d[roads[i].from]>min_d+roads[i].distance) d[roads[i].from]=min_d+roads[i].distance;\n      }\n    }\n    is_searched[min_city]=1;\n    count++;\n  }\n\n  return;\n}"
  },
  {
    "language": "C",
    "code": "\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct road{\n  int from;\n  int to;\n  int distance;\n};\n\nstruct heap{\n  int index;\n  int d;\n};\n\nint calc_longest(int, int, int, int*, struct road*, int);\nvoid calc_shortestDistance(int, int, int, struct road*, int, int*);\nstruct heap pop(void);\nint selectchild(int index);\nvoid push(struct heap node);\nint get_d(int ind);\nvoid update(int ind, struct heap node);\n\nstruct heap h[3001];\nint heapsize=0;\nint heapindex[3001];\n\nint main(void)\n{\n  int N, M, K;\n  int i, j, l;\n  struct road roads[100000];\n  int mall[3001];\n  int max_distance;\n  int nearest_d, tmp_d;\n\n  scanf(\"%d %d %d\", &N, &M, &K);\n  max_distance=0;\n  for(i=0; i<M; i++){\n    scanf(\"%d %d %d\", &roads[i].from, &roads[i].to, &roads[i].distance);\n    if(max_distance<roads[i].distance) max_distance=roads[i].distance;\n  }\n  for(i=0; i<K; i++){\n    scanf(\"%d\", &mall[i]);\n  }\n  \n  nearest_d=calc_longest(N, M, K, mall, roads, max_distance);\n  printf(\"%d\\n\", nearest_d);\n\n  /*struct heap node;\n  node.index=2;\n  node.d=1;\n  push(node);\n  node.index=3;\n  node.d=1;\n  push(node);\n  pop();\n\n  for(i=1; i<=heapsize; i++){\n    printf(\"(%d %d)\", h[i].index, h[i].d);\n  }\n  printf(\"\\n\");\n  */\n\n  return 0;\n}\n\nint calc_longest(int N, int M, int K, int *mall, struct road *roads, int max_distance)\n{\n  int i, j;\n  float longest_d, tmp_d;\n  int longest_int;\n  int d[3001];\n  int nearest_d[3001], nearest_tmp;\n  int shortest_d;\n  int neighbor_d;\n\n  for(i=1; i<=N; i++) nearest_d[i]=max_distance*(M+1);\n  for(i=0; i<K; i++){\n    calc_shortestDistance(mall[i], N, M, roads, max_distance, d);\n    for(j=1; j<=N; j++){\n      if(nearest_d[j]>d[j]) nearest_d[j]=d[j];\n    }\n  }\n\n  longest_d=0.0f;\n  for(i=0; i<M; i++){\n    tmp_d=(float)(nearest_d[roads[i].from]+nearest_d[roads[i].to]+roads[i].distance);\n    tmp_d/=2.0f;\n    if(longest_d<tmp_d) longest_d=tmp_d;\n  }\n\n  longest_int=longest_d+0.5f;\n  return longest_int;\n}\n\nvoid calc_shortestDistance(int from, int city_size, int n, struct road* roads, int max_distance, int* d)\n{\n  struct heap node;\n  int min_d, min_city;\n  int count;\n  int i;\n\n  heapsize=0;\n  for(i=1; i<=city_size; i++){\n    if(i==from) node.d=0;\n    else node.d=max_distance*n+1;\n    node.index=i;\n    push(node);\n  }\n\n  count=0;\n  while(count<city_size){\n    node=pop();\n    min_d=node.d;\n    min_city=node.index;\n    d[min_city]=min_d;\n\n    for(i=0; i<n; i++){\n      if(roads[i].from==min_city){\n\tif(get_d(roads[i].to)>min_d+roads[i].distance){\n\t  node.index=roads[i].to;\n\t  node.d=min_d+roads[i].distance;\n\t  update(roads[i].to, node);\n\t}\n      }\n      else if(roads[i].to==min_city){\n\tif(get_d(roads[i].from)>min_d+roads[i].distance){\n\t  node.index=roads[i].from;\n\t  node.d=min_d+roads[i].distance;\n\t  update(roads[i].from, node);\n\t}\n      }\n    }\n    count++;\n  }\n\n  return;\n}\n\nstruct heap pop(void)\n{\n  int index, child;\n  struct heap node, tmp_node;\n\n  node=h[1];\n  heapindex[node.index]=-1;\n  h[1]=h[heapsize];\n  heapsize--;\n  index=1;\n  heapindex[h[index].index]=1;\n  while((child=selectchild(index))>0){\n    if(h[child].d>=h[index].d) break;\n    tmp_node=h[child];\n    h[child]=h[index];\n    h[index]=tmp_node;\n    heapindex[tmp_node.index]=index;\n    index=child;\n    heapindex[h[index].index]=child;\n  }\n  return node;\n}\n\nint selectchild(int index)\n{\n  if(index*2>heapsize) return -1;\n  else if(index*2==heapsize) return index*2;\n  else {\n    if(h[index*2].d<=h[index*2+1].d) return index*2;\n    else return index*2+1;\n  }\n}\n\nvoid push(struct heap node)\n{\n  int index, parent;\n  struct heap tmp_node;\n\n  heapsize++;\n  h[heapsize]=node;\n  index=heapsize;\n  while((parent=index/2)>0){\n    if(h[parent].d<=h[index].d) break;\n    tmp_node=h[parent];\n    h[parent]=h[index];\n    h[index]=tmp_node;\n    heapindex[tmp_node.index]=index;\n    index=parent;\n  }\n  heapindex[node.index]=index;\n}\n\nint get_d(int ind)\n{\n  int index;\n\n  index=heapindex[ind];\n  if(index==-1) return -1;\n  else return h[heapindex[ind]].d;\n}\n\nvoid update(int ind, struct heap node)\n{\n  int index, parent;\n  int child;\n  struct heap tmp_node;\n\n  index=heapindex[ind];\n  h[index]=node;\n\n  while((parent=index/2)>0){\n    if(h[parent].d<=h[index].d) break;\n    tmp_node=h[parent];\n    h[parent]=h[index];\n    h[index]=tmp_node;\n    heapindex[tmp_node.index]=index;\n    index=parent;\n  }\n  heapindex[node.index]=index;\n\n  while((child=selectchild(index))>0){\n    if(h[child].d>=h[index].d) break;\n    tmp_node=h[child];\n    h[child]=h[index];\n    h[index]=tmp_node;\n    heapindex[tmp_node.index]=index;\n    index=child;\n    heapindex[h[index].index]=child;\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define NODE (3000)\n#define INF (100000000)\n\nint v[NODE + 1];\nint dist[NODE + 1];\nint w[NODE + 1][NODE + 1];\n\nint n, m, k;\n\nvoid dijkstra(int start)\n{\n    int i, j;\n    int mincost;\n    int node;\n    \n    for (i = 1; i <= n; i++){\n        v[i] = 0;\n    }\n    \n    dist[start] = 0;\n    \n    while (1){\n        mincost = -1;\n        for (i = 1; i <= n; i++){\n            if (v[i] == 0 && (mincost == -1 || mincost > dist[i])){\n                mincost = dist[i];\n                node = i;\n            }\n        }\n        \n        if (mincost == -1){\n            break;\n        }\n        \n        v[node] = 1;\n        \n        for (i = 1; i <= n; i++){\n            if (dist[i] > dist[node] + w[node][i] && v[i] == 0){\n                dist[i] = dist[node] + w[node][i];\n            }\n        }\n    }\n}\n\nint main(void)\n{\n    int i, j;\n    int from, to, cost, res;\n    \n    scanf(\"%d%d%d\", &n, &m, &k);\n    \n    for (i = 1; i <= n; i++){\n        dist[i] = INF;\n        for (j = 1; j <= n; j++){\n            w[i][j] = INF;\n            if (i == j){\n                w[i][j] = 0;\n            }\n        }\n    }\n    \n    for (i = 1; i <= m; i++){\n        scanf(\"%d%d%d\", &from, &to, &cost);\n        w[from][to] = w[to][from] = cost;\n    }\n    for (i = 1; i <= k; i++){\n        scanf(\"%d\", &from);\n        dijkstra(from);\n    }\n    \n    res = 0;\n    \n    for (i = 1; i <= n; i++){\n        if (dist[i] > res){\n            res = dist[i];\n        }\n    }\n    \n    printf(\"%d\\n\", res);\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "\n#include <stdio.h>\n\nstruct road{\n  int from;\n  int to;\n  int distance;\n};\n\nint min(int p, int q)\n{\n  if(p<q) return p;\n  else return q;\n}\nint calc_longest(int, int, int, int*, struct road*, int);\n\nint d[3001][3001][3];\n\nint main(void)\n{\n  int N, M, K;\n  struct road roads[100000];\n  int mall[3001];\n  int max_distance;\n  int longest_d;\n  int i;\n\n  scanf(\"%d %d %d\", &N, &M, &K);\n  max_distance=0;\n  for(i=0; i<M; i++){\n    scanf(\"%d %d %d\", &roads[i].from, &roads[i].to, &roads[i].distance);\n    if(max_distance<roads[i].distance) max_distance=roads[i].distance;\n  }\n  for(i=0; i<K; i++){\n    scanf(\"%d\", &mall[i]);\n  }\n  \n  longest_d=calc_longest(N, M, K, mall, roads, max_distance);\n  printf(\"%d\\n\", longest_d);\n\n  return 0;\n}\n\nint calc_longest(int N, int M, int K, int* mall, struct road* roads, int max_distance)\n{\n  int i, j, l;\n  float longest_d, tmp_d;\n  int longest_int;\n  int shortest_d[3001];\n  int current, prev;\n\n  for(i=1; i<=N; i++){\n    for(j=1; j<=N; j++){\n      for(l=0; l<3; l++){\n\td[i][j][l]=max_distance*(M+1);\n      }\n    }\n  }\n  for(i=0; i<M; i++){\n    d[roads[i].from][roads[i].to][0]=roads[i].distance;\n    d[roads[i].to][roads[i].from][0]=roads[i].distance;\n  }\n  /*for(i=0; i<K; i++){\n    for(j=0; j<K; j++){\n      d[mall[i]][mall[j]][0]=0; d[mall[j]][mall[i]][0]=0;\n    }\n  }\n  */\n\n  prev=0;\n  current=1;\n  for(l=1; l<=N; l++){\n    for(i=1; i<=N; i++){\n      for(j=1; j<=N; j++){\n\td[i][j][current]=min(d[i][j][prev], d[i][l][prev]+d[l][j][prev]);\n      }\n    }\n    prev=current;\n    current=3-prev;\n  }\n\n  for(i=1; i<=N; i++){\n    shortest_d[i]=max_distance*(M+1);\n    for(j=1; j<=N; j++){\n      if(shortest_d[i]>d[i][j][prev]) shortest_d[i]=d[i][j][prev];\n    }\n  }\n\n  longest_d=0.0f;\n  for(i=0; i<M; i++){\n    tmp_d=(float)(shortest_d[roads[i].from]+shortest_d[roads[i].to]+roads[i].distance);\n    tmp_d/=2.0f;\n    if(longest_d<tmp_d) longest_d=tmp_d;\n  }\n\n  longest_int=longest_d+0.5f;\n  return longest_int;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint d[3000][3000]={0};\nint l[3000];\nint main(){\n  int n,m,k,min,mi,a,b,c,max,i,j;\n  double D;\n  scanf(\"%d %d %d\",&n,&m,&k);\n  for(i=0;i<n;i++)l[i]=2100000000;\n  while(m--){\n    scanf(\"%d %d %d\",&a,&b,&c);\n    a--;\n    b--;\n    d[a][b]=d[b][a]=c;\n  }//return 0;\n  while(k--){\n    char f[3000]={0};\n    scanf(\"%d\",&a);\n    a--;\n    l[mi=a]=0;\n    for(i=0;i<n;i++){\n      f[mi]=2;\n      for(j=0;j<n;j++){\n\tif(d[mi][j]==0||f[j])continue;\n\tif(l[j]>l[mi]+d[mi][j]){\n\t  l[j]=l[mi]+d[mi][j];\n\t  f[j]=1;\n\t}\n      }\n      min=2100000000;\n      for(j=0;j<n;j++){\n\tif(f[j]!=1)continue;\n\tif(min>l[j])min=l[mi=j];\n      }\n      if(min==2100000000)break;\n    }\n  }\n  for(i=max=0;i<n;i++){//printf(\"%d %d\\n\",i+1,l[i]);\n    for(j=0;j<n;j++){\n      if(i==j)continue;//printf(\"%d %d\\n\",l[i],l[mi]);\n      D=(d[i][j]+l[i]+l[j])/2.0+0.5;//printf(\"%f\\n\",D);\n      if(max<D)max=D;\n    }\n  }\n  printf(\"%d\\n\",max);\n  return 0;\n}\n  \n  "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <string.h>\n#define mem(x,y)\t\t(x*)malloc(sizeof(x)*(y))\n#define PI 3.14159265358979\n\nint list_sort(const void* a,const void* b)\n{\n\tif((*(int**)a)[0] > (*(int**)b)[0])\n\t{\n\t\treturn 1;\n\t}\n\telse if((*(int**)a)[0] == (*(int**)b)[0])\n\t{\n\t\tif((*(int**)a)[1] > (*(int**)b)[1])\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\telse if((*(int**)a)[1] == (*(int**)b)[1])\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}\n\nvoid dijkstra(int** list,int*** road,int* score,int m,int n,int s)\n{\n\tint len;\n\tif(s == (n-1))\n\t{\n\t\tlen = road[0]+m-road[s];\n\t}\n\telse\n\t{\n\t\tlen = road[s+1]-road[s];\n\t}\n\tint i;\n\tfor(i = 0;i < len;i++)\n\t{\n\t\tint sc = score[road[s][i][1]];\n\t\tif(sc > score[s]+road[s][i][2] || sc == -1)\n\t\t{\n\t\t\tscore[road[s][i][1]] = score[s]+road[s][i][2];\n\t\t\tdijkstra(list,road,score,m,n,road[s][i][1]);\n\t\t}\n\t\telse if(sc < score[s]-road[s][i][2])\n\t\t{\n\t\t\tscore[s] = sc+road[s][i][2];\n\t\t\ti = -1;\n\t\t\tcontinue;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint m,n,k;\n\tint** list;\n\tint*** road;\n\tint* score;\n\tint i,j;\n\tdouble longest;\n\tscanf(\"%d %d %d\",&n,&m,&k);\n\tscore = mem(int,n);\n\troad = mem(int**,n);\n\tfor(i = 0;i < n;i++)\n\t{\n\t\tscore[i] = -1;\n\t}\n\tlist = mem(int*,2*m);\n\tfor(i = 0;i < m;i++)\n\t{\n\t\tlist[i] = mem(int,3);\n\t\tlist[i+m] = mem(int,3);\n\t\tscanf(\"%d %d %d\",&list[i][0],&list[i][1],&list[i][2]);\n\t\tlist[i+m][0] = --list[i][1];\n\t\tlist[i+m][1] = --list[i][0];\n\t\tlist[i+m][2] = list[i][2];\n\t}\n\tqsort(list,m*2,sizeof(int*),list_sort);\n\tj = 0;\n\tfor(i = 0;i < n;i++)\n\t{\n\t\troad[i] = list+j;\n\t\twhile(j < m*2 && list[j][0] == i)j++;\n\t}\n\tfor(i = 0;i < k;i++)\n\t{\n\t\tint s;\n\t\tscanf(\"%d\",&s);\n\t\tscore[s-1] = 0;\n\t}\n\tfor(i = 0;i < n;i++)\n\t{\n\t\tif(score[i] != -1)\n\t\t\tdijkstra(list,road,score,2*m,n,i);\n\t}\n\tlongest = 0;\n\tfor(i = 0;i < m*2;i++)\n\t{\n\t\tint val = score[list[i][0]]+score[list[i][1]]+list[i][2];\n\t\tif(val > longest*2)\n\t\t{\n\t\t\tlongest = (double)val/2.0;\n\t\t}\n\t}\n\tint num = floor(longest+0.5);\n\tprintf(\"%d\\n\",num);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0562: Shopping in JOI Kingdom\n// 2017.12.3 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 100005\ntypedef struct { int t, node; } QUE;\nQUE que[MAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int n, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].node = n, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\ntypedef struct { int to[300], w[300]; } TBL;\nTBL tbl[3002]; int len[3002];\nint dist[3002];\n\nchar buf[40], *p;\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nint main()\n{\n\tint n, m, k, i, a, b, w, t, ans;\n\n\tfgets(p=buf, 40, stdin);\n\tn = getint(), m = getint(), k = getint();\n\tfor (i = 0; i < m; i++) {\n\t\tfgets(p=buf, 40, stdin);\n\t\ta = getint()-1, b = getint()-1, w = getint();\n\t\tt = len[a], tbl[a].to[t] = b, tbl[a].w[t] = w, len[a]++;\n\t\tt = len[b], tbl[b].to[t] = a, tbl[b].w[t] = w, len[b]++;\n\t}\n\n\tmemset(dist, 0x33, sizeof(dist));\n\tqsize = 0;\n\twhile (k--) {\n\t\tfgets(p=buf, 40, stdin);\n\t\ta = getint()-1;\n\t\tdist[a] = 0;\n\t\tenq(a, 0);\n\t}\n\twhile (qsize) {\n\t\ta = que[0].node, w = que[0].t, deq();\n\t\tfor (i = 0; i < len[a]; i++) {\n\t\t\tb = tbl[a].to[i];\n\t\t\tw = dist[a] + tbl[a].w[i];\n\t\t\tif (w < dist[b]) dist[b] = w, enq(b, w);\n\t\t}\n\t}\n\n\tans = 0;\n\tfor (a = 0; a < n; a++) {\n\t\tfor (i = 0; i < len[a]; i++) {\n\t\t\tb = tbl[a].to[i];\n\t\t\tt = (dist[a] + dist[b] + tbl[a].w[i] + 1) >> 1;\n\t\t\tif (t > ans) ans = t;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0562: Shopping in JOI Kingdom\n// 2017.12.3 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 100005\ntypedef struct { int t, node; } QUE;\nQUE que[MAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int n, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].node = n, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\ntypedef struct { int to[150], w[150]; } TBL;\nTBL tbl[3002]; int len[3002];\nint dist[3002];\n\nchar buf[40], *p;\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nint main()\n{\n\tint n, m, k, i, a, b, w, t, ans;\n\n\tfgets(p=buf, 40, stdin);\n\tn = getint(), m = getint(), k = getint();\n\tfor (i = 0; i < m; i++) {\n\t\tfgets(p=buf, 40, stdin);\n\t\ta = getint()-1, b = getint()-1, w = getint();\n\t\tt = len[a], tbl[a].to[t] = b, tbl[a].w[t] = w, len[a]++;\n\t\tt = len[b], tbl[b].to[t] = a, tbl[b].w[t] = w, len[b]++;\n\t}\n\tt = 0;\n\n\tmemset(dist, 0x33, sizeof(dist));\n\tqsize = 0;\n\twhile (k--) {\n\t\tfgets(p=buf, 40, stdin);\n\t\ta = getint()-1;\n\t\tdist[a] = 0;\n\t\tenq(a, 0);\n\t}\n\twhile (qsize) {\n\t\ta = que[0].node, w = que[0].t, deq();\n\t\tfor (i = 0; i < len[a]; i++) {\n\t\t\tb = tbl[a].to[i];\n\t\t\tw = dist[a] + tbl[a].w[i];\n\t\t\tif (w < dist[b]) dist[b] = w, enq(b, w);\n\t\t}\n\t}\n\n\tans = 0;\n\tfor (a = 0; a < n; a++) {\n\t\tfor (i = 0; i < len[a]; i++) {\n\t\t\tb = tbl[a].to[i];\n\t\t\tt = (dist[a] + dist[b] + tbl[a].w[i] + 1) >> 1;\n\t\t\tif (t > ans) ans = t;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint map[3000][3000];\nint kyori[3000];\nint douro[100000][3];\n\nint main(void) {\n\tint smalls[3000];\n\tint visited[3000];\n\tint tyousataisyounum;\n\tint matinum;\n\tint douronum;\n\tint smallnum;\n\tint dourolen;\n\tint i;\n\tint from,to;\n\tint smallpos;\n\tint mincost,mincostto;\n\tint maxkyori;\n\tint nowkyori;\n\tint maekyori;\n\tscanf(\"%d %d %d\",&matinum,&douronum,&smallnum);\n\tfor(i=0;i<douronum;i++) {\n\t\tscanf(\"%d %d %d\",&from,&to,&dourolen);\n\t\tdouro[i][0]=from-1;\n\t\tdouro[i][1]=to-1;\n\t\tdouro[i][2]=dourolen;\n\t\tmap[from-1][to-1]=dourolen;\n\t\tmap[to-1][from-1]=dourolen;\n\t}\n\tfor(i=0;i<smallnum;i++)scanf(\"%d\",&smalls[i]);\n\tfor(i=0;i<matinum;i++)kyori[i]=0x7fffffff;\n\tmemset(visited,0,sizeof(visited));\n\tfor(i=0;i<smallnum;i++) {\n\t\tsmallpos=smalls[i]-1;\n\t\tkyori[smallpos]=0;\n\t\t//visited[smallpos]=1;\n\t}\n\ttyousataisyounum=smallnum;\n\twhile(1) {\n\t\tmincost=0x7fffffff;\n\t\tmincostto=-1;\n\t\tfor(i=0;i<matinum;i++) {\n\t\t\tif(!visited[i]) {\n\t\t\t\tif(kyori[i]<mincost) {\n\t\t\t\t\tmincost=kyori[i];\n\t\t\t\t\tmincostto=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(mincostto>=0) {\n\t\t\tvisited[mincostto]=1;\n\t\t\tfor(i=0;i<matinum;i++) {\n\t\t\t\tif(map[i][mincostto]>0) {\n\t\t\t\t\tif(kyori[i]>kyori[mincostto]+map[i][mincostto]) {\n\t\t\t\t\t\tkyori[i]=kyori[mincostto]+map[i][mincostto];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else break;\n\t}\n\tmaxkyori=0;\n\tfor(i=0;i<douronum;i++) {\n\t\tnowkyori=kyori[douro[i][0]];\n\t\tif(nowkyori<kyori[douro[i][1]]) {\n\t\t\tmaekyori=nowkyori;\n\t\t\tnowkyori=kyori[douro[i][1]];\n\t\t} else maekyori=kyori[douro[i][1]];\n\t\tif(maekyori+douro[i][2]>nowkyori) {\n\t\t\tnowkyori=((douro[i][2]+nowkyori-maekyori)*5+5)/10;\n\t\t\tnowkyori+=maekyori;\n\t\t}\n\t\tif(maxkyori<nowkyori)maxkyori=nowkyori;\n\t}\n\tprintf(\"%d\\n\",maxkyori);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "\n#include <stdio.h>\n\nstruct road{\n  int from;\n  int to;\n  int distance;\n};\n\nint min(int p, int q)\n{\n  if(p<q) return p;\n  else return q;\n}\nint calc_longest(int, int, int, int*, struct road*, int);\n\nint d[3001][3001][3];\n\nint main(void)\n{\n  int N, M, K;\n  struct road roads[100000];\n  int mall[3001];\n  int max_distance;\n  int longest_d;\n  int i;\n\n  scanf(\"%d %d %d\", &N, &M, &K);\n  max_distance=0;\n  for(i=0; i<M; i++){\n    scanf(\"%d %d %d\", &roads[i].from, &roads[i].to, &roads[i].distance);\n    if(max_distance<roads[i].distance) max_distance=roads[i].distance;\n  }\n  for(i=0; i<K; i++){\n    scanf(\"%d\", &mall[i]);\n  }\n  \n  longest_d=calc_longest(N, M, K, mall, roads, max_distance);\n  printf(\"%d\\n\", longest_d);\n\n  return 0;\n}\n\nint calc_longest(int N, int M, int K, int* mall, struct road* roads, int max_distance)\n{\n  int i, j, l;\n  float longest_d, tmp_d;\n  int longest_int;\n  int shortest_d[3001];\n  int current, prev;\n\n  for(i=1; i<=N; i++){\n    for(j=1; j<=N; j++){\n      for(l=0; l<3; l++){\n\td[i][j][l]=max_distance*(M+1);\n      }\n    }\n  }\n  for(i=0; i<M; i++){\n    d[roads[i].from][roads[i].to][0]=roads[i].distance;\n    d[roads[i].to][roads[i].from][0]=roads[i].distance;\n  }\n  for(i=0; i<K; i++){\n    for(j=0; j<K; j++){\n      d[mall[i]][mall[j]][0]=0; d[mall[j]][mall[i]][0]=0;\n    }\n  }\n\n  prev=0;\n  current=1;\n  for(l=1; l<=N; l++){\n    for(i=1; i<=N; i++){\n      for(j=1; j<=N; j++){\n\td[i][j][current]=min(d[i][j][prev], d[i][l][prev]+d[l][j][prev]);\n      }\n    }\n    prev=current;\n    current=3-prev;\n  }\n\n  for(i=1; i<=N; i++){\n    shortest_d[i]=max_distance*(M+1);\n    for(j=1; j<=N; j++){\n      if(shortest_d[i]>d[i][j][prev]) shortest_d[i]=d[i][j][prev];\n    }\n  }\n\n  longest_d=0.0f;\n  for(i=0; i<M; i++){\n    tmp_d=(float)(shortest_d[roads[i].from]+shortest_d[roads[i].to]+roads[i].distance);\n    tmp_d/=2.0f;\n    if(longest_d<tmp_d) longest_d=tmp_d;\n  }\n\n  longest_int=longest_d+0.5f;\n  return longest_int;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define NODE (3000)\n#define INF (100000000)\n\nint v[NODE + 1];\nint dist[NODE + 1];\nint w[NODE + 1][NODE + 1];\n\nint n, m, k;\n\nint max(int a, int b)\n{\n    return (a > b ? a : b);\n}\n\nvoid dijkstra(int start)\n{\n    int i, j;\n    int node;\n    \n    for (i = 1; i <= n; i++){\n        v[i] = 0;\n    }\n    \n    dist[start] = 0;\n    \n    while (1){\n        node = -1;\n        for (i = 1; i <= n; i++){\n            if (v[i] == 0 && (node == -1 || dist[node] > dist[i])){\n                node = i;\n            }\n        }\n        \n        if (node == -1){\n            break;\n        }\n        \n        v[node] = 1;\n        \n        for (i = 1; i <= n; i++){\n            if (dist[i] > dist[node] + w[node][i] && v[i] == 0){\n                dist[i] = dist[node] + w[node][i];\n            }\n        }\n    }\n}\n\nint main(void)\n{\n    int i, j;\n    int from, to, cost, res;\n    \n    scanf(\"%d%d%d\", &n, &m, &k);\n    \n    for (i = 1; i <= n; i++){\n        dist[i] = INF;\n        for (j = 1; j <= n; j++){\n            w[i][j] = INF;\n            if (i == j){\n                w[i][j] = 0;\n            }\n        }\n    }\n    \n    for (i = 1; i <= m; i++){\n        scanf(\"%d%d%d\", &from, &to, &cost);\n        w[from][to] = w[to][from] = cost;\n    }\n    for (i = 1; i <= k; i++){\n        scanf(\"%d\", &from);\n        dijkstra(from);\n    }\n    \n    res = 0;\n    \n    for (i = 1; i <= n; i++){\n        for (j = i + 1; j <= n; j++){\n            if (w[i][j] != INF){\n                res = max(res, (w[i][j] + dist[i] + dist[j] + 1) / 2);\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", res);\n    \n    return (0);\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint M=10000;\n\t\twhile(in.hasNext())\n\t\t{\n\t\t\tint n=in.nextInt(), m=in.nextInt(),K=in.nextInt();\n\t\t\tint minmax=0;\n\t\t\tint cost[][]=new int[n+1][n+1];\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tArrays.fill(cost[i], M);\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tcost[i][i]=0;\n\t\t\tfor(int i=0;i<m;i++)\n\t\t\t{\n\t\t\t\tint a=in.nextInt(),b=in.nextInt(),l=in.nextInt();\n\t\t\t\tcost[a][b]=l;\n\t\t\t\tcost[b][a]=l;\n\t\t\t}\n\t\t\twhile(K-->0)\n\t\t\t{\n\t\t\t\tint mool=in.nextInt();\n\t\t\t\tint leng[]=new int[11];// minimum distance\n\t\t\t\tint v[] = new int[11];// decision flag\n\t\t\t\tfor(int I=1;I<=n;I++)\n\t\t\t\t{\n\t\t\t\t\tint p=0;\n\t\t\t\t\tint start =I;\n\t\t\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tleng[k]=M;\n\t\t\t\t\t\tv[k]=0;\n\t\t\t\t\t}\n\t\t\t\t\tleng[start]=0;\n\t\t\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint min=M;//最小の節点を探す\n\t\t\t\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(v[k]==0&&leng[k]<min)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tp=k;\n\t\t\t\t\t\t\t\tmin=leng[k];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tv[p]=1;//確定フラグ\n\t\t\t\t\t\tfor(int k=1;k<=n;k++) //pを経由してkに至長さがそれまでの最短経路より小さければ更新\n\t\t\t\t\t\t\tleng[k]=Math.min(leng[p]+cost[p][k], leng[k]);\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\t\t\tminmax=Math.max(minmax, leng[mool]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(minmax);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Shopping in JOI Kingdom\npublic class Main{\n\n\tint n, m, k, INF = 1<<29;\n\tList<E>[] adj;\n\tint[] d;\n\t\n\tclass E{\n\t\tint t, c;\n\t\tpublic E(int t, int c) {\n\t\t\tthis.t = t;\n\t\t\tthis.c = c;\n\t\t}\n\t}\n\t\n\tvoid dijkstra(int x){\n\t\td[x] = 0;\n\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(n, new Comparator<Integer>() {\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\treturn d[o1]-d[o2];\n\t\t\t}\n\t\t});\n\t\tq.add(x);\n\t\twhile(!q.isEmpty()){\n\t\t\tint v = q.poll();\n\t\t\tfor(E e:adj[v]){\n\t\t\t\tint w = d[v]+e.c;\n\t\t\t\tif(w<d[e.t]){\n\t\t\t\t\tq.remove(e.t); d[e.t] = w; q.add(e.t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt(); m = sc.nextInt(); k = sc.nextInt();\n\t\tadj = new List[n];\n\t\tfor(int i=0;i<n;i++)adj[i]=new ArrayList<E>();\n\t\td = new int[n];\n\t\tArrays.fill(d, INF);\n\t\twhile(m--!=0){\n\t\t\tint s = sc.nextInt()-1, t = sc.nextInt()-1, c = sc.nextInt();\n\t\t\tadj[s].add(new E(t, c)); adj[t].add(new E(s, c));\n\t\t}\n\t\twhile(k--!=0)dijkstra(sc.nextInt()-1);\n\t\tdouble res = 0;\n\t\tfor(int i=0;i<n;i++)for(E e:adj[i]){\n\t\t\tint dif = Math.abs(d[i]-d[e.t]);\n\t\t\tif(d[i]<d[e.t])res = Math.max(res, d[i]+dif+(e.c-dif)/2.0);\n\t\t\telse res = Math.max(res, d[e.t]+dif+(e.c-dif)/2.0);\n\t\t}\n\t\tSystem.out.printf(\"%.0f\\n\", res);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint M=50000000;\n\t\twhile(in.hasNext())\n\t\t{\n\t\t\tint n=in.nextInt(), m=in.nextInt(),K=in.nextInt();\n\t\t\tdouble minmax=0;\n\t\t\tint cost[][]=new int[n+1][n+1];\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tArrays.fill(cost[i], M);\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tcost[i][i]=0;\n\t\t\tString cap[]=new String[m];\n\t\t\tfor(int i=0;i<m;i++)\n\t\t\t{\n\t\t\t\tint a=in.nextInt(),b=in.nextInt(),l=in.nextInt();\n\t\t\t\tcap[i]=a+\" \"+b+\" \"+l;\n\t\t\t\tcost[a][b]=l;\n\t\t\t\tcost[b][a]=l;\n\t\t\t}\n\t\t\tint fmo=in.nextInt();\n\t\t\tint startmo=fmo;\n\t\t\tif(K>1)\n\t\t\t\tfor(int i=1;i<K;i++)\n\t\t\t\t{\n\t\t\t\t\tint nexmo=in.nextInt();\n\t\t\t\t\tcost[fmo][nexmo]=0;\n\t\t\t\t\tcost[nexmo][fmo]=0;\n\t\t\t\t\tfmo=nexmo;\n\t\t\t\t}\n\t\t\tint leng[]=new int[n+1];// minimum distance\n\t\t\tint v[] = new int[n+1];// decision flag\n\n\t\t\tint p=0;\n\t\t\tint start =startmo;\n\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t{\n\t\t\t\tleng[k]=M;\n\t\t\t\tv[k]=0;\n\t\t\t}\n\t\t\tleng[start]=0;\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tint min=M;//最小の節点を探す\n\t\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t\t{\n\t\t\t\t\tif(v[k]==0&&leng[k]<min)\n\t\t\t\t\t{\n\t\t\t\t\t\tp=k;\n\t\t\t\t\t\tmin=leng[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tv[p]=1;//確定フラグ\n\t\t\t\tfor(int k=1;k<=n;k++) //pを経由してkに至長さがそれまでの最短経路より小さければ更新\n\t\t\t\t\tleng[k]=Math.min(leng[p]+cost[p][k], leng[k]);\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++)\n\t\t\t{\n\t\t\t\tString ss[]=cap[i].split(\" \");\n\t\t\t\tint a=Integer.valueOf(ss[0]);\n\t\t\t\tint b=Integer.valueOf(ss[1]);\n\t\t\t\tint cos=Integer.valueOf(ss[2]);\n\t\t\t\tdouble d=(leng[a]+leng[b]+cos)/2.0;\n\t\t\t\tminmax=Math.max(minmax, d);\n\t\t\t}\n\t\t\tSystem.out.println(Math.round(minmax));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint M=10000;\n\t\twhile(in.hasNext())\n\t\t{\n\t\t\tint n=in.nextInt(), m=in.nextInt(),K=in.nextInt();\n\t\t\tint minmax=0;\n\t\t\tint cost[][]=new int[n+1][n+1];\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tArrays.fill(cost[i], M);\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tcost[i][i]=0;\n\t\t\tString cap[]=new String[m];\n\t\t\tfor(int i=0;i<m;i++)\n\t\t\t{\n\t\t\t\tint a=in.nextInt(),b=in.nextInt(),l=in.nextInt();\n\t\t\t\tcap[i]=a+\" \"+b+\" \"+l;\n\t\t\t\tcost[a][b]=l;\n\t\t\t\tcost[b][a]=l;\n\t\t\t}\n\t\t\tint fmo=in.nextInt();\n\t\t\tint startmo=fmo;\n\t\t\tif(K>1)\n\t\t\t\tfor(int i=1;i<K;i++)\n\t\t\t\t{\n\t\t\t\t\tint nexmo=in.nextInt();\n\t\t\t\t\tcost[fmo][nexmo]=0;\n\t\t\t\t\tcost[nexmo][fmo]=0;\n\t\t\t\t\tfmo=nexmo;\n\t\t\t\t}\n\t\t\tint leng[]=new int[n+1];// minimum distance\n\t\t\tint v[] = new int[n+1];// decision flag\n\n\t\t\tint p=0;\n\t\t\tint start =startmo;\n\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t{\n\t\t\t\tleng[k]=M;\n\t\t\t\tv[k]=0;\n\t\t\t}\n\t\t\tleng[start]=0;\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tint min=M;//最小の節点を探す\n\t\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t\t{\n\t\t\t\t\tif(v[k]==0&&leng[k]<min)\n\t\t\t\t\t{\n\t\t\t\t\t\tp=k;\n\t\t\t\t\t\tmin=leng[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tv[p]=1;//確定フラグ\n\t\t\t\tfor(int k=1;k<=n;k++) //pを経由してkに至長さがそれまでの最短経路より小さければ更新\n\t\t\t\t\tleng[k]=Math.min(leng[p]+cost[p][k], leng[k]);\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++)\n\t\t\t{\n\t\t\t\tString ss[]=cap[i].split(\" \");\n\t\t\t\tint a=Integer.valueOf(ss[0]);\n\t\t\t\tint b=Integer.valueOf(ss[1]);\n\t\t\t\tint cos=Integer.valueOf(ss[2]);\n\t\t\t\tdouble d=(leng[a]+leng[b]+cos+1);\n\t\t\t\td=d/2;\n\t\t\t\tminmax= (int)Math.max(minmax, d);\n\t\t\t}\n\t\t\tSystem.out.println(minmax);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\n    int n,m,k;\n    int[][] c;\n    int[] shop;\n    int[] d;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        n = sc.nextInt();\n        m = sc.nextInt();\n        k = sc.nextInt();\n        c = new int[n][n];\n        for(int i=0; i<n; i++) Arrays.fill(c[i],-1);\n        for(int i=0; i<m; i++){\n            int a = sc.nextInt()-1;\n            int b = sc.nextInt()-1;\n            int l = sc.nextInt();\n            c[a][b] = l;\n            c[b][a] = l;\n        }\n\n        shop = new int[k];\n        for(int i=0; i<k; i++) shop[i] = sc.nextInt()-1;\n\n        d = new int[n];\n        Arrays.fill(d,-1);\n        dijkstra();\n\n        int max = 0;\n        for(int i=0; i<n; i++){\n            if(d[i]==-1) continue;\n            for(int j=i+1; j<n; j++){\n                if(c[i][j]==-1 || d[j]==-1) continue;\n                int d1 = d[i], d2 = d[j];\n                int cc = c[i][j];\n\n                if(d1<d2){\n                    cc -= (d2-d1);\n                    d1 = d2;\n                }else{\n                    cc -= (d1-d2);\n                    d2 = d1;\n                }\n\n                if(cc>0){\n                    if(cc%2==0) d1 += cc/2;\n                    else d1 += cc/2+1;\n                }\n                max = Math.max(max,d1);\n            }\n        }\n\n        System.out.println(max);\n    }\n\n    void dijkstra(){\n        //pos, cost\n        PriorityQueue<int[]> \n            q = new PriorityQueue<int[]>(n, new Comparator<int[]>(){\n                    public int compare(int[] a, int [] b){\n                        return a[1] - b[1];\n                    }\n                });\n        for(int i=0; i<k ;i++) q.add(new int[]{shop[i],0});\n\n        while(q.size()>0){\n            int[] qq = q.poll();\n            int pos = qq[0], cost = qq[1];\n\n            if(d[pos]!=-1) continue;\n            d[pos] = cost;\n\n            for(int i=0; i<n; i++){\n                if(c[pos][i]==-1) continue;\n                q.add(new int[]{i,cost+c[pos][i]});\n            }\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n int n=ir.nextInt();\n int m=ir.nextInt();\n int K=ir.nextInt();\n int[] a=new int[m],b=new int[m],l=new int[m];\n G g=new G(n,true);\n for(int i=0;i<m;i++){\n  a[i]=ir.nextInt()-1;\n  b[i]=ir.nextInt()-1;\n  l[i]=ir.nextInt();\n  g.addEdge(a[i],b[i],l[i]);\n }\n int[] s=ir.nextIntArray(K);\n for(int i=0;i<K;i++) s[i]--;\n int[][] d=new int[K][];\n for(int i=0;i<K;i++) d[i]=g.dijkstra(s[i]);\n int[] md=new int[n];\n for(int i=0;i<n;i++){\n  md[i]=1<<27;\n  for(int j=0;j<K;j++){\n   md[i]=Math.min(md[i],d[j][i]);\n  }\n }\n int ma=0;\n for(int i=0;i<n;i++){\n  for(int j=0;j<g.g[i].size();j++){\n   ma=Math.max(ma,(int)(md[i]+md[g.to(i,j)]+g.cost(i,j)+1)/2);\n  }\n }\n out.println(ma);\n}\n\nstatic class G{\n\n AL[] g,rg;\n private int V;\n private boolean ndir;\n\n public G(int V,boolean ndir){\n  this.V=V;\n  this.ndir=ndir;\n  g=new AL[V];\n  for(int i=0;i<V;i++) g[i]=new AL();\n }\n\n public void addEdge(int u,int v,int t){\n  g[u].add(new int[]{v,t});\n  if(this.ndir) g[v].add(new int[]{u,t});\n }\n\n public void addEdge(int u,int v){\n  addEdge(u,v,0);\n }\n\n public int to(int from,int ind){return g[from].get(ind)[0];}\n\n public int cost(int from,int ind){return g[from].get(ind)[1];}\n\n public int size(int from){return g[from].size();}\n\n public int[] dijkstra(int s){\n  int[] dist=new int[this.V];\n  java.util.PriorityQueue<int[]> pque=new java.util.PriorityQueue<int[]>(11,new Comparator<int[]>(){\n   public int compare(int[] a,int[] b){\n    return Integer.compare(a[0],b[0]);\n   }\n  });\n  Arrays.fill(dist,1<<26);\n  dist[s]=0;\n  pque.offer(new int[]{0,s});\n  while(!pque.isEmpty()){\n   int[] p=pque.poll();\n   int v=p[1];\n   if(dist[v]<p[0]) continue;\n   for(int i=0;i<g[v].size();i++){\n    int to=to(v,i),cost=cost(v,i);\n    if(dist[to]>dist[v]+cost){\n     dist[to]=dist[v]+cost;\n     pque.offer(new int[]{dist[to],to});\n    }\n   }\n  }\n  return dist;\n }\n\n public int[] tporder(){\n  boolean[] vis=new boolean[V];\n  ArrayList<Integer> ord=new ArrayList<>();\n  for(int i=0;i<V;i++) if(!vis[i]) ts(i,vis,ord);\n  int[] ret=new int[V];\n  for(int i=ord.size()-1;i>=0;i--) ret[ord.size()-1-i]=ord.get(i);\n  return ret;\n }\n\n public int[] scc(){\n  rg=new AL[V];\n  for(int i=0;i<V;i++) rg[i]=new AL();\n  int from,to;\n  for(int i=0;i<V;i++){\n   for(int j=0;j<g[i].size();j++){\n    to=i;\n    from=to(i,j);\n    rg[from].add(new int[]{to,0});\n   }\n  } \n  int[] ord=tporder();\n  int k=0;\n  boolean[] vis=new boolean[V];\n  int[] ret=new int[V+1];\n  for(int i=0;i<V;i++) if(!vis[i]) rs(ord[i],vis,ret,k++);\n  ret[V]=k;\n  return ret;\n }\n\n private void ts(int now,boolean[] vis,ArrayList<Integer> ord){\n  vis[now]=true;\n  int to;\n  for(int i=0;i<g[now].size();i++){\n   to=to(now,i);\n   if(!vis[to]) ts(to,vis,ord);\n  }\n  ord.add(now);\n }\n\n private void rs(int now,boolean[] vis,int[] ret,int k){\n  vis[now]=true;\n  ret[now]=k;\n  int to;\n  for(int i=0;i<rg[now].size();i++){\n   to=rg[now].get(i)[0];\n   if(!vis[to]) rs(to,vis,ret,k);\n  }\n }\n\n static class AL extends ArrayList<int[]>{};\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint M=50000000;\n\t\twhile(in.hasNext())\n\t\t{\n\t\t\tint n=in.nextInt(), m=in.nextInt(),K=in.nextInt();\n\t\t\tdouble minmax=0;\n\t\t\tint cost[][]=new int[n+1][n+1];\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tArrays.fill(cost[i], M);\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tcost[i][i]=0;\n\t\t\tString cap[]=new String[m];\n\t\t\tfor(int i=0;i<m;i++)\n\t\t\t{\n\t\t\t\tint a=in.nextInt(),b=in.nextInt(),l=in.nextInt();\n\t\t\t\tcap[i]=a+\" \"+b+\" \"+l;\n\t\t\t\tcost[a][b]=l;\n\t\t\t\tcost[b][a]=l;\n\t\t\t}\n\t\t\tint fmo=in.nextInt();\n\t\t\tint startmo=fmo;\n\t\t\tif(K>1)\n\t\t\t\tfor(int i=1;i<K;i++)\n\t\t\t\t{\n\t\t\t\t\tint nexmo=in.nextInt();\n\t\t\t\t\tcost[fmo][nexmo]=0;\n\t\t\t\t\tcost[nexmo][fmo]=0;\n\t\t\t\t\tfmo=nexmo;\n\t\t\t\t}\n\t\t\tint leng[]=new int[n+1];// minimum distance\n\t\t\tint v[] = new int[n+1];// decision flag\n\n\t\t\tint p=0;\n\t\t\tint start =startmo;\n\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t{\n\t\t\t\tleng[k]=M;\n\t\t\t\tv[k]=0;\n\t\t\t}\n\t\t\tleng[start]=0;\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tint min=M;//最小の節点を探す\n\t\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t\t{\n\t\t\t\t\tif(v[k]==0&&leng[k]<min)\n\t\t\t\t\t{\n\t\t\t\t\t\tp=k;\n\t\t\t\t\t\tmin=leng[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tv[p]=1;//確定フラグ\n\t\t\t\tfor(int k=1;k<=n;k++) //pを経由してkに至長さがそれまでの最短経路より小さければ更新\n\t\t\t\t\tleng[k]=Math.min(leng[p]+cost[p][k], leng[k]);\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++)\n\t\t\t{\n\t\t\t\tString ss[]=cap[i].split(\" \");\n\t\t\t\tint a=Integer.valueOf(ss[0]);\n\t\t\t\tint b=Integer.valueOf(ss[1]);\n\t\t\t\tint cos=Integer.valueOf(ss[2]);\n\t\t\t\tdouble d=(leng[a]+leng[b]+cos)/2.0;\n\t\t\t\tminmax=Math.max(minmax, d);\n\t\t\t}\n\t\t\tSystem.out.println(Math.round(minmax));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\t\tint m = scanner.nextInt();\n\t\tint k = scanner.nextInt();\n\t\tList<Pair>[] list = new List[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tlist[i] = new ArrayList<Pair>();\n\t\twhile (m-- > 0) {\n\t\t\tint a = scanner.nextInt() - 1;\n\t\t\tint b = scanner.nextInt() - 1;\n\t\t\tint l = scanner.nextInt();\n\t\t\tlist[a].add(new Pair(b, l));\n\t\t\tlist[b].add(new Pair(a, l));\n\t\t}\n\t\tint[] dp = new int[n];\n\t\tArrays.fill(dp, 1 << 25);\n\t\tPriorityQueue<Pair> pq = new PriorityQueue<Main.Pair>();\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tint s = scanner.nextInt() - 1;\n\t\t\tdp[s] = 0;\n\t\t\tpq.offer(new Pair(0, s));\n\t\t}\n\t\twhile (!pq.isEmpty()) {\n\t\t\tPair pair = pq.poll();\n\t\t\tint f = pair.f;\n\t\t\tint s = pair.s;\n\t\t\tif (dp[s] < f)\n\t\t\t\tcontinue;\n\t\t\tfor (Pair p : list[s]) {\n\t\t\t\tif (dp[p.f] <= f + p.s)\n\t\t\t\t\tcontinue;\n\t\t\t\tdp[p.f] = f + p.s;\n\t\t\t\tpq.offer(new Pair(f + p.s, p.f));\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (Pair p : list[i]) {\n\t\t\t\tif(dp[p.f]==0)\n\t\t\t\t\tcontinue;\n\t\t\t\tint a = Math.max(dp[i], dp[p.f]);\n\t\t\t\tint b = a + (p.s - Math.abs(dp[i] - dp[p.f]) + 1) / 2;\n\t\t\t\tans = Math.max(ans, b);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tint f, s;\n\n\t\tpublic Pair(int f, int s) {\n\t\t\tsuper();\n\t\t\tthis.f = f;\n\t\t\tthis.s = s;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Pair [f=\" + f + \", s=\" + s + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn f - o.f;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\t\tint m = scanner.nextInt();\n\t\tint k = scanner.nextInt();\n\t\tList<Pair>[] list = new List[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tlist[i] = new ArrayList<Pair>();\n\t\twhile (m-- > 0) {\n\t\t\tint a = scanner.nextInt() - 1;\n\t\t\tint b = scanner.nextInt() - 1;\n\t\t\tint l = scanner.nextInt();\n\t\t\tlist[a].add(new Pair(b, l));\n\t\t\tlist[b].add(new Pair(a, l));\n\t\t}\n\t\tint[] dp = new int[n];\n\t\tArrays.fill(dp, 1 << 25);\n\t\tPriorityQueue<Pair> pq = new PriorityQueue<Main.Pair>();\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tint s = scanner.nextInt() - 1;\n\t\t\tdp[s] = 0;\n\t\t\tpq.offer(new Pair(0, s));\n\t\t}\n\t\twhile (!pq.isEmpty()) {\n\t\t\tPair pair = pq.poll();\n\t\t\tint f = pair.f;\n\t\t\tint s = pair.s;\n\t\t\tif (dp[s] < f)\n\t\t\t\tcontinue;\n\t\t\tfor (Pair p : list[s]) {\n\t\t\t\tif (dp[p.f] <= f + p.s)\n\t\t\t\t\tcontinue;\n\t\t\t\tdp[p.f] = f + p.s;\n\t\t\t\tpq.offer(new Pair(f + p.s, p.f));\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif(dp[i]==0)\n\t\t\t\tcontinue;\n\t\t\tfor (Pair p : list[i]) {\n\t\t\t\tif(dp[p.f]==0)\n\t\t\t\t\tcontinue;\n\t\t\t\tint b = dp[i] + (p.s - Math.abs(dp[i] - dp[p.f]) + 1) / 2;\n\t\t\t\tans = Math.max(ans, b);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tint f, s;\n\n\t\tpublic Pair(int f, int s) {\n\t\t\tsuper();\n\t\t\tthis.f = f;\n\t\t\tthis.s = s;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Pair [f=\" + f + \", s=\" + s + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn f - o.f;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\t\tint m = scanner.nextInt();\n\t\tint k = scanner.nextInt();\n\t\tList<Pair>[] list = new List[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tlist[i] = new ArrayList<Pair>();\n\t\twhile (m-- > 0) {\n\t\t\tint a = scanner.nextInt() - 1;\n\t\t\tint b = scanner.nextInt() - 1;\n\t\t\tint l = scanner.nextInt();\n\t\t\tlist[a].add(new Pair(b, l));\n\t\t\tlist[b].add(new Pair(a, l));\n\t\t}\n\t\tint[] dp = new int[n];\n\t\tArrays.fill(dp, 1 << 25);\n\t\tPriorityQueue<Pair> pq = new PriorityQueue<Main.Pair>();\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tint s = scanner.nextInt() - 1;\n\t\t\tdp[s] = 0;\n\t\t\tpq.offer(new Pair(0, s));\n\t\t}\n\t\twhile (!pq.isEmpty()) {\n\t\t\tPair pair = pq.poll();\n\t\t\tint f = pair.f;\n\t\t\tint s = pair.s;\n\t\t\tfor (Pair p : list[s]) {\n\t\t\t\tif (dp[p.f] <= f + p.s)\n\t\t\t\t\tcontinue;\n\t\t\t\tdp[p.f] = f + p.s;\n\t\t\t\tpq.offer(new Pair(f + p.s, p.f));\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (Pair p : list[i])\n\t\t\t\tans = Math.max(\n\t\t\t\t\t\tans,\n\t\t\t\t\t\tMath.max(dp[i], dp[p.f])\n\t\t\t\t\t\t\t\t+ (p.s - Math.abs(dp[i] - dp[p.f]) + 1) / 2);\n\t\tSystem.out.println(ans);\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tint f, s;\n\n\t\tpublic Pair(int f, int s) {\n\t\t\tsuper();\n\t\t\tthis.f = f;\n\t\t\tthis.s = s;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Pair [f=\" + f + \", s=\" + s + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn f - o.f;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\t\tint m = scanner.nextInt();\n\t\tint k = scanner.nextInt();\n\t\tList<Pair>[] list = new List[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tlist[i] = new ArrayList<Pair>();\n\t\twhile (m-- > 0) {\n\t\t\tint a = scanner.nextInt() - 1;\n\t\t\tint b = scanner.nextInt() - 1;\n\t\t\tint l = scanner.nextInt();\n\t\t\tlist[a].add(new Pair(b, l));\n\t\t\tlist[b].add(new Pair(a, l));\n\t\t}\n\t\tint[] dp = new int[n];\n\t\tArrays.fill(dp, 1 << 25);\n\t\tPriorityQueue<Pair> pq = new PriorityQueue<Main.Pair>();\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tint s = scanner.nextInt() - 1;\n\t\t\tdp[s] = 0;\n\t\t\tpq.offer(new Pair(0, s));\n\t\t}\n\t\twhile (!pq.isEmpty()) {\n\t\t\tPair pair = pq.poll();\n\t\t\tint f = pair.f;\n\t\t\tint s = pair.s;\n\t\t\tif (dp[s] < f)\n\t\t\t\tcontinue;\n\t\t\tfor (Pair p : list[s]) {\n\t\t\t\tif (dp[p.f] <= f + p.s)\n\t\t\t\t\tcontinue;\n\t\t\t\tdp[p.f] = f + p.s;\n\t\t\t\tpq.offer(new Pair(f + p.s, p.f));\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tboolean[] b = new boolean[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tb[i] = true;\n\t\t\tfor (Pair p : list[i]) {\n\t\t\t\tif (b[p.f])\n\t\t\t\t\tcontinue;\n\t\t\t\tint a = Math.max(dp[i], dp[p.f])\n\t\t\t\t\t\t+ (p.s - Math.abs(dp[i] - dp[p.f]) + 1) / 2;\n\t\t\t\tans = Math.max(ans, a);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tint f, s;\n\n\t\tpublic Pair(int f, int s) {\n\t\t\tsuper();\n\t\t\tthis.f = f;\n\t\t\tthis.s = s;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Pair [f=\" + f + \", s=\" + s + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn f - o.f;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n int n=ir.nextInt();\n int m=ir.nextInt();\n int K=ir.nextInt();\n int[] a=new int[m],b=new int[m],l=new int[m];\n int[][] d=new int[n][n];\n for(int i=0;i<n;i++){\n  Arrays.fill(d[i],1<<26);\n  d[i][i]=0;\n }\n for(int i=0;i<m;i++){\n  a[i]=ir.nextInt()-1;\n  b[i]=ir.nextInt()-1;\n  l[i]=ir.nextInt();\n  d[a[i]][b[i]]=d[b[i]][a[i]]=l[i];\n }\n for(int k=0;k<n;k++){\n  for(int i=0;i<n;i++){\n   for(int j=0;j<n;j++){\n    d[i][j]=Math.min(d[i][j],d[i][k]+d[k][j]);\n   }\n  }\n }\n int[] s=ir.nextIntArray(K);\n for(int i=0;i<K;i++) s[i]--;\n int ma=0;\n for(int i=0;i<n;i++){\n  int mi=1<<29;\n  for(int j=0;j<K;j++){\n   mi=Math.min(mi,d[i][j]);\n  }\n  ma=Math.max(mi,ma);\n }\n out.println(ma+1);\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt(), m = sc.nextInt(), k = sc.nextInt();\n\n\t\tE[] G = new E[n];\n\t\tfor(int i=0;i<n;i++) G[i] = new E();\n\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tint a = sc.nextInt() - 1, b = sc.nextInt() - 1, l = sc.nextInt();\n\t\t\tG[a].add(new V(b, 2*l));\n\t\t\tG[b].add(new V(a, 2*l));\n\t\t}\n\n\t\tint[] sp = new int[k];\n\t\tint[] dist = new int[n]; fill(dist, INF);\n\n\t\tPriorityQueue<S> que = new PriorityQueue<S>();\n\t\tint max = 0;\n\n\t\tfor(int i=0;i<k;i++) {\n\t\t\tsp[i] = sc.nextInt() - 1;\n\t\t\tdist[sp[i]] = 0;\n\n\t\t\tfor(V v: G[sp[i]]) if(dist[v.t] > v.l){\n\t\t\t\tque.add(new S(v.t, v.l));\n\t\t\t}\n\t\t}\n\n\t\tfor(;!que.isEmpty();) {\n\t\t\tS cur = que.remove();\n\t\t\tif(dist[cur.p] == INF) {\n\t\t\t\tdist[cur.p] = cur.c;\n\t\t\t\tmax = max(max, cur.c);\n\t\t\t} else {\n\t\t\t\tmax = max(max, ( dist[cur.p] + cur.c ) / 2);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor(V v: G[cur.p]) if(dist[v.t] > v.l){\n\t\t\t\tque.add(new S(v.t, cur.c + v.l));\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println((max+1) / 2);\n\t}\n\n\tclass S implements Comparable<S>{\n\t\tint p, c;\n\t\tS(int p, int c){\n\t\t\tthis.p = p;\n\t\t\tthis.c = c;\n\t\t}\n\n\t\tpublic int compareTo(S arg0) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn c - arg0.c;\n\t\t}\n\t}\n\n\tclass V {\n\t\tint t, l;\n\t\tV(int t, int l) {\n\t\t\tthis.t = t; this.l = l;\n\t\t}\n\t}\n\n\tclass E extends ArrayList<V> {}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\tint N = sc.nextInt();\n\t\tint M = sc.nextInt();\n\t\tint K = sc.nextInt();\n\t\tint[][] g = new int[N][N];\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a = Integer.parseInt(sc.next()) - 1;\n\t\t\tint b = Integer.parseInt(sc.next()) - 1;\n\t\t\tint l = Integer.parseInt(sc.next()) * 2;\n\t\t\tg[a][b] = g[b][a] = l;\n\t\t}\n\t\tPriorityQueue<Long> q = new PriorityQueue<Long>();\n\t\tfor (int i = 0; i < K; ++i) {\n\t\t\tq.add(Long.parseLong(sc.next()) - 1);\n\t\t}\n\t\tint[] dist = new int[N];\n\t\tArrays.fill(dist, -1);\n\t\tint ans = 0;\n\t\twhile (!q.isEmpty()) {\n\t\t\tlong st = q.poll();\n\t\t\tint t = (int) st;\n\t\t\tlong d = st >> 32;\n\t\t\tif (dist[t] >= 0) continue;\n\t\t\tdist[t] = (int) d;\n\t\t\tans = (int) d;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (dist[i] == -1 && g[t][i] > 0) {\n\t\t\t\t\tq.add(((d + g[t][i]) << 32) + i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\t\tif (g[i][j] == 0) continue;\n\t\t\t\tans = Math.max(ans, (dist[i] + dist[j] + g[i][j]) / 2);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println((ans + 1) / 2);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\n    int n,m,k;\n    int[][] c;\n    int[] shop;\n    int[] d;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        n = sc.nextInt();\n        m = sc.nextInt();\n        k = sc.nextInt();\n        c = new int[n][n];\n        for(int i=0; i<n; i++) Arrays.fill(c[i],-1);\n        for(int i=0; i<m; i++){\n            int a = sc.nextInt()-1;\n            int b = sc.nextInt()-1;\n            int l = sc.nextInt();\n            c[a][b] = l;\n            c[b][a] = l;\n        }\n\n        shop = new int[k];\n        for(int i=0; i<k; i++) shop[i] = sc.nextInt()-1;\n\n        d = new int[n];\n        Arrays.fill(d,-1);\n        dijkstra();\n\n        int max = 0;\n        for(int i=0; i<n; i++){\n            if(d[i]==-1) continue;\n            for(int j=i+1; j<n; j++){\n                if(c[i][j]==-1 || d[j]==-1) continue;\n                int d1 = d[i], d2 = d[j];\n                int cc = c[i][j];\n                while(cc>0){\n                    if(d1<d2) d1++;\n                    else d2++;\n                    cc--;\n                }\n                max = Math.max(max,Math.max(d1,d2));\n            }\n        }\n\n        System.out.println(max);\n    }\n\n    void dijkstra(){\n        //pos, cost\n        PriorityQueue<int[]> \n            q = new PriorityQueue<int[]>(n, new Comparator<int[]>(){\n                    public int compare(int[] a, int [] b){\n                        return a[1] - b[1];\n                    }\n                });\n        for(int i=0; i<k ;i++) q.add(new int[]{shop[i],0});\n\n        while(q.size()>0){\n            int[] qq = q.poll();\n            int pos = qq[0], cost = qq[1];\n\n            if(d[pos]!=-1) continue;\n            d[pos] = cost;\n\n            for(int i=0; i<n; i++){\n                if(c[pos][i]==-1) continue;\n                q.add(new int[]{i,cost+c[pos][i]});\n            }\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\t\tint m = scanner.nextInt();\n\t\tint k = scanner.nextInt();\n\t\tList<Pair>[] list = new List[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tlist[i] = new ArrayList<Pair>();\n\t\twhile (m-- > 0) {\n\t\t\tint a = scanner.nextInt() - 1;\n\t\t\tint b = scanner.nextInt() - 1;\n\t\t\tint l = scanner.nextInt();\n\t\t\tlist[a].add(new Pair(b, l));\n\t\t\tlist[b].add(new Pair(a, l));\n\t\t}\n\t\tint[] dp = new int[n];\n\t\tArrays.fill(dp, 1 << 25);\n\t\tPriorityQueue<Pair> pq = new PriorityQueue<Main.Pair>();\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tint s = scanner.nextInt() - 1;\n\t\t\tdp[s] = 0;\n\t\t\tpq.offer(new Pair(0, s));\n\t\t}\n\t\twhile (!pq.isEmpty()) {\n\t\t\tPair pair = pq.poll();\n\t\t\tint f = pair.f;\n\t\t\tint s = pair.s;\n\t\t\tif (dp[s] < f)\n\t\t\t\tcontinue;\n\t\t\tfor (Pair p : list[s]) {\n\t\t\t\tif (dp[p.f] <= f + p.s)\n\t\t\t\t\tcontinue;\n\t\t\t\tdp[p.f] = f + p.s;\n\t\t\t\tpq.offer(new Pair(f + p.s, p.f));\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif(dp[i]==0)\n\t\t\t\tcontinue;\n\t\t\tfor (Pair p : list[i]) {\n\t\t\t\tif(dp[p.f]==0)\n\t\t\t\t\tcontinue;\n\t\t\t\tint a = Math.max(dp[i], dp[p.f]);\n\t\t\t\tint b = a + (p.s - Math.abs(dp[i] - dp[p.f]) + 1) / 2;\n\t\t\t\tans = Math.max(ans, b);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tint f, s;\n\n\t\tpublic Pair(int f, int s) {\n\t\t\tsuper();\n\t\t\tthis.f = f;\n\t\t\tthis.s = s;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Pair [f=\" + f + \", s=\" + s + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn f - o.f;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n int n=ir.nextInt();\n int m=ir.nextInt();\n int K=ir.nextInt();\n int[] a=new int[m],b=new int[m],l=new int[m];\n G g=new G(n,true);\n for(int i=0;i<m;i++){\n  a[i]=ir.nextInt()-1;\n  b[i]=ir.nextInt()-1;\n  l[i]=ir.nextInt();\n  g.addEdge(a[i],b[i],l[i]);\n }\n int[] s=ir.nextIntArray(K);\n for(int i=0;i<K;i++) s[i]--;\n int[][] d=new int[n][];\n for(int i=0;i<n;i++) d[i]=g.dijkstra(i);\n int[] md=new int[n];\n for(int i=0;i<n;i++){\n  md[i]=1<<27\n  for(int j=0;j<K;j++){\n   md[i]=Math.min(md[i],d[i][s[j]]);\n  }\n }\n int ma=0;\n for(int i=0;i<n;i++){\n  for(int j=0;j<g.g[i].size();j++){\n   ma=Math.max(ma,(int)(md[i]+md[g.to(i,j)]+g.cost(i,j)+1)/2);\n  }\n }\n out.println(ma);\n}\n\nstatic class G{\n\n AL[] g,rg;\n private int V;\n private boolean ndir;\n\n public G(int V,boolean ndir){\n  this.V=V;\n  this.ndir=ndir;\n  g=new AL[V];\n  for(int i=0;i<V;i++) g[i]=new AL();\n }\n\n public void addEdge(int u,int v,int t){\n  g[u].add(new int[]{v,t});\n  if(this.ndir) g[v].add(new int[]{u,t});\n }\n\n public void addEdge(int u,int v){\n  addEdge(u,v,0);\n }\n\n public int to(int from,int ind){return g[from].get(ind)[0];}\n\n public int cost(int from,int ind){return g[from].get(ind)[1];}\n\n public int size(int from){return g[from].size();}\n\n public int[] dijkstra(int s){\n  int[] dist=new int[this.V];\n  java.util.PriorityQueue<int[]> pque=new java.util.PriorityQueue<int[]>(11,new Comparator<int[]>(){\n   public int compare(int[] a,int[] b){\n    return Integer.compare(a[0],b[0]);\n   }\n  });\n  Arrays.fill(dist,1<<26);\n  dist[s]=0;\n  pque.offer(new int[]{0,s});\n  while(!pque.isEmpty()){\n   int[] p=pque.poll();\n   int v=p[1];\n   if(dist[v]<p[0]) continue;\n   for(int i=0;i<g[v].size();i++){\n    int to=to(v,i),cost=cost(v,i);\n    if(dist[to]>dist[v]+cost){\n     dist[to]=dist[v]+cost;\n     pque.offer(new int[]{dist[to],to});\n    }\n   }\n  }\n  return dist;\n }\n\n public int[] tporder(){\n  boolean[] vis=new boolean[V];\n  ArrayList<Integer> ord=new ArrayList<>();\n  for(int i=0;i<V;i++) if(!vis[i]) ts(i,vis,ord);\n  int[] ret=new int[V];\n  for(int i=ord.size()-1;i>=0;i--) ret[ord.size()-1-i]=ord.get(i);\n  return ret;\n }\n\n public int[] scc(){\n  rg=new AL[V];\n  for(int i=0;i<V;i++) rg[i]=new AL();\n  int from,to;\n  for(int i=0;i<V;i++){\n   for(int j=0;j<g[i].size();j++){\n    to=i;\n    from=to(i,j);\n    rg[from].add(new int[]{to,0});\n   }\n  } \n  int[] ord=tporder();\n  int k=0;\n  boolean[] vis=new boolean[V];\n  int[] ret=new int[V+1];\n  for(int i=0;i<V;i++) if(!vis[i]) rs(ord[i],vis,ret,k++);\n  ret[V]=k;\n  return ret;\n }\n\n private void ts(int now,boolean[] vis,ArrayList<Integer> ord){\n  vis[now]=true;\n  int to;\n  for(int i=0;i<g[now].size();i++){\n   to=to(now,i);\n   if(!vis[to]) ts(to,vis,ord);\n  }\n  ord.add(now);\n }\n\n private void rs(int now,boolean[] vis,int[] ret,int k){\n  vis[now]=true;\n  ret[now]=k;\n  int to;\n  for(int i=0;i<rg[now].size();i++){\n   to=rg[now].get(i)[0];\n   if(!vis[to]) rs(to,vis,ret,k);\n  }\n }\n\n static class AL extends ArrayList<int[]>{};\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n int n=ir.nextInt();\n int m=ir.nextInt();\n int K=ir.nextInt();\n int[] a=new int[m],b=new int[m],l=new int[m];\n G g=new G(n,true);\n for(int i=0;i<m;i++){\n  a[i]=ir.nextInt();\n  b[i]=ir.nextInt();\n  l[i]=ir.nextInt();\n  g.addEdge(a[i],b[i],l[i]);\n }\n int[] s=ir.nextIntArray(K);\n for(int i=0;i<K;i++) s[i]--;\n int[][] d=new int[n][];\n for(int i=0;i<n;i++) d[i]=g.dijkstra(i);\n int[] md=new int[n];\n for(int i=0;i<n;i++){\n  int mi=1<<27;\n  for(int j=0;j<K;j++){\n   mi=Math.min(mi,d[i][s[j]]);\n  }\n  md[i]=mi;\n }\n int ma=0;\n for(int i=0;i<n;i++){\n  for(int j=0;j<g.g[i].size();j++){\n   ma=Math.max(ma,(int)(md[i]+md[g.to(i,j)]+g.cost(i,j)+1)/2);\n  }\n }\n out.println(ma);\n}\n\nstatic class G{\n\n AL[] g,rg;\n private int V;\n private boolean ndir;\n\n public G(int V,boolean ndir){\n  this.V=V;\n  this.ndir=ndir;\n  g=new AL[V];\n  for(int i=0;i<V;i++) g[i]=new AL();\n }\n\n public void addEdge(int u,int v,int t){\n  g[u].add(new int[]{v,t});\n  if(this.ndir) g[v].add(new int[]{u,t});\n }\n\n public void addEdge(int u,int v){\n  addEdge(u,v,0);\n }\n\n public int to(int from,int ind){return g[from].get(ind)[0];}\n\n public int cost(int from,int ind){return g[from].get(ind)[1];}\n\n public int[] dijkstra(int s){\n  int[] dist=new int[this.V];\n  java.util.PriorityQueue<int[]> pque=new java.util.PriorityQueue<int[]>(11,new Comparator<int[]>(){\n   public int compare(int[] a,int[] b){\n    return Integer.compare(a[0],b[0]);\n   }\n  });\n  Arrays.fill(dist,1<<26);\n  dist[s]=0;\n  pque.offer(new int[]{0,s});\n  while(!pque.isEmpty()){\n   int[] p=pque.poll();\n   int v=p[1];\n   if(dist[v]<p[0]) continue;\n   for(int i=0;i<g[v].size();i++){\n    int to=to(v,i),cost=cost(v,i);\n    if(dist[to]>dist[v]+cost){\n     dist[to]=dist[v]+cost;\n     pque.offer(new int[]{dist[to],to});\n    }\n   }\n  }\n  return dist;\n }\n\n public int[] tporder(){\n  boolean[] vis=new boolean[V];\n  ArrayList<Integer> ord=new ArrayList<>();\n  for(int i=0;i<V;i++) if(!vis[i]) ts(i,vis,ord);\n  int[] ret=new int[V];\n  for(int i=ord.size()-1;i>=0;i--) ret[ord.size()-1-i]=ord.get(i);\n  return ret;\n }\n\n public int[] scc(){\n  rg=new AL[V];\n  for(int i=0;i<V;i++) rg[i]=new AL();\n  int from,to;\n  for(int i=0;i<V;i++){\n   for(int j=0;j<g[i].size();j++){\n    to=i;\n    from=to(i,j);\n    rg[from].add(new int[]{to,0});\n   }\n  } \n  int[] ord=tporder();\n  int k=0;\n  boolean[] vis=new boolean[V];\n  int[] ret=new int[V+1];\n  for(int i=0;i<V;i++) if(!vis[i]) rs(ord[i],vis,ret,k++);\n  ret[V]=k;\n  return ret;\n }\n\n private void ts(int now,boolean[] vis,ArrayList<Integer> ord){\n  vis[now]=true;\n  int to;\n  for(int i=0;i<g[now].size();i++){\n   to=to(now,i);\n   if(!vis[to]) ts(to,vis,ord);\n  }\n  ord.add(now);\n }\n\n private void rs(int now,boolean[] vis,int[] ret,int k){\n  vis[now]=true;\n  ret[now]=k;\n  int to;\n  for(int i=0;i<rg[now].size();i++){\n   to=rg[now].get(i)[0];\n   if(!vis[to]) rs(to,vis,ret,k);\n  }\n }\n\n static class AL extends ArrayList<int[]>{};\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n int n=ir.nextInt();\n int m=ir.nextInt();\n int K=ir.nextInt();\n int[] a=new int[m],b=new int[m],l=new int[m];\n G g=new G(n,true);\n for(int i=0;i<m;i++){\n  a[i]=ir.nextInt()-1;\n  b[i]=ir.nextInt()-1;\n  l[i]=ir.nextInt();\n  g.addEdge(a[i],b[i],l[i]);\n }\n int[] s=ir.nextIntArray(K);\n for(int i=0;i<K;i++) s[i]--;\n int[][] d=new int[n][];\n for(int i=0;i<n;i++) d[i]=g.dijkstra(i);\n int[] md=new int[n];\n for(int i=0;i<n;i++){\n  md[i]=1<<27;\n  for(int j=0;j<K;j++){\n   md[i]=Math.min(md[i],d[i][s[j]]);\n  }\n }\n int ma=0;\n for(int i=0;i<n;i++){\n  for(int j=0;j<g.g[i].size();j++){\n   ma=Math.max(ma,(int)(md[i]+md[g.to(i,j)]+g.cost(i,j)+1)/2);\n  }\n }\n out.println(ma);\n}\n\nstatic class G{\n\n AL[] g,rg;\n private int V;\n private boolean ndir;\n\n public G(int V,boolean ndir){\n  this.V=V;\n  this.ndir=ndir;\n  g=new AL[V];\n  for(int i=0;i<V;i++) g[i]=new AL();\n }\n\n public void addEdge(int u,int v,int t){\n  g[u].add(new int[]{v,t});\n  if(this.ndir) g[v].add(new int[]{u,t});\n }\n\n public void addEdge(int u,int v){\n  addEdge(u,v,0);\n }\n\n public int to(int from,int ind){return g[from].get(ind)[0];}\n\n public int cost(int from,int ind){return g[from].get(ind)[1];}\n\n public int size(int from){return g[from].size();}\n\n public int[] dijkstra(int s){\n  int[] dist=new int[this.V];\n  java.util.PriorityQueue<int[]> pque=new java.util.PriorityQueue<int[]>(11,new Comparator<int[]>(){\n   public int compare(int[] a,int[] b){\n    return Integer.compare(a[0],b[0]);\n   }\n  });\n  Arrays.fill(dist,1<<26);\n  dist[s]=0;\n  pque.offer(new int[]{0,s});\n  while(!pque.isEmpty()){\n   int[] p=pque.poll();\n   int v=p[1];\n   if(dist[v]<p[0]) continue;\n   for(int i=0;i<g[v].size();i++){\n    int to=to(v,i),cost=cost(v,i);\n    if(dist[to]>dist[v]+cost){\n     dist[to]=dist[v]+cost;\n     pque.offer(new int[]{dist[to],to});\n    }\n   }\n  }\n  return dist;\n }\n\n public int[] tporder(){\n  boolean[] vis=new boolean[V];\n  ArrayList<Integer> ord=new ArrayList<>();\n  for(int i=0;i<V;i++) if(!vis[i]) ts(i,vis,ord);\n  int[] ret=new int[V];\n  for(int i=ord.size()-1;i>=0;i--) ret[ord.size()-1-i]=ord.get(i);\n  return ret;\n }\n\n public int[] scc(){\n  rg=new AL[V];\n  for(int i=0;i<V;i++) rg[i]=new AL();\n  int from,to;\n  for(int i=0;i<V;i++){\n   for(int j=0;j<g[i].size();j++){\n    to=i;\n    from=to(i,j);\n    rg[from].add(new int[]{to,0});\n   }\n  } \n  int[] ord=tporder();\n  int k=0;\n  boolean[] vis=new boolean[V];\n  int[] ret=new int[V+1];\n  for(int i=0;i<V;i++) if(!vis[i]) rs(ord[i],vis,ret,k++);\n  ret[V]=k;\n  return ret;\n }\n\n private void ts(int now,boolean[] vis,ArrayList<Integer> ord){\n  vis[now]=true;\n  int to;\n  for(int i=0;i<g[now].size();i++){\n   to=to(now,i);\n   if(!vis[to]) ts(to,vis,ord);\n  }\n  ord.add(now);\n }\n\n private void rs(int now,boolean[] vis,int[] ret,int k){\n  vis[now]=true;\n  ret[now]=k;\n  int to;\n  for(int i=0;i<rg[now].size();i++){\n   to=rg[now].get(i)[0];\n   if(!vis[to]) rs(to,vis,ret,k);\n  }\n }\n\n static class AL extends ArrayList<int[]>{};\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint M=10000;\n\t\twhile(in.hasNext())\n\t\t{\n\t\t\tint n=in.nextInt(), m=in.nextInt(),K=in.nextInt();\n\t\t\tdouble minmax=0;\n\t\t\tint cost[][]=new int[n+1][n+1];\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tArrays.fill(cost[i], M);\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tcost[i][i]=0;\n\t\t\tString cap[]=new String[m];\n\t\t\tfor(int i=0;i<m;i++)\n\t\t\t{\n\t\t\t\tint a=in.nextInt(),b=in.nextInt(),l=in.nextInt();\n\t\t\t\tcap[i]=a+\" \"+b+\" \"+l;\n\t\t\t\tcost[a][b]=l;\n\t\t\t\tcost[b][a]=l;\n\t\t\t}\n\t\t\tint fmo=in.nextInt();\n\t\t\tint startmo=fmo;\n\t\t\tif(K>1)\n\t\t\t\tfor(int i=1;i<K;i++)\n\t\t\t\t{\n\t\t\t\t\tint nexmo=in.nextInt();\n\t\t\t\t\tcost[fmo][nexmo]=0;\n\t\t\t\t\tcost[nexmo][fmo]=0;\n\t\t\t\t\tfmo=nexmo;\n\t\t\t\t}\n\t\t\tint leng[]=new int[n+1];// minimum distance\n\t\t\tint v[] = new int[n+1];// decision flag\n\n\t\t\tint p=0;\n\t\t\tint start =startmo;\n\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t{\n\t\t\t\tleng[k]=M;\n\t\t\t\tv[k]=0;\n\t\t\t}\n\t\t\tleng[start]=0;\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tint min=M;//最小の節点を探す\n\t\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t\t{\n\t\t\t\t\tif(v[k]==0&&leng[k]<min)\n\t\t\t\t\t{\n\t\t\t\t\t\tp=k;\n\t\t\t\t\t\tmin=leng[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tv[p]=1;//確定フラグ\n\t\t\t\tfor(int k=1;k<=n;k++) //pを経由してkに至長さがそれまでの最短経路より小さければ更新\n\t\t\t\t\tleng[k]=Math.min(leng[p]+cost[p][k], leng[k]);\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++)\n\t\t\t{\n\t\t\t\tString ss[]=cap[i].split(\" \");\n\t\t\t\tint a=Integer.valueOf(ss[0]);\n\t\t\t\tint b=Integer.valueOf(ss[1]);\n\t\t\t\tint cos=Integer.valueOf(ss[2]);\n\t\t\t\tdouble d=(leng[a]+leng[b]+cos)/2.0;\n\t\t\t\t//System.out.println(d);\n\t\t\t\tminmax= Math.max(minmax, Math.round(d));\n\t\t\t}\n\t\t\tSystem.out.printf(\"%.0f\\n\",minmax);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint M=10000;\n\t\twhile(in.hasNext())\n\t\t{\n\t\t\tint n=in.nextInt(), m=in.nextInt(),K=in.nextInt();\n\t\t\tint minmax=0;\n\t\t\tint cost[][]=new int[n+1][n+1];\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tArrays.fill(cost[i], M);\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tcost[i][i]=0;\n\t\t\tString cap[]=new String[m];\n\t\t\tfor(int i=0;i<m;i++)\n\t\t\t{\n\t\t\t\tint a=in.nextInt(),b=in.nextInt(),l=in.nextInt();\n\t\t\t\tcap[i]=a+\" \"+b+\" \"+l;\n\t\t\t\tcost[a][b]=l;\n\t\t\t\tcost[b][a]=l;\n\t\t\t}\n\t\t\tint fmo=in.nextInt();\n\t\t\tint startmo=fmo;\n\t\t\tif(K>1)\n\t\t\t\tfor(int i=1;i<K;i++)\n\t\t\t\t{\n\t\t\t\t\tint nexmo=in.nextInt();\n\t\t\t\t\tcost[fmo][nexmo]=0;\n\t\t\t\t\tcost[nexmo][fmo]=0;\n\t\t\t\t\tfmo=nexmo;\n\t\t\t\t}\n\t\t\tint leng[]=new int[n+1];// minimum distance\n\t\t\tint v[] = new int[n+1];// decision flag\n\n\t\t\tint p=0;\n\t\t\tint start =startmo;\n\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t{\n\t\t\t\tleng[k]=M;\n\t\t\t\tv[k]=0;\n\t\t\t}\n\t\t\tleng[start]=0;\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tint min=M;//最小の節点を探す\n\t\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t\t{\n\t\t\t\t\tif(v[k]==0&&leng[k]<min)\n\t\t\t\t\t{\n\t\t\t\t\t\tp=k;\n\t\t\t\t\t\tmin=leng[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tv[p]=1;//確定フラグ\n\t\t\t\tfor(int k=1;k<=n;k++) //pを経由してkに至長さがそれまでの最短経路より小さければ更新\n\t\t\t\t\tleng[k]=Math.min(leng[p]+cost[p][k], leng[k]);\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++)\n\t\t\t{\n\t\t\t\tString ss[]=cap[i].split(\" \");\n\t\t\t\tint a=Integer.valueOf(ss[0]);\n\t\t\t\tint b=Integer.valueOf(ss[1]);\n\t\t\t\tint cos=Integer.valueOf(ss[2]);\n\t\t\t\tdouble d=(leng[a]+leng[b]+cos);\n\t\t\t\td=d/2;\n\t\t\t\tminmax= (int)Math.max(minmax, Math.round(d));\n\t\t\t}\n\t\t\tSystem.out.println(minmax);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint M=10000;\n\t\twhile(in.hasNext())\n\t\t{\n\t\t\tint n=in.nextInt(), m=in.nextInt(),K=in.nextInt();\n\t\t\tdouble minmax=0;\n\t\t\tint cost[][]=new int[n+1][n+1];\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tArrays.fill(cost[i], M);\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tcost[i][i]=0;\n\t\t\tString cap[]=new String[m];\n\t\t\tfor(int i=0;i<m;i++)\n\t\t\t{\n\t\t\t\tint a=in.nextInt(),b=in.nextInt(),l=in.nextInt();\n\t\t\t\tcap[i]=a+\" \"+b+\" \"+l;\n\t\t\t\tcost[a][b]=l;\n\t\t\t\tcost[b][a]=l;\n\t\t\t}\n\t\t\tint fmo=in.nextInt();\n\t\t\tint startmo=fmo;\n\t\t\tif(K>1)\n\t\t\t\tfor(int i=1;i<K;i++)\n\t\t\t\t{\n\t\t\t\t\tint nexmo=in.nextInt();\n\t\t\t\t\tcost[fmo][nexmo]=0;\n\t\t\t\t\tcost[nexmo][fmo]=0;\n\t\t\t\t\tfmo=nexmo;\n\t\t\t\t}\n\t\t\tint leng[]=new int[n+1];// minimum distance\n\t\t\tint v[] = new int[n+1];// decision flag\n\n\t\t\tint p=0;\n\t\t\tint start =startmo;\n\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t{\n\t\t\t\tleng[k]=M;\n\t\t\t\tv[k]=0;\n\t\t\t}\n\t\t\tleng[start]=0;\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tint min=M;//最小の節点を探す\n\t\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t\t{\n\t\t\t\t\tif(v[k]==0&&leng[k]<min)\n\t\t\t\t\t{\n\t\t\t\t\t\tp=k;\n\t\t\t\t\t\tmin=leng[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tv[p]=1;//確定フラグ\n\t\t\t\tfor(int k=1;k<=n;k++) //pを経由してkに至長さがそれまでの最短経路より小さければ更新\n\t\t\t\t\tleng[k]=Math.min(leng[p]+cost[p][k], leng[k]);\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++)\n\t\t\t{\n\t\t\t\tString ss[]=cap[i].split(\" \");\n\t\t\t\tint a=Integer.valueOf(ss[0]);\n\t\t\t\tint b=Integer.valueOf(ss[1]);\n\t\t\t\tint cos=Integer.valueOf(ss[2]);\n\t\t\t\tdouble d=(leng[a]+leng[b]+cos)/2.0;\n\t\t\t\tminmax=Math.max(minmax, Math.round(d));\n\t\t\t}\n\t\t\tSystem.out.println((int)minmax);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\t\tint m = scanner.nextInt();\n\t\tint k = scanner.nextInt();\n\t\tList<Pair>[] list = new List[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tlist[i] = new ArrayList<Pair>();\n\t\twhile (m-- > 0) {\n\t\t\tint a = scanner.nextInt() - 1;\n\t\t\tint b = scanner.nextInt() - 1;\n\t\t\tint l = scanner.nextInt();\n\t\t\tlist[a].add(new Pair(b, l));\n\t\t\tlist[b].add(new Pair(a, l));\n\t\t}\n\t\tint[] dp = new int[n];\n\t\tArrays.fill(dp, 1 << 25);\n\t\tPriorityQueue<Pair> pq = new PriorityQueue<Main.Pair>();\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tint s = scanner.nextInt() - 1;\n\t\t\tdp[s] = 0;\n\t\t\tpq.offer(new Pair(0, s));\n\t\t}\n\t\twhile (!pq.isEmpty()) {\n\t\t\tPair pair = pq.poll();\n\t\t\tint f = pair.f;\n\t\t\tint s = pair.s;\n\t\t\tif (dp[s] < f)\n\t\t\t\tcontinue;\n\t\t\tfor (Pair p : list[s]) {\n\t\t\t\tif (dp[p.f] <= f + p.s)\n\t\t\t\t\tcontinue;\n\t\t\t\tdp[p.f] = f + p.s;\n\t\t\t\tpq.offer(new Pair(f + p.s, p.f));\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (dp[i] == 0)\n\t\t\t\tcontinue;\n\t\t\tfor (Pair p : list[i]) {\n\t\t\t\tint a = Math.max(dp[i], dp[p.f]);\n\t\t\t\tint b = a + (p.s - Math.abs(dp[i] - dp[p.f]) + 1) / 2;\n\t\t\t\tans = Math.max(ans, b);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tint f, s;\n\n\t\tpublic Pair(int f, int s) {\n\t\t\tsuper();\n\t\t\tthis.f = f;\n\t\t\tthis.s = s;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Pair [f=\" + f + \", s=\" + s + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn f - o.f;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\t\tint m = scanner.nextInt();\n\t\tint k = scanner.nextInt();\n\t\tList<Pair>[] list = new List[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tlist[i] = new ArrayList<Pair>();\n\t\twhile (m-- > 0) {\n\t\t\tint a = scanner.nextInt() - 1;\n\t\t\tint b = scanner.nextInt() - 1;\n\t\t\tint l = scanner.nextInt();\n\t\t\tlist[a].add(new Pair(b, l));\n\t\t\tlist[b].add(new Pair(a, l));\n\t\t}\n\t\tint[] dp = new int[n];\n\t\tArrays.fill(dp, 1 << 25);\n\t\tPriorityQueue<Pair> pq = new PriorityQueue<Main.Pair>();\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tint s = scanner.nextInt() - 1;\n\t\t\tdp[s] = 0;\n\t\t\tpq.offer(new Pair(0, s));\n\t\t}\n\t\twhile (!pq.isEmpty()) {\n\t\t\tPair pair = pq.poll();\n\t\t\tint f = pair.f;\n\t\t\tint s = pair.s;\n\t\t\tif (dp[s] < f)\n\t\t\t\tcontinue;\n\t\t\tfor (Pair p : list[s]) {\n\t\t\t\tif (dp[p.f] <= f + p.s)\n\t\t\t\t\tcontinue;\n\t\t\t\tdp[p.f] = f + p.s;\n\t\t\t\tpq.offer(new Pair(f + p.s, p.f));\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (Pair p : list[i]) {\n\t\t\t\tint a = Math.max(dp[i], dp[p.f]);\n\t\t\t\tint b = a + (p.s - Math.abs(dp[i] - dp[p.f]) + 1) / 2;\n\t\t\t\tans = Math.max(ans, b);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tint f, s;\n\n\t\tpublic Pair(int f, int s) {\n\t\t\tsuper();\n\t\t\tthis.f = f;\n\t\t\tthis.s = s;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Pair [f=\" + f + \", s=\" + s + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn f - o.f;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main \n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint M=10000;\n\t\twhile(in.hasNext())\n\t\t{\n\t\t\tint n=in.nextInt(), m=in.nextInt(),K=in.nextInt();\n\t\t\tint minmax=0;\n\t\t\tint cost[][]=new int[n+1][n+1];\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tArrays.fill(cost[i], M);\n\t\t\tfor(int i=0;i<=n;i++)\n\t\t\t\tcost[i][i]=0;\n\t\t\tString cap[]=new String[m];\n\t\t\tfor(int i=0;i<m;i++)\n\t\t\t{\n\t\t\t\tint a=in.nextInt(),b=in.nextInt(),l=in.nextInt();\n\t\t\t\tcap[i]=a+\" \"+b+\" \"+l;\n\t\t\t\tcost[a][b]=l;\n\t\t\t\tcost[b][a]=l;\n\t\t\t}\n\t\t\tint fmo=in.nextInt();\n\t\t\tint startmo=fmo;\n\t\t\tif(K>1)\n\t\t\t\tfor(int i=1;i<K;i++)\n\t\t\t\t{\n\t\t\t\t\tint nexmo=in.nextInt();\n\t\t\t\t\tcost[fmo][nexmo]=0;\n\t\t\t\t\tcost[nexmo][fmo]=0;\n\t\t\t\t\tfmo=nexmo;\n\t\t\t\t}\n\t\t\tint leng[]=new int[n+1];// minimum distance\n\t\t\tint v[] = new int[n+1];// decision flag\n\n\t\t\tint p=0;\n\t\t\tint start =startmo;\n\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t{\n\t\t\t\tleng[k]=M;\n\t\t\t\tv[k]=0;\n\t\t\t}\n\t\t\tleng[start]=0;\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tint min=M;//最小の節点を探す\n\t\t\t\tfor(int k=1;k<=n;k++)\n\t\t\t\t{\n\t\t\t\t\tif(v[k]==0&&leng[k]<min)\n\t\t\t\t\t{\n\t\t\t\t\t\tp=k;\n\t\t\t\t\t\tmin=leng[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tv[p]=1;//確定フラグ\n\t\t\t\tfor(int k=1;k<=n;k++) //pを経由してkに至長さがそれまでの最短経路より小さければ更新\n\t\t\t\t\tleng[k]=Math.min(leng[p]+cost[p][k], leng[k]);\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++)\n\t\t\t{\n\t\t\t\tString ss[]=cap[i].split(\" \");\n\t\t\t\tint a=Integer.valueOf(ss[0]);\n\t\t\t\tint b=Integer.valueOf(ss[1]);\n\t\t\t\tint cos=Integer.valueOf(ss[2]);\n\t\t\t\tdouble d=(leng[a]+leng[b]+cos);\n\t\t\t\td=d/2.0;\n\t\t\t\tminmax= (int)Math.max(minmax, Math.round(d));\n\t\t\t}\n\t\t\tSystem.out.println(minmax);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Solver.Ex;\nusing Debug = System.Diagnostics.Debug;\nusing Watch = System.Diagnostics.Stopwatch;\nusing StringBuilder = System.Text.StringBuilder;\n//using System.Numerics;\nnamespace Solver\n{\n    struct Edge\n    {\n        public int from, to, cost;\n        public Edge(int f, int t, int c) : this() { from = f; to = t; cost = c; }\n    }\n    public class Solver\n    {\n\n        public void Solve()\n        {\n            var n = sc.Integer();\n            var m = sc.Integer();\n            var k = sc.Integer();\n            var G = Enumerate(n, x => new List<KeyValuePair<int, int>>());\n            var E = new Edge[m];\n            for (int i = 0; i < m; i++)\n            {\n                var a = sc.Integer() - 1;\n                var b = sc.Integer() - 1;\n                var c = sc.Integer();\n                G[a].Add(new KeyValuePair<int, int>(b, c));\n                G[b].Add(new KeyValuePair<int, int>(a, c));\n                E[i] = new Edge(a, b, c);\n            }\n            var shop = new bool[n];\n            for (int i = 0; i < k; i++)\n            {\n                var a = sc.Integer() - 1;\n                shop[a] = true;\n            }\n            var dist=new int[n];\n            for (int i = 0; i < n; i++)\n                dist[i] = 1 << 30;\n            for (int v = 0; v < n; v++)\n            {\n                if (!shop[v]) continue;\n                dist[v] = 0;\n                var pq = new MergeablePriorityQueue<KeyValuePair<int, int>>((l,r)=>l.Value.CompareTo(r.Value));\n                pq.Enqueue(new KeyValuePair<int, int>(v, 0));\n                while(pq.Any())\n                {\n                    var p = pq.Dequeue();\n                    if (dist[p.Key] < p.Value) continue;\n                    foreach(var next in G[p.Key])\n                        if(next.Value+p.Value<dist[next.Key])\n                        {\n                            dist[next.Key] = next.Value + p.Value;\n                            pq.Enqueue(new KeyValuePair<int, int>(next.Key, dist[next.Key]));\n                        }\n\n                }\n            }\n            var ret = 0;\n            foreach(var e in E)\n            {\n                var da = dist[e.from];\n                var db = dist[e.to];\n                var l = e.cost;\n                if (da > db) { var tmp = da; da = db; db = tmp; }\n                if (db - da > l) ret = Math.Max(db, ret);\n                else ret = Math.Max(ret, (db + da + l) / 2 + (db + da + l) %2);             \n            }\n            IO.Printer.Out.WriteLine(ret);\n           \n        }\n\n\n        internal IO.StreamScanner sc;\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; i++) a[i] = f(i); return a; }\n    }\n\n    #region Main and Settings\n    static class Program\n    {\n        static void Main(string[] arg)\n        {\n#if DEBUG\n            var errStream = new System.IO.FileStream(@\"..\\..\\dbg.out\", System.IO.FileMode.Create, System.IO.FileAccess.Write, System.IO.FileShare.ReadWrite);\n            Debug.Listeners.Add(new System.Diagnostics.TextWriterTraceListener(errStream, \"debugStream\"));\n            Debug.AutoFlush = false;\n            var sw = new Watch(); sw.Start();\n            IO.Printer.Out.AutoFlush = true;\n            try\n            {\n#endif\n\n                var solver = new Solver();\n                solver.sc = new IO.StreamScanner(Console.OpenStandardInput());\n                solver.Solve();\n                IO.Printer.Out.Flush();\n#if DEBUG\n            }\n            catch (Exception ex)\n            {\n                Console.Error.WriteLine(ex.Message);\n                Console.Error.WriteLine(ex.StackTrace);\n            }\n            finally\n            {\n                sw.Stop();\n                Console.ForegroundColor = ConsoleColor.Green;\n                Console.Error.WriteLine(\"Time:{0}ms\", sw.ElapsedMilliseconds);\n                Debug.Close();\n                System.Threading.Thread.Sleep(System.Threading.Timeout.Infinite);\n            }\n#endif\n        }\n\n\n    }\n    #endregion\n}\n\n#region IO Helper\nnamespace Solver.IO\n{\n    public class Printer : System.IO.StreamWriter\n    {\n        static Printer()\n        {\n            Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false };\n#if DEBUG\n            Error = new Printer(Console.OpenStandardError()) { AutoFlush = true };\n#else\n            Error = new Printer(System.IO.Stream.Null) { AutoFlush = false };\n#endif\n        }\n        public static Printer Out { get; set; }\n        public static Printer Error { get; set; }\n        public override IFormatProvider FormatProvider { get { return System.Globalization.CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new System.Text.UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, System.Text.Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, IEnumerable<T> source) { Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, IEnumerable<T> source) { WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(System.IO.Stream stream) { iStream = stream; }\n        private readonly System.IO.Stream iStream;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        private bool eof = false;\n        public bool IsEndOfStream { get { return eof; } }\n        const byte lb = 33, ub = 126, el = 10, cr = 13;\n        public byte read()\n        {\n            if (eof) throw new System.IO.EndOfStreamException();\n            if (ptr >= len) { ptr = 0; if ((len = iStream.Read(buf, 0, 1024)) <= 0) { eof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while (b < lb || ub < b);            return (char)b; }\n        public char[] Char(int n) { var a = new char[n]; for (int i = 0; i < n; i++) a[i] = Char(); return a; }\n        public char[][] Char(int n, int m) { var a = new char[n][]; for (int i = 0; i < n; i++) a[i] = Char(m); return a; }\n        public string Scan()\n        {\n            if (eof) throw new System.IO.EndOfStreamException();\n            StringBuilder sb = null;\n            var enc = System.Text.UTF8Encoding.Default;\n            do\n            {\n                for (; ptr < len && (buf[ptr] < lb || ub < buf[ptr]); ptr++) ;\n                if (ptr < len) break;\n                ptr = 0;\n                if ((len = iStream.Read(buf, 0, 1024)) <= 0) { eof = true; return \"\"; }\n            } while (true);\n            do\n            {\n                var f = ptr;\n                for (; ptr < len; ptr++)\n                    if (buf[ptr] < lb || ub < buf[ptr])\n                    //if (buf[ptr] == cr || buf[ptr] == el)\n                    {\n                        string s;\n                        if (sb == null) s = enc.GetString(buf, f, ptr - f);\n                        else { sb.Append(enc.GetChars(buf, f, ptr - f)); s = sb.ToString(); }\n                        ptr++; return s;\n                    }\n                if (sb == null) sb = new StringBuilder(enc.GetString(buf, f, len - f));\n                else sb.Append(enc.GetChars(buf, f, len - f));\n                ptr = 0;\n\n            }\n            while (!eof && (len = iStream.Read(buf, 0, 1024)) > 0);\n            eof = true; return (sb != null) ? sb.ToString() : \"\";\n        }\n        public long Long()\n        {\n            long ret = 0; byte b = 0; bool isMynus = false;\n            const byte zr = 48, nn = 57, my = 45;\n            do b = read();\n            while (b != my && (b < zr || nn < b));\n            if (b == my) { isMynus = true; b = read(); }\n            for (; true; b = read())\n                if (b < zr || nn < b)\n                    return isMynus ? -ret : ret;\n                else ret = ret * 10 + b - zr;\n        }\n        public int Integer()\n        {\n            int ret = 0; byte b = 0; bool isMynus = false;\n            const byte zr = 48, nn = 57, my = 45;\n            do b = read();\n            while (b != my && (b < zr || nn < b));\n            if (b == my) { isMynus = true; b = read(); }\n            for (; true; b = read())\n                if (b < zr || nn < b)\n                    return isMynus ? -ret : ret;\n                else ret = ret * 10 + b - zr;\n        }\n        public double Double() { return double.Parse(Scan(), System.Globalization.CultureInfo.InvariantCulture); }\n        public string[] Scan(int n) { var a = new string[n]; for (int i = 0; i < n; i++) a[i] = Scan(); return a; }\n        public double[] Double(int n) { var a = new double[n]; for (int i = 0; i < n; i++) a[i] = Double(); return a; }\n        public int[] Integer(int n) { var a = new int[n]; for (int i = 0; i < n; i++) a[i] = Integer(); return a; }\n        public long[] Long(int n) { var a = new long[n]; for (int i = 0; i < n; i++)a[i] = Long(); return a; }\n        public void Flush() { iStream.Flush(); }\n    }\n}\n#endregion\n#region Extension\nnamespace Solver.Ex\n{\n    static public partial class EnumerableEx\n    {\n        static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n        //static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") { return string.Join(st, ie); }\n    }\n}\n#endregion\n#region PriorityQueue and PairingHeap\npublic class MergeablePriorityQueue<T>\n{\n    PairingHeap<T> top;\n    Comparison<T> compare;\n    int size;\n    public int Count { get { return size; } }\n    public MergeablePriorityQueue() : this(Comparer<T>.Default) { }\n    public MergeablePriorityQueue(Comparison<T> comparison) { compare = comparison; }\n    public MergeablePriorityQueue(IComparer<T> comparer) { compare = comparer.Compare; }\n    public void Enqueue(T item)\n    {\n        var heap = new PairingHeap<T>(item);\n        top = PairingHeap<T>.Merge(top, heap, compare);\n        size++;\n    }\n    public T Dequeue()\n    {\n        var ret = top.Key;\n        size--;\n        top = PairingHeap<T>.Pop(top, compare);\n        return ret;\n    }\n    public bool Any() { return size > 0; }\n    public T Peek() { return top.Key; }\n}\n\n#region PairingHeap\npublic class PairingHeap<T>\n{\n    public PairingHeap(T k) { key = k; }\n    private readonly T key;\n    public T Key { get { return key; } }\n    private PairingHeap<T> head;\n    private PairingHeap<T> next;\n    static public PairingHeap<T> Pop(PairingHeap<T> s, Comparison<T> compare)\n    {\n        return MergeLst(s.head, compare);\n    }\n    static public PairingHeap<T> Merge(PairingHeap<T> l, PairingHeap<T> r, Comparison<T> compare)\n    {\n        if (l == null || r == null) return l == null ? r : l;\n        if (compare(l.key, r.key) > 0) Swap(ref l, ref r);\n        r.next = l.head;\n        l.head = r;\n        return l;\n    }\n    static public PairingHeap<T> MergeLst(PairingHeap<T> s, Comparison<T> compare)\n    {\n        var n = new PairingHeap<T>(default(T));\n        while (s != null)\n        {\n            PairingHeap<T> a = s, b = null;\n            s = s.next; a.next = null;\n            if (s != null) { b = s; s = s.next; b.next = null; }\n            a = Merge(a, b, compare); a.next = n.next;\n            n.next = a;\n        }\n        while (n.next != null)\n        {\n            var j = n.next;\n            n.next = n.next.next;\n            s = Merge(j, s, compare);\n        }\n        return s;\n    }\n    static void Swap(ref PairingHeap<T> l, ref PairingHeap<T> r) { var t = l; l = r; r = t; }\n}\n#endregion\n#endregion\n"
  },
  {
    "language": "Ruby",
    "code": "def calc(a, b, c)\n  (a+b+c+1)/2\nend\n\nn, m, k = gets.split.map(&:to_i)\nl1 = Array.new(n){ [0]*n }\nl2 = Array.new(n){ [] }\nl3 = []\nm.times do\n  a, b, c = gets.split.map(&:to_i)\n  a -= 1; b -= 1\n  l1[a][b] = l1[b][a] = c\n  l2[a] << b; l2[b] << a\n  l3 << [a,b,c]\nend\narr = []\ndist = [1<<31]*n\nk.times do\n  arr << i\n  dist[i] = 0\nend\n\nuntil arr.empty?\n  s = arr.min{ |a,b| dist[a] <=> dist[b] }\n  arr.delete s\n  l2[s].each do |t|\n    d = dist[s] + l1[s][t]\n    if (old = dist[t]) > d\n      dist[t] = d\n      arr << t if old == 1 << 31\n    end\n  end\nend\nret = 0\nm.times{ |i| ret = [ret, calc(dist[l3[i][0]], dist[l3[i][1]], l3[i][2])].max }\np ret"
  },
  {
    "language": "Ruby",
    "code": "def calc(a, b, c)\n  a,b = b,a if a > b\n  (c-(b-a)+1)/2 + b\nend\n\nn, m, k = gets.split.map(&:to_i)\nl1 = n.times.map{ [1<<31]*n }\nl2 = n.times.map{ [] }\nl3 = []\nn.times{ |i| l1[i][i] = -1 }\nm.times do\n  a, b, c = gets.split.map(&:to_i)\n  a -= 1; b -= 1\n  l1[a][b] = l1[b][a] = c\n  l2[a] << b; l2[b] << a\n  l3 << [a,b,c]\nend\n\nvisited = n.times.map{ false }\narr = []\ndist = n.times.map{ 1<<31 }\nk.times do\n  visited[i = gets.to_i - 1] = true\n  arr << i\n  dist[i] = 0\nend\n\nuntil arr.empty?\n  s = arr.min{ |a,b| dist[a] <=> dist[b] }\n  arr.delete s\n  l2[s].each do |t|\n    d = dist[s] + l1[s][t]\n    if (old = dist[t]) > d\n      dist[t] = d\n      arr << t if old == 1 << 31\n    end\n  end\nend\nret = 0\nm.times{ |i| ret = [ret, calc(dist[l3[i][0]], dist[l3[i][1]], l3[i][2])].max }\np ret"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif @array[i][1] < @array[j][1]\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if new_key >= @array[i][1]\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif @array[i][1] > @array[j][1]\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = (@array[j][1] < @array[k][1] ? j : k)\n\t\t\tif @array[i][1] > @array[l][1]\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graph\n\trequire 'set'\n\tdef add_node(label = nil)\n\t\tNode.new(label)\n\tend\n\n\tdef add_edge(u, v, label = nil)\n\t\te = Edge.new(u, v, label)\n\t\tu.outgoings << e\n\t\tv.incomings << e\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.outgoings.delete(e)\n\t\tv.incomings.delete(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(label)\n\t\t\t@label = label\n\t\t\t@outgoings = Set.new\n\t\t\t@incomings = Set.new\n\t\tend\n\n\t\tdef to_nodes\n\t\t\t@outgoings.map(&:to)\n\t\tend\n\n\t\tdef from_nodes\n\t\t\t@incomings.map(&:from)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@label\n\t\tend\n\t\t\n\t\tattr_accessor :incomings, :outgoings\n\t\tattr_reader :label\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, label = nil)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\t\t@label = label\n\t\tend\n\t\tattr_reader :from, :to, :label\n\tend\n\n\tdef get_path_bfs(s, t)\n\t\tpath_edge = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\tu.outgoings.each{|e|\n\t\t\t\tv = e.to\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tpath_edge[v] = e\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = []\n\t\t\t\t\twhile e = path_edge[v]\n\t\t\t\t\t\tpath.unshift e\n\t\t\t\t\t\tv = e.from\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_path_dfs(s, t, reached = Set.new)\n\t\treached << s\t\n\t\ts.outgoings.each{|e|\n\t\t\tv = e.to\n\t\t\tnext if reached.include?(v)\n\t\t\treturn [e] if v == t\n\t\t\t\n\t\t\tpath = get_path_dfs(v, t, reached) \n\t\t\treturn [e] + path if path\n\t\t}\n\t\tnil\n\tend\n\n\tdef layers_from(start)\n\t\treached = Set[*start]\n\t\tlayers = [start]\n\n\t\tloop {\n\t\t\tlayers << []\n\t\t\tlayers[-2].each{|u|\n\t\t\t\tu.to_nodes.each{|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tlayers[-1] << v\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\tif layers[-1].empty?\n\t\t\t\tlayers.pop\n\t\t\t\treturn layers\n\t\t\tend\n\t\t}\n\tend\n\n\tdef reachable_from(s, reached = Set.new, root = true)\n\t\treached << s\t\n\t\ts.outgoings.each{|e|\n\t\t\tv = e.to\n\t\t\tnext if reached.include?(v)\n\t\t\treachable_from(v, reached, false) \n\t\t}\n\t\troot ? reached : nil\n\tend\n\n\tdef dijkstra(s, t = nil)\n\t\tif t && t.class != Set\n\t\t\tt = Set[t]\n\t\tend\n\t\tdist = {}\n\t\th = Heap.new\n\t\th.add(s, 0)\n\t\treached = Set[s]\n\t\tuntil h.size == 0\n\t\t\tu, key = h.del_min\n\t\t\treturn key if t.include?(u)\n\t\t\tdist[u] = key\n\t\t\tu.outgoings.each{|e|\n\t\t\t\tv = e.to\n\t\t\t\td = dist[u] + e.label\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tt ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\tu.outgoings.each{|e|\n\t\t\t\t\tv = e.to\n\t\t\t\t\td = f_dist[u] + e.label\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\tu.incomings.each{|e|\n\t\t\t\t\tv = e.from\n\t\t\t\t\td = b_dist[u] + e.label\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\nend\n\ninclude Graph\n\nn, m, k = gets.split.map &:to_i\n\nnodes = [nil] + (1..n).map{ add_node }\n\nedges = []\nm.times {\n\ti, j, l = gets.split.map &:to_i\n\tu = nodes[i]\n\tv = nodes[j]\n\tedges << add_edge(u, v, l)\n\tadd_edge(v, u, l)\n}\n\nshop = Set.new \nk.times {\n\tshop << nodes[gets.to_i]\n}\n\nto_shop = {}\nnodes[1..-1].each{|v|\n\tto_shop[v] = dijkstra(v, shop)\n}\n\np edges.map{|e|\n\tu, v, l = e.from, e.to, e.label\n\tdu = to_shop[u]\n\tdv = to_shop[v]\n\t(dv + du + l) / 2.0 \n}.max.round"
  },
  {
    "language": "Ruby",
    "code": "def calc(a, b, c)\n  (a+b+c+1)/2\nend\n\nn, m, k = gets.split.map(&:to_i)\nl1 = Array.new(n){ [0]*n }\nl2 = Array.new(n){ [] }\nl3 = []\nm.times do\n  a, b, c = gets.split.map(&:to_i)\n  a -= 1; b -= 1\n  l1[a][b] = l1[b][a] = c\n  l2[a] << b; l2[b] << a\n  l3 << [a,b,c]\nend\n\nvisited = [false]*n\narr = []\ndist = [1<<31]*n\nk.times do\n  visited[i = gets.to_i - 1] = true\n  arr << i\n  dist[i] = 0\nend\n\nuntil arr.empty?\n  s = arr.min{ |a,b| dist[a] <=> dist[b] }\n  arr.delete s\n  l2[s].each do |t|\n    d = dist[s] + l1[s][t]\n    if (old = dist[t]) > d\n      dist[t] = d\n      arr << t if old == 1 << 31\n    end\n  end\nend\nret = 0\nm.times{ |i| ret = [ret, calc(dist[l3[i][0]], dist[l3[i][1]], l3[i][2])].max }\np ret"
  },
  {
    "language": "Ruby",
    "code": "def calc(a, b, c)\n  a,b = b,a if a > b\n  (c-(b-a)+1)/2 + b\nend\n\nn, m, k = gets.split.map(&:to_i)\nl1 = Array.new(n){ Array.new(n, 1<<31) }\nl2 = n.times.map{[]}\nl3 = []\nn.times{ |i| l1[i][i] = -1 }\nm.times do\n  a, b, c = gets.split.map(&:to_i)\n  a -= 1; b -= 1\n  l1[a][b] = l1[b][a] = c\n  l2[a] << b; l2[b] << a\n  l3 << [a,b,c]\nend\n\nvisited = n.times.map{ false }\narr = []\ndist = n.times.map{ 1<<31 }\nk.times do\n  visited[n = gets.to_i - 1] = true\n  arr << n\n  dist[n] = 0\nend\n\nuntil arr.empty?\n  s = arr.min{ |a,b| dist[a] <=> dist[b] }\n  arr.delete s\n  l2[s].each do |t|\n    d = dist[s] + l1[s][t]\n    if (old = dist[t]) > d\n      dist[t] = d\n      arr << t if old == 1 << 31\n    end\n  end\nend\np m.times.map{ |i| calc(dist[l3[i][0]], dist[l3[i][1]], l3[i][2]) }.max"
  },
  {
    "language": "Ruby",
    "code": "def calc(a, b, c)\n  a,b = b,a if a > b\n  (c-(b-a)+1)/2 + b\nend\n\nn, m, k = gets.split.map(&:to_i)\nl1 = Array.new(n){ Array.new(n, 1<<31) }\nl2 = n.times.map{[]}\nl3 = []\nn.times{ |i| l1[i][i] = -1 }\nm.times do\n  a, b, c = gets.split.map(&:to_i)\n  a -= 1; b -= 1\n  l1[a][b] = l1[b][a] = c\n  l2[a] << b; l2[b] << a\n  l3 << [a,b,c]\nend\n\nvisited = n.times.map{ false }\narr = []\ndist = n.times.map{ 1<<31 }\nk.times do\n  visited[i = gets.to_i - 1] = true\n  arr << i\n  dist[i] = 0\nend\n\nuntil arr.empty?\n  s = arr.min{ |a,b| dist[a] <=> dist[b] }\n  arr.delete s\n  l2[s].each do |t|\n    d = dist[s] + l1[s][t]\n    if (old = dist[t]) > d\n      dist[t] = d\n      arr << t if old == 1 << 31\n    end\n  end\nend\nret = 0\nm.times{ |i| ret = [ret, calc(dist[l3[i][0]], dist[l3[i][1]], l3[i][2])].max }\np ret"
  },
  {
    "language": "Ruby",
    "code": "def calc(a, b, c)\n  a,b = b,a if a > b\n  (c-(b-a)+1)/2 + b\nend\n\nn, m, k = gets.split.map(&:to_i)\nl1 = Array.new(n){ [1<<31]*n }\nl2 = Array.new(n){ [] }\nl3 = []\nn.times{ |i| l1[i][i] = -1 }\nm.times do\n  a, b, c = gets.split.map(&:to_i)\n  a -= 1; b -= 1\n  l1[a][b] = l1[b][a] = c\n  l2[a] << b; l2[b] << a\n  l3 << [a,b,c]\nend\n\nvisited = [false]*n\narr = []\ndist = [1<<31]*n\nk.times do\n  visited[i = gets.to_i - 1] = true\n  arr << i\n  dist[i] = 0\nend\n\nuntil arr.empty?\n  s = arr.min{ |a,b| dist[a] <=> dist[b] }\n  arr.delete s\n  l2[s].each do |t|\n    d = dist[s] + l1[s][t]\n    if (old = dist[t]) > d\n      dist[t] = d\n      arr << t if old == 1 << 31\n    end\n  end\nend\nret = 0\nm.times{ |i| ret = [ret, calc(dist[l3[i][0]], dist[l3[i][1]], l3[i][2])].max }\np ret"
  },
  {
    "language": "Ruby",
    "code": "def calc(a, b, c)\n  a,b = b,a if a > b\n  (c-(b-a)+1)/2 + b\nend\nn, m, k = gets.split.map(&:to_i)\nl = Array.new(n, 1<<31)\nt = m.times.map{ gets.split.map(&:to_i) }\nm.times{ |i| t[i][0] -= 1; t[i][1] -= 1 }\nk.times{ l[gets.to_i-1] = 0 }\nn.times do\n  for a in (0...m)\n    for b in (0...2)\n      l[t[a][b]] = [l[t[a][b]], l[t[a][1-b]] + t[a][2]].min\n    end\n  end\nend\np m.times.map{ |i| calc(l[t[i][0]], l[t[i][1]], t[i][2]) }.max"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_INT = 1 << 30\n\n### main\n\nn, m, k = gets.strip.split(' ').map{|s| s.to_i}\n\nedges = n.times.map{[]}\nnbrs = n.times.map{[]}\n\nm.times do\n  a, b, l = gets.strip.split(' ').map{|s| s.to_i}\n  a -= 1\n  b -= 1\n\n  edges[a][b] = edges[b][a] = l\n  nbrs[a] << b\n  nbrs[b] << a\nend\n#p edges\n#p nbrs\n\nsms = n.times.map{false}\n\nk.times do\n  si = gets.strip.to_i\n  sms[si - 1] = true\nend\n#p sms\n\ndists = n.times.map{MAX_INT}\nq = []\n\nfor st in (0...n)\n  if sms[st]\n    q << st\n    dists[st] = 0\n  end\nend\n\nwhile ! q.empty?\n  u = q.min{|a, b| dists[a] <=> dists[b]}\n  q.delete u\n\n  for v in nbrs[u]\n    dv = dists[v]\n    d = dists[u] + edges[u][v]\n    if dists[v] > d\n      dists[v] = d\n      q << v if dv >= MAX_INT\n    end\n  end\nend\n\nmax_dist = 0\n\nfor s0 in (0...n)\n  d0 = dists[s0]\n  for s1 in nbrs[s0]\n    d1 = dists[s1]\n    l = edges[s0][s1]\n\n    d = (l + d1 - d0 + 1) / 2 + d0\n    max_dist = d if max_dist < d\n  end\nend\n\nputs max_dist"
  },
  {
    "language": "Ruby",
    "code": "def calc(a, b, c)\n  (a+b+c+1)/2\nend\n\nn, m, k = gets.split.map(&:to_i)\nl1 = Array.new(n){ [0]*n }\nl2 = Array.new(n){ [] }\nl3 = []\nm.times do\n  a, b, c = gets.split.map(&:to_i)\n  a -= 1; b -= 1\n  l1[a][b] = l1[b][a] = c\n  l2[a] << b; l2[b] << a\n  l3 << [a,b,c]\nend\narr = []\ndist = [1<<31]*n\nk.times do\n  i = gets.to_i-1\n  arr << i\n  dist[i] = 0\nend\n\nuntil arr.empty?\n  s = arr.min{ |a,b| dist[a] <=> dist[b] }\n  arr.delete s\n  l2[s].each do |t|\n    d = dist[s] + l1[s][t]\n    if (old = dist[t]) > d\n      dist[t] = d\n      arr << t if old == 1 << 31\n    end\n  end\nend\nret = 0\nm.times{ |i| ret = [ret, calc(dist[l3[i][0]], dist[l3[i][1]], l3[i][2])].max }\np ret"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif @array[i][1] < @array[j][1]\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if new_key >= @array[i][1]\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif @array[i][1] > @array[j][1]\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = (@array[j][1] < @array[k][1] ? j : k)\n\t\t\tif @array[i][1] > @array[l][1]\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graph\n\trequire 'set'\n\tdef add_node(label = nil)\n\t\tNode.new(label)\n\tend\n\n\tdef add_edge(u, v, label = nil)\n\t\te = Edge.new(u, v, label)\n\t\tu.outgoings << e\n\t\tv.incomings << e\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.outgoings.delete(e)\n\t\tv.incomings.delete(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(label)\n\t\t\t@label = label\n\t\t\t@outgoings = Set.new\n\t\t\t@incomings = Set.new\n\t\tend\n\n\t\tdef to_nodes\n\t\t\t@outgoings.map(&:to)\n\t\tend\n\n\t\tdef from_nodes\n\t\t\t@incomings.map(&:from)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@label\n\t\tend\n\t\t\n\t\tattr_accessor :incomings, :outgoings\n\t\tattr_reader :label\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, label = nil)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\t\t@label = label\n\t\tend\n\t\tattr_reader :from, :to, :label\n\tend\n\n\tdef dijkstra(s, t = nil)\n\t\tt = Set[t] if t && t.class != Set\n\t\tdist = {}\n\t\th = Heap.new\n\t\ts.each{|v| h.add(v, 0)}\n\t\treached = s.dup\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if t && t.include?(u)\n\t\t\tdist[u] = key\n\t\t\tu.outgoings.each{|e|\n\t\t\t\tv = e.to\n\t\t\t\td = dist[u] + e.label\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tt ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tf_heap = Heap.new\n\t\tf_heap.add(s, 0)\n\t\tf_reached = Set[s]\n\n\t\tb_dist = {}\n\t\tb_heap = Heap.new\n\t\tif t.class == Set\n\t\t\tt.each{|v| b_heap.add(v, 0)}\n\t\t\tb_reached = t.dup\n\t\tend\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\tu.outgoings.each{|e|\n\t\t\t\t\tv = e.to\n\t\t\t\t\td = f_dist[u] + e.label\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\tu.incomings.each{|e|\n\t\t\t\t\tv = e.from\n\t\t\t\t\td = b_dist[u] + e.label\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\nend\n\ninclude Graph\n\nn, m, k = gets.split.map &:to_i\n\nnodes = [nil] + (1..n).map{ add_node }\n\nedges = []\nm.times {\n\ti, j, l = gets.split.map &:to_i\n\tu = nodes[i]\n\tv = nodes[j]\n\tedges << add_edge(u, v, l)\n\tadd_edge(v, u, l)\n}\n\nshop = Set.new \nk.times {\n\tshop << nodes[gets.to_i]\n}\n\nto_shop = {}\nto_shop = dijkstra(shop)\n\np edges.map{|e|\n\tu, v, l = e.from, e.to, e.label\n\tdu = to_shop[u]\n\tdv = to_shop[v]\n\t(dv + du + l) / 2.0 \n}.max.round"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nstruct Edge {\n    int from, to;\n    int cost;\n}\n\nstruct State {\n    int v;\n    int cost;\n    int opCmp(const ref State s) const {\n        return cost - s.cost;\n    }\n}\n\nvoid main() {\n    int N, M, K;\n    readf(\"%d %d %d\\n\", &N, &M, &K);\n    Edge[][] G = new Edge[][N];\n    foreach (i; 0 .. M) {\n        int a, b, l; readf(\"%d %d %d\\n\", &a, &b, &l);\n        a--; b--;\n        G[a] ~= Edge(a, b, l);\n        G[b] ~= Edge(b, a, l);\n    }\n    int[] D = new int[N];\n    D[] = int.max / 2;\n    BinaryHeap!(Array!State, \"a > b\") Q;\n    foreach (i; 0 .. K) {\n        int s; readf(\"%d\\n\", &s);\n        s--;\n        D[s] = 0; \n        Q.insert(State(s, 0));\n    }\n    // dijkstra\n    while (!Q.empty) {\n        State s = Q.front; Q.removeFront;\n        foreach (e; G[s.v]) {\n            if (D[e.to] > D[s.v] + e.cost) {\n                D[e.to] = D[s.v] + e.cost;\n                Q.insert(State(e.to, D[e.to]));\n            }\n        }\n    }\n    int ans = 0;\n    foreach (i; 0 .. N) {\n        ans = max(ans, D[i]);\n    }\n    foreach (i; 0 .. N) {\n        foreach (e; G[i]) {\n            static int div2(int x) {\n                return (x + 1) / 2;\n            }\n            ans = max(ans, div2(D[e.from] + D[e.to] + e.cost));\n        }\n    }\n    ans.writeln;\n}"
  },
  {
    "language": "D",
    "code": "import core.stdc.stdio;\nimport std.container;\nimport std.algorithm;\nimport std.typecons;\nimport std.stdio;\n\nvoid main(){\n\tint n,m,k;\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\talias Tuple!(int,\"cost\",int,\"to\") ct;\n\tct[][] graph = new ct[][n];\n\talias Tuple!(int,\"a\",int,\"b\",int,\"l\") edge;\n\tedge[] es = new edge[m];\n\tforeach(ref e;es){\n\t\tscanf(\"%d%d%d\",&e.a,&e.b,&e.l);\n\t\tgraph[--e.a]~=ct(e.l,--e.b);\n\t\tgraph[e.b]~=ct(e.l,e.a);\n\t}\n\tauto pq = BinaryHeap!(ct[],\"a>b\")(new ct[n+m],0);\n\tint[] nc = new int[n];\n\tnc[] = 1145141919;\n\tforeach(i;0..k){\n\t\tint a;\n\t\tscanf(\"%d\",&a);\n\t\tnc[--a]=0;\n\t\tpq.insert(ct(0,a));\n\t}\n\twhile(!pq.empty){\n\t\tauto t=pq.front;\n\t\tpq.popFront;\n\t\twith(t){\n\t\t\tif(cost>nc[to])\n\t\t\t\tcontinue;\n\t\t\tforeach(c;graph[to]){\n\t\t\t\tif(nc[c.to]>cost+c.cost){\n\t\t\t\t\tnc[c.to]=cost+c.cost;\n\t\t\t\t\tpq.insert(ct(cost+c.cost,c.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans;\n\tforeach(e;es)\n\t\tans = max(ans,e.l+nc[e.a]+nc[e.b]);\n\tprintf(\"%d\\n\",(ans+1)/2);\n}"
  },
  {
    "language": "Python",
    "code": "import heapq\n\nn,m,K=map(int,raw_input().split())\ng=[[] for _ in xrange(n)]\ncost=[[10**5]*n for _ in xrange(n)]\n\nfor i in xrange(m):\n    a,b,l=map(int,raw_input().split())\n    a-=1;b-=1\n    g[a].append(b)\n    g[b].append(a)\n    cost[a][b]=l\n    cost[b][a]=l\n\npq=[]\nd=[float('inf')]*n\nfor i in xrange(K):\n    c=int(raw_input())-1\n    heapq.heappush(pq,[0,c])\n    d[c]=0\nwhile len(pq)!=0:\n    t,u=heapq.heappop(pq)\n    if d[u]<t:\n        continue\n    for v in g[u]:\n        if d[u]+cost[u][v]<d[v]:\n            d[v]=d[u]+cost[u][v]\n            heapq.heappush(pq,[d[v],v])\n\nans=0\nfor i in xrange(n):\n    for j in g[i]:\n        ans=max(ans,(1+d[i]+d[j]+cost[i][j])/2)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import heapq\n\ndef dijkstra(s,g,c):\n    visited=[0]*(n+m)\n    d=[float('inf')]*(n+m)\n    d[s]=0\n    heapq.heappush(pq,[0,s])\n    while len(pq)!=0:\n        t,u=heapq.heappop(pq)\n        visited[u]=2\n        if d[u]<t:\n            continue\n        for v in g[u]:\n            if visited[v]!= 2:\n                if d[u]+c[u][v]<d[v]:\n                    d[v]=d[u]+c[u][v]\n                    visited[v]=1\n                    heapq.heappush(pq,[d[v],v])\n    return d\n\nn,m,k=map(int,raw_input().split())\ng=[[] for _ in xrange(n+m)]\ncost=[[0]*(n+m) for _ in xrange(n+m)]\n\nfor i in xrange(m):\n    a,b,l=map(int,raw_input().split())\n    a-=1;b-=1;c=n+i\n    g[a].append(c)\n    g[c].append(a)\n    g[b].append(c)\n    g[c].append(b)\n    cost[a][c]=l/2.0\n    cost[b][c]=l/2.0\n    cost[c][a]=cost[a][c]\n    cost[c][b]=cost[b][c]\n\nshop=[int(raw_input()) for _ in xrange(k)]\nans=float('inf')\nfor i in xrange(k):\n    pq=[]\n    dis=dijkstra(shop[i],g,cost)\n    ans=min(ans,max(dis))\n\nprint(int(round(ans)))"
  },
  {
    "language": "Python",
    "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\ndef solve():\n  \n  INF = 10 ** 18\n  \n  class edge:\n    def __init__(self, to, cost):\n      self.to = to\n      self.cost = cost\n  \n  N, M, K = map(int,input().split())\n  \n  G = [[] for i in range(N)]\n  #G[i]...頂点iからの辺list、(行き先、コスト)\n  \n  d = [INF for i in range(N)]\n  #d[i]...スタートからみた頂点iまでの最短距離\n  \n  def dijkstra(lst):\n    que = []\n    for s in lst:\n      d[s] = 0\n      push(que, (0,s))\n  \n    while len(que):\n      p = pop(que)\n      v = p[1]\n      if (d[v] < p[0]):\n        continue\n      for i in range(len(G[v])):\n        e = G[v][i]\n        if d[e.to] > d[v] + e.cost:\n          d[e.to] = d[v] + e.cost\n          push(que, (d[e.to], e.to))\n  \n  for i in range(M):\n    s, t, c = map(int,input().split())\n    s -= 1\n    t -= 1\n    G[s].append(edge(t,c))\n    G[t].append(edge(s,c))\n  \n  \n  lst =  [int(input()) - 1 for i in range(K)]\n  dijkstra(lst)\n  \n  anss = []\n  append = anss.append\n  \n  for i in range(N):\n    for e in G[i]:\n      x = d[i] + d[e.to] + e.cost\n      if x % 2:\n        append(x // 2 + 1)\n      else:\n        append(x // 2)\n  \n  print(max(anss))\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\n\nINF = 10 ** 18\n\nclass edge:\n  def __init__(self, to, cost):\n    self.to = to\n    self.cost = cost\n\n#V, E, r = map(int,input().split())\nN, M, K = map(int,input().split())\n\nG = [[] for i in range(N)]\n#G[i]...頂点iからの辺list、(行き先、コスト)\n\nd = [INF for i in range(N)]\n#d[i]...スタートからみた頂点iまでの最短距離\n\ndef dijkstra(lst):\n  que = []\n  for s in lst:\n    d[s] = 0\n    push(que, (0,s))\n\n  while len(que):\n    p = pop(que)\n    v = p[1]\n    if (d[v] < p[0]):\n      continue\n    for i in range(len(G[v])):\n      e = G[v][i]\n      if d[e.to] > d[v] + e.cost:\n        d[e.to] = d[v] + e.cost\n        push(que, (d[e.to], e.to))\n\nfor i in range(M):\n  s, t, c = map(int,input().split())\n  s -= 1\n  t -= 1\n  G[s].append(edge(t,c))\n  G[t].append(edge(s,c))\n\n\nlst =  [int(input()) - 1 for i in range(K)]\ndijkstra(lst)\n\nanss = []\nappend = anss.append\n\nfor i in range(N):\n  for e in G[i]:\n    x = d[i] + d[e.to] + e.cost\n    if x % 2:\n      append(x // 2 + 1)\n    else:\n      append(x // 2)\n\nprint(max(anss))\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nShopping in JOI Kingdom\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0562\n\n\"\"\"\nimport sys\nfrom heapq import heappush, heappop\nfrom itertools import combinations\n\n\ndef dijkstra(adj, s):\n    WHITE, GRAY, BLACK = 0, 1, 2\n    color = [WHITE] * len(adj)\n    d = [float('inf')] * len(adj)\n    d[s] = 0\n    pq = []\n    heappush(pq, (0, s))\n    while pq:\n        cost, u = heappop(pq)\n        color[u] = BLACK\n        if d[u] < cost:\n            continue\n        for v, cost in adj[u]:\n            if color[v] == BLACK:\n                continue\n            if d[v] > d[u] + cost:\n                d[v] = d[u] + cost\n                heappush(pq, (d[v], v))\n                color[v] = GRAY\n    return d\n\n\ndef solve(adj, malls, n):\n    distance = dijkstra(adj, malls[0])\n    ans = [max([(d + j[1] + distance[j[0]])/2 for j in adj[n]]) for n, d in enumerate(distance[1:], start=1)]\n    return int(max(ans) + 0.5) \n\n\ndef main(args):\n    n, m, k = map(int, input().split())\n    adj = [[] for _ in range(n+1)]\n    for _ in range(m):\n        f,t, c = map(int, input().split())\n        adj[f].append((t, c))\n        adj[t].append((f, c))\n\n    malls = [int(input()) for _ in range(k)]\n    for f, t in combinations(malls, 2):\n        adj[f].append((t, 0))\n        adj[t].append((f, 0))\n    ans = solve(adj, malls, n)\n    print(ans)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n"
  }
]