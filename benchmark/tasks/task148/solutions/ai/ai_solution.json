[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_N 5000\n#define MAX_M 100000\n\ntypedef struct {\n    int town;\n    int distance;\n} Node;\n\ntypedef struct {\n    int to;\n    int length;\n    int next;\n} Edge;\n\nEdge edges[MAX_M * 2];\nint head[MAX_N + 1];\nint edge_count = 0;\nint shopping[MAX_N + 1];\nint dist[MAX_N + 1];\n\nvoid add_edge(int from, int to, int length) {\n    edges[edge_count].to = to;\n    edges[edge_count].length = length;\n    edges[edge_count].next = head[from];\n    head[from] = edge_count++;\n}\n\nvoid dijkstra(int n) {\n    Node heap[MAX_N * 10];\n    int heap_size = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        if (shopping[i]) {\n            heap[heap_size].town = i;\n            heap[heap_size].distance = 0;\n            heap_size++;\n            dist[i] = 0;\n        } else {\n            dist[i] = INT_MAX;\n        }\n    }\n\n    while (heap_size > 0) {\n        Node current = heap[0];\n        heap[0] = heap[--heap_size];\n        int idx = 0;\n        while (1) {\n            int left = 2 * idx + 1;\n            int right = 2 * idx + 2;\n            int smallest = idx;\n            if (left < heap_size && heap[left].distance < heap[smallest].distance) {\n                smallest = left;\n            }\n            if (right < heap_size && heap[right].distance < heap[smallest].distance) {\n                smallest = right;\n            }\n            if (smallest == idx) break;\n            Node temp = heap[idx];\n            heap[idx] = heap[smallest];\n            heap[smallest] = temp;\n            idx = smallest;\n        }\n\n        if (current.distance > dist[current.town]) continue;\n\n        for (int i = head[current.town]; i != -1; i = edges[i].next) {\n            int to = edges[i].to;\n            int new_dist = current.distance + edges[i].length;\n            if (new_dist < dist[to]) {\n                dist[to] = new_dist;\n                heap[heap_size].town = to;\n                heap[heap_size].distance = new_dist;\n                heap_size++;\n                int child = heap_size - 1;\n                while (child > 0) {\n                    int parent = (child - 1) / 2;\n                    if (heap[parent].distance <= heap[child].distance) break;\n                    Node temp = heap[parent];\n                    heap[parent] = heap[child];\n                    heap[child] = temp;\n                    child = parent;\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m, k;\n    scanf(\"%d %d %d\", &n, &m, &k);\n\n    for (int i = 1; i <= n; ++i) {\n        head[i] = -1;\n        shopping[i] = 0;\n    }\n\n    for (int i = 0; i < k; ++i) {\n        int town;\n        scanf(\"%d\", &town);\n        shopping[town] = 1;\n    }\n\n    for (int i = 0; i < m; ++i) {\n        int a, b, l;\n        scanf(\"%d %d %d\", &a, &b, &l);\n        add_edge(a, b, l);\n        add_edge(b, a, l);\n    }\n\n    dijkstra(n);\n\n    int max_dist = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (dist[i] > max_dist) {\n            max_dist = dist[i];\n        }\n    }\n\n    for (int u = 1; u <= n; ++u) {\n        for (int i = head[u]; i != -1; i = edges[i].next) {\n            int v = edges[i].to;\n            int l = edges[i].length;\n            int d = dist[u] + dist[v] + l;\n            if (d > max_dist) {\n                max_dist = d;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", (max_dist + 1) / 2);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:50:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class ShortestDistanceToMall {\n    static class Edge {\n        int to, weight;\n        Edge(int to, int weight) {\n            this.to = to;\n            this.weight = weight;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        int N = Integer.parseInt(st.nextToken());\n        int M = Integer.parseInt(st.nextToken());\n        int K = Integer.parseInt(st.nextToken());\n        \n        List<List<Edge>> graph = new ArrayList<>(N + 1);\n        for (int i = 0; i <= N; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < M; i++) {\n            st = new StringTokenizer(br.readLine());\n            int u = Integer.parseInt(st.nextToken());\n            int v = Integer.parseInt(st.nextToken());\n            int w = Integer.parseInt(st.nextToken());\n            \n            graph.get(u).add(new Edge(v, w));\n            graph.get(v).add(new Edge(u, w));\n        }\n        \n        st = new StringTokenizer(br.readLine());\n        int[] malls = new int[K];\n        for (int i = 0; i < K; i++) {\n            malls[i] = Integer.parseInt(st.nextToken());\n        }\n        \n        double maxDistance = dijkstra(N, graph, malls);\n        System.out.printf(\"%.1f%n\", maxDistance);\n    }\n    \n    static double dijkstra(int N, List<List<Edge>> graph, int[] malls) {\n        PriorityQueue<double[]> pq = new PriorityQueue<>((a, b) -> Double.compare(a[1], b[1]));\n        double[] dist = new double[N + 1];\n        Arrays.fill(dist, Double.MAX_VALUE);\n        \n        for (int mall : malls) {\n            dist[mall] = 0;\n            pq.offer(new double[]{mall, 0});\n        }\n        \n        while (!pq.isEmpty()) {\n            double[] curr = pq.poll();\n            int node = (int)curr[0];\n            double distance = curr[1];\n            \n            if (distance > dist[node]) continue;\n            \n            for (Edge edge : graph.get(node)) {\n                double newDist = distance + edge.weight;\n                \n                if (newDist < dist[edge.to]) {\n                    dist[edge.to] = newDist;\n                    pq.offer(new double[]{edge.to, newDist});\n                }\n            }\n        }\n        \n        double maxDistance = 0;\n        for (int u = 1; u <= N; u++) {\n            for (Edge edge : graph.get(u)) {\n                int v = edge.to;\n                if (u > v) continue;\n                \n                double midDist = (dist[u] + dist[v] + edge.weight) / 2.0;\n                maxDistance = Math.max(maxDistance, midDist);\n            }\n        }\n        \n        return maxDistance;\n    }\n}",
    "timestamp": "2025-08-05 18:50:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge {\n    int to;\n    int length;\n};\n\nint main() {\n    int N, M, K;\n    cin >> N >> M >> K;\n    vector<vector<Edge>> graph(N + 1);\n    vector<int> shopping(K);\n    for (int i = 0; i < K; ++i) {\n        cin >> shopping[i];\n    }\n    for (int i = 0; i < M; ++i) {\n        int a, b, l;\n        cin >> a >> b >> l;\n        graph[a].push_back({b, l});\n        graph[b].push_back({a, l});\n    }\n\n    vector<int> dist(N + 1, INT_MAX);\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    for (int s : shopping) {\n        dist[s] = 0;\n        pq.push({0, s});\n    }\n\n    while (!pq.empty()) {\n        int current_dist = pq.top().first;\n        int u = pq.top().second;\n        pq.pop();\n        if (current_dist > dist[u]) continue;\n        for (const Edge& e : graph[u]) {\n            int v = e.to;\n            int new_dist = current_dist + e.length;\n            if (new_dist < dist[v]) {\n                dist[v] = new_dist;\n                pq.push({new_dist, v});\n            }\n        }\n    }\n\n    int max_dist = 0;\n    for (int u = 1; u <= N; ++u) {\n        for (const Edge& e : graph[u]) {\n            int v = e.to;\n            if (u > v) continue; // To avoid processing the same edge twice\n            int d = max(dist[u], dist[v]);\n            int remaining = e.length - abs(dist[u] - dist[v]);\n            if (remaining > 0) {\n                d += (remaining + 1) / 2;\n            }\n            if (d > max_dist) {\n                max_dist = d;\n            }\n        }\n    }\n    cout << max_dist << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 18:50:37"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_TOWNS 5001\n#define MAX_ROADS 10001\n\ntypedef struct {\n    int to;\n    int weight;\n    struct Edge* next;\n} Edge;\n\ntypedef struct {\n    int dist;\n    int is_mall;\n} Node;\n\nNode graph[MAX_TOWNS];\nEdge* adj_list[MAX_TOWNS];\nint dist[MAX_TOWNS];\nint queue[MAX_TOWNS * 10];\n\nvoid add_edge(int from, int to, int weight) {\n    Edge* edge = malloc(sizeof(Edge));\n    edge->to = to;\n    edge->weight = weight;\n    edge->next = adj_list[from];\n    adj_list[from] = edge;\n}\n\nvoid bfs(int n, int k, int* malls) {\n    int front = 0, rear = 0;\n    memset(dist, 0x3f, sizeof(dist));\n\n    for (int i = 0; i < k; i++) {\n        dist[malls[i]] = 0;\n        queue[rear++] = malls[i];\n    }\n\n    while (front < rear) {\n        int curr = queue[front++];\n\n        for (Edge* edge = adj_list[curr]; edge; edge = edge->next) {\n            int next = edge->to;\n            int new_dist = dist[curr] + edge->weight;\n\n            if (new_dist < dist[next]) {\n                dist[next] = new_dist;\n                queue[rear++] = next;\n            }\n        }\n    }\n}\n\ndouble find_max_distance(int n, int m, int k, int* malls) {\n    double max_dist = 0;\n\n    for (int road = 1; road <= m; road++) {\n        for (Edge* edge = adj_list[road]; edge; edge = edge->next) {\n            int u = road, v = edge->to;\n            int road_length = edge->weight;\n\n            int mall_dist_u = dist[u];\n            int mall_dist_v = dist[v];\n\n            if (mall_dist_u == mall_dist_v) continue;\n\n            if (mall_dist_u > mall_dist_v) {\n                int temp = u;\n                u = v;\n                v = temp;\n                int temp_dist = mall_dist_u;\n                mall_dist_u = mall_dist_v;\n                mall_dist_v = temp_dist;\n            }\n\n            double midpoint_dist = (double)road_length / 2.0;\n            double max_road_dist = mall_dist_u + midpoint_dist;\n\n            if (mall_dist_v < max_road_dist) {\n                max_road_dist = (mall_dist_u + mall_dist_v + road_length) / 2.0;\n            }\n\n            max_dist = (max_dist > max_road_dist) ? max_dist : max_road_dist;\n        }\n    }\n\n    return max_dist;\n}\n\nint main() {\n    int n, m, k;\n    scanf(\"%d %d %d\", &n, &m, &k);\n\n    int malls[k];\n    for (int i = 0; i < k; i++) {\n        scanf(\"%d\", &malls[i]);\n    }\n\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        scanf(\"%d %d %d\", &a, &b, &c);\n        add_edge(a, b, c);\n        add_edge(b, a, c);\n    }\n\n    bfs(n, k, malls);\n    double result = find_max_distance(n, m, k, malls);\n    printf(\"%.1f\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:50:53"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1005;\nconst int INF = 1e9;\n\nvector<pair<int, int>> graph[MAXN];\nvector<int> mall_towns;\nint dist[MAXN];\n\nvoid dijkstra(int start) {\n    fill(dist, dist + MAXN, INF);\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    \n    for (int mall : mall_towns) {\n        dist[mall] = 0;\n        pq.push({0, mall});\n    }\n    \n    while (!pq.empty()) {\n        int curr_dist = pq.top().first;\n        int curr_node = pq.top().second;\n        pq.pop();\n        \n        if (curr_dist > dist[curr_node]) continue;\n        \n        for (auto& [next_node, edge_dist] : graph[curr_node]) {\n            int new_dist = curr_dist + edge_dist;\n            if (new_dist < dist[next_node]) {\n                dist[next_node] = new_dist;\n                pq.push({new_dist, next_node});\n            }\n        }\n    }\n}\n\ndouble find_max_min_distance(int N, int M, int K, vector<pair<int, int>>& roads, vector<int>& malls) {\n    mall_towns = malls;\n    \n    for (auto& [u, v, w] : roads) {\n        graph[u].push_back({v, w});\n        graph[v].push_back({u, w});\n    }\n    \n    dijkstra(0);\n    \n    double max_dist = 0;\n    \n    for (int u = 1; u <= N; u++) {\n        for (auto& [v, w] : graph[u]) {\n            if (u > v) continue;\n            \n            double mid_dist = (dist[u] + dist[v] - w) / 2.0;\n            max_dist = max(max_dist, min(dist[u], dist[v]));\n            \n            if (mid_dist >= 0 && mid_dist <= w) {\n                max_dist = max(max_dist, mid_dist);\n            }\n        }\n    }\n    \n    return max_dist;\n}\n\nint main() {\n    int N, M, K;\n    cin >> N >> M >> K;\n    \n    vector<int> malls(K);\n    for (int i = 0; i < K; i++) {\n        cin >> malls[i];\n    }\n    \n    vector<pair<int, int>> roads(M);\n    for (int i = 0; i < M; i++) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        roads[i] = {u, v, w};\n    }\n    \n    double result = find_max_min_distance(N, M, K, roads, malls);\n    printf(\"%.1f\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:51:05"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static class Edge {\n        int to, length;\n        Edge(int to, int length) {\n            this.to = to;\n            this.length = length;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int N = Integer.parseInt(st.nextToken());\n        int M = Integer.parseInt(st.nextToken());\n        int K = Integer.parseInt(st.nextToken());\n\n        List<List<Edge>> graph = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            graph.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < M; i++) {\n            st = new StringTokenizer(br.readLine());\n            int A = Integer.parseInt(st.nextToken());\n            int B = Integer.parseInt(st.nextToken());\n            int L = Integer.parseInt(st.nextToken());\n            graph.get(A).add(new Edge(B, L));\n            graph.get(B).add(new Edge(A, L));\n        }\n\n        boolean[] isMall = new boolean[N + 1];\n        int[] dist = new int[N + 1];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n\n        st = new StringTokenizer(br.readLine());\n        for (int i = 0; i < K; i++) {\n            int town = Integer.parseInt(st.nextToken());\n            isMall[town] = true;\n            dist[town] = 0;\n            pq.offer(new int[]{town, 0});\n        }\n\n        while (!pq.isEmpty()) {\n            int[] current = pq.poll();\n            int u = current[0];\n            int d = current[1];\n            if (d > dist[u]) continue;\n            for (Edge edge : graph.get(u)) {\n                int v = edge.to;\n                int newDist = d + edge.length;\n                if (newDist < dist[v]) {\n                    dist[v] = newDist;\n                    pq.offer(new int[]{v, newDist});\n                }\n            }\n        }\n\n        int maxDist = 0;\n        for (int u = 1; u <= N; u++) {\n            for (Edge edge : graph.get(u)) {\n                int v = edge.to;\n                if (u > v) continue; // To avoid processing the same edge twice\n                int d1 = dist[u];\n                int d2 = dist[v];\n                int edgeLen = edge.length;\n                int currentMax = (d1 + d2 + edgeLen + 1) / 2;\n                if (currentMax > maxDist) {\n                    maxDist = currentMax;\n                }\n            }\n        }\n\n        System.out.println(maxDist);\n    }\n}",
    "timestamp": "2025-08-05 18:51:34"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\nimport sys\nfrom collections import defaultdict\n\ndef max_distance_to_malls(N, M, K, mall_towns, roads):\n    INF = sys.maxsize\n    graph = defaultdict(list)\n    \n    for u, v, l in roads:\n        graph[u].append((v, l))\n        graph[v].append((u, l))\n    \n    def dijkstra(start_towns, num_towns):\n        distances = [INF] * (num_towns + 1)\n        min_heap = []\n        \n        for town in start_towns:\n            heapq.heappush(min_heap, (0, town))\n            distances[town] = 0\n        \n        while min_heap:\n            cur_dist, cur_town = heapq.heappop(min_heap)\n            if cur_dist > distances[cur_town]:\n                continue\n            for neighbor, length in graph[cur_town]:\n                new_dist = cur_dist + length\n                if new_dist < distances[neighbor]:\n                    distances[neighbor] = new_dist\n                    heapq.heappush(min_heap, (new_dist, neighbor))\n        \n        return distances[1:]\n    \n    mall_distances = dijkstra(mall_towns, N)\n    \n    max_distance = 0\n    for u, v, l in roads:\n        d1, d2 = mall_distances[u - 1], mall_distances[v - 1]\n        max_distance = max(max_distance, min(d1, d2) + l / 2)\n    \n    return max_distance\n\n# Example usage will be something like:\n# N = 4\n# M = 4\n# K = 2\n# mall_towns = [1, 4]\n# roads = [(1, 2, 2), (2, 3, 3), (3, 4, 4), (1, 3, 5)]\n# print(max_distance_to_malls(N, M, K, mall_towns, roads))",
    "timestamp": "2025-08-13 01:05:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class JOIKingdom {\n\n    static class Town {\n        int id;\n        List<Road> roads = new ArrayList<>();\n\n        Town(int id) {\n            this.id = id;\n        }\n    }\n\n    static class Road {\n        Town from;\n        Town to;\n        int length;\n\n        Road(Town from, Town to, int length) {\n            this.from = from;\n            this.to = to;\n            this.length = length;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        int K = scanner.nextInt();\n\n        Town[] towns = new Town[N];\n        for (int i = 0; i < N; i++) {\n            towns[i] = new Town(i);\n        }\n\n        for (int i = 0; i < M; i++) {\n            int u = scanner.nextInt() - 1;\n            int v = scanner.nextInt() - 1;\n            int d = scanner.nextInt();\n            Road road = new Road(towns[u], towns[v], d);\n            towns[u].roads.add(road);\n            towns[v].roads.add(road);\n        }\n\n        Set<Integer> mallTowns = new HashSet<>();\n        for (int i = 0; i < K; i++) {\n            mallTowns.add(scanner.nextInt() - 1);\n        }\n\n        scanner.close();\n        System.out.println(findMaxShortestDistance(towns, mallTowns));\n    }\n\n    private static int findMaxShortestDistance(Town[] towns, Set<Integer> mallTowns) {\n        int[] distanceToMall = new int[towns.length];\n        Arrays.fill(distanceToMall, Integer.MAX_VALUE);\n\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));\n\n        for (int mall : mallTowns) {\n            pq.offer(new int[]{mall, 0});\n            distanceToMall[mall] = 0;\n        }\n\n        while (!pq.isEmpty()) {\n            int[] current = pq.poll();\n            int townId = current[0];\n            int dist = current[1];\n\n            if (dist > distanceToMall[townId]) continue;\n\n            for (Road road : towns[townId].roads) {\n                Town adjacentTown = road.from.id == townId ? road.to : road.from;\n                int newDist = dist + road.length;\n\n                if (newDist < distanceToMall[adjacentTown.id]) {\n                    distanceToMall[adjacentTown.id] = newDist;\n                    pq.offer(new int[]{adjacentTown.id, newDist});\n                }\n            }\n        }\n\n        int maxShortestDistance = 0;\n        for (Town town : towns) {\n            for (Road road : town.roads) {\n                Town adjTown = road.from.id == town.id ? road.to : road.from;\n                maxShortestDistance = Math.max(maxShortestDistance, road.length + Math.abs(distanceToMall[town.id] - distanceToMall[adjTown.id]));\n            }\n        }\n\n        return maxShortestDistance / 2;\n    }\n}",
    "timestamp": "2025-08-13 01:05:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 1000\n#define MAX_M 10000\n\ntypedef struct {\n    int u, v, w;\n} Road;\n\nint N, M, K;\nint malls[MAX_N];\nRoad roads[MAX_M];\nint dist[MAX_N];\nint visited[MAX_N];\nint shopping_mall[MAX_N];\n\nvoid dijkstra() {\n    for (int i = 0; i < N; i++) {\n        dist[i] = INT_MAX;\n        visited[i] = 0;\n    }\n    \n    for (int i = 0; i < K; i++) {\n        dist[malls[i]] = 0;\n    }\n    \n    while (1) {\n        int u = -1;\n        for (int i = 0; i < N; i++) {\n            if (!visited[i] && (u == -1 || dist[i] < dist[u])) {\n                u = i;\n            }\n        }\n        \n        if (u == -1 || dist[u] == INT_MAX) break;\n        \n        visited[u] = 1;\n        \n        for (int i = 0; i < M; i++) {\n            Road road = roads[i];\n            int v = road.u == u ? road.v : road.u;\n            if (v == u) continue;\n            int w = road.w;\n            if (dist[u] + w < dist[v]) {\n                dist[v] = dist[u] + w;\n            }\n        }\n    }\n}\n\nint calculate_max_distance() {\n    dijkstra();\n    int max_dist = 0;\n    for (int i = 0; i < M; i++) {\n        Road road = roads[i];\n        int u = road.u;\n        int v = road.v;\n        int w = road.w;\n        \n        int d1 = dist[u];\n        int d2 = dist[v];\n        \n        int local_max1 = d1 + w;\n        int local_max2 = d2 + w;\n        \n        if (local_max1 > max_dist) max_dist = local_max1;\n        if (local_max2 > max_dist) max_dist = local_max2;\n        \n        int mid_dist = abs(d1 - d2) <= w ? (d2 + (w - abs(d1 - d2)) / 2) : (d1 + w);\n        if (mid_dist > max_dist) max_dist = mid_dist;\n    }\n    return max_dist;\n}\n\nint main() {\n    scanf(\"%d %d %d\", &N, &M, &K);\n    for (int i = 0; i < K; i++) {\n        scanf(\"%d\", &malls[i]);\n        malls[i]--; // convert to 0-indexed\n    }\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d %d\", &roads[i].u, &roads[i].v, &roads[i].w);\n        roads[i].u--; // convert to 0-indexed\n        roads[i].v--; // convert to 0-indexed\n    }\n    \n    int max_dist = calculate_max_distance();\n    printf(\"%d\\n\", max_dist);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 01:05:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\nimport heapq\n\ndef solve(N, M, K, mall_towns, roads):\n    # Create adjacency list representation of the graph\n    graph = [[] for _ in range(N+1)]\n    for u, v, w in roads:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    \n    # Initialize distances to malls\n    dist_to_mall = [float('inf')] * (N+1)\n    \n    # Perform multi-source Dijkstra from mall towns\n    pq = []\n    for mall in mall_towns:\n        dist_to_mall[mall] = 0\n        heapq.heappush(pq, (0, mall))\n    \n    while pq:\n        curr_dist, curr_town = heapq.heappop(pq)\n        \n        if curr_dist > dist_to_mall[curr_town]:\n            continue\n        \n        for next_town, road_dist in graph[curr_town]:\n            dist = curr_dist + road_dist\n            if dist < dist_to_mall[next_town]:\n                dist_to_mall[next_town] = dist\n                heapq.heappush(pq, (dist, next_town))\n    \n    # Find max distance along roads\n    max_dist = 0\n    for u, v, w in roads:\n        # Check both road endpoints and midpoint\n        max_dist = max(max_dist, \n                       min(dist_to_mall[u] + w/2, dist_to_mall[v] + w/2),\n                       min(dist_to_mall[u], dist_to_mall[v]))\n    \n    return max_dist\n\n# Read input\nN, M, K = map(int, input().split())\nmall_towns = list(map(int, input().split()))\nroads = []\nfor _ in range(M):\n    u, v, w = map(int, input().split())\n    roads.append((u, v, w))\n\n# Print result\nprint(solve(N, M, K, mall_towns, roads))",
    "timestamp": "2025-08-13 01:06:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    \n    N = int(data[idx])\n    idx += 1\n    M = int(data[idx])\n    idx += 1\n    K = int(data[idx])\n    idx += 1\n    \n    shopping_towns = list(map(int, data[idx:idx+K]))\n    shopping_towns = [x-1 for x in shopping_towns]  # converting to 0-based\n    idx += K\n    \n    adj = [[] for _ in range(N)]\n    for _ in range(M):\n        u = int(data[idx]) - 1\n        v = int(data[idx+1]) - 1\n        w = int(data[idx+2])\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n        idx += 3\n    \n    INF = float('inf')\n    dist = [INF] * N\n    heap = []\n    \n    for town in shopping_towns:\n        dist[town] = 0\n        heapq.heappush(heap, (0, town))\n    \n    while heap:\n        current_dist, u = heapq.heappop(heap)\n        if current_dist > dist[u]:\n            continue\n        for v, w in adj[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                heapq.heappush(heap, (dist[v], v))\n    \n    max_dist = 0\n    for u in range(N):\n        for v, w in adj[u]:\n            if u > v:  # to avoid processing the same edge twice\n                continue\n            d = (dist[u] + dist[v] + w) / 2\n            if d > max_dist:\n                max_dist = d\n    \n    print(int(max_dist) if max_dist.is_integer() else max_dist)\n\nsolve()",
    "timestamp": "2025-08-13 01:06:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge {\n    int to;\n    long long length;\n};\n\nconst long long INF = numeric_limits<long long>::max();\n\nstruct State {\n    int node;\n    long long dist;\n    bool operator<(const State &other) const {\n        return dist > other.dist; // Min-heap based on dist\n    }\n};\n\nvoid dijkstra(int n, const vector<vector<Edge>> &adj, vector<long long> &dist, const vector<int> &malls) {\n    priority_queue<State> pq;\n    for (int mall : malls) {\n        dist[mall] = 0;\n        pq.push(State{mall, 0});\n    }\n\n    while (!pq.empty()) {\n        State cur = pq.top();\n        pq.pop();\n        if (cur.dist > dist[cur.node]) continue;\n        for (const Edge &e : adj[cur.node]) {\n            long long newDist = cur.dist + e.length;\n            if (newDist < dist[e.to]) {\n                dist[e.to] = newDist;\n                pq.push(State{e.to, newDist});\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m, k;\n    cin >> n >> m >> k;\n    \n    vector<vector<Edge>> adj(n + 1);\n    vector<int> malls(k);\n    \n    for (int i = 0; i < k; ++i) {\n        cin >> malls[i];\n    }\n    \n    for (int i = 0; i < m; ++i) {\n        int u, v;\n        long long l;\n        cin >> u >> v >> l;\n        adj[u].push_back(Edge{v, l});\n        adj[v].push_back(Edge{u, l});\n    }\n    \n    vector<long long> dist(n + 1, INF);\n    dijkstra(n, adj, dist, malls);\n\n    long long maxShortestDist = 0;\n    for (int u = 1; u <= n; ++u) {\n        for (const Edge &e : adj[u]) {\n            long long distToMall = min(dist[u], dist[e.to]);\n            long long farthestDistOnEdge = distToMall + e.length / 2;\n            maxShortestDist = max(maxShortestDist, farthestDistOnEdge);\n        }\n    }\n    \n    cout << maxShortestDist << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 10:58:21"
  }
]