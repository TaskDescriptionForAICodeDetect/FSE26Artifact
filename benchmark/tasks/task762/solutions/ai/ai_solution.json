[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_N 200005\n\ntypedef struct {\n    int vertex;\n    int next;\n} Edge;\n\nEdge graph[2 * MAX_N];\nint head[MAX_N], edge_count = 0;\nint pieces[MAX_N], parent[MAX_N], depth[MAX_N];\nint total_pieces = 0;\n\nvoid add_edge(int u, int v) {\n    graph[edge_count].vertex = v;\n    graph[edge_count].next = head[u];\n    head[u] = edge_count++;\n}\n\nvoid dfs(int u, int p, int d) {\n    parent[u] = p;\n    depth[u] = d;\n    for (int i = head[u]; i != -1; i = graph[i].next) {\n        int v = graph[i].vertex;\n        if (v != p) {\n            dfs(v, u, d + 1);\n        }\n    }\n}\n\nint lowest_common_ancestor(int u, int v) {\n    if (depth[u] < depth[v]) {\n        int temp = u;\n        u = v;\n        v = temp;\n    }\n    \n    while (depth[u] > depth[v]) {\n        u = parent[u];\n    }\n    \n    while (u != v) {\n        u = parent[u];\n        v = parent[v];\n    }\n    \n    return u;\n}\n\nint distance(int u, int v) {\n    int lca = lowest_common_ancestor(u, v);\n    return depth[u] + depth[v] - 2 * depth[lca];\n}\n\nint solve(int n, char* s) {\n    memset(head, -1, sizeof(head));\n    edge_count = 0;\n    \n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        a--; b--;\n        add_edge(a, b);\n        add_edge(b, a);\n    }\n    \n    dfs(0, -1, 0);\n    \n    int piece_vertices[MAX_N];\n    total_pieces = 0;\n    for (int i = 0; i < n; i++) {\n        if (s[i] == '1') {\n            piece_vertices[total_pieces++] = i;\n        }\n    }\n    \n    if (total_pieces == 0) return 0;\n    if (total_pieces == 1) return 0;\n    \n    int total_moves = 0;\n    int target_vertex = piece_vertices[0];\n    \n    for (int i = 1; i < total_pieces; i++) {\n        total_moves += distance(target_vertex, piece_vertices[i]);\n    }\n    \n    return total_moves;\n}\n\nint main() {\n    int n;\n    char s[MAX_N];\n    \n    scanf(\"%d\", &n);\n    scanf(\"%s\", s);\n    \n    int result = solve(n, s);\n    printf(\"%d\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:48:28"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAXN 200000\n#define INF 1e18\n\ntypedef struct {\n    int to, next;\n} Edge;\n\nEdge edges[2 * MAXN + 5];\nint head[MAXN + 5], edgeCount;\nint N;\nchar S[MAXN + 5];\nint size[MAXN + 5];\nlong long down[MAXN + 5], up[MAXN + 5];\nlong long res[MAXN + 5];\n\nvoid addEdge(int u, int v) {\n    edges[edgeCount].to = v;\n    edges[edgeCount].next = head[u];\n    head[u] = edgeCount++;\n}\n\nvoid dfs1(int u, int p) {\n    size[u] = (S[u] == '1');\n    down[u] = 0;\n    for (int i = head[u]; i != -1; i = edges[i].next) {\n        int v = edges[i].to;\n        if (v == p) continue;\n        dfs1(v, u);\n        size[u] += size[v];\n        down[u] += down[v] + size[v];\n    }\n}\n\nvoid dfs2(int u, int p) {\n    res[u] = up[u] + down[u];\n    for (int i = head[u]; i != -1; i = edges[i].next) {\n        int v = edges[i].to;\n        if (v == p) continue;\n        up[v] = up[u] + down[u] - (down[v] + size[v]) + (size[1] - size[v]);\n        dfs2(v, u);\n    }\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    scanf(\"%s\", S + 1);\n\n    memset(head, -1, sizeof(head));\n    edgeCount = 0;\n\n    for (int i = 1; i < N; ++i) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        addEdge(a, b);\n        addEdge(b, a);\n    }\n\n    int total = 0;\n    for (int i = 1; i <= N; ++i) {\n        if (S[i] == '1') {\n            total++;\n        }\n    }\n\n    if (total == 0) {\n        printf(\"0\\n\");\n        return 0;\n    }\n\n    dfs1(1, -1);\n    up[1] = 0;\n    dfs2(1, -1);\n\n    long long min_moves = INF;\n    for (int i = 1; i <= N; ++i) {\n        if (res[i] < min_moves) {\n            min_moves = res[i];\n        }\n    }\n\n    if (min_moves % 2 != 0) {\n        printf(\"-1\\n\");\n    } else {\n        printf(\"%lld\\n\", min_moves / 2);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:49:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<int> cnt;\nvector<int> dist;\nint total;\n\nvoid dfs(int u, int p) {\n    for (int v : adj[u]) {\n        if (v == p) continue;\n        dfs(v, u);\n        cnt[u] += cnt[v];\n    }\n}\n\npair<int, bool> find_centroid(int N) {\n    cnt.assign(N + 1, 0);\n    for (int i = 1; i <= N; ++i) {\n        if (S[i - 1] == '1') {\n            cnt[i] = 1;\n        }\n    }\n    dfs(1, -1);\n    int centroid = 1;\n    bool found = false;\n    for (int u = 1; u <= N; ++u) {\n        bool ok = true;\n        for (int v : adj[u]) {\n            if (cnt[v] > cnt[u]) continue;\n            if (cnt[v] > total / 2) {\n                ok = false;\n                break;\n            }\n        }\n        if (total - cnt[u] > total / 2) ok = false;\n        if (ok) {\n            if (found) return {-1, false}; // multiple centroids\n            found = true;\n            centroid = u;\n        }\n    }\n    return {centroid, found};\n}\n\nint compute_moves(int centroid, int N) {\n    dist.assign(N + 1, 0);\n    queue<int> q;\n    q.push(centroid);\n    dist[centroid] = 0;\n    int res = 0;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        if (S[u - 1] == '1') {\n            res += dist[u];\n        }\n        for (int v : adj[u]) {\n            if (dist[v] == 0 && v != centroid) {\n                dist[v] = dist[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    adj.resize(N + 1);\n    for (int i = 0; i < N - 1; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n    string S;\n    cin >> S;\n    total = count(S.begin(), S.end(), '1');\n    if (total == 0) {\n        cout << 0 << endl;\n        return 0;\n    }\n    auto [centroid, valid] = find_centroid(N);\n    if (!valid) {\n        cout << -1 << endl;\n        return 0;\n    }\n    cout << compute_moves(centroid, N) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:49:46"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static List<Integer>[] tree;\n    static String S;\n    static int totalPieces;\n    static int[] subtreePieces;\n    static int N;\n    static int centroid;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        N = Integer.parseInt(br.readLine());\n        tree = new ArrayList[N + 1];\n        for (int i = 1; i <= N; i++) {\n            tree[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < N - 1; i++) {\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int a = Integer.parseInt(st.nextToken());\n            int b = Integer.parseInt(st.nextToken());\n            tree[a].add(b);\n            tree[b].add(a);\n        }\n        S = br.readLine();\n        totalPieces = 0;\n        for (int i = 0; i < N; i++) {\n            if (S.charAt(i) == '1') {\n                totalPieces++;\n            }\n        }\n        if (totalPieces == 0) {\n            System.out.println(0);\n            return;\n        }\n        subtreePieces = new int[N + 1];\n        findCentroid(1, -1);\n        if (centroid == -1) {\n            System.out.println(-1);\n            return;\n        }\n        long res = calculateMoves(centroid);\n        System.out.println(res);\n    }\n\n    static void findCentroid(int u, int parent) {\n        subtreePieces[u] = (S.charAt(u - 1) == '1') ? 1 : 0;\n        boolean isCentroid = true;\n        for (int v : tree[u]) {\n            if (v == parent) continue;\n            findCentroid(v, u);\n            subtreePieces[u] += subtreePieces[v];\n            if (subtreePieces[v] > totalPieces / 2) {\n                isCentroid = false;\n            }\n        }\n        if (isCentroid && (totalPieces - subtreePieces[u]) <= totalPieces / 2) {\n            centroid = u;\n        }\n    }\n\n    static long calculateMoves(int root) {\n        long[] distSum = new long[1];\n        dfsDist(root, -1, 0, distSum);\n        return distSum[0];\n    }\n\n    static void dfsDist(int u, int parent, int depth, long[] distSum) {\n        if (S.charAt(u - 1) == '1') {\n            distSum[0] += depth;\n        }\n        for (int v : tree[u]) {\n            if (v != parent) {\n                dfsDist(v, u, depth + 1, distSum);\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:50:12"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SnukePieces {\n    static ArrayList<Integer>[] graph;\n    static int[] pieces;\n    static int N;\n\n    public static int minimumMoves() {\n        List<Integer> piecesLocations = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            if (pieces[i] > 0) {\n                piecesLocations.add(i);\n            }\n        }\n\n        int totalPieces = piecesLocations.size();\n        if (totalPieces == 0) return 0;\n        if (totalPieces == 1) return 0;\n\n        int[][] dist = new int[N][N];\n        for (int i = 0; i < N; i++) {\n            Arrays.fill(dist[i], Integer.MAX_VALUE / 2);\n            dist[i][i] = 0;\n        }\n\n        // BFS to calculate distances between all vertices\n        for (int start = 0; start < N; start++) {\n            Queue<Integer> queue = new LinkedList<>();\n            queue.offer(start);\n            boolean[] visited = new boolean[N];\n            visited[start] = true;\n\n            while (!queue.isEmpty()) {\n                int curr = queue.poll();\n                for (int next : graph[curr]) {\n                    if (!visited[next]) {\n                        dist[start][next] = dist[start][curr] + 1;\n                        dist[next][start] = dist[start][next];\n                        queue.offer(next);\n                        visited[next] = true;\n                    }\n                }\n            }\n        }\n\n        // Try each vertex as the final destination\n        int minMoves = Integer.MAX_VALUE;\n        for (int destination = 0; destination < N; destination++) {\n            int currentMoves = 0;\n            boolean possible = true;\n\n            for (int pieceLocation : piecesLocations) {\n                int bestMove = Integer.MAX_VALUE;\n                for (int intermediate = 0; intermediate < N; intermediate++) {\n                    int movesToIntermediate = dist[pieceLocation][intermediate];\n                    int movesToDestination = dist[intermediate][destination];\n                    bestMove = Math.min(bestMove, movesToIntermediate + movesToDestination);\n                }\n                if (bestMove == Integer.MAX_VALUE) {\n                    possible = false;\n                    break;\n                }\n                currentMoves += bestMove;\n            }\n\n            if (possible) {\n                minMoves = Math.min(minMoves, currentMoves);\n            }\n        }\n\n        return minMoves == Integer.MAX_VALUE ? -1 : minMoves;\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        Scanner scanner = new Scanner(System.in);\n        N = scanner.nextInt();\n        graph = new ArrayList[N];\n        for (int i = 0; i < N; i++) {\n            graph[i] = new ArrayList<>();\n        }\n\n        for (int i = 0; i < N - 1; i++) {\n            int a = scanner.nextInt() - 1;\n            int b = scanner.nextInt() - 1;\n            graph[a].add(b);\n            graph[b].add(a);\n        }\n\n        String S = scanner.next();\n        pieces = new int[N];\n        for (int i = 0; i < N; i++) {\n            pieces[i] = S.charAt(i) - '0';\n        }\n\n        System.out.println(minimumMoves());\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 22:50:24"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100005;\n\nvector<int> graph[MAXN];\nint pieces[MAXN];\nint n;\n\npair<int, int> dfs(int node, int parent) {\n    int total_pieces = pieces[node];\n    int depth = 0;\n    int max_depth = 0;\n    int max_depth_node = node;\n\n    for (int child : graph[node]) {\n        if (child == parent) continue;\n\n        auto [child_pieces, child_max_depth] = dfs(child, node);\n        total_pieces += child_pieces;\n\n        if (child_max_depth > max_depth) {\n            max_depth = child_max_depth;\n            max_depth_node = child;\n        }\n    }\n\n    if (total_pieces > 0) {\n        depth = max_depth + 1;\n    }\n\n    return {total_pieces, depth};\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n;\n    \n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n\n    string S;\n    cin >> S;\n\n    for (int i = 0; i < n; i++) {\n        pieces[i] = S[i] - '0';\n    }\n\n    int total_pieces = 0;\n    for (int i = 0; i < n; i++) {\n        total_pieces += pieces[i];\n    }\n\n    if (total_pieces == 0) {\n        cout << 0 << endl;\n        return 0;\n    }\n\n    int moves = INT_MAX;\n    for (int root = 0; root < n; root++) {\n        int current_moves = dfs(root, -1).second;\n        moves = min(moves, current_moves);\n    }\n\n    cout << moves << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:50:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef calculate_distances(tree, N):\n    # BFS from an arbitrary node, let's pick node 0\n    dist = [-1] * N\n    queue = deque([0])\n    dist[0] = 0\n    while queue:\n        node = queue.popleft()\n        for neighbor in tree[node]:\n            if dist[neighbor] == -1:\n                dist[neighbor] = dist[node] + 1\n                queue.append(neighbor)\n    return dist\n\ndef total_moves(S, distances):\n    total = 0\n    for i in range(len(S)):\n        total += distances[i] * int(S[i])\n    return total\n\ndef minimum_moves(N, a, b, S):\n    # Convert edge list to adjacency list\n    tree = defaultdict(list)\n    for i in range(N-1):\n        tree[a[i]-1].append(b[i]-1)\n        tree[b[i]-1].append(a[i]-1)\n    \n    # Initial BFS to find distances\n    initial_distances = calculate_distances(tree, N)\n\n    # Check feasibility: sum of pieces must be even\n    if sum(int(x) for x in S) % 2 != 0:\n        return -1\n    \n    # Find the farthest node with maximum distance\n    farthest_node = initial_distances.index(max(initial_distances))\n    \n    # BFS from the farthest node to get the diameter\n    final_distances = calculate_distances(tree, N)\n    \n    # Calculate effective moves\n    return total_moves(S, final_distances)\n\n# Example usage:\n# N = 5\n# a = [1, 1, 3, 3]\n# b = [2, 3, 4, 5]\n# S = \"11001\"\n# print(minimum_moves(N, a, b, S))",
    "timestamp": "2025-08-13 12:40:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class TreePieces {\n    \n    public static int minMovesToConsolidatePieces(int n, int[][] edges, String s) {\n        List<List<Integer>> tree = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            tree.add(new ArrayList<>());\n        }\n        for (int[] edge : edges) {\n            int a = edge[0], b = edge[1];\n            tree.get(a).add(b);\n            tree.get(b).add(a);\n        }\n        \n        int[] depth = new int[n];\n        int[][] parent = new int[n][20];\n        Arrays.fill(depth, -1);\n        \n        dfs(tree, 0, -1, depth, parent);\n        \n        int pieceCount = 0, root = -1;\n        int maxMove = 0;\n        \n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == '1') {\n                pieceCount++;\n                if (root == -1) {\n                    root = i;\n                } else {\n                    int dist = computeDistance(i, root, depth, parent);\n                    if (maxMove < dist) {\n                        maxMove = dist;\n                    }\n                }\n            }\n        }\n        \n        return pieceCount > 0 ? maxMove : 0;\n    }\n    \n    private static void dfs(List<List<Integer>> tree, int node, int par, int[] depth, int[][] parent) {\n        parent[node][0] = par;\n        for (int i = 1; i < 20; i++) {\n            parent[node][i] = parent[node][i - 1] == -1 ? -1 : parent[parent[node][i - 1]][i - 1];\n        }\n        for (int neighbor : tree.get(node)) {\n            if (neighbor != par) {\n                depth[neighbor] = depth[node] + 1;\n                dfs(tree, neighbor, node, depth, parent);\n            }\n        }\n    }\n\n    private static int computeDistance(int u, int v, int[] depth, int[][] parent) {\n        if (depth[u] < depth[v]) {\n            int temp = u;\n            u = v;\n            v = temp;\n        }\n        int diff = depth[u] - depth[v];\n        for (int i = 0; i < 20; i++) {\n            if ((diff & (1 << i)) != 0) {\n                u = parent[u][i];\n            }\n        }\n        if (u == v) return diff;\n        for (int i = 19; i >= 0; i--) {\n            if (parent[u][i] != parent[v][i]) {\n                u = parent[u][i];\n                v = parent[v][i];\n            }\n        }\n        return depth[u] + depth[v] - 2 * depth[parent[u][0]];\n    }\n    \n    public static void main(String[] args) {\n        int n = 5;\n        int[][] edges = {{0, 1}, {1, 2}, {1, 3}, {3, 4}};\n        String s = \"11001\";\n        System.out.println(minMovesToConsolidatePieces(n, edges, s));\n    }\n}",
    "timestamp": "2025-08-13 12:40:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAXN 100005\n\nint n;\nint edges[MAXN][2];\nchar s[MAXN];\nint degree[MAXN];\nint queue[MAXN];\nint head, tail;\n\nint main() {\n    // Read the number of vertices\n    scanf(\"%d\", &n);\n    \n    for(int i = 1; i < n; i++) {\n        // Read vertices connected by edges\n        scanf(\"%d %d\", &edges[i][0], &edges[i][1]);\n    }\n    \n    // Read string S of length N\n    scanf(\"%s\", s);\n\n    // Calculate the degree for each vertex\n    memset(degree, 0, sizeof(degree));\n    for(int i = 1; i < n; i++) {\n        degree[edges[i][0]]++;\n        degree[edges[i][1]]++;\n    }\n\n    head = 0;\n    tail = 0;\n\n    // Add leaf nodes (degree 1) with piece ('1') to the queue\n    for(int i = 1; i <= n; i++) {\n        if(degree[i] == 1 && s[i - 1] == '1') {\n            queue[tail++] = i;\n        }\n    }\n\n    int moves = 0;\n    while(head < tail) {\n\n        int current = queue[head++];\n        \n        if(degree[current] > 1) continue;\n\n        for(int i = 1; i < n; i++) {\n            \n            int u = edges[i][0], v = edges[i][1];\n            \n            if(u != current && v != current) continue;\n\n            int next = (u == current) ? v : u;\n            \n            if(s[current - 1] == '0' || s[next - 1] == '0')\n                continue;\n            \n            if(--degree[next] == 1) {\n                \n                queue[tail++] = next;\n            }\n            \n            moves++;\n            \n            s[current - 1] = '0';\n            \n            s[next - 1] = '1';\n            \n            break;\n        }\n    }\n\n    // Check if all pieces are on a single vertex\n    for(int i = 1; i <= n; i++) {\n        if(s[i - 1] == '1') {\n            printf(\"%d\\n\", moves);\n            return 0;\n        }\n    }\n\n    printf(\"-1\\n\");\n    return 0;\n}",
    "timestamp": "2025-08-13 12:40:35"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nconst int MAXN = 100010;\n\nvector<int> adj[MAXN];\nint dist[MAXN];\nint pieces[MAXN];\n\nvoid bfs(int start, int n) {\n    queue<int> q;\n    fill(dist, dist + n + 1, -1);\n    dist[start] = 0;\n    q.push(start);\n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        for (int u : adj[v]) {\n            if (dist[u] == -1) {\n                dist[u] = dist[v] + 1;\n                q.push(u);\n            }\n        }\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n    string S;\n    cin >> S;\n\n    for (int i = 1; i < n; i++) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    for (int i = 1; i <= n; i++) {\n        pieces[i] = S[i - 1] - '0';\n    }\n\n    // Find a farthest node from node 1\n    bfs(1, n);\n    int farthest = 1;\n    for (int i = 2; i <= n; i++) {\n        if (dist[i] > dist[farthest]) {\n            farthest = i;\n        }\n    }\n\n    // Find a longest path from the farthest node\n    bfs(farthest, n);\n    int other_end = 1;\n    for (int i = 2; i <= n; i++) {\n        if (dist[i] > dist[other_end]) {\n            other_end = i;\n        }\n    }\n\n    // Total moves = longest path\n    int total_moves = dist[other_end];\n\n    // Check if it's possible: sum of pieces should be N or N-1\n    int sum_pieces = 0;\n    for (int i = 1; i <= n; i++) {\n        sum_pieces += pieces[i];\n    }\n\n    if (sum_pieces != n && sum_pieces != n - 1) {\n        cout << \"Impossible\\n\";\n    } else {\n        cout << total_moves << '\\n';\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 12:40:42"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef solve(N, edges, S):\n    # Build adjacency list\n    graph = defaultdict(list)\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    # Find vertices with pieces\n    piece_vertices = [i for i in range(N) if S[i] == '1']\n    \n    if len(piece_vertices) == 0:\n        return 0\n    \n    # Find distances between all vertices\n    def bfs_distances(start):\n        dist = [float('inf')] * N\n        dist[start] = 0\n        queue = deque([start])\n        \n        while queue:\n            curr = queue.popleft()\n            for neighbor in graph[curr]:\n                if dist[neighbor] == float('inf'):\n                    dist[neighbor] = dist[curr] + 1\n                    queue.append(neighbor)\n        \n        return dist\n    \n    # Try each vertex as the final destination\n    min_moves = float('inf')\n    for target in range(N):\n        total_moves = 0\n        \n        # Compute distances from target to all vertices\n        distances = bfs_distances(target)\n        \n        # Check if any piece is too far\n        if any(distances[v] == float('inf') for v in piece_vertices):\n            continue\n        \n        # Compute total moves needed\n        max_dist = max(distances[v] for v in piece_vertices)\n        if max_dist == float('inf'):\n            continue\n        \n        # Check if moves are possible\n        if all(max_dist >= distances[v] for v in piece_vertices):\n            total_moves = sum(max_dist - distances[v] for v in piece_vertices)\n            min_moves = min(min_moves, total_moves // 2)\n    \n    return min_moves if min_moves != float('inf') else -1\n\n# Input parsing\ndef main():\n    N = int(input())\n    edges = []\n    for _ in range(N-1):\n        a, b = map(int, input().split())\n        edges.append((a-1, b-1))\n    S = input()\n    \n    result = solve(N, edges, S)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 12:40:51"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    S = input[ptr]\n    ptr += 1\n    adj = [[] for _ in range(N)]\n    for _ in range(N-1):\n        a = int(input[ptr]) - 1\n        ptr += 1\n        b = int(input[ptr]) - 1\n        ptr += 1\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    total = S.count('1')\n    if total == 0:\n        print(0)\n        return\n    \n    # Find the centroid(s)\n    parent = [-1] * N\n    size = [0] * N\n    q = deque()\n    q.append(0)\n    order = []\n    while q:\n        u = q.popleft()\n        order.append(u)\n        for v in adj[u]:\n            if v != parent[u]:\n                parent[v] = u\n                q.append(v)\n    \n    for u in reversed(order):\n        size[u] = 1 if S[u] == '1' else 0\n        for v in adj[u]:\n            if v != parent[u]:\n                size[u] += size[v]\n    \n    centroid = -1\n    for u in range(N):\n        is_centroid = True\n        for v in adj[u]:\n            if v == parent[u]:\n                if total - size[u] > total // 2:\n                    is_centroid = False\n                    break\n            else:\n                if size[v] > total // 2:\n                    is_centroid = False\n                    break\n        if is_centroid:\n            centroid = u\n            break\n    \n    # Compute the sum of distances to the centroid\n    res = 0\n    q = deque()\n    q.append((centroid, -1, 0))\n    while q:\n        u, p, d = q.popleft()\n        if S[u] == '1':\n            res += d\n        for v in adj[u]:\n            if v != p:\n                q.append((v, u, d + 1))\n    \n    # Check if possible\n    possible = True\n    for u in range(N):\n        if S[u] == '1':\n            # Check if any neighbor has more than total - 1 pieces\n            cnt = 0\n            for v in adj[u]:\n                if S[v] == '1':\n                    cnt += 1\n            if u != centroid and cnt > 1:\n                possible = False\n                break\n    \n    if possible:\n        print(res)\n    else:\n        print(-1)\n\nsolve()",
    "timestamp": "2025-08-13 12:41:06"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minMovesToUnifyPieces(N, edges, S) {\n    const adjacencyList = Array.from({ length: N + 1 }, () => []);\n    for (let [a, b] of edges) {\n        adjacencyList[a].push(b);\n        adjacencyList[b].push(a);\n    }\n    \n    const pieces = [];\n    for (let i = 0; i < N; i++) {\n        if (S[i] === '1') {\n            pieces.push(i + 1);\n        }\n    }\n\n    if (pieces.length <= 1) return 0;\n\n    let src = pieces[0];\n    const distFromSrc = bfs(src);\n\n    let farthestVertex = src;\n    let maxDistance = -1;\n    for (let i = 1; i <= N; i++) {\n        if (distFromSrc[i] > maxDistance) {\n            maxDistance = distFromSrc[i];\n            farthestVertex = i;\n        }\n    }\n\n    const distFromFarthest = bfs(farthestVertex);\n\n    let diameter = 0;\n    for (let i = 1; i <= N; i++) {\n        diameter = Math.max(diameter, distFromFarthest[i]);\n    }\n\n    return Math.ceil(diameter / 2);\n\n    function bfs(start) {\n        const dist = Array(N + 1).fill(Infinity);\n        const queue = [];\n        dist[start] = 0;\n        queue.push(start);\n\n        while (queue.length > 0) {\n            const vertex = queue.shift();\n            for (let neighbor of adjacencyList[vertex]) {\n                if (dist[neighbor] === Infinity) {\n                    dist[neighbor] = dist[vertex] + 1;\n                    queue.push(neighbor);\n                }\n            }\n        }\n\n        return dist;\n    }\n}\n\n// Example initialization for using the function:\n// const N = 5;\n// const edges = [[1, 2], [2, 3], [3, 4], [4, 5]];\n// const S = \"11000\";\n// console.log(minMovesToUnifyPieces(N, edges, S));  // Output: number of minimum moves",
    "timestamp": "2025-08-13 12:41:34"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(N, edges, S) {\n    const graph = Array.from({ length: N }, () => []);\n    for (const [a, b] of edges) {\n        graph[a - 1].push(b - 1);\n        graph[b - 1].push(a - 1);\n    }\n\n    const pieces = [];\n    for (let i = 0; i < N; i++) {\n        if (S[i] === '1') pieces.push(i);\n    }\n\n    if (pieces.length === 0) return 0;\n    if (pieces.length === 1) return 0;\n\n    const dist = new Array(N).fill(Infinity);\n    const queue = [...pieces];\n    pieces.forEach(p => dist[p] = 0);\n\n    while (queue.length) {\n        const curr = queue.shift();\n        for (const next of graph[curr]) {\n            if (dist[next] > dist[curr] + 1) {\n                dist[next] = dist[curr] + 1;\n                queue.push(next);\n            }\n        }\n    }\n\n    let minMoves = Infinity;\n    for (let vertex = 0; vertex < N; vertex++) {\n        let maxDist = 0;\n        for (const piece of pieces) {\n            maxDist = Math.max(maxDist, dist[piece] - dist[vertex]);\n        }\n        minMoves = Math.min(minMoves, maxDist);\n    }\n\n    return minMoves;\n}",
    "timestamp": "2025-08-13 12:41:40"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const fs = require('fs');\nconst input = fs.readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\nlet ptr = 0;\n\nfunction solve() {\n    const N = parseInt(input[ptr++]);\n    const adj = Array.from({ length: N + 1 }, () => []);\n    for (let i = 0; i < N - 1; i++) {\n        const [a, b] = input[ptr++].split(' ').map(Number);\n        adj[a].push(b);\n        adj[b].push(a);\n    }\n    const S = input[ptr++].trim();\n    \n    let total = 0;\n    for (const c of S) {\n        if (c === '1') total++;\n    }\n    if (total === 0 || total === N) {\n        console.log(0);\n        return;\n    }\n    \n    let centroid = -1;\n    const size = new Array(N + 1).fill(0);\n    \n    function findCentroid(u, parent) {\n        size[u] = (S[u - 1] === '1') ? 1 : 0;\n        let isCentroid = true;\n        for (const v of adj[u]) {\n            if (v === parent) continue;\n            findCentroid(v, u);\n            size[u] += size[v];\n            if (size[v] > total / 2) isCentroid = false;\n        }\n        if (total - size[u] > total / 2) isCentroid = false;\n        if (isCentroid) centroid = u;\n    }\n    \n    findCentroid(1, -1);\n    \n    function calculateMoves(u, parent, depth) {\n        let moves = 0;\n        if (S[u - 1] === '1') moves += depth;\n        for (const v of adj[u]) {\n            if (v === parent) continue;\n            moves += calculateMoves(v, u, depth + 1);\n        }\n        return moves;\n    }\n    \n    const minMoves = calculateMoves(centroid, -1, 0);\n    console.log(minMoves);\n}\n\nsolve();",
    "timestamp": "2025-08-13 12:41:52"
  }
]