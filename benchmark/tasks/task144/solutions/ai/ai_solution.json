[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_SIZE 50\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint office1[MAX_SIZE][MAX_SIZE];\nint office2[MAX_SIZE][MAX_SIZE];\nint H, W, R;\nPoint elevator1, elevator2;\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nvoid read_input() {\n    scanf(\"%d %d %d\", &H, &W, &R);\n    scanf(\"%d %d\", &elevator1.x, &elevator1.y);\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            scanf(\"%d\", &office1[i][j]);\n        }\n    }\n    scanf(\"%d %d\", &elevator2.x, &elevator2.y);\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            scanf(\"%d\", &office2[i][j]);\n        }\n    }\n}\n\nint count_accessible(int level, int office[MAX_SIZE][MAX_SIZE], Point elevator) {\n    int visited[MAX_SIZE][MAX_SIZE] = {0};\n    Point queue[MAX_SIZE * MAX_SIZE];\n    int front = 0, rear = 0;\n    int count = 0;\n\n    if (office[elevator.x][elevator.y] <= level) {\n        queue[rear++] = elevator;\n        visited[elevator.x][elevator.y] = 1;\n        count++;\n    }\n\n    int dx[] = {-1, 1, 0, 0};\n    int dy[] = {0, 0, -1, 1};\n\n    while (front < rear) {\n        Point current = queue[front++];\n        for (int i = 0; i < 4; i++) {\n            int nx = current.x + dx[i];\n            int ny = current.y + dy[i];\n            if (nx >= 0 && nx < H && ny >= 0 && ny < W && !visited[nx][ny] && office[nx][ny] <= level) {\n                visited[nx][ny] = 1;\n                queue[rear++] = (Point){nx, ny};\n                count++;\n            }\n        }\n    }\n    return count;\n}\n\nint solve() {\n    int left = 1, right = 0;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            right = max(right, office1[i][j]);\n            right = max(right, office2[i][j]);\n        }\n    }\n\n    int result = INT_MAX;\n    while (left <= right) {\n        int mid = (left + right) / 2;\n        int total = count_accessible(mid, office1, elevator1) + count_accessible(mid, office2, elevator2);\n        if (total >= R) {\n            result = min(result, mid);\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return result;\n}\n\nint main() {\n    read_input();\n    printf(\"%d\\n\", solve());\n    return 0;\n}",
    "timestamp": "2025-08-05 18:48:14"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class JOIAuthentication {\n    static final int INF = Integer.MAX_VALUE;\n    \n    public static int solve(int R, int[][] officeA, int[][] officeB) {\n        int m = officeA.length;\n        int n = officeA[0].length;\n        \n        List<Integer> levelsA = new ArrayList<>();\n        List<Integer> levelsB = new ArrayList<>();\n        \n        for (int[] row : officeA) {\n            for (int val : row) {\n                levelsA.add(val);\n            }\n        }\n        \n        for (int[] row : officeB) {\n            for (int val : row) {\n                levelsB.add(val);\n            }\n        }\n        \n        Collections.sort(levelsA);\n        Collections.sort(levelsB);\n        \n        int result = INF;\n        \n        for (int i = 0; i < levelsA.size(); i++) {\n            for (int j = 0; j < levelsB.size(); j++) {\n                int countA = countRoomsAccessible(officeA, levelsA.get(i));\n                int countB = countRoomsAccessible(officeB, levelsB.get(j));\n                \n                if (countA + countB >= R) {\n                    result = Math.min(result, levelsA.get(i) + levelsB.get(j));\n                }\n            }\n        }\n        \n        return result == INF ? -1 : result;\n    }\n    \n    static int countRoomsAccessible(int[][] office, int authLevel) {\n        int count = 0;\n        for (int[] row : office) {\n            for (int val : row) {\n                if (val <= authLevel) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        int R = Integer.parseInt(st.nextToken());\n        int M = Integer.parseInt(st.nextToken());\n        int N = Integer.parseInt(st.nextToken());\n        \n        int[][] officeA = new int[M][N];\n        int[][] officeB = new int[M][N];\n        \n        for (int i = 0; i < M; i++) {\n            st = new StringTokenizer(br.readLine());\n            for (int j = 0; j < N; j++) {\n                officeA[i][j] = Integer.parseInt(st.nextToken());\n            }\n        }\n        \n        for (int i = 0; i < M; i++) {\n            st = new StringTokenizer(br.readLine());\n            for (int j = 0; j < N; j++) {\n                officeB[i][j] = Integer.parseInt(st.nextToken());\n            }\n        }\n        \n        System.out.println(solve(R, officeA, officeB));\n    }\n}",
    "timestamp": "2025-08-05 18:48:26"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int H1, W1, H2, W2, R;\n    cin >> H1 >> W1;\n\n    vector<vector<int>> office1(H1, vector<int>(W1));\n    for (int i = 0; i < H1; ++i) {\n        for (int j = 0; j < W1; ++j) {\n            cin >> office1[i][j];\n        }\n    }\n\n    cin >> H2 >> W2;\n    vector<vector<int>> office2(H2, vector<int>(W2));\n    for (int i = 0; i < H2; ++i) {\n        for (int j = 0; j < W2; ++j) {\n            cin >> office2[i][j];\n        }\n    }\n\n    int X1, Y1, X2, Y2;\n    cin >> X1 >> Y1 >> X2 >> Y2 >> R;\n\n    // Collect all security levels from both offices\n    vector<int> levels;\n    for (int i = 0; i < H1; ++i) {\n        for (int j = 0; j < W1; ++j) {\n            levels.push_back(office1[i][j]);\n        }\n    }\n    for (int i = 0; i < H2; ++i) {\n        for (int j = 0; j < W2; ++j) {\n            levels.push_back(office2[i][j]);\n        }\n    }\n\n    sort(levels.begin(), levels.end());\n\n    int left = 0, right = levels.size() - 1;\n    int answer = INT_MAX;\n\n    // Binary search over possible levels\n    while (left <= right) {\n        int mid = (left + right) / 2;\n        int threshold = levels[mid];\n\n        // Count accessible rooms in office1\n        int count1 = 0;\n        for (int i = 0; i < H1; ++i) {\n            for (int j = 0; j < W1; ++j) {\n                if (office1[i][j] <= threshold) {\n                    count1++;\n                }\n            }\n        }\n\n        // Count accessible rooms in office2\n        int count2 = 0;\n        for (int i = 0; i < H2; ++i) {\n            for (int j = 0; j < W2; ++j) {\n                if (office2[i][j] <= threshold) {\n                    count2++;\n                }\n            }\n        }\n\n        if (count1 + count2 >= R) {\n            answer = threshold;\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    cout << answer << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:49:23"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 50\n#define MAX_M 50\n\nint office1[MAX_N][MAX_M];\nint office2[MAX_N][MAX_M];\nint N, M, R;\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint calculate_rooms_accessed(int auth_level, int office[MAX_N][MAX_M]) {\n    int rooms = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            if (auth_level >= office[i][j]) {\n                rooms++;\n            }\n        }\n    }\n    return rooms;\n}\n\nint solve() {\n    int min_auth = INT_MAX;\n    \n    for (int auth1 = 0; auth1 <= 100; auth1++) {\n        for (int auth2 = 0; auth2 <= 100; auth2++) {\n            int rooms1 = calculate_rooms_accessed(auth1, office1);\n            int rooms2 = calculate_rooms_accessed(auth2, office2);\n            \n            if (rooms1 + rooms2 >= R) {\n                min_auth = min(min_auth, auth1 + auth2);\n            }\n        }\n    }\n    \n    return min_auth;\n}\n\nint main() {\n    scanf(\"%d %d %d\", &N, &M, &R);\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            scanf(\"%d\", &office1[i][j]);\n        }\n    }\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            scanf(\"%d\", &office2[i][j]);\n        }\n    }\n    \n    printf(\"%d\\n\", solve());\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:49:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nconst int MAX_N = 50;\nconst int MAX_M = 50;\n\nint N1, M1, N2, M2, R;\nint office1[MAX_N][MAX_M];\nint office2[MAX_N][MAX_M];\n\nstruct State {\n    int auth1, auth2, rooms;\n    \n    bool operator<(const State& other) const {\n        return auth1 + auth2 > other.auth1 + other.auth2;\n    }\n};\n\nint solve() {\n    vector<vector<vector<bool>>> visited(101, vector<vector<bool>>(101, vector<bool>(R + 1, false)));\n    \n    priority_queue<State> pq;\n    pq.push({0, 0, 0});\n    \n    while (!pq.empty()) {\n        State curr = pq.top();\n        pq.pop();\n        \n        if (curr.rooms >= R) {\n            return curr.auth1 + curr.auth2;\n        }\n        \n        if (visited[curr.auth1][curr.auth2][curr.rooms]) {\n            continue;\n        }\n        visited[curr.auth1][curr.auth2][curr.rooms] = true;\n        \n        for (int i = 0; i < N1; i++) {\n            for (int j = 0; j < M1; j++) {\n                if (curr.auth1 >= office1[i][j]) {\n                    int newRooms = curr.rooms + 1;\n                    int newAuth1 = max(curr.auth1, office1[i][j]);\n                    pq.push({newAuth1, curr.auth2, newRooms});\n                }\n            }\n        }\n        \n        for (int i = 0; i < N2; i++) {\n            for (int j = 0; j < M2; j++) {\n                if (curr.auth2 >= office2[i][j]) {\n                    int newRooms = curr.rooms + 1;\n                    int newAuth2 = max(curr.auth2, office2[i][j]);\n                    pq.push({curr.auth1, newAuth2, newRooms});\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    cin >> N1 >> M1 >> N2 >> M2 >> R;\n    \n    for (int i = 0; i < N1; i++) {\n        for (int j = 0; j < M1; j++) {\n            cin >> office1[i][j];\n        }\n    }\n    \n    for (int i = 0; i < N2; i++) {\n        for (int j = 0; j < M2; j++) {\n            cin >> office2[i][j];\n        }\n    }\n    \n    int result = solve();\n    cout << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:49:39"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static int H, W, N, R;\n    static int[][] office1, office2;\n    static int[] dx = {-1, 1, 0, 0};\n    static int[] dy = {0, 0, -1, 1};\n\n    static class Room {\n        int x, y, level;\n\n        Room(int x, int y, int level) {\n            this.x = x;\n            this.y = y;\n            this.level = level;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        H = sc.nextInt();\n        W = sc.nextInt();\n        N = sc.nextInt();\n        R = sc.nextInt();\n\n        office1 = new int[H][W];\n        office2 = new int[H][W];\n\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                office1[i][j] = sc.nextInt();\n            }\n        }\n\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                office2[i][j] = sc.nextInt();\n            }\n        }\n\n        int x = sc.nextInt() - 1;\n        int y = sc.nextInt() - 1;\n\n        List<Integer> levels1 = bfs(office1, x, y);\n        List<Integer> levels2 = bfs(office2, x, y);\n\n        Collections.sort(levels1);\n        Collections.sort(levels2);\n\n        int minSum = Integer.MAX_VALUE;\n\n        for (int i = 0; i <= levels1.size(); i++) {\n            int j = Math.max(0, R - i);\n            if (j > levels2.size()) continue;\n            int sum = (i == 0 ? 0 : levels1.get(i - 1)) + (j == 0 ? 0 : levels2.get(j - 1));\n            if (sum < minSum) {\n                minSum = sum;\n            }\n        }\n\n        System.out.println(minSum);\n    }\n\n    static List<Integer> bfs(int[][] office, int x, int y) {\n        PriorityQueue<Room> pq = new PriorityQueue<>(Comparator.comparingInt(r -> r.level));\n        boolean[][] visited = new boolean[H][W];\n        List<Integer> levels = new ArrayList<>();\n\n        pq.add(new Room(x, y, office[x][y]));\n        visited[x][y] = true;\n\n        while (!pq.isEmpty()) {\n            Room current = pq.poll();\n            levels.add(current.level);\n\n            for (int d = 0; d < 4; d++) {\n                int nx = current.x + dx[d];\n                int ny = current.y + dy[d];\n\n                if (nx >= 0 && nx < H && ny >= 0 && ny < W && !visited[nx][ny]) {\n                    visited[nx][ny] = true;\n                    pq.add(new Room(nx, ny, office[nx][ny]));\n                }\n            }\n        }\n\n        return levels;\n    }\n}",
    "timestamp": "2025-08-05 18:50:10"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\nfrom collections import defaultdict\n\ndef min_authentication_level(office1, office2, R):\n    def build_graph_and_do_bfs(office, elevator, rows, cols):\n        dx, dy = [1, -1, 0, 0], [0, 0, 1, -1]\n        queue = [(office[elevator[0]][elevator[1]], elevator[0], elevator[1])]\n        room_security = defaultdict(list)\n        heapq.heapify(queue)\n        visited = set()\n        visited.add((elevator[0], elevator[1]))\n        \n        while queue:\n            sec_level, r, c = heapq.heappop(queue)\n            room_security[sec_level].append((r, c))\n            \n            for i in range(4):\n                nr, nc = r + dx[i], c + dy[i]\n                if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited:\n                    visited.add((nr, nc))\n                    heapq.heappush(queue, (office[nr][nc], nr, nc))\n        \n        return room_security\n\n    def select_rooms(room_security, total_rooms):\n        levels = sorted(room_security.keys())\n        selected_rooms, min_sum_security = 0, 0\n        \n        for level in levels:\n            available_rooms = len(room_security[level])\n            if selected_rooms + available_rooms >= total_rooms:\n                remaining_rooms = total_rooms - selected_rooms\n                min_sum_security += level * remaining_rooms\n                break\n            else:\n                selected_rooms += available_rooms\n                min_sum_security += level * available_rooms\n        \n        return min_sum_security\n\n    rows1, cols1, elevator1 = office1['rows'], office1['cols'], office1['elevator']\n    rows2, cols2, elevator2 = office2['rows'], office2['cols'], office2['elevator']\n    \n    room_security1 = build_graph_and_do_bfs(office1['security'], elevator1, rows1, cols1)\n    room_security2 = build_graph_and_do_bfs(office2['security'], elevator2, rows2, cols2)\n    \n    min_sum1 = select_rooms(room_security1, R)\n    min_sum2 = select_rooms(room_security2, R)\n    \n    return min(min_sum1, min_sum2)\n\n# Example usage:\noffice1 = {\n    'rows': 3, \n    'cols': 3, \n    'elevator': (0, 0), \n    'security': [\n        [1, 3, 2],\n        [1, 2, 2],\n        [3, 2, 1]\n    ]\n}\n\noffice2 = {\n    'rows': 3, \n    'cols': 3, \n    'elevator': (0, 0), \n    'security': [\n        [2, 3, 3],\n        [2, 1, 1],\n        [3, 1, 2]\n    ]\n}\n\nR = 4\nprint(min_authentication_level(office1, office2, R))",
    "timestamp": "2025-08-13 01:00:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class MinAuthLevel {\n    static final int MAX = 500;\n\n    static int[][] securityLevelsA, securityLevelsB;\n    static int n, m, r;\n    static int elevatorX, elevatorY;\n    \n    public static int findMinSum(int[][] securityLevels) {\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\n        boolean[][] visited = new boolean[n][m];\n        pq.offer(new int[]{elevatorX, elevatorY, securityLevels[elevatorX][elevatorY]});\n        \n        int sum = 0;\n        int roomsCount = 0;\n        \n        while (!pq.isEmpty() && roomsCount < r) {\n            int[] current = pq.poll();\n            int x = current[0], y = current[1], secLevel = current[2];\n            \n            if (visited[x][y]) continue;\n            visited[x][y] = true;\n            sum += secLevel;\n            roomsCount++;\n            \n            int[] dx = {-1, 0, 1, 0};\n            int[] dy = {0, 1, 0, -1};\n            for (int i = 0; i < 4; i++) {\n                int nx = x + dx[i], ny = y + dy[i];\n                if (nx >= 0 && nx < n && ny >= 0 && ny < m && !visited[nx][ny]) {\n                    pq.offer(new int[]{nx, ny, securityLevels[nx][ny]});\n                }\n            }\n        }\n        \n        return roomsCount >= r ? sum : Integer.MAX_VALUE;\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        n = scanner.nextInt();\n        m = scanner.nextInt();\n        r = scanner.nextInt();\n        elevatorX = scanner.nextInt();\n        elevatorY = scanner.nextInt();\n\n        securityLevelsA = new int[n][m];\n        securityLevelsB = new int[n][m];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                securityLevelsA[i][j] = scanner.nextInt();\n            }\n        }\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                securityLevelsB[i][j] = scanner.nextInt();\n            }\n        }\n        \n        int minSumA = findMinSum(securityLevelsA);\n        int minSumB = findMinSum(securityLevelsB);\n        \n        int result = Math.min(minSumA, minSumB);\n        if (result == Integer.MAX_VALUE) {\n            System.out.println(\"Impossible\");\n        } else {\n            System.out.println(result);\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 01:00:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_N 100\n#define MAX_LEVEL 1000\n#define INF (MAX_N * MAX_N * MAX_LEVEL)\n\ntypedef struct {\n    int x, y;\n} Position;\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nvoid find_min_authentication(int office[MAX_N][MAX_N], int n, int m, Position elevator, int *auth_levels, int *num_rooms) {\n    int visited[MAX_N][MAX_N] = {0};\n    int authentication = 0;\n    *num_rooms = 0;\n    \n    while (*num_rooms < n * m) {\n        int min_level = INF;\n        Position selected = {-1, -1};\n        \n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (!visited[i][j] && office[i][j] <= authentication && office[i][j] < min_level) {\n                    min_level = office[i][j];\n                    selected.x = i;\n                    selected.y = j;\n                }\n            }\n        }\n        \n        if (selected.x == -1 && selected.y == -1) {\n            authentication++;\n        } else {\n            visited[selected.x][selected.y] = 1;\n            auth_levels[(*num_rooms)++] = authentication;\n        }\n    }\n}\n\nint main() {\n    int n1, m1, n2, m2, R;\n    scanf(\"%d %d %d %d %d\", &n1, &m1, &n2, &m2, &R);\n    \n    Position elevator1, elevator2;\n    scanf(\"%d %d\", &elevator1.x, &elevator1.y);\n    scanf(\"%d %d\", &elevator2.x, &elevator2.y);\n    \n    int office1[MAX_N][MAX_N], office2[MAX_N][MAX_N];\n    for (int i = 0; i < n1; ++i) {\n        for (int j = 0; j < m1; ++j) {\n            scanf(\"%d\", &office1[i][j]);\n        }\n    }\n    \n    for (int i = 0; i < n2; ++i) {\n        for (int j = 0; j < m2; ++j) {\n            scanf(\"%d\", &office2[i][j]);\n        }\n    }\n    \n    int auth_levels1[MAX_N * MAX_N] = {0}, num_rooms1;\n    int auth_levels2[MAX_N * MAX_N] = {0}, num_rooms2;\n\n    find_min_authentication(office1, n1, m1, elevator1, auth_levels1, &num_rooms1);\n    find_min_authentication(office2, n2, m2, elevator2, auth_levels2, &num_rooms2);\n\n    int min_auth_sum = INF;\n    for (int i = 0; i <= num_rooms1 && i <= R; ++i) {\n        if (R - i <= num_rooms2) {\n            int sum1 = 0, sum2 = 0;\n            for (int j = 0; j < i; ++j) sum1 += auth_levels1[j];\n            for (int j = 0; j < R - i; ++j) sum2 += auth_levels2[j];\n            min_auth_sum = min(min_auth_sum, sum1 + sum2);\n        }\n    }\n\n    printf(\"%d\\n\", min_auth_sum);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 01:01:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_authentication_problem(R, N1, M1, A1, N2, M2, A2):\n    # Create lists to store room security levels for each office\n    office1_rooms = []\n    office2_rooms = []\n    \n    # Read input for office 1\n    for _ in range(N1):\n        row = list(map(int, input().split()))\n        office1_rooms.append(row)\n    \n    # Read input for office 2\n    for _ in range(N2):\n        row = list(map(int, input().split()))\n        office2_rooms.append(row)\n    \n    # Find elevator hall coordinates\n    elev1_x, elev1_y = A1[0]-1, A1[1]-1\n    elev2_x, elev2_y = A2[0]-1, A2[1]-1\n    \n    # Create DP table to track minimum authentication levels\n    dp = [[float('inf')] * (R+1) for _ in range(R+1)]\n    dp[0][0] = 0\n    \n    # Explore all possible room combinations\n    for x1 in range(R+1):\n        for x2 in range(R+1):\n            if dp[x1][x2] == float('inf'):\n                continue\n            \n            # Try adding rooms from office 1\n            if x1 < R:\n                for i in range(N1):\n                    for j in range(M1):\n                        if i == elev1_x and j == elev1_y:\n                            continue\n                        new_auth = max(dp[x1][x2], office1_rooms[i][j])\n                        dp[x1+1][x2] = min(dp[x1+1][x2], new_auth)\n            \n            # Try adding rooms from office 2\n            if x2 < R:\n                for i in range(N2):\n                    for j in range(M2):\n                        if i == elev2_x and j == elev2_y:\n                            continue\n                        new_auth = max(dp[x1][x2], office2_rooms[i][j])\n                        dp[x1][x2+1] = min(dp[x1][x2+1], new_auth)\n    \n    # Find minimum authentication level\n    min_auth = float('inf')\n    for x1 in range(R+1):\n        for x2 in range(R+1):\n            if x1 + x2 >= R:\n                min_auth = min(min_auth, dp[x1][x2])\n    \n    return min_auth if min_auth != float('inf') else -1\n\n# Read input parameters\nR, N1, M1 = map(int, input().split())\nA1 = list(map(int, input().split()))\nN2, M2 = map(int, input().split())\nA2 = list(map(int, input().split()))\n\n# Solve and print result\nresult = solve_authentication_problem(R, N1, M1, A1, N2, M2, A2)\nprint(result)",
    "timestamp": "2025-08-13 01:01:21"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    \n    H1 = int(data[idx])\n    W1 = int(data[idx+1])\n    idx +=2\n    \n    office1 = []\n    for _ in range(H1):\n        row = list(map(int, data[idx:idx+W1]))\n        office1.append(row)\n        idx += W1\n    \n    a1 = int(data[idx]) -1\n    b1 = int(data[idx+1]) -1\n    idx +=2\n    \n    H2 = int(data[idx])\n    W2 = int(data[idx+1])\n    idx +=2\n    \n    office2 = []\n    for _ in range(H2):\n        row = list(map(int, data[idx:idx+W2]))\n        office2.append(row)\n        idx += W2\n    \n    a2 = int(data[idx]) -1\n    b2 = int(data[idx+1]) -1\n    idx +=2\n    \n    R = int(data[idx])\n    idx +=1\n    \n    def dijkstra(office, start_x, start_y):\n        H = len(office)\n        W = len(office[0])\n        directions = [(-1,0), (1,0), (0,-1), (0,1)]\n        heap = []\n        heapq.heappush(heap, (office[start_x][start_y], start_x, start_y))\n        visited = [[False for _ in range(W)] for _ in range(H)]\n        visited[start_x][start_y] = True\n        levels = []\n        \n        while heap:\n            level, x, y = heapq.heappop(heap)\n            levels.append(level)\n            if len(levels) >= R:\n                break\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < H and 0 <= ny < W and not visited[nx][ny]:\n                    visited[nx][ny] = True\n                    heapq.heappush(heap, (max(level, office[nx][ny]), nx, ny))\n        return levels\n    \n    levels1 = dijkstra(office1, a1, b1)\n    levels2 = dijkstra(office2, a2, b2)\n    \n    min_sum = float('inf')\n    for k in range(0, R+1):\n        if k <= len(levels1) and (R - k) <= len(levels2):\n            sum1 = levels1[k-1] if k > 0 else 0\n            sum2 = levels2[R - k -1] if (R -k) >0 else 0\n            total = sum1 + sum2\n            if total < min_sum:\n                min_sum = total\n    print(min_sum)\n\nsolve()",
    "timestamp": "2025-08-13 01:01:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nstruct Room {\n    int x, y;\n    int securityLevel;\n};\n\nint main() {\n    int R, C1, C2, X1, Y1, X2, Y2, R_needed;\n    cin >> R >> C1 >> C2 >> X1 >> Y1 >> X2 >> Y2 >> R_needed;\n\n    vector<vector<int>> office1(R, vector<int>(C1));\n    vector<vector<int>> office2(R, vector<int>(C2));\n\n    for (int i = 0; i < R; ++i) {\n        for (int j = 0; j < C1; ++j) {\n            cin >> office1[i][j];\n        }\n    }\n\n    for (int i = 0; i < R; ++i) {\n        for (int j = 0; j < C2; ++j) {\n            cin >> office2[i][j];\n        }\n    }\n\n    auto bfs = [&](int startX, int startY, const vector<vector<int>>& office) {\n        int rows = office.size();\n        int cols = office[0].size();\n        vector<vector<int>> visited(rows, vector<int>(cols, 0));\n        priority_queue<int, vector<int>, greater<int>> pq;\n        queue<Room> q;\n        \n        q.push({startX, startY, office[startX][startY]});\n        visited[startX][startY] = 1;\n        \n        vector<int> dx = {-1, 1, 0, 0};\n        vector<int> dy = {0, 0, -1, 1};\n        \n        while (!q.empty()) {\n            Room current = q.front();\n            q.pop();\n            pq.push(office[current.x][current.y]);\n\n            for (int i = 0; i < 4; ++i) {\n                int newX = current.x + dx[i];\n                int newY = current.y + dy[i];\n\n                if (newX >= 0 && newX < rows && newY >= 0 && newY < cols && !visited[newX][newY]) {\n                    visited[newX][newY] = 1;\n                    q.push({newX, newY, office[newX][newY]});\n                }\n            }\n        }\n\n        vector<int> securityLevels;\n        while (!pq.empty()) {\n            securityLevels.push_back(pq.top());\n            pq.pop();\n        }\n        return securityLevels;\n    };\n\n    auto levels1 = bfs(X1, Y1, office1);\n    auto levels2 = bfs(X2, Y2, office2);\n\n    vector<int> combined(levels1);\n    combined.insert(combined.end(), levels2.begin(), levels2.end());\n    sort(combined.begin(), combined.end());\n\n    int minSum = 0;\n    for (int i = 0; i < R_needed; ++i) {\n        minSum += combined[i];\n    }\n    \n    cout << minSum << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 10:57:45"
  }
]