[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define p pair<int,int>\n#define P pair<int,p>\nusing namespace std;\n\nint x[4] = { -1,0,0,1 }, y[4] = { 0,-1,1,0 };\nint f[500][500];\nbool i[500][500];\nset<p>l,r;\nsigned main() {\n\tint a;\n\twhile (cin >> a, a) {\n\t\tl.insert(p(0, 0)); r.insert(p(0, 0));\n\t\tint b, c, d, e; cin >> c >> b >> e >> d;\n\t\td--; e--;\n\t\tfor (int g = 0; g < b; g++) {\n\t\t\tfor (int h = 0; h < c; h++) {\n\t\t\t\tscanf(\"%lld\", &f[g][h]);\n\t\t\t}\n\t\t}\n\t\tmemset(i, true, sizeof(i));\n\t\tint sum = 0, MAX = 0;\n\t\tpriority_queue<P, vector<P>, greater<P>>Q;\n\t\tQ.push(P(1, p(d, e)));\n\t\twhile (Q.size()) {\n\t\t\tP o = Q.top(); Q.pop();\n\t\t\tMAX = o.first; \n\t\t\tif(i[o.second.first][o.second.second])sum++;\n\t\t\ti[o.second.first][o.second.second] = false;\n\t\t\tqueue<p>q;\n\t\t\tq.push(p(o.second.first, o.second.second));\n\t\t\twhile (q.size()) {\n\t\t\t\tp t = q.front(); q.pop();\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint dx = t.first + x[i], dy = t.second + y[i];\n\t\t\t\t\tif (dx >= 0 && dx < b&&dy >= 0 && dy < c&&::i[dx][dy]) {\n\t\t\t\t\t\tif (f[dx][dy] <= o.first) {\n\t\t\t\t\t\t\tsum++;\n\t\t\t\t\t\t\tq.push(p(dx,dy));\n\t\t\t\t\t\t\t::i[dx][dy] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tQ.push(P(f[dx][dy],p(dx,dy)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tl.insert(p(sum, MAX));\n\t\t}\n\t\tcin >> c >> b >> e >> d;\n\t\td--; e--;\n\t\tfor (int g = 0; g < b; g++) {\n\t\t\tfor (int h = 0; h < c; h++) {\n\t\t\t\tscanf(\"%lld\", &f[g][h]);\n\t\t\t}\n\t\t}\n\t\tmemset(i, true, sizeof(i));\n\t\tsum = 0; MAX = 0;\n\t\tpriority_queue<P, vector<P>, greater<P>>U;\n\t\tU.push(P(1, p(d, e)));\n\t\twhile (U.size()) {\n\t\t\tP o = U.top(); U.pop();\n\t\t\tMAX = o.first;\n\t\t\tif (i[o.second.first][o.second.second])sum++;\n\t\t\ti[o.second.first][o.second.second] = false;\n\t\t\tqueue<p>q;\n\t\t\tq.push(p(o.second.first, o.second.second));\n\t\t\twhile (q.size()) {\n\t\t\t\tp t = q.front(); q.pop();\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint dx = t.first + x[i], dy = t.second + y[i];\n\t\t\t\t\tif (dx >= 0 && dx < b&&dy >= 0 && dy < c&&::i[dx][dy]) {\n\t\t\t\t\t\tif (f[dx][dy] <= o.first) {\n\t\t\t\t\t\t\tsum++;\n\t\t\t\t\t\t\tq.push(p(dx, dy));\n\t\t\t\t\t\t\t::i[dx][dy] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tU.push(P(f[dx][dy], p(dx, dy)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tr.insert(p(sum, MAX));\n\t\t}\n\t\tint MIN = LLONG_MAX/3;\n\t\tfor (auto i = l.begin(); i != l.end(); i++) {\n\t\t\tauto j = r.lower_bound(p(a-(*i).first,0));\n\t\t\tif (j != r.end()) {\n\t\t\t\tMIN = min(MIN, (*i).second + (*j).second);\n\t\t\t}\n\t\t}\n\t\tcout << 0 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define MP make_pair\n#define PB push_back\n#define FI first\n#define SE second\n#define MAX_K 200000\ntypedef pair< int,pair<int,pair<int, int> > > P3;\ntypedef pair<int, pair<int, int> > P2;\ntypedef pair<int, int> P1;\nstatic const int INF = 1ll<<60;\nstatic const int dx[] = { 1, -1, 0, 0, };\nstatic const int dy[] = { 0, 0, 1, -1 };\n\nint W1,H1,W2,H2,R;\nint sx1,sy1,sx2,sy2;\nint fe1[550][550],fe2[550][550];\nvector<int> V;\nvector<int> S;\nmap<int,int> level[2];\nint ans=INF;\nint visit[550][550];\n\nvoid input(int* W,int* H,int* sx,int* sy,int fe[550][550]){\n    scanf(\"%d%d%d%d\",W,H,sx,sy);\n    for(int y=0;y<*H;++y)\n        for(int x=0;x<*W;++x)scanf(\"%d\",&fe[y][x]);\n}\n\nvoid bfs(int num,int W,int H,int sx,int sy,int fe[550][550]){\n    memset(visit,0,sizeof(visit));\n    priority_queue<P2,vector<P2>,greater<P2> > que;\n    que.push(P2(fe[sy-1][sx-1],P1(sx-1,sy-1)));\n    while(!que.empty()){\n        P2 p = que.top();\n        que.pop();\n        int cost=p.first;\n        int x=p.second.first;\n        int y=p.second.second;\n        if(visit[y][x]==1)continue;\n        visit[y][x]=1;\n        level[num][cost]++;\n        for(int i=0;i<4;++i){\n            int nx=x+dx[i],ny=y+dy[i];\n            if(nx<0||nx>=W||ny<0||ny>=H||visit[ny][nx])continue;\n\n            int maxcost=max(cost,fe[ny][nx]);\n            que.push(P2(maxcost,P1(nx,ny)));\n        }\n    }\n}\n\nsigned main(){\n    while(1){\n        cin>>R;\n        if(R==0)break;\n        input(&W1,&H1,&sx1,&sy1,fe1);\n        input(&W2,&H2,&sx2,&sy2,fe2);\n        bfs(0,W1,H1,sx1,sy1,fe1);\n        bfs(1,W2,H2,sx2,sy2,fe2);\n\n        int sum1=0;\n\n        for(map<int,int>::iterator i=level[0].begin();i!=level[0].end();++i){\n            S.PB(i->first);\n            V.PB(i->second+sum1);\n            sum1+=i->second;\n        }\n\n        int sum2=0;\n        level[0][0]=0;\n        level[1][0]=0;\n        for(map<int,int>::iterator i=level[1].begin();i!=level[1].end();++i){\n            int cost = i->first;\n            int cnt2 = i->second+sum2;\n            int cnt1 = *lower_bound(V.begin(),V.end(),R-cnt2);\n            ans=min(ans,cost+S[lower_bound(V.begin(),V.end(),R-cnt2)-V.begin()]);\n            sum2+=i->second;\n        }\n\n        cout<<ans<<endl;\n        ans=INF;\n        V.clear();\n        S.clear();\n        level[0].clear();\n        level[1].clear();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,b) FOR(i,0,b)\n\t\nstruct cxy{\n\tint cost,x,y;\n\tbool operator<(const cxy& rhs)const{\n\t\treturn cost<rhs.cost;\n\t}\n\tbool operator>(const cxy& rhs)const{\n\t\treturn cost>rhs.cost;\n\t}\n};\n\nint CalcTable(int* ret){\n\tint w,h,x,y;\n\tscanf(\"%d%d%d%d\",&w,&h,&x,&y);\n\tstatic int m[500][500];\n\tREP(i,h)\n\t\tREP(j,w)\n\t\t\tscanf(\"%d\",&m[i][j]);\n\tret[0]=0;\n\tpriority_queue<cxy,vector<cxy>,greater<cxy> > pq;\n\tstatic bool used[500][500];\n\tREP(i,h)\n\t\tREP(j,w)\n\t\t\tused[i][j]=false;\n\tpq.push({1,--x,--y});\n\tused[y][x]=true;\n\tint c=0;\n\tstatic const int dxy[] = {0,-1,0,1,0};\n\tint b=0;\n\twhile(!pq.empty()){\n\t\tcxy t=pq.top();\n\t\tpq.pop();\n\t\tb=max(b,t.cost);\n\t\tret[++c]=b;\n\t\tREP(i,4){\n\t\t\tint nx=t.x+dxy[i];\n\t\t\tint ny=t.y+dxy[i+1];\n\t\t\tif(0<=nx&&nx<w&&0<=ny&&ny<h)\n\t\t\t\tif(!used[ny][nx]){\n\t\t\t\t\tpq.push({m[ny][nx],nx,ny});\n\t\t\t\t\tused[ny][nx]=true;\n\t\t\t\t}\n\t\t}\n\t}\n\treturn w*h+1;\n}\n\t\nint main(){\n\twhile(1){\n\t\tint r;\n\t\tscanf(\"%d\",&r);\n\t\tif(r==0)\n\t\t\tbreak;\n\t\tstatic int buf1[250001];\n\t\tstatic int buf2[250001];\n\t\tint r1 = CalcTable(buf1);\n\t\tint r2 = CalcTable(buf2);\n\t\tint ans=1145141919;\n\t\tREP(i,r1){\n\t\t\tint j=r-i;\n\t\t\tif(0<=j&&j<r2)\n\t\t\t\tans = min(ans,buf1[i]+buf2[j]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <queue>\n\nusing namespace std;\n\nconst int N = 500;\nconst int INF = 1000000000;\n\nclass S{\npublic:\n  int x, y, cost;\n  S(){}\n  S(int x, int y, int cost) : x(x), y(y), cost(cost) {}\n  bool operator < (const S& s) const {\n    return cost > s.cost;\n  }\n};\n\nint R, w[2], h[2], sx[2], sy[2], input[2][N][N], vis[N][N];\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nvector<int> vec[2];\nset<int> data;\n\nvoid bfs(int x, int y, int cost, int d){\n  priority_queue<S> q;\n  S u;\n  q.push(S(x, y, cost));\n  vis[y][x] = cost;\n  while(!q.empty()){\n    u = q.top(); q.pop();\n    if(vis[u.y][u.x] < u.cost) continue;\n    for(int i=0;i<4;i++){\n      int ny = u.y + dy[i];\n      int nx = u.x + dx[i];\n      if(ny < 0 || ny >= h[d]) continue;\n      if(nx < 0 || nx >= w[d]) continue;\n      if(vis[ny][nx] > max(u.cost, input[d][ny][nx])){\n        vis[ny][nx] = max(u.cost, input[d][ny][nx]);\n        q.push(S(nx, ny, max(u.cost, input[d][ny][nx])));\n      }\n    }\n  }\n}\n\nvoid init(){\n  data.clear();\n  for(int k=0;k<2;k++){\n    for(int i=0;i<h[k];i++){\n      for(int j=0;j<w[k];j++){\n        data.insert(input[k][i][j]);\n      }\n    }\n  }\n  for(int k=0;k<2;k++){\n    fill(vis[0], vis[N], INF);\n    bfs(sx[k], sy[k], 1, k);\n    vec[k].clear();\n    for(int i=0;i<h[k];i++){\n      for(int j=0;j<w[k];j++){\n        vec[k].push_back(vis[i][j]);\n      }\n    }\n    sort(vec[k].begin(), vec[k].end());\n  }\n}\n\nint solve(){\n  int l = 0, r = 100000000;\n  while(l<r){\n    int m = (l + r) / 2;\n    bool f = false;\n    for(set<int>::iterator ite=data.begin();ite!=data.end();ite++){\n      if(*ite > m) break;\n      int a = distance(vec[0].begin(), upper_bound(vec[0].begin(), vec[0].end(), *ite));\n      int b = distance(vec[1].begin(), upper_bound(vec[1].begin(), vec[1].end(), m-(*ite)));\n      if(a + b >= R) f = true;\n    }\n    if(f) r = m;\n    else l = m + 1;\n  }\n  return l;\n}\n\nmain(){\n  while(cin >> R && R){\n    for(int k=0;k<2;k++){\n      cin >> w[k] >> h[k] >> sx[k] >> sy[k];\n      sx[k]--; sy[k]--;\n      for(int i=0;i<h[k];i++){\n        for(int j=0;j<w[k];j++){\n          cin >> input[k][i][j];\n        }\n      }\n    }\n    init();\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef pair<int,pair<int,int>> PP;\nint r,w[2],h[2],x[2],y[2];\nlong long level[501][501][2];\nbool used[501][501][2]={};\nlong long sparklingdaydream[501][501][2];\nlong long need[250005][2]={};\nlong long s[250005]={},d[250005]={};\nint main(){\n\twhile(1){\n\t\tmemset(need,0,sizeof(need));\n\t\tmemset(s,0,sizeof(s));\n\t\tmemset(d,0,sizeof(d));\n\t\tmemset(used,false,sizeof(used));\n\tpriority_queue<PP,vector<PP>,greater<PP>>pque;\n\tscanf(\"%d\",&r);\n\tif(r==0) break;\n\tscanf(\"%d %d %d %d\",&w[0],&h[0],&x[0],&y[0]);\n\tfor(int r=0;r<501;r++){\n\t\tfor(int g=0;g<501;g++){\n\t\t\t\tsparklingdaydream[r][g][0]=1000000000000;\n\t\t\t\tlevel[r][g][0]=1000000000000;\n\t\t\t}\n\t\t}\n\tfor(int i=1;i<=h[0];i++){\n\t\tfor(int j=1;j<=w[0];j++){\n\t\t\tscanf(\"%lld\",&level[j][i][0]);\n\t\t}\n\t}\n\tsparklingdaydream[x[0]][y[0]][0]=1;\n\tpque.push(make_pair(sparklingdaydream[x[0]][y[0]][0],make_pair(x[0],y[0])));\n\tint dx[3]={0,1,-1};\n\tint dy[3]={0,1,-1};\n\twhile(!pque.empty()){\n\t\tPP p=pque.top();\n\t\tpque.pop();\n\t\tused[p.second.first][p.second.second][0]=true;\n\t\tfor(int k=0;k<3;k++){\n\t\t\tfor(int l=0;l<3;l++){\n\t\t\t\tif(k!=l && (k==0 || l==0)){\n\t\t\t\t\tif(!used[p.second.first+dx[k]][p.second.second+dy[l]][0]){\n\t\t\t\t\t\tif(p.second.first+dx[k]>=1 && p.second.first+dx[k]<=w[0] && p.second.second+dy[l]>=1 && p.second.second+dy[l]<=h[0]){\n\t\t\t\t\t\t\tlong long h=p.first;\n\t\t\t\t\t\t\tsparklingdaydream[p.second.first+dx[k]][p.second.second+dy[l]][0]=max(h,level[p.second.first+dx[k]][p.second.second+dy[l]][0]);\n\t\t\t\t\t\t\tpque.push(make_pair(sparklingdaydream[p.second.first+dx[k]][p.second.second+dy[l]][0],make_pair(p.second.first+dx[k],p.second.second+dy[l])));\n\t\t\t\t\t\t\tused[p.second.first+dx[k]][p.second.second+dy[l]][0]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tfor(int r=0;r<501;r++){\n\t\tfor(int g=0;g<501;g++){\n\t\t\t\tsparklingdaydream[r][g][1]=1000000000000;\n\t\t\t\tlevel[r][g][1]=1000000000000;\n\t\t\t}\n\t\t}\n\tscanf(\"%d %d %d %d\",&w[1],&h[1],&x[1],&y[1]);\n\tfor(int i=1;i<=h[1];i++){\n\t\tfor(int j=1;j<=w[1];j++){\n\t\t\tscanf(\"%lld\",&level[j][i][1]);\n\t\t}\n\t}\n\tsparklingdaydream[x[1]][y[1]][1]=1;\n\tpque.push(make_pair(sparklingdaydream[x[1]][y[1]][1],make_pair(x[1],y[1])));\n\twhile(!pque.empty()){\n\t\tPP p=pque.top();\n\t\tpque.pop();\n\t\tused[p.second.first][p.second.second][1]=true;\n\t\tfor(int k=0;k<3;k++){\n\t\t\tfor(int l=0;l<3;l++){\n\t\t\t\tif(k!=l && (k==0 || l==0)){\n\t\t\t\t\tif(!used[p.second.first+dx[k]][p.second.second+dy[l]][1]){\n\t\t\t\t\t\tif(p.second.first+dx[k]>=1 && p.second.first+dx[k]<=w[1] && p.second.second+dy[l]>=1 && p.second.second+dy[l]<=h[1]){\n\t\t\t\t\t\t\tlong long h=p.first;\n\t\t\t\t\t\t\tsparklingdaydream[p.second.first+dx[k]][p.second.second+dy[l]][1]=max(h,level[p.second.first+dx[k]][p.second.second+dy[l]][1]);\n\t\t\t\t\t\t\tpque.push(make_pair(sparklingdaydream[p.second.first+dx[k]][p.second.second+dy[l]][1],make_pair(p.second.first+dx[k],p.second.second+dy[l])));\n\t\t\t\t\t\t\tused[p.second.first+dx[k]][p.second.second+dy[l]][1]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tint g=0;\n\tfor(int i=1;i<=w[0];i++){\n\t\tfor(int j=1;j<=h[0];j++){\n\t\t\ts[g]=sparklingdaydream[i][j][0];\n\t\t\tg++;\n\t\t}\n\t}\n\tsort(s,s+g);\n\tint eee=1;\n\tfor(int i=0;i<g;i++){\n\t\tif(s[i]!=s[i+1]){\n\t\t\tfor(int j=eee;j<=i+1;j++){\n\t\t\t\tneed[j][0]=s[i];\n\t\t\t\teee=i+2;\n\t\t\t}\n\t\t}\n\t}\n\tg=0;\n\tfor(int i=1;i<=w[1];i++){\n\t\tfor(int j=1;j<=h[1];j++){\n\t\t\td[g]=sparklingdaydream[i][j][1];\n\t\t\tg++;\n\t\t}\n\t}\n\tsort(d,d+g);\n\teee=1;\n\tfor(int i=0;i<g;i++){\n\t\tif(d[i]!=d[i+1]){\n\t\t\tfor(int j=eee;j<=i+1;j++){\n\t\t\t\tneed[j][1]=d[i];\n\t\t\t\teee=i+2;\n\t\t\t}\n\t\t}\n\t}\n\tlong long ans=10000000000;\n\tfor(int i=1;i<250005;i++){\n\t\tfor(int j=0;j<2;j++){\n\t\t\tif(!need[i][j]){\n\t\t\tneed[i][j]=10000000000000;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=r;i++){\n\t\tans=min(ans,need[i][0]+need[r-i][1]);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <tuple>\n\ntemplate <class T>\nusing MinHeap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class T>\nstd::vector<T> vec(int len, T elem) { return std::vector<T>(len, elem); }\n\nconstexpr int INF = 1 << 30;\n\nconst std::vector<std::pair<int, int>>\n    dxys{{0, -1}, {0, 1}, {-1, 0}, {1, 0}};\n\nbool solve() {\n    int r;\n    std::cin >> r;\n    if (r == 0) return false;\n\n    std::vector<std::vector<int>> levss(2);\n    for (auto& levs : levss) {\n        int h, w, sx, sy;\n        std::cin >> w >> h >> sy >> sx;\n        --sx, --sy;\n\n        auto grid = vec(h, vec(w, 0));\n        for (auto& v : grid) {\n            for (auto& x : v) std::cin >> x;\n        }\n\n        auto visited = vec(h, vec(w, false));\n        visited[sx][sy] = 1;\n\n        MinHeap<std::tuple<int, int, int>> heap;\n        heap.emplace(grid[sx][sy], sx, sy);\n\n        levs.resize(h * w + 1, 0);\n        int cnt = 0, lmax = 0;\n\n        while (!heap.empty()) {\n            int l, x, y;\n            std::tie(l, x, y) = heap.top();\n            heap.pop();\n\n            lmax = std::max(lmax, l);\n            levs[++cnt] = lmax;\n\n            for (auto dxy : dxys) {\n                int dx, dy;\n                std::tie(dx, dy) = dxy;\n\n                int nx = x + dx,\n                    ny = y + dy;\n                if (nx < 0 || h <= nx ||\n                    ny < 0 || w <= ny ||\n                    visited[nx][ny]) continue;\n\n                visited[nx][ny] = true;\n                heap.emplace(grid[nx][ny], nx, ny);\n            }\n        }\n\n        levs.resize(r + 1, INF);\n    }\n\n    int ans = INF;\n    for (int i = 0; i <= r; ++i) {\n        ans = std::min(ans, levss[0][i] + levss[1][r - i]);\n    }\n\n    std::cout << ans << \"\\n\";\n    return true;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    while (solve()) {}\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nll c[2501];\nll b[500][500];\nstruct A {\n\tll ko, level;\n};\nA a[2][2501];\nll u[500][500];\nstruct P {\n\tll x, y, level;\n};\nll d[2];\nbool operator<(P a, P b) { return a.level < b.level; }\nbool operator>(P a, P b) { return a.level > b.level; }\nconst ll inf = 800000000000000000;\nint main() {\n\tll r;\n\tint lp[4][2] = { {1,0},{-1,0},{0,1},{0,-1} };\n\twhile (cin >> r&&r != 0) {\n\t\tfor (int z = 0; z < 2; z++) {\n\t\t\tll h, w, x, y;\n\t\t\tcin >> w >> h >> y >> x;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tqueue<P>p;\n\t\t\tfor (ll i = 0; i < h; i++) {\n\t\t\t\tfor (ll j = 0; j < w; j++) {\n\t\t\t\t\tcin >> u[i][j];\n\t\t\t\t\tb[i][j] = inf;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.push(P{ x,y,1 });\n\t\t\tb[x][y] = 1;\n\t\t\twhile (!p.empty()) {\n\t\t\t\tP t = p.front(); p.pop();\n\t\t\t\tll x = t.x, y = t.y;\n\t\t\t\tif (t.level == b[x][y]) {\n\t\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\t\tll x2 = x + lp[i][0], y2 = y + lp[i][1];\n\t\t\t\t\t\tif (b[x2][y2] > t.level) {\n\t\t\t\t\t\t\tif (u[x2][y2] <= t.level) {\n\t\t\t\t\t\t\t\tb[x2][y2] = t.level;\n\t\t\t\t\t\t\t\tp.push(P{ x2,y2,t.level });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (u[x2][y2] < b[x2][y2]) {\n\t\t\t\t\t\t\t\t\tb[x2][y2] = u[x2][y2];\n\t\t\t\t\t\t\t\t\tp.push(P{ x2,y2,u[x2][y2] });\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tll o = 0;\n\t\t\tfor (ll i = 0; i < h; i++) {\n\t\t\t\tfor (ll j = 0; j < w; j++) {\n\t\t\t\t\tc[o] = b[i][j];\n\t\t\t\t\to++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(c, c + o);\n\t\t\tll sum = 0, g = 1;\n\t\t\ta[z][0] = A{ 0,0 };\n\t\t\tfor (ll i = 0; i < (h*w);) {\n\t\t\t\tll k = c[i], sum2 = 0;\n\t\t\t\twhile (i < (h*w) && c[i] == k) {\n\t\t\t\t\tsum2++;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\ta[z][g] = A{ sum2 + sum,k };\n\t\t\t\tg++;\n\t\t\t\tsum += sum2;\n\t\t\t}\n\t\t\td[z] = g;\n\t\t}\n\t\tll sum = inf;\n\t\tfor (ll i = 0; i < d[0]; i++) {\n\t\t\tll s = 0, e = d[1] - 1, t, m = r - a[0][i].ko;\n\t\t\twhile (e - s > 1) {\n\t\t\t\tt = (e + s) / 2;\n\t\t\t\tif (a[1][t].ko <= m)\n\t\t\t\t\ts = t;\n\t\t\t\tif (a[1][t].ko >= m)\n\t\t\t\t\te = t;\n\t\t\t}\n\t\t\tif (a[0][i].ko + a[1][s].ko >= r)\n\t\t\t\tsum = min(sum, a[0][i].level + a[1][s].level);\n\t\t\tif (a[0][i].ko + a[1][e].ko >= r)\n\t\t\t\tsum = min(sum, a[0][i].level + a[1][e].level);\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> plli;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst ll mod = 1e9 + 7;\nconst ll INF = 1<<30;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\nint r;\nint w1, h1, x1, y1;\nint w2, h2, x2, y2;\nint g1[505][505], g2[505][505];\n\nbool check(int y, int x, int h, int w) {\n    if ((0 <= y && y < h) && (0 <= x && x < w)) return true;\n    return false;\n}\n\nvector<int> search(int sy, int sx, int h, int w, int g[505][505]) {\n    priority_queue<pipii, vector<pipii>, greater<pipii>> pq;\n    pq.push(make_pair(1LL, make_pair(sy, sx)));\n    bool visited[h + 5][w + 5]={};\n    vector<int> cnt;\n    cnt.pb(0);\n    int now_level = 1;\n    visited[sy][sx] = true;\n    while (!pq.empty()) {\n        pipii p = pq.top();\n        pq.pop();\n        int level = p.fi;\n        int y = p.se.fi;\n        int x = p.se.se;\n        //cout << level << endl;\n        if (now_level < level) {\n            cnt.pb(level);\n            now_level = level;\n        }\n        else {\n            cnt.pb(now_level);\n        }\n        rep(i, 4) {\n            int ny = y + dy4[i];\n            int nx = x + dx4[i];\n            if (!check(ny, nx, h, w) || visited[ny][nx]) continue;\n            pq.push(make_pair(g[ny][nx], make_pair(ny, nx)));\n            //cout << ny << nx << endl;\n            visited[ny][nx] = true;\n        }\n    }\n    return cnt;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> r;\n    while (r != 0) {\n        cin >> w1 >> h1 >> x1 >> y1;\n        x1--;y1--;\n        rep(i, h1)rep(j, w1) cin >> g1[i][j];\n        cin >> w2 >> h2 >> x2 >> y2;\n        x2--;y2--;\n        rep(i, h2)rep(j, w2) cin >> g2[i][j];\n        vector<int> cnt1 = search(y1, x1, h1, w1, g1);\n        vector<int> cnt2 = search(y2, x2, h2, w2, g2);\n        int ans = 1e12;\n        rep(i, r + 1) {\n            if (cnt1.size() <= i) break;\n            if (cnt2.size() <= r - i) continue;\n            ans = min(ans, cnt1[i] + cnt2[r - i]);\n        }\n        cout << ans << endl;\n        cin >> r;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <iterator>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <cmath>\n#include <complex>\n#include <functional>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <cstdlib>\n#include <cctype>\n\n#define REP(i,m,n) for(int i=m;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rp(i,c) rep(i,(int)c.size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define v_delete(a,b) (a).erase(remove((a).begin(), (a).end(), b), (a).end())\n#define v_unique(a) (a).erase(unique((a).begin(), (a).end()), (a).end())\n#define VV(T) vector<vector< T > >\n#define init(a,b) memset((a), (b), sizeof((a)))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double EPS=1e-9;\nconst long long INF = 100001000010000100ll;\n\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntypedef pair<int,int> pii;\n\nint R;\nint W[2], H[2], X[2], Y[2];\n\nint m[4][500+10][500+10];\nint visited[2][500+10][500+10];\n\nint wa[2][500*500+10];\n\nvi ls;\n\nmap<int ,int> cnt[2];\n\nbool exists(const map<int ,int> &mapp, int key){\n\treturn mapp.find(key) != mapp.end();\n}\n\nint dx[]={1,0,0,-1};\nint dy[]={0,1,-1,0};\n\nclass BIT{\nprivate:\n\tvi bit;\n\tint n;\npublic:\n\tBIT(int _n){\n\t\tn = _n;\n\t\tbit.assign(n+1,0 );\n\t}\n\tvoid add(int i, int x){\n\t\twhile(i <= n){\n\t\t\tbit[i] += x;\n\t\t\ti += (i & -i);\n\t\t}\n\t}\n\tint sum(int i){\n\t\tint s = 0;\n\t\twhile(i > 0){\n\t\t\ts += bit[i];\n\t\t\ti -= (i & -i);\n\t\t}\n\t\treturn s;\n\t}\n};\n\n\nint main(){\n\twhile(cin >> R){\n\n\t\tmemset(visited, 0, sizeof(visited));\n\n\t\tmemset(wa, 0, sizeof(wa));\n\n\t\tls.clear();\n\n\t\tfill_n(**m, 4 * (500+10) * (500+10), inf);\n\n\t\trep(c, 2){\n\t\t\tcin >> W[c] >> H[c] >> X[c] >> Y[c];\n\t\t\trep(i, H[c]){\n\t\t\t\trep(j, W[c]){\n\t\t\t\t\tcin >> m[c][i+1][j+1];\n\t\t\t\t\tls.pb(m[c][i+1][j+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tls.pb(0);\n\t\tls.pb(inf);\n\t\tsort(all(ls));\n\t\tls.erase(unique(all(ls)), ls.end());\n\t\trep(c, 2){\n\t\t\tpriority_queue<pair<int, pii>, vector<pair<int, pii> >, greater<pair<int, pii> > >Q;\n\t\t\tQ.push(mp(1, mp(X[c], Y[c])));\n\t\t\twhile(!Q.empty()){\n\t\t\t\tint x,y,level;\n\t\t\t\tx=Q.top().second.first;y=Q.top().second.second;level=Q.top().first;\n\t\t\t\tvisited[c][y][x] = 1;\n\n\t\t\t\tif(level > m[c][y][x]){\n\t\t\t\t\tm[c][y][x] = level;\n\t\t\t\t}else{\n\t\t\t\t\tlevel = m[c][y][x];\n\t\t\t\t}\n\t\t\t\t//printf(\"%d %d %d %d\\n\",c, x, y, level);\n\n\t\t\t\tQ.pop();\n\t\t\t\trep(k, 4){\n\t\t\t\t\tif(m[c][y+dy[k]][x+dx[k]]!=inf){\n\t\t\t\t\t\tif(!visited[c][y+dy[k]][x+dx[k]]){\n\t\t\t\t\t\t\tQ.push(mp(max(m[c][y+dy[k]][x+dx[k]], level), mp(x+dx[k], y+dy[k])));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}/*\n\t\trep(c, 2){\n\t\t\trep(i, H[c]){\n\t\t\t\trep(j, W[c]){\n\t\t\t\t\tcout <<  m[c][i+1][j+1] << \" \";\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\tcout << endl;\n\t\t\tcout << endl;\n\t\t}*/\n\t\trep(c, 2){\n\t\t\trep(i, H[c]){\n\t\t\t\trep(j, W[c]){\n\t\t\t\t\tint ma=-1;\n\t\t\t\t\tint tmp=inf;\n\t\t\t\t\t/*\n\t\t\t\t\trep(k, 4){\n\t\t\t\t\t\ttmp=min(tmp, m[c][i + 1 + dx[k]][j + 1 + dy[k]]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i + 1 == Y[c] && j + 1 == X[c]){\n\t\t\t\t\t\tma=m[c][i + 1][j + 1];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tma = max(m[c][i + 1][j + 1], tmp);\n\t\t\t\t\t}*/\n\t\t\t\t\tma=m[c][i + 1][j + 1];\n\t\t\t\t\tint l = lower_bound(all(ls), ma) - ls.begin();\n\t\t\t\t\twa[c][l]++;\n\n\t\t\t\t}\n\t\t\t}\n\t\t\trp(i, ls){\n\t\t\t\tif(i - 1 >= 0)\n\t\t\t\t\twa[c][i] = wa[c][i - 1] + wa[c][i];\n\t\t\t}\n\n\t\t}\n\t\t/*\n\t\trep(c, 2){\n\t\t\trp(i, ls){\n\t\t\t\tcout << ls[i] << \" \" << wa[c][i] << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\tcout << endl;\n\t\t}*/\n\t\tint ans=inf;\n\t\trp(i, ls){\n\n\t\t\tint l=lower_bound(wa[1],(wa[1]+(int)ls.size()) , R - wa[0][i]) - wa[1];\n\t\t\tif(l < ls.size())\n\t\t\tif(wa[0][i] + wa[1][l] >= R){\n\t\t\t\t//cout << ls[i] << \" \" << ls[l] << endl;\n\t\t\t\tans=min(ans, ls[i] + ls[l]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\n\nconst int INF=1000000000;\nconst long long int INF_=1000000000000000000;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\ninline bool IsIn(int y,int x,int h,int w){\n\treturn 0<=y&&y<h&&0<=x&&x<w;\n}\n\nvoid BFS(vector<vector<int> > &f,vector<vector<int> > &l,int sy,int sx,int h,int w){\n\tvector<vector<int> > done(h,vector<int>(w));\n\tvector<vector<int> > done_(h,vector<int>(w));\n\tl[sy][sx]=1;\n\tdone[sy][sx]=done_[sy][sx]=1;\n\tqueue<Pi> que;\n\tREP(i,0,4){\n\t\tint ny=sy+dy[i],nx=sx+dx[i];\n\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\tdone_[ny][nx]=1;\n\t\tque.push(Pi(ny,nx));\n\t}\n\twhile(!que.empty()){\n\t\tPi p=que.front();\n\t\tque.pop();\n\t\tdone[p.F_][p.S_]=1;\n\t\tbool flag=true;\n\t\tint tmp=INF;\n\t\tREP(i,0,4){\n\t\t\tint ny=p.F_+dy[i],nx=p.S_+dx[i];\n\t\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\t\tif(done[ny][nx]==1) tmp=min(tmp,l[ny][nx]);\n\t\t\tif(done[ny][nx]==1&&l[ny][nx]>=f[p.F_][p.S_]) flag=false;\n\t\t\tif(done_[ny][nx]!=1){\n\t\t\t\tdone_[ny][nx]=1;\n\t\t\t\tque.push(Pi(ny,nx));\n\t\t\t}\n\t\t}\n\t\tif(flag) l[p.F_][p.S_]=f[p.F_][p.S_];\n\t\telse {\n\t\t\tif(tmp!=INF) l[p.F_][p.S_]=max(tmp,f[p.F_][p.S_]);\n\t\t\telse l[p.F_][p.S_]=f[p.F_][p.S_];\n\t\t}\n\t}\n}\n\ninline int f(int x){\n\tif(x==0) return 1;\n\telse if(x==1) return 0;\n}\n\nvoid solve(){\n\tint R;\n\twhile(cin >> R&&R){\n\t\tint W[2],H[2],X[2],Y[2];\n\t\tvector<vector<int> > field[2];\n\t\tvector<vector<int> > level[2];\n\t\tint max_[2]={};\n\t\tREP(i,0,2){\n\t\t\tcin >> W[i] >> H[i] >> X[i] >> Y[i];\n\t\t\t--X[i]; --Y[i];\n\t\t\tfield[i].resize(H[i]);\n\t\t\tlevel[i].resize(H[i]);\n\t\t\tREP(j,0,H[i]){\n\t\t\t\tfield[i][j].resize(W[i]);\n\t\t\t\tlevel[i][j].resize(W[i]);\n\t\t\t}\n\t\t\tREP(y,0,H[i]) REP(x,0,W[i]){\n\t\t\t\tcin >> field[i][y][x];\n\t\t\t\tmax_[i]=max(max_[i],field[i][y][x]);\n\t\t\t}\n\t\t\tBFS(field[i],level[i],Y[i],X[i],H[i],W[i]);\n\t\t\t/*\n\t\t\tcout << endl << endl;\n\t\t\tREP(y,0,H[i]){\n\t\t\t\tREP(x,0,W[i]) cout << level[i][y][x] << ' ';\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\t/*\n\t\tvector<unsigned int> s[2];\n\t\tREP(i,0,2){\n\t\t\ts[i].resize(max_[i]+1);\n\t\t\tREP(y,0,H[i]) REP(x,0,W[i]) ++s[i][level[i][y][x]];\n\t\t\tREP(j,1,max_[i]+1) s[i][j]+=s[i][j-1];\n\t\t}\n\t\tint result=INF;\n\t\tREP(i,0,2){\n\t\t\tfor(int j=0; j<=max_[i]&&j<=result; ++j){\n\t\t\t\tint idx=(int)(lower_bound(s[i].begin(),s[i].end(),R-s[f(i)][j])-s[i].begin());\n\t\t\t\tif(!(0<=idx&&idx<=max_[i])) continue;\n\t\t\t\tresult=min(result,j+idx);\n\t\t\t}\n\t\t}\n\t\tcout << result << endl;\n\t\t*/\n\t\tmap<int,int> s[2];\n\t\tvector<int> idx[2],num[2];\n\t\tREP(i,0,2){\n\t\t\tREP(y,0,H[i]) REP(x,0,W[i]) ++s[i][level[i][y][x]];\n\t\t\tauto it=s[i].begin();\n\t\t\tidx[i].push_back(0);\n\t\t\tnum[i].push_back(0);\n\t\t\tidx[i].push_back(it->F_);\n\t\t\tnum[i].push_back(it->S_);\n\t\t\tauto prev=it;\n\t\t\t++it;\n\t\t\tfor(; it!=s[i].end(); ++it,++prev){\n\t\t\t\tit->S_+=prev->S_;\n\t\t\t\t//cout << it->F_ << ' ' << it->S_ << endl;\n\t\t\t\tidx[i].push_back(it->F_);\n\t\t\t\tnum[i].push_back(it->S_);\n\t\t\t}\n\t\t}\n\t\tint result=INF;\n\t\t/*\n\t\tcout << endl;\n\t\tREP(i,0,2) REP(j,0,idx[i].size()){\n\t\t\tcout << i << ' ' << idx[i][j] << ' ' << num[i][j] << endl;\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\t\tREP(i,0,2) REP(j,0,idx[i].size()){\n\t\t\tint tmp=(int)(lower_bound(num[f(i)].begin(),num[f(i)].end(),R-num[i][j])-num[f(i)].begin());\n\t\t\t//cout << idx[i][tmp] << ' ' << num[i][tmp] << ' ' << idx[f(i)][j] << ' ' << num[f(i)][j] << endl;\n\t\t\tif(!(0<=tmp&&tmp<=idx[f(i)].size()-1)) continue;\n\t\t\tresult=min(result,idx[i][j]+idx[f(i)][tmp]);\n\t\t}\n\t\tcout << result << endl;\n\t}\n}\n\nint main(){\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<map>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int i,j,k;\n  int r;\n  while(cin>>r&&r){\n    int a[2][502][502],w[2],h[2],x[2],y[2];\n    memset(a,-1,sizeof(a));\n    for(i=0;i<2;i++){\n      cin>>w[i]>>h[i]>>x[i]>>y[i];\n      for(j=1;j<h[i]+1;j++)\n\tfor(k=1;k<w[i]+1;k++)\n\t  cin>>a[i][k][j];\n    }\n    unsigned b[2][502][502];\n    memset(b,-1,sizeof(b));\n    for(i=0;i<2;i++){\n      queue<pair<pair<int,int>,int> > c;\n      c.push(make_pair(make_pair(x[i],y[i]),0));\n      while(c.empty()==0){\n\tint u,v,z;\n\tu=c.front().first.first;\n\tv=c.front().first.second;\n\tz=c.front().second;\n\tc.pop();\n\tif(a[i][u][v]!=-1&&b[i][u][v]>(unsigned)max(a[i][u][v],z)){\n\t  b[i][u][v]=max(a[i][u][v],z);\n\t  c.push(make_pair(make_pair(u-1,v),max(a[i][u][v],z)));\n\t  c.push(make_pair(make_pair(u+1,v),max(a[i][u][v],z)));\n\t  c.push(make_pair(make_pair(u,v-1),max(a[i][u][v],z)));\n\t  c.push(make_pair(make_pair(u,v+1),max(a[i][u][v],z)));\n\t}\n      }\n    }\n    map<int,int> c[2];\n    map<int,int>::iterator it,jt;\n    for(i=0;i<2;i++){\n      c[i][0]=0;\n      for(j=1;j<h[i]+1;j++)\n\tfor(k=1;k<w[i]+1;k++)\n\t  c[i][b[i][k][j]]++;\n    }\n    for(i=0;i<2;i++){\n      it=jt=c[i].begin();\n      for(jt++;jt!=c[i].end();){\n\t(*jt).second+=(*it).second;\n\tit++;\n\tjt++;\n      }\n    }\n    for(i=1;;i++){\n      for(j=0;j<i+1;j++){\n\tit=c[0].upper_bound(j);\n\tit--;\n\tjt=c[1].upper_bound(i-j);\n\tjt--;\n\tif((*it).second+(*jt).second>=r)\n\t  break;\n      }\n      if(j!=i+1)\n\tbreak;\n    }\n    cout<<i<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint l[2][500][500];\nbool c[2][500][500];\nint memo[2][250001];\n\nstruct level{\n  int l;\n  int x;\n  int y;\n  level(int a,int b,int c){\n    l=a; x=b; y=c;\n  }\n};\n\nbool operator < (const level &a, const level &b){\n  return a.l > b.l;\n}\n\nint main(){\n  int r;\n  while(r = getInt()){\n    int w[2],h[2],x[2],y[2];\n    REP(k,2){\n      w[k] = getInt();\n      h[k] = getInt();\n      x[k] = getInt() - 1;\n      y[k] = getInt() - 1;\n      REP(i,h[k]) REP(j,w[k]){\n        l[k][i][j] = getInt();\n        c[k][i][j] = false;\n      }\n\n      priority_queue<level> pq;\n      pq.push(level(1,x[k],y[k]));\n      c[k][y[k]][x[k]] = true;\n\n      int cnt = 0;\n      int now = 1;\n\n      memo[k][cnt++] = 0;\n      while(!pq.empty()){\n        level lv = pq.top();\n        int ll = lv.l;\n        int xx = lv.x;\n        int yy = lv.y;\n        pq.pop();\n        //printf(\"%d %d %d\\n\",ll,xx,yy);\n\n        memo[k][cnt++] = (now = max(ll, now));\n        if(cnt == r+1) break;\n\n        REP(i,4){\n          int xxx = xx + _dx[i];\n          int yyy = yy + _dy[i];\n\n          if(ISIN(xxx,yyy,w[k],h[k]) && !c[k][yyy][xxx]){\n            c[k][yyy][xxx] = true;\n            pq.push(level(l[k][yyy][xxx], xxx, yyy));\n          }\n        }\n      }\n\n      //REP(i, w[k]*h[k]+1) printf(\"%d \",memo[k][i]); puts(\"\");\n    }\n\n    int end = min(r, w[0] * h[0]) + 1;\n    int start = max(0, r - w[1] * h[1]);\n    int ans = INT_MAX;\n    rep(i,start,end)\n      ans = min(ans, memo[0][i] + memo[1][r-i]);\n    print(ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\n\nclass union_find {\n\tvector<int> par;\n\tvector<int> rank;\n\tint find(int a) {\n\t\treturn par[a] < 0 ? a : par[a] = find(par[a]);\n\t}\npublic:\n\tunion_find(int n) : par(n, -1), rank(n, 1) {}\n\tbool same(int a, int b) {\n\t\treturn find(a) == find(b);\n\t}\n\tvoid unite(int a, int b) {\n\t\ta = find(a);\n\t\tb = find(b);\n\t\tif (a == b) return;\n\t\tif (rank[a] > rank[b]) {\n\t\t\tpar[a] += par[b];\n\t\t\tpar[b] = a;\n\t\t}\n\t\telse {\n\t\t\tpar[b] += par[a];\n\t\t\tpar[a] = b;\n\t\t\tif (rank[a] == rank[b]) rank[b]++;\n\t\t}\n\t}\n\tint size(int a) {\n\t\treturn -par[find(a)];\n\t}\n};\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint R;\n\twhile (cin >> R, R) {\n\t\tvector<vector<int>> v(2);\n\t\tfor (int k = 0; k < 2; k++) {\n\t\t\tint W, H, X, Y;\n\t\t\tcin >> W >> H >> X >> Y; X--, Y--;\n\t\t\tvector<vector<int>> a(H, vector<int>(W));\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tcin >> a[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tvector<int> cs;\n\t\t\tvector<vector<int>> es;\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tif (i + 1 < H) {\n\t\t\t\t\t\tcs.push_back(max(a[i][j], a[i + 1][j]));\n\t\t\t\t\t\tes.push_back(vector<int>({ max(a[i][j], a[i + 1][j]), i * W + j, (i + 1) * W + j }));\n\t\t\t\t\t}\n\t\t\t\t\tif (j + 1 < W) {\n\t\t\t\t\t\tcs.push_back(max(a[i][j], a[i][j + 1]));\n\t\t\t\t\t\tes.push_back(vector<int>({ max(a[i][j], a[i][j + 1]), i * W + j, i * W + j + 1 }));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(cs.begin(), cs.end());\n\t\t\tcs.erase(unique(cs.begin(), cs.end()), cs.end());\n\t\t\tsort(es.begin(), es.end());\n\n\t\t\tv[k].assign(H * W + 1, INF);\n\t\t\tv[k][0] = 0;\n\t\t\tv[k][1] = 1;\n\t\t\tunion_find uf(H * W);\n\t\t\tfor (int i = 0, j = 0; i < (int)cs.size(); i++) {\n\t\t\t\twhile (j < (int)es.size() && es[j][0] == cs[i]) {\n\t\t\t\t\tuf.unite(es[j][1], es[j][2]);\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tint sz = uf.size(Y * W + X);\n\t\t\t\tv[k][sz] = min(v[k][sz], cs[i]);\n\t\t\t}\n\t\t\tfor (int i = H * W - 1; i >= 2; i--) {\n\t\t\t\tv[k][i] = min(v[k][i], v[k][i + 1]);\n\t\t\t}\n\t\t}\n\t\tint res = INF;\n\t\tfor (int i = 0; i < (int)v[0].size(); i++) if (0 <= R - i && R - i < (int)v[1].size()) {\n\t\t\tres = min(res, v[0][i] + v[1][R - i]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing PII = pair<int, int>;\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T> using VV = vector<V<T>>;\ntemplate <typename T> using VVV = vector<VV<T>>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll INF = (1LL<<60);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nclass UnionFind {\npublic:\n  const static int MAX_N = 250010;\n  int par[MAX_N];\n  int s[MAX_N];\n  UnionFind() { init(); }\n  UnionFind(int n) { init(n); }\n  void init() { for(int i=0; i<MAX_N; ++i) par[i] = i, s[i] = 1; }\n  void init(int n) { for(int i=0; i<n; ++i) par[i] = i, s[i] = 1; }\n  int find(int x) {\n    if(par[x] == x) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(s[x] < s[y]) par[x] = y, s[y] = s[x] + s[y];\n    else par[y] = x, s[x] = s[x] + s[y];\n  }\n  bool same(int x, int y) { return find(x) == find(y);}\n};\nUnionFind uf;\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(1) {\n    int r;\n    cin >> r;\n    if(!r) break;\n    int h, w, x, y;\n    VV<int> a;\n\n    auto func = [&]() -> V<int> {\n      V<int> v;\n      REP(i, h) REP(j, w) v.PB(a[i][j]);\n      sort(ALL(v));\n      v.erase(unique(ALL(v)), v.end());\n\n      // cout << v << endl;\n\n      VV<int> g2(v.size());\n      REP(i, h) REP(j, w) {\n        g2[lower_bound(ALL(v), a[i][j]) - v.begin()].PB(i*w+j);\n      }\n\n      // REP(i, v.size()) {\n      //   cout << i << \",\" << g2[i] << endl;\n      // }\n\n      VV<int> g(h*w);\n      REP(i, h) REP(j, w) {\n        REP(k, 4) {\n          int nx = j + dx[k], ny = i + dy[k];\n          if(IN(0LL,w,nx) && IN(0LL,h,ny) && a[i][j]>=a[ny][nx]) {\n            g[i*w+j].PB(ny*w+nx);\n            // cout << i << \",\" << j << \" \" << ny << \",\" << nx << endl;\n            // cout << i*w+j << \" \" << ny*w+nx << endl;\n          }\n        }\n      }\n\n      // b[i] = (部屋をi個訪れるときに必要な最小の認証レベル)\n      V<int> b(h*w+1, INF);\n      b[0] = 0, b[1] = 1;\n      uf.init(h*w);\n      REP(i, v.size()) {\n        // cout << \"i=\" << i << \" \" << v[i] << endl;\n        for(auto j: g2[i]) {\n          for(auto k: g[j]) {\n            // cout << j << \",\" << k << endl;\n            uf.unite(j, k);\n          }\n        }\n        chmin(b[uf.s[uf.find(y*w+x)]], v[i]);\n      }\n      return b;\n    };\n\n    cin >> w >> h >> x >> y, x--, y--;\n    a = VV<int>(h, V<int>(w));\n    REP(i, h) REP(j, w) cin >> a[i][j];\n    V<int> p = func();\n    for(int i=p.size()-2; i>=0; --i) {\n      chmin(p[i], p[i+1]);\n    }\n    // cout << p << endl;\n\n    cin >> w >> h >> x >> y, x--, y--;\n    a = VV<int>(h, V<int>(w));\n    REP(i, h) REP(j, w) cin >> a[i][j];\n    V<int> q = func();\n    for(int i=q.size()-2; i>=0; --i) {\n      chmin(q[i], q[i+1]);\n    }\n    // cout << q << endl;\n\n    int ret = INF;\n    REP(i, r+1) {\n      if(!IN(0LL,(int)p.size(),i) || !IN(0LL,(int)q.size(),r-i)) continue;\n      chmin(ret, p[i]+q[r-i]);\n      // cout << ret << \" \" << p[i] << \" \" << q[r-i] << endl;\n    }\n    cout << ret << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\n\nconst int INF=1000000000;\nconst long long int INF_=1000000000000000000;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\ninline bool IsIn(int y,int x,int h,int w){\n\treturn 0<=y&&y<h&&0<=x&&x<w;\n}\n\nvoid BFS(vector<vector<int> > &f,vector<vector<int> > &l,int sy,int sx,int h,int w){\n\tvector<vector<int> > done(h,vector<int>(w));\n\tvector<vector<int> > done_(h,vector<int>(w));\n\tl[sy][sx]=1;\n\tdone[sy][sx]=done_[sy][sx]=1;\n\tqueue<Pi> que;\n\tREP(i,0,4){\n\t\tint ny=sy+dy[i],nx=sx+dx[i];\n\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\tdone_[ny][nx]=1;\n\t\tque.push(Pi(ny,nx));\n\t}\n\twhile(!que.empty()){\n\t\tPi p=que.front();\n\t\tque.pop();\n\t\tdone[p.F_][p.S_]=1;\n\t\tbool flag=true;\n\t\tint tmp=INF;\n\t\tREP(i,0,4){\n\t\t\tint ny=p.F_+dy[i],nx=p.S_+dx[i];\n\t\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\t\tif(done[ny][nx]==1) tmp=min(tmp,l[ny][nx]);\n\t\t\t//if(p.S_==2&&p.F_==1) cout << l[ny][nx] << endl;\n\t\t\tif(done[ny][nx]==1&&l[ny][nx]>=f[p.F_][p.S_]) flag=false;\n\t\t\tif(done_[ny][nx]!=1){\n\t\t\t\tdone_[ny][nx]=1;\n\t\t\t\tque.push(Pi(ny,nx));\n\t\t\t}\n\t\t}\n\t\t//if(p.S_==2&&p.F_==1) cout << tmp << endl << endl;\n\t\tif(flag) l[p.F_][p.S_]=f[p.F_][p.S_];\n\t\telse {\n\t\t\tif(tmp!=INF) l[p.F_][p.S_]=max(tmp,f[p.F_][p.S_]);\n\t\t\telse l[p.F_][p.S_]=f[p.F_][p.S_];\n\t\t}\n\t}\n}\n\ninline int f(int x){\n\tif(x==0) return 1;\n\telse if(x==1) return 0;\n}\n\nvoid solve(){\n\tint R;\n\twhile(cin >> R&&R){\n\t\tint W[2],H[2],X[2],Y[2];\n\t\tvector<vector<int> > field[2];\n\t\tvector<vector<int> > level[2];\n\t\tint max_[2]={};\n\t\tREP(i,0,2){\n\t\t\tcin >> W[i] >> H[i] >> X[i] >> Y[i];\n\t\t\t--X[i]; --Y[i];\n\t\t\tfield[i].resize(H[i]);\n\t\t\tlevel[i].resize(H[i]);\n\t\t\tREP(j,0,H[i]){\n\t\t\t\tfield[i][j].resize(W[i]);\n\t\t\t\tlevel[i][j].resize(W[i]);\n\t\t\t}\n\t\t\tREP(y,0,H[i]) REP(x,0,W[i]){\n\t\t\t\tcin >> field[i][y][x];\n\t\t\t\tmax_[i]=max(max_[i],field[i][y][x]);\n\t\t\t}\n\t\t\tBFS(field[i],level[i],Y[i],X[i],H[i],W[i]);\n\t\t\t/*\n\t\t\tcout << endl << endl;\n\t\t\tREP(y,0,H[i]){\n\t\t\t\tREP(x,0,W[i]) cout << level[i][y][x] << ' ';\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\tvector<int> s[2];\n\t\tREP(i,0,2) s[i].resize(max_[i]+1);\n\t\tREP(i,0,2) REP(y,0,H[i]) REP(x,0,W[i]) ++s[i][level[i][y][x]];\n\t\tREP(i,0,2) REP(j,1,max_[i]+1) s[i][j]+=s[i][j-1];\n\t\tint result=INF;\n\t\tREP(i,0,2){\n\t\t\tfor(int j=0; j<=max_[i]&&j<=result; ++j){\n\t\t\t\tint idx=(int)(lower_bound(s[i].begin(),s[i].end(),R-s[f(i)][j])-s[i].begin());\n\t\t\t\tif(!(0<=idx&&idx<=max_[i])) continue;\n\t\t\t\tresult=min(result,j+idx);\n\t\t\t}\n\t\t}\n\t\tcout << result << endl;\n\t}\n}\n\nint main(){\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\n\nconst int N = 500;\nconst int inf = 1000000000;\nconst int dx[]={0,0,1,-1};\nconst int dy[]={1,-1,0,0};\n\nclass st{\npublic:\n  int y,x,cost;\n  bool operator<(const st & a)const{\n    return cost > a.cost;\n  }\n};\n\n\n/*\n  e®É½Çè­½ßÉKvÈÅ¬ÌFØxðßéB\n  »ÌÊÉîÃ¢ÄAx±Ì®ðKêé½ßÉKvÈÅ¬ÌxðvZ·é\n*/\nint cost[N][N];\nint m[N][N];\nvector<ll> dijkstra(int r,int c,int sy,int sx){\n  rep(i,r)rep(j,c)cost[i][j] = inf;\n  priority_queue<st> Q;\n  cost[sy][sx] = 1;\n  Q.push((st){sy,sx,1});\n  while(!Q.empty()){\n    st now = Q.top();Q.pop();\n    int y = now.y,x = now.x;\n    if (cost[y][x] != now.cost)continue;\n    rep(i,4){\n      int nex = x+dx[i],ney = y+dy[i];\n      if (nex == -1 || ney == -1 || nex == c || ney == r)continue;\n      int nec = max(now.cost,m[ney][nex]);\n      if (cost[ney][nex] > nec){\n\t//cout << y <<\" \"<< x <<\" to \" << ney <<\" \"<< nex <<\" \"<< now.cost <<\" \" << m[ney][nex] << endl;\n\tcost[ney][nex] = nec;\n\tQ.push((st){ney,nex,nec});\n      }\n    }\n  }\n  vector<ll> ret;\n  ret.push_back(0);/*0±Ì®ðKêéÉÍx0Å¢¢B*/\n  rep(i,r)rep(j,c)ret.push_back(cost[i][j]);\n  sort(ret.begin(),ret.end());\n  return ret;\n}\n\n\nvector<ll> compute(){\n  int r,c,sy,sx;\n  cin>>c>>r>>sx>>sy;\n  sy--;sx--;\n  rep(i,r)rep(j,c)cin>>m[i][j];\n  return dijkstra(r,c,sy,sx);\n}\n\nmain(){\n  int R;\n  while(cin>>R && R){\n    vector<ll> a=compute();\n    vector<ll> b = compute();\n    //rep(i,a.size())cout << a[i] <<\" \" ;cout << endl;\n    //rep(i,b.size())cout << b[i] <<\" \" ;cout << endl;\n    ll ans = inf;\n    rep(i,R+1){\n      int j = R-i;\n      if (i >= a.size() || j >= b.size())continue;\n      ans = min(ans,a[i]+b[j]);\n    }\n    cout << ans << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#define mp make_pair\nusing namespace std;\n\nint dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\ntypedef pair<int,pair<int,int> > P;\n\nint main(){\n\tint r,w,h,x,y,field[500][500],rank[500][500];\n\twhile(cin >> r,r){\n\t\tmap<int,int> sum;\n\t\tvector<int> vec[2][2];\n\t\tfor(int i = 0;i < 2;i++){\n\t\t\tsum.clear();\n\t\t\tcin >> w >> h >> x >> y;\n\t\t\tfor(int j = 0;j < h;j++){\n\t\t\t\tfor(int k = 0;k < w;k++){\n\t\t\t\t\tcin >> field[j][k];\n\t\t\t\t\trank[j][k] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\trank[y - 1][x - 1] = 1;\n\t\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\t\tque.push(mp(1,mp(y - 1,x - 1)));\n\t\t\twhile(!que.empty()){\n\t\t\t\tP p = que.top();que.pop();\n\t\t\t\tint nowr = p.first,nowy = p.second.first,nowx = p.second.second;\n\t\t\t\tfor(int j = 0;j < 4;j++){\n\t\t\t\t\tint ny = nowy + dy[j],nx = nowx + dx[j];\n\t\t\t\t\tif(ny >= 0 && ny < h && nx >= 0 && nx < w && rank[ny][nx] == -1){\n\t\t\t\t\t\tif(field[ny][nx] > nowr){\n\t\t\t\t\t\t\trank[ny][nx] = field[ny][nx];\n\t\t\t\t\t\t\tque.push(mp(rank[ny][nx],mp(ny,nx)));\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\trank[ny][nx] = nowr;\n\t\t\t\t\t\t\tque.push(mp(nowr,mp(ny,nx)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0;j < h;j++){\n\t\t\t\tfor(int k = 0;k < w;k++){\n\t\t\t\t\tsum[rank[j][k]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint s = 0;\n\t\t\tvec[i][0].push_back(0);\n\t\t\tvec[i][1].push_back(0);\n\t\t\tfor(auto itr = sum.begin();itr != sum.end();itr++){\n\t\t\t\ts += itr->second;\n\t\t\t\tvec[i][0].push_back(s);\n\t\t\t\tvec[i][1].push_back(itr->first);\n\t\t\t}\n\t\t}\n\t\tint mi = 1e+9;\n\t\tfor(int i = 0;i < vec[0][0].size();i++){\n\t\t\tint pos = lower_bound(vec[1][0].begin(),vec[1][0].end(),r - vec[0][0][i]) - vec[1][0].begin();\n\t\t\tif(pos < vec[1][0].size()) mi = min(mi,vec[0][1][i] + vec[1][1][pos]);\n\t\t}\n\t\tcout << mi << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\n\nconst int INF=1000000000;\nconst long long int INF_=1000000000000000000;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nbool IsIn(int y,int x,int h,int w){\n\treturn 0<=y&&y<h&&0<=x&&x<w;\n}\n\nvoid BFS(vector<vector<int> > &f,vector<vector<int> > &l,int sy,int sx,int h,int w){\n\tvector<vector<int> > done(h,vector<int>(w));\n\tvector<vector<int> > done_(h,vector<int>(w));\n\tl[sy][sx]=1;\n\tdone[sy][sx]=done_[sy][sx]=1;\n\tqueue<Pi> que;\n\tREP(i,0,4){\n\t\tint ny=sy+dy[i],nx=sx+dx[i];\n\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\tdone_[ny][nx]=1;\n\t\tque.push(Pi(ny,nx));\n\t}\n\twhile(!que.empty()){\n\t\tPi p=que.front();\n\t\tque.pop();\n\t\tdone[p.F_][p.S_]=1;\n\t\tbool flag=true;\n\t\tint tmp=INF;\n\t\tREP(i,0,4){\n\t\t\tint ny=p.F_+dy[i],nx=p.S_+dx[i];\n\t\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\t\tif(done[ny][nx]==1) tmp=min(tmp,l[ny][nx]);\n\t\t\t//if(p.S_==2&&p.F_==1) cout << l[ny][nx] << endl;\n\t\t\tif(done[ny][nx]==1&&l[ny][nx]>=f[p.F_][p.S_]) flag=false;\n\t\t\tif(done_[ny][nx]!=1){\n\t\t\t\tdone_[ny][nx]=1;\n\t\t\t\tque.push(Pi(ny,nx));\n\t\t\t}\n\t\t}\n\t\t//if(p.S_==2&&p.F_==1) cout << tmp << endl << endl;\n\t\tif(flag) l[p.F_][p.S_]=f[p.F_][p.S_];\n\t\telse {\n\t\t\tif(tmp!=INF) l[p.F_][p.S_]=max(tmp,f[p.F_][p.S_]);\n\t\t\telse l[p.F_][p.S_]=f[p.F_][p.S_];\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tint R;\n\twhile(cin >> R&&R){\n\t\tint W[2],H[2],X[2],Y[2];\n\t\tvector<vector<int> > field[2];\n\t\tvector<vector<int> > level[2];\n\t\tint _max=0;\n\t\tREP(i,0,2){\n\t\t\tcin >> W[i] >> H[i] >> X[i] >> Y[i];\n\t\t\t--X[i]; --Y[i];\n\t\t\tfield[i].resize(H[i]);\n\t\t\tlevel[i].resize(H[i]);\n\t\t\tREP(j,0,H[i]){\n\t\t\t\tfield[i][j].resize(W[i]);\n\t\t\t\tlevel[i][j].resize(W[i]);\n\t\t\t}\n\t\t\tREP(y,0,H[i]) REP(x,0,W[i]){\n\t\t\t\tcin >> field[i][y][x];\n\t\t\t\t_max=max(_max,field[i][y][x]);\n\t\t\t}\n\t\t\tBFS(field[i],level[i],Y[i],X[i],H[i],W[i]);\n\n\t\t\t/*\n\t\t\tcout << endl << endl;\n\t\t\tREP(y,0,H[i]){\n\t\t\t\tREP(x,0,W[i]) cout << level[i][y][x] << ' ';\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\tvector<int> s[2];\n\t\tREP(i,0,2) s[i].resize(_max+1);\n\t\tREP(i,0,2) REP(y,0,H[i]) REP(x,0,W[i]) ++s[i][level[i][y][x]];\n\t\tREP(i,0,2) REP(j,1,_max+1) s[i][j]+=s[i][j-1];\n\t\tint result=INF;\n\t\tfor(int i=0; i<=_max&&i<=result; ++i){\n\t\t\tint idx=(int)(lower_bound(s[1].begin(),s[1].end(),R-s[0][i])-s[1].begin());\n\t\t\tif(!(0<=idx&&idx<=_max)) continue;\n\t\t\tresult=min(result,i+idx);\n\t\t}\n\t\tcout << result << endl;\n\t}\n}\n\nint main(){\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\n\nusing namespace std;\n#define N 260010\n#define H 510\nclass UnionFind{\npublic:\n\tint p[N],s[N];\n\tint Par(int x){\n\t\tint a=x,t;\n\t\twhile(a!=p[a])a=p[a];\n\t\twhile(x!=a){\n\t\t\tt=p[x];\n\t\t\tp[x]=a,s[a]+=s[x],s[x]=0;\n\t\t\tx=t;\n\t\t}\n\t\treturn a;\n\t}\n\tint Num(int y,int x){return y*H+x;}\n\tvoid Unite(int y1,int x1,int y2,int x2){\n\t\tint a=Num(y1,x1),b=Num(y2,x2);\n\t\ta=Par(a),b=Par(b);\n\t\tif(a==b)return;\n\t\tp[a]=b,s[b]+=s[a],s[a]=0;\n\t}\n\tvoid Init(){\n\t\tlol(i,N)p[i]=i,s[i]=1;\n\t}\n};\nint res[2][N],lev[2][N],siz[2];\nint d[H][H];\nvector<pair<int,pair<int,int> > >v;\nUnionFind uf;\nint main(){\n\tint n,h,w,f,g;\n\twhile(cin>>n&&n){\n\tlol(k,2){cin>>w>>h>>f>>g;f--,g--;\n\t\tuf.Init();\n\t\tf=uf.Num(g,f);\n\t\tv.clear();\n\t\tlol(i,h)lol(j,w){\n\t\t\tcin>>d[i][j];\n\t\t\tv.push_back(make_pair(d[i][j],make_pair(i,j)));\n\t\t}\n\t\tsort(v.begin(),v.end());\n\t\tlol(i,v.size()){\n\t\t\tint cost=v[i].first;\n\t\t\tint y=v[i].second.first;\n\t\t\tint x=v[i].second.second;\n\t\t\tint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\t\t\tlol(j,4){\n\t\t\t\tint xx=x+dx[j],yy=y+dy[j];\n\t\t\t\tif(xx<0||xx==w||yy<0||yy==h)continue;\n\t\t\t\tif(d[yy][xx]<=cost)uf.Unite(yy,xx,y,x);\n\t\t\t}\n\t\t\tres[k][i+1]=uf.s[uf.Par(f)];\n\t\t\tlev[k][i+1]=cost;\n\t\t}\n\t\tres[k][0]=0,lev[k][0]=0;\n\t\tsiz[k]=v.size()+1;\n\t}\n\tint ans=mod;\n\tlol(i,siz[0]){\n\t\tif(res[0][i]+res[1][siz[1]-1]<n)continue;\n\t\tint l=-1,r=siz[1],m;\n\t\twhile(l<r-1){\n\t\t\tm=(l+r)/2;\n\t\t\tif(res[0][i]+res[1][m]>=n)r=m;\n\t\t\telse l=m;\n\t\t}\n\t\tans=min(ans,lev[0][i]+lev[1][r]);\n\t}\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,-1,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pint pair<int,int>\n#define tint tuple<int,int,int>\n#define INF 1<<29\n#define MAX 501\nusing namespace std;\n \nint R,W[2],H[2],X[2],Y[2],L[2][MAX][MAX],d[2][MAX][MAX],dd[4]={0,-1,0,1};\nmap<int,int> m[2];\nmap<int,int>::iterator ite;\nvector<int> lev,sum;\n \nvoid solve(){\n for(;;){\n  cin>>R;\n  if(!R) return;\n  FOR(i,2){\n   cin>>W[i]>>H[i]>>X[i]>>Y[i];\n   X[i]--;\n   Y[i]--;\n   FOR(j,H[i]) FOR(k,W[i]) cin>>L[i][j][k];\n   FOR(j,H[i]) FOR(k,W[i]) d[i][j][k]=INT_MAX/3;\n   d[i][X[i]][Y[i]]=1;\n   priority_queue<pint,vector<pint>,greater<pint>> pque;\n   pque.push(mp(1,X[i]*W[i]+Y[i]));\n   while(!pque.empty()){\n    pint p=pque.top(); pque.pop();\n    int x=p.second/W[i],y=p.second%W[i];\n    if(d[i][x][y]<p.first) continue;\n    FOR(j,4){\n     int nx=x+dd[j],ny=y+dd[j^1];\n     if(nx<0||ny<0||nx>=H[i]||ny>=W[i]) continue;\n     if(d[i][nx][ny]>max(d[i][x][y],L[i][nx][ny])){\n      d[i][nx][ny]=max(d[i][x][y],L[i][nx][ny]);\n      pque.push(mp(d[i][nx][ny],nx*W[i]+ny));\n     }\n    }\n   }\n   FOR(j,H[i]) FOR(k,W[i]) m[i][d[i][j][k]]++;\n   int tot=0;\n   lev[i].pb(0);\n   sum[i].pb(0);\n   for(ite=m[0].begin();ite!=m[0].end();ite++){\n    lev[i].pb(ite->first);\n    tot+=ite->second;\n    sum[i].pb(tot);\n   }\n  }\n  int mi=1<<30;\n  FOR(i,lev[0].size()){\n   int ind=lower_bound(ALL(sum[1]),R-sum[0])-sum[1].begin();\n   mi=min(mi,lev[ind]+lev[i]);\n  }\n  cout<<mi<<endl;\n  FOR(i,2){\n   m[i].clear();\n   lev[i].clear();\n   sum[i].clear();\n  }\n }\n}\n \nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct State{int H,W,sx,sy,x[500][500];};\nstruct P{int cost,cx,cy;};\nbool operator<(P p1,P p2){\n\tif(p1.cost<p2.cost)return true;\n\treturn false;\n}\nbool operator>(P p1,P p2){\n\tif(p1.cost>p2.cost)return true;\n\treturn false;\n}\nint dist[500][500];vector<int>v1,v2;\nvector<int>dijkstra(State I){\n\tfor(int i=0;i<I.H;i++){for(int j=0;j<I.W;j++)dist[i][j]=999999999;}\n\tpriority_queue<P,vector<P>,greater<P> >Q;\n\tQ.push(P{1,I.sx,I.sy});\n\tdist[I.sx][I.sy]=1;\n\twhile(!Q.empty()){\n\t\tP a1=Q.top();Q.pop();\n\t\tint dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint ex=a1.cx+dx[i],ey=a1.cy+dy[i];\n\t\t\tif(ex<0 || ey<0 || ex>=I.H || ey>=I.W)continue;\n\t\t\tint dst=max(dist[a1.cx][a1.cy],I.x[ex][ey]);\n\t\t\tif(dist[ex][ey]>dst){\n\t\t\t\tdist[ex][ey]=dst;Q.push(P{dist[ex][ey],ex,ey});\n\t\t\t}\n\t\t}\n\t}\n\tvector<int>ret;ret.push_back(0);\n\tfor(int i=0;i<I.H;i++){for(int j=0;j<I.W;j++)ret.push_back(dist[i][j]);}\n\tsort(ret.begin(),ret.end());\n\treturn ret;\n}\nint main(){\n\twhile(true){\n\t\tState S[2];int R;cin>>R;if(R==0)break;\n\t\tfor(int i=0;i<2;i++){\n\t\t\tcin>>S[i].W>>S[i].H>>S[i].sy>>S[i].sx;S[i].sx--;S[i].sy--;\n\t\t\tfor(int j=0;j<S[i].H;j++){\n\t\t\t\tfor(int k=0;k<S[i].W;k++){\n\t\t\t\t\tscanf(\"%d\",&S[i].x[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<2;i++){\n\t\t\tvector<int>v=dijkstra(S[i]);\n\t\t\tif(i==0)v1=v;else v2=v;\n\t\t}\n\t\tint minx=999999999;\n\t\tfor(int i=0;i<(int)v1.size();i++){\n\t\t\tint U=R-i;if(U>(int)v2.size())break;\n\t\t\tif(U<0)minx=min(minx,v1[i]);\n\t\t\telse minx=min(minx,v1[i]+v2[U]);\n\t\t}\n\t\tcout<<minx<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\ntypedef pair<int,Pi> PP;\n\nconst int INF=1000000000;\nconst long long int INF_=1000000000000000000;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\ninline bool IsIn(int y,int x,int h,int w){\n\treturn 0<=y&&y<h&&0<=x&&x<w;\n}\n\nvoid BFS(vector<vector<int> > &f,vector<vector<int> > &l,int sy,int sx,int h,int w){\n\tvector<vector<int> > done(h,vector<int>(w));\n\tvector<vector<int> > done_(h,vector<int>(w));\n\tl[sy][sx]=1;\n\tdone[sy][sx]=done_[sy][sx]=1;\n\tqueue<Pi> que;\n\tREP(i,0,4){\n\t\tint ny=sy+dy[i],nx=sx+dx[i];\n\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\tdone_[ny][nx]=1;\n\t\tque.push(Pi(ny,nx));\n\t}\n\twhile(!que.empty()){\n\t\tPi p=que.front();\n\t\tque.pop();\n\t\tdone[p.F_][p.S_]=1;\n\t\tbool flag=true;\n\t\tint tmp=INF;\n\t\tREP(i,0,4){\n\t\t\tint ny=p.F_+dy[i],nx=p.S_+dx[i];\n\t\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\t\tif(done[ny][nx]==1) tmp=min(tmp,l[ny][nx]);\n\t\t\tif(done[ny][nx]==1&&l[ny][nx]>=f[p.F_][p.S_]) flag=false;\n\t\t\tif(done_[ny][nx]!=1){\n\t\t\t\tdone_[ny][nx]=1;\n\t\t\t\tque.push(Pi(ny,nx));\n\t\t\t}\n\t\t}\n\t\tif(flag) l[p.F_][p.S_]=f[p.F_][p.S_];\n\t\telse {\n\t\t\tif(tmp!=INF) l[p.F_][p.S_]=max(tmp,f[p.F_][p.S_]);\n\t\t\telse l[p.F_][p.S_]=f[p.F_][p.S_];\n\t\t}\n\t}\n}\n\n/*\nvoid Djikstra(vector<vector<int> > &f,vector<vector<int> > &l,int sy,int sx,int h,int w){\n\tvector<vector<bool> > used(h,vector<bool>(w,false));\n\tREP(y,0,h) fill(l[y].begin(),l[y].end(),INF);\n\tl[sy][sx]=1;\n\twhile(true){\n\t\tPi v(-1,-1);\n\t\tREP(y,0,h){\n\t\t\tREP(x,0,w){\n\t\t\t\tif(!used[y][x]&&((v.F_==-1&&v.S_==-1)||l[y][x]<l[v.F_][v.S_])){\n\t\t\t\t\tv.F_=y;\n\t\t\t\t\tv.S_=x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(v.F_==-1&&v.S_==-1) break;\n\t\tused[v.F_][v.S_]=true;\n\t\tREP(i,0,4){\n\t\t\tint ny=v.F_+dy[i],nx=v.S_+dx[i];\n\t\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\t\tl[ny][nx]=min(l[ny][nx],max(f[ny][nx],l[v.F_][v.S_]));\n\t\t}\n\t}\n}\n*/\n\nvoid Djikstra(vector<vector<int> > &f,vector<vector<int> > &l,int sy,int sx,int h,int w){\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\tREP(y,0,h) fill(l[y].begin(),l[y].end(),INF);\n\tl[sy][sx]=1;\n\tque.push(PP(1,Pi(sy,sx)));\n\twhile(!que.empty()){\n\t\tPP p=que.top(); que.pop();\n\t\tPi v=p.S_;\n\t\tif(l[v.F_][v.S_]<p.F_) continue;\n\t\tREP(i,0,4){\n\t\t\tint ny=v.F_+dy[i],nx=v.S_+dx[i];\n\t\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\t\tif(l[ny][nx]>max(f[ny][nx],l[v.F_][v.S_])){\n\t\t\t\tl[ny][nx]=max(f[ny][nx],l[v.F_][v.S_]);\n\t\t\t\tque.push(PP(l[ny][nx],Pi(ny,nx)));\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int f(int x){\n\tif(x==0) return 1;\n\telse if(x==1) return 0;\n}\n\nvoid solve(){\n\tint R;\n\twhile(cin >> R&&R){\n\t\tint W[2],H[2],X[2],Y[2];\n\t\tvector<vector<int> > field[2];\n\t\tvector<vector<int> > level[2];\n\t\tint max_[2]={};\n\t\tREP(i,0,2){\n\t\t\tcin >> W[i] >> H[i] >> X[i] >> Y[i];\n\t\t\t--X[i]; --Y[i];\n\t\t\tfield[i].resize(H[i]);\n\t\t\tlevel[i].resize(H[i]);\n\t\t\tREP(j,0,H[i]){\n\t\t\t\tfield[i][j].resize(W[i]);\n\t\t\t\tlevel[i][j].resize(W[i]);\n\t\t\t}\n\t\t\tREP(y,0,H[i]) REP(x,0,W[i]){\n\t\t\t\tcin >> field[i][y][x];\n\t\t\t\tmax_[i]=max(max_[i],field[i][y][x]);\n\t\t\t}\n\t\t\tDjikstra(field[i],level[i],Y[i],X[i],H[i],W[i]);\n\t\t\t/*\n\t\t\tcout << endl << endl;\n\t\t\tREP(y,0,H[i]){\n\t\t\t\tREP(x,0,W[i]) cout << level[i][y][x] << ' ';\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\t/*\n\t\tvector<unsigned int> s[2];\n\t\tREP(i,0,2){\n\t\t\ts[i].resize(max_[i]+1);\n\t\t\tREP(y,0,H[i]) REP(x,0,W[i]) ++s[i][level[i][y][x]];\n\t\t\tREP(j,1,max_[i]+1) s[i][j]+=s[i][j-1];\n\t\t}\n\t\tint result=INF;\n\t\tREP(i,0,2){\n\t\t\tfor(int j=0; j<=max_[i]&&j<=result; ++j){\n\t\t\t\tint idx=(int)(lower_bound(s[i].begin(),s[i].end(),R-s[f(i)][j])-s[i].begin());\n\t\t\t\tif(!(0<=idx&&idx<=max_[i])) continue;\n\t\t\t\tresult=min(result,j+idx);\n\t\t\t}\n\t\t}\n\t\tcout << result << endl;\n\t\t*/\n\t\tmap<int,int> s[2];\n\t\tvector<int> idx[2],num[2];\n\t\tREP(i,0,2){\n\t\t\tREP(y,0,H[i]) REP(x,0,W[i]) ++s[i][level[i][y][x]];\n\t\t\tauto it=s[i].begin();\n\t\t\tidx[i].push_back(0);\n\t\t\tnum[i].push_back(0);\n\t\t\tidx[i].push_back(it->F_);\n\t\t\tnum[i].push_back(it->S_);\n\t\t\tauto prev=it;\n\t\t\t++it;\n\t\t\tfor(; it!=s[i].end(); ++it,++prev){\n\t\t\t\tit->S_+=prev->S_;\n\t\t\t\t//cout << it->F_ << ' ' << it->S_ << endl;\n\t\t\t\tidx[i].push_back(it->F_);\n\t\t\t\tnum[i].push_back(it->S_);\n\t\t\t}\n\t\t}\n\t\tint result=INF;\n\t\t/*\n\t\tcout << endl;\n\t\tREP(i,0,2) REP(j,0,idx[i].size()){\n\t\t\tcout << i << ' ' << idx[i][j] << ' ' << num[i][j] << endl;\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\t\tREP(i,0,2) REP(j,0,idx[i].size()){\n\t\t\tint tmp=(int)(lower_bound(num[f(i)].begin(),num[f(i)].end(),R-num[i][j])-num[f(i)].begin());\n\t\t\t//cout << idx[i][tmp] << ' ' << num[i][tmp] << ' ' << idx[f(i)][j] << ' ' << num[f(i)][j] << endl;\n\t\t\tif(!(0<=tmp&&tmp<=idx[f(i)].size()-1)) continue;\n\t\t\tresult=min(result,idx[i][j]+idx[f(i)][tmp]);\n\t\t}\n\t\tcout << result << endl;\n\t}\n}\n\nint main(){\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n#define F first\n#define S second\n#define INF 2e9\n#define MP(i, j) make_pair((i), (j))\ntypedef pair<int, int> P;\nint revel[500][500];\n\nint r, w, h, x, y;\nvector<P> able, able2;\nstruct S{\n\tint x, y, r;\n\tS(int inx, int iny, int inr): x(inx), y(iny), r(inr){}\n\tbool operator < (const S &s)const{\n\t\treturn r > s.r;\n\t}\n};\nvoid dijkstra(vector<P> &able){\n\tint nowr = 1, cnt = 0;\n\tbool flag[500][500] = {};\n\tpriority_queue<S> que;\n\tque.push(S(x - 1, y - 1, 1));\n\tflag[y - 1][x - 1] =  true;\n\twhile(!que.empty()){\n\t\tS p = que.top();\n\t\tif(nowr < revel[p.y][p.x]){\n\t\t\table.push_back(MP(cnt, nowr));\n\t\t\tnowr = revel[p.y][p.x];\n\t\t}\n\t\tcnt++;\n\t\t\n\t\tque.pop();\n\t\tfor(int i = -1; i <= 1; i++){\n\t\t\tif(!flag[p.y + i][p.x]&& p.y + i >= 0 && p.y + i < h && p.x >= 0 && p.x < w){\n\t\t\t\tque.push(S(p.x, p.y + i, revel[p.y + i][p.x]));\n\t\t\t\tflag[p.y + i][p.x] = true;\n\t\t\t}\n\t\t\tif(!flag[p.y][p.x + i]&& p.y >= 0 && p.y < h && p.x + i >= 0 && p.x + i < w){\n\t\t\t\tque.push(S(p.x + i, p.y, revel[p.y][p.x + i]));\n\t\t\t\tflag[p.y][p.x + i] = true;\n\t\t\t}\n\t\t}\n\t}\n\table.push_back(MP(cnt, nowr));\n}\nint main(){\n\twhile(cin >> r && r){\n\t\tcin >> w >> h >> x >> y ;\n\t\tint ans = INF;\n\t\table.clear();\n\t\table2.clear();\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tscanf(\"%d\", &revel[i][j]);\n\t\t\t}\n\t\t}\n\t\tdijkstra(able);\n\t\tcin >> w >> h >> x >> y;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tscanf(\"%d\", &revel[i][j]);\n\t\t\t}\n\t\t}\n\t\tdijkstra(able2);\n\n\t\tfor(int i = 0; i < able.size(); i++){\n\t\t\tP pp = MP(r - able[i].F, 0);\n\t\t\tif(pp.F > 0){\n\t\t\t\tint p = lower_bound(able2.begin(),able2.end(), pp) - able2.begin();\n\t\t\t\tif(p != able2.end() - able2.begin())\n\t\t\t\t\tans = min(ans, able2[p].S + able[i].S);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans = min(ans, able[i].S);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define\tmp\tmake_pair\n#define\tpb\tpush_back\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint main(){\n\tfor(int r;scanf(\"%d\",&r),r;){\n\t\tint w1,h1,x1,y1;\tscanf(\"%d%d%d%d\",&w1,&h1,&x1,&y1);\n\t\tx1--,y1--;\n\t\tstatic int room1[500][500];\n\t\tfor(int i=0;i<h1;i++)for(int j=0;j<w1;j++)\tscanf(\"%d\",room1[i]+j);\n\t\tint w2,h2,x2,y2;\tscanf(\"%d%d%d%d\",&w2,&h2,&x2,&y2);\n\t\tx2--,y2--;\n\t\tstatic int room2[500][500];\n\t\tfor(int i=0;i<h2;i++)for(int j=0;j<w2;j++)\tscanf(\"%d\",room2[i]+j);\n\n\t\tvector<pii> roomcnt1;\t// <auth lev,number of rooms>\n\t\tstatic bool visited[500][500];\n\t\tfor(int i=0;i<h1;i++)for(int j=0;j<w1;j++)\tvisited[i][j]=false;\n\t\tvisited[y1][x1]=true;\n\t\troomcnt1.pb(mp(0,0));\n\t\tint cnt=0,lev=0;\n\t\tpriority_queue< pair<int,pii> > pq;\tpq.push(mp(-room1[y1][x1],mp(y1,x1)));\n\t\twhile(!pq.empty()){\n\t\t\tpair<int,pii> a=pq.top();\tpq.pop();\n\t\t\tint nowlev=-a.first,x=a.second.second,y=a.second.first;\n\t\t\tcnt++;\n\t\t\tif(lev<nowlev){\n\t\t\t\troomcnt1.pb(mp(cnt,nowlev));\n\t\t\t\tlev=nowlev;\n\t\t\t}\n\t\t\telse\t*(roomcnt1.rbegin())=mp(cnt,lev);\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint xx=x+dx[i],yy=y+dy[i];\n\t\t\t\tif(0<=xx && xx<w1 && 0<=yy && yy<h1 && !visited[yy][xx]){\n\t\t\t\t\tpq.push(mp(-room1[yy][xx],mp(yy,xx)));\n\t\t\t\t\tvisited[yy][xx]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<pii> roomcnt2;\n\t\tfor(int i=0;i<h1;i++)for(int j=0;j<w1;j++)\tvisited[i][j]=false;\n\t\tvisited[y2][x2]=true;\n\t\troomcnt2.pb(mp(0,0));\n\t\tcnt=0,lev=0;\n\t\tpq=priority_queue< pair<int,pii> >();\tpq.push(mp(-room2[y2][x2],mp(y2,x2)));\n\t\twhile(!pq.empty()){\n\t\t\tpair<int,pii> a=pq.top();\tpq.pop();\n\t\t\tint nowlev=-a.first,x=a.second.second,y=a.second.first;\n\t\t\tcnt++;\n\t\t\tif(lev<nowlev){\n\t\t\t\troomcnt2.pb(mp(cnt,nowlev));\n\t\t\t\tlev=nowlev;\n\t\t\t}\n\t\t\telse\t*(roomcnt2.rbegin())=mp(cnt,lev);\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint xx=x+dx[i],yy=y+dy[i];\n\t\t\t\tif(0<=xx && xx<w2 && 0<=yy && yy<h2 && !visited[yy][xx]){\n\t\t\t\t\tpq.push(mp(-room2[yy][xx],mp(yy,xx)));\n\t\t\t\t\tvisited[yy][xx]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans=1<<30;\n\t\tfor(int i=0;i<roomcnt1.size();i++){\n\t\t\tint rem=r-roomcnt1[i].first;\n\t\t\tvector<pii>::iterator it=lower_bound(roomcnt2.begin(),roomcnt2.end(),mp(rem,0));\n\t\t\tif(it!=roomcnt2.end()){\n\t\t\t\tint lev1=roomcnt1[i].second;\n\t\t\t\tint lev2=it->second;\n\t\t\t\tans=min(ans,lev1+lev2);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\n#include<map>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<24)\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nstruct state {\n  int y,x,cost;\n  bool operator < (const state &p)const{\n    return cost > p.cost; \n  }\n};\n\nint R;\nint th,tw,uh,uw,ty,tx,uy,ux;\nint t[500][500],u[500][500];\nint T[1000000],U[1000000];\nint d[500][500];\nvector<int> G;\nmap<int,int> g;\n\nvoid compute(int a[500][500],int H,int W,int sy,int sx,int v[1000000]){\n  for(int i=0;i<500;i++)for(int j=0;j<500;j++)d[i][j]=INF;\n  priority_queue<state> Q;\n  Q.push((state){sy,sx,1});\n  d[sy][sx]=1;\n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    if(d[s.y][s.x]<s.cost)continue;\n    v[g[s.cost]]++;\n    for(int i=0;i<4;i++){\n      int ny=s.y+dy[i],nx=s.x+dx[i];\n      if(ny<0||nx<0)continue;\n      if(ny>=H||nx>=W)continue;\n      int ncost=max(a[ny][nx],s.cost);\n      if(d[ny][nx]<=ncost)continue;\n      d[ny][nx]=ncost;\n      Q.push((state){ny,nx,ncost});\n    }\n  }\n}\n\nvoid solve(){\n  sort(G.begin(),G.end());\n  G.erase(unique(G.begin(),G.end()),G.end());\n  for(int i=0;i<(int)G.size();i++)g[G[i]]=i;\n  compute(t,th,tw,ty,tx,T);\n  compute(u,uh,uw,uy,ux,U);\n  int size=G.size();\n  for(int i=0;i<size;i++){\n    if(i)T[i]+=T[i-1];\n    if(i)U[i]+=U[i-1];\n    //cout<<T[i]<<\" \"<<U[i]<<\" \"<<G[i]<<endl;\n  }\n\n  int ans=1e9;\n  for(int i=0;i<size;i++){\n    int target=R-T[i];\n    int* it=lower_bound(U,U+size,target);\n    if(it==U+size){\n      continue;\n    }\n    ans=min(ans,G[i]+G[it-U]);\n  }\n  cout<<ans<<endl;\n}\n\nvoid init(){\n  G.clear();\n  g.clear();\n  G.push_back(0);\n  for(int i=0;i<1000000;i++)\n    T[i]=U[i]=0;\n}\n\nint main(){\n  while(cin>>R,R){    \n    init();\n    cin>>tw>>th>>tx>>ty;\n    ty--,tx--;\n    for(int i=0;i<th;i++){\n      for(int j=0;j<tw;j++){\n\tcin>>t[i][j];\n\tG.push_back(t[i][j]);\n      }\n    }\n    cin>>uw>>uh>>ux>>uy;\n    uy--,ux--;\n    for(int i=0;i<uh;i++){\n      for(int j=0;j<uw;j++){\n\tcin>>u[i][j];\n\tG.push_back(u[i][j]);\n      }\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\n#include<map>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<24)\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nstruct state {\n  int y,x,cost;\n  bool operator < (const state &p)const{\n    return cost > p.cost; \n  }\n};\n\nint R;\nint th,tw,uh,uw,ty,tx,uy,ux;\nint t[500][500],u[500][500];\nint T[1000000],U[1000000];\nint d[500][500];\nvector<int> G;\nmap<int,int> g;\n\nvoid compute(int a[500][500],int H,int W,int sy,int sx,int v[1000000]){\n  for(int i=0;i<500;i++)for(int j=0;j<500;j++)d[i][j]=INF;\n  priority_queue<state> Q;\n  Q.push((state){sy,sx,1});\n  d[sy][sx]=1;\n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    if(d[s.y][s.x]<s.cost)continue;\n    v[g[s.cost]]++;\n    for(int i=0;i<4;i++){\n      int ny=s.y+dy[i],nx=s.x+dx[i];\n      if(ny<0||nx<0)continue;\n      if(ny>=H||nx>=W)continue;\n      int ncost=max(a[ny][nx],s.cost);\n      if(d[ny][nx]<=ncost)continue;\n      d[ny][nx]=ncost;\n      Q.push((state){ny,nx,ncost});\n    }\n  }\n}\n\nvoid solve(){\n  sort(G.begin(),G.end());\n  G.erase(unique(G.begin(),G.end()),G.end());\n  for(int i=0;i<(int)G.size();i++)g[G[i]]=i;\n  compute(t,th,tw,ty,tx,T);\n  compute(u,uh,uw,uy,ux,U);\n  int size=G.size();\n  for(int i=0;i<size;i++){\n    if(i)T[i]+=T[i-1];\n    if(i)U[i]+=U[i-1];\n    //cout<<T[i]<<\" \"<<U[i]<<\" \"<<G[i]<<endl;\n  }\n\n  int ans=INF;\n  for(int i=0;i<size;i++){\n    int target=R-T[i];\n    int* it=lower_bound(U,U+size,target);\n    if(it==U+size)continue;\n    ans=min(ans,G[i]+G[it-U]);\n  }\n  cout<<ans<<endl;\n}\n\nvoid init(){\n  G.clear();\n  g.clear();\n  G.push_back(0);\n  for(int i=0;i<1000000;i++)\n    T[i]=U[i]=0;\n}\n\nint main(){\n  while(cin>>R,R){    \n    init();\n    cin>>tw>>th>>tx>>ty;\n    ty--,tx--;\n    for(int i=0;i<th;i++){\n      for(int j=0;j<tw;j++){\n\tcin>>t[i][j];\n\tG.push_back(t[i][j]);\n      }\n    }\n    cin>>uw>>uh>>ux>>uy;\n    uy--,ux--;\n    for(int i=0;i<uh;i++){\n      for(int j=0;j<uw;j++){\n\tcin>>u[i][j];\n\tG.push_back(u[i][j]);\n      }\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define INF 100000001\ntypedef struct{\n\tint x,y;\n\tint lev;\n}data;\ndata d[25000];\nint min(int a,int b){return a<b?a:b;}\nint max(int a,int b){return a>b?a:b;}\nint comp(const void *a,const void *b){\n\tdata* p=(data*)a;\n\tdata* q=(data*)b;\n\treturn p->lev-q->lev;\n}\nint comp2(const void *a,const void *b){\n\tint* p=(int*)a;\n\tint* q=(int*)b;\n\treturn *p-*q;\n}\nint cd;\nint level[2][500][500];\nint mlevel[2][500][500];\nint mlevel2[2][25000];\ntypedef struct{\n\tint val;\n\tint time;\n}poss;\nposs pos[2][25001];\nint cpos[2];\nint sx[2];\nint sy[2];\nint w[2];\nint h[2];\nbool used[500][500];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,1,-1,0};\nint main(){\n\tint r,x,y;\n\tint i,j,k;\n\twhile(1){\n\tscanf(\"%d\",&r);\n\tif(r==0)return 0;\n\tfor(i=0;i<2;i++){\n\t\tscanf(\"%d %d %d %d\",&w[i],&h[i],&x,&y);\n\t\tsx[i]=x-1;\n\t\tsy[i]=y-1;\n\t\tfor(j=0;j<h[i];j++)for(k=0;k<w[i];k++)scanf(\"%d\",&level[i][j][k]);\n\t}\n\tcpos[0]=0;\n\tcpos[1]=0;\n\tfor(i=0;i<2;i++)for(j=0;j<h[i];j++)for(k=0;k<w[i];k++)mlevel[i][j][k]=0;\n\tfor(i=0;i<2;i++){\n\t\tcd=0;\n\t\tfor(j=0;j<h[i];j++)for(k=0;k<w[i];k++)used[j][k]=false;\n\t\tdata da;\n\t\tda.x=sx[i];\n\t\tda.y=sy[i];\n\t\tda.lev=level[i][sy[i]][sx[i]];\n\t\td[cd++]=da;\n\t\tused[sy[i]][sx[i]]=true;\n\t\tfor(j=0;j<w[i]*h[i];j++){\n\t\t\tqsort(d,cd,sizeof(data),comp);\n\t\t\tmlevel[i][d[0].y][d[0].x]=d[0].lev;\n\t\t\td[0].lev=INF;\n\t\t\tfor(k=0;k<4;k++){\n\t\t\t\tif(d[0].x+dx[k]>=0&&d[0].x+dx[k]<w[i]&&d[0].y+dy[k]>=0&&d[0].y+dy[k]<h[i]&&!used[d[0].y+dy[k]][d[0].x+dx[k]]){\n\t\t\t\t\tmlevel[i][d[0].y+dy[k]][d[0].x+dx[k]]=max(mlevel[i][d[0].y+dy[k]][d[0].x+dx[k]],max(level[i][d[0].y+dy[k]][d[0].x+dx[k]],mlevel[i][d[0].y][d[0].x]));\n\t\t\t\t\tif(!used[d[0].y+dy[k]][d[0].x+dx[k]]){\n\t\t\t\t\t\tdata dat;\n\t\t\t\t\t\tdat.x=d[0].x+dx[k];\n\t\t\t\t\t\tdat.y=d[0].y+dy[k];\n\t\t\t\t\t\tdat.lev=mlevel[i][d[0].y+dy[k]][d[0].x+dx[k]];\n\t\t\t\t\t\td[cd++]=dat;\n\t\t\t\t\t\tused[d[0].y+dy[k]][d[0].x+dx[k]]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint old=-1;\n\t\tfor(j=0;j<h[i]*w[i];j++)pos[i][j].time=0;\n\t\tfor(j=0;j<h[i];j++)for(k=0;k<w[i];k++)mlevel2[i][j*w[i]+k]=mlevel[i][j][k];\n\t\tqsort(mlevel2[i],w[i]*h[i],sizeof(int),comp2);\n\t\tfor(j=0;j<w[i]*h[i];j++){\n\t\t\tif(mlevel2[i][j]!=old){\n\t\t\t\tpos[i][++cpos[i]].time=1;\n\t\t\t\tpos[i][cpos[i]].time+=pos[i][cpos[i]-1].time;\n\t\t\t\told=mlevel2[i][j];\n\t\t\t\tpos[i][cpos[i]].val=old;\n\t\t\t}\n\t\t\telse pos[i][cpos[i]].time++;\n\t\t}\n\t}\n\tint ans=INF;\n\tint s;\n\tint g;\n\tint mid;\n\tint res;\n\tfor(i=1;i<=cpos[0];i++){\n\t\tres=r-pos[0][i].time;\n\t\tif(res<0){\n\t\t\tans=min(ans,pos[0][i].val);\n\t\t\tcontinue;\n\t\t}\n\t\ts=0;\n\t\tg=cpos[1]+1;\n\t\tfor(j=0;j<100;j++){\n\t\t\tmid=(int)(s+g)/2;\n\t\t\tif(pos[1][mid].time==res)break;\n\t\t\telse if(pos[1][mid].time<res)s=mid;\n\t\t\telse g=mid;\n\t\t}\n\t\tmid=(int)(s+g)/2;\n\t\tif(pos[0][i].time+pos[1][mid].time>=r){\n\t\t\tans=min(ans,pos[0][i].val+pos[1][mid].val);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\t}\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_row,int arg_col,int arg_max_level,int arg_max_level_index){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tmax_level = arg_max_level;\n\t\tmax_level_index = arg_max_level_index;\n\t}\n\tint row,col,max_level,max_level_index;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_level){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tlevel = arg_level;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn level > arg.level;\n\t};\n\tint row,col,level;\n};\n\nint R;\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nvoid func(){\n\n\tint W,H,start_col,start_row;\n\tscanf(\"%d %d %d %d\",&W,&H,&start_col,&start_row);\n\tstart_row--;\n\tstart_col--;\n\n\tint table_1[H][W];\n\n\tvector<int> first_V;\n\tfirst_V.push_back(0);\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tscanf(\"%d\",&table_1[row][col]);\n\t\t\tfirst_V.push_back(table_1[row][col]);\n\t\t}\n\t}\n\n\tsort(first_V.begin(),first_V.end());\n\n\tint pre  = -1;\n\n\tvector<int> second_V;\n\n\tfor(int i = 0; i < first_V.size(); i++){\n\t\tif(pre != first_V[i]){\n\t\t\tsecond_V.push_back(first_V[i]);\n\t\t}\n\t\tpre = first_V[i];\n\t}\n\n\tmap<int, int> index_map;\n\n\tfor(int i = 0; i < second_V.size(); i++){\n\t\tindex_map[second_V[i]] = i;\n\t}\n\n\tint ruisekiwa_1[second_V.size()];\n\n\tfor(int i = 0; i < second_V.size(); i++){\n\t\truisekiwa_1[i] = 0;\n\t}\n\n\tqueue<Info> Q;\n\n\tbool visited[H][W];\n\tbool pushed[H][W];\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tvisited[row][col] = false;\n\t\t\tpushed[row][col] = false;\n\t\t}\n\t}\n\n\tvisited[start_row][start_col] = true;\n\truisekiwa_1[1] = 1;\n\n\tQ.push(Info(start_row,start_col,1,1));\n\tint visited_num = 1;\n\tint limit = H*W;\n\n\tint next_row,next_col,next_level,next_index;\n\n\tpriority_queue<Data> cannot_Q;\n\n\twhile(visited_num < limit){\n\n\t\tnext_level = BIG_NUM;\n\n\t\twhile(!Q.empty()){\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tnext_row = Q.front().row + diff_row[i];\n\t\t\t\tnext_col = Q.front().col + diff_col[i];\n\n\t\t\t\tif((next_row < 0 || next_row >= H || next_col < 0 || next_col >= W) || visited[next_row][next_col] == true)continue;\n\n\t\t\t\tif(table_1[next_row][next_col] <= Q.front().max_level){\n\t\t\t\t\tvisited[next_row][next_col] = true;\n\t\t\t\t\tvisited_num++;\n\t\t\t\t\truisekiwa_1[Q.front().max_level_index]++;\n\t\t\t\t\tQ.push(Info(next_row,next_col,Q.front().max_level,Q.front().max_level_index));\n\t\t\t\t}else if(table_1[next_row][next_col] > Q.front().max_level && pushed[next_row][next_col] == false){\n\t\t\t\t\tpushed[next_row][next_col] = true;\n\t\t\t\t\tcannot_Q.push(Data(next_row,next_col,table_1[next_row][next_col]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\n\t\tif(visited_num == limit)break;\n\n\t\tnext_level = cannot_Q.top().level;\n\t\tnext_index = index_map[next_level];\n\n\t\twhile(!cannot_Q.empty()){\n\t\t\tif(cannot_Q.top().level > next_level)break;\n\t\t\tvisited[cannot_Q.top().row][cannot_Q.top().col] = true;\n\t\t\tvisited_num++;\n\t\t\truisekiwa_1[next_index]++;\n\t\t\tQ.push(Info(cannot_Q.top().row,cannot_Q.top().col,next_level,next_index));\n\t\t\tcannot_Q.pop();\n\t\t}\n\t}\n\n\tfor(int i = 1; i < second_V.size(); i++){\n\t\truisekiwa_1[i] += ruisekiwa_1[i-1];\n\t}\n\n\n\tint W_2,H_2;\n\tscanf(\"%d %d %d %d\",&W_2,&H_2,&start_col,&start_row);\n\tstart_row--;\n\tstart_col--;\n\n\tint table_2[H_2][W_2];\n\n\tvector<int> first_V2;\n\tfirst_V2.push_back(0);\n\n\tfor(int row = 0; row < H_2; row++){\n\t\tfor(int col = 0; col < W_2; col++){\n\t\t\tscanf(\"%d\",&table_2[row][col]);\n\t\t\tfirst_V2.push_back(table_2[row][col]);\n\t\t}\n\t}\n\n\tsort(first_V2.begin(),first_V2.end());\n\n\tpre  = -1;\n\n\tvector<int> second_V2;\n\n\tfor(int i = 0; i < first_V2.size(); i++){\n\t\tif(pre != first_V2[i]){\n\t\t\tsecond_V2.push_back(first_V2[i]);\n\t\t}\n\t\tpre = first_V2[i];\n\t}\n\n\tmap<int, int> index_map2;\n\n\tfor(int i = 0; i < second_V2.size(); i++){\n\t\tindex_map2[second_V2[i]] = i;\n\t}\n\n\tint ruisekiwa_2[second_V2.size()];\n\n\tfor(int i = 0; i < second_V2.size(); i++){\n\t\truisekiwa_2[i] = 0;\n\t}\n\n\tqueue<Info> Q2;\n\n\tbool visited2[H_2][W_2];\n\tbool pushed2[H_2][W_2];\n\n\tfor(int row = 0; row < H_2; row++){\n\t\tfor(int col = 0; col < W_2; col++){\n\t\t\tvisited2[row][col] = false;\n\t\t\tpushed2[row][col] = false;\n\t\t}\n\t}\n\n\tvisited2[start_row][start_col] = true;\n\truisekiwa_2[1] = 1;\n\n\tQ2.push(Info(start_row,start_col,1,1));\n\tint visited_num2 = 1;\n\tint limit2 = H_2*W_2;\n\n\tpriority_queue<Data> cannot_Q2;\n\n\twhile(visited_num2 < limit2){\n\n\t\tnext_level = BIG_NUM;\n\n\t\twhile(!Q2.empty()){\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tnext_row = Q2.front().row + diff_row[i];\n\t\t\t\tnext_col = Q2.front().col + diff_col[i];\n\n\t\t\t\tif((next_row < 0 || next_row >= H_2 || next_col < 0 || next_col >= W_2) || visited2[next_row][next_col] == true)continue;\n\n\t\t\t\tif(table_2[next_row][next_col] <= Q2.front().max_level){\n\t\t\t\t\tvisited2[next_row][next_col] = true;\n\t\t\t\t\tvisited_num2++;\n\t\t\t\t\truisekiwa_2[Q2.front().max_level_index]++;\n\t\t\t\t\tQ2.push(Info(next_row,next_col,Q2.front().max_level,Q2.front().max_level_index));\n\t\t\t\t}else if(pushed2[next_row][next_col] == false){\n\t\t\t\t\tpushed2[next_row][next_col] = true;\n\t\t\t\t\tcannot_Q2.push(Data(next_row,next_col,table_2[next_row][next_col]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ2.pop();\n\t\t}\n\n\t\tif(visited_num2 == limit)break;\n\n\t\tnext_level = cannot_Q2.top().level;\n\t\tnext_index = index_map2[next_level];\n\n\t\twhile(!cannot_Q2.empty()){\n\t\t\tif(cannot_Q2.top().level > next_level)break;\n\t\t\tvisited2[cannot_Q2.top().row][cannot_Q2.top().col] = true;\n\t\t\tvisited_num2++;\n\t\t\truisekiwa_2[next_index]++;\n\t\t\tQ2.push(Info(cannot_Q2.top().row,cannot_Q2.top().col,next_level,next_index));\n\t\t\tcannot_Q2.pop();\n\t\t}\n\t}\n\n\tfor(int i = 1; i < second_V2.size(); i++){\n\t\truisekiwa_2[i] += ruisekiwa_2[i-1];\n\t}\n\n\tint ans = BIG_NUM;\n\tint tmp1,tmp2,left,right,m;\n\n\tfor(int i = 0; i < second_V.size(); i++){\n\t\ttmp1 = ruisekiwa_1[i];\n\n\t\tif(tmp1 >= R){\n\t\t\tans = min(ans,second_V[i]);\n\t\t\tbreak;\n\t\t}\n\n\t\tleft = 0,right = second_V2.size()-1,m = (right+left)/2;\n\n\t\twhile(left <= right){\n\n\t\t\tif(ruisekiwa_2[m]+tmp1 >= R){\n\t\t\t\tans = min(ans,second_V[i]+second_V2[m]);\n\t\t\t\tright = m-1;\n\t\t\t}else{\n\t\t\t\tleft = m+1;\n\t\t\t}\n\t\t\tm = (left+right)/2;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&R);\n\t\tif(R == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <map>\n#define fi first\n#define sec second\n#define INF 1000000000\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nint r, w[2], h[2], x[2], y[2];\nint s, e, mid;\nint cell[2][500][500];\nbool used[500][500];\nint dp[2][250001];\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\npriority_queue<PP, vector<PP>, greater<PP> >  que;\n\nint A(int u, int Y, int X, int p){\n\tif(used[Y][X]) return 0;\n\tif(cell[u][Y][X] > p){\n\t\tque.push(PP(cell[u][Y][X],P(Y,X)));\n\t\treturn 0;\n\t}\n\tint ret = 1;\n\tused[Y][X] = true;\n\tfor(int i = 0; i < 4; i++){\n\t\tif(0<=Y+dy[i]&&Y+dy[i]<h[u]&&0<=X+dx[i]&&X+dx[i] < w[u]){\n\t\t\tret += A(u,Y+dy[i],X+dx[i],p);\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid solve(){\n\tfor(int i = 0; i < 2; i++){\n\t\tdp[i][0] = 0;\n\t}\n\tfor(int i = 1; i < 250001; i++){\n\t\tdp[0][i] = INF; dp[1][i] = INF;\n\t}\n\tfor(int u = 0; u < 2; u++){\n\t\tscanf(\"%d%d%d%d\", &w[u], &h[u], &x[u], &y[u]);\n\t\tx[u]--; y[u]--;\n\t\tfor(int i = 0; i < h[u]; i++){\n\t\t\tfor(int j = 0; j < w[u]; j++){\n\t\t\t\tscanf(\"%d\", &cell[u][i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int u = 0; u < 2; u++){\n\t\tque.push(PP(1,P(y[u],x[u])));\n\t\tmemset(used,0,sizeof(used));\n\t\tint cnt = 0;\n\t\twhile(true){\n\t\t\tint tmp = que.top().fi;\n\t\t\twhile(true){\n\t\t\t\tif(que.size() == 0) break;\n\t\t\t\tif(tmp != que.top().fi) break;\n\t\t\t\tPP p = que.top(); que.pop();\n\t\t\t\tcnt += A(u,p.sec.fi,p.sec.sec,p.fi);\n\t\t\t}\n\t\t\tdp[u][cnt] = tmp;\n\t\t\tif(que.size() == 0) break;\n\t\t}\n\t}\n\tfor(int u = 0; u < 2; u++){\n\t\tfor(int i = w[u]*h[u]-1; i >= 0; i--){\n\t\t\tdp[u][i] = min(dp[u][i],dp[u][i+1]);\n\t\t}\n\t}\n\tint ans = INF;\n\tfor(int i = 0; i <= r; i++){\n\t\tif(i > w[0]*h[0] || r-i > w[1]*h[1]) continue;\n\t\tans = min(ans,dp[0][i]+dp[1][r-i]);\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\nint main(){\n\twhile(scanf(\"%d\", &r),r) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pint;\ntypedef pair<ll, int> P;\n//typedef tuple<int,int,int> T;\nll INFL = 1000000000000000010;//10^18 = 2^60\nint INF = 2147483600;//10^9\nll MOD  = 1000000007;\nint solve(){\n    vector<int> dy(4);\n    vector<int> dx(4);\n    dy.at(0) = 0;\n    dy.at(1) = 0;\n    dy.at(2) = 1;\n    dy.at(3) = -1;\n    dx.at(0) = 1;\n    dx.at(1) = -1;\n    dx.at(2) = 0;\n    dx.at(3) = 0;\n    \n    int R;\n    cin >> R;\n    if(R == 0)return 0;\n    int H1,W1,X1,Y1;\n    cin >> W1 >> H1 >> X1 >> Y1;\n    X1--;\n    Y1--;\n    vector<vector<ll>> mp1(H1, vector<ll>(W1));\n    vector<vector<ll>> d1(H1, vector<ll>(W1, INFL));\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            cin >> mp1[i][j];\n        }\n    }\n    \n    d1[Y1][X1] = 1;\n    priority_queue<pair<ll, pair<int, int>>> pque1;\n    pque1.push({1, {Y1, X1}});\n    \n    while(!pque1.empty()){\n        ll c;\n        int y,x;\n        c = pque1.top().first;\n        y = pque1.top().second.first;\n        x = pque1.top().second.second;\n        pque1.pop();\n        if(c > d1[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H1 && 0 <= nx && nx < W1){\n                if(d1[ny][nx] > d1[y][x]){\n                    if(d1[y][x] > mp1[ny][nx]){\n                        d1[ny][nx] = d1[y][x];\n                    }else{\n                        d1[ny][nx] = mp1[ny][nx];\n                    }\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }else if(d1[ny][nx] > d1[y][x]){\n                    d1[ny][nx] = mp1[ny][nx];\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    int H2,W2,X2,Y2;\n    cin >> W2 >> H2 >> X2 >> Y2;\n    X2--;\n    Y2--;\n    vector<vector<ll>> mp2(H2, vector<ll>(W2));\n    vector<vector<ll>> d2(H2, vector<ll>(W2, INFL));\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            cin >> mp2[i][j];\n        }\n    }\n    \n    d2[Y2][X2] = 1;\n    priority_queue<pair<ll, pair<int, int>>> pque2;\n    pque2.push({1, {Y2, X2}});\n    \n    while(!pque2.empty()){\n        ll c;\n        int y,x;\n        c = pque2.top().first;\n        y = pque2.top().second.first;\n        x = pque2.top().second.second;\n        pque2.pop();\n        if(c > d2[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H2 && 0 <= nx && nx < W2){\n                if(d2[ny][nx] > d2[y][x]){\n                    if(d2[y][x] > mp2[ny][nx]){\n                        d2[ny][nx] = d2[y][x];\n                    }else{\n                        d2[ny][nx] = mp2[ny][nx];\n                    }\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }else if(d2[ny][nx] > d2[y][x]){\n                    d2[ny][nx] = mp2[ny][nx];\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    vector<pair<ll,int>> O1(0);\n    vector<ll> COST1(0);\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            COST1.push_back(d1[i][j]);\n        }\n    }\n    sort(COST1.begin(), COST1.end());\n    COST1.push_back(INFL);\n    ll ad1 = COST1.at(0);\n    int cnt = 0;\n    for(int i = 0; i < COST1.size(); i++){\n        if(ad1 == COST1.at(i)){\n            cnt++;\n        }else{\n            O1.push_back({ad1, cnt});\n            ad1 = COST1.at(i);\n            cnt++;\n        }\n    }\n    \n    vector<pair<ll,int>> O2 = {pair{0, 0}};\n    vector<ll> COST2(0);\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            COST2.push_back(d2[i][j]);\n        }\n    }\n    sort(COST2.begin(), COST2.end());\n    COST2.push_back(INFL);\n    ll ad2 = COST2.at(0);\n    cnt = 0;\n    for(int i = 0; i < COST2.size(); i++){\n        if(ad2 == COST2.at(i)){\n            cnt++;\n        }else{\n            O2.push_back({ad2, cnt});\n            ad2 = COST2.at(i);\n            cnt++;\n        }\n    }\n    \n    ll ans = INFL;\n    for(int i = 0; i < O1.size(); i++){\n        ll cost = O1.at(i).first;\n        int rest = R - O1.at(i).second;\n        \n        if(rest > O2.at(O2.size()-1).second) continue;\n        int left = -1, right = O2.size();\n        int mid;\n        while(right - left > 1){\n            mid = (left + right) / 2;\n            if(O2.at(mid).second >= rest){\n                right = mid;\n            }else{\n                left = mid;\n            }\n        }\n        cost += O2.at(right).first;\n        ans = min(ans, cost);\n        \n    }\n    \n    cout << ans << endl;\n    \n    solve();\n    return 0;\n}\n\nint main(void){\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> PA;\ntypedef pair<long long,PA> PPA;\n\nconst long long INF = 1000010000100001;\n\nint r,w,h;\nlong long masu[510][510];\nbool b[510][510];\nlong long min_cost[2][100010];\npriority_queue<PPA,vector<PPA>,greater<PPA> > pq;\n\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\n\nvoid solve(int k){\n    \n    for(int i=1;i<=r;i++){\n        min_cost[k][i] = INF;\n    }\n    min_cost[k][0] = 0;\n    \n    long long ma = 1;\n    int cnt = 1;\n    while(!pq.empty() && cnt <= r){\n        \n        PPA pp = pq.top();\n        pq.pop();\n        PA p = pp.second;\n        if(b[p.second][p.first]) continue;\n        b[p.second][p.first] = true;\n        \n        ma = max(ma,pp.first);\n        min_cost[k][cnt] = ma;\n        \n        for(int i=0;i<4;i++){\n            int x = p.first + dx[i];\n            int y = p.second + dy[i];\n            if(x<1 || y<1 || x>w || y>h) continue;\n            pq.push( PPA(masu[y][x],PA(x,y)) );\n        }\n        cnt++;\n    }\n    \n    while(!pq.empty()) pq.pop();\n    \n}\n\nint main(){\n    \n    int x,y;\n    \n    while(cin >> r,r!=0){\n        cin >> w >> h >> x >> y;\n        for(int i=1;i<=h;i++){\n            for(int j=1;j<=w;j++){\n                cin >> masu[i][j];\n                b[i][j] = false;\n            }\n        }\n    \n        pq.push( PPA(1,PA(x,y)) );\n        solve(0);\n    \n        cin >> w >> h >> x >> y;\n        for(int i=1;i<=h;i++){\n            for(int j=1;j<=w;j++){\n                cin >> masu[i][j];\n                b[i][j] = false;\n            }\n        }\n    \n        pq.push( PPA(1,PA(x,y)) );\n        solve(1);\n    \n        long long ans = INF;\n        for(int i=0;i<=r;i++){\n            ans = min(ans,min_cost[0][i]+min_cost[1][r-i]);\n        }\n    \n        cout << ans << endl;\n    }\n    return(0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define\tmp\tmake_pair\n#define\tpb\tpush_back\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint main(){\n\tfor(int r;scanf(\"%d\",&r),r;){\n\t\tint w1,h1,x1,y1;\tscanf(\"%d%d%d%d\",&w1,&h1,&x1,&y1);\n\t\tx1--,y1--;\n\t\tstatic int room1[500][500];\n\t\tfor(int i=0;i<h1;i++)for(int j=0;j<w1;j++)\tscanf(\"%d\",room1[i]+j);\n\t\tint w2,h2,x2,y2;\tscanf(\"%d%d%d%d\",&w2,&h2,&x2,&y2);\n\t\tx2--,y2--;\n\t\tstatic int room2[500][500];\n\t\tfor(int i=0;i<h2;i++)for(int j=0;j<w2;j++)\tscanf(\"%d\",room2[i]+j);\n\n\t\tvector<pii> roomcnt1;\t// <auth lev,number of rooms>\n\t\tstatic bool visited[500][500];\n\t\tfor(int i=0;i<h1;i++)for(int j=0;j<w1;j++)\tvisited[i][j]=false;\n\t\tvisited[y1][x1]=true;\n\t\troomcnt1.pb(mp(0,0));\n\t\tint cnt=0,lev=0;\n\t\tpriority_queue< pair<int,pii> > pq;\tpq.push(mp(-room1[y1][x1],mp(y1,x1)));\n\t\twhile(!pq.empty()){\n\t\t\tpair<int,pii> a=pq.top();\tpq.pop();\n\t\t\tint nowlev=-a.first,x=a.second.second,y=a.second.first;\n\t\t\tcnt++;\n\t\t\tif(lev<nowlev){\n\t\t\t\troomcnt1.pb(mp(cnt,nowlev));\n\t\t\t\tlev=nowlev;\n\t\t\t}\n\t\t\telse\t*(roomcnt1.rbegin())=mp(cnt,lev);\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint xx=x+dx[i],yy=y+dy[i];\n\t\t\t\tif(0<=xx && xx<w1 && 0<=yy && yy<h1 && !visited[yy][xx]){\n\t\t\t\t\tpq.push(mp(-room1[yy][xx],mp(yy,xx)));\n\t\t\t\t\tvisited[yy][xx]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<pii> roomcnt2;\n\t\tfor(int i=0;i<h1;i++)for(int j=0;j<w1;j++)\tvisited[i][j]=false;\n\t\tvisited[y2][x2]=true;\n\t\troomcnt2.pb(mp(0,0));\n\t\tcnt=0,lev=0;\n\t\tpq=priority_queue< pair<int,pii> >();\tpq.push(mp(-room2[y2][x2],mp(y2,x2)));\n\t\twhile(!pq.empty()){\n\t\t\tpair<int,pii> a=pq.top();\tpq.pop();\n\t\t\tint nowlev=-a.first,x=a.second.second,y=a.second.first;\n\t\t\tcnt++;\n\t\t\tif(lev<nowlev){\n\t\t\t\troomcnt2.pb(mp(cnt,nowlev));\n\t\t\t\tlev=nowlev;\n\t\t\t}\n\t\t\telse\t*(roomcnt2.rbegin())=mp(cnt,lev);\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint xx=x+dx[i],yy=y+dy[i];\n\t\t\t\tif(0<=xx && xx<w2 && 0<=yy && yy<h2 && !visited[yy][xx]){\n\t\t\t\t\tpq.push(mp(-room2[yy][xx],mp(yy,xx)));\n\t\t\t\t\tvisited[yy][xx]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans=1<<30;\n\t\tfor(int i=0;i<roomcnt1.size();i++){\n\t\t\tint rem=r-roomcnt1[i].first;\n\t\t\tvector<pii>::iterator it=lower_bound(roomcnt2.begin(),roomcnt2.end(),mp(rem,0));\n\t\t\tif(it!=roomcnt2.end()){\n\t\t\t\tint lev1=roomcnt1[i].second;\n\t\t\t\tint lev2=it->second;\n\t\t\t\tans=min(ans,lev1+lev2);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<queue>\n#include<map>\n#include<algorithm>\n#define INF 200000000\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> Q;\nint w[2],h[2],x[2],y[2];\nint cos[2][500][500];\nint d[2][500][500];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,1,-1,0};\nvector<int> m[2];\nint min(int a,int b){return a<b?a:b;}\nint max(int a,int b){return a>b?a:b;}\nvoid calc(int n){\n\tint i,j;\n\tfor(i=0;i<h[n];i++)for(j=0;j<w[n];j++)d[n][i][j]=INF;\n\td[n][y[n]][x[n]]=1;\n\tpriority_queue< Q,vector<Q>,greater<Q> > que;\n\tque.push(Q(1,P(y[n],x[n])));\n\twhile(!que.empty()){\n\t\tQ q=que.top();que.pop();\n\t\tP p=q.second;\n\t\tif(q.first>d[n][p.first][p.second])continue;\n\t\tfor(i=0;i<4;i++){\n\t\t\tint nx=p.first+dx[i];\n\t\t\tint ny=p.second+dy[i];\n\t\t\tif(nx>=0&&nx<h[n]&&ny>=0&&ny<w[n]){\n\t\t\t\tint cost=max(cos[n][nx][ny],d[n][p.first][p.second]);\n\t\t\t\tif(d[n][nx][ny]>cost){\n\t\t\t\t\td[n][nx][ny]=cost;\n\t\t\t\t\tque.push(Q(cost,P(nx,ny)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tint r;\n\tint i,j,k;\n\twhile(1){\n\tscanf(\"%d\",&r);\n\tif(r==0)return 0;\n\tm[0].clear();\n\tm[1].clear();\n\tfor(i=0;i<2;i++){\n\t\tscanf(\"%d %d %d %d\",&w[i],&h[i],&x[i],&y[i]);\n\t\tx[i]--;y[i]--;\n\t\tfor(j=0;j<h[i];j++){\n\t\t\tfor(k=0;k<w[i];k++)scanf(\"%d\",&cos[i][j][k]);\n\t\t}\n\t}\n\tcalc(0);\n\tcalc(1);\n\tfor(i=0;i<2;i++){\n\t\tm[i].push_back(0);\n\t\tfor(j=0;j<h[i];j++){\n\t\t\tfor(k=0;k<w[i];k++)m[i].push_back(d[i][j][k]);\n\t\t}\n\t\tsort(m[i].begin(),m[i].end());\n\t}\n\tint ans=INF;\n\tfor(i=0;i<=r;i++){\n\t\tif(i>w[0]*h[0])break;\n\t\tif(r-i>w[1]*h[1])continue;\n\t\tint a,b;\n\t\ta=m[0][i];\n\t\tif(r-i<0)b=0;\n\t\telse b=m[1][r-i];\n\t\tans=min(ans,a+b);\n\t}\n\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\n\nconst int INF=100000000;\nconst long long int INF_=1000000000000000000;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nbool IsIn(int y,int x,int h,int w){\n\treturn 0<=y&&y<h&&0<=x&&x<w;\n}\n\nvoid BFS(vector<vector<int> > &f,vector<vector<int> > &l,int sy,int sx,int h,int w){\n\tvector<vector<int> > done(h,vector<int>(w));\n\tl[sy][sx]=1;\n\tdone[sy][sx]=1;\n\tqueue<Pi> que;\n\tREP(i,0,4){\n\t\tint ny=sy+dy[i],nx=sx+dx[i];\n\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\tque.push(Pi(ny,nx));\n\t}\n\twhile(!que.empty()){\n\t\tPi p=que.front();\n\t\tque.pop();\n\t\tdone[p.F_][p.S_]=1;\n\t\tbool flag=true;\n\t\tint tmp=INF;\n\t\tREP(i,0,4){\n\t\t\tint ny=p.F_+dy[i],nx=p.S_+dx[i];\n\t\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\t\ttmp=min(tmp,l[ny][nx]);\n\t\t\tif(done[ny][nx]==1&&l[ny][nx]>=f[p.F_][p.S_]) flag=false;\n\t\t\tif(done[ny][nx]!=1) que.push(Pi(ny,nx));\n\t\t}\n\t\tif(flag) l[p.F_][p.S_]=f[p.F_][p.S_];\n\t\telse l[p.F_][p.S_]=tmp;\n\t}\n}\n\nvoid solve(){\n\tint R;\n\twhile(cin >> R&&R){\n\t\tint W[2],H[2],X[2],Y[2];\n\t\tvector<vector<int> > field[2];\n\t\tvector<vector<int> > level[2];\n\t\tvector<int> count[2],s[2];\n\t\tint _max=0;\n\t\tREP(i,0,2){\n\t\t\tcin >> W[i] >> H[i] >> X[i] >> Y[i];\n\t\t\t--X[i]; --Y[i];\n\t\t\tfield[i].resize(H[i]);\n\t\t\tlevel[i].resize(H[i]);\n\t\t\tREP(j,0,H[i]){\n\t\t\t\tfield[i][j].resize(W[i]);\n\t\t\t\tlevel[i][j].resize(W[i]);\n\t\t\t}\n\t\t\tREP(y,0,H[i]) REP(x,0,W[i]){\n\t\t\t\tcin >> field[i][y][x];\n\t\t\t\t_max=max(_max,field[i][y][x]);\n\t\t\t}\n\t\t\tBFS(field[i],level[i],Y[i],X[i],H[i],W[i]);\n\t\t\t/*\n\t\t\tcout << endl << endl;\n\t\t\tREP(y,0,H[i]){\n\t\t\t\tREP(x,0,W[i]) cout << level[i][y][x] << ' ';\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\tREP(i,0,2){\n\t\t\tcount[i].resize(_max+1);\n\t\t\ts[i].resize(_max+1);\n\t\t}\n\t\tREP(i,0,2) REP(y,0,H[i]) REP(x,0,W[i]) ++count[i][level[i][y][x]];\n\t\tREP(i,0,2) REP(j,1,_max+1) s[i][j]=s[i][j-1]+count[i][j];\n\t\tint result=INF;\n\t\tfor(int i=0; i<=_max*2&&i<=result; ++i){\n\t\t\t//cout << i << ' ' << s[0][i] << ' ' <<  (int)(lower_bound(s[1].begin(),s[1].end(),R-s[0][i])-s[1].begin()) << ' ' << s[1][(int)(lower_bound(s[1].begin(),s[1].end(),R-s[0][i])-s[1].begin())] << endl;\n\t\t\tint idx=(int)(lower_bound(s[1].begin(),s[1].end(),R-s[0][i])-s[1].begin());\n\t\t\tif(!(0<=idx&&idx<=_max)) continue;\n\t\t\tresult=min(result,i+idx);\n\t\t}\n\t\tcout << result << endl;\n\t}\n}\n\nint main(){\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <iterator>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <cmath>\n#include <complex>\n#include <functional>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <cstdlib>\n#include <cctype>\n\n#define REP(i,m,n) for(int i=m;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rp(i,c) rep(i,(int)c.size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define v_delete(a,b) (a).erase(remove((a).begin(), (a).end(), b), (a).end())\n#define v_unique(a) (a).erase(unique((a).begin(), (a).end()), (a).end())\n#define VV(T) vector<vector< T > >\n#define init(a,b) memset((a), (b), sizeof((a)))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double EPS=1e-9;\nconst long long INF = 100001000010000100ll;\n\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntypedef pair<int,int> pii;\n\nint R;\nint W[2], H[2], X[2], Y[2];\n\nint m[4][500+10][500+10];\nint visited[2][500+10][500+10];\n\nint wa[2][500*500*2+10];\n\nvi ls;\n\nmap<int ,int> cnt[2];\n\nbool exists(const map<int ,int> &mapp, int key){\n\treturn mapp.find(key) != mapp.end();\n}\n\nint dx[]={1,0,0,-1};\nint dy[]={0,1,-1,0};\n\nclass BIT{\nprivate:\n\tvi bit;\n\tint n;\npublic:\n\tBIT(int _n){\n\t\tn = _n;\n\t\tbit.assign(n+1,0 );\n\t}\n\tvoid add(int i, int x){\n\t\twhile(i <= n){\n\t\t\tbit[i] += x;\n\t\t\ti += (i & -i);\n\t\t}\n\t}\n\tint sum(int i){\n\t\tint s = 0;\n\t\twhile(i > 0){\n\t\t\ts += bit[i];\n\t\t\ti -= (i & -i);\n\t\t}\n\t\treturn s;\n\t}\n};\n\n\nint main(){\n\twhile(cin >> R, R){\n\n\t\tmemset(visited, 0, sizeof(visited));\n\n\t\tmemset(wa, 0, sizeof(wa));\n\n\t\tls.clear();\n\n\t\tfill_n(**m, 4 * (500+10) * (500+10), inf);\n\n\t\trep(c, 2){\n\t\t\tcin >> W[c] >> H[c] >> X[c] >> Y[c];\n\t\t\trep(i, H[c]){\n\t\t\t\trep(j, W[c]){\n\t\t\t\t\tcin >> m[c][i+1][j+1];\n\t\t\t\t\tls.pb(m[c][i+1][j+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tls.pb(0);\n\t\tls.pb(inf);\n\t\tsort(all(ls));\n\t\tls.erase(unique(all(ls)), ls.end());\n\t\trep(c, 2){\n\t\t\tpriority_queue<pair<int, pii>, vector<pair<int, pii> >, greater<pair<int, pii> > >Q;\n\t\t\tQ.push(mp(1, mp(X[c], Y[c])));\n\t\t\twhile(!Q.empty()){\n\t\t\t\tint x,y,level;\n\t\t\t\tx=Q.top().second.first;y=Q.top().second.second;level=Q.top().first;\n\t\t\t\tQ.pop();\n\t\t\t\tif(visited[c][y][x]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvisited[c][y][x] = 1;\n\n\t\t\t\tif(level > m[c][y][x]){\n\t\t\t\t\tm[c][y][x] = level;\n\t\t\t\t}else{\n\t\t\t\t\tlevel = m[c][y][x];\n\t\t\t\t}\n\t\t\t\t//printf(\"%d %d %d %d\\n\",c, x, y, level);\n\t\t\t\trep(k, 4){\n\t\t\t\t\tif(m[c][y+dy[k]][x+dx[k]]!=inf){\n\t\t\t\t\t\tif(!visited[c][y+dy[k]][x+dx[k]]){\n\t\t\t\t\t\t\tQ.push(mp(max(m[c][y+dy[k]][x+dx[k]], level), mp(x+dx[k], y+dy[k])));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}/*\n\t\trep(c, 2){\n\t\t\trep(i, H[c]){\n\t\t\t\trep(j, W[c]){\n\t\t\t\t\tcout <<  m[c][i+1][j+1] << \" \";\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\tcout << endl;\n\t\t\tcout << endl;\n\t\t}*/\n\t\trep(c, 2){\n\t\t\trep(i, H[c]){\n\t\t\t\trep(j, W[c]){\n\t\t\t\t\tint ma=-1;\n\t\t\t\t\tint tmp=inf;\n\t\t\t\t\t/*\n\t\t\t\t\trep(k, 4){\n\t\t\t\t\t\ttmp=min(tmp, m[c][i + 1 + dx[k]][j + 1 + dy[k]]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i + 1 == Y[c] && j + 1 == X[c]){\n\t\t\t\t\t\tma=m[c][i + 1][j + 1];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tma = max(m[c][i + 1][j + 1], tmp);\n\t\t\t\t\t}*/\n\t\t\t\t\tma=m[c][i + 1][j + 1];\n\t\t\t\t\tint l = lower_bound(all(ls), ma) - ls.begin();\n\t\t\t\t\twa[c][l]++;\n\n\t\t\t\t}\n\t\t\t}\n\t\t\trp(i, ls){\n\t\t\t\tif(i - 1 >= 0)\n\t\t\t\t\twa[c][i] = wa[c][i - 1] + wa[c][i];\n\t\t\t}\n\n\t\t}\n\t\t/*\n\t\trep(c, 2){\n\t\t\trp(i, ls){\n\t\t\t\tcout << ls[i] << \" \" << wa[c][i] << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\tcout << endl;\n\t\t}*/\n\t\tint ans=inf;\n\t\trp(i, ls){\n\n\t\t\tint l=lower_bound(wa[1],(wa[1]+(int)ls.size()) , R - wa[0][i]) - wa[1];\n\t\t\tif(l < ls.size())\n\t\t\tif(wa[0][i] + wa[1][l] >= R){\n\t\t\t\t//cout << ls[i] << \" \" << ls[l] << endl;\n\t\t\t\tans=min(ans, ls[i] + ls[l]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 160000\n#define B 100\n#define dpb push_back\n#define fi first\n#define se second\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst int inf = 1e9;\nconst ll INF = 1e18;\n//__gcd(a,b), __builtin_popcount(a);\n\nint r, h1, w1, X1, Y1, h2, w2, X2, Y2;\nint dy[4] = {0, 0, -1, 1}, dx[4] = {-1, 1, 0, 0};\nint a[602][602], b[602][602];\nint an[250004], bn[250004];\n\nint to_n(int y, int x, int w){\n\treturn (w*(y-1)+x);\n}\nint to_y(int n, int w){\n\treturn ((n-1)/w+1);\n}\nint to_x(int n, int w){\n\treturn (n-(to_y(n, w)-1)*w);\n}\nint main(){\n\twhile(1){\n\tfill((int*)a, (int*)(a+601), inf);\n\tfill((int*)b, (int*)(b+601), inf);\n\tfill(an, an+250004, 0);\n\tfill(bn, bn+250004, 0);\n\tscanf(\"%d\", &r);\n\tif(!r)break;\n\tscanf(\"%d%d%d%d\", &w1, &h1, &X1, &Y1);\n\trrep(i,h1)rrep(j,w1)scanf(\"%d\", &a[i][j]);\n\tscanf(\"%d%d%d%d\", &w2, &h2, &X2, &Y2);\n\trrep(i,h2)rrep(j,w2)scanf(\"%d\", &b[i][j]);\n\t\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tq.push(P(a[Y1][X1], to_n(Y1, X1,w1)));\n\ta[Y1][X1] = inf;\n\tint acnt = 1;\n\twhile(!q.empty()){\n\t\tP p = q.top();q.pop();\n\t\tint y = to_y(p.se, w1), x = to_x(p.se, w1);\n\t\tan[acnt++] = p.fi;\n\t\tfor(int i = 0;i < 4;i++){\n\t\t\tint yy = y+dy[i], xx = x+dx[i];\n\t\t\tif(a[yy][xx] != inf){\n\t\t\t\tq.push(P(a[yy][xx], to_n(yy, xx,w1)));\n\t\t\t\ta[yy][xx] = inf;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tq.push(P(b[Y2][X2], to_n(Y2, X2,w2)));\n\tb[Y2][X2] = inf;\n\tint bcnt = 1;\n\twhile(!q.empty()){\n\t\tP p = q.top();q.pop();\n\t\tint y = to_y(p.se, w2), x = to_x(p.se, w2);\n\t\tbn[bcnt++] = p.fi;\n\t\tfor(int i = 0;i < 4;i++){\n\t\t\tint yy = y+dy[i], xx = x+dx[i];\n\t\t\tif(b[yy][xx] != inf){\n\t\t\t\tq.push(P(b[yy][xx], to_n(yy, xx,w2)));\n\t\t\t\tb[yy][xx] = inf;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint t1 = 0, t2 = 0;\n\tfor(int i = 0;i < acnt;i++){\n\t\tt1 = max(t1, an[i]);\n\t\tan[i] = t1;\n\t}\n\tfor(int i = 0;i < bcnt;i++){\n\t\tt2 = max(t2, bn[i]);\n\t\tbn[i] = t2;\n\t}\n\t\n\tint ans = inf;\n\tfor(int i = 0;i < acnt;i++){\n\t\tif(r-i < bcnt)ans = min(ans, an[i]+bn[r-i]);\n\t}\n\t\n\t/*rep(i,acnt)printf(\"%d \", an[i]);\n\tprintf(\"\\n\");\n\trep(i,bcnt)printf(\"%d \", bn[i]);\n\tprintf(\"\\n\");*/\n\t//int ans = 0;\n\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\n\n\nint R;\nint W1, W2, H1, H2;\nint X1, X2, Y1, Y2;\nint map1[550][550], map2[550][550];\n\nint dx[4] = {-1, 1, 0, 0};\nint dy[4] = {0, 0, -1, 1};\n\nstruct Hole {\n\tint level;\n\tint x, y;\n\t\n\tHole(int _l, int _x, int _y) : level(_l), x(_x), y(_y) {}\n};\n\nbool operator < (const Hole& h1, const Hole& h2) { return h1.level < h2.level; }\nbool operator > (const Hole& h1, const Hole& h2) { return h1.level > h2.level; }\nbool operator == (const Hole& h1, const Hole& h2) { return h1.level == h2.level; }\nbool operator <= (const Hole& h1, const Hole& h2) { return h1.level <= h2.level; }\nbool operator >= (const Hole& h1, const Hole& h2) { return h1.level >= h2.level; }\n\nstruct Data {\n\tint need, rooms;\n\tData(int _n, int _r) : need(_n), rooms(_r) {}\n};\n\nint solver() {\n\tpriority_queue<Hole, vector<Hole>, greater<Hole> > q1, q2;\n\tq1.push(Hole(1, X1-1, Y1-1)); q2.push(Hole(1, X2-1, Y2-1));\n\tmap1[Y1-1][X1-1] = -1; map2[Y2-1][X2-1] = -1;\n\t\n\tvector<Data> v1, v2;\n\t\n\tint lev = 0;\n\tint cnt = 0;\n\tdo {\n\t\tHole h = q1.top(); q1.pop();\n\t\tif (h.level <= lev) {\n\t\t\tcnt++;\n\t\t} else {\n\t\t\tv1.push_back(Data(lev, cnt));\n\t\t\tlev = h.level;\n\t\t\tcnt++;\n\t\t}\n\t\t\n\t\tfor (int d=0; d<4; d++) {\n\t\t\tint x = h.x + dx[d], y = h.y + dy[d];\n\t\t\tif (!(0<=x && x<W1 && 0<=y && y<H1)) continue;\n\t\t\tif (map1[y][x]==-1) continue;\n\t\t\tq1.push(Hole(map1[y][x], x, y));\n\t\t\tmap1[y][x] = -1;\n\t\t}\n\t\t\n\t} while(!q1.empty());\n\tv1.push_back(Data(lev, cnt));\n\t\n\tlev = 0;\n\tcnt = 0;\n\tdo {\n\t\tHole h = q2.top(); q2.pop();\n\t\tif (h.level <= lev) {\n\t\t\tcnt++;\n\t\t} else {\n\t\t\tv2.push_back(Data(lev, cnt));\n\t\t\tlev = h.level;\n\t\t\tcnt++;\n\t\t}\n\t\t\n\t\tfor (int d=0; d<4; d++) {\n\t\t\tint x = h.x + dx[d], y = h.y + dy[d];\n\t\t\tif (!(0<=x && x<W2 && 0<=y && y<H2)) continue;\n\t\t\tif (map2[y][x]==-1) continue;\n\t\t\tq2.push(Hole(map2[y][x], x, y));\n\t\t\tmap2[y][x] = -1;\n\t\t}\n\t\t\n\t} while(!q2.empty());\n\tv2.push_back(Data(lev, cnt));\n\t\n\tint ret = 1e8;\n\tint i = 0, j = (int)v2.size()-1;\n\twhile (i<(int)v1.size() && j >= 0) {\n\t\tData d1 = v1[i], d2 = v2[j];\n\t\tif (d1.rooms + d2.rooms >= R) {\n\t\t\tret = min(ret, d1.need + d2.need);\n\t\t\tj--;\n\t\t} else {\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> R; if (R==0) break;\n\t\tcin >> W1 >> H1 >> X1 >> Y1;\n\t\tfor (int i=0; i<H1; i++) {\n\t\t\tfor (int j=0; j<W1; j++) {\n\t\t\t\tcin >> map1[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcin >> W2 >> H2 >> X2 >> Y2;\n\t\tfor (int i=0; i<H2; i++) {\n\t\t\tfor (int j=0; j<W2; j++) {\n\t\t\t\tcin >> map2[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solver() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<queue>\nusing namespace std;\n\nconst int dy[4]={-1,0,1,0},dx[4]={0,1,0,-1};\nint needlev[2][100002];\nint fld[500][500];\n\nstruct Data{\n\tint y,x,lev;\n\tData(){}\n\tData(int _y,int _x,int _lev){\n\t\ty=_y; x=_x; lev=_lev;\n\t}\n\tbool operator<(const Data &a)const{\n\t\treturn lev>a.lev;\n\t}\n};\n\nint main(){\n\tint W,H,X,Y,R;\n\twhile(cin>>R,R){\n\t\tvector<int> r[2];\n\t\tfor(int K=0;K<2;K++){\n\t\t\tpriority_queue<Data> q;\n\t\t\tcin>>W>>H>>X>>Y; X--; Y--;\n\t\t\tq.push(Data(Y,X,1));\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tcin>>fld[i][j];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint cntR=0;\n\t\t\tData q_c;\n\t\t\tbool used[500][500]={};\n\t\t\tused[Y][X] = true;\n\t\t\tneedlev[K][0] = needlev[K][R+1] = 0;\n\t\t\twhile(!q.empty()){\n\t\t\t\tq_c = q.top(); q.pop();\n\t\t\t\tcntR++;\n\t\t\t\t//printf(\"%d: %d,%d,%d\\n\",cntR,q_c.y,q_c.x,q_c.lev);\n\t\t\t\tneedlev[K][cntR] = q_c.lev;\n\t\t\t\tif(cntR==R) break;\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint ny = q_c.y+dy[i],\n\t\t\t\t\t\tnx = q_c.x+dx[i];\n\t\t\t\t\tif(ny<0 || H<=ny || nx<0 || W<=nx || used[ny][nx])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tused[ny][nx] = true;\n\t\t\t\t\tq.push(Data(ny,nx,max(q_c.lev,fld[ny][nx])));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<=cntR;i++){\n\t\t\t\tif(needlev[i]!=needlev[i+1]){\n\t\t\t\t\tr[K].push_back(i);\n\t\t\t\t\t//printf(\"%d \",i);\n\t\t\t\t}\n\t\t\t}//puts(\"\");\n\t\t}\n\t\tint ans=1000000000;\n\t\tfor(int i=0;i<r[0].size();i++){\n\t\t\tvector<int>::iterator itr = lower_bound(r[1].begin(),r[1].end(),R-r[0][i]);\n\t\t\tif(itr!=r[1].end())\n\t\t\t\tans = min(ans,needlev[0][r[0][i]]+needlev[1][*itr]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb push_back\n#define mp make_pair\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,-1,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pint pair<int,int>\n#define INF 1<<29\n#define MAX 501\nusing namespace std;\n \nint R,W[2],H[2],X[2],Y[2],L[2][MAX][MAX],d[2][MAX][MAX],dd[4]={0,-1,0,1};\nmap<int,int> m[2];\nmap<int,int>::iterator ite;\nvector<int> lev[2],sum[2];\n \nvoid solve(){\n for(;;){\n  cin>>R;\n  if(!R) return;\n  FOR(i,2){\n   cin>>W[i]>>H[i]>>X[i]>>Y[i];\n   X[i]--;\n   Y[i]--;\n   FOR(j,H[i]) FOR(k,W[i]) cin>>L[i][j][k];\n   FOR(j,H[i]) FOR(k,W[i]) d[i][j][k]=INT_MAX/3;\n   d[i][X[i]][Y[i]]=1;\n   priority_queue<pint,vector<pint>,greater<pint>> pque;\n   pque.push(mp(1,X[i]*W[i]+Y[i]));\n   while(!pque.empty()){\n    pint p=pque.top(); pque.pop();\n    int x=p.second/W[i],y=p.second%W[i];\n    if(d[i][x][y]<p.first) continue;\n    FOR(j,4){\n     int nx=x+dd[j],ny=y+dd[j^1];\n     if(nx<0||ny<0||nx>=H[i]||ny>=W[i]) continue;\n     if(d[i][nx][ny]>max(d[i][x][y],L[i][nx][ny])){\n      d[i][nx][ny]=max(d[i][x][y],L[i][nx][ny]);\n      pque.push(mp(d[i][nx][ny],nx*W[i]+ny));\n     }\n    }\n   }\n   FOR(j,H[i]) FOR(k,W[i]) m[i][d[i][j][k]]++;\n   int tot=0;\n   lev[i].pb(0);\n   sum[i].pb(0);\n   for(ite=m[0].begin();ite!=m[0].end();ite++){\n    lev[i].pb(ite->first);\n    tot+=ite->second;\n    sum[i].pb(tot);\n   }\n  }\n  int mi=1<<30;\n  FOR(i,lev[0].size()){\n   int ind=lower_bound(ALL(sum[1]),R-sum[0])-sum[1].begin();\n   mi=min(mi,lev[ind]+lev[i]);\n  }\n  cout<<mi<<endl;\n  FOR(i,2){\n   m[i].clear();\n   lev[i].clear();\n   sum[i].clear();\n  }\n }\n}\n \nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pint;\ntypedef pair<ll, int> P;\n//typedef tuple<int,int,int> T;\nll INFL = 1000000000000000010;//10^18 = 2^60\nint INF = 2147483600;//10^9\nll MOD  = 1000000007;\nint solve(){\n    vector<int> dy(4);\n    vector<int> dx(4);\n    dy.at(0) = 0;\n    dy.at(1) = 0;\n    dy.at(2) = 1;\n    dy.at(3) = -1;\n    dx.at(0) = 1;\n    dx.at(1) = -1;\n    dx.at(2) = 0;\n    dx.at(3) = 0;\n    \n    int R;\n    cin >> R;\n    if(R == 0)return 0;\n    int H1,W1,X1,Y1;\n    cin >> W1 >> H1 >> X1 >> Y1;\n    X1--;\n    Y1--;\n    vector<vector<ll>> mp1(H1, vector<ll>(W1));\n    vector<vector<ll>> d1(H1, vector<ll>(W1, INFL));\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            cin >> mp1[i][j];\n        }\n    }\n    \n    d1[Y1][X1] = 1;\n    priority_queue<pair<ll, pair<int, int>>> pque1;\n    pque1.push({1, {Y1, X1}});\n    \n    while(!pque1.empty()){\n        ll c;\n        int y,x;\n        c = pque1.top().first;\n        y = pque1.top().second.first;\n        x = pque1.top().second.second;\n        pque1.pop();\n        if(c > d1[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H1 && 0 <= nx && nx < W1){\n                if(d1[ny][nx] > d1[y][x]){\n                    if(d1[y][x] > mp1[ny][nx]){\n                        d1[ny][nx] = d1[y][x];\n                    }else{\n                        d1[ny][nx] = mp1[ny][nx];\n                    }\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }else if(d1[ny][nx] > d1[y][x]){\n                    d1[ny][nx] = mp1[ny][nx];\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    int H2,W2,X2,Y2;\n    cin >> W2 >> H2 >> X2 >> Y2;\n    X2--;\n    Y2--;\n    vector<vector<ll>> mp2(H2, vector<ll>(W2));\n    vector<vector<ll>> d2(H2, vector<ll>(W2, INFL));\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            cin >> mp2[i][j];\n        }\n    }\n    \n    d2[Y2][X2] = 1;\n    priority_queue<pair<ll, pair<int, int>>> pque2;\n    pque2.push({1, {Y2, X2}});\n    \n    while(!pque2.empty()){\n        ll c;\n        int y,x;\n        c = pque2.top().first;\n        y = pque2.top().second.first;\n        x = pque2.top().second.second;\n        pque2.pop();\n        if(c > d2[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H2 && 0 <= nx && nx < W2){\n                if(d2[ny][nx] > d2[y][x]){\n                    if(d2[y][x] > mp2[ny][nx]){\n                        d2[ny][nx] = d2[y][x];\n                    }else{\n                        d2[ny][nx] = mp2[ny][nx];\n                    }\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }else if(d2[ny][nx] > d2[y][x]){\n                    d2[ny][nx] = mp2[ny][nx];\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    vector<pair<ll,int>> O1(0);\n    vector<ll> COST1(0);\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            COST1.push_back(d1[i][j]);\n        }\n    }\n    sort(COST1.begin(), COST1.end());\n    COST1.push_back(INFL);\n    ll ad1 = COST1.at(0);\n    int cnt = 0;\n    for(int i = 0; i < COST1.size(); i++){\n        if(ad1 == COST1.at(i)){\n            cnt++;\n        }else{\n            O1.push_back({ad1, cnt});\n            ad1 = COST1.at(i);\n            cnt++;\n        }\n    }\n    \n    vector<pair<ll,int>> O2 = {pair{0, 0}};\n    vector<ll> COST2(0);\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            COST2.push_back(d2[i][j]);\n        }\n    }\n    sort(COST2.begin(), COST2.end());\n    COST2.push_back(INFL);\n    ll ad2 = COST2.at(0);\n    cnt = 0;\n    for(int i = 0; i < COST2.size(); i++){\n        if(ad2 == COST2.at(i)){\n            cnt++;\n        }else{\n            O2.push_back({ad2, cnt});\n            ad2 = COST2.at(i);\n            cnt++;\n        }\n    }\n    \n    ll ans = INFL;\n    for(int i = 0; i < O1.size(); i++){\n        ll cost = O1.at(i).first;\n        int rest = R - O1.at(i).second;\n        \n        if(rest > O2.at(O2.size()-1).second) continue;\n        int left = -1, right = O2.size();\n        int mid;\n        while(right - left > 1){\n            mid = (left + right) / 2;\n            if(O2.at(mid).second >= rest){\n                right = mid;\n            }else{\n                left = mid;\n            }\n        }\n        cost += O2.at(right).first;\n        ans = min(ans, cost);\n        \n    }\n    \n    cout << ans << endl;\n    \n    solve();\n    return 0;\n}\n\nint main(void){\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint R;\nint W[2], H[2], X[2], Y[2];\nint grid[500][500][2];\nbool used[500][500];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n/*\nint count(int B, int idx){\n  if(grid[Y[idx]][X[idx]][idx] > B) return 0;\n  queue<int> qx, qy;\n  qx.push(X[idx]);\n  qy.push(Y[idx]);\n  bool used[500][500] = {};\n  used[Y[idx]][X[idx]] = true;\n  int res = 1;\n  while(!qx.empty()){\n    int x = qx.front(), y = qy.front();\n    qx.pop(), qy.pop();\n    REP(r, 4){\n      int nx = x + dx[r];\n      int ny = y + dy[r];\n      if(nx >= 0 && nx < W[idx] && ny >= 0 && ny < H[idx] && grid[ny][nx][idx] <= B && !used[ny][nx]){\n        used[ny][nx] = true;\n        res++;\n        qx.push(nx), qy.push(ny);\n      }\n    }\n  }\n  return res;\n}\n*/\ntypedef pair<int, int> P;\nstruct S{\n  P p;\n  int d;\n  S() {}\n  S(P p, int d) : p(p), d(d) {}\n  bool operator < (const S& s) const {\n    return d > s.d;\n  }\n};\nint get_index(vector<int>& v, int n){\n  return (lower_bound(v.begin(), v.end(), n) - v.begin());\n}\n\nint main(){\n  while(cin>>R && R){\n    vector<int> cand[2];\n    REP(i, 2){\n      cin>>W[i]>>H[i]>>X[i]>>Y[i];\n      X[i]--; Y[i]--;\n      REP(y, H[i])REP(x, W[i]){\n        cin>>grid[y][x][i];\n        cand[i].push_back(grid[y][x][i]);\n      }\n    }\n    REP(i, 2){\n      sort(cand[i].begin(), cand[i].end());\n      cand[i].erase(unique(cand[i].begin(), cand[i].end()), cand[i].end());\n    }\n    vector<int> count[2];\n    REP(i, 2)count[i] = vector<int>(cand[i].size());\n    REP(i, 2){\n      int memo[500][500] = {};\n      REP(y, H[i])REP(x, W[i]) memo[y][x] = INF;\n      priority_queue<S> que;\n      que.push(S(P(X[i], Y[i]), grid[Y[i]][X[i]][i]));\n      memo[Y[i]][X[i]] = grid[Y[i]][X[i]][i];\n      while(!que.empty()){\n        S s = que.top(); que.pop();\n        int x = s.p.first, y = s.p.second;\n        if(memo[y][x] < s.d) continue;\n        REP(r, 4){\n          int nx = x + dx[r], ny = y + dy[r];\n          if(nx >= 0 && nx < W[i] && ny >= 0 && ny < H[i]){\n            int next_d = max(grid[ny][nx][i], s.d);\n            if(next_d >= memo[ny][nx]) continue;\n            memo[ny][nx] = next_d;\n            que.push(S(P(nx, ny), next_d));\n          }\n        }\n      }\n      REP(y, H[i])REP(x, W[i]) count[i][get_index(cand[i], memo[y][x])] ++;\n    }\n    vector<int> sum[2];\n    REP(i, 2){\n      sum[i] = vector<int>(cand[i].size() + 1);\n      REP(j, cand[i].size()) sum[i][j + 1] = sum[i][j] + count[i][j];\n    }\n    int ans = INF;\n    REP(i, cand[0].size() + 1){\n      int rest = R - sum[0][i];\n      int j = get_index(sum[1], rest);\n      ans = min(ans, ((i != 0) ? cand[0][i - 1] : 0) + ((j == 0) ? 0 : (j == cand[1].size() + 1) ? INF : cand[1][j - 1]));\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> P1;\n\nint m[1001][1001];\n\nbool used[1001][1001];\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint main(){\n\t\n\twhile(true){\n\t\tint R;\n\t\tcin >> R;\n\t\tif(R == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tint a[2] = {};\n\t\t\n\t\tint num[2][100001];\n\t\t\n\t\tfor(int i = 0; i < 2; i++){\n\t\t\tfor(int j = 0; j <= 100000; j++){\n\t\t\t\tnum[i][j] = 1000000000;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < 2; i++){\n\t\t\tint W, H, X, Y;\n\t\t\tcin >> W >> H >> X >> Y;\n\t\t\tX--;\n\t\t\tY--;\n\t\t\tfor(int j = 0; j < H; j++){\n\t\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\t\tcin >> m[j][k];\n\t\t\t\t\tused[j][k] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpriority_queue<P1, vector<P1>, greater<P1> > pque;\n\t\t\tP1 p;\n\t\t\tp.first = 1;\n\t\t\tp.second.first = X;\n\t\t\tp.second.second = Y;\n\t\t\tpque.push(p);\n\t\t\tused[Y][X] = true;\n\t\t\t\n\t\t\tfor(int j = 0; j <= R; j++){\n\t\t\t\tnum[i][j] = a[i];\n\t\t\t\tif(pque.empty()){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tP1 p1 = pque.top();\n\t\t\t\tpque.pop();\n\t\t\t\t//cout << p1.first << \" \";\n\t\t\t\t//cout << p1.second.second << \" \" << p1.second.first << endl;\n\t\t\t\ta[i] = max(a[i], p1.first);\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tP1 pp;\n\t\t\t\t\tpp.second.first = p1.second.first + dy[j];\n\t\t\t\t\tpp.second.second = p1.second.second + dx[j];\n\t\t\t\t\tif(pp.second.second >= 0 && pp.second.first >= 0 && pp.second.second < W && pp.second.first < H && !used[pp.second.first][pp.second.second]){\n\t\t\t\t\t\tpp.first = m[pp.second.first][pp.second.second];\n\t\t\t\t\t\tpque.push(pp);\n\t\t\t\t\t\tused[pp.second.first][pp.second.second] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 1000000000;\n\t\t\n\t\tfor(int j = 0; j <= R; j++){\n\t\t\tans = min(ans, num[0][j] + num[1][R - j]);\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <numeric>\n#include <map>\n#include <vector>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <cmath>\n#include <stack>\n#include <cctype>\n#include <queue>\n#include <algorithm>\n#include <memory>\n#include <memory.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nconst int INF = 1 << 30;\nconst double EPS = 1e-10;\nconst double PI = 3.14159;\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, -1, 0, 1};\nbool used[2][502][502];\nint office[2][502][502];\nint cost[2][110000];\nint w[2];\nint h[2];\nint x[2];\nint y[2];\n\nint main(){\n\tint R;\n\twhile(cin >> R && R){\n\t\tfill(&office[0][0][0], &office[1][501][501] + 1, INF);\n\t\tfill(&cost[0][0], &cost[1][109999] + 1, INF);\n\t\tmemset(used, false, sizeof(used));\n\t\tfor(int i = 0; i < 2; i++){\n\t\t\tcin >> w[i] >> h[i] >> x[i] >> y[i];\n\t\t\tfor(int j = 1; j <= h[i]; j++){\n\t\t\t\tfor(int k = 1; k <= w[i]; k++){\n\t\t\t\t\tcin >> office[i][j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 2; i++){\n\t\t\tpriority_queue<PP, vector<PP>, greater<PP> > que;\n\t\t\tcost[i][0] = 0;\n\t\t\tint m_cost = 0;\n\t\t\tint count = 1;\n\t\t\tque.push(PP(1, P(y[i], x[i])));\n\t\t\twhile(!que.empty()){\n\t\t\t\tPP pp = que.top();\n\t\t\t\tque.pop();\n\t\t\t\tint c = pp.first;\n\t\t\t\tif(c == INF || count >= R + 10 || count > h[i] * w[i]) break;\n\t\t\t\tm_cost = max(m_cost, c);\n\t\t\t\tint y1 = pp.second.first;\n\t\t\t\tint x1 = pp.second.second;\n\t\t\t\tused[i][y1][x1] = true;\n\t\t\t\tcost[i][count++] = m_cost;\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tint y2 = y1 + dy[j];\n\t\t\t\t\tint x2 = x1 + dx[j];\n\t\t\t\t\tif(used[i][y2][x2]) continue;\n\t\t\t\t\tque.push(PP(office[i][y2][x2], P(y2, x2)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = INF;\n\t\tfor(int i = 0; i <= R; i++){\n\t\t\tres = min(res, cost[0][i] + cost[1][R-i]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\n\nvector<int> calc_required_level_to_rooms()\n{\n\tint w, h, sx, sy;\n\tstatic int req[512][512];\n\tcin >> w >> h >> sx >> sy;\n\t--sx, --sy;\n\tfor (int y = 0; y < h; ++y)\n\t\tfor (int x = 0; x < w; ++x)\n\t\t\tcin >> req[y][x];\n\n\tvector<int> res;\n\tres.push_back(0);\n\n\tstatic bool visit[512][512];\n\tCLEAR(visit, 0);\n\n\ttypedef pair<int, pint> P;\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tq.push(P(1, pint(sx, sy)));\n\twhile (!q.empty())\n\t{\n\t\tP tt = q.top(); q.pop();\n\t\tint level = tt.first;\n\t\tint x = tt.second.first, y = tt.second.second;\n\t\tif (visit[y][x])\n\t\t\tcontinue;\n\n\t\tvisit[y][x] = true;\n\t\tres.push_back(level);\n\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\t\tif (valid_pos(tx, ty, w, h) && !visit[ty][tx])\n\t\t\t\tq.push(P(max(level, req[ty][tx]), pint(tx, ty)));\n\t\t}\n\t}\n\n\treturn res;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tint r;\n\tcin >> r;\n\n\tvector<int> a = calc_required_level_to_rooms();\n\tvector<int> b = calc_required_level_to_rooms();\n\tif (a.size() < b.size())\n\t\tswap(a, b);\n\n\tint res = 1e9;\n\tfor (int i = min<int>(r, a.size()); i >= 0 && r - i < b.size(); --i)\n\t\tmin_swap(res, a[i] + b[r - i]);\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <tuple>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nconst vector<int> dx = { 0, 1, 0, -1 };\nconst vector<int> dy = { -1, 0, 1, 0 };\n\nint R, W[2], H[2], X[2], Y[2], F[2][500][500], D[2][500][500];\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &R);\n\n\t\tif (R == 0) break;\n\n\t\tfor (int i = 0; i < 2; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &W[i]);\n\t\t\tscanf(\"%d\", &H[i]);\n\t\t\tscanf(\"%d\", &X[i]); X[i]--;\n\t\t\tscanf(\"%d\", &Y[i]); Y[i]--;\n\n\t\t\tfor (int j = 0; j < H[i]; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < W[i]; k++)\n\t\t\t\t{\n\t\t\t\t\tscanf(\"%d\", &F[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(D, -1, sizeof(D));\n\n\t\tfor (int i = 0; i < 2; i++)\n\t\t{\n\t\t\tD[i][Y[i]][X[i]] = 1;\n\n\t\t\tpriority_queue<tuple<int, int, int>, vector<tuple<int, int, int> >, greater<tuple<int, int, int> > > que;\n\n\t\t\tque.push(make_tuple(0, X[i], Y[i]));\n\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\ttuple<int, int, int> state = que.top(); que.pop();\n\n\t\t\t\tint d = get<0>(state);\n\t\t\t\tint x = get<1>(state);\n\t\t\t\tint y = get<2>(state);\n\n\t\t\t\tfor (int dir = 0; dir < 4; dir++)\n\t\t\t\t{\n\t\t\t\t\tint x2 = x + dx[dir];\n\t\t\t\t\tint y2 = y + dy[dir];\n\n\t\t\t\t\tif (0 <= x2 && x2 < W[i] && 0 <= y2 && y2 < H[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (D[i][y2][x2] == -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tD[i][y2][x2] = max(d, F[i][y2][x2]);\n\n\t\t\t\t\t\t\tque.push(make_tuple(D[i][y2][x2], x2, y2));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<int> E[2];\n\n\t\tfor (int i = 0; i < 2; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < H[i]; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < W[i]; k++)\n\t\t\t\t{\n\t\t\t\t\tE[i].push_back(D[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsort(E[i].begin(), E[i].end());\n\t\t}\n\n\t\tint ret = 999999999;\n\n\t\tfor (int i = 0; i < R; i++)\n\t\t{\n\t\t\tif (i < E[0].size() && R - i < E[1].size())\n\t\t\t{\n\t\t\t\tret = min(ret, E[0][i] + E[1][R - i - 1]);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define all(x) x.begin(),x.end()\n#define rep(i,N) for(int i=0;i<(int)N;++i)\nusing namespace std;\nusing ll = long long;\nusing vint = vector<int>;\nusing vll = vector<ll>;\nusing vll2 = vector<vector<ll>>;\nconst ll INF = (1LL << 30);\nconst ll LINF = (1LL << 60);\nconst ll MOD = 1e9 + 7;\n\nstruct Data {\n   int y;\n   int x;\n   ll cost;\n   bool operator<(const Data& r) const {\n      return cost < r.cost;\n   }\n   bool operator>(const Data& r) const {\n      return cost > r.cost;\n   }\n};\n\nint main() {\n   cin.tie(0);\n   ios::sync_with_stdio(false);\n   using P = pair<int, int>;\n   int dy[] = { 0, 1, 0, -1 };\n   int dx[] = { -1, 0, 1, 0 };\n\n   while (true) {\n      int R; cin >> R;\n      if (R == 0) break;\n      vll2 v(2, vll(R + 1, INF));\n      v[0][0] = v[1][0] = 0;\n      rep(k, 2) {\n         int W, H, X, Y;\n         cin >> W >> H >> X >> Y, X--, Y--;\n         vll2 L(H, vll(W));\n         rep(i, H) rep(j, W) cin >> L[i][j];\n\n         priority_queue<Data, vector<Data>, greater<Data>> que;\n         que.emplace(Data{ Y, X, 1 });\n         int cnt = 1;\n         ll res = 1;\n         while (cnt <= R && !que.empty()) {\n            Data dat = que.top(); que.pop();\n            if (L[dat.y][dat.x] == INF) continue;\n            res = max(res, dat.cost);\n            v[k][cnt++] = res;\n            L[dat.y][dat.x] = INF;\n            rep(i, 4) {\n               int ny = dy[i] + dat.y, nx = dx[i] + dat.x;\n               if (ny < 0 || ny >= H || nx < 0 || nx >= W || L[ny][nx] == INF) continue;\n               que.emplace(Data{ ny, nx, L[ny][nx] });\n            }\n         }\n      }\n\n      ll ans = LINF;\n      for (int i = 0; i <= R; ++i) {\n         ans = min(ans, v[0][i] + v[1][R - i]);\n      }\n      cout << ans << endl;\n   }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int INF = 1001001001;\n\nint r, x[2], y[2];\nint grid[2][502][502];\nbool done[2][502][502];\n\nstruct P\n{\n\tint g, x, y;\n\t\n\tbool operator < (const P& t) const {\n\t\treturn grid[g][x][y] > grid[g][t.x][t.y];\n\t}\n};\n\nint search(int g, int num)\n{\n\tfor (int i = 0; i < 502; i++){\n\t\tfor (int j = 0; j < 502; j++){\n\t\t\tdone[g][i][j] = false;\n\t\t}\n\t}\n\t\n\tint level = 0;\n\tint mini = INF;\n\tpriority_queue<P> que;\n\tque.push({g, x[g], y[g]});\n\twhile (!que.empty()){\n\t\tP p = que.top(); que.pop();\n\t\tif (done[g][p.x][p.y]) continue;\n\t\tdone[g][p.x][p.y] = true;\n\t\t\n\t\t//printf(\"%d %d %d\\n\", g, p.x, p.y);\n\t\t\n\t\tif (grid[g][p.x][p.y] <= level){\n\t\t\tnum++;\n\t\t}\n\t\telse {\n\t\t\tif (g == 0){\n\t\t\t\tmini = min(mini, level + search(1, num));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (num >= r){\n\t\t\t\t\treturn level;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (grid[g][p.x][p.y] == INF) break;\n\t\t\tlevel = grid[g][p.x][p.y];\n\t\t\tnum++;\n\t\t}\n\t\t\n\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\tint tx = p.x + dx[dir];\n\t\t\tint ty = p.y + dy[dir];\n\t\t\tif (!done[g][tx][ty]){\n\t\t\t\tque.push({g, tx, ty});\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn mini;\n}\n\nint main()\n{\n\twhile (scanf(\"%d\", &r), r){\n\t\tfor (int i = 0; i < 2; i++){\n\t\t\tfor (int j = 0; j < 502; j++){\n\t\t\t\tfor (int k = 0; k < 502; k++){\n\t\t\t\t\tgrid[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint h, w;\n\t\t\tscanf(\"%d %d %d %d\", &w, &h, &y[i], &x[i]);\n\t\t\tfor (int j = 1; j <= h; j++){\n\t\t\t\tfor (int k = 1; k <= w; k++){\n\t\t\t\t\tscanf(\"%d\", &grid[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", search(0, 0));\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int, pair<int, int> >P;\n\nint R;\nint W[2],H[2],X[2],Y[2];\nint o[2][512][512];\nint cost[2][100005];\nint vis[2][512][512];\nint dy[]={0,-1,0,1},dx[]={-1,0,1,0};\n\nint main(){\n  while(scanf(\"%d\",&R) && R){\n    for(int i=0;i<2;i++){\n      scanf(\"%d%d%d%d\",&W[i],&H[i],&X[i],&Y[i]); X[i]--; Y[i]--;\n      for(int j=0;j<H[i];j++) for(int k=0;k<W[i];k++) scanf(\"%d\",&o[i][j][k]);\n    }\n    memset(vis, 0, sizeof vis);\n    for(int i=0;i<2;i++) for(int j=0;j<=R;j++) cost[i][j] = 1<<29;\n    for(int i=0;i<2;i++){\n      cost[i][0] = 0;\n      priority_queue<P, vector<P>, greater<P> >q;\n      q.push(make_pair(o[i][Y[i]][X[i]], make_pair(Y[i], X[i])));\n      vis[i][Y[i]][X[i]] = 1;\n      for(int r=1;r<=min(R, W[i]*H[i]);r++){\n\tP p = q.top(); q.pop();\n\tint c = p.first, y = p.second.first, x = p.second.second;\n\tcost[i][r] = max(cost[i][r-1], c);\n\tfor(int d=0;d<4;d++){\n\t  int nx=x+dx[d],ny=y+dy[d];\n\t  if(ny<0||ny>=H[i]||nx<0||nx>=W[i]||vis[i][ny][nx]) continue;\n\t  q.push(make_pair(o[i][ny][nx], make_pair(ny, nx)));\n\t  vis[i][ny][nx] = 1;\n\t}\n      }\n    }\n\n    int res = 1<<29;\n    for(int i=0;i<=R;i++){\n      res = min(res, cost[0][i]+cost[1][R-i]);\n    }\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <bitset>\n#include <stack>\n#include <cstdlib>\n#include <complex>\n#include <unordered_map>\n#define rep(i,s,n) for(int i = s; n > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define MODU 33\n#define Range(x,a,b) ((a) <= (x) && (x) <= (b))\n#define POWT(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\nusing namespace std;\ntypedef vector<int> Ivec;\ntypedef pair<int, int> pii;\ntypedef long long int ll;\nconst pii Dir[8] = { //?????????\n\t{ 0,1 },{ 0,-1 },{ 1,0 },{ -1,0 },\n\t{ 1,1 },{ 1,-1 },{ -1,-1 },{ -1,1 }\n};\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*)array, (T*)(array + N), val);\n}\nint main() {\n\tint r;\n\tscanf(\"%d\", &r);\n\tint w, h, x, y;\n\tscanf(\"%d %d %d %d\", &w, &h, &x, &y);\n\tvector<vector<int>> m(h, vector<int>(w));\n\tREP(i, h) {\n\t\tREP(j, w) {\n\t\t\tscanf(\"%d\", &m[i][j]);\n\t\t\tm[i][j]--;\n\t\t}\n\t}\n\tint w2, h2, x2, y2;\n\tscanf(\"%d %d %d %d\", &w2, &h2, &x2, &y2);\n\tvector<vector<int>> m2(h2, vector<int>(w2));\n\n\tREP(i, h2) {\n\t\tREP(j, w2) {\n\t\t\tscanf(\"%d\", &m2[i][j]);\n\t\t\tm2[i][j]--;\n\t\t}\n\t}\n\n\tpriority_queue<pair<int, pii>, vector<pair<int, pii>>, greater<pair<int, pii>>> que;\n\n\tque.push({ 1,{x,y} });\n\n\tmap<int, int> mcount;\n\tvector<vector<int>> al(h, vector<int>(w));\n\twhile (que.size()) {\n\t\tint  p = que.top().first;\n\t\tpii cur = que.top().second;\n\t\tque.pop();\n\t\tif (al[cur.first][cur.second])\n\t\t\tcontinue;\n\t\tal[cur.first][cur.second] = 1;\n\t\tmcount[p]++;\n\n\t\tREP(i, 4) {\n\t\t\tpii next = { cur.first + Dir[i].first, cur.second + Dir[i].second };\n\t\t\tif (Range(next.first, 0, h - 1), Range(next.second, 0, w - 1)) {\n\t\t\t\tif (al[next.first][next.second]) {\n\t\t\t\t\tque.push({ max(p,m[next.first][next.second]),next });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<pii> cou;//???????????°?????¬??????\n\tfor (auto cur : mcount) {\n\t\tcou.push_back({ cur.second,cur.first });\n\t}\n\trep(i, 1, cou.size()) {\n\t\tif (cou[i].first == cou[i - 1].first) {\n\t\t\tif (cou[i].second > cou[i - 1].second)\n\t\t\t\tcou.erase(cou.begin() + i);\n\t\t\telse\n\t\t\t\tcou.erase(cou.begin() + i - 1);\n\t\t\ti--;\n\t\t}\n\t}\n\n\tmcount.clear();\n\tfill(ALL(al), vector<int>(w));\n\tque.push({ 1,{x2,y2} });\n\twhile (que.size()) {\n\t\tint  p = que.top().first;\n\t\tpii cur = que.top().second;\n\t\tal[cur.first][cur.second] = 1;\n\t\tmcount[p]++;\n\n\t\tREP(i, 4) {\n\t\t\tpii next = { cur.first + Dir[i].first, cur.second + Dir[i].second };\n\t\t\tif (Range(next.first, 0, h - 1), Range(next.second, 0, w - 1)) {\n\t\t\t\tif (al[next.first][next.second]) {\n\t\t\t\t\tque.push({ max(p,m2[next.first][next.second]),next });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<pii> cou2;\n\tfor (auto cur : mcount) {\n\t\tcou2.push_back(cur);\n\t}\n\trep(i, 1, cou2.size()) {\n\t\tif (cou2[i].first == cou2[i - 1].first) {\n\t\t\tif (cou2[i].second > cou2[i - 1].second)\n\t\t\t\tcou2.erase(cou2.begin() + i);\n\t\t\telse\n\t\t\t\tcou2.erase(cou2.begin() + i - 1);\n\t\t\ti--;\n\t\t}\n\t}\n\n\tint Min = INT_MAX;\n\tREP(i, cou.size()) {\n\t\tauto itr = upper_bound(ALL(cou2) ,make_pair(cou[i].first,0));\n\t\tif (itr != cou2.end()) {\n\t\t\tMin = min(Min,itr->second + cou[i].second);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", Min);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\n\nvector<int> calc_required_level_to_rooms()\n{\n\tint w, h, sx, sy;\n\tstatic int req[512][512];\n\tcin >> w >> h >> sx >> sy;\n\t--sx, --sy;\n\tfor (int y = 0; y < h; ++y)\n\t\tfor (int x = 0; x < w; ++x)\n\t\t\tcin >> req[y][x];\n\n\tvector<int> res;\n\tres.push_back(0);\n\n\tstatic bool visit[512][512];\n\tCLEAR(visit, 0);\n\n\ttypedef pair<int, pint> P;\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tq.push(P(1, pint(sx, sy)));\n\twhile (!q.empty())\n\t{\n\t\tP tt = q.top(); q.pop();\n\t\tint level = tt.first;\n\t\tint x = tt.second.first, y = tt.second.second;\n\t\tif (visit[y][x])\n\t\t\tcontinue;\n\n\t\tvisit[y][x] = true;\n\t\tres.push_back(level);\n\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\t\tif (valid_pos(tx, ty, w, h) && !visit[ty][tx])\n\t\t\t\tq.push(P(max(level, req[ty][tx]), pint(tx, ty)));\n\t\t}\n\t}\n\treturn res;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tint r;\n\twhile (cin >> r, r)\n\t{\n\t\tvector<int> a = calc_required_level_to_rooms();\n\t\tvector<int> b = calc_required_level_to_rooms();\n\n\t\tint res = 1e9;\n\t\tfor (int i = min<int>(r, a.size() - 1); i >= 0 && r - i < b.size(); --i)\n\t\t\tmin_swap(res, a[i] + b[r - i]);\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\n\n#define fr first\n#define sc second\n#define pb push_back\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define rep1(i,x) for(ll i=1;i<=x;i++)\n#define rrep(i,x) for(ll i=x-1;i>=0;i--)\n#define rrep1(i,x) for(ll i=x;i>0;i--)\n\nstruct T{\n\tll l,y,x;\n\tbool operator<(const T& b)const{\n\t\treturn l<b.l;\n\t};\n\tbool operator>(const T& b)const{\n\t\treturn l>b.l;\n\t};\n};\nconst ll INF=0xfffffffffffffff;\nll R;\nll W1,W2,H1,H2;\nll X1,Y1,X2,Y2;\nll L1[500][500];\nll L2[500][500];\nll atu1[25000];\nll atu2[25000];\nll dp1[25000];//?¨???????????????¨?±?????????°\nll dp2[25000];\nll sz1,sz2;\nll vx[4]={1,0,-1,0};\nll vy[4]={0,1,0,-1};\nbool pushed[500][500];\nvoid solve(ll W,ll H,ll sx,ll sy,ll L[][500],ll *atu,ll *dp,ll& sz){\n\tauto ok = [&](ll y,ll x){\n\t\treturn 0<=x&&x<W&&0<=y&&y<H;\n\t};\n\tfill(atu,atu+25000,INF);\n\tmemset(pushed,0,sizeof(pushed));\n\tvector<ll> xs;\n\trep(i,H) rep(j,W){\n\t\txs.pb(L[i][j]);\n\t}\n\tsort(xs.begin(),xs.end());\n\txs.erase(unique(xs.begin(),xs.end()),xs.end());\n\tsz=xs.size();\n\trep(i,xs.size()) atu[i]=xs[i];\n\trep(i,H) rep(j,W){\n\t\tL[i][j]=lower_bound(xs.begin(),xs.end(),L[i][j])-xs.begin();\n\t}\n\tll kosu=0,now=0;\n\tpriority_queue<T,vector<T>,greater<T> > q;\n\tq.push(T{0,sy,sx});\n\tpushed[sy][sx]=1;\n\twhile(!q.empty()){\n\t\tT t=q.top();\n\t\tq.pop();\n\t\tnow=max(now,t.l);\n\t\tkosu++;\n\t\tdp[now]=kosu;\n\t\trep(i,4){\n\t\t\tll ny=t.y+vy[i];\n\t\t\tll nx=t.x+vx[i];\n\t\t\tif(ok(ny,nx)&&!pushed[ny][nx]){\n\t\t\t\tq.push(T{L[ny][nx],ny,nx});\n\t\t\t\tpushed[ny][nx]=1;\n\t\t\t}\n\t\t}\n\t}\n\trep1(i,sz-1) if(dp[i]<dp[i-1]){\n\t\tdp[i]=dp[i-1];\n\t}\n\treturn;\n}\n\nint main()\n{while(1){\n\tcin>>R;\n\tif(!R) break;\n\tmemset(dp1,0,sizeof(dp1));\n\tmemset(dp2,0,sizeof(dp2));\n\tcin>>W1>>H1>>X1>>Y1;\n\tX1--;\n\tY1--;\n\trep(i,H1) rep(j,W1) cin>>L1[i][j];\n\tsolve(W1,H1,X1,Y1,L1,atu1,dp1,sz1);\n\tcin>>W2>>H2>>X2>>Y2;\n\tX2--;\n\tY2--;\n\trep(i,H2) rep(j,W2) cin>>L2[i][j];\n\tsolve(W2,H2,X2,Y2,L2,atu2,dp2,sz2);\n\tll ans=atu2[lower_bound(dp2,dp2+sz2,R)-dp2];\n\trep(i,sz1){\n\t\tif(dp1[i]>=R) ans=min(ans,atu1[i]);\n\t\telse ans=min(ans,atu1[i]+atu2[lower_bound(dp2,dp2+sz2,R-dp1[i])-dp2]);\n\t}\n\tcout<<ans<<endl;\n}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define all(a) a.begin(),a.end()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\n\nconst int inf = 1e9;\n\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, -1, 0, 1};\n\nint R;\nint W[2], H[2];\nint X[2], Y[2];\nint A[2][502][502];\n\nbool used[502][502];\n\nvpii data[2];\n\nvoid bfs(int num)\n{\n\ttypedef pair<int, pii> Data;\n\tmemset(used, false, sizeof(used));\n\n\tpriority_queue<Data> q;\n\n\tq.push(Data(-1, pii(Y[num], X[num])));\n\tused[Y[num]][X[num]] = true;\n\n\tif (num == 0) {\n\t\tdata[num].PB(pii(1, 0));\n\t} else {\n\t\tdata[num].PB(pii(0, 0));\n\t\tdata[num].PB(pii(0, 1));\n\t}\n\n\tint ma = 1;\n\tint cnt = 0;\n\tint hoge = 0;\n\n\twhile (q.size()) {\n\t\tData p = q.top(); q.pop();\n\n\t\tint cur = -p.fst;\n\n\t\tif (ma < cur) {\n\t\t\tif (num == 0) {\n\t\t\t\tdata[num].back().scd = cnt;\n\t\t\t} else {\n\t\t\t\tdata[num].back().fst = cnt;\n\t\t\t}\n\n\t\t\tma = cur;\n\n\t\t\tif (num == 0) {\n\t\t\t\tdata[num].PB(pii(ma, 0));\n\t\t\t} else {\n\t\t\t\tdata[num].PB(pii(0, ma));\n\t\t\t}\n\t\t}\n\n\t\tcnt++;\n\n\t\trep(i, 4) {\n\t\t\tint ny = p.scd.fst + dy[i], nx = p.scd.scd + dx[i];\n\n\t\t\tif (ny < 0 || ny >= H[num] || nx < 0 || nx >= W[num] || used[ny][nx]) continue;\n\t\t\tused[ny][nx] = true;\n\n\t\t\tq.push(Data(-A[num][ny][nx], pii(ny, nx)));\n\t\t}\n\t}\n\n\tif (num == 0) {\n\t\tdata[num].back().scd = cnt;\n\t} else {\n\t\tdata[num].back().fst = cnt;\n\t}\n}\n\nsigned main()\n{\n\tomajinai;\n\n\twhile (cin >> R, R) {\n\t\tdata[0].clear();\n\t\tdata[1].clear();\n\n\t\trep(i, 2) {\n\t\t\tcin >> W[i] >> H[i] >> X[i] >> Y[i];\n\n\t\t\t--X[i], --Y[i];\n\n\t\t\trep(j, H[i]) rep(k, W[i]) {\n\t\t\t\tcin >> A[i][j][k];\n\t\t\t}\n\t\t}\n\n\t\tbfs(0);\n\t\tbfs(1);\n\n\t\tint mi = inf;\n\n\t\tdata[1].PB(pii(inf, inf));\n\n\t\trep(i, data[0].size()) {\n\t\t\tpii a = data[0][i];\n\n\t\t\tchmin(mi, a.fst + lower_bound(all(data[1]), pii(R - a.scd, -inf))->scd);\n\t\t}\n\n\t\tcout << mi << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <map>\n#include <cstring>\n \nusing namespace std;\nconst int FIELD_SIZE = 502 * 502; // 逡ェ蜈オ縺ョ縺溘ａ+2縺吶ｋ\nconst int FIELD_WIDTH = 502;\nint field[FIELD_SIZE];  // 菴懈・ュ逕ィ鬆伜沺\n \ntypedef struct LevelRoomRelation {\n    int level, room;    // 隱崎ィシ繝ャ繝吶Ν, 驛ィ螻区焚\n} LevelRoomRelation;\n \nint fill(int r, int p, multimap<int, int> *nexts){\n    int count = 1;\n    field[p] = 0;\n    if(field[p + 1] == 0){          // 騾夐℃貂医∩\n    }else if(field[p + 1] <= r){ // 縺昴&#65533;驛ィ螻九↓蜈・繧&#65533;     count += fill(r, p + 1, nexts);\n    }else{                          // 蠕後〒蜈・繧九Μ繧ケ繝医∈霑ス蜉&#65533;        nexts->insert(multimap<int, int>::value_type(field[p + 1], p + 1));\n    }\n    if(field[p - 1] == 0){          // 騾夐℃貂医∩\n    }else if(field[p - 1] <= r){ // 縺昴&#65533;驛ィ螻九↓蜈・繧&#65533;     count += fill(r, p - 1, nexts);\n    }else{                          // 蠕後〒蜈・繧九Μ繧ケ繝医∈霑ス蜉&#65533;        nexts->insert(multimap<int, int>::value_type(field[p - 1], p - 1));\n    }\n    if(field[p + FIELD_WIDTH] == 0){        // 騾夐℃貂医∩\n    }else if(field[p + FIELD_WIDTH] <= r){   // 縺昴&#65533;驛ィ螻九↓蜈・繧&#65533;     count += fill(r, p + FIELD_WIDTH, nexts);\n    }else{                                  // 蠕後〒蜈・繧九Μ繧ケ繝医∈霑ス蜉&#65533;        nexts->insert(multimap<int, int>::value_type(field[p + FIELD_WIDTH], p + FIELD_WIDTH));\n    }\n    if(field[p - FIELD_WIDTH] == 0){        // 騾夐℃貂医∩\n    }else if(field[p - FIELD_WIDTH] <= r){   // 縺昴&#65533;驛ィ螻九↓蜈・繧&#65533;     count += fill(r, p - FIELD_WIDTH, nexts);\n    }else{                                  // 蠕後〒蜈・繧九Μ繧ケ繝医∈霑ス蜉&#65533;        nexts->insert(multimap<int, int>::value_type(field[p - FIELD_WIDTH], p - FIELD_WIDTH));\n    }\n    return count;\n}\n \nvoid calculateLevel(int r, list<LevelRoomRelation> *answer){\n    // 蝠城。後&#65533;蜈・蜉&#65533;    int w, h, x, y;\n    scanf(\"%d%d%d%d\", &w, &h, &x, &y);\n    memset(field, 0, sizeof(int) * FIELD_SIZE);\n    for(int i = 1; i <= h; i++){\n        for(int j = 1; j <= w; j++){\n            scanf(\"%d\", &(field[i * FIELD_WIDTH + j]));\n        }\n    }\n    // 險育ョ励☆繧&#65533;  int currentLevel = 0, currentRoomCount = 0, remains = w * h;\n    multimap<int, int> nexts;\n    nexts.insert(multimap<int, int>::value_type(1, x + y * FIELD_WIDTH));\n    multimap<int, int>::iterator front = nexts.begin();\n    while(currentRoomCount < r && remains > 0){\n        while(front != nexts.end()){\n            currentLevel = field[(*front).second];\n            if(currentLevel != 0){ break; }\n            multimap<int, int>::iterator tmp = front;\n            front++;\n            nexts.erase(tmp);\n        }\n        while(front != nexts.end() && field[(*front).second] <= currentLevel){\n            if(field[(*front).second] != 0){    // 縺セ縺&#65533;&#65533;驕弱＠縺ヲ縺&#65533;↑縺&#65533;&#65533;蜷&#65533;               int fillResult = fill(currentLevel, (*front).second, &nexts);\n                currentRoomCount += fillResult;\n                remains -= fillResult;\n            }\n            multimap<int, int>::iterator tmp = front;\n            front++;\n            nexts.erase(tmp);\n        }\n        LevelRoomRelation lrr;\n        lrr.level = currentLevel;\n        lrr.room = currentRoomCount;\n        answer->push_back(lrr);\n        //cout << \"Level: \" << (lrr).level << \" / \" << \"Room: \" << (lrr).room << endl;\n    }\n}\n \nint main(){\n    while(true){\n        int r;\n        if(!~scanf(\"%d\", &r)){ break; }\n        if(r == 0){ break; }\n \n        LevelRoomRelation lrr;\n        lrr.level = 0;\n        lrr.room = 0;\n \n        list<LevelRoomRelation> office1;\n        calculateLevel(r, &office1);\n        office1.insert(office1.begin(), lrr);\n        {\n//          cout << \"Office1 dump:\" << endl;\n            list<LevelRoomRelation>::iterator it = office1.begin();\n            while(it != office1.end()){\n//              cout << \"Level: \" << (*it).level << \" / \" << \"Room: \" << (*it).room << endl;\n                it++;\n            }\n        }\n        list<LevelRoomRelation> office2;\n        calculateLevel(r, &office2);\n        office2.insert(office2.begin(), lrr);\n        {\n//          cout << \"Office2 dump:\" << endl;\n            list<LevelRoomRelation>::iterator it = office2.begin();\n            while(it != office2.end()){\n//              cout << \"Level: \" << (*it).level << \" / \" << \"Room: \" << (*it).room << endl;\n                it++;\n            }\n        }\n \n        int minLevel = 0x7fffffff;\n        list<LevelRoomRelation>::iterator it1 = office1.begin(), it2 = office2.end();\n        int level2, level1 = 0;\n        int roomCount2, roomCount1 = 0, roomCount;\n        while(true){\n            if(it2 == office2.begin()){\n                if(it1 == office1.end()){ break; }\n            }else{\n                it2--;\n            }\n            level2 = (*it2).level;\n            roomCount2 = (*it2).room;\n            roomCount = roomCount2 + roomCount1;\n            while(it1 != office1.end() && roomCount < r){\n                roomCount1 = (*it1).room;\n                roomCount = roomCount2 + roomCount1;\n                level1 = (*it1).level;\n                it1++;\n            }\n//          cout << \"office1: \" << level1 << \" / office2: \" << level2 << endl;\n            if(minLevel > (level2 + level1)){\n                minLevel = level2 + level1;\n            }\n        }\n        cout << minLevel << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define reps(i,j,k) for(int i=j;i<=k;i++)\n#define HOGE -9\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\n\tint w,h,r,d[500][500],ex,ey,ans;\n\tint m[500][500];\nint main(){\n\tfor(;;){\n\t\tscanf(\"%d\",&r);\n\t\tif(r==0)break;\n\t\tvector<pii> cost[2];\n\t\trep(k,2){\n\t\t\tvector<int> c;\n\t\t\tscanf(\"%d%d%d%d\",&w,&h,&ex,&ey);\n\t\t\trep(i,h)rep(j,w){\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\",&t);\n\t\t\t\td[j][i] = t;\n\t\t\t\tc.push_back(t);\n\t\t\t}\n\t\t\tsort(c.begin(),c.end());\n\t\t\tc.erase(unique(c.begin(),c.end()),c.end());\n\t\t\trep(i,w)rep(j,h)m[i][j]=HOGE;\n\t\t\tint s=c.size(),cnt=1;\n\t\t\tconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\t\t\tm[--ex][--ey]=3;\n\t\t\trep(i,4)if(!(ex+dx[i]>=0 && ex+dx[i]<w && ey+dy[i]>=0 && ey+dy[i]<h))m[ex][ey]--;\n\t\t\tqueue<pii> q;\n\t\t\tcost[k].push_back(pii(0,0));\n\t\t\trep(l,s){\n\t\t\t\trep(i,w)rep(j,h){\n\t\t\t\t\tif(m[i][j]>0){\n\t\t\t\t\t\tq.push(pii(i,j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile(!q.empty()){\n\t\t\t\t\tint x=q.front().first,y=q.front().second;\n\t\t\t\t\tq.pop();\n\t\t\t\t\trep(i,4){\n\t\t\t\t\t\tint tx=x+dx[i],ty=y+dy[i];\n\t\t\t\t\t\tif(tx>=0 && tx<w && ty>=0 && ty<h){\n\t\t\t\t\t\t\tif(d[tx][ty]<=c[l]){\n\t\t\t\t\t\t\t\tif(m[tx][ty]==HOGE){\n\t\t\t\t\t\t\t\t\tm[tx][ty]=4;\n\t\t\t\t\t\t\t\t\trep(o,4)if(!(tx+dx[o]>=0 && tx+dx[o]<w && ty+dy[o]>=0 && ty+dy[o]<h) || d[tx+dx[o]][ty+dy[o]]<=c[l])m[tx][ty]--;\n\t\t\t\t\t\t\t\t\tq.push(pii(tx,ty));\n\t\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tm[x][y]=4;\n\t\t\t\t\trep(o,4)if(!(x+dx[o]>=0 && x+dx[o]<w && y+dy[o]>=0 && y+dy[o]<h) || d[x+dx[o]][y+dy[o]]<=c[l])m[x][y]--;\n\t\t\t\t}\n\t\t\t\tcost[k].push_back(pii(cnt,c[l]));\n\t\t\t}\n\t\t}\n\t\tans=2000;\n\t\tint s0=cost[0].size(),s1=cost[1].size();\n\t\trep(i,s0)rep(j,s1){\n\t\t\tif(cost[0][i].first+cost[1][j].first>=r)ans=min(ans,cost[0][i].second+cost[1][j].second);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<cassert>\n#include<queue>\n#include<map>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 501\nusing namespace std;\n\nstruct P\n{\n  int x,y;\n  P(int x=inf,int y=inf):x(x),y(y){}\n  bool operator < (const P& a)const\n  {\n    return (x!=a.x?x<a.x:y<a.y);\n  } \n};\n\nstruct Pox{\n  int x,y,level;\n  Pox(int x=inf,int y=inf,int level = inf,int index=inf):x(x),y(y),level(level){}\n  bool operator < (const Pox& a)const\n  {\n    return level > a.level;\n  }\n};\n\ntypedef pair<int,int> ii;\n\nint R;\nint room[2][MAX][MAX];\nint ex[2],ey[2];\nint h[2],w[2];\nvector<int> level[2];\nvector<ii> vec[2];\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n//int COST[2];\n//deque<P> deq[2];\nbool visited[2][MAX][MAX];\nint sum[2][MAX*MAX];\nmap<int,int> dict[2];\n\nvoid init()\n{\n  rep(i,2)\n    {\n      dict[i].clear();\n      level[i].clear();\n      vec[i].clear();\n      rep(j,MAX)rep(k,MAX)\n\t{\n\t  visited[i][j][k] = false;\n\t}\n      rep(j,MAX*MAX)sum[i][j] = 0;\n    }\n\n\n\n}\n\nvoid compute_cost(int sp)\n{\n  int N = level[sp].size();\n  int H = h[sp],W = w[sp];\n  priority_queue<Pox> Q;\n\n  rep(i,H)rep(j,W)visited[sp][i][j] = false,sum[sp][i*W+W] = 0;\n\n  Q.push(Pox(ex[sp],ey[sp],1));\n  //sum[sp][dict[sp][1]]++;\n  visited[sp][ey[sp]][ex[sp]] = true;\n  int dex = 1;\n  while(!Q.empty())\n    {\n      Pox pox = Q.top(); Q.pop();\n      //cout << \"add sum[\"<<sp<<\"][dict[\"<<sp<<\"][\"<<*lower_bound(all(level[sp]),pox.level)<<\"]] : \" << dict[sp][*lower_bound(all(level[sp]),pox.level)] << endl;\n      //sum[sp][dict[sp][*lower_bound(all(level[sp]),pox.level)]]++;\n      dex = max(dex,pox.level);\n      sum[sp][dict[sp][dex]]++;\n      //ut << \"pox = \" << pox.x << \",\" << pox.y << \" \" << pox.level << endl; \n\n      rep(i,4)\n\t{\n\t  int nx = pox.x + dx[i];\n\t  int ny = pox.y + dy[i];\n\t  if(!(0 <= nx && nx < W && 0 <= ny && ny < H))continue;\n\t  if(visited[sp][ny][nx])continue;\n\t  visited[sp][ny][nx] = true;\n\t  Q.push(Pox(nx,ny,room[sp][ny][nx]));\n\t}\n\n    }\n\n}\n\n/*\nint getCost(int sp,int l)\n{\n  if(room[sp][ey[sp]][ex[sp]] > l)return 0;\n\n  int H = h[sp], W = w[sp];\n\n  deque<P> store;\n  //cout << \"IN : level \" << l << endl;\n\n  while(!deq[sp].empty())\n    {\n      P p = deq[sp].front(); deq[sp].pop_front();\n\n      rep(i,4)\n\t{\n\t  int nx = p.x + dx[i];\n\t  int ny = p.y + dy[i];\n\t  if(!(0 <= nx && nx < W && 0 <= ny && ny < H))continue;\n\t  if(room[sp][ny][nx] > l)continue;\n\t  if(!visited[sp][ny][nx])\n\t    {\n\t      //cout << \"from \" << p.x << \",\" << p.y << \" goto \" << nx << \",\" << ny << \" level is \"<< room[sp][ny][nx] << endl;\n\t      visited[sp][ny][nx] = true;\n\t      deq[sp].push_back(P(nx,ny));\n\t      COST[sp]++;\n\t    }\n\t}\n\n      bool update = false;\n      rep(i,4)\n\t{\n\t  int nx = p.x + dx[i];\n\t  int ny = p.y + dy[i];\n\t  if(!(0 <= nx && nx < W && 0 <= ny && ny < H))continue;\n\t  if(visited[sp][ny][nx])continue;\n\t  update = true;\n\t  break;\n\t}      \n      if(update)store.push_back(p);\n    }\n  deq[sp] = store;\n  return COST[sp];\n}\n*/\n\nvoid compute()\n{\n  /*\n  rep(i,2)\n    {\n      COST[i] = 0;\n      deq[i].clear();\n      deq[i].push_back(P(ex[i],ey[i]));\n      visited[i][ey[i]][ex[i]] = true;\n      vec[i].push_back(ii(0,0));\n      rep(y,h[i])rep(x,w[i])visited[i][y][x] = false;\n\n      rep(j,level[i].size())\n\t{\n\t  int cost = getCost(i,level[i][j]);\n\t  vec[i].push_back(ii(cost,level[i][j]));\n\t}\n      sort(all(vec[i]));\n    }\n  */\n\n  rep(i,2)\n    {\n      compute_cost(i);\n      //cout << \"finish - \" << i << endl;\n      //cout << \"fsee sum ---- \"<< endl;\n      /*\n      rep(j,level[i].size())\n\t{\n\t  cout << j << \"-th \" << sum[i][j] << endl;\n\t}\n      */\n      REP(j,1,level[i].size())sum[i][j] += sum[i][j-1];\n      /*\n      cout << \"see sum ---- \"<< endl;\n      rep(j,level[i].size())\n\t{\n\t  cout << j << \"-th \" << sum[i][j] << endl;\n\t}\n      */\n      rep(j,level[i].size())vec[i].push_back(ii(sum[i][j],level[i][j]));\n    }\n  /*\n  rep(i,2)\n    {\n      rep(j,vec[i].size())\n\t{\n\t  cout << \"vec[\"<<i<<\"][\"<<j<<\"] = (\" << vec[i][j].first << \",\" << vec[i][j].second << \")\\n\";\n\t}\n    }\n  */\n\n  int minlevel = inf;\n  rep(i,vec[0].size())\n    {\n      int lvl = vec[0][i].second;\n      int cost = vec[0][i].first;\n      int request = R - cost;\n      if(request <= 0)\n\t{\n\t  minlevel = min(minlevel,lvl);\n\t  continue;\n\t}\n\n      if(lower_bound(all(vec[1]),ii(request,-1)) == vec[1].end())continue;\n      ii store = *lower_bound(all(vec[1]),ii(request,-1));\n      int nlvl = store.second;\n      int ncost = store.first;\n\n      minlevel = min(minlevel,lvl+nlvl);\n    }\n  cout << minlevel << endl;\n}\n\nint main()\n{\n  while(cin >> R,R)\n    {\n      init();\n      rep(i,2)\n\t{\n\t  dict[i].clear();\n\t  level[i].clear(),vec[i].clear();\n\t  cin >> w[i] >> h[i] >> ex[i] >> ey[i];\n\t  ex[i]--,ey[i]--;\n\t  rep(y,h[i])rep(x,w[i])cin >> room[i][y][x],level[i].push_back(room[i][y][x]);\n\t  sort(all(level[i]));\n\t  level[i].erase(unique(all(level[i])),level[i].end());\n\t  rep(j,level[i].size())dict[i][level[i][j]] = j;\n\t}\n      compute();\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<functional>\n#include<vector>\n#include<cstring>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\n\n#define T1 1000000LL\n#define T2 1000LL\n\nlong long W, H, X, Y, R;\nlong long x[1000][1000];\nlong long d[1000][1000];\nlong long p1, p2, p3;\nlong long y_1[1000000], y_2[1000000], cnt, cnt2, v, minx;\n\npriority_queue<long long, vector<long long>, greater<long long>> Q, S;\n\nint main() {\n\twhile (true) {\n\t\tcnt = 1; cnt2 = 1; minx = 1145141919810LL;\n\t\tmemset(x, 51, sizeof(x));\n\t\tmemset(d, 51, sizeof(d));\n\t\tcin >> R;\n\t\tif (R == 0) { break; }\n\t\tcin >> W >> H >> X >> Y;\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tscanf(\"%lld\",&x[i][j]);\n\t\t\t}\n\t\t}\n\t\td[Y][X] = 0;\n\t\tQ.push(Y*T2 + X);\n\t\twhile (!Q.empty()) {\n\t\t\tp1 = Q.top() / T1;\n\t\t\tp2 = (Q.top() / T2) % T2;\n\t\t\tp3 = Q.top() % T2;\n\t\t\tif (max(p1, x[p2 - 1][p3]) < d[p2 - 1][p3]) {\n\t\t\t\td[p2 - 1][p3] = max(p1, x[p2 - 1][p3]);\n\t\t\t\tS.push(d[p2 - 1][p3] * T1 + (p2 - 1)*T2 + p3);\n\t\t\t}\n\t\t\tif (max(p1, x[p2 + 1][p3]) < d[p2 + 1][p3]) {\n\t\t\t\td[p2 + 1][p3] = max(p1, x[p2 + 1][p3]);\n\t\t\t\tS.push(d[p2 + 1][p3] * T1 + (p2 + 1)*T2 + p3);\n\t\t\t}\n\t\t\tif (max(p1, x[p2][p3 - 1]) < d[p2][p3 - 1]) {\n\t\t\t\td[p2][p3 - 1] = max(p1, x[p2][p3 - 1]);\n\t\t\t\tS.push(d[p2][p3 - 1] * T1 + p2*T2 + (p3 - 1));\n\t\t\t}\n\t\t\tif (max(p1, x[p2][p3 + 1]) < d[p2][p3 + 1]) {\n\t\t\t\td[p2][p3 + 1] = max(p1, x[p2][p3 + 1]);\n\t\t\t\tS.push(d[p2][p3 + 1] * T1 + p2*T2 + (p3 + 1));\n\t\t\t}\n\t\t\tQ.pop();\n\t\t\twhile (!S.empty()) {\n\t\t\t\tQ.push(S.top());\n\t\t\t\tS.pop();\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\ty_1[cnt] = d[i][j];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tmemset(x, 51, sizeof(x));\n\t\tmemset(d, 51, sizeof(d));\n\t\tcin >> W >> H >> X >> Y;\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tscanf(\"%lld\",&x[i][j]);\n\t\t\t}\n\t\t}\n\t\td[Y][X] = 0;\n\t\tQ.push(Y*T2 + X);\n\t\twhile (!Q.empty()) {\n\t\t\tp1 = Q.top() / T1;\n\t\t\tp2 = (Q.top() / T2) % T2;\n\t\t\tp3 = Q.top() % T2;\n\t\t\tif (max(p1, x[p2 - 1][p3]) < d[p2 - 1][p3]) {\n\t\t\t\td[p2 - 1][p3] = max(p1, x[p2 - 1][p3]);\n\t\t\t\tS.push(d[p2 - 1][p3] * T1 + (p2 - 1)*T2 + p3);\n\t\t\t}\n\t\t\tif (max(p1, x[p2 + 1][p3]) < d[p2 + 1][p3]) {\n\t\t\t\td[p2 + 1][p3] = max(p1, x[p2 + 1][p3]);\n\t\t\t\tS.push(d[p2 + 1][p3] * T1 + (p2 + 1)*T2 + p3);\n\t\t\t}\n\t\t\tif (max(p1, x[p2][p3 - 1]) < d[p2][p3 - 1]) {\n\t\t\t\td[p2][p3 - 1] = max(p1, x[p2][p3 - 1]);\n\t\t\t\tS.push(d[p2][p3 - 1] * T1 + p2*T2 + (p3 - 1));\n\t\t\t}\n\t\t\tif (max(p1, x[p2][p3 + 1]) < d[p2][p3 + 1]) {\n\t\t\t\td[p2][p3 + 1] = max(p1, x[p2][p3 + 1]);\n\t\t\t\tS.push(d[p2][p3 + 1] * T1 + p2*T2 + (p3 + 1));\n\t\t\t}\n\t\t\tQ.pop();\n\t\t\twhile (!S.empty()) {\n\t\t\t\tQ.push(S.top());\n\t\t\t\tS.pop();\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\ty_2[cnt2] = d[i][j];\n\t\t\t\tcnt2++;\n\t\t\t}\n\t\t}\n\n\t\tsort(y_1, y_1 + cnt);\n\t\tsort(y_2, y_2 + cnt2);\n\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\tv = R - i;\n\t\t\tif (v >= 0 && v < cnt2) {\n\t\t\t\tminx = min(minx, y_1[i] + y_2[v]);\n\t\t\t}\n\t\t}\n\t\tcout << minx << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n//これは、頭が悪く競プロが世界で一番できないHIR180が\n//IOI2014日本代表になるまでのN日間の記録である。\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define f first\n#define s second\n#define rep(i,x) for(int i=0;i<x;i++)\nint s[250005][2];\nint f[505][505];\nbool used[505][505];\nint main()\n{\n\tsrand((unsigned int)time(NULL));\n\twhile(1)\n\t{\n\t\tint lim;\n\t\tscanf(\"%d\",&lim); if(!lim) return 0;\n\t\tfor(int q=0;q<2;q++)\n\t\t{\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tint cnt=1;\n\t\t\tint w,h,x,y; scanf(\"%d%d%d%d\",&w,&h,&x,&y);\n\t\t\tfor(int i=1;i<=h;i++)for(int j=1;j<=w;j++) scanf(\"%d\",&f[i][j]);\n\t\t\tpriority_queue<P1,vector<P1>,greater<P1> >que;\n\t\t\tque.push(mp(f[y][x],mp(y,x)));\n\t\t\tfor(int i=1;i<=lim;i++) s[i][q]=INF;\n\t\t\twhile(!que.empty())\n\t\t\t{\n\t\t\t\tint v=que.top().f;\n\t\t\t\tint x=que.top().s.f; int y=que.top().s.s;\n\t\t\t\tque.pop();\n\t\t\t\tif(used[x][y]) continue;\n\t\t\t\tused[x][y]=true;\n\t\t\t\ts[cnt][q]=max(s[cnt-1][q],v); cnt++;\n\t\t\t\tint dx[4]={0,1,0,-1};\n\t\t\t\tint dy[4]={1,0,-1,0};\n\t\t\t\tfor(int i=0;i<4;i++)\n\t\t\t\t{\n\t\t\t\t\tint nx=x+dx[i];\n\t\t\t\t\tint ny=y+dy[i];\n\t\t\t\t\tif(!(1<=nx && nx<=h)) continue;\n\t\t\t\t\tif(!(1<=ny && ny<=w)) continue;\n\t\t\t\t\tif(used[nx][ny]) continue;\n\t\t\t\t\tque.push(mp(f[nx][ny],mp(nx,ny)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=INF;\n\t\tfor(int i=0;i<=lim;i++)\n\t\t{\n\t\t\tret=min(ret,s[i][0]+s[lim-i][1]);\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define PB push_back\n#define ALL(V) V.begin(), V.end()\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, int> ppiii;\n\nconstexpr int INF = 1LL<<60;\nconstexpr int MOD = 1000000007;\n//constexpr int MAX_N = 100005;\nconstexpr int dx[] = {-1, 0, 1, 0};\nconstexpr int dy[] = {0, -1, 0, 1};\n\nint r, w[2], h[2], ex[2], ey[2], fld[2][505][505], d[2][505][505];\n\nvector<pii> lvs[2];\nvector<int> templvs[2];\n\nvoid Dijkstra(int k) {\n    fill(d[k][0], d[k][505], INF);\n    priority_queue<pipii, vector<pipii>, greater<pipii>> pq;\n    d[k][ex[k]][ey[k]] = 1;\n    pq.push({1, {ex[k], ey[k]}});\n\n    while (pq.size()) {\n        pipii p = pq.top();\n        pq.pop();\n        int x = p.second.first, y = p.second.second;\n        if (d[k][x][y] < p.first) continue;\n\n        for (int i = 0; i < 4; ++i) {\n            int tx = x + dx[i], ty = y + dy[i], lv = max(p.first, fld[k][tx][ty]);\n            if (fld[k][tx][ty] == 0) continue;\n            if (d[k][tx][ty] <= lv) continue;\n            d[k][tx][ty] = lv;\n            pq.push({lv, {tx, ty}});\n        }\n    }\n}\n\nbool Solve() {\n    cin >> r;\n    if (r == 0) return false;\n    memset(fld, 0, sizeof(fld));\n\n    for (int i = 0; i < 2; ++i) {\n        cin >> w[i] >> h[i] >> ex[i] >> ey[i]; \n\n        for (int y = 1; y <= h[i]; ++y) {\n            for (int x = 1; x <= w[i]; ++x) {\n                cin >> fld[i][x][y];\n            }\n        }\n    }\n\n    Dijkstra(0);\n    Dijkstra(1);\n\n    for (int i = 0; i < 2; ++i) {\n        lvs[i].clear();\n        templvs[i].clear();\n\n        for (int y = 1; y <= h[i]; ++y) {\n            for (int x = 1; x <= w[i]; ++x) {\n                templvs[i].PB(d[i][x][y]);\n            }\n        }\n\n        sort(ALL(templvs[i]));\n        templvs[i].PB(INF);\n        lvs[i].PB({0, 0});\n        for (int j = 0; j < templvs[i].size(); ++j) {\n            for (int c = 1; j + c <= templvs[i].size(); ++c) {\n                if (templvs[i][j + c - 1] == templvs[i][j]) continue;\n                c--;\n                lvs[i].PB({templvs[i][j], c + lvs[i][lvs[i].size() - 1].second});\n                j += c - 1;\n                break;\n            }\n        }\n        lvs[i].PB({INF, INF});\n    }\n\n    int ans = INF;\n    for (int i = 0; i < lvs[0].size(); ++i) {\n        int cnt = lvs[0][i].second;\n        if (cnt + w[1] * h[1] < r) continue;\n\n        int s = 0, t = lvs[1].size() - 1;\n        while (1 < t - s) {\n            int mid = (s + t) / 2;\n            if (cnt + lvs[1][mid].second < r) {\n                s = mid + 1;\n            } else {\n                t = mid;\n            }\n        }\n        ans = min(ans, lvs[0][i].first + min(lvs[1][s].first, lvs[1][s + 1].first));\n    }\n\n    cout << ans << endl;\n\n    return true;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while(Solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\nconst int MAX = 100000000;\nconst int dx[4] = {0, 0, 1, -1};\nconst int dy[4] = {-1, 1, 0, 0};\n\nstruct state {\n\tint x, y, level;\n\tstate(int x, int y, int level):x(x), y(y), level(level){}\n\tbool operator>(const state& s) const {\n\t\treturn level > s.level;\n\t}\n};\n\nmap<int, int> nextOffice() {\n\tint w, h, x, y;\n\tcin >> w >> h >> x >> y;\n\t--x;\n\t--y;\n\n\tvector<vector<int> > field(h, vector<int>(w));\n\tfor(int i = 0; i < h; ++i)\n\t\tfor(int j = 0; j < w; ++j)\n\t\t\tcin >> field[i][j];\n\n\tvector<vector<bool> > visited(h, vector<bool>(w, false));\n\tpriority_queue<state, vector<state>, greater<state> > que;\n\tque.push(state(x, y, field[y][x]));\n\n\twhile(!que.empty()) {\n\t\tstate s = que.top();\n\t\tque.pop();\n\n\t\tvisited[s.y][s.x] = true;\n\n\t\tfor(int i = 0; i < 4; ++i) {\n\t\t\tint nx = s.x + dx[i], ny = s.y + dy[i];\n\t\t\tif(nx < 0 || ny < 0 || nx >= w || ny >= h || visited[ny][nx])\n\t\t\t\tcontinue;\n\n\t\t\tchmax(field[ny][nx], field[s.y][s.x]);\n\t\t\tque.push(state(nx, ny, field[ny][nx]));\n\t\t}\n\t}\n\n\tmap<int, int> res;\n\tres.insert(make_pair(0, 0));\n\tfor(int i = 0; i < h; ++i)\n\t\tfor(int j = 0; j < w; ++j)\n\t\t\tres[field[i][j]] += 1;\n\n\tfor(map<int, int>::iterator it = res.begin(); it != res.end(); ++it) {\n\t\tmap<int, int>::iterator next = it;\n\t\t++next;\n\n\t\tif(next != res.end())\n\t\t\tnext->second += it->second;\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int r; cin >> r, r;) {\n\t\tmap<int, int> office1 = nextOffice();\n\t\tmap<int, int> office2 = nextOffice();\n\n\t\tint ans = MAX * 2;\n\t\tmap<int, int>::const_iterator it = office1.begin();\n\t\tmap<int, int>::const_reverse_iterator it2 = office2.rbegin();\n\t\tfor(; it != office1.end(); ++it) {\n\t\t\twhile(it->second + it2->second >= r) {\n\t\t\t\tchmin(ans, it->first + it2->first);\n\t\t\t\tif(++it2 == office2.rend())\n\t\t\t\t\tgoto finish;\n\t\t\t}\n\t\t}\n\n\tfinish:;\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pint;\ntypedef pair<ll, int> P;\n//typedef tuple<int,int,int> T;\nll INFL = 1000000000000000010;//10^18 = 2^60\nint INF = 2147483600;//10^9\nll MOD  = 1000000007;\nint solve(){\n    vector<int> dy(4);\n    vector<int> dx(4);\n    dy.at(0) = 0;\n    dy.at(1) = 0;\n    dy.at(2) = 1;\n    dy.at(3) = -1;\n    dx.at(0) = 1;\n    dx.at(1) = -1;\n    dx.at(2) = 0;\n    dx.at(3) = 0;\n    \n    int R;\n    cin >> R;\n    if(R == 0)return 0;\n    int H1,W1,X1,Y1;\n    cin >> W1 >> H1 >> X1 >> Y1;\n    X1--;\n    Y1--;\n    vector<vector<ll> > mp1(H1, vector<ll>(W1));\n    vector<vector<ll> > d1(H1, vector<ll>(W1, INFL));\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            cin >> mp1[i][j];\n        }\n    }\n    \n    d1[Y1][X1] = 1;\n    priority_queue<pair<ll, pair<int, int>>> pque1;\n    pque1.push({1, {Y1, X1}});\n    \n    while(!pque1.empty()){\n        ll c;\n        int y,x;\n        c = pque1.top().first;\n        y = pque1.top().second.first;\n        x = pque1.top().second.second;\n        pque1.pop();\n        if(c > d1[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H1 && 0 <= nx && nx < W1){\n                if(d1[ny][nx] > d1[y][x]){\n                    if(d1[y][x] > mp1[ny][nx]){\n                        d1[ny][nx] = d1[y][x];\n                    }else{\n                        d1[ny][nx] = mp1[ny][nx];\n                    }\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }else if(d1[ny][nx] > d1[y][x]){\n                    d1[ny][nx] = mp1[ny][nx];\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    int H2,W2,X2,Y2;\n    cin >> W2 >> H2 >> X2 >> Y2;\n    X2--;\n    Y2--;\n    vector<vector<ll> > mp2(H2, vector<ll>(W2));\n    vector<vector<ll> > d2(H2, vector<ll>(W2, INFL));\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            cin >> mp2[i][j];\n        }\n    }\n    \n    d2[Y2][X2] = 1;\n    priority_queue<pair<ll, pair<int, int>>> pque2;\n    pque2.push({1, {Y2, X2}});\n    \n    while(!pque2.empty()){\n        ll c;\n        int y,x;\n        c = pque2.top().first;\n        y = pque2.top().second.first;\n        x = pque2.top().second.second;\n        pque2.pop();\n        if(c > d2[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H2 && 0 <= nx && nx < W2){\n                if(d2[ny][nx] > d2[y][x]){\n                    if(d2[y][x] > mp2[ny][nx]){\n                        d2[ny][nx] = d2[y][x];\n                    }else{\n                        d2[ny][nx] = mp2[ny][nx];\n                    }\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }else if(d2[ny][nx] > d2[y][x]){\n                    d2[ny][nx] = mp2[ny][nx];\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    vector<pair<ll,int> > O1(0);\n    vector<ll> COST1(0);\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            COST1.push_back(d1[i][j]);\n        }\n    }\n    sort(COST1.begin(), COST1.end());\n    COST1.push_back(INFL);\n    ll ad1 = COST1.at(0);\n    int cnt = 0;\n    for(int i = 0; i < COST1.size(); i++){\n        if(ad1 == COST1.at(i)){\n            cnt++;\n        }else{\n            O1.push_back({ad1, cnt});\n            ad1 = COST1.at(i);\n            cnt++;\n        }\n    }\n    \n    vector<pair<ll,int> > O2(1);\n    O2.at(0).first = 0;\n    O2.at(0).second = 0;\n    vector<ll> COST2(0);\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            COST2.push_back(d2[i][j]);\n        }\n    }\n    sort(COST2.begin(), COST2.end());\n    COST2.push_back(INFL);\n    ll ad2 = COST2.at(0);\n    cnt = 0;\n    for(int i = 0; i < COST2.size(); i++){\n        if(ad2 == COST2.at(i)){\n            cnt++;\n        }else{\n            O2.push_back({ad2, cnt});\n            ad2 = COST2.at(i);\n            cnt++;\n        }\n    }\n    \n    ll ans = INFL;\n    for(int i = 0; i < O1.size(); i++){\n        ll cost = O1.at(i).first;\n        int rest = R - O1.at(i).second;\n        \n        if(rest > O2.at(O2.size()-1).second) continue;\n        int left = -1, right = O2.size();\n        int mid;\n        while(right - left > 1){\n            mid = (left + right) / 2;\n            if(O2.at(mid).second >= rest){\n                right = mid;\n            }else{\n                left = mid;\n            }\n        }\n        cost += O2.at(right).first;\n        ans = min(ans, cost);\n        \n    }\n    \n    cout << ans << endl;\n    \n    solve();\n    return 0;\n}\n\nint main(void){\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 160000\n#define B 100\n#define dpb push_back\n#define fi first\n#define se second\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst int inf = 1e9;\nconst ll INF = 1e18;\nconst int size = 504;\n//__gcd(a,b), __builtin_popcount(a);\n\nint r, h1, w1, X1, Y1, h2, w2, X2, Y2;\nint dy[4] = {0, 0, -1, 1}, dx[4] = {-1, 1, 0, 0};\nint a[size][size], b[size][size];\nint an[250010], bn[250010];\n\nint to_n(int y, int x, int w){\n\treturn (w*(y-1)+x);\n}\nint to_y(int n, int w){\n\treturn ((n-1)/w+1);\n}\nint to_x(int n, int w){\n\treturn (n-(to_y(n, w)-1)*w);\n}\nint main(){\n\twhile(1){\n\tfill((int*)a, (int*)(a+size), inf);\n\tfill((int*)b, (int*)(b+size), inf);\n\tfill(an, an+250010, 0);\n\tfill(bn, bn+250010, 0);\n\tscanf(\"%d\", &r);\n\tif(!r)break;\n\tscanf(\"%d%d%d%d\", &w1, &h1, &X1, &Y1);\n\trrep(i,h1)rrep(j,w1)scanf(\"%d\", &a[i][j]);\n\tscanf(\"%d%d%d%d\", &w2, &h2, &X2, &Y2);\n\trrep(i,h2)rrep(j,w2)scanf(\"%d\", &b[i][j]);\n\t\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tq.push(P(a[Y1][X1], to_n(Y1, X1,w1)));\n\ta[Y1][X1] = inf;\n\tint acnt = 1;\n\twhile(!q.empty()){\n\t\tP p = q.top();q.pop();\n\t\tint y = to_y(p.se, w1), x = to_x(p.se, w1);\n\t\tan[acnt++] = p.fi;\n\t\tfor(int i = 0;i < 4;i++){\n\t\t\tint yy = y+dy[i], xx = x+dx[i];\n\t\t\tif(a[yy][xx] != inf){\n\t\t\t\tq.push(P(a[yy][xx], to_n(yy, xx,w1)));\n\t\t\t\ta[yy][xx] = inf;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tq.push(P(b[Y2][X2], to_n(Y2, X2,w2)));\n\tb[Y2][X2] = inf;\n\tint bcnt = 1;\n\twhile(!q.empty()){\n\t\tP p = q.top();q.pop();\n\t\tint y = to_y(p.se, w2), x = to_x(p.se, w2);\n\t\tbn[bcnt++] = p.fi;\n\t\tfor(int i = 0;i < 4;i++){\n\t\t\tint yy = y+dy[i], xx = x+dx[i];\n\t\t\tif(b[yy][xx] != inf){\n\t\t\t\tq.push(P(b[yy][xx], to_n(yy, xx,w2)));\n\t\t\t\tb[yy][xx] = inf;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint t1 = 0, t2 = 0;\n\tfor(int i = 0;i < acnt;i++){\n\t\tt1 = max(t1, an[i]);\n\t\tan[i] = t1;\n\t}\n\tfor(int i = 0;i < bcnt;i++){\n\t\tt2 = max(t2, bn[i]);\n\t\tbn[i] = t2;\n\t}\n\t\n\tint ans = inf;\n\tfor(int i = 0;i < acnt;i++){\n\t\tif(r-i < bcnt)ans = min(ans, an[i]+bn[r-i]);\n\t\tif(r == i)break;\n\t}\n\t\n\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pint;\ntypedef pair<ll, int> P;\n//typedef tuple<int,int,int> T;\nll INFL = 1000000000000000010;//10^18 = 2^60\nint INF = 2147483600;//10^9\nll MOD  = 1000000007;\nvector<int> dy = {1,-1,0,0};\nvector<int> dx = {0,0,1,-1};\nvector<ll> Ans(0);\nvector<vector<ll>> mp1(510, vector<ll>(510));\nvector<vector<ll>> mp2(510, vector<ll>(510));\nvector<vector<ll>> d1(510, vector<ll>(510));\nvector<vector<ll>> d2(510, vector<ll>(510));\nint solve(){\n    int R;\n    cin >> R;\n    if(R == 0)return 0;\n    int H1,W1,X1,Y1;\n    cin >> W1 >> H1 >> X1 >> Y1;\n    X1--;\n    Y1--;\n    for(int i = 0; i < H1; i++) for(int j = 0; j < W1; j++) d1[i][j] = INFL;\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            cin >> mp1[i][j];\n        }\n    }\n    \n    d1[Y1][X1] = 1;\n    priority_queue<pair<ll, pair<int, int>>> pque1;\n    pque1.push({1, {Y1, X1}});\n    \n    while(!pque1.empty()){\n        ll c;\n        int y,x;\n        c = pque1.top().first;\n        y = pque1.top().second.first;\n        x = pque1.top().second.second;\n        pque1.pop();\n        if(c > d1[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H1 && 0 <= nx && nx < W1){\n                if(d1[ny][nx] > d1[y][x]){\n                    if(d1[y][x] > mp1[ny][nx]){\n                        d1[ny][nx] = d1[y][x];\n                    }else{\n                        d1[ny][nx] = mp1[ny][nx];\n                    }\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }else if(d1[ny][nx] > d1[y][x]){\n                    d1[ny][nx] = mp1[ny][nx];\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    int H2,W2,X2,Y2;\n    cin >> W2 >> H2 >> X2 >> Y2;\n    X2--;\n    Y2--;\n    for(int i = 0; i < H2; i++) for(int j = 0; j < W2; j++) d2[i][j] = INFL;\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            cin >> mp2[i][j];\n        }\n    }\n    \n    d2[Y2][X2] = 1;\n    priority_queue<pair<ll, pair<int, int>>> pque2;\n    pque2.push({1, {Y2, X2}});\n    \n    while(!pque2.empty()){\n        ll c;\n        int y,x;\n        c = pque2.top().first;\n        y = pque2.top().second.first;\n        x = pque2.top().second.second;\n        pque2.pop();\n        if(c > d2[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H2 && 0 <= nx && nx < W2){\n                if(d2[ny][nx] > d2[y][x]){\n                    if(d2[y][x] > mp2[ny][nx]){\n                        d2[ny][nx] = d2[y][x];\n                    }else{\n                        d2[ny][nx] = mp2[ny][nx];\n                    }\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }else if(d2[ny][nx] > d2[y][x]){\n                    d2[ny][nx] = mp2[ny][nx];\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    vector<pair<ll,int>> O1(0);\n    vector<ll> COST1(0);\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            COST1.push_back(d1[i][j]);\n        }\n    }\n    sort(COST1.begin(), COST1.end());\n    COST1.push_back(INFL);\n    ll ad1 = COST1.at(0);\n    for(int i = 0; i < COST1.size(); i++){\n        if(ad1 == COST1.at(i)){\n        }else{\n            O1.push_back({ad1, i});\n            ad1 = COST1.at(i);\n        }\n    }\n    \n    vector<pair<ll,int>> O2(1);\n    O2.at(0).first = 0;\n    O2.at(0).second = 0;\n    vector<ll> COST2(0);\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            COST2.push_back(d2[i][j]);\n        }\n    }\n    sort(COST2.begin(), COST2.end());\n    COST2.push_back(INFL);\n    ll ad2 = COST2.at(0);\n    for(int i = 0; i < COST2.size(); i++){\n        if(ad2 == COST2.at(i)){\n        }else{\n            O2.push_back({ad2, i});\n            ad2 = COST2.at(i);\n        }\n    }\n    \n    \n    ll ans = INFL;\n    int right = -1;\n    for(int i = 0; i < O1.size(); i++){\n        ll cost = O1.at(i).first;\n        int rest = R - O1.at(i).second;\n        \n        if(rest > O2.at(O2.size()-1).second) continue;\n        int left = -1;\n        if(right == -1){\n            right = O2.size();\n        }\n        int mid;\n        while(right - left > 1){\n            mid = (left + right) / 2;\n            if(O2.at(mid).second >= rest){\n                right = mid;\n            }else{\n                left = mid;\n            }\n        }\n        cost += O2.at(right).first;\n        ans = min(ans, cost);\n    }\n    \n    Ans.push_back(ans);\n    solve();\n    return 0;\n}\n\nint main(void){\n    solve();\n    for(int i = 0; i < Ans.size(); i++){\n        cout << Ans.at(i) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint w,h,x,y,a[505][505],b[505][505],c[505][505];\n\npair<int,int> make_P(int ma,int mb){pair<int,int> ret; ret.first=ma; ret.second=mb; return ret;}\n\npair<int,pair<int,int>> make_PP(int ma,pair<int,int> mb){pair<int,pair<int,int>> ret; ret.first=ma; ret.second=mb; return ret;}\n\nbool f(pair<int,pair<int,int>> fx,pair<int,pair<int,int>> fy){return fx.first<=fy.first;}\n\nvoid ww(int wx,int wy){\n\tc[wx][wy]=1;\n\tif(b[wx][wy+1]==1&&c[wx][wy+1]==0)ww(wx,wy+1);\n\tif(b[wx][wy-1]==1&&c[wx][wy-1]==0)ww(wx,wy-1);\n\tif(b[wx+1][wy]==1&&c[wx+1][wy]==0)ww(wx+1,wy);\n\tif(b[wx-1][wy]==1&&c[wx-1][wy]==0)ww(wx-1,wy);\n}\n\nvector<int> els(vector<int> vp){\n\tvector<int> ret;\n\tint s=vp.size();\n\tret.push_back(vp[0]);\n\tfor(int i=1;i<s;i++){\n\t\tif(vp[i]!=vp[i-1])ret.push_back(vp[i]);\n\t}\n\treturn ret;\n}\n\nvector<pair<int,int>> office(){\n\tfor(int i=0;i<505;i++)for(int j=0;j<505;j++){b[i][j]=0; c[i][j]=0;}\n\tvector<pair<int,pair<int,int>>> v;\n\tfor(int i=1;i<=h;i++)for(int j=1;j<=h;j++)v.push_back(make_PP(a[i][j],make_P(i,j)));\n\tsort(v.begin(),v.end(),f);\n\t//v=els(v);\n\tvector<pair<int,int>> ret;\n\tret.push_back(make_P(0,0));\n\tint s=v.size();\n\tb[x][y]=1; c[x][y]=1;\n\tfor(int i=0;i<s;i++){\n\t\t/*for(int j=1;j<=h;j++)for(int k=1;k<=w;k++){\n\t\t\tif(a[j][k]==v[i]){\n\t\t\t\tb[j][k]=1;\n\t\t\t\tif(c[j][k+1]+c[j][k-1]+c[j+1][k]+c[j-1][k]!=0)ww(j,k);\n\t\t\t}\n\t\t}*/\n\t\tb[v[i].second.first][v[i].second.second]=1;\n\t\tif(c[v[i].second.first][v[i].second.second+1]+c[v[i].second.first][v[i].second.second-1]+c[v[i].second.first+1][v[i].second.second]+c[v[i].second.first-1][v[i].second.second]!=0)ww(v[i].second.first,v[i].second.second);\n\t\tint sum=0;\n\t\tfor(int j=1;j<=h;j++)for(int k=1;k<=w;k++)sum+=c[j][k];\n\t\tret.push_back(make_P(v[i].first,sum));\n\t}\n\treturn ret;\n}\n\nint main(){\nwhile(1){\n\tint r,s[2];\n\tscanf(\"%d\",&r);\n\tif(r==0)break;\n\tvector<pair<int,int>> vvp[2];\n\tfor(int i=0;i<=1;i++){\n\t\tfor(int k=0;k<505;k++)for(int j=0;j<505;j++)a[k][j]=0;\n\t\tscanf(\"%d%d%d%d\",&w,&h,&x,&y);\n\t\tfor(int j=1;j<=h;j++)for(int k=1;k<=w;k++)scanf(\"%d\",&a[j][k]);\n\t\tvvp[i]=office();\n\t\ts[i]=vvp[i].size();\n\t}\n\tint n=s[1]-1,ret=200000000;\n\tfor(int i=0;i<s[0];i++){\n\t\tif(n!=0)while(vvp[0][i].second+vvp[1][n-1].second>=r){n--; if(n==0)break;}\n\t\tif(vvp[0][i].second+vvp[1][n].second>=r)ret=min(ret,vvp[0][i].first+vvp[1][n].first);\n\t}\n\tprintf(\"%d\\n\",ret);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<vector>\n#include<iostream>\n#include<algorithm>\n\n#define\tmp\tmake_pair\n#define\tpb\tpush_back\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint main(){\n\tfor(int r;cin>>r,r;){\n\t\tint w1,h1,x1,y1;\tcin>>w1>>h1>>x1>>y1;\n\t\tx1--,y1--;\n\t\tstatic int room1[500][500];\n\t\tfor(int i=0;i<h1;i++)for(int j=0;j<w1;j++)\tcin>>room1[i][j];\n\t\tint w2,h2,x2,y2;\tcin>>w2>>h2>>x2>>y2;\n\t\tx2--,y2--;\n\t\tstatic int room2[500][500];\n\t\tfor(int i=0;i<h2;i++)for(int j=0;j<w2;j++)\tcin>>room2[i][j];\n\n\t\tvector<pii> roomcnt1;\n\t\tstatic bool visited[500][500];\n\t\tfor(int i=0;i<h1;i++)for(int j=0;j<w1;j++)\tvisited[i][j]=false;\n\t\tvisited[y1][x1]=true;\n\t\troomcnt1.pb(mp(0,0));\n\t\tint cnt=0,lev=0;\n\t\tpriority_queue< pair<int,pii> > pq;\tpq.push(mp(-room1[y1][x1],mp(y1,x1)));\n\t\twhile(!pq.empty()){\n\t\t\tpair<int,pii> a=pq.top();\tpq.pop();\n\t\t\tint nowlev=-a.first,x=a.second.second,y=a.second.first;\n\t\t\tcnt++;\n\t\t\tif(lev<nowlev){\n\t\t\t\troomcnt1.pb(mp(cnt,nowlev));\n\t\t\t\tlev=nowlev;\n\t\t\t}\n\t\t\telse\t*(roomcnt1.rbegin())=mp(cnt,lev);\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint xx=x+dx[i],yy=y+dy[i];\n\t\t\t\tif(0<=xx && xx<w1 && 0<=yy && yy<h1 && !visited[yy][xx]){\n\t\t\t\t\tpq.push(mp(-room1[yy][xx],mp(yy,xx)));\n\t\t\t\t\tvisited[yy][xx]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<pii> roomcnt2;\n\t\tfor(int i=0;i<h1;i++)for(int j=0;j<w1;j++)\tvisited[i][j]=false;\n\t\tvisited[y2][x2]=true;\n\t\troomcnt2.pb(mp(0,0));\n\t\tcnt=0,lev=0;\n\t\tpq=priority_queue< pair<int,pii> >();\tpq.push(mp(-room2[y2][x2],mp(y2,x2)));\n\t\twhile(!pq.empty()){\n\t\t\tpair<int,pii> a=pq.top();\tpq.pop();\n\t\t\tint nowlev=-a.first,x=a.second.second,y=a.second.first;\n\t\t\tcnt++;\n\t\t\tif(lev<nowlev){\n\t\t\t\troomcnt2.pb(mp(cnt,nowlev));\n\t\t\t\tlev=nowlev;\n\t\t\t}\n\t\t\telse\t*(roomcnt2.rbegin())=mp(cnt,lev);\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint xx=x+dx[i],yy=y+dy[i];\n\t\t\t\tif(0<=xx && xx<w2 && 0<=yy && yy<h2 && !visited[yy][xx]){\n\t\t\t\t\tpq.push(mp(-room2[yy][xx],mp(yy,xx)));\n\t\t\t\t\tvisited[yy][xx]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans=1<<30;\n\t\tfor(int i=0;i<roomcnt1.size();i++){\n\t\t\tint rem=r-roomcnt1[i].first;\n\t\t\tvector<pii>::iterator it=lower_bound(roomcnt2.begin(),roomcnt2.end(),mp(rem,0));\n\t\t\tif(it!=roomcnt2.end()){\n\t\t\t\tint lev1=roomcnt1[i].second;\n\t\t\t\tint lev2=it->second;\n\t\t\t\tans=min(ans,lev1+lev2);\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <numeric>\n#include <map>\n#include <vector>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <cmath>\n#include <stack>\n#include <cctype>\n#include <queue>\n#include <algorithm>\n#include <memory>\n#include <memory.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nconst int INF = 1 << 30;\nconst double EPS = 1e-10;\nconst double PI = 3.14159;\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, -1, 0, 1};\nbool used[2][502][502];\nint office[2][502][502];\nint cost[2][110000];\nint w[2];\nint h[2];\nint x[2];\nint y[2];\n\nint main(){\n\tint R;\n\twhile(cin >> R && R){\n\t\tfill(&office[0][0][0], &office[1][501][501] + 1, INF);\n\t\tfill(&cost[0][0], &cost[1][109999] + 1, INF);\n\t\tmemset(used, false, sizeof(used));\n\t\tfor(int i = 0; i < 2; i++){\n\t\t\tcin >> w[i] >> h[i] >> x[i] >> y[i];\n\t\t\tfor(int j = 1; j <= h[i]; j++){\n\t\t\t\tfor(int k = 1; k <= w[i]; k++){\n\t\t\t\t\tcin >> office[i][j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 2; i++){\n\t\t\tpriority_queue<PP, vector<PP>, greater<PP> > que;\n\t\t\tcost[i][0] = 0;\n\t\t\tint m_cost = 0;\n\t\t\tint count = 1;\n\t\t\tque.push(PP(1, P(y[i], x[i])));\n\t\t\twhile(!que.empty()){\n\t\t\t\tPP pp = que.top();\n\t\t\t\tque.pop();\n\t\t\t\tint c = pp.first;\n\t\t\t\tif(c == INF || count >= R + 10 || count > h[i] * w[i]) break;\n\t\t\t\tm_cost = max(m_cost, c);\n\t\t\t\tint y1 = pp.second.first;\n\t\t\t\tint x1 = pp.second.second;\n\t\t\t\tused[i][y1][x1] = true;\n\t\t\t\tcost[i][count++] = m_cost;\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tint y2 = y1 + dy[j];\n\t\t\t\t\tint x2 = x1 + dx[j];\n\t\t\t\t\tif(used[i][y2][x2]) continue;\n\t\t\t\t\tque.push(PP(office[i][y2][x2], P(y2, x2)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = INF;\n\t\tfor(int i = 0; i <= R; i++){\n\t\t\tcout << cost[0][i] << \" \" << cost[1][R-i] << endl;\n\t\t\tres = min(res, cost[0][i] + cost[1][R-i]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint r,w[2],h[2],x[2],y[2],l[2][500][500],temp[500][500]; vector<P> d[2];\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nvoid search(int n){\n\tfor(int i=0;i<500;i++) for(int j=0;j<500;j++) temp[i][j]=0;\n\tpriority_queue<P, vector<P>, greater<P> > q; d[n].push_back(P(0,0));\n\tq.push(P(l[n][y[n]][x[n]],x[n]*1000+y[n])); temp[y[n]][x[n]]=1;\n\tint res=0;\n\twhile(!q.empty()){\n\t\tP z=q.top(),qq;\n\t\twhile(qq=q.top(),qq.first<=z.first&&!q.empty()){\n\t\t\tq.pop(); int X=qq.second/1000,Y=qq.second%1000; res++;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tint i=X+dx[k],j=Y+dy[k];\n\t\t\t\tif(i<0||j<0||i>=w[n]||j>=h[n]) continue;\n\t\t\t\tif(temp[j][i]) continue;\n\t\t\t\tq.push(P(l[n][j][i],i*1000+j)); temp[j][i]=1;\n\t\t\t}\n\t\t}\n\t\td[n].push_back(P(res,l[n][z.second%1000][z.second/1000]));\n\t}\n}\n\nP l_b(int m){\n\tint lb=-1,rb=d[1].size();\n\twhile(lb+1<rb){\n\t\tint mid=(lb+rb)/2;\n\t\tif(d[1][mid].first>=m) rb=mid;\n\t\telse lb=mid;\n\t}\n\treturn d[1][rb];\n}\n\nint main(){\n\tscanf(\"%d\",&r);\n\tfor(int i=0;i<2;i++){\n\t\tscanf(\"%d%d%d%d\",&w[i],&h[i],&x[i],&y[i]); x[i]--; y[i]--;\n\t\tfor(int j=0;j<h[i];j++) for(int k=0;k<w[i];k++) scanf(\"%d\",&l[i][j][k]);\n\t\tsearch(i);\n\t}\n\tint res=INT_MAX;\n\tfor(int i=0;i<d[0].size();i++){\n\t\tP p=l_b(r-d[0][i].first);\n\t\tif(p.first+d[0][i].first>=r) res=min(res,p.second+d[0][i].second);\n\t}\n\tprintf(\"%d\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\ntypedef pair<int,Pi> PP;\n\nconst int INF=1000000000;\nconst long long int INF_=1000000000000000000;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\ninline bool IsIn(int y,int x,int h,int w){\n\treturn 0<=y&&y<h&&0<=x&&x<w;\n}\n\ninline int f(int x){\n\tif(x==0) return 1;\n\telse if(x==1) return 0;\n}\n\nvoid Djikstra(vector<vector<int> > &f,vector<vector<int> > &l,int sy,int sx,int h,int w){\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\tREP(y,0,h) fill(l[y].begin(),l[y].end(),INF);\n\tl[sy][sx]=1;\n\tque.push(PP(1,Pi(sy,sx)));\n\twhile(!que.empty()){\n\t\tPP p=que.top(); que.pop();\n\t\tPi v=p.S_;\n\t\tif(l[v.F_][v.S_]<p.F_) continue;\n\t\tREP(i,0,4){\n\t\t\tint ny=v.F_+dy[i],nx=v.S_+dx[i];\n\t\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\t\tif(l[ny][nx]>max(f[ny][nx],l[v.F_][v.S_])){\n\t\t\t\tl[ny][nx]=max(f[ny][nx],l[v.F_][v.S_]);\n\t\t\t\tque.push(PP(l[ny][nx],Pi(ny,nx)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tint R;\n\twhile(cin >> R&&R){\n\t\tint W[2],H[2],X[2],Y[2];\n\t\tvector<vector<int> > field[2];\n\t\tvector<vector<int> > level[2];\n\t\tREP(i,0,2){\n\t\t\tcin >> W[i] >> H[i] >> X[i] >> Y[i];\n\t\t\t--X[i]; --Y[i];\n\t\t\tfield[i].resize(H[i]);\n\t\t\tlevel[i].resize(H[i]);\n\t\t\tREP(j,0,H[i]){\n\t\t\t\tfield[i][j].resize(W[i]);\n\t\t\t\tlevel[i][j].resize(W[i]);\n\t\t\t}\n\t\t\tREP(y,0,H[i]) REP(x,0,W[i]) cin >> field[i][y][x];\n\t\t\tDjikstra(field[i],level[i],Y[i],X[i],H[i],W[i]);\n\t\t}\n\t\tmap<int,int> s[2];\n\t\tvector<int> idx[2],num[2];\n\t\tREP(i,0,2){\n\t\t\tREP(y,0,H[i]) REP(x,0,W[i]) ++s[i][level[i][y][x]];\n\t\t\tauto it=s[i].begin();\n\t\t\tidx[i].push_back(0);\n\t\t\tnum[i].push_back(0);\n\t\t\tidx[i].push_back(it->F_);\n\t\t\tnum[i].push_back(it->S_);\n\t\t\tauto prev=it;\n\t\t\t++it;\n\t\t\tfor(; it!=s[i].end(); ++it,++prev){\n\t\t\t\tit->S_+=prev->S_;\n\t\t\t\tidx[i].push_back(it->F_);\n\t\t\t\tnum[i].push_back(it->S_);\n\t\t\t}\n\t\t}\n\t\tint result=INF;\n\t\tREP(i,0,2) REP(j,0,idx[i].size()){\n\t\t\tint tmp=(int)(lower_bound(num[f(i)].begin(),num[f(i)].end(),R-num[i][j])-num[f(i)].begin());\n\t\t\tif(!(0<=tmp&&tmp<=idx[f(i)].size()-1)) continue;\n\t\t\tresult=min(result,idx[i][j]+idx[f(i)][tmp]);\n\t\t}\n\t\tcout << result << endl;\n\t}\n}\n\nint main(){\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\ntypedef pair< int, int > Pi;\ntypedef pair< int, Pi > Pii;\nconst int INF = 1 << 29;\nconst int dy[] = {0, 1, 0, -1}, dx[] = {1, 0, -1, 0};\n \nstruct Field\n{\n  int W, H, X, Y;\n  int L[500][500];\n};\n \nvoid InputField(Field& e)\n{\n  cin >> e.W >> e.H >> e.X >> e.Y;\n  --e.X, --e.Y;\n  for(int i = 0; i < e.H; i++) {\n    for(int j = 0; j < e.W; j++) {\n      cin >> e.L[i][j];\n    }\n  }\n}\n// ????\nint BFSField(const Field& e, vector< int >& cost)\n{\n  priority_queue< Pii, vector< Pii >, greater< Pii > > que;\n  que.push({1, make_pair(e.X, e.Y)});\n  int min_cost[500][500];\n  fill_n(*min_cost, 500 * 500, INF);\n  min_cost[e.X][e.Y] = 1;\n  map< int, int > cur;\n  while(!que.empty()) {\n    Pi point = que.top().second;\n    int c = que.top().first;\n    que.pop();\n    if(c > min_cost[point.first][point.second]) continue;\n    cur[c]++;\n    for(int i = 0; i < 4; i++) {\n      int ny = point.second + dy[i], nx = point.first + dx[i];\n      if(ny < 0 || nx < 0 || ny >= e.H || nx >= e.W) continue;\n      if(min_cost[nx][ny] > max(c, e.L[ny][nx])) {\n        min_cost[nx][ny] = max(c, e.L[ny][nx]);\n        que.push({min_cost[nx][ny], Pi(nx, ny)});\n      }\n    }\n  }\n   \n  // ????????????????????\\?????????????????????\n  cost.assign(e.W * e.H + 1, INF);\n  int sum = 0;\n  cost[0] = 0;\n  for(auto e : cur) {\n    sum += e.second;\n    cost[sum] = e.first;\n  }\n  for(int i = cost.size() - 2; i >= 0; i--) {\n    cost[i] = min(cost[i + 1], cost[i]);\n  }\n}\n \nint main()\n{\n  int R;\n  Field A, B;\n \n  cin >> R;\n  InputField(A);\n  InputField(B);\n  vector< int > a, b;\n  BFSField(A, a);\n  BFSField(B, b);\n   \n  int ret = INF;\n  for(int i = 0; i < a.size(); i++) {\n    if(R - i >= 0 && R - i < b.size()) {\n      ret = min(ret, a[i] + b[R - i]);\n    }\n  }\n   \n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <utility>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <cstring>\nusing namespace std;\n#define INF 200000000\n\nint ary1[510][510],ary2[510][510];\nbool used[510][510];\nint main(){\n\tint R,W1,W2,H1,H2,X1,X2,Y1,Y2,imax,imay,imad,res;\n\tpriority_queue<pair<int,pair<int,int> > ,vector<pair<int,pair<int,int> > >,greater<pair<int,pair<int,int> > > > que;\n\tset<int> se1,se2;\n\tvector<int> v1,v2;\n\tpair<int,pair<int,int> > pa;\n\twhile(1){\n\t\tv1.clear();\n\t\tv2.clear();\n\t\tcin>>R;\n\t\tif(R==0) break;\n\t\tcin>>W1>>H1>>Y1>>X1;\n\t\tX1--;Y1--;\n\t\tfor(int i=0;i<H1;i++){\n\t\t\tfor(int j=0;j<W1;j++){\n\t\t\t\tcin>>ary1[i][j];\n\t\t\t}\n\t\t}\n\t\tcin>>W2>>H2>>Y2>>X2;\n\t\tX2--;Y2--;\n\t\tfor(int i=0;i<H2;i++){\n\t\t\tfor(int j=0;j<W2;j++){\n\t\t\t\tcin>>ary2[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemset(used,0,sizeof(used));\n\t\tque.push(make_pair(1,make_pair(X1,Y1)));\n\t\tused[X1][Y1]=true;\n\t\twhile(!que.empty()){\n\t\t\tpa=que.top();que.pop();\n\t\t\timax=pa.second.first;\n\t\t\timay=pa.second.second;\n\t\t\timad=pa.first;\n\t\t\tary1[imax][imay]=imad;\n\t\t\tif(imax>0&&(!used[imax-1][imay])){\n\t\t\t\tused[imax-1][imay]=true;\n\t\t\t\tque.push(make_pair(max(ary1[imax-1][imay],imad),make_pair(imax-1,imay)));\n\t\t\t}\n\t\t\tif(imax<H1-1&&(!used[imax+1][imay])){\n\t\t\t\tused[imax+1][imay]=true;\n\t\t\t\tque.push(make_pair(max(ary1[imax+1][imay],imad),make_pair(imax+1,imay)));\n\t\t\t}\n\t\t\tif(imay>0&&(!used[imax][imay-1])){\n\t\t\t\tused[imax][imay-1]=true;\n\t\t\t\tque.push(make_pair(max(ary1[imax][imay-1],imad),make_pair(imax,imay-1)));\n\t\t\t}\n\t\t\tif(imay<W1-1&&(!used[imax][imay+1])){\n\t\t\t\tused[imax][imay+1]=true;\n\t\t\t\tque.push(make_pair(max(ary1[imax][imay+1],imad),make_pair(imax,imay+1)));\n\t\t\t}\n\t\t}\n\t\tmemset(used,0,sizeof(used));\n\t\tque.push(make_pair(1,make_pair(X2,Y2)));\n\t\tused[X2][Y2]=true;\n\t\twhile(!que.empty()){\n\t\t\tpa=que.top();que.pop();\n\t\t\timax=pa.second.first;\n\t\t\timay=pa.second.second;\n\t\t\timad=pa.first;\n\t\t\tary2[imax][imay]=imad;\n\t\t\tif(imax>0&&(!used[imax-1][imay])){\n\t\t\t\tused[imax-1][imay]=true;\n\t\t\t\tque.push(make_pair(max(ary2[imax-1][imay],imad),make_pair(imax-1,imay)));\n\t\t\t}\n\t\t\tif(imax<H2-1&&(!used[imax+1][imay])){\n\t\t\t\tused[imax+1][imay]=true;\n\t\t\t\tque.push(make_pair(max(ary2[imax+1][imay],imad),make_pair(imax+1,imay)));\n\t\t\t}\n\t\t\tif(imay>0&&(!used[imax][imay-1])){\n\t\t\t\tused[imax][imay-1]=true;\n\t\t\t\tque.push(make_pair(max(ary2[imax][imay-1],imad),make_pair(imax,imay-1)));\n\t\t\t}\n\t\t\tif(imay<W2-1&&(!used[imax][imay+1])){\n\t\t\t\tused[imax][imay+1]=true;\n\t\t\t\tque.push(make_pair(max(ary2[imax][imay+1],imad),make_pair(imax,imay+1)));\n\t\t\t}\n\t\t}\n\t\tv1.push_back(0);\n\t\tfor(int i=0;i<H1;i++){\n\t\t\tfor(int j=0;j<W1;j++){\n\t\t\t\tv1.push_back(ary1[i][j]);\n\t\t\t}\n\t\t}\n\t\tsort(v1.begin(),v1.end());\n\t\tv2.push_back(0);\n\t\tfor(int i=0;i<H2;i++){\n\t\t\tfor(int j=0;j<W2;j++){\n\t\t\t\tv2.push_back(ary2[i][j]);\n\t\t\t}\n\t\t}\n\t\tsort(v2.begin(),v2.end());\n\t\tres=INF;\n\t\tfor(int i=0;i<=R;i++){\n\t\t\tif(W1*H1>=i&&W2*H2>=R-i)res=min(res,v1.at(i)+v2.at(R-i));\n\t\t}\n\t\tcout<<res<<endl;\n\n\t\tfor(int i=0;i<H1;i++){\n\t\t\tfor(int j=0;j<W1;j++){\n\t\t\t\tcout<<ary1[i][j]<<\" \";\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t\tfor(int i=0;i<H2;i++){\n\t\t\tfor(int j=0;j<W2;j++){\n\t\t\t\tcout<<ary2[i][j]<<\" \";\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define p pair<int,int>\n#define P pair<int,p>\nusing namespace std;\n \nint x[4] = { -1,0,0,1 }, y[4] = { 0,-1,1,0 };\nint f[500][500];\nbool i[500][500];\nvector<p>l,r;\nsigned main() {\n    int a;\n    while (cin >> a, a) {\n        l.clear(); r.clear();\n        l.push_back(p(0, 0)); r.push_back(p(0, 0));\n        int b, c, d, e; cin >> c >> b >> e >> d;\n        d--; e--;\n        for (int g = 0; g < b; g++) {\n            for (int h = 0; h < c; h++) {\n                scanf(\"%lld\", &f[g][h]);\n            }\n        }\n        memset(i, true, sizeof(i));\n        int sum = 0, MAX = 0;\n        priority_queue<P, vector<P>, greater<P>>Q;\n        Q.push(P(1, p(d, e)));\n        while (Q.size()) {\n            P o = Q.top(); Q.pop();\n            MAX = o.first; \n            if(i[o.second.first][o.second.second])sum++;\n            i[o.second.first][o.second.second] = false;\n            queue<p>q;\n            q.push(p(o.second.first, o.second.second));\n            while (q.size()) {\n                p t = q.front(); q.pop();\n                for (int i = 0; i < 4; i++) {\n                    int dx = t.first + x[i], dy = t.second + y[i];\n                    if (dx >= 0 && dx < b&&dy >= 0 && dy < c&&::i[dx][dy]) {\n                        if (f[dx][dy] <= o.first) {\n                            sum++;\n                            q.push(p(dx,dy));\n                            ::i[dx][dy] = false;\n                        }\n                        else {\n                            Q.push(P(f[dx][dy],p(dx,dy)));\n                        }\n                    }\n                }\n            }\n            l.push_back(p(sum, MAX));\n        }\n        cin >> c >> b >> e >> d;\n        d--; e--;\n        for (int g = 0; g < b; g++) {\n            for (int h = 0; h < c; h++) {\n                scanf(\"%lld\", &f[g][h]);\n            }\n        }\n        memset(i, true, sizeof(i));\n        sum = 0; MAX = 0;\n        priority_queue<P, vector<P>, greater<P>>U;\n        U.push(P(1, p(d, e)));\n        while (U.size()) {\n            P o = U.top(); U.pop();\n            MAX = o.first;\n            if (i[o.second.first][o.second.second])sum++;\n            i[o.second.first][o.second.second] = false;\n            queue<p>q;\n            q.push(p(o.second.first, o.second.second));\n            while (q.size()) {\n                p t = q.front(); q.pop();\n                for (int i = 0; i < 4; i++) {\n                    int dx = t.first + x[i], dy = t.second + y[i];\n                    if (dx >= 0 && dx < b&&dy >= 0 && dy < c&&::i[dx][dy]) {\n                        if (f[dx][dy] <= o.first) {\n                            sum++;\n                            q.push(p(dx, dy));\n                            ::i[dx][dy] = false;\n                        }\n                        else {\n                            U.push(P(f[dx][dy], p(dx, dy)));\n                        }\n                    }\n                }\n            }\n            r.push_back(p(sum, MAX));\n        }\n        int MIN = LLONG_MAX/3;\n        for (auto i = l.begin(); i != l.end(); i++) {\n            auto j = lower_bound(r.begin(),r.end(),p(a-(*i).first,0));\n            if (j != r.end()) {\n                MIN = min(MIN, (*i).second + (*j).second);\n            }\n        }\n        cout << MIN << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <tuple>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nconst vector<int> dx = { 0, 1, 0, -1 };\nconst vector<int> dy = { -1, 0, 1, 0 };\n\nint R, W[2], H[2], X[2], Y[2], F[2][500][500], D[2][500][500];\n\nint main()\n{\n\tscanf(\"%d\", &R);\n\n\tfor (int i = 0; i < 2; i++)\n\t{\n\t\tscanf(\"%d\", &W[i]);\n\t\tscanf(\"%d\", &H[i]);\n\t\tscanf(\"%d\", &X[i]); X[i]--;\n\t\tscanf(\"%d\", &Y[i]); Y[i]--;\n\n\t\tfor (int j = 0; j < H[i]; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < W[i]; k++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &F[i][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\n\tmemset(D, -1, sizeof(D));\n\n\tfor (int i = 0; i < 2; i++)\n\t{\n\t\tD[i][Y[i]][X[i]] = 1;\n\n\t\tpriority_queue<tuple<int, int, int>, vector<tuple<int, int, int> >, greater<tuple<int, int, int> > > que;\n\n\t\tque.push(make_tuple(0, X[i], Y[i]));\n\n\t\twhile (!que.empty())\n\t\t{\n\t\t\ttuple<int, int, int> state = que.top(); que.pop();\n\n\t\t\tint d = get<0>(state);\n\t\t\tint x = get<1>(state);\n\t\t\tint y = get<2>(state);\n\n\t\t\tfor (int dir = 0; dir < 4; dir++)\n\t\t\t{\n\t\t\t\tint x2 = x + dx[dir];\n\t\t\t\tint y2 = y + dy[dir];\n\n\t\t\t\tif (0 <= x2 && x2 < W[i] && 0 <= y2 && y2 < H[i])\n\t\t\t\t{\n\t\t\t\t\tif (D[i][y2][x2] == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tD[i][y2][x2] = max(d, F[i][y2][x2]);\n\n\t\t\t\t\t\tque.push(make_tuple(D[i][y2][x2], x2, y2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<int> E[2];\n\n\tfor (int i = 0; i < 2; i++)\n\t{\n\t\tfor (int j = 0; j < H[i]; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < W[i]; k++)\n\t\t\t{\n\t\t\t\tE[i].push_back(D[i][j][k]);\n\t\t\t}\n\t\t}\n\n\t\tsort(E[i].begin(), E[i].end());\n\t}\n\n\tint ret = 999999999;\n\n\tfor (int i = 0; i < R; i++)\n\t{\n\t\tif (i < E[0].size() && R - i < E[1].size())\n\t\t{\n\t\t\tret = min(ret, E[0][i] + E[1][R - i - 1]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Rep(i, N) for(int i = 0; i < N; i++)\n#define pb push_back\n#define INF 1 << 29\n#define fi first\n#define se second\ntypedef pair<int, int> Pi;\ntypedef pair<int, Pi> Ti;\n\nint R;\nint W[2], H[2];\nint sx[2], sy[2];\nint mas[2][505][505];\nint mc[2][100005];\nint mx[] = {1, 0, -1, 0};\nint my[] = {0, 1, 0, -1};\n\nvoid Dijkstra(int p) {\n  int ssy = sy[p], ssx = sx[p];\n  bool flag[505][505] = {0};\n  priority_queue< Ti , vector< Ti >, greater< Ti > > pq;\n  pq.push(Ti(1, Pi(ssy, ssx)));\n  mc[p][1] = 1;\n  for(int r = 1; r <= R && r <= H[p] * W[p]; r++) {\n    int w = pq.top().fi, y = pq.top().se.fi, x = pq.top().se.se; pq.pop();\n    flag[y][x] = true; mc[p][r] = w;\n    Rep(i, 4) {\n      int ny = y + my[i], nx = x + mx[i];\n      if(ny < 0 || nx < 0 || nx >= W[p] || ny >= H[p]) continue;\n      int nw = max(mc[p][r], mas[p][ny][nx]);\n      if(!flag[ny][nx]) {\n\tpq.push(Ti(nw, Pi(ny, nx)));\n      }\n    }\n  }\n}\n\nsigned main()\n{\n  int minv = INF;\n\n  fill_n(*mc, 2 * 100005, INF);\n  cin >> R;\n  Rep(p, 2) {\n    cin >> W[p] >> H[p] >> sx[p] >> sy[p]; --sx[p], --sy[p];\n    Rep(i, H[p]) Rep(j, W[p]) cin >> mas[p][i][j];\n  }\n  \n  Rep(p, 2) Dijkstra(p);\n  mc[0][0] = mc[1][0] = 0;\n  Rep(i, R + 1) {\n    minv = min(minv, mc[0][i] + mc[1][R - i]);\n  }\n  \n  cout << minv << endl;\n  \n  return 0;\n}\n  \n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst LL INF = 1001001001001001;\n\nint r, x[2], y[2];\nLL grid[2][502][502];\nbool done[2][502][502];\nLL memo[2][5001];\n\nstruct P\n{\n\tint g, x, y;\n\t\n\tbool operator < (const P& t) const {\n\t\treturn grid[g][x][y] > grid[g][t.x][t.y];\n\t}\n};\n\nvoid search(int g)\n{\n\tfor (int i = 0; i < 502; i++){\n\t\tfor (int j = 0; j < 502; j++){\n\t\t\tdone[g][i][j] = false;\n\t\t}\n\t}\n\tfor (int i = 0; i <= 5000; i++){\n\t\tmemo[g][i] = INF;\n\t}\n\tmemo[g][0] = 0;\n\t\n\tint num = 0;\n\tLL level = 0;\n\tLL mini = INF;\n\tpriority_queue<P> que;\n\tque.push({g, x[g], y[g]});\n\twhile (!que.empty()){\n\t\tP p = que.top(); que.pop();\n\t\tif (done[g][p.x][p.y]) continue;\n\t\tdone[g][p.x][p.y] = true;\n\t\t\n\t\t//printf(\"%d %d %d\\n\", g, p.x, p.y);\n\t\t\n\t\tif (grid[g][p.x][p.y] <= level){\n\t\t\tnum++;\n\t\t\tmemo[g][num] = level;\n\t\t}\n\t\telse {\n\t\t\t//if (grid[g][p.x][p.y] == INF) break;\n\t\t\tlevel = grid[g][p.x][p.y];\n\t\t\tnum++;\n\t\t\tmemo[g][num] = level;\n\t\t}\n\t\t\n\t\tif (num >= r) return;\n\t\t\n\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\tint tx = p.x + dx[dir];\n\t\t\tint ty = p.y + dy[dir];\n\t\t\tif (!done[g][tx][ty] && done[g][tx][ty] != INF){\n\t\t\t\tque.push({g, tx, ty});\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (scanf(\"%d\", &r), r){\n\t\tfor (int i = 0; i < 2; i++){\n\t\t\tfor (int j = 0; j < 502; j++){\n\t\t\t\tfor (int k = 0; k < 502; k++){\n\t\t\t\t\tgrid[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint h, w;\n\t\t\tscanf(\"%d %d %d %d\", &w, &h, &y[i], &x[i]);\n\t\t\tfor (int j = 1; j <= h; j++){\n\t\t\t\tfor (int k = 1; k <= w; k++){\n\t\t\t\t\tscanf(\"%lld\", &grid[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < 2; i++){\n\t\t\tsearch(i);\n\t\t}\n\t\t\n\t\tLL mini = INF;\n\t\tfor (int i = 0; i <= r; i++){\n\t\t\tmini = min(mini, memo[0][i] + memo[1][r - i]);\n\t\t}\n\t\tprintf(\"%lld\\n\", mini);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\n\nvector<int> calc_required_level_to_rooms()\n{\n\tint w, h, sx, sy;\n\tstatic int req[512][512];\n\tcin >> w >> h >> sx >> sy;\n\t--sx, --sy;\n\tfor (int y = 0; y < h; ++y)\n\t\tfor (int x = 0; x < w; ++x)\n\t\t\tcin >> req[y][x];\n\n\tvector<int> res;\n\tres.push_back(0);\n\n\tstatic bool visit[512][512];\n\tCLEAR(visit, 0);\n\n\ttypedef pair<int, pint> P;\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tq.push(P(1, pint(sx, sy)));\n\twhile (!q.empty())\n\t{\n\t\tP tt = q.top(); q.pop();\n\t\tint level = tt.first;\n\t\tint x = tt.second.first, y = tt.second.second;\n\t\tif (visit[y][x])\n\t\t\tcontinue;\n\n\t\tvisit[y][x] = true;\n\t\tres.push_back(level);\n\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\t\tif (valid_pos(tx, ty, w, h) && !visit[ty][tx])\n\t\t\t\tq.push(P(max(level, req[ty][tx]), pint(tx, ty)));\n\t\t}\n\t}\n\tif (res.size() != w * h + 1)\n\t\texit(1);\n\treturn res;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tint r;\n\tcin >> r;\n\n\tvector<int> a = calc_required_level_to_rooms();\n\tvector<int> b = calc_required_level_to_rooms();\n\n\tif (a.size() < b.size())\n\t\tswap(a, b);\n\n\tint res = 1e9;\n\tfor (int i = min<int>(r, a.size() - 1); i >= 0 && r - i < b.size(); --i)\n\t\tmin_swap(res, a[i] + b[r - i]);\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#define MP(a, b) make_pair(a, b)\n#define MMP(a, b, c) make_pair(make_pair(a, b), c)\n#define MAX 1000000000\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483647\n#define INT_MAX 2147483647\n#define LL_MIN (LL)-9223372036854775807\n#define LL_MAX (LL)9223372036854775807\n#define PI 3.14159265359\n\nint main(){\n    ios::sync_with_stdio(false);\n\n    START:\n\n    int R;\n    cin >> R;\n    if(R == 0) return 0;\n\n    int W1, H1, X1, Y1;\n    cin >> W1 >> H1 >> X1 >> Y1;\n    X1--; Y1--;\n    int room1[500][500];\n    vector<pair<int,pair<int,int> > > level1;\n    for(int i=0; i<H1; i++){\n        for(int j=0; j<W1; j++){\n            cin >> room1[i][j];\n            level1.push_back(MP(room1[i][j], MP(i,j)));\n        }\n    }\n    sort(level1.begin(), level1.end());\n    vector<pair<int, int> > ans1;\n    ans1.push_back(MP(0, 0));\n    bool already1[500][500] = {};\n    queue<pair<int,int> > que;\n    int tmp = 0;\n    for(int i=0; i<level1.size(); i++){\n        int y = level1[i].second.first;\n        int x = level1[i].second.second;\n        if(y == Y1 && x == X1){\n            que.push(MP(Y1, X1));\n            already1[Y1][X1] = true;\n            tmp++;\n        }\n        else if((y-1>=0 && already1[y-1][x]) || (y+1<H1 && already1[y+1][x])\n        || (x-1>=0 && already1[y][x-1]) || (x+1<W1 && already1[y][x+1]) ){\n            que.push(MP(y, x));\n            already1[y][x] = true;\n            tmp++;\n        }\n        if(i != level1.size()-1 && level1[i].first == level1[i+1].first) continue;\n\n        while(!que.empty()){\n            y = que.front().first;\n            x = que.front().second;\n            if(y-1>=0 && room1[y-1][x]<=level1[i].first && !already1[y-1][x]){\n                que.push(MP(y-1, x));\n                already1[y-1][x] = true;\n                tmp++;\n            }\n            if(y+1<H1 && room1[y+1][x]<=level1[i].first && !already1[y+1][x]){\n                que.push(MP(y+1, x));\n                already1[y+1][x] = true;\n                tmp++;\n            }\n            if(x-1>=0 && room1[y][x-1]<=level1[i].first && !already1[y][x-1]){\n                que.push(MP(y, x-1));\n                already1[y][x-1] = true;\n                tmp++;\n            }\n            if(x+1<W1 && room1[y][x+1]<=level1[i].first && !already1[y][x+1]){\n                que.push(MP(y, x+1));\n                already1[y][x+1] = true;\n                tmp++;\n            }\n            que.pop();\n        }\n        ans1.push_back(MP(tmp, level1[i].first));\n        if(tmp >= R) while(!que.empty()) que.pop();\n    }\n\n    int ans = INT_MAX;\n    auto itr = lower_bound(ans1.begin(), ans1.end(), MP(R,0));\n    if(itr != ans1.end()) ans = itr->second;\n\n    int W2, H2, X2, Y2;\n    cin >> W2 >> H2 >> X2 >> Y2;\n    X2--; Y2--;\n    int room2[500][500];\n    vector<pair<int,pair<int,int> > > level2;\n    for(int i=0; i<H2; i++){\n        for(int j=0; j<W2; j++){\n            cin >> room2[i][j];\n            level2.push_back(MP(room2[i][j], MP(i,j)));\n        }\n    }\n    sort(level2.begin(), level2.end());\n    bool already2[500][500] = {};\n    tmp = 0;\n    for(int i=0; i<level2.size(); i++){\n        int y = level2[i].second.first;\n        int x = level2[i].second.second;\n        if(y == Y2 && x == X2){\n            que.push(MP(Y2, X2));\n            already2[Y2][X2] = true;\n            tmp++;\n        }\n        else if((y-1>=0 && already2[y-1][x]) || (y+1<H2 && already2[y+1][x])\n        || (x-1>=0 && already2[y][x-1]) || (x+1<W2 && already2[y][x+1]) ){\n            que.push(MP(y, x));\n            already2[y][x] = true;\n            tmp++;\n        }\n        if(i != level2.size()-1 && level2[i].first == level2[i+1].first) continue;\n\n        while(!que.empty()){\n            y = que.front().first;\n            x = que.front().second;\n            if(y-1>=0 && room2[y-1][x]<=level2[i].first && !already2[y-1][x]){\n                que.push(MP(y-1, x));\n                already2[y-1][x] = true;\n                tmp++;\n            }\n            if(y+1<H2 && room2[y+1][x]<=level2[i].first && !already2[y+1][x]){\n                que.push(MP(y+1, x));\n                already2[y+1][x] = true;\n                tmp++;\n            }\n            if(x-1>=0 && room2[y][x-1]<=level2[i].first && !already2[y][x-1]){\n                que.push(MP(y, x-1));\n                already2[y][x-1] = true;\n                tmp++;\n            }\n            if(x+1<W2 && room2[y][x+1]<=level2[i].first && !already2[y][x+1]){\n                que.push(MP(y, x+1));\n                already2[y][x+1] = true;\n                tmp++;\n            }\n            que.pop();\n        }\n        itr = lower_bound(ans1.begin(), ans1.end(), MP(R-tmp,0));\n        if(itr != ans1.end()) ans = min(ans, itr->second + level2[i].first);\n        if(tmp >= R) while(!que.empty()) que.pop();\n    }\n\n    cout << ans << endl;\n\n    goto START;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cassert>\n#include <map>\nusing namespace std;\n\nclass state{\npublic:\n  int x,y,l;\n  state(int y=0, int x=0, int l=0):y(y),x(x),l(l){}\n  bool operator < (const state &s) const {return l > s.l;}\n};\n\nconst int INF = (1<<29);\ntypedef pair<int,int> P;\nint r,h,w,rx,ry,a[500][500];\nint dy[] = {0,1,0,-1};\nint dx[] = {1,0,-1,0};\nbool f[500][500];\nvector<int> numr[2],numl[2];\nmap<int,int> m[2];\n\nbool check(int y, int x){\n  if(y < 0 || y >= h) return false;\n  if(x < 0 || x >= w) return false;\n  return true;\n}\n\nvoid bfs(int k){\n  int maxl = 0;\n  priority_queue<state> Q;\n  state u,v;\n\n  m[k].clear();\n  fill(f[0],f[max(h,w)],false);\n  f[ry][rx] = true;\n  Q.push(state(ry,rx,1));\n  while(!Q.empty()){\n    u = Q.top();\n    Q.pop();\n\n    if(u.l > maxl){\n      m[k][u.l] = m[k][maxl] + 1;\n      maxl = u.l;\n    } else m[k][maxl]++;\n\n    for(int i=0;i<4;i++){\n      v.x = u.x + dx[i];\n      v.y = u.y + dy[i];\n      if(check(v.y,v.x) && !f[v.y][v.x]){\n\tf[v.y][v.x] = true;\n\tv.l = a[v.y][v.x];\n\tQ.push(v);\n      }\n    }\n  }\n\n  numr[k].clear();\n  numl[k].clear();\n  for(map<int,int>::iterator it=m[k].begin(); it!=m[k].end(); it++){\n    numl[k].push_back(it->first);\n    numr[k].push_back(it->second);\n  }\n\n}\n\nint main(){\n  while(cin >> r && r){\n    int ans = INF;\n    for(int k=0;k<2;k++){\n      cin >> w >> h >> rx >> ry;\n      rx--;\n      ry--;\n      for(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++)\n\t  cin >> a[i][j];\n      bfs(k);      \n    }\n\n    for(int i=0;i<numr[0].size();i++){\n      if(numr[0][i] >= r){\n\tans = min(numl[0][i],ans);\n\tbreak;\n      }\n      int cnt = r - numr[0][i];\n      int pos = upper_bound(numr[1].begin(), numr[1].end(), cnt) - numr[1].begin();\n      if(pos < numr[1].size()) ans = min(ans,numl[0][i] + numl[1][pos]);\n      pos = max(0,pos-1);\n      if(numr[0][i] + numr[1][pos] >= r) ans = min(ans,numl[0][i] + numl[1][pos]);\n    }\n    int pos = upper_bound(numr[1].begin(), numr[1].end(), r) - numr[1].begin();\n    if(pos < numr[1].size()) ans = min(ans,numl[1][pos]);\n    pos = max(0,pos-1);\n    if(numr[1][pos] >= r) ans = min(ans,numl[1][pos]);\n\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define PB push_back\n#define ALL(V) V.begin(), V.end()\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, int> ppiii;\n\nconstexpr int INF = 1LL<<60;\nconstexpr int MOD = 1000000007;\n//constexpr int MAX_N = 100005;\nconstexpr int dx[] = {-1, 0, 1, 0};\nconstexpr int dy[] = {0, -1, 0, 1};\n\nint r, w[2], h[2], ex[2], ey[2], fld[2][505][505], d[2][505][505];\n\nvector<pii> lvs[2];\nvector<int> templvs[2];\n\nvoid Dijkstra(int k) {\n    fill(d[k][0], d[k][505], INF);\n    priority_queue<pipii, vector<pipii>, greater<pipii>> pq;\n    d[k][ex[k]][ey[k]] = 1;\n    pq.push({1, {ex[k], ey[k]}});\n\n    while (pq.size()) {\n        pipii p = pq.top();\n        pq.pop();\n        int x = p.second.first, y = p.second.second;\n        if (d[k][x][y] < p.first) continue;\n\n        for (int i = 0; i < 4; ++i) {\n            int tx = x + dx[i], ty = y + dy[i], lv = max(p.first, fld[k][tx][ty]);\n            if (fld[k][tx][ty] == 0) continue;\n            if (d[k][tx][ty] <= lv) continue;\n            d[k][tx][ty] = lv;\n            pq.push({lv, {tx, ty}});\n        }\n    }\n}\n\nbool Solve() {\n    cin >> r;\n    if (r == 0) return false;\n    memset(fld, 0, sizeof(fld));\n\n    for (int i = 0; i < 2; ++i) {\n        cin >> w[i] >> h[i] >> ex[i] >> ey[i]; \n\n        for (int y = 1; y <= h[i]; ++y) {\n            for (int x = 1; x <= w[i]; ++x) {\n                cin >> fld[i][x][y];\n            }\n        }\n    }\n\n    Dijkstra(0);\n    Dijkstra(1);\n\n    for (int i = 0; i < 2; ++i) {\n        lvs[i].clear();\n        templvs[i].clear();\n\n        for (int y = 1; y <= h[i]; ++y) {\n            for (int x = 1; x <= w[i]; ++x) {\n                templvs[i].PB(d[i][x][y]);\n            }\n        }\n\n        sort(ALL(templvs[i]));\n        templvs[i].PB(INF);\n        lvs[i].PB({0, 0});\n        for (int j = 0; j < templvs[i].size(); ++j) {\n            for (int c = 1; j + c <= templvs[i].size(); ++c) {\n                if (templvs[i][j + c - 1] == templvs[i][j]) continue;\n                c--;\n                lvs[i].PB({templvs[i][j], c + lvs[i][lvs[i].size() - 1].second});\n                j += c - 1;\n                break;\n            }\n        }\n        lvs[i].PB({INF, INF});\n    }\n\n    int ans = INF;\n    for (int i = 0; i < lvs[0].size(); ++i) {\n        int cnt = lvs[0][i].second;\n        if (cnt + w[1] * h[1] < r) continue;\n\n        int s = 0, t = lvs[1].size();\n        while (1 < t - s) {\n            int mid = (s + t) / 2;\n            if (cnt + lvs[1][mid].second < r) {\n                s = mid + 1;\n            } else {\n                t = mid;\n            }\n        }\n        ans = min(ans, lvs[0][i].first + lvs[1][s].first);\n    }\n\n    cout << ans << endl;\n\n    return true;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while(Solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef tuple<int,int,int> tri;\n\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint r,w,h,x,y;\nint g[555][555];\nbool vis[555][555];\n\nint main(){\n  while(scanf(\"%d\",&r), r){\n    vector<pii> num[2];\n\n    for(int id=0;id<2;id++){\n      scanf(\"%d%d%d%d\",&w,&h,&x,&y);\n      x--; y--;\n      for(int i=0;i<h;i++){\n\tfor(int j=0;j<w;j++)scanf(\"%d\",&g[i][j]);\n      }\n\n      memset(vis,0,sizeof(vis));\n      vis[y][x] = true;\n      priority_queue<tri> q;\n      q.push(tri(-g[y][x],y,x));\n\n      int cnt = 0, val = 0;\n      while(q.size()){\n\tnum[id].push_back(pii(cnt,val));\n\t\n\tdo{\n\t  cnt++;\n\t  y = get<1>(q.top()); x = get<2>(q.top());\n\t  val = min(val, get<0>(q.top()) );\n\t  q.pop();\n\t  \n\t  for(int i=0;i<4;i++){\n\t    int ny = y+dy[i], nx = x+dx[i];\n\t    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n\t    if(vis[ny][nx])continue;\n\t    vis[ny][nx] = true;\n\t    q.push(tri(-g[ny][nx],ny,nx));\n\t  }\n\t}while(q.size() && get<0>(q.top()) >= val);\n      }\n      num[id].push_back(pii(cnt,val));\n    }\n    \n    int ans = 1e9, rev_ite = num[1].size() - 1;\n    for(int i=0;i<(int)num[0].size();i++){\n      while(rev_ite>=0 && num[0][i].first + num[1][rev_ite].first >= r)rev_ite--;\n      rev_ite++;\n      if(num[0][i].first + num[1][rev_ite].first >= r){\n\tans = min(ans, - num[0][i].second - num[1][rev_ite].second);\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n//#define int long long \n#define rep(i,n) for(int i=0;i<n;i++)\n#define mp make_pair\nconst int INF=1001001001;\nint W[2],H[2],X[2],Y[2];\nint L[2][502][502];\nvector<int> levs[2];//????????????????¨???¬??????sorted\nvector<int> levtoheya[2];//???????????¨????????¬?????????????????????????????¨?±??????°\nint solve(){\n     int R;\n     scanf(\"%d\",&R);\n     if(R==0)return -1;\n    rep(k,2){\n        if(levs[k].size())levs[k].clear();\n        if(levtoheya[k].size())levtoheya[k].clear();\n        levs[k].push_back(0);\n        scanf(\"%d %d %d %d\",&W[k],&H[k],&X[k],&Y[k]);\n        X[k]--;Y[k]--;\n        rep(i,H[k]){\n            rep(j,W[k]){\n                scanf(\"%d\",&L[k][j][i]);\n                levs[k].push_back( L[k][j][i] );\n            }\n            \n        }\n        sort(levs[k].begin(),levs[k].end() );\n        levs[k].erase( unique(levs[k].begin(),levs[k].end() ), levs[k].end() );\n    }\n    rep(k,2){\n        int heya=1;//??????????????¨?±???°\n        queue< pair<int,int> > q1; \n        queue< pair<int,int> > q2;\n        queue< pair<int,int> > qnull;\n        q2.push( mp(X[k],Y[k] ) );\n        bool ifgo[500][500];\n        fill(ifgo[0],ifgo[500],false);\n        ifgo[X[k]][Y[k]]=true;\n        rep(x,levs[k].size() ){//????????????x????¢???????????????¨?????????????????¨?±??????°??????????¢????\n            if(x==0){levtoheya[k].push_back(0);continue;}\n            int NX=levs[k][x];\n            //que2?????????????????????(??¨??????????????\\????????¨?±??????????)?????¨?±????????????¬??????x?????¨?±??????????????????¨?±???°????¢???????\n            q1=q2;q2=qnull;\n            while( q1.size() ){\n                pair<int,int> n=q1.front(); q1.pop();\n                int nx=n.first;int ny=n.second;\n                bool ifaround=false;\n                if(nx>0){\n                    if(L[k][nx-1][ny]<=NX){if(!ifgo[nx-1][ny]){q1.push(mp(nx-1,ny) );ifgo[nx-1][ny]=true;heya++;} }else ifaround=true;\n                }\n                if(ny>0){\n                    if(L[k][nx][ny-1]<=NX){if(!ifgo[nx][ny-1]){q1.push(mp(nx,ny-1) );ifgo[nx][ny-1]=true;heya++;} }else ifaround=true;\n                }\n                if(nx+1<W[k]){\n                    if(L[k][nx+1][ny]<=NX){if(!ifgo[nx+1][ny]){q1.push(mp(nx+1,ny));ifgo[nx+1][ny]=true;heya++;} }else ifaround=true;\n                }\n                if(ny+1<H[k]){\n                    if(L[k][nx][ny+1]<=NX){if(!ifgo[nx][ny+1]){q1.push(mp(nx,ny+1) );ifgo[nx][ny+1]=true;heya++;} }else ifaround=true;\n                }\n                if(ifaround){q2.push(mp(nx,ny));}\n            }\n            levtoheya[k].push_back(heya);\n        }\n    }\n    //levtoheya??????????????????????????????????±???????\n    int ans=INF;\n    rep(i,levtoheya[0].size()){\n        int mi=lower_bound(levtoheya[1].begin(),levtoheya[1].end(), R-levtoheya[0][i] )-levtoheya[1].begin();\n        if(mi>=levtoheya[1].size())continue;\n        int sans=levs[0][i]+levs[1][mi];\n        ans=min(ans,sans);\n    }\n    return ans;\n}\nsigned main(){\n    while(1){\n    int ans=solve();\n    if(ans<0)break;\n    printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pint;\ntypedef pair<ll, int> P;\n//typedef tuple<int,int,int> T;\nll INFL = 1000000000000000010;//10^18 = 2^60\nint INF = 2147483600;//10^9\nll MOD  = 1000000007;\nint solve(){\n    vector<int> dy(4);\n    vector<int> dx(4);\n    dy.at(0) = 0;\n    dy.at(1) = 0;\n    dy.at(2) = 1;\n    dy.at(3) = -1;\n    dx.at(0) = 1;\n    dx.at(1) = -1;\n    dx.at(2) = 0;\n    dx.at(3) = 0;\n    \n    int R;\n    cin >> R;\n    if(R == 0)return 0;\n    int H1,W1,X1,Y1;\n    cin >> W1 >> H1 >> X1 >> Y1;\n    X1--;\n    Y1--;\n    vector<vector<ll>> mp1(H1, vector<ll>(W1));\n    vector<vector<ll>> d1(H1, vector<ll>(W1, INFL));\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            cin >> mp1[i][j];\n        }\n    }\n    \n    d1[Y1][X1] = 1;\n    priority_queue<pair<ll, pair<int, int>>> pque1;\n    pque1.push({1, {Y1, X1}});\n    \n    while(!pque1.empty()){\n        ll c;\n        int y,x;\n        c = pque1.top().first;\n        y = pque1.top().second.first;\n        x = pque1.top().second.second;\n        pque1.pop();\n        if(c > d1[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H1 && 0 <= nx && nx < W1){\n                if(d1[ny][nx] > d1[y][x]){\n                    if(d1[y][x] > mp1[ny][nx]){\n                        d1[ny][nx] = d1[y][x];\n                    }else{\n                        d1[ny][nx] = mp1[ny][nx];\n                    }\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }else if(d1[ny][nx] > d1[y][x]){\n                    d1[ny][nx] = mp1[ny][nx];\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    int H2,W2,X2,Y2;\n    cin >> W2 >> H2 >> X2 >> Y2;\n    X2--;\n    Y2--;\n    vector<vector<ll>> mp2(H2, vector<ll>(W2));\n    vector<vector<ll>> d2(H2, vector<ll>(W2, INFL));\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            cin >> mp2[i][j];\n        }\n    }\n    \n    d2[Y2][X2] = 1;\n    priority_queue<pair<ll, pair<int, int>>> pque2;\n    pque2.push({1, {Y2, X2}});\n    \n    while(!pque2.empty()){\n        ll c;\n        int y,x;\n        c = pque2.top().first;\n        y = pque2.top().second.first;\n        x = pque2.top().second.second;\n        pque2.pop();\n        if(c > d2[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H2 && 0 <= nx && nx < W2){\n                if(d2[ny][nx] > d2[y][x]){\n                    if(d2[y][x] > mp2[ny][nx]){\n                        d2[ny][nx] = d2[y][x];\n                    }else{\n                        d2[ny][nx] = mp2[ny][nx];\n                    }\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }else if(d2[ny][nx] > d2[y][x]){\n                    d2[ny][nx] = mp2[ny][nx];\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    vector<pair<ll,int>> O1(0);\n    vector<ll> COST1(0);\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            COST1.push_back(d1[i][j]);\n        }\n    }\n    sort(COST1.begin(), COST1.end());\n    COST1.push_back(INFL);\n    ll ad1 = COST1.at(0);\n    int cnt = 0;\n    for(int i = 0; i < COST1.size(); i++){\n        if(ad1 == COST1.at(i)){\n            cnt++;\n        }else{\n            O1.push_back({ad1, cnt});\n            ad1 = COST1.at(i);\n            cnt++;\n        }\n    }\n    \n    vector<pair<ll,int>> O2(1);\n    O2.at(0).first = 0;\n    O2.at(0).second = 0;\n    vector<ll> COST2(0);\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            COST2.push_back(d2[i][j]);\n        }\n    }\n    sort(COST2.begin(), COST2.end());\n    COST2.push_back(INFL);\n    ll ad2 = COST2.at(0);\n    cnt = 0;\n    for(int i = 0; i < COST2.size(); i++){\n        if(ad2 == COST2.at(i)){\n            cnt++;\n        }else{\n            O2.push_back({ad2, cnt});\n            ad2 = COST2.at(i);\n            cnt++;\n        }\n    }\n    \n    ll ans = INFL;\n    for(int i = 0; i < O1.size(); i++){\n        ll cost = O1.at(i).first;\n        int rest = R - O1.at(i).second;\n        \n        if(rest > O2.at(O2.size()-1).second) continue;\n        int left = -1, right = O2.size();\n        int mid;\n        while(right - left > 1){\n            mid = (left + right) / 2;\n            if(O2.at(mid).second >= rest){\n                right = mid;\n            }else{\n                left = mid;\n            }\n        }\n        cost += O2.at(right).first;\n        ans = min(ans, cost);\n        \n    }\n    \n    cout << ans << endl;\n    \n    solve();\n    return 0;\n}\n\nint main(void){\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//56\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nstruct R{\n  int s,x,y;\n  bool operator<(R a)const{\n    return s>a.s;\n  }\n};\n\nint main(){\n  for(int r;cin>>r,r;){\n    static int w[2],h[2],x[2],y[2],g[2][500][500];\n    vector<int> nr[2],sl[2];\n    for(int i=0;i<2;i++){\n      cin>>w[i]>>h[i]>>x[i]>>y[i];\n      for(int j=0;j<h[i];j++){\n\tfor(int k=0;k<w[i];k++){\n\t  cin>>g[i][j][k];\n\t}\n      }\n      int p=0,cn=0;\n      priority_queue<R> que;\n      R is={1,x[i]-1,y[i]-1};\n      que.push(is);\n      while(!que.empty()){\n\tR c=que.top();\n\tque.pop();\n\tif(g[i][c.y][c.x]==0)continue;\n\tif(c.s>p){\n\t  nr[i].push_back(cn);\n\t  sl[i].push_back(p);\n\t  p=c.s;\n\t}\n\tcn++;\n\tg[i][c.y][c.x]=0;\n\tfor(int j=0;j<4;j++){\n\t  int d[]={0,1,0,-1,0};\n\t  int nx=c.x+d[j];\n\t  int ny=c.y+d[j+1];\n\t  if(0<=nx&&nx<w[i]&&0<=ny&&ny<h[i]){\n\t    R n={g[i][ny][nx],nx,ny};\n\t    que.push(n);\n\t  }\n\t}\n      }\n      nr[i].push_back(cn);\n      sl[i].push_back(p);\n    }\n    int m=1<<30;\n    for(int i=0;i<nr[0].size();i++){\n      int x=lower_bound(nr[1].begin(),nr[1].end(),r-nr[0][i])-nr[1].begin();\n      if(x!=nr[1].size()){\n\tm=min(m,sl[0][i]+sl[1][x]);\n      }\n    }\n    cout<<m<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<fstream>\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint r;\nint w[2],h[2];\nint x[2],y[2];\nint dx[4]={0,0,-1,1},dy[4]={1,-1,0,0};\nint field[2][501][501];\nbool used[2][501][501];\nint INF=300000000;\nint dp[2][100001];\nint ans;\n\nvoid dfs(int i,int sx,int sy){\n\tpriority_queue<PP , vector<PP> , greater<PP> > que;\n\tint fl=1;\n\tque.push(PP(field[i][sx][sy],P(sx,sy)));\n\tused[i][sx][sy]=true;\n\twhile(que.size() && fl<=100000){\n\t\tPP q=que.top();que.pop();\n\t\tint c=q.first;\n\t\tint mx=q.second.first,my=q.second.second;\n\t\tdp[i][fl]=max(dp[i][fl-1],c);\n\t\tfl++;\n\t\tfor(int j=0;j<4;j++){\n\t\t\tint nx=mx+dx[j],ny=my+dy[j];\n\t\t\tif(nx>=0 && nx<w[i] && ny>=0 && ny<h[i] && used[i][nx][ny]==false){\n\t\t\t\tque.push(PP(field[i][nx][ny],P(nx,ny)));\n\t\t\t\tused[i][nx][ny]=true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\tint st2=1;\n\twhile(1){\n\t\tcin >> r;\n\t\tif(r==0)break;\n\t\tfor(int i=1;i<=100000;i++)dp[0][i]=dp[1][i]=INF;\n\t\tdp[0][0]=dp[1][0]=0;\n\t\tmemset(field,0,sizeof(field));\n\t\tmemset(used,false,sizeof(used));\n\t\tcin >> w[0] >> h[0] >> x[0] >> y[0];\n\t\tfor(int i=0;i<h[0];i++){\n\t\t\tfor(int j=0;j<w[0];j++){\n\t\t\t\tcin >> field[0][j][i];\n\t\t\t}\n\t\t}\n\t\tcin >> w[1] >> h[1] >> x[1] >> y[1];\n\t\tfor(int i=0;i<h[1];i++){\n\t\t\tfor(int j=0;j<w[1];j++){\n\t\t\t\tcin >> field[1][j][i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<2;i++)dfs(i,x[i]-1,y[i]-1);\n\t\tans=INF;\n\n\t\tfor(int i=0;i<=r;i++){\n\t\t\tans=min(ans,dp[0][i]+dp[1][r-i]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint l[2][500][500];\nbool c[2][500][500];\nint memo[2][100001];\n\nstruct level{\n  int l;\n  int x;\n  int y;\n  level(int a,int b,int c){\n    l=a; x=b; y=c;\n  }\n};\n\nbool operator < (const level &a, const level &b){\n  return a.l > b.l;\n}\n\nint main(){\n  int r;\n  while(r = getInt()){\n    int w[2],h[2],x[2],y[2];\n    REP(k,2){\n      w[k] = getInt();\n      h[k] = getInt();\n      x[k] = getInt() - 1;\n      y[k] = getInt() - 1;\n      REP(i,h[k]) REP(j,w[k]){\n        l[k][i][j] = getInt();\n        c[k][i][j] = false;\n      }\n\n      priority_queue<level> pq;\n      pq.push(level(1,x[k],y[k]));\n      c[k][y[k]][x[k]] = true;\n\n      int cnt = 0;\n      int now = 1;\n\n      memo[k][cnt++] = 0;\n      while(!pq.empty()){\n        level lv = pq.top();\n        int ll = lv.l;\n        int xx = lv.x;\n        int yy = lv.y;\n        pq.pop();\n        //printf(\"%d %d %d\\n\",ll,xx,yy);\n\n        memo[k][cnt++] = (now = max(ll, now));\n        if(cnt == w[k]*h[k] + 1) break;\n\n        REP(i,4){\n          int xxx = xx + _dx[i];\n          int yyy = yy + _dy[i];\n\n          if(ISIN(xxx,yyy,w[k],h[k]) && !c[k][yyy][xxx]){\n            c[k][yyy][xxx] = true;\n            pq.push(level(l[k][yyy][xxx], xxx, yyy));\n          }\n        }\n      }\n\n      //REP(i, w[k]*h[k]+1) printf(\"%d \",memo[k][i]); puts(\"\");\n    }\n\n    int end = min(r, w[0] * h[0]) + 1;\n    int start = max(0, r - w[1] * h[1]);\n    int ans = INT_MAX;\n    rep(i,start,end)\n      ans = min(ans, memo[0][i] + memo[1][r-i]);\n    print(ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\nusing namespace std;\ntypedef pair<int,int> P;\nconst int MAXH = 501;\nconst int MAXW = 501;\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\nint R;\nint W[2], H[2], X[2], Y[2];\nint L[2][MAXH][MAXW];\nint lev[2][MAXH][MAXW];\n\nvoid bfs(int k) {\n  priority_queue<pair<int,P>, vector<pair<int,P> >, greater<pair<int,P> > > que;\n  fill(lev[k][0], lev[k][MAXH], -1);\n  que.push(make_pair(L[k][Y[k]][X[k]],P(X[k],Y[k])));\n  while(!que.empty()) {\n    P p = que.top().second;\n    int l = que.top().first;\n    que.pop();\n    if(lev[k][p.second][p.first] != -1) continue;\n    lev[k][p.second][p.first] = l;\n    for(int i = 0; i < 4; ++i) {\n      int nx = p.first + dx[i];\n      int ny = p.second + dy[i];\n      if(nx < 0 || nx >= W[k]) continue;\n      if(ny < 0 || ny >= H[k]) continue;\n      if(lev[k][ny][nx] != -1) continue;\n      que.push(make_pair(max(l,L[k][ny][nx]),P(nx,ny)));\n    }\n  }\n}\n\nint solve() {\n  vector<pair<int,int> > v[2];\n  for(int k = 0; k < 2; ++k) {\n    bfs(k);\n    map<int,int> m;\n    m[0] = 0;\n    for(int i = 0; i < H[k]; ++i) {\n      for(int j = 0; j < W[k]; ++j) {\n\t++m[lev[k][i][j]];\n      }\n    }\n    v[k] = vector<pair<int,int> >(m.begin(), m.end());\n    for(int i = 1; i < v[k].size(); ++i) v[k][i].second += v[k][i-1].second;\n  }\n  for(int i = 0; i < v[1].size(); ++i) swap(v[1][i].first, v[1][i].second);\n  sort(v[1].begin(), v[1].end());\n  int res = (1<<28);\n  for(int i = 0; i < v[0].size(); ++i) {\n    int tmp = lower_bound(v[1].begin(), v[1].end(), P(R-v[0][i].second, -(1<<28)))->second;\n    res = min(res, v[0][i].first + tmp);\n  }\n  return res;\n}\n\nint main() {\n  while(cin >> R && R) {\n    for(int k = 0; k < 2; ++k) {\n      cin >> W[k] >> H[k] >> X[k] >> Y[k];\n      --X[k]; --Y[k];\n      for(int i = 0; i < H[k]; ++i) {\n\tfor(int j = 0; j < W[k]; ++j) {\n\t  cin >> L[k][i][j];\n\t}\n      }\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n \n#define mp  make_pair\n#define pb  push_back\n \nusing namespace std;\n \ntypedef pair<int,int> pii;\n \nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n \nint main(){\n    for(int r;scanf(\"%d\",&r),r;){\n        int w[2],h[2],x[2],y[2];\n        static int room[2][500][500];\n        static int roomcnt[2][100001];\n        for(int k=0;k<2;k++){\n            scanf(\"%d%d%d%d\",&w[k],&h[k],&x[k],&y[k]);\n            x[k]--,y[k]--;\n            for(int i=0;i<h[k];i++)for(int j=0;j<w[k];j++)    scanf(\"%d\",&room[k][i][j]);\n \n            for(int i=0;i<=r;i++)    roomcnt[k][i]=1<<30;\n            roomcnt[k][0]=0;\n \n            static bool visited[500][500];\n            for(int i=0;i<h[k];i++)for(int j=0;j<w[k];j++)    visited[i][j]=false;\n            visited[y[k]][x[k]]=true;\n            int cnt=0,lev=0;\n            priority_queue< pair<int,pii> > pq;\n            pq.push(mp(-room[k][y[k]][x[k]],mp(y[k],x[k])));\n            while(!pq.empty()){\n                pair<int,pii> a=pq.top(); pq.pop();\n                int nowlev=-a.first,x=a.second.second,y=a.second.first;\n                cnt++;\n                if(lev<nowlev)   lev=nowlev;\n                roomcnt[k][cnt]=lev;\n                if(cnt==r)  break;\n \n                for(int i=0;i<4;i++){\n                    int xx=x+dx[i],yy=y+dy[i];\n                    if(0<=xx && xx<w[k] && 0<=yy && yy<h[k] && !visited[yy][xx]){\n                        pq.push(mp(-room[k][yy][xx],mp(yy,xx)));\n                        visited[yy][xx]=true;\n                    }\n                }\n            }\n        }\n \n        int ans=1<<30;\n        for(int i=0;i<=r;i++)    ans=min(ans,roomcnt[0][i]+roomcnt[1][r-i]);\n        printf(\"%d\\n\",ans);\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<queue>\nusing namespace std;\n\nconst int dy[4]={-1,0,1,0},dx[4]={0,1,0,-1};\nint needlev[2][100002];\nint fld[500][500];\n\nstruct Data{\n\tint y,x,lev;\n\tData(){}\n\tData(int _y,int _x,int _lev){\n\t\ty=_y; x=_x; lev=_lev;\n\t}\n\tbool operator<(const Data &a)const{\n\t\treturn lev>a.lev;\n\t}\n};\n\nint main(){\n\tint W,H,X,Y,R;\n\twhile(cin>>R,R){\n\t\tvector<int> r[2];\n\t\tfor(int K=0;K<2;K++){\n\t\t\tpriority_queue<Data> q;\n\t\t\tcin>>W>>H>>X>>Y; X--; Y--;\n\t\t\tq.push(Data(Y,X,1));\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tcin>>fld[i][j];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint cntR=0;\n\t\t\tData q_c;\n\t\t\tbool used[500][500]={};\n\t\t\tused[Y][X] = true;\n\t\t\tneedlev[K][0] = needlev[K][R+1] = 0;\n\t\t\twhile(!q.empty()){\n\t\t\t\tq_c = q.top(); q.pop();\n\t\t\t\tcntR++;\n\t\t\t\t//printf(\"%d: %d,%d,%d\\n\",cntR,q_c.y,q_c.x,q_c.lev);\n\t\t\t\tneedlev[K][cntR] = q_c.lev;\n\t\t\t\tif(cntR==R) break;\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint ny = q_c.y+dy[i],\n\t\t\t\t\t\tnx = q_c.x+dx[i];\n\t\t\t\t\tif(ny<0 || H<=ny || nx<0 || W<=nx || used[ny][nx])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tused[ny][nx] = true;\n\t\t\t\t\tq.push(Data(ny,nx,max(q_c.lev,fld[ny][nx])));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<=cntR;i++){\n\t\t\t\tif(needlev[i]!=needlev[i+1]){\n\t\t\t\t\tr[K].push_back(i);\n\t\t\t\t\t//printf(\"%d \",i);\n\t\t\t\t}\n\t\t\t}//puts(\"\");\n\t\t}\n\t\tint ans=1000000000;\n\t\tfor(int i=0;i<r[0].size();i++){\n\t\t\tvector<int>::iterator itr = lower_bound(r[1].begin(),r[1].end(),R-r[0][i]);\n\t\t\tif(itr!=r[1].end())\n\t\t\t\tans = min(ans,needlev[0][r[0][i]]+needlev[1][*itr]);\n\t\t}\n\t\tprintf(\"\\t%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint w,h,x,y,a[505][505],b[505][505],c[505][505];\n\npair<int,int> make_P(int ma,int mb){pair<int,int> ret; ret.first=ma; ret.second=mb; return ret;}\n\npair<int,pair<int,int>> make_PP(int ma,pair<int,int> mb){pair<int,pair<int,int>> ret; ret.first=ma; ret.second=mb; return ret;}\n\nbool f(pair<int,pair<int,int>> fx,pair<int,pair<int,int>> fy){return fx.first<=fy.first;}\n\nvoid ww(int wx,int wy){\n\tc[wx][wy]=1;\n\tif(b[wx][wy+1]==1&&c[wx][wy+1]==0)ww(wx,wy+1);\n\tif(b[wx][wy-1]==1&&c[wx][wy-1]==0)ww(wx,wy-1);\n\tif(b[wx+1][wy]==1&&c[wx+1][wy]==0)ww(wx+1,wy);\n\tif(b[wx-1][wy]==1&&c[wx-1][wy]==0)ww(wx-1,wy);\n}\n\nvector<int> els(vector<int> vp){\n\tvector<int> ret;\n\tint s=vp.size();\n\tret.push_back(vp[0]);\n\tfor(int i=1;i<s;i++){\n\t\tif(vp[i]!=vp[i-1])ret.push_back(vp[i]);\n\t}\n\treturn ret;\n}\n\nvector<pair<int,int>> office(){\n\tfor(int i=0;i<505;i++)for(int j=0;j<505;j++){b[i][j]=0; c[i][j]=0;}\n\tvector<pair<int,pair<int,int>>> v;\n\tfor(int i=1;i<=h;i++)for(int j=1;j<=h;j++)v.push_back(make_PP(a[i][j],make_P(i,j)));\n\tsort(v.begin(),v.end(),f);\n\t//v=els(v);\n\tvector<pair<int,int>> ret;\n\tret.push_back(make_P(0,0));\n\tint s=v.size();\n\tb[x][y]=1; c[x][y]=1;\n\tfor(int i=0;i<s;i++){\n\t\t/*for(int j=1;j<=h;j++)for(int k=1;k<=w;k++){\n\t\t\tif(a[j][k]==v[i]){\n\t\t\t\tb[j][k]=1;\n\t\t\t\tif(c[j][k+1]+c[j][k-1]+c[j+1][k]+c[j-1][k]!=0)ww(j,k);\n\t\t\t}\n\t\t}*/\n\t\t//b[v[i].second.first][v[i].second.second]=1;\n\t\t//if(c[v[i].second.first][v[i].second.second+1]+c[v[i].second.first][v[i].second.second-1]+c[v[i].second.first+1][v[i].second.second]+c[v[i].second.first-1][v[i].second.second]!=0)ww(v[i].second.first,v[i].second.second);\n\t\tint sum=0;\n\t\tfor(int j=1;j<=h;j++)for(int k=1;k<=w;k++)sum+=c[j][k];\n\t\tret.push_back(make_P(v[i].first,sum));\n\t}\n\treturn ret;\n}\n\nint main(){\nwhile(1){\n\tint r,s[2];\n\tscanf(\"%d\",&r);\n\tif(r==0)break;\n\tvector<pair<int,int>> vvp[2];\n\tfor(int i=0;i<=1;i++){\n\t\tfor(int k=0;k<505;k++)for(int j=0;j<505;j++)a[k][j]=0;\n\t\tscanf(\"%d%d%d%d\",&w,&h,&x,&y);\n\t\tfor(int j=1;j<=h;j++)for(int k=1;k<=w;k++)scanf(\"%d\",&a[j][k]);\n\t\tvvp[i]=office();\n\t\ts[i]=vvp[i].size();\n\t}\n\tint n=s[1]-1,ret=200000000;\n\tfor(int i=0;i<s[0];i++){\n\t\tif(n!=0)while(vvp[0][i].second+vvp[1][n-1].second>=r){n--; if(n==0)break;}\n\t\tif(vvp[0][i].second+vvp[1][n].second>=r)ret=min(ret,vvp[0][i].first+vvp[1][n].first);\n\t}\n\tprintf(\"%d\\n\",ret);\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <tuple>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nconst vector<int> dx = { 0, 1, 0, -1 };\nconst vector<int> dy = { -1, 0, 1, 0 };\n\nint R, W[2], H[2], X[2], Y[2], F[2][500][500], D[2][500][500], L[2];\n\nint main()\n{\n\tscanf(\"%d\", &R);\n\n\tfor (int i = 0; i < 2; i++)\n\t{\n\t\tscanf(\"%d\", &W[i]);\n\t\tscanf(\"%d\", &H[i]);\n\t\tscanf(\"%d\", &X[i]); X[i]--;\n\t\tscanf(\"%d\", &Y[i]); Y[i]--;\n\n\t\tfor (int j = 0; j < H[i]; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < W[i]; k++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &F[i][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\n\tmemset(D, -1, sizeof(D));\n\n\tfor (int i = 0; i < 2; i++)\n\t{\n\t\tD[i][Y[i]][X[i]] = 1;\n\n\t\tpriority_queue<tuple<int, int, int>, vector<tuple<int, int, int> >, greater<tuple<int, int, int> > > que;\n\n\t\tque.push(make_tuple(0, X[i], Y[i]));\n\n\t\twhile (!que.empty())\n\t\t{\n\t\t\ttuple<int, int, int> state = que.top(); que.pop();\n\n\t\t\tint d = get<0>(state);\n\t\t\tint x = get<1>(state);\n\t\t\tint y = get<2>(state);\n\n\t\t\tfor (int dir = 0; dir < 4; dir++)\n\t\t\t{\n\t\t\t\tint x2 = x + dx[dir];\n\t\t\t\tint y2 = y + dy[dir];\n\n\t\t\t\tif (0 <= x2 && x2 < W[i] && 0 <= y2 && y2 < H[i])\n\t\t\t\t{\n\t\t\t\t\tif (D[i][y2][x2] == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tD[i][y2][x2] = max(d, F[i][y2][x2]);\n\n\t\t\t\t\t\tque.push(make_tuple(D[i][y2][x2], x2, y2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<int> E[2];\n\n\tfor (int i = 0; i < 2; i++)\n\t{\n\t\tfor (int j = 0; j < H[i]; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < W[i]; k++)\n\t\t\t{\n\t\t\t\tE[i].push_back(D[i][j][k]);\n\t\t\t}\n\t\t}\n\n\t\tsort(E[i].begin(), E[i].end());\n\t}\n\n\tint ret = 999999999;\n\n\tfor (int i = 0; i <= R; i++)\n\t{\n\t\tL[0] = i;\n\t\tL[1] = R - i;\n\n\t\tint cost = 0;\n\n\t\tfor (int j = 0; j < 2; j++)\n\t\t{\n\t\t\tint cl = 0;\n\t\t\tint cr = 1000000000;\n\n\t\t\twhile (cr - cl > 1)\n\t\t\t{\n\t\t\t\tint cm = (cl + cr) / 2;\n\n\t\t\t\tint counts = upper_bound(E[j].begin(), E[j].end(), cm) - E[j].begin();\n\n\t\t\t\tif (counts < L[0])\n\t\t\t\t{\n\t\t\t\t\tcl = cm;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcr = cm;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcost += cr;\n\t\t}\n\n\t\tret = min(ret, cost);\n\t}\n\n\tprintf(\"%d\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <vector>\n#include <functional>\n#include <cstring>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\ntypedef pair<int,int> mp;\ntypedef pair<int,mp> mmp;\n#define min(a,b) (((a)>(b))?(b):(a))\n#define MAX (100000005)\nint dir[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nint R;\n\nint eans[2][250005];\nint emap[2][505][505];\nclass evh{\npublic:\n\tint sx,sy,w,h;\n\tevh(int* ans,int map[][505]){\n\t\tscanf(\"%d%d%d%d\",&w,&h,&sx,&sy);\n\t\tsx--;sy--;\n\t\trep(y,h)\n\t\t\trep(x,w)scanf(\"%d\",&(map[x][y]));\n\t\t\n\t\tint no=1;\n\t\tans[0]=0;\n\t\tpriority_queue<mmp,vector<mmp>,greater<mmp> > que;\n\t\tque.push( mmp(1,mp(sx,sy)) );\n\t\twhile(!que.empty()){\n\t\t\tint nl=que.top().first;\n\t\t\t\n\t\t\twhile(!que.empty() && que.top().first<=nl){\n\t\t\t\tint nx=que.top().second.first,\n\t\t\t\t\tny=que.top().second.second;\n\t\t\t\tque.pop();\n\t\t\t\t\n\t\t\t\tif(map[nx][ny]==-1)continue;\n\t\t\t\tmap[nx][ny]=-1;\n\t\t\t\tans[no]=nl;\n\t\t\t\t//printf(\"kek  %d %d\\n\",no,ans[no]);\n\t\t\t\tno++;\n\t\t\t\t\n\t\t\t\trep(i,4){\n\t\t\t\t\tint dx=nx+dir[i][0],dy=ny+dir[i][1];\n\t\t\t\t\t//printf(\"pus %d %d\\n\",dx,dy);\n\t\t\t\t\tif(dx<0 || dx>=w || dy<0 || dy>=h || map[dx][dy]==-1)continue;\n\t\t\t\t\tque.push( mmp(map[dx][dy],mp(dx,dy)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nint main(void){\n\twhile(true){\n\t\tscanf(\"%d\",&R);\n\t\tif(R==0)break;\n\t\tmemset(eans,-1,sizeof(eans));\n\t\tevh evh1(eans[0],emap[0]);\n\t\tevh evh2(eans[1],emap[1]);\n\t\tint ans=MAX;\n\t\trep(i,R+1){\n\t\t\t//printf(\"res  %d %d %d\\n\",i,eans[0][i],eans[1][i]);\n\t\t\tif(eans[0][R-i]!=-1 && eans[1][i]!=-1){\n\t\t\t\tans=min(ans,eans[0][R-i]+eans[1][i]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reps(i,n) for(int i=1;i<=n;i++)\n\nconst int INF=1010000000;\n\nint R;\nint w[2],h[2],st[2],gl[2];\nint masu[2][501][501];\n\nint need[2][25001];\n\nint visit[501][501];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nint glcont;\n\nvoid saiki(int w,int h,int x,int y,int masu[501][501],int mn){\n\tif(x<0 || y<0 || x>=w || y>=h)return;\n\tif(masu[x][y]>mn)return;\n\tif(visit[x][y]==1)return;\n\tvisit[x][y]=1;\n\t\n\t\n\trep(i,4){\n\t\tsaiki(w,h,x+dx[i],y+dy[i],masu,mn);\n\t}\n\t\n\tglcont++;\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d\",&R);\n\t\tif(R==0)break;\n\t\t\n\t\trep(i,2){\n\t\t\tscanf(\"%d%d%d%d\",&w[i],&h[i],&st[i],&gl[i]);\n\t\t\t\n\t\t\trep(j,h[i]){\n\t\t\t\trep(k,w[i]){\n\t\t\t\t\tscanf(\"%d\",&masu[i][k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint left,right;\n\t\tleft=0;\n\t\tright=1000000001;\n\t\trep(i,2)rep(j,250001)need[i][j]=INF;\n\t\trep(i,2){\n\t\t\trep(n,w[i]*h[i]+1){\n\t\t\t\tint left,right;\n\t\t\t\tleft=0;right=1000000001;\n\t\t\t\t\n\t\t\t\twhile(1){\n\t\t\t\t\tdouble half= double(left+right)/2.0;\n\t\t\t\t\trep(rr,w[i])rep(ee,h[i])visit[rr][ee]=0;\n\t\t\t\t\tglcont=0;\n\t\t\t\t\t\n\t\t\t\t\tsaiki(w[i],h[i],st[i]-1,gl[i]-1,masu[i],int(half));\n\t\t\t\t\t\n\t\t\t\t\tif(glcont<n){\n\t\t\t\t\t\tleft=half+0.5;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tright=half;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(left==right){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tneed[i][n]=left;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint mini=INF*2+1;\n\t\t\n\t\tint dd=0;\n\t\tif(w[0]*h[0] < w[1]+h[1]){\n\t\t\tdd=1;\n\t\t}\n\t\t\n\t\trep(i,250001){\n\t\t\tif(R-i<0)break;\n\t\t\tmini = min(mini, need[dd][i] + need[!dd][R-i]);\n\t\t}\n\t\t/*\n\t\trep(i,2){\n\t\t\tputs(\"\");\n\t\t\trep(n,w[i]*h[i]+1){\n\t\t\t\tprintf(\"%d %d\\n\",n,need[i][n]);\n\t\t\t}\n\t\t}*/\n\t\tprintf(\"%d\\n\",mini);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n\nusing namespace std;\ntypedef pair<int,pair<int,int> > P;\ntypedef long long ll;\n\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\n\nint w[2],h[2],x[2],y[2];\nint r;\nint field[2][501][501];\nbool passed[501][501];\nmap<int,int> visitableRooms[2];\n\nint INF=1000000000;\n\nvoid bfs(int k,int sx,int sy){\n    // FØx1©çÔÉTõ\n    priority_queue<P,vector<P>,greater<P> > pq;\n    pq.push(make_pair(1,make_pair(sy,sx)));\n    // »ÝÌx\n    int cL=0;\n    // Kê½®Ì\n    int sum=0;\n    passed[sy][sx]=true;\n    while(pq.size()){\n        P p=pq.top();\n        pq.pop();\n        int level=p.first;\n        int cx=p.second.second;\n        int cy=p.second.first;\n        sum++;\n        // »ÝÌxðXV·éKvª êÎAXV·é\n        if(level>cL)\n            cL=level;\n        visitableRooms[k][cL]=sum;\n        for(int i = 0; i < 4; i++){\n            int ny=cy+dy[i];\n            int nx=cx+dx[i];\n            if(ny>=0&&nx>=0&&ny<h[k]&&nx<w[k]&&!passed[ny][nx]){\n                pq.push(P(field[k][ny][nx],make_pair(ny,nx)));\n                passed[ny][nx]=true;\n            }\n        }\n    }\n    if(visitableRooms[k].find(cL)==visitableRooms[k].end())\n        visitableRooms[k][cL]=sum;\n}\n\nint main(){\n    while(cin>>r&&r!=0){\n        for(int k = 0; k < 2; k++){\n            visitableRooms[k].clear();\n            cin>>w[k]>>h[k]>>x[k]>>y[k];\n            x[k]--;y[k]--;\n            for(int i = 0; i < h[k]; i++)\n                for(int j = 0; j < w[k]; j++)\n                    cin>>field[k][i][j];\n        }\n        for(int k = 0; k < 2; k++){\n            visitableRooms[k][0]=0;\n            memset(passed,0,sizeof(passed));\n            bfs(k,x[k],y[k]);\n        }\n        map<int,int>::iterator ait=visitableRooms[0].begin();\n        map<int,int>::iterator bit=visitableRooms[1].end();\n        bit--;\n        int minLevelSum=INF;\n        // »ê¼êÌiteratorð®©·\n        while(1){\n            int roomSum=(ait->second)+(bit->second);\n            if(roomSum>=r){\n                minLevelSum=min(minLevelSum,(int)(ait->first+bit->first));\n                if(bit==visitableRooms[1].begin())\n                    break;\n                bit--;\n            }\n            else{\n                ait++;\n                if(ait==visitableRooms[0].end())\n                    break;\n            }\n        }\n        cout<<minLevelSum<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n#include <algorithm>\n#include <limits.h>\nusing namespace std;\n\nstruct room \n{\n\tint level, x, y;\n\troom(int level, int x, int y)\n\t{ this->level = level, this->x = x, this->y = y; }\n\tbool operator < (room rhs) const\n\t{ return this->level > rhs.level; }\n};\n\nint map[2][500][500];\nbool visit[2][500][500];\nint result[2][100001];\n\nint main()\n{\n\tint r, w[2], h[2], sx[2], sy[2], tmp, sec, open, ans;\n\n\twhile(true) {\n\t\tscanf(\"%d\", &r);\n\t\tif(r == 0) break;\n\t\tfor(int i = 0; i < 2; ++i) {\n\t\t\tscanf(\"%d%d%d%d\", &w[i], &h[i], &sx[i], &sy[i]);\n\t\t\t--sx[i], --sy[i];\n\t\t\tfor(int y = 0; y < h[i]; ++y) {\n\t\t\t\tfor(int x = 0; x < w[i]; ++x) {\n\t\t\t\t\tscanf(\"%d\", &tmp);\n\t\t\t\t\tmap[i][x][y] = tmp;\n\t\t\t\t\tvisit[i][x][y] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 1; j <= r; ++j) result[i][j] = -1;\n\t\t\tresult[i][0] = 0;\n\t\t}\n\n\t\tpriority_queue<room> next;\n\t\tqueue<room> seek;\n\n\t\tfor(int i = 0; i < 2; ++i) {\n\t\t\topen = 0;\n\t\t\tsec = 0;\n\t\t\tnext.push(room(1, sx[i], sy[i]));\n\n\t\t\twhile(!next.empty() && open < r) {\n\t\t\t\tsec = next.top().level;\n\t\t\t\twhile(!next.empty()) {\n\t\t\t\t\troom m = next.top();\n\t\t\t\t\tif(m.level > sec) break;\n\t\t\t\t\tvisit[i][m.x][m.y] = true;\n\t\t\t\t\tseek.push(m);\n\t\t\t\t\tnext.pop();\n\t\t\t\t}\n\n\t\t\t\twhile(!seek.empty()) {\n\t\t\t\t\troom at = seek.front();\n\t\t\t\t\tseek.pop();\n\t\t\t\t\tresult[i][++open] = sec;\n\t\t\t\t\tfor(int rx = at.x - 1; rx < at.x + 2; ++rx) {\n\t\t\t\t\t\tfor(int ry = at.y - 1; ry < at.y + 2; ++ry) {\n\t\t\t\t\t\t\tif(abs(rx - at.x) + abs(ry - at.y) != 1) continue;\n\t\t\t\t\t\t\tif(rx < 0 || rx >= w[i] || ry < 0 || ry >= h[i]) continue;\n\t\t\t\t\t\t\tif(visit[i][rx][ry]) continue;\n\t\t\t\t\t\t\tif(map[i][rx][ry] <= sec) {\n\t\t\t\t\t\t\t\tseek.push(room(map[i][rx][ry], rx, ry));\n\t\t\t\t\t\t\t\tvisit[i][rx][ry] = true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnext.push(room(map[i][rx][ry], rx, ry));\n\t\t\t\t\t\t\t\tvisit[i][rx][ry] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 1; j <= open; ++j) {\n\t\t\t\tif(result[i][j] == -1)\n\t\t\t\t\tresult[i][j] = result[i][j - 1];\n\t\t\t\t//printf(\"%d \", result[i][j]);\n\t\t\t}\n\t\t\t//printf(\"\\n%d: open=%d level=%d\\n\", i, open, sec);\n\t\t}\n\t\t\n\t\tans = INT_MAX;\n\t\tfor(int i = 0; i <= r; ++i) {\n\t\t\tif(result[0][i] == -1 || result[1][r - i] == -1) continue;\n\t\t\tans = min(ans, result[0][i] + result[1][r - i]);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef pair<int,int> P;\nint R;\nint W1,H1,X1,Y1;\nint W2,H2,X2,Y2;\nint L1[501][501];\nint L2[501][501];\nint AA[250010];\nint BB[250010];\nint num11[250010];\nint num22[250010];\nbool field1[501][501];\nbool field2[501][501];\nvector<P>XX1;vector<P>XX2;\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nint solve1(int x,int y,int num){\n\tbool FF=true;\n\tfor(int k=0;k<4;k++){\n\t\tif(x+dx[k]<0)continue;\n\t\tif(x+dx[k]>=W1)continue;\n\t\tif(y+dy[k]<0)continue;\n\t\tif(y+dy[k]>=H1)continue;\n\t\tif(field1[y+dy[k]][x+dx[k]])FF=false;\n\t}\n\tif(FF)return 0;\n\tint res=0;\n\tqueue<P>que;\n\tque.push(P(y,x));\n\twhile(!que.empty()){\n\t\tP p=que.front();que.pop();\n\t\tint pf=p.first;int ps=p.second;\n\t\tif(field1[pf][ps])continue;\n\t\tfield1[pf][ps]=true;res++;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tif(ps+dx[k]<0)continue;\n\t\t\tif(ps+dx[k]>=W1)continue;\n\t\t\tif(pf+dy[k]<0)continue;\n\t\t\tif(pf+dy[k]>=H1)continue;\n\t\t\tif(L1[pf+dy[k]][ps+dx[k]]>num)continue;\n\t\t\tif(!field1[pf+dy[k]][ps+dx[k]])que.push(P(pf+dy[k],ps+dx[k]));\n\t\t}\n\t}\n\treturn res;\n}\nint solve2(int x,int y,int num){\n\tbool FF=true;\n\tfor(int k=0;k<4;k++){\n\t\tif(x+dx[k]<0)continue;\n\t\tif(x+dx[k]>=W2)continue;\n\t\tif(y+dy[k]<0)continue;\n\t\tif(y+dy[k]>=H2)continue;\n\t\tif(field2[y+dy[k]][x+dx[k]])FF=false;\n\t}\n\tif(FF)return 0;\n\tint res=0;\n\tqueue<P>que;\n\tque.push(P(y,x));\n\twhile(!que.empty()){\n\t\tP p=que.front();que.pop();\n\t\tint pf=p.first;int ps=p.second;\n\t\tif(field2[pf][ps])continue;\n\t\tfield2[pf][ps]=true;res++;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tif(ps+dx[k]<0)continue;\n\t\t\tif(ps+dx[k]>=W2)continue;\n\t\t\tif(pf+dy[k]<0)continue;\n\t\t\tif(pf+dy[k]>=H2)continue;\n\t\t\tif(L2[pf+dy[k]][ps+dx[k]]>num)continue;\n\t\t\tif(!field2[pf+dy[k]][ps+dx[k]])que.push(P(pf+dy[k],ps+dx[k]));\n\t\t}\n\t}\n\treturn res;\n}\nint main()\n{\n\twhile(true){\n\t\tXX1.clear();XX2.clear();\n\t\tscanf(\"%d\",&R);\n\t\tif(R==0)break;\n\t\tscanf(\"%d%d%d%d\",&W1,&H1,&X1,&Y1);\n\t\tfor(int i=0;i<H1;i++){\n\t\t\tfor(int j=0;j<W1;j++){\n\t\t\t\tscanf(\"%d\",&L1[i][j]);\n\t\t\t\tXX1.push_back(P(L1[i][j],i*W1+j));\n\t\t\t}\n\t\t}\n\t\tsort(XX1.begin(),XX1.end());\n\t\tfor(int i=0;i<H1;i++){\n\t\t\tfor(int j=0;j<W1;j++){\n\t\t\t\tfield1[i][j]=false;\n\t\t\t}\n\t\t}\n\t\tfield1[Y1-1][X1-1]=true;\n\t\tnum11[1]=1;\n\t\tfor(int i=2;i<=XX1.size();i++){\n\t\t\tnum11[i]=num11[i-1];\n\t\t\tnum11[i]+=solve1(XX1[i-1].second%W1,XX1[i-1].second/W1,XX1[i-1].first);\n\t\t}\n\t\tfor(int i=XX1.size();i>=2;i--){\n\t\t\tif(XX1[i-1].first==XX1[i-2].first){\n\t\t\t\tnum11[i-1]=num11[i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<XX1.size();i++){\n\t\t\t//printf(\"%d:%d\\n\",XX1[i].first,num11[i+1]);\n\t\t}\n\t\tscanf(\"%d%d%d%d\",&W2,&H2,&X2,&Y2);\n\t\tfor(int i=0;i<H2;i++){\n\t\t\tfor(int j=0;j<W2;j++){\n\t\t\t\tscanf(\"%d\",&L2[i][j]);\n\t\t\t\tXX2.push_back(P(L2[i][j],i*W2+j));\n\t\t\t}\n\t\t}\n\t\tsort(XX2.begin(),XX2.end());\n\t\tfor(int i=0;i<H2;i++){\n\t\t\tfor(int j=0;j<W2;j++){\n\t\t\t\tfield2[i][j]=false;\n\t\t\t}\n\t\t}\n\t\tfield2[Y2-1][X2-1]=true;\n\t\tnum22[1]=1;\n\t\tfor(int i=2;i<=XX2.size();i++){\n\t\t\tnum22[i]=num22[i-1];\n\t\t\tnum22[i]+=solve2(XX2[i-1].second%W2,XX2[i-1].second/W2,XX2[i-1].first);\n\t\t}\n\t\tfor(int i=XX2.size();i>=2;i--){\n\t\t\tif(XX2[i-1].first==XX2[i-2].first){\n\t\t\t\tnum22[i-1]=num22[i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<XX2.size();i++){\n\t\t\t//printf(\"%d:%d\\n\",XX2[i].first,num22[i+1]);\n\t\t}\n\t\tint ans=1000000000;\n\t\tfor(int i=0;i<=H1*W1;i++){\n\t\t\tint RRR=R-num11[i];\n\t\t\tint l=0;int r=H2*W2+1;\n\t\t\twhile(r-l>1){\n\t\t\t\tint c=(l+r)/2;\n\t\t\t\tif(num22[c]<RRR)l=c;\n\t\t\t\telse r=c;\n\t\t\t}\n\t\t\tl-=2;\n\t\t\tif(l<0)l=0;\n\t\t\twhile(l<=H1*W1&&num11[i]+num22[l]<R)l++;\n\t\t\tif(num11[i]+num22[l]<R)continue;\n\t\t\t//printf(\"%d %d\\n\",num11[i],num22[l]);\n\t\t\tint I=i-1;l--;\n\t\t\tif(I==-1)ans=min(ans,XX2[l].first);\n\t\t\telse if(l==-1)ans=min(ans,XX1[I].first);\n\t\t\telse ans=min(ans,XX1[I].first+XX2[l].first);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nll c[2500001];\nll b[501][501];\nstruct A {\n\tll ko, level;\n};\nA a[2][250001];\nll u[501][501];\nstruct P {\n\tll x, y, level;\n};\nll d[2];\nbool operator<(P a, P b) { return a.level < b.level; }\nbool operator>(P a, P b) { return a.level > b.level; }\nconst ll inf = 800000000000000000;\nint main() {\n\tll r;\n\tint lp[4][2] = { {1,0},{-1,0},{0,1},{0,-1} };\n\twhile (cin >> r&&r != 0) {\n\t\tfor (int z = 0; z < 2; z++) {\n\t\t\tll h, w, x, y;\n\t\t\tcin >> w >> h >> y >> x;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tqueue<P>p;\n\t\t\tfor (ll i = 0; i < h; i++) {\n\t\t\t\tfor (ll j = 0; j < w; j++) {\n\t\t\t\t\tcin >> u[i][j];\n\t\t\t\t\tb[i][j] = inf;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.push(P{ x,y,1 });\n\t\t\tb[x][y] = 1;\n\t\t\twhile (!p.empty()) {\n\t\t\t\tP t = p.front(); p.pop();\n\t\t\t\tll x = t.x, y = t.y;\n\t\t\t\tif (t.level == b[x][y]) {\n\t\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\t\tll x2 = x + lp[i][0], y2 = y + lp[i][1];\n\t\t\t\t\t\tif (b[x2][y2] > t.level) {\n\t\t\t\t\t\t\tif (u[x2][y2] <= t.level) {\n\t\t\t\t\t\t\t\tb[x2][y2] = t.level;\n\t\t\t\t\t\t\t\tp.push(P{ x2,y2,t.level });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (u[x2][y2] < b[x2][y2]) {\n\t\t\t\t\t\t\t\t\tb[x2][y2] = u[x2][y2];\n\t\t\t\t\t\t\t\t\tp.push(P{ x2,y2,u[x2][y2] });\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tll o = 0;\n\t\t\tfor (ll i = 0; i < h; i++) {\n\t\t\t\tfor (ll j = 0; j < w; j++) {\n\t\t\t\t\tc[o] = b[i][j];\n\t\t\t\t\to++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(c, c + o);\n\t\t\tll sum = 0, g = 1;\n\t\t\ta[z][0] = A{ 0,0 };\n\t\t\tfor (ll i = 0; i < (h*w);) {\n\t\t\t\tll k = c[i], sum2 = 0;\n\t\t\t\twhile (i < (h*w) && c[i] == k) {\n\t\t\t\t\tsum2++;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\ta[z][g] = A{ sum2 + sum,k };\n\t\t\t\tg++;\n\t\t\t\tsum += sum2;\n\t\t\t}\n\t\t\td[z] = g;\n\t\t}\n\t\tll sum = inf;\n\t\tfor (ll i = 0; i < d[0]; i++) {\n\t\t\tll s = 0, e = d[1] - 1, t, m = r - a[0][i].ko;\n\t\t\twhile (e - s > 1) {\n\t\t\t\tt = (e + s) / 2;\n\t\t\t\tif (a[1][t].ko <= m)\n\t\t\t\t\ts = t;\n\t\t\t\tif (a[1][t].ko >= m)\n\t\t\t\t\te = t;\n\t\t\t}\n\t\t\tif (a[0][i].ko + a[1][s].ko >= r)\n\t\t\t\tsum = min(sum, a[0][i].level + a[1][s].level);\n\t\t\tif (a[0][i].ko + a[1][e].ko >= r)\n\t\t\t\tsum = min(sum, a[0][i].level + a[1][e].level);\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\ntypedef pair< int, int > Pi;\ntypedef pair< int, Pi > Pii;\nconst int INF = 1 << 29;\nconst int dy[] = {0, 1, 0, -1}, dx[] = {1, 0, -1, 0};\n  \nstruct Field\n{\n  int W, H, X, Y;\n  int L[500][500];\n};\n  \nvoid InputField(Field& e)\n{\n  cin >> e.W >> e.H >> e.X >> e.Y;\n  --e.X, --e.Y;\n  for(int i = 0; i < e.H; i++) {\n    for(int j = 0; j < e.W; j++) {\n      cin >> e.L[i][j];\n    }\n  }\n}\nint BFSField(const Field& e, vector< int >& cost)\n{\n  priority_queue< Pii, vector< Pii >, greater< Pii > > que;\n  que.push({1, make_pair(e.X, e.Y)});\n  int min_cost[500][500];\n  fill_n(*min_cost, 500 * 500, INF);\n  min_cost[e.X][e.Y] = 1;\n  map< int, int > cur;\n  while(!que.empty()) {\n    Pi point = que.top().second;\n    int c = que.top().first;\n    que.pop();\n    if(c > min_cost[point.first][point.second]) continue;\n    cur[c]++;\n    for(int i = 0; i < 4; i++) {\n      int ny = point.second + dy[i], nx = point.first + dx[i];\n      if(ny < 0 || nx < 0 || ny >= e.H || nx >= e.W) continue;\n      if(min_cost[nx][ny] > max(c, e.L[ny][nx])) {\n        min_cost[nx][ny] = max(c, e.L[ny][nx]);\n        que.push({min_cost[nx][ny], Pi(nx, ny)});\n      }\n    }\n  }\n  cost.assign(e.W * e.H + 1, INF);\n  int sum = 0;\n  cost[0] = 0;\n  for(auto e : cur) {\n    sum += e.second;\n    cost[sum] = e.first;\n  }\n  for(int i = cost.size() - 2; i >= 0; i--) {\n    cost[i] = min(cost[i + 1], cost[i]);\n  }\n}\n  \nint main()\n{\n  int R;\n  Field A, B;\n  \n  while(cin >> R, R) {\n    InputField(A);\n    InputField(B);\n    vector< int > a, b;\n    BFSField(A, a);\n    BFSField(B, b);\n    \n    int ret = INF;\n    for(int i = 0; i < a.size(); i++) {\n      if(R - i >= 0 && R - i < b.size()) {\n        ret = min(ret, a[i] + b[R - i]);\n      }\n    }\n    \n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <iterator>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <cmath>\n#include <complex>\n#include <functional>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <cstdlib>\n#include <cctype>\n\n#define REP(i,m,n) for(int i=m;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rp(i,c) rep(i,(int)c.size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define v_delete(a,b) (a).erase(remove((a).begin(), (a).end(), b), (a).end())\n#define v_unique(a) (a).erase(unique((a).begin(), (a).end()), (a).end())\n#define VV(T) vector<vector< T > >\n#define init(a,b) memset((a), (b), sizeof((a)))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double EPS=1e-9;\nconst long long INF = 100001000010000100ll;\n\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntypedef pair<int,int> pii;\n\nint R;\nint W[2], H[2], X[2], Y[2];\n\nint m[4][500+10][500+10];\nint visited[2][500+10][500+10];\n\nint wa[2][500*500+10];\n\nvi ls;\n\nmap<int ,int> cnt[2];\n\nbool exists(const map<int ,int> &mapp, int key){\n\treturn mapp.find(key) != mapp.end();\n}\n\nint dx[]={1,0,0,-1};\nint dy[]={0,1,-1,0};\n\nclass BIT{\nprivate:\n\tvi bit;\n\tint n;\npublic:\n\tBIT(int _n){\n\t\tn = _n;\n\t\tbit.assign(n+1,0 );\n\t}\n\tvoid add(int i, int x){\n\t\twhile(i <= n){\n\t\t\tbit[i] += x;\n\t\t\ti += (i & -i);\n\t\t}\n\t}\n\tint sum(int i){\n\t\tint s = 0;\n\t\twhile(i > 0){\n\t\t\ts += bit[i];\n\t\t\ti -= (i & -i);\n\t\t}\n\t\treturn s;\n\t}\n};\n\n\nint main(){\n\twhile(cin >> R, R){\n\n\t\tmemset(visited, 0, sizeof(visited));\n\n\t\tmemset(wa, 0, sizeof(wa));\n\n\t\tls.clear();\n\n\t\tfill_n(**m, 4 * (500+10) * (500+10), inf);\n\n\t\trep(c, 2){\n\t\t\tcin >> W[c] >> H[c] >> X[c] >> Y[c];\n\t\t\trep(i, H[c]){\n\t\t\t\trep(j, W[c]){\n\t\t\t\t\tcin >> m[c][i+1][j+1];\n\t\t\t\t\tls.pb(m[c][i+1][j+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tls.pb(0);\n\t\tls.pb(inf);\n\t\tsort(all(ls));\n\t\tls.erase(unique(all(ls)), ls.end());\n\t\trep(c, 2){\n\t\t\tpriority_queue<pair<int, pii>, vector<pair<int, pii> >, greater<pair<int, pii> > >Q;\n\t\t\tQ.push(mp(1, mp(X[c], Y[c])));\n\t\t\twhile(!Q.empty()){\n\t\t\t\tint x,y,level;\n\t\t\t\tx=Q.top().second.first;y=Q.top().second.second;level=Q.top().first;\n\t\t\t\tQ.pop();\n\t\t\t\tif(visited[c][y][x]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvisited[c][y][x] = 1;\n\n\t\t\t\tif(level > m[c][y][x]){\n\t\t\t\t\tm[c][y][x] = level;\n\t\t\t\t}else{\n\t\t\t\t\tlevel = m[c][y][x];\n\t\t\t\t}\n\t\t\t\t//printf(\"%d %d %d %d\\n\",c, x, y, level);\n\t\t\t\trep(k, 4){\n\t\t\t\t\tif(m[c][y+dy[k]][x+dx[k]]!=inf){\n\t\t\t\t\t\tif(!visited[c][y+dy[k]][x+dx[k]]){\n\t\t\t\t\t\t\tQ.push(mp(max(m[c][y+dy[k]][x+dx[k]], level), mp(x+dx[k], y+dy[k])));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}/*\n\t\trep(c, 2){\n\t\t\trep(i, H[c]){\n\t\t\t\trep(j, W[c]){\n\t\t\t\t\tcout <<  m[c][i+1][j+1] << \" \";\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\tcout << endl;\n\t\t\tcout << endl;\n\t\t}*/\n\t\trep(c, 2){\n\t\t\trep(i, H[c]){\n\t\t\t\trep(j, W[c]){\n\t\t\t\t\tint ma=-1;\n\t\t\t\t\tint tmp=inf;\n\t\t\t\t\t/*\n\t\t\t\t\trep(k, 4){\n\t\t\t\t\t\ttmp=min(tmp, m[c][i + 1 + dx[k]][j + 1 + dy[k]]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i + 1 == Y[c] && j + 1 == X[c]){\n\t\t\t\t\t\tma=m[c][i + 1][j + 1];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tma = max(m[c][i + 1][j + 1], tmp);\n\t\t\t\t\t}*/\n\t\t\t\t\tma=m[c][i + 1][j + 1];\n\t\t\t\t\tint l = lower_bound(all(ls), ma) - ls.begin();\n\t\t\t\t\twa[c][l]++;\n\n\t\t\t\t}\n\t\t\t}\n\t\t\trp(i, ls){\n\t\t\t\tif(i - 1 >= 0)\n\t\t\t\t\twa[c][i] = wa[c][i - 1] + wa[c][i];\n\t\t\t}\n\n\t\t}\n\t\t/*\n\t\trep(c, 2){\n\t\t\trp(i, ls){\n\t\t\t\tcout << ls[i] << \" \" << wa[c][i] << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\tcout << endl;\n\t\t}*/\n\t\tint ans=inf;\n\t\trp(i, ls){\n\n\t\t\tint l=lower_bound(wa[1],(wa[1]+(int)ls.size()) , R - wa[0][i]) - wa[1];\n\t\t\tif(l < ls.size())\n\t\t\tif(wa[0][i] + wa[1][l] >= R){\n\t\t\t\t//cout << ls[i] << \" \" << ls[l] << endl;\n\t\t\t\tans=min(ans, ls[i] + ls[l]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <complex>\n#include <cstdio>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define FORE(i,a,b) for(int i=(a);i<=(b);i++)\n#define REP(i,a) FOR(i,0,a)\n#define SQR(a) ((a)*(a))\n#define X first\n#define Y second\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pr;\ntypedef pair<pr,ll> ppr;\ntypedef vector<pr> vpr;\ntypedef pair<int,int> ci;\ntypedef pair<int,ci> pci;\ntypedef priority_queue<pci,vector<pci>,greater<pci> > pq;\nconst int INF=1<<30;\nbool finished[502][502];\nint level[502][502];\nci dc[4]={ci(1,0),ci(0,1),ci(-1,0),ci(0,-1)};\nint main() {\n\tint R;\n\twhile(cin >> R && R){\n\tvpr ables[2];\n\tREP(l,2){\n\t\tint W,H,sx,sy,mlevel=0,sum=0;\n\t\tcin >> W  >>H >>sx >> sy;\n\t\tFORE(i,1,H)\n\t\t\tFORE(j,1,W)\n\t\t\t\tscanf(\"%d\",&level[i][j]);\n\t\tFORE(i,0,H+1)\n\t\t\tFORE(j,0,W+1)\n\t\t\t\tif(i&&j&&i<=H&&j<=W)\n\t\t\t\t\tfinished[i][j]=false;\n\t\t\t\telse\n\t\t\t\t\tfinished[i][j]=true;\n\t\tfinished[sy][sx]=false;\n\t\tlevel[sy][sx]=INF;\n\t\tpq dungeon;\n\t\tdungeon.push(pci(1,ci(sx,sy)));\n\t\twhile(!dungeon.empty()){\n\t\t\tci point=dungeon.top().second;\n\t\t\tint nowlevel=dungeon.top().first;\n\t\t\tdungeon.pop();\n\t\t\tif(mlevel<nowlevel){\n\t\t\t\tables[l].push_back(pr(sum,mlevel));\n\t\t\t\tmlevel=nowlevel;\n\t\t\t}\n\t\t\tsum++;\n\t\t\tREP(i,4){\n\t\t\t\tci d=dc[i];\n\t\t\t\tif(!finished[point.Y+d.Y][point.X+d.X]){\n\t\t\t\t\tfinished[point.Y+d.Y][point.X+d.X]=true;\n\t\t\t\t\tdungeon.push(pci(level[point.Y+d.Y][point.X+d.X],ci(point.X+d.X,point.Y+d.Y)));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tint e=ables[1].size()-1,minium=INF;\n\tREP(i,ables[0].size()){\n\t\twhile(e && ables[0][i].first+ables[1][e-1].first>=R) e--;\n\t\tif(ables[0][i].first+ables[1][e].first>=R)\n\t\t\tminium=min(minium,ables[0][i].second+ables[1][e].second);\n\t}\n\tcout << minium << endl;\n\t}\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, -1, 0, 1};\n\ninline vector<pii> func(){\n\tint w, h, x, y;\n\tscanf(\"%d%d%d%d\", &w, &h, &x, &y);\n\t\n\tvector<vector<int> > L(w + 2, vector<int>(h + 2, -1));\n\tvector<int> Ls;\n\tLs.reserve(w * h + 1);\n\tLs.push_back(0);\n\t\n\tfor(int i = 1; i <= h; ++i)\n\tfor(int j = 1; j <= w; ++j){\n\t\tscanf(\"%d\", &L[j][i]);\n\t\tLs.push_back(L[j][i]);\n\t}\n\t\n\tsort(Ls.begin(), Ls.end());\n\tLs.erase(unique(Ls.begin(), Ls.end()), Ls.end());\n\t\n\tvector<pii> c(Ls.size());\n\tfor(int i = 0; i < Ls.size(); ++i){\n\t\tc[i].second = Ls[i];\n\t}\n\n\tpriority_queue<pii,vector<pii>,greater<pii> > pq;\n\tpq.push( pii(1, x << 16 | y) );\n\tL[x][y] = -1;\n\t\n\twhile( !pq.empty() ){\n\t\tqueue<int> q;\n\t\tq.push(pq.top().second);\n\t\tint u = pq.top().first;\n\t\tpq.pop();\n\n\t\tint k = lower_bound(Ls.begin(), Ls.end(), u) - Ls.begin();\n\t\t++c[k].first;\n\n\t\twhile( !q.empty() ){\n\t\t\tfor(int i = 0; i < 4; ++i){\n\t\t\t\tx = (q.front() >> 16) + dx[i];\n\t\t\t\ty = (q.front() & 0xff) + dy[i];\n\n\t\t\t\tif( L[x][y] > 0 ){\n\t\t\t\t\tif( L[x][y] <= u ){\n\t\t\t\t\t\tL[x][y] = -1;\n\t\t\t\t\t\t++c[k].first;\n\t\t\t\t\t\tq.push(x << 16 | y);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpq.push( pii(L[x][y], x << 16 | y) );\n\t\t\t\t\t\tL[x][y] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tq.pop();\n\t\t}\n\t}\n\t\n\tfor(int i = 2; i < c.size(); ++i){\n\t\tc[i].first += c[i - 1].first;\n\t}\n\t\n\treturn c;\n}\n\nint main(){\n\tint R;\n\twhile( scanf(\"%d\", &R), R != 0 ){\n\t\tvector<pii> t1 = func();\n\t\tvector<pii> t2 = func();\n\n\t\tint ans = (int)1e9;\n\t\tfor(int i = 0; i <= R; ++i){\n\t\t\tint a = t1[i].second;\n\t\t\tpii p = pii(R - t1[i].first, 0);\n\t\t\tint b = lower_bound(t2.begin(), t2.end(), p)->second;\n\t\t\tans = min(ans, a + b);\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <climits>\n#include <cstring>\nusing namespace std;\n\nclass P{\npublic:\n  int x, y, level;\n  P(){}\n  P(int x, int y, int level) : x(x), y(y), level(level) {}\n\n  bool operator<(const P &p)const{\n    return level > p.level;\n  }\n};\n\nint R;\nint H[2], W[2];\nint SX[2], SY[2];\nint T[2][502][502];\nvector<int> LEVEL[2], ROOM[2];\n\nbool closed[502][502];\n\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nvoid solve_small(int h, int w, int sx, int sy, int t[502][502], vector<int> &level, vector<int> &room){\n  priority_queue<P> open;\n  memset(closed, 0, sizeof(closed));\n  open.push(P(sx, sy, 1));\n\n  int nowLevel = 1;\n  int nowRoom = 0;\n\n  while(!open.empty()){\n    P p = open.top();\n    open.pop();\n\n    if(closed[p.y][p.x]){\n      continue;\n    }\n    closed[p.y][p.x] = true;\n\n    if(p.level > nowLevel){\n      level.push_back(nowLevel);\n      room.push_back(nowRoom);\n      nowLevel = p.level;\n    }\n\n    nowRoom++;\n\n    for(int i = 0; i < 4; i++){\n      int nx = p.x + dx[i];\n      int ny = p.y + dy[i];\n      if(nx < 0 || w <= nx || ny < 0 || h <= ny) continue;\n      if(closed[ny][nx]) continue;\n      open.push(P(nx, ny, t[ny][nx]));\n    }\n  }\n\n  level.push_back(nowLevel);\n  room.push_back(nowRoom);\n}\n\nvoid solve(){\n  for(int i = 0; i < 2; i++){\n    solve_small(H[i], W[i], SX[i], SY[i], T[i], LEVEL[i], ROOM[i]);\n  }\n\n  int ans = INT_MAX;\n\n  for(int i = 0; i < ROOM[0].size(); i++){\n    if(ROOM[0][i] >= R){\n      ans = min(ans, LEVEL[0][i]);\n      continue;\n    }\n\n    int rem = R - ROOM[0][i];\n    int pos = lower_bound(ROOM[1].begin(), ROOM[1].end(), rem) - ROOM[1].begin();\n    if(pos == ROOM[1].size()) continue;\n\n    ans = min(ans, LEVEL[0][i] + LEVEL[1][pos]);\n  }\n\n  cout << ans << endl;\n}\n\nint main(){\n  while(cin >> R, R){\n    for(int i = 0; i < 2; i++){\n      LEVEL[i].clear();\n      ROOM[i].clear();\n\n      cin >> W[i] >> H[i] >> SX[i] >> SY[i];\n      SX[i]--;\n      SY[i]--;\n\n      for(int j = 0; j < H[i]; j++){\n        for(int k = 0; k < W[i]; k++){\n          cin >> T[i][j][k];\n        }\n      }\n    }\n\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 500000000\n#define f first\n#define s second\n#define rep(i,x) for(int i=0;i<x;i++)\nint d[505][505];\nint v[505][505];\nbool used[505][505]={};\nint val[100005][2];\nint main()\n{\n\tsrand((unsigned int)time(NULL));\n\twhile(1)\n\t{\n\t\tint lim; scanf(\"%d\",&lim); if(!lim) return 0;\n\t\tfor(int q=0;q<2;q++)\n\t\t{\n\t\t\tfor(int i=0;i<505;i++) for(int j=0;j<505;j++) d[i][j]=INF;\n\t\t\tfor(int i=0;i<100005;i++) val[i][q]=INF;\n\t\t\tint w,h,x,y;\n\t\t\tscanf(\"%d%d%d%d\",&w,&h,&x,&y);\n\t\t\tx--; y--;\n\t\t\tfor(int i=0;i<h;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<w;j++)\n\t\t\t\t{\n\t\t\t\t\tscanf(\"%d\",&v[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tpriority_queue<P1,vector<P1>,greater<P1> >que;\n\t\t\tint cur=0;\n\t\t\tval[cur++][q]=0;\n\t\t\tque.push(mp(v[y][x],mp(y,x)));\n\t\t\twhile(!que.empty())\n\t\t\t{\n\t\t\t\tP1 p=que.top(); que.pop();\n\t\t\t\tint num=p.f; int x=p.s.f; int y=p.s.s;\n\t\t\t\tif(used[x][y]) continue;\n\t\t\t\tused[x][y]=true;\n\t\t\t\tval[cur][q]=max(val[cur-1][q],num);\n\t\t\t\tcur++;\n\t\t\t\tint dx[4]={0,1,0,-1};\n\t\t\t\tint dy[4]={1,0,-1,0};\n\t\t\t\tfor(int i=0;i<4;i++)\n\t\t\t\t{\n\t\t\t\t\tint nx=x+dx[i];\n\t\t\t\t\tint ny=y+dy[i];\n\t\t\t\t\tif(!(0<=nx && nx<h)) continue;\n\t\t\t\t\tif(!(0<=ny && ny<w)) continue;\n\t\t\t\t\tif(used[nx][ny]) continue;\n\t\t\t\t\tque.push(mp(v[nx][ny],mp(nx,ny)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=INF;\n\t\tfor(int i=0;i<=lim;i++)\n\t\t{\n\t\t\tret=min(val[i][0]+val[lim-i][1],ret);\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> plli;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst ll mod = 1e9 + 7;\nconst ll INF = 1<<30;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\nint r;\nint w_1, h_1, x_1, y_1;\nint w_2, h_2, x_2, y_2;\nint g1[505][505], g2[505][505];\n\nbool check(int y, int x, int h, int w) {\n    if ((0 <= y && y < h) && (0 <= x && x < w)) return true;\n    return false;\n}\n\nvector<int> search(int sy, int sx, int h, int w, int g[505][505]) {\n    priority_queue<pipii, vector<pipii>, greater<pipii>> pq;\n    pq.push(make_pair(1LL, make_pair(sy, sx)));\n    bool visited[h + 5][w + 5] = {};\n    vector<int> cnt;\n    cnt.pb(0);\n    int now_level = 1;\n    visited[sy][sx] = true;\n    while (!pq.empty()) {\n        pipii p = pq.top();\n        pq.pop();\n        int level = p.fi;\n        int y = p.se.fi;\n        int x = p.se.se;\n        if (now_level < level) {\n            cnt.pb(level);\n            now_level = level;\n        }\n        else {\n            cnt.pb(now_level);\n        }\n        rep(i, 4) {\n            int ny = y + dy4[i];\n            int nx = x + dx4[i];\n            if (!check(ny, nx, h, w) || visited[ny][nx]) continue;\n            pq.push(make_pair(g[ny][nx], make_pair(ny, nx)));\n            visited[ny][nx] = true;\n        }\n    }\n    return cnt;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> r;\n    while (r != 0) {\n        cin >> w_1 >> h_1 >> x_1 >> y_1;\n        x_1--;y_1--;\n        rep(i, h_1)rep(j, w_1) cin >> g1[i][j];\n        cin >> w_2 >> h_2 >> x_2 >> y_2;\n        x_2--;y_2--;\n        rep(i, h_2)rep(j, w_2) cin >> g2[i][j];\n        vector<int> cnt1 = search(y_1, x_1, h_1, w_1, g1);\n        vector<int> cnt2 = search(y_2, x_2, h_2, w_2, g2);\n        int ans = 1e12;\n        rep(i, r + 1) {\n            if (cnt1.size() <= i) break;\n            if (cnt2.size() <= r - i) continue;\n            ans = min(ans, cnt1[i] + cnt2[r - i]);\n        }\n        cout << ans << endl;\n        cin >> r;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define err(args...) {}\n#ifdef DEBUG\n#include \"_debug.cpp\"\n#endif\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\ntemplate <typename T> using lim = numeric_limits<T>;\ntemplate <typename T> istream& operator>>(istream& is, vector<T>& a) { for(T& x : a) { is >> x; } return is; }\ntemplate <typename Iter, typename T> int gt(Iter L, Iter R, T v) { return upper_bound(L, R, v) - L; }\ntemplate <typename Iter, typename T> int ge(Iter L, Iter R, T v) { return lower_bound(L, R, v) - L; }\ntemplate <typename Iter, typename T> int lt(Iter L, Iter R, T v) { return lower_bound(L, R, v) - L - 1; }\ntemplate <typename Iter, typename T> int le(Iter L, Iter R, T v) { return upper_bound(L, R, v) - L - 1; }\ntemplate <typename Bst, typename T> typename Bst::const_iterator gt(const Bst& bst, T v) { return bst.upper_bound(v); }\ntemplate <typename Bst, typename T> typename Bst::const_iterator ge(const Bst& bst, T v) { return bst.lower_bound(v); }\ntemplate <typename Bst, typename T> typename Bst::const_iterator lt(const Bst& bst, T v) { return bst.lower_bound(v) == bst.begin() ? bst.end() : --bst.lower_bound(v); }\ntemplate <typename Bst, typename T> typename Bst::const_iterator le(const Bst& bst, T v) { return bst.upper_bound(v) == bst.begin() ? bst.end() : --bst.upper_bound(v); }\nconst int N = 500;\nint g[N][N], vis[N][N];\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\nvector<int> solve_grid() {\n    int w, h, x, y;\n    cin >> w >> h >> x >> y;\n    for(int i = 0; i < h; i++) {\n        for(int j = 0; j < w; j++) {\n            cin >> g[i][j];\n            vis[i][j] = false;\n        }\n    }\n    vector<int> cost(h * w + 1);\n    priority_queue<tuple<int, int, int>> pq({}, {make_tuple(-1, y - 1, x - 1)});\n    vis[y - 1][x - 1] = true;\n    for(int component_size = 1; not pq.empty(); component_size++) {\n        int val, y, x;\n        tie(val, y, x) = pq.top();\n        pq.pop();\n        cost[component_size] = max(cost[component_size - 1], -val);\n        for(int d = 0; d < 4; d++) {\n            int ny = y + dy[d], nx = x + dx[d];\n            if(0 <= ny and ny < h and 0 <= nx and nx < w and not vis[ny][nx]) {\n                pq.push(make_tuple(-g[ny][nx], ny, nx));\n                vis[ny][nx] = true;\n            }\n        }\n    }\n    return cost;\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int r;\n    while(cin >> r and r) {\n        auto cost1 = solve_grid();\n        auto cost2 = solve_grid();\n        int ans = lim<int>::max();\n        for(int r1 = 0; r1 <= r; r1++) {\n            if(r1 < cost1.size() and r - r1 < cost2.size()) {\n                ans = min(ans, cost1[r1] + cost2[r - r1]);\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\n\nvector<int> calc_required_level_to_rooms()\n{\n\tint w, h, sx, sy;\n\tstatic int req[512][512];\n\tcin >> w >> h >> sx >> sy;\n\t--sx, --sy;\n\tfor (int y = 0; y < h; ++y)\n\t\tfor (int x = 0; x < w; ++x)\n\t\t\tcin >> req[y][x];\n\n\tvector<int> res;\n\tres.push_back(0);\n\n\tstatic bool visit[512][512];\n\tCLEAR(visit, 0);\n\n\ttypedef pair<int, pint> P;\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tq.push(P(1, pint(sx, sy)));\n\twhile (!q.empty())\n\t{\n\t\tP tt = q.top(); q.pop();\n\t\tint level = tt.first;\n\t\tint x = tt.second.first, y = tt.second.second;\n\t\tif (visit[y][x])\n\t\t\tcontinue;\n\n\t\tvisit[y][x] = true;\n\t\tres.push_back(level);\n\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\t\tif (valid_pos(tx, ty, w, h) && !visit[ty][tx])\n\t\t\t\tq.push(P(max(level, req[ty][tx]), pint(tx, ty)));\n\t\t}\n\t}\n\treturn res;\n}\nint min_level(int r, const vector<int>& a, const vector<int>& b)\n{\n\tint res = 1e9;\n\tfor (int i = min<int>(r, a.size() - 1); i >= 0 && r - i < b.size(); --i)\n\t\tmin_swap(res, a[i] + b[r - i]);\n\treturn res;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tint r;\n\twhile (cin >> r, r)\n\t{\n\t\tvector<int> a = calc_required_level_to_rooms();\n\t\tvector<int> b = calc_required_level_to_rooms();\n\n\t\tint res;\n\t\tif (a.size() >= b.size())\n\t\t\tres = min_level(r, a, b);\n\t\telse\n\t\t\tres = min_level(r, b, a);\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n// #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v==0) return b;\n                                \tif(b==0) return v;\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[10000100];\n                int inv[10000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n\n\nint a[600][600];\nint vis[600][600];\n\npair<vector<int>,vector<int>> solve(){\n\t\n\tint h,w;\n\tcin>>w>>h;\n\tint x,y;\n\tcin>>y>>x;\n\ty--,x--;\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)vis[i][j]=0;\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)cin>>a[i][j];\n\t\n\tpriority_queue<pa3,vector<pa3>,greater<pa3>> pq;\n\tint cnt=0;\n\tvector<int> num,kosu;\n\t\n\t//num.pb(0),kosu.pb(0);\n\t\tpq.push((pa3){1,x,y});\n\tint ima=0;\n\tvis[x][y]=1;\n\twhile(cnt<h*w){\n\t\tpa3 z=pq.top();\n\t\tpq.pop();\n\n\t//\tcout<<z.y<<\" \"<<z.z<<\"   \"<<z.x<<endl;\n\t\tif(ima<z.x){\n\t\t\tnum.pb(ima);\n\t\t\tkosu.pb(cnt);\n\t\t\tima=z.x;\n\t\t}\n\t\tcnt++;\n\t\t\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint X=z.y+dx[i];\n\t\t\tint Y=z.z+dy[i];\n\t\t\tif(X<0 || Y<0 || X>=h || Y>=w)continue;\n\t\t\tif(vis[X][Y])continue;\n\t\t\t\tpq.push((pa3){a[X][Y],X,Y});\n\t\t\tvis[X][Y]=1;\n\t\t\t\n\t\t}\n\t}\n\tnum.pb(ima);\n\tkosu.pb(cnt);\n\n\treturn mp(num,kosu);\n\t\n}\nvoid solve1(){\nint R;\n\tcin>>R;\n\tif(R==0) exit(0);\n\tauto A=solve();\n\tauto B=solve();\n\t\n\tvector<int> num1=A.first;\n\tvector<int> num2=B.first;\n\tvector<int> ko1=A.second;\n\tvector<int> ko2=B.second;\n\tint l1=num1.size();\n\tint l2=num2.size();\n\tint ans=inf*2;\n\tfor(int i=0;i<l1;i++){\n\t\tif(ko1[i]+ko2.back()<R)continue;\n\t\tint noko=R-ko1[i];\n\t\tint it=lower_bound(ko2.begin(),ko2.end(),noko)-ko2.begin();\n\t\tans=min(ans,num1[i]+num2[it]);\n\t}\n\tcout<<ans<<endl;\n\t\n}\nsigned main(){\n\t\n\t\ncin.tie(0);\nios::sync_with_stdio(false);\nint n;\n//cin>>n;\nfor(int i=0;;i++)solve1();\n\treturn 0;\n }\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<functional>\n#include<vector>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\n#define T1 1000000\n#define T2 1000\n\nlong long W,H,X,Y,R;\nlong long x[1000][1000];\nlong long d[1000][1000];\nlong long p1,p2,p3;\nlong long y_1[1000000],y_2[1000000],cnt,cnt2,v,minx;\n\npriority_queue<long long,vector<long long>,greater<long long>> Q;\n\nint main(){\n\twhile(true){\n\t\tcnt=1;cnt2=1;minx=1145141919810;\n\t\tmemset(x,51,sizeof(x));\n\t\tmemset(d,51,sizeof(d));\n\t\tcin>>R;\n\t\tif(R==0){break;}\n\t\tcin>>W>>H>>X>>Y;\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tfor(int j=1;j<=W;j++){\n\t\t\t\tcin>>x[i][j];\n\t\t\t}\n\t\t}\n\t\td[Y][X]=0;\n\t\tQ.push(Y*T2+X);\n\t\twhile(!Q.empty()){\n\t\t\tp1=Q.top()/T1;\n\t\t\tp2=(Q.top()/T2)%T2;\n\t\t\tp3=Q.top()%T2;\n\t\t\tif(max(p1,x[p2-1][p3])<d[p2-1][p3]){\n\t\t\t\td[p2-1][p3]=max(p1,x[p2-1][p3]);\n\t\t\t\tQ.push(d[p2-1][p3]*T1+(p2-1)*T2+p3);\n\t\t\t}\n\t\t\tif(max(p1,x[p2+1][p3])<d[p2+1][p3]){\n\t\t\t\td[p2+1][p3]=max(p1,x[p2+1][p3]);\n\t\t\t\tQ.push(d[p2+1][p3]*T1+(p2+1)*T2+p3);\n\t\t\t}\n\t\t\tif(max(p1,x[p2][p3-1])<d[p2][p3-1]){\n\t\t\t\td[p2][p3-1]=max(p1,x[p2][p3-1]);\n\t\t\t\tQ.push(d[p2][p3-1]*T1+p2*T2+(p3-1));\n\t\t\t}\n\t\t\tif(max(p1,x[p2][p3+1])<d[p2][p3+1]){\n\t\t\t\td[p2][p3+1]=max(p1,x[p2][p3+1]);\n\t\t\t\tQ.push(d[p2][p3+1]*T1+p2*T2+(p3+1));\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tfor(int j=1;j<=W;j++){\n\t\t\t\ty_1[cnt]=d[i][j];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tmemset(x,51,sizeof(x));\n\t\tmemset(d,51,sizeof(d));\n\t\tcin>>W>>H>>X>>Y;\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tfor(int j=1;j<=W;j++){\n\t\t\t\tcin>>x[i][j];\n\t\t\t}\n\t\t}\n\t\td[Y][X]=0;\n\t\tQ.push(Y*T2+X);\n\t\twhile(!Q.empty()){\n\t\t\tp1=Q.top()/T1;\n\t\t\tp2=(Q.top()/T2)%T2;\n\t\t\tp3=Q.top()%T2;\n\t\t\tif(max(p1,x[p2-1][p3])<d[p2-1][p3]){\n\t\t\t\td[p2-1][p3]=max(p1,x[p2-1][p3]);\n\t\t\t\tQ.push(d[p2-1][p3]*T1+(p2-1)*T2+p3);\n\t\t\t}\n\t\t\tif(max(p1,x[p2+1][p3])<d[p2+1][p3]){\n\t\t\t\td[p2+1][p3]=max(p1,x[p2+1][p3]);\n\t\t\t\tQ.push(d[p2+1][p3]*T1+(p2+1)*T2+p3);\n\t\t\t}\n\t\t\tif(max(p1,x[p2][p3-1])<d[p2][p3-1]){\n\t\t\t\td[p2][p3-1]=max(p1,x[p2][p3-1]);\n\t\t\t\tQ.push(d[p2][p3-1]*T1+p2*T2+(p3-1));\n\t\t\t}\n\t\t\tif(max(p1,x[p2][p3+1])<d[p2][p3+1]){\n\t\t\t\td[p2][p3+1]=max(p1,x[p2][p3+1]);\n\t\t\t\tQ.push(d[p2][p3+1]*T1+p2*T2+(p3+1));\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tfor(int j=1;j<=W;j++){\n\t\t\t\ty_2[cnt2]=d[i][j];\n\t\t\t\tcnt2++;\n\t\t\t}\n\t\t}\n\n\t\tsort(y_1,y_1+cnt);\n\t\tsort(y_2,y_2+cnt2);\n\n\t\tfor(int i=0;i<cnt;i++){\n\t\t\tv=R-i;\n\t\t\tif(v>=0 && v<cnt2){\n\t\t\t\tminx=min(minx,y_1[i]+y_2[v]);\n\t\t\t}\n\t\t}\n\t\tcout<<minx<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<climits>\nusing namespace std;\nint field[500][500],cost[500][500];\nint R,W,H,X,Y;\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\n\nstruct edge{\n int y,x,cost;\n edge(int y,int x,int cost) : y(y) , x(x) , cost(cost) {}\n};\nbool operator < (const edge &a,const edge &b){\n return a.cost > b.cost;\n}\nvector<int> dijkstra(){\n int x,y,nx,ny,rec;\n vector<int> foo(500000, INT_MAX / 4);\n foo[0] = 0;\n priority_queue<edge> que;\n for(int i = 0; i < H; i++){\n  for(int j = 0; j < W; j++){\n   cost[i][j] = INT_MAX;\n  }\n }\n cost[Y][X] = 1;\n que.push(edge(Y,X,1));\n int rank = 0;\n foo[rank++] = 0;\n while(!que.empty()){\n  edge crt = que.top();\n  que.pop();\n  x = crt.x;\n  y = crt.y;\n  foo[rank] = max(foo[rank - 1], crt.cost);\n  rank++;\n  if(cost[y][x] != crt.cost) continue;\n  for(int i = 0; i < 4; i++){\n   nx = x + dx[i];\n   ny = y + dy[i];\n   if(nx == -1 || ny == -1 || nx ==  W || ny == H)continue;\n   rec = max(field[ny][nx], crt.cost);\n   if(cost[ny][nx] > rec){\n    cost[ny][nx] = rec;\n    que.push(edge(ny,nx,rec));\n   }\n  }\n }\n return foo;\n}  \n\nint main(){\n while(scanf(\"%d\", &R)){\n  if(!R) break;\n  vector<int> f(500000, INT_MAX / 2);\n  vector<int> g(500000, INT_MAX / 2);\n  for(int q = 0; q < 2; q++){\n   scanf(\"%d %d %d %d\", &W,&H,&X,&Y);\n   X--;\n   Y--;\n   for(int i = 0; i < H; i++){\n    for(int j = 0; j < W;j++){\n     scanf(\"%d\",&field[i][j]);\n    }\n   }\n   if (q == 0){\n       f = dijkstra();\n   }\n   else {\n       g = dijkstra();\n   }\n  }\n  int res = INT_MAX;\n  for (int i = 0; i <= R; i++){\n    res = min(res, f[i] + g[R - i]);\n  }\n  printf(\"%d\\n\", res);\n }\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define MAX_H 504 \n#define MAX_W 504\n#define MAX_LEVEL 100000000\n#define mp make_pair\n#define INF 1001001001\n#define ppp pair<int, pair<int,int> >\nusing namespace std;\n#define rep(i,n) for(int i=0; i<n ; i++)\nvector< int > LEVEL_ABILITY[2];\nvector<int> LEVEL_ABILITY_UNIQUE[2];\nvector<int> LEVEL_ABILITY_BOX[2];\nint main(void){\n    while(1){\n        LEVEL_ABILITY_UNIQUE[0].clear();LEVEL_ABILITY_UNIQUE[1].clear();\n        LEVEL_ABILITY[0].clear();LEVEL_ABILITY[1].clear();\n        LEVEL_ABILITY_BOX[0].clear();LEVEL_ABILITY_BOX[1].clear();\n        int R;\n        scanf(\"%d\",&R);if(R==0)break;\n        rep(i,2){\n            int W,H,X,Y;int LEVEL[MAX_H][MAX_W];int DLEVEL[MAX_H][MAX_W];\n            scanf(\"%d %d %d %d\",&W,&H,&X,&Y);X--;Y--;\n            rep(j,H)rep(k,W){\n                scanf(\"%d\",&LEVEL[j][k]);\n                DLEVEL[j][k]=INF;\n            }\n            //探索\n            priority_queue< ppp ,vector< ppp > , greater< ppp > > D;\n            D.push( mp(1, mp(Y,X) ) );\n            while(!D.empty() ){\n                pair<int, pair<int,int> >p= D.top(); D.pop();\n                int pL=p.first;int pY=p.second.first;int pX=p.second.second; \n                if( pL>=DLEVEL[pY][pX] )continue;\n                DLEVEL[pY][pX]=max( pL , LEVEL[pY][pX] );\n                if(pY>0)D.push( mp(DLEVEL[pY][pX], mp(pY-1,pX) ) );\n                if(pY<H-1)D.push( mp(DLEVEL[pY][pX], mp(pY+1,pX) ) );\n                if(pX>0)D.push( mp(DLEVEL[pY][pX], mp(pY,pX-1) ) );\n                if(pX<W-1)D.push( mp(DLEVEL[pY][pX], mp(pY,pX+1) ) );\n            }\n            //LEVEL_ABILITYを作る\n            LEVEL_ABILITY[i].push_back(0);\n            rep(j,H)rep(k,W){\n                LEVEL_ABILITY[i].push_back( DLEVEL[j][k] );\n            }\n            sort( LEVEL_ABILITY[i].begin(),LEVEL_ABILITY[i].end() );\n            //rep(test,LEVEL_ABILITY[i].size() ){printf(\"%d-\",LEVEL_ABILITY[i][test]);}\n            LEVEL_ABILITY_UNIQUE[i]=LEVEL_ABILITY[i];\n            LEVEL_ABILITY_UNIQUE[i].erase( unique(LEVEL_ABILITY_UNIQUE[i].begin(),LEVEL_ABILITY_UNIQUE[i].end() ) , LEVEL_ABILITY_UNIQUE[i].end() );\n            int ite=1;\n            rep(j,LEVEL_ABILITY[i].size() ){\n                if(j==0){LEVEL_ABILITY_BOX[i].push_back(0);continue;}\n                if(LEVEL_ABILITY[i][j]!=LEVEL_ABILITY[i][ite]){LEVEL_ABILITY_BOX[i].push_back(j-1);ite=j;}\n                if(j==LEVEL_ABILITY[i].size()-1){\n                    LEVEL_ABILITY_BOX[i].push_back(j);\n                }\n            }LEVEL_ABILITY_UNIQUE[i].push_back(INF);\n        }\n        //一件目の認定レベルを決め、二回目に何個行けるか調べる。\n        int ans=INF;\n        rep(i,LEVEL_ABILITY_UNIQUE[0].size() ){\n            int firstLV=LEVEL_ABILITY_UNIQUE[0][i];\n            int firstscore=LEVEL_ABILITY_BOX[0][i];\n            int secondscore=R-firstscore;int secondLV;\n            if(secondscore<=0)secondLV=0;\n            else{\n                int ite=lower_bound(LEVEL_ABILITY_BOX[1].begin(), LEVEL_ABILITY_BOX[1].end(), secondscore )- LEVEL_ABILITY_BOX[1].begin();\n                secondLV=LEVEL_ABILITY_UNIQUE[1][ite];\n            }\n            ans=min(ans,firstLV+secondLV);\n        }\n        printf(\"%d\\n\",ans);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\n\nvector<int> calc_required_level_to_rooms()\n{\n\tint w, h, sx, sy;\n\tstatic int req[512][512];\n\tcin >> w >> h >> sx >> sy;\n\t--sx, --sy;\n\tfor (int y = 0; y < h; ++y)\n\t\tfor (int x = 0; x < w; ++x)\n\t\t\tcin >> req[y][x];\n\n\tvector<int> res;\n\tres.push_back(0);\n\n\tstatic bool visit[512][512];\n\tCLEAR(visit, 0);\n\n\ttypedef pair<int, pint> P;\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tq.push(P(1, pint(sx, sy)));\n\twhile (!q.empty())\n\t{\n\t\tP tt = q.top(); q.pop();\n\t\tint level = tt.first;\n\t\tint x = tt.second.first, y = tt.second.second;\n\t\tif (visit[y][x])\n\t\t\tcontinue;\n\n\t\tvisit[y][x] = true;\n\t\tres.push_back(level);\n\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\t\tif (valid_pos(tx, ty, w, h) && !visit[ty][tx])\n\t\t\t\tq.push(P(max(level, req[ty][tx]), pint(tx, ty)));\n\t\t}\n\t}\n\n\treturn res;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tint r;\n\tcin >> r;\n\n\tvector<int> a = calc_required_level_to_rooms();\n\tvector<int> b = calc_required_level_to_rooms();\n\tif (a.size() < b.size())\n\t\tswap(a, b);\n\n\tint res = 1e9;\n\tfor (int i = min<int>(r, a.size()), j = 0; i >= 0 && j < b.size(); --i, ++j)\n\t\tmin_swap(res, a[i] + b[j]);\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\n\nconst int INF=1000000000;\nconst long long int INF_=1000000000000000000;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nbool IsIn(int y,int x,int h,int w){\n\treturn 0<=y&&y<h&&0<=x&&x<w;\n}\n\nvoid BFS(vector<vector<int> > &f,vector<vector<int> > &l,int sy,int sx,int h,int w){\n\tvector<vector<int> > done(h,vector<int>(w));\n\tl[sy][sx]=1;\n\tdone[sy][sx]=1;\n\tqueue<Pi> que;\n\tREP(i,0,4){\n\t\tint ny=sy+dy[i],nx=sx+dx[i];\n\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\tque.push(Pi(ny,nx));\n\t}\n\twhile(!que.empty()){\n\t\tPi p=que.front();\n\t\tque.pop();\n\t\tdone[p.F_][p.S_]=1;\n\t\tbool flag=true;\n\t\tint tmp=INF;\n\t\tREP(i,0,4){\n\t\t\tint ny=p.F_+dy[i],nx=p.S_+dx[i];\n\t\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\t\tif(done[ny][nx]==1) tmp=min(tmp,l[ny][nx]);\n\t\t\t//if(p.S_==2&&p.F_==1) cout << l[ny][nx] << endl;\n\t\t\tif(done[ny][nx]==1&&l[ny][nx]>=f[p.F_][p.S_]) flag=false;\n\t\t\tif(done[ny][nx]!=1) que.push(Pi(ny,nx));\n\t\t}\n\t\t//if(p.S_==2&&p.F_==1) cout << tmp << endl << endl;\n\t\tif(flag) l[p.F_][p.S_]=f[p.F_][p.S_];\n\t\telse l[p.F_][p.S_]=max(tmp,f[p.F_][p.S_]);\n\t}\n}\n\nvoid solve(){\n\tint R;\n\twhile(cin >> R&&R){\n\t\tint W[2],H[2],X[2],Y[2];\n\t\tvector<vector<int> > field[2];\n\t\tvector<vector<int> > level[2];\n\t\tint _max=0;\n\t\tREP(i,0,2){\n\t\t\tcin >> W[i] >> H[i] >> X[i] >> Y[i];\n\t\t\t--X[i]; --Y[i];\n\t\t\tfield[i].resize(H[i]);\n\t\t\tlevel[i].resize(H[i]);\n\t\t\tREP(j,0,H[i]){\n\t\t\t\tfield[i][j].resize(W[i]);\n\t\t\t\tlevel[i][j].resize(W[i]);\n\t\t\t}\n\t\t\tREP(y,0,H[i]) REP(x,0,W[i]){\n\t\t\t\tcin >> field[i][y][x];\n\t\t\t\tif(_max<field[i][y][x]){\n\t\t\t\t\t_max=field[i][y][x];\n\t\t\t\t}\n\t\t\t}\n\t\t\tBFS(field[i],level[i],Y[i],X[i],H[i],W[i]);\n\t\t\t/*\n\t\t\tcout << endl << endl;\n\t\t\tREP(y,0,H[i]){\n\t\t\t\tREP(x,0,W[i]) cout << level[i][y][x] << ' ';\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\t*/\n\t\t\t\n\t\t}\n\t\tvector<int> count[2],s[2];\n\t\tREP(i,0,2){\n\t\t\tcount[i].resize(_max+1);\n\t\t\ts[i].resize(_max+1);\n\t\t}\n\t\tREP(i,0,2) REP(y,0,H[i]) REP(x,0,W[i]) ++count[i][level[i][y][x]];\n\t\tREP(i,0,2) REP(j,1,_max+1) s[i][j]=s[i][j-1]+count[i][j];\n\t\tint result=INF;\n\t\tfor(int i=0; i<=_max&&i<=result; ++i){\n\t\t\t//cout << i << ' ' << s[0][i] << ' ' <<  (int)(lower_bound(s[1].begin(),s[1].end(),R-s[0][i])-s[1].begin()) << ' ' << s[1][(int)(lower_bound(s[1].begin(),s[1].end(),R-s[0][i])-s[1].begin())] << endl;\n\t\t\tint idx=(int)(lower_bound(s[1].begin(),s[1].end(),R-s[0][i])-s[1].begin());\n\t\t\tif(!(0<=idx&&idx<=_max)) continue;\n\t\t\tresult=min(result,i+idx);\n\t\t}\n\t\tcout << result << endl;\n\t}\n}\n\nint main(){\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<map>\n#include<algorithm>\n#define gs(x, r) (r==0?0:x[r-1])\nusing namespace std;\n#define INF (1 << 29)\ntypedef pair<int, int> P; \ntypedef pair<int, P> F;\nint xs[] = {-1, 0, 1, 0}, ys[] = {0, 1, 0, -1};\n\nvector<int> input_djk(int z){\n  int w, h, x ,y;\n  scanf(\"%d%d%d%d\", &w, &h ,&x ,&y);\n  int dist[w][h], level[w][h];\n  bool used[w][h];\n  priority_queue<F, vector<F>, greater<F> > pq;\n  x--,y--;\n  for(int j = 0;j < h;j++){\n    for(int i = 0;i < w;i++){\n      scanf(\"%d\", &level[i][j]);\n      dist[i][j] = INF;\n      used[i][j] = false;\n    }\n  }\n  dist[x][y] = 1;\n  used[x][y] = true;\n  pq.push(F(1, P(x, y)));\n  while(!pq.empty()){\n    F tmp = pq.top();pq.pop();\n    int tx = tmp.second.first, ty = tmp.second.second;\n    if(dist[tx][ty] < tmp.first)continue;\n    for(int i = 0;i < 4;i++){\n      if(tx + xs[i] < 0 || tx + xs[i] >= w || ty + ys[i] < 0 || ty + ys[i] >= h || used[tx + xs[i]][ty + ys[i]])continue;\n      tx += xs[i], ty += ys[i];\n      if(dist[tx][ty] > max(tmp.first, level[tx][ty])){\n\tdist[tx][ty] = max(tmp.first, level[tx][ty]);\n\tused[tx][ty] = true;\n\tpq.push(F(dist[tx][ty], P(tx, ty)));\n      }\n      tx -= xs[i], ty -= ys[i];\n    }\n  }\n  vector<int> res;\n  for(int i = 0;i < w;i++)\n    for(int j = 0;j < h;j++)\n      res.push_back(dist[i][j]);\n   \n  sort(res.begin(), res.end());\n  return res;\n}\n\n\nint solve(vector<int> a, vector<int> b, int r){\n  int res = INF;\n  for(int i = min(r,(int) a.size());i >= 0 && b.size() >= r - i;i--){\n    res = min(res, gs(a, i) + gs(b, r - i));\n  }\n  return res;\n}\n\nint main(){\n  while(true){\n    int r;\n    scanf(\"%d\", &r);\n    if(r == 0)return 0;\n    vector<int> a, b;\n    a = input_djk(0);\n    b = input_djk(1);\n    cout << solve(a, b, r) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<cassert>\n#include<queue>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 501\nusing namespace std;\n\nstruct P\n{\n  int x,y;\n  P(int x=inf,int y=inf):x(x),y(y){}\n  bool operator < (const P& a)const\n  {\n    return (x!=a.x?x<a.x:y<a.y);\n  } \n};\n\ntypedef pair<int,int> ii;\n\nint R;\nint room[2][MAX][MAX];\nint ex[2],ey[2];\nint h[2],w[2];\nvector<int> level[2];\nvector<ii> vec[2];\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\nint COST[2];\ndeque<P> deq[2];\nbool visited[2][MAX][MAX];\n\nint getCost(int sp,int l)\n{\n  if(room[sp][ey[sp]][ex[sp]] > l)return 0;\n\n  int H = h[sp], W = w[sp];\n\n  deque<P> store;\n  //cout << \"IN : level \" << l << endl;\n\n  while(!deq[sp].empty())\n    {\n      P p = deq[sp].front(); deq[sp].pop_front();\n\n      rep(i,4)\n\t{\n\t  int nx = p.x + dx[i];\n\t  int ny = p.y + dy[i];\n\t  if(!(0 <= nx && nx < W && 0 <= ny && ny < H))continue;\n\t  if(room[sp][ny][nx] > l)continue;\n\t  if(!visited[sp][ny][nx])\n\t    {\n\t      //cout << \"from \" << p.x << \",\" << p.y << \" goto \" << nx << \",\" << ny << \" level is \"<< room[sp][ny][nx] << endl;\n\t      visited[sp][ny][nx] = true;\n\t      deq[sp].push_back(P(nx,ny));\n\t      COST[sp]++;\n\t    }\n\t}\n\n      bool update = false;\n      rep(i,4)\n\t{\n\t  int nx = p.x + dx[i];\n\t  int ny = p.y + dy[i];\n\t  if(!(0 <= nx && nx < W && 0 <= ny && ny < H))continue;\n\t  if(visited[sp][ny][nx])continue;\n\t  update = true;\n\t  break;\n\t}      \n      if(update)store.push_back(p);\n    }\n  deq[sp] = store;\n  return COST[sp];\n}\n\nvoid compute()\n{\n  rep(i,2)\n    {\n      COST[i] = 0;\n      deq[i].clear();\n      deq[i].push_back(P(ex[i],ey[i]));\n      visited[i][ey[i]][ex[i]] = true;\n      vec[i].push_back(ii(0,0));\n      rep(y,h[i])rep(x,w[i])visited[i][y][x] = false;\n\n      rep(j,level[i].size())\n\t{\n\t  int cost = getCost(i,level[i][j]);\n\t  vec[i].push_back(ii(cost,level[i][j]));\n\t}\n      sort(all(vec[i]));\n    }\n\n  /*\n  rep(i,2)\n    {\n      rep(j,vec[i].size())\n\t{\n\t  cout << \"vec[\"<<i<<\"][\"<<j<<\"] = (\" << vec[i][j].first << \",\" << vec[i][j].second << \")\\n\";\n\t}\n    }\n  */\n\n  int minlevel = inf;\n  rep(i,vec[0].size())\n    {\n      int lvl = vec[0][i].second;\n      int cost = vec[0][i].first;\n      int request = R - cost;\n      if(request <= 0)\n\t{\n\t  minlevel = min(minlevel,lvl);\n\t  continue;\n\t}\n\n      if(lower_bound(all(vec[1]),ii(request,-1)) == vec[1].end())continue;\n      ii store = *lower_bound(all(vec[1]),ii(request,-1));\n      int nlvl = store.second;\n      int ncost = store.first;\n\n      minlevel = min(minlevel,lvl+nlvl);\n    }\n  cout << minlevel << endl;\n}\n\nint main()\n{\n  while(cin >> R,R)\n    {\n      rep(i,2)\n\t{\n\t  level[i].clear(),vec[i].clear();\n\t  cin >> w[i] >> h[i] >> ex[i] >> ey[i];\n\t  ex[i]--,ey[i]--;\n\t  rep(y,h[i])rep(x,w[i])cin >> room[i][y][x],level[i].push_back(room[i][y][x]);\n\t  sort(all(level[i]));\n\t  level[i].erase(unique(all(level[i])),level[i].end());\n\t}\n      compute();\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pint;\ntypedef pair<ll, int> P;\n//typedef tuple<int,int,int> T;\nll INFL = 1000000000000000010;//10^18 = 2^60\nint INF = 2147483600;//10^9\nll MOD  = 1000000007;\nvector<int> dy = {1,-1,0,0};\nvector<int> dx = {0,0,1,-1};\nvector<int> Ans(0);\nvector<vector<int>> mp1(510, vector<int>(510));\nvector<vector<int>> mp2(510, vector<int>(510));\nvector<vector<int>> d1(510, vector<int>(510));\nvector<vector<int>> d2(510, vector<int>(510));\nint solve(){\n    int R;\n    cin >> R;\n    if(R == 0) return 0;\n    int H1,W1,X1,Y1;\n    cin >> W1 >> H1 >> X1 >> Y1;\n    X1--;\n    Y1--;\n    for(int i = 0; i < H1; i++) for(int j = 0; j < W1; j++) d1[i][j] = INF;\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            cin >> mp1[i][j];\n        }\n    }\n    \n    d1[Y1][X1] = 1;\n    priority_queue<pair<int, pair<int, int>>> pque1;\n    pque1.push({1, {Y1, X1}});\n    \n    while(!pque1.empty()){\n        int c;\n        int y,x;\n        c = pque1.top().first;\n        y = pque1.top().second.first;\n        x = pque1.top().second.second;\n        pque1.pop();\n        if(c > d1[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H1 && 0 <= nx && nx < W1){\n                if(d1[ny][nx] > d1[y][x]){\n                    if(d1[y][x] > mp1[ny][nx]){\n                        d1[ny][nx] = d1[y][x];\n                    }else{\n                        d1[ny][nx] = mp1[ny][nx];\n                    }\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }else if(d1[ny][nx] > d1[y][x]){\n                    d1[ny][nx] = mp1[ny][nx];\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    int H2,W2,X2,Y2;\n    cin >> W2 >> H2 >> X2 >> Y2;\n    X2--;\n    Y2--;\n    for(int i = 0; i < H2; i++) for(int j = 0; j < W2; j++) d2[i][j] = INF;\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            cin >> mp2[i][j];\n        }\n    }\n    \n    d2[Y2][X2] = 1;\n    priority_queue<pair<int, pair<int, int>>> pque2;\n    pque2.push({1, {Y2, X2}});\n    \n    while(!pque2.empty()){\n        int c;\n        int y,x;\n        c = pque2.top().first;\n        y = pque2.top().second.first;\n        x = pque2.top().second.second;\n        pque2.pop();\n        if(c > d2[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H2 && 0 <= nx && nx < W2){\n                if(d2[ny][nx] > d2[y][x]){\n                    if(d2[y][x] > mp2[ny][nx]){\n                        d2[ny][nx] = d2[y][x];\n                    }else{\n                        d2[ny][nx] = mp2[ny][nx];\n                    }\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }else if(d2[ny][nx] > d2[y][x]){\n                    d2[ny][nx] = mp2[ny][nx];\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    vector<pair<int,int>> O1(0);\n    vector<int> COST1(0);\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            COST1.push_back(d1[i][j]);\n        }\n    }\n    sort(COST1.begin(), COST1.end());\n    COST1.push_back(INFL);\n    int ad1 = COST1.at(0);\n    for(int i = 0; i < COST1.size(); i++){\n        if(ad1 == COST1.at(i)){\n        }else{\n            O1.push_back({ad1, i});\n            ad1 = COST1.at(i);\n        }\n    }\n    \n    vector<pair<int,int>> O2(1);\n    O2.at(0).first = 0;\n    O2.at(0).second = 0;\n    vector<int> COST2(0);\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            COST2.push_back(d2[i][j]);\n        }\n    }\n    sort(COST2.begin(), COST2.end());\n    COST2.push_back(INFL);\n    int ad2 = COST2.at(0);\n    for(int i = 0; i < COST2.size(); i++){\n        if(ad2 == COST2.at(i)){\n        }else{\n            O2.push_back({ad2, i});\n            ad2 = COST2.at(i);\n        }\n    }\n    \n    \n    int ans = INF;\n    int right = -1;\n    for(int i = 0; i < O1.size(); i++){\n        int cost = O1.at(i).first;\n        int rest = R - O1.at(i).second;\n        \n        if(rest > O2.at(O2.size()-1).second) continue;\n        int left = -1;\n        if(right == -1){\n            right = O2.size();\n        }\n        int mid;\n        while(right - left > 1){\n            mid = (left + right) / 2;\n            if(O2.at(mid).second >= rest){\n                right = mid;\n            }else{\n                left = mid;\n            }\n        }\n        cost += O2.at(right).first;\n        ans = min(ans, cost);\n    }\n    \n    Ans.push_back(ans);\n    solve();\n    return 0;\n}\nint main(void){\n    solve();\n    for(int i = 0; i < Ans.size(); i++){\n        cout << Ans.at(i) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <tuple>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nconst vector<int> dx = { 0, 1, 0, -1 };\nconst vector<int> dy = { -1, 0, 1, 0 };\n\nint R, W[2], H[2], X[2], Y[2], F[2][500][500], D[2][500][500];\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &R);\n\n\t\tif (R == 0) break;\n\n\t\tfor (int i = 0; i < 2; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &W[i]);\n\t\t\tscanf(\"%d\", &H[i]);\n\t\t\tscanf(\"%d\", &X[i]); X[i]--;\n\t\t\tscanf(\"%d\", &Y[i]); Y[i]--;\n\n\t\t\tfor (int j = 0; j < H[i]; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < W[i]; k++)\n\t\t\t\t{\n\t\t\t\t\tscanf(\"%d\", &F[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(D, -1, sizeof(D));\n\n\t\tfor (int i = 0; i < 2; i++)\n\t\t{\n\t\t\tD[i][Y[i]][X[i]] = 1;\n\n\t\t\tpriority_queue<tuple<int, int, int>, vector<tuple<int, int, int> >, greater<tuple<int, int, int> > > que;\n\n\t\t\tque.push(make_tuple(0, X[i], Y[i]));\n\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\ttuple<int, int, int> state = que.top(); que.pop();\n\n\t\t\t\tint d = get<0>(state);\n\t\t\t\tint x = get<1>(state);\n\t\t\t\tint y = get<2>(state);\n\n\t\t\t\tfor (int dir = 0; dir < 4; dir++)\n\t\t\t\t{\n\t\t\t\t\tint x2 = x + dx[dir];\n\t\t\t\t\tint y2 = y + dy[dir];\n\n\t\t\t\t\tif (0 <= x2 && x2 < W[i] && 0 <= y2 && y2 < H[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (D[i][y2][x2] == -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tD[i][y2][x2] = max(d, F[i][y2][x2]);\n\n\t\t\t\t\t\t\tque.push(make_tuple(D[i][y2][x2], x2, y2));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<int> E[2];\n\n\t\tfor (int i = 0; i < 2; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < H[i]; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < W[i]; k++)\n\t\t\t\t{\n\t\t\t\t\tE[i].push_back(D[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsort(E[i].begin(), E[i].end());\n\t\t}\n\n\t\tint ret = 999999999;\n\n\t\tint petl = E[0].size();\n\t\tint petr = E[1].size();\n\n\t\tfor (int i = 0; i < R - 2; i++)\n\t\t{\n\t\t\tif (i < petl && R - i < petr)\n\t\t\t{\n\t\t\t\tret = min(ret, E[0][i] + E[1][R - i]);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nint w[2], h[2], l[2][500][500], sx[2], sy[2], r;\nint dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nint ans[2][100001], d[250000];\nbool vis[500][500], used[500][500];\ndeque<P>que[250000];\nint compress(int k) {\n\tvector<int>x;\n\trep(i, h[k])rep(j, w[k])x.push_back(l[k][i][j]);\n\tsort(x.begin(), x.end());\n\tx.erase(unique(x.begin(), x.end()), x.end());\n\trep(i, x.size())d[i] = x[i];\n\trep(i, h[k])rep(j, w[k])\n\t\tl[k][i][j] = lower_bound(x.begin(), x.end(), l[k][i][j]) - x.begin();\n\treturn x.size();\n}\nvoid solve(int k) {\n\tans[k][0] = 0;\n\tqueue<P>Q;\n\tint n = compress(k);\n\trep(i, n)que[i].clear();\n\tmemset(vis, 0, sizeof(vis));\n\tmemset(used, 0, sizeof(used));\n\tQ.push(P(sx[k], sy[k]));\n\tvis[sx[k]][sy[k]] = true;\n\tint cnt = 0, Max = 0;\n\twhile (1) {\n\t\twhile (!Q.empty()) {\n\t\t\tP p = Q.front(); Q.pop();\n\t\t\tif (used[p.first][p.second])continue;\n\t\t\tused[p.first][p.second] = true;\n\t\t\tcnt++; if (cnt >= r)break;\n\t\t\trep(i, 4) {\n\t\t\t\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\tif (0 <= nx&&nx < h[k] && 0 <= ny&&ny < w[k] && !vis[nx][ny]) {\n\t\t\t\t\tvis[nx][ny] = true;\n\t\t\t\t\tif (l[k][nx][ny] <= Max)Q.push(P(nx, ny));\n\t\t\t\t\telse que[l[k][nx][ny]].push_back(P(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans[k][cnt] = min(ans[k][cnt], d[Max]);\n\t\tfor (int i = Max; i < n; i++) {\n\t\t\tif (!que[i].empty()) {\n\t\t\t\tMax = i;\n\t\t\t\tfor (P p : que[i])Q.push(p);\n\t\t\t\tque[i].clear();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (cnt >= r || Q.empty())break;\n\t}\n\tfor (int i = r - 1; i >= 1; i--)ans[k][i] = min(ans[k][i], ans[k][i + 1]);\n}\nint main() {\n\twhile (scanf(\"%d\", &r), r) {\n\t\trep(k, 2) {\n\t\t\tscanf(\"%d%d%d%d\", &w[k], &h[k], &sy[k], &sx[k]); sx[k]--; sy[k]--;\n\t\t\trep(i, h[k])rep(j, w[k])scanf(\"%d\", &l[k][i][j]);\n\t\t}\n\t\tfill(ans[0], ans[2], INT_MAX);\n\t\trep(k, 2)solve(k);\n\t\tint Min = INT_MAX;\n\t\tfor (int i = 0; i <= r; i++) {\n\t\t\tif (ans[0][i] == INT_MAX || ans[1][r - i] == INT_MAX)continue;\n\t\t\tMin = min(Min, ans[0][i] + ans[1][r - i]);\n\t\t}\n\t\tprintf(\"%d\\n\", Min);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define MOD 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nstruct pos{\n  int x;\n  int y;\n  int d;\n};\n\nint main(){\n  int v[5]={0,1,0,-1,0};\n  while(1){\n    int r;\n    cin >> r;\n    if(r==0) return 0;\n    int w,h,x,y;\n    cin >> w >> h >> x >> y;\n    x--,y--;\n    vector<vector<int>> m(h,vector<int>(w));\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> m[i][j];\n      }\n    }\n    priority_queue<pos,vector<pos>,function<bool(pos,pos)>>\n      q([](const pos &a, const pos &b){return a.d>b.d;});\n    q.push({x,y,1});\n    m[y][x]=-1;\n    vector<int> a(w*h+1);\n    a[0]=0;\n    int nowidx=1;\n    pos now;\n    while(!q.empty()){\n      now=q.top();\n      q.pop();\n      a[nowidx]=max(now.d,a[nowidx-1]);\n      // cout << a[nowidx] << \" \";\n      nowidx++;\n      for(int i=0;i<4;i++){\n        int nx=now.x+v[i+1];\n        int ny=now.y+v[i];\n        if(0<=nx&&nx<w&&0<=ny&&ny<h){\n          if(m[ny][nx]>0){\n            q.push({nx,ny,m[ny][nx]});\n            m[ny][nx]=-1;\n          }\n        }\n      }\n    }\n    // cout << endl;\n    cin >> w >> h >> x >> y;\n    x--,y--;\n    m=vector<vector<int>>(h,vector<int>(w));\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> m[i][j];\n      }\n    }\n    q.push({x,y,1});\n    m[y][x]=-1;\n    vector<int> b(w*h+1);\n    b[0]=0;\n    nowidx=1;\n    while(!q.empty()){\n      now=q.top();\n      q.pop();\n      // cout << now.d SP b[nowidx-1] << endl;\n      b[nowidx]=max(now.d,b[nowidx-1]);\n      // cout << b[nowidx] << endl;\n      nowidx++;\n      for(int i=0;i<4;i++){\n        int nx=now.x+v[i+1];\n        int ny=now.y+v[i];\n        if(0<=nx&&nx<w&&0<=ny&&ny<h){\n          if(m[ny][nx]>0){\n            q.push({nx,ny,m[ny][nx]});\n            m[ny][nx]=-1;\n          }\n        }\n      }\n    }\n    // cout << endl;\n    int ans=IINF;\n    for(int i=0;i<=min(r,(int)a.size()-1)&&r-i<=b.size()-1;i++){\n      ans=min(ans,a[i]+b[r-i]);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//c\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <memory>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n \n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define REPR(i,b,n) for(int i=n-1;i>=b;i--)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\n#define NCLR(mat) memset(mat, -1, sizeof(mat))\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define EACH(i, c) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define BIT(n, b) ((n>>b) & 1)\n#define PB push_back\n#define MP make_pair\n \nusing namespace std;\n \nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-9;\ntypedef long long ll;\ntypedef pair<int, int> pii;   \n \nint r;\nint w[2], h[2], ex[2], ey[2];\nint room[2][512][512];\nbool vis[512][512];\n \nint rec(int x, int y, int k, int lev){\n     \n    int res = 0;\n     \n    if(x < 0 || w[k] <= x || y < 0 || h[k] <= y \n        || vis[x][y] || lev < room[k][x][y]){\n        return 0;\n    }\n     \n    vis[x][y] = true;\n     \n    res += rec(x+1, y, k, lev);\n    res += rec(x-1, y, k, lev);\n    res += rec(x, y+1, k, lev);\n    res += rec(x, y-1, k, lev);\n     \n    return res + 1;\n}\n \nint main(){\n     \n    while(cin>>r, r){\n         \n        vector< vector<int> > exlev(2);\n        vector< vector<int> > reach(2);\n         \n        for(int k=0; k<2; ++k){\n             \n            cin>>w[k]>>h[k]>>ex[k]>>ey[k];\n            ex[k]--;\n            ey[k]--;\n             \n             \n            exlev[k].push_back(0);\n             \n            for(int y=0; y<h[k]; ++y){\n                for(int x=0; x<w[k]; ++x){\n\t\t\t\t\n                    cin>>room[k][x][y];\n                    exlev[k].push_back(room[k][x][y]);\n                }\n            }\n\t\t\t\n\t\t\tsort( exlev[k].begin(), exlev[k].end() );\n\t\t\texlev[k].erase( unique(exlev[k].begin(), exlev[k].end()), exlev[k].end() );\n             \n            for(int i=0; i<exlev[k].size(); ++i){\n                CLR(vis);\n                reach[k].push_back(rec(ex[k], ey[k], k, exlev[k][i]));\n            }\n             \n        }\n         \n        int mn = INT_MAX/2;\n         \n        for(int i=0; i<reach[0].size(); ++i){\n            for(int j=lower_bound(reach[1].begin(), reach[1].end(), r-reach[0][i]) - reach[1].begin(); j<reach[1].size(); ++j){\n                 \n                if(reach[0][i]+reach[1][j]>=r){\n                    mn = min(mn, exlev[0][i]+exlev[1][j]);\n\t\t\t\t\tbreak;\n                }\n                 \n            }\n        }\n         \n        cout << mn << endl;\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\n\nint x[2],y[2],w[2],h[2];\nint R;\nvector<vvi> zimu;\n\nvoid dfs(int i, int x, int y, int& lev, vvi& used, int* mini, int* room){\n  //cout << \" \" << x << \" \" << y << endl; \n  used[y][x] = 1;\n  (*room)++;\n  for(int j=0; j<4; j++){\n    int nx = x + dx[j];\n    int ny = y + dy[j];\n    if(nx >= w[i] || nx < 0 || ny >= h[i] || ny < 0) continue; // ????£?\n    if(used[ny][nx] == 1) continue; // ??¢?´¢??????\n    if(zimu[i][ny][nx] > lev){ // ????¨???¬???????¶??????????\n      *mini = min( *mini, zimu[i][ny][nx] );\n      continue;\n    }\n    dfs(i,nx,ny,lev,used,mini,room);\n  }\n\n}\n\nint main(){\n  while(1){\n  \n    cin >> R; if(!R) break;\n    zimu.clear();\n    \n    // ??\\???\n    for(int i=0; i<2; i++){\n      cin >> w[i] >> h[i] >> x[i] >> y[i];\n  \n      zimu.push_back(vvi(h[i],vi(w[i])));\n\n      for(int j=0; j<h[i]; j++)\n\tfor(int k=0; k<w[i]; k++)\n\t  cin >> zimu[i][j][k];\n    }\n\n    // \n    vector<vector<pair<int,int> > > list(2); // ???????????¨?±???°???????¨???¬??????\n    \n    for(int i=0; i<2; i++){\n      list[i].push_back(pii(0,0));\n      int lev=1;\n      int mini=1e+9;\n      int room=0;\n      do{\n\troom=0;\n\tvvi used(h[i],vi(w[i],0));\n\tdfs(i,x[i]-1,y[i]-1,lev,used,&mini,&room);\n\t//cout << room << \" \"<< lev << endl;\n\tlist[i].push_back(pii(room,lev));\n\tlev = mini;\n\tmini = 1e+9;\n      }while(room != w[i]*h[i]);// ??????????????¨?±?????????????????¨???¬???????????§\n    }\n    /*    \n    for(int i=0; i<2; i++){\n      for(int j=0; j<list[i].size(); j++)\n\tcout << \"(\" << list[i][j].first << \",\" << list[i][j].second << \"), \";\n      cout << endl;\n    }\n    */\t\n\n\n    int ans = 1e+9;\n    for(int i=0; i<list[0].size(); i++){\n      int rooma = list[0][i].first;\n      int autha = list[0][i].second;\n      pii tmp = *lower_bound(list[1].begin(),list[1].end(), pii(R-rooma,0));\n      int roomb = tmp.first;\n      int authb = tmp.second;\n      if(rooma + roomb < R) continue;\n      ans = min(ans,autha + authb);\n    }\n    cout << ans << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<algorithm>\n#include<functional>\n\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<long long int,P> PP;\nint r;\nint w[2],h[2];\nint x[2],y[2];\nint dx[4]={0,0,-1,1},dy[4]={1,-1,0,0};\nlong long int field[2][501][501];\nbool used[2][501][501];\nlong long int INF=10000000000000;\nlong long int dp[2][25001];\nlong long int ans;\n\nvoid dfs(int i,int sx,int sy){\n\tpriority_queue<PP , vector<PP> , greater<PP> > que;\n\tint fl=1;\n\tque.push(PP(field[i][sx][sy],P(sx,sy)));\n\tused[i][sx][sy]=true;\n\twhile(que.size()){\n\t\tPP q=que.top();que.pop();\n\t\tlong long int c=q.first;\n\t\tint mx=q.second.first,my=q.second.second;\n\t\tdp[i][fl]=max(dp[i][fl-1],c);\n\t\tfl++;\n\t\tfor(int j=0;j<4;j++){\n\t\t\tint nx=mx+dx[j],ny=my+dy[j];\n\t\t\tif(nx>=0 && nx<w[i] && ny>=0 && ny<h[i] && used[i][nx][ny]==false){\n\t\t\t\tque.push(PP(field[i][nx][ny],P(nx,ny)));\n\t\t\t\tused[i][nx][ny]=true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&r);\n\t\tif(r==0)break;\n\t\tfor(int i=1;i<=25000;i++)dp[0][i]=dp[1][i]=INF;\n\t\tmemset(field,0,sizeof(field));\n\t\tmemset(used,false,sizeof(used));\n\n\t\tscanf(\"%d%d%d%d\",&w[0],&h[0],&x[0],&y[0]);\n\t\tfor(int i=0;i<h[0];i++){\n\t\t\tfor(int j=0;j<w[0];j++){\n\t\t\t\tscanf(\"%d\",&field[0][j][i]);\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d%d%d%d\",&w[1],&h[1],&x[1],&y[1]);\n\t\tfor(int i=0;i<h[1];i++){\n\t\t\tfor(int j=0;j<w[1];j++){\n\t\t\t\tscanf(\"%d\",&field[1][j][i]);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<2;i++)dfs(i,x[i]-1,y[i]-1);\n\t\tans=INF;\n\t\tfor(int i=0;i<=r;i++){\n\t\t\tans=min(ans,dp[0][i]+dp[1][r-i]);\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\n\nconst int INF=1000000000;\nconst long long int INF_=1000000000000000000;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\ninline bool IsIn(int y,int x,int h,int w){\n\treturn 0<=y&&y<h&&0<=x&&x<w;\n}\n\nvoid BFS(vector<vector<int> > &f,vector<vector<int> > &l,int sy,int sx,int h,int w){\n\tvector<vector<int> > done(h,vector<int>(w));\n\tvector<vector<int> > done_(h,vector<int>(w));\n\tl[sy][sx]=1;\n\tdone[sy][sx]=done_[sy][sx]=1;\n\tqueue<Pi> que;\n\tREP(i,0,4){\n\t\tint ny=sy+dy[i],nx=sx+dx[i];\n\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\tdone_[ny][nx]=1;\n\t\tque.push(Pi(ny,nx));\n\t}\n\twhile(!que.empty()){\n\t\tPi p=que.front();\n\t\tque.pop();\n\t\tdone[p.F_][p.S_]=1;\n\t\tbool flag=true;\n\t\tint tmp=INF;\n\t\tREP(i,0,4){\n\t\t\tint ny=p.F_+dy[i],nx=p.S_+dx[i];\n\t\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\t\tif(done[ny][nx]==1) tmp=min(tmp,l[ny][nx]);\n\t\t\tif(done[ny][nx]==1&&l[ny][nx]>=f[p.F_][p.S_]) flag=false;\n\t\t\tif(done_[ny][nx]!=1){\n\t\t\t\tdone_[ny][nx]=1;\n\t\t\t\tque.push(Pi(ny,nx));\n\t\t\t}\n\t\t}\n\t\tif(flag) l[p.F_][p.S_]=f[p.F_][p.S_];\n\t\telse {\n\t\t\tif(tmp!=INF) l[p.F_][p.S_]=max(tmp,f[p.F_][p.S_]);\n\t\t\telse l[p.F_][p.S_]=f[p.F_][p.S_];\n\t\t}\n\t}\n}\n\ninline int f(int x){\n\tif(x==0) return 1;\n\telse if(x==1) return 0;\n}\n\nvoid solve(){\n\tint R;\n\twhile(cin >> R&&R){\n\t\tint W[2],H[2],X[2],Y[2];\n\t\tvector<vector<int> > field[2];\n\t\tvector<vector<int> > level[2];\n\t\tint max_[2]={};\n\t\tREP(i,0,2){\n\t\t\tcin >> W[i] >> H[i] >> X[i] >> Y[i];\n\t\t\t--X[i]; --Y[i];\n\t\t\tfield[i].resize(H[i]);\n\t\t\tlevel[i].resize(H[i]);\n\t\t\tREP(j,0,H[i]){\n\t\t\t\tfield[i][j].resize(W[i]);\n\t\t\t\tlevel[i][j].resize(W[i]);\n\t\t\t}\n\t\t\tREP(y,0,H[i]) REP(x,0,W[i]){\n\t\t\t\tcin >> field[i][y][x];\n\t\t\t\tmax_[i]=max(max_[i],field[i][y][x]);\n\t\t\t}\n\t\t\tBFS(field[i],level[i],Y[i],X[i],H[i],W[i]);\n\t\t\t/*\n\t\t\tcout << endl << endl;\n\t\t\tREP(y,0,H[i]){\n\t\t\t\tREP(x,0,W[i]) cout << level[i][y][x] << ' ';\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\t/*\n\t\tvector<unsigned int> s[2];\n\t\tREP(i,0,2){\n\t\t\ts[i].resize(max_[i]+1);\n\t\t\tREP(y,0,H[i]) REP(x,0,W[i]) ++s[i][level[i][y][x]];\n\t\t\tREP(j,1,max_[i]+1) s[i][j]+=s[i][j-1];\n\t\t}\n\t\tint result=INF;\n\t\tREP(i,0,2){\n\t\t\tfor(int j=0; j<=max_[i]&&j<=result; ++j){\n\t\t\t\tint idx=(int)(lower_bound(s[i].begin(),s[i].end(),R-s[f(i)][j])-s[i].begin());\n\t\t\t\tif(!(0<=idx&&idx<=max_[i])) continue;\n\t\t\t\tresult=min(result,j+idx);\n\t\t\t}\n\t\t}\n\t\tcout << result << endl;\n\t\t*/\n\t\tmap<int,int> s[2];\n\t\tvector<int> idx[2],num[2];\n\t\tREP(i,0,2){\n\t\t\tREP(y,0,H[i]) REP(x,0,W[i]) ++s[i][level[i][y][x]];\n\t\t\tauto it=s[i].begin();\n\t\t\tidx[i].push_back(0);\n\t\t\tnum[i].push_back(0);\n\t\t\tidx[i].push_back(it->F_);\n\t\t\tnum[i].push_back(it->S_);\n\t\t\tauto prev=it;\n\t\t\t++it;\n\t\t\tfor(; it!=s[i].end(); ++it,++prev){\n\t\t\t\tit->S_+=prev->S_;\n\t\t\t\t//cout << it->F_ << ' ' << it->S_ << endl;\n\t\t\t\tidx[i].push_back(it->F_);\n\t\t\t\tnum[i].push_back(it->S_);\n\t\t\t}\n\t\t}\n\t\tint result=INF;\n\t\t/*\n\t\tcout << endl;\n\t\tREP(i,0,2) REP(j,0,idx[i].size()){\n\t\t\tcout << i << ' ' << idx[i][j] << ' ' << num[i][j] << endl;\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\t\tREP(i,0,2) REP(j,0,idx[i].size()){\n\t\t\tint tmp=(int)(lower_bound(num[f(i)].begin(),num[f(i)].end(),R-num[i][j])-num[f(i)].begin());\n\t\t\t//cout << idx[i][tmp] << ' ' << num[i][tmp] << ' ' << idx[f(i)][j] << ' ' << num[f(i)][j] << endl;\n\t\t\tif(!(0<=tmp&&tmp<=idx[f(i)].size()-1)) continue;\n\t\t\tresult=min(result,idx[i][j]+idx[f(i)][tmp]);\n\t\t}\n\t\tcout << result << endl;\n\t}\n}\n\nint main(){\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,-1,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pint pair<int,int>\n#define tint tuple<int,int,int>\n#define INF 1<<29\n#define MAX 501\nusing namespace std;\n\nint R,W[2],H[2],X[2],Y[2],L[2][MAX][MAX],d[2][MAX][MAX],dd[4]={0,-1,0,1};\nmap<int,int> m[2];\nmap<int,int>::iterator ite;\n\nvoid solve(){\n for(;;){\n  cin>>R;\n  if(!R) return;\n  FOR(i,2){\n   cin>>W[i]>>H[i]>>X[i]>>Y[i];\n   X[i]--;\n   Y[i]--;\n   FOR(j,H[i]) FOR(k,W[i]) cin>>L[i][j][k];\n   FOR(j,H[i]) FOR(k,W[i]) d[i][j][k]=INT_MAX/3;\n   d[i][X[i]][Y[i]]=1;\n   priority_queue<pint,vector<pint>,greater<pint>> pque;\n   pque.push(mp(1,X[i]*W[i]+Y[i]));\n   while(!pque.empty()){\n    pint p=pque.top(); pque.pop();\n    int x=p.second/W[i],y=p.second-x*W[i];\n    if(d[i][x][y]<p.first) continue;\n    FOR(j,4){\n     int nx=x+dd[j],ny=y+dd[j^1];\n     if(nx<0||ny<0||nx>=H[i]||ny>=W[i]) continue;\n     if(d[i][nx][ny]>max(d[i][x][y],L[i][x][y])){\n      d[i][nx][ny]=max(d[i][x][y],L[i][x][y]);\n      pque.push(mp(d[i][nx][ny],nx*W[i]+ny));\n     }\n    }\n   }\n   FOR(j,H[i]) FOR(k,W[i]) m[i][d[i][j][k]]++;\n   for(ite=m[i].begin();ite!=m[i].end();ite++){\n    if(ite==m[i].begin()) continue;\n    m[i][ite->first]+=m[i][(--ite)->first];\n    ite++;\n   }\n  }\n  int mi=m[1].lower_bound(R)->first;\n  for(ite=m[0].begin();ite!=m[0].end();ite++){\n   mi=min(mi,(ite->first)+(m[1].lower_bound(R-(ite->second))->first));\n  }\n  cout<<mi<<endl;\n  FOR(i,2) map[i].clear();\n }\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include<string.h>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef pair<int,pair<int,int> > PP;\nint r,w[2],h[2],x[2],y[2];\nlong long level[501][501][2];\nbool used[501][501][2]={};\nlong long sparklingdaydream[501][501][2];\nlong long need[250005][2]={};\nlong long s[250005]={},d[250005]={};\nint main(){\n    while(1){\n        memset(need,0,sizeof(need) );\n        memset(s,0,sizeof(s) );\n        memset(d,0,sizeof(d) );\n        memset(used,false,sizeof(used) );\n    priority_queue<PP,vector<PP>,greater<PP> >pque;\n    scanf(\"%d\",&r);\n    if(r==0) break;\n    scanf(\"%d %d %d %d\",&w[0],&h[0],&x[0],&y[0]);\n    for(int r=0;r<501;r++){\n        for(int g=0;g<501;g++){\n                sparklingdaydream[r][g][0]=1000000000000;\n                level[r][g][0]=1000000000000;\n            }\n        }\n    for(int i=1;i<=h[0];i++){\n        for(int j=1;j<=w[0];j++){\n            scanf(\"%lld\",&level[j][i][0]);\n        }\n    }\n    sparklingdaydream[x[0]][y[0]][0]=1;\n    pque.push(make_pair(sparklingdaydream[x[0]][y[0]][0],make_pair(x[0],y[0])));\n    int dx[3]={0,1,-1};\n    int dy[3]={0,1,-1};\n    while(!pque.empty()){\n        PP p=pque.top();\n        pque.pop();\n        used[p.second.first][p.second.second][0]=true;\n        for(int k=0;k<3;k++){\n            for(int l=0;l<3;l++){\n                if(k!=l && (k==0 || l==0)){\n                    if(!used[p.second.first+dx[k]][p.second.second+dy[l]][0]){\n                        if(p.second.first+dx[k]>=1 && p.second.first+dx[k]<=w[0] && p.second.second+dy[l]>=1 && p.second.second+dy[l]<=h[0]){\n                            long long h=p.first;\n                            sparklingdaydream[p.second.first+dx[k]][p.second.second+dy[l]][0]=max(h,level[p.second.first+dx[k]][p.second.second+dy[l]][0]);\n                            pque.push(make_pair(sparklingdaydream[p.second.first+dx[k]][p.second.second+dy[l]][0],make_pair(p.second.first+dx[k],p.second.second+dy[l])));\n                            used[p.second.first+dx[k]][p.second.second+dy[l]][0]=true;\n                        }\n                    }\n                    }\n                }\n            }\n        }\n    for(int r=0;r<501;r++){\n        for(int g=0;g<501;g++){\n                sparklingdaydream[r][g][1]=1000000000000;\n                level[r][g][1]=1000000000000;\n            }\n        }\n    scanf(\"%d %d %d %d\",&w[1],&h[1],&x[1],&y[1]);\n    for(int i=1;i<=h[1];i++){\n        for(int j=1;j<=w[1];j++){\n            scanf(\"%lld\",&level[j][i][1]);\n        }\n    }\n    sparklingdaydream[x[1]][y[1]][1]=1;\n    pque.push(make_pair(sparklingdaydream[x[1]][y[1]][1],make_pair(x[1],y[1])));\n    while(!pque.empty()){\n        PP p=pque.top();\n        pque.pop();\n        used[p.second.first][p.second.second][1]=true;\n        for(int k=0;k<3;k++){\n            for(int l=0;l<3;l++){\n                if(k!=l && (k==0 || l==0)){\n                    if(!used[p.second.first+dx[k]][p.second.second+dy[l]][1]){\n                        if(p.second.first+dx[k]>=1 && p.second.first+dx[k]<=w[1] && p.second.second+dy[l]>=1 && p.second.second+dy[l]<=h[1]){\n                            long long h=p.first;\n                            sparklingdaydream[p.second.first+dx[k]][p.second.second+dy[l]][1]=max(h,level[p.second.first+dx[k]][p.second.second+dy[l]][1]);\n                            pque.push(make_pair(sparklingdaydream[p.second.first+dx[k]][p.second.second+dy[l]][1],make_pair(p.second.first+dx[k],p.second.second+dy[l])));\n                            used[p.second.first+dx[k]][p.second.second+dy[l]][1]=true;\n                        }\n                    }\n                    }\n                }\n            }\n        }\n    int g=0;\n    for(int i=1;i<=w[0];i++){\n        for(int j=1;j<=h[0];j++){\n            s[g]=sparklingdaydream[i][j][0];\n            g++;\n        }\n    }\n    sort(s,s+g);\n    int eee=1;\n    for(int i=0;i<g;i++){\n        if(s[i]!=s[i+1]){\n            for(int j=eee;j<=i+1;j++){\n                need[j][0]=s[i];\n                eee=i+2;\n            }\n        }\n    }\n    g=0;\n    for(int i=1;i<=w[1];i++){\n        for(int j=1;j<=h[1];j++){\n            d[g]=sparklingdaydream[i][j][1];\n            g++;\n        }\n    }\n    sort(d,d+g);\n    eee=1;\n    for(int i=0;i<g;i++){\n        if(d[i]!=d[i+1]){\n            for(int j=eee;j<=i+1;j++){\n                need[j][1]=d[i];\n                eee=i+2;\n            }\n        }\n    }\n    long long ans=10000000000;\n    for(int i=1;i<250005;i++){\n        for(int j=0;j<2;j++){\n            if(!need[i][j]){\n            need[i][j]=10000000000000;\n            }\n        }\n    }\n    for(int i=0;i<=r;i++){\n        ans=min(ans,need[i][0]+need[r-i][1]);\n    }\n    printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n\n "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#define INF (1 << 29)\ntypedef pair<int, int> P; \ntypedef pair<int, P> F;\npriority_queue<F, vector<F>, greater<F> > pq[2];\nint xs[] = {-1, 0, 1, 0}, ys[] = {0, 1, 0, -1};\nvector<int> input_djk(int z){\n  int w, h, x ,y;\n  cin >> w >> h >> x >> y;\n  x--,y--;\n  int dist[w][h], level[w][h];\n  bool used[w][h];\n  for(int j = 0;j < h;j++){\n    for(int i = 0;i < w;i++){\n      scanf(\"%d\", &level[i][j]);\n      dist[i][j] = INF;\n      used[i][j] = false;\n    }\n  }\n  dist[x][y] = 1;\n  used[x][y] = true;\n  pq[z].push(F(1, P(x, y)));\n  while(!pq[z].empty()){\n    F tmp = pq[z].top();pq[z].pop();\n    int tx = tmp.second.first, ty = tmp.second.second;\n    if(dist[tx][ty] < tmp.first)continue;\n    for(int i = 0;i < 4;i++){\n      if(tx + xs[i] < 0 || tx + xs[i] >= w || ty + ys[i] < 0 || ty + ys[i] >= h || used[tx + xs[i]][ty + ys[i]])continue;\n      tx += xs[i], ty += ys[i];\n      if(dist[tx][ty] > max(tmp.first, level[tx][ty])){\n\tdist[tx][ty] = max(tmp.first, level[tx][ty]);\n\tused[tx][ty] = true;\n\tpq[z].push(F(dist[tx][ty], P(tx, ty)));\n      }\n      tx -= xs[i], ty -= ys[i];\n    }\n  }\n  vector<int> res;\n  for(int i = 0;i < w;i++)\n    for(int j = 0;j < h;j++)\n      res.push_back(dist[i][j]);\n   \n  sort(res.begin(), res.end());\n  return res;\n}\n\nint gs(vector<int> x, int r){\n  if(r == 0)return 0;\n  else return x[r - 1];\n}\n\n\nint solve(vector<int> a, vector<int> b, int r){\n  int res = INF;\n  for(int i = min(r,(int) a.size());i >= 0 && b.size() >= r - i;i--){\n    res = min(res, gs(a, i) + gs(b, r - i));\n  }\n  return res;\n}\n\nint main(){\n  while(true){\n    int r;\n    cin >> r;\n    if(r == 0)return 0;\n    vector<int> a, b;\n    a = input_djk(0);\n    b = input_djk(1);\n    cout << solve(a, b, r) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef pair<int,pair<int,int> > PP;\nint r,w[2],h[2],x[2],y[2];\nlong long level[501][501][2];\nbool used[501][501][2]={};\nlong long sparklingdaydream[501][501][2];\nlong long need[250005][2]={};\nlong long s[250005]={},d[250005]={};\nint main(){\n\twhile(1){\n\t\tmemset(need,0,sizeof(need));\n\t\tmemset(s,0,sizeof(s));\n\t\tmemset(d,0,sizeof(d));\n\t\tmemset(used,false,sizeof(used));\n\tpriority_queue<PP,vector<PP>,greater<PP> >pque;\n\tscanf(\"%d\",&r);\n\tif(r==0) break;\n\tscanf(\"%d %d %d %d\",&w[0],&h[0],&x[0],&y[0]);\n\tfor(int r=0;r<501;r++){\n\t\tfor(int g=0;g<501;g++){\n\t\t\t\tsparklingdaydream[r][g][0]=1000000000000;\n\t\t\t\tlevel[r][g][0]=1000000000000;\n\t\t\t}\n\t\t}\n\tfor(int i=1;i<=h[0];i++){\n\t\tfor(int j=1;j<=w[0];j++){\n\t\t\tscanf(\"%lld\",&level[j][i][0]);\n\t\t}\n\t}\n\tsparklingdaydream[x[0]][y[0]][0]=1;\n\tpque.push(make_pair(sparklingdaydream[x[0]][y[0]][0],make_pair(x[0],y[0])));\n\tint dx[3]={0,1,-1};\n\tint dy[3]={0,1,-1};\n\twhile(!pque.empty()){\n\t\tPP p=pque.top();\n\t\tpque.pop();\n\t\tused[p.second.first][p.second.second][0]=true;\n\t\tfor(int k=0;k<3;k++){\n\t\t\tfor(int l=0;l<3;l++){\n\t\t\t\tif(k!=l && (k==0 || l==0)){\n\t\t\t\t\tif(!used[p.second.first+dx[k]][p.second.second+dy[l]][0]){\n\t\t\t\t\t\tif(p.second.first+dx[k]>=1 && p.second.first+dx[k]<=w[0] && p.second.second+dy[l]>=1 && p.second.second+dy[l]<=h[0]){\n\t\t\t\t\t\t\tlong long h=p.first;\n\t\t\t\t\t\t\tsparklingdaydream[p.second.first+dx[k]][p.second.second+dy[l]][0]=max(h,level[p.second.first+dx[k]][p.second.second+dy[l]][0]);\n\t\t\t\t\t\t\tpque.push(make_pair(sparklingdaydream[p.second.first+dx[k]][p.second.second+dy[l]][0],make_pair(p.second.first+dx[k],p.second.second+dy[l])));\n\t\t\t\t\t\t\tused[p.second.first+dx[k]][p.second.second+dy[l]][0]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tfor(int r=0;r<501;r++){\n\t\tfor(int g=0;g<501;g++){\n\t\t\t\tsparklingdaydream[r][g][1]=1000000000000;\n\t\t\t\tlevel[r][g][1]=1000000000000;\n\t\t\t}\n\t\t}\n\tscanf(\"%d %d %d %d\",&w[1],&h[1],&x[1],&y[1]);\n\tfor(int i=1;i<=h[1];i++){\n\t\tfor(int j=1;j<=w[1];j++){\n\t\t\tscanf(\"%lld\",&level[j][i][1]);\n\t\t}\n\t}\n\tsparklingdaydream[x[1]][y[1]][1]=1;\n\tpque.push(make_pair(sparklingdaydream[x[1]][y[1]][1],make_pair(x[1],y[1])));\n\twhile(!pque.empty()){\n\t\tPP p=pque.top();\n\t\tpque.pop();\n\t\tused[p.second.first][p.second.second][1]=true;\n\t\tfor(int k=0;k<3;k++){\n\t\t\tfor(int l=0;l<3;l++){\n\t\t\t\tif(k!=l && (k==0 || l==0)){\n\t\t\t\t\tif(!used[p.second.first+dx[k]][p.second.second+dy[l]][1]){\n\t\t\t\t\t\tif(p.second.first+dx[k]>=1 && p.second.first+dx[k]<=w[1] && p.second.second+dy[l]>=1 && p.second.second+dy[l]<=h[1]){\n\t\t\t\t\t\t\tlong long h=p.first;\n\t\t\t\t\t\t\tsparklingdaydream[p.second.first+dx[k]][p.second.second+dy[l]][1]=max(h,level[p.second.first+dx[k]][p.second.second+dy[l]][1]);\n\t\t\t\t\t\t\tpque.push(make_pair(sparklingdaydream[p.second.first+dx[k]][p.second.second+dy[l]][1],make_pair(p.second.first+dx[k],p.second.second+dy[l])));\n\t\t\t\t\t\t\tused[p.second.first+dx[k]][p.second.second+dy[l]][1]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tint g=0;\n\tfor(int i=1;i<=w[0];i++){\n\t\tfor(int j=1;j<=h[0];j++){\n\t\t\ts[g]=sparklingdaydream[i][j][0];\n\t\t\tg++;\n\t\t}\n\t}\n\tsort(s,s+g);\n\tint eee=1;\n\tfor(int i=0;i<g;i++){\n\t\tif(s[i]!=s[i+1]){\n\t\t\tfor(int j=eee;j<=i+1;j++){\n\t\t\t\tneed[j][0]=s[i];\n\t\t\t\teee=i+2;\n\t\t\t}\n\t\t}\n\t}\n\tg=0;\n\tfor(int i=1;i<=w[1];i++){\n\t\tfor(int j=1;j<=h[1];j++){\n\t\t\td[g]=sparklingdaydream[i][j][1];\n\t\t\tg++;\n\t\t}\n\t}\n\tsort(d,d+g);\n\teee=1;\n\tfor(int i=0;i<g;i++){\n\t\tif(d[i]!=d[i+1]){\n\t\t\tfor(int j=eee;j<=i+1;j++){\n\t\t\t\tneed[j][1]=d[i];\n\t\t\t\teee=i+2;\n\t\t\t}\n\t\t}\n\t}\n\tlong long ans=10000000000;\n\tfor(int i=1;i<250005;i++){\n\t\tfor(int j=0;j<2;j++){\n\t\t\tif(!need[i][j]){\n\t\t\tneed[i][j]=10000000000000;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=r;i++){\n\t\tans=min(ans,need[i][0]+need[r-i][1]);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <string.h>\n\nusing namespace std;\n\nstruct key_auth\n{\n\tint level, space;\n};\n\nbool flag[500][500];\nvoid serve(int w, int h, int x, int y, vector<vector<int>>&lev, vector<key_auth>&ret)\n{\n\tmemset(flag, false, sizeof(flag));\n\tint stop = 0;\n\tint room = 0;\n\tpriority_queue<pair<int, pair<int, int>>>que;\n\tque.push(make_pair(-1, make_pair(y, x)));\n\twhile (!que.empty())\n\t{\n\t\tauto qq = que.top();\n\t\tif (-qq.first > stop)\n\t\t{\n\t\t\tret.push_back({ stop,room });\n\t\t\tstop = -qq.first;\n\t\t}\n\t\tque.pop();\n\t\tif (flag[qq.second.first][qq.second.second])continue;\n\t\t++room;\n\t\tflag[qq.second.first][qq.second.second] = true;\n\t\tconst int dxy[5] = { 1,0,-1,0,1 };\n\t\tfor (int d = 0; d < 4; ++d)\n\t\t{\n\t\t\tif (qq.second.first + dxy[d] < 0 || qq.second.first + dxy[d] >= h)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (qq.second.second + dxy[d + 1] < 0 || qq.second.second + dxy[d + 1] >= w)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!flag[qq.second.first + dxy[d]][qq.second.second + dxy[d + 1]])\n\t\t\t{\n\t\t\t\tque.push(make_pair(-lev[qq.second.first + dxy[d]][qq.second.second + dxy[d + 1]], make_pair(qq.second.first + dxy[d], qq.second.second + dxy[d + 1])));\n\t\t\t}\n\t\t}\n\t}\n\tret.push_back({ stop,room });\n\treturn;\n}\n\nint main()\n{\n\tfor (;;)\n\t{\n\t\tint r;\n\t\tscanf(\"%d\", &r);\n\t\tif (r == 0)break;\n\t\tint w1, w2;\n\t\tint h1, h2;\n\t\tint x1, x2;\n\t\tint y1, y2;\n\t\tvector<vector<int>>lev1, lev2;\n\t\tvector<key_auth>ret1, ret2;\n\t\tscanf(\"%d %d %d %d\", &w1, &h1, &x1, &y1);\n\t\t--x1; --y1;\n\t\tlev1.resize(h1);\n\t\tfor (int i = 0; i < h1; ++i)lev1[i].resize(w1);\n\t\tfor (int i = 0; i < h1; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < w1; ++j)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &lev1[i][j]);\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d %d %d %d\", &w2, &h2, &x2, &y2);\n\t\tlev2.resize(h2);\n\t\tfor (int i = 0; i < h2; ++i)lev2[i].resize(w2);\n\t\t--x2; --y2;\n\t\tfor (int i = 0; i < h2; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < w2; ++j)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &lev2[i][j]);\n\t\t\t}\n\t\t}\n\t\tserve(w1, h1, x1, y1, lev1, ret1);\n\t\tserve(w2, h2, x2, y2, lev2, ret2);\n\t\tauto itr = ret2.rbegin();\n\t\tint ans = 1234567890;\n\t\tfor (auto& rr : ret1)\n\t\t{\n\t\t\twhile (((itr + 1) != ret2.rend()) && ((itr + 1)->space + rr.space >= r))\n\t\t\t{\n\t\t\t\t++itr;\n\t\t\t}\n\t\t\tif (itr->space + rr.space >= r)ans = min(ans, itr->level + rr.level);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\n#include<map>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1e9)\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nstruct state {\n  int y,x,cost;\n  bool operator < (const state &p)const{\n    return cost > p.cost; \n  }\n};\n\nint R;\nint th,tw,uh,uw,ty,tx,uy,ux;\nint t[500][500],u[500][500];\nint T[1000000],U[1000000];\nint d[500][500];\nvector<int> G;\nmap<int,int> g;\n\nvoid compute(int a[500][500],int H,int W,int sy,int sx,int v[1000000]){\n  for(int i=0;i<500;i++)for(int j=0;j<500;j++)d[i][j]=INF;\n  priority_queue<state> Q;\n  Q.push((state){sy,sx,1});\n  d[sy][sx]=1;\n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    if(d[s.y][s.x]<s.cost)continue;\n    v[g[s.cost]]++;\n    for(int i=0;i<4;i++){\n      int ny=s.y+dy[i],nx=s.x+dx[i];\n      if(ny<0||nx<0)continue;\n      if(ny>=H||nx>=W)continue;\n      int ncost=max(a[ny][nx],s.cost);\n      if(d[ny][nx]<=ncost)continue;\n      d[ny][nx]=ncost;\n      Q.push((state){ny,nx,ncost});\n    }\n  }\n}\n\nvoid solve(){\n  sort(G.begin(),G.end());\n  G.erase(unique(G.begin(),G.end()),G.end());\n  for(int i=0;i<(int)G.size();i++)g[G[i]]=i;\n  compute(t,th,tw,ty,tx,T);\n  compute(u,uh,uw,uy,ux,U);\n  int size=G.size();\n  for(int i=0;i<size;i++){\n    if(i)T[i]+=T[i-1];\n    if(i)U[i]+=U[i-1];\n    //cout<<T[i]<<\" \"<<U[i]<<\" \"<<G[i]<<endl;\n  }\n\n  int ans=INF;\n  for(int i=0;i<size;i++){\n    int target=R-T[i];\n    int* it=lower_bound(U,U+size,target);\n    if(it==U+size){\n      continue;\n    }\n    ans=min(ans,G[i]+G[it-U]);\n  }\n  cout<<ans<<endl;\n}\n\nvoid init(){\n  G.clear();\n  g.clear();\n  G.push_back(0);\n  for(int i=0;i<1000000;i++)\n    T[i]=U[i]=0;\n}\n\nint main(){\n  while(cin>>R,R){    \n    init();\n    cin>>tw>>th>>tx>>ty;\n    ty--,tx--;\n    for(int i=0;i<th;i++){\n      for(int j=0;j<tw;j++){\n\tcin>>t[i][j];\n\tG.push_back(t[i][j]);\n      }\n    }\n    cin>>uw>>uh>>ux>>uy;\n    uy--,ux--;\n    for(int i=0;i<uh;i++){\n      for(int j=0;j<uw;j++){\n\tcin>>u[i][j];\n\tG.push_back(u[i][j]);\n      }\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\n\nconst int INF=1000000000;\nconst long long int INF_=1000000000000000000;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nbool IsIn(int y,int x,int h,int w){\n\treturn 0<=y&&y<h&&0<=x&&x<w;\n}\n\nvoid BFS(vector<vector<int> > &f,vector<vector<int> > &l,int sy,int sx,int h,int w){\n\tvector<vector<int> > done(h,vector<int>(w));\n\tl[sy][sx]=1;\n\tdone[sy][sx]=1;\n\tqueue<Pi> que;\n\tREP(i,0,4){\n\t\tint ny=sy+dy[i],nx=sx+dx[i];\n\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\tque.push(Pi(ny,nx));\n\t}\n\twhile(!que.empty()){\n\t\tPi p=que.front();\n\t\tque.pop();\n\t\tdone[p.F_][p.S_]=1;\n\t\tbool flag=true;\n\t\tint tmp=INF;\n\t\tREP(i,0,4){\n\t\t\tint ny=p.F_+dy[i],nx=p.S_+dx[i];\n\t\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\t\ttmp=min(tmp,l[ny][nx]);\n\t\t\tif(done[ny][nx]==1&&l[ny][nx]>=f[p.F_][p.S_]) flag=false;\n\t\t\tif(done[ny][nx]!=1) que.push(Pi(ny,nx));\n\t\t}\n\t\tif(flag) l[p.F_][p.S_]=f[p.F_][p.S_];\n\t\telse l[p.F_][p.S_]=tmp;\n\t}\n}\n\nvoid solve(){\n\tint R;\n\twhile(cin >> R&&R){\n\t\tint W[2],H[2],X[2],Y[2];\n\t\tvector<vector<int> > field[2];\n\t\tvector<vector<int> > level[2];\n\t\tint _max=0;\n\t\tREP(i,0,2){\n\t\t\tcin >> W[i] >> H[i] >> X[i] >> Y[i];\n\t\t\t--X[i]; --Y[i];\n\t\t\tfield[i].resize(H[i]);\n\t\t\tlevel[i].resize(H[i]);\n\t\t\tREP(j,0,H[i]){\n\t\t\t\tfield[i][j].resize(W[i]);\n\t\t\t\tlevel[i][j].resize(W[i]);\n\t\t\t}\n\t\t\tREP(y,0,H[i]) REP(x,0,W[i]){\n\t\t\t\tcin >> field[i][y][x];\n\t\t\t\tif(_max<field[i][y][x]){\n\t\t\t\t\t_max=field[i][y][x];\n\t\t\t\t}\n\t\t\t}\n\t\t\tBFS(field[i],level[i],Y[i],X[i],H[i],W[i]);\n\t\t\t/*\n\t\t\tcout << endl << endl;\n\t\t\tREP(y,0,H[i]){\n\t\t\t\tREP(x,0,W[i]) cout << level[i][y][x] << ' ';\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\tvector<int> count[2],s[2];\n\t\tREP(i,0,2){\n\t\t\tcount[i].resize(_max+1);\n\t\t\ts[i].resize(_max+1);\n\t\t}\n\t\tREP(i,0,2) REP(y,0,H[i]) REP(x,0,W[i]) ++count[i][level[i][y][x]];\n\t\tREP(i,0,2) REP(j,1,_max+1) s[i][j]=s[i][j-1]+count[i][j];\n\t\tint result=INF;\n\t\tfor(int i=0; i<=_max&&i<=result; ++i){\n\t\t\t//cout << i << ' ' << s[0][i] << ' ' <<  (int)(lower_bound(s[1].begin(),s[1].end(),R-s[0][i])-s[1].begin()) << ' ' << s[1][(int)(lower_bound(s[1].begin(),s[1].end(),R-s[0][i])-s[1].begin())] << endl;\n\t\t\tint idx=(int)(lower_bound(s[1].begin(),s[1].end(),R-s[0][i])-s[1].begin());\n\t\t\tif(!(0<=idx&&idx<=_max)) continue;\n\t\t\tresult=min(result,i+idx);\n\t\t}\n\t\tcout << result << endl;\n\t}\n}\n\nint main(){\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\n\n\nint R;\nint W1, W2, H1, H2;\nint X1, X2, Y1, Y2;\nint map1[550][550], map2[550][550];\n\nint dx[4] = {-1, 1, 0, 0};\nint dy[4] = {0, 0, -1, 1};\n\nstruct Hole {\n\tint level;\n\tint x, y;\n\t\n\tHole(int _l, int _x, int _y) : level(_l), x(_x), y(_y) {}\n};\n\nbool operator < (const Hole& h1, const Hole& h2) { return h1.level < h2.level; }\nbool operator > (const Hole& h1, const Hole& h2) { return h1.level > h2.level; }\nbool operator == (const Hole& h1, const Hole& h2) { return h1.level == h2.level; }\nbool operator <= (const Hole& h1, const Hole& h2) { return h1.level <= h2.level; }\nbool operator >= (const Hole& h1, const Hole& h2) { return h1.level >= h2.level; }\n\nstruct Data {\n\tint need, rooms;\n\tData(int _n, int _r) : need(_n), rooms(_r) {}\n};\n\nbool operator < (const Data& d1, const Data& d2) { return d1.need < d2.need; }\nbool operator > (const Data& d1, const Data& d2) { return d1.need > d2.need; }\nbool operator == (const Data& d1, const Data& d2) { return d1.need == d2.need; }\nbool operator <= (const Data& d1, const Data& d2) { return d1.need <= d2.need; }\nbool operator >= (const Data& d1, const Data& d2) { return d1.need >= d2.need; }\n\nint solver() {\n\tpriority_queue<Hole, vector<Hole>, greater<Hole> > q1, q2;\n\tq1.push(Hole(1, X1-1, Y1-1)); q2.push(Hole(1, X2-1, Y2-1));\n\tmap1[Y1-1][X1-1] = -1; map2[Y2-1][X2-1] = -1;\n\t\n\tvector<Data> v1, v2;\n\t\n\tint lev = 0;\n\tint cnt = 0;\n\tdo {\n\t\tHole h = q1.top(); q1.pop();\n\t\tif (h.level <= lev) {\n\t\t\tcnt++;\n\t\t} else {\n\t\t\tv1.push_back(Data(lev, cnt));\n\t\t\tlev = h.level;\n\t\t\tcnt++;\n\t\t}\n\t\t\n\t\tfor (int d=0; d<4; d++) {\n\t\t\tint x = h.x + dx[d], y = h.y + dy[d];\n\t\t\tif (!(0<=x && x<W1 && 0<=y && y<H1)) continue;\n\t\t\tif (map1[y][x]==-1) continue;\n\t\t\tq1.push(Hole(map1[y][x], x, y));\n\t\t\tmap1[y][x] = -1;\n\t\t}\n\t\t\n\t} while(!q1.empty());\n\tv1.push_back(Data(lev, cnt));\n\t\n\tlev = 0;\n\tcnt = 0;\n\tdo {\n\t\tHole h = q2.top(); q2.pop();\n\t\tif (h.level <= lev) {\n\t\t\tcnt++;\n\t\t} else {\n\t\t\tv2.push_back(Data(lev, cnt));\n\t\t\tlev = h.level;\n\t\t\tcnt++;\n\t\t}\n\t\t\n\t\tfor (int d=0; d<4; d++) {\n\t\t\tint x = h.x + dx[d], y = h.y + dy[d];\n\t\t\tif (!(0<=x && x<W2 && 0<=y && y<H2)) continue;\n\t\t\tif (map2[y][x]==-1) continue;\n\t\t\tq2.push(Hole(map2[y][x], x, y));\n\t\t\tmap2[y][x] = -1;\n\t\t}\n\t\t\n\t} while(!q2.empty());\n\tv2.push_back(Data(lev, cnt));\n\t\n\tint ret = 1e8;\n\tint i = 0, j = (int)v2.size()-1;\n\twhile (i<(int)v1.size() && j >= 0) {\n\t\tData d1 = v1[i], d2 = v2[j];\n\t\tif (d1.rooms + d2.rooms >= R) {\n\t\t\tret = min(ret, d1.need + d2.need);\n\t\t\tj--;\n\t\t} else {\n\t\t\ti++;\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> R; if (R==0) break;\n\t\tcin >> W1 >> H1 >> X1 >> Y1;\n\t\tfor (int i=0; i<H1; i++) {\n\t\t\tfor (int j=0; j<W1; j++) {\n\t\t\t\tcin >> map1[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcin >> W2 >> H2 >> X2 >> Y2;\n\t\tfor (int i=0; i<H2; i++) {\n\t\t\tfor (int j=0; j<W2; j++) {\n\t\t\t\tcin >> map2[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solver() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<functional>\n#define int long long\n#define p pair<int,int>\n#define P pair<int,p>\nusing namespace std;\n\nint x[4] = { -1,0,0,1 }, y[4] = { 0,-1,1,0 };\nint f[500][500];\nbool i[500][500];\nset<p>l,r;\nsigned main() {\n\tint a;\n\twhile (cin >> a, a) {\n\t\tl.insert(p(0, 0)); r.insert(p(0, 0));\n\t\tint b, c, d, e; cin >> c >> b >> e >> d;\n\t\td--; e--;\n\t\tfor (int g = 0; g < b; g++) {\n\t\t\tfor (int h = 0; h < c; h++) {\n\t\t\t\tscanf(\"%lld\", &f[g][h]);\n\t\t\t}\n\t\t}\n\t\tmemset(i, true, sizeof(i));\n\t\tint sum = 0, MAX = 0;\n\t\tpriority_queue<P, vector<P>, greater<P>>Q;\n\t\tQ.push(P(1, p(d, e)));\n\t\twhile (Q.size()) {\n\t\t\tP o = Q.top(); Q.pop();\n\t\t\tMAX = o.first; \n\t\t\tif(i[o.second.first][o.second.second])sum++;\n\t\t\ti[o.second.first][o.second.second] = false;\n\t\t\tqueue<p>q;\n\t\t\tq.push(p(o.second.first, o.second.second));\n\t\t\twhile (q.size()) {\n\t\t\t\tp t = q.front(); q.pop();\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint dx = t.first + x[i], dy = t.second + y[i];\n\t\t\t\t\tif (dx >= 0 && dx < b&&dy >= 0 && dy < c&&::i[dx][dy]) {\n\t\t\t\t\t\tif (f[dx][dy] <= o.first) {\n\t\t\t\t\t\t\tsum++;\n\t\t\t\t\t\t\tq.push(p(dx,dy));\n\t\t\t\t\t\t\t::i[dx][dy] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tQ.push(P(f[dx][dy],p(dx,dy)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tl.insert(p(sum, MAX));\n\t\t}\n\t\tcin >> c >> b >> e >> d;\n\t\td--; e--;\n\t\tfor (int g = 0; g < b; g++) {\n\t\t\tfor (int h = 0; h < c; h++) {\n\t\t\t\tscanf(\"%lld\", &f[g][h]);\n\t\t\t}\n\t\t}\n\t\tmemset(i, true, sizeof(i));\n\t\tsum = 0; MAX = 0;\n\t\tpriority_queue<P, vector<P>, greater<P>>U;\n\t\tU.push(P(1, p(d, e)));\n\t\twhile (U.size()) {\n\t\t\tP o = U.top(); U.pop();\n\t\t\tMAX = o.first;\n\t\t\tif (i[o.second.first][o.second.second])sum++;\n\t\t\ti[o.second.first][o.second.second] = false;\n\t\t\tqueue<p>q;\n\t\t\tq.push(p(o.second.first, o.second.second));\n\t\t\twhile (q.size()) {\n\t\t\t\tp t = q.front(); q.pop();\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint dx = t.first + x[i], dy = t.second + y[i];\n\t\t\t\t\tif (dx >= 0 && dx < b&&dy >= 0 && dy < c&&::i[dx][dy]) {\n\t\t\t\t\t\tif (f[dx][dy] <= o.first) {\n\t\t\t\t\t\t\tsum++;\n\t\t\t\t\t\t\tq.push(p(dx, dy));\n\t\t\t\t\t\t\t::i[dx][dy] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tU.push(P(f[dx][dy], p(dx, dy)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tr.insert(p(sum, MAX));\n\t\t}\n\t\tint MIN = LLONG_MAX/3;\n\t\tfor (auto i = l.begin(); i != l.end(); i++) {\n\t\t\tauto j = r.lower_bound(p(a-(*i).first,0));\n\t\t\tif (j != r.end()) {\n\t\t\t\tMIN = min(MIN, (*i).second + (*j).second);\n\t\t\t}\n\t\t}\n\t\tcout << 0 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstring>\n \n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define MP make_pair\n#define X first\n#define Y second\n#define all(v) v.begin(), v.end()\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> P;\n\nconst int INF = 1<<29;\n\nint w, h;\nint k[501][501];\nbool visit[501][501];\n\nstruct room{\n\tint sec, x, y;\n\troom(int s, int x, int y):sec(s), x(x), y(y){}\n\tbool operator<(const room &r) const {\n\t\treturn sec > r.sec;\n\t}\n};\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nvoid createMap(int x, int y, vi &s, vi &c){\n\tmemset(visit, 0, sizeof(visit));\n\tpriority_queue<room> q;\n\tq.push(room(1, x, y));\n\tvisit[y][x] = 1;\n\tint sec = 0, cnt = 0;\n\twhile(!q.empty()){\n\t\troom r = q.top();\n\t\tq.pop();\n\n\t\tif(r.sec > sec){\n\t\t\ts.push_back(sec);\n\t\t\tc.push_back(cnt);\n\t\t\tsec = r.sec;\n\t\t}\n\t\tcnt++;\n\n\t\trep(i, 4){\n\t\t\tint nx = r.x + dx[i], ny = r.y + dy[i];\n\t\t\tif(nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n\t\t\tif(visit[ny][nx]) continue;\n\t\t\tvisit[ny][nx] = true;\n\t\t\tq.push(room(k[ny][nx], nx, ny));\n\t\t}\n\t}\n\ts.push_back(sec);\n\tc.push_back(cnt);\n}\n\n\nint main(){\n\tint R;\n\twhile(cin >> R, R){\n\t\tvi sec[2];\n\t\tvi cnt[2];\n\t\trep(m, 2){\n\t\t\tint x, y;\n\t\t\tcin >> w >> h >> x >> y;\n\t\t\trep(i, h) rep(j, w) cin >> k[i][j];\n\t\t\tcreateMap(x-1, y-1, sec[m], cnt[m]);\n\t\t}\n\n\t\tint ans = INF;\n\t\tint size = sec[1].size();\n\t\trep(i, sec[0].size()){\n\t\t\tint pos = lower_bound(all(cnt[1]), R-cnt[0][i])-cnt[1].begin();\n\t\t\tif(pos == size) continue;\n\t\t\tans = min(ans, sec[0][i]+sec[1][pos]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<long long int, P> P1;\n\nlong long int m[1001][1001];\n\nbool used[1001][1001];\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint main(){\n\t\n\twhile(true){\n\t\tint R;\n\t\tcin >> R;\n\t\tif(R == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tlong long int a[2] = {};\n\t\t\n\t\tlong long int num[2][100001];\n\t\t\n\t\tfor(int i = 0; i < 2; i++){\n\t\t\tfor(int j = 0; j <= 100000; j++){\n\t\t\t\tnum[i][j] = 1000000000LL;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < 2; i++){\n\t\t\tint W, H, X, Y;\n\t\t\tcin >> W >> H >> X >> Y;\n\t\t\tX--;\n\t\t\tY--;\n\t\t\tfor(int j = 0; j < H; j++){\n\t\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\t\tcin >> m[j][k];\n\t\t\t\t\tused[j][k] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpriority_queue<P1, vector<P1>, greater<P1> > pque;\n\t\t\tP1 p;\n\t\t\tp.first = 1;\n\t\t\tp.second.first = X;\n\t\t\tp.second.second = Y;\n\t\t\tpque.push(p);\n\t\t\tused[Y][X] = true;\n\t\t\t\n\t\t\tfor(int j = 0; j <= R; j++){\n\t\t\t\tnum[i][j] = a[i];\n\t\t\t\tif(pque.empty()){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tP1 p1 = pque.top();\n\t\t\t\tpque.pop();\n\t\t\t\t//cout << p1.first << \" \";\n\t\t\t\t//cout << p1.second.second << \" \" << p1.second.first << endl;\n\t\t\t\ta[i] = max(a[i], p1.first);\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tP1 pp;\n\t\t\t\t\tpp.second.first = p1.second.first + dy[j];\n\t\t\t\t\tpp.second.second = p1.second.second + dx[j];\n\t\t\t\t\tif(pp.second.second >= 0 && pp.second.first >= 0 && pp.second.second < W && pp.second.first < H && !used[pp.second.first][pp.second.second]){\n\t\t\t\t\t\tpp.first = m[pp.second.first][pp.second.second];\n\t\t\t\t\t\tpque.push(pp);\n\t\t\t\t\t\tused[pp.second.first][pp.second.second] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong long int ans = 1000000000LL;\n\t\t\n\t\tfor(int j = 0; j <= R; j++){\n\t\t\tans = min(ans, num[0][j] + num[1][R - j]);\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nint w[2], h[2], l[2][500][500], sx[2], sy[2], r;\nint dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nint ans[2][100001], d[250000];\nbool vis[500][500], used[500][500];\ndeque<P>que[2500];\nint compress(int k) {\n\tvector<int>x;\n\trep(i, h[k])rep(j, w[k])x.push_back(l[k][i][j]);\n\tsort(x.begin(), x.end());\n\tx.erase(unique(x.begin(), x.end()), x.end());\n\trep(i, x.size())d[i] = x[i];\n\trep(i, h[k])rep(j, w[k])\n\t\tl[k][i][j] = lower_bound(x.begin(), x.end(), l[k][i][j]) - x.begin();\n\treturn x.size();\n}\nvoid solve(int k) {\n\tans[k][0] = 0;\n\tqueue<P>Q;\n\tint n = compress(k);\n\trep(i, n)que[i].clear();\n\tmemset(vis, 0, sizeof(vis));\n\tmemset(used, 0, sizeof(used));\n\tQ.push(P(sx[k], sy[k]));\n\tvis[sx[k]][sy[k]] = true;\n\tint cnt = 0, Max = 0;\n\twhile (1) {\n\t\twhile (!Q.empty()) {\n\t\t\tP p = Q.front(); Q.pop();\n\t\t\tif (used[p.first][p.second])continue;\n\t\t\tused[p.first][p.second] = true;\n\t\t\tcnt++; if (cnt >= r)break;\n\t\t\trep(i, 4) {\n\t\t\t\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\tif (0 <= nx&&nx < h[k] && 0 <= ny&&ny < w[k] && !vis[nx][ny]) {\n\t\t\t\t\tvis[nx][ny] = true;\n\t\t\t\t\tif (l[k][nx][ny] <= Max)Q.push(P(nx, ny));\n\t\t\t\t\telse que[l[k][nx][ny]].push_back(P(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans[k][cnt] = min(ans[k][cnt], d[Max]);\n\t\trep(i, n) {\n\t\t\tif (!que[i].empty()) {\n\t\t\t\tMax = i;\n\t\t\t\tfor (P p : que[i])Q.push(p);\n\t\t\t\tque[i].clear();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (cnt >= r || Q.empty())break;\n\t}\n\tfor (int i = r - 1; i >= 1; i--)ans[k][i] = min(ans[k][i], ans[k][i + 1]);\n}\nint main() {\n\twhile (scanf(\"%d\", &r), r) {\n\t\trep(k, 2) {\n\t\t\tscanf(\"%d%d%d%d\", &w[k], &h[k], &sy[k], &sx[k]); sx[k]--; sy[k]--;\n\t\t\trep(i, h[k])rep(j, w[k])scanf(\"%d\", &l[k][i][j]);\n\t\t}\n\t\tfill(ans[0], ans[2], INT_MAX);\n\t\trep(k, 2)solve(k);\n\t\tint Min = INT_MAX;\n\t\tfor (int i = 0; i <= r; i++) {\n\t\t\tif (ans[0][i] == INT_MAX || ans[1][r - i] == INT_MAX)continue;\n\t\t\tMin = min(Min, ans[0][i] + ans[1][r - i]);\n\t\t}\n\t\tprintf(\"%d\\n\", Min);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<string>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define rep(i,x) for(int i = 0 ; i < x ; i ++)\n#define rep1(i,x) for(int i = 1 ; i <= x ; i ++)\n#define rrep(i,x) for(int i = x-1 ; i >= 0 ; i --)\n#define rrep1(i,x) for(int i = x ; i > 0 ; i --)\n#define sor(vec) sort(vec.begin(),vec.end())\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(min(a,b),c)\n#define max_3(a,b,c) max(max(a,b),c)\n#define mp1(a,b,c) P1(a,P(b,c))\n#define fr first\n#define sc second\n#define pb push_back\n\nconst int INF = 1000000000;\nconst int dir_4[4][2] = { {1,0} , {0,1} , {-1,0} , {0,-1} };\n\nint r;\nint w[2],h[2],x[2],y[2];\nint l[2][502][502];\n\nint a[502][502];\n\nint dfs(int X,int Y){\n\tif(a[X][Y] != 0)return 0;\n\ta[X][Y] = 1;\n\tint ret = 1;\n\trep(i,4){\n\t\tret += dfs(X+dir_4[i][0],Y+dir_4[i][1]);\n\t}\n\treturn ret;\n}\n\n/*int f(int t,int m){\n\trep(i,502){\n\t\trep(j,502){\n\t\t\ta[i][j] = 1;\n\t\t}\n\t}\n\trep1(i,h[t]){\n\t\trep1(j,w[t]){\n\t\t\tif(l[t][i][j] <= m)a[i][j] = 0;\n\t\t}\n\t}\n\treturn dfs(y[t],x[t]);\n}*/\n\nint C;\nbool comp(P1 a,P1 b){\n\tif(a.fr != b.fr)return a <= b;\n\tif(a.sc.fr == y[C] && a.sc.sc == x[C])return true;\n\tif(b.sc.fr == y[C] && b.sc.sc == x[C])return false;\n\treturn a <= b;\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d\",&r); if(r == 0)break;\n\t\trep(i,2){\n\t\t\tscanf(\"%d%d%d%d\",&w[i],&h[i],&x[i],&y[i]);\n\t\t\trep1(j,h[i]){\n\t\t\t\trep1(k,w[i]){\n\t\t\t\t\tscanf(\"%d\",&l[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tstatic int cost[2][250010];\n\t\tvector<P1> vec[2];\n\t\t\n\t\tvec[0].clear();\n\t\tvec[1].clear();\n\t\t\n\t\trep(k,2){\n\t\t\tvec[k].pb( mp1 ( 0 , -1 , -1 ) );\n\t\t\trep1(i,h[k]){\n\t\t\t\trep1(j,w[k]){\n\t\t\t\t\tvec[k].pb( mp1 ( l[k][i][j] , i , j ) );\n\t\t\t\t}\n\t\t\t}\n\t\t\tC = k;\n\t\t\tsort(vec[k].begin(),vec[k].end(),comp);\n\t\t\t\n\t\t\trep(i,502){\n\t\t\t\trep(j,502){\n\t\t\t\t\ta[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tcost[k][0] = 0;\n\t\t\ta[y[k]][x[k]] = 1;\n\t\t\tcost[k][1] = 1;\n\t\t\t\n\t\t\tfor(int i = 2; i < vec[k].size() ; i ++){\n\t\t\t\tP p = vec[k][i].sc;\n\t\t\t\ta[p.fr][p.sc] = 0;\n\t\t\t\tcost[k][i] = cost[k][i-1];\n\t\t\t\tbool t = false;\n\t\t\t\trep(j,4){\n\t\t\t\t\tt |= (a[p.fr+dir_4[j][0]][p.sc+dir_4[j][1]] == 1);\n\t\t\t\t}\n\t\t\t\tif(t)cost[k][i] += dfs(p.fr,p.sc);\n\t\t\t}\n\t\t\t\n\t\t\t/*rep(i,vec[k].size()){\n\t\t\t\tprintf(\"%d %d\\n\",vec[k][i].fr,cost[k][i]);\n\t\t\t}*/\n\t\t}\n\t\t\n\t\tint ret = INF;\n\t\tint k = vec[1].size()-1;\n\t\trep(i,vec[0].size()){\n\t\t\twhile(k > 0 && cost[0][i] + cost[1][k-1] >= r)k --;\n\t\t\tif(cost[0][i] + cost[1][k] >= r){\n\t\t\t\tret = min ( ret , vec[0][i].fr + vec[1][k].fr );\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ret);\n\t\t\n\t\t/*int L = 0,R = 100000000;\n\t\twhile(L < R){\n\t\t\tint M = (L+R)/2;\n\t\t\tif(f(0,M)+f(1,M) < r)L = M+1;\n\t\t\telse R = M;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",L);*/\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,-1,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pint pair<int,int>\n#define tint tuple<int,int,int>\n#define INF 1<<29\n#define MAX 501\nusing namespace std;\n\nint R,W[2],H[2],X[2],Y[2],L[2][MAX][MAX],d[2][MAX][MAX],dd[4]={0,-1,0,1};\nmap<int,int> m[2];\nmap<int,int>::iterator ite;\n\nvoid solve(){\n for(;;){\n  cin>>R;\n  if(!R) return;\n  FOR(i,2){\n   cin>>W[i]>>H[i]>>X[i]>>Y[i];\n   X[i]--;\n   Y[i]--;\n   FOR(j,H[i]) FOR(k,W[i]) cin>>L[i][j][k];\n   FOR(j,H[i]) FOR(k,W[i]) d[i][j][k]=INT_MAX/3;\n   d[i][X[i]][Y[i]]=1;\n   priority_queue<pint,vector<pint>,greater<pint>> pque;\n   pque.push(mp(1,X[i]*W[i]+Y[i]));\n   while(!pque.empty()){\n    pint p=pque.top(); pque.pop();\n    int x=p.second/W[i],y=p.second-x*W[i];\n    if(d[i][x][y]<p.first) continue;\n    FOR(j,4){\n     int nx=x+dd[j],ny=y+dd[j^1];\n     if(nx<0||ny<0||nx>=H[i]||ny>=W[i]) continue;\n     if(d[i][nx][ny]>max(d[i][x][y],L[i][x][y])){\n      d[i][nx][ny]=max(d[i][x][y],L[i][x][y]);\n      pque.push(mp(d[i][nx][ny],nx*W[i]+ny));\n     }\n    }\n   }\n   FOR(j,H[i]) FOR(k,W[i]) m[i][d[i][j][k]]++;\n   for(ite=m[i].begin();ite!=m[i].end();ite++){\n    if(ite==m[i].begin()) continue;\n    m[i][ite->first]+=m[i][(--ite)->first];\n    ite++;\n   }\n  }\n  int mi=m[1].lower_bound(R)->first;\n  for(ite=m[0].begin();ite!=m[0].end();ite++){\n   mi=min(mi,(ite->first)+(m[1].lower_bound(R-(ite->second))->first));\n  }\n  cout<<mi<<endl;\n  FOR(i,2) m[i].clear();\n }\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <string>\n#include <map>\n#include <utility>\n#include <set>\n#include <queue>\n#include <unordered_set>\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\n\n//using LL = long long;\n//using P = pair < int, int > ;\n//using PI = pair < P, int > ;\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\nvector<P> visitable(vector<vector<int>>& stage, P start)\n{\n\tint h = stage.size(), w = stage[0].size();\n\tvector<vector<int>> ns(h, vector<int>(w, INF));\n\tset<P> visited;\n\tqueue<P> que;\n\tque.push(start);\n\tvisited.insert(start);\n\tns[start.first][start.second] = 1;\n\twhile (!que.empty())\n\t{\n\t\tP p = que.front(); que.pop();\n\t\trep(i, 4)\n\t\t{\n\t\t\tint nr = dr[i] + p.first, nc = dc[i] + p.second;\n\t\t\tif (nr < 0 || nr >= h || nc < 0 || nc >= w) continue;\n\n\t\t\tns[nr][nc] = max(stage[nr][nc], min(ns[nr][nc], ns[p.first][p.second]));\n\n\t\t\tP np = P(nr, nc);\n\t\t\tif (visited.count(np)) continue;\n\t\t\tvisited.insert(np);\n\t\t\tque.push(np);\n\t\t}\n\t}\n\n\tmap<int, int> mp;\n\trep(i, h) rep(j, w) mp[ns[i][j]]++;\n\tvector<P> ret;\n\tfor (P p : mp) ret.push_back(p);\n\tfor (int i = 0; i + 1 < ret.size(); i++) ret[i + 1].second += ret[i].second;\n\treturn move(ret);\n}\n\n//x個を満たす最小の機密レベル\nint lower(vector<int>& sums, vector<int>& data, int x)\n{\n\tif (sums[sums.size() - 1] < x) return -1;\n\tif (x == 0) return 0;\n\n\tint idx = lower_bound(all(sums), x) - sums.begin();\n\treturn data[idx];\n}\n\nsigned main()\n{\n\tint R;\n\twhile (cin >> R)\n\t{\n\t\tint w1, h1, c1, r1; cin >> w1 >> h1 >> c1 >> r1;\n\t\tr1--; c1--;\n\t\tvector<vector<int>> stage1(h1, vector<int>(w1));\n\t\trep(i, h1) rep(j, w1) cin >> stage1[i][j];\n\n\t\tvector<P> ps1 = visitable(stage1, P(r1, c1));\n\t\tvector<int> sums1, data1;\n\t\tfor (P p : ps1)\n\t\t{\n\t\t\tsums1.push_back(p.second);\n\t\t\tdata1.push_back(p.first);\n\t\t}\n\n\t\tint w2, h2, c2, r2; cin >> w2 >> h2 >> c2 >> r2;\n\t\tr2--; c2--;\n\t\tvector<vector<int>> stage2(h2, vector<int>(w2));\n\t\trep(i, h2) rep(j, w2) cin >> stage2[i][j];\n\n\t\tvector<P> ps2 = visitable(stage2, P(r2, c2));\n\t\tvector<int> sums2, data2;\n\t\tfor (P p : ps2)\n\t\t{\n\t\t\tsums2.push_back(p.second);\n\t\t\tdata2.push_back(p.first);\n\t\t}\n\n\t\tint ans = INF;\n\t\trep(x, R + 1)\n\t\t{\n\t\t\tint y = R - x;\n\t\t\tint l1 = lower(sums1, data1, x);\n\t\t\tint l2 = lower(sums2, data2, y);\n\t\t\tif (l1 != -1 && l2 != -1)\n\t\t\t{\n\t\t\t\tans = min(ans, l1 + l2);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> iP;\n#define pb push_back\n#define fi first\n#define sc second\n#define MAX_H 514\nint R;\nint W[2],H[2],X[2],Y[2];\nint L[2][MAX_H][MAX_H];\nbool F[2][MAX_H][MAX_H];\nvector<iP>data[2];\nint need[2][MAX_H*MAX_H];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nint main()\n{\n\tscanf(\"%d\",&R);\n\tfor(int i=0;i<2;i++){\n\t\tscanf(\"%d%d%d%d\",&W[i],&H[i],&X[i],&Y[i]);X[i]--;Y[i]--;\n\t\tfor(int j=0;j<H[i];j++){\n\t\t\tfor(int k=0;k<W[i];k++){\n\t\t\t\tscanf(\"%d\",&L[i][j][k]);\n\t\t\t\tif(j==Y[i]&&k==X[i]){continue;}\n\t\t\t\tdata[i].pb(iP(L[i][j][k],P(j,k)));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tsort(data[i].begin(),data[i].end());\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tF[i][Y[i]][X[i]]=true;\n\t\tneed[i][0]=0;\n\t\tint cou=1;need[i][1]=1;\n\t\tfor(int j=0;j<(int)data[i].size();j++){\n\t\t\tint x=data[i][j].sc.fi;\n\t\t\tint y=data[i][j].sc.sc;\n\t\t\tbool flag=false;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tif(x+dx[k]<0||x+dx[k]>=H[i]||y+dy[k]<0||y+dy[k]>=W[i]){continue;}\n\t\t\t\tif(F[i][x+dx[k]][y+dy[k]])flag=true;\n\t\t\t}\n\t\t\tif(!flag){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tqueue<P>que;\n\t\t\tque.push(P(x,y));\n\t\t\twhile(!que.empty()){\n\t\t\t\tP p=que.front();que.pop();\n\t\t\t\tif(F[i][p.fi][p.sc])continue;\n\t\t\t\tF[i][p.fi][p.sc]=true;\n\t\t\t\t//printf(\"%d %d\\n\",p.fi,p.sc);\n\t\t\t\tcou++;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(p.fi+dx[k]<0||p.fi+dx[k]>=H[i]||p.sc+dy[k]<0||p.sc+dy[k]>=W[i]){continue;}\n\t\t\t\t\tif(F[i][p.fi+dx[k]][p.sc+dy[k]]){continue;}\n\t\t\t\t\tif(L[i][p.fi+dx[k]][p.sc+dy[k]]<=data[i][j].fi){\n\t\t\t\t\t\tque.push(P(p.fi+dx[k],p.sc+dy[k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tneed[i][cou]=L[i][x][y];\n\t\t\t//printf(\"%d:%d %d\\n\",cou,x,y);\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<2;i++){\n\t\tfor(int j=0;j<=W[i]*H[i];j++){\n\t\t\tprintf(\"need[%d][%d]=%d\\n\",i,j,need[i][j]);\n\t\t}\n\t}\n\t*/\n\tint ans=1<<30;\n\tfor(int i=0;i<=W[0]*H[0];i++){\n\t\tint k=R-i;\n\t\tif(k>W[1]*H[1]||k<0){\n\t\t\tcontinue;\n\t\t}\n\t\tans=min(need[0][i]+need[1][k],ans);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef tuple<int,int,int> tri;\n\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint r,w,h,x,y;\nint g[555][555];\nbool vis[555][555];\n\nint main(){\n  while(scanf(\"%d\",&r), r){\n    vector<pii> num[2];\n\n    for(int id=0;id<2;id++){\n      scanf(\"%d%d%d%d\",&w,&h,&x,&y);\n      x--; y--;\n      for(int i=0;i<h;i++){\n\tfor(int j=0;j<w;j++)scanf(\"%d\",&g[i][j]);\n      }\n\n      memset(vis,0,sizeof(vis));\n      vis[y][x] = true;\n      priority_queue<tri> q;\n      q.push(tri(-g[y][x],y,x));\n\n      int cnt = 0, val = 0;\n      while(q.size()){\n\tnum[id].push_back(pii(cnt,val));\n\t\n\tdo{\n\t  cnt++;\n\t  y = get<1>(q.top()); x = get<2>(q.top());\n\t  val = min(val, get<0>(q.top()) );\n\t  q.pop();\n\t  \n\t  for(int i=0;i<4;i++){\n\t    int ny = y+dy[i], nx = x+dx[i];\n\t    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n\t    if(vis[ny][nx])continue;\n\t    vis[ny][nx] = true;\n\t    q.push(tri(-g[ny][nx],ny,nx));\n\t  }\n\t}while(q.size() && get<0>(q.top()) >= val);\n      }\n      num[id].push_back(pii(cnt,val));\n    }\n    \n    int ans = 1e9, rev_ite = num[1].size() - 1;\n    for(int i=0;i<(int)num[0].size();i++){\n      while(rev_ite>=0 && num[0][i].first + num[1][rev_ite].first >= r)rev_ite--;\n      rev_ite++;\n      if(num[0][i].first + num[1][rev_ite].first >= r){\n\tans = min(ans, - num[0][i].second - num[1][rev_ite].second);\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long R, W, H, X, Y, i, j, L[510][510], O, T, a, b;\nlong long m[5] = {1, 0, -1, 0, 1};\nbool u[510][510], v[510][510];\nvector<long long> d1, d2;\ntuple<long long, long long, long long> t;\npriority_queue<tuple<long long, long long, long long>, vector<tuple<long long, long long, long long> >, greater<tuple<long long, long long, long long> > > q;\n\nint main(){\n  for(;scanf(\"%lld\", &R), R != 0;){\n  d1.clear();\n  d2.clear();\n  scanf(\"%lld%lld%lld%lld\", &W, &H, &X, &Y);\n  for(i = 0; i < H; ++i){\n    for(j = 0; j < W; ++j){\n      scanf(\"%lld\", L[j] + i);\n    }\n  }\n  for(i = 0; i < 510; ++i){\n    for(j = 0; j < 510; ++j){\n      u[j][i] = false;\n      v[j][i] = false;\n    }\n  }\n  d1.push_back(0);\n  d2.push_back(0);\n  q.push(make_tuple(1, X - 1, Y - 1));\n  u[X - 1][Y - 1] = true;\n  while(!q.empty()){\n    t = q.top();\n    q.pop();\n    tie(O, a, b) = t;\n    d1.push_back(O);\n    //cout << O << endl;\n    for(i = 0; i < 4; ++i){\n      if(0 <= a + m[i] && a + m[i] < W && 0 <= b + m[i + 1] && b + m[i + 1] < H && !u[a + m[i]][b + m[i + 1]]){\n        //cout << L[a + m[i]][b + m[i + 1]] << \" \" << a + m[i] << \" \" << b + m[i + 1] << endl;\n\tu[a + m[i]][b + m[i + 1]] = true;\n\tq.push(make_tuple(max(O, L[a + m[i]][b + m[i + 1]]), a + m[i], b + m[i + 1]));\n      }\n    }\n  }\n  O = W * H + 1;\n  scanf(\"%lld%lld%lld%lld\", &W, &H, &X, &Y);\n  for(i = 0; i < H; ++i){\n    for(j = 0; j < W; ++j){\n      scanf(\"%lld\", L[j] + i);\n    }\n  }\n  q.push(make_tuple(1, X - 1, Y - 1));\n  v[X - 1][Y - 1] = true;\n  while(!q.empty()){\n    t = q.top();\n    q.pop();\n    tie(T, a, b) = t;\n    d2.push_back(T);\n    for(i = 0; i < 4; ++i){\n      if(0 <= a + m[i] && a + m[i] < W && 0 <= b + m[i + 1] && b + m[i + 1] < H && !v[a + m[i]][b + m[i + 1]]){\n\t//cout << a + m[i] << \" \" << b + m[i + 1] << endl;\n\tv[a + m[i]][b + m[i + 1]] = true;\n\tq.push(make_tuple(max(T, L[a + m[i]][b + m[i + 1]]), a + m[i], b + m[i + 1]));\n      }\n    }\n  }\n  T = W * H + 1;\n  a = 1099511627775LL;\n  /*for(i = 0, j = O; i < j; ++i){\n    cout << d1[i] << \" \";\n  }\n  cout << endl;\n  for(i = 0, j = T; i < j; ++i){\n    cout << d2[i] << \" \";\n  }\n  cout << endl;// */\n  for(i = 0LL, j = R + 1; i < j; ++i){\n    //cout << i << \" \" << R - i << endl;\n    if(R - i <= T && i <= O)a = min(a, d1[i] + d2[R - i]);\n  }\n  cout << a << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint l[2][500][500];\nbool c[2][500][500];\nint memo[2][100001];\n\nstruct level{\n  int l;\n  int x;\n  int y;\n  level(int a,int b,int c){\n    l=a; x=b; y=c;\n  }\n};\n\nbool operator < (const level &a, const level &b){\n  return a.l > b.l;\n}\n\nint main(){\n  int r;\n  while(r = getInt()){\n    int w[2],h[2],x[2],y[2];\n    REP(k,2){\n      w[k] = getInt();\n      h[k] = getInt();\n      x[k] = getInt() - 1;\n      y[k] = getInt() - 1;\n      REP(i,h[k]) REP(j,w[k]){\n        l[k][i][j] = getInt();\n        c[k][i][j] = false;\n      }\n\n      priority_queue<level> pq;\n      pq.push(level(1,x[k],y[k]));\n      c[k][x[k]][y[k]] = true;\n\n      int cnt = 0;\n      int now = 1;\n\n      memo[k][cnt++] = 0;\n      while(!pq.empty()){\n        level lv = pq.top();\n        int ll = lv.l;\n        int xx = lv.x;\n        int yy = lv.y;\n        pq.pop();\n        //printf(\"%d %d %d\\n\",ll,xx,yy);\n\n        memo[k][cnt++] = (now = max(ll, now));\n\n        REP(i,4){\n          int xxx = xx + _dx[i];\n          int yyy = yy + _dy[i];\n\n          if(ISIN(xxx,yyy,w[k],h[k]) && !c[k][yyy][xxx]){\n            c[k][yyy][xxx] = true;\n            pq.push(level(l[k][yyy][xxx], yyy, xxx));\n          }\n        }\n      }\n\n      //REP(i, w[k]*h[k]+1) printf(\"%d \",memo[k][i]); puts(\"\");\n    }\n\n    continue;\n\n    int end = min(r, w[0] * h[0]) + 1;\n    int start = max(0, r - w[1] * h[1]);\n    int ans = INT_MAX;\n    rep(i,start,end)\n      ans = min(ans, memo[0][i] + memo[1][r-i]);\n    print(ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <string>\n#include <map>\n#include <utility>\n#include <set>\n#include <queue>\n#include <unordered_set>\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\n\n//using LL = long long;\n//using P = pair < int, int > ;\n//using PI = pair < P, int > ;\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\nvector<P> visitable(vector<vector<int>>& stage, P start)\n{\n\tint h = stage.size(), w = stage[0].size();\n\tvector<vector<int>> ns(h, vector<int>(w, INF));\n\tset<P> visited;\n\tqueue<P> que;\n\tque.push(start);\n\tvisited.insert(start);\n\tns[start.first][start.second] = 1;\n\twhile (!que.empty())\n\t{\n\t\tP p = que.front(); que.pop();\n\t\trep(i, 4)\n\t\t{\n\t\t\tint nr = dr[i] + p.first, nc = dc[i] + p.second;\n\t\t\tif (nr < 0 || nr >= h || nc < 0 || nc >= w) continue;\n\n\t\t\tns[nr][nc] = max(stage[nr][nc], min(ns[nr][nc], ns[p.first][p.second]));\n\n\t\t\tP np = P(nr, nc);\n\t\t\tif (visited.count(np)) continue;\n\t\t\tvisited.insert(np);\n\t\t\tque.push(np);\n\t\t}\n\t}\n\n\tmap<int, int> mp;\n\trep(i, h) rep(j, w) mp[ns[i][j]]++;\n\tvector<P> ret;\n\tfor (P p : mp) ret.push_back(p);\n\tfor (int i = 0; i + 1 < ret.size(); i++) ret[i + 1].second += ret[i].second;\n\treturn move(ret);\n}\n\n//x個を満たす最小の機密レベル\nint lower(vector<int>& sums, vector<int>& data, int x)\n{\n\tif (sums[sums.size() - 1] < x) return -1;\n\tif (x == 0) return 0;\n\n\tint idx = lower_bound(all(sums), x) - sums.begin();\n\treturn data[idx];\n}\n\nsigned main()\n{\n\tint R;\n\twhile (cin >> R)\n\t{\n\t\tint w1, h1, c1, r1; cin >> w1 >> h1 >> c1 >> r1;\n\t\tr1--; c1--;\n\t\tvector<vector<int>> stage1(h1, vector<int>(w1));\n\t\trep(i, h1) rep(j, w1) cin >> stage1[i][j];\n\n\t\tvector<P> ps1 = visitable(stage1, P(r1, c1));\n\t\tvector<int> sums1, data1;\n\t\tfor (P p : ps1)\n\t\t{\n\t\t\tsums1.push_back(p.second);\n\t\t\tdata1.push_back(p.first);\n\t\t}\n\n\t\tint w2, h2, c2, r2; cin >> w2 >> h2 >> c2 >> r2;\n\t\tr2--; c2--;\n\t\tvector<vector<int>> stage2(h2, vector<int>(w2));\n\t\trep(i, h2) rep(j, w2) cin >> stage2[i][j];\n\n\t\tvector<P> ps2 = visitable(stage2, P(r2, c2));\n\t\tvector<int> sums2, data2;\n\t\tfor (P p : ps2)\n\t\t{\n\t\t\tsums2.push_back(p.second);\n\t\t\tdata2.push_back(p.first);\n\t\t}\n\n\t\tint ans = INF;\n\t\trep(x, R + 1)\n\t\t{\n\t\t\tint y = R - x;\n\t\t\tint l1 = lower(sums1, data1, x);\n\t\t\tint l2 = lower(sums2, data2, y);\n\t\t\tif (l1 != -1 && l2 != -1)\n\t\t\t{\n\t\t\t\tans = min(ans, l1 + l2);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//認証レベルの小さい順に鍵を設定すると、入れる部屋が単調にふえるので、その部屋に入るための最少認証レベルが簡単に求まる。\n//と思ったら、そうでもなかった…とりあえず、ダイクストラの負の辺OK盤を使う。\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n//#define DEBUG DEBUG\n#define F first\n#define S second\nusing namespace std;\n#define MAX(x,y) (x>y?x:y)\t// ()がいります\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint R;\nint W1,H1,X1,Y1,W2,H2,X2,Y2;\nint JOI1[500][500],JOI2[500][500];\t//JOI[y][x]として入れます。\nint ADD1[501][501],ADD2[501][501];\t//入るための認証レベルの最小値(1以上)\n\nvoid Make_list1(){\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\tPP node;\n\tque.push(PP(1,P(Y1,X1)));\n\twhile(!que.empty()){\n\t\tnode = que.top();\n\t\tque.pop();\n\t\t//周り4辺を更新\n\t\tif(ADD1[node.S.F+1][node.S.S] > MAX(node.F,JOI1[node.S.F+1][node.S.S])){\n\t\t\tADD1[node.S.F+1][node.S.S] = MAX(node.F,JOI1[node.S.F+1][node.S.S]);\n\t\t\tque.push(PP(ADD1[node.S.F+1][node.S.S],P(node.S.F+1,node.S.S)));\t\n\t\t}\n\t\tif(ADD1[node.S.F][node.S.S+1] > MAX(node.F,JOI1[node.S.F][node.S.S+1])){\n\t\t\tADD1[node.S.F][node.S.S+1] = MAX(node.F,JOI1[node.S.F][node.S.S+1]);\n\t\t\tque.push(PP(ADD1[node.S.F][node.S.S+1],P(node.S.F,node.S.S+1)));\t\n\t\t}\n\t\tif(node.S.F > 0 && ADD1[node.S.F-1][node.S.S] > MAX(node.F,JOI1[node.S.F-1][node.S.S])){\n\t\t\tADD1[node.S.F-1][node.S.S] = MAX(node.F,JOI1[node.S.F-1][node.S.S]);\n\t\t\tque.push(PP(ADD1[node.S.F-1][node.S.S],P(node.S.F-1,node.S.S)));\t\n\t\t}\n\t\tif(node.S.S > 0 && ADD1[node.S.F][node.S.S-1] > MAX(node.F,JOI1[node.S.F][node.S.S-1])){\n\t\t\tADD1[node.S.F][node.S.S-1] = MAX(node.F,JOI1[node.S.F][node.S.S-1]);\n\t\t\tque.push(PP(ADD1[node.S.F][node.S.S-1],P(node.S.F,node.S.S-1)));\t\n\t\t}\n\t}\n}\nvoid Make_list2(){\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\tPP node;\n\tque.push(PP(1,P(Y2,X2)));\n\twhile(!que.empty()){\n\t\tnode = que.top();\n\t\tque.pop();\n\t\t//周り4辺を更新\n\t\tif(ADD2[node.S.F+1][node.S.S] > MAX(node.F,JOI2[node.S.F+1][node.S.S])){\n\t\t\tADD2[node.S.F+1][node.S.S] = MAX(node.F,JOI2[node.S.F+1][node.S.S]);\n\t\t\tque.push(PP(ADD2[node.S.F+1][node.S.S],P(node.S.F+1,node.S.S)));\t\n\t\t}\n\t\tif(ADD2[node.S.F][node.S.S+1] > MAX(node.F,JOI2[node.S.F][node.S.S+1])){\n\t\t\tADD2[node.S.F][node.S.S+1] = MAX(node.F,JOI2[node.S.F][node.S.S+1]);\n\t\t\tque.push(PP(ADD2[node.S.F][node.S.S+1],P(node.S.F,node.S.S+1)));\t\n\t\t}\n\t\tif(node.S.F > 0 && ADD2[node.S.F-1][node.S.S] > MAX(node.F,JOI2[node.S.F-1][node.S.S])){\n\t\t\tADD2[node.S.F-1][node.S.S] = MAX(node.F,JOI2[node.S.F-1][node.S.S]);\n\t\t\tque.push(PP(ADD2[node.S.F-1][node.S.S],P(node.S.F-1,node.S.S)));\t\n\t\t}\n\t\tif(node.S.S > 0 && ADD2[node.S.F][node.S.S-1] > MAX(node.F,JOI2[node.S.F][node.S.S-1])){\n\t\t\tADD2[node.S.F][node.S.S-1] = MAX(node.F,JOI2[node.S.F][node.S.S-1]);\n\t\t\tque.push(PP(ADD2[node.S.F][node.S.S-1],P(node.S.F,node.S.S-1)));\t\n\t\t}\n\t}\n}\nint main(){\n\tint i,j;\n\tint minest[200],mcor = 0;\n\tfor(i = 0;i < 200;i++){minest[i] = 1000000000;}\n\twhile(1){\n\t\tcin >> R;\n\t\tif(R == 0)\n\t\t\tbreak;\n\t\tcin >> W1 >> H1 >> X1 >> Y1;\n\t\tX1--;Y1--;\n\t\tfor(i = 0;i < H1;i++){\n\t\t\tfor(j = 0;j < W1;j++){\n\t\t\t\tcin >> JOI1[i][j];\n\t\t\t\tADD1[i][j] = 1000000001;\n\t\t\t}\n\t\t}\n\t\tADD1[Y1][X1] = 1;\n\t\tcin >> W2 >> H2 >> X2 >> Y2;\n\t\tX2--;Y2--;\n\t\tfor(i = 0;i < H2;i++){\n\t\t\tfor(j = 0;j < W2;j++){\n\t\t\t\tcin >> JOI2[i][j];\n\t\t\t\tADD2[i][j] = 1000000001;\n\t\t\t}\n\t\t}\n\t\tADD2[Y2][X2] = 1;\n\t\t//幅優先探索で部屋に入るための認証レベルの最小値,R部屋入るための認証レベルの最小値を記録する。\n\t\t//認証レベルの設定はWH回したほうがよい。まちがっても、部屋数に対する認証レベルを探すO(R^2logWH)解法は行わない！\n\t\t//queueを使うとO(WH)で行ける。WH*最大4方向*最大4回更新\n\t\tMake_list1();\n\t\tMake_list2();\n\t\t//認証レベルに対して入れる部屋数を考えてみよう(ヒント→認証レベルがiのとき認証レベルがi-1のとき行けた部屋はすべていける)\n\t\tstatic map<int,int> nin1,nin2;\t//認証レベル,部屋数\n\t\tnin1.insert(make_pair(0,0));\n\t\tfor(i = 0;i < H1;i++){\n\t\t\tfor(j = 0;j < W1;j++){\n\t\t\t\tif(nin1.find(ADD1[i][j]) == nin1.end()){\n\t\t\t\t\tnin1.insert(make_pair(ADD1[i][j],1));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tnin1[ADD1[i][j]]++;\t\t//2番目のキーをプラスしましょう。\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnin2.insert(make_pair(0,0));\n\t\tfor(i = 0;i < H2;i++){\n\t\t\tfor(j = 0;j < W2;j++){\n\t\t\t\tif(nin2.find(ADD2[i][j]) == nin2.end()){\n\t\t\t\t\tnin2.insert(make_pair(ADD2[i][j],1));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tnin2[ADD2[i][j]]++;\t\t//2番目のキーをプラスしましょう。\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmap<int,int>::iterator it,bit;\n\t\tit = nin1.begin();\n\t\tfor(it++;it != nin1.end();it++){\n\t\t\tbit = it;\n\t\t\tbit--;\n\t\t\t(*it).S += (*bit).S;\n\t\t}\n\t\tit = nin2.begin();\n\t\tfor(it++;it != nin2.end();it++){\n\t\t\tbit = it;\n\t\t\tbit--;\n\t\t\t(*it).S += (*bit).S;\n\t\t}\n\t\t//入れる部屋数にたいする認証レベルの最小値を考えてみよう\n\t\tstatic int R1[100001],R2[100001];\n\t\tfor(i = 0;i < R+1;i++){R1[i] = 1000000000;R2[i] = 1000000000;}\n\t\tit = nin1.begin();\n\t\tR1[0] = 0;\n\t\tit++;\n\t\tfor(;it != nin1.end();it++){\n\t\t\tif((*it).S > R)\n\t\t\t\t(*it).S = R;\n\t\t\tbit = it;\n\t\t\tbit--;\n\t\t\tfor(i = (*it).S;i > (*bit).S;i--){\n\t\t\t\tif(R1[i] > (*it).F)\n\t\t\t\t\tR1[i] = (*it).F;\n\t\t\t}\n\t\t}\n\t\tit = nin2.begin();\n\t\tR2[0] = 0;\n\t\tit++;\n\t\tfor(;it != nin2.end();it++){\n\t\t\tif((*it).S > R)\n\t\t\t\t(*it).S = R;\n\t\t\tbit = it;\n\t\t\tbit--;\n\t\t\tfor(i = (*it).S;i > (*bit).S;i--){\n\t\t\t\tif(R2[i] > (*it).F)\n\t\t\t\t\tR2[i] = (*it).F;\n\t\t\t}\n\t\t}\n\t\t//デバッグ\n#ifdef DEBUG\n\t\tfor(i = 0;i < H1;i++){\n\t\t\tfor(j = 0;j < W1;j++){\n\t\t\t\tcout << ADD1[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tfor(i = 0;i < H2;i++){\n\t\t\tfor(j = 0;j < W2;j++){\n\t\t\t\tcout << ADD2[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << \"1部屋目\" << endl;\n\t\tfor(it = nin1.begin();it != nin1.end();it++){\n\t\t\tcout << (*it).F << \" \" << (*it).S << endl;\n\t\t}\n\t\tcout << \"2部屋目\" << endl;\n\t\tfor(it = nin2.begin();it != nin2.end();it++){\n\t\t\tcout << (*it).F << \" \" << (*it).S << endl;\n\t\t}\n\t\t//認証レベル\n\t\tfor(i = 0;i < H1;i++){\n\t\t\tfor(j = 0;j < W1;j++){\n\t\t\t\tcout << R1[i*W1+j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tfor(i = 0;i < H2;i++){\n\t\t\tfor(j = 0;j < W2;j++){\n\t\t\t\tcout << R2[i*W2+j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n#endif\n\t\t//探索(O(R))\n\t\tfor(i = 0;i < R+1;i++){\n\t\t\tif(minest[mcor] > R1[i]+R2[R-i])\n\t\t\t\tminest[mcor] = R1[i]+R2[R-i];\n\t\t}\t\t\n\t\t//使った分を初期化\n\t\tfor(i = 0;i < H1;i++){\n\t\t\tfor(j = 0;j < W1;j++){\n\t\t\t\tJOI1[i][j] = 0;\n\t\t\t\tADD1[i][j] = 100000001;\n\t\t\t}\n\t\t}\n\t\tfor(i = 0;i < H2;i++){\n\t\t\tfor(j = 0;j < W2;j++){\n\t\t\t\tJOI2[i][j] = 0;\n\t\t\t\tADD2[i][j] = 100000001;\n\t\t\t}\n\t\t}\n\t\tnin1.clear();\n\t\tnin2.clear();\n\t\t//カーソル移動\n\t\tmcor++;\n\t}\n\tfor(i = 0;i < mcor;i++){\n\t\tcout << minest[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n      \n#define FOR(i,a,b) for( ll i = (a); i < (ll)(b); i++ )\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define ALL(x) (x).begin(),(x).end()\n#define SORT(x) sort( (x).begin(),(x).end() )\n#define REVERSE(x) reverse( (x).begin(),(x).end() )\n#define UNIQUE(x) (x).erase( unique( ALL( (x) ) ) , (x).end() )\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n#define SHOW(x) cout << #x << \" = \" << x << endl\n#define SHOWA(x,n) for( int yui = 0; yui < n; yui++ ){ cout << x[yui] << \" \"; } cout << endl\n\n#define pb emplace_back\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long int ll;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<vpl> gr;\ntypedef vector<vl> ml;\ntypedef vector<vd> md;\ntypedef vector<vi> mi;\n     \nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ld EPS = 1e-12;\nconst ll MOD = 1e9+7;\n     \ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> inline T sq( T a ){ return a * a; }\n\nll in(){ long long int x; scanf( \"%lld\" , &x ); return x; }\nchar yuyushiki[1000010]; string stin(){ scanf( \"%s\" , yuyushiki ); return yuyushiki; }\n\n// head\n\ntemplate<class T> pair<vi,vector<T> > compress( vector<T> a ){\n  vector<T> ord = a;\n  vi res(0);\n  SORT( ord );\n  UNIQUE( ord );\n  YYS( w , a ) res.pb( lower_bound( ALL(ord) , w ) - ord.begin() );\n  return make_pair( res , ord );\n}\n\nint w, h;\nint a[510][510];\nbool used[510][510];\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nbool isin(int y, int x){\n  return 0 <= y && y < h && 0 <= x && x < w;\n}\n\nusing T = tuple<int, int, int>;\n\nvi calc(){\n  w = in();\n  h = in();\n  int x = in() - 1;\n  int y = in() - 1;\n  vi v(0);\n  REP(i, h){\n    REP(j, w){\n      v.pb(in());\n    }\n  }\n  auto c = compress(v);\n  REP(i, h){\n    REP(j, w){\n      a[i][j] = c.fi[i*w+j];\n    }\n  }\n  REP(i, h){\n    REP(j, w){\n      used[i][j] = false;\n    }\n  }\n  vi res = {0};\n  int cur = 0;\n  priority_queue<T, vector<T>, greater<T> > que;\n  que.emplace(a[y][x], y, x);\n  used[y][x] = true;\n  while(!que.empty()){\n    int val, cy, cx;\n    tie(val, cy, cx) = que.top();\n    que.pop();\n    chmax(cur, val);\n    res.pb(c.se[cur]);\n    REP(i, 4){\n      int ny = cy + dy[i];\n      int nx = cx + dx[i];\n      if(isin(ny, nx) && !used[ny][nx]){\n        used[ny][nx] = true;        \n        que.emplace(a[ny][nx], ny, nx);\n      }\n    }\n  }\n  return res;\n}\n\nvoid solve(){\n  int r = in();\n  if(r == 0){\n    exit(0);\n  }\n  vi resa = calc();\n  vi resb = calc();\n  /*\n  SHOWA(resa, SZ(resa));\n  SHOWA(resb, SZ(resb));\n  */\n  int ans = INF;\n  REP(i, r+1){\n    int j = r - i;\n    if(i < SZ(resa) && j < SZ(resb)){\n      chmin(ans, resa[i] + resb[j]);\n    }\n  }\n  printf(\"%d\\n\", ans);\n}\n\nint main(){\n\n  while(1){\n    solve();\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\ntypedef pair<int,Pi> PP;\n\nconst int INF=1000000000;\nconst long long int INF_=1000000000000000000;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\ninline bool IsIn(int y,int x,int h,int w){\n\treturn 0<=y&&y<h&&0<=x&&x<w;\n}\n\ninline int f(int x){\n\tif(x==0) return 1;\n\telse if(x==1) return 0;\n}\n\nvoid Djikstra(vector<vector<int> > &f,vector<vector<int> > &l,int sy,int sx,int h,int w){\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\tREP(y,0,h) fill(l[y].begin(),l[y].end(),INF);\n\tl[sy][sx]=1;\n\tque.push(PP(1,Pi(sy,sx)));\n\twhile(!que.empty()){\n\t\tPP p=que.top(); que.pop();\n\t\tPi v=p.S_;\n\t\tif(l[v.F_][v.S_]<p.F_) continue;\n\t\tREP(i,0,4){\n\t\t\tint ny=v.F_+dy[i],nx=v.S_+dx[i];\n\t\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\t\tif(l[ny][nx]>max(f[ny][nx],l[v.F_][v.S_])){\n\t\t\t\tl[ny][nx]=max(f[ny][nx],l[v.F_][v.S_]);\n\t\t\t\tque.push(PP(l[ny][nx],Pi(ny,nx)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tint R;\n\twhile(cin >> R&&R){\n\t\tint W[2],H[2],X[2],Y[2];\n\t\tvector<vector<int> > field[2];\n\t\tvector<vector<int> > level[2];\n\t\tint max_[2]={};\n\t\tREP(i,0,2){\n\t\t\tcin >> W[i] >> H[i] >> X[i] >> Y[i];\n\t\t\t--X[i]; --Y[i];\n\t\t\tfield[i].resize(H[i]);\n\t\t\tlevel[i].resize(H[i]);\n\t\t\tREP(j,0,H[i]){\n\t\t\t\tfield[i][j].resize(W[i]);\n\t\t\t\tlevel[i][j].resize(W[i]);\n\t\t\t}\n\t\t\tREP(y,0,H[i]) REP(x,0,W[i]){\n\t\t\t\tcin >> field[i][y][x];\n\t\t\t\tmax_[i]=max(max_[i],field[i][y][x]);\n\t\t\t}\n\t\t\tDjikstra(field[i],level[i],Y[i],X[i],H[i],W[i]);\n\t\t}\n\t\tmap<int,int> s[2];\n\t\tvector<int> idx[2],num[2];\n\t\tREP(i,0,2){\n\t\t\tREP(y,0,H[i]) REP(x,0,W[i]) ++s[i][level[i][y][x]];\n\t\t\tauto it=s[i].begin();\n\t\t\tidx[i].push_back(0);\n\t\t\tnum[i].push_back(0);\n\t\t\tidx[i].push_back(it->F_);\n\t\t\tnum[i].push_back(it->S_);\n\t\t\tauto prev=it;\n\t\t\t++it;\n\t\t\tfor(; it!=s[i].end(); ++it,++prev){\n\t\t\t\tit->S_+=prev->S_;\n\t\t\t\tidx[i].push_back(it->F_);\n\t\t\t\tnum[i].push_back(it->S_);\n\t\t\t}\n\t\t}\n\t\tint result=INF;\n\t\tREP(i,0,2) REP(j,0,idx[i].size()){\n\t\t\tint tmp=(int)(lower_bound(num[f(i)].begin(),num[f(i)].end(),R-num[i][j])-num[f(i)].begin());\n\t\t\tif(!(0<=tmp&&tmp<=idx[f(i)].size()-1)) continue;\n\t\t\tresult=min(result,idx[i][j]+idx[f(i)][tmp]);\n\t\t}\n\t\tcout << result << endl;\n\t}\n}\n\nint main(){\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <map>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\n\nint r,w1,w2,h1,h2,x1,x2,y1,y2;\n\n\nint k1[503][503];\n\nint k2[503][503];\n\nbool f1[503][503];\n\nbool f2[503][503];\n\n\n\nint main(){\n\n  while(1){\n\n  scanf(\"%d\",&r);\n\n  if(r == 0) break;\nscanf(\"%d%d%d%d\",&w1,&h1,&x1,&y1);\n\n  for(int i = 1;i <= h1;i++){\n    for(int j = 1;j <= w1;j++){\n      scanf(\"%d\",&k1[i][j]);\n      f1[i][j] = true;\n    }\n  }\n\n  scanf(\"%d%d%d%d\",&w2,&h2,&x2,&y2);\n\n  for(int i = 1;i <= h2;i++){\n    for(int j = 1;j <= w2;j++){\n      scanf(\"%d\",&k2[i][j]);\n      f2[i][j] = true;\n    }\n  }\n\n\n\n  priority_queue< P, vector<P> , greater<P> > que;\n\n  que.push(P(1,w1*(y1-1)+x1));\n\n  f1[y1][x1] = false;\n\n  map<int,int> m;\n\n  int nl = 0,ko = 0;\n\n  vector<int> hea;\n\n  vector<int>::iterator it;\n\n\n\n  while(!que.empty()){\n\n\n    P tmp = que.top();\n    que.pop();\n\n    int fir = tmp.first;\n    int sec = tmp.second;\n\n    int xx = sec % w1;\n    if(xx == 0) xx = w1;\n    int yy = (sec / w1) + 1;\n    f1 [yy][xx] = false; \n\n    for(int i = 0;i < 4;i++){\n      int nx = dx[i] + xx;\n      int ny = dy[i] + yy;\n\n      if(nx >= 1 && nx <= w1 && ny >= 1 && ny <= h1 && f1[ny][nx] == true){\n\tque.push(P(k1[ny][nx],w1*(ny-1)+nx));\n\tf1[ny][nx] = false;\n      }\n    }\n\n    if(nl < fir){\n      hea.push_back(ko);\n      m[ko] = nl;\n\n\n      nl =max(nl,fir);\n    }\n    ko++;\n\n  }\n  hea.push_back(ko);\n  m[ko] = nl;\n sort(hea.begin(),hea.end());\n\n\n\n que.push(P(1,w2*(y2-1)+x2));\n\n it = lower_bound(hea.begin(),hea.end(),r);\n\n\n int tuka = *it;\n\n int ans = m[tuka];\n if(ans == 0) ans = 1000000;\n\n\n f2[y2][x2] = false;\n\n int nau = 0;\n\n nl = 0;\n\n while(!que.empty()){\n\n   P  tmp = que.top(); que.pop();\n\n   int   fir = tmp.first;\n   int  sec = tmp.second;\n\n   int   xx = sec % w2;\n    if(xx == 0) xx = w2;\n    int   yy = (sec / w2);\n    if(sec % w2 != 0) yy++;\n    f2[yy][xx] = false; \n\n    for(int i = 0;i < 4;i++){\n      int nx = dx[i] + xx;\n      int ny = dy[i] + yy;\n\n      if(nx >= 1 && nx <= w2 && ny >= 1 && ny <= h2 && f2[ny][nx] == true){\n\tque.push(P(k2[ny][nx],w2*(ny-1)+nx));\n\tf2[ny][nx] = false;\n      }\n\n    }\n\n\n\n\n   if(nau >= r){\n     ans = min(ans,nl);\n\n     break;\n\n   }\n   if(nl != fir){\n   int ttt = r - nau;\n\n   it = lower_bound(hea.begin(),hea.end(),ttt);\n\n   int sea = *it;\n\n   int kari = m[sea];\n\n   if(kari != 0){\n\n   ans = min(ans,kari+nl);\n\n   }\n\n   nl = max(fir,nl);\n\n   }\n\n   nau++;\n \n }\n\n printf(\"%d\\n\",ans);\n\n  }\n return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nll c[2501];\nll b[500][500];\nstruct A {\n\tll ko, level;\n};\nA a[2][2501];\nll u[500][500];\nstruct P {\n\tll x, y, level;\n};\nll d[2];\nbool operator<(P a, P b) { return a.level < b.level; }\nbool operator>(P a, P b) { return a.level > b.level; }\nconst ll inf = 800000000000000000;\nint main() {\n\tll r;\n\tint lp[4][2] = { {1,0},{-1,0},{0,1},{0,-1} };\n\twhile (cin >> r&&r != 0) {\n\t\tfor (int z = 0; z < 2; z++) {\n\t\t\tll h, w, x, y;\n\t\t\tcin >> w >> h >> y >> x;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tqueue<P>p;\n\t\t\tfor (ll i = 0; i < h; i++) {\n\t\t\t\tfor (ll j = 0; j < w; j++) {\n\t\t\t\t\tcin >> u[i][j];\n\t\t\t\t\tb[i][j] = inf;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.push(P{ x,y,1 });\n\t\t\tb[x][y] = 1;\n\t\t\twhile (!p.empty()) {\n\t\t\t\tP t = p.front(); p.pop();\n\t\t\t\tll x = t.x, y = t.y;\n\t\t\t\tif (t.level == b[x][y]) {\n\t\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\t\tll x2 = x + lp[i][0], y2 = y + lp[i][1];\n\t\t\t\t\t\tif (b[x2][y2] > t.level) {\n\t\t\t\t\t\t\tif (u[x2][y2] <= t.level) {\n\t\t\t\t\t\t\t\tb[x2][y2] = t.level;\n\t\t\t\t\t\t\t\tp.push(P{ x2,y2,t.level });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (u[x2][y2] < b[x2][y2]) {\n\t\t\t\t\t\t\t\t\tb[x2][y2] = u[x2][y2];\n\t\t\t\t\t\t\t\t\tp.push(P{ x2,y2,u[x2][y2] });\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tll o = 0;\n\t\t\tfor (ll i = 0; i < h; i++) {\n\t\t\t\tfor (ll j = 0; j < w; j++) {\n\t\t\t\t\tc[o] = b[i][j];\n\t\t\t\t\to++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(c, c + o);\n\t\t\tll sum = 0, g = 1;\n\t\t\ta[z][0] = A{ 0,0 };\n\t\t\tfor (ll i = 0; i < (h*w);) {\n\t\t\t\tll k = c[i], sum2 = 0;\n\t\t\t\twhile (i < (h*w) && c[i] == k) {\n\t\t\t\t\tsum2++;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\ta[z][g] = A{ sum2 + sum,k };\n\t\t\t\tg++;\n\t\t\t\tsum += sum2;\n\t\t\t}\n\t\t\td[z] = g;\n\t\t}\n\t\tll sum = inf;\n\t\tfor (ll i = 0; i < d[0]; i++) {\n\t\t\tll s = 0, e = d[1] - 1, t, m = r - a[0][i].ko;\n\t\t\twhile (e - s > 1) {\n\t\t\t\tt = (e + s) / 2;\n\t\t\t\tif (a[1][t].ko <= m)\n\t\t\t\t\ts = t;\n\t\t\t\tif (a[1][t].ko >= m)\n\t\t\t\t\te = t;\n\t\t\t}\n\t\t\tif (a[0][i].ko + a[1][s].ko >= r)\n\t\t\t\tsum = min(sum, a[0][i].level + a[1][s].level);\n\t\t\tif (a[0][i].ko + a[1][e].ko >= r)\n\t\t\t\tsum = min(sum, a[0][i].level + a[1][e].level);\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntemplate<class T> constexpr bool in_range(T y, T x, T H, T W) { return 0<=y&&y<H&&0<=x&&x<W; }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\ntemplate<class T> using PQ_G = priority_queue<T, vector<T>, greater<T>>;\n\nbool solve() {\n\n  int R; cin >> R;\n  if(R == 0) return 1;\n\n  int W[2], H[2], X[2], Y[2];\n  vector<vector<vector<int>>> G(2);\n\n  rep(i, 2) {\n    cin >> W[i] >> H[i] >> X[i] >> Y[i]; Y[i]--, X[i]--;\n    G[i].resize(H[i]); rep(k, H[i]) G[i][k].resize(W[i]);\n    rep(y, H[i]) rep(x, W[i]) cin >> G[i][y][x];\n  }\n\n  map<int, int> counts[2];\n\n  rep(t, 2) {\n    vector<vector<int>> dist(H[t], vector<int>(W[t], inf));\n    PQ_G<tuple<int, int, int>> pq;\n    pq.emplace(0, Y[t], X[t]);\n    dist[Y[t]][X[t]] = 0;\n\n    counts[t][0] = 0;\n    counts[t][1] = 1;\n\n    while(!pq.empty()) {\n      int c, y, x; tie(c, y, x) = pq.top(); pq.pop();\n\n      if(dist[y][x] < c) continue;\n\n      rep(k, 4) {\n        int ny = y + dy[k], nx = x + dx[k];\n        if(!in_range(ny, nx, H[t], W[t])) continue;\n        int nc = max(c, G[t][ny][nx]);\n        if(dist[ny][nx] <= nc) continue;\n        dist[ny][nx] = nc;\n        counts[t][nc]++;\n        pq.emplace(nc, ny, nx);\n      }\n    }\n  }\n\n  set<pair<int, int>> st[2];\n\n  rep(t, 2) {\n    st[t].emplace(inf, inf);\n    for(auto iter=counts[t].begin(); iter!=counts[t].end(); iter++) {\n      if(iter == counts[t].begin()) continue;\n      auto prev = iter; prev--;\n      iter->second += prev->second;\n    }\n  }\n\n  rep(t, 2) for(auto e: counts[t]) {\n    st[t].emplace(e.second, e.first);\n  }\n\n  int ans = inf;\n\n  rep(i, R + 1) {\n    auto a = st[0].lower_bound({i, -inf});\n    auto b = st[1].lower_bound({R-i, -inf});\n    if(a->first == inf) continue;\n    if(b->first == inf) continue;\n    ans = min(ans, a->second + b->second);\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}\n\nint main() {\n\n  while(!solve());\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nint w[2], h[2], l[2][500][500], sx[2], sy[2], r;\nint dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nint ans[2][100001], d[250000];\nbool vis[500][500], used[500][500];\nvector<P>que[250000];\nint compress(int k) {\n\tvector<int>x;\n\trep(i, h[k])rep(j, w[k])x.push_back(l[k][i][j]);\n\tsort(x.begin(), x.end());\n\tx.erase(unique(x.begin(), x.end()), x.end());\n\trep(i, x.size())d[i] = x[i];\n\trep(i, h[k])rep(j, w[k])\n\t\tl[k][i][j] = lower_bound(x.begin(), x.end(), l[k][i][j]) - x.begin();\n\treturn x.size();\n}\nvoid solve(int k) {\n\tans[k][0] = 0;\n\tqueue<P>Q;\n\tint n = compress(k);\n\trep(i, n)que[i].clear();\n\tmemset(vis, 0, sizeof(vis));\n\tmemset(used, 0, sizeof(used));\n\tQ.push(P(sx[k], sy[k]));\n\tvis[sx[k]][sy[k]] = true;\n\tint cnt = 0, Max = 0;\n\twhile (1) {\n\t\twhile (!Q.empty()) {\n\t\t\tP p = Q.front(); Q.pop();\n\t\t\tif (used[p.first][p.second])continue;\n\t\t\tused[p.first][p.second] = true;\n\t\t\tcnt++; if (cnt >= r)break;\n\t\t\trep(i, 4) {\n\t\t\t\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\tif (0 <= nx&&nx < h[k] && 0 <= ny&&ny < w[k] && !vis[nx][ny]) {\n\t\t\t\t\tvis[nx][ny] = true;\n\t\t\t\t\tif (l[k][nx][ny] <= Max)Q.push(P(nx, ny));\n\t\t\t\t\telse que[l[k][nx][ny]].push_back(P(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans[k][cnt] = min(ans[k][cnt], d[Max]);\n\t\tfor (int i = Max; i < n; i++) {\n\t\t\tif (!que[i].empty()) {\n\t\t\t\tMax = i;\n\t\t\t\tfor (P p : que[i])Q.push(p);\n\t\t\t\tque[i].clear();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (cnt >= r || Q.empty())break;\n\t}\n\tfor (int i = r - 1; i >= 1; i--)ans[k][i] = min(ans[k][i], ans[k][i + 1]);\n}\nint main() {\n\twhile (scanf(\"%d\", &r), r) {\n\t\trep(k, 2) {\n\t\t\tscanf(\"%d%d%d%d\", &w[k], &h[k], &sy[k], &sx[k]); sx[k]--; sy[k]--;\n\t\t\trep(i, h[k])rep(j, w[k])scanf(\"%d\", &l[k][i][j]);\n\t\t}\n\t\tfill(ans[0], ans[2], INT_MAX);\n\t\trep(k, 2)solve(k);\n\t\tint Min = INT_MAX;\n\t\tfor (int i = 0; i <= r; i++) {\n\t\t\tif (ans[0][i] == INT_MAX || ans[1][r - i] == INT_MAX)continue;\n\t\t\tMin = min(Min, ans[0][i] + ans[1][r - i]);\n\t\t}\n\t\tprintf(\"%d\\n\", Min);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\n\nconst int INF=1000000000;\nconst long long int INF_=1000000000000000000;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\ninline bool IsIn(int y,int x,int h,int w){\n\treturn 0<=y&&y<h&&0<=x&&x<w;\n}\n\nvoid BFS(vector<vector<int> > &f,vector<vector<int> > &l,int sy,int sx,int h,int w){\n\tvector<vector<int> > done(h,vector<int>(w));\n\tvector<vector<int> > done_(h,vector<int>(w));\n\tl[sy][sx]=1;\n\tdone[sy][sx]=done_[sy][sx]=1;\n\tqueue<Pi> que;\n\tREP(i,0,4){\n\t\tint ny=sy+dy[i],nx=sx+dx[i];\n\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\tdone_[ny][nx]=1;\n\t\tque.push(Pi(ny,nx));\n\t}\n\twhile(!que.empty()){\n\t\tPi p=que.front();\n\t\tque.pop();\n\t\tdone[p.F_][p.S_]=1;\n\t\tbool flag=true;\n\t\tint tmp=INF;\n\t\tREP(i,0,4){\n\t\t\tint ny=p.F_+dy[i],nx=p.S_+dx[i];\n\t\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\t\tif(done[ny][nx]==1) tmp=min(tmp,l[ny][nx]);\n\t\t\tif(done[ny][nx]==1&&l[ny][nx]>=f[p.F_][p.S_]) flag=false;\n\t\t\tif(done_[ny][nx]!=1){\n\t\t\t\tdone_[ny][nx]=1;\n\t\t\t\tque.push(Pi(ny,nx));\n\t\t\t}\n\t\t}\n\t\tif(flag) l[p.F_][p.S_]=f[p.F_][p.S_];\n\t\telse {\n\t\t\tif(tmp!=INF) l[p.F_][p.S_]=max(tmp,f[p.F_][p.S_]);\n\t\t\telse l[p.F_][p.S_]=f[p.F_][p.S_];\n\t\t}\n\t}\n}\n\n\n\nvoid Djikstra(vector<vector<int> > &f,vector<vector<int> > &l,int sy,int sx,int h,int w){\n\tvector<vector<bool> > used(h,vector<bool>(w,false));\n\tREP(y,0,h) fill(l[y].begin(),l[y].end(),INF);\n\tl[sy][sx]=1;\n\twhile(true){\n\t\tPi v(-1,-1);\n\t\tREP(y,0,h){\n\t\t\tREP(x,0,w){\n\t\t\t\tif(!used[y][x]&&((v.F_==-1&&v.S_==-1)||l[y][x]<l[v.F_][v.S_])){\n\t\t\t\t\tv.F_=y;\n\t\t\t\t\tv.S_=x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(v.F_==-1&&v.S_==-1) break;\n\t\tused[v.F_][v.S_]=true;\n\t\tREP(i,0,4){\n\t\t\tint ny=v.F_+dy[i],nx=v.S_+dx[i];\n\t\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\t\tl[ny][nx]=min(l[ny][nx],max(f[ny][nx],l[v.F_][v.S_]));\n\t\t}\n\t}\n}\n\ninline int f(int x){\n\tif(x==0) return 1;\n\telse if(x==1) return 0;\n}\n\nvoid solve(){\n\tint R;\n\twhile(cin >> R&&R){\n\t\tint W[2],H[2],X[2],Y[2];\n\t\tvector<vector<int> > field[2];\n\t\tvector<vector<int> > level[2];\n\t\tint max_[2]={};\n\t\tREP(i,0,2){\n\t\t\tcin >> W[i] >> H[i] >> X[i] >> Y[i];\n\t\t\t--X[i]; --Y[i];\n\t\t\tfield[i].resize(H[i]);\n\t\t\tlevel[i].resize(H[i]);\n\t\t\tREP(j,0,H[i]){\n\t\t\t\tfield[i][j].resize(W[i]);\n\t\t\t\tlevel[i][j].resize(W[i]);\n\t\t\t}\n\t\t\tREP(y,0,H[i]) REP(x,0,W[i]){\n\t\t\t\tcin >> field[i][y][x];\n\t\t\t\tmax_[i]=max(max_[i],field[i][y][x]);\n\t\t\t}\n\t\t\tDjikstra(field[i],level[i],Y[i],X[i],H[i],W[i]);\n\t\t\t/*\n\t\t\tcout << endl << endl;\n\t\t\tREP(y,0,H[i]){\n\t\t\t\tREP(x,0,W[i]) cout << level[i][y][x] << ' ';\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\t/*\n\t\tvector<unsigned int> s[2];\n\t\tREP(i,0,2){\n\t\t\ts[i].resize(max_[i]+1);\n\t\t\tREP(y,0,H[i]) REP(x,0,W[i]) ++s[i][level[i][y][x]];\n\t\t\tREP(j,1,max_[i]+1) s[i][j]+=s[i][j-1];\n\t\t}\n\t\tint result=INF;\n\t\tREP(i,0,2){\n\t\t\tfor(int j=0; j<=max_[i]&&j<=result; ++j){\n\t\t\t\tint idx=(int)(lower_bound(s[i].begin(),s[i].end(),R-s[f(i)][j])-s[i].begin());\n\t\t\t\tif(!(0<=idx&&idx<=max_[i])) continue;\n\t\t\t\tresult=min(result,j+idx);\n\t\t\t}\n\t\t}\n\t\tcout << result << endl;\n\t\t*/\n\t\tmap<int,int> s[2];\n\t\tvector<int> idx[2],num[2];\n\t\tREP(i,0,2){\n\t\t\tREP(y,0,H[i]) REP(x,0,W[i]) ++s[i][level[i][y][x]];\n\t\t\tauto it=s[i].begin();\n\t\t\tidx[i].push_back(0);\n\t\t\tnum[i].push_back(0);\n\t\t\tidx[i].push_back(it->F_);\n\t\t\tnum[i].push_back(it->S_);\n\t\t\tauto prev=it;\n\t\t\t++it;\n\t\t\tfor(; it!=s[i].end(); ++it,++prev){\n\t\t\t\tit->S_+=prev->S_;\n\t\t\t\t//cout << it->F_ << ' ' << it->S_ << endl;\n\t\t\t\tidx[i].push_back(it->F_);\n\t\t\t\tnum[i].push_back(it->S_);\n\t\t\t}\n\t\t}\n\t\tint result=INF;\n\t\t/*\n\t\tcout << endl;\n\t\tREP(i,0,2) REP(j,0,idx[i].size()){\n\t\t\tcout << i << ' ' << idx[i][j] << ' ' << num[i][j] << endl;\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\t\tREP(i,0,2) REP(j,0,idx[i].size()){\n\t\t\tint tmp=(int)(lower_bound(num[f(i)].begin(),num[f(i)].end(),R-num[i][j])-num[f(i)].begin());\n\t\t\t//cout << idx[i][tmp] << ' ' << num[i][tmp] << ' ' << idx[f(i)][j] << ' ' << num[f(i)][j] << endl;\n\t\t\tif(!(0<=tmp&&tmp<=idx[f(i)].size()-1)) continue;\n\t\t\tresult=min(result,idx[i][j]+idx[f(i)][tmp]);\n\t\t}\n\t\tcout << result << endl;\n\t}\n}\n\nint main(){\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\n\nint calc_required_level_to_rooms(int* res)\n{\n\tint w, h, sx, sy;\n\tstatic int req[512][512];\n\tscanf(\"%d%d%d%d\", &w, &h, &sx, &sy);\n\t--sx, --sy;\n\tfor (int y = 0; y < h; ++y)\n\t\tfor (int x = 0; x < w; ++x)\n\t\t\tscanf(\"%d\", &req[y][x]);\n\n\tstatic bool visit[512][512];\n\tfor (int y = 0; y < h; ++y)\n\t\tfor (int x = 0; x < w; ++x)\n\t\t\tvisit[y][x] = false;\n\n\tint c = 0;\n\tres[c++] = 0;\n\n\ttypedef pair<int, pint> P;\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tq.push(P(1, pint(sx, sy)));\n\twhile (c <= w * h)\n\t{\n\t\tP tt = q.top(); q.pop();\n\t\tint level = tt.first;\n\t\tint x = tt.second.first, y = tt.second.second;\n\t\tif (visit[y][x])\n\t\t\tcontinue;\n\n\t\tvisit[y][x] = true;\n\t\tres[c++] = level;\n\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\t\tif (valid_pos(tx, ty, w, h) && !visit[ty][tx])\n\t\t\t\tq.push(P(max(level, req[ty][tx]), pint(tx, ty)));\n\t\t}\n\t}\n\treturn w * h;\n}\nint main()\n{\n\tint r;\n\twhile (scanf(\"%d\", &r), r)\n\t{\n\t\tstatic int a[512 * 512], b[512 * 512];\n\t\tint a_size = calc_required_level_to_rooms(a);\n\t\tint b_size = calc_required_level_to_rooms(b);\n\n\t\tint res = 1e9;\n\t\tfor (int i = min<int>(r, a_size); i >= 0 && r - i <= b_size; --i)\n\t\t\tmin_swap(res, a[i] + b[r - i]);\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef tuple<int,int,int> tri;\n\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint r,w,h,x,y;\nint g[555][555];\nbool vis[555][555];\n\nint main(){\n  while(cin >> r, r){\n    vector<pii> num[2];\n\n    for(int id=0;id<2;id++){\n      cin >> w >> h >> x >> y;\n      x--; y--;\n      for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++)cin >> g[i][j];\n      }\n\n      memset(vis,0,sizeof(vis));\n      vis[y][x] = true;\n      priority_queue<tri> q;\n      q.push(tri(-g[y][x],y,x));\n\n      int cnt = 0, val = 0;\n      while(q.size()){\n\tnum[id].push_back(pii(cnt,val));\n\t\n\tdo{\n\t  cnt++;\n\t  y = get<1>(q.top()); x = get<2>(q.top());\n\t  val = min(val, get<0>(q.top()) );\n\t  q.pop();\n\t  \n\t  for(int i=0;i<4;i++){\n\t    int ny = y+dy[i], nx = x+dx[i];\n\t    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n\t    if(vis[ny][nx])continue;\n\t    vis[ny][nx] = true;\n\t    q.push(tri(-g[ny][nx],ny,nx));\n\t  }\n\t}while(q.size() && get<0>(q.top()) >= val);\n      }\n      num[id].push_back(pii(cnt,val));\n    }\n    \n    int ans = 1e9, rev_ite = num[1].size() - 1;\n    for(int i=0;i<(int)num[0].size();i++){\n      while(rev_ite>=0 && num[0][i].first + num[1][rev_ite].first >= r)rev_ite--;\n      rev_ite++;\n      if(num[0][i].first + num[1][rev_ite].first >= r){\n\tans = min(ans, - num[0][i].second - num[1][rev_ite].second);\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\n\nclass union_find {\n\tvector<int> par;\n\tvector<int> rank;\n\tint find(int a) {\n\t\treturn par[a] < 0 ? a : par[a] = find(par[a]);\n\t}\npublic:\n\tunion_find(int n) : par(n, -1), rank(n, 1) {}\n\tbool same(int a, int b) {\n\t\treturn find(a) == find(b);\n\t}\n\tvoid unite(int a, int b) {\n\t\ta = find(a);\n\t\tb = find(b);\n\t\tif (a == b) return;\n\t\tif (rank[a] > rank[b]) {\n\t\t\tpar[a] += par[b];\n\t\t\tpar[b] = a;\n\t\t}\n\t\telse {\n\t\t\tpar[b] += par[a];\n\t\t\tpar[a] = b;\n\t\t\tif (rank[a] == rank[b]) rank[b]++;\n\t\t}\n\t}\n\tint size(int a) {\n\t\treturn -par[find(a)];\n\t}\n};\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint R;\n\twhile (cin >> R, R) {\n\t\tvector<vector<int>> v(2);\n\t\tfor (int k = 0; k < 2; k++) {\n\t\t\tint W, H, X, Y;\n\t\t\tcin >> W >> H >> X >> Y; X--, Y--;\n\t\t\tvector<vector<int>> a(H, vector<int>(W));\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tcin >> a[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tvector<int> cs;\n\t\t\tvector<vector<int>> es;\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tif (i + 1 < H) {\n\t\t\t\t\t\tcs.push_back(max(a[i][j], a[i][j + 1]));\n\t\t\t\t\t\tes.push_back(vector<int>({ max(a[i][j], a[i + 1][j]), i * W + j, (i + 1) * W + j }));\n\t\t\t\t\t}\n\t\t\t\t\tif (j + 1 < W) {\n\t\t\t\t\t\tcs.push_back(max(a[i][j], a[i][j + 1]));\n\t\t\t\t\t\tes.push_back(vector<int>({ max(a[i][j], a[i][j + 1]), i * W + j, i * W + j + 1 }));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(cs.begin(), cs.end());\n\t\t\tcs.erase(unique(cs.begin(), cs.end()), cs.end());\n\t\t\tsort(es.begin(), es.end());\n\n\t\t\tv[k].assign(H * W + 1, INF);\n\t\t\tv[k][0] = 0;\n\t\t\tv[k][1] = 1;\n\t\t\tunion_find uf(H * W);\n\t\t\tfor (int i = 0, j = 0; i < (int)cs.size(); i++) {\n\t\t\t\twhile (j < (int)es.size() && es[j][0] == cs[i]) {\n\t\t\t\t\tuf.unite(es[j][1], es[j][2]);\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tint sz = uf.size(Y * W + X);\n\t\t\t\tv[k][sz] = min(v[k][sz], cs[i]);\n\t\t\t}\n\t\t\tfor (int i = H * W - 1; i >= 2; i--) {\n\t\t\t\tv[k][i] = min(v[k][i], v[k][i + 1]);\n\t\t\t}\n\t\t}\n\t\tint res = 1e8;\n\t\tfor (int i = 0; i < (int)v[0].size(); i++) if (0 <= R - i && R - i < (int)v[1].size()) {\n\t\t\tres = min(res, v[0][i] + v[1][R - i]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define int long long\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>T& max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T& min(T&a,T&b){if(a<b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T get(){T a;cin>>a;return a;}\ntemplate<typename T>T rev(T a){reverse(all(a));return a;}\ntemplate<typename T>vector<T>&sort(vector<T>&a){sort(all(a));return a;}\n\nconst int inf = 1e9;\nconst ll linf = 3e18;\nconst double eps = 1e-9;\n\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, -1, 0, 1};\n\nint R;\nint W[2], H[2];\nint X[2], Y[2];\nint A[2][502][502];\n\nbool used[502][502];\n\nvpii data[2];\n\nvoid bfs(int num)\n{\n    typedef pair<int, pii> Data;\n    memset(used, false, sizeof(used));\n\n    priority_queue<Data> q;\n\n    q.push(Data(-1, pii(Y[num], X[num])));\n    used[Y[num]][X[num]] = true;\n\n    if (num == 0) {\n        data[num].PB(pii(1, 0));\n    } else {\n        data[num].PB(pii(0, 0));\n        data[num].PB(pii(0, 1));\n    }\n\n    int ma = 1;\n    int cnt = 0;\n    int hoge = 0;\n\n    while (q.size()) {\n        Data p = q.top(); q.pop();\n\n        int cur = -p.fst;\n\n        if (ma < cur) {\n            if (num == 0) {\n                data[num].back().scd = cnt;\n            } else {\n                data[num].back().fst = cnt;\n            }\n\n            ma = cur;\n\n            if (num == 0) {\n                data[num].PB(pii(ma, 0));\n            } else {\n                data[num].PB(pii(0, ma));\n            }\n        }\n\n        cnt++;\n\n        rep(i, 4) {\n            int ny = p.scd.fst + dy[i], nx = p.scd.scd + dx[i];\n\n            if (ny < 0 || ny >= H[num] || nx < 0 || nx >= W[num] || used[ny][nx]) continue;\n            used[ny][nx] = true;\n\n            q.push(Data(-A[num][ny][nx], pii(ny, nx)));\n        }\n    }\n\n    if (num == 0) {\n        data[num].back().scd = cnt;\n    } else {\n        data[num].back().fst = cnt;\n    }\n}\n\nsigned main()\n{ // #define int long long ?????????????????§scanf???????????¨???????????????????????\\?????????????????????\n    while (cin >> R, R) {\n        data[0].clear();\n        data[1].clear();\n\n        rep(i, 2) {\n            cin >> W[i] >> H[i] >> X[i] >> Y[i];\n\n            --X[i], --Y[i];\n\n            rep(j, H[i]) rep(k, W[i]) {\n                cin >> A[i][j][k];\n            }\n        }\n\n        bfs(0);\n        bfs(1);\n\n        int mi = inf;\n\n        data[1].PB(pii(inf, inf));\n\n        rep(i, data[0].size()) {\n            pii a = data[0][i];\n\n            chmin(mi, a.fst + lower_bound(all(data[1]), pii(R - a.scd, -inf))->scd);\n        }\n\n        cout << mi << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<algorithm>\n#include<functional>\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<long long int,P> PP;\nint r;\nint w[2],h[2];\nint x[2],y[2];\nint dx[4]={0,0,-1,1},dy[4]={1,-1,0,0};\nlong long int field[2][501][501];\nbool used[2][501][501];\nlong long int INF=10000000000000;\nlong long int dp[2][25001];\nlong long int ans;\n\nvoid dfs(int i,int sx,int sy){\n\tpriority_queue<PP , vector<PP> , greater<PP> > que;\n\tint fl=1;\n\tque.push(PP(field[i][sx][sy],P(sx,sy)));\n\tused[i][sx][sy]=true;\n\twhile(que.size()){\n\t\tPP q=que.top();que.pop();\n\t\tlong long int c=q.first;\n\t\tint mx=q.second.first,my=q.second.second;\n\t\tdp[i][fl]=max(dp[i][fl-1],c);\n\t\tfl++;\n\t\tfor(int j=0;j<4;j++){\n\t\t\tint nx=mx+dx[j],ny=my+dy[j];\n\t\t\tif(nx>=0 && nx<w[i] && ny>=0 && ny<h[i] && used[i][nx][ny]==false){\n\t\t\t\tque.push(PP(field[i][nx][ny],P(nx,ny)));\n\t\t\t\tused[i][nx][ny]=true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&r);\n\t\tif(r==0)break;\n\t\tfor(int i=1;i<=25000;i++)dp[0][i]=dp[1][i]=INF;\n\t\tdp[0][0]=dp[1][0]=0;\n\t\tmemset(field,0,sizeof(field));\n\t\tmemset(used,false,sizeof(used));\n\n\t\tscanf(\"%d%d%d%d\",&w[0],&h[0],&x[0],&y[0]);\n\t\tfor(int i=0;i<h[0];i++){\n\t\t\tfor(int j=0;j<w[0];j++){\n\t\t\t\tscanf(\"%lld\",&field[0][j][i]);\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d%d%d%d\",&w[1],&h[1],&x[1],&y[1]);\n\t\tfor(int i=0;i<h[1];i++){\n\t\t\tfor(int j=0;j<w[1];j++){\n\t\t\t\tscanf(\"%lld\",&field[1][j][i]);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<2;i++)dfs(i,x[i]-1,y[i]-1);\n\t\tans=INF;\n\t\tfor(int i=0;i<=r;i++){\n\t\t\tans=min(ans,dp[0][i]+dp[1][r-i]);\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<iostream>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define reps(i,n) for(int i=1;i<=int(n);i++)\n\nvector<int> need[2];\nint masu[555][555];\nint visit[555][555];\nclass S{\npublic:\n  int x,y;\n  int n;\n  S(int x,int y,int n):x(x),y(y),n(n){};\n  bool operator<(const S& a)const{\n    return n>a.n;\n  }\n};\nint main(){\n  while(1){\n  int n;\n  cin>>n;\n  if(n==0)break;\n  int dx[]={1,0,-1,0};\n  int dy[]={0,1,0,-1};\n  need[0].clear();\n  need[1].clear();\n  rep(p,2){\n    int a,b,c,d;\n    cin>>a>>b>>c>>d;\n    rep(i,b){\n      rep(j,a){\n\tcin>>masu[j][i];\n      }\n    }\n    rep(i,b){\n      rep(j,a){\n\tvisit[j][i]=0;\n      }\n    }\n    priority_queue<S> que;\n    que.push(S(c-1,d-1,1));\n    need[p].push_back(0);\n    int now=-1;\n    while(1){\n      if(que.empty()==1){\n\tbreak;\n      }\n      S u=que.top();\n      que.pop();\n      if(u.x<0 || u.y<0||u.y>=b||u.x>=a)continue;\n      if(visit[u.x][u.y]==1){\n\tcontinue;\n      }\n      //printf(\"!%d %d %d\\n\",u.x,u.y,u.n);\n      visit[u.x][u.y]=1;\n      now=max(now,masu[u.x][u.y]);\n      need[p].push_back(now);\n      \n      rep(i,4){\n\tque.push(S(u.x+dx[i],u.y+dy[i],masu[u.x+dx[i]][u.y+dy[i]]));\n      }\n    }\n  }\n  /*\n  rep(i,2){\n    rep(j,need[i].size()){\n      printf(\"%d\\n\",need[i][j]);\n    }puts(\"\");\n    }*/\n  int ans=101000000;\n  rep(i,max(need[0].size(),need[1].size())){\n    if(i>=need[0].size())continue;\n    if(n-i<0)continue;\n    if(n-i>=need[1].size())continue;\n    ans=min(ans,need[0][i]+need[1][n-i]);\n  }\n  printf(\"%d\\n\",ans);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pint;\ntypedef pair<ll, int> P;\n//typedef tuple<int,int,int> T;\nll INFL = 1000000000000000010;//10^18 = 2^60\nint INF = 2147483600;//10^9\nll MOD  = 1000000007;\nvector<int> dy = {1,-1,0,0};\nvector<int> dx = {0,0,1,-1};\nvector<int> Ans(0);\nvector<vector<int>> mp1(510, vector<int>(510));\nvector<vector<int>> mp2(510, vector<int>(510));\nvector<vector<int>> d1(510, vector<int>(510));\nvector<vector<int>> d2(510, vector<int>(510));\nint solve(){\n    int R;\n    cin >> R;\n    if(R == 0) return 0;\n    int H1,W1,X1,Y1;\n    cin >> W1 >> H1 >> X1 >> Y1;\n    X1--;\n    Y1--;\n    for(int i = 0; i < H1; i++) for(int j = 0; j < W1; j++) d1[i][j] = INF;\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            cin >> mp1[i][j];\n        }\n    }\n    \n    d1[Y1][X1] = 1;\n    priority_queue<pair<int, pair<int, int>>> pque1;\n    pque1.push({1, {Y1, X1}});\n    \n    while(!pque1.empty()){\n        int c;\n        int y,x;\n        c = pque1.top().first;\n        y = pque1.top().second.first;\n        x = pque1.top().second.second;\n        pque1.pop();\n        if(c > d1[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H1 && 0 <= nx && nx < W1){\n                if(d1[ny][nx] > d1[y][x]){\n                    if(d1[y][x] > mp1[ny][nx]){\n                        d1[ny][nx] = d1[y][x];\n                    }else{\n                        d1[ny][nx] = mp1[ny][nx];\n                    }\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }else if(d1[ny][nx] > d1[y][x]){\n                    d1[ny][nx] = mp1[ny][nx];\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    int H2,W2,X2,Y2;\n    cin >> W2 >> H2 >> X2 >> Y2;\n    X2--;\n    Y2--;\n    for(int i = 0; i < H2; i++) for(int j = 0; j < W2; j++) d2[i][j] = INF;\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            cin >> mp2[i][j];\n        }\n    }\n    \n    d2[Y2][X2] = 1;\n    priority_queue<pair<int, pair<int, int>>> pque2;\n    pque2.push({1, {Y2, X2}});\n    \n    while(!pque2.empty()){\n        int c;\n        int y,x;\n        c = pque2.top().first;\n        y = pque2.top().second.first;\n        x = pque2.top().second.second;\n        pque2.pop();\n        if(c > d2[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H2 && 0 <= nx && nx < W2){\n                if(d2[ny][nx] > d2[y][x]){\n                    if(d2[y][x] > mp2[ny][nx]){\n                        d2[ny][nx] = d2[y][x];\n                    }else{\n                        d2[ny][nx] = mp2[ny][nx];\n                    }\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }else if(d2[ny][nx] > d2[y][x]){\n                    d2[ny][nx] = mp2[ny][nx];\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    vector<pair<int,int>> O1(0);\n    vector<int> COST1(0);\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            COST1.push_back(d1[i][j]);\n        }\n    }\n    sort(COST1.begin(), COST1.end());\n    COST1.push_back(INFL);\n    ll ad1 = COST1.at(0);\n    for(int i = 0; i < COST1.size(); i++){\n        if(ad1 == COST1.at(i)){\n        }else{\n            O1.push_back({ad1, i});\n            ad1 = COST1.at(i);\n        }\n    }\n    \n    vector<pair<int,int>> O2(1);\n    O2.at(0).first = 0;\n    O2.at(0).second = 0;\n    vector<ll> COST2(0);\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            COST2.push_back(d2[i][j]);\n        }\n    }\n    sort(COST2.begin(), COST2.end());\n    COST2.push_back(INFL);\n    int ad2 = COST2.at(0);\n    for(int i = 0; i < COST2.size(); i++){\n        if(ad2 == COST2.at(i)){\n        }else{\n            O2.push_back({ad2, i});\n            ad2 = COST2.at(i);\n        }\n    }\n    \n    \n    int ans = INF;\n    int right = -1;\n    for(int i = 0; i < O1.size(); i++){\n        int cost = O1.at(i).first;\n        int rest = R - O1.at(i).second;\n        \n        if(rest > O2.at(O2.size()-1).second) continue;\n        int left = -1;\n        if(right == -1){\n            right = O2.size();\n        }\n        int mid;\n        while(right - left > 1){\n            mid = (left + right) / 2;\n            if(O2.at(mid).second >= rest){\n                right = mid;\n            }else{\n                left = mid;\n            }\n        }\n        cost += O2.at(right).first;\n        ans = min(ans, cost);\n    }\n    \n    Ans.push_back(ans);\n    solve();\n    return 0;\n}\n\nint main(void){\n    solve();\n    for(int i = 0; i < Ans.size(); i++){\n        cout << Ans.at(i) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <utility>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <cstring>\nusing namespace std;\n#define INF 10000000\n\nint ary1[510][510],ary2[510][510];\nbool used[510][510];\nint main(){\n\tint R,W1,W2,H1,H2,X1,X2,Y1,Y2,imax,imay,imad,res;\n\tpriority_queue<pair<int,pair<int,int> > ,vector<pair<int,pair<int,int> > >,greater<pair<int,pair<int,int> > > > que;\n\tset<int> se1,se2;\n\tvector<int> v1,v2;\n\tpair<int,pair<int,int> > pa;\n\twhile(1){\n\t\tv1.clear();\n\t\tv2.clear();\n\t\tcin>>R;\n\t\tif(R==0) break;\n\t\tcin>>W1>>H1>>Y1>>X1;\n\t\tX1--;Y1--;\n\t\tfor(int i=0;i<H1;i++){\n\t\t\tfor(int j=0;j<W1;j++){\n\t\t\t\tcin>>ary1[i][j];\n\t\t\t}\n\t\t}\n\t\tcin>>W2>>H2>>Y2>>X2;\n\t\tX2--;Y2--;\n\t\tfor(int i=0;i<H2;i++){\n\t\t\tfor(int j=0;j<W2;j++){\n\t\t\t\tcin>>ary2[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemset(used,0,sizeof(used));\n\t\tque.push(make_pair(1,make_pair(X1,Y1)));\n\t\tused[X1][Y1]=true;\n\t\twhile(!que.empty()){\n\t\t\tpa=que.top();que.pop();\n\t\t\timax=pa.second.first;\n\t\t\timay=pa.second.second;\n\t\t\timad=pa.first;\n\t\t\tary1[imax][imay]=imad;\n\t\t\tif(imax>0&&(!used[imax-1][imay])){\n\t\t\t\tused[imax-1][imay]=true;\n\t\t\t\tque.push(make_pair(max(ary1[imax-1][imay],imad),make_pair(imax-1,imay)));\n\t\t\t}\n\t\t\tif(imax<H1-1&&(!used[imax+1][imay])){\n\t\t\t\tused[imax+1][imay]=true;\n\t\t\t\tque.push(make_pair(max(ary1[imax+1][imay],imad),make_pair(imax+1,imay)));\n\t\t\t}\n\t\t\tif(imay>0&&(!used[imax][imay-1])){\n\t\t\t\tused[imax][imay-1]=true;\n\t\t\t\tque.push(make_pair(max(ary1[imax][imay-1],imad),make_pair(imax,imay-1)));\n\t\t\t}\n\t\t\tif(imay<W1-1&&(!used[imax][imay+1])){\n\t\t\t\tused[imax][imay+1]=true;\n\t\t\t\tque.push(make_pair(max(ary1[imax][imay+1],imad),make_pair(imax,imay+1)));\n\t\t\t}\n\t\t}\n\t\tmemset(used,0,sizeof(used));\n\t\tque.push(make_pair(1,make_pair(X2,Y2)));\n\t\tused[X2][Y2]=true;\n\t\twhile(!que.empty()){\n\t\t\tpa=que.top();que.pop();\n\t\t\timax=pa.second.first;\n\t\t\timay=pa.second.second;\n\t\t\timad=pa.first;\n\t\t\tary2[imax][imay]=imad;\n\t\t\tif(imax>0&&(!used[imax-1][imay])){\n\t\t\t\tused[imax-1][imay]=true;\n\t\t\t\tque.push(make_pair(max(ary2[imax-1][imay],imad),make_pair(imax-1,imay)));\n\t\t\t}\n\t\t\tif(imax<H2-1&&(!used[imax+1][imay])){\n\t\t\t\tused[imax+1][imay]=true;\n\t\t\t\tque.push(make_pair(max(ary2[imax+1][imay],imad),make_pair(imax+1,imay)));\n\t\t\t}\n\t\t\tif(imay>0&&(!used[imax][imay-1])){\n\t\t\t\tused[imax][imay-1]=true;\n\t\t\t\tque.push(make_pair(max(ary2[imax][imay-1],imad),make_pair(imax,imay-1)));\n\t\t\t}\n\t\t\tif(imay<W2-1&&(!used[imax][imay+1])){\n\t\t\t\tused[imax][imay+1]=true;\n\t\t\t\tque.push(make_pair(max(ary2[imax][imay+1],imad),make_pair(imax,imay+1)));\n\t\t\t}\n\t\t}\n\t\tv1.push_back(0);\n\t\tfor(int i=0;i<H1;i++){\n\t\t\tfor(int j=0;j<W1;j++){\n\t\t\t\tv1.push_back(ary1[i][j]);\n\t\t\t}\n\t\t}\n\t\tsort(v1.begin(),v1.end());\n\t\tv2.push_back(0);\n\t\tfor(int i=0;i<H2;i++){\n\t\t\tfor(int j=0;j<W2;j++){\n\t\t\t\tv2.push_back(ary2[i][j]);\n\t\t\t}\n\t\t}\n\t\tsort(v2.begin(),v2.end());\n\t\tres=INF;\n\t\tfor(int i=0;i<=R;i++){\n\t\t\tif(W1*H1>=i&&W2*H2>=R-i)res=min(res,v1.at(i)+v2.at(R-i));\n\t\t}\n\t\tcout<<res<<endl;\n\t\t////\n\t\t//for(int i=0;i<H1;i++){\n\t\t//\tfor(int j=0;j<W1;j++){\n\t\t//\t\tcout<<ary1[i][j]<<\" \";\n\t\t//\t}\n\t\t//\tcout<<endl;\n\t\t//}\n\t\t//for(int i=0;i<H2;i++){\n\t\t//\tfor(int j=0;j<W2;j++){\n\t\t//\t\tcout<<ary2[i][j]<<\" \";\n\t\t//\t}\n\t\t//\tcout<<endl;\n\t\t//}\n\t\t//\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<functional>\n#define int long long\n#define p pair<int,int>\n#define P pair<int,p>\nusing namespace std;\n\nint x[4] = { -1,0,0,1 }, y[4] = { 0,-1,1,0 };\nint f[500][500];\nbool i[500][500];\nset<p>l,r;\nsigned main() {\n\tint a;\n\twhile (cin >> a, a) {\n\t\tl.insert(p(0, 0)); r.insert(p(0, 0));\n\t\tint b, c, d, e; cin >> c >> b >> e >> d;\n\t\td--; e--;\n\t\tfor (int g = 0; g < b; g++) {\n\t\t\tfor (int h = 0; h < c; h++) {\n\t\t\t\tscanf(\"%lld\", &f[g][h]);\n\t\t\t}\n\t\t}\n\t\tmemset(i, true, sizeof(i));\n\t\tint sum = 0, MAX = 0;\n\t\tpriority_queue<P, vector<P>, greater<P>>Q;\n\t\tQ.push(P(1, p(d, e)));\n\t\twhile (Q.size()) {\n\t\t\tP o = Q.top(); Q.pop();\n\t\t\tMAX = o.first; \n\t\t\tif(i[o.second.first][o.second.second])sum++;\n\t\t\ti[o.second.first][o.second.second] = false;\n\t\t\tqueue<p>q;\n\t\t\tq.push(p(o.second.first, o.second.second));\n\t\t\twhile (q.size()) {\n\t\t\t\tp t = q.front(); q.pop();\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint dx = t.first + x[i], dy = t.second + y[i];\n\t\t\t\t\tif (dx >= 0 && dx < b&&dy >= 0 && dy < c&&::i[dx][dy]) {\n\t\t\t\t\t\tif (f[dx][dy] <= o.first) {\n\t\t\t\t\t\t\tsum++;\n\t\t\t\t\t\t\tq.push(p(dx,dy));\n\t\t\t\t\t\t\t::i[dx][dy] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tQ.push(P(f[dx][dy],p(dx,dy)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tl.insert(p(sum, MAX));\n\t\t}\n\t\tcin >> c >> b >> e >> d;\n\t\td--; e--;\n\t\tfor (int g = 0; g < b; g++) {\n\t\t\tfor (int h = 0; h < c; h++) {\n\t\t\t\tscanf(\"%lld\", &f[g][h]);\n\t\t\t}\n\t\t}\n\t\tmemset(i, true, sizeof(i));\n\t\tsum = 0; MAX = 0;\n\t\tpriority_queue<P, vector<P>, greater<P>>U;\n\t\tU.push(P(1, p(d, e)));\n\t\twhile (U.size()) {\n\t\t\tP o = U.top(); U.pop();\n\t\t\tMAX = o.first;\n\t\t\tif (i[o.second.first][o.second.second])sum++;\n\t\t\ti[o.second.first][o.second.second] = false;\n\t\t\tqueue<p>q;\n\t\t\tq.push(p(o.second.first, o.second.second));\n\t\t\twhile (q.size()) {\n\t\t\t\tp t = q.front(); q.pop();\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint dx = t.first + x[i], dy = t.second + y[i];\n\t\t\t\t\tif (dx >= 0 && dx < b&&dy >= 0 && dy < c&&::i[dx][dy]) {\n\t\t\t\t\t\tif (f[dx][dy] <= o.first) {\n\t\t\t\t\t\t\tsum++;\n\t\t\t\t\t\t\tq.push(p(dx, dy));\n\t\t\t\t\t\t\t::i[dx][dy] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tU.push(P(f[dx][dy], p(dx, dy)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tr.insert(p(sum, MAX));\n\t\t}\n\t\tint MIN = LLONG_MAX/3;\n\t\tfor (auto i = l.begin(); i != l.end(); i++) {\n\t\t\tauto j = r.lower_bound(p(a-(*i).first,0));\n\t\t\tif (j != r.end()) {\n\t\t\t\tMIN = min(MIN, (*i).second + (*j).second);\n\t\t\t}\n\t\t}\n\t\tcout << MIN << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Tag {\n    int x, y, level;\n    Tag() {}\n    Tag(int xx, int yy, int l) : x(xx), y(yy), level(l) {}\n};\n\nbool operator < (const Tag &t1, const Tag &t2) {\n    return t1.level > t2.level;\n}\n\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nvoid check(vector<vector<int> > &room, vector<pair<int, int> > &v, int sx, int sy) {\n    int W = room[0].size();\n    int H = room.size();\n\n    priority_queue<Tag> q;\n    q.push(Tag(sx, sy, room[sy][sx]));\n    room[sy][sx] = 0;\n    int level = 0;\n    int cnt = 0;\n\n    while(!q.empty()) {\n        int x = q.top().x;\n        int y = q.top().y;\n        int lv = q.top().level;\n        q.pop();\n\n        if(lv > level) {\n            v.push_back(make_pair(level, cnt));\n            level = lv;\n        }\n        ++cnt;\n\n        for(int i = 0; i < 4; ++i) {\n            int nx = x+dx[i];\n            int ny = y+dy[i];\n            if(nx < 0 || W <= nx || ny < 0 || H <= ny) continue;\n            if(room[ny][nx] == 0) continue;\n            q.push(Tag(nx, ny, room[ny][nx]));\n            room[ny][nx] = 0;\n        }\n    }\n    v.push_back(make_pair(level, cnt));\n}\n\nint main() {\n    while(true) {\n        int R;\n        cin >> R;\n        if(!R) break;\n\n        vector<pair<int, int> > v[2];\n        for(int K = 0; K < 2; ++K) {\n            int W, H, X, Y;\n            cin >> W >> H >> X >> Y;\n            vector<vector<int> > room(H, vector<int>(W));\n            for(int i = 0; i < H; ++i) {\n                for(int j = 0; j < W; ++j) {\n                    cin >> room[i][j];\n                }\n            }\n            check(room, v[K], X-1, Y-1);\n        }\n\n        int ans = INT_MAX;\n        for(int i = 0; i < v[0].size(); ++i) {\n            int l = v[0][i].first;\n            int rem = R-v[0][i].second;\n            //cout << l << ':' << rem << endl;\n            if(rem <= 0) {\n                ans = min(ans, l);\n                break;\n            }\n\n            int left = 0, right = v[1].size();\n            while(left < right) {\n                int center = (left+right)/2;\n                int cr = v[1][center].second;\n                if(cr < rem) left = center+1;\n                else right = center;\n            }\n            if(left >= v[1].size()) continue;\n            ans = min(ans, l+v[1][left].first);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pint;\ntypedef pair<ll, int> P;\n//typedef tuple<int,int,int> T;\nll INFL = 1000000000000000010;//10^18 = 2^60\nint INF = 2147483600;//10^9\nll MOD  = 1000000007;\nint solve(){\n    vector<int> dy(4);\n    vector<int> dx(4);\n    dy.at(0) = 0;\n    dy.at(1) = 0;\n    dy.at(2) = 1;\n    dy.at(3) = -1;\n    dx.at(0) = 1;\n    dx.at(1) = -1;\n    dx.at(2) = 0;\n    dx.at(3) = 0;\n    \n    int R;\n    cin >> R;\n    if(R == 0)return 0;\n    int H1,W1,X1,Y1;\n    cin >> W1 >> H1 >> X1 >> Y1;\n    X1--;\n    Y1--;\n    vector<vector<ll>> mp1(H1, vector<ll>(W1));\n    vector<vector<ll>> d1(H1, vector<ll>(W1, INFL));\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            cin >> mp1[i][j];\n        }\n    }\n    \n    d1[Y1][X1] = 1;\n    priority_queue<pair<ll, pair<int, int>>> pque1;\n    pque1.push({1, {Y1, X1}});\n    \n    while(!pque1.empty()){\n        ll c;\n        int y,x;\n        c = pque1.top().first;\n        y = pque1.top().second.first;\n        x = pque1.top().second.second;\n        pque1.pop();\n        if(c > d1[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H1 && 0 <= nx && nx < W1){\n                if(d1[ny][nx] > d1[y][x]){\n                    if(d1[y][x] > mp1[ny][nx]){\n                        d1[ny][nx] = d1[y][x];\n                    }else{\n                        d1[ny][nx] = mp1[ny][nx];\n                    }\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }else if(d1[ny][nx] > d1[y][x]){\n                    d1[ny][nx] = mp1[ny][nx];\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    int H2,W2,X2,Y2;\n    cin >> W2 >> H2 >> X2 >> Y2;\n    X2--;\n    Y2--;\n    vector<vector<ll>> mp2(H2, vector<ll>(W2));\n    vector<vector<ll>> d2(H2, vector<ll>(W2, INFL));\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            cin >> mp2[i][j];\n        }\n    }\n    \n    d2[Y2][X2] = 1;\n    priority_queue<pair<ll, pair<int, int>>> pque2;\n    pque2.push({1, {Y2, X2}});\n    \n    while(!pque2.empty()){\n        ll c;\n        int y,x;\n        c = pque2.top().first;\n        y = pque2.top().second.first;\n        x = pque2.top().second.second;\n        pque2.pop();\n        if(c > d2[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H2 && 0 <= nx && nx < W2){\n                if(d2[ny][nx] > d2[y][x]){\n                    if(d2[y][x] > mp2[ny][nx]){\n                        d2[ny][nx] = d2[y][x];\n                    }else{\n                        d2[ny][nx] = mp2[ny][nx];\n                    }\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }else if(d2[ny][nx] > d2[y][x]){\n                    d2[ny][nx] = mp2[ny][nx];\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    vector<pair<ll,int>> O1(0);\n    vector<ll> COST1(0);\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            COST1.push_back(d1[i][j]);\n        }\n    }\n    sort(COST1.begin(), COST1.end());\n    COST1.push_back(INFL);\n    ll ad1 = COST1.at(0);\n    int cnt = 0;\n    for(int i = 0; i < COST1.size(); i++){\n        if(ad1 == COST1.at(i)){\n            cnt++;\n        }else{\n            O1.push_back({ad1, cnt});\n            ad1 = COST1.at(i);\n            cnt++;\n        }\n    }\n    \n    vector<pair<ll,int>> O2 = {pair{0, 0}};\n    vector<ll> COST2(0);\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            COST2.push_back(d2[i][j]);\n        }\n    }\n    sort(COST2.begin(), COST2.end());\n    COST2.push_back(INFL);\n    ll ad2 = COST2.at(0);\n    cnt = 0;\n    for(int i = 0; i < COST2.size(); i++){\n        if(ad2 == COST2.at(i)){\n            cnt++;\n        }else{\n            O2.push_back({ad2, cnt});\n            ad2 = COST2.at(i);\n            cnt++;\n        }\n    }\n    \n    ll ans = INFL;\n    for(int i = 0; i < O1.size(); i++){\n        ll cost = O1.at(i).first;\n        int rest = R - O1.at(i).second;\n        \n        if(rest > O2.at(O2.size()-1).second) continue;\n        int left = -1, right = O2.size();\n        int mid;\n        while(right - left > 1){\n            mid = (left + right) / 2;\n            if(O2.at(mid).second >= rest){\n                right = mid;\n            }else{\n                left = mid;\n            }\n        }\n        cost += O2.at(right).first;\n        ans = min(ans, cost);\n        \n    }\n    \n    cout << ans << endl;\n    \n    solve();\n    return 0;\n}\n\nint main(void){\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\n\nconst int INF=100000000;\nconst long long int INF_=1000000000000000000;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nbool IsIn(int y,int x,int h,int w){\n\treturn 0<=y&&y<h&&0<=x&&x<w;\n}\n\nvoid BFS(vector<vector<int> > &f,vector<vector<int> > &l,int sy,int sx,int h,int w){\n\tvector<vector<int> > done(h,vector<int>(w));\n\tl[sy][sx]=1;\n\tdone[sy][sx]=1;\n\tqueue<Pi> que;\n\tREP(i,0,4){\n\t\tint ny=sy+dy[i],nx=sx+dx[i];\n\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\tque.push(Pi(ny,nx));\n\t}\n\twhile(!que.empty()){\n\t\tPi p=que.front();\n\t\tque.pop();\n\t\tdone[p.F_][p.S_]=1;\n\t\tbool flag=true;\n\t\tint tmp=INF;\n\t\tREP(i,0,4){\n\t\t\tint ny=p.F_+dy[i],nx=p.S_+dx[i];\n\t\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\t\ttmp=min(tmp,l[ny][nx]);\n\t\t\tif(done[ny][nx]==1&&l[ny][nx]>=f[p.F_][p.S_]) flag=false;\n\t\t\tif(done[ny][nx]!=1) que.push(Pi(ny,nx));\n\t\t}\n\t\tif(flag) l[p.F_][p.S_]=f[p.F_][p.S_];\n\t\telse l[p.F_][p.S_]=tmp;\n\t}\n}\n\nvoid solve(){\n\tint R;\n\twhile(cin >> R&&R){\n\t\tint W[2],H[2],X[2],Y[2];\n\t\tvector<vector<int> > field[2];\n\t\tvector<vector<int> > level[2];\n\t\tvector<int> count[2],s[2];\n\t\tint _max=0;\n\t\tREP(i,0,2){\n\t\t\tcin >> W[i] >> H[i] >> X[i] >> Y[i];\n\t\t\t--X[i]; --Y[i];\n\t\t\tfield[i].resize(H[i]);\n\t\t\tlevel[i].resize(H[i]);\n\t\t\tREP(j,0,H[i]){\n\t\t\t\tfield[i][j].resize(W[i]);\n\t\t\t\tlevel[i][j].resize(W[i]);\n\t\t\t}\n\t\t\tREP(y,0,H[i]) REP(x,0,W[i]){\n\t\t\t\tcin >> field[i][y][x];\n\t\t\t\t_max=max(_max,field[i][y][x]);\n\t\t\t}\n\t\t\tBFS(field[i],level[i],Y[i],X[i],H[i],W[i]);\n\t\t\t/*\n\t\t\tcout << endl << endl;\n\t\t\tREP(y,0,H[i]){\n\t\t\t\tREP(x,0,W[i]) cout << level[i][y][x] << ' ';\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\tREP(i,0,2){\n\t\t\tcount[i].resize(_max+1);\n\t\t\ts[i].resize(_max+1);\n\t\t}\n\t\tREP(i,0,2) REP(y,0,H[i]) REP(x,0,W[i]) ++count[i][level[i][y][x]];\n\t\tREP(i,0,2) REP(j,1,_max+1) s[i][j]=s[i][j-1]+count[i][j];\n\t\tint result=INF;\n\t\tREP(i,0,_max*2+1){\n\t\t\t//cout << i << ' ' << s[0][i] << ' ' <<  (int)(lower_bound(s[1].begin(),s[1].end(),R-s[0][i])-s[1].begin()) << ' ' << s[1][(int)(lower_bound(s[1].begin(),s[1].end(),R-s[0][i])-s[1].begin())] << endl;\n\t\t\tint idx=(int)(lower_bound(s[1].begin(),s[1].end(),R-s[0][i])-s[1].begin());\n\t\t\tif(!(0<=idx&&idx<=_max)) continue;\n\t\t\tresult=min(result,i+idx);\n\t\t}\n\t\tcout << result << endl;\n\t}\n}\n\nint main(){\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 160000\n#define B 100\n#define dpb push_back\n#define fi first\n#define se second\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst int inf = 1e9;\nconst ll INF = 1e18;\n//__gcd(a,b), __builtin_popcount(a);\n\nint r, h1, w1, X1, Y1, h2, w2, X2, Y2;\nint dy[4] = {0, 0, -1, 1}, dx[4] = {-1, 1, 0, 0};\nint a[502][502], b[502][502];\nint an[250004], bn[250004];\n\nint to_n(int y, int x, int w){\n\treturn (w*(y-1)+x);\n}\nint to_y(int n, int w){\n\treturn ((n-1)/w+1);\n}\nint to_x(int n, int w){\n\treturn (n-(to_y(n, w)-1)*w);\n}\nint main(){\n\twhile(1){\n\tfill((int*)a, (int*)(a+501), inf);\n\tfill((int*)b, (int*)(b+501), inf);\n\tfill(an, an+250004, 0);\n\tfill(bn, bn+250004, 0);\n\tscanf(\"%d\", &r);\n\tif(!r)break;\n\tscanf(\"%d%d%d%d\", &w1, &h1, &X1, &Y1);\n\trrep(i,h1)rrep(j,w1)scanf(\"%d\", &a[i][j]);\n\tscanf(\"%d%d%d%d\", &w2, &h2, &X2, &Y2);\n\trrep(i,h2)rrep(j,w2)scanf(\"%d\", &b[i][j]);\n\t\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tq.push(P(a[Y1][X1], to_n(Y1, X1,w1)));\n\ta[Y1][X1] = inf;\n\tint acnt = 1;\n\twhile(!q.empty()){\n\t\tP p = q.top();q.pop();\n\t\tint y = to_y(p.se, w1), x = to_x(p.se, w1);\n\t\tan[acnt++] = p.fi;\n\t\tfor(int i = 0;i < 4;i++){\n\t\t\tint yy = y+dy[i], xx = x+dx[i];\n\t\t\tif(a[yy][xx] != inf){\n\t\t\t\tq.push(P(a[yy][xx], to_n(yy, xx,w1)));\n\t\t\t\ta[yy][xx] = inf;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tq.push(P(b[Y2][X2], to_n(Y2, X2,w2)));\n\tb[Y2][X2] = inf;\n\tint bcnt = 1;\n\twhile(!q.empty()){\n\t\tP p = q.top();q.pop();\n\t\tint y = to_y(p.se, w2), x = to_x(p.se, w2);\n\t\tbn[bcnt++] = p.fi;\n\t\tfor(int i = 0;i < 4;i++){\n\t\t\tint yy = y+dy[i], xx = x+dx[i];\n\t\t\tif(b[yy][xx] != inf){\n\t\t\t\tq.push(P(b[yy][xx], to_n(yy, xx,w2)));\n\t\t\t\tb[yy][xx] = inf;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint t1 = 0, t2 = 0;\n\tfor(int i = 0;i < acnt;i++){\n\t\tt1 = max(t1, an[i]);\n\t\tan[i] = t1;\n\t}\n\tfor(int i = 0;i < bcnt;i++){\n\t\tt2 = max(t2, bn[i]);\n\t\tbn[i] = t2;\n\t}\n\t\n\tint ans = inf;\n\tfor(int i = 0;i < acnt;i++){\n\t\tif(r-i < bcnt)ans = min(ans, an[i]+bn[r-i]);\n\t}\n\t\n\t/*rep(i,acnt)printf(\"%d \", an[i]);\n\tprintf(\"\\n\");\n\trep(i,bcnt)printf(\"%d \", bn[i]);\n\tprintf(\"\\n\");*/\n\t//int ans = 0;\n\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\ntypedef vector<vector<pii>> Graph;\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n\tbool operator<(const Edge& e)const{return weight<e.weight;}\n\tbool operator>(const Edge& e)const{return weight>e.weight;}\n};\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int size):data(size,-1){}\n\tint Find(int n){\n\t\treturn data[n]<0?n:(data[n]=Find(data[n]));\n\t}\n\tvoid Unite(int a,int b){\n\t\tint ra=Find(a),rb=Find(b);\n\t\tif(ra!=rb){\n\t\t\tif(-data[ra]<-data[rb])\n\t\t\t\tswap(ra,rb);\n\t\t\tdata[ra]+=data[rb];\n\t\t\tdata[rb]=ra;\n\t\t}\n\t}\n\tint Size(int n){\n\t\treturn -data[Find(n)];\n\t}\n};\n\nint main()\n{\n\tfor(int r;~scanf(\"%d\",&r) && r;){\n\t\tint n[2],p[2],l[2];\n\t\tvector<Edge> es[2];\n\t\trep(k,2){\n\t\t\tint w,h,x,y; scanf(\"%d%d%d%d\",&w,&h,&x,&y);\n\t\t\tn[k]=w*h; p[k]=(y-1)*w+(x-1);\n\t\t\tvi level(n[k]);\n\t\t\trep(i,n[k]) scanf(\"%d\",&level[i]);\n\t\t\tl[k]=level[p[k]];\n\t\t\t\n\t\t\trep(i,h) rep(j,w) rep(_,4){\n\t\t\t\tint ni=i+\"\\xff\\x1\\0\\0\"[_],nj=j+\"\\0\\0\\xff\\x1\"[_];\n\t\t\t\tif(ni<0 || h<=ni || nj<0 || w<=nj) continue;\n\t\t\t\tes[k].emplace_back(i*w+j,ni*w+nj,max(level[i*w+j],level[ni*w+nj]));\n\t\t\t}\n\t\t\tsort(all(es[k]));\n\t\t}\n\t\t\n\t\tvector<pii> mn[2]; // (#rooms,level)\n\t\trep(k,2){\n\t\t\tmn[k].emplace_back(0,0);\n\t\t\tUnionFind uf(n[k]);\n\t\t\tfor(Edge e:es[k]){\n\t\t\t\tuf.Unite(e.src,e.dst);\n\t\t\t\tif(e.weight<l[k])\n\t\t\t\t\tcontinue;\n\t\t\t\telse if(e.weight>mn[k].back().second)\n\t\t\t\t\tmn[k].emplace_back(uf.Size(p[k]),e.weight);\n\t\t\t\telse\n\t\t\t\t\tmn[k].back().first=uf.Size(p[k]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint res=INFTY;\n\t\trep(i,mn[0].size()){\n\t\t\tint j=lower_bound(all(mn[1]),mp(r-mn[0][i].first,0))-mn[1].begin();\n\t\t\tif(j==mn[1].size()) continue;\n\t\t\tres=min(res,mn[0][i].second+mn[1][j].second);\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <functional>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF (1<<29)\n\nstruct Data {\n\tint x, y, c;\n\tData() {}\n\tData(int x, int y, int c) : x(x), y(y), c(c) {}\n\t\n\tbool operator > (const Data &r) const {\n\t\tif (c > r.c) return true;\n\t\telse return false;\n\t}\n};\n\nint W[2], H[2], X[2], Y[2];\nint maps[2][500][500];\nint level[2][250001]; // [i][j] ?????????i??§j????¨???????????????????????????¬??????\nint R;\n\nint main() {\n\twhile (cin >> R, R) {\n\t\tfill(level[0], level[2], 0);\n\t\t\n\t\tREP(i, 2) {\n\t\t\tcin >> W[i] >> H[i] >> X[i] >> Y[i];\n\t\t\tX[i]--; Y[i]--;\n\t\t\t\n\t\t\tREP(j, H[i]) REP(k, W[i]) scanf(\"%d\", &maps[i][j][k]);\n\t\t\t\n\t\t\tint cnt = 1, nc = 0;\n\t\t\tbool done[500][500] = {};\n\t\t\tpriority_queue<Data, vector<Data>, greater<Data> > pq;\n\t\t\t\n\t\t\t\n\t\t\tpq.push(Data(X[i], Y[i], 1));\n\t\t\t\n\t\t\twhile (!pq.empty()) {\n\t\t\t\tData now = pq.top(); pq.pop();\n\t\t\t\t\n\t\t\t\tif (done[now.y][now.x]) continue;\n\t\t\t\tdone[now.y][now.x] = true;\n\t\t\t\t\n\t\t\t\tif (now.c > nc) nc = now.c;\n\t\t\t\tlevel[i][cnt++] = nc;\n\t\t\t\t\n\t\t\t\tint dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1};\n\t\t\t\tREP(j, 4) {\n\t\t\t\t\tint nx = now.x + dx[j], ny = now.y + dy[j];\n\t\t\t\t\tif (!(nx >= 0 && nx < W[i] && ny >= 0 && ny < H[i])) continue;\n\t\t\t\t\tif (done[ny][nx]) continue;\n\t\t\t\t\t\n\t\t\t\t\tpq.push(Data(nx, ny, maps[i][ny][nx]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = INF;\n\t\tREP(i, R + 1) {\n\t\t\tif (H[0] * W[0] < i) continue;\n\t\t\tif (H[1] * W[1] < R - i) continue;\n\t\t\t\n\t\t\tans = min(ans, level[0][i] + level[1][R - i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\n\nconst int inf = 1e9;\n\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, -1, 0, 1};\n\nint R;\nint W[2], H[2];\nint X[2], Y[2];\nint A[2][502][502];\n\nbool used[502][502];\n\nvpii data[2];\n\nvoid bfs(int num)\n{\n\ttypedef pair<int, pii> Data;\n\tmemset(used, false, sizeof(used));\n\n\tpriority_queue<Data> q;\n\n\tq.push(Data(-1, pii(Y[num], X[num])));\n\tused[Y[num]][X[num]] = true;\n\n\tif (num == 0) {\n\t\tdata[num].PB(pii(1, 0));\n\t} else {\n\t\tdata[num].PB(pii(0, 0));\n\t\tdata[num].PB(pii(0, 1));\n\t}\n\n\tint ma = 1;\n\tint cnt = 0;\n\tint hoge = 0;\n\n\twhile (q.size()) {\n\t\tData p = q.top(); q.pop();\n\n\t\tint cur = -p.fst;\n\n\t\tif (ma < cur) {\n\t\t\tif (num == 0) {\n\t\t\t\tdata[num].back().scd = cnt;\n\t\t\t} else {\n\t\t\t\tdata[num].back().fst = cnt;\n\t\t\t}\n\n\t\t\tma = cur;\n\n\t\t\tif (num == 0) {\n\t\t\t\tdata[num].PB(pii(ma, 0));\n\t\t\t} else {\n\t\t\t\tdata[num].PB(pii(0, ma));\n\t\t\t}\n\t\t}\n\n\t\tcnt++;\n\n\t\trep(i, 4) {\n\t\t\tint ny = p.scd.fst + dy[i], nx = p.scd.scd + dx[i];\n\n\t\t\tif (ny < 0 || ny >= H[num] || nx < 0 || nx >= W[num] || used[ny][nx]) continue;\n\t\t\tused[ny][nx] = true;\n\n\t\t\tq.push(Data(-A[num][ny][nx], pii(ny, nx)));\n\t\t}\n\t}\n\n\tif (num == 0) {\n\t\tdata[num].back().scd = cnt;\n\t} else {\n\t\tdata[num].back().fst = cnt;\n\t}\n}\n\nsigned main()\n{\n\twhile (cin >> R, R) {\n\t\tdata[0].clear();\n\t\tdata[1].clear();\n\n\t\trep(i, 2) {\n\t\t\tcin >> W[i] >> H[i] >> X[i] >> Y[i];\n\n\t\t\t--X[i], --Y[i];\n\n\t\t\trep(j, H[i]) rep(k, W[i]) {\n\t\t\t\tcin >> A[i][j][k];\n\t\t\t}\n\t\t}\n\n\t\tbfs(0);\n\t\tbfs(1);\n\n\t\tint mi = inf;\n\n\t\tdata[1].PB(pii(inf, inf));\n\n\t\trep(i, data[0].size()) {\n\t\t\tpii a = data[0][i];\n\n\t\t\tchmin(mi, a.fst + lower_bound(all(data[1]), pii(R - a.scd, -inf))->scd);\n\t\t}\n\n\t\tcout << mi << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <iterator>\n#include <list>\n#include <map>\n#include <queue>\n#include <bitset>\n#include <fstream>\n#include <cmath>\n#include <ctime>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define REP(i,s,n) for(int i = s; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define MSG(a) cout << #a << \" \"  << a << endl;\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nconst int INF = 1 << 30;\n\nstruct node\n{\n\tint x, y, cost;\n\tnode(int x, int y, int cost) : x(x), y(y), cost(cost) {}\n};\nbool operator < (const node &a, const node &b)\n{ return a.cost > b.cost; }\n\nint room[500][500];\nint from[500 * 500];\nbool flag[500][500];\n\nint main()\n{\n\tint r;\n\twhile(cin >> r && r)\n\t{\n\t\t// key, value\n\t\tmap<int, int> result[2];\n\t\tresult[0][0] = result[1][0] = 0;\n\n\t\t\n\t\t// Dijkstra\n\t\trep(i, 2)\n\t\t{\n\t\t\tint w, h, sx, sy;\n\t\t\tcin >> w >> h >> sx >> sy; sx--; sy--;\n\n\t\t\trep(y, h) rep(x, w) cin >> room[y][x];\n\n\n\t\t\tpriority_queue<node> que;\n\t\t\tmemset(flag, 0, sizeof(flag));\n\t\t\t\n\t\t\tfor(que.push(node(sx, sy, room[sy][sx])); !que.empty(); que.pop())\n\t\t\t{\n\t\t\t\tnode q = que.top();\n\t\t\t\t\n\t\t\t\tif(flag[q.y][q.x]) continue;\n\t\t\t\telse flag[q.y][q.x] = true;\n\t\t\t\t\n\t\t\t\tresult[i][q.cost]++;\n\t\t\t\t\n\t\t\t\tint dx[] = {-1,0,1,0} , dy[] = {0,-1,0,1};\n\t\t\t\trep(d, 4)\n\t\t\t\t{\n\t\t\t\t\tint tx = q.x + dx[d], ty = q.y + dy[d];\n\t\t\t\t\tif(0 <= tx && tx < w && 0 <= ty && ty < h && !flag[ty][tx]) que.push(node(tx, ty, max(q.cost, room[ty][tx])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint res = INF;\n\n\t\tint sum_one = 0;\n\t\tvector<int> u;\n\t\t\n\t\tfor(map<int, int>::iterator it = result[1].begin(); it != result[1].end(); it++)\n\t\t{\n\t\t\tfrom[u.size()] = it->first;\n\t\t\tu.push_back(it->second + sum_one);\n\t\t\tsum_one += it->second;\n\t\t}\n\t\tu.push_back(INF);\n\n\n\t\tint sum_one_second = 0;\n\n\t\tfor(map<int, int>::iterator it = result[0].begin(); it != result[0].end(); it++)\n\t\t{\n\t\t\tint l = it->first, c = it->second + sum_one_second, ac = *lower_bound(u.begin(), u.end(), r - l);\n\t\t\tif(ac != INF)\n\t\t\t{\n\t\t\t\tint al = from[lower_bound(u.begin(), u.end(), r - c) - u.begin()];\n\t\t\t\tchmin(res, l + al);\n\t\t\t}\n\t\t\tsum_one_second += it->second;\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int>pii;\ntypedef pair<int,pii>piii;\nconst int dxy[5]={0,-1,0,1,0};\nint main(){\n    int r;\n    while(scanf(\"%d\",&r),r){\n        vector<pair<int,int> >ans[2];\n        for(int k=0;k<2;k++){\n            int w,h,sx,sy;\n            int fld[500][500];\n            vector<int>vec(1,0);\n            scanf(\"%d%d%d%d\",&w,&h,&sx,&sy);\n            sx--;sy--;\n            for(int i=0;i<h;i++){\n                for(int j=0;j<w;j++){\n                    int v;\n                    scanf(\"%d\",&v);\n                    fld[i][j]=v;\n                    vec.push_back(v);\n                }\n            }\n            sort(vec.begin(),vec.end());\n            vec.erase(unique(vec.begin(),vec.end()),vec.end());\n            priority_queue<piii,vector<piii>,greater<piii> >Q;\n            int pos=0,cnt=0;\n            Q.push(piii(1,pii(sy,sx)));\n            bool used[500][500]={{0}};\n            while(Q.size()){\n                int y=Q.top().second.first,x=Q.top().second.second;\n                int v=Q.top().first;\n                Q.pop();\n                if(used[y][x])continue;\n                if(v>vec[pos]){\n                    ans[k].push_back(pii(cnt,vec[pos]));\n                    pos++;\n                    Q.push(piii(v,pii(y,x)));\n                    continue;\n                }\n                used[y][x]=true;\n                cnt++;\n                for(int i=0;i<4;i++){\n                    int ty=y+dxy[i+1],tx=x+dxy[i];\n                    if(ty<0||ty>=h||tx<0||tx>=w)continue;\n                    Q.push(piii(fld[ty][tx],pii(ty,tx)));\n                }\n            }\n            ans[k].push_back(pii(cnt,vec[pos]));\n        }\n        //for(int i=0;i<ans[0].size();i++)printf(\"%d:%d\\n\",ans[0][i].first,ans[0][i].second);\n\n        int Min=1e9;\n        for(int i=0;i<ans[0].size();i++){\n            int to=r-ans[0][i].first;\n            int lb=0,ub=ans[1].size();\n            while(ub-lb>1){\n                int mid=(ub+lb)/2;\n                if(ans[1][mid].first>to)ub=mid;\n                else lb=mid;\n            }\n            int value=ans[0][i].first+ans[1][ub-1].first;\n            if(value>=r){\n                Min=min(Min,ans[0][i].second+ans[1][ub-1].second);\n               //printf(\"%d:%d->%d\\n\",ans[0][i].second,ans[1][ub-1].second,value);\n            }\n        }\n        printf(\"%d\\n\",Min);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint w,h,x,y,a[505][505],b[505][505],c[505][505];\n\npair<int,int> make_P(int ma,int mb){pair<int,int> ret; ret.first=ma; ret.second=mb; return ret;}\n\npair<int,pair<int,int>> make_PP(int ma,pair<int,int> mb){pair<int,pair<int,int>> ret; ret.first=ma; ret.second=mb; return ret;}\n\nbool f(pair<int,pair<int,int>> fx,pair<int,pair<int,int>> fy){return fx.first<=fy.first;}\n\nvoid ww(int wx,int wy){\n\tc[wx][wy]=1;\n\tif(b[wx][wy+1]==1&&c[wx][wy+1]==0)ww(wx,wy+1);\n\tif(b[wx][wy-1]==1&&c[wx][wy-1]==0)ww(wx,wy-1);\n\tif(b[wx+1][wy]==1&&c[wx+1][wy]==0)ww(wx+1,wy);\n\tif(b[wx-1][wy]==1&&c[wx-1][wy]==0)ww(wx-1,wy);\n}\n\nvector<int> els(vector<int> vp){\n\tvector<int> ret;\n\tint s=vp.size();\n\tret.push_back(vp[0]);\n\tfor(int i=1;i<s;i++){\n\t\tif(vp[i]!=vp[i-1])ret.push_back(vp[i]);\n\t}\n\treturn ret;\n}\n\nvector<pair<int,int>> office(){\n\tfor(int i=0;i<505;i++)for(int j=0;j<505;j++){b[i][j]=0; c[i][j]=0;}\n\tvector<pair<int,pair<int,int>>> v;\n\tfor(int i=1;i<=h;i++)for(int j=1;j<=h;j++)v.push_back(make_PP(a[i][j],make_P(i,j)));\n\tsort(v.begin(),v.end(),f);\n\t//v=els(v);\n\tvector<pair<int,int>> ret;\n\tret.push_back(make_P(0,0));\n\tint s=v.size();\n\tb[x][y]=1; c[x][y]=1;\n\tfor(int i=0;i<s;i++){\n\t\t/*for(int j=1;j<=h;j++)for(int k=1;k<=w;k++){\n\t\t\tif(a[j][k]==v[i]){\n\t\t\t\tb[j][k]=1;\n\t\t\t\tif(c[j][k+1]+c[j][k-1]+c[j+1][k]+c[j-1][k]!=0)ww(j,k);\n\t\t\t}\n\t\t}*/\n\t\tb[v[i].second.first][v[i].second.second]=1;\n\t\tif(c[v[i].second.first][v[i].second.second+1]+c[v[i].second.first][v[i].second.second-1]+c[v[i].second.first+1][v[i].second.second]+c[v[i].second.first-1][v[i].second.second]!=0)ww(v[i].second.first,v[i].second.second);\n\t\tint sum=0;\n\t\tfor(int j=1;j<=h;j++)for(int k=1;k<=w;k++)sum+=c[j][k];\n\t\tret.push_back(make_P(v[i].first,sum));\n\t}\n\treturn ret;\n}\n\nint main(){\nwhile(1){\n\tint r,s[2];\n\tscanf(\"%d\",&r);\n\tif(r==0)break;\n\tvector<pair<int,int>> vvp[2];\n\tfor(int i=0;i<=1;i++){\n\t\tfor(int k=0;k<505;k++)for(int j=0;j<505;j++)a[k][j]=0;\n\t\tscanf(\"%d%d%d%d\",&w,&h,&x,&y);\n\t\tfor(int j=1;j<=h;j++)for(int k=1;k<=w;k++)scanf(\"%d\",&a[j][k]);\n\t\tvvp[i]=office();\n\t\ts[i]=vvp[i].size();\n\t}\n\tint n=s[1]-1,ret=200000000;\n\tfor(int i=0;i<s[0];i++){\n\t\tif(n!=0)while(vvp[0][i].second+vvp[1][n-1].second>=r){n--; if(n==0)break;}\n\t\tif(vvp[0][i].second+vvp[1][n].second>=r)ret=min(ret,vvp[0][i].first+vvp[1][n].first);\n\t}\n\tprintf(\"%d\\n\",ret);\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef pair<int,pair<int,int> > PP;\nint r,w[2],h[2],x[2],y[2];\nlong long level[501][501][2];\nbool used[501][501][2]={};\nlong long sparklingdaydream[501][501][2];\nlong long need[250005][2]={};\nlong long s[250005]={},d[250005]={};\nint main(){\n    while(1){\n        memset(need,0,sizeof(need) );\n        memset(s,0,sizeof(s) );\n        memset(d,0,sizeof(d) );\n        memset(used,false,sizeof(used) );\n    priority_queue<PP,vector<PP>,greater<PP> >pque;\n    scanf(\"%d\",&r);\n    if(r==0) break;\n    scanf(\"%d %d %d %d\",&w[0],&h[0],&x[0],&y[0]);\n    for(int r=0;r<501;r++){\n        for(int g=0;g<501;g++){\n                sparklingdaydream[r][g][0]=1000000000000;\n                level[r][g][0]=1000000000000;\n            }\n        }\n    for(int i=1;i<=h[0];i++){\n        for(int j=1;j<=w[0];j++){\n            scanf(\"%lld\",&level[j][i][0]);\n        }\n    }\n    sparklingdaydream[x[0]][y[0]][0]=1;\n    pque.push(make_pair(sparklingdaydream[x[0]][y[0]][0],make_pair(x[0],y[0])));\n    int dx[3]={0,1,-1};\n    int dy[3]={0,1,-1};\n    while(!pque.empty()){\n        PP p=pque.top();\n        pque.pop();\n        used[p.second.first][p.second.second][0]=true;\n        for(int k=0;k<3;k++){\n            for(int l=0;l<3;l++){\n                if(k!=l && (k==0 || l==0)){\n                    if(!used[p.second.first+dx[k]][p.second.second+dy[l]][0]){\n                        if(p.second.first+dx[k]>=1 && p.second.first+dx[k]<=w[0] && p.second.second+dy[l]>=1 && p.second.second+dy[l]<=h[0]){\n                            long long h=p.first;\n                            sparklingdaydream[p.second.first+dx[k]][p.second.second+dy[l]][0]=max(h,level[p.second.first+dx[k]][p.second.second+dy[l]][0]);\n                            pque.push(make_pair(sparklingdaydream[p.second.first+dx[k]][p.second.second+dy[l]][0],make_pair(p.second.first+dx[k],p.second.second+dy[l])));\n                            used[p.second.first+dx[k]][p.second.second+dy[l]][0]=true;\n                        }\n                    }\n                    }\n                }\n            }\n        }\n    for(int r=0;r<501;r++){\n        for(int g=0;g<501;g++){\n                sparklingdaydream[r][g][1]=1000000000000;\n                level[r][g][1]=1000000000000;\n            }\n        }\n    scanf(\"%d %d %d %d\",&w[1],&h[1],&x[1],&y[1]);\n    for(int i=1;i<=h[1];i++){\n        for(int j=1;j<=w[1];j++){\n            scanf(\"%lld\",&level[j][i][1]);\n        }\n    }\n    sparklingdaydream[x[1]][y[1]][1]=1;\n    pque.push(make_pair(sparklingdaydream[x[1]][y[1]][1],make_pair(x[1],y[1])));\n    while(!pque.empty()){\n        PP p=pque.top();\n        pque.pop();\n        used[p.second.first][p.second.second][1]=true;\n        for(int k=0;k<3;k++){\n            for(int l=0;l<3;l++){\n                if(k!=l && (k==0 || l==0)){\n                    if(!used[p.second.first+dx[k]][p.second.second+dy[l]][1]){\n                        if(p.second.first+dx[k]>=1 && p.second.first+dx[k]<=w[1] && p.second.second+dy[l]>=1 && p.second.second+dy[l]<=h[1]){\n                            long long h=p.first;\n                            sparklingdaydream[p.second.first+dx[k]][p.second.second+dy[l]][1]=max(h,level[p.second.first+dx[k]][p.second.second+dy[l]][1]);\n                            pque.push(make_pair(sparklingdaydream[p.second.first+dx[k]][p.second.second+dy[l]][1],make_pair(p.second.first+dx[k],p.second.second+dy[l])));\n                            used[p.second.first+dx[k]][p.second.second+dy[l]][1]=true;\n                        }\n                    }\n                    }\n                }\n            }\n        }\n    int g=0;\n    for(int i=1;i<=w[0];i++){\n        for(int j=1;j<=h[0];j++){\n            s[g]=sparklingdaydream[i][j][0];\n            g++;\n        }\n    }\n    sort(s,s+g);\n    int eee=1;\n    for(int i=0;i<g;i++){\n        if(s[i]!=s[i+1]){\n            for(int j=eee;j<=i+1;j++){\n                need[j][0]=s[i];\n                eee=i+2;\n            }\n        }\n    }\n    g=0;\n    for(int i=1;i<=w[1];i++){\n        for(int j=1;j<=h[1];j++){\n            d[g]=sparklingdaydream[i][j][1];\n            g++;\n        }\n    }\n    sort(d,d+g);\n    eee=1;\n    for(int i=0;i<g;i++){\n        if(d[i]!=d[i+1]){\n            for(int j=eee;j<=i+1;j++){\n                need[j][1]=d[i];\n                eee=i+2;\n            }\n        }\n    }\n    long long ans=10000000000;\n    for(int i=1;i<250005;i++){\n        for(int j=0;j<2;j++){\n            if(!need[i][j]){\n            need[i][j]=10000000000000;\n            }\n        }\n    }\n    for(int i=0;i<=r;i++){\n        ans=min(ans,need[i][0]+need[r-i][1]);\n    }\n    printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n\n "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int, pair<int,int> >P;\n\nconst int INF = 1<<30;\n\nint R,H[2],W[2],X[2],Y[2];\nint G[2][512][512];\nint dy[]={0,-1,0,1},dx[]={-1,0,1,0};\nint L[2][100005];\n\nvoid C(int h, int w, int x, int y, int l[100005], int g[512][512]){\n\n  int vis[512][512];\n  memset(vis, -1, sizeof vis);\n  priority_queue<P, vector<P>, greater<P> >q;\n  q.push(make_pair(1, make_pair(y,x)));\n  vis[y][x] = 0;\n  for(int i=0;i<=R;i++) l[i] = INF;\n  l[0] = min(l[0], 0);\n\n  for(int i=1;i<=R && i<=h*w;i++){\n    P p = q.top(); q.pop();\n    l[i] = min(l[i],p.first);\n    int cy = p.second.first, cx = p.second.second;\n    for(int d=0;d<4;d++){\n      int ty=cy+dy[d],tx=cx+dx[d];\n      if(ty<0||ty>=h||tx<0||tx>=w||vis[ty][tx]!=-1) continue;\n      vis[ty][tx] = 0;\n      //      cout << g[ty][tx] << endl;\n      q.push(make_pair(max(g[ty][tx], l[i]), make_pair(ty, tx)));\n    }\n  }\n}\n\nint main(){\n  while(scanf(\"%d\", &R) && R){\n    for(int i=0;i<2;i++){\n      scanf(\"%d%d%d%d\", &W[i],&H[i],&X[i],&Y[i]); X[i]--; Y[i]--;\n      for(int j=0;j<H[i];j++) for(int k=0;k<W[i];k++) scanf(\"%d\", &G[i][j][k]);\n    }\n\n    for(int i=0;i<2;i++){\n      C(H[i],W[i],X[i],Y[i],L[i],G[i]);\n      //      for(int j=0;j<=R;j++) printf(\"%d \", L[i][j]); puts(\"\");\n    }\n\n    int res = INF;\n    for(int i=0;i<=R;i++) res = min(res, L[0][i] + L[1][R-i]);\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nvvint vv1;\nvvint vv2;\nvvint dp1;\nvvint dp2;\nint dd[]={1,0,-1,0,1};\nint w1,h1,x1,y1;\nint w2,h2,x2,y2;\nvoid foo1(int x,int y,int c){\n\tc=max(c,vv1[y][x]);\n\tif(dp1[y][x]<=c) return;\n\tdp1[y][x]=c;\n\trep(i,4){\n\t\tint yy=y+dd[i];\n\t\tint xx=x+dd[i+1];\n\t\tif(0<=xx&&xx<w1&&0<=yy&&yy<h1){\n\t\t\tfoo1(xx,yy,c);\n\t\t}\n\t}\n}\nvoid foo2(int x,int y,int c){\n\tc=max(c,vv2[y][x]);\n\tif(dp2[y][x]<=c) return;\n\tdp2[y][x]=c;\n\trep(i,4){\n\t\tint yy=y+dd[i];\n\t\tint xx=x+dd[i+1];\n\t\tif(0<=xx&&xx<w2&&0<=yy&&yy<h2){\n\t\t\tfoo2(xx,yy,c);\n\t\t}\n\t}\n}\nvoid mainmain(){\n\tint R;\n\twhile(cin>>R,R){\n\t\tmap<int,int> ma1;\n\t\tmap<int,int> ma2;\n\t\tcin>>w1>>h1>>x1>>y1;\n\t\tinitvv(vv1,h1,w1);\n\t\tinitvv(dp1,h1,w1,INF);\n\t\trep(i,h1){\n\t\t\trep(j,w1){\n\t\t\t\tcin>>vv1[i][j];\n\t\t\t}\n\t\t}\n\t\tcin>>w2>>h2>>x2>>y2;\n\t\tinitvv(vv2,h2,w2);\n\t\tinitvv(dp2,h2,w2,INF);\n\t\trep(i,h2){\n\t\t\trep(j,w2){\n\t\t\t\tcin>>vv2[i][j];\n\t\t\t}\n\t\t}\n\t\tfoo1(x1-1,y1-1,1);\n\t\tfoo2(x2-1,y2-1,1);\n\t\tcontinue;\n\t\trep(i,h1){\n\t\t\trep(j,w1){\n\t\t\t\tif(ma1.count(dp1[i][j])==0) ma1[dp1[i][j]]=0;\n\t\t\t\tma1[dp1[i][j]]++;\n\t\t\t}\n\t\t}\n\t\trep(i,h2){\n\t\t\trep(j,w2){\n\t\t\t\tif(ma2.count(dp2[i][j])==0) ma2[dp2[i][j]]=0;\n\t\t\t\tma2[dp2[i][j]]++;\n\t\t\t}\n\t\t}\n\t\tvector<pii> v1;\n\t\tvector<pii> v2;\n\t\tint t=0;\n\t\tv1.PB(pii(0,0));\n\t\tv2.PB(pii(0,0));\n\t\tfor(auto i:ma1){\n\t\t\tt+=i.S;\n\t\t\tv1.PB(pii(t,i.F));\n\t\t}\n\t\tt=0;\n\t\tfor(auto i:ma2){\n\t\t\tt+=i.S;\n\t\t\tv2.PB(pii(t,i.F));\n\t\t}\n\t\tint ans=INT_MAX;\n\t\trep(i,v1.size()){\n\t\t\tint tmp=v1[i].S;\n\t\t\tauto it=lower_bound(ALL(v2),pii(R-v1[i].F,0));\n\t\t\tif(it==v2.end()) continue;\n\t\t\tpii tt = *it;\n\t\t\t// cout<<v1[i].F<<\" \"<<v1[i].S<<\" \"<<tt.F<<\" \"<<tt.S<<endl;\n\t\t\tans=min(ans,tmp+tt.S);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<fstream>\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint r;\nint w[2],h[2];\nint x[2],y[2];\nint dx[4]={0,0,-1,1},dy[4]={1,-1,0,0};\nint field[2][501][501];\nbool used[2][501][501];\nint INF=200000000;\nint dp[2][100001];\nint ans;\n\nvoid dfs(int i,int sx,int sy){\n\tpriority_queue<PP , vector<PP> , greater<PP> > que;\n\tint fl=1;\n\tque.push(PP(field[i][sx][sy],P(sx,sy)));\n\tused[i][sx][sy]=true;\n\twhile(que.size()){\n\t\tPP q=que.top();que.pop();\n\t\tint c=q.first;\n\t\tint mx=q.second.first,my=q.second.second;\n\t\tdp[i][fl]=max(dp[i][fl-1],c);\n\t\tfl++;\n\t\tfor(int j=0;j<4;j++){\n\t\t\tint nx=mx+dx[j],ny=my+dy[j];\n\t\t\tif(nx>=0 && nx<w[i] && ny>=0 && ny<h[i] && used[i][nx][ny]==false){\n\t\t\t\tque.push(PP(field[i][nx][ny],P(nx,ny)));\n\t\t\t\tused[i][nx][ny]=true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\tint st2=1;\n\twhile(1){\n\t\tcin >> r;\n\t\tif(r==0)break;\n\t\tfor(int i=1;i<=100000;i++)dp[0][i]=dp[1][i]=INF;\n\t\tdp[0][0]=dp[1][0]=0;\n\t\tmemset(field,0,sizeof(field));\n\t\tmemset(used,false,sizeof(used));\n\t\tcin >> w[0] >> h[0] >> x[0] >> y[0];\n\t\tfor(int i=0;i<h[0];i++){\n\t\t\tfor(int j=0;j<w[0];j++){\n\t\t\t\tcin >> field[0][j][i];\n\t\t\t}\n\t\t}\n\t\tcin >> w[1] >> h[1] >> x[1] >> y[1];\n\t\tfor(int i=0;i<h[1];i++){\n\t\t\tfor(int j=0;j<w[1];j++){\n\t\t\t\tcin >> field[1][j][i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<2;i++)dfs(i,x[i]-1,y[i]-1);\n\t\tans=INF;\n\n\t\tfor(int i=0;i<=r;i++){\n\t\t\tans=min(ans,dp[0][i]+dp[1][r-i]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\n#include<map>\n#include<vector>\nusing namespace std;\n#define INF (1<<24)\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nstruct state {\n  int y,x,cost;\n  bool operator < (const state &p)const{\n    return cost > p.cost; \n  }\n};\n\nint R;\nint th,tw,uh,uw,ty,tx,uy,ux;\nint t[500][500],u[500][500];\nint T[100000],U[100000];\nint d[500][500];\nvector<int> G;\nmap<int,int> g;\n\nvoid compute(int a[500][500],int H,int W,int sy,int sx,int v[100000]){\n  for(int i=0;i<500;i++)for(int j=0;j<500;j++)d[i][j]=INF;\n  priority_queue<state> Q;\n  Q.push((state){sy,sx,1});\n  d[sy][sx]=1;\n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    if(d[s.y][s.x]<s.cost)continue;\n    v[g[s.cost]]++;\n    for(int i=0;i<4;i++){\n      int ny=s.y+dy[i],nx=s.x+dx[i];\n      if(ny<0||nx<0)continue;\n      if(ny>=H||nx>=W)continue;\n      int ncost=max(a[ny][nx],s.cost);\n      if(d[ny][nx]<=ncost)continue;\n      d[ny][nx]=ncost;\n      Q.push((state){ny,nx,ncost});\n    }\n  }\n}\n\nvoid solve(){\n  sort(G.begin(),G.end());\n  G.erase(unique(G.begin(),G.end()),G.end());\n  for(int i=0;i<(int)G.size();i++)g[G[i]]=i;\n  compute(t,th,tw,ty,tx,T);\n  compute(u,uh,uw,uy,ux,U);\n  int size=G.size();\n  for(int i=0;i<size;i++){\n    if(i)T[i]+=T[i-1];\n    if(i)U[i]+=U[i-1];\n    //cout<<T[i]<<\" \"<<U[i]<<\" \"<<G[i]<<endl;\n  }\n\n  int ans=INF;\n  for(int i=0;i<size;i++){\n    int target=R-T[i];\n    int* it=lower_bound(U,U+size,target);\n    if(it==U+size)continue;\n    ans=min(ans,G[i]+G[it-U]);\n  }\n  cout<<ans<<endl;\n}\n\nvoid init(){\n  G.clear();\n  g.clear();\n  G.push_back(0);\n  for(int i=0;i<100000;i++)\n    T[i]=U[i]=0;\n}\n\nint main(){\n  while(cin>>R,R){    \n    init();\n    cin>>tw>>th>>tx>>ty;\n    ty--,tx--;\n    for(int i=0;i<th;i++){\n      for(int j=0;j<tw;j++){\n\tcin>>t[i][j];\n\tG.push_back(t[i][j]);\n      }\n    }\n    cin>>uw>>uh>>ux>>uy;\n    uy--,ux--;\n    for(int i=0;i<uh;i++){\n      for(int j=0;j<uw;j++){\n\tcin>>u[i][j];\n\tG.push_back(u[i][j]);\n      }\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, -1, 0, 1};\n\nconst int INF = (int)1e9;\n\ninline vector<pii> func(){\n\tint w, h, x, y;\n\tscanf(\"%d%d%d%d\", &w, &h, &x, &y);\n\t\n\tvector<vector<int> > L(w + 2, vector<int>(h + 2, -1));\n\tvector<int> Ls;\n\tLs.reserve(w * h + 2);\n\tLs.push_back(0);\n\tLs.push_back(INF);\n\t\n\tfor(int i = 1; i <= h; ++i)\n\tfor(int j = 1; j <= w; ++j){\n\t\tscanf(\"%d\", &L[j][i]);\n\t\tLs.push_back(L[j][i]);\n\t}\n\t\n\tsort(Ls.begin(), Ls.end());\n\tLs.erase(unique(Ls.begin(), Ls.end()), Ls.end());\n\t\n\tvector<pii> c(Ls.size());\n\tfor(int i = 0; i < Ls.size(); ++i){\n\t\tc[i].second = Ls[i];\n\t}\n\n\tpriority_queue<pii,vector<pii>,greater<pii> > pq;\n\tpq.push( pii(1, x << 16 | y) );\n\tL[x][y] = -1;\n\t\n\twhile( !pq.empty() ){\n\t\tqueue<int> q;\n\t\tq.push(pq.top().second);\n\t\tint u = pq.top().first;\n\t\tpq.pop();\n\n\t\tint k = lower_bound(Ls.begin(), Ls.end(), u) - Ls.begin();\n\t\t++c[k].first;\n\n\t\twhile( !q.empty() ){\n\t\t\tfor(int i = 0; i < 4; ++i){\n\t\t\t\tx = (q.front() >> 16) + dx[i];\n\t\t\t\ty = (q.front() & 0xff) + dy[i];\n\n\t\t\t\tif( L[x][y] > 0 ){\n\t\t\t\t\tif( L[x][y] <= u ){\n\t\t\t\t\t\tL[x][y] = -1;\n\t\t\t\t\t\t++c[k].first;\n\t\t\t\t\t\tq.push(x << 16 | y);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpq.push( pii(L[x][y], x << 16 | y) );\n\t\t\t\t\t\tL[x][y] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tq.pop();\n\t\t}\n\t}\n\t\n\tfor(int i = 2; i < c.size(); ++i){\n\t\tc[i].first += c[i - 1].first;\n\t}\n\tc.back().first = INF;\n\t\n\treturn c;\n}\n\nint main(){\n\tint R;\n\twhile( scanf(\"%d\", &R), R != 0 ){\n\t\tvector<pii> t1 = func();\n\t\tvector<pii> t2 = func();\n\n\t\tint ans = INF;\n\t\tfor(int i = 0; i <= R; ++i){\n\t\t\tint a = t1[i].second;\n\t\t\tpii p = pii(R - t1[i].first, -1);\n\t\t\tint b = lower_bound(t2.begin(), t2.end(), p)->second;\n\t\t\tans = min(ans, a + b);\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n\nusing namespace std;\ntypedef pair<int,pair<int,int> > P;\ntypedef long long ll;\n\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\n\nint w[2],h[2],x[2],y[2];\nint r;\nint field[2][501][501];\nbool passed[501][501];\nmap<ll,int> visitableRooms[2];\n\nint INF=1000000000;\n\nvoid bfs(int k,int sx,int sy){\n    // FØx1©çÔÉTõ\n    priority_queue<P,vector<P>,greater<P> > pq;\n    pq.push(make_pair(1,make_pair(sy,sx)));\n    // »ÝÌx\n    ll cL=0;\n    // Kê½®Ì\n    int sum=0;\n    passed[sy][sx]=true;\n    while(pq.size()){\n        P p=pq.top();\n        pq.pop();\n        ll level=p.first;\n        int cx=p.second.second;\n        int cy=p.second.first;\n        sum++;\n        // »ÝÌxðXV·éKvª êÎAXV·é\n        if(level>cL)\n            cL=level;\n        visitableRooms[k][cL]=sum;\n        for(int i = 0; i < 4; i++){\n            int ny=cy+dy[i];\n            int nx=cx+dx[i];\n            if(ny>=0&&nx>=0&&ny<h[k]&&nx<w[k]&&!passed[ny][nx]){\n                pq.push(P(field[k][ny][nx],make_pair(ny,nx)));\n                passed[ny][nx]=true;\n            }\n        }\n    }\n    if(visitableRooms[k].find(cL)==visitableRooms[k].end())\n        visitableRooms[k][cL]=sum;\n}\n\nint main(){\n    while(cin>>r&&r!=0){\n        for(int k = 0; k < 2; k++){\n            visitableRooms[k].clear();\n            cin>>w[k]>>h[k]>>x[k]>>y[k];\n            x[k]--;y[k]--;\n            for(int i = 0; i < h[k]; i++)\n                for(int j = 0; j < w[k]; j++)\n                    cin>>field[k][i][j];\n        }\n        for(int k = 0; k < 2; k++){\n            visitableRooms[k][0]=0;\n            memset(passed,0,sizeof(passed));\n            bfs(k,x[k],y[k]);\n        }\n        map<ll,int>::iterator ait=visitableRooms[0].begin();\n        map<ll,int>::iterator bit=visitableRooms[1].end();\n        bit--;\n        int minLevelSum=INF;\n        // »ê¼êÌiteratorð®©·\n        while(1){\n            int roomSum=(ait->second)+(bit->second);\n            if(roomSum>=r){\n                minLevelSum=min(minLevelSum,(int)(ait->first+bit->first));\n                if(bit==visitableRooms[1].begin())\n                    break;\n                bit--;\n            }\n            else{\n                ait++;\n                if(ait==visitableRooms[0].end())\n                    break;\n            }\n        }\n        cout<<minLevelSum<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int INF = (1<<29);\nint r,h,w,rx,ry,a[500][500],minl,cntr,nowl;\nint dy[] = {0,1,0,-1};\nint dx[] = {1,0,-1,0};\nbool f[500][500];\nvector<int> numr[2],numl[2];\n\nbool check(int y, int x){\n  if(y < 0 || y >= h) return false;\n  if(x < 0 || x >= w) return false;\n  return true;\n}\n\nvoid dfs(int y, int x){\n  f[y][x] = true;\n  cntr++;\n  for(int i=0;i<4;i++){\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if(check(ny,nx) && !f[ny][nx]){\n      if(a[ny][nx] <= nowl) dfs(ny,nx);\n      else minl = min(minl,a[ny][nx]);\n    }\n  }\n}\n\nvoid solve(int k){\n  nowl = 1;\n  numr[k].clear();\n  numl[k].clear();\n  while(1){\n    fill(f[0],f[500],false);\n    cntr = 0;\n    minl = INF;\n    dfs(ry,rx);\n    numr[k].push_back(cntr);\n    numl[k].push_back(nowl);\n    if(cntr == h * w) return;\n    nowl = minl;\n  }\n}\n\nint main(){\n  while(cin >> r && r){\n    int ans = INF;\n    for(int k=0;k<2;k++){\n      cin >> w >> h >> rx >> ry;\n      rx--;\n      ry--;\n      for(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++)\n\t  cin >> a[i][j];\n      solve(k);\n    }\n    for(int i=0;i<numr[0].size();i++){\n      if(numr[0][i] >= r){\n\tans = min(numl[0][i],ans);\n\tbreak;\n      }\n      int cnt = r - numr[0][i];\n      int pos = lower_bound(numr[1].begin(), numr[1].end(), cnt) - numr[1].begin();\n      if(pos < numr[1].size()) ans = min(ans,numl[0][i] + numl[1][pos]);\n      else if(numr[0][i] + numr[1][numl[1].size()-1] >= r) ans = min(ans,numl[0][i] + numl[1][numl[1].size()-1]);\n    }\n    int pos = lower_bound(numr[1].begin(), numr[1].end(), r) - numr[1].begin();\n    if(pos < numr[1].size()) ans = min(ans,numl[1][pos]);\n    else if(numr[1][numl[1].size()-1] >= r) ans = min(ans,numl[1][numl[1].size()-1]);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF (1<<29)\n\nstruct State {\n    int c, x, y;\n    \n    State (int c, int x, int y) : c(c), x(x), y(y) {}\n\n    bool operator < (const State &s) const {\n        return c > s.c;\n    }\n};\n\nint main()\n{\n    int R;\n    while (cin >> R, R) {\n        int W, H, sy, sx;\n        vector<int> level[2];\n        for (int i = 0; i < 2; i++) {\n            cin >> W >> H >> sx >> sy;\n            sy--; sx--;\n            vector<vector<int>> a(H, vector<int>(W));\n            for (int i = 0; i < H; i++) {\n                for (int j = 0; j < W; j++) {\n                    cin >> a[i][j];\n                }\n            }\n\n            vector<vector<bool>> visited(H, vector<bool>(W, 0));\n            visited[sy][sx] = 1;\n            \n            priority_queue<State> pq;\n            pq.push(State(a[sy][sx], sx, sy));\n\n            level[i].push_back(0);\n\n            const int dx[] = {-1, +0, +1, +0};\n            const int dy[] = {+0, -1, +0, +1};\n            int maxi = 0;\n            \n            while (!pq.empty()) {\n                State st = pq.top(); pq.pop();\n                level[i].push_back(max(maxi, st.c));\n                maxi = max(maxi, st.c);\n                for (int j = 0; j < 4; j++) {\n                    int nx = st.x + dx[j];\n                    int ny = st.y + dy[j];\n                    if (0 <= nx && nx < W && 0 <= ny && ny < H &&\n                        !visited[ny][nx]) {\n                        visited[ny][nx] = 1;\n                        pq.push(State(a[ny][nx], nx, ny));\n                    }\n                }\n            }\n        }\n        \n        int res = INF;\n        for (int i = 0; i <= R; i++) {\n            int j = R - i;\n            if ((int)level[0].size() <= i) continue;\n            if ((int)level[1].size() <= j) continue;\n            res = min(res, level[0][i] + level[1][j]);\n        }\n        cout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\n\nint x[2],y[2],w[2],h[2];\nint R;\nvector<vvi> zimu;\n\nvoid dfs(int i, int x, int y, vvi& used, vector<pair<int,int>>& list){\n\n  priority_queue< pair<int,pii>, vector<pair<int,pii> >,greater<pair<int,pii> > > que;\n  que.push(pair<int,pii>(1,pii(x,y)));\n\n  int auth = 0;\n  int room = 0;\n  while(que.size()){\n    int corr_lev = que.top().first;\n    int corr_x = que.top().second.first;\n    int corr_y = que.top().second.second;\n    //cout << \"POP (\" << corr_x << \",\" << corr_y <<\") \" << corr_lev << endl; \n    que.pop();\n    if( used[corr_y][corr_x] == 1) continue;\n    used[corr_y][corr_x] = 1;\n    \n    if(corr_lev > auth){\n      list.push_back(pii(room,auth));\n      auth = corr_lev;\n    }\n    room++;\n    if( room == w[i]*h[i] ) break;\n\n\n    for(int j=0; j<4; j++){\n      int nx = corr_x + dx[j];\n      int ny = corr_y + dy[j];\n      if(nx >= w[i] || nx < 0 || ny >= h[i] || ny < 0) continue; // ????£?\n      if(used[ny][nx] == 1) continue; // ??¢?´¢??????\n      que.push( pair<int,pii>(zimu[i][ny][nx],pii(nx,ny)) );\n      //cout << \"  PUSH (\" << nx << \",\" << ny << \") \" << zimu[i][ny][nx] << endl; \n    }\n  }\n  list.push_back(pii(room,auth));\n}\n\nint main(){\n  while(1){\n  \n    cin >> R; if(!R) break;\n    zimu.clear();\n    \n    // ??\\???\n    for(int i=0; i<2; i++){\n      cin >> w[i] >> h[i] >> x[i] >> y[i];\n  \n      zimu.push_back(vvi(h[i],vi(w[i])));\n\n      for(int j=0; j<h[i]; j++)\n\tfor(int k=0; k<w[i]; k++)\n\t  cin >> zimu[i][j][k];\n    }\n\n    // \n    vector<vector<pair<int,int> > > list(2); // ???????????¨?±???°???????¨???¬??????\n    \n    for(int i=0; i<2; i++){\n      list[i].push_back(pii(0,0));\n      vvi used(h[i],vi(w[i],0));\n      dfs(i, x[i]-1, y[i]-1, used, list[i]);\n    }\n    /*\n    for(int i=0; i<2; i++){\n      for(int j=0; j<list[i].size(); j++)\n\tcout << \"(\" << list[i][j].first << \",\" << list[i][j].second << \"), \";\n      cout << endl;\n      }*/\n    \n\n    int ans = 1e+9;\n    for(int i=0; i<list[0].size(); i++){\n      int rooma = list[0][i].first;\n      int autha = list[0][i].second;\n      pii tmp = *lower_bound(list[1].begin(),list[1].end(), pii(R-rooma,0));\n      int roomb = tmp.first;\n      int authb = tmp.second;\n      if(rooma + roomb < R) continue;\n      ans = min(ans,autha + authb);\n    }\n    cout << ans << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\ntypedef pair< int, int > Pi;\ntypedef pair< int, Pi > Pii;\nconst int INF = 1 << 29;\nconst int dy[] = {0, 1, 0, -1}, dx[] = {1, 0, -1, 0};\n \nstruct Field\n{\n  int W, H, X, Y;\n  int L[500][500];\n};\n \nvoid InputField(Field& e)\n{\n  cin >> e.W >> e.H >> e.X >> e.Y;\n  --e.X, --e.Y;\n  for(int i = 0; i < e.H; i++) {\n    for(int j = 0; j < e.W; j++) {\n      cin >> e.L[i][j];\n    }\n  }\n}\n// ????\nint BFSField(const Field& e, vector< int >& cost)\n{\n  priority_queue< Pii, vector< Pii >, greater< Pii > > que;\n  que.push({1, make_pair(e.X, e.Y)});\n  int min_cost[500][500];\n  fill_n(*min_cost, 500 * 500, INF);\n  min_cost[e.X][e.Y] = 1;\n  map< int, int > cur;\n  while(!que.empty()) {\n    Pi point = que.top().second;\n    int c = que.top().first;\n    que.pop();\n    if(c > min_cost[point.first][point.second]) continue;\n    cur[c]++;\n    for(int i = 0; i < 4; i++) {\n      int ny = point.second + dy[i], nx = point.first + dx[i];\n      if(ny < 0 || nx < 0 || ny >= e.H || nx >= e.W) continue;\n      if(min_cost[nx][ny] > max(c, e.L[ny][nx])) {\n        min_cost[nx][ny] = max(c, e.L[ny][nx]);\n        que.push({min_cost[nx][ny], Pi(nx, ny)});\n      }\n    }\n  }\n   \n  // ????????????????????\\?????????????????????\n  cost.assign(e.W * e.H + 1, INF);\n  int sum = 0;\n  cost[0] = 0;\n  for(auto e : cur) {\n    sum += e.second;\n    cost[sum] = e.first;\n  }\n  for(int i = cost.size() - 2; i >= 0; i--) {\n    cost[i] = min(cost[i + 1], cost[i]);\n  }\n  /*\n  for(int i = 0; i < cost.size(); i++) {\n    cout << cost[i] << endl;\n  }\n  */\n}\n \nint main()\n{\n  int R;\n  Field A, B;\n \n  cin >> R;\n  InputField(A);\n  InputField(B);\n  vector< int > a, b;\n  BFSField(A, a);\n  BFSField(B, b);\n   \n  int ret = INF;\n  for(int i = 0; i < a.size(); i++) {\n    if(R - i >= 0 && R - i < b.size()) {\n      ret = min(ret, a[i] + b[R - i]);\n    }\n  }\n   \n  cout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (1) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nstruct state {\n\tint sx, sy, cost;\n};\nbool operator<(const state& s1, const state& s2) {\n\treturn s1.cost < s2.cost;\n}\nint R, H[2], W[2], sx[2], sy[2], a[2][509][509], cnt[2], b[2][250009]; bool vis[509][509];\nint dir[] = { 0, 1, 0, -1 };\nint main() {\n\twhile (scanf(\"%d\", &R), R) {\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tscanf(\"%d%d%d%d\", &W[i], &H[i], &sy[i], &sx[i]); sy[i]--, sx[i]--;\n\t\t\tfor (int j = 0; j < H[i]; j++) {\n\t\t\t\tfor (int k = 0; k < W[i]; k++) {\n\t\t\t\t\treader(&a[i][j][k]);\n\t\t\t\t\tvis[j][k] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpriority_queue<state> que; que.push(state{ sx[i], sy[i], -1 });\n\t\t\tvis[sx[i]][sy[i]] = true; cnt[i] = 1;\n\t\t\twhile (!que.empty()) {\n\t\t\t\tstate u = que.top(); que.pop();\n\t\t\t\tb[i][cnt[i]++] = a[i][u.sx][u.sy];\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tint tx = u.sx + dir[j], ty = u.sy + dir[j ^ 1];\n\t\t\t\t\tif (0 <= tx && tx < H[i] && 0 <= ty && ty < W[i] && !vis[tx][ty]) {\n\t\t\t\t\t\ta[i][tx][ty] = max(a[i][tx][ty], a[i][u.sx][u.sy]);\n\t\t\t\t\t\tvis[tx][ty] = true;\n\t\t\t\t\t\tque.push(state{ tx, ty, -a[i][tx][ty] });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 2000000009;\n\t\tfor (int i = 0; i <= H[0] * W[0]; i++) {\n\t\t\tint z = max(R - i, 0);\n\t\t\tif (z > H[1] * W[1]) continue;\n\t\t\tret = min(ret, b[0][i] + b[1][z]);\n\t\t}\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\n\nvector<int> calc_required_level_to_rooms()\n{\n\tint w, h, sx, sy;\n\tstatic int req[512][512];\n\tcin >> w >> h >> sx >> sy;\n\t--sx, --sy;\n\tfor (int y = 0; y < h; ++y)\n\t\tfor (int x = 0; x < w; ++x)\n\t\t\tcin >> req[y][x];\n\n\n\tstatic int min_level[512][512];\n\tfor (int y = 0; y < h; ++y)\n\t\tfor (int x = 0; x < w; ++x)\n\t\t\tmin_level[y][x] = 1e9;\n\n\tvector<int> res;\n\tmin_level[sy][sx] = 1;\n\tres.push_back(0);\n\n\ttypedef pair<int, pint> P;\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tq.push(P(1, pint(sx, sy)));\n\twhile (res.size() <= w * h)\n\t{\n\t\tP tt = q.top(); q.pop();\n\t\tint level = tt.first;\n\t\tint x = tt.second.first, y = tt.second.second;\n\t\tif (level > min_level[y][x])\n\t\t\tcontinue;\n\n\t\tres.push_back(level);\n\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\t\tif (valid_pos(tx, ty, w, h))\n\t\t\t{\n\t\t\t\tint nl = max(level, req[ty][tx]);\n\t\t\t\tif (nl < min_level[ty][tx])\n\t\t\t\t{\n\t\t\t\t\tq.push(P(nl, pint(tx, ty)));\n\t\t\t\t\tmin_level[ty][tx] = nl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tint r;\n\twhile (cin >> r, r)\n\t{\n\t\tvector<int> a = calc_required_level_to_rooms();\n\t\tvector<int> b = calc_required_level_to_rooms();\n\n\t\tint res = 1e9;\n\t\tfor (int i = min<int>(r, a.size() - 1); i >= 0 && r - i < b.size(); --i)\n\t\t\tmin_swap(res, a[i] + b[r - i]);\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int, pair<int,int> >P;\n\nconst int INF = 1<<30;\n\nint R,H[2],W[2],X[2],Y[2];\nint G[2][512][512];\nint dy[]={0,-1,0,1},dx[]={-1,0,1,0};\nint L[2][10005];\n\nvoid C(int h, int w, int x, int y, int l[10005], int g[512][512]){\n  int vis[512][512];\n  memset(vis, -1, sizeof vis);\n  priority_queue<P, vector<P>, greater<P> >q;\n  q.push(make_pair(1, make_pair(y,x)));\n  vis[y][x] = 0;\n  for(int i=0;i<=R;i++) l[i] = INF;\n  l[0] = min(l[0], 0);\n  for(int i=1;i<=R && i<=h*w;i++){\n    P p = q.top(); q.pop();\n    l[i] = min(l[i],p.first);\n    int cy = p.second.first, cx = p.second.second;\n    for(int d=0;d<4;d++){\n      int ty=cy+dy[d],tx=cx+dx[d];\n      if(ty<0||ty>=h||tx<0||tx>=w||vis[ty][tx]!=-1) continue;\n      vis[ty][tx] = 0;\n      //      cout << g[ty][tx] << endl;\n      q.push(make_pair(max(g[ty][tx], l[i]), make_pair(ty, tx)));\n    }\n  }\n}\n\nint main(){\n  while(scanf(\"%d\", &R) && R){\n    for(int i=0;i<2;i++){\n      scanf(\"%d%d%d%d\", &W[i],&H[i],&X[i],&Y[i]); X[i]--; Y[i]--;\n      for(int j=0;j<H[i];j++) for(int k=0;k<W[i];k++) scanf(\"%d\", &G[i][j][k]);\n    }\n\n    for(int i=0;i<2;i++){\n      C(H[i],W[i],X[i],Y[i],L[i],G[i]);\n      //      for(int j=0;j<=R;j++) printf(\"%d \", L[i][j]); puts(\"\");\n    }\n    int res = INF;\n    for(int i=0;i<=R;i++) res = min(res, L[0][i] + L[1][R-i]);\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define PB push_back\n#define ALL(V) V.begin(), V.end()\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, int> ppiii;\n\nconstexpr int INF = 1LL<<60;\nconstexpr int MOD = 1000000007;\n//constexpr int MAX_N = 100005;\nconstexpr int dx[] = {-1, 0, 1, 0};\nconstexpr int dy[] = {0, -1, 0, 1};\n\nint r, w[2], h[2], ex[2], ey[2], fld[2][505][505], d[2][505][505];\n\nvector<pii> lvs[2];\nvector<int> templvs[2];\n\nvoid Dijkstra(int k) {\n    fill(d[k][0], d[k][505], INF);\n    priority_queue<pipii, vector<pipii>, greater<pipii>> pq;\n    d[k][ex[k]][ey[k]] = 1;\n    pq.push({1, {ex[k], ey[k]}});\n\n    while (pq.size()) {\n        pipii p = pq.top();\n        pq.pop();\n        int x = p.second.first, y = p.second.second;\n        if (d[k][x][y] < p.first) continue;\n\n        for (int i = 0; i < 4; ++i) {\n            int tx = x + dx[i], ty = y + dy[i], lv = max(p.first, fld[k][tx][ty]);\n            if (fld[k][tx][ty] == 0) continue;\n            if (d[k][tx][ty] <= lv) continue;\n            d[k][tx][ty] = lv;\n            pq.push({lv, {tx, ty}});\n        }\n    }\n}\n\nbool Solve() {\n    cin >> r;\n    if (r == 0) return false;\n    memset(fld, 0, sizeof(fld));\n\n    for (int i = 0; i < 2; ++i) {\n        cin >> w[i] >> h[i] >> ex[i] >> ey[i]; \n\n        for (int y = 1; y <= h[i]; ++y) {\n            for (int x = 1; x <= w[i]; ++x) {\n                cin >> fld[i][x][y];\n            }\n        }\n    }\n\n    Dijkstra(0);\n    Dijkstra(1);\n\n    for (int i = 0; i < 2; ++i) {\n        lvs[i].clear();\n        templvs[i].clear();\n\n        for (int y = 1; y <= h[i]; ++y) {\n            for (int x = 1; x <= w[i]; ++x) {\n                templvs[i].PB(d[i][x][y]);\n            }\n        }\n\n        sort(ALL(templvs[i]));\n        templvs[i].PB(INF);\n        lvs[i].PB({0, 0});\n        for (int j = 0; j < templvs[i].size(); ++j) {\n            for (int c = 1; j + c <= templvs[i].size(); ++c) {\n                if (templvs[i][j + c - 1] == templvs[i][j]) continue;\n                c--;\n                lvs[i].PB({c + lvs[i][lvs[i].size() - 1].first, templvs[i][j]});\n                j += c - 1;\n                break;\n            }\n        }\n        lvs[i].PB({INF, INF});\n    }\n\n    int ans = INF;\n    for (int i = 0; i < lvs[0].size(); ++i) {\n        int cnt = lvs[0][i].first;\n        if (cnt + w[1] * h[1] < r) continue;\n        \n        auto s = upper_bound(ALL(lvs[1]), pii(r - cnt - 1, INF));\n        if (s == lvs[1].end()) continue; \n        ans = min(ans, lvs[0][i].second + s->second);\n    }\n\n    cout << ans << endl;\n\n    return true;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while(Solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <iterator>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <cmath>\n#include <complex>\n#include <functional>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <cstdlib>\n#include <cctype>\n\n#define REP(i,m,n) for(int i=m;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rp(i,c) rep(i,(int)c.size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define v_delete(a,b) (a).erase(remove((a).begin(), (a).end(), b), (a).end())\n#define v_unique(a) (a).erase(unique((a).begin(), (a).end()), (a).end())\n#define VV(T) vector<vector< T > >\n#define init(a,b) memset((a), (b), sizeof((a)))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double EPS=1e-9;\nconst long long INF = 100001000010000100ll;\n\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntypedef pair<int,int> pii;\n\nint R;\nint W[2], H[2], X[2], Y[2];\n\nint m[4][500+10][500+10];\nint visited[2][500+10][500+10];\n\nint wa[2][500*500+10];\n\nvi ls;\n\nmap<int ,int> cnt[2];\n\nbool exists(const map<int ,int> &mapp, int key){\n\treturn mapp.find(key) != mapp.end();\n}\n\nint dx[]={1,0,0,-1};\nint dy[]={0,1,-1,0};\n\nclass BIT{\nprivate:\n\tvi bit;\n\tint n;\npublic:\n\tBIT(int _n){\n\t\tn = _n;\n\t\tbit.assign(n+1,0 );\n\t}\n\tvoid add(int i, int x){\n\t\twhile(i <= n){\n\t\t\tbit[i] += x;\n\t\t\ti += (i & -i);\n\t\t}\n\t}\n\tint sum(int i){\n\t\tint s = 0;\n\t\twhile(i > 0){\n\t\t\ts += bit[i];\n\t\t\ti -= (i & -i);\n\t\t}\n\t\treturn s;\n\t}\n};\n\n\nint main(){\n\twhile(cin >> R){\n\n\t\tmemset(visited, 0, sizeof(visited));\n\n\t\tmemset(wa, 0, sizeof(wa));\n\n\t\tls.clear();\n\n\t\tfill_n(**m, 4 * (500+10) * (500+10), inf);\n\n\t\trep(c, 2){\n\t\t\tcin >> W[c] >> H[c] >> X[c] >> Y[c];\n\t\t\trep(i, H[c]){\n\t\t\t\trep(j, W[c]){\n\t\t\t\t\tcin >> m[c][i+1][j+1];\n\t\t\t\t\tls.pb(m[c][i+1][j+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tls.pb(0);\n\t\tls.pb(inf);\n\t\tsort(all(ls));\n\t\tls.erase(unique(all(ls)), ls.end());\n\t\trep(c, 2){\n\t\t\tpriority_queue<pair<int, pii>, vector<pair<int, pii> >, greater<pair<int, pii> > >Q;\n\t\t\tQ.push(mp(1, mp(X[c], Y[c])));\n\t\t\twhile(!Q.empty()){\n\t\t\t\tint x,y,level;\n\t\t\t\tx=Q.top().second.first;y=Q.top().second.second;level=Q.top().first;\n\t\t\t\tQ.pop();\n\t\t\t\tif(visited[c][y][x]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tvisited[c][y][x] = 1;\n\n\t\t\t\tif(level > m[c][y][x]){\n\t\t\t\t\tm[c][y][x] = level;\n\t\t\t\t}else{\n\t\t\t\t\tlevel = m[c][y][x];\n\t\t\t\t}\n\t\t\t\t//printf(\"%d %d %d %d\\n\",c, x, y, level);\n\t\t\t\trep(k, 4){\n\t\t\t\t\tif(m[c][y+dy[k]][x+dx[k]]!=inf){\n\t\t\t\t\t\tif(!visited[c][y+dy[k]][x+dx[k]]){\n\t\t\t\t\t\t\tQ.push(mp(max(m[c][y+dy[k]][x+dx[k]], level), mp(x+dx[k], y+dy[k])));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}/*\n\t\trep(c, 2){\n\t\t\trep(i, H[c]){\n\t\t\t\trep(j, W[c]){\n\t\t\t\t\tcout <<  m[c][i+1][j+1] << \" \";\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\tcout << endl;\n\t\t\tcout << endl;\n\t\t}*/\n\t\trep(c, 2){\n\t\t\trep(i, H[c]){\n\t\t\t\trep(j, W[c]){\n\t\t\t\t\tint ma=-1;\n\t\t\t\t\tint tmp=inf;\n\t\t\t\t\t/*\n\t\t\t\t\trep(k, 4){\n\t\t\t\t\t\ttmp=min(tmp, m[c][i + 1 + dx[k]][j + 1 + dy[k]]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i + 1 == Y[c] && j + 1 == X[c]){\n\t\t\t\t\t\tma=m[c][i + 1][j + 1];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tma = max(m[c][i + 1][j + 1], tmp);\n\t\t\t\t\t}*/\n\t\t\t\t\tma=m[c][i + 1][j + 1];\n\t\t\t\t\tint l = lower_bound(all(ls), ma) - ls.begin();\n\t\t\t\t\twa[c][l]++;\n\n\t\t\t\t}\n\t\t\t}\n\t\t\trp(i, ls){\n\t\t\t\tif(i - 1 >= 0)\n\t\t\t\t\twa[c][i] = wa[c][i - 1] + wa[c][i];\n\t\t\t}\n\n\t\t}\n\t\t/*\n\t\trep(c, 2){\n\t\t\trp(i, ls){\n\t\t\t\tcout << ls[i] << \" \" << wa[c][i] << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\tcout << endl;\n\t\t}*/\n\t\tint ans=inf;\n\t\trp(i, ls){\n\n\t\t\tint l=lower_bound(wa[1],(wa[1]+(int)ls.size()) , R - wa[0][i]) - wa[1];\n\t\t\tif(l < ls.size())\n\t\t\tif(wa[0][i] + wa[1][l] >= R){\n\t\t\t\t//cout << ls[i] << \" \" << ls[l] << endl;\n\t\t\t\tans=min(ans, ls[i] + ls[l]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <queue>\n\nusing namespace std;\n\nconst int N = 500;\nconst int INF = 1000000000;\n\nclass S{\npublic:\n  int x, y, cost;\n  S(){}\n  S(int x, int y, int cost) : x(x), y(y), cost(cost) {}\n};\n\nint R, w[2], h[2], sx[2], sy[2], input[2][N][N], vis[N][N];\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nvector<int> vec[2];\nset<int> data;\n\nvoid bfs(int x, int y, int cost, int d){\n  queue<S> q;\n  S u;\n  q.push(S(x, y, cost));\n  vis[y][x] = cost;\n  while(!q.empty()){\n    u = q.front(); q.pop();\n    for(int i=0;i<4;i++){\n      int ny = u.y + dy[i];\n      int nx = u.x + dx[i];\n      if(ny < 0 || ny >= h[d]) continue;\n      if(nx < 0 || nx >= w[d]) continue;\n      if(vis[ny][nx] > max(u.cost, input[d][ny][nx])){\n        vis[ny][nx] = max(u.cost, input[d][ny][nx]);\n        q.push(S(nx, ny, max(u.cost, input[d][ny][nx])));\n      }\n    }\n  }\n}\n\nvoid init(){\n  data.clear();\n  for(int k=0;k<2;k++){\n    for(int i=0;i<h[k];i++){\n      for(int j=0;j<w[k];j++){\n        data.insert(input[k][i][j]);\n      }\n    }\n  }\n  for(int k=0;k<2;k++){\n    fill(vis[0], vis[N], INF);\n    bfs(sx[k], sy[k], 1, k);\n    vec[k].clear();\n    for(int i=0;i<h[k];i++){\n      for(int j=0;j<w[k];j++){\n        vec[k].push_back(vis[i][j]);\n      }\n    }\n    sort(vec[k].begin(), vec[k].end());\n  }\n}\n\nint solve(){\n  int l = 0, r = 100000000;\n  while(l<r){\n    int m = (l + r) / 2;\n    bool f = false;\n    for(set<int>::iterator ite=data.begin();ite!=data.end();ite++){\n      if(*ite > m) break;\n      int a = distance(vec[0].begin(), upper_bound(vec[0].begin(), vec[0].end(), *ite));\n      int b = distance(vec[1].begin(), upper_bound(vec[1].begin(), vec[1].end(), m-(*ite)));\n      if(a + b >= R) f = true;\n    }\n    if(f) r = m;\n    else l = m + 1;\n  }\n  return l;\n}\n\nmain(){\n  while(cin >> R && R){\n    for(int k=0;k<2;k++){\n      cin >> w[k] >> h[k] >> sx[k] >> sy[k];\n      sx[k]--; sy[k]--;\n      for(int i=0;i<h[k];i++){\n        for(int j=0;j<w[k];j++){\n          cin >> input[k][i][j];\n        }\n      }\n    }\n    init();\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#define F first\n#define S second\nusing namespace std;\nint r;\nint f[555][555];\nbool used[555][555];\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\nvector< pair<int,int> > v[2];\nint main(void){\n  while(cin >> r && r){\n    for(int k = 0; k < 2; k++){\n      v[k].clear();\n      int w,h,ox,oy;\n      cin >> w >> h >> ox >> oy;\n      for(int y = 1; y <= h; y++){\n\tfor(int x = 1; x <= w; x++){\n\t  cin >> f[x][y];\n\t}\n      }\n\n      priority_queue< pair<int,pair<int,int> > , vector< pair<int,pair<int,int> > > , greater< pair<int,pair<int,int> > > > que;\n      que.push(make_pair(1,make_pair(ox,oy)));\n      memset(used,false,sizeof(used));\n      used[ox][oy] = true;\n      int best = 0;\n      int cr = 0;\n      while(!que.empty()){\n\tint x = que.top().S.F;\n\tint y = que.top().S.S;\n\tint l = que.top().F;\n\tque.pop();\n\tif(best < l){\n\t  v[k].push_back(make_pair(cr,best));\n\t  best = l;\n\t}\n\tcr++;\n\tif(cr >= r){\n\t  v[k].push_back(make_pair(cr,best));\n\t  break;\n\t}\n\tfor(int i = 0; i < 4; i++){\n\t  int nx = x + dx[i];\n\t  int ny = y + dy[i];\n\t  if(0 >= nx || 0 >= ny || w < nx || h < ny || used[nx][ny]) continue;\n\t  used[nx][ny] = true;\n\t  que.push(make_pair(f[nx][ny],make_pair(nx,ny)));\n\t}\n      }\n      v[k].push_back(make_pair(cr,best));\n    }\n\n    int res = 1<<28;\n    for(int i = 0; i < (int)v[0].size(); i++){\n      int p = r - v[0][i].F;\n      int t = 0,e = (int)v[1].size();\n      while(t < e){\n\tint h = (t+e)/2;\n\tif(p <= v[1][h].F) e = h;\n\telse t = h+1;\n      }\n      if(e == (int)v[1].size()) continue;\n      res = min(res,v[0][i].S+v[1][e].S);\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint l[2][500][500];\nbool c[2][500][500];\nint memo[2][100001];\n\nstruct level{\n  int l;\n  int x;\n  int y;\n  level(int a,int b,int c){\n    l=a; x=b; y=c;\n  }\n};\n\nbool operator < (const level &a, const level &b){\n  return a.l > b.l;\n}\n\nint main(){\n  int r;\n  while(r = getInt()){\n    int w[2],h[2],x[2],y[2];\n    REP(k,2){\n      w[k] = getInt();\n      h[k] = getInt();\n      x[k] = getInt() - 1;\n      y[k] = getInt() - 1;\n      REP(i,h[k]) REP(j,w[k]){\n        l[k][i][j] = getInt();\n        c[k][i][j] = false;\n      }\n\n      priority_queue<level> pq;\n      pq.push(level(1,x[k],y[k]));\n      c[k][x[k]][y[k]] = true;\n\n      int cnt = 0;\n      int now = 1;\n\n      memo[k][cnt++] = 0;\n      while(!pq.empty()){\n        level lv = pq.top();\n        int ll = lv.l;\n        int xx = lv.x;\n        int yy = lv.y;\n        pq.pop();\n        //printf(\"%d %d %d\\n\",ll,xx,yy);\n\n        memo[k][cnt++] = (now = max(ll, now));\n\n        REP(i,4){\n          int xxx = xx + _dx[i];\n          int yyy = yy + _dy[i];\n\n          if(ISIN(xxx,yyy,w[k],h[k]) && !c[k][yyy][xxx]){\n            c[k][yyy][xxx] = true;\n            pq.push(level(l[k][yyy][xxx], yyy, xxx));\n          }\n        }\n      }\n\n      //REP(i, w[k]*h[k]+1) printf(\"%d \",memo[k][i]); puts(\"\");\n    }\n\n    int end = min(r, w[0] * h[0]) + 1;\n    int start = max(0, r - w[1] * h[1]);\n    int ans = INT_MAX;\n    rep(i,start,end)\n      ans = min(ans, memo[0][i] + memo[1][r-i]);\n    print(ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = (1 << 30) - 1;\nstruct Node\n{\n    int y, x, cost;\n    Node () {}\n    Node (int y, int x, int cost) : y(y), x(x), cost(cost) {}\n    bool operator < (const Node &d) const { return (cost > d.cost); }\n};\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nint R;\nint W[2], H[2], X[2], Y[2];\nint mas[2][505][505];\nint mc[2][505][505];\nvector < int > D[2];\nvoid Dijkstra(int p, int sx, int sy)\n{\n    priority_queue < Node > pq;\n    pq.push(Node(sy, sx, 1));\n    mc[p][sy][sx] = 1;\n    while(!pq.empty()) {\n        Node d = pq.top(); pq.pop();\n        if(d.cost > mc[p][d.y][d.x]) continue;\n        D[p].push_back(d.cost);\n        for(int i = 0; i < 4; i++) {\n            int ny = d.y + dy[i], nx = d.x + dx[i], w = max(d.cost, mas[p][ny][nx]);\n            if(ny < H[p] && nx < W[p] && ny >= 0 && nx >= 0 && mc[p][ny][nx] > w) {\n                mc[p][ny][nx] = w;\n                pq.push(Node(ny, nx, w));\n            }\n        }\n    }\n}\n\nint main()\n{\n    while(cin >> R, R) {\n        D[0].push_back(0); D[1].push_back(0);\n        fill_n(**mc, 2 * 505 * 505, INF);\n        for(int p = 0; p < 2; p++) {\n            cin >> W[p] >> H[p] >> X[p] >> Y[p]; --X[p], --Y[p];\n            for(int i = 0; i < H[p]; i++) {\n                for(int j = 0; j < W[p]; j++) {\n                    cin >> mas[p][i][j];\n                }\n            }\n            Dijkstra(p, X[p], Y[p]);\n        }\n        int minv = INF;\n        for(int i = 0; i <= R; i++) {\n            if(i < D[0].size() && R - i < D[1].size()) {\n                minv = min(minv, D[0][i] + D[1][R - i]);\n            }\n        }\n        cout << minv << endl;\n        while(!D[0].empty()) D[0].pop_back();\n        while(!D[1].empty()) D[1].pop_back();\n    }\n    return (0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define X first\n#define Y second\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\ntypedef pair<int, int> P;\ntypedef pair<int, P> Elm;\n\nconst int WMAX = 500, HMAX = 500;\nconst int LMAX = 100000000;\nconst int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\n\nint office[WMAX][HMAX], level[WMAX][HMAX];\n\nvoid dijkstra(int w, int h, int sx, int sy) {\n  REP(y, h) {\n    REP(x, w) {\n      level[x][y] = LMAX;\n    }\n  }\n  priority_queue<Elm, vector<Elm>, greater<Elm> > que;\n  que.push( Elm(1, P(sx, sy)) );\n  level[sx][sy] = 1;\n\n  while (!que.empty()) {\n    int lev = que.top().first; P p = que.top().second;\n    que.pop();\n\n    if (level[p.X][p.Y] < lev) continue;\n\n    REP(i, 4) {\n      int x = p.X + dx[i], y = p.Y + dy[i];\n      if (x < 0 or w <= x or y < 0 or h <= y) continue;\n      \n      int newlevel = max(office[x][y], lev);\n      if (newlevel < level[x][y]) {\n        level[x][y] = newlevel;\n        que.push(Elm(newlevel, P(x, y)));\n      }\n    }\n  }\n}\n\nvector<int> count_level(int w, int h) {\n  vector<int> v;\n  v.push_back(0);\n  REP(y, h) {\n    REP(x, w) {\n      v.push_back(level[x][y]);\n    }\n  }\n  sort(v.begin(), v.end());\n  return v;\n}\n\nvector<int> make_level_table() {\n  int w, h, sx, sy;\n  cin >> w >> h >> sx >> sy;\n  REP(y, h) {\n    REP(x, w) {\n      cin >> office[x][y];\n    }\n  }\n  dijkstra(w, h, sx - 1, sy - 1);\n  return count_level(w, h);\n}\n\nint search(int key, \n    vector<int>::iterator begin, vector<int>::iterator end) {\n  if (key == 0) return 0;\n  pair<vector<int>::iterator, vector<int>::iterator> eqr = \n    equal_range(begin, end, key);\n  return eqr.second - eqr.first;\n}\n\nint main() {\n  int r, w, h, sx, sy;\n  while (cin >> r and r) {\n    vector<int> ltab1 = make_level_table();\n    vector<int> ltab2 = make_level_table();\n\n    vector<int>::iterator lev1 = ltab1.end() - 1, \n      lev2 = ltab2.begin();\n    int rooms = ltab1.size() - 1;\n    int ans = 2 * LMAX + 1;\n\n    while (lev1 != ltab1.begin()) {\n      while (rooms < r and lev2 != ltab2.end()) {\n        lev2 = upper_bound(lev2, ltab2.end(), *lev2);\n        rooms += search(*lev2, lev2, ltab2.end());\n      }\n      \n      if (rooms < r or lev2 == ltab2.end()) break;\n      ans = min(ans, *lev1 + *lev2);\n      \n      rooms -= search(*lev1, ltab1.begin(), lev1 + 1);\n      lev1 = lower_bound(ltab1.begin(), lev1, *lev1) - 1;\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <iterator>\n#include <list>\n#include <map>\n#include <queue>\n#include <bitset>\n#include <fstream>\n#include <cmath>\n#include <ctime>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define REP(i,s,n) for(int i = s; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define MSG(a) cout << #a << \" \"  << a << endl;\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\n\nstruct node\n{\n\tint x, y, cost;\n\tnode(int x, int y, int cost) : x(x), y(y), cost(cost) {}\n};\nbool operator < (const node &a, const node &b)\n{ return a.cost > b.cost; }\n\nint room[500][500];\nint from[500 * 500];\nbool flag[500][500];\n\nint main()\n{\n\tint r;\n\twhile(cin >> r && r)\n\t{\n\t\t// key, value\n\t\tmap<int, int> result[2];\n\t\tresult[0][0] = result[1][0] = 0;\n\n\t\t\n\t\t// Dijkstra\n\t\trep(i, 2)\n\t\t{\n\t\t\tint w, h, sx, sy;\n\t\t\tcin >> w >> h >> sx >> sy; sx--; sy--;\n\n\t\t\trep(y, h) rep(x, w) cin >> room[y][x];\n\n\n\t\t\tpriority_queue<node> que;\n\t\t\tmemset(flag, 0, sizeof(flag));\n\t\t\t\n\t\t\tfor(que.push(node(sx, sy, room[sy][sx])); !que.empty(); que.pop())\n\t\t\t{\n\t\t\t\tnode q = que.top();\n\t\t\t\t\n\t\t\t\tif(flag[q.y][q.x]) continue;\n\t\t\t\telse flag[q.y][q.x] = true;\n\t\t\t\t\n\t\t\t\tresult[i][q.cost]++;\n\t\t\t\t\n\t\t\t\tint dx[] = {-1,0,1,0} , dy[] = {0,-1,0,1};\n\t\t\t\trep(d, 4)\n\t\t\t\t{\n\t\t\t\t\tint tx = q.x + dx[d], ty = q.y + dy[d];\n\t\t\t\t\tif(0 <= tx && tx < w && 0 <= ty && ty < h && !flag[ty][tx]) que.push(node(tx, ty, max(q.cost, room[ty][tx])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint res = INT_MAX;\n\n\t\tint sum_one = 0;\n\t\tvector<int> u;\n\t\t\n\t\tfor(map<int, int>::iterator it = result[1].begin(); it != result[1].end(); it++)\n\t\t{\n\t\t\tfrom[u.size()] = it->first;\n\t\t\tu.push_back(it->second + sum_one);\n\t\t\tsum_one += it->second;\n\t\t}\n\t\tu.push_back(INT_MAX);\n\n\n\t\tint sum_one_second = 0;\n\n\t\tfor(map<int, int>::iterator it = result[0].begin(); it != result[0].end(); it++)\n\t\t{\n\t\t\tint l = it->first, c = it->second + sum_one_second, ac = *lower_bound(u.begin(), u.end(), r - l);\n\t\t\tif(ac != INT_MAX)\n\t\t\t{\n\t\t\t\tint al = from[lower_bound(u.begin(), u.end(), r - c) - u.begin()];\n\t\t\t\tchmin(res, l + al);\n\t\t\t}\n\t\t\tsum_one_second += it->second;\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint w,h,x,y,a[505][505],b[505][505],c[505][505];\n\npair<int,int> make_P(int ma,int mb){pair<int,int> ret; ret.first=ma; ret.second=mb; return ret;}\n\npair<int,pair<int,int>> make_PP(int ma,pair<int,int> mb){pair<int,pair<int,int>> ret; ret.first=ma; ret.second=mb; return ret;}\n\nbool f(pair<int,pair<int,int>> fx,pair<int,pair<int,int>> fy){return fx.first<=fy.first;}\n\nvoid ww(int wx,int wy){\n\tc[wx][wy]=1;\n\tif(b[wx][wy+1]==1&&c[wx][wy+1]==0)ww(wx,wy+1);\n\tif(b[wx][wy-1]==1&&c[wx][wy-1]==0)ww(wx,wy-1);\n\tif(b[wx+1][wy]==1&&c[wx+1][wy]==0)ww(wx+1,wy);\n\tif(b[wx-1][wy]==1&&c[wx-1][wy]==0)ww(wx-1,wy);\n}\n\nvector<int> els(vector<int> vp){\n\tvector<int> ret;\n\tint s=vp.size();\n\tret.push_back(vp[0]);\n\tfor(int i=1;i<s;i++){\n\t\tif(vp[i]!=vp[i-1])ret.push_back(vp[i]);\n\t}\n\treturn ret;\n}\n\nvector<pair<int,int>> office(){\n\tfor(int i=0;i<505;i++)for(int j=0;j<505;j++){b[i][j]=0; c[i][j]=0;}\n\tvector<pair<int,pair<int,int>>> v;\n\tfor(int i=1;i<=h;i++)for(int j=1;j<=h;j++)v.push_back(make_PP(a[i][j],make_P(i,j)));\n\tsort(v.begin(),v.end(),f);\n\t//v=els(v);\n\tvector<pair<int,int>> ret;\n\tret.push_back(make_P(0,0));\n\tint s=v.size();\n\tb[x][y]=1; c[x][y]=1;\n\tfor(int i=0;i<s;i++){\n\t\t/*for(int j=1;j<=h;j++)for(int k=1;k<=w;k++){\n\t\t\tif(a[j][k]==v[i]){\n\t\t\t\tb[j][k]=1;\n\t\t\t\tif(c[j][k+1]+c[j][k-1]+c[j+1][k]+c[j-1][k]!=0)ww(j,k);\n\t\t\t}\n\t\t}*/\n\t\tb[v[i].second.first][v[i].second.second]=1;\n\t\tif(c[v[i].second.first][v[i].second.second+1]+c[v[i].second.first][v[i].second.second-1]+c[v[i].second.first+1][v[i].second.second]+c[v[i].second.first-1][v[i].second.second]!=0)ww(v[i].second.first,v[i].second.second);\n\t\tint sum=0;\n\t\tfor(int j=1;j<=h;j++)for(int k=1;k<=w;k++)sum+=c[j][k];\n\t\tret.push_back(make_P(v[i].first,sum));\n\t}\n\treturn ret;\n}\n\nint main(){\nwhile(1){\n\tint r,s[2];\n\tscanf(\"%d\",&r);\n\tif(r==0)break;\n\tvector<pair<int,int>> vvp[2];\n\tfor(int i=0;i<=1;i++){\n\t\tfor(int k=0;k<505;k++)for(int j=0;j<505;j++)a[k][j]=0;\n\t\tscanf(\"%d%d%d%d\",&w,&h,&x,&y);\n\t\tfor(int j=1;j<=h;j++)for(int k=1;k<=w;k++)scanf(\"%d\",&a[j][k]);\n\t\tvvp[i]=office();\n\t\ts[i]=vvp[i].size();\n\t}\n\tint n=s[1]-1,ret=200000000;\n\tfor(int i=0;i<s[0];i++){\n\t\tif(n!=0)while(vvp[0][i].second+vvp[1][n-1].second>=r){n--; if(n==0)break;}\n\t\tif(vvp[0][i].second+vvp[1][n].second>=r)ret=min(ret,vvp[0][i].first+vvp[1][n].first);\n\t}\n\tprintf(\"%d\\n\",ret);\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\n\nint x[2],y[2],w[2],h[2];\nint R;\nvector<vvi> zimu;\n\nvoid dfs(int i, int x, int y, vvi& used, vector<pair<int,int>>& list){\n\n  priority_queue< pair<int,pii>, vector<pair<int,pii> >,greater<pair<int,pii> > > que;\n  que.push(pair<int,pii>(1,pii(x,y)));\n\n  int auth = 0;\n  int room = 0;\n  while(que.size()){\n    int corr_lev = que.top().first;\n    int corr_x = que.top().second.first;\n    int corr_y = que.top().second.second;\n    //cout << \"POP (\" << corr_x << \",\" << corr_y <<\") \" << corr_lev << endl; \n    que.pop();\n    if( used[corr_y][corr_x] == 1) continue;\n    used[corr_y][corr_x] = 1;\n    \n    if(corr_lev > auth){\n      list.push_back(pii(room,auth));\n      auth = corr_lev;\n    }\n    room++;\n    if( room == w[i]*h[i] ) break;\n\n\n    for(int j=0; j<4; j++){\n      int nx = corr_x + dx[j];\n      int ny = corr_y + dy[j];\n      if(nx >= w[i] || nx < 0 || ny >= h[i] || ny < 0) continue; // ????£?\n      if(used[ny][nx] == 1) continue; // ??¢?´¢??????\n      que.push( pair<int,pii>(zimu[i][ny][nx],pii(nx,ny)) );\n      //cout << \"  PUSH (\" << nx << \",\" << ny << \") \" << zimu[i][ny][nx] << endl; \n    }\n  }\n  list.push_back(pii(room,auth));\n}\n\nint main(){\n  while(1){\n  \n    cin >> R; if(!R) break;\n    zimu.clear();\n    \n    // ??\\???\n    for(int i=0; i<2; i++){\n      cin >> w[i] >> h[i] >> x[i] >> y[i];\n  \n      zimu.push_back(vvi(h[i],vi(w[i])));\n\n      for(int j=0; j<h[i]; j++)\n\tfor(int k=0; k<w[i]; k++)\n\t  cin >> zimu[i][j][k];\n    }\n\n    // \n    vector<vector<pair<int,int> > > list(2); // ???????????¨?±???°???????¨???¬??????\n    \n    for(int i=0; i<2; i++){\n      list[i].push_back(pii(0,0));\n      vvi used(h[i],vi(w[i],0));\n      dfs(i, x[i]-1, y[i]-1, used, list[i]);\n    }\n    /*\n    for(int i=0; i<2; i++){\n      for(int j=0; j<list[i].size(); j++)\n\tcout << \"(\" << list[i][j].first << \",\" << list[i][j].second << \"), \";\n      cout << endl;\n      }*/\n    \n\n    int ans = 1e+9;\n    for(int i=0; i<list[0].size(); i++){\n      int rooma = list[0][i].first;\n      int autha = list[0][i].second;\n      pii tmp = *lower_bound(list[1].begin(),list[1].end(), pii(R-rooma,0));\n      int roomb = tmp.first;\n      int authb = tmp.second;\n      if(rooma + roomb < R) continue;\n      ans = min(ans,autha + authb);\n    }\n    cout << ans << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <string>\n#include <map>\n#include <utility>\n#include <set>\n#include <queue>\n#include <unordered_set>\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\n\n//using LL = long long;\n//using P = pair < int, int > ;\n//using PI = pair < P, int > ;\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\nvector<P> visitable(vector<vector<int>>& stage, P start)\n{\n\tint h = stage.size(), w = stage[0].size();\n\tvector<vector<int>> ns(h, vector<int>(w, INF));\n\tset<P> visited;\n\tqueue<P> que;\n\tque.push(start);\n\tvisited.insert(start);\n\tns[start.first][start.second] = 1;\n\twhile (!que.empty())\n\t{\n\t\tP p = que.front(); que.pop();\n\t\trep(i, 4)\n\t\t{\n\t\t\tint nr = dr[i] + p.first, nc = dc[i] + p.second;\n\t\t\tif (nr < 0 || nr >= h || nc < 0 || nc >= w) continue;\n\n\t\t\tns[nr][nc] = max(stage[nr][nc], min(ns[nr][nc], ns[p.first][p.second]));\n\n\t\t\tP np = P(nr, nc);\n\t\t\tif (visited.count(np)) continue;\n\t\t\tvisited.insert(np);\n\t\t\tque.push(np);\n\t\t}\n\t}\n\n\tmap<int, int> mp;\n\trep(i, h) rep(j, w) mp[ns[i][j]]++;\n\tvector<P> ret;\n\tfor (P p : mp) ret.push_back(p);\n\tfor (int i = 0; i + 1 < ret.size(); i++) ret[i + 1].second += ret[i].second;\n\treturn move(ret);\n}\n\n//x個を満たす最小の機密レベル\nint lower(vector<int>& sums, vector<int>& data, int x)\n{\n\tif (sums[sums.size() - 1] < x) return -1;\n\tif (x == 0) return 0;\n\n\tint idx = lower_bound(all(sums), x) - sums.begin();\n\treturn data[idx];\n}\n\nsigned main()\n{\n\tint R;\n\twhile (cin >> R && R)\n\t{\n\t\tint w1, h1, c1, r1; cin >> w1 >> h1 >> c1 >> r1;\n\t\tr1--; c1--;\n\t\tvector<vector<int>> stage1(h1, vector<int>(w1));\n\t\trep(i, h1) rep(j, w1) cin >> stage1[i][j];\n\n\t\tvector<P> ps1 = visitable(stage1, P(r1, c1));\n\t\tvector<int> sums1, data1;\n\t\tfor (P p : ps1)\n\t\t{\n\t\t\tsums1.push_back(p.second);\n\t\t\tdata1.push_back(p.first);\n\t\t}\n\n\t\tint w2, h2, c2, r2; cin >> w2 >> h2 >> c2 >> r2;\n\t\tr2--; c2--;\n\t\tvector<vector<int>> stage2(h2, vector<int>(w2));\n\t\trep(i, h2) rep(j, w2) cin >> stage2[i][j];\n\n\t\tvector<P> ps2 = visitable(stage2, P(r2, c2));\n\t\tvector<int> sums2, data2;\n\t\tfor (P p : ps2)\n\t\t{\n\t\t\tsums2.push_back(p.second);\n\t\t\tdata2.push_back(p.first);\n\t\t}\n\n\t\tint ans = INF;\n\t\trep(x, R + 1)\n\t\t{\n\t\t\tint y = R - x;\n\t\t\tint l1 = lower(sums1, data1, x);\n\t\t\tint l2 = lower(sums2, data2, y);\n\t\t\tif (l1 != -1 && l2 != -1)\n\t\t\t{\n\t\t\t\tans = min(ans, l1 + l2);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define\tmp\tmake_pair\n#define\tpb\tpush_back\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint main(){\n\tfor(int r;scanf(\"%d\",&r),r;){\n\t\tint w[2],h[2],x[2],y[2];\n\t\tstatic int room[2][500][500];\n\t\tstatic int roomcnt[2][100001];\n\t\tfor(int k=0;k<2;k++){\n\t\t\tscanf(\"%d%d%d%d\",&w[k],&h[k],&x[k],&y[k]);\n\t\t\tx[k]--,y[k]--;\n\t\t\tfor(int i=0;i<h[k];i++)for(int j=0;j<w[k];j++)\tscanf(\"%d\",&room[k][i][j]);\n\n\t\t\tfor(int i=0;i<=r;i++)\troomcnt[k][i]=1<<30;\n\t\t\troomcnt[k][0]=0;\n\n\t\t\tstatic bool visited[500][500];\n\t\t\tfor(int i=0;i<h[k];i++)for(int j=0;j<w[k];j++)\tvisited[i][j]=false;\n\t\t\tvisited[y[k]][x[k]]=true;\n\t\t\tint cnt=0,lev=0;\n\t\t\tpriority_queue< pair<int,pii> > pq;\n\t\t\tpq.push(mp(-room[k][y[k]][x[k]],mp(y[k],x[k])));\n\t\t\twhile(!pq.empty()){\n\t\t\t\tpair<int,pii> a=pq.top();\tpq.pop();\n\t\t\t\tint nowlev=-a.first,x=a.second.second,y=a.second.first;\n\t\t\t\tcnt++;\n\t\t\t\tif(lev<nowlev)\tlev=nowlev;\n\t\t\t\troomcnt[k][cnt]=lev;\n\t\t\t\tif(cnt==r)\tbreak;\n\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint xx=x+dx[i],yy=y+dy[i];\n\t\t\t\t\tif(0<=xx && xx<w[k] && 0<=yy && yy<h[k] && !visited[yy][xx]){\n\t\t\t\t\t\tpq.push(mp(-room[k][yy][xx],mp(yy,xx)));\n\t\t\t\t\t\tvisited[yy][xx]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans=1<<30;\n\t\tfor(int i=0;i<=r;i++)\tans=min(ans,roomcnt[0][i]+roomcnt[1][r-i]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\n\n#define fr first\n#define sc second\n#define pb push_back\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define rep1(i,x) for(ll i=1;i<=x;i++)\n#define rrep(i,x) for(ll i=x-1;i>=0;i--)\n#define rrep1(i,x) for(ll i=x;i>0;i--)\n\nstruct T{\n\tll l,y,x;\n\tbool operator<(const T& b)const{\n\t\treturn l<b.l;\n\t};\n\tbool operator>(const T& b)const{\n\t\treturn l>b.l;\n\t};\n};\nconst ll INF=0xfffffffffffffff;\nll R;\nll W1,W2,H1,H2;\nll X1,Y1,X2,Y2;\nll L1[500][500];\nll L2[500][500];\nll atu1[250001];\nll atu2[250001];\nll dp1[250001];//?¨???????????????¨?±?????????°\nll dp2[250001];\nll sz1,sz2;\nll vx[4]={1,0,-1,0};\nll vy[4]={0,1,0,-1};\nbool pushed[500][500];\nvector<ll> xs;\npriority_queue<T,vector<T>,greater<T> > q;\nvoid solve(ll W,ll H,ll sx,ll sy,ll L[][500],ll *atu,ll *dp,ll& sz){\n\tauto ok = [&](ll y,ll x){\n\t\treturn 0<=x&&x<W&&0<=y&&y<H;\n\t};\n\txs.clear();\n\tfill(atu,atu+250001,INF);\n\tmemset(pushed,0,sizeof(pushed));\n\trep(i,H) rep(j,W){\n\t\txs.pb(L[i][j]);\n\t}\n\t\n\tsort(xs.begin(),xs.end());\n\n\txs.erase(unique(xs.begin(),xs.end()),xs.end());\n\tsz=xs.size();\n\t//cout<<sz<<endl;\n\trep(i,sz) atu[i]=xs[i];\n\trep(i,H) rep(j,W){\n\t\tL[i][j]=lower_bound(xs.begin(),xs.end(),L[i][j])-xs.begin();\n\t}\n\tll kosu=0,now=0;\n\tq.push(T{0,sy,sx});\n\tpushed[sy][sx]=1;\n\t\n\twhile(!q.empty()){\n\t\tT t=q.top();\n\t\tq.pop();\n\t\tnow=max(now,t.l);\n\t\tkosu++;\n\t\tdp[now]=kosu;\n\t\trep(i,4){\n\t\t\tll ny=t.y+vy[i];\n\t\t\tll nx=t.x+vx[i];\n\t\t\tif(ok(ny,nx)&&!pushed[ny][nx]){\n\t\t\t\tq.push(T{L[ny][nx],ny,nx});\n\t\t\t\tpushed[ny][nx]=1;\n\t\t\t}\n\t\t}\n\t}\n\trep1(i,sz-1) if(dp[i]<dp[i-1]){\n\t\tdp[i]=dp[i-1];\n\t}\n\treturn;\n}\n\nint main()\n{while(1){\n\tcin>>R;\n\tif(!R) break;\n\tmemset(dp1,0,sizeof(dp1));\n\tmemset(dp2,0,sizeof(dp2));\n\tcin>>W1>>H1>>X1>>Y1;\n\tX1--;\n\tY1--;\n\trep(i,H1) rep(j,W1) cin>>L1[i][j];\n\tsolve(W1,H1,X1,Y1,L1,atu1,dp1,sz1);\n\tcin>>W2>>H2>>X2>>Y2;\n\tX2--;\n\tY2--;\n\trep(i,H2) rep(j,W2) cin>>L2[i][j];\n\tsolve(W2,H2,X2,Y2,L2,atu2,dp2,sz2);\n\tll ans=atu2[lower_bound(dp2,dp2+sz2,R)-dp2];\n\trep(i,sz1){\n\t\tif(dp1[i]>=R) ans=min(ans,atu1[i]);\n\t\telse ans=min(ans,atu1[i]+atu2[lower_bound(dp2,dp2+sz2,R-dp1[i])-dp2]);\n\t}\n\tcout<<ans<<endl;\n}}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<utility>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nvector<int> val[2];\n\nint field[2][550][550];\nint cfield[2][550][550];\n\nint X[2],Y[2];\nint H[2],W[2];\n\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nint cango[2][300300];\n\nbool visited[550][550];\n\nint main()\n{\n\twhile(1)\n\t{\n\tint R;\n\tscanf(\"%d\",&R);\n\tif(R==0) break;\n\tfor(int f=0;f<=1;f++)\n\t{\n\t\tval[f].clear();\n\t\tscanf(\"%d%d%d%d\",W+f,H+f,X+f,Y+f);\n\t\tX[f]--;Y[f]--;\n\t\tfor(int y=0;y<H[f];y++)\n\t\t{\n\t\t\tfor(int x=0;x<W[f];x++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&field[f][y][x]);\n\t\t\t\tval[f].push_back(field[f][y][x]);\n\t\t\t}\n\t\t}\n\t\tval[f].push_back(0);\n\t\tsort(val[f].begin(),val[f].end());\n\t\tval[f].erase(unique(val[f].begin(),val[f].end()),val[f].end());\n\t\tfor(int y=0;y<H[f];y++)\n\t\t{\n\t\t\tfor(int x=0;x<W[f];x++)\n\t\t\t{\n\t\t\t\tcfield[f][y][x]=distance(val[f].begin(),lower_bound(val[f].begin(),val[f].end(),field[f][y][x]));\n\t\t\t}\n\t\t}\n\t}\n\tmemset(cango,0,sizeof(cango));\n\tfor(int f=0;f<=1;f++)\n\t{\n\t\tmemset(visited,false,sizeof(visited));\n\t\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\t\tint nowlv=0;\n\t\tque.push(PP(1,P(Y[f],X[f])));\n\t\tvisited[Y[f]][X[f]]=true;\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tPP pp=que.top();\n\t\t\tque.pop();\n\t\t\tint y=pp.second.first,x=pp.second.second;\n\t\t\tif(pp.first<=nowlv)\n\t\t\t{\n\t\t\t\tcango[f][nowlv]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int lvs=nowlv;lvs<=pp.first;lvs++)\n\t\t\t\t{\n\t\t\t\t\tcango[f][lvs]=cango[f][nowlv];\n\t\t\t\t}\n\t\t\t\tnowlv=pp.first;\n\t\t\t\tcango[f][nowlv]++;\n\t\t\t}\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t{\n\t\t\t\tint ny=y+dy[i],nx=x+dx[i];\n\t\t\t\tif(ny<0||nx<0||ny>=H[f]||nx>=W[f]) continue;\n\t\t\t\tif(visited[ny][nx]==true) continue;\n\t\t\t\tvisited[ny][nx]=true;\n\t\t\t\tque.push(PP(cfield[f][ny][nx],P(ny,nx)));\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<val[0].size();i++)\n\t{\n\t\tprintf(\"%d \",cango[0][i]);\n\t}\n\tprintf(\"\\n\");\n\tfor(int i=0;i<val[1].size();i++)\n\t{\n\t\tprintf(\"%d \",cango[1][i]);\n\t}\n\tprintf(\"\\n\");\n\t*/\n\tint ans=1100100100;\n\tint a1=0,a2=val[1].size()-1;\n\twhile(1)\n\t{\n\t\tif(cango[0][a1]+cango[1][a2]>=R)\n\t\t{\n\t\t\tans=min(ans,val[0][a1]+val[1][a2]);\n\t\t\tif(a2==0) break;\n\t\t\ta2--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ta1++;\n\t\t\tif(a1==val[0].size()) break;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst int INF = 1 << 30;\nconst int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};\n\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nint R, W[2], H[2], X[2], Y[2];\nint Room[2][500][500];\nstd::vector<int> L[2]; // 事務所ごとの存在するレベル\nint maxR[2][250001]; // maxR[i][j]: 事務所iでj番目に小さいレベルで行ける部屋の数\nint used[500][500];\n\nvoid travel(int r){\n    REP(j, H[r]){\n        REP(k, W[r]){\n            used[j][k] = 0;\n        }\n    }\n    \n    std::priority_queue<State, std::vector<State>, std::greater<State>> q;\n    q.push(mp(1, mp(X[r], Y[r])));\n    used[Y[r]][X[r]] = 1;\n    maxR[r][1] = 1;\n\n    while(!q.empty()){\n        State s = q.top(); q.pop();\n        int l = s.first;\n        P p = s.second;\n        int x = p.first, y = p.second;\n\n        //std::cout << x << \",\" << y << \",\" << l << std::endl;\n\n        REP(i, 4){\n            int nx = x + dx[i], ny = y + dy[i];\n            if(0 <= nx && nx < W[r] && 0 <= ny && ny < H[r] && !used[ny][nx]){\n\n                int nl = std::max(l, Room[r][ny][nx]),\n                    nl_index = std::distance(L[r].begin(), std::find(L[r].begin(), L[r].end(), nl));\n\n                q.push(mp(nl, mp(nx, ny)));\n                used[ny][nx] = 1;\n                maxR[r][nl_index]++;\n            }\n        }\n    }\n}\n\nint main(){\n    while(std::cin >> R, R){\n        REP(i, 2){\n            std::cin >> W[i] >> H[i] >> X[i] >> Y[i];\n            X[i]--; Y[i]--;\n\n            L[i].clear();\n            L[i].push_back(0);\n            REP(j, H[i]){\n                REP(k, W[i]){\n                    std::cin >> Room[i][j][k];\n                    L[i].push_back(Room[i][j][k]);\n                }\n            }\n\n            std::sort(L[i].begin(), L[i].end());\n            L[i].erase(std::unique(L[i].begin(), L[i].end()), L[i].end());\n        }\n\n        REP(i, 2){\n            REP(j, L[i].size()){\n                maxR[i][j] = 0;\n            }\n        }\n\n        REP(i, 2){\n            travel(i);\n        }\n\n        REP(i, 2){\n            //std::cout << maxR[i][0] << std::endl;\n            FOR(j, 1, L[i].size()){\n                maxR[i][j] += maxR[i][j-1];\n                // std::cout << maxR[i][j] << std::endl;\n            }\n            // puts(\"##############################\");\n        }\n\n        int res = INF;\n        REP(i, L[0].size()){\n            int r1 = maxR[0][i],\n                r2_index = std::lower_bound(maxR[1], maxR[1]+L[1].size(), R-r1) - maxR[1];\n        \n            if(r2_index == L[1].size()){\n                continue;\n            }\n\n            res = std::min(res, L[0][i] + L[1][r2_index]);\n        }\n\n        std::cout << res << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\nconst int INF = 1000000000;\n\nint main(){\n  while(true){\n    int r,w,h,x,y,field[500][500];\n    vector<pii> v[2];\n    scanf(\"%d\",&r);\n    if(r==0) return 0;\n    for(int k=0;k<2;k++){\n      scanf(\"%d %d %d %d\",&w,&h,&x,&y);\n      for(int i=0;i<h;i++) for(int j=0;j<w;j++) scanf(\"%d\",&field[i][j]);\n      int level = 0, cnt = 0;\n      priority_queue<pii,vector<pii>,greater<pii> > q;\n      x--; y--;\n      field[y][x] = 0;\n      q.push(pii(1,w*y+x));\n      q.push(pii(INF,0));\n      while(true){\n        pii p = q.top(); q.pop();\n        if(p.first>level){\n          v[k].push_back(pii(cnt,level));\n          level = p.first;\n          if(p.first==INF) break;\n        }\n        cnt++;\n        int dx[] = {0,0,1,-1};\n        int dy[] = {1,-1,0,0};\n        for(int i=0;i<4;i++){\n          int nx = p.second / w + dx[i], ny = p.second % w + dy[i];\n          if(nx>=0&&nx<h&&ny>=0&&ny<w&&field[nx][ny]>0){\n            q.push(pii(field[nx][ny],w*nx+ny));\n            field[nx][ny] = 0;\n          }\n        }\n      }\n    }\n    v[1].push_back(pii(INF,INF));\n    int ans = INF;\n    for(int i=0;i<v[0].size();i++){\n      ans = min(ans,v[0][i].second+(*lower_bound(v[1].begin(),v[1].end(),pii(r-v[0][i].first,0))).second);\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint r,w[2],h[2],x[2],y[2],l[2][500][500],temp[500][500]; vector<P> d[2];\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nvoid search(int n){\n\tfor(int i=0;i<500;i++) for(int j=0;j<500;j++) temp[i][j]=0;\n\tpriority_queue<P, vector<P>, greater<P> > q; d[n].push_back(P(0,0));\n\tq.push(P(l[n][y[n]][x[n]],x[n]*1000+y[n])); temp[y[n]][x[n]]=1;\n\tint res=0;\n\twhile(!q.empty()){\n\t\tP z=q.top(),qq;\n\t\twhile(qq=q.top(),qq.first<=z.first&&!q.empty()){\n\t\t\tq.pop(); int X=qq.second/1000,Y=qq.second%1000; res++;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tint i=X+dx[k],j=Y+dy[k];\n\t\t\t\tif(i<0||j<0||i>=w[n]||j>=h[n]) continue;\n\t\t\t\tif(temp[j][i]) continue;\n\t\t\t\tq.push(P(l[n][j][i],i*1000+j)); temp[j][i]=1;\n\t\t\t}\n\t\t}\n\t\td[n].push_back(P(res,l[n][z.second%1000][z.second/1000]));\n\t}\n}\n\nP l_b(int m){\n\tint lb=-1,rb=d[1].size();\n\twhile(lb+1<rb){\n\t\tint mid=(lb+rb)/2;\n\t\tif(d[1][mid].first>=m) rb=mid;\n\t\telse lb=mid;\n\t}\n\treturn d[1][rb];\n}\n\nint main(){\n\twhile(scanf(\"%d\",&r),r!=0){\n\t\tfor(int i=0;i<2;i++){\n\t\t\tscanf(\"%d%d%d%d\",&w[i],&h[i],&x[i],&y[i]); x[i]--; y[i]--;\n\t\t\tfor(int j=0;j<h[i];j++) for(int k=0;k<w[i];k++) scanf(\"%d\",&l[i][j][k]);\n\t\t\tsearch(i);\n\t\t}\n\t\tint res=INT_MAX;\n\t\tfor(int i=0;i<d[0].size();i++){\n\t\t\tP p=l_b(r-d[0][i].first);\n\t\t\tif(p.first+d[0][i].first>=r) res=min(res,p.second+d[0][i].second);\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t\tfor(int n=0;n<2;n++) for(int i=0;i<d[n].size();i++) d[n].pop();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nint w[2], h[2], l[2][500][500], sx[2], sy[2], r;\nint dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nint ans[2][100001], d[250000];\nbool vis[500][500], used[500][500];\nlist<P>que[250000];\nint compress(int k) {\n\tvector<int>x;\n\trep(i, h[k])rep(j, w[k])x.push_back(l[k][i][j]);\n\tsort(x.begin(), x.end());\n\tx.erase(unique(x.begin(), x.end()), x.end());\n\trep(i, x.size())d[i] = x[i];\n\trep(i, h[k])rep(j, w[k])\n\t\tl[k][i][j] = lower_bound(x.begin(), x.end(), l[k][i][j]) - x.begin();\n\treturn x.size();\n}\nvoid solve(int k) {\n\tans[k][0] = 0;\n\tqueue<P>Q;\n\tint n = compress(k);\n\trep(i, n)que[i].clear();\n\tmemset(vis, 0, sizeof(vis));\n\tmemset(used, 0, sizeof(used));\n\tQ.push(P(sx[k], sy[k]));\n\tvis[sx[k]][sy[k]] = true;\n\tint cnt = 0, Max = 0;\n\twhile (1) {\n\t\twhile (!Q.empty()) {\n\t\t\tP p = Q.front(); Q.pop();\n\t\t\tif (used[p.first][p.second])continue;\n\t\t\tused[p.first][p.second] = true;\n\t\t\tcnt++; if (cnt >= r)break;\n\t\t\trep(i, 4) {\n\t\t\t\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\tif (0 <= nx&&nx < h[k] && 0 <= ny&&ny < w[k] && !vis[nx][ny]) {\n\t\t\t\t\tvis[nx][ny] = true;\n\t\t\t\t\tif (l[k][nx][ny] <= Max)Q.push(P(nx, ny));\n\t\t\t\t\telse que[l[k][nx][ny]].push_back(P(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans[k][cnt] = min(ans[k][cnt], d[Max]);\n\t\tfor (int i = Max; i < n; i++) {\n\t\t\tif (!que[i].empty()) {\n\t\t\t\tMax = i;\n\t\t\t\tfor (P p : que[i])Q.push(p);\n\t\t\t\tque[i].clear();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (cnt >= r || Q.empty())break;\n\t}\n\tfor (int i = r - 1; i >= 1; i--)ans[k][i] = min(ans[k][i], ans[k][i + 1]);\n}\nint main() {\n\twhile (scanf(\"%d\", &r), r) {\n\t\trep(k, 2) {\n\t\t\tscanf(\"%d%d%d%d\", &w[k], &h[k], &sy[k], &sx[k]); sx[k]--; sy[k]--;\n\t\t\trep(i, h[k])rep(j, w[k])scanf(\"%d\", &l[k][i][j]);\n\t\t}\n\t\tfill(ans[0], ans[2], INT_MAX);\n\t\trep(k, 2)solve(k);\n\t\tint Min = INT_MAX;\n\t\tfor (int i = 0; i <= r; i++) {\n\t\t\tif (ans[0][i] == INT_MAX || ans[1][r - i] == INT_MAX)continue;\n\t\t\tMin = min(Min, ans[0][i] + ans[1][r - i]);\n\t\t}\n\t\tprintf(\"%d\\n\", Min);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint l[2][500][500];\nbool c[2][500][500];\nint memo[2][100001];\n\nstruct level{\n  int l;\n  int x;\n  int y;\n  level(int a,int b,int c){\n    l=a; x=b; y=c;\n  }\n};\n\nbool operator < (const level &a, const level &b){\n  return a.l > b.l;\n}\n\nint main(){\n  int r;\n  while(r = getInt()){\n    int w[2],h[2],x[2],y[2];\n    REP(k,2){\n      w[k] = getInt();\n      h[k] = getInt();\n      x[k] = getInt() - 1;\n      y[k] = getInt() - 1;\n      REP(i,h[k]) REP(j,w[k]){\n        l[k][i][j] = getInt();\n        c[k][i][j] = false;\n      }\n\n      priority_queue<level> pq;\n      pq.push(level(1,x[k],y[k]));\n      c[k][y[k]][x[k]] = true;\n\n      int cnt = 0;\n      int now = 1;\n\n      memo[k][cnt++] = 0;\n      while(!pq.empty()){\n        level lv = pq.top();\n        int ll = lv.l;\n        int xx = lv.x;\n        int yy = lv.y;\n        pq.pop();\n        //printf(\"%d %d %d\\n\",ll,xx,yy);\n\n        memo[k][cnt++] = (now = max(ll, now));\n\n        REP(i,4){\n          int xxx = xx + _dx[i];\n          int yyy = yy + _dy[i];\n\n          if(ISIN(xxx,yyy,w[k],h[k]) && !c[k][yyy][xxx]){\n            c[k][yyy][xxx] = true;\n            pq.push(level(l[k][yyy][xxx], xxx, yyy));\n          }\n        }\n      }\n\n      //REP(i, w[k]*h[k]+1) printf(\"%d \",memo[k][i]); puts(\"\");\n    }\n\n    int end = min(r, w[0] * h[0]) + 1;\n    int start = max(0, r - w[1] * h[1]);\n    int ans = INT_MAX;\n    rep(i,start,end)\n      ans = min(ans, memo[0][i] + memo[1][r-i]);\n    print(ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <iterator>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <cmath>\n#include <complex>\n#include <functional>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <cstdlib>\n#include <cctype>\n\n#define REP(i,m,n) for(int i=m;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rp(i,c) rep(i,(int)c.size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define v_delete(a,b) (a).erase(remove((a).begin(), (a).end(), b), (a).end())\n#define v_unique(a) (a).erase(unique((a).begin(), (a).end()), (a).end())\n#define VV(T) vector<vector< T > >\n#define init(a,b) memset((a), (b), sizeof((a)))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double EPS=1e-9;\nconst long long INF = 100001000010000100ll;\n\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntypedef pair<int,int> pii;\n\nint R;\nint W[2], H[2], X[2], Y[2];\n\nint m[4][500+10][500+10];\nint visited[2][500+10][500+10];\n\nint wa[2][500*500*10];\n\nvi ls;\n\nmap<int ,int> cnt[2];\n\nbool exists(const map<int ,int> &mapp, int key){\n\treturn mapp.find(key) != mapp.end();\n}\n\nint dx[]={1,0,0,-1};\nint dy[]={0,1,-1,0};\n\nclass BIT{\nprivate:\n\tvi bit;\n\tint n;\npublic:\n\tBIT(int _n){\n\t\tn = _n;\n\t\tbit.assign(n+1,0 );\n\t}\n\tvoid add(int i, int x){\n\t\twhile(i <= n){\n\t\t\tbit[i] += x;\n\t\t\ti += (i & -i);\n\t\t}\n\t}\n\tint sum(int i){\n\t\tint s = 0;\n\t\twhile(i > 0){\n\t\t\ts += bit[i];\n\t\t\ti -= (i & -i);\n\t\t}\n\t\treturn s;\n\t}\n};\n\n\nint main(){\n\twhile(cin >> R, R){\n\n\t\tmemset(visited, 0, sizeof(visited));\n\n\t\tmemset(wa, 0, sizeof(wa));\n\n\t\tls.clear();\n\n\t\tfill_n(**m, 4 * (500+10) * (500+10), inf);\n\n\t\trep(c, 2){\n\t\t\tcin >> W[c] >> H[c] >> X[c] >> Y[c];\n\t\t\trep(i, H[c]){\n\t\t\t\trep(j, W[c]){\n\t\t\t\t\tcin >> m[c][i+1][j+1];\n\t\t\t\t\tm[c+2][i+1][j+1]=m[c][i+1][j+1];\n\t\t\t\t\tls.pb(m[c][i+1][j+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tls.pb(0);\n\t\tls.pb(inf);\n\t\tsort(all(ls));\n\t\tls.erase(unique(all(ls)), ls.end());\n\t\trep(c, 2){\n\t\t\tqueue<pair<pii, int> >Q;\n\t\t\tQ.push(mp(mp(X[c], Y[c]), 1));\n\t\t\twhile(!Q.empty()){\n\t\t\t\tint x,y,level;\n\t\t\t\tx=Q.front().first.first;y=Q.front().first.second;level=Q.front().second;\n\t\t\t\tQ.pop();\n\t\t\t\trep(k, 4){\n\t\t\t\t\tif(m[c][x+dx[k]][y+dy[k]]!=inf){\n\t\t\t\t\t\tif(!visited[c][x+dx[k]][y+dy[k]]){\n\t\t\t\t\t\t\tif(m[c][x+dx[k]][y+dy[k]] < level){\n\t\t\t\t\t\t\t\tvisited[c][x+dx[k]][y+dy[k]]=1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tm[c][x+dx[k]][y+dy[k]] = max(m[c][x+dx[k]][y+dy[k]], level);\n\t\t\t\t\t\t\tQ.push(mp(mp(x+dx[k], y+dy[k]), m[c][x+dx[k]][y+dy[k]]));\n\t\t\t\t\t\t}else if(visited[c][x+dx[k]][y+dy[k]] && m[c][x+dx[k]][y+dy[k]] > level){\n\t\t\t\t\t\t\tm[c][x+dx[k]][y+dy[k]] = max(level, m[c + 2][x+dx[k]][y+dy[k]]);\n\t\t\t\t\t\t\tQ.push(mp(mp(x+dx[k], y+dy[k]), m[c][x+dx[k]][y+dy[k]]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\trep(c, 2){\n\t\t\trep(i, H[c]){\n\t\t\t\trep(j, W[c]){\n\t\t\t\t\tint ma=-1;\n\t\t\t\t\tint tmp=inf;\n\t\t\t\t\t/*\n\t\t\t\t\trep(k, 4){\n\t\t\t\t\t\ttmp=min(tmp, m[c][i + 1 + dx[k]][j + 1 + dy[k]]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i + 1 == Y[c] && j + 1 == X[c]){\n\t\t\t\t\t\tma=m[c][i + 1][j + 1];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tma = max(m[c][i + 1][j + 1], tmp);\n\t\t\t\t\t}*/\n\t\t\t\t\tma=m[c][i + 1][j + 1];\n\t\t\t\t\tint l = lower_bound(all(ls), ma) - ls.begin();\n\t\t\t\t\twa[c][l]++;\n\n\t\t\t\t}\n\t\t\t}\n\t\t\trp(i, ls){\n\t\t\t\tif(i - 1 >= 0)\n\t\t\t\t\twa[c][i] = wa[c][i - 1] + wa[c][i];\n\t\t\t}\n\n\t\t}\n\t\t/*\n\t\trep(c, 2){\n\t\t\trp(i, ls){\n\t\t\t\tcout << ls[i] << \" \" << wa[c][i] << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\tcout << endl;\n\t\t}*/\n\t\tint ans=inf;\n\t\trp(i, ls){\n\n\t\t\tint l=lower_bound(wa[1],(wa[1]+(int)ls.size()) , R - wa[0][i]) - wa[1];\n\t\t\tif(l < ls.size())\n\t\t\tif(wa[0][i] + wa[1][l] >= R){\n\t\t\t\t//cout << ls[i] << \" \" << ls[l] << endl;\n\t\t\t\tans=min(ans, ls[i] + ls[l]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint r,w[2],h[2],x[2],y[2],l[2][500][500],temp[500][500]; vector<P> d[2];\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nvoid search(int n){\n    for(int i=0;i<500;i++) for(int j=0;j<500;j++) temp[i][j]=0;\n    priority_queue<P, vector<P>, greater<P> > q; d[n].push_back(P(0,0));\n    q.push(P(l[n][y[n]][x[n]],x[n]*1000+y[n])); temp[y[n]][x[n]]=1;\n    int res=0;\n    while(!q.empty()){\n        P z=q.top(),qq;\n        while(qq=q.top(),qq.first<=z.first&&!q.empty()){\n            q.pop(); int X=qq.second/1000,Y=qq.second%1000; res++;\n            for(int k=0;k<4;k++){\n                int i=X+dx[k],j=Y+dy[k];\n                if(i<0||j<0||i>=w[n]||j>=h[n]) continue;\n                if(temp[j][i]) continue;\n                q.push(P(l[n][j][i],i*1000+j)); temp[j][i]=1;\n            }\n        }\n        d[n].push_back(P(res,l[n][z.second%1000][z.second/1000]));\n    }\n}\n\nP l_b(int m){\n    int lb=-1,rb=d[1].size()-1;\n    while(lb+1<rb){\n        int mid=(lb+rb)/2;\n        if(d[1][mid].first>=m) rb=mid;\n        else lb=mid;\n    }\n    return d[1][rb];\n}\n\nint main(){\n    while(scanf(\"%d\",&r),r!=0){\n        for(int i=0;i<2;i++){\n            scanf(\"%d%d%d%d\",&w[i],&h[i],&x[i],&y[i]); x[i]--; y[i]--;\n            for(int j=0;j<h[i];j++) for(int k=0;k<w[i];k++) scanf(\"%d\",&l[i][j][k]);\n            search(i);\n        }\n        int res=INT_MAX;\n        for(int i=0;i<d[0].size();i++){\n            P p=l_b(r-d[0][i].first);\n            if(p.first+d[0][i].first>=r) res=min(res,p.second+d[0][i].second);\n        }\n        printf(\"%d\\n\",res);\n        d[0].erase(d[0].begin(),d[0].end());\n        d[1].erase(d[1].begin(),d[1].end());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size, -1) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\n\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\nint main() {\n\twhile (1) {\n\t\tint R; cin >> R;\n\t\tif (!R)break;\n\t\tvector<map<int, int>>nums(2);\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tint W, H, X, Y; cin >> W >> H >> X >> Y;\n\t\t\tvector<vector<int>>field(H + 2, vector<int>(W + 2, 1e9));\n\t\t\tmap<int, vector<pair<int, int>>>mp;\n\t\t\tfor (int y = 1; y <= H; ++y) {\n\t\t\t\tfor (int x = 1; x <= W; ++x) {\n\t\t\t\t\tcin >> field[y][x];\n\t\t\t\t\tmp[field[y][x]].emplace_back(x, y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tUnionFind uf((W * 2)*(H * 2));\n\t\t\tint aroot = Y*(W + 2) + X;\n\t\t\tnums[k][0] = 0;\n\t\t\tfor (auto m : mp) {\n\t\t\t\tfor (auto v : m.second) {\n\t\t\t\t\tconst int nx = v.first;\n\t\t\t\t\tconst int ny = v.second;\n\t\t\t\t\tfor (int way = 0; way < 4; ++way) {\n\t\t\t\t\t\tif (field[ny + dy[way]][nx + dx[way]] <= m.first) {\n\t\t\t\t\t\t\tuf.unionSet(ny*(W + 2) + nx, (ny + dy[way]) * (W + 2) + nx + dx[way]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnums[k][m.first] = uf.size(aroot);\n\t\t\t}\n\t\t}\n\t\tauto it = nums[0].begin();\n\t\tauto jt = prev(nums[1].end());\n\t\tint ans = 1e9;\n\t\tfor (it; it != nums[0].end(); ++it) {\n\t\t\tif (it->second + jt->second < R)continue;\n\t\t\telse {\n\t\t\t\twhile (jt != nums[1].begin()) {\n\t\t\t\t\tif (it->second + (prev(jt))->second >= R) {\n\t\t\t\t\t\tjt--;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans = min(ans, it->first + jt->first);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\nusing namespace std;\n\nint room[2][500][500];\n\nstruct NODE{\n\tint x,y,cst;\n\tNODE(int x,int y,int cst) : x(x) , y(y) , cst(cst) {}\n};\nbool operator < (const NODE &a,const NODE &b){\n\treturn a.cst > b.cst;\n}\nbool flag[500][500];\nint main(){\n\tint R;\n\twhile(cin >> R && R){\n\t\tint W[2],H[2],sx[2],sy[2];\n\t\tmap<int,int> result[2];\n\t\tresult[0][0] = 0;\n\t\tresult[1][0] = 0;\n\t\t\n\t\tfor(int i = 0 ; i < 2 ; i++){\n\t\t\tcin >> W[i] >> H[i] >> sx[i] >> sy[i];\n\t\t\tsx[i]--,sy[i]--;\n\t\t\tfor(int y = 0 ; y < H[i] ; y++)\n\t\t\t\tfor(int x = 0 ; x < W[i] ; x++)\n\t\t\t\t\tcin >> room[i][y][x];\n\t\t\tpriority_queue<NODE> Q;\n\t\t\tQ.push(NODE(sx[i],sy[i],room[i][sy[i]][sx[i]]));\n\t\t\tmemset(flag,0,sizeof(flag));\n\t\t\twhile(Q.size()){\n\t\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\t\tif(flag[q.y][q.x]) continue;\n\t\t\t\telse flag[q.y][q.x] = true;\n\t\t\t\tresult[i][q.cst]++;\n\t\t\t\tint dx[] = {-1,0,1,0} , dy[] = {0,-1,0,1};\n\t\t\t\tfor(int d = 0 ; d < 4 ; d++){\n\t\t\t\t\tint tx = q.x + dx[d] , ty = q.y + dy[d];\n\t\t\t\t\tif(tx >= 0 && ty >= 0 && tx < W[i] && ty < H[i] && !flag[ty][tx]) Q.push(NODE(tx,ty,max(q.cst,room[i][ty][tx])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmap<int,int> from;\n\t\tvector<int> u;\n\t\tint prev = 0;\n\t\tfor(map<int,int>::iterator it = result[1].begin() ; it != result[1].end() ; ++it){\n\t\t\tfrom[u.size()] = it->first;\n\t\t\tu.push_back(it->second + prev);\n\t\t\tprev = u.back();\n\t\t}\n\t\tint ans = INT_MAX;\n\t\tu.push_back(INT_MAX);\n\t\tint prev2 = 0;\n\t\tfor(map<int,int>::iterator it = result[0].begin() ; it != result[0].end() ; ++it){\n\t\t\tint thisLevel = it->first;\n\t\t\tint thisCount = it->second + prev2;\n\t\t\tint anotherCount = *lower_bound(u.begin(),u.end(),R-thisCount);\n\t\t\tif(anotherCount != INT_MAX){\n\t\t\t\tint anotherLevel = from[ lower_bound(u.begin(),u.end(),R-thisCount) - u.begin() ] ;\n\t\t\t\tans = min(ans,thisLevel+anotherLevel);\n\t\t\t}\n\t\t\tprev2 += it->second;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#define INF (1 << 29)\ntypedef pair<int, int> P; \ntypedef pair<int, P> F;\nint xs[] = {-1, 0, 1, 0}, ys[] = {0, 1, 0, -1};\nvector<int> input_djk(){\n  int w, h, x ,y;\n  cin >> w >> h >> x >> y;\n  x--,y--;\n  int dist[w][h], level[w][h];\n  for(int i = 0;i < w;i++)\n    for(int j = 0;j < h;j++)\n      dist[i][j] = INF;\n  for(int j = 0;j < h;j++){\n    for(int i = 0;i < w;i++){\n      cin >> level[i][j];\n    }\n  }\n  priority_queue<F, vector<F>, greater<F> > pq;\n  dist[x][y] = 1;\n  pq.push(F(1, P(x, y)));\n  while(!pq.empty()){\n    F tmp = pq.top();pq.pop();\n    int tx = tmp.second.first, ty = tmp.second.second;\n    if(dist[tx][ty] < tmp.first)continue;\n    for(int i = 0;i < 4;i++){\n      if(tx + xs[i] < 0 || tx + xs[i] >= w || ty + ys[i] < 0 || ty + ys[i] >= h)continue;\n      tx += xs[i], ty += ys[i];\n      if(dist[tx][ty] > max(tmp.first, level[tx][ty])){\n\tdist[tx][ty] = max(tmp.first, level[tx][ty]);\n\tpq.push(F(dist[tx][ty], P(tx, ty)));\n      }\n      tx -= xs[i], ty -= ys[i];\n    }\n  }\n  vector<int> res;\n  for(int i = 0;i < h;i++)\n    for(int j = 0;j < w;j++)\n      res.push_back(dist[j][i]);\n   \n  sort(res.begin(), res.end());\n  return res;\n}\n\nint gs(vector<int> x, int r){\n  if(r == 0)return 0;\n  else return x[r - 1];\n}\n\n\nint solve(vector<int> a, vector<int> b, int r){\n  int res = INF;\n  for(int i = min(r,(int) a.size());i >= 0 && b.size() >= r - i;i--){\n    res = min(res, gs(a, i) + gs(b, r - i));\n  }\n  return res;\n}\n\nint main(){\n  while(true){\n    int r;\n    cin >> r;\n    if(r == 0)return 0;\n    vector<int> a, b;\n    a = input_djk();\n    b = input_djk();\n    cout << solve(a, b, r) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T1,typename T2> void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int r;\n  while(cin>>r,r){\n    vector<Int> w(2),h(2),x(2),y(2);\n    vector<vector<vector<Int> > > a(2);\n    for(Int k=0;k<2;k++){\n      cin>>w[k]>>h[k]>>x[k]>>y[k];\n      x[k]--;y[k]--;\n      a[k]=vector<vector<Int> >(h[k],vector<Int>(w[k]));\n      for(Int i=0;i<h[k];i++)\n\tfor(Int j=0;j<w[k];j++)\n\t  cin>>a[k][i][j];\n    }\n    auto dijkstra=[](Int h,Int w,Int y,Int x,auto &a){\n      auto dp=a;\n      const Int INF = 1e15;\n      for(Int i=0;i<h;i++)\n\tfor(Int j=0;j<w;j++)\n\t  dp[i][j]=INF;\n\n      using T = tuple<Int, Int, Int>;\n      priority_queue<T,vector<T>,greater<T> > pq;\n      \n      dp[y][x]=a[y][x];\n      pq.emplace(dp[y][x],y,x);\n\n      Int dy[]={0,0,1,-1};\n      Int dx[]={1,-1,0,0};\n      auto in=[&](Int y,Int x){return 0<=y&&y<h&&0<=x&&x<w;};\n      \n      while(!pq.empty()){\n\tInt d;\n\ttie(d,y,x)=pq.top();pq.pop();\n\tif(dp[y][x]<d) continue;\n\t//cout<<y<<\" \"<<x<<\":\"<<d<<endl;\n\tfor(Int k=0;k<4;k++){\n\t  Int ny=y+dy[k],nx=x+dx[k];\n\t  if(!in(ny,nx)||dp[ny][nx]<=max(dp[y][x],a[ny][nx])) continue;\n\t  dp[ny][nx]=max(dp[y][x],a[ny][nx]);\n\t  pq.emplace(dp[ny][nx],ny,nx);\n\t}\n      }\n      \n      vector<Int> v(h*w);\n      for(Int i=0;i<h;i++)\n\tfor(Int j=0;j<w;j++)\n\t  v[i*w+j]=dp[i][j];\n      sort(v.begin(),v.end());\n      return v;\n    };\n    auto v=dijkstra(h[0],w[0],y[0],x[0],a[0]);\n    auto u=dijkstra(h[1],w[1],y[1],x[1],a[1]);\n    v.emplace(v.begin(),0);\n    u.emplace(u.begin(),0);\n    \n    Int n=v.size(),m=u.size();\n    Int ans=1e15;\n    for(Int i=0;i<n;i++){\n      Int j=r-i;\n      if(0<=j&&j<m) chmin(ans,v[i]+u[j]);\n    }\n    for(Int i=0;i<m;i++){\n      Int j=r-i;\n      if(0<=j&&j<n) chmin(ans,v[j]+u[i]);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<functional>\n#include<vector>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\n#define T1 1000000LL\n#define T2 1000LL\n\nlong long W, H, X, Y, R;\nlong long x[1000][1000];\nlong long d[1000][1000];\nlong long p1, p2, p3;\nlong long y_1[1000000], y_2[1000000], cnt, cnt2, v, minx;\n\npriority_queue<long long, vector<long long>, greater<long long>> Q, S;\n\nint main() {\n\twhile (true) {\n\t\tcnt = 1; cnt2 = 1; minx = 1145141919810LL;\n\t\tmemset(x, 51, sizeof(x));\n\t\tmemset(d, 51, sizeof(d));\n\t\tcin >> R;\n\t\tif (R == 0) { break; }\n\t\tcin >> W >> H >> X >> Y;\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tcin >> x[i][j];\n\t\t\t}\n\t\t}\n\t\td[Y][X] = 0;\n\t\tQ.push(Y*T2 + X);\n\t\twhile (!Q.empty()) {\n\t\t\tp1 = Q.top() / T1;\n\t\t\tp2 = (Q.top() / T2) % T2;\n\t\t\tp3 = Q.top() % T2;\n\t\t\tif (max(p1, x[p2 - 1][p3]) < d[p2 - 1][p3]) {\n\t\t\t\td[p2 - 1][p3] = max(p1, x[p2 - 1][p3]);\n\t\t\t\tS.push(d[p2 - 1][p3] * T1 + (p2 - 1)*T2 + p3);\n\t\t\t}\n\t\t\tif (max(p1, x[p2 + 1][p3]) < d[p2 + 1][p3]) {\n\t\t\t\td[p2 + 1][p3] = max(p1, x[p2 + 1][p3]);\n\t\t\t\tS.push(d[p2 + 1][p3] * T1 + (p2 + 1)*T2 + p3);\n\t\t\t}\n\t\t\tif (max(p1, x[p2][p3 - 1]) < d[p2][p3 - 1]) {\n\t\t\t\td[p2][p3 - 1] = max(p1, x[p2][p3 - 1]);\n\t\t\t\tS.push(d[p2][p3 - 1] * T1 + p2*T2 + (p3 - 1));\n\t\t\t}\n\t\t\tif (max(p1, x[p2][p3 + 1]) < d[p2][p3 + 1]) {\n\t\t\t\td[p2][p3 + 1] = max(p1, x[p2][p3 + 1]);\n\t\t\t\tS.push(d[p2][p3 + 1] * T1 + p2*T2 + (p3 + 1));\n\t\t\t}\n\t\t\tQ.pop();\n\t\t\twhile (!S.empty()) {\n\t\t\t\tQ.push(S.top());\n\t\t\t\tS.pop();\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\ty_1[cnt] = d[i][j];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tmemset(x, 51, sizeof(x));\n\t\tmemset(d, 51, sizeof(d));\n\t\tcin >> W >> H >> X >> Y;\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tcin >> x[i][j];\n\t\t\t}\n\t\t}\n\t\td[Y][X] = 0;\n\t\tQ.push(Y*T2 + X);\n\t\twhile (!Q.empty()) {\n\t\t\tp1 = Q.top() / T1;\n\t\t\tp2 = (Q.top() / T2) % T2;\n\t\t\tp3 = Q.top() % T2;\n\t\t\tif (max(p1, x[p2 - 1][p3]) < d[p2 - 1][p3]) {\n\t\t\t\td[p2 - 1][p3] = max(p1, x[p2 - 1][p3]);\n\t\t\t\tS.push(d[p2 - 1][p3] * T1 + (p2 - 1)*T2 + p3);\n\t\t\t}\n\t\t\tif (max(p1, x[p2 + 1][p3]) < d[p2 + 1][p3]) {\n\t\t\t\td[p2 + 1][p3] = max(p1, x[p2 + 1][p3]);\n\t\t\t\tS.push(d[p2 + 1][p3] * T1 + (p2 + 1)*T2 + p3);\n\t\t\t}\n\t\t\tif (max(p1, x[p2][p3 - 1]) < d[p2][p3 - 1]) {\n\t\t\t\td[p2][p3 - 1] = max(p1, x[p2][p3 - 1]);\n\t\t\t\tS.push(d[p2][p3 - 1] * T1 + p2*T2 + (p3 - 1));\n\t\t\t}\n\t\t\tif (max(p1, x[p2][p3 + 1]) < d[p2][p3 + 1]) {\n\t\t\t\td[p2][p3 + 1] = max(p1, x[p2][p3 + 1]);\n\t\t\t\tS.push(d[p2][p3 + 1] * T1 + p2*T2 + (p3 + 1));\n\t\t\t}\n\t\t\tQ.pop();\n\t\t\twhile (!S.empty()) {\n\t\t\t\tQ.push(S.top());\n\t\t\t\tS.pop();\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\ty_2[cnt2] = d[i][j];\n\t\t\t\tcnt2++;\n\t\t\t}\n\t\t}\n\n\t\tsort(y_1, y_1 + cnt);\n\t\tsort(y_2, y_2 + cnt2);\n\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\tv = R - i;\n\t\t\tif (v >= 0 && v < cnt2) {\n\t\t\t\tminx = min(minx, y_1[i] + y_2[v]);\n\t\t\t}\n\t\t}\n\t\tcout << minx << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <unordered_set>\n\nusing namespace std;\n\n#define INF (1e9)\n\ntypedef pair<int,int> P;\ntypedef pair<int, pair<int,int> > PP;\n\nclass HashP {\n    public :\n    size_t operator()(const P& key) const {\n        return (size_t)(key.first*5000+key.second);\n    }\n};\n\n\nvoid solve(int R) {\n    vector<P> vis[2];\n\n    for(int r=0; r<2; ++r) {\n        int W,H,X,Y;\n        vector<vector<int> > L;\n        cin >> W >> H >> X >> Y;\n\n        vector<int> temp(W+2,INF);\n        L.push_back(temp);\n        for(int h=1; h<=H; ++h) {\n            for(int w=1; w<=W; ++w) {\n                cin >> temp[w];\n            }\n            L.push_back(temp);\n        }\n        fill(temp.begin(),temp.end(),INF);\n        L.push_back(temp);\n\n        priority_queue<PP,vector<PP>,greater<PP> > q[2];\n        bool flag=true;\n        int lev=0;\n        int cnt=0;\n        unordered_set<P,HashP> pushed[2];\n\n        q[r].push(PP(L[Y][X],P(X,Y)));\n        pushed[r].insert(P(X,Y));\n\n        while(!q[r].empty()) {\n            PP pp=q[r].top();\n            int pplev=pp.first;\n            int ppx=pp.second.first;\n            int ppy=pp.second.second;\n            if(L[ppy][ppx]==INF) continue;\n            if(lev<pplev) {\n                vis[r].push_back(P(cnt,lev));\n                if(cnt>R) {\n                    flag=false;\n                    break;\n                }\n                lev=pplev;\n                continue;\n            }\n            q[r].pop();\n            L[ppy][ppx]=INF;\n            ++cnt;\n            int dx[4]={-1,0,1,0};\n            int dy[4]={0,1,0,-1};\n            for(int i=0; i<4; ++i) {\n                if(L[ppy+dy[i]][ppx+dx[i]]!=INF && pushed[r].count(P(ppx+dx[i],ppy+dy[i]))==0) {\n                    q[r].push(PP(L[ppy+dy[i]][ppx+dx[i]],P(ppx+dx[i],ppy+dy[i])));\n                    pushed[r].insert(P(ppx+dx[i],ppy+dy[i]));\n                }\n            }\n        }\n        if(flag) vis[r].push_back(P(cnt,lev));\n        L.clear();\n    }\n\n    int ans=INF;\n    for(vector<P>::iterator itr0=vis[0].begin(); itr0!=vis[0].end(); ++itr0) {\n        vector<P>::iterator itr1=lower_bound(vis[1].begin(),vis[1].end(),P(R-itr0->first,-1));\n        if(itr1==vis[1].end()) continue;\n        ans=min(ans,itr0->second+itr1->second);\n    }\n\n    cout << ans << endl;\n\n\n    return;\n}\n\n\nint main() {\n    int R;\n    while(true) {\n        cin >> R;\n        if(R==0) break;\n        solve(R);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define MP make_pair\n#define PB push_back\n#define FI first\n#define SE second\n#define MAX_K 200000\ntypedef pair< int,pair<int,pair<int, int> > > P3;\ntypedef pair<int, pair<int, int> > P2;\ntypedef pair<int, int> P1;\nstatic const int INF = 1ll<<60;\nstatic const int dx[] = { 1, -1, 0, 0, };\nstatic const int dy[] = { 0, 0, 1, -1 };\n\nint W1,H1,W2,H2,R;\nint sx1,sy1,sx2,sy2;\nint fe1[550][550],fe2[550][550];\nvector<int> V;\nvector<int> S;\nmap<int,int> level[2];\nint ans=INF;\nint visit[550][550];\n\nvoid input(int* W,int* H,int* sx,int* sy,int fe[550][550]){\n    scanf(\"%d%d%d%d\",W,H,sx,sy);\n    for(int y=0;y<*H;++y)\n        for(int x=0;x<*W;++x)scanf(\"%d\",&fe[y][x]);\n}\n\nvoid bfs(int num,int W,int H,int sx,int sy,int fe[550][550]){\n    memset(visit,0,sizeof(visit));\n    priority_queue<P2,vector<P2>,greater<P2> > que;\n    que.push(P2(fe[sy-1][sx-1],P1(sx-1,sy-1)));\n    while(!que.empty()){\n        P2 p = que.top();\n        que.pop();\n        int cost=p.first;\n        int x=p.second.first;\n        int y=p.second.second;\n        if(visit[y][x]==1)continue;\n        visit[y][x]=1;\n        level[num][cost]++;\n        for(int i=0;i<4;++i){\n            int nx=x+dx[i],ny=y+dy[i];\n            if(nx<0||nx>=W||ny<0||ny>=H||visit[ny][nx])continue;\n            int maxcost=max(cost,fe[ny][nx]);\n            que.push(P2(maxcost,P1(nx,ny)));\n        }\n    }\n}\n\nsigned main(){\n    cin>>R;\n    input(&W1,&H1,&sx1,&sy1,fe1);\n    input(&W2,&H2,&sx2,&sy2,fe2);\n    bfs(0,W1,H1,sx1,sy1,fe1);\n    bfs(1,W2,H2,sx2,sy2,fe2);\n\n    int sum1=0;\n\n    for(map<int,int>::iterator i=level[0].begin();i!=level[0].end();++i){\n        S.PB(i->first);\n        V.PB(i->second+sum1);\n        sum1+=i->second;\n    }\n\n    int sum2=0;\n\n    for(map<int,int>::iterator i=level[1].begin();i!=level[1].end();++i){\n        int cost = i->first;\n        int cnt2 = i->second+sum2;\n        int cnt1 = *lower_bound(V.begin(),V.end(),R-cnt2);\n        ans=min(ans,cost+S[lower_bound(V.begin(),V.end(),R-cnt2)-V.begin()]);\n        sum2+=i->second;\n    }\n\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n\nusing namespace std;\nconst int FIELD_SIZE = 502 * 502; // ÔºÌ½ß+2·é\nconst int FIELD_WIDTH = 502;\nint field[FIELD_SIZE];\t// ìÆpÌæ\n\ntypedef struct LevelRoomRelation {\n\tint level, room;\t// FØx, ®\n} LevelRoomRelation;\n\nint fill(int r, int p, list<int> *nexts){\n\tint count = 1;\n\tfield[p] = 0;\n\tif(field[p + 1] == 0){\t\t\t// ÊßÏÝ\n\t}else if(field[p + 1] <= r){\t// »Ì®Éüé\n\t\tcount += fill(r, p + 1, nexts);\n\t}else{\t\t\t\t\t\t\t// ãÅüéXgÖÇÁ\n\t\tlist<int>::iterator it = nexts->begin();\n\t\twhile(it != nexts->end()){\n\t\t\tif(field[*it] >= field[p + 1]){ break; }\n\t\t\tit++;\n\t\t}\n\t\tnexts->insert(it, p + 1);\n\t}\n\tif(field[p - 1] == 0){\t\t\t// ÊßÏÝ\n\t}else if(field[p - 1] <= r){\t// »Ì®Éüé\n\t\tcount += fill(r, p - 1, nexts);\n\t}else{\t\t\t\t\t\t\t// ãÅüéXgÖÇÁ\n\t\tlist<int>::iterator it = nexts->begin();\n\t\twhile(it != nexts->end()){\n\t\t\tif(field[*it] >= field[p - 1]){ break; }\n\t\t\tit++;\n\t\t}\n\t\tnexts->insert(it, p - 1);\n\t}\n\tif(field[p + FIELD_WIDTH] == 0){\t\t// ÊßÏÝ\n\t}else if(field[p + FIELD_WIDTH] <= r){\t// »Ì®Éüé\n\t\tcount += fill(r, p + FIELD_WIDTH, nexts);\n\t}else{\t\t\t\t\t\t\t\t\t// ãÅüéXgÖÇÁ\n\t\tlist<int>::iterator it = nexts->begin();\n\t\twhile(it != nexts->end()){\n\t\t\tif(field[*it] >= field[p + FIELD_WIDTH]){ break; }\n\t\t\tit++;\n\t\t}\n\t\tnexts->insert(it, p + FIELD_WIDTH);\n\t}\n\tif(field[p - FIELD_WIDTH] == 0){\t\t// ÊßÏÝ\n\t}else if(field[p - FIELD_WIDTH] <= r){\t// »Ì®Éüé\n\t\tcount += fill(r, p - FIELD_WIDTH, nexts);\n\t}else{\t\t\t\t\t\t\t\t\t// ãÅüéXgÖÇÁ\n\t\tlist<int>::iterator it = nexts->begin();\n\t\twhile(it != nexts->end()){\n\t\t\tif(field[*it] >= field[p - FIELD_WIDTH]){ break; }\n\t\t\tit++;\n\t\t}\n\t\tnexts->insert(it, p - FIELD_WIDTH);\n\t}\n\treturn count;\n}\n\nvoid calculateLevel(int r, list<LevelRoomRelation> *answer){\n\t// âèÌüÍ\n\tint w, h, x, y;\n\tscanf(\"%d%d%d%d\", &w, &h, &x, &y);\n\tmemset(field, 0, sizeof(int) * FIELD_SIZE);\n\tfor(int i = 1; i <= h; i++){\n\t\tfor(int j = 1; j <= w; j++){\n\t\t\tscanf(\"%d\", &(field[i * FIELD_WIDTH + j]));\n\t\t}\n\t}\n\t// vZ·é\n\tint currentLevel = 0, currentRoomCount = 0, remains = w * h;\n\tlist<int> nexts;\n\tnexts.push_back(x + y * FIELD_WIDTH);\n\tlist<int>::iterator front = nexts.begin();\n\twhile(currentRoomCount < r && remains > 0){\n\t\twhile(front != nexts.end()){\n\t\t\tcurrentLevel = field[*front];\n\t\t\tif(currentLevel != 0){ break; }\n\t\t\tfront++;\n\t\t}\n\t\twhile(front != nexts.end() && field[*front] <= currentLevel){\n\t\t\tif(field[*front] != 0){\t// Ü¾ÊßµÄ¢È¢ê\n\t\t\t\tint fillResult = fill(currentLevel, (*front), &nexts);\n\t\t\t\tcurrentRoomCount += fillResult;\n\t\t\t\tremains -= fillResult;\n\t\t\t}\n\t\t\tfront++;\n\t\t}\n\t\tLevelRoomRelation lrr;\n\t\tlrr.level = currentLevel;\n\t\tlrr.room = currentRoomCount;\n\t\tanswer->push_back(lrr);\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tint r;\n\t\tscanf(\"%d\", &r);\n\t\tif(r == 0){ break; }\n\n\t\tLevelRoomRelation lrr;\n\t\tlrr.level = 0;\n\t\tlrr.room = 0;\n\n\t\tlist<LevelRoomRelation> office1;\n\t\tcalculateLevel(r, &office1);\n\t\toffice1.insert(office1.begin(), lrr);\n\t\t{\n//\t\t\tcout << \"Office1 dump:\" << endl;\n\t\t\tlist<LevelRoomRelation>::iterator it = office1.begin();\n\t\t\twhile(it != office1.end()){\n//\t\t\t\tcout << \"Level: \" << (*it).level << \" / \" << \"Room: \" << (*it).room << endl;\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\t\tlist<LevelRoomRelation> office2;\n\t\tcalculateLevel(r, &office2);\n\t\toffice2.insert(office2.begin(), lrr);\n\t\t{\n//\t\t\tcout << \"Office2 dump:\" << endl;\n\t\t\tlist<LevelRoomRelation>::iterator it = office2.begin();\n\t\t\twhile(it != office2.end()){\n//\t\t\t\tcout << \"Level: \" << (*it).level << \" / \" << \"Room: \" << (*it).room << endl;\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\n\t\tint minLevel = 0x7fffffff;\n\t\tlist<LevelRoomRelation>::iterator it1 = office1.begin(), it2 = office2.end();\n\t\tint level2, level1 = 0;\n\t\tint roomCount2, roomCount1 = 0, roomCount;\n\t\twhile(true){\n\t\t\tif(it2 == office2.begin()){\n\t\t\t\tif(it1 == office1.end()){ break; }\n\t\t\t}else{\n\t\t\t\tit2--;\n\t\t\t}\n\t\t\tlevel2 = (*it2).level;\n\t\t\troomCount2 = (*it2).room;\n\t\t\troomCount = roomCount2 + roomCount1;\n\t\t\twhile(it1 != office1.end() && roomCount < r){\n\t\t\t\troomCount1 = (*it1).room;\n\t\t\t\troomCount = roomCount2 + roomCount1;\n\t\t\t\tlevel1 = (*it1).level;\n\t\t\t\tit1++;\n\t\t\t}\n//\t\t\tcout << \"office1: \" << level1 << \" / office2: \" << level2 << endl;\n\t\t\tif(minLevel > (level2 + level1)){\n\t\t\t\tminLevel = level2 + level1;\n\t\t\t}\n\t\t}\n\t\tcout << minLevel << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//認証レベルの小さい順に鍵を設定すると、入れる部屋が単調にふえるので、その部屋に入るための最少認証レベルが簡単に求まる。\n//と思ったら、そうでもなかった…とりあえず、ダイクストラの負の辺OK盤を使う。\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n//#define DEBUG DEBUG\n#define F first\n#define S second\nusing namespace std;\n#define MAX(x,y) (x>y?x:y)\t// ()がいります\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint R;\nint W1,H1,X1,Y1,W2,H2,X2,Y2;\nint JOI1[500][500],JOI2[500][500];\t//JOI[y][x]として入れます。\nint ADD1[501][501],ADD2[501][501];\t//入るための認証レベルの最小値(1以上)\n\nvoid Make_list1(){\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\tPP node;\n\tque.push(PP(1,P(Y1,X1)));\n\twhile(!que.empty()){\n\t\tnode = que.top();\n\t\tque.pop();\n\t\t//周り4辺を更新\n\t\tif(ADD1[node.S.F+1][node.S.S] > MAX(node.F,JOI1[node.S.F+1][node.S.S])){\n\t\t\tADD1[node.S.F+1][node.S.S] = MAX(node.F,JOI1[node.S.F+1][node.S.S]);\n\t\t\tque.push(PP(ADD1[node.S.F+1][node.S.S],P(node.S.F+1,node.S.S)));\t\n\t\t}\n\t\tif(ADD1[node.S.F][node.S.S+1] > MAX(node.F,JOI1[node.S.F][node.S.S+1])){\n\t\t\tADD1[node.S.F][node.S.S+1] = MAX(node.F,JOI1[node.S.F][node.S.S+1]);\n\t\t\tque.push(PP(ADD1[node.S.F][node.S.S+1],P(node.S.F,node.S.S+1)));\t\n\t\t}\n\t\tif(node.S.F > 0 && ADD1[node.S.F-1][node.S.S] > MAX(node.F,JOI1[node.S.F-1][node.S.S])){\n\t\t\tADD1[node.S.F-1][node.S.S] = MAX(node.F,JOI1[node.S.F-1][node.S.S]);\n\t\t\tque.push(PP(ADD1[node.S.F-1][node.S.S],P(node.S.F-1,node.S.S)));\t\n\t\t}\n\t\tif(node.S.S > 0 && ADD1[node.S.F][node.S.S-1] > MAX(node.F,JOI1[node.S.F][node.S.S-1])){\n\t\t\tADD1[node.S.F][node.S.S-1] = MAX(node.F,JOI1[node.S.F][node.S.S-1]);\n\t\t\tque.push(PP(ADD1[node.S.F][node.S.S-1],P(node.S.F,node.S.S-1)));\t\n\t\t}\n\t}\n}\nvoid Make_list2(){\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\tPP node;\n\tque.push(PP(1,P(Y2,X2)));\n\twhile(!que.empty()){\n\t\tnode = que.top();\n\t\tque.pop();\n\t\t//周り4辺を更新\n\t\tif(ADD2[node.S.F+1][node.S.S] > MAX(node.F,JOI2[node.S.F+1][node.S.S])){\n\t\t\tADD2[node.S.F+1][node.S.S] = MAX(node.F,JOI2[node.S.F+1][node.S.S]);\n\t\t\tque.push(PP(ADD2[node.S.F+1][node.S.S],P(node.S.F+1,node.S.S)));\t\n\t\t}\n\t\tif(ADD2[node.S.F][node.S.S+1] > MAX(node.F,JOI2[node.S.F][node.S.S+1])){\n\t\t\tADD2[node.S.F][node.S.S+1] = MAX(node.F,JOI2[node.S.F][node.S.S+1]);\n\t\t\tque.push(PP(ADD2[node.S.F][node.S.S+1],P(node.S.F,node.S.S+1)));\t\n\t\t}\n\t\tif(node.S.F > 0 && ADD2[node.S.F-1][node.S.S] > MAX(node.F,JOI2[node.S.F-1][node.S.S])){\n\t\t\tADD2[node.S.F-1][node.S.S] = MAX(node.F,JOI2[node.S.F-1][node.S.S]);\n\t\t\tque.push(PP(ADD2[node.S.F-1][node.S.S],P(node.S.F-1,node.S.S)));\t\n\t\t}\n\t\tif(node.S.S > 0 && ADD2[node.S.F][node.S.S-1] > MAX(node.F,JOI2[node.S.F][node.S.S-1])){\n\t\t\tADD2[node.S.F][node.S.S-1] = MAX(node.F,JOI2[node.S.F][node.S.S-1]);\n\t\t\tque.push(PP(ADD2[node.S.F][node.S.S-1],P(node.S.F,node.S.S-1)));\t\n\t\t}\n\t}\n}\nint main(){\n\tint i,j;\n\tint minest[200],mcor = 0;\n\tfor(i = 0;i < 200;i++){minest[i] = 1000000000;}\n\twhile(1){\n\t\tcin >> R;\n\t\tif(R == 0)\n\t\t\tbreak;\n\t\tcin >> W1 >> H1 >> X1 >> Y1;\n\t\tX1--;Y1--;\n\t\tfor(i = 0;i < H1;i++){\n\t\t\tfor(j = 0;j < W1;j++){\n\t\t\t\tcin >> JOI1[i][j];\n\t\t\t\tADD1[i][j] = 1000000001;\n\t\t\t}\n\t\t}\n\t\tADD1[Y1][X1] = 1;\n\t\tcin >> W2 >> H2 >> X2 >> Y2;\n\t\tX2--;Y2--;\n\t\tfor(i = 0;i < H2;i++){\n\t\t\tfor(j = 0;j < W2;j++){\n\t\t\t\tcin >> JOI2[i][j];\n\t\t\t\tADD2[i][j] = 1000000001;\n\t\t\t}\n\t\t}\n\t\tADD2[Y2][X2] = 1;\n\t\t//幅優先探索で部屋に入るための認証レベルの最小値,R部屋入るための認証レベルの最小値を記録する。\n\t\t//認証レベルの設定はWH回したほうがよい。まちがっても、部屋数に対する認証レベルを探すO(R^2logWH)解法は行わない！\n\t\t//queueを使うとO(WH)で行ける。WH*最大4方向*最大4回更新\n\t\tMake_list1();\n\t\tMake_list2();\n\t\t//認証レベルに対して入れる部屋数を考えてみよう(ヒント→認証レベルがiのとき認証レベルがi-1のとき行けた部屋はすべていける)\n\t\tstatic map<int,int> nin1,nin2;\t//認証レベル,部屋数\n\t\tnin1.insert(make_pair(0,0));\n\t\tfor(i = 0;i < H1;i++){\n\t\t\tfor(j = 0;j < W1;j++){\n\t\t\t\tif(nin1.find(ADD1[i][j]) == nin1.end()){\n\t\t\t\t\tnin1.insert(make_pair(ADD1[i][j],1));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tnin1[ADD1[i][j]]++;\t\t//2番目のキーをプラスしましょう。\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnin2.insert(make_pair(0,0));\n\t\tfor(i = 0;i < H2;i++){\n\t\t\tfor(j = 0;j < W2;j++){\n\t\t\t\tif(nin2.find(ADD2[i][j]) == nin2.end()){\n\t\t\t\t\tnin2.insert(make_pair(ADD2[i][j],1));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tnin2[ADD2[i][j]]++;\t\t//2番目のキーをプラスしましょう。\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmap<int,int>::iterator it,bit;\n\t\tit = nin1.begin();\n\t\tfor(it++;it != nin1.end();it++){\n\t\t\tbit = it;\n\t\t\tbit--;\n\t\t\t(*it).S += (*bit).S;\n\t\t}\n\t\tit = nin2.begin();\n\t\tfor(it++;it != nin2.end();it++){\n\t\t\tbit = it;\n\t\t\tbit--;\n\t\t\t(*it).S += (*bit).S;\n\t\t}\n\t\t//入れる部屋数にたいする認証レベルの最小値を考えてみよう\n\t\tstatic int R1[100001],R2[100001];\n\t\tfor(i = 0;i < R+1;i++){R1[i] = 1000000000;R2[i] = 1000000000;}\n\t\tit = nin1.begin();\n\t\tR1[0] = 0;\n\t\tit++;\n\t\tfor(;it != nin1.end();it++){\n\t\t\tif((*it).S > R)\n\t\t\t\t(*it).S = R;\n\t\t\tbit = it;\n\t\t\tbit--;\n\t\t\tfor(i = (*it).S;i > (*bit).S;i--){\n\t\t\t\tif(R1[i] > (*it).F)\n\t\t\t\t\tR1[i] = (*it).F;\n\t\t\t}\n\t\t}\n\t\tit = nin2.begin();\n\t\tR2[0] = 0;\n\t\tit++;\n\t\tfor(;it != nin2.end();it++){\n\t\t\tif((*it).S > R)\n\t\t\t\t(*it).S = R;\n\t\t\tbit = it;\n\t\t\tbit--;\n\t\t\tfor(i = (*it).S;i > (*bit).S;i--){\n\t\t\t\tif(R2[i] > (*it).F)\n\t\t\t\t\tR2[i] = (*it).F;\n\t\t\t}\n\t\t}\n\t\t//デバッグ\n#ifdef DEBUG\n\t\tfor(i = 0;i < H1;i++){\n\t\t\tfor(j = 0;j < W1;j++){\n\t\t\t\tcout << ADD1[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tfor(i = 0;i < H2;i++){\n\t\t\tfor(j = 0;j < W2;j++){\n\t\t\t\tcout << ADD2[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << \"1部屋目\" << endl;\n\t\tfor(it = nin1.begin();it != nin1.end();it++){\n\t\t\tcout << (*it).F << \" \" << (*it).S << endl;\n\t\t}\n\t\tcout << \"2部屋目\" << endl;\n\t\tfor(it = nin2.begin();it != nin2.end();it++){\n\t\t\tcout << (*it).F << \" \" << (*it).S << endl;\n\t\t}\n\t\t//認証レベル\n\t\tfor(i = 0;i < H1;i++){\n\t\t\tfor(j = 0;j < W1;j++){\n\t\t\t\tcout << R1[i*W1+j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tfor(i = 0;i < H2;i++){\n\t\t\tfor(j = 0;j < W2;j++){\n\t\t\t\tcout << R2[i*W2+j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n#endif\n\t\t//探索(O(R))\n\t\tfor(i = 0;i < R+1;i++){\n\t\t\tif(minest[mcor] > R1[i]+R2[R-i])\n\t\t\t\tminest[mcor] = R1[i]+R2[R-i];\n\t\t}\t\t\n\t\t//使った分を初期化\n\t\tfor(i = 0;i < H1;i++){\n\t\t\tfor(j = 0;j < W1;j++){\n\t\t\t\tJOI1[i][j] = 0;\n\t\t\t\tADD1[i][j] = 100000001;\n\t\t\t}\n\t\t}\n\t\tfor(i = 0;i < H2;i++){\n\t\t\tfor(j = 0;j < W2;j++){\n\t\t\t\tJOI2[i][j] = 0;\n\t\t\t\tADD2[i][j] = 100000001;\n\t\t\t}\n\t\t}\n\t\tnin1.clear();\n\t\tnin2.clear();\n\t\t//カーソル移動\n\t\tmcor++;\n\t}\n\tfor(i = 0;i < mcor;i++){\n\t\tcout << minest[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define POWT(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nconst pii Dir[8] = { //?????????\n\t{ 0,1 },{ 0,-1 },{ 1,0 },{ -1,0 },\n\t{ 1,1 },{ 1,-1 },{ -1,-1 },{ -1,1 }\n};\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\n\nsigned main() {\n\tint r;\n\n\twhile (scanf(\"%d\", &r)) {\n\t\tif (r == 0)\n\t\t\tbreak;\n\t\tint w, h, x, y;\n\t\tscanf(\"%d %d %d %d\", &w, &h, &y, &x);\n\t\tx--; y--;\n\t\tvector<vector<int>> m(h, vector<int>(w));\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tscanf(\"%d\", &m[i][j]);\n\t\t\t}\n\t\t}\n\t\tint w2, h2, x2, y2;\n\t\tscanf(\"%d %d %d %d\", &w2, &h2, &y2, &x2);\n\t\tx2--; y2--;\n\t\tvector<vector<int>> m2(h2, vector<int>(w2));\n\n\t\tREP(i, h2) {\n\t\t\tREP(j, w2) {\n\t\t\t\tscanf(\"%d\", &m2[i][j]);\n\t\t\t}\n\t\t}\n\t\tpriority_queue<pair<int, pii>, vector<pair<int, pii>>, greater<pair<int, pii>>> que;\n\n\t\tque.push({ 1,{ x,y } });\n\n\t\tmap<int, int> mcount;\n\t\tvector<vector<int>> al(h, vector<int>(w));\n\t\twhile (que.size()) {\n\t\t\tint  p = que.top().first;\n\t\t\tpii cur = que.top().second;\n\t\t\tque.pop();\n\t\t\tif (al[cur.first][cur.second])\n\t\t\t\tcontinue;\n\t\t\tal[cur.first][cur.second] = 1;\n\t\t\tmcount[p]++;\n\n\t\t\tREP(i, 4) {\n\t\t\t\tpii next = { cur.first + Dir[i].first, cur.second + Dir[i].second };\n\t\t\t\tif (RANGE(next.first, 0, h - 1) && RANGE(next.second, 0, w - 1)) {\n\t\t\t\t\tif (!al[next.first][next.second]) {\n\t\t\t\t\t\tque.push({ max(p,m[next.first][next.second]),next });\n\t\t\t\t\t\t//al[next.first][next.second] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<pii> cou;//????????????°??????¬??????\n\t\tfor (auto cur : mcount) {\n\t\t\tcou.push_back({ cur.second,cur.first });\n\t\t}\n\t\trep(i, 1, cou.size()) {\n\t\t\tcou[i].first += cou[i - 1].first;\n\t\t}\n\t\trep(i, 1, cou.size()) {\n\t\t\tif (cou[i].first == cou[i - 1].first) {\n\t\t\t\tif (cou[i].second > cou[i - 1].second)\n\t\t\t\t\tcou.erase(cou.begin() + i);\n\t\t\t\telse\n\t\t\t\t\tcou.erase(cou.begin() + i - 1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\n\t\tmcount.clear();\n\t\tal.swap(vector<vector<int>>(h2, vector<int>(w2)));\n\t\tque.push({ 1,{ x2,y2 } });\n\t\twhile (que.size()) {\n\t\t\tint  p = que.top().first;\n\t\t\tpii cur = que.top().second;\n\t\t\tque.pop();\n\t\t\tif (al[cur.first][cur.second])\n\t\t\t\tcontinue;\n\t\t\tal[cur.first][cur.second] = 1;\n\t\t\tmcount[p]++;\n\n\t\t\tREP(i, 4) {\n\t\t\t\tpii next = { cur.first + Dir[i].first, cur.second + Dir[i].second };\n\t\t\t\tif (RANGE(next.first, 0, h2 - 1) && RANGE(next.second, 0, w2 - 1)) {\n\t\t\t\t\tif (!al[next.first][next.second]) {\n\t\t\t\t\t\tque.push({ max(p,m2[next.first][next.second]),next });\n\t\t\t\t\t\t//al[next.first][next.second] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<pii> cou2;\n\t\tfor (auto cur : mcount) {\n\t\t\tcou2.push_back({ cur.second,cur.first });\n\t\t}\n\t\trep(i, 1, cou2.size()) {\n\t\t\tcou2[i].first += cou2[i - 1].first;\n\t\t}\n\t\trep(i, 1, cou2.size()) {\n\t\t\tif (cou2[i].first == cou2[i - 1].first) {\n\t\t\t\tif (cou2[i].second > cou2[i - 1].second)\n\t\t\t\t\tcou2.erase(cou2.begin() + i);\n\t\t\t\telse\n\t\t\t\t\tcou2.erase(cou2.begin() + i - 1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\n\t\tint Min = INT_MAX;\n\t\tcou.insert(cou.begin(), { 0,0 });\n\t\tcou2.insert(cou2.begin(), { 0,0 });\n\t\tREP(i, cou.size()) {\n\t\t\tauto itr = upper_bound(ALL(cou2), make_pair(r - cou[i].first, 0));\n\t\t\tif (itr != cou2.end()) {\n\t\t\t\tMin = min(Min, itr->second + cou[i].second);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", Min);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\ntypedef pair<int,Pi> PP;\n\nconst int INF=1000000000;\nconst long long int INF_=1000000000000000000;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\ninline bool IsIn(int y,int x,int h,int w){\n\treturn 0<=y&&y<h&&0<=x&&x<w;\n}\n\nvoid BFS(vector<vector<int> > &f,vector<vector<int> > &l,int sy,int sx,int h,int w){\n\tvector<vector<int> > done(h,vector<int>(w));\n\tvector<vector<int> > done_(h,vector<int>(w));\n\tl[sy][sx]=1;\n\tdone[sy][sx]=done_[sy][sx]=1;\n\tqueue<Pi> que;\n\tREP(i,0,4){\n\t\tint ny=sy+dy[i],nx=sx+dx[i];\n\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\tdone_[ny][nx]=1;\n\t\tque.push(Pi(ny,nx));\n\t}\n\twhile(!que.empty()){\n\t\tPi p=que.front();\n\t\tque.pop();\n\t\tdone[p.F_][p.S_]=1;\n\t\tbool flag=true;\n\t\tint tmp=INF;\n\t\tREP(i,0,4){\n\t\t\tint ny=p.F_+dy[i],nx=p.S_+dx[i];\n\t\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\t\tif(done[ny][nx]==1) tmp=min(tmp,l[ny][nx]);\n\t\t\tif(done[ny][nx]==1&&l[ny][nx]>=f[p.F_][p.S_]) flag=false;\n\t\t\tif(done_[ny][nx]!=1){\n\t\t\t\tdone_[ny][nx]=1;\n\t\t\t\tque.push(Pi(ny,nx));\n\t\t\t}\n\t\t}\n\t\tif(flag) l[p.F_][p.S_]=f[p.F_][p.S_];\n\t\telse {\n\t\t\tif(tmp!=INF) l[p.F_][p.S_]=max(tmp,f[p.F_][p.S_]);\n\t\t\telse l[p.F_][p.S_]=f[p.F_][p.S_];\n\t\t}\n\t}\n}\n\n/*\nvoid Djikstra(vector<vector<int> > &f,vector<vector<int> > &l,int sy,int sx,int h,int w){\n\tvector<vector<bool> > used(h,vector<bool>(w,false));\n\tREP(y,0,h) fill(l[y].begin(),l[y].end(),INF);\n\tl[sy][sx]=1;\n\twhile(true){\n\t\tPi v(-1,-1);\n\t\tREP(y,0,h){\n\t\t\tREP(x,0,w){\n\t\t\t\tif(!used[y][x]&&((v.F_==-1&&v.S_==-1)||l[y][x]<l[v.F_][v.S_])){\n\t\t\t\t\tv.F_=y;\n\t\t\t\t\tv.S_=x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(v.F_==-1&&v.S_==-1) break;\n\t\tused[v.F_][v.S_]=true;\n\t\tREP(i,0,4){\n\t\t\tint ny=v.F_+dy[i],nx=v.S_+dx[i];\n\t\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\t\tl[ny][nx]=min(l[ny][nx],max(f[ny][nx],l[v.F_][v.S_]));\n\t\t}\n\t}\n}\n*/\n\nvoid Djikstra(vector<vector<int> > &f,vector<vector<int> > &l,int sy,int sx,int h,int w){\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\tREP(y,0,h) fill(l[y].begin(),l[y].end(),INF);\n\tl[sy][sx]=1;\n\tque.push(PP(1,Pi(sy,sx)));\n\twhile(!que.empty()){\n\t\tPP p=que.top(); que.pop();\n\t\tPi v=p.S_;\n\t\tif(l[v.F_][v.S_]<p.F_) continue;\n\t\tREP(i,0,4){\n\t\t\tint ny=v.F_+dy[i],nx=v.S_+dx[i];\n\t\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\t\tif(l[ny][nx]>max(f[ny][nx],l[v.F_][v.S_])){\n\t\t\t\tl[ny][nx]=max(f[ny][nx],l[v.F_][v.S_]);\n\t\t\t\tque.push(PP(l[ny][nx],Pi(ny,nx)));\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline int f(int x){\n\tif(x==0) return 1;\n\telse if(x==1) return 0;\n}\n\nvoid solve(){\n\tint R;\n\twhile(cin >> R&&R){\n\t\tint W[2],H[2],X[2],Y[2];\n\t\tvector<vector<int> > field[2];\n\t\tvector<vector<int> > level[2];\n\t\tint max_[2]={};\n\t\tREP(i,0,2){\n\t\t\tcin >> W[i] >> H[i] >> X[i] >> Y[i];\n\t\t\t--X[i]; --Y[i];\n\t\t\tfield[i].resize(H[i]);\n\t\t\tlevel[i].resize(H[i]);\n\t\t\tREP(j,0,H[i]){\n\t\t\t\tfield[i][j].resize(W[i]);\n\t\t\t\tlevel[i][j].resize(W[i]);\n\t\t\t}\n\t\t\tREP(y,0,H[i]) REP(x,0,W[i]){\n\t\t\t\tcin >> field[i][y][x];\n\t\t\t\tmax_[i]=max(max_[i],field[i][y][x]);\n\t\t\t}\n\t\t\tDjikstra(field[i],level[i],Y[i],X[i],H[i],W[i]);\n\t\t\t/*\n\t\t\tcout << endl << endl;\n\t\t\tREP(y,0,H[i]){\n\t\t\t\tREP(x,0,W[i]) cout << level[i][y][x] << ' ';\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\t/*\n\t\tvector<unsigned int> s[2];\n\t\tREP(i,0,2){\n\t\t\ts[i].resize(max_[i]+1);\n\t\t\tREP(y,0,H[i]) REP(x,0,W[i]) ++s[i][level[i][y][x]];\n\t\t\tREP(j,1,max_[i]+1) s[i][j]+=s[i][j-1];\n\t\t}\n\t\tint result=INF;\n\t\tREP(i,0,2){\n\t\t\tfor(int j=0; j<=max_[i]&&j<=result; ++j){\n\t\t\t\tint idx=(int)(lower_bound(s[i].begin(),s[i].end(),R-s[f(i)][j])-s[i].begin());\n\t\t\t\tif(!(0<=idx&&idx<=max_[i])) continue;\n\t\t\t\tresult=min(result,j+idx);\n\t\t\t}\n\t\t}\n\t\tcout << result << endl;\n\t\t*/\n\t\tmap<int,int> s[2];\n\t\tvector<int> idx[2],num[2];\n\t\tREP(i,0,2){\n\t\t\tREP(y,0,H[i]) REP(x,0,W[i]) ++s[i][level[i][y][x]];\n\t\t\tauto it=s[i].begin();\n\t\t\tidx[i].push_back(0);\n\t\t\tnum[i].push_back(0);\n\t\t\tidx[i].push_back(it->F_);\n\t\t\tnum[i].push_back(it->S_);\n\t\t\tauto prev=it;\n\t\t\t++it;\n\t\t\tfor(; it!=s[i].end(); ++it,++prev){\n\t\t\t\tit->S_+=prev->S_;\n\t\t\t\t//cout << it->F_ << ' ' << it->S_ << endl;\n\t\t\t\tidx[i].push_back(it->F_);\n\t\t\t\tnum[i].push_back(it->S_);\n\t\t\t}\n\t\t}\n\t\tint result=INF;\n\t\t/*\n\t\tcout << endl;\n\t\tREP(i,0,2) REP(j,0,idx[i].size()){\n\t\t\tcout << i << ' ' << idx[i][j] << ' ' << num[i][j] << endl;\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\t\tREP(i,0,2) REP(j,0,idx[i].size()){\n\t\t\tint tmp=(int)(lower_bound(num[f(i)].begin(),num[f(i)].end(),R-num[i][j])-num[f(i)].begin());\n\t\t\t//cout << idx[i][tmp] << ' ' << num[i][tmp] << ' ' << idx[f(i)][j] << ' ' << num[f(i)][j] << endl;\n\t\t\tif(!(0<=tmp&&tmp<=idx[f(i)].size()-1)) continue;\n\t\t\tresult=min(result,idx[i][j]+idx[f(i)][tmp]);\n\t\t}\n\t\tcout << result << endl;\n\t}\n}\n\nint main(){\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pint;\ntypedef pair<ll, int> P;\n//typedef tuple<int,int,int> T;\nll INFL = 1000000000000000010;//10^18 = 2^60\nint INF = 2147483600;//10^9\nll MOD  = 1000000007;\nvector<int> dy = {1,-1,0,0};\nvector<int> dx = {0,0,1,-1};\nvector<ll> Ans(0);\nint solve(){\n    int R;\n    cin >> R;\n    if(R == 0)return 0;\n    int H1,W1,X1,Y1;\n    cin >> W1 >> H1 >> X1 >> Y1;\n    X1--;\n    Y1--;\n    vector<vector<ll>> mp1(H1, vector<ll>(W1));\n    vector<vector<ll>> d1(H1, vector<ll>(W1, INFL));\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            cin >> mp1[i][j];\n        }\n    }\n    \n    d1[Y1][X1] = 1;\n    priority_queue<pair<ll, pair<int, int>>> pque1;\n    pque1.push({1, {Y1, X1}});\n    \n    while(!pque1.empty()){\n        ll c;\n        int y,x;\n        c = pque1.top().first;\n        y = pque1.top().second.first;\n        x = pque1.top().second.second;\n        pque1.pop();\n        if(c > d1[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H1 && 0 <= nx && nx < W1){\n                if(d1[ny][nx] > d1[y][x]){\n                    if(d1[y][x] > mp1[ny][nx]){\n                        d1[ny][nx] = d1[y][x];\n                    }else{\n                        d1[ny][nx] = mp1[ny][nx];\n                    }\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }else if(d1[ny][nx] > d1[y][x]){\n                    d1[ny][nx] = mp1[ny][nx];\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    int H2,W2,X2,Y2;\n    cin >> W2 >> H2 >> X2 >> Y2;\n    X2--;\n    Y2--;\n    vector<vector<ll>> mp2(H2, vector<ll>(W2));\n    vector<vector<ll>> d2(H2, vector<ll>(W2, INFL));\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            cin >> mp2[i][j];\n        }\n    }\n    \n    d2[Y2][X2] = 1;\n    priority_queue<pair<ll, pair<int, int>>> pque2;\n    pque2.push({1, {Y2, X2}});\n    \n    while(!pque2.empty()){\n        ll c;\n        int y,x;\n        c = pque2.top().first;\n        y = pque2.top().second.first;\n        x = pque2.top().second.second;\n        pque2.pop();\n        if(c > d2[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H2 && 0 <= nx && nx < W2){\n                if(d2[ny][nx] > d2[y][x]){\n                    if(d2[y][x] > mp2[ny][nx]){\n                        d2[ny][nx] = d2[y][x];\n                    }else{\n                        d2[ny][nx] = mp2[ny][nx];\n                    }\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }else if(d2[ny][nx] > d2[y][x]){\n                    d2[ny][nx] = mp2[ny][nx];\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    vector<pair<ll,int>> O1(0);\n    vector<ll> COST1(0);\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            COST1.push_back(d1[i][j]);\n        }\n    }\n    sort(COST1.begin(), COST1.end());\n    COST1.push_back(INFL);\n    ll ad1 = COST1.at(0);\n    for(int i = 0; i < COST1.size(); i++){\n        if(ad1 == COST1.at(i)){\n        }else{\n            O1.push_back({ad1, i});\n            ad1 = COST1.at(i);\n        }\n    }\n    \n    vector<pair<ll,int>> O2(1);\n    O2.at(0).first = 0;\n    O2.at(0).second = 0;\n    vector<ll> COST2(0);\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            COST2.push_back(d2[i][j]);\n        }\n    }\n    sort(COST2.begin(), COST2.end());\n    COST2.push_back(INFL);\n    ll ad2 = COST2.at(0);\n    for(int i = 0; i < COST2.size(); i++){\n        if(ad2 == COST2.at(i)){\n        }else{\n            O2.push_back({ad2, i});\n            ad2 = COST2.at(i);\n        }\n    }\n    \n    \n    ll ans = INFL;\n    int right = -1;\n    for(int i = 0; i < O1.size(); i++){\n        ll cost = O1.at(i).first;\n        int rest = R - O1.at(i).second;\n        \n        if(rest > O2.at(O2.size()-1).second) continue;\n        int left = -1;\n        if(right == -1){\n            right = O2.size();\n        }\n        int mid;\n        while(right - left > 1){\n            mid = (left + right) / 2;\n            if(O2.at(mid).second >= rest){\n                right = mid;\n            }else{\n                left = mid;\n            }\n        }\n        cost += O2.at(right).first;\n        ans = min(ans, cost);\n    }\n    \n    Ans.push_back(ans);\n    solve();\n    return 0;\n}\n\nint main(void){\n    solve();\n    for(int i = 0; i < Ans.size(); i++){\n        cout << Ans.at(i) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n\n#define MAX 512\nusing namespace std;\n\ntypedef pair<int,int> pi;\ntypedef pair< int, pi > lvq;\n\nstruct lvloc{\n  int lv;\n  vector< pi > locs;\n  bool operator<(const lvloc &t)const{\n    return lv > t.lv;\n  }\n};\n\nconst int di[] = {-1,0,1,0};\nconst int dj[] = {0,1,0,-1};\nconst int infty = 1<<29;\n\nstruct Office{\n  int W,H;\n  int X,Y;\n  int M[MAX][MAX];\n  vector< pi > AuthenticationLevel;\n\n  Office():W(0),H(0),X(0),Y(0){}\n  Office(int W, int H, int X, int Y):W(W),H(H),X(X-1),Y(Y-1){}\n\n  bool isinside(pi p)const{ return 0<=p.first&&p.first<H&&0<=p.second&&p.second<W; }\n\n  void CheckSecurity(){\n    int total = 0;\n    priority_queue< lvloc > nextQ;\n    bool vis[MAX][MAX] = {{false,},};\n    lvloc init;\n    init.lv = 1;\n    init.locs.push_back( pi(Y,X) );\n    nextQ.push( init );\n\n    \n    while(!nextQ.empty()){\n      lvloc nlv = nextQ.top();\n      int newcnt = 0;\n      nextQ.pop();\n\n      queue<lvq> Q;\n      for(int i = 0; i < nlv.locs.size(); ++i){\n\t++newcnt;\n\t++total;\n\tQ.push( lvq( nlv.lv, nlv.locs[i] ) );\n\tvis[ nlv.locs[i].first ][ nlv.locs[i].second ] = true;\n      }\n      int level;\n      map< int, vector<pi> > T;\n\n      while(!Q.empty()){\n\tlvq now = Q.front();\n\tQ.pop();\n\tlevel = now.first;\n\tpi pos = now.second;\n\n\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t  pi nxpos = pi( pos.first + di[k], pos.second + dj[k] );\n\t  if( isinside( nxpos ) ){\n\t    if( M[ nxpos.first ][ nxpos.second ] <= level ){\n\t      if( !vis[ nxpos.first ][ nxpos.second ] ){\n\t\tvis[ nxpos.first ][ nxpos.second ] = true;\n\t\t++newcnt;++total;\n\t\tQ.push( lvq( level, nxpos ) );\n\t      }\n\t    }else{\n\t      if( !vis[nxpos.first][nxpos.second ] ){\n\t\tvis[nxpos.first][nxpos.second]=true;\n\t\tT[ M[ nxpos.first ][ nxpos.second ] ].push_back( nxpos );\n\t      }\n\t    }\n\t  }\n\t}\n      }\n\n      AuthenticationLevel.push_back( pi( level, total ) );\n      \n\n      for(map<int,vector<pi> >::iterator itm = T.begin();\n\t  itm != T.end(); ++itm ){\n\tlvloc nextlvloc;\n\tnextlvloc.lv = itm->first;\n\tnextlvloc.locs = itm->second;\n\tnextQ.push( nextlvloc );\n      }\n\n    }    \n  }\n};\nint binsearch( const vector< pi > & vpi, int v ){\n  int R=vpi.size();\n  int L=0;\n  int M;\n  int preM=-1;\n  while(true){\n    M=(R+L)/2;\n    if(preM==M)break;\n    if( vpi[M].second > v ){\n      R=M;\n    }else if( vpi[M].second == v ){\n      return vpi[M].first;\n    }else{\n      L=M;\n    }\n    preM=M;\n  }\n  if( vpi[M].second < v ){\n    if( M+1 < vpi.size() ) return vpi[M+1].first;\n    else return infty;\n  }else{\n    return vpi[M].first;\n  }\n}\n\nint main()\n{\n  while(true){\n    int ans = infty;\n    int R;\n    scanf(\"%d\", &R);\n    if( R == 0 ) break;\n    static Office office[2];\n    for(int x = 0; x < 2; ++x){\n      int W,H,X,Y;\n      scanf(\"%d%d%d%d\", &W, &H, &X, &Y);\n      office[x] = Office(W,H,X,Y);\n      for(int i = 0; i < H; ++i){\n\tfor(int j = 0; j < W; ++j){\n\t  scanf(\"%d\" , &office[x].M[i][j] );\n\t}\n      }\n      office[x].CheckSecurity();\n      /*      \n      cout << \"Authentication levels : Office \" << 1+x << endl;\n      for(int i = 0; i < office[x].AuthenticationLevel.size(); ++i){\n\tcout << \"Level : \" << office[x].AuthenticationLevel[i].first << \" -> \" << \n\t  office[x].AuthenticationLevel[i].second << endl;\n      }\n      */\n    }\n    ans = min( binsearch(office[0].AuthenticationLevel, R ), binsearch(office[1].AuthenticationLevel, R ) );\n    for(int i = 0; i < office[0].AuthenticationLevel.size(); ++i){\n      ans = min (ans, office[0].AuthenticationLevel[i].first + binsearch( office[1].AuthenticationLevel, R - office[0].AuthenticationLevel[i].second ) );\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,-1,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pint pair<int,int>\n#define tint tuple<int,int,int>\n#define INF 1<<29\n#define MAX 501\nusing namespace std;\n\nint R,W[2],H[2],X[2],Y[2],L[2][MAX][MAX],d[2][MAX][MAX],dd[4]={0,-1,0,1};\nmap<int,int> m[2];\nmap<int,int>::iterator ite;\n\nvoid solve(){\n for(;;){\n  cin>>R;\n  if(!R) return;\n  priority_queue<pint,vector<pint>,greater<pint>> pque;\n  FOR(i,2){\n   cin>>W[i]>>H[i]>>X[i]>>Y[i];\n   X[i]--;\n   Y[i]--;\n   FOR(j,H[i]) FOR(k,W[i]) cin>>L[i][j][k];\n   FOR(j,H[i]) FOR(k,W[i]) d[i][j][k]=INT_MAX/3;\n   d[i][X[i]][Y[i]]=1;\n   que.push(mp(1,X[i]*W[i]+Y[i]));\n   while(!que.empty()){\n    pint p=pque.top(); pque.pop();\n    int x=p.second/W[i],y=p.second-x*W[i];\n    if(d[i][x][y]<p.first) continue;\n    FOR(j,4){\n     int nx=x+dd[j],ny=y+dd[j^1];\n     if(nx<0||ny<0||nx>=H[i]||ny>=W[i]) continue;\n     if(d[i][nx][ny]>max(d[i][x][y],L[i][x][y])){\n      d[i][nx][ny]=max(d[i][x][y],L[i][x][y]);\n      pque.push(mp(d[i][nx][ny],nx*W[i]+ny));\n     }\n    }\n   }\n   FOR(j,H[i]) FOR(k,W[i]) m[i][d[i][j][k]]++;\n   for(ite=m[i].begin()+1;ite!=m[i].end();ite++){\n    m[i][ite->first]+=m[i][(ite-1)->first];\n   }\n  }\n  int mi=m[1].lower_bound(R)->first;\n  for(ite=m[0].begin();ite!=m[0].end();ite++){\n   mi=min(mi,(ite->first)+(m[1].lower_bound(R-(ite->second))->first));\n  }\n  cout<<mi<<endl;\n  FOR(i,2) map[i].clear();\n }\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint ans[2][100001], w, h, x, y, f[500][500];\nint dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nbool used[500][500];\nstruct st {\n\tint x, y, c;\n};\nbool operator<(st a, st b) {\n\treturn a.c > b.c;\n}\nint main() {\n\tint r;\n\twhile (scanf(\"%d\", &r), r) {\n\t\tfill(ans[0], ans[2], INT_MAX);\n\t\trep(i, 2) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tans[i][0] = 0;\n\t\t\tscanf(\"%d%d%d%d\", &w, &h, &y, &x);\n\t\t\tx--; y--;\n\t\t\trep(j, h)rep(k, w)scanf(\"%d\", &f[j][k]);\n\t\t\tpriority_queue<st>que;\n\t\t\tque.push({ x,y,1 });\n\t\t\tused[x][y] = true;\n\t\t\tint cnt = 0, Max = 0;\n\t\t\twhile (!que.empty()) {\n\t\t\t\tst s = que.top(); que.pop(); cnt++;\n\t\t\t\tMax = max(Max, s.c);\n\t\t\t\tans[i][cnt] = min(ans[i][cnt], Max);\n\t\t\t\tif (cnt >= r)break;\n\t\t\t\trep(j, 4) {\n\t\t\t\t\tint nx = s.x + dx[j], ny = s.y + dy[j];\n\t\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w && !used[nx][ny]) {\n\t\t\t\t\t\tused[nx][ny] = true;\n\t\t\t\t\t\tque.push({ nx,ny,f[nx][ny] });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = r - 1; j > 0; j--)\n\t\t\t\tans[i][j] = min(ans[i][j], ans[i][j + 1]);\n\t\t}\n\t\tint Min = INT_MAX;\n\t\trep(i, r + 1) {\n\t\t\tif (ans[0][i] == INT_MAX || ans[1][r - i] == INT_MAX)continue;\n\t\t\tMin = min(Min, ans[0][i] + ans[1][r - i]);\n\t\t}\n\t\tprintf(\"%d\\n\", Min);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\nusing namespace std;\n\n\nstruct NODE{\n\tint x,y,cst;\n\tNODE(int x,int y,int cst) : x(x) , y(y) , cst(cst) {}\n};\nbool operator < (const NODE &a,const NODE &b){\n\treturn a.cst > b.cst;\n}\nint room[500][500];\nbool flag[500][500];\nint from[500*500];\nint main(){\n\tint R;\n\twhile(cin >> R && R){\n\t\tmap<int,int> result[2];\n\t\tresult[0][0] = 0;\n\t\tresult[1][0] = 0;\n\t\t\n\t\tfor(int i = 0 ; i < 2 ; i++){\n\t\t\tint W,H,sx,sy;\n\t\t\tcin >> W >> H >> sx >> sy;\n\t\t\tsx--,sy--;\n\t\t\tfor(int y = 0 ; y < H ; y++)\n\t\t\t\tfor(int x = 0 ; x < W ; x++)\n\t\t\t\t\tcin >> room[y][x];\n\t\t\tpriority_queue<NODE> Q;\n\t\t\tQ.push(NODE(sx,sy,room[sy][sx]));\n\t\t\tmemset(flag,0,sizeof(flag));\n\t\t\twhile(Q.size()){\n\t\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\t\tif(flag[q.y][q.x]) continue;\n\t\t\t\telse flag[q.y][q.x] = true;\n\t\t\t\tresult[i][q.cst]++;\n\t\t\t\tint dx[] = {-1,0,1,0} , dy[] = {0,-1,0,1};\n\t\t\t\tfor(int d = 0 ; d < 4 ; d++){\n\t\t\t\t\tint tx = q.x + dx[d] , ty = q.y + dy[d];\n\t\t\t\t\tif(tx >= 0 && ty >= 0 && tx < W && ty < H && !flag[ty][tx]) Q.push(NODE(tx,ty,max(q.cst,room[ty][tx])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> u;\n\t\tint prev = 0;\n\t\tfor(map<int,int>::iterator it = result[1].begin() ; it != result[1].end() ; ++it){\n\t\t\tfrom[u.size()] = it->first;\n\t\t\tu.push_back(it->second + prev);\n\t\t\tprev = u.back();\n\t\t}\n\t\tint ans = INT_MAX;\n\t\tu.push_back(INT_MAX);\n\t\tint prev2 = 0;\n\t\tfor(map<int,int>::iterator it = result[0].begin() ; it != result[0].end() ; ++it){\n\t\t\tint thisLevel = it->first;\n\t\t\tint thisCount = it->second + prev2;\n\t\t\tint anotherCount = *lower_bound(u.begin(),u.end(),R-thisCount);\n\t\t\tif(anotherCount != INT_MAX){\n\t\t\t\tint anotherLevel = from[ lower_bound(u.begin(),u.end(),R-thisCount) - u.begin() ] ;\n\t\t\t\tans = min(ans,thisLevel+anotherLevel);\n\t\t\t}\n\t\t\tprev2 += it->second;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int,pair<int,int> > pp;\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\nint level[2][250001];\nint room[500][500];\nbool visited[500][500];\n\nint main(){\n    int r;\n    while(cin>>r,r){\n        int w,h,ex,ey;\n        int e[2];\n        for(int i=0;i<2;++i){\n            cin>>w>>h>>ex>>ey;\n            for(int j=0;j<h;++j){\n                for(int k=0;k<w;++k){\n                    cin>>room[j][k];\n                }\n            }\n            memset(visited,0,sizeof(visited));\n            visited[--ey][--ex]=1;\n            level[i][0]=0;\n            int mlevel=0,index=1;\n            priority_queue<pp,vector<pp>,greater<pp> > pq;\n            pq.push(make_pair(room[ey][ex],make_pair(ex,ey)));\n            while(!pq.empty()){\n                pp cur=pq.top();pq.pop();\n                mlevel=max(mlevel,cur.first);\n                level[i][index++]=mlevel;\n                for(int j=0;j<4;++j){\n                    int cx=cur.second.first+dx[j];\n                    int cy=cur.second.second+dy[j];\n                    if(cx>=0&&cx<w&&cy>=0&&cy<h&&visited[cy][cx]==0){\n                        visited[cy][cx]=1;\n                        pq.push(make_pair(room[cy][cx],make_pair(cx,cy)));\n                    }\n                }\n            }\n            e[i]=index-1;\n        }\n        int ans = 1000000000;\n        for(int i=0;i<=r;++i){\n            if(e[0]<r-i||e[1]<i) continue;\n            ans=min(ans,level[1][i]+level[0][r-i]);\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconstexpr int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconstexpr int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vvi = vector<vi>;\nusing vvl = vector<vl>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\ntemplate <class T> bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint r;\n\twhile (cin >> r, r) {\n\t\tvi h(2), w(2), x(2), y(2);\n\t\tvector<vvi> v(2);\n\t\tREP(i, 2) {\n\t\t\tcin >> w[i] >> h[i] >> y[i] >> x[i];\n\t\t\tx[i]--; y[i]--;\n\t\t\tvvi tmp(h[i], vi(w[i]));\n\t\t\tREP(k, h[i])REP(j, w[i]) {\n\t\t\t\tcin >> tmp[k][j];\n\t\t\t}\n\t\t\tv[i] = tmp;\n\t\t}\n\t\tvvi c(2, vi(r + 1, INF));\n\t\tREP(a, 2) {\n\t\t\tauto tmp = [&](pii l, pii r) {\n\t\t\t\treturn v[a][l.first][l.second] > v[a][r.first][r.second];\n\t\t\t};\n\t\t\tpriority_queue<pii, vector<pii>, decltype(tmp)> q(tmp);\n\t\t\tq.push({ x[a],y[a] });\n\t\t\tvvi b(h[a], vi(w[a], 0));\n\t\t\tb[x[a]][y[a]] = 1;\n\t\t\tint cnt = 0;\n\t\t\tc[a][0] = 0;\n\t\t\twhile (!q.empty()) {\n\t\t\t\tpii p = q.top(); q.pop();\n\t\t\t\tcnt++;\n\t\t\t\tchmin(c[a][min(r, cnt)], v[a][p.first][p.second]);\n\t\t\t\tREP(k, 4) {\n\t\t\t\t\tint ni = p.first + dx[2 * k], nj = p.second + dy[2 * k];\n\t\t\t\t\tif (ni < 0 || nj < 0 || ni >= h[a] || nj >= w[a] || b[ni][nj] == 1)continue;\n\t\t\t\t\tb[ni][nj] = 1;\n\t\t\t\t\tq.push({ ni,nj });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(a, 2)REP(i, r)chmax(c[a][i + 1], c[a][i]);\n\t\tint ans = INF;\n\t\tREP(i, r + 1) {\n\t\t\tchmin(ans, c[0][i] + c[1][r - i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef tuple<int,int,int> tri;\n\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint r,w,h,x,y;\nint g[555][555];\nbool vis[555][555];\n\nint main(){\n  while(cin >> r, r){\n    vector<pii> num[2];\n\n    for(int id=0;id<2;id++){\n      cin >> w >> h >> x >> y;\n      x--; y--;\n      for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++)cin >> g[i][j];\n      }\n\n      memset(vis,0,sizeof(vis));\n      vis[y][x] = true;\n      priority_queue<tri> q;\n      q.push(tri(-g[y][x],y,x));\n\n      int cnt = 0, val = 0;\n      while(q.size()){\n\tnum[id].push_back(pii(cnt,val));\n\t\n\tdo{\n\t  cnt++;\n\t  y = get<1>(q.top()); x = get<2>(q.top());\n\t  val = min(val, get<0>(q.top()) );\n\t  q.pop();\n\t  \n\t  for(int i=0;i<4;i++){\n\t    int ny = y+dy[i], nx = x+dx[i];\n\t    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n\t    if(vis[ny][nx])continue;\n\t    vis[ny][nx] = true;\n\t    q.push(tri(-g[ny][nx],ny,nx));\n\t  }\n\t}while(q.size() && get<0>(q.top()) >= val);\n      }\n      num[id].push_back(pii(cnt,val));\n    }\n    \n    int ans = 1e9, rev_ite = num[1].size() - 1;\n    for(int i=0;i<(int)num[0].size();i++){\n      while(rev_ite>=0 && num[0][i].first + num[1][rev_ite].first >= r)rev_ite--;\n      rev_ite++;\n      if(num[0][i].first + num[1][rev_ite].first >= r){\n\tans = min(ans, - num[0][i].second - num[1][rev_ite].second);\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define MP make_pair\n#define PB push_back\n#define FI first\n#define SE second\n#define MAX_K 200000\ntypedef pair< int,pair<int,pair<int, int> > > P3;\ntypedef pair<int, pair<int, int> > P2;\ntypedef pair<int, int> P1;\nstatic const int INF = 1ll<<60;\nstatic const int dx[] = { 1, -1, 0, 0, };\nstatic const int dy[] = { 0, 0, 1, -1 };\n\nint W1,H1,W2,H2,R;\nint sx1,sy1,sx2,sy2;\nint fe1[550][550],fe2[550][550];\nvector<int> V;\nvector<int> S;\nmap<int,int> level[2];\nint ans=INF;\nint visit[550][550];\n\nvoid input(int* W,int* H,int* sx,int* sy,int fe[550][550]){\n    scanf(\"%d%d%d%d\",W,H,sx,sy);\n    for(int y=0;y<*H;++y)\n        for(int x=0;x<*W;++x)scanf(\"%d\",&fe[y][x]);\n}\n\nvoid bfs(int num,int W,int H,int sx,int sy,int fe[550][550]){\n    memset(visit,0,sizeof(visit));\n    priority_queue<P2,vector<P2>,greater<P2> > que;\n    que.push(P2(fe[sy-1][sx-1],P1(sx-1,sy-1)));\n    while(!que.empty()){\n        P2 p = que.top();\n        que.pop();\n        int cost=p.first;\n        int x=p.second.first;\n        int y=p.second.second;\n        if(visit[y][x]==1)continue;\n        visit[y][x]=1;\n        level[num][cost]++;\n        for(int i=0;i<4;++i){\n            int nx=x+dx[i],ny=y+dy[i];\n            if(nx<0||nx>=W||ny<0||ny>=H)continue;\n            int maxcost=max(cost,fe[ny][nx]);\n            que.push(P2(maxcost,P1(nx,ny)));\n        }\n    }\n}\n\nsigned main(){\n    while(1){\n        cin>>R;\n        if(R==0)break;\n        input(&W1,&H1,&sx1,&sy1,fe1);\n        input(&W2,&H2,&sx2,&sy2,fe2);\n        bfs(0,W1,H1,sx1,sy1,fe1);\n        bfs(1,W2,H2,sx2,sy2,fe2);\n\n        int sum1=0;\n\n        for(map<int,int>::iterator i=level[0].begin();i!=level[0].end();++i){\n            S.PB(i->first);\n            V.PB(i->second+sum1);\n            sum1+=i->second;\n        }\n\n        int sum2=0;\n        level[0][0]=0;\n        level[1][0]=0;\n        for(map<int,int>::iterator i=level[1].begin();i!=level[1].end();++i){\n            int cost = i->first;\n            int cnt2 = i->second+sum2;\n            int cnt1 = *lower_bound(V.begin(),V.end(),R-cnt2);\n            ans=min(ans,cost+S[lower_bound(V.begin(),V.end(),R-cnt2)-V.begin()]);\n            sum2+=i->second;\n        }\n\n        cout<<ans<<endl;\n        ans=INF;\n        V.clear();\n        S.clear();\n        level[0].clear();\n        level[1].clear();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdlib>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint main(){\n  int i,j,k;\n  int n;\n  while(cin>>n&&n){\n    int a[2][502][502],w[2],h[2],sx[2],sy[2];\n    memset(a,-1,sizeof(a));\n    for(i=0;i<2;i++){\n      cin>>w[i]>>h[i]>>sx[i]>>sy[i];\n      for(j=1;j<h[i]+1;j++)\n\tfor(k=1;k<w[i]+1;k++)\n\t  cin>>a[i][k][j];\n    }\n    vector<pair<int,int> > b[2];\n    for(i=0;i<2;i++){\n      b[i].reserve(w[i]*h[i]);\n      b[i].push_back(make_pair(0,0));\n      priority_queue<pair<int,pair<int,int> >,deque<pair<int,pair<int,int> > >,greater<pair<int,pair<int,int> > > > c;\n      c.push(make_pair(1,make_pair(sx[i],sy[i])));\n      while(c.empty()==0){\n\tint p,x,y;\n\tp=c.top().first;\n\tx=c.top().second.first;\n\ty=c.top().second.second;\n\tc.pop();\n\tif(a[i][x][y]!=-1){\n\t  a[i][x][y]=-1;\n\t  if(b[i].back().first==p){\n\t    b[i].back().second++;\n\t  }else{\n\t    b[i].push_back(make_pair(p,b[i].back().second+1));\n\t  }\n\t  if(a[i][x+1][y]!=-1)\n\t    c.push(make_pair(max(p,a[i][x+1][y]),make_pair(x+1,y)));\n\t  if(a[i][x-1][y]!=-1)\n\t    c.push(make_pair(max(p,a[i][x-1][y]),make_pair(x-1,y)));\n\t  if(a[i][x][y+1]!=-1)\n\t    c.push(make_pair(max(p,a[i][x][y+1]),make_pair(x,y+1)));\n\t  if(a[i][x][y-1]!=-1)\n\t    c.push(make_pair(max(p,a[i][x][y-1]),make_pair(x,y-1)));  \n\t}\n      }\n    }\n    int sm=200000000;\n    for(i=0;i<(int)b[0].size()&&b[0][i].second+b[1][(int)b[1].size()-1].second<n;i++);\n    for(;i<(int)b[0].size()&&b[0][i].second<n;i++){\n      int mn=1,mx=b[1].size()-1;\n      for(;;){\n\tif(0){\n\t}else if(b[1][(mn+mx)/2-1].second>=n-b[0][i].second){\n\t  mx=(mn+mx)/2-1;\n\t}else if(b[1][(mn+mx)/2].second<n-b[0][i].second){\n\t  mn=(mn+mx)/2+1;\n\t}else{\n\t  break;\n\t}\n      }\n      sm=min(sm,b[0][i].first+b[1][(mn+mx)/2].first);\n    }\n    if(i<(int)b[0].size())\n      sm=min(sm,b[0][i].second);\n    cout<<sm<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//オーダーは大体O(RW1H1logW2H2)くらい\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint R;\nint W[2],H[2],ex[2],ey[2];\nint WS[2][500][500];\nint NL[2][250001];\nint AD[2][500][500];\n\nvoid CANGO(int place,int NLINDEX,int x,int y,int* entered){\n\tif(WS[place][y][x] > NL[place][NLINDEX]){\n\t\treturn;\n\t}\n\tif(x >= W[place] || y >= H[place] || x < 0 || y < 0){\n\t\treturn;\n\t}\n\tif(AD[place][y][x] == 1){\n\t\treturn;\n\t}\n\telse{\n\t\tAD[place][y][x] = 1;\n\t\t(*entered)++;\n\t\tCANGO(place,NLINDEX,x+1,y,entered);\n\t\tCANGO(place,NLINDEX,x-1,y,entered);\n\t\tCANGO(place,NLINDEX,x,y+1,entered);\n\t\tCANGO(place,NLINDEX,x,y-1,entered);\n\t}\n\tif(*entered >= R)\n\t\treturn;\n\treturn;\n}\nvoid IniAD(int place){\n\tfor(int i = 0;i < H[place];i++){\n\t\tfor(int j = 0;j < W[place];j++){\n\t\t\tAD[place][i][j] = 0;\n\t\t}\n\t}\n}\nint main(){\n\tint i,j,k;\n\tint ncor[2];\n\tint mcorsole = 0;\n\tint minest[100];\n\twhile(1){\n\t\tcin >> R;\n\t\tif(R == 0){\n\t\t\tbreak;\n\t\t}\n\t\tncor[0] = 0;\n\t\tncor[1] = 0;\n\t\tfor(i = 0;i < 2;i++){\n\t\t\tcin >> W[i] >> H[i] >> ex[i] >> ey[i];\n\t\t\tex[i]--;\n\t\t\tey[i]--;\n\t\t\tfor(j = 0;j < H[i];j++){\n\t\t\t\tfor(k = 0;k < W[i];k++){\n\t\t\t\t\tcin >> WS[i][j][k];\n\t\t\t\t\tNL[i][ncor[i]] = WS[i][j][k];\n\t\t\t\t\tncor[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tNL[i][ncor[i]] = 0;\n\t\t\tsort(NL[i],NL[i]+ncor[i]+1);\n\t\t}\n\t\t//探索(1つは2分木)\n\t\tint in1,in2;\n\t\tint start,last,medi,evergo;\n\t\tminest[mcorsole] = 200000001;\n\t\tfor(i = 0;i < ncor[0]+1;i++){\n\t\t\tin1 = 0;\n\t\t\tCANGO(0,i,ex[0],ey[0],&in1);\n\t\t\tIniAD(0);\n\t\t\tevergo = 0;\n\t\t\tstart = 0;\n\t\t\tlast = ncor[1];\n\t\t\twhile(NL[1][start] < NL[1][last]){\n\t\t\t\tmedi = (start+last)/2;\n\t\t\t\tin2 = 0;\n\t\t\t\tIniAD(1);\n\t\t\t\tCANGO(1,medi,ex[1],ey[1],&in2);\n\t\t\t\tif(in1+in2 >= R){\n\t\t\t\t\tlast = medi;\n\t\t\t\t\tevergo = 1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tstart = medi+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(NL[0][i]+NL[1][start] < minest[mcorsole] && evergo == 1){\n\t\t\t\tminest[mcorsole] = NL[0][i]+NL[1][start];\n\t\t\t}\n\t\t}\n\t\tmcorsole++;\n\t}\n\tfor(i = 0;i < mcorsole;i++){\n\t\tcout << minest[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define p pair<int,int>\n#define P pair<int,p>\nusing namespace std;\n\nint x[4] = { -1,0,0,1 }, y[4] = { 0,-1,1,0 };\nint f[500][500];\nbool i[500][500];\nset<p>l,r;\nsigned main() {\n\tint a;\n\twhile (cin >> a, a) {\n\t\tl.insert(p(0, 0)); r.insert(p(0, 0));\n\t\tint b, c, d, e; cin >> c >> b >> e >> d;\n\t\td--; e--;\n\t\tfor (int g = 0; g < b; g++) {\n\t\t\tfor (int h = 0; h < c; h++) {\n\t\t\t\tscanf(\"%lld\", &f[g][h]);\n\t\t\t}\n\t\t}\n\t\tmemset(i, true, sizeof(i));\n\t\tint sum = 0, MAX = 0;\n\t\tpriority_queue<P, vector<P>, greater<P>>Q;\n\t\tQ.push(P(1, p(d, e)));\n\t\twhile (Q.size()) {\n\t\t\tP o = Q.top(); Q.pop();\n\t\t\tMAX = o.first; \n\t\t\tif(i[o.second.first][o.second.second])sum++;\n\t\t\ti[o.second.first][o.second.second] = false;\n\t\t\tqueue<p>q;\n\t\t\tq.push(p(o.second.first, o.second.second));\n\t\t\twhile (q.size()) {\n\t\t\t\tp t = q.front(); q.pop();\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint dx = t.first + x[i], dy = t.second + y[i];\n\t\t\t\t\tif (dx >= 0 && dx < b&&dy >= 0 && dy < c&&::i[dx][dy]) {\n\t\t\t\t\t\tif (f[dx][dy] <= o.first) {\n\t\t\t\t\t\t\tsum++;\n\t\t\t\t\t\t\tq.push(p(dx,dy));\n\t\t\t\t\t\t\t::i[dx][dy] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tQ.push(P(f[dx][dy],p(dx,dy)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tl.insert(p(sum, MAX));\n\t\t}\n\t\tcin >> c >> b >> e >> d;\n\t\td--; e--;\n\t\tfor (int g = 0; g < b; g++) {\n\t\t\tfor (int h = 0; h < c; h++) {\n\t\t\t\tscanf(\"%lld\", &f[g][h]);\n\t\t\t}\n\t\t}\n\t\tmemset(i, true, sizeof(i));\n\t\tsum = 0; MAX = 0;\n\t\tpriority_queue<P, vector<P>, greater<P>>U;\n\t\tU.push(P(1, p(d, e)));\n\t\twhile (U.size()) {\n\t\t\tP o = U.top(); U.pop();\n\t\t\tMAX = o.first;\n\t\t\tif (i[o.second.first][o.second.second])sum++;\n\t\t\ti[o.second.first][o.second.second] = false;\n\t\t\tqueue<p>q;\n\t\t\tq.push(p(o.second.first, o.second.second));\n\t\t\twhile (q.size()) {\n\t\t\t\tp t = q.front(); q.pop();\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint dx = t.first + x[i], dy = t.second + y[i];\n\t\t\t\t\tif (dx >= 0 && dx < b&&dy >= 0 && dy < c&&::i[dx][dy]) {\n\t\t\t\t\t\tif (f[dx][dy] <= o.first) {\n\t\t\t\t\t\t\tsum++;\n\t\t\t\t\t\t\tq.push(p(dx, dy));\n\t\t\t\t\t\t\t::i[dx][dy] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tU.push(P(f[dx][dy], p(dx, dy)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tr.insert(p(sum, MAX));\n\t\t}\n\t\tint MIN = LLONG_MAX/3;\n\t\tfor (auto i = l.begin(); i != l.end(); i++) {\n\t\t\tauto j = r.lower_bound(p(a-(*i).first,0));\n\t\t\tif (j != r.end()) {\n\t\t\t\tMIN = min(MIN, (*i).second + (*j).second);\n\t\t\t}\n\t\t}\n\t\tcout << MIN << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n#define repi(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,a) repi(i,0,a)\n#define all(a) (a).begin(), (a).end()\n#define clr(a,v) memset((a),(v),sizeof(a))\n\nusing P = std::pair<int, int>;\nusing State = std::pair<int, P>;\n\nconstexpr int dx[4] = { 0, 1, 0, -1 }, dy[4] = { -1, 0, 1, 0 };\n\nint R;\nint W[2], H[2], X[2], Y[2];\nint L[2][510][510];\nbool used[510][510];\nstd::vector<int> lev[2];\n\nvoid dijkstra( int k )\n{\n  clr( used, false );\n  lev[k].clear();\n\n  std::priority_queue<State, std::vector<State>, std::greater<State> > pque;\n  pque.push( State( 1, P( X[k], Y[k] ) ) );\n\n  int ma = 0;\n  lev[k].push_back( 0 );\n\n  while( !pque.empty() )\n  {\n    State st = pque.top(); pque.pop();\n    int dist = st.first;\n    P p = st.second;\n\n    if( used[p.first][p.second] )\n      continue;\n\n    used[p.first][p.second] = true;\n\n    ma = std::max( ma, dist );\n    lev[k].emplace_back( ma );\n\n    rep( i, 4 )\n    {\n      int nx = p.first+dx[i], ny = p.second+dy[i];\n\n      if( nx >= 0 && nx < W[k] && ny >= 0 && ny < H[k] && !used[nx][ny] )\n        pque.push( State( L[k][nx][ny], P( nx, ny ) ) );\n    }\n  }\n\n  return;\n}\n\nint main()\n{\n  while( scanf( \"%d\", &R ), R )\n  {\n    rep( i, 2 )\n    {\n      scanf( \"%d%d%d%d\", W+i, H+i, X+i, Y+i );\n      --X[i]; --Y[i];\n\n      rep( j, H[i] ) rep( k, W[i] )\n        scanf( \"%d\", &L[i][k][j] );\n    }\n\n    dijkstra( 0 );\n    dijkstra( 1 );\n\n    int ans = 1<<30;\n\n    rep( i, R+1 )\n    {\n      if( lev[0].size() <= i )\n        continue;\n      if( lev[1].size() <= R-i )\n        continue;\n\n      ans = std::min( ans, lev[0][i]+lev[1][R-i] );\n    }  \n\n    printf( \"%d\\n\", ans );\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#define INF (1 << 29)\ntypedef pair<int, int> P; \ntypedef pair<int, P> F;\nint xs[] = {-1, 0, 1, 0}, ys[] = {0, 1, 0, -1};\nvector<int> input_djk(){\n  int w, h, x ,y;\n  cin >> w >> h >> x >> y;\n  x--,y--;\n  int dist[w][h], level[w][h];\n  for(int j = 0;j < h;j++){\n    for(int i = 0;i < w;i++){\n      cin >> level[i][j];\n      dist[i][j] = INF;\n    }\n  }\n  \n\n  priority_queue<F, vector<F>, greater<F> > pq;\n  dist[x][y] = 1;\n  pq.push(F(1, P(x, y)));\n  while(!pq.empty()){\n    F tmp = pq.top();pq.pop();\n    int tx = tmp.second.first, ty = tmp.second.second;\n    if(dist[tx][ty] < tmp.first)continue;\n    for(int i = 0;i < 4;i++){\n      if(tx + xs[i] < 0 || tx + xs[i] >= w || ty + ys[i] < 0 || ty + ys[i] >= h)continue;\n      tx += xs[i], ty += ys[i];\n      if(dist[tx][ty] > max(tmp.first, level[tx][ty])){\n\tdist[tx][ty] = max(tmp.first, level[tx][ty]);\n\tpq.push(F(dist[tx][ty], P(tx, ty)));\n      }\n      tx -= xs[i], ty -= ys[i];\n    }\n  }\n  vector<int> res;\n  for(int i = 0;i < w;i++)\n    for(int j = 0;j < h;j++)\n      res.push_back(dist[i][j]);\n   \n  sort(res.begin(), res.end());\n  return res;\n}\n\nint gs(vector<int> x, int r){\n  if(r == 0)return 0;\n  else return x[r - 1];\n}\n\n\nint solve(vector<int> a, vector<int> b, int r){\n  int res = INF;\n  for(int i = min(r,(int) a.size());i >= 0 && b.size() >= r - i;i--){\n    res = min(res, gs(a, i) + gs(b, r - i));\n  }\n  return res;\n}\n\nint main(){\n  while(true){\n    int r;\n    cin >> r;\n    if(r == 0)return 0;\n    vector<int> a, b;\n    a = input_djk();\n    b = input_djk();\n    cout << solve(a, b, r) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<long long int, P> P1;\n\nlong long int m[1001][1001];\n\nbool used[1001][1001];\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint main(){\n\t\n\twhile(true){\n\t\tint R;\n\t\tcin >> R;\n\t\tif(R == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tlong long int a[2] = {};\n\t\t\n\t\tlong long int num[2][100001];\n\t\t\n\t\tfor(int i = 0; i < 2; i++){\n\t\t\tfor(int j = 0; j <= 100000; j++){\n\t\t\t\tnum[i][j] = 1000000000;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < 2; i++){\n\t\t\tint W, H, X, Y;\n\t\t\tcin >> W >> H >> X >> Y;\n\t\t\tX--;\n\t\t\tY--;\n\t\t\tfor(int j = 0; j < H; j++){\n\t\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\t\tcin >> m[j][k];\n\t\t\t\t\tused[j][k] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpriority_queue<P1, vector<P1>, greater<P1> > pque;\n\t\t\tP1 p;\n\t\t\tp.first = 1;\n\t\t\tp.second.first = X;\n\t\t\tp.second.second = Y;\n\t\t\tpque.push(p);\n\t\t\tused[Y][X] = true;\n\t\t\t\n\t\t\tfor(int j = 0; j <= R; j++){\n\t\t\t\tnum[i][j] = a[i];\n\t\t\t\tif(pque.empty()){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tP1 p1 = pque.top();\n\t\t\t\tpque.pop();\n\t\t\t\t//cout << p1.first << \" \";\n\t\t\t\t//cout << p1.second.second << \" \" << p1.second.first << endl;\n\t\t\t\ta[i] = max(a[i], p1.first);\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tP1 pp;\n\t\t\t\t\tpp.second.first = p1.second.first + dy[j];\n\t\t\t\t\tpp.second.second = p1.second.second + dx[j];\n\t\t\t\t\tif(pp.second.second >= 0 && pp.second.first >= 0 && pp.second.second < W && pp.second.first < H && !used[pp.second.first][pp.second.second]){\n\t\t\t\t\t\tpp.first = m[pp.second.first][pp.second.second];\n\t\t\t\t\t\tpque.push(pp);\n\t\t\t\t\t\tused[pp.second.first][pp.second.second] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong long int ans = 1000000000;\n\t\t\n\t\tfor(int j = 0; j <= R; j++){\n\t\t\tans = min(ans, num[0][j] + num[1][R - j]);\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nstatic const int MAX_H = 500;\nstatic const int MAX_W = 500;\nstatic const int INF = 1 << 30;\n\nint R;\nint W1, H1, X1, Y1;\nint W2, H2, X2, Y2;\nint L1[MAX_H][MAX_W], L2[MAX_H][MAX_W];\nbool visited[MAX_H][MAX_W];\nint dy[] = {0, -1, 0, 1};\nint dx[] = {1, 0, -1, 0};\n\nvector<P> bfs(int L[MAX_H][MAX_W], int W, int H, int X, int Y){\n\tvector<P> ret;\n\tfill(visited[0], visited[H], false);\n\tret.push_back(P(0, 0));\n\tpriority_queue<PP, vector<PP>, greater<PP> > pqa;\n\tpqa.push(PP(1, P(Y, X)));\n\tvisited[Y][X] = true;\n\tint max_sec = 0;\n\tint cnt = 0;\n\twhile(!pqa.empty()){\n\t\tPP cur = pqa.top(); pqa.pop();\n\t\tcnt++;\n\t\tint cy = cur.second.first, cx = cur.second.second;\n\t\tint sec = cur.first;\n\t\tif(sec > max_sec){\n\t\t\tmax_sec = sec;\n\t\t\tret.push_back(P(max_sec, cnt));\n\t\t}else{\n\t\t\tret.back().second = cnt;\n\t\t}\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint ny = cy + dy[i], nx = cx + dx[i];\n\t\t\tif(ny < 0 || ny >= H || nx < 0 || nx >= W) continue;\n\t\t\tif(visited[ny][nx]) continue;\n\t\t\tpqa.push(PP(L[ny][nx], P(ny, nx)));\n\t\t\tvisited[ny][nx] = true;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tfor(;;){\n\t\tscanf(\"%d\", &R);\n\t\tif(R == 0) break;\n\t\tscanf(\"%d %d %d %d\", &W1, &H1, &X1, &Y1);\n\t\tX1--; Y1--;\n\t\tfor(int i = 0; i < H1; i++){\n\t\t\tfor(int j = 0; j < W1; j++){\n\t\t\t\tscanf(\"%d\", &L1[i][j]);\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d %d %d %d\", &W2, &H2, &X2, &Y2);\n\t\tX2--; Y2--;\n\t\tfor(int i = 0; i < H2; i++){\n\t\t\tfor(int j = 0; j < W2; j++){\n\t\t\t\tscanf(\"%d\", &L2[i][j]);\n\t\t\t}\n\t\t}\n\t\tvector<P> va = bfs(L1, W1, H1, X1, Y1);\n\t\tvector<P> vb = bfs(L2, W2, H2, X2, Y2);\n\t\tint res = INF;\n\t\tint j = vb.size() - 1;\n\t\tfor(int i = 0; i < va.size(); i++){\n\t\t\tfor(; j >= 1 && va[i].second + vb[j - 1].second >= R; j--);\n\t\t\tif(va[i].second + vb[j].second >= R) res = min(res, va[i].first + vb[j].first);\n\t\t}\n\t\tprintf(\"%d\\n\", res);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <bitset>\n#include <stack>\n#include <cstdlib>\n#include <complex>\n#include <unordered_map>\n#define rep(i,s,n) for(int i = s; n > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define MODU 33\n#define Range(x,a,b) ((a) <= (x) && (x) <= (b))\n#define POWT(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\nusing namespace std;\ntypedef vector<int> Ivec;\ntypedef pair<int, int> pii;\ntypedef long long int ll;\nconst pii Dir[8] = { //?????????\n\t{ 0,1 },{ 0,-1 },{ 1,0 },{ -1,0 },\n\t{ 1,1 },{ 1,-1 },{ -1,-1 },{ -1,1 }\n};\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*)array, (T*)(array + N), val);\n}\nint main() {\n\tint r;\n\tscanf(\"%d\", &r);\n\tint w, h, x, y;\n\tscanf(\"%d %d %d %d\", &w, &h, &x, &y);\n\tx--; y--;\n\tvector<vector<int>> m(h, vector<int>(w));\n\tREP(i, h) {\n\t\tREP(j, w) {\n\t\t\tscanf(\"%d\", &m[i][j]);\n\t\t}\n\t}\n\tint w2, h2, x2, y2;\n\tscanf(\"%d %d %d %d\", &w2, &h2, &x2, &y2);\n\tx2--; y2--;\n\tvector<vector<int>> m2(h2, vector<int>(w2));\n\n\tREP(i, h2) {\n\t\tREP(j, w2) {\n\t\t\tscanf(\"%d\", &m2[i][j]);\n\t\t}\n\t}\n\tpriority_queue<pair<int, pii>, vector<pair<int, pii>>, greater<pair<int, pii>>> que;\n\n\tque.push({ 1,{x,y} });\n\n\tmap<int, int> mcount;\n\tvector<vector<int>> al(h, vector<int>(w));\n\twhile (que.size()) {\n\t\tint  p = que.top().first;\n\t\tpii cur = que.top().second;\n\t\tque.pop();\n\t\tif (al[cur.first][cur.second])\n\t\t\tcontinue;\n\t\tal[cur.first][cur.second] = 1;\n\t\tmcount[p]++;\n\n\t\tREP(i, 4) {\n\t\t\tpii next = { cur.first + Dir[i].first, cur.second + Dir[i].second };\n\t\t\tif (Range(next.first, 0, h - 1) && Range(next.second, 0, w - 1)) {\n\t\t\t\tif (!al[next.first][next.second]) {\n\t\t\t\t\tque.push({ max(p,m[next.first][next.second]),next });\n\t\t\t\t\t//al[next.first][next.second] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<pii> cou;//???????????°?????¬??????\n\tfor (auto cur : mcount) {\n\t\tcou.push_back({ cur.second,cur.first });\n\t}\n\trep(i, 1, cou.size()) {\n\t\tif (cou[i].first == cou[i - 1].first) {\n\t\t\tif (cou[i].second > cou[i - 1].second)\n\t\t\t\tcou.erase(cou.begin() + i);\n\t\t\telse\n\t\t\t\tcou.erase(cou.begin() + i - 1);\n\t\t\ti--;\n\t\t}\n\t}\n\n\tmcount.clear();\n\tal.swap(vector<vector<int>>(h2,vector<int>(w2)));\n\tque.push({ 1,{x2,y2} });\n\twhile (que.size()) {\n\t\tint  p = que.top().first;\n\t\tpii cur = que.top().second;\n\t\tque.pop();\n\t\tif (al[cur.first][cur.second])\n\t\t\tcontinue;\n\t\tal[cur.first][cur.second] = 1;\n\t\tmcount[p]++;\n\n\t\tREP(i, 4) {\n\t\t\tpii next = { cur.first + Dir[i].first, cur.second + Dir[i].second };\n\t\t\tif (Range(next.first, 0, h2 - 1) && Range(next.second, 0, w2 - 1)) {\n\t\t\t\tif (!al[next.first][next.second]) {\n\t\t\t\t\tque.push({ max(p,m2[next.first][next.second]),next });\n\t\t\t\t\t//al[next.first][next.second] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvector<pii> cou2;\n\tfor (auto cur : mcount) {\n\t\tcou2.push_back({ cur.second,cur.first });\n\t}\n\trep(i, 1, cou2.size()) {\n\t\tif (cou2[i].first == cou2[i - 1].first) {\n\t\t\tif (cou2[i].second > cou2[i - 1].second)\n\t\t\t\tcou2.erase(cou2.begin() + i);\n\t\t\telse\n\t\t\t\tcou2.erase(cou2.begin() + i - 1);\n\t\t\ti--;\n\t\t}\n\t}\n\n\tint Min = INT_MAX;\n\tREP(i, cou.size()) {\n\t\tauto itr = upper_bound(ALL(cou2) ,make_pair(cou[i].first,0));\n\t\tif (itr != cou2.end()) {\n\t\t\tMin = min(Min,itr->second + cou[i].second);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", Min);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int,pair<int,int> > pp;\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\nint level[2][100001];\nint room[500][500];\nbool visited[500][500];\n\nint main(){\n    int r;\n    while(cin>>r,r){\n        int w,h,ex,ey;\n        int e[2];\n        for(int i=0;i<2;++i){\n            cin>>w>>h>>ex>>ey;\n            for(int j=0;j<h;++j){\n                for(int k=0;k<w;++k){\n                    cin>>room[j][k];\n                }\n            }\n            memset(visited,0,sizeof(visited));\n            visited[--ey][--ex]=1;\n            level[i][0]=0;\n            int mlevel=0,index=1;\n            priority_queue<pp,vector<pp>,greater<pp> > pq;\n            pq.push(make_pair(room[ey][ex],make_pair(ex,ey)));\n            while(!pq.empty()){\n                pp cur=pq.top();pq.pop();\n                mlevel=max(mlevel,cur.first);\n                level[i][index++]=mlevel;\n                if(index>r) break;\n                for(int j=0;j<4;++j){\n                    int cx=cur.second.first+dx[j];\n                    int cy=cur.second.second+dy[j];\n                    if(cx>=0&&cx<w&&cy>=0&&cy<h&&visited[cy][cx]==0){\n                        visited[cy][cx]=1;\n                        pq.push(make_pair(room[cy][cx],make_pair(cx,cy)));\n                    }\n                }\n            }\n            e[i]=index-1;\n        }\n        int ans = 1000000000;\n        for(int i=0;i<=r;++i){\n            if(e[0]<r-i||e[1]<i) continue;\n            ans=min(ans,level[1][i]+level[0][r-i]);\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"iomanip\"\n#include \"cmath\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\nclass CBox {\npublic:\n\tint c;\n\tint x;\n\tint y;\n\tCBox(){\n\t\tc = INT_MAX;\n\t}\n\tbool operator < (const CBox& b)const {\n\t\treturn c < b.c;\n\t}\n\tbool operator > (const CBox& b)const {\n\t\treturn c > b.c;\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> K;\n\twhile (K) {\n\t\tint h1, h2, w1, w2, sx1, sy1, sx2, sy2;\n\t\tcin >> w1 >> h1 >> sx1 >> sy1;\n\t\tsx1--;\n\t\tsy1--;\n\t\tvector<vector<int>>field1(h1, vector<int>(w1));\n\t\tfor (int i = 0; i < h1; i++) {\n\t\t\tfor (int j = 0; j < w1; j++) {\n\t\t\t\tcin >> field1[i][j];\n\t\t\t}\n\t\t}\n\t\tcin >> w2 >> h2 >> sx2 >> sy2;\n\t\tsx2--;\n\t\tsy2--;\n\t\tvector<vector<int>>field2(h2, vector<int>(w2));\n\t\tfor (int i = 0; i < h2; i++) {\n\t\t\tfor (int j = 0; j < w2; j++) {\n\t\t\t\tcin >> field2[i][j];\n\t\t\t}\n\t\t}\n\t\tvector<vector<CBox>>min1(h1, vector<CBox>(w1));\n\t\tmin1[sy1][sx1].c = 1;\n\t\tfor (int i = 0; i < h1; i++) {\n\t\t\tfor (int j = 0; j < w1; j++) {\n\t\t\t\tmin1[i][j].y = i;\n\t\t\t\tmin1[i][j].x = j;\n\t\t\t}\n\t\t}\n\t\tpriority_queue<CBox,vector<CBox>,greater<CBox>>PQ;\n\t\tPQ.push(min1[sy1][sx1]);\n\t\tint dir[] = { 1,0,-1,0,1 };\n\t\twhile (!PQ.empty()) {\n\t\t\tint cx = PQ.top().x;\n\t\t\tint cy = PQ.top().y;\n\t\t\tint c = PQ.top().c;\n\t\t\tPQ.pop();\n\t\t\tif (min1[cy][cx].c < c) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint nx = cx + dir[i + 1];\n\t\t\t\tint ny = cy + dir[i];\n\t\t\t\tif (ny < 0 || ny >= h1 || nx < 0 || nx >= w1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (min1[ny][nx].c > max(c, field1[ny][nx])) {\n\t\t\t\t\tmin1[ny][nx].c = max(c, field1[ny][nx]);\n\t\t\t\t\tPQ.push(min1[ny][nx]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<vector<CBox>>min2(h2, vector<CBox>(w2));\n\t\tmin2[sy2][sx2].c = 1;\n\t\tfor (int i = 0; i < h2; i++) {\n\t\t\tfor (int j = 0; j < w2; j++) {\n\t\t\t\tmin2[i][j].y = i;\n\t\t\t\tmin2[i][j].x = j;\n\t\t\t}\n\t\t}\n\t\tPQ.push(min2[sy2][sx2]);\n\t\twhile (!PQ.empty()) {\n\t\t\tint cx = PQ.top().x;\n\t\t\tint cy = PQ.top().y;\n\t\t\tint c = PQ.top().c;\n\t\t\tPQ.pop();\n\t\t\tif (min2[cy][cx].c < c) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint nx = cx + dir[i + 1];\n\t\t\t\tint ny = cy + dir[i];\n\t\t\t\tif (ny < 0 || ny >= h2 || nx < 0 || nx >= w2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (min2[ny][nx].c > max(c, field2[ny][nx])) {\n\t\t\t\t\tmin2[ny][nx].c = max(c, field2[ny][nx]);\n\t\t\t\t\tPQ.push(min2[ny][nx]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int>v1;\n\t\tfor (int i = 0; i < h1; i++) {\n\t\t\tfor (int j = 0; j < w1; j++) {\n\t\t\t\tv1.push_back(min1[i][j].c);\n\t\t\t}\n\t\t}\n\t\tvector<int>v2;\n\t\tfor (int i = 0; i < h2; i++) {\n\t\t\tfor (int j = 0; j < w2; j++) {\n\t\t\t\tv2.push_back(min2[i][j].c);\n\t\t\t}\n\t\t}\n\t\tv1.push_back(0);\n\t\tv2.push_back(0);\n\t\tsort(v1.begin(), v1.end());\n\t\tsort(v2.begin(), v2.end());\n\t\tN = v1.size()-1;\n\t\tM = v2.size()-1;\n\t\tL = 0;\n\t\tR = 100000001;\n\t\t//for (auto i : v2) {\n\t\t//\tcout << i << endl;\n\t\t//}\n\t\twhile (R - L > 1) {\n\t\t\tint mid = (R + L + 1) / 2;\n\t\t//\tcout << \"  \" << mid << endl;\n\t\t\tbool flag = false;\n\t\t\tfor (int i = 0; i <= N; i++) {\n\t\t\t\tint bag = K - i;\n\t\t\t\tif (bag < 0) {\n\t\t\t\t\tbag = 0;\n\t\t\t\t}\n\t\t\t\tif (bag > M) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t//\tcout << \"   \" << v1[i] + v2[bag] << endl;\n\t\t\t\tif (v1[i] + v2[bag] <= mid) {\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!flag) {\n\t\t\t\tL = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tR = mid;\n\t\t\t}\n\t\t}\n\t\tcout << R << endl;\n\t\tcin >> K;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<string>\n#include<queue>\n#include<climits>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\n\nint vx[4]={0,1,0,-1};\nint vy[4]={1,0,-1,0};\n\nstruct pos{\n  pos(){};\n  pos(int cost,int kpos,int xpos,int ypos){\n    c=cost;\n    k=kpos;\n    x=xpos;\n    y=ypos;\n  }\n  int c,k,x,y;\n};\n\nbool operator<(const pos &a,const pos &b){\n  return a.c>b.c;\n}\n\nint r;\npair<int,int> el[2];\nvector< vector<int> > map[2];\nvector< vector<int> > used[2];\nvoid init(){\n  map[0].clear();\n  map[1].clear();\n  used[0].clear();\n  used[1].clear();\n}\n\nint input(){\n  cin>>r;\n  if(r==0)return 0;\n  int x,y;\n  cin>>x>>y;\n  cin>>el[0].second;\n  cin>>el[0].first;\n  el[0].first--;\n  el[0].second--;\n  map[0].resize(y);\n  used[0].resize(y);\n  for(int i=0;i<y;i++){\n    used[0][i].resize(x);\n    for(int j=0;j<x;j++){\n      int tmp;\n      cin>>tmp;\n      map[0][i].push_back(tmp);\n    }\n  }\n  cin>>x>>y;\n  cin>>el[1].second;\n  cin>>el[1].first;\n  el[1].first--;\n  el[1].second--;\n  map[1].resize(y);\n  used[1].resize(y);\n  for(int i=0;i<y;i++){\n    used[1][i].resize(x);\n    for(int j=0;j<x;j++){\n      int tmp;\n      cin>>tmp;\n      map[1][i].push_back(tmp);\n    }\n  }\n  return r;\n\n}\nvector< pair<int,int> > cost_room[2];\n\nint binary_serch(int n/*second*/,int begin,int end){\n  if(begin>=end){\n    if(cost_room[1][begin].second<n){\n      return -1;\n    }else{\n      return end;\n    }\n  }\n  //return first\n  int tmp=(begin+end)/2;\n  if(cost_room[1][tmp].second<n){\n    return binary_serch(n,tmp+1,end);\n  }else{\n    return binary_serch(n,begin,tmp);\n  }\n}\n\n\nint solve(){\n  \n  priority_queue<pos> q;\n  q.push(pos(map[0][el[0].first][el[0].second] , 0 , el[0].first , el[0].second));\n\n  cost_room[0].clear();\n  cost_room[1].clear();\n  pair<int,int> tmp_c;\n\n  tmp_c.first =0;\n  tmp_c.second=0;\n\n  while((!q.empty())){\n    pos tmp=q.top();q.pop();\n    if(tmp_c.first<tmp.c){\n      cost_room[tmp.k].push_back(tmp_c);\n      tmp_c.second++;\n      tmp_c.first=tmp.c;\n    }else if(tmp_c.first>=tmp.c && tmp.c!=0){\n      tmp_c.second++;\n    }\n\n    used[tmp.k][tmp.x][tmp.y]=true;\n    for(int i=0;i<4;i++){\n      if((!(tmp.x+vx[i]<0||used[tmp.k].size()-1<tmp.x+vx[i]))\n          &&(!(tmp.y+vy[i]<0||used[tmp.k][tmp.x+vx[i]].size()-1<tmp.y+vy[i]))\n          &&(!used[tmp.k][tmp.x+vx[i]][tmp.y+vy[i]])){\n        q.push(pos( map[tmp.k][tmp.x+vx[i]][tmp.y+vy[i]], tmp.k, tmp.x+vx[i],tmp.y+vy[i]));\n      }\n    }\n  }\n  cost_room[0].push_back(tmp_c);\n  \n  q.push(pos(map[1][el[1].first][el[1].second] , 1 , el[1].first , el[1].second));\n  tmp_c.first =0;\n  tmp_c.second=0;\n  while((!q.empty())){\n    pos tmp=q.top();q.pop();\n    if(used[tmp.k][tmp.x][tmp.y])continue; \n    if(tmp_c.first<tmp.c){\n      cost_room[tmp.k].push_back(tmp_c);\n      tmp_c.second++;\n      tmp_c.first=tmp.c;\n    }else if(tmp_c.first>=tmp.c && tmp.c!=0){\n      tmp_c.second++;\n    }\n\n    used[tmp.k][tmp.x][tmp.y]=true;\n    for(int i=0;i<4;i++){\n      if((!(tmp.x+vx[i]<0||used[tmp.k].size()-1<tmp.x+vx[i]))\n          &&(!(tmp.y+vy[i]<0||used[tmp.k][tmp.x+vx[i]].size()-1<tmp.y+vy[i]))\n          &&(!used[tmp.k][tmp.x+vx[i]][tmp.y+vy[i]])){\n        q.push(pos( map[tmp.k][tmp.x+vx[i]][tmp.y+vy[i]], tmp.k, tmp.x+vx[i],tmp.y+vy[i]));\n      }\n    }\n  }\n  cost_room[1].push_back(tmp_c);\n\n\n  int res=INT_MAX;\n  for(int i=0;i<cost_room[0].size();i++){\n    int tmp=binary_serch(r-cost_room[0][i].second,0,cost_room[1].size()-1);\n    if(tmp!=-1){\n      res=min(cost_room[0][i].first+cost_room[1][tmp].first,res);\n    }\n  }\n  return res;\n}\n\n\n\nint main(){\n  while(init(),input()){\n    cout<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\ntypedef pair< int, int > Pi;\ntypedef pair< int, Pi > Pii;\nconst int INF = 1 << 29;\nconst int dy[] = {0, 1, 0, -1}, dx[] = {1, 0, -1, 0};\n \nstruct Field\n{\n  int W, H, X, Y;\n  int L[500][500];\n};\n \nvoid InputField(Field& e)\n{\n  cin >> e.W >> e.H >> e.X >> e.Y;\n  --e.X, --e.Y;\n  for(int i = 0; i < e.H; i++) {\n    for(int j = 0; j < e.W; j++) {\n      cin >> e.L[i][j];\n    }\n  }\n}\n// ????\nint BFSField(const Field& e, vector< int >& cost)\n{\n  priority_queue< Pii, vector< Pii >, greater< Pii > > que;\n  que.push({1, make_pair(e.X, e.Y)});\n  int min_cost[500][500];\n  fill_n(*min_cost, 500 * 500, INF);\n  min_cost[e.X][e.Y] = 1;\n  map< int, int > cur;\n  while(!que.empty()) {\n    Pi point = que.top().second;\n    int c = que.top().first;\n    que.pop();\n    if(c > min_cost[point.first][point.second]) continue;\n    cur[c]++;\n    for(int i = 0; i < 4; i++) {\n      int ny = point.second + dy[i], nx = point.first + dx[i];\n      if(ny < 0 || nx < 0 || ny >= e.H || nx >= e.W) continue;\n      if(min_cost[nx][ny] > max(c, e.L[ny][nx])) {\n        min_cost[nx][ny] = max(c, e.L[ny][nx]);\n        que.push({min_cost[nx][ny], Pi(nx, ny)});\n      }\n    }\n  }\n   \n  // ????????????????????\\?????????????????????\n  cost.assign(e.W * e.H + 1, INF);\n  int sum = 0;\n  cost[0] = 0;\n  for(auto e : cur) {\n    sum += e.second;\n    cost[sum] = e.first;\n  }\n  for(int i = cost.size() - 2; i >= 0; i--) {\n    cost[i] = min(cost[i + 1], cost[i]);\n  }\n  /*\n  for(int i = 0; i < cost.size(); i++) {\n    cout << cost[i] << endl;\n  }\n  */\n}\n \nint main()\n{\n  int R;\n  Field A, B;\n \n  while(cin >> R, R) {\n    InputField(A);\n    InputField(B);\n    vector< int > a, b;\n    BFSField(A, a);\n    BFSField(B, b);\n   \n    int ret = INF;\n    for(int i = 0; i < a.size(); i++) {\n      if(R - i >= 0 && R - i < b.size()) {\n        ret = min(ret, a[i] + b[R - i]);\n      }\n    }\n   \n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 200000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\nstruct ROOM\n{\n\tint level,x,y;\n};\nbool operator <(const ROOM &a,const ROOM &b)\n{\n\treturn a.level > b.level;\n}\nint office[2][510][510];\nbool used[510][510];\nint W[2],H[2],X[2],Y[2];\nint can[2][100010];\nint dx[]={0,1,-1,0};\nint dy[]={1,0,0,-1};\nint main()\n{\n\twhile(1)\n\t{\n\t\tint R;\n\t\tcin >> R;\n\t\tif(R==0)break;\n\t\tfor(int i=0;i<100010;i++)\n\t\t{\n\t\t\tcan[0][i]=INF;\n\t\t\tcan[1][i]=INF;\n\t\t}\n\t\tmemset(office,0,sizeof(office));\n\t\tfor(int t=0;t<2;t++)\n\t\t{\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tcin >> W[t] >> H[t] >> X[t] >> Y[t];\n\t\t\tfor(int i=0;i<H[t];i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<W[t];j++)\n\t\t\t\t{\n\t\t\t\t\tcin >> office[t][i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tpriority_queue<ROOM> q;\n\t\t\tROOM f;\n\t\t\tf.level=office[t][Y[t]][X[t]];\n\t\t\tf.x=Y[t]-1;\n\t\t\tf.y=X[t]-1;\n\t\t\tq.push(f);\n\t\t\tint num=0,now=0,mx=0;\n\t\t\twhile(!q.empty())\n\t\t\t{\n\t\t\t\tROOM a=q.top();\n\t\t\t\tif(used[a.x][a.y])\n\t\t\t\t{\n\t\t\t\t\tq.pop();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tnow=max(now,a.level);\n\t\t\t\twhile(now>=a.level)\n\t\t\t\t{\n\t\t\t\t\tq.pop();\n\t\t\t\t\tif(!used[a.x][a.y])\n\t\t\t\t\t{\n\t\t\t\t\t\tused[a.x][a.y]=true;\n\t\t\t\t\t\tnum++;\n\t\t\t\t\t\tfor(int i=0;i<4;i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint nx=a.x+dx[i],ny=a.y+dy[i];\n\t\t\t\t\t\t\tif(nx>=0&&nx<H[t]&&ny>=0&&ny<W[t]&&!used[nx][ny])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tROOM b;\n\t\t\t\t\t\t\t\tb.level=office[t][nx][ny];\n\t\t\t\t\t\t\t\tb.x=nx;\n\t\t\t\t\t\t\t\tb.y=ny;\n\t\t\t\t\t\t\t\tq.push(b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(q.empty())break;\n\t\t\t\t\ta=q.top();\n\t\t\t\t}\n\t\t\t\tif(now<a.level)\n\t\t\t\t{\n\t\t\t\t\tq.push(a);\n\t\t\t\t}\n\t\t\t\tfor(int i=mx+1;i<=min(R+1,num+1);i++)\n\t\t\t\t{\n\t\t\t\t\tcan[t][i]=now;\n\t\t\t\t}\n\t\t\t\tmx=num;\n\t\t\t\tif(mx>R)break;\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(int i=1;i<=R+1;i++)\n\t\t{\n\t\t\tans=min(ans,can[0][i]+can[1][R-i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nvvint vv1;\nvvint vv2;\nvvint dp1;\nvvint dp2;\nint dd[]={1,0,-1,0,1};\nint w1,h1,x1,y1;\nint w2,h2,x2,y2;\nvoid foo1(int x,int y,int c){\n\tc=max(c,vv1[y][x]);\n\tif(dp1[y][x]<=c) return;\n\tdp1[y][x]=c;\n\trep(i,4){\n\t\tint yy=y+dd[i];\n\t\tint xx=x+dd[i+1];\n\t\tif(0<=xx&&xx<w1&&0<=yy&&yy<h1){\n\t\t\tfoo1(xx,yy,c);\n\t\t}\n\t}\n}\nvoid foo2(int x,int y,int c){\n\tc=max(c,vv2[y][x]);\n\tif(dp2[y][x]<=c) return;\n\tdp2[y][x]=c;\n\trep(i,4){\n\t\tint yy=y+dd[i];\n\t\tint xx=x+dd[i+1];\n\t\tif(0<=xx&&xx<w2&&0<=yy&&yy<h2){\n\t\t\tfoo2(xx,yy,c);\n\t\t}\n\t}\n}\nvoid mainmain(){\n\tint R;\n\twhile(cin>>R,R){\n\t\tmap<int,int> ma1;\n\t\tmap<int,int> ma2;\n\t\tcin>>w1>>h1>>x1>>y1;\n\t\tinitvv(vv1,h1,w1);\n\t\tinitvv(dp1,h1,w1,INF);\n\t\trep(i,h1){\n\t\t\trep(j,w1){\n\t\t\t\tcin>>vv1[i][j];\n\t\t\t}\n\t\t}\n\t\tcin>>w2>>h2>>x2>>y2;\n\t\tinitvv(vv2,h2,w2);\n\t\tinitvv(dp2,h2,w2,INF);\n\t\trep(i,h2){\n\t\t\trep(j,w2){\n\t\t\t\tcin>>vv2[i][j];\n\t\t\t}\n\t\t}\n\t\tfoo1(x1-1,y1-1,1);\n\t\tfoo2(x2-1,y2-1,1);\n\t\trep(i,h1){\n\t\t\trep(j,w1){\n\t\t\t\tif(ma1.count(dp1[i][j])==0) ma1[dp1[i][j]]=0;\n\t\t\t\tma1[dp1[i][j]]++;\n\t\t\t}\n\t\t}\n\t\trep(i,h2){\n\t\t\trep(j,w2){\n\t\t\t\tif(ma2.count(dp2[i][j])==0) ma2[dp2[i][j]]=0;\n\t\t\t\tma2[dp2[i][j]]++;\n\t\t\t}\n\t\t}\n\t\tvector<pii> v1;\n\t\tvector<pii> v2;\n\t\tint t=0;\n\t\tv1.PB(pii(0,0));\n\t\tv2.PB(pii(0,0));\n\t\tfor(auto i:ma1){\n\t\t\tt+=i.S;\n\t\t\tv1.PB(pii(t,i.F));\n\t\t}\n\t\tt=0;\n\t\tfor(auto i:ma2){\n\t\t\tt+=i.S;\n\t\t\tv2.PB(pii(t,i.F));\n\t\t}\n\t\tint ans=INT_MAX;\n\t\trep(i,v1.size()){\n\t\t\tint tmp=v1[i].S;\n\t\t\tauto it=lower_bound(ALL(v2),pii(R-v1[i].F,0));\n\t\t\tif(it==v2.end()) continue;\n\t\t\tpii tt = *it;\n\t\t\t// cout<<v1[i].F<<\" \"<<v1[i].S<<\" \"<<tt.F<<\" \"<<tt.S<<endl;\n\t\t\tans=min(ans,tmp+tt.S);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,-1,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pint pair<int,int>\n#define tint tuple<int,int,int>\n#define INF 1<<29\n#define MAX 501\nusing namespace std;\n\nint R,W[2],H[2],X[2],Y[2],L[2][MAX][MAX],d[2][MAX][MAX],dd[4]={0,-1,0,1};\nmap<int,int> m[2];\nmap<int,int>::iterator ite;\n\nvoid solve(){\n for(;;){\n  cin>>R;\n  if(!R) return;\n  FOR(i,2){\n   cin>>W[i]>>H[i]>>X[i]>>Y[i];\n   X[i]--;\n   Y[i]--;\n   FOR(j,H[i]) FOR(k,W[i]) cin>>L[i][j][k];\n   FOR(j,H[i]) FOR(k,W[i]) d[i][j][k]=INT_MAX/3;\n   d[i][X[i]][Y[i]]=1;\n   priority_queue<pint,vector<pint>,greater<pint>> pque;\n   pque.push(mp(1,X[i]*W[i]+Y[i]));\n   while(!pque.empty()){\n    pint p=pque.top(); pque.pop();\n    int x=p.second/W[i],y=p.second-x*W[i];\n    if(d[i][x][y]<p.first) continue;\n    FOR(j,4){\n     int nx=x+dd[j],ny=y+dd[j^1];\n     if(nx<0||ny<0||nx>=H[i]||ny>=W[i]) continue;\n     if(d[i][nx][ny]>max(d[i][x][y],L[i][nx][ny])){\n      d[i][nx][ny]=max(d[i][x][y],L[i][nx][ny]);\n      pque.push(mp(d[i][nx][ny],nx*W[i]+ny));\n     }\n    }\n   }\n   FOR(j,H[i]) FOR(k,W[i]) m[i][d[i][j][k]]++;\n   for(ite=m[i].begin();ite!=m[i].end();ite++){\n    if(ite==m[i].begin()) continue;\n    ite->second+=(--ite)->second;\n    ite++;\n   }\n  }\n  int mi=min(m[1].lower_bound(R)->first,m[2].lower_bound(R)->first);\n  for(ite=m[0].begin();ite!=m[0].end();ite++){\n   mi=min(mi,(ite->first)+(m[1].lower_bound(R-(ite->second))->first));\n  }\n  cout<<mi<<endl;\n  FOR(i,2) m[i].clear();\n }\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//認証レベルの小さい順に鍵を設定すると、入れる部屋が単調にふえるので、その部屋に入るための最少認証レベルが簡単に求まる。\n//と思ったら、そうでもなかった…とりあえず、ダイクストラの負の辺OK盤を使う。\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n//#define DEBUG DEBUG\n#define F first\n#define S second\nusing namespace std;\n#define MAX(x,y) (x>y?x:y)\t// ()がいります\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint R;\nint W1,H1,X1,Y1,W2,H2,X2,Y2;\nint JOI1[501][501],JOI2[501][501];\t//JOI[y][x]として入れます。\nint ADD1[501][501],ADD2[501][501];\t//入るための認証レベルの最小値(1以上)\n\nvoid Make_list1(){\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\tPP node;\n\tque.push(PP(1,P(Y1,X1)));\n\twhile(!que.empty()){\n\t\tnode = que.top();\n\t\tque.pop();\n\t\t//周り4辺を更新\n\t\tif(ADD1[node.S.F+1][node.S.S] > MAX(node.F,JOI1[node.S.F+1][node.S.S])){\n\t\t\tADD1[node.S.F+1][node.S.S] = MAX(node.F,JOI1[node.S.F+1][node.S.S]);\n\t\t\tque.push(PP(ADD1[node.S.F+1][node.S.S],P(node.S.F+1,node.S.S)));\t\n\t\t}\n\t\tif(ADD1[node.S.F][node.S.S+1] > MAX(node.F,JOI1[node.S.F][node.S.S+1])){\n\t\t\tADD1[node.S.F][node.S.S+1] = MAX(node.F,JOI1[node.S.F][node.S.S+1]);\n\t\t\tque.push(PP(ADD1[node.S.F][node.S.S+1],P(node.S.F,node.S.S+1)));\t\n\t\t}\n\t\tif(node.S.F > 0 && ADD1[node.S.F-1][node.S.S] > MAX(node.F,JOI1[node.S.F-1][node.S.S])){\n\t\t\tADD1[node.S.F-1][node.S.S] = MAX(node.F,JOI1[node.S.F-1][node.S.S]);\n\t\t\tque.push(PP(ADD1[node.S.F-1][node.S.S],P(node.S.F-1,node.S.S)));\t\n\t\t}\n\t\tif(node.S.S > 0 && ADD1[node.S.F][node.S.S-1] > MAX(node.F,JOI1[node.S.F][node.S.S-1])){\n\t\t\tADD1[node.S.F][node.S.S-1] = MAX(node.F,JOI1[node.S.F][node.S.S-1]);\n\t\t\tque.push(PP(ADD1[node.S.F][node.S.S-1],P(node.S.F,node.S.S-1)));\t\n\t\t}\n\t}\n}\nvoid Make_list2(){\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\tPP node;\n\tque.push(PP(1,P(Y2,X2)));\n\twhile(!que.empty()){\n\t\tnode = que.top();\n\t\tque.pop();\n\t\t//周り4辺を更新\n\t\tif(ADD2[node.S.F+1][node.S.S] > MAX(node.F,JOI2[node.S.F+1][node.S.S])){\n\t\t\tADD2[node.S.F+1][node.S.S] = MAX(node.F,JOI2[node.S.F+1][node.S.S]);\n\t\t\tque.push(PP(ADD2[node.S.F+1][node.S.S],P(node.S.F+1,node.S.S)));\t\n\t\t}\n\t\tif(ADD2[node.S.F][node.S.S+1] > MAX(node.F,JOI2[node.S.F][node.S.S+1])){\n\t\t\tADD2[node.S.F][node.S.S+1] = MAX(node.F,JOI2[node.S.F][node.S.S+1]);\n\t\t\tque.push(PP(ADD2[node.S.F][node.S.S+1],P(node.S.F,node.S.S+1)));\t\n\t\t}\n\t\tif(node.S.F > 0 && ADD2[node.S.F-1][node.S.S] > MAX(node.F,JOI2[node.S.F-1][node.S.S])){\n\t\t\tADD2[node.S.F-1][node.S.S] = MAX(node.F,JOI2[node.S.F-1][node.S.S]);\n\t\t\tque.push(PP(ADD2[node.S.F-1][node.S.S],P(node.S.F-1,node.S.S)));\t\n\t\t}\n\t\tif(node.S.S > 0 && ADD2[node.S.F][node.S.S-1] > MAX(node.F,JOI2[node.S.F][node.S.S-1])){\n\t\t\tADD2[node.S.F][node.S.S-1] = MAX(node.F,JOI2[node.S.F][node.S.S-1]);\n\t\t\tque.push(PP(ADD2[node.S.F][node.S.S-1],P(node.S.F,node.S.S-1)));\t\n\t\t}\n\t}\n}\nint main(){\n\tint i,j;\n\tint minest[200],mcor = 0;\n\tfor(i = 0;i < 200;i++){minest[i] = 1000000000;}\n\twhile(1){\n\t\tcin >> R;\n\t\tif(R == 0)\n\t\t\tbreak;\n\t\tcin >> W1 >> H1 >> X1 >> Y1;\n\t\tX1--;Y1--;\n\t\tfor(i = 0;i < H1;i++){\n\t\t\tfor(j = 0;j < W1;j++){\n\t\t\t\tcin >> JOI1[i][j];\n\t\t\t\tADD1[i][j] = 1000000001;\n\t\t\t}\n\t\t}\n\t\tADD1[Y1][X1] = 1;\n\t\tcin >> W2 >> H2 >> X2 >> Y2;\n\t\tX2--;Y2--;\n\t\tfor(i = 0;i < H2;i++){\n\t\t\tfor(j = 0;j < W2;j++){\n\t\t\t\tcin >> JOI2[i][j];\n\t\t\t\tADD2[i][j] = 1000000001;\n\t\t\t}\n\t\t}\n\t\tADD2[Y2][X2] = 1;\n\t\t//幅優先探索で部屋に入るための認証レベルの最小値,R部屋入るための認証レベルの最小値を記録する。\n\t\t//認証レベルの設定はWH回したほうがよい。まちがっても、部屋数に対する認証レベルを探すO(R^2logWH)解法は行わない！\n\t\t//queueを使うとO(WH)で行ける。WH*最大4方向*最大4回更新\n\t\tMake_list1();\n\t\tMake_list2();\n\t\t//認証レベルに対して入れる部屋数を考えてみよう(ヒント→認証レベルがiのとき認証レベルがi-1のとき行けた部屋はすべていける)\n\t\tstatic map<int,int> nin1,nin2;\t//認証レベル,部屋数\n\t\tnin1.insert(make_pair(0,0));\n\t\tfor(i = 0;i < H1;i++){\n\t\t\tfor(j = 0;j < W1;j++){\n\t\t\t\tif(nin1.find(ADD1[i][j]) == nin1.end()){\n\t\t\t\t\tnin1.insert(make_pair(ADD1[i][j],1));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tnin1[ADD1[i][j]]++;\t\t//2番目のキーをプラスしましょう。\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnin2.insert(make_pair(0,0));\n\t\tfor(i = 0;i < H2;i++){\n\t\t\tfor(j = 0;j < W2;j++){\n\t\t\t\tif(nin2.find(ADD2[i][j]) == nin2.end()){\n\t\t\t\t\tnin2.insert(make_pair(ADD2[i][j],1));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tnin2[ADD2[i][j]]++;\t\t//2番目のキーをプラスしましょう。\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmap<int,int>::iterator it,bit;\n\t\tit = nin1.begin();\n\t\tfor(it++;it != nin1.end();it++){\n\t\t\tbit = it;\n\t\t\tbit--;\n\t\t\t(*it).S += (*bit).S;\n\t\t}\n\t\tit = nin2.begin();\n\t\tfor(it++;it != nin2.end();it++){\n\t\t\tbit = it;\n\t\t\tbit--;\n\t\t\t(*it).S += (*bit).S;\n\t\t}\n\t\t//入れる部屋数にたいする認証レベルの最小値を考えてみよう\n\t\tstatic int R1[100001],R2[100001];\n\t\tfor(i = 0;i < R+1;i++){R1[i] = 1000000000;R2[i] = 1000000000;}\n\t\tit = nin1.begin();\n\t\tR1[0] = 0;\n\t\tit++;\n\t\tfor(;it != nin1.end();it++){\n\t\t\tif((*it).S > R)\n\t\t\t\t(*it).S = R;\n\t\t\tbit = it;\n\t\t\tbit--;\n\t\t\tfor(i = (*it).S;i > (*bit).S;i--){\n\t\t\t\tif(R1[i] > (*it).F)\n\t\t\t\t\tR1[i] = (*it).F;\n\t\t\t}\n\t\t}\n\t\tit = nin2.begin();\n\t\tR2[0] = 0;\n\t\tit++;\n\t\tfor(;it != nin2.end();it++){\n\t\t\tif((*it).S > R)\n\t\t\t\t(*it).S = R;\n\t\t\tbit = it;\n\t\t\tbit--;\n\t\t\tfor(i = (*it).S;i > (*bit).S;i--){\n\t\t\t\tif(R2[i] > (*it).F)\n\t\t\t\t\tR2[i] = (*it).F;\n\t\t\t}\n\t\t}\n\t\t//デバッグ\n/*#ifdef DEBUG\n\t\tfor(i = 0;i < H1;i++){\n\t\t\tfor(j = 0;j < W1;j++){\n\t\t\t\tcout << ADD1[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tfor(i = 0;i < H2;i++){\n\t\t\tfor(j = 0;j < W2;j++){\n\t\t\t\tcout << ADD2[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << \"1部屋目\" << endl;\n\t\tfor(it = nin1.begin();it != nin1.end();it++){\n\t\t\tcout << (*it).F << \" \" << (*it).S << endl;\n\t\t}\n\t\tcout << \"2部屋目\" << endl;\n\t\tfor(it = nin2.begin();it != nin2.end();it++){\n\t\t\tcout << (*it).F << \" \" << (*it).S << endl;\n\t\t}\n\t\t//認証レベル\n\t\tfor(i = 0;i < H1;i++){\n\t\t\tfor(j = 0;j < W1;j++){\n\t\t\t\tcout << R1[i*W1+j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tfor(i = 0;i < H2;i++){\n\t\t\tfor(j = 0;j < W2;j++){\n\t\t\t\tcout << R2[i*W2+j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n#endif*/\n\t\t//探索(O(R))\n\t\tfor(i = 0;i < R+1;i++){\n\t\t\tif(minest[mcor] > R1[i]+R2[R-i])\n\t\t\t\tminest[mcor] = R1[i]+R2[R-i];\n\t\t}\t\t\n\t\t//使った分を初期化\n\t\tfor(i = 0;i < H1;i++){\n\t\t\tfor(j = 0;j < W1;j++){\n\t\t\t\tJOI1[i][j] = 0;\n\t\t\t\tADD1[i][j] = 100000001;\n\t\t\t}\n\t\t}\n\t\tfor(i = 0;i < H2;i++){\n\t\t\tfor(j = 0;j < W2;j++){\n\t\t\t\tJOI2[i][j] = 0;\n\t\t\t\tADD2[i][j] = 100000001;\n\t\t\t}\n\t\t}\n\t\tnin1.clear();\n\t\tnin2.clear();\n\t\t//カーソル移動\n\t\tmcor++;\n\t}\n\tfor(i = 0;i < mcor;i++){\n\t\tcout << minest[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst LL INF = 1001001001001001;\n\nint r, x[2], y[2];\nLL grid[2][502][502];\nbool done[2][502][502];\nLL memo[2][5001];\n\nstruct P\n{\n\tint g, x, y;\n\t\n\tbool operator < (const P& t) const {\n\t\treturn grid[g][x][y] > grid[g][t.x][t.y];\n\t}\n};\n\nvoid search(int g)\n{\n\tfor (int i = 0; i < 502; i++){\n\t\tfor (int j = 0; j < 502; j++){\n\t\t\tdone[g][i][j] = false;\n\t\t}\n\t}\n\tfor (int i = 0; i <= 5000; i++){\n\t\tmemo[g][i] = INF;\n\t}\n\tmemo[g][0] = 0;\n\t\n\tint num = 0;\n\tLL level = 0;\n\tLL mini = INF;\n\tpriority_queue<P> que;\n\tque.push({g, x[g], y[g]});\n\twhile (!que.empty()){\n\t\tP p = que.top(); que.pop();\n\t\tif (done[g][p.x][p.y]) continue;\n\t\tdone[g][p.x][p.y] = true;\n\t\t\n\t\t//printf(\"%d %d %d\\n\", g, p.x, p.y);\n\t\t\n\t\tif (grid[g][p.x][p.y] <= level){\n\t\t\tnum++;\n\t\t\tmemo[g][num] = level;\n\t\t}\n\t\telse {\n\t\t\tif (grid[g][p.x][p.y] == INF) break;\n\t\t\tlevel = grid[g][p.x][p.y];\n\t\t\tnum++;\n\t\t\tmemo[g][num] = level;\n\t\t}\n\t\t\n\t\tif (num >= r) return;\n\t\t\n\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\tint tx = p.x + dx[dir];\n\t\t\tint ty = p.y + dy[dir];\n\t\t\tif (!done[g][tx][ty]){\n\t\t\t\tque.push({g, tx, ty});\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (scanf(\"%d\", &r), r){\n\t\tfor (int i = 0; i < 2; i++){\n\t\t\tfor (int j = 0; j < 502; j++){\n\t\t\t\tfor (int k = 0; k < 502; k++){\n\t\t\t\t\tgrid[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint h, w;\n\t\t\tscanf(\"%d %d %d %d\", &w, &h, &y[i], &x[i]);\n\t\t\tfor (int j = 1; j <= h; j++){\n\t\t\t\tfor (int k = 1; k <= w; k++){\n\t\t\t\t\tscanf(\"%lld\", &grid[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < 2; i++){\n\t\t\tsearch(i);\n\t\t}\n\t\t\n\t\tLL mini = INF;\n\t\tfor (int i = 0; i <= r; i++){\n\t\t\tmini = min(mini, memo[0][i] + memo[1][r - i]);\n\t\t}\n\t\tprintf(\"%lld\\n\", mini);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst int INF = 1 << 30;\nconst int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};\n\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nint R, W[2], H[2], X[2], Y[2];\nint Room[2][500][500];\nstd::map<int, int> maxR[2]; // maxR[i][j]: 事務所iでj番目に小さいレベルで行ける部屋の数\nint used[500][500];\n\nvoid travel(int r){\n    REP(j, H[r]){\n        REP(k, W[r]){\n            used[j][k] = 0;\n        }\n    }\n    \n    std::priority_queue<State, std::vector<State>, std::greater<State>> q;\n    q.push(mp(1, mp(X[r], Y[r])));\n\n    while(!q.empty()){\n        State s = q.top(); q.pop();\n        int l = s.first;\n        P p = s.second;\n        int x = p.first, y = p.second;\n\n        if(used[y][x]){continue;}\n        else{used[y][x] = 1;}\n\n        maxR[r][l]++;\n\n        //std::cout << x << \",\" << y << \",\" << l << std::endl;\n\n        REP(i, 4){\n            int nx = x + dx[i], ny = y + dy[i];\n            if(0 <= nx && nx < W[r] && 0 <= ny && ny < H[r] && !used[ny][nx]){\n\n                int nl = std::max(l, Room[r][ny][nx]);\n                q.push(mp(nl, mp(nx, ny)));\n            }\n        }\n    }\n}\n\nint main(){\n    while(std::cin >> R, R){\n        REP(i, 2){\n            std::cin >> W[i] >> H[i] >> X[i] >> Y[i];\n            X[i]--; Y[i]--;\n\n            maxR[i].clear();\n            maxR[i][0] = 0;\n\n            REP(j, H[i]){\n                REP(k, W[i]){\n                    std::cin >> Room[i][j][k];\n                }\n            }\n        }\n\n        REP(i, 2){\n            travel(i);\n        }\n        \n        std::vector<int> u, v;\n        int prev = 0;\n        for(auto it=maxR[0].begin();it!=maxR[0].end();it++){\n            u.push_back(it->first);\n            v.push_back(prev + it->second);\n            prev += it->second;\n        }\n\n        int res = INF;\n        prev = 0;\n        for(auto it=maxR[1].begin();it!=maxR[1].end();it++){\n            int r2 = prev + it->second,\n                r1_index = std::lower_bound(v.begin(), v.end(), R-r2) - v.begin();\n        \n            if(r1_index == v.size()){\n                continue;\n            }\n\n            res = std::min(res, it->first + u[r1_index]);\n            prev += it->second;\n        }\n\n        std::cout << res << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define\tmp\tmake_pair\n#define\tpb\tpush_back\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint main(){\n\tfor(int r;scanf(\"%d\",&r),r;){\n\t\tint w1,h1,x1,y1;\tscanf(\"%d%d%d%d\",&w1,&h1,&x1,&y1);\n\t\tx1--,y1--;\n\t\tstatic int room1[500][500];\n\t\tfor(int i=0;i<h1;i++)for(int j=0;j<w1;j++)\tscanf(\"%d\",room1[i]+j);\n\t\tint w2,h2,x2,y2;\tscanf(\"%d%d%d%d\",&w2,&h2,&x2,&y2);\n\t\tx2--,y2--;\n\t\tstatic int room2[500][500];\n\t\tfor(int i=0;i<h2;i++)for(int j=0;j<w2;j++)\tscanf(\"%d\",room2[i]+j);\n\n\t\tvector<pii> roomcnt1;\t// <auth lev,number of rooms>\n\t\tstatic bool visited[500][500];\n\t\tfor(int i=0;i<h1;i++)for(int j=0;j<w1;j++)\tvisited[i][j]=false;\n\t\tint cnt=0,lev=0;\n\t\tvisited[y1][x1]=true;\n\t\troomcnt1.pb(mp(0,0));\n\t\tpriority_queue< pair<int,pii> > pq;\tpq.push(mp(0,mp(y1,x1)));\n\t\twhile(!pq.empty()){\n\t\t\tpair<int,pii> a=pq.top();\tpq.pop();\n\t\t\tint nowlev=-a.first,x=a.second.second,y=a.second.first;\n\t\t\tcnt++;\n\t\t\tif(lev<nowlev){\n\t\t\t\troomcnt1.pb(mp(cnt,nowlev));\n\t\t\t\tlev=nowlev;\n\t\t\t}\n\t\t\telse\t*(roomcnt1.rbegin())=mp(cnt,lev);\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint xx=x+dx[i],yy=y+dy[i];\n\t\t\t\tif(0<=xx && xx<w1 && 0<=yy && yy<h1 && !visited[yy][xx]){\n\t\t\t\t\tpq.push(mp(-room1[yy][xx],mp(yy,xx)));\n\t\t\t\t\tvisited[yy][xx]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<pii> roomcnt2;\n\t\tfor(int i=0;i<h1;i++)for(int j=0;j<w1;j++)\tvisited[i][j]=false;\n\t\tcnt=0,lev=0;\n\t\tvisited[y2][x2]=true;\n\t\troomcnt2.pb(mp(0,0));\n\t\tpq=priority_queue< pair<int,pii> >();\tpq.push(mp(0,mp(y2,x2)));\n\t\twhile(!pq.empty()){\n\t\t\tpair<int,pii> a=pq.top();\tpq.pop();\n\t\t\tint nowlev=-a.first,x=a.second.second,y=a.second.first;\n\t\t\tcnt++;\n\t\t\tif(lev<nowlev){\n\t\t\t\troomcnt2.pb(mp(cnt,nowlev));\n\t\t\t\tlev=nowlev;\n\t\t\t}\n\t\t\telse\t*(roomcnt2.rbegin())=mp(cnt,lev);\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint xx=x+dx[i],yy=y+dy[i];\n\t\t\t\tif(0<=xx && xx<w2 && 0<=yy && yy<h2 && !visited[yy][xx]){\n\t\t\t\t\tpq.push(mp(-room2[yy][xx],mp(yy,xx)));\n\t\t\t\t\tvisited[yy][xx]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans=1<<30;\n\t\tfor(int i=0;i<roomcnt1.size();i++){\n\t\t\tint rem=r-roomcnt1[i].first;\n\t\t\tint lev1=roomcnt1[i].second;\n\t\t\tint lev2=lower_bound(roomcnt2.begin(),roomcnt2.end(),mp(rem,0))->second;\n\t\t\tans=min(ans,lev1+lev2);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ALL(a) (a).begin(), (a).end()\n#define llong long long\n\nusing namespace std;\n\n\nsigned main(){\n\twhile(true){\n\t\tint r; cin >> r;\n\t\tif(r == 0)break;\n\t\tvector<int> a(r+1, -(int)1e9);\n\t\ta[0] = 0;\n\t\tint dx[] = {-1,0,1,0};\n\t\tint dy[] = {0,1,0,-1};\n\t\t{\n\t\t\tint w,h,x,y;cin >> w >> h >> x >> y;\n\t\t\tvector<vector<int> > m(h+2,vector<int>(w+2,-(int)1e9));\n\t\t\tfor(int i = 1; i <= h; i++)for(int j = 1; j <= w; j++){\n\t\t\t\tcin >> m[i][j];\n\t\t\t\tm[i][j] *= -1;\n\t\t\t}\n\t\t\tpriority_queue<pair<int, pair<int, int> > > p;\n\t\t\tvector<vector<bool> > used(h+2, vector<bool>(w+2));\n\t\t\tp.push({m[y][x],{y,x}});\n\t\t\tused[y][x] = true;\n\t\t\tint c = 0;\n\t\t\twhile(!p.empty()){\n\t\t\t\tauto tmp = p.top();\n\t\t\t\tc++;\n\t\t\t\ta[c] = tmp.first;\n\t\t\t\tif(c >= r)break;\n\t\t\t\tp.pop();\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tint nextx = tmp.second.second+dx[i];\n\t\t\t\t\tint nexty = tmp.second.first+dy[i];\n\t\t\t\t\tif(0 < nextx && nextx <= w && 0 < nexty && nexty <= h){\n\t\t\t\t\tif(!used[nexty][nextx]){\n\t\t\t\t\t\tused[nexty][nextx] = true;\n\t\t\t\t\t\tp.push({min(tmp.first,m[nexty][nextx]),{nexty,nextx}});\n\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> b(r+1, -(int)1e9);\n\t\tb[0] = 0;\n\t\t{\n\t\t\tint w,h,x,y;cin >> w >> h >> x >> y;\n\t\t\tvector<vector<int> > m(h+2,vector<int>(w+2,-(int)1e9));\n\t\t\tfor(int i = 1; i <= h; i++)for(int j = 1; j <= w; j++){\n\t\t\t\tcin >> m[i][j];\n\t\t\t\tm[i][j] *= -1;\n\t\t\t}\n\t\t\tpriority_queue<pair<int, pair<int, int> > > p;\n\t\t\tvector<vector<bool> > used(h+2, vector<bool>(w+2));\n\t\t\tp.push({m[y][x],{y,x}});\n\t\t\tused[y][x] = true;\n\t\t\tint c = 0;\n\t\t\twhile(!p.empty()){\n\t\t\t\tauto tmp = p.top();\n\t\t\t\tc++;\n\t\t\t\tb[c] = tmp.first;\n\t\t\t\tif(c >= r)break;\n\t\t\t\tp.pop();\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tint nextx = tmp.second.second+dx[i];\n\t\t\t\t\tint nexty = tmp.second.first+dy[i];\n\t\t\t\t\tif(0 < nextx && nextx <= w && 0 < nexty && nexty <= h){\n\t\t\t\t\t\tif(!used[nexty][nextx]){\n\t\t\t\t\t\t\tused[nexty][nextx] = true;\n\t\t\t\t\t\t\tp.push({min(tmp.first,m[nexty][nextx]),{nexty,nextx}});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tfor(auto e : a)cerr << e << \" \";\n//\t\tcerr << endl;\n//\t\tfor(auto e : b)cerr << e << \" \";\n//\t\tcerr << endl;\n\t\tint ans = -(int)1e9;\n\t\tfor(int i = 0; i <= r; i++){\n\t\t\tans = max(ans,a[i]+b[r-i]);\n\t\t}\n\t\tcout << (-ans) << endl;\n\t}\n\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst int INF = 1 << 24;\nconst int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};\n\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nint R, W[2], H[2], X[2], Y[2];\nint Room[2][500][500];\nstd::vector<int> L[2]; // 事務所ごとの存在するレベル\nint maxR[2][250001]; // maxR[i][j]: 事務所iでj番目に小さいレベルで行ける部屋の数\nint used[500][500];\n\nvoid travel(int r){\n    REP(j, H[r]){\n        REP(k, W[r]){\n            used[j][k] = 0;\n        }\n    }\n    \n    std::priority_queue<State, std::vector<State>, std::greater<State>> q;\n    q.push(mp(1, mp(X[r], Y[r])));\n    used[Y[r]][X[r]] = 1;\n    maxR[r][1] = 1;\n\n    while(!q.empty()){\n        State s = q.top(); q.pop();\n        int l = s.first;\n        P p = s.second;\n        int x = p.first, y = p.second;\n\n        //std::cout << x << \",\" << y << \",\" << l << std::endl;\n\n        REP(i, 4){\n            int nx = x + dx[i], ny = y + dy[i];\n            if(0 <= nx && nx < W[r] && 0 <= ny && ny < H[r] && !used[ny][nx]){\n\n                int nl = std::max(l, Room[r][ny][nx]),\n                    nl_index = std::distance(L[r].begin(), std::find(L[r].begin(), L[r].end(), nl));\n\n                q.push(mp(nl, mp(nx, ny)));\n                used[ny][nx] = 1;\n                maxR[r][nl_index]++;\n            }\n        }\n    }\n}\n\nint main(){\n    while(std::cin >> R, R){\n        REP(i, 2){\n            std::cin >> W[i] >> H[i] >> X[i] >> Y[i];\n            X[i]--; Y[i]--;\n\n            L[i].push_back(0);\n            REP(j, H[i]){\n                REP(k, W[i]){\n                    std::cin >> Room[i][j][k];\n                    L[i].push_back(Room[i][j][k]);\n                }\n            }\n\n            std::sort(L[i].begin(), L[i].end());\n            L[i].erase(std::unique(L[i].begin(), L[i].end()), L[i].end());\n        }\n\n        REP(i, 2){\n            REP(j, L[i].size()){\n                maxR[i][j] = 0;\n            }\n        }\n\n        REP(i, 2){\n            travel(i);\n        }\n\n        REP(i, 2){\n            //std::cout << maxR[i][0] << std::endl;\n            FOR(j, 1, L[i].size()){\n                maxR[i][j] += maxR[i][j-1];\n                // std::cout << maxR[i][j] << std::endl;\n            }\n            // puts(\"##############################\");\n        }\n\n        int res = INF;\n        REP(i, L[0].size()){\n            int r1 = maxR[0][i],\n                r2_index = std::lower_bound(maxR[1], maxR[1]+L[1].size(), R-r1) - maxR[1];\n        \n            if(r2_index == L[1].size()){\n                continue;\n            }\n\n            res = std::min(res, L[0][i] + L[1][r2_index]);\n        }\n\n        std::cout << res << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pint;\ntypedef pair<ll, int> P;\n//typedef tuple<int,int,int> T;\nll INFL = 1000000000000000010;//10^18 = 2^60\nint INF = 2147483600;//10^9\nll MOD  = 1000000007;\nvector<int> dy = {1,-1,0,0};\nvector<int> dx = {0,0,1,-1};\nvector<ll> Ans(0);\nint solve(){\n    \n    int R;\n    cin >> R;\n    if(R == 0)return 0;\n    int H1,W1,X1,Y1;\n    cin >> W1 >> H1 >> X1 >> Y1;\n    X1--;\n    Y1--;\n    vector<vector<ll> > mp1(H1, vector<ll>(W1));\n    vector<vector<ll> > d1(H1, vector<ll>(W1, INFL));\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            cin >> mp1[i][j];\n        }\n    }\n    \n    d1[Y1][X1] = 1;\n    priority_queue<pair<ll, pair<int, int> > > pque1;\n    pque1.push({1, {Y1, X1}});\n    \n    while(!pque1.empty()){\n        ll c;\n        int y,x;\n        c = pque1.top().first;\n        y = pque1.top().second.first;\n        x = pque1.top().second.second;\n        pque1.pop();\n        if(c > d1[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H1 && 0 <= nx && nx < W1){\n                if(d1[ny][nx] > d1[y][x]){\n                    if(d1[y][x] > mp1[ny][nx]){\n                        d1[ny][nx] = d1[y][x];\n                    }else{\n                        d1[ny][nx] = mp1[ny][nx];\n                    }\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }else if(d1[ny][nx] > d1[y][x]){\n                    d1[ny][nx] = mp1[ny][nx];\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    int H2,W2,X2,Y2;\n    cin >> W2 >> H2 >> X2 >> Y2;\n    X2--;\n    Y2--;\n    vector<vector<ll> > mp2(H2, vector<ll>(W2));\n    vector<vector<ll> > d2(H2, vector<ll>(W2, INFL));\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            cin >> mp2[i][j];\n        }\n    }\n    \n    d2[Y2][X2] = 1;\n    priority_queue<pair<ll, pair<int, int> > > pque2;\n    pque2.push({1, {Y2, X2}});\n    \n    while(!pque2.empty()){\n        ll c;\n        int y,x;\n        c = pque2.top().first;\n        y = pque2.top().second.first;\n        x = pque2.top().second.second;\n        pque2.pop();\n        if(c > d2[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H2 && 0 <= nx && nx < W2){\n                if(d2[ny][nx] > d2[y][x]){\n                    if(d2[y][x] > mp2[ny][nx]){\n                        d2[ny][nx] = d2[y][x];\n                    }else{\n                        d2[ny][nx] = mp2[ny][nx];\n                    }\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }else if(d2[ny][nx] > d2[y][x]){\n                    d2[ny][nx] = mp2[ny][nx];\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    vector<pair<ll,int> > O1(0);\n    vector<ll> COST1(0);\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            COST1.push_back(d1[i][j]);\n        }\n    }\n    sort(COST1.begin(), COST1.end());\n    COST1.push_back(INFL);\n    ll ad1 = COST1.at(0);\n    int cnt = 0;\n    for(int i = 0; i < COST1.size(); i++){\n        if(ad1 == COST1.at(i)){\n            cnt++;\n        }else{\n            O1.push_back({ad1, cnt});\n            ad1 = COST1.at(i);\n            cnt++;\n        }\n    }\n    \n    vector<pair<ll,int> > O2(1);\n    O2.at(0).first = 0;\n    O2.at(0).second = 0;\n    vector<ll> COST2(0);\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            COST2.push_back(d2[i][j]);\n        }\n    }\n    sort(COST2.begin(), COST2.end());\n    COST2.push_back(INFL);\n    ll ad2 = COST2.at(0);\n    cnt = 0;\n    for(int i = 0; i < COST2.size(); i++){\n        if(ad2 == COST2.at(i)){\n            cnt++;\n        }else{\n            O2.push_back({ad2, cnt});\n            ad2 = COST2.at(i);\n            cnt++;\n        }\n    }\n    \n    \n    ll ans = INFL;\n    int right = -1;\n    for(int i = 0; i < O1.size(); i++){\n        ll cost = O1.at(i).first;\n        int rest = R - O1.at(i).second;\n        \n        if(rest > O2.at(O2.size()-1).second) continue;\n        int left = -1;\n        if(right == -1){\n            right = O2.size();\n        }\n        int mid;\n        while(right - left > 1){\n            mid = (left + right) / 2;\n            if(O2.at(mid).second >= rest){\n                right = mid;\n            }else{\n                left = mid;\n            }\n        }\n        cost += O2.at(right).first;\n        ans = min(ans, cost);\n    }\n    \n    Ans.push_back(ans);\n    solve();\n    return 0;\n}\n\nint main(void){\n    solve();\n    for(int i = 0; i < Ans.size(); i++){\n        cout << Ans.at(i) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <utility>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\nusing namespace std;\n#define INF 10000000\n\nint ary1[510][510],ary2[510][510];\nbool used[510][510];\nint main(){\n\tint R,W1,W2,H1,H2,X1,X2,Y1,Y2,imax,imay,imad,res;\n\tpriority_queue<pair<int,pair<int,int> > ,vector<pair<int,pair<int,int> > >,greater<pair<int,pair<int,int> > > > que;\n\tset<int> se1,se2;\n\tvector<int> v1,v2;\n\tpair<int,pair<int,int> > pa;\n\twhile(1){\n\t\tv1.clear();\n\t\tv2.clear();\n\t\tcin>>R;\n\t\tif(R==0) break;\n\t\tcin>>W1>>H1>>Y1>>X1;\n\t\tX1--;Y1--;\n\t\tfor(int i=0;i<H1;i++){\n\t\t\tfor(int j=0;j<W1;j++){\n\t\t\t\tcin>>ary1[i][j];\n\t\t\t}\n\t\t}\n\t\tcin>>W2>>H2>>Y2>>X2;\n\t\tX2--;Y2--;\n\t\tfor(int i=0;i<H2;i++){\n\t\t\tfor(int j=0;j<W2;j++){\n\t\t\t\tcin>>ary2[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemset(used,0,sizeof(used));\n\t\tque.push(make_pair(1,make_pair(X1,Y1)));\n\t\tused[X1][Y1]=true;\n\t\twhile(!que.empty()){\n\t\t\tpa=que.top();que.pop();\n\t\t\timax=pa.second.first;\n\t\t\timay=pa.second.second;\n\t\t\timad=pa.first;\n\t\t\tary1[imax][imay]=imad;\n\t\t\tif(imax>0&&(!used[imax-1][imay])){\n\t\t\t\tused[imax-1][imay]=true;\n\t\t\t\tque.push(make_pair(max(ary1[imax-1][imay],imad),make_pair(imax-1,imay)));\n\t\t\t}\n\t\t\tif(imax<H1-1&&(!used[imax+1][imay])){\n\t\t\t\tused[imax+1][imay]=true;\n\t\t\t\tque.push(make_pair(max(ary1[imax+1][imay],imad),make_pair(imax+1,imay)));\n\t\t\t}\n\t\t\tif(imay>0&&(!used[imax][imay-1])){\n\t\t\t\tused[imax][imay-1]=true;\n\t\t\t\tque.push(make_pair(max(ary1[imax][imay-1],imad),make_pair(imax,imay-1)));\n\t\t\t}\n\t\t\tif(imay<W1-1&&(!used[imax][imay+1])){\n\t\t\t\tused[imax][imay+1]=true;\n\t\t\t\tque.push(make_pair(max(ary1[imax][imay+1],imad),make_pair(imax,imay+1)));\n\t\t\t}\n\t\t}\n\t\tmemset(used,0,sizeof(used));\n\t\tque.push(make_pair(1,make_pair(X2,Y2)));\n\t\tused[X2][Y2]=true;\n\t\twhile(!que.empty()){\n\t\t\tpa=que.top();que.pop();\n\t\t\timax=pa.second.first;\n\t\t\timay=pa.second.second;\n\t\t\timad=pa.first;\n\t\t\tary2[imax][imay]=imad;\n\t\t\tif(imax>0&&(!used[imax-1][imay])){\n\t\t\t\tused[imax-1][imay]=true;\n\t\t\t\tque.push(make_pair(max(ary2[imax-1][imay],imad),make_pair(imax-1,imay)));\n\t\t\t}\n\t\t\tif(imax<H2-1&&(!used[imax+1][imay])){\n\t\t\t\tused[imax+1][imay]=true;\n\t\t\t\tque.push(make_pair(max(ary2[imax+1][imay],imad),make_pair(imax+1,imay)));\n\t\t\t}\n\t\t\tif(imay>0&&(!used[imax][imay-1])){\n\t\t\t\tused[imax][imay-1]=true;\n\t\t\t\tque.push(make_pair(max(ary2[imax][imay-1],imad),make_pair(imax,imay-1)));\n\t\t\t}\n\t\t\tif(imay<W2-1&&(!used[imax][imay+1])){\n\t\t\t\tused[imax][imay+1]=true;\n\t\t\t\tque.push(make_pair(max(ary2[imax][imay+1],imad),make_pair(imax,imay+1)));\n\t\t\t}\n\t\t}\n\t\tv1.push_back(0);\n\t\tfor(int i=0;i<H1;i++){\n\t\t\tfor(int j=0;j<W1;j++){\n\t\t\t\tv1.push_back(ary1[i][j]);\n\t\t\t}\n\t\t}\n\t\tsort(v1.begin(),v1.end());\n\t\tv2.push_back(0);\n\t\tfor(int i=0;i<H2;i++){\n\t\t\tfor(int j=0;j<W2;j++){\n\t\t\t\tv2.push_back(ary2[i][j]);\n\t\t\t}\n\t\t}\n\t\tsort(v2.begin(),v2.end());\n\t\tres=INF;\n\t\tfor(int i=0;i<=R;i++){\n\t\t\tif(W1*H1>=i&&W2*H2>=R-i)res=min(res,v1.at(i)+v2.at(R-i));\n\t\t}\n\t\tcout<<res<<endl;\n\t\t//\n\t\t/*for(int i=0;i<H1;i++){\n\t\t\tfor(int j=0;j<W1;j++){\n\t\t\t\tcout<<ary1[i][j]<<\" \";\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t\tfor(int i=0;i<H2;i++){\n\t\t\tfor(int j=0;j<W2;j++){\n\t\t\t\tcout<<ary2[i][j]<<\" \";\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}*/\n\t\t//\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 160000\n#define B 100\n#define dpb push_back\n#define fi first\n#define se second\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst int inf = 1e9;\nconst ll INF = 1e18;\n//__gcd(a,b), __builtin_popcount(a);\n\nint r, h1, w1, X1, Y1, h2, w2, X2, Y2;\nint dy[4] = {0, 0, -1, 1}, dx[4] = {-1, 1, 0, 0};\nint a[502][502], b[502][502];\nint an[250004], bn[250004];\n\nint to_n(int y, int x, int w){\n\treturn (w*(y-1)+x);\n}\nint to_y(int n, int w){\n\treturn ((n-1)/w+1);\n}\nint to_x(int n, int w){\n\treturn (n-(to_y(n, w)-1)*w);\n}\nint main(){\n\twhile(1){\n\tfill((int*)a, (int*)(a+5001), inf);\n\tfill((int*)b, (int*)(b+5001), inf);\n\tfill(an, an+250004, 0);\n\tfill(bn, bn+250004, 0);\n\tscanf(\"%d\", &r);\n\tif(!r)break;\n\tscanf(\"%d%d%d%d\", &w1, &h1, &X1, &Y1);\n\trrep(i,h1)rrep(j,w1)scanf(\"%d\", &a[i][j]);\n\tscanf(\"%d%d%d%d\", &w2, &h2, &X2, &Y2);\n\trrep(i,h2)rrep(j,w2)scanf(\"%d\", &b[i][j]);\n\t\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tq.push(P(a[Y1][X1], to_n(Y1, X1,w1)));\n\ta[Y1][X1] = inf;\n\tint acnt = 1;\n\twhile(!q.empty()){\n\t\tP p = q.top();q.pop();\n\t\tint y = to_y(p.se, w1), x = to_x(p.se, w1);\n\t\tan[acnt++] = p.fi;\n\t\tfor(int i = 0;i < 4;i++){\n\t\t\tint yy = y+dy[i], xx = x+dx[i];\n\t\t\tif(a[yy][xx] != inf){\n\t\t\t\tq.push(P(a[yy][xx], to_n(yy, xx,w1)));\n\t\t\t\ta[yy][xx] = inf;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tq.push(P(b[Y2][X2], to_n(Y2, X2,w2)));\n\tb[Y2][X2] = inf;\n\tint bcnt = 1;\n\twhile(!q.empty()){\n\t\tP p = q.top();q.pop();\n\t\tint y = to_y(p.se, w2), x = to_x(p.se, w2);\n\t\tbn[bcnt++] = p.fi;\n\t\tfor(int i = 0;i < 4;i++){\n\t\t\tint yy = y+dy[i], xx = x+dx[i];\n\t\t\tif(b[yy][xx] != inf){\n\t\t\t\tq.push(P(b[yy][xx], to_n(yy, xx,w2)));\n\t\t\t\tb[yy][xx] = inf;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint t1 = 0, t2 = 0;\n\tfor(int i = 0;i < acnt;i++){\n\t\tt1 = max(t1, an[i]);\n\t\tan[i] = t1;\n\t}\n\tfor(int i = 0;i < bcnt;i++){\n\t\tt2 = max(t2, bn[i]);\n\t\tbn[i] = t2;\n\t}\n\t\n\tint ans = inf;\n\tfor(int i = 0;i < acnt;i++){\n\t\tif(r-i < bcnt)ans = min(ans, an[i]+bn[r-i]);\n\t}\n\t\n\t/*rep(i,acnt)printf(\"%d \", an[i]);\n\tprintf(\"\\n\");\n\trep(i,bcnt)printf(\"%d \", bn[i]);\n\tprintf(\"\\n\");*/\n\t//int ans = 0;\n\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#define INF (1 << 29)\ntypedef pair<int, int> P; \ntypedef pair<int, P> F;\nint xs[] = {-1, 0, 1, 0}, ys[] = {0, 1, 0, -1};\nvector<int> input_djk(){\n  int w, h, x ,y;\n  cin >> w >> h >> x >> y;\n  x--,y--;\n  int dist[w][h], level[w][h];\n  bool used[w][h];\n  for(int j = 0;j < h;j++){\n    for(int i = 0;i < w;i++){\n      cin >> level[i][j];\n      dist[i][j] = INF;\n      used[i][j] = false;\n    }\n  }\n  \n\n  priority_queue<F, vector<F>, greater<F> > pq;\n  dist[x][y] = 1;\n  used[x][y] = true;\n  pq.push(F(1, P(x, y)));\n  while(!pq.empty()){\n    F tmp = pq.top();pq.pop();\n    int tx = tmp.second.first, ty = tmp.second.second;\n    if(dist[tx][ty] < tmp.first)continue;\n    used[tx][ty] = true;\n    for(int i = 0;i < 4;i++){\n      if(tx + xs[i] < 0 || tx + xs[i] >= w || ty + ys[i] < 0 || ty + ys[i] >= h || used[tx + xs[i]][ty + ys[i]])continue;\n      tx += xs[i], ty += ys[i];\n      if(dist[tx][ty] > max(tmp.first, level[tx][ty])){\n\tdist[tx][ty] = max(tmp.first, level[tx][ty]);\n\tpq.push(F(dist[tx][ty], P(tx, ty)));\n      }\n      tx -= xs[i], ty -= ys[i];\n    }\n  }\n  vector<int> res;\n  for(int i = 0;i < w;i++)\n    for(int j = 0;j < h;j++)\n      res.push_back(dist[i][j]);\n   \n  sort(res.begin(), res.end());\n  return res;\n}\n\nint gs(vector<int> x, int r){\n  if(r == 0)return 0;\n  else return x[r - 1];\n}\n\n\nint solve(vector<int> a, vector<int> b, int r){\n  int res = INF;\n  for(int i = min(r,(int) a.size());i >= 0 && b.size() >= r - i;i--){\n    res = min(res, gs(a, i) + gs(b, r - i));\n  }\n  return res;\n}\n\nint main(){\n  while(true){\n    int r;\n    cin >> r;\n    if(r == 0)return 0;\n    vector<int> a, b;\n    a = input_djk();\n    b = input_djk();\n    cout << solve(a, b, r) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <string>\n#include <map>\n#include <utility>\n#include <set>\n#include <queue>\n#include <unordered_set>\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\n\n//using LL = long long;\n//using P = pair < int, int > ;\n//using PI = pair < P, int > ;\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\nvector<P> visitable(vector<vector<int>>& stage, P start)\n{\n\tint h = stage.size(), w = stage[0].size();\n\tvector<vector<int>> ns(h, vector<int>(w, INF));\n\tset<P> visited;\n\tqueue<P> que;\n\tque.push(start);\n\tvisited.insert(start);\n\tns[start.first][start.second] = 1;\n\twhile (!que.empty())\n\t{\n\t\tP p = que.front(); que.pop();\n\t\trep(i, 4)\n\t\t{\n\t\t\tint nr = dr[i] + p.first, nc = dc[i] + p.second;\n\t\t\tif (nr < 0 || nr >= h || nc < 0 || nc >= w) continue;\n\n\t\t\tint next = max(stage[nr][nc], min(ns[nr][nc], ns[p.first][p.second]));\n\n\t\t\tif (next >= ns[nr][nc]) continue;\n\n\t\t\tns[nr][nc] = next;\n\t\t\tP np = P(nr, nc);\n\t\t\t//if (visited.count(np)) continue;\n\t\t\t//visited.insert(np);\n\t\t\tque.push(np);\n\t\t}\n\t}\n\n\tmap<int, int> mp;\n\trep(i, h) rep(j, w) mp[ns[i][j]]++;\n\tvector<P> ret;\n\tfor (P p : mp) ret.push_back(p);\n\tfor (int i = 0; i + 1 < ret.size(); i++) ret[i + 1].second += ret[i].second;\n\treturn move(ret);\n}\n\n//x個を満たす最小の添字\nint lower(vector<int>& sums, vector<int>& data, int x)\n{\n\tif (sums[sums.size() - 1] < x) return -1;\n\tif (x <= 0) return -2;\n\n\tint idx = lower_bound(all(sums), x) - sums.begin();\n\treturn idx;\n}\n\nsigned main()\n{\n\tint R;\n\twhile (cin >> R && R)\n\t{\n\t\tint w1, h1, c1, r1; cin >> w1 >> h1 >> c1 >> r1;\n\t\tr1--; c1--;\n\t\tvector<vector<int>> stage1(h1, vector<int>(w1));\n\t\trep(i, h1) rep(j, w1) cin >> stage1[i][j];\n\n\t\tvector<P> ps1 = visitable(stage1, P(r1, c1));\n\t\tvector<int> sums1, data1;\n\t\tfor (P p : ps1)\n\t\t{\n\t\t\tsums1.push_back(p.second);\n\t\t\tdata1.push_back(p.first);\n\t\t}\n\n\t\tint w2, h2, c2, r2; cin >> w2 >> h2 >> c2 >> r2;\n\t\tr2--; c2--;\n\t\tvector<vector<int>> stage2(h2, vector<int>(w2));\n\t\trep(i, h2) rep(j, w2) cin >> stage2[i][j];\n\n\t\tvector<P> ps2 = visitable(stage2, P(r2, c2));\n\t\tvector<int> sums2, data2;\n\t\tfor (P p : ps2)\n\t\t{\n\t\t\tsums2.push_back(p.second);\n\t\t\tdata2.push_back(p.first);\n\t\t}\n\n\t\tint ans = INF;\n\t\trep(x, R + 1)\n\t\t{\n\t\t\tint l1 = lower(sums1, data1, x);\n\t\t\tif (l1 == -1) continue;\n\t\t\tint s1 = l1 == -2 ? 0 : sums1[l1];\n\t\t\tint a1 = l1 == -2 ? 0 : data1[l1];\n\n\t\t\tint y = R - s1;\n\t\t\tint l2 = lower(sums2, data2, y);\n\t\t\tif (l2 == -1) continue;\n\t\t\tint s2 = l2 == -2 ? 0 : sums2[l2];\n\t\t\tint a2 = l2 == -2 ? 0 : data2[l2];\n\n\t\t\tans = min(ans, a1 + a2);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst LL INF = 1001001001001001;\n\nint r, x[2], y[2];\nLL grid[2][502][502];\nbool done[2][502][502];\n\nstruct P\n{\n\tint g, x, y;\n\t\n\tbool operator < (const P& t) const {\n\t\treturn grid[g][x][y] > grid[g][t.x][t.y];\n\t}\n};\n\nint search(int g, int num)\n{\n\tfor (int i = 0; i < 502; i++){\n\t\tfor (int j = 0; j < 502; j++){\n\t\t\tdone[g][i][j] = false;\n\t\t}\n\t}\n\t\n\tLL level = 0;\n\tLL mini = INF;\n\tpriority_queue<P> que;\n\tque.push({g, x[g], y[g]});\n\twhile (!que.empty()){\n\t\tP p = que.top(); que.pop();\n\t\tif (done[g][p.x][p.y]) continue;\n\t\tdone[g][p.x][p.y] = true;\n\t\t\n\t\t//printf(\"%d %d %d\\n\", g, p.x, p.y);\n\t\t\n\t\tif (grid[g][p.x][p.y] <= level){\n\t\t\tnum++;\n\t\t\tif (num >= r) return level;\n\t\t}\n\t\telse {\n\t\t\tif (g == 0){\n\t\t\t\tmini = min(mini, level + search(1, num));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (num >= r){\n\t\t\t\t\treturn level;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (grid[g][p.x][p.y] == INF) break;\n\t\t\tlevel = grid[g][p.x][p.y];\n\t\t\tnum++;\n\t\t}\n\t\t\n\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\tint tx = p.x + dx[dir];\n\t\t\tint ty = p.y + dy[dir];\n\t\t\tif (!done[g][tx][ty]){\n\t\t\t\tque.push({g, tx, ty});\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn mini;\n}\n\nint main()\n{\n\twhile (scanf(\"%d\", &r), r){\n\t\tfor (int i = 0; i < 2; i++){\n\t\t\tfor (int j = 0; j < 502; j++){\n\t\t\t\tfor (int k = 0; k < 502; k++){\n\t\t\t\t\tgrid[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint h, w;\n\t\t\tscanf(\"%d %d %d %d\", &w, &h, &y[i], &x[i]);\n\t\t\tfor (int j = 1; j <= h; j++){\n\t\t\t\tfor (int k = 1; k <= w; k++){\n\t\t\t\t\tscanf(\"%d\", &grid[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", search(0, 0));\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf=1<<30;\nint maps[2][510][510];\nbool visited[2][510][510];\nint cnt[2][100010];\nint w[2],h[2],sx[2],sy[2];\nconst int dx[]={1,-1,0,0},dy[]={0,0,1,-1};\nvoid calc(){\n\tfor(int k=0;k<2;k++){\n\t\tint room=0,level=0;\n\t\tpriority_queue<tuple<int,int,int>> pq;\n\t\tfor(int i=0;i<=h[k];i++)\tvisited[k][i][0]=visited[k][i][w[k]+1]=true;\n\t\tfor(int i=0;i<=w[k];i++)\tvisited[k][0][i]=visited[k][h[k]+1][i]=true;\n\t\tpq.push(make_tuple(-1,sx[k],sy[k]));\n\t\twhile(!pq.empty()){\n\t\t\tauto now=pq.top();\tpq.pop();\n\t\t\tint l=-get<0>(now),x=get<1>(now),y=get<2>(now);\n\t\t\tif(visited[k][y][x])\tcontinue;\n\t\t\tvisited[k][y][x]=true;\n\t\t\tif(level<l)\tlevel=l;\n\t\t\troom++;\tcnt[k][room]=level;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint ny=y+dy[i],nx=x+dx[i];\n\t\t\t\tif(visited[k][ny][nx])\tcontinue;\n\t\t\t\tpq.push(make_tuple(-maps[k][ny][nx],nx,ny));\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile(true){\n\t\tint r;\tcin>>r;\n\t\tif(r==0)\treturn 0;\n\t\tmemset(maps,0,sizeof(maps));\n\t\tfor(int k=0;k<2;k++){\n\t\t\tfor(int i=1;i<100010;i++) cnt[k][i]=inf;\n\t\t\tcnt[k][0]=0;\n\t\t\tfor(int i=0;i<510;i++){\n\t\t\t\tfor(int j=0;j<510;j++)\tvisited[k][i][j]=false;\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<2;k++){\n\t\t\tcin>>w[k]>>h[k]>>sx[k]>>sy[k];\n\t\t\tfor(int i=1;i<=h[k];i++){//区画の外側を壁で覆う\n\t\t\t\tfor(int j=1;j<=w[k];j++)\tcin>>maps[k][i][j];\n\t\t\t}\n\t\t}\n\t\tcalc();\n\t\tfor(int k=0;k<2;k++){\n\t\t\tint tmp=inf;\n\t\t\tfor(int i=w[k]*h[k];i>=0;i--){\n\t\t\t\ttmp=min(tmp,cnt[k][i]);\n\t\t\t\tcnt[k][i]=tmp;\n\t\t\t}\n\t\t}\n\t\tint ans=inf;\n\t\tfor(int i=0;i<=r;i++){\n\t\t\tif(i>h[0]*w[0]||r-i>h[1]*w[1])\tcontinue;\n\t\t\tans=min(ans,cnt[0][i]+cnt[1][r-i]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nll W[2],H[2],X[2],Y[2];\nll R;\n\nll field[2][600][600];\nll dist[2][600][600];\n\nll dx[] = {0,1,0,-1};\nll dy[] = {-1,0,1,0};\n\nbool check(){\n    ll sum = 0;\n    for (int k = 0;k < 2;k++){\n        for (int i = 0;i < 600;i++){\n            for (int j = 0;j < 600;j++){\n                dist[k][i][j] = -1;\n            }\n        }\n        for (int i = 1;i <= H[k];i++){\n            for (int j = 1;j <= W[k];j++){\n                dist[k][i][j] = INT_MAX;\n            }\n        }\n        queue<P> que;\n        que.push(P(Y[k],X[k]));\n        dist[k][Y[k]][X[k]] = field[k][Y[k]][X[k]];\n        while(que.size()){\n            P p = que.front(); que.pop();\n            int cy = p.first, cx = p.second;\n            for (int i = 0;i < 4;i++){\n                int ny = cy+dy[i];\n                int nx = cx+dx[i];\n                int cost = max(field[k][ny][nx],dist[k][cy][cx]);\n                if( dist[k][ny][nx] > cost){\n                    dist[k][ny][nx] = cost;\n                    que.push(P(ny,nx));\n                }\n            }\n        }\n    }\n    return sum >= R;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n    cin >> R;\n    if(R == 0) break;\n\n    for (int k = 0;k < 2;k++){\n        cin >> W[k] >> H[k] >> X[k] >> Y[k];\n        for (int i = 1;i <= H[k];i++){\n            for (int j = 1;j <= W[k];j++){\n                cin >> field[k][i][j];\n            }\n        }\n    }\n\n    check();\n\n    map<int,int> cnt[2];\n\n    for (int k = 0;k < 2;k++){\n        //cin >> W[k] >> H[k] >> X[k] >> Y[k];\n        for (int i = 1;i <= H[k];i++){\n            for (int j = 1;j <= W[k];j++){\n                cnt[k][dist[k][i][j]]++;\n            }\n        }\n    }\n\n    vector<P> sum[2];\n\n    sum[0].push_back(P(0,0));\n    sum[1].push_back(P(0,0));\n\n    for (int k = 0;k < 2;k++){\n        for(auto&& i:cnt[k]){\n            sum[k].push_back(P(sum[k][sum[k].size()-1].first+i.second,i.first));\n        }\n    }\n\n    int ans = INT_MAX;\n\n    for (int i = 0;i < sum[0].size();i++){\n        ll now = sum[0][i].first;\n        //cout << sum[0][i].first << \" \" << sum[0][i].second << endl;\n        ll rem = R-now;\n        ll idx = lower_bound(sum[1].begin(),sum[1].end(),P(rem,0))-sum[1].begin();\n        //cout << idx << endl;\n        if(idx == sum[1].size()) continue;\n        //cout << rem << \" \" << sum[1][idx].first << endl;\n        if(sum[1][idx].first+now >= R){\n            ans = min(ans,sum[0][i].second+sum[1][idx].second);\n        }\n    }\n\n    cout << ans << endl;}\n\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 200000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\nstruct ROOM\n{\n\tint level,x,y;\n};\nbool operator <(const ROOM &a,const ROOM &b)\n{\n\treturn a.level > b.level;\n}\nint office[2][510][510];\nbool used[510][510];\nint W[2],H[2],X[2],Y[2];\nint can[2][100010];\nint dx[]={0,1,-1,0};\nint dy[]={1,0,0,-1};\nint main()\n{\n\twhile(1)\n\t{\n\t\tint R;\n\t\tcin >> R;\n\t\tif(R==0)break;\n\t\tfor(int i=0;i<100010;i++)\n\t\t{\n\t\t\tcan[0][i]=INF;\n\t\t\tcan[1][i]=INF;\n\t\t}\n\t\tmemset(office,0,sizeof(office));\n\t\tfor(int t=0;t<2;t++)\n\t\t{\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tcin >> W[t] >> H[t] >> X[t] >> Y[t];\n\t\t\tfor(int i=0;i<H[t];i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<W[t];j++)\n\t\t\t\t{\n\t\t\t\t\tcin >> office[t][i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tpriority_queue<ROOM> q;\n\t\t\tROOM f;\n\t\t\tf.level=office[t][Y[t]][X[t]];\n\t\t\tf.x=Y[t]-1;\n\t\t\tf.y=X[t]-1;\n\t\t\tq.push(f);\n\t\t\tint num=0,now=0,mx=0;\n\t\t\twhile(!q.empty())\n\t\t\t{\n\t\t\t\tROOM a=q.top();\n\t\t\t\tif(used[a.x][a.y])\n\t\t\t\t{\n\t\t\t\t\tq.pop();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tnow=max(now,a.level);\n\t\t\t\twhile(now>=a.level)\n\t\t\t\t{\n\t\t\t\t\tq.pop();\n\t\t\t\t\tif(!used[a.x][a.y])\n\t\t\t\t\t{\n\t\t\t\t\t\tused[a.x][a.y]=true;\n\t\t\t\t\t\tnum++;\n\t\t\t\t\t\tfor(int i=0;i<4;i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint nx=a.x+dx[i],ny=a.y+dy[i];\n\t\t\t\t\t\t\tif(nx>=0&&nx<H[t]&&ny>=0&&ny<W[t]&&!used[nx][ny])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tROOM b;\n\t\t\t\t\t\t\t\tb.level=office[t][nx][ny];\n\t\t\t\t\t\t\t\tb.x=nx;\n\t\t\t\t\t\t\t\tb.y=ny;\n\t\t\t\t\t\t\t\tq.push(b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(q.empty())break;\n\t\t\t\t\ta=q.top();\n\t\t\t\t}\n\t\t\t\tif(now<a.level)\n\t\t\t\t{\n\t\t\t\t\tq.push(a);\n\t\t\t\t}\n\t\t\t\tfor(int i=mx+1;i<=min(R+1,num+1);i++)\n\t\t\t\t{\n\t\t\t\t\tcan[t][i]=now;\n\t\t\t\t}\n\t\t\t\tmx=num;\n\t\t\t\tif(mx>R)break;\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(int i=1;i<=R;i++)\n\t\t{\n\t\t\tans=min(ans,can[0][i]+can[1][R-i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nstruct Heap {\n\tHeap *l, *r;\n\tint val;\n\tint pos;\n\tHeap(int val, int pos) : val(val), pos(pos){\n\t\tl = r = (Heap *)0;\n\t}\n};\n\nHeap *root;\n\nHeap *meld(Heap *a, Heap *b)\n{\n\tif (!a) return (b);\n\tif (!b) return (a);\n\t\n\tif (a->val > b->val) swap(a, b);\n\ta->r = meld(a->r, b);\n\tswap(a->l, a->r);\n\t\n\treturn (a);\n}\n\nvoid push(Heap x)\n{\n\tHeap *p = new Heap(x);\n\t\n\troot = meld(root, p);\n}\n\nHeap top()\n{\n\treturn (*root);\n}\n\nvoid pop()\n{\n\tHeap *p = root;\n\t\n\troot = meld(root->r, root->l);\n\tdelete p;\n}\n\nint reqLevel[2][500 * 500 + 1];\nint map[512][512];\nbool visited[512][512];\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, 1, 0, -1};\n\nint main()\n{\n\tint R;\n\t\n\twhile (scanf(\"%d\", &R) && R){\n\t\t\n\t\tfor (int t = 0; t < 2; t++){\n\t\t\tint W, H, Sx, Sy;\n\t\t\tscanf(\"%d %d %d %d\", &W, &H, &Sx, &Sy);\n\t\t\t\n\t\t\tfor (int i = 1; i <= R; i++){\n\t\t\t\treqLevel[t][i] = 1000000000;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < H; i++){\n\t\t\t\tfor (int j = 0; j < W; j++){\n\t\t\t\t\tscanf(\"%d\", &map[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tmemset(visited, 0, sizeof(visited));\n\t\t\t--Sy; --Sx;\n\t\t\tpush(Heap(map[Sy][Sx], Sy * 1000 + Sx));\n\t\t\tint req = 0;\n\t\t\tint num = 0;\n\t\t\twhile (root){\n\t\t\t\tHeap x = top();\n\t\t\t\tpop();\n\t\t\t\t\n\t\t\t\tif (visited[x.pos / 1000][x.pos % 1000]) continue;\n\t\t\t\tvisited[x.pos / 1000][x.pos % 1000] = true;\n\t\t\t\t\n\t\t\t\treq = max(req, x.val);\n\t\t\t\treqLevel[t][++num] = req;\n\t\t\t\t\n\t\t\t\tfor (int i = 0; i < 4; i++){\n\t\t\t\t\tint ny = x.pos / 1000 + dy[i], nx = x.pos % 1000 + dx[i];\n\t\t\t\t\tif (0 <= ny && ny < H && 0 <= nx && nx < W){\n\t\t\t\t\t\tpush(Heap(map[ny][nx], ny * 1000 + nx));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 2000000000;\n\t\t\n\t\tfor (int i = 0; i <= R; i++){\n\t\t\tans = min(ans, reqLevel[0][i] + reqLevel[1][R - i]);\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\n\nstatic const double eps = 1e-8;\n\nconst int tx[4] = {+0,+1,+0,-1};\nconst int ty[4] = {-1,+0,+1,+0};\n\nbool visited[501][501];\nint rooms[2][501][501];\n\nint dfs(int sx,int sy,int W,int H,int auth_level,int office_i){\n  if(visited[sy][sx]) return 0;\n  if(auth_level < rooms[office_i][sy][sx]) return 0;\n\n  visited[sy][sx] = true;\n  int res = 1;\n  for(int i = 0; i < 4; i++){\n    int dx = sx + tx[i];\n    int dy = sy + ty[i];\n    if(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n    if(auth_level < rooms[office_i][dy][dx]) continue;\n    res += dfs(dx,dy,W,H,auth_level,office_i);\n  }\n  return res;\n}\n\nint main(){\n  int have_to_visit_rooms;\n  while(~scanf(\"%d\",&have_to_visit_rooms)){\n    int elevator_x[2];\n    int elevator_y[2];\n    int W[2];\n    int H[2];\n    vector<int> auth_candidates;\n    for(int office_i = 0; office_i < 2; office_i++){\n      scanf(\"%d %d %d %d\",&W[office_i],&H[office_i],\n            &elevator_x[office_i],&elevator_y[office_i]);\n      elevator_x[office_i]--;\n      elevator_y[office_i]--;\n\n      for(int y = 0; y < H[office_i]; y++){\n        for(int x = 0; x < W[office_i]; x++){\n          scanf(\"%d\",&rooms[office_i][y][x]);\n          if(office_i == 1){\n            auth_candidates.push_back(rooms[office_i][y][x]);\n          }\n        }\n      }\n    }\n\n    sort(auth_candidates.begin(),auth_candidates.end());\n    auth_candidates.erase(unique(auth_candidates.begin(),auth_candidates.end()),\n                          auth_candidates.end());\n    int res = 1000000000;\n    for(int auth_i = 0; auth_i < auth_candidates.size(); auth_i++){\n      int first_auth = auth_candidates[auth_i];\n\n      int lhs = 0; \n      int rhs = 1000000000;\n\n      for(int round = 0; round < 30; round++){\n        int mid = lhs + (rhs - lhs) / 2;\n        int sum = 0;\n        for(int office_i = 0; office_i < 2; office_i++){\n          memset(visited,false,sizeof(visited));\n          if(office_i == 0){\n            sum += dfs(elevator_x[office_i],\n                       elevator_y[office_i],\n                       W[office_i],H[office_i],mid,office_i);\n          }\n          else{\n            sum += dfs(elevator_x[office_i],\n                       elevator_y[office_i],\n                       W[office_i],H[office_i],first_auth,office_i);\n          }\n        }\n        \n        if(sum < have_to_visit_rooms){\n          lhs = mid;\n        }\n        else{\n          rhs = mid;\n          res = min(rhs + first_auth,res);          \n        }\n      }\n    }\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\nusing namespace std;\nconst long long INF = 1LL << 60;    // 1.15x10^18\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nint main() {\n    int r;\n    while (cin >> r, r) {\n        vector<int> w(2), h(2), x(2), y(2);\n        using ll = long long;\n        using Field = vector<vector<ll>>;\n        vector<Field> a(2);\n        for (int k: {0, 1}) {\n            cin >> w[k] >> h[k] >> x[k] >> y[k]; x[k]--, y[k]--;\n            a[k].resize(h[k], vector<ll>(w[k]));\n            for (auto &ai: a[k]) for (auto &aij: ai) cin >> aij;\n        }\n        auto dijkstra = [&](const Field &a, int si, int sj) {\n            int h = a.size(), w = a[0].size();\n            vector<vector<ll>> dp(h, vector<ll>(w, INF));\n            using pii = pair<int, int>;\n            using Pi = pair<long long, pii>;\n            priority_queue<Pi, vector<Pi>, greater<Pi>> que;\n            dp[si][sj] = a[si][sj]; que.emplace(dp[si][sj], pii(si, sj));\n            int dij[] = {0, 1, 0, -1, 0};\n            while (!que.empty()) {\n                long long cost; pii p; tie(cost, p) = que.top(); que.pop();\n                int i, j; tie(i, j) = p;\n                if (dp[i][j] < cost) continue;\n                for (int k = 0; k < 4; k++) {\n                    int ni = i + dij[k], nj = j + dij[k + 1];\n                    if (ni < 0 || ni >= h || nj < 0 || nj >= w) continue;\n                    if (chmin(dp[ni][nj], max(dp[i][j], a[ni][nj]))) {\n                        que.emplace(dp[ni][nj], pii(ni, nj));\n                    }\n                }\n            }\n            vector<ll> dist(h * w);\n            for (int i = 0; i < h; i++) for (int j = 0; j < w; j++) {\n                dist[i * w + j] = dp[i][j];\n            }\n            dist.emplace_back(0);\n            sort(dist.begin(), dist.end());\n            return dist;\n        };\n        auto v = dijkstra(a[0], y[0], x[0]);\n        auto u = dijkstra(a[1], y[1], x[1]);\n        int n = h[0] * w[0], m = h[1] * w[1];\n        ll ans = INF;\n        for (int i = 0; i <= r; i++) {\n            if (i <= n && r - i <= m) chmin(ans, v[i] + u[r - i]);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,-1,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pint pair<int,int>\n#define tint tuple<int,int,int>\n#define INF 1<<29\n#define MAX 501\nusing namespace std;\n \nint R,W[2],H[2],X[2],Y[2],L[2][MAX][MAX],d[2][MAX][MAX],dd[4]={0,-1,0,1};\nmap<int,int> m[2];\nmap<int,int>::iterator ite;\n \nvoid solve(){\n for(;;){\n  cin>>R;\n  if(!R) return;\n  FOR(i,2){\n   cin>>W[i]>>H[i]>>X[i]>>Y[i];\n   X[i]--;\n   Y[i]--;\n   FOR(j,H[i]) FOR(k,W[i]) cin>>L[i][j][k];\n   FOR(j,H[i]) FOR(k,W[i]) d[i][j][k]=INT_MAX/3;\n   d[i][Y[i]][X[i]]=1;\n   priority_queue<pint,vector<pint>,greater<pint>> pque;\n   pque.push(mp(1,Y[i]*W[i]+X[i]));\n   while(!pque.empty()){\n    pint p=pque.top(); pque.pop();\n    int x=p.second/W[i],y=p.second-x*W[i];\n    if(d[i][x][y]<p.first) continue;\n    FOR(j,4){\n     int nx=x+dd[j],ny=y+dd[j^1];\n     if(nx<0||ny<0||nx>=H[i]||ny>=W[i]) continue;\n     if(d[i][nx][ny]>max(d[i][x][y],L[i][nx][ny])){\n      d[i][nx][ny]=max(d[i][x][y],L[i][nx][ny]);\n      pque.push(mp(d[i][nx][ny],nx*W[i]+ny));\n     }\n    }\n   }\n   FOR(j,H[i]) FOR(k,W[i]) m[i][d[i][j][k]]++;\n   for(ite=m[i].begin();ite!=m[i].end();ite++){\n    if(ite==m[i].begin()) continue;\n    ite->second+=(--ite)->second;\n    ite++;\n   }\n  }\n  int mi=min(m[0].lower_bound(R)->first,m[1].lower_bound(R)->first);\n  for(ite=m[0].begin();ite!=m[0].end();ite++){\n   mi=min(mi,(ite->first)+(m[1].lower_bound(R-(ite->second))->first));\n  }\n  cout<<mi<<endl;\n  FOR(i,2) m[i].clear();\n }\n}\n \nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint l[2][500][500];\nbool c[2][500][500];\nint memo[2][100001];\n\nstruct level{\n  int l;\n  int x;\n  int y;\n  level(int a,int b,int c){\n    l=a; x=b; y=c;\n  }\n};\n\nbool operator < (const level &a, const level &b){\n  return a.l > b.l;\n}\n\nint main(){\n  int r;\n  while(r = getInt()){\n    int w[2],h[2],x[2],y[2];\n    REP(k,2){\n      w[k] = getInt();\n      h[k] = getInt();\n      x[k] = getInt() - 1;\n      y[k] = getInt() - 1;\n      REP(i,h[k]) REP(j,w[k]){\n        l[k][i][j] = getInt();\n        c[k][i][j] = false;\n      }\n\n      continue;\n\n      priority_queue<level> pq;\n      pq.push(level(1,x[k],y[k]));\n      c[k][y[k]][x[k]] = true;\n\n      int cnt = 0;\n      int now = 1;\n\n      memo[k][cnt++] = 0;\n      while(!pq.empty()){\n        level lv = pq.top();\n        int ll = lv.l;\n        int xx = lv.x;\n        int yy = lv.y;\n        pq.pop();\n        //printf(\"%d %d %d\\n\",ll,xx,yy);\n\n        memo[k][cnt++] = (now = max(ll, now));\n\n        REP(i,4){\n          int xxx = xx + _dx[i];\n          int yyy = yy + _dy[i];\n\n          if(ISIN(xxx,yyy,w[k],h[k]) && !c[k][yyy][xxx]){\n            c[k][yyy][xxx] = true;\n            pq.push(level(l[k][yyy][xxx], xxx, yyy));\n          }\n        }\n      }\n\n      //REP(i, w[k]*h[k]+1) printf(\"%d \",memo[k][i]); puts(\"\");\n    }\n\n    int end = min(r, w[0] * h[0]) + 1;\n    int start = max(0, r - w[1] * h[1]);\n    int ans = INT_MAX;\n    rep(i,start,end)\n      ans = min(ans, memo[0][i] + memo[1][r-i]);\n    print(ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#define INF (1 << 29)\ntypedef pair<int, int> P; \ntypedef pair<int, P> F;\nint xs[] = {-1, 0, 1, 0}, ys[] = {0, 1, 0, -1};\nvector<int> input_djk(){\n  int w, h, x ,y;\n  cin >> w >> h >> x >> y;\n  x--,y--;\n  int dist[w][h], level[w][h];\n  for(int i = 0;i < w;i++)\n    for(int j = 0;j < h;j++)\n      dist[i][j] = INF;\n  for(int j = 0;j < h;j++){\n    for(int i = 0;i < w;i++){\n      cin >> level[i][j];\n    }\n  }\n  priority_queue<F, vector<F>, greater<F> > pq;\n  dist[x][y] = 1;\n  pq.push(F(1, P(x, y)));\n  while(!pq.empty()){\n    F tmp = pq.top();pq.pop();\n    int tx = tmp.second.first, ty = tmp.second.second;\n    if(dist[tx][ty] < tmp.first)continue;\n    for(int i = 0;i < 4;i++){\n      if(tx + xs[i] < 0 || tx + xs[i] >= w || ty + ys[i] < 0 || ty + ys[i] >= h)continue;\n      tx += xs[i], ty += ys[i];\n      if(dist[tx][ty] > max(tmp.first, level[tx][ty])){\n\tdist[tx][ty] = max(tmp.first, level[tx][ty]);\n\tpq.push(F(dist[tx][ty], P(tx, ty)));\n      }\n      tx -= xs[i], ty -= ys[i];\n    }\n  }\n  vector<int> res;\n  for(int i = 0;i < h;i++)\n    for(int j = 0;j < w;j++)\n      res.push_back(dist[j][i]);\n   \n  sort(res.begin(), res.end());\n  return res;\n}\n\nint gs(vector<int> x, int r){\n  if(r == 0)return 0;\n  else return x[r - 1];\n}\n\n\nint solve(vector<int> a, vector<int> b, int r){\n  int res = INF;\n  for(int i = min(r,(int) a.size());i >= 0 && b.size() >= r - i;i--){\n    res = min(res, gs(a, i) + gs(b, r - i));\n  }\n  return res;\n}\n\nint main(){\n  while(true){\n    int r;\n    cin >> r;\n    if(r == 0)return 0;\n    vector<int> a, b;\n    a = input_djk();\n    b = input_djk();\n\n    cout << solve(a, b, r) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,-1,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pint pair<int,int>\n#define tint tuple<int,int,int>\n#define INF 1<<29\n#define MAX 501\nusing namespace std;\n \nint R,W[2],H[2],X[2],Y[2],L[2][MAX][MAX],d[2][MAX][MAX],dd[4]={0,-1,0,1};\nmap<int,int> m[2];\nmap<int,int>::iterator ite;\n \nvoid solve(){\n for(;;){\n  cin>>R;\n  if(!R) return;\n  FOR(i,2){\n   cin>>W[i]>>H[i]>>X[i]>>Y[i];\n   X[i]--;\n   Y[i]--;\n   FOR(j,H[i]) FOR(k,W[i]) cin>>L[i][j][k];\n   FOR(j,H[i]) FOR(k,W[i]) d[i][j][k]=INT_MAX/3;\n   d[i][Y[i]][X[i]]=1;\n   priority_queue<pint,vector<pint>,greater<pint>> pque;\n   pque.push(mp(1,Y[i]*W[i]+X[i]));\n   while(!pque.empty()){\n    pint p=pque.top(); pque.pop();\n    int x=p.second/W[i],y=p.second-x*W[i];\n    if(d[i][x][y]<p.first) continue;\n    FOR(j,4){\n     int nx=x+dd[j],ny=y+dd[j^1];\n     if(nx<0||ny<0||nx>=H[i]||ny>=W[i]) continue;\n     if(d[i][nx][ny]>max(d[i][x][y],L[i][nx][ny])){\n      d[i][nx][ny]=max(d[i][x][y],L[i][nx][ny]);\n      pque.push(mp(d[i][nx][ny],nx*W[i]+ny));\n     }\n    }\n   }\n   FOR(j,H[i]) FOR(k,W[i]) m[i][d[i][j][k]]++;\n   for(ite=m[i].begin();ite!=m[i].end();ite++){\n    if(ite==m[i].begin()) continue;\n    ite->second+=(--ite)->second;\n    ite++;\n   }\n  }\n  int mi=min(m[0].lower_bound(R)->first,m[1].lower_bound(R)->first);\n  for(ite=m[0].begin();ite!=m[0].end();ite++){\n   mi=min(mi,(ite->first)+(m[1].lower_bound(R-(ite->second))->first));\n  }\n  cout<<mi<<endl;\n  FOR(i,2) m[i].clear();\n }\n}\n \nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    int dy[] = {0, 0, 1, -1};\n    int dx[] = {1, -1, 0, 0};\n    const int INF = INT_MAX/2;\n\n    for(;;){\n        int r;\n        cin >> r;\n        if(r == 0)\n            return 0;\n\n        int w[2], h[2], x0[2], y0[2];\n        vector<vector<int> > room[2];\n        for(int i=0; i<2; ++i){\n            cin >> w[i] >> h[i] >> x0[i] >> y0[i];\n            room[i].assign(h[i]+2, vector<int>(w[i]+2, INF));\n            for(int j=1; j<=h[i]; ++j){\n                for(int k=1; k<=w[i]; ++k){\n                    cin >> room[i][j][k];\n                }\n            }\n        }\n\n        vector<int> level[2];\n        for(int i=0; i<2; ++i){\n            level[i].resize(h[i]*w[i]+1, INF);\n            level[i][0] = 0;\n            multimap<int, pair<int, int> > mm;\n            vector<vector<int> > check(h[i]+2, vector<int>(w[i]+2, INF));\n            mm.insert(make_pair(room[i][y0[i]][x0[i]], make_pair(y0[i], x0[i])));\n            check[y0[i]][x0[i]] = room[i][y0[i]][x0[i]];\n            int a = 1;\n            while(!mm.empty()){\n                int l = mm.begin()->first;\n                int y = mm.begin()->second.first;\n                int x = mm.begin()->second.second;\n                mm.erase(mm.begin());\n                if(l > check[y][x])\n                    continue;\n                level[i][a] = l;\n                ++ a;\n                for(int j=0; j<4; ++j){\n                    int y1 = y + dy[j];\n                    int x1 = x + dx[j];\n                    if(max(l, room[i][y1][x1]) < check[y1][x1]){\n                        mm.insert(make_pair(max(l, room[i][y1][x1]), make_pair(y1, x1)));\n                        check[y1][x1] = max(l, room[i][y1][x1]);\n                    }\n                }\n            }\n        }\n\n        int ret = INF;\n        for(unsigned i=0; i<=r; ++i){\n            if(i >= level[0].size() || r-i >= level[1].size())\n                continue;\n            ret = min(ret, level[0][i] + level[1][r-i]);\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdlib>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint main(){\n  int i,j,k;\n  int n;\n  while(cin>>n&&n){\n    int a[2][502][502],w[2],h[2],sx[2],sy[2];\n    memset(a,-1,sizeof(a));\n    for(i=0;i<2;i++){\n      cin>>w[i]>>h[i]>>sx[i]>>sy[i];\n      for(j=1;j<h[i]+1;j++)\n\tfor(k=1;k<w[i]+1;k++)\n\t  cin>>a[i][k][j];\n    }\n    vector<pair<int,int> > b[2];\n    for(i=0;i<2;i++){\n      b[i].reserve(w[i]*h[i]);\n      b[i].push_back(make_pair(0,0));\n      priority_queue<pair<int,pair<int,int> >,deque<pair<int,pair<int,int> > >,greater<pair<int,pair<int,int> > > > c;\n      c.push(make_pair(1,make_pair(sx[i],sy[i])));\n      while(c.empty()==0){\n\tint p,x,y;\n\tp=c.top().first;\n\tx=c.top().second.first;\n\ty=c.top().second.second;\n\tc.pop();\n\tif(a[i][x][y]!=-1){\n\t  a[i][x][y]=-1;\n\t  if(b[i].back().first==p){\n\t    b[i].back().second++;\n\t  }else{\n\t    b[i].push_back(make_pair(p,b[i].back().second+1));\n\t  }\n\t  if(a[i][x+1][y]!=-1)\n\t    c.push(make_pair(max(p,a[i][x+1][y]),make_pair(x+1,y)));\n\t  if(a[i][x-1][y]!=-1)\n\t    c.push(make_pair(max(p,a[i][x-1][y]),make_pair(x-1,y)));\n\t  if(a[i][x][y+1]!=-1)\n\t    c.push(make_pair(max(p,a[i][x][y+1]),make_pair(x,y+1)));\n\t  if(a[i][x][y-1]!=-1)\n\t    c.push(make_pair(max(p,a[i][x][y-1]),make_pair(x,y-1)));  \n\t}\n      }\n    }\n    int sm=200000000;\n    for(i=0;i<(int)b[0].size()&&b[0][i].second+b[1][(int)b[1].size()-1].second<n;i++);\n    for(;i<(int)b[0].size()&&b[0][i].second<n;i++){\n      int mn=1,mx=b[1].size()-1;\n      for(;;){\n\tif(0){\n\t}else if(b[1][(mn+mx)/2-1].second>=n-b[0][i].second){\n\t  mx=(mn+mx)/2-1;\n\t}else if(b[1][(mn+mx)/2].second<n-b[0][i].second){\n\t  mn=(mn+mx)/2+1;\n\t}else{\n\t  break;\n\t}\n      }\n      sm=min(sm,b[0][i].first+b[1][(mn+mx)/2].first);\n    }\n    if(i<(int)b[0].size())\n      sm=min(sm,b[0][i].first);\n    cout<<sm<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,-1,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pint pair<int,int>\n#define tint tuple<int,int,int>\n#define INF 1<<29\n#define MAX 501\nusing namespace std;\n\nint R,W[2],H[2],X[2],Y[2],L[2][MAX][MAX],d[2][MAX][MAX],dd[4]={0,-1,0,1};\nmap<int,int> m[2];\nmap<int,int>::iterator ite;\n\nvoid solve(){\n for(;;){\n  cin>>R;\n  if(!R) return;\n  FOR(i,2){\n   cin>>W[i]>>H[i]>>X[i]>>Y[i];\n   X[i]--;\n   Y[i]--;\n   FOR(j,H[i]) FOR(k,W[i]) cin>>L[i][j][k];\n   FOR(j,H[i]) FOR(k,W[i]) d[i][j][k]=INT_MAX/3;\n   d[i][X[i]][Y[i]]=1;\n   priority_queue<pint,vector<pint>,greater<pint>> pque;\n   pque.push(mp(1,X[i]*W[i]+Y[i]));\n   while(!pque.empty()){\n    pint p=pque.top(); pque.pop();\n    int x=p.second/W[i],y=p.second-x*W[i];\n    if(d[i][x][y]<p.first) continue;\n    FOR(j,4){\n     int nx=x+dd[j],ny=y+dd[j^1];\n     if(nx<0||ny<0||nx>=H[i]||ny>=W[i]) continue;\n     if(d[i][nx][ny]>max(d[i][x][y],L[i][x][y])){\n      d[i][nx][ny]=max(d[i][x][y],L[i][x][y]);\n      pque.push(mp(d[i][nx][ny],nx*W[i]+ny));\n     }\n    }\n   }\n   FOR(j,H[i]) FOR(k,W[i]) m[i][d[i][j][k]]++;\n   for(ite=m[i].begin();ite!=m[i].end();ite++){\n    if(ite==m[i].begin()) continue;\n    m[i][ite->first]+=m[i][(ite-1)->first];\n   }\n  }\n  int mi=m[1].lower_bound(R)->first;\n  for(ite=m[0].begin();ite!=m[0].end();ite++){\n   mi=min(mi,(ite->first)+(m[1].lower_bound(R-(ite->second))->first));\n  }\n  cout<<mi<<endl;\n  FOR(i,2) map[i].clear();\n }\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint R;\nint W[2],H[2],ex[2],ey[2];\nint WS[2][500][500];\nint NL[2][250001];\nint AD[2][500][500];\n\nvoid CANGO(int place,int NLINDEX,int x,int y,int* entered){\n\tif(WS[place][y][x] > NL[place][NLINDEX]){\n\t\treturn;\n\t}\n\tif(x >= W[place] || y >= H[place] || x < 0 || y < 0){\n\t\treturn;\n\t}\n\tif(AD[place][y][x] == 1){\n\t\treturn;\n\t}\n\telse{\n\t\tAD[place][y][x] = 1;\n\t\t(*entered)++;\n\t\tCANGO(place,NLINDEX,x+1,y,entered);\n\t\tCANGO(place,NLINDEX,x-1,y,entered);\n\t\tCANGO(place,NLINDEX,x,y+1,entered);\n\t\tCANGO(place,NLINDEX,x,y-1,entered);\n\t}\n\treturn;\n}\nvoid IniAD(int place){\n\tfor(int i = 0;i < H[place];i++){\n\t\tfor(int j = 0;j < W[place];j++){\n\t\t\tAD[place][i][j] = 0;\n\t\t}\n\t}\n}\nint main(){\n\tint i,j,k;\n\tint ncor[2];\n\tint mcorsole = 0;\n\tint minest[100];\n\twhile(1){\n\t\tcin >> R;\n\t\tif(R == 0){\n\t\t\tbreak;\n\t\t}\n\t\tncor[0] = 0;\n\t\tncor[1] = 0;\n\t\tfor(i = 0;i < 2;i++){\n\t\t\tcin >> W[i] >> H[i] >> ex[i] >> ey[i];\n\t\t\tex[i]--;\n\t\t\tey[i]--;\n\t\t\tfor(j = 0;j < H[i];j++){\n\t\t\t\tfor(k = 0;k < W[i];k++){\n\t\t\t\t\tcin >> WS[i][j][k];\n\t\t\t\t\tNL[i][ncor[i]] = WS[i][j][k];\n\t\t\t\t\tncor[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tNL[i][ncor[i]] = 0;\n\t\t\tsort(NL[i],NL[i]+ncor[i]+1);\n\t\t}\n\t\t//探索(1つは2分木)\n\t\tint in1,in2;\n\t\tint start,last,medi,evergo;\n\t\tminest[mcorsole] = 200000001;\n\t\tfor(i = 0;i < ncor[0]+1;i++){\n\t\t\tin1 = 0;\n\t\t\tCANGO(0,i,ex[0],ey[0],&in1);\n\t\t\tIniAD(0);\n\t\t\tevergo = 0;\n\t\t\tstart = 0;\n\t\t\tlast = ncor[1];\n\t\t\twhile(NL[1][start] < NL[1][last]){\n\t\t\t\tmedi = (start+last)/2;\n\t\t\t\tin2 = 0;\n\t\t\t\tIniAD(1);\n\t\t\t\tCANGO(1,medi,ex[1],ey[1],&in2);\n\t\t\t\tif(in1+in2 >= R){\n\t\t\t\t\tlast = medi;\n\t\t\t\t\tevergo = 1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tstart = medi+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(NL[0][i]+NL[1][start] < minest[mcorsole] && evergo == 1){\n\t\t\t\tminest[mcorsole] = NL[0][i]+NL[1][start];\n\t\t\t}\n\t\t}\n\t\tmcorsole++;\n\t}\n\tfor(i = 0;i < mcorsole;i++){\n\t\tcout << minest[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<map>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<ll,P> PP;\nint r;\nll INF;\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\nint w[2],h[2],x[2],y[2];\nll dp[2][500001];\nll fie[2][501][501];\nbool used[2][501][501];\n\nvoid dijk(int f){\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\tque.push(PP(fie[f][x[f]][y[f]],P(x[f],y[f])));\n\tint cnt=1;\n\twhile(que.size()){\n\t\tPP p=que.top();\n\t\tque.pop();\n\t\tll cost=p.first;\n\t\tint px=p.second.first;\n\t\tint py=p.second.second;\n\t\tif(used[f][px][py])continue;\n\t\tused[f][px][py]=true;\n\t\tdp[f][cnt]=max(cost,dp[f][cnt-1]);\n\t\tcnt++;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=px+dx[i];\n\t\t\tint ny=py+dy[i];\n\t\t\tif(nx>=0 && nx<w[f] && ny>=0 && ny<h[f]){\n\t\t\t\tif(!used[f][nx][ny]){\n\t\t\t\t\tque.push(PP(fie[f][nx][ny],P(nx,ny)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tINF=0;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tmemset(fie,0,sizeof(fie));\n\t\tmemset(used,false,sizeof(used));\n\t\tscanf(\"%d\",&r);\n\t\tif(r==0)break;\n\t\tscanf(\"%d%d%d%d\",&w[0],&h[0],&x[0],&y[0]);\n\t\tx[0]--,y[0]--;\n\t\tfor(int i=0;i<h[0];i++){\n\t\t\tfor(int j=0;j<w[0];j++){\n\t\t\t\tscanf(\"%lld\",&fie[0][j][i]);\n\t\t\t\tINF+=fie[0][j][i];\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d%d%d%d\",&w[1],&h[1],&x[1],&y[1]);\n\t\tx[1]--,y[1]--;\n\t\tfor(int i=0;i<h[1];i++){\n\t\t\tfor(int j=0;j<w[1];j++){\n\t\t\t\tscanf(\"%lld\",&fie[1][j][i]);\n\t\t\t\tINF+=fie[1][j][i];\n\t\t\t}\n\t\t}\n\t\tdijk(0);\n\t\tdijk(1);\n\t\tll res=INF;\n\t\tfor(int i=0;i<=r;i++){\n\t\t\tif(w[0]*h[0]<i)continue;\n\t\t\tif(w[1]*h[1]<r-i)continue;\n\t\t\tres=min(res,dp[0][i]+dp[1][r-i]);\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define INF 100000001\ntypedef struct{\n\tint x,y;\n\tint lev;\n}data;\ndata d[25000];\nint min(int a,int b){return a<b?a:b;}\nint max(int a,int b){return a>b?a:b;}\nint comp(const void *a,const void *b){\n\tdata* p=(data*)a;\n\tdata* q=(data*)b;\n\treturn p->lev-q->lev;\n}\nint comp2(const void *a,const void *b){\n\tint* p=(int*)a;\n\tint* q=(int*)b;\n\treturn *p-*q;\n}\nint cd;\nint level[2][500][500];\nint mlevel[2][500][500];\nint mlevel2[2][25000];\ntypedef struct{\n\tint val;\n\tint time;\n}poss;\nposs pos[2][25001];\nint cpos[2];\nint sx[2];\nint sy[2];\nint w[2];\nint h[2];\nbool used[500][500];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,1,-1,0};\nint main(){\n\tint r,x,y;\n\tint i,j,k;\n\twhile(1){\n\tscanf(\"%d\",&r);\n\tif(r==0)return 0;\n\tfor(i=0;i<2;i++){\n\t\tscanf(\"%d %d %d %d\",&w[i],&h[i],&x,&y);\n\t\tsx[i]=x-1;\n\t\tsy[i]=y-1;\n\t\tfor(j=0;j<h[i];j++)for(k=0;k<w[i];k++)scanf(\"%d\",&level[i][j][k]);\n\t}\n\tcpos[0]=0;\n\tcpos[1]=0;\n\tfor(i=0;i<2;i++)for(j=0;j<h[i];j++)for(k=0;k<w[i];k++)mlevel[i][j][k]=0;\n\tfor(i=0;i<2;i++){\n\t\tcd=0;\n\t\tfor(j=0;j<h[i];j++)for(k=0;k<w[i];k++)used[j][k]=false;\n\t\tdata da;\n\t\tda.x=sx[i];\n\t\tda.y=sy[i];\n\t\tda.lev=level[i][sy[i]][sx[i]];\n\t\td[cd++]=da;\n\t\tused[sy[i]][sx[i]]=true;\n\t\tfor(j=0;j<w[i]*h[i];j++){\n\t\t\tqsort(d,cd,sizeof(data),comp);\n\t\t\tmlevel[i][d[0].y][d[0].x]=d[0].lev;\n\t\t\td[0].lev=INF;\n\t\t\tfor(k=0;k<4;k++){\n\t\t\t\tif(d[0].x+dx[k]>=0&&d[0].x+dx[k]<w[i]&&d[0].y+dy[k]>=0&&d[0].y+dy[k]<h[i]&&!used[d[0].y+dy[k]][d[0].x+dx[k]]){\n\t\t\t\t\tmlevel[i][d[0].y+dy[k]][d[0].x+dx[k]]=max(mlevel[i][d[0].y+dy[k]][d[0].x+dx[k]],max(level[i][d[0].y+dy[k]][d[0].x+dx[k]],mlevel[i][d[0].y][d[0].x]));\n\t\t\t\t\tif(!used[d[0].y+dy[k]][d[0].x+dx[k]]){\n\t\t\t\t\t\tdata dat;\n\t\t\t\t\t\tdat.x=d[0].x+dx[k];\n\t\t\t\t\t\tdat.y=d[0].y+dy[k];\n\t\t\t\t\t\tdat.lev=mlevel[i][d[0].y+dy[k]][d[0].x+dx[k]];\n\t\t\t\t\t\td[cd++]=dat;\n\t\t\t\t\t\tused[d[0].y+dy[k]][d[0].x+dx[k]]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint old=-1;\n\t\tfor(j=0;j<h[i]*w[i];j++)pos[i][j].time=0;\n\t\tfor(j=0;j<h[i];j++)for(k=0;k<w[i];k++)mlevel2[i][j*w[i]+k]=mlevel[i][j][k];\n\t\tqsort(mlevel2[i],w[i]*h[i],sizeof(int),comp2);\n\t\tfor(j=0;j<w[i]*h[i];j++){\n\t\t\tif(mlevel2[i][j]!=old){\n\t\t\t\tpos[i][++cpos[i]].time=1;\n\t\t\t\tpos[i][cpos[i]].time+=pos[i][cpos[i]-1].time;\n\t\t\t\told=mlevel2[i][j];\n\t\t\t\tpos[i][cpos[i]].val=old;\n\t\t\t}\n\t\t\telse pos[i][cpos[i]].time++;\n\t\t}\n\t}\n\tint ans=INF;\n\tint s;\n\tint g;\n\tint mid;\n\tint res;\n\tfor(i=1;i<=cpos[0];i++){\n\t\tres=r-pos[0][i].time;\n\t\tif(res<0){\n\t\t\tans=min(ans,pos[0][i].val);\n\t\t\tcontinue;\n\t\t}\n\t\ts=0;\n\t\tg=cpos[1]+1;\n\t\tfor(j=0;j<40;j++){\n\t\t\tmid=(int)(s+g)/2;\n\t\t\tif(pos[1][mid].time==res)break;\n\t\t\telse if(pos[1][mid].time<res)s=mid;\n\t\t\telse g=mid;\n\t\t}\n\t\tmid=(int)(s+g)/2;\n\t\tif(pos[0][i].time+pos[1][mid].time>=r){\n\t\t\tans=min(ans,pos[0][i].val+pos[1][mid].val);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\t}\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define all(a) a.begin(),a.end()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\n\nconst int inf = 1e9;\n\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, -1, 0, 1};\n\nint R;\nint W[2], H[2];\nint X[2], Y[2];\nint A[2][502][502];\n\nbool used[502][502];\n\nvpii data[2];\n\nvoid bfs(int num)\n{\n\ttypedef pair<int, pii> Data;\n\tmemset(used, false, sizeof(used));\n\n\tpriority_queue<Data> q;\n\n\tq.push(Data(-1, pii(Y[num], X[num])));\n\tused[Y[num]][X[num]] = true;\n\n\tif (num == 0) {\n\t\tdata[num].PB(pii(1, 0));\n\t} else {\n\t\tdata[num].PB(pii(0, 0));\n\t\tdata[num].PB(pii(0, 1));\n\t}\n\n\tint ma = 1;\n\tint cnt = 0;\n\n\twhile (q.size()) {\n\t\tData p = q.top(); q.pop();\n\n\t\tint cur = -p.fst;\n\n\t\tif (ma < cur) {\n\t\t\tif (num == 0) {\n\t\t\t\tdata[num].back().scd = cnt;\n\t\t\t\tma = cur;\n\t\t\t\tdata[num].PB(pii(ma, 0));\n\t\t\t} else {\n\t\t\t\tdata[num].back().fst = cnt;\n\t\t\t\tma = cur;\n\t\t\t\tdata[num].PB(pii(0, ma));\n\t\t\t}\n\t\t}\n\n\t\tcnt++;\n\n\t\trep(i, 4) {\n\t\t\tint ny = p.scd.fst + dy[i], nx = p.scd.scd + dx[i];\n\n\t\t\tif (ny < 0 || ny >= H[num] || nx < 0 || nx >= W[num] || used[ny][nx]) continue;\n\t\t\tused[ny][nx] = true;\n\n\t\t\tq.push(Data(-A[num][ny][nx], pii(ny, nx)));\n\t\t}\n\t}\n\n\tif (num == 0) {\n\t\tdata[num].back().scd = cnt;\n\t} else {\n\t\tdata[num].back().fst = cnt;\n\t}\n}\n\nsigned main()\n{\n\twhile (cin >> R, R) {\n\t\tdata[0].clear();\n\t\tdata[1].clear();\n\n\t\trep(i, 2) {\n\t\t\tcin >> W[i] >> H[i] >> X[i] >> Y[i];\n\n\t\t\t--X[i], --Y[i];\n\n\t\t\trep(j, H[i]) rep(k, W[i]) {\n\t\t\t\tcin >> A[i][j][k];\n\t\t\t}\n\t\t}\n\n\t\tbfs(0);\n\t\tbfs(1);\n\n\t\tint mi = inf;\n\n\t\tdata[1].PB(pii(inf, inf));\n\n\t\trep(i, data[0].size()) {\n\t\t\tpii a = data[0][i];\n\n\t\t\tchmin(mi, a.fst + lower_bound(all(data[1]), pii(R - a.scd, -inf))->scd);\n\t\t}\n\n\t\tcout << mi << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pint;\ntypedef pair<ll, int> P;\n//typedef tuple<int,int,int> T;\nll INFL = 1000000000000000010;//10^18 = 2^60\nint INF = 2147483600;//10^9\nll MOD  = 1000000007;\nint solve(){\n    vector<int> dy(4);\n    vector<int> dx(4);\n    dy.at(0) = 0;\n    dy.at(1) = 0;\n    dy.at(2) = 1;\n    dy.at(3) = -1;\n    dx.at(0) = 1;\n    dx.at(1) = -1;\n    dx.at(2) = 0;\n    dx.at(3) = 0;\n    \n    int R;\n    cin >> R;\n    if(R == 0)return 0;\n    int H1,W1,X1,Y1;\n    cin >> W1 >> H1 >> X1 >> Y1;\n    X1--;\n    Y1--;\n    vector<vector<ll> > mp1(H1, vector<ll>(W1));\n    vector<vector<ll> > d1(H1, vector<ll>(W1, INFL));\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            cin >> mp1[i][j];\n        }\n    }\n    \n    d1[Y1][X1] = 1;\n    priority_queue<pair<ll, pair<int, int> > > pque1;\n    pque1.push({1, {Y1, X1}});\n    \n    while(!pque1.empty()){\n        ll c;\n        int y,x;\n        c = pque1.top().first;\n        y = pque1.top().second.first;\n        x = pque1.top().second.second;\n        pque1.pop();\n        if(c > d1[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H1 && 0 <= nx && nx < W1){\n                if(d1[ny][nx] > d1[y][x]){\n                    if(d1[y][x] > mp1[ny][nx]){\n                        d1[ny][nx] = d1[y][x];\n                    }else{\n                        d1[ny][nx] = mp1[ny][nx];\n                    }\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }else if(d1[ny][nx] > d1[y][x]){\n                    d1[ny][nx] = mp1[ny][nx];\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    int H2,W2,X2,Y2;\n    cin >> W2 >> H2 >> X2 >> Y2;\n    X2--;\n    Y2--;\n    vector<vector<ll> > mp2(H2, vector<ll>(W2));\n    vector<vector<ll> > d2(H2, vector<ll>(W2, INFL));\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            cin >> mp2[i][j];\n        }\n    }\n    \n    d2[Y2][X2] = 1;\n    priority_queue<pair<ll, pair<int, int> > > pque2;\n    pque2.push({1, {Y2, X2}});\n    \n    while(!pque2.empty()){\n        ll c;\n        int y,x;\n        c = pque2.top().first;\n        y = pque2.top().second.first;\n        x = pque2.top().second.second;\n        pque2.pop();\n        if(c > d2[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H2 && 0 <= nx && nx < W2){\n                if(d2[ny][nx] > d2[y][x]){\n                    if(d2[y][x] > mp2[ny][nx]){\n                        d2[ny][nx] = d2[y][x];\n                    }else{\n                        d2[ny][nx] = mp2[ny][nx];\n                    }\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }else if(d2[ny][nx] > d2[y][x]){\n                    d2[ny][nx] = mp2[ny][nx];\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    vector<pair<ll,int> > O1(0);\n    vector<ll> COST1(0);\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            COST1.push_back(d1[i][j]);\n        }\n    }\n    sort(COST1.begin(), COST1.end());\n    COST1.push_back(INFL);\n    ll ad1 = COST1.at(0);\n    int cnt = 0;\n    for(int i = 0; i < COST1.size(); i++){\n        if(ad1 == COST1.at(i)){\n            cnt++;\n        }else{\n            O1.push_back({ad1, cnt});\n            ad1 = COST1.at(i);\n            cnt++;\n        }\n    }\n    \n    vector<pair<ll,int> > O2(1);\n    O2.at(0).first = 0;\n    O2.at(0).second = 0;\n    vector<ll> COST2(0);\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            COST2.push_back(d2[i][j]);\n        }\n    }\n    sort(COST2.begin(), COST2.end());\n    COST2.push_back(INFL);\n    ll ad2 = COST2.at(0);\n    cnt = 0;\n    for(int i = 0; i < COST2.size(); i++){\n        if(ad2 == COST2.at(i)){\n            cnt++;\n        }else{\n            O2.push_back({ad2, cnt});\n            ad2 = COST2.at(i);\n            cnt++;\n        }\n    }\n    \n    ll ans = INFL;\n    for(int i = 0; i < O1.size(); i++){\n        ll cost = O1.at(i).first;\n        int rest = R - O1.at(i).second;\n        \n        if(rest > O2.at(O2.size()-1).second) continue;\n        int left = -1, right = O2.size();\n        int mid;\n        while(right - left > 1){\n            mid = (left + right) / 2;\n            if(O2.at(mid).second >= rest){\n                right = mid;\n            }else{\n                left = mid;\n            }\n        }\n        cost += O2.at(right).first;\n        ans = min(ans, cost);\n        \n    }\n    \n    cout << ans << endl;\n    \n    solve();\n    return 0;\n}\n\nint main(void){\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//c\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <memory>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n \n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define REPR(i,b,n) for(int i=n-1;i>=b;i--)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\n#define NCLR(mat) memset(mat, -1, sizeof(mat))\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define EACH(i, c) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define BIT(n, b) ((n>>b) & 1)\n#define PB push_back\n#define MP make_pair\n \nusing namespace std;\n \nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-9;\ntypedef long long ll;\ntypedef pair<int, int> pii;   \n \nint r;\nint w[2], h[2], ex[2], ey[2];\nint room[2][512][512];\nbool vis[512][512];\n \nint rec(int x, int y, int k, int lev){\n     \n    int res = 0;\n     \n    if(x < 0 || w[k] <= x || y < 0 || h[k] <= y \n        || vis[x][y] || lev < room[k][x][y]){\n        return 0;\n    }\n     \n    vis[x][y] = true;\n     \n    res += rec(x+1, y, k, lev);\n    res += rec(x-1, y, k, lev);\n    res += rec(x, y+1, k, lev);\n    res += rec(x, y-1, k, lev);\n     \n    return res + 1;\n}\n \nint main(){\n     \n    while(cin>>r, r){\n         \n        vector< vector<int> > exlev(2);\n        vector< vector<int> > reach(2);\n         \n        for(int k=0; k<2; ++k){\n             \n            cin>>w[k]>>h[k]>>ex[k]>>ey[k];\n            ex[k]--;\n            ey[k]--;\n             \n             \n            exlev[k].push_back(0);\n             \n            for(int y=0; y<h[k]; ++y){\n                for(int x=0; x<w[k]; ++x){\n\t\t\t\t\n                    cin>>room[k][x][y];\n                    exlev[k].push_back(room[k][x][y]);\n                }\n            }\n\t\t\t\n\t\t\tsort( exlev[k].begin(), exlev[k].end() );\n\t\t\texlev[k].erase( unique(exlev[k].begin(), exlev[k].end()), exlev[k].end() );\n             \n            for(int i=0; i<exlev[k].size(); ++i){\n                CLR(vis);\n                reach[k].push_back(rec(ex[k], ey[k], k, exlev[k][i]));\n            }\n             \n        }\n         \n        int mn = INT_MAX/2;\n         \n        for(int i=0; i<reach[0].size(); ++i){\n            for(int j=lower_bound(reach[1].begin(), reach[1].end(), r-reach[0][i]) - reach[1].begin(); j<reach[1].size(); ++j){\n                 \n                if(reach[0][i]+reach[1][j]>=r){\n                    mn = min(mn, exlev[0][i]+exlev[1][j]);\n                }\n                 \n            }\n        }\n         \n        cout << mn << endl;\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reps(i,n) for(int i=1;i<=n;i++)\n\nconst int INF=1010000000;\n\nint R;\nint w[2],h[2],st[2],gl[2];\nint masu[2][501][501];\n\nint need[2][25001];\n\nint visit[501][501];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nint glcont;\n\nvoid saiki(int w,int h,int x,int y,int masu[501][501],int mn){\n\tif(x<0 || y<0 || x>=w || y>=h)return;\n\tif(masu[x][y]>mn)return;\n\tif(visit[x][y]==1)return;\n\tvisit[x][y]=1;\n\t\n\t\n\trep(i,4){\n\t\tsaiki(w,h,x+dx[i],y+dy[i],masu,mn);\n\t}\n\t\n\tglcont++;\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d\",&R);\n\t\tif(R==0)break;\n\t\t\n\t\trep(i,2){\n\t\t\tscanf(\"%d%d%d%d\",&w[i],&h[i],&st[i],&gl[i]);\n\t\t\t\n\t\t\trep(j,h[i]){\n\t\t\t\trep(k,w[i]){\n\t\t\t\t\tscanf(\"%d\",&masu[i][k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint left,right;\n\t\tleft=0;\n\t\tright=1000000001;\n\t\trep(i,2)rep(j,250001)need[i][j]=INF;\n\t\trep(i,2){\n\t\t\trep(n,w[i]*h[i]+1){\n\t\t\t\tint left,right;\n\t\t\t\tleft=0;right=1000000001;\n\t\t\t\t\n\t\t\t\twhile(1){\n\t\t\t\t\tdouble half= double(left+right)/2.0;\n\t\t\t\t\trep(rr,w[i])rep(ee,h[i])visit[rr][ee]=0;\n\t\t\t\t\tglcont=0;\n\t\t\t\t\t\n\t\t\t\t\tsaiki(w[i],h[i],st[i]-1,gl[i]-1,masu[i],int(half));\n\t\t\t\t\t\n\t\t\t\t\tif(glcont<n){\n\t\t\t\t\t\tleft=half;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tright=int(half-0.5);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(left==right){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tneed[i][n]=left;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint mini=INF*2+1;\n\t\t\n\t\tint dd=0;\n\t\tif(w[0]*h[0] < w[1]+h[1]){\n\t\t\tdd=1;\n\t\t}\n\t\t\n\t\trep(i,250001){\n\t\t\tif(R-i<0)break;\n\t\t\tmini = min(mini, need[dd][i] + need[!dd][R-i]);\n\t\t}\n\t\t/*\n\t\trep(i,2){\n\t\t\tputs(\"\");\n\t\t\trep(n,w[i]*h[i]+1){\n\t\t\t\tprintf(\"%d %d\\n\",n,need[i][n]);\n\t\t\t}\n\t\t}*/\n\t\tprintf(\"%d\\n\",mini);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n \ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n \ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint R;\nint W[2], H[2], X[2], Y[2];\nint grid[500][500][2];\nbool used[500][500];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n/*\nint count(int B, int idx){\n  if(grid[Y[idx]][X[idx]][idx] > B) return 0;\n  queue<int> qx, qy;\n  qx.push(X[idx]);\n  qy.push(Y[idx]);\n  bool used[500][500] = {};\n  used[Y[idx]][X[idx]] = true;\n  int res = 1;\n  while(!qx.empty()){\n    int x = qx.front(), y = qy.front();\n    qx.pop(), qy.pop();\n    REP(r, 4){\n      int nx = x + dx[r];\n      int ny = y + dy[r];\n      if(nx >= 0 && nx < W[idx] && ny >= 0 && ny < H[idx] && grid[ny][nx][idx] <= B && !used[ny][nx]){\n        used[ny][nx] = true;\n        res++;\n        qx.push(nx), qy.push(ny);\n      }\n    }\n  }\n  return res;\n}\n*/\ntypedef pair<int, int> P;\nstruct S{\n  P p;\n  int d;\n  S() {}\n  S(P p, int d) : p(p), d(d) {}\n  bool operator < (const S& s) const {\n    return d > s.d;\n  }\n};\nint get_index(vector<int>& v, int n){\n  return (lower_bound(v.begin(), v.end(), n) - v.begin());\n}\n \nint main(){\n  while(cin>>R && R){\n    vector<int> cand[2];\n    REP(i, 2){\n      cin>>W[i]>>H[i]>>X[i]>>Y[i];\n      X[i]--; Y[i]--;\n      REP(y, H[i])REP(x, W[i]){\n        cin>>grid[y][x][i];\n        cand[i].push_back(grid[y][x][i]);\n      }\n    }\n    REP(i, 2){\n      sort(cand[i].begin(), cand[i].end());\n      cand[i].erase(unique(cand[i].begin(), cand[i].end()), cand[i].end());\n    }\n    vector<int> count[2];\n    REP(i, 2)count[i] = vector<int>(cand[i].size());\n    REP(i, 2){\n      int memo[500][500] = {};\n      REP(y, H[i])REP(x, W[i]) memo[y][x] = INF;\n      priority_queue<S> que;\n      que.push(S(P(X[i], Y[i]), grid[Y[i]][X[i]][i]));\n      memo[Y[i]][X[i]] = grid[Y[i]][X[i]][i];\n      while(!que.empty()){\n        S s = que.top(); que.pop();\n        int x = s.p.first, y = s.p.second;\n        if(memo[y][x] < s.d) continue;\n        REP(r, 4){\n          int nx = x + dx[r], ny = y + dy[r];\n          if(nx >= 0 && nx < W[i] && ny >= 0 && ny < H[i]){\n            int next_d = max(grid[ny][nx][i], s.d);\n            if(next_d >= memo[ny][nx]) continue;\n            memo[ny][nx] = next_d;\n            que.push(S(P(nx, ny), next_d));\n          }\n        }\n      }\n      REP(y, H[i])REP(x, W[i]) count[i][get_index(cand[i], memo[y][x])] ++;\n    }\n    vector<int> sum[2];\n    REP(i, 2){\n      sum[i] = vector<int>(cand[i].size() + 1);\n      REP(j, cand[i].size()) sum[i][j + 1] = sum[i][j] + count[i][j];\n    }\n    int ans = INF;\n    REP(i, cand[0].size() + 1){\n      int rest = R - sum[0][i];\n      int j = get_index(sum[1], rest);\n      ans = min(ans, ((i != 0) ? cand[0][i - 1] : 0) + ((j == 0) ? 0 : (j == cand[1].size() + 1) ? INF : cand[1][j - 1]));\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <iostream>\n\nusing namespace std;\ntypedef long long ll;\n\nint mo[5] = {0,1,0,-1,0};\n\nvoid calc(int r){\n    int w[2],h[2],x[2],y[2],l[2][500][500],c,a,b,s[2][100001]={0},ans=1000000000;\n    bool kaku[2][500][500]={0};\n    pair<int,pair<int,int> > pp;\n    \n    for(int k=0;k<2;k++){\n        priority_queue<pair<int,pair<int,int> > > pq;\n        \n        scanf(\"%d%d%d%d\",&w[k],&h[k],&x[k],&y[k]);\n        \n        for(int i=0;i<h[k];i++)\n            for(int j=0;j<w[k];j++)\n                scanf(\"%d\",&l[k][i][j]);\n        \n        pq.push(make_pair(-1,make_pair(y[k]-1,x[k]-1)));\n        s[k][0]=0;\n        kaku[k][y[k]-1][x[k]-1]=true;\n        c=0;\n        \n        for(int i=1;i<=min(w[k]*h[k],r);i++){\n            pp = pq.top();\n            pq.pop();\n            \n            c=max(c,-pp.first);\n            s[k][i]=c;\n            \n            for(int j=0;j<4;j++){\n                a = pp.second.first+mo[j];\n                b = pp.second.second+mo[j+1];\n                if(0<=a && a<h[k] && 0<=b && b<w[k])\n                    if(!kaku[k][a][b]){\n                        pq.push(make_pair(-l[k][a][b],make_pair(a,b)));\n                        kaku[k][a][b]=true;\n                    }\n            }\n        }\n    }\n    \n    for(int i=0;i<=r;i++){\n        if(i<=w[0]*h[0] && r-i<=w[1]*h[1])\n            ans=min(ans,s[0][i]+s[1][r-i]);\n    }\n    printf(\"%d\\n\",ans);\n    \n    return;\n}\n\nint main(){\n    int r;\n    \n    while(1){\n        scanf(\"%d\",&r);\n        \n        if(r==0) break;\n        \n        calc(r);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<string>\n#include<queue>\n#include<climits>\nusing namespace std;\n\nint vx[4]={0,1,0,-1};\nint vy[4]={1,0,-1,0};\n\nstruct pos{\n  pos(){};\n  pos(int cost,int kpos,int xpos,int ypos){\n    c=cost;\n    k=kpos;\n    x=xpos;\n    y=ypos;\n  }\n  int c,k,x,y;\n};\n\nbool operator<(pos a,pos b){\n  return a.c>b.c;\n}\n\nint r;\npair<int,int> el[2];\nvector< vector<int> > map[2];\nvector< vector<int> > used[2];\nvoid init(){\n  map[0].clear();\n  map[1].clear();\n  used[0].clear();\n  used[1].clear();\n}\n\nint input(){\n  cin>>r;\n  if(r==0)return 0;\n  int x,y;\n  cin>>x>>y;\n  cin>>el[0].second;\n  cin>>el[0].first;\n  el[0].first--;\n  el[0].second--;\n  map[0].resize(y);\n  used[0].resize(y);\n  for(int i=0;i<y;i++){\n    used[0][i].resize(x);\n    for(int j=0;j<x;j++){\n      int tmp;\n      cin>>tmp;\n      map[0][i].push_back(tmp);\n    }\n  }\n  cin>>x>>y;\n  cin>>el[1].second;\n  cin>>el[1].first;\n  el[1].first--;\n  el[1].second--;\n  map[1].resize(y);\n  used[1].resize(y);\n  for(int i=0;i<y;i++){\n    used[1][i].resize(x);\n    for(int j=0;j<x;j++){\n      int tmp;\n      cin>>tmp;\n      map[1][i].push_back(tmp);\n    }\n  }\n  return r;\n\n}\n\nint solve(){\n  \n  priority_queue<pos> q;\n  q.push(pos(map[0][el[0].first][el[0].second] , 0 , el[0].first , el[0].second));\n  q.push(pos(map[1][el[1].first][el[1].second] , 1 , el[1].first , el[1].second));\n\n  vector< pair<int,int> > cost_room[2];\n  pair<int,int> tmp_c[2];\n\n  tmp_c[0].first =0;\n  tmp_c[0].second=0;\n  tmp_c[1].first =0;\n  tmp_c[1].second=0;\n\n  while((!q.empty())){\n    pos tmp=q.top();q.pop();\n    if(used[tmp.k][tmp.x][tmp.y])continue; \n    if(tmp_c[tmp.k].first<tmp.c){\n      cost_room[tmp.k].push_back(tmp_c[tmp.k]);\n      tmp_c[tmp.k].second++;\n      tmp_c[tmp.k].first=tmp.c;\n    }else if(tmp_c[tmp.k].first>=tmp.c && tmp.c!=0){\n      tmp_c[tmp.k].second++;\n    }\n\n    used[tmp.k][tmp.x][tmp.y]=true;\n    for(int i=0;i<4;i++){\n      if((!(tmp.x+vx[i]<0||used[tmp.k].size()-1<tmp.x+vx[i]))\n          &&(!(tmp.y+vy[i]<0||used[tmp.k][tmp.x+vx[i]].size()-1<tmp.y+vy[i]))\n          &&(!used[tmp.k][tmp.x+vx[i]][tmp.y+vy[i]])){\n        q.push(pos( map[tmp.k][tmp.x+vx[i]][tmp.y+vy[i]], tmp.k, tmp.x+vx[i],tmp.y+vy[i]));\n      }\n    }\n  }\n  cost_room[0].push_back(tmp_c[0]);\n  cost_room[1].push_back(tmp_c[1]);\n\n  \n  \n\n  int res=INT_MAX;\n  for(int i=0;i<cost_room[0].size();i++){\n    for(int j=0;j<cost_room[1].size();j++){\n      if( cost_room[0][i].second+cost_room[1][j].second>=r){\n        res=min(cost_room[0][i].first+cost_room[1][j].first,res);\n      }\n    }\n  }\n  return res;\n}\n\n\n\nint main(){\n  while(init(),input()){\n    cout<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\nconst int INF=1e9;\nstruct dat{\n\tint x,y,level;\n\tdat(){}\n\tdat(int x,int y,int level):x(x),y(y),level(level){}\n\tbool operator>(const dat &a)const{\n\t\treturn level>a.level;\n\t}\n};\nbool pos(int x,int y,int w,int h){\n\treturn 0<=x&&x<w&&0<=y&&y<h;\n}\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\nint fld[2][550][550];\nint r,w[2],h[2],sx[2],sy[2];\nint main(){\n\twhile(1){\n\t\tcin>>r;\n\t\tif(r==0)break;\n\t\tREP(i,2){\n\t\t\tcin>>w[i]>>h[i]>>sx[i]>>sy[i];sx[i]--;sy[i]--;\n\t\t\tREP(j,h[i])REP(k,w[i]){\n\t\t\t\tcin>>fld[i][k][j];\n\t\t\t}\n\t\t}\n\t\tvector<P>V[2];\n\t\tREP(i,2){\n\t\t\tV[i].PB(MP(0,0));\n\t\t\tV[i].PB(MP(1,1));\n\t\t}\n\t\tbool used[2][550][550];\n\t\tmemset(used,false,sizeof(used));\n\t\tREP(i,2){\n\t\t\tused[i][sx[i]][sy[i]]=true;\n\t\t\tpriority_queue<dat,vector<dat>,greater<dat> >Q;\n\t\t\tREP(j,4){\n\t\t\t\tif(pos(sx[i]+dx[j],sy[i]+dy[j],w[i],h[i])){\n\t\t\t\t\tQ.push((dat){sx[i]+dx[j],sy[i]+dy[j],fld[i][sx[i]+dx[j]][sy[i]+dy[j]]});\n\t\t\t\t\tused[i][sx[i]+dx[j]][sy[i]+dy[j]]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cnt=1,ma=0;\n\t\t\twhile(!Q.empty()){\n\t\t\t\tdat d=Q.top();Q.pop();\n\t\t\t\tint x=d.x,y=d.y;\n\t\t\t\tcnt++;\n\t\t\t\tma=max(d.level,ma);\n\t\t\t\tV[i].PB(MP(cnt,ma));\n\t\t\t\tREP(j,4){\n\t\t\t\t\tint nx=x+dx[j],ny=y+dy[j];\n\t\t\t\t\tif(pos(nx,ny,w[i],h[i])&&!used[i][nx][ny]){\n\t\t\t\t\t\tQ.push((dat){nx,ny,fld[i][nx][ny]});\n\t\t\t\t\t\tused[i][nx][ny]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i,2)sort(ALL(V[i]));\n\t\tint ans=INF;\n\t\tREP(i,V[0].size()){\n\t\t\tint cnt=V[0][i].first,level=V[0][i].second;\n\t\t\tif(cnt>=r){\n\t\t\t\tans=min(ans,level);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(cnt+V[1].size()<r){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans=min(ans,V[1][r-cnt].second+level);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n\n#define MAX 512\nusing namespace std;\n\ntypedef pair<int,int> pi;\ntypedef pair< int, pi > lvq;\n\nstruct lvloc{\n  int lv;\n  vector< pi > locs;\n  bool operator<(const lvloc &t)const{\n    return lv > t.lv;\n  }\n};\n\nconst int di[] = {-1,0,1,0};\nconst int dj[] = {0,1,0,-1};\n\nstruct Office{\n  int W,H;\n  int X,Y;\n  int M[MAX][MAX];\n  vector< pi > AuthenticationLevel;\n\n  Office():W(0),H(0),X(0),Y(0){}\n  Office(int W, int H, int X, int Y):W(W),H(H),X(X-1),Y(Y-1){}\n\n  bool isinside(pi p)const{ return 0<=p.first&&p.first<H&&0<=p.second&&p.second<W; }\n\n  void CheckSecurity(){\n    priority_queue< lvloc > nextQ;\n    bool vis[MAX][MAX] = {{false,},};\n    lvloc init;\n    init.lv = 1; init.locs.push_back( pi(Y,X) );\n    nextQ.push( init );\n\n    \n    while(!nextQ.empty()){\n      lvloc nlv = nextQ.top();\n      int newcnt = 0;\n      nextQ.pop();\n\n      queue<lvq> Q;\n      for(int i = 0; i < nlv.locs.size(); ++i){\n\t++newcnt;\n\tQ.push( lvq( nlv.lv, nlv.locs[i] ) );\n\tvis[ nlv.locs[i].first ][ nlv.locs[i].second ] = true;\n\t//visT[nlv.locs[i].first ][ nlv.locs[i].second ] = true;\n      }\n      int level;\n      map< int, vector<pi> > T;\n\n      while(!Q.empty()){\n\tlvq now = Q.front();\n\tQ.pop();\n\tlevel = now.first;\n\tpi pos = now.second;\n\n\t//cout << \" NOW : \" << level << \" POS : \" << pos.first << ' ' << pos.second << endl;\n\n\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t  pi nxpos = pi( pos.first + di[k], pos.second + dj[k] );\n\t  if( isinside( nxpos ) ){\n\t    if( M[ nxpos.first ][ nxpos.second ] <= level ){\n\t      if( !vis[ nxpos.first ][ nxpos.second ] ){\n\t\t//cout << \" level : \" << level << \" pos : \" << pos.first << ' ' << pos.second << \" can reach \" << nxpos.first << ' ' << nxpos.second << endl;\n\t\tvis[ nxpos.first ][ nxpos.second ] = true;\n\t\t++newcnt;\n\t\tQ.push( lvq( level, nxpos ) );\n\t      }\n\t    }else{\n\t      if( !vis[nxpos.first][nxpos.second ] ){\n\t\t//cout << \" level : \" << level << \" can NOT reach \" << nxpos.first << ' ' << nxpos.second << endl;\n\t\tvis[nxpos.first][nxpos.second]=true;\n\t\tT[ M[ nxpos.first ][ nxpos.second ] ].push_back( nxpos );\n\t      }\n\t    }\n\t  }\n\t}\n      }\n\n      AuthenticationLevel.push_back( pi( level, newcnt ) );\n      \n\n      for(map<int,vector<pi> >::iterator itm = T.begin();\n\t  itm != T.end(); ++itm ){\n\tlvloc nextlvloc;\n\tnextlvloc.lv = itm->first;\n\tnextlvloc.locs = itm->second;\n\tnextQ.push( nextlvloc );\n      }\n\n    }    \n  }\n};\n\nint main()\n{\n  while(true){\n    int R;\n    scanf(\"%d\", &R);\n    if( R == 0 ) break;\n    static Office office[2];\n    for(int x = 0; x < 2; ++x){\n      int W,H,X,Y;\n      scanf(\"%d%d%d%d\", &W, &H, &X, &Y);\n      office[x] = Office(W,H,X,Y);\n      for(int i = 0; i < H; ++i){\n\tfor(int j = 0; j < W; ++j){\n\t  scanf(\"%d\" , &office[x].M[i][j] );\n\t}\n      }\n      office[x].CheckSecurity();\n      /*\n      cout << \"Authentication levels : Office \" << 1+x << endl;\n      for(int i = 0; i < office[x].AuthenticationLevel.size(); ++i){\n\tcout << \"Level : \" << office[x].AuthenticationLevel[i].first << \" -> \" << \n\t  office[x].AuthenticationLevel[i].second << endl;\n      }\n      */\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for (int i=0;i<(int)n;++i)\n\nint dx[] ={0,1,0,-1};\nint dy[] = {1,0,-1,0};\nstruct P {\n  int d;\n  int x,y;\n  P(int d,int x,int y):d(d),x(x),y(y){}\n};\nbool operator<(const P &a, const P &b) {\n  return a.d > b.d;\n}\nint main() {\n  int r;\n  while(cin >> r, r) {\n    int w[2],h[2],sx[2],sy[2];\n    int ba[2][500][500];\n    rep(k,2) {\n      cin >> w[k]>>h[k]>>sx[k]>>sy[k];\n      sx[k]--;sy[k]--;\n      rep(y,h[k])\n        rep(x, w[k])\n        cin >> ba[k][x][y];\n    }\n    int table[2][250001];\n    rep(k,2) {\n      priority_queue<P> Q;\n      Q.push(P(1, sx[k], sy[k]));\n      bool visited[w[k]][h[k]];\n      memset(visited,0,sizeof(visited));\n      int nowd = 0;\n      int cnt = 0;\n      while(!Q.empty()) {\n        P p = Q.top();\n        int x = p.x;\n        int y = p.y;\n        Q.pop();\n        if (visited[x][y]) continue;\n        nowd = max(nowd, p.d);\n        table[k][++cnt] = nowd;\n        if(cnt>=r) break;\n        //      printf(\"%d,%d -> %d\\n\",k,cnt,nowd);\n        visited[x][y] = 1;\n        rep(i,4) {\n          int xx = x+dx[i];\n          int yy = y+dy[i];\n\n          if (xx<0||xx>=w[k]||yy<0||yy>=h[k]) continue;\n          if (visited[xx][yy]) continue;\n          Q.push(P(ba[k][xx][yy], xx, yy));\n        }\n      }\n    }\n    int res = 1<<29;\n    for (int i=0; i<=r; ++i) {\n      if (i>w[0]*h[0] || r-i>w[1]*h[1]) continue;\n      //  printf(\"%d->%d %d->%d\\n\", i,table[0][i], r-i,table[1][r-i]);\n      res = min(res, table[0][i]+table[1][r-i]);\n    }\n    cout << res << endl;\n  \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n \n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n \n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n \n \nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n \nint dx[] = {-1,0,1,0};\nint dy[] = {0,-1,0,1};\n \nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n \n  int R;\n  cin >> R;\n \n  map<int,int> num[2];\n  REP(k,2){\n\tint W, H, sx, sy;\n\tcin >> W >> H >> sx >> sy;\n\t--sx;\n\t--sy;\n\tVVI lv(H, VI(W));\n\tREP(y,H) REP(x,W) cin >> lv[y][x];\n \n\tusing P = pair<int,PII>;\n\tpriority_queue<P,vector<P>,greater<P>> pq;\n\tvector<vector<bool>> vis(H, vector<bool>(W));\n\tpq.push(MP(1, MP(sx, sy)));\n\tvis[sy][sx] = true;\n \n\tint acc = 0;\n\tint cur = 0;\n\tnum[k][0] = 0;\n\twhile(!pq.empty()){\n\t  cur = pq.top().FF;\n\t  while(!pq.empty() && pq.top().FF <= cur){\n\t\tauto p = pq.top();\n\t\tpq.pop();\n\t\t++acc;\n\t\tREP(d,4){\n\t\t  int tx = p.SS.FF + dx[d];\n\t\t  int ty = p.SS.SS + dy[d];\n\t\t  if(tx < 0 || W <= tx || ty < 0 || H <= ty || vis[ty][tx]) continue;\n\t\t  vis[ty][tx] = true;\n\t\t  pq.push(MP(lv[ty][tx], MP(tx, ty)));\n\t\t}\n\t  }\n\t  num[k][acc] = cur;\n\t}\n  }\n  /*\n  for(auto&p:num[0]) cout << p << endl;\n  cout<<\"===\"<<endl;\n  for(auto&p:num[1]) cout << p << endl;\n  */\n  int ans = 1e9;\n  for(auto& p: num[0]){\n\tauto it = num[1].lower_bound(R - p.FF);\n\tif(it == end(num[1])) continue;\n\t\n\tmini(ans, p.SS + it->SS);\n  }\n  cout << ans << endl;\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int,pair<int,int> > pp;\nconst int dx[] = {-1,0,1,0};\nconst int dy[] = {0,-1,0,1};\nint level[2][100001];\nint room[500][500];\nbool visited[500][500];\n\nint main(){\n    int r;\n    while(cin>>r,r){\n        int w,h,ex,ey;\n        int e[2];\n        for(int i=0;i<2;++i){\n            cin>>w>>h>>ex>>ey;\n            for(int j=0;j<h;++j){\n                for(int k=0;k<w;++k){\n                    cin>>room[j][k];\n                }\n            }\n            memset(visited,0,sizeof(visited));\n            visited[--ey][--ex]=1;\n            level[i][0]=0;\n            int mlevel=0,index=1;\n            priority_queue<pp,vector<pp>,greater<pp> > pq;\n            pq.push(make_pair(room[ey][ex],make_pair(ex,ey)));\n            while(!pq.empty()){\n                pp cur=pq.top();pq.pop();\n                mlevel=max(mlevel,cur.first);\n                level[i][index++]=mlevel;\n                for(int j=0;j<4;++j){\n                    int cx=cur.second.first+dx[j];\n                    int cy=cur.second.second+dy[j];\n                    if(cx>=0&&cx<w&&cy>=0&&cy<h&&visited[cy][cx]==0){\n                        visited[cy][cx]=1;\n                        pq.push(make_pair(room[cy][cx],make_pair(cx,cy)));\n                    }\n                }\n            }\n            e[i]=index-1;\n        }\n        int ans = 1000000000;\n        for(int i=0;i<=r;++i){\n            if(e[0]<r-i||e[1]<i) continue;\n            ans=min(ans,level[1][i]+level[0][r-i]);\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n \n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n \nconst int INF = 1 << 30;\nconst int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};\n \ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n \nint R, W[2], H[2], X[2], Y[2];\nint Room[2][500][500];\nstd::vector<int> L[2]; // 事務所ごとの存在するレベル\nint maxR[2][250001]; // maxR[i][j]: 事務所iでj番目に小さいレベルで行ける部屋の数\nint used[500][500];\n \nvoid travel(int r){\n    REP(j, H[r]){\n        REP(k, W[r]){\n            used[j][k] = 0;\n        }\n    }\n     \n    std::priority_queue<State, std::vector<State>, std::greater<State>> q;\n    q.push(mp(1, mp(X[r], Y[r])));\n \n    while(!q.empty()){\n        State s = q.top(); q.pop();\n        int l = s.first;\n        P p = s.second;\n        int x = p.first, y = p.second;\n \n        //std::cout << x << \",\" << y << \",\" << l << std::endl;\n \n        if(used[y][x]){continue;}\n        else{used[y][x] = 1;}\n\n        maxR[r][std::lower_bound(L[r].begin(), L[r].end(), l) - L[r].begin()]++;\n\n        REP(i, 4){\n            int nx = x + dx[i], ny = y + dy[i];\n            if(0 <= nx && nx < W[r] && 0 <= ny && ny < H[r] && !used[ny][nx]){\n \n                int nl = std::max(l, Room[r][ny][nx]);\n \n                q.push(mp(nl, mp(nx, ny)));\n            }\n        }\n    }\n}\n \nint main(){\n    while(std::cin >> R, R){\n        REP(i, 2){\n            std::cin >> W[i] >> H[i] >> X[i] >> Y[i];\n            X[i]--; Y[i]--;\n \n            L[i].clear();\n            L[i].push_back(0);\n            REP(j, H[i]){\n                REP(k, W[i]){\n                    std::cin >> Room[i][j][k];\n                    L[i].push_back(Room[i][j][k]);\n                }\n            }\n \n            std::sort(L[i].begin(), L[i].end());\n            L[i].erase(std::unique(L[i].begin(), L[i].end()), L[i].end());\n        }\n \n        REP(i, 2){\n            REP(j, L[i].size()){\n                maxR[i][j] = 0;\n            }\n        }\n \n        REP(i, 2){\n            travel(i);\n        }\n \n        REP(i, 2){\n            //std::cout << maxR[i][0] << std::endl;\n            FOR(j, 1, L[i].size()){\n                maxR[i][j] += maxR[i][j-1];\n                // std::cout << maxR[i][j] << std::endl;\n            }\n            // puts(\"##############################\");\n        }\n \n        int res = INF;\n        REP(i, L[0].size()){\n            int r1 = maxR[0][i],\n                r2_index = std::lower_bound(maxR[1], maxR[1]+L[1].size(), R-r1) - maxR[1];\n         \n            if(r2_index == L[1].size()){\n                continue;\n            }\n \n            res = std::min(res, L[0][i] + L[1][r2_index]);\n        }\n \n        std::cout << res << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef pair<int,int> P;\nint R;\nint W1,H1,X1,Y1;\nint W2,H2,X2,Y2;\nint L1[501][501];\nint L2[501][501];\nint AA[250010];\nint BB[250010];\nint num11[250010];\nint num22[250010];\nbool field1[501][501];\nbool field2[501][501];\nvector<P>XX1;vector<P>XX2;\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nint solve1(int x,int y,int num){\n\tbool FF=true;\n\tfor(int k=0;k<4;k++){\n\t\tif(x+dx[k]<0)continue;\n\t\tif(x+dx[k]>=W1)continue;\n\t\tif(y+dy[k]<0)continue;\n\t\tif(y+dy[k]>=H1)continue;\n\t\tif(field1[y+dy[k]][x+dx[k]])FF=false;\n\t}\n\tif(FF)return 0;\n\tint res=0;\n\tqueue<P>que;\n\tque.push(P(y,x));\n\twhile(!que.empty()){\n\t\tP p=que.front();que.pop();\n\t\tint pf=p.first;int ps=p.second;\n\t\tif(field1[pf][ps])continue;\n\t\tfield1[pf][ps]=true;res++;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tif(ps+dx[k]<0)continue;\n\t\t\tif(ps+dx[k]>=W1)continue;\n\t\t\tif(pf+dy[k]<0)continue;\n\t\t\tif(pf+dy[k]>=H1)continue;\n\t\t\tif(L1[pf+dy[k]][ps+dx[k]]>num)continue;\n\t\t\tif(!field1[pf+dy[k]][ps+dx[k]])que.push(P(pf+dy[k],ps+dx[k]));\n\t\t}\n\t}\n\treturn res;\n}\nint solve2(int x,int y,int num){\n\tbool FF=true;\n\tfor(int k=0;k<4;k++){\n\t\tif(x+dx[k]<0)continue;\n\t\tif(x+dx[k]>=W2)continue;\n\t\tif(y+dy[k]<0)continue;\n\t\tif(y+dy[k]>=H2)continue;\n\t\tif(field2[y+dy[k]][x+dx[k]])FF=false;\n\t}\n\tif(FF)return 0;\n\tint res=0;\n\tqueue<P>que;\n\tque.push(P(y,x));\n\twhile(!que.empty()){\n\t\tP p=que.front();que.pop();\n\t\tint pf=p.first;int ps=p.second;\n\t\tif(field2[pf][ps])continue;\n\t\tfield2[pf][ps]=true;res++;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tif(ps+dx[k]<0)continue;\n\t\t\tif(ps+dx[k]>=W2)continue;\n\t\t\tif(pf+dy[k]<0)continue;\n\t\t\tif(pf+dy[k]>=H2)continue;\n\t\t\tif(L2[pf+dy[k]][ps+dx[k]]>num)continue;\n\t\t\tif(!field2[pf+dy[k]][ps+dx[k]])que.push(P(pf+dy[k],ps+dx[k]));\n\t\t}\n\t}\n\treturn res;\n}\nint main()\n{\n\twhile(true){\n\t\tXX1.clear();XX2.clear();\n\t\tscanf(\"%d\",&R);\n\t\tif(R==0)break;\n\t\tscanf(\"%d%d%d%d\",&W1,&H1,&X1,&Y1);\n\t\tfor(int i=0;i<H1;i++){\n\t\t\tfor(int j=0;j<W1;j++){\n\t\t\t\tscanf(\"%d\",&L1[i][j]);\n\t\t\t\tXX1.push_back(P(L1[i][j],i*W1+j));\n\t\t\t}\n\t\t}\n\t\tsort(XX1.begin(),XX1.end());\n\t\tfor(int i=0;i<H1;i++){\n\t\t\tfor(int j=0;j<W1;j++){\n\t\t\t\tfield1[i][j]=false;\n\t\t\t}\n\t\t}\n\t\tfield1[Y1-1][X1-1]=true;\n\t\tnum11[1]=1;\n\t\tfor(int i=2;i<=XX1.size();i++){\n\t\t\tnum11[i]=num11[i-1];\n\t\t\tnum11[i]+=solve1(XX1[i-1].second%W1,XX1[i-1].second/W1,XX1[i-1].first);\n\t\t}\n\t\tfor(int i=XX1.size();i>=2;i--){\n\t\t\tif(XX1[i-1].first==XX1[i-2].first){\n\t\t\t\tnum11[i-1]=num11[i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<XX1.size();i++){\n\t\t\t//printf(\"%d:%d\\n\",XX1[i].first,num11[i+1]);\n\t\t}\n\t\tscanf(\"%d%d%d%d\",&W2,&H2,&X2,&Y2);\n\t\tfor(int i=0;i<H2;i++){\n\t\t\tfor(int j=0;j<W2;j++){\n\t\t\t\tscanf(\"%d\",&L2[i][j]);\n\t\t\t\tXX2.push_back(P(L2[i][j],i*W2+j));\n\t\t\t}\n\t\t}\n\t\tsort(XX2.begin(),XX2.end());\n\t\tfor(int i=0;i<H2;i++){\n\t\t\tfor(int j=0;j<W2;j++){\n\t\t\t\tfield2[i][j]=false;\n\t\t\t}\n\t\t}\n\t\tfield2[Y2-1][X2-1]=true;\n\t\tnum22[1]=1;\n\t\tfor(int i=2;i<=XX2.size();i++){\n\t\t\tnum22[i]=num22[i-1];\n\t\t\tnum22[i]+=solve2(XX2[i-1].second%W2,XX2[i-1].second/W2,XX2[i-1].first);\n\t\t}\n\t\tfor(int i=XX2.size();i>=2;i--){\n\t\t\tif(XX2[i-1].first==XX2[i-2].first){\n\t\t\t\tnum22[i-1]=num22[i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<XX2.size();i++){\n\t\t\t//printf(\"%d:%d\\n\",XX2[i].first,num22[i+1]);\n\t\t}\n\t\tint ans=1000000000;\n\t\tfor(int i=0;i<=H1*W1;i++){\n\t\t\tint RRR=R-num11[i];\n\t\t\tint l=0;int r=H2*W2+1;\n\t\t\twhile(r-l>1){\n\t\t\t\tint c=(l+r)/2;\n\t\t\t\tif(num22[c]<RRR)l=c;\n\t\t\t\telse r=c;\n\t\t\t}\n\t\t\tl-=H1;\n\t\t\tif(l<0)l=0;\n\t\t\twhile(l<=H2*W2&&num11[i]+num22[l]<R)l++;\n\t\t\tif(num11[i]+num22[l]<R)continue;\n\t\t\t//printf(\"%d %d\\n\",num11[i],num22[l]);\n\t\t\tint I=i-1;l--;\n\t\t\tif(I==-1)ans=min(ans,XX2[l].first);\n\t\t\telse if(l==-1)ans=min(ans,XX1[I].first);\n\t\t\telse ans=min(ans,XX1[I].first+XX2[l].first);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\ntypedef pair< int, int > Pi;\ntypedef pair< int, Pi > Pii;\nconst int INF = 1 << 29;\nconst int dy[] = {0, 1, 0, -1}, dx[] = {1, 0, -1, 0};\n   \nstruct Field\n{\n  int W, H, X, Y;\n  int L[500][500];\n};\n   \nvoid InputField(Field& e)\n{\n  cin >> e.W >> e.H >> e.X >> e.Y;\n  --e.X, --e.Y;\n  for(int i = 0; i < e.H; i++) {\n    for(int j = 0; j < e.W; j++) {\n      cin >> e.L[i][j];\n    }\n  }\n}\nint BFSField(const Field& e, vector< int >& cost)\n{\n  priority_queue< Pii, vector< Pii >, greater< Pii > > que;\n  que.push({1, make_pair(e.X, e.Y)});\n  int min_cost[500][500];\n  fill_n(*min_cost, 500 * 500, INF);\n  min_cost[e.X][e.Y] = 1;\n  unordered_map< int, int > cur;\n  while(!que.empty()) {\n    Pi point = que.top().second;\n    int c = que.top().first;\n    que.pop();\n    if(c > min_cost[point.first][point.second]) continue;\n    cur[c]++;\n    for(int i = 0; i < 4; i++) {\n      int ny = point.second + dy[i], nx = point.first + dx[i];\n      if(ny < 0 || nx < 0 || ny >= e.H || nx >= e.W) continue;\n      if(min_cost[nx][ny] > max(c, e.L[ny][nx])) {\n        min_cost[nx][ny] = max(c, e.L[ny][nx]);\n        que.push({min_cost[nx][ny], Pi(nx, ny)});\n      }\n    }\n  }\n  cost.assign(e.W * e.H + 1, INF);\n  int sum = 0;\n  cost[0] = 0;\n  for(auto e : cur) {\n    sum += e.second;\n    cost[sum] = e.first;\n  }\n  for(int i = cost.size() - 2; i >= 0; i--) {\n    cost[i] = min(cost[i + 1], cost[i]);\n  }\n}\n   \nint main()\n{\n  int R;\n  Field A, B;\n   \n  while(cin >> R, R) {\n    InputField(A);\n    InputField(B);\n    vector< int > a, b;\n    BFSField(A, a);\n    BFSField(B, b);\n     \n    int ret = INF;\n    for(int i = 0; i < a.size(); i++) {\n      if(R - i >= 0 && R - i < b.size()) {\n        ret = min(ret, a[i] + b[R - i]);\n      }\n    }\n     \n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pint;\ntypedef pair<ll, int> P;\n//typedef tuple<int,int,int> T;\nll INFL = 1000000000000000010;//10^18 = 2^60\nint INF = 2147483600;//10^9\nll MOD  = 1000000007;\nint solve(){\n    vector<int> dy = {0,0,1,-1};\n    vector<int> dx = {1,-1,0,0};\n    int R;\n    cin >> R;\n    if(R == 0)return 0;\n    int H1,W1,X1,Y1;\n    cin >> W1 >> H1 >> X1 >> Y1;\n    X1--;\n    Y1--;\n    vector<vector<ll>> mp1(H1, vector<ll>(W1));\n    vector<vector<ll>> d1(H1, vector<ll>(W1, INFL));\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            cin >> mp1[i][j];\n        }\n    }\n    \n    d1[Y1][X1] = 1;\n    priority_queue<pair<ll, pair<int, int>>> pque1;\n    pque1.push({1, {Y1, X1}});\n    \n    while(!pque1.empty()){\n        ll c;\n        int y,x;\n        c = pque1.top().first;\n        y = pque1.top().second.first;\n        x = pque1.top().second.second;\n        pque1.pop();\n        if(c > d1[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H1 && 0 <= nx && nx < W1){\n                if(d1[ny][nx] > d1[y][x]){\n                    if(d1[y][x] > mp1[ny][nx]){\n                        d1[ny][nx] = d1[y][x];\n                    }else{\n                        d1[ny][nx] = mp1[ny][nx];\n                    }\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }else if(d1[ny][nx] > d1[y][x]){\n                    d1[ny][nx] = mp1[ny][nx];\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    int H2,W2,X2,Y2;\n    cin >> W2 >> H2 >> X2 >> Y2;\n    X2--;\n    Y2--;\n    vector<vector<ll>> mp2(H2, vector<ll>(W2));\n    vector<vector<ll>> d2(H2, vector<ll>(W2, INFL));\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            cin >> mp2[i][j];\n        }\n    }\n    \n    d2[Y2][X2] = 1;\n    priority_queue<pair<ll, pair<int, int>>> pque2;\n    pque2.push({1, {Y2, X2}});\n    \n    while(!pque2.empty()){\n        ll c;\n        int y,x;\n        c = pque2.top().first;\n        y = pque2.top().second.first;\n        x = pque2.top().second.second;\n        pque2.pop();\n        if(c > d2[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H2 && 0 <= nx && nx < W2){\n                if(d2[ny][nx] > d2[y][x]){\n                    if(d2[y][x] > mp2[ny][nx]){\n                        d2[ny][nx] = d2[y][x];\n                    }else{\n                        d2[ny][nx] = mp2[ny][nx];\n                    }\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }else if(d2[ny][nx] > d2[y][x]){\n                    d2[ny][nx] = mp2[ny][nx];\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    vector<pair<ll,int>> O1(0);\n    vector<ll> COST1(0);\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            COST1.push_back(d1[i][j]);\n        }\n    }\n    sort(COST1.begin(), COST1.end());\n    COST1.push_back(INFL);\n    ll ad1 = COST1.at(0);\n    int cnt = 0;\n    for(int i = 0; i < COST1.size(); i++){\n        if(ad1 == COST1.at(i)){\n            cnt++;\n        }else{\n            O1.push_back({ad1, cnt});\n            ad1 = COST1.at(i);\n            cnt++;\n        }\n    }\n    \n    vector<pair<ll,int>> O2 = {pair{0, 0}};\n    vector<ll> COST2(0);\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            COST2.push_back(d2[i][j]);\n        }\n    }\n    sort(COST2.begin(), COST2.end());\n    COST2.push_back(INFL);\n    ll ad2 = COST2.at(0);\n    cnt = 0;\n    for(int i = 0; i < COST2.size(); i++){\n        if(ad2 == COST2.at(i)){\n            cnt++;\n        }else{\n            O2.push_back({ad2, cnt});\n            ad2 = COST2.at(i);\n            cnt++;\n        }\n    }\n    \n    ll ans = INFL;\n    for(int i = 0; i < O1.size(); i++){\n        ll cost = O1.at(i).first;\n        int rest = R - O1.at(i).second;\n        \n        if(rest > O2.at(O2.size()-1).second) continue;\n        int left = -1, right = O2.size();\n        int mid;\n        while(right - left > 1){\n            mid = (left + right) / 2;\n            if(O2.at(mid).second >= rest){\n                right = mid;\n            }else{\n                left = mid;\n            }\n        }\n        cost += O2.at(right).first;\n        ans = min(ans, cost);\n        \n    }\n    \n    cout << ans << endl;\n    \n    solve();\n    return 0;\n}\n\nint main(void){\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define all(a) a.begin(),a.end()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\n\nconst int inf = 1e9;\n\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, -1, 0, 1};\n\nint R;\nint W[2], H[2];\nint X[2], Y[2];\nint A[2][502][502];\n\nbool used[502][502];\n\nvpii data[2];\n\nvoid bfs(int num)\n{\n\ttypedef pair<int, pii> Data;\n\tmemset(used, false, sizeof(used));\n\n\tpriority_queue<Data> q;\n\n\tq.push(Data(-1, pii(Y[num], X[num])));\n\tused[Y[num]][X[num]] = true;\n\n\tif (num == 0) {\n\t\tdata[num].PB(pii(1, 0));\n\t} else {\n\t\tdata[num].PB(pii(0, 0));\n\t\tdata[num].PB(pii(0, 1));\n\t}\n\n\tint ma = 1;\n\tint cnt = 0;\n\n\twhile (q.size()) {\n\t\tData p = q.top(); q.pop();\n\n\t\tint cur = -p.fst;\n\n\t\tif (ma < cur) {\n\t\t\tif (num == 0) {\n\t\t\t\tdata[num].back().scd = cnt;\n\t\t\t\tma = cur;\n\t\t\t\tdata[num].PB(pii(ma, 0));\n\t\t\t} else {\n\t\t\t\tdata[num].back().fst = cnt;\n\t\t\t\tma = cur;\n\t\t\t\tdata[num].PB(pii(0, ma));\n\t\t\t}\n\t\t}\n\n\t\tcnt++;\n\n\t\trep(i, 4) {\n\t\t\tint ny = p.scd.fst + dy[i], nx = p.scd.scd + dx[i];\n\n\t\t\tif (ny < 0 || ny >= H[num] || nx < 0 || nx >= W[num] || used[ny][nx]) continue;\n\t\t\tused[ny][nx] = true;\n\n\t\t\tq.push(Data(-A[num][ny][nx], pii(ny, nx)));\n\t\t}\n\t}\n\n\tif (num == 0) {\n\t\tdata[num].back().scd = cnt;\n\t} else {\n\t\tdata[num].back().fst = cnt;\n\t}\n}\n\nsigned main()\n{\n\tomajinai;\n\n\twhile (cin >> R, R) {\n\t\tdata[0].clear();\n\t\tdata[1].clear();\n\n\t\trep(i, 2) {\n\t\t\tcin >> W[i] >> H[i] >> X[i] >> Y[i];\n\n\t\t\t--X[i], --Y[i];\n\n\t\t\trep(j, H[i]) rep(k, W[i]) {\n\t\t\t\tcin >> A[i][j][k];\n\t\t\t}\n\t\t}\n\n\t\tbfs(0);\n\t\tbfs(1);\n\n\t\tint mi = inf;\n\n\t\tdata[1].PB(pii(inf, inf));\n\n\t\trep(i, data[0].size()) {\n\t\t\tpii a = data[0][i];\n\n\t\t\tchmin(mi, a.fst + lower_bound(all(data[1]), pii(R - a.scd, -inf))->scd);\n\t\t}\n\n\t\tcout << mi << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\n\nconst int INF=1000000000;\nconst long long int INF_=1000000000000000000;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nbool IsIn(int y,int x,int h,int w){\n\treturn 0<=y&&y<h&&0<=x&&x<w;\n}\n\nvoid BFS(vector<vector<int> > &f,vector<vector<int> > &l,int sy,int sx,int h,int w){\n\tvector<vector<int> > done(h,vector<int>(w));\n\tvector<vector<int> > done_(h,vector<int>(w));\n\tl[sy][sx]=1;\n\tdone[sy][sx]=done_[sy][sx]=1;\n\tqueue<Pi> que;\n\tREP(i,0,4){\n\t\tint ny=sy+dy[i],nx=sx+dx[i];\n\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\tdone_[ny][nx]=1;\n\t\tque.push(Pi(ny,nx));\n\t}\n\twhile(!que.empty()){\n\t\tPi p=que.front();\n\t\tque.pop();\n\t\tdone[p.F_][p.S_]=1;\n\t\tbool flag=true;\n\t\tint tmp=INF;\n\t\tREP(i,0,4){\n\t\t\tint ny=p.F_+dy[i],nx=p.S_+dx[i];\n\t\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\t\tif(done[ny][nx]==1) tmp=min(tmp,l[ny][nx]);\n\t\t\t//if(p.S_==2&&p.F_==1) cout << l[ny][nx] << endl;\n\t\t\tif(done[ny][nx]==1&&l[ny][nx]>=f[p.F_][p.S_]) flag=false;\n\t\t\tif(done_[ny][nx]!=1){\n\t\t\t\tdone_[ny][nx]=1;\n\t\t\t\tque.push(Pi(ny,nx));\n\t\t\t}\n\t\t}\n\t\t//if(p.S_==2&&p.F_==1) cout << tmp << endl << endl;\n\t\tif(flag) l[p.F_][p.S_]=f[p.F_][p.S_];\n\t\telse {\n\t\t\tif(tmp!=INF) l[p.F_][p.S_]=max(tmp,f[p.F_][p.S_]);\n\t\t\telse l[p.F_][p.S_]=f[p.F_][p.S_];\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tint R;\n\twhile(cin >> R&&R){\n\t\tint W[2],H[2],X[2],Y[2];\n\t\tvector<vector<int> > field[2];\n\t\tvector<vector<int> > level[2];\n\t\tint _max=0;\n\t\tREP(i,0,2){\n\t\t\tcin >> W[i] >> H[i] >> X[i] >> Y[i];\n\t\t\t--X[i]; --Y[i];\n\t\t\tfield[i].resize(H[i]);\n\t\t\tlevel[i].resize(H[i]);\n\t\t\tREP(j,0,H[i]){\n\t\t\t\tfield[i][j].resize(W[i]);\n\t\t\t\tlevel[i][j].resize(W[i]);\n\t\t\t}\n\t\t\tREP(y,0,H[i]) REP(x,0,W[i]){\n\t\t\t\tcin >> field[i][y][x];\n\t\t\t\t_max=max(_max,field[i][y][x]);\n\t\t\t}\n\t\t\tBFS(field[i],level[i],Y[i],X[i],H[i],W[i]);\n\n\t\t\t/*\n\t\t\tcout << endl << endl;\n\t\t\tREP(y,0,H[i]){\n\t\t\t\tREP(x,0,W[i]) cout << level[i][y][x] << ' ';\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\tvector<int> count[2],s[2];\n\t\tREP(i,0,2){\n\t\t\tcount[i].resize(_max+1);\n\t\t\ts[i].resize(_max+1);\n\t\t}\n\t\tREP(i,0,2) REP(y,0,H[i]) REP(x,0,W[i]) ++count[i][level[i][y][x]];\n\t\tREP(i,0,2) REP(j,1,_max+1) s[i][j]=s[i][j-1]+count[i][j];\n\t\tint result=INF;\n\t\tfor(int i=0; i<=_max&&i<=result; ++i){\n\t\t\t//cout << i << ' ' << s[0][i] << ' ' <<  (int)(lower_bound(s[1].begin(),s[1].end(),R-s[0][i])-s[1].begin()) << ' ' << s[1][(int)(lower_bound(s[1].begin(),s[1].end(),R-s[0][i])-s[1].begin())] << endl;\n\t\t\tint idx=(int)(lower_bound(s[1].begin(),s[1].end(),R-s[0][i])-s[1].begin());\n\t\t\tif(!(0<=idx&&idx<=_max)) continue;\n\t\t\tresult=min(result,i+idx);\n\t\t}\n\t\tcout << result << endl;\n\t}\n}\n\nint main(){\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\nconst int N = 500;\nconst int INF = 1000000000;\n\nclass S{\npublic:\n  int x, y, cost;\n  S(){}\n  S(int x, int y, int cost) : x(x), y(y), cost(cost) {}\n  bool operator < (const S& s) const {\n    return cost > s.cost;\n  }\n};\n\nint R, w[2], h[2], sx[2], sy[2], input[2][N][N], vis[N][N];\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nvector<int> vec[2];\nset<int> used;\nvector<int> data;\nint cnt;\n\nvoid dfs(int x, int y, int cost, int d){\n  vis[y][x] = true;\n  cnt++;\n  for(int i=0;i<4;i++){\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if(ny < 0 || ny >= h[d]) continue;\n    if(nx < 0 || nx >= w[d]) continue;\n    if(input[d][ny][nx] > cost) continue;\n    if(!vis[ny][nx]) dfs(nx, ny, cost, d);\n  }\n}\n\nvoid bfs(int d){\n  int x = sx[d];\n  int y = sy[d];\n  int cost = 1;\n  priority_queue<S> q;\n  S u;\n  q.push(S(x, y, cost));\n  vis[y][x] = cost;\n  while(!q.empty()){\n    u = q.top(); q.pop();\n    if(vis[u.y][u.x] < u.cost) continue;\n    for(int i=0;i<4;i++){\n      int ny = u.y + dy[i];\n      int nx = u.x + dx[i];\n      if(ny < 0 || ny >= h[d]) continue;\n      if(nx < 0 || nx >= w[d]) continue;\n      int tmp = max(u.cost, input[d][ny][nx]);\n      if(vis[ny][nx] > tmp){\n        vis[ny][nx] = tmp;\n        q.push(S(nx, ny, tmp));\n      }\n    }\n  }\n}\n\nvoid init(){\n  used.clear();\n  data.clear();\n  for(int k=0;k<2;k++){\n    for(int i=0;i<h[k];i++){\n      for(int j=0;j<w[k];j++){\n        if(!used.count(input[k][i][j])){\n          used.insert(input[k][i][j]);\n          data.push_back(input[k][i][j]);\n        }\n      }\n    }\n  }\n  sort(data.begin(), data.end());\n  for(int k=0;k<2;k++){\n    /*int vis2[N][N];\n    fill(vis2[0], vis2[N], INF);\n    set<int>::iterator ite = data.begin();\n    for(;ite!=data.end();ite++){\n      fill(vis[0], vis[N], false);\n      dfs(sx[k], sy[k], *ite, k);      \n      for(int i=0;i<h[k];i++){\n        for(int j=0;j<w[k];j++){\n          if(vis[i][j]) vis2[i][j] = min(vis2[i][j], *ite);\n        }\n      }\n      }*/\n    fill(vis[0], vis[N], INF);\n    bfs(k);\n\n    vec[k].clear();\n    for(int i=0;i<h[k];i++){\n      for(int j=0;j<w[k];j++){\n        //vec[k].push_back(vis2[i][j]);\n        vec[k].push_back(vis[i][j]);\n      }\n    }\n    sort(vec[k].begin(), vec[k].end());\n  }\n}\n\nbool check(int a, int b){\n  int t1 = distance(vec[0].begin(), upper_bound(vec[0].begin(), vec[0].end(), a));\n  int t2 = distance(vec[1].begin(), upper_bound(vec[1].begin(), vec[1].end(), b));\n  return t1 + t2 >= R;\n  /*int sum = 0;\n  for(int i=0;i<2;i++){\n    fill(vis[0], vis[N], false);\n    cnt = 0;\n    int cost = a;\n    if(i == 1) cost = b;\n    if(cost > 0) dfs(sx[i], sy[i], cost, i);\n    sum += cnt;\n  }\n  return sum >= R;*/\n}\n\nint solve(){\n  //set<int>::iterator ite = data.end();\n  //int l = 0, r = *(--ite) + 1;\n  int l = 0, r = data[data.size()-1] + 1;\n  while(l<r){\n    int m = (l + r) / 2;\n    bool f = false;\n    //for(ite=data.begin();ite!=data.end();ite++){\n    for(int i=0;i<data.size();i++){\n      //if(*ite > m) break;\n      if(data[i] > m) break;\n      //if(check(*ite, m-(*ite))) f = true;\n      if(check(data[i], m-data[i])) f = true;\n    }\n    if(f) r = m;\n    else l = m + 1;\n  }\n  return l;\n}\n\nmain(){\n  //while(cin >> R && R){\n  while(scanf(\"%d\", &R) && R){\n    for(int k=0;k<2;k++){\n      scanf(\"%d %d %d %d\", w+k, h+k, sx+k, sy+k);\n      //cin >> w[k] >> h[k] >> sx[k] >> sy[k];\n      sx[k]--; sy[k]--;\n      for(int i=0;i<h[k];i++){\n        for(int j=0;j<w[k];j++){\n          //cin >> input[k][i][j];\n          scanf(\"%d\", &input[k][i][j]);\n        }\n      }\n    }\n    init();\n    //cout << solve() << endl;\n    printf(\"%d\\n\", solve());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\n\nint x[2],y[2],w[2],h[2];\nint R;\nvector<vvi> zimu;\n\nvoid dfs(int i, int x, int y, vvi& used, vector<pair<int,int>>& list){\n\n  priority_queue< pair<int,pii>, vector<pair<int,pii> >,greater<pair<int,pii> > > que;\n  que.push(pair<int,pii>(1,pii(x,y)));\n  used[y][x] = 1;\n\n  int auth = 1;\n  int room = 0;\n  while(que.size()){\n    int corr_lev = que.top().first;\n    int corr_x = que.top().second.first;\n    int corr_y = que.top().second.second;\n    //cout << corr_x << \" \" << corr_y << \" \" << corr_lev << endl;\n    que.pop();\n    used[corr_y][corr_x] = 1;\n\n    if(corr_lev > auth){\n      list.push_back(pii(room,auth));\n      auth = corr_lev;\n    }\n    room++;\n    if(room == w[i]*h[i]) break;\n\n    for(int j=0; j<4; j++){\n      int nx = corr_x + dx[j];\n      int ny = corr_y + dy[j];\n      if(nx >= w[i] || nx < 0 || ny >= h[i] || ny < 0) continue; // ????£?\n      if(used[ny][nx] == 1) continue; // ??¢?´¢??????\n      que.push( pair<int,pii>(zimu[i][ny][nx],pii(nx,ny)) );\n    }\n  }\n  list.push_back(pii(room,auth));\n}\n\nint main(){\n  while(1){\n  \n    cin >> R; if(!R) break;\n    zimu.clear();\n    \n    // ??\\???\n    for(int i=0; i<2; i++){\n      cin >> w[i] >> h[i] >> x[i] >> y[i];\n  \n      zimu.push_back(vvi(h[i],vi(w[i])));\n\n      for(int j=0; j<h[i]; j++)\n\tfor(int k=0; k<w[i]; k++)\n\t  cin >> zimu[i][j][k];\n    }\n\n    // \n    vector<vector<pair<int,int> > > list(2); // ???????????¨?±???°???????¨???¬??????\n    \n    for(int i=0; i<2; i++){\n      list[i].push_back(pii(0,0));\n      int lev=1;\n      int mini=1e+9;\n      vvi used(h[i],vi(w[i],0));\n      dfs(i, x[i]-1, y[i]-1, used, list[i]);\n    }\n    /*\n    for(int i=0; i<2; i++){\n      for(int j=0; j<list[i].size(); j++)\n\tcout << \"(\" << list[i][j].first << \",\" << list[i][j].second << \"), \";\n      cout << endl;\n    }\n    */\n\n    int ans = 1e+9;\n    for(int i=0; i<list[0].size(); i++){\n      int rooma = list[0][i].first;\n      int autha = list[0][i].second;\n      pii tmp = *lower_bound(list[1].begin(),list[1].end(), pii(R-rooma,0));\n      int roomb = tmp.first;\n      int authb = tmp.second;\n      if(rooma + roomb < R) continue;\n      ans = min(ans,autha + authb);\n    }\n    cout << ans << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> iP;\n#define pb push_back\n#define fi first\n#define sc second\n#define MAX_H 514\nint R;\nint W[2],H[2],X[2],Y[2];\nint L[2][MAX_H][MAX_H];\nbool F[2][MAX_H][MAX_H];\nvector<iP>data[2];\nint need[2][MAX_H*MAX_H];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nint main()\n{\n\tscanf(\"%d\",&R);\n\tfor(int i=0;i<2;i++){\n\t\tscanf(\"%d%d%d%d\",&W[i],&H[i],&X[i],&Y[i]);X[i]--;Y[i]--;\n\t\tfor(int j=0;j<H[i];j++){\n\t\t\tfor(int k=0;k<W[i];k++){\n\t\t\t\tscanf(\"%d\",&L[i][j][k]);\n\t\t\t\tif(j==Y[i]&&k==X[i]){continue;}\n\t\t\t\tdata[i].pb(iP(L[i][j][k],P(j,k)));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tsort(data[i].begin(),data[i].end());\n\t\tfor(int j=0;j<=W[i]*H[i];j++){\n\t\t\tneed[i][j]=(1<<30)-1;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tF[i][Y[i]][X[i]]=true;\n\t\tneed[i][0]=0;\n\t\tint cou=1;need[i][1]=1;\n\t\tfor(int j=0;j<(int)data[i].size();j++){\n\t\t\tint x=data[i][j].sc.fi;\n\t\t\tint y=data[i][j].sc.sc;\n\t\t\tbool flag=false;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tif(x+dx[k]<0||x+dx[k]>=H[i]||y+dy[k]<0||y+dy[k]>=W[i]){continue;}\n\t\t\t\tif(F[i][x+dx[k]][y+dy[k]])flag=true;\n\t\t\t}\n\t\t\tif(!flag){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tqueue<P>que;\n\t\t\tque.push(P(x,y));\n\t\t\twhile(!que.empty()){\n\t\t\t\tP p=que.front();que.pop();\n\t\t\t\tif(F[i][p.fi][p.sc])continue;\n\t\t\t\tF[i][p.fi][p.sc]=true;\n\t\t\t\t//printf(\"%d %d\\n\",p.fi,p.sc);\n\t\t\t\tcou++;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(p.fi+dx[k]<0||p.fi+dx[k]>=H[i]||p.sc+dy[k]<0||p.sc+dy[k]>=W[i]){continue;}\n\t\t\t\t\tif(F[i][p.fi+dx[k]][p.sc+dy[k]]){continue;}\n\t\t\t\t\tif(L[i][p.fi+dx[k]][p.sc+dy[k]]<=data[i][j].fi){\n\t\t\t\t\t\tque.push(P(p.fi+dx[k],p.sc+dy[k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tneed[i][cou]=L[i][x][y];\n\t\t\t//printf(\"%d:%d %d\\n\",cou,x,y);\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<2;i++){\n\t\tfor(int j=0;j<=W[i]*H[i];j++){\n\t\t\tprintf(\"need[%d][%d]=%d\\n\",i,j,need[i][j]);\n\t\t}\n\t}\n\t*/\n\tint ans=100000000;\n\tfor(int i=0;i<=W[0]*H[0];i++){\n\t\tint k=R-i;\n\t\tif(k>W[1]*H[1]){\n\t\t\tcontinue;\n\t\t}\n\t\tans=min(need[0][i]+need[1][k],ans);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n\nvector<int> search(vector<vector<int>> const& flr, int sx, int sy, int const R) {\n    const int H = flr.size();\n    const int W = flr[0].size();\n    vector<int> res = {0};\n    vector<vector<bool>> visited(H, vector<bool>(W));\n    visited[sy][sx] = true;\n    priority_queue<P, vector<P>, greater<P>> que;\n    que.push(make_pair(flr[sy][sx], sy*W+sx));\n    while(!que.empty() && res.size() <= R) {\n        P p = que.top();\n        int y = p.second / W, x = p.second % W;\n        que.pop();\n        res.push_back(max(res.back(), p.first));\n        int dx[4] = {0, 1, 0, -1},\n            dy[4] = {1, 0, -1, 0};\n        for(int i=0; i<4; ++i) {\n            int ny = y + dy[i], nx = x + dx[i];\n            if(ny < 0 || H <= ny || nx < 0 || W <= nx || visited[ny][nx]) {\n                continue;\n            }\n            visited[ny][nx] = true;\n            que.push(make_pair(flr[ny][nx], ny*W+nx));\n        }\n    }\n    return res;\n}\n\nint main() {\n    int R;\n    while(cin >> R, R) {\n        int W, H, sx, sy;\n        cin >> W >> H >> sx >> sy;\n        sx--; sy--;\n        vector<vector<int>> flr1(H, vector<int>(W));\n        for(int i=0; i<H; ++i) {\n            for(int j=0; j<W; ++j) {\n                cin >> flr1[i][j];\n            }\n        }\n        auto f1 = search(flr1, sx, sy, R);\n        cin >> W >> H >> sx >> sy;\n        sx--; sy--;\n        vector<vector<int>> flr2(H, vector<int>(W));\n        for(int i=0; i<H; ++i) {\n            for(int j=0; j<W; ++j) {\n                cin >> flr2[i][j];\n            }\n        }\n        auto f2 = search(flr2, sx, sy, R);\n\n        int res = 1e9;\n        for(int i=0; i<f1.size(); ++i) {\n            int t = f1[i];\n            if(R - i >= f2.size()) {\n                continue;\n            }\n            t += f2[R-i];\n            res = min(res, t);\n        }\n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <complex>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define FORE(i,a,b) for(int i=(a);i<=(b);i++)\n#define REP(i,a) FOR(i,0,a)\n#define SQR(a) ((a)*(a))\n#define X first\n#define Y second\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> pr;\ntypedef pair<pr,ll> ppr;\ntypedef vector<pr> vpr;\ntypedef pair<int,int> ci;\ntypedef pair<int,ci> pci;\ntypedef priority_queue<pci,vector<pci>,greater<pci> > pq;\nconst int INF=1<<30;\nbool finished[502][502];\nint level[502][502];\nci dc[4]={ci(1,0),ci(0,1),ci(-1,0),ci(0,-1)};\nint main() {\n\tint R;\n\twhile(cin >> R && R){\n\tvpr ables[2];\n\tREP(l,2){\n\t\tint W,H,sx,sy,mlevel=0,sum=0;\n\t\tcin >> W  >>H >>sx >> sy;\n\t\tFORE(i,1,H)\n\t\t\tFORE(j,1,W)\n\t\t\t\tscanf(\"%d\",&level[i][j]);\n\t\tFORE(i,0,H+1)\n\t\t\tFORE(j,0,W+1)\n\t\t\t\tif(i&&j&&i<=H&&j<=W)\n\t\t\t\t\tfinished[i][j]=false;\n\t\t\t\telse\n\t\t\t\t\tfinished[i][j]=true;\n\t\tfinished[sy][sx]=false;\n\t\tlevel[sy][sx]=INF;\n\t\tpq dungeon;\n\t\tdungeon.push(pci(1,ci(sx,sy)));\n\t\twhile(!dungeon.empty()){\n\t\t\tci point=dungeon.top().second;\n\t\t\tint nowlevel=dungeon.top().first;\n\t\t\tdungeon.pop();\n\t\t\tif(mlevel<nowlevel){\n\t\t\t\tables[l].push_back(pr(sum,mlevel));\n\t\t\t\tmlevel=nowlevel;\n\t\t\t}\n\t\t\tsum++;\n\t\t\tREP(i,4){\n\t\t\t\tci d=dc[i];\n\t\t\t\tif(!finished[point.Y+d.Y][point.X+d.X]){\n\t\t\t\t\tfinished[point.Y+d.Y][point.X+d.X]=true;\n\t\t\t\t\tdungeon.push(pci(level[point.Y+d.Y][point.X+d.X],ci(point.X+d.X,point.Y+d.Y)));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tint e=ables[1].size()-1,minium=INF;\n\tREP(i,ables[0].size()){\n\t\twhile(e && ables[0][i].first+ables[1][e-1].first>=R) e--;\n\t\tif(ables[0][i].first+ables[1][e].first>=R)\n\t\t\tminium=min(minium,ables[0][i].second+ables[1][e].second);\n\t}\n\tcout << minium << endl;\n\t}\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<functional>\n#include<vector>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\n#define T1 1000000LL\n#define T2 1000LL\n\nlong long W,H,X,Y,R;\nlong long x[1000][1000];\nlong long d[1000][1000];\nlong long p1,p2,p3;\nlong long y_1[1000000],y_2[1000000],cnt,cnt2,v,minx;\n\npriority_queue<long long,vector<long long>,greater<long long>> Q;\n\nint main(){\n\twhile(true){\n\t\tcnt=1;cnt2=1;minx=1145141919810LL;\n\t\tmemset(x,51,sizeof(x));\n\t\tmemset(d,51,sizeof(d));\n\t\tcin>>R;\n\t\tif(R==0){break;}\n\t\tcin>>W>>H>>X>>Y;\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tfor(int j=1;j<=W;j++){\n\t\t\t\tcin>>x[i][j];\n\t\t\t}\n\t\t}\n\t\td[Y][X]=0;\n\t\tQ.push(Y*T2+X);\n\t\twhile(!Q.empty()){\n\t\t\tp1=Q.top()/T1;\n\t\t\tp2=(Q.top()/T2)%T2;\n\t\t\tp3=Q.top()%T2;\n\t\t\tif(max(p1,x[p2-1][p3])<d[p2-1][p3]){\n\t\t\t\td[p2-1][p3]=max(p1,x[p2-1][p3]);\n\t\t\t\tQ.push(d[p2-1][p3]*T1+(p2-1)*T2+p3);\n\t\t\t}\n\t\t\tif(max(p1,x[p2+1][p3])<d[p2+1][p3]){\n\t\t\t\td[p2+1][p3]=max(p1,x[p2+1][p3]);\n\t\t\t\tQ.push(d[p2+1][p3]*T1+(p2+1)*T2+p3);\n\t\t\t}\n\t\t\tif(max(p1,x[p2][p3-1])<d[p2][p3-1]){\n\t\t\t\td[p2][p3-1]=max(p1,x[p2][p3-1]);\n\t\t\t\tQ.push(d[p2][p3-1]*T1+p2*T2+(p3-1));\n\t\t\t}\n\t\t\tif(max(p1,x[p2][p3+1])<d[p2][p3+1]){\n\t\t\t\td[p2][p3+1]=max(p1,x[p2][p3+1]);\n\t\t\t\tQ.push(d[p2][p3+1]*T1+p2*T2+(p3+1));\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tfor(int j=1;j<=W;j++){\n\t\t\t\ty_1[cnt]=d[i][j];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tmemset(x,51,sizeof(x));\n\t\tmemset(d,51,sizeof(d));\n\t\tcin>>W>>H>>X>>Y;\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tfor(int j=1;j<=W;j++){\n\t\t\t\tcin>>x[i][j];\n\t\t\t}\n\t\t}\n\t\td[Y][X]=0;\n\t\tQ.push(Y*T2+X);\n\t\twhile(!Q.empty()){\n\t\t\tp1=Q.top()/T1;\n\t\t\tp2=(Q.top()/T2)%T2;\n\t\t\tp3=Q.top()%T2;\n\t\t\tif(max(p1,x[p2-1][p3])<d[p2-1][p3]){\n\t\t\t\td[p2-1][p3]=max(p1,x[p2-1][p3]);\n\t\t\t\tQ.push(d[p2-1][p3]*T1+(p2-1)*T2+p3);\n\t\t\t}\n\t\t\tif(max(p1,x[p2+1][p3])<d[p2+1][p3]){\n\t\t\t\td[p2+1][p3]=max(p1,x[p2+1][p3]);\n\t\t\t\tQ.push(d[p2+1][p3]*T1+(p2+1)*T2+p3);\n\t\t\t}\n\t\t\tif(max(p1,x[p2][p3-1])<d[p2][p3-1]){\n\t\t\t\td[p2][p3-1]=max(p1,x[p2][p3-1]);\n\t\t\t\tQ.push(d[p2][p3-1]*T1+p2*T2+(p3-1));\n\t\t\t}\n\t\t\tif(max(p1,x[p2][p3+1])<d[p2][p3+1]){\n\t\t\t\td[p2][p3+1]=max(p1,x[p2][p3+1]);\n\t\t\t\tQ.push(d[p2][p3+1]*T1+p2*T2+(p3+1));\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tfor(int j=1;j<=W;j++){\n\t\t\t\ty_2[cnt2]=d[i][j];\n\t\t\t\tcnt2++;\n\t\t\t}\n\t\t}\n\n\t\tsort(y_1,y_1+cnt);\n\t\tsort(y_2,y_2+cnt2);\n\n\t\tfor(int i=0;i<cnt;i++){\n\t\t\tv=R-i;\n\t\t\tif(v>=0 && v<cnt2){\n\t\t\t\tminx=min(minx,y_1[i]+y_2[v]);\n\t\t\t}\n\t\t}\n\t\tcout<<minx<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pint;\ntypedef pair<ll, int> P;\n//typedef tuple<int,int,int> T;\nll INFL = 1000000000000000010;//10^18 = 2^60\nint INF = 2147483600;//10^9\nll MOD  = 1000000007;\nvector<int> dy = {0,0,1,-1};\nvector<int> dx = {1,-1,0,0};\nint solve(){\n    int R;\n    cin >> R;\n    if(R == 0)return 0;\n    int H1,W1,X1,Y1;\n    cin >> W1 >> H1 >> X1 >> Y1;\n    X1--;\n    Y1--;\n    vector<vector<ll>> mp1(H1, vector<ll>(W1));\n    vector<vector<ll>> d1(H1, vector<ll>(W1, INFL));\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            cin >> mp1[i][j];\n        }\n    }\n    \n    d1[Y1][X1] = 1;\n    priority_queue<pair<ll, pair<int, int>>> pque1;\n    pque1.push({1, {Y1, X1}});\n    \n    while(!pque1.empty()){\n        ll c;\n        int y,x;\n        c = pque1.top().first;\n        y = pque1.top().second.first;\n        x = pque1.top().second.second;\n        pque1.pop();\n        if(c > d1[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H1 && 0 <= nx && nx < W1){\n                if(d1[ny][nx] > d1[y][x]){\n                    if(d1[y][x] > mp1[ny][nx]){\n                        d1[ny][nx] = d1[y][x];\n                    }else{\n                        d1[ny][nx] = mp1[ny][nx];\n                    }\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }else if(d1[ny][nx] > d1[y][x]){\n                    d1[ny][nx] = mp1[ny][nx];\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    int H2,W2,X2,Y2;\n    cin >> W2 >> H2 >> X2 >> Y2;\n    X2--;\n    Y2--;\n    vector<vector<ll>> mp2(H2, vector<ll>(W2));\n    vector<vector<ll>> d2(H2, vector<ll>(W2, INFL));\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            cin >> mp2[i][j];\n        }\n    }\n    \n    d2[Y2][X2] = 1;\n    priority_queue<pair<ll, pair<int, int>>> pque2;\n    pque2.push({1, {Y2, X2}});\n    \n    while(!pque2.empty()){\n        ll c;\n        int y,x;\n        c = pque2.top().first;\n        y = pque2.top().second.first;\n        x = pque2.top().second.second;\n        pque2.pop();\n        if(c > d2[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H2 && 0 <= nx && nx < W2){\n                if(d2[ny][nx] > d2[y][x]){\n                    if(d2[y][x] > mp2[ny][nx]){\n                        d2[ny][nx] = d2[y][x];\n                    }else{\n                        d2[ny][nx] = mp2[ny][nx];\n                    }\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }else if(d2[ny][nx] > d2[y][x]){\n                    d2[ny][nx] = mp2[ny][nx];\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    vector<pair<ll,int>> O1(0);\n    vector<ll> COST1(0);\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            COST1.push_back(d1[i][j]);\n        }\n    }\n    sort(COST1.begin(), COST1.end());\n    COST1.push_back(INFL);\n    ll ad1 = COST1.at(0);\n    int cnt = 0;\n    for(int i = 0; i < COST1.size(); i++){\n        if(ad1 == COST1.at(i)){\n            cnt++;\n        }else{\n            O1.push_back({ad1, cnt});\n            ad1 = COST1.at(i);\n            cnt++;\n        }\n    }\n    \n    vector<pair<ll,int>> O2 = {{0, 0}};\n    vector<ll> COST2(0);\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            COST2.push_back(d2[i][j]);\n        }\n    }\n    sort(COST2.begin(), COST2.end());\n    COST2.push_back(INFL);\n    ll ad2 = COST2.at(0);\n    cnt = 0;\n    for(int i = 0; i < COST2.size(); i++){\n        if(ad2 == COST2.at(i)){\n            cnt++;\n        }else{\n            O2.push_back({ad2, cnt});\n            ad2 = COST2.at(i);\n            cnt++;\n        }\n    }\n    \n    ll ans = INFL;\n    for(int i = 0; i < O1.size(); i++){\n        ll cost = O1.at(i).first;\n        int rest = R - O1.at(i).second;\n        \n        if(rest > O2.at(O2.size()-1).second) continue;\n        int left = -1, right = O2.size();\n        int mid;\n        while(right - left > 1){\n            mid = (left + right) / 2;\n            if(O2.at(mid).second >= rest){\n                right = mid;\n            }else{\n                left = mid;\n            }\n        }\n        cost += O2.at(right).first;\n        ans = min(ans, cost);\n        \n    }\n    \n    cout << ans << endl;\n    \n    solve();\n    return 0;\n}\n\nint main(void){\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define X first\n#define Y second\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\ntypedef pair<int, int> P;\ntypedef pair<int, P> Elm;\n\nconst int WMAX = 500, HMAX = 500;\nconst int LMAX = 100000000;\nconst int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\n\nint office[WMAX][HMAX], level[WMAX][HMAX];\n\nvoid dijkstra(int w, int h, int sx, int sy) {\n  REP(y, h) {\n    REP(x, w) {\n      level[x][y] = LMAX;\n    }\n  }\n  priority_queue<Elm, vector<Elm>, greater<Elm> > que;\n  que.push( Elm(1, P(sx, sy)) );\n  level[sx][sy] = 1;\n\n  while (!que.empty()) {\n    int lev = que.top().first; P p = que.top().second;\n    que.pop();\n\n    if (level[p.X][p.Y] < lev) continue;\n\n    REP(i, 4) {\n      int x = p.X + dx[i], y = p.Y + dy[i];\n      if (x < 0 or w <= x or y < 0 or h <= y) continue;\n      \n      int newlevel = max(office[x][y], lev);\n      if (newlevel < level[x][y]) {\n        level[x][y] = newlevel;\n        que.push(Elm(newlevel, P(x, y)));\n      }\n    }\n  }\n}\n\nvector<int> count_level(int w, int h) {\n  vector<int> v;\n  v.push_back(0);\n  REP(y, h) {\n    REP(x, w) {\n      v.push_back(level[x][y]);\n    }\n  }\n  sort(v.begin(), v.end());\n  return v;\n}\n\nvector<int> make_level_table() {\n  int w, h, sx, sy;\n  cin >> w >> h >> sx >> sy;\n  REP(y, h) {\n    REP(x, w) {\n      cin >> office[x][y];\n    }\n  }\n  dijkstra(w, h, sx - 1, sy - 1);\n  return count_level(w, h);\n}\n\nint search(int key, \n    vector<int>::iterator begin, vector<int>::iterator end) {\n  if (key == 0) return 0;\n  pair<vector<int>::iterator, vector<int>::iterator> eqr = \n    equal_range(begin, end, key);\n  return eqr.second - eqr.first;\n}\n\nint main() {\n  int r, w, h, sx, sy;\n  while (cin >> r and r) {\n    vector<int> ltab1 = make_level_table();\n    vector<int> ltab2 = make_level_table();\n\n    vector<int>::iterator lev1 = ltab1.end() - 1, \n      lev2 = ltab2.begin();\n    int rooms = ltab1.size() - 1;\n    int ans = 2 * LMAX + 1;\n\n    while (lev1 != ltab1.begin()) {\n      while (rooms < r and lev2 != ltab2.end()) {\n        lev2 = upper_bound(lev2, ltab2.end(), *lev2);\n        rooms += search(*lev2, lev2, ltab2.end());\n      }\n      \n      if (rooms < r or lev2 == ltab2.end()) break;\n      ans = min(ans, *lev1 + *lev2);\n      \n      rooms -= search(*lev1, ltab1.begin(), lev1 + 1);\n      lev1 = lower_bound(ltab1.begin(), lev1, *lev1) - 1;\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<string>\n#include<queue>\n#include<climits>\nusing namespace std;\n\nint vx[4]={0,1,0,-1};\nint vy[4]={1,0,-1,0};\n\nstruct pos{\n  pos(){};\n  pos(int cost,int kpos,int xpos,int ypos){\n    c=cost;\n    k=kpos;\n    x=xpos;\n    y=ypos;\n  }\n  int c,k,x,y;\n};\n\nbool operator<(pos a,pos b){\n  return a.c>b.c;\n}\n\nint r;\npair<int,int> el[2];\nvector< vector<int> > map[2];\nvector< vector<int> > used[2];\nvoid init(){\n  map[0].clear();\n  map[1].clear();\n  used[0].clear();\n  used[1].clear();\n}\n\nint input(){\n  cin>>r;\n  if(r==0)return 0;\n  int x,y;\n  cin>>x>>y;\n  cin>>el[0].second;\n  cin>>el[0].first;\n  el[0].first--;\n  el[0].second--;\n  map[0].resize(y);\n  used[0].resize(y);\n  for(int i=0;i<y;i++){\n    used[0][i].resize(x);\n    for(int j=0;j<x;j++){\n      int tmp;\n      cin>>tmp;\n      map[0][i].push_back(tmp);\n    }\n  }\n  cin>>x>>y;\n  cin>>el[1].second;\n  cin>>el[1].first;\n  el[1].first--;\n  el[1].second--;\n  map[1].resize(y);\n  used[1].resize(y);\n  for(int i=0;i<y;i++){\n    used[1][i].resize(x);\n    for(int j=0;j<x;j++){\n      int tmp;\n      cin>>tmp;\n      map[1][i].push_back(tmp);\n    }\n  }\n  return r;\n\n}\n\nint solve(){\n  \n  priority_queue<pos> q;\n  q.push(pos(map[0][el[0].first][el[0].second] , 0 , el[0].first , el[0].second));\n\n  vector< pair<int,int> > cost_room[2];\n  pair<int,int> tmp_c[2];\n\n  tmp_c[0].first =0;\n  tmp_c[0].second=0;\n\n  while((!q.empty())){\n    pos tmp=q.top();q.pop();\n    if(used[tmp.k][tmp.x][tmp.y])continue; \n    if(tmp_c[tmp.k].first<tmp.c){\n      cost_room[tmp.k].push_back(tmp_c[tmp.k]);\n      tmp_c[tmp.k].second++;\n      tmp_c[tmp.k].first=tmp.c;\n    }else if(tmp_c[tmp.k].first>=tmp.c && tmp.c!=0){\n      tmp_c[tmp.k].second++;\n    }\n\n    used[tmp.k][tmp.x][tmp.y]=true;\n    for(int i=0;i<4;i++){\n      if((!(tmp.x+vx[i]<0||used[tmp.k].size()-1<tmp.x+vx[i]))\n          &&(!(tmp.y+vy[i]<0||used[tmp.k][tmp.x+vx[i]].size()-1<tmp.y+vy[i]))\n          &&(!used[tmp.k][tmp.x+vx[i]][tmp.y+vy[i]])){\n        q.push(pos( map[tmp.k][tmp.x+vx[i]][tmp.y+vy[i]], tmp.k, tmp.x+vx[i],tmp.y+vy[i]));\n      }\n    }\n  }\n  cost_room[0].push_back(tmp_c[0]);\n  \n  q.push(pos(map[1][el[1].first][el[1].second] , 1 , el[1].first , el[1].second));\n  tmp_c[1].first =0;\n  tmp_c[1].second=0;\n  while((!q.empty())){\n    pos tmp=q.top();q.pop();\n    if(used[tmp.k][tmp.x][tmp.y])continue; \n    if(tmp_c[tmp.k].first<tmp.c){\n      cost_room[tmp.k].push_back(tmp_c[tmp.k]);\n      tmp_c[tmp.k].second++;\n      tmp_c[tmp.k].first=tmp.c;\n    }else if(tmp_c[tmp.k].first>=tmp.c && tmp.c!=0){\n      tmp_c[tmp.k].second++;\n    }\n\n    used[tmp.k][tmp.x][tmp.y]=true;\n    for(int i=0;i<4;i++){\n      if((!(tmp.x+vx[i]<0||used[tmp.k].size()-1<tmp.x+vx[i]))\n          &&(!(tmp.y+vy[i]<0||used[tmp.k][tmp.x+vx[i]].size()-1<tmp.y+vy[i]))\n          &&(!used[tmp.k][tmp.x+vx[i]][tmp.y+vy[i]])){\n        q.push(pos( map[tmp.k][tmp.x+vx[i]][tmp.y+vy[i]], tmp.k, tmp.x+vx[i],tmp.y+vy[i]));\n      }\n    }\n  }\n  cost_room[1].push_back(tmp_c[1]);\n\n  \n  \n\n  int res=INT_MAX;\n  for(int i=0;i<cost_room[0].size();i++){\n    for(int j=0;j<cost_room[1].size();j++){\n      if( cost_room[0][i].second+cost_room[1][j].second>=r){\n        res=min(cost_room[0][i].first+cost_room[1][j].first,res);\n      }\n    }\n  }\n  return res;\n}\n\n\n\nint main(){\n  while(init(),input()){\n    cout<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int INF = 1001001001;\n\nint r, x[2], y[2];\nint grid[2][502][502];\nbool done[2][502][502];\n\nstruct P\n{\n\tint g, x, y;\n\t\n\tbool operator < (const P& t) const {\n\t\treturn grid[g][x][y] > grid[g][t.x][t.y];\n\t}\n};\n\nint search(int g, int num)\n{\n\tfor (int i = 0; i < 502; i++){\n\t\tfor (int j = 0; j < 502; j++){\n\t\t\tdone[g][i][j] = false;\n\t\t}\n\t}\n\t\n\tint level = 0;\n\tint mini = INF;\n\tpriority_queue<P> que;\n\tque.push({g, x[g], y[g]});\n\twhile (!que.empty()){\n\t\tP p = que.top(); que.pop();\n\t\tif (done[g][p.x][p.y]) continue;\n\t\tdone[g][p.x][p.y] = true;\n\t\t\n\t\t//printf(\"%d %d %d\\n\", g, p.x, p.y);\n\t\t\n\t\tif (grid[g][p.x][p.y] <= level){\n\t\t\tnum++;\n\t\t\tif (num >= r) return level;\n\t\t}\n\t\telse {\n\t\t\tif (g == 0){\n\t\t\t\tmini = min(mini, level + search(1, num));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (num >= r){\n\t\t\t\t\treturn level;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (grid[g][p.x][p.y] == INF) break;\n\t\t\tlevel = grid[g][p.x][p.y];\n\t\t\tnum++;\n\t\t}\n\t\t\n\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\tint tx = p.x + dx[dir];\n\t\t\tint ty = p.y + dy[dir];\n\t\t\tif (!done[g][tx][ty]){\n\t\t\t\tque.push({g, tx, ty});\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn mini;\n}\n\nint main()\n{\n\twhile (scanf(\"%d\", &r), r){\n\t\tfor (int i = 0; i < 2; i++){\n\t\t\tfor (int j = 0; j < 502; j++){\n\t\t\t\tfor (int k = 0; k < 502; k++){\n\t\t\t\t\tgrid[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint h, w;\n\t\t\tscanf(\"%d %d %d %d\", &w, &h, &y[i], &x[i]);\n\t\t\tfor (int j = 1; j <= h; j++){\n\t\t\t\tfor (int k = 1; k <= w; k++){\n\t\t\t\t\tscanf(\"%d\", &grid[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", search(0, 0));\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <iterator>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <cmath>\n#include <complex>\n#include <functional>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <cstdlib>\n#include <cctype>\n\n#define REP(i,m,n) for(int i=m;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rp(i,c) rep(i,(int)c.size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define v_delete(a,b) (a).erase(remove((a).begin(), (a).end(), b), (a).end())\n#define v_unique(a) (a).erase(unique((a).begin(), (a).end()), (a).end())\n#define VV(T) vector<vector< T > >\n#define init(a,b) memset((a), (b), sizeof((a)))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double EPS=1e-9;\nconst long long INF = 100001000010000100ll;\n\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntypedef pair<int,int> pii;\n\nint R;\nint W[2], H[2], X[2], Y[2];\n\nint m[4][500+10][500+10];\nint visited[2][500+10][500+10];\n\nint memo[2][500+10][500+10];\n\nint wa[2][500*500*10];\n\nvi ls;\n\nmap<int ,int> cnt[2];\n\nbool exists(const map<int ,int> &mapp, int key){\n\treturn mapp.find(key) != mapp.end();\n}\n\nint dx[]={1,0,0,-1};\nint dy[]={0,1,-1,0};\n\nclass BIT{\nprivate:\n\tvi bit;\n\tint n;\npublic:\n\tBIT(int _n){\n\t\tn = _n;\n\t\tbit.assign(n+1,0 );\n\t}\n\tvoid add(int i, int x){\n\t\twhile(i <= n){\n\t\t\tbit[i] += x;\n\t\t\ti += (i & -i);\n\t\t}\n\t}\n\tint sum(int i){\n\t\tint s = 0;\n\t\twhile(i > 0){\n\t\t\ts += bit[i];\n\t\t\ti -= (i & -i);\n\t\t}\n\t\treturn s;\n\t}\n};\n\n\nint rec(int c, int x, int y){\n\tint ans;\n\tfflush(stdout);\n\tif(memo[c][x][y]!=-1){\n\t\tcout << \"returned\" << endl;\n\t\treturn memo[c][x][y];\n\t}\n\tif(x == X[c] && y == Y[c])\n\t\tcout << \"returned\" << endl;\n\t\treturn memo[c][x][y] = 1;\n\tif(m[c][y][x] == inf)\n\t\tcout << \"returned\" << endl;\n\t\treturn memo[c][x][y] = inf;\n\n\tint tmp=inf;\n\trep(k, 4){\n\t\ttmp=min(tmp, rec(c, x + dx[k], y + dy[k]));\n\t}\n\n\tm[c][y][x] = max(m[c][y][x], ans);\n\n\tcout << \"returned\" << endl;\n\treturn memo[c][x][y] = m[c][y][x];\n}\n\n\nint main(){\n\twhile(cin >> R, R){\n\t\tmemset(memo, -1, sizeof(memo));\n\n\t\tmemset(visited, 0, sizeof(visited));\n\n\t\tmemset(wa, 0, sizeof(wa));\n\n\t\tls.clear();\n\n\t\tfill_n(**m, 4 * (500+10) * (500+10), inf);\n\n\t\trep(c, 2){\n\t\t\tcin >> W[c] >> H[c] >> X[c] >> Y[c];\n\t\t\trep(i, H[c]){\n\t\t\t\trep(j, W[c]){\n\t\t\t\t\tcin >> m[c][i+1][j+1];\n\t\t\t\t\tm[c+2][i+1][j+1]=m[c][i+1][j+1];\n\t\t\t\t\tls.pb(m[c][i+1][j+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tls.pb(0);\n\t\tls.pb(inf);\n\t\tsort(all(ls));\n\t\tls.erase(unique(all(ls)), ls.end());\n\t\trep(c, 2){\n\t\t\tpriority_queue<pair<int, pii>, vector<pair<int, pii> >, greater<pair<int, pii> > >Q;\n\t\t\tQ.push(mp(1, mp(X[c], Y[c])));\n\t\t\twhile(!Q.empty()){\n\t\t\t\tint x,y,level;\n\t\t\t\tx=Q.top().second.first;y=Q.top().second.second;level=Q.top().first;\n\t\t\t\tQ.pop();\n\t\t\t\trep(k, 4){\n\t\t\t\t\tif(m[c][x+dx[k]][y+dy[k]]!=inf){\n\t\t\t\t\t\tif(!visited[c][x+dx[k]][y+dy[k]]){\n\t\t\t\t\t\t\tvisited[c][x+dx[k]][y+dy[k]] = 1;\n\t\t\t\t\t\t\tm[c][x+dx[k]][y+dy[k]]=max(m[c][x+dx[k]][y+dy[k]], level);\n\t\t\t\t\t\t\tQ.push(mp(m[c][x+dx[k]][y+dy[k]], mp(x+dx[k], y+dy[k])));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\trep(c, 2){\n\t\t\trep(i, H[c]){\n\t\t\t\trep(j, W[c]){\n\t\t\t\t\tint ma=-1;\n\t\t\t\t\tint tmp=inf;\n\t\t\t\t\t/*\n\t\t\t\t\trep(k, 4){\n\t\t\t\t\t\ttmp=min(tmp, m[c][i + 1 + dx[k]][j + 1 + dy[k]]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i + 1 == Y[c] && j + 1 == X[c]){\n\t\t\t\t\t\tma=m[c][i + 1][j + 1];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tma = max(m[c][i + 1][j + 1], tmp);\n\t\t\t\t\t}*/\n\t\t\t\t\tma=m[c][i + 1][j + 1];\n\t\t\t\t\tint l = lower_bound(all(ls), ma) - ls.begin();\n\t\t\t\t\twa[c][l]++;\n\n\t\t\t\t}\n\t\t\t}\n\t\t\trp(i, ls){\n\t\t\t\tif(i - 1 >= 0)\n\t\t\t\t\twa[c][i] = wa[c][i - 1] + wa[c][i];\n\t\t\t}\n\n\t\t}\n\t\t/*\n\t\trep(c, 2){\n\t\t\trp(i, ls){\n\t\t\t\tcout << ls[i] << \" \" << wa[c][i] << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\tcout << endl;\n\t\t}*/\n\t\tint ans=inf;\n\t\trp(i, ls){\n\n\t\t\tint l=lower_bound(wa[1],(wa[1]+(int)ls.size()) , R - wa[0][i]) - wa[1];\n\t\t\tif(l < ls.size())\n\t\t\tif(wa[0][i] + wa[1][l] >= R){\n\t\t\t\t//cout << ls[i] << \" \" << ls[l] << endl;\n\t\t\t\tans=min(ans, ls[i] + ls[l]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<string>\n#include<queue>\n#include<climits>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\n\nint vx[4]={0,1,0,-1};\nint vy[4]={1,0,-1,0};\n\nstruct pos{\n  pos(){};\n  pos(int cost,int kpos,int xpos,int ypos){\n    c=cost;\n    k=kpos;\n    x=xpos;\n    y=ypos;\n  }\n  int c,k,x,y;\n};\n\nbool operator<(const pos &a,const pos &b){\n  return a.c>b.c;\n}\n\nint r;\npair<int,int> el[2];\nvector< vector<int> > map[2];\nvector< vector<int> > used[2];\nvoid init(){\n  map[0].clear();\n  map[1].clear();\n  used[0].clear();\n  used[1].clear();\n}\n\nint input(){\n  cin>>r;\n  if(r==0)return 0;\n  int x,y;\n  cin>>x>>y;\n  cin>>el[0].second;\n  cin>>el[0].first;\n  el[0].first--;\n  el[0].second--;\n  map[0].resize(y);\n  used[0].resize(y);\n  for(int i=0;i<y;i++){\n    used[0][i].resize(x);\n    for(int j=0;j<x;j++){\n      int tmp;\n      cin>>tmp;\n      map[0][i].push_back(tmp);\n    }\n  }\n  cin>>x>>y;\n  cin>>el[1].second;\n  cin>>el[1].first;\n  el[1].first--;\n  el[1].second--;\n  map[1].resize(y);\n  used[1].resize(y);\n  for(int i=0;i<y;i++){\n    used[1][i].resize(x);\n    for(int j=0;j<x;j++){\n      int tmp;\n      cin>>tmp;\n      map[1][i].push_back(tmp);\n    }\n  }\n  return r;\n\n}\nvector< pair<int,int> > cost_room[2];\n\nbool pair_sec_comp(pair<int,int> a,pair<int,int> b){\n  if(a.second!=b.second){\n    return a.second<b.second;\n  }else{\n    return a.first<b.second;\n  }\n}\n\nint binary_serch(int n/*second*/,int begin,int end){\n  if(begin>=end){\n    if(cost_room[1][begin].second<n){\n      return -1;\n    }else{\n      return end;\n    }\n  }\n  //return first\n  int tmp=(begin+end)/2;\n  if(cost_room[1][tmp].second<n){\n    return binary_serch(n,tmp+1,end);\n  }else{\n    return binary_serch(n,begin,tmp);\n  }\n}\n\n\nint solve(){\n  \n  priority_queue<pos> q;\n  q.push(pos(map[0][el[0].first][el[0].second] , 0 , el[0].first , el[0].second));\n\n  cost_room[0].clear();\n  cost_room[1].clear();\n  pair<int,int> tmp_c;\n\n  tmp_c.first =0;\n  tmp_c.second=0;\n\n  while((!q.empty())){\n    pos tmp=q.top();q.pop();\n    if(tmp_c.first<tmp.c){\n      cost_room[tmp.k].push_back(tmp_c);\n      tmp_c.second++;\n      tmp_c.first=tmp.c;\n    }else if(tmp_c.first>=tmp.c && tmp.c!=0){\n      tmp_c.second++;\n    }\n\n    used[tmp.k][tmp.x][tmp.y]=true;\n    for(int i=0;i<4;i++){\n      if((!(tmp.x+vx[i]<0||used[tmp.k].size()-1<tmp.x+vx[i]))\n          &&(!(tmp.y+vy[i]<0||used[tmp.k][tmp.x+vx[i]].size()-1<tmp.y+vy[i]))\n          &&(!used[tmp.k][tmp.x+vx[i]][tmp.y+vy[i]])){\n        q.push(pos( map[tmp.k][tmp.x+vx[i]][tmp.y+vy[i]], tmp.k, tmp.x+vx[i],tmp.y+vy[i]));\n      }\n    }\n  }\n  cost_room[0].push_back(tmp_c);\n  \n  q.push(pos(map[1][el[1].first][el[1].second] , 1 , el[1].first , el[1].second));\n  tmp_c.first =0;\n  tmp_c.second=0;\n  while((!q.empty())){\n    pos tmp=q.top();q.pop();\n    if(used[tmp.k][tmp.x][tmp.y])continue; \n    if(tmp_c.first<tmp.c){\n      cost_room[tmp.k].push_back(tmp_c);\n      tmp_c.second++;\n      tmp_c.first=tmp.c;\n    }else if(tmp_c.first>=tmp.c && tmp.c!=0){\n      tmp_c.second++;\n    }\n\n    used[tmp.k][tmp.x][tmp.y]=true;\n    for(int i=0;i<4;i++){\n      if((!(tmp.x+vx[i]<0||used[tmp.k].size()-1<tmp.x+vx[i]))\n          &&(!(tmp.y+vy[i]<0||used[tmp.k][tmp.x+vx[i]].size()-1<tmp.y+vy[i]))\n          &&(!used[tmp.k][tmp.x+vx[i]][tmp.y+vy[i]])){\n        q.push(pos( map[tmp.k][tmp.x+vx[i]][tmp.y+vy[i]], tmp.k, tmp.x+vx[i],tmp.y+vy[i]));\n      }\n    }\n  }\n  cost_room[1].push_back(tmp_c);\n\n  sort(cost_room[0].begin(),cost_room[0].end(),pair_sec_comp);\n  sort(cost_room[1].begin(),cost_room[1].end(),pair_sec_comp);\n\n  int res=INT_MAX;\n  for(int i=0;i<cost_room[0].size();i++){\n    int tmp=binary_serch(r-cost_room[0][i].second,0,cost_room[1].size()-1);\n    if(tmp!=-1){\n      res=min(cost_room[0][i].first+cost_room[1][tmp].first,res);\n    }\n  }\n  return res;\n}\n\n\n\nint main(){\n  while(init(),input()){\n    cout<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <climits>\n#include <vector>\n#include <map>\n#include <set>\n#include <list>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <tuple>\n\n#define REP(i,n) for(long long i=0;i<n;++i)\n#define REPR(i,n) for(long long i=n;i>=0;--i)\n#define REPI(itr,v) for(auto itr=v.begin();itr!=v.end();++itr)\n#define REPIR(itr,v) for(auto itr=v.rbegin();itr!=v.rend();++itr)\n#define FOR(i,a,b) for(long long i=a;i<b;++i)\n#define SORT(v,n) sort(v, v+n)\n#define SORTV(v) sort(v.begin(), v.end())\n#define ALL(v) v.begin(),v.end()\n#define llong long long\n#define INF 999999999\n#define SUR 1000000007\n#define pb push_back\n#define pf push_front\n#define MP make_pair\n#define SV(v) {for(long long sitr=0;sitr<v.size();++sitr){cin>>v[sitr];}}\n\nint dx[] = {0, 0, -1, 1};\nint dy[] = {1, -1, 0, 0};\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\n\nint main(){\n\n  while(true){\n\n    llong R;\n    cin >> R;\n\n    if(R == 0) break;\n\n    llong L1[500][500], L2[500][500];\n    llong w[2], h[2], x[2], y[2];\n\n\n    cin >> w[0] >> h[0] >> x[0] >> y[0];\n    x[0]--; y[0]--;\n    REP(i,h[0]){\n      REP(j,w[0]){\n        cin >> L1[i][j];\n      }\n    }\n\n    cin >> w[1] >> h[1] >> x[1] >> y[1];\n    x[1]--; y[1]--;\n    REP(i,h[1]){\n      REP(j,w[1]){\n        cin >> L2[i][j];\n      }\n    }\n\n    llong max_level1 = 0, max_level2 = 0;\n    vector<llong> rec1, rec2;\n    rec1.push_back(0);\n    rec2.push_back(0);\n    \n    bool used[500][500] = {};\n    using Elem = tuple<llong, int, int>;\n    priority_queue<Elem, vector<Elem>, greater<Elem> > que;\n\n    que.emplace(1, x[0], y[0]);\n    used[y[0]][x[0]] = true;\n\n    while(que.size()) {\n      llong level; int X, Y; tie(level, X, Y) = que.top(); que.pop();\n      if(level > max_level1) max_level1 = level;\n      rec1.push_back(max_level1);\n\n      REP(i,4){\n        if(X + dx[i] >= 0 && X + dx[i] < w[0] && Y + dy[i] >= 0 && Y + dy[i] < h[0]){\n          if(!used[Y+dy[i]][X+dx[i]]){\n            used[Y+dy[i]][X+dx[i]] = true;\n            que.emplace(L1[Y+dy[i]][X+dx[i]], X+dx[i], Y+dy[i]);\n          }\n        }\n      }\n    }\n\n    memset(used, 0, sizeof(used));    \n\n    que.emplace(1, x[1], y[1]);\n    used[y[1]][x[1]] = true;\n\n    while(que.size()) {\n      llong level; int X, Y; tie(level, X, Y) = que.top(); que.pop();\n      if(level > max_level2) max_level2 = level;\n      rec2.push_back(max_level2);\n\n      REP(i,4){\n        if(X + dx[i] >= 0 && X + dx[i] < w[1] && Y + dy[i] >= 0 && Y + dy[i] < h[1]){\n          if(!used[Y+dy[i]][X+dx[i]]){\n            used[Y+dy[i]][X+dx[i]] = true;\n            que.emplace(L2[Y+dy[i]][X+dx[i]], X+dx[i], Y+dy[i]);\n          }\n        }\n      }\n    }\n\n    llong ans = 1LL << 60;\n    REP(i,R+1){\n      if(i >= rec1.size()) continue;\n      if(R-i >= rec2.size()) continue;\n      ans = min(ans, rec1[i] + rec2[R-i]);\n    }\n    cout << ans << endl;\n  }\n\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint w,h,x,y,a[505][505],b[505][505],c[505][505];\n\npair<int,int> make_P(int ma,int mb){pair<int,int> ret; ret.first=ma; ret.second=mb; return ret;}\n\nvoid ww(int wx,int wy){\n\tc[wx][wy]=1;\n\tif(b[wx][wy+1]==1&&c[wx][wy+1]==0)ww(wx,wy+1);\n\tif(b[wx][wy-1]==1&&c[wx][wy-1]==0)ww(wx,wy-1);\n\tif(b[wx+1][wy]==1&&c[wx+1][wy]==0)ww(wx+1,wy);\n\tif(b[wx-1][wy]==1&&c[wx-1][wy]==0)ww(wx-1,wy);\n}\n\nvector<int> els(vector<int> vp){\n\tvector<int> ret;\n\tint s=vp.size();\n\tret.push_back(vp[0]);\n\tfor(int i=1;i<s;i++){\n\t\tif(vp[i]!=vp[i-1])ret.push_back(vp[i]);\n\t}\n\treturn ret;\n}\n\nvector<pair<int,int>> office(){\n\tfor(int i=0;i<505;i++)for(int j=0;j<505;j++){b[i][j]=0; c[i][j]=0;}\n\tvector<int> v;\n\tfor(int i=1;i<=h;i++)for(int j=1;j<=h;j++)v.push_back(a[i][j]);\n\tsort(v.begin(),v.end());\n\tv=els(v);\n\tvector<pair<int,int>> ret;\n\tret.push_back(make_P(0,0));\n\tint s=v.size();\n\tb[x][y]=1; c[x][y]=1;\n\tfor(int i=0;i<s;i++){\n\t\tfor(int j=1;j<=h;j++)for(int k=1;k<=w;k++){\n\t\t\tif(a[j][k]==v[i]){\n\t\t\t\tb[j][k]=1;\n\t\t\t\tif(c[j][k+1]+c[j][k-1]+c[j+1][k]+c[j-1][k]!=0)ww(j,k);\n\t\t\t}\n\t\t}\n\t\tint sum=0;\n\t\tfor(int j=1;j<=h;j++)for(int k=1;k<=w;k++)sum+=c[j][k];\n\t\tret.push_back(make_P(v[i],sum));\n\t}\n\treturn ret;\n}\n\nint main(){\nwhile(1){\n\tint r,s[2];\n\tscanf(\"%d\",&r);\n\tif(r==0)break;\n\tvector<pair<int,int>> vvp[2];\n\tfor(int i=0;i<=1;i++){\n\t\tfor(int k=0;k<505;k++)for(int j=0;j<505;j++)a[k][j]=0;\n\t\tscanf(\"%d%d%d%d\",&w,&h,&x,&y);\n\t\tfor(int j=1;j<=h;j++)for(int k=1;k<=w;k++)scanf(\"%d\",&a[j][k]);\n\t\tvvp[i]=office();\n\t\ts[i]=vvp[i].size();\n\t}\n\tint n=s[1]-1,ret=200000000;\n\tfor(int i=0;i<s[0];i++){\n\t\tif(n!=0)while(vvp[0][i].second+vvp[1][n-1].second>=r){n--; if(n==0)break;}\n\t\tif(vvp[0][i].second+vvp[1][n].second>=r)ret=min(ret,vvp[0][i].first+vvp[1][n].first);\n\t}\n\tprintf(\"%d\\n\",ret);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\ntypedef pair<int, P> T;\nint table[500][500];\nint R;\nint W;\nint H;\nint X;\nint Y;\nvector<int> num[2];\nvector<int> level[2];\npriority_queue<T,vector<T>,greater<T> > q;\nint main() {\nwhile(1){\n\tscanf(\"%d\",&R);\n\tif(R==0)return 0;\n\tfor(int i=0;i<2;i++){\n\t\tnum[i].clear();\n\t\tlevel[i].clear();\n\t\tnum[i].push_back(0);\n\t\tlevel[i].push_back(0);\n\t\tscanf(\"%d%d%d%d\",&W,&H,&X,&Y);\n\t\tX--;\n\t\tY--;\n\t\tfor(int y=0;y<H;y++){\n\t\t\tfor(int x=0;x<W;x++){\n\t\t\t\tscanf(\"%d\",table[y]+x);\n\t\t\t}\n\t\t}\n\t\tq.push(T(1,P(Y,X)));\n\t\ttable[Y][X]=-1;\n\t\twhile(q.size()){\n\t\t\tint l=q.top().first;\n\t\t\tif(level[i].back()<l){\n\t\t\t\tlevel[i].push_back(l);\n\t\t\t\tnum[i].push_back(num[i].back());\n\t\t\t}\n\t\t\tnum[i].back()++;\n\t\t\tint dx=1;\n\t\t\tint dy=0;\n\t\t\tint x=q.top().second.second;\n\t\t\tint y=q.top().second.first;\n\t\t\tq.pop();\n\t\t\t//cout << x << \", \" << y << \", \" << l << endl;\n\t\t\tfor(int k=0;k<4;k++,swap(dx,dy),dx=-dx){\n\t\t\t\tint s=x+dx;\n\t\t\t\tint t=y+dy;\n\t\t\t\tif(0<=s&&s<W&&0<=t&&t<H&&table[t][s]>=0){\n\t\t\t\t\tq.push(T(table[t][s],P(t,s)));\n\t\t\t\t\ttable[t][s]=-1;\n\t\t\t\t\t//cout << s << \", \" << t << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int j=0;j<num[i].size();j++){\n\t\t\tcout << level[i][j] << \": \" << num[i][j] << endl;\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\t}\n\tint a=num[1].size()-1;\n\tint ret=INT_MAX;\n\tfor(int i=0;i<num[0].size();i++){\n\t\twhile(R<=num[1][a]+num[0][i]&&a>=0){\n\t\t\tret=min(ret,level[1][a]+level[0][i]);\n\t\t\ta--;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ret);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 160000\n#define B 100\n#define dpb push_back\n#define fi first\n#define se second\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst int inf = 1e9;\nconst ll INF = 1e18;\nconst int size = 902;\n//__gcd(a,b), __builtin_popcount(a);\n\nint r, h1, w1, X1, Y1, h2, w2, X2, Y2;\nint dy[4] = {0, 0, -1, 1}, dx[4] = {-1, 1, 0, 0};\nint a[size][size], b[size][size];\nint an[250010], bn[250010];\n\nint to_n(int y, int x, int w){\n\treturn (w*(y-1)+x);\n}\nint to_y(int n, int w){\n\treturn ((n-1)/w+1);\n}\nint to_x(int n, int w){\n\treturn (n-(to_y(n, w)-1)*w);\n}\nint main(){\n\twhile(1){\n\tfill((int*)a, (int*)(a+size), inf);\n\tfill((int*)b, (int*)(b+size), inf);\n\tfill(an, an+250004, 0);\n\tfill(bn, bn+250004, 0);\n\tscanf(\"%d\", &r);\n\tif(!r)break;\n\tscanf(\"%d%d%d%d\", &w1, &h1, &X1, &Y1);\n\trrep(i,h1)rrep(j,w1)scanf(\"%d\", &a[i][j]);\n\tscanf(\"%d%d%d%d\", &w2, &h2, &X2, &Y2);\n\trrep(i,h2)rrep(j,w2)scanf(\"%d\", &b[i][j]);\n\t\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tq.push(P(a[Y1][X1], to_n(Y1, X1,w1)));\n\ta[Y1][X1] = inf;\n\tint acnt = 1;\n\twhile(!q.empty()){\n\t\tP p = q.top();q.pop();\n\t\tint y = to_y(p.se, w1), x = to_x(p.se, w1);\n\t\tan[acnt++] = p.fi;\n\t\tfor(int i = 0;i < 4;i++){\n\t\t\tint yy = y+dy[i], xx = x+dx[i];\n\t\t\tif(a[yy][xx] != inf){\n\t\t\t\tq.push(P(a[yy][xx], to_n(yy, xx,w1)));\n\t\t\t\ta[yy][xx] = inf;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tq.push(P(b[Y2][X2], to_n(Y2, X2,w2)));\n\tb[Y2][X2] = inf;\n\tint bcnt = 1;\n\twhile(!q.empty()){\n\t\tP p = q.top();q.pop();\n\t\tint y = to_y(p.se, w2), x = to_x(p.se, w2);\n\t\tbn[bcnt++] = p.fi;\n\t\tfor(int i = 0;i < 4;i++){\n\t\t\tint yy = y+dy[i], xx = x+dx[i];\n\t\t\tif(b[yy][xx] != inf){\n\t\t\t\tq.push(P(b[yy][xx], to_n(yy, xx,w2)));\n\t\t\t\tb[yy][xx] = inf;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint t1 = 0, t2 = 0;\n\tfor(int i = 0;i < acnt;i++){\n\t\tt1 = max(t1, an[i]);\n\t\tan[i] = t1;\n\t}\n\tfor(int i = 0;i < bcnt;i++){\n\t\tt2 = max(t2, bn[i]);\n\t\tbn[i] = t2;\n\t}\n\t\n\tint ans = inf;\n\tfor(int i = 0;i < acnt;i++){\n\t\tif(r-i < bcnt)ans = min(ans, an[i]+bn[r-i]);\n\t}\n\t\n\t/*rep(i,acnt)printf(\"%d \", an[i]);\n\tprintf(\"\\n\");\n\trep(i,bcnt)printf(\"%d \", bn[i]);\n\tprintf(\"\\n\");*/\n\t//int ans = 0;\n\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#pragma warning(disable : 4996)\nusing namespace std;\nstruct state {\n\tint sx, sy, cost;\n};\nbool operator<(const state& s1, const state& s2) {\n\treturn s1.cost < s2.cost;\n}\nint R, H[2], W[2], sx[2], sy[2], a[2][509][509], b[2][250009]; bool vis[509][509];\nint dir[] = { 0, 1, 0, -1 };\nint main() {\n\twhile (scanf(\"%d\", &R), R) {\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tscanf(\"%d%d%d%d\", &W[i], &H[i], &sy[i], &sx[i]); sy[i]--, sx[i]--;\n\t\t\tfor (int j = 0; j < H[i]; j++) {\n\t\t\t\tfor (int k = 0; k < W[i]; k++) {\n\t\t\t\t\tscanf(\"%d\", &a[i][j][k]);\n\t\t\t\t\tvis[j][k] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpriority_queue<state> que; que.push(state{ sx[i], sy[i], -1 }); vis[sx[i]][sy[i]] = true;\n\t\t\twhile (!que.empty()) {\n\t\t\t\tstate u = que.top(); que.pop();\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tint tx = u.sx + dir[j], ty = u.sy + dir[j ^ 1];\n\t\t\t\t\tif (0 <= tx && tx < H[i] && 0 <= ty && ty < W[i] && !vis[tx][ty]) {\n\t\t\t\t\t\ta[i][tx][ty] = max(a[i][tx][ty], a[i][u.sx][u.sy]);\n\t\t\t\t\t\tvis[tx][ty] = true;\n\t\t\t\t\t\tque.push(state{ tx, ty, -a[i][tx][ty] });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < H[i]; j++) {\n\t\t\t\tfor (int k = 0; k < W[i]; k++) {\n\t\t\t\t\tb[i][j * W[i] + k] = a[i][j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(b[i], b[i] + H[i] * W[i]);\n\t\t}\n\t\tint ret = 2000000009; R -= 2;\n\t\tfor (int i = 0; i <= R && i < H[0] * W[0] && i < H[1] * W[1]; i++) ret = min(ret, b[0][i] + b[1][R - i]);\n\t\tif (R == -1) ret = 2;\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, -1, 0, 1};\n\nconst int INF = (int)1e9;\n\ninline vector<pii> func(){\n\tint w, h, x, y;\n\tscanf(\"%d%d%d%d\", &w, &h, &x, &y);\n\t\n\tvector<vector<int> > L(w + 2, vector<int>(h + 2, -1));\n\tvector<int> Ls;\n\tLs.reserve(w * h + 2);\n\tLs.push_back(0);\n\tLs.push_back(INF);\n\t\n\tfor(int i = 1; i <= h; ++i)\n\tfor(int j = 1; j <= w; ++j){\n\t\tscanf(\"%d\", &L[j][i]);\n\t\tLs.push_back(L[j][i]);\n\t}\n\t\n\tsort(Ls.begin(), Ls.end());\n\tLs.erase(unique(Ls.begin(), Ls.end()), Ls.end());\n\t\n\tvector<pii> c(Ls.size());\n\tfor(int i = 0; i < Ls.size(); ++i){\n\t\tc[i].second = Ls[i];\n\t}\n\n\tpriority_queue<pii,vector<pii>,greater<pii> > pq;\n\tpq.push( pii(1, x << 16 | y) );\n\tL[x][y] = -1;\n\n\twhile( !pq.empty() ){\n\t\tqueue<int> q;\n\t\tq.push(pq.top().second);\n\t\tint u = pq.top().first;\n\t\tpq.pop();\n\n\t\tint k = lower_bound(Ls.begin(), Ls.end(), u) - Ls.begin();\n\t\t++c[k].first;\n\n\t\twhile( !q.empty() ){\n\t\t\tfor(int i = 0; i < 4; ++i){\n\t\t\t\tx = (q.front() >> 16) + dx[i];\n\t\t\t\ty = (q.front() & 0xffff) + dy[i];\n\n\t\t\t\tif( L[x][y] > 0 ){\n\t\t\t\t\tif( L[x][y] <= u ){\n\t\t\t\t\t\tL[x][y] = -1;\n\t\t\t\t\t\t++c[k].first;\n\t\t\t\t\t\tq.push(x << 16 | y);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpq.push( pii(L[x][y], x << 16 | y) );\n\t\t\t\t\t\tL[x][y] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tq.pop();\n\t\t}\n\t}\n\t\n\tfor(int i = 2; i < c.size(); ++i){\n\t\tc[i].first += c[i - 1].first;\n\t}\n\tc.back().first = INF;\n\t\n\treturn c;\n}\n\nint main(){\n\tint R;\n\twhile( scanf(\"%d\", &R), R != 0 ){\n\t\tvector<pii> t1 = func();\n\t\tvector<pii> t2 = func();\n\n\t\tint ans = INF;\n\t\tfor(int i = 0; i + 1 < t1.size(); ++i){\n\t\t\tint a = t1[i].second;\n\t\t\tpii p = pii(R - t1[i].first, -1);\n\t\t\tint b = lower_bound(t2.begin(), t2.end(), p)->second;\n\t\t\tans = min(ans, a + b);\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nconst int N = 500;\nconst int INF = 1000000000;\n\nint R, w[2], h[2], sx[2], sy[2], input[2][N][N], vis[N][N];\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nvector<int> vec[2];\nset<int> data;\n\nvoid dfs(int x, int y, int cost, int d){\n  vis[y][x] = cost;\n  for(int i=0;i<4;i++){\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if(ny < 0 || ny >= h[d]) continue;\n    if(nx < 0 || nx >= w[d]) continue;\n    if(vis[ny][nx] > max(cost, input[d][ny][nx])) dfs(nx, ny, max(cost, input[d][ny][nx]), d);\n  }\n}\n\nvoid init(){\n  for(int k=0;k<2;k++){\n    for(int i=0;i<h[k];i++){\n      for(int j=0;j<w[k];j++){\n        data.insert(input[k][i][j]);\n      }\n    }\n  }\n  for(int k=0;k<2;k++){\n    fill(vis[0], vis[N], INF);\n    dfs(sx[k], sy[k], 1, k);\n    vec[k].clear();\n    for(int i=0;i<h[k];i++){\n      for(int j=0;j<w[k];j++){\n        vec[k].push_back(vis[i][j]);\n      }\n    }\n    sort(vec[k].begin(), vec[k].end());\n  }\n  /*data[0] = 0;\n  int p = 0;\n  for(int i=0;i<tmp.size();i++){\n    if(tmp[i] > p) p = tmp[i];\n    data[p]++;\n    }*/\n}\n\nint solve(){\n  /*for(int i=0;i<2;i++){\n    for(int j=0;j<vec[i].size();j++){\n      cout << vec[i][j] << ' ';\n    }\n    cout << endl;\n    }*/\n  int l = 0, r = 100000000;\n  while(l<r){\n    //cout << l << ' ' << r << endl;\n    int m = (l + r) / 2;\n    bool f = false;\n    for(set<int>::iterator ite=data.begin();ite!=data.end();ite++){\n      if(*ite > m) break;\n      int a = distance(vec[0].begin(), upper_bound(vec[0].begin(), vec[0].end(), *ite));\n      int b = distance(vec[1].begin(), upper_bound(vec[1].begin(), vec[1].end(), m-(*ite)));\n      if(a + b >= R) f = true;\n      //cout << *ite << ' ' << m - (*ite) << ' ' << a << ' ' << b << ' ' << R << endl;\n    }\n    //cout << \"f = \" << f << ' ' << \"m = \" << m << endl;\n    if(f) r = m;\n    else l = m + 1;\n  }\n  //cout << l << ' ' << r << endl;\n  return l;\n}\n\nmain(){\n  while(cin >> R && R){\n    for(int k=0;k<2;k++){\n      cin >> w[k] >> h[k] >> sx[k] >> sy[k];\n      sx[k]--; sy[k]--;\n      for(int i=0;i<h[k];i++){\n        for(int j=0;j<w[k];j++){\n          cin >> input[k][i][j];\n        }\n      }\n    }\n    init();\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\n\nvector<int> calc_required_level_to_rooms()\n{\n\tint w, h, sx, sy;\n\tstatic int req[512][512];\n\tcin >> w >> h >> sx >> sy;\n\t--sx, --sy;\n\tfor (int y = 0; y < h; ++y)\n\t\tfor (int x = 0; x < w; ++x)\n\t\t\tcin >> req[y][x];\n\n\tvector<int> res;\n\tres.push_back(0);\n\n\tstatic bool visit[512][512];\n\tCLEAR(visit, 0);\n\n\ttypedef pair<int, pint> P;\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tq.push(P(1, pint(sx, sy)));\n\twhile (!q.empty())\n\t{\n\t\tP tt = q.top(); q.pop();\n\t\tint level = tt.first;\n\t\tint x = tt.second.first, y = tt.second.second;\n\t\tif (visit[y][x])\n\t\t\tcontinue;\n\n\t\tvisit[y][x] = true;\n\t\tres.push_back(level);\n\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\t\tif (valid_pos(tx, ty, w, h) && !visit[ty][tx])\n\t\t\t\tq.push(P(max(level, req[ty][tx]), pint(tx, ty)));\n\t\t}\n\t}\n\treturn res;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tint r;\n\twhile (cin >> r, r)\n\t{\n\t\tvector<int> a = calc_required_level_to_rooms();\n\t\tvector<int> b = calc_required_level_to_rooms();\n\n\t\tif (a.size() < b.size())\n\t\t\tswap(a, b);\n\n\t\tint res = 1e9;\n\t\tfor (int i = min<int>(r, a.size() - 1); i >= 0 && r - i < b.size(); --i)\n\t\t\tmin_swap(res, a[i] + b[r - i]);\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define\tmp\tmake_pair\n#define\tpb\tpush_back\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint main(){\n\tfor(int r;scanf(\"%d\",&r),r;){\n\t\tint w[2],h[2],x[2],y[2];\n\t\tstatic int room[2][500][500];\n\t\tvector<pii> roomcnt[2];\t// <auth lev,number of rooms>\n\t\tfor(int k=0;k<2;k++){\n\t\t\tscanf(\"%d%d%d%d\",&w[k],&h[k],&x[k],&y[k]);\n\t\t\tx[k]--,y[k]--;\n\t\t\tfor(int i=0;i<h[k];i++)for(int j=0;j<w[k];j++)\tscanf(\"%d\",&room[k][i][j]);\n\n\t\t\tstatic bool visited[500][500];\n\t\t\tfor(int i=0;i<h[k];i++)for(int j=0;j<w[k];j++)\tvisited[i][j]=false;\n\t\t\tvisited[y[k]][x[k]]=true;\n\t\t\troomcnt[k].pb(mp(0,0));\n\n\t\t\tint cnt=0,lev=0;\n\t\t\tpriority_queue< pair<int,pii> > pq;\n\t\t\tpq.push(mp(-room[k][y[k]][x[k]],mp(y[k],x[k])));\n\t\t\twhile(!pq.empty()){\n\t\t\t\tpair<int,pii> a=pq.top();\tpq.pop();\n\t\t\t\tint nowlev=-a.first,x=a.second.second,y=a.second.first;\n\t\t\t\tcnt++;\n\t\t\t\tif(lev<nowlev){\n\t\t\t\t\troomcnt[k].pb(mp(cnt,nowlev));\n\t\t\t\t\tlev=nowlev;\n\t\t\t\t}\n\t\t\t\telse\t*(roomcnt[k].rbegin())=mp(cnt,lev);\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint xx=x+dx[i],yy=y+dy[i];\n\t\t\t\t\tif(0<=xx && xx<w[k] && 0<=yy && yy<h[k] && !visited[yy][xx]){\n\t\t\t\t\t\tpq.push(mp(-room[k][yy][xx],mp(yy,xx)));\n\t\t\t\t\t\tvisited[yy][xx]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans=1<<30;\n\t\tfor(int i=0;i<roomcnt[0].size();i++){\n\t\t\tint rem=r-roomcnt[0][i].first;\n\t\t\tvector<pii>::iterator it=lower_bound(roomcnt[1].begin(),roomcnt[1].end(),mp(rem,0));\n\t\t\tif(it!=roomcnt[1].end()){\n\t\t\t\tint lev1=roomcnt[0][i].second;\n\t\t\t\tint lev2=it->second;\n\t\t\t\tans=min(ans,lev1+lev2);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\n#include<map>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define INF (1<<24)\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\n\nstruct state {\n  int y,x,cost;\n  bool operator < (const state &p)const{\n    return cost > p.cost; \n  }\n};\n\nint R;\nint th,tw,uh,uw,ty,tx,uy,ux;\nint t[500][500],u[500][500];\nint T[100000],U[100000];\nint d[500][500];\nvector<int> G;\nmap<int,int> g;\n\nvoid compute(int a[500][500],int H,int W,int sy,int sx,int v[100000]){\n  for(int i=0;i<500;i++)for(int j=0;j<500;j++)d[i][j]=INF;\n  priority_queue<state> Q;\n  Q.push((state){sy,sx,1});\n  d[sy][sx]=1;\n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    if(d[s.y][s.x]<s.cost)continue;\n    v[g[s.cost]]++;\n    for(int i=0;i<4;i++){\n      int ny=s.y+dy[i],nx=s.x+dx[i];\n      if(ny<0||nx<0)continue;\n      if(ny>=H||nx>=W)continue;\n      int ncost=max(a[ny][nx],s.cost);\n      if(d[ny][nx]<=ncost)continue;\n      d[ny][nx]=ncost;\n      Q.push((state){ny,nx,ncost});\n    }\n  }\n}\n\nvoid solve(){\n  sort(G.begin(),G.end());\n  G.erase(unique(G.begin(),G.end()),G.end());\n  for(int i=0;i<(int)G.size();i++)g[G[i]]=i;\n  compute(t,th,tw,ty,tx,T);\n  compute(u,uh,uw,uy,ux,U);\n  int size=G.size();\n  for(int i=0;i<size;i++){\n    if(i)T[i]+=T[i-1];\n    if(i)U[i]+=U[i-1];\n    //cout<<T[i]<<\" \"<<U[i]<<\" \"<<G[i]<<endl;\n  }\n\n  int ans=INF;\n  for(int i=0;i<size;i++){\n    int target=R-T[i];\n    int* it=lower_bound(U,U+size,target);\n    if(it==U+size)continue;\n    ans=min(ans,G[i]+G[it-U]);\n  }\n  cout<<ans<<endl;\n}\n\nvoid init(){\n  G.clear();\n  g.clear();\n  G.push_back(0);\n  for(int i=0;i<100000;i++)\n    T[i]=U[i]=0;\n}\n\nint main(){\n  while(cin>>R,R){    \n    init();\n    cin>>tw>>th>>tx>>ty;\n    ty--,tx--;\n    for(int i=0;i<th;i++){\n      for(int j=0;j<tw;j++){\n\tcin>>t[i][j];\n\tG.push_back(t[i][j]);\n      }\n    }\n    cin>>uw>>uh>>ux>>uy;\n    uy--,ux--;\n    for(int i=0;i<uh;i++){\n      for(int j=0;j<uw;j++){\n\tcin>>u[i][j];\n\tG.push_back(u[i][j]);\n      }\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint main() {\n    while (true) {\n        int r;\n        cin >> r;\n        if (r == 0)break;\n        vector<vector<int>> v(2, vector<int>(r + 1));\n        for (int _ = 0; _ < 2; _++) {\n            int w, h, x, y;\n            cin >> w >> h >> x >> y;\n            vector<vector<int>> ban(h, vector<int>(w));\n            for (int i = 0; i < h; i++) {\n                for (int j = 0; j < w; j++)cin >> ban[i][j];\n            }\n            priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> q;\n            q.push({1, y, x});\n            vector<vector<bool>> visited(h + 2, vector<bool>(w + 2));\n            visited[y][x] = true;\n            v[_][1] = 1;\n            for (int i = 0; i <= h + 1; i++) {\n                visited[i][0] = true;\n                visited[i][w + 1] = true;\n            }\n            for (int i = 0; i <= w + 1; i++) {\n                visited[0][i] = true;\n                visited[h + 1][i] = true;\n            }\n\n            vector<vector<int>> move = {{1,  0},\n                                        {-1, 0},\n                                        {0,  1},\n                                        {0,  -1}};\n            for (int i = 2; i <= r; i++) {\n                vector<int> a = q.top();\n                q.pop();\n                for (int j = 0; j < 4; j++) {\n                    int c = a[1] + move[j][0];\n                    int d = a[2] + move[j][1];\n                    if (!visited[c][d]) {\n                        visited[c][d] = true;\n                        vector<int> aaa(3);\n                        aaa[0] = ban[c - 1][d - 1];\n                        aaa[1] = c;\n                        aaa[2] = d;\n                        q.push(aaa);\n                    }\n                }\n                if (q.empty())break;\n                v[_][i] = max(v[_][i - 1], q.top()[0]);\n            }\n        }\n        int ret = 1145141919;\n        for (int i = 0; i <= r; i++) {\n            if ((i == 0 || v[0][i] != 0) && (r - i == 0 || v[1][r - i] != 0))\n                ret = min(ret, v[0][i] + v[1][r - i]);\n        }\n        cout << ret << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pint;\ntypedef pair<ll, int> P;\ntypedef tuple<int,int,int> T;\nll INFL = 1000000000000000010;//10^18 = 2^60\nint INF = 2147483600;//10^9\nll MOD  = 1000000007;\nvector<int> dy = {0,0,1,-1};\nvector<int> dx = {1,-1,0,0};\nint solve(){\n    int R;\n    cin >> R;\n    if(R == 0)return 0;\n    int H1,W1,X1,Y1;\n    cin >> W1 >> H1 >> X1 >> Y1;\n    X1--;\n    Y1--;\n    vector<vector<ll>> mp1(H1, vector<ll>(W1));\n    vector<vector<ll>> d1(H1, vector<ll>(W1, INFL));\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            cin >> mp1[i][j];\n        }\n    }\n    \n    d1[Y1][X1] = 1;\n    priority_queue<pair<ll, pair<int, int>>> pque1;\n    pque1.push({1, {Y1, X1}});\n    \n    while(!pque1.empty()){\n        ll c;\n        int y,x;\n        c = pque1.top().first;\n        y = pque1.top().second.first;\n        x = pque1.top().second.second;\n        pque1.pop();\n        if(c > d1[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H1 && 0 <= nx && nx < W1){\n                if(d1[ny][nx] > d1[y][x]){\n                    if(d1[y][x] > mp1[ny][nx]){\n                        d1[ny][nx] = d1[y][x];\n                    }else{\n                        d1[ny][nx] = mp1[ny][nx];\n                    }\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }else if(d1[ny][nx] > d1[y][x]){\n                    d1[ny][nx] = mp1[ny][nx];\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    int H2,W2,X2,Y2;\n    cin >> W2 >> H2 >> X2 >> Y2;\n    X2--;\n    Y2--;\n    vector<vector<ll>> mp2(H2, vector<ll>(W2));\n    vector<vector<ll>> d2(H2, vector<ll>(W2, INFL));\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            cin >> mp2[i][j];\n        }\n    }\n    \n    d2[Y2][X2] = 1;\n    priority_queue<pair<ll, pair<int, int>>> pque2;\n    pque2.push({1, {Y2, X2}});\n    \n    while(!pque2.empty()){\n        ll c;\n        int y,x;\n        c = pque2.top().first;\n        y = pque2.top().second.first;\n        x = pque2.top().second.second;\n        pque2.pop();\n        if(c > d2[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H2 && 0 <= nx && nx < W2){\n                if(d2[ny][nx] > d2[y][x]){\n                    if(d2[y][x] > mp2[ny][nx]){\n                        d2[ny][nx] = d2[y][x];\n                    }else{\n                        d2[ny][nx] = mp2[ny][nx];\n                    }\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }else if(d2[ny][nx] > d2[y][x]){\n                    d2[ny][nx] = mp2[ny][nx];\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    vector<pair<ll,int>> O1(0);\n    vector<ll> COST1(0);\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            COST1.push_back(d1[i][j]);\n        }\n    }\n    sort(COST1.begin(), COST1.end());\n    COST1.push_back(INFL);\n    ll ad1 = COST1.at(0);\n    int cnt = 0;\n    for(int i = 0; i < COST1.size(); i++){\n        if(ad1 == COST1.at(i)){\n            cnt++;\n        }else{\n            O1.push_back({ad1, cnt});\n            ad1 = COST1.at(i);\n            cnt++;\n        }\n    }\n    \n    vector<pair<ll,int>> O2 = {{0, 0}};\n    vector<ll> COST2(0);\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            COST2.push_back(d2[i][j]);\n        }\n    }\n    sort(COST2.begin(), COST2.end());\n    COST2.push_back(INFL);\n    ll ad2 = COST2.at(0);\n    cnt = 0;\n    for(int i = 0; i < COST2.size(); i++){\n        if(ad2 == COST2.at(i)){\n            cnt++;\n        }else{\n            O2.push_back({ad2, cnt});\n            ad2 = COST2.at(i);\n            cnt++;\n        }\n    }\n    \n    ll ans = INFL;\n    for(int i = 0; i < O1.size(); i++){\n        ll cost = O1.at(i).first;\n        int rest = R - O1.at(i).second;\n        \n        if(rest > O2.at(O2.size()-1).second) continue;\n        int left = -1, right = O2.size();\n        int mid;\n        while(right - left > 1){\n            mid = (left + right) / 2;\n            if(O2.at(mid).second >= rest){\n                right = mid;\n            }else{\n                left = mid;\n            }\n        }\n        cost += O2.at(right).first;\n        ans = min(ans, cost);\n        \n    }\n    \n    cout << ans << endl;\n    \n    solve();\n    return 0;\n}\n\nint main(void){\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <queue>\n\nusing namespace std;\n\nconst int N = 500;\nconst int INF = 1000000000;\n\nclass S{\npublic:\n  int x, y, cost;\n  S(){}\n  S(int x, int y, int cost) : x(x), y(y), cost(cost) {}\n  bool operator < (const S& s) const {\n    return cost > s.cost;\n  }\n};\n\nint R, w[2], h[2], sx[2], sy[2], input[2][N][N], vis[N][N];\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nvector<int> vec[2];\nset<int> data;\nint cnt;\n\nvoid bfs(int d){\n  int x = sx[d];\n  int y = sy[d];\n  int cost = 1;\n  priority_queue<S> q;\n  S u;\n  q.push(S(x, y, cost));\n  vis[y][x] = cost;\n  while(!q.empty()){\n    u = q.top(); q.pop();\n    if(vis[u.y][u.x] < u.cost) continue;\n    for(int i=0;i<4;i++){\n      int ny = u.y + dy[i];\n      int nx = u.x + dx[i];\n      if(ny < 0 || ny >= h[d]) continue;\n      if(nx < 0 || nx >= w[d]) continue;\n      int tmp = max(u.cost, input[d][ny][nx]);\n      if(vis[ny][nx] > tmp){\n        vis[ny][nx] = tmp;\n        q.push(S(nx, ny, tmp));\n      }\n    }\n  }\n}\n\nvoid init(){\n  data.clear();\n  for(int k=0;k<2;k++){\n    for(int i=0;i<h[k];i++){\n      for(int j=0;j<w[k];j++){\n        data.insert(input[k][i][j]);\n      }\n    }\n  }\n  for(int k=0;k<2;k++){\n    fill(vis[0], vis[N], INF);\n    bfs(k);\n    vec[k].clear();\n    for(int i=0;i<h[k];i++){\n      for(int j=0;j<w[k];j++){\n        vec[k].push_back(vis[i][j]);\n      }\n    }\n    sort(vec[k].begin(), vec[k].end());\n  }\n}\n\n/*void dfs(int x, int y, int cost, int d){\n  vis[y][x] = true;\n  cnt++;\n  for(int i=0;i<4;i++){\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if(ny < 0 || ny >= h[d]) continue;\n    if(nx < 0 || nx >= w[d]) continue;\n    if(input[d][ny][nx] > cost) continue;\n    if(!vis[ny][nx]) dfs(nx, ny, cost, d);\n  }\n  }*/\n\nbool check(int a, int b){\n  int t1 = distance(vec[0].begin(), upper_bound(vec[0].begin(), vec[0].end(), a));\n  int t2 = distance(vec[1].begin(), upper_bound(vec[1].begin(), vec[1].end(), b));\n  return t1 + t2 >= R;\n  /*int sum = 0;\n  for(int i=0;i<2;i++){\n    fill(vis[0], vis[N], false);\n    cnt = 0;\n    int cost = a;\n    if(i == 1) cost = b;\n    if(cost > 0) dfs(sx[i], sy[i], cost, i);\n    sum += cnt;\n  }\n  return sum >= R;*/\n}\n\nint solve(){\n  set<int>::iterator ite = data.end();\n  int l = 0, r = *(--ite) + 1;\n  while(l<r){\n    int m = (l + r) / 2;\n    bool f = false;\n    for(ite=data.begin();ite!=data.end();ite++){\n      if(*ite > m) break;\n      if(check(*ite, m-(*ite))) f = true;\n    }\n    if(f) r = m;\n    else l = m + 1;\n  }\n  return l;\n}\n\nmain(){\n  while(cin >> R && R){\n    for(int k=0;k<2;k++){\n      cin >> w[k] >> h[k] >> sx[k] >> sy[k];\n      sx[k]--; sy[k]--;\n      for(int i=0;i<h[k];i++){\n        for(int j=0;j<w[k];j++){\n          cin >> input[k][i][j];\n        }\n      }\n    }\n    init();\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\nint R;\ntemplate<typename T> using min_priority_queue = priority_queue<T, vector<T>, greater<T>>;\nint dx[4] = { 0, 1, 0, -1 }, dy[4] = { -1, 0, 1, 0 };\n//---------------------------------------------------------------------------------------------------\nint W, H, X, Y, A[505][505], dp[505][505], vis[505][505];\nvector<pair<int,int>> get() {\n    cin >> W >> H >> X >> Y;\n    X--; Y--;\n    rep(y, 0, H) rep(x, 0, W) cin >> A[y][x];\n\n    rep(y, 0, H) rep(x, 0, W) dp[y][x] = inf;\n    rep(y, 0, H) rep(x, 0, W) vis[y][x] = 0;\n    dp[Y][X] = 1;\n\n    min_priority_queue<pair<int, int>> que;\n    que.push({ 1, Y * 505 + X });\n\n    while (!que.empty()) {\n        auto q = que.top(); que.pop();\n\n        int c = q.first;\n        int y = q.second / 505;\n        int x = q.second % 505;\n\n        if (vis[y][x]) continue;\n        vis[y][x] = 1;\n\n        rep(i, 0, 4) {\n            int xx = x + dx[i];\n            int yy = y + dy[i];\n\n            if (0 <= xx and xx < W and 0 <= yy and yy < H) {\n                int cc = max(c, A[yy][xx]);\n                if (cc < dp[yy][xx]) {\n                    dp[yy][xx] = cc;\n                    que.push({ cc, yy * 505 + xx });\n                }\n            }\n        }\n    }\n\n    map<int, int> cnt;\n    rep(y, 0, H) rep(x, 0, W) cnt[dp[y][x]]++;\n\n    vector<pair<int, int>> res;\n    int sm = 0;\n    fore(p, cnt) {\n        sm += p.second;\n        res.push_back({ sm, p.first });\n    }\n    return res;\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    while (cin >> R) {\n        if (R == 0) return;\n        auto a = get();\n        auto b = get();\n\n        int ans = inf;\n        fore(p, a) {\n            if (R <= p.first) {\n                chmin(ans, p.second);\n                continue;\n            }\n\n            int idx = lower_bound(all(b), make_pair(R - p.first, -inf)) - b.begin();\n            if (idx < b.size()) {\n                chmin(ans, p.second + b[idx].second);\n            }\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define s(x) scanf(\"%d\",&x)\n#define rep(i,x) for(int i=0;i<x;i++)\nint v[500*500+500]={};\nint v2[500*500+500]={};\nint a[505][505];\nint b[505][505];\nbool used[505][505]={};\nint main()\n{\n\twhile(1)\n\t{\n\t\tint r;\n\t\tint w1,h1,x1,y1;\n\t\tscanf(\"%d\",&r);if(!r) return 0;\n\t\tscanf(\"%d %d %d %d\",&w1,&h1,&x1,&y1);\n\t\tfor(int i=1;i<=h1;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=w1;j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&a[j][i]);\n\t\t\t}\n\t\t}\n\t\tint w2,h2,x2,y2;\n\t\tscanf(\"%d %d %d %d\",&w2,&h2,&x2,&y2);\n\t\tfor(int i=1;i<=h2;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=w2;j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&b[j][i]);\n\t\t\t}\n\t\t}\n\t\tmemset(used,0,sizeof(used));\n\t\tpriority_queue<P1,vector<P1>,greater<P1> >que;\n\t\tque.push(mp(1,mp(x1,y1)));\n\t\tint cur=0;\n\t\tint now=0;\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tP1 p=que.top(); que.pop();\n\t\t\tint x=p.second.first;\n\t\t\tint y=p.second.second;\n\t\t\tused[x][y]=true;\n\t\t\tnow=max(now,p.first);\n\t\t\tv[++cur]=now;\n\t\t\tint dx[4]={0,1,0,-1};\n\t\t\tint dy[4]={1,0,-1,0};\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t{\n\t\t\t\tint nx=x+dx[i];\n\t\t\t\tint ny=y+dy[i];\n\t\t\t\tif(!(1<=nx && nx<=w1)) continue;\n\t\t\t\tif(!(1<=ny && ny<=h1)) continue;\n\t\t\t\tif(used[nx][ny]) continue;\n\t\t\t\tque.push(mp(a[nx][ny],mp(nx,ny)));\n\t\t\t}\n\t\t}\n\t\tmemset(used,0,sizeof(used));\n\t\tque.push(mp(1,mp(x2,y2)));\n\t\tcur=now=0;\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tP1 p=que.top(); que.pop();\n\t\t\tint x=p.second.first;\n\t\t\tint y=p.second.second;\n\t\t\tused[x][y]=true;\n\t\t\tnow=max(now,p.first);\n\t\t\tv2[++cur]=now;\n\t\t\tint dx[4]={0,1,0,-1};\n\t\t\tint dy[4]={1,0,-1,0};\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t{\n\t\t\t\tint nx=x+dx[i];\n\t\t\t\tint ny=y+dy[i];\n\t\t\t\tif(!(1<=nx && nx<=w2)) continue;\n\t\t\t\tif(!(1<=ny && ny<=h2)) continue;\n\t\t\t\tif(used[nx][ny]) continue;\n\t\t\t\tque.push(mp(b[nx][ny],mp(nx,ny)));\n\t\t\t}\n\t\t}\n//for(int i=0;i<=w1*h1;i++) printf(\"%ds \",v[i]);\n \n//for(int i=0;i<=w2*h2;i++) printf(\"%ds \",v2[i]); \n\t\tint ret=INF;\n\t\tfor(int i=max(0,r-w2*h2);i<=min(r,w1*h1);i++)\n\t\t{\n\t\t\tret=min(ret,v[i]+v2[r-i]);\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define reps(i,j,k) for(int i=j;i<=k;i++)\n#define HOGE -9\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\n\tint w,h,r,d[500][500],ex,ey,ans;\n\tint m[500][500];\nint main(){\n\tfor(;;){\n\t\tscanf(\"%d\",&r);\n\t\tif(r==0)break;\n\t\tvector<pii> cost[2];\n\t\trep(k,2){\n\t\t\tvector<int> c;\n\t\t\tscanf(\"%d%d%d%d\",&w,&h,&ex,&ey);\n\t\t\trep(i,h)rep(j,w){\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\",&t);\n\t\t\t\td[j][i] = t;\n\t\t\t\tc.push_back(t);\n\t\t\t}\n\t\t\tsort(c.begin(),c.end());\n\t\t\tc.erase(unique(c.begin(),c.end()),c.end());\n\t\t\trep(i,w)rep(j,h)m[i][j]=HOGE;\n\t\t\tint s=c.size(),cnt=1;\n\t\t\tconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\t\t\tm[--ex][--ey]=3;\n\t\t\trep(i,4)if(!(ex+dx[i]>=0 && ex+dx[i]<w && ey+dy[i]>=0 && ey+dy[i]<h))m[ex][ey]--;\n\t\t\tqueue<pii> q;\n\t\t\tcost[k].push_back(pii(0,0));\n\t\t\trep(l,s){\n\t\t\t\trep(i,w)rep(j,h){\n\t\t\t\t\tif(m[i][j]>0){\n\t\t\t\t\t\tq.push(pii(i,j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile(!q.empty()){\n\t\t\t\t\tint x=q.front().first,y=q.front().second;\n\t\t\t\t//\tputs(\"hoge\");\n\t\t\t\t\tq.pop();\n\t\t\t\t\trep(i,4){\n\t\t\t\t\t\tint tx=x+dx[i],ty=y+dy[i];\n\t\t\t\t\t\tif(tx>=0 && tx<w && ty>=0 && ty<h){\n\t\t\t\t\t\t\tif(d[tx][ty]<=c[l]){\n\t\t\t\t\t\t\t\tif(m[tx][ty]==HOGE){\n\t\t\t\t\t\t\t\t\tm[tx][ty]=4;\n\t\t\t\t\t\t\t\t\trep(o,4)if(!(tx+dx[o]>=0 && tx+dx[o]<w && ty+dy[o]>=0 && ty+dy[o]<h) || d[tx+dx[o]][ty+dy[o]]<=c[l])m[tx][ty]--;\n\t\t\t\t\t\t\t\t\tq.push(pii(tx,ty));\n\t\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tm[x][y]=4;\n\t\t\t\t\trep(o,4)if(!(x+dx[o]>=0 && x+dx[o]<w && y+dy[o]>=0 && y+dy[o]<h) || d[x+dx[o]][y+dy[o]]<=c[l])m[x][y]--;\n\t\t\t\t}\n\t\t\t\t//rep(i,h){rep(j,w)printf(\"%3d\",m[j][i]);puts(\"\");}\n\t\t\t\tcost[k].push_back(pii(cnt,c[l]));\n\t\t\t}\n\t\t}\n\t\tans=2000;\n\t\tint s0=cost[0].size(),s1=cost[1].size();\n//\t\trep(i,s1)printf(\"%d %d\\n\",cost[1][i].first,cost[1][i].second);\n//\t\trep(i,h){rep(j,w)printf(\"%3d\",m[j][i]);puts(\"\");}\n\t\trep(i,s0)rep(j,s1){\n\t\t\t//if(cost[0][i].first+cost[1][j].first>=r)ans=min(ans,cost[0][i].second+cost[1][j].second);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int>pii;\ntypedef pair<int,pii>piii;\nconst int dxy[5]={0,-1,0,1,0};\nint main(){\n    int r;\n    while(scanf(\"%d\",&r),r){\n        vector<pair<int,int> >ans[2];\n        for(int k=0;k<2;k++){\n            int w,h,sx,sy;\n            int fld[500][500];\n            vector<int>vec(1,0);\n            scanf(\"%d%d%d%d\",&w,&h,&sx,&sy);\n            sx--;sy--;\n            for(int i=0;i<h;i++){\n                for(int j=0;j<w;j++){\n                    int v;\n                    scanf(\"%d\",&v);\n                    fld[i][j]=v;\n                    vec.push_back(v);\n                }\n            }\n            sort(vec.begin(),vec.end());\n            vec.erase(unique(vec.begin(),vec.end()),vec.end());\n            priority_queue<piii,vector<piii>,greater<piii> >Q;\n            int pos=0,cnt=0;\n            Q.push(piii(1,pii(sy,sx)));\n            bool used[500][500]={{0}};\n            while(Q.size()){\n                int y=Q.top().second.first,x=Q.top().second.second;\n                int v=Q.top().first;\n                Q.pop();\n                if(used[y][x])continue;\n                if(v>vec[pos]){\n                    ans[k].push_back(pii(cnt,vec[pos]));\n                    pos++;\n                    Q.push(piii(v,pii(y,x)));\n                    continue;\n                }\n                used[y][x]=true;\n                cnt++;\n                for(int i=0;i<4;i++){\n                    int ty=y+dxy[i+1],tx=x+dxy[i];\n                    if(ty<0||ty>=h||tx<0||tx>=w)continue;\n                    Q.push(piii(fld[ty][tx],pii(ty,tx)));\n                }\n            }\n            ans[k].push_back(pii(cnt,vec[pos]));\n        }\n        //for(int k=0;k<2;k++)for(int i=0;i<ans[k].size();i++)printf(\"%d...%d:%d\\n\",k,ans[k][i].first,ans[k][i].second);\n\n        int Min=1e9;\n        for(int i=0;i<ans[0].size();i++){\n            int to=r-ans[0][i].first;\n            int lb=0,ub=ans[1].size();\n            while(ub-lb>1){\n                int mid=(ub+lb)/2;\n                if(ans[1][mid].first>to)ub=mid;\n                else lb=mid;\n            }\n            int value=ans[0][i].first+ans[1][ub-1].first;\n            if(value>=r){\n                Min=min(Min,ans[0][i].second+ans[1][ub-1].second);\n               //printf(\"%d:%d->%d\\n\",ans[0][i].second,ans[1][ub-1].second,value);\n            }\n        }\n        printf(\"%d\\n\",Min);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\n\nconst int INF=1000000000;\nconst long long int INF_=1000000000000000000;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\ninline bool IsIn(int y,int x,int h,int w){\n\treturn 0<=y&&y<h&&0<=x&&x<w;\n}\n\nvoid BFS(vector<vector<int> > &f,vector<vector<int> > &l,int sy,int sx,int h,int w){\n\tvector<vector<int> > done(h,vector<int>(w));\n\tvector<vector<int> > done_(h,vector<int>(w));\n\tl[sy][sx]=1;\n\tdone[sy][sx]=done_[sy][sx]=1;\n\tqueue<Pi> que;\n\tREP(i,0,4){\n\t\tint ny=sy+dy[i],nx=sx+dx[i];\n\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\tdone_[ny][nx]=1;\n\t\tque.push(Pi(ny,nx));\n\t}\n\twhile(!que.empty()){\n\t\tPi p=que.front();\n\t\tque.pop();\n\t\tdone[p.F_][p.S_]=1;\n\t\tbool flag=true;\n\t\tint tmp=INF;\n\t\tREP(i,0,4){\n\t\t\tint ny=p.F_+dy[i],nx=p.S_+dx[i];\n\t\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\t\tif(done[ny][nx]==1) tmp=min(tmp,l[ny][nx]);\n\t\t\tif(done[ny][nx]==1&&l[ny][nx]>=f[p.F_][p.S_]) flag=false;\n\t\t\tif(done_[ny][nx]!=1){\n\t\t\t\tdone_[ny][nx]=1;\n\t\t\t\tque.push(Pi(ny,nx));\n\t\t\t}\n\t\t}\n\t\tif(flag) l[p.F_][p.S_]=f[p.F_][p.S_];\n\t\telse {\n\t\t\tif(tmp!=INF) l[p.F_][p.S_]=max(tmp,f[p.F_][p.S_]);\n\t\t\telse l[p.F_][p.S_]=f[p.F_][p.S_];\n\t\t}\n\t}\n}\n\n\n\nvoid Djikstra(vector<vector<int> > &f,vector<vector<int> > &l,int sy,int sx,int h,int w){\n\tvector<vector<bool> > used(h,vector<bool>(w,false));\n\tREP(y,0,h) fill(l[y].begin(),l[y].end(),INF);\n\tl[sy][sx]=1;\n\twhile(true){\n\t\tPi v(-1,-1);\n\t\tREP(y,0,h){\n\t\t\tREP(x,0,w){\n\t\t\t\tif(!used[y][x]&&((v.F_==-1&&v.S_==-1)||l[y][x]<l[v.F_][v.S_])){\n\t\t\t\t\tv.F_=y;\n\t\t\t\t\tv.S_=x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(v.F_==-1&&v.S_==-1) break;\n\t\tused[v.F_][v.S_]=true;\n\t\tREP(i,0,4){\n\t\t\tint ny=v.F_+dy[i],nx=v.S_+dx[i];\n\t\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\t\tl[ny][nx]=min(l[ny][nx],max(f[ny][nx],l[v.F_][v.S_]));\n\t\t}\n\t}\n}\n\ninline int f(int x){\n\tif(x==0) return 1;\n\telse if(x==1) return 0;\n}\n\nvoid solve(){\n\tint R;\n\twhile(cin >> R&&R){\n\t\tint W[2],H[2],X[2],Y[2];\n\t\tvector<vector<int> > field[2];\n\t\tvector<vector<int> > level[2];\n\t\tint max_[2]={};\n\t\tREP(i,0,2){\n\t\t\tcin >> W[i] >> H[i] >> X[i] >> Y[i];\n\t\t\t--X[i]; --Y[i];\n\t\t\tfield[i].resize(H[i]);\n\t\t\tlevel[i].resize(H[i]);\n\t\t\tREP(j,0,H[i]){\n\t\t\t\tfield[i][j].resize(W[i]);\n\t\t\t\tlevel[i][j].resize(W[i]);\n\t\t\t}\n\t\t\tREP(y,0,H[i]) REP(x,0,W[i]){\n\t\t\t\tcin >> field[i][y][x];\n\t\t\t\tmax_[i]=max(max_[i],field[i][y][x]);\n\t\t\t}\n\t\t\tDjikstra(field[i],level[i],Y[i],X[i],H[i],W[i]);\n\t\t\t/*\n\t\t\tcout << endl << endl;\n\t\t\tREP(y,0,H[i]){\n\t\t\t\tREP(x,0,W[i]) cout << level[i][y][x] << ' ';\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\t/*\n\t\tvector<unsigned int> s[2];\n\t\tREP(i,0,2){\n\t\t\ts[i].resize(max_[i]+1);\n\t\t\tREP(y,0,H[i]) REP(x,0,W[i]) ++s[i][level[i][y][x]];\n\t\t\tREP(j,1,max_[i]+1) s[i][j]+=s[i][j-1];\n\t\t}\n\t\tint result=INF;\n\t\tREP(i,0,2){\n\t\t\tfor(int j=0; j<=max_[i]&&j<=result; ++j){\n\t\t\t\tint idx=(int)(lower_bound(s[i].begin(),s[i].end(),R-s[f(i)][j])-s[i].begin());\n\t\t\t\tif(!(0<=idx&&idx<=max_[i])) continue;\n\t\t\t\tresult=min(result,j+idx);\n\t\t\t}\n\t\t}\n\t\tcout << result << endl;\n\t\t*/\n\t\tmap<int,int> s[2];\n\t\tvector<int> idx[2],num[2];\n\t\tREP(i,0,2){\n\t\t\tREP(y,0,H[i]) REP(x,0,W[i]) ++s[i][level[i][y][x]];\n\t\t\tauto it=s[i].begin();\n\t\t\tidx[i].push_back(0);\n\t\t\tnum[i].push_back(0);\n\t\t\tidx[i].push_back(it->F_);\n\t\t\tnum[i].push_back(it->S_);\n\t\t\tauto prev=it;\n\t\t\t++it;\n\t\t\tfor(; it!=s[i].end(); ++it,++prev){\n\t\t\t\tit->S_+=prev->S_;\n\t\t\t\t//cout << it->F_ << ' ' << it->S_ << endl;\n\t\t\t\tidx[i].push_back(it->F_);\n\t\t\t\tnum[i].push_back(it->S_);\n\t\t\t}\n\t\t}\n\t\tint result=INF;\n\t\t/*\n\t\tcout << endl;\n\t\tREP(i,0,2) REP(j,0,idx[i].size()){\n\t\t\tcout << i << ' ' << idx[i][j] << ' ' << num[i][j] << endl;\n\t\t}\n\t\tcout << endl;\n\t\t*/\n\t\tREP(i,0,2) REP(j,0,idx[i].size()){\n\t\t\tint tmp=(int)(lower_bound(num[f(i)].begin(),num[f(i)].end(),R-num[i][j])-num[f(i)].begin());\n\t\t\t//cout << idx[i][tmp] << ' ' << num[i][tmp] << ' ' << idx[f(i)][j] << ' ' << num[f(i)][j] << endl;\n\t\t\tif(!(0<=tmp&&tmp<=idx[f(i)].size()-1)) continue;\n\t\t\tresult=min(result,idx[i][j]+idx[f(i)][tmp]);\n\t\t}\n\t\tcout << result << endl;\n\t}\n}\n\nint main(){\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<string>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define rep(i,x) for(int i = 0 ; i < x ; i ++)\n#define rep1(i,x) for(int i = 1 ; i <= x ; i ++)\n#define rrep(i,x) for(int i = x-1 ; i >= 0 ; i --)\n#define rrep1(i,x) for(int i = x ; i > 0 ; i --)\n#define sor(vec) sort(vec.begin(),vec.end())\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(min(a,b),c)\n#define max_3(a,b,c) max(max(a,b),c)\n#define mp1(a,b,c) P1(a,P(b,c))\n#define fr first\n#define sc second\n#define pb push_back\n\nconst int INF = 1000000000;\nconst int dir_4[4][2] = { {1,0} , {0,1} , {-1,0} , {0,-1} };\n\nint r;\nint w[2],h[2],x[2],y[2];\nint l[2][502][502];\n\nint a[502][502];\n\nint dfs(int X,int Y){\n\tif(a[X][Y] != 0)return 0;\n\ta[X][Y] = 1;\n\tint ret = 1;\n\trep(i,4){\n\t\tret += dfs(X+dir_4[i][0],Y+dir_4[i][1]);\n\t}\n\treturn ret;\n}\n\n/*int f(int t,int m){\n\trep(i,502){\n\t\trep(j,502){\n\t\t\ta[i][j] = 1;\n\t\t}\n\t}\n\trep1(i,h[t]){\n\t\trep1(j,w[t]){\n\t\t\tif(l[t][i][j] <= m)a[i][j] = 0;\n\t\t}\n\t}\n\treturn dfs(y[t],x[t]);\n}*/\n\nint C;\nbool comp(P1 a,P1 b){\n\tif(a.fr != b.fr)return a <= b;\n\tif(a.sc.fr == y[C] && a.sc.sc == x[C])return true;\n\tif(b.sc.fr == y[C] && b.sc.sc == x[C])return false;\n\treturn a <= b;\n}\n\nint main(){\n\tscanf(\"%d\",&r);\n\trep(i,2){\n\t\tscanf(\"%d%d%d%d\",&w[i],&h[i],&x[i],&y[i]);\n\t\trep1(j,h[i]){\n\t\t\trep1(k,w[i]){\n\t\t\t\tscanf(\"%d\",&l[i][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic int cost[2][250010];\n\tvector<P1> vec[2];\n\t\n\trep(k,2){\n\t\tvec[k].pb( mp1 ( 0 , -1 , -1 ) );\n\t\trep1(i,h[k]){\n\t\t\trep1(j,w[k]){\n\t\t\t\tvec[k].pb( mp1 ( l[k][i][j] , i , j ) );\n\t\t\t}\n\t\t}\n\t\tC = k;\n\t\tsort(vec[k].begin(),vec[k].end(),comp);\n\t\t\n\t\trep(i,502){\n\t\t\trep(j,502){\n\t\t\t\ta[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcost[k][0] = 0;\n\t\ta[y[k]][x[k]] = 1;\n\t\tcost[k][1] = 1;\n\t\t\n\t\tfor(int i = 2; i < vec[k].size() ; i ++){\n\t\t\tP p = vec[k][i].sc;\n\t\t\ta[p.fr][p.sc] = 0;\n\t\t\tcost[k][i] = cost[k][i-1];\n\t\t\tbool t = false;\n\t\t\trep(j,4){\n\t\t\t\tt |= (a[p.fr+dir_4[j][0]][p.sc+dir_4[j][1]] == 1);\n\t\t\t}\n\t\t\tif(t)cost[k][i] += dfs(p.fr,p.sc);\n\t\t}\n\t\t\n\t\t/*rep(i,vec[k].size()){\n\t\t\tprintf(\"%d %d\\n\",vec[k][i].fr,cost[k][i]);\n\t\t}*/\n\t}\n\t\n\tint ret = INF;\n\tint k = vec[1].size()-1;\n\trep(i,vec[0].size()){\n\t\twhile(k > 0 && cost[0][i] + cost[1][k-1] >= r)k --;\n\t\tif(cost[0][i] + cost[1][k-1] >= r){\n\t\t\tret = min ( ret , vec[0][i].fr + vec[1][k].fr );\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\",ret);\n\t\n\t/*int L = 0,R = 100000000;\n\twhile(L < R){\n\t\tint M = (L+R)/2;\n\t\tif(f(0,M)+f(1,M) < r)L = M+1;\n\t\telse R = M;\n\t}\n\t\n\tprintf(\"%d\\n\",L);*/\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define rep(i,n) for (int i=0;i<(int)n;++i)\n\nint dx[] ={0,1,0,-1};\nint dy[] = {1,0,-1,0};\nstruct P {\n  int d;\n  int x,y;\n  P(int d,int x,int y):d(d),x(x),y(y){}\n};\nbool operator<(const P &a, const P &b) {\n  return a.d > b.d;\n}\nint main() {\n  int r;\n  while(cin >> r, r) {\n    int w[2],h[2],sx[2],sy[2];\n    int ba[2][500][500];\n    rep(k,2) {\n      cin >> w[k]>>h[k]>>sx[k]>>sy[k];\n      sx[k]--;sy[k]--;\n      rep(y,h[k])\n        rep(x, w[k])\n        cin >> ba[k][x][y];\n    }\n    int table[2][250001];\n    rep(k,2) {\n      priority_queue<P> Q;\n      Q.push(P(1, sx[k], sy[k]));\n      bool visited[w[k]][h[k]];\n      memset(visited,0,sizeof(visited));\n      int nowd = 0;\n      int cnt = 0;\n      while(!Q.empty()) {\n        P p = Q.top();\n        int x = p.x;\n        int y = p.y;\n        Q.pop();\n        if (visited[x][y]) continue;\n        nowd = max(nowd, p.d);\n        table[k][++cnt] = nowd;\n        //      printf(\"%d,%d -> %d\\n\",k,cnt,nowd);\n        visited[x][y] = 1;\n        rep(i,4) {\n          int xx = x+dx[i];\n          int yy = y+dy[i];\n\n          if (xx<0||xx>=w[k]||yy<0||yy>=h[k]) continue;\n          if (visited[xx][yy]) continue;\n          Q.push(P(ba[k][xx][yy], xx, yy));\n        }\n      }\n    }\n    int res = 1<<29;\n    for (int i=0; i<=r; ++i) {\n      if (i>w[0]*h[0] || r-i>w[1]*h[1]) continue;\n      //  printf(\"%d->%d %d->%d\\n\", i,table[0][i], r-i,table[1][r-i]);\n      res = min(res, table[0][i]+table[1][r-i]);\n    }\n    cout << res << endl;\n  \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<string>\n#include<queue>\n#include<climits>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\n\nint vx[4]={0,1,0,-1};\nint vy[4]={1,0,-1,0};\n\nstruct pos{\n  pos(){};\n  pos(int cost,int kpos,int xpos,int ypos){\n    c=cost;\n    k=kpos;\n    x=xpos;\n    y=ypos;\n  }\n  int c,k,x,y;\n};\n\nbool operator<(const pos &a,const pos &b){\n  return a.c>b.c;\n}\n\nint r;\npair<int,int> el[2];\nvector< vector<int> > map[2];\nvector< vector<int> > used[2];\nvoid init(){\n  map[0].clear();\n  map[1].clear();\n  used[0].clear();\n  used[1].clear();\n}\n\nint input(){\n  cin>>r;\n  if(r==0)return 0;\n  int x,y;\n  cin>>x>>y;\n  cin>>el[0].second;\n  cin>>el[0].first;\n  el[0].first--;\n  el[0].second--;\n  map[0].resize(y);\n  used[0].resize(y);\n  for(int i=0;i<y;i++){\n    used[0][i].resize(x);\n    for(int j=0;j<x;j++){\n      int tmp;\n      cin>>tmp;\n      map[0][i].push_back(tmp);\n    }\n  }\n  cin>>x>>y;\n  cin>>el[1].second;\n  cin>>el[1].first;\n  el[1].first--;\n  el[1].second--;\n  map[1].resize(y);\n  used[1].resize(y);\n  for(int i=0;i<y;i++){\n    used[1][i].resize(x);\n    for(int j=0;j<x;j++){\n      int tmp;\n      cin>>tmp;\n      map[1][i].push_back(tmp);\n    }\n  }\n  return r;\n\n}\nvector< pair<int,int> > cost_room[2];\n\nint binary_serch(int n/*second*/,int begin,int end){\n  if(begin>=end){\n    return end; \n  }\n  //return first\n  int tmp=(begin+end)/2;\n  if(cost_room[1][tmp].second==n){\n    return tmp;\n  }else if(cost_room[1][tmp].second<n){\n    return binary_serch(n,tmp+1,end);\n  }else{\n    return binary_serch(n,begin,tmp-1);\n  }\n}\n\n\nint solve(){\n  \n  priority_queue<pos> q;\n  q.push(pos(map[0][el[0].first][el[0].second] , 0 , el[0].first , el[0].second));\n\n  cost_room[0].clear();\n  cost_room[1].clear();\n  pair<int,int> tmp_c;\n\n  tmp_c.first =0;\n  tmp_c.second=0;\n\n  while((!q.empty())){\n    pos tmp=q.top();q.pop();\n    if(tmp_c.first<tmp.c){\n      cost_room[tmp.k].push_back(tmp_c);\n      tmp_c.second++;\n      tmp_c.first=tmp.c;\n    }else if(tmp_c.first>=tmp.c && tmp.c!=0){\n      tmp_c.second++;\n    }\n\n    used[tmp.k][tmp.x][tmp.y]=true;\n    for(int i=0;i<4;i++){\n      if((!(tmp.x+vx[i]<0||used[tmp.k].size()-1<tmp.x+vx[i]))\n          &&(!(tmp.y+vy[i]<0||used[tmp.k][tmp.x+vx[i]].size()-1<tmp.y+vy[i]))\n          &&(!used[tmp.k][tmp.x+vx[i]][tmp.y+vy[i]])){\n        q.push(pos( map[tmp.k][tmp.x+vx[i]][tmp.y+vy[i]], tmp.k, tmp.x+vx[i],tmp.y+vy[i]));\n      }\n    }\n  }\n  cost_room[0].push_back(tmp_c);\n  \n  q.push(pos(map[1][el[1].first][el[1].second] , 1 , el[1].first , el[1].second));\n  tmp_c.first =0;\n  tmp_c.second=0;\n  while((!q.empty())){\n    pos tmp=q.top();q.pop();\n    if(used[tmp.k][tmp.x][tmp.y])continue; \n    if(tmp_c.first<tmp.c){\n      cost_room[tmp.k].push_back(tmp_c);\n      tmp_c.second++;\n      tmp_c.first=tmp.c;\n    }else if(tmp_c.first>=tmp.c && tmp.c!=0){\n      tmp_c.second++;\n    }\n\n    used[tmp.k][tmp.x][tmp.y]=true;\n    for(int i=0;i<4;i++){\n      if((!(tmp.x+vx[i]<0||used[tmp.k].size()-1<tmp.x+vx[i]))\n          &&(!(tmp.y+vy[i]<0||used[tmp.k][tmp.x+vx[i]].size()-1<tmp.y+vy[i]))\n          &&(!used[tmp.k][tmp.x+vx[i]][tmp.y+vy[i]])){\n        q.push(pos( map[tmp.k][tmp.x+vx[i]][tmp.y+vy[i]], tmp.k, tmp.x+vx[i],tmp.y+vy[i]));\n      }\n    }\n  }\n  cost_room[1].push_back(tmp_c);\n\n  sort(cost_room[0].begin(),cost_room[0].end());\n  sort(cost_room[1].begin(),cost_room[1].end());\n  \n\n  int res=INT_MAX;\n  for(int i=0;i<cost_room[0].size();i++){\n    res=min(cost_room[0][i].first+cost_room[1][binary_serch(r-cost_room[0][i].second,0,cost_room[1].size()-1)].first,res);\n  }\n  return res;\n}\n\n\n\nint main(){\n  while(init(),input()){\n    cout<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define INF 1145141919\ntypedef pair<int, int> P;\ntypedef pair<int, P> P2;\n\nint DX[4] = {-1, 0, 1, 0};\nint DY[4] = {0, -1, 0, 1};\n\nint R;\nint M[500][500];\nbool V[500][500];\n\nint main() {\n  while (cin >> R) {\n    if (R == 0) break;\n    vector<P> S[2];\n\n    for (int k=0; k<=1; k++) {\n      S[k%2].push_back(P(0, 0));\n\n      int w, h, x, y;\n      cin >> w >> h >> x >> y;\n      x--, y--;\n      for (int i=0; i<h; i++) {\n        for (int j=0; j<w; j++) {\n          cin >> M[j][i];\n        }\n      }\n      for (int i=0; i<w; i++) {\n        for (int j=0; j<h; j++) {\n          V[i][j] = false;\n        }\n      }\n      priority_queue< P2, vector<P2>, greater<P2> > q;\n      V[x][y] = true;\n      q.push(P2(M[x][y], P(x, y)));\n      int c = -1;\n\n      while (!q.empty()) {\n        int r = q.top().first,\n            sx = q.top().second.first,\n            sy = q.top().second.second; q.pop();\n        P last = S[k%2][S[k%2].size()-1];\n        if (c == r) {\n          S[k%2][S[k%2].size()-1] = P(last.first + 1, r);\n        }\n        else {\n          S[k%2].push_back(P(last.first + 1, r));\n          c = r;\n        }\n\n        for (int i=0; i<4; i++) {\n          int tx = sx + DX[i], ty = sy + DY[i];\n          if (tx < 0 || tx >= w || ty < 0 || ty >= h) continue;\n          int g = max(r, M[tx][ty]);\n          if (!V[tx][ty]) {\n            V[tx][ty] = true;\n            q.push(P2(g, P(tx, ty)));\n          }\n        }\n      }\n      S[k%2].push_back(P(INF, INF));\n    }\n    int m = INF;\n    for (auto x : S[0]) {\n      int r = max(0, R - x.first);\n      auto it = lower_bound(S[1].begin(), S[1].end(), P(r, 0));\n      P y = *it;\n      m = min(m, x.second + y.second);\n    }\n    cout << m << \"\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nvvint vv1;\nvvint vv2;\nvvint dp1;\nvvint dp2;\nint dd[]={1,0,-1,0,1};\nint w1,h1,x1,y1;\nint w2,h2,x2,y2;\nvoid foo1(int x,int y,int c){\n\tc=max(c,vv1[y][x]);\n\tif(dp1[y][x]<=c) return;\n\tdp1[y][x]=c;\n\trep(i,4){\n\t\tint yy=y+dd[i];\n\t\tint xx=x+dd[i+1];\n\t\tif(0<=xx&&xx<w1&&0<=yy&&yy<h1){\n\t\t\tfoo1(xx,yy,c);\n\t\t}\n\t}\n}\nvoid foo2(int x,int y,int c){\n\tc=max(c,vv2[y][x]);\n\tif(dp2[y][x]<=c) return;\n\tdp2[y][x]=c;\n\trep(i,4){\n\t\tint yy=y+dd[i];\n\t\tint xx=x+dd[i+1];\n\t\tif(0<=xx&&xx<w2&&0<=yy&&yy<h2){\n\t\t\tfoo2(xx,yy,c);\n\t\t}\n\t}\n}\nvoid mainmain(){\n\tint R;\n\twhile(cin>>R,R){\n\t\tmap<int,int> ma1;\n\t\tmap<int,int> ma2;\n\t\tcin>>w1>>h1>>x1>>y1;\n\t\tinitvv(vv1,h1,w1);\n\t\tinitvv(dp1,h1,w1,INF);\n\t\trep(i,h1){\n\t\t\trep(j,w1){\n\t\t\t\tcin>>vv1[i][j];\n\t\t\t}\n\t\t}\n\t\tcin>>w2>>h2>>x2>>y2;\n\t\tinitvv(vv2,h2,w2);\n\t\tinitvv(dp2,h2,w2,INF);\n\t\trep(i,h2){\n\t\t\trep(j,w2){\n\t\t\t\tcin>>vv2[i][j];\n\t\t\t}\n\t\t}\n\t\tpriority_queue<pair<int,pii>> pq1;\n\t\tpriority_queue<pair<int,pii>> pq2;\n\t\tpq1.push(mkp(-1,pii(y1-1,x1-1)));\n\t\tpq2.push(mkp(-1,pii(y2-1,x2-1)));\n\t\twhile(pq1.size()){\n\t\t\tpair<int,pii> top=pq1.top();\n\t\t\tpq1.pop();\n\t\t\tint yy=top.S.F;\n\t\t\tint xx=top.S.S;\n\t\t\ttop.F=min(top.F,-vv1[yy][xx]);\n\t\t\tif(dp1[yy][xx]!=INF){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdp1[yy][xx]=-top.F;\n\t\t\trep(i,4){\n\t\t\t\tint ny=yy+dd[i];\n\t\t\t\tint nx=xx+dd[i+1];\n\t\t\t\tif(0<=ny&&ny<h1&&0<=nx&&nx<w1){\n\t\t\t\t\tif(dp1[ny][nx]==INF){\n\t\t\t\t\t\tpq1.push(mkp(top.F,pii(ny,nx)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// rep(i,h1){\n\t\t\t// rep(j,w1){\n\t\t\t\t// cout<<dp1[i][j]<<\" \";\n\t\t\t// }\n\t\t\t// cout<<endl;\n\t\t// }\n\t\twhile(pq2.size()){\n\t\t\tpair<int,pii> top=pq2.top();\n\t\t\tpq2.pop();\n\t\t\tint yy=top.S.F;\n\t\t\tint xx=top.S.S;\n\t\t\ttop.F=min(top.F,-vv2[yy][xx]);\n\t\t\tif(dp2[yy][xx]!=INF){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdp2[yy][xx]=-top.F;\n\t\t\trep(i,4){\n\t\t\t\tint ny=yy+dd[i];\n\t\t\t\tint nx=xx+dd[i+1];\n\t\t\t\tif(0<=ny&&ny<h2&&0<=nx&&nx<w2){\n\t\t\t\t\tif(dp2[ny][nx]==INF){\n\t\t\t\t\t\tpq2.push(mkp(top.F,pii(ny,nx)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// foo1(x1-1,y1-1,1);\n\t\t// foo2(x2-1,y2-1,1);\n\t\trep(i,h1){\n\t\t\trep(j,w1){\n\t\t\t\tif(ma1.count(dp1[i][j])==0) ma1[dp1[i][j]]=0;\n\t\t\t\tma1[dp1[i][j]]++;\n\t\t\t}\n\t\t}\n\t\trep(i,h2){\n\t\t\trep(j,w2){\n\t\t\t\tif(ma2.count(dp2[i][j])==0) ma2[dp2[i][j]]=0;\n\t\t\t\tma2[dp2[i][j]]++;\n\t\t\t}\n\t\t}\n\t\tvector<pii> v1;\n\t\tvector<pii> v2;\n\t\tint t=0;\n\t\tv1.PB(pii(0,0));\n\t\tv2.PB(pii(0,0));\n\t\tfor(auto i:ma1){\n\t\t\tt+=i.S;\n\t\t\tv1.PB(pii(t,i.F));\n\t\t}\n\t\tt=0;\n\t\tfor(auto i:ma2){\n\t\t\tt+=i.S;\n\t\t\tv2.PB(pii(t,i.F));\n\t\t}\n\t\tint ans=INT_MAX;\n\t\trep(i,v1.size()){\n\t\t\tint tmp=v1[i].S;\n\t\t\tauto it=lower_bound(ALL(v2),pii(R-v1[i].F,0));\n\t\t\tif(it==v2.end()) continue;\n\t\t\tpii tt = *it;\n\t\t\t// cout<<v1[i].F<<\" \"<<v1[i].S<<\" \"<<tt.F<<\" \"<<tt.S<<endl;\n\t\t\tans=min(ans,tmp+tt.S);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,-1,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pint pair<int,int>\n#define tint tuple<int,int,int>\n#define INF 1<<29\n#define MAX 501\nusing namespace std;\n\nint R,W[2],H[2],X[2],Y[2],L[2][MAX][MAX],d[2][MAX][MAX],dd[4]={0,-1,0,1};\nmap<int,int> m[2];\nmap<int,int>::iterator ite;\n\nvoid solve(){\n for(;;){\n  cin>>R;\n  if(!R) return;\n  FOR(i,2){\n   cin>>W[i]>>H[i]>>X[i]>>Y[i];\n   X[i]--;\n   Y[i]--;\n   FOR(j,H[i]) FOR(k,W[i]) cin>>L[i][j][k];\n   FOR(j,H[i]) FOR(k,W[i]) d[i][j][k]=INT_MAX/3;\n   d[i][X[i]][Y[i]]=1;\n   priority_queue<pint,vector<pint>,greater<pint>> pque;\n   pque.push(mp(1,X[i]*W[i]+Y[i]));\n   while(!pque.empty()){\n    pint p=pque.top(); pque.pop();\n    int x=p.second/W[i],y=p.second-x*W[i];\n    if(d[i][x][y]<p.first) continue;\n    FOR(j,4){\n     int nx=x+dd[j],ny=y+dd[j^1];\n     if(nx<0||ny<0||nx>=H[i]||ny>=W[i]) continue;\n     if(d[i][nx][ny]>max(d[i][x][y],L[i][nx][ny])){\n      d[i][nx][ny]=max(d[i][x][y],L[i][nx][ny]);\n      pque.push(mp(d[i][nx][ny],nx*W[i]+ny));\n     }\n    }\n   }\n   FOR(j,H[i]) FOR(k,W[i]) m[i][d[i][j][k]]++;\n   for(ite=m[i].begin();ite!=m[i].end();ite++){\n    if(ite==m[i].begin()) continue;\n    ite->second+=(--ite)->second;\n    ite++;\n   }\n  }\n  int mi=min(m[0].lower_bound(R)->first,m[1].lower_bound(R)->first);\n  for(ite=m[0].begin();ite!=m[0].end();ite++){\n   mi=min(mi,(ite->first)+(m[1].lower_bound(R-(ite->second))->first));\n  }\n  cout<<mi<<endl;\n  FOR(i,2) m[i].clear();\n }\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long R, W, H, X, Y, i, j, L[500][500], O, T, a, b;\nlong long m[5] = {1, 0, -1, 0, 1};\nbool u[500][500], v[500][500];\nvector<long long> d1, d2;\ntuple<long long, long long, long long> t;\npriority_queue<tuple<long long, long long, long long>, vector<tuple<long long, long long, long long> >, greater<tuple<long long, long long, long long> > > q;\n\nint main(){\n  scanf(\"%lld\", &R);\n  scanf(\"%lld%lld%lld%lld\", &W, &H, &X, &Y);\n  for(i = 0; i < H; ++i){\n    for(j = 0; j < W; ++j){\n      scanf(\"%lld\", L[j] + i);\n    }\n  }\n  d1.push_back(0);\n  d2.push_back(0);\n  q.push(make_tuple(1, X - 1, Y - 1));\n  u[X - 1][Y - 1] = true;\n  while(!q.empty()){\n    t = q.top();\n    q.pop();\n    tie(O, a, b) = t;\n    d1.push_back(O);\n    //cout << O << endl;\n    for(i = 0; i < 4; ++i){\n      if(0 <= a + m[i] && a + m[i] < W && 0 <= b + m[i + 1] && b + m[i + 1] < H && !u[a + m[i]][b + m[i + 1]]){\n        //cout << L[a + m[i]][b + m[i + 1]] << \" \" << a + m[i] << \" \" << b + m[i + 1] << endl;\n\tu[a + m[i]][b + m[i + 1]] = true;\n\tq.push(make_tuple(max(O, L[a + m[i]][b + m[i + 1]]), a + m[i], b + m[i + 1]));\n      }\n    }\n  }\n  O = W * H + 1;\n  scanf(\"%lld%lld%lld%lld\", &W, &H, &X, &Y);\n  for(i = 0; i < H; ++i){\n    for(j = 0; j < W; ++j){\n      scanf(\"%lld\", L[j] + i);\n    }\n  }\n  q.push(make_tuple(1, X - 1, Y - 1));\n  v[X - 1][Y - 1] = true;\n  while(!q.empty()){\n    t = q.top();\n    q.pop();\n    tie(T, a, b) = t;\n    d2.push_back(T);\n    for(i = 0; i < 4; ++i){\n      if(0 <= a + m[i] && a + m[i] < W && 0 <= b + m[i + 1] && b + m[i + 1] < H && !v[a + m[i]][b + m[i + 1]]){\n\t//cout << a + m[i] << \" \" << b + m[i + 1] << endl;\n\tv[a + m[i]][b + m[i + 1]] = true;\n\tq.push(make_tuple(max(T, L[a + m[i]][b + m[i + 1]]), a + m[i], b + m[i + 1]));\n      }\n    }\n  }\n  T = W * H + 1;\n  a = 1099511627775LL;\n  /*for(i = 0, j = O; i < j; ++i){\n    cout << d1[i] << \" \";\n  }\n  cout << endl;\n  for(i = 0, j = T; i < j; ++i){\n    cout << d2[i] << \" \";\n  }\n  cout << endl;*/\n  for(i = max(0LL, R - T + 1), j = min(R, O) + 1; i < j; ++i){\n    //cout << i << \" \" << R - i << endl;\n    a = min(a, d1[i] + d2[R - i]);\n  }\n  cout << a << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nint w[2], h[2], l[2][500][500], sx[2], sy[2], r;\nint dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nint ans[2][100001], d[2500];\nbool vis[500][500], used[500][500];\ndeque<P>que[2500];\nint compress(int k) {\n\tvector<int>x;\n\trep(i, h[k])rep(j, w[k])x.push_back(l[k][i][j]);\n\tsort(x.begin(), x.end());\n\tx.erase(unique(x.begin(), x.end()), x.end());\n\trep(i, x.size())d[i] = x[i];\n\trep(i, h[k])rep(j, w[k])\n\t\tl[k][i][j] = lower_bound(x.begin(), x.end(), l[k][i][j]) - x.begin();\n\treturn x.size();\n}\nvoid solve(int k) {\n\tans[k][0] = 0;\n\tqueue<P>Q;\n\tint n = compress(k);\n\trep(i, n)que[i].clear();\n\tmemset(vis, 0, sizeof(vis));\n\tmemset(used, 0, sizeof(used));\n\tQ.push(P(sx[k], sy[k]));\n\tvis[sx[k]][sy[k]] = true;\n\tint cnt = 0, Max = 0;\n\twhile (1) {\n\t\twhile (!Q.empty()) {\n\t\t\tP p = Q.front(); Q.pop();\n\t\t\tif (used[p.first][p.second])continue;\n\t\t\tused[p.first][p.second] = true;\n\t\t\tcnt++; if (cnt >= r)break;\n\t\t\trep(i, 4) {\n\t\t\t\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\tif (0 <= nx&&nx < h[k] && 0 <= ny&&ny < w[k] && !vis[nx][ny]) {\n\t\t\t\t\tvis[nx][ny] = true;\n\t\t\t\t\tif (l[k][nx][ny] <= Max)Q.push(P(nx, ny));\n\t\t\t\t\telse que[l[k][nx][ny]].push_back(P(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans[k][cnt] = min(ans[k][cnt], d[Max]);\n\t\trep(i, n) {\n\t\t\tif (!que[i].empty()) {\n\t\t\t\tMax = i;\n\t\t\t\tfor (P p : que[i])Q.push(p);\n\t\t\t\tque[i].clear();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (cnt >= r || Q.empty())break;\n\t}\n\tfor (int i = r - 1; i >= 1; i--)ans[k][i] = min(ans[k][i], ans[k][i + 1]);\n}\nint main() {\n\twhile (scanf(\"%d\", &r), r) {\n\t\trep(k, 2) {\n\t\t\tscanf(\"%d%d%d%d\", &w[k], &h[k], &sy[k], &sx[k]); sx[k]--; sy[k]--;\n\t\t\trep(i, h[k])rep(j, w[k])scanf(\"%d\", &l[k][i][j]);\n\t\t}\n\t\tfill(ans[0], ans[2], INT_MAX);\n\t\trep(k, 2)solve(k);\n\t\tint Min = INT_MAX;\n\t\tfor (int i = 0; i <= r; i++) {\n\t\t\tif (ans[0][i] == INT_MAX || ans[1][r - i] == INT_MAX)continue;\n\t\t\tMin = min(Min, ans[0][i] + ans[1][r - i]);\n\t\t}\n\t\tprintf(\"%d\\n\", Min);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<deque>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#define fir first\n#define sec second\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\nusing namespace std;\ntypedef long long int llint;\nconst llint one = 1;\nconst llint big = (one<<30);\nvoid solve(int R,int ans[]){\n\tint W,H,X,Y,i,j,a,x,y,l;\n\ttuple<int,int,int> t;\n\tvector<vector<int>> lev;\n\tvector<vector<int>> floa;//false->????????¢?´¢???????????????true ?????\\?????????\n\tpriority_queue<tuple<int,int,int>,vector<tuple<int,int,int>>,greater<tuple<int,int,int>>> que;//???????????????\n\tscanf(\"%d %d %d %d\",&W,&H,&X,&Y);\n\tlev.resize(H+2);\n\tfloa.resize(H+2);\n\tfor(i=0;i<H+2;i++){ lev[i].resize(W+2);floa[i].resize(W+2); }\n\tfor(i=0;i<H+2;i++){\n\t\tfor(j=0;j<W+2;j++){\n\t\t\tfloa[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<W+2;i++){ lev[0][i]=big; }\n\tfor(i=1;i<H+1;i++){\n\t\tlev[i][0]=big;\n\t\tfor(j=1;j<W+1;j++){ scanf(\"%d\",&a);lev[i][j]=a; }\n\t\tlev[i][W+1]=big;\n\t}\n\tfor(i=0;i<W+2;i++){ lev[H+1][i]=big; }\n\tque.push(mt(1,Y,X));floa[Y][X]=1;\n\tif(R>W*H){\n\t\tfor(i=W*H+1;i<=R;i++){\n\t\t\tans[i]=big;\n\t\t}\n\t\tR=W*H;\n\t}\n\tfor(i=1;i<=R;i++){\n\t\tt=que.top();\n\t\tl=get<0>(t);\n\t\ty=get<1>(t);\n\t\tx=get<2>(t);\n\t\tque.pop();\n\t\tif(floa[y+1][x]==0){ floa[y+1][x]=1;que.push(mt(lev[y+1][x],y+1,x)); }\n\t\tif(floa[y-1][x]==0){ floa[y-1][x]=1;que.push(mt(lev[y-1][x],y-1,x)); }\n\t\tif(floa[y][x+1]==0){ floa[y][x+1]=1;que.push(mt(lev[y][x+1],y,x+1)); }\n\t\tif(floa[y][x-1]==0){ floa[y][x-1]=1;que.push(mt(lev[y][x-1],y,x-1)); }\n\t\tans[i]=max(l,ans[i-1]);\n\t}\n\treturn;\n}\nbool Q(void){\n\tint ans=big,i,R;\n\tstatic int keia[100001]={0};//1????????????????????§i????¨?????????????????????????????¨???¬??????\n\tstatic int keib[100001]={0};//2???)ry\n\tscanf(\"%d\",&R);\n\tif(R==0){\n\t\treturn false;\n\t}\n\tsolve(R,keia);\n\tsolve(R,keib);\n\tfor(i=0;i<=R;i++){\n\t\tans=min(ans,keia[i]+keib[R-i]);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn true;\n}\nint main(void){while(Q()){}return 0;}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, -1, 0, 1};\n\nconst int INF = (int)1e9;\n\ninline vector<pii> func(){\n\tint w, h, x, y;\n\tscanf(\"%d%d%d%d\", &w, &h, &x, &y);\n\t\n\tvector<vector<int> > L(w + 2, vector<int>(h + 2, -1));\n\tvector<int> Ls;\n\tLs.reserve(w * h + 2);\n\tLs.push_back(0);\n\tLs.push_back(INF);\n\t\n\tfor(int i = 1; i <= h; ++i)\n\tfor(int j = 1; j <= w; ++j){\n\t\tscanf(\"%d\", &L[j][i]);\n\t\tLs.push_back(L[j][i]);\n\t}\n\t\n\tsort(Ls.begin(), Ls.end());\n\tLs.erase(unique(Ls.begin(), Ls.end()), Ls.end());\n\t\n\tvector<pii> c(Ls.size());\n\tfor(int i = 0; i < Ls.size(); ++i){\n\t\tc[i].second = Ls[i];\n\t}\n\n\tpriority_queue<pii,vector<pii>,greater<pii> > pq;\n\tpq.push( pii(1, x << 16 | y) );\n\tL[x][y] = -1;\n\t\n\twhile( !pq.empty() ){\n\t\tqueue<int> q;\n\t\tq.push(pq.top().second);\n\t\tint u = pq.top().first;\n\t\tpq.pop();\n\n\t\tint k = lower_bound(Ls.begin(), Ls.end(), u) - Ls.begin();\n\t\t++c[k].first;\n\n\t\twhile( !q.empty() ){\n\t\t\tfor(int i = 0; i < 4; ++i){\n\t\t\t\tx = (q.front() >> 16) + dx[i];\n\t\t\t\ty = (q.front() & 0xff) + dy[i];\n\n\t\t\t\tif( L[x][y] > 0 ){\n\t\t\t\t\tif( L[x][y] <= u ){\n\t\t\t\t\t\tL[x][y] = -1;\n\t\t\t\t\t\t++c[k].first;\n\t\t\t\t\t\tq.push(x << 16 | y);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tpq.push( pii(L[x][y], x << 16 | y) );\n\t\t\t\t\t\tL[x][y] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tq.pop();\n\t\t}\n\t}\n\t\n\tfor(int i = 2; i < c.size(); ++i){\n\t\tc[i].first += c[i - 1].first;\n\t}\n\tc.back().first = INF;\n\t\n\treturn c;\n}\n\nint main(){\n\tint R;\n\twhile( scanf(\"%d\", &R), R != 0 ){\n\t\tvector<pii> t1 = func();\n\t\tvector<pii> t2 = func();\n\n\t\tint ans = INF;\n\t\tfor(int i = 0; i + 1 < t1.size(); ++i){\n\t\t\tint a = t1[i].second;\n\t\t\tpii p = pii(R - t1[i].first, -1);\n\t\t\tint b = lower_bound(t2.begin(), t2.end(), p)->second;\n\t\t\tans = min(ans, a + b);\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nconst int N = 500;\nconst int INF = 1000000000;\n\nint R, w[2], h[2], sx[2], sy[2], input[2][N][N], vis[N][N];\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nvector<int> vec[2];\nset<int> data;\n\nvoid dfs(int x, int y, int cost, int d){\n  vis[y][x] = cost;\n  for(int i=0;i<4;i++){\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if(ny < 0 || ny >= h[d]) continue;\n    if(nx < 0 || nx >= w[d]) continue;\n    if(vis[ny][nx] > max(cost, input[d][ny][nx])) dfs(nx, ny, max(cost, input[d][ny][nx]), d);\n  }\n}\n\nvoid init(){\n  data.clear();\n  for(int k=0;k<2;k++){\n    for(int i=0;i<h[k];i++){\n      for(int j=0;j<w[k];j++){\n        data.insert(input[k][i][j]);\n      }\n    }\n  }\n  for(int k=0;k<2;k++){\n    fill(vis[0], vis[N], INF);\n    dfs(sx[k], sy[k], 1, k);\n    vec[k].clear();\n    for(int i=0;i<h[k];i++){\n      for(int j=0;j<w[k];j++){\n        vec[k].push_back(vis[i][j]);\n      }\n    }\n    sort(vec[k].begin(), vec[k].end());\n  }\n}\n\nint solve(){\n  int l = 0, r = 100000000;\n  while(l<r){\n    int m = (l + r) / 2;\n    bool f = false;\n    for(set<int>::iterator ite=data.begin();ite!=data.end();ite++){\n      if(*ite > m) break;\n      int a = distance(vec[0].begin(), upper_bound(vec[0].begin(), vec[0].end(), *ite));\n      int b = distance(vec[1].begin(), upper_bound(vec[1].begin(), vec[1].end(), m-(*ite)));\n      if(a + b >= R) f = true;\n    }\n    if(f) r = m;\n    else l = m + 1;\n  }\n  return l;\n}\n\nmain(){\n  while(cin >> R && R){\n    for(int k=0;k<2;k++){\n      cin >> w[k] >> h[k] >> sx[k] >> sy[k];\n      sx[k]--; sy[k]--;\n      for(int i=0;i<h[k];i++){\n        for(int j=0;j<w[k];j++){\n          cin >> input[k][i][j];\n        }\n      }\n    }\n    init();\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,-1,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pint pair<int,int>\n#define tint tuple<int,int,int>\n#define INF 1<<29\n#define MAX 501\nusing namespace std;\n\nint R,W[2],H[2],X[2],Y[2],L[2][MAX][MAX],d[2][MAX][MAX],dd[4]={0,-1,0,1};\nmap<int,int> m[2];\nmap<int,int>::itelator ite;\n\nvoid solve(){\n for(;;){\n  cin>>R;\n  if(!R) return;\n  FOR(i,2){\n   cin>>W[i]>>H[i]>>X[i]>>Y[i];\n   X[i]--;\n   Y[i]--;\n   FOR(j,H[i]) FOR(k,W[i]) cin>>L[i][j][k];\n   FOR(j,H[i]) FOR(k,W[i]) d[i][j][k]=INT_MAX/3;\n   d[i][X[i]][Y[i]]=1;\n   priority_queue<pint,vector<pint>,greater<pint>> pque;\n   que.push(mp(1,X[i]*W[i]+Y[i]));\n   while(!que.empty()){\n    pint p=pque.top(); pque.pop();\n    int x=p.second/W[i],y=p.second-x*W[i];\n    if(d[i][x][y]<p.first) continue;\n    FOR(j,4){\n     int nx=x+dd[j],ny=y+dd[j^1];\n     if(nx<0||ny<0||nx>=H[i]||ny>=W[i]) continue;\n     if(d[i][nx][ny]>max(d[i][x][y],L[i][x][y])){\n      d[i][nx][ny]=max(d[i][x][y],L[i][x][y]);\n      pque.push(mp(d[i][nx][ny],nx*W[i]+ny));\n     }\n    }\n   }\n   FOR(j,H[i]) FOR(k,W[i]) m[i][d[i][j][k]]++;\n   for(ite=m[i].begin()+1;ite!=m[i].end();ite++){\n    m[i][ite->first]+=m[i][(ite-1)->first];\n   }\n  }\n  int mi=m[1].lower_bound(R)->first;\n  for(ite=m[0].begin();ite!=m[0].end();ite++){\n   mi=min(mi,(ite->first)+(m[1].lower_bound(R-(ite->second))->first));\n  }\n  cout<<mi<<endl;\n  FOR(i,2) map[i].clear();\n }\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pint;\ntypedef pair<ll, int> P;\n//typedef tuple<int,int,int> T;\nll INFL = 1000000000000000010;//10^18 = 2^60\nint INF = 2147483600;//10^9\nll MOD  = 1000000007;\nvector<int> dy(4);\nvector<int> dx(4);\nvector<ll> Ans(0);\nint solve(){\n    int R;\n    cin >> R;\n    if(R == 0)return 0;\n    int H1,W1,X1,Y1;\n    cin >> W1 >> H1 >> X1 >> Y1;\n    X1--;\n    Y1--;\n    vector<vector<ll> > mp1(H1, vector<ll>(W1));\n    vector<vector<ll> > d1(H1, vector<ll>(W1, INFL));\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            cin >> mp1[i][j];\n        }\n    }\n    \n    d1[Y1][X1] = 1;\n    priority_queue<pair<ll, pair<int, int> > > pque1;\n    pque1.push({1, {Y1, X1}});\n    \n    while(!pque1.empty()){\n        ll c;\n        int y,x;\n        c = pque1.top().first;\n        y = pque1.top().second.first;\n        x = pque1.top().second.second;\n        pque1.pop();\n        if(c > d1[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H1 && 0 <= nx && nx < W1){\n                if(d1[ny][nx] > d1[y][x]){\n                    if(d1[y][x] > mp1[ny][nx]){\n                        d1[ny][nx] = d1[y][x];\n                    }else{\n                        d1[ny][nx] = mp1[ny][nx];\n                    }\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }else if(d1[ny][nx] > d1[y][x]){\n                    d1[ny][nx] = mp1[ny][nx];\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    int H2,W2,X2,Y2;\n    cin >> W2 >> H2 >> X2 >> Y2;\n    X2--;\n    Y2--;\n    vector<vector<ll> > mp2(H2, vector<ll>(W2));\n    vector<vector<ll> > d2(H2, vector<ll>(W2, INFL));\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            cin >> mp2[i][j];\n        }\n    }\n    \n    d2[Y2][X2] = 1;\n    priority_queue<pair<ll, pair<int, int> > > pque2;\n    pque2.push({1, {Y2, X2}});\n    \n    while(!pque2.empty()){\n        ll c;\n        int y,x;\n        c = pque2.top().first;\n        y = pque2.top().second.first;\n        x = pque2.top().second.second;\n        pque2.pop();\n        if(c > d2[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H2 && 0 <= nx && nx < W2){\n                if(d2[ny][nx] > d2[y][x]){\n                    if(d2[y][x] > mp2[ny][nx]){\n                        d2[ny][nx] = d2[y][x];\n                    }else{\n                        d2[ny][nx] = mp2[ny][nx];\n                    }\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }else if(d2[ny][nx] > d2[y][x]){\n                    d2[ny][nx] = mp2[ny][nx];\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    vector<pair<ll,int> > O1(0);\n    vector<ll> COST1(0);\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            COST1.push_back(d1[i][j]);\n        }\n    }\n    sort(COST1.begin(), COST1.end());\n    COST1.push_back(INFL);\n    ll ad1 = COST1.at(0);\n    int cnt = 0;\n    for(int i = 0; i < COST1.size(); i++){\n        if(ad1 == COST1.at(i)){\n            cnt++;\n        }else{\n            O1.push_back({ad1, cnt});\n            ad1 = COST1.at(i);\n            cnt++;\n        }\n    }\n    \n    vector<pair<ll,int> > O2(1);\n    O2.at(0).first = 0;\n    O2.at(0).second = 0;\n    vector<ll> COST2(0);\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            COST2.push_back(d2[i][j]);\n        }\n    }\n    sort(COST2.begin(), COST2.end());\n    COST2.push_back(INFL);\n    ll ad2 = COST2.at(0);\n    cnt = 0;\n    for(int i = 0; i < COST2.size(); i++){\n        if(ad2 == COST2.at(i)){\n            cnt++;\n        }else{\n            O2.push_back({ad2, cnt});\n            ad2 = COST2.at(i);\n            cnt++;\n        }\n    }\n    \n    \n    ll ans = INFL;\n    int right = -1;\n    for(int i = 0; i < O1.size(); i++){\n        ll cost = O1.at(i).first;\n        int rest = R - O1.at(i).second;\n        \n        if(rest > O2.at(O2.size()-1).second) continue;\n        int left = -1;\n        if(right == -1){\n            right = O2.size();\n        }\n        int mid;\n        while(right - left > 1){\n            mid = (left + right) / 2;\n            if(O2.at(mid).second >= rest){\n                right = mid;\n            }else{\n                left = mid;\n            }\n        }\n        cost += O2.at(right).first;\n        ans = min(ans, cost);\n    }\n    \n    Ans.push_back(ans);\n    solve();\n    return 0;\n}\n\nint main(void){\n    dy[0] = 1;\n    dy[1] = -1;\n    dx[2] = 1;\n    dx[3] = -1;\n    solve();\n    for(int i = 0; i < Ans.size(); i++){\n        cout << Ans.at(i) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cstring>\nusing namespace std;\n#define inRange(x,a,b) (a <= x && x < b)\nint di[4] = {-1, 1, 0, 0};\nint dj[4] = {0, 0, -1, 1};\n\nint room[2][500][500];\nbool visit[2][500][500];\n\nint main(){\n    int r;\n    while(cin >> r, r){\n        int w[2], h[2], x[2], y[2];\n        memset(room, 0, sizeof(room));\n        memset(visit, 0, sizeof(visit));\n        for(int s = 0; s < 2; s++){\n            cin >> w[s] >> h[s] >> x[s] >> y[s];\n            x[s]--, y[s]--;\n            for(int i = 0; i < h[s]; i++){\n                for(int j = 0; j < w[s]; j++){\n                    cin >> room[s][i][j];\n                }\n            }\n        }\n        map<int,int> m[2], n[2];\n        for(int s = 0; s < 2; s++){\n            int tmplevel = 0;\n            priority_queue<pair<int,pair<int,int>>> pq;\n            pq.push({-room[s][y[s]][x[s]], {y[s], x[s]}});\n            visit[s][y[s]][x[s]] = true;\n            int cnt = 0;\n            while(!pq.empty()){\n                auto p = pq.top();  pq.pop();\n                int val = -p.first, i = p.second.first, j = p.second.second;\n                tmplevel = max(tmplevel, val);\n                m[s][tmplevel] = ++cnt;\n                for(int k = 0; k < 4; k++){\n                    int ni = i + di[k], nj = j + dj[k];\n                    if(inRange(ni, 0, h[s]) && inRange(nj, 0, w[s]) && !visit[s][ni][nj]){\n                        visit[s][ni][nj] = true;\n                        pq.push({-room[s][ni][nj], {ni, nj}});\n                    }\n                }\n            }\n            for(auto p : m[s]){\n                n[s][p.second] = p.first;\n            }\n            n[s][0] = 0;   // sentinel\n        }\n        int ans = 1<<30;\n        for(auto p : n[0]){\n            int residual = r-p.first;\n            auto it = n[1].lower_bound(residual);\n            if(it != n[1].end()){\n                ans = min(ans, p.second + n[1].lower_bound(residual)->second);\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// vvvvvvvvvvvv TEMPLATE vvvvvvvvvvvv\n#include <bits/stdc++.h>\nusing namespace std; using ll = long long; using P = pair<ll, ll>;\nconst ll linf = 1e18; const double eps = 1e-12, pi = acos(-1);\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define each(i,a) for (auto&& i : a)\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define eb emplace_back\n#define all(a) begin(a),end(a)\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\ntemplate<typename T> ll min(ll a, const T&& b) { return a < b ? a : b; }\ntemplate<typename T> ll min(const T&& a, ll b) { return a < b ? a : b; }\ntemplate<typename T> ll max(ll a, const T&& b) { return a > b ? a : b; }\ntemplate<typename T> ll max(const T&& a, ll b) { return a > b ? a : b; }\ntemplate<typename Head> void out(Head h) { cout << h << endl; } template<typename Head, typename... Tail>void out(Head h, Tail... t) { cout << h << \" \"; out(t...); }\ntemplate<typename T> istream& operator>>(istream& is, vector<T>& v) { each(x,v) is >> x; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) { rep(i,v.size()) { if (i) os << \" \"; os << v[i]; } return os; }\nostream& operator<<(ostream& os, const vector<string>& v) { rep(i,v.size()) { if (i) os << endl; os << v[i]; } return os; }\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<vector<T>>& v) { rep(i,v.size()) { if (i) os << endl; os << v[i]; } return os; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\nstruct yes_no : std::numpunct<char> { string_type do_truename() const { return \"Yes\"; } string_type do_falsename() const { return \"No\"; } };\nvoid solve(); int main() {\n  ios::sync_with_stdio(false); cin.tie(0); locale loc(locale(), new yes_no); cout.imbue(loc); cout << fixed << setprecision(10) << boolalpha;\n  solve();\n}\n// ^^^^^^^^^^^^ TEMPLATE ^^^^^^^^^^^^\n\nclass UnionFind {\n  vector<ll> par, h, sz;\npublic:\n  UnionFind(ll size) : par(size, 0), h(size, 0), sz(size, 1) {\n    rep(i, size) par[i] = i;\n  }\n  void unite(ll u, ll v) {\n    u = root(u), v = root(v);\n    if (u == v) return;\n    if (h[u] < h[v]) {\n      par[u] = v;\n      sz[v] += sz[u];\n    }\n    else {\n      par[v] = u;\n      sz[u] += sz[v];\n    }\n    if (h[u] == h[v]) ++h[u];\n  }\n  ll size(ll v) {\n    return sz[root(v)];\n  }\n  bool isUnited(ll u, ll v) {\n    return root(u) == root(v);\n  }\n  ll root(ll v) {\n    if (par[v] == v) return v;\n    return par[v] = root(par[v]);\n  }\n};\n\nll dx[] = {1, 0, -1, 0};\nll dy[] = {0, 1, 0, -1};\n\n#define NODE(x, y) ((y) * w + (x))\n\nvector<ll> f(ll R) {\n  ll w, h, sx, sy; cin >> w >> h >> sx >> sy; --sx, --sy;\n  vector<vector<ll>> a(h, vector<ll>(w));\n  map<ll, vector<P>> m;\n  rep(y, h) rep(x, w) {\n    cin >> a[y][x];\n    m[a[y][x]].eb(x, y);\n  }\n  UnionFind uf(h*w);\n  vector<ll> res(R+1, linf);\n  res[0] = 0;\n  each(pp, m) {\n    each(p, pp.second) {\n      ll x, y; tie(x, y) = p;\n      rep(d, 4) {\n        ll nx = x + dx[d];\n        ll ny = y + dy[d];\n        if (0 <= nx && nx < w && 0 <= ny && ny < h && a[ny][nx] <= a[y][x]) {\n          uf.unite(NODE(x, y), NODE(nx, ny));\n        }\n      }\n    }\n    ll sz = uf.size(NODE(sx, sy));\n    chmin(res[min(R, sz)], pp.first);\n  }\n  rrep(i, R) chmin(res[i], res[i+1]);\n  return res;\n}\n\nll solve(ll R) {\n  vector<ll> dp1 = f(R);\n  vector<ll> dp2 = f(R);\n  ll ans = linf;\n  rep(i, R+1) {\n    chmin(ans, dp1[i] + dp2[R-i]);\n  }\n  return ans;\n}\n\nvoid solve() {\n  ll R;\n  while (cin >> R, R) {\n    cout << solve(R) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\nconst int N = 500;\nconst int INF = 1000000000;\n\nclass S{\npublic:\n  int x, y, cost;\n  S(){}\n  S(int x, int y, int cost) : x(x), y(y), cost(cost) {}\n  bool operator < (const S& s) const {\n    return cost > s.cost;\n  }\n};\n\nint R, w[2], h[2], sx[2], sy[2], input[2][N][N], vis[N][N];\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nvector<int> vec[2];\nset<int> used;\nvector<int> data;\nint cnt;\n\n/*void dfs(int x, int y, int cost, int d){\n  vis[y][x] = true;\n  cnt++;\n  for(int i=0;i<4;i++){\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if(ny < 0 || ny >= h[d]) continue;\n    if(nx < 0 || nx >= w[d]) continue;\n    if(input[d][ny][nx] > cost) continue;\n    if(!vis[ny][nx]) dfs(nx, ny, cost, d);\n  }\n  }*/\n\nvoid bfs(int d){\n  int x = sx[d];\n  int y = sy[d];\n  int cost = 1;\n  priority_queue<S> q;\n  S u;\n  q.push(S(x, y, cost));\n  vis[y][x] = cost;\n  while(!q.empty()){\n    u = q.top(); q.pop();\n    if(vis[u.y][u.x] < u.cost) continue;\n    for(int i=0;i<4;i++){\n      int ny = u.y + dy[i];\n      int nx = u.x + dx[i];\n      if(ny < 0 || ny >= h[d]) continue;\n      if(nx < 0 || nx >= w[d]) continue;\n      int tmp = max(u.cost, input[d][ny][nx]);\n      if(vis[ny][nx] > tmp){\n        vis[ny][nx] = tmp;\n        q.push(S(nx, ny, tmp));\n      }\n    }\n  }\n}\n\nvoid init(){\n  //used.clear();\n  data.clear();\n  for(int k=0;k<2;k++){\n    for(int i=0;i<h[k];i++){\n      for(int j=0;j<w[k];j++){\n        /*if(!used.count(input[k][i][j])){\n          used.insert(input[k][i][j]);\n          data.push_back(input[k][i][j]);\n          }*/\n        data.push_back(input[k][i][j]);\n      }\n    }\n  }\n  sort(data.begin(), data.end());\n  for(int k=0;k<2;k++){\n    /*int vis2[N][N];\n    fill(vis2[0], vis2[N], INF);\n    set<int>::iterator ite = data.begin();\n    for(;ite!=data.end();ite++){\n      fill(vis[0], vis[N], false);\n      dfs(sx[k], sy[k], *ite, k);      \n      for(int i=0;i<h[k];i++){\n        for(int j=0;j<w[k];j++){\n          if(vis[i][j]) vis2[i][j] = min(vis2[i][j], *ite);\n        }\n      }\n      }*/\n    fill(vis[0], vis[N], INF);\n    for(int i=0;i<h[k];i++){\n      for(int j=0;j<w[k];j++){\n        vis[i][j] = INF;\n      }\n    }\n    bfs(k);\n\n    vec[k].clear();\n    for(int i=0;i<h[k];i++){\n      for(int j=0;j<w[k];j++){\n        //vec[k].push_back(vis2[i][j]);\n        vec[k].push_back(vis[i][j]);\n      }\n    }\n    sort(vec[k].begin(), vec[k].end());\n  }\n}\n\nbool check(int a, int b){\n  int t1 = distance(vec[0].begin(), upper_bound(vec[0].begin(), vec[0].end(), a));\n  int t2 = distance(vec[1].begin(), upper_bound(vec[1].begin(), vec[1].end(), b));\n  return t1 + t2 >= R;\n  /*int sum = 0;\n  for(int i=0;i<2;i++){\n    fill(vis[0], vis[N], false);\n    cnt = 0;\n    int cost = a;\n    if(i == 1) cost = b;\n    if(cost > 0) dfs(sx[i], sy[i], cost, i);\n    sum += cnt;\n  }\n  return sum >= R;*/\n}\n\nint solve(){\n  //set<int>::iterator ite = data.end();\n  //int l = 0, r = *(--ite) + 1;\n  int l = 0, r = data[data.size()-1] + 1;\n  while(l<r){\n    int m = (l + r) / 2;\n    bool f = false;\n    //for(ite=data.begin();ite!=data.end();ite++){\n    for(int i=0;i<data.size();i++){\n      //if(*ite > m) break;\n      if(data[i] > m) break;\n      //if(check(*ite, m-(*ite))) f = true;\n      if(check(data[i], m-data[i])) f = true;\n    }\n    if(f) r = m;\n    else l = m + 1;\n  }\n  return l;\n}\n\nmain(){\n  //while(cin >> R && R){\n  while(scanf(\"%d\", &R) && R){\n    for(int k=0;k<2;k++){\n      scanf(\"%d %d %d %d\", w+k, h+k, sx+k, sy+k);\n      //cin >> w[k] >> h[k] >> sx[k] >> sy[k];\n      sx[k]--; sy[k]--;\n      for(int i=0;i<h[k];i++){\n        for(int j=0;j<w[k];j++){\n          //cin >> input[k][i][j];\n          scanf(\"%d\", &input[k][i][j]);\n        }\n      }\n    }\n    init();\n    //cout << solve() << endl;\n    printf(\"%d\\n\", solve());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nll c[2500001];\nll b[501][501];\nstruct A {\n\tll ko, level;\n};\nA a[2][250001];\nll u[501][501];\nstruct P {\n\tll x, y, level;\n};\nll d[2];\nbool operator<(P a, P b) { return a.level < b.level; }\nbool operator>(P a, P b) { return a.level > b.level; }\nconst ll inf = 800000000000000000;\nint main() {\n\tll r;\n\tint lp[4][2] = { {1,0},{-1,0},{0,1},{0,-1} };\n\twhile (cin >> r&&r != 0) {\n\t\tfor (int z = 0; z < 2; z++) {\n\t\t\tll h, w, x, y;\n\t\t\tcin >> w >> h >> y >> x;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tqueue<P>p;\n\t\t\tfor (ll i = 0; i < h; i++) {\n\t\t\t\tfor (ll j = 0; j < w; j++) {\n\t\t\t\t\tcin >> u[i][j];\n\t\t\t\t\tb[i][j] = inf;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.push(P{ x,y,1 });\n\t\t\tb[x][y] = 1;\n\t\t\twhile (!p.empty()) {\n\t\t\t\tP t = p.front(); p.pop();\n\t\t\t\tll x = t.x, y = t.y;\n\t\t\t\tif (t.level == b[x][y]) {\n\t\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\t\tll x2 = x + lp[i][0], y2 = y + lp[i][1];\n\t\t\t\t\t\tif (b[x2][y2] > t.level) {\n\t\t\t\t\t\t\tif (u[x2][y2] <= t.level) {\n\t\t\t\t\t\t\t\tb[x2][y2] = t.level;\n\t\t\t\t\t\t\t\tp.push(P{ x2,y2,t.level });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (u[x2][y2] < b[x2][y2]) {\n\t\t\t\t\t\t\t\t\tb[x2][y2] = u[x2][y2];\n\t\t\t\t\t\t\t\t\tp.push(P{ x2,y2,u[x2][y2] });\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tll o = 0;\n\t\t\tfor (ll i = 0; i < h; i++) {\n\t\t\t\tfor (ll j = 0; j < w; j++) {\n\t\t\t\t\tc[o] = b[i][j];\n\t\t\t\t\to++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(c, c + o);\n\t\t\tll sum = 0, g = 1;\n\t\t\ta[z][0] = A{ 0,0 };\n\t\t\tfor (ll i = 0; i < (h*w);) {\n\t\t\t\tll k = c[i], sum2 = 0;\n\t\t\t\twhile (i < (h*w) && c[i] == k) {\n\t\t\t\t\tsum2++;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\ta[z][g] = A{ sum2 + sum,k };\n\t\t\t\tg++;\n\t\t\t\tsum += sum2;\n\t\t\t}\n\t\t\td[z] = g;\n\t\t}\n\t\tll sum = inf;\n\t\tfor (ll i = 0; i < d[0]; i++) {\n\t\t\tll s = 0, e = d[1] - 1, t, m = r - a[0][i].ko;\n\t\t\twhile (e - s > 1) {\n\t\t\t\tt = (e + s) / 2;\n\t\t\t\tif (a[1][t].ko <= m)\n\t\t\t\t\ts = t;\n\t\t\t\tif (a[1][t].ko >= m)\n\t\t\t\t\te = t;\n\t\t\t}\n\t\t\tif (a[0][i].ko + a[1][s].ko >= r)\n\t\t\t\tsum = min(sum, a[0][i].level + a[1][s].level);\n\t\t\tif (a[0][i].ko + a[1][e].ko >= r)\n\t\t\t\tsum = min(sum, a[0][i].level + a[1][e].level);\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <tuple>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nconst vector<int> dx = { 0, 1, 0, -1 };\nconst vector<int> dy = { -1, 0, 1, 0 };\n\nint R, W[2], H[2], X[2], Y[2], F[2][500][500], D[2][500][500];\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &R);\n\n\t\tif (R == 0) break;\n\n\t\tfor (int i = 0; i < 2; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &W[i]);\n\t\t\tscanf(\"%d\", &H[i]);\n\t\t\tscanf(\"%d\", &X[i]); X[i]--;\n\t\t\tscanf(\"%d\", &Y[i]); Y[i]--;\n\n\t\t\tfor (int j = 0; j < H[i]; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < W[i]; k++)\n\t\t\t\t{\n\t\t\t\t\tscanf(\"%d\", &F[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(D, -1, sizeof(D));\n\n\t\tfor (int i = 0; i < 2; i++)\n\t\t{\n\t\t\tD[i][Y[i]][X[i]] = 1;\n\n\t\t\tpriority_queue<tuple<int, int, int>, vector<tuple<int, int, int> >, greater<tuple<int, int, int> > > que;\n\n\t\t\tque.push(make_tuple(0, X[i], Y[i]));\n\n\t\t\twhile (!que.empty())\n\t\t\t{\n\t\t\t\ttuple<int, int, int> state = que.top(); que.pop();\n\n\t\t\t\tint d = get<0>(state);\n\t\t\t\tint x = get<1>(state);\n\t\t\t\tint y = get<2>(state);\n\n\t\t\t\tfor (int dir = 0; dir < 4; dir++)\n\t\t\t\t{\n\t\t\t\t\tint x2 = x + dx[dir];\n\t\t\t\t\tint y2 = y + dy[dir];\n\n\t\t\t\t\tif (0 <= x2 && x2 < W[i] && 0 <= y2 && y2 < H[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (D[i][y2][x2] == -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tD[i][y2][x2] = max(d, F[i][y2][x2]);\n\n\t\t\t\t\t\t\tque.push(make_tuple(D[i][y2][x2], x2, y2));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<int> E[2];\n\n\t\tfor (int i = 0; i < 2; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < H[i]; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < W[i]; k++)\n\t\t\t\t{\n\t\t\t\t\tE[i].push_back(D[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsort(E[i].begin(), E[i].end());\n\t\t}\n\n\t\tint ret = 999999999;\n\n\t\tint petl = E[0].size();\n\t\tint petr = E[1].size();\n\n\t\tfor (int i = 0; i < R - 2; i++)\n\t\t{\n\t\t\tif (i < petl && R - i < petr)\n\t\t\t{\n\t\t\t\tret = min(ret, E[0][i] + E[1][R - i - 2]);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n\nconst int INF = 1 << 24;\nconst int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};\n\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\n\n#define mt std::make_tuple\n#define mp std::make_pair\n\nint R, W[2], H[2], X[2], Y[2];\nint room[2][500][500], minL[2][500][500], maxR[2][250000];\nstd::vector<int> L[2];\n\nvoid tour(int index){\n    int used[500][500];\n    REP(i, H[index]){\n        REP(j, W[index]){\n            used[i][j] = 0;\n        }\n    }\n    \n    std::priority_queue<std::pair<int, P>, std::vector<std::pair<int, P>>, std::greater<std::pair<int, P>>> q;\n    q.push(mp(1, mp(X[index], Y[index])));\n    used[Y[index]][X[index]] = 1;\n    minL[index][Y[index]][X[index]] = 1;\n    maxR[index][1] = 1;\n\n    while(!q.empty()){\n        auto s = q.top(); q.pop();\n        int l = std::get<0>(s);\n        P p = std::get<1>(s);\n        int x = p.first, y = p.second;\n\n        //std::cout << x << \",\" << y << \",\" << l << std::endl;\n        \n        if(l > minL[index][y][x]){continue;}\n\n        REP(i, 4){\n            int nx = x + dx[i], ny = y + dy[i];\n            \n            if(0 <= nx && nx < W[index] && 0 <= ny && ny < H[index] && \n               !used[ny][nx]){\n                int nl = std::max(l, room[index][ny][nx]);\n                minL[index][ny][nx] = nl;//std::min(minL[index][ny][nx], nl);\n                maxR[index][std::lower_bound(L[index].begin(), L[index].end(), nl)-L[index].begin()] += 1;\n                used[ny][nx] = 1;\n                q.push(mp(nl, mp(nx, ny)));\n            }\n        }\n    }\n}\n\nint main(){\n    while(std::cin >> R, R){\n        REP(i, 2){\n            L[i].clear();\n        }\n\n        REP(i, 2){\n            std::cin >> W[i] >> H[i] >> X[i] >> Y[i];\n            X[i]--; Y[i]--;\n\n            L[i].push_back(0);\n            REP(j, H[i]){\n                REP(k, W[i]){\n                    std::cin >> room[i][j][k];\n                    if(std::find(L[i].begin(), L[i].end(), room[i][j][k]) == L[i].end()){\n                        L[i].push_back(room[i][j][k]);\n                    }\n                }\n            }\n\n            std::sort(L[i].begin(), L[i].end());\n        }\n\n\n\n        REP(i, 2){\n            REP(j, L[i].size()){\n                maxR[i][j] = 0;\n            }\n        }\n\n        REP(k, 2){\n            REP(i, H[k]){\n                REP(j, W[k]){\n                    minL[k][i][j] = INF;\n                }\n            }\n        }\n\n        REP(i, 2){\n            tour(i);\n            //puts(\"###########################################\");\n        }\n\n        REP(i, 2){\n            FOR(j, 1, L[i].size()){\n                maxR[i][j] += maxR[i][j-1];\n            }\n        }\n\n        // REP(i, 2){\n        //     printf(\"Room %d\\n\", i);\n        //     REP(j, L[i].size()){\n        //         std::cout << maxR[i][j] << std::endl;\n        //     }\n        // }\n\n        int res = INF;\n        REP(i, L[0].size()){\n            int r = maxR[0][i],\n                index = std::lower_bound(maxR[1], maxR[1]+L[1].size(), R - r) - maxR[1];\n        \n            //std::cout << R - r << std::endl;\n            //std::cout << index << std::endl;\n\n            if(index >= L[1].size());\n            else{\n                //std::cout << \"wa-i\" << std::endl;\n                res = std::min(res, L[0][i] + L[1][index]);\n            }\n        }\n\n        std::cout << res << std::endl;\n\n        // REP(k, 2){\n        //     REP(i, H[k]){\n        //         REP(j, W[k]){\n        //             printf(\"%d, \", minL[k][i][j]);\n        //         }\n        //         puts(\"\");\n        //     }\n        //     puts(\"##########################################\");\n        // }\n    }    \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define p pair<int,int>\n#define P pair<int,p>\nusing namespace std;\n\nint x[4] = { -1,0,0,1 }, y[4] = { 0,-1,1,0 };\nint f[500][500];\nbool i[500][500];\nset<p>l,r;\nsigned main() {\n\tint a;\n\twhile (cin >> a, a) {\n\t\tl.clear(); r.clear();\n\t\tl.insert(p(0, 0)); r.insert(p(0, 0));\n\t\tint b, c, d, e; cin >> c >> b >> e >> d;\n\t\td--; e--;\n\t\tfor (int g = 0; g < b; g++) {\n\t\t\tfor (int h = 0; h < c; h++) {\n\t\t\t\tscanf(\"%lld\", &f[g][h]);\n\t\t\t}\n\t\t}\n\t\tmemset(i, true, sizeof(i));\n\t\tint sum = 0, MAX = 0;\n\t\tpriority_queue<P, vector<P>, greater<P>>Q;\n\t\tQ.push(P(1, p(d, e)));\n\t\twhile (Q.size()) {\n\t\t\tP o = Q.top(); Q.pop();\n\t\t\tMAX = o.first; \n\t\t\tif(i[o.second.first][o.second.second])sum++;\n\t\t\ti[o.second.first][o.second.second] = false;\n\t\t\tqueue<p>q;\n\t\t\tq.push(p(o.second.first, o.second.second));\n\t\t\twhile (q.size()) {\n\t\t\t\tp t = q.front(); q.pop();\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint dx = t.first + x[i], dy = t.second + y[i];\n\t\t\t\t\tif (dx >= 0 && dx < b&&dy >= 0 && dy < c&&::i[dx][dy]) {\n\t\t\t\t\t\tif (f[dx][dy] <= o.first) {\n\t\t\t\t\t\t\tsum++;\n\t\t\t\t\t\t\tq.push(p(dx,dy));\n\t\t\t\t\t\t\t::i[dx][dy] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tQ.push(P(f[dx][dy],p(dx,dy)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tl.insert(p(sum, MAX));\n\t\t}\n\t\tcin >> c >> b >> e >> d;\n\t\td--; e--;\n\t\tfor (int g = 0; g < b; g++) {\n\t\t\tfor (int h = 0; h < c; h++) {\n\t\t\t\tscanf(\"%lld\", &f[g][h]);\n\t\t\t}\n\t\t}\n\t\tmemset(i, true, sizeof(i));\n\t\tsum = 0; MAX = 0;\n\t\tpriority_queue<P, vector<P>, greater<P>>U;\n\t\tU.push(P(1, p(d, e)));\n\t\twhile (U.size()) {\n\t\t\tP o = U.top(); U.pop();\n\t\t\tMAX = o.first;\n\t\t\tif (i[o.second.first][o.second.second])sum++;\n\t\t\ti[o.second.first][o.second.second] = false;\n\t\t\tqueue<p>q;\n\t\t\tq.push(p(o.second.first, o.second.second));\n\t\t\twhile (q.size()) {\n\t\t\t\tp t = q.front(); q.pop();\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint dx = t.first + x[i], dy = t.second + y[i];\n\t\t\t\t\tif (dx >= 0 && dx < b&&dy >= 0 && dy < c&&::i[dx][dy]) {\n\t\t\t\t\t\tif (f[dx][dy] <= o.first) {\n\t\t\t\t\t\t\tsum++;\n\t\t\t\t\t\t\tq.push(p(dx, dy));\n\t\t\t\t\t\t\t::i[dx][dy] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tU.push(P(f[dx][dy], p(dx, dy)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tr.insert(p(sum, MAX));\n\t\t}\n\t\tint MIN = LLONG_MAX/3;\n\t\tfor (auto i = l.begin(); i != l.end(); i++) {\n\t\t\tauto j = r.lower_bound(p(a-(*i).first,0));\n\t\t\tif (j != r.end()) {\n\t\t\t\tMIN = min(MIN, (*i).second + (*j).second);\n\t\t\t}\n\t\t}\n\t\tcout << MIN << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<functional>\n#include<vector>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\n#define T1 1000000LL\n#define T2 1000LL\n\nlong long W, H, X, Y, R;\nlong long x[1000][1000];\nlong long d[1000][1000];\nlong long p1, p2, p3;\nlong long y_1[1000000], y_2[1000000], cnt, cnt2, v, minx;\n\npriority_queue<long long, vector<long long>, greater<long long>> Q, S;\n\nint main() {\n\twhile (true) {\n\t\tcnt = 1; cnt2 = 1; minx = 1145141919810LL;\n\t\tmemset(x, 51, sizeof(x));\n\t\tmemset(d, 51, sizeof(d));\n\t\tcin >> R;\n\t\tif (R == 0) { break; }\n\t\tcin >> W >> H >> X >> Y;\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tcin >> x[i][j];\n\t\t\t}\n\t\t}\n\t\td[Y][X] = 0;\n\t\tQ.push(Y*T2 + X);\n\t\twhile (!Q.empty()) {\n\t\t\tp1 = Q.top() / T1;\n\t\t\tp2 = (Q.top() / T2) % T2;\n\t\t\tp3 = Q.top() % T2;\n\t\t\tif (max(p1, x[p2 - 1][p3]) < d[p2 - 1][p3]) {\n\t\t\t\td[p2 - 1][p3] = max(p1, x[p2 - 1][p3]);\n\t\t\t\tS.push(d[p2 - 1][p3] * T1 + (p2 - 1)*T2 + p3);\n\t\t\t}\n\t\t\tif (max(p1, x[p2 + 1][p3]) < d[p2 + 1][p3]) {\n\t\t\t\td[p2 + 1][p3] = max(p1, x[p2 + 1][p3]);\n\t\t\t\tS.push(d[p2 + 1][p3] * T1 + (p2 + 1)*T2 + p3);\n\t\t\t}\n\t\t\tif (max(p1, x[p2][p3 - 1]) < d[p2][p3 - 1]) {\n\t\t\t\td[p2][p3 - 1] = max(p1, x[p2][p3 - 1]);\n\t\t\t\tS.push(d[p2][p3 - 1] * T1 + p2*T2 + (p3 - 1));\n\t\t\t}\n\t\t\tif (max(p1, x[p2][p3 + 1]) < d[p2][p3 + 1]) {\n\t\t\t\td[p2][p3 + 1] = max(p1, x[p2][p3 + 1]);\n\t\t\t\tS.push(d[p2][p3 + 1] * T1 + p2*T2 + (p3 + 1));\n\t\t\t}\n\t\t\twhile (!S.empty()) {\n\t\t\t\tQ.push(S.top());\n\t\t\t\tS.pop();\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\ty_1[cnt] = d[i][j];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tmemset(x, 51, sizeof(x));\n\t\tmemset(d, 51, sizeof(d));\n\t\tcin >> W >> H >> X >> Y;\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\tcin >> x[i][j];\n\t\t\t}\n\t\t}\n\t\td[Y][X] = 0;\n\t\tQ.push(Y*T2 + X);\n\t\twhile (!Q.empty()) {\n\t\t\tp1 = Q.top() / T1;\n\t\t\tp2 = (Q.top() / T2) % T2;\n\t\t\tp3 = Q.top() % T2;\n\t\t\tif (max(p1, x[p2 - 1][p3]) < d[p2 - 1][p3]) {\n\t\t\t\td[p2 - 1][p3] = max(p1, x[p2 - 1][p3]);\n\t\t\t\tS.push(d[p2 - 1][p3] * T1 + (p2 - 1)*T2 + p3);\n\t\t\t}\n\t\t\tif (max(p1, x[p2 + 1][p3]) < d[p2 + 1][p3]) {\n\t\t\t\td[p2 + 1][p3] = max(p1, x[p2 + 1][p3]);\n\t\t\t\tS.push(d[p2 + 1][p3] * T1 + (p2 + 1)*T2 + p3);\n\t\t\t}\n\t\t\tif (max(p1, x[p2][p3 - 1]) < d[p2][p3 - 1]) {\n\t\t\t\td[p2][p3 - 1] = max(p1, x[p2][p3 - 1]);\n\t\t\t\tS.push(d[p2][p3 - 1] * T1 + p2*T2 + (p3 - 1));\n\t\t\t}\n\t\t\tif (max(p1, x[p2][p3 + 1]) < d[p2][p3 + 1]) {\n\t\t\t\td[p2][p3 + 1] = max(p1, x[p2][p3 + 1]);\n\t\t\t\tS.push(d[p2][p3 + 1] * T1 + p2*T2 + (p3 + 1));\n\t\t\t}\n\t\t\twhile (!S.empty()) {\n\t\t\t\tQ.push(S.top());\n\t\t\t\tS.pop();\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\ty_2[cnt2] = d[i][j];\n\t\t\t\tcnt2++;\n\t\t\t}\n\t\t}\n\n\t\tsort(y_1, y_1 + cnt);\n\t\tsort(y_2, y_2 + cnt2);\n\n\t\tfor (int i = 0; i < cnt; i++) {\n\t\t\tv = R - i;\n\t\t\tif (v >= 0 && v < cnt2) {\n\t\t\t\tminx = min(minx, y_1[i] + y_2[v]);\n\t\t\t}\n\t\t}\n\t\tcout << minx << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,b) FOR(i,0,b)\n\t\nstruct cxy{\n\tint cost,x,y;\n\tbool operator<(const cxy& rhs)const{\n\t\treturn cost<rhs.cost;\n\t}\n\tbool operator>(const cxy& rhs)const{\n\t\treturn cost>rhs.cost;\n\t}\n};\n\nint CalcTable(int* ret){\n\tint w,h,x,y;\n\tscanf(\"%d%d%d%d\",&w,&h,&x,&y);\n\tstatic int m[500][500];\n\tREP(i,h)\n\t\tREP(j,w)\n\t\t\tscanf(\"%d\",&m[i][j]);\n\tret[0]=0;\n\tpriority_queue<cxy,vector<cxy>,greater<cxy> > pq;\n\tstatic bool used[500][500];\n\tREP(i,h)\n\t\tREP(j,w)\n\t\t\tused[i][j]=false;\n\tpq.push({1,--x,--y});\n\tused[y][x]=true;\n\tint c=0;\n\tstatic const int dxy[] = {0,-1,0,1,0};\n\tint b=0;\n\twhile(!pq.empty()){\n\t\tcxy t=pq.top();\n\t\tpq.pop();\n\t\tb=max(b,t.cost);\n\t\tret[++c]=b;\n\t\tREP(i,4){\n\t\t\tint nx=t.x+dxy[i];\n\t\t\tint ny=t.y+dxy[i+1];\n\t\t\tif(0<=nx&&nx<w&&0<=ny&&ny<h)\n\t\t\t\tif(!used[ny][nx]){\n\t\t\t\t\tpq.push({m[ny][nx],nx,ny});\n\t\t\t\t\tused[ny][nx]=true;\n\t\t\t\t}\n\t\t}\n\t}\n\treturn w*h+1;\n}\n\t\nint main(){\n\twhile(1){\n\t\tint r;\n\t\tscanf(\"%d\",&r);\n\t\tif(r==0)\n\t\t\tbreak;\n\t\tstatic int buf1[250001];\n\t\tstatic int buf2[250001];\n\t\tint r1 = CalcTable(buf1);\n\t\tint r2 = CalcTable(buf2);\n\t\tint ans=1145141919;\n\t\tREP(i,r1){\n\t\t\tint j=r-i;\n\t\t\tif(j<r2)\n\t\t\t\tans = min(ans,buf1[i]+buf2[j]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (int R; cin >> R&&R;) {\n\t\tstatic int L[2][510][510];\n\t\tvector<int> W(2), H(2), X(2), Y(2); rep(i, 0, 2) {\n\t\t\tcin >> W[i] >> H[i] >> X[i] >> Y[i]; X[i]--, Y[i]--;\n\t\t\trep(y, 0, H[i])rep(x, 0, W[i]) {\n\t\t\t\tcin >> L[i][y][x];\n\t\t\t}\n\t\t}\n\t\tusing T = tuple<int, int, int>;\n\t\tvector<vector<int>> level(2, vector<int>(R + 1, INF));\n\t\trep(k, 0, 2) {\n\t\t\tstatic bool flag[510][510];\n\t\t\tmemset(flag, 0, sizeof(flag));\n\t\t\tpriority_queue<T, vector<T>, greater<T>> pq;\n\t\t\tpq.emplace(L[k][Y[k]][X[k]], Y[k], X[k]);\n\t\t\tflag[Y[k]][X[k]] = true;\n\t\t\tauto inrange = [&](int i, int j) { return i >= 0 && i < H[k] && j >= 0 && j < W[k]; };\n\t\t\tint c = 0;\n\t\t\tint nl = 0;\n\t\t\twhile (pq.size()) {\n\t\t\t\tint l, ci, cj; tie(l, ci, cj) = pq.top(); pq.pop();\n\t\t\t\tstatic const int di[] = { 1,0,-1,0 };\n\t\t\t\tstatic const int dj[] = { 0,1,0,-1 };\n\t\t\t\tc++;\n\t\t\t\tchmax(nl, l);\n\t\t\t\tlevel[k][c] = nl;\n\t\t\t\tif (c == R)break;\n\t\t\t\trep(d, 0, 4) {\n\t\t\t\t\tint ni = ci + di[d], nj = cj + dj[d];\n\t\t\t\t\tif (!inrange(ni, nj))continue;\n\t\t\t\t\tif (flag[ni][nj])continue;\n\t\t\t\t\tflag[ni][nj] = true;\n\t\t\t\t\tpq.emplace(L[k][ni][nj], ni, nj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdump(level);\n\t\tint ans = INF;\n\t\trep(r, 0, R + 1) {\n\t\t\tchmin(ans, level[0][r] + level[1][R - r]);\n\t\t\tdump(level[0][r], level[1][R - r]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cassert>\n#include <map>\nusing namespace std;\n\nclass state{\npublic:\n  int x,y,l;\n  state(int y=0, int x=0, int l=0):y(y),x(x),l(l){}\n  bool operator < (const state &s) const {return l > s.l;}\n};\n\nconst int INF = (1<<29);\ntypedef pair<int,int> P;\nint r,h,w,rx,ry,a[500][500];\nint dy[] = {0,1,0,-1};\nint dx[] = {1,0,-1,0};\nbool f[500][500];\nvector<int> numr[2],numl[2];\nmap<int,int> m[2];\n\nbool check(int y, int x){\n  if(y < 0 || y >= h) return false;\n  if(x < 0 || x >= w) return false;\n  return true;\n}\n\nvoid bfs(int k){\n  int maxl = 0;\n  priority_queue<state> Q;\n  state u,v;\n\n  m[k].clear();\n  fill(f[0],f[500],false);\n  f[ry][rx] = true;\n  Q.push(state(ry,rx,1));\n  while(!Q.empty()){\n    u = Q.top();\n    Q.pop();\n\n    if(u.l > maxl){\n      m[k][u.l] = m[k][maxl] + 1;\n      maxl = u.l;\n    } else m[k][maxl]++;\n\n    for(int i=0;i<4;i++){\n      v.x = u.x + dx[i];\n      v.y = u.y + dy[i];\n      if(check(v.y,v.x) && !f[v.y][v.x]){\n\tf[v.y][v.x] = true;\n\tv.l = a[v.y][v.x];\n\tQ.push(v);\n      }\n    }\n  }\n\n  numr[k].clear();\n  numl[k].clear();\n  for(map<int,int>::iterator it=m[k].begin(); it!=m[k].end(); it++){\n    numl[k].push_back(it->first);\n    numr[k].push_back(it->second);\n  }\n\n}\n\nint main(){\n  while(cin >> r && r){\n    int ans = INF;\n    for(int k=0;k<2;k++){\n      cin >> w >> h >> rx >> ry;\n      rx--;\n      ry--;\n      for(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++)\n\t  cin >> a[i][j];\n      bfs(k);      \n    }\n\n    for(int i=0;i<numr[0].size();i++){\n      if(numr[0][i] >= r){\n\tans = min(numl[0][i],ans);\n\tbreak;\n      }\n      int cnt = r - numr[0][i];\n      int pos = upper_bound(numr[1].begin(), numr[1].end(), cnt) - numr[1].begin();\n      if(pos < numr[1].size()) ans = min(ans,numl[0][i] + numl[1][pos]);\n      pos = max(0,pos-1);\n      if(numr[0][i] + numr[1][pos] >= r) ans = min(ans,numl[0][i] + numl[1][pos]);\n    }\n    int pos = upper_bound(numr[1].begin(), numr[1].end(), r) - numr[1].begin();\n    if(pos < numr[1].size()) ans = min(ans,numl[1][pos]);\n    pos = max(0,pos-1);\n    if(numr[1][pos] >= r) ans = min(ans,numl[1][pos]);\n\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\n\nstatic const double eps = 1e-8;\n\nconst int tx[4] = {+0,+1,+0,-1};\nconst int ty[4] = {-1,+0,+1,+0};\n\nbool visited[501][501];\nint rooms[2][501][501];\nint passed_rooms[2][250001];\n\nstruct State {\n  int x;\n  int y;\n  int auth;\n  bool operator<(const State& s) const {\n    return auth < s.auth;\n  }\n  bool operator>(const State& s) const {\n    return auth > s.auth;\n  }\n  State(int x,int y,int auth) : x(x), y(y), auth(auth) {}\n};\n\nvoid bfs(int sx,int sy,int W,int H,int office_i){\n  memset(visited,false,sizeof(visited));\n  priority_queue<State,vector<State>, greater<State> > que;\n  que.push(State(sx,sy,1));\n  int current_auth_level = 0;\n  int count = 0;\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    if(visited[s.y][s.x]) continue;\n    visited[s.y][s.x] = true;\n\n    count++;\n    current_auth_level = max(s.auth,current_auth_level);\n    passed_rooms[office_i][count] = current_auth_level;\n\n    for(int i = 0; i < 4; i++){\n      int dx = s.x + tx[i];\n      int dy = s.y + ty[i];\n      if(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n      if(visited[dy][dx]) continue;\n       que.push(State(dx,dy,rooms[office_i][dy][dx]));\n    }\n  }\n}\n\nint main(){\n  int have_to_visit_rooms;\n  while(~scanf(\"%d\",&have_to_visit_rooms)){\n    memset(passed_rooms,0x3f,sizeof(passed_rooms));\n    int elevator_x[2];\n    int elevator_y[2];\n    int W[2];\n    int H[2];\n    for(int office_i = 0; office_i < 2; office_i++){\n      scanf(\"%d %d %d %d\",&W[office_i],&H[office_i],\n            &elevator_x[office_i],&elevator_y[office_i]);\n      elevator_x[office_i]--;\n      elevator_y[office_i]--;\n\n      for(int y = 0; y < H[office_i]; y++){\n        for(int x = 0; x < W[office_i]; x++){\n          scanf(\"%d\",&rooms[office_i][y][x]);\n        }\n      }\n\n      bfs(elevator_x[office_i],\n          elevator_y[office_i],\n          W[office_i],H[office_i],office_i);\n    }\n\n    int res = 0x3f3f3f3f;\n    for(int i = have_to_visit_rooms; i >= 0; i--){\n      int j = have_to_visit_rooms - i;\n      res = min(passed_rooms[0][i] + passed_rooms[1][j],res);\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <vector>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint R;\nint x[2], y[2], w[2], h[2];\nint level[2][501][501];\nint seen[501][501];\n\nint dx[4] = { 0, 1, 0, -1 };\nint dy[4] = { 1, 0, -1, 0 };\n\nstruct state {\n  int l,x,y;\n  state(const int _l, const int _x, const int _y) : l(_l), x(_x), y(_y) {}\n  bool operator<(const state &rhs) const {\n    return (l != rhs.l) ? l > rhs.l : x < rhs.x;\n  }\n};\n\nvector<pair<int,int> > bfs(int k) {\n  memset(seen, 0, sizeof(seen));\n  priority_queue<state> q; q.push(state(1, x[k], y[k]));\n  vector<pair<int,int> > v(1, make_pair(0,0));\n  seen[y[k]][x[k]] = 1;\n  int cnt = 0, cl = 0;\n  while(!q.empty()) {\n    cl = q.top().l;\n    while(!q.empty() && q.top().l <= cl) {\n      const state s = q.top(); q.pop();\n      int x = s.x, y = s.y;\n      cnt++;\n      for (int i=0; i<4; ++i) {\n        int nx = x + dx[i], ny = y+dy[i];\n        if (nx < 0 || nx >= w[k] || ny < 0 || ny >= h[k]) continue;\n        if (seen[ny][nx]) continue; seen[ny][nx] = 1;\n        q.push(state(level[k][ny][nx], nx, ny));\n      }\n    }\n    v.push_back(make_pair(cl, cnt));\n  }\n  return v;\n}\n\nint main() {\n  while(cin>>R, R) {\n    for (int i=0; i<2; ++i) {\n      cin>>w[i]>>h[i]>>x[i]>>y[i]; x[i]--, y[i]--;\n      for (int j=0; j<h[i]; ++j)\n        for (int k=0; k<w[i]; ++k) cin>>level[i][j][k];\n    }\n\n    vector<pair<int,int> > v1, v2;\n    v1 = bfs(0);\n    v2 = bfs(1);\n    vector<int> l1, l2, r1, r2;\n    for (int i=0; i<v1.size(); ++i) {\n      l1.push_back(v1[i].first);\n      r1.push_back(v1[i].second);\n    }\n    for (int i=0; i<v2.size(); ++i) {\n      l2.push_back(v2[i].first);\n      r2.push_back(v2[i].second);\n    }\n\n    int ans = 1<<29;\n    for (int i=0; i<v1.size(); ++i) {\n      int need = R-r1[i];\n      int d = lower_bound(r2.begin(), r2.end(), need) - r2.begin();\n      if (d == r2.size()) continue;\n      //cout<<l1[i]<<\" \"<<l2[d]<<\" \"<<d<<\" \"<<r2[d]<<\" \"<<r1[i]<<endl;\n      ans = min(ans, l1[i]+l2[d]);\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint l[2][500][500];\nbool c[2][500][500];\nint memo[2][250001];\n\nstruct level{\n  int l;\n  int x;\n  int y;\n  level(int a,int b,int c){\n    l=a; x=b; y=c;\n  }\n};\n\nbool operator < (const level &a, const level &b){\n  return a.l > b.l;\n}\n\nint main(){\n  int r;\n  while(r = getInt()){\n    int w[2],h[2],x[2],y[2];\n    REP(k,2){\n      w[k] = getInt();\n      h[k] = getInt();\n      x[k] = getInt() - 1;\n      y[k] = getInt() - 1;\n      REP(i,h[k]) REP(j,w[k]){\n        l[k][i][j] = getInt();\n        c[k][i][j] = false;\n      }\n\n      priority_queue<level> pq;\n      pq.push(level(1,x[k],y[k]));\n      c[k][y[k]][x[k]] = true;\n\n      int cnt = 0;\n      int now = 1;\n\n      memo[k][cnt++] = 0;\n      while(!pq.empty()){\n        level lv = pq.top();\n        int ll = lv.l;\n        int xx = lv.x;\n        int yy = lv.y;\n        pq.pop();\n        //printf(\"%d %d %d\\n\",ll,xx,yy);\n\n        memo[k][cnt++] = (now = max(ll, now));\n\n        REP(i,4){\n          int xxx = xx + _dx[i];\n          int yyy = yy + _dy[i];\n\n          if(ISIN(xxx,yyy,w[k],h[k]) && !c[k][yyy][xxx]){\n            c[k][yyy][xxx] = true;\n            pq.push(level(l[k][yyy][xxx], xxx, yyy));\n          }\n        }\n      }\n\n      //REP(i, w[k]*h[k]+1) printf(\"%d \",memo[k][i]); puts(\"\");\n    }\n\n    int end = min(r, w[0] * h[0]) + 1;\n    int start = max(0, r - w[1] * h[1]);\n    int ans = INT_MAX;\n    rep(i,start,end)\n      ans = min(ans, memo[0][i] + memo[1][r-i]);\n    print(ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//認証レベルの小さい順に鍵を設定すると、入れる部屋が単調にふえるので、その部屋に入るための最少認証レベルが簡単に求まる。\n//と思ったら、そうでもなかった…とりあえず、ダイクストラの負の辺OK盤を使う。\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n//#define DEBUG DEBUG\n#define F first\n#define S second\nusing namespace std;\n#define MAX(x,y) (x>y?x:y)\t// ()がいります\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint R;\nint W1,H1,X1,Y1,W2,H2,X2,Y2;\nint JOI1[501][501],JOI2[501][501];\t//JOI[y][x]として入れます。\nint ADD1[501][501],ADD2[501][501];\t//入るための認証レベルの最小値(1以上)\n\nvoid Make_list1(){\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\tPP node;\n\tque.push(PP(1,P(Y1,X1)));\n\twhile(!que.empty()){\n\t\tnode = que.top();\n\t\tque.pop();\n\t\t//周り4辺を更新\n\t\tif(ADD1[node.S.F+1][node.S.S] > MAX(node.F,JOI1[node.S.F+1][node.S.S])){\n\t\t\tADD1[node.S.F+1][node.S.S] = MAX(node.F,JOI1[node.S.F+1][node.S.S]);\n\t\t\tque.push(PP(ADD1[node.S.F+1][node.S.S],P(node.S.F+1,node.S.S)));\t\n\t\t}\n\t\tif(ADD1[node.S.F][node.S.S+1] > MAX(node.F,JOI1[node.S.F][node.S.S+1])){\n\t\t\tADD1[node.S.F][node.S.S+1] = MAX(node.F,JOI1[node.S.F][node.S.S+1]);\n\t\t\tque.push(PP(ADD1[node.S.F][node.S.S+1],P(node.S.F,node.S.S+1)));\t\n\t\t}\n\t\tif(node.S.F > 0 && ADD1[node.S.F-1][node.S.S] > MAX(node.F,JOI1[node.S.F-1][node.S.S])){\n\t\t\tADD1[node.S.F-1][node.S.S] = MAX(node.F,JOI1[node.S.F-1][node.S.S]);\n\t\t\tque.push(PP(ADD1[node.S.F-1][node.S.S],P(node.S.F-1,node.S.S)));\t\n\t\t}\n\t\tif(node.S.S > 0 && ADD1[node.S.F][node.S.S-1] > MAX(node.F,JOI1[node.S.F][node.S.S-1])){\n\t\t\tADD1[node.S.F][node.S.S-1] = MAX(node.F,JOI1[node.S.F][node.S.S-1]);\n\t\t\tque.push(PP(ADD1[node.S.F][node.S.S-1],P(node.S.F,node.S.S-1)));\t\n\t\t}\n\t}\n}\nvoid Make_list2(){\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\tPP node;\n\tque.push(PP(1,P(Y2,X2)));\n\twhile(!que.empty()){\n\t\tnode = que.top();\n\t\tque.pop();\n\t\t//周り4辺を更新\n\t\tif(ADD2[node.S.F+1][node.S.S] > MAX(node.F,JOI2[node.S.F+1][node.S.S])){\n\t\t\tADD2[node.S.F+1][node.S.S] = MAX(node.F,JOI2[node.S.F+1][node.S.S]);\n\t\t\tque.push(PP(ADD2[node.S.F+1][node.S.S],P(node.S.F+1,node.S.S)));\t\n\t\t}\n\t\tif(ADD2[node.S.F][node.S.S+1] > MAX(node.F,JOI2[node.S.F][node.S.S+1])){\n\t\t\tADD2[node.S.F][node.S.S+1] = MAX(node.F,JOI2[node.S.F][node.S.S+1]);\n\t\t\tque.push(PP(ADD2[node.S.F][node.S.S+1],P(node.S.F,node.S.S+1)));\t\n\t\t}\n\t\tif(node.S.F > 0 && ADD2[node.S.F-1][node.S.S] > MAX(node.F,JOI2[node.S.F-1][node.S.S])){\n\t\t\tADD2[node.S.F-1][node.S.S] = MAX(node.F,JOI2[node.S.F-1][node.S.S]);\n\t\t\tque.push(PP(ADD2[node.S.F-1][node.S.S],P(node.S.F-1,node.S.S)));\t\n\t\t}\n\t\tif(node.S.S > 0 && ADD2[node.S.F][node.S.S-1] > MAX(node.F,JOI2[node.S.F][node.S.S-1])){\n\t\t\tADD2[node.S.F][node.S.S-1] = MAX(node.F,JOI2[node.S.F][node.S.S-1]);\n\t\t\tque.push(PP(ADD2[node.S.F][node.S.S-1],P(node.S.F,node.S.S-1)));\t\n\t\t}\n\t}\n}\nint main(){\n\tint i,j;\n\tint minest[200],mcor = 0;\n\tfor(i = 0;i < 200;i++){minest[i] = 1000000000;}\n\twhile(1){\n\t\tcin >> R;\n\t\tif(R == 0)\n\t\t\tbreak;\n\t\tcin >> W1 >> H1 >> X1 >> Y1;\n\t\tX1--;Y1--;\n\t\tfor(i = 0;i < H1;i++){\n\t\t\tfor(j = 0;j < W1;j++){\n\t\t\t\tcin >> JOI1[i][j];\n\t\t\t\tADD1[i][j] = 1000000001;\n\t\t\t}\n\t\t}\n\t\tADD1[Y1][X1] = 1;\n\t\tcin >> W2 >> H2 >> X2 >> Y2;\n\t\tX2--;Y2--;\n\t\tfor(i = 0;i < H2;i++){\n\t\t\tfor(j = 0;j < W2;j++){\n\t\t\t\tcin >> JOI2[i][j];\n\t\t\t\tADD2[i][j] = 1000000001;\n\t\t\t}\n\t\t}\n\t\tADD2[Y2][X2] = 1;\n\t\t//幅優先探索で部屋に入るための認証レベルの最小値,R部屋入るための認証レベルの最小値を記録する。\n\t\t//認証レベルの設定はWH回したほうがよい。まちがっても、部屋数に対する認証レベルを探すO(R^2logWH)解法は行わない！\n\t\t//queueを使うとO(WH)で行ける。WH*最大4方向*最大4回更新\n\t\tMake_list1();\n\t\tMake_list2();\n\t\t//認証レベルに対して入れる部屋数を考えてみよう(ヒント→認証レベルがiのとき認証レベルがi-1のとき行けた部屋はすべていける)\n\t\tstatic map<int,int> nin1,nin2;\t//認証レベル,部屋数\n\t\tnin1.insert(make_pair(0,0));\n\t\tfor(i = 0;i < H1;i++){\n\t\t\tfor(j = 0;j < W1;j++){\n\t\t\t\tif(nin1.find(ADD1[i][j]) == nin1.end()){\n\t\t\t\t\tnin1.insert(make_pair(ADD1[i][j],0));\n\t\t\t\t}\n\t\t\t\tnin1[ADD1[i][j]]++;\t\t//2番目のキーをプラスしましょう。\n\t\t\t}\n\t\t}\n\t\tnin2.insert(make_pair(0,0));\n\t\tfor(i = 0;i < H2;i++){\n\t\t\tfor(j = 0;j < W2;j++){\n\t\t\t\tif(nin2.find(ADD2[i][j]) == nin2.end()){\n\t\t\t\t\tnin2.insert(make_pair(ADD2[i][j],0));\n\t\t\t\t}\n\t\t\t\tnin2[ADD2[i][j]]++;\t\t//2番目のキーをプラスしましょう。\n\t\t\t}\n\t\t}\n\t\tmap<int,int>::iterator it,bit;\n\t\tit = nin1.begin();\n\t\tfor(it++;it != nin1.end();it++){\n\t\t\tbit = it;\n\t\t\tbit--;\n\t\t\t(*it).S += (*bit).S;\n\t\t}\n\t\tit = nin2.begin();\n\t\tfor(it++;it != nin2.end();it++){\n\t\t\tbit = it;\n\t\t\tbit--;\n\t\t\t(*it).S += (*bit).S;\n\t\t}\n\t\t//入れる部屋数にたいする認証レベルの最小値を考えてみよう\n\t\tstatic int R1[100001],R2[100001];\n\t\tfor(i = 0;i < R+1;i++){R1[i] = 1000000000;R2[i] = 1000000000;}\n\t\tit = nin1.begin();\n\t\tR1[0] = 0;\n\t\tit++;\n\t\tfor(;it != nin1.end();it++){\n\t\t\tif((*it).S > R)\n\t\t\t\t(*it).S = R;\n\t\t\tbit = it;\n\t\t\tbit--;\n\t\t\tfor(i = (*it).S;i > (*bit).S;i--){\n\t\t\t\tif(R1[i] > (*it).F)\n\t\t\t\t\tR1[i] = (*it).F;\n\t\t\t}\n\t\t}\n\t\tit = nin2.begin();\n\t\tR2[0] = 0;\n\t\tit++;\n\t\tfor(;it != nin2.end();it++){\n\t\t\tif((*it).S > R)\n\t\t\t\t(*it).S = R;\n\t\t\tbit = it;\n\t\t\tbit--;\n\t\t\tfor(i = (*it).S;i > (*bit).S;i--){\n\t\t\t\tif(R2[i] > (*it).F)\n\t\t\t\t\tR2[i] = (*it).F;\n\t\t\t}\n\t\t}\n\t\t//デバッグ\n#ifdef DEBUG\n\t\tfor(i = 0;i < H1;i++){\n\t\t\tfor(j = 0;j < W1;j++){\n\t\t\t\tcout << ADD1[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tfor(i = 0;i < H2;i++){\n\t\t\tfor(j = 0;j < W2;j++){\n\t\t\t\tcout << ADD2[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << \"(NL,OK)1部屋目\" << endl;\n\t\tfor(it = nin1.begin();it != nin1.end();it++){\n\t\t\tcout << (*it).F << \" \" << (*it).S << endl;\n\t\t}\n\t\tcout << \"(NL,OK)2部屋目\" << endl;\n\t\tfor(it = nin2.begin();it != nin2.end();it++){\n\t\t\tcout << (*it).F << \" \" << (*it).S << endl;\n\t\t}\n\t\t//認証レベル\n\t\tcout << \"NL1部屋目\" << endl;\n\t\tfor(i = 0;i < H1;i++){\n\t\t\tfor(j = 0;j < W1;j++){\n\t\t\t\tcout << R1[i*W1+j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << R1[H1*W1] << endl;\n\t\tcout << \"NL2部屋目\" << endl;\n\t\tfor(i = 0;i < H2;i++){\n\t\t\tfor(j = 0;j < W2;j++){\n\t\t\t\tcout << R2[i*W2+j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << R2[H1*W1] << endl;\n#endif\n\t\t//探索(O(R))\n\t\tfor(i = 0;i < R+1;i++){\n\t\t\tif(minest[mcor] > R1[i]+R2[R-i])\n\t\t\t\tminest[mcor] = R1[i]+R2[R-i];\n\t\t}\t\t\n\t\t//使った分を初期化\n\t\tfor(i = 0;i < H1;i++){\n\t\t\tfor(j = 0;j < W1;j++){\n\t\t\t\tJOI1[i][j] = 0;\n\t\t\t\tADD1[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(i = 0;i < H2;i++){\n\t\t\tfor(j = 0;j < W2;j++){\n\t\t\t\tJOI2[i][j] = 0;\n\t\t\t\tADD2[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tnin1.clear();\n\t\tnin2.clear();\n\t\tfor(i = 0;i < R+1;i++){R1[i] = 1000000000;R2[i] = 1000000000;}\n\t\t//カーソル移動\n\t\tmcor++;\n\t}\n\tfor(i = 0;i < mcor;i++){\n\t\tcout << minest[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int INF = 1<<30;\n\nint R,H[2],W[2],X[2],Y[2];\nint G[2][512][512];\nint dy[]={0,-1,0,1},dx[]={-1,0,1,0};\n\nint C(int d, int r, int h, int w, int x, int y, int g[512][512]){\n  int res = 0, vis[512][512];\n  memset(vis, -1, sizeof vis);\n  queue<P>q;\n  q.push(P(y,x));\n  vis[y][x] = 0;\n  //  cout << \"tansaku  \"<< y << \" \" << x << \" \" << g[y][x] << endl;\n  while(!q.empty()){\n    P p = q.front(); q.pop();\n    if(g[p.first][p.second] > d) continue;\n    res++;\n    for(int i=0;i<4;i++){\n      int ny=dy[i]+p.first, nx=dx[i]+p.second;\n      if(ny<0||ny>=h||nx<0||nx>=w||vis[ny][nx]!=-1) continue;\n      vis[ny][nx] = vis[p.first][p.second] + 1;\n      q.push(P(ny,nx));\n    }\n  }\n  return res >=r;\n}\n\nint main(){\n  while(scanf(\"%d\", &R) && R){\n    for(int i=0;i<2;i++){\n      scanf(\"%d%d%d%d\", &W[i],&H[i],&X[i],&Y[i]); X[i]--; Y[i]--;\n      for(int j=0;j<H[i];j++) for(int k=0;k<W[i];k++) scanf(\"%d\", &G[i][j][k]);\n    }\n    //    puts(\"END OF FILE\");\n    int res = INF;\n    for(int x=0;x<=R;x++){\n      //      if(x!=3) continue;\n      int r[2]; r[0] = x; r[1] = R-x;\n      int sum = 0;\n      for(int i=0;i<2;i++){\n\tint lb = -1, ub = 100000005;\n\twhile(lb + 1 < ub){\n\t  int mid = (lb+ub)/2;\n\t  //\t  cout << lb << \" \" << ub << endl;\n\t  if(C(mid, r[i], H[i], W[i], X[i], Y[i], G[i])) ub = mid;\n\t  else lb = mid;\n\t}\n\tsum += ub;\n\t///\tcout << r[0] << \" \" << r[1] << \" \" << sum << endl;\n      }\n      res = min(res, sum);\n    }\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#define INF (1 << 29)\ntypedef pair<int, int> P; \ntypedef pair<int, P> F;\nint xs[] = {-1, 0, 1, 0}, ys[] = {0, 1, 0, -1};\nvector<int> input_djk(){\n  int w, h, x ,y;\n  cin >> w >> h >> x >> y;\n  x--,y--;\n  int dist[w][h], level[w][h];\n  bool used[w][h];\n  for(int j = 0;j < h;j++){\n    for(int i = 0;i < w;i++){\n      cin >> level[i][j];\n      dist[i][j] = INF;\n      used[i][j] = false;\n    }\n  }\n  \n\n  priority_queue<F, vector<F>, greater<F> > pq;\n  dist[x][y] = 1;\n  used[x][y] = true;\n  pq.push(F(1, P(x, y)));\n  while(!pq.empty()){\n    F tmp = pq.top();pq.pop();\n    int tx = tmp.second.first, ty = tmp.second.second;\n    if(dist[tx][ty] < tmp.first)continue;\n    for(int i = 0;i < 4;i++){\n      if(tx + xs[i] < 0 || tx + xs[i] >= w || ty + ys[i] < 0 || ty + ys[i] >= h || used[tx + xs[i]][ty + ys[i]])continue;\n      tx += xs[i], ty += ys[i];\n      if(dist[tx][ty] > max(tmp.first, level[tx][ty])){\n\tdist[tx][ty] = max(tmp.first, level[tx][ty]);\n\tused[tx][ty] = true;\n\tpq.push(F(dist[tx][ty], P(tx, ty)));\n      }\n      tx -= xs[i], ty -= ys[i];\n    }\n  }\n  vector<int> res;\n  for(int i = 0;i < w;i++)\n    for(int j = 0;j < h;j++)\n      res.push_back(dist[i][j]);\n   \n  sort(res.begin(), res.end());\n  return res;\n}\n\nint gs(vector<int> x, int r){\n  if(r == 0)return 0;\n  else return x[r - 1];\n}\n\n\nint solve(vector<int> a, vector<int> b, int r){\n  int res = INF;\n  for(int i = min(r,(int) a.size());i >= 0 && b.size() >= r - i;i--){\n    res = min(res, gs(a, i) + gs(b, r - i));\n  }\n  return res;\n}\n\nint main(){\n  while(true){\n    int r;\n    cin >> r;\n    if(r == 0)return 0;\n    vector<int> a, b;\n    a = input_djk();\n    b = input_djk();\n    cout << solve(a, b, r) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\n\nconst int INF=1000000000;\nconst long long int INF_=1000000000000000000;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\ninline bool IsIn(int y,int x,int h,int w){\n\treturn 0<=y&&y<h&&0<=x&&x<w;\n}\n\nvoid BFS(vector<vector<int> > &f,vector<vector<int> > &l,int sy,int sx,int h,int w){\n\tvector<vector<int> > done(h,vector<int>(w));\n\tvector<vector<int> > done_(h,vector<int>(w));\n\tl[sy][sx]=1;\n\tdone[sy][sx]=done_[sy][sx]=1;\n\tqueue<Pi> que;\n\tREP(i,0,4){\n\t\tint ny=sy+dy[i],nx=sx+dx[i];\n\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\tdone_[ny][nx]=1;\n\t\tque.push(Pi(ny,nx));\n\t}\n\twhile(!que.empty()){\n\t\tPi p=que.front();\n\t\tque.pop();\n\t\tdone[p.F_][p.S_]=1;\n\t\tbool flag=true;\n\t\tint tmp=INF;\n\t\tREP(i,0,4){\n\t\t\tint ny=p.F_+dy[i],nx=p.S_+dx[i];\n\t\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\t\tif(done[ny][nx]==1) tmp=min(tmp,l[ny][nx]);\n\t\t\t//if(p.S_==2&&p.F_==1) cout << l[ny][nx] << endl;\n\t\t\tif(done[ny][nx]==1&&l[ny][nx]>=f[p.F_][p.S_]) flag=false;\n\t\t\tif(done_[ny][nx]!=1){\n\t\t\t\tdone_[ny][nx]=1;\n\t\t\t\tque.push(Pi(ny,nx));\n\t\t\t}\n\t\t}\n\t\t//if(p.S_==2&&p.F_==1) cout << tmp << endl << endl;\n\t\tif(flag) l[p.F_][p.S_]=f[p.F_][p.S_];\n\t\telse {\n\t\t\tif(tmp!=INF) l[p.F_][p.S_]=max(tmp,f[p.F_][p.S_]);\n\t\t\telse l[p.F_][p.S_]=f[p.F_][p.S_];\n\t\t}\n\t}\n}\n\ninline int f(int x){\n\tif(x==0) return 1;\n\telse if(x==1) return 0;\n}\n\nvoid solve(){\n\tint R;\n\twhile(cin >> R&&R){\n\t\tint W[2],H[2],X[2],Y[2];\n\t\tvector<vector<int> > field[2];\n\t\tvector<vector<int> > level[2];\n\t\tint max_[2]={};\n\t\tREP(i,0,2){\n\t\t\tcin >> W[i] >> H[i] >> X[i] >> Y[i];\n\t\t\t--X[i]; --Y[i];\n\t\t\tfield[i].resize(H[i]);\n\t\t\tlevel[i].resize(H[i]);\n\t\t\tREP(j,0,H[i]){\n\t\t\t\tfield[i][j].resize(W[i]);\n\t\t\t\tlevel[i][j].resize(W[i]);\n\t\t\t}\n\t\t\tREP(y,0,H[i]) REP(x,0,W[i]){\n\t\t\t\tcin >> field[i][y][x];\n\t\t\t\tmax_[i]=max(max_[i],field[i][y][x]);\n\t\t\t}\n\t\t\tBFS(field[i],level[i],Y[i],X[i],H[i],W[i]);\n\t\t\t/*\n\t\t\tcout << endl << endl;\n\t\t\tREP(y,0,H[i]){\n\t\t\t\tREP(x,0,W[i]) cout << level[i][y][x] << ' ';\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\tvector<unsigned short> s[2];\n\t\tREP(i,0,2) s[i].resize(max_[i]+1);\n\t\tREP(i,0,2) REP(y,0,H[i]) REP(x,0,W[i]) ++s[i][level[i][y][x]];\n\t\tREP(i,0,2) REP(j,1,max_[i]+1) s[i][j]+=s[i][j-1];\n\t\tint result=INF;\n\t\tREP(i,0,2){\n\t\t\tfor(int j=0; j<=max_[i]&&j<=result; ++j){\n\t\t\t\tint idx=(int)(lower_bound(s[i].begin(),s[i].end(),R-s[f(i)][j])-s[i].begin());\n\t\t\t\tif(!(0<=idx&&idx<=max_[i])) continue;\n\t\t\t\tresult=min(result,j+idx);\n\t\t\t}\n\t\t}\n\t\tcout << result << endl;\n\t}\n}\n\nint main(){\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <utility>\n#include <queue>\n#include <map>\n#include <complex>\n#define fir first\n#define sec second\n#define sz(s) (s).size()\n#define pb push_back\n#define get(n) scanf(\"%d\",&n);\n#define gets(s) string s;cin >> (s);\n#define prfi(n) printf(\"%d\", &n);\n#define prfd(n) printf(\"%lf\", &n);\n#define All(s) (s).begin(), (s).end()\n#define rep(i,j) for(int (i)=0;(i)<(j);(i)++)\n#define For(i,j,k) for(int (i)=(j);(i)<(k);(i)++)\n#define drep(i,j) for(int (i)=(j);(i)>=0;(i)--)\n#define Ford(i,j,k) for(int (i)=(j);i>=(k);i--)\n#define fore(c,v) for(auto (c): (v))\n#define lp for(int __=0;__<n;i++)\n#define mem(a,b) memset(a,b,sizeof(a));\n#define dump(x)  std::cout << #x << \" = \" << (x) << std::endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nusing ull = unsigned long long int;\nusing ll = long long;\nusing ld = long double;\nusing pii = std::pair<int,int>;\nusing pll = std::pair<ll, ll>;\nusing vi = std::vector<int> ;\nusing vvi = std::vector<vi> ;\nusing vll = std::vector<ll>;\nusing vvll = std::vector<vll>;\nusing vd = std::vector<double> ;\nusing vvd = std::vector<vd> ;\nusing qi = std::queue<int> ;\nusing vpii = std::vector<std::pair<int, int> >;\nusing vpll = std::vector<pll>;\nusing namespace std;\n\nconst int Mod = (1e9) + 7;\nconst int INF = 1e9 + 19;\nconst ll INFL = 1e18 + 19;\nconst int dx[] = {-1, 0, 0, 1};\nconst int dy[] = {0, -1, 1, 0};\nconst int dx2[] = {-1, -1, -1, 0, 0, 0, 1, 1, 1};\nconst int dy2[] = {1, 0, -1, 1, 0, -1, 1, 0, -1};\nconst double EPS = 1e-10;\n//_____________________________________Templates_________________________________________//\n\ntemplate<class T1, class T2> inline void chmin(T1 &a, T2 b){if(a > b) a = b;}\ntemplate<class T1, class T2> inline void chmax(T1 &a, T2 b){if(a < b) a = b;}\ntemplate<class T> inline void pri(T a){cout << a << endl;}\ntemplate<class Z> using vec = vector<Z>;\ntemplate<class T> using min_priority_queue = priority_queue<T, vector<T>, greater<T>>;\n//mainly use for dynamic prog\ntemplate<class T1, class T2>\nvoid update(T1 &a, T2 b){\n  a += b;\n  if(a > Mod) a %= Mod;\n}\n\ninline void IN(void){\n  return;\n}\n\ntemplate <typename First, typename... Rest>\nvoid IN(First& first, Rest&... rest){\n  cin >> first;\n  IN(rest...);\n  return;\n}\n\ninline void OUT(void){\n  cout << \"\\n\";\n  return;\n}\n\ntemplate <typename First, typename... Rest>\nvoid OUT(First first, Rest... rest){\n  cout << first << \" \";\n  OUT(rest...);\n  return;\n}\n\nbool pairsort(pll pl, pll pr){\n  if(pl.first == pr.first)return pl.second > pr.second;\n  return pl.first < pr.first;\n}\n\nint cntbit(ll a,int n,int j){int res = 0;For(i,j,n){if(a>>i & 1){res++;}}return res;}\nvector<int> make_bit(int a){vector<int> res; for(int i=31;i>=0;i--)if(a&(1<<i))res.pb(i);return res;}\nbool stdbit(int a, int b){return a&(1 << b); }\nint GCD(int a, int b){if(b > a)return GCD(b,a);if(a%b == 0)return b;else return GCD(b, a%b);}\nint LCM(int a, int b){return a*b/GCD(a,b);}\nint roundup(int a, int b){if(a % b == 0)return a/b;else return (a+b)/b;}\nint rounddown(int a, int b){if(a%b == 0)return a/b;else {return (a-b)/b;}}\nll pow(ll a, ll n){ll res = 1;while(n > 0){if(n&1)res *= a; a *= a; n = n >> 1;}return res;}\nll GetDiviserCount(ll N)//約数の個数\n{\n  ll res = 1;\n  For(i,2,sqrt(N)+1)\n  {\n    ll cnt = 0;\n    while(N%i == 0)\n    {\n      cnt++;\n      N /= i;\n    }\n    res *= (cnt + 1);\n    if(N == 1)break;\n  }\n  if(N != 1)res *= 2;\n  return res;\n}\nvll GetDivisor(ll N)//約数列挙\n{\n  vll res;\n  for(ll i = 1;i*i <= N;i++)\n  {\n    if(N%i == 0)\n    {\n      res.pb(i);\n      if(i*i != N)res.pb(N/i);\n    }\n  }\n  sort(All(res));\n  return res;\n}\n\n\nstruct mint {\n  ll x; // typedef long long ll;\n  mint(ll x=0):x((x%Mod+Mod)%Mod){}\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) {\n    if ((x += a.x) >= Mod) x -= Mod;\n    return *this;\n  }\n  mint& operator-=(const mint a) {\n    if ((x += Mod-a.x) >= Mod) x -= Mod;\n    return *this;\n  }\n  mint& operator*=(const mint a) {\n    (x *= a.x) %= Mod;\n    return *this;\n  }\n  mint operator+(const mint a) const {\n    mint res(*this);\n    return res+=a;\n  }\n  mint operator-(const mint a) const {\n    mint res(*this);\n    return res-=a;\n  }\n  mint operator*(const mint a) const {\n    mint res(*this);\n    return res*=a;\n  }\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n \n  // for prime mod\n  mint inv() const {\n    return pow(Mod-2);\n  }\n  mint& operator/=(const mint a) {\n    return (*this) *= a.inv();\n  }\n  mint operator/(const mint a) const {\n    mint res(*this);\n    return res/=a;\n  }\n  friend ostream& operator<<(ostream& os, const mint& a);\n};\nostream& operator<<(ostream& os, const mint& a)\n{\n  os << a.x;\n  return os;\n}\nstruct combination {\n  vector<mint> fact, ifact;\n  combination(int n):fact(n+1),ifact(n+1) {\n    assert(n < Mod);\n    fact[0] = 1;\n    for (int i = 1; i <= n; ++i) fact[i] = fact[i-1]*i;\n    ifact[n] = fact[n].inv();\n    for (int i = n; i >= 1; --i) ifact[i-1] = ifact[i]*i;\n  }\n  mint operator()(int n, int k) {\n    if (k < 0 || k > n) return 0;\n    return fact[n]*ifact[k]*ifact[n-k];\n  }\n};\n \n//_____________________　following sorce code_________________________//\nconst int max_n = 3 * (1e5) + 1;\nconst int max_m = 83 * (1e5) + 1;\n\nint n,m,k;\nll N;\nint h,w;\nvvi tree;\nstring S;\nint a,b,c;\nvi v;\nint ans;\ndouble x,y,z;\nint R;\nint W[2], H[2], X[2], Y[2];\nvi room[2];\nvi level[2];\nint L[2][505][505];\nbool visi[2][505][505];\nvoid init(int k)\n{\n  IN(W[k], H[k], X[k], Y[k]);\n  X[k]--;\n  Y[k]--;\n  room[k].clear();\n  level[k].clear();\n  rep(i,H[k])rep(j,W[k])\n  {\n    IN(L[k][i][j]);\n    visi[k][i][j] = false;\n  }\n}\nstruct Dat\n{\n  int v, x, y;\n  Dat () {}\n  Dat(int v,int x, int y) : v(v), x(x), y(y){}\n  bool operator>(const Dat &a) const{return v>a.v;}\n};\n\nint dfs(Dat e, int k, min_priority_queue<Dat> &qu)\n{\n  int res = 1;\n  visi[k][e.y][e.x] = true;\n  rep(i,4)\n  {\n    int x = e.x + dx[i];\n    int y = e.y + dy[i];\n    Dat d = Dat(e.v, x, y);\n    if(x >= 0 and x < W[k] and y >= 0 and y < H[k] and !visi[k][y][x])\n    {\n      if(L[k][y][x] <= e.v)res += dfs(d, k, qu);\n      else \n      {\n        //dump(d.v);\n        d.v = L[k][y][x];\n        qu.push(d);\n      }\n    }\n  }\n  //OUT(-1);\n  return res;\n}\n\nvoid calc(int k)\n{\n  min_priority_queue<Dat> qu;\n  room[k].push_back(0);\n  level[k].push_back(0);\n  qu.push({1,X[k],Y[k]});\n  while(!qu.empty())\n  {\n    auto e = qu.top(); qu.pop();\n    //dump(e.v);\n    if(visi[k][e.y][e.x])continue;\n    room[k].push_back(dfs(e,k,qu) + room[k][room[k].size()-1]);\n    level[k].push_back(e.v);\n  }\n}\n\nsigned main (int argc, char* argv[]) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  while(1)\n  {\n    IN(R);\n    if(R == 0)return 0;\n    init(0); init(1);\n    rep(i,2)calc(i);\n    int ans = INF;\n    rep(i,sz(room[0]))\n    {\n      int rom = room[0][i];\n      int idx = lower_bound(All(room[1]), R - rom) - room[1].begin();\n      if(idx < room[1].size())\n      {\n        chmin(ans, level[0][i] + level[1][idx]);\n      }\n    }\n    /*\n    OUT();\n    fore(e,level[0])cout << e << \" \";\n    OUT();\n    fore(e, room[0])cout << e << \" \";\n    OUT();\n    fore(e,level[1])cout << e << \" \";\n    OUT();\n    fore(e, room[1])cout << e << \" \";\n    OUT();\n    */\n    cout << ans << endl;\n  }\n  //for(auto c : ans){cout << c << endl;}\n  //cout << fixed << setprecision(15) << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (1) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nstruct state {\n\tint sx, sy, cost;\n};\nbool operator<(const state& s1, const state& s2) {\n\treturn s1.cost < s2.cost;\n}\nint R, H[2], W[2], sx[2], sy[2], a[2][509][509], cnt[2], b[2][250009], vis[509][36];\nint dir[] = { 0, 1, 0, -1 };\nint main() {\n\twhile (scanf(\"%d\", &R), R) {\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tscanf(\"%d%d%d%d\", &W[i], &H[i], &sy[i], &sx[i]); sy[i]--, sx[i]--;\n\t\t\tfor (int j = 0; j < H[i]; j++) {\n\t\t\t\tfor (int k = 0; k < W[i]; k++) {\n\t\t\t\t\treader(&a[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpriority_queue<state> que; que.push(state{ sx[i], sy[i], -1 });\n\t\t\tmemset(vis, 0, sizeof(vis));\n\t\t\tvis[sx[i]][sy[i] >> 5] |= 1 << (sy[i] & 31); cnt[i] = 1;\n\t\t\twhile (!que.empty()) {\n\t\t\t\tstate u = que.top(); que.pop();\n\t\t\t\tb[i][cnt[i]++] = a[i][u.sx][u.sy];\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tint tx = u.sx + dir[j], ty = u.sy + dir[j ^ 1];\n\t\t\t\t\tif (0 <= tx && tx < H[i] && 0 <= ty && ty < W[i] && !(vis[tx][ty >> 5] & (1 << (ty & 31)))) {\n\t\t\t\t\t\ta[i][tx][ty] = max(a[i][tx][ty], a[i][u.sx][u.sy]);\n\t\t\t\t\t\tvis[tx][ty >> 5] |= 1 << (ty & 31);\n\t\t\t\t\t\tque.push(state{ tx, ty, -a[i][tx][ty] });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 2000000009;\n\t\tfor (int i = 0; i <= H[0] * W[0]; i++) {\n\t\t\tint z = max(R - i, 0);\n\t\t\tif (z > H[1] * W[1]) continue;\n\t\t\tret = min(ret, b[0][i] + b[1][z]);\n\t\t}\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf=1<<30;\nint maps[2][510][510];\nbool visited[2][510][510];\nint cnt[2][250010];\nint r,w[2],h[2],sx[2],sy[2];\nconst int dx[]={1,-1,0,0},dy[]={0,0,1,-1};\nvoid calc(){\n\tfor(int k=0;k<2;k++){\n\t\tint room=0,level=0;\n\t\tpriority_queue<tuple<int,int,int>> pq;\n\t\tfor(int i=0;i<=h[k];i++)\tvisited[k][i][0]=visited[k][i][w[k]+1]=true;\n\t\tfor(int i=0;i<=w[k];i++)\tvisited[k][0][i]=visited[k][h[k]+1][i]=true;\n\t\tpq.push(make_tuple(-1,sx[k],sy[k]));\n\t\twhile(!pq.empty()&&room<h[k]*w[k]){\n\t\t\tauto now=pq.top();\tpq.pop();\n\t\t\tint l=-get<0>(now),x=get<1>(now),y=get<2>(now);\n\t\t\tif(visited[k][y][x])\tcontinue;\n\t\t\tvisited[k][y][x]=true;\n\t\t\tif(level<l)\tlevel=l;\n\t\t\troom++;\tcnt[k][room]=level;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint ny=y+dy[i],nx=x+dx[i];\n\t\t\t\tif(visited[k][ny][nx])\tcontinue;\n\t\t\t\tpq.push(make_tuple(-maps[k][ny][nx],nx,ny));\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile(true){\n\t\tcin>>r;\n\t\tif(r==0)\treturn 0;\n\t\tmemset(maps,0,sizeof(maps));\n\t\tfor(int k=0;k<2;k++){\n\t\t\tfor(int i=1;i<100010;i++) cnt[k][i]=inf;\n\t\t\tcnt[k][0]=0;\n\t\t\tfor(int i=0;i<510;i++){\n\t\t\t\tfor(int j=0;j<510;j++)\tvisited[k][i][j]=false;\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<2;k++){\n\t\t\tcin>>w[k]>>h[k]>>sx[k]>>sy[k];\n\t\t\tfor(int i=1;i<=h[k];i++){//区画の外側を壁で覆う\n\t\t\t\tfor(int j=1;j<=w[k];j++)\tcin>>maps[k][i][j];\n\t\t\t}\n\t\t}\n\t\tcalc();\n\t\tfor(int k=0;k<2;k++){\n\t\t\tint tmp=inf;\n\t\t\tfor(int i=w[k]*h[k];i>=0;i--){\n\t\t\t\ttmp=min(tmp,cnt[k][i]);\n\t\t\t\tcnt[k][i]=tmp;\n\t\t\t}\n\t\t}\n\t\tint ans=inf;\n\t\tfor(int i=0;i<=r;i++){\n\t\t\tif(i>h[0]*w[0]||r-i>h[1]*w[1])\tcontinue;\n\t\t\tans=min(ans,cnt[0][i]+cnt[1][r-i]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint w[2], h[2], x[2], y[2];\t// z[ÌAs«, Gx[^ÌÊu(x,y)\n\nint  R[2][500][500];\nbool v[500][500];\n\t\nP bfs (int currk, int floor, P e, int k )\n{\n\tconst int dx[] = { 0, 1, 0, -1 };\n\tconst int dy[] = {-1, 0, 1,  0 };\n\n\tqueue<P> que;\n\tque.push (e );\n\tint res = 0;\n\tint mink = k;\n\n\tmemset (v, false, sizeof (v ) );\n\n\twhile (!que.empty() ){\n\t\tP curr = que.front(); que.pop();\n\t\tint r = curr.first, c = curr.second;\n\t\tv[r][c] = true;\n\t\tres++;\n\t\trep (k, 4 ){\n\t\t\tint nr = r + dy[k], nc = c + dx[k];\n\t\t\tif (nr < 0 || nr >= h[floor] || nc < 0 || nc >= w[floor] )\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tif (R[floor][nr][nc] > currk ){\n\t\t\t\tmink = min (mink, R[floor][nr][nc] );\n\t\t\t\tcontinue;\n\t\t\t} // end if \n\t\t\tif (v[nr][nc] )\n\t\t\t\tcontinue;\n\t\t\tque.push (P (nr, nc ) );\n\t\t} // end rep\n\t} // end while\n\n\treturn P(res, mink );\n}\n\nint main()\n{\n\tint r;\n\n\twhile (cin >> r && r ){\t// Kêé®Ì (Åá±ÌÌ®ðKêé)\n\t\tmemset (R, 0, sizeof (R ) );\n\t\tvector <int> maxk (2, 0 );\n\t\trep (k, 2 ){\n\t\t\tcin >> w[k] >> h[k] >> x[k] >> y[k];\t\n\t\t\tx[k]--, y[k]--;\n\t\t\trep (i, h[k] ){\n\t\t\t\trep (j, w[k] ){\n\t\t\t\t\tcin >> R[k][i][j];\n\t\t\t\t\tmaxk[k] = max (maxk[k], R[k][i][j] );\n\t\t\t\t} // end rep\n\t\t\t} // end rep\n\t\t} // end rep\n\t\n\t\tint res = 0;\n\t\tvector <P> curr (2); // »ÝÌKê½etAÌ®Ì,@etAÌ»ÝÌZLeBx \n\t\trep (i, 2 ){\n\t\t\tcurr[i].first = 0;\n\t\t\tcurr[i].second = R[i][y[i]][x[i]];\n\t\t} // end rep\n\t\tbool found = false;\n\t\twhile (1) {\n\t\t\tvector <P> pre = curr;\n\t\t\trep (i, 2 ){\n\t\t\t\tcurr[i] = bfs (curr[i].second, i, P(y[i], x[i] ), maxk[i] );\n\t\t\t\tif (curr[i].first >= r ){\n\t\t\t\t\tres = pre[i].second;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t} // end if\n\t\t\t} // end if\n\t\t\tif (found )\n\t\t\t\tbreak;\n\t\t\tif (curr[0].first + curr[1].first >= r ){\n\t\t\t\tres = pre[0].second + pre[1].second;\n\t\t\t\tbreak;\n\t\t\t} // end if\n\t\t} // end while\n\t\tcout << res << endl;\t\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb push_back\n#define mp make_pair\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,-1,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pint pair<int,int>\n#define INF 1<<29\n#define MAX 501\nusing namespace std;\n \nint R,W[2],H[2],X[2],Y[2],L[2][MAX][MAX],d[2][MAX][MAX],dd[4]={0,-1,0,1};\nmap<int,int> m[2];\nmap<int,int>::iterator ite;\nvector<int> lev[2],sum[2];\n \nvoid solve(){\n for(;;){\n  cin>>R;\n  if(!R) return;\n  FOR(i,2){\n   cin>>W[i]>>H[i]>>X[i]>>Y[i];\n   X[i]--;\n   Y[i]--;\n   FOR(j,H[i]) FOR(k,W[i]) cin>>L[i][j][k];\n   FOR(j,H[i]) FOR(k,W[i]) d[i][j][k]=INT_MAX/3;\n   d[i][X[i]][Y[i]]=1;\n   priority_queue<pint,vector<pint>,greater<pint>> pque;\n   pque.push(mp(1,X[i]*W[i]+Y[i]));\n   while(!pque.empty()){\n    pint p=pque.top(); pque.pop();\n    int x=p.second/W[i],y=p.second%W[i];\n    if(d[i][x][y]<p.first) continue;\n    FOR(j,4){\n     int nx=x+dd[j],ny=y+dd[j^1];\n     if(nx<0||ny<0||nx>=H[i]||ny>=W[i]) continue;\n     if(d[i][nx][ny]>max(d[i][x][y],L[i][nx][ny])){\n      d[i][nx][ny]=max(d[i][x][y],L[i][nx][ny]);\n      pque.push(mp(d[i][nx][ny],nx*W[i]+ny));\n     }\n    }\n   }\n   FOR(j,H[i]) FOR(k,W[i]) m[i][d[i][j][k]]++;\n   int tot=0;\n   lev[i].pb(0);\n   sum[i].pb(0);\n   for(ite=m[0].begin();ite!=m[0].end();ite++){\n    lev[i].pb(ite->first);\n    tot+=ite->second;\n    sum[i].pb(tot);\n   }\n  }\n  sum[1].pb(INT_MAX);\n  int mi=1<<30;\n  FOR(i,lev[0].size()){\n   int ind=lower_bound(ALL(sum[1]),R-sum[0][i])-sum[1].begin();\n   if(sum[1][ind]==INT_MAX) continue;\n   mi=min(mi,lev[1][ind]+lev[0][i]);\n  }\n  cout<<mi<<endl;\n  FOR(i,2){\n   m[i].clear();\n   lev[i].clear();\n   sum[i].clear();\n  }\n }\n}\n \nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb push_back\n#define mp make_pair\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,-1,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pint pair<int,int>\n#define INF 1<<29\n#define MAX 501\nusing namespace std;\n \nint R,W[2],H[2],X[2],Y[2],L[2][MAX][MAX],d[2][MAX][MAX],dd[4]={0,-1,0,1};\nmap<int,int> m[2];\nmap<int,int>::iterator ite;\nvector<int> lev,sum;\n \nvoid solve(){\n for(;;){\n  cin>>R;\n  if(!R) return;\n  FOR(i,2){\n   cin>>W[i]>>H[i]>>X[i]>>Y[i];\n   X[i]--;\n   Y[i]--;\n   FOR(j,H[i]) FOR(k,W[i]) cin>>L[i][j][k];\n   FOR(j,H[i]) FOR(k,W[i]) d[i][j][k]=INT_MAX/3;\n   d[i][X[i]][Y[i]]=1;\n   priority_queue<pint,vector<pint>,greater<pint>> pque;\n   pque.push(mp(1,X[i]*W[i]+Y[i]));\n   while(!pque.empty()){\n    pint p=pque.top(); pque.pop();\n    int x=p.second/W[i],y=p.second%W[i];\n    if(d[i][x][y]<p.first) continue;\n    FOR(j,4){\n     int nx=x+dd[j],ny=y+dd[j^1];\n     if(nx<0||ny<0||nx>=H[i]||ny>=W[i]) continue;\n     if(d[i][nx][ny]>max(d[i][x][y],L[i][nx][ny])){\n      d[i][nx][ny]=max(d[i][x][y],L[i][nx][ny]);\n      pque.push(mp(d[i][nx][ny],nx*W[i]+ny));\n     }\n    }\n   }\n   FOR(j,H[i]) FOR(k,W[i]) m[i][d[i][j][k]]++;\n   int tot=0;\n   lev[i].pb(0);\n   sum[i].pb(0);\n   for(ite=m[0].begin();ite!=m[0].end();ite++){\n    lev[i].pb(ite->first);\n    tot+=ite->second;\n    sum[i].pb(tot);\n   }\n  }\n  int mi=1<<30;\n  FOR(i,lev[0].size()){\n   int ind=lower_bound(ALL(sum[1]),R-sum[0])-sum[1].begin();\n   mi=min(mi,lev[ind]+lev[i]);\n  }\n  cout<<mi<<endl;\n  FOR(i,2){\n   m[i].clear();\n   lev[i].clear();\n   sum[i].clear();\n  }\n }\n}\n \nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint w,h,x,y,a[505][505],b[505][505],c[505][505];\n\npair<int,int> make_P(int ma,int mb){pair<int,int> ret; ret.first=ma; ret.second=mb; return ret;}\n\npair<int,pair<int,int>> make_PP(int ma,pair<int,int> mb){pair<int,pair<int,int>> ret; ret.first=ma; ret.second=mb; return ret;}\n\nbool f(pair<int,pair<int,int>> fx,pair<int,pair<int,int>> fy){return fx.first<=fy.first;}\n\nvoid ww(int wx,int wy){\n\tc[wx][wy]=1;\n\tif(b[wx][wy+1]==1&&c[wx][wy+1]==0)ww(wx,wy+1);\n\tif(b[wx][wy-1]==1&&c[wx][wy-1]==0)ww(wx,wy-1);\n\tif(b[wx+1][wy]==1&&c[wx+1][wy]==0)ww(wx+1,wy);\n\tif(b[wx-1][wy]==1&&c[wx-1][wy]==0)ww(wx-1,wy);\n}\n\nvector<int> els(vector<int> vp){\n\tvector<int> ret;\n\tint s=vp.size();\n\tret.push_back(vp[0]);\n\tfor(int i=1;i<s;i++){\n\t\tif(vp[i]!=vp[i-1])ret.push_back(vp[i]);\n\t}\n\treturn ret;\n}\n\nvector<pair<int,int>> office(){\n\tfor(int i=0;i<505;i++)for(int j=0;j<505;j++){b[i][j]=0; c[i][j]=0;}\n\tvector<pair<int,pair<int,int>>> v;\n\tfor(int i=1;i<=h;i++)for(int j=1;j<=h;j++)v.push_back(make_PP(a[i][j],make_P(i,j)));\n\tsort(v.begin(),v.end(),f);\n\t//v=els(v);\n\tvector<pair<int,int>> ret;\n\tret.push_back(make_P(0,0));\n\tint s=v.size();\n\tb[x][y]=1; c[x][y]=1;\n\tfor(int i=0;i<s;i++){\n\t\t/*for(int j=1;j<=h;j++)for(int k=1;k<=w;k++){\n\t\t\tif(a[j][k]==v[i]){\n\t\t\t\tb[j][k]=1;\n\t\t\t\tif(c[j][k+1]+c[j][k-1]+c[j+1][k]+c[j-1][k]!=0)ww(j,k);\n\t\t\t}\n\t\t}*/\n\t\tb[v[i].second.first][v[i].second.second]=1;\n\t\tif(c[v[i].second.first][v[i].second.second+1]+c[v[i].second.first][v[i].second.second-1]+c[v[i].second.first+1][v[i].second.second]+c[v[i].second.first-1][v[i].second.second]!=0)ww(v[i].second.first,v[i].second.second);\n\t\tint sum=0;\n\t\tfor(int j=1;j<=h;j++)for(int k=1;k<=w;k++)sum+=c[j][k];\n\t\tret.push_back(make_P(v[i].first,sum));\n\t}\n\treturn ret;\n}\n\nint main(){\nwhile(1){\n\tint r,s[2];\n\tscanf(\"%d\",&r);\n\tif(r==0)break;\n\tvector<pair<int,int>> vvp[2];\n\tfor(int i=0;i<=1;i++){\n\t\tfor(int k=0;k<505;k++)for(int j=0;j<505;j++)a[k][j]=0;\n\t\tscanf(\"%d%d%d%d\",&w,&h,&x,&y);\n\t\tfor(int j=1;j<=h;j++)for(int k=1;k<=w;k++)scanf(\"%d\",&a[j][k]);\n\t\tvvp[i]=office();\n\t\ts[i]=vvp[i].size();\n\t}\n\tint n=s[1]-1,ret=200000000;\n\tfor(int i=0;i<s[0];i++){\n\t\tif(n!=0)while(vvp[0][i].second+vvp[1][n-1].second>=r){n--; if(n==0)break;}\n\t\tif(vvp[0][i].second+vvp[1][n].second>=r)ret=min(ret,vvp[0][i].first+vvp[1][n].first);\n\t}\n\tprintf(\"%d\\n\",ret);\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <tuple>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\nconst vector<int> dx = { 0, 1, 0, -1 };\nconst vector<int> dy = { -1, 0, 1, 0 };\n\nint R, W[2], H[2], X[2], Y[2], F[2][500][500], D[2][500][500], L[2];\n\nint main()\n{\n\tscanf(\"%d\", &R);\n\n\tfor (int i = 0; i < 2; i++)\n\t{\n\t\tscanf(\"%d\", &W[i]);\n\t\tscanf(\"%d\", &H[i]);\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\n\t\tfor (int j = 0; j < H[i]; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < W[i]; k++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &F[i][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\n\tmemset(D, -1, sizeof(D));\n\n\tfor (int i = 0; i < 2; i++)\n\t{\n\t\tD[i][Y[i]][X[i]] = 1;\n\n\t\tpriority_queue<tuple<int, int, int>, vector<tuple<int, int, int> >, greater<tuple<int, int, int> > > que;\n\n\t\tque.push(make_tuple(0, X[i], Y[i]));\n\n\t\twhile (!que.empty())\n\t\t{\n\t\t\ttuple<int, int, int> state = que.top(); que.pop();\n\n\t\t\tint d = get<0>(state);\n\t\t\tint x = get<1>(state);\n\t\t\tint y = get<2>(state);\n\n\t\t\tfor (int dir = 0; dir < 4; dir++)\n\t\t\t{\n\t\t\t\tint x2 = x + dx[dir];\n\t\t\t\tint y2 = y + dy[dir];\n\n\t\t\t\tif (0 <= x2 && x2 < W[i] && 0 <= y2 && y2 < H[i])\n\t\t\t\t{\n\t\t\t\t\tif (D[i][y2][x2] == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tD[i][y2][x2] = max(d, F[i][y2][x2]);\n\n\t\t\t\t\t\tque.push(make_tuple(D[i][y2][x2], x2, y2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<int> E[2];\n\n\tfor (int i = 0; i < 2; i++)\n\t{\n\t\tfor (int j = 0; j < H[i]; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < W[i]; k++)\n\t\t\t{\n\t\t\t\tE[i].push_back(F[i][j][k]);\n\t\t\t}\n\t\t}\n\n\t\tsort(E[i].begin(), E[i].end());\n\t}\n\n\tint ret = 999999999;\n\n\tfor (int i = 0; i <= R; i++)\n\t{\n\t\tL[0] = i;\n\t\tL[1] = R - i;\n\n\t\tint cost = 0;\n\n\t\tfor (int j = 0; j < 2; j++)\n\t\t{\n\t\t\tint cl = 0;\n\t\t\tint cr = 100000000;\n\n\t\t\twhile (cr - cl > 1)\n\t\t\t{\n\t\t\t\tint cm = (cl + cr) / 2;\n\n\t\t\t\tint counts = upper_bound(E[j].begin(), E[j].end(), cm) - E[j].begin();\n\n\t\t\t\tif (counts < L[0])\n\t\t\t\t{\n\t\t\t\t\tcl = cm;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcr = cm;\n\t\t\t\t}\n\n\t\t\t\tcost += cr;\n\t\t\t}\n\t\t}\n\n\t\tret = min(ret, cost);\n\t}\n\n\tprintf(\"%d\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <utility>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <cstring>\nusing namespace std;\n#define INF 200000000\n\nint ary1[510][510],ary2[510][510];\nbool used[510][510];\nint main(){\n\tint R,W1,W2,H1,H2,X1,X2,Y1,Y2,imax,imay,imad,res;\n\tpriority_queue<pair<int,pair<int,int> > ,vector<pair<int,pair<int,int> > >,greater<pair<int,pair<int,int> > > > que;\n\tset<int> se1,se2;\n\tvector<int> v1,v2;\n\tpair<int,pair<int,int> > pa;\n\twhile(1){\n\t\tv1.clear();\n\t\tv2.clear();\n\t\tcin>>R;\n\t\tif(R==0) break;\n\t\tcin>>W1>>H1>>Y1>>X1;\n\t\tX1--;Y1--;\n\t\tfor(int i=0;i<H1;i++){\n\t\t\tfor(int j=0;j<W1;j++){\n\t\t\t\tcin>>ary1[i][j];\n\t\t\t}\n\t\t}\n\t\tcin>>W2>>H2>>Y2>>X2;\n\t\tX2--;Y2--;\n\t\tfor(int i=0;i<H2;i++){\n\t\t\tfor(int j=0;j<W2;j++){\n\t\t\t\tcin>>ary2[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemset(used,0,sizeof(used));\n\t\tque.push(make_pair(1,make_pair(X1,Y1)));\n\t\tused[X1][Y1]=true;\n\t\twhile(!que.empty()){\n\t\t\tpa=que.top();que.pop();\n\t\t\timax=pa.second.first;\n\t\t\timay=pa.second.second;\n\t\t\timad=pa.first;\n\t\t\tary1[imax][imay]=imad;\n\t\t\tif(imax>0&&(!used[imax-1][imay])){\n\t\t\t\tused[imax-1][imay]=true;\n\t\t\t\tque.push(make_pair(max(ary1[imax-1][imay],imad),make_pair(imax-1,imay)));\n\t\t\t}\n\t\t\tif(imax<H1-1&&(!used[imax+1][imay])){\n\t\t\t\tused[imax+1][imay]=true;\n\t\t\t\tque.push(make_pair(max(ary1[imax+1][imay],imad),make_pair(imax+1,imay)));\n\t\t\t}\n\t\t\tif(imay>0&&(!used[imax][imay-1])){\n\t\t\t\tused[imax][imay-1]=true;\n\t\t\t\tque.push(make_pair(max(ary1[imax][imay-1],imad),make_pair(imax,imay-1)));\n\t\t\t}\n\t\t\tif(imay<W1-1&&(!used[imax][imay+1])){\n\t\t\t\tused[imax][imay+1]=true;\n\t\t\t\tque.push(make_pair(max(ary1[imax][imay+1],imad),make_pair(imax,imay+1)));\n\t\t\t}\n\t\t}\n\t\tmemset(used,0,sizeof(used));\n\t\tque.push(make_pair(1,make_pair(X2,Y2)));\n\t\tused[X2][Y2]=true;\n\t\twhile(!que.empty()){\n\t\t\tpa=que.top();que.pop();\n\t\t\timax=pa.second.first;\n\t\t\timay=pa.second.second;\n\t\t\timad=pa.first;\n\t\t\tary2[imax][imay]=imad;\n\t\t\tif(imax>0&&(!used[imax-1][imay])){\n\t\t\t\tused[imax-1][imay]=true;\n\t\t\t\tque.push(make_pair(max(ary2[imax-1][imay],imad),make_pair(imax-1,imay)));\n\t\t\t}\n\t\t\tif(imax<H2-1&&(!used[imax+1][imay])){\n\t\t\t\tused[imax+1][imay]=true;\n\t\t\t\tque.push(make_pair(max(ary2[imax+1][imay],imad),make_pair(imax+1,imay)));\n\t\t\t}\n\t\t\tif(imay>0&&(!used[imax][imay-1])){\n\t\t\t\tused[imax][imay-1]=true;\n\t\t\t\tque.push(make_pair(max(ary2[imax][imay-1],imad),make_pair(imax,imay-1)));\n\t\t\t}\n\t\t\tif(imay<W2-1&&(!used[imax][imay+1])){\n\t\t\t\tused[imax][imay+1]=true;\n\t\t\t\tque.push(make_pair(max(ary2[imax][imay+1],imad),make_pair(imax,imay+1)));\n\t\t\t}\n\t\t}\n\t\tv1.push_back(0);\n\t\tfor(int i=0;i<H1;i++){\n\t\t\tfor(int j=0;j<W1;j++){\n\t\t\t\tv1.push_back(ary1[i][j]);\n\t\t\t}\n\t\t}\n\t\tsort(v1.begin(),v1.end());\n\t\tv2.push_back(0);\n\t\tfor(int i=0;i<H2;i++){\n\t\t\tfor(int j=0;j<W2;j++){\n\t\t\t\tv2.push_back(ary2[i][j]);\n\t\t\t}\n\t\t}\n\t\tsort(v2.begin(),v2.end());\n\t\tres=INF;\n\t\tfor(int i=0;i<=R;i++){\n\t\t\tif(W1*H1>=i&&W2*H2>=R-i)res=min(res,v1.at(i)+v2.at(R-i));\n\t\t}\n\t\tcout<<res<<endl;\n\n\t\t/*for(int i=0;i<H1;i++){\n\t\t\tfor(int j=0;j<W1;j++){\n\t\t\t\tcout<<ary1[i][j]<<\" \";\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t\tfor(int i=0;i<H2;i++){\n\t\t\tfor(int j=0;j<W2;j++){\n\t\t\t\tcout<<ary2[i][j]<<\" \";\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}*/\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (1) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nstruct state {\n\tint sx, sy, cost;\n};\nbool operator<(const state& s1, const state& s2) {\n\treturn s1.cost < s2.cost;\n}\nint R, H[2], W[2], sx[2], sy[2], a[2][509][509], cnt[2], b[2][250009]; bool vis[509][509];\nint dir[] = { 0, 1, 0, -1 };\nint main() {\n\twhile (scanf(\"%d\", &R), R) {\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tscanf(\"%d%d%d%d\", &W[i], &H[i], &sy[i], &sx[i]); sy[i]--, sx[i]--;\n\t\t\tfor (int j = 0; j < H[i]; j++) {\n\t\t\t\tfor (int k = 0; k < W[i]; k++) {\n\t\t\t\t\treader(&a[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpriority_queue<state> que; que.push(state{ sx[i], sy[i], -1 });\n\t\t\tmemset(vis, 0, sizeof(vis));\n\t\t\tvis[sx[i]][sy[i]] = true; cnt[i] = 1;\n\t\t\twhile (!que.empty()) {\n\t\t\t\tstate u = que.top(); que.pop();\n\t\t\t\tb[i][cnt[i]++] = a[i][u.sx][u.sy];\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tint tx = u.sx + dir[j], ty = u.sy + dir[j ^ 1];\n\t\t\t\t\tif (0 <= tx && tx < H[i] && 0 <= ty && ty < W[i] && !vis[tx][ty]) {\n\t\t\t\t\t\ta[i][tx][ty] = max(a[i][tx][ty], a[i][u.sx][u.sy]);\n\t\t\t\t\t\tvis[tx][ty] = true;\n\t\t\t\t\t\tque.push(state{ tx, ty, -a[i][tx][ty] });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 2000000009;\n\t\tfor (int i = 0; i <= H[0] * W[0]; i++) {\n\t\t\tint z = max(R - i, 0);\n\t\t\tif (z > H[1] * W[1]) continue;\n\t\t\tret = min(ret, b[0][i] + b[1][z]);\n\t\t}\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<functional>\n#include<vector>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\n#define T1 1000000\n#define T2 1000\n\nlong long W,H,X,Y,R;\nlong long x[1000][1000];\nlong long d[1000][1000];\nlong long p1,p2,p3;\nlong long y_1[1000000],y_2[1000000],cnt,cnt2,v,minx;\n\npriority_queue<long long,vector<long long>,greater<long long>> Q;\n\nint main(){\n\twhile(true){\n\t\tcnt=1;cnt2=1;minx=1145141919810;\n\t\tmemset(x,51,sizeof(x));\n\t\tmemset(d,51,sizeof(d));\n\t\tcin>>R;\n\t\tif(R==0){break;}\n\t\tcin>>W>>H>>X>>Y;\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tfor(int j=1;j<=W;j++){\n\t\t\t\tcin>>x[i][j];\n\t\t\t}\n\t\t}\n\t\td[Y][X]=0;\n\t\tQ.push(Y*T2+X);\n\t\twhile(!Q.empty()){\n\t\t\tp1=Q.top()/T1;\n\t\t\tp2=(Q.top()/T2)%T2;\n\t\t\tp3=Q.top()%T2;\n\t\t\tif(max(p1,x[p2-1][p3])<d[p2-1][p3]){\n\t\t\t\td[p2-1][p3]=max(p1,x[p2-1][p3]);\n\t\t\t\tQ.push(d[p2-1][p3]*T1+(p2-1)*T2+p3);\n\t\t\t}\n\t\t\tif(max(p1,x[p2+1][p3])<d[p2+1][p3]){\n\t\t\t\td[p2+1][p3]=max(p1,x[p2+1][p3]);\n\t\t\t\tQ.push(d[p2+1][p3]*T1+(p2+1)*T2+p3);\n\t\t\t}\n\t\t\tif(max(p1,x[p2][p3-1])<d[p2][p3-1]){\n\t\t\t\td[p2][p3-1]=max(p1,x[p2][p3-1]);\n\t\t\t\tQ.push(d[p2][p3-1]*T1+p2*T2+(p3-1));\n\t\t\t}\n\t\t\tif(max(p1,x[p2][p3+1])<d[p2][p3+1]){\n\t\t\t\td[p2][p3+1]=max(p1,x[p2][p3+1]);\n\t\t\t\tQ.push(d[p2][p3+1]*T1+p2*T2+(p3+1));\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tfor(int j=1;j<=W;j++){\n\t\t\t\ty_1[cnt]=d[i][j];\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tmemset(x,51,sizeof(x));\n\t\tmemset(d,51,sizeof(d));\n\t\tcin>>W>>H>>X>>Y;\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tfor(int j=1;j<=W;j++){\n\t\t\t\tcin>>x[i][j];\n\t\t\t}\n\t\t}\n\t\td[Y][X]=0;\n\t\tQ.push(Y*T2+X);\n\t\twhile(!Q.empty()){\n\t\t\tp1=Q.top()/T1;\n\t\t\tp2=(Q.top()/T2)%T2;\n\t\t\tp3=Q.top()%T2;\n\t\t\tif(max(p1,x[p2-1][p3])<d[p2-1][p3]){\n\t\t\t\td[p2-1][p3]=max(p1,x[p2-1][p3]);\n\t\t\t\tQ.push(d[p2-1][p3]*T1+(p2-1)*T2+p3);\n\t\t\t}\n\t\t\tif(max(p1,x[p2+1][p3])<d[p2+1][p3]){\n\t\t\t\td[p2+1][p3]=max(p1,x[p2+1][p3]);\n\t\t\t\tQ.push(d[p2+1][p3]*T1+(p2+1)*T2+p3);\n\t\t\t}\n\t\t\tif(max(p1,x[p2][p3-1])<d[p2][p3-1]){\n\t\t\t\td[p2][p3-1]=max(p1,x[p2][p3-1]);\n\t\t\t\tQ.push(d[p2][p3-1]*T1+p2*T2+(p3-1));\n\t\t\t}\n\t\t\tif(max(p1,x[p2][p3+1])<d[p2][p3+1]){\n\t\t\t\td[p2][p3+1]=max(p1,x[p2][p3+1]);\n\t\t\t\tQ.push(d[p2][p3+1]*T1+p2*T2+(p3+1));\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tfor(int j=1;j<=W;j++){\n\t\t\t\ty_2[cnt2]=d[i][j];\n\t\t\t\tcnt2++;\n\t\t\t}\n\t\t}\n\n\t\tsort(y_1,y_1+cnt);\n\t\tsort(y_2,y_2+cnt2);\n\n\t\tfor(int i=0;i<cnt;i++){\n\t\t\tv=R-i;\n\t\t\tif(v>=0 && v<cnt2){\n\t\t\t\tminx=min(minx,y_1[i]+y_2[v]);\n\t\t\t}\n\t\t}\n\t\tcout<<minx<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\n\nint x[2],y[2],w[2],h[2];\nint R;\nvector<vvi> zimu;\n\nvoid dfs(int i, int x, int y, vvi& used, vector<pair<int,int>>& list){\n\n  priority_queue< pair<int,pii>, vector<pair<int,pii> >,greater<pair<int,pii> > > que;\n  que.push(pair<int,pii>(1,pii(x,y)));\n  used[y][x] = 1;\n\n  int auth = 1;\n  int room = 0;\n  while(que.size()){\n    int corr_lev = que.top().first;\n    int corr_x = que.top().second.first;\n    int corr_y = que.top().second.second;\n    //cout << corr_x << \" \" << corr_y << \" \" << corr_lev << endl;\n    que.pop();\n    used[corr_y][corr_x] = 1;\n\n    if(corr_lev > auth){\n      list.push_back(pii(room,auth));\n      auth = corr_lev;\n    }\n    room++;\n    if(room == w[i]*h[i]) break;\n\n    for(int j=0; j<4; j++){\n      int nx = corr_x + dx[j];\n      int ny = corr_y + dy[j];\n      if(nx >= w[i] || nx < 0 || ny >= h[i] || ny < 0) continue; // ????£?\n      if(used[ny][nx] == 1) continue; // ??¢?´¢??????\n      que.push( pair<int,pii>(zimu[i][ny][nx],pii(nx,ny)) );\n    }\n  }\n  list.push_back(pii(room,auth));\n}\n\nint main(){\n  while(1){\n  \n    cin >> R; if(!R) break;\n    zimu.clear();\n    \n    // ??\\???\n    for(int i=0; i<2; i++){\n      cin >> w[i] >> h[i] >> x[i] >> y[i];\n  \n      zimu.push_back(vvi(h[i],vi(w[i])));\n\n      for(int j=0; j<h[i]; j++)\n\tfor(int k=0; k<w[i]; k++)\n\t  cin >> zimu[i][j][k];\n    }\n\n    // \n    vector<vector<pair<int,int> > > list(2); // ???????????¨?±???°???????¨???¬??????\n    \n    for(int i=0; i<2; i++){\n      list[i].push_back(pii(0,0));\n      int lev=1;\n      int mini=1e+9;\n      vvi used(h[i],vi(w[i],0));\n      dfs(i, x[i]-1, y[i]-1, used, list[i]);\n    }\n    /*\n    for(int i=0; i<2; i++){\n      for(int j=0; j<list[i].size(); j++)\n\tcout << \"(\" << list[i][j].first << \",\" << list[i][j].second << \"), \";\n      cout << endl;\n    }\n    */\n\n    int ans = 1e+9;\n    for(int i=0; i<list[0].size(); i++){\n      int rooma = list[0][i].first;\n      int autha = list[0][i].second;\n      pii tmp = *lower_bound(list[1].begin(),list[1].end(), pii(R-rooma,0));\n      int roomb = tmp.first;\n      int authb = tmp.second;\n      if(rooma + roomb < R) continue;\n      ans = min(ans,autha + authb);\n    }\n    cout << ans << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb push_back\n#define mp make_pair\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,-1,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pint pair<int,int>\n#define INF 1<<29\n#define MAX 501\nusing namespace std;\n \nint R,W[2],H[2],X[2],Y[2],L[2][MAX][MAX],d[2][MAX][MAX],dd[4]={0,-1,0,1};\nmap<int,int> m[2];\nmap<int,int>::iterator ite;\nvector<int> lev[2],sum[2];\n \nvoid solve(){\n for(;;){\n  cin>>R;\n  if(!R) return;\n  FOR(i,2){\n   cin>>W[i]>>H[i]>>X[i]>>Y[i];\n   X[i]--;\n   Y[i]--;\n   FOR(j,H[i]) FOR(k,W[i]) cin>>L[i][j][k];\n   FOR(j,H[i]) FOR(k,W[i]) d[i][j][k]=INT_MAX/3;\n   d[i][X[i]][Y[i]]=1;\n   priority_queue<pint,vector<pint>,greater<pint>> pque;\n   pque.push(mp(1,X[i]*W[i]+Y[i]));\n   while(!pque.empty()){\n    pint p=pque.top(); pque.pop();\n    int x=p.second/W[i],y=p.second%W[i];\n    if(d[i][x][y]<p.first) continue;\n    FOR(j,4){\n     int nx=x+dd[j],ny=y+dd[j^1];\n     if(nx<0||ny<0||nx>=H[i]||ny>=W[i]) continue;\n     if(d[i][nx][ny]>max(d[i][x][y],L[i][nx][ny])){\n      d[i][nx][ny]=max(d[i][x][y],L[i][nx][ny]);\n      pque.push(mp(d[i][nx][ny],nx*W[i]+ny));\n     }\n    }\n   }\n   FOR(j,H[i]) FOR(k,W[i]) m[i][d[i][j][k]]++;\n   int tot=0;\n   lev[i].pb(0);\n   sum[i].pb(0);\n   for(ite=m[i].begin();ite!=m[i].end();ite++){\n    lev[i].pb(ite->first);\n    tot+=ite->second;\n    sum[i].pb(tot);\n   }\n  }\n  sum[1].pb(INT_MAX);\n  int mi=1<<30;\n  FOR(i,lev[0].size()){\n   int ind=lower_bound(ALL(sum[1]),R-sum[0][i])-sum[1].begin();\n   if(sum[1][ind]==INT_MAX) continue;\n   mi=min(mi,lev[1][ind]+lev[0][i]);\n  }\n  cout<<mi<<endl;\n  FOR(i,2){\n   m[i].clear();\n   lev[i].clear();\n   sum[i].clear();\n  }\n }\n}\n \nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<long long int, P> P1;\n\nlong long int m[1001][1001];\n\nbool used[1001][1001];\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint main(){\n\t\n\twhile(true){\n\t\tint R;\n\t\tcin >> R;\n\t\tif(R == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tlong long int a[2] = {};\n\t\t\n\t\tlong long int num[2][100001];\n\t\t\n\t\tfor(int i = 0; i < 2; i++){\n\t\t\tfor(int j = 0; j <= 100000; j++){\n\t\t\t\tnum[i][j] = 1000000000LL;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < 2; i++){\n\t\t\tint W, H, X, Y;\n\t\t\tcin >> W >> H >> X >> Y;\n\t\t\tX--;\n\t\t\tY--;\n\t\t\tfor(int j = 0; j < H; j++){\n\t\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\t\tcin >> m[j][k];\n\t\t\t\t\tused[j][k] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpriority_queue<P1, vector<P1>, greater<P1> > pque;\n\t\t\tP1 p;\n\t\t\tp.first = 1;\n\t\t\tp.second.first = Y;\n\t\t\tp.second.second = X;\n\t\t\tpque.push(p);\n\t\t\tused[Y][X] = true;\n\t\t\t\n\t\t\tfor(int j = 0; j <= R; j++){\n\t\t\t\tnum[i][j] = a[i];\n\t\t\t\tif(pque.empty()){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tP1 p1 = pque.top();\n\t\t\t\tpque.pop();\n\t\t\t\t//cout << p1.first << \" \";\n\t\t\t\t//cout << p1.second.second << \" \" << p1.second.first << endl;\n\t\t\t\ta[i] = max(a[i], p1.first);\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tP1 pp;\n\t\t\t\t\tpp.second.first = p1.second.first + dy[j];\n\t\t\t\t\tpp.second.second = p1.second.second + dx[j];\n\t\t\t\t\tif(pp.second.second >= 0 && pp.second.first >= 0 && pp.second.second < W && pp.second.first < H && !used[pp.second.first][pp.second.second]){\n\t\t\t\t\t\tpp.first = m[pp.second.first][pp.second.second];\n\t\t\t\t\t\tpque.push(pp);\n\t\t\t\t\t\tused[pp.second.first][pp.second.second] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong long int ans = 1000000000LL;\n\t\t\n\t\tfor(int j = 0; j <= R; j++){\n\t\t\tans = min(ans, num[0][j] + num[1][R - j]);\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pint;\ntypedef pair<ll, int> P;\n//typedef tuple<int,int,int> T;\nll INFL = 1000000000000000010;//10^18 = 2^60\nint INF = 2147483600;//10^9\nll MOD  = 1000000007;\nint solve(){\n    vector<int> dy = {0,0,1,-1};\n    vector<int> dx = {1,-1,0,0};\n    int R;\n    cin >> R;\n    if(R == 0)return 0;\n    int H1,W1,X1,Y1;\n    cin >> W1 >> H1 >> X1 >> Y1;\n    X1--;\n    Y1--;\n    vector<vector<ll>> mp1(H1, vector<ll>(W1));\n    vector<vector<ll>> d1(H1, vector<ll>(W1, INFL));\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            cin >> mp1[i][j];\n        }\n    }\n    \n    d1[Y1][X1] = 1;\n    priority_queue<pair<ll, pair<int, int>>> pque1;\n    pque1.push({1, {Y1, X1}});\n    \n    while(!pque1.empty()){\n        ll c;\n        int y,x;\n        c = pque1.top().first;\n        y = pque1.top().second.first;\n        x = pque1.top().second.second;\n        pque1.pop();\n        if(c > d1[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H1 && 0 <= nx && nx < W1){\n                if(d1[ny][nx] > d1[y][x]){\n                    if(d1[y][x] > mp1[ny][nx]){\n                        d1[ny][nx] = d1[y][x];\n                    }else{\n                        d1[ny][nx] = mp1[ny][nx];\n                    }\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }else if(d1[ny][nx] > d1[y][x]){\n                    d1[ny][nx] = mp1[ny][nx];\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    int H2,W2,X2,Y2;\n    cin >> W2 >> H2 >> X2 >> Y2;\n    X2--;\n    Y2--;\n    vector<vector<ll>> mp2(H2, vector<ll>(W2));\n    vector<vector<ll>> d2(H2, vector<ll>(W2, INFL));\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            cin >> mp2[i][j];\n        }\n    }\n    \n    d2[Y2][X2] = 1;\n    priority_queue<pair<ll, pair<int, int>>> pque2;\n    pque2.push({1, {Y2, X2}});\n    \n    while(!pque2.empty()){\n        ll c;\n        int y,x;\n        c = pque2.top().first;\n        y = pque2.top().second.first;\n        x = pque2.top().second.second;\n        pque2.pop();\n        if(c > d2[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H2 && 0 <= nx && nx < W2){\n                if(d2[ny][nx] > d2[y][x]){\n                    if(d2[y][x] > mp2[ny][nx]){\n                        d2[ny][nx] = d2[y][x];\n                    }else{\n                        d2[ny][nx] = mp2[ny][nx];\n                    }\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }else if(d2[ny][nx] > d2[y][x]){\n                    d2[ny][nx] = mp2[ny][nx];\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    vector<pair<ll,int>> O1(0);\n    vector<ll> COST1(0);\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            COST1.push_back(d1[i][j]);\n        }\n    }\n    sort(COST1.begin(), COST1.end());\n    COST1.push_back(INFL);\n    ll ad1 = COST1.at(0);\n    int cnt = 0;\n    for(int i = 0; i < COST1.size(); i++){\n        if(ad1 == COST1.at(i)){\n            cnt++;\n        }else{\n            O1.push_back({ad1, cnt});\n            ad1 = COST1.at(i);\n            cnt++;\n        }\n    }\n    \n    vector<pair<ll,int>> O2 = {{0, 0}};\n    vector<ll> COST2(0);\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            COST2.push_back(d2[i][j]);\n        }\n    }\n    sort(COST2.begin(), COST2.end());\n    COST2.push_back(INFL);\n    ll ad2 = COST2.at(0);\n    cnt = 0;\n    for(int i = 0; i < COST2.size(); i++){\n        if(ad2 == COST2.at(i)){\n            cnt++;\n        }else{\n            O2.push_back({ad2, cnt});\n            ad2 = COST2.at(i);\n            cnt++;\n        }\n    }\n    \n    ll ans = INFL;\n    for(int i = 0; i < O1.size(); i++){\n        ll cost = O1.at(i).first;\n        int rest = R - O1.at(i).second;\n        \n        if(rest > O2.at(O2.size()-1).second) continue;\n        int left = -1, right = O2.size();\n        int mid;\n        while(right - left > 1){\n            mid = (left + right) / 2;\n            if(O2.at(mid).second >= rest){\n                right = mid;\n            }else{\n                left = mid;\n            }\n        }\n        cost += O2.at(right).first;\n        ans = min(ans, cost);\n        \n    }\n    \n    cout << ans << endl;\n    \n    solve();\n    return 0;\n}\n\nint main(void){\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\n\nstatic const double eps = 1e-8;\n\nconst int tx[4] = {+0,+1,+0,-1};\nconst int ty[4] = {-1,+0,+1,+0};\n\nbool visited[501][501];\nint rooms[2][501][501];\nint required_auth_level[2][250001];\n\nstruct State {\n  int x;\n  int y;\n  int auth;\n  bool operator<(const State& s) const {\n    return auth < s.auth;\n  }\n  bool operator>(const State& s) const {\n    return auth > s.auth;\n  }\n  State(int x,int y,int auth) : x(x), y(y), auth(auth) {}\n};\n\nvoid bfs(int sx,int sy,int W,int H,int office_i){\n  memset(visited,false,sizeof(visited));\n  priority_queue<State,vector<State>, greater<State> > que;\n  que.push(State(sx,sy,1));\n  int current_auth_level = 0;\n  int count = 0;\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    if(visited[s.y][s.x]) continue;\n    visited[s.y][s.x] = true;\n\n    count++;\n    current_auth_level = max(s.auth,current_auth_level);\n    required_auth_level[office_i][count] = current_auth_level;\n\n    for(int i = 0; i < 4; i++){\n      int dx = s.x + tx[i];\n      int dy = s.y + ty[i];\n      if(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n      if(visited[dy][dx]) continue;\n       que.push(State(dx,dy,rooms[office_i][dy][dx]));\n    }\n  }\n}\n\nint main(){\n  int have_to_visit_rooms;\n  while(~scanf(\"%d\",&have_to_visit_rooms)){\n    memset(required_auth_level,0x3f,sizeof(required_auth_level));\n    required_auth_level[0][0] = 0;\n    required_auth_level[1][0] = 0;\n    int elevator_x[2];\n    int elevator_y[2];\n    int W[2];\n    int H[2];\n    for(int office_i = 0; office_i < 2; office_i++){\n      scanf(\"%d %d %d %d\",&W[office_i],&H[office_i],\n            &elevator_x[office_i],&elevator_y[office_i]);\n      elevator_x[office_i]--;\n      elevator_y[office_i]--;\n\n      for(int y = 0; y < H[office_i]; y++){\n        for(int x = 0; x < W[office_i]; x++){\n          scanf(\"%d\",&rooms[office_i][y][x]);\n        }\n      }\n\n      bfs(elevator_x[office_i],\n          elevator_y[office_i],\n          W[office_i],H[office_i],office_i);\n    }\n    int res = 0x3f3f3f3f;\n    for(int i = have_to_visit_rooms; i >= 0; i--){\n      int j = have_to_visit_rooms - i;\n      res = min(required_auth_level[0][i] + required_auth_level[1][j],res);\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <string>\n#include <map>\n#include <utility>\n#include <set>\n#include <queue>\n#include <unordered_set>\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\n\n//using LL = long long;\n//using P = pair < int, int > ;\n//using PI = pair < P, int > ;\ntypedef pair<int, int> P;\ntypedef long long LL;\ntypedef pair<P, int> PI;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\nvector<P> visitable(vector<vector<int>>& stage, P start)\n{\n\tint h = stage.size(), w = stage[0].size();\n\tvector<vector<int>> ns(h, vector<int>(w, INF));\n\tset<P> visited;\n\tqueue<P> que;\n\tque.push(start);\n\tvisited.insert(start);\n\tns[start.first][start.second] = 1;\n\twhile (!que.empty())\n\t{\n\t\tP p = que.front(); que.pop();\n\t\trep(i, 4)\n\t\t{\n\t\t\tint nr = dr[i] + p.first, nc = dc[i] + p.second;\n\t\t\tif (nr < 0 || nr >= h || nc < 0 || nc >= w) continue;\n\n\t\t\tns[nr][nc] = max(stage[nr][nc], min(ns[nr][nc], ns[p.first][p.second]));\n\n\t\t\tP np = P(nr, nc);\n\t\t\tif (visited.count(np)) continue;\n\t\t\tvisited.insert(np);\n\t\t\tque.push(np);\n\t\t}\n\t}\n\n\tmap<int, int> mp;\n\trep(i, h) rep(j, w) mp[ns[i][j]]++;\n\tvector<P> ret;\n\tfor (P p : mp) ret.push_back(p);\n\tfor (int i = 0; i + 1 < ret.size(); i++) ret[i + 1].second += ret[i].second;\n\treturn move(ret);\n}\n\n//x個を満たす最小の機密レベル\nint lower(vector<int>& sums, vector<int>& data, int x)\n{\n\tif (sums[sums.size() - 1] < x) return -1;\n\tif (x == 0) return 0;\n\n\tint idx = lower_bound(all(sums), x) - sums.begin();\n\treturn data[idx];\n}\n\nsigned main()\n{\n\tint R;\n\twhile (cin >> R && R)\n\t{\n\t\tint w1, h1, c1, r1; cin >> w1 >> h1 >> c1 >> r1;\n\t\tr1--; c1--;\n\t\tvector<vector<int>> stage1(h1, vector<int>(w1));\n\t\trep(i, h1) rep(j, w1) cin >> stage1[i][j];\n\n\t\tvector<P> ps1 = visitable(stage1, P(r1, c1));\n\t\tvector<int> sums1, data1;\n\t\tfor (P p : ps1)\n\t\t{\n\t\t\tsums1.push_back(p.second);\n\t\t\tdata1.push_back(p.first);\n\t\t}\n\n\t\tint w2, h2, c2, r2; cin >> w2 >> h2 >> c2 >> r2;\n\t\tr2--; c2--;\n\t\tvector<vector<int>> stage2(h2, vector<int>(w2));\n\t\trep(i, h2) rep(j, w2) cin >> stage2[i][j];\n\n\t\tvector<P> ps2 = visitable(stage2, P(r2, c2));\n\t\tvector<int> sums2, data2;\n\t\tfor (P p : ps2)\n\t\t{\n\t\t\tsums2.push_back(p.second);\n\t\t\tdata2.push_back(p.first);\n\t\t}\n\n\t\tint ans = INF;\n\t\trep(x, R + 1)\n\t\t{\n\t\t\tint y = R - x;\n\t\t\tint l1 = lower(sums1, data1, x);\n\t\t\tint l2 = lower(sums2, data2, y);\n\t\t\tif (l1 != -1 && l2 != -1)\n\t\t\t{\n\t\t\t\tans = min(ans, l1 + l2);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n#define F first\n#define S second\n#define INF 2e9\n#define MP(i, j) make_pair((i), (j))\ntypedef pair<int, int> P;\nint level[500][500];\n\nint r, w, h, x, y;\nvector<P> able, able2;\nstruct S{\n\tint x, y, r;\n\tS(int inx, int iny, int inr): x(inx), y(iny), r(inr){}\n\tbool operator < (const S &s)const{\n\t\treturn r > s.r;\n\t}\n};\nvoid dijkstra(vector<P> &able){\n\tint nowr = 1, cnt = 0;\n\tbool flag[500][500] = {};\n\tpriority_queue<S> que;\n\tque.push(S(x - 1, y - 1, 1));\n\tflag[y - 1][x - 1] =  true;\n\twhile(!que.empty()){\n\t\tS p = que.top();\n\t\tif(nowr < level[p.y][p.x]){\n\t\t\table.push_back(MP(cnt, nowr));\n\t\t\tnowr = level[p.y][p.x];\n\t\t}\n\t\tcnt++;\n\t\t\n\t\tque.pop();\n\t\tfor(int i = -1; i <= 1; i++){\n\t\t\tif(!flag[p.y + i][p.x]&& p.y + i >= 0 && p.y + i < h && p.x >= 0 && p.x < w){\n\t\t\t\tque.push(S(p.x, p.y + i, level[p.y + i][p.x]));\n\t\t\t\tflag[p.y + i][p.x] = true;\n\t\t\t}\n\t\t\tif(!flag[p.y][p.x + i]&& p.y >= 0 && p.y < h && p.x + i >= 0 && p.x + i < w){\n\t\t\t\tque.push(S(p.x + i, p.y, level[p.y][p.x + i]));\n\t\t\t\tflag[p.y][p.x + i] = true;\n\t\t\t}\n\t\t}\n\t}\n\table.push_back(MP(cnt, nowr));\n}\nint main(){\n\twhile(scanf(\"%d\", &r) && r){\n\t\tscanf(\"%d%d%d%d\", &w, &h, &x, &y);\n\t\tint ans = INF;\n\t\table.clear();\n\t\table2.clear();\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tscanf(\"%d\", &level[i][j]);\n\t\t\t}\n\t\t}\n\t\tdijkstra(able);\n\t\tscanf(\"%d%d%d%d\", &w, &h, &x, &y);\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tscanf(\"%d\", &level[i][j]);\n\t\t\t}\n\t\t}\n\t\tdijkstra(able2);\n\n\t\tfor(int i = 0; i < able.size(); i++){\n\t\t\tP pp = MP(r - able[i].F, 0);\n\t\t\tif(pp.F > 0){\n\t\t\t\tint p = lower_bound(able2.begin(),able2.end(), pp) - able2.begin();\n\t\t\t\tif(p != able2.end() - able2.begin())\n\t\t\t\t\tans = min(ans, able2[p].S + able[i].S);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans = min(ans, able[i].S);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 160000\n#define B 100\n#define dpb push_back\n#define fi first\n#define se second\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst int inf = 1e9;\nconst ll INF = 1e18;\n//__gcd(a,b), __builtin_popcount(a);\n\nint r, h1, w1, X1, Y1, h2, w2, X2, Y2;\nint dy[4] = {0, 0, -1, 1}, dx[4] = {-1, 1, 0, 0};\nint a[5002][5002], b[5002][5002];\nint an[250004], bn[250004];\n\nint to_n(int y, int x, int w){\n\treturn (w*(y-1)+x);\n}\nint to_y(int n, int w){\n\treturn ((n-1)/w+1);\n}\nint to_x(int n, int w){\n\treturn (n-(to_y(n, w)-1)*w);\n}\nint main(){\n\twhile(1){\n\tfill((int*)a, (int*)(a+5001), inf);\n\tfill((int*)b, (int*)(b+5001), inf);\n\tfill(an, an+250004, 0);\n\tfill(bn, bn+250004, 0);\n\tscanf(\"%d\", &r);\n\tif(!r)break;\n\tscanf(\"%d%d%d%d\", &w1, &h1, &X1, &Y1);\n\trrep(i,h1)rrep(j,w1)scanf(\"%d\", &a[i][j]);\n\tscanf(\"%d%d%d%d\", &w2, &h2, &X2, &Y2);\n\trrep(i,h2)rrep(j,w2)scanf(\"%d\", &b[i][j]);\n\t\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tq.push(P(a[Y1][X1], to_n(Y1, X1,w1)));\n\ta[Y1][X1] = inf;\n\tint acnt = 1;\n\twhile(!q.empty()){\n\t\tP p = q.top();q.pop();\n\t\tint y = to_y(p.se, w1), x = to_x(p.se, w1);\n\t\tan[acnt++] = p.fi;\n\t\tfor(int i = 0;i < 4;i++){\n\t\t\tint yy = y+dy[i], xx = x+dx[i];\n\t\t\tif(a[yy][xx] != inf){\n\t\t\t\tq.push(P(a[yy][xx], to_n(yy, xx,w1)));\n\t\t\t\ta[yy][xx] = inf;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tq.push(P(b[Y2][X2], to_n(Y2, X2,w2)));\n\tb[Y2][X2] = inf;\n\tint bcnt = 1;\n\twhile(!q.empty()){\n\t\tP p = q.top();q.pop();\n\t\tint y = to_y(p.se, w2), x = to_x(p.se, w2);\n\t\tbn[bcnt++] = p.fi;\n\t\tfor(int i = 0;i < 4;i++){\n\t\t\tint yy = y+dy[i], xx = x+dx[i];\n\t\t\tif(b[yy][xx] != inf){\n\t\t\t\tq.push(P(b[yy][xx], to_n(yy, xx,w2)));\n\t\t\t\tb[yy][xx] = inf;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint t1 = 0, t2 = 0;\n\tfor(int i = 0;i < acnt;i++){\n\t\tt1 = max(t1, an[i]);\n\t\tan[i] = t1;\n\t}\n\tfor(int i = 0;i < bcnt;i++){\n\t\tt2 = max(t2, bn[i]);\n\t\tbn[i] = t2;\n\t}\n\t\n\tint ans = inf;\n\tfor(int i = 0;i < acnt;i++){\n\t\tif(r-i < bcnt)ans = min(ans, an[i]+bn[r-i]);\n\t}\n\t\n\t/*rep(i,acnt)printf(\"%d \", an[i]);\n\tprintf(\"\\n\");\n\trep(i,bcnt)printf(\"%d \", bn[i]);\n\tprintf(\"\\n\");*/\n\t//int ans = 0;\n\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pint;\ntypedef pair<ll, int> P;\n//typedef tuple<int,int,int> T;\nll INFL = 1000000000000000010;//10^18 = 2^60\nint INF = 2147483600;//10^9\nll MOD  = 1000000007;\nvector<int> dy = {1,-1,0,0};\nvector<int> dx = {0,0,1,-1};\nvector<ll> Ans(0);\nint solve(){\n    int R;\n    cin >> R;\n    if(R == 0)return 0;\n    int H1,W1,X1,Y1;\n    cin >> W1 >> H1 >> X1 >> Y1;\n    X1--;\n    Y1--;\n    vector<vector<ll>> mp1(H1, vector<ll>(W1));\n    vector<vector<ll>> d1(H1, vector<ll>(W1, INFL));\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            cin >> mp1[i][j];\n        }\n    }\n    \n    d1[Y1][X1] = 1;\n    priority_queue<pair<ll, pair<int, int>>> pque1;\n    pque1.push({1, {Y1, X1}});\n    \n    while(!pque1.empty()){\n        ll c;\n        int y,x;\n        c = pque1.top().first;\n        y = pque1.top().second.first;\n        x = pque1.top().second.second;\n        pque1.pop();\n        if(c > d1[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H1 && 0 <= nx && nx < W1){\n                if(d1[ny][nx] > d1[y][x]){\n                    if(d1[y][x] > mp1[ny][nx]){\n                        d1[ny][nx] = d1[y][x];\n                    }else{\n                        d1[ny][nx] = mp1[ny][nx];\n                    }\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }else if(d1[ny][nx] > d1[y][x]){\n                    d1[ny][nx] = mp1[ny][nx];\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    int H2,W2,X2,Y2;\n    cin >> W2 >> H2 >> X2 >> Y2;\n    X2--;\n    Y2--;\n    vector<vector<ll>> mp2(H2, vector<ll>(W2));\n    vector<vector<ll>> d2(H2, vector<ll>(W2, INFL));\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            cin >> mp2[i][j];\n        }\n    }\n    \n    d2[Y2][X2] = 1;\n    priority_queue<pair<ll, pair<int, int>>> pque2;\n    pque2.push({1, {Y2, X2}});\n    \n    while(!pque2.empty()){\n        ll c;\n        int y,x;\n        c = pque2.top().first;\n        y = pque2.top().second.first;\n        x = pque2.top().second.second;\n        pque2.pop();\n        if(c > d2[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H2 && 0 <= nx && nx < W2){\n                if(d2[ny][nx] > d2[y][x]){\n                    if(d2[y][x] > mp2[ny][nx]){\n                        d2[ny][nx] = d2[y][x];\n                    }else{\n                        d2[ny][nx] = mp2[ny][nx];\n                    }\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }else if(d2[ny][nx] > d2[y][x]){\n                    d2[ny][nx] = mp2[ny][nx];\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    vector<pair<ll,int>> O1(0);\n    vector<ll> COST1(0);\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            COST1.push_back(d1[i][j]);\n        }\n    }\n    sort(COST1.begin(), COST1.end());\n    COST1.push_back(INFL);\n    ll ad1 = COST1.at(0);\n    int cnt = 0;\n    for(int i = 0; i < COST1.size(); i++){\n        if(ad1 == COST1.at(i)){\n            cnt++;\n        }else{\n            O1.push_back({ad1, cnt});\n            ad1 = COST1.at(i);\n            cnt++;\n        }\n    }\n    \n    vector<pair<ll,int>> O2(1);\n    O2.at(0).first = 0;\n    O2.at(0).second = 0;\n    vector<ll> COST2(0);\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            COST2.push_back(d2[i][j]);\n        }\n    }\n    sort(COST2.begin(), COST2.end());\n    COST2.push_back(INFL);\n    ll ad2 = COST2.at(0);\n    cnt = 0;\n    for(int i = 0; i < COST2.size(); i++){\n        if(ad2 == COST2.at(i)){\n            cnt++;\n        }else{\n            O2.push_back({ad2, cnt});\n            ad2 = COST2.at(i);\n            cnt++;\n        }\n    }\n    \n    \n    ll ans = INFL;\n    int right = -1;\n    for(int i = 0; i < O1.size(); i++){\n        ll cost = O1.at(i).first;\n        int rest = R - O1.at(i).second;\n        \n        if(rest > O2.at(O2.size()-1).second) continue;\n        int left = -1;\n        if(right == -1){\n            right = O2.size();\n        }\n        int mid;\n        while(right - left > 1){\n            mid = (left + right) / 2;\n            if(O2.at(mid).second >= rest){\n                right = mid;\n            }else{\n                left = mid;\n            }\n        }\n        cost += O2.at(right).first;\n        ans = min(ans, cost);\n    }\n    \n    Ans.push_back(ans);\n    solve();\n    return 0;\n}\n\nint main(void){\n    solve();\n    for(int i = 0; i < Ans.size(); i++){\n        cout << Ans.at(i) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> iP;\n#define pb push_back\n#define fi first\n#define sc second\n#define MAX_H 514\nint R;\nint W[2],H[2],X[2],Y[2];\nint L[2][MAX_H][MAX_H];\nbool F[2][MAX_H][MAX_H];\nvector<iP>data[2];\nint need[2][MAX_H*MAX_H];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nint main()\n{\n\twhile(true){\n\tfor(int i=0;i<2;i++){\n\t\tdata[i].erase(data[i].begin(),data[i].end());\n\t\tfor(int j=0;j<514;j++){\n\t\t\tfor(int k=0;k<514;k++){\n\t\t\t\tF[i][j][k]=false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tscanf(\"%d\",&R);\n\tif(R==0)break;\n\tfor(int i=0;i<2;i++){\n\t\tscanf(\"%d%d%d%d\",&W[i],&H[i],&X[i],&Y[i]);X[i]--;Y[i]--;\n\t\tfor(int j=0;j<H[i];j++){\n\t\t\tfor(int k=0;k<W[i];k++){\n\t\t\t\tscanf(\"%d\",&L[i][j][k]);\n\t\t\t\tif(j==Y[i]&&k==X[i]){continue;}\n\t\t\t\tdata[i].pb(iP(L[i][j][k],P(j,k)));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tsort(data[i].begin(),data[i].end());\n\t\tfor(int j=0;j<=W[i]*H[i];j++){\n\t\t\tneed[i][j]=(1<<30)-1;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tF[i][Y[i]][X[i]]=true;\n\t\tneed[i][0]=0;\n\t\tint cou=1;need[i][1]=1;\n\t\tfor(int j=0;j<(int)data[i].size();j++){\n\t\t\tint x=data[i][j].sc.fi;\n\t\t\tint y=data[i][j].sc.sc;\n\t\t\tif(F[i][x][y])continue;\n\t\t\tbool flag=false;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tif(x+dx[k]<0||x+dx[k]>=H[i]||y+dy[k]<0||y+dy[k]>=W[i]){continue;}\n\t\t\t\tif(F[i][x+dx[k]][y+dy[k]])flag=true;\n\t\t\t}\n\t\t\tif(!flag){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tqueue<P>que;\n\t\t\tque.push(P(x,y));\n\t\t\twhile(!que.empty()){\n\t\t\t\tP p=que.front();que.pop();\n\t\t\t\tif(F[i][p.fi][p.sc])continue;\n\t\t\t\tF[i][p.fi][p.sc]=true;\n\t\t\t\t//printf(\"%d %d\\n\",p.fi,p.sc);\n\t\t\t\tcou++;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(p.fi+dx[k]<0||p.fi+dx[k]>=H[i]||p.sc+dy[k]<0||p.sc+dy[k]>=W[i]){continue;}\n\t\t\t\t\tif(F[i][p.fi+dx[k]][p.sc+dy[k]]){continue;}\n\t\t\t\t\tif(L[i][p.fi+dx[k]][p.sc+dy[k]]<=data[i][j].fi){\n\t\t\t\t\t\tque.push(P(p.fi+dx[k],p.sc+dy[k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tneed[i][cou]=L[i][x][y];\n\t\t\t//printf(\"%d:%d %d\\n\",cou,x,y);\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tfor(int j=W[i]*H[i]-1;j>=0;j--){\n\t\t\tneed[i][j]=min(need[i][j],need[i][j+1]);\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<2;i++){\n\t\tfor(int j=0;j<=W[i]*H[i];j++){\n\t\t\tprintf(\"need[%d][%d]=%d\\n\",i,j,need[i][j]);\n\t\t}\n\t}*/\n\t\n\tint ans=1<<30;\n\tfor(int i=0;i<=W[0]*H[0];i++){\n\t\tint k=R-i;\n\t\tif(k>W[1]*H[1]||k<0){\n\t\t\tcontinue;\n\t\t}\n\t\tans=min(need[0][i]+need[1][k],ans);\n\t}\n\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <tuple>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nconst vector<int> dx = { 0, 1, 0, -1 };\nconst vector<int> dy = { -1, 0, 1, 0 };\n\nint R, W[2], H[2], X[2], Y[2], F[2][500][500], D[2][500][500];\n\nint main()\n{\n\tscanf(\"%d\", &R);\n\n\tfor (int i = 0; i < 2; i++)\n\t{\n\t\tscanf(\"%d\", &W[i]);\n\t\tscanf(\"%d\", &H[i]);\n\t\tscanf(\"%d\", &X[i]); X[i]--;\n\t\tscanf(\"%d\", &Y[i]); Y[i]--;\n\n\t\tfor (int j = 0; j < H[i]; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < W[i]; k++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &F[i][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\n\tmemset(D, -1, sizeof(D));\n\n\tfor (int i = 0; i < 2; i++)\n\t{\n\t\tD[i][Y[i]][X[i]] = 1;\n\n\t\tpriority_queue<tuple<int, int, int>, vector<tuple<int, int, int> >, greater<tuple<int, int, int> > > que;\n\n\t\tque.push(make_tuple(0, X[i], Y[i]));\n\n\t\twhile (!que.empty())\n\t\t{\n\t\t\ttuple<int, int, int> state = que.top(); que.pop();\n\n\t\t\tint d = get<0>(state);\n\t\t\tint x = get<1>(state);\n\t\t\tint y = get<2>(state);\n\n\t\t\tfor (int dir = 0; dir < 4; dir++)\n\t\t\t{\n\t\t\t\tint x2 = x + dx[dir];\n\t\t\t\tint y2 = y + dy[dir];\n\n\t\t\t\tif (0 <= x2 && x2 < W[i] && 0 <= y2 && y2 < H[i])\n\t\t\t\t{\n\t\t\t\t\tif (D[i][y2][x2] == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tD[i][y2][x2] = max(d, F[i][y2][x2]);\n\n\t\t\t\t\t\tque.push(make_tuple(D[i][y2][x2], x2, y2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<int> E[2];\n\n\tfor (int i = 0; i < 2; i++)\n\t{\n\t\tfor (int j = 0; j < H[i]; j++)\n\t\t{\n\t\t\tfor (int k = 0; k < W[i]; k++)\n\t\t\t{\n\t\t\t\tE[i].push_back(D[i][j][k]);\n\t\t\t}\n\t\t}\n\n\t\tsort(E[i].begin(), E[i].end());\n\t}\n\n\tint ret = 999999999;\n\n\tfor (int i = 0; i <= R; i++)\n\t{\n\t\tif (i < E[0].size() && R - i < E[1].size())\n\t\t{\n\t\t\tret = min(ret, E[0][i] + E[1][R - i]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n#define MP make_pair\n#define PB push_back\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) \n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P) \n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P) \n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s; }\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nconst int INF = 1<<29;\nint R;\nint n[2], m[2];\nint s[2], t[2];\nint fi[2][510][510], fi2[510][510];\nint need[2][510][510], need2[510][510];\n\nint main() {\n    while (cin >> R) {\n        if (R == 0) break;\n        for (int it = 0; it < 2; ++it) {\n            cin >> m[it] >> n[it] >> t[it] >> s[it]; --t[it]; --s[it];\n            for (int i = 0; i < n[it]; ++i) for (int j = 0; j < m[it]; ++j) cin >> fi[it][i][j];\n        }\n        \n        for (int it = 0; it < 2; ++it) {\n            for (int i = 0; i < 510; ++i) for (int j = 0; j < 510; ++j) need[it][i][j] = INF;\n            need[it][s[it]][t[it]] = 1;\n            priority_queue<pair<int,pint>, vector<pair<int,pint> >, greater<pair<int,pint> > > que;\n            que.push( MP(1,pint(s[it],t[it])) );\n            while (!que.empty()) {\n                int dist = que.top().first;\n                int x = que.top().second.first;\n                int y = que.top().second.second;\n                que.pop();\n            \n                if (need[it][x][y] < dist) continue;\n                \n                //cout << it << \", \" << MP(x,y) << \" : \" << dist << endl;\n                \n                for (int i = 0; i < 4; ++i) {\n                    int nx = x + dx[i], ny = y + dy[i];\n                    if (nx < 0 || nx >= n[it] || ny < 0 || ny >= m[it]) continue;\n                    int num = max(fi[it][nx][ny], dist);\n                    if (chmin(need[it][nx][ny], num)) {\n                        que.push( MP(need[it][nx][ny],pint(nx,ny)) );\n                    }\n                }\n            }\n        }\n        map<int,int> ma[2];\n        for (int it = 0; it < 2; ++it) {\n            ma[it][0] = 0;\n            for (int i = 0; i < n[it]; ++i) for (int j = 0; j < m[it]; ++j) ma[it][need[it][i][j]]++;\n            int pre = 0;\n            EACH(t, ma[it]) {\n                t->second += pre;\n                pre = t->second;\n            }\n            //COUT(ma[it]);\n        }\n        vector<pint> rem;\n        EACH(t, ma[1]) {\n            rem.PB( pint(t->second, t->first) );\n        }\n        rem.PB( pint(0,0) );\n        rem.PB( pint(INF,INF) );\n        sort(ALL(rem));\n        \n        int res = INF;\n        EACH(t, ma[0]) {\n            int r = R - t->second;\n            int level1 = t->first;\n            int id = lower_bound(ALL(rem), pint(r,0)) - rem.begin();\n            int level2 = rem[id].second;\n            \n            chmin(res, level1 + level2);\n        }\n        \n        cout << res << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long int;\nusing P = pair<int,int>;\nusing P3 = pair<int,P>;\nusing PP = pair<P, P>;\nconstexpr int INF = 1<<30;\nconstexpr int MOD = 10000;\nconstexpr int di[] = {0,1,0,-1};\nconstexpr int dj[] = {1,0,-1,0};\n\nvector<P> gen(){\n    int w, h, x, y;\n    cin >> w >> h >> x >> y;\n    x--; y--;\n    vector<vector<int> > lv(h, vector<int>(w));\n    vector<int> ord;\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            cin >> lv[i][j];\n            ord.emplace_back(lv[i][j]);\n        }\n    }\n    sort(ord.begin(),ord.end());\n    ord.erase(unique(ord.begin(),ord.end()),ord.end());\n    vector<P> res = {P(0,0)};\n    priority_queue<P3,vector<P3>,greater<P3> > que;\n    vector<vector<bool> > used(h, vector<bool>(w));\n    int cnt = 0;\n    used[y][x] = true;\n    que.push(P3(1,P(y,x)));\n    for(auto l : ord){\n        bool update = false;\n        while(!que.empty()){\n            auto p = que.top();\n            int i = p.second.first, j = p.second.second;\n            if(lv[i][j] > l) break;\n            que.pop();\n            cnt++;\n            update = true;\n            for(int k=0;k<4;k++){\n                int ni=i+di[k], nj=j+dj[k];\n                if(ni<0 || ni>=h) continue;\n                if(nj<0 || nj>=w) continue;\n                if(used[ni][nj]) continue;\n                used[ni][nj] = true;\n                que.push(P3(lv[ni][nj],P(ni,nj)));\n            }\n        }\n        if(update){\n            res.emplace_back(P(cnt,l));\n        }\n    }\n    return res;\n}\n\nbool solve(){\n    int r;\n    cin >> r;\n    if(r == 0) return false;\n    vector<P> v1, v2;\n    v1 = gen();\n    v2 = gen();\n    int n = v1.size(), m = v2.size(), ans = INF;\n    for(int i=0,j=m-1;i<n;i++){\n        while(j>0 && v1[i].first+v2[j-1].first >= r) j--;\n        if(v1[i].first+v2[j].first >= r){\n            ans = min(ans, v1[i].second+v2[j].second);\n        }\n    }\n    cout << ans << endl;\n    return true;\n}\n\nint main(){\n    while(solve());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 200000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\nstruct ROOM\n{\n\tint level,x,y;\n};\nbool operator <(const ROOM &a,const ROOM &b)\n{\n\treturn a.level > b.level;\n}\nint office[2][510][510];\nbool used[510][510];\nint W[2],H[2],X[2],Y[2];\nint can[2][100010];\nint dx[]={0,1,-1,0};\nint dy[]={1,0,0,-1};\nint main()\n{\n\twhile(1)\n\t{\n\t\tint R;\n\t\tcin >> R;\n\t\tif(R==0)break;\n\t\tfor(int i=0;i<100010;i++)\n\t\t{\n\t\t\tcan[0][i]=INF;\n\t\t\tcan[1][i]=INF;\n\t\t}\n\t\tcan[0][0]=0;\n\t\tcan[1][0]=0;\n\t\tmemset(office,0,sizeof(office));\n\t\tfor(int t=0;t<2;t++)\n\t\t{\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tcin >> W[t] >> H[t] >> X[t] >> Y[t];\n\t\t\tfor(int i=0;i<H[t];i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<W[t];j++)\n\t\t\t\t{\n\t\t\t\t\tcin >> office[t][i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tpriority_queue<ROOM> q;\n\t\t\tROOM f;\n\t\t\tf.level=1;\n\t\t\tf.x=Y[t]-1;\n\t\t\tf.y=X[t]-1;\n\t\t\tq.push(f);\n\t\t\tint num=0,now=0,mx=0;\n\t\t\twhile(!q.empty())\n\t\t\t{\n\t\t\t\tROOM a=q.top();\n\t\t\t\tif(used[a.x][a.y])\n\t\t\t\t{\n\t\t\t\t\tq.pop();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tnow=max(now,a.level);\n\t\t\t\twhile(now>=a.level)\n\t\t\t\t{\n\t\t\t\t\tq.pop();\n\t\t\t\t\tif(!used[a.x][a.y])\n\t\t\t\t\t{\n\t\t\t\t\t\tused[a.x][a.y]=true;\n\t\t\t\t\t\tnum++;\n\t\t\t\t\t\tfor(int i=0;i<4;i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint nx=a.x+dx[i],ny=a.y+dy[i];\n\t\t\t\t\t\t\tif(nx>=0&&nx<H[t]&&ny>=0&&ny<W[t]&&!used[nx][ny])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tROOM b;\n\t\t\t\t\t\t\t\tb.level=office[t][nx][ny];\n\t\t\t\t\t\t\t\tb.x=nx;\n\t\t\t\t\t\t\t\tb.y=ny;\n\t\t\t\t\t\t\t\tq.push(b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(q.empty())break;\n\t\t\t\t\ta=q.top();\n\t\t\t\t}\n\t\t\t\tif(now<a.level)\n\t\t\t\t{\n\t\t\t\t\tq.push(a);\n\t\t\t\t}\n\t\t\t\tfor(int i=mx+1;i<=min(R,num);i++)\n\t\t\t\t{\n\t\t\t\t\tcan[t][i]=now;\n\t\t\t\t}\n\t\t\t\tmx=num;\n\t\t\t\tif(mx>R)break;\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(int i=0;i<=R;i++)\n\t\t{\n\t\t\tans=min(ans,can[0][i]+can[1][R-i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pint;\ntypedef pair<ll, int> P;\n//typedef tuple<int,int,int> T;\nll INFL = 1000000000000000010;//10^18 = 2^60\nint INF = 2147483600;//10^9\nll MOD  = 1000000007;\nvector<int> dy(4);\nvector<int> dx(4);\ndy.at(0) = 1;\ndy.at(1) = -1;\ndx.at(2) = 1;\ndx.at(3) = -1;\nvector<ll> Ans(0);\nint solve(){\n    \n    int R;\n    cin >> R;\n    if(R == 0)return 0;\n    int H1,W1,X1,Y1;\n    cin >> W1 >> H1 >> X1 >> Y1;\n    X1--;\n    Y1--;\n    vector<vector<ll> > mp1(H1, vector<ll>(W1));\n    vector<vector<ll> > d1(H1, vector<ll>(W1, INFL));\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            cin >> mp1[i][j];\n        }\n    }\n    \n    d1[Y1][X1] = 1;\n    priority_queue<pair<ll, pair<int, int> > > pque1;\n    pque1.push({1, {Y1, X1}});\n    \n    while(!pque1.empty()){\n        ll c;\n        int y,x;\n        c = pque1.top().first;\n        y = pque1.top().second.first;\n        x = pque1.top().second.second;\n        pque1.pop();\n        if(c > d1[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H1 && 0 <= nx && nx < W1){\n                if(d1[ny][nx] > d1[y][x]){\n                    if(d1[y][x] > mp1[ny][nx]){\n                        d1[ny][nx] = d1[y][x];\n                    }else{\n                        d1[ny][nx] = mp1[ny][nx];\n                    }\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }else if(d1[ny][nx] > d1[y][x]){\n                    d1[ny][nx] = mp1[ny][nx];\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    int H2,W2,X2,Y2;\n    cin >> W2 >> H2 >> X2 >> Y2;\n    X2--;\n    Y2--;\n    vector<vector<ll> > mp2(H2, vector<ll>(W2));\n    vector<vector<ll> > d2(H2, vector<ll>(W2, INFL));\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            cin >> mp2[i][j];\n        }\n    }\n    \n    d2[Y2][X2] = 1;\n    priority_queue<pair<ll, pair<int, int> > > pque2;\n    pque2.push({1, {Y2, X2}});\n    \n    while(!pque2.empty()){\n        ll c;\n        int y,x;\n        c = pque2.top().first;\n        y = pque2.top().second.first;\n        x = pque2.top().second.second;\n        pque2.pop();\n        if(c > d2[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H2 && 0 <= nx && nx < W2){\n                if(d2[ny][nx] > d2[y][x]){\n                    if(d2[y][x] > mp2[ny][nx]){\n                        d2[ny][nx] = d2[y][x];\n                    }else{\n                        d2[ny][nx] = mp2[ny][nx];\n                    }\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }else if(d2[ny][nx] > d2[y][x]){\n                    d2[ny][nx] = mp2[ny][nx];\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    vector<pair<ll,int> > O1(0);\n    vector<ll> COST1(0);\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            COST1.push_back(d1[i][j]);\n        }\n    }\n    sort(COST1.begin(), COST1.end());\n    COST1.push_back(INFL);\n    ll ad1 = COST1.at(0);\n    int cnt = 0;\n    for(int i = 0; i < COST1.size(); i++){\n        if(ad1 == COST1.at(i)){\n            cnt++;\n        }else{\n            O1.push_back({ad1, cnt});\n            ad1 = COST1.at(i);\n            cnt++;\n        }\n    }\n    \n    vector<pair<ll,int> > O2(1);\n    O2.at(0).first = 0;\n    O2.at(0).second = 0;\n    vector<ll> COST2(0);\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            COST2.push_back(d2[i][j]);\n        }\n    }\n    sort(COST2.begin(), COST2.end());\n    COST2.push_back(INFL);\n    ll ad2 = COST2.at(0);\n    cnt = 0;\n    for(int i = 0; i < COST2.size(); i++){\n        if(ad2 == COST2.at(i)){\n            cnt++;\n        }else{\n            O2.push_back({ad2, cnt});\n            ad2 = COST2.at(i);\n            cnt++;\n        }\n    }\n    \n    \n    ll ans = INFL;\n    int right = -1;\n    for(int i = 0; i < O1.size(); i++){\n        ll cost = O1.at(i).first;\n        int rest = R - O1.at(i).second;\n        \n        if(rest > O2.at(O2.size()-1).second) continue;\n        int left = -1;\n        if(right == -1){\n            right = O2.size();\n        }\n        int mid;\n        while(right - left > 1){\n            mid = (left + right) / 2;\n            if(O2.at(mid).second >= rest){\n                right = mid;\n            }else{\n                left = mid;\n            }\n        }\n        cost += O2.at(right).first;\n        ans = min(ans, cost);\n    }\n    \n    Ans.push_back(ans);\n    solve();\n    return 0;\n}\n\nint main(void){\n    solve();\n    for(int i = 0; i < Ans.size(); i++){\n        cout << Ans.at(i) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb push_back\n#define mp make_pair\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,-1,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pint pair<int,int>\n#define INF 1<<29\n#define MAX 501\nusing namespace std;\n \nint R,W[2],H[2],X[2],Y[2],L[2][MAX][MAX],d[2][MAX][MAX],dd[4]={0,-1,0,1};\nmap<int,int> m[2];\nmap<int,int>::iterator ite;\nvector<int> lev[2],sum[2];\n \nvoid solve(){\n for(;;){\n  cin>>R;\n  if(!R) return;\n  FOR(i,2){\n   cin>>W[i]>>H[i]>>X[i]>>Y[i];\n   X[i]--;\n   Y[i]--;\n   FOR(j,H[i]) FOR(k,W[i]) cin>>L[i][j][k];\n   FOR(j,H[i]) FOR(k,W[i]) d[i][j][k]=INT_MAX/3;\n   d[i][Y[i]][X[i]]=1;\n   priority_queue<pint,vector<pint>,greater<pint>> pque;\n   pque.push(mp(1,Y[i]*W[i]+X[i]));\n   while(!pque.empty()){\n    pint p=pque.top(); pque.pop();\n    int x=p.second/W[i],y=p.second%W[i];\n    if(d[i][x][y]<p.first) continue;\n    FOR(j,4){\n     int nx=x+dd[j],ny=y+dd[j^1];\n     if(nx<0||ny<0||nx>=H[i]||ny>=W[i]) continue;\n     if(d[i][nx][ny]>max(d[i][x][y],L[i][nx][ny])){\n      d[i][nx][ny]=max(d[i][x][y],L[i][nx][ny]);\n      pque.push(mp(d[i][nx][ny],nx*W[i]+ny));\n     }\n    }\n   }\n   FOR(j,H[i]) FOR(k,W[i]) m[i][d[i][j][k]]++;\n   int tot=0;\n   lev[i].pb(0);\n   sum[i].pb(0);\n   for(ite=m[i].begin();ite!=m[i].end();ite++){\n    lev[i].pb(ite->first);\n    tot+=ite->second;\n    sum[i].pb(tot);\n   }\n  }\n  sum[1].pb(INT_MAX);\n  int mi=1<<30;\n  FOR(i,lev[0].size()){\n   int ind=lower_bound(ALL(sum[1]),R-sum[0][i])-sum[1].begin();\n   if(sum[1][ind]==INT_MAX) continue;\n   mi=min(mi,lev[1][ind]+lev[0][i]);\n  }\n  cout<<mi<<endl;\n  FOR(i,2){\n   m[i].clear();\n   lev[i].clear();\n   sum[i].clear();\n  }\n }\n}\n \nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nint w[2], h[2], l[2][500][500], sx[2], sy[2];\nint dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nint ans[2][100001];\nbool used[500][500], vis[500][500];\nint main() {\n\tint r;\n\twhile (scanf(\"%d\", &r), r) {\n\t\trep(k, 2) {\n\t\t\tscanf(\"%d%d%d%d\", &w[k], &h[k], &sy[k], &sx[k]); sx[k]--; sy[k]--;\n\t\t\trep(i, h[k])rep(j, w[k])scanf(\"%d\", &l[k][i][j]);\n\t\t}\n\t\tfill(ans[0], ans[2], INT_MAX);\n\t\tans[0][0] = ans[1][0] = 0;\n\t\trep(k, 2) {\n\t\t\tdeque<P>que[2]; bool b = 0;\n\t\t\tque[0].push_back(P(sx[k], sy[k]));\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tmemset(vis, 0, sizeof(vis));\n\t\t\tused[sx[k]][sy[k]] = true;\n\t\t\tint cnt = 0;\n\t\t\tint Min, Max = 1;\n\t\t\twhile (!que[b].empty()) {\n\t\t\t\tMin = INT_MAX;\n\t\t\t\tque[!b].clear();\n\t\t\t\twhile (!que[b].empty()) {\n\t\t\t\t\tP p = que[b].front(); que[b].pop_front();\n\t\t\t\t\tif (vis[p.first][p.second])continue;\n\t\t\t\t\tvis[p.first][p.second] = true;\n\t\t\t\t\tcnt++; if (cnt >= r)break;\n\t\t\t\t\trep(j, 4) {\n\t\t\t\t\t\tint nx = p.first + dx[j], ny = p.second + dy[j];\n\t\t\t\t\t\tif (0 <= nx&&nx < h[k] && 0 <= ny&&ny < w[k] && !used[nx][ny]) {\n\t\t\t\t\t\t\tif (l[k][nx][ny] <= Max) {\n\t\t\t\t\t\t\t\tused[nx][ny] = true;\n\t\t\t\t\t\t\t\tque[b].push_back(P(nx, ny));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (l[k][nx][ny] < Min)Min = l[k][nx][ny], que[!b].clear();\n\t\t\t\t\t\t\t\tif (l[k][nx][ny] == Min)que[!b].push_back(P(nx, ny));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans[k][cnt] = min(ans[k][cnt], Max);\n\t\t\t\tif (cnt >= r)break;\n\t\t\t\tb = !b;\n\t\t\t\tMax = max(Max, Min);\n\t\t\t}\n\t\t}\n\t\trep(k, 2)for (int i = r - 1; i >= 1; i--)ans[k][i] = min(ans[k][i], ans[k][i + 1]);\n\t\tint Min = INT_MAX;\n\t\tfor (int i = 1; i <= r; i++) {\n\t\t\tif (ans[0][i] == INT_MAX || ans[1][r - i] == INT_MAX)continue;\n\t\t\tMin = min(Min, ans[0][i] + ans[1][r - i]);\n\t\t}\n\t\tprintf(\"%d\\n\", Min);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define s(x) scanf(\"%d\",&x)\n#define rep(i,x) for(int i=0;i<x;i++)\nint v[500*500+500]={};\nint v2[500*500+500]={};\nint a[505][505];\nint b[505][505];\nbool used[505][505]={};\nint main()\n{\n\twhile(1)\n\t{\n\t\tint r;\n\t\tint w1,h1,x1,y1;\n\t\tscanf(\"%d\",&r);if(!r) return 0;\n\t\tscanf(\"%d %d %d %d\",&w1,&h1,&x1,&y1);\n\t\tfor(int i=1;i<=h1;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=w1;j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&a[j][i]);\n\t\t\t}\n\t\t}\n\t\tint w2,h2,x2,y2;\n\t\tscanf(\"%d %d %d %d\",&w2,&h2,&x2,&y2);\n\t\tfor(int i=1;i<=h2;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=w2;j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&b[j][i]);\n\t\t\t}\n\t\t}\n\t\tmemset(used,0,sizeof(used));\n\t\tpriority_queue<P1,vector<P1>,greater<P1> >que;\n\t\tque.push(mp(1,mp(x1,y1)));\n\t\tint cur=0;\n\t\tint now=0;\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tP1 p=que.top(); que.pop();\n\t\t\tint x=p.second.first;\n\t\t\tint y=p.second.second;\n\t\t\tif(used[x][y]) continue;\n\t\t\tused[x][y]=true;\n\t\t\tnow=max(now,p.first);\n\t\t\tv[++cur]=now;\n\t\t\tint dx[4]={0,1,0,-1};\n\t\t\tint dy[4]={1,0,-1,0};\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t{\n\t\t\t\tint nx=x+dx[i];\n\t\t\t\tint ny=y+dy[i];\n\t\t\t\tif(!(1<=nx && nx<=w1)) continue;\n\t\t\t\tif(!(1<=ny && ny<=h1)) continue;\n\t\t\t\tif(used[nx][ny]) continue;\n\t\t\t\tque.push(mp(a[nx][ny],mp(nx,ny)));\n\t\t\t}\n\t\t}\n\t\tmemset(used,0,sizeof(used));\n\t\tque.push(mp(1,mp(x2,y2)));\n\t\tcur=now=0;\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tP1 p=que.top(); que.pop();\n\t\t\tint x=p.second.first;\n\t\t\tint y=p.second.second;\n\t\t\tif(used[x][y]) continue;\n\t\t\tused[x][y]=true;\n\t\t\tnow=max(now,p.first);\n\t\t\tv2[++cur]=now;\n\t\t\tint dx[4]={0,1,0,-1};\n\t\t\tint dy[4]={1,0,-1,0};\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t{\n\t\t\t\tint nx=x+dx[i];\n\t\t\t\tint ny=y+dy[i];\n\t\t\t\tif(!(1<=nx && nx<=w2)) continue;\n\t\t\t\tif(!(1<=ny && ny<=h2)) continue;\n\t\t\t\tif(used[nx][ny]) continue;\n\t\t\t\tque.push(mp(b[nx][ny],mp(nx,ny)));\n\t\t\t}\n\t\t}\n//for(int i=0;i<=w1*h1;i++) printf(\"%ds \",v[i]);\n \n//for(int i=0;i<=w2*h2;i++) printf(\"%ds \",v2[i]); \n\t\tint ret=INF;\n\t\tfor(int i=max(0,r-w2*h2);i<=min(r,w1*h1);i++)\n\t\t{\n\t\t\tret=min(ret,v[i]+v2[r-i]);\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<cassert>\n#include<queue>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n#define MAX 501\nusing namespace std;\n\nstruct P\n{\n  int x,y;\n  P(int x=inf,int y=inf):x(x),y(y){}\n  bool operator < (const P& a)const\n  {\n    return (x!=a.x?x<a.x:y<a.y);\n  } \n};\n\ntypedef pair<int,int> ii;\n\nint R;\nint room[2][MAX][MAX];\nint ex[2],ey[2];\nint h[2],w[2];\nvector<int> level[2];\nvector<ii> vec[2];\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nint getCost(int sp,int l)\n{\n  if(room[sp][ey[sp]][ex[sp]] > l)return 0;\n\n  int H = h[sp], W = w[sp];\n  bool visited[H][W];\n  rep(i,H)rep(j,W)visited[i][j] = false;\n  visited[ey[sp]][ex[sp]] = true;\n\n  deque<P> deq;\n  deq.push_back(P(ex[sp],ey[sp]));\n\n  int cost = 1;\n\n  while(!deq.empty())\n    {\n      P p = deq.front(); deq.pop_front();\n\n      rep(i,4)\n\t{\n\t  int nx = p.x + dx[i];\n\t  int ny = p.y + dy[i];\n\t  if(!(0 <= nx && nx < W && 0 <= ny && ny < H))continue;\n\t  if(room[sp][ny][nx] > l)continue;\n\t  if(!visited[ny][nx])\n\t    {\n\t      visited[ny][nx] = true;\n\t      deq.push_back(P(nx,ny));\n\t      cost++;\n\t    }\n\t}\n\n    }\n  return cost;\n}\n\nvoid compute()\n{\n  rep(i,2)\n    {\n      vec[i].push_back(ii(0,0));\n      rep(j,level[i].size())\n\t{\n\t  int cost = getCost(i,level[i][j]);\n\t  vec[i].push_back(ii(cost,level[i][j]));\n\t}\n      sort(all(vec[i]));\n    }\n\n  /*\n  rep(i,2)\n    {\n      rep(j,vec[i].size())\n\t{\n\t  cout << \"vec[\"<<i<<\"][\"<<j<<\"] = (\" << vec[i][j].first << \",\" << vec[i][j].second << \")\\n\";\n\t}\n    }\n  */\n\n  int minlevel = inf;\n  rep(i,vec[0].size())\n    {\n      int lvl = vec[0][i].second;\n      int cost = vec[0][i].first;\n      int request = R - cost;\n      if(request <= 0)\n\t{\n\t  minlevel = min(minlevel,lvl);\n\t  continue;\n\t}\n\n      if(lower_bound(all(vec[1]),ii(request,-1)) == vec[1].end())continue;\n      ii store = *lower_bound(all(vec[1]),ii(request,-1));\n      int nlvl = store.second;\n      int ncost = store.first;\n      //cout << \"lvl = \" << lvl << \" nlvl = \" << nlvl << \" cost = \" << cost << \" ncost = \" << ncost <<  \" request : \" << request << endl; \n      minlevel = min(minlevel,lvl+nlvl);\n    }\n  cout << minlevel << endl;\n}\n\nint main()\n{\n  while(cin >> R,R)\n    {\n      rep(i,2)\n\t{\n\t  level[i].clear(),vec[i].clear();\n\t  cin >> w[i] >> h[i] >> ex[i] >> ey[i];\n\t  ex[i]--,ey[i]--;\n\t  rep(y,h[i])rep(x,w[i])cin >> room[i][y][x],level[i].push_back(room[i][y][x]);\n\t  sort(all(level[i]));\n\t  level[i].erase(unique(all(level[i])),level[i].end());\n\t}\n      compute();\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <numeric>\n#include <map>\n#include <vector>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <cmath>\n#include <stack>\n#include <cctype>\n#include <queue>\n#include <algorithm>\n#include <memory>\n#include <memory.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nconst int INF = 1 << 30;\nconst double EPS = 1e-10;\nconst double PI = 3.14159;\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, -1, 0, 1};\nbool used[2][502][502];\nint office[2][502][502];\nint cost[2][110000];\nint w[2];\nint h[2];\nint x[2];\nint y[2];\n\nint main(){\n\tint R;\n\twhile(cin >> R && R){\n\t\tfill(&office[0][0][0], &office[1][501][501] + 1, INF);\n\t\tfill(&cost[0][0], &cost[1][109999] + 1, INF);\n\t\tmemset(used, false, sizeof(used));\n\t\tfor(int i = 0; i < 2; i++){\n\t\t\tcin >> w[i] >> h[i] >> x[i] >> y[i];\n\t\t\tfor(int j = 1; j <= h[i]; j++){\n\t\t\t\tfor(int k = 1; k <= w[i]; k++){\n\t\t\t\t\tcin >> office[i][j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 2; i++){\n\t\t\tpriority_queue<PP, vector<PP>, greater<PP> > que;\n\t\t\tcost[i][0] = 0;\n\t\t\tint m_cost = 0;\n\t\t\tint count = 1;\n\t\t\tque.push(PP(1, P(y[i], x[i])));\n\t\t\twhile(!que.empty()){\n\t\t\t\tPP pp = que.top();\n\t\t\t\tque.pop();\n\t\t\t\tint c = pp.first;\n\t\t\t\tif(c == INF || count >= R + 10 || count > h[i] * w[i]) break;\n\t\t\t\tm_cost = max(m_cost, c);\n\t\t\t\tint y1 = pp.second.first;\n\t\t\t\tint x1 = pp.second.second;\n\t\t\t\tused[i][y1][x1] = true;\n\t\t\t\tcost[i][count++] = m_cost;\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tint y2 = y1 + dy[j];\n\t\t\t\t\tint x2 = x1 + dx[j];\n\t\t\t\t\tif(used[i][y2][x2]) continue;\n\t\t\t\t\tque.push(PP(office[i][y2][x2], P(y2, x2)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = INF;\n\t\tfor(int i = 0; i <= R; i++){\n\t\t\tres = min(res, cost[0][i] + cost[1][R-i]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<map>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int i,j,k;\n  int r;\n  while(cin>>r&&r){\n    int a[2][502][502],w[2],h[2],x[2],y[2];\n    memset(a,-1,sizeof(a));\n    for(i=0;i<2;i++){\n      cin>>w[i]>>h[i]>>x[i]>>y[i];\n      for(j=1;j<h[i]+1;j++)\n\tfor(k=1;k<w[i]+1;k++)\n\t  cin>>a[i][k][j];\n    }\n    unsigned b[2][502][502];\n    memset(b,-1,sizeof(b));\n    for(i=0;i<2;i++){\n      queue<pair<pair<int,int>,int> > c;\n      c.push(make_pair(make_pair(x[i],y[i]),0));\n      while(c.empty()==0){\n\tint u,v,z;\n\tu=c.front().first.first;\n\tv=c.front().first.second;\n\tz=c.front().second;\n\tc.pop();\n\tif(a[i][u][v]!=-1&&b[i][u][v]>(unsigned)max(a[i][u][v],z)){\n\t  b[i][u][v]=max(a[i][u][v],z);\n\t  c.push(make_pair(make_pair(u-1,v),max(a[i][u][v],z)));\n\t  c.push(make_pair(make_pair(u+1,v),max(a[i][u][v],z)));\n\t  c.push(make_pair(make_pair(u,v-1),max(a[i][u][v],z)));\n\t  c.push(make_pair(make_pair(u,v+1),max(a[i][u][v],z)));\n\t}\n      }\n    }\n    map<int,int> c[2];\n    map<int,int>::iterator it,jt,kt;\n    for(i=0;i<2;i++){\n      c[i][0]=0;\n      for(j=1;j<h[i]+1;j++)\n\tfor(k=1;k<w[i]+1;k++)\n\t  c[i][b[i][k][j]]++;\n    }\n    for(i=0;i<2;i++){\n      it=jt=c[i].begin();\n      for(jt++;jt!=c[i].end();){\n\t(*jt).second+=(*it).second;\n\tit++;\n\tjt++;\n      }\n    }\n    unsigned mn=-1;\n    for(it=c[0].begin();it!=c[0].end();it++){\n      for(jt=c[1].begin();jt!=c[1].end()&&(*it).second+(*jt).second<r;jt++);\n      if(jt!=c[1].end())\n\tmn=min(mn,(unsigned)((*it).first+(*jt).first));\n      if((*it).second>=r)\n\tbreak;\n    }\n    cout<<mn<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nstruct state {\n\tint sx, sy, cost;\n};\nbool operator<(const state& s1, const state& s2) {\n\treturn s1.cost < s2.cost;\n}\nint R, H[2], W[2], sx[2], sy[2], a[2][509][509], cnt[2], b[2][250009]; bool vis[509][509];\nint dir[] = { 0, 1, 0, -1 };\nint main() {\n\twhile (scanf(\"%d\", &R), R) {\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tscanf(\"%d%d%d%d\", &W[i], &H[i], &sy[i], &sx[i]); sy[i]--, sx[i]--;\n\t\t\tfor (int j = 0; j < H[i]; j++) {\n\t\t\t\tfor (int k = 0; k < W[i]; k++) {\n\t\t\t\t\tscanf(\"%d\", &a[i][j][k]);\n\t\t\t\t\tvis[j][k] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpriority_queue<state> que; que.push(state{ sx[i], sy[i], -1 });\n\t\t\tvis[sx[i]][sy[i]] = true; cnt[i] = 1;\n\t\t\twhile (!que.empty()) {\n\t\t\t\tstate u = que.top(); que.pop();\n\t\t\t\tb[i][cnt[i]++] = a[i][u.sx][u.sy];\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tint tx = u.sx + dir[j], ty = u.sy + dir[j ^ 1];\n\t\t\t\t\tif (0 <= tx && tx < H[i] && 0 <= ty && ty < W[i] && !vis[tx][ty]) {\n\t\t\t\t\t\ta[i][tx][ty] = max(a[i][tx][ty], a[i][u.sx][u.sy]);\n\t\t\t\t\t\tvis[tx][ty] = true;\n\t\t\t\t\t\tque.push(state{ tx, ty, -a[i][tx][ty] });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 2000000009;\n\t\tfor (int i = 0; i <= H[0] * W[0]; i++) {\n\t\t\tint z = max(R - i, 0);\n\t\t\tif (z > H[1] * W[1]) continue;\n\t\t\tret = min(ret, b[0][i] + b[1][z]);\n\t\t}\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<math.h>\n#include<queue>\n#include<set>\n#include<map>\n#include<random>\n#include<functional>\n#include<utility>\n\ntypedef long long ll;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define pb push_back\n#define P pair<int, int>\n#define PLI pair<ll, int>\n#define PLL pair<ll, ll>\n#define VI vector<int>\n#define VII vector<VI>\n\nusing namespace std;\n\n\nconst int INF = 1e9;\n\nint dx[] = { 0, 0, -1, 1 };\nint dy[] = { -1, 1, 0, 0 };\n\nint R, W, H, X, Y;\nint sz[2];\nVI need[2];\nVII L, used;\n\nstruct room\n{\n\tint l, x, y;\n\troom(int l, int x, int y) :l(l), x(x), y(y) {}\n\tbool operator< (const room& r) const {\n\t\treturn l > r.l;\n\t}\n};\n\nint main() {\n\twhile (cin >> R, R)\n\t{\n\t\trep(k, 2) {\n\t\t\tcin >> W >> H >> X >> Y;\n\t\t\tneed[k] = VI(W*H+1);\n\t\t\tsz[k] = min(R, W*H);\n\t\t\tL = used = VII(W+2, VI(H+2));\n\t\t\trep(j, H) {\n\t\t\t\trep(i, W) {\n\t\t\t\t\tcin >> L[i+1][j+1];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint cnt = 0;\n\t\t\tpriority_queue<room> pq;\n\t\t\tpq.emplace(1, X, Y);\n\t\t\twhile (!pq.empty())\n\t\t\t{\n\t\t\t\troom now = pq.top(); pq.pop();\n\t\t\t\tused[now.x][now.y] = true;\n\n\t\t\t\tcnt++;\n\t\t\t\tneed[k][cnt] = max(need[k][cnt - 1], now.l);\n\n\t\t\t\trep(i, 4) {\n\t\t\t\t\tint nx = now.x + dx[i], ny = now.y + dy[i];\n\t\t\t\t\tif (L[nx][ny] == 0) continue;\n\t\t\t\t\tif (used[nx][ny]) continue;\n\t\t\t\t\tused[nx][ny] = true;\n\t\t\t\t\tpq.emplace(L[nx][ny], nx, ny);\n\t\t\t\t}\n\n\t\t\t\tif (cnt > R) break;\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\trep(i, sz[0] + 1) {\n\t\t\tif (R - i <= sz[1]) {\n\t\t\t\tans = min(ans, need[0][i] + need[1][R - i]);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <iterator>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <cmath>\n#include <complex>\n#include <functional>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <cstdlib>\n#include <cctype>\n\n#define REP(i,m,n) for(int i=m;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rp(i,c) rep(i,(int)c.size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define v_delete(a,b) (a).erase(remove((a).begin(), (a).end(), b), (a).end())\n#define v_unique(a) (a).erase(unique((a).begin(), (a).end()), (a).end())\n#define VV(T) vector<vector< T > >\n#define init(a,b) memset((a), (b), sizeof((a)))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double EPS=1e-9;\nconst long long INF = 100001000010000100ll;\n\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntypedef pair<int,int> pii;\n\nint R;\nint W[2], H[2], X[2], Y[2];\n\nint m[4][500+10][500+10];\nint visited[2][500+10][500+10];\n\nint wa[2][500*500*10];\n\nvi ls;\n\nmap<int ,int> cnt[2];\n\nbool exists(const map<int ,int> &mapp, int key){\n\treturn mapp.find(key) != mapp.end();\n}\n\nint dx[]={1,0,0,-1};\nint dy[]={0,1,-1,0};\n\nclass BIT{\nprivate:\n\tvi bit;\n\tint n;\npublic:\n\tBIT(int _n){\n\t\tn = _n;\n\t\tbit.assign(n+1,0 );\n\t}\n\tvoid add(int i, int x){\n\t\twhile(i <= n){\n\t\t\tbit[i] += x;\n\t\t\ti += (i & -i);\n\t\t}\n\t}\n\tint sum(int i){\n\t\tint s = 0;\n\t\twhile(i > 0){\n\t\t\ts += bit[i];\n\t\t\ti -= (i & -i);\n\t\t}\n\t\treturn s;\n\t}\n};\n\n\nint main(){\n\twhile(cin >> R){\n\n\t\tmemset(visited, 0, sizeof(visited));\n\n\t\tmemset(wa, 0, sizeof(wa));\n\n\t\tls.clear();\n\n\t\tfill_n(**m, 4 * (500+10) * (500+10), inf);\n\n\t\trep(c, 2){\n\t\t\tcin >> W[c] >> H[c] >> X[c] >> Y[c];\n\t\t\trep(i, H[c]){\n\t\t\t\trep(j, W[c]){\n\t\t\t\t\tcin >> m[c][i+1][j+1];\n\t\t\t\t\tm[c+2][i+1][j+1]=m[c][i+1][j+1];\n\t\t\t\t\tls.pb(m[c][i+1][j+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tls.pb(0);\n\t\tls.pb(inf);\n\t\tsort(all(ls));\n\t\tls.erase(unique(all(ls)), ls.end());\n\t\trep(c, 2){\n\t\t\tpriority_queue<pair<int, pii>, vector<pair<int, pii> >, greater<pair<int, pii> > >Q;\n\t\t\tQ.push(mp(1, mp(X[c], Y[c])));\n\t\t\twhile(!Q.empty()){\n\t\t\t\tint x,y,level;\n\t\t\t\tx=Q.top().second.first;y=Q.top().second.second;level=Q.top().first;\n\t\t\t\tvisited[c][y][x] = 1;\n\n\t\t\t\tif(level > m[c][y][x]){\n\t\t\t\t\tm[c][y][x] = level;\n\t\t\t\t}else{\n\t\t\t\t\tlevel = m[c][y][x];\n\t\t\t\t}\n\t\t\t\t//printf(\"%d %d %d %d\\n\",c, x, y, level);\n\n\t\t\t\tQ.pop();\n\t\t\t\trep(k, 4){\n\t\t\t\t\tif(m[c][y+dy[k]][x+dx[k]]!=inf){\n\t\t\t\t\t\tif(!visited[c][y+dy[k]][x+dx[k]]){\n\t\t\t\t\t\t\tQ.push(mp(max(m[c][y+dy[k]][x+dx[k]], level), mp(x+dx[k], y+dy[k])));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}/*\n\t\trep(c, 2){\n\t\t\trep(i, H[c]){\n\t\t\t\trep(j, W[c]){\n\t\t\t\t\tcout <<  m[c][i+1][j+1] << \" \";\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\tcout << endl;\n\t\t\tcout << endl;\n\t\t}*/\n\t\trep(c, 2){\n\t\t\trep(i, H[c]){\n\t\t\t\trep(j, W[c]){\n\t\t\t\t\tint ma=-1;\n\t\t\t\t\tint tmp=inf;\n\t\t\t\t\t/*\n\t\t\t\t\trep(k, 4){\n\t\t\t\t\t\ttmp=min(tmp, m[c][i + 1 + dx[k]][j + 1 + dy[k]]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i + 1 == Y[c] && j + 1 == X[c]){\n\t\t\t\t\t\tma=m[c][i + 1][j + 1];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tma = max(m[c][i + 1][j + 1], tmp);\n\t\t\t\t\t}*/\n\t\t\t\t\tma=m[c][i + 1][j + 1];\n\t\t\t\t\tint l = lower_bound(all(ls), ma) - ls.begin();\n\t\t\t\t\twa[c][l]++;\n\n\t\t\t\t}\n\t\t\t}\n\t\t\trp(i, ls){\n\t\t\t\tif(i - 1 >= 0)\n\t\t\t\t\twa[c][i] = wa[c][i - 1] + wa[c][i];\n\t\t\t}\n\n\t\t}\n\t\t/*\n\t\trep(c, 2){\n\t\t\trp(i, ls){\n\t\t\t\tcout << ls[i] << \" \" << wa[c][i] << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\tcout << endl;\n\t\t}*/\n\t\tint ans=inf;\n\t\trp(i, ls){\n\n\t\t\tint l=lower_bound(wa[1],(wa[1]+(int)ls.size()) , R - wa[0][i]) - wa[1];\n\t\t\tif(l < ls.size())\n\t\t\tif(wa[0][i] + wa[1][l] >= R){\n\t\t\t\t//cout << ls[i] << \" \" << ls[l] << endl;\n\t\t\t\tans=min(ans, ls[i] + ls[l]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<tuple>\n#include<functional>\nusing namespace std;\n\nconst int INF = 100000000 + 1;\n\nstruct Data {\n    int level, numbers;\n    Data(const int l, const int n) :level(l), numbers(n) {}\n};\n\nvector<Data> bfs(const vector<vector<int>>& office, const int Y, const int X) {\n    typedef tuple<int, int, int> Node;\n\n    const int H = office.size();\n    const int W = office.front().size();\n    const int NEXT[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    vector<Data> result;\n    vector<vector<bool>> visited(H, vector<bool>(W, false));\n    priority_queue<Node, vector<Node>, greater<Node>> q;\n    int level = 1;\n    int count = 0;\n\n    result.push_back(Data(0, 0));\n    q.push(Node(1, Y, X));\n    q.push(Node(INF, H, W));\n    visited[Y][X] = true;\n\n    while(!q.empty()) {\n        int l, y, x;\n        tie(l, y, x) = q.top();\n        q.pop();\n\n        if(l > level) {\n            result.push_back(Data(level, count));\n            level = l;\n        }\n\n        ++count;\n\n        for(const auto d: NEXT) {\n            int ny = y + d[0];\n            int nx = x + d[1];\n            if(ny < 0 || H <= ny || nx < 0 || W <= nx) continue;\n            if(visited[ny][nx]) continue;\n            visited[ny][nx] = true;\n            q.push(Node(office[ny][nx], ny, nx));\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    int R;\n    while(cin >> R, R) {\n        int W[2], H[2], X[2], Y[2];\n        vector<vector<int>> office[2];\n        for(int k = 0; k < 2; ++k) {\n            cin >> W[k] >> H[k] >> X[k] >> Y[k];\n            office[k].resize(H[k], vector<int>(W[k]));\n            for(int i = 0; i < H[k]; ++i) for(int j = 0; j < W[k]; ++j) cin >> office[k][i][j];\n        }\n\n        vector<Data> data[2];\n        for(int k = 0; k < 2; ++k) data[k] = bfs(office[k], --Y[k], --X[k]);\n\n        int answer = INF;\n        int b = data[1].size() - 1;\n        for(int a = 0; a < data[0].size(); ++a) {\n            if(data[0][a].numbers + data[1][b].numbers < R) continue; \n            while(0 < b && data[0][a].numbers + data[1][b].numbers >= R) --b;\n            if(data[0][a].numbers + data[1][b].numbers >= R) answer = min(answer, data[0][a].level + data[1][b].level);\n            if(b < data[1].size() - 1)                       answer = min(answer, data[0][a].level + data[1][b + 1].level);\n        }\n\n        cout << answer << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<deque>\n#include<iostream>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\n\n#define MAX(x,y) ((x>y)?(x):(y))\n#define min(x,y) ((x<y)?(x):(y))\ntypedef long long ll;\n\nusing namespace std;\n\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nstruct room{\n\tint x,y,l;\n\troom(int x0,int y0,int l0){x=x0;y=y0;l=l0;}\n\tbool operator < (room a) const {return (l>a.l);}\n};\nint L[2][505][505],f[505][505];\nint d[2][100005],e;\nint main(){\n\tint i,j,k;\n\tint w[2],h[2],r,x[2],y[2],cx,cy;\n\tint ma,ans;\n\tpriority_queue<room> q;\n\t\n\twhile(1){\n\t\tscanf(\"%d\",&r);\n\t\tif(r==0)break;\n\t\tmemset(L,-1,sizeof(L));\n\t\t\n\t\tfor(k=0;k<2;k++){\n\t\t\tscanf(\"%d%d%d%d\",&w[k],&h[k],&x[k],&y[k]);\n\t\t\tfor(i=1;i<=h[k];i++)for(j=1;j<=w[k];j++){\n\t\t\t\tscanf(\"%d\",&L[k][i][j]);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemset(d,-1,sizeof(d));\n\t\tfor(i=0;i<2;i++){\n\t\t\tmemset(f,0,sizeof(f)); \n\t\t\tf[y[i]][x[i]]=1;\n\t\t\tq.push(room(x[i],y[i],1));\n\t\t\tma=0;\n\t\t\te=0;\n\t\t\td[i][0]=0;\n\t\t\twhile(!q.empty()){\n\t\t\t\troom cr=q.top();\n\t\t\t\tq.pop();\n\t\t\t\te++;\n\t\t\t\tma=MAX(ma,cr.l);\n\t\t\t\td[i][e]=ma;\n\t\t\t\t//printf(\"%d\\n\",ma);\n\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\tcx=cr.x+dx[k];\n\t\t\t\t\tcy=cr.y+dy[k];\n\t\t\t\t\tif(L[i][cy][cx]>=0 && f[cy][cx]==0){\n\t\t\t\t\t\tq.push(room(cx,cy,L[i][cy][cx]));\n\t\t\t\t\t\tf[cy][cx]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//printf(\"END%d\\n\",i);\n\t\t\t\n\t\t\t/*for(j=1;j<=r;j++){\n\t\t\t\t//if(d[i][i]==0)d[i][j]=d[i][j-1];\n\t\t\t\t//printf(\"%d %3d ->%d\\n\",i,j,d[i][j]);\n\t\t\t}*/\n\t\t}\n\t\tans=1000000;\n\t\tfor(i=0;i<=r;i++){\n\t\t\tif(d[0][i]!=-1 && d[1][r-i]!=-1)ans=min(ans,d[0][i]+d[1][r-i]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> iP;\n#define pb push_back\n#define fi first\n#define sc second\n#define MAX_H 514\nint R;\nint W[2],H[2],X[2],Y[2];\nint L[2][MAX_H][MAX_H];\nbool F[2][MAX_H][MAX_H];\nvector<iP>data[2];\nint need[2][MAX_H*MAX_H];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nint main()\n{\n\tscanf(\"%d\",&R);\n\tfor(int i=0;i<2;i++){\n\t\tscanf(\"%d%d%d%d\",&W[i],&H[i],&X[i],&Y[i]);X[i]--;Y[i]--;\n\t\tfor(int j=0;j<H[i];j++){\n\t\t\tfor(int k=0;k<W[i];k++){\n\t\t\t\tscanf(\"%d\",&L[i][j][k]);\n\t\t\t\tif(j==Y[i]&&k==X[i]){continue;}\n\t\t\t\tdata[i].pb(iP(L[i][j][k],P(j,k)));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tsort(data[i].begin(),data[i].end());\n\t\tfor(int j=0;j<=W[i]*H[i];j++){\n\t\t\tneed[i][j]=(1<<30)-1;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tF[i][Y[i]][X[i]]=true;\n\t\tneed[i][0]=0;\n\t\tint cou=1;need[i][1]=1;\n\t\tfor(int j=0;j<(int)data[i].size();j++){\n\t\t\tint x=data[i][j].sc.fi;\n\t\t\tint y=data[i][j].sc.sc;\n\t\t\tbool flag=false;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tif(x+dx[k]<0||x+dx[k]>=H[i]||y+dy[k]<0||y+dy[k]>=W[i]){continue;}\n\t\t\t\tif(F[i][x+dx[k]][y+dy[k]])flag=true;\n\t\t\t}\n\t\t\tif(!flag){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tqueue<P>que;\n\t\t\tque.push(P(x,y));\n\t\t\twhile(!que.empty()){\n\t\t\t\tP p=que.front();que.pop();\n\t\t\t\tif(F[i][p.fi][p.sc])continue;\n\t\t\t\tF[i][p.fi][p.sc]=true;\n\t\t\t\t//printf(\"%d %d\\n\",p.fi,p.sc);\n\t\t\t\tcou++;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(p.fi+dx[k]<0||p.fi+dx[k]>=H[i]||p.sc+dy[k]<0||p.sc+dy[k]>=W[i]){continue;}\n\t\t\t\t\tif(F[i][p.fi+dx[k]][p.sc+dy[k]]){continue;}\n\t\t\t\t\tif(L[i][p.fi+dx[k]][p.sc+dy[k]]<=data[i][j].fi){\n\t\t\t\t\t\tque.push(P(p.fi+dx[k],p.sc+dy[k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tneed[i][cou]=L[i][x][y];\n\t\t\t//printf(\"%d:%d %d\\n\",cou,x,y);\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<2;i++){\n\t\tfor(int j=0;j<=W[i]*H[i];j++){\n\t\t\tprintf(\"need[%d][%d]=%d\\n\",i,j,need[i][j]);\n\t\t}\n\t}\n\t\n\tint ans=1<<30;\n\tfor(int i=0;i<=W[0]*H[0];i++){\n\t\tint k=R-i;\n\t\tif(k>W[1]*H[1]||k<0){\n\t\t\tcontinue;\n\t\t}\n\t\tans=min(need[0][i]+need[1][k],ans);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define POWT(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nconst pii Dir[8] = { //?????????\n\t{ 0,1 },{ 0,-1 },{ 1,0 },{ -1,0 },\n\t{ 1,1 },{ 1,-1 },{ -1,-1 },{ -1,1 }\n};\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\n\nsigned main() {\n\tint r;\n\n\twhile (scanf(\"%d\", &r)) {\n\t\tif (r == 0)\n\t\t\tbreak;\n\t\tint w, h, x, y;\n\t\tscanf(\"%d %d %d %d\", &w, &h, &y, &x);\n\t\tx--; y--;\n\t\tvector<vector<int>> m(h, vector<int>(w));\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tscanf(\"%d\", &m[i][j]);\n\t\t\t}\n\t\t}\n\t\tint w2, h2, x2, y2;\n\t\tscanf(\"%d %d %d %d\", &w2, &h2, &y2, &x2);\n\t\tx2--; y2--;\n\t\tvector<vector<int>> m2(h2, vector<int>(w2));\n\n\t\tREP(i, h2) {\n\t\t\tREP(j, w2) {\n\t\t\t\tscanf(\"%d\", &m2[i][j]);\n\t\t\t}\n\t\t}\n\t\tpriority_queue<pair<int, pii>, vector<pair<int, pii>>, greater<pair<int, pii>>> que;\n\n\t\tque.push({ 1,{ x,y } });\n\n\t\tmap<int, int> mcount;\n\t\tvector<vector<int>> al(h, vector<int>(w));\n\t\twhile (que.size()) {\n\t\t\tint  p = que.top().first;\n\t\t\tpii cur = que.top().second;\n\t\t\tque.pop();\n\t\t\tif (al[cur.first][cur.second])\n\t\t\t\tcontinue;\n\t\t\tal[cur.first][cur.second] = 1;\n\t\t\tmcount[p]++;\n\n\t\t\tREP(i, 4) {\n\t\t\t\tpii next = { cur.first + Dir[i].first, cur.second + Dir[i].second };\n\t\t\t\tif (RANGE(next.first, 0, h - 1) && RANGE(next.second, 0, w - 1)) {\n\t\t\t\t\tif (!al[next.first][next.second]) {\n\t\t\t\t\t\tque.push({ max(p,m[next.first][next.second]),next });\n\t\t\t\t\t\t//al[next.first][next.second] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<pii> cou;//????????????°??????¬??????\n\t\tfor (auto cur : mcount) {\n\t\t\tcou.push_back({ cur.second,cur.first });\n\t\t}\n\t\trep(i, 1, cou.size()) {\n\t\t\tcou[i].first += cou[i - 1].first;\n\t\t}\n\t\trep(i, 1, cou.size()) {\n\t\t\tif (cou[i].first == cou[i - 1].first) {\n\t\t\t\tif (cou[i].second > cou[i - 1].second)\n\t\t\t\t\tcou.erase(cou.begin() + i);\n\t\t\t\telse\n\t\t\t\t\tcou.erase(cou.begin() + i - 1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\n\t\tmcount.clear();\n\t\tal.swap(vector<vector<int>>(h2, vector<int>(w2)));\n\t\tque.push({ 1,{ x2,y2 } });\n\t\twhile (que.size()) {\n\t\t\tint  p = que.top().first;\n\t\t\tpii cur = que.top().second;\n\t\t\tque.pop();\n\t\t\tif (al[cur.first][cur.second])\n\t\t\t\tcontinue;\n\t\t\tal[cur.first][cur.second] = 1;\n\t\t\tmcount[p]++;\n\n\t\t\tREP(i, 4) {\n\t\t\t\tpii next = { cur.first + Dir[i].first, cur.second + Dir[i].second };\n\t\t\t\tif (RANGE(next.first, 0, h2 - 1) && RANGE(next.second, 0, w2 - 1)) {\n\t\t\t\t\tif (!al[next.first][next.second]) {\n\t\t\t\t\t\tque.push({ max(p,m2[next.first][next.second]),next });\n\t\t\t\t\t\t//al[next.first][next.second] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<pii> cou2;\n\t\tfor (auto cur : mcount) {\n\t\t\tcou2.push_back({ cur.second,cur.first });\n\t\t}\n\t\trep(i, 1, cou2.size()) {\n\t\t\tcou2[i].first += cou2[i - 1].first;\n\t\t}\n\t\trep(i, 1, cou2.size()) {\n\t\t\tif (cou2[i].first == cou2[i - 1].first) {\n\t\t\t\tif (cou2[i].second > cou2[i - 1].second)\n\t\t\t\t\tcou2.erase(cou2.begin() + i);\n\t\t\t\telse\n\t\t\t\t\tcou2.erase(cou2.begin() + i - 1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\n\t\tint Min = INT_MAX;\n\t\tcou.insert(cou.begin(), { 0,0 });\n\t\tcou2.insert(cou2.begin(), { 0,0 });\n\t\tREP(i, cou.size()) {\n\t\t\tauto itr = upper_bound(ALL(cou2), make_pair(r - cou[i].first, 0));\n\t\t\tif (itr != cou2.end()) {\n\t\t\t\tMin = min(Min, itr->second + cou[i].second);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", Min);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pint;\ntypedef pair<ll, int> P;\n//typedef tuple<int,int,int> T;\nll INFL = 1000000000000000010;//10^18 = 2^60\nint INF = 2147483600;//10^9\nll MOD  = 1000000007;\nvector<int> dy = {1,-1,0,0};\nvector<int> dx = {0,0,1,-1};\nvector<ll> Ans(0);\nvector<vector<ll>> mp1(510, vector<ll>(510));\nvector<vector<ll>> mp2(510, vector<ll>(510));\nint solve(){\n    int R;\n    cin >> R;\n    if(R == 0)return 0;\n    int H1,W1,X1,Y1;\n    cin >> W1 >> H1 >> X1 >> Y1;\n    X1--;\n    Y1--;\n    vector<vector<ll>> d1(H1, vector<ll>(W1, INFL));\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            cin >> mp1[i][j];\n        }\n    }\n    \n    d1[Y1][X1] = 1;\n    priority_queue<pair<ll, pair<int, int>>> pque1;\n    pque1.push({1, {Y1, X1}});\n    \n    while(!pque1.empty()){\n        ll c;\n        int y,x;\n        c = pque1.top().first;\n        y = pque1.top().second.first;\n        x = pque1.top().second.second;\n        pque1.pop();\n        if(c > d1[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H1 && 0 <= nx && nx < W1){\n                if(d1[ny][nx] > d1[y][x]){\n                    if(d1[y][x] > mp1[ny][nx]){\n                        d1[ny][nx] = d1[y][x];\n                    }else{\n                        d1[ny][nx] = mp1[ny][nx];\n                    }\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }else if(d1[ny][nx] > d1[y][x]){\n                    d1[ny][nx] = mp1[ny][nx];\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    int H2,W2,X2,Y2;\n    cin >> W2 >> H2 >> X2 >> Y2;\n    X2--;\n    Y2--;\n    vector<vector<ll>> d2(H2, vector<ll>(W2, INFL));\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            cin >> mp2[i][j];\n        }\n    }\n    \n    d2[Y2][X2] = 1;\n    priority_queue<pair<ll, pair<int, int>>> pque2;\n    pque2.push({1, {Y2, X2}});\n    \n    while(!pque2.empty()){\n        ll c;\n        int y,x;\n        c = pque2.top().first;\n        y = pque2.top().second.first;\n        x = pque2.top().second.second;\n        pque2.pop();\n        if(c > d2[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H2 && 0 <= nx && nx < W2){\n                if(d2[ny][nx] > d2[y][x]){\n                    if(d2[y][x] > mp2[ny][nx]){\n                        d2[ny][nx] = d2[y][x];\n                    }else{\n                        d2[ny][nx] = mp2[ny][nx];\n                    }\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }else if(d2[ny][nx] > d2[y][x]){\n                    d2[ny][nx] = mp2[ny][nx];\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    vector<pair<ll,int>> O1(0);\n    vector<ll> COST1(0);\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            COST1.push_back(d1[i][j]);\n        }\n    }\n    sort(COST1.begin(), COST1.end());\n    COST1.push_back(INFL);\n    ll ad1 = COST1.at(0);\n    for(int i = 0; i < COST1.size(); i++){\n        if(ad1 == COST1.at(i)){\n        }else{\n            O1.push_back({ad1, i});\n            ad1 = COST1.at(i);\n        }\n    }\n    \n    vector<pair<ll,int>> O2(1);\n    O2.at(0).first = 0;\n    O2.at(0).second = 0;\n    vector<ll> COST2(0);\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            COST2.push_back(d2[i][j]);\n        }\n    }\n    sort(COST2.begin(), COST2.end());\n    COST2.push_back(INFL);\n    ll ad2 = COST2.at(0);\n    for(int i = 0; i < COST2.size(); i++){\n        if(ad2 == COST2.at(i)){\n        }else{\n            O2.push_back({ad2, i});\n            ad2 = COST2.at(i);\n        }\n    }\n    \n    \n    ll ans = INFL;\n    int right = -1;\n    for(int i = 0; i < O1.size(); i++){\n        ll cost = O1.at(i).first;\n        int rest = R - O1.at(i).second;\n        \n        if(rest > O2.at(O2.size()-1).second) continue;\n        int left = -1;\n        if(right == -1){\n            right = O2.size();\n        }\n        int mid;\n        while(right - left > 1){\n            mid = (left + right) / 2;\n            if(O2.at(mid).second >= rest){\n                right = mid;\n            }else{\n                left = mid;\n            }\n        }\n        cost += O2.at(right).first;\n        ans = min(ans, cost);\n    }\n    \n    Ans.push_back(ans);\n    solve();\n    return 0;\n}\n\nint main(void){\n    solve();\n    for(int i = 0; i < Ans.size(); i++){\n        cout << Ans.at(i) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#include <utility>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <cstring>\nusing namespace std;\n#define INF 10000000\n\nint ary1[510][510],ary2[510][510];\nbool used[510][510];\nint main(){\n\tint R,W1,W2,H1,H2,X1,X2,Y1,Y2,imax,imay,imad,res;\n\tpriority_queue<pair<int,pair<int,int> > ,vector<pair<int,pair<int,int> > >,greater<pair<int,pair<int,int> > > > que;\n\tset<int> se1,se2;\n\tvector<int> v1,v2;\n\tpair<int,pair<int,int> > pa;\n\twhile(1){\n\t\tv1.clear();\n\t\tv2.clear();\n\t\tcin>>R;\n\t\tif(R==0) break;\n\t\tcin>>W1>>H1>>Y1>>X1;\n\t\tX1--;Y1--;\n\t\tfor(int i=0;i<H1;i++){\n\t\t\tfor(int j=0;j<W1;j++){\n\t\t\t\tcin>>ary1[i][j];\n\t\t\t}\n\t\t}\n\t\tcin>>W2>>H2>>Y2>>X2;\n\t\tX2--;Y2--;\n\t\tfor(int i=0;i<H2;i++){\n\t\t\tfor(int j=0;j<W2;j++){\n\t\t\t\tcin>>ary2[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemset(used,0,sizeof(used));\n\t\tque.push(make_pair(1,make_pair(X1,Y1)));\n\t\tused[X1][Y1]=true;\n\t\twhile(!que.empty()){\n\t\t\tpa=que.top();que.pop();\n\t\t\timax=pa.second.first;\n\t\t\timay=pa.second.second;\n\t\t\timad=pa.first;\n\t\t\tary1[imax][imay]=imad;\n\t\t\tif(imax>0&&(!used[imax-1][imay])){\n\t\t\t\tused[imax-1][imay]=true;\n\t\t\t\tque.push(make_pair(max(ary1[imax-1][imay],imad),make_pair(imax-1,imay)));\n\t\t\t}\n\t\t\tif(imax<H1-1&&(!used[imax+1][imay])){\n\t\t\t\tused[imax+1][imay]=true;\n\t\t\t\tque.push(make_pair(max(ary1[imax+1][imay],imad),make_pair(imax+1,imay)));\n\t\t\t}\n\t\t\tif(imay>0&&(!used[imax][imay-1])){\n\t\t\t\tused[imax][imay-1]=true;\n\t\t\t\tque.push(make_pair(max(ary1[imax][imay-1],imad),make_pair(imax,imay-1)));\n\t\t\t}\n\t\t\tif(imay<W1-1&&(!used[imax][imay+1])){\n\t\t\t\tused[imax][imay+1]=true;\n\t\t\t\tque.push(make_pair(max(ary1[imax][imay+1],imad),make_pair(imax,imay+1)));\n\t\t\t}\n\t\t}\n\t\tmemset(used,0,sizeof(used));\n\t\tque.push(make_pair(1,make_pair(X2,Y2)));\n\t\tused[X2][Y2]=true;\n\t\twhile(!que.empty()){\n\t\t\tpa=que.top();que.pop();\n\t\t\timax=pa.second.first;\n\t\t\timay=pa.second.second;\n\t\t\timad=pa.first;\n\t\t\tary2[imax][imay]=imad;\n\t\t\tif(imax>0&&(!used[imax-1][imay])){\n\t\t\t\tused[imax-1][imay]=true;\n\t\t\t\tque.push(make_pair(max(ary2[imax-1][imay],imad),make_pair(imax-1,imay)));\n\t\t\t}\n\t\t\tif(imax<H2-1&&(!used[imax+1][imay])){\n\t\t\t\tused[imax+1][imay]=true;\n\t\t\t\tque.push(make_pair(max(ary2[imax+1][imay],imad),make_pair(imax+1,imay)));\n\t\t\t}\n\t\t\tif(imay>0&&(!used[imax][imay-1])){\n\t\t\t\tused[imax][imay-1]=true;\n\t\t\t\tque.push(make_pair(max(ary2[imax][imay-1],imad),make_pair(imax,imay-1)));\n\t\t\t}\n\t\t\tif(imay<W2-1&&(!used[imax][imay+1])){\n\t\t\t\tused[imax][imay+1]=true;\n\t\t\t\tque.push(make_pair(max(ary2[imax][imay+1],imad),make_pair(imax,imay+1)));\n\t\t\t}\n\t\t}\n\t\tv1.push_back(0);\n\t\tfor(int i=0;i<H1;i++){\n\t\t\tfor(int j=0;j<W1;j++){\n\t\t\t\tv1.push_back(ary1[i][j]);\n\t\t\t}\n\t\t}\n\t\tsort(v1.begin(),v1.end());\n\t\tv2.push_back(0);\n\t\tfor(int i=0;i<H2;i++){\n\t\t\tfor(int j=0;j<W2;j++){\n\t\t\t\tv2.push_back(ary2[i][j]);\n\t\t\t}\n\t\t}\n\t\tsort(v2.begin(),v2.end());\n\t\tres=INF;\n\t\tfor(int i=0;i<=R;i++){\n\t\t\tif(W1*H1>=i&&W2*H2>=R-i)res=min(res,v1.at(i)+v2.at(R-i));\n\t\t}\n\t\tcout<<res<<endl;\n\t\t//\n\t\t/*for(int i=0;i<H1;i++){\n\t\t\tfor(int j=0;j<W1;j++){\n\t\t\t\tcout<<ary1[i][j]<<\" \";\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t\tfor(int i=0;i<H2;i++){\n\t\t\tfor(int j=0;j<W2;j++){\n\t\t\t\tcout<<ary2[i][j]<<\" \";\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}*/\n\t\t//\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//c\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <memory>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n \n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define REPR(i,b,n) for(int i=n-1;i>=b;i--)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\n#define NCLR(mat) memset(mat, -1, sizeof(mat))\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define EACH(i, c) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define BIT(n, b) ((n>>b) & 1)\n#define PB push_back\n#define MP make_pair\n \nusing namespace std;\n \nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-9;\ntypedef long long ll;\ntypedef pair<int, int> pii;   \n \nint r;\nint w[2], h[2], ex[2], ey[2];\nint room[2][512][512];\nbool vis[512][512];\n \nint rec(int x, int y, int k, int lev){\n     \n    int res = 0;\n     \n    if(x < 0 || w[k] <= x || y < 0 || h[k] <= y \n        || vis[x][y] || lev < room[k][x][y]){\n        return 0;\n    }\n     \n    vis[x][y] = true;\n     \n    res += rec(x+1, y, k, lev);\n    res += rec(x-1, y, k, lev);\n    res += rec(x, y+1, k, lev);\n    res += rec(x, y-1, k, lev);\n     \n    return res + 1;\n}\n \nint main(){\n     \n    while(cin>>r, r){\n         \n        vector< vector<int> > exlev(2);\n        vector< vector<int> > reach(2);\n         \n        for(int k=0; k<2; ++k){\n             \n            cin>>w[k]>>h[k]>>ex[k]>>ey[k];\n            ex[k]--;\n            ey[k]--;\n             \n             \n            exlev[k].push_back(0);\n             \n            for(int y=0; y<h[k]; ++y){\n                for(int x=0; x<w[k]; ++x){\n                     \n                    cin>>room[k][x][y];\n                    exlev[k].push_back(room[k][x][y]);\n                }\n            }\n\t\t\t\n\t\t\tsort( exlev[k].begin(), exlev[k].end() );\n\t\t\texlev[k].erase( unique(exlev[k].begin(), exlev[k].end()), exlev[k].end() );\n             \n            for(int i=0; i<exlev[k].size(); ++i){\n                CLR(vis);\n                reach[k].push_back(rec(ex[k], ey[k], k, exlev[k][i]));\n            }\n             \n        }\n         \n        int mn = INT_MAX/2;\n         \n        for(int i=0; i<reach[0].size(); ++i){\n            for(int j=0; j<reach[1].size(); ++j){\n                 \n                if(reach[0][i]+reach[1][j]>=r){\n                    mn = min(mn, exlev[0][i]+exlev[1][j]);\n                }\n                 \n            }\n        }\n         \n        cout << mn << endl;\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (1) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nstruct state {\n\tint sx, sy, cost;\n};\nbool operator<(const state& s1, const state& s2) {\n\treturn s1.cost < s2.cost;\n}\nint R, H[2], W[2], sx[2], sy[2], a[2][509][509], cnt[2], b[2][250009], vis[509][36];\nint dir[] = { 0, 1, 0, -1 };\nint main() {\n\twhile (scanf(\"%d\", &R), R) {\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tscanf(\"%d%d%d%d\", &W[i], &H[i], &sy[i], &sx[i]); sy[i]--, sx[i]--;\n\t\t\tfor (int j = 0; j < H[i]; j++) {\n\t\t\t\tfor (int k = 0; k < W[i]; k++) {\n\t\t\t\t\treader(&a[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpriority_queue<state> que; que.push(state{ sx[i], sy[i], -1 });\n\t\t\tmemset(vis, 0, sizeof(vis));\n\t\t\tvis[sx[i]][sy[i] >> 5] |= 1 << (sy[i] & 31); cnt[i] = 1;\n\t\t\twhile (!que.empty()) {\n\t\t\t\tstate u = que.top(); que.pop();\n\t\t\t\tb[i][cnt[i]++] = a[i][u.sx][u.sy];\n\t\t\t\tif (cnt[i] > R) break;\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tint tx = u.sx + dir[j], ty = u.sy + dir[j ^ 1];\n\t\t\t\t\tif (0 <= tx && tx < H[i] && 0 <= ty && ty < W[i] && !(vis[tx][ty >> 5] & (1 << (ty & 31)))) {\n\t\t\t\t\t\ta[i][tx][ty] = max(a[i][tx][ty], a[i][u.sx][u.sy]);\n\t\t\t\t\t\tvis[tx][ty >> 5] |= 1 << (ty & 31);\n\t\t\t\t\t\tque.push(state{ tx, ty, -a[i][tx][ty] });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 2000000009;\n\t\tfor (int i = 0; i <= R && i <= H[0] * W[0]; i++) {\n\t\t\tint z = max(R - i, 0);\n\t\t\tif (z > H[1] * W[1]) continue;\n\t\t\tret = min(ret, b[0][i] + b[1][z]);\n\t\t}\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\n\nconst int INF=1000000000;\nconst long long int INF_=1000000000000000000;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nbool IsIn(int y,int x,int h,int w){\n\treturn 0<=y&&y<h&&0<=x&&x<w;\n}\n\nvoid BFS(vector<vector<int> > &f,vector<vector<int> > &l,int sy,int sx,int h,int w){\n\tvector<vector<bool> > done(h,vector<bool>(w,false));\n\tvector<vector<bool> > done_(h,vector<bool>(w,false));\n\tl[sy][sx]=1;\n\tdone[sy][sx]=done_[sy][sx]=true;\n\tqueue<Pi> que;\n\tREP(i,0,4){\n\t\tint ny=sy+dy[i],nx=sx+dx[i];\n\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\tdone_[ny][nx]=true;\n\t\tque.push(Pi(ny,nx));\n\t}\n\twhile(!que.empty()){\n\t\tPi p=que.front();\n\t\tque.pop();\n\t\tdone[p.F_][p.S_]=1;\n\t\tbool flag=true;\n\t\tint tmp=INF;\n\t\tREP(i,0,4){\n\t\t\tint ny=p.F_+dy[i],nx=p.S_+dx[i];\n\t\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\t\tif(done[ny][nx]) tmp=min(tmp,l[ny][nx]);\n\t\t\t//if(p.S_==2&&p.F_==1) cout << l[ny][nx] << endl;\n\t\t\tif(done[ny][nx]&&l[ny][nx]>=f[p.F_][p.S_]) flag=false;\n\t\t\tif(!done_[ny][nx]){\n\t\t\t\tdone_[ny][nx]=true;\n\t\t\t\tque.push(Pi(ny,nx));\n\t\t\t}\n\t\t}\n\t\t//if(p.S_==2&&p.F_==1) cout << tmp << endl << endl;\n\t\tif(flag) l[p.F_][p.S_]=f[p.F_][p.S_];\n\t\telse {\n\t\t\tif(tmp!=INF) l[p.F_][p.S_]=max(tmp,f[p.F_][p.S_]);\n\t\t\telse l[p.F_][p.S_]=f[p.F_][p.S_];\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tint R;\n\twhile(cin >> R&&R){\n\t\tint W[2],H[2],X[2],Y[2];\n\t\tvector<vector<int> > field[2];\n\t\tvector<vector<int> > level[2];\n\t\tint _max=0;\n\t\tREP(i,0,2){\n\t\t\tcin >> W[i] >> H[i] >> X[i] >> Y[i];\n\t\t\t--X[i]; --Y[i];\n\t\t\tfield[i].resize(H[i]);\n\t\t\tlevel[i].resize(H[i]);\n\t\t\tREP(j,0,H[i]){\n\t\t\t\tfield[i][j].resize(W[i]);\n\t\t\t\tlevel[i][j].resize(W[i]);\n\t\t\t}\n\t\t\tREP(y,0,H[i]) REP(x,0,W[i]){\n\t\t\t\tcin >> field[i][y][x];\n\t\t\t\t_max=max(_max,field[i][y][x]);\n\t\t\t}\n\t\t\tBFS(field[i],level[i],Y[i],X[i],H[i],W[i]);\n\n\t\t\t/*\n\t\t\tcout << endl << endl;\n\t\t\tREP(y,0,H[i]){\n\t\t\t\tREP(x,0,W[i]) cout << level[i][y][x] << ' ';\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\tvector<int> count[2],s[2];\n\t\tREP(i,0,2){\n\t\t\tcount[i].resize(_max+1);\n\t\t\ts[i].resize(_max+1);\n\t\t}\n\t\tREP(i,0,2) REP(y,0,H[i]) REP(x,0,W[i]) ++count[i][level[i][y][x]];\n\t\tREP(i,0,2) REP(j,1,_max+1) s[i][j]=s[i][j-1]+count[i][j];\n\t\tint result=INF;\n\t\tfor(int i=0; i<=_max&&i<=result; ++i){\n\t\t\t//cout << i << ' ' << s[0][i] << ' ' <<  (int)(lower_bound(s[1].begin(),s[1].end(),R-s[0][i])-s[1].begin()) << ' ' << s[1][(int)(lower_bound(s[1].begin(),s[1].end(),R-s[0][i])-s[1].begin())] << endl;\n\t\t\tint idx=(int)(lower_bound(s[1].begin(),s[1].end(),R-s[0][i])-s[1].begin());\n\t\t\tif(!(0<=idx&&idx<=_max)) continue;\n\t\t\tresult=min(result,i+idx);\n\t\t}\n\t\tcout << result << endl;\n\t}\n}\n\nint main(){\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nconst int dxy[5]={0,-1,0,1,0};\nint used[500][500];\nint main(){\n    int r;\n    while(scanf(\"%d\",&r),r){\n        vector<pair<int,int> >ans[2];\n        for(int k=0;k<2;k++){\n            int w,h,sx,sy;\n            int fld[500][500];\n            vector<int>vec(1,0);\n            scanf(\"%d%d%d%d\",&w,&h,&sx,&sy);\n            sx--;sy--;\n            for(int i=0;i<h;i++){\n                for(int j=0;j<w;j++){\n                    int v;\n                    scanf(\"%d\",&v);\n                    fld[i][j]=v;\n                    vec.push_back(v);\n                }\n            }\n            sort(vec.begin(),vec.end());\n            vec.erase(unique(vec.begin(),vec.end()),vec.end());\n            bool visited[500][500];\n            fill_n(*visited,500*500,false);\n            fill_n(*used,500*500,-1);\n            queue<pair<int,int> >que[2];\n            que[0].push(pair<int,int>(sy,sx));\n            for(int i=0;i<vec.size();i++){\n                    int cnt=0;\n                    while(que[i&1].size()){\n                        int y=que[i&1].front().first,x=que[i&1].front().second;\n                        que[i&1].pop();\n                        if(y<0||y>=h||x<0||x>=w)continue;\n                        if(visited[y][x])continue;\n                        if(used[y][x]==vec[i])continue;\n                        if(fld[y][x]>vec[i]){\n                            que[(i+1)&1].push(pair<int,int>(y,x));\n                            used[y][x]=vec[i];\n                            continue;\n                        }\n                        cnt++;\n                        visited[y][x]=true;\n                        for(int l=0;l<4;l++){\n                            int ty=y+dxy[l+1],tx=x+dxy[l];\n                            que[i&1].push(pair<int,int>(ty,tx));\n                        }\n                    }\n                    ans[k].push_back(pair<int,int>(cnt,vec[i]));\n                    ans[k][i].first+=(i?ans[k][i-1].first:0);\n            }\n\n        }\n\n        int Min=1e9;\n        for(int i=0;i<ans[0].size();i++){\n            int to=r-ans[0][i].first;\n            int lb=0,ub=ans[1].size();\n            while(ub-lb>1){\n                int mid=(ub+lb)/2;\n                if(ans[1][mid].first>to)ub=mid;\n                else lb=mid;\n            }\n            int value=ans[0][i].first+ans[1][ub-1].first;\n            if(value>=r){\n                Min=min(Min,ans[0][i].second+ans[1][ub-1].second);\n                //printf(\"%d:%d->%d\\n\",ans[0][i].second,ans[1][ub-1].second,value);\n            }\n        }\n        printf(\"%d\\n\",Min);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    int dy[] = {0, 0, 1, -1};\n    int dx[] = {1, -1, 0, 0};\n    const int INF = INT_MAX/2;\n\n    for(;;){\n        int r;\n        cin >> r;\n        if(r == 0)\n            return 0;\n\n        int w[2], h[2], x0[2], y0[2];\n        vector<vector<int> > room[2];\n        for(int i=0; i<2; ++i){\n            cin >> w[i] >> h[i] >> x0[i] >> y0[i];\n            room[i].assign(h[i]+2, vector<int>(w[i]+2, INF));\n            for(int j=1; j<=h[i]; ++j){\n                for(int k=1; k<=w[i]; ++k){\n                    cin >> room[i][j][k];\n                }\n            }\n        }\n\n        vector<int> level[2];\n        for(int i=0; i<2; ++i){\n            level[i].resize(h[i]*w[i]+1, INF);\n            level[i][0] = 0;\n            multimap<int, pair<int, int> > mm;\n            vector<vector<int> > check(h[i]+2, vector<int>(w[i]+2, INF));\n            mm.insert(make_pair(room[i][y0[i]][x0[i]], make_pair(y0[i], x0[i])));\n            check[y0[i]][x0[i]] = room[i][y0[i]][x0[i]];\n            int a = 1;\n            while(!mm.empty()){\n                int l = mm.begin()->first;\n                int y = mm.begin()->second.first;\n                int x = mm.begin()->second.second;\n                mm.erase(mm.begin());\n                if(l > check[y][x])\n                    continue;\n                level[i][a] = l;\n                ++ a;\n                for(int j=0; j<4; ++j){\n                    int y1 = y + dy[j];\n                    int x1 = x + dx[j];\n                    if(max(l, room[i][y1][x1]) < check[y1][x1]){\n                        mm.insert(make_pair(max(l, room[i][y1][x1]), make_pair(y1, x1)));\n                        check[y1][x1] = max(l, room[i][y1][x1]);\n                    }\n                }\n            }\n        }\n\n        int ret = INF;\n        for(int i=0; i<=r; ++i){\n            if(i >= level[0].size() || r-i >= level[1].size())\n                continue;\n            ret = min(ret, level[0][i] + level[1][r-i]);\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <climits>\n#include <vector>\nusing namespace std;\n\nstruct UF {\n    vector<int> p;\n    UF(int n):p(n,-1) {}\n    int rt(int x) {return p[x]<0?x:(p[x]=rt(p[x]));}\n    bool eq(int x,int y) {return rt(x)==rt(y);}\n    int siz(int x) {return -p[rt(x)];}\n    void cat(int x, int y) {\n        x=rt(x); y=rt(y);\n        if(x==y) return;\n        if(p[x]<p[y]) swap(x,y);\n        p[y]+=p[x];\n        p[x]=y;\n    }\n};\n\nint main() {\n    while(true) {\n        int r; scanf(\"%d\", &r);\n        if(r==0) break;\n        static pair<int,int> lv_rm[2][2*500*499+1];\n        static int lv_rm_siz[2];\n        for(int i = 0; i < 2; i++) {\n            int w,h,evx,evy; scanf(\"%d%d%d%d\", &w, &h, &evx, &evy); evx--; evy--;\n            int ev = evy*w+evx;\n            UF uf(w*h);\n            static int lvs[500*500];\n            for(int y = 0; y < h; y++) {\n                for(int x = 0; x < w; x++) {\n                    scanf(\"%d\", lvs+(y*w+x));\n                }\n            }\n            static pair<int,pair<int,int> > edg[2*500*499];\n            for(int y = 0; y < h; y++)\n                for(int x = 1; x < w; x++)\n                    edg[y*(w-1)+(x-1)] = make_pair(max(lvs[y*w+x],lvs[y*w+(x-1)]), make_pair(y*w+x,y*w+(x-1)));\n            for(int y = 1; y < h; y++)\n                for(int x = 0; x < w; x++)\n                    edg[h*(w-1)+(y-1)*w+x] = make_pair(max(lvs[y*w+x],lvs[(y-1)*w+x]), make_pair(y*w+x,(y-1)*w+x));\n            sort(edg, edg+h*(w-1)+(h-1)*w);\n            lv_rm_siz[i] = 0;\n            lv_rm[i][lv_rm_siz[i]++] = make_pair(0,0);\n            for(int j = 0; j < h*(w-1)+(h-1)*w; j++) {\n                int lv = edg[j].first;\n                int p0 = edg[j].second.first;\n                int p1 = edg[j].second.second;\n                uf.cat(p0,p1);\n                lv_rm[i][lv_rm_siz[i]++] = make_pair(lv,uf.siz(ev));\n            }\n        }\n        int min_lv_sum = INT_MAX;\n        int i0=0, i1=lv_rm_siz[1]-1;\n        while(i0<lv_rm_siz[0] && 0<=i1) {\n            int rooms = lv_rm[0][i0].second + lv_rm[1][i1].second;\n            if(rooms < r) {\n                i0++;\n            } else {\n                min_lv_sum = min(min_lv_sum, lv_rm[0][i0].first + lv_rm[1][i1].first);\n                i1--;\n            }\n        }\n        printf(\"%d\\n\", min_lv_sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n#include <limits.h>\nusing namespace std;\n\nstruct room \n{\n\tint level, x, y;\n\troom(int level, int x, int y)\n\t{ this->level = level, this->x = x, this->y = y; }\n\tbool operator < (room rhs) const\n\t{ return this->level > rhs.level; }\n};\n\nint map[2][500][500];\nbool visit[2][500][500];\nint result[2][100001];\n\nint main()\n{\n\tint r, w[2], h[2], sx[2], sy[2], tmp, sec, open, ans;\n\n\twhile(true) {\n\t\tscanf(\"%d\", &r);\n\t\tif(r == 0) break;\n\t\tfor(int i = 0; i < 2; ++i) {\n\t\t\tscanf(\"%d%d%d%d\", &w[i], &h[i], &sx[i], &sy[i]);\n\t\t\t--sx[i], --sy[i];\n\t\t\tfor(int y = 0; y < h[i]; ++y) {\n\t\t\t\tfor(int x = 0; x < w[i]; ++x) {\n\t\t\t\t\tscanf(\"%d\", &tmp);\n\t\t\t\t\tmap[i][x][y] = tmp;\n\t\t\t\t\tvisit[i][x][y] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 1; j <= r; ++j) result[i][j] = -1;\n\t\t\tresult[i][0] = 0;\n\t\t}\n\n\t\tpriority_queue<room> next;\n\t\tqueue<room> seek;\n\n\t\tfor(int i = 0; i < 2; ++i) {\n\t\t\topen = 0;\n\t\t\tsec = 0;\n\t\t\tnext.push(room(1, sx[i], sy[i]));\n\n\t\t\twhile(!next.empty() && open < r) {\n\t\t\t\tsec = next.top().level;\n\t\t\t\twhile(!next.empty()) {\n\t\t\t\t\troom m = next.top();\n\t\t\t\t\tif(m.level > sec) break;\n\t\t\t\t\tvisit[i][m.x][m.y] = true;\n\t\t\t\t\tseek.push(m);\n\t\t\t\t\tnext.pop();\n\t\t\t\t}\n\n\t\t\t\twhile(!seek.empty()) {\n\t\t\t\t\troom at = seek.front();\n\t\t\t\t\tseek.pop();\n\t\t\t\t\tresult[i][++open] = sec;\n\t\t\t\t\tfor(int rx = at.x - 1; rx < at.x + 2; ++rx) {\n\t\t\t\t\t\tfor(int ry = at.y - 1; ry < at.y + 2; ++ry) {\n\t\t\t\t\t\t\tif(abs(rx - at.x) + abs(ry - at.y) != 1) continue;\n\t\t\t\t\t\t\tif(rx < 0 || rx >= w[i] || ry < 0 || ry >= h[i]) continue;\n\t\t\t\t\t\t\tif(visit[i][rx][ry]) continue;\n\t\t\t\t\t\t\tif(map[i][rx][ry] <= sec) {\n\t\t\t\t\t\t\t\tseek.push(room(map[i][rx][ry], rx, ry));\n\t\t\t\t\t\t\t\tvisit[i][rx][ry] = true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnext.push(room(map[i][rx][ry], rx, ry));\n\t\t\t\t\t\t\t\tvisit[i][rx][ry] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 1; j <= open; ++j) {\n\t\t\t\tif(result[i][j] == -1)\n\t\t\t\t\tresult[i][j] = result[i][j - 1];\n\t\t\t\tprintf(\"%d \", result[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n%d: open=%d level=%d\\n\", i, open, sec);\n\t\t}\n\t\t\n\t\tans = INT_MAX;\n\t\tfor(int i = 0; i <= r; ++i) {\n\t\t\tif(result[0][i] == -1 || result[1][r - i] == -1) continue;\n\t\t\tans = min(ans, result[0][i] + result[1][r - i]);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <cassert>\nusing namespace std;\n\nclass state{\npublic:\n  int x,y,n;\n  state(int y=0, int x=0, int n=0):y(y),x(x),n(n){}\n  bool operator < (const state &s) const {return n > s.n;}\n};\n\nconst int INF = (1<<29);\ntypedef pair<int,int> P;\nint r,h,w,rx,ry,a[500][500],nowl,cntr;//,minl;\nint dy[] = {0,1,0,-1};\nint dx[] = {1,0,-1,0};\nbool f[500][500];\nvector<int> numr[2],numl[2];\npriority_queue<state> Q;\nset<P> s;\n\nbool check(int y, int x){\n  if(y < 0 || y >= h) return false;\n  if(x < 0 || x >= w) return false;\n  return true;\n}\n\nvoid dfs(int y, int x){\n  f[y][x] = true;\n  cntr++;\n  for(int i=0;i<4;i++){\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if(check(ny,nx) && !f[ny][nx]){\n      if(a[ny][nx] <= nowl) dfs(ny,nx);\n      else{\n\t//minl = min(minl,a[ny][nx]);\n\tif(s.find(P(ny,nx)) == s.end()){\n\t    Q.push(state(ny,nx,a[ny][nx]));\n\t    s.insert(P(ny,nx));\n\t  }\n\t  \n      }\n    }\n  }\n}\n\nvoid solve(int k){\n  nowl = 1;\n  numr[k].clear();\n  numl[k].clear();\n  s.clear();\n  fill(f[0],f[500],false);\n  //Q.clear();\n  Q.push(state(ry,rx,1));\n  cntr = 0;\n  while(!Q.empty()){\n    state u = Q.top();\n    Q.pop();\n    nowl = u.n;\n    /*\n    minl = INF;\n    for(int i=0;i<Q.size();i++){\n      if(a[][] <= nowl){\n\tif(!f[Q[i].first][Q[i].second]) dfs(Q[i].first,Q[i].second);\n\tQ.erase(Q.begin()+i);\n\ti--;\n\t}\n\t}*/\n    if(f[u.y][u.x]) continue;\n    dfs(u.y,u.x);\n\n    numr[k].push_back(cntr);\n    numl[k].push_back(nowl);\n    //if(cntr == h * w || cntr >= r) return;\n    //nowl = minl;\n  }\n}\n\nint main(){\n  while(cin >> r && r){\n    int ans = INF;\n    for(int k=0;k<2;k++){\n      cin >> w >> h >> rx >> ry;\n      rx--;\n      ry--;\n      for(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++)\n\t  cin >> a[i][j];\n      solve(k);\n\n      //for(int i=0;i<numr[k].size();i++) cout << numr[k][i] << ' ' << numl[k][i] << endl;\n      //cout << endl;\n\n    }\n    for(int i=0;i<numr[0].size();i++){\n      if(numr[0][i] >= r){\n\tans = min(numl[0][i],ans);\n\tbreak;\n      }\n      int cnt = r - numr[0][i];\n      int pos = upper_bound(numr[1].begin(), numr[1].end(), cnt) - numr[1].begin();\n      if(pos < numr[1].size()) ans = min(ans,numl[0][i] + numl[1][pos]);\n      pos = max(0,pos-1);\n      if(numr[0][i] + numr[1][pos] >= r) ans = min(ans,numl[0][i] + numl[1][pos]);\n    }\n    int pos = upper_bound(numr[1].begin(), numr[1].end(), r) - numr[1].begin();\n    if(pos < numr[1].size()) ans = min(ans,numl[1][pos]);\n    pos = max(0,pos-1);\n    if(numr[1][pos] >= r) ans = min(ans,numl[1][pos]);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef pair<int,int> P;\nint R;\nint W1,H1,X1,Y1;\nint W2,H2,X2,Y2;\nint L1[501][501];\nint L2[501][501];\nint AA[250010];\nint BB[250010];\nint num11[250010];\nint num22[250010];\nbool field1[501][501];\nbool field2[501][501];\nvector<P>XX1;vector<P>XX2;\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nint solve1(int x,int y,int num){\n\tbool FF=true;\n\tfor(int k=0;k<4;k++){\n\t\tif(x+dx[k]<0)continue;\n\t\tif(x+dx[k]>=W1)continue;\n\t\tif(y+dy[k]<0)continue;\n\t\tif(y+dy[k]>=H1)continue;\n\t\tif(field1[y+dy[k]][x+dx[k]])FF=false;\n\t}\n\tif(FF)return 0;\n\tint res=0;\n\tqueue<P>que;\n\tque.push(P(y,x));\n\twhile(!que.empty()){\n\t\tP p=que.front();que.pop();\n\t\tint pf=p.first;int ps=p.second;\n\t\tif(field1[pf][ps])continue;\n\t\tfield1[pf][ps]=true;res++;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tif(ps+dx[k]<0)continue;\n\t\t\tif(ps+dx[k]>=W1)continue;\n\t\t\tif(pf+dy[k]<0)continue;\n\t\t\tif(pf+dy[k]>=H1)continue;\n\t\t\tif(L1[pf+dy[k]][ps+dx[k]]>num)continue;\n\t\t\tif(!field1[pf+dy[k]][ps+dx[k]])que.push(P(pf+dy[k],ps+dx[k]));\n\t\t}\n\t}\n\treturn res;\n}\nint solve2(int x,int y,int num){\n\tbool FF=true;\n\tfor(int k=0;k<4;k++){\n\t\tif(x+dx[k]<0)continue;\n\t\tif(x+dx[k]>=W2)continue;\n\t\tif(y+dy[k]<0)continue;\n\t\tif(y+dy[k]>=H2)continue;\n\t\tif(field2[y+dy[k]][x+dx[k]])FF=false;\n\t}\n\tif(FF)return 0;\n\tint res=0;\n\tqueue<P>que;\n\tque.push(P(y,x));\n\twhile(!que.empty()){\n\t\tP p=que.front();que.pop();\n\t\tint pf=p.first;int ps=p.second;\n\t\tif(field2[pf][ps])continue;\n\t\tfield2[pf][ps]=true;res++;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tif(ps+dx[k]<0)continue;\n\t\t\tif(ps+dx[k]>=W2)continue;\n\t\t\tif(pf+dy[k]<0)continue;\n\t\t\tif(pf+dy[k]>=H2)continue;\n\t\t\tif(L2[pf+dy[k]][ps+dx[k]]>num)continue;\n\t\t\tif(!field2[pf+dy[k]][ps+dx[k]])que.push(P(pf+dy[k],ps+dx[k]));\n\t\t}\n\t}\n\treturn res;\n}\nint main()\n{\n\twhile(true){\n\t\tXX1.clear();XX2.clear();\n\t\tscanf(\"%d\",&R);\n\t\tif(R==0)break;\n\t\tscanf(\"%d%d%d%d\",&W1,&H1,&X1,&Y1);\n\t\tfor(int i=0;i<H1;i++){\n\t\t\tfor(int j=0;j<W1;j++){\n\t\t\t\tscanf(\"%d\",&L1[i][j]);\n\t\t\t\tXX1.push_back(P(L1[i][j],i*W1+j));\n\t\t\t}\n\t\t}\n\t\tsort(XX1.begin(),XX1.end());\n\t\tfor(int i=0;i<H1;i++){\n\t\t\tfor(int j=0;j<W1;j++){\n\t\t\t\tfield1[i][j]=false;\n\t\t\t}\n\t\t}\n\t\tfield1[Y1-1][X1-1]=true;\n\t\tnum11[1]=1;\n\t\tfor(int i=2;i<=XX1.size();i++){\n\t\t\tnum11[i]=num11[i-1];\n\t\t\tnum11[i]+=solve1(XX1[i-1].second%W1,XX1[i-1].second/W1,XX1[i-1].first);\n\t\t}\n\t\tfor(int i=XX1.size();i>=2;i--){\n\t\t\tif(XX1[i-1].first==XX1[i-2].first){\n\t\t\t\tnum11[i-1]=num11[i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<XX1.size();i++){\n\t\t\t//printf(\"%d:%d\\n\",XX1[i].first,num11[i+1]);\n\t\t}\n\t\tscanf(\"%d%d%d%d\",&W2,&H2,&X2,&Y2);\n\t\tfor(int i=0;i<H2;i++){\n\t\t\tfor(int j=0;j<W2;j++){\n\t\t\t\tscanf(\"%d\",&L2[i][j]);\n\t\t\t\tXX2.push_back(P(L2[i][j],i*W2+j));\n\t\t\t}\n\t\t}\n\t\tsort(XX2.begin(),XX2.end());\n\t\tfor(int i=0;i<H2;i++){\n\t\t\tfor(int j=0;j<W2;j++){\n\t\t\t\tfield2[i][j]=false;\n\t\t\t}\n\t\t}\n\t\tfield2[Y2-1][X2-1]=true;\n\t\tnum22[1]=1;\n\t\tfor(int i=2;i<=XX2.size();i++){\n\t\t\tnum22[i]=num22[i-1];\n\t\t\tnum22[i]+=solve2(XX2[i-1].second%W2,XX2[i-1].second/W2,XX2[i-1].first);\n\t\t}\n\t\tfor(int i=XX2.size();i>=2;i--){\n\t\t\tif(XX2[i-1].first==XX2[i-2].first){\n\t\t\t\tnum22[i-1]=num22[i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<XX2.size();i++){\n\t\t\t//printf(\"%d:%d\\n\",XX2[i].first,num22[i+1]);\n\t\t}\n\t\tint ans=1000000000;\n\t\tfor(int i=0;i<=H1*W1;i++){\n\t\t\tint RRR=R-num11[i];\n\t\t\tint l=0;int r=H2*W2+1;\n\t\t\twhile(r-l>1){\n\t\t\t\tint c=(l+r)/2;\n\t\t\t\tif(num22[c]<RRR)l=c;\n\t\t\t\telse r=c;\n\t\t\t}\n\t\t\twhile(l<=H1*W1&&num11[i]+num22[l]<R)l++;\n\t\t\tif(num11[i]+num22[l]<R)continue;\n\t\t\t//printf(\"%d %d\\n\",num11[i],num22[l]);\n\t\t\tint I=i-1;l--;\n\t\t\tif(I==-1)ans=min(ans,XX2[l].first);\n\t\t\telse if(l==-1)ans=min(ans,XX1[I].first);\n\t\t\telse ans=min(ans,XX1[I].first+XX2[l].first);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,-1,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pint pair<int,int>\n#define tint tuple<int,int,int>\n#define INF 1<<29\n#define MAX 501\nusing namespace std;\n\nint R,W[2],H[2],X[2],Y[2],L[2][MAX][MAX],d[2][MAX][MAX],dd[4]={0,-1,0,1};\nmap<int,int> m[2];\nmap<int,int>::iterator ite;\n\nvoid solve(){\n for(;;){\n  cin>>R;\n  if(!R) return;\n  FOR(i,2){\n   cin>>W[i]>>H[i]>>X[i]>>Y[i];\n   X[i]--;\n   Y[i]--;\n   FOR(j,H[i]) FOR(k,W[i]) cin>>L[i][j][k];\n   FOR(j,H[i]) FOR(k,W[i]) d[i][j][k]=INT_MAX/3;\n   d[i][X[i]][Y[i]]=1;\n   priority_queue<pint,vector<pint>,greater<pint>> pque;\n   pque.push(mp(1,X[i]*W[i]+Y[i]));\n   while(!pque.empty()){\n    pint p=pque.top(); pque.pop();\n    int x=p.second/W[i],y=p.second-x*W[i];\n    if(d[i][x][y]<p.first) continue;\n    FOR(j,4){\n     int nx=x+dd[j],ny=y+dd[j^1];\n     if(nx<0||ny<0||nx>=H[i]||ny>=W[i]) continue;\n     if(d[i][nx][ny]>max(d[i][x][y],L[i][nx][ny])){\n      d[i][nx][ny]=max(d[i][x][y],L[i][nx][ny]);\n      pque.push(mp(d[i][nx][ny],nx*W[i]+ny));\n     }\n    }\n   }\n   FOR(j,H[i]) FOR(k,W[i]) m[i][d[i][j][k]]++;\n   for(ite=m[i].begin();ite!=m[i].end();ite++){\n    if(ite==m[i].begin()) continue;\n    m[i][ite->first]+=m[i][(--ite)->first];\n    ite++;\n   }\n  }\n  int mi=m[1].lower_bound(R)->first;\n  for(ite=m[0].begin();ite!=m[0].end();ite++){\n   mi=min(mi,(ite->first)+(m[1].lower_bound(R-(ite->second))->first));\n  }\n  cout<<mi<<endl;\n  FOR(i,2) m[i].clear();\n }\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\nconst int MAX = 100000000;\nconst int dx[4] = {0, 0, 1, -1};\nconst int dy[4] = {-1, 1, 0, 0};\n\nstruct state {\n\tint x, y, level;\n\tstate(int x, int y, int level):x(x), y(y), level(level){}\n\tbool operator>(const state& s) const {\n\t\treturn level > s.level;\n\t}\n};\n\nmap<int, int> nextOffice() {\n\tint w, h, x, y;\n\tcin >> w >> h >> x >> y;\n\t--x;\n\t--y;\n\n\tvector<vector<int> > field(h, vector<int>(w));\n\tfor(int i = 0; i < h; ++i)\n\t\tfor(int j = 0; j < w; ++j)\n\t\t\tcin >> field[i][j];\n\n\tvector<vector<bool> > visited(h, vector<bool>(w, false));\n\tpriority_queue<state, vector<state>, greater<state> > que;\n\tque.push(state(x, y, field[y][x]));\n\n\twhile(!que.empty()) {\n\t\tstate s = que.top();\n\t\tque.pop();\n\n\t\tvisited[s.y][s.x] = true;\n\n\t\tfor(int i = 0; i < 4; ++i) {\n\t\t\tint nx = s.x + dx[i], ny = s.y + dy[i];\n\t\t\tif(nx < 0 || ny < 0 || nx >= w || ny >= h || visited[ny][nx])\n\t\t\t\tcontinue;\n\n\t\t\tchmax(field[ny][nx], field[s.y][s.x]);\n\t\t\tque.push(state(nx, ny, field[ny][nx]));\n\t\t}\n\t}\n\n\tmap<int, int> res;\n\tres.insert(make_pair(0, 0));\n\tfor(int i = 0; i < h; ++i)\n\t\tfor(int j = 0; j < w; ++j)\n\t\t\tres[field[i][j]] += 1;\n\n\tfor(map<int, int>::iterator it = res.begin(); it != res.end(); ++it) {\n\t\tmap<int, int>::iterator next = it;\n\t\t++next;\n\n\t\tif(next != res.end())\n\t\t\tnext->second += it->second;\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int r; cin >> r, r;) {\n\t\tmap<int, int> office1 = nextOffice();\n\t\tmap<int, int> office2 = nextOffice();\n\n\t\tint ans = MAX * 2;\n\t\tmap<int, int>::iterator it = office1.begin();\n\t\tmap<int, int>::reverse_iterator it2 = office2.rbegin();\n\t\tfor(; it != office1.end(); ++it) {\n\t\t\twhile(it2 != office2.rend() && it->second + it2->second >= r) {\n\t\t\t\tchmin(ans, it->first + it2->first);\n\t\t\t\t++it2;\n\t\t\t}\n\n\t\t\tif(it2 == office2.rend())\n\t\t\t\tgoto finish;\n\t\t}\n\n\tfinish:;\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<string>\n#include<queue>\n#include<climits>\nusing namespace std;\n\nint vx[4]={0,1,0,-1};\nint vy[4]={1,0,-1,0};\n\nstruct pos{\n  pos(){};\n  pos(int cost,int kpos,int xpos,int ypos){\n    c=cost;\n    k=kpos;\n    x=xpos;\n    y=ypos;\n  }\n  int c,k,x,y;\n};\n\nbool operator<(const pos &a,const pos &b){\n  return a.c>b.c;\n}\n\nint r;\npair<int,int> el[2];\nvector< vector<int> > map[2];\nvector< vector<int> > used[2];\nvoid init(){\n  map[0].clear();\n  map[1].clear();\n  used[0].clear();\n  used[1].clear();\n}\n\nint input(){\n  cin>>r;\n  if(r==0)return 0;\n  int x,y;\n  cin>>x>>y;\n  cin>>el[0].second;\n  cin>>el[0].first;\n  el[0].first--;\n  el[0].second--;\n  map[0].resize(y);\n  used[0].resize(y);\n  for(int i=0;i<y;i++){\n    used[0][i].resize(x);\n    for(int j=0;j<x;j++){\n      int tmp;\n      cin>>tmp;\n      map[0][i].push_back(tmp);\n    }\n  }\n  cin>>x>>y;\n  cin>>el[1].second;\n  cin>>el[1].first;\n  el[1].first--;\n  el[1].second--;\n  map[1].resize(y);\n  used[1].resize(y);\n  for(int i=0;i<y;i++){\n    used[1][i].resize(x);\n    for(int j=0;j<x;j++){\n      int tmp;\n      cin>>tmp;\n      map[1][i].push_back(tmp);\n    }\n  }\n  return r;\n\n}\n\nint solve(){\n  \n  priority_queue<pos> q;\n  q.push(pos(map[0][el[0].first][el[0].second] , 0 , el[0].first , el[0].second));\n\n  vector< pair<int,int> > cost_room[2];\n  pair<int,int> tmp_c[2];\n\n  tmp_c[0].first =0;\n  tmp_c[0].second=0;\n\n  while((!q.empty())){\n    pos tmp=q.top();q.pop();\n    if(used[tmp.k][tmp.x][tmp.y])continue; \n    if(tmp_c[tmp.k].first<tmp.c){\n      cost_room[tmp.k].push_back(tmp_c[tmp.k]);\n      tmp_c[tmp.k].second++;\n      tmp_c[tmp.k].first=tmp.c;\n    }else if(tmp_c[tmp.k].first>=tmp.c && tmp.c!=0){\n      tmp_c[tmp.k].second++;\n    }\n\n    used[tmp.k][tmp.x][tmp.y]=true;\n    for(int i=0;i<4;i++){\n      if((!(tmp.x+vx[i]<0||used[tmp.k].size()-1<tmp.x+vx[i]))\n          &&(!(tmp.y+vy[i]<0||used[tmp.k][tmp.x+vx[i]].size()-1<tmp.y+vy[i]))\n          &&(!used[tmp.k][tmp.x+vx[i]][tmp.y+vy[i]])){\n        q.push(pos( map[tmp.k][tmp.x+vx[i]][tmp.y+vy[i]], tmp.k, tmp.x+vx[i],tmp.y+vy[i]));\n      }\n    }\n  }\n  cost_room[0].push_back(tmp_c[0]);\n  \n  q.push(pos(map[1][el[1].first][el[1].second] , 1 , el[1].first , el[1].second));\n  tmp_c[1].first =0;\n  tmp_c[1].second=0;\n  while((!q.empty())){\n    pos tmp=q.top();q.pop();\n    if(used[tmp.k][tmp.x][tmp.y])continue; \n    if(tmp_c[tmp.k].first<tmp.c){\n      cost_room[tmp.k].push_back(tmp_c[tmp.k]);\n      tmp_c[tmp.k].second++;\n      tmp_c[tmp.k].first=tmp.c;\n    }else if(tmp_c[tmp.k].first>=tmp.c && tmp.c!=0){\n      tmp_c[tmp.k].second++;\n    }\n\n    used[tmp.k][tmp.x][tmp.y]=true;\n    for(int i=0;i<4;i++){\n      if((!(tmp.x+vx[i]<0||used[tmp.k].size()-1<tmp.x+vx[i]))\n          &&(!(tmp.y+vy[i]<0||used[tmp.k][tmp.x+vx[i]].size()-1<tmp.y+vy[i]))\n          &&(!used[tmp.k][tmp.x+vx[i]][tmp.y+vy[i]])){\n        q.push(pos( map[tmp.k][tmp.x+vx[i]][tmp.y+vy[i]], tmp.k, tmp.x+vx[i],tmp.y+vy[i]));\n      }\n    }\n  }\n  cost_room[1].push_back(tmp_c[1]);\n\n  \n  \n\n  int res=INT_MAX;\n  for(int i=0;i<cost_room[0].size();i++){\n    for(int j=0;j<cost_room[1].size();j++){\n      if( cost_room[0][i].second+cost_room[1][j].second>=r){\n        res=min(cost_room[0][i].first+cost_room[1][j].first,res);\n      }\n    }\n  }\n  return res;\n}\n\n\n\nint main(){\n  while(init(),input()){\n    cout<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n#define INF (1<<27)\ntypedef pair<int,int> _P;\ntypedef pair<int,_P> P;\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\nint R,L1[100001],L2[100001];\nint room1[500][500],W1,H1,X1,Y1;\nint room2[500][500],W2,H2,X2,Y2;\nbool vst[500][500];\nint main() {\n\twhile(scanf(\"%d\",&R),R) {\n\t\tscanf(\"%d %d %d %d\",&W1,&H1,&X1,&Y1); X1--; Y1--;\n\t\tfor(int y=0;y<H1;y++) for(int x=0;x<W1;x++)\n\t\t\tscanf(\"%d\",&room1[x][y]);\n\t\tscanf(\"%d %d %d %d\",&W2,&H2,&X2,&Y2); X2--; Y2--;\n\t\tfor(int y=0;y<H2;y++) for(int x=0;x<W2;x++)\n\t\t\tscanf(\"%d\",&room2[x][y]);\n\t\tfill(L1,L1+100001,INF);\n\t\tL1[0]=0;\n\t\tmemset(vst,0,sizeof(vst));\n\t\tpriority_queue<P,vector<P>,greater<P> > Q;\n\t\tQ.push(P(1,_P(X1,Y1)));\n\t\tvst[X1][Y1]=true;\n\t\tint r=1,l=1;\n\t\twhile(r<=R&&!Q.empty()) {\n\t\t\tP p=Q.top(); Q.pop();\n\t\t\tl=max(l,p.first);\n\t\t\tL1[r]=l;\n\t\t\tfor(int i=0;i<4;i++) {\n\t\t\t\tint nx=p.second.first+dx[i],ny=p.second.second+dy[i];\n\t\t\t\tif(0>nx||nx>=W1||0>ny||ny>=H1) continue;\n\t\t\t\tif(vst[nx][ny]) continue;\n\t\t\t\tvst[nx][ny]=true;\n\t\t\t\tQ.push(P(room1[nx][ny],_P(nx,ny)));\n\t\t\t}\n\t\t\tr++;\n\t\t}\n\t\tfill(L2,L2+100001,INF);\n\t\tL2[0]=0;\n\t\tmemset(vst,0,sizeof(vst));\n\t\tpriority_queue<P,vector<P>,greater<P> > _Q;\n\t\t_Q.push(P(1,_P(X2,Y2)));\n\t\tvst[X2][Y2]=true;\n\t\tr=1,l=1;\n\t\twhile(r<=R&&!_Q.empty()) {\n\t\t\tP p=_Q.top(); _Q.pop();\n\t\t\tl=max(l,p.first);\n\t\t\tL2[r]=l;\n\t\t\tfor(int i=0;i<4;i++) {\n\t\t\t\tint nx=p.second.first+dx[i],ny=p.second.second+dy[i];\n\t\t\t\tif(0>nx||nx>=W2||0>ny||ny>=H2) continue;\n\t\t\t\tif(vst[nx][ny]) continue;\n\t\t\t\tvst[nx][ny]=true;\n\t\t\t\t_Q.push(P(room2[nx][ny],_P(nx,ny)));\n\t\t\t}\n\t\t\tr++;\n\t\t}\n\t\tint ans=INF;\n\t\tfor(int i=0;i<=R;i++) ans=min(ans,L1[i]+L2[R-i]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nvoid reader(int *x) {\n\tint k = getchar_unlocked(); *x = k - '0';\n\twhile (1) {\n\t\tk = getchar_unlocked();\n\t\tif (k < '0' || k > '9') break;\n\t\t*x = ((*x) << 1) + ((*x) << 3) + k - '0';\n\t}\n}\nstruct state {\n\tint sx, sy, cost;\n};\nbool operator<(const state& s1, const state& s2) {\n\treturn s1.cost < s2.cost;\n}\nint R, H[2], W[2], sx[2], sy[2], a[2][509][509], cnt[2], b[2][250009], vis[509][36];\nint dir[] = { 0, 1, 0, -1 };\nint main() {\n\twhile (scanf(\"%d\", &R), R) {\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tscanf(\"%d%d%d%d\", &W[i], &H[i], &sy[i], &sx[i]); sy[i]--, sx[i]--;\n\t\t\tfor (int j = 0; j < H[i]; j++) {\n\t\t\t\tfor (int k = 0; k < W[i]; k++) {\n\t\t\t\t\treader(&a[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpriority_queue<state> que; que.push(state{ sx[i], sy[i], -1 });\n\t\t\tmemset(vis, 0, sizeof(vis));\n\t\t\tvis[sx[i]][sy[i]] = true; cnt[i] = 1;\n\t\t\twhile (!que.empty()) {\n\t\t\t\tstate u = que.top(); que.pop();\n\t\t\t\tb[i][cnt[i]++] = a[i][u.sx][u.sy];\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tint tx = u.sx + dir[j], ty = u.sy + dir[j ^ 1];\n\t\t\t\t\tif (0 <= tx && tx < H[i] && 0 <= ty && ty < W[i] && !(vis[tx][ty >> 5] & (1 << (ty & 31)))) {\n\t\t\t\t\t\ta[i][tx][ty] = max(a[i][tx][ty], a[i][u.sx][u.sy]);\n\t\t\t\t\t\tvis[tx][ty >> 5] |= 1 << (ty & 31);\n\t\t\t\t\t\tque.push(state{ tx, ty, -a[i][tx][ty] });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 2000000009;\n\t\tfor (int i = 0; i <= H[0] * W[0]; i++) {\n\t\t\tint z = max(R - i, 0);\n\t\t\tif (z > H[1] * W[1]) continue;\n\t\t\tret = min(ret, b[0][i] + b[1][z]);\n\t\t}\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint R,W,H,X,Y;\nint f[500][500];\nint v[500][500];\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\n\nclass State\n{\n\tpublic:\n\t\tint y,x,l;\n\t\tState(int a, int b, int c)\n\t\t{\n\t\t\ty=a; x=b; l=c;\n\t\t}\n\n\t\tbool operator<(const State &s) const\n\t\t{\n\t\t\treturn l>s.l;\n\t\t}\n};\n\nvoid bfs(vector<int> &lv, vector<int> &rm)\n{\n\tint nlv=0,nrm=0;\n\n\tmemset(v,0,sizeof(v));\n\tpriority_queue<State> q;\n\n\tv[Y][X] = 1;\n\tq.push(State(Y,X,f[Y][X]));\n\n\twhile(!q.empty())\n\t{\n\t\tState s=q.top(); q.pop();\n\t\n\t\tif(nlv < s.l)\n\t\t{\n\t\t\tlv.push_back(nlv);\n\t\t\trm.push_back(nrm);\n\t\t\tnlv = s.l;\n\t\t}\n\t\tnrm++;\n\n\t\tfor(int i=0; i<4; i++)\n\t\t{\n\t\t\tint ny = s.y+dy[i];\n\t\t\tint nx = s.x+dx[i];\n\n\t\t\tif(0<=ny && ny<H && 0<=nx && nx<W)\n\t\t\t{\n\t\t\t\tif(!v[ny][nx])\n\t\t\t\t{\n\t\t\t\t\tv[ny][nx] = 1;\n\t\t\t\t\tq.push(State(ny,nx,f[ny][nx]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlv.push_back(nlv);\n\trm.push_back(nrm);\n}\n\nint main()\n{\n\twhile(cin >> R, R)\n\t{\n\t\tvector<int> lv[2],rm[2];\n\t\tfor(int k=0; k<2; k++)\n\t\t{\n\t\t\tcin >> W >> H >> X >> Y;\n\t\t\tfor(int y=0; y<H; y++)\n\t\t\tfor(int x=0; x<W; x++)\n\t\t\t{\n\t\t\t\tcin >> f[y][x];\n\t\t\t}\n\n\t\t\tX--; Y--;\n\t\t\tbfs(lv[k],rm[k]);\n\t\t}\n\n\t\tint ans = (1<<30);\n\t\tfor(int i=0; i<rm[0].size(); i++)\n\t\t{\n\t\t\tint j = lower_bound(rm[1].begin(), rm[1].end(), R-rm[0][i]) - rm[1].begin();\n\n\t\t\tif(j<rm[1].size())\n\t\t\t{\n\t\t\t\tans = min(ans, lv[0][i]+lv[1][j]);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dr[4][2]={{0, 1},{1, 0},{0, -1},{-1, 0}};\n\nint R;\nint W, H, X, Y;\nint memo[501][501];\n\nvoid get(vector<vi> &d, int x, int y, vi &res){\n\tpriority_queue<pair<int, pii>, vector<pair<int, pii> >, greater<pair<int, pii> > > pq;\n\tmemset(memo, 63, sizeof(memo));\n\tpq.emplace(d[y][x], pii(x, y));\n\tmemo[y][x] = d[y][x];\n\tint p = 0;\n\tres[p++] = 0;\n\twhile(!pq.empty()){\n\t\tint c = pq.top().first;\n\t\tint x = pq.top().second.first;\n\t\tint y = pq.top().second.second;\n\t\tpq.pop();\n\t\tif(memo[y][x] < c) continue;\n\t\tif(res.size() <= p)break;\n\t\tres[p++] = c;\n\t\tREP(i, 4){\n\t\t\tint dx = x+dr[i][0];\n\t\t\tint dy = y+dr[i][1];\n\t\t\tif(dx<0||dy<0||W<=dx||H<=dy) continue;\n\t\t\tint dc = max(c, d[dy][dx]);\n\t\t\tif(chmin(memo[dy][dx], dc)) pq.emplace(dc, pii(dx, dy));\n\t\t}\n\t}\n}\n\nmain(){\n\twhile(cin >> R, R){\n\t\tvector<vi> l(2, vi(R+1, INF));\n\t\tREP(k, 2){\n\t\t\tcin >> W >> H >> X >> Y;\n\t\t\tvector<vi> d(H, vi(W));\n\t\t\tREP(i, H)REP(j, W) cin >> d[i][j];\n\t\t\tget(d, X-1, Y-1, l[k]);\n\t\t}\n\t\t\n\t\tint ans=INF;\n\t\tREP(i, R+1) ans = min(ans, l[0][i] + l[1][R-i]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<queue>\nusing namespace std;\n\nconst int dy[4]={-1,0,1,0},dx[4]={0,1,0,-1};\nint needlev[2][100002];\nint fld[500][500];\n\nstruct Data{\n\tint y,x,lev;\n\tData(){}\n\tData(int _y,int _x,int _lev){\n\t\ty=_y; x=_x; lev=_lev;\n\t}\n\tbool operator<(const Data &a)const{\n\t\treturn lev>a.lev;\n\t}\n};\n\nint main(){\n\tint W,H,X,Y,R;\n\tvector<int> r[2];\n\tcin>>R;\n\tfor(int K=0;K<2;K++){\n\t\tpriority_queue<Data> q;\n\t\tcin>>W>>H>>X>>Y; X--; Y--;\n\t\tq.push(Data(Y,X,1));\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tcin>>fld[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint cntR=0;\n\t\tData q_c;\n\t\tbool used[500][500]={};\n\t\tused[Y][X] = true;\n\t\twhile(!q.empty()){\n\t\t\tq_c = q.top(); q.pop();\n\t\t\tcntR++;\n\t\t\t//printf(\"%d: %d,%d,%d\\n\",cntR,q_c.y,q_c.x,q_c.lev);\n\t\t\tneedlev[K][cntR] = q_c.lev;\n\t\t\tif(cntR==R) break;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint ny = q_c.y+dy[i],\n\t\t\t\t\tnx = q_c.x+dx[i];\n\t\t\t\tif(ny<0 || H<=ny || nx<0 || W<=nx || used[ny][nx])\n\t\t\t\t\tcontinue;\n\t\t\t\tused[ny][nx] = true;\n\t\t\t\tq.push(Data(ny,nx,max(q_c.lev,fld[ny][nx])));\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=cntR;i++){\n\t\t\tif(needlev[i]!=needlev[i+1]){\n\t\t\t\tr[K].push_back(i);\n\t\t\t\t//printf(\"%d \",i);\n\t\t\t}\n\t\t}//puts(\"\");\n\t}\n\tint ans=1000000000;\n\tfor(int i=0;i<r[0].size();i++){\n\t\tvector<int>::iterator itr = lower_bound(r[1].begin(),r[1].end(),R-r[0][i]);\n\t\tif(itr!=r[1].end())\n\t\t\tans = min(ans,needlev[0][r[0][i]]+needlev[1][*itr]);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int>pii;\ntypedef pair<int,pii>piii;\nconst int dxy[5]={0,-1,0,1,0};\nint main(){\n    int r;\n    while(scanf(\"%d\",&r),r){\n        vector<pair<int,int> >ans[2];\n        for(int k=0;k<2;k++){\n            int w,h,sx,sy;\n            int fld[500][500];\n            vector<int>vec(1,0);\n            scanf(\"%d%d%d%d\",&w,&h,&sx,&sy);\n            sx--;sy--;\n            for(int i=0;i<h;i++){\n                for(int j=0;j<w;j++){\n                    int v;\n                    scanf(\"%d\",&v);\n                    fld[i][j]=v;\n                    vec.push_back(v);\n                }\n            }\n            sort(vec.begin(),vec.end());\n            vec.erase(unique(vec.begin(),vec.end()),vec.end());\n            priority_queue<piii,vector<piii>,greater<piii> >Q;\n            int pos=0,cnt=0;\n            Q.push(piii(1,pii(sy,sx)));\n            bool used[500][500]={{0}};\n            while(Q.size()){\n                int y=Q.top().second.first,x=Q.top().second.second;\n                int v=Q.top().first;\n                Q.pop();\n                if(used[y][x])continue;\n                if(v>vec[pos]){\n                    ans[k].push_back(pii(cnt,vec[pos]));\n                    pos++;\n                    Q.push(piii(v,pii(y,x)));\n                    continue;\n                }\n                used[y][x]=true;\n                cnt++;\n                for(int i=0;i<4;i++){\n                    int ty=y+dxy[i+1],tx=x+dxy[i];\n                    if(ty<0||ty>=h||tx<0||tx>=w)continue;\n                    Q.push(piii(fld[ty][tx],pii(ty,tx)));\n                }\n            }\n            ans[k].push_back(pii(cnt,vec[pos]));\n        }\n        //for(int k=0;k<2;k++)for(int i=0;i<ans[k].size();i++)printf(\"%d...%d:%d\\n\",k,ans[k][i].first,ans[k][i].second);\n\n        int Min=1000000000;\n        for(int i=0;i<ans[0].size();i++){\n            int to=r-ans[0][i].first;\n            int lb=-1,ub=ans[1].size();\n            while(ub-lb>1){\n                int mid=(ub+lb)/2;\n                if(ans[1][mid].first>=to)ub=mid;\n                else lb=mid;\n            }\n            if(ub==ans[1].size())continue;\n            int value=ans[0][i].first+ans[1][ub].first;\n            Min=min(Min,ans[0][i].second+ans[1][ub].second);\n\n            //printf(\"%d:%d->%d\\n\",ans[0][i].second,ans[1][ub].second,value);\n        }\n        printf(\"%d\\n\",Min);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<deque>\n#include<iostream>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\n\n#define MAX(x,y) ((x>y)?(x):(y))\n#define min(x,y) ((x<y)?(x):(y))\ntypedef long long ll;\n\nusing namespace std;\n\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nstruct room{\n\tint x,y,l;\n\troom(int x0,int y0,int l0){x=x0;y=y0;l=l0;}\n\tbool operator < (room a) const {return (l>a.l);}\n};\nint L[2][505][505],f[505][505];\nint d[2][250005],e;\nint main(){\n\tint i,j,k;\n\tint w[2],h[2],r,x[2],y[2],cx,cy;\n\tint ma,ans;\n\tpriority_queue<room> q;\n\t\n\twhile(1){\n\t\tscanf(\"%d\",&r);\n\t\tif(r==0)break;\n\t\tmemset(L,-1,sizeof(L));\n\t\t\n\t\tfor(k=0;k<2;k++){\n\t\t\tscanf(\"%d%d%d%d\",&w[k],&h[k],&x[k],&y[k]);\n\t\t\tfor(i=1;i<=h[k];i++)for(j=1;j<=w[k];j++){\n\t\t\t\tscanf(\"%d\",&L[k][i][j]);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemset(d,-1,sizeof(d));\n\t\tfor(i=0;i<2;i++){\n\t\t\tmemset(f,0,sizeof(f)); \n\t\t\tf[y[i]][x[i]]=1;\n\t\t\tq.push(room(x[i],y[i],1));\n\t\t\tma=0;\n\t\t\te=0;\n\t\t\td[i][0]=0;\n\t\t\twhile(!q.empty()){\n\t\t\t\troom cr=q.top();\n\t\t\t\tq.pop();\n\t\t\t\te++;\n\t\t\t\tma=MAX(ma,cr.l);\n\t\t\t\td[i][e]=ma;\n\t\t\t\t//printf(\"%d\\n\",ma);\n\t\t\t\tfor(k=0;k<4;k++){\n\t\t\t\t\tcx=cr.x+dx[k];\n\t\t\t\t\tcy=cr.y+dy[k];\n\t\t\t\t\tif(L[i][cy][cx]>=0 && f[cy][cx]==0){\n\t\t\t\t\t\tq.push(room(cx,cy,L[i][cy][cx]));\n\t\t\t\t\t\tf[cy][cx]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//printf(\"END%d\\n\",i);\n\t\t\t\n\t\t\t/*for(j=1;j<=r;j++){\n\t\t\t\t//if(d[i][i]==0)d[i][j]=d[i][j-1];\n\t\t\t\t//printf(\"%d %3d ->%d\\n\",i,j,d[i][j]);\n\t\t\t}*/\n\t\t}\n\t\tans=100000005;\n\t\tfor(i=0;i<=w[0]*h[0];i++){\n\t\t\tif(d[0][i]!=-1 && d[1][r-i]!=-1 && r-i>=0 && r-i<=w[1]*h[1])ans=min(ans,d[0][i]+d[1][r-i]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\nconst int N = 500;\nconst int INF = 1000000000;\n\nclass S{\npublic:\n  int x, y, cost;\n  S(){}\n  S(int x, int y, int cost) : x(x), y(y), cost(cost) {}\n  bool operator < (const S& s) const {\n    return cost > s.cost;\n  }\n};\n\nint R, w[2], h[2], sx[2], sy[2], input[2][N][N], vis[N][N];\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nvector<int> vec[2];\nset<int> used;\nvector<int> data;\nint cnt;\n\nvoid bfs(int d){\n  int x = sx[d];\n  int y = sy[d];\n  int cost = 1;\n  priority_queue<S> q;\n  S u;\n  q.push(S(x, y, cost));\n  vis[y][x] = cost;\n  while(!q.empty()){\n    u = q.top(); q.pop();\n    if(vis[u.y][u.x] < u.cost) continue;\n    for(int i=0;i<4;i++){\n      int ny = u.y + dy[i];\n      int nx = u.x + dx[i];\n      if(ny < 0 || ny >= h[d]) continue;\n      if(nx < 0 || nx >= w[d]) continue;\n      int tmp = max(u.cost, input[d][ny][nx]);\n      if(vis[ny][nx] > tmp){\n        vis[ny][nx] = tmp;\n        q.push(S(nx, ny, tmp));\n      }\n    }\n  }\n}\n\nvoid init(){\n  data.clear();\n  for(int k=0;k<2;k++){\n    for(int i=0;i<h[k];i++){\n      for(int j=0;j<w[k];j++){\n        data.push_back(input[k][i][j]);\n      }\n    }\n  }\n  sort(data.begin(), data.end());\n  for(int k=0;k<2;k++){\n    fill(vis[0], vis[N], INF);\n    for(int i=0;i<h[k];i++){\n      for(int j=0;j<w[k];j++){\n        vis[i][j] = INF;\n      }\n    }\n    bfs(k);\n\n    vec[k].clear();\n    for(int i=0;i<h[k];i++){\n      for(int j=0;j<w[k];j++){\n        vec[k].push_back(vis[i][j]);\n      }\n    }\n    sort(vec[k].begin(), vec[k].end());\n  }\n}\n\nbool check(int a, int b){\n  int t1 = distance(vec[0].begin(), upper_bound(vec[0].begin(), vec[0].end(), a));\n  int t2 = distance(vec[1].begin(), upper_bound(vec[1].begin(), vec[1].end(), b));\n  return t1 + t2 >= R;\n}\n\nint solve(){\n  int l = 0, r = data[data.size()-1] + 1;\n  while(l<r){\n    int m = (l + r) / 2;\n    bool f = false;\n    for(int i=0;i<data.size();i++){\n      if(data[i] > m) break;\n      if(check(data[i], m-data[i])) f = true;\n    }\n    if(f) r = m;\n    else l = m + 1;\n  }\n  return l;\n}\n\nmain(){\n  while(scanf(\"%d\", &R) && R){\n    for(int k=0;k<2;k++){\n      scanf(\"%d %d %d %d\", w+k, h+k, sx+k, sy+k);\n      sx[k]--; sy[k]--;\n      for(int i=0;i<h[k];i++){\n        for(int j=0;j<w[k];j++){\n          scanf(\"%d\", &input[k][i][j]);\n        }\n      }\n    }\n    init();\n    printf(\"%d\\n\", solve());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//c\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <memory>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define REPR(i,b,n) for(int i=n-1;i>=b;i--)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\n#define NCLR(mat) memset(mat, -1, sizeof(mat))\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define EACH(i, c) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define BIT(n, b) ((n>>b) & 1)\n#define PB push_back\n#define MP make_pair\n\nusing namespace std;\n\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-9;\ntypedef long long ll;\ntypedef pair<int, int> pii;   \n\nint r;\nint w[2], h[2], ex[2], ey[2];\nint room[2][512][512];\nbool vis[512][512];\n\nint rec(int x, int y, int k, int lev){\n\t\n\tint res = 0;\n\t\n\tif(x < 0 || w[k] <= x || y < 0 || h[k] <= y \n\t\t|| vis[x][y] || lev < room[k][x][y]){\n\t\treturn 0;\n\t}\n\t\n\tvis[x][y] = true;\n\t\n\tres += rec(x+1, y, k, lev);\n\tres += rec(x-1, y, k, lev);\n\tres += rec(x, y+1, k, lev);\n\tres += rec(x, y-1, k, lev);\n\t\n\treturn res + 1;\n}\n\nint main(){\n\t\n\twhile(cin>>r, r){\n\t\t\n\t\tvector< vector<int> > exlev(2);\n\t\tvector< vector<int> > reach(2);\n\t\t\n\t\tfor(int k=0; k<2; ++k){\n\t\t\t\n\t\t\tcin>>w[k]>>h[k]>>ex[k]>>ey[k];\n\t\t\tex[k]--;\n\t\t\tey[k]--;\n\t\t\t\n\t\t\t\n\t\t\texlev[k].push_back(0);\n\t\t\t\n\t\t\tfor(int y=0; y<h[k]; ++y){\n\t\t\t\tfor(int x=0; x<w[k]; ++x){\n\t\t\t\t\t\n\t\t\t\t\tcin>>room[k][x][y];\n\t\t\t\t\t\n\t\t\t\t\tif(!binary_search(exlev[k].begin(), exlev[k].end(), room[k][x][y])){\n\t\t\t\t\t\texlev[k].push_back(room[k][x][y]);\n\t\t\t\t\t\tsort(exlev[k].begin(), exlev[k].end());\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0; i<exlev[k].size(); ++i){\n\t\t\t\tCLR(vis);\n\t\t\t\treach[k].push_back(rec(ex[k], ey[k], k, exlev[k][i]));\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tint mn = INT_MAX/2;\n\t\t\n\t\tfor(int i=0; i<reach[0].size(); ++i){\n\t\t\tfor(int j=0; j<reach[1].size(); ++j){\n\t\t\t\t\n\t\t\t\tif(reach[0][i]+reach[1][j]>=r){\n\t\t\t\t\tmn = min(mn, exlev[0][i]+exlev[1][j]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << mn << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<queue>\n#include<map>\n#include<algorithm>\nusing namespace std;\ntypedef pair<int,int> P;\nint w[2];\nint h[2];\nint x[2];\nint y[2];\nint t[2][500][500];\nint m[2][500][500];\nbool used[2][500][500];\nvector<int> ad[2];\npriority_queue<P,vector<P>,greater<P> > que;\nint dx[4]={-1,0,1,0};\nint dy[4]={0,1,0,-1};\nint min(int a,int b){return a<b?a:b;}\nint max(int a,int b){return a>b?a:b;}\nvoid bfs(int a){\n\tint i;\n\tm[a][y[a]][x[a]]=1;\n\tque.push(P(1,y[a]*w[a]+x[a]));\n\twhile(!que.empty()){\n\t\tP p=que.top();que.pop();\n\t\tint xp=p.second%w[a];\n\t\tint yp=p.second/w[a];\n\t\tif(p.first>m[a][yp][xp])continue;\n\t\tused[a][yp][xp]=true;\n\t\tfor(i=0;i<4;i++){\n\t\t\tif(xp+dx[i]>=0&&xp+dx[i]<w[a]&&yp+dy[i]>=0&&yp+dy[i]<h[a]){\n\t\t\t\tif(!used[a][yp+dy[i]][xp+dx[i]]&&m[a][yp+dy[i]][xp+dx[i]]>max(p.first,t[a][yp+dy[i]][xp+dx[i]])){\n\t\t\t\t\tm[a][yp+dy[i]][xp+dx[i]]=max(p.first,t[a][yp+dy[i]][xp+dx[i]]);\n\t\t\t\t\tque.push(P(m[a][yp+dy[i]][xp+dx[i]],(yp+dy[i])*w[a]+(xp+dx[i])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tint r;\n\tint i,j,k;\n\twhile(1){\n\tscanf(\"%d\",&r);\n\tif(r==0)return 0;\n\tfor(i=0;i<2;i++){\n\t\tscanf(\"%d %d %d %d\",&w[i],&h[i],&x[i],&y[i]);\n\t\tx[i]--;y[i]--;\n\t\tfor(j=0;j<h[i];j++)for(k=0;k<w[i];k++)scanf(\"%d\",&t[i][j][k]);\n\t}\n\tfor(i=0;i<2;i++){\n\t\tfor(j=0;j<h[i];j++)for(k=0;k<w[i];k++){\n\t\t\tm[i][j][k]=200000000;\n\t\t\tused[i][j][k]=false;\n\t\t}\n\t\tbfs(i);\n\t}\n\tfor(i=0;i<2;i++){\n\t\tad[i].clear();\n\t\tad[i].push_back(0);\n\t\tfor(j=0;j<h[i];j++){\n\t\t\tfor(k=0;k<w[i];k++){\n\t\t\t\tad[i].push_back(m[i][j][k]);\n\t\t\t}\n\t\t}\n\t\tsort(ad[i].begin(),ad[i].end());\n\t}\n\tint ans=200000000;\n\ti=max(0,r-ad[1].size()+1);\n\twhile(1){\n\t\tif(i>=ad[0].size()||r-i>=ad[1].size())break;\n\t\tans=min(ans,ad[0][i]+ad[1][r-i]);\n\t\ti++;\n\t}\n\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n#define F first\n#define S second\n#define INF 2e9\n#define MP(i, j) make_pair((i), (j))\ntypedef pair<int, int> P;\nint level[500][500];\n\nint r, w, h, x, y;\nvector<P> able, able2;\nstruct S{\n\tint x, y, r;\n\tS(int inx, int iny, int inr): x(inx), y(iny), r(inr){}\n\tbool operator < (const S &s)const{\n\t\treturn r > s.r;\n\t}\n};\nvoid dijkstra(vector<P> &able){\n\tint nowr = 1, cnt = 0;\n\tbool flag[500][500] = {};\n\tpriority_queue<S> que;\n\tque.push(S(x - 1, y - 1, 1));\n\tflag[y - 1][x - 1] =  true;\n\twhile(!que.empty()){\n\t\tS p = que.top();\n\t\tif(nowr < level[p.y][p.x]){\n\t\t\table.push_back(MP(cnt, nowr));\n\t\t\tnowr = level[p.y][p.x];\n\t\t}\n\t\tcnt++;\n\t\t\n\t\tque.pop();\n\t\tfor(int i = -1; i <= 1; i++){\n\t\t\tif(!flag[p.y + i][p.x]&& p.y + i >= 0 && p.y + i < h && p.x >= 0 && p.x < w){\n\t\t\t\tque.push(S(p.x, p.y + i, level[p.y + i][p.x]));\n\t\t\t\tflag[p.y + i][p.x] = true;\n\t\t\t}\n\t\t\tif(!flag[p.y][p.x + i]&& p.y >= 0 && p.y < h && p.x + i >= 0 && p.x + i < w){\n\t\t\t\tque.push(S(p.x + i, p.y, level[p.y][p.x + i]));\n\t\t\t\tflag[p.y][p.x + i] = true;\n\t\t\t}\n\t\t}\n\t}\n\table.push_back(MP(cnt, nowr));\n}\nint main(){\n\twhile(scanf(\"%d\", &r) && r){\n\t\tscanf(\"%d%d%d%d\", &w, &h, &x, &y);\n\t\tint ans = INF;\n\t\table.clear();\n\t\table2.clear();\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tscanf(\"%d\", &level[i][j]);\n\t\t\t}\n\t\t}\n\t\tdijkstra(able);\n\t\tcin >> w >> h >> x >> y;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tscanf(\"%d\", &level[i][j]);\n\t\t\t}\n\t\t}\n\t\tdijkstra(able2);\n\n\t\tfor(int i = 0; i < able.size(); i++){\n\t\t\tP pp = MP(r - able[i].F, 0);\n\t\t\tif(pp.F > 0){\n\t\t\t\tint p = lower_bound(able2.begin(),able2.end(), pp) - able2.begin();\n\t\t\t\tif(p != able2.end() - able2.begin())\n\t\t\t\t\tans = min(ans, able2[p].S + able[i].S);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans = min(ans, able[i].S);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef pair<int,int> P;\nint R;\nint W1,H1,X1,Y1;\nint W2,H2,X2,Y2;\nint L1[501][501];\nint L2[501][501];\nint AA[250010];\nint BB[250010];\nint num11[250010];\nint num22[250010];\nbool field1[501][501];\nbool field2[501][501];\nvector<P>XX1;vector<P>XX2;\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nint solve1(int x,int y,int num){\n\tbool FF=true;\n\tfor(int k=0;k<4;k++){\n\t\tif(x+dx[k]<0)continue;\n\t\tif(x+dx[k]>=W1)continue;\n\t\tif(y+dy[k]<0)continue;\n\t\tif(y+dy[k]>=H1)continue;\n\t\tif(field1[y+dy[k]][x+dx[k]])FF=false;\n\t}\n\tif(FF)return 0;\n\tint res=0;\n\tqueue<P>que;\n\tque.push(P(y,x));\n\twhile(!que.empty()){\n\t\tP p=que.front();que.pop();\n\t\tint pf=p.first;int ps=p.second;\n\t\tif(field1[pf][ps])continue;\n\t\tfield1[pf][ps]=true;res++;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tif(ps+dx[k]<0)continue;\n\t\t\tif(ps+dx[k]>=W1)continue;\n\t\t\tif(pf+dy[k]<0)continue;\n\t\t\tif(pf+dy[k]>=H1)continue;\n\t\t\tif(L1[pf+dy[k]][ps+dx[k]]>num)continue;\n\t\t\tif(!field1[pf+dy[k]][ps+dx[k]])que.push(P(pf+dy[k],ps+dx[k]));\n\t\t}\n\t}\n\treturn res;\n}\nint solve2(int x,int y,int num){\n\tbool FF=true;\n\tfor(int k=0;k<4;k++){\n\t\tif(x+dx[k]<0)continue;\n\t\tif(x+dx[k]>=W2)continue;\n\t\tif(y+dy[k]<0)continue;\n\t\tif(y+dy[k]>=H2)continue;\n\t\tif(field2[y+dy[k]][x+dx[k]])FF=false;\n\t}\n\tif(FF)return 0;\n\tint res=0;\n\tqueue<P>que;\n\tque.push(P(y,x));\n\twhile(!que.empty()){\n\t\tP p=que.front();que.pop();\n\t\tint pf=p.first;int ps=p.second;\n\t\tif(field2[pf][ps])continue;\n\t\tfield2[pf][ps]=true;res++;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tif(ps+dx[k]<0)continue;\n\t\t\tif(ps+dx[k]>=W2)continue;\n\t\t\tif(pf+dy[k]<0)continue;\n\t\t\tif(pf+dy[k]>=H2)continue;\n\t\t\tif(L2[pf+dy[k]][ps+dx[k]]>num)continue;\n\t\t\tif(!field2[pf+dy[k]][ps+dx[k]])que.push(P(pf+dy[k],ps+dx[k]));\n\t\t}\n\t}\n\treturn res;\n}\nint main()\n{\n\twhile(true){\n\t\tXX1.clear();XX2.clear();\n\t\tscanf(\"%d\",&R);\n\t\tif(R==0)break;\n\t\tscanf(\"%d%d%d%d\",&W1,&H1,&X1,&Y1);\n\t\tfor(int i=0;i<H1;i++){\n\t\t\tfor(int j=0;j<W1;j++){\n\t\t\t\tscanf(\"%d\",&L1[i][j]);\n\t\t\t\tXX1.push_back(P(L1[i][j],i*W1+j));\n\t\t\t}\n\t\t}\n\t\tsort(XX1.begin(),XX1.end());\n\t\tfor(int i=0;i<H1;i++){\n\t\t\tfor(int j=0;j<W1;j++){\n\t\t\t\tfield1[i][j]=false;\n\t\t\t}\n\t\t}\n\t\tfield1[Y1-1][X1-1]=true;\n\t\tnum11[1]=1;\n\t\tfor(int i=2;i<=XX1.size();i++){\n\t\t\tnum11[i]=num11[i-1];\n\t\t\tnum11[i]+=solve1(XX1[i-1].second%W1,XX1[i-1].second/W1,XX1[i-1].first);\n\t\t}\n\t\tfor(int i=XX1.size();i>=2;i--){\n\t\t\tif(XX1[i-1].first==XX1[i-2].first){\n\t\t\t\tnum11[i-1]=num11[i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<XX1.size();i++){\n\t\t\t//printf(\"%d:%d\\n\",XX1[i].first,num11[i+1]);\n\t\t}\n\t\tscanf(\"%d%d%d%d\",&W2,&H2,&X2,&Y2);\n\t\tfor(int i=0;i<H2;i++){\n\t\t\tfor(int j=0;j<W2;j++){\n\t\t\t\tscanf(\"%d\",&L2[i][j]);\n\t\t\t\tXX2.push_back(P(L2[i][j],i*W2+j));\n\t\t\t}\n\t\t}\n\t\tsort(XX2.begin(),XX2.end());\n\t\tfor(int i=0;i<H2;i++){\n\t\t\tfor(int j=0;j<W2;j++){\n\t\t\t\tfield2[i][j]=false;\n\t\t\t}\n\t\t}\n\t\tfield2[Y2-1][X2-1]=true;\n\t\tnum22[1]=1;\n\t\tfor(int i=2;i<=XX2.size();i++){\n\t\t\tnum22[i]=num22[i-1];\n\t\t\tnum22[i]+=solve2(XX2[i-1].second%W2,XX2[i-1].second/W2,XX2[i-1].first);\n\t\t}\n\t\tfor(int i=XX2.size();i>=2;i--){\n\t\t\tif(XX2[i-1].first==XX2[i-2].first){\n\t\t\t\tnum22[i-1]=num22[i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<XX2.size();i++){\n\t\t\t//printf(\"%d:%d\\n\",XX2[i].first,num22[i+1]);\n\t\t}\n\t\tint ans=1000000000;\n\t\tfor(int i=0;i<=H1*W1;i++){\n\t\t\tint RRR=R-num11[i];\n\t\t\tint l=0;int r=H2*W2+1;\n\t\t\twhile(r-l>1){\n\t\t\t\tint c=(l+r)/2;\n\t\t\t\tif(num22[c]<RRR)l=c;\n\t\t\t\telse r=c;\n\t\t\t}\n\t\t\tl-=H1;\n\t\t\tif(l<0)l=0;\n\t\t\twhile(l<=H1*W1&&num11[i]+num22[l]<R)l++;\n\t\t\tif(num11[i]+num22[l]<R)continue;\n\t\t\t//printf(\"%d %d\\n\",num11[i],num22[l]);\n\t\t\tint I=i-1;l--;\n\t\t\tif(I==-1)ans=min(ans,XX2[l].first);\n\t\t\telse if(l==-1)ans=min(ans,XX1[I].first);\n\t\t\telse ans=min(ans,XX1[I].first+XX2[l].first);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dr[4][2]={{0, 1},{1, 0},{0, -1},{-1, 0}};\n\nint R;\nint W, H, X, Y;\nint memo[501][501];\n\nvoid get(vector<vi> &d, int x, int y, vi &res){\n\tpriority_queue<pair<int, pii>, vector<pair<int, pii> >, greater<pair<int, pii> > > pq;\n\tmemset(memo, 63, sizeof(memo));\n\tpq.emplace(d[y][x], pii(x, y));\n\tmemo[y][x] = d[y][x];\n\tint p = 0;\n\tres[p++] = 0;\n\twhile(!pq.empty()){\n\t\tint c = pq.top().first;\n\t\tint x = pq.top().second.first;\n\t\tint y = pq.top().second.second;\n\t\tpq.pop();\n\t\tif(memo[y][x] < c) continue;\n\t\tif(res.size() <= p)break;\n\t\tres[p++] = c;\n\t\tREP(i, 4){\n\t\t\tint dx = x+dr[i][0];\n\t\t\tint dy = y+dr[i][1];\n\t\t\tif(dx<0||dy<0||W<=dx||H<=dy) continue;\n\t\t\tint dc = max(c, d[dy][dx]);\n\t\t\tif(chmin(memo[dy][dx], dc)) pq.emplace(dc, pii(dx, dy));\n\t\t}\n\t}\n}\n\nmain(){\n\twhile(cin >> R, R){\n\t\tvector<vi> l(2, vi(R+1, INF));\n\t\tREP(k, 2){\n\t\t\tcin >> W >> H >> X >> Y;\n\t\t\tvector<vi> d(H, vi(W));\n\t\t\tREP(i, H)REP(j, W) cin >> d[i][j];\n\t\t\tget(d, X-1, Y-1, l[k]);\n\t\t}\n\t\t\n\t\tint ans=INF;\n\t\tREP(i, R+1) ans = min(ans, l[0][i] + l[1][R-i]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\n\nvector<int> calc_required_level_to_rooms()\n{\n\tint w, h, sx, sy;\n\tstatic int req[512][512];\n\tcin >> w >> h >> sx >> sy;\n\t--sx, --sy;\n\tfor (int y = 0; y < h; ++y)\n\t\tfor (int x = 0; x < w; ++x)\n\t\t\tcin >> req[y][x];\n\n\tvector<int> res;\n\tres.push_back(0);\n\n\tstatic bool visit[512][512];\n\tCLEAR(visit, 0);\n\n\ttypedef pair<int, pint> P;\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tq.push(P(1, pint(sx, sy)));\n\twhile (!q.empty())\n\t{\n\t\tP tt = q.top(); q.pop();\n\t\tint level = tt.first;\n\t\tint x = tt.second.first, y = tt.second.second;\n\t\tif (visit[y][x])\n\t\t\tcontinue;\n\n\t\tvisit[y][x] = true;\n\t\tres.push_back(level);\n\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\t\tif (valid_pos(tx, ty, w, h) && !visit[ty][tx])\n\t\t\t\tq.push(P(max(level, req[ty][tx]), pint(tx, ty)));\n\t\t}\n\t}\n\n\treturn res;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tint r;\n\tcin >> r;\n\n\tvector<int> a = calc_required_level_to_rooms();\n\tvector<int> b = calc_required_level_to_rooms();\n\n\tif (a.size() < b.size())\n\t\tswap(a, b);\n\n\tint res = 1e9;\n\tfor (int i = min<int>(r, a.size() - 1); i >= 0 && r - i < b.size(); --i)\n\t\tmin_swap(res, a[i] + b[r - i]);\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,n) for(int i=0;i<(int)(n);i++)\n#define FORR(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define pb(a) push_back(a)\n#define mp(x,y) make_pair(x,y)\n#define mp(x,y,z) make_tuple(x,y,z)\n#define ALL(a) a.begin(),a.end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,-1,sizeof(a))\n#define len(a) sizeof(a)\n#define ll long long\n#define pint pair<int,int>\n#define tint tuple<int,int,int>\n#define INF 1<<29\n#define MAX 501\nusing namespace std;\n\nint R,W[2],H[2],X[2],Y[2],L[2][MAX][MAX],d[2][MAX][MAX],dd[4]={0,-1,0,1};\nmap<int,int> m[2];\n\nvoid solve(){\n for(;;){\n  cin>>R;\n  if(!R) return;\n  FOR(i,2){\n   cin>>W[i]>>H[i]>>X[i]>>Y[i];\n   X[i]--;\n   Y[i]--;\n   FOR(j,H[i]) FOR(k,W[i]) cin>>L[i][j][k];\n   FOR(j,H[i]) FOR(k,W[i]) d[i][j][k]=INT_MAX/3;\n   d[i][X[i]][Y[i]]=1;\n   priority_queue<pint,vextor<pint>,greater<pint>> pque;\n   que.push(mp(1,X[i]*W[i]+Y[i]));\n   while(!que.empty()){\n    pint p=pque.top(); pque.pop();\n    int x=p.second/W[i],y=p.second-x*W[i];\n    if(d[i][x][y]<p.first) continue;\n    FOR(j,4){\n     int nx=x+dd[j],ny=y+dd[j^1];\n     if(nx<0||ny<0||nx>=H[i]||ny>=W[i]) continue;\n     if(d[i][nx][ny]>max(d[i][x][y],L[i][x][y])){\n      d[i][nx][ny]=max(d[i][x][y],L[i][x][y]);\n      pque.push(mp(d[i][nx][ny],nx*W[i]+ny));\n     }\n    }\n   }\n   FOR(j,H[i]) FOR(k,W[i]) m[i][d[i][j][k]]++;\n   for(map<int,int>::itelator ite=m[i].begin()+1;ite!=m[i].end();ite++){\n    m[i][ite->first]+=m[i][(ite-1)->first];\n   }\n  }\n  int mi=m[1].lower_bound(R)->first;\n  for(map<int,int>::itelator ite=m[0].begin();ite!=m[0].end();ite++){\n   mi=min(mi,(ite->first)+(m[1].lower_bound(R-(ite->second))->first));\n  }\n  cout<<mi<<endl;\n  FOR(i,2) map[i].clear();\n }\n}\n\nint main(){\n solve();\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pint;\ntypedef pair<ll, int> P;\n//typedef tuple<int,int,int> T;\nll INFL = 1000000000000000010;//10^18 = 2^60\nint INF = 2147483600;//10^9\nll MOD  = 1000000007;\nvector<int> dy = {1,-1,0,0};\nvector<int> dx = {0,0,1,-1};\nvector<ll> Ans(0);\nint solve(){\n    int R;\n    cin >> R;\n    if(R == 0)return 0;\n    int H1,W1,X1,Y1;\n    cin >> W1 >> H1 >> X1 >> Y1;\n    X1--;\n    Y1--;\n    vector<vector<ll>> mp1(H1, vector<ll>(W1));\n    vector<vector<ll>> d1(H1, vector<ll>(W1, INFL));\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            cin >> mp1[i][j];\n        }\n    }\n    \n    d1[Y1][X1] = 1;\n    priority_queue<pair<ll, pair<int, int>>> pque1;\n    pque1.push({1, {Y1, X1}});\n    \n    while(!pque1.empty()){\n        ll c;\n        int y,x;\n        c = pque1.top().first;\n        y = pque1.top().second.first;\n        x = pque1.top().second.second;\n        pque1.pop();\n        if(c > d1[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H1 && 0 <= nx && nx < W1){\n                if(d1[ny][nx] > d1[y][x]){\n                    if(d1[y][x] > mp1[ny][nx]){\n                        d1[ny][nx] = d1[y][x];\n                    }else{\n                        d1[ny][nx] = mp1[ny][nx];\n                    }\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }else if(d1[ny][nx] > d1[y][x]){\n                    d1[ny][nx] = mp1[ny][nx];\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    int H2,W2,X2,Y2;\n    cin >> W2 >> H2 >> X2 >> Y2;\n    X2--;\n    Y2--;\n    vector<vector<ll>> mp2(H2, vector<ll>(W2));\n    vector<vector<ll>> d2(H2, vector<ll>(W2, INFL));\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            cin >> mp2[i][j];\n        }\n    }\n    \n    d2[Y2][X2] = 1;\n    priority_queue<pair<ll, pair<int, int>>> pque2;\n    pque2.push({1, {Y2, X2}});\n    \n    while(!pque2.empty()){\n        ll c;\n        int y,x;\n        c = pque2.top().first;\n        y = pque2.top().second.first;\n        x = pque2.top().second.second;\n        pque2.pop();\n        if(c > d2[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H2 && 0 <= nx && nx < W2){\n                if(d2[ny][nx] > d2[y][x]){\n                    if(d2[y][x] > mp2[ny][nx]){\n                        d2[ny][nx] = d2[y][x];\n                    }else{\n                        d2[ny][nx] = mp2[ny][nx];\n                    }\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }else if(d2[ny][nx] > d2[y][x]){\n                    d2[ny][nx] = mp2[ny][nx];\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    vector<pair<ll,int>> O1(0);\n    vector<ll> COST1(0);\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            COST1.push_back(d1[i][j]);\n        }\n    }\n    sort(COST1.begin(), COST1.end());\n    COST1.push_back(INFL);\n    ll ad1 = COST1.at(0);\n    int cnt = 0;\n    for(int i = 0; i < COST1.size(); i++){\n        if(ad1 == COST1.at(i)){\n            cnt++;\n        }else{\n            O1.push_back({ad1, cnt});\n            ad1 = COST1.at(i);\n            cnt++;\n        }\n    }\n    \n    vector<pair<ll,int>> O2(1);\n    O2.at(0).first = 0;\n    O2.at(0).second = 0;\n    vector<ll> COST2(0);\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            COST2.push_back(d2[i][j]);\n        }\n    }\n    sort(COST2.begin(), COST2.end());\n    COST2.push_back(INFL);\n    ll ad2 = COST2.at(0);\n    cnt = 0;\n    for(int i = 0; i < COST2.size(); i++){\n        if(ad2 == COST2.at(i)){\n            cnt++;\n        }else{\n            O2.push_back({ad2, cnt});\n            ad2 = COST2.at(i);\n            cnt++;\n        }\n    }\n    \n    \n    ll ans = INFL;\n    int right = -1;\n    for(int i = 0; i < O1.size(); i++){\n        ll cost = O1.at(i).first;\n        int rest = R - O1.at(i).second;\n        \n        if(rest > O2.at(O2.size()-1).second) continue;\n        int left = -1;\n        if(right == -1){\n            right = O2.size();\n        }\n        int mid;\n        while(right - left > 1){\n            mid = (left + right) / 2;\n            if(O2.at(mid).second >= rest){\n                right = mid;\n            }else{\n                left = mid;\n            }\n        }\n        cost += O2.at(right).first;\n        ans = min(ans, cost);\n    }\n    \n    Ans.push_back(ans);\n    solve();\n    return 0;\n}\n\nint main(void){\n    solve();\n    for(int i = 0; i < Ans.size(); i++){\n        cout << Ans.at(i) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\n\nconst int INF=1000000000;\nconst long long int INF_=1000000000000000000;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nbool IsIn(int y,int x,int h,int w){\n\treturn 0<=y&&y<h&&0<=x&&x<w;\n}\n\nvoid BFS(vector<vector<int> > &f,vector<vector<int> > &l,int sy,int sx,int h,int w){\n\tvector<vector<int> > done(h,vector<int>(w));\n\tl[sy][sx]=1;\n\tdone[sy][sx]=1;\n\tqueue<Pi> que;\n\tREP(i,0,4){\n\t\tint ny=sy+dy[i],nx=sx+dx[i];\n\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\tque.push(Pi(ny,nx));\n\t}\n\twhile(!que.empty()){\n\t\tPi p=que.front();\n\t\tque.pop();\n\t\tdone[p.F_][p.S_]=1;\n\t\tbool flag=true;\n\t\tint tmp=INF;\n\t\tREP(i,0,4){\n\t\t\tint ny=p.F_+dy[i],nx=p.S_+dx[i];\n\t\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\t\tif(done[ny][nx]==1) tmp=min(tmp,l[ny][nx]);\n\t\t\t//if(p.S_==2&&p.F_==1) cout << l[ny][nx] << endl;\n\t\t\tif(done[ny][nx]==1&&l[ny][nx]>=f[p.F_][p.S_]) flag=false;\n\t\t\tif(done[ny][nx]!=1) que.push(Pi(ny,nx));\n\t\t}\n\t\t//if(p.S_==2&&p.F_==1) cout << tmp << endl << endl;\n\t\tif(flag) l[p.F_][p.S_]=f[p.F_][p.S_];\n\t\telse {\n\t\t\tif(tmp!=INF) l[p.F_][p.S_]=max(tmp,f[p.F_][p.S_]);\n\t\t\telse l[p.F_][p.S_]=f[p.F_][p.S_];\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tint R;\n\twhile(cin >> R&&R){\n\t\tint W[2],H[2],X[2],Y[2];\n\t\tvector<vector<int> > field[2];\n\t\tvector<vector<int> > level[2];\n\t\tint _max=0;\n\t\tREP(i,0,2){\n\t\t\tcin >> W[i] >> H[i] >> X[i] >> Y[i];\n\t\t\t--X[i]; --Y[i];\n\t\t\tfield[i].resize(H[i]);\n\t\t\tlevel[i].resize(H[i]);\n\t\t\tREP(j,0,H[i]){\n\t\t\t\tfield[i][j].resize(W[i]);\n\t\t\t\tlevel[i][j].resize(W[i]);\n\t\t\t}\n\t\t\tREP(y,0,H[i]) REP(x,0,W[i]){\n\t\t\t\tcin >> field[i][y][x];\n\t\t\t\t_max=max(_max,field[i][y][x]);\n\t\t\t}\n\t\t\tBFS(field[i],level[i],Y[i],X[i],H[i],W[i]);\n\n\t\t\t/*\n\t\t\tcout << endl << endl;\n\t\t\tREP(y,0,H[i]){\n\t\t\t\tREP(x,0,W[i]) cout << level[i][y][x] << ' ';\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\tvector<int> count[2],s[2];\n\t\tREP(i,0,2){\n\t\t\tcount[i].resize(_max+1);\n\t\t\ts[i].resize(_max+1);\n\t\t}\n\t\tREP(i,0,2) REP(y,0,H[i]) REP(x,0,W[i]) ++count[i][level[i][y][x]];\n\t\tREP(i,0,2) REP(j,1,_max+1) s[i][j]=s[i][j-1]+count[i][j];\n\t\tint result=INF;\n\t\tfor(int i=0; i<=_max&&i<=result; ++i){\n\t\t\t//cout << i << ' ' << s[0][i] << ' ' <<  (int)(lower_bound(s[1].begin(),s[1].end(),R-s[0][i])-s[1].begin()) << ' ' << s[1][(int)(lower_bound(s[1].begin(),s[1].end(),R-s[0][i])-s[1].begin())] << endl;\n\t\t\tint idx=(int)(lower_bound(s[1].begin(),s[1].end(),R-s[0][i])-s[1].begin());\n\t\t\tif(!(0<=idx&&idx<=_max)) continue;\n\t\t\tresult=min(result,i+idx);\n\t\t}\n\t\tcout << result << endl;\n\t}\n}\n\nint main(){\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define reps(i,j,k) for(int i=j;i<=k;i++)\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\n\tint w,h,r,d[500][500],ex,ey,ans;\n\tint m[500][500];\nint main(){\n\tfor(;;){\n\t\tscanf(\"%d\",&r);\n\t\tif(r==0)break;\n\t\tvector<pii> cost[2];\n\t\trep(k,2){\n\t\t\tvector<int> c;\n\t\t\tscanf(\"%d%d%d%d\",&w,&h,&ex,&ey);\n\t\t\trep(i,h)rep(j,w){\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\",&t);\n\t\t\t\td[j][i] = t;\n\t\t\t\tc.push_back(t);\n\t\t\t}\n\t\t\tsort(c.begin(),c.end());\n\t\t\tc.erase(unique(c.begin(),c.end()),c.end());\n\t\t\trep(i,w)rep(j,h)m[i][j]=-1;\n\t\t\tint s=c.size(),cnt=1;\n\t\t\tconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\t\t\tm[--ex][--ey]=3;\n\t\t\tqueue<pii> q;\n\t\t\tcost[k].push_back(pii(0,0));\n\t\t\trep(l,s){\n\t\t\t\trep(i,w)rep(j,h){\n\t\t\t\t\tif(m[i][j]>0){\n\t\t\t\t\t\tq.push(pii(i,j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile(!q.empty()){\n\t\t\t\t\tint x=q.front().first,y=q.front().second;\n\t\t\t\t\tq.pop();\n\t\t\t\t\trep(i,4){\n\t\t\t\t\t\tif(x+dx[i]>=0 && x+dx[i]<w && y+dy[i]>=0 && y+dy[i]<h){\n\t\t\t\t\t\t\tif(d[ x+dx[i] ][ y+dy[i] ]<=c[l] && m[x+dx[i]][y+dy[i]]==-1){\n\t\t\t\t\t\t\t\tm[x][y]--;\n\t\t\t\t\t\t\t\tm[ x+dx[i] ][ y+dy[i] ]=3;\n\t\t\t\t\t\t\t\tq.push(pii(x+dx[i],y+dy[i]));\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else if(m[x][y]!=0)m[x][y]--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcost[k].push_back(pii(cnt,c[l]));\n\t\t\t}\n\t\t}\n\t\tans=2000;\n\t\tint s0=cost[0].size(),s1=cost[1].size();\n\t\trep(i,s0)rep(j,s1){\n\t\t\tif(cost[0][i].first+cost[1][j].first>=r)ans=min(ans,cost[0][i].second+cost[1][j].second);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n#include <algorithm>\n#include <limits.h>\nusing namespace std;\n\nstruct room \n{\n\tint level, x, y;\n\troom(int level, int x, int y)\n\t{ this->level = level, this->x = x, this->y = y; }\n\tbool operator < (room rhs) const\n\t{ return this->level > rhs.level; }\n};\n\nint map[2][500][500];\nbool visit[2][500][500];\nint result[2][100001];\n\nint main()\n{\n\tint r, w[2], h[2], sx[2], sy[2], tmp, sec, open, ans;\n\n\twhile(true) {\n\t\tscanf(\"%d\", &r);\n\t\tif(r == 0) break;\n\t\tfor(int i = 0; i < 2; ++i) {\n\t\t\tscanf(\"%d%d%d%d\", &w[i], &h[i], &sx[i], &sy[i]);\n\t\t\t--sx[i], --sy[i];\n\t\t\tfor(int y = 0; y < h[i]; ++y) {\n\t\t\t\tfor(int x = 0; x < w[i]; ++x) {\n\t\t\t\t\tscanf(\"%d\", &tmp);\n\t\t\t\t\tmap[i][x][y] = tmp;\n\t\t\t\t\tvisit[i][x][y] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 1; j <= r; ++j) result[i][j] = -1;\n\t\t\tresult[i][0] = 0;\n\t\t}\n\n\t\tpriority_queue<room> next;\n\t\tqueue<room> seek;\n\n\t\tfor(int i = 0; i < 2; ++i) {\n\t\t\topen = 0;\n\t\t\tsec = 0;\n\t\t\tnext.push(room(1, sx[i], sy[i]));\n\n\t\t\twhile(!next.empty() && open < r) {\n\t\t\t\tsec = next.top().level;\n\t\t\t\twhile(!next.empty()) {\n\t\t\t\t\troom m = next.top();\n\t\t\t\t\tif(m.level > sec) break;\n\t\t\t\t\tvisit[i][m.x][m.y] = true;\n\t\t\t\t\tseek.push(m);\n\t\t\t\t\tnext.pop();\n\t\t\t\t}\n\n\t\t\t\twhile(!seek.empty()) {\n\t\t\t\t\troom at = seek.front();\n\t\t\t\t\tseek.pop();\n\t\t\t\t\tresult[i][++open] = sec;\n\t\t\t\t\tfor(int rx = at.x - 1; rx < at.x + 2; ++rx) {\n\t\t\t\t\t\tfor(int ry = at.y - 1; ry < at.y + 2; ++ry) {\n\t\t\t\t\t\t\tif(abs(rx - at.x) + abs(ry - at.y) != 1) continue;\n\t\t\t\t\t\t\tif(rx < 0 || rx >= w[i] || ry < 0 || ry >= h[i]) continue;\n\t\t\t\t\t\t\tif(visit[i][rx][ry]) continue;\n\t\t\t\t\t\t\tif(map[i][rx][ry] <= sec) {\n\t\t\t\t\t\t\t\tseek.push(room(map[i][rx][ry], rx, ry));\n\t\t\t\t\t\t\t\tvisit[i][rx][ry] = true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnext.push(room(map[i][rx][ry], rx, ry));\n\t\t\t\t\t\t\t\tvisit[i][rx][ry] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 1; j <= open; ++j) {\n\t\t\t\tif(result[i][j] == -1)\n\t\t\t\t\tresult[i][j] = result[i][j - 1];\n\t\t\t\tprintf(\"%d \", result[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n%d: open=%d level=%d\\n\", i, open, sec);\n\t\t}\n\t\t\n\t\tans = INT_MAX;\n\t\tfor(int i = 0; i <= r; ++i) {\n\t\t\tif(result[0][i] == -1 || result[1][r - i] == -1) continue;\n\t\t\tans = min(ans, result[0][i] + result[1][r - i]);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = {-1, 0, 1,  0 };\n\nint w[2], h[2], x[2], y[2];\t// z[ÌAs«, Gx[^ÌÊu(x,y)\n\nint  R[2][500][500];\nbool v[500][500];\n\t\nP bfs (int currk, int floor, P e )\n{\n\n\tqueue<P> que;\n\tque.push (e );\n\tint res = 0;\n\tint mink = 1 << 30;\n\n\tmemset (v, false, sizeof (v ) );\n\n\twhile (!que.empty() ){\n\t\tP curr = que.front(); que.pop();\n\t\tint r = curr.first, c = curr.second;\n\t\tv[r][c] = true;\n\t\tres++;\n\t\trep (k, 4 ){\n\t\t\tint nr = r + dy[k], nc = c + dx[k];\n\t\t\tif (nr < 0 || nr >= h[floor] || nc < 0 || nc >= w[floor] )\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tif (R[floor][nr][nc] > currk ){\n\t\t\t\tmink = min (mink, R[floor][nr][nc] );\n\t\t\t\tcontinue;\n\t\t\t} // end if \n\t\t\tif (v[nr][nc] )\n\t\t\t\tcontinue;\n\t\t\tque.push (P (nr, nc ) );\n\t\t} // end rep\n\t} // end while\n\n\treturn P(res, mink );\n}\n\nint main()\n{\n\tint r;\n\n\twhile (cin >> r && r ){\t// Kêé®Ì (Åá±ÌÌ®ðKêé)\n\t\tmemset (R, 0, sizeof (R ) );\n\t\trep (k, 2 ){\n\t\t\tcin >> w[k] >> h[k] >> x[k] >> y[k];\t\n\t\t\tx[k]--, y[k]--;\n\t\t\trep (i, h[k] ){\n\t\t\t\trep (j, w[k] ){\n\t\t\t\t\tcin >> R[k][i][j];\n\t\t\t\t} // end rep\n\t\t\t} // end rep\n\t\t} // end rep\n\t\n\t\tint res = 0;\n\t\tvector <P> curr (2); // »ÝÌKê½etAÌ®Ì,@etAÌ»ÝÌZLeBx \n\t\trep (i, 2 ){\n\t\t\tcurr[i].first = 0;\n\t\t\tcurr[i].second = R[i][y[i]][x[i]];\n\t\t} // end rep\n\t\tbool found = false;\n\t\twhile (1) {\n\t\t\tvector <P> pre = curr;\n\t\t\trep (i, 2 ){\n\t\t\t\tcurr[i] = bfs (curr[i].second, i, P(y[i], x[i] ) );\n\t\t\t\tif (curr[i].first >= r ){\n\t\t\t\t\tres = pre[i].second;\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t} // end if\n\t\t\t} // end if\n\t\t\tif (found )\n\t\t\t\tbreak;\n\t\t\tif (curr[0].first + curr[1].first >= r ){\n\t\t\t\tres = pre[0].second + pre[1].second;\n\t\t\t\tbreak;\n\t\t\t} // end if\n\t\t} // end while\n\t\tcout << res << endl;\t\n\t} // end loop\n\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reps(i,n) for(int i=1;i<=n;i++)\n\nconst int INF=1010000000;\n\nint R;\nint w[2],h[2],st[2],gl[2];\nint masu[2][501][501];\n\nint need[2][25001];\n\nint visit[501][501];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nint glcont;\n\nvoid saiki(int w,int h,int x,int y,int masu[501][501],int mn){\n\tif(x<0 || y<0 || x>=w || y>=h)return;\n\tif(masu[x][y]>mn)return;\n\tif(visit[x][y]==1)return;\n\tvisit[x][y]=1;\n\t\n\t\n\trep(i,4){\n\t\tsaiki(w,h,x+dx[i],y+dy[i],masu,mn);\n\t}\n\t\n\tglcont++;\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d\",&R);\n\t\tif(R==0)break;\n\t\t\n\t\trep(i,2){\n\t\t\tscanf(\"%d%d%d%d\",&w[i],&h[i],&st[i],&gl[i]);\n\t\t\t\n\t\t\trep(j,h[i]){\n\t\t\t\trep(k,w[i]){\n\t\t\t\t\tscanf(\"%d\",&masu[i][k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint left,right;\n\t\tleft=0;\n\t\tright=1000000001;\n\t\trep(i,2)rep(j,250001)need[i][j]=INF;\n\t\trep(i,2){\n\t\t\trep(n,w[i]*h[i]+1){\n\t\t\t\tint left,right;\n\t\t\t\tleft=0;right=1000000001;\n\t\t\t\t\n\t\t\t\twhile(1){\n\t\t\t\t\tdouble half= double(left+right)/2.0;\n\t\t\t\t\trep(rr,w[i])rep(ee,h[i])visit[rr][ee]=0;\n\t\t\t\t\tglcont=0;\n\t\t\t\t\t\n\t\t\t\t\tsaiki(w[i],h[i],st[i]-1,gl[i]-1,masu[i],int(half));\n\t\t\t\t\t\n\t\t\t\t\tif(glcont<n){\n\t\t\t\t\t\tleft=half+0.5;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tright=half;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(left==right){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tneed[i][n]=left;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint mini=INT_MAX;\n\t\t\n\t\tint dd=0;\n\t\tif(w[0]*h[0] < w[1]+h[1]){\n\t\t\tdd=1;\n\t\t}\n\t\t\n\t\trep(i,250001){\n\t\t\tif(R-i<0)break;\n\t\t\tmini = min(mini, need[dd][i] + need[!dd][R-i]);\n\t\t}\n\t\t/*\n\t\trep(i,2){\n\t\t\tputs(\"\");\n\t\t\trep(n,w[i]*h[i]+1){\n\t\t\t\tprintf(\"%d %d\\n\",n,need[i][n]);\n\t\t\t}\n\t\t}*/\n\t\tprintf(\"%d\\n\",mini);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n#define INF (200000001)\n#define F first\n#define S second\nint W[2],H[2],X[2],Y[2];\nint L[2][501][501];\nint R;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nvector<int> E[2];\nvoid dijk(int id){\n  priority_queue<PP,vector<PP>,greater<PP> > q;\n  int h[501][501];\n  memset(h,-1,sizeof(h));\n  q.push( PP( 1, P(X[id], Y[id]) ) );\n  h[X[id]][Y[id]]=1;\n  while( !q.empty() ){\n    PP p = q.top(); q.pop();\n    int x=p.S.F, y=p.S.S;\n    for(int i=0;i<4;i++){\n      int nx = x+dx[i];\n      int ny = y+dy[i];\n      if( nx < 0 || nx >= W[id] || ny < 0 || ny >= H[id] ) continue;\n      if( h[nx][ny] == -1 ){\n\tint c = max(L[id][nx][ny],p.F);\n\tq.push(PP(c,P(nx,ny)));\n\th[nx][ny]=c;\n      }\n    }\n  }\n  E[id].clear();\n  for(int y=0;y<H[id];y++){\n    for(int x=0;x<W[id];x++){\n      //      printf(\"%d \",h[x][y]);\n      E[id].push_back( h[x][y] );\n    }\n    //    puts(\"\");\n  }\n  sort(E[id].begin(),E[id].end());\n}\nint search(int id){\n  int res = INF;\n  int id2 = (id+1)%2;\n  for(int i=0;i<(int)E[id].size();i++){\n    int r = R-i-2;\n    if( i+1 >= R ){\n      res = min(res,E[id][i]);\n      break;\n    }\n    if( r >= E[id2].size() ) continue;\n    res = min(res,E[id][i]+E[id2][r]);\n  }\n  return res;\n}\nint main(){\n  while(1){\n    scanf(\"%d\",&R);\n    if(!R) break;\n    for(int i=0;i<2;i++){\n      scanf(\"%d %d %d %d\",&W[i],&H[i],&X[i],&Y[i]);\n      X[i]--; Y[i]--;\n      for(int y=0;y<H[i];y++)\n\tfor(int x=0;x<W[i];x++)\n\t  scanf(\"%d\",&L[i][x][y]);\n      dijk(i);\n    }\n    printf(\"%d\\n\",min(search(0),search(1)));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint R;\nint W[2],H[2],ex[2],ey[2];\nint WS[2][500][500];\nint NL[2][250001];\nint AD[2][500][500];\n\nvoid CANGO(int place,int NLINDEX,int x,int y,int* entered){\n\tif(WS[place][y][x] > NL[place][NLINDEX]){\n\t\treturn;\n\t}\n\tif(x >= W[place] || y >= H[place] || x < 0 || y < 0){\n\t\treturn;\n\t}\n\tif(AD[place][y][x] == 1){\n\t\treturn;\n\t}\n\telse{\n\t\tAD[place][y][x] = 1;\n\t\t(*entered)++;\n\t\tCANGO(place,NLINDEX,x+1,y,entered);\n\t\tCANGO(place,NLINDEX,x-1,y,entered);\n\t\tCANGO(place,NLINDEX,x,y+1,entered);\n\t\tCANGO(place,NLINDEX,x,y-1,entered);\n\t}\n\treturn;\n}\nvoid IniAD(int place){\n\tfor(int i = 0;i < H[place];i++){\n\t\tfor(int j = 0;j < W[place];j++){\n\t\t\tAD[place][i][j] = 0;\n\t\t}\n\t}\n}\nint main(){\n\tint i,j,k;\n\tint ncor[2] = {0};\n\tcin >> R;\n\tfor(i = 0;i < 2;i++){\n\t\tcin >> W[i] >> H[i] >> ex[i] >> ey[i];\n\t\tex[i]--;\n\t\tey[i]--;\n\t\tfor(j = 0;j < H[i];j++){\n\t\t\tfor(k = 0;k < W[i];k++){\n\t\t\t\tcin >> WS[i][j][k];\n\t\t\t\tNL[i][ncor[i]] = WS[i][j][k];\n\t\t\t\tncor[i]++;\n\t\t\t}\n\t\t}\n\t\tsort(NL[i],NL[i]+ncor[i]+1);\n\t}\n\t//探索(1つは2分木)\n\tint in1,in2;\n\tint start,last,medi,evergo;\n\tint min = 200000001;\n\tfor(i = 0;i < ncor[0]+1;i++){\n\t\tin1 = 0;\n\t\tCANGO(0,i,ex[0],ey[0],&in1);\n\t\tIniAD(0);\n\t\tevergo = 0;\n\t\tstart = 0;\n\t\tlast = ncor[1];\n\t\twhile(NL[1][start] < NL[1][last]){\n\t\t\tmedi = (start+last)/2;\n\t\t\tin2 = 0;\n\t\t\tIniAD(1);\n\t\t\tCANGO(1,medi,ex[1],ey[1],&in2);\n\t\t\tif(in1+in2 >= R){\n\t\t\t\tlast = medi;\n\t\t\t\tevergo = 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstart = medi+1;\n\t\t\t}\n\t\t}\n\t\tif(NL[0][i]+NL[1][start] < min && evergo == 1){\n\t\t\tmin = NL[0][i]+NL[1][start];\n\t\t}\n\t}\n\tcout << min << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <queue>\n\nusing namespace std;\n\nconst int N = 500;\nconst int INF = 1000000000;\n\nclass S{\npublic:\n  int x, y, cost;\n  S(){}\n  S(int x, int y, int cost) : x(x), y(y), cost(cost) {}\n  bool operator < (const S& s) const {\n    return cost > s.cost;\n  }\n};\n\nint R, w[2], h[2], sx[2], sy[2], input[2][N][N], vis[N][N];\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nvector<int> vec[2];\nset<int> data;\nint cnt;\n\nvoid bfs(int d){\n  int x = sx[d];\n  int y = sy[d];\n  int cost = 1;\n  priority_queue<S> q;\n  S u;\n  q.push(S(x, y, cost));\n  vis[y][x] = cost;\n  while(!q.empty()){\n    u = q.top(); q.pop();\n    if(vis[u.y][u.x] < u.cost) continue;\n    for(int i=0;i<4;i++){\n      int ny = u.y + dy[i];\n      int nx = u.x + dx[i];\n      if(ny < 0 || ny >= h[d]) continue;\n      if(nx < 0 || nx >= w[d]) continue;\n      if(vis[ny][nx] > max(u.cost, input[d][ny][nx])){\n        vis[ny][nx] = max(u.cost, input[d][ny][nx]);\n        q.push(S(nx, ny, max(u.cost, input[d][ny][nx])));\n      }\n    }\n  }\n}\n\nvoid init(){\n  data.clear();\n  for(int k=0;k<2;k++){\n    for(int i=0;i<h[k];i++){\n      for(int j=0;j<w[k];j++){\n        data.insert(input[k][i][j]);\n      }\n    }\n  }\n  for(int k=0;k<2;k++){\n    fill(vis[0], vis[N], INF);\n    bfs(k);\n    vec[k].clear();\n    for(int i=0;i<h[k];i++){\n      for(int j=0;j<w[k];j++){\n        vec[k].push_back(vis[i][j]);\n      }\n    }\n    sort(vec[k].begin(), vec[k].end());\n  }\n}\n\n/*void dfs(int x, int y, int cost, int d){\n  vis[y][x] = true;\n  cnt++;\n  for(int i=0;i<4;i++){\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if(ny < 0 || ny >= h[d]) continue;\n    if(nx < 0 || nx >= w[d]) continue;\n    if(input[d][ny][nx] > cost) continue;\n    if(!vis[ny][nx]) dfs(nx, ny, cost, d);\n  }\n  }*/\n\nbool check(int a, int b){\n  int t1 = distance(vec[0].begin(), upper_bound(vec[0].begin(), vec[0].end(), a));\n  int t2 = distance(vec[1].begin(), upper_bound(vec[1].begin(), vec[1].end(), b));\n  return t1 + t2 >= R;\n  /*int sum = 0;\n  for(int i=0;i<2;i++){\n    fill(vis[0], vis[N], false);\n    cnt = 0;\n    int cost = a;\n    if(i == 1) cost = b;\n    if(cost > 0) dfs(sx[i], sy[i], cost, i);\n    sum += cnt;\n  }\n  return sum >= R;*/\n}\n\nint solve(){\n  set<int>::iterator ite = data.end();\n  int l = 0, r = *(--ite) + 1;\n  while(l<r){\n    int m = (l + r) / 2;\n    bool f = false;\n    for(ite=data.begin();ite!=data.end();ite++){\n      if(*ite > m) break;\n      if(check(*ite, m-(*ite))) f = true;\n    }\n    if(f) r = m;\n    else l = m + 1;\n  }\n  return l;\n}\n\nmain(){\n  while(cin >> R && R){\n    for(int k=0;k<2;k++){\n      cin >> w[k] >> h[k] >> sx[k] >> sy[k];\n      sx[k]--; sy[k]--;\n      for(int i=0;i<h[k];i++){\n        for(int j=0;j<w[k];j++){\n          cin >> input[k][i][j];\n        }\n      }\n    }\n    init();\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\n\nstatic const double eps = 1e-8;\n\nconst int tx[4] = {+0,+1,+0,-1};\nconst int ty[4] = {-1,+0,+1,+0};\n\nbool visited[501][501];\nint rooms[2][501][501];\n\nint dfs(int sx,int sy,int W,int H,int auth_level,int office_i){\n  if(visited[sy][sx]) return 0;\n  if(auth_level < rooms[office_i][sy][sx]) return 0;\n\n  visited[sy][sx] = true;\n  int res = 1;\n  for(int i = 0; i < 4; i++){\n    int dx = sx + tx[i];\n    int dy = sy + ty[i];\n    if(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n    if(auth_level < rooms[office_i][dy][dx]) continue;\n    res += dfs(dx,dy,W,H,auth_level,office_i);\n  }\n  return res;\n}\n\nint main(){\n  int have_to_visit_rooms;\n  while(~scanf(\"%d\",&have_to_visit_rooms)){\n    int elevator_x[2];\n    int elevator_y[2];\n    int W[2];\n    int H[2];\n    vector<int> auth_candidates;\n    for(int office_i = 0; office_i < 2; office_i++){\n      scanf(\"%d %d %d %d\",&W[office_i],&H[office_i],\n            &elevator_x[office_i],&elevator_y[office_i]);\n      elevator_x[office_i]--;\n      elevator_y[office_i]--;\n\n      for(int y = 0; y < H[office_i]; y++){\n        for(int x = 0; x < W[office_i]; x++){\n          scanf(\"%d\",&rooms[office_i][y][x]);\n          if(office_i == 1){\n            auth_candidates.push_back(rooms[office_i][y][x]);\n          }\n        }\n      }\n    }\n\n    int res = 1000000000;\n    int lhs = 0; \n    int rhs = 1000000000;\n    for(int auth_i = 0; auth_i < auth_candidates.size(); auth_i++){\n      int first_auth = auth_candidates[auth_i];\n      for(int round = 0; round < 50; round++){\n        int mid = lhs + (rhs - lhs) / 2;\n        int sum = 0;\n        for(int office_i = 0; office_i < 2; office_i++){\n          memset(visited,false,sizeof(visited));\n          if(office_i == 0){\n            sum += dfs(elevator_x[office_i],\n                       elevator_y[office_i],\n                       W[office_i],H[office_i],mid,office_i);\n          }\n          else{\n            sum += dfs(elevator_x[office_i],\n                       elevator_y[office_i],\n                       W[office_i],H[office_i],first_auth,office_i);\n          }\n        }\n        \n        if(sum < have_to_visit_rooms){\n          lhs = mid;\n        }\n        else{\n          rhs = mid;\n          res = min(rhs + first_auth,res);          \n        }\n      }\n    }\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst LL INF = 1001001001001001;\n\nint r, x[2], y[2];\nLL grid[2][502][502];\nbool done[2][502][502];\nLL memo[2][500001];\n\nstruct P\n{\n\tint g, x, y;\n\t\n\tbool operator < (const P& t) const {\n\t\treturn grid[g][x][y] > grid[g][t.x][t.y];\n\t}\n};\n\nvoid search(int g)\n{\n\tfor (int i = 0; i < 502; i++){\n\t\tfor (int j = 0; j < 502; j++){\n\t\t\tdone[g][i][j] = false;\n\t\t}\n\t}\n\tfor (int i = 0; i <= 5000; i++){\n\t\tmemo[g][i] = INF;\n\t}\n\tmemo[g][0] = 0;\n\t\n\tint num = 0;\n\tLL level = 0;\n\tLL mini = INF;\n\tpriority_queue<P> que;\n\tque.push({g, x[g], y[g]});\n\twhile (!que.empty()){\n\t\tP p = que.top(); que.pop();\n\t\tif (done[g][p.x][p.y]) continue;\n\t\tdone[g][p.x][p.y] = true;\n\t\t\n\t\t//printf(\"%d %d %d\\n\", g, p.x, p.y);\n\t\t\n\t\tif (grid[g][p.x][p.y] <= level){\n\t\t\tnum++;\n\t\t\tmemo[g][num] = level;\n\t\t}\n\t\telse {\n\t\t\t//if (grid[g][p.x][p.y] == INF) break;\n\t\t\tlevel = grid[g][p.x][p.y];\n\t\t\tnum++;\n\t\t\tmemo[g][num] = level;\n\t\t}\n\t\t\n\t\tif (num >= r) return;\n\t\t\n\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\tint tx = p.x + dx[dir];\n\t\t\tint ty = p.y + dy[dir];\n\t\t\tif (!done[g][tx][ty] && done[g][tx][ty] != INF){\n\t\t\t\tque.push({g, tx, ty});\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (scanf(\"%d\", &r), r){\n\t\tfor (int i = 0; i < 2; i++){\n\t\t\tfor (int j = 0; j < 502; j++){\n\t\t\t\tfor (int k = 0; k < 502; k++){\n\t\t\t\t\tgrid[i][j][k] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint h, w;\n\t\t\tscanf(\"%d %d %d %d\", &w, &h, &y[i], &x[i]);\n\t\t\tfor (int j = 1; j <= h; j++){\n\t\t\t\tfor (int k = 1; k <= w; k++){\n\t\t\t\t\tscanf(\"%lld\", &grid[i][j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < 2; i++){\n\t\t\tsearch(i);\n\t\t}\n\t\t\n\t\tLL mini = INF;\n\t\tfor (int i = 0; i <= r; i++){\n\t\t\tmini = min(mini, memo[0][i] + memo[1][r - i]);\n\t\t}\n\t\tprintf(\"%lld\\n\", mini);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nconst int dxy[5]={0,-1,0,1,0};\nint main(){\n    int r;\n    while(scanf(\"%d\",&r),r){\n        vector<pair<int,int> >ans[2];\n        for(int k=0;k<2;k++){\n            int w,h,sx,sy;\n            int fld[500][500];\n            vector<int>vec(1,0);\n            scanf(\"%d%d%d%d\",&w,&h,&sx,&sy);\n            sx--;sy--;\n            for(int i=0;i<h;i++){\n                for(int j=0;j<w;j++){\n                    int v;\n                    scanf(\"%d\",&v);\n                    fld[i][j]=v;\n                    vec.push_back(v);\n                }\n            }\n            sort(vec.begin(),vec.end());\n            vec.erase(unique(vec.begin(),vec.end()),vec.end());\n            bool used[500][500];\n            fill_n(*used,500*500,false);\n            queue<pair<int,int> >que[2];\n            que[0].push(pair<int,int>(sy,sx));\n            for(int i=0;i<vec.size();i++){\n                    int cnt=0;\n                    while(que[i&1].size()){\n                        int y=que[i&1].front().first,x=que[i&1].front().second;\n                        que[i&1].pop();\n                        if(y<0||y>=h||x<0||x>=w)continue;\n                        if(used[y][x])continue;\n                        if(fld[y][x]>vec[i]){\n                            que[(i+1)&1].push(pair<int,int>(y,x));\n                            continue;\n                        }\n                        cnt++;\n                        used[y][x]=true;\n                        for(int l=0;l<4;l++){\n                            int ty=y+dxy[l+1],tx=x+dxy[l];\n                            que[i&1].push(pair<int,int>(ty,tx));\n                        }\n                    }\n                    ans[k].push_back(pair<int,int>(cnt,vec[i]));\n                    ans[k][i].first+=(i?ans[k][i-1].first:0);\n            }\n\n        }\n\n        int Min=1e9;\n        for(int i=0;i<ans[0].size();i++){\n            int to=r-ans[0][i].first;\n            int lb=0,ub=ans[1].size();\n            while(ub-lb>1){\n                int mid=(ub+lb)/2;\n                if(ans[1][mid].first>to)ub=mid;\n                else lb=mid;\n            }\n            int value=ans[0][i].first+ans[1][ub-1].first;\n            if(value>=r){\n                Min=min(Min,ans[0][i].second+ans[1][ub-1].second);\n                //printf(\"%d:%d->%d\\n\",ans[0][i].second,ans[1][ub-1].second,value);\n            }\n        }\n        printf(\"%d\\n\",Min);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long R, W, H, X, Y, i, j, L[500][500], O, T, a, b;\nlong long m[5] = {1, 0, -1, 0, 1};\nbool u[500][500], v[500][500];\nvector<long long> d1, d2;\ntuple<long long, long long, long long> t;\npriority_queue<tuple<long long, long long, long long>, vector<tuple<long long, long long, long long> >, greater<tuple<long long, long long, long long> > > q;\n\nint main(){\n  for(;scanf(\"%lld\", &R), R != 0;){\n  d1.clear();\n  d2.clear();\n  scanf(\"%lld%lld%lld%lld\", &W, &H, &X, &Y);\n  for(i = 0; i < H; ++i){\n    for(j = 0; j < W; ++j){\n      scanf(\"%lld\", L[j] + i);\n      u[j][i] = false;\n      v[j][i] = false;\n    }\n  }\n  d1.push_back(0);\n  d2.push_back(0);\n  q.push(make_tuple(1, X - 1, Y - 1));\n  u[X - 1][Y - 1] = true;\n  while(!q.empty()){\n    t = q.top();\n    q.pop();\n    tie(O, a, b) = t;\n    d1.push_back(O);\n    //cout << O << endl;\n    for(i = 0; i < 4; ++i){\n      if(0 <= a + m[i] && a + m[i] < W && 0 <= b + m[i + 1] && b + m[i + 1] < H && !u[a + m[i]][b + m[i + 1]]){\n        //cout << L[a + m[i]][b + m[i + 1]] << \" \" << a + m[i] << \" \" << b + m[i + 1] << endl;\n\tu[a + m[i]][b + m[i + 1]] = true;\n\tq.push(make_tuple(max(O, L[a + m[i]][b + m[i + 1]]), a + m[i], b + m[i + 1]));\n      }\n    }\n  }\n  O = W * H + 1;\n  scanf(\"%lld%lld%lld%lld\", &W, &H, &X, &Y);\n  for(i = 0; i < H; ++i){\n    for(j = 0; j < W; ++j){\n      scanf(\"%lld\", L[j] + i);\n    }\n  }\n  q.push(make_tuple(1, X - 1, Y - 1));\n  v[X - 1][Y - 1] = true;\n  while(!q.empty()){\n    t = q.top();\n    q.pop();\n    tie(T, a, b) = t;\n    d2.push_back(T);\n    for(i = 0; i < 4; ++i){\n      if(0 <= a + m[i] && a + m[i] < W && 0 <= b + m[i + 1] && b + m[i + 1] < H && !v[a + m[i]][b + m[i + 1]]){\n\t//cout << a + m[i] << \" \" << b + m[i + 1] << endl;\n\tv[a + m[i]][b + m[i + 1]] = true;\n\tq.push(make_tuple(max(T, L[a + m[i]][b + m[i + 1]]), a + m[i], b + m[i + 1]));\n      }\n    }\n  }\n  T = W * H + 1;\n  a = 1099511627775LL;\n  /*for(i = 0, j = O; i < j; ++i){\n    cout << d1[i] << \" \";\n  }\n  cout << endl;\n  for(i = 0, j = T; i < j; ++i){\n    cout << d2[i] << \" \";\n  }\n  cout << endl;// */\n  for(i = max(0LL, R - T + 1), j = min(R, O - 1) + 1; i < j; ++i){\n    //cout << i << \" \" << R - i << endl;\n    a = min(a, d1[i] + d2[R - i]);\n  }\n  cout << a << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    12/15はkyuridenamida啓発デー\n*/\n\n#include <cstdio>\n#include <utility>\n#include <queue>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\nint r;\nint w[2], h[2], x[2], y[2];\nint l[2][500][500];\nchar has_reached[2][500][500];\nvector<pair<int,int> > variation[2];\n\nvoid input(int k) {\n    int i;\n\n    scanf(\"%d %d %d %d\", w+k, h+k, x+k, y+k);\n    x[k]--;\n    y[k]--;\n\n    variation[k].clear();\n\n    for (i=0;i<h[k];i++) {\n\tint j;\n        for (j=0;j<w[k];j++) {\n\t    has_reached[k][i][j] = 0;\n\t    scanf(\"%d\", &l[k][i][j]);\n\t}\n    }\n}\n\nvoid bfs(int k) {\n    int i;\n    int dx[] = {0,  0, 1, -1};\n    int dy[] = {1, -1, 0,  0};\n    int count = 0;\n    int now_level = 0;\n    priority_queue<pair<int, pair<int, int> >,  vector<pair<int, pair<int,int > > >, greater<pair<int, pair<int, int> > > > q;\n\n    q.push(make_pair(l[k][y[k]][x[k]], make_pair(x[k], y[k])));\n\n    while (!q.empty()) {\n         pair<int, pair<int, int> > tmp = q.top();\n\t q.pop();\n\t int need_level = tmp.first;\n         int x = tmp.second.first;\n\t int y = tmp.second.second;\n\n\t if (count > r) break;\n         if (has_reached[k][y][x]) continue;\n\t has_reached[k][y][x] = 1;\n\n\t if (now_level < need_level) {\n\t     variation[k].push_back(make_pair(count, now_level));\n\t     now_level = need_level;\n\t }\n\n\t count++;\n\n\t for (i=0;i<4;i++) {\n\t     int new_x = x + dx[i];\n\t     int new_y = y + dy[i];\n\n\n\t     if ( !(new_x < 0 || new_x >= w[k] || new_y < 0 || new_y >= h[k]) ) {\n                 if (!has_reached[k][new_y][new_x]) q.push(make_pair(l[k][new_y][new_x], make_pair(new_x, new_y)));\n\t     }\n\t }\n\n    }\n    \n    variation[k].push_back(make_pair(count, now_level));\n}\n\nint main() {\n    while (1) {\n        int i;\n\tint min = 100000000;\n\n\tscanf(\"%d\", &r);\n\tif (r == 0) return 0;\n\n        input(0);\n        input(1);\n        bfs(0);\n        bfs(1);\n\n\tvector<pair<int, int> >::iterator it1 = variation[0].begin();\n\twhile (it1 != variation[0].end()) {\n\t    vector<pair<int, int> >::iterator it2 = lower_bound(variation[1].begin(), variation[1].end(), make_pair(r - it1->first, -1));\n\n\t    if (it2 == variation[1].end()) {\n                ++it1;\n\t\tcontinue;\n\t    }\n\n\t    if (it1->second + it2->second < min)min = it1->second + it2->second;\n\t    ++it1;\n\t}\n\n\tprintf(\"%d\\n\", min);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=1;i<=n;i++)\n#define drep(i,n) for(int i=n;i>=0;i--)\n#define MAX 160000\n#define B 100\n#define dpb push_back\n#define fi first\n#define se second\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst int inf = 1e9;\nconst ll INF = 1e18;\nconst int size = 1002;\n//__gcd(a,b), __builtin_popcount(a);\n\nint r, h1, w1, X1, Y1, h2, w2, X2, Y2;\nint dy[4] = {0, 0, -1, 1}, dx[4] = {-1, 1, 0, 0};\nint a[size][size], b[size][size];\nint an[250010], bn[250010];\n\nint to_n(int y, int x, int w){\n\treturn (w*(y-1)+x);\n}\nint to_y(int n, int w){\n\treturn ((n-1)/w+1);\n}\nint to_x(int n, int w){\n\treturn (n-(to_y(n, w)-1)*w);\n}\nint main(){\n\twhile(1){\n\tfill((int*)a, (int*)(a+size), inf);\n\tfill((int*)b, (int*)(b+size), inf);\n\tfill(an, an+250004, 0);\n\tfill(bn, bn+250004, 0);\n\tscanf(\"%d\", &r);\n\tif(!r)break;\n\tscanf(\"%d%d%d%d\", &w1, &h1, &X1, &Y1);\n\trrep(i,h1)rrep(j,w1)scanf(\"%d\", &a[i][j]);\n\tscanf(\"%d%d%d%d\", &w2, &h2, &X2, &Y2);\n\trrep(i,h2)rrep(j,w2)scanf(\"%d\", &b[i][j]);\n\t\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tq.push(P(a[Y1][X1], to_n(Y1, X1,w1)));\n\ta[Y1][X1] = inf;\n\tint acnt = 1;\n\twhile(!q.empty()){\n\t\tP p = q.top();q.pop();\n\t\tint y = to_y(p.se, w1), x = to_x(p.se, w1);\n\t\tan[acnt++] = p.fi;\n\t\tfor(int i = 0;i < 4;i++){\n\t\t\tint yy = y+dy[i], xx = x+dx[i];\n\t\t\tif(a[yy][xx] != inf){\n\t\t\t\tq.push(P(a[yy][xx], to_n(yy, xx,w1)));\n\t\t\t\ta[yy][xx] = inf;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tq.push(P(b[Y2][X2], to_n(Y2, X2,w2)));\n\tb[Y2][X2] = inf;\n\tint bcnt = 1;\n\twhile(!q.empty()){\n\t\tP p = q.top();q.pop();\n\t\tint y = to_y(p.se, w2), x = to_x(p.se, w2);\n\t\tbn[bcnt++] = p.fi;\n\t\tfor(int i = 0;i < 4;i++){\n\t\t\tint yy = y+dy[i], xx = x+dx[i];\n\t\t\tif(b[yy][xx] != inf){\n\t\t\t\tq.push(P(b[yy][xx], to_n(yy, xx,w2)));\n\t\t\t\tb[yy][xx] = inf;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint t1 = 0, t2 = 0;\n\tfor(int i = 0;i < acnt;i++){\n\t\tt1 = max(t1, an[i]);\n\t\tan[i] = t1;\n\t}\n\tfor(int i = 0;i < bcnt;i++){\n\t\tt2 = max(t2, bn[i]);\n\t\tbn[i] = t2;\n\t}\n\t\n\tint ans = inf;\n\tfor(int i = 0;i < acnt;i++){\n\t\tif(r-i < bcnt)ans = min(ans, an[i]+bn[r-i]);\n\t}\n\t\n\t/*rep(i,acnt)printf(\"%d \", an[i]);\n\tprintf(\"\\n\");\n\trep(i,bcnt)printf(\"%d \", bn[i]);\n\tprintf(\"\\n\");*/\n\t//int ans = 0;\n\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \ntemplate<typename T1, typename T2> istream& operator>>(istream& is, pair<T1,T2>& a){ return is >> a.first >> a.second; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, pair<T1,T2>& a){ return os << a.first << \" \" << a.second; }\ntemplate<typename T> istream& operator>>(istream& is, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) is >> vc[i]; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) os << vc[i] << endl; return os; }\n \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n\ntypedef long long int64;\ntypedef pair< int , int > Pi;\ntypedef pair< int , Pi > Pii;\nconst int INF = 1 << 30;\n\nint main()\n{\n  int R, W[2], H[2], X, Y, L[500][500];\n  int min_cost[500][500], limit[2][500 * 500 + 1];\n\n  static const signed dy[] = { 0, 1, 0, -1}, dx[] = { 1, 0, -1, 0};\n\n  while(scanf(\"%d\", &R), R){\n    map< int, int > level[2];\n    for(int i = 0; i < 2; i++){\n      scanf(\"%d %d %d %d\", &W[i], &H[i], &X, &Y);\n      --X, --Y;\n      for(int j = 0; j < H[i]; j++){\n        for(int k = 0; k < W[i]; k++){\n          scanf(\"%d\", &L[j][k]);\n        }\n      }\n      priority_queue< Pii, vector< Pii >, greater< Pii > > que;\n      fill_n( *min_cost, 500 * 500, INF);\n      que.push( Pii( L[Y][X], make_pair( X, Y)));\n      min_cost[X][Y] = L[Y][X];\n      level[i][min_cost[X][Y]]++;\n      while(!que.empty()){\n        Pii p = que.top(); que.pop();\n        if(p.first > min_cost[p.second.first][p.second.second]) continue;\n        for(int j = 0; j < 4; j++){\n          int nx = p.second.first + dx[j], ny = p.second.second + dy[j];\n          if(nx < 0 || nx >= W[i] || ny < 0 || ny >= H[i]) continue;\n          if(max( L[ny][nx], p.first) >= min_cost[nx][ny]) continue;\n          min_cost[nx][ny] = max( L[ny][nx], p.first);\n          que.push( Pii( max( L[ny][nx], p.first), make_pair( nx, ny)));\n          level[i][min_cost[nx][ny]]++;\n        }\n      }\n\n      int sz = 0;\n      fill_n( limit[i], H[i] * W[i], 0);\n      ForEach(it, level[i]){\n        sz += it -> second;\n        limit[i][sz] = it -> first;\n      }\n      for(int j = H[i] * W[i] - 1; j > 0; j--){\n        if(limit[i][j] == 0) limit[i][j] = limit[i][j + 1];\n      }\n    }\n\n    int ret = INF;\n    for(int i = 0; i < H[0] * W[0]; i++){\n      int nokori = R - i;\n      if(nokori < 0 || nokori > W[1] * H[1]) continue;\n      ret = min( ret, limit[0][i] + limit[1][nokori]);\n    }\n    printf(\"%d\\n\", ret);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<utility>\n#include<cstring>\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef pair<int, int> PII;\ntypedef vector<PII> VP;\ntypedef VP::iterator VPI;\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\n\nint r;\nint w[2], h[2], x[2], y[2];\nint room[2][500][500];\n\nVP level[2];\nbool though[2][500][500];\nint main()\n{\n  while(cin >> r && r){\n\n    memset(though, false, sizeof though);\n    level[0].clear();\n    level[1].clear();\n\n    //part1\n    for(int i = 0; i < 2; i++){\n      cin >> w[i] >> h[i] >> x[i] >> y[i];\n      for(int j = 0; j < h[i]; j++){\n\tfor(int k = 0; k < w[i]; k++){\n\t  cin >> room[i][j][k];\n\t}\n      }\n    }\n\n    //part2\n    for(int i = 0; i < 2; i++){\n      priority_queue<PII, vector<PII>, greater<PII> > search;\n      search.push(MP(1, (y[i] - 1) * 10000 + (x[i] - 1)));\n      though[i][y[i] - 1][x[i] - 1] = true;\n      \n      int counter = 0, lv = 0;\n      while(!search.empty()){\n\tPII now = search.top();\n\tsearch.pop();\n\n\tif(now.first > lv){\n\t  level[i].PB(MP(counter, lv));\n\t  lv = now.first;\n\t}\n\tcounter++;\n\tfor(int j = 0; j < 4; j++){\n\t  int nexty = now.second / 10000 + dy[j];\n\t  int nextx = now.second % 10000 + dx[j];\n\n\t  if(0 <= nexty && nexty < h[i] && 0 <= nextx && nextx < w[i] && !though[i][nexty][nextx]){\n\t    though[i][nexty][nextx] = true;\n\t    search.push(MP(room[i][nexty][nextx], nexty * 10000 + nextx));\n\t  }\n\t}\n      }\n      level[i].PB(MP(counter, lv));\n    }\n\n    //part3\n    int ans = 2e9;\n    for(int i = 0; i < level[0].size(); i++){\n      VPI pr = lower_bound(level[1].begin(), level[1].end(), MP(r - level[0][i].first, 0));\n      if(pr != level[1].end())\n\tans = min(ans, level[0][i].second + pr->second);\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\n\n#define fr first\n#define sc second\n#define pb push_back\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define rep1(i,x) for(ll i=1;i<=x;i++)\n#define rrep(i,x) for(ll i=x-1;i>=0;i--)\n#define rrep1(i,x) for(ll i=x;i>0;i--)\n\nstruct T{\n\tll l,y,x;\n\tbool operator<(const T& b)const{\n\t\treturn l<b.l;\n\t};\n\tbool operator>(const T& b)const{\n\t\treturn l>b.l;\n\t};\n};\nconst ll INF=0xfffffffffffffff;\nll R;\nll W1,W2,H1,H2;\nll X1,Y1,X2,Y2;\nll L1[500][500];\nll L2[500][500];\nll atu1[25000];\nll atu2[25000];\nll dp1[25000];//?¨???????????????¨?±?????????°\nll dp2[25000];\nll sz1,sz2;\nll vx[4]={1,0,-1,0};\nll vy[4]={0,1,0,-1};\nbool pushed[500][500];\nvoid solve(ll W,ll H,ll sx,ll sy,ll L[][500],ll *atu,ll *dp,ll& sz){\n\tauto ok = [&](ll y,ll x){\n\t\treturn 0<=x&&x<W&&0<=y&&y<H;\n\t};\n\tfill(atu,atu+25000,INF);\n\tmemset(pushed,0,sizeof(pushed));\n\tvector<ll> xs;\n\trep(i,H) rep(j,W){\n\t\txs.pb(L[i][j]);\n\t}\n\tsort(xs.begin(),xs.end());\n\txs.erase(unique(xs.begin(),xs.end()),xs.end());\n\tsz=xs.size();\n\trep(i,xs.size()) atu[i]=xs[i];\n\trep(i,H) rep(j,W){\n\t\tL[i][j]=lower_bound(xs.begin(),xs.end(),L[i][j])-xs.begin();\n\t}\n\tll kosu=0,now=0;\n\tpriority_queue<T,vector<T>,greater<T> > q;\n\tq.push(T{0,sy,sx});\n\tpushed[sy][sx]=1;\n\twhile(!q.empty()){\n\t\tT t=q.top();\n\t\tq.pop();\n\t\tnow=max(now,t.l);\n\t\tkosu++;\n\t\tdp[now]=kosu;\n\t\trep(i,4){\n\t\t\tll ny=t.y+vy[i];\n\t\t\tll nx=t.x+vx[i];\n\t\t\tif(ok(ny,nx)&&!pushed[ny][nx]){\n\t\t\t\tq.push(T{L[ny][nx],ny,nx});\n\t\t\t\tpushed[ny][nx]=1;\n\t\t\t}\n\t\t}\n\t}\n\trep1(i,sz-1) if(dp[i]<dp[i-1]){\n\t\tdp[i]=dp[i-1];\n\t}\n\treturn;\n}\n\nint main()\n{while(1){\n\tcin>>R;\n\tif(!R) break;\n\tmemset(dp1,0,sizeof(dp1));\n\tmemset(dp2,0,sizeof(dp2));\n\tcin>>W1>>H1>>X1>>Y1;\n\tX1--;\n\tY1--;\n\trep(i,H1) rep(j,W1) cin>>L1[i][j];\n\tsolve(W1,H1,X1,Y1,L1,atu1,dp1,sz1);\n\tcin>>W2>>H2>>X2>>Y2;\n\tX2--;\n\tY2--;\n\trep(i,H2) rep(j,W2) cin>>L2[i][j];\n\tsolve(W2,H2,X2,Y2,L2,atu2,dp2,sz2);\n\tll ans=atu2[lower_bound(dp2,dp2+sz2,R)-dp2];\n\trep(i,sz1){\n\t\tif(dp1[i]>=R) ans=min(ans,atu1[i]);\n\t\telse ans=min(ans,atu1[i]+atu2[lower_bound(dp2,dp2+sz2,R-dp1[i])-dp2]);\n\t}\n\tcout<<ans<<endl;\n}}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nll c[2501];\nll b[501][501];\nstruct A {\n\tll ko, level;\n};\nA a[2][2501];\nll u[501][501];\nstruct P {\n\tll x, y, level;\n};\nll d[2];\nbool operator<(P a, P b) { return a.level < b.level; }\nbool operator>(P a, P b) { return a.level > b.level; }\nconst ll inf = 800000000000000000;\nint main() {\n\tll r;\n\tint lp[4][2] = { {1,0},{-1,0},{0,1},{0,-1} };\n\twhile (cin >> r&&r != 0) {\n\t\tfor (int z = 0; z < 2; z++) {\n\t\t\tll h, w, x, y;\n\t\t\tcin >> w >> h >> y >> x;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tqueue<P>p;\n\t\t\tfor (ll i = 0; i < h; i++) {\n\t\t\t\tfor (ll j = 0; j < w; j++) {\n\t\t\t\t\tcin >> u[i][j];\n\t\t\t\t\tb[i][j] = inf;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.push(P{ x,y,1 });\n\t\t\tb[x][y] = 1;\n\t\t\twhile (!p.empty()) {\n\t\t\t\tP t = p.front(); p.pop();\n\t\t\t\tll x = t.x, y = t.y;\n\t\t\t\tif (t.level == b[x][y]) {\n\t\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\t\tll x2 = x + lp[i][0], y2 = y + lp[i][1];\n\t\t\t\t\t\tif (b[x2][y2] > t.level) {\n\t\t\t\t\t\t\tif (u[x2][y2] <= t.level) {\n\t\t\t\t\t\t\t\tb[x2][y2] = t.level;\n\t\t\t\t\t\t\t\tp.push(P{ x2,y2,t.level });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (u[x2][y2] < b[x2][y2]) {\n\t\t\t\t\t\t\t\t\tb[x2][y2] = u[x2][y2];\n\t\t\t\t\t\t\t\t\tp.push(P{ x2,y2,u[x2][y2] });\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tll o = 0;\n\t\t\tfor (ll i = 0; i < h; i++) {\n\t\t\t\tfor (ll j = 0; j < w; j++) {\n\t\t\t\t\tc[o] = b[i][j];\n\t\t\t\t\to++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(c, c + o);\n\t\t\tll sum = 0, g = 1;\n\t\t\ta[z][0] = A{ 0,0 };\n\t\t\tfor (ll i = 0; i < (h*w);) {\n\t\t\t\tll k = c[i], sum2 = 0;\n\t\t\t\twhile (i < (h*w) && c[i] == k) {\n\t\t\t\t\tsum2++;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\ta[z][g] = A{ sum2 + sum,k };\n\t\t\t\tg++;\n\t\t\t\tsum += sum2;\n\t\t\t}\n\t\t\td[z] = g;\n\t\t}\n\t\tll sum = inf;\n\t\tfor (ll i = 0; i < d[0]; i++) {\n\t\t\tll s = 0, e = d[1] - 1, t, m = r - a[0][i].ko;\n\t\t\twhile (e - s > 1) {\n\t\t\t\tt = (e + s) / 2;\n\t\t\t\tif (a[1][t].ko <= m)\n\t\t\t\t\ts = t;\n\t\t\t\tif (a[1][t].ko >= m)\n\t\t\t\t\te = t;\n\t\t\t}\n\t\t\tif (a[0][i].ko + a[1][s].ko >= r)\n\t\t\t\tsum = min(sum, a[0][i].level + a[1][s].level);\n\t\t\tif (a[0][i].ko + a[1][e].ko >= r)\n\t\t\t\tsum = min(sum, a[0][i].level + a[1][e].level);\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <queue>\n\nusing namespace std;\n\nconst int N = 500;\nconst int INF = 1000000000;\n\nclass S{\npublic:\n  int x, y, cost;\n  S(){}\n  S(int x, int y, int cost) : x(x), y(y), cost(cost) {}\n  bool operator < (const S& s) const {\n    return cost > s.cost;\n  }\n};\n\nint R, w[2], h[2], sx[2], sy[2], input[2][N][N], vis[N][N];\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nvector<int> vec[2];\nset<int> data;\nint cnt;\n\nvoid dfs(int x, int y, int cost, int d){\n  vis[y][x] = true;\n  cnt++;\n  for(int i=0;i<4;i++){\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if(ny < 0 || ny >= h[d]) continue;\n    if(nx < 0 || nx >= w[d]) continue;\n    if(input[d][ny][nx] > cost) continue;\n    if(!vis[ny][nx]) dfs(nx, ny, cost, d);\n  }\n}\n\nvoid bfs(int d){\n  int x = sx[d];\n  int y = sy[d];\n  int cost = 1;\n  priority_queue<S> q;\n  S u;\n  q.push(S(x, y, cost));\n  vis[y][x] = cost;\n  while(!q.empty()){\n    u = q.top(); q.pop();\n    if(vis[u.y][u.x] < u.cost) continue;\n    for(int i=0;i<4;i++){\n      int ny = u.y + dy[i];\n      int nx = u.x + dx[i];\n      if(ny < 0 || ny >= h[d]) continue;\n      if(nx < 0 || nx >= w[d]) continue;\n      int tmp = max(u.cost, input[d][ny][nx]);\n      if(vis[ny][nx] > tmp){\n        vis[ny][nx] = tmp;\n        q.push(S(nx, ny, tmp));\n      }\n    }\n  }\n}\n\nvoid init(){\n  data.clear();\n  for(int k=0;k<2;k++){\n    for(int i=0;i<h[k];i++){\n      for(int j=0;j<w[k];j++){\n        data.insert(input[k][i][j]);\n      }\n    }\n  }\n  for(int k=0;k<2;k++){\n    int vis2[N][N];\n    fill(vis2[0], vis2[N], INF);\n    set<int>::iterator ite = data.begin();\n    for(;ite!=data.end();ite++){\n      fill(vis[0], vis[N], false);\n      dfs(sx[k], sy[k], *ite, k);      \n      for(int i=0;i<h[k];i++){\n        for(int j=0;j<w[k];j++){\n          if(vis[i][j]) vis2[i][j] = min(vis2[i][j], *ite);\n        }\n      }\n    }\n    //bfs(k);\n\n    vec[k].clear();\n    for(int i=0;i<h[k];i++){\n      for(int j=0;j<w[k];j++){\n        vec[k].push_back(vis2[i][j]);\n      }\n    }\n    sort(vec[k].begin(), vec[k].end());\n  }\n}\n\nbool check(int a, int b){\n  int t1 = distance(vec[0].begin(), upper_bound(vec[0].begin(), vec[0].end(), a));\n  int t2 = distance(vec[1].begin(), upper_bound(vec[1].begin(), vec[1].end(), b));\n  return t1 + t2 >= R;\n  /*int sum = 0;\n  for(int i=0;i<2;i++){\n    fill(vis[0], vis[N], false);\n    cnt = 0;\n    int cost = a;\n    if(i == 1) cost = b;\n    if(cost > 0) dfs(sx[i], sy[i], cost, i);\n    sum += cnt;\n  }\n  return sum >= R;*/\n}\n\nint solve(){\n  set<int>::iterator ite = data.end();\n  int l = 0, r = *(--ite) + 1;\n  while(l<r){\n    int m = (l + r) / 2;\n    bool f = false;\n    for(ite=data.begin();ite!=data.end();ite++){\n      if(*ite > m) break;\n      if(check(*ite, m-(*ite))) f = true;\n    }\n    if(f) r = m;\n    else l = m + 1;\n  }\n  return l;\n}\n\nmain(){\n  while(cin >> R && R){\n    for(int k=0;k<2;k++){\n      cin >> w[k] >> h[k] >> sx[k] >> sy[k];\n      sx[k]--; sy[k]--;\n      for(int i=0;i<h[k];i++){\n        for(int j=0;j<w[k];j++){\n          cin >> input[k][i][j];\n        }\n      }\n    }\n    init();\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define INF 1145141919\ntypedef pair<int, int> P;\ntypedef pair<int, P> P2;\n\nint DX[4] = {-1, 0, 1, 0};\nint DY[4] = {0, -1, 0, 1};\n\nint R;\nint M[500][500];\nbool V[500][500];\n\nint main() {\n  while (cin >> R) {\n    if (R == 0) break;\n    vector<P> S[2];\n\n    for (int k=0; k<=1; k++) {\n      S[k%2].push_back(P(0, 0));\n\n      int w, h, x, y;\n      cin >> w >> h >> x >> y;\n      x--, y--;\n      for (int i=0; i<h; i++) {\n        for (int j=0; j<w; j++) {\n          cin >> M[j][i];\n        }\n      }\n      for (int i=0; i<h; i++) {\n        for (int j=0; j<w; j++) {\n          V[i][j] = false;\n        }\n      }\n      priority_queue< P2, vector<P2>, greater<P2> > q;\n      V[x][y] = true;\n      q.push(P2(M[x][y], P(x, y)));\n      int c = -1;\n\n      while (!q.empty()) {\n        int r = q.top().first,\n            sx = q.top().second.first,\n            sy = q.top().second.second; q.pop();\n        P last = S[k%2][S[k%2].size()-1];\n        if (c == r) {\n          S[k%2][S[k%2].size()-1] = P(last.first + 1, r);\n        }\n        else {\n          S[k%2].push_back(P(last.first + 1, r));\n          c = r;\n        }\n\n        for (int i=0; i<4; i++) {\n          int tx = sx + DX[i], ty = sy + DY[i];\n          if (tx < 0 || tx >= w || ty < 0 || ty >= h) continue;\n          int g = max(r, M[tx][ty]);\n          if (!V[tx][ty]) {\n            V[tx][ty] = true;\n            q.push(P2(g, P(tx, ty)));\n          }\n        }\n      }\n    }\n    int m = INF;\n    for (auto x : S[0]) {\n      int r = R - x.first;\n      auto it = lower_bound(S[1].begin(), S[1].end(), P(r, 0));\n      if (it == S[1].end()) continue;\n      P y = *it;\n      if (x.first + y.first < R) continue;\n      m = min(m, x.second + y.second);\n    }\n    cout << m << \"\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = 1e+14;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\nll d[2][500][500];\nvector<ll> v[2];\ntypedef pair<int, P> speP;\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\nbool used[2][500][500];\nvoid solve() {\n\tint r;\n\twhile (cin >> r,r) {\n\t\tint w[2], h[2], x[2], y[2];\n\t\trep(i, 2) {\n\t\t\tcin >> w[i] >> h[i] >> x[i] >> y[i]; x[i]--; y[i]--;\n\t\t\trep(j, h[i]) {\n\t\t\t\trep(k, w[i]) {\n\t\t\t\t\tcin >> d[i][j][k];\n\t\t\t\t\tused[i][j][k] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tv[i].clear(); v[i].resize(w[i] * h[i] + 1, 0);\n\t\t}\n\t\trep(id, 2) {\n\t\t\tint cnt = 1;\n\t\t\tpriority_queue<speP,vector<speP>,greater<speP>> q;\n\t\t\tq.push({ 0,{y[id],x[id]} });\n\t\t\tused[id][y[id]][x[id]] = true;\n\t\t\tint num = 1;\n\t\t\twhile (!q.empty()) {\n\t\t\t\tspeP p = q.top(); q.pop();\n\t\t\t\tint ix = p.second.first; int iy = p.second.second;\n\t\t\t\tnum = max(num, p.first);\n\t\t\t\tv[id][cnt] = num; cnt++;\n\t\t\t\trep(j, 4) {\n\t\t\t\t\tint nx = ix + dx[j];\n\t\t\t\t\tint ny = iy + dy[j];\n\t\t\t\t\tif (nx < 0 || ny < 0 || nx >= h[id] || ny >= w[id])continue;\n\t\t\t\t\tif (used[id][nx][ny])continue;\n\t\t\t\t\tused[id][nx][ny] = true;\n\t\t\t\t\tq.push({ (int)d[id][nx][ny],P{nx,ny} });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = mod;\n\t\trep(i, h[0] * w[0] + 1) {\n\t\t\tint j = r - i;\n\t\t\tif (j<0 || j>w[1] * h[1])continue;\n\t\t\t//cout << v[0][i] << \" \" << v[1][j] << endl;\n\t\t\tans = min(ans, v[0][i] + v[1][j]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(7);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <iterator>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <cmath>\n#include <complex>\n#include <functional>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <cstdlib>\n#include <cctype>\n\n#define REP(i,m,n) for(int i=m;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rp(i,c) rep(i,(int)c.size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define v_delete(a,b) (a).erase(remove((a).begin(), (a).end(), b), (a).end())\n#define v_unique(a) (a).erase(unique((a).begin(), (a).end()), (a).end())\n#define VV(T) vector<vector< T > >\n#define init(a,b) memset((a), (b), sizeof((a)))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double EPS=1e-9;\nconst long long INF = 100001000010000100ll;\n\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntypedef pair<int,int> pii;\n\nint R;\nint W[2], H[2], X[2], Y[2];\n\nint m[4][500+10][500+10];\nint visited[2][500+10][500+10];\n\nint wa[2][500*500*10];\n\nvi ls;\n\nmap<int ,int> cnt[2];\n\nbool exists(const map<int ,int> &mapp, int key){\n\treturn mapp.find(key) != mapp.end();\n}\n\nint dx[]={1,0,0,-1};\nint dy[]={0,1,-1,0};\n\nclass BIT{\nprivate:\n\tvi bit;\n\tint n;\npublic:\n\tBIT(int _n){\n\t\tn = _n;\n\t\tbit.assign(n+1,0 );\n\t}\n\tvoid add(int i, int x){\n\t\twhile(i <= n){\n\t\t\tbit[i] += x;\n\t\t\ti += (i & -i);\n\t\t}\n\t}\n\tint sum(int i){\n\t\tint s = 0;\n\t\twhile(i > 0){\n\t\t\ts += bit[i];\n\t\t\ti -= (i & -i);\n\t\t}\n\t\treturn s;\n\t}\n};\n\n\nint main(){\n\twhile(cin >> R, R){\n\n\t\tmemset(visited, 0, sizeof(visited));\n\n\t\tmemset(wa, 0, sizeof(wa));\n\n\t\tls.clear();\n\n\t\tfill_n(**m, 4 * (500+10) * (500+10), inf);\n\n\t\trep(c, 2){\n\t\t\tcin >> W[c] >> H[c] >> X[c] >> Y[c];\n\t\t\trep(i, H[c]){\n\t\t\t\trep(j, W[c]){\n\t\t\t\t\tcin >> m[c][i+1][j+1];\n\t\t\t\t\tm[c+2][i+1][j+1]=m[c][i+1][j+1];\n\t\t\t\t\tls.pb(m[c][i+1][j+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tls.pb(0);\n\t\tls.pb(inf);\n\t\tsort(all(ls));\n\t\tls.erase(unique(all(ls)), ls.end());\n\t\trep(c, 2){\n\t\t\tpriority_queue<pair<int, pii>, vector<pair<int, pii> >, greater<pair<int, pii> > >Q;\n\t\t\tQ.push(mp(1, mp(X[c], Y[c])));\n\t\t\twhile(!Q.empty()){\n\t\t\t\tint x,y,level;\n\t\t\t\tx=Q.top().second.first;y=Q.top().second.second;level=Q.top().first;\n\t\t\t\tvisited[c][y][x] = 1;\n\n\t\t\t\tif(level > m[c][y][x]){\n\t\t\t\t\tm[c][y][x] = level;\n\t\t\t\t}else{\n\t\t\t\t\tlevel = m[c][y][x];\n\t\t\t\t}\n\t\t\t\t//printf(\"%d %d %d %d\\n\",c, x, y, level);\n\n\t\t\t\tQ.pop();\n\t\t\t\trep(k, 4){\n\t\t\t\t\tif(m[c][y+dy[k]][x+dx[k]]!=inf){\n\t\t\t\t\t\tif(!visited[c][y+dy[k]][x+dx[k]]){\n\t\t\t\t\t\t\tQ.push(mp(max(m[c][y+dy[k]][x+dx[k]], level), mp(x+dx[k], y+dy[k])));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}/*\n\t\trep(c, 2){\n\t\t\trep(i, H[c]){\n\t\t\t\trep(j, W[c]){\n\t\t\t\t\tcout <<  m[c][i+1][j+1] << \" \";\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\tcout << endl;\n\t\t\tcout << endl;\n\t\t}*/\n\t\trep(c, 2){\n\t\t\trep(i, H[c]){\n\t\t\t\trep(j, W[c]){\n\t\t\t\t\tint ma=-1;\n\t\t\t\t\tint tmp=inf;\n\t\t\t\t\t/*\n\t\t\t\t\trep(k, 4){\n\t\t\t\t\t\ttmp=min(tmp, m[c][i + 1 + dx[k]][j + 1 + dy[k]]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i + 1 == Y[c] && j + 1 == X[c]){\n\t\t\t\t\t\tma=m[c][i + 1][j + 1];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tma = max(m[c][i + 1][j + 1], tmp);\n\t\t\t\t\t}*/\n\t\t\t\t\tma=m[c][i + 1][j + 1];\n\t\t\t\t\tint l = lower_bound(all(ls), ma) - ls.begin();\n\t\t\t\t\twa[c][l]++;\n\n\t\t\t\t}\n\t\t\t}\n\t\t\trp(i, ls){\n\t\t\t\tif(i - 1 >= 0)\n\t\t\t\t\twa[c][i] = wa[c][i - 1] + wa[c][i];\n\t\t\t}\n\n\t\t}\n\t\t/*\n\t\trep(c, 2){\n\t\t\trp(i, ls){\n\t\t\t\tcout << ls[i] << \" \" << wa[c][i] << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\tcout << endl;\n\t\t}*/\n\t\tint ans=inf;\n\t\trp(i, ls){\n\n\t\t\tint l=lower_bound(wa[1],(wa[1]+(int)ls.size()) , R - wa[0][i]) - wa[1];\n\t\t\tif(l < ls.size())\n\t\t\tif(wa[0][i] + wa[1][l] >= R){\n\t\t\t\t//cout << ls[i] << \" \" << ls[l] << endl;\n\t\t\t\tans=min(ans, ls[i] + ls[l]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\n\nint r1[500][500];\nint r2[500][500];\nint UF1[250000];\nint UF2[250000];\npair<int,pair<int,int> > k1[500000];\npair<int,pair<int,int> >k2[500000];\nint cost1[250001];\nint cost2[250001];\nint FIND1(int a){\n\tif(UF1[a]<0)return a;\n\treturn UF1[a]=FIND1(UF1[a]);\n}\nint FIND2(int a){\n\tif(UF2[a]<0)return a;\n\treturn UF2[a]=FIND2(UF2[a]);\n}\nvoid UNION1(int a,int b){\n\ta=FIND1(a);\n\tb=FIND1(b);\n\tif(a==b)return ;\n\tUF1[a]+=UF1[b];\n\tUF1[b]=a;\n}\nvoid UNION2(int a,int b){\n\ta=FIND2(a);\n\tb=FIND2(b);\n\tif(a==b)return;\n\tUF2[a]+=UF2[b];\n\tUF2[b]=a;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<250001;i++)cost1[i]=cost2[i]=999999999;\n\t\tfor(int i=0;i<250000;i++)UF1[i]=UF2[i]=-1;\n\t\tcost1[0]=cost2[0]=0;\n\t\tint b1,c1,d1,e1;\n\t\tint b2,c2,d2,e2;\n\t\tscanf(\"%d%d%d%d\",&b1,&c1,&d1,&e1);\n\t\tfor(int i=0;i<c1;i++){\n\t\t\tfor(int j=0;j<b1;j++){\n\t\t\t\tscanf(\"%d\",&r1[i][j]);\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d%d%d%d\",&b2,&c2,&d2,&e2);\n\t\tfor(int i=0;i<c2;i++)\n\t\t\tfor(int j=0;j<b2;j++)\n\t\t\t\tscanf(\"%d\",&r2[i][j]);\n\t\tint now1=0;\n\t\tfor(int i=0;i<c1-1;i++){\n\t\t\tfor(int j=0;j<b1;j++){\n\t\t\t\tk1[now1++]=make_pair(max(r1[i][j],r1[i+1][j]),make_pair(b1*i+j,b1*(i+1)+j));\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<c1;i++){\n\t\t\tfor(int j=0;j<b1-1;j++)\n\t\t\t\tk1[now1++]=make_pair(max(r1[i][j],r1[i][j+1]),make_pair(b1*i+j,b1*i+j+1));\n\t\t}\n\t\tint now2=0;\n\t\tfor(int i=0;i<c2-1;i++){\n\t\t\tfor(int j=0;j<b2;j++){\n\t\t\t\tk2[now2++]=make_pair(max(r2[i][j],r2[i+1][j]),make_pair(b2*i+j,b2*(i+1)+j));\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<c2;i++){\n\t\t\tfor(int j=0;j<b2-1;j++)\n\t\t\t\tk2[now2++]=make_pair(max(r2[i][j],r2[i][j+1]),make_pair(b2*i+j,b2*i+j+1));\n\t\t}\n\t\tstd::sort(k1,k1+now1);\n\t\tstd::sort(k2,k2+now2);\n\t\tfor(int i=0;i<now1;i++){\n\t\t\tUNION1(k1[i].second.first,k1[i].second.second);\n\t\t\tcost1[-UF1[FIND1((e1-1)*b1+d1-1)]]=min(cost1[-UF1[FIND1((e1-1)*b1+d1-1)]],k1[i].first);\n\t\t}\n\t\tfor(int i=0;i<now2;i++){\n\t\t\tUNION2(k2[i].second.first,k2[i].second.second);\n\t\t\tcost2[-UF2[FIND2((e2-1)*b2+d2-1)]]=min(cost2[-UF2[FIND2((e2-1)*b2+d2-1)]],k2[i].first);\n\t\t}\n\t\tfor(int i=249999;i>=0;i--){\n\t\t\tcost1[i]=min(cost1[i],cost1[i+1]);\n\t\t\tcost2[i]=min(cost2[i],cost2[i+1]);\n\t\t}\n\t\tint ret=999999999;\n\t\tfor(int i=0;i<=a;i++)ret=min(ret,cost1[i]+cost2[a-i]);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int ,int> pii;\ntypedef pair<int ,pii > pipii;\n\nvoid solve();\nvoid range(int o);\n\nint R;\nint room[2][510][510];\nint W[2],H[2],X[2],Y[2];\nint cost[2][1000000];\nint dx[] = {0,1,0,-1},dy[] = {1,0,-1,0};\n\nint main()\n{\n    while(scanf(\"%d\",&R),R)\n    {\n        for(int i = 0; i < 2; i++)\n        {\n            scanf(\"%d%d%d%d\",&W[i],&H[i],&X[i],&Y[i]);\n            for(int j = 1; j < H[i] + 1; j++)\n            {\n                for(int k = 1; k < W[i] + 1; k++)\n                {\n                    scanf(\"%d\",&room[i][k][j]);\n                }\n            }\n        }\n        solve();\n    }\n}\n\nvoid solve()\n{\n    int ans = 200000000;\n    for(int i = 0; i < 2; i++)\n    {\n        range(i);\n        /*for(int j = 0; j <= H[i] * W[i]; j++)\n        {\n            printf(\"%d \",cost[i][j]);\n        }\n        printf(\"\\n\");*/\n    }\n    for(int i = 0; i <= W[0] * H[0]; i++)\n    {\n        if(R - i <= W[1] * H[1]&& 0 <= R - i)\n        {\n            ans = min(ans,cost[0][i] + cost[1][R - i]);\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return;\n}\n\nvoid range(int o)\n{\n    int cou = 1;\n    cost[o][0] = 0;\n    priority_queue<pipii, vector<pipii>, greater<pipii> > l;\n    l.push(make_pair(room[o][X[o]][Y[o]],make_pair(X[o],Y[o])));\n    while(l.size())\n    {\n        pipii now = l.top();\n        l.pop();\n        if(room[o][now.second.first][now.second.second] == 0)continue;\n        cost[o][cou] = now.first;\n        cou++;\n        for(int j = 0; j < 4; j++)\n        {\n            int x = now.second.first + dx[j],y = now.second.second + dy[j];\n            if(x <= 0 || W[o] < x || y <= 0 || H[o] < y || room[o][x][y] == 0)continue;\n            l.push(make_pair(max(room[o][x][y],now.first),make_pair(x,y)));\n            //printf(\"{%d %d}\\n\",x,y);\n        }\n        room[o][now.second.first][now.second.second] = 0;\n    }\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <string>\n#include <map>\n#include <utility>\n#include <set>\n#include <queue>\n#include <unordered_set>\n\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < signed(n); i++)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\n\nusing LL = long long;\nusing P = pair < int, int > ;\nusing PI = pair < P, int > ;\nconst int INF = 1 << 29;\nconst LL LINF = 1ll << 62ll;\n\nstruct edge{ int to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\nvector<P> visitable(vector<vector<int>>& stage, P start)\n{\n\tint h = stage.size(), w = stage[0].size();\n\tvector<vector<int>> ns(h, vector<int>(w, INF));\n\tset<P> visited;\n\tqueue<P> que;\n\tque.push(start);\n\tvisited.insert(start);\n\tns[start.first][start.second] = 1;\n\twhile (!que.empty())\n\t{\n\t\tP p = que.front(); que.pop();\n\t\trep(i, 4)\n\t\t{\n\t\t\tint nr = dr[i] + p.first, nc = dc[i] + p.second;\n\t\t\tif (nr < 0 || nr >= h || nc < 0 || nc >= w) continue;\n\n\t\t\tns[nr][nc] = max(stage[nr][nc], min(ns[nr][nc], ns[p.first][p.second]));\n\n\t\t\tP np = P(nr, nc);\n\t\t\tif (visited.count(np)) continue;\n\t\t\tvisited.insert(np);\n\t\t\tque.push(np);\n\t\t}\n\t}\n\n\tmap<int, int> mp;\n\trep(i, h) rep(j, w) mp[ns[i][j]]++;\n\tvector<P> ret;\n\tfor (P p : mp) ret.push_back(p);\n\tfor (int i = 0; i + 1 < ret.size(); i++) ret[i + 1].second += ret[i].second;\n\treturn move(ret);\n}\n\n//x個を満たす最小の機密レベル\nint lower(vector<int>& sums, vector<int>& data, int x)\n{\n\tif (sums[sums.size() - 1] < x) return -1;\n\tif (x == 0) return 0;\n\n\tint idx = lower_bound(all(sums), x) - sums.begin();\n\treturn data[idx];\n}\n\nsigned main()\n{\n\tint R;\n\twhile (cin >> R)\n\t{\n\t\tint w1, h1, c1, r1; cin >> w1 >> h1 >> c1 >> r1;\n\t\tr1--; c1--;\n\t\tvector<vector<int>> stage1(h1, vector<int>(w1));\n\t\trep(i, h1) rep(j, w1) cin >> stage1[i][j];\n\n\t\tvector<P> ps1 = visitable(stage1, P(r1, c1));\n\t\tvector<int> sums1, data1;\n\t\tfor (P p : ps1)\n\t\t{\n\t\t\tsums1.push_back(p.second);\n\t\t\tdata1.push_back(p.first);\n\t\t}\n\n\t\tint w2, h2, c2, r2; cin >> w2 >> h2 >> c2 >> r2;\n\t\tr2--; c2--;\n\t\tvector<vector<int>> stage2(h2, vector<int>(w2));\n\t\trep(i, h2) rep(j, w2) cin >> stage2[i][j];\n\n\t\tvector<P> ps2 = visitable(stage2, P(r2, c2));\n\t\tvector<int> sums2, data2;\n\t\tfor (P p : ps2)\n\t\t{\n\t\t\tsums2.push_back(p.second);\n\t\t\tdata2.push_back(p.first);\n\t\t}\n\n\t\tint ans = INF;\n\t\trep(x, R + 1)\n\t\t{\n\t\t\tint y = R - x;\n\t\t\tint l1 = lower(sums1, data1, x);\n\t\t\tint l2 = lower(sums2, data2, y);\n\t\t\tif (l1 != -1 && l2 != -1)\n\t\t\t{\n\t\t\t\tans = min(ans, l1 + l2);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#define mp make_pair\nusing namespace std;\n\nint dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\ntypedef pair<int,pair<int,int> > P;\n\nint main(){\n\tint r,w,h,x,y,field[500][500],rank[500][500];\n\twhile(cin >> r,r){\n\t\tmap<int,int> sum;\n\t\tvector<int> vec[2][2];\n\t\tfor(int i = 0;i < 2;i++){\n\t\t\tsum.clear();\n\t\t\tcin >> w >> h >> x >> y;\n\t\t\tfor(int j = 0;j < h;j++){\n\t\t\t\tfor(int k = 0;k < w;k++){\n\t\t\t\t\tcin >> field[j][k];\n\t\t\t\t\trank[j][k] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\trank[y - 1][x - 1] = 1;\n\t\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\t\tque.push(mp(1,mp(y - 1,x - 1)));\n\t\t\twhile(!que.empty()){\n\t\t\t\tP p = que.top();que.pop();\n\t\t\t\tint nowr = p.first,nowy = p.second.first,nowx = p.second.second;\n\t\t\t\tfor(int j = 0;j < 4;j++){\n\t\t\t\t\tint ny = nowy + dy[j],nx = nowx + dx[j];\n\t\t\t\t\tif(ny >= 0 && ny < h && nx >= 0 && nx < w && rank[ny][nx] == -1){\n\t\t\t\t\t\tif(field[ny][nx] > nowr){\n\t\t\t\t\t\t\trank[ny][nx] = field[ny][nx];\n\t\t\t\t\t\t\tque.push(mp(rank[ny][nx],mp(ny,nx)));\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\trank[ny][nx] = nowr;\n\t\t\t\t\t\t\tque.push(mp(nowr,mp(ny,nx)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0;j < h;j++){\n\t\t\t\tfor(int k = 0;k < w;k++){\n\t\t\t\t\tsum[rank[j][k]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint s = 0;\n\t\t\tvec[i][0].push_back(0);\n\t\t\tvec[i][1].push_back(0);\n\t\t\tfor(auto itr = sum.begin();itr != sum.end();itr++){\n\t\t\t\ts += itr->second;\n\t\t\t\tvec[i][0].push_back(s);\n\t\t\t\tvec[i][1].push_back(itr->first);\n\t\t\t}\n\t\t}\n\t\tint mi = 1e+9;\n\t\tfor(int i = 0;i < vec[0][0].size();i++){\n\t\t\tint pos = lower_bound(vec[1][0].begin(),vec[1][0].end(),r - vec[0][0][i]) - vec[1][0].begin();\n\t\t\tif(pos < vec[1][0].size()) mi = min(mi,vec[0][1][i] + vec[1][1][pos]);\n\t\t}\n\t\tcout << mi << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define s(x) scanf(\"%d\",&x)\n#define rep(i,x) for(int i=0;i<x;i++)\nint v[500*500+500];\nint v2[500*500+500];\nint a[505][505];\nint b[505][505];\nbool used[505][505]={};\nint main()\n{\n\twhile(1)\n\t{\n\t\tint r;\n\t\tint w1,h1,x1,y1;\n\t\tscanf(\"%d\",&r);if(!r) return 0;\n\t\tscanf(\"%d %d %d %d\",&w1,&h1,&x1,&y1);\n\t\tfor(int i=1;i<=h1;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=w1;j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&a[j][i]);\n\t\t\t}\n\t\t}\n\t\tint w2,h2,x2,y2;\n\t\tscanf(\"%d %d %d %d\",&w2,&h2,&x2,&y2);\n\t\tfor(int i=1;i<=h2;i++)\n\t\t{\n\t\t\tfor(int j=1;j<=w2;j++)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&b[j][i]);\n\t\t\t}\n\t\t}\n\t\tmemset(used,0,sizeof(used));\n\t\tpriority_queue<P1,vector<P1>,greater<P1> >que;\n\t\tque.push(mp(1,mp(x1,y1)));\n\t\tint cur=0;\n\t\tint now=0;\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tP1 p=que.top(); que.pop();\n\t\t\tint x=p.second.first;\n\t\t\tint y=p.second.second;\n\t\t\tused[x][y]=true;\n\t\t\tnow=max(now,p.first);\n\t\t\tv[++cur]=now;\n\t\t\tint dx[4]={0,1,0,-1};\n\t\t\tint dy[4]={1,0,-1,0};\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t{\n\t\t\t\tint nx=x+dx[i];\n\t\t\t\tint ny=y+dy[i];\n\t\t\t\tif(!(0<=nx && nx<=w1)) continue;\n\t\t\t\tif(!(0<=ny && ny<=h1)) continue;\n\t\t\t\tif(used[nx][ny]) continue;\n\t\t\t\tque.push(mp(a[nx][ny],mp(nx,ny)));\n\t\t\t}\n\t\t}\n\t\tmemset(used,0,sizeof(used));\n\t\tque.push(mp(1,mp(x2,y2)));\n\t\tcur=now=0;\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tP1 p=que.top(); que.pop();\n\t\t\tint x=p.second.first;\n\t\t\tint y=p.second.second;\n\t\t\tused[x][y]=true;\n\t\t\tnow=max(now,p.first);\n\t\t\tv2[++cur]=now;\n\t\t\tint dx[4]={0,1,0,-1};\n\t\t\tint dy[4]={1,0,-1,0};\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t{\n\t\t\t\tint nx=x+dx[i];\n\t\t\t\tint ny=y+dy[i];\n\t\t\t\tif(!(0<=nx && nx<=w2)) continue;\n\t\t\t\tif(!(0<=ny && ny<=h2)) continue;\n\t\t\t\tif(used[nx][ny]) continue;\n\t\t\t\tque.push(mp(b[nx][ny],mp(nx,ny)));\n\t\t\t}\n\t\t}\n\t\tint ret=INF;\n\t\tfor(int i=max(0,r-w2*h2);i<=min(r,w1*h1);i++)\n\t\t{\n\t\t\tret=min(ret,v[i]+v2[r-i]);\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\n\nint x[2],y[2],w[2],h[2];\nint R;\nvector<vvi> zimu;\n\nvoid dfs(int i, int x, int y, vvi used, vector<pair<int,int>>& list){\n\n  priority_queue< pair<int,pii>, vector<pair<int,pii> >,greater<pair<int,pii> > > que;\n  que.push(pair<int,pii>(1,pii(x,y)));\n\n  int auth = 0;\n  int room = 0;\n  while(que.size()){\n    int corr_lev = que.top().first;\n    int corr_x = que.top().second.first;\n    int corr_y = que.top().second.second;\n    que.pop();\n    if( used[corr_y][corr_x] == 1) continue;\n    used[corr_y][corr_x] = 1;\n    \n    if(corr_lev > auth){\n      list.push_back(pii(room,auth));\n      auth = corr_lev;\n    }\n    room++;\n    if( room == w[i]*h[i] ) break;\n\n\n    for(int j=0; j<4; j++){\n      int nx = corr_x + dx[j];\n      int ny = corr_y + dy[j];\n      if(nx >= w[i] || nx < 0 || ny >= h[i] || ny < 0) continue; // ????£?\n      if(used[ny][nx] == 1) continue; // ??¢?´¢??????\n      que.push( pair<int,pii>(zimu[i][ny][nx],pii(nx,ny)) );\n    }\n  }\n  list.push_back(pii(room,auth));\n}\n\nint main(){\n  while(1){\n  \n    cin >> R; if(!R) break;\n    zimu.clear();\n    \n    // ??\\???\n    for(int i=0; i<2; i++){\n      cin >> w[i] >> h[i] >> x[i] >> y[i];\n  \n      zimu.push_back(vvi(h[i],vi(w[i])));\n\n      for(int j=0; j<h[i]; j++)\n\tfor(int k=0; k<w[i]; k++)\n\t  cin >> zimu[i][j][k];\n    }\n\n    // \n    vector<vector<pair<int,int> > > list(2); // ???????????¨?±???°???????¨???¬??????\n    \n    for(int i=0; i<2; i++){\n      list[i].push_back(pii(0,0));\n      vvi used(h[i],vi(w[i],0));\n      dfs(i, x[i]-1, y[i]-1, used, list[i]);\n    }\n\n    int ans = 1e+9;\n    for(int i=0; i<list[0].size(); i++){\n      int rooma = list[0][i].first;\n      int autha = list[0][i].second;\n      pii tmp = *lower_bound(list[1].begin(),list[1].end(), pii(R-rooma,0));\n      int roomb = tmp.first;\n      int authb = tmp.second;\n      if(rooma + roomb < R) continue;\n      ans = min(ans,autha + authb);\n    }\n    cout << ans << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\n\nconst int INF=100000000;\nconst long long int INF_=1000000000000000000;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nbool IsIn(int y,int x,int h,int w){\n\treturn 0<=y&&y<h&&0<=x&&x<w;\n}\n\nvoid BFS(vector<vector<int> > &f,vector<vector<int> > &l,int sy,int sx,int h,int w){\n\tvector<vector<int> > done(h,vector<int>(w));\n\tl[sy][sx]=1;\n\tdone[sy][sx]=1;\n\tqueue<Pi> que;\n\tREP(i,0,4){\n\t\tint ny=sy+dy[i],nx=sx+dx[i];\n\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\tque.push(Pi(ny,nx));\n\t}\n\twhile(!que.empty()){\n\t\tPi p=que.front();\n\t\tque.pop();\n\t\tdone[p.F_][p.S_]=1;\n\t\tbool flag=true;\n\t\tint tmp=INF;\n\t\tREP(i,0,4){\n\t\t\tint ny=p.F_+dy[i],nx=p.S_+dx[i];\n\t\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\t\ttmp=min(tmp,l[ny][nx]);\n\t\t\tif(done[ny][nx]==1&&l[ny][nx]>=f[p.F_][p.S_]) flag=false;\n\t\t\tif(done[ny][nx]!=1) que.push(Pi(ny,nx));\n\t\t}\n\t\tif(flag) l[p.F_][p.S_]=f[p.F_][p.S_];\n\t\telse l[p.F_][p.S_]=tmp;\n\t}\n}\n\nvoid solve(){\n\tint R;\n\twhile(cin >> R&&R){\n\t\tint W[2],H[2],X[2],Y[2];\n\t\tvector<vector<int> > field[2];\n\t\tvector<vector<int> > level[2];\n\t\tint _max=0;\n\t\tREP(i,0,2){\n\t\t\tcin >> W[i] >> H[i] >> X[i] >> Y[i];\n\t\t\t--X[i]; --Y[i];\n\t\t\tfield[i].resize(H[i]);\n\t\t\tlevel[i].resize(H[i]);\n\t\t\tREP(j,0,H[i]){\n\t\t\t\tfield[i][j].resize(W[i]);\n\t\t\t\tlevel[i][j].resize(W[i]);\n\t\t\t}\n\t\t\tREP(y,0,H[i]) REP(x,0,W[i]){\n\t\t\t\tcin >> field[i][y][x];\n\t\t\t\t_max=max(_max,field[i][y][x]);\n\t\t\t}\n\t\t\tBFS(field[i],level[i],Y[i],X[i],H[i],W[i]);\n\t\t\t/*\n\t\t\tcout << endl << endl;\n\t\t\tREP(y,0,H[i]){\n\t\t\t\tREP(x,0,W[i]) cout << level[i][y][x] << ' ';\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t\tvector<int> count[2],s[2];\n\t\tREP(i,0,2){\n\t\t\tcount[i].resize(_max+1);\n\t\t\ts[i].resize(_max+1);\n\t\t}\n\t\tREP(i,0,2) REP(y,0,H[i]) REP(x,0,W[i]) ++count[i][level[i][y][x]];\n\t\tREP(i,0,2) REP(j,1,_max+1) s[i][j]=s[i][j-1]+count[i][j];\n\t\tint result=INF;\n\t\tfor(int i=0; i<=_max&&i<=result; ++i){\n\t\t\t//cout << i << ' ' << s[0][i] << ' ' <<  (int)(lower_bound(s[1].begin(),s[1].end(),R-s[0][i])-s[1].begin()) << ' ' << s[1][(int)(lower_bound(s[1].begin(),s[1].end(),R-s[0][i])-s[1].begin())] << endl;\n\t\t\tint idx=(int)(lower_bound(s[1].begin(),s[1].end(),R-s[0][i])-s[1].begin());\n\t\t\tif(!(0<=idx&&idx<=_max)) continue;\n\t\t\tresult=min(result,i+idx);\n\t\t}\n\t\tcout << result << endl;\n\t}\n}\n\nint main(){\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n  \ntemplate<typename T1, typename T2> istream& operator>>(istream& is, pair<T1,T2>& a){ return is >> a.first >> a.second; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, pair<T1,T2>& a){ return os << a.first << \" \" << a.second; }\ntemplate<typename T> istream& operator>>(istream& is, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) is >> vc[i]; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) os << vc[i] << endl; return os; }\n  \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n \ntypedef long long int64;\ntypedef pair< int , int > Pi;\ntypedef pair< int , Pi > Pii;\nconst int INF = 1 << 30;\n \nint main()\n{\n  int R, W[2], H[2], X, Y, L[500][500];\n  int min_cost[500][500], limit[2][500 * 500 + 1];\n \n  static const signed dy[] = { 0, 1, 0, -1}, dx[] = { 1, 0, -1, 0};\n \n  while(scanf(\"%d\", &R), R){\n    map< int, int > level[2];\n    for(int i = 0; i < 2; i++){\n      scanf(\"%d %d %d %d\", &W[i], &H[i], &X, &Y);\n      --X, --Y;\n      for(int j = 0; j < H[i]; j++){\n        for(int k = 0; k < W[i]; k++){\n          scanf(\"%d\", &L[j][k]);\n        }\n      }\n      priority_queue< Pii, vector< Pii >, greater< Pii > > que;\n      fill_n( *min_cost, 500 * 500, INF);\n      que.push( Pii( L[Y][X], make_pair( X, Y)));\n      min_cost[X][Y] = L[Y][X];\n      level[i][min_cost[X][Y]]++;\n      while(!que.empty()){\n        Pii p = que.top(); que.pop();\n        if(p.first > min_cost[p.second.first][p.second.second]) continue;\n        for(int j = 0; j < 4; j++){\n          int nx = p.second.first + dx[j], ny = p.second.second + dy[j];\n          if(nx < 0 || nx >= W[i] || ny < 0 || ny >= H[i]) continue;\n          if(max( L[ny][nx], p.first) >= min_cost[nx][ny]) continue;\n          min_cost[nx][ny] = max( L[ny][nx], p.first);\n          que.push( Pii( max( L[ny][nx], p.first), make_pair( nx, ny)));\n          level[i][min_cost[nx][ny]]++;\n        }\n      }\n \n      int sz = 0;\n      fill_n( limit[i], H[i] * W[i], 0);\n      ForEach(it, level[i]){\n        sz += it -> second;\n        limit[i][sz] = it -> first;\n      }\n      for(int j = H[i] * W[i] - 1; j > 0; j--){\n        if(limit[i][j] == 0) limit[i][j] = limit[i][j + 1];\n      }\n    }\n \n    int ret = INF, end = min( H[0] * W[0], R);\n    for(int i = 0; i <= end; i++){\n      int nokori = R - i;\n      if(nokori < 0 || nokori > W[1] * H[1]) continue;\n      ret = min( ret, limit[0][i] + limit[1][nokori]);\n    }\n    printf(\"%d\\n\", ret);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\nlli d[505][505];\nint gone[505][505];\n\nlli ds[2][100005];\n\nint dy[4]={1,0,-1,0};\nint dx[4]={0,-1,0,1};\n\ntypedef pair<lli,pair<int,int> > mmp;\nint main(void){\n\tfor(;;){\n\t\tmemset(ds,-1,sizeof(ds));\n\t\tlli R;\n\t\tscanf(\"%lld\",&R);\n\t\tif(R==0)break;\n\t\trep(k,2){\n\t\t\tint h,w,sy,sx;\n\t\t\tscanf(\"%d%d%d%d\",&w,&h,&sx,&sy); sy--; sx--;\n\t\t\trep(y,h)rep(x,w){\n\t\t\t\tscanf(\"%lld\",&d[y][x]);\n\t\t\t}\n\t\t\tmemset(gone,0,sizeof(gone));\n\t\t\tlli nc=0;\n\t\t\tint s=0;\n\t\t\tint ms=0;\n\t\t\tpriority_queue<mmp,vector<mmp>,greater<mmp> > que;\n\t\t\tque.push(mmp(d[sy][sx],mp(sy,sx)));\n\t\t\tque.push(mmp(LINF,mp(-1,-1)));\n\t\t\tgone[sy][sx]=1;\n\t\t\twhile(!que.empty()){\n\t\t\t\tmmp pa = que.top();\n\t\t\t\tque.pop();\n\t\t\t\t//printf(\"%lld\\n\",pa.fir);\n\t\t\t\tif(pa.fir > nc){\n\t\t\t\t\treg(t,ms,s){\n\t\t\t\t\t\tds[k][t]=nc;\n\t\t\t\t\t\t//printf(\"%d %d : %lld\\n\",k,t,nc);\n\t\t\t\t\t}\n\t\t\t\t\t//printf(\"%d : %d->%d : %lld\\n\",k,ms,s,nc);\n\t\t\t\t\tnc = pa.fir;\n\t\t\t\t\tms = s+1;\n\t\t\t\t}\n\t\t\t\ts += 1;\n\t\t\t\tint y = pa.sec.fir,x = pa.sec.sec;\n\t\t\t\tif(y<0)break;\n\t\t\t\trep(t,4){\n\t\t\t\t\tint ty=y+dy[t],tx = x+dx[t];\n\t\t\t\t\tif(ty<0 || ty>=h || tx<0 || tx>=w || gone[ty][tx])continue;\n\t\t\t\t\tgone[ty][tx]=1;\n\t\t\t\t\tque.push(mmp(d[ty][tx],mp(ty,tx)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tlli ans = LINF;\n\t\treg(i,0,R){\n\t\t\tlli a=ds[0][i],b=ds[1][R-i];\n\t\t\t//printf(\"%d : %d %d\\n\",i,a,b);\n\t\t\tif(a<0 || b<0)continue;\n\t\t\tans=min(ans,a+b);\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <climits>\n#include <vector>\n#include <functional>\n#include <algorithm>\n#include <map>\n#include <queue>\n#define inf INT_MAX/2\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nint dx[4]={0,0,-1,1};\nint dy[4]={-1,1,0,0};\nstruct office {\n    int minl[100001], w, h, is, js, maps[500][500];\n    bool used[500][500];\n    office () {}\n    office (int w, int h, int is, int js) : w(w), h(h), is(is), js(js) {\n        for (int i=0; i<h; i++) for (int j=0; j<w; j++) {\n            used[i][j]=false;\n        }\n    }\n    void calc(int r) {\n        fill(minl, minl+(r+1), inf);\n        if (maps[is][js]==0) return;\n        minl[0]=0;\n        draw(r);\n    }\n    bool isin(int x, int y) {\n        return x>=0&&x<h&&y>=0&&y<w;\n    }\n    void draw(int r) {\n        priority_queue<PP, vector<PP>, greater<PP> > que;\n        que.push(make_pair(1,P(is,js)));\n        int l=1, cnt=0;\n        used[is][js]=true;\n        while (!que.empty()) {\n            PP p=que.top(); que.pop();\n            l=max(l, p.first);\n            int x=p.second.first, y=p.second.second;\n            cnt++;\n            if (cnt>=r) minl[r]=min(minl[r], l);\n            else minl[cnt]=min(minl[cnt], l);\n            for (int i=0; i<4; i++) {\n                int nx=x+dx[i], ny=y+dy[i];\n                if (isin(nx,ny)&&!used[nx][ny]) {\n                    que.push(make_pair(maps[nx][ny],P(nx,ny)));\n                    used[nx][ny]=true;\n                }\n            }\n       }\n    }\n};\nint main() {\n    int r;\n    while (scanf(\"%d\",&r)) {\n        if (!r) break;\n        office o1, o2;\n        int w, h, x, y;\n        scanf(\"%d%d%d%d\",&w,&h,&x,&y);\n        o1=office(w,h,y-1,x-1);\n        for (int i=0; i<h; i++) for (int j=0; j<w; j++) {\n            scanf(\"%d\",&o1.maps[i][j]);\n        }\n        scanf(\"%d%d%d%d\",&w,&h,&x,&y);\n        o2=office(w,h,y-1,x-1);\n        for (int i=0; i<h; i++) for (int j=0; j<w; j++) {\n            scanf(\"%d\",&o2.maps[i][j]);\n        }\n        o1.calc(r); o2.calc(r);\n        int res=inf;\n        for (int i=r; i>=0; i--) {\n            res=min(res, o1.minl[i]+o2.minl[r-i]);\n        }\n        printf(\"%d\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> plli;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst ll mod = 1e9 + 7;\nconst ll INF = 1<<30;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\nint r;\nint w1, h1, x1, y1;\nint w2, h2, x2, y2;\nint g1[505][505], g2[505][505];\n\nbool check(int y, int x, int h, int w) {\n    if ((0 <= y && y < h) && (0 <= x && x < w)) return true;\n    return false;\n}\n\nvector<int> search(int sy, int sx, int h, int w, int g[505][505]) {\n    priority_queue<pipii, vector<pipii>, greater<pipii>> pq;\n    pq.push(make_pair(1LL, make_pair(sy, sx)));\n    bool visited[h + 5][w + 5]={};\n    vector<int> cnt;\n    cnt.pb(0);\n    int now_level = 1;\n    visited[sy][sx] = true;\n    while (!pq.empty()) {\n        pipii p = pq.top();\n        pq.pop();\n        int level = p.fi;\n        int y = p.se.fi;\n        int x = p.se.se;\n        if (now_level < level) {\n            cnt.pb(level);\n            now_level = level;\n        }\n        else {\n            cnt.pb(now_level);\n        }\n        rep(i, 4) {\n            int ny = y + dy4[i];\n            int nx = x + dx4[i];\n            if (!check(ny, nx, h, w) || visited[ny][nx]) continue;\n            pq.push(make_pair(g[ny][nx], make_pair(ny, nx)));\n            visited[ny][nx] = true;\n        }\n    }\n    return cnt;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> r;\n    while (r != 0) {\n        cin >> w1 >> h1 >> x1 >> y1;\n        x1--;y1--;\n        rep(i, h1)rep(j, w1) cin >> g1[i][j];\n        cin >> w2 >> h2 >> x2 >> y2;\n        x2--;y2--;\n        rep(i, h2)rep(j, w2) cin >> g2[i][j];\n        vector<int> cnt1 = search(y1, x1, h1, w1, g1);\n        vector<int> cnt2 = search(y2, x2, h2, w2, g2);\n        int ans = 1e12;\n        rep(i, r + 1) {\n            if (cnt1.size() <= i) break;\n            if (cnt2.size() <= r - i) continue;\n            ans = min(ans, cnt1[i] + cnt2[r - i]);\n        }\n        cout << ans << endl;\n        cin >> r;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <tuple>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nvector<int> bfs(const vector<vector<int>>& t, int si, int sj, int h, int w) {\n  queue<tuple<int,int,int>> q;\n  q.push(make_tuple(si,sj,t[si][sj]));\n  vector<vector<int>> mc(h,vector<int>(w,1000000000));\n  mc[si][sj] = t[si][sj];\n  while(!q.empty()){\n    int i,j,c;\n    tie(i,j,c) = q.front();q.pop();\n    if (c > mc[i][j]) continue;\n    int di[]={1,0,-1,0};\n    int dj[]={0,1,0,-1};\n    REP(k,4){\n      int ni=i+di[k];\n      int nj=j+dj[k];\n      if(ni<0||ni>=h||nj<0||nj>=w)continue;\n      if(mc[ni][nj] > max(t[ni][nj], mc[i][j])) {\n        mc[ni][nj] = max(t[ni][nj], mc[i][j]);\n        q.push(make_tuple(ni,nj,mc[ni][nj]));\n      }\n    }\n  }\n  vector<int> ans;\n  REP(i,h)REP(j,w)ans.push_back(mc[i][j]);\n  return ans;\n}\n\nint main() {\n  while(1){\n    int r;\n    cin>>r;\n    if(!r)break;\n    int w[2],h[2],x[2],y[2];\n    vector<vector<vector<int>>> t(2);\n    vector<vector<int>> ans(2);\n    REP(i,2){\n      cin>>w[i]>>h[i]>>x[i]>>y[i];\n      --x[i];--y[i];\n      t[i] = vector<vector<int>>(h[i],vector<int>(w[i]));\n      REP(j,h[i])\n        REP(k,w[i])\n          cin>>t[i][j][k];\n      ans[i] = bfs(t[i],y[i],x[i],h[i],w[i]);\n    }\n    REP(i,2)\n      sort(begin(ans[i]),end(ans[i]));\n    int mn = 1000000000;\n    if (w[0]*h[0] >= r)\n      mn = min(mn, ans[0][r-1]);\n    if (w[1]*h[1] >= r)\n      mn = min(mn, ans[1][r-1]);\n    REP(i,min(r-1,w[1]*h[1])){\n      int l1 = ans[1][i];\n      int l2 = ans[0][r-i-2];\n      mn = min(l1 + l2, mn);\n    }\n    cout << mn << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <climits>\n#include <vector>\n#include <functional>\n#include <algorithm>\n#include <map>\n#include <queue>\n#define inf INT_MAX/2\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nint dx[4]={0,0,-1,1};\nint dy[4]={-1,1,0,0};\nstruct office {\n    int minl[100001], w, h, is, js, maps[500][500];\n    bool used[500][500];\n    office () {}\n    office (int w, int h, int is, int js) : w(w), h(h), is(is), js(js) {\n        for (int i=0; i<h; i++) for (int j=0; j<w; j++) {\n            used[i][j]=false;\n        }\n    }\n    void calc(int r) {\n        fill(minl, minl+(r+1), inf);\n        if (maps[is][js]==0) return;\n        minl[0]=0;\n        draw(r);\n        for (int i=r-1; i>=0; i--) {\n            minl[i]=min(minl[i], minl[i+1]);\n//            printf(\"%d %d\\n\",i,minl[i]);\n        }\n    }\n    bool isin(int x, int y) {\n        return x>=0&&x<h&&y>=0&&y<w;\n    }\n    void draw(int r) {\n        priority_queue<PP, vector<PP>, greater<PP> > que;\n        que.push(make_pair(1,P(is,js)));\n        int l=1, cnt=0;\n        used[is][js]=true;\n        while (!que.empty()) {\n            PP p=que.top(); que.pop();\n            l=max(l, p.first);\n            int x=p.second.first, y=p.second.second;\n            cnt++;\n            if (cnt>=r) minl[r]=min(minl[r], l);\n            else minl[cnt]=min(minl[cnt], l);\n            for (int i=0; i<4; i++) {\n                int nx=x+dx[i], ny=y+dy[i];\n                if (isin(nx,ny)&&!used[nx][ny]) {\n                    que.push(make_pair(maps[nx][ny],P(nx,ny)));\n                    used[nx][ny]=true;\n                }\n            }\n       }\n    }\n};\nint main() {\n    int r;\n    while (scanf(\"%d\",&r)) {\n        if (!r) break;\n        office o1, o2;\n        int w, h, x, y;\n        scanf(\"%d%d%d%d\",&w,&h,&x,&y);\n        o1=office(w,h,y-1,x-1);\n        for (int i=0; i<h; i++) for (int j=0; j<w; j++) {\n            scanf(\"%d\",&o1.maps[i][j]);\n        }\n        scanf(\"%d%d%d%d\",&w,&h,&x,&y);\n        o2=office(w,h,y-1,x-1);\n        for (int i=0; i<h; i++) for (int j=0; j<w; j++) {\n            scanf(\"%d\",&o2.maps[i][j]);\n        }\n        o1.calc(r); o2.calc(r);\n        int res=inf;\n        for (int i=r; i>=0; i--) {\n            res=min(res, o1.minl[i]+o2.minl[r-i]);\n        }\n        printf(\"%d\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define PB push_back\n#define ALL(V) V.begin(), V.end()\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, int> ppiii;\n\nconstexpr int INF = 1LL<<60;\nconstexpr int MOD = 1000000007;\n//constexpr int MAX_N = 100005;\nconstexpr int dx[] = {-1, 0, 1, 0};\nconstexpr int dy[] = {0, -1, 0, 1};\n\nint r, w[2], h[2], ex[2], ey[2], fld[2][505][505], d[2][505][505];\n\nvector<pii> lvs[2];\nvector<int> templvs[2];\n\nvoid Dijkstra(int k) {\n    fill(d[k][0], d[k][505], INF);\n    priority_queue<pipii, vector<pipii>, greater<pipii>> pq;\n    d[k][ex[k]][ey[k]] = 1;\n    pq.push({1, {ex[k], ey[k]}});\n\n    while (pq.size()) {\n        pipii p = pq.top();\n        pq.pop();\n        int x = p.second.first, y = p.second.second;\n        if (d[k][x][y] < p.first) continue;\n\n        for (int i = 0; i < 4; ++i) {\n            int tx = x + dx[i], ty = y + dy[i], lv = max(p.first, fld[k][tx][ty]);\n            if (fld[k][tx][ty] == 0) continue;\n            if (d[k][tx][ty] <= lv) continue;\n            d[k][tx][ty] = lv;\n            pq.push({lv, {tx, ty}});\n        }\n    }\n}\n\nbool Solve() {\n    cin >> r;\n    if (r == 0) return false;\n    memset(fld, 0, sizeof(fld));\n\n    for (int i = 0; i < 2; ++i) {\n        cin >> w[i] >> h[i] >> ex[i] >> ey[i]; \n\n        for (int y = 1; y <= h[i]; ++y) {\n            for (int x = 1; x <= w[i]; ++x) {\n                cin >> fld[i][x][y];\n            }\n        }\n    }\n\n    Dijkstra(0);\n    Dijkstra(1);\n\n    for (int i = 0; i < 2; ++i) {\n        lvs[i].clear();\n        templvs[i].clear();\n\n        for (int y = 1; y <= h[i]; ++y) {\n            for (int x = 1; x <= w[i]; ++x) {\n                templvs[i].PB(d[i][x][y]);\n            }\n        }\n\n        sort(ALL(templvs[i]));\n        templvs[i].PB({INF});\n        lvs[i].PB({0, 0});\n        for (int j = 0; j < templvs[i].size(); ++j) {\n            for (int c = 1; j + c <= templvs[i].size(); ++c) {\n                if (templvs[i][j + c - 1] == templvs[i][j]) continue;\n                c--;\n                lvs[i].PB({templvs[i][j], c + lvs[i][lvs[i].size() - 1].second});\n                j += c - 1;\n                break;\n            }\n        }\n\n    }\n\n    int ans = INF;\n    for (int i = 0; i < lvs[0].size(); ++i) {\n        int cnt = lvs[0][i].second;\n        if (cnt + w[1] * h[1] < r) continue;\n\n        int s = 0, t = lvs[1].size();\n        while (1 < t - s) {\n            int mid = (s + t) / 2;\n            if (cnt + lvs[1][mid].second < r) {\n                s = mid + 1;\n            } else {\n                t = mid;\n            }\n        }\n        ans = min(ans, lvs[0][i].first + lvs[1][s].first);\n    }\n\n    cout << ans << endl;\n\n    return true;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while(Solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf=1<<30;\nint maps[2][510][510];\nbool visited[2][510][510];\nint cnt[2][100010];\nint w[2],h[2],sx[2],sy[2];\nconst int dx[]={1,-1,0,0},dy[]={0,0,1,-1};\nvoid calc(){\n\tfor(int k=0;k<2;k++){\n\t\tint room=0,level=0;\n\t\tpriority_queue<tuple<int,int,int>> pq;\n\t\tfor(int i=0;i<=h[k];i++)\tvisited[k][i][0]=visited[k][i][w[k]+1]=true;\n\t\tfor(int i=0;i<=w[k];i++)\tvisited[k][0][i]=visited[k][h[k]+1][i]=true;\n\t\tpq.push(make_tuple(-1,sx[k],sy[k]));\n\t\twhile(!pq.empty()){\n\t\t\tauto now=pq.top();\tpq.pop();\n\t\t\tint l=-get<0>(now),x=get<1>(now),y=get<2>(now);\n\t\t\tif(visited[k][y][x])\tcontinue;\n\t\t\tvisited[k][y][x]=true;\n\t\t\tif(level<l)\tlevel=l;\n\t\t\troom++;\tcnt[k][room]=level;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint ny=y+dy[i],nx=x+dx[i];\n\t\t\t\tif(visited[k][ny][nx])\tcontinue;\n\t\t\t\tpq.push(make_tuple(-maps[k][ny][nx],nx,ny));\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile(true){\n\t\tint r;\tcin>>r;\n\t\tif(r==0)\treturn 0;\n\t\tmemset(maps,0,sizeof(maps));\n\t\tfor(int k=0;k<2;k++){\n\t\t\tfor(int i=1;i<100010;i++) cnt[k][i]=inf;\n\t\t\tcnt[k][0]=0;\n\t\t\tfor(int i=0;i<510;i++){\n\t\t\t\tfor(int j=0;j<510;j++)\tvisited[k][i][j]=false;\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<2;k++){\n\t\t\tcin>>w[k]>>h[k]>>sx[k]>>sy[k];\n\t\t\tfor(int i=1;i<=h[k];i++){//区画の外側を壁で覆う\n\t\t\t\tfor(int j=1;j<=w[k];j++)\tcin>>maps[k][i][j];\n\t\t\t}\n\t\t}\n\t\tcalc();\n\t\tfor(int k=0;k<2;k++){\n\t\t\tint tmp=inf;\n\t\t\tfor(int i=w[k]*h[k];i>=0;i--){\n\t\t\t\ttmp=min(tmp,cnt[k][i]);\n\t\t\t\tcnt[k][i]=tmp;\n\t\t\t}\n\t\t}\n\t\tint ans=inf;\n\t\tfor(int i=0;i<=r;i++){\n\t\t\tif(i>h[0]*w[0]||r-i>h[1]*w[1])\tcontinue;\n\t\t\tans=min(ans,cnt[0][i]+cnt[1][r-i]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\n\nint calc_required_level_to_rooms(int* res)\n{\n\tint w, h, sx, sy;\n\tstatic int req[512][512];\n\tcin >> w >> h >> sx >> sy;\n\t--sx, --sy;\n\tfor (int y = 0; y < h; ++y)\n\t\tfor (int x = 0; x < w; ++x)\n\t\t\tcin >> req[y][x];\n\n\tstatic bool visit[512][512];\n\tfor (int y = 0; y < h; ++y)\n\t\tfor (int x = 0; x < w; ++x)\n\t\t\tvisit[y][x] = false;\n\n\tint c = 0;\n\tres[c++] = 0;\n\n\ttypedef pair<int, pint> P;\n\tpriority_queue<P, vector<P>, greater<P> > q;\n\tq.push(P(1, pint(sx, sy)));\n\twhile (c <= w * h)\n\t{\n\t\tP tt = q.top(); q.pop();\n\t\tint level = tt.first;\n\t\tint x = tt.second.first, y = tt.second.second;\n\t\tif (visit[y][x])\n\t\t\tcontinue;\n\n\t\tvisit[y][x] = true;\n\t\tres[c++] = level;\n\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\t\tif (valid_pos(tx, ty, w, h) && !visit[ty][tx])\n\t\t\t\tq.push(P(max(level, req[ty][tx]), pint(tx, ty)));\n\t\t}\n\t}\n\treturn w * h;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tint r;\n\twhile (cin >> r, r)\n\t{\n\t\tstatic int a[512 * 512], b[512 * 512];\n\t\tint a_size = calc_required_level_to_rooms(a);\n\t\tint b_size = calc_required_level_to_rooms(b);\n\n\t\tint res = 1e9;\n\t\tfor (int i = min<int>(r, a_size); i >= 0 && r - i <= b_size; --i)\n\t\t\tmin_swap(res, a[i] + b[r - i]);\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef pair<int,pi> edge;\n\nstruct UF{\n    int n;\n    //??£?????£????????????????????????,????????£???????????§??£?????????????????°\n    vector<int> d;\n    UF() {}\n    UF(int N):n(N), d(N,-1){}\n    int root(int v){\n        if(d[v]<0) return v;\n        return d[v]=root(d[v]);\n    }\n    bool unite(int X,int Y){\n        X=root(X); Y=root(Y);\n        if(X==Y) return false;\n        if(size(X) < size(Y)) swap(X,Y);\n        d[X]+=d[Y];\n        d[Y]=X;\n        return true;\n    }\n    int size(int v){ return -d[root(v)]; }\n    bool same(int X,int Y){ return root(X)==root(Y); }\n};\n\nconst int INF=123456789;\nconst int N=250000;\nint dp[2][N+1];\n\nint main()\n{\n    int R;\n    while(scanf(\" %d\", &R),R)\n    {\n        fill(dp[0],dp[2],INF);\n\n        rep(room,2)\n        {\n            int W,H,X,Y;\n            scanf(\" %d %d %d %d\", &W, &H, &X, &Y);\n            --X;\n            --Y;\n\n            vector<vi> f(H,vi(W));\n            rep(i,H)rep(j,W) scanf(\" %d\", &f[i][j]);\n\n            #define NUM(x,y) (y*W+x)\n            #define IN(x,y) (0<=x && x<W && 0<=y && y<H)\n            int dx[4]={1,-1,0,0}, dy[4]={0,0,1,-1};\n            vector<edge> e;\n            rep(i,H)rep(j,W)\n            {\n                int u = NUM(j,i);\n                rep(k,4)\n                {\n                    int nx=j+dx[k], ny=i+dy[k];\n                    if(IN(nx,ny))\n                    {\n                        int v = NUM(nx,ny);\n                        int cost = max(f[i][j], f[ny][nx]);\n                        e.pb(edge(cost,pi(u,v)));\n                    }\n                }\n            }\n            sort(all(e));\n\n            dp[room][0] = 0;\n            dp[room][1] = 1;\n            UF uf(H*W);\n            rep(i,e.size())\n            {\n                int cost = e[i].fi;\n                int u = e[i].se.fi, v = e[i].se.se;\n                uf.unite(u,v);\n\n                int SZ = uf.size(NUM(X,Y));\n                dp[room][SZ] = min(dp[room][SZ],cost);\n            }\n\n            for(int i=N; i>0; --i) dp[room][i-1] = min(dp[room][i-1], dp[room][i]);\n        }\n\n        int ans = 2*INF;\n        rep(i,R+1) ans = min(ans, dp[0][i]+dp[1][R-i]);\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst int INF = 1 << 24;\nconst int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};\n\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nint R, W[2], H[2], X[2], Y[2];\nint Room[2][500][500];\nstd::vector<int> L[2]; // 事務所ごとの存在するレベル\nint maxR[2][250001]; // maxR[i][j]: 事務所iでj番目に小さいレベルで行ける部屋の数\nint used[500][500];\n\nvoid travel(int r){\n    REP(j, H[r]){\n        REP(k, W[r]){\n            used[j][k] = 0;\n        }\n    }\n    \n    std::priority_queue<State, std::vector<State>, std::greater<State>> q;\n    q.push(mp(1, mp(X[r], Y[r])));\n    used[Y[r]][X[r]] = 1;\n    maxR[r][1] = 1;\n\n    while(!q.empty()){\n        State s = q.top(); q.pop();\n        int l = s.first;\n        P p = s.second;\n        int x = p.first, y = p.second;\n\n        // std::cout << x << \",\" << y << \",\" << l << std::endl;\n\n        REP(i, 4){\n            int nx = x + dx[i], ny = y + dy[i];\n            if(0 <= nx && nx < W[r] && 0 <= ny && ny < H[r] && !used[ny][nx]){\n\n                int nl = std::max(l, Room[r][ny][nx]),\n                    nl_index = std::distance(L[r].begin(), std::find(L[r].begin(), L[r].end(), nl));\n\n                q.push(mp(nl, mp(nx, ny)));\n                used[ny][nx] = 1;\n                maxR[r][nl_index]++;\n            }\n        }\n    }\n}\n\nint main(){\n    while(std::cin >> R, R){\n        REP(i, 2){\n            std::cin >> W[i] >> H[i] >> X[i] >> Y[i];\n            X[i]--; Y[i]--;\n\n            L[i].push_back(0);\n            REP(j, H[i]){\n                REP(k, W[i]){\n                    std::cin >> Room[i][j][k];\n                    L[i].push_back(Room[i][j][k]);\n                }\n            }\n\n            std::sort(L[i].begin(), L[i].end());\n        }\n\n        REP(i, 2){\n            REP(j, L[i].size()){\n                maxR[i][j] = 0;\n            }\n        }\n\n        REP(i, 2){\n            travel(i);\n        }\n\n        REP(i, 2){\n            //std::cout << maxR[i][0] << std::endl;\n            FOR(j, 1, L[i].size()){\n                maxR[i][j] += maxR[i][j-1];\n                // std::cout << maxR[i][j] << std::endl;\n            }\n            // puts(\"##############################\");\n        }\n\n        int res = INF;\n        REP(i, L[0].size()){\n            int r1 = maxR[0][i],\n                r2_index = std::lower_bound(maxR[1], maxR[1]+L[1].size(), R-r1) - maxR[1];\n        \n            if(r2_index == L[1].size()){\n                continue;\n            }\n\n            res = std::min(res, L[0][i] + L[1][r2_index]);\n        }\n\n        std::cout << res << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nll c[2501];\nll b[501][501];\nstruct A {\n\tll ko, level;\n};\nA a[2][2501];\nll u[501][501];\nstruct P {\n\tll x, y, level;\n};\nll d[2];\nbool operator<(P a, P b) { return a.level < b.level; }\nbool operator>(P a, P b) { return a.level > b.level; }\nconst ll inf = 800000000000000000;\nint main() {\n\tll r;\n\tint lp[4][2] = { {1,0},{-1,0},{0,1},{0,-1} };\n\twhile (cin >> r&&r != 0) {\n\t\tfor (int z = 0; z < 2; z++) {\n\t\t\tll h, w, x, y;\n\t\t\tcin >> w >> h >> y >> x;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tqueue<P>p;\n\t\t\tfor (ll i = 0; i < h; i++) {\n\t\t\t\tfor (ll j = 0; j < w; j++) {\n\t\t\t\t\tcin >> u[i][j];\n\t\t\t\t\tb[i][j] = inf;\n\t\t\t\t}\n\t\t\t}\n\t\t\tp.push(P{ x,y,1 });\n\t\t\tb[x][y] = 1;\n\t\t\twhile (!p.empty()) {\n\t\t\t\tP t = p.front(); p.pop();\n\t\t\t\tll x = t.x, y = t.y;\n\t\t\t\tif (t.level == b[x][y]) {\n\t\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\t\tll x2 = x + lp[i][0], y2 = y + lp[i][1];\n\t\t\t\t\t\tif (b[x2][y2] > t.level) {\n\t\t\t\t\t\t\tif (u[x2][y2] <= t.level) {\n\t\t\t\t\t\t\t\tb[x2][y2] = t.level;\n\t\t\t\t\t\t\t\tp.push(P{ x2,y2,t.level });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (u[x2][y2] < b[x2][y2]) {\n\t\t\t\t\t\t\t\t\tb[x2][y2] = u[x2][y2];\n\t\t\t\t\t\t\t\t\tp.push(P{ x2,y2,u[x2][y2] });\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tll o = 0;\n\t\t\tfor (ll i = 0; i < h; i++) {\n\t\t\t\tfor (ll j = 0; j < w; j++) {\n\t\t\t\t\tc[o] = b[i][j];\n\t\t\t\t\to++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(c, c + o);\n\t\t\tll sum = 0, g = 1;\n\t\t\ta[z][0] = A{ 0,0 };\n\t\t\tfor (ll i = 0; i < (h*w);) {\n\t\t\t\tll k = c[i], sum2 = 0;\n\t\t\t\twhile (i < (h*w) && c[i] == k) {\n\t\t\t\t\tsum2++;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\ta[z][g] = A{ sum2 + sum,k };\n\t\t\t\tg++;\n\t\t\t\tsum += sum2;\n\t\t\t}\n\t\t\td[z] = g;\n\t\t}\n\t\tll sum = inf;\n\t\tfor (ll i = 0; i < d[0]; i++) {\n\t\t\tll s = 0, e = d[1] - 1, t, m = r - a[0][i].ko;\n\t\t\twhile (e - s > 1) {\n\t\t\t\tt = (e + s) / 2;\n\t\t\t\tif (a[1][t].ko <= m)\n\t\t\t\t\ts = t;\n\t\t\t\tif (a[1][t].ko >= m)\n\t\t\t\t\te = t;\n\t\t\t}\n\t\t\tif (a[0][i].ko + a[1][s].ko >= r)\n\t\t\t\tsum = min(sum, a[0][i].level + a[1][s].level);\n\t\t\tif (a[0][i].ko + a[1][e].ko >= r)\n\t\t\t\tsum = min(sum, a[0][i].level + a[1][e].level);\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst int INF = 1 << 30;\nconst int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};\n\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nint R, W[2], H[2], X[2], Y[2];\nint Room[2][500][500];\nstd::vector<int> L[2]; // 事務所ごとの存在するレベル\nint maxR[2][250001]; // maxR[i][j]: 事務所iでj番目に小さいレベルで行ける部屋の数\nint used[500][500];\n\nvoid travel(int r){\n    REP(j, H[r]){\n        REP(k, W[r]){\n            used[j][k] = 0;\n        }\n    }\n    \n    std::priority_queue<State, std::vector<State>, std::greater<State>> q;\n    q.push(mp(1, mp(X[r], Y[r])));\n    used[Y[r]][X[r]] = 1;\n    maxR[r][1] = 1;\n\n    while(!q.empty()){\n        State s = q.top(); q.pop();\n        int l = s.first;\n        P p = s.second;\n        int x = p.first, y = p.second;\n\n        //std::cout << x << \",\" << y << \",\" << l << std::endl;\n\n        REP(i, 4){\n            int nx = x + dx[i], ny = y + dy[i];\n            if(0 <= nx && nx < W[r] && 0 <= ny && ny < H[r] && !used[ny][nx]){\n\n                int nl = std::max(l, Room[r][ny][nx]),\n                    nl_index = std::distance(L[r].begin(), std::find(L[r].begin(), L[r].end(), nl));\n\n                q.push(mp(nl, mp(nx, ny)));\n                used[ny][nx] = 1;\n                maxR[r][nl_index]++;\n            }\n        }\n    }\n}\n\nint main(){\n    while(std::cin >> R, R){\n        REP(i, 2){\n            std::cin >> W[i] >> H[i] >> X[i] >> Y[i];\n            X[i]--; Y[i]--;\n\n            L[i].push_back(0);\n            REP(j, H[i]){\n                REP(k, W[i]){\n                    std::cin >> Room[i][j][k];\n                    L[i].push_back(Room[i][j][k]);\n                }\n            }\n\n            std::sort(L[i].begin(), L[i].end());\n            L[i].erase(std::unique(L[i].begin(), L[i].end()), L[i].end());\n        }\n\n        REP(i, 2){\n            REP(j, L[i].size()){\n                maxR[i][j] = 0;\n            }\n        }\n\n        REP(i, 2){\n            travel(i);\n        }\n\n        REP(i, 2){\n            //std::cout << maxR[i][0] << std::endl;\n            FOR(j, 1, L[i].size()){\n                maxR[i][j] += maxR[i][j-1];\n                // std::cout << maxR[i][j] << std::endl;\n            }\n            // puts(\"##############################\");\n        }\n\n        int res = INF;\n        REP(i, L[0].size()){\n            int r1 = maxR[0][i],\n                r2_index = std::lower_bound(maxR[1], maxR[1]+L[1].size(), R-r1) - maxR[1];\n        \n            if(r2_index == L[1].size()){\n                continue;\n            }\n\n            res = std::min(res, L[0][i] + L[1][r2_index]);\n        }\n\n        std::cout << res << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pint;\ntypedef pair<ll, int> P;\n//typedef tuple<int,int,int> T;\nll INFL = 1000000000000000010;//10^18 = 2^60\nint INF = 2147483600;//10^9\nll MOD  = 1000000007;\nvector<int> dy(4);\nvector<int> dx(4);\nvector<ll> Ans(0);\nint solve(){\n    int R;\n    cin >> R;\n    if(R == 0)return 0;\n    int H1,W1,X1,Y1;\n    cin >> W1 >> H1 >> X1 >> Y1;\n    X1--;\n    Y1--;\n    vector<vector<ll> > mp1(H1, vector<ll>(W1));\n    vector<vector<ll> > d1(H1, vector<ll>(W1, INFL));\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            cin >> mp1[i][j];\n        }\n    }\n    \n    d1[Y1][X1] = 1;\n    priority_queue<pair<ll, pair<int, int> > > pque1;\n    pque1.push({1, {Y1, X1}});\n    \n    while(!pque1.empty()){\n        ll c;\n        int y,x;\n        c = pque1.top().first;\n        y = pque1.top().second.first;\n        x = pque1.top().second.second;\n        pque1.pop();\n        if(c > d1[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H1 && 0 <= nx && nx < W1){\n                if(d1[ny][nx] > d1[y][x]){\n                    if(d1[y][x] > mp1[ny][nx]){\n                        d1[ny][nx] = d1[y][x];\n                    }else{\n                        d1[ny][nx] = mp1[ny][nx];\n                    }\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }else if(d1[ny][nx] > d1[y][x]){\n                    d1[ny][nx] = mp1[ny][nx];\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    int H2,W2,X2,Y2;\n    cin >> W2 >> H2 >> X2 >> Y2;\n    X2--;\n    Y2--;\n    vector<vector<ll> > mp2(H2, vector<ll>(W2));\n    vector<vector<ll> > d2(H2, vector<ll>(W2, INFL));\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            cin >> mp2[i][j];\n        }\n    }\n    \n    d2[Y2][X2] = 1;\n    priority_queue<pair<ll, pair<int, int> > > pque2;\n    pque2.push({1, {Y2, X2}});\n    \n    while(!pque2.empty()){\n        ll c;\n        int y,x;\n        c = pque2.top().first;\n        y = pque2.top().second.first;\n        x = pque2.top().second.second;\n        pque2.pop();\n        if(c > d2[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H2 && 0 <= nx && nx < W2){\n                if(d2[ny][nx] > d2[y][x]){\n                    if(d2[y][x] > mp2[ny][nx]){\n                        d2[ny][nx] = d2[y][x];\n                    }else{\n                        d2[ny][nx] = mp2[ny][nx];\n                    }\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }else if(d2[ny][nx] > d2[y][x]){\n                    d2[ny][nx] = mp2[ny][nx];\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    vector<pair<ll,int> > O1(0);\n    vector<ll> COST1(0);\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            COST1.push_back(d1[i][j]);\n        }\n    }\n    sort(COST1.begin(), COST1.end());\n    COST1.push_back(INFL);\n    ll ad1 = COST1.at(0);\n    int cnt = 0;\n    for(int i = 0; i < COST1.size(); i++){\n        if(ad1 == COST1.at(i)){\n            cnt++;\n        }else{\n            O1.push_back({ad1, cnt});\n            ad1 = COST1.at(i);\n            cnt++;\n        }\n    }\n    \n    vector<pair<ll,int> > O2(1);\n    O2.at(0).first = 0;\n    O2.at(0).second = 0;\n    vector<ll> COST2(0);\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            COST2.push_back(d2[i][j]);\n        }\n    }\n    sort(COST2.begin(), COST2.end());\n    COST2.push_back(INFL);\n    ll ad2 = COST2.at(0);\n    cnt = 0;\n    for(int i = 0; i < COST2.size(); i++){\n        if(ad2 == COST2.at(i)){\n            cnt++;\n        }else{\n            O2.push_back({ad2, cnt});\n            ad2 = COST2.at(i);\n            cnt++;\n        }\n    }\n    \n    \n    ll ans = INFL;\n    int right = -1;\n    for(int i = 0; i < O1.size(); i++){\n        ll cost = O1.at(i).first;\n        int rest = R - O1.at(i).second;\n        \n        if(rest > O2.at(O2.size()-1).second) continue;\n        int left = -1;\n        if(right == -1){\n            right = O2.size();\n        }\n        int mid;\n        while(right - left > 1){\n            mid = (left + right) / 2;\n            if(O2.at(mid).second >= rest){\n                right = mid;\n            }else{\n                left = mid;\n            }\n        }\n        cost += O2.at(right).first;\n        ans = min(ans, cost);\n    }\n    \n    Ans.push_back(ans);\n    solve();\n    return 0;\n}\n\nint main(void){\n    dy[0] = 1;\n    dy[1] = -1;\n    dx[2] = 1;\n    dx[3] = -1;\n    solve();\n    for(int i = 0; i < Ans.size(); i++){\n        cout << Ans.at(i) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <queue>\n\nusing namespace std;\n\nconst int N = 500;\nconst int INF = 1000000000;\n\nclass S{\npublic:\n  int x, y, cost;\n  S(){}\n  S(int x, int y, int cost) : x(x), y(y), cost(cost) {}\n  bool operator < (const S& s) const {\n    return cost > s.cost;\n  }\n};\n\nint R, w[2], h[2], sx[2], sy[2], input[2][N][N], vis[N][N];\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nvector<int> vec[2];\nset<int> used;\nvector<int> data;\nint cnt;\n\nvoid dfs(int x, int y, int cost, int d){\n  vis[y][x] = true;\n  cnt++;\n  for(int i=0;i<4;i++){\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if(ny < 0 || ny >= h[d]) continue;\n    if(nx < 0 || nx >= w[d]) continue;\n    if(input[d][ny][nx] > cost) continue;\n    if(!vis[ny][nx]) dfs(nx, ny, cost, d);\n  }\n}\n\nvoid bfs(int d){\n  int x = sx[d];\n  int y = sy[d];\n  int cost = 1;\n  priority_queue<S> q;\n  S u;\n  q.push(S(x, y, cost));\n  vis[y][x] = cost;\n  while(!q.empty()){\n    u = q.top(); q.pop();\n    if(vis[u.y][u.x] < u.cost) continue;\n    for(int i=0;i<4;i++){\n      int ny = u.y + dy[i];\n      int nx = u.x + dx[i];\n      if(ny < 0 || ny >= h[d]) continue;\n      if(nx < 0 || nx >= w[d]) continue;\n      int tmp = max(u.cost, input[d][ny][nx]);\n      if(vis[ny][nx] > tmp){\n        vis[ny][nx] = tmp;\n        q.push(S(nx, ny, tmp));\n      }\n    }\n  }\n}\n\nvoid init(){\n  used.clear();\n  data.clear();\n  for(int k=0;k<2;k++){\n    for(int i=0;i<h[k];i++){\n      for(int j=0;j<w[k];j++){\n        if(!used.count(input[k][i][j])){\n          used.insert(input[k][i][j]);\n          data.push_back(input[k][i][j]);\n        }\n      }\n    }\n  }\n  sort(data.begin(), data.end());\n  for(int k=0;k<2;k++){\n    /*int vis2[N][N];\n    fill(vis2[0], vis2[N], INF);\n    set<int>::iterator ite = data.begin();\n    for(;ite!=data.end();ite++){\n      fill(vis[0], vis[N], false);\n      dfs(sx[k], sy[k], *ite, k);      \n      for(int i=0;i<h[k];i++){\n        for(int j=0;j<w[k];j++){\n          if(vis[i][j]) vis2[i][j] = min(vis2[i][j], *ite);\n        }\n      }\n      }*/\n    fill(vis[0], vis[N], INF);\n    bfs(k);\n\n    vec[k].clear();\n    for(int i=0;i<h[k];i++){\n      for(int j=0;j<w[k];j++){\n        //vec[k].push_back(vis2[i][j]);\n        vec[k].push_back(vis[i][j]);\n      }\n    }\n    sort(vec[k].begin(), vec[k].end());\n  }\n}\n\nbool check(int a, int b){\n  int t1 = distance(vec[0].begin(), upper_bound(vec[0].begin(), vec[0].end(), a));\n  int t2 = distance(vec[1].begin(), upper_bound(vec[1].begin(), vec[1].end(), b));\n  return t1 + t2 >= R;\n  /*int sum = 0;\n  for(int i=0;i<2;i++){\n    fill(vis[0], vis[N], false);\n    cnt = 0;\n    int cost = a;\n    if(i == 1) cost = b;\n    if(cost > 0) dfs(sx[i], sy[i], cost, i);\n    sum += cnt;\n  }\n  return sum >= R;*/\n}\n\nint solve(){\n  //set<int>::iterator ite = data.end();\n  //int l = 0, r = *(--ite) + 1;\n  int l = 0, r = data[data.size()-1] + 1;\n  while(l<r){\n    int m = (l + r) / 2;\n    bool f = false;\n    //for(ite=data.begin();ite!=data.end();ite++){\n    for(int i=0;i<data.size();i++){\n      //if(*ite > m) break;\n      if(data[i] > m) break;\n      //if(check(*ite, m-(*ite))) f = true;\n      if(check(data[i], m-data[i])) f = true;\n    }\n    if(f) r = m;\n    else l = m + 1;\n  }\n  return l;\n}\n\nmain(){\n  while(cin >> R && R){\n    for(int k=0;k<2;k++){\n      cin >> w[k] >> h[k] >> sx[k] >> sy[k];\n      sx[k]--; sy[k]--;\n      for(int i=0;i<h[k];i++){\n        for(int j=0;j<w[k];j++){\n          cin >> input[k][i][j];\n        }\n      }\n    }\n    init();\n    cout << solve() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define POWT(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nconst pii Dir[8] = { //?????????\n\t{ 0,1 },{ 0,-1 },{ 1,0 },{ -1,0 },\n\t{ 1,1 },{ 1,-1 },{ -1,-1 },{ -1,1 }\n};\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\n\nsigned main() {\n\tint r;\n\n\twhile (scanf(\"%d\", &r)) {\n\t\tif (r == 0)\n\t\t\tbreak;\n\t\tint w, h, x, y;\n\t\tscanf(\"%d %d %d %d\", &w, &h, &y, &x);\n\t\tx--; y--;\n\t\tvector<vector<int>> m(h, vector<int>(w));\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tscanf(\"%d\", &m[i][j]);\n\t\t\t}\n\t\t}\n\t\tint w2, h2, x2, y2;\n\t\tscanf(\"%d %d %d %d\", &w2, &h2, &y2, &x2);\n\t\tx2--; y2--;\n\t\tvector<vector<int>> m2(h2, vector<int>(w2));\n\n\t\tREP(i, h2) {\n\t\t\tREP(j, w2) {\n\t\t\t\tscanf(\"%d\", &m2[i][j]);\n\t\t\t}\n\t\t}\n\t\tpriority_queue<pair<int, pii>, vector<pair<int, pii>>, greater<pair<int, pii>>> que;\n\n\t\tque.push({ 1,{ x,y } });\n\n\t\tmap<int, int> mcount;\n\t\tvector<vector<int>> al(h, vector<int>(w));\n\t\twhile (que.size()) {\n\t\t\tint  p = que.top().first;\n\t\t\tpii cur = que.top().second;\n\t\t\tque.pop();\n\t\t\tif (al[cur.first][cur.second])\n\t\t\t\tcontinue;\n\t\t\tal[cur.first][cur.second] = 1;\n\t\t\tmcount[p]++;\n\n\t\t\tREP(i, 4) {\n\t\t\t\tpii next = { cur.first + Dir[i].first, cur.second + Dir[i].second };\n\t\t\t\tif (RANGE(next.first, 0, h - 1) && RANGE(next.second, 0, w - 1)) {\n\t\t\t\t\tif (!al[next.first][next.second]) {\n\t\t\t\t\t\tque.push({ max(p,m[next.first][next.second]),next });\n\t\t\t\t\t\t//al[next.first][next.second] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<pii> cou;//????????????°??????¬??????\n\t\tfor (auto cur : mcount) {\n\t\t\tcou.push_back({ cur.second,cur.first });\n\t\t}\n\t\trep(i, 1, cou.size()) {\n\t\t\tcou[i].first += cou[i - 1].first;\n\t\t}\n\t\trep(i, 1, cou.size()) {\n\t\t\tif (cou[i].first == cou[i - 1].first) {\n\t\t\t\tif (cou[i].second > cou[i - 1].second)\n\t\t\t\t\tcou.erase(cou.begin() + i);\n\t\t\t\telse\n\t\t\t\t\tcou.erase(cou.begin() + i - 1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\n\t\tmcount.clear();\n\t\tal=vector<vector<int>>(h2, vector<int>(w2));\n\t\tque.push({ 1,{ x2,y2 } });\n\t\twhile (que.size()) {\n\t\t\tint  p = que.top().first;\n\t\t\tpii cur = que.top().second;\n\t\t\tque.pop();\n\t\t\tif (al[cur.first][cur.second])\n\t\t\t\tcontinue;\n\t\t\tal[cur.first][cur.second] = 1;\n\t\t\tmcount[p]++;\n\n\t\t\tREP(i, 4) {\n\t\t\t\tpii next = { cur.first + Dir[i].first, cur.second + Dir[i].second };\n\t\t\t\tif (RANGE(next.first, 0, h2 - 1) && RANGE(next.second, 0, w2 - 1)) {\n\t\t\t\t\tif (!al[next.first][next.second]) {\n\t\t\t\t\t\tque.push({ max(p,m2[next.first][next.second]),next });\n\t\t\t\t\t\t//al[next.first][next.second] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<pii> cou2;\n\t\tfor (auto cur : mcount) {\n\t\t\tcou2.push_back({ cur.second,cur.first });\n\t\t}\n\t\trep(i, 1, cou2.size()) {\n\t\t\tcou2[i].first += cou2[i - 1].first;\n\t\t}\n\t\trep(i, 1, cou2.size()) {\n\t\t\tif (cou2[i].first == cou2[i - 1].first) {\n\t\t\t\tif (cou2[i].second > cou2[i - 1].second)\n\t\t\t\t\tcou2.erase(cou2.begin() + i);\n\t\t\t\telse\n\t\t\t\t\tcou2.erase(cou2.begin() + i - 1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\n\t\tint Min = INT_MAX;\n\t\tcou.insert(cou.begin(), { 0,0 });\n\t\tcou2.insert(cou2.begin(), { 0,0 });\n\t\tREP(i, cou.size()) {\n\t\t\tauto itr = upper_bound(ALL(cou2), make_pair(r - cou[i].first, 0));\n\t\t\tif (itr != cou2.end()) {\n\t\t\t\tMin = min(Min, itr->second + cou[i].second);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", Min);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <numeric>\n#include <map>\n#include <vector>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <cmath>\n#include <stack>\n#include <cctype>\n#include <queue>\n#include <algorithm>\n#include <memory>\n#include <memory.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nconst int INF = 1 << 30;\nconst double EPS = 1e-10;\nconst double PI = 3.14159;\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, -1, 0, 1};\nbool used[2][502][502];\nint office[2][502][502];\nint cost[2][110000];\nint w[2];\nint h[2];\nint x[2];\nint y[2];\n\nint main(){\n\tint R;\n\twhile(cin >> R && R){\n\t\tfill(&office[0][0][0], &office[1][501][501] + 1, INF);\n\t\tfill(&cost[0][0], &cost[1][109999] + 1, INF);\n\t\tmemset(used, false, sizeof(used));\n\t\tfor(int i = 0; i < 2; i++){\n\t\t\tcin >> w[i] >> h[i] >> x[i] >> y[i];\n\t\t\tfor(int j = 1; j <= h[i]; j++){\n\t\t\t\tfor(int k = 1; k <= w[i]; k++){\n\t\t\t\t\tcin >> office[i][j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 2; i++){\n\t\t\tpriority_queue<PP, vector<PP>, greater<PP> > que;\n\t\t\tcost[i][0] = 0;\n\t\t\tint m_cost = 0;\n\t\t\tint count = 1;\n\t\t\tque.push(PP(1, P(y[i], x[i])));\n\t\t\twhile(!que.empty()){\n\t\t\t\tPP pp = que.top();\n\t\t\t\tque.pop();\n\t\t\t\tint c = pp.first;\n\t\t\t\tif(c == INF || count >= R + 10 || count > h[i] * w[i]) break;\n\t\t\t\tm_cost = max(m_cost, c);\n\t\t\t\tint y1 = pp.second.first;\n\t\t\t\tint x1 = pp.second.second;\n\t\t\t\tif(used[i][y1][x1]) continue;\n\t\t\t\tused[i][y1][x1] = true;\n\t\t\t\tcost[i][count++] = m_cost;\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tint y2 = y1 + dy[j];\n\t\t\t\t\tint x2 = x1 + dx[j];\n\t\t\t\t\tif(used[i][y2][x2]) continue;\n\t\t\t\t\tque.push(PP(office[i][y2][x2], P(y2, x2)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = INF;\n\t\tfor(int i = 0; i <= R; i++){\n\t\t\tres = min(res, cost[0][i] + cost[1][R-i]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n//#define int long long \n#define rep(i,n) for(int i=0;i<n;i++)\n#define mp make_pair\nconst int INF=1001001001;\nint W[2],H[2],X[2],Y[2];\nint L[2][502][502];\nvector<int> levs[2];//????????????????¨???¬??????sorted\nvector<int> levtoheya[2];//???????????¨????????¬?????????????????????????????¨?±??????°\nint solve(){\n     int R;\n     scanf(\"%d\",&R);\n     if(R==0)return -1;\n    rep(k,2){\n        if(levs[k].size())levs[k].clear();\n        if(levtoheya[k].size())levtoheya[k].clear();\n        levs[k].push_back(0);\n        scanf(\"%d %d %d %d\",&W[k],&H[k],&X[k],&Y[k]);\n        X[k]--;Y[k]--;\n        rep(i,H[k]){\n            rep(j,W[k]){\n                scanf(\"%d\",&L[k][j][i]);\n                levs[k].push_back( L[k][j][i] );\n            }\n            \n        }\n        sort(levs[k].begin(),levs[k].end() );\n        levs[k].erase( unique(levs[k].begin(),levs[k].end() ), levs[k].end() );\n    }\n    rep(k,2){\n        int heya=1;//??????????????¨?±???°\n        queue< pair<int,int> > q1; \n        queue< pair<int,int> > q2;\n        queue< pair<int,int> > qnull;\n        q2.push( mp(X[k],Y[k] ) );\n        bool ifgo[500][500];\n        fill(ifgo[0],ifgo[500],false);\n        ifgo[X[k]][Y[k]]=true;\n        rep(x,levs[k].size() ){//????????????x????¢???????????????¨?????????????????¨?±??????°??????????¢????\n            if(x==0){levtoheya[k].push_back(0);continue;}\n            int NX=levs[k][x];\n            //que2?????????????????????(??¨??????????????\\????????¨?±??????????)?????¨?±????????????¬??????x?????¨?±??????????????????¨?±???°????¢???????\n            q1=q2;q2=qnull;\n            while( q1.size() ){\n                pair<int,int> n=q1.front(); q1.pop();\n                int nx=n.first;int ny=n.second;\n                bool ifaround=false;\n                if(nx>0){\n                    if(L[k][nx-1][ny]<=NX){if(!ifgo[nx-1][ny]){q1.push(mp(nx-1,ny) );ifgo[nx-1][ny]=true;heya++;} }else ifaround=true;\n                }\n                if(ny>0){\n                    if(L[k][nx][ny-1]<=NX){if(!ifgo[nx][ny-1]){q1.push(mp(nx,ny-1) );ifgo[nx][ny-1]=true;heya++;} }else ifaround=true;\n                }\n                if(nx+1<W[k]){\n                    if(L[k][nx+1][ny]<=NX){if(!ifgo[nx+1][ny]){q1.push(mp(nx+1,ny));ifgo[nx+1][ny]=true;heya++;} }else ifaround=true;\n                }\n                if(ny+1<H[k]){\n                    if(L[k][nx][ny+1]<=NX){if(!ifgo[nx][ny+1]){q1.push(mp(nx,ny+1) );ifgo[nx][ny+1]=true;heya++;} }else ifaround=true;\n                }\n                if(ifaround){q2.push(mp(nx,ny));}\n            }\n            levtoheya[k].push_back(heya);\n        }\n    }\n    //levtoheya??????????????????????????????????±???????\n    int ans=INF;\n    rep(i,levtoheya[0].size()){\n        int mi=lower_bound(levtoheya[1].begin(),levtoheya[1].end(), R-levtoheya[0][i] )-levtoheya[1].begin();\n        if(mi>=levtoheya[1].size())continue;\n        int sans=levs[0][i]+levs[1][mi];\n        ans=min(ans,sans);\n    }\n    return ans;\n}\nsigned main(){\n    while(1){\n    int ans=solve();\n    if(ans<0)break;\n    printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(i,x,y) for(int i=(x);i<(y);++i)\n#define MP(a,b) make_pair((a),(b))\n#define F_ first\n#define S_ second\n\ntypedef long long int lli;\ntypedef pair<int,int> Pi;\ntypedef pair<int,Pi> PP;\n\nconst int INF=1000000000;\nconst long long int INF_=1000000000000000000;\nconst int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\ninline bool IsIn(int y,int x,int h,int w){\n\treturn 0<=y&&y<h&&0<=x&&x<w;\n}\n\ninline int f(int x){\n\tif(x==0) return 1;\n\telse if(x==1) return 0;\n}\n\nvoid Djikstra(vector<vector<int> > &f,vector<vector<int> > &l,int sy,int sx,int h,int w){\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\tREP(y,0,h) fill(l[y].begin(),l[y].end(),INF);\n\tl[sy][sx]=1;\n\tque.push(PP(1,Pi(sy,sx)));\n\twhile(!que.empty()){\n\t\tPP p=que.top(); que.pop();\n\t\tPi v=p.S_;\n\t\tif(l[v.F_][v.S_]<p.F_) continue;\n\t\tREP(i,0,4){\n\t\t\tint ny=v.F_+dy[i],nx=v.S_+dx[i];\n\t\t\tif(!IsIn(ny,nx,h,w)) continue;\n\t\t\tif(l[ny][nx]>max(f[ny][nx],l[v.F_][v.S_])){\n\t\t\t\tl[ny][nx]=max(f[ny][nx],l[v.F_][v.S_]);\n\t\t\t\tque.push(PP(l[ny][nx],Pi(ny,nx)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tint R;\n\twhile(cin >> R&&R){\n\t\tint W[2],H[2],X[2],Y[2];\n\t\tvector<vector<int> > field[2];\n\t\tvector<vector<int> > level[2];\n\t\tREP(i,0,2){\n\t\t\tcin >> W[i] >> H[i] >> X[i] >> Y[i];\n\t\t\t--X[i]; --Y[i];\n\t\t\tfield[i].resize(H[i]);\n\t\t\tlevel[i].resize(H[i]);\n\t\t\tREP(j,0,H[i]){\n\t\t\t\tfield[i][j].resize(W[i]);\n\t\t\t\tlevel[i][j].resize(W[i]);\n\t\t\t}\n\t\t\tREP(y,0,H[i]) REP(x,0,W[i]) cin >> field[i][y][x];\n\t\t\tDjikstra(field[i],level[i],Y[i],X[i],H[i],W[i]);\n\t\t}\n\t\tmap<int,int> s[2];\n\t\tvector<int> idx[2],num[2];\n\t\tREP(i,0,2){\n\t\t\tREP(y,0,H[i]) REP(x,0,W[i]) ++s[i][level[i][y][x]];\n\t\t\tauto it=s[i].begin();\n\t\t\tidx[i].push_back(0);\n\t\t\tnum[i].push_back(0);\n\t\t\tidx[i].push_back(it->F_);\n\t\t\tnum[i].push_back(it->S_);\n\t\t\tauto prev=it;\n\t\t\t++it;\n\t\t\tfor(; it!=s[i].end(); ++it,++prev){\n\t\t\t\tit->S_+=prev->S_;\n\t\t\t\tidx[i].push_back(it->F_);\n\t\t\t\tnum[i].push_back(it->S_);\n\t\t\t}\n\t\t}\n\t\tint result=INF;\n\t\tREP(i,0,2) REP(j,0,idx[i].size()){\n\t\t\tint tmp=(int)(lower_bound(num[f(i)].begin(),num[f(i)].end(),R-num[i][j])-num[f(i)].begin());\n\t\t\tif(!(0<=tmp&&tmp<=idx[f(i)].size()-1)) continue;\n\t\t\tresult=min(result,idx[i][j]+idx[f(i)][tmp]);\n\t\t}\n\t\tcout << result << endl;\n\t}\n}\n\nint main(){\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<string>\n#include<queue>\n#include<climits>\nusing namespace std;\n\nint vx[4]={0,1,0,-1};\nint vy[4]={1,0,-1,0};\n\nstruct pos{\n  pos(){};\n  pos(int cost,int kpos,int xpos,int ypos){\n    c=cost;\n    k=kpos;\n    x=xpos;\n    y=ypos;\n  }\n  int c,k,x,y;\n};\n\nbool operator<(const pos &a,const pos &b){\n  return a.c>b.c;\n}\n\nint r;\npair<int,int> el[2];\nvector< vector<int> > map[2];\nvector< vector<int> > used[2];\nvoid init(){\n  map[0].clear();\n  map[1].clear();\n  used[0].clear();\n  used[1].clear();\n}\n\nint input(){\n  cin>>r;\n  if(r==0)return 0;\n  int x,y;\n  cin>>x>>y;\n  cin>>el[0].second;\n  cin>>el[0].first;\n  el[0].first--;\n  el[0].second--;\n  map[0].resize(y);\n  used[0].resize(y);\n  for(int i=0;i<y;i++){\n    used[0][i].resize(x);\n    for(int j=0;j<x;j++){\n      int tmp;\n      cin>>tmp;\n      map[0][i].push_back(tmp);\n    }\n  }\n  cin>>x>>y;\n  cin>>el[1].second;\n  cin>>el[1].first;\n  el[1].first--;\n  el[1].second--;\n  map[1].resize(y);\n  used[1].resize(y);\n  for(int i=0;i<y;i++){\n    used[1][i].resize(x);\n    for(int j=0;j<x;j++){\n      int tmp;\n      cin>>tmp;\n      map[1][i].push_back(tmp);\n    }\n  }\n  return r;\n\n}\n\nint solve(){\n  \n  priority_queue<pos> q;\n  q.push(pos(map[0][el[0].first][el[0].second] , 0 , el[0].first , el[0].second));\n\n  vector< pair<int,int> > cost_room[2];\n  pair<int,int> tmp_c;\n\n  tmp_c.first =0;\n  tmp_c.second=0;\n\n  while((!q.empty())){\n    pos tmp=q.top();q.pop();\n    if(tmp_c.first<tmp.c){\n      cost_room[tmp.k].push_back(tmp_c);\n      tmp_c.second++;\n      tmp_c.first=tmp.c;\n    }else if(tmp_c.first>=tmp.c && tmp.c!=0){\n      tmp_c.second++;\n    }\n\n    used[tmp.k][tmp.x][tmp.y]=true;\n    for(int i=0;i<4;i++){\n      if((!(tmp.x+vx[i]<0||used[tmp.k].size()-1<tmp.x+vx[i]))\n          &&(!(tmp.y+vy[i]<0||used[tmp.k][tmp.x+vx[i]].size()-1<tmp.y+vy[i]))\n          &&(!used[tmp.k][tmp.x+vx[i]][tmp.y+vy[i]])){\n        used[tmp.k][tmp.x][tmp.y]=1; \n        q.push(pos( map[tmp.k][tmp.x+vx[i]][tmp.y+vy[i]], tmp.k, tmp.x+vx[i],tmp.y+vy[i]));\n      }\n    }\n  }\n  cost_room[0].push_back(tmp_c);\n  \n  q.push(pos(map[1][el[1].first][el[1].second] , 1 , el[1].first , el[1].second));\n  tmp_c.first =0;\n  tmp_c.second=0;\n  while((!q.empty())){\n    pos tmp=q.top();q.pop();\n    if(used[tmp.k][tmp.x][tmp.y])continue; \n    if(tmp_c.first<tmp.c){\n      cost_room[tmp.k].push_back(tmp_c);\n      tmp_c.second++;\n      tmp_c.first=tmp.c;\n    }else if(tmp_c.first>=tmp.c && tmp.c!=0){\n      tmp_c.second++;\n    }\n\n    used[tmp.k][tmp.x][tmp.y]=true;\n    for(int i=0;i<4;i++){\n      if((!(tmp.x+vx[i]<0||used[tmp.k].size()-1<tmp.x+vx[i]))\n          &&(!(tmp.y+vy[i]<0||used[tmp.k][tmp.x+vx[i]].size()-1<tmp.y+vy[i]))\n          &&(!used[tmp.k][tmp.x+vx[i]][tmp.y+vy[i]])){\n        used[tmp.k][tmp.x][tmp.y]=1; \n        q.push(pos( map[tmp.k][tmp.x+vx[i]][tmp.y+vy[i]], tmp.k, tmp.x+vx[i],tmp.y+vy[i]));\n      }\n    }\n  }\n  cost_room[1].push_back(tmp_c);\n\n  \n  \n\n  int res=INT_MAX;\n  for(int i=0;i<cost_room[0].size();i++){\n    for(int j=0;j<cost_room[1].size();j++){\n      if( cost_room[0][i].second+cost_room[1][j].second>=r){\n        res=min(cost_room[0][i].first+cost_room[1][j].first,res);\n      }\n    }\n  }\n  return res;\n}\n\n\n\nint main(){\n  while(init(),input()){\n    cout<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<map>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int i,j,k;\n  int r;\n  while(cin>>r&&r){\n    int a[2][502][502],w[2],h[2],x[2],y[2];\n    memset(a,-1,sizeof(a));\n    for(i=0;i<2;i++){\n      cin>>w[i]>>h[i]>>x[i]>>y[i];\n      for(j=1;j<h[i]+1;j++)\n\tfor(k=1;k<w[i]+1;k++)\n\t  cin>>a[i][k][j];\n    }\n    unsigned b[2][502][502];\n    memset(b,-1,sizeof(b));\n    for(i=0;i<2;i++){\n      queue<pair<pair<int,int>,int> > c;\n      c.push(make_pair(make_pair(x[i],y[i]),0));\n      while(c.empty()==0){\n\tint u,v,z;\n\tu=c.front().first.first;\n\tv=c.front().first.second;\n\tz=c.front().second;\n\tc.pop();\n\tif(a[i][u][v]!=-1&&b[i][u][v]>(unsigned)max(a[i][u][v],z)){\n\t  b[i][u][v]=max(a[i][u][v],z);\n\t  c.push(make_pair(make_pair(u-1,v),max(a[i][u][v],z)));\n\t  c.push(make_pair(make_pair(u+1,v),max(a[i][u][v],z)));\n\t  c.push(make_pair(make_pair(u,v-1),max(a[i][u][v],z)));\n\t  c.push(make_pair(make_pair(u,v+1),max(a[i][u][v],z)));\n\t}\n      }\n    }\n    map<int,int> c[2];\n    map<int,int>::iterator it,jt;\n    for(i=0;i<2;i++){\n      c[i][0]=0;\n      for(j=1;j<h[i]+1;j++)\n\tfor(k=1;k<w[i]+1;k++)\n\t  c[i][b[i][k][j]]++;\n    }\n    for(i=0;i<2;i++){\n      it=jt=c[i].begin();\n      for(jt++;jt!=c[i].end();){\n\t(*jt).second+=(*it).second;\n\tit++;\n\tjt++;\n      }\n    }\n    unsigned mn=-1;\n    for(it=c[0].begin();it!=c[0].end();it++){\n      for(jt=c[1].begin();jt!=c[1].end()&&(*it).second+(*jt).second<r;jt++);\n      if(jt!=c[1].end())\n\tmn=min(mn,(unsigned)((*it).first+(*jt).first));\n      if((*it).second>=r)\n\tbreak;\n    }\n    cout<<mn<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long R, W, H, X, Y, i, j, L[500][500], O, T, a, b;\nlong long m[5] = {1, 0, -1, 0, 1};\nbool u[500][500], v[500][500];\nvector<long long> d1, d2;\ntuple<long long, long long, long long> t;\npriority_queue<tuple<long long, long long, long long>, vector<tuple<long long, long long, long long> >, greater<tuple<long long, long long, long long> > > q;\n\nint main(){\n  scanf(\"%lld\", &R);\n  scanf(\"%lld%lld%lld%lld\", &W, &H, &X, &Y);\n  for(i = 0; i < H; ++i){\n    for(j = 0; j < W; ++j){\n      scanf(\"%lld\", L[j] + i);\n    }\n  }\n  d1.push_back(0);\n  d2.push_back(0);\n  q.push(make_tuple(1, X - 1, Y - 1));\n  u[X - 1][Y - 1] = true;\n  while(!q.empty()){\n    t = q.top();\n    q.pop();\n    tie(O, a, b) = t;\n    d1.push_back(O);\n    //cout << O << endl;\n    for(i = 0; i < 4; ++i){\n      if(0 <= a + m[i] && a + m[i] < W && 0 <= b + m[i + 1] && b + m[i + 1] < H && !u[a + m[i]][b + m[i + 1]]){\n        //cout << L[a + m[i]][b + m[i + 1]] << \" \" << a + m[i] << \" \" << b + m[i + 1] << endl;\n\tu[a + m[i]][b + m[i + 1]] = true;\n\tq.push(make_tuple(max(O, L[a + m[i]][b + m[i + 1]]), a + m[i], b + m[i + 1]));\n      }\n    }\n  }\n  O = W * H + 1;\n  scanf(\"%lld%lld%lld%lld\", &W, &H, &X, &Y);\n  for(i = 0; i < H; ++i){\n    for(j = 0; j < W; ++j){\n      scanf(\"%lld\", L[j] + i);\n    }\n  }\n  q.push(make_tuple(1, X - 1, Y - 1));\n  v[X - 1][Y - 1] = true;\n  while(!q.empty()){\n    t = q.top();\n    q.pop();\n    tie(T, a, b) = t;\n    d2.push_back(T);\n    for(i = 0; i < 4; ++i){\n      if(0 <= a + m[i] && a + m[i] < W && 0 <= b + m[i + 1] && b + m[i + 1] < H && !v[a + m[i]][b + m[i + 1]]){\n\t//cout << a + m[i] << \" \" << b + m[i + 1] << endl;\n\tv[a + m[i]][b + m[i + 1]] = true;\n\tq.push(make_tuple(max(T, L[a + m[i]][b + m[i + 1]]), a + m[i], b + m[i + 1]));\n      }\n    }\n  }\n  T = W * H + 1;\n  a = 1099511627775LL;\n  /*for(i = 0, j = O; i < j; ++i){\n    cout << d1[i] << \" \";\n  }\n  cout << endl;\n  for(i = 0, j = T; i < j; ++i){\n    cout << d2[i] << \" \";\n  }\n  cout << endl;*/\n  for(i = max(0LL, R - T + 1), j = min(R, O) + 1; i < j; ++i){\n    //cout << i << \" \" << R - i << endl;\n    a = min(a, d1[i] + d2[R - i]);\n  }\n  cout << a << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n \n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n \n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n \n \nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n \nint dx[] = {-1,0,1,0};\nint dy[] = {0,-1,0,1};\n \nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n \n  int R;\nwhile(\n  cin >> R,R){\n \n  map<int,int> num[2];\n  REP(k,2){\n\tint W, H, sx, sy;\n\tcin >> W >> H >> sx >> sy;\n\t--sx;\n\t--sy;\n\tVVI lv(H, VI(W));\n\tREP(y,H) REP(x,W) cin >> lv[y][x];\n \n\tusing P = pair<int,PII>;\n\tpriority_queue<P,vector<P>,greater<P>> pq;\n\tvector<vector<bool>> vis(H, vector<bool>(W));\n\tpq.push(MP(1, MP(sx, sy)));\n\tvis[sy][sx] = true;\n \n\tint acc = 0;\n\tint cur = 0;\n\tnum[k][0] = 0;\n\twhile(!pq.empty()){\n\t  cur = pq.top().FF;\n\t  while(!pq.empty() && pq.top().FF <= cur){\n\t\tauto p = pq.top();\n\t\tpq.pop();\n\t\t++acc;\n\t\tREP(d,4){\n\t\t  int tx = p.SS.FF + dx[d];\n\t\t  int ty = p.SS.SS + dy[d];\n\t\t  if(tx < 0 || W <= tx || ty < 0 || H <= ty || vis[ty][tx]) continue;\n\t\t  vis[ty][tx] = true;\n\t\t  pq.push(MP(lv[ty][tx], MP(tx, ty)));\n\t\t}\n\t  }\n\t  num[k][acc] = cur;\n\t}\n  }\n  /*\n  for(auto&p:num[0]) cout << p << endl;\n  cout<<\"===\"<<endl;\n  for(auto&p:num[1]) cout << p << endl;\n  */\n  int ans = 1e9;\n  for(auto& p: num[0]){\n\tauto it = num[1].lower_bound(R - p.FF);\n\tif(it == end(num[1])) continue;\n\t\n\tmini(ans, p.SS + it->SS);\n  }\n  cout << ans << endl;\n }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<vector>\n#include<iostream>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> P2;\n\nint r,w[2],h[2],x[2],y[2];\nint l[2][501][501],num,prv;\nint d[2][501][501];\nvector<P> v[2];\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nvoid dijkstra(int k){\n  v[k].clear();\n  for(int i=1;i<=h[k];i++)\n    for(int j=1;j<=w[k];j++)d[k][i][j] = 100000000;\n  \n  priority_queue<P2,vector<P2>,greater<P2> > q;\n  q.push(P2(l[k][y[k]][x[k]],P(y[k],x[k])));\n  num = prv = 0;\n  \n  while(q.size()){\n    P2 p = q.top(); q.pop();\n    int lv = p.first, sy = p.second.first, sx = p.second.second;\n\n    if(d[k][sy][sx] <= lv)continue;\n    d[k][sy][sx] = lv;\n    if(prv != lv){\n      v[k].push_back(P(num,prv));\n      prv = lv;\n    }\n    num++;\n\n    for(int i=0;i<4;i++){\n      int tlv = lv, ty = sy+dy[i], tx = sx+dx[i];\n      if(ty<1 || tx<1 || h[k]<ty || w[k]<tx)continue;\n      if(tlv<l[k][ty][tx])tlv = l[k][ty][tx];\n      if(tlv < d[k][ty][tx]){\n\tq.push(P2(tlv,P(ty,tx)));\n      }\n    }\n  }\n  v[k].push_back(P(num,prv));\n}\n\nint main(){\n  while(scanf(\"%d\",&r), r){\n    for(int k=0;k<2;k++){\n      scanf(\"%d%d%d%d\",&w[k],&h[k],&x[k],&y[k]);\n      for(int i=1;i<=h[k];i++)\n\tfor(int j=1;j<=w[k];j++)scanf(\"%d\",&l[k][i][j]);\n\n      dijkstra(k);\n      sort(v[k].begin(),v[k].end());\n    }\n\n    int ans = 200000000;\n    for(int i = (int)v[0].size()-1;i>=0;i--){\n      P tmp = P(r-v[0][i].first,0);\n      vector<P>::iterator it = lower_bound(v[1].begin(),v[1].end(),tmp);\n      if(it == v[1].end())break;\n      else ans = min(ans,v[0][i].second + (*it).second);\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\n\nstatic const double eps = 1e-8;\n\nconst int tx[4] = {+0,+1,+0,-1};\nconst int ty[4] = {-1,+0,+1,+0};\n\nbool visited[501][501];\nint rooms[2][501][501];\nint required_auth_level[2][250001];\n\nstruct State {\n  int x;\n  int y;\n  int auth;\n  bool operator<(const State& s) const {\n    return auth < s.auth;\n  }\n  bool operator>(const State& s) const {\n    return auth > s.auth;\n  }\n  State(int x,int y,int auth) : x(x), y(y), auth(auth) {}\n};\n\nvoid bfs(int sx,int sy,int W,int H,int office_i){\n  memset(visited,false,sizeof(visited));\n  priority_queue<State,vector<State>, greater<State> > que;\n  que.push(State(sx,sy,1));\n  int current_auth_level = 0;\n  int count = 0;\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n    if(visited[s.y][s.x]) continue;\n    visited[s.y][s.x] = true;\n\n    count++;\n    current_auth_level = max(s.auth,current_auth_level);\n    required_auth_level[office_i][count] = current_auth_level;\n\n    for(int i = 0; i < 4; i++){\n      int dx = s.x + tx[i];\n      int dy = s.y + ty[i];\n      if(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n      if(visited[dy][dx]) continue;\n       que.push(State(dx,dy,rooms[office_i][dy][dx]));\n    }\n  }\n}\n\nint main(){\n  int have_to_visit_rooms;\n  while(~scanf(\"%d\",&have_to_visit_rooms)){\n    if(have_to_visit_rooms == 0) break;\n    memset(required_auth_level,0x3f,sizeof(required_auth_level));\n    required_auth_level[0][0] = 0;\n    required_auth_level[1][0] = 0;\n    int elevator_x[2];\n    int elevator_y[2];\n    int W[2];\n    int H[2];\n    for(int office_i = 0; office_i < 2; office_i++){\n      scanf(\"%d %d %d %d\",&W[office_i],&H[office_i],\n            &elevator_x[office_i],&elevator_y[office_i]);\n      elevator_x[office_i]--;\n      elevator_y[office_i]--;\n\n      for(int y = 0; y < H[office_i]; y++){\n        for(int x = 0; x < W[office_i]; x++){\n          scanf(\"%d\",&rooms[office_i][y][x]);\n        }\n      }\n\n      bfs(elevator_x[office_i],\n          elevator_y[office_i],\n          W[office_i],H[office_i],office_i);\n    }\n    int res = 0x3f3f3f3f;\n    for(int i = have_to_visit_rooms; i >= 0; i--){\n      int j = have_to_visit_rooms - i;\n      res = min(required_auth_level[0][i] + required_auth_level[1][j],res);\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "# 2 \"0542.cpp\"\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <functional>\n#include <iterator>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n\n\nnamespace solution {\n   using namespace std;\n\n   typedef istringstream ISS;\n   typedef ostringstream OSS;\n   typedef vector<string> VS;\n   typedef long long LL;\n   typedef int INT;\n   typedef vector<INT> VI;\n   typedef vector<VI> VVI;\n   typedef pair<INT, INT> II;\n\n   const int R_MAX = 100011;\n   const int SIZE = 511;\n   const int INF = INT_MAX;\n   int R;\n   int H1, W1, R1, C1;\n   int L1[SIZE][SIZE];\n   int T1[R_MAX];\n   int TC1;\n   int H2, W2, R2, C2;\n   int L2[SIZE][SIZE];\n   int T2[R_MAX];\n   int TC2;\n\n   void init() {\n   }\n\n   void input( int &H, int &W, int &R, int &C, int L[SIZE][SIZE] ) {\n      cin >> W >> H >> C >> R;\n      R --;\n      C --;\n      for ( int i = 0; i < H; ++ i ) {\n         for ( int j = 0; j < W; ++ j ) {\n            cin >> L[i][j];\n         }\n      }\n   }\n\n   bool input() {\n      if ( ! ( cin >> R && R ) ) return false;\n      input( H1, W1, R1, C1, L1 );\n      input( H2, W2, R2, C2, L2 );\n      return true;\n   }\n\n   typedef pair <int, II> Node;\n   typedef priority_queue <Node, vector<Node>, greater<Node> > Queue;\n\n   const int dr[4] = { 0, 0, 1, -1 };\n   const int dc[4] = { 1, -1, 0, 0 };\n\n   Queue Q;\n   bool MC[SIZE][SIZE];\n\n   void update_init( int &TC ) {\n      TC = 1;\n      Q = Queue();\n      for ( int i = 0; i < SIZE; ++ i ) {\n         for ( int j = 0; j < SIZE; ++ j ) {\n            MC[i][j] = false;\n         }\n      }\n   }\n\n   void update( int &H, int &W, int &R, int &C, int L[SIZE][SIZE], int T[R_MAX], int& TC ) {\n      update_init(TC);\n      int max_l = 0;\n      Node start_node( L[R][C], II( R, C ) );\n      Q.push( start_node );\n      MC[R][C] = true;\n\n      while ( ! ( Q.empty() ) ) {\n         Node node = Q.top();\n         Q.pop();\n\n         int s = node.first;\n         int r = node.second.first;\n         int c = node.second.second;\n\n         max_l = max( max_l, s );\n         T[TC ++] = max_l;\n\n         for ( int k = 0; k < 4; ++ k ) {\n            int nr = r + dr[k];\n            int nc = c + dc[k];\n            if ( nr < 0 || nr >= H || nc < 0 || nc >= W ) continue;\n            if ( MC[nr][nc] ) continue;\n            MC[nr][nc] = true;\n            int ns = L[nr][nc];\n            Node next_node( ns, II( nr, nc ) );\n            Q.push( next_node );\n         }\n      }\n   }\n\n   int solve() {\n      update( H1, W1, R1, C1, L1, T1, TC1 );\n      update( H2, W2, R2, C2, L2, T2, TC2 );\n      int res = INF;\n      for ( int i = 1; i <= min( R, TC1 - 1 ); ++ i ) {\n         int j = R - i;\n         if ( j >= TC2 ) continue;\n         res = min( res, T1[i] + T2[j] );\n      }\n      return res;\n   }\n}\n\nint main() {\n   using namespace std;\n   using namespace solution;\n\n   while ( init(), input() ) {\n      cout << solve() << endl;\n   }\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \ntemplate<typename T1, typename T2> istream& operator>>(istream& is, pair<T1,T2>& a){ return is >> a.first >> a.second; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, pair<T1,T2>& a){ return os << a.first << \" \" << a.second; }\ntemplate<typename T> istream& operator>>(istream& is, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) is >> vc[i]; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) os << vc[i] << endl; return os; }\n \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n\ntypedef long long int64;\ntypedef pair< int , int > Pi;\ntypedef pair< int , Pi > Pii;\nconst int INF = 1 << 30;\n\nint main()\n{\n  int R, W[2], H[2], X, Y, L[500][500];\n  int min_cost[500][500], limit[2][500 * 500 + 1];\n\n  static const signed dy[] = { 0, 1, 0, -1}, dx[] = { 1, 0, -1, 0};\n\n  while(cin >> R, R){\n    map< int, int > level[2];\n    for(int i = 0; i < 2; i++){\n      cin >> W[i] >> H[i] >> X >> Y;\n      --X, --Y;\n      for(int j = 0; j < H[i]; j++){\n        for(int k = 0; k < W[i]; k++){\n          cin >> L[j][k];\n        }\n      }\n      priority_queue< Pii, vector< Pii >, greater< Pii > > que;\n      fill_n( *min_cost, 500 * 500, INF);\n      que.push( Pii( L[Y][X], make_pair( X, Y)));\n      min_cost[X][Y] = L[Y][X];\n      level[i][min_cost[X][Y]]++;\n      while(!que.empty()){\n        Pii p = que.top(); que.pop();\n        if(p.first > min_cost[p.second.first][p.second.second]) continue;\n        for(int j = 0; j < 4; j++){\n          int nx = p.second.first + dx[j], ny = p.second.second + dy[j];\n          if(nx < 0 || nx >= W[i] || ny < 0 || ny >= H[i]) continue;\n          if(max( L[ny][nx], p.first) >= min_cost[nx][ny]) continue;\n          min_cost[nx][ny] = max( L[ny][nx], p.first);\n          que.push( Pii( max( L[ny][nx], p.first), make_pair( nx, ny)));\n          level[i][min_cost[nx][ny]]++;\n        }\n      }\n\n      int sz = 0;\n      fill_n( limit[i], H[i] * W[i], 0);\n      ForEach(it, level[i]){\n        sz += it -> second;\n        limit[i][sz] = it -> first;\n      }\n      for(int j = H[i] * W[i] - 1; j > 0; j--){\n        if(limit[i][j] == 0) limit[i][j] = limit[i][j + 1];\n      }\n    }\n\n    int ret = INF;\n    for(int i = 0; i < H[0] * W[0]; i++){\n      int nokori = R - i;\n      if(nokori < 0 || nokori > W[1] * H[1]) continue;\n      ret = min( ret, limit[0][i] + limit[1][nokori]);\n    }\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> iP;\n#define pb push_back\n#define fi first\n#define sc second\n#define MAX_H 514\nint R;\nint W[2],H[2],X[2],Y[2];\nint L[2][MAX_H][MAX_H];\nbool F[2][MAX_H][MAX_H];\nvector<iP>data[2];\nint need[2][MAX_H*MAX_H];\nint dx[4]={-1,0,0,1};\nint dy[4]={0,-1,1,0};\nint main()\n{\n\tscanf(\"%d\",&R);\n\tfor(int i=0;i<2;i++){\n\t\tscanf(\"%d%d%d%d\",&W[i],&H[i],&X[i],&Y[i]);X[i]--;Y[i]--;\n\t\tfor(int j=0;j<H[i];j++){\n\t\t\tfor(int k=0;k<W[i];k++){\n\t\t\t\tscanf(\"%d\",&L[i][j][k]);\n\t\t\t\tif(j==Y[i]&&k==X[i]){continue;}\n\t\t\t\tdata[i].pb(iP(L[i][j][k],P(j,k)));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tsort(data[i].begin(),data[i].end());\n\t\tfor(int j=0;j<=W[i]*H[i];j++){\n\t\t\tneed[i][j]=(1<<30)-1;\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tF[i][Y[i]][X[i]]=true;\n\t\tneed[i][0]=0;\n\t\tint cou=1;need[i][1]=1;\n\t\tfor(int j=0;j<(int)data[i].size();j++){\n\t\t\tint x=data[i][j].sc.fi;\n\t\t\tint y=data[i][j].sc.sc;\n\t\t\tbool flag=false;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tif(x+dx[k]<0||x+dx[k]>=H[i]||y+dy[k]<0||y+dy[k]>=W[i]){continue;}\n\t\t\t\tif(F[i][x+dx[k]][y+dy[k]])flag=true;\n\t\t\t}\n\t\t\tif(!flag){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tqueue<P>que;\n\t\t\tque.push(P(x,y));\n\t\t\twhile(!que.empty()){\n\t\t\t\tP p=que.front();que.pop();\n\t\t\t\tif(F[i][p.fi][p.sc])continue;\n\t\t\t\tF[i][p.fi][p.sc]=true;\n\t\t\t\t//printf(\"%d %d\\n\",p.fi,p.sc);\n\t\t\t\tcou++;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(p.fi+dx[k]<0||p.fi+dx[k]>=H[i]||p.sc+dy[k]<0||p.sc+dy[k]>=W[i]){continue;}\n\t\t\t\t\tif(F[i][p.fi+dx[k]][p.sc+dy[k]]){continue;}\n\t\t\t\t\tif(L[i][p.fi+dx[k]][p.sc+dy[k]]<=data[i][j].fi){\n\t\t\t\t\t\tque.push(P(p.fi+dx[k],p.sc+dy[k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tneed[i][cou]=L[i][x][y];\n\t\t\t//printf(\"%d:%d %d\\n\",cou,x,y);\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<2;i++){\n\t\tfor(int j=0;j<=W[i]*H[i];j++){\n\t\t\tprintf(\"need[%d][%d]=%d\\n\",i,j,need[i][j]);\n\t\t}\n\t}\n\t*/\n\tint ans=1<<30;\n\tfor(int i=0;i<=W[0]*H[0];i++){\n\t\tint k=R-i;\n\t\tif(k>W[1]*H[1]){\n\t\t\tcontinue;\n\t\t}\n\t\tans=min(need[0][i]+need[1][k],ans);\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<climits>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint ve[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nint main(){\n    for(;;){\n        int r;\n        scanf(\"%d\",&r);\n        if(r==0) break;\n        vector<vector<int> > rtole(2,vector<int>(r+1,-1));\n        for(int ii=0;ii<2;ii++){\n            int w,h,xe,ye;\n            scanf(\"%d%d%d%d\",&w,&h,&xe,&ye);\n            xe--;ye--;\n            vector<vector<int> > levs(h,vector<int>(w));\n            for(int iy=0;iy<h;iy++){\n                for(int ix=0;ix<w;ix++){\n                    scanf(\"%d\",&levs[iy][ix]);\n                }\n            }\n            vector<vector<bool> > isused(h,vector<bool>(w,false));\n            priority_queue<PP,vector<PP>,greater<PP> > pq;\n            pq.push(PP(levs[ye][xe],P(ye,xe)));\n            int nowlev=0,nowro=0;\n            rtole[ii][0]=0;\n            isused[ye][xe]=true;\n            for(;;){\n                if(pq.empty())break;\n                PP te=pq.top();\n                pq.pop();\n                int le=te.first,yy=te.second.first,xx=te.second.second;\n                if(le<=nowlev){\n                    nowro++;\n                    if(nowro<=r) rtole[ii][nowro]=nowlev;\n                }else{\n                    nowlev=le;\n                    nowro++;\n                    if(nowro<=r) rtole[ii][nowro]=nowlev;\n                }\n                for(int jj=0;jj<4;jj++){\n                    int newy=yy+ve[jj][0],newx=xx+ve[jj][1];\n                    if(newy>=0&&newy<h&&newx>=0&&newx<w&&!isused[newy][newx]){\n                        isused[newy][newx]=true;\n                        pq.push(PP(levs[newy][newx],P(newy,newx)));\n                    }\n                }\n            }\n        }\n        int mi=INT_MAX;\n        for(int i=0;i<rtole[0].size();i++){\n            if(rtole[0][i]!=-1&&rtole[1][r-i]!=-1){\n                mi=min(mi,rtole[0][i]+rtole[1][r-i]);\n            }\n        }\n        printf(\"%d\\n\",mi);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> Pint;\ntypedef pair<ll, int> P;\n//typedef tuple<int,int,int> T;\nll INFL = 1000000000000000010;//10^18 = 2^60\nint INF = 2147483600;//10^9\nll MOD  = 1000000007;\nvector<int> dy(4);\nvector<int> dx(4);\nvector<ll> Ans(0);\nint solve(){\n    int R;\n    cin >> R;\n    if(R == 0)return 0;\n    int H1,W1,X1,Y1;\n    cin >> W1 >> H1 >> X1 >> Y1;\n    X1--;\n    Y1--;\n    vector<vector<ll> > mp1(H1, vector<ll>(W1));\n    vector<vector<ll> > d1(H1, vector<ll>(W1, INFL));\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            cin >> mp1[i][j];\n        }\n    }\n    \n    d1[Y1][X1] = 1;\n    priority_queue<pair<ll, pair<int, int> > > pque1;\n    pque1.push({1, {Y1, X1}});\n    \n    while(!pque1.empty()){\n        ll c;\n        int y,x;\n        c = pque1.top().first;\n        y = pque1.top().second.first;\n        x = pque1.top().second.second;\n        pque1.pop();\n        if(c > d1[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H1 && 0 <= nx && nx < W1){\n                if(d1[ny][nx] > d1[y][x]){\n                    if(d1[y][x] > mp1[ny][nx]){\n                        d1[ny][nx] = d1[y][x];\n                    }else{\n                        d1[ny][nx] = mp1[ny][nx];\n                    }\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }else if(d1[ny][nx] > d1[y][x]){\n                    d1[ny][nx] = mp1[ny][nx];\n                    pque1.push({d1[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    int H2,W2,X2,Y2;\n    cin >> W2 >> H2 >> X2 >> Y2;\n    X2--;\n    Y2--;\n    vector<vector<ll> > mp2(H2, vector<ll>(W2));\n    vector<vector<ll> > d2(H2, vector<ll>(W2, INFL));\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            cin >> mp2[i][j];\n        }\n    }\n    \n    d2[Y2][X2] = 1;\n    priority_queue<pair<ll, pair<int, int> > > pque2;\n    pque2.push({1, {Y2, X2}});\n    \n    while(!pque2.empty()){\n        ll c;\n        int y,x;\n        c = pque2.top().first;\n        y = pque2.top().second.first;\n        x = pque2.top().second.second;\n        pque2.pop();\n        if(c > d2[y][x]) continue;\n        for(int i = 0; i < 4; i++){\n            int ny = y + dy[i];\n            int nx = x + dx[i];\n            if(0 <= ny && ny < H2 && 0 <= nx && nx < W2){\n                if(d2[ny][nx] > d2[y][x]){\n                    if(d2[y][x] > mp2[ny][nx]){\n                        d2[ny][nx] = d2[y][x];\n                    }else{\n                        d2[ny][nx] = mp2[ny][nx];\n                    }\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }else if(d2[ny][nx] > d2[y][x]){\n                    d2[ny][nx] = mp2[ny][nx];\n                    pque2.push({d2[ny][nx], {ny, nx}});\n                }\n            }\n        }\n    }\n    \n    vector<pair<ll,int> > O1(0);\n    vector<ll> COST1(0);\n    for(int i = 0; i < H1; i++){\n        for(int j = 0; j < W1; j++){\n            COST1.push_back(d1[i][j]);\n        }\n    }\n    sort(COST1.begin(), COST1.end());\n    COST1.push_back(INFL);\n    ll ad1 = COST1.at(0);\n    int cnt = 0;\n    for(int i = 0; i < COST1.size(); i++){\n        if(ad1 == COST1.at(i)){\n            cnt++;\n        }else{\n            O1.push_back({ad1, cnt});\n            ad1 = COST1.at(i);\n            cnt++;\n        }\n    }\n    \n    vector<pair<ll,int> > O2(1);\n    O2.at(0).first = 0;\n    O2.at(0).second = 0;\n    vector<ll> COST2(0);\n    for(int i = 0; i < H2; i++){\n        for(int j = 0; j < W2; j++){\n            COST2.push_back(d2[i][j]);\n        }\n    }\n    sort(COST2.begin(), COST2.end());\n    COST2.push_back(INFL);\n    ll ad2 = COST2.at(0);\n    cnt = 0;\n    for(int i = 0; i < COST2.size(); i++){\n        if(ad2 == COST2.at(i)){\n            cnt++;\n        }else{\n            O2.push_back({ad2, cnt});\n            ad2 = COST2.at(i);\n            cnt++;\n        }\n    }\n    \n    \n    ll ans = INFL;\n    int right = -1;\n    for(int i = 0; i < O1.size(); i++){\n        ll cost = O1.at(i).first;\n        int rest = R - O1.at(i).second;\n        \n        if(rest > O2.at(O2.size()-1).second) continue;\n        int left = -1;\n        if(right == -1){\n            right = O2.size();\n        }\n        int mid;\n        while(right - left > 1){\n            mid = (left + right) / 2;\n            if(O2.at(mid).second >= rest){\n                right = mid;\n            }else{\n                left = mid;\n            }\n        }\n        cost += O2.at(right).first;\n        ans = min(ans, cost);\n    }\n    \n    Ans.push_back(ans);\n    solve();\n    return 0;\n}\n\nint main(void){\n    dy[0] = 1;\n    dy[1] = -1;\n    dx[2] = 1;\n    dx[3] = -1;\n    solve();\n    for(int i = 0; i < Ans.size(); i++){\n        cout << Ans.at(i) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef pair<int,pair<int,int>> PP;\nint r,w[2],h[2],x[2],y[2];\nlong long level[501][501][2];\nbool used[501][501][2]={};\nlong long sparklingdaydream[501][501][2];\nlong long need[250005][2]={};\nlong long s[250005]={},d[250005]={};\nint main(){\n\twhile(1){\n\t\tmemset(need,0,sizeof(need));\n\t\tmemset(s,0,sizeof(s));\n\t\tmemset(d,0,sizeof(d));\n\t\tmemset(used,false,sizeof(used));\n\tpriority_queue<PP,vector<PP>,greater<PP>>pque;\n\tscanf(\"%d\",&r);\n\tif(r==0) break;\n\tscanf(\"%d %d %d %d\",&w[0],&h[0],&x[0],&y[0]);\n\tfor(int r=0;r<501;r++){\n\t\tfor(int g=0;g<501;g++){\n\t\t\t\tsparklingdaydream[r][g][0]=1000000000000;\n\t\t\t\tlevel[r][g][0]=1000000000000;\n\t\t\t}\n\t\t}\n\tfor(int i=1;i<=h[0];i++){\n\t\tfor(int j=1;j<=w[0];j++){\n\t\t\tscanf(\"%lld\",&level[j][i][0]);\n\t\t}\n\t}\n\tsparklingdaydream[x[0]][y[0]][0]=1;\n\tpque.push(make_pair(sparklingdaydream[x[0]][y[0]][0],make_pair(x[0],y[0])));\n\tint dx[3]={0,1,-1};\n\tint dy[3]={0,1,-1};\n\twhile(!pque.empty()){\n\t\tPP p=pque.top();\n\t\tpque.pop();\n\t\tused[p.second.first][p.second.second][0]=true;\n\t\tfor(int k=0;k<3;k++){\n\t\t\tfor(int l=0;l<3;l++){\n\t\t\t\tif(k!=l && (k==0 || l==0)){\n\t\t\t\t\tif(!used[p.second.first+dx[k]][p.second.second+dy[l]][0]){\n\t\t\t\t\t\tif(p.second.first+dx[k]>=1 && p.second.first+dx[k]<=w[0] && p.second.second+dy[l]>=1 && p.second.second+dy[l]<=h[0]){\n\t\t\t\t\t\t\tlong long h=p.first;\n\t\t\t\t\t\t\tsparklingdaydream[p.second.first+dx[k]][p.second.second+dy[l]][0]=max(h,level[p.second.first+dx[k]][p.second.second+dy[l]][0]);\n\t\t\t\t\t\t\tpque.push(make_pair(sparklingdaydream[p.second.first+dx[k]][p.second.second+dy[l]][0],make_pair(p.second.first+dx[k],p.second.second+dy[l])));\n\t\t\t\t\t\t\tused[p.second.first+dx[k]][p.second.second+dy[l]][0]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tfor(int r=0;r<501;r++){\n\t\tfor(int g=0;g<501;g++){\n\t\t\t\tsparklingdaydream[r][g][1]=1000000000000;\n\t\t\t\tlevel[r][g][1]=1000000000000;\n\t\t\t}\n\t\t}\n\tscanf(\"%d %d %d %d\",&w[1],&h[1],&x[1],&y[1]);\n\tfor(int i=1;i<=h[1];i++){\n\t\tfor(int j=1;j<=w[1];j++){\n\t\t\tscanf(\"%lld\",&level[j][i][1]);\n\t\t}\n\t}\n\tsparklingdaydream[x[1]][y[1]][1]=1;\n\tpque.push(make_pair(sparklingdaydream[x[1]][y[1]][1],make_pair(x[1],y[1])));\n\twhile(!pque.empty()){\n\t\tPP p=pque.top();\n\t\tpque.pop();\n\t\tused[p.second.first][p.second.second][1]=true;\n\t\tfor(int k=0;k<3;k++){\n\t\t\tfor(int l=0;l<3;l++){\n\t\t\t\tif(k!=l && (k==0 || l==0)){\n\t\t\t\t\tif(!used[p.second.first+dx[k]][p.second.second+dy[l]][1]){\n\t\t\t\t\t\tif(p.second.first+dx[k]>=1 && p.second.first+dx[k]<=w[1] && p.second.second+dy[l]>=1 && p.second.second+dy[l]<=h[1]){\n\t\t\t\t\t\t\tlong long h=p.first;\n\t\t\t\t\t\t\tsparklingdaydream[p.second.first+dx[k]][p.second.second+dy[l]][1]=max(h,level[p.second.first+dx[k]][p.second.second+dy[l]][1]);\n\t\t\t\t\t\t\tpque.push(make_pair(sparklingdaydream[p.second.first+dx[k]][p.second.second+dy[l]][1],make_pair(p.second.first+dx[k],p.second.second+dy[l])));\n\t\t\t\t\t\t\tused[p.second.first+dx[k]][p.second.second+dy[l]][1]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tint g=0;\n\tfor(int i=1;i<=w[0];i++){\n\t\tfor(int j=1;j<=h[0];j++){\n\t\t\ts[g]=sparklingdaydream[i][j][0];\n\t\t\tg++;\n\t\t}\n\t}\n\tsort(s,s+g);\n\tint eee=1;\n\tfor(int i=0;i<g;i++){\n\t\tif(s[i]!=s[i+1]){\n\t\t\tfor(int j=eee;j<=i+1;j++){\n\t\t\t\tneed[j][0]=s[i];\n\t\t\t\teee=i+2;\n\t\t\t}\n\t\t}\n\t}\n\tg=0;\n\tfor(int i=1;i<=w[1];i++){\n\t\tfor(int j=1;j<=h[1];j++){\n\t\t\td[g]=sparklingdaydream[i][j][1];\n\t\t\tg++;\n\t\t}\n\t}\n\tsort(d,d+g);\n\teee=1;\n\tfor(int i=0;i<g;i++){\n\t\tif(d[i]!=d[i+1]){\n\t\t\tfor(int j=eee;j<=i+1;j++){\n\t\t\t\tneed[j][1]=d[i];\n\t\t\t\teee=i+2;\n\t\t\t}\n\t\t}\n\t}\n\tlong long ans=10000000000;\n\tfor(int i=1;i<250005;i++){\n\t\tfor(int j=0;j<2;j++){\n\t\t\tif(!need[i][j]){\n\t\t\tneed[i][j]=10000000000000;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=r;i++){\n\t\tans=min(ans,need[i][0]+need[r-i][1]);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\n\nclass union_find {\n\tvector<int> par;\n\tvector<int> rank;\n\tint find(int a) {\n\t\treturn par[a] < 0 ? a : par[a] = find(par[a]);\n\t}\npublic:\n\tunion_find(int n) : par(n, -1), rank(n, 1) {}\n\tbool same(int a, int b) {\n\t\treturn find(a) == find(b);\n\t}\n\tvoid unite(int a, int b) {\n\t\ta = find(a);\n\t\tb = find(b);\n\t\tif (a == b) return;\n\t\tif (rank[a] > rank[b]) {\n\t\t\tpar[a] += par[b];\n\t\t\tpar[b] = a;\n\t\t}\n\t\telse {\n\t\t\tpar[b] += par[a];\n\t\t\tpar[a] = b;\n\t\t\tif (rank[a] == rank[b]) rank[b]++;\n\t\t}\n\t}\n\tint size(int a) {\n\t\treturn -par[find(a)];\n\t}\n};\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint R;\n\twhile (cin >> R, R) {\n\t\tvector<vector<int>> v(2);\n\t\tfor (int k = 0; k < 2; k++) {\n\t\t\tint W, H, X, Y;\n\t\t\tcin >> W >> H >> X >> Y; X--, Y--;\n\t\t\tvector<vector<int>> a(H, vector<int>(W));\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tcin >> a[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tvector<int> cs;\n\t\t\tvector<vector<int>> es;\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tif (i + 1 < H) {\n\t\t\t\t\t\tcs.push_back(max(a[i][j], a[i][j + 1]));\n\t\t\t\t\t\tes.push_back(vector<int>({ max(a[i][j], a[i + 1][j]), i * W + j, (i + 1) * W + j }));\n\t\t\t\t\t}\n\t\t\t\t\tif (j + 1 < W) {\n\t\t\t\t\t\tcs.push_back(max(a[i][j], a[i][j + 1]));\n\t\t\t\t\t\tes.push_back(vector<int>({ max(a[i][j], a[i][j + 1]), i * W + j, i * W + j + 1 }));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort(cs.begin(), cs.end());\n\t\t\tcs.erase(unique(cs.begin(), cs.end()), cs.end());\n\t\t\tsort(es.begin(), es.end());\n\n\t\t\tv[k].assign(H * W + 1, INF);\n\t\t\tv[k][0] = 0;\n\t\t\tv[k][1] = 1;\n\t\t\tunion_find uf(H * W);\n\t\t\tfor (int i = 0, j = 0; i < (int)cs.size(); i++) {\n\t\t\t\twhile (j < (int)es.size() && es[j][0] == cs[i]) {\n\t\t\t\t\tuf.unite(es[j][1], es[j][2]);\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tint sz = uf.size(Y * W + X);\n\t\t\t\tv[k][sz] = min(v[k][sz], cs[i]);\n\t\t\t}\n\t\t\tfor (int i = H * W - 1; i >= 2; i--) {\n\t\t\t\tv[k][i] = min(v[k][i], v[k][i + 1]);\n\t\t\t}\n\t\t}\n\t\tint res = 1e9;\n\t\tfor (int i = 0; i < (int)v[0].size(); i++) if (0 <= R - i && R - i < (int)v[1].size()) {\n\t\t\tres = min(res, v[0][i] + v[1][R - i]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reps(i,n) for(int i=1;i<=n;i++)\n\nconst int INF=1010000000;\n\nint R;\nint w[2],h[2],st[2],gl[2];\nint masu[2][501][501];\n\nint need[2][25001];\n\nint visit[501][501];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nint glcont;\n\nvoid saiki(int w,int h,int x,int y,int masu[501][501],int mn){\n\tif(x<0 || y<0 || x>=w || y>=h)return;\n\tif(masu[x][y]>mn)return;\n\tif(visit[x][y]==1)return;\n\tvisit[x][y]=1;\n\t\n\t\n\trep(i,4){\n\t\tsaiki(w,h,x+dx[i],y+dy[i],masu,mn);\n\t}\n\t\n\tglcont++;\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d\",&R);\n\t\tif(R==0)break;\n\t\t\n\t\trep(i,2){\n\t\t\tscanf(\"%d%d%d%d\",&w[i],&h[i],&st[i],&gl[i]);\n\t\t\t\n\t\t\trep(j,h[i]){\n\t\t\t\trep(k,w[i]){\n\t\t\t\t\tscanf(\"%d\",&masu[i][k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint left,right;\n\t\tleft=0;\n\t\tright=1000000001;\n\t\trep(i,2)rep(j,250001)need[i][j]=INF;\n\t\trep(i,2){\n\t\t\trep(n,w[i]*h[i]+1){\n\t\t\t\tint left,right;\n\t\t\t\tleft=0;right=1000000001;\n\t\t\t\t\n\t\t\t\twhile(1){\n\t\t\t\t\tdouble half= double(left+right)/2.0;\n\t\t\t\t\trep(rr,w[i])rep(ee,h[i])visit[rr][ee]=0;\n\t\t\t\t\tglcont=0;\n\t\t\t\t\t\n\t\t\t\t\tsaiki(w[i],h[i],st[i]-1,gl[i]-1,masu[i],int(half));\n\t\t\t\t\t\n\t\t\t\t\tif(glcont<n){\n\t\t\t\t\t\tleft=half+0.5;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tright=half;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(left==right){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tneed[i][n]=left;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint mini=INF*2+1;\n\t\t\n\t\tint dd=0;\n\t\tif(w[0]*h[0] < w[1]+h[1]){\n\t\t\tdd=1;\n\t\t}\n\t\t\n\t\trep(i,250001){\n\t\t\tif(R-i<0)break;\n\t\t\tmini = min(mini, need[dd][i] + need[!dd][R-i]);\n\t\t}\n\t\t/*\n\t\trep(i,2){\n\t\t\tputs(\"\");\n\t\t\trep(n,w[i]*h[i]+1){\n\t\t\t\tprintf(\"%d %d\\n\",n,need[i][n]);\n\t\t\t}\n\t\t}*/\n\t\tprintf(\"%d\\n\",mini);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <functional>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int INF = 1000000000;\n\nvector<pii> gettable(){\n\tint w, h, x, y;\n\tscanf(\"%d%d%d%d\", &w, &h, &x, &y);\n\n\tvector<int> Ls(1, 0);\n\tvector<vector<int> > L(h + 2, vector<int>(w + 2, -1));\n\tfor(int i = 1; i <= h; ++i)\n\tfor(int j = 1; j <= w; ++j){\n\t\tscanf(\"%d\", &L[i][j]);\n\t\tLs.push_back(L[i][j]);\n\t}\n\tLs.push_back(INF);\n\tsort(Ls.begin(), Ls.end());\n\tLs.erase(unique(Ls.begin(), Ls.end()), Ls.end());\n\tfor(int i = 1; i <= h; ++i)\n\tfor(int j = 1; j <= w; ++j){\n\t\tL[i][j] = lower_bound(Ls.begin(), Ls.end(), L[i][j]) - Ls.begin();\n\t}\n\n\tvector<pii> res(Ls.size());\n\tfor(int i = 0; i < Ls.size(); ++i){\n\t\tres[i].second = Ls[i];\n\t}\n\n\tpriority_queue<pii,vector<pii>,greater<pii> > pq;\n\tpq.push(pii(L[y][x], y << 16 | x));\n\t++res[L[y][x]].first;\n\tL[y][x] = -1;\n\twhile(!pq.empty()){\n\t\tint a = pq.top().first;\n\t\ty = pq.top().second >> 16 & 0xffff;\n\t\tx = pq.top().second & 0xffff;\n\t\tpq.pop();\n\n\t\tfor(int i = 0; i < 4; ++i){\n\t\t\tint ny = y + dy[i], nx = x + dx[i];\n\t\t\tif(L[ny][nx] >= 0){\n\t\t\t\tint b = max(a, L[ny][nx]);\n\t\t\t\t++res[b].first;\n\t\t\t\tpq.push(pii(b, ny << 16 | nx));\n\t\t\t\tL[ny][nx] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 1; i < res.size(); ++i){\n\t\tres[i].first += res[i - 1].first;\n\t}\n\n\treturn res;\n}\n\nint main(){\n\tint r;\n\twhile(scanf(\"%d\", &r), r){\n\t\tvector<pii> v = gettable(), w = gettable();\n\t\tint ans = INF;\n\t\tfor(int i = 0; i < v.size(); ++i){\n\t\t\tpii tmp(r - v[i].first, -INF);\n\t\t\tint k = lower_bound(w.begin(), w.end(), tmp)->second;\n\t\t\tans = min(ans, v[i].second + k);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint room[2][500][500];\nchar v[500][500];\nint num, count;\nint r;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nvoid dfs(int which, int ty, int tx, int level, int y, int x)\n{\n    int i;\n    int my, mx;\n    \n    v[ty][tx] = 1;\n    count++;\n    if (num + count >= r){\n        return;\n    }\n    for (i = 0; i < 4; i++){\n        my = ty + dy[i];\n        mx = tx + dx[i];\n        if (0 <= mx && mx < x && 0 <= my && my < y && v[my][mx] == 0 && room[which][my][mx] <= level){\n            dfs(which, my, mx, level, y, x);\n        }\n    }\n}\n\nint main(void)\n{\n    int w1, h1, sx1, sy1;\n    int w2, h2, sx2, sy2;\n    int i, j;\n    int left, right, center;\n    int ileft, iright, icenter;\n    int res;\n    \n    while (1){\n        scanf(\"%d\", &r);\n        \n        if (r == 0){\n            break;\n        }\n        \n        scanf(\"%d%d%d%d\", &w1, &h1, &sx1, &sy1);\n        sx1--;\n        sy1--;\n        \n        for (i = 0; i < h1; i++){\n            for (j = 0; j < w1; j++){\n                scanf(\"%d\", &room[0][i][j]);\n            }\n        }\n        \n        scanf(\"%d%d%d%d\", &w2, &h2, &sx2, &sy2);\n        sx2--;\n        sy2--;\n        \n        for (i = 0; i < h2; i++){\n            for (j = 0; j < w2; j++){\n                scanf(\"%d\", &room[1][i][j]);\n            }\n        }\n        \n        left = 0;\n        right = 100000000;\n        res = 999999999;\n        while (left != right){\n            center = (left + right) / 2;\n            num = count = 0;\n            memset(v, 0, sizeof(v));\n            if (center > 0){\n                dfs(0, sy1, sx1, center, h1, w1);\n            }\n            num += count;\n            \n            ileft = 0;\n            iright = 100000000;\n            while (ileft < iright){\n                icenter = (ileft + iright) / 2;\n                \n                count = 0;\n                memset(v, 0, sizeof(v));\n                if (center > 0){\n                    dfs(1, sy2, sx2, icenter, h2, w2);\n                }\n                \n                if (num + count >= r){\n                    iright = icenter;\n                }\n                else {\n                    ileft = icenter + 1;\n                }\n            }\n            if (ileft > iright){\n                ileft = iright = 1000000000;\n            }\n            \n            if (ileft + center < res){\n                res = ileft + center;\n                right = center;\n            }\n            else {\n                left = center + 1;\n            }\n        }\n        \n        printf(\"%d\\n\", res);\n    }\n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint room[2][500][500];\nchar v[500][500];\nint count;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nvoid dfs(int which, int ty, int tx, int level, int y, int x)\n{\n    int i;\n    int my, mx;\n    \n    v[ty][tx] = 1;\n    count++;\n    \n    for (i = 0; i < 4; i++){\n        my = ty + dy[i];\n        mx = tx + dx[i];\n        if (0 <= mx && mx < x && 0 <= my && my < y && v[my][mx] == 0 && room[which][my][mx] <= level){\n            dfs(which, my, mx, level, y, x);\n        }\n    }\n}\n\nint main(void)\n{\n    int r;\n    int w1, h1, sx1, sy1;\n    int w2, h2, sx2, sy2;\n    int i, j;\n    int left, right, center;\n    int ileft, iright, icenter;\n    int num, res;\n    \n    while (1){\n        scanf(\"%d\", &r);\n        \n        if (r == 0){\n            break;\n        }\n        \n        scanf(\"%d%d%d%d\", &w1, &h1, &sx1, &sy1);\n        sx1--;\n        sy1--;\n        \n        for (i = 0; i < h1; i++){\n            for (j = 0; j < w1; j++){\n                scanf(\"%d\", &room[0][i][j]);\n            }\n        }\n        \n        scanf(\"%d%d%d%d\", &w2, &h2, &sx2, &sy2);\n        sx2--;\n        sy2--;\n        \n        for (i = 0; i < h2; i++){\n            for (j = 0; j < w2; j++){\n                scanf(\"%d\", &room[1][i][j]);\n            }\n        }\n        \n        left = 0;\n        right = 100000000;\n        res = 999999999;\n        while (left != right){\n            center = (left + right) / 2;\n            num = count = 0;\n            memset(v, 0, sizeof(v));\n            if (center > 0){\n                dfs(0, sy1, sx1, center, h1, w1);\n            }\n            num += count;\n            \n            ileft = 0;\n            iright = 100000000;\n            while (ileft < iright){\n                icenter = (ileft + iright) / 2;\n                \n                count = 0;\n                memset(v, 0, sizeof(v));\n                if (center > 0){\n                    dfs(1, sy2, sx2, icenter, h2, w2);\n                }\n                \n                if (num + count >= r){\n                    iright = icenter;\n                }\n                else {\n                    ileft = icenter + 1;\n                }\n            }\n            if (ileft > iright){\n                ileft = iright = 1000000000;\n            }\n            \n            if (ileft + center < res){\n                res = ileft + center;\n                right = center;\n            }\n            else {\n                left = center + 1;\n            }\n        }\n        \n        printf(\"%d\\n\", res);\n    }\n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX (500000)\nint room[2][500][500];\n\ntypedef struct {\n    int ty, tx;\n} POINT;\n\nPOINT pque[MAX + 1];\nint size;\nint view;\n\nvoid upHeap(int cursor);\nvoid downHeap(int cursor);\n\nvoid swap(POINT *a, POINT *b)\n{\n    POINT temp;\n    \n    temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nvoid insert(POINT x){\n    size++;\n    pque[size] = x;\n    upHeap(size);\n}\n\nPOINT get(void)\n{\n    POINT v = pque[1];\n    pque[1] = pque[size];\n    size--;\n    downHeap(1);\n    return (v);\n}\n\nvoid upHeap(int cursor)\n{\n    int parent;\n    while (1){\n        parent = cursor / 2;\n        if (parent < 1){\n            break;\n        }\n        if (room[view][pque[parent].ty][pque[parent].tx] > room[view][pque[cursor].ty][pque[cursor].tx]){\n            swap(&pque[parent], &pque[cursor]);\n        }\n        else {\n            break;\n        }\n        cursor = parent;\n    }\n}\n\nvoid downHeap(int cursor)\n{\n    int child;\n    while (1){\n        if (cursor > size / 2){\n            break;\n        }\n        child = cursor * 2;\n        if (child < size && room[view][pque[child].ty][pque[child].tx] > room[view][pque[child + 1].ty][pque[child + 1].tx]){\n            child++;\n        }\n        if (room[view][pque[child].ty][pque[child].tx] < room[view][pque[cursor].ty][pque[cursor].tx]){\n            swap(&pque[child], &pque[cursor]);\n        }\n        else {\n            break;\n        }\n        cursor = child;\n    }\n}\n\nint max(int a, int b)\n{\n    return (a > b ? a : b);\n}\n\nint min(int a, int b)\n{\n    return (b > a ? a : b);\n}\n\nint main(void)\n{\n    char v[500][501];\n    int w1, h1, sx1, sy1;\n    int w2, h2, sx2, sy2;\n    int i, j;\n    int r;\n    POINT temp, add;\n    int a1, a2;\n    int dx[] = {1, 0, -1, 0};\n    int dy[] = {0, 1, 0, -1};\n    static int auth1[100001], auth2[100001];\n    int ans;\n    \n    while (1){\n        scanf(\"%d\", &r);\n        \n        if (r == 0){\n            break;\n        }\n        scanf(\"%d%d%d%d\", &w1, &h1, &sx1, &sy1);\n        sx1--;\n        sy1--;\n        for (i = 0; i < h1; i++){\n            for (j = 0; j < w1; j++){\n                scanf(\"%d\", &room[0][i][j]);\n            }\n        }\n        size = view = 0;\n        memset(pque, 0, sizeof(pque));\n        memset(v, 0, sizeof(v));\n        add.ty = sy1;\n        add.tx = sx1;\n        v[add.ty][add.tx] = 1;\n        insert(add);\n        memset(auth1, 0, sizeof(auth1));\n        for (i = 1; i <= r; i++){\n            auth1[i] = 100000000;\n            if (size == 0){\n                continue;\n            }\n            temp = get();\n            auth1[i] = max(auth1[i - 1], room[0][temp.ty][temp.tx]);\n            for (j = 0; j < 4; j++){\n                add.tx = temp.tx + dx[j];\n                add.ty = temp.ty + dy[j];\n                if (0 <= add.tx && add.tx < w1 && 0 <= add.ty && add.ty < h1 && !v[add.ty][add.tx]){\n                    v[add.ty][add.tx] = 1;\n                    insert(add);\n                }\n            }\n        }\n        \n        scanf(\"%d%d%d%d\", &w2, &h2, &sx2, &sy2);\n        sx2--;\n        sy2--;\n        for (i = 0; i < h2; i++){\n            for (j = 0; j < w2; j++){\n                scanf(\"%d\", &room[1][i][j]);\n            }\n        }\n        view++;\n        add.ty = sy2;\n        add.tx = sx2;\n        size = 0;\n        memset(pque, 0, sizeof(pque));\n        memset(v, 0, sizeof(v));\n        v[add.ty][add.tx] = 1;\n        insert(add);\n        memset(auth2, 0, sizeof(auth2));\n        for (i = 1; i <= r; i++){\n            auth2[i] = 100000000;\n            if (size == 0){\n                continue;\n            }\n            temp = get();\n            auth2[i] = max(auth2[i - 1], room[1][temp.ty][temp.tx]);\n            for (j = 0; j < 4; j++){\n                add.tx = temp.tx + dx[j];\n                add.ty = temp.ty + dy[j];\n                \n                if (0 <= add.tx && add.tx < w2 && 0 <= add.ty && add.ty < h2 && !v[add.ty][add.tx]){\n                    v[add.ty][add.tx] = 1;\n                    insert(add);\n                }\n            }\n        }\n        \n        ans = 1000000000;\n        for (i = 0; i <= r; i++){\n            ans = min(auth1[i] + auth2[r - i], ans);\n        }\n        \n        printf(\"%d\\n\", ans);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint m[501][501]={0};\nint s[501][501]={0};\nconst int X[]={0,1,0,-1};\nconst int Y[]={1,0,-1,0};\nvoid f(int x,int y){\n  int i,ny,nx;\n  for(i=0;i<4;i++){\n    nx=x+X[i];\n    ny=y+Y[i];\n    if(m[ny][nx]==0)continue;\n    if(s[ny][nx]==0||s[ny][nx]>s[y][x]&&s[ny][nx]>m[ny][nx]){\n      s[ny][nx]=s[y][x];\n      if(s[ny][nx]<m[ny][nx])s[ny][nx]=m[ny][nx];\n      f(nx,ny);\n    }\n  }\n  return;\n}\nint main(){\n  int n,w,h,x,y,i,j,ans,r,h1;\n  while(scanf(\"%d\",&n),n){\n    int ba[100000]={0};\n    int bb[100000]={0};\n    int  d[100000][2]={0};\n    scanf(\"%d %d %d %d\",&w,&h,&x,&y);\n    h1=w*h;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++)scanf(\"%d\",&m[i+1][j+1]);\n    }\n    s[y][x]=1;\n    f(x,y);//printf(\"\\n\");\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tba[s[i+1][j+1]]++;//printf(\"%d \",s[i+1][j+1]);\n\ts[i+1][j+1]=0;\n\tm[i+1][j+1]=0;\n      }//printf(\"\\n\");\n    }\n    scanf(\"%d %d %d %d\",&w,&h,&x,&y);\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++)scanf(\"%d\",&m[i+1][j+1]);\n    }\n    s[y][x]=1;\n    f(x,y);//printf(\"\\n\");\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tbb[s[i+1][j+1]]++;//printf(\"%d \",s[i+1][j+1]);\n\ts[i+1][j+1]=0;\n\tm[i+1][j+1]=0;\n      }//printf(\"\\n\");\n    }\n    r=1;\n    d[0][0]=d[0][1]=0;\n    for(i=0;d[r-1][0]<n&&d[r-1][0]<h1;i++){\n      if(ba[i]){\n\td[r][0]=d[r-1][0]+ba[i];\n\td[r][1]=i;//printf(\"%d %d\\n\",d[r][0],d[r][1]);\n\tr++;\n      }\n    }r--;\n    h=0;\n    for(j=0;h+d[r][0]<n;j++){\n      h+=bb[j];\n      if(h+d[r][0]>=n)break;\n    }\n    ans=d[r][1]+j++;//printf(\"%d %d\\n\",ans,j);\n    while(r--){\n      for(;j<ans;j++){\n\tif(h+d[r][0]>=n)break;\n\th+=bb[j];//printf(\"%d %d\\n\",j,bb[j]);\n\t//if(h+d[r][0]>=n)break;\n      }//printf(\":%d %d %d\\n\",d[r][1],j-1,h);\n      if(j==ans)break;\n      if(ans>d[r][1]+j-1)ans=d[r][1]+j-1;\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint room[2][500][500];\nchar v[500][501];\nint count;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint min(int a, int b)\n{\n    return (b > a ? a : b);\n}\n\nvoid dfs(int which, int ty, int tx, int level, int y, int x, int target)\n{\n    int i;\n    int my, mx;\n    \n    v[ty][tx] = 1;\n    count++;\n    if (count >= target){\n        return;\n    }\n    for (i = 0; i < 4; i++){\n        my = ty + dy[i];\n        mx = tx + dx[i];\n        if (0 <= mx && mx < x && 0 <= my && my < y && v[my][mx] == 0 && room[which][my][mx] <= level){\n            dfs(which, my, mx, level, y, x, target);\n        }\n    }\n}\n\nint main(void)\n{\n    int w1, h1, sx1, sy1;\n    int w2, h2, sx2, sy2;\n    int i, j;\n    int r;\n    int left, right, center;\n    int auth1[100001], auth2[100001];\n    int ans;\n    \n    while (1){\n        scanf(\"%d\", &r);\n        \n        if (r == 0){\n            break;\n        }\n        \n        scanf(\"%d%d%d%d\", &w1, &h1, &sx1, &sy1);\n        sx1--;\n        sy1--;\n        for (i = 0; i < h1; i++){\n            for (j = 0; j < w1; j++){\n                scanf(\"%d\", &room[0][i][j]);\n            }\n        }\n        \n        for (i = 0; i <= r; i++){\n            auth1[i] = 1000000000;\n            left = 0;\n            right = 100000000;\n            while (left != right){\n                center = (left + right) / 2;\n                \n                memset(v, 0, sizeof(v));\n                count = 0;\n                dfs(0, sy1, sx1, center, h1, w1, i);\n                \n                if (count >= i){\n                    \n                    right = center;\n                }\n                else {\n                    left = center + 1;\n                }\n            }\n            if (left == right){\n                auth1[i] = left;\n            }\n        }\n        \n        scanf(\"%d%d%d%d\", &w2, &h2, &sx2, &sy2);\n        sx2--;\n        sy2--;\n        for (i = 0; i < h2; i++){\n            for (j = 0; j < w2; j++){\n                scanf(\"%d\", &room[1][i][j]);\n            }\n        }\n        \n        for (i = 0; i <= r; i++){\n            auth2[i] = 1000000000;\n            left = 0;\n            right = 100000000;\n            while (left != right){\n                center = (left + right) / 2;\n                \n                memset(v, 0, sizeof(v));\n                count = 0;\n                dfs(1, sy2, sx2, center, h2, w2, i);\n                \n                if (count >= i){\n                    right = center;\n                }\n                else {\n                    left = center + 1;\n                }\n            }\n            if (left == right){\n                auth2[i] = left;\n            }\n        }\n        \n        ans = 1000000000;\n        for (i = 0; i <= r; i++){\n            ans = min(ans, auth1[i] + auth2[r - i]);\n        }\n        \n        printf(\"%d\\n\", ans);\n    }\n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint room[2][500][500];\nchar v[500][501];\nint count;\nint ma;\nint r;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nvoid dfs(int which, int ty, int tx, int level, int y, int x)\n{\n    int i;\n    int my, mx;\n    \n    v[ty][tx] = 1;\n    count++;\n    if (count >= r){\n        return;\n    }\n    for (i = 0; i < 4; i++){\n        my = ty + dy[i];\n        mx = tx + dx[i];\n        if (0 <= mx && mx < x && 0 <= my && my < y && v[my][mx] == 0 && room[which][my][mx] <= level){\n            if (room[which][my][mx] >= ma){\n                ma = room[which][my][mx];\n            }\n            dfs(which, my, mx, level, y, x);\n        }\n    }\n}\n\nint main(void)\n{\n    int w1, h1, sx1, sy1;\n    int w2, h2, sx2, sy2;\n    int i, j;\n    int left, right, center;\n    int ans;\n    \n    while (1){\n        scanf(\"%d\", &r);\n        \n        if (r == 0){\n            break;\n        }\n        \n        scanf(\"%d%d%d%d\", &w1, &h1, &sx1, &sy1);\n        sx1--;\n        sy1--;\n        for (i = 0; i < h1; i++){\n            for (j = 0; j < w1; j++){\n                scanf(\"%d\", &room[0][i][j]);\n            }\n        }\n        \n        scanf(\"%d%d%d%d\", &w2, &h2, &sx2, &sy2);\n        sx2--;\n        sy2--;\n        for (i = 0; i < h2; i++){\n            for (j = 0; j < w2; j++){\n                scanf(\"%d\", &room[1][i][j]);\n            }\n        }\n        \n        left = 0;\n        right = 200000000;\n        while (left != right){\n            center = (left + right) / 2;\n            \n            memset(v, 0, sizeof(v));\n            count = ma = 0;\n            dfs(0, sy1, sx1, center, h1, w1);\n            memset(v, 0, sizeof(v));\n            dfs(1, sy2, sx2, center - ma, h2, w2);\n            if (count >= r){\n                right = center;\n            }\n            else {\n                left = center + 1;\n            }\n        }\n        \n        printf(\"%d\\n\", left);\n    }\n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint room[2][500][500];\nchar v[500][500];\nint num, count;\nint r;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nvoid dfs(int which, int ty, int tx, int level, int y, int x)\n{\n    int i;\n    int my, mx;\n    \n    v[ty][tx] = 1;\n    count++;\n    if (num + count >= r){\n        return;\n    }\n    for (i = 0; i < 4; i++){\n        my = ty + dy[i];\n        mx = tx + dx[i];\n        if (0 <= mx && mx < x && 0 <= my && my < y && v[my][mx] == 0 && room[which][my][mx] <= level){\n            dfs(which, my, mx, level, y, x);\n        }\n    }\n}\n\nint main(void)\n{\n    int w1, h1, sx1, sy1;\n    int w2, h2, sx2, sy2;\n    int i, j;\n    int left, right, center;\n    int ileft, iright, icenter;\n    int res;\n    \n    while (1){\n        scanf(\"%d\", &r);\n        \n        if (r == 0){\n            break;\n        }\n        \n        scanf(\"%d%d%d%d\", &w1, &h1, &sx1, &sy1);\n        sx1--;\n        sy1--;\n        \n        for (i = 0; i < h1; i++){\n            for (j = 0; j < w1; j++){\n                scanf(\"%d\", &room[0][i][j]);\n            }\n        }\n        \n        scanf(\"%d%d%d%d\", &w2, &h2, &sx2, &sy2);\n        sx2--;\n        sy2--;\n        \n        for (i = 0; i < h2; i++){\n            for (j = 0; j < w2; j++){\n                scanf(\"%d\", &room[1][i][j]);\n            }\n        }\n        \n        left = 0;\n        right = 100000000;\n        res = 999999999;\n        while (left != right){\n            center = (left + right) / 2;\n            num = count = 0;\n            memset(v, 0, sizeof(v));\n            if (center > 0){\n                dfs(0, sy1, sx1, center, h1, w1);\n            }\n            num += count;\n            \n            ileft = 0;\n            iright = 100000000;\n            if (num < r){\n                while (ileft < iright){\n                    icenter = (ileft + iright) / 2;\n                    \n                    count = 0;\n                    memset(v, 0, sizeof(v));\n                    if (center > 0){\n                        dfs(1, sy2, sx2, icenter, h2, w2);\n                    }\n                    \n                    if (num + count >= r){\n                        iright = icenter;\n                    }\n                    else {\n                        ileft = icenter + 1;\n                    }\n                }\n            }\n            if (ileft > iright){\n                ileft = iright = 1000000000;\n            }\n            \n            if (ileft + center < res){\n                res = ileft + center;\n                right = center;\n            }\n            else {\n                left = center + 1;\n            }\n        }\n        \n        printf(\"%d\\n\", res);\n    }\n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0542: Authentication Level\n// 2018.1.28 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n#define QMAX 150000\ntypedef struct { int t; short r, c; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n//\tif (qsize == 0) return 0;\n//\t*n = que[0].node, *t = que[0].t, *c = que[0].c;\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int r, int c, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].r = r, que[i].c = c, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\nint l[501][501];\nint level[2][100001], lsz[2];\nint mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\nchar mk[501][501];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint main()\n{\n    int R, W, H, X, Y;\n\tint i, j, r, c, r2, c2, t, max, ans;\n\n    while (R = in()) {\n        for (i = 0; i < 2; i++) {\n\t\t\tW = in(), H = in(), X = in()-1, Y = in()-1;\n\t\t\tfor (r = 0; r < H; r++) for (c = 0; c < W; c++) l[r][c] = in();\n\n\t\t\tmemset(mk, 0, sizeof(mk));\n\t\t\tqsize = 0, level[i][0] = max = 0, lsz[i] = 1;\n\t\t\tenq(Y, X, l[Y][X]), mk[Y][X] = 1;\n\t\t\twhile (qsize) {\n\t\t\t\tt = que[0].t, r = que[0].r, c = que[0].c, deq();\n\t\t\t\tif (t > max) max = t;\n\t\t\t\tlevel[i][lsz[i]++] = max;\n\n\t\t\t\tfor (j = 0; j < 4; j++) {\n\t\t\t\t\tr2 = r + mv[j][0], c2 = c + mv[j][1];\n\t\t\t\t\tif (r2 < 0 || r2 >= H || c2 < 0 || c2 >= W) continue;\n\t\t\t\t\tif (mk[r2][c2]) continue;\n\t\t\t\t\tmk[r2][c2] = 1;\t\t\t\t// 同一部屋は２度とQに入れない\n\t\t\t\t\tenq(r2, c2, l[r2][c2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans = 0x7ffffff;\n\t\tfor (i = 0; i <= R; i++) {\n\t\t\tj = R - i;\n\t\t\tif (i < lsz[0] && j < lsz[1]) {\n\t\t\t\tt = level[0][i] + level[1][j];\n\t\t\t\tif (t < ans) ans = t;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint m[502][502]={0};\nint s[502][502]={0};\nconst int X[]={0,1,0,-1};\nconst int Y[]={1,0,-1,0};\nvoid f(int x,int y){\n  int i,ny,nx;\n  for(i=0;i<4;i++){\n    nx=x+X[i];\n    ny=y+Y[i];\n    if(m[ny][nx]==0)continue;\n    if(s[ny][nx]==0||s[ny][nx]>s[y][x]&&s[ny][nx]>m[ny][nx]){\n      s[ny][nx]=s[y][x];\n      if(s[ny][nx]<m[ny][nx])s[ny][nx]=m[ny][nx];\n      f(nx,ny);\n    }\n  }\n  return;\n}\nint main(){\n  int n,w,h,x,y,i,j,ans,r,h1;\n  while(scanf(\"%d\",&n),n){\n    int ba[100000]={0};\n    int bb[100000]={0};\n    int  d[100000][2]={0};\n    scanf(\"%d %d %d %d\",&w,&h,&x,&y);\n    h1=w*h;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++)scanf(\"%d\",&m[i+1][j+1]);\n    }\n    s[y][x]=1;\n    f(x,y);//printf(\"\\n\");\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tba[s[i+1][j+1]]++;//printf(\"%d \",s[i+1][j+1]);\n\ts[i+1][j+1]=0;\n\tm[i+1][j+1]=0;\n      }//printf(\"\\n\");\n    }\n    scanf(\"%d %d %d %d\",&w,&h,&x,&y);\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++)scanf(\"%d\",&m[i+1][j+1]);\n    }\n    s[y][x]=1;\n    f(x,y);//printf(\"\\n\");\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tbb[s[i+1][j+1]]++;//printf(\"%d \",s[i+1][j+1]);\n\ts[i+1][j+1]=0;\n\tm[i+1][j+1]=0;\n      }//printf(\"\\n\");\n    }\n    r=1;\n    d[0][0]=d[0][1]=0;\n    for(i=0;d[r-1][0]<n&&d[r-1][0]<h1;i++){\n      if(ba[i]){\n\td[r][0]=d[r-1][0]+ba[i];\n\td[r][1]=i;//printf(\"%d %d\\n\",d[r][0],d[r][1]);\n\tr++;\n      }\n    }r--;\n    h=0;\n    for(j=0;h+d[r][0]<n;j++){\n      h+=bb[j];\n      if(h+d[r][0]>=n)break;\n    }\n    ans=d[r][1]+j++;//printf(\"%d %d\\n\",ans,j);\n    while(r--){\n      for(;j<ans;j++){\n\tif(h+d[r][0]>=n)break;\n\th+=bb[j];//printf(\"%d %d\\n\",j,bb[j]);\n\t//if(h+d[r][0]>=n)break;\n      }//printf(\":%d %d %d\\n\",d[r][1],j-1,h);\n      if(j==ans)break;\n      if(ans>d[r][1]+j-1)ans=d[r][1]+j-1;\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<climits>\nusing namespace std;\nint field[500][500],cost[500][500];\nint R,W,H,X,Y;\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\n\nstruct edge{\n int y,x,cost;\n edge(int y,int x,int cost) : y(y) , x(x) , cost(cost) {}\n};\nbool operator < (const edge &a,const edge &b){\n return a.cost > b.cost;\n}\nvector<int> dijkstra(){\n int x,y,nx,ny,rec;\n vector<int> foo(500000, INT_MAX / 4);\n foo[0] = 0;\n priority_queue<edge> que;\n for(int i = 0; i < H; i++){\n  for(int j = 0; j < W; j++){\n   cost[i][j] = INT_MAX;\n  }\n }\n cost[Y][X] = 1;\n que.push(edge(Y,X,1));\n int rank = 0;\n foo[rank++] = 0;\n while(!que.empty()){\n  edge crt = que.top();\n  que.pop();\n  x = crt.x;\n  y = crt.y;\n  foo[rank] = max(foo[rank - 1], crt.cost);\n  rank++;\n  if(cost[y][x] != crt.cost) continue;\n  for(int i = 0; i < 4; i++){\n   nx = x + dx[i];\n   ny = y + dy[i];\n   if(nx == -1 || ny == -1 || nx ==  W || ny == H)continue;\n   rec = max(field[ny][nx], crt.cost);\n   if(cost[ny][nx] > rec){\n    cost[ny][nx] = rec;\n    que.push(edge(ny,nx,rec));\n   }\n  }\n }\n return foo;\n}  \n\nint main(){\n while(scanf(\"%d\", &R)){\n  if(!R) break;\n  vector<int> f(500000, INT_MAX / 2);\n  vector<int> g(500000, INT_MAX / 2);\n  for(int q = 0; q < 2; q++){\n   scanf(\"%d %d %d %d\", &W,&H,&X,&Y);\n   X--;\n   Y--;\n   for(int i = 0; i < H; i++){\n    for(int j = 0; j < W;j++){\n     scanf(\"%d\",&field[i][j]);\n    }\n   }\n   if (q == 0){\n       f = dijkstra();\n   }\n   else {\n       g = dijkstra();\n   }\n  }\n  int res = INT_MAX;\n  for (int i = 0; i <= R; i++){\n    res = min(res, f[i] + g[R - i]);\n  }\n  printf(\"%d\\n\", res);\n }\n return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint m[500][500]={0};\nint s[500][500]={0};\nconst int X[]={0,1,0,-1};\nconst int Y[]={1,0,-1,0};\nvoid f(int x,int y){\n  int i,ny,nx;\n  for(i=0;i<4;i++){\n    nx=x+X[i];\n    ny=y+Y[i];\n    if(m[ny][nx]==0)continue;\n    if(s[ny][nx]==0||s[ny][nx]>s[y][x]&&s[ny][nx]>m[ny][nx]){\n      s[ny][nx]=s[y][x];\n      if(s[ny][nx]<m[ny][nx])s[ny][nx]=m[ny][nx];\n      f(nx,ny);\n    }\n  }\n  return;\n}\nint main(){\n  int n,w,h,x,y,i,j,ans,r,h1;\n  while(scanf(\"%d\",&n),n){\n    int ba[100000]={0};\n    int bb[100000]={0};\n    int  d[100000][2]={0};\n    scanf(\"%d %d %d %d\",&w,&h,&x,&y);\n    h1=w*h;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++)scanf(\"%d\",&m[i+1][j+1]);\n    }\n    s[y][x]=1;\n    f(x,y);//printf(\"\\n\");\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tba[s[i+1][j+1]]++;//printf(\"%d \",s[i+1][j+1]);\n\ts[i+1][j+1]=0;\n\tm[i+1][j+1]=0;\n      }//printf(\"\\n\");\n    }\n    scanf(\"%d %d %d %d\",&w,&h,&x,&y);\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++)scanf(\"%d\",&m[i+1][j+1]);\n    }\n    s[y][x]=1;\n    f(x,y);//printf(\"\\n\");\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tbb[s[i+1][j+1]]++;//printf(\"%d \",s[i+1][j+1]);\n\ts[i+1][j+1]=0;\n\tm[i+1][j+1]=0;\n      }//printf(\"\\n\");\n    }\n    r=1;\n    d[0][0]=d[0][1]=0;\n    for(i=0;d[r-1][0]<n&&d[r-1][0]<h1;i++){\n      if(ba[i]){\n\td[r][0]=d[r-1][0]+ba[i];\n\td[r][1]=i;//printf(\"%d %d\\n\",d[r][0],d[r][1]);\n\tr++;\n      }\n    }r--;\n    h=0;\n    for(j=0;h+d[r][0]<n;j++){\n      h+=bb[j];\n      if(h+d[r][0]>=n)break;\n    }\n    ans=d[r][1]+j++;//printf(\"%d %d\\n\",ans,j);\n    while(r--){\n      for(;j<ans;j++){\n\tif(h+d[r][0]>=n)break;\n\th+=bb[j];//printf(\"%d %d\\n\",j,bb[j]);\n\t//if(h+d[r][0]>=n)break;\n      }//printf(\":%d %d %d\\n\",d[r][1],j-1,h);\n      if(j==ans)break;\n      if(ans>d[r][1]+j-1)ans=d[r][1]+j-1;\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0542: Authentication Level\n// 2018.1.28 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n#define QMAX 150000\ntypedef struct { int t; short r, c; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n//\tif (qsize == 0) return 0;\n//\t*n = que[0].node, *t = que[0].t, *c = que[0].c;\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int r, int c, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].r = r, que[i].c = c, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\nint l[501][501];\nint level[2][100001], lsz[2];\nint mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\nchar mk[501][501];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint main()\n{\n    int R, W, H, X, Y;\n\tint i, j, r, c, r2, c2, t, max, ans;\n\n    while (R = in()) {\n        for (i = 0; i < 2; i++) {\n\t\t\tW = in(), H = in(), X = in()-1, Y = in()-1;\n\t\t\tfor (r = 0; r < H; r++) for (c = 0; c < W; c++) l[r][c] = in();\n\n\t\t\tmemset(mk, 0, sizeof(mk));\n\t\t\tqsize = 0, level[i][0] = max = 0, lsz[i] = 1;\n\t\t\tenq(Y, X, l[Y][X]), mk[Y][X] = 1;\n\t\t\twhile (qsize) {\n\t\t\t\tt = que[0].t, r = que[0].r, c = que[0].c, deq();\n\t\t\t\tif (t > max) max = t;\n\t\t\t\tlevel[i][lsz[i]++] = max;\n\t\t\t\tif (lsz[i] > R) break;\n\n\t\t\t\tfor (j = 0; j < 4; j++) {\n\t\t\t\t\tr2 = r + mv[j][0], c2 = c + mv[j][1];\n\t\t\t\t\tif (r2 < 0 || r2 >= H || c2 < 0 || c2 >= W) continue;\n\t\t\t\t\tif (mk[r2][c2]) continue;\n\t\t\t\t\tmk[r2][c2] = 1;\t\t\t\t// 同一部屋は２度とQに入れない\n\t\t\t\t\tenq(r2, c2, l[r2][c2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans = 0x7ffffff;\n\t\tmax = lsz[0]; if (max > R+1) max = R+1;\n\t\tfor (i = 0; i < max; i++) {\n\t\t\tj = R - i;\n\t\t\tif (j < lsz[1]) {\n\t\t\t\tt = level[0][i] + level[1][j];\n\t\t\t\tif (t < ans) ans = t;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "Kotlin",
    "code": "\nimport java.util.*\n\nfun main(args:Array<String>):Unit {\n    while (true){\n        val r = readLine()!!.trim().toInt()\n        if (r == 0) return\n        val (w1, h1, x1, y1) = readLine()!!.trim().split(' ').map(String::toInt)\n        val office1 = Array(h1){readLine()!!.trim().split(' ').map(String::toInt).toIntArray()}\n        val (w2, h2, x2, y2) = readLine()!!.trim().split(' ').map(String::toInt)\n        val office2 = Array(h2){readLine()!!.trim().split(' ').map(String::toInt).toIntArray()}\n        val office1Level = calRLevel(office1, Point(x1 - 1, y1 - 1))\n        val office2Level = calRLevel(office2, Point(x2 - 1, y2 - 1))\n        var minRLevel = Int.MAX_VALUE\n        val maxSize = minOf(r, w1 * h1)\n        val minSize = maxOf(0, r - w2 * h2)\n        for (i in minSize .. maxSize){\n            if (minRLevel > office1Level[i] + office2Level[r - i])\n                minRLevel = office1Level[i] + office2Level[r - i]\n        }\n        println(minRLevel)\n    }\n}\ndata class Point(val x:Int, val y:Int) {\n    operator fun plus(that:Point):Point = Point(x + that.x, y + that.y)\n}\nfun Point.neighbors():Iterable<Point> {\n    return listOf(Point(1, 0), Point(0, 1), Point(-1, 0), Point(0, -1)).map{it + this}\n}\nfun calRLevel(securityLevels:Array<IntArray>, start:Point):IntArray{\n    val height = securityLevels.size\n    val width = securityLevels.first().size\n    val res = IntArray(height * width + 1){0}\n    val queue = PriorityQueue<Pair<Int, Point>>(compareBy(Pair<Int, Point>::first))\n    val isSearched = Array(height){BooleanArray(width){false}}\n    isSearched[start.y][start.x] = true\n    queue.add(Pair(securityLevels[start.y][start.x], start))\n    var max = 1\n    var idx = 1\n    while (queue.isNotEmpty()){\n        val top = queue.remove()\n        if (max < top.first)\n            max = top.first\n        res[idx++] = max\n        top.second.neighbors().forEach {\n            if (it.x in 0 until width && it.y in 0 until height && !isSearched[it.y][it.x]){\n                isSearched[it.y][it.x] = true\n                queue.add(Pair(securityLevels[it.y][it.x], it))\n            }\n        }\n    }\n    return res\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 400000000;\n\tint r;\n\tScanner sc;\n\n\tvoid run() {\n\t\tsc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tr = sc.nextInt();\n\t\t\tif( r == 0) break;\n\t\t\tPair[] a = scan();\n\t\t\tPair[] b = scan();\n//\t\t\tfor(Pair p: a) debug(p.f, p.s);\n//\t\t\tfor(Pair p: b) debug(p.f, p.s);\n\n\t\t\tint min = INF;\n\t\t\tint i=0,j=b.length-1;\n\t\t\tfor(;;) {\n\t\t\t\tif(i == a.length || j == -1) break;\n\t\t\t\tif(a[i].s+b[j].s >= r) {\n\t\t\t\t\tmin = min(a[i].f + b[j].f, min);\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\n\tint w, h;\n\tint[][] map;\n\tboolean[][] visited;\n\tint sx, sy;\n\n\tPair[] scan() {\n\t\tw = sc.nextInt();\n\t\th = sc.nextInt();\n\t\tmap = new int[h+2][w+2];\n\t\tvisited = new boolean[h+2][w+2];\n\n\t\tfor(int[] a: map) fill(a, INF);\n\n\t\tsx = sc.nextInt();\n\t\tsy = sc.nextInt();\n\n\t\tfor(int i=1;i<=h;i++) for(int j=1;j<=w;j++)\n\t\t\tmap[i][j] = Integer.parseInt(sc.next());\n//\t\tfor(int[] a: map) debug(a);\n\t\tPriorityQueue<P> que = new PriorityQueue<P>(1, new Comp());\n\t\tque.add(new P(sx, sy));\n\t\tLinkedList<Pair> pairs = new LinkedList<Pair>();\n\t\tvisited[sy][sx] = true;\n\t\tfor(;;) {\n\t\t\tP p = que.remove();\n//\t\t\tdebug(p.x, p.y, map[p.y][p.x]);\n\t\t\tif( map[p.y][p.x]== INF ) break;\n\n\t\t\tfor(int i=0;i<4;i++) if( !visited[p.y+dy[i]][p.x+dx[i]] ) {\n\t\t\t\tque.add(new P(p.x+dx[i], p.y+dy[i]));\n\t\t\t\tvisited[p.y+dy[i]][p.x+dx[i]] = true;\n\t\t\t}\n\n\t\t\tpairs.add( new Pair( map[p.y][p.x], bfs(que, map[p.y][p.x]) ) );\n\n\n\t\t}\n\n\t\tPair[] pp = new Pair[pairs.size()+1];\n\t\tpp[0] = new Pair(0, 0);\n\t\tint size = pairs.size();\n\t\tfor(int i=1;i<=size;i++) {\n\t\t\tPair pair = pairs.remove();\n\t\t\tpp[i] = new Pair( pair.f, pair.s + pp[i-1].s );\n\t\t}\n\n\t\treturn pp;\n\t}\n\n\tint dx[] = {-1,0,1,0};\n\tint dy[] = {0,-1,0,1};\n\n\tint bfs(PriorityQueue<P> que, int lev) {\n\t\tint cnt = 1;\n\t\tif(que.isEmpty()) return cnt;\n\t\tfor(;;) {\n\t\t\tP p = que.remove();\n\t\t\tif( map[p.y][p.x] > lev  ) {\n\t\t\t\tque.add(p);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcnt++;\n\t\t\tfor(int i=0;i<4;i++) if( !visited[p.y+dy[i]][p.x+dx[i]] ) {\n\t\t\t\tque.add(new P(p.x+dx[i], p.y+dy[i]));\n\t\t\t\tvisited[p.y+dy[i]][p.x+dx[i]] = true;\n\t\t\t}\n\t\t}\n\n\t\treturn cnt;\n\t}\n\n\tclass Pair {\n\t\tint f,s;\n\t\tPair(int f, int s ) {\n\t\t\tthis.f = f;\n\t\t\tthis.s = s;\n\t\t}\n\t}\n\n\tclass Comp implements Comparator<P> {\n\n\t\t@Override\n\t\tpublic int compare(P o1, P o2) {\n\t\t\t// TODO 自動生成されたメソッド・スタブ\n\t\t\treturn map[o1.y][o1.x] - map[o2.y][o2.x];\n\t\t}\n\n\t}\n\n\tclass P {\n\t\tint x, y;\n\t\tP (int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tr = scanner.nextInt();\n\t\t\tif (r == 0)\n\t\t\t\tbreak;\n\t\t\tmap = new int[2][250001];\n\t\t\tfor (int[] ma : map)\n\t\t\t\tArrays.fill(ma, 1 << 30);\n\t\t\tmap[0][0] = map[1][0] = 0;\n\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\tw = scanner.nextInt();\n\t\t\t\th = scanner.nextInt();\n\t\t\t\tsx = scanner.nextInt() - 1;\n\t\t\t\tsy = scanner.nextInt() - 1;\n\t\t\t\tint[][] m = new int[h][w];\n\t\t\t\tfor (int j = 0; j < h; j++)\n\t\t\t\t\tfor (int k = 0; k < w; k++)\n\t\t\t\t\t\tm[j][k] = scanner.nextInt();\n\t\t\t\tslove(m, i);\n\t\t\t}\n\t\t\tint res = 1 << 30;\n\t\t\tfor (int i = 0; i <= r; i++) {\n\t\t\t\tres = Math.min(res, map[0][i] + map[1][r - i]);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\n\t\t}\n\t}\n\n\tprivate void slove(int[][] m, int i) {\n\t\tboolean[][] b = new boolean[h][w];\n\t\tint id = 1;\n\t\tint l = -1;\n\t\tb[sy][sx] = true;\n\t\tPriorityQueue<Point> pq = new PriorityQueue<Point>();\n\t\tpq.offer(new Point(m[sy][sx], sy, sx));\n\t\twhile (!pq.isEmpty()) {\n\t\t\tPoint point = pq.poll();\n\t\t\tl = Math.max(l, point.k);\n\t\t\tmap[i][id++] = l;\n\t\t\tfor (int[] mo : move) {\n\t\t\t\tint ny = point.y + mo[0];\n\t\t\t\tint nx = point.x + mo[1];\n\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (b[ny][nx])\n\t\t\t\t\tcontinue;\n\t\t\t\tb[ny][nx] = true;\n\t\t\t\tpq.offer(new Point(m[ny][nx], ny, nx));\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean isOK(int ny, int nx) {\n\t\tif (0 <= ny && ny < h && 0 <= nx && nx < w)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tint r, w, h, sx, sy;\n\tint[][] map;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\n\tclass Point implements Comparable<Point> {\n\t\tint k, y, x;\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Point [k=\" + k + \", y=\" + y + \", x=\" + x + \"]\";\n\t\t}\n\n\t\tpublic Point(int k, int y, int x) {\n\t\t\tsuper();\n\t\t\tthis.k = k;\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Point o) {\n\t\t\treturn this.k - o.k;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.Map.Entry;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\npublic class Main {\n\n\tpublic static final long INF = Long.MAX_VALUE / 4 - 1;\n\t\n\tpublic static final int[][] move_dir = new int[][]{\n\t\t{1, 0}, {-1, 0}, {0, 1}, {0, -1}\n\t};\n\t\n\tpublic static class Auth implements Comparable<Auth>{\n\t\tint x, y;\n\t\tlong level;\n\n\t\tpublic Auth(int x, int y, long level) {\n\t\t\tsuper();\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.level = level;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Auth arg0) {\n\t\t\treturn this.level < arg0.level ? -1 : this.level > arg0.level ? 1 : 0;\n\t\t}\n\t}\n\t\n\tpublic static boolean is_ok(int H, int W, int y, int x){\n\t\tif(x < 0 || x >= W || y < 0 || y >= H){ return false; }\n\t\treturn true;\n\t}\n\t\n\tpublic static long[] process(Scanner sc, final int R) throws IOException{\n\t\tfinal int W = sc.nextInt();\n\t\tfinal int H = sc.nextInt();\n\t\tfinal int X = sc.nextInt() - 1;\n\t\tfinal int Y = sc.nextInt() - 1;\n\t\t\n\t\tlong[][] map = new long[H][W];\n\t\t\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\tfinal int level = sc.nextInt();\n\t\t\t\t\n\t\t\t\tmap[i][j] = level;\n\t\t\t}\n\t\t}\n\t\t\n\t\tTreeMap<Long, Integer> counts = new TreeMap<Long, Integer>();\n\t\tboolean[][] already = new boolean[H][W];\n\t\t\n\t\tPriorityQueue<Auth> queue = new PriorityQueue<Auth>();\n\t\tqueue.add(new Auth(X, Y, 1));\n\t\tcounts.put(0l, 0);\n\t\t\n\t\twhile(!queue.isEmpty()){\n\t\t\tAuth auth = queue.poll();\n\t\t\t\n\t\t\tif(already[auth.y][auth.x]){\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\talready[auth.y][auth.x] = true;\n\t\t\t\tif(!counts.containsKey(auth.level)){\n\t\t\t\t\tcounts.put(auth.level, 0);\n\t\t\t\t}\n\t\t\t\tcounts.put(auth.level, counts.get(auth.level) + 1);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int[] move : move_dir){\n\t\t\t\tfinal int nx = auth.x + move[0];\n\t\t\t\tfinal int ny = auth.y + move[1];\n\t\t\t\t\n\t\t\t\tif(!is_ok(H, W, ny, nx)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(already[ny][nx]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tqueue.add(new Auth(nx, ny, Math.max(auth.level, map[ny][nx])));\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong[] ret = new long[R + 1];\n\t\tArrays.fill(ret, INF);\n\t\tret[0] = 0l;\n\t\tint cnt = 1;\n\t\tfor(Entry<Long, Integer> entry : counts.entrySet()){\n\t\t\tfinal int next_cnt = Math.min(cnt + entry.getValue(), R + 1);\n\t\t\t\n\t\t\tfor(int i = cnt; i < next_cnt; i++){\n\t\t\t\tret[i] = entry.getKey();\n\t\t\t}\n\t\t\tcnt = next_cnt;\n\t\t}\n\t\t//System.out.println(Arrays.toString(ret));\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int R = sc.nextInt();\n\t\t\tif(R == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tlong[] one = process(sc, R);\n\t\t\tlong[] two = process(sc, R);\n\t\t\t\n\t\t\tlong min = INF;\n\t\t\tfor(int i = 0; i <= R; i++){\n\t\t\t\tmin = Math.min(min, one[i] + two[R - i]);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t\t\n\t\t\t//System.gc();\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n\t\n\tpublic static class Scanner {\n\t    private BufferedReader br;\n\t    private StringTokenizer tok;\n\n\t    public Scanner(InputStream is) throws IOException {\n\t        br = new BufferedReader(new InputStreamReader(is));\n\t    }\n\n\t    private void getLine() throws IOException {\n\t        while (!hasNext()) { tok = new StringTokenizer(br.readLine()); }\n\t    }\n\n\t    private boolean hasNext() {\n\t        return tok != null && tok.hasMoreTokens();\n\t    }\n\n\t    public String next() throws IOException {\n\t        getLine(); return tok.nextToken();\n\t    }\n\n\t    public int nextInt() throws IOException {\n\t        return Integer.parseInt(next());\n\t    }\n\t    \n\t    public void close() throws IOException {\n\t        br.close();\n\t    }\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Authentication Level\npublic class Main{\n\n\tclass R implements Comparable<R>{\n\t\tint i,j,l,k;\n\t\tpublic R(int i, int j, int l, int k) {\n\t\t\tthis.i = i;\n\t\t\tthis.j = j;\n\t\t\tthis.l = l;\n\t\t\tthis.k = k;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn l-o.l;\n\t\t}\n\t}\n\n\tPriorityQueue<R> q;\n\tint w1, h1, w2, h2;\n\tint[][] m1, m2;\n\tint[][] move = {{-1,0},{0,1},{1,0},{0,-1}};\n\tint level1, level2;\n\tint c1, c2;\n\tint[][] a1, a2;\n\n\tvoid f1(int i, int j){\n\t\tif(m1[i][j]==0)return;\n\t\tif(level1<m1[i][j]){\n\t\t\tq.add(new R(i,j,m1[i][j],1));\n\t\t\treturn;\n\t\t}\n\t\tm1[i][j] = 0;\n\t\tc1++;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+move[k][0];\n\t\t\tint nj = j+move[k][1];\n\t\t\tif(0<=ni&&ni<h1&&0<=nj&&nj<w1)f1(ni,nj);\n\t\t}\n\t}\n\n\tvoid f2(int i, int j){\n\t\tif(m2[i][j]==0)return;\n\t\tif(level2<m2[i][j]){\n\t\t\tq.add(new R(i,j,m2[i][j],2));\n\t\t\treturn;\n\t\t}\n\t\tm2[i][j] = 0;\n\t\tc2++;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+move[k][0];\n\t\t\tint nj = j+move[k][1];\n\t\t\tif(0<=ni&&ni<h2&&0<=nj&&nj<w2)f2(ni,nj);\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint r = sc.nextInt();\n\t\t\tif(r==0)break;\n\t\t\tw1 = sc.nextInt();\n\t\t\th1 = sc.nextInt();\n\t\t\tm1 = new int[h1][w1];\n\t\t\tint j1 = sc.nextInt()-1;\n\t\t\tint i1 = sc.nextInt()-1;\n\t\t\tfor(int i=0;i<h1;i++)for(int j=0;j<w1;j++)m1[i][j]=sc.nextInt();\n\t\t\tw2 = sc.nextInt();\n\t\t\th2 = sc.nextInt();\n\t\t\tm2 = new int[h2][w2];\n\t\t\tint j2 = sc.nextInt()-1;\n\t\t\tint i2 = sc.nextInt()-1;\n\t\t\tfor(int i=0;i<h2;i++)for(int j=0;j<w2;j++)m2[i][j]=sc.nextInt();\n\t\t\tq = new PriorityQueue<R>();\n\t\t\tlevel1 = level2 = c1 = c2 = 0;\n\t\t\tq.add(new R(i1,j1,1,1));\n\t\t\tq.add(new R(i2,j2,1,2));\n\t\t\ta1 = new int[h1*w1+2][2];\n\t\t\ta2 = new int[h2*w2+2][2];\n\t\t\tint k1, k2;\n\t\t\tk1 = k2 = 1;\n\t\t\twhile(true){\n\t\t\t\tR v = q.poll();\n//\t\t\t\tSystem.out.println(\"K1:\" + k1 + \" K2:\" + k2 + \" A1:\" + a1.length + \" A2:\" + a2.length);\n\t\t\t\tif(v.k==1){\n\t\t\t\t\tlevel1 = v.l;\n\t\t\t\t\tf1(v.i, v.j);\n\t\t\t\t\ta1[k1][0] = level1;\n\t\t\t\t\ta1[k1][1] = c1;\n\t\t\t\t\tk1++;\n\t\t\t\t\tif(r<=c1+c2){\n\t\t\t\t\t\tk2--;\n\t\t\t\t\t\twhile(0<=k2){\n\t\t\t\t\t\t\tif(r>c1+a2[k2][1])break;\n\t\t\t\t\t\t\tlevel2 = a2[k2][0];\n\t\t\t\t\t\t\tk2--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tlevel2 = v.l;\n\t\t\t\t\tf2(v.i, v.j);\n\t\t\t\t\ta2[k2][0] = level2;\n\t\t\t\t\ta2[k2][1] = c2;\n\t\t\t\t\tk2++;\n\t\t\t\t\tif(r<=c1+c2){\n\t\t\t\t\t\tk1--;\n\t\t\t\t\t\twhile(0<=k1){\n\t\t\t\t\t\t\tif(r>a1[k1][1]+c2)break;\n\t\t\t\t\t\t\tlevel1 = a1[k1][0];\n\t\t\t\t\t\t\tk1--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(r<=c1+c2){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(level1+level2);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.PriorityQueue;\nimport java.util.TreeSet;\n\npublic class Main {\n\n\tstatic MyScanner sc = new MyScanner(System.in);\n\tstatic int R;\n\tstatic int[] DR = { 1, 0, -1, 0 };\n\tstatic int[] DC = { 0, 1, 0, -1 };\n\n\tstatic int[][] count() {\n\t\tint W = sc.nextInt();\n\t\tint H = sc.nextInt();\n\t\tint X = sc.nextInt() - 1;\n\t\tint Y = sc.nextInt() - 1;\n\t\tint[][] L = new int[H][W];\n\t\tTreeSet<Integer> level = new TreeSet<Integer>();\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tL[i][j] = sc.nextInt();\n\t\t\t\tlevel.add(L[i][j]);\n\t\t\t}\n\t\t}\n\t\tint[][] ret = new int[level.size() + 1][2];\n\t\tint t = 1;\n\t\tboolean[][] visited = new boolean[H][W];\n\t\tint count = 0;\n\t\tPriorityQueue<Pos> pos = new PriorityQueue<Pos>();\n\t\tpos.add(new Pos(X, Y, 1));\n\t\tvisited[Y][X] = true;\n\t\tfor (int l : level) {\n\t\t\twhile (!pos.isEmpty()) {\n\t\t\t\tif (pos.peek().l > l) break;\n\t\t\t\tPos cur = pos.poll();\n\t\t\t\t++count;\n\t\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\t\tint nx = cur.x + DC[i];\n\t\t\t\t\tint ny = cur.y + DR[i];\n\t\t\t\t\tif (nx < 0 || W <= nx || ny < 0 || H <= ny || visited[ny][nx]) continue;\n\t\t\t\t\tpos.add(new Pos(nx, ny, L[ny][nx]));\n\t\t\t\t\tvisited[ny][nx] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tret[t][0] = l;\n\t\t\tret[t][1] = count;\n\t\t\t++t;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic int solve(int[][] c1, int[][] c2) {\n\t\tint min = Integer.MAX_VALUE;\n\t\tint pos = c2.length - 1;\n\t\tfor (int i = 0; i < c1.length; ++i) {\n\t\t\tint count = c1[i][1];\n\t\t\tif (count >= R) {\n\t\t\t\tmin = Math.min(min, c1[i][0]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile (pos > 0 && count + c2[pos - 1][1] >= R) {\n\t\t\t\t--pos;\n\t\t\t}\n\t\t\tif (count + c2[pos][1] >= R) min = Math.min(min, c1[i][0] + c2[pos][0]);\n\t\t}\n\t\treturn min;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tR = sc.nextInt();\n\t\t\tif (R == 0) break;\n\t\t\tint[][] c1 = count();\n\t\t\tint[][] c2 = count();\n\t\t\tSystem.out.println(Math.min(solve(c1, c2), solve(c2, c1)));\n\t\t}\n\t}\n\n\tstatic class Pos implements Comparable<Pos> {\n\t\tint x, y, l;\n\n\t\tPos(int x, int y, int l) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.l = l;\n\t\t}\n\n\t\tpublic int compareTo(Pos o) {\n\t\t\treturn this.l - o.l;\n\t\t}\n\t}\n\n\tstatic class MyScanner {\n\n\t\tBufferedInputStream stream;\n\t\tint top = -1;\n\n\t\tMyScanner(InputStream input) {\n\t\t\tthis.stream = new BufferedInputStream(input);\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tskipSpace();\n\t\t\t\tint c = read();\n\t\t\t\twhile (c != -1 && Character.isWhitespace((char) c)) {\n\t\t\t\t\tsb.append((char) c);\n\t\t\t\t\tc = read();\n\t\t\t\t}\n\t\t\t\treturn sb.toString();\n\t\t\t} catch (IOException e) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t}\n\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint sign = 1;\n\t\t\t\tint ret = 0;\n\t\t\t\tskipSpace();\n\t\t\t\tint c = read();\n\t\t\t\tif (c == '-') {\n\t\t\t\t\tsign = -1;\n\t\t\t\t\tc = read();\n\t\t\t\t} else if (c == '+') {\n\t\t\t\t\tc = read();\n\t\t\t\t}\n\t\t\t\twhile ('0' <= c && c <= '9') {\n\t\t\t\t\tret *= 10;\n\t\t\t\t\tret += c - '0';\n\t\t\t\t\tc = read();\n\t\t\t\t}\n\t\t\t\treturn ret * sign;\n\t\t\t} catch (IOException e) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tvoid skipSpace() throws IOException {\n\t\t\twhile (true) {\n\t\t\t\tint c = read();\n\t\t\t\tif (c == -1 || !Character.isWhitespace((char) c)) {\n\t\t\t\t\tunread(c);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint read() throws IOException {\n\t\t\tif (this.top != -1) {\n\t\t\t\tint ret = this.top;\n\t\t\t\tthis.top = -1;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\treturn this.stream.read();\n\t\t}\n\n\t\tvoid unread(int c) {\n\t\t\tthis.top = c;\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 400000000;\n\tint r;\n\tScanner sc;\n\t\n\tvoid run() {\n\t\tsc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tr = sc.nextInt();\n\t\t\tif( r == 0) break;\n\t\t\tPair[] a = scan();\n\t\t\tPair[] b = scan();\n//\t\t\tfor(Pair p: a) debug(p.f, p.s);\n//\t\t\tfor(Pair p: b) debug(p.f, p.s);\n\t\t\t\n\t\t\tint min = INF;\n\t\t\tint i=0,j=b.length-1;\n\t\t\tfor(;;) {\n\t\t\t\tif(i == a.length || j == -1) break;\n\t\t\t\tif(a[i].s+b[j].s >= r) {\n\t\t\t\t\tmin = min(a[i].f + b[j].f, min);\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\t\n\tint w, h;\n\tint[][] map;\n\tboolean[][] visited;\n\tint sx, sy;\n\t\n\tPair[] scan() {\n\t\tw = sc.nextInt();\n\t\th = sc.nextInt();\n\t\tmap = new int[h+2][w+2];\n\t\tvisited = new boolean[h+2][w+2];\n\t\t\n\t\tfor(int[] a: map) fill(a, INF);\n\t\t\n\t\tsx = sc.nextInt();\n\t\tsy = sc.nextInt();\n\t\t\n\t\tfor(int i=1;i<=h;i++) for(int j=1;j<=w;j++) \n\t\t\tmap[i][j] = sc.nextInt();\n//\t\tfor(int[] a: map) debug(a);\n\t\tPriorityQueue<P> que = new PriorityQueue<P>(1, new Comp());\n\t\tque.add(new P(sx, sy));\n\t\tLinkedList<Pair> pairs = new LinkedList<Pair>();\n\t\tvisited[sy][sx] = true;\n\t\tfor(;;) {\n\t\t\tP p = que.remove();\n//\t\t\tdebug(p.x, p.y, map[p.y][p.x]);\n\t\t\tif( map[p.y][p.x]== INF ) break;\n\t\t\t\n\t\t\tfor(int i=0;i<4;i++) if( !visited[p.y+dy[i]][p.x+dx[i]] ) {\n\t\t\t\tque.add(new P(p.x+dx[i], p.y+dy[i]));\n\t\t\t\tvisited[p.y+dy[i]][p.x+dx[i]] = true;\n\t\t\t}\n\t\t\t\n\t\t\tpairs.add( new Pair( map[p.y][p.x], bfs(que, map[p.y][p.x]) ) );\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tPair[] pp = new Pair[pairs.size()+1];\n\t\tpp[0] = new Pair(0, 0);\n\t\tint size = pairs.size();\n\t\tfor(int i=1;i<=size;i++) {\n\t\t\tPair pair = pairs.remove();\n\t\t\tpp[i] = new Pair( pair.f, pair.s + pp[i-1].s );\n\t\t}\n\t\t\n\t\treturn pp;\n\t}\n\t\n\tint dx[] = {-1,0,1,0};\n\tint dy[] = {0,-1,0,1};\n\t\n\tint bfs(PriorityQueue<P> que, int lev) {\n\t\tint cnt = 1;\n\t\tif(que.isEmpty()) return cnt;\n\t\tfor(;;) {\n\t\t\tP p = que.remove();\n\t\t\tif( map[p.y][p.x] > lev  ) {\n\t\t\t\tque.add(p);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcnt++;\n\t\t\tfor(int i=0;i<4;i++) if( !visited[p.y+dy[i]][p.x+dx[i]] ) {\n\t\t\t\tque.add(new P(p.x+dx[i], p.y+dy[i]));\n\t\t\t\tvisited[p.y+dy[i]][p.x+dx[i]] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn cnt;\n\t}\n\t\n\tclass Pair {\n\t\tint f,s;\n\t\tPair(int f, int s ) {\n\t\t\tthis.f = f;\n\t\t\tthis.s = s;\n\t\t}\n\t}\n\t\n\tclass Comp implements Comparator<P> {\n\n\t\t@Override\n\t\tpublic int compare(P o1, P o2) {\n\t\t\t// TODO 自動生成されたメソッド・スタブ\n\t\t\treturn map[o1.y][o1.x] - map[o2.y][o2.x];\n\t\t}\n\t\t\n\t}\n\t\n\tclass P {\n\t\tint x, y;\n\t\tP (int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tr = scanner.nextInt();\n\t\t\tif (r == 0)\n\t\t\t\tbreak;\n\t\t\tmap = new int[2][250001];\n\t\t\tfor (int[] ma : map)\n\t\t\t\tArrays.fill(ma, 1 << 30);\n\t\t\tmap[0][0] = map[1][0] = 0;\n\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\tw = scanner.nextInt();\n\t\t\t\th = scanner.nextInt();\n\t\t\t\tsx = scanner.nextInt() - 1;\n\t\t\t\tsy = scanner.nextInt() - 1;\n\t\t\t\tint[][] m = new int[h][w];\n\t\t\t\tfor (int j = 0; j < h; j++)\n\t\t\t\t\tfor (int k = 0; k < w; k++)\n\t\t\t\t\t\tm[j][k] = scanner.nextInt();\n\t\t\t\tslove(m, i);\n\t\t\t}\n\t\t\tint res = 1 << 30;\n\t\t\tfor (int i = 0; i <= r; i++) {\n\t\t\t\tres = Math.min(res, map[0][i] + map[1][r - i]);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tprivate void slove(int[][] m, int i) {\n\t\tboolean[][] b = new boolean[h][w];\n\t\tint id = 1;\n\t\tint l = -1;\n\t\tb[sy][sx] = true;\n\t\tint a = h * w - 1;\n\t\tPriorityQueue<Point> pq = new PriorityQueue<Point>();\n\t\tpq.offer(new Point(m[sy][sx], sy, sx));\n\t\twhile (!pq.isEmpty()) {\n\t\t\tPoint point = pq.poll();\n\t\t\tl = Math.max(l, point.k);\n\t\t\tmap[i][id++] = l;\n\t\t\tif(a==0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int[] mo : move) {\n\t\t\t\tint ny = point.y + mo[0];\n\t\t\t\tint nx = point.x + mo[1];\n\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (b[ny][nx])\n\t\t\t\t\tcontinue;\n\t\t\t\tb[ny][nx] = true;\n\t\t\t\ta--;\n\t\t\t\tpq.offer(new Point(m[ny][nx], ny, nx));\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean isOK(int ny, int nx) {\n\t\tif (0 <= ny && ny < h && 0 <= nx && nx < w)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tint r, w, h, sx, sy;\n\tint[][] map;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\n\tclass Point implements Comparable<Point> {\n\t\tint k, y, x;\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Point [k=\" + k + \", y=\" + y + \", x=\" + x + \"]\";\n\t\t}\n\n\t\tpublic Point(int k, int y, int x) {\n\t\t\tsuper();\n\t\t\tthis.k = k;\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Point o) {\n\t\t\treturn this.k - o.k;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Authentication Level\npublic class Main{\n\n\tclass R implements Comparable<R>{\n\t\tint i,j,l,k;\n\t\tpublic R(int i, int j, int l, int k) {\n\t\t\tthis.i = i;\n\t\t\tthis.j = j;\n\t\t\tthis.l = l;\n\t\t\tthis.k = k;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn l-o.l;\n\t\t}\n\t}\n\n\tPriorityQueue<R> q;\n\tint w1, h1, w2, h2;\n\tint[][] m1, m2;\n\tint[][] move = {{-1,0},{0,1},{1,0},{0,-1}};\n\tint level1, level2;\n\tint c1, c2;\n\tint[][] a1, a2;\n\n\tvoid f1(int i, int j){\n\t\tif(m1[i][j]==0)return;\n\t\tif(level1<m1[i][j]){\n\t\t\tq.add(new R(i,j,m1[i][j],1));\n\t\t\treturn;\n\t\t}\n\t\tm1[i][j] = 0;\n\t\tc1++;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+move[k][0];\n\t\t\tint nj = j+move[k][1];\n\t\t\tif(0<=ni&&ni<h1&&0<=nj&&nj<w1)f1(ni,nj);\n\t\t}\n\t}\n\n\tvoid f2(int i, int j){\n\t\tif(m2[i][j]==0)return;\n\t\tif(level2<m2[i][j]){\n\t\t\tq.add(new R(i,j,m2[i][j],2));\n\t\t\treturn;\n\t\t}\n\t\tm2[i][j] = 0;\n\t\tc2++;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+move[k][0];\n\t\t\tint nj = j+move[k][1];\n\t\t\tif(0<=ni&&ni<h2&&0<=nj&&nj<w2)f2(ni,nj);\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint r = sc.nextInt();\n\t\t\tif(r==0)break;\n\t\t\tw1 = sc.nextInt();\n\t\t\th1 = sc.nextInt();\n\t\t\tm1 = new int[h1][w1];\n\t\t\tint j1 = sc.nextInt()-1;\n\t\t\tint i1 = sc.nextInt()-1;\n\t\t\tfor(int i=0;i<h1;i++)for(int j=0;j<w1;j++)m1[i][j]=sc.nextInt();\n\t\t\tw2 = sc.nextInt();\n\t\t\th2 = sc.nextInt();\n\t\t\tm2 = new int[h2][w2];\n\t\t\tint j2 = sc.nextInt()-1;\n\t\t\tint i2 = sc.nextInt()-1;\n\t\t\tfor(int i=0;i<h2;i++)for(int j=0;j<w2;j++)m2[i][j]=sc.nextInt();\n\t\t\tq = new PriorityQueue<R>();\n\t\t\tlevel1 = level2 = c1 = c2 = 0;\n\t\t\tq.add(new R(i1,j1,1,1));\n\t\t\tq.add(new R(i2,j2,1,2));\n\t\t\ta1 = new int[h1*w1+2][2];\n\t\t\ta2 = new int[h2*w2+2][2];\n\t\t\tint k1, k2;\n\t\t\tk1 = k2 = 1;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tR v = q.poll();\n\t\t\t\tif(v.k==1&&m1[v.i][v.j]!=0){\n\t\t\t\t\tlevel1 = v.l;\n\t\t\t\t\tf1(v.i, v.j);\n\t\t\t\t\ta1[k1][0] = level1;\n\t\t\t\t\ta1[k1][1] = c1;\n\t\t\t\t\tk1++;\n\t\t\t\t}\n\t\t\t\telse if(v.k==2&&m2[v.i][v.j]!=0){\n\t\t\t\t\tlevel2 = v.l;\n\t\t\t\t\tf2(v.i, v.j);\n\t\t\t\t\ta2[k2][0] = level2;\n\t\t\t\t\ta2[k2][1] = c2;\n\t\t\t\t\tk2++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint min = level1+level2;\n\t\t\tfor(int i=0;i<k1;i++){\n\t\t\t\tif(min<a1[i][0])break;\n\t\t\t\tint x = r-a1[i][1];\n\t\t\t\tif(a2[k2][1]<x)continue;\n\t\t\t\tint L = 0;\n\t\t\t\tint R = k2-1;\n\t\t\t\twhile(R-L>1){\n\t\t\t\t\tint M = (R+L)/2;\n\t\t\t\t\tif(x<=a2[M][1])R = M;\n\t\t\t\t\telse L = M;\n\t\t\t\t}\n\t\t\t\tif(x<=a2[R][1])min = Math.min(min, a1[i][0]+a2[R][0]);\n\t\t\t\tif(x<=a2[L][1])min = Math.min(min, a1[i][0]+a2[L][0]);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Authentication Level\npublic class Main{\n\n\tclass R implements Comparable<R>{\n\t\tint i,j,l,k;\n\t\tpublic R(int i, int j, int l, int k) {\n\t\t\tthis.i = i;\n\t\t\tthis.j = j;\n\t\t\tthis.l = l;\n\t\t\tthis.k = k;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn l-o.l;\n\t\t}\n\t}\n\n\tPriorityQueue<R> q;\n\tint w1, h1, w2, h2;\n\tint[][] m1, m2;\n\tint[][] move = {{-1,0},{0,1},{1,0},{0,-1}};\n\tint level1, level2;\n\tint c1, c2;\n\tint[][] a1, a2;\n\n\tvoid f1(int i, int j){\n\t\tif(m1[i][j]==0)return;\n\t\tif(level1<m1[i][j]){\n\t\t\tq.add(new R(i,j,m1[i][j],1));\n\t\t\treturn;\n\t\t}\n\t\tm1[i][j] = 0;\n\t\tc1++;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+move[k][0];\n\t\t\tint nj = j+move[k][1];\n\t\t\tif(0<=ni&&ni<h1&&0<=nj&&nj<w1)f1(ni,nj);\n\t\t}\n\t}\n\n\tvoid f2(int i, int j){\n\t\tif(m2[i][j]==0)return;\n\t\tif(level2<m2[i][j]){\n\t\t\tq.add(new R(i,j,m2[i][j],2));\n\t\t\treturn;\n\t\t}\n\t\tm2[i][j] = 0;\n\t\tc2++;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+move[k][0];\n\t\t\tint nj = j+move[k][1];\n\t\t\tif(0<=ni&&ni<h2&&0<=nj&&nj<w2)f2(ni,nj);\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint r = sc.nextInt();\n\t\t\tif(r==0)break;\n\t\t\tw1 = sc.nextInt();\n\t\t\th1 = sc.nextInt();\n\t\t\tm1 = new int[h1][w1];\n\t\t\tint j1 = sc.nextInt()-1;\n\t\t\tint i1 = sc.nextInt()-1;\n\t\t\tfor(int i=0;i<h1;i++)for(int j=0;j<w1;j++)m1[i][j]=sc.nextInt();\n\t\t\tw2 = sc.nextInt();\n\t\t\th2 = sc.nextInt();\n\t\t\tm2 = new int[h2][w2];\n\t\t\tint j2 = sc.nextInt()-1;\n\t\t\tint i2 = sc.nextInt()-1;\n\t\t\tfor(int i=0;i<h2;i++)for(int j=0;j<w2;j++)m2[i][j]=sc.nextInt();\n\t\t\tq = new PriorityQueue<R>();\n\t\t\tlevel1 = level2 = c1 = c2 = 0;\n\t\t\tq.add(new R(i1,j1,1,1));\n\t\t\tq.add(new R(i2,j2,1,2));\n\t\t\ta1 = new int[h1*w1+2][2];\n\t\t\ta2 = new int[h2*w2+2][2];\n\t\t\tint k1, k2;\n\t\t\tk1 = k2 = 1;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tR v = q.poll();\n\t\t\t\tif(v.k==1&&m1[v.i][v.j]!=0){\n\t\t\t\t\tlevel1 = v.l;\n\t\t\t\t\tf1(v.i, v.j);\n\t\t\t\t\ta1[k1][0] = level1;\n\t\t\t\t\ta1[k1][1] = c1;\n\t\t\t\t\tk1++;\n\t\t\t\t}\n\t\t\t\telse if(v.k==2&&m2[v.i][v.j]!=0){\n\t\t\t\t\tlevel2 = v.l;\n\t\t\t\t\tf2(v.i, v.j);\n\t\t\t\t\ta2[k2][0] = level2;\n\t\t\t\t\ta2[k2][1] = c2;\n\t\t\t\t\tk2++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint min = level1+level2;\n\t\t\tfor(int i=0;i<k1;i++){\n\t\t\t\tint x = r-a1[i][1];\n\t\t\t\tint L = 0;\n\t\t\t\tint R = k2-1;\n\t\t\t\twhile(R-L>1){\n\t\t\t\t\tint M = (R+L)/2;\n\t\t\t\t\tif(x<=a2[M][1])R = M;\n\t\t\t\t\telse L = M;\n\t\t\t\t}\n\t\t\t\tif(x<=a2[R][1])min = Math.min(min, a1[i][0]+a2[R][0]);\n\t\t\t\tif(x<=a2[L][1])min = Math.min(min, a1[i][0]+a2[L][0]);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n  // constant\n\n  static final int MAX_INT = 1 << 30;\n\n  static final int[][] DRCS = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n  // inner classes\n\n  static class Masu implements Comparable<Masu> {\n    int level, x, y;\n\n    Masu(int level, int x, int y) {\n      this.level = level;\n      this.x = x;\n      this.y = y;\n    }\n\n    public int compareTo(Masu m) {\n      return this.level - m.level;\n    }\n  }\n\n  // main\n  public static final void main(String[] args) throws Exception {\n    Scanner sc = new Scanner(System.in);\n\n    for (;;) {\n      int r = sc.nextInt();\n      if (r == 0) break;\n\n      int[][] mlss = new int[2][r + 1];\n      int[] mlslen = new int[2];\n\n      for (int k = 0; k < 2; k++) {\n        int w = sc.nextInt();\n        int h = sc.nextInt();\n        int ex = sc.nextInt() - 1;\n        int ey = sc.nextInt() - 1;\n\n        int[][] als = new int[h][w];\n        int[][] mls = new int[h][w];\n        boolean[][] notq = new boolean[h][w];\n\n        for (int y = 0; y < h; y++)\n          for (int x = 0; x < w; x++) {\n            als[y][x] = sc.nextInt();\n            mls[y][x] = MAX_INT;\n            notq[y][x] = true;\n          }\n\n        mls[ey][ex] = als[ey][ex];\n        notq[ey][ex] = false;\n\n        PriorityQueue<Masu> q = new PriorityQueue<Masu>();\n        q.add(new Masu(mls[ey][ex], ex, ey));\n\n        mlss[k][0] = 0;\n        mlslen[k] = 1;\n\n        while (! q.isEmpty()) {\n          Masu min_u = q.poll();\n\n          mlss[k][mlslen[k]++] = min_u.level;\n          if (mlslen[k] > r) break;\n\n          for (int[] drc: DRCS) {\n            int vx = min_u.x + drc[0];\n            int vy = min_u.y + drc[1];\n            if (vx < 0 || vx >= w || vy < 0 || vy >= h) continue;\n\n            int l = min_u.level;\n            if (l < als[vy][vx]) l = als[vy][vx];\n\n            if (mls[vy][vx] > l) {\n              mls[vy][vx] = l;\n              if (notq[vy][vx]) {\n                notq[vy][vx] = false;\n                q.add(new Masu(mls[vy][vx], vx, vy));\n              }\n            }\n          }\n        }\n      }\n\n      int min_sum = MAX_INT;\n\n      int i0 = 0;\n      int i1 = r - i0;\n\n      if (i1 >= mlslen[1]) {\n        i1 = mlslen[1] - 1;\n        i0 = r - i1;\n      }\n\n      while (i0 < mlslen[0] && i1 >= 0) {\n        int sum = mlss[0][i0] + mlss[1][i1];\n        if (min_sum > sum) min_sum = sum;\n\n        i0++; i1--;\n      }\n\n      System.out.println(min_sum);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Authentication Level\npublic class Main{\n\n\tclass E implements Comparable<E>{\n\t\tint k, i, j;\n\t\tpublic E(int k, int i, int j) {\n\t\t\tthis.k = k;\n\t\t\tthis.i = i;\n\t\t\tthis.j = j;\n\t\t}\n\t\tpublic int compareTo(E o) {\n\t\t\treturn k-o.k;\n\t\t}\n\t}\n\t\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1}};\n\tint[] f(int h, int w, int[][] a, int si, int sj){\n\t\tint[] r = new int[w*h+1];\n\t\tboolean[][] mark = new boolean[h][w], u = new boolean[h][w];\n\t\tint id = 1, L = -1;\n\t\tmark[si][sj] = true;\n\t\tPriorityQueue<E> q = new PriorityQueue<E>();\n\t\tq.add(new E(a[si][sj], si, sj));\n\t\twhile(!q.isEmpty()){\n\t\t\tE e = q.poll();\n\t\t\tif(L<e.k)L = e.k;\n\t\t\tu[e.i][e.j] = true;\n\t\t\tr[id++] = L;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tint ni = e.i+d[k][0], nj = e.j+d[k][1];\n\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&!mark[ni][nj]){\n\t\t\t\t\tmark[ni][nj] = true;\n\t\t\t\t\tq.add(new E(a[ni][nj], ni, nj));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint R = sc.nextInt();\n\t\t\tif(R==0)break;\n\t\t\tint[][] a = new int[2][];\n\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\tint w = sc.nextInt(), h = sc.nextInt(), sj = sc.nextInt()-1, si = sc.nextInt()-1;\n\t\t\t\tint[][] m = new int[h][w];\n\t\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)m[i][j]=sc.nextInt();\n\t\t\t\ta[k] = f(h, w, m, si, sj);\n\t\t\t}\n\t\t\tint res = 1<<29;\n\t\t\tfor(int r=0;r<=Math.min(R, a[0].length-1);r++){\n\t\t\t\tif(a[1].length<=R-r)continue;\n\t\t\t\tres = Math.min(res, a[0][r]+a[1][R-r]);\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.ThreadMXBean;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\n\t\tThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();\n\t\tlong startCpuTime = threadMXBean.getCurrentThreadCpuTime();\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t// Scanner scan = new Scanner(new\n\t\t// File(\"D:\\\\UserArea\\\\J0124567\\\\Downloads\\\\0541-input.txt\"));\n\n\t\twhile (scan.hasNext()) {\n\n\t\t\tint r = scan.nextInt();\n\t\t\tif (r == 0)\n\t\t\t\tbreak;\n\t\t\tRank[][] rank = new Rank[2][];\n\t\t\tfor (int f = 0; f < 2; f++) {\n\t\t\t\tint w = scan.nextInt();\n\t\t\t\tint h = scan.nextInt();\n\t\t\t\tint x = scan.nextInt();\n\t\t\t\tint y = scan.nextInt();\n\t\t\t\tOffice of = new Office(w, h, r);\n\t\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\t\tof.set(j, i, scan.nextInt());\n\t\t\t\trank[f] = of.start(x, y);\n\t\t\t}\n\t\t\t// for (int f = 0; f < 2; f++)\n\t\t\t// for (int i = 0; i < rank[f].length; i++)\n\t\t\t// System.out.println(f + \" \" + rank[f][i].sec + \" \" +\n\t\t\t// rank[f][i].rooms);\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor (int i = 0; i < rank[0].length; i++)\n\t\t\t\tfor (int j = rank[1].length - 1; j >= 0; j--)\n\t\t\t\t\tif (rank[0][i].rooms + rank[1][j].rooms < r)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\telse if (min > rank[0][i].sec + rank[1][j].sec)\n\t\t\t\t\t\tmin = rank[0][i].sec + rank[1][j].sec;\n\t\t\tSystem.out.println(min);\n\t\t}\n\n\t\tscan.close();\n\t\tlong stopCpuTime = threadMXBean.getCurrentThreadCpuTime();\n\t\t// System.out.println(\"CPU=\" + (stopCpuTime - startCpuTime) / 1000000);\n\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Rank {\n\tpublic Rank(int r, int cnt) {\n\t\tsec = r;\n\t\trooms = cnt;\n\t}\n\n\tint sec, rooms;\n}\n\nclass Office {\n\tclass Ent {\n\t\tpublic Ent(int _sec, int _w, int _h) {\n\t\t\tsec = _sec;\n\t\t\tw = _w;\n\t\t\th = _h;\n\t\t}\n\n\t\tint sec, w, h;\n\t}\n\n\tclass EntComp implements Comparator<Ent> {\n\n\t\t@Override\n\t\tpublic int compare(Ent o1, Ent o2) {\n\t\t\tif (o1.sec > o2.sec)\n\t\t\t\treturn 1;\n\t\t\telse if (o1.sec == o2.sec)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t}\n\n\tint R;\n\tint[][] roomS;\n\tboolean[][] roomF;\n\tPriorityQueue<Ent> ent = new PriorityQueue<Ent>(10, new EntComp());\n\n\tpublic Office(int w, int h, int r) {\n\t\troomS = new int[w][h];\n\t\troomF = new boolean[w][h];\n\t\tR = r;\n\t}\n\n\tpublic Rank[] start(int x, int y) {\n\t\troomF[x - 1][y - 1] = true;\n\t\tent.add(new Ent(roomS[x - 1][y - 1], x - 1, y - 1));\n\t\tList<Rank> rank = new ArrayList<Rank>();\n\n\t\tint r = 1, cnt = 0;\n\t\tEnt c;\n\t\twhile (true) {\n\t\t\tc = ent.poll();\n\t\t\tif (c != null && c.sec <= r)\n\t\t\t\tcnt++;\n\t\t\telse {\n\t\t\t\trank.add(new Rank(r, cnt));\n\t\t\t\tif (cnt >= R)\n\t\t\t\t\tbreak;\n\t\t\t\tif (c != null) {\n\t\t\t\t\tr = c.sec;\n\t\t\t\t\tcnt++;\n\t\t\t\t} else\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (c.h > 0 && !roomF[c.w][c.h - 1]) {\n\t\t\t\troomF[c.w][c.h - 1] = true;\n\t\t\t\tent.add(new Ent(roomS[c.w][c.h - 1], c.w, c.h - 1));\n\t\t\t}\n\t\t\tif (c.w > 0 && !roomF[c.w - 1][c.h]) {\n\t\t\t\troomF[c.w - 1][c.h] = true;\n\t\t\t\tent.add(new Ent(roomS[c.w - 1][c.h], c.w - 1, c.h));\n\t\t\t}\n\t\t\tif (c.h + 1 < roomF[0].length && !roomF[c.w][c.h + 1]) {\n\t\t\t\troomF[c.w][c.h + 1] = true;\n\t\t\t\tent.add(new Ent(roomS[c.w][c.h + 1], c.w, c.h + 1));\n\t\t\t}\n\t\t\tif (c.w + 1 < roomF.length && !roomF[c.w + 1][c.h]) {\n\t\t\t\troomF[c.w + 1][c.h] = true;\n\t\t\t\tent.add(new Ent(roomS[c.w + 1][c.h], c.w + 1, c.h));\n\t\t\t}\n\n\t\t}\n\t\treturn ((Rank[]) rank.toArray(new Rank[0]));\n\t}\n\n\tpublic void set(int w, int h, int sec) {\n\t\troomS[w][h] = sec;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n  // constant\n\n  static final int MAX_INT = 1 << 30;\n\n  static final int[][] DRCS = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n  // inner classes\n\n  static class Masu {\n    int x, y, level;\n\n    Masu(int x, int y, int level) {\n      this.x = x;\n      this.y = y;\n      this.level = level;\n    }\n  }\n\n  // main\n  public static final void main(String[] args) throws Exception {\n    Scanner sc = new Scanner(System.in);\n\n    for (;;) {\n      int r = sc.nextInt();\n      if (r == 0) break;\n\n      int[][] mlss = new int[2][r + 1];\n      int[] mlslen = new int[2];\n\n      for (int k = 0; k < 2; k++) {\n        int w = sc.nextInt();\n        int h = sc.nextInt();\n        int ex = sc.nextInt() - 1;\n        int ey = sc.nextInt() - 1;\n\n        int[][] als = new int[h][w];\n        int[][] mls = new int[h][w];\n        boolean[][] notq = new boolean[h][w];\n\n        for (int y = 0; y < h; y++)\n          for (int x = 0; x < w; x++) {\n            als[y][x] = sc.nextInt();\n            mls[y][x] = MAX_INT;\n            notq[y][x] = true;\n          }\n\n        mls[ey][ex] = als[ey][ex];\n        notq[ey][ex] = false;\n\n        ArrayList<Masu> q = new ArrayList<Masu>();\n        q.add(new Masu(ex, ey, mls[ey][ex]));\n\n        mlss[k][0] = 0;\n        mlslen[k] = 1;\n\n        while (! q.isEmpty()) {\n          int min_i = 0;\n          Masu min_u = q.get(0);\n          for (int i = 1; i < q.size(); i++) {\n            Masu u = q.get(i);\n            if (min_u.level > u.level) {\n              min_i = i;\n              min_u = u;\n            }\n          }\n          q.remove(min_i);\n\n          mlss[k][mlslen[k]++] = min_u.level;\n          if (mlslen[k] > r) break;\n\n          for (int[] drc: DRCS) {\n            int vx = min_u.x + drc[0];\n            int vy = min_u.y + drc[1];\n            if (vx < 0 || vx >= w || vy < 0 || vy >= h) continue;\n\n            int l = min_u.level;\n            if (l < als[vy][vx]) l = als[vy][vx];\n\n            if (mls[vy][vx] > l) {\n              mls[vy][vx] = l;\n              if (notq[vy][vx]) {\n                notq[vy][vx] = false;\n                q.add(new Masu(vx, vy, mls[vy][vx]));\n              }\n            }\n          }\n        }\n      }\n\n      int min_sum = MAX_INT;\n\n      int i0 = 0;\n      int i1 = r - i0;\n\n      if (i1 >= mlslen[1]) {\n        i1 = mlslen[1] - 1;\n        i0 = r - i1;\n      }\n\n      while (i0 < mlslen[0] && i1 >= 0) {\n        int sum = mlss[0][i0] + mlss[1][i1];\n        if (min_sum > sum) min_sum = sum;\n\n        i0++; i1--;\n      }\n\n      System.out.println(min_sum);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.ThreadMXBean;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\n\t\tThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();\n\t\tlong startCpuTime = threadMXBean.getCurrentThreadCpuTime(), stopCpuTime = 0;\n\n\t\t Scanner scan = new Scanner(System.in);\n\t\t//Scanner scan = new Scanner(new File(\"D:\\\\UserArea\\\\J0124567\\\\Downloads\\\\0542-input.txt\"));\n\n\t\twhile (scan.hasNext()) {\n\n\t\t\tint r = scan.nextInt();\n\t\t\tif (r == 0)\n\t\t\t\tbreak;\n\t\t\tRank[][] rank = new Rank[2][];\n\t\t\tfor (int f = 0; f < 2; f++) {\n\t\t\t\tint w = scan.nextInt();\n\t\t\t\tint h = scan.nextInt();\n\t\t\t\tint x = scan.nextInt();\n\t\t\t\tint y = scan.nextInt();\n\t\t\t\tOffice of = new Office(w, h, r);\n\t\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\t\tof.set(j, i, scan.nextInt());\n\t\t\t\trank[f] = of.start(x, y);\n\t\t\t}\n\t\t\t// for (int f = 0; f < 2; f++)\n\t\t\t// for (int i = 0; i < rank[f].length; i++)\n\t\t\t// System.out.println(f + \" \" + rank[f][i].sec + \" \" +\n\t\t\t// rank[f][i].rooms);\n\t\t\tstopCpuTime = threadMXBean.getCurrentThreadCpuTime();\n\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor (int i = 0; i < rank[0].length; i++)\n\t\t\t\tfor (int j = rank[1].length - 1; j >= 0; j--)\n\t\t\t\t\tif (rank[0][i].rooms + rank[1][j].rooms < r)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\telse {\n\t\t\t\t\t\tint t = rank[0][i].sec + rank[1][j].sec;\n\t\t\t\t\t\tif (min > t)\n\t\t\t\t\t\t\tmin = t;\n\t\t\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\n\t\tscan.close();\n\t\t// stopCpuTime = threadMXBean.getCurrentThreadCpuTime();\n\t\t//System.out.println(\"CPU=\" + (stopCpuTime - startCpuTime) / 1000000);\n\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Rank {\n\tpublic Rank(int r, int cnt) {\n\t\tsec = r;\n\t\trooms = cnt;\n\t}\n\n\tint sec, rooms;\n}\n\nclass Office {\n\tclass Ent {\n\t\tpublic Ent(int _sec, int _w, int _h) {\n\t\t\tsec = _sec;\n\t\t\tw = _w;\n\t\t\th = _h;\n\t\t}\n\n\t\tint sec, w, h;\n\t}\n\n\tclass EntComp implements Comparator<Ent> {\n\n\t\t@Override\n\t\tpublic int compare(Ent o1, Ent o2) {\n\t\t\tif (o1.sec > o2.sec)\n\t\t\t\treturn 1;\n\t\t\telse if (o1.sec == o2.sec)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t}\n\n\tint R;\n\tint[][] roomS;\n\tboolean[][] roomF;\n\tPriorityQueue<Ent> ent = new PriorityQueue<Ent>(10, new EntComp());\n\n\tpublic Office(int w, int h, int r) {\n\t\troomS = new int[w][h];\n\t\troomF = new boolean[w][h];\n\t\tR = r;\n\t}\n\n\tpublic Rank[] start(int x, int y) {\n\t\troomF[x - 1][y - 1] = true;\n\t\tent.add(new Ent(roomS[x - 1][y - 1], x - 1, y - 1));\n\t\tList<Rank> rank = new ArrayList<Rank>();\n\t\trank.add(new Rank(0, 0));\n\n\t\tint r = 1, cnt = 0;\n\t\tEnt c;\n\t\twhile (true) {\n\t\t\tc = ent.poll();\n\t\t\tif (c != null && c.sec <= r)\n\t\t\t\tcnt++;\n\t\t\telse {\n\t\t\t\trank.add(new Rank(r, cnt));\n\t\t\t\tif (cnt >= R)\n\t\t\t\t\tbreak;\n\t\t\t\tif (c != null) {\n\t\t\t\t\tr = c.sec;\n\t\t\t\t\tcnt++;\n\t\t\t\t} else\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (c.h > 0 && !roomF[c.w][c.h - 1]) {\n\t\t\t\troomF[c.w][c.h - 1] = true;\n\t\t\t\tent.add(new Ent(roomS[c.w][c.h - 1], c.w, c.h - 1));\n\t\t\t}\n\t\t\tif (c.w > 0 && !roomF[c.w - 1][c.h]) {\n\t\t\t\troomF[c.w - 1][c.h] = true;\n\t\t\t\tent.add(new Ent(roomS[c.w - 1][c.h], c.w - 1, c.h));\n\t\t\t}\n\t\t\tif (c.h + 1 < roomF[0].length && !roomF[c.w][c.h + 1]) {\n\t\t\t\troomF[c.w][c.h + 1] = true;\n\t\t\t\tent.add(new Ent(roomS[c.w][c.h + 1], c.w, c.h + 1));\n\t\t\t}\n\t\t\tif (c.w + 1 < roomF.length && !roomF[c.w + 1][c.h]) {\n\t\t\t\troomF[c.w + 1][c.h] = true;\n\t\t\t\tent.add(new Ent(roomS[c.w + 1][c.h], c.w + 1, c.h));\n\t\t\t}\n\n\t\t}\n\t\treturn ((Rank[]) rank.toArray(new Rank[0]));\n\t}\n\n\tpublic void set(int w, int h, int sec) {\n\t\troomS[w][h] = sec;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Authentication Level\npublic class Main{\n\n\tclass R implements Comparable<R>{\n\t\tint i,j,l,k;\n\t\tpublic R(int i, int j, int l, int k) {\n\t\t\tthis.i = i;\n\t\t\tthis.j = j;\n\t\t\tthis.l = l;\n\t\t\tthis.k = k;\n\t\t}\n\t\tpublic int compareTo(R o) {\n\t\t\treturn l-o.l;\n\t\t}\n\t}\n\n\tPriorityQueue<R> q;\n\tint w1, h1, w2, h2;\n\tint[][] m1, m2;\n\tint[][] move = {{-1,0},{0,1},{1,0},{0,-1}};\n\tint level1, level2;\n\tint c1, c2;\n\tint[][] a1, a2;\n\n\tvoid f1(int i, int j){\n\t\tif(m1[i][j]==0)return;\n\t\tif(level1<m1[i][j]){\n\t\t\tq.add(new R(i,j,m1[i][j],1));\n\t\t\treturn;\n\t\t}\n\t\tm1[i][j] = 0;\n\t\tc1++;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+move[k][0];\n\t\t\tint nj = j+move[k][1];\n\t\t\tif(0<=ni&&ni<h1&&0<=nj&&nj<w1)f1(ni,nj);\n\t\t}\n\t}\n\n\tvoid f2(int i, int j){\n\t\tif(m2[i][j]==0)return;\n\t\tif(level2<m2[i][j]){\n\t\t\tq.add(new R(i,j,m2[i][j],2));\n\t\t\treturn;\n\t\t}\n\t\tm2[i][j] = 0;\n\t\tc2++;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+move[k][0];\n\t\t\tint nj = j+move[k][1];\n\t\t\tif(0<=ni&&ni<h2&&0<=nj&&nj<w2)f2(ni,nj);\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint r = sc.nextInt();\n\t\t\tif(r==0)break;\n\t\t\tw1 = sc.nextInt();\n\t\t\th1 = sc.nextInt();\n\t\t\tm1 = new int[h1][w1];\n\t\t\tint j1 = sc.nextInt()-1;\n\t\t\tint i1 = sc.nextInt()-1;\n\t\t\tfor(int i=0;i<h1;i++)for(int j=0;j<w1;j++)m1[i][j]=sc.nextInt();\n\t\t\tw2 = sc.nextInt();\n\t\t\th2 = sc.nextInt();\n\t\t\tm2 = new int[h2][w2];\n\t\t\tint j2 = sc.nextInt()-1;\n\t\t\tint i2 = sc.nextInt()-1;\n\t\t\tfor(int i=0;i<h2;i++)for(int j=0;j<w2;j++)m2[i][j]=sc.nextInt();\n\t\t\tq = new PriorityQueue<R>();\n\t\t\tlevel1 = level2 = c1 = c2 = 0;\n\t\t\tq.add(new R(i1,j1,1,1));\n\t\t\tq.add(new R(i2,j2,1,2));\n\t\t\ta1 = new int[h1*w1+2][2];\n\t\t\ta2 = new int[h2*w2+2][2];\n\t\t\tint k1, k2;\n\t\t\tk1 = k2 = 1;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tR v = q.poll();\n\t\t\t\tif(v.k==1&&m1[v.i][v.j]!=0){\n\t\t\t\t\tlevel1 = v.l;\n\t\t\t\t\tf1(v.i, v.j);\n\t\t\t\t\ta1[k1][0] = level1;\n\t\t\t\t\ta1[k1][1] = c1;\n\t\t\t\t\tk1++;\n\t\t\t\t}\n\t\t\t\telse if(v.k==2&&m2[v.i][v.j]!=0){\n\t\t\t\t\tlevel2 = v.l;\n\t\t\t\t\tf2(v.i, v.j);\n\t\t\t\t\ta2[k2][0] = level2;\n\t\t\t\t\ta2[k2][1] = c2;\n\t\t\t\t\tk2++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint min = level1+level2;\n\t\t\tfor(int i=0;i<k1;i++){\n\t\t\t\tif(min<a1[i][0])break;\n\t\t\t\tint x = r-a1[i][1];\n\t\t\t\tint L = 0;\n\t\t\t\tint R = k2-1;\n\t\t\t\twhile(R-L>1){\n\t\t\t\t\tint M = (R+L)/2;\n\t\t\t\t\tif(x<=a2[M][1])R = M;\n\t\t\t\t\telse L = M;\n\t\t\t\t}\n\t\t\t\tif(x<=a2[R][1])min = Math.min(min, a1[i][0]+a2[R][0]);\n\t\t\t\tif(x<=a2[L][1])min = Math.min(min, a1[i][0]+a2[L][0]);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.ThreadMXBean;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\n\t\tThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();\n\t\tlong startCpuTime = threadMXBean.getCurrentThreadCpuTime(), stopCpuTime = 0;\n\n\t\t Scanner scan = new Scanner(System.in);\n\t\t//Scanner scan = new Scanner(new File(\"D:\\\\UserArea\\\\J0124567\\\\Downloads\\\\0542-input.txt\"));\n\n\t\twhile (scan.hasNext()) {\n\n\t\t\tint r = scan.nextInt();\n\t\t\tif (r == 0)\n\t\t\t\tbreak;\n\t\t\tRank[][] rank = new Rank[2][];\n\t\t\tfor (int f = 0; f < 2; f++) {\n\t\t\t\tint w = scan.nextInt();\n\t\t\t\tint h = scan.nextInt();\n\t\t\t\tint x = scan.nextInt();\n\t\t\t\tint y = scan.nextInt();\n\t\t\t\tOffice of = new Office(w, h, r);\n\t\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\t\tof.set(j, i, scan.nextInt());\n\t\t\t\trank[f] = of.start(x, y);\n\t\t\t}\n\t\t\t// for (int f = 0; f < 2; f++)\n\t\t\t// for (int i = 0; i < rank[f].length; i++)\n\t\t\t// System.out.println(f + \" \" + rank[f][i].sec + \" \" +\n\t\t\t// rank[f][i].rooms);\n\t\t\tstopCpuTime = threadMXBean.getCurrentThreadCpuTime();\n\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tint j = rank[1].length - 1;\n\t\t\tfor (int i = 0; i < rank[0].length; i++)\n\t\t\t\tfor (; j >= 0; j--)\n\t\t\t\t\tif (rank[0][i].rooms + rank[1][j].rooms < r)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\telse {\n\t\t\t\t\t\tint t = rank[0][i].sec + rank[1][j].sec;\n\t\t\t\t\t\tif (min > t)\n\t\t\t\t\t\t\tmin = t;\n\t\t\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\n\t\tscan.close();\n\t\t// stopCpuTime = threadMXBean.getCurrentThreadCpuTime();\n\t\t//System.out.println(\"CPU=\" + (stopCpuTime - startCpuTime) / 1000000);\n\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Rank {\n\tpublic Rank(int r, int cnt) {\n\t\tsec = r;\n\t\trooms = cnt;\n\t}\n\n\tint sec, rooms;\n}\n\nclass Office {\n\tclass Ent {\n\t\tpublic Ent(int _sec, int _w, int _h) {\n\t\t\tsec = _sec;\n\t\t\tw = _w;\n\t\t\th = _h;\n\t\t}\n\n\t\tint sec, w, h;\n\t}\n\n\tclass EntComp implements Comparator<Ent> {\n\n\t\t@Override\n\t\tpublic int compare(Ent o1, Ent o2) {\n\t\t\tif (o1.sec > o2.sec)\n\t\t\t\treturn 1;\n\t\t\telse if (o1.sec == o2.sec)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t}\n\n\tint R;\n\tint[][] roomS;\n\tboolean[][] roomF;\n\tPriorityQueue<Ent> ent = new PriorityQueue<Ent>(10, new EntComp());\n\n\tpublic Office(int w, int h, int r) {\n\t\troomS = new int[w][h];\n\t\troomF = new boolean[w][h];\n\t\tR = r;\n\t}\n\n\tpublic Rank[] start(int x, int y) {\n\t\troomF[x - 1][y - 1] = true;\n\t\tent.add(new Ent(roomS[x - 1][y - 1], x - 1, y - 1));\n\t\tList<Rank> rank = new ArrayList<Rank>();\n\t\trank.add(new Rank(0, 0));\n\n\t\tint r = 1, cnt = 0;\n\t\tEnt c;\n\t\twhile (true) {\n\t\t\tc = ent.poll();\n\t\t\tif (c != null && c.sec <= r)\n\t\t\t\tcnt++;\n\t\t\telse {\n\t\t\t\trank.add(new Rank(r, cnt));\n\t\t\t\tif (cnt >= R)\n\t\t\t\t\tbreak;\n\t\t\t\tif (c != null) {\n\t\t\t\t\tr = c.sec;\n\t\t\t\t\tcnt++;\n\t\t\t\t} else\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (c.h > 0 && !roomF[c.w][c.h - 1]) {\n\t\t\t\troomF[c.w][c.h - 1] = true;\n\t\t\t\tent.add(new Ent(roomS[c.w][c.h - 1], c.w, c.h - 1));\n\t\t\t}\n\t\t\tif (c.w > 0 && !roomF[c.w - 1][c.h]) {\n\t\t\t\troomF[c.w - 1][c.h] = true;\n\t\t\t\tent.add(new Ent(roomS[c.w - 1][c.h], c.w - 1, c.h));\n\t\t\t}\n\t\t\tif (c.h + 1 < roomF[0].length && !roomF[c.w][c.h + 1]) {\n\t\t\t\troomF[c.w][c.h + 1] = true;\n\t\t\t\tent.add(new Ent(roomS[c.w][c.h + 1], c.w, c.h + 1));\n\t\t\t}\n\t\t\tif (c.w + 1 < roomF.length && !roomF[c.w + 1][c.h]) {\n\t\t\t\troomF[c.w + 1][c.h] = true;\n\t\t\t\tent.add(new Ent(roomS[c.w + 1][c.h], c.w + 1, c.h));\n\t\t\t}\n\n\t\t}\n\t\treturn ((Rank[]) rank.toArray(new Rank[0]));\n\t}\n\n\tpublic void set(int w, int h, int sec) {\n\t\troomS[w][h] = sec;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint INF = 1<<25;\n\t\twhile (true) {\n\t\t\tr = scanner.nextInt();\n\t\t\tif (r == 0)\n\t\t\t\tbreak;\n\t\t\tmap = new int[2][250001];\n\t\t\tfor (int[] m : map)\n\t\t\t\tArrays.fill(m, INF);\n\t\t\tmap[0][0] = map[1][0] = 0;\n\n\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\tw = scanner.nextInt();\n\t\t\t\th = scanner.nextInt();\n\t\t\t\tsx = scanner.nextInt() - 1;\n\t\t\t\tsy = scanner.nextInt() - 1;\n\t\t\t\tint[][] m = new int[h][w];\n\t\t\t\tfor (int j = 0; j < h; j++)\n\t\t\t\t\tfor (int k = 0; k < w; k++)\n\t\t\t\t\t\tm[j][k] = scanner.nextInt();\n\t\t\t\tslove(m, i);\n\t\t\t}\n\t\t\tint res = INF;\n\t\t\tfor (int i = 0; i <= r; i++)\n\t\t\t\tres = Math.min(res, map[0][i] + map[1][r - i]);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tprivate void slove(int[][] m, int i) {\n\t\tboolean[][] b = new boolean[h][w];\n\t\tb[sy][sx] = true;\n\t\tPriorityQueue<Point> pq = new PriorityQueue<Point>();\n\t\tpq.offer(new Point(m[sy][sx], sy, sx));\n\t\tint l = -1;\n\t\tint id = 1;\n\t\twhile (!pq.isEmpty()) {\n\t\t\tPoint p = pq.poll();\n\t\t\tl = Math.max(l, p.k);\n\t\t\tmap[i][id++] = l;\n\t\t\tfor (int[] mo : move) {\n\t\t\t\tint ny = p.y + mo[0];\n\t\t\t\tint nx = p.x + mo[1];\n\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (b[ny][nx])\n\t\t\t\t\tcontinue;\n\t\t\t\tb[ny][nx] = true;\n\t\t\t\tpq.offer(new Point(m[ny][nx], ny, nx));\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate boolean isOK(int ny, int nx) {\n\t\tif (0 <= ny && ny < h && 0 <= nx && nx < w)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tint r, w, h, sx, sy;\n\tint[][] map;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\n\tclass Point implements Comparable<Point> {\n\t\tint k, y, x;\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Point [k=\" + k + \", y=\" + y + \", x=\" + x + \"]\";\n\t\t}\n\n\t\tpublic Point(int k, int y, int x) {\n\t\t\tsuper();\n\t\t\tthis.k = k;\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Point o) {\n\t\t\treturn k - o.k;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "### constant\n\nMAX_INT = 1 << 30\n\n### main\n\nloop do\n  r = gets.strip.to_i\n  break if r == 0\n\n  mlss = []\n\n  for k in (0..1)\n    w, h, ex, ey = gets.strip.split(' ').map{|s| s.to_i}\n    ex -= 1\n    ey -= 1\n    als = h.times.map{gets.strip.split(' ').map{|s| s.to_i}}\n\n    mls = h.times.map{w.times.map{MAX_INT}}\n    visited = h.times.map{w.times.map{false}}\n\n    mls[ey][ex] = als[ey][ex]\n    visited[ey][ex] = als[ey][ex]\n    q = [[ex, ey]]\n    mlq = []\n\n    while ! q.empty?\n      u = q.min{|a, b| mls[a[1]][a[0]] <=> mls[b[1]][b[0]]}\n      q.delete u\n\n      x, y = u\n\n      mlq << mls[y][x]\n      break if mlq.length > r\n\n      nbrs = []\n      nbrs << [x - 1, y] if x > 0\n      nbrs << [x + 1, y] if x < w - 1\n      nbrs << [x, y - 1] if y > 0\n      nbrs << [x, y + 1] if y < h - 1\n\n      for v in nbrs\n        vx, vy = v\n        l = [mls[y][x], als[vy][vx]].max\n\n        if mls[vy][vx] > l\n          mls[vy][vx] = l\n          if ! visited[vy][vx]\n            visited [vy][vx] = true\n            q << [vx, vy]\n          end\n        end\n      end\n    end\n\n    mlss << [0] + mlq\n  end\n  #p mlss\n\n  min_sum = MAX_INT\n\n  mlen0 = mlss[0].length\n  mlen1 = mlss[1].length\n\n  i0 = 0\n  i1 = r - i0\n\n  if i1 >= mlen1\n    i1 = mlen1 - 1\n    i0 = r - i1\n  end\n\n  while i0 < mlen0 && i1 >= 0\n    sum = mlss[0][i0] + mlss[1][i1]\n    min_sum = sum if min_sum > sum\n\n    i0 += 1\n    i1 -= 1\n  end\n\n  puts min_sum\nend"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int R;\n\tstatic int[] DR = { 1, 0, -1, 0 };\n\tstatic int[] DC = { 0, 1, 0, -1 };\n\n\tstatic int[][] count() {\n\t\tint W = sc.nextInt();\n\t\tint H = sc.nextInt();\n\t\tint X = sc.nextInt() - 1;\n\t\tint Y = sc.nextInt() - 1;\n\t\tint[][] L = new int[H][W];\n\t\tTreeSet<Integer> level = new TreeSet<Integer>();\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tL[i][j] = sc.nextInt();\n\t\t\t\tlevel.add(L[i][j]);\n\t\t\t}\n\t\t}\n\t\tint[][] ret = new int[level.size() + 1][2];\n\t\tint t = 1;\n\t\tboolean[][] visited = new boolean[H][W];\n\t\tint count = 0;\n\t\tPriorityQueue<Pos> pos = new PriorityQueue<Pos>();\n\t\tpos.add(new Pos(X, Y, 1));\n\t\tvisited[Y][X] = true;\n\t\tfor (int l : level) {\n\t\t\twhile (!pos.isEmpty()) {\n\t\t\t\tif (pos.peek().l > l) break;\n\t\t\t\tPos cur = pos.poll();\n\t\t\t\t++count;\n\t\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\t\tint nx = cur.x + DC[i];\n\t\t\t\t\tint ny = cur.y + DR[i];\n\t\t\t\t\tif (nx < 0 || W <= nx || ny < 0 || H <= ny || visited[ny][nx]) continue;\n\t\t\t\t\tpos.add(new Pos(nx, ny, L[ny][nx]));\n\t\t\t\t\tvisited[ny][nx] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tret[t][0] = l;\n\t\t\tret[t][1] = count;\n\t\t\t++t;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic int solve(int[][] c1, int[][] c2) {\n\t\tint min = Integer.MAX_VALUE;\n\t\tint pos = c2.length - 1;\n\t\tfor (int i = 0; i < c1.length; ++i) {\n\t\t\tint count = c1[i][1];\n\t\t\tif (count >= R) {\n\t\t\t\tmin = Math.min(min, c1[i][0]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile (pos > 0 && count + c2[pos - 1][1] >= R) {\n\t\t\t\t--pos;\n\t\t\t}\n\t\t\tif (count + c2[pos][1] >= R) min = Math.min(min, c1[i][0] + c2[pos][0]);\n\t\t}\n\t\treturn min;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tR = sc.nextInt();\n\t\t\tif (R == 0) break;\n\t\t\tint[][] c1 = count();\n\t\t\tint[][] c2 = count();\n\t\t\tSystem.out.println(Math.min(solve(c1, c2), solve(c2, c1)));\n\t\t}\n\t}\n\n\tstatic class Pos implements Comparable<Pos> {\n\t\tint x, y, l;\n\n\t\tPos(int x, int y, int l) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.l = l;\n\t\t}\n\n\t\tpublic int compareTo(Pos o) {\n\t\t\treturn this.l - o.l;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int R;\n\tstatic int[] DR = { 1, 0, -1, 0 };\n\tstatic int[] DC = { 0, 1, 0, -1 };\n\n\tstatic int[][] count() {\n\t\tint W = sc.nextInt();\n\t\tint H = sc.nextInt();\n\t\tint X = sc.nextInt() - 1;\n\t\tint Y = sc.nextInt() - 1;\n\t\tint[][] L = new int[H][W];\n\t\tTreeSet<Integer> level = new TreeSet<Integer>();\n\t\tsc.nextLine();\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tString line = sc.nextLine();\n\t\t\tint pos = 0;\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\twhile (line.charAt(pos) == ' ') {\n\t\t\t\t\t++pos;\n\t\t\t\t}\n\t\t\t\tint v = 0;\n\t\t\t\twhile (pos < line.length() && line.charAt(pos) != ' ') {\n\t\t\t\t\tv *= 10;\n\t\t\t\t\tv += line.charAt(pos) - '0';\n\t\t\t\t\t++pos;\n\t\t\t\t}\n\t\t\t\tL[i][j] = v;\n\t\t\t\tlevel.add(v);\n\t\t\t}\n\t\t}\n\t\tint[][] ret = new int[level.size() + 1][2];\n\t\tint t = 1;\n\t\tboolean[][] visited = new boolean[H][W];\n\t\tint count = 0;\n\t\tPriorityQueue<Pos> pos = new PriorityQueue<Pos>();\n\t\tpos.add(new Pos(X, Y, 1));\n\t\tvisited[Y][X] = true;\n\t\tfor (int l : level) {\n\t\t\twhile (!pos.isEmpty()) {\n\t\t\t\tif (pos.peek().l > l) break;\n\t\t\t\tPos cur = pos.poll();\n\t\t\t\t++count;\n\t\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\t\tint nx = cur.x + DC[i];\n\t\t\t\t\tint ny = cur.y + DR[i];\n\t\t\t\t\tif (nx < 0 || W <= nx || ny < 0 || H <= ny || visited[ny][nx]) continue;\n\t\t\t\t\tpos.add(new Pos(nx, ny, L[ny][nx]));\n\t\t\t\t\tvisited[ny][nx] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tret[t][0] = l;\n\t\t\tret[t][1] = count;\n\t\t\t++t;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic int solve(int[][] c1, int[][] c2) {\n\t\tint min = Integer.MAX_VALUE;\n\t\tint pos = c2.length - 1;\n\t\tfor (int i = 0; i < c1.length; ++i) {\n\t\t\tint count = c1[i][1];\n\t\t\tif (count >= R) {\n\t\t\t\tmin = Math.min(min, c1[i][0]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twhile (pos > 0 && count + c2[pos - 1][1] >= R) {\n\t\t\t\t--pos;\n\t\t\t}\n\t\t\tif (count + c2[pos][1] >= R) min = Math.min(min, c1[i][0] + c2[pos][0]);\n\t\t}\n\t\treturn min;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tR = sc.nextInt();\n\t\t\tif (R == 0) break;\n\t\t\tint[][] c1 = count();\n\t\t\tint[][] c2 = count();\n\t\t\tSystem.out.println(Math.min(solve(c1, c2), solve(c2, c1)));\n\t\t}\n\t}\n\n\tstatic class Pos implements Comparable<Pos> {\n\t\tint x, y, l;\n\n\t\tPos(int x, int y, int l) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.l = l;\n\t\t}\n\n\t\tpublic int compareTo(Pos o) {\n\t\t\treturn this.l - o.l;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.Map.Entry;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\npublic class Main {\n\n\tpublic static final long INF = Long.MAX_VALUE / 4 - 1;\n\t\n\tpublic static final int[][] move_dir = new int[][]{\n\t\t{1, 0}, {-1, 0}, {0, 1}, {0, -1}\n\t};\n\t\n\tpublic static class Auth implements Comparable<Auth>{\n\t\tint x, y;\n\t\tlong level;\n\n\t\tpublic Auth(int x, int y, long level) {\n\t\t\tsuper();\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.level = level;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Auth arg0) {\n\t\t\treturn this.level < arg0.level ? -1 : this.level > arg0.level ? 1 : 0;\n\t\t}\n\t}\n\t\n\tpublic static boolean is_ok(int H, int W, int y, int x){\n\t\tif(x < 0 || x >= W || y < 0 || y >= H){ return false; }\n\t\treturn true;\n\t}\n\t\n\tpublic static long[] process(Scanner sc, final int R) throws IOException{\n\t\tfinal int W = sc.nextInt();\n\t\tfinal int H = sc.nextInt();\n\t\tfinal int X = sc.nextInt() - 1;\n\t\tfinal int Y = sc.nextInt() - 1;\n\t\t\n\t\tlong[][] map = new long[H][W];\n\t\t\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\tfinal int level = sc.nextInt();\n\t\t\t\t\n\t\t\t\tmap[i][j] = level;\n\t\t\t}\n\t\t}\n\t\t\n\t\tTreeMap<Long, Integer> counts = new TreeMap<Long, Integer>();\n\t\tboolean[][] already = new boolean[H][W];\n\t\t\n\t\tPriorityQueue<Auth> queue = new PriorityQueue<Auth>();\n\t\tqueue.add(new Auth(X, Y, 1));\n\t\tcounts.put(0l, 0);\n\t\t\n\t\twhile(!queue.isEmpty()){\n\t\t\tAuth auth = queue.poll();\n\t\t\t\n\t\t\tif(already[auth.y][auth.x]){\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\talready[auth.y][auth.x] = true;\n\t\t\t\tif(!counts.containsKey(auth.level)){\n\t\t\t\t\tcounts.put(auth.level, 0);\n\t\t\t\t}\n\t\t\t\tcounts.put(auth.level, counts.get(auth.level) + 1);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int[] move : move_dir){\n\t\t\t\tfinal int nx = auth.x + move[0];\n\t\t\t\tfinal int ny = auth.y + move[1];\n\t\t\t\t\n\t\t\t\tif(!is_ok(H, W, ny, nx)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(already[ny][nx]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tqueue.add(new Auth(nx, ny, Math.max(auth.level, map[ny][nx])));\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong[] ret = new long[R + 1];\n\t\tArrays.fill(ret, INF);\n\t\tret[0] = 0l;\n\t\tint cnt = 1;\n\t\tfor(Entry<Long, Integer> entry : counts.entrySet()){\n\t\t\tfinal int next_cnt = Math.min(cnt + entry.getValue(), R + 1);\n\t\t\t\n\t\t\tfor(int i = cnt; i < next_cnt; i++){\n\t\t\t\tret[i] = entry.getKey();\n\t\t\t}\n\t\t\tcnt = next_cnt;\n\t\t}\n\t\t//System.out.println(Arrays.toString(ret));\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int R = sc.nextInt();\n\t\t\tif(R == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tlong[] one = process(sc, R);\n\t\t\tlong[] two = process(sc, R);\n\t\t\t\n\t\t\tlong min = INF;\n\t\t\tfor(int i = 0; i <= R; i++){\n\t\t\t\tmin = Math.min(min, one[i] + two[R - i]);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t\t\n\t\t\tSystem.gc();\n\t\t}\n\t\t\n\t\tsc.close();\n\t}\n\t\n\tpublic static class Scanner {\n\t    private BufferedReader br;\n\t    private StringTokenizer tok;\n\n\t    public Scanner(InputStream is) throws IOException {\n\t        br = new BufferedReader(new InputStreamReader(is));\n\t    }\n\n\t    private void getLine() throws IOException {\n\t        while (!hasNext()) { tok = new StringTokenizer(br.readLine()); }\n\t    }\n\n\t    private boolean hasNext() {\n\t        return tok != null && tok.hasMoreTokens();\n\t    }\n\n\t    public String next() throws IOException {\n\t        getLine(); return tok.nextToken();\n\t    }\n\n\t    public int nextInt() throws IOException {\n\t        return Integer.parseInt(next());\n\t    }\n\t    \n\t    public void close() throws IOException {\n\t        br.close();\n\t    }\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint w,h,x,y,a[505][505],b[505][505],c[505][505];\n\npair<int,int> make_P(int ma,int mb){pair<int,int> ret; ret.first=ma; ret.second=mb; return ret;}\n\npair<int,pair<int,int>> make_PP(int ma,pair<int,int> mb){pair<int,pair<int,int>> ret; ret.first=ma; ret.second=mb; return ret;}\n\nbool f(pair<int,pair<int,int>> fx,pair<int,pair<int,int>> fy){return fx.first<=fy.first;}\n\nvoid ww(int wx,int wy){\n\tc[wx][wy]=1;\n\tif(b[wx][wy+1]==1&&c[wx][wy+1]==0)ww(wx,wy+1);\n\tif(b[wx][wy-1]==1&&c[wx][wy-1]==0)ww(wx,wy-1);\n\tif(b[wx+1][wy]==1&&c[wx+1][wy]==0)ww(wx+1,wy);\n\tif(b[wx-1][wy]==1&&c[wx-1][wy]==0)ww(wx-1,wy);\n}\n\nvector<int> els(vector<int> vp){\n\tvector<int> ret;\n\tint s=vp.size();\n\tret.push_back(vp[0]);\n\tfor(int i=1;i<s;i++){\n\t\tif(vp[i]!=vp[i-1])ret.push_back(vp[i]);\n\t}\n\treturn ret;\n}\n\nvector<pair<int,int>> office(){\n\tfor(int i=0;i<505;i++)for(int j=0;j<505;j++){b[i][j]=0; c[i][j]=0;}\n\tvector<pair<int,pair<int,int>>> v;\n\tfor(int i=1;i<=h;i++)for(int j=1;j<=h;j++)v.push_back(make_PP(a[i][j],make_P(i,j)));\n\tsort(v.begin(),v.end(),f);\n\t//v=els(v);\n\tvector<pair<int,int>> ret;\n\tret.push_back(make_P(0,0));\n\tint s=v.size();\n\tb[x][y]=1; c[x][y]=1;\n\tfor(int i=0;i<s;i++){\n\t\t/*for(int j=1;j<=h;j++)for(int k=1;k<=w;k++){\n\t\t\tif(a[j][k]==v[i]){\n\t\t\t\tb[j][k]=1;\n\t\t\t\tif(c[j][k+1]+c[j][k-1]+c[j+1][k]+c[j-1][k]!=0)ww(j,k);\n\t\t\t}\n\t\t}*/\n\t\tb[v[i].second.first][v[i].second.second]=1;\n\t\tif(c[v[i].second.first][v[i].second.second+1]+c[v[i].second.first][v[i].second.second-1]+c[v[i].second.first+1][v[i].second.second]+c[v[i].second.first-1][v[i].second.second]!=0)ww(v[i].second.first,v[i].second.second);\n\t\tint sum=0;\n\t\tfor(int j=1;j<=h;j++)for(int k=1;k<=w;k++)sum+=c[j][k];\n\t\tret.push_back(make_P(v[i].first,sum));\n\t}\n\treturn ret;\n}\n\nint main(){\nwhile(1){\n\tint r,s[2];\n\tscanf(\"%d\",&r);\n\tif(r==0)break;\n\tvector<pair<int,int>> vvp[2];\n\tfor(int i=0;i<=1;i++){\n\t\tfor(int k=0;k<505;k++)for(int j=0;j<505;j++)a[k][j]=0;\n\t\tscanf(\"%d%d%d%d\",&w,&h,&x,&y);\n\t\tfor(int j=1;j<=h;j++)for(int k=1;k<=w;k++)scanf(\"%d\",&a[j][k]);\n\t\tvvp[i]=office();\n\t\ts[i]=vvp[i].size();\n\t}\n\tint n=s[1]-1,ret=200000000;\n\tfor(int i=0;i<s[0];i++){\n\t\tif(n!=0)while(vvp[0][i].second+vvp[1][n-1].second>=r){n--; if(n==0)break;}\n\t\tif(vvp[0][i].second+vvp[1][n].second>=r)ret=min(ret,vvp[0][i].first+vvp[1][n].first);\n\t}\n\tprintf(\"%d\\n\",ret);\n}\nreturn 0;\n}"
  },
  {
    "language": "C#",
    "code": "using static System.Math;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class PriorityQueue<T> where T : IComparable\n{\n\tprivate IComparer<T> _comparer = null;\n\tprivate int _type = 0;\n\tprivate T[] _heap;\n\tprivate int _sz = 0;\n\tprivate int _count = 0;\n\tpublic PriorityQueue(int maxSize, IComparer<T> comparer)\n\t{\n\t\t_heap = new T[maxSize];\n\t\t_comparer = comparer;\n\t}\n\tpublic PriorityQueue(int maxSize, int type = 0)\n\t{\n\t\t_heap = new T[maxSize];\n\t\t_type = type;\n\t}\n\tprivate int Compare(T x, T y)\n\t{\n\t\tif (_comparer != null) return _comparer.Compare(x, y);\n\t\treturn _type == 0 ? x.CompareTo(y) : y.CompareTo(x);\n\t}\n\tpublic void Push(T x)\n\t{\n\t\t_count++;\n\t\tvar i = _sz++;\n\t\twhile (i > 0)\n\t\t{\n\t\t\tvar p = (i - 1) / 2;\n\t\t\tif (Compare(_heap[p], x) <= 0) break;\n\t\t\t_heap[i] = _heap[p];\n\t\t\ti = p;\n\t\t}\n\t\t_heap[i] = x;\n\t}\n\tpublic T Pop()\n\t{\n\t\t_count--;\n\t\tT ret = _heap[0];\n\t\tT x = _heap[--_sz];\n\t\tint i = 0;\n\t\twhile (i * 2 + 1 < _sz)\n\t\t{\n\t\t\tint a = i * 2 + 1;\n\t\t\tint b = i * 2 + 2;\n\t\t\tif (b < _sz && Compare(_heap[b], _heap[a]) < 0) a = b;\n\t\t\tif (Compare(_heap[a], x) >= 0) break;\n\t\t\t_heap[i] = _heap[a];\n\t\t\ti = a;\n\t\t}\n\t\t_heap[i] = x;\n\t\treturn ret;\n\t}\n\tpublic int Count() => _count;\n\tpublic T Peek() => _heap[0];\n\tpublic bool Contains(T x)\n\t{\n\t\tfor (int i = 0; i < _sz; i++) if (x.Equals(_heap[i])) return true;\n\t\treturn false;\n\t}\n\tpublic void Clear()\n\t{\n\t\twhile (this.Count() > 0) this.Pop();\n\t}\n\tpublic IEnumerator<T> GetEnumerator()\n\t{\n\t\tvar ret = new List<T>();\n\t\twhile (this.Count() > 0)\n\t\t{\n\t\t\tret.Add(this.Pop());\n\t\t}\n\t\tforeach (var r in ret)\n\t\t{\n\t\t\tthis.Push(r);\n\t\t\tyield return r;\n\t\t}\n\t}\n\tpublic T[] ToArray()\n\t{\n\t\tT[] array = new T[_sz];\n\t\tint i = 0;\n\t\tforeach (var r in this)\n\t\t{\n\t\t\tarray[i++] = r;\n\t\t}\n\t\treturn array;\n\t}\n}\n\npublic class Room : IComparable\n{\n\tpublic int x { get; set; }\n\tpublic int y { get; set; }\n\tpublic int d { get; set; }\n\tpublic int CompareTo(object obj)\n\t{\n\t\tvar x = (Room)obj;\n\t\tif (this.d > x.d) return 1;\n\t\telse if (this.d == x.d) return 0;\n\t\telse return -1;\n\t}\n}\n\n\npublic class P\n{\n\tpublic int x { get; set; }\n\tpublic int y { get; set; }\n}\n\npublic class hello\n{\n\tpublic static int[] dx, dy;\n\tpublic static void Main()\n\t{\n\t\tdx = new int[] { 0, 1, 0, -1 };\n\t\tdy = new int[] { 1, 0, -1, 0 };\n\t\twhile (true)\n\t\t{\n\t\t\tvar r = int.Parse(Console.ReadLine().Trim());\n\t\t\tif (r == 0) break;\n\t\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\t\tvar w1 = int.Parse(line[0]);\n\t\t\tvar h1 = int.Parse(line[1]);\n\t\t\tvar sy1 = int.Parse(line[2]) - 1;\n\t\t\tvar sx1 = int.Parse(line[3]) - 1;\n\t\t\tvar map1 = new int[h1, w1];\n\t\t\tfor (int i = 0; i < h1; i++)\n\t\t\t{\n\t\t\t\tline = Console.ReadLine().Trim().Split(' ');\n\t\t\t\tfor (int j = 0; j < w1; j++)\n\t\t\t\t\tmap1[i, j] = int.Parse(line[j]);\n\t\t\t}\n\t\t\tline = Console.ReadLine().Trim().Split(' ');\n\t\t\tvar w2 = int.Parse(line[0]);\n\t\t\tvar h2 = int.Parse(line[1]);\n\t\t\tvar sy2 = int.Parse(line[2]) - 1;\n\t\t\tvar sx2 = int.Parse(line[3]) - 1;\n\t\t\tvar map2 = new int[h2, w2];\n\t\t\tfor (int i = 0; i < h2; i++)\n\t\t\t{\n\t\t\t\tline = Console.ReadLine().Trim().Split(' ');\n\t\t\t\tfor (int j = 0; j < w2; j++)\n\t\t\t\t\tmap2[i, j] = int.Parse(line[j]);\n\t\t\t}\n\n\t\t\tvar ps1 = getList(map1, h1, w1, sx1, sy1);\n\t\t\tvar ps2 = getList(map2, h2, w2, sx2, sy2);\n\t\t\tvar ans = getAns(ps1, ps2, r);\n\t\t\tConsole.WriteLine(ans);\n\t\t}\n\t}\n\tstatic int getAns(List<P> ps1, List<P> ps2, int r)\n\t{\n\t\tvar ans = int.MaxValue;\n\t\tvar pc = ps1.Count();\n\t\tfor (int i = 0; i < pc; i++)\n\t\t{\n\t\t\tvar w = BS(ps2, r, ps1[i].y);\n\t\t\tif (w != -1) ans = Min(ans, ps1[i].x + ps2[w].x);\n\t\t}\n\t\treturn ans;\n\t}\n\tstatic int BS(List<P> ps, int r, int tv)\n\t{\n\t\tvar pc = ps.Count();\n\t\tif (tv + ps[pc - 1].y < r) return -1;\n\t\tif (tv >= r) return 0;\n\t\tvar ng = 0;\n\t\tvar ok = pc - 1;\n\t\twhile (ok - ng > 1)\n\t\t{\n\t\t\tvar mid = ng + (ok - ng) / 2;\n\t\t\tif (tv + ps[mid].y >= r) ok = mid;\n\t\t\telse ng = mid;\n\t\t}\n\t\treturn ok;\n\t}\n\tstatic List<P> getList(int[,] map, int h, int w, int sx, int sy)\n\t{\n\t\tvar used = new bool[h, w];\n\t\tvar dic = new Dictionary<int, int>();\n\t\tvar pq = new PriorityQueue<Room>(h * w+ 10);\n\t\tpq.Push(new Room { x = sx, y = sy, d = 1 });\n\t\tused[sx, sy] = true;\n\t\tvar Lnow = 1;\n\t\twhile (pq.Count() > 0)\n\t\t{\n\t\t\tvar t = pq.Pop();\n\t\t\tif (t.d > Lnow) Lnow = t.d;\n\t\t\tif (dic.ContainsKey(Lnow)) dic[Lnow]++;\n\t\t\telse dic[Lnow] = 1;\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tvar nx = t.x + dx[i];\n\t\t\t\tvar ny = t.y + dy[i];\n\t\t\t\tif (nx >= 0 && nx < h && ny >= 0 && ny < w && !used[nx, ny])\n\t\t\t\t{\n\t\t\t\t\tpq.Push(new Room { x = nx, y = ny, d = map[nx, ny] });\n\t\t\t\t\tused[nx, ny] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvar ans = new List<P>();\n\t\tvar dicc = dic.Count();\n\t\tvar dic2 = dic.OrderBy(x => x.Key).ToArray();\n\t\tans.Add(new P { x = dic2[0].Key, y = dic2[0].Value });\n\t\tfor (int i = 1; i < dicc; i++)\n\t\t\tans.Add(new P { x = dic2[i].Key, y = dic2[i].Value + ans[i - 1].y });\n\t\tans.Insert(0, new P { x = 0, y = 0 });\n\t\treturn ans;\n\t}\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "## constant\n\nMAX_INT = 1 << 30\n\n### main\n\nloop do\n  r = gets.strip.to_i\n  break if r == 0\n\n  mlss = []\n\n  for k in (0..1)\n    w, h, ex, ey = gets.strip.split(' ').map{|s| s.to_i}\n    ex -= 1\n    ey -= 1\n    als = h.times.map{gets.strip.split(' ').map{|s| s.to_i}}\n\n    mls = h.times.map{w.times.map{MAX_INT}}\n    visited = h.times.map{w.times.map{false}}\n\n    mls[ey][ex] = als[ey][ex]\n    visited[ey][ex] = als[ey][ex]\n    q = [[ex, ey]]\n    mlq = []\n\n    while ! q.empty?\n      u = q.min{|a, b| mls[a[1]][a[0]] <=> mls[b[1]][b[0]]}\n      q.delete u\n\n      x, y = u\n\n      mlq << mls[y][x]\n      break if mlq.length > r\n\n      nbrs = []\n      nbrs << [x - 1, y] if x > 0\n      nbrs << [x + 1, y] if x < w - 1\n      nbrs << [x, y - 1] if y > 0\n      nbrs << [x, y + 1] if y < h - 1\n\n      for v in nbrs\n        vx, vy = v\n        l = [mls[y][x], als[vy][vx]].max\n\n        if mls[vy][vx] > l\n          mls[vy][vx] = l\n          if ! visited[vy][vx]\n            visited [vy][vx] = true\n            q << [vx, vy]\n          end\n        end\n      end\n    end\n\n    mlss << [0] + mlq\n  end\n  #p mlss\n\n  min_sum = MAX_INT\n\n  mlen0 = mlss[0].length\n  mlen1 = mlss[1].length\n\n  i0 = 0\n  i1 = r - i0\n\n  if i1 >= mlen1\n    i1 = mlen1 - 1\n    i0 = r - i1\n  end\n\n  while i0 < mlen0 && i1 >= 0\n    sum = mlss[0][i0] + mlss[1][i1]\n    min_sum = sum if min_sum > sum\n\n    i0 += 1\n    i1 -= 1\n  end\n\n  puts min_sum\nend"
  },
  {
    "language": "Ruby",
    "code": "class UnionFind\n\tdef initialize\n\t\t@obj_to_node = {}\n\tend\n\n\tdef add(obj)\n\t\t@obj_to_node[obj] ||= Node.new(obj)\n\tend\n\n\tdef size(x = nil)\n\t\tx ? @obj_to_node[x].root.size : @obj_to_node.size\n\tend\n\n\tclass Node\n\t\tdef initialize(obj)\n\t\t\t@obj = obj\n\t\t\t@parent = self\n\t\t\t@size = 1\n\t\t\t@rank = 0\n\t\tend\n\n\t\tdef root\n\t\t\treturn self if @parent == self\n\t\t\t@parent = @parent.root\n\t\tend\t\n\n\t\tattr_accessor :parent, :size, :rank\n\tend\n\n\tdef union(x, y)\n\t\tu = (@obj_to_node[x] ||= Node.new(x)).root\n\t\tv = (@obj_to_node[y] ||= Node.new(y)).root\n\t\treturn if u == v\n\t\tif u.rank > v.rank\n\t\t\tv.parent = u\n\t\t\tu.size += v.size\n\t\telsif v.rank > u.rank\n\t\t\tu.parent = v\n\t\t\tv.size += u.size\n\t\telse\n\t\t\tu.parent = v\n\t\t\tv.rank += 1\n\t\t\tv.size += u.size\n\t\tend\n\tend\n\n\tdef same?(x, y)\n\t\treturn false unless u = @obj_to_node[x]\n\t\treturn false unless v = @obj_to_node[y]\n\t\tu.root == v.root\n\tend\nend\n\n\nloop {\n\tr = gets.to_i\n\tbreak if r == 0\n\n\troom_auth = []\n\t2.times {\n\t\tw, h, x, y = gets.split.map &:to_i\n\t\ta = (1..h).map{gets.split.map &:to_i}\n\t\tedges = {}\n\t\t(0..h-1).each{|i|\n\t\t\t(0..w-1).each{|j|\n\t\t\t\tif i < h-1\n\t\t\t\t\tp1, p2 = a[i][j], a[i+1][j]\n\t\t\t\t\tp3 = (p1 > p2 ? p1 : p2)\n\t\t\t\t\t(edges[p3] ||= []) << [i*w+j, (i+1)*w+j]\n\t\t\t\tend\n\t\t\t\tif j < w-1\n\t\t\t\t\tp1, p2 = a[i][j], a[i][j+1]\n\t\t\t\t\tp3 = (p1 > p2 ? p1 : p2)\n\t\t\t\t\t(edges[p3] ||= []) << [i*w+j, i*w+j+1]\n\t\t\t\tend\n\t\t\t}\n\t\t}\n\n\t\tedges = edges.to_a.sort_by(&:first)\n\t\tuf = UnionFind.new\n\t\tuf.add((y-1)*w+x-1)\n\t\thash = {0 => 0, 1 => 1}\n\t\n\t\tuntil edges.empty?\n\t\t\tauth, auth_edges = edges.shift\n\t\t\tauth_edges.each{|e|\n\t\t\t\tuf.union(e[0], e[1])\n\t\t\t}\n\t\t\thash[auth] = uf.size((y-1)*w+x-1)\n\t\tend\n\t\troom_auth << hash.invert.to_a\n\t}\n\n\tmin = Float::INFINITY\n\n\tj = room_auth[1].size-1\n\t(0..room_auth[0].size-1).each{|i|\n\t\troom1, auth1 = room_auth[0][i]\n\t\tj -= 1 until j == 0 || room1 + room_auth[1][j-1][0] < r\n\t\troom2, auth2 = room_auth[1][j]\n\t\tmin = auth1 + auth2 if auth1 + auth2 < min\n\t}\n\tp min\n}"
  },
  {
    "language": "Ruby",
    "code": "class Array\n\tdef accum\n\t\tinject([0]){|a, x| a + [a[-1] + x]}\n\tend\n\n\tdef accum!\n\t\t(1..size-1).each{|i|\n\t\t\tself[i] += self[i-1]\n\t\t}\n\t\tself.unshift(0)\n\tend\n\n\tdef accum_2d\n\t\tac = map{|r| r.accum}\n\t\t(1..size-1).each{|i|\n\t\t\t(1..ac[0].size-1).each{|j|\n\t\t\t\tac[i][j] += ac[i-1][j]\n\t\t\t}\n\t\t}\n\t\tac.unshift([0] * ac[0].size)\n\t\tac\n\tend\n\n\tdef accum_2d!\n\t\teach{|r| r.accum!}\n\t\t(1..size-1).each{|i|\n\t\t\t(1..self[0].size-1).each{|j|\n\t\t\t\tself[i][j] += self[i-1][j]\n\t\t\t}\n\t\t}\n\t\tunshift([0] * self[0].size)\n\tend\n\t\t\n\tdef bsearch_first_index(l = 0, r = size - 1, &pred)\n\t\treturn nil if l > r\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch_first_index(l, c-1, &pred) || c\n\t\telse\n\t\t\tbsearch_first_index(c+1, r, &pred)\n\t\tend\n\tend\n\n\tdef bsearch_first_item(l = 0, r = size - 1, &pred)\n\t\ti = bsearch_first_index(l, r, &pred)\n\t\ti ? self[i] : nil\n\tend\n\n\tdef bsearch_last_index(l = 0, r = size - 1, &pred)\n\t\treturn nil if l > r\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch_last_index(c+1, r, &pred) || c\n\t\telse\n\t\t\tbsearch_last_index(l, c-1, &pred)\n\t\tend\n\tend\n\n\tdef bsearch_last_item(l = 0, r = size - 1, &pred)\n\t\ti = bsearch_last_index(l, r, &pred)\n\t\ti ? self[i] : nil\n\tend\nend\n\nclass UnionFind\n\tdef initialize\n\t\t@obj_to_node = {}\n\tend\n\n\tdef add(obj)\n\t\t@obj_to_node[obj] ||= Node.new(obj)\n\tend\n\n\tdef size(x = nil)\n\t\tx ? @obj_to_node[x].root.size : @obj_to_node.size\n\tend\n\n\tclass Node\n\t\tdef initialize(obj)\n\t\t\t@obj = obj\n\t\t\t@parent = self\n\t\t\t@size = 1\n\t\tend\n\n\t\tdef root\n\t\t\treturn self if @parent == self\n\t\t\t@parent = @parent.root\n\t\tend\t\n\n\t\tattr_accessor :parent, :size\n\tend\n\n\tdef union(x, y)\n\t\tu = (@obj_to_node[x] ||= Node.new(x)).root\n\t\tv = (@obj_to_node[y] ||= Node.new(y)).root\n\t\treturn if u == v\n\t\tu.parent = v.root\n\t\tv.size += u.size\n\tend\n\n\tdef same?(x, y)\n\t\treturn false unless u = @obj_to_node[x]\n\t\treturn false unless v = @obj_to_node[y]\n\t\tu.root == v.root\n\tend\nend\n\nloop {\n\tr = gets.to_i\n\tbreak if r == 0\n\n\troom_auth = []\n\t2.times {\n\t\tw, h, x, y = gets.split.map &:to_i\n\t\ta = (1..h).map{gets.split.map &:to_i}\n\t\tedges = []\n\t\t(0..h-1).each{|i|\n\t\t\t(0..w-1).each{|j|\n\t\t\t\tif i < h-1\n\t\t\t\t\tp1, p2 = a[i][j], a[i+1][j]\n\t\t\t\t\tedges << [[i, j], [i+1, j], p1 > p2 ? p1 : p2]\n\t\t\t\tend\n\t\t\t\tif j < w-1\n\t\t\t\t\tp1, p2 = a[i][j], a[i][j+1]\n\t\t\t\t\tedges << [[i, j], [i, j+1], p1 > p2 ? p1 : p2]\n\t\t\t\tend\n\t\t\t}\n\t\t}\n\t\tedges.sort_by!(&:last)\n\t\tuf = UnionFind.new\n\t\tuf.add([y-1,x-1])\n\t\thash = {0 => 0, 1 => 1}\n\t\n\t\tuntil edges.empty?\n\t\t\tauth = edges[0][-1]\n\t\t\twhile !edges.empty? && edges[0][-1] == auth\n\t\t\t\te = edges.shift\n\t\t\t\tuf.union(e[0], e[1])\n\t\t\tend\n\t\t\thash[auth] = uf.size([y-1, x-1])\n\t\tend\n\t\troom_auth << hash.invert.to_a\n\t}\n\n\tmin = Float::INFINITY\n\troom_auth.sort_by!(&:size)\n\troom_auth[0].each{|room1, auth1|\n\t\troom2, auth2 = room_auth[1].bsearch_first_item{|room2, auth2|\n\t\t\troom1 + room2 >= r\n\t\t}\n\t\tif auth2\n\t\t\tauth = auth1 + auth2\n\t\t\tmin = auth if auth < min\n\t\tend\n\t}\n\tp min\n}"
  },
  {
    "language": "Ruby",
    "code": "class UnionFind\n\tdef initialize\n\t\t@obj_to_node = {}\n\tend\n\n\tdef add(obj)\n\t\t@obj_to_node[obj] ||= Node.new(obj)\n\tend\n\n\tdef size(x = nil)\n\t\tx ? @obj_to_node[x].root.size : @obj_to_node.size\n\tend\n\n\tclass Node\n\t\tdef initialize(obj)\n\t\t\t@obj = obj\n\t\t\t@parent = self\n\t\t\t@size = 1\n\t\tend\n\n\t\tdef root\n\t\t\treturn self if @parent == self\n\t\t\t@parent = @parent.root\n\t\tend\t\n\n\t\tattr_accessor :parent, :size\n\tend\n\n\tdef union(x, y)\n\t\tu = (@obj_to_node[x] ||= Node.new(x)).root\n\t\tv = (@obj_to_node[y] ||= Node.new(y)).root\n\t\treturn if u == v\n\t\tu.parent = v.root\n\t\tv.size += u.size\n\tend\n\n\tdef same?(x, y)\n\t\treturn false unless u = @obj_to_node[x]\n\t\treturn false unless v = @obj_to_node[y]\n\t\tu.root == v.root\n\tend\nend\n\nloop {\n\tr = gets.to_i\n\tbreak if r == 0\n\n\troom_auth = []\n\t2.times {\n\t\tw, h, x, y = gets.split.map &:to_i\n\t\ta = (1..h).map{gets.split.map &:to_i}\n\t\tedges = []\n\t\t(0..h-1).each{|i|\n\t\t\t(0..w-1).each{|j|\n\t\t\t\tif i < h-1\n\t\t\t\t\tp1, p2 = a[i][j], a[i+1][j]\n\t\t\t\t\tedges << [[i, j], [i+1, j], p1 > p2 ? p1 : p2]\n\t\t\t\tend\n\t\t\t\tif j < w-1\n\t\t\t\t\tp1, p2 = a[i][j], a[i][j+1]\n\t\t\t\t\tedges << [[i, j], [i, j+1], p1 > p2 ? p1 : p2]\n\t\t\t\tend\n\t\t\t}\n\t\t}\n\t\tedges.sort_by!(&:last)\n\t\tuf = UnionFind.new\n\t\tuf.add([y-1,x-1])\n\t\thash = {0 => 0, 1 => 1}\n\t\n\t\tuntil edges.empty?\n\t\t\tauth = edges[0][-1]\n\t\t\twhile !edges.empty? && edges[0][-1] == auth\n\t\t\t\te = edges.shift\n\t\t\t\tuf.union(e[0], e[1])\n\t\t\tend\n\t\t\thash[uf.size([y-1, x-1])] = auth\n\t\tend\n\t\troom_auth << hash.to_a\n\t}\n\n\tmin = Float::INFINITY\n\troom_auth[0].each{|room1, auth1|\n\t\troom2, auth2 = room_auth[1].find{|room2, auth2|\n\t\t\troom1 + room2 >= r\n\t\t}\n\t\tif auth2\n\t\t\tauth = auth1 + auth2\n\t\t\tmin = auth if auth < min\n\t\tend\n\t}\n\tp min\n}"
  },
  {
    "language": "Ruby",
    "code": "class UnionFind\n\tdef initialize\n\t\t@obj_to_node = {}\n\tend\n\n\tdef add(obj)\n\t\t@obj_to_node[obj] ||= Node.new(obj)\n\tend\n\n\tdef size(x = nil)\n\t\tx ? @obj_to_node[x].root.size : @obj_to_node.size\n\tend\n\n\tclass Node\n\t\tdef initialize(obj)\n\t\t\t@obj = obj\n\t\t\t@parent = self\n\t\t\t@size = 1\n\t\tend\n\n\t\tdef root\n\t\t\treturn self if @parent == self\n\t\t\t@parent = @parent.root\n\t\tend\t\n\n\t\tattr_accessor :parent, :size\n\tend\n\n\tdef union(x, y)\n\t\tu = (@obj_to_node[x] ||= Node.new(x)).root\n\t\tv = (@obj_to_node[y] ||= Node.new(y)).root\n\t\treturn if u == v\n\t\tu.parent = v.root\n\t\tv.size += u.size\n\tend\n\n\tdef same?(x, y)\n\t\treturn false unless u = @obj_to_node[x]\n\t\treturn false unless v = @obj_to_node[y]\n\t\tu.root == v.root\n\tend\nend\n\nloop {\n\tr = gets.to_i\n\tbreak if r == 0\n\n\troom_auth = []\n\t2.times {\n\t\tw, h, x, y = gets.split.map &:to_i\n\t\ta = (1..h).map{gets.split.map &:to_i}\n\t\tedges = []\n\t\t(0..h-1).each{|i|\n\t\t\t(0..w-1).each{|j|\n\t\t\t\tif i < h-1\n\t\t\t\t\tp1, p2 = a[i][j], a[i+1][j]\n\t\t\t\t\tedges << [[i, j], [i+1, j], p1 > p2 ? p1 : p2]\n\t\t\t\tend\n\t\t\t\tif j < w-1\n\t\t\t\t\tp1, p2 = a[i][j], a[i][j+1]\n\t\t\t\t\tedges << [[i, j], [i, j+1], p1 > p2 ? p1 : p2]\n\t\t\t\tend\n\t\t\t}\n\t\t}\n\t\tedges.sort_by!(&:last)\n\t\tuf = UnionFind.new\n\t\tuf.add([y-1,x-1])\n\t\thash = {0 => 0, 1 => 1}\n\t\n\t\tuntil edges.empty?\n\t\t\tauth = edges[0][-1]\n\t\t\twhile !edges.empty? && edges[0][-1] == auth\n\t\t\t\te = edges.shift\n\t\t\t\tuf.union(e[0], e[1])\n\t\t\tend\n\t\t\thash[auth] = uf.size([y-1, x-1])\n\t\tend\n\t\troom_auth << hash.invert.to_a\n\t}\n\n\tmin = Float::INFINITY\n\troom_auth[0].each{|room1, auth1|\n\t\troom2, auth2 = room_auth[1].find{|room2, auth2|\n\t\t\troom1 + room2 >= r\n\t\t}\n\t\tif auth2\n\t\t\tauth = auth1 + auth2\n\t\t\tmin = auth if auth < min\n\t\tend\n\t}\n\tp min\n}"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_INT = 1 << 30\n\n### main\n\nloop do\n  r = gets.strip.to_i\n  break if r == 0\n\n  mlss = []\n\n  for k in (0..1)\n    w, h, ex, ey = gets.strip.split(' ').map{|s| s.to_i}\n    ex -= 1\n    ey -= 1\n    als = h.times.map{gets.strip.split(' ').map{|s| s.to_i}}\n\n    mls = h.times.map{w.times.map{MAX_INT}}\n    visited = h.times.map{w.times.map{false}}\n\n    mls[ey][ex] = als[ey][ex]\n    visited[ey][ex] = als[ey][ex]\n    q = [[ex, ey]]\n\n    while ! q.empty?\n      u = q.min{|a, b| mls[a[1]][a[0]] <=> mls[b[1]][b[0]]}\n      q.delete u\n\n      x, y = u\n      nbrs = []\n      nbrs << [x - 1, y] if x > 0\n      nbrs << [x + 1, y] if x < w - 1\n      nbrs << [x, y - 1] if y > 0\n      nbrs << [x, y + 1] if y < h - 1\n\n      for v in nbrs\n        vx, vy = v\n        l = [mls[y][x], als[vy][vx]].max\n\n        if mls[vy][vx] > l\n          mls[vy][vx] = l\n          if ! visited[vy][vx]\n            visited [vy][vx] = true\n            q << [vx, vy]\n          end\n        end\n      end\n    end\n\n    mlss << [0] + mls.flatten.sort\n  end\n  #p mlss\n\n  min_sum = MAX_INT\n\n  mlen0 = mlss[0].length\n  mlen1 = mlss[1].length\n\n  i0 = 0\n  i1 = r - i0\n\n  if i1 >= mlen1\n    i1 = mlen1 - 1\n    i0 = r - i1\n  end\n\n  while i0 < mlen0 && i1 >= 0\n    sum = mlss[0][i0] + mlss[1][i1]\n    min_sum = sum if min_sum > sum\n\n    i0 += 1\n    i1 -= 1\n  end\n\n  puts min_sum\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_INT = 1 << 30\n\n### main\n\nloop do\n  r = gets.strip.to_i\n  break if r == 0\n\n  mlss = []\n\n  for k in (0..1)\n    w, h, ex, ey = gets.strip.split(' ').map{|s| s.to_i}\n    ex -= 1\n    ey -= 1\n    als = h.times.map{gets.strip.split(' ').map{|s| s.to_i}}\n\n    mls = h.times.map{w.times.map{MAX_INT}}\n    visited = h.times.map{w.times.map{false}}\n\n    mls[ey][ex] = als[ey][ex]\n    visited[ey][ex] = als[ey][ex]\n    q = [[ex, ey]]\n\n    while ! q.empty?\n      u = q.min{|a, b| mls[a[1]][a[0]] <=> mls[b[1]][b[0]]}\n      q.delete u\n\n      x, y = u\n      nbrs = []\n      nbrs << [x - 1, y] if x > 0\n      nbrs << [x + 1, y] if x < w - 1\n      nbrs << [x, y - 1] if y > 0\n      nbrs << [x, y + 1] if y < h - 1\n\n      for v in nbrs\n        vx, vy = v\n        l = [mls[y][x], als[vy][vx]].max\n\n        if mls[vy][vx] > l\n          mls[vy][vx] = l\n          if ! visited[vy][vx]\n            visited [vy][vx] = true\n            q << [vx, vy]\n          end\n        end\n      end\n    end\n\n    mlss << [0] + mls.flatten.sort\n  end\n  #p mlss\n\n  min_sum = MAX_INT\n\n  mlen0 = mlss[0].length\n  mlen1 = mlss[1].length\n\n  i0 = 0\n  i1 = r - i0\n\n  while i0 < mlen0 && i1 >= 0\n    if i1 < mlen1\n      sum = mlss[0][i0] + mlss[1][i1]\n      min_sum = sum if min_sum > sum\n    end\n\n    i0 += 1\n    i1 -= 1\n  end\n\n  puts min_sum\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.range;\nimport std.container;\nimport std.algorithm;\nimport std.array;\nimport std.string;\nimport std.functional;\nimport std.conv;\nimport std.typecons;\n\nstruct P {\n    int y, x, level;\n    int opCmp(P o) {\n        return level - o.level;\n    }\n}\n\nint[] init() {\n    int W, H, X, Y; readf(\"%d %d %d %d\\n\", &W, &H, &X, &Y);\n    X--; Y--;\n    int[][] F = new int[][H];\n    foreach (i; 0 .. H) {\n        F[i] = readln.chomp.split(\" \").map!(to!int).array;\n    }\n    bool[][] used = new bool[][](H, W);\n    int[] L;\n    DList!P Q;\n    Q.insert(P(Y, X, F[Y][X])); used[Y][X] = true;\n    BinaryHeap!(Array!P, \"a >= b\") PQ;\n    static const dy = [0, 1, 0, -1],\n                 dx = [1, 0, -1, 0];\n    while (true) {\n        if (Q.empty) {\n            if (PQ.empty) break;\n            P next = PQ.front; PQ.removeFront;\n            if (used[next.y][next.x]) continue;\n            Q.insert(next);\n            used[next.y][next.x] = true;\n        } else {\n            P cur = Q.front; Q.removeFront;\n            L ~= cur.level;\n            F[cur.y][cur.x] = cur.level;\n            foreach (i; 0 .. 4) {\n                int ny = cur.y + dy[i],\n                    nx = cur.x + dx[i];\n                if (ny < 0 || ny >= H) continue;\n                if (nx < 0 || nx >= W) continue;\n                if (used[ny][nx]) continue;\n                if (F[ny][nx] <= cur.level) {\n                    Q.insert(P(ny, nx, cur.level));\n                    used[ny][nx] = true;\n                } else {\n                    PQ.insert(P(ny, nx, F[ny][nx]));\n                }\n            }\n        }\n    }\n    //foreach (ref _; F) _.writeln;\n    return L;\n}\n\nvoid main() {\n    int R;\n    while (readf(\"%d\\n\", &R), R) {\n        int[][] L = new int[][2];\n        foreach (i; 0 .. 2) {\n            L[i] = init;\n        }\n        int[] X = L[0].uniq.array;\n        int ans = int.max;\n        foreach (i; 0 .. 2) {\n            if (L[i].length < R) continue;\n            int lb = -1, ub = L[i].back + 1;\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (L[i].assumeSorted.lowerBound(mid + 1).length >= R) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            ans = min(ans, ub);\n        }\n        //writeln(\"ans \", ans);\n        foreach (x; X) {\n            int c = cast(int)L[0].assumeSorted.lowerBound(x + 1).length;\n            int r = R - c;\n            int lb = -1, ub = L[1].back + 1;\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (L[1].assumeSorted.lowerBound(mid + 1).length >= r) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            ans = min(ans, (x + ub));\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.range;\nimport std.container;\nimport std.algorithm;\nimport std.array;\nimport std.string;\nimport std.functional;\nimport std.conv;\nimport std.typecons;\n\nstruct P {\n    int y, x, level;\n    int opCmp(P o) {\n        return level - o.level;\n    }\n}\n\nint[] init() {\n    int W, H, X, Y; readf(\"%d %d %d %d\\n\", &W, &H, &X, &Y);\n    X--; Y--;\n    int[][] F = new int[][H];\n    foreach (i; 0 .. H) {\n        F[i] = readln.chomp.split(\" \").map!(to!int).array;\n    }\n    bool[][] used = new bool[][](H, W);\n    bool[][] usedPQ = new bool[][](H, W);\n    int[] L;\n    DList!P Q;\n    Q.insert(P(Y, X, F[Y][X])); used[Y][X] = true;\n    BinaryHeap!(Array!P, \"a >= b\") PQ;\n    static const dy = [0, 1, 0, -1],\n                 dx = [1, 0, -1, 0];\n    while (true) {\n        if (Q.empty) {\n            if (PQ.empty) break;\n            P next = PQ.front; PQ.removeFront;\n            Q.insert(next);\n            used[next.y][next.x] = true;\n        } else {\n            P cur = Q.front; Q.removeFront;\n            //L ~= cur.level;\n            F[cur.y][cur.x] = cur.level;\n            foreach (i; 0 .. 4) {\n                int ny = cur.y + dy[i],\n                    nx = cur.x + dx[i];\n                if (ny < 0 || ny >= H) continue;\n                if (nx < 0 || nx >= W) continue;\n                if (used[ny][nx]) continue;\n                if (F[ny][nx] <= cur.level) {\n                    Q.insert(P(ny, nx, cur.level));\n                    used[ny][nx] = true;\n                } else {\n                    if (usedPQ[ny][nx]) continue;\n                    usedPQ[ny][nx] = true;\n                    PQ.insert(P(ny, nx, F[ny][nx]));\n                }\n            }\n        }\n    }\n    foreach (_; F) {\n        L ~= _;\n    }\n    //foreach (ref _; F) _.writeln;\n    return L.sort.array;\n}\n\nint countUnder(int[] L, int k) {\n    int lb = 0, ub = cast(int)L.length;\n    while (lb + 1 < ub) {\n        int mid = (lb + ub) / 2;\n        if (L[mid] <= k) {\n            lb = mid;\n        } else {\n            ub = mid;\n        }\n    }\n    //\"countUnder\".writeln([k, ub]);\n    return ub;\n}\n\nvoid main() {\n    int R;\n    while (readf(\"%d\\n\", &R), R) {\n        int[][] L = new int[][2];\n        foreach (i; 0 .. 2) {\n            L[i] = init;\n        }\n        auto X = L[0].uniq;\n        int ans = int.max;\n        foreach (i; 0 .. 2) {\n            if (L[i].length < R) continue;\n            int lb = 0, ub = L[i].back + 1;\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (L[i].countUnder(mid) >= R) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            ans = (ans < ub ? ans : ub);\n        }\n        //writeln(\"ans \", ans);\n        foreach (x; X) {\n            int c = L[0].countUnder(x);\n            int r = R - c;\n            if (r <= 0) break;\n            if (r > L[1].length) continue;\n            int lb = 0, ub = cast(int)L[1].length - 1;\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (L[1].countUnder(L[1][mid]) >= r) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            //[r, c, L[1][ub]].writeln;\n            int cand = x + L[1][ub];\n            ans = (ans < cand ? ans : cand);\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.range;\nimport std.container;\nimport std.algorithm;\nimport std.array;\nimport std.string;\nimport std.functional;\nimport std.conv;\nimport std.typecons;\n\nstruct P {\n    int y, x, level;\n    int opCmp(P o) {\n        return level - o.level;\n    }\n}\n\nint R;\n\nint[] init() {\n    int W, H, X, Y; readf(\"%d %d %d %d\\n\", &W, &H, &X, &Y);\n    X--; Y--;\n    int[][] F = new int[][H];\n    foreach (i; 0 .. H) {\n        F[i] = readln.chomp.split(\" \").map!(to!int).array;\n    }\n    bool[][] used = new bool[][](H, W);\n    bool[][] usedPQ = new bool[][](H, W);\n    int[] L;\n    DList!P Q;\n    Q.insert(P(Y, X, F[Y][X])); used[Y][X] = true;\n    BinaryHeap!(Array!P, \"a >= b\") PQ;\n    static const dy = [0, 1, 0, -1],\n                 dx = [1, 0, -1, 0];\n    while (true) {\n        if (Q.empty) {\n            if (PQ.empty) break;\n            P next = PQ.front; PQ.removeFront;\n            if (used[next.y][next.x]) continue;\n            Q.insert(next);\n            used[next.y][next.x] = true;\n        } else {\n            P cur = Q.front; Q.removeFront;\n            L ~= cur.level;\n            if (L.length >= R) break;\n            F[cur.y][cur.x] = cur.level;\n            foreach (i; 0 .. 4) {\n                int ny = cur.y + dy[i],\n                    nx = cur.x + dx[i];\n                if (ny < 0 || ny >= H) continue;\n                if (nx < 0 || nx >= W) continue;\n                if (used[ny][nx]) continue;\n                if (F[ny][nx] <= cur.level) {\n                    Q.insert(P(ny, nx, cur.level));\n                    used[ny][nx] = true;\n                } else {\n                    if (usedPQ[ny][nx]) continue;\n                    usedPQ[ny][nx] = true;\n                    PQ.insert(P(ny, nx, F[ny][nx]));\n                }\n            }\n        }\n    }\n    //foreach (ref _; F) _.writeln;\n    return L;\n}\n\nint countUnder(int[] L, int k) {\n    int lb = 0, ub = cast(int)L.length;\n    if (L[lb] > k) return 0;\n    while (lb + 1 < ub) {\n        int mid = (lb + ub) / 2;\n        if (L[mid] <= k) {\n            lb = mid;\n        } else {\n            ub = mid;\n        }\n    }\n    //\"countUnder\".writeln([k, ub]);\n    return ub;\n}\n\nvoid main() {\n    while (readf(\"%d\\n\", &R), R) {\n        int[][] L = new int[][2];\n        foreach (i; 0 .. 2) {\n            L[i] = init;\n        }\n        auto X = [0] ~ L[0].uniq.array;\n        //X.map!(a => [a, countUnder(L[0], a)]).writeln;\n        auto Y = [0] ~ L[1].uniq.array;\n        //Y.map!(a => [a, countUnder(L[1], a)]).writeln;\n        int ans = int.max;\n        foreach (x; X) {\n            int c = L[0].countUnder(x);\n            if (c >= R) {\n                ans = min(ans, x);\n                break;\n            }\n            int r = R - c;\n            if (r > L[1].length) continue;\n            int lb = 0, ub = cast(int)Y.length - 1;\n            if (L[1].countUnder(Y[lb]) >= r) {\n                ans = min(ans, x + Y[lb]);\n                continue;\n            }\n            assert(L[1].countUnder(Y[ub]) >= r);\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (L[1].countUnder(Y[mid]) >= r) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            ans = min(ans, x + Y[ub]);\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.range;\nimport std.container;\nimport std.algorithm;\nimport std.array;\nimport std.string;\nimport std.functional;\nimport std.conv;\nimport std.typecons;\n\nstruct P {\n    int y, x, level;\n    int opCmp(P o) {\n        return level - o.level;\n    }\n}\n\nint[] init() {\n    int W, H, X, Y; readf(\"%d %d %d %d\\n\", &W, &H, &X, &Y);\n    X--; Y--;\n    int[][] F = new int[][H];\n    foreach (i; 0 .. H) {\n        F[i] = readln.chomp.split(\" \").map!(to!int).array;\n    }\n    bool[][] used = new bool[][](H, W);\n    int[] L;\n    P[] Q;\n    Q ~= (P(Y, X, F[Y][X])); used[Y][X] = true;\n    BinaryHeap!(Array!P, \"a >= b\") PQ;\n    static const dy = [0, 1, 0, -1],\n                 dx = [1, 0, -1, 0];\n    while (true) {\n        if (Q.empty) {\n            if (PQ.empty) break;\n            P next = PQ.front; PQ.removeFront;\n            if (used[next.y][next.x]) continue;\n            Q ~= next;\n            used[next.y][next.x] = true;\n        } else {\n            P cur = Q.front; Q = Q[1 .. $];\n            L ~= cur.level;\n            F[cur.y][cur.x] = cur.level;\n            foreach (i; 0 .. 4) {\n                int ny = cur.y + dy[i],\n                    nx = cur.x + dx[i];\n                if (ny < 0 || ny >= H) continue;\n                if (nx < 0 || nx >= W) continue;\n                if (used[ny][nx]) continue;\n                if (F[ny][nx] <= cur.level) {\n                    Q ~= (P(ny, nx, cur.level));\n                    used[ny][nx] = true;\n                } else {\n                    PQ.insert(P(ny, nx, F[ny][nx]));\n                }\n            }\n        }\n    }\n    //foreach (ref _; F) _.writeln;\n    return L;\n}\n\nvoid main() {\n    int R;\n    while (readf(\"%d\\n\", &R), R) {\n        int[][] L = new int[][2];\n        foreach (i; 0 .. 2) {\n            L[i] = init;\n        }\n        int[] X = L[0].uniq.array;\n        int ans = int.max;\n        foreach (i; 0 .. 2) {\n            if (L[i].length < R) continue;\n            int lb = -1, ub = L[i].back + 1;\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (L[i].assumeSorted.lowerBound(mid + 1).length >= R) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            ans = min(ans, ub);\n        }\n        //writeln(\"ans \", ans);\n        foreach (x; X) {\n            int c = cast(int)L[0].assumeSorted.lowerBound(x + 1).length;\n            int r = R - c;\n            int lb = -1, ub = L[1].back + 1;\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (L[1].assumeSorted.lowerBound(mid + 1).length >= r) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            ans = min(ans, (x + ub));\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import core.stdc.stdio;\nimport std.stdio;\nimport std.container;\nimport std.typecons;\nimport std.algorithm;\n\nint[] CalcTable(int[] dst,int r){\n\tint w,h,x,y;\n\tscanf(\"%d%d%d%d\",&w,&h,&x,&y);\n\tstatic int[][] map = new int[][](500,500);\n\tforeach(i;0..h)\n\t\tforeach(j;0..w)\n\t\t\tscanf(\"%d\",&map[i][j]);\n\tint[] ret = dst[0..h*w+1];\n\tret[0]=0;\n\talias Tuple!(int,\"cost\",int,\"x\",int,\"y\") cxy;\n\tstatic cxy[] pqbuf = new cxy[250000];\n\tauto pq = BinaryHeap!(cxy[],\"a>b\")(pqbuf,0);\n\tstatic bool[][] used = new bool[][](500,500);\n\tforeach(i;0..h)\n\t\tforeach(j;0..w)\n\t\t\tused[i][j]=false;\n\tpq.insert(cxy(1,--x,--y));\n\tused[y][x]=true;\n\tint c;\n\tstatic immutable int[] dxy = [0,-1,0,1,0];\n\tint b=0;\n\twhile(!pq.empty){\n\t\tauto t=pq.front;\n\t\tpq.removeFront;\n\t\tb=max(b,t.cost);\n\t\tret[++c]=b;\n\t\tif(c==r)\n\t\t\tbreak;\n\t\tforeach(i;0..4){\n\t\t\tint nx=t.x+dxy[i];\n\t\t\tint ny=t.y+dxy[i+1];\n\t\t\tif(0<=nx&&nx<w&&0<=ny&&ny<h)\n\t\t\t\tif(!used[ny][nx]){\n\t\t\t\t\tpq.insert(cxy(map[ny][nx],nx,ny));\n\t\t\t\t\tused[ny][nx]=true;\n\t\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\t\nvoid main(){\n\twhile(1){\n\t\tint r;\n\t\tscanf(\"%d\",&r);\n\t\tif(r==0)\n\t\t\tbreak;\n\t\tstatic int[] buf1 = new int[250001];\n\t\tstatic int[] buf2 = new int[250001];\n\t\tint[] r1 = CalcTable(buf1,r);\n\t\tint[] r2 = CalcTable(buf2,r);\n\t\tint ans=1145141919;\n\t\tforeach(int i,p;r1){\n\t\t\tint j=r-i;\n\t\t\tif(j<r2.length)\n\t\t\t\tans = min(ans,p+r2[j]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.range;\nimport std.container;\nimport std.algorithm;\nimport std.array;\nimport std.string;\nimport std.functional;\nimport std.conv;\nimport std.typecons;\n\nstruct P {\n    int y, x, level;\n    int opCmp(P o) {\n        return level - o.level;\n    }\n}\n\nint[] init() {\n    int W, H, X, Y; readf(\"%d %d %d %d\\n\", &W, &H, &X, &Y);\n    X--; Y--;\n    int[][] F = new int[][H];\n    foreach (i; 0 .. H) {\n        F[i] = readln.chomp.split(\" \").map!(to!int).array;\n    }\n    bool[][] used = new bool[][](H, W);\n    bool[][] usedPQ = new bool[][](H, W);\n    int[] L;\n    DList!P Q;\n    Q.insert(P(Y, X, F[Y][X])); used[Y][X] = true;\n    BinaryHeap!(Array!P, \"a >= b\") PQ;\n    static const dy = [0, 1, 0, -1],\n                 dx = [1, 0, -1, 0];\n    while (true) {\n        if (Q.empty) {\n            if (PQ.empty) break;\n            P next = PQ.front; PQ.removeFront;\n            if (used[next.y][next.x]) continue;\n            Q.insert(next);\n            used[next.y][next.x] = true;\n        } else {\n            P cur = Q.front; Q.removeFront;\n            L ~= cur.level;\n            F[cur.y][cur.x] = cur.level;\n            foreach (i; 0 .. 4) {\n                int ny = cur.y + dy[i],\n                    nx = cur.x + dx[i];\n                if (ny < 0 || ny >= H) continue;\n                if (nx < 0 || nx >= W) continue;\n                if (used[ny][nx]) continue;\n                if (F[ny][nx] <= cur.level) {\n                    Q.insert(P(ny, nx, cur.level));\n                    used[ny][nx] = true;\n                } else {\n                    if (usedPQ[ny][nx]) continue;\n                    PQ.insert(P(ny, nx, F[ny][nx]));\n                    usedPQ[ny][nx] = true;\n                }\n            }\n        }\n    }\n    //foreach (ref _; F) _.writeln;\n    return L;\n}\n\nvoid main() {\n    int R;\n    while (readf(\"%d\\n\", &R), R) {\n        int[][] L = new int[][2];\n        foreach (i; 0 .. 2) {\n            L[i] = init;\n        }\n        int[] X = L[0].uniq.array;\n        int ans = int.max;\n        foreach (i; 0 .. 2) {\n            if (L[i].length < R) continue;\n            int lb = -1, ub = L[i].back + 1;\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (L[i].assumeSorted.lowerBound(mid + 1).length >= R) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            ans = min(ans, ub);\n        }\n        //writeln(\"ans \", ans);\n        foreach (x; X) {\n            int c = cast(int)L[0].assumeSorted.lowerBound(x + 1).length;\n            int r = R - c;\n            int lb = -1, ub = L[1].back + 1;\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (L[1].assumeSorted.lowerBound(mid + 1).length >= r) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            ans = min(ans, (x + ub));\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.range;\nimport std.container;\nimport std.algorithm;\nimport std.array;\nimport std.string;\nimport std.functional;\nimport std.conv;\nimport std.typecons;\n\nstruct P {\n    int y, x, level;\n    int opCmp(P o) {\n        return level - o.level;\n    }\n}\n\nint[] init() {\n    int W, H, X, Y; readf(\"%d %d %d %d\\n\", &W, &H, &X, &Y);\n    X--; Y--;\n    int[][] F = new int[][H];\n    foreach (i; 0 .. H) {\n        F[i] = readln.chomp.split(\" \").map!(to!int).array;\n    }\n    bool[][] used = new bool[][](H, W);\n    bool[][] usedPQ = new bool[][](H, W);\n    int[] L;\n    DList!P Q;\n    Q.insert(P(Y, X, F[Y][X])); used[Y][X] = true;\n    BinaryHeap!(Array!P, \"a >= b\") PQ;\n    static const dy = [0, 1, 0, -1],\n                 dx = [1, 0, -1, 0];\n    while (true) {\n        if (Q.empty) {\n            if (PQ.empty) break;\n            P next = PQ.front; PQ.removeFront;\n            Q.insert(next);\n            used[next.y][next.x] = true;\n        } else {\n            P cur = Q.front; Q.removeFront;\n            L ~= cur.level;\n            F[cur.y][cur.x] = cur.level;\n            foreach (i; 0 .. 4) {\n                int ny = cur.y + dy[i],\n                    nx = cur.x + dx[i];\n                if (ny < 0 || ny >= H) continue;\n                if (nx < 0 || nx >= W) continue;\n                if (used[ny][nx]) continue;\n                if (F[ny][nx] <= cur.level) {\n                    Q.insert(P(ny, nx, cur.level));\n                    used[ny][nx] = true;\n                } else {\n                    if (usedPQ[ny][nx]) continue;\n                    usedPQ[ny][nx] = true;\n                    PQ.insert(P(ny, nx, F[ny][nx]));\n                }\n            }\n        }\n    }\n    //foreach (ref _; F) _.writeln;\n    return L;\n}\n\nvoid main() {\n    int R;\n    while (readf(\"%d\\n\", &R), R) {\n        int[][] L = new int[][2];\n        foreach (i; 0 .. 2) {\n            L[i] = init;\n        }\n        int[] X = L[0].uniq.array;\n        int ans = int.max;\n        auto K = L.map!(a => a.assumeSorted);\n        foreach (i; 0 .. 2) {\n            if (L[i].length < R) continue;\n            int lb = -1, ub = L[i].back + 1;\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (K[i].lowerBound(mid + 1).length >= R) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            ans = min(ans, ub);\n        }\n        //writeln(\"ans \", ans);\n        foreach (x; X) {\n            int c = cast(int)K[0].lowerBound(x + 1).length;\n            int r = R - c;\n            int lb = -1, ub = L[1].back + 1;\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (K[1].lowerBound(mid + 1).length >= r) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            ans = min(ans, (x + ub));\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.range;\nimport std.container;\nimport std.algorithm;\nimport std.array;\nimport std.string;\nimport std.functional;\nimport std.conv;\nimport std.typecons;\n\nstruct P {\n    int y, x, level;\n    int opCmp(P o) {\n        return level - o.level;\n    }\n}\n\nint R;\n\nint[] init() {\n    int W, H, X, Y; readf(\"%d %d %d %d\\n\", &W, &H, &X, &Y);\n    X--; Y--;\n    int[][] F = new int[][H];\n    foreach (i; 0 .. H) {\n        F[i] = readln.chomp.split(\" \").map!(to!int).array;\n    }\n    bool[][] used = new bool[][](H, W);\n    bool[][] usedPQ = new bool[][](H, W);\n    int[] L;\n    DList!P Q;\n    Q.insert(P(Y, X, F[Y][X])); used[Y][X] = true;\n    BinaryHeap!(Array!P, \"a >= b\") PQ;\n    static const dy = [0, 1, 0, -1],\n                 dx = [1, 0, -1, 0];\n    while (true) {\n        if (Q.empty) {\n            if (PQ.empty) break;\n            P next = PQ.front; PQ.removeFront;\n            Q.insert(next);\n            used[next.y][next.x] = true;\n        } else {\n            P cur = Q.front; Q.removeFront;\n            L ~= cur.level;\n            if (L.length >= R) break;\n            F[cur.y][cur.x] = cur.level;\n            foreach (i; 0 .. 4) {\n                int ny = cur.y + dy[i],\n                    nx = cur.x + dx[i];\n                if (ny < 0 || ny >= H) continue;\n                if (nx < 0 || nx >= W) continue;\n                if (used[ny][nx]) continue;\n                if (F[ny][nx] <= cur.level) {\n                    Q.insert(P(ny, nx, cur.level));\n                    used[ny][nx] = true;\n                } else {\n                    if (usedPQ[ny][nx]) continue;\n                    usedPQ[ny][nx] = true;\n                    PQ.insert(P(ny, nx, F[ny][nx]));\n                }\n            }\n        }\n    }\n    //foreach (ref _; F) _.writeln;\n    return L;\n}\n\nint countUnder(int[] L, int k) {\n    int lb = 0, ub = cast(int)L.length;\n    if (L[lb] > k) return 0;\n    while (lb + 1 < ub) {\n        int mid = (lb + ub) / 2;\n        if (L[mid] <= k) {\n            lb = mid;\n        } else {\n            ub = mid;\n        }\n    }\n    //\"countUnder\".writeln([k, ub]);\n    return ub;\n}\n\nvoid main() {\n    while (readf(\"%d\\n\", &R), R) {\n        int[][] L = new int[][2];\n        foreach (i; 0 .. 2) {\n            L[i] = init;\n        }\n        auto X = [0] ~ L[0].uniq.array;\n        int ans = int.max;\n        foreach (x; X) {\n            int c = L[0].countUnder(x);\n            if (c >= R) {\n                ans = min(ans, x);\n                break;\n            }\n            int r = R - c;\n            if (r > L[1].length) continue;\n            int lb = 0, ub = cast(int)L[1].length - 1;\n            if (L[1].countUnder(L[1][lb]) >= r) {\n                int cand = x + L[1][lb];\n                ans = (ans < cand ? ans : cand);\n                continue;\n            }\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (L[1].countUnder(L[1][mid]) >= r) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            //[r, c, L[1][ub]].writeln;\n            int cand = x + L[1][ub];\n            ans = (ans < cand ? ans : cand);\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.range;\nimport std.container;\nimport std.algorithm;\nimport std.array;\nimport std.string;\nimport std.functional;\nimport std.conv;\nimport std.typecons;\n\nstruct P {\n    int y, x, level;\n    int opCmp(P o) {\n        return level - o.level;\n    }\n}\n\nint R;\n\nint[] init() {\n    int W, H, X, Y; readf(\"%d %d %d %d\\n\", &W, &H, &X, &Y);\n    X--; Y--;\n    int[][] F = new int[][H];\n    foreach (i; 0 .. H) {\n        F[i] = readln.chomp.split(\" \").map!(to!int).array;\n    }\n    bool[][] used = new bool[][](H, W);\n    bool[][] usedPQ = new bool[][](H, W);\n    int[] L;\n    DList!P Q;\n    Q.insert(P(Y, X, F[Y][X])); used[Y][X] = true;\n    BinaryHeap!(Array!P, \"a >= b\") PQ;\n    static const dy = [0, 1, 0, -1],\n                 dx = [1, 0, -1, 0];\n    while (true) {\n        if (Q.empty) {\n            if (PQ.empty) break;\n            P next = PQ.front; PQ.removeFront;\n            Q.insert(next);\n            used[next.y][next.x] = true;\n        } else {\n            P cur = Q.front; Q.removeFront;\n            L ~= cur.level;\n            if (L.length >= R) break;\n            F[cur.y][cur.x] = cur.level;\n            foreach (i; 0 .. 4) {\n                int ny = cur.y + dy[i],\n                    nx = cur.x + dx[i];\n                if (ny < 0 || ny >= H) continue;\n                if (nx < 0 || nx >= W) continue;\n                if (used[ny][nx]) continue;\n                if (F[ny][nx] <= cur.level) {\n                    Q.insert(P(ny, nx, cur.level));\n                    used[ny][nx] = true;\n                } else {\n                    if (usedPQ[ny][nx]) continue;\n                    usedPQ[ny][nx] = true;\n                    PQ.insert(P(ny, nx, F[ny][nx]));\n                }\n            }\n        }\n    }\n    //foreach (ref _; F) _.writeln;\n    return L;\n}\n\nint countUnder(int[] L, int k) {\n    int lb = 0, ub = cast(int)L.length;\n    while (lb + 1 < ub) {\n        int mid = (lb + ub) / 2;\n        if (L[mid] <= k) {\n            lb = mid;\n        } else {\n            ub = mid;\n        }\n    }\n    //\"countUnder\".writeln([k, ub]);\n    return ub;\n}\n\nvoid main() {\n    while (readf(\"%d\\n\", &R), R) {\n        int[][] L = new int[][2];\n        foreach (i; 0 .. 2) {\n            L[i] = init;\n        }\n        auto X = L[0].uniq;\n        int ans = int.max;\n        foreach (i; 0 .. 2) {\n            if (L[i].length < R) continue;\n            int lb = 0, ub = cast(int)L[i].length - 1;\n            if (L[i].countUnder(L[i][lb]) >= R) {\n                ans = (ans < L[i][lb] ? ans : L[i][lb]);\n                continue;\n            }\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (L[i].countUnder(L[i][mid]) >= R) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            ans = (ans < L[i][ub] ? ans : L[i][ub]);\n        }\n        //writeln(\"ans \", ans);\n        foreach (x; X) {\n            int c = L[0].countUnder(x);\n            int r = R - c;\n            if (r < 0) break;\n            if (r > L[1].length) continue;\n            int lb = 0, ub = cast(int)L[1].length - 1;\n            if (L[1].countUnder(L[1][lb]) >= r) {\n                int cand = x + L[1][lb];\n                ans = (ans < cand ? ans : cand);\n                continue;\n            }\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (L[1].countUnder(L[1][mid]) >= r) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            //[r, c, L[1][ub]].writeln;\n            int cand = x + L[1][ub];\n            ans = (ans < cand ? ans : cand);\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.range;\nimport std.container;\nimport std.algorithm;\nimport std.array;\nimport std.string;\nimport std.functional;\nimport std.conv;\nimport std.typecons;\n\nstruct P {\n    int y, x, level;\n    int opCmp(P o) {\n        return level - o.level;\n    }\n}\n\nint R;\n\nint[] init() {\n    int W, H, X, Y; readf(\"%d %d %d %d\\n\", &W, &H, &X, &Y);\n    X--; Y--;\n    int[][] F = new int[][H];\n    foreach (i; 0 .. H) {\n        F[i] = readln.chomp.split(\" \").map!(to!int).array;\n    }\n    bool[][] used = new bool[][](H, W);\n    bool[][] usedPQ = new bool[][](H, W);\n    int[] L;\n    DList!P Q;\n    Q.insert(P(Y, X, F[Y][X])); used[Y][X] = true;\n    BinaryHeap!(Array!P, \"a >= b\") PQ;\n    static const dy = [0, 1, 0, -1],\n                 dx = [1, 0, -1, 0];\n    while (true) {\n        if (Q.empty) {\n            if (PQ.empty) break;\n            P next = PQ.front; PQ.removeFront;\n            Q.insert(next);\n            used[next.y][next.x] = true;\n        } else {\n            P cur = Q.front; Q.removeFront;\n            L ~= cur.level;\n            if (L.length > R) break;\n            F[cur.y][cur.x] = cur.level;\n            foreach (i; 0 .. 4) {\n                int ny = cur.y + dy[i],\n                    nx = cur.x + dx[i];\n                if (ny < 0 || ny >= H) continue;\n                if (nx < 0 || nx >= W) continue;\n                if (used[ny][nx]) continue;\n                if (F[ny][nx] <= cur.level) {\n                    Q.insert(P(ny, nx, cur.level));\n                    used[ny][nx] = true;\n                } else {\n                    if (usedPQ[ny][nx]) continue;\n                    usedPQ[ny][nx] = true;\n                    PQ.insert(P(ny, nx, F[ny][nx]));\n                }\n            }\n        }\n    }\n    //foreach (ref _; F) _.writeln;\n    L.writeln;\n    return L;\n}\n\nint countUnder(int[] L, int k) {\n    int lb = 0, ub = cast(int)L.length;\n    while (lb + 1 < ub) {\n        int mid = (lb + ub) / 2;\n        if (L[mid] <= k) {\n            lb = mid;\n        } else {\n            ub = mid;\n        }\n    }\n    //\"countUnder\".writeln([k, ub]);\n    return ub;\n}\n\nvoid main() {\n    while (readf(\"%d\\n\", &R), R) {\n        int[][] L = new int[][2];\n        foreach (i; 0 .. 2) {\n            L[i] = init;\n        }\n        auto X = L[0].uniq;\n        int ans = int.max;\n        foreach (i; 0 .. 2) {\n            if (L[i].length < R) continue;\n            int lb = 0, ub = cast(int)L[i].length;\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (L[i].countUnder(L[i][mid]) >= R) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            ans = (ans < L[i][ub] ? ans : L[i][ub]);\n        }\n        //writeln(\"ans \", ans);\n        foreach (x; X) {\n            int c = L[0].countUnder(x);\n            int r = R - c;\n            if (r <= 0) break;\n            if (r > L[1].length) continue;\n            int lb = 0, ub = cast(int)L[1].length - 1;\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (L[1].countUnder(L[1][mid]) >= r) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            //[r, c, L[1][ub]].writeln;\n            int cand = x + L[1][ub];\n            ans = (ans < cand ? ans : cand);\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.range;\nimport std.container;\nimport std.algorithm;\nimport std.array;\nimport std.string;\nimport std.functional;\nimport std.conv;\nimport std.typecons;\n\nstruct P {\n    int y, x, level;\n    int opCmp(P o) {\n        return level - o.level;\n    }\n}\n\nint R;\n\nint[] init() {\n    int W, H, X, Y; readf(\"%d %d %d %d\\n\", &W, &H, &X, &Y);\n    X--; Y--;\n    int[][] F = new int[][H];\n    foreach (i; 0 .. H) {\n        F[i] = readln.chomp.split(\" \").map!(to!int).array;\n    }\n    bool[][] used = new bool[][](H, W);\n    bool[][] usedPQ = new bool[][](H, W);\n    int[] L;\n    DList!P Q;\n    Q.insert(P(Y, X, F[Y][X])); used[Y][X] = true;\n    BinaryHeap!(Array!P, \"a >= b\") PQ;\n    static const dy = [0, 1, 0, -1],\n                 dx = [1, 0, -1, 0];\n    while (true) {\n        if (Q.empty) {\n            if (PQ.empty) break;\n            P next = PQ.front; PQ.removeFront;\n            Q.insert(next);\n            used[next.y][next.x] = true;\n        } else {\n            P cur = Q.front; Q.removeFront;\n            L ~= cur.level;\n            if (L.length >= R) break;\n            F[cur.y][cur.x] = cur.level;\n            foreach (i; 0 .. 4) {\n                int ny = cur.y + dy[i],\n                    nx = cur.x + dx[i];\n                if (ny < 0 || ny >= H) continue;\n                if (nx < 0 || nx >= W) continue;\n                if (used[ny][nx]) continue;\n                if (F[ny][nx] <= cur.level) {\n                    Q.insert(P(ny, nx, cur.level));\n                    used[ny][nx] = true;\n                } else {\n                    if (usedPQ[ny][nx]) continue;\n                    usedPQ[ny][nx] = true;\n                    PQ.insert(P(ny, nx, F[ny][nx]));\n                }\n            }\n        }\n    }\n    //foreach (ref _; F) _.writeln;\n    return L;\n}\n\nint countUnder(int[] L, int k) {\n    int lb = 0, ub = cast(int)L.length;\n    while (lb + 1 < ub) {\n        int mid = (lb + ub) / 2;\n        if (L[mid] <= k) {\n            lb = mid;\n        } else {\n            ub = mid;\n        }\n    }\n    //\"countUnder\".writeln([k, ub]);\n    return ub;\n}\n\nvoid main() {\n    while (readf(\"%d\\n\", &R), R) {\n        int[][] L = new int[][2];\n        foreach (i; 0 .. 2) {\n            L[i] = init;\n        }\n        auto X = L[0].uniq;\n        int ans = int.max;\n        foreach (i; 0 .. 2) {\n            if (L[i].length < R) continue;\n            int lb = 0, ub = cast(int)L[i].length;\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (L[i].countUnder(L[i][mid]) >= R) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            ans = (ans < L[i][ub] ? ans : L[i][ub]);\n        }\n        //writeln(\"ans \", ans);\n        foreach (x; X) {\n            int c = L[0].countUnder(x);\n            int r = R - c;\n            if (r <= 0) break;\n            if (r > L[1].length) continue;\n            int lb = 0, ub = cast(int)L[1].length - 1;\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (L[1].countUnder(L[1][mid]) >= r) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            //[r, c, L[1][ub]].writeln;\n            int cand = x + L[1][ub];\n            ans = (ans < cand ? ans : cand);\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.range;\nimport std.container;\nimport std.algorithm;\nimport std.array;\nimport std.string;\nimport std.functional;\nimport std.conv;\nimport std.typecons;\n\nstruct P {\n    int y, x, level;\n    int opCmp(P o) {\n        return level - o.level;\n    }\n}\n\nint R;\n\nint[] init() {\n    int W, H, X, Y; readf(\"%d %d %d %d\\n\", &W, &H, &X, &Y);\n    X--; Y--;\n    int[][] F = new int[][H];\n    foreach (i; 0 .. H) {\n        F[i] = readln.chomp.split(\" \").map!(to!int).array;\n    }\n    bool[][] used = new bool[][](H, W);\n    bool[][] usedPQ = new bool[][](H, W);\n    int[] L;\n    DList!P Q;\n    Q.insert(P(Y, X, F[Y][X])); used[Y][X] = true;\n    BinaryHeap!(Array!P, \"a >= b\") PQ;\n    static const dy = [0, 1, 0, -1],\n                 dx = [1, 0, -1, 0];\n    while (true) {\n        if (Q.empty) {\n            if (PQ.empty) break;\n            P next = PQ.front; PQ.removeFront;\n            Q.insert(next);\n            used[next.y][next.x] = true;\n        } else {\n            P cur = Q.front; Q.removeFront;\n            L ~= cur.level;\n            if (L.length > R) break;\n            F[cur.y][cur.x] = cur.level;\n            foreach (i; 0 .. 4) {\n                int ny = cur.y + dy[i],\n                    nx = cur.x + dx[i];\n                if (ny < 0 || ny >= H) continue;\n                if (nx < 0 || nx >= W) continue;\n                if (used[ny][nx]) continue;\n                if (F[ny][nx] <= cur.level) {\n                    Q.insert(P(ny, nx, cur.level));\n                    used[ny][nx] = true;\n                } else {\n                    if (usedPQ[ny][nx]) continue;\n                    usedPQ[ny][nx] = true;\n                    PQ.insert(P(ny, nx, F[ny][nx]));\n                }\n            }\n        }\n    }\n    //foreach (ref _; F) _.writeln;\n    return L;\n}\n\nint countUnder(int[] L, int k) {\n    int lb = 0, ub = cast(int)L.length;\n    while (lb + 1 < ub) {\n        int mid = (lb + ub) / 2;\n        if (L[mid] <= k) {\n            lb = mid;\n        } else {\n            ub = mid;\n        }\n    }\n    //\"countUnder\".writeln([k, ub]);\n    return ub;\n}\n\nvoid main() {\n    while (readf(\"%d\\n\", &R), R) {\n        int[][] L = new int[][2];\n        foreach (i; 0 .. 2) {\n            L[i] = init;\n        }\n        auto X = L[0].uniq;\n        int ans = int.max;\n        foreach (i; 0 .. 2) {\n            if (L[i].length < R) continue;\n            int lb = 0, ub = cast(int)L[i].length;\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (L[i].countUnder(L[i][mid]) >= R) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            ans = (ans < L[i][ub] ? ans : L[i][ub]);\n        }\n        //writeln(\"ans \", ans);\n        foreach (x; X) {\n            int c = L[0].countUnder(x);\n            int r = R - c;\n            if (r <= 0) break;\n            if (r > L[1].length) continue;\n            int lb = 0, ub = cast(int)L[1].length - 1;\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (L[1].countUnder(L[1][mid]) >= r) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            //[r, c, L[1][ub]].writeln;\n            int cand = x + L[1][ub];\n            ans = (ans < cand ? ans : cand);\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.range;\nimport std.container;\nimport std.algorithm;\nimport std.array;\nimport std.string;\nimport std.functional;\nimport std.conv;\nimport std.typecons;\n\nstruct P {\n    int y, x, level;\n    int opCmp(P o) {\n        return level - o.level;\n    }\n}\n\nint[] init() {\n    int W, H, X, Y; readf(\"%d %d %d %d\\n\", &W, &H, &X, &Y);\n    X--; Y--;\n    int[][] F = new int[][H];\n    foreach (i; 0 .. H) {\n        F[i] = readln.chomp.split(\" \").map!(to!int).array;\n    }\n    bool[][] used = new bool[][](H, W);\n    bool[][] usedPQ = new bool[][](H, W);\n    int[] L;\n    DList!P Q;\n    Q.insert(P(Y, X, F[Y][X])); used[Y][X] = true;\n    BinaryHeap!(Array!P, \"a >= b\") PQ;\n    static const dy = [0, 1, 0, -1],\n                 dx = [1, 0, -1, 0];\n    while (true) {\n        if (Q.empty) {\n            if (PQ.empty) break;\n            P next = PQ.front; PQ.removeFront;\n            Q.insert(next);\n            used[next.y][next.x] = true;\n        } else {\n            P cur = Q.front; Q.removeFront;\n            //L ~= cur.level;\n            F[cur.y][cur.x] = cur.level;\n            foreach (i; 0 .. 4) {\n                int ny = cur.y + dy[i],\n                    nx = cur.x + dx[i];\n                if (ny < 0 || ny >= H) continue;\n                if (nx < 0 || nx >= W) continue;\n                if (used[ny][nx]) continue;\n                if (F[ny][nx] <= cur.level) {\n                    Q.insert(P(ny, nx, cur.level));\n                    used[ny][nx] = true;\n                } else {\n                    if (usedPQ[ny][nx]) continue;\n                    usedPQ[ny][nx] = true;\n                    PQ.insert(P(ny, nx, F[ny][nx]));\n                }\n            }\n        }\n    }\n    foreach (_; F) {\n        L ~= _;\n    }\n    //foreach (ref _; F) _.writeln;\n    return L.sort.array;\n}\n\nint countUnder(int[] L, int k) {\n    int lb = 0, ub = cast(int)L.length;\n    while (lb + 1 < ub) {\n        int mid = (lb + ub) / 2;\n        if (L[mid] <= k) {\n            lb = mid;\n        } else {\n            ub = mid;\n        }\n    }\n    //\"countUnder\".writeln([k, ub]);\n    return ub;\n}\n\nvoid main() {\n    int R;\n    while (readf(\"%d\\n\", &R), R) {\n        int[][] L = new int[][2];\n        foreach (i; 0 .. 2) {\n            L[i] = init;\n        }\n        auto X = L[0].uniq;\n        int ans = int.max;\n        foreach (i; 0 .. 2) {\n            if (L[i].length < R) continue;\n            int lb = 0, ub = cast(int)L[i].length;\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (L[i].countUnder(L[i][mid]) >= R) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            ans = (ans < L[i][ub] ? ans : L[i][ub]);\n        }\n        //writeln(\"ans \", ans);\n        foreach (x; X) {\n            int c = L[0].countUnder(x);\n            int r = R - c;\n            if (r <= 0) break;\n            if (r > L[1].length) continue;\n            int lb = 0, ub = cast(int)L[1].length - 1;\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (L[1].countUnder(L[1][mid]) >= r) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            //[r, c, L[1][ub]].writeln;\n            int cand = x + L[1][ub];\n            ans = (ans < cand ? ans : cand);\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.range;\nimport std.container;\nimport std.algorithm;\nimport std.array;\nimport std.string;\nimport std.functional;\nimport std.conv;\nimport std.typecons;\n\nstruct P {\n    int y, x, level;\n    int opCmp(P o) {\n        return level - o.level;\n    }\n}\n\nint[] init() {\n    int W, H, X, Y; readf(\"%d %d %d %d\\n\", &W, &H, &X, &Y);\n    X--; Y--;\n    int[][] F = new int[][H];\n    foreach (i; 0 .. H) {\n        F[i] = readln.chomp.split(\" \").map!(to!int).array;\n    }\n    bool[][] used = new bool[][](H, W);\n    bool[][] usedPQ = new bool[][](H, W);\n    int[] L;\n    DList!P Q;\n    Q.insert(P(Y, X, F[Y][X])); used[Y][X] = true;\n    BinaryHeap!(Array!P, \"a >= b\") PQ;\n    static const dy = [0, 1, 0, -1],\n                 dx = [1, 0, -1, 0];\n    while (true) {\n        if (Q.empty) {\n            if (PQ.empty) break;\n            P next = PQ.front; PQ.removeFront;\n            Q.insert(next);\n            used[next.y][next.x] = true;\n        } else {\n            P cur = Q.front; Q.removeFront;\n            L ~= cur.level;\n            F[cur.y][cur.x] = cur.level;\n            foreach (i; 0 .. 4) {\n                int ny = cur.y + dy[i],\n                    nx = cur.x + dx[i];\n                if (ny < 0 || ny >= H) continue;\n                if (nx < 0 || nx >= W) continue;\n                if (used[ny][nx]) continue;\n                if (F[ny][nx] <= cur.level) {\n                    Q.insert(P(ny, nx, cur.level));\n                    used[ny][nx] = true;\n                } else {\n                    if (usedPQ[ny][nx]) continue;\n                    usedPQ[ny][nx] = true;\n                    PQ.insert(P(ny, nx, F[ny][nx]));\n                }\n            }\n        }\n    }\n    //foreach (ref _; F) _.writeln;\n    return L;\n}\n\nvoid main() {\n    int R;\n    while (readf(\"%d\\n\", &R), R) {\n        int[][] L = new int[][2];\n        foreach (i; 0 .. 2) {\n            L[i] = init;\n        }\n        int[] X = L[0].uniq.array;\n        int ans = int.max;\n        foreach (i; 0 .. 2) {\n            if (L[i].length < R) continue;\n            int lb = -1, ub = L[i].back + 1;\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (L[i].assumeSorted.lowerBound(mid + 1).length >= R) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            ans = min(ans, ub);\n        }\n        //writeln(\"ans \", ans);\n        foreach (x; X) {\n            int c = cast(int)L[0].assumeSorted.lowerBound(x + 1).length;\n            int r = R - c;\n            int lb = -1, ub = L[1].back + 1;\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (L[1].assumeSorted.lowerBound(mid + 1).length >= r) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            ans = min(ans, (x + ub));\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.range;\nimport std.container;\nimport std.algorithm;\nimport std.array;\nimport std.string;\nimport std.functional;\nimport std.conv;\nimport std.typecons;\n\nstruct P {\n    int y, x, level;\n    int opCmp(P o) {\n        return level - o.level;\n    }\n}\n\nint[] init() {\n    int W, H, X, Y; readf(\"%d %d %d %d\\n\", &W, &H, &X, &Y);\n    X--; Y--;\n    int[][] F = new int[][H];\n    foreach (i; 0 .. H) {\n        F[i] = readln.chomp.split(\" \").map!(to!int).array;\n    }\n    bool[][] used = new bool[][](H, W);\n    bool[][] usedPQ = new bool[][](H, W);\n    int[] L;\n    DList!P Q;\n    Q.insert(P(Y, X, F[Y][X])); used[Y][X] = true;\n    BinaryHeap!(Array!P, \"a >= b\") PQ;\n    static const dy = [0, 1, 0, -1],\n                 dx = [1, 0, -1, 0];\n    while (true) {\n        if (Q.empty) {\n            if (PQ.empty) break;\n            P next = PQ.front; PQ.removeFront;\n            Q.insert(next);\n            used[next.y][next.x] = true;\n        } else {\n            P cur = Q.front; Q.removeFront;\n            L ~= cur.level;\n            //F[cur.y][cur.x] = cur.level;\n            foreach (i; 0 .. 4) {\n                int ny = cur.y + dy[i],\n                    nx = cur.x + dx[i];\n                if (ny < 0 || ny >= H) continue;\n                if (nx < 0 || nx >= W) continue;\n                if (used[ny][nx]) continue;\n                if (F[ny][nx] <= cur.level) {\n                    Q.insert(P(ny, nx, cur.level));\n                    used[ny][nx] = true;\n                } else {\n                    if (usedPQ[ny][nx]) continue;\n                    usedPQ[ny][nx] = true;\n                    PQ.insert(P(ny, nx, F[ny][nx]));\n                }\n            }\n        }\n    }\n    //foreach (ref _; F) _.writeln;\n    return L;\n}\n\nint countUnder(int[] L, int k) {\n    int lb = 0, ub = cast(int)L.length;\n    while (lb + 1 < ub) {\n        int mid = (lb + ub) / 2;\n        if (L[mid] <= k) {\n            lb = mid;\n        } else {\n            ub = mid;\n        }\n    }\n    return ub;\n}\n\nvoid main() {\n    int R;\n    while (readf(\"%d\\n\", &R), R) {\n        int[][] L = new int[][2];\n        foreach (i; 0 .. 2) {\n            L[i] = init;\n        }\n        auto X = L[0].uniq;\n        int ans = int.max;\n        foreach (i; 0 .. 2) {\n            if (L[i].length < R) continue;\n            int lb = 1, ub = L[i].back + 1;\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (L[i].countUnder(mid) >= R) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            ans = (ans < ub ? ans : ub);\n        }\n        //writeln(\"ans \", ans);\n        foreach (x; X) {\n            int c = L[0].countUnder(x);\n            int r = R - c;\n            if (r <= 0) break;\n            int lb = 0, ub = L[1].back + 1;\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (L[1].countUnder(mid) >= r) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            int cand = x + ub;\n            ans = (ans < cand ? ans : cand);\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.range;\nimport std.container;\nimport std.algorithm;\nimport std.array;\nimport std.string;\nimport std.functional;\nimport std.conv;\nimport std.typecons;\n\nstruct P {\n    int y, x, level;\n    int opCmp(P o) {\n        return level - o.level;\n    }\n}\n\nint R;\n\nint[] init() {\n    int W, H, X, Y; readf(\"%d %d %d %d\\n\", &W, &H, &X, &Y);\n    X--; Y--;\n    int[][] F = new int[][H];\n    foreach (i; 0 .. H) {\n        F[i] = readln.chomp.split(\" \").map!(to!int).array;\n    }\n    bool[][] used = new bool[][](H, W);\n    bool[][] usedPQ = new bool[][](H, W);\n    int[] L;\n    DList!P Q;\n    Q.insert(P(Y, X, F[Y][X])); used[Y][X] = true;\n    BinaryHeap!(Array!P, \"a >= b\") PQ;\n    static const dy = [0, 1, 0, -1],\n                 dx = [1, 0, -1, 0];\n    while (true) {\n        if (Q.empty) {\n            if (PQ.empty) break;\n            P next = PQ.front; PQ.removeFront;\n            Q.insert(next);\n            used[next.y][next.x] = true;\n        } else {\n            P cur = Q.front; Q.removeFront;\n            L ~= cur.level;\n            if (L.length >= R) break;\n            F[cur.y][cur.x] = cur.level;\n            foreach (i; 0 .. 4) {\n                int ny = cur.y + dy[i],\n                    nx = cur.x + dx[i];\n                if (ny < 0 || ny >= H) continue;\n                if (nx < 0 || nx >= W) continue;\n                if (used[ny][nx]) continue;\n                if (F[ny][nx] <= cur.level) {\n                    Q.insert(P(ny, nx, cur.level));\n                    used[ny][nx] = true;\n                } else {\n                    if (usedPQ[ny][nx]) continue;\n                    usedPQ[ny][nx] = true;\n                    PQ.insert(P(ny, nx, F[ny][nx]));\n                }\n            }\n        }\n    }\n    //foreach (ref _; F) _.writeln;\n    return L;\n}\n\nint countUnder(int[] L, int k) {\n    int lb = 0, ub = cast(int)L.length;\n    if (L[lb] > k) return 0;\n    while (lb + 1 < ub) {\n        int mid = (lb + ub) / 2;\n        if (L[mid] <= k) {\n            lb = mid;\n        } else {\n            ub = mid;\n        }\n    }\n    //\"countUnder\".writeln([k, ub]);\n    return ub;\n}\n\nvoid main() {\n    while (readf(\"%d\\n\", &R), R) {\n        int[][] L = new int[][2];\n        foreach (i; 0 .. 2) {\n            L[i] = init;\n        }\n        auto X = [0] ~ L[0].uniq.array;\n        int ans = int.max;\n        foreach (i; 0 .. 2) {\n            if (L[i].length < R) continue;\n            int lb = 0, ub = cast(int)L[i].length - 1;\n            if (L[i].countUnder(L[i][lb]) >= R) {\n                ans = (ans < L[i][lb] ? ans : L[i][lb]);\n                continue;\n            }\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (L[i].countUnder(L[i][mid]) >= R) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            ans = (ans < L[i][ub] ? ans : L[i][ub]);\n        }\n        //writeln(\"ans \", ans);\n        foreach (x; X) {\n            int c = L[0].countUnder(x);\n            int r = R - c;\n            if (r < 0) break;\n            if (r > L[1].length) continue;\n            int lb = 0, ub = cast(int)L[1].length - 1;\n            if (L[1].countUnder(L[1][lb]) >= r) {\n                int cand = x + L[1][lb];\n                ans = (ans < cand ? ans : cand);\n                continue;\n            }\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (L[1].countUnder(L[1][mid]) >= r) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            //[r, c, L[1][ub]].writeln;\n            int cand = x + L[1][ub];\n            ans = (ans < cand ? ans : cand);\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.range;\nimport std.container;\nimport std.algorithm;\nimport std.array;\nimport std.string;\nimport std.functional;\nimport std.conv;\nimport std.typecons;\n\nstruct P {\n    int y, x, level;\n    int opCmp(P o) {\n        return level - o.level;\n    }\n}\n\nint[] init() {\n    int W, H, X, Y; readf(\"%d %d %d %d\\n\", &W, &H, &X, &Y);\n    X--; Y--;\n    int[][] F = new int[][H];\n    foreach (i; 0 .. H) {\n        F[i] = readln.chomp.split(\" \").map!(to!int).array;\n    }\n    bool[][] used = new bool[][](H, W);\n    bool[][] usedPQ = new bool[][](H, W);\n    int[] L;\n    DList!P Q;\n    Q.insert(P(Y, X, F[Y][X])); used[Y][X] = true;\n    BinaryHeap!(Array!P, \"a >= b\") PQ;\n    static const dy = [0, 1, 0, -1],\n                 dx = [1, 0, -1, 0];\n    while (true) {\n        if (Q.empty) {\n            if (PQ.empty) break;\n            P next = PQ.front; PQ.removeFront;\n            Q.insert(next);\n            used[next.y][next.x] = true;\n        } else {\n            P cur = Q.front; Q.removeFront;\n            L ~= cur.level;\n            //F[cur.y][cur.x] = cur.level;\n            foreach (i; 0 .. 4) {\n                int ny = cur.y + dy[i],\n                    nx = cur.x + dx[i];\n                if (ny < 0 || ny >= H) continue;\n                if (nx < 0 || nx >= W) continue;\n                if (used[ny][nx]) continue;\n                if (F[ny][nx] <= cur.level) {\n                    Q.insert(P(ny, nx, cur.level));\n                    used[ny][nx] = true;\n                } else {\n                    if (usedPQ[ny][nx]) continue;\n                    usedPQ[ny][nx] = true;\n                    PQ.insert(P(ny, nx, F[ny][nx]));\n                }\n            }\n        }\n    }\n    //foreach (ref _; F) _.writeln;\n    return L;\n}\n\nint countUnder(int[] L, int k) {\n    int lb = 0, ub = cast(int)L.length;\n    while (lb + 1 < ub) {\n        int mid = (lb + ub) / 2;\n        if (L[mid] <= k) {\n            lb = mid;\n        } else {\n            ub = mid;\n        }\n    }\n    return ub;\n}\n\nvoid main() {\n    int R;\n    while (readf(\"%d\\n\", &R), R) {\n        int[][] L = new int[][2];\n        foreach (i; 0 .. 2) {\n            L[i] = init;\n        }\n        int[] X = L[0].uniq.array;\n        int ans = int.max;\n        foreach (i; 0 .. 2) {\n            if (L[i].length < R) continue;\n            int lb = -1, ub = L[i].back + 1;\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (L[i].countUnder(mid) >= R) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            ans = min(ans, ub);\n        }\n        //writeln(\"ans \", ans);\n        foreach (x; X) {\n            int c = cast(int)L[0].countUnder(x);\n            int r = R - c;\n            int lb = -1, ub = L[1].back + 1;\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (L[1].countUnder(mid) >= r) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            ans = min(ans, (x + ub));\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.range;\nimport std.container;\nimport std.algorithm;\nimport std.array;\nimport std.string;\nimport std.functional;\nimport std.conv;\nimport std.typecons;\n\nstruct P {\n    int y, x, level;\n    int opCmp(P o) {\n        return level - o.level;\n    }\n}\n\nint R;\n\nint[] init() {\n    int W, H, X, Y; readf(\"%d %d %d %d\\n\", &W, &H, &X, &Y);\n    X--; Y--;\n    int[][] F = new int[][H];\n    foreach (i; 0 .. H) {\n        F[i] = readln.chomp.split(\" \").map!(to!int).array;\n    }\n    bool[][] used = new bool[][](H, W);\n    bool[][] usedPQ = new bool[][](H, W);\n    int[] L;\n    DList!P Q;\n    Q.insert(P(Y, X, F[Y][X])); used[Y][X] = true;\n    BinaryHeap!(Array!P, \"a >= b\") PQ;\n    static const dy = [0, 1, 0, -1],\n                 dx = [1, 0, -1, 0];\n    while (true) {\n        if (Q.empty) {\n            if (PQ.empty) break;\n            P next = PQ.front; PQ.removeFront;\n            Q.insert(next);\n            used[next.y][next.x] = true;\n        } else {\n            P cur = Q.front; Q.removeFront;\n            L ~= cur.level;\n            if (L.length >= R) break;\n            F[cur.y][cur.x] = cur.level;\n            foreach (i; 0 .. 4) {\n                int ny = cur.y + dy[i],\n                    nx = cur.x + dx[i];\n                if (ny < 0 || ny >= H) continue;\n                if (nx < 0 || nx >= W) continue;\n                if (used[ny][nx]) continue;\n                if (F[ny][nx] <= cur.level) {\n                    Q.insert(P(ny, nx, cur.level));\n                    used[ny][nx] = true;\n                } else {\n                    if (usedPQ[ny][nx]) continue;\n                    usedPQ[ny][nx] = true;\n                    PQ.insert(P(ny, nx, F[ny][nx]));\n                }\n            }\n        }\n    }\n    //foreach (ref _; F) _.writeln;\n    return L;\n}\n\nint countUnder(int[] L, int k) {\n    int lb = 0, ub = cast(int)L.length;\n    if (L[lb] > k) return 0;\n    while (lb + 1 < ub) {\n        int mid = (lb + ub) / 2;\n        if (L[mid] <= k) {\n            lb = mid;\n        } else {\n            ub = mid;\n        }\n    }\n    //\"countUnder\".writeln([k, ub]);\n    return ub;\n}\n\nvoid main() {\n    while (readf(\"%d\\n\", &R), R) {\n        int[][] L = new int[][2];\n        foreach (i; 0 .. 2) {\n            L[i] = init;\n        }\n        auto X = L[0].uniq;\n        int ans = int.max;\n        foreach (i; 0 .. 2) {\n            if (L[i].length < R) continue;\n            int lb = 0, ub = cast(int)L[i].length - 1;\n            if (L[i].countUnder(L[i][lb]) >= R) {\n                ans = (ans < L[i][lb] ? ans : L[i][lb]);\n                continue;\n            }\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (L[i].countUnder(L[i][mid]) >= R) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            ans = (ans < L[i][ub] ? ans : L[i][ub]);\n        }\n        //writeln(\"ans \", ans);\n        foreach (x; X) {\n            int c = L[0].countUnder(x);\n            int r = R - c;\n            if (r < 0) break;\n            if (r > L[1].length) continue;\n            int lb = 0, ub = cast(int)L[1].length - 1;\n            if (L[1].countUnder(L[1][lb]) >= r) {\n                int cand = x + L[1][lb];\n                ans = (ans < cand ? ans : cand);\n                continue;\n            }\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (L[1].countUnder(L[1][mid]) >= r) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            //[r, c, L[1][ub]].writeln;\n            int cand = x + L[1][ub];\n            ans = (ans < cand ? ans : cand);\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import core.stdc.stdio;\nimport std.stdio;\nimport std.container;\nimport std.typecons;\nimport std.algorithm;\n\nint[] CalcTable(int[] dst){\n\tint w,h,x,y;\n\tscanf(\"%d%d%d%d\",&w,&h,&x,&y);\n\tstatic int[][] map = new int[][](500,500);\n\tforeach(i;0..h)\n\t\tforeach(j;0..w)\n\t\t\tscanf(\"%d\",&map[i][j]);\n\tint[] ret = dst[0..h*w+1];\n\tret[0]=0;\n\talias Tuple!(int,\"cost\",int,\"x\",int,\"y\") cxy;\n\tstatic cxy[] pqbuf = new cxy[250000];\n\tauto pq = BinaryHeap!(cxy[],\"a>b\")(pqbuf,0);\n\tstatic bool[][] used = new bool[][](500,500);\n\tforeach(i;0..h)\n\t\tforeach(j;0..w)\n\t\t\tused[i][j]=false;\n\tpq.insert(cxy(1,--x,--y));\n\tused[y][x]=true;\n\tint c;\n\tstatic immutable int[] dxy = [0,-1,0,1,0];\n\tint b=0;\n\twhile(!pq.empty){\n\t\tauto t=pq.front;\n\t\tpq.removeFront;\n\t\tb=max(b,t.cost);\n\t\tret[++c]=b;\n\t\tforeach(i;0..4){\n\t\t\tint nx=t.x+dxy[i];\n\t\t\tint ny=t.y+dxy[i+1];\n\t\t\tif(0<=nx&&nx<w&&0<=ny&&ny<h)\n\t\t\t\tif(!used[ny][nx]){\n\t\t\t\t\tpq.insert(cxy(map[ny][nx],nx,ny));\n\t\t\t\t\tused[ny][nx]=true;\n\t\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\t\nvoid main(){\n\twhile(1){\n\t\tint r;\n\t\tscanf(\"%d\",&r);\n\t\tif(r==0)\n\t\t\tbreak;\n\t\tstatic int[] buf1 = new int[250001];\n\t\tstatic int[] buf2 = new int[250001];\n\t\tint[] r1 = CalcTable(buf1);\n\t\tint[] r2 = CalcTable(buf2);\n\t\tint ans=1145141919;\n\t\tforeach(int i,p;r1){\n\t\t\tint j=r-i;\n\t\t\tif(j<r2.length)\n\t\t\t\tans = min(ans,p+r2[j]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import core.stdc.stdio;\nimport std.stdio;\nimport std.container;\nimport std.typecons;\nimport std.algorithm;\n\nint[] CalcTable(){\n\tint w,h,x,y;\n\tscanf(\"%d%d%d%d\",&w,&h,&x,&y);\n\tint[][] map = new int[][](h,w);\n\tforeach(i;0..h)\n\t\tforeach(j;0..w)\n\t\t\tscanf(\"%d\",&map[i][j]);\n\tint[] ret = new int[h*w+1];\n\tret[0]=0;\n\talias Tuple!(int,\"cost\",int,\"x\",int,\"y\") cxy;\n\tauto pq = BinaryHeap!(cxy[],\"a>b\")(new cxy[w*h],0);\n\tbool[][] used = new bool[][](h,w);\n\tpq.insert(cxy(1,--x,--y));\n\tused[y][x]=true;\n\tint c;\n\tstatic immutable int[] dxy = [0,-1,0,1,0];\n\tint b=0;\n\twhile(!pq.empty){\n\t\tauto t=pq.front;\n\t\tpq.removeFront;\n\t\tb=max(b,t.cost);\n\t\tret[++c]=b;\n\t\tforeach(i;0..4){\n\t\t\tint nx=t.x+dxy[i];\n\t\t\tint ny=t.y+dxy[i+1];\n\t\t\tif(0<=nx&&nx<w&&0<=ny&&ny<h)\n\t\t\t\tif(!used[ny][nx]){\n\t\t\t\t\tpq.insert(cxy(map[ny][nx],nx,ny));\n\t\t\t\t\tused[ny][nx]=true;\n\t\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\t\nvoid main(){\n\twhile(1){\n\t\tint r;\n\t\tscanf(\"%d\",&r);\n\t\tif(r==0)\n\t\t\tbreak;\n\t\tint[] r1 = CalcTable;\n\t\tint[] r2 = CalcTable;\n\t\tint ans=1145141919;\n\t\tforeach(int i,p;r1){\n\t\t\tint j=r-i;\n\t\t\tif(j<r2.length)\n\t\t\t\tans = min(ans,p+r2[j]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.range;\nimport std.container;\nimport std.algorithm;\nimport std.array;\nimport std.string;\nimport std.functional;\nimport std.conv;\nimport std.typecons;\n\nstruct P {\n    int y, x, level;\n    int opCmp(P o) {\n        return level - o.level;\n    }\n}\n\nint[] init() {\n    int W, H, X, Y; readf(\"%d %d %d %d\\n\", &W, &H, &X, &Y);\n    X--; Y--;\n    int[][] F = new int[][H];\n    foreach (i; 0 .. H) {\n        F[i] = readln.chomp.split(\" \").map!(to!int).array;\n    }\n    bool[][] used = new bool[][](H, W);\n    int[] L;\n    BinaryHeap!(Array!P, \"a >= b\") PQ;\n    PQ.insert(P(Y, X, F[Y][X])); used[Y][X] = true;\n    static const dy = [0, 1, 0, -1],\n                 dx = [1, 0, -1, 0];\n    while (!PQ.empty) {\n        P cur = PQ.front; PQ.removeFront;\n        F[cur.y][cur.x] = cur.level;\n        foreach (i; 0 .. 4) {\n            int ny = cur.y + dy[i],\n                nx = cur.x + dx[i];\n            if (ny < 0 || ny >= H) continue;\n            if (nx < 0 || nx >= W) continue;\n            if (used[ny][nx]) continue;\n            PQ.insert(P(ny, nx, max(F[ny][nx], cur.level)));\n            used[ny][nx] = true;\n        }\n    }\n    foreach (_; F) {\n        L ~= _;\n    }\n    //foreach (ref _; F) _.writeln;\n    return L.sort.array;\n}\n\nint countUnder(int[] L, int k) {\n    int lb = 0, ub = cast(int)L.length;\n    while (lb + 1 < ub) {\n        int mid = (lb + ub) / 2;\n        if (L[mid] <= k) {\n            lb = mid;\n        } else {\n            ub = mid;\n        }\n    }\n    //\"countUnder\".writeln([k, ub]);\n    return ub;\n}\n\nvoid main() {\n    int R;\n    while (readf(\"%d\\n\", &R), R) {\n        int[][] L = new int[][2];\n        foreach (i; 0 .. 2) {\n            L[i] = init;\n        }\n        auto X = L[0].uniq;\n        int ans = int.max;\n        foreach (i; 0 .. 2) {\n            if (L[i].length < R) continue;\n            int lb = 0, ub = cast(int)L[i].length;\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (L[i].countUnder(L[i][mid]) >= R) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            ans = (ans < L[i][ub] ? ans : L[i][ub]);\n        }\n        //writeln(\"ans \", ans);\n        foreach (x; X) {\n            int c = L[0].countUnder(x);\n            int r = R - c;\n            if (r <= 0) break;\n            if (r > L[1].length) continue;\n            int lb = 0, ub = cast(int)L[1].length - 1;\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (L[1].countUnder(L[1][mid]) >= r) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            //[r, c, L[1][ub]].writeln;\n            int cand = x + L[1][ub];\n            ans = (ans < cand ? ans : cand);\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.range;\nimport std.container;\nimport std.algorithm;\nimport std.array;\nimport std.string;\nimport std.functional;\nimport std.conv;\nimport std.typecons;\n\nstruct P {\n    int y, x, level;\n    int opCmp(P o) {\n        return level - o.level;\n    }\n}\n\nint[] init() {\n    int W, H, X, Y; readf(\"%d %d %d %d\\n\", &W, &H, &X, &Y);\n    X--; Y--;\n    int[][] F = new int[][H];\n    foreach (i; 0 .. H) {\n        F[i] = readln.chomp.split(\" \").map!(to!int).array;\n    }\n    bool[][] used = new bool[][](H, W);\n    bool[][] usedPQ = new bool[][](H, W);\n    int[] L;\n    DList!P Q;\n    Q.insert(P(Y, X, F[Y][X])); used[Y][X] = true;\n    BinaryHeap!(Array!P, \"a >= b\") PQ;\n    static const dy = [0, 1, 0, -1],\n                 dx = [1, 0, -1, 0];\n    while (true) {\n        if (Q.empty) {\n            if (PQ.empty) break;\n            P next = PQ.front; PQ.removeFront;\n            Q.insert(next);\n            used[next.y][next.x] = true;\n        } else {\n            P cur = Q.front; Q.removeFront;\n            //L ~= cur.level;\n            F[cur.y][cur.x] = cur.level;\n            foreach (i; 0 .. 4) {\n                int ny = cur.y + dy[i],\n                    nx = cur.x + dx[i];\n                if (ny < 0 || ny >= H) continue;\n                if (nx < 0 || nx >= W) continue;\n                if (used[ny][nx]) continue;\n                if (F[ny][nx] <= cur.level) {\n                    Q.insert(P(ny, nx, cur.level));\n                    used[ny][nx] = true;\n                } else {\n                    if (usedPQ[ny][nx]) continue;\n                    usedPQ[ny][nx] = true;\n                    PQ.insert(P(ny, nx, F[ny][nx]));\n                }\n            }\n        }\n    }\n    //foreach (ref _; F) _.writeln;\n    foreach (i; 0 .. H) {\n        L ~= F[i];\n    }\n    return L.sort.array;\n}\n\nint countUnder(int[] L, int k) {\n    int lb = 0, ub = cast(int)L.length;\n    while (lb + 1 < ub) {\n        int mid = (lb + ub) / 2;\n        if (L[mid] <= k) {\n            lb = mid;\n        } else {\n            ub = mid;\n        }\n    }\n    return ub;\n}\n\nvoid main() {\n    int R;\n    while (readf(\"%d\\n\", &R), R) {\n        int[][] L = new int[][2];\n        foreach (i; 0 .. 2) {\n            L[i] = init;\n        }\n        int[] X = L[0].uniq.array;\n        int ans = int.max;\n        foreach (i; 0 .. 2) {\n            if (L[i].length < R) continue;\n            int lb = -1, ub = L[i].back + 1;\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (L[i].countUnder(mid) >= R) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            ans = (ans < ub ? ans : ub);\n        }\n        //writeln(\"ans \", ans);\n        foreach (x; X) {\n            int c = cast(int)L[0].countUnder(x);\n            int r = R - c;\n            int lb = -1, ub = L[1].back + 1;\n            while (lb + 1 < ub) {\n                int mid = (lb + ub) / 2;\n                if (L[1].countUnder(mid) >= r) {\n                    ub = mid;\n                } else {\n                    lb = mid;\n                }\n            }\n            int cand = x + ub;\n            ans = (ans < cand ? ans : cand);\n        }\n        ans.writeln;\n    }\n}"
  },
  {
    "language": "Python",
    "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\nINF = 1000000000000\n\ndef bfs(lst, used, que, w, h):\n  v, y, x  = pop(que)\n\n  if not used[y - 1][x]:\n    push(que, (lst[y - 2][x - 1], y - 1, x))\n    used[y - 1][x] = True\n\n  if not used[y + 1][x]:\n    push(que, (lst[y][x - 1], y + 1, x))\n    used[y + 1][x] = True\n\n  if not used[y][x - 1]:\n    push(que, (lst[y - 1][x - 2], y, x - 1))\n    used[y][x - 1] = True\n\n  if not used[y][x + 1]:\n    push(que, (lst[y - 1][x], y, x + 1))\n    used[y][x + 1] = True\n\n  return v\n\ndef make_dic(lst, w, h, x, y):\n  que = [(1, y, x)]\n\n  used = [[True] * (w + 2)]\n  for i in range(h):\n    used.append([True] + [False] * w + [True])\n  used.append([True] * (w + 2))\n  used[y][x] = True\n\n  dic = [[0, 0]]\n  app = dic.append\n  Max = 0\n  acc = 0\n\n  while que:\n    v = bfs(lst, used, que, w, h)\n    acc += 1\n    if v > Max:\n      app([v, acc])\n      Max = v\n    else:\n      dic[-1][1] += 1\n  return dic\n\ndef solve():\n  while True:\n\n    R = int(input())\n    if not R:\n      break\n\n    w1, h1, x1, y1 = map(int, input().split())\n    lst1 = [list(map(int, input().split())) for _ in range(h1)]\n  \n    w2, h2, x2, y2 = map(int, input().split())\n    lst2 = [list(map(int, input().split())) for _ in range(h2)]\n  \n    dic1 = make_dic(lst1, w1, h1, x1, y1)\n    dic2 = make_dic(lst2, w2, h2, x2, y2)\n  \n    end1 = len(dic1)\n    end2 = len(dic2)\n    ind1 = 0\n    ind2 = end2 - 1\n    ans = INF\n  \n    while ind1 < end1 and ind2 > 0:\n      r1, sum1 = dic1[ind1]\n      r2, sum2 = dic2[ind2]\n  \n      if sum1 + sum2 < R:\n        ind1 += 1\n        continue\n  \n      while ind2 > 0 and sum1 + sum2 >= R:\n        ind2 -= 1\n        r2, sum2 = dic2[ind2]\n  \n      if ind2 == 0 and sum1 + sum2 >= R:\n        rs = r1 + r2\n        if rs < ans:\n          ans = rs\n        break\n  \n      else:\n        ind2 += 1\n        r2 = dic2[ind2][0]\n        rs = r1 + r2\n        if rs < ans:\n          ans = rs\n  \n      ind1 += 1\n    print(ans)\n \nsolve()\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\nINF = 1000000000000\n\ndef solve():\n  while True:\n    R = int(input())\n    if not R:\n      break\n    w1, h1, x1, y1 = map(int, input().split())\n    x1 -= 1\n    y1 -= 1\n    lst1 = [list(map(int, input().split())) for _ in range(h1)]\n    used1 = [[False] * w1 for _ in range(h1)]\n  \n    w2, h2, x2, y2 = map(int, input().split())\n    x2 -= 1\n    y2 -= 1\n    lst2 = [list(map(int, input().split())) for _ in range(h2)]\n    used2 = [[False] * w2 for _ in range(h2)]\n  \n    def bfs(lst, used, que, w, h):\n      v, y, x  = pop(que)\n      if y > 0 and not used[y - 1][x]:\n        push(que, (lst[y - 1][x], y - 1, x))\n        used[y - 1][x] = True\n      if h > y + 1 and not used[y + 1][x]:\n        push(que, (lst[y + 1][x], y + 1, x))\n        used[y + 1][x] = True\n      if x > 0 and not used[y][x - 1]:\n        push(que, (lst[y][x - 1], y, x - 1))\n        used[y][x - 1] = True\n      if w > x + 1 and not used[y][x + 1]:\n        push(que, (lst[y][x + 1], y, x + 1))\n        used[y][x + 1] = True\n      return v\n  \n    def make_dic(lst, w, h, x, y):\n      que = [(1, y, x)]\n      used = [[False] * w for _ in range(h)]\n      used[y][x] = True\n      dic = [[0, 0]]\n      app = dic.append\n      Max = 0\n      acc = 0\n  \n      while que:\n        v = bfs(lst, used, que, w, h)\n        acc += 1\n        if v > Max:\n          app([v, acc])\n          Max = v\n        else:\n          dic[-1][1] += 1\n      return dic\n  \n    dic1 = make_dic(lst1, w1, h1, x1, y1)\n    dic2 = make_dic(lst2, w2, h2, x2, y2)\n  \n    end1 = len(dic1)\n    end2 = len(dic2)\n    ind1 = 0\n    ind2 = end2 - 1\n    ans = INF\n  \n    while ind1 < end1 and ind2 > 0:\n      r1, sum1 = dic1[ind1]\n      r2, sum2 = dic2[ind2]\n  \n      if sum1 + sum2 < R:\n        ind1 += 1\n        continue\n  \n      while ind2 > 0 and sum1 + sum2 >= R:\n        ind2 -= 1\n        r2, sum2 = dic2[ind2]\n  \n      if ind2 == 0 and sum1 + sum2 >= R:\n        rs = r1 + r2\n        if rs < ans:\n          ans = rs\n        break\n  \n      else:\n        if ind2 < end2 - 1:\n          ind2 += 1\n        r2 = dic2[ind2][0]\n        rs = r1 + r2\n        if rs < ans:\n          ans = rs\n  \n      ind1 += 1\n    print(ans)\n \nsolve()\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\nINF = 1000000000000\n\ndef bfs(lst, used, que, w, h):\n  v, y, x  = pop(que)\n\n  if not used[y - 1][x]:\n    push(que, (lst[y - 2][x - 1], y - 1, x))\n    used[y - 1][x] = True\n\n  if not used[y + 1][x]:\n    push(que, (lst[y][x - 1], y + 1, x))\n    used[y + 1][x] = True\n\n  if not used[y][x - 1]:\n    push(que, (lst[y - 1][x - 2], y, x - 1))\n    used[y][x - 1] = True\n\n  if not used[y][x + 1]:\n    push(que, (lst[y - 1][x], y, x + 1))\n    used[y][x + 1] = True\n\n  return v\n\ndef make_dic(lst, w, h, x, y):\n  que = [(1, y, x)]\n  used = [[True] + [False] * w + [True] for _ in range(h)]\n  used.insert(0, [True] * (w + 2))\n  used.append([True] * (w + 2))\n  used[y][x] = True\n  dic = [[0, 0]]\n  app = dic.append\n  Max = 0\n  acc = 0\n\n  while que:\n    v = bfs(lst, used, que, w, h)\n    acc += 1\n    if v > Max:\n      app([v, acc])\n      Max = v\n    else:\n      dic[-1][1] += 1\n  return dic\n\ndef solve():\n  while True:\n\n    R = int(input())\n    if not R:\n      break\n\n    w1, h1, x1, y1 = map(int, input().split())\n    lst1 = [list(map(int, input().split())) for _ in range(h1)]\n  \n    w2, h2, x2, y2 = map(int, input().split())\n    lst2 = [list(map(int, input().split())) for _ in range(h2)]\n  \n    dic1 = make_dic(lst1, w1, h1, x1, y1)\n    dic2 = make_dic(lst2, w2, h2, x2, y2)\n  \n    end1 = len(dic1)\n    end2 = len(dic2)\n    ind1 = 0\n    ind2 = end2 - 1\n    ans = INF\n  \n    while ind1 < end1 and ind2 > 0:\n      r1, sum1 = dic1[ind1]\n      r2, sum2 = dic2[ind2]\n  \n      if sum1 + sum2 < R:\n        ind1 += 1\n        continue\n  \n      while ind2 > 0 and sum1 + sum2 >= R:\n        ind2 -= 1\n        r2, sum2 = dic2[ind2]\n  \n      if ind2 == 0 and sum1 + sum2 >= R:\n        rs = r1 + r2\n        if rs < ans:\n          ans = rs\n        break\n  \n      else:\n        ind2 += 1\n        r2 = dic2[ind2][0]\n        rs = r1 + r2\n        if rs < ans:\n          ans = rs\n  \n      ind1 += 1\n    print(ans)\n \nsolve()\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\nINF = 1000000000000\n\ndef bfs(lst, used, que, w, h):\n  v, y, x  = pop(que)\n  if y > 0 and not used[y - 1][x]:\n    push(que, (lst[y - 1][x], y - 1, x))\n    used[y - 1][x] = True\n  if h > y + 1 and not used[y + 1][x]:\n    push(que, (lst[y + 1][x], y + 1, x))\n    used[y + 1][x] = True\n  if x > 0 and not used[y][x - 1]:\n    push(que, (lst[y][x - 1], y, x - 1))\n    used[y][x - 1] = True\n  if w > x + 1 and not used[y][x + 1]:\n    push(que, (lst[y][x + 1], y, x + 1))\n    used[y][x + 1] = True\n  return v\n\ndef make_dic(lst, w, h, x, y):\n  que = [(1, y, x)]\n  used = [[False] * w for _ in range(h)]\n  used[y][x] = True\n  dic = [[0, 0]]\n  app = dic.append\n  Max = 0\n  acc = 0\n\n  while que:\n    v = bfs(lst, used, que, w, h)\n    acc += 1\n    if v > Max:\n      app([v, acc])\n      Max = v\n    else:\n      dic[-1][1] += 1\n  return dic\n\ndef solve():\n  while True:\n\n    R = int(input())\n    if not R:\n      break\n\n    w1, h1, x1, y1 = map(int, input().split())\n    lst1 = [list(map(int, input().split())) for _ in range(h1)]\n  \n    w2, h2, x2, y2 = map(int, input().split())\n    lst2 = [list(map(int, input().split())) for _ in range(h2)]\n  \n    dic1 = make_dic(lst1, w1, h1, x1 - 1, y1 - 1)\n    dic2 = make_dic(lst2, w2, h2, x2 - 1, y2 - 1)\n  \n    end1 = len(dic1)\n    end2 = len(dic2)\n    ind1 = 0\n    ind2 = end2 - 1\n    ans = INF\n  \n    while ind1 < end1 and ind2 > 0:\n      r1, sum1 = dic1[ind1]\n      r2, sum2 = dic2[ind2]\n  \n      if sum1 + sum2 < R:\n        ind1 += 1\n        continue\n  \n      while ind2 > 0 and sum1 + sum2 >= R:\n        ind2 -= 1\n        r2, sum2 = dic2[ind2]\n  \n      if ind2 == 0 and sum1 + sum2 >= R:\n        rs = r1 + r2\n        if rs < ans:\n          ans = rs\n        break\n  \n      else:\n        if ind2 < end2 - 1:\n          ind2 += 1\n        r2 = dic2[ind2][0]\n        rs = r1 + r2\n        if rs < ans:\n          ans = rs\n  \n      ind1 += 1\n    print(ans)\n \nsolve()\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\nINF = 1000000000000\n\ndef bfs(lst, used, que, w, h):\n  v, y, x  = pop(que)\n  if y > 0 and not used[y - 1][x]:\n    push(que, (lst[y - 1][x], y - 1, x))\n    used[y - 1][x] = True\n  if h > y + 1 and not used[y + 1][x]:\n    push(que, (lst[y + 1][x], y + 1, x))\n    used[y + 1][x] = True\n  if x > 0 and not used[y][x - 1]:\n    push(que, (lst[y][x - 1], y, x - 1))\n    used[y][x - 1] = True\n  if w > x + 1 and not used[y][x + 1]:\n    push(que, (lst[y][x + 1], y, x + 1))\n    used[y][x + 1] = True\n  return v\n\ndef make_dic(lst, w, h, x, y):\n  que = [(1, y, x)]\n  used = [[False] * w for _ in range(h)]\n  used[y][x] = True\n  dic = [[0, 0]]\n  app = dic.append\n  Max = 0\n  acc = 0\n\n  while que:\n    v = bfs(lst, used, que, w, h)\n    acc += 1\n    if v > Max:\n      app([v, acc])\n      Max = v\n    else:\n      dic[-1][1] += 1\n  return dic\n\ndef solve():\n  while True:\n\n    R = int(input())\n    if not R:\n      break\n\n    w1, h1, x1, y1 = map(int, input().split())\n    lst1 = [list(map(int, input().split())) for _ in range(h1)]\n  \n    w2, h2, x2, y2 = map(int, input().split())\n    lst2 = [list(map(int, input().split())) for _ in range(h2)]\n  \n    dic1 = make_dic(lst1, w1, h1, x1 - 1, y1 - 1)\n    dic2 = make_dic(lst2, w2, h2, x2 - 1, y2 - 1)\n  \n    end1 = len(dic1)\n    end2 = len(dic2)\n    ind1 = 0\n    ind2 = end2 - 1\n    ans = INF\n  \n    while ind1 < end1 and ind2 > 0:\n      r1, sum1 = dic1[ind1]\n      r2, sum2 = dic2[ind2]\n  \n      if sum1 + sum2 < R:\n        ind1 += 1\n        continue\n  \n      while ind2 > 0 and sum1 + sum2 >= R:\n        ind2 -= 1\n        r2, sum2 = dic2[ind2]\n  \n      if ind2 == 0 and sum1 + sum2 >= R:\n        rs = r1 + r2\n        if rs < ans:\n          ans = rs\n        break\n  \n      else:\n        ind2 += 1\n        r2 = dic2[ind2][0]\n        rs = r1 + r2\n        if rs < ans:\n          ans = rs\n  \n      ind1 += 1\n    print(ans)\n \nsolve()\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\nINF = 1000000000000\n\ndef bfs(lst, used, que, w, h):\n  v, y, x  = pop(que)\n  if y > 0 and not used[y - 1][x]:\n    push(que, (lst[y - 1][x], y - 1, x))\n    used[y - 1][x] = True\n  if h > y + 1 and not used[y + 1][x]:\n    push(que, (lst[y + 1][x], y + 1, x))\n    used[y + 1][x] = True\n  if x > 0 and not used[y][x - 1]:\n    push(que, (lst[y][x - 1], y, x - 1))\n    used[y][x - 1] = True\n  if w > x + 1 and not used[y][x + 1]:\n    push(que, (lst[y][x + 1], y, x + 1))\n    used[y][x + 1] = True\n  return v\n\ndef make_dic(lst, w, h, x, y):\n  que = [(1, y, x)]\n  used = [[False] * w for _ in range(h)]\n  used[y][x] = True\n  dic = [[0, 0]]\n  app = dic.append\n  Max = 0\n  acc = 0\n\n  while que:\n    v = bfs(lst, used, que, w, h)\n    acc += 1\n    if v > Max:\n      app([v, acc])\n      Max = v\n    else:\n      dic[-1][1] += 1\n  return dic\n\ndef solve():\n  while True:\n\n    R = int(input())\n    if not R:\n      break\n\n    w1, h1, x1, y1 = map(int, input().split())\n    x1 -= 1\n    y1 -= 1\n    lst1 = [list(map(int, input().split())) for _ in range(h1)]\n    used1 = [[False] * w1 for _ in range(h1)]\n  \n    w2, h2, x2, y2 = map(int, input().split())\n    x2 -= 1\n    y2 -= 1\n    lst2 = [list(map(int, input().split())) for _ in range(h2)]\n    used2 = [[False] * w2 for _ in range(h2)]\n  \n    dic1 = make_dic(lst1, w1, h1, x1, y1)\n    dic2 = make_dic(lst2, w2, h2, x2, y2)\n  \n    end1 = len(dic1)\n    end2 = len(dic2)\n    ind1 = 0\n    ind2 = end2 - 1\n    ans = INF\n  \n    while ind1 < end1 and ind2 > 0:\n      r1, sum1 = dic1[ind1]\n      r2, sum2 = dic2[ind2]\n  \n      if sum1 + sum2 < R:\n        ind1 += 1\n        continue\n  \n      while ind2 > 0 and sum1 + sum2 >= R:\n        ind2 -= 1\n        r2, sum2 = dic2[ind2]\n  \n      if ind2 == 0 and sum1 + sum2 >= R:\n        rs = r1 + r2\n        if rs < ans:\n          ans = rs\n        break\n  \n      else:\n        if ind2 < end2 - 1:\n          ind2 += 1\n        r2 = dic2[ind2][0]\n        rs = r1 + r2\n        if rs < ans:\n          ans = rs\n  \n      ind1 += 1\n    print(ans)\n \nsolve()\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappop as pop\nfrom heapq import heappush as push\nINF = 1000000000000\nwhile True:\n  R = int(input())\n  if not R:\n    break\n  w1, h1, x1, y1 = map(int, input().split())\n  x1 -= 1\n  y1 -= 1\n  lst1 = [list(map(int, input().split())) for _ in range(h1)]\n  used1 = [[False] * w1 for _ in range(h1)]\n\n  w2, h2, x2, y2 = map(int, input().split())\n  x2 -= 1\n  y2 -= 1\n  lst2 = [list(map(int, input().split())) for _ in range(h2)]\n  used2 = [[False] * w2 for _ in range(h2)]\n\n  def bfs(lst, used, que, w, h):\n    v, y, x  = pop(que)\n    if y > 0 and not used[y - 1][x]:\n      push(que, (lst[y - 1][x], y - 1, x))\n      used[y - 1][x] = True\n    if h > y + 1 and not used[y + 1][x]:\n      push(que, (lst[y + 1][x], y + 1, x))\n      used[y + 1][x] = True\n    if x > 0 and not used[y][x - 1]:\n      push(que, (lst[y][x - 1], y, x - 1))\n      used[y][x - 1] = True\n    if w > x + 1 and not used[y][x + 1]:\n      push(que, (lst[y][x + 1], y, x + 1))\n      used[y][x + 1] = True\n    return v\n\n  que = [(1, y1, x1)]\n  used1[y1][x1] = True\n  rec1 = [[0, 0]]\n  Max = 0\n  acc = 0\n\n  while que:\n    v = bfs(lst1, used1, que, w1, h1)\n    acc += 1\n    if v > Max:\n      rec1.append([v, acc])\n      Max = v\n    else:\n      rec1[-1][1] += 1\n\n  que = [(1, y2, x2)]\n  used2[y2][x2] = True\n  rec2 = [[0, 0]]\n  Max = 0\n  acc = 0\n\n  while que:\n    v = bfs(lst2, used2, que, w2, h2)\n    acc += 1\n    if v > Max:\n      rec2.append([v, acc])\n      Max = v\n    else:\n      rec2[-1][1] += 1\n  \n  end1 = len(rec1)\n  end2 = len(rec2)\n  ind1 = 0\n  ind2 = end2 - 1\n  ans = INF\n#  print(rec1)\n#  print(rec2)\n  while ind1 < end1 and ind2 > 0:\n    r1, sum1 = rec1[ind1]\n    r2, sum2 = rec2[ind2]\n    if sum1 + sum2 < R:\n      ind1 += 1\n      continue\n    while ind2 > 0 and sum1 + sum2 >= R:\n      ind2 -= 1\n      r2, sum2 = rec2[ind2]\n    if ind2 == 0 and sum1 + sum2 >= R:\n      ans = min(ans, r1 + r2)\n      break\n    else:\n      if ind2 < end2 - 1:\n        ind2 += 1\n      r2, sum2 = rec2[ind2]\n      ans = min(ans, r1 + r2)\n    ind1 += 1\n  print(ans)\n"
  }
]