[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <stdbool.h>\n\n#define MAX_N 100\n\nint N, D1, D2;\nint points[MAX_N * MAX_N][2];\nint pointCount;\n\ndouble distance(int x1, int y1, int x2, int y2) {\n    return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n}\n\nbool isGoodSet(int *set, int size) {\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            double dist = distance(points[set[i]][0], points[set[i]][1], \n                                   points[set[j]][0], points[set[j]][1]);\n            if (fabs(dist - sqrt(D1)) < 1e-9 || fabs(dist - sqrt(D2)) < 1e-9) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nbool backtrack(int *current, int currentSize, int start) {\n    if (currentSize == N * N) {\n        return true;\n    }\n\n    for (int i = start; i < pointCount; i++) {\n        current[currentSize] = i;\n        if (isGoodSet(current, currentSize + 1)) {\n            if (backtrack(current, currentSize + 1, i + 1)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    scanf(\"%d %d %d\", &N, &D1, &D2);\n\n    pointCount = 0;\n    for (int i = 0; i < 2 * N; i++) {\n        for (int j = 0; j < 2 * N; j++) {\n            points[pointCount][0] = i;\n            points[pointCount][1] = j;\n            pointCount++;\n        }\n    }\n\n    int subset[MAX_N * MAX_N];\n    if (backtrack(subset, 0, 0)) {\n        for (int i = 0; i < N * N; i++) {\n            printf(\"%d %d\\n\", points[subset[i]][0], points[subset[i]][1]);\n        }\n    } else {\n        printf(\"No solution\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:05:40"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nbool isGood(int x1, int y1, int x2, int y2, int D1, int D2) {\n    int dx = x1 - x2;\n    int dy = y1 - y2;\n    int distance_squared = dx * dx + dy * dy;\n    return (distance_squared != D1) && (distance_squared != D2);\n}\n\nvoid findGoodSubset(int N, int D1, int D2) {\n    int size = 2 * N;\n    int count = 0;\n    int max_points = N * N;\n    \n    for (int i = 0; i < size && count < max_points; i++) {\n        for (int j = 0; j < size && count < max_points; j++) {\n            bool valid = true;\n            for (int x = 0; x < i && valid; x++) {\n                for (int y = 0; y < size; y++) {\n                    if (!isGood(i, j, x, y, D1, D2)) {\n                        valid = false;\n                        break;\n                    }\n                }\n            }\n            if (valid) {\n                for (int y = 0; y < j && valid; y++) {\n                    if (!isGood(i, j, i, y, D1, D2)) {\n                        valid = false;\n                        break;\n                    }\n                }\n            }\n            if (valid) {\n                printf(\"%d %d\\n\", i, j);\n                count++;\n            }\n        }\n    }\n}\n\nint main() {\n    int N, D1, D2;\n    scanf(\"%d %d %d\", &N, &D1, &D2);\n    findGoodSubset(N, D1, D2);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:06:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\nbool isGood(int x1, int y1, int x2, int y2, int D1, int D2) {\n    int dx = x1 - x2;\n    int dy = y1 - y2;\n    int distance = dx * dx + dy * dy;\n    return (distance != D1) && (distance != D2);\n}\n\nvector<pair<int, int>> findGoodSubset(int N, int D1, int D2) {\n    vector<pair<int, int>> points;\n    for (int i = 0; i < 2 * N; ++i) {\n        for (int j = 0; j < 2 * N; ++j) {\n            points.emplace_back(i, j);\n        }\n    }\n\n    vector<pair<int, int>> selected;\n    int required = N * N;\n    for (int i = 0; i < points.size() && selected.size() < required; ++i) {\n        bool valid = true;\n        for (const auto& p : selected) {\n            if (!isGood(p.first, p.second, points[i].first, points[i].second, D1, D2)) {\n                valid = false;\n                break;\n            }\n        }\n        if (valid) {\n            selected.push_back(points[i]);\n        }\n    }\n\n    if (selected.size() < required) {\n        selected.clear();\n        int colorD1 = 0;\n        int colorD2 = 0;\n        for (int k = 0; k <= 30; ++k) {\n            if ((D1 >> k) & 1) {\n                colorD1 = k % 2;\n                break;\n            }\n        }\n        for (int k = 0; k <= 30; ++k) {\n            if ((D2 >> k) & 1) {\n                colorD2 = k % 2;\n                break;\n            }\n        }\n        for (int i = 0; i < 2 * N && selected.size() < required; ++i) {\n            for (int j = 0; j < 2 * N && selected.size() < required; ++j) {\n                int c1 = (i >> colorD1) & 1;\n                int c2 = (j >> colorD2) & 1;\n                if ((c1 + c2) % 2 == 0) {\n                    selected.emplace_back(i, j);\n                }\n            }\n        }\n    }\n\n    return selected;\n}\n\nint main() {\n    int N, D1, D2;\n    cin >> N >> D1 >> D2;\n    vector<pair<int, int>> result = findGoodSubset(N, D1, D2);\n    for (const auto& p : result) {\n        cout << p.first << \" \" << p.second << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 23:06:53"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static class Point {\n        int x, y;\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int D1 = scanner.nextInt();\n        int D2 = scanner.nextInt();\n        \n        List<Point> points = new ArrayList<>();\n        for (int i = 0; i < 2 * N; i++) {\n            for (int j = 0; j < 2 * N; j++) {\n                points.add(new Point(i, j));\n            }\n        }\n        \n        List<Point> goodSet = new ArrayList<>();\n        for (Point p : points) {\n            boolean isValid = true;\n            for (Point q : goodSet) {\n                int dx = p.x - q.x;\n                int dy = p.y - q.y;\n                int distanceSq = dx * dx + dy * dy;\n                if (distanceSq == D1 || distanceSq == D2) {\n                    isValid = false;\n                    break;\n                }\n            }\n            if (isValid) {\n                goodSet.add(p);\n                if (goodSet.size() == N * N) {\n                    break;\n                }\n            }\n        }\n        \n        for (Point p : goodSet) {\n            System.out.println(p.x + \" \" + p.y);\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:07:37"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class GoodPointSet {\n    public static int[][] findGoodSet(int N, int D1, int D2) {\n        int[][] points = new int[N * N][2];\n        int count = 0;\n        \n        outerLoop:\n        for (int i = 0; i < 2 * N; i++) {\n            for (int j = 0; j < 2 * N; j++) {\n                boolean isGood = true;\n                \n                for (int k = 0; k < count; k++) {\n                    int dx = points[k][0] - i;\n                    int dy = points[k][1] - j;\n                    double dist = Math.sqrt(dx * dx + dy * dy);\n                    \n                    if (dist == Math.sqrt(D1) || dist == Math.sqrt(D2)) {\n                        isGood = false;\n                        break;\n                    }\n                }\n                \n                if (isGood) {\n                    points[count][0] = i;\n                    points[count][1] = j;\n                    count++;\n                    \n                    if (count == N * N) {\n                        break outerLoop;\n                    }\n                }\n            }\n        }\n        \n        return points;\n    }\n}",
    "timestamp": "2025-08-05 23:07:42"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<pair<int, int>> findGoodSet(int N, int D1, int D2) {\n        vector<pair<int, int>> points;\n        vector<pair<int, int>> goodSet;\n        \n        // Generate all points\n        for (int i = 0; i < 2*N; i++) {\n            for (int j = 0; j < 2*N; j++) {\n                points.push_back({i, j});\n            }\n        }\n        \n        // Try to find a good set using greedy approach\n        goodSet.push_back(points[0]);\n        \n        for (int k = 1; k < points.size(); k++) {\n            bool isGood = true;\n            \n            // Check if point can be added to set\n            for (auto& p : goodSet) {\n                double dist = sqrt(pow(p.first - points[k].first, 2) + \n                                   pow(p.second - points[k].second, 2));\n                \n                if (abs(dist - sqrt(D1)) < 1e-9 || abs(dist - sqrt(D2)) < 1e-9) {\n                    isGood = false;\n                    break;\n                }\n            }\n            \n            // Add point if it maintains goodness\n            if (isGood) {\n                goodSet.push_back(points[k]);\n            }\n            \n            // Stop when good set reaches desired size\n            if (goodSet.size() == N*N) {\n                break;\n            }\n        }\n        \n        return goodSet;\n    }\n};\n\nint main() {\n    int N, D1, D2;\n    cin >> N >> D1 >> D2;\n    \n    Solution sol;\n    vector<pair<int, int>> result = sol.findGoodSet(N, D1, D2);\n    \n    // Print result\n    for (auto& point : result) {\n        cout << point.first << \" \" << point.second << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:07:50"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import combinations\nimport math\n\ndef is_good_set(points, D1, D2):\n    for (x1, y1), (x2, y2) in combinations(points, 2):\n        dist = (x2 - x1)**2 + (y2 - y1)**2\n        if dist == D1 or dist == D2:\n            return False\n    return True\n\ndef find_good_set(N, D1, D2):\n    D1, D2 = D1**2, D2**2\n    X = [(i, j) for i in range(2 * N) for j in range(2 * N)]\n    \n    for subset in combinations(X, N**2):\n        if is_good_set(subset, D1, D2):\n            return subset\n\nN = int(input(\"Enter value for N: \"))\nD1 = int(input(\"Enter value for D1: \"))\nD2 = int(input(\"Enter value for D2: \"))\n\ngood_set = find_good_set(N, D1, D2)\nif good_set:\n    print(\"Good set of size N² found:\")\n    for point in good_set:\n        print(point)\nelse:\n    print(\"No good set of size N² found.\")",
    "timestamp": "2025-08-13 13:38:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class GoodSetFinder {\n\n    public static void main(String[] args) {\n        int N = 5; // Example value; use the given N\n        int D1 = 13; // Example value; use the given D1\n        int D2 = 20; // Example value; use the given D2\n\n        Set<Point> goodSet = findGoodSet(N, D1, D2);\n\n        // Output the result\n        for (Point p : goodSet) {\n            System.out.println(\"(\" + p.x + \", \" + p.y + \")\");\n        }\n    }\n\n    private static Set<Point> findGoodSet(int N, int D1, int D2) {\n        Set<Point> goodSet = new HashSet<>();\n        int limit = 2 * N;\n        double sqrtD1 = Math.sqrt(D1);\n        double sqrtD2 = Math.sqrt(D2);\n\n        for (int i = 0; i < limit; i++) {\n            for (int j = 0; j < limit; j++) {\n                Point current = new Point(i, j);\n                boolean validPoint = true;\n\n                for (Point p : goodSet) {\n                    double distance = euclideanDistance(p, current);\n                    if (Double.compare(distance, sqrtD1) == 0 || Double.compare(distance, sqrtD2) == 0) {\n                        validPoint = false;\n                        break;\n                    }\n                }\n\n                if (validPoint) {\n                    goodSet.add(current);\n                    if (goodSet.size() == N * N) {\n                        return goodSet;\n                    }\n                }\n            }\n        }\n\n        return goodSet;\n    }\n\n    private static double euclideanDistance(Point p1, Point p2) {\n        int dx = p1.x - p2.x;\n        int dy = p1.y - p2.y;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    private static class Point {\n        int x, y;\n\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n}",
    "timestamp": "2025-08-13 13:38:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint is_good_distance(int x1, int y1, int x2, int y2, int D1, int D2) {\n    int dx = x2 - x1;\n    int dy = y2 - y1;\n    int distance_squared = dx * dx + dy * dy;\n    if (distance_squared == D1 || distance_squared == D2) return 0;\n    return 1;\n}\n\nint main() {\n    int N, D1, D2;\n    scanf(\"%d %d %d\", &N, &D1, &D2);\n\n    int size = 2 * N;\n    Point subset[N][N];\n    int filled = 0;\n\n    for (int i = 0; i < size && filled < N; i += 2) {  // Skip every row\n        for (int j = (i/2) % 2; j < size && filled < N; j += 2) { // Skip every other col\n            subset[filled/size][filled % size] = (Point){i, j};\n            filled++;\n        }\n    }\n\n    // Output the subset\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            printf(\"(%d, %d)\\n\", subset[i][j].x, subset[i][j].y);\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 13:38:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function isGoodSet(points, D1, D2) {\n    const dist = (p1, p2) => (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2;\n    for (let i = 0; i < points.length; i++) {\n        for (let j = i + 1; j < points.length; j++) {\n            const d = dist(points[i], points[j]);\n            if (d === D1 || d === D2) return false;\n        }\n    }\n    return true;\n}\n\nfunction generatePoints(N) {\n    const points = [];\n    for (let i = 0; i < 2 * N; i++) {\n        for (let j = 0; j < 2 * N; j++) {\n            points.push([i, j]);\n        }\n    }\n    return points;\n}\n\nfunction findGoodSet(N, D1, D2) {\n    const allPoints = generatePoints(N);\n    const goodSet = [];\n    for (const point of allPoints) {\n        if (goodSet.length < N * N) {\n            goodSet.push(point);\n            if (isGoodSet(goodSet, D1, D2)) continue;\n            goodSet.pop();\n        }\n    }\n    return goodSet;\n}\n\n// Example usage:\nconst N = 3;\nconst D1 = 4;\nconst D2 = 5;\nconst goodSet = findGoodSet(N, D1, D2);\nconsole.log(goodSet);",
    "timestamp": "2025-08-13 13:38:36"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def is_good_set(points, D1, D2):\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            dist = ((points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2) ** 0.5\n            if dist == (D1 ** 0.5) or dist == (D2 ** 0.5):\n                return False\n    return True\n\ndef solve(N, D1, D2):\n    points = [(x, y) for x in range(2*N) for y in range(2*N)]\n    \n    def backtrack(current_set):\n        if len(current_set) == N * N:\n            return current_set\n        \n        for point in points:\n            if point not in current_set:\n                current_set.append(point)\n                if is_good_set(current_set, D1, D2):\n                    result = backtrack(current_set)\n                    if result:\n                        return result\n                current_set.pop()\n        \n        return None\n\n    return backtrack([])\n\n# Example usage\nN, D1, D2 = map(int, input().split())\nresult = solve(N, D1, D2)\nif result:\n    for point in result:\n        print(point[0], point[1])\nelse:\n    print(\"No solution\")",
    "timestamp": "2025-08-13 13:38:42"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function findGoodSet(N, D1, D2) {\n    const points = [];\n    for (let i = 0; i < 2*N; i++) {\n        for (let j = 0; j < 2*N; j++) {\n            points.push([i, j]);\n        }\n    }\n\n    function distance(p1, p2) {\n        return Math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2);\n    }\n\n    function isGoodSet(set, point) {\n        for (const p of set) {\n            const dist = distance(p, point);\n            if (dist === Math.sqrt(D1) || dist === Math.sqrt(D2)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function backtrack(currentSet) {\n        if (currentSet.length === N*N) {\n            return currentSet;\n        }\n\n        for (const point of points) {\n            if (!currentSet.includes(point) && isGoodSet(currentSet, point)) {\n                currentSet.push(point);\n                const result = backtrack(currentSet);\n                if (result) return result;\n                currentSet.pop();\n            }\n        }\n\n        return null;\n    }\n\n    return backtrack([]);\n}",
    "timestamp": "2025-08-13 13:38:47"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    N, D1, D2 = map(int, sys.stdin.readline().split())\n    \n    def is_valid(x, y):\n        # Check if (x,y) can be included in the good set\n        # We need to ensure that for any two points (x1,y1) and (x2,y2) in the set,\n        # (x1-x2)^2 + (y1-y2)^2 != D1 and != D2\n        # To simplify, we can use a coloring approach based on D1 and D2's properties\n        # Here, we use a coloring based on parity or other properties\n        \n        # For D1 and D2, find a coloring pattern that ensures no two points in the same color\n        # have distance squared D1 or D2\n        # One common approach is to use (x + y) % 2 or (x // k + y // k) % 2 etc.\n        # We need to find a pattern where for any two points (x1,y1) and (x2,y2) in the same color,\n        # (x1-x2)^2 + (y1-y2)^2 is neither D1 nor D2\n        \n        # For simplicity, we can use multiple colorings and pick the one that gives enough points\n        # Here, we try two colorings:\n        # 1. (x + y) % 2 == 0\n        # 2. (x // 2 + y // 2) % 2 == 0\n        # We'll try both and see which one gives at least N^2 points\n        \n        # Try coloring 1: (x + y) % 2 == 0\n        cnt1 = 0\n        points1 = []\n        for i in range(2*N):\n            for j in range(2*N):\n                if (i + j) % 2 == 0:\n                    cnt1 += 1\n                    points1.append((i, j))\n        if cnt1 >= N*N:\n            return 1\n        \n        # Try coloring 2: (x // 2 + y // 2) % 2 == 0\n        cnt2 = 0\n        points2 = []\n        for i in range(2*N):\n            for j in range(2*N):\n                if (i // 2 + j // 2) % 2 == 0:\n                    cnt2 += 1\n                    points2.append((i, j))\n        if cnt2 >= N*N:\n            return 2\n        \n        # If neither works, try another coloring, but for the problem's constraints, one should work\n        # As a fallback, use coloring 1 even if it's not enough (though the problem says it's possible)\n        return 1\n    \n    coloring = is_valid(0, 0)\n    \n    selected = []\n    if coloring == 1:\n        for i in range(2*N):\n            for j in range(2*N):\n                if (i + j) % 2 == 0:\n                    selected.append((i, j))\n                    if len(selected) == N*N:\n                        break\n            if len(selected) == N*N:\n                break\n    elif coloring == 2:\n        for i in range(2*N):\n            for j in range(2*N):\n                if (i // 2 + j // 2) % 2 == 0:\n                    selected.append((i, j))\n                    if len(selected) == N*N:\n                        break\n            if len(selected) == N*N:\n                break\n    \n    for point in selected:\n        print(point[0], point[1])\n\nsolve()",
    "timestamp": "2025-08-13 13:39:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(N, D1, D2) {\n    let points = [];\n    for (let i = 0; i < 2 * N; i++) {\n        for (let j = 0; j < 2 * N; j++) {\n            points.push([i, j]);\n        }\n    }\n\n    // Check if a point is valid based on color (parity)\n    function getColor(x, y) {\n        // We use two different coloring schemes based on D1 and D2\n        // For D1: (x + y) % (2 * k1) where k1 is related to D1\n        // For D2: (x - y) % (2 * k2) where k2 is related to D2\n        // We need to find a common color that appears at least N² times\n        // Here, we use parity for simplicity (but may not work for all D1, D2)\n        // A more robust approach is needed for arbitrary D1, D2\n        const c1 = (Math.floor(x / Math.sqrt(D1)) + Math.floor(y / Math.sqrt(D1))) % 2;\n        const c2 = (Math.floor(x / Math.sqrt(D2)) - Math.floor(y / Math.sqrt(D2))) % 2;\n        return [c1, c2];\n    }\n\n    // Count points for each color combination\n    let colorCounts = {};\n    for (let [x, y] of points) {\n        let [c1, c2] = getColor(x, y);\n        let key = `${c1},${c2}`;\n        if (!colorCounts[key]) {\n            colorCounts[key] = [];\n        }\n        colorCounts[key].push([x, y]);\n    }\n\n    // Find a color with at least N² points\n    for (let key in colorCounts) {\n        if (colorCounts[key].length >= N * N) {\n            let result = colorCounts[key].slice(0, N * N);\n            // Output the result\n            result.forEach(point => {\n                console.log(point[0] + ' ' + point[1]);\n            });\n            return;\n        }\n    }\n\n    // If no color has enough points, try another approach (e.g., combining colors)\n    // This part is a fallback and may not work for all cases\n    let combined = [];\n    for (let key in colorCounts) {\n        combined.push(...colorCounts[key]);\n        if (combined.length >= N * N) {\n            combined.slice(0, N * N).forEach(point => {\n                console.log(point[0] + ' ' + point[1]);\n            });\n            return;\n        }\n    }\n}\n\n// Read input (assuming input is given via standard input)\nconst readline = require('readline');\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nlet input = [];\nrl.on('line', (line) => {\n    input.push(line.trim());\n}).on('close', () => {\n    const [N, D1, D2] = input[0].split(' ').map(Number);\n    solve(N, D1, D2);\n});",
    "timestamp": "2025-08-13 13:39:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <set>\n\nusing namespace std;\n\nint main() {\n    int N, D1, D2;\n    cin >> N >> D1 >> D2;\n    vector<pair<int, int>> points;\n    set<pair<int, int>> goodSet;\n\n    // Generate all points (i, j) with 0 <= i, j < 2N\n    for (int i = 0; i < 2 * N; ++i) {\n        for (int j = 0; j < 2 * N; ++j) {\n            points.emplace_back(i, j);\n        }\n    }\n    \n    auto distanceSquared = [](const pair<int, int>& p1, const pair<int, int>& p2) {\n        int dx = p1.first - p2.first;\n        int dy = p1.second - p2.second;\n        return dx * dx + dy * dy;\n    };\n\n    for (const auto& point : points) {\n        bool canAdd = true;\n        for (const auto& existing : goodSet) {\n            int distSq = distanceSquared(point, existing);\n            if (distSq == D1 || distSq == D2) {\n                canAdd = false;\n                break;\n            }\n        }\n        if (canAdd) {\n            goodSet.insert(point);\n        }\n        if (goodSet.size() == N * N) {\n            break;\n        }\n    }\n\n    for (const auto& p : goodSet) {\n        cout << p.first << \" \" << p.second << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:40:36"
  }
]