[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_N 100\n#define MAX_M 100\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef struct {\n    Point pos[2];\n    int steps;\n} State;\n\nint N, M;\nchar grid[MAX_N][MAX_M];\nbool visited[MAX_N][MAX_M][MAX_N][MAX_M];\nPoint start[2], dest;\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nState queue[MAX_N * MAX_N * MAX_M * MAX_M];\nint front, rear;\n\nvoid enqueue(State s) {\n    queue[rear++] = s;\n}\n\nState dequeue() {\n    return queue[front++];\n}\n\nbool is_valid(int x, int y) {\n    return x >= 0 && x < N && y >= 0 && y < M && grid[x][y] != '#';\n}\n\nbool bfs() {\n    front = rear = 0;\n    State initial;\n    initial.pos[0] = start[0];\n    initial.pos[1] = start[1];\n    initial.steps = 0;\n    enqueue(initial);\n    visited[start[0].x][start[0].y][start[1].x][start[1].y] = true;\n\n    while (front < rear) {\n        State current = dequeue();\n        if (current.pos[0].x == dest.x && current.pos[0].y == dest.y &&\n            current.pos[1].x == dest.x && current.pos[1].y == dest.y) {\n            return true;\n        }\n\n        for (int i = 0; i < 4; i++) {\n            Point next[2];\n            next[0].x = current.pos[0].x + dx[i];\n            next[0].y = current.pos[0].y + dy[i];\n            if (!is_valid(next[0].x, next[0].y)) {\n                next[0] = current.pos[0];\n            }\n\n            next[1].x = current.pos[1].x + dx[i];\n            next[1].y = current.pos[1].y + dy[i];\n            if (!is_valid(next[1].x, next[1].y)) {\n                next[1] = current.pos[1];\n            }\n\n            if (!visited[next[0].x][next[0].y][next[1].x][next[1].y]) {\n                visited[next[0].x][next[0].y][next[1].x][next[1].y] = true;\n                State newState;\n                newState.pos[0] = next[0];\n                newState.pos[1] = next[1];\n                newState.steps = current.steps + 1;\n                enqueue(newState);\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n    for (int i = 0; i < N; i++) {\n        scanf(\"%s\", grid[i]);\n        for (int j = 0; j < M; j++) {\n            if (grid[i][j] == 'R') {\n                start[0].x = i;\n                start[0].y = j;\n                grid[i][j] = '.';\n            } else if (grid[i][j] == 'L') {\n                start[1].x = i;\n                start[1].y = j;\n                grid[i][j] = '.';\n            } else if (grid[i][j] == 'T') {\n                dest.x = i;\n                dest.y = j;\n                grid[i][j] = '.';\n            }\n        }\n    }\n\n    memset(visited, false, sizeof(visited));\n    if (bfs()) {\n        printf(\"YES\\n\");\n    } else {\n        printf(\"NO\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:10:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\nusing namespace std;\n\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\nbool is_valid(int x, int y, int n, int m, const vector<string>& grid) {\n    return x >= 0 && x < n && y >= 0 && y < m && grid[x][y] != '#';\n}\n\nbool can_reach(int n, int m, const vector<string>& grid, int r1, int c1, int r2, int c2, int dr, int dc) {\n    queue<tuple<int, int, int, int>> q;\n    vector<vector<vector<vector<bool>>>> visited(n, vector<vector<vector<bool>>>(m, vector<vector<bool>>(n, vector<bool>(m, false))));\n    q.push({r1, c1, r2, c2});\n    visited[r1][c1][r2][c2] = true;\n\n    while (!q.empty()) {\n        auto [x1, y1, x2, y2] = q.front();\n        q.pop();\n\n        if (x1 == dr && y1 == dc && x2 == dr && y2 == dc) {\n            return true;\n        }\n\n        for (int k = 0; k < 4; ++k) {\n            int nx1 = x1 + dx[k];\n            int ny1 = y1 + dy[k];\n            int nx2 = x2 + dx[k];\n            int ny2 = y2 + dy[k];\n\n            if (!is_valid(nx1, ny1, n, m, grid)) {\n                nx1 = x1;\n                ny1 = y1;\n            }\n            if (!is_valid(nx2, ny2, n, m, grid)) {\n                nx2 = x2;\n                ny2 = y2;\n            }\n\n            if (!visited[nx1][ny1][nx2][ny2]) {\n                visited[nx1][ny1][nx2][ny2] = true;\n                q.push({nx1, ny1, nx2, ny2});\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<string> grid(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> grid[i];\n    }\n\n    int r1 = -1, c1 = -1, r2 = -1, c2 = -1, dr = -1, dc = -1;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (grid[i][j] == 'R') {\n                r1 = i;\n                c1 = j;\n            } else if (grid[i][j] == 'L') {\n                r2 = i;\n                c2 = j;\n            } else if (grid[i][j] == 'T') {\n                dr = i;\n                dc = j;\n            }\n        }\n    }\n\n    if (can_reach(n, m, grid, r1, c1, r2, c2, dr, dc)) {\n        cout << \"YES\" << endl;\n    } else {\n        cout << \"NO\" << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:10:43"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TwinsTreasure {\n    static class State {\n        int r1, c1, r2, c2;\n        State(int r1, int c1, int r2, int c2) {\n            this.r1 = r1;\n            this.c1 = c1;\n            this.r2 = r2;\n            this.c2 = c2;\n        }\n        \n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            State state = (State) o;\n            return r1 == state.r1 && c1 == state.c1 && r2 == state.r2 && c2 == state.c2;\n        }\n        \n        @Override\n        public int hashCode() {\n            return Objects.hash(r1, c1, r2, c2);\n        }\n    }\n    \n    public static boolean canReach(int[][] grid, int[] start1, int[] start2, int[] dest) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n        int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        Queue<State> queue = new LinkedList<>();\n        Set<State> visited = new HashSet<>();\n        \n        State initial = new State(start1[0], start1[1], start2[0], start2[1]);\n        queue.add(initial);\n        visited.add(initial);\n        \n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n            if (current.r1 == dest[0] && current.c1 == dest[1] && current.r2 == dest[0] && current.c2 == dest[1]) {\n                return true;\n            }\n            \n            for (int[] dir : dirs) {\n                int nr1 = current.r1 + dir[0];\n                int nc1 = current.c1 + dir[1];\n                int nr2 = current.r2 + dir[0];\n                int nc2 = current.c2 + dir[1];\n                \n                if (nr1 < 0 || nr1 >= rows || nc1 < 0 || nc1 >= cols || grid[nr1][nc1] == 1) {\n                    nr1 = current.r1;\n                    nc1 = current.c1;\n                }\n                if (nr2 < 0 || nr2 >= rows || nc2 < 0 || nc2 >= cols || grid[nr2][nc2] == 1) {\n                    nr2 = current.r2;\n                    nc2 = current.c2;\n                }\n                \n                State next = new State(nr1, nc1, nr2, nc2);\n                if (!visited.contains(next)) {\n                    visited.add(next);\n                    queue.add(next);\n                }\n            }\n        }\n        return false;\n    }\n    \n    public static void main(String[] args) {\n        // Example usage\n        int[][] grid = {\n            {0, 0, 1, 0, 0},\n            {0, 0, 0, 0, 0},\n            {0, 0, 1, 0, 1},\n            {1, 1, 0, 0, 0},\n            {0, 0, 0, 1, 0}\n        };\n        int[] start1 = {0, 0};\n        int[] start2 = {4, 4};\n        int[] dest = {2, 2};\n        System.out.println(canReach(grid, start1, start2, dest));\n    }\n}",
    "timestamp": "2025-08-05 21:11:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    private static final int[] dx = {0, 0, 1, -1};\n    private static final int[] dy = {1, -1, 0, 0};\n\n    public boolean canReachTreasure(char[][] grid, int[] rinStart, int[] lenStart, int[] destination) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n        \n        Queue<State> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        \n        State initialState = new State(rinStart[0], rinStart[1], lenStart[0], lenStart[1], 0);\n        queue.offer(initialState);\n        visited.add(getStateKey(initialState));\n        \n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n            \n            if (current.rinX == destination[0] && current.rinY == destination[1] && \n                current.lenX == destination[0] && current.lenY == destination[1]) {\n                return true;\n            }\n            \n            for (int i = 0; i < 4; i++) {\n                int newRinX = current.rinX + dx[i];\n                int newRinY = current.rinY + dy[i];\n                int newLenX = current.lenX + dx[i];\n                int newLenY = current.lenY + dy[i];\n                \n                boolean rinBlocked = !isValidMove(grid, newRinX, newRinY);\n                boolean lenBlocked = !isValidMove(grid, newLenX, newLenY);\n                \n                if (rinBlocked) {\n                    newRinX = current.rinX;\n                    newRinY = current.rinY;\n                }\n                \n                if (lenBlocked) {\n                    newLenX = current.lenX;\n                    newLenY = current.lenY;\n                }\n                \n                if (rinBlocked && lenBlocked) continue;\n                \n                State nextState = new State(newRinX, newRinY, newLenX, newLenY, current.steps + 1);\n                String stateKey = getStateKey(nextState);\n                \n                if (!visited.contains(stateKey)) {\n                    queue.offer(nextState);\n                    visited.add(stateKey);\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    private boolean isValidMove(char[][] grid, int x, int y) {\n        return x >= 0 && x < grid.length && y >= 0 && y < grid[0].length && grid[x][y] != '#';\n    }\n    \n    private String getStateKey(State state) {\n        return state.rinX + \",\" + state.rinY + \",\" + state.lenX + \",\" + state.lenY;\n    }\n    \n    private class State {\n        int rinX, rinY, lenX, lenY, steps;\n        \n        State(int rinX, int rinY, int lenX, int lenY, int steps) {\n            this.rinX = rinX;\n            this.rinY = rinY;\n            this.lenX = lenX;\n            this.lenY = lenY;\n            this.steps = steps;\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:11:25"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_SIZE 100\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nbool visited[MAX_SIZE][MAX_SIZE][MAX_SIZE][MAX_SIZE];\nchar cave[MAX_SIZE][MAX_SIZE];\nint rows, cols;\n\nbool is_valid_move(Point a, Point b, int dir) {\n    Point next_a = {a.x + dx[dir], a.y + dy[dir]};\n    Point next_b = {b.x + dx[dir], b.y + dy[dir]};\n\n    bool a_blocked = next_a.x < 0 || next_a.x >= rows || next_a.y < 0 || next_a.y >= cols || \n                     cave[next_a.x][next_a.y] == '#';\n    bool b_blocked = next_b.x < 0 || next_b.x >= rows || next_b.y < 0 || next_b.y >= cols || \n                     cave[next_b.x][next_b.y] == '#';\n\n    if (a_blocked && b_blocked) return false;\n    if (a_blocked) next_a = a;\n    if (b_blocked) next_b = b;\n\n    return true;\n}\n\nbool solve(Point rin, Point len, Point dest_rin, Point dest_len) {\n    if (rin.x == dest_rin.x && rin.y == dest_rin.y && \n        len.x == dest_len.x && len.y == dest_len.y) \n        return true;\n\n    if (visited[rin.x][rin.y][len.x][len.y]) \n        return false;\n\n    visited[rin.x][rin.y][len.x][len.y] = true;\n\n    for (int dir = 0; dir < 4; dir++) {\n        if (is_valid_move(rin, len, dir)) {\n            Point next_rin = {rin.x + dx[dir], rin.y + dy[dir]};\n            Point next_len = {len.x + dx[dir], len.y + dy[dir]};\n\n            if (is_valid_move(rin, len, dir) && \n                solve(next_rin, next_len, dest_rin, dest_len)) \n                return true;\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    scanf(\"%d %d\", &rows, &cols);\n\n    Point rin, len, dest_rin, dest_len;\n    for (int i = 0; i < rows; i++) {\n        scanf(\"%s\", cave[i]);\n        for (int j = 0; j < cols; j++) {\n            if (cave[i][j] == 'R') {\n                rin.x = i;\n                rin.y = j;\n            }\n            if (cave[i][j] == 'L') {\n                len.x = i;\n                len.y = j;\n            }\n            if (cave[i][j] == 'D') {\n                dest_rin.x = i;\n                dest_rin.y = j;\n            }\n            if (cave[i][j] == 'E') {\n                dest_len.x = i;\n                dest_len.y = j;\n            }\n        }\n    }\n\n    memset(visited, 0, sizeof(visited));\n    \n    printf(\"%s\\n\", solve(rin, len, dest_rin, dest_len) ? \"YES\" : \"NO\");\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:11:37"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <unordered_set>\n\nusing namespace std;\n\nint dx[4] = {0, 0, 1, -1};\nint dy[4] = {1, -1, 0, 0};\n\nstruct State {\n    int x1, y1, x2, y2;\n    int steps;\n    \n    bool operator==(const State& other) const {\n        return x1 == other.x1 && y1 == other.y1 && \n               x2 == other.x2 && y2 == other.y2;\n    }\n};\n\nstruct StateHash {\n    size_t operator()(const State& state) const {\n        return hash<int>()(state.x1) ^ hash<int>()(state.y1) ^ \n               hash<int>()(state.x2) ^ hash<int>()(state.y2);\n    }\n};\n\nbool isValidMove(int x, int y, int n, int m, vector<vector<char>>& grid) {\n    return x >= 0 && x < n && y >= 0 && y < m && grid[x][y] != '#';\n}\n\nint solve(vector<vector<char>>& grid, pair<int,int> start1, pair<int,int> start2, \n          pair<int,int> end1, pair<int,int> end2) {\n    int n = grid.size(), m = grid[0].size();\n    \n    queue<State> q;\n    unordered_set<State, StateHash> visited;\n    \n    State initial = {start1.first, start1.second, start2.first, start2.second, 0};\n    q.push(initial);\n    visited.insert(initial);\n    \n    while (!q.empty()) {\n        State curr = q.front();\n        q.pop();\n        \n        if (curr.x1 == end1.first && curr.y1 == end1.second &&\n            curr.x2 == end2.first && curr.y2 == end2.second) {\n            return curr.steps;\n        }\n        \n        for (int d = 0; d < 4; d++) {\n            int nx1 = curr.x1 + dx[d], ny1 = curr.y1 + dy[d];\n            int nx2 = curr.x2 + dx[d], ny2 = curr.y2 + dy[d];\n            \n            bool valid1 = isValidMove(nx1, ny1, n, m, grid);\n            bool valid2 = isValidMove(nx2, ny2, n, m, grid);\n            \n            if (!valid1) {\n                nx1 = curr.x1;\n                ny1 = curr.y1;\n            }\n            \n            if (!valid2) {\n                nx2 = curr.x2;\n                ny2 = curr.y2;\n            }\n            \n            State next = {nx1, ny1, nx2, ny2, curr.steps + 1};\n            \n            if (visited.find(next) == visited.end()) {\n                q.push(next);\n                visited.insert(next);\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    vector<vector<char>> grid(n, vector<char>(m));\n    pair<int,int> start1, start2, end1, end2;\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> grid[i][j];\n            if (grid[i][j] == 'R') start1 = {i, j};\n            if (grid[i][j] == 'L') start2 = {i, j};\n            if (grid[i][j] == 'D') end1 = {i, j};\n            if (grid[i][j] == 'E') end2 = {i, j};\n        }\n    }\n    \n    int result = solve(grid, start1, start2, end1, end2);\n    \n    if (result == -1) {\n        cout << \"impossible\" << endl;\n    } else {\n        cout << result << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:11:50"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_unlock_door(cave, start1, start2, destination):\n    rows, cols = len(cave), len(cave[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    def is_valid(r, c):\n        return 0 <= r < rows and 0 <= c < cols and cave[r][c] != '#'\n    \n    from collections import deque\n    queue = deque([(start1, start2)])\n    visited = set()\n    visited.add((start1, start2))\n    \n    while queue:\n        (r1, c1), (r2, c2) = queue.popleft()\n        \n        if (r1, c1) == destination and (r2, c2) == destination:\n            return True\n\n        for dr, dc in directions:\n            nr1, nc1 = r1 + dr, c1 + dc\n            nr2, nc2 = r2 + dr, c2 + dc\n            \n            if not is_valid(nr1, nc1):\n                nr1, nc1 = r1, c1\n            if not is_valid(nr2, nc2):\n                nr2, nc2 = r2, c2\n                \n            if (nr1, nc1, nr2, nc2) not in visited:\n                visited.add((nr1, nc1, nr2, nc2))\n                queue.append(((nr1, nc1), (nr2, nc2)))\n    \n    return False",
    "timestamp": "2025-08-13 05:16:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\n\npublic class MirrorCaveTreasure {\n\n    private static final int[] DIR_X = {-1, 0, 1, 0}; // North, East, South, West\n    private static final int[] DIR_Y = {0, 1, 0, -1};\n\n    public boolean canUnlockTreasure(char[][] cave, int[] start1, int[] start2, int[] destination) {\n        int rows = cave.length;\n        int cols = cave[0].length;\n        \n        boolean[][][][] visited = new boolean[rows][cols][rows][cols];\n        Queue<int[]> queue = new LinkedList<>();\n        \n        queue.offer(new int[]{start1[0], start1[1], start2[0], start2[1]});\n        visited[start1[0]][start1[1]][start2[0]][start2[1]] = true;\n\n        while (!queue.isEmpty()) {\n            int[] positions = queue.poll();\n            int x1 = positions[0];\n            int y1 = positions[1];\n            int x2 = positions[2];\n            int y2 = positions[3];\n\n            if (x1 == destination[0] && y1 == destination[1] && x2 == destination[0] && y2 == destination[1]) {\n                return true;\n            }\n\n            for (int d = 0; d < 4; d++) {\n                int newX1 = x1 + DIR_X[d];\n                int newY1 = y1 + DIR_Y[d];\n                int newX2 = x2 + DIR_X[d];\n                int newY2 = y2 + DIR_Y[d];\n\n                if (isValidMove(cave, rows, cols, newX1, newY1)) {\n                    newX1 = x1;\n                    newY1 = y1;\n                }\n                if (isValidMove(cave, rows, cols, newX2, newY2)) {\n                    newX2 = x2;\n                    newY2 = y2;\n                }\n\n                if (!visited[newX1][newY1][newX2][newY2]) {\n                    visited[newX1][newY1][newX2][newY2] = true;\n                    queue.offer(new int[]{newX1, newY1, newX2, newY2});\n                }\n            }\n        }\n\n        return false;\n    }\n\n    private boolean isValidMove(char[][] cave, int rows, int cols, int x, int y) {\n        return x < 0 || x >= rows || y < 0 || y >= cols || cave[x][y] == '#';\n    }\n\n    public static void main(String[] args) {\n        char[][] cave = {\n            {'S', '.', '.', '#', '.'},\n            {'.', '#', '.', '.', '.'},\n            {'.', '.', '.', '#', '.'},\n            {'.', '#', '.', '.', 'D'},\n        };\n\n        int[] start1 = {0, 0};\n        int[] start2 = {0, 4};\n        int[] destination = {3, 4};\n\n        MirrorCaveTreasure mirrorCaveTreasure = new MirrorCaveTreasure();\n        System.out.println(mirrorCaveTreasure.canUnlockTreasure(cave, start1, start2, destination));\n    }\n}",
    "timestamp": "2025-08-13 05:16:50"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX 10\n#define EMPTY '.'\n#define WALL '#'\n\ntypedef struct {\n    int x, y;\n} Position;\n\nbool isValidMove(char cave[MAX][MAX], int n, Position pos) {\n    return pos.x >= 0 && pos.x < n && pos.y >= 0 && pos.y < n && cave[pos.x][pos.y] != WALL;\n}\n\nbool twinsCanUnlock(char cave[MAX][MAX], int n, Position rin, Position len, Position dest) {\n    if (rin.x == dest.x && rin.y == dest.y && len.x == dest.x && len.y == dest.y) {\n        return true;\n    }\n    if (cave[rin.x][rin.y] == WALL || cave[len.x][len.y] == WALL) {\n        return false;\n    }\n    \n    int directions[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    \n    for (int i = 0; i < 4; i++) {\n        Position nextRin = {rin.x + directions[i][0], rin.y + directions[i][1]};\n        Position nextLen = {len.x + directions[i][0], len.y + directions[i][1]};\n        \n        bool rinCanMove = isValidMove(cave, n, nextRin);\n        bool lenCanMove = isValidMove(cave, n, nextLen);\n\n        Position newRin = rinCanMove ? nextRin : rin;\n        Position newLen = lenCanMove ? nextLen : len;\n        \n        if (newRin.x == newLen.x && newRin.y == newLen.y &&\n            twinsCanUnlock(cave, n, newRin, newLen, dest)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nint main() {\n    int n = 5;\n    char cave[MAX][MAX] = {\n        {'.', '.', '.', '.', '.'},\n        {'.', '#', '#', '#', '.'},\n        {'.', '.', '.', '#', '.'},\n        {'#', '.', '.', '.', '.'},\n        {'.', '.', '.', '.', '.'}\n    };\n    \n    Position rin = {0, 0};\n    Position len = {0, 1};\n    Position dest = {4, 4};\n    \n    if (twinsCanUnlock(cave, n, rin, len, dest)) {\n        printf(\"The twins can unlock the door!\\n\");\n    } else {\n        printf(\"The twins cannot unlock the door.\\n\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 05:16:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List, Tuple\nfrom collections import deque\n\ndef can_reach_together(grid: List[List[str]], start_rin: Tuple[int, int], start_len: Tuple[int, int], \n                       goal: Tuple[int, int]) -> bool:\n    rows, cols = len(grid), len(grid[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set()\n    queue = deque([(start_rin, start_len)])\n\n    while queue:\n        pos_rin, pos_len = queue.popleft()\n\n        if pos_rin == goal and pos_len == goal:\n            return True\n\n        if (pos_rin, pos_len) in visited:\n            continue\n        visited.add((pos_rin, pos_len))\n\n        for dx, dy in directions:\n            new_rin_x, new_rin_y = pos_rin[0] + dx, pos_rin[1] + dy\n            new_len_x, new_len_y = pos_len[0] + dx, pos_len[1] + dy\n\n            # Check wall and grid boundaries\n            rin_blocked = (new_rin_x < 0 or new_rin_x >= rows or \n                           new_rin_y < 0 or new_rin_y >= cols or \n                           grid[new_rin_x][new_rin_y] == '#')\n            len_blocked = (new_len_x < 0 or new_len_x >= rows or \n                           new_len_y < 0 or new_len_y >= cols or \n                           grid[new_len_x][new_len_y] == '#')\n\n            # Adjust positions based on blocking\n            if rin_blocked and len_blocked:\n                continue\n            elif rin_blocked:\n                new_rin_x, new_rin_y = pos_rin\n            elif len_blocked:\n                new_len_x, new_len_y = pos_len\n\n            queue.append(((new_rin_x, new_rin_y), (new_len_x, new_len_y)))\n\n    return False",
    "timestamp": "2025-08-13 05:17:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef solve():\n    H, W = map(int, input().split())\n    grid = [input().strip() for _ in range(H)]\n    Rin_pos = None\n    Len_pos = None\n    target_pos = None\n    \n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'R':\n                Rin_pos = (i, j)\n            elif grid[i][j] == 'L':\n                Len_pos = (i, j)\n            elif grid[i][j] == 'T':\n                target_pos = (i, j)\n    \n    if not Rin_pos or not Len_pos or not target_pos:\n        print(\"No\")\n        return\n    \n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    visited = set()\n    q = deque()\n    q.append((Rin_pos[0], Rin_pos[1], Len_pos[0], Len_pos[1]))\n    visited.add((Rin_pos[0], Rin_pos[1], Len_pos[0], Len_pos[1]))\n    \n    while q:\n        r_i, r_j, l_i, l_j = q.popleft()\n        \n        if (r_i, r_j) == target_pos and (l_i, l_j) == target_pos:\n            print(\"Yes\")\n            return\n        \n        for dr, dc in directions:\n            new_r_i, new_r_j = r_i + dr, r_j + dc\n            new_l_i, new_l_j = l_i + dr, l_j - dc  # mirrored movement\n            \n            # Check Rin's new position\n            if 0 <= new_r_i < H and 0 <= new_r_j < W and grid[new_r_i][new_r_j] != '#':\n                pass  # Rin moves\n            else:\n                new_r_i, new_r_j = r_i, r_j  # Rin stays\n            \n            # Check Len's new position\n            if 0 <= new_l_i < H and 0 <= new_l_j < W and grid[new_l_i][new_l_j] != '#':\n                pass  # Len moves\n            else:\n                new_l_i, new_l_j = l_i, l_j  # Len stays\n            \n            if (new_r_i, new_r_j, new_l_i, new_l_j) not in visited:\n                visited.add((new_r_i, new_r_j, new_l_i, new_l_j))\n                q.append((new_r_i, new_r_j, new_l_i, new_l_j))\n    \n    print(\"No\")\n\nsolve()",
    "timestamp": "2025-08-13 05:17:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\nconst int DIRECTIONS = 4;\nconst int dx[DIRECTIONS] = {1, -1, 0, 0};\nconst int dy[DIRECTIONS] = {0, 0, 1, -1};\n\nstruct State {\n    int x1, y1, x2, y2;\n    State(int a1, int b1, int a2, int b2) : x1(a1), y1(b1), x2(a2), y2(b2) {}\n};\n\nbool isValid(int x, int y, int n, int m, const vector<vector<char>>& grid) {\n    return x >= 0 && x < n && y >= 0 && y < m && grid[x][y] != '#';\n}\n\nbool canUnlock(vector<vector<char>>& grid, int n, int m, int x1, int y1, int x2, int y2, int dx, int dy) {\n    queue<State> q;\n    q.emplace(x1, y1, x2, y2);\n    vector<vector<vector<vector<bool>>>> visited(n, vector<vector<vector<bool>>>(m, vector<vector<bool>>(n, vector<bool>(m, false))));\n    visited[x1][y1][x2][y2] = true;\n\n    while (!q.empty()) {\n        State cur = q.front(); q.pop();\n\n        if (cur.x1 == dx && cur.y1 == dy && cur.x2 == dx && cur.y2 == dy) return true;\n\n        for (int d = 0; d < DIRECTIONS; d++) {\n            int nx1 = cur.x1 + dx[d];\n            int ny1 = cur.y1 + dy[d];\n            if (!isValid(nx1, ny1, n, m, grid)) {\n                nx1 = cur.x1;\n                ny1 = cur.y1;\n            }\n\n            int nx2 = cur.x2 + dx[d];\n            int ny2 = cur.y2 + dy[d];\n            if (!isValid(nx2, ny2, n, m, grid)) {\n                nx2 = cur.x2;\n                ny2 = cur.y2;\n            }\n\n            if (!visited[nx1][ny1][nx2][ny2]) {\n                visited[nx1][ny1][nx2][ny2] = true;\n                q.emplace(nx1, ny1, nx2, ny2);\n            }\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<char>> grid(n, vector<char>(m));\n    int x1, y1, x2, y2, dx, dy;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            cin >> grid[i][j];\n            if (grid[i][j] == 'R') {\n                x1 = i;\n                y1 = j;\n            } else if (grid[i][j] == 'L') {\n                x2 = i;\n                y2 = j;\n            } else if (grid[i][j] == 'D') {\n                dx = i;\n                dy = j;\n            }\n        }\n    }\n\n    if (canUnlock(grid, n, m, x1, y1, x2, y2, dx, dy))\n        cout << \"Yes\" << endl;\n    else\n        cout << \"No\" << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:24:14"
  }
]