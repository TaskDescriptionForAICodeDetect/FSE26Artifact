[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<n; i++)\n\nconst int dx[2][4] = {{1, 0, -1, 0}, {1, 0, -1, 0}};\nconst int dy[2][4] = {{0, 1, 0, -1}, {0, -1, 0, 1}};\nconst int MAX_W = 55;\nconst int MAX_H = 55;\nchar maze[2][MAX_H][MAX_W+1];\nint sx[2], sy[2];\nint tx[2], ty[2];\nint h, w;\nbool used[MAX_H][MAX_W][MAX_H][MAX_W];\n\ninline bool check(int hx, int hy){ return 0 <= hx && hx < h && 0 <= hy && hy < w; }\n\nint main()\n{\n  while(cin >> w >> h, w){\n    rep(i, h) rep(j, w) rep(k, h) rep(l, w) used[i][j][k][l] = false;\n    rep(i, h){\n      rep(j, w) cin >> maze[0][i][j];\n      rep(j, w) cin >> maze[1][i][j];\n    }\n\n    rep(i, h) rep(j, w) if(maze[0][i][j] == 'L') sx[0] = i,  sy[0] = j;\n    rep(i, h) rep(j, w) if(maze[0][i][j] == '%') tx[0] = i,  ty[0] = j;\n    rep(i, h) rep(j, w) if(maze[1][i][j] == 'R') sx[1] = i,  sy[1] = j;\n    rep(i, h) rep(j, w) if(maze[1][i][j] == '%') tx[1] = i,  ty[1] = j;\n\n    stack<vector<int> > st;\n    vector<int> tmp(4);\n    tmp[0] = sx[0];\n    tmp[1] = sy[0];\n    tmp[2] = sx[1];\n    tmp[3] = sy[1];\n    st.push(tmp);\n    used[tmp[0]][tmp[1]][tmp[2]][tmp[3]] = true;\n    bool ok = false;\n    while(!st.empty()){\n      vector<int> h = st.top();  st.pop();\n      if(h[0] == tx[0] && h[1] == ty[0] && h[2] == tx[1] && h[3] == ty[1]){\n        ok = true;\n        break;\n      }\n      rep(k, 4){\n        int nx[2] = {h[0] + dx[0][k], h[2] + dx[1][k]};\n        int ny[2] = {h[1] + dy[0][k], h[3] + dy[1][k]};\n        if(!check(nx[0], ny[0]) && !check(nx[1], ny[1])) continue;\n        if((nx[0] == tx[0] && ny[0] == ty[0]) && (nx[1] != tx[1] || ny[1] != ty[1])) continue;\n        if((nx[0] != tx[0] || ny[0] != ty[0]) && (nx[1] == tx[1] && ny[1] == ty[1])) continue;\n        rep(i, 2){\n          if(check(nx[i], ny[i]) && maze[i][nx[i]][ny[i]] != '#'){\n            tmp[2*i] = nx[i];\n            tmp[2*i+1] = ny[i];\n          }\n          else{\n            tmp[2*i] = h[2*i];\n            tmp[2*i+1] = h[2*i+1];\n          }\n        }\n        if(h != tmp && !used[tmp[0]][tmp[1]][tmp[2]][tmp[3]]){\n          used[tmp[0]][tmp[1]][tmp[2]][tmp[3]] = true;\n          st.push(tmp);\n        }\n      }\n    }\n\n    puts(ok ? \"Yes\" : \"No\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<n; i++)\n\nconst int dx[2][4] = {{1, 0, -1, 0}, {1, 0, -1, 0}};\nconst int dy[2][4] = {{0, 1, 0, -1}, {0, -1, 0, 1}};\nconst int MAX_W = 55;\nconst int MAX_H = 55;\nchar maze[2][MAX_H][MAX_W+1];\nint sx[2], sy[2];\nint tx[2], ty[2];\nint h, w;\n\ninline bool check(int hx, int hy){ return 0 <= hx && hx < h && 0 <= hy && hy < w; }\n\nint main()\n{\n  while(cin >> w >> h, w){\n    rep(i, h){\n      rep(j, w) cin >> maze[0][i][j];\n      rep(j, w) cin >> maze[1][i][j];\n    }\n\n    rep(i, h) rep(j, w) if(maze[0][i][j] == 'L') sx[0] = i,  sy[0] = j;\n    rep(i, h) rep(j, w) if(maze[0][i][j] == '%') tx[0] = i,  ty[0] = j;\n    rep(i, h) rep(j, w) if(maze[1][i][j] == 'R') sx[1] = i,  sy[1] = j;\n    rep(i, h) rep(j, w) if(maze[1][i][j] == '%') tx[1] = i,  ty[1] = j;\n\n    stack<vector<int> > que;\n    vector<int> tmp(4);\n    tmp[0] = sx[0];\n    tmp[1] = sy[0];\n    tmp[2] = sx[1];\n    tmp[3] = sy[1];\n    que.push(tmp);\n    map<vector<int>, bool> used;\n    used[tmp] = true;\n    bool ok = false;\n    while(!que.empty()){\n      vector<int> h = que.top();  que.pop();\n      if(h[0] == tx[0] && h[1] == ty[0] && h[2] == tx[1] && h[3] == ty[1]){\n        ok = true;\n        break;\n      }\n      rep(k, 4){\n        int nx[2] = {h[0] + dx[0][k], h[2] + dx[1][k]};\n        int ny[2] = {h[1] + dy[0][k], h[3] + dy[1][k]};\n        if(!check(nx[0], ny[0]) && !check(nx[1], ny[1])) continue;\n        if((nx[0] == tx[0] && ny[0] == ty[0]) && (nx[1] != tx[1] || ny[1] != ty[1])) continue;\n        if((nx[0] != tx[0] || ny[0] != ty[0]) && (nx[1] == tx[1] && ny[1] == ty[1])) continue;\n        if(check(nx[0], ny[0]) && maze[0][nx[0]][ny[0]] != '#'){\n          tmp[0] = nx[0];\n          tmp[1] = ny[0];\n        }\n        else{\n          tmp[0] = h[0];\n          tmp[1] = h[1];\n        }\n        if(check(nx[1], ny[1]) && maze[1][nx[1]][ny[1]] != '#'){\n          tmp[2] = nx[1];\n          tmp[3] = ny[1];\n        }\n        else{\n          tmp[2] = h[2];\n          tmp[3] = h[3];\n        }\n        if(h != tmp && !used[tmp]){\n          used[tmp] = true;\n          que.push(tmp);\n        }\n      }\n    }\n\n    puts(ok ? \"Yes\" : \"No\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nstruct Node {\n  Node(int lx, int ly, int rx, int ry) {\n    this->lx = lx;\n    this->ly = ly;\n    this->rx = rx;\n    this->ry = ry;\n  }\n\n  int val() {\n    return lx * 8000000 + ly * 40000 + rx * 200 + ry;\n  }\n\n  int lx;\n  int ly;\n  int rx;\n  int ry;\n};\n\nint main() {\n  vector<vector<char> > f(103);\n  for (int i = 0; i < f.size(); i++) {\n    f[i].resize(52);\n  }\n\n  while (true) {\n    int W, H;\n    cin >> W >> H;\n\n    if (W == 0) {\n      break;\n    }\n\n    int cw = W + 1;\n    int w = W * 2 + 3;\n    int h = H + 2;\n    for (int i = 0; i < w; i++) {\n      f[i][0] = f[i][h - 1] = '#';\n    }\n    for (int i = 0; i < h; i++) {\n      f[0][i] = f[cw][i] = f[w - 1][i] = '#';\n    }\n\n    int lx = 0, ly = 0;\n    int rx = 0, ry = 0;\n    for (int i = 1; i < h - 1; i++) {\n      for (int j = 1; j < cw; j++) {\n\tcin >> f[j][i];\n\tif (f[j][i] == 'L') {\n\t  lx = j;\n\t  ly = i;\n\t  f[j][i] = '.';\n\t}\n      }\n      for (int j = cw + 1; j < w - 1; j++) {\n\tcin >> f[j][i];\n\tif (f[j][i] == 'R') {\n\t  rx = j;\n\t  ry = i;\n\t  f[j][i] = '.';\n\t}\n      }\n    }\n\n    set<int> s;\n    queue<Node> q;\n    q.push(Node(lx, ly, rx, ry));\n    while (!q.empty()) {\n      Node n = q.front();\n\n      if (f[n.lx][n.ly] == '%' && f[n.rx][n.ry] == '%') {\n\tcout << \"Yes\" << endl;\n\tbreak;\n      }\n      q.pop();\n\n      if (s.count(n.val()) != 0 ||\n\t  f[n.lx][n.ly] == '%' || f[n.rx][n.ry] == '%') {\n\tcontinue;\n      }\n      s.insert(n.val());\n\n      q.push(Node(n.lx, f[n.lx][n.ly - 1] != '#' ? n.ly - 1 : n.ly,\n\t\t  n.rx, f[n.rx][n.ry - 1] != '#' ? n.ry - 1 : n.ry));\n      q.push(Node(f[n.lx - 1][n.ly] != '#' ? n.lx - 1 : n.lx, n.ly,\n\t\t  f[n.rx + 1][n.ry] != '#' ? n.rx + 1 : n.rx, n.ry));\n      q.push(Node(f[n.lx + 1][n.ly] != '#' ? n.lx + 1 : n.lx, n.ly,\n\t\t  f[n.rx - 1][n.ry] != '#' ? n.rx - 1 : n.rx, n.ry));\n      q.push(Node(n.lx, f[n.lx][n.ly + 1] != '#' ? n.ly + 1 : n.ly,\n\t\t  n.rx, f[n.rx][n.ry + 1] != '#' ? n.ry + 1 : n.ry));\n    }\n\n    if (q.empty()) {\n      cout << \"No\" << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp make_pair\n#define pb push_back\n#define F first\n#define S second\n\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nbool app[50][50][50][50];\n\nmain(){\n  int w,h;\n  while(cin>>w>>h,w|h){\n    memset(app,0,sizeof(app));\n    string lr[h],rr[h];\n    rep(i,h){\n      cin>>lr[i]>>rr[i];\n    }\n\n    string ans=\"No\";\n    int rsx,rsy,lsx,lsy;\n    rep(i,h)rep(j,w){\n      if(lr[i][j]=='L')lsx=i,lsy=j;\n      if(rr[i][j]=='R')rsx=i,rsy=j;\n    }\n\n    queue<pair<PI,PI> > Q;\n    Q.push(mp(mp(lsx,lsy),mp(rsx,rsy)));\n\n    while(!Q.empty()){\n      PI tp=Q.front().F;\n      int clx,cly,crx,cry;\n      clx=tp.F,cly=tp.S;\n      tp=Q.front().S;Q.pop();\n      crx=tp.F,cry=tp.S;\n      if(lr[clx][cly]=='%' && rr[crx][cry]=='%'){\n        ans=\"Yes\";\n        break;\n      }\n      if(lr[clx][cly]=='%' || rr[crx][cry]=='%')continue;\n      \n      app[clx][cly][crx][cry]=true;\n\n      rep(i,4){\n        int nrx=crx+dx[i],nlx=clx+dx[i],nry=cry+dy[i],nly=cly-dy[i];\n        if(nrx<0 || nry<0 || nrx>=h || nry>=w)nrx=crx,nry=cry;\n        if(nlx<0 || nly<0 || nlx>=h || nly>=w)nlx=clx,nly=cly;\n        if(lr[nlx][nly]=='#'){\n          nlx=clx;\n          nly=cly;\n        }\n        if(rr[nrx][nry]=='#'){\n          nrx=crx;\n          nry=cry;\n        }\n        if(app[nlx][nly][nrx][nry])continue;\n        app[nlx][nly][nrx][nry]=true;\n        Q.push(mp(mp(nlx,nly),mp(nrx,nry)));\n      }\n/*      \n      rep(i,h){\n        rep(j,w){\n          if(clx==i && cly==j)cout<<'L';\n          else if(lr[i][j]=='L')cout<<'.';\n          else cout<<lr[i][j];\n        }\n        cout<<\" \";\n        rep(j,w){\n          if(crx==i && cry==j)cout<<'R';\n          else if(rr[i][j]=='R')cout<<'.';\n          else cout<<rr[i][j];\n        }\n        cout<<endl;\n      }\n      cout<<endl;\n*/\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,s,n) for(int i=s; i<n; i++)\n#define ALL(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nint w, h;\nint rooml[52][52], roomr[52][52];\nbool memo[52][52][52][52];\n\nbool dfs(int xl, int yl, int xr, int yr) {\n\tif( memo[xl][yl][xr][yr] ) {\n\t\treturn false;\n\t}\n\tmemo[xl][yl][xr][yr] = true;\n\tconst int dx[4] = {-1, 0, 1, 0};\n\tconst int dy[4] = {0, 1, 0, -1};\n\trep(i, 4) {\n\t\tint nxl = xl + dx[i];\n\t\tint nyl = yl + dy[i];\n\t\tint nxr = xr + dx[i]*-1;\n\t\tint nyr = yr + dy[i];\n\t\tint nl = rooml[nyl][nxl];\n\t\tint nr = roomr[nyr][nxr];\n\t\tif( nl==2 && nr==2 ) {\n\t\t\treturn true;\n\t\t}\n\t\telse if( nl==1 && nr==1 ) {\n\t\t\tbool f = dfs(nxl, nyl, nxr, nyr);\n\t\t\tif(f) return true;\n\t\t}\n\t\telse if( nl==1 && nr==0 ) {\n\t\t\tbool f = dfs(nxl, nyl, xr, yr);\n\t\t\tif(f) return true;\n\t\t}\n\t\telse if( nl==0 && nr==1 ) {\n\t\t\tbool f = dfs(xl, yl, nxr, nyr);\n\t\t\tif(f) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\twhile(cin >> w >> h, w||h) {\n\t\tmemset(rooml, 0, sizeof(rooml));\n\t\tmemset(roomr, 0, sizeof(roomr));\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tint xl, yl, xr, yr;\n\t\trep(y, h) {\n\t\t\tstring sl, sr;\n\t\t\tcin >> sl >> sr;\n\t\t\trep(x, w) {\n\t\t\t\tif(sl[x] == 'L') {\n\t\t\t\t\txl = x+1;\n\t\t\t\t\tyl = y+1;\n\t\t\t\t\trooml[y+1][x+1] = 1;\n\t\t\t\t} else {\n\t\t\t\t\trooml[y+1][x+1] = (sl[x]=='%' ? 2 : (sl[x]=='.' ? 1 : 0));\n\t\t\t\t}\n\t\t\t\tif(sr[x] == 'R') {\n\t\t\t\t\txr = x+1;\n\t\t\t\t\tyr = y+1;\n\t\t\t\t\troomr[y+1][x+1] = 1;\n\t\t\t\t} else {\n\t\t\t\t\troomr[y+1][x+1] = (sr[x]=='%' ? 2 : (sr[x]=='.' ? 1 : 0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( dfs(xl, yl, xr, yr) ) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t} else {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nint W, H;\nstruct pos\n{\n\tint x, y, dis;\n};\nint main() {\n\n\twhile (cin >> W >> H, W | H){\n\t\tvector<string> vsl;\n\t\tvector<string> vsr;\n\t\tREP(i, H){\n\t\t\tstring l;\n\t\t\tstring r;\n\t\t\tcin >> l >> r;\n\t\t\tvsl.push_back(l);\n\t\t\tvsr.push_back(r);\n\t\t}\n\t\tvector<vector<int>> vvil(H);\n\t\tvector<vector<int>> vvir(H);\n\t\tint glx;\n\t\tint gly;\n\t\tint grx;\n\t\tint gry;\n\t\tint lx;\n\t\tint ly;\n\t\tint rx;\n\t\tint ry;\n\t\tREP(i, H){\n\t\t\tREP(j, W){\n\t\t\t\tif (vsl[i][j] == '#')vvil[i].push_back(-1);\n\t\t\t\telse vvil[i].push_back(9999);\n\n\t\t\t\tif (vsr[i][j] == '#')vvir[i].push_back(-1);\n\t\t\t\telse vvir[i].push_back(9999);\n\n\t\t\t\tif (vsl[i][j] == 'L'){\n\t\t\t\t\tlx = j;\n\t\t\t\t\tly = i;\n\t\t\t\t}\n\t\t\t\tif (vsr[i][j] == 'R'){\n\t\t\t\t\trx = j;\n\t\t\t\t\try = i;\n\t\t\t\t}\n\t\t\t\tif (vsl[i][j] == '%'){\n\t\t\t\t\tglx = j;\n\t\t\t\t\tgly = i;\n\t\t\t\t}\n\t\t\t\tif (vsr[i][j] == '%'){\n\t\t\t\t\tgrx = j;\n\t\t\t\t\tgry = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<pos> vp;\n\t\tvp.push_back({ glx, gly, 0 });\n\t\tvvil[gly][glx] = 0;\n\t\twhile (!vp.empty()){\n\t\t\tpos p = vp[0];\n\t\t\tvp.erase(vp.begin());\n\t\t\tREP(i, 4){\n\t\t\t\tif (p.x + dx[i] >= 0 && p.x + dx[i] < W&&p.y + dy[i] >= 0 && p.y + dy[i] < H&& vvil[p.y + dy[i]][p.x + dx[i]] != -1 && vvil[p.y + dy[i]][p.x + dx[i]] == 9999){\n\t\t\t\t\tvp.push_back({ p.x + dx[i], p.y + dy[i], p.dis + 1 });\n\t\t\t\t\tvvil[p.y + dy[i]][p.x + dx[i]] = p.dis + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvp.push_back({ grx, gry, 0 });\n\t\tvvir[gry][grx] = 0;\n\t\twhile (!vp.empty()){\n\t\t\tpos p = vp[0];\n\t\t\tvp.erase(vp.begin());\n\t\t\tREP(i, 4){\n\t\t\t\tif (p.x + dx[i] >= 0 && p.x + dx[i] < W&&p.y + dy[i] >= 0 && p.y + dy[i] < H&& vvir[p.y + dy[i]][p.x + dx[i]] != -1 && vvir[p.y + dy[i]][p.x + dx[i]] == 9999){\n\t\t\t\t\tvp.push_back({ p.x + dx[i], p.y + dy[i], p.dis + 1 });\n\t\t\t\t\tvvir[p.y + dy[i]][p.x + dx[i]] = p.dis + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<int> vi;\n\t\tvi.push_back(lx * 1000000 + ly * 10000 + rx * 100 + ry);\n\t\tint count = 0;\n\t\tint pcount = 1;\n\t\tbool clear = false;\n\t\twhile (1){\n\t\t\tif (vvil[ly][lx] == 9999 || vvir[ry][rx] == 9999)break;\n\t\t\t/*if (vi[count] == glx * 1000000 + gly * 10000 + grx * 100 + gry){\n\t\t\t\tclear = true;\n\t\t\t\tbreak;\n\t\t\t\t}*/\n\t\t\tint lx2 = vi[count] / 1000000 % 100;\n\t\t\tint ly2 = vi[count] / 10000 % 100;\n\t\t\tint rx2 = vi[count] / 100 % 100;\n\t\t\tint ry2 = vi[count] % 100;\n\n\t\t\tREP(i, 4){\n\t\t\t\tint lx3 = lx2;\n\t\t\t\tint ly3 = ly2;\n\t\t\t\tint rx3 = rx2;\n\t\t\t\tint ry3 = ry2;\n\t\t\t\tif (dx[i] != 0 && lx3 + dx[i] >= 0 && lx3 + dx[i] < W && vsl[ly3 + dy[i]][lx3 + dx[i]] != '#')lx3 += dx[i];\n\t\t\t\tif (dy[i] != 0 && ly3 + dy[i] >= 0 && ly3 + dy[i] < H && vsl[ly3 + dy[i]][lx3 + dx[i]] != '#')ly3 += dy[i];\n\t\t\t\tif (dx[i] != 0 && rx3 - dx[i] >= 0 && rx3 - dx[i] < W && vsr[ry3 + dy[i]][rx3 - dx[i]] != '#')rx3 -= dx[i];\n\t\t\t\tif (dy[i] != 0 && ry3 + dy[i] >= 0 && ry3 + dy[i] < H && vsr[ry3 + dy[i]][rx3 - dx[i]] != '#')ry3 += dy[i];\n\t\t\t\tif (find(vi.begin(), vi.end(), lx3 * 1000000 + ly3 * 10000 + rx3 * 100 + ry3) == vi.end() && vvil[ly3][lx3] != 0 && vvir[ry3][rx3] != 0)vi.push_back(lx3 * 1000000 + ly3 * 10000 + rx3 * 100 + ry3);\n\t\t\t\tif (lx3 == glx&&ly3 == gly&&rx3 == grx&&ry3 == gry)clear = true;\n\t\t\t}\n\t\t\tif (clear)break;\n\t\t\tif (count + 1 == vi.size())break;\n\t\t\tint min = 10000;\n\t\t\tint i2 = 0;\n\n\t\t\tFOR(i, count + 1, vi.size()){\n\t\t\t\tif (vvil[(vi[i] / 10000 % 100)][(vi[i] / 1000000 % 100)] + vvir[(vi[i] % 100)][(vi[i] / 100 % 100)] < min){\n\t\t\t\t\tmin = vvil[(vi[i] / 10000 % 100)][(vi[i] / 1000000 % 100)] + vvir[(vi[i] % 100)][(vi[i] / 100 % 100)];\n\t\t\t\t\ti2 = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (vvil[ly2][lx2]<vvil[(vi[i2] / 10000 % 100)][(vi[i2] / 1000000 % 100)] && vvir[ry2][rx2]<vvir[(vi[i2] % 100)][(vi[i2] / 100 % 100)])break;\n\t\t\tswap(vi[count + 1], vi[i2]);\n\n\t\t\tcount++;\n\t\t}\n\n\t\tif (clear)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<queue>\n#define MAX 50\nusing namespace std;\nstruct Point{int x,y;};\nstruct P{\n  Point l,r;\n  int cost;\n  bool operator<(const P &a)const{\n    return (l.x==a.l.x?\n\t    (l.y==a.l.y?\n\t     (r.x==a.r.x?\n\t      (r.y<a.r.y):r.x<a.r.x)\n\t     :l.y<a.l.y)\n\t    :l.x<a.l.x);\n  }\n};\nint main(){\n  int w,h;\n  while(cin>>w>>h,w||h){\n    int i,j,k;\n    int inf = 1<<20;\n    \n    bool d[MAX+1][MAX+1][MAX+1][MAX+1];\n    fill(d[0][0][0],d[MAX][MAX][MAX],0);\n    \n    //map<P,int> m;\n    string sr[60],sl[60];\n    for(i=0;i<h;i++){\n      cin >> sl[i] >> sr[i];\n    }\n    \n    Point pr,pl,br,bl;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(sl[i][j]=='L'){\n\t  pl.x=j;pl.y=i;\n\t}\n\tif(sr[i][j]=='R'){\n\t  pr.x=j;pr.y=i;\n\t}\n      }\n    }\n    //cout << pl.x << \":\" << pl.y << endl;\n    //cout << pr.x << \":\" << pr.y << endl;\n    //d[pl.x][pl.y][pr.x][pr.y]=\n    P p,b;\n    p.r=pr;\n    p.l=pl;\n    p.cost=0;\n    //m[p]=p.cost;\n    queue<P> q;\n    q.push(p);\n    bool f = false;\n    while(!q.empty()){\n      p=q.front();q.pop();\n      pl=p.l;pr=p.r;\n      /*\n      if(m.find(p)!=m.end())\n\tif(p.cost>m[p]) continue;\n      m[p]=p.cost;\n      */\n      if(d[pl.x][pl.y][pr.x][pr.y]) continue;\n      d[pl.x][pl.y][pr.x][pr.y]=true;\n      \n      //cout << pl.x<<\":\"<<pl.y<<\":\"<<pr.x<<\":\"<<pr.y<<\"/\"<<p.cost<<endl;\n      if(sl[pl.y][pl.x]=='%'&&sr[pr.y][pr.x]=='%'){\n\tf=true;\n\tbreak;\n      }else if(sl[pl.y][pl.x]=='%') continue;\n      else if(sr[pr.y][pr.x]=='%') continue;\n      \n      p.cost++;\n      int lx[]={1,-1,0,0};int ly[]={0,0,1,-1};\n      int rx[]={-1,1,0,0};int ry[]={0,0,1,-1};\n      for(i=0;i<4;i++){\n\tbl=pl;br=pr;\n\tbl.x+=lx[i];bl.y+=ly[i];\n\tbr.x+=rx[i];br.y+=ry[i];\n\n\t//cout << bl.x<<\":\"<<bl.y<<\":\"<<br.x<<\":\"<<br.y<<\"/\"<<p.cost<<endl;\n\t\n\tif(bl.x<0) bl.x=0;\n\telse if(bl.x>=w) bl.x=w-1;\n\tif(bl.y<0) bl.y=0;\n\telse if(bl.y>=h) bl.y=h-1;\n\n\tif(br.x<0) br.x=0;\n\telse if(br.x>=w) br.x=w-1;\n\tif(br.y<0) br.y=0;\n\telse if(br.y>=h) br.y=h-1;\n\n\tif(sl[bl.y][bl.x]=='#'){\n\t  bl.x-=lx[i];bl.y-=ly[i];\n\t}\n\tif(sr[br.y][br.x]=='#'){\n\t  br.x-=rx[i];br.y-=ry[i];\n\t}\n\tp.r=br;p.l=bl;\n\tq.push(p);\n\t//m[p]=p.cost;\n      }\n    }\n    if(f) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nstring RenR[50],LinR[50];\nbool memo[50][50][50][50];\nstring ans;\nint h,w;\n//         l r d u\nint Rx[4]={0,0,1,-1};\nint Ry[4]={1,-1,0,0};\n//         r l d u\nint Lx[4]={0,0,1,-1};\nint Ly[4]={-1,1,0,0};\n\n\nvoid move(int muki,int ri,int rj,int li,int lj)\n{\n  int ra=ri+Rx[muki],rb=rj+Ry[muki];\n  if(0<=ra && 0<=rb && ra<h && rb<w){\n    if(RenR[ra][rb]!='#'){\n      ri=ra;\n      rj=rb;\n    }\n  }\n  int la=li+Lx[muki],lb=lj+Ly[muki];\n  if(0<=la && 0<=lb && la<h && lb<w){\n    if(LinR[la][lb]!='#'){\n      li=la;\n      lj=lb;\n    }\n  }\n  if(memo[li][lj][ri][rj])return;\n\n  memo[li][lj][ri][rj]=true;\n\n  if(RenR[ri][rj]=='%' && LinR[li][lj]=='%'){\n    ans=\"Yes\";\n    return;\n  }\n  if(RenR[ri][rj]=='%' || LinR[li][lj]=='%')return;\n\n  for(int k=0;k<4;k++){\n    move(k,ri,rj,li,lj);\n    if(ans==\"Yes\")break;\n  }\n  return;\n}\n\nint main()\n{\n  int ri,rj,li,lj;\n  while(1){\n    cin>>w>>h;\n    if(w+h==0)break;\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tfor(int k=0;k<h;k++){\n\t  for(int l=0;l<w;l++)memo[i][j][k][l]=false;\n\t}\n      }\n    }\n\n    for(int i=0;i<h;i++){\n      cin>>LinR[i];\n      for(int j=0;j<w;j++){\n\tif(LinR[i][j]=='L'){\n\t  li=i;lj=j;\n\t  break;\n\t}\n      }\n      cin>>RenR[i];\n      for(int j=0;j<w;j++){\n\tif(RenR[i][j]=='R'){\n\t  ri=i;rj=j;\n\t  break;\n\t}\n      }\n    }\n    ans=\"No\";\n    memo[li][lj][ri][rj]=true;\n    for(int i=0;i<4;i++){\n      move(i,ri,rj,li,lj);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint w, h;\nchar l[52][52], r[52][52];\nint ldx[4] = {1, 0, -1, 0};\nint ldy[4] = {0, 1, 0, -1};\nint rdx[4] = {1, 0, -1, 0};\nint rdy[4] = {0, -1, 0, 1};\nint lsx, lsy, rsx, rsy, lgx, lgy, rgx, rgy;\nbool lischecked[52][52], rischecked[52][52];\n\nbool solve(int lx, int ly, int rx, int ry){\n    if(lx == lgx && ly == lgy && rx == rgx && ry == rgy) return true;\n    if((lx == lgx && ly == lgy) || (rx == rgx && ry == rgy)) return false;\n    for(int i = 0; i < 4; i++){\n        int nlx = lx + ldx[i], nly = ly + ldy[i];\n        int nrx = rx + rdx[i], nry = ry + rdy[i];\n        if((nlx < 0 || nly < 0 || nlx >= h || nly >= w) && (nrx < 0 || nry < 0 || nrx >= h || nry >= w)) continue;\n        if((l[nlx][nly] == '#' && r[nrx][nry] == '#') || (lischecked[nlx][nly] && rischecked[nrx][nry])) continue;\n        if(nlx < 0 || nlx >= h || nly < 0 || nly >= w || l[nlx][nly] == '#'){\n            nlx = lx;\n            nly = ly;\n        }\n        if(nrx < 0 || nrx >= h || nry < 0 || nry >= w || r[nrx][nry] == '#'){\n            nrx = rx;\n            nry = ry;\n        }\n        lischecked[nlx][nly] = true;\n        rischecked[nrx][nry] = true;\n        if(solve(nlx, nly, nrx, nry)) return true;\n        lischecked[nlx][nly] = false;\n        rischecked[nrx][nry] = false;\n    }\n    return false;\n}\n\nint main()\n{\n    while(1){\n        cin >> w >> h;\n        if(w == 0 && h == 0) break;\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin >> l[i][j];\n            }\n            for(int j = 0; j < w; j++){\n                cin >> r[i][j];\n            }\n        }\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                lischecked[i][j] = false;\n                rischecked[i][j] = false;\n                if(l[i][j] == 'L'){\n                    lsx = i;\n                    lsy = j;\n                }\n                if(l[i][j] == '%'){\n                    lgx = i;\n                    lgy = j;\n                }\n                if(r[i][j] == 'R'){\n                    rsx = i;\n                    rsy = j;\n                }\n                if(r[i][j] == '%'){\n                    rgx = i;\n                    rgy = j;\n                }\n            }\n        }\n        lischecked[lsx][lsy] = true;\n        rischecked[rsx][rsy] = true;\n        if(solve(lsx, lsy, rsx, rsy)) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nstruct state{\n\tint lw,lh,rw,rh;\n\tint dist;\n};\n\nint w,h;\nstring bl[55],br[55];\nint slw,slh,srw,srh;\nint glw,glh,grw,grh;\n\nint d[55][55][55][55];\n\nint dd[]={-1,0,1,0,-1};\n\nint main(){\n\tcin.sync_with_stdio(false);\n\twhile(1){\n\t\tcin>>w>>h;\n\t\tif(w==0)break;\n\t\trep(i,h)cin>>bl[i]>>br[i];\n\t\trep(i,h)rep(j,w){\n\t\t\tif(bl[i][j]=='L'){\n\t\t\t\tslw=j; slh=i;\n\t\t\t}\n\t\t\tif(br[i][j]=='R'){\n\t\t\t\tsrw=j; srh=i;\n\t\t\t}\n\t\t\tif(bl[i][j]=='%'){\n\t\t\t\tglw=j; glh=i;\n\t\t\t}\n\t\t\tif(br[i][j]=='%'){\n\t\t\t\tgrw=j; grh=i;\n\t\t\t}\n\t\t}\n\t\tbool ok=false;\n\t\tqueue<state> que;\n\t\tque.push((state){slw,slh,srw,srh,0});\n\t\trep(a,55)rep(b,55)rep(c,55)rep(e,55)d[a][b][c][e]=INF;\n\t\twhile(!que.empty()){\n\t\t\tstate ns=que.front(); que.pop();\n\t\t\tint w1=ns.lw,h1=ns.lh,w2=ns.rw,h2=ns.rh;\n\t\t\tif(d[w1][h1][w2][h2]!=INF)continue;\n\t\t\tif(w1==glw&&h1==glh&&w2==grw&&h2==grh){\n\t\t\t\tok=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//dbg(w1); dbg(h1); dbg(w2); dbg(h2);\n\t\t\t//cout<<endl;\n\t\t\tif((w1==glw&&h1==glh)||(w2==grw&&h2==grh))continue;\n\t\t\td[w1][h1][w2][h2]=ns.dist;\n\t\t\trep(di,4){\n\t\t\t\tint nw1=w1+dd[di],nh1=h1+dd[di+1];\n\t\t\t\tif(nw1>=0&&nw1<w&&nh1>=0&&nh1<h&&bl[nh1][nw1]!='#'){\n\t\t\t\t\tint nw2=w2-dd[di],nh2=h2+dd[di+1];\n\t\t\t\t\tif(nw2<0||nw2>=w||nh2<0||nh2>=h||br[nh2][nw2]=='#'){\n\t\t\t\t\t\tnw2+=dd[di];\n\t\t\t\t\t\tnh2-=dd[di+1];\n\t\t\t\t\t}\n\t\t\t\t\tque.push((state){nw1,nh1,nw2,nh2,ns.dist+1});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ok)cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef pair< int, int > Pi;\n\nbool used[50][50][50][50];\nchar masL[50][50], masR[50][50];\nint W, H;\nPi RinS, LenS; //スタート\nconst int dy[] = { 1, 0, -1, 0}, dx[] = { 0, 1, 0, -1};\n\nbool isover(int y, int x){\n  return y < 0 || y >= H || x < 0 || x >= W;\n}\n\nint bfs(){\n  queue< Pi > Rin, Len;\n  Rin.push(RinS);\n  Len.push(LenS);\n  used[RinS.first][RinS.second][LenS.first][LenS.second] = true;\n  while(!Rin.empty()){\n    Pi r = Rin.front(), l = Len.front();\n    Rin.pop(), Len.pop();\n    if(masL[l.first][l.second] == '%' && masR[r.first][r.second] == '%'){\n      return true;\n    }\n    if(masL[l.first][l.second] != '%' && masR[r.first][r.second] != '%'){\n      for(int i = 0; i < 4; i++){\n        int rny = min( H - 1, max( 0, r.first + dy[i]));\n        int rnx = min( W - 1, max( 0, r.second + dx[i]));\n        int lny = min( H - 1, max( 0, l.first + dy[i]));\n        int lnx = min( W - 1, max( 0, r.second - dx[i]));\n        //めんどい\n        if(masR[lny][lnx] == '#'){ //元の位置に戻す！！\n          lny = l.first, lnx = l.second;\n        }\n        if(masL[rny][rnx] == '#'){\n          rny = r.first, rnx = r.second;\n        }\n        \n        if(!used[rny][rnx][lny][lnx]){\n          used[rny][rnx][lny][lnx] = true;\n          Rin.push( Pi( rny, rnx)), Len.push( Pi( lny, lnx));\n        }\n      }\n    }\n  }\n  return false; //いけない!!\n}\nint main()\n{\n  while(cin >> W >> H, W){\n    memset( used, false, sizeof(used));\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n        cin >> masL[i][j];\n        if(masL[i][j] == 'L'){\n          LenS = Pi( i, j);\n          masL[i][j] = '.';\n        }\n      }\n      for(int j = 0; j < W; j++){\n        cin >> masR[i][j];\n        if(masR[i][j] == 'R'){\n          RinS = Pi( i, j);\n          masR[i][j] = '.';\n        }\n      }\n    }\n    bool judge = bfs();\n    if(!judge) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i < n; i++)\n\ntypedef pair<int,int> PII;\n\nint di0[] = {0,0,1,-1};\nint dj0[] = {-1,1,0,0};\n\nint di1[] = {0,0,1,-1};\nint dj1[] = {1,-1,0,0};\n\nvoid solve(int h, int w){\n    string b1[h];\n    string b2[h];\n    rep(i,h){\n        cin >> b1[i] >>  b2[i];\n    }\n    int si1=0,si2=0,sj1=0,sj2=0;\n    int gi1 = 0,gi2 = 0, gj1 = 0, gj2 = 0;\n    rep(i,h)rep(j,w){\n            if(b1[i][j] == 'L'){\n                si1 = i;\n                sj1 = j;\n            }\n            if(b1[i][j] == '%'){\n                gi1 = i;\n                gj1 = j;\n            }\n            if(b2[i][j] == '%'){\n                gi2 = i;\n                gj2 = j;\n            }\n            if(b2[i][j] == 'R'){\n                si2 = i;\n                sj2 = j;\n            }\n        }\n    bool mp[50][50][50][50];\n    memset(mp,false,sizeof(mp));\n    deque<pair<PII,PII>> que;\n    que.push_back({{si1,sj1},{si2,sj2}});\n    mp[si1][sj1][si2][sj2] = true;\n\n    while(! que.empty()){\n        if(mp[gi1][gj1][gi2][gj2]) {\n            cout << \"Yes\" << endl;\n            return;\n        }\n        pair<PII,PII> p = que.front();\n        que.pop_front();\n        int ci[2],cj[2];\n\n        ci[0] = p.first.first;\n        cj[0] = p.first.second;\n\n        ci[1] = p.second.first;\n        cj[1] = p.second.second;\n\n        rep(dir,4){\n            int ni[2],nj[2];\n            ni[0] = ci[0] + di0[dir];\n            nj[0] = cj[0] + dj0[dir];\n\n            ni[1] = ci[1] + di1[dir];\n            nj[1] = cj[1] + dj1[dir];\n\n\n            rep(i,2) if(ni[i] < 0) ni[i] = 0;\n            rep(i,2) if(ni[i] >= h) ni[i] = h-1;\n            rep(i,2) if(nj[i] < 0) nj[i] = 0;\n            rep(i,2) if(nj[i] >= w) nj[i] = w-1;\n            if(b1[ni[0]][nj[0]] == '#') {\n                ni[0] = ci[0];\n                nj[0] = cj[0];\n            }\n            if(b2[ni[1]][nj[1]] == '#') {\n                ni[1] = ci[1];\n                nj[1] = cj[1];\n            }\n            bool flag1 = (ni[0] == gi1 && gj1 == nj[0] );\n            bool flag2 = (ni[1] == gi2 && nj[1] == gj2);\n            if(mp[ni[0]][nj[0]][ni[1]][nj[1]] == false && !(flag1 ^ flag2)) {\n                que.push_back({{ni[0], nj[0]},\n                               {ni[1], nj[1]}});\n                mp[ni[0]][nj[0]][ni[1]][nj[1]] = true;\n            }\n\n        }\n    }\n\n\n\n    cout << \"No\" << endl;\n}\nint main(){\n    int w,h;\n    while(true){\n        cin  >> w >> h;\n        if(h == 0 && w == 0) break;\n        solve(h,w);\n\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint W,H;\nchar fie[2][55][55];\n\nbool used[55][55][55][55];\nint dx[2][4]={\n  {0,1,0,-1},\n  {0,-1,0,1}\n};\nint dy[]={1,0,-1,0};\n\nvoid move(int &x,int &y,int id,int rl){\n  int nx = x + dx[rl][id];\n  int ny = y + dy[id];\n  if( nx < 0 || ny < 0 || nx >= W || ny >= H ) return;\n  if( fie[rl][nx][ny] == '#' ) return;\n  x = nx; y = ny;\n}\n\nbool solve(int lx,int ly,int rx,int ry){\n  if( used[lx][ly][rx][ry] ) return false;\n  used[lx][ly][rx][ry] = true;\n  if( fie[0][lx][ly] == '%' && fie[1][rx][ry] == '%' ) return true;\n  if( fie[0][lx][ly] == '%' || fie[1][rx][ry] == '%' ) return false;\n  for(int i=0;i<4;i++){\n    int nlx = lx, nly = ly, nrx = rx, nry = ry;\n    move(nlx,nly,i,0);\n    move(nrx,nry,i,1);\n    if( used[nlx][nly][nrx][nry] ) continue;\n    if( solve(nlx,nly,nrx,nry) ) return true;\n  }\n  return false;\n}\n\nint main(){\n  while( cin >> W >> H && (W||H) ){\n    int lx,ly,rx,ry;\n    memset(used,0,sizeof(used));\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tcin >> fie[0][j][i];\n\tif( fie[0][j][i] == 'L' || fie[0][j][i] == 'R' ){\n\t  lx=j; ly=i;\n\t}\n      }\n      for(int j=0;j<W;j++){\n\tcin >> fie[1][j][i];\n\tif( fie[1][j][i] == 'L' || fie[1][j][i] == 'R' ){\n\t  rx=j; ry=i;\n\t}\n      }\n    }\n    if( solve(lx,ly,rx,ry) ) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<char,char> P;\n\nstruct state{\n\tP p1, p2;\n\tstate(P p1_, P p2_){ p1 = p1_; p2 = p2_; }\n};\nint w, h;\nint dx1[4] = {0,-1,1,0};\nint dy1[4] = {-1,0,0,1};\nint dx2[4] = {0,1,-1,0};\nint dy2[4] = {-1,0,0,1};\nbool flag[51][51][51][51];\nchar L[51][51];\nchar R[51][51];\n\nvoid init(){\n\tfor(int i=0 ; i < 51 ; i++ ){\n\t\tfor(int j=0 ; j < 51 ; j++ ){\n\t\t\tfor(int k=0 ; k < 51 ; k++ ){\n\t\t\t\tfor(int l=0 ; l < 51 ; l++ ){\n\t\t\t\t\tflag[i][j][k][l] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// デバッグ用\nvoid debug(){\n\tcout << \"[Left]\" << endl;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tcout << L[y][x];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n\tcout << \"[right]\" << endl;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tcout << R[y][x];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// R[y][x] == 'R' となる (x,y) を返す\nP R_search(){\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( R[y][x] == 'R' ){\n\t\t\t\tR[y][x] = '.';\n\t\t\t\treturn P(x,y);\n\t\t\t}\n\t\t}\n\t}\n\treturn P(0,0);\n}\n\n// L[y][x] == 'L' となる (x,y) を返す\nP L_search(){\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( L[y][x] == 'L' ){\n\t\t\t\tL[y][x] = '.';\n\t\t\t\treturn P(x,y);\n\t\t\t}\n\t\t}\n\t}\n\treturn P(0,0);\n}\n\nbool bfs(){\n\tP ls = L_search();\n\tP rs = R_search();\n\t\n\tqueue< pair<P,P> > q;\n\tpair<P,P> s( ls , rs );\n\tq.push( s );\n\t\n\twhile( !q.empty() && q.size() < 1000000 ){\n\t\tpair<P,P> now = q.front(); q.pop();\n\t\tint x1 = now.first.first;\n\t\tint y1 = now.first.second;\n\t\tint x2 = now.second.first;\n\t\tint y2 = now.second.second;\n\t\tflag[y1][x1][y2][x2] = true;\n\t\tif( L[y1][x1] == '%' && R[y2][x2] == '%' ){\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\tint mx1 = x1 + dx1[i];\n\t\t\tint my1 = y1 + dy1[i];\n\t\t\tif( mx1 < 0 || my1 < 0 || mx1 >= w || my1 >= h || L[my1][mx1] == '#' ){\n\t\t\t\tmx1 = x1;\n\t\t\t\tmy1 = y1;\n\t\t\t}\n\t\t\tint mx2 = x2 + dx2[i];\n\t\t\tint my2 = y2 + dy2[i];\n\t\t\tif( mx2 < 0 || my2 < 0 || mx2 >= w || my2 >= h || R[my2][mx2] == '#' ){\n\t\t\t\tmx2 = x2;\n\t\t\t\tmy2 = y2;\n\t\t\t}\n\t\t\tP p1(mx1,my1);\n\t\t\tP p2(mx2,my2);\n\t\t\tpair<P,P> next(p1,p2);\n\t\t\tif( flag[my1][mx1][my2][mx2] ){\n\t\t\t\tcontinue;\n\t\t\t}else if( L[my1][mx1] == '%' && R[my2][mx2] != '%' ){\n\t\t\t\tflag[my1][mx1][my2][mx2] = true;\n\t\t\t}else if( L[my1][mx1] != '%' && R[my2][mx2] == '%' ){\n\t\t\t\tflag[my1][mx1][my2][mx2] = true;\n\t\t\t}else{\n\t\t\t\tq.push( next );\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\twhile( cin >> w >> h, w || h ){\n\t\tinit();\n\t\t\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tstring l, r;\n\t\t\tcin >> l >> r;\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tL[y][x] = l[x];\n\t\t\t\tR[y][x] = r[x];\n\t\t\t}\n\t\t}\n\t\t// debug();\n\t\tbool ans = bfs();\n\t\tif( ans )\n\t\t\tcout << \"Yes\" << endl;\n\t\telse\n\t\t\tcout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int MAX = 55;\nchar rm[MAX][MAX], lm[MAX][MAX];\nint w, h;\n\nstruct Point{\n    int x,y;\n};\nbool u[MAX][MAX][MAX][MAX];\nbool ans;\n\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\nvoid bfs(Point a, Point b){\n    queue<pair<Point,Point>> q;\n    q.push(make_pair(a, b));\n\n    auto f = [](Point p, char m[MAX][MAX]){\n        if(p.y < 0 || p.y >= h || p.x < 0 || p.x >= w) return 1;\n        if(m[p.y][p.x] == '#') return 1;\n        return 0;\n    };\n\n    while(not q.empty()){\n        Point rp = q.front().first;\n        Point lp = q.front().second;\n        //cout << lp.x << ' ' << lp.y << \"  /  \" << rp.x << ' ' << rp.y << endl;\n        q.pop();\n\n        if(rm[rp.y][rp.x] == '%' && lm[lp.y][lp.x] == '%'){\n            ans = true;\n            return;\n        }\n        if(rm[rp.y][rp.x] == '%' || lm[lp.y][lp.x] == '%') continue;\n        rep(i,4){\n            Point l,r;\n            l = Point{lp.x + dx[i], lp.y + dy[i]};\n            r = Point{rp.x - dx[i], rp.y + dy[i]};\n            if(f(l, lm)) l = lp;\n            if(f(r, rm)) r = rp;\n\n            if(u[r.y][r.x][l.y][l.x]) continue;\n            u[r.y][r.x][l.y][l.x] = true;\n            q.push(make_pair(r,l));\n        }\n    }\n}\n\nint main(){\n    while(cin >> w >> h, w){\n        ans = false;\n        Point rp, lp;\n        memset(u, 0, sizeof(u));\n        rep(i,h) cin >> lm[i] >> rm[i];\n\n        rep(i,h){\n            rep(j,w){\n                if(lm[i][j] == 'L') lp = Point{j,i};\n                if(rm[i][j] == 'R') rp = Point{j,i};\n            }\n        }\n        bfs(rp,lp);\n        cout << (ans ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\n\ntemplate<class T>\ninline bool chmax(T &a, const T &b) {\n    if(a<b) {\n        a=b;\n        return true;\n    }\n\n    return false;\n}\ntemplate<class T>\ninline bool chmin(T &a, const T &b) {\n    if(a>b) {\n        a=b;\n        return true;\n    }\n\n    return false;\n}\n\nint W,H;\nstring roomL[51],roomR[51];\n\nbool ok(P len,P rin) {\n    bool visited[51][51][51][51]={};\n    visited[len.fr][len.sc][rin.fr][rin.sc]=true;\n    queue<PP> que;\n    que.push(PP(len,rin));\n\n    while(que.size()) {\n        PP pp=que.front(); que.pop();\n        P next_len=pp.fr;\n        P next_rin=pp.sc;\n\n        //printf(\"[debug] %d %d %d %d\\n\",next_len.fr,next_len.sc,next_rin.fr,next_rin.sc);\n\n        if(roomL[next_len.fr][next_len.sc]=='%' && roomR[next_rin.fr][next_rin.sc]=='%') {\n            return true;\n        }\n        if(roomL[next_len.fr][next_len.sc]=='%' || roomR[next_rin.fr][next_rin.sc]=='%') {\n            continue;\n        }\n        rep(i,4) {\n            next_len=pp.fr;\n            next_rin=pp.sc;\n\n            next_len.fr+=dy[i];\n            next_len.sc+=dx[i];\n            next_rin.fr+=dy[i];\n            next_rin.sc-=dx[i];\n\n            chmax(next_len.fr,0);\n            chmin(next_len.fr,H-1);\n            chmax(next_len.sc,0);\n            chmin(next_len.sc,W-1);\n            chmax(next_rin.fr,0);\n            chmin(next_rin.fr,H-1);\n            chmax(next_rin.sc,0);\n            chmin(next_rin.sc,W-1);\n\n            if(roomL[next_len.fr][next_len.sc]=='#') {\n                next_len.fr-=dy[i];\n                next_len.sc-=dx[i];\n            }\n            if(roomR[next_rin.fr][next_rin.sc]=='#') {\n                next_rin.fr-=dy[i];\n                next_rin.sc+=dx[i];\n            }\n\n            if(!visited[next_len.fr][next_len.sc][next_rin.fr][next_len.sc]) {\n                visited[next_len.fr][next_len.sc][next_rin.fr][next_len.sc]=true;\n                que.push(PP(next_len,next_rin));\n            }\n        }\n    }\n\n    return false;\n}\n\nvoid solve() {\n    rep(y,H) cin>>roomL[y]>>roomR[y];\n    P len,rin;\n    rep(y,H) rep(x,W) {\n        if(roomL[y][x]=='L') len=P(y,x);\n        if(roomR[y][x]=='R') rin=P(y,x);\n    }\n    if(ok(len,rin)) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n}\n\nint main() {\n    while(cin>>W>>H) {\n        if(!W) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif // !_WIN32\n\n#include<string>\n#include<iomanip>\n#include<vector>\n#include<string>\n#include<stack>\n#include<tuple>\n#include<algorithm>\nusing namespace std;\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n\n\nconst int dr[] = {0,1,0,-1};\nconst int dc1[] = {1,0,-1,0 };\nconst int dc2[] = { -1,0,1,0 };\n\nvector<string> wrap(vector<string> in,char c) {\n\tint R = in.size();\n\tint C = in[0].size();\n\tvector<string> out(R + 2, string(C + 2, c));\n\tREP(i, R)REP(j, C)out[i + 1][j + 1] = in[i][j];\n\treturn out;\n\n}\ntypedef tuple<int, int, int, int> T;\ninline int f(int a, int b, int c, int d) {\n\treturn ((a * 55 + b) * 55 + c) * 55 + d;\n}\nint dp[55 * 55 * 55 * 55];\nint main() {\n\tint R, C;\n\twhile (cin >> C >> R, R + C) {\n\t\tvector<string> A(R), B(R);\n\t\tREP(i, R) {\n\t\t\tcin >> A[i] >> B[i];\n\t\t}\n\t\tA = wrap(A, '#');\n\t\tB = wrap(B, '#');\n\t\tint asr, asc, bsr, bsc;\n\t\tint agr, agc, bgr, bgc;\n\n\t\tR += 2;\n\t\tC += 2;\n\t\tREP(a, R)REP(b, C)REP(c, R)REP(d, C)dp[f(a,b,c,d)] = 0;\n\t\tREP(i, R)REP(j, C)if (A[i][j] == 'L') { asr = i, asc = j; }\n\t\tREP(i, R)REP(j, C)if (B[i][j] == 'R') { bsr = i, bsc = j; }\n\t\tREP(i, R)REP(j, C)if (A[i][j] == '%') { agr = i, agc = j; }\n\t\tREP(i, R)REP(j, C)if (B[i][j] == '%') { bgr = i, bgc = j; }\n\t\tstack<T> st;\n\t\tst.push(T(asr, asc, bsr, bsc));\n\t\tdp[f(asr, asc, bsr, bsc)] = 1;\n\t\twhile (st.size()) {\n\t\t\tint ar, ac, br, bc;\n\t\t\ttie(ar, ac, br, bc) = st.top();\n\t\t\tst.pop();\n\t\t\tREP(i, 4) {\n\t\t\t\tint nar = ar + dr[i];\n\t\t\t\tint nac = ac + dc1[i];\n\t\t\t\tint nbr = br + dr[i];\n\t\t\t\tint nbc = bc + dc2[i];\n\t\t\t\tif (A[nar][nac] == '#') { nar = ar, nac = ac; }\n\t\t\t\tif (B[nbr][nbc] == '#') { nbr = br, nbc = bc; }\n\t\t\t\tif (A[nar][nac] == '%') {\n\t\t\t\t\tif (B[nbr][nbc] != '%')continue;\n\t\t\t\t}\n\t\t\t\tif (B[nbr][nbc] == '%') {\n\t\t\t\t\tif (A[nar][nac] != '%')continue;\n\t\t\t\t}\n\t\t\t\tif (dp[f(nar, nac, nbr, nbc)])continue;\n\t\t\t\tdp[f(nar, nac, nbr, nbc)]=1;\n\t\t\t\tst.push(T(nar, nac, nbr, nbc));\n\t\t\t}\n\n\t\t}\n\t\tif (dp[f(agr, agc, bgr, bgc)])cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nint W, H;\nint dxy[4] = {1,-1,0,0};\nvector<string> len, rin;\n/*\nbool solve(vector<vector<vector<vector<int> > > > &used, int ly, int lx, int ry, int rx){\n  if(used[ly][lx][ry][rx]) return false;\n  used[ly][lx][ry][rx] = true;\n\n  // cout<<ly<<\" \"<<lx<<\" \"<<ry<<\" \"<<rx<<endl;\n  for(int i = 0; i < 4; i++){\n      int nly = ly + dxy[i], nlx = lx + dxy[3-i];\n      int nry = ry + dxy[i], nrx = rx + dxy[3-i]*-1;\n      if(nly < 0 || H <= nly || nlx < 0 || W <= nlx || len[nly][nlx] == '#'){\n\tnly -= dxy[i], nlx -= dxy[3-i];\t\n      }\n      \n      if(nry < 0 || H <= nry || nrx < 0 || W <= nrx || rin[nry][nrx] == '#'){\n\tnry -= dxy[i], nrx -= dxy[3-i]*-1;\n      }\n      \n      if(len[nly][nlx] == '%' &&  rin[nry][nrx] == '%') return true;\n\n      if(solve(used,nly,nlx,nry,nrx)) return true;\n  }\n\n  return false;\n}\n*/\n\nbool solve(vector<vector<vector<vector<int> > > > &used, int ly, int lx, int ry, int rx){\n  queue<pair<pair<int,int>,pair<int,int> > > Q;\n\n  Q.push(make_pair(make_pair(ly,lx),make_pair(ry,rx)));\n  \n  while(!Q.empty()){\n    pair<pair<int,int>,pair<int,int> > P = Q.front(); Q.pop();\n    int ly = P.first.first, lx = P.first.second;\n    int ry = P.second.first, rx = P.second.second;\n    used[ly][lx][ry][rx] = true;\n  \n    for(int i = 0; i < 4; i++){\n      int nly = ly + dxy[i], nlx = lx + dxy[3-i];\n      int nry = ry + dxy[i], nrx = rx + dxy[3-i]*-1;\n      if(nly < 0 || H <= nly || nlx < 0 || W <= nlx || len[nly][nlx] == '#'){\n\tnly -= dxy[i], nlx -= dxy[3-i];\t\n      }\n      \n      if(nry < 0 || H <= nry || nrx < 0 || W <= nrx || rin[nry][nrx] == '#'){\n\tnry -= dxy[i], nrx -= dxy[3-i]*-1;\n      }\n      \n      if(len[nly][nlx] == '%' &&  rin[nry][nrx] == '%') return true;\n      if(len[nly][nlx] == '%' ||  rin[nry][nrx] == '%') continue;\n       \n      if(used[nly][nlx][nry][nrx]) continue;\n      \n      used[nly][nlx][nry][nrx] = true;\n      \n      Q.push(make_pair(make_pair(nly,nlx),make_pair(nry,nrx)));\n    }\n    \n  }\n\n  return false;\n}\nsigned main(){\n\n  while(true){\n    \n    vector<vector<vector<vector<int> > > > used;\n    int lsx,lsy, rsx, rsy;\n    cin>>W>>H;\n\n    if(!W && !H) break;\n\n    len.clear();\n    rin.clear();\n    len.resize(H);\n    rin.resize(H);\n    used.resize(H,vector<vector<vector<int> > >(W,vector<vector<int> >(H,vector<int>(W,0))));\n     \n    for(int i = 0; i < H; i++){\n      cin>>len[i];\n      cin>>rin[i];\n      for(int j = 0; j < W; j++){\n\tif(len[i][j] == 'L'){\n\t  lsx = j;\n\t  lsy = i;\n\t}\n\tif(rin[i][j] == 'R'){\n\t  rsx = j;\n\t  rsy = i;\n\t}\n      }\n    }\n     \n     cout<<(solve(used,lsy,lsx,rsy,rsx)?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<char,char> P;\n\nstruct state{\n\tP p1, p2;\n\tstate(P p1_, P p2_){ p1 = p1_; p2 = p2_; }\n};\nint w, h;\nint dx1[4] = {0,-1,1,0};\nint dy1[4] = {-1,0,0,1};\nint dx2[4] = {0,1,-1,0};\nint dy2[4] = {-1,0,0,1};\nbool flag[51][51][51][51];\nchar L[51][51];\nchar R[51][51];\n\nvoid init(){\n\tfor(int i=0 ; i < 51 ; i++ ){\n\t\tfor(int j=0 ; j < 51 ; j++ ){\n\t\t\tfor(int k=0 ; k < 51 ; k++ ){\n\t\t\t\tfor(int l=0 ; l < 51 ; l++ ){\n\t\t\t\t\tflag[i][j][k][l] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// デバッグ用\nvoid debug(){\n\tcout << \"[Left]\" << endl;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tcout << L[y][x];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n\tcout << \"[right]\" << endl;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tcout << R[y][x];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// R[y][x] == 'R' となる (x,y) を返す\nP R_search(){\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( R[y][x] == 'R' ){\n\t\t\t\tR[y][x] = '.';\n\t\t\t\treturn P(x,y);\n\t\t\t}\n\t\t}\n\t}\n\treturn P(0,0);\n}\n\n// L[y][x] == 'L' となる (x,y) を返す\nP L_search(){\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( L[y][x] == 'L' ){\n\t\t\t\tL[y][x] = '.';\n\t\t\t\treturn P(x,y);\n\t\t\t}\n\t\t}\n\t}\n\treturn P(0,0);\n}\n\nbool bfs(){\n\tP ls = L_search();\n\tP rs = R_search();\n\t\n\tqueue< pair<P,P> > q;\n\tpair<P,P> s( ls , rs );\n\tq.push( s );\n\t\n\twhile( !q.empty() && q.size() < 100000 ){\n\t\tpair<P,P> now = q.front(); q.pop();\n\t\tint x1 = now.first.first;\n\t\tint y1 = now.first.second;\n\t\tint x2 = now.second.first;\n\t\tint y2 = now.second.second;\n\t\tflag[y1][x1][y2][x2] = true;\n\t\tif( L[y1][x1] == '%' && R[y2][x2] == '%' ){\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\tint mx1 = x1 + dx1[i];\n\t\t\tint my1 = y1 + dy1[i];\n\t\t\tif( mx1 < 0 || my1 < 0 || mx1 >= w || my1 >= h || L[my1][mx1] == '#' ){\n\t\t\t\tmx1 = x1;\n\t\t\t\tmy1 = y1;\n\t\t\t}\n\t\t\tint mx2 = x2 + dx2[i];\n\t\t\tint my2 = y2 + dy2[i];\n\t\t\tif( mx2 < 0 || my2 < 0 || mx2 >= w || my2 >= h || R[my2][mx2] == '#' ){\n\t\t\t\tmx2 = x2;\n\t\t\t\tmy2 = y2;\n\t\t\t}\n\t\t\tP p1(mx1,my1);\n\t\t\tP p2(mx2,my2);\n\t\t\tpair<P,P> next(p1,p2);\n\t\t\tif( flag[my1][mx1][my2][mx2] ){\n\t\t\t\tcontinue;\n\t\t\t}else if( L[my1][mx1] == '%' && R[my2][mx2] != '%' ){\n\t\t\t\tflag[my1][mx1][my2][mx2] = true;\n\t\t\t}else if( L[my1][mx1] != '%' && R[my2][mx2] == '%' ){\n\t\t\t\tflag[my1][mx1][my2][mx2] = true;\n\t\t\t}else{\n\t\t\t\tq.push( next );\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\twhile( cin >> w >> h, w || h ){\n\t\tinit();\n\t\t\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tstring l, r;\n\t\t\tcin >> l >> r;\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tL[y][x] = l[x];\n\t\t\t\tR[y][x] = r[x];\n\t\t\t}\n\t\t}\n\t\t// debug();\n\t\tbool ans = bfs();\n\t\tif( ans )\n\t\t\tcout << \"Yes\" << endl;\n\t\telse\n\t\t\tcout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<cmath>\n#include<utility>\n#include<functional>\n#include<map>\n#include<set>\n#include<cctype>\n\n\n#define FOR(i, a, b) for( int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for( int i=(a);i>=(b);i--)\n#define LFOR(i, a, b) for( long long int i=(a);i<=(b);i++)\n#define LRFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LLINF 1000000000000000000 //9000000000000000000\n#define PI 3.14159265358979\n#define MAXI 7500000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\n\nint dy[4] = { 0,0,1,-1 };\nint dx[4] = { 1,-1,0,0 };\n\n//int dp[50][50][50][50] = {};//ly,lx,ry,rx\n\n\nint main(void) {\n\t\n\twhile (1) {\n\n\t\ttypedef struct {\n\t\tpublic:\n\t\t\tint leftx;\n\t\t\tint lefty;\n\t\t\tint rightx;\n\t\t\tint righty;\n\t\t}Pos;\n\n\t\tint w, h;\n\t\tint lx = -1, ly = -1, rx = -1, ry = -1;\n\t\tint lgx = -1, lgy = -1, rgx = -1, rgy = -1;\n\n\t\tvector< vector< vector< vector<int> > > > dp(50, vector< vector< vector<int > > >(50, vector< vector<int> >(50, vector<int>(50, 0))));\n\t\t\n\n\t\tqueue< Pos > que;\n\t\tPos now;\n\n\t\tcin >> w >> h;\n\n\t\tif (w == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tvector<string> left(h), right(h);\n\n\t\tFOR(i, 0, h-1) {\n\t\t\tcin >> left[i] >> right[i];\n\t\t}\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (left[i][j] == 'L') {\n\t\t\t\t\tlx = j;\n\t\t\t\t\tly = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (right[i][j] == 'R') {\n\t\t\t\t\trx = j;\n\t\t\t\t\try = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (left[i][j] == '%') {\n\t\t\t\t\tlgx = j;\n\t\t\t\t\tlgy = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lgx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (right[i][j] == '%') {\n\t\t\t\t\trgx = j;\n\t\t\t\t\trgy = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rgx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdp[ly][lx][ry][rx] = 1;\n\n\t\tnow.lefty = ly;\n\t\tnow.leftx = lx;\n\t\tnow.righty = ry;\n\t\tnow.rightx = rx;\n\t\t\n\t\tque.push(now);\n\n\n\t\twhile (!que.empty()) {\n\t\t\tnow = que.front();\n\t\t\t\n\t\t\tque.pop();\n\t\t\tly = now.lefty;\n\t\t\tlx = now.leftx;\n\t\t\try = now.righty;\n\t\t\trx = now.rightx;\n\t\t\t//cout << ly << \" \" << lx << \" \" << ry << \" \" << rx << endl;\n\n\t\t\tFOR(i, 0, 3) {\n\t\t\t\t\n\t\t\t\tif (ly + dy[i] >= 0 && lx - dx[i] >= 0 && ry + dy[i] <= h - 1 && rx + dx[i] <= w - 1 && ly + dy[i] <= h - 1 && lx - dx[i] <= w - 1 && ry + dy[i] >= 0 && rx + dx[i] >= 0) {\n\t\t\t\t\tif (dp[ly + dy[i]][lx - dx[i]][ry + dy[i]][rx + dx[i]] != 1) {\n\t\t\t\t\t\tif (left[ly + dy[i]][lx - dx[i]] == '#') {\n\t\t\t\t\t\t\tif (right[ry + dy[i]][rx + dx[i]] == '#') {\n\t\t\t\t\t\t\t\t//no\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdp[ly][lx][ry + dy[i]][rx + dx[i]] = 1;\n\t\t\t\t\t\t\t\tnow.lefty = ly;\n\t\t\t\t\t\t\t\tnow.leftx = lx;\n\t\t\t\t\t\t\t\tnow.righty = ry + dy[i];\n\t\t\t\t\t\t\t\tnow.rightx = rx + dx[i];\n\t\t\t\t\t\t\t\tque.push(now);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (right[ry + dy[i]][rx + dx[i]] == '#') {\n\t\t\t\t\t\t\t\tdp[ly + dy[i]][lx - dx[i]][ry][rx] = 1;\n\t\t\t\t\t\t\t\tnow.lefty = ly + dy[i];\n\t\t\t\t\t\t\t\tnow.leftx = lx - dx[i];\n\t\t\t\t\t\t\t\tnow.righty = ry;\n\t\t\t\t\t\t\t\tnow.rightx = rx;\n\t\t\t\t\t\t\t\tque.push(now);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdp[ly + dy[i]][lx - dx[i]][ry + dy[i]][rx + dx[i]] = 1;\n\t\t\t\t\t\t\t\tnow.lefty = ly + dy[i];\n\t\t\t\t\t\t\t\tnow.leftx = lx - dx[i];\n\t\t\t\t\t\t\t\tnow.righty = ry + dy[i];\n\t\t\t\t\t\t\t\tnow.rightx = rx + dx[i];\n\t\t\t\t\t\t\t\tque.push(now);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (dp[lgy][lgx][rgy][rgx] == 1) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t\t\n\n\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <map>\n#include <algorithm>\n#define fr first\n#define sc second\nusing namespace std;\n\n// first:x, second:y\ntypedef pair<int, int> iP;\ntypedef pair<iP, iP> iiiP;\n\niP sR, sL;\nint h, w, used[50][50][50][50];\nint dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\nchar mapR[51][51], mapL[51][51];\nbool judge;\n\nvoid bfs(){\n  queue <iiiP> que;\n  que.push(iiiP(sL, sR));\n  used[sL.fr][sL.sc][sR.fr][sR.sc] = 1;\n  while(!que.empty()){\n    iiiP p = que.front(); que.pop();\n    if(mapL[p.fr.sc][p.fr.fr] != '%' && mapR[p.sc.sc][p.sc.fr] != '%'){\n      for(int i = 0; i < 4; i++){\n\tint Lnx = min(w-1, max(0, p.fr.fr + dx[i]));\n\tint Lny = min(h-1, max(0, p.fr.sc + dy[i]));\n\tint Rnx = min(w-1, max(0, p.sc.fr - dx[i]));\n\tint Rny = min(h-1, max(0, p.sc.sc + dy[i]));\n\t\n\tif(mapL[Lny][Lnx] == '%' && mapR[Rny][Rnx] == '%'){ judge = true; break; }\n\tif(mapL[Lny][Lnx] == '#') Lnx = p.fr.fr, Lny = p.fr.sc;\n\tif(mapR[Rny][Rnx] == '#') Rnx = p.sc.fr, Rny = p.sc.sc;\n\tif(!used[Lny][Lnx][Rny][Rnx]){\n\t  que.push(iiiP(iP(Lnx, Lny), iP(Rnx, Rny)));\n\t  used[Lny][Lnx][Rny][Rnx] = 1;\n\t}\n      }\n    }\n  }\n}\n\nint main(){\n  \n  while(cin >> w >> h, w){\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n\tcin >> mapL[i][j];\n\tif(mapL[i][j] == 'L'){\n\t  mapL[i][j] = '.'; sL.fr = j, sL.sc = i;\n\t}\n      }\n      \n      for(int j = 0; j < w; j++){\n\tcin >> mapR[i][j];\n\tif(mapR[i][j] == 'R'){\n\t  mapR[i][j] = '.'; sR.fr = j, sR.sc = i;\n\t}\n      }\n    }\n\n    judge = false;\n    memset(used, 0, sizeof(used));\n    bfs();\n    if(judge) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp make_pair\n#define pb push_back\n#define F first\n#define S second\n\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nbool app[50][50][50][50];\nchar lr[53][53],rr[53][53]\nstring ans;\n\nmain(){\n  int w,h;\n  while(cin>>w>>h,w|h){\n    memset(app,0,6250000);\n    rep(i,h)scanf(\" %s %s \",lr[i],rr[i]);\n\n    int rsx,rsy,lsx,lsy;\n    rep(i,h)rep(j,w){\n      if(lr[i][j]=='L')lsx=i,lsy=j;\n      if(rr[i][j]=='R')rsx=i,rsy=j;\n    }\n    ans=\"No\";\n    queue<pair<PI,PI> > Q;\n    Q.push(mp(mp(lsx,lsy),mp(rsx,rsy)));\n\n    while(!Q.empty()){\n      PI tp=Q.front().F;\n      int clx,cly,crx,cry;\n      clx=tp.F,cly=tp.S;\n      tp=Q.front().S;Q.pop();\n      crx=tp.F,cry=tp.S;\n      if(lr[clx][cly]=='%' && rr[crx][cry]=='%'){\n        ans=\"Yes\";\n        break;\n      }\n      if(lr[clx][cly]=='%' || rr[crx][cry]=='%')continue;\n      app[clx][cly][crx][cry]=true;\n\n      rep(i,4){\n        int nrx=crx+dx[i],nlx=clx+dx[i],nry=cry+dy[i],nly=cly-dy[i];\n        if(nrx<0 || nry<0 || nrx>=h || nry>=w || rr[nrx][nry]=='#')nrx=crx,nry=cry;\n        if(nlx<0 || nly<0 || nlx>=h || nly>=w || lr[nlx][nly]=='#')nlx=clx,nly=cly;\n        if(app[nlx][nly][nrx][nry])continue;\n        app[nlx][nly][nrx][nry]=true;\n        Q.push(mp(mp(nlx,nly),mp(nrx,nry)));\n      }\n/*      \n      rep(i,h){\n        rep(j,w){\n          if(clx==i && cly==j)cout<<'L';\n          else if(lr[i][j]=='L')cout<<'.';\n          else cout<<lr[i][j];\n        }\n        cout<<\" \";\n        rep(j,w){\n          if(crx==i && cry==j)cout<<'R';\n          else if(rr[i][j]=='R')cout<<'.';\n          else cout<<rr[i][j];\n        }\n        cout<<endl;\n      }\n      cout<<endl;\n*/\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nbool vis[50][50][50][50];\nint H,W,dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nstring sl[50],sr[50];\nbool okl(int x,int y){\n\treturn 0<=x&&x<H&&0<=y&&y<W&&sl[x][y]!='#';\n}\nbool okr(int x,int y){\n\treturn 0<=x&&x<H&&0<=y&&y<W&&sr[x][y]!='#';\n}\nvoid dfs(int lx,int ly,int rx,int ry){\n\tif(vis[lx][ly][rx][ry]) return;\n\tvis[lx][ly][rx][ry]=1;\n\tif(sl[lx][ly]=='%'||sr[rx][ry]=='%') return;\n\trep(di,4){\n\t\tint lnx=lx+dx[di],lny=ly+dy[di],rnx=rx+dx[di],rny=ry+dy[di];\n\t\tif(!okl(lnx,lny)) lnx=lx,lny=ly;\n\t\tif(!okr(rnx,rny)) rnx=rx,rny=ry;\n\t\tdfs(lnx,lny,rnx,rny);\n\t}\n}\nint main(){\n\twhile(true){\n\t\tcin>>W>>H;\n\t\tif(H==0) break;\n\t\trep(i,H){\n\t\t\tcin>>sl[i]>>sr[i];\n\t\t\treverse(all(sr[i]));\n\t\t}\n\t\tint lx,ly,rx,ry,ax,ay,bx,by;\n\t\trep(i,H) rep(j,W) if(sl[i][j]=='L') lx=i,ly=j;\n\t\trep(i,H) rep(j,W) if(sr[i][j]=='R') rx=i,ry=j;\n\t\trep(i,H) rep(j,W) if(sl[i][j]=='%') ax=i,ay=j;\n\t\trep(i,H) rep(j,W) if(sr[i][j]=='%') bx=i,by=j;\n\t\trep(i,H) rep(j,W) rep(k,H) rep(h,W) vis[i][j][k][h]=0;\n\t\tdfs(lx,ly,rx,ry);\n\t\tif(vis[ax][ay][bx][by]) puts(\"Yes\");\n\t\telse puts(\"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\nusing namespace std;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e12;\nconst int inf = 1e9;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef set<int> S;\nll n;\nint w,h;\nint di[]={0,1,0,-1};\nint dj[]={1,0,-1,0};\nstring s[60],t[60];\nint dist[60][60][60][60];\nint gx1,gy1,gx2,gy2;\nbool ok=0;\nvoid solve(int i,int j,int k,int l){\n    queue<pair<pii,pii>> que;\n    que.push({pii(i,j),pii(k,l)});\n    dist[i][j][k][l]=0;\n    while(!que.empty()){\n        int now1_i = que.front().first.first, now1_j = que.front().first.second;\n        int now2_i = que.front().second.first,now2_j = que.front().second.second;\n        if(s[now1_i][now1_j]=='%' && t[now2_i][now2_j]=='%') {\n            ok = true;\n            break;\n        }\n        que.pop();\n        if(s[now1_i][now1_j]!='%' && t[now2_i][now2_j]!='%')\n            for(int m=0;m<4;m++){\n                int nex1_i = now1_i + 1*di[m];\n                int nex1_j = now1_j - 1*dj[m];\n                int nex2_i = now2_i + 1*di[m];\n                int nex2_j = now2_j + 1*dj[m];\n                if(nex1_i >= h || nex1_j >= w || nex1_i < 0 || nex1_j < 0){\n                    nex1_i=now1_i;\n                    nex1_j=now1_j;\n                }\n                if(nex2_i >= h || nex2_j >= w || nex2_i < 0 || nex2_j < 0){\n                    nex2_i=now2_i;\n                    nex2_j=now2_j;\n                }\n                if(s[nex1_i][nex1_j]=='#') nex1_i=now1_i,nex1_j=now1_j;\n                if(t[nex2_i][nex2_j]=='#') nex2_i=now2_i,nex2_j=now2_j;\n                if(dist[nex1_i][nex1_j][nex2_i][nex2_j] == inf){\n                    que.push( {pii(nex1_i,nex1_j), pii(nex2_i,nex2_j)});\n                    dist[nex1_i][nex1_j][nex2_i][nex2_j] = dist[now1_i][now1_j][now2_i][now2_j]+1;\n                }\n            }\n    }\n}\nint main(){\n    while(1){\n        cin>>w>>h;\n        if(w==0 && h==0) break;\n        rep(i,60){\n            rep(j,60){\n                rep(k,60){\n                    rep(l,60){\n                        dist[i][j][k][l]=inf;\n                    }\n                }\n            }\n        }\n        for(int i=0;i<h;i++) cin>>s[i]>>t[i];\n        int a,b,c,d;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(s[i][j]=='L'){\n                    a=i;\n                    b=j;\n                }\n                if(t[i][j]=='R'){\n                    c=i;\n                    d=j;\n                }\n                if(s[i][j]=='%'){\n                    gx1=i;\n                    gy1=j;\n                }\n                if(t[i][j]=='%'){\n                    gx2=i;\n                    gy2=j;\n                }\n            }\n        }\n        ok=0;\n        solve(a,b,c,d);\n        if(ok) cout<<\"Yes\"<<endl;\n        else cout<<\"No\"<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//typedef\n//-------------------------#include <bits/stdc++.h>\n\nconst double pi = 3.141592653589793238462643383279;\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s)\n{\n  int v;\n  istringstream sin(s);\n  sin >> v;\n  return v;\n}\ntemplate <class T>\ninline string toString(T x)\n{\n  ostringstream sout;\n  sout << x;\n  return sout.str();\n}\ninline int readInt()\n{\n  int x;\n  scanf(\"%d\", &x);\n  return x;\n}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a) * (a))\n#define EACH(i, c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort((c).begin(), (c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i, s, n) for (int i = s; i < (int)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define MOD 1000000007\n\n#define rep(i, a, b) for (int i = a; i < (b); ++i)\n#define trav(a, x) for (auto &a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst double EPS = 1E-8;\n\n#define chmin(x, y) x = min(x, y)\n#define chmax(x, y) x = max(x, y)\n\nclass UnionFind\n{\npublic:\n  vector<int> par;\n  vector<int> siz;\n\n  UnionFind(int sz_) : par(sz_), siz(sz_, 1)\n  {\n    for (ll i = 0; i < sz_; ++i)\n      par[i] = i;\n  }\n  void init(int sz_)\n  {\n    par.resize(sz_);\n    siz.assign(sz_, 1LL);\n    for (ll i = 0; i < sz_; ++i)\n      par[i] = i;\n  }\n\n  int root(int x)\n  {\n    while (par[x] != x)\n    {\n      x = par[x] = par[par[x]];\n    }\n    return x;\n  }\n\n  bool merge(int x, int y)\n  {\n    x = root(x);\n    y = root(y);\n    if (x == y)\n      return false;\n    if (siz[x] < siz[y])\n      swap(x, y);\n    siz[x] += siz[y];\n    par[y] = x;\n    return true;\n  }\n\n  bool issame(int x, int y)\n  {\n    return root(x) == root(y);\n  }\n\n  int size(int x)\n  {\n    return siz[root(x)];\n  }\n};\n\nll modPow(ll x, ll n, ll mod = MOD)\n{\n  ll res = 1;\n  while (n)\n  {\n    if (n & 1)\n      res = (res * x) % mod;\n\n    res %= mod;\n    x = x * x % mod;\n    n >>= 1;\n  }\n  return res;\n}\n\n#define SIEVE_SIZE 5000000 + 10\nbool sieve[SIEVE_SIZE];\nvoid makeSieve()\n{\n  for (int i = 0; i < SIEVE_SIZE; ++i)\n    sieve[i] = true;\n  sieve[0] = sieve[1] = false;\n  for (int i = 2; i * i < SIEVE_SIZE; ++i)\n    if (sieve[i])\n      for (int j = 2; i * j < SIEVE_SIZE; ++j)\n        sieve[i * j] = false;\n}\n\nbool isprime(ll n)\n{\n  if (n == 0 || n == 1)\n    return false;\n  for (ll i = 2; i * i <= n; ++i)\n    if (n % i == 0)\n      return false;\n  return true;\n}\n\nconst int MAX = 2000010;\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit()\n{\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (int i = 2; i < MAX; i++)\n  {\n    fac[i] = fac[i - 1] * i % MOD;\n    inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n    finv[i] = finv[i - 1] * inv[i] % MOD;\n  }\n}\n\n// 二項係数計算\nlong long COM(int n, int k)\n{\n  if (n < k)\n    return 0;\n  if (n < 0 || k < 0)\n    return 0;\n  return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nlong long extGCD(long long a, long long b, long long &x, long long &y)\n{\n  if (b == 0)\n  {\n    x = 1;\n    y = 0;\n    return a;\n  }\n  long long d = extGCD(b, a % b, y, x);\n  y -= a / b * x;\n  return d;\n}\n// 負の数にも対応した mod (a = -11 とかでも OK)\ninline long long mod(long long a, long long m)\n{\n  return (a % m + m) % m;\n}\n\n// 逆元計算 (ここでは a と m が互いに素であることが必要)\nlong long modinv(long long a, long long m)\n{\n  long long x, y;\n  extGCD(a, m, x, y);\n  return mod(x, m); // 気持ち的には x % m だが、x が負かもしれないので\n}\nll GCD(ll a, ll b)\n{\n\n  if (b == 0)\n    return a;\n  return GCD(b, a % b);\n}\n\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n\nmat mul(mat &A, mat &B)\n{\n  mat C(A.size(), vec((int)B[0].size()));\n  for (int i = 0; i < A.size(); ++i)\n  {\n    for (int k = 0; k < B.size(); ++k)\n    {\n      for (int j = 0; j < B[0].size(); ++j)\n      {\n        C[i][j] = (C[i][j] + A[i][k] * B[k][j] % MOD) % MOD;\n      }\n    }\n  }\n  return C;\n}\nmat matPow(mat A, ll n)\n{\n  mat B(A.size(), vec((int)A.size()));\n\n  for (int i = 0; i < A.size(); ++i)\n  {\n    B[i][i] = 1;\n  }\n\n  while (n > 0)\n  {\n    if (n & 1)\n      B = mul(B, A);\n    A = mul(A, A);\n    n >>= 1;\n  }\n  return B;\n}\nint dist[55][55][55][55];\nint dxy[5] = {-1, 0, 1, 0, -1};\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n\n  int W, H;\n  while (cin >> W >> H)\n  {\n    if (W == 0 && H == 0)\n      break;\n    vector<string> f1, f2;\n    for (int i = 0; i < H; i++)\n    {\n      string s, t;\n      cin >> s >> t;\n      f1.push_back(s);\n      f2.push_back(t);\n    }\n\n    int lx, ly, rx, ry;\n    int gx1, gy1, gx2, gy2;\n    for (int i = 0; i < H; i++)\n    {\n      for (int j = 0; j < W; j++)\n      {\n        if (f1[i][j] == 'L')\n        {\n          lx = j, ly = i;\n        }\n\n        if (f2[i][j] == 'R')\n        {\n          rx = j, ry = i;\n        }\n\n        if (f1[i][j] == '%')\n        {\n          gx1 = j, gy1 = i;\n        }\n\n        if (f2[i][j] == '%')\n        {\n          gx2 = j, gy2 = i;\n        }\n      }\n    }\n\n    for (int i = 0; i < H; i++)\n    {\n      for (int j = 0; j < W; j++)\n      {\n        for (int k = 0; k < H; k++)\n        {\n          for (int l = 0; l < W; l++)\n          {\n            dist[i][j][k][l] = INT_MAX;\n          }\n        }\n      }\n    }\n    dist[ly][lx][ry][rx] = 0;\n    queue<pair<pair<int, int>, pair<int, int>>> q;\n    bool flag = false;\n    q.push(make_pair(make_pair(ly, lx), make_pair(ry, rx)));\n    while (q.size())\n    {\n      auto p = q.front();\n      q.pop();\n\n      int y1 = p.first.first, x1 = p.first.second;\n      int y2 = p.second.first, x2 = p.second.second;\n\n      int ny1 = y1 + 1, nx1 = x1;\n      int ny2 = y2 + 1, nx2 = x2;\n\n      bool c1 = false, c2 = false;\n\n      if (ny1 >= 0 && ny1 < H && nx1 >= 0 && nx1 < W && f1[ny1][nx1] != '#')\n      {\n        c1 = true;\n      }\n      if (ny2 >= 0 && ny2 < H && nx2 >= 0 && nx2 < W && f2[ny2][nx2] != '#')\n      {\n        c2 = true;\n      }\n\n      if (c1 && c2)\n      {\n        if (f1[ny1][nx1] == '%' && f2[ny2][nx2] == '%')\n        {\n          flag = true;\n        }\n        else if (f1[ny1][nx1] != '%' && f2[ny2][nx2] != '%')\n        {\n          if (dist[ny1][nx1][ny2][nx2] == INT_MAX)\n          {\n            dist[ny1][nx1][ny2][nx2] = dist[y1][x1][y2][x2] + 1;\n            q.push(make_pair(make_pair(ny1, nx1), make_pair(ny2, nx2)));\n          }\n        }\n      }\n      else if (c1)\n      {\n        ny2 = y2, nx2 = x2;\n        if (f1[ny1][nx1] == '%' && f2[ny2][nx2] == '%')\n        {\n          flag = true;\n        }\n        else if (f1[ny1][nx1] != '%' && f2[ny2][nx2] != '%')\n        {\n          if (dist[ny1][nx1][ny2][nx2] == INT_MAX)\n          {\n            dist[ny1][nx1][ny2][nx2] = dist[y1][x1][y2][x2] + 1;\n            q.push(make_pair(make_pair(ny1, nx1), make_pair(ny2, nx2)));\n          }\n        }\n      }\n      else if (c2)\n      {\n        ny1 = y1, nx1 = x1;\n        if (f1[ny1][nx1] == '%' && f2[ny2][nx2] == '%')\n        {\n          flag = true;\n        }\n        else if (f1[ny1][nx1] != '%' && f2[ny2][nx2] != '%')\n        {\n          if (dist[ny1][nx1][ny2][nx2] == INT_MAX)\n          {\n            dist[ny1][nx1][ny2][nx2] = dist[y1][x1][y2][x2] + 1;\n            q.push(make_pair(make_pair(ny1, nx1), make_pair(ny2, nx2)));\n          }\n        }\n      }\n\n      ny1 = y1 - 1, nx1 = x1;\n      ny2 = y2 - 1, nx2 = x2;\n\n      c1 = false, c2 = false;\n\n      if (ny1 >= 0 && ny1 < H && nx1 >= 0 && nx1 < W && f1[ny1][nx1] != '#')\n      {\n        c1 = true;\n      }\n      if (ny2 >= 0 && ny2 < H && nx2 >= 0 && nx2 < W && f2[ny2][nx2] != '#')\n      {\n        c2 = true;\n      }\n\n      if (c1 && c2)\n      {\n        if (f1[ny1][nx1] == '%' && f2[ny2][nx2] == '%')\n        {\n          flag = true;\n        }\n        else if (f1[ny1][nx1] != '%' && f2[ny2][nx2] != '%')\n        {\n          if (dist[ny1][nx1][ny2][nx2] == INT_MAX)\n          {\n            dist[ny1][nx1][ny2][nx2] = dist[y1][x1][y2][x2] + 1;\n            q.push(make_pair(make_pair(ny1, nx1), make_pair(ny2, nx2)));\n          }\n        }\n      }\n      else if (c1)\n      {\n        ny2 = y2, nx2 = x2;\n        if (f1[ny1][nx1] == '%' && f2[ny2][nx2] == '%')\n        {\n          flag = true;\n        }\n        else if (f1[ny1][nx1] != '%' && f2[ny2][nx2] != '%')\n        {\n          if (dist[ny1][nx1][ny2][nx2] == INT_MAX)\n          {\n            dist[ny1][nx1][ny2][nx2] = dist[y1][x1][y2][x2] + 1;\n            q.push(make_pair(make_pair(ny1, nx1), make_pair(ny2, nx2)));\n          }\n        }\n      }\n      else if (c2)\n      {\n        ny1 = y1, nx1 = x1;\n        if (f1[ny1][nx1] == '%' && f2[ny2][nx2] == '%')\n        {\n          flag = true;\n        }\n        else if (f1[ny1][nx1] != '%' && f2[ny2][nx2] != '%')\n        {\n          if (dist[ny1][nx1][ny2][nx2] == INT_MAX)\n          {\n            dist[ny1][nx1][ny2][nx2] = dist[y1][x1][y2][x2] + 1;\n            q.push(make_pair(make_pair(ny1, nx1), make_pair(ny2, nx2)));\n          }\n        }\n      }\n\n      ny1 = y1, nx1 = x1 - 1;\n      ny2 = y2, nx2 = x2 + 1;\n\n      c1 = false, c2 = false;\n\n      if (ny1 >= 0 && ny1 < H && nx1 >= 0 && nx1 < W && f1[ny1][nx1] != '#')\n      {\n        c1 = true;\n      }\n      if (ny2 >= 0 && ny2 < H && nx2 >= 0 && nx2 < W && f2[ny2][nx2] != '#')\n      {\n        c2 = true;\n      }\n\n      if (c1 && c2)\n      {\n        if (f1[ny1][nx1] == '%' && f2[ny2][nx2] == '%')\n        {\n          flag = true;\n        }\n        else if (f1[ny1][nx1] != '%' && f2[ny2][nx2] != '%')\n        {\n          if (dist[ny1][nx1][ny2][nx2] == INT_MAX)\n          {\n            dist[ny1][nx1][ny2][nx2] = dist[y1][x1][y2][x2] + 1;\n            q.push(make_pair(make_pair(ny1, nx1), make_pair(ny2, nx2)));\n          }\n        }\n      }\n      else if (c1)\n      {\n        ny2 = y2, nx2 = x2;\n        if (f1[ny1][nx1] == '%' && f2[ny2][nx2] == '%')\n        {\n          flag = true;\n        }\n        else if (f1[ny1][nx1] != '%' && f2[ny2][nx2] != '%')\n        {\n          if (dist[ny1][nx1][ny2][nx2] == INT_MAX)\n          {\n            dist[ny1][nx1][ny2][nx2] = dist[y1][x1][y2][x2] + 1;\n            q.push(make_pair(make_pair(ny1, nx1), make_pair(ny2, nx2)));\n          }\n        }\n      }\n      else if (c2)\n      {\n        ny1 = y1, nx1 = x1;\n        if (f1[ny1][nx1] == '%' && f2[ny2][nx2] == '%')\n        {\n          flag = true;\n        }\n        else if (f1[ny1][nx1] != '%' && f2[ny2][nx2] != '%')\n        {\n          if (dist[ny1][nx1][ny2][nx2] == INT_MAX)\n          {\n            dist[ny1][nx1][ny2][nx2] = dist[y1][x1][y2][x2] + 1;\n            q.push(make_pair(make_pair(ny1, nx1), make_pair(ny2, nx2)));\n          }\n        }\n      }\n\n      ny1 = y1, nx1 = x1 + 1;\n      ny2 = y2, nx2 = x2 - 1;\n\n      c1 = false, c2 = false;\n\n      if (ny1 >= 0 && ny1 < H && nx1 >= 0 && nx1 < W && f1[ny1][nx1] != '#')\n      {\n        c1 = true;\n      }\n      if (ny2 >= 0 && ny2 < H && nx2 >= 0 && nx2 < W && f2[ny2][nx2] != '#')\n      {\n        c2 = true;\n      }\n\n      if (c1 && c2)\n      {\n        if (f1[ny1][nx1] == '%' && f2[ny2][nx2] == '%')\n        {\n          flag = true;\n        }\n        else if (f1[ny1][nx1] != '%' && f2[ny2][nx2] != '%')\n        {\n          if (dist[ny1][nx1][ny2][nx2] == INT_MAX)\n          {\n            dist[ny1][nx1][ny2][nx2] = dist[y1][x1][y2][x2] + 1;\n            q.push(make_pair(make_pair(ny1, nx1), make_pair(ny2, nx2)));\n          }\n        }\n      }\n      else if (c1)\n      {\n        ny2 = y2, nx2 = x2;\n        if (f1[ny1][nx1] == '%' && f2[ny2][nx2] == '%')\n        {\n          flag = true;\n        }\n        else if (f1[ny1][nx1] != '%' && f2[ny2][nx2] != '%')\n        {\n          if (dist[ny1][nx1][ny2][nx2] == INT_MAX)\n          {\n            dist[ny1][nx1][ny2][nx2] = dist[y1][x1][y2][x2] + 1;\n            q.push(make_pair(make_pair(ny1, nx1), make_pair(ny2, nx2)));\n          }\n        }\n      }\n      else if (c2)\n      {\n        ny1 = y1, nx1 = x1;\n        if (f1[ny1][nx1] == '%' && f2[ny2][nx2] == '%')\n        {\n          flag = true;\n        }\n        else if (f1[ny1][nx1] != '%' && f2[ny2][nx2] != '%')\n        {\n          if (dist[ny1][nx1][ny2][nx2] == INT_MAX)\n          {\n            dist[ny1][nx1][ny2][nx2] = dist[y1][x1][y2][x2] + 1;\n            q.push(make_pair(make_pair(ny1, nx1), make_pair(ny2, nx2)));\n          }\n        }\n      }\n    }\n\n    if (flag)\n    {\n      cout << \"Yes\" << endl;\n    }\n    else\n    {\n      cout << \"No\" << endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP(a, b) make_pair(a, b)\n#define Y first\n#define X second\n#define L first\n#define R second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef pair<pi, pi> pipi;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint W, H, used[64][64][64][64];\nint dy[] = {0,-1,0,1}, dx[] = {-1,0,1,0};\nchar len[64][64], rin[64][64];\n\nstruct P{\n  int rx, ry, lx, ly;\n  P(int ly, int lx, int ry, int rx):ly(ly),lx(lx),ry(ry),rx(rx){};\n};\n\nint main(){\n  while(scanf(\"%d%d\", &W, &H) && W){\n    rep(i, H) scanf(\"%s%s\", len[i], rin[i]);\n\n    int ly, lx, ry, rx;\n    rep(i, H) rep(j, W){\n      if(len[i][j] == 'L'){ ly = i, lx = j; len[i][j] = '.';}\n      if(rin[i][j] == 'R'){ ry = i, rx = j; rin[i][j] = '.';}\n    }\n\n    memset(used, 0, sizeof(used));\n    queue<P>q;\n    q.push(P(ly, lx, ry, rx));\n    used[ly][lx][ry][rx] = 1;\n\n    while(!q.empty()){\n      P now = q.front(); q.pop();\n      rep(d, 4){\n\tint nly, nlx, nry, nrx;\n\tif(d%2){\n\t  nly = now.ly + dy[d], nlx = now.lx;\n\t  if(nly < 0 || nly >= H || len[nly][nlx] == '#') nly = now.ly; \n\t  nry = now.ry + dy[d], nrx = now.rx;\n\t  if(nry < 0 || nry >= H || rin[nry][nrx] == '#') nry = now.ry; \n\t}else{\n\t  nly = now.ly, nlx = now.lx + dx[d];\n\t  if(nlx < 0 || nlx >= W || len[nly][nlx] == '#') nlx = now.lx; \t    \n\t  nry = now.ry, nrx = now.rx + -1*dx[d];\n\t  if(nrx < 0 || nrx >= W || rin[nry][nrx] == '#') nrx = now.rx;\n\t}\n\n\t  //\t  pipi next = MP(MP(nly, nlx), MP(nry, nrx));\n\tif(len[nly][nlx] == '%' && rin[nry][nrx] == '%'){\n\t  puts(\"Yes\"); goto e;\n\t}\n\tif(len[nly][nlx] == '%' || rin[nry][nrx] == '%') continue;\n       \n\tif(used[nly][nlx][nry][nrx] != 0) continue;\n\t//\t  printf(\"%d %d %d %d\\n\", next.L.Y, next.L.X, next.R.Y, next.R.X);\n\tq.push(P(nly, nlx, nry, nrx));\n\tused[nly][nlx][nry][nrx] = 1;\n      }\n    }\n    puts(\"No\");\n  e:;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <set>\n#include <queue>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\tint h, w, i, j, a, b, c, d, dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\n\tchar rf[50][51], lf[50][51];\n\tset<pair<P,P> > s;\n\tP rs, ls, rg, lg;\n\tqueue<P> r, l;\n\twhile(1){\n\t\tscanf(\"%d%d%*c\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tlf[i][j] = getchar();\n\t\t\t\tif(lf[i][j] == 'L'){\n\t\t\t\t\tls = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(lf[i][j] == '%'){\n\t\t\t\t\tlg = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 空白読み飛ばし\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\trf[i][j] = getchar();\n\t\t\t\tif(rf[i][j] == 'R'){\n\t\t\t\t\trs = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(rf[i][j] == '%'){\n\t\t\t\t\trg = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 改行文字読み飛ばし\n\t\t}\n\t\tr.push(rs), l.push(ls);\n\t\twhile(r.size() && s.find(pair<P,P>(P(lg.first,lg.second),P(rg.first,rg.second))) == s.end()){\n\t\t\ta = l.front().first, b = l.front().second, c = r.front().first, d = r.front().second;\n\t\t\tl.pop(), r.pop();\n\t\t\ts.insert(pair<P,P>(P(a,b),P(c,d)));\n\t\t\tfor(i = 0;i < 4;i++){\n\t\t\t\tif(a + dy[i] >= 0 && a + dy[i] < h && b + dx[i] >= 0 && b + dx[i] < w && lf[a + dy[i]][b + dx[i]] == '.' && c + dy[i] >= 0 && c + dy[i] < h && d - dx[i] >= 0 && d - dx[i] < w && rf[c + dy[i]][d - dx[i]] == '.' && s.find(pair<P,P>(P(a + dy[i],b + dx[i]),P(c + dy[i],d - dx[i]))) == s.end()) // 両方とも動くとき\n\t\t\t\t\tl.push(P(a + dy[i],b + dx[i])), r.push(P(c + dy[i],d - dx[i]));\n\t\t\t\telse if((a + dy[i] < 0 || a + dy[i] >= h || b + dx[i] < 0 || b + dx[i] >= w || lf[a + dy[i]][b + dx[i]] == '#') && c + dy[i] >= 0 && c + dy[i] < h && d - dx[i] >= 0 && d - dx[i] < w && rf[c + dy[i]][d - dx[i]] == '.' && s.find(pair<P,P>(P(a,b),P(c + dy[i],d - dx[i]))) == s.end()) // Rinだけ動く\n\t\t\t\t\tl.push(P(a,b)), r.push(P(c + dy[i],d - dx[i]));\n\t\t\t\telse if(a + dy[i] >= 0 && a + dy[i] < h && b + dx[i] >= 0 && b + dx[i] < w && lf[a + dy[i]][b + dx[i]] == '.' && (c + dy[i] < 0 || c + dy[i] >= h || d - dx[i] < 0 || d - dx[i] >= w || rf[c + dy[i]][d - dx[i]] == '#') && s.find(pair<P,P>(P(a + dy[i],b + dx[i]),P(c,d))) == s.end()) // Lenだけ動く\n\t\t\t\t\tl.push(P(a + dy[i],b + dx[i])), r.push(P(c,d));\n\t\t\t}\n\t\t}\n\t\twhile(r.size())\n\t\t\tr.pop(),l.pop();\n\t\tif(s.find(pair<P,P>(P(lg.first,lg.second),P(rg.first,rg.second))) != s.end())\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t\ts.erase(s.begin(),s.end());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP(a, b) make_pair(a, b)\n#define Y first\n#define X second\n#define L first\n#define R second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef pair<pi, pi> pipi;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint W, H;\nint dy[] = {0,-1,0,1}, dx[] = {-1,0,1,0};\nchar len[64][64], rin[64][64];\n\nint main(){\n  while(scanf(\"%d%d\", &W, &H) && W){\n    rep(i, H) scanf(\"%s%s\", len[i], rin[i]);\n\n    int ly, lx, ry, rx;\n    rep(i, H) rep(j, W){\n      if(len[i][j] == 'L'){ ly = i, lx = j; len[i][j] = '.';}\n      if(rin[i][j] == 'R'){ ry = i, rx = j; rin[i][j] = '.';}\n    }\n\n    pipi p = MP(MP(ly, lx), MP(ry, rx));\n    queue<pipi>q;\n    map<pipi, int>m;\n    q.push(p);\n    m[p] = 1;\n\n    while(!q.empty()){\n      int qsize = (int)q.size();\n      rep(i, qsize){\n\tpipi now = q.front(); q.pop();\n\trep(d, 4){\n\t  int nly, nlx, nry, nrx;\n\t  if(d%2){\n\t    nly = now.L.Y + dy[d], nlx = now.L.X;\n\t    if(nly < 0 || nly >= H || len[nly][nlx] == '#') nly = now.L.Y; \n\t    nry = now.R.Y + dy[d], nrx = now.R.X;\n\t    if(nry < 0 || nry >= H || rin[nry][nrx] == '#') nry = now.R.Y; \n\t  }else{\n\t    nly = now.L.Y, nlx = now.L.X + dx[d];\n\t    if(nlx < 0 || nlx >= W || len[nly][nlx] == '#') nlx = now.L.X; \t    \n\t    nry = now.R.Y, nrx = now.R.X + -1*dx[d];\n\t    if(nrx < 0 || nrx >= W || rin[nry][nrx] == '#') nrx = now.R.X;\n\t  }\n\n\t  pipi next = MP(MP(nly, nlx), MP(nry, nrx));\n\t  if(len[nly][nlx] == '%' && rin[nry][nrx] == '%'){\n\t    puts(\"Yes\"); goto e;\n\t  }else if(len[nly][nlx] == '%' || rin[nry][nrx] == '%'){\n\t    continue;\n\t  }\n\n\t  if(m.count(next) != 0) continue;\n\t  m[next] = 1;\n\t  q.push(next);\n\t}\n      }\n    }\n    puts(\"No\");\n  e:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nstruct S {\n\tint ly, lx, ry, rx;\n\n\tS(int _ly, int _lx, int _ry, int _rx) :ly(_ly), lx(_lx), ry(_ry), rx(_rx) {};\n};\n\nconst int MAX = 52;\nconst int ldy[4] = { 0,1,0,-1 };\nconst int ldx[4] = { 1,0,-1,0 };\nconst int rdy[4] = { 0,1,0,-1 };\nconst int rdx[4] = { -1,0,1,0 };\n\nchar l_grid[MAX][MAX];\nchar r_grid[MAX][MAX];\nint visited[MAX][MAX][MAX][MAX];\nbool goal;\n\nint main()\n{\n\twhile (true) {\n\t\tint W, H;\n\t\tcin >> W >> H;\n\n\t\tif (W == 0 && H == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tgoal = false;\n\n\t\tfor (int i = 0; i < MAX; i++) {\n\t\t\tfor (int j = 0; j < MAX; j++) {\n\t\t\t\tl_grid[i][j] = '#';\n\t\t\t\tr_grid[i][j] = '#';\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < MAX; i++) {\n\t\t\tfor (int j = 0; j < MAX; j++) {\n\t\t\t\tfor (int k = 0; k < MAX; k++) {\n\t\t\t\t\tfor (int l = 0; l < MAX; l++) {\n\t\t\t\t\t\tvisited[i][j][k][l] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ly, lx, ry, rx;\n\n\t\tfor (int y = 1; y <= H; y++) {\n\t\t\tfor (int x = 1; x <= W; x++) {\n\t\t\t\tcin >> l_grid[y][x];\n\t\t\t\t\n\t\t\t\tif (l_grid[y][x] == 'L') {\n\t\t\t\t\tly = y;\n\t\t\t\t\tlx = x;\n\t\t\t\t\tl_grid[y][x] = '.';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int x = 1; x <= W; x++) {\n\t\t\t\tcin >> r_grid[y][x];\n\n\t\t\t\tif (r_grid[y][x] == 'R') {\n\t\t\t\t\try = y;\n\t\t\t\t\trx = x;\n\t\t\t\t\tr_grid[y][x] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqueue<S> q;\n\t\tq.push(S(ly, lx, ry, rx));\n\t\tvisited[ly][lx][ry][rx] = true;\n\n\t\twhile (q.empty() == false) {\n\t\t\tint size = q.size();\n\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tS now = q.front();\n\t\t\t\tq.pop();\n\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tint nly, nlx, nry, nrx;\n\n\t\t\t\t\tif (l_grid[now.ly + ldy[j]][now.lx + ldx[j]] == '#') {\n\t\t\t\t\t\tnly = now.ly;\n\t\t\t\t\t\tnlx = now.lx;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnly = now.ly + ldy[j];\n\t\t\t\t\t\tnlx = now.lx + ldx[j];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (r_grid[now.ry + rdy[j]][now.rx + rdx[j]] == '#') {\n\t\t\t\t\t\tnry = now.ry;\n\t\t\t\t\t\tnrx = now.rx;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnry = now.ry + rdy[j];\n\t\t\t\t\t\tnrx = now.rx + rdx[j];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (l_grid[nly][nlx] == '%'&&r_grid[nry][nrx] == '%') {\n\t\t\t\t\t\tgoal = true;\n\t\t\t\t\t\tgoto End;\n\t\t\t\t\t}\n\t\t\t\t\telse if (l_grid[nly][nlx] == '%' || r_grid[nry][nrx] == '%') {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (visited[nly][nlx][nry][nrx] == false) {\n\t\t\t\t\t\tq.push(S(nly, nlx, nry, nrx));\n\t\t\t\t\t\tvisited[nly][nlx][nry][nrx] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tEnd:\n\n\t\tif (goal == true) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint w, h;\nstring l[52], r[52];\nint ldx[4] = {1, 0, -1, 0};\nint ldy[4] = {0, 1, 0, -1};\nint rdx[4] = {1, 0, -1, 0};\nint rdy[4] = {0, -1, 0, 1};\nint lsx, lsy, rsx, rsy, lgx, lgy, rgx, rgy;\nbool lischecked[52][52], rischecked[52][52];\n\nbool solve(int lx, int ly, int rx, int ry){\n    if(lx == lgx && ly == lgy && rx == rgx && ry == rgy) return true;\n    if((lx == lgx && ly == lgy) || (rx == rgx && ry == rgy)) return false;\n    for(int i = 0; i < 4; i++){\n        int nlx = lx + ldx[i], nly = ly + ldy[i];\n        int nrx = rx + rdx[i], nry = ry + rdy[i];\n        if((nlx < 0 || nly < 0 || nlx >= h || nly >= w) && (nrx < 0 || nry < 0 || nrx >= h || nry >= w)) continue;\n        if((l[nlx][nly] == '#' && r[nrx][nry] == '#') || (lischecked[nlx][nly] && rischecked[nrx][nry])) continue;\n        if(nlx < 0 || nlx >= h || nly < 0 || nly >= w || l[nlx][nly] == '#'){\n            nlx = lx;\n            nly = ly;\n        }\n        if(nrx < 0 || nrx >= h || nry < 0 || nry >= w || r[nrx][nry] == '#'){\n            nrx = rx;\n            nry = ry;\n        }\n        lischecked[nlx][nly] = true;\n        rischecked[nrx][nry] = true;\n        if(solve(nlx, nly, nrx, nry)) return true;\n        lischecked[nlx][nly] = false;\n        rischecked[nrx][nry] = false;\n    }\n    return false;\n}\n\nint main()\n{\n    while(1){\n        cin >> w >> h;\n        if(w == 0 && h == 0) break;\n        for(int i = 0; i < h; i++){\n            cin >> l[i] >> r[i];\n        }\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                lischecked[i][j] = false;\n                rischecked[i][j] = false;\n                if(l[i][j] == 'L'){\n                    lsx = i;\n                    lsy = j;\n                }\n                if(l[i][j] == '%'){\n                    lgx = i;\n                    lgy = j;\n                }\n                if(r[i][j] == 'R'){\n                    rsx = i;\n                    rsy = j;\n                }\n                if(r[i][j] == '%'){\n                    rgx = i;\n                    rgy = j;\n                }\n            }\n        }\n        lischecked[lsx][lsy] = true;\n        rischecked[rsx][rsy] = true;\n        if(solve(lsx, lsy, rsx, rsy)) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nint w, h;\nbool vis[64][64][64][64];\npii ls, lg, rs, rg;\nconst int dx[]={0, 0, 1, -1}, dy[]={1, -1, 0, 0};\n\ninline bool border(pii p){\n\treturn 0<=p.first&&p.first<w&&0<=p.second&&p.second<h;\n}\n\nstring solve(vector<string> left, vector<string> right){\n\t\n\tqueue<pii> lqu, rqu;\n\tlqu.push(ls);\n\trqu.push(rs);\n\t\n\tmemset(vis, 0, sizeof(vis));\n\tvis[ls.first][ls.second][rs.first][rs.second] = true;\n\t\n\twhile(!lqu.empty()&&!rqu.empty()){\n\t\n\t\tpii lnx, rnx, lnw, rnw;\n\t\t\n\t\tlnw = lqu.front();\n\t\trnw = rqu.front();\n\t\t\n\t\tlqu.pop();\n\t\trqu.pop();\n\t\t\n\t\tfor(int i=0; i<4; ++i){\n\t\t\t\n\t\t\tlnx = make_pair(lnw.first + dx[i], lnw.second + dy[i]);\n\t\t\trnx = make_pair(rnw.first - dx[i], rnw.second + dy[i]);\n\t\t\t\n\t\t\tif(!border(lnx)||left[lnx.second][lnx.first]=='#')\n\t\t\t\tlnx = lnw;\n\t\t\t\n\t\t\tif(!border(rnx)||right[rnx.second][rnx.first]=='#')\n\t\t\t\trnx = rnw;\n\t\t\t\n\t\t\tif(lnx == lg && rnx == rg)\n\t\t\t\treturn \"Yes\";\n\t\t\t\n\t\t\tif(lnx == lg ^ rnx == rg)\n\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\tif(!vis[lnx.first][lnx.second][rnx.first][rnx.second]){\n\t\t\t\t\n\t\t\t\tvis[lnx.first][lnx.second][rnx.first][rnx.second] = true;\n\t\t\t\tlqu.push(lnx);\n\t\t\t\trqu.push(rnx);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn \"No\";\n}\n\nint main(){\n\t\n\twhile(cin>>w>>h, (w||h)){\n\t\t\n\t\tvector<string> left, right;\n\t\t\n\t\tfor(int i=0; i<h; ++i){\n\t\t\t\n\t\t\tstring l, r;\n\t\t\tcin >> l >> r;\n\t\t\t\n\t\t\tleft.push_back(l);\n\t\t\tright.push_back(r);\n\t\t}\n\t\t\n\t\tfor(int y=0; y<h; ++y){\n\t\t\tfor(int x=0; x<w; ++x){\n\t\t\t\n\t\t\t\tif(left[y][x] == 'L')\n\t\t\t\t\tls = make_pair(x, y);\n\t\t\t\tif(right[y][x] == 'R')\n\t\t\t\t\trs = make_pair(x, y);\n\t\t\t\tif(left[y][x] == '%')\n\t\t\t\t\tlg = make_pair(x, y);\n\t\t\t\tif(right[y][x] == '%')\n\t\t\t\t\trg = make_pair(x, y);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout <<\tsolve(left, right) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<ctime>\n#include<climits>\n#include<queue>\n#include<fstream>\n#include<deque>\n#include<iomanip>\n#include<list>\n#include<stack>\n#include<sstream>\n#include<string>\n#include<cctype>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<cstring>\n#include<iomanip>\n#include<map>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS 1e-10\n#define F first\n#define S second\n#define all(n) n.begin(),n.end()\n#define pb push_back\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define INF (1<<27)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nconst P dx[4] = {P(0,0),P(0,0),P(1,-1),P(-1,1)};\nconst P dy[4] = {P(1,1),P(-1,-1),P(0,0),P(0,0)};\nconst int idx[4] = {0,1,0,-1};\nconst int idy[4] = {1,0,-1,0};\n\nint H,W;\nchar L_cmap[65][65],R_cmap[65][65];\n//stinrg L_cmap[65],R_cmap[65];\nbool L_used[65][65],R_used[65][65];\nP Ls,Rs,Lg,Rg;\nbool fin;\n//vector<string> L_cmap,R_cmap;\n\nvoid dfs(PP pp){\n\n  //cout << \"here\" << endl;\n  if(fin)return;\n      if(pp.F == Lg && pp.S == Rg){\n\tcout << \"Yes\" << endl;\n\tfin = true;\n\treturn;\n      }\n      //cout << \"pp.F = \" << pp.F.F << \",\" << pp.F.S << \" pp.S = \" << pp.S.F << \",\" << pp.S.S << endl;\n      rep(i,4){\n\tint L_nx = pp.F.F + dx[i].F,L_ny = pp.F.S + dy[i].F;\n\tint R_nx = pp.S.F + dx[i].S,R_ny = pp.S.S + dy[i].S;\n\t//cout << \"First next L = \" << L_nx << \",\" << L_ny << \" Pre next R = \" << R_nx << \",\" << R_ny << endl;\n\n\n \tif(!(0<=L_nx && L_nx <W && 0<= R_nx && R_nx <W && 0<= L_ny && L_ny <H && 0<= R_ny && R_ny < H))continue;\n\tif(L_cmap[L_ny][L_nx] != '#' && L_used[L_ny][L_nx])continue;\n\tif(R_cmap[R_ny][R_nx] != '#' && R_used[R_ny][R_nx])continue;\n\tif(L_cmap[L_ny][L_nx] == '#' && R_cmap[R_ny][R_nx] == '#')continue;\n\n\t//cout << \"next L = \" << L_nx << \",\" << L_ny << \" Pre next R = \" << R_nx << \",\" << R_ny << endl;\n\tif(L_cmap[L_ny][L_nx] == '#')L_nx = pp.F.F,L_ny = pp.F.S;\n\tif(R_cmap[R_ny][R_nx] == '#')R_nx = pp.S.F,R_ny = pp.S.S;\n\t\n\tR_used[R_ny][R_nx] = L_used[L_ny][L_nx] = true;\n\t//que.push(insert(L_nx,L_ny,R_nx,R_ny));\n\tif(fin)return;\n\tdfs(insert(L_nx,L_ny,R_nx,R_ny));\n\tif(fin)return;\n\tR_used[R_ny][R_nx] = L_used[L_ny][L_nx] = false;\n      }\n      return;\n}\n   \n\n\nint main(){\n  //clock_t start,end;\n  //start = clock();\n  while(true){\n    cin >> W >> H;\n    if(W+H == 0)break;\n    //L_cmap.clear(),R_cmap.clear();\n    fin = false;\n    int index=0;\n    rep(i,H){\n      string s;\n      cin >> s;\n      //if(i == 0 || s != L_cmap[index])\n      rep(j,W){\n\tL_cmap[i][j] = s[j],L_used[i][j] = false;\n\tif(s[j] == 'L')\n\t  Ls = P(j,i);\n\tif(s[j] == '%')\n\t  Lg = P(j,i);\n      }\n      cin >> s;\n      rep(j,W){\n\tR_cmap[i][j] = s[j],R_used[i][j] = false;\n\tif(s[j] == 'R')\n\t  Rs = P(j,i);\n\tif(s[j] == '%')\n\t  Rg = P(j,i);\n      }\n    }\n    \n    bool L_ok,R_ok;\n    L_ok = R_ok = false;\n    queue<P> que;\n    que.push(Ls);    \n    L_used[Ls.S][Ls.F] = true;\n    while(!que.empty()){\n      P pi = que.front(); que.pop();\n      if(pi == Lg){\n\tL_ok = true;\n\tbreak;\n      }\n      rep(i,4){\n\tint nx = pi.F+idx[i],ny = pi.S+idy[i];\n\tif(!(0<=nx && nx < W && 0<= ny && ny < H) || L_cmap[ny][nx] == '#' || L_used[ny][nx])continue;\n\tL_used[ny][nx] = true;\n\tque.push(P(nx,ny));\n      }\n    }\n    if(!L_ok){\n      cout << \"No\" << endl;\n      continue;\n    }\n    queue<P> R_que;\n    R_que.push(Rs);\n    R_used[Rs.S][Rs.F] = true;\n    while(!R_que.empty()){\n      P pi = R_que.front(); R_que.pop();\n      //cout << \"pi = \" << pi.F << \",\" << pi.S << endl;\n      if(pi == Rg){\n\tR_ok = true;\n\tbreak;\n      }\n      rep(i,4){\n\tint nx = pi.F+idx[i],ny = pi.S+idy[i];\n\tif(!(0<=nx && nx < W && 0<= ny && ny < H) || R_cmap[ny][nx] == '#' || R_used[ny][nx])continue;\n\tR_used[ny][nx] = true;\n\tR_que.push(P(nx,ny));\n      }\n    }\n\n\n    if(!L_ok || !R_ok){\n      //cout << L_ok << \" \" << R_ok << endl;\n      cout << \"No\" << endl;\n      continue;\n    }\n    \n    rep(i,H)rep(j,W)L_used[i][j] = R_used[i][j] = false;\n    L_used[Ls.S][Ls.F] = true,R_used[Rs.S][Rs.F] = true;\n    dfs(insert(Ls.F,Ls.S,Rs.F,Rs.S));\n\n    if(!fin)cout << \"No\" << endl;\n\n  }\n  //end = clock();\n  //cout << setiosflags(ios::fixed) << setprecision(10) << (double)(end-start)/CLOCKS_PER_SEC << endl;\nreturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n //cout<< \"Ls = \" << Ls.F << \" \" << Ls.S << \", Lg = \" << Lg.F << \" \" << Lg.S << \", Rs = \" << Rs.F << \" \" << Rs.S << \", Rg = \" << Rg.F << \" \" << Rg.S << endl; \n    //rep(i,4){\n    //rep(j,51)rep(k,51)R_used[j][k] = L_used[j][k] = false;\n      //if(!(0<= Ls.F+dx[i].F && Ls.F+dx[i].F < W && 0<= Ls.S+dy[i].F && Ls.S+dy[i].F < H  && 0<= Rs.F+dx[i].S && Rs.F+dx[i].S < W  && 0<= Rs.S+dy[i].S && Rs.S+dy[i].S < H))continue;\n      //cout << Ls.F+dx[i].F << \" \" << Ls.S+dy[i].F<< \" \"<< Rs.F+dx[i].S<< \" \" << Rs.S+dy[i].S << endl;\n      //dfs(insert(Ls.F+dx[i].F,Ls.S+dy[i].F,Rs.F+dx[i].S,Rs.S+dy[i].S));\n      //cout << \"----------\" << endl;\n      //}    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,s,n) for(int i=s; i<n; i++)\n#define ALL(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nint w, h;\nint rooml[60][60], roomr[60][60];\nbool memo[3000][3000];\n\nbool dfs(int xl, int yl, int xr, int yr) {\n\tif( memo[yl*(w+2)+xl][yr*(w+2)+xr] ) {\n\t\treturn false;\n\t}\n\tmemo[yl*(w+2)+xl][yr*(w+2)+xr] = true;\n\tconst int dx[4] = {-1, 0, 1, 0};\n\tconst int dy[4] = {0, 1, 0, -1};\n\trep(i, 4) {\n\t\tint nxl = xl + dx[i];\n\t\tint nyl = yl + dy[i];\n\t\tint nxr = xr - dx[i];\n\t\tint nyr = yr + dy[i];\n\t\tint nl = rooml[nyl][nxl];\n\t\tint nr = roomr[nyr][nxr];\n\t\tif( nl==2 && nr==2 ) {\n\t\t\treturn true;\n\t\t}\n\t\telse if( nl==1 && nr==1 ) {\n\t\t\tbool f = dfs(nxl, nyl, nxr, nyr);\n\t\t\tif(f) return true;\n\t\t}\n\t\telse if( nl==1 && nr==0 ) {\n\t\t\tbool f = dfs(nxl, nyl, xr, yr);\n\t\t\tif(f) return true;\n\t\t}\n\t\telse if( nl==0 && nr==1 ) {\n\t\t\tbool f = dfs(xl, yl, nxr, nyr);\n\t\t\tif(f) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\twhile(cin >> w >> h, w||h) {\n\t\tmemset(rooml, 0, sizeof(rooml));\n\t\tmemset(roomr, 0, sizeof(roomr));\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tint xl, yl, xr, yr;\n\t\trep(y, h) {\n\t\t\tstring sl, sr;\n\t\t\tcin >> sl >> sr;\n\t\t\trep(x, w) {\n\t\t\t\tif(sl[x] == 'L') {\n\t\t\t\t\txl = x+1;\n\t\t\t\t\tyl = y+1;\n\t\t\t\t\trooml[y+1][x+1] = 1;\n\t\t\t\t} else {\n\t\t\t\t\trooml[y+1][x+1] = (sl[x]=='%' ? 2 : (sl[x]=='.' ? 1 : 0));\n\t\t\t\t}\n\t\t\t\tif(sr[x] == 'R') {\n\t\t\t\t\txr = x+1;\n\t\t\t\t\tyr = y+1;\n\t\t\t\t\troomr[y+1][x+1] = 1;\n\t\t\t\t} else {\n\t\t\t\t\troomr[y+1][x+1] = (sr[x]=='%' ? 2 : (sr[x]=='.' ? 1 : 0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( dfs(xl, yl, xr, yr) ) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t} else {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nbool vis[50][50][50][50];\nint H,W,dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nstring sl[50],sr[50];\nbool okl(int x,int y){\n\treturn 0<=x&&x<H&&0<=y&&y<W&&sl[x][y]!='#';\n}\nbool okr(int x,int y){\n\treturn 0<=x&&x<H&&0<=y&&y<W&&sr[x][y]!='#';\n}\nvoid bfs(int lx,int ly,int rx,int ry){\n\tqueue<PP> que;\n\tque.push(PP(P(lx,ly),P(rx,ry)));\n\twhile(!que.empty()){\n\t\tPP pp=que.front();\n\t\tque.pop();\n\t\tint lx=pp.fs.fs,ly=pp.fs.sc,rx=pp.sc.fs,ry=pp.sc.sc;\n\t\tvis[lx][ly][rx][ry]=1;\n\t\tif(sl[lx][ly]=='%'||sr[rx][ry]=='%') continue;\n\t\trep(di,4){\n\t\t\tint lnx=lx+dx[di],lny=ly+dy[di],rnx=rx+dx[di],rny=ry+dy[di];\n\t\t\tif(!okl(lnx,lny)) lnx=lx,lny=ly;\n\t\t\tif(!okr(rnx,rny)) rnx=rx,rny=ry;\n\t\t\tif(vis[lnx][lny][rnx][rny]) continue;\n\t\t\tque.push(PP(P(lnx,lny),P(rnx,rny)));\n\t\t}\n\t}\n\t\n}\nint main(){\n\twhile(true){\n\t\tcin>>W>>H;\n\t\tif(H==0) break;\n\t\trep(i,H){\n\t\t\tcin>>sl[i]>>sr[i];\n\t\t\treverse(all(sr[i]));\n\t\t}\n\t\tint lx,ly,rx,ry,ax,ay,bx,by;\n\t\trep(i,H) rep(j,W) if(sl[i][j]=='L') lx=i,ly=j;\n\t\trep(i,H) rep(j,W) if(sr[i][j]=='R') rx=i,ry=j;\n\t\trep(i,H) rep(j,W) if(sl[i][j]=='%') ax=i,ay=j;\n\t\trep(i,H) rep(j,W) if(sr[i][j]=='%') bx=i,by=j;\n\t\trep(i,H) rep(j,W) rep(k,H) rep(h,W) vis[i][j][k][h]=0;\n\t\tbfs(lx,ly,rx,ry);\n\t\tif(vis[ax][ay][bx][by]) puts(\"Yes\");\n\t\telse puts(\"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#define N 50\n#define y1 first.first\n#define x1 first.second\n#define y2 second.first\n#define x2 second.second\nusing namespace std;\n\nvoid bfs();\npair<int,int> P;\npair<P,P> P1;\n\nint w,h,sy1,sx1,sy2,sx2,gy1,gx1,gy2,gx2,ans;\nstring r1[N],r2[N];\nset<P1> visited;\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(!w&&!h) break;\n    for(int i=0;i<h;i++) cin>>r1[i]>>r2[i];\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(r1[i][j]=='L') sy1=i,sx1=j;\n\tif(r1[i][j]=='%') gy1=i,gx1=j;\n\tif(r2[i][j]=='R') sy2=i,sx2=j;\n\tif(r2[i][j]=='%') gy2=i,gx2=j;\n      }\n    ans=0;\n    bfs();\n    if(ans) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n  return 0;\n}\n\nvoid bfs(){\n  int dy[4]={0,-1,0,1},dx[4]={-1,0,1,0};\n  queue<P1> q;\n  P1 k=(P1){(P){sy1,sx1},(P){sy2,sx2}};\n  q.push(k);\n  visited.insert(k);\n  while(!q.empty()){\n    P1 t=q.front(); q.pop();\n    for(int i=0;i<4;i++){\n      int ny1=t.y1+dy[i],nx1=t.x1+dx[i];\n      int ny2=t.y2-dy[i],nx2=t.y2-dx[i];\n      if(ny1<0) ny1=0;\n      if(nx1<0) nx1=0;\n      if(h<=ny1) ny1=h;\n      if(w<=nx1) nx1=w;\n      if(ny2<0) ny2=0;\n      if(nx2<0) nx2=0;\n      if(h<=ny2) ny2=h;\n      if(w<=nx2) nx2=w;\n      if(r1[ny1][nx1]=='#') ny1=t.y1,nx1=t.x1;\n      if(r2[ny2][nx2]=='#') ny2=t.y2,nx2=t.x2;\n      P1 u=(P1){(P){ny1,nx1},(P){ny2,nx2}};\n      if(visited.find(u)!=visited.end()) continue;\n      visited.insert(u);\n      if(ny1==gy1&&nx1==gx1&&ny2==gy2&&nx2==gx2){\n\tans=1;\n\tbreak;\n      }\n    }\n    if(ans) break;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<set>\n#include<queue>\n#include<cmath>\nusing namespace std;\ntypedef vector<int> vi;\nconst int inf=1e9;\nint w,h;\nint ldx[]={-1,0,1,0};\nint ldy[]={0,1,0,-1};\nint rdx[]={1,0,-1,0};\nint rdy[]={0,1,0,-1};\nbool vis[55][55][55][55];\nstring rin[55];\nstring len[55];\nbool treasure;\nint rinsx,rinsy,ringx,ringy,lensx,lensy,lengx,lengy;\nstruct P\n{\n  int ly,lx,ry,rx;\n  P(int ly,int lx,int ry,int rx):ly(ly),lx(lx),ry(ry),rx(rx){};\n};\nvoid bfs(int lx,int ly,int rx,int ry)\n{\n  vis[ly][lx][ry][rx]=true;\n  // lenvis[ly][lx]=true;\n  //rinvis[ry][rx]=true;\n  queue<P> q;\n  q.push(P(ly,lx,ry,rx));\n  while(!q.empty())\n    {\n      P now=q.front();q.pop();\n      int lennx,lenny,rinnx,rinny;\n      bool lengoal=false;\n      bool ringoal=false;\n      for(int k=0;k<4;k++)\n\t{\n\t  lennx=now.lx+ldx[k];\n\t  lenny=now.ly+ldy[k];\n\t  rinnx=now.rx+rdx[k];\n\t  rinny=now.ry+rdy[k];\n\t  if(lennx>=w || lennx<0 || lenny>=h || lenny<0 || len[lenny][lennx]=='#')\n\t    {\n\t      lennx=now.lx;\n\t      lenny=now.ly;\n\t    }\n\t  if(rinnx>=w || rinnx<0 || rinny>=h || rinny<0 || rin[rinny][rinnx]=='#')\n\t    {\n\t      rinnx=now.rx;\n\t      rinny=now.ry;\n\t    }\n\t  if(vis[lenny][lennx][rinny][rinnx])continue;\n\t  if(len[lenny][lennx]=='%') lengoal=true;\n\t  else lengoal=false;\n\t  if(rin[rinny][rinnx]=='%') ringoal=true;\n\t  else ringoal=false;\n\t  if(lengoal && ringoal)\n\t    {\n\t      treasure=true;\n\t      return;\n\t    }\n\t  if((lengoal ||ringoal) && !(lengoal && ringoal)) continue;\n\t  q.push(P(lenny,lennx,rinny,rinnx));\n\t  vis[lenny][lennx][rinny][rinnx]=true;\n\t}\n    }\n}\n\nint main()\n{\n  while(cin >> w >> h && w)\n    {\n      treasure=false;\n      memset(vis,false,sizeof(vis));\n      //memset(lenvis,false,sizeof(lenvis));\n      //memset(rinvis,false,sizeof(rinvis));\n      for(int i=0;i<h;i++)\n\t{\n\t  cin >> len[i] >> rin[i];\n\t}\n      for(int i=0;i<h;i++)\n\t{\n\t  for(int j=0;j<w;j++)\n\t    {\n\t      if(len[i][j]=='L')\n\t\t{\n\t\t  lensy=i;\n\t\t  lensx=j;\n\t\t}\n\t      if(rin[i][j]=='R')\n\t\t{\n\t\t  rinsy=i;\n\t\t  rinsx=j;\n\t\t}\n\t    }\n\t}\n      bfs(lensx,lensy,rinsx,rinsy);\n      if(treasure)\n\t{\n\t  cout << \"Yes\" << endl;\n\t}\n      else\n\t{\n\t  cout << \"No\" << endl;\n\t}\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<int, int> Point;\n\nconst int N = 50;\n\nint w, h;\nchar room[2][N][N];\nbool vis[N][N][N][N];\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = {0, 1, 0, -1};\n\nvoid check(int& y, int& x){\n  if(y < 0) y = 0;\n  if(y >= h) y = h-1;\n  if(x < 0) x = 0;\n  if(x >= w) x = w-1;\n}\n\nbool dfs(Point l, Point r){\n  vis[l.first][l.second][r.first][r.second] = true;\n  if(room[0][l.first][l.second] == '%' && room[1][r.first][r.second] == '%'){\n    return true;\n  }else if(room[0][l.first][l.second] == '%' || room[1][r.first][r.second] == '%'){\n    return false;\n  }else{\n    for(int i=0;i<4;i++){\n      Point nl = Point(l.first + dy[i], l.second + dx[i]);\n      Point nr = Point(r.first + dy[i], r.second - dx[i]);\n      check(nl.first, nl.second);\n      check(nr.first, nr.second);\n      if(room[0][nl.first][nl.second] == '#') nl = l;\n      if(room[1][nr.first][nr.second] == '#') nr = r;\n      if(vis[nl.first][nl.second][nr.first][nr.second]) continue;\n      if(dfs(nl, nr)) return true;\n    }\n  }\n  return false;\n}\n\nmain(){\n  Point l, r;\n  while(cin >> w >> h && (w|h)){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> room[0][i][j];\n        if(room[0][i][j] == 'L'){\n          l = Point(i, j);\n          room[0][i][j] = '.';\n        }\n      }\n      for(int j=0;j<w;j++){\n        cin >> room[1][i][j];\n        if(room[1][i][j] == 'R'){\n          r = Point(i, j);\n          room[1][i][j] = '.';\n        }\n      }      \n    }\n    fill(vis[0][0][0], vis[N][0][0], false);\n    cout << (dfs(l, r) ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//coding on smartphone\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<cstring>\nusing namespace std;\n#define inRange(x,a,b) (a <= x && x < b)\n\nint di[2][4] = {{0, 0, 1, -1}, {0, 0, 1, -1}};\nint dj[2][4] = {{1, -1, 0, 0}, {-1, 1, 0, 0}};\n\nstruct data{\n    int li, lj, ri, rj;\n};\n\nint main(){\n    int w, h;\n    char c;\n    while(cin >> w >> h, w+h){\n        bool dp[h][w][h][w];\n        int li, lj, ri, rj;\n        memset(dp, 0, sizeof(dp));\n        char mat[2][h][w];\n        for(int i = 0; i < h; i++){\n            for(int k = 0; k < 2; k++){\n                for(int j = 0; j < w; j++){\n                    cin >> mat[k][i][j];\n                    if(mat[k][i][j]=='L')   li = i, lj = j;\n                    if(mat[k][i][j]=='R')   ri = i, rj = j;\n                }\n                //if(k == 0) cin >> c;   // space\n            }\n        }\n        bool valid = false;\n        queue<data> q;\n        q.push(data({li,lj,ri,rj}));\n        dp[li][lj][ri][rj] = true;\n        while(!q.empty()){\n            data d = q.front(); q.pop();\n            for(int k = 0; k < 4; k++){\n                int nli = d.li+di[0][k], nlj = d.lj+dj[0][k];\n                int nri = d.ri+di[1][k], nrj = d.rj+dj[1][k];\n                if(!inRange(nli,0,h)||!inRange(nlj,0,w)||mat[0][nli][nlj]=='#') nli = d.li, nlj = d.lj;\n                if(!inRange(nri,0,h)||!inRange(nrj,0,w)||mat[1][nri][nrj]=='#') nri = d.ri, nrj = d.rj;\n                int target = (mat[0][nli][nlj]=='%') + (mat[1][nri][nrj]=='%');\n                if(target == 2){\n                    valid = true;\n                    break;\n                }\n                if(target == 0 && !dp[nli][nlj][nri][nrj]){\n                    dp[nli][nlj][nri][nrj] = true;\n                    q.push(data({nli,nlj,nri,nrj}));\n                }\n            }\n            if(valid)   break;\n        }\n        cout << (valid ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef long long int ll;\n\nP lg, rg;\nint dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0}, h, w;\nll f[50][50][50];\nchar lf[50][51],rf[50][51]; \n\nint range(int a,int b){\n\treturn a >= 0 && a < h && b >= 0 && b < w;\n}\n\nbool dfs(int ly,int lx,int ry,int rx){\n\tint i;\n\tif(lg.first == ly && lg.second == lx || rg.first == ry && rg.second == rx){\n\t\tif(lg.first == ly && lg.second == lx && rg.first == ry && rg.second == rx)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tfor(i = 0;i < 4;i++){\n\t\tif(range(ly + dy[i],lx + dx[i]) && range(ry + dy[i],rx - dx[i])){\n\t\t\tif(lf[ly + dy[i]][lx + dx[i]] != '#' && rf[ry + dy[i]][rx - dx[i]] != '#' && !(f[ly + dy[i]][lx + dx[i]][ry + dy[i]] & (ll)(1 << (rx - dx[i])))){\n\t\t\t\tf[ly + dy[i]][lx + dx[i]][ry + dy[i]] |= (ll)(1 << (rx - dx[i]));\n\t\t\t\tif(dfs(ly + dy[i],lx + dx[i],ry + dy[i],rx - dx[i])) return 1;\n\t\t\t}\n\t\t\telse if(lf[ly + dy[i]][lx + dx[i]] != '#' && rf[ry + dy[i]][rx - dx[i]] == '#' && !(f[ly + dy[i]][lx + dx[i]][ry] & (ll)(1 << rx))){\n\t\t\t\tf[ly + dy[i]][lx + dx[i]][ry] |= (ll)(1 << rx);\n\t\t\t\tif(dfs(ly + dy[i],lx + dx[i],ry,rx)) return 1;\n\t\t\t}\n\t\t\telse if(lf[ly + dy[i]][lx + dx[i]] == '#' && rf[ry + dy[i]][rx - dx[i]] != '#' && !(f[ly][lx][ry + dy[i]] & (ll)(1 << (rx - dx[i])))){\n\t\t\t\tf[ly][lx][ry + dy[i]] |= (ll)(1 << (rx - dx[i]));\n\t\t\t\tif(dfs(ly,lx,ry + dy[i],rx - dx[i])) return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(void){\n\tint i, j;\n\tP rs, ls;\n\twhile(1){\n\t\tscanf(\"%d%d%*c\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tlf[i][j] = getchar();\n\t\t\t\tif(lf[i][j] == 'L'){\n\t\t\t\t\tls = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(lf[i][j] == '%'){\n\t\t\t\t\tlg = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 空白読み飛ばし\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\trf[i][j] = getchar();\n\t\t\t\tif(rf[i][j] == 'R'){\n\t\t\t\t\trs = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(rf[i][j] == '%'){\n\t\t\t\t\trg = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 改行文字読み飛ばし\n\t\t}\n\t\tmemset(f,0,sizeof(f));\n\t\tf[ls.first][ls.second][rs.first] = (ll)(1 << rs.second);\n\t\tif(dfs(ls.first,ls.second,rs.first,rs.second))\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\nconst int size = 51;\nint n, m;\nbool OL[size][size];\nbool OR[size][size];\n\ntypedef vector <string> VS;\n\nvoid init() {\n    for ( int i = 0; i < size; i++ ) {\n        for ( int j = 0; j < size; j++ ) {\n            OL[i][j] = false;\n            OR[i][j] = false;\n        }\n    }\n}\n\n/*\n. : ©RÉÚ®Å«éZ\n# : ÇÌ éZiiüÅ«È¢j\n% : ÚIn\nR : Rin ÌúÊu\nL : Len ÌúÊu\n*/\n\ntypedef pair <int, int> PII;\ntypedef pair <PII, PII> Node;\ntypedef queue <Node> Queue;\n\nint srL, scL, srR, scR;\nint grL, gcL, grR, gcR;\nconst int dr[4] = { 0, 0, 1, -1 };\nconst int dc[4] = { 1, -1, 0, 0 };\nbool used[size][size][size][size];\n\nbool bad( int r, int c ) {\n    return r < 0 || r >= m || c < 0 || c >= n;\n}\n\nbool solve() {\n    Queue Q;\n    Node start( PII( srL, scL ), PII( srR, scR ) );\n    Q.push( start );\n\n    for ( int i = 0; i < m; i++ ) {\n        for ( int j = 0; j < n; j++ ) {\n            for ( int k = 0; k < m; k++ ) {\n                for ( int l = 0; l < n; l++ ) {\n                    used[i][j][k][l] = false;\n                }\n            }\n        }\n    }\n\n    while ( !Q.empty() ) {\n        Node node = Q.front();\n        Q.pop();\n\n        int rL = node.first.first;\n        int cL = node.first.second;\n        int rR = node.second.first;\n        int cR = node.second.second;\n\n        if ( rL == grL && cL == gcL && rR == grR && cR == gcR ) {\n            return true;\n        }\n\n        for ( int k = 0; k < 4; k++ ) {\n            int nrL = rL + dr[k];\n            int ncL = cL + dc[k];\n            int nrR = rR + dr[k];\n            int ncR = cR - dc[k];\n\n            if ( bad( nrL, ncL ) || bad( nrR, ncR ) ) continue;\n            if ( OL[nrL][ncL] ) {\n                nrL = rL;\n                ncL = cL;\n            }\n            if ( OR[nrR][ncR] ) {\n                nrR = rR;\n                ncR = cR;\n            }\n\n            if ( used[nrL][ncL][nrR][ncR] ) continue;\n            used[nrL][ncL][nrR][ncR] = true;\n            Node next_node( PII( nrL, ncL ), PII( nrR, ncR ) );\n            Q.push( next_node );\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n\n        init();\n\n        VS inputL(m), inputR(m);\n        for ( int i = 0; i < m; i++ ) {\n            cin >> inputL[i] >> inputR[i];\n        }\n\n        for ( int i = 0; i < m; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                if ( inputL[i][j] == '#' ) OL[i][j] = true;\n                if ( inputR[i][j] == '#' ) OR[i][j] = true;\n            }\n        }\n\n        for ( int i = 0; i < m; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                if ( inputL[i][j] == 'L' ) {\n                    srL = i;\n                    scL = j;\n                }\n                if ( inputR[i][j] == 'R' ) {\n                    srR = i;\n                    scR = j;\n                }\n                if ( inputL[i][j] == '%' ) {\n                    grL = i;\n                    gcL = j;\n                }\n                if ( inputR[i][j] == '%' ) {\n                    grR = i;\n                    gcR = j;\n                }\n            }\n        }\n\n        cout << ( solve() ? \"Yes\" : \"No\" ) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\ntypedef vector<vvi> vvvi;\n\nint ldx[] = {0, 1, 0, -1};\nint rdx[] = {0, -1, 0, 1};\nint dy[] = {-1, 0, 1, 0};\n\nstruct state {\n\tpii l, r;\n\tstate(pii l, pii r) : l(l), r(r) {};\n};\n\nint main() {\n\tint W, H;\n\twhile(cin >> W >> H, W) {\n\t\tvs roomL(H), roomR(H);\n\t\tint lsx, lsy, rsx, rsy;\n\t\tREP(i, H) {\n\t\t\tcin >> roomL[i] >> roomR[i];\n\t\t\tif(roomL[i].find(\"L\") != string::npos) {\n\t\t\t\tlsx = roomL[i].find(\"L\");\n\t\t\t\tlsy = i;\n\t\t\t}\n\t\t\tif(roomR[i].find(\"R\") != string::npos) {\n\t\t\t\trsx = roomR[i].find(\"R\");\n\t\t\t\trsy = i;\n\t\t\t}\n\t\t}\n\n\t\tvector<vvvi> visited(H, vvvi(W, vvi(H, vi(W))));\n\t\tqueue<state> Q;\n\t\tQ.push(state(make_pair(lsy, lsx), make_pair(rsy, rsx)));\n\t\tvisited[lsy][lsx][rsy][rsx] = 1;\n\t\tbool goal = false;\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.front();\n\t\t\tQ.pop();\n\n\t\t\tif(roomL[st.l.first][st.l.second] == '%' && roomR[st.r.first][st.r.second] == '%') {\n\t\t\t\tgoal = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tREP(d, 4) {\n\t\t\t\tint lny = st.l.first + dy[d];\n\t\t\t\tint lnx = st.l.second + ldx[d];\n\t\t\t\tif(lny < 0 || H <= lny || lnx < 0 || W <= lnx || roomL[lny][lnx] == '#') {\n\t\t\t\t\tlny = st.l.first;\n\t\t\t\t\tlnx = st.l.second;\n\t\t\t\t}\n\t\t\t\tint rny = st.r.first + dy[d];\n\t\t\t\tint rnx = st.r.second + rdx[d];\n\t\t\t\tif(rny < 0 || H <= rny || rnx < 0 || W <= rnx || roomR[rny][rnx] == '#') {\n\t\t\t\t\trny = st.r.first;\n\t\t\t\t\trnx = st.r.second;\n\t\t\t\t}\n\n\t\t\t\tif(!visited[lny][lnx][rny][rnx]) {\n\t\t\t\t\tvisited[lny][lnx][rny][rnx] = 1;\n\t\t\t\t\tQ.push(state(make_pair(lny, lnx), make_pair(rny, rnx)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << (goal ? \"Yes\" : \"No\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_W 50\n#define MAX_H 50\n//深さ優先探索で行けるんじゃないか？\n\n\nint di[4] = {0, -1, 0, 1};\nint dj[4] = {1, 0, -1, 0};\nvector<vector<bool> > Room_L(MAX_H + 2, vector<bool> (MAX_W + 2, false));\nvector<vector<bool> > Room_R(MAX_H + 2, vector<bool> (MAX_W + 2, false));\nint si_L, si_R, sj_L, sj_R, gi_L, gi_R, gj_L, gj_R;  //スタートとゴールの座標\n\n\nint main(){\n\n    while(1){\n\n        //入力\n        int W, H; cin >> W >> H;\n        if(W == 0) break;\n\n        for(int i = 0; i <= H + 1; i++){\n            for(int j = 0; j <= W + 1; j++){\n                Room_L[i][j] = Room_R[i][j] = false;\n            }\n        }\n\n        for(int i = 1; i <= H; i++){\n            //L\n            for(int j = 1; j <= W; j++){\n                char input; cin >> input;\n                if(input == '#') continue;\n                else{\n                    Room_L[i][j] = true;\n\n                    if(input == '%'){\n                        gi_L = i;\n                        gj_L = j;\n                    }\n\n                    if(input == 'L'){\n                        si_L = i;\n                        sj_L = j;\n                    }\n                }\n            }\n\n            //R\n            for(int j = 1; j <= W; j++){\n                char input; cin >> input;\n                if(input == '#') continue;\n                else{\n                    Room_R[i][j] = true;\n\n                    if(input == '%'){\n                        gi_R = i;\n                        gj_R = j;\n                    }\n\n                    if(input == 'R'){\n                        si_R = i;\n                        sj_R = j;\n                    }\n                }\n            }\n        }\n\n\n            //幅優先をする\n        set<pair<pair<int, int>, pair<int, int> > > s;\n        queue<pair<pair<int, int>, pair<int, int> > > wait;                      //左の座標　右の座標\n        wait.push({ {si_L, sj_L}, {si_R, sj_R} });\n        s.insert({ {si_L, sj_L}, {si_R, sj_R} });\n        \n        bool can = false;\n\n        while(!wait.empty()){    //キュー画空になるまで\n\n\n            //キューの先頭要素を取り出す\n            int nowi_L = wait.front().first.first;\n            int nowj_L = wait.front().first.second;\n            int nowi_R = wait.front().second.first;\n            int nowj_R = wait.front().second.second;\n            //cout << nowi_L << \" \" << nowj_L << \"  \" << nowi_R << \" \" << nowj_R << endl;\n            wait.pop();\n\n            //四方向を探索\n            for(int k = 0; k < 4; k++){\n                int nexti_L = nowi_L + di[k];\n                int nextj_L = nowj_L + dj[k];\n                int nexti_R = nowi_R + di[k];\n                int nextj_R = nowj_R - dj[k];\n                //cout << \" \" << nexti_L << \" \" << nextj_L << \"  \" << nexti_R << \" \" << nextj_R << endl;\n\n\n                int L = Room_L[nexti_L][nextj_L];\n                int R = Room_R[nexti_R][nextj_R];\n                //cout << \" \" << L << \" \" << R << endl;\n                \n\n                //その方向に進めるなら\n                if(nexti_L == gi_L && nextj_L == gj_L && nexti_R == gi_R && nextj_R == gj_R){\n                    can = true;\n                    break;\n                }else if((nexti_L == gi_L && nextj_L == gj_L) || (nexti_R == gi_R && nextj_R == gj_R)){\n                    continue;\n                }else if(R && L && s.find({{nexti_L, nextj_L}, {nexti_R, nextj_R}}) == s.end()){\n                    wait.push({{nexti_L, nextj_L}, {nexti_R, nextj_R}});\n                    s.insert({{nexti_L, nextj_L}, {nexti_R, nextj_R}});\n                }else if(R && !L && s.find({{nowi_L, nowj_L}, {nexti_R, nextj_R}}) == s.end()){\n                    wait.push({{nowi_L, nowj_L}, {nexti_R, nextj_R}});\n                    s.insert({{nowi_L, nowj_L}, {nexti_R, nextj_R}});\n                }else if(!R && L && s.find({{nexti_L, nextj_L}, {nowi_R, nowj_R}}) == s.end()){\n                    wait.push({{nexti_L, nextj_L}, {nowi_R, nowj_R}});\n                    s.insert({{nexti_L, nextj_L}, {nowi_R, nowj_R}});\n                }\n            }\n        }\n\n        if(can) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n/* monkukui 競技プログラミング用のテンプレート  (ここから) */\n#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\nusing lint = long long int;\nusing ll = long long int;\nusing lnt = long long int;\nusing graph = vector<vector<int>>;\nusing wgraph = vector<vector<pair<int, long long int>>>;\nlong long int INF = 1001001001001001LL;\nint inf = 100100100;\nlong long int MOD = 1000000007LL;\ndouble PI = 3.1415926535897932;\nlong long int di[] = {-1, 0, 1, 0, -1, 1, 1, -1};\nlong long int dj[] = {0, 1, 0, -1, 1, 1, -1, -1};\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\ninline void yes(){ cout << \"yes\" << endl; }\ninline void Yes(){ cout << \"Yes\" << endl; }\ninline void YES(){ cout << \"YES\" << endl; }\ninline void no(){ cout << \"no\" << endl; }\ninline void No(){ cout << \"No\" << endl; }\ninline void NO(){ cout << \"NO\" << endl; }\ninline void possible(){ cout << \"possible\" << endl; }\ninline void Possible(){ cout << \"Possible\" << endl; }\ninline void POSSIBLE(){ cout << \"POSSIBLE\" << endl; }\ninline void impossible(){ cout << \"impossible\" << endl; }\ninline void Impossible(){ cout << \"Impossible\" << endl; }\ninline void IMPOSSIBLE(){ cout << \"IMPOSSIBLE\" << endl; }\n\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define rrep(i,n) for(int i = 1; i <= (n); i++)\n#define drep(i,n) for(int i = (n)-1; i >= 0; i--)\n#define srep(i,s,t) for(int i = s; i < t; i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define pb push_back\n\n/* monkukui 競技プログラミング用のテンプレート (ここまで)*/\n\nint used[53][53][53][53];\n\nint main(){\n  \n  while(1) {\n\n    int h, w; cin >> h >> w;\n    swap(h, w);\n    if(h == 0) break;\n\n    memset(used, 0, sizeof(used));\n\n    vector<vector<int>> L(h + 2, vector<int> (w + 2, 0));\n    vector<vector<int>> R(h + 2, vector<int> (w + 2, 0));\n    \n    int lsi, lsj, rsi, rsj, lgi, lgj, rgi, rgj;\n    for(int i = 1; i <= h; i++) {\n      for(int j = 1; j <= w; j++) {\n        char c; cin >> c;\n        if(c == '#') continue;\n        L[i][j] = 1;\n        if(c == 'L') {\n          lsi = i;\n          lsj = j;\n        }\n        if(c == '%') {\n          lgi = i;\n          lgj = j;\n        }\n      }\n\n      for(int j = 1; j <= w; j++) {\n        char c; cin >> c;\n        if(c == '#') continue;\n        R[i][j] = 1;\n        if(c == 'R') {\n          rsi = i;\n          rsj = j;\n        }\n        if(c == '%') {\n          rgi = i;\n          rgj = j;\n        }\n      }\n    }\n    \n    queue<pair<pair<int, int>, pair<int, int>>> q;\n    q.push({{lsi, lsj},{rsi, rsj}});\n    used[lsi][lsj][rsi][rsj] = 1;\n    bool ok = false;\n    while(!q.empty()) {\n\n\n      auto hoge = q.front();\n      q.pop();\n      int li = hoge.first.first;\n      int lj = hoge.first.second;\n      int ri = hoge.second.first;\n      int rj = hoge.second.second;\n      \n      if(li == lgi and lj == lgj and ri == rgi and rj == rgj) {\n        ok = true;\n        break;\n      }\n\n      for(int itr = 0; itr < 4; itr++) {\n        // 壁なら進まない\n        int nli = li + di[itr];\n        int nlj = lj + dj[itr];\n        int nri = ri + di[itr];\n        int nrj = rj - dj[itr];\n\n        if(L[nli][nlj] == 0) {\n          nli = li;\n          nlj = lj;\n        }\n\n        if(R[nri][nrj] == 0) {\n          nri = ri;\n          nrj = rj;\n        }\n\n        if(used[nli][nlj][nri][nrj]) continue;\n        if((nli == lgi and nlj == lgj) ^ (nri == rgi and nrj == rgj)) continue;\n\n        used[nli][nlj][nri][nrj] = 1;\n        q.push({{nli, nlj}, {nri, nrj}});\n      }\n    }\n\n    if(ok) Yes();\n    else No();\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<cstring>\n#include<map>\nusing namespace std;\ntypedef pair< int, int > Pi;\n\nbool used[50][50][50][50];\nchar masL[50][50], masR[50][50];\nint W, H;\nPi RinS, LenS; //スタート\nconst int dy[] = { 1, 0, -1, 0}, dx[] = { 0, 1, 0, -1};\n\nint bfs(){\n  queue< Pi > Rin, Len;\n  Rin.push(RinS);\n  Len.push(LenS);\n  used[RinS.first][RinS.second][LenS.first][LenS.second] = true;\n  while(!Rin.empty()){\n    Pi r = Rin.front(), l = Len.front();\n    Rin.pop(), Len.pop();\n    if(masL[l.first][l.second] == '%' && masR[r.first][r.second] == '%'){\n      return true;\n    }\n    if(masL[l.first][l.second] != '%' && masR[r.first][r.second] != '%'){\n      for(int i = 0; i < 4; i++){\n        int rny = min( H - 1, max( 0, r.first + dy[i]));\n        int rnx = min( W - 1, max( 0, r.second + dx[i]));\n        int lny = min( H - 1, max( 0, l.first + dy[i]));\n        int lnx = min( W - 1, max( 0, l.second - dx[i]));\n        //めんどい\n        if(masL[lny][lnx] == '#'){ //元の位置に戻す！！\n          lny = l.first, lnx = l.second;\n        }\n        if(masR[rny][rnx] == '#'){\n          rny = r.first, rnx = r.second;\n        }\n        \n        if(!used[rny][rnx][lny][lnx]){\n          used[rny][rnx][lny][lnx] = true;\n          Rin.push( Pi( rny, rnx)), Len.push( Pi( lny, lnx));\n        }\n      }\n    }\n  }\n  return false; //いけない!!\n}\nint main()\n{\n  while(cin >> W >> H, W){\n    memset( used, false, sizeof(used));\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n        cin >> masL[i][j];\n        if(masL[i][j] == 'L'){\n          LenS = Pi( i, j);\n          masL[i][j] = '.';\n        }\n      }\n      for(int j = 0; j < W; j++){\n        cin >> masR[i][j];\n        if(masR[i][j] == 'R'){\n          RinS = Pi( i, j);\n          masR[i][j] = '.';\n        }\n      }\n    }\n    bool judge = bfs();\n    if(judge) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint ans;\nint h,w;\nstring ma1[55];\nstring ma2[55];\nint dp[55][55][55][55];\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\nstruct node{int a,b,c,d;};\nvoid bfs(int x1,int y1,int x2,int y2){\n  node n=(node){x1,y1,x2,y2};\n  queue<node> q;\n  q.push(n);\n  while(!q.empty()){\n    node t=q.front();\n    q.pop();\n    int lx=t.a;\n    int ly=t.b;\n    int rx=t.c;\n    int ry=t.d;\n    if(ans)continue;\n    if(dp[lx][ly][rx][ry])continue;\n    if(ma1[lx][ly]=='%'&&ma2[rx][ry]=='%'){\n      ans=1;\n      return;\n    }\n    dp[lx][ly][rx][ry]=1;\n    for(int i=0;i<4;i++){\n      int nlx=lx+dx[i];\n      int nly=ly+dy[i];\n      int nrx=rx+dx[i];\n      int nry=ry-dy[i];\n      if(nlx==h||nlx<0)nlx=lx;\n      if(nly==w||nly<0)nly=ly;\n      if(ma1[nlx][nly]=='#')nlx=lx,nly=ly;\n      if(nrx==h||nrx<0)nrx=rx;\n      if(nry==w||nry<0)nry=ry;\n      if(ma2[nrx][nry]=='#')nrx=rx,nry=ry;\n      if(dp[nlx][nly][nrx][nry]==0){\n\tnode d=(node){nlx,nly,nrx,nry};\n\tq.push(d);\n      }\n    }\n  }\n  return;\n}\n\nint main(){\n  while(cin>>w>>h,w+h){\n    ans=0;\n    memset(dp,0,sizeof(dp));\n    int sl[2],sr[2];\n    for(int i=0;i<h;i++){\n      cin>>ma1[i]>>ma2[i];\n      for(int j=0;j<w;j++){\n\tif(ma1[i][j]=='L')sl[0]=i,sl[1]=j;\n\tif(ma2[i][j]=='R')sr[0]=i,sr[1]=j;\n      }\n    }\n    bfs(sl[0],sl[1],sr[0],sr[1]);\n    if(ans)cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef LOCAL\n#include \"../../dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int ll\n#define rep(i,n) for(int i=0,i##_cond=(n);i<i##_cond;++i)\n#define FOR(i,a,b) for(int i=(a),i##_cond=(b);i<i##_cond;++i)\n#define ROF(i,a,b) for(int i=(a)-1,i##_cond=(b);i>=i##_cond;--i)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend() //sortで大きい順\n#define sz(x) ((int)(x).size())\n#define pb push_back\n#define fst first\n#define snd second\n#define mp make_pair\nusing ll  = long long;\nusing vi  = vector<int>;\nusing vvi = vector<vi>;\nusing vs  = vector<string>;\nusing pii = pair<int,int>;\nconstexpr ll inf = 1ll<<61;\nconstexpr ll mod = 1e9+7;\ntemplate<class T>bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T>void add(T &a, const T &b){a += b; a %= mod;}\n\nint h, w;\nvector<vector<vvi>> used;\nvs rooml, roomr;\npii ls, lg, rs, rg;\nvi dx = {0, 1, 0, -1}, dy = {1, 0, -1, 0};\n\nbool isin(pii a){\n  return 0 <= a.fst and a.fst < h and 0 <= a.snd and a.snd < w;\n}\n\nint bfs(pii lp, pii rp){ // sを根としてbfs\n  queue<pair<pii,pii>> q;\n  used[lp.fst][lp.snd][rp.fst][rp.snd] = 1;\n  q.push(make_pair(lp,rp));\n  \n  while(!q.empty()){\n    pair<pii,pii> now = q.front();\n    q.pop();\n    \n    rep(i, 4){\n      pair<pii,pii> next = now;\n      next.fst.fst += dx[i];\n      //dump(next.fst.fst);\n      if(dx[i] != 0 and (next.fst.fst < 0 or h <= next.fst.fst or rooml[next.fst.fst][next.fst.snd] == '#')){ // 移動できない\n\tnext.fst.fst -= dx[i];\n      }\n      next.fst.snd += dy[i];\n      //dump(next.fst.snd);\n      if(dy[i] != 0 and (next.fst.snd < 0 or w <= next.fst.snd or rooml[next.fst.fst][next.fst.snd] == '#')){ // 移動できない\n\tnext.fst.snd -= dy[i];\n      }\n      next.snd.fst += dx[i];\n      //dump(next.snd.fst);\n      if(dx[i] != 0 and (next.snd.fst < 0 or h <= next.snd.fst or roomr[next.snd.fst][next.snd.snd] == '#')){ // 移動できない\n\tnext.snd.fst -= dx[i];\n      }\n      next.snd.snd += dy[i];\n      //dump(next.snd.snd);\n      if(dy[i] != 0 and (next.snd.snd < 0 or w <= next.snd.snd or roomr[next.snd.fst][next.snd.snd] == '#')){ // 移動できない\n\tnext.snd.snd -= dy[i];\n      }\n      if(next == now) continue;\n      if(next.fst == lg and next.snd == rg) return 1;\n      if(used[next.fst.fst][next.fst.snd][next.snd.fst][next.snd.snd] == 0 and next.fst != lg and next.snd != rg){\n\tused[next.fst.fst][next.fst.snd][next.snd.fst][next.snd.snd] = 1;\n\tq.push(next);\n      }\n    }\n  }\n  return 0;\n}\n\nsigned main(){\n  while(cin >> w >> h, w){\n    used.clear();\n    used.resize(h,vector<vvi>(w, vvi(h, vi(w))));\n    rooml.resize(h), roomr.resize(h);\n    rep(i,h){\n      cin >> rooml[i] >> roomr[i];\n      reverse(all(roomr[i])); // 同じ向きに動く\n    }\n    //dump(rooml, roomr);\n    rep(i,h) rep(j,w){\n      if(rooml[i][j] == 'L') ls = pii(i,j);\n      if(rooml[i][j] == '%') lg = pii(i,j);\n      if(roomr[i][j] == 'R') rs = pii(i,j);\n      if(roomr[i][j] == '%') rg = pii(i,j);\n    }\n    //dump(ls,lg,rs,rg);\n    if(bfs(ls, rs)) cout << \"Yes\\n\";\n    else cout << \"No\\n\";\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nint W, H;\nstruct pos\n{\n\tint x, y, dis;\n};\nint main() {\n\n\twhile (cin >> W >> H, W | H){\n\t\tvector<string> vsl;\n\t\tvector<string> vsr;\n\t\tREP(i, H){\n\t\t\tstring l;\n\t\t\tstring r;\n\t\t\tcin >> l >> r;\n\t\t\tvsl.push_back(l);\n\t\t\tvsr.push_back(r);\n\t\t}\n\t\tvector<vector<int>> vvil(H);\n\t\tvector<vector<int>> vvir(H);\n\t\tint glx;\n\t\tint gly;\n\t\tint grx;\n\t\tint gry;\n\t\tint lx;\n\t\tint ly;\n\t\tint rx;\n\t\tint ry;\n\t\tREP(i, H){\n\t\t\tREP(j, W){\n\t\t\t\tif (vsl[i][j] == '#')vvil[i].push_back(-1);\n\t\t\t\telse vvil[i].push_back(9999);\n\n\t\t\t\tif (vsr[i][j] == '#')vvir[i].push_back(-1);\n\t\t\t\telse vvir[i].push_back(9999);\n\n\t\t\t\tif (vsl[i][j] == 'L'){\n\t\t\t\t\tlx = j;\n\t\t\t\t\tly = i;\n\t\t\t\t}\n\t\t\t\tif (vsr[i][j] == 'R'){\n\t\t\t\t\trx = j;\n\t\t\t\t\try = i;\n\t\t\t\t}\n\t\t\t\tif (vsl[i][j] == '%'){\n\t\t\t\t\tglx = j;\n\t\t\t\t\tgly = i;\n\t\t\t\t}\n\t\t\t\tif (vsr[i][j] == '%'){\n\t\t\t\t\tgrx = j;\n\t\t\t\t\tgry = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<pos> vp;\n\t\tvp.push_back({ glx, gly, 0 });\n\t\tvvil[gly][glx] = 0;\n\t\twhile (!vp.empty()){\n\t\t\tpos p = vp[0];\n\t\t\tvp.erase(vp.begin());\n\t\t\tREP(i, 4){\n\t\t\t\tif (p.x + dx[i] >= 0 && p.x + dx[i] < W&&p.y + dy[i] >= 0 && p.y + dy[i] < H&& vvil[p.y + dy[i]][p.x + dx[i]] != -1 && vvil[p.y + dy[i]][p.x + dx[i]] == 9999){\n\t\t\t\t\tvp.push_back({ p.x + dx[i], p.y + dy[i], p.dis + 1 });\n\t\t\t\t\tvvil[p.y + dy[i]][p.x + dx[i]] = p.dis + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvp.push_back({ grx, gry, 0 });\n\t\tvvir[gry][grx] = 0;\n\t\twhile (!vp.empty()){\n\t\t\tpos p = vp[0];\n\t\t\tvp.erase(vp.begin());\n\t\t\tREP(i, 4){\n\t\t\t\tif (p.x + dx[i] >= 0 && p.x + dx[i] < W&&p.y + dy[i] >= 0 && p.y + dy[i] < H&& vvir[p.y + dy[i]][p.x + dx[i]] != -1 && vvir[p.y + dy[i]][p.x + dx[i]] == 9999){\n\t\t\t\t\tvp.push_back({ p.x + dx[i], p.y + dy[i], p.dis + 1 });\n\t\t\t\t\tvvir[p.y + dy[i]][p.x + dx[i]] = p.dis + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<int> vi;\n\t\tvi.push_back(lx * 1000000 + ly * 10000 + rx * 100 + ry);\n\t\tint count = 0;\n\t\tint pcount = 1;\n\t\tbool clear = false;\n\t\twhile (1){\n\t\t\t/*if (vi[count] == glx * 1000000 + gly * 10000 + grx * 100 + gry){\n\t\t\t\tclear = true;\n\t\t\t\tbreak;\n\t\t\t\t}*/\n\t\t\tint lx2 = vi[count] / 1000000 % 100;\n\t\t\tint ly2 = vi[count] / 10000 % 100;\n\t\t\tint rx2 = vi[count] / 100 % 100;\n\t\t\tint ry2 = vi[count] % 100;\n\n\t\t\tREP(i, 4){\n\t\t\t\tint lx3 = lx2;\n\t\t\t\tint ly3 = ly2;\n\t\t\t\tint rx3 = rx2;\n\t\t\t\tint ry3 = ry2;\n\t\t\t\tif (dx[i] != 0 && lx3 + dx[i] >= 0 && lx3 + dx[i] < W && vsl[ly3 + dy[i]][lx3 + dx[i]] != '#')lx3 += dx[i];\n\t\t\t\tif (dy[i] != 0 && ly3 + dy[i] >= 0 && ly3 + dy[i] < H && vsl[ly3 + dy[i]][lx3 + dx[i]] != '#')ly3 += dy[i];\n\t\t\t\tif (dx[i] != 0 && rx3 - dx[i] >= 0 && rx3 - dx[i] < W && vsr[ry3 + dy[i]][rx3 - dx[i]] != '#')rx3 -= dx[i];\n\t\t\t\tif (dy[i] != 0 && ry3 + dy[i] >= 0 && ry3 + dy[i] < H && vsr[ry3 + dy[i]][rx3 - dx[i]] != '#')ry3 += dy[i];\n\t\t\t\tif (find(vi.begin(), vi.end(), lx3 * 1000000 + ly3 * 10000 + rx3 * 100 + ry3) == vi.end() && vvil[ly3][lx3] != 0 && vvir[ry3][rx3] != 0)vi.push_back(lx3 * 1000000 + ly3 * 10000 + rx3 * 100 + ry3);\n\t\t\t\tif (lx3 == glx&&ly3 == gly&&rx3 == grx&&ry3 == gry)clear = true;\n\t\t\t}\n\t\t\tif (clear)break;\n\t\t\tif (count + 1 == vi.size())break;\n\t\t\tint min = 10000;\n\t\t\tint i2 = 0;\n\n\t\t\tFOR(i, count + 1, vi.size()){\n\t\t\t\tif (vvil[(vi[i] / 10000 % 100)][(vi[i] / 1000000 % 100)] + vvir[(vi[i] % 100)][(vi[i] / 100 % 100)] < min){\n\t\t\t\t\tmin = vvil[(vi[i] / 10000 % 100)][(vi[i] / 1000000 % 100)] + vvir[(vi[i] % 100)][(vi[i] / 100 % 100)];\n\t\t\t\t\ti2 = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (vvil[ly2][lx2] + vvir[ry2][rx2] < min)break;\n\t\t\tswap(vi[count + 1], vi[i2]);\n\n\t\t\tcount++;\n\t\t}\n\n\t\tif (clear)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint lsx, lsy, ltx, lty, rsx, rsy, rtx, rty;\nbool dfs(vector<vector<vvi>> &dp, int lx, int ly, int rx, int ry) {\n\tif (dp[ly][lx][ry][rx] != -1)return dp[ly][lx][ry][rx];\n\treturn true;\n}\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint w, h;\n\twhile (cin >> w >> h, w) {\n\t\tvector<string> l(h), r(h);\n\t\tREP(i, h) cin >> l[i] >> r[i];\n\n\t\tREP(i, h) {\n\t\t\tREP(j, h) {\n\t\t\t\tif (l[i][j] == '%') {\n\t\t\t\t\tltx = j; lty = i;\n\t\t\t\t}\n\t\t\t\tif (l[i][j] == 'L') {\n\t\t\t\t\tlsx = j; lsy = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tREP(i, h) {\n\t\t\tREP(j, h) {\n\t\t\t\tif (r[i][j] == '%') {\n\t\t\t\t\trtx = j; rty = i;\n\t\t\t\t}\n\t\t\t\tif (r[i][j] == 'R') {\n\t\t\t\t\trsx = j; rsy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<vector<vvi>> dp(h, vector<vvi>(w, vvi(h, vi(w, -1))));\n\t\tqueue<pair<pii, pii>> q;\n\t\tvector<vector<vvi>> b(h, vector<vvi>(w, vvi(h, vi(w, 0))));\n\t\tq.push(pair<pii, pii>(pii(lsx, lsy), pii(rsx, rsy)));\n\t\tb[lsy][lsx][rsy][rsx] = 1;\n\t\twhile (!q.empty()) {\n\t\t\tauto a = q.front(); q.pop();\n\t\t\tint lx = a.first.first, ly = a.first.second, rx = a.second.first, ry = a.second.second;\n\t\t\tif (lx == ltx&&ly == lty&&rx == rtx&&ry == rty) {\n\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\tgoto a;\n\t\t\t}\n\n\t\t\tREP(i, 4) {\n\t\t\t\tint lnx = lx + dx[i * 2], lny = ly + dy[i * 2], rnx = rx + dx[(i + 2 * (i % 2 == 0)) * 2 % 8], rny = ry + dy[(i + 2 * (i % 2 == 0)) * 2 % 8];\n\t\t\t\tif (lnx < 0 || lnx >= w || lny < 0 || lny >= h ){ \n\t\t\t\t\tlny = ly; lnx = lx;\n\t\t\t\t}\n\t\t\t\telse if (l[lny][lnx] == '#') {\n\t\t\t\t\tlny = ly; lnx = lx;\n\t\t\t\t}\n\t\t\t\tif (rnx < 0 || rnx >= w || rny < 0 || rny >= h ) {\n\t\t\t\t\trny = ry; rnx = rx;\n\t\t\t\t}\n\t\t\t\telse if (r[rny][rnx] == '#') {\n\t\t\t\t\trny = ry; rnx = rx;\n\t\t\t\t}\n\t\t\t\tif ((lnx!=lx||lny!=ly||rnx!=rx||rny!=ry)&& b[lny][lnx][rny][rnx]!=1) {\n\t\t\t\t\n\t\t\t\t\tq.push(pair<pii, pii>(pii(lnx, lny), pii(rnx, rny)));\n\t\t\t\t\tb[lny][lnx][rny][rnx] = 1;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << \"No\" << endl;\n\n\ta:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cstdio>\nusing namespace std;\n\nstruct Data{int x[2],y[2];};\nData start,goal;\n\nint W,H;\nvector< vector<string> >room(2);\n\nint dx[2][4]={{0,1,0,-1}, {0,-1,0,1}};\nint dy[2][4]={{-1,0,1,0}, {-1,0,1,0}};\n\nbool operator<(Data a, Data b){\n  return a.x[0]!=b.x[0]?a.x[0]<b.x[0]:(a.y[0]!=b.y[0]?a.y[0]<b.y[0]:(\n           a.x[1]!=b.x[1]?a.x[1]<b.x[1]:a.y[1]<b.y[1]\n         ));\n}\nbool operator==(Data a, Data b){\n  return a.x[0]==b.x[0] && a.x[1]==b.x[1] && a.y[0]==b.y[0] && a.y[1]==b.y[1];\n}\nbool over(Data a){\n  return a.x[0]<0 || W<=a.x[0] || a.y[0]<0 || H<=a.y[0] ||\n         a.x[1]<0 || W<=a.x[1] || a.y[1]<0 || H<=a.y[1];\n}\n\nbool bfs()\n{\n  queue<Data>q;\n  q.push(start);\n  map<Data,bool>visited;\n\n  while(!q.empty()){\n    Data now=q.front();\n    q.pop();\n\n    visited[now]=true;\n\n    if(now==goal)return true;\n    if(now.x[0]==goal.x[0] && now.y[0]==goal.y[0])continue;\n    if(now.x[1]==goal.x[1] && now.y[1]==goal.y[1])continue;\n\n    for(int i=0;i<4;i++){\n      Data next=now;\n      for(int j=0;j<2;j++){\n\tnext.x[j]+=dx[j][i];\n\tnext.y[j]+=dy[j][i];\n\tif(over(next)){\n\t  next.x[j]=now.x[j];\n\t  next.y[j]=now.y[j];\n\t}\n\tif(room[j][next.y[j]][next.x[j]]=='#'){\n\t  next.x[j]=now.x[j];\n\t  next.y[j]=now.y[j];\n\t}\n      }\n      if(visited.count(next))continue;\n      q.push(next);\n    }\n  }\n\n  return false;\n}\n\nint main()\n{\n  while(cin>>W>>H,W|H){\n    room[0].resize(H);\n    room[1].resize(H);\n    for(int i=0;i<H;i++){\n      cin>>room[0][i]>>room[1][i];\n      for(int j=0;j<W;j++){\n\tif(room[0][i][j]=='L'){\n\t  start.x[0]=j;\n\t  start.y[0]=i;\n\t}\n\tif(room[1][i][j]=='R'){\n\t  start.x[1]=j;\n\t  start.y[1]=i;\n\t}\n\tif(room[0][i][j]=='%'){\n\t  goal.x[0]=j;\n\t  goal.y[0]=i;\n\t}\n\tif(room[1][i][j]=='%'){\n\t  goal.x[1]=j;\n\t  goal.y[1]=i;\n\t}\n      }\n    }\n\n    puts(bfs()?\"Yes\":\"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstring>\n#include <iostream>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nconst int dx1[4] = { 0, 1, 0, -1 };\nconst int dy1[4] = { -1, 0, 1, 0 };\nconst int dx2[4] = { 0, -1, 0, 1 };\nconst int dy2[4] = { -1, 0, 1, 0 };\n\nint H, W; string L[50], R[50];\n\nbool used[50][50][50][50];\n\nbool over(int x, int y)\n{\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\nbool solve(int lx, int ly, int rx, int ry)\n{\n\tused[ly][lx][ry][rx] = true;\n\n\tif (L[ly][lx] == '%' && R[ry][rx] == '%') return true;\n\n\tif (L[ly][lx] == '%') return false;\n\tif (R[ry][rx] == '%') return false;\n\n\tbool ok = false;\n\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint ltx = lx + dx1[i];\n\t\tint lty = ly + dy1[i];\n\t\tint rtx = rx + dx2[i];\n\t\tint rty = ry + dx2[i];\n\n\t\tif (over(ltx, lty) && over(rtx, rty))\n\t\t{\n\t\t\tif (L[lty][ltx] != '#' && R[rty][rtx] != '#')\n\t\t\t{\n\t\t\t\tif (!used[lty][ltx][rty][rtx])\n\t\t\t\t{\n\t\t\t\t\tok |= solve(ltx, lty, rtx, rty);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ok;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &W);\n\t\tscanf(\"%d\", &H);\n\n\t\tfor (int i = 0; i < H; i++) cin >> L[i] >> R[i];\n\n\t\tint lx, ly, rx, ry;\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (L[i][j] == 'L')\n\t\t\t\t{\n\t\t\t\t\tlx = j;\n\t\t\t\t\tly = i;\n\t\t\t\t}\n\n\t\t\t\tif (R[i][j] == 'R')\n\t\t\t\t{\n\t\t\t\t\trx = j;\n\t\t\t\t\try = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(used, false, sizeof(used));\n\n\t\tprintf(\"%s\\n\", solve(lx, ly, rx, ry) ? \"Yes\" : \"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\n\ntemplate<class T>\ninline bool chmax(T &a, const T &b) {\n    if(a<b) {\n        a=b;\n        return true;\n    }\n\n    return false;\n}\ntemplate<class T>\ninline bool chmin(T &a, const T &b) {\n    if(a>b) {\n        a=b;\n        return true;\n    }\n\n    return false;\n}\n\nint W,H;\nstring roomL[51],roomR[51];\n\nbool ok(P len,P rin) {\n    bool visited[51][51][51][51]={};\n    visited[len.fr][len.sc][rin.fr][rin.sc]=true;\n    queue<PP> que;\n    que.push(PP(len,rin));\n\n    while(que.size()) {\n        PP pp=que.front(); que.pop();\n        P next_len=pp.fr;\n        P next_rin=pp.sc;\n\n        //printf(\"[debug] %d %d %d %d\\n\",next_len.fr,next_len.sc,next_rin.fr,next_rin.sc);\n\n        if(roomL[next_len.fr][next_len.sc]=='%' && roomR[next_rin.fr][next_rin.sc]=='%') {\n            return true;\n        }\n        if(roomL[next_len.fr][next_len.sc]=='%' || roomR[next_rin.fr][next_rin.sc]=='%') {\n            visited[next_len.fr][next_len.sc][next_rin.fr][next_rin.sc]=false;\n            continue;\n        }\n        rep(i,4) {\n            next_len=pp.fr;\n            next_rin=pp.sc;\n\n            next_len.fr+=dy[i];\n            next_len.sc+=dx[i];\n            next_rin.fr+=dy[i];\n            next_rin.sc-=dx[i];\n            if(roomL[next_len.fr][next_len.sc]=='#') {\n                next_len.fr-=dy[i];\n                next_len.sc-=dx[i];\n            }\n            if(roomR[next_rin.fr][next_rin.sc]=='#') {\n                next_rin.fr-=dy[i];\n                next_rin.sc+=dx[i];\n            }\n\n            chmax(next_len.fr,0);\n            chmin(next_len.fr,H-1);\n            chmax(next_len.sc,0);\n            chmin(next_len.sc,W-1);\n            chmax(next_rin.fr,0);\n            chmin(next_rin.fr,H-1);\n            chmax(next_rin.sc,0);\n            chmin(next_rin.sc,W-1);\n\n\n            if(!visited[next_len.fr][next_len.sc][next_rin.fr][next_len.sc]) {\n                visited[next_len.fr][next_len.sc][next_rin.fr][next_len.sc]=true;\n                que.push(PP(next_len,next_rin));\n            }\n        }\n    }\n\n    return false;\n}\n\nvoid solve() {\n    rep(y,H) cin>>roomL[y]>>roomR[y];\n    P len,rin;\n    rep(y,H) rep(x,W) {\n        if(roomL[y][x]=='L') len=P(y,x);\n        if(roomR[y][x]=='R') rin=P(y,x);\n    }\n    if(ok(len,rin)) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n}\n\nint main() {\n    while(cin>>W>>H) {\n        if(!W) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) for(auto x : v){cout << x << \" \";} cout << endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(vv) for(auto v : vv){for(auto&& x : v){cout << x << \" \";}cout << endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\ntypedef vector<vector<int>> Graph;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nint a[5000][5000];\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    cout << 123 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> P;\n\nstruct state{\n    int ly, lx, ry, rx;\n};\nint w, h;\nbool contain(int y, int x){\n    return (0 <= y && y < h && 0 <= x && x < w);\n}\nint dy[4] = {1, -1, 0, 0};\nint dx[4] = {0, 0, 1, -1};\nbool f[51][51][51][51];\n\nsigned main(){\n    while(1){\n        cin >> w >> h;\n        if(w + h == 0) break;\n        vector<string> s(h), t(h);\n        bool ans = false;\n        int lsy, lsx, lgy, lgx, rsy, rsx, rgy, rgx;\n        rep(i, 0, h){\n            cin >> s[i] >> t[i];\n            rep(j, 0, w){\n                if(s[i][j] == 'L'){ lsy = i; lsx = j;}\n                if(s[i][j] == '%'){ lgy = i; lgx = j;}\n                if(t[i][j] == 'R'){ rsy = i; rsx = j;}\n                if(t[i][j] == '%'){ rgy = i; rgx = j;}\n            }\n        }\n        queue<state> q;\n        q.push((state){lsy, lsx, rsy, rsx});\n        rep(i, 0, 51) rep(j, 0, 5) rep(k, 0, 51) rep(l, 0, 51) f[i][j][k][l] = false;\n        f[lsy][lsx][rsy][rsx] = true;\n        while(!q.empty()){\n            state p = q.front(); q.pop();\n            // cout << p.ly << \" \" << p.lx << \" \" << p.ry << \" \" << p.rx << endl;\n            rep(i, 0, 4){\n                int nly = p.ly + dy[i];\n                int nlx = p.lx + dx[i];\n                int nry = p.ry + dy[i];\n                int nrx = p.rx - dx[i];\n                if(!contain(nly, nlx) || s[nly][nlx] == '#'){ nly = p.ly; nlx = p.lx;}\n                if(!contain(nry, nrx) || t[nry][nrx] == '#'){ nry = p.ry; nrx = p.rx;}\n                if(f[nly][nlx][nry][nrx]) continue;\n                f[nly][nlx][nry][nrx] = true;\n                if(s[nly][nlx] == '%' && t[nry][nrx] == '%'){ ans = true; break;}\n                if(s[nly][nlx] == '%' || t[nry][nrx] == '%') continue;\n                q.push((state){nly, nlx, nry, nrx});\n            }\n        }\n        cout << (ans ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint w, h;\nstring l[51], r[51];\nint ldx[4] = {1, 0, -1, 0};\nint ldy[4] = {0, 1, 0, -1};\nint rdx[4] = {1, 0, -1, 0};\nint rdy[4] = {0, -1, 0, 1};\nint lsx, lsy, rsx, rsy, lgx, lgy, rgx, rgy;\nbool lischecked[51][51], rischecked[51][51];\n\nbool solve(int lx, int ly, int rx, int ry){\n    if(lx == lgx && ly == lgy && rx == rgx && ry == rgy) return true;\n    if((lx == lgx && ly == lgy) || (rx == rgx && ry == rgy)) return false;\n    for(int i = 0; i < 4; i++){\n        int nlx = lx + ldx[i], nly = ly + ldy[i];\n        int nrx = rx + rdx[i], nry = ry + rdy[i];\n        if((nlx < 0 || nly < 0 || nlx >= h || nly >= w) && (nrx < 0 || nry < 0 || nrx >= h || nry >= w)) continue;\n        if(nlx < 0 || nlx >= h || nly < 0 || nly >= w){\n            nlx = lx;\n            nly = ly;\n        }\n        if(nrx < 0 || nrx >= h || nry < 0 || nry >= w){\n            nrx = rx;\n            nry = ry;\n        }\n        if((l[nlx][nly] == '#' && r[nrx][nry] == '#') || (lischecked[nlx][nly] && rischecked[nrx][nry])) continue;\n        if(l[nlx][nly] == '#'){\n            nlx = lx;\n            nly = ly;\n        }\n        if(r[nrx][nry] == '#'){\n            nrx = rx;\n            nry = ry;\n        }\n        lischecked[nlx][nly] = true;\n        rischecked[nrx][nry] = true;\n        if(solve(nlx, nly, nrx, nry)) return true;\n        lischecked[nlx][nly] = false;\n        rischecked[nrx][nry] = false;\n    }\n    return false;\n}\n\nint main()\n{\n    while(1){\n        cin >> w >> h;\n        if(w == 0 && h == 0) break;\n        for(int i = 0; i < h; i++){\n            cin >> l[i] >> r[i];\n        }\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                lischecked[i][j] = false;\n                rischecked[i][j] = false;\n                if(l[i][j] == 'L'){\n                    lsx = i;\n                    lsy = j;\n                }\n                if(l[i][j] == '%'){\n                    lgx = i;\n                    lgy = j;\n                }\n                if(r[i][j] == 'R'){\n                    rsx = i;\n                    rsy = j;\n                }\n                if(r[i][j] == '%'){\n                    rgx = i;\n                    rgy = j;\n                }\n            }\n        }\n        lischecked[lsx][lsy] = true;\n        rischecked[rsx][rsy] = true;\n        if(solve(lsx, lsy, rsx, rsy)) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<tuple>\n#include<string>\nusing namespace std;\n\n#define MAX_N 60\n#define INF 1<<30\n\nint dist[MAX_N][MAX_N][MAX_N][MAX_N];\nint dy1[4] = { 0,1,0,-1 };\nint dy2[4] = { 0,1,0,-1 };\nint dx1[4] = { 1,0,-1,0 };\nint dx2[4] = { -1,0,1,0 };\nint H, W, map1[MAX_N][MAX_N], map2[MAX_N][MAX_N];\nint Lsy, Lsx, Lgy, Lgx;\nint Rsy, Rsx, Rgy, Rgx;\nstring S, T;\nqueue<tuple<int, int, int, int>>Q;\n\nvoid _memset() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tfor (int k = 0; k < MAX_N; k++) {\n\t\t\t\tfor (int l = 0; l < MAX_N; l++) {\n\t\t\t\t\tdist[i][j][k][l] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tmap1[i][j] = 1;\n\t\t\tmap2[i][j] = 1;\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\t_memset();\n\t\tcin >> H >> W;\n\t\tif (H == 0 && W == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tcin >> S >> T;\n\t\t\tfor (int j = 0; j < S.size(); j++) {\n\t\t\t\tif (S[i] == '%') {\n\t\t\t\t\tLsx = j + 1; Lsy = i;\n\t\t\t\t\tmap1[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\tif (S[i] == '#') {\n\t\t\t\t\tmap1[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (S[i] == '.') {\n\t\t\t\t\tmap1[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (S[i] = 'L') {\n\t\t\t\t\tLgy = i; Lgx = j + 1;\n\t\t\t\t\tmap1[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < T.size(); j++) {\n\t\t\t\tif (T[i] == '%') {\n\t\t\t\t\tRsx = j + 1; Rsy = i;\n\t\t\t\t\tmap2[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\tif (S[i] == '#') {\n\t\t\t\t\tmap2[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (S[i] == '.') {\n\t\t\t\t\tmap2[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (S[i] = 'L') {\n\t\t\t\t\tRgy = i; Rgx = j + 1;\n\t\t\t\t\tmap2[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQ.push(make_tuple(Lsy, Lsx, Rsy, Rsx));\n\t\tdist[Lsy][Lsx][Rsy][Rsx] = 0;\n\n\t\twhile (!Q.empty()) {\n\t\t\ttuple<int, int, int, int>tup = Q.front(); Q.pop();\n\t\t\tint ay = get<0>(tup);\n\t\t\tint ax = get<1>(tup);\n\t\t\tint by = get<2>(tup);\n\t\t\tint bx = get<3>(tup);\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint ey = ay + dy1[i], ex = ax + dx1[i];\n\t\t\t\tint fy = by + dy2[i], fx = bx + dx2[i];\n\t\t\t\tif (dist[ey][ex][fy][fx] == INF) {\n\t\t\t\t\tdist[ey][ex][fy][fx] = 0;\n\t\t\t\t\tQ.push(make_tuple(ey, ex, fy, fx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[Lgy][Lgx][Rgy][Rgx] == INF) {\n\t\t\tcout << \"no\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"yes\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\nusing namespace std;\nstring s1[50],s2[50];\nint dx1[]={1,-1,0,0,},dy1[]={0,0,1,-1};\nint dx2[]={-1,1,0,0,},dy2[]={0,0,1,-1};\nint w,h,gx1,gx2,gy1,gy2;\nunordered_set<int>s;\nbool bfs(int x1,int y1,int x2,int y2){\n  queue<int>q;\n  q.push(x1+y1*100+x2*10000+y2*1000000);\n  while(!q.empty()){\n    int p=q.front();q.pop();\n    x1=p%100;y1=p%10000/100;\n    x2=p%1000000/10000;y2=p/1000000;\n    if(x1==gx1&&y1==gy1&&(x2!=gx2||y2!=gy2))continue;\n    if((x1!=gx1||y1!=gy1)&&x2==gx2&&y2==gy2)continue;\n    if(x1==gx1&&y1==gy1&&x2==gx2&&y2==gy2){\n      while(!q.empty())q.pop();\n      return 1;\n    }\n    for(int i=0;i<4;i++){\n      int x3=x1+dx1[i],y3=y1+dy1[i];\n      int x4=x2+dx2[i],y4=y2+dy2[i];\n      if(x3>=0&&x4>=0&&y3>=0&&y4>=0)\n        if(x3<w&&x4<w&&y3<h&&y4<h){\n          if(s1[y3][x3]=='#')y3=y1,x3=x1;\n          if(s2[y4][x4]=='#')y4=y2,x4=x2;\n          if(!s.count(x3+y3*100+x4*10000+y4*1000000)){\n            s.insert(x3+y3*100+x4*10000+y4*1000000);\n            q.push(x3+y3*100+x4*10000+y4*1000000);\n          }\n        }\n      }\n    }\n    return 0;\n}\nint main(){\n  int x1,y1,x2,y2;\n  while(cin>>w>>h,w){\n    s.clear();\n    r(i,h)cin>>s1[i]>>s2[i];\n    r(i,h)r(j,w){\n      if(s1[i][j]=='L')x1=j,y1=i;\n      if(s2[i][j]=='R')x2=j,y2=i;\n      if(s1[i][j]=='%')gx1=j,gy1=i;\n      if(s2[i][j]=='%')gx2=j,gy2=i;\n    }\n    s.insert(x1+y1*100+x2*10000+y2*1000000);\n    if(bfs(x1,y1,x2,y2))cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// テ・ツ淞コテヲツ慊ャテ」ツδ?」ツδウテ」ツδ療」ツδャテ」ツδシテ」ツδ?\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[2][4] = { {0, 0, 1, -1}, {0, 0, 1, -1} };\nint dy[2][4] = { {1, -1, 0, 0}, {-1, 1, 0, 0} };\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nconst int S = 51;\n// ax, ay, bx, by\nint step[S][S][S][S];\nbool visited[S][S][S][S];\nint W, H;\n\nstruct Elem {\n    int ax, ay, bx, by;\n};\n\npii search_p(vector<string> &vs, char target) {\n    rep(i,0,H) rep(j,0,W) {\n        if(vs[i][j] == target) return make_pair(i, j);\n    }\n}\n\nvoid move_p(vector<string> &vs, int &x, int &y, int dir, int mode) {\n    int nx = x + dx[mode][dir];\n    int ny = y + dy[mode][dir];\n    if(nx < 0 || nx >= H || ny < 0 || ny >= W) return;\n    if(vs[nx][ny] == '#') return;\n    x = nx;\n    y = ny;\n}\n\nsigned main() {\n    while(cin >> W >> H, W || H) {\n        rep(i,0,S) rep(j,0,S) rep(k,0,S) rep(l,0,S) step[i][j][k][l] = INF;\n        memset(visited, false, sizeof(visited));\n\n        vector<string> lboard(H), rboard(W);\n        rep(i,0,H) cin >> lboard[i] >> rboard[i];\n        pii init_a = search_p(lboard, 'L');\n        pii init_b = search_p(rboard, 'R');\n        int a = init_a.first, b = init_a.second;\n        int x = init_b.first, y = init_b.second;\n        step[a][b][x][y] = 0;\n\n        queue<Elem> que;\n        que.push(Elem{a, b, x, y});\n        visited[a][b][x][y] = true;\n        while(!que.empty()) {\n            Elem cur = que.front(); que.pop();\n            rep(k,0,4) {\n                Elem nxt = cur;\n                move_p(lboard, nxt.ax, nxt.ay, k, 0);\n                move_p(rboard, nxt.bx, nxt.by, k, 1);\n                if(visited[nxt.ax][nxt.ay][nxt.bx][nxt.by]) continue;\n                if(step[nxt.ax][nxt.ay][nxt.bx][nxt.by] > step[cur.ax][cur.ay][cur.bx][cur.by] + 1) {\n                    step[nxt.ax][nxt.ay][nxt.bx][nxt.by] = step[cur.ax][cur.ay][cur.bx][cur.by] + 1;\n                    que.push(nxt);\n                }\n            }\n        }\n\n        pii goal_a = search_p(lboard, '%');\n        pii goal_b = search_p(rboard, '%');\n        a = goal_a.first, b = goal_a.second;\n        x = goal_b.first, y = goal_b.second;\n        if(step[a][b][x][y] == INF) cout << \"No\" << endl;\n        else cout << \"Yes\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define out(S) cout<<(S)<<endl;\n#define ShowAll(collection) for(auto i:collection){out(i);}\n#define beginend(v) v.begin(),v.end()\n\nusing pii=pair<int,int>;\nusing ll=long long;\nusing ull=unsigned long long;\nusing vi=vector<int>;\nusing vvc=vector<vector<char>>;\nusing ti3=tuple<int,int,int>;\ntemplate<typename T> void removeAt(vector<T>& v, int index) { v.erase(v.begin() + index); }\n\nstruct pos {\n  int lx,ly,rx,ry;\n  pos(int lx,int ly,int rx,int ry):lx(lx),rx(rx),ly(ly),ry(ry){};\n};\n\n\nbool used[51][51][51][51];\nbool bfs(int w, int h){\n  vvc roomL(h,vector<char>(w)),roomR(h,vector<char>(w));\n  rep(i,51)rep(j,51)rep(k,51)rep(l,51) used[i][j][k][l]=false;\n  auto s=pos(0,0,0,0);\n  rep(i,h){\n    rep(j,w) {cin>>roomL[i][j];if(roomL[i][j]=='L'){s.lx=j;s.ly=i;}}\n    rep(j,w) {cin>>roomR[i][j];if(roomR[i][j]=='R'){s.rx=j;s.ry=i;}}\n  }\n\n  queue<pos> Q;\n  Q.push(s);\n\n  pii dx[4]{pii(1,-1),pii(-1,1),pii(0,0),pii(0,0)};\n  pii dy[4]{pii(0,0), pii(0,0) ,pii(1,1),pii(-1,-1)};\n\n  while(!Q.empty()){\n    int lx,ly,rx,ry;\n    auto src=Q.front();Q.pop();\n    lx=src.lx;rx=src.rx;ly=src.ly;ry=src.ry;\n\n    for (int i = 0; i < 4; ++i) {\n      int LX,LY,RX,RY;\n      LX=lx+dx[i].first;\n      RX=rx+dx[i].second;\n      LY=ly+dy[i].first;\n      RY=ry+dy[i].second;\n\n      if(LX<0||LX>=w) LX=lx;\n      if(RX<0||RX>=w) RX=rx;\n      if(LY<0||LY>=h) LY=ly;\n      if(RY<0||RY>=h) RY=ry;\n      if(roomR[RY][RX]=='#') RY=ry,RX=rx;\n      if(roomL[LY][LX]=='#') LY=ly,LX=lx;\n\n      \n      if(roomR[RY][RX]=='%'&&roomL[LY][LX]=='%') return true;\n      if(roomR[RY][RX]=='%') continue;\n      if(roomL[LY][LX]=='%') continue;\n      \n      if(!used[LX][LY][RX][RY])Q.push(pos(LX,LY,RX,RY)),used[LX][LY][RX][RY]=true;\n    }\n  }\n  return false;\n\n}\n\nint main(){\n  int W,H;\n  while(cin>>W>>H,(W|H)){\n    cout << (bfs(W,H)?\"Yes\":\"No\") << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx_r[] = {0,1,0,-1};\nstatic const int ty_r[] = {-1,0,1,0};\n\nstatic const int tx_l[] = {0,-1,0,1};\nstatic const int ty_l[] = {-1,0,1,0};\n\nbool visited[50][50][50][50];\nchar stage_Len[50][50];\nchar stage_Rin[50][50];\n\nbool can_reach;\nint W,H;\n\nvoid dfs(int Rin_x,int Rin_y,int Len_x,int Len_y){\n  for(int i=0;i<4;i++){\n    int Rin_dx = Rin_x + tx_r[i];\n    int Rin_dy = Rin_y + ty_r[i];\n\n    int Len_dx = Len_x + tx_l[i];\n    int Len_dy = Len_y + ty_l[i];\n    if(Rin_dx < 0 || Rin_dx >= W || Rin_dy < 0 || Rin_dy >= H){\n\tcontinue;\n    }\n    if(Len_dx < 0 || Len_dx >= W || Len_dy < 0 || Len_dy >= H){\n\tcontinue;\n    }\n    if(stage_Rin[Rin_dy][Rin_dx] == '#'){\n      Rin_dy = Rin_y;\n      Rin_dx = Rin_x;\n    }\n    if(stage_Len[Len_dy][Len_dx] == '#'){\n      Len_dy = Len_y;\n      Len_dx = Len_x;\n    }\n\n    if(visited[Rin_dx][Rin_dy][Len_dx][Len_dy]){\n      continue;\n    }\n\n    if(stage_Len[Len_dy][Len_dx] == '%'\n       && stage_Rin[Rin_dy][Rin_dx] == '%'){\n      can_reach = true;\n      return;\n    }\n\n    if(stage_Len[Len_dy][Len_dx] != '%'\n       && stage_Rin[Rin_dy][Rin_dx] != '%'){\n      visited[Rin_dx][Rin_dy][Len_dx][Len_dy] = true;\n      dfs(Rin_dx,Rin_dy,Len_dx,Len_dy);\n    }\n  }\n}\n\nint main(){\n\n  while(~scanf(\"%d %d\",&W,&H)){\n    if(W==0 && H==0) break;\n\n    for(int y=0;y<H;y++){\n      for(int x=0;x<W;x++){\n\tfor(int y2=0;y2<H;y2++){\n\t  for(int x2=0;x2<W;x2++){\n\t    visited[x][y][x2][y2] = false;\n\t  }\n\t}\n      }\n    }\n\n    can_reach = false;\n    \n    int Rin_start_x = 0;\n    int Rin_start_y = 0;\n    int Len_start_x = 0;\n    int Len_start_y = 0;\n \n    for(int y=0;y<H;y++){\n      string str_Len,str_Rin;\n      cin >> str_Len >> str_Rin;\n      \n      // cout << str_Len << endl;\n      // cout << str_Rin << endl;\n\n      for(int x=0;x<W;x++){\n\tstage_Len[y][x] = str_Len[x];\n\tstage_Rin[y][x] = str_Rin[x];\n\n\tif(str_Len[x] == 'L'){\n\t  Len_start_x = x;\n\t  Len_start_y = y;\n\t}\n\tif(str_Rin[x] == 'R'){\n\t  Rin_start_x = x;\n\t  Rin_start_y = y;\n\t}\n      }\n    }\n\n    dfs(Rin_start_x,Rin_start_y,Len_start_x,Len_start_y);\n    printf(\"%s\\n\",can_reach ? \"Yes\" : \"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <map>\n#include <algorithm>\n#define fr first\n#define sc second\nusing namespace std;\n\n// first:x, second:y\ntypedef pair<int, int> iP;\ntypedef pair<iP, iP> iiiP;\n\niP sR, sL;\nint h, w, used[50][50][50][50];\nint dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\nchar mapR[51][51], mapL[51][51];\nbool judge;\n\nvoid bfs(){\n  queue <iiiP> que;\n  que.push(iiiP(sL, sR));\n  while(!que.empty()){\n    iiiP p = que.front(); que.pop();\n    for(int i = 0; i < 4; i++){\n      int Lnx = min(w-1, max(0, p.fr.fr + dx[i]));\n      int Lny = min(h-1, max(0, p.fr.sc + dy[i]));\n      int Rnx = min(w-1, max(0, p.sc.fr - dx[i]));\n      int Rny = min(h-1, max(0, p.sc.sc + dy[i]));\n      \n      if(mapL[Lny][Lnx] == '%' && mapR[Rny][Rnx] == '%'){ judge = true; break; }\n      if(mapL[Lny][Lnx] == '#') Lnx = p.fr.fr, Lny = p.fr.sc;\n      if(mapR[Rny][Rnx] == '#') Rnx = p.sc.fr, Rny = p.sc.sc;\n      if(!used[Lny][Lnx][Rny][Rnx]){\n\tque.push(iiiP(iP(Lnx, Lny), iP(Rnx, Rny)));\n\tused[Lny][Lnx][Rny][Rnx] = 1;\n      }\n    }\n  }\n}\n\nint main(){\n  \n  while(cin >> w >> h, w){\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n\tcin >> mapL[i][j];\n\tif(mapL[i][j] == 'L') sL.fr = j, sL.sc = i;\n      }\n      \n      for(int j = 0; j < w; j++){\n\tcin >> mapR[i][j];\n\tif(mapR[i][j] == 'R') sR.fr = j, sR.sc = i;\n      }\n    }\n\n    judge = false;\n    memset(used, 0, sizeof(used));\n    bfs();\n    if(judge) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <utility>\n#include <tuple>\n#include <queue>\n\ntemplate <class Tp>\nstd::vector<Tp> make_vector(size_t n, const Tp& x) {\n  return std::vector<Tp>(n, x);\n}\n\ntemplate <class... Ts>\nauto make_vector(size_t n, size_t m, const Ts&... x) {\n  return std::vector<decltype(make_vector(m, x...))>(n, make_vector(m, x...));\n}\n\nconstexpr size_t m1 = -1;\nconstexpr size_t di[] = {m1, 0, 1, 0};\nconstexpr size_t dj[] = {0, m1, 0, 1};\n\nint testcase_ends() {\n  size_t h, w;\n  scanf(\"%zu %zu\", &w, &h);\n  if (h == 0 && w == 0) return 1;\n\n  std::vector<std::string> L(h+2), R(h+2);\n  L[0] = L[h+1] = R[0] = R[h+1] = std::string(w+2, '#');\n  size_t lsi = -1;\n  size_t lsj = -1;\n  size_t rsi = -1;\n  size_t rsj = -1;\n  for (size_t i = 1; i <= h; ++i) {\n    char buf[64];\n    scanf(\"%s\", buf);\n    L[i] = \"#\";\n    L[i] += buf;\n    L[i] += '#';\n    for (size_t j = 1; j <= w; ++j) {\n      if (L[i][j] == 'L') {\n        lsi = i;\n        lsj = j;\n      }\n    }\n\n    scanf(\"%s\", buf);\n    R[i] = \"#\";\n    R[i] += buf;\n    R[i] += '#';\n    std::reverse(R[i].begin(), R[i].end());\n    for (size_t j = 1; j <= w; ++j) {\n      if (R[i][j] == 'R') {\n        rsi = i;\n        rsj = j;\n      }\n    }\n  }\n  h += 2;\n  w += 2;\n\n  auto dp = make_vector(h, w, h, w, false);\n  dp[lsi][lsj][rsi][rsj] = true;\n  using zahyo = std::pair<size_t, size_t>;\n  std::queue<std::pair<zahyo, zahyo>> q;\n  q.emplace(std::make_pair(lsi, lsj), std::make_pair(rsi, rsj));\n  while (!q.empty()) {\n    size_t li, lj, ri, rj;\n    std::tie(li, lj) = q.front().first;\n    std::tie(ri, rj) = q.front().second;\n    q.pop();\n    \n    for (int k = 0; k < 4; ++k) {\n      size_t lni = li + di[k];\n      size_t lnj = lj + dj[k];\n      size_t rni = ri + di[k];\n      size_t rnj = rj + dj[k];\n\n      if (L[lni][lnj] == '#') {\n        lni = li;\n        lnj = lj;\n      }\n      if (R[rni][rnj] == '#') {\n        rni = ri;\n        rnj = rj;\n      }\n\n      if (L[lni][lnj] == '%' && R[rni][rnj] == '%')\n        return puts(\"Yes\"), 0;\n\n      if (dp[lni][lnj][rni][rnj]) continue;\n      if (L[lni][lnj] == '%') continue;\n      if (R[rni][rnj] == '%') continue;\n\n      dp[lni][lnj][rni][rnj] = true;\n      q.emplace(std::make_pair(lni, lnj), std::make_pair(rni, rnj));\n    }\n  }\n\n  puts(\"No\");\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\nint const dxL[] = {-1,0,1,0};\nint const dxR[] = {1,0,-1,0};\nint const dy[]  = {0,-1,0,1};\ntypedef pair<int, int> Pii;\n#define X first\n#define Y second\nint const INF = 1<<28;\nint W, H;\nchar grL[51][51], grR[51][51];\nint dist[300][300];\ninline bool inF(int x, int y, int isL) {\n  if(0<=x&&x<W && 0<=y&&y<H) {\n    if(isL) return grL[y][x]!='#';\n    else return grR[y][x]!='#';\n  }\n  return false;\n}\ninline int toNode(int x, int y) {\n  return y*W+x;\n}\ninline void toPos(int node, int &x, int &y) {\n  x = node%W, y = node/W;\n}\nint main() {\n  \n  while(cin >> W >> H && (W|H)) {\n    int sxL, syL, sxR, syR;\n    int gxL, gyL, gxR, gyR;\n    for(int i=0; i<H; i++) {\n      for(int j=0; j<2*W; j++) {\n        if(j<W) {\n          cin >> grL[i][j];\n          if(grL[i][j] == 'L') {\n            sxL = j, syL = i;\n          }\n          if(grL[i][j] == '%') {\n            gxL = j, gyL = i;\n          }\n        }\n        else {\n          cin >> grR[i][j-W];\n          if(grR[i][j-W] == 'R') {\n            sxR = j-W, syR = i;\n          }\n          if(grR[i][j-W] == '%') {\n            gxR = j-W, gyR = i;\n          }\n        }\n      }\n    }\n    \n    queue<int> qCost;\n    queue<int> qL, qR;\n    qL.push(toNode(sxL, syL)); qR.push(toNode(sxR, syR));\n    bool ok = false;\n    fill(dist[0], dist[0]+300*300, INF);\n    dist[toNode(sxL, syL)][toNode(sxR, syR)] = 0;\n    while(!qL.empty()) {\n      int nowL = qL.front(); qL.pop();\n      int nowR = qR.front(); qR.pop();\n      int lx, ly; toPos(nowL, lx, ly);\n      int rx, ry; toPos(nowR, rx, ry);\n      if(lx == gxL && ly == gyL && rx == gxR && ry == gyR) {\n        ok = true; break;\n      }\n      if(lx == gxL && ly == gyL) {\n        continue;\n      }\n      if(rx == gxR && ry == gyR) {\n        continue;\n      }\n      for(int i=0; i<4; i++) {\n        int nxL = lx+dxL[i], nyL = ly+dy[i];\n        int nxR = rx+dxR[i], nyR = ry+dy[i];\n        if(!inF(nxL, nyL, 1) && !inF(nxR, nyR, 0)) continue;\n        if(!inF(nxL, nyL, 1)) { nxL = lx, nyL = ly; }\n        if(!inF(nxR, nyR, 0)) { nxR = rx, nyR = ry; }\n        if(dist[toNode(nxL, nyL)][toNode(nxR, nyR)] != INF) continue;\n        qL.push(toNode(nxL, nyL));\n        qR.push(toNode(nxR, nyR));\n        dist[toNode(nxL, nyL)][toNode(nxR, nyR)] = dist[nowL][nowR]+1;\n      }\n    }\n    if(ok) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp make_pair\n#define pb push_back\n#define F first\n#define S second\n\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nbool app[50][50][50][50];\n\nmain(){\n  int w,h;\n  while(cin>>w>>h,w|h){\n    memset(app,0,6250000);\n    string lr[h],rr[h];\n    rep(i,h){\n      cin>>lr[i]>>rr[i];\n    }\n\n    string ans=\"No\";\n    int rsx,rsy,lsx,lsy;\n    rep(i,h)rep(j,w){\n      if(lr[i][j]=='L')lsx=i,lsy=j;\n      if(rr[i][j]=='R')rsx=i,rsy=j;\n    }\n\n    queue<pair<PI,PI> > Q;\n    Q.push(mp(mp(lsx,lsy),mp(rsx,rsy)));\n\n    while(!Q.empty()){\n      PI tp=Q.front().F;\n      int clx,cly,crx,cry;\n      clx=tp.F,cly=tp.S;\n      tp=Q.front().S;Q.pop();\n      crx=tp.F,cry=tp.S;\n      if(lr[clx][cly]=='%' && rr[crx][cry]=='%'){\n        ans=\"Yes\";\n        break;\n      }\n      if(lr[clx][cly]=='%' || rr[crx][cry]=='%')continue;\n      \n      app[clx][cly][crx][cry]=true;\n\n      rep(i,4){\n        int nrx=crx+dx[i],nlx=clx+dx[i],nry=cry+dy[i],nly=cly-dy[i];\n        if(nrx<0 || nry<0 || nrx>=h || nry>=w || rr[nrx][nry]=='#')nrx=crx,nry=cry;\n        if(nlx<0 || nly<0 || nlx>=h || nly>=w || lr[nlx][nly]=='#')nlx=clx,nly=cly;\n        if(app[nlx][nly][nrx][nry])continue;\n        Q.push(mp(mp(nlx,nly),mp(nrx,nry)));\n      }\n/*      \n      rep(i,h){\n        rep(j,w){\n          if(clx==i && cly==j)cout<<'L';\n          else if(lr[i][j]=='L')cout<<'.';\n          else cout<<lr[i][j];\n        }\n        cout<<\" \";\n        rep(j,w){\n          if(crx==i && cry==j)cout<<'R';\n          else if(rr[i][j]=='R')cout<<'.';\n          else cout<<rr[i][j];\n        }\n        cout<<endl;\n      }\n      cout<<endl;\n*/\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nint W, H;\nchar RoomL[50][50];\nchar RoomR[50][50];\n\nconst int dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};\n\nstruct P {\n    int lx, ly, rx, ry;\n};\n\nbool is_reachable(int x, int y, char room[50][50]) {\n    bool G[50][50] = {};\n    queue<pii> que;\n    que.push({x, y});\n    while (!que.empty()) {\n        pii p = que.front(); que.pop();\n        int x = p.first, y = p.second;\n        REP(i, 4) {\n            int sx = x + dx[i], sy = y + dy[i];\n            if (0 <= sx && sx < W && 0 <= sy && sy < H) {\n                switch (room[sy][sx]) {\n                case '%':\n                    return true;\n                case '#':\n                    break;\n                default:\n                    if (!G[sy][sx]) {\n                        G[sy][sx] = true;\n                        que.push({sx, sy});\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    while (cin >> W >> H, W|H) {\n        fill_n((char *)RoomL, 50*50, '#');\n        fill_n((char *)RoomR, 50*50, '#');\n\n        int lx, ly, rx, ry;\n        int lgx, lgy, rgx, rgy;\n        REP(y, H) {\n            REP(x, W) {\n                cin >> RoomL[y][x];\n                switch (RoomL[y][x]) {\n                case 'L':\n                    lx = x;\n                    ly = y;\n                    RoomL[y][x] = '.';\n                    break;\n                case '%':\n                    lgx = x;\n                    lgy = y;\n                    break;\n                }\n            }\n            REP(x, W) {\n                cin >> RoomR[y][x];\n                switch (RoomR[y][x]) {\n                case 'R':\n                    rx = x;\n                    ry = y;\n                    RoomR[y][x] = '.';\n                    break;\n                case '%':\n                    rgx = x;\n                    rgy = y;\n                    break;\n                }\n            }\n        }\n\n        LOG(\"%d %d\", is_reachable(lx, ly, RoomL), is_reachable(rx, ry, RoomR));\n        if (!(is_reachable(lx, ly, RoomL) && is_reachable(rx, ry, RoomR))) {\n            cout << \"No\" << endl;\n            break;\n        }\n\n        set<int> G;\n\n        queue<P> que;\n        que.push({lx, ly, rx, ry});\n        G.insert(lx + ly*100 + rx*10000 + ry*1000000);\n        while (!que.empty()) {\n            P p = que.front(); que.pop();\n            if (p.lx == lgx && p.ly == lgy && p.rx == rgx && p.ry == rgy) {\n                cout << \"Yes\" << endl;\n                goto END;\n            }\n\n            REP(i, 4) {\n                int lsx = p.lx - dx[i], lsy = p.ly + dy[i];\n                int rsx = p.rx + dx[i], rsy = p.ry + dy[i];\n                if (!(0 <= lsx && lsx < W && 0 <= lsy && lsy < H) || RoomL[lsy][lsx] == '#') {\n                    lsx = p.lx;\n                    lsy = p.lx;\n                }\n                if (!(0 <= rsx && rsx < W && 0 <= rsy && rsy < H) || RoomR[rsy][rsx] == '#') {\n                    rsx = p.rx;\n                    rsy = p.rx;\n                }\n                if (RoomR[rsy][rsx] == '%' || RoomL[lsy][lsx] == '%') {\n                    if (RoomR[rsy][rsx] == '%' && RoomL[lsy][lsx] == '%') {\n                    } else {\n                        continue;\n                    }\n                }\n                if (G.insert(lsx + lsy*100 + rsx*10000 + rsy*1000000).second) {\n//                    LOG(\"-----\\n%d %d # %d %d\\n-----\\n\", lsx, lsy, rsx, rsy);\n//                    REP(y, H) {\n//                        REP(x, W) {\n//                            if (lsx == x && lsy == y) {\n//                                printf(\"L\");\n//                            } else {\n//                                printf(\"%c\", RoomL[y][x]);\n//                            }\n//                        }\n//                        printf(\"\\n\");\n//                    }\n//                    REP(y, H) {\n//                        REP(x, W) {\n//                            if (rsx == x && rsy == y) {\n//                                printf(\"R\");\n//                            } else {\n//                                printf(\"%c\", RoomR[y][x]);\n//                            }\n//                        }\n//                        printf(\"\\n\");\n//                    }\n\n                    que.push({lsx, lsy, rsx, rsy});\n                }\n            }\n        }\n        cout << \"No\" << endl;\n    END: {}\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\nstruct po{int lx,ly,rx,ry;};\nint w,h;\nstring mp[2][51];\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\n\nbool bfs(int lx,int ly,int rx,int ry){\n  bool visited[50][50][50][50]={};\n  queue <po> Q;\n  Q.push((po){lx,ly,rx,ry});\n  while(!Q.empty()){\n    po t=Q.front();Q.pop();\n    lx=t.lx, ly=t.ly;\n    rx=t.rx, ry=t.ry;\n    int cnt=(mp[0][ly][lx]=='%')+(mp[1][ry][rx]=='%');\n    if(visited[lx][ly][rx][ry]||cnt==1)continue;;\n    if(cnt==2)return true;\n    visited[lx][ly][rx][ry]=1;\n    for(int i=0;i<4;i++){\n      int flg=0;\n      int nlx=lx+dx[i],nly=ly+dy[i];\n      int nrx=rx-dx[i],nry=ry+dy[i];\n      if(nlx<0||nly<0||nlx>=w||nly>=h||mp[0][nly][nlx]=='#')nlx=lx,nly=ly,flg++;\n      if(nrx<0||nry<0||nrx>=w||nry>=h||mp[1][nry][nrx]=='#')nrx=rx,nry=ry,flg++;\n      if(flg==2||visited[nlx][nly][nrx][nry])continue;\n      Q.push((po){nlx,nly,nrx,nry});\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(1){\n    cin >>w>>h;\n    if(!w&&!h)break;\n    for(int i=0;i<h;i++)cin>>mp[0][i]>>mp[1][i];\n    int lx,ly,rx,ry;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(mp[0][i][j]=='L')lx=j,ly=i;\n\tif(mp[1][i][j]=='R')rx=j,ry=i;\n      }\n\n    if(bfs(lx,ly,rx,ry))cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nint W,H;\nint vis[50][50][50][50] = {};\nint dx[4] = {-1,1,0,0},dy[4] = {0,0,-1,1};\nstring F[2][50];\nint s0x,s0y,s1x,s1y,g0x,g0y,g1x,g1y;\n        \nbool in(int x,int y,int c){\n    return 0<=x && x<H && 0<=y && y<W && F[c][x][y]!='#';\n}\n\nbool goal(int x,int y,int c){\n    if(c==0) return g0x==x && g0y==y;\n    else return g1x==x && g1y==y;\n}\n\nstruct state{\n    int x0,y0,x1,y1;\n};\n\n\nint main(){\n    while(cin >> W >> H && W>0){\n        for(int i=0;i<H;i++) for(int j=0;j<W;j++) for(int k=0;k<H;k++) for(int l=0;l<W;l++) vis[i][j][k][l] = 0;\n        for(int i=0;i<H;i++){\n            cin >> F[0][i] >> F[1][i];\n            for(int j=0;j<W;j++) if(F[0][i][j]=='L'){s0x = i; s0y = j;}\n            for(int j=0;j<W;j++) if(F[1][i][j]=='R'){s1x = i; s1y = j;}\n            for(int j=0;j<W;j++) if(F[0][i][j]=='%'){g0x = i; g0y = j;}\n            for(int j=0;j<W;j++) if(F[1][i][j]=='%'){g1x = i; g1y = j;}            \n        }\n        queue<state> Q;\n        Q.push({s0x,s0y,s1x,s1y});\n        vis[s0x][s0y][s1x][s1y] = 1;\n        while(!Q.empty()){\n            state now = Q.front(); Q.pop();\n            for(int i=0;i<4;i++){\n                int n0x = now.x0+dx[i],n0y = now.y0+dy[i],\n                n1x = now.x1+dx[i],n1y = now.y1-dy[i];\n                if(!in(n0x,n0y,0) && in(n1x,n1y,1) && vis[now.x0][now.y0][n1x][n1y]==0){\n                    if(goal(now.x0,now.y0,0) xor goal(n1x,n1y,1)) continue;\n                    vis[now.x0][now.y0][n1x][n1y] = 1;\n                    Q.push({now.x0,now.y0,n1x,n1y});\n                }\n                if(in(n0x,n0y,0) && !in(n1x,n1y,1) && vis[n0x][n0y][now.x1][now.y1]==0){\n                    if(goal(n0x,n0y,0) xor goal(now.x1,now.y1,1)) continue;\n                    vis[n0x][n0y][now.x1][now.y1] = 1;\n                    Q.push({n0x,n0y,now.x1,now.y1});\n                }\n                if(in(n0x,n0y,0) && in(n1x,n1y,1) && vis[n0x][n0y][n1x][n1y]==0){\n                    if(goal(n0x,n0y,0) xor goal(n1x,n1y,1)) continue;\n                    vis[n0x][n0y][n1x][n1y] = 1;\n                    Q.push({n0x,n0y,n1x,n1y});\n                }\n            }\n        }\n        cout << (vis[g0x][g0y][g1x][g1y]? \"Yes\":\"No\") << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<tuple>\n#include<string>\nusing namespace std;\n\n#define MAX_N 60\n#define INF 1<<30\n\nint dist[MAX_N][MAX_N][MAX_N][MAX_N];\nint dy1[4] = { 0,1,0,-1 };\nint dy2[4] = { 0,1,0,-1 };\nint dx1[4] = { 1,0,-1,0 };\nint dx2[4] = { -1,0,1,0 };\nint H, W, map1[MAX_N][MAX_N], map2[MAX_N][MAX_N];\nint Lsy, Lsx, Lgy, Lgx;\nint Rsy, Rsx, Rgy, Rgx;\nstring S, T;\nqueue<tuple<int, int, int, int>>Q;\n\nvoid _memset() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tfor (int k = 0; k < MAX_N; k++) {\n\t\t\t\tfor (int l = 0; l < MAX_N; l++) {\n\t\t\t\t\tdist[i][j][k][l] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tmap1[i][j] = 1;\n\t\t\tmap2[i][j] = 1;\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\t_memset();\n\t\tcin >> W >> H;\n\t\tif (H == 0 && W == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tcin >> S >> T;\n\t\t\tfor (int j = 0; j < S.size(); j++) {\n\t\t\t\tif (S[j] == '%') {\n\t\t\t\t\tLsx = j + 1; Lsy = i;\n\t\t\t\t\tmap1[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\tif (S[j] == '#') {\n\t\t\t\t\tmap1[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (S[j] == '.') {\n\t\t\t\t\tmap1[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (S[j] = 'L') {\n\t\t\t\t\tLgy = i; Lgx = j + 1;\n\t\t\t\t\tmap1[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < T.size(); j++) {\n\t\t\t\tif (T[j] == '%') {\n\t\t\t\t\tRsx = j + 1; Rsy = i;\n\t\t\t\t\tmap2[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\tif (T[j] == '#') {\n\t\t\t\t\tmap2[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (T[j] == '.') {\n\t\t\t\t\tmap2[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (T[j] = 'R') {\n\t\t\t\t\tRgy = i; Rgx = j + 1;\n\t\t\t\t\tmap2[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQ.push(make_tuple(Lsy, Lsx, Rsy, Rsx));\n\t\tdist[Lsy][Lsx][Rsy][Rsx] = 0;\n\n\t\twhile (!Q.empty()) {\n\t\t\ttuple<int, int, int, int>tup = Q.front(); Q.pop();\n\t\t\tint ay = get<0>(tup);\n\t\t\tint ax = get<1>(tup);\n\t\t\tint by = get<2>(tup);\n\t\t\tint bx = get<3>(tup);\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint ey = ay + dy1[i], ex = ax + dx1[i];\n\t\t\t\tint fy = by + dy2[i], fx = bx + dx2[i];\n\t\t\t\tif (map1[ey][ex] == 1) {\n\t\t\t\t\tey = ay; ex = ax;\n\t\t\t\t}\n\t\t\t\tif (map2[fy][fx] == 1) {\n\t\t\t\t\tfy = by; fx = bx;\n\t\t\t\t}\n\t\t\t\tif (dist[ey][ex][fy][fx] == INF) {\n\t\t\t\t\tdist[ey][ex][fy][fx] = 0;\n\t\t\t\t\tQ.push(make_tuple(ey, ex, fy, fx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[Lgy][Lgx][Rgy][Rgx] == INF) {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstring>\n#include<queue>\n#include<tuple>\n#include<stack>\n#include<cstdio>\n#include<iomanip>\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<string> vs;\nDef inf = sizeof(Def) == sizeof(ll) ?2e18:1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint d[52][52][52][52];\ntypedef tuple<int,int,int,int>tp;\nvs a,b;\nint n,m;\nint f(int x1,int y1,int x2,int y2){\n  //    cout<<x1<<\" \"<<y1<<\" \"<<x2<<\" \"<<y2<<endl;\n\n  priority_queue<tp>q;\n  q.push(tp{x1,y1,x2,y2});\n  while(!q.empty()){ \n    int x1,y1,x2,y2;\n    tie(x1,y1,x2,y2)=q.top();\n    q.pop();\n    rep(i,4){\n  \n      int nx1=x1+dx[i];\n      int ny1=y1+dy[i];\n      int nx2=x2+dx[i];\n      int ny2=y2+dy[(2+i)%4];\n      if(nx1<0||ny1<0||nx1>=n||ny1>=m){\n\tnx1-=dx[i];\n\tny1-=dy[(i)%4];\n      }\n      if(nx2<0||ny2<0||nx2>=n||ny2>=m){\n\tnx2-=dx[i];\n\tny2-=dy[(i+2)%4];\n      }\n      if(a[nx1][ny1]=='#'){\n\tnx1-=dx[i];\n\tny1-=dy[i];\n      }\n      if(b[nx2][ny2]=='#'){\n\tnx2-=dx[i];\n\tny2-=dy[(i+2)%4];\n      }\n      bool A=a[nx1][ny1]=='%';\n      bool B=b[nx2][ny2]=='%';\n      if(A!=B)continue;\n      if(d[nx1][ny1][nx2][ny2])continue;\n      // cout<<nx1<<\" \"<<ny1<<\" \"<<nx2<<\" \"<<ny2<<endl;\n      d[nx1][ny1][nx2][ny2]=1;\n      q.push(tp{nx1,ny1,nx2,ny2});//f(nx1,ny1,nx2,ny2);\n    }\n  }\n}\nint main(){\n  while(cin>>m>>n,n){\n    rep(i,52)rep(j,52)rep(k,52)rep(l,52)\n      d[i][j][k][l]=0;\n    a=b=vs(n);\n    rep(i,n)cin>>a[i]>>b[i];\n    rep(i,n)rep(j,m)rep(k,n)rep(l,m)if(a[i][j]=='L'&&b[k][l]=='R'){\n      d[i][j][k][l]=1;\n      f(i,j,k,l);\n    }\n    rep(i,n)rep(j,m)rep(k,n)rep(l,m)if(a[i][j]=='%'&&b[k][l]=='%'){\n      if(d[i][j][k][l])cout<<\"YES\"<<endl;\n      else cout<<\"NO\"<<endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstring>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\ntypedef pair<int, int> Pi;\n\n#define fr first\n#define sc second\n\nint W, H;\nPi Rp, Lp;\nstring roomL[64], roomR[64];\nbool used[51][51][51][51];\n\nbool bfs(Pi R, Pi L)\n{\n  Pi Crp, Clp;\n  queue<Pi> queR, queL;\n  int dx[] = {-1, 0, 0, 1},\n      dy[] = {0, -1, 1, 0};\n\n  memset(used, false, sizeof(used));\n\n  used[L.fr][L.sc][R.fr][R.sc] = true;\n  queR.push(R); queL.push(L);\n  while(queR.size()){\n    Crp = queR.front(); queR.pop();\n    Clp = queL.front(); queL.pop();\n\n    if(Crp == Rp && Clp == Lp) return true;\n    if(Crp == Rp && Clp != Lp || Crp != Rp && Clp == Lp) continue;\n\n    for(int i = 0;i < 4; i++){\n      int nlx = Clp.fr + dx[i], nly = Clp.sc + dy[i],\n          nrx = Crp.fr - dx[i], nry = Crp.sc + dy[i];\n      if(nlx < 0 || nlx >= W || nly < 0 || nly >= H)\n        nlx = Clp.fr, nly = Clp.sc;\n      if(nrx < 0 || nrx >= W || nry < 0 || nry >= H)\n        nrx = Crp.fr, nry = Crp.sc;\n      if(roomL[nly][nlx] == '#')\n        nlx = Clp.fr, nly = Clp.sc;\n      if(roomR[nry][nrx] == '#')\n        nrx = Crp.fr, nry = Crp.sc;\n      if(!used[nlx][nly][nrx][nry]){\n        used[nlx][nly][nrx][nry] = true;\n        queR.push(make_pair(nrx, nry));\n        queL.push(make_pair(nlx, nly));\n      }\n    }\n  }\n\n  return false;\n}\n\nint main(void)\n{\n  Pi Crp, Clp;\n\n  while(cin >> W >> H, W || H){\n    for(int i = 0;i < H; i++){\n      cin >> roomL[i] >> roomR[i];\n      for(int j = 0;j < W; j++){\n        if(roomL[i][j] == 'L')\n          Clp = make_pair(j, i);\n        if(roomR[i][j] == 'R')\n          Crp = make_pair(j, i);\n        if(roomL[i][j] == '%')\n          Lp = make_pair(j, i);\n        if(roomR[i][j] == '%')\n          Rp = make_pair(j, i);\n      }\n    }\n    cout << (bfs(Crp, Clp)? \"Yes\" : \"No\") << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<utility>\n#include<queue>\nusing namespace std;\ntypedef struct P{int rh,rw,lh,lw,d;}P;\nstruct Order{bool operator ()(P const&a, P const&b) const{return a.d>b.d;}};\n\nint W,H,i,j,rh,rw,lh,lw,f;\nint rm[4][2]={{0,1},{0,-1},{1,0},{-1,0}};\nint lm[4][2]={{0,-1},{0,1},{1,0},{-1,0}};\nbool dp[55][55][55][55];\nchar M[55][110]={0},t;\n\nint main()\n{\n\tfor(;scanf(\"%d%d\\n\",&W,&H),W;)\n\t{\n\t\tmemset(M,0,sizeof(M));\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(i=1;i<=H;i++)\n\t\t\tfor(j=1;j<=2*W+2;j++)\n\t\t\t{\n\t\t\t\tt=getchar();\n\t\t\t\tif(t=='R'){rh=i;rw=j;t='.';}\n\t\t\t\tif(t=='L'){lh=i;lw=j;t='.';}\n\t\t\t\tM[i][j]=t;\n\t\t\t}\n\t\tpriority_queue<P,vector<P>,Order>Q;\n\t\tP p={rh,rw,lh,lw,0};\n\t\tQ.push(p);\n\t\tfor(f=0;!Q.empty();)\n\t\t{\n\t\t\tp=Q.top();Q.pop();\n\t\t\tif(M[p.rh][p.rw]=='%'&&M[p.lh][p.lw]=='%'){f=1;break;}\n\t\t\tif(M[p.rh][p.rw]=='%'||M[p.lh][p.lw]=='%'||p.d==1500)\n\t\t\t\tcontinue;\n\t\t\tfor(i=0;i<4;i++)\n\t\t\t{\n\t\t\t\tP ins={p.rh,p.rw,p.lh,p.lw,p.d+1};\n\t\t\t\tif(M[p.rh+rm[i][0]][p.rw+rm[i][1]]=='.'||M[p.rh+rm[i][0]][p.rw+rm[i][1]]=='%'){ins.rh+=rm[i][0];ins.rw+=rm[i][1];}\n\t\t\t\tif(M[p.lh+lm[i][0]][p.lw+lm[i][1]]=='.'||M[p.lh+lm[i][0]][p.lw+lm[i][1]]=='%'){ins.lh+=lm[i][0];ins.lw+=lm[i][1];}\n\t\t\t\tif(!dp[ins.rh][ins.rw][ins.lh][ins.lw-W-1])\n\t\t\t\t{\n\t\t\t\t\tdp[ins.rh][ins.rw][ins.lh][ins.lw-W-1]=1;\n\t\t\t\t\tQ.push(ins);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(f?\"Yes\":\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n// #define int ll\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#ifdef int\nconst ll INF = (1LL<<60);\n#else\nconst int INF = (1LL<<30);\n#endif\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[2][4] = {{0, 1, 0, -1}, {0, -1, 0, 1}}, dy[2][4] = {{1, 0, -1, 0}, {1, 0, -1, 0}};\n\nstring s1[55], s2[55];\nint d[55][55][55][55];\nsigned main(void)\n{\n  while(true) {\n    int w, h;\n    cin >> w >> h;\n    if(!w && !h) break;\n    REP(i, h) cin >> s1[i] >> s2[i];\n\n    int srx, sry, slx, sly, grx, gry, glx, gly;\n    REP(i, h) REP(j, w) {\n      if(s1[i][j] == 'L') {\n        srx = j, sry = i;\n      }\n      if(s1[i][j] == '%') {\n        grx = j, gry = i;\n      }\n      if(s2[i][j] == 'R') {\n        slx = j, sly = i;\n      }\n      if(s2[i][j] == '%') {\n        glx = j, gly = i;\n      }\n    }\n    // cout << srx << \" \" << sry << \" \" << grx << \" \" << gry << endl;\n    // cout << slx << \" \" << sly << \" \" << glx << \" \" << gly << endl;\n\n    queue<VI> que;\n    que.push({srx, sry, slx, sly});\n    memset(d, 0x3f, sizeof(d));\n    d[sry][srx][sly][slx] = 0;\n    while(que.size()) {\n      VI v = que.front(); que.pop();\n      int rx = v[0], ry = v[1], lx = v[2], ly = v[3];\n      // cout << rx << \" \" << ry << \" \" << lx << \" \" << ly << endl;\n      if(s1[ry][rx] == '%' && s2[ly][lx] == '%') break;\n      else if(s1[ry][rx] == '%' || s2[ly][lx] == '%') continue;\n      REP(i, 4) {\n        int nrx = rx + dx[0][i], nry = ry + dy[0][i], nlx = lx + dx[1][i], nly = ly + dy[1][i];\n        if(IN(0, w, nrx) && IN(0, h, nry) && IN(0, w, nlx) && IN(0, h, nly)) {\n          if(s1[nry][nrx] != '#' && s2[nly][nlx] != '#') {\n            if(d[nry][nrx][nly][nlx] == 0x3f3f3f3f) {\n              d[nry][nrx][nly][nlx] = d[ry][rx][ly][lx] + 1;\n              que.push({nrx, nry, nlx, nly});\n            }\n          } else if(s1[nry][nrx] != '#') {\n            if(d[nry][nrx][ly][lx] == 0x3f3f3f3f) {\n              d[nry][nrx][ly][lx] = d[ry][rx][ly][lx] + 1;\n              que.push({nrx, nry, lx, ly});\n            }\n          } else if(s2[nly][nlx] != '#') {\n            if(d[ry][rx][nly][nlx] == 0x3f3f3f3f) {\n              d[ry][rx][nly][nlx] = d[ry][rx][ly][lx] + 1;\n              que.push({rx, ry, nlx, nly});\n            }\n          }\n        }\n      }\n    }\n\n    if(d[gry][grx][gly][glx] == 0x3f3f3f3f) cout << \"No\" << endl;\n    else cout << \"Yes\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <cstring>\nusing namespace std;\n\nint w,h;\npair<int,int> sa,sb,ga,gb;\nchar mapA[52][52], mapB[52][52];\nbool memo[52][52][52][52];\n\nint dxa[] = {0,0,1,-1};\nint dxb[] = {0,0,-1,1};\nint dya[] = {1,-1,0,0};\nint dyb[] = {1,-1,0,0};\n\nbool solve(pair<int,int> posA, pair<int,int> posB){\n\tmemo[posA.first][posA.second][posB.first][posB.second] = true;\n\t\n\tfor(int i=0;i<4;i++){\n\t\tpair<int,int> na = pair<int,int>(posA.first+dxa[i], posA.second+dya[i]);\n\t\tpair<int,int> nb = pair<int,int>(posB.first+dxb[i], posB.second+dyb[i]);\n\t\t\n\t\tif(na.first<0 || na.first>=w || na.second<0 || na.second>=h || mapA[na.second][na.first]=='#') na = posA;\n\t\tif(nb.first<0 || nb.first>=w || nb.second<0 || nb.second>=h || mapB[nb.second][nb.first]=='#') nb = posB;\n\n\t\tif(na == ga && nb == gb) return true;\n\t\tif(na == ga || nb == gb) continue;\n\t\tif(memo[na.first][na.second][nb.first][nb.second]) continue;\n\t\tif(solve(na,nb)) return true;\n\t}\n\treturn false;\n}\n\nint main(void){\n\twhile(cin>>w>>h && (w||h)){\n\t\tmemset(memo,0,sizeof(memo));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>mapA[i]>>mapB[i];\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(mapA[i][j] == 'L'){\n\t\t\t\t\tsa = pair<int,int>(j,i);\n\t\t\t\t}\n\t\t\t\telse if(mapA[i][j] == '%'){\n\t\t\t\t\tga = pair<int,int>(j,i);\n\t\t\t\t}\n\t\t\t\tif(mapB[i][j] == 'R'){\n\t\t\t\t\tsb = pair<int,int>(j,i);\n\t\t\t\t}\n\t\t\t\telse if(mapB[i][j] == '%'){\n\t\t\t\t\tgb = pair<int,int>(j,i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(solve(sa,sb)) cout<<\"Yes\\n\";\n\t\telse cout<<\"No\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntypedef double weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\ntypedef vector<vector<edge>> Graph;\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\n\n\nint main()\n{\n\tint h, w;\n\twhile (cin >> w >> h, w)\n\t{\n\t\tvs fld1(h), fld2(h);\n\t\tREP(i, h) cin >> fld1[i] >> fld2[i];\n\t\tpii sa, sb, ga, gb;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld1[i][j] == 'L') sa = pii(i, j);\n\t\t\tif (fld2[i][j] == 'R') sb = pii(i, j);\n\t\t\tif (fld1[i][j] == '%') ga = pii(i, j);\n\t\t\tif (fld2[i][j] == '%') gb = pii(i, j);\n\t\t}\n\t\ttypedef pair<pii, pii> data;\n\t\tset<data> st;\n\t\tqueue<data> que;\n\t\tque.push(data(sa, sb));\n\t\twhile (que.size())\n\t\t{\n\t\t\tdata tmp = que.front();\n\t\t\tque.pop();\n\t\t\tst.insert(tmp);\n\t\t\tint lx = tmp.first.first, ly = tmp.first.second;\n\t\t\tint rx = tmp.second.first, ry = tmp.second.second;\n\t\t\tREP(i, 4)\n\t\t\t{\n\t\t\t\tint lnx = lx + dx[i], lny = ly + dy[i];\n\t\t\t\tint rnx = rx + dx[i], rny = ry - dy[i];\n\t\t\t\tif (!valid(lnx, lny, h, w) || fld1[lnx][lny]=='#')\n\t\t\t\t{\n\t\t\t\t\tlnx = lx, lny = ly;\n\t\t\t\t}\t\t\t\t\n\t\t\t\tif (!valid(rnx, rny, h, w) || fld2[rnx][rny] == '#')\n\t\t\t\t{\n\t\t\t\t\trnx = rx, rny = ry;\n\t\t\t\t}\n\t\t\t\tdata next = data(pii(lnx, lny), pii(rnx, rny));\n\t\t\t\tif (st.find(next) != st.end()) continue;\n\t\t\t\tque.push(next);\n\t\t\t}\n\t\t}\n\t\tdata goal = data(ga, gb);\n\t\tif (st.find(goal) == st.end()) puts(\"No\");\n\t\telse puts(\"Yes\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint LDY[4] = {-1, 0, 1, 0};\nint LDX[4] = {0, 1, 0, -1};\nint RDY[4] = {-1, 0, 1, 0};\nint RDX[4] = {0, -1, 0, 1};\n\nint W, H;\nchar used[52][52][52][52]; // ly, lx, ry, rx\nchar L[52][52], R[52][52];\n\nclass State {\npublic:\n    int ly, lx, ry, rx;\n    State() {}\n    State(int ly, int lx, int ry, int rx) : ly(ly), lx(lx), ry(ry), rx(rx) {}\n    bool operator==(const State& a) { return ly == a.ly && lx == a.lx && ry == a.ry && rx == a.rx; }\n};\n\nvoid init() {\n    memset(used, 0, 52*52*52*52);\n    for (int i=0; i<52; ++i) {\n        for (int j=0; j<52; ++j) {\n            L[i][j] = R[i][j] = '#';\n        }\n    }\n}\n\nint main() {\n    while (cin >> W >> H, W) {\n        init();\n        State S, G;\n        for (int i=1; i<=H; ++i) {\n            string rl, rr;\n            cin >> rl >> rr;\n            for (int j=1; j<=W; ++j) {\n                L[i][j] = rl[j-1];\n                R[i][j] = rr[j-1];\n                if (L[i][j] == 'L') {\n                    S.ly = i;\n                    S.lx = j;\n                } else if (L[i][j] == '%') {\n                    G.ly = i;\n                    G.lx = j;\n                }\n                if (R[i][j] == 'R') {\n                    S.ry = i;\n                    S.rx = j;\n                } else if (R[i][j] == '%') {\n                    G.ry = i;\n                    G.rx = j;\n                }\n            }\n        }\n        \n        bool ok = false;\n        queue<State> q;\n        q.push(S);\n        while ( ! ok && ! q.empty()) {\n            State t = q.front(); q.pop();\n            if (used[t.ly][t.lx][t.ry][t.rx]) continue;\n            used[t.ly][t.lx][t.ry][t.rx] = 1;\n            for (int i=0; i<4; ++i) {\n                State t2 = t;\n                if (L[t.ly + LDY[i]][t.lx + LDX[i]] != '#') {\n                    t2.ly += LDY[i];\n                    t2.lx += LDX[i];\n                }\n                if (R[t.ry + RDY[i]][t.rx + RDX[i]] != '#') {\n                    t2.ry += RDY[i];\n                    t2.rx += RDX[i];\n                }\n                if (t2 == G) {\n                    ok = true;\n                    break;\n                }\n                if ((L[t2.ly][t2.lx] == '%' && R[t2.ry][t2.rx] != '%')\n                || (L[t2.ly][t2.lx] != '%' && R[t2.ry][t2.rx] == '%')) {\n                    continue;\n                }\n                if ( ! used[t2.ly][t2.lx][t2.ry][t2.rx]) q.push(t2);\n            }\n        }\n        cout << (ok ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <set>\n#include <queue>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\tint h, w, i, j, a, b, c, d, dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\n\tchar rf[50][51], lf[50][51];\n\tset<pair<P,P> > s;\n\tP rs, ls, rg, lg;\n\tqueue<P> r, l;\n\twhile(1){\n\t\tscanf(\"%d%d%*c\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tlf[i][j] = getchar();\n\t\t\t\tif(lf[i][j] == 'L'){\n\t\t\t\t\tls = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(lf[i][j] == '%'){\n\t\t\t\t\tlg = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 空白読み飛ばし\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\trf[i][j] = getchar();\n\t\t\t\tif(rf[i][j] == 'R'){\n\t\t\t\t\trs = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(rf[i][j] == '%'){\n\t\t\t\t\trg = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 改行文字読み飛ばし\n\t\t}\n\t\tr.push(rs), l.push(ls);\n\t\twhile(r.size()){\n\t\t\ta = l.front().first, b = l.front().second, c = r.front().first, d = r.front().second;\n\t\t\tl.pop(), r.pop();\n\t\t\ts.insert(pair<P,P>(P(a,b),P(c,d)));\n\t\t\tfor(i = 0;i < 4;i++){\n\t\t\t\tif(a + dy[i] >= 0 && a + dy[i] < h && b + dx[i] >= 0 && b + dx[i] < w && lf[a + dy[i]][b + dx[i]] == '.' && c + dy[i] >= 0 && c + dy[i] < h && d - dx[i] >= 0 && d - dx[i] < w && rf[c + dy[i]][d - dx[i]] == '.' && s.find(pair<P,P>(P(a + dy[i],b + dx[i]),P(c + dy[i],d - dx[i]))) == s.end()) // 両方とも動くとき\n\t\t\t\t\tl.push(P(a + dy[i],b + dx[i])), r.push(P(c + dy[i],d - dx[i]));\n\t\t\t\telse if((a + dy[i] < 0 || a + dy[i] >= h || b + dx[i] < 0 || b + dx[i] >= w || lf[a + dy[i]][b + dx[i]] == '#') && c + dy[i] >= 0 && c + dy[i] < h && d - dx[i] >= 0 && d - dx[i] < w && rf[c + dy[i]][d - dx[i]] == '.' && s.find(pair<P,P>(P(a,b),P(c + dy[i],d - dx[i]))) == s.end()) // Rinだけ動く\n\t\t\t\t\tl.push(P(a,b)), r.push(P(c + dy[i],d - dx[i]));\n\t\t\t\telse if(a + dy[i] >= 0 && a + dy[i] < h && b + dx[i] >= 0 && b + dx[i] < w && lf[a + dy[i]][b + dx[i]] == '.' && (c + dy[i] < 0 || c + dy[i] >= h || d - dx[i] < 0 || d - dx[i] >= w || rf[c + dy[i]][d - dx[i]] == '#') && s.find(pair<P,P>(P(a + dy[i],b + dx[i]),P(c,d))) == s.end()) // Lenだけ動く\n\t\t\t\t\tl.push(P(a + dy[i],b + dx[i])), r.push(P(c,d));\n\t\t\t}\n\t\t}\n\t\tif(s.find(pair<P,P>(P(lg.first,lg.second),P(rg.first,rg.second))) != s.end())\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t\tfor(set<pair<P,P> >::iterator iti = s.begin();iti != s.end();iti = s.erase(iti));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nstruct POINT\n{\n\tint x, y;\n\tbool operator<(const POINT &t)const{\n\t\tif (x == t.x) return y < t.y;\n\t\treturn x < t.x;\n\t}\n\tbool operator==(const POINT &t)const{\n\t\treturn x == t.x && y == t.y;\n\t}\n};\n\nstruct P\n{\n\tPOINT l, r;\n\tbool operator<(const P &t)const{\n\t\tif (l == t.l) return r < t.r;\n\t\treturn l < t.l;\n\t}\n};\n\nchar g1[64][64], g2[64][64];\n\nint main()\n{\n\tint w, h;\n\twhile (scanf(\"%d %d\", &w, &h), w + h){\n\t\tmemset(g1, '#', sizeof(g1));\n\t\tmemset(g2, '#', sizeof(g2));\n\t\t\n\t\tPOINT L, R;\n\t\tfor (int i = 1; i <= h; i++){\n\t\t\tfor (int j = 1; j <= w; j++){\n\t\t\t\tscanf(\" %c\", &g1[i][j]);\n\t\t\t\tif (g1[i][j] == 'L'){\n\t\t\t\t\tL = {i, j};\n\t\t\t\t\tg1[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = w; j >= 1; j--){\n\t\t\t\tscanf(\" %c\", &g2[i][j]);\n\t\t\t\tif (g2[i][j] == 'R'){\n\t\t\t\t\tR = {i, j};\n\t\t\t\t\tg2[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<P> que;\n\t\tstatic bool done[51][51][51][51] = {false};\n\t\tmemset(done, 0, sizeof(done));\n\t\tbool res = false;\n\t\tfor (que.push({L, R}); !que.empty(); que.pop()){\n\t\t\tP p = que.front();\n\t\t\t\n\t\t\t//printf(\"%d %d %d %d\\n\", p.l.x, p.l.y, p.r.x, p.r.y);\n\t\t\t\n\t\t\tif (done[p.l.x][p.l.y][p.r.x][p.r.y]) continue;\n\t\t\tdone[p.l.x][p.l.y][p.r.x][p.r.y] = true;\n\t\t\t\n\t\t\tif (g1[p.l.x][p.l.y] == '%' && g2[p.r.x][p.r.y] == '%'){\n\t\t\t\tres = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (g1[p.l.x][p.l.y] == '%' || g2[p.r.x][p.r.y] == '%'){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\t\tint ltx = p.l.x + dx[dir];\n\t\t\t\tint lty = p.l.y + dy[dir];\n\t\t\t\tint rtx = p.r.x + dx[dir];\n\t\t\t\tint rty = p.r.y + dy[dir];\n\t\t\t\t\n\t\t\t\tif (g1[ltx][lty] == '#'){\n\t\t\t\t\tltx = p.l.x;\n\t\t\t\t\tlty = p.l.y;\n\t\t\t\t}\n\t\t\t\tif (g2[rtx][rty] == '#'){\n\t\t\t\t\trtx = p.r.x;\n\t\t\t\t\trty = p.r.y;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tque.push({{ltx, lty}, {rtx, rty}});\n\t\t\t}\n\t\t}\n\t\tprintf(res ? \"Yes\\n\" : \"No\\n\");\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp make_pair\n#define pb push_back\n#define F first\n#define S second\n\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nbool app[50][50][50][50];\n\nmain(){\n  int w,h;\n  while(cin>>w>>h,w|h){\n    memset(app,0,6250000);\n    string lr[h],rr[h];\n    rep(i,h){\n      cin>>lr[i]>>rr[i];\n    }\n\n    string ans=\"No\";\n    int rsx,rsy,lsx,lsy;\n    rep(i,h)rep(j,w){\n      if(lr[i][j]=='L')lsx=i,lsy=j;\n      if(rr[i][j]=='R')rsx=i,rsy=j;\n    }\n\n    queue<pair<PI,PI> > Q;\n    Q.push(mp(mp(lsx,lsy),mp(rsx,rsy)));\n    app[lsx][lsy][rsx][rsy]=true;\n\n    while(!Q.empty()){\n      pair<PI,PI> tp=Q.front();Q.pop();\n      int clx=tp.F.F,cly=tp.F.S,crx=tp.S.F,cry=tp.S.S;\n\n      if(lr[clx][cly]=='%' && rr[crx][cry]=='%'){\n        ans=\"Yes\";\n        break;\n      }\n\n      if(lr[clx][cly]=='%' || rr[crx][cry]=='%')continue;\n      \n\n      rep(i,4){\n        int nrx=crx+dx[i],nlx=clx+dx[i],nry=cry+dy[i],nly=cly-dy[i];\n        if(nrx<0 || nry<0 || nrx>=h || nry>=w || lr[nrx][nry]=='#')nrx=crx,nry=cry;\n        if(nlx<0 || nly<0 || nlx>=h || nly>=w || rr[nlx][nly]=='#')nlx=clx,nly=cly;\n        if(app[nlx][nly][nrx][nry])continue;\n        app[nlx][nly][nrx][nry]=true;\n        Q.push(mp(mp(nlx,nly),mp(nrx,nry)));\n      }\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n#define MAXH 52\n#define MAXW 52\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nint w, h;\nchar field_r[MAXH][MAXW];\nchar field_l[MAXH][MAXW];\n\nstruct state {\n    int xl, yl, xr, yr;\n};\n\nint main(void) {\n    while (1) {\n        cin >> w >> h;\n        if (w == 0 && h == 0) break;\n        vector<string> roomr(h), rooml(h);\n        for (int i = 0; i < h; i++) {\n            cin >> rooml[i] >> roomr[i];\n        }\n        int sxl, syl, sxr, syr;\n        bool done[MAXH][MAXW][MAXH][MAXW] = {false};\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (rooml[i][j] == 'L') {\n                    sxl = j; syl = i;\n                }\n                if (roomr[i][j] == 'R') {\n                    sxr = j; syr = i;\n                }\n            }\n        }\n        state s;\n        s.xl = sxl; s.yl = syl; s.xr = sxr; s.yr = syr;\n        queue<state> que;\n        que.push(s);\n        bool ok = false;\n        done[sxl][syl][sxr][syr] = true;\n        while (!que.empty()) {\n            state now = que.front(); que.pop();\n            if (rooml[now.yl][now.xl] == '%' && roomr[now.yr][now.xr] == '%') {\n                cout << \"Yes\" << endl;\n                ok = true;\n                break;\n            }\n            if (rooml[now.yl][now.xl] == '%' && roomr[now.yr][now.xr] != '%') continue;\n            if (rooml[now.yl][now.xl] != '%' && roomr[now.yr][now.xr] == '%') continue;\n            for (int i = 0; i < 4; i++) {\n                int nxl = now.xl + dx[i];\n                int nyl = now.yl + dy[i];\n                int nxr = now.xr - dx[i];\n                int nyr = now.yr + dy[i];\n                if (nxl < 0 || nxl >= w || nyl < 0 || nyl >= h || rooml[nyl][nxl] == '#') {\n                    nxl = now.xl; nyl = now.yl;\n                }\n                if (nxr < 0 || nxr >= w || nyr < 0 || nyr >= h || roomr[nyr][nxr] == '#') {\n                    nxr = now.xr; nyr = now.yr;\n                }\n                if (done[nxl][nyl][nxr][nyr]) continue;\n                done[nxl][nyl][nxr][nyr] = true;\n                state st;\n                st.xl = nxl; st.yl = nyl; st.xr = nxr; st.yr = nyr;\n                que.push(st);\n            }\n        }\n        if (!ok) cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\nstring ml[50], mr[50];\nbool fm[50][50][50][50];\nconst int dx[] = { 0,1,0,-1 };\nconst int dy[] = { 1,0,-1,0 };\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h, w) {\n\t\tfill((bool*)fm, (bool*)fm + 2500 * 2500, 0);\n\t\tvector<pair<pii,pii>> que;\n\t\tpii r, l, gl, gr;\n\t\tpair<pii, pii> g;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tcin >> ml[i] >> mr[i];\n\t\t\tint a = ml[i].find('L');\n\t\t\tif (a != string::npos)l = make_pair(a, i);\n\t\t\ta = ml[i].find('%');\n\t\t\tif (a != string::npos)gl = make_pair(a, i);\n\t\t\ta = mr[i].find('R');\n\t\t\tif (a != string::npos)r = make_pair(a, i);\n\t\t\ta = mr[i].find('%');\n\t\t\tif (a != string::npos)gr = make_pair(a, i);\n\t\t}\n\t\tg = make_pair(gl, gr);\n\t\tque.push_back(make_pair(l, r));\n\t\tbool f = 0;\n\t\twhile (!que.empty()&&!f) {\n\t\t\tauto top = que.back();\n\t\t\tque.pop_back();\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tauto n = top;\n\t\t\t\tn.first.first += dx[i];\n\t\t\t\tn.first.second += dy[i];\n\t\t\t\tn.second.first -= dx[i];\n\t\t\t\tn.second.second += dy[i];\n\t\t\t\tif (n.first.first < 0 || n.first.first >= w)n.first.first = top.first.first;\n\t\t\t\tif (n.first.second < 0 || n.first.second >= h)n.first.second = top.first.second;\n\t\t\t\tif (n.second.first < 0 || n.second.first >= w)n.second.first = top.second.first;\n\t\t\t\tif (n.second.second < 0 || n.second.second >= h)n.second.second = top.second.second;\n\t\t\t\tif (ml[n.first.second][n.first.first] == '#')n.first = top.first;\n\t\t\t\tif (mr[n.second.second][n.second.first] == '#')n.second = top.second;\n\t\t\t\tif (ml[n.first.second][n.first.first] == '%'&&mr[n.second.second][n.second.first] == '%') {\n\t\t\t\t\tf = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (ml[n.first.second][n.first.first] == '%'^mr[n.second.second][n.second.first] == '%')continue;\n\t\t\t\tbool a = 1;\n\t\t\t\tswap(fm[n.first.first][n.first.second][n.second.first][n.second.second], a);\n\t\t\t\tif (a)continue;\n\t\t\t\tque.push_back(n);\n\t\t\t}\n\t\t}\n\t\tcout << (f ? \"Yes\" : \"No\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// C++11\n#include \"bits/stdc++.h\"\n#include <sys/time.h>\n#include <emmintrin.h>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <random>\n#include <bitset>\n\nusing namespace std;\n\ninline long long GetTSC() {\n  long long lo, hi;\n  asm volatile (\"rdtsc\": \"=a\"(lo), \"=d\"(hi));\n  return lo + (hi << 32);\n}\ninline double GetSeconds() {\n  return GetTSC() / 2.8e9;\n}\n\nconst long inf = pow(10,15);\nint di[] = {-1,0,1,0};\nint dj[] = {0,1,0,-1};\ntuple<int, int>q[50*50*50*50];\n\nvoid solve(){\n  double starttime = GetSeconds();\n  while(1){\n    int w,h;\n    cin >> w >> h;\n    // cerr << w << \", \" << h << endl;\n    if(w==0 && h==0) break;\n    int lp,ls,rp,rs;\n    bool lb[2500] = {};\n    bool rb[2500] = {};\n    bool f[2500][2500] = {};\n    for(int i=0; i<h; i++){\n      string s;\n      cin >> s;\n      for(int j=0; j<w; j++){\n        if(s[j]=='#') lb[i*w+j] = 1;\n        if(s[j]=='%') lp = i*w+j;\n        if(s[j]=='L') ls = i*w+j;\n      }\n      cin >> s;\n      for(int j=0; j<w; j++){\n        if(s[j]=='#') rb[i*w+j] = 1;\n        if(s[j]=='%') rp = i*w+j;\n        if(s[j]=='R') rs = i*w+j;\n      }\n    }\n    f[ls][rs] = 1;\n    int qi = 0;\n    int qe = 1;\n    q[0] = make_tuple(ls,rs);\n    bool ff = 0;\n    while(qi<qe){\n      int lt = get<0>(q[qi]);\n      int rt = get<1>(q[qi]);\n      int li = lt / w;\n      int lj = lt % w;\n      int ri = rt / w;\n      int rj = rt % w;\n      qi++;\n      // cerr << \"qie: \" << qi << \", \" << qe << \", lij: \" << li << \", \" << lj << \", rij: \" << ri << \", \" << rj << endl;\n      for(int i=0; i<4; i++){\n        int nli = li + di[i];\n        int nlj = lj + dj[i];\n        int nri = ri + di[i];\n        int nrj = rj - dj[i];\n        if(nli < 0 || nli >= h || nlj < 0 || nlj >= w || lb[nli*w+nlj]){\n          nli = li;\n          nlj = lj;\n        }\n        if(nri < 0 || nri >= h || nrj < 0 || nrj >= w || rb[nri*w+nrj]){\n          nri = ri;\n          nrj = rj;\n        }\n        int nlt = nli*w+nlj;\n        int nrt = nri*w+nrj;\n        if(nlt == lp && nrt == rp){\n          ff = 1;\n          break;\n        }\n        if(nlt == lp || nrt == rp) continue;\n        if(f[nlt][nrt]) continue;\n        f[nlt][nrt] = 1;\n        q[qe++] = make_tuple(nlt,nrt);\n      }\n      if(ff) break;\n    }\n    if(ff){\n      cout << \"Yes\" << endl;\n    }else{\n      cout << \"No\" << endl;\n    }\n  }\n  // cerr << \"time: \" << GetSeconds() - starttime << endl;\n\n  return;\n}\n\nint main() {\n  solve();\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "from collections import deque\nwhile True:\n    w,h=map(int,input().split(\" \"))\n    def isrange(p):\n        return 0<=p[0] and p[0]<h and 0<=p[1] and p[1]<w\n    if w==0: break\n    rl=[[str()] for i in range(h)]\n    rr=[[str()] for i in range(h)]\n    for i in range(h):\n        rl[i],rr[i]=input().split(\" \")\n    q = deque()\n    s=set()\n    for i in range(h):\n        for j in range(w):\n            if rl[i][j]==\"L\": ls=(i,j)\n            if rr[i][j]==\"R\": rs=(i,j)\n            if rl[i][j]==\"%\": gl=(i,j)\n            if rr[i][j]==\"%\": gr=(i,j)\n    q.append((ls,rs))\n    dw=(-1,0,1,0)\n    dh=(0,1,0,-1)\n    while q:\n        val=q.pop()\n        if val in s: continue\n        s.add(val)\n        lp=val[0]\n        rp=val[1]\n        for i in range(4):\n            lnp=(lp[0]+dh[i],lp[1]+dw[i])\n            rnp=(rp[0]+dh[i],rp[1]-dw[i])\n            if (not isrange(lnp)) or rl[lnp[0]][lnp[1]]==\"#\" : lnp=lp\n            if (not isrange(rnp)) or rr[rnp[0]][rnp[1]]==\"#\" : rnp=rp\n            q.append((lnp,rnp))\n    if (gl,gr) in s : print(\"Yes\")\n    else : print(\"No\")"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,s,n) for(int i=s; i<n; i++)\n#define ALL(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nint w, h;\nint rooml[60][60], roomr[60][60];\nbool memo[60][60][60][60];\n\nbool dfs(int xl, int yl, int xr, int yr) {\n\tif( xl<=0 || w+1<=xl || yl<=0 || h+1<=yl || \n\t\txr<=0 || w+1<=xr || yr<=0 || h+1<=yr ) {\n\t\treturn false;\n\t}\n\n\tif( memo[xl][yl][xr][yr] ) {\n\t\treturn false;\n\t}\n\tmemo[xl][yl][xr][yr] = true;\n\tconst int dx[4] = {-1, 0, 1, 0};\n\tconst int dy[4] = {0, 1, 0, -1};\n\tbool f = false;\n\trep(i, 4) {\n\t\tint nxl = xl + dx[i];\n\t\tint nyl = yl + dy[i];\n\t\tint nxr = xr - dx[i];\n\t\tint nyr = yr + dy[i];\n\t\tint nl = rooml[nyl][nxl];\n\t\tint nr = roomr[nyr][nxr];\n\t\tif( nl==2 && nr==2 ) {\n\t\t\tf = true;\n\t\t}\n\t\telse if( nl==1 && nr==1 ) {\n\t\t\tf |= dfs(nxl, nyl, nxr, nyr);\n\t\t}\n\t\telse if( nl==1 && nr==0 ) {\n\t\t\tf |= dfs(nxl, nyl, xr, yr);\n\t\t}\n\t\telse if( nl==0 && nr==1 ) {\n\t\t\tf |= dfs(xl, yl, nxr, nyr);\n\t\t}\n\t}\n\treturn f;\n}\n\nint main() {\n\twhile(cin >> w >> h, w) {\n\t\tmemset(rooml, 0, sizeof(rooml));\n\t\tmemset(roomr, 0, sizeof(roomr));\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tint xl=1, yl=1, xr=1, yr=1;\n\t\trep(y, h) {\n\t\t\tstring sl, sr;\n\t\t\tcin >> sl >> sr;\n\t\t\trep(x, w) {\n\t\t\t\tif(sl[x] == 'L') {\n\t\t\t\t\txl = x+1;\n\t\t\t\t\tyl = y+1;\n\t\t\t\t\trooml[y+1][x+1] = 1;\n\t\t\t\t} else {\n\t\t\t\t\trooml[y+1][x+1] = (sl[x]=='%' ? 2 : (sl[x]=='.' ? 1 : 0));\n\t\t\t\t}\n\t\t\t\tif(sr[x] == 'R') {\n\t\t\t\t\txr = x+1;\n\t\t\t\t\tyr = y+1;\n\t\t\t\t\troomr[y+1][x+1] = 1;\n\t\t\t\t} else {\n\t\t\t\t\troomr[y+1][x+1] = (sr[x]=='%' ? 2 : (sr[x]=='.' ? 1 : 0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( dfs(xl, yl, xr, yr) ) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t} else {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing Coor = pair<int, int>;\nusing Pair = pair<Coor, Coor>;\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {-1, 0, 1, 0};\n\nint H;\nint W;\nint sty[2];\nint stx[2];\nint y[2];\nint x[2];\nchar field[2][50][50];\nbool dp[50][50][50][50];\n\nbool WithinRange(int y, int x) {\n  if (y < 0 || H <= y) return false;\n  if (x < 0 || W <= x) return false;\n  return true;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &W, &H);\n    if (W == 0 && H == 0) return 0;\n\n    for (int i=0; i<H; i++) {\n      for (int j=0; j<W; j++) {\n        scanf(\" %c\", &field[0][i][j]);\n        if (field[0][i][j] == '%') {\n          sty[0] = i;\n          stx[0] = j;\n        }\n        if (field[0][i][j] == 'L') {\n          y[0] = i;\n          x[0] = j;\n        }\n      }\n      for (int j=0; j<W; j++) {\n        scanf(\" %c\", &field[1][i][W-1-j]);\n        if (field[1][i][W-1-j] == '%') {\n          sty[1] = i;\n          stx[1] = W-1-j;\n        }\n        if (field[1][i][W-1-j] == 'R') {\n          y[1] = i;\n          x[1] = W-1-j;\n        }\n      }\n    }\n\n    for (int i=0; i<H; i++) {\n      for (int j=0; j<W; j++) {\n        for (int k=0; k<H; k++) {\n          for (int l=0; l<W; l++) {\n            dp[i][j][k][l] = false;\n          }\n        }\n      }\n    }\n\n    dp[y[0]][x[0]][y[1]][x[1]] = true;\n    queue<Pair> q;\n    q.push(Pair(Coor(y[0], x[0]), Coor(y[1], x[1])));\n    while (!q.empty()) {\n      Pair p = q.front(); q.pop();\n      Coor c1 = p.first;\n      int y1 = c1.first;\n      int x1 = c1.second;\n      Coor c2 = p.second;\n      int y2 = c2.first;\n      int x2 = c2.second;\n\n      for (int i=0; i<4; i++) {\n        int newy1 = y1 + dy[i];\n        int newy2 = y2 + dy[i];\n        int newx1 = x1 + dx[i];\n        int newx2 = x2 + dx[i];\n        if (!WithinRange(newy1, newx1) || field[0][newy1][newx1] == '#') {\n          newy1 -= dy[i];\n          newx1 -= dx[i];\n        }\n\n        if (!WithinRange(newy2, newx2) || field[1][newy2][newx2] == '#') {\n          newy2 -= dy[i];\n          newx2 -= dx[i];\n        }\n\n        if (dp[newy1][newx1][newy2][newx2]) continue;\n        dp[newy1][newx1][newy2][newx2] = true;\n        q.push(Pair(Coor(newy1, newx1), Coor(newy2, newx2)));\n      }\n    }\n\n    if (dp[sty[0]][stx[0]][sty[1]][stx[1]]) puts(\"Yes\");\n    else puts(\"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = {-1,0,1,0}; const int dy[] = {0,1,0,-1};\n\nconst int MAX_W = 52;\nconst int MAX_H = 52;\n\nchar fieldL[MAX_H][MAX_W];\nchar fieldR[MAX_H][MAX_W];\n\nbool dfsG[MAX_H][MAX_W];\n\nbool dfsL(pii p, pii& g){\n\tif(p == g) return true;\n\tdfsG[p.second][p.first] = true;\n\n\tREP(i, 4){\n\t\tpii next = {p.first + dx[i], p.second + dy[i]};\n\t\tif(dfsG[next.second][next.first])continue;\n\t\tif(fieldL[next.second][next.first] != '#'){\n\t\t\tif(dfsL(next, g)) return true;\n\t\t}\n\t}\n\n\treturn false;\n}\nbool dfsR(pii p, pii& g){\n\tif(p == g) return true;\n\tdfsG[p.second][p.first] = true;\n\n\tREP(i, 4){\n\t\tpii next = {p.first + dx[i], p.second + dy[i]};\n\t\tif(dfsG[next.second][next.first])continue;\n\t\tif(fieldR[next.second][next.first] != '#'){\n\t\t\tif(dfsR(next, g)) return true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tint w, h;\n\twhile(cin >> w >> h, w|h){\n\t\tfill_n((char *)fieldL, MAX_W * MAX_H, '#');\n\t\tfill_n((char *)fieldR, MAX_W * MAX_H, '#');\n\n\t\tpii ls, rs, lg, rg;\n\t\tREP(y, h){\n\t\t\tchar c;\n\t\t\tREP(x, w){\n\t\t\t\tcin >> c;\n\t\t\t\tswitch(c){\n\t\t\t\tcase '%':\n\t\t\t\t\tc = '.';\n\t\t\t\t\tlg.first = x + 1;\n\t\t\t\t\tlg.second = y + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\tc = '.';\n\t\t\t\t\tls.first = x + 1;\n\t\t\t\t\tls.second = x + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfieldL[y + 1][x + 1] = c;\n\t\t\t}\n\t\t\tREP(x, w){\n\t\t\t\tcin >> c;\n\t\t\t\tswitch(c){\n\t\t\t\tcase '%':\n\t\t\t\t\tc = '.';\n\t\t\t\t\trg.first = x + 1;\n\t\t\t\t\trg.second = y + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tc = '.';\n\t\t\t\t\trs.first = x + 1;\n\t\t\t\t\trs.second = y + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfieldR[y + 1][x + 1] = c;\n\t\t\t}\n\t\t}\n\n\t\tfill_n((bool *)dfsG, MAX_W*MAX_H, false);\n\t\tbool lres = dfsL(ls, lg);\n\t\tfill_n((bool *)dfsG, MAX_W*MAX_H, false);\n\t\tbool rres = dfsR(rs, rg);\n\t\tif(!lres || !rres){\n\t\t\tcout << \"No!!\" << endl;\n\t\t}\n\n\t\t/*\n\t\tLOG(\"------\\n\");\n\t\tREP(y, h + 2){\n\t\t\tREP(x, w + 2){\n\t\t\t\tLOG(\"%c\", fieldL[y][x]);\n\t\t\t}\n\t\t\tLOG(\"\\n\");\n\t\t}\n\t\tLOG(\"------\\n\");\n\t\tREP(y, h + 2){\n\t\t\tREP(x, w + 2){\n\t\t\t\tLOG(\"%c\", fieldR[y][x]);\n\t\t\t}\n\t\t\tLOG(\"\\n\");\n\t\t}\n\t\tLOG(\"------\\n\");\n\t\t*/\n\n//\t\tLOG(\"%d %d ,, %d %d\\n\", ls.first, ls.second , rs.first, rs.second);\n\n\t\tset<pair<pii, pii>> G;\n\t\tqueue<pair<pii, pii>> que;\n\t\tque.push({ls, rs});\n\t\tbool res = false;\n\t\twhile(!que.empty()){\n\t\t\tpii L = que.front().first;\n\t\t\tpii R = que.front().second;\n\t\t\tque.pop();\n\n//\t\t\tLOG(\"%d %d |||| %d %d\\n\", L.first, L.second , R.first, R.second);\n\n\t\t\tif(L == lg){\n\t\t\t\tif(R == rg){\n\t\t\t\t\tres = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}else if(R == rg) continue;\n\n\t\t\tREP(i, 4){\n\t\t\t\tpii nextL = {L.first + dx[i], L.second + dy[i]};\n\t\t\t\tpii nextR = {R.first - dx[i], R.second + dy[i]};\n\t\t\t\tif(fieldL[nextL.second][nextL.first] == '#'){\n\t\t\t\t\tnextL = L;\n\t\t\t\t}\n\t\t\t\tif(fieldR[nextR.second][nextR.first] == '#'){\n\t\t\t\t\tnextR = R;\n\t\t\t\t}\n\t\t\t\tpair<pii, pii> next = {nextL, nextR};\n\n//\t\t\t\tLOG(\"%c %c   %d %d  <<<--- %d %d\\n\", fieldL[nextL.second][nextL.first],fieldR[nextR.second][nextR.first], nextR.first, nextR.second, R.first, R.second);\n\t\t\t\tif(G.insert(next).second)\n\t\t\t\t\tque.push({nextL, nextR});\n\t\t\t}\n\t\t}\n\n\t\tcout << (res ? \"Yes\" : \"No\") << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n\n#define F first\n#define S second\n\nusing namespace std;\n\nconst int MAX = 51;\ntypedef pair<int,int> P;\nchar M[2][MAX][MAX];\nbool come[MAX][MAX][MAX][MAX];\nint W,H;\nP s1,s2;\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\n\nvoid init(){\n  memset(come,false,sizeof(come));\n}\n\nvoid print(){\n  for(int x = 0; x < 2; x++){\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++) cout << M[x][i][j];\n      cout << endl;\n    }\n    cout << endl<< endl;\n  }\n}\n\nvoid input(){\n  for(int i = 0; i < H; i++)\n    for(int x = 0; x < 2; x++)\n      for(int j = 0; j < W; j++){\n\tcin >> M[x][i][j];\n\tif(M[x][i][j] == 'L' && !x) s1 = P(i,j);\n\tif(M[x][i][j] == 'R' && x) s2 = P(i,j);\n\t}\n}\n\nbool isInside(int x, int y){return 0<=x&&x<W&&0<=y&&y<H;}\n\nbool rec(int x1, int y1, int x2, int y2){\n  if(come[x1][y1][x2][y2]) return false;\n  come[x1][y1][x2][y2] = true;\n  // cout << x1 <<  \" \" << y1 << \" \" << x2 << \" \" << y2 <<endl;\n  if(M[0][y1][x1] == '%' && M[1][y2][x2] == '%') return true;\n  if(M[0][y1][x1] == '%' || M[1][y2][x2] == '%') return false;\n  \n  bool tmp = false;\n\n  for(int i = 0; i < 4; i++){\n    int nx1 = x1+dx[i];\n    int ny1 = y1+dy[i];\n    int nx2 = x2-dx[i];\n    int ny2 = y2+dy[i];\n    if(!isInside(nx1,ny1) || M[0][ny1][nx1] == '#'){\n      nx1 = x1;\n      ny1 = y1;\n    }\n    if(!isInside(nx2,ny2) || M[1][ny2][nx2] == '#'){\n      nx2 = x2;\n      ny2 = y2;\n    }\n    tmp =(tmp||rec(nx1,ny1,nx2,ny2));\n  }\n  return tmp;\n} \n\nvoid solve(){\n  if(rec(s1.S,s1.F,s2.S,s2.F)) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n}\n\nint main(){\n  while(cin >> W >> H && W+H){\n    init();\n    input();\n    //   print();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nconst int SZ = 51;\n\nint dx[] = {0, -1, 0, 1};\nint dy[] = {1, 0, -1, 0};\n\nint H, W;\nbool visit[SZ][SZ][SZ][SZ];\nstring LIN[SZ], REN[SZ];\n\ninline bool inside(int x, int y){\n  return 0 <= x && x < H && 0 <= y && y < W;\n}\n\nbool bfs(int lsx, int lsy, int rsx, int rsy){\n  memset(visit, false, sizeof(visit));\n  visit[lsx][lsy][rsx][rsy] = true;\n  queue<int> que_lx, que_ly, que_rx, que_ry;\n  que_lx.push(lsx);\n  que_ly.push(lsy);\n  que_rx.push(rsx);\n  que_ry.push(rsy);\n  while(!que_lx.empty()){\n\n    int lx = que_lx.front(); que_lx.pop();\n    int ly = que_ly.front(); que_ly.pop();\n    int rx = que_rx.front(); que_rx.pop();\n    int ry = que_ry.front(); que_ry.pop();\n    \n    if(LIN[lx][ly] == '%' && REN[rx][ry] == '%') return true;\n    REP(i, 4){\n      int nlx = lx + dx[i];\n      int nly = ly + dy[i];\n      int nrx = rx + dx[i];\n      int nry = ry + dy[(i+2)%4];\n      \n      if(!inside(nlx, nly) || LIN[nlx][nly] == '#') nlx = lx, nly = ly;\n      if(!inside(nrx, nry) || REN[nrx][nry] == '#') nrx = rx, nry = ry;\n      if(!visit[nlx][nly][nrx][nry] && !((LIN[lx][ly] == '%') ^ (REN[rx][ry]=='%'))){\n        visit[nlx][nly][nrx][nry] = true;\n        que_lx.push(nlx);\n        que_ly.push(nly);\n        que_rx.push(nrx);\n        que_ry.push(nry);        \n      }\n    }\n  }\n  \n  return false;\n}\n\n\nint main(){\n  while(cin >> W >> H && H + W > 0){\n    REP(i, H) cin >> LIN[i] >> REN[i];\n    int rsx, rsy, lsx, lsy;\n    \n    REP(i, H)REP(j, W){\n      if(LIN[i][j] == 'L') lsx = i, lsy = j;\n      if(REN[i][j] == 'R') rsx = i, rsy = j;\n    }\n    cout << (bfs(lsx, lsy, rsx, rsy) ? \"Yes\" : \"No\") << endl;\n      \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,s,n) for(int i=s; i<n; i++)\n#define ALL(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nint w, h;\nint rooml[60][60], roomr[60][60];\nbool memo[60][60][60][60];\n\nbool dfs(int xl, int yl, int xr, int yr) {\n\tif( memo[xl][yl][xr][yr] ) {\n\t\treturn false;\n\t}\n\tmemo[xl][yl][xr][yr] = true;\n\tconst int dx[4] = {-1, 0, 1, 0};\n\tconst int dy[4] = {0, 1, 0, -1};\n\trep(i, 4) {\n\t\tint nxl = xl + dx[i];\n\t\tint nyl = yl + dy[i];\n\t\tint nxr = xr - dx[i];\n\t\tint nyr = yr + dy[i];\n\t\tif(nxl<0 || nxl>=w+1 || nyl<0 || nyl>=h+1 ||\n\t\t\t\tnxr<0 || nxr>=w+1 || nyr<0 || nyr>=h+1 ) continue;\n\t\tint nl = rooml[nyl][nxl];\n\t\tint nr = roomr[nyr][nxr];\n\t\tif( nl==2 && nr==2 ) {\n\t\t\treturn true;\n\t\t}\n\t\telse if( nl==1 && nr==1 ) {\n\t\t\tbool f = dfs(nxl, nyl, nxr, nyr);\n\t\t\tif(f) return true;\n\t\t}\n\t\telse if( nl==1 && nr==0 ) {\n\t\t\tbool f = dfs(nxl, nyl, xr, yr);\n\t\t\tif(f) return true;\n\t\t}\n\t\telse if( nl==0 && nr==1 ) {\n\t\t\tbool f = dfs(xl, yl, nxr, nyr);\n\t\t\tif(f) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\twhile(cin >> w >> h, w||h) {\n\t\tmemset(rooml, 0, sizeof(rooml));\n\t\tmemset(roomr, 0, sizeof(roomr));\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tint xl, yl, xr, yr;\n\t\trep(y, h) {\n\t\t\tstring sl, sr;\n\t\t\tcin >> sl >> sr;\n\t\t\trep(x, w) {\n\t\t\t\tif(sl[x] == 'L') {\n\t\t\t\t\txl = x+1;\n\t\t\t\t\tyl = y+1;\n\t\t\t\t\trooml[y+1][x+1] = 1;\n\t\t\t\t} else {\n\t\t\t\t\trooml[y+1][x+1] = (sl[x]=='%' ? 2 : (sl[x]=='.' ? 1 : 0));\n\t\t\t\t}\n\t\t\t\tif(sr[x] == 'R') {\n\t\t\t\t\txr = x+1;\n\t\t\t\t\tyr = y+1;\n\t\t\t\t\troomr[y+1][x+1] = 1;\n\t\t\t\t} else {\n\t\t\t\t\troomr[y+1][x+1] = (sr[x]=='%' ? 2 : (sr[x]=='.' ? 1 : 0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( dfs(xl, yl, xr, yr) ) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t} else {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nint w, h;\nchar f1[54][54], f2[54][54];\nbool visit[54][54][54][54];\nint dys[] = {-1, 0, 1, 0};\nint dxs[] = {0, -1, 0, 1};\n\nvoid trymove(const char f[][54], int &y, int &x, int dy, int dx){\n\tif(f[y + dy][x + dx] != '#'){\n\t\ty += dy;\n\t\tx += dx;\n\t}\n}\n\nbool solve(){\n\tmemset(f1, '#', sizeof f1);\n\tmemset(f2, '#', sizeof f2);\n\tmemset(visit, 0, sizeof visit);\n\n\tint ly = -1, lx = -1, ry = -1, rx = -1;\n\tfor(int i = 1; i <= h; ++i){\n\t\tscanf(\"%s%s\", f1[i] + 1, f2[i] + 1);\n\t\tf1[i][w + 1] = f2[i][w + 1] = '#';\n\t\t\n\t\tfor(int j = 1; j <= w; ++j){\n\t\t\tif(f1[i][j] == 'L'){\n\t\t\t\tly = i;\n\t\t\t\tlx = j;\n\t\t\t}\n\t\t\tif(f2[i][j] == 'R'){\n\t\t\t\try = i;\n\t\t\t\trx = j;\n\t\t\t}\n\t\t}\n\t}\n\n\tvisit[ly][lx][ry][rx] = true;\n\tqueue<int> q;\n\tq.push(ly << 24 | lx << 16 | ry << 8 | rx);\n\twhile(!q.empty()){\n\t\tfor(int i = 0; i < 4; ++i){\n\t\t\tly = q.front() >> 24;\n\t\t\tlx = q.front() >> 16 & 0xff;\n\t\t\try = q.front() >> 8 & 0xff;\n\t\t\trx = q.front() & 0xff;\n\n\t\t\ttrymove(f1, ly, lx, dys[i], dxs[i]);\n\t\t\ttrymove(f2, ry, rx, dys[i], dxs[(i + 2) & 3]);\n\t\t\tif(visit[ly][lx][ry][rx]){ continue; }\n\t\t\tvisit[ly][lx][ry][rx] = true;\n\t\t\tint chk = (f1[ly][lx] == '%') + (f2[ry][rx] == '%');\n\t\t\tif(chk == 2){ return true; }\n\t\t\tif(chk == 0){\n\t\t\t\tq.push(ly << 24 | lx << 16 | ry << 8 | rx);\n\t\t\t}\n\t\t}\n\t\tq.pop();\n\t}\n\treturn false;\n\n}\n\nint main(){\n\twhile(scanf(\"%d%d\", &w, &h), w){\n\t\tputs(solve() ? \"Yes\" : \"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint dx[]{ 1,0,-1,0 }, dy[]{ 0,1,0,-1 };\nchar f[2][50][51];\nbool used[50][50][50][50];\nstruct st {\n\tint rx, ry, lx, ly;\n};\nint main() {\n\tint w, h;\n\twhile (scanf(\"%d%d\", &w, &h), w) {\n\t\tmemset(used, 0, sizeof(used));\n\t\tst in;\n\t\trep(i, h * 2) {\n\t\t\tscanf(\"%s\", f[i % 2][i / 2]);\n\t\t\trep(j, w) {\n\t\t\t\tif (f[i % 2][i / 2][j] == 'R')in.rx = i / 2, in.ry = j, f[i % 2][i / 2][j] = '.';\n\t\t\t\tif (f[i % 2][i / 2][j] == 'L')in.lx = i / 2, in.ly = j, f[i % 2][i / 2][j] = '.';\n\t\t\t}\n\t\t}\n\t\tqueue<st>que;\n\t\tque.push(in);\n\t\tused[in.rx][in.ry][in.lx][in.ly] = true;\n\t\twhile (!que.empty()) {\n\t\t\tst s = que.front(); que.pop();\n\t\t\tif (f[1][s.rx][s.ry] == '%'&&f[0][s.lx][s.ly] == '%') {\n\t\t\t\tputs(\"Yes\"); goto g;\n\t\t\t}\n\t\t\tif (f[1][s.rx][s.ry] == '%' || f[0][s.lx][s.ly] == '%')continue;\n\t\t\trep(i, 4) {\n\t\t\t\tint nrx = s.rx + dx[i], nry = s.ry + dy[i], nlx = s.lx + dx[i], nly = s.ly + dy[(i + 2) % 4];\n\t\t\t\tif (nrx < 0 || nrx >= h || nry < 0 || nry >= w || f[1][nrx][nry] == '#')nrx = s.rx, nry = s.ry;\n\t\t\t\tif (nlx < 0 || nlx >= h || nly < 0 || nly >= w || f[0][nlx][nly] == '#')nlx = s.lx, nly = s.ly;\n\t\t\t\tif (!used[nrx][nry][nlx][nly]) {\n\t\t\t\t\tused[nrx][nry][nlx][nly] = true;\n\t\t\t\t\tque.push({ nrx,nry,nlx,nly });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(\"No\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint w, h;\nstring l[52], r[52];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint lsx, lsy, rsx, rsy, lgx, lgy, rgx, rgy;\nbool ischecked[52][52][52][52];\n\nbool solve(int lx, int ly, int rx, int ry){\n    if(lx == lgx && ly == lgy && rx == rgx && ry == rgy) return true;\n    if((lx == lgx && ly == lgy) || (rx == rgx && ry == rgy)) return false;\n    for(int i = 0; i < 4; i++){\n        int nlx = lx + dx[i], nly = ly + dy[i];\n        int nrx = rx + dx[i], nry = ry - dy[i];\n        if((nlx < 0 || nly < 0 || nlx >= h || nly >= w) && (nrx < 0 || nry < 0 || nrx >= h || nry >= w)) continue;\n        if(nlx < 0 || nlx >= h || nly < 0 || nly >= w){\n            nlx = lx;\n            nly = ly;\n        }\n        if(nrx < 0 || nrx >= h || nry < 0 || nry >= w){\n            nrx = rx;\n            nry = ry;\n        }\n        if((l[nlx][nly] == '#' && r[nrx][nry] == '#') || ischecked[nlx][nly][nrx][nry]) continue;\n        if(l[nlx][nly] == '#'){\n            nlx = lx;\n            nly = ly;\n        }\n        if(r[nrx][nry] == '#'){\n            nrx = rx;\n            nry = ry;\n        }\n        ischecked[nlx][nly][nrx][nry] = true;\n        if(solve(nlx, nly, nrx, nry)) return true;\n        // ischecked[nlx][nly][nrx][nry] = false;\n    }\n    return false;\n}\n\nint main()\n{\n    while(1){\n        cin >> w >> h;\n        if(w == 0 && h == 0) break;\n        for(int i = 0; i < h; i++){\n            cin >> l[i] >> r[i];\n        }\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                for(int k = 0; k < h; k++){\n                    for(int l = 0; l < w; l++){\n                        ischecked[i][j][k][l] = false;\n                    }\n                }\n                if(l[i][j] == 'L'){\n                    lsx = i;\n                    lsy = j;\n                }\n                if(l[i][j] == '%'){\n                    lgx = i;\n                    lgy = j;\n                }\n                if(r[i][j] == 'R'){\n                    rsx = i;\n                    rsy = j;\n                }\n                if(r[i][j] == '%'){\n                    rgx = i;\n                    rgy = j;\n                }\n            }\n        }\n        ischecked[lsx][lsy][rsx][rsy] = true;\n        if(solve(lsx, lsy, rsx, rsy)) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nint const dxL[] = {-1,0,1,0};\nint const dxR[] = {1,0,-1,0};\nint const dy[]  = {0,-1,0,1};\ntypedef pair<int, int> Pii;\n#define X first\n#define Y second\nint const INF = 1<<28;\nint W, H;\nchar grL[51][51], grR[51][51];\nbool used[2500][2500];\ninline bool isValid(int x, int y) {\n  if(0<=x&&x<W && 0<=y&&y<H) return true;\n  return false;\n}\n\ninline bool inF(int x, int y, int isL) {\n  if(isL) return grL[y][x]!='#';\n  return grR[y][x]!='#';\n}\ninline int toNode(int x, int y) {\n  return y*W+x;\n}\ninline void toPos(int node, int &x, int &y) {\n  x = node%W, y = node/W;\n}\nint main() {\n  \n  while(cin >> W >> H && (W|H)) {\n    int sxL, syL, sxR, syR;\n    int gxL, gyL, gxR, gyR;\n    for(int i=0; i<H; i++) {\n      for(int j=0; j<2*W; j++) {\n        if(j<W) {\n          cin >> grL[i][j];\n          if(grL[i][j] == 'L') {\n            sxL = j, syL = i;\n          }\n          if(grL[i][j] == '%') {\n            gxL = j, gyL = i;\n          }\n        }\n        else {\n          cin >> grR[i][j-W];\n          if(grR[i][j-W] == 'R') {\n            sxR = j-W, syR = i;\n          }\n          if(grR[i][j-W] == '%') {\n            gxR = j-W, gyR = i;\n          }\n        }\n      }\n    }\n    \n    queue<int> qL, qR;\n    qL.push(toNode(sxL, syL)); qR.push(toNode(sxR, syR));\n    bool ok = false;\n    memset(used, false, sizeof used);\n    while(!qL.empty()) {\n      const int nowL = qL.front(); qL.pop();\n      const int nowR = qR.front(); qR.pop();\n      int lx, ly; toPos(nowL, lx, ly);\n      int rx, ry; toPos(nowR, rx, ry);\n\n      if(lx == gxL && ly == gyL && rx == gxR && ry == gyR) {\n        ok = true; break;\n      }\n      if(lx == gxL && ly == gyL) {\n        continue;\n      }\n      if(rx == gxR && ry == gyR) {\n        continue;\n      }\n      for(int i=0; i<4; i++) {\n        int nxL = lx+dxL[i], nyL = ly+dy[i];\n        int nxR = rx+dxR[i], nyR = ry+dy[i];\n\n        if((!isValid(nxL, nyL)) || (!isValid(nxR, nyR))) continue;\n\n        if((!inF(nxL, nyL, 1)) && (!inF(nxR, nyR, 0))) continue;\n        if(!inF(nxL, nyL, 1)) { nxL = lx, nyL = ly; }\n        if(!inF(nxR, nyR, 0)) { nxR = rx, nyR = ry; }\n        if(used[toNode(nxL, nyL)][toNode(nxR, nyR)]) continue;\n        qL.push(toNode(nxL, nyL));\n        qR.push(toNode(nxR, nyR));\n        used[toNode(nxL, nyL)][toNode(nxR, nyR)] = true;\n      }\n    }\n    if(ok) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// テ・ツ淞コテヲツ慊ャテ」ツδ?」ツδウテ」ツδ療」ツδャテ」ツδシテ」ツδ?\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[2][4] = { {0, 0, 1, -1}, {0, 0, 1, -1} };\nint dy[2][4] = { {1, -1, 0, 0}, {-1, 1, 0, 0} };\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nconst int S = 51;\n// ax, ay, bx, by\nint step[S][S][S][S];\nbool visited[S][S][S][S];\nint W, H;\n\nstruct Elem {\n    int ax, ay, bx, by;\n};\n\npii search_p(vector<string> &vs, char target) {\n    rep(i,0,H) rep(j,0,W) {\n        if(vs[i][j] == target) return make_pair(i, j);\n    }\n}\n\nvoid move_p(vector<string> &vs, int &x, int &y, int dir, int mode) {\n    int nx = x + dx[mode][dir];\n    int ny = y + dy[mode][dir];\n    if(nx < 0 || nx >= H || ny < 0 || ny >= W) return;\n    if(vs[nx][ny] == '#') return;\n    x = nx;\n    y = ny;\n}\n\nsigned main() {\n    while(cin >> W >> H, W || H) {\n        rep(i,0,S) rep(j,0,S) rep(k,0,S) rep(l,0,S) step[i][j][k][l] = INF;\n        memset(visited, false, sizeof(visited));\n\n        vector<string> lboard(H), rboard(H);\n        rep(i,0,H) cin >> lboard[i] >> rboard[i];\n        pii init_a = search_p(lboard, 'L');\n        pii init_b = search_p(rboard, 'R');\n        int a = init_a.first, b = init_a.second;\n        int x = init_b.first, y = init_b.second;\n        step[a][b][x][y] = 0;\n\n        queue<Elem> que;\n        que.push(Elem{a, b, x, y});\n        visited[a][b][x][y] = true;\n        while(!que.empty()) {\n            Elem cur = que.front(); que.pop();\n            rep(k,0,4) {\n                Elem nxt = cur;\n                move_p(lboard, nxt.ax, nxt.ay, k, 0);\n                move_p(rboard, nxt.bx, nxt.by, k, 1);\n                if(visited[nxt.ax][nxt.ay][nxt.bx][nxt.by]) continue;\n                if(step[nxt.ax][nxt.ay][nxt.bx][nxt.by] > step[cur.ax][cur.ay][cur.bx][cur.by] + 1) {\n                    step[nxt.ax][nxt.ay][nxt.bx][nxt.by] = step[cur.ax][cur.ay][cur.bx][cur.by] + 1;\n                    que.push(nxt);\n                }\n            }\n        }\n\n        pii goal_a = search_p(lboard, '%');\n        pii goal_b = search_p(rboard, '%');\n        a = goal_a.first, b = goal_a.second;\n        x = goal_b.first, y = goal_b.second;\n        if(step[a][b][x][y] == INF) cout << \"No\" << endl;\n        else cout << \"Yes\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <fstream>\n#include <stack>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, k, n) for (int i = (int)(k); i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rREP(i, k, n) for (int i = (int)(n)-1; i >= k; i--)\n\n#define debug(x) cerr << #x << \": \" << x << endl;\n\n#define fi first\n#define se second\n\n#define vi vector<int>\n#define pii pair<int, int>\n#define pb push_back\n#define mp make_pair\n\n#define pcnt __builtin_popcount\n\ntypedef long long ll;\n\nconst int    inf = 100100100;\nconst int    MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\nconst int    dx[4] = { 0, 1, 0, -1 };\nconst int    dy[4] = { 1, 0, -1, 0 };\n\nstruct POINT {\n    int lx;\n    int ly;\n    int rx;\n    int ry;\n};\n\nbool u[55][55][55][55] = {};\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n//    ifstream in(\"./input.txt\");\n//    cin.rdbuf(in.rdbuf());\n    int    w, h;\n    string ML[55], MR[55];\n    int slx,sly,srx,sry;\n    while (cin >> w >> h, w) {\n        memset(u,0,sizeof(u));\n        rep(y, h) cin >> ML[y] >> MR[y];\n        rep(y, h) rep(x,w){\n                if(ML[y][x] == 'L') ML[y][x] = '.',slx = x,sly = y;\n                if(MR[y][x] == 'R') ML[y][x] = '.',srx = x,sry = y;\n            }\n        stack<POINT> st;\n        st.push(POINT{slx, sly, srx, sry});\n\n        bool flag = false;\n        while (!st.empty()) {\n            POINT p = st.top();\n            st.pop();\n            if (u[p.lx][p.ly][p.rx][p.ry]) continue;\n            rep(i, 4) {\n                int nlx = p.lx + dx[i];\n                int nly = p.ly + dy[i];\n                int nrx = p.rx + dx[(i + 2) % 4];\n                int nry = p.ry + dy[i];\n                bool left_do = true;\n                bool right_do = true;\n                if (nlx < 0 || w <= nlx) left_do = false;\n                if (nly < 0 || h <= nly) left_do = false;\n                if (ML[nly][nlx] == '#') left_do = false;\n                if (nrx < 0 || w <= nrx) right_do = false;\n                if (nry < 0 || h <= nry) right_do = false;\n                if (MR[nry][nrx] == '#') right_do = false;\n                if (ML[nly][nlx] == '%' && MR[nry][nrx] == '%') {\n                    flag = true;\n                    while (!st.empty()) st.pop();\n                    break;\n                } else if (ML[nly][nlx] == '%' || MR[nry][nrx] == '%') {\n                    continue;\n                }\n                if (!left_do && !right_do) continue;\n                if (!left_do) nlx = p.lx, nly = p.ly;\n                if (!right_do) nrx = p.rx, nry = p.ry;\n                if(!u[p.lx][p.ly][p.rx][p.ry]) st.emplace(POINT{nlx, nly, nrx, nry});\n            }\n            u[p.lx][p.ly][p.rx][p.ry] = true;\n        }\n        if (flag)\n            cout << \"Yes\" << endl;\n        else\n            cout << \"No\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, k, n) for (int i = (int)(k); i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rREP(i, k, n) for (int i = (int)(n)-1; i >= k; i--)\n\n#define debug(x) cerr << #x << \": \" << x << endl;\n\n#define fi first\n#define se second\n\n#define vi vector<int>\n#define pii pair<int, int>\n#define pb push_back\n#define mp make_pair\n\n#define pcnt __builtin_popcount\n\ntypedef long long ll;\n\nconst int    inf = 100100100;\nconst int    MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\nconst int    dx[4] = { 0, 1, 0, -1 };\nconst int    dy[4] = { 1, 0, -1, 0 };\n\nstruct POINT {\n    int lx;\n    int ly;\n    int rx;\n    int ry;\n};\n\nbool u[55][55][55][55] = {};\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n//    ifstream in(\"./input.txt\");\n//    cin.rdbuf(in.rdbuf());\n    int    w, h;\n    string ML[55], MR[55];\n    int slx,sly,srx,sry;\n    while (cin >> w >> h, w) {\n        memset(u,0,sizeof(u));\n        rep(y, h) cin >> ML[y] >> MR[y];\n        rep(y,h) rep(x,w){\n            if(ML[y][x] == 'L') slx = x,sly = y;\n            if(MR[y][x] == 'R') srx = x,sry = y;\n        }\n        queue<POINT> que;\n        que.push(POINT{slx, sly, srx, sry});\n\n        bool flag = false;\n        while (!que.empty()) {\n            POINT p = que.front();\n            que.pop();\n            if (u[p.lx][p.ly][p.rx][p.ry]) continue;\n            rep(i, 4) {\n                int nlx = p.lx + dx[i];\n                int nly = p.ly + dy[i];\n                int nrx = p.rx + dx[(i + 2) % 4];\n                int nry = p.ry + dy[i];\n                bool left_do = true;\n                bool right_do = true;\n                if (nlx < 0 || w <= nlx) left_do = false;\n                if (nly < 0 || h <= nly) left_do = false;\n                if (ML[nly][nlx] == '#') left_do = false;\n                if (nrx < 0 || w <= nrx) right_do = false;\n                if (nry < 0 || h <= nry) right_do = false;\n                if (MR[nry][nrx] == '#') right_do = false;\n                if (ML[nly][nlx] == '%' && MR[nry][nrx] == '%') {\n                    flag = true;\n                    while (!que.empty()) que.pop();\n                    break;\n                } else if (ML[nly][nlx] == '%' || MR[nry][nrx] == '%') {\n                    continue;\n                }\n                if (!left_do && !right_do) continue;\n                if (!left_do) nlx = p.lx, nly = p.ly;\n                if (!right_do) nrx = p.rx, nry = p.ry;\n                if(!u[p.lx][p.ly][p.rx][p.ry]) que.push(POINT{nlx, nly, nrx, nry});\n            }\n            u[p.lx][p.ly][p.rx][p.ry] = true;\n        }\n        if (flag)\n            cout << \"Yes\" << endl;\n        else\n            cout << \"No\" << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<tuple>\n#include<string>\nusing namespace std;\n\n#define MAX_N 60\n#define INF 1<<30\n\nint dist[MAX_N][MAX_N][MAX_N][MAX_N];\nint dy1[4] = { 0,1,0,-1 };\nint dy2[4] = { 0,1,0,-1 };\nint dx1[4] = { 1,0,-1,0 };\nint dx2[4] = { -1,0,1,0 };\nint H, W, map1[MAX_N][MAX_N], map2[MAX_N][MAX_N];\nint Lsy, Lsx, Lgy, Lgx;\nint Rsy, Rsx, Rgy, Rgx;\nstring S, T;\nqueue<tuple<int, int, int, int>>Q;\n\nvoid _memset() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tfor (int k = 0; k < MAX_N; k++) {\n\t\t\t\tfor (int l = 0; l < MAX_N; l++) {\n\t\t\t\t\tdist[i][j][k][l] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tmap1[i][j] = 1;\n\t\t\tmap2[i][j] = 1;\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\t_memset();\n\t\tcin >> W >> H;\n\t\tif (H == 0 && W == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tcin >> S >> T;\n\t\t\tfor (int j = 0; j < S.size(); j++) {\n\t\t\t\tif (S[j] == '%') {\n\t\t\t\t\tLsx = j + 1; Lsy = i;\n\t\t\t\t\tmap1[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\tif (S[j] == '#') {\n\t\t\t\t\tmap1[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (S[j] == '.') {\n\t\t\t\t\tmap1[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (S[j] = 'L') {\n\t\t\t\t\tLgy = i; Lgx = j + 1;\n\t\t\t\t\tmap1[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < T.size(); j++) {\n\t\t\t\tif (T[j] == '%') {\n\t\t\t\t\tRsx = j + 1; Rsy = i;\n\t\t\t\t\tmap2[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\tif (S[j] == '#') {\n\t\t\t\t\tmap2[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (S[j] == '.') {\n\t\t\t\t\tmap2[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (S[j] = 'L') {\n\t\t\t\t\tRgy = i; Rgx = j + 1;\n\t\t\t\t\tmap2[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQ.push(make_tuple(Lsy, Lsx, Rsy, Rsx));\n\t\tdist[Lsy][Lsx][Rsy][Rsx] = 0;\n\n\t\twhile (!Q.empty()) {\n\t\t\ttuple<int, int, int, int>tup = Q.front(); Q.pop();\n\t\t\tint ay = get<0>(tup);\n\t\t\tint ax = get<1>(tup);\n\t\t\tint by = get<2>(tup);\n\t\t\tint bx = get<3>(tup);\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint ey = ay + dy1[i], ex = ax + dx1[i];\n\t\t\t\tint fy = by + dy2[i], fx = bx + dx2[i];\n\t\t\t\tif (map1[ey][ex] == 1) {\n\t\t\t\t\tey = ay; ex = ax;\n\t\t\t\t}\n\t\t\t\tif (map2[fy][fx] == 1) {\n\t\t\t\t\tfy = by; fx = bx;\n\t\t\t\t}\n\t\t\t\tif (dist[ey][ex][fy][fx] == INF) {\n\t\t\t\t\tdist[ey][ex][fy][fx] = 0;\n\t\t\t\t\tQ.push(make_tuple(ey, ex, fy, fx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[Lgy][Lgx][Rgy][Rgx] == INF) {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\nchar fieldL[51][51];\nchar fieldR[51][51];\n\nbool isArrival[51][51][51][51];\nint h,w;\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\n\nvoid bfs(int slx,int sly,int srx,int sry){\n\tqueue<pair<int,int> > *prvL=new queue<pair<int,int> >();\n\tqueue<pair<int,int> > *nxtL=new queue<pair<int,int> >();\n\tqueue<pair<int,int> > *prvR=new queue<pair<int,int> >();\n\tqueue<pair<int,int> > *nxtR=new queue<pair<int,int> >();\n\tprvL->push(make_pair(sly,slx));\n\tprvR->push(make_pair(sry,srx));\n\twhile(prvL->size()){\n\t\twhile(prvL->size()){\n\t\t\tpair<int,int> pl=prvL->front();prvL->pop();\n\t\t\tpair<int,int> pr=prvR->front();prvR->pop();\n\t\t\tint ly=pl.first;int lx=pl.second;\n\t\t\tint ry=pr.first;int rx=pr.second;\n\t\t\tif(isArrival[ly][lx][ry][rx])\n\t\t\t\tcontinue;\n\t\t\tisArrival[ly][lx][ry][rx]=true;\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint nly=max(0,min(h-1,ly+dy[i]));\n\t\t\t\tint nlx=max(0,min(w-1,lx+dx[i]));\n\t\t\t\tint nry=max(0,min(h-1,ry+dy[i]));\n\t\t\t\tint nrx=max(0,min(w-1,rx-dx[i]));\n\t\t\t\tif(fieldL[nly][nlx]=='#'){\n\t\t\t\t\tnly=ly;\n\t\t\t\t\tnlx=lx;\n\t\t\t\t}\n\t\t\t\tif(fieldL[nry][nrx]=='#'){\n\t\t\t\t\tnry=ry;\n\t\t\t\t\tnrx=rx;\n\t\t\t\t}\n\t\t\t\tif(!isArrival[nly][nlx][nry][nrx]){\n\t\t\t\t\tnxtL->push(make_pair(nly,nlx));\n\t\t\t\t\tnxtR->push(make_pair(nry,nrx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(prvL,nxtL);\n\t\tswap(prvR,nxtR);\n\t}\n\tdelete prvL,prvR,nxtL,nxtR;\n}\n\nint main(){\n\twhile(cin>>w>>h&&!(w==0&&h==0)){\n\t\tmemset(isArrival,0,sizeof(isArrival));\n\t\tint sly,slx,srx,sry;\n\t\tint fly,flx,frx,fry;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>fieldL[i][j];\n\t\t\t\tif(fieldL[i][j]=='L'){\n\t\t\t\t\tfieldL[i][j]='.';\n\t\t\t\t\tsly=i;\n\t\t\t\t\tslx=j;\n\t\t\t\t}\n\t\t\t\telse if(fieldL[i][j]=='%'){\n\t\t\t\t\tfieldL[i][j]='.';\n\t\t\t\t\tfly=i;\n\t\t\t\t\tflx=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>fieldR[i][j];\n\t\t\t\tif(fieldR[i][j]=='R'){\n\t\t\t\t\tfieldR[i][j]='.';\n\t\t\t\t\tsry=i;\n\t\t\t\t\tsrx=j;\n\t\t\t\t}\n\t\t\t\telse if(fieldR[i][j]=='%'){\n\t\t\t\t\tfieldR[i][j]='.';\n\t\t\t\t\tfry=i;\n\t\t\t\t\tfrx=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbfs(slx,sly,srx,sry);\n\t\tif(isArrival[fly][flx][fry][frx])\n\t\t\tcout<<\"Yes\"<<endl;\n\t\telse\n\t\t\tcout<<\"No\"<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <queue>\nusing namespace std;\nconst int INF = 1000000000;\nint d[50][50][50][50];\nstring f[2][50];\n\nint dx[2][4] = {\n\t{ 1, 0, -1, 0 },\n\t{ -1, 0, 1, 0 }\n};\n\nint dy[2][4] = {\n\t{ 0, 1, 0, -1 },\n\t{ 0, 1, 0, -1 }\n};\n\nint sx[2], sy[2], gx[2], gy[2];\n\n\nstruct State {\n\tint x1, y1, x2, y2;\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint H, W;\n\twhile(cin >> W >> H, H) {\n\t\tfor(int y = 0; y < H; y++) {\n\t\t\tcin >> f[0][y] >> f[1][y];\n\t\t\tfor(int x = 0; x < W; x++) {\n\t\t\t\tif(f[0][y][x] == 'L') sx[0] = x, sy[0] = y;\n\t\t\t\tif(f[1][y][x] == 'R') sx[1] = x, sy[1] = y;\n\t\t\t\tif(f[0][y][x] == '%') gx[0] = x, gy[0] = y;\n\t\t\t\tif(f[1][y][x] == '%') gx[1] = x, gy[1] = y;\n\t\t\t}\n\t\t}\n\n\t\tfill((int*)begin(d), (int*)end(d), INF);\n\n\t\tqueue<State> q;\n\t\tq.push(State{ sx[0], sy[0], sx[1], sy[1] });\n\t\td[sx[0]][sy[0]][sx[1]][sy[1]] = 0;\n\t\twhile(!q.empty()) {\n\t\t\tState s = q.front();\n\t\t\tq.pop();\n\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\tint nx1 = s.x1 + dx[0][k], ny1 = s.y1 + dy[0][k];\n\t\t\t\tif(nx1 < 0 || W <= nx1 || ny1 < 0 || H <= ny1 || f[0][ny1][nx1] == '#') {\n\t\t\t\t\tnx1 = s.x1, ny1 = s.y1;\n\t\t\t\t}\n\t\t\t\tint nx2 = s.x2 + dx[1][k], ny2 = s.y2 + dy[1][k];\n\t\t\t\tif(nx2 < 0 || W <= nx2 || ny2 < 0 || H <= ny2 || f[1][ny2][nx2] == '#') {\n\t\t\t\t\tnx2 = s.x2, ny2 = s.y2;\n\t\t\t\t}\n\t\t\t\tif((f[0][ny1][nx1] == '%') ^ (f[1][ny2][nx2] == '%')) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(d[s.x1][s.y1][s.x2][s.y2] + 1 < d[nx1][ny1][nx2][ny2]) {\n\t\t\t\t\td[nx1][ny1][nx2][ny2] = d[s.x1][s.y1][s.x2][s.y2] + 1;\n\t\t\t\t\tq.push(State{ nx1, ny1, nx2, ny2 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(d[gx[0]][gy[0]][gx[1]][gy[1]] == INF) {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "//????????????????????????\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> ver;\ntypedef pair<int, ver> piv;\nint dx[2][4] = {{1, 0, -1, 0},\n                {-1, 0, 1, 0}};\nint dy[] = {0, 1, 0, -1};\nint dp[50][50][50][50];\n\nbool range(pii p, int w, int h){\n  if(0 <= p.first  && p.first  < w &&\n     0 <= p.second && p.second < h)return true;\n  return false;\n}\nint main(int argc, char *argv[]){\n  int w, h;\n  while(cin >> w >> h, w){\n    vector<string> grid1(h), grid2(h);\n    pii s[2], g[2];\n    for (int i = 0; i < h; i++) {\n      cin >> grid1[i] >> grid2[i];\n      for (int j = 0; j < w; j++) {\n        if(grid1[i][j] == 'L')s[0].first = j, s[0].second = i;\n        if(grid1[i][j] == '%')g[0].first = j, g[0].second = i;\n        if(grid2[i][j] == 'R')s[1].first = j, s[1].second = i;\n        if(grid2[i][j] == '%')g[1].first = j, g[1].second = i;\n      }\n    }\n    for (int i = 0; i < h; i++) \n      for (int j = 0; j < w; j++) \n        for (int k = 0; k < h; k++) \n          for (int l = 0; l < w; l++) \n            dp[i][j][k][l] = 1e9;\n    \n    dp[s[0].second][s[0].first][s[1].second][s[1].first] = 0;\n    queue<piv> que;\n    que.push(piv(0, ver(s[0], s[1])));\n    while(!que.empty()){\n      pii u = que.front().second.first;\n      pii v = que.front().second.second;\n      int c = que.front().first;\n      que.pop();\n      if(u == g[0] && v == g[1])break;\n      for (int i = 0; i < 4; i++) {\n        pii a = u, b = v;\n        a.first  += dx[0][i];\n        a.second += dy[i];\n        b.first  += dx[1][i];\n        b.second += dy[i];\n        if(!range(a, w, h) || grid1[a.second][a.first] == '#')\n          a = u;\n        if(!range(b, w, h) || grid2[b.second][b.first] == '#')\n          b = v;\n        if((a != g[0] && b != g[1])){\n          if(a == g[0] || b == g[1])continue;\n        }\n        if(dp[a.second][a.first][b.second][b.first] > c + 1){\n          dp[a.second][a.first][b.second][b.first] = c + 1;\n          que.push(piv(c + 1, ver(a, b)));\n        }\n      }\n    }\n\n    if(dp[g[0].second][g[0].first][g[1].second][g[1].first]\n       != 1e9)\n      std::cout << \"Yes\" << std::endl;\n    else\n      std::cout << \"No\" << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\nusing namespace std;\n\nstruct Data{int x[2],y[2];};\nData start,goal;\n\nint W,H;\nvector< vector<string> >room(2);\n\nint dx[2][4]={{0,1,0,-1}, {0,-1,0,1}};\nint dy[2][4]={{-1,0,1,0}, {-1,0,1,0}};\n\nbool operator<(Data a, Data b){\n  return a.x[0]!=b.x[0]?a.x[0]<b.x[0]:(a.y[0]!=b.y[0]?a.y[0]<b.y[0]:(\n           a.x[1]!=b.x[1]?a.x[1]<b.x[1]:a.y[1]<b.y[1]\n         ));\n}\nbool operator==(Data a, Data b){\n  return a.x[0]==b.x[0] && a.x[1]==b.x[1] && a.y[0]==b.y[0] && a.y[1]==b.y[1];\n}\nbool over(Data a){\n  return a.x[0]<0 || W<=a.x[0] || a.y[0]<0 || H<=a.y[0] ||\n         a.x[1]<0 || W<=a.x[1] || a.y[1]<0 || H<=a.y[1];\n}\n\nbool bfs()\n{\n  queue<Data>q;\n  q.push(start);\n  map<Data,bool>visited;\n\n  while(!q.empty()){\n    Data now=q.front();\n    q.pop();\n\n    visited[now]=true;\n\n    if(now==goal)return true;\n    if(now.x[0]==goal.x[0] && now.y[0]==goal.y[0])continue;\n    if(now.x[1]==goal.x[1] && now.y[1]==goal.y[1])continue;\n\n    for(int i=0;i<4;i++){\n      Data next=now;\n      for(int j=0;j<2;j++){\n\tnext.x[j]+=dx[j][i];\n\tnext.y[j]+=dy[j][i];\n\tif(over(next)){\n\t  next.x[j]=now.x[j];\n\t  next.y[j]=now.y[j];\n\t}\n\tif(room[j][next.y[j]][next.x[j]]=='#'){\n\t  next.x[j]=now.x[j];\n\t  next.y[j]=now.y[j];\n\t}\n      }\n      if(visited.count(next))continue;\n      q.push(next);\n    }\n  }\n\n  return false;\n}\n\nint main()\n{\n  while(cin>>W>>H,W|H){\n    room[0].resize(H);\n    room[1].resize(H);\n    for(int i=0;i<H;i++){\n      cin>>room[0][i]>>room[1][i];\n      for(int j=0;j<W;j++){\n\tif(room[0][i][j]=='L'){\n\t  start.x[0]=j;\n\t  start.y[0]=i;\n\t}\n\tif(room[1][i][j]=='R'){\n\t  start.x[1]=j;\n\t  start.y[1]=i;\n\t}\n\tif(room[0][i][j]=='%'){\n\t  goal.x[0]=j;\n\t  goal.y[0]=i;\n\t}\n\tif(room[1][i][j]=='%'){\n\t  goal.x[1]=j;\n\t  goal.y[1]=i;\n\t}\n      }\n    }\n\n    puts(bfs()?\"Yes\":\"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<utility>\n#include<queue>\nusing namespace std;\ntypedef struct P{int rh,rw,lh,lw,d;}P;\nstruct Order{bool operator ()(P const&a, P const&b) const{return a.d>b.d;}};\n\nint W,H,i,j,rh,rw,lh,lw,f;\nint rm[4][2]={{0,1},{0,-1},{1,0},{-1,0}};\nint lm[4][2]={{0,-1},{0,1},{1,0},{-1,0}};\nbool dp[55][55][55][55];\nchar M[110][110]={0},t;\n\nint main()\n{\n\tfor(;scanf(\"%d%d\\n\",&W,&H),W;)\n\t{\n\t\tmemset(M,0,sizeof(M));\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(i=1;i<=H;i++)\n\t\t\tfor(j=1;j<=2*W+2;j++)\n\t\t\t{\n\t\t\t\tt=getchar();\n\t\t\t\tif(t=='R'){rh=i;rw=j;t='.';}\n\t\t\t\tif(t=='L'){lh=i;lw=j;t='.';}\n\t\t\t\tM[i][j]=t;\n\t\t\t}\n\t\tpriority_queue<P,vector<P>,Order>Q;\n\t\tP p={rh,rw,lh,lw,0};\n\t\tQ.push(p);\n\t\tfor(f=0;!Q.empty();)\n\t\t{\n\t\t\tp=Q.top();Q.pop();\n\t\t\tif(M[p.rh][p.rw]=='%'&&M[p.lh][p.lw]=='%'){f=1;break;}\n\t\t\tif(M[p.rh][p.rw]=='%'||M[p.lh][p.lw]=='%'||p.d==105)continue;\n\t\t\tfor(i=0;i<4;i++)\n\t\t\t{\n\t\t\t\tP ins={p.rh,p.rw,p.lh,p.lw,p.d+1};\n\t\t\t\tif(M[p.rh+rm[i][0]][p.rw+rm[i][1]]=='.'||M[p.rh+rm[i][0]][p.rw+rm[i][1]]=='%'){ins.rh+=rm[i][0];ins.rw+=rm[i][1];}\n\t\t\t\tif(M[p.lh+lm[i][0]][p.lw+lm[i][1]]=='.'||M[p.lh+lm[i][0]][p.lw+lm[i][1]]=='%'){ins.lh+=lm[i][0];ins.lw+=lm[i][1];}\n\t\t\t\tif(!dp[ins.rh][ins.rw][ins.lh][ins.lw-W-1])\n\t\t\t\t{\n\t\t\t\t\tdp[ins.rh][ins.rw][ins.lh][ins.lw-W-1]=1;\n\t\t\t\t\tQ.push(ins);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(f?\"YES\":\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <set>\n#include <queue>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint range(int a,int b,int h, int w){\n\treturn a >= 0 && a < h && b >= 0 && b < w;\n}\n\nint main(void){\n\tint h, w, i, j, a, b, c, d, dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\n\tchar rf[50][51], lf[50][51];\n\tP rs, ls, rg, lg;\n\tqueue<pair<P,P> >que;\n\tset<pair<P,P> > s;\n\twhile(1){\n\t\tscanf(\"%d%d%*c\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tlf[i][j] = getchar();\n\t\t\t\tif(lf[i][j] == 'L'){\n\t\t\t\t\tls = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(lf[i][j] == '%'){\n\t\t\t\t\tlg = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 空白読み飛ばし\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\trf[i][j] = getchar();\n\t\t\t\tif(rf[i][j] == 'R'){\n\t\t\t\t\trs = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(rf[i][j] == '%'){\n\t\t\t\t\trg = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 改行文字読み飛ばし\n\t\t}\n\t\tque.push(pair<P,P>(ls,rs));\n\t\ts.insert(pair<P,P>(ls,rs));\n\t\twhile(que.size()){\n\t\t\ta = que.front().first.first, b = que.front().first.second, c = que.front().second.first, d = que.front().second.second;\n\t\t\tque.pop();\n\t\t\tif(a == lg.first && b == lg.second && c == rg.first && d == rg.second)\n\t\t\t\tbreak;\n\t\t\tif(a == lg.first && b == lg.second || c == rg.first && d == rg.second)\n\t\t\t\tcontinue;\n\t\t\tfor(i = 0;i < 4;i++){\n\t\t\t\tif(range(a + dy[i],b + dx[i],h,w) && range(c + dy[i],d - dx[i],h,w)){ // 両方とも動くとき\n\t\t\t\t\tif(lf[a + dy[i]][b + dx[i]] == '.'  && rf[c + dy[i]][d - dx[i]] == '.' && s.find(pair<P,P>(P(a + dy[i],b + dx[i]),P(c + dy[i],d - dx[i]))) == s.end()){\n\t\t\t\t\t\tque.push(pair<P,P>(P(a + dy[i],b + dx[i]),P(c + dy[i],d - dx[i])));\n\t\t\t\t\t\ts.insert(pair<P,P>(P(a + dy[i],b + dx[i]),P(c + dy[i],d - dx[i])));\n\t\t\t\t\t}\n\t\t\t\t\telse if(lf[a + dy[i]][b + dx[i]] == '#' && rf[c + dy[i]][d - dx[i]] == '.' && s.find(pair<P,P>(P(a,b),P(c + dy[i],d - dx[i]))) == s.end()){// Rinだけ動く\n\t\t\t\t\t\tque.push(pair<P,P>(P(a,b),P(c + dy[i],d - dx[i])));\n\t\t\t\t\t\ts.insert(pair<P,P>(P(a,b),P(c + dy[i],d - dx[i])));\n\t\t\t\t\t}\n\t\t\t\t\telse if(lf[a + dy[i]][b + dx[i]] == '.' && rf[c + dy[i]][d - dx[i]] == '#' && s.find(pair<P,P>(P(a + dy[i],b + dx[i]),P(c,d))) == s.end()){ // Lenだけ動く\n\t\t\t\t\t\tque.push(pair<P,P>(P(a + dy[i],b + dx[i]),P(c,d)));\n\t\t\t\t\t\ts.insert(pair<P,P>(P(a + dy[i],b + dx[i]),P(c,d)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(que.size())\n\t\t\tque.pop();\n\t\tif(s.find(pair<P,P>(P(lg.first,lg.second),P(rg.first,rg.second))) != s.end())\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t\ts.erase(s.begin(),s.end());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nint w, h;\nbool vis[64][64][64][64];\npii ls, lg, rs, rg;\nconst int dx[]={0, 0, 1, -1}, dy[]={1, -1, 0, 0};\n\ninline bool border(pii p){\n\treturn 0<=p.first&&p.first<w&&0<=p.second&&p.second<h;\n}\n\nstring solve(vector<string> left, vector<string> right){\n\t\n\tqueue<pii> lqu, rqu;\n\tlqu.push(ls);\n\trqu.push(rs);\n\t\n\tmemset(vis, 0, sizeof(vis));\n\tvis[ls.first][ls.second][rs.first][rs.second] = true;\n\t\n\twhile(!lqu.empty()&&!rqu.empty()){\n\t\n\t\tpii lnx, rnx, lnw, rnw;\n\t\t\n\t\tlnw = lqu.front();\n\t\trnw = rqu.front();\n\t\t\n\t\tlqu.pop();\n\t\trqu.pop();\n\t\t\n\t\tfor(int i=0; i<4; ++i){\n\t\t\t\n\t\t\tlnx = make_pair(lnw.first + dx[i], lnw.second + dy[i]);\n\t\t\trnx = make_pair(rnw.first - dx[i], rnw.second + dy[i]);\n\t\t\t\n\t\t\tif(!border(lnx)||left[lnx.second][lnx.first]=='#')\n\t\t\t\tlnx = lnw;\n\t\t\t\n\t\t\tif(!border(rnx)||right[rnx.second][rnx.first]=='#')\n\t\t\t\trnx = rnw;\n\t\t\t\n\t\t\tif(lnx == lg && rnx == rg)\n\t\t\t\treturn \"Yes\";\n\t\t\t\n\t\t\tif(!vis[lnx.first][lnx.second][rnx.first][rnx.second]){\n\t\t\t\t\n\t\t\t\tvis[lnx.first][lnx.second][rnx.first][rnx.second] = true;\n\t\t\t\tlqu.push(lnx);\n\t\t\t\trqu.push(rnx);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn \"No\";\n}\n\nint main(){\n\t\n\twhile(cin>>w>>h, (w||h)){\n\t\t\n\t\tvector<string> left, right;\n\t\t\n\t\tfor(int i=0; i<h; ++i){\n\t\t\t\n\t\t\tstring l, r;\n\t\t\tcin >> l >> r;\n\t\t\t\n\t\t\tleft.push_back(l);\n\t\t\tright.push_back(r);\n\t\t}\n\t\t\n\t\tfor(int y=0; y<h; ++y){\n\t\t\tfor(int x=0; x<w; ++x){\n\t\t\t\n\t\t\t\tif(left[y][x] == 'L')\n\t\t\t\t\tls = make_pair(x, y);\n\t\t\t\tif(right[y][x] == 'R')\n\t\t\t\t\trs = make_pair(x, y);\n\t\t\t\tif(left[y][x] == '%')\n\t\t\t\t\tlg = make_pair(x, y);\n\t\t\t\tif(right[y][x] == '%')\n\t\t\t\t\trg = make_pair(x, y);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout <<\tsolve(left, right) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <set>\n#include <queue>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\tint dl[50][50][50][50], h, w, i, j, a, b, c, d, dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\n\tchar rf[50][51], lf[50][51];\n\tP rs, ls, rg, lg;\n\tqueue<P> r, l;\n\twhile(1){\n\t\tscanf(\"%d%d%*c\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tlf[i][j] = getchar();\n\t\t\t\tif(lf[i][j] == 'L'){\n\t\t\t\t\tls = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(lf[i][j] == '%'){\n\t\t\t\t\tlg = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 空白読み飛ばし\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\trf[i][j] = getchar();\n\t\t\t\tif(rf[i][j] == 'R'){\n\t\t\t\t\trs = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(rf[i][j] == '%'){\n\t\t\t\t\trg = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 改行文字読み飛ばし\n\t\t}\n\t\tmemset(dl,0,sizeof(dl));\n\t\tr.push(rs), l.push(ls);\n\t\tdl[ls.first][ls.second][rs.first][rs.second] = 1;\n\t\twhile(r.size()){\n\t\t\ta = l.front().first, b = l.front().second, c = r.front().first, d = r.front().second;\n\t\t\tl.pop(), r.pop();\n\t\t\tif(a == lg.first && b == lg.second && c == rg.first && d == rg.second)\n\t\t\t\tbreak;\n\t\t\tif(a == lg.first && b == lg.second || c == rg.first && d == rg.second)\n\t\t\t\tcontinue;\n\t\t\tfor(i = 0;i < 4;i++){\n\t\t\t\tif(a + dy[i] >= 0 && a + dy[i] < h && b + dx[i] >= 0 && b + dx[i] < w && lf[a + dy[i]][b + dx[i]] == '.' && c + dy[i] >= 0 && c + dy[i] < h && d - dx[i] >= 0 && d - dx[i] < w && rf[c + dy[i]][d - dx[i]] == '.' && !dl[a + dy[i]][b + dx[i]][c + dy[i]][d - dx[i]]){ // 両方とも動くとき\n\t\t\t\t\tl.push(P(a + dy[i],b + dx[i])), r.push(P(c + dy[i],d - dx[i]));\n\t\t\t\t\tdl[a + dy[i]][b + dx[i]][c + dy[i]][d - dx[i]] = 1;\n\t\t\t\t}\n\t\t\t\telse if(a + dy[i] >= 0 && a + dy[i] < h && b + dx[i] >= 0 && b + dx[i] < w && lf[a + dy[i]][b + dx[i]] == '#' && c + dy[i] >= 0 && c + dy[i] < h && d - dx[i] >= 0 && d - dx[i] < w && rf[c + dy[i]][d - dx[i]] == '.' && !dl[a][b][c + dy[i]][d - dx[i]]){// Rinだけ動く\n\t\t\t\t\tl.push(P(a,b)), r.push(P(c + dy[i],d - dx[i]));\n\t\t\t\t\tdl[a][b][c + dy[i]][d - dx[i]] = 1;\n\t\t\t\t}\n\t\t\t\telse if(a + dy[i] >= 0 && a + dy[i] < h && b + dx[i] >= 0 && b + dx[i] < w && lf[a + dy[i]][b + dx[i]] == '.' && c + dy[i] >= 0 && c + dy[i] < h && d - dx[i] >= 0 && d - dx[i] < w && rf[c + dy[i]][d - dx[i]] == '#' && !dl[a + dy[i]][b + dx[i]][c][d]){ // Lenだけ動く\n\t\t\t\t\tl.push(P(a + dy[i],b + dx[i])), r.push(P(c,d));\n\t\t\t\t\tdl[a + dy[i]][b + dx[i]][c][d] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(r.size())\n\t\t\tr.pop(),l.pop();\n\t\tif(dl[lg.first][lg.second][rg.first][rg.second])\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*** ???????????? ***/\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, a, n) for(int i=a; i<n; i++)\n\nstruct State{\n\tint xL, yL, xR, yR;\n};\n\nint main(){\n\tint w, h;\n\t\n\tint dx[4]={0, 1, 0, -1}; // ????????????\n\tint dy[4]={-1, 0, 1, 0};\n\t\n\twhile(cin>>w>>h, w||h){\n\t\tState st;\n\t\tchar Len[51][51];\n\t\tchar Rin[51][51];\n\t\tbool hist[51][51][51][51]={false};\n\t\t\n\t\tREP(i, 0, h){\n\t\t\tREP(j, 0, w){\n\t\t\t\tcin >> Len[i][j];\n\t\t\t\tif(Len[i][j]=='L'){\n\t\t\t\t\tst.yL=i;\n\t\t\t\t\tst.xL=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(j, 0, w){\n\t\t\t\tcin >> Rin[i][j];\n\t\t\t\tif(Rin[i][j]=='R'){\n\t\t\t\t\tst.yR=i;\n\t\t\t\t\tst.xR=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<State> qu;\n\t\tqu.push(st);\n\t\thist[st.yL][st.xL][st.yR][st.xR]=true;\n\t\tbool flag=false;\n\t\t\n\t\twhile(!qu.empty()){\n\t\t\t//pair<int, int> q=qu.front();\n\t\t\tState q=qu.front();\n\t\t\tqu.pop();\n\t\t\t\n\t\t\tint yl=q.yL, xl=q.xL, yr=q.yR, xr=q.xR;\n\t\t\tif(Lin[yl][xl]=='%' && Ren[yr][xr]=='%'){\n\t\t\t\tflag=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int k=0; k<4; ++k){\n\t\t\t\tint yyl=yl+dy[k], xxl=xl+dx[k];\n\t\t\t\tint yyr=yyl, xxr=xxl;\n\t\t\t\tif(k%2==1){\n\t\t\t\t\tyyr=yr+dy[k]*(-1);\n\t\t\t\t\txxr=xr+dx[k]*(-1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(yyl<0 || yyl>=h || xxl<0 || xxl>=w || Lin[yyl][xxl]=='#'){\n\t\t\t\t\tyyl=yl;\n\t\t\t\t\txxl=xl;\n\t\t\t\t}\n\t\t\t\tif(yyr<0 || yyr>=h || xxr<0 || xxr>=w || Ren[yyr][xxr]=='#'){\n\t\t\t\t\tyyr=yr;\n\t\t\t\t\txxr=xr;\n\t\t\t\t}\n\t\t\t\tif(hist[yyl][xxl][yyr][xxr]) continue;\n\t\t\t\thist[yyl][xxl][yyr][xxr]=true;\n\t\t\t\tqu.push({yyl, xxl, yyr, xxr});\n\t\t\t}\n\t\t}\n\t\tif(flag) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n#define int long long int\nconst int INF = 1001001001001001LL;\nconst int MOD = 1000000007;\n\nint used[60][60][60][60] = {};\n\nint di[4] = {-1, 0, 1, 0};\nint dj[4] = {0, 1, 0, -1};\n\nsigned main(){\n    \n    while(1){\n       \n        int h, w; cin >> w >> h;\n        if(h == 0) break;\n        \n\n        memset(used, 0, sizeof(used));    \n        vector<vector<int> > L(h + 2, vector<int> (w + 2, 0));\n        vector<vector<int> > R(h + 2, vector<int> (w + 2, 0));\n        \n        int sli, slj, gli, glj, sri, srj, gri, grj;\n\n        for(int i = 1; i <= h; i++){\n            for(int j = 1; j <= w; j++){\n                char c; cin >> c;\n                if(c == '#') continue;\n                L[i][j] = 1;\n                if(c == 'L'){\n                    sli = i;\n                    slj = j;\n                }\n\n                if(c == '%'){\n                    gli = i;\n                    glj = j;\n                }\n            }\n\n            for(int j = 1; j <= w; j++){\n                char c; cin >> c;\n                if(c == '#') continue;\n                R[i][j] = 1;\n                if(c == 'R'){\n                    sri = i;\n                    srj = j;\n                }\n                \n                if(c == '%'){\n                    gri = i;\n                    grj = j;\n                }\n            }\n        }\n        \n        queue<pair<int, pair<pair<int, int>, pair<int, int> > > > q;\n        q.push({0, {{sli, slj}, {sri, srj}}});\n        used[sli][slj][sri][srj] = 1;\n\n        bool flag = false;\n\n        while(!q.empty()){\n            int li = q.front().second.first.first;\n            int lj = q.front().second.first.second;\n            int ri = q.front().second.second.first;\n            int rj = q.front().second.second.second;\n            int cost = q.front().first;\n\n            q.pop();\n            bool f1 = (li == gli && lj == glj);\n            bool f2 = (ri == gri && rj == grj);\n\n            \n\n            if(f1 && f2){\n                flag = true;\n                break;\n            }else if(f1 || f2) continue;\n\n            \n            for(int h = 0; h < 4; h++){\n                int nli = li + di[h];\n                int nlj = lj + dj[h];\n                int nri = ri + di[h];\n                int nrj = rj - dj[h];\n                if(!L[nli][nlj]){\n                    nli = li;\n                    nlj = lj;\n                }\n                if(!R[nri][nrj]){\n                    nri = ri;\n                    nrj = rj;\n                }\n\n                if(!used[nli][nlj][nri][nrj]){\n                    used[nli][nlj][nri][nrj] = 1;\n                    q.push({cost + 1, {{nli, nlj}, {nri, nrj}}});\n                }\n            }\n        }\n\n        if(flag) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<algorithm>\n\n#define fs first\n#define sc second\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint main(){\n  int w,h;\n  string room[2][50];\n  int ry,rx,ly,lx;\n\n  while(cin >> w >> h && (w||h)){\n    int ay[2],ax[2];\n\n    for(int i=0;i<h;i++){\n      for(int k=0;k<2;k++){\n\tcin >> room[k][i];\n\tfor(int j=0;j<w;j++){\n\t  if(room[k][i][j] == 'L'){\n\t    ly = i; lx = j;\n\t    room[k][i][j] == '.';\n\t  }\n\t  if(room[k][i][j] == 'R'){\n\t    ry = i; rx = j;\n\t    room[k][i][j] = '.';\n\t  }\n\t  if(room[k][i][j] == '%'){\n\t    ay[k] = i; ax[k] = j;\n\t  }\n\t}\n      }\n    }\n\n    bool visit[50][50][50][50];\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tfor(int k=0;k<h;k++)\n\t  for(int l=0;l<w;l++)visit[i][j][k][l] = false;\n\n    visit[ly][lx][ry][rx] = true;\n    queue<P2> q;\n    q.push(P2(P(ly,lx),P(ry,rx)));\n\n    while(q.size()){\n      P2 p = q.front();q.pop();\n      ly = p.fs.fs; lx = p.fs.sc; ry = p.sc.fs; rx = p.sc.sc;\n\n      if(room[0][ly][lx] == '%' && room[1][ry][rx] == '%')break;\n\n      int ldy[] = {-1,0,1,0}, ldx[] = {0,-1,0,1};\n      int rdy[] = {-1,0,1,0}, rdx[] = {0,1,0,-1};\n\n      for(int i=0;i<4;i++){\n\tint lsy = ly + ldy[i], lsx = lx + ldx[i];\n\tint rsy = ry + rdy[i], rsx = rx + rdx[i];\n\tif(lsy < 0 || h-1 < lsy)lsy = ly;\n\tif(lsx < 0 || w-1 < lsx)lsx = lx;\n\tif(room[0][lsy][lsx] == '#'){\n\t  lsy = ly;\n\t  lsx = lx;\n\t}\n\tif(rsy < 0 || h-1 < rsy)rsy = ry;\n\tif(rsx < 0 || w-1 < rsx)rsx = rx;\n\tif(room[1][rsy][rsx] == '#'){\n\t  rsy = ry;\n\t  rsx = rx;\n\t}\n\n\tif( (room[0][lsy][lsx] == '%') != (room[1][rsy][rsx] == '%') )continue;\n\tif(visit[lsy][lsx][rsy][rsx])continue;\n\tvisit[lsy][lsx][rsy][rsx] = true;\n\n\tq.push(P2(P(lsy,lsx),P(rsy,rsx)));\n      }\n    }\n\n    if(visit[ay[0]][ax[0]][ay[1]][ax[1]])cout << \"Yes\\n\";\n    else cout << \"No\\n\";\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\nint main() {\n\tfor (;;) {\n\t\tint W, H; cin >> W >> H;\n\t\tif (W == 0 && H == 0) break;\n\t\tvector< vector<string> > a(2, vector<string>(H + 2, string(W + 2, '#')));\n\t\tfor (int y = 1; y <= H; y++) {\n\t\t\tstring s1, s2; cin >> s1 >> s2;\n\t\t\ta[0][y] = '#' + s1 + '#';\n\t\t\ta[1][y] = '#' + s2 + '#';\n\t\t}\n\t\tvector<int> xs(2), ys(2), xt(2), yt(2);\n\t\tfor (int k = 0; k < 2; k++)\n\t\t\tfor (int y = 1; y <= H; y++)\n\t\t\t\tfor (int x = 1; x <= W; x++){\n\t\t\t\t\tchar& c = a[k][y][x];\n\t\t\t\t\tif (c == 'L' || c == 'R') {\n\t\t\t\t\t\tc = '.';\n\t\t\t\t\t\txs[k] = x; ys[k] = y;\n\t\t\t\t\t}\n\t\t\t\t\telse if (c == '%') {\n\t\t\t\t\t\tc = '.';\n\t\t\t\t\t\txt[k] = x; yt[k] = y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tvector< vector<bool> > vis(3000, vector<bool>(3000));\n\t\tstack< vector<int> > stx, sty;\n\t\tstx.push(xs); sty.push(ys);\n\t\twhile (!stx.empty()) {\n\t\t\tvector<int> x = stx.top(); stx.pop();\n\t\t\tvector<int> y = sty.top(); sty.pop();\n\t\t\tvector<int> z(2);\n\t\t\tfor (int k = 0; k < 2; k++)\n\t\t\t\tz[k] = y[k] * W + x[k];\n\t\t\tvis[z[0]][z[1]] = true;\n\t\t\tif (x[0] == xt[0] && y[0] == yt[0]) continue;\n\t\t\tif (x[1] == xt[1] && y[1] == yt[1]) continue;\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tvector<int> _x = x, _y = y, _z(2);\n\t\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\t\t_x[k] += (k ? dx[i] : -dx[i]);\n\t\t\t\t\t_y[k] += dy[i];\n\t\t\t\t\tif (a[k][_y[k]][_x[k]] == '#') {\n\t\t\t\t\t\t_x[k] = x[k]; _y[k] = y[k];\n\t\t\t\t\t}\n\t\t\t\t\t_z[k] = _y[k] * W + _x[k];\n\t\t\t\t}\n\t\t\t\tif (!vis[_z[0]][_z[1]]) {\n\t\t\t\t\tvis[_z[0]][_z[1]] = true;\n\t\t\t\t\tstx.push(_x);\n\t\t\t\t\tsty.push(_y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> zt(2);\n\t\tfor (int k = 0; k < 2; k++)\n\t\t\tzt[k] = yt[k] * W + xt[k];\n\t\tcout << (vis[zt[0]][zt[1]] ? \"Yes\" : \"No\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nint w,h;\npair<int,int> sa,sb,ga,gb;\nchar mapA[52][52], mapB[52][52];\nbool memo[52][52][52][52];\n\nint dxa[] = {0,0,1,-1};\nint dxb[] = {0,0,-1,1};\nint dya[] = {1,-1,0,0};\nint dyb[] = {1,-1,0,0};\n\nbool solve(pair<int,int> posA, pair<int,int> posB){\n\tqueue< pair< pair<int,int>, pair<int,int> > > q;\n\tq.push(pair< pair<int,int>, pair<int,int> >(posA,posB));\n\t\n\twhile(!q.empty()){\n\t\tposA = q.front().first;\n\t\tposB = q.front().second;\n\t\tq.pop();\n\n\t\tfor(int i=0;i<4;i++){\n\t\t\tpair<int,int> na = pair<int,int>(posA.first+dxa[i], posA.second+dya[i]);\n\t\t\tpair<int,int> nb = pair<int,int>(posB.first+dxb[i], posB.second+dyb[i]);\n\t\t\t\n\t\t\tif(na.first<0 || na.first>=w || na.second<0 || na.second>=h || mapA[na.second][na.first]=='#') na = posA;\n\t\t\tif(nb.first<0 || nb.first>=w || nb.second<0 || nb.second>=h || mapB[nb.second][nb.first]=='#') nb = posB;\n\n\t\t\tif(na == ga && nb == gb) return true;\n\t\t\tif(na == ga || nb == gb) continue;\n\t\t\tif(memo[na.first][na.second][nb.first][nb.second]) continue;\n\n\t\t\tq.push(pair< pair<int,int>, pair<int,int> >(na,nb));\n\t\t\tmemo[na.first][na.second][nb.first][nb.second] = true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(void){\n\twhile(cin>>w>>h && (w||h)){\n\t\tmemset(memo,0,sizeof(memo));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>mapA[i]>>mapB[i];\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(mapA[i][j] == 'L'){\n\t\t\t\t\tsa = pair<int,int>(j,i);\n\t\t\t\t}\n\t\t\t\telse if(mapA[i][j] == '%'){\n\t\t\t\t\tga = pair<int,int>(j,i);\n\t\t\t\t}\n\t\t\t\tif(mapB[i][j] == 'R'){\n\t\t\t\t\tsb = pair<int,int>(j,i);\n\t\t\t\t}\n\t\t\t\telse if(mapB[i][j] == '%'){\n\t\t\t\t\tgb = pair<int,int>(j,i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(solve(sa,sb)) cout<<\"Yes\\n\";\n\t\telse cout<<\"No\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <fstream>\n \nusing namespace std;\n \n#define INF 100000000\n#define EPS 1e-9\n#define PI acos(-1)\n \ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define MAX_W 50\n#define MAX_H 50\n\nint W, H;\nstring L[MAX_H], R[MAX_H];\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nint dp[MAX_H][MAX_W][MAX_H][MAX_W];\n\nvector<string> ans_list;\n\n\n\nint main(){\n  \n  while(true){\n    \n    cin >> W >> H;\n    if(W == 0)\n      break;\n    \n    int lsx, lsy, rsx, rsy, lgx, lgy, rgx, rgy;\n    \n    for(int i = 0; i < H; i++){\n      cin >> L[i] >> R[i];\n      for(int j = 0; j < W; j++){\n\tif(L[i][j] =='L'){\n\t  lsx = j;\n\t  lsy = i;\n\t}\n\tif(R[i][j] == 'R'){\n\t  rsx = j;\n\t  rsy = i;\n\t}\n\tif(L[i][j] == '%'){\n\t  lgx = j;\n\t  lgy = i;\n\t}\n\tif(R[i][j] == '%'){\n\t  rgx = j;\n\t  rgy = i;\n\t}\n      }\n      \n    }\n    \n\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n\tfor(int k = 0; k < H; k++){\n\t  for(int l = 0; l < W; l++){\n\t    dp[i][j][k][l] = INF;\n\t  }\n\t}\n      }\n    }\n\n    dp[lsy][lsx][rsy][rsx] = 0;\n    \n    queue<P> que1, que2;\n    que1.push(P(lsx, lsy));\n    que2.push(P(rsx, rsy));\n    \n    bool flag = false;\n\n    while(que1.size()){\n      P p1 = que1.front();\n      P p2 = que2.front();\n      que1.pop();\n      que2.pop();\n      int lx = p1.first;\n      int ly = p1.second;\n      int rx = p2.first;\n      int ry = p2.second;\n      \n      if(lx == lgx && ly == lgy && rx == rgx && ry == rgy){\n\tflag = true;\n\tbreak;\n      }\n      \n      for(int i = 0; i < 4; i++){\n\tint lnx = lx + dx[i];\n\tint lny = ly + dy[i];\n\tint rnx = rx + dx[(i+2)%4];\n\tint rny = ry + dy[i];\n\n\tif(lnx == -1 || lnx == W || lny == -1 || lny == H){\n\t  lnx = lx;\n\t  lny = ly;\n\t}\n\tif(L[lny][lnx] == '#'){\n\t  lnx = lx;\n\t  lny = ly;\n\t}\n\n\tif(rnx == -1 || rnx == W || rny == -1 || rny == H){\n\t  rnx = rx;\n\t  rny = ry;\n\t}\n\tif(R[rny][rnx] == '#'){\n\t  rnx = rx;\n\t  rny = ry;\n\t}\n\n\tif((lnx == lgx && lny == lgy) || (rnx == rgx && rny == rgy)){\n\t  if(!(lnx == lgx && lny == lgy && rnx == rgx && rny == rgy)){\n\t    continue;\n\t  }\n\t}\n\t  \n\n\tif(dp[lny][lnx][rny][rnx] == INF){\n\t  // printf(\"%d:%d %d:%d -> %d:%d %d:%d\\n\", lx,ly,rx,ry,lnx, lny, rnx, rny);\n\t  dp[lny][lnx][rny][rnx] = dp[ly][lx][ry][rx] + 1;\n\t  que1.push(P(lnx, lny));\n\t  que2.push(P(rnx, rny));\n\t}\n\t\n      }\n\n    }\n    \n    if(flag){\n      ans_list.push_back(\"Yes\");\n    }\n    else{\n      ans_list.push_back(\"No\");\n    }\n    \n    \n\n  }\n  \n  for(int i = 0; i < ans_list.size(); i++){\n    cout << ans_list[i] << endl;\n  }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint room[2][100*100];\nint start[2], goal[2];\nint dz[] = {-1,1,-100,100};\nint dz_[] = {1,-1,-100,100};\n\nint toz(int x, int y){\n  return x + y * 100;\n}\nint ptoz(int z0, int z1){\n  return z0 + z1*3000;\n}\n\nbool search(){\n  vector<bool> visited(3000*3000, false);\n  queue<PII> q;\n  q.push(MP(start[0], start[1]));\n  visited[ptoz(start[0],start[1])] = true;\n\n  while(!q.empty()){\n\tPII now = q.front(); q.pop();\n\tREP(i,4){\n\t  int z0 = now.first + dz[i];\n\t  int z1 = now.second + dz_[i];\n\t  if(!room[0][z0])\n\t\tz0 -= dz[i];\n\t  if(!room[1][z1])\n\t\tz1 -= dz_[i];\n\n\t  if(z0 == goal[0]){\n\t\tif(z1 == goal[1])\n\t\t  return true;\n\t\telse continue;\n\t  }\n\t  if(z1 == goal[1])\n\t\tcontinue;\n\n\t  if(!visited[ptoz(z0,z1)]){\n\t\tvisited[ptoz(z0,z1)] = true;\n\t\tq.push(MP(z0,z1));\n\t  }\n\t}\n  }\n\n  return false;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int W, H;\n  while(cin>>W>>H, W){\n\tfill((int*)room, (int*)room+2*100*100, 0);\n\tREP(y,H){\n\t  REP(i,2){\n\t\tstring t; cin >> t;\n\t\tREP(x,W){\n\t\t  int st = 0;\n\t\t  switch(t[x]){\n\t\t  case 'R':\n\t\t  case 'L':\n\t\t\tst = 1;\n\t\t\tstart[i] = toz(x+1,y+1);\n\t\t\tbreak;\n\t\t  case '%':\n\t\t\tst = 1;\n\t\t\tgoal[i] = toz(x+1,y+1);\n\t\t\tbreak;\n\t\t  case '.':\n\t\t\tst = 1;\n\t\t\tbreak;\n\t\t  }\n\t\t  room[i][toz(x+1,y+1)] = st;\n\t\t}\n\t  }\n\t}\n\n\tcout << (search()? \"Yes\": \"No\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp make_pair\n#define pb push_back\n#define F first\n#define S second\n\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nbool app[50][50][50][50];\n\nmain(){\n  int w,h;\n  while(cin>>w>>h,w|h){\n    memset(app,0,sizeof(app));\n    string lr[h],rr[h];\n    rep(i,h){\n      cin>>lr[i]>>rr[i];\n    }\n\n    string ans=\"No\";\n    int rsx,rsy,lsx,lsy;\n    rep(i,h)rep(j,w){\n      if(lr[i][j]=='L')lsx=i,lsy=j;\n      if(rr[i][j]=='R')rsx=i,rsy=j;\n    }\n\n    queue<pair<PI,PI> > Q;\n    Q.push(mp(mp(lsx,lsy),mp(rsx,rsy)));\n\n    while(!Q.empty()){\n      PI tp=Q.front().F;\n      int clx,cly,crx,cry;\n      clx=tp.F,cly=tp.S;\n      tp=Q.front().S;Q.pop();\n      crx=tp.F,cry=tp.S;\n      if(lr[clx][cly]=='%' && rr[crx][cry]=='%'){\n        ans=\"Yes\";\n        break;\n      }\n      if(lr[clx][cly]=='%' || rr[crx][cry]=='%')continue;\n      \n      app[clx][cly][crx][cry]=true;\n\n      rep(i,4){\n        int nrx=crx+dx[i],nlx=clx+dx[i],nry=cry+dy[i],nly=cly-dy[i];\n        if(nrx<0 || nry<0 || nrx>=h || nry>=w)nrx=crx,nry=cry;\n        if(nlx<0 || nly<0 || nlx>=h || nly>=w)nlx=clx,nly=cly;\n        if(lr[nlx][nly]=='#'){\n          nlx=clx;\n          nly=cly;\n        }\n        if(rr[nrx][nry]=='#'){\n          nrx=crx;\n          nry=cry;\n        }\n        if(app[nlx][nly][nrx][nry])continue;\n        app[nlx][nly][nrx][nry]=true;\n        Q.push(mp(mp(nlx,nly),mp(nrx,nry)));\n      }\n/*      \n      rep(i,h){\n        rep(j,w){\n          if(clx==i && cly==j)cout<<'L';\n          else if(lr[i][j]=='L')cout<<'.';\n          else cout<<lr[i][j];\n        }\n        cout<<\" \";\n        rep(j,w){\n          if(crx==i && cry==j)cout<<'R';\n          else if(rr[i][j]=='R')cout<<'.';\n          else cout<<rr[i][j];\n        }\n        cout<<endl;\n      }\n      cout<<endl;\n*/\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\nbool memo[52][52][52][52];\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\n\nlong long int powint(long long int a, long long int b) {\n\tassert(b >= 0);\n\tif (b == 0)return 1;\n\tif (b == 1)return a;\n\tlong long int ans = 1;\n\tlong long int aa = powint(a, b / 2);\n\tans *= aa*aa;\n\tif (b % 2)ans *= a;\n\treturn ans;\n}\n\nstruct aa {\n\tint ly;\n\tint lx;\n\tint ry;\n\tint rx;\n};\n\nint main() {\n\twhile (1) {\n\t\tmemset(memo, false, sizeof(memo));\n\t\tint W, H; cin >> W >> H;\n\t\tif (!W)break;\n\t\tvector<vector<int>>lmap(H + 2, vector<int>(W + 2, 1));\n\t\tvector<vector<int>>rmap(H + 2, vector<int>(W + 2, 1));\n\n\t\tint lsx, lsy, rsx, rsy;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (st[j] == '.') {\n\t\t\t\t\tlmap[i+1][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\telse if (st[j] == 'L') {\n\t\t\t\t\tlsx = j + 1; lsy = i + 1;\n\t\t\t\t\tlmap[i + 1][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\telse if (st[j] == '%') {\n\n\t\t\t\t\tlmap[i + 1][j + 1] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t cin >> st;\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (st[j] == '.') {\n\t\t\t\t\trmap[i + 1][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\telse if (st[j] == 'R') {\n\t\t\t\t\trsx = j + 1; rsy = i + 1;\n\t\t\t\t\trmap[i + 1][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\telse if (st[j] == '%') {\n\n\t\t\t\t\trmap[i + 1][j + 1] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemo[lsy][lsx][rsy][rsx] = true;\n\t\tvector<aa>que;\n\t\tque.push_back(aa{ lsy,lsx,rsy,rsx });\n\t\tbool ok = false;\n\t\twhile (que.size()) {\n\t\t\taa atop(que.back());\n\t\t\tque.pop_back();\n\t\t\t\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tconst int lway = i;\n\t\t\t\t int rway = i;\n\t\t\t\tif (i == 0)rway = 2;\n\t\t\t\tif (i == 2)rway = 0;\n\t\t\t\tint nlx,nly,nrx,nry;\n\t\t\t\tif (lmap[atop.ly + dy[lway]][atop.lx + dx[lway]]!=1) {\n\t\t\t\t\tnlx = atop.lx + dx[lway];\n\t\t\t\t\tnly = atop.ly + dy[lway];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnlx = atop.lx;\n\t\t\t\t\tnly = atop.ly;\n\t\t\t\t}\n\t\t\t\tif (rmap[atop.ry + dy[rway]][atop.rx + dx[rway]]!=1) {\n\t\t\t\t\tnrx = atop.rx + dx[rway];\n\t\t\t\t\tnry = atop.ry + dy[rway];\n\t\t\t\t}else {\n\t\t\t\t\tnrx = atop.rx;\n\t\t\t\t\tnry = atop.ry;\n\t\t\t\t}\n\t\t\t\tif (!memo[nly][nlx][nry][nrx]) {\n\t\t\t\t\tmemo[nly][nlx][nry][nrx] = true;\n\t\t\t\t\tif (lmap[nly][nlx] == 2 && rmap[nry][nrx] == 2) {\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tque.push_back(aa{ nly,nlx,nry,nrx });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e9\n#define rep(i,n) for(int i=0;i<n;i++)\n\nstruct C{\n\tint tx,ty,kx,ky;\n\tC(int tx,int ty,int kx,int ky):\n\ttx(tx),ty(ty),kx(kx),ky(ky) {}\n};\n\nint X,Y,sxl,syl,gxl,gyl,sxr,syr,gxr,gyr,dx[]={1,0,-1,0},dy[]={0,1,0,-1},d[51][51][51][51];\nchar l[51][51],r[51][51];\n\nint bfs(int tx,int ty,int kx,int ky){\n\tqueue<C> q;\n\trep(i,X)rep(j,Y)rep(k,X)rep(l,Y)d[i][j][k][l]=INF;\n\tq.push(C(tx,ty,kx,ky));\n\td[tx][ty][kx][ky]=0;\n\twhile(!q.empty()){\n\t\tC c=q.front();q.pop();\n\t\tif(c.tx==gxl&&c.ty==gyl&&c.kx==gxr&&c.ky==gyr)return d[c.tx][c.ty][c.kx][c.ky];\n\t\trep(i,4){\n\t\t\tint ntx=c.tx+dx[i],nty=c.ty+dy[i],nkx=c.kx-dx[i],nky=c.ky+dy[i];\n\t\t\tif(ntx<0||ntx>=X||nty<0||nty>=Y||l[nty][ntx]=='#'){ntx=c.tx;nty=c.ty;}\n\t\t\tif(nkx<0||nkx>=X||nky<0||nky>=Y||r[nky][nkx]=='#'){nkx=c.kx;nky=c.ky;}\n\t\t\tif(d[ntx][nty][nkx][nky]==INF){\n\t\t\t\tq.push(C(ntx,nty,nkx,nky));\n\t\t\t\td[ntx][nty][nkx][nky]=d[c.tx][c.ty][c.kx][c.ky]+1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\twhile(cin>>X>>Y&&X){\n\t\trep(i,Y){\n\t\t\trep(j,X){\n\t\t\t\tcin>>l[i][j];\n\t\t\t\tif(l[i][j]=='%'){gxl=j;gyl=i;}\n\t\t\t\tif(l[i][j]=='L'){sxl=j;syl=i;}\n\t\t\t}\n\t\t\trep(j,X){\n\t\t\t\tcin>>r[i][j];\n\t\t\t\tif(r[i][j]=='%'){gxr=j;gyr=i;}\n\t\t\t\tif(r[i][j]=='R'){sxr=j;syr=i;}\n\t\t\t}\n\t\t}\n\t\tint ans=bfs(sxl,syl,sxr,syr);\n\t\tcout<<(bfs(sxl,syl,sxr,syr)?\"Yes\":\"No\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nint W, H;\nchar RoomL[52][52];\nchar RoomR[52][52];\n\nconst int dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};\n\nstruct P {\n    int lx, ly, rx, ry;\n};\n\nbool is_reachable(int x, int y, char room[52][52]) {\n    bool G[52][52] = {};\n    G[y][x] = true;\n    queue<pii> que;\n    que.push({x, y});\n    while (!que.empty()) {\n        pii p = que.front(); que.pop();\n        int x = p.first, y = p.second;\n        REP(i, 4) {\n            int sx = x + dx[i], sy = y + dy[i];\n            switch (room[sy][sx]) {\n            case '%':\n                return true;\n            case '#':\n                break;\n            default:\n                if (!G[sy][sx]) {\n                    G[sy][sx] = true;\n                    que.push({sx, sy});\n                }\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    while (cin >> W >> H, W|H) {\n        fill_n((char *)RoomL, 52*52, '#');\n        fill_n((char *)RoomR, 52*52, '#');\n\n        int lx, ly, rx, ry;\n        int lgx, lgy, rgx, rgy;\n        FOR(y, 1, H+1) {\n            FOR(x, 1, W+1) {\n                cin >> RoomL[y][x];\n                switch (RoomL[y][x]) {\n                case 'L':\n                    lx = x;\n                    ly = y;\n                    RoomL[y][x] = '.';\n                    break;\n                case '%':\n                    lgx = x;\n                    lgy = y;\n                    break;\n                }\n            }\n            FOR(x, 1, W+1) {\n                cin >> RoomR[y][x];\n                switch (RoomR[y][x]) {\n                case 'R':\n                    rx = x;\n                    ry = y;\n                    RoomR[y][x] = '.';\n                    break;\n                case '%':\n                    rgx = x;\n                    rgy = y;\n                    break;\n                }\n            }\n        }\n\n        if (!(is_reachable(lx, ly, RoomL) && is_reachable(rx, ry, RoomR))) {\n            cout << \"No\" << endl;\n            continue;\n        }\n\n        bool G[52][52][52][52] = {};\n        G[lx][ly][rx][ry] = true;\n        queue<P> que;\n        que.push({lx, ly, rx, ry});\n        while (!que.empty()) {\n            P p = que.front(); que.pop();\n            if (p.lx == lgx && p.ly == lgy && p.rx == rgx && p.ry == rgy) {\n                cout << \"Yes\" << endl;\n                goto END;\n            }\n\n            REP(i, 4) {\n                int lsx = p.lx - dx[i], lsy = p.ly + dy[i];\n                int rsx = p.rx + dx[i], rsy = p.ry + dy[i];\n                if (RoomL[lsy][lsx] == '#') {\n                    lsx = p.lx;\n                    lsy = p.lx;\n                }\n                if (RoomR[rsy][rsx] == '#') {\n                    rsx = p.rx;\n                    rsy = p.rx;\n                }\n                if (RoomR[rsy][rsx] == '%' || RoomL[lsy][lsx] == '%') {\n                    if (RoomR[rsy][rsx] == '%' && RoomL[lsy][lsx] == '%') {\n                    } else {\n                        continue;\n                    }\n                }\n                if (!G[lsx][lsy][rsx][rsy]) {\n//                    LOG(\"-----\\n%d %d # %d %d\\n-----\\n\", lsx, lsy, rsx, rsy);\n//                    REP(y, H) {\n//                        REP(x, W) {\n//                            if (lsx == x && lsy == y) {\n//                                printf(\"L\");\n//                            } else {\n//                                printf(\"%c\", RoomL[y][x]);\n//                            }\n//                        }\n//                        printf(\"\\n\");\n//                    }\n//                    REP(y, H) {\n//                        REP(x, W) {\n//                            if (rsx == x && rsy == y) {\n//                                printf(\"R\");\n//                            } else {\n//                                printf(\"%c\", RoomR[y][x]);\n//                            }\n//                        }\n//                        printf(\"\\n\");\n//                    }\n                    G[lsx][lsy][rsx][rsy] = true;\n                    que.push({lsx, lsy, rsx, rsy});\n                }\n            }\n        }\n        cout << \"No\" << endl;\n    END: {}\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<set>\n#include<cmath>\nusing namespace std;\ntypedef vector<int> vi;\nconst int inf=1e9;\nint w,h;\nint ldx[]={-1,0,1,0};\nint ldy[]={0,1,0,-1};\nint rdx[]={1,0,-1,0};\nint rdy[]={0,1,0,-1};\nbool rinvis[55][55];\nbool renvis[55][55];\nbool vis[55][55][55][55];\nstring rin[55];\nstring ren[55];\nbool treasure;\nint rinsx,rinsy,ringx,ringy,rensx,rensy,rengx,rengy;\nvoid bfs(int lx,int ly,int rx,int ry)\n{\n  vis[ly][lx][ry][rx]=true;\n  // renvis[ly][lx]=true;\n  //rinvis[ry][rx]=true;\n  if(ren[ly][lx]=='%' && rin[ry][rx]=='%')\n    {\n      treasure=true;\n      return;\n    }\n  else\n    {\n      int rennx,renny,rinnx,rinny;\n      bool rengoal=false;\n      bool ringoal=false;\n      for(int k=0;k<4;k++)\n\t{\n\t  rennx=lx+ldx[k];\n\t  renny=ly+ldy[k];\n\t  rinnx=rx+rdx[k];\n\t  rinny=ry+rdy[k];\n\t  if(rennx>=w || renny>=h || rennx<0 || renny<0 || rinnx>=w || rinny>=h || rinnx<0 || rinny<0) continue;\n\t  //if(renvis[renny][rennx] || rinvis[rinny][rinnx]) continue;\n\t  if(ren[renny][rennx]=='#')\n\t    {\n\t      rennx=lx;\n\t      renny=ly;\n\t    }\n\t  if(rin[rinny][rinnx]=='#')\n\t    {\n\t      rinnx=rx;\n\t      rinny=ry;\n\t    }\n\t  if(vis[renny][rennx][rinny][rinnx])continue;\n\t  if(ren[renny][rennx]=='%') rengoal=true;\n\t  else rengoal=false;\n\t  if(rin[rinny][rinnx]=='%') ringoal=true;\n\t  else ringoal=false;\n\t  if(rengoal^ringoal) continue;\n\t  else bfs(rennx,renny,rinnx,rinny);\n\t}\n      return;\n    }\n}\n\nint main()\n{\n  while(cin >> w >> h && w)\n    {\n      treasure=false;\n      memset(vis,false,sizeof(vis));\n      //memset(renvis,false,sizeof(renvis));\n      //memset(rinvis,false,sizeof(rinvis));\n      for(int i=0;i<h;i++)\n\t{\n\t  cin >> ren[i] >> rin[i];\n\t}\n      for(int i=0;i<h;i++)\n\t{\n\t  for(int j=0;j<h;j++)\n\t    {\n\t      if(ren[i][j]=='L')\n\t\t{\n\t\t  rensy=i;\n\t\t  rensx=j;\n\t\t}\n\t      if(ren[i][j]=='%')\n\t\t{\n\t\t  rengy=i;\n\t\t  rengx=j;\n\t\t}\n\t      if(rin[i][j]=='R')\n\t\t{\n\t\t  rinsy=i;\n\t\t  rinsx=j;\n\t\t}\n\t      if(rin[i][j]=='%')\n\t\t{\n\t\t  ringy=i;\n\t\t  ringx=j;\n\t\t}\n\t    }\n\t}\n      bfs(rensx,rensy,rinsx,rinsy);\n      if(treasure)\n\t{\n\t  cout << \"Yes\" << endl;\n\t}\n      else\n\t{\n\t  cout << \"No\" << endl;\n\t}\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<char,char> P;\n\nstruct state{\n\tP p1, p2;\n\tstate(P p1_, P p2_){ p1 = p1_; p2 = p2_; }\n};\nint w, h;\nint dx1[4] = {0,-1,1,0};\nint dy1[4] = {-1,0,0,1};\nint dx2[4] = {0,1,-1,0};\nint dy2[4] = {-1,0,0,1};\n\n// デバッグ用\ntemplate <class T>\nvoid debug(T v, string s){\n\tcout << s << endl;\n\tfor(int y=0 ; y < v.size() ; y++ ){\n\t\tcout << v[y] << endl;\n\t}\n\tcout << endl;\n}\n\n// vs から vs[y][x] == c となる (x,y) を返す\nP search(vector<string>& vs, char c){\n\tfor(int y=0 ; y < vs.size() ; y++ ){\n\t\tfor(int x=0 ; x < vs[y].size() ; x++ ){\n\t\t\tif( vs[y][x] == c ){\n\t\t\t\tvs[y][x] = '.';\n\t\t\t\treturn P(x,y);\n\t\t\t}\n\t\t}\n\t}\n\treturn P(0,0);\n}\n\nbool bfs(vector<string> L, vector<string>& R){\n\tP ls = search( L , 'L' );\n\tP rs = search( R , 'R' );\n\t//debug( L , \"[Left]\" );\n\t//debug( R , \"[right]\" );\n\t\n\tqueue< pair<P,P> > q;\n\tpair<P,P> s( ls , rs );\n\tq.push( s );\n\tmap<pair<P,P>,bool> memo;\n\twhile( !q.empty() ){\n\t\tpair<P,P> now = q.front(); q.pop();\n\t\tmemo[now] = true;\n\t\tint x1 = now.first.first;\n\t\tint y1 = now.first.second;\n\t\tint x2 = now.second.first;\n\t\tint y2 = now.second.second;\n\t\tif( L[y1][x1] == '%' && R[y2][x2] == '%' ){\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\tint mx1 = x1 + dx1[i];\n\t\t\tint my1 = y1 + dy1[i];\n\t\t\tif( mx1 < 0 || my1 < 0 || mx1 >= w || my1 >= h || L[my1][mx1] == '#' ){\n\t\t\t\tmx1 = x1;\n\t\t\t\tmy1 = y1;\n\t\t\t}\n\t\t\tint mx2 = x2 + dx2[i];\n\t\t\tint my2 = y2 + dy2[i];\n\t\t\tif( mx2 < 0 || my2 < 0 || mx2 >= w || my2 >= h || R[my2][mx2] == '#' ){\n\t\t\t\tmx2 = x2;\n\t\t\t\tmy2 = y2;\n\t\t\t}\n\t\t\tP p1(mx1,my1);\n\t\t\tP p2(mx2,my2);\n\t\t\tpair<P,P> next(p1,p2);\n\t\t\tif( memo.count( next ) ){\n\t\t\t\tcontinue;\n\t\t\t}else if( L[my1][mx1] == '%' && R[my2][mx2] != '%' ){\n\t\t\t\tmemo[next] = true;\n\t\t\t}else if( L[my1][mx1] != '%' && R[my2][mx2] == '%' ){\n\t\t\t\tmemo[next] = true;\n\t\t\t}else{\n\t\t\t\tq.push( next );\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\twhile( cin >> w >> h, w || h ){\n\t\tvector<string> L(h), R(h);\n\t\t\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tcin >> L[y];\n\t\t\tcin >> R[y];\n\t\t}\n\t\tbool ans = bfs( L , R );\n\t\tif( ans )\n\t\t\tcout << \"Yes\" << endl;\n\t\telse\n\t\t\tcout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint dx[4] = {1, 0,-1, 0};\nint dy[4] = {0, 1, 0,-1};\n\nvector<vector<char> > l;\nvector<vector<char> > r;\nvector<vector<bool> > u;\nint w,h;\n\nbool dfs(int lx, int ly, int rx, int ry){\n\t//cout << lx << \" \" << ly << \" \" << rx << \" \" << ry << endl;\n\tif(u[(ly-1)*w+(lx-1)][(ry-1)*w+(rx-1)]) return false;\n\tu[(ly-1)*w+(lx-1)][(ry-1)*w+(rx-1)] = true;\n\tif(l[ly][lx]=='%' && r[ry][rx]=='%') return true;\n\tfor(int i=0; i<4; i++){\n\t\tint nlx = lx+dx[i], nly = ly+dy[i];\n\t\tint nrx, nry;\n\t\tif(i%2==0){\n\t\t\tnrx = rx+dx[(i+2)%4];\n\t\t\tnry = ry+dy[(i+2)%4];\n\t\t}else{\n\t\t\tnrx = rx+dx[i];\n\t\t\tnry = ry+dy[i];\n\t\t}\n\t\tif(l[nly][nlx]=='#'){\n\t\t\tnlx = lx;\n\t\t\tnly = ly;\n\t\t}\n\t\tif(r[nry][nrx]=='#'){\n\t\t\tnrx = rx;\n\t\t\tnry = ry;\n\t\t}\n\t\tif(dfs(nlx, nly, nrx, nry)){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w==0) break;\n\t\t\n\t\tvector<vector<char> > left(h+2, vector<char>(w+2, '#'));\n\t\tvector<vector<char> > right(h+2, vector<char>(w+2, '#'));\n\t\tvector<vector<bool> > used(h*w, vector<bool>(h*w, false));\n\t\tint lx,ly, rx,ry;\n\t\tfor(int i=1; i<=h; i++){\n\t\t\tfor(int j=1; j<=w; j++){\n\t\t\t\tcin >> left[i][j];\n\t\t\t\tif(left[i][j]=='L'){\n\t\t\t\t\tlx = j;\n\t\t\t\t\tly = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=1; j<=w; j++){\n\t\t\t\tcin >> right[i][j];\n\t\t\t\tif(right[i][j]=='R'){\n\t\t\t\t\trx = j;\n\t\t\t\t\try = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tl = left;\n\t\tr = right;\n\t\tu = used;\n\t\t\n\t\tif(dfs(lx, ly, rx, ry)){\n\t\t\tcout << \"Yes\" << endl;\n\t\t}else{\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint w, h;\nstring l[51], r[51];\nint ldx[4] = {1, 0, -1, 0};\nint ldy[4] = {0, 1, 0, -1};\nint rdx[4] = {1, 0, -1, 0};\nint rdy[4] = {0, -1, 0, 1};\nint lsx, lsy, rsx, rsy, lgx, lgy, rgx, rgy;\nbool lischecked[51][51], rischecked[51][51];\n\nbool solve(int lx, int ly, int rx, int ry){\n    queue<int> rxqu, ryqu, lxqu, lyqu;\n    rxqu.push(rx);\n    ryqu.push(ry);\n    lxqu.push(lx);\n    lyqu.push(ly);\n    while(!rxqu.empty()){\n        lx = lxqu.front();\n        ly = lyqu.front();\n        rx = rxqu.front();\n        ry = ryqu.front();\n        lxqu.pop();\n        lyqu.pop();\n        rxqu.pop();\n        ryqu.pop();\n        if(lx == lgx && ly == lgy && rx == rgx && ry == rgy) return true;\n        if((lx == lgx && ly == lgy) || (rx == rgx && ry == rgy)) continue;\n        for(int i = 0; i < 4; i++){\n            int nlx = lx + ldx[i], nly = ly + ldy[i];\n            int nrx = rx + rdx[i], nry = ry + rdy[i];\n            if((nlx < 0 || nly < 0 || nlx >= h || nly >= w) && (nrx < 0 || nry < 0 || nrx >= h || nry >= w)) continue;\n            if(nlx < 0 || nlx >= h || nly < 0 || nly >= w){\n                nlx = lx;\n                nly = ly;\n            }\n            if(nrx < 0 || nrx >= h || nry < 0 || nry >= w){\n                nrx = rx;\n                nry = ry;\n            }\n            if((l[nlx][nly] == '#' && r[nrx][nry] == '#') || (lischecked[nlx][nly] && rischecked[nrx][nry])) continue;\n            if(l[nlx][nly] == '#'){\n                nlx = lx;\n                nly = ly;\n            }\n            if(r[nrx][nry] == '#'){\n                nrx = rx;\n                nry = ry;\n            }\n            lischecked[nlx][nly] = true;\n            rischecked[nrx][nry] = true;\n            rxqu.push(nrx);\n            ryqu.push(nry);\n            lxqu.push(nlx);\n            lyqu.push(nly);\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    while(1){\n        cin >> w >> h;\n        if(w == 0 && h == 0) break;\n        for(int i = 0; i < h; i++){\n            cin >> l[i] >> r[i];\n        }\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                lischecked[i][j] = false;\n                rischecked[i][j] = false;\n                if(l[i][j] == 'L'){\n                    lsx = i;\n                    lsy = j;\n                }\n                if(l[i][j] == '%'){\n                    lgx = i;\n                    lgy = j;\n                }\n                if(r[i][j] == 'R'){\n                    rsx = i;\n                    rsy = j;\n                }\n                if(r[i][j] == '%'){\n                    rgx = i;\n                    rgy = j;\n                }\n            }\n        }\n        lischecked[lsx][lsy] = true;\n        rischecked[rsx][rsy] = true;\n        if(solve(lsx, lsy, rsx, rsy)) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define MAX 51\n#include<cstring>\nusing namespace std;\n\nbool f=false,visited[MAX][MAX][MAX][MAX];\nint w,h;\nchar L[MAX][MAX],R[MAX][MAX];\n\nint ldy[]={0,-1,0,1};\nint ldx[]={1,0,-1,0};\nint rdy[]={0,-1,0,1};\nint rdx[]={-1,0,1,0};\n\nvoid dfs(int ly,int lx, int ry, int rx){\n  visited[ly][lx][ry][rx] = true;\n\n  int nly,nlx,nry,nrx;\n  for(int i=0; i<4; i++){\n    nly = ly + ldy[i];\n    nlx = lx + ldx[i];\n    nry = ry + rdy[i];\n    nrx = rx + rdx[i];\n\n    if(!visited[nly][nlx][nry][nrx] &&\n       0<=nly && nly<h && 0<=nlx && nlx<w && 0<=nry && nry<h && 0<=nrx && nrx<w){\n      if(L[nly][nlx]=='%' && R[nry][nrx]=='%'){\n\tf = true;\n\treturn ;\n      }\n      if(L[nly][nlx]=='%' || R[nry][nrx]=='%') visited[nly][nlx][nry][nrx] = true;\n      if(L[nly][nlx]=='#' && R[nry][nrx]=='.') dfs(ly,lx,nry,nrx);\n      if(L[nly][nlx]=='.' && R[nry][nrx]=='#') dfs(nly,nlx,ry,rx);\n      if(L[nly][nlx]='.' && R[nry][nrx]=='.')  dfs(nly,nlx,nry,nrx);\n    }\n  }\n}\n\n\nint main(){\n\n  while(cin >> w >> h ,w|h){\n    cin.ignore();\n\n    for(int i=0; i<h; i++){\n      string str;\n      getline(cin,str);\n      bool first=true;\n      int cnt = 0;\n      for(int j=0; j<str.size(); j++){\n\tif(str[j]==' '){\n\t  first = false;\n\t  continue;\n\t}\n\tif(first) L[i][j] = str[j];\n\telse R[i][cnt++] = str[j];\n      }\n    }\n    int sly,slx,sry,srx;\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tif(L[i][j]=='L'){\n\t  sly = i;\n\t  slx = j;\n\t}\n\tif(R[i][j]=='R'){\n\t  sry = i;\n\t  srx = j;\n\t}\n      }\n    }\n\n    f = false;\n    memset(visited,false,sizeof(visited));\n    visited[sly][slx][sry][srx]=true;\n    dfs(sly,slx,sry,srx);\n    if(f) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntemplate<typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int from, int to, T cost) {\n        this->from = from;\n        this->to = to;\n        this->cost = cost;\n    }\n};\nbool operator == (Edge<int> e1, Edge<int> e2) {\n    return e1.from == e2.from &&\n            e1.to == e2.to &&\n            e1.cost == e2.cost;\n}\nbool operator > (Edge<int> e1, Edge<int> e2) {\n    return e1.cost < e2.cost;\n}\ntemplate<typename T>\nusing Edges = std::vector<Edge<T>>;\ntemplate<typename T>\nusing Graph = std::vector<Edges<T>>;\ntemplate <typename T>\nstd::vector<T> dijkstra(const Graph<T> &g, int s) {\n    int sz = (int)(g.size());\n    std::vector<T> dist(sz, -1);\n    std::priority_queue<std::pair<T, int>, std::vector<std::pair<T, int>>, std::greater<std::pair<T, int>>> pq;\n    dist[s] = 0;\n    pq.push({0, s});\n    while(!pq.empty()) {\n        T d = pq.top().first;\n        int now = pq.top().second;\n        pq.pop();\n        if(dist[now] == -1 || d > dist[now]) continue;\n        for(int i=0;i<(int)(g[now].size());++i) {\n            int next = g[now][i].to;\n            T cost = g[now][i].cost;\n            if(dist[next] == -1 || dist[next] > dist[now] + cost) {\n                dist[next] = dist[now] + cost;\n                pq.push({cost, next});\n            }\n        }\n    }\n    return dist;\n}\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\nvoid solve(int w, int h) {\n  vector<string> sl(h), sr(h);\n  int st = 0, ed = 0;\n  for(int i=0;i<h;++i) {\n    cin >> sl[i] >> sr[i];\n    reverse(sl[i].begin(), sl[i].end());\n    for(int j=0;j<w;++j) {\n      if(sl[i][j] == 'L') st += i*w*h*w + j*h*w;\n      if(sr[i][j] == 'R') st += i*w + j;\n    }\n  }\n  vi dr = {-1, 1, 0, 0}, dc = {0, 0, -1, 1};\n  queue<P> que;\n  map<P, bool> sel;\n  que.push({st / (h*w), st % (h*w)});\n  sel[{st / (h*w), st % (h*w)}] = true;\n  bool ok = false;\n  while(!que.empty()) {\n    if(ok) break;\n    P now = que.front(); que.pop();\n    int i = now.first / w, j = now.first % w;\n    int k = now.second / w, l = now.second % w;\n    for(int p=0;p<4;++p) {\n      int ni = i + dr[p], nj = j + dc[p], nk = k + dr[p], nl = l + dc[p];\n      if(!(0 <= ni && ni < h && 0 <= nj && nj < w) || sl[ni][nj] == '#') {\n        ni -= dr[p];\n        nj -= dc[p];\n      }\n      if(!(0 <= nk && nk < h && 0 <= nl && nl < w) || sr[nk][nl] == '#') {\n        nk -= dr[p];\n        nl -= dc[p];\n      }\n      if(sel[{ni * w + nj, nk * w + nl}]) continue;\n      sel[{ni * w + nj, nk * w + nl}] = true;\n      if((sl[ni][nj] == '%' || sr[nk][nl] == '%') && !(sl[ni][nj] == '%' && sr[nk][nl] == '%')) {\n        continue;\n      }\n      if(sl[ni][nj] == '%' && sr[nk][nl] == '%') {\n        ok = true;\n        break;\n      }\n      que.push({ni * w + nj, nk * w + nl});\n    }\n  }\n  if(ok) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  while(1) {\n    int w, h; cin >> w >> h;\n    if(w == 0) break;\n    solve(w, h);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e18\n//#define int long long\n#define Rep(i, a, n) for (int i = (a); i < (n); i++)\n#define Repr(i, n, a) for (int i = (n); i >= (a); i--)\n#define rep(i, n) Rep(i, 0, n)\n#define repr(i, n) Repr(i, n, 0)\n#define all(a) a.begin(), a.end()\nusing namespace std;\ntypedef pair<int, int> P;\nconst int mod = 1000000007;\n\nint w, h;\nchar r1[60][60], r2[60][60];\nint dx[] = {1, 0, -1, 0}, dy1[] = {0, -1, 0, 1}, dy2[] = {0, 1, 0, -1};\nbool vis[51][51][51][51];\n\nbool in(int x, int y) { return 0 <= x && x < h && 0 <= y && y < w; }\nbool solve(int X1, int Y1, int X2, int Y2)\n{\n    typedef pair<P, P> PP;\n    queue<PP> que;\n    que.push(PP(P(X1, Y1), P(X2, Y2)));\n    vis[X1][Y1][X2][Y2] = true;\n    while (!que.empty())\n    {\n        PP pp = que.front();\n        que.pop();\n        P L = pp.first, R = pp.second;\n        int x1 = L.first, y1 = L.second, x2 = R.first, y2 = R.second;\n        rep(i, 4)\n        {\n            int nx1 = x1 + dx[i], ny1 = y1 + dy1[i];\n            int nx2 = x2 + dx[i], ny2 = y2 + dy2[i];\n            if (!in(nx1, ny1) || r1[nx1][ny1] == '#')\n                nx1 = x1, ny1 = y1;\n            if (!in(nx2, ny2) || r2[nx2][ny2] == '#')\n                nx2 = x2, ny2 = y2;\n            if (r1[nx1][ny1] == '%' && r2[nx2][ny2] == '%')\n                return true;\n            if (r1[nx1][ny1] == '%' || r2[nx2][ny2] == '%')\n                continue;\n            if (vis[nx1][ny1][nx2][ny2])\n                continue;\n            vis[nx1][ny1][nx2][ny2] = true;\n            que.push(PP(P(nx1, ny1), P(nx2, ny2)));\n        }\n    }\n    return false;\n}\n\nsigned main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    while (1)\n    {\n        cin >> w >> h;\n        if (w == 0)\n            break;\n        rep(i, h)\n        {\n            rep(j, w) cin >> r1[i][j];\n            rep(j, w) cin >> r2[i][j];\n        }\n        rep(i, h) rep(j, w) rep(k, h) rep(l, w) vis[i][j][k][l] = false;\n        int lx, ly, rx, ry;\n        rep(i, h) rep(j, w) if (r1[i][j] == 'L') lx = i, ly = j;\n        rep(i, h) rep(j, w) if (r2[i][j] == 'R') rx = i, ry = j;\n        cout << (solve(lx, ly, rx, ry) ? \"Yes\" : \"No\") << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<sstream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<climits>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = j; i < k; i++)\n#define P pair<int, int>\n#define PP pair<P, P>\nconst int INF = INT_MAX / 2;\nconst int MAX_H = 51;\nconst int MAX_W = 51;\n\nbool closed[MAX_H][MAX_W][MAX_H][MAX_W];\n\nbool canMove(int y, int x, vector< vector<char> > m){\n    if(m[y][x] == '#') return false;\n    else return true;\n}\n\nint main(){\n    int w, h;\n    while(cin >>w >>h && (w || h) ){\n\n        int srx, sry, slx, sly;\n        int grx, gry, glx, gly;\n        vector< vector<char> > l_map(h + 2, vector<char>(w + 2, '*') ), r_map(h + 2, vector<char>(w + 2, '*') );\n\n        //start of input\n        REP(i, l_map.size()){\n            l_map[i][0] = '#';\n            r_map[i][0] = '#';\n            l_map[i][w + 1] = '#';\n            r_map[i][w + 1] = '#';\n        }\n        REP(i, l_map[0].size()){\n            l_map[0][i] = '#';\n            r_map[0][i] = '#';\n            l_map[h + 1][i] = '#';\n            r_map[h + 1][i] = '#';\n        }\n\n        FOR(i, 1, h + 1){\n            FOR(j, 1, w + 1){\n                cin >>l_map[i][j];\n                if(l_map[i][j] == 'L'){\n                    sly = i;\n                    slx = j;\n                }\n                if(l_map[i][j] == '%'){\n                    gly = i;\n                    glx = j;\n                }\n            }\n            FOR(j, 1, w + 1){\n                cin >>r_map[i][j];\n                if(r_map[i][j] == 'R'){\n                    sry = i;\n                    srx = j;\n                }\n                if(r_map[i][j] == '%'){\n                    gry = i;\n                    grx = j;\n                }\n            }\n        }\n        //end of input\n\n        priority_queue<PP> open;\n        open.push( PP( P(sry, srx), P(sly, slx) ) );\n        memset(closed, false, sizeof(closed));\n\n        bool ans = false;\n        int my[] = {0, 0, 1, -1};\n        int mx[] = {1, -1, 0, 0};\n\n        while(!open.empty()){\n            PP now = open.top();\n            open.pop();\n            int ry = now.first.first, rx = now.first.second, ly = now.second.first, lx = now.second.second;\n\n            if(ry == gry && rx == grx && ly == gly && lx == glx){\n                ans = true;\n                break;\n            }\n            closed[ry][rx][ly][lx] = true;\n\n            REP(i, 4){\n                int n_ry = ry + my[i];\n                int n_rx = rx + mx[i];\n                int n_ly = ly + my[i];\n                int n_lx = lx + (mx[i] * -1);\n\n                if(!canMove(n_ry, n_rx, r_map) && !canMove(n_ly, n_lx, l_map)){\n                    continue;\n                } else if(!canMove(n_ry, n_rx, r_map)){\n                    n_ry = ry;\n                    n_rx = rx;\n                }\n                else if(!canMove(n_ly, n_lx, l_map)){\n                    n_ly = ly;\n                    n_lx = lx;\n                }\n                if(closed[n_ry][n_rx][n_ly][n_lx]) continue;\n                open.push( PP( P(n_ry, n_rx), P(n_ly, n_lx) ) );\n            }\n        }\n\n        cout <<((ans)? \"Yes\" : \"No\") <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <numeric>\n#include <functional>\n#include <cctype>\n#include <list>\n#include <limits>\n#include <cassert>\n//#include <boost/multiprecision/cpp_int.hpp>\n\n\n\nusing namespace std;\nusing Int = long long;\n//using namespace boost::multiprecision;\n\nconst double EPS = (1e-10);\nlong long const MOD = 1000000007;\n\nlong long mod_pow(long long x, long long n) {\n    long long res = 1;\n    for(int i = 0;i < 60; i++){\n        if(n >> i & 1) res = res * x % MOD;\n        x = x * x % MOD;\n    }\n    return res;\n}\n\ntemplate<typename T>\nT gcd(T a, T b) {\n    return b != 0 ? gcd(b, a % b) : a;\n}\n\ntemplate<typename T>\nT lcm(T a, T b) {\n    return a * b / gcd(a, b);\n}\n\nvoid fastInput() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n}\n\nstruct Coordinate {\n    int w, h;\n};\n\nstruct State {\n    int lh, lw, rh, rw;\n};\n\nint v[60][60][60][60];\n\nint solve(int W, int H) {\n    vector<string> roomL;\n    vector<string> roomR;\n\n    for (int h = 0; h <= H+1; h++) {\n        string tmp;\n        for (int w = 0; w <= W+1; w++) {\n            tmp.push_back('#');\n        }\n        roomL.push_back(tmp);\n        roomR.push_back(tmp);\n    }\n\n    Coordinate Lgoal;\n    Coordinate Lstart;\n    Coordinate Rgoal;\n    Coordinate Rstart;\n\n    for (int h = 1; h <= H; h++) {\n        for (int w = 1; w <= W; w++) {\n            char c; cin >> c;\n            roomL[h][w] = c;\n            if (roomL[h][w] == '%') {\n                Lgoal.h = h;\n                Lgoal.w = w;\n            }\n            if (roomL[h][w] == 'L') {\n                Lstart.h = h;\n                Lstart.w = w;\n            }\n        }\n        for (int w = 1; w <= W; w++) {\n            char c; cin >> c;\n            roomR[h][w] = c;\n            if (roomR[h][w] == '%') {\n                Rgoal.h = h;\n                Rgoal.w = w;\n            }\n            if (roomR[h][w] == 'R') {\n                Rstart.h = h;\n                Rstart.w = w;\n            }\n        }\n    }\n\n    memset(v, 0, sizeof(v));\n    int ldw[] = {0, 1, 0, -1};\n    int ldh[] = {-1, 0, 1, 0};\n    int rdw[] = {0, -1, 0, 1};\n    int rdh[] = {-1, 0, 1, 0};\n\n    State crt = {Lstart.h, Lstart.w, Rstart.h, Rstart.w};\n    queue<State> q;\n    q.push(crt);\n    v[crt.lh][crt.lw][crt.rh][crt.rw] = 1;\n\n    while (!q.empty()) {\n        crt = q.front();\n        q.pop();\n        State nextState;\n        for (int i = 0; i < 4; i++) {\n            nextState.lh = crt.lh + ldh[i];\n            nextState.lw = crt.lw + ldw[i];\n            nextState.rh = crt.rh + rdh[i];\n            nextState.rw = crt.rw + rdw[i];\n\n            int flag[2] = {0};\n            if (roomL[nextState.lh][nextState.lw] == '%') flag[0] = 1;\n            if (roomR[nextState.rh][nextState.rw] == '%') flag[1] = 1;\n            if (flag[0] + flag[1] == 1) continue;\n\n            if (roomL[nextState.lh][nextState.lw] == '#') {\n                nextState.lh = crt.lh;\n                nextState.lw = crt.lw;\n            }\n            if (roomR[nextState.rh][nextState.rw] == '#') {\n                nextState.rh = crt.rh;\n                nextState.rw = crt.rw;\n            }\n            if (v[nextState.lh][nextState.lw][nextState.rh][nextState.rw] == 0) {\n                v[nextState.lh][nextState.lw][nextState.rh][nextState.rw] = 1;\n                q.push(nextState);\n            }\n        }\n    }\n    return v[Lgoal.h][Lgoal.w][Rgoal.h][Rgoal.w];\n}\n\nint main(void) {\n    int W, H;\n    vector<int> ans;\n    while (1) {\n        cin >> W >> H;\n        if (!W && !H) break;\n        ans.push_back(solve(W, H));\n    }\n    for (auto &i : ans) {\n        if (i) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// Header {{{\n// includes {{{\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <unistd.h>\n#include <vector>\n// }}}\nusing namespace std;\n// consts {{{\nstatic const int INF = 1e9;\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n// }}}\n// typedefs {{{\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<ULL> VULL;\ntypedef vector<VULL> VVULL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\ntypedef complex<int> P;\n#define PQ(type) priority_queue<type>\n// priority queue reverse\n#define PQR(type) priority_queue< type, vector<type>, greater<type> >\n// }}}\n// macros & inline functions {{{\n// syntax sugars {{{\n#define FOR(i, b, e) for (typeof(e) i = (b); i < (e); ++i)\n#define FORI(i, b, e) for (typeof(e) i = (b); i <= (e); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(i, n) FORI(i, 0, n)\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n#define ASSIGN_MAX(var, val) ((var) = max((var), (val)))\n#define ASSIGN_MIN(var, val) ((var) = min((var), (val)))\n// }}}\n// conversion {{{\ninline int toInt(string s) { int v; istringstream sin(s); sin>>v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout<<x; return sout.str(); }\n// }}}\n// array and STL {{{\n#define ARRSIZE(a) ( sizeof(a) / sizeof(a[0]) )\n#define ZERO(a, v) ( assert(v == 0 || v == -1), memset(a, v, sizeof(a)) )\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define SIZE(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c, it) for(typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define REACH(c, it) for(typeof((c).rbegin()) it=(c).rbegin(); it!=(c).rend(); ++it)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n// }}}\n// bit manipulation {{{\n// singed integers are not for bitwise operations, specifically arithmetic shifts ('>>', and maybe not good for '<<' too)\n#define IS_UNSIGNED(n) (!numeric_limits<typeof(n)>::is_signed)\n#define BIT(n) (assert(IS_UNSIGNED(n)), assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(IS_UNSIGNED(n)), assert(m < 64), ((ULL)(n) >> (m) & 1))\ninline int BITS_COUNT(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int MSB(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c-1; }\ninline int MAKE_MASK(ULL upper, ULL lower) { assert(lower < 64 && upper < 64 && lower <= upper); return (BIT(upper) - 1) ^ (BIT(lower) - 1); }\n// }}}\n// for readable code {{{\n#define EVEN(n) (n % 2 == 0)\n#define ODD(n) (!EVEN(n))\n// }}}\n// debug {{{\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n#define dprt(fmt, ...) if (opt_debug) { fprintf(stderr, fmt, ##__VA_ARGS__); }\n#define darr(a) if (opt_debug) { copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr_range(a, f, t) if (opt_debug) { copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define dvec(v) if (opt_debug) { copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr2(a) if (opt_debug) { FOR(__i, 0, (arrsz(a))){ darr( (a)[__i] ); } }\n#define WAIT() if (opt_debug) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#define dump(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl; }\n// dump vector elements in [s, e)\n#define dumpv(v, s, e) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #v << \" = \"; FOR(__i, s, e) { cerr << v[__i] << \"\\t\"; } cerr << endl; }\n#define dumpl(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << endl << (x) << endl; }\n#define dumpf() if (opt_debug) { cerr << __PRETTY_FUNCTION__ << endl; }\n#define where() if (opt_debug) { cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl; }\n#define dumpb(bit, digits) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #bit << \" = \"; for(int __i = digits - 1; __i >= 0; __i--) { cerr << static_cast<bool>(bit & (1 << __i)); if (__i % 4 == 0) { cerr << \" \"; } } cerr << endl; }\n\n// ostreams {{{\n// complex\ntemplate<typename T> ostream& operator<<(ostream& s, const complex<T>& d) {return s << \"(\" << d.real() << \", \" << d.imag() << \")\";}\n\n// pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n// vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i]; if (i < len - 1) s << \"\\t\";\n\t}\n\treturn s;\n}\n\n// 2 dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i] << endl;\n\t}\n\treturn s;\n}\n\n// map\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const map<T1, T2>& m) {\n\ts << \"{\" << endl;\n\tfor (typeof(m.begin()) itr = m.begin(); itr != m.end(); ++itr) {\n\t\ts << \"\\t\" << (*itr).first << \" : \" << (*itr).second << endl;\n\t}\n\ts << \"}\" << endl;\n\treturn s;\n}\n// }}}\n// }}}\n// }}}\n// time {{{\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\n// }}}\n// string manipulation {{{\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\ninline string join(VS s, string j) { string t; REP(i, s.size()) { t += s[i] + j; } return t; }\n// }}}\n// geometry {{{\n#define Y real()\n#define X imag()\n// }}}\n// 2 dimentional array {{{\nenum { UP, RIGHT, DOWN, LEFT, UP_RIGHT, DOWN_RIGHT, DOWN_LEFT, UP_LEFT };\nP dydx4[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\nP dydx8[8] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(-1, 1), P(1, 1), P(1, -1), P(-1, -1) };\nbool in_field(int H, int W, P p) {\n\treturn (0 <= p.Y && p.Y < H) && (0 <= p.X && p.X < W);\n}\n// }}}\n// input and output {{{\ninline void input(string filename) {\n\tfreopen(filename.c_str(), \"r\", stdin);\n}\ninline void output(string filename) {\n\tfreopen(filename.c_str(), \"w\", stdout);\n}\n// }}}\n// }}}\n\nbool opt_debug = false;\n\nint main(int argc, char** argv) {\n\tstd::ios_base::sync_with_stdio(false);\n\t// set options {{{\n\tint __c;\n\twhile ( (__c = getopt(argc, argv, \"d\")) != -1 ) {\n\t\tswitch (__c) {\n\t\t\tcase 'd':\n\t\t\t\topt_debug = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tabort();\n\t\t}\n\t}\n\t// }}}\n\n\t// opt_debug = true;\n\t// input(\"./inputs/0.txt\");\n\t// output(\"./outputs/0.txt\");\n\n\tint W, H;\n\twhile (cin >> W >> H, W | H) {\n\t\tVVC room_l(H, VC(W));\n\t\tVVC room_r(H, VC(W));\n\t\tP len, rin;\n\t\tREP (i, H) {\n\t\t\tREP (j, W) {\n\t\t\t\tcin >> room_l[i][j];\n\t\t\t\tif (room_l[i][j] == 'L') {\n\t\t\t\t\tlen = P(i, j);\n\t\t\t\t\troom_l[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP (j, W) {\n\t\t\t\tcin >> room_r[i][j];\n\t\t\t\tif (room_r[i][j] == 'R') {\n\t\t\t\t\trin = P(i, j);\n\t\t\t\t\troom_r[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttypedef pair<P, P> PPP;\n\t\tqueue<PPP> q;\n\t\tq.push(MP(len, rin));\n\t\tP dydx_l[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\n\t\tP dydx_r[4] = { P(-1, 0), P(0, -1), P(1, 0), P(0, 1) };\n\t\ttypedef pair< pair<int, int>, pair<int, int> > PPIIPII;\n\t\tset< PPIIPII > visited;\n\t\tbool ok = false;\n\t\twhile (!q.empty()) {\n\t\t\tPPP t = q.front(); q.pop();\n\t\t\tPPIIPII key = MP( MP(t.F.Y, t.F.X), MP(t.S.Y, t.S.X) );\n\t\t\tif (EXIST(visited, key)) { continue; }\n\t\t\tvisited.insert(key);\n\t\t\tlen = t.F; rin = t.S;\n\t\t\tif (room_l[len.Y][len.X] == '%' && room_r[rin.Y][rin.X] == '%') {\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (room_l[len.Y][len.X] == '%' || room_r[rin.Y][rin.X] == '%') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tREP (d, 4) {\n\t\t\t\tP n_len = len + dydx_l[d];\n\t\t\t\tP n_rin = rin + dydx_r[d];\n\t\t\t\tif (!in_field(H, W, n_len) || room_l[n_len.Y][n_len.X] == '#') {\n\t\t\t\t\tn_len -= dydx_l[d];\n\t\t\t\t}\n\t\t\t\tif (!in_field(H, W, n_rin) || room_r[n_rin.Y][n_rin.X] == '#') {\n\t\t\t\t\tn_rin -= dydx_r[d];\n\t\t\t\t}\n\t\t\t\tq.push(MP(n_len, n_rin));\n\t\t\t}\n\t\t}\n\n\t\tif (ok) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t} else {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\nusing namespace std;\nstring s1[50],s2[50];\nint dx1[]={1,-1,0,0,},dy1[]={0,0,1,-1};\nint dx2[]={-1,1,0,0,},dy2[]={0,0,1,-1};\nint w,h,gx1,gx2,gy1,gy2;\nset<pair<pair<int,int>,pair<int,int> > >s;\nbool bfs(int x1,int y1,int x2,int y2){\n  queue<pair<int,int> >q;\n  q.push(mk(x1*100+y1,x2*100+y2));\n  while(!q.empty()){\n    pair<int,int>p=q.front();q.pop();\n    x1=p.first/100;y1=p.first%100;\n    x2=p.second/100;y2=p.second%100;\n    if(x1==gx1&&y1==gy1&&(x2!=gx2||y2!=gy2))continue;\n    if((x1!=gx1||y1!=gy1)&&x2==gx2&&y2==gy2)continue;\n    if(x1==gx1&&y1==gy1&&x2==gx2&&y2==gy2)return 1;\n    for(int i=0;i<4;i++){\n      int x3=x1+dx1[i],y3=y1+dy1[i];\n      int x4=x2+dx2[i],y4=y2+dy2[i];\n      if(x3>=0&&x4>=0&&y3>=0&&y4>=0)\n        if(x3<w&&x4<w&&y3<h&&y4<h){\n          if(s1[y3][x3]=='#')y3=y1,x3=x1;\n          if(s2[y4][x4]=='#')y4=y2,x4=x2;\n          if(!s.count(mk(mk(x3,y3),mk(x4,y4)))){\n            s.insert(mk(mk(x3,y3),mk(x4,y4)));\n            q.push(mk(x3*100+y3,x4*100+y4));\n          }\n        }\n      }\n    }\n    return 0;\n}\nint main(){\n  int x1,y1,x2,y2;\n  while(cin>>w>>h,w){\n    s.clear();\n    r(i,h)cin>>s1[i]>>s2[i];\n    r(i,h)r(j,w){\n      if(s1[i][j]=='L')x1=j,y1=i;\n      if(s2[i][j]=='R')x2=j,y2=i;\n      if(s1[i][j]=='%')gx1=j,gy1=i;\n      if(s2[i][j]=='%')gx2=j,gy2=i;\n    }\n    s.insert(mk(mk(x1,y1),mk(x2,y2)));\n    if(bfs(x1,y1,x2,y2))cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = {-1,0,1,0}; const int dy[] = {0,1,0,-1};\n\nconst int MAX_W = 52;\nconst int MAX_H = 52;\n\nchar fieldL[MAX_H][MAX_W];\nchar fieldR[MAX_H][MAX_W];\n\nint main() {\n\tint w, h;\n\twhile(cin >> w >> h, w|h){\n\t\tfill_n((char *)fieldL, MAX_W * MAX_H, '#');\n\t\tfill_n((char *)fieldR, MAX_W * MAX_H, '#');\n\n\t\tpii ls, rs, lg, rg;\n\t\tREP(y, h){\n\t\t\tchar c;\n\t\t\tREP(x, w){\n\t\t\t\tcin >> c;\n\t\t\t\tswitch(c){\n\t\t\t\tcase '%':\n\t\t\t\t\tc = '.';\n\t\t\t\t\tlg.first = x + 1;\n\t\t\t\t\tlg.second = y + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\tc = '.';\n\t\t\t\t\tls.first = x + 1;\n\t\t\t\t\tls.second = x + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfieldL[y + 1][x + 1] = c;\n\t\t\t}\n\t\t\tREP(x, w){\n\t\t\t\tcin >> c;\n\t\t\t\tswitch(c){\n\t\t\t\tcase '%':\n\t\t\t\t\tc = '.';\n\t\t\t\t\trg.first = x + 1;\n\t\t\t\t\trg.second = y + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tc = '.';\n\t\t\t\t\trs.first = x + 1;\n\t\t\t\t\trs.second = y + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfieldR[y + 1][x + 1] = c;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tLOG(\"------\\n\");\n\t\tREP(y, h + 2){\n\t\t\tREP(x, w + 2){\n\t\t\t\tLOG(\"%c\", fieldL[y][x]);\n\t\t\t}\n\t\t\tLOG(\"\\n\");\n\t\t}\n\t\tLOG(\"------\\n\");\n\t\tREP(y, h + 2){\n\t\t\tREP(x, w + 2){\n\t\t\t\tLOG(\"%c\", fieldR[y][x]);\n\t\t\t}\n\t\t\tLOG(\"\\n\");\n\t\t}\n\t\tLOG(\"------\\n\");\n\t\t*/\n\n//\t\tLOG(\"%d %d ,, %d %d\\n\", ls.first, ls.second , rs.first, rs.second);\n\n\t\tset<pair<pii, pii>> G;\n\t\tqueue<pair<pii, pii>> que;\n\t\tque.push({ls, rs});\n\t\tbool res = false;\n\t\twhile(!que.empty()){\n\t\t\tpii L = que.front().first;\n\t\t\tpii R = que.front().second;\n\t\t\tque.pop();\n\n//\t\t\tLOG(\"%d %d |||| %d %d\\n\", L.first, L.second , R.first, R.second);\n\n\t\t\tif(L == lg){\n\t\t\t\tif(R == rg){\n\t\t\t\t\tres = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}else if(R == rg) continue;\n\n\t\t\tREP(i, 4){\n\t\t\t\tpii nextL = {L.first + dx[i], L.second + dy[i]};\n\t\t\t\tpii nextR = {R.first - dx[i], R.second + dy[i]};\n\t\t\t\tif(fieldL[nextL.second][nextL.first] == '#'){\n\t\t\t\t\tnextL = L;\n\t\t\t\t}\n\t\t\t\tif(fieldR[nextR.second][nextR.first] == '#'){\n\t\t\t\t\tnextR = R;\n\t\t\t\t}\n\t\t\t\tpair<pii, pii> next = {nextL, nextR};\n\n//\t\t\t\tLOG(\"%c %c   %d %d  <<<--- %d %d\\n\", fieldL[nextL.second][nextL.first],fieldR[nextR.second][nextR.first], nextR.first, nextR.second, R.first, R.second);\n\t\t\t\tif(G.insert(next).second)\n\t\t\t\t\tque.push({nextL, nextR});\n\t\t\t}\n\t\t}\n\n\t\tcout << (res ? \"Yes\" : \"No\") << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\nint const dxL[] = {-1,0,1,0};\nint const dxR[] = {1,0,-1,0};\nint const dy[]  = {0,-1,0,1};\ntypedef pair<int, int> Pii;\n#define X first\n#define Y second\nint const INF = 1<<28;\nint W, H;\nchar grL[51][51], grR[51][51];\nint dist[255][255];\ninline bool inF(int x, int y, int isL) {\n  if(0<=x&&x<W && 0<=y&&y<H) {\n    if(isL) return grL[y][x]!='#';\n    else return grR[y][x]!='#';\n  }\n  return false;\n}\ninline int toNode(int x, int y) {\n  return y*W+x;\n}\ninline void toPos(int node, int &x, int &y) {\n  x = node%W, y = node/W;\n}\nint main() {\n  \n  while(cin >> W >> H && (W|H)) {\n    int sxL, syL, sxR, syR;\n    int gxL, gyL, gxR, gyR;\n    for(int i=0; i<H; i++) {\n      for(int j=0; j<2*W; j++) {\n        if(j<W) {\n          cin >> grL[i][j];\n          if(grL[i][j] == 'L') {\n            sxL = j, syL = i;\n          }\n          if(grL[i][j] == '%') {\n            gxL = j, gyL = i;\n          }\n        }\n        else {\n          cin >> grR[i][j-W];\n          if(grR[i][j-W] == 'R') {\n            sxR = j-W, syR = i;\n          }\n          if(grR[i][j-W] == '%') {\n            gxR = j-W, gyR = i;\n          }\n        }\n      }\n    }\n    \n    queue<int> qCost;\n    queue<int> qL, qR;\n    qL.push(toNode(sxL, syL)); qR.push(toNode(sxR, syR));\n    bool ok = false;\n    fill(dist[0], dist[0]+250*250, INF);\n    dist[toNode(sxL, syL)][toNode(sxR, syR)] = 0;\n    while(!qL.empty()) {\n      int nowL = qL.front(); qL.pop();\n      int nowR = qR.front(); qR.pop();\n      int lx, ly; toPos(nowL, lx, ly);\n      int rx, ry; toPos(nowR, rx, ry);\n      if(lx == gxL && ly == gyL && rx == gxR && ry == gyR) {\n        ok = true; break;\n      }\n      if(lx == gxL && ly == gyL) {\n        continue;\n      }\n      if(rx == gxR && ry == gyR) {\n        continue;\n      }\n      for(int i=0; i<4; i++) {\n        int nxL = lx+dxL[i], nyL = ly+dy[i];\n        int nxR = rx+dxR[i], nyR = ry+dy[i];\n        if(!inF(nxL, nyL, 1) && !inF(nxR, nyR, 0)) continue;\n        if(!inF(nxL, nyL, 1)) { nxL = lx, nyL = ly; }\n        if(!inF(nxR, nyR, 0)) { nxR = rx, nyR = ry; }\n        if(dist[toNode(nxL, nyL)][toNode(nxR, nyR)] != INF) continue;\n        qL.push(toNode(nxL, nyL));\n        qR.push(toNode(nxR, nyR));\n        dist[toNode(nxL, nyL)][toNode(nxR, nyR)] = dist[nowL][nowR]+1;\n      }\n    }\n    if(ok) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define WRAP(x,y,w,h) (0<=x && x<w && 0<=y && y<h)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h, w) {\n\t\tvector<string> cell1(h);\n\t\tvector<string> cell2(h);\n\t\tint slx, sly, srx, sry;\n\t\tint glx, gly, grx, gry;\n\t\tREP(i, h) {\n\t\t\tcin >> cell1[i] >> cell2[i];\n\t\t\tREP(j, w / 2)\n\t\t\t\tswap(cell2[i][j], cell2[i][w - 1 - j]);\n\t\t\tREP(j, w) {\n\t\t\t\tif (cell1[i][j] == 'L') {\n\t\t\t\t\tsly = i;\n\t\t\t\t\tslx = j;\n\t\t\t\t}\n\t\t\t\tif (cell1[i][j] == '%') {\n\t\t\t\t\tgly = i;\n\t\t\t\t\tglx = j;\n\t\t\t\t}\n\t\t\t\tif (cell2[i][j] == 'R') {\n\t\t\t\t\tsry = i;\n\t\t\t\t\tsrx = j;\n\t\t\t\t}\n\t\t\t\tif (cell2[i][j] == '%') {\n\t\t\t\t\tgry = i;\n\t\t\t\t\tgrx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tset<pair<pii, pii>> G;\n\t\tG.insert({ {sly,slx},{sry,srx} });\n\t\tqueue<pair<pii, pii>> Q;\n\t\tQ.push({ { sly,slx },{ sry,srx } });\n\t\tset<pair<pii, pii>> G2;\n\t\tG2.insert({ { gly,glx },{ gry,grx } });\n\t\tqueue<pair<pii, pii>> Q2;\n\t\tQ2.push({ { gly,glx },{ sry,grx } });\n\t\tstring clear = \"No\";\n\t\twhile (!Q.empty() && !Q2.empty()) {\n\t\t\tREP(j, 2) {\n\t\t\t\tpair<pii, pii> q;\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tq = Q.front();Q.pop();\n\t\t\t\t}\n\t\t\t\tif (j == 1) {\n\t\t\t\t\tq = Q2.front();Q2.pop();\n\t\t\t\t}\n\t\t\t\tif ((j == 0 && G2.find(q) != G2.end()) || (j == 1 && G.find(q) != G.end())) {\n\t\t\t\t\tclear = \"Yes\";\n\t\t\t\t\tgoto ANS;\n\t\t\t\t}\n\t\t\t\tREP(i, 4) {\n\t\t\t\t\tint nly = q.first.first + dy[i];\n\t\t\t\t\tint nlx = q.first.second + dx[i];\n\t\t\t\t\tint nry = q.second.first + dy[i];\n\t\t\t\t\tint nrx = q.second.second + dx[i];\n\t\t\t\t\tif (!WRAP(nlx, nly, w, h) || cell1[nly][nlx] == '#') {\n\t\t\t\t\t\tnly = q.first.first;\n\t\t\t\t\t\tnlx = q.first.second;\n\t\t\t\t\t}\n\t\t\t\t\tif (!WRAP(nrx, nry, w, h) || cell2[nry][nrx] == '#') {\n\t\t\t\t\t\tnry = q.second.first;\n\t\t\t\t\t\tnrx = q.second.second;\n\t\t\t\t\t}\n\t\t\t\t\tbool b1 = (nly == gly&&nlx == glx);\n\t\t\t\t\tbool b2 = (nry == gry&&nrx == grx);\n\t\t\t\t\tif (b1 != b2)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (j == 0) {\n\t\t\t\t\t\tif (G.find({ {nly,nlx},{nry,nrx} }) == G.end()) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tG.insert({ { nly,nlx }, { nry,nrx } });\n\t\t\t\t\t\t\tQ.push({ { nly,nlx },{ nry,nrx } });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (G2.find({ { nly,nlx },{ nry,nrx } }) == G2.end()) {\n\t\t\t\t\t\t\tG2.insert({ { nly,nlx },{ nry,nrx } });\n\t\t\t\t\t\t\tQ2.push({ { nly,nlx },{ nry,nrx } });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tANS:\n\t\tcout << clear << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\nconst ld eps=1e-8;\nint d1[4] = { 1,0,-1,0 };\nint d2[4] = { 0,1,0,-1 };\nint d3[4] = { 0,-1,0,1 };\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h, w) {\n\t\tchar fi1[52][52]; char fi2[52][52];\n\t\trep(i, 52) {\n\t\t\trep(j, 52) {\n\t\t\t\tfi1[i][j] = fi2[i][j] = '#';\n\t\t\t}\n\t\t}\n\t\tstring s, t;\n\t\tP s1, s2, g1, g2;\n\t\trep1(i, h) {\n\t\t\tcin >> s >> t;\n\t\t\trep1(j, w) {\n\t\t\t\tfi1[i][j] = s[j - 1];\n\t\t\t\tif (fi1[i][j] == '%') {\n\t\t\t\t\tg1 = { i,j };\n\t\t\t\t}\n\t\t\t\telse if (fi1[i][j] == 'L') {\n\t\t\t\t\ts1 = { i,j };\n\t\t\t\t}\n\t\t\t}\n\t\t\trep1(j, w) {\n\t\t\t\tfi2[i][j] = t[j - 1];\n\t\t\t\tif (fi2[i][j] == '%') {\n\t\t\t\t\tg2 = { i,j };\n\t\t\t\t}\n\t\t\t\telse if (fi2[i][j] == 'R') {\n\t\t\t\t\ts2 = { i,j };\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmap<pair<P, P>, int> used;\n\t\tvector<pair<P, P>> v;\n\t\tbool f = false;\n\t\tv.push_back({ s1, s2 });\n\t\tused[{s1, s2}] = 1;\n\t\twhile (!v.empty()) {\n\t\t\tP n1 = v[0].first; P n2 = v[0].second; v.erase(v.begin());\n\t\t\tif (n1 == g1 && n2 == g2) {\n\t\t\t\tf = true; break;\n\t\t\t}\n\t\t\telse if (n1 == g1 || n2 == g2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trep(i, 4) {\n\t\t\t\tP nex1 = { n1.first + d1[i],n1.second + d2[i] };\n\t\t\t\tP nex2 = { n2.first + d1[i],n2.second + d3[i] };\n\t\t\t\tif (fi1[nex1.first][nex1.second] == '#') {\n\t\t\t\t\tnex1 = n1;\n\t\t\t\t}\n\t\t\t\tif (fi2[nex2.first][nex2.second] == '#') {\n\t\t\t\t\tnex2 = n2;\n\t\t\t\t}\n\t\t\t\tif (used[{nex1, nex2}]!=1) {\n\t\t\t\t\tused[{nex1, nex2}] = 1;\n\t\t\t\t\tv.push_back({ nex1,nex2 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (f) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct XY {\n\tint x, y;\n\tXY() {}\n\tXY(int x, int y) : x(x), y(y) {}\n};\n\nusing P = pair<XY, XY>;\n\nbool operator<(const XY& l, const XY& r) {\n\treturn l.x < r.x || (l.x == r.x && l.y < r.y);\n}\n\nint dx[] = { 1, 0, -1, 0 };\nint dy[] = { 0, 1, 0, -1 };\n\nint W, H;\nbool isIn(const XY& p) {\n\treturn p.x >= 0 && p.x < H && p.y >= 0 && p.y < W;\n}\n\nint main()\n{\n\twhile (cin >> W >> H, W | H) {\n\t\tvector<string> Rl(H), Rr(H);\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tcin >> Rl[i] >> Rr[i];\n\t\t}\n\t\tP s, g;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (Rl[i][j] == 'L') {\n\t\t\t\t\ts.first.x = i;\n\t\t\t\t\ts.first.y = j;\n\t\t\t\t}\n\t\t\t\telse if (Rl[i][j] == '%') {\n\t\t\t\t\tg.first.x = i;\n\t\t\t\t\tg.first.y = j;\n\t\t\t\t}\n\t\t\t\tif (Rr[i][j] == 'R') {\n\t\t\t\t\ts.second.x = i;\n\t\t\t\t\ts.second.y = j;\n\t\t\t\t}\n\t\t\t\telse if (Rr[i][j] == '%') {\n\t\t\t\t\tg.second.x = i;\n\t\t\t\t\tg.second.y = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool flag = true;\n\t\tset<P> se; se.insert(s);\n\t\twhile (flag) {\n\t\t\tflag = false;\n\t\t\tauto tmp = se;\n\t\t\tfor (auto p : tmp) {\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tXY tl = p.first, tr = p.second;\n\t\t\t\t\ttl.x += dx[i]; tl.y -= dy[i]; tr.x += dx[i]; tr.y += dy[i];\n\t\t\t\t\tbool f1 = isIn(tl) && Rl[tl.x][tl.y] != '#';\n\t\t\t\t\tbool f2 = isIn(tr) && Rr[tr.x][tr.y] != '#';\n\t\t\t\t\tif (f1 && f2) {\n\t\t\t\t\t\tif ((Rl[tl.x][tl.y] == '%') && (Rr[tr.x][tr.y] == '%')) {\n\t\t\t\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\t\t\t\tgoto End;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!(Rl[tl.x][tl.y] == '%') && !(Rr[tr.x][tr.y] == '%')) {\n\t\t\t\t\t\t\tif (!se.count(P(tl, tr))) {\n\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\tse.insert(P(tl, tr));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (f1) {\n\t\t\t\t\t\tif ((Rl[tl.x][tl.y] == '%') && (Rr[p.second.x][p.second.y] == '%')) {\n\t\t\t\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\t\t\t\tgoto End;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!(Rl[tl.x][tl.y] == '%') && !(Rr[p.second.x][p.second.y] == '%')) {\n\t\t\t\t\t\t\tif (!se.count(P(tl, p.second))) {\n\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\tse.insert(P(tl, p.second));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (f2) {\n\t\t\t\t\t\tif ((Rl[p.first.x][p.first.y] == '%') && (Rr[tr.x][tr.y] == '%')) {\n\t\t\t\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\t\t\t\tgoto End;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!(Rl[p.first.x][p.first.y] == '%') && !(Rr[tr.x][tr.y] == '%')) {\n\t\t\t\t\t\t\tif (!se.count(P(p.first, tr))) {\n\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\tse.insert(P(p.first, tr));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << \"No\" << endl;\n\tEnd:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\nusing namespace std;\ntypedef pair<char,char> pcc;\nint W, H;\nint dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\npcc s1, s2, g1, g2;\n\nvoid rec(pcc &p1, pcc &p2, map<pair<pcc,pcc>,bool> &memo, vector<string> &R1, vector<string> &R2){\n  for(int i = 0; i < 4; ++i){\n    //int x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;\n    pcc p1_ = p1, p2_ = p2;\n    if(p1_.first + dx[i] < H && p1_.first + dx[i] >= 0 &&\n       p1_.second + dy[i] < W && p1_.second + dy[i] >= 0 &&\n       R1[p1_.first + dx[i]][p1_.second + dy[i]] != '#'){\n      p1_.first += dx[i];\n      p1_.second += dy[i];\n    }\n    if(p2_.first + dx[i] < H && p2_.first + dx[i] >= 0 &&\n       p2_.second - dy[i] < W && p2_.second - dy[i] >= 0 &&\n       R2[p2_.first + dx[i]][p2_.second - dy[i]] != '#'){\n      p2_.first += dx[i];\n      p2_.second -= dy[i];\n    }\n    if(p1_ == g1 || p2_ == g2){\n      memo[make_pair(p1_,p2_)] = true;\n    }else if((!memo[make_pair(g1,g2)]) && (!memo[make_pair(p1_,p2_)])){\n      memo[make_pair(p1_,p2_)] = true;\n      rec(p1_,p2_,memo,R1,R2);\n    }\n  }\n}\n\nint main(){\n  while(cin >> W >> H, W){\n    vector<string> R1(H), R2(H);\n    for(int i = 0; i < H; ++i){\n      cin >> R1[i] >> R2[i];\n      for(int j = 0; j < W; ++j){\n        if(R1[i][j] == 'L'){\n          s1.first = i;\n          s1.second = j;\n        }\n        if(R2[i][j] == 'R'){\n          s2.first = i;\n          s2.second = j;\n        }\n        if(R1[i][j] == '%'){\n          g1.first = i;\n          g1.second = j;\n        }\n        if(R2[i][j] == '%'){\n          g2.first = i;\n          g2.second = j;\n        }\n      }\n    }\n    map<pair<pcc,pcc>,bool> memo;\n    rec(s1,s2,memo,R1,R2);\n    if(memo[make_pair(g1,g2)]) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nstruct Data{int x[2],y[2];};\nData start,goal;\n\nint W,H;\nvector< vector<string> >room(2);\n\nint dx[2][4]={{0,1,0,-1}, {0,-1,0,1}};\nint dy[2][4]={{-1,0,1,0}, {-1,0,1,0}};\nbool operator==(Data a, Data b){\n  return a.x[0]==b.x[0] && a.x[1]==b.x[1] && a.y[0]==b.y[0] && a.y[1]==b.y[1];\n}\nbool over(Data a){\n  return a.x[0]<0 || W<=a.x[0] || a.y[0]<0 || H<=a.y[0] ||\n         a.x[1]<0 || W<=a.x[1] || a.y[1]<0 || H<=a.y[1];\n}\n\nbool bfs()\n{\n  queue<Data>q;\n  q.push(start);\n  bool visited[50][50][50][50]={false};\n\n  while(!q.empty()){\n    Data now=q.front();\n    q.pop();\n\n    visited[now.x[0]][now.y[0]][now.x[1]][now.y[1]]=true;\n\n    if(now==goal)return true;\n    if(now.x[0]==goal.x[0] && now.y[0]==goal.y[0])continue;\n    if(now.x[1]==goal.x[1] && now.y[1]==goal.y[1])continue;\n\n    for(int i=0;i<4;i++){\n      Data next=now;\n      for(int j=0;j<2;j++){\n\tnext.x[j]+=dx[j][i];\n\tnext.y[j]+=dy[j][i];\n\tif(over(next)){\n\t  next.x[j]=now.x[j];\n\t  next.y[j]=now.y[j];\n\t}\n\tif(room[j][next.y[j]][next.x[j]]=='#'){\n\t  next.x[j]=now.x[j];\n\t  next.y[j]=now.y[j];\n\t}\n      }\n      if(visited[next.x[0]][next.y[0]][next.x[1]][next.y[1]])continue;\n      q.push(next);\n    }\n  }\n\n  return false;\n}\n\nint main()\n{\n  while(cin>>W>>H,W|H){\n    room[0].resize(H);\n    room[1].resize(H);\n    for(int i=0;i<H;i++){\n      cin>>room[0][i]>>room[1][i];\n      for(int j=0;j<W;j++){\n\tif(room[0][i][j]=='L'){\n\t  start.x[0]=j;\n\t  start.y[0]=i;\n\t}\n\tif(room[1][i][j]=='R'){\n\t  start.x[1]=j;\n\t  start.y[1]=i;\n\t}\n\tif(room[0][i][j]=='%'){\n\t  goal.x[0]=j;\n\t  goal.y[0]=i;\n\t}\n\tif(room[1][i][j]=='%'){\n\t  goal.x[1]=j;\n\t  goal.y[1]=i;\n\t}\n      }\n    }\n\n    puts(bfs()?\"Yes\":\"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint w, h;\nchar l[52][52], r[52][52];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint lsx, lsy, rsx, rsy, lgx, lgy, rgx, rgy;\nbool ischecked[52][52][52][52];\n\nbool solve(int lx, int ly, int rx, int ry){\n    // cout << lx << \" \" << ly << \" \" << rx << \" \" << ry << endl;\n    // ischecked[lx][ly][rx][ry] = true;\n    // if(lx == lgx && ly == lgy && rx == rgx && ry == rgy) return true;\n    // if((lx == lgx && ly == lgy) || (rx == rgx && ry == rgy)) return false;\n    queue<int> rxqu, ryqu, lxqu, lyqu;\n    rxqu.push(rx);\n    ryqu.push(ry);\n    lxqu.push(lx);\n    lyqu.push(ly);\n    while(!rxqu.empty()){\n        lx = lxqu.front();\n        ly = lyqu.front();\n        rx = rxqu.front();\n        ry = ryqu.front();\n        lxqu.pop();\n        lyqu.pop();\n        rxqu.pop();\n        ryqu.pop();\n        if(lx == lgx && ly == lgy && rx == rgx && ry == rgy) return true;\n        if(ischecked[lx][ly][rx][ry]) continue;\n        ischecked[lx][ly][rx][ry] = true;\n        if((lx == lgx && ly == lgy) || (rx == rgx && ry == rgy)) continue;\n        for(int i = 0; i < 4; i++){\n            int nlx = lx + dx[i], nly = ly + dy[i];\n            int nrx = rx + dx[i], nry = ry - dy[i];\n            if(nlx < 0 || nlx >= h || nly < 0 || nly >= w){\n                nlx = lx;\n                nly = ly;\n            }\n            if(nrx < 0 || nrx >= h || nry < 0 || nry >= w){\n                nrx = rx;\n                nry = ry;\n            }\n            if(l[nlx][nly] == '#'){\n                nlx = lx;\n                nly = ly;\n            }\n            if(r[nrx][nry] == '#'){\n                nrx = rx;\n                nry = ry;\n            }\n            if((nrx == rx && nry == ry && nlx == lx && nly == ly)|| ischecked[nlx][nly][nrx][nry]) continue;\n            rxqu.push(nrx);\n            ryqu.push(nry);\n            lxqu.push(nlx);\n            lyqu.push(nly);\n            // ischecked[nlx][nly][nrx][nry] = false;\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    while(1){\n        cin >> w >> h;\n        if(w == 0 && h == 0) break;\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin >> l[i][j];\n            }\n            for(int j = 0; j < w; j++){\n                cin >> r[i][j];\n            }\n        }\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                for(int k = 0; k < h; k++){\n                    for(int l = 0; l < w; l++){\n                        ischecked[i][j][k][l] = false;\n                    }\n                }\n                if(l[i][j] == 'L'){\n                    lsx = i;\n                    lsy = j;\n                }\n                if(l[i][j] == '%'){\n                    lgx = i;\n                    lgy = j;\n                }\n                if(r[i][j] == 'R'){\n                    rsx = i;\n                    rsy = j;\n                }\n                if(r[i][j] == '%'){\n                    rgx = i;\n                    rgy = j;\n                }\n            }\n        }\n        // ischecked[lsx][lsy][rsx][rsy] = true;\n        if(solve(lsx, lsy, rsx, rsy)) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <tuple>\nusing namespace std;\n\nbool visited[51][51][51][51];\nint h, w;\nvector<string> L(50), R(50);\npair<int,int> gl, gr;\n\nbool in_range(int a, int b){\n  return a >= 0 && a < b;\n}\n\nconst int dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\n\nvoid rec(pair<int,int> &l, pair<int,int> &r){\n  stack<pair<pair<int,int>,pair<int,int>>> st;\n  st.emplace(l,r);\n  while(st.size()){\n    tie(l,r) = st.top();\n    st.pop();\n    for(int i = 0; i < 4; ++i){\n      pair<int,int> l_ = l, r_ = r;\n      l_.first += dx[i], l_.second += dy[i];\n      r_.first += dx[i], r_.second -= dy[i];\n\n      if(!(in_range(l_.first,h) and in_range(l_.second,w)))\n        l_ = l;\n      if(!(in_range(r_.first,h) and in_range(r_.second,w)))\n        r_ = r;\n\n      if(L[l_.first][l_.second] == '#') l_ = l;\n      if(R[r_.first][r_.second] == '#') r_ = r;\n\n      if(visited[l_.first][l_.second][r_.first][r_.second]) continue;\n      visited[l_.first][l_.second][r_.first][r_.second] = true;\n      if(gl == l_ or gr == r_) continue;\n      if(visited[gl.first][gl.second][gr.first][gr.second]) return;\n      // rec(l_,r_);\n      st.emplace(l_,r_);\n    }\n  }\n}\n\nint main(){\n  while(cin >> w >> h, h&&w){\n    for(int i = 0; i < h; ++i){\n      for(int j = 0; j < w; ++j){\n        for(int k = 0; k < h; ++k){\n          for(int l = 0; l < w; ++l){\n            visited[i][j][k][l] = false;\n          }\n        }\n      }\n    }\n    for(int i = 0; i < h; ++i) cin >> L[i] >> R[i];\n    pair<int,int> sl, sr;\n    for(int i = 0; i < h; ++i){\n      for(int j = 0; j < w; ++j){\n        if(L[i][j] == '%') gl = {i,j};\n        if(R[i][j] == '%') gr = {i,j};\n        if(L[i][j] == 'L') sl = {i,j};\n        if(R[i][j] == 'R') sr = {i,j};\n      }\n    }\n    // cerr << sl.first << \" \" << sl.second << \" \" << sr.first << \" \" << sr.second << endl;\n    // cerr << gl.first << \" \" << gl.second << \" \" << gr.first << \" \" << gr.second << endl;\n    visited[sl.first][sl.second][sr.first][sr.second] = true;\n    rec(sl,sr);\n    if(visited[gl.first][gl.second][gr.first][gr.second]){\n      puts(\"Yes\");\n    }else{\n      puts(\"No\");\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\ntypedef pair<P,P> PP;\nll h,w;\nvector<string> s,t;\nll slx,sly,srx,sry;\nll glx,gly,grx,gry;\nbool used[51][51][51][51];\n\nll dy[] = {0,1,0,-1};\nll dx[] = {1,0,-1,0};\n\nbool in(int y,int x){\n    return y >= 0 && y < h && x >= 0 && x < w;\n}\n\nbool solve(){\n    queue<PP> que;\n    que.push(PP(P(sly,slx),P(sry,srx)));\n    used[sly][slx][sry][srx] = 1;\n    while(!que.empty()){\n        PP p = que.front();\n        que.pop();\n        ll cly = p.first.first;\n        ll clx = p.first.second;\n        ll cry = p.second.first;\n        ll crx = p.second.second;\n        // cout << cly << \" \" << clx << \" \" << cry << \" \" << crx << endl;\n        rep(i,4){\n            ll nly = cly + dy[i];\n            ll nlx = clx + dx[i];\n            ll nry = cry + dy[i];\n            ll nrx = crx + dx[i];\n            if(!in(nly,nlx) || s[nly][nlx] == '#'){\n                nlx = clx; nly = cly;\n            }\n            if(!in(nry,nrx) || t[nry][nrx] == '#'){\n                nrx = crx; nry = cry;\n            }\n            if(nry == gry && nrx == grx && nly == gly && nlx == glx)return true;\n            if(nry == gry && nrx == grx)continue;\n            if(nly == gly && nlx == glx)continue;\n            if(used[nly][nlx][nry][nrx])continue;\n            PP tmp = PP(P(nly,nlx),P(nry,nrx));\n            used[nly][nlx][nry][nrx] = 1;\n            que.push(tmp);\n        }\n    }\n    return false;\n}\n\nint main(){\n    while(cin >> w >> h && w){\n        s.clear();\n        t.clear();\n        rep(i,51)rep(j,51)rep(k,51)rep(l,51)used[i][j][k][l] = 0;\n        s.resize(h);\n        t.resize(h);\n        rep(i,h){\n            cin >> s[i] >> t[i];\n            reverse(ALL(t[i]));\n            // cout << s[i] << \" \" << t[i] << endl;\n            rep(j,w){\n                if(s[i][j] == 'L'){\n                    slx = j,sly = i;\n                }\n                if(s[i][j] == '%'){\n                    glx = j,gly = i;\n                }\n                if(t[i][j] == 'R'){\n                    srx = j,sry = i;\n                }\n                if(t[i][j] == '%'){\n                    grx = j,gry = i;\n                }\n            }\n        }\n        if(solve())cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// tsukasa_diary's programing contest code template\n#include <bits/stdc++.h>\nusing namespace std;\n// define\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n// typedef\ntypedef long long lint;\ntypedef double Double;\ntypedef pair<int, int> pii;\n//\ntypedef vector< int > Array;\ntypedef vector< Array > Matrix;\ntypedef vector< Double > DArray;\ntypedef vector< DArray > DMatrix;\ntypedef vector< string > SArray;\ntypedef vector< pii > PArray;\n// popcount\ninline int POPCNT(int _x) { return __builtin_popcount(_x); }\ninline int POPCNT(lint _x) { return __builtin_popcountll(_x); }\n// inf\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\n// eps\nDouble EPS = 1e-9;\n// in range\ninline bool in_range(int _v, int _mx, int _mi) { return _mi <= _v && _v < _mx; }\ninline bool in_range(Double _v, Double _mi, Double _mx) { return -EPS < _v - _mi && _v - _mx < EPS; }\ninline bool in_range(int _x, int _y, int _W, int _H) { return 0 <= _x && _x < _W && 0 <= _y && _y < _H; }\n// neighbor clockwise\nconst int DX[4] = {0,1,0,-1}, DY[4] = {-1,0,1,0};\nconst int DX_[8] = {0,1,1,1,0,-1,-1,-1}, DY_[8] = {-1,-1,0,1,1,1,0,-1};\n\nstruct State {\n\tint lx, ly, rx, ry;\n\tState(int _lx, int _ly, int _rx, int _ry) : lx(_lx), ly(_ly), rx(_rx), ry(_ry) {}\n};\n\nint W, H;\nint srx, sry, slx, sly;\nstring roomL[55], roomR[55];\n\nbool visit[55][55][55][55];\n\nvoid solve() {\n\tminit(visit, 0);\n\t\n\tbool flag = false;\n\t\n\tqueue< State > q;\n\tq.push(State(slx, sly, srx, sry));\n\t\n\twhile (!q.empty()) {\n\t\tState s = q.front(); q.pop();\n\t\tint lx = s.lx, ly = s.ly, rx = s.rx, ry = s.ry;\n\t\t\n\t\tif (visit[ly][lx][ry][rx]) continue;\n\t\tvisit[ly][lx][ry][rx] = true;\n\t\tif (roomL[ly][lx] == '%' && roomR[ry][rx] == '%') {\n\t\t\tflag = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor_(d,0,4) {\n\t\t\tint nlx = lx + DX[d], nly = ly + DY[d];\n\t\t\tint nrx = rx, nry = ry;\n\t\t\tif (d != 0 && d != 2) nrx += DX[(d + 2) % 4], nry += DY[(d + 2) % 4];\n\t\t\telse nrx += DX[d], nry += DY[d];\n\t\n\t\t\tif (!in_range(nlx, nly, W, H)) {\n\t\t\t\tnlx = lx;\n\t\t\t\tnly = ly;\n\t\t\t} else if (roomL[nly][nlx] == '#') {\n\t\t\t\tnlx = lx;\n\t\t\t\tnly = ly;\n\t\t\t}\n\t\t\t\n\t\t\tif (!in_range(nrx, nry, W, H)) {\n\t\t\t\tnrx = rx;\n\t\t\t\tnry = ry;\n\t\t\t} else if (roomR[nry][nrx] == '#') {\n\t\t\t\tnrx = rx;\n\t\t\t\tnry = ry;\n\t\t\t}\n\n\t\t\tq.push(State(nlx, nly, nrx, nry));\n\t\t}\n\t}\n\t\n\tif (flag) {\n\t\tcout << \"Yes\" << endl;\n\t} else {\n\t\tcout << \"No\" << endl;\n\t}\n}\n\nint main() {\n\twhile (cin >> W >> H, W) {\n\t\tfor_(i,0,H) {\n\t\t\tcin >> roomL[i] >> roomR[i];\n\t\t\tfor_(j,0,W) {\n\t\t\t\tif (roomL[i][j] == 'L') slx = j, sly = i;\n\t\t\t\tif (roomR[i][j] == 'R') srx = j, sry = i;\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<sstream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<climits>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = j; i < k; i++)\n#define P pair<int, int>\n#define PP pair<P, P>\nconst int INF = INT_MAX / 2;\nconst int MAX_H = 51;\nconst int MAX_W = 51;\n\nbool closed[MAX_H][MAX_W][MAX_H][MAX_W];\n\nbool canMove(int y, int x, vector< vector<char> > m){\n    if(m[y][x] == '#') return false;\n    else return true;\n}\n\nint main(){\n    int w, h;\n    while(cin >>w >>h && (w || h) ){\n\n        int srx, sry, slx, sly;\n        int grx, gry, glx, gly;\n        vector< vector<char> > l_map(h + 2, vector<char>(w + 2, '*') ), r_map(h + 2, vector<char>(w + 2, '*') );\n\n        //start of input\n        REP(i, l_map.size()){\n            l_map[i][0] = '#';\n            r_map[i][0] = '#';\n            l_map[i][w + 1] = '#';\n            r_map[i][w + 1] = '#';\n        }\n        REP(i, l_map[0].size()){\n            l_map[0][i] = '#';\n            r_map[0][i] = '#';\n            l_map[h + 1][i] = '#';\n            r_map[h + 1][i] = '#';\n        }\n\n        FOR(i, 1, h + 1){\n            FOR(j, 1, w + 1){\n                cin >>l_map[i][j];\n                if(l_map[i][j] == 'L'){\n                    sly = i;\n                    slx = j;\n                }\n                if(l_map[i][j] == '%'){\n                    gly = i;\n                    glx = j;\n                }\n            }\n            FOR(j, 1, w + 1){\n                cin >>r_map[i][j];\n                if(r_map[i][j] == 'R'){\n                    sry = i;\n                    srx = j;\n                }\n                if(r_map[i][j] == '%'){\n                    gry = i;\n                    grx = j;\n                }\n            }\n        }\n        //end of input\n\n        priority_queue<PP, vector<PP>, greater<PP> > open;\n        open.push( PP( P(sry, srx), P(sly, slx) ) );\n        memset(closed, false, sizeof(closed));\n\n        bool ans = false;\n        int my[] = {0, 0, 1, -1};\n        int mx[] = {1, -1, 0, 0};\n\n        while(!open.empty()){\n            PP now = open.top();\n            open.pop();\n            int ry = now.first.first, rx = now.first.second, ly = now.second.first, lx = now.second.second;\n\n            if(ry == gry && rx == grx && ly == gly && lx == glx){\n                ans = true;\n                break;\n            }\n            closed[ry][rx][ly][lx] = true;\n\n            REP(i, 4){\n                int n_ry = ry + my[i];\n                int n_rx = rx + mx[i];\n                int n_ly = ly + my[i];\n                int n_lx = lx + (mx[i] * -1);\n\n                if(!canMove(n_ry, n_rx, r_map) && !canMove(n_ly, n_lx, l_map)){\n                    continue;\n                } else if(!canMove(n_ry, n_rx, r_map)){\n                    n_ry = ry;\n                    n_rx = rx;\n                }\n                else if(!canMove(n_ly, n_lx, l_map)){\n                    n_ly = ly;\n                    n_lx = lx;\n                }\n                if(closed[n_ry][n_rx][n_ly][n_lx]) continue;\n                open.push( PP( P(n_ry, n_rx), P(n_ly, n_lx) ) );\n            }\n        }\n\n        cout <<((ans)? \"Yes\" : \"No\") <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint w, h;\nstring l[52], r[52];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint lsx, lsy, rsx, rsy, lgx, lgy, rgx, rgy;\nbool ischecked[52][52][52][52];\n\nbool solve(int lx, int ly, int rx, int ry){\n   // cout << lx << \" \" << ly << \" \" << rx << \" \" << ry << endl;\n    ischecked[lx][ly][rx][ry] = true;\n    if(lx == lgx && ly == lgy && rx == rgx && ry == rgy) return true;\n    if((lx == lgx && ly == lgy) || (rx == rgx && ry == rgy)) return false;\n    for(int i = 0; i < 4; i++){\n        int nlx = lx + dx[i], nly = ly + dy[i];\n        int nrx = rx + dx[i], nry = ry - dy[i];\n        if(nlx < 0 || nlx >= h || nly < 0 || nly >= w){\n            nlx = lx;\n            nly = ly;\n        }\n        if(nrx < 0 || nrx >= h || nry < 0 || nry >= w){\n            nrx = rx;\n            nry = ry;\n        }\n        if(l[nlx][nly] == '#'){\n            nlx = lx;\n            nly = ly;\n        }\n        if(r[nrx][nry] == '#'){\n            nrx = rx;\n            nry = ry;\n        }\n        if((nrx == rx && nry == ry && nlx == lx && nly == ly )|| ischecked[nlx][nly][nrx][nry]) continue;\n        if(solve(nlx, nly, nrx, nry)) return true;\n        // ischecked[nlx][nly][nrx][nry] = false;\n    }\n    return false;\n}\n\nint main()\n{\n    while(1){\n        cin >> w >> h;\n        if(w == 0 && h == 0) break;\n        for(int i = 0; i < h; i++){\n            cin >> l[i] >> r[i];\n        }\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                for(int k = 0; k < h; k++){\n                    for(int l = 0; l < w; l++){\n                        ischecked[i][j][k][l] = false;\n                    }\n                }\n                if(l[i][j] == 'L'){\n                    lsx = i;\n                    lsy = j;\n                }\n                if(l[i][j] == '%'){\n                    lgx = i;\n                    lgy = j;\n                }\n                if(r[i][j] == 'R'){\n                    rsx = i;\n                    rsy = j;\n                }\n                if(r[i][j] == '%'){\n                    rgx = i;\n                    rgy = j;\n                }\n            }\n        }\n        // ischecked[lsx][lsy][rsx][rsy] = true;\n        if(solve(lsx, lsy, rsx, rsy)) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<queue>\n#include<string.h>\nusing namespace std;\n#define REP(i, a, n) for(int i=a; i<n; i++)\n\nbool hist[51][51][51][51];\n\nstruct State {\n\tint xL, yL, xR, yR;\n};\n\nint main() {\n\tint w, h;\n\n\tint dx[4] = { 0, 1, 0, -1 }; // ????????????\n\tint dy[4] = { -1, 0, 1, 0 };\n\n\twhile (cin >> w >> h, w || h) {\n\t\tState st;\n\t\tchar Len[51][51];\n\t\tchar Rin[51][51];\n\t\t//bool hist[51][51][51][51] = { false };\n\t\t//hist[51][51][51][51] = { false };\n\t\tmemset(hist, false, sizeof hist);\n\n\t\t/* crate maze */\n\t\tREP(i, 0, h) {\n\t\t\tREP(j, 0, w) {\n\t\t\t\tcin >> Len[i][j];\n\t\t\t\tif (Len[i][j] == 'L') {\n\t\t\t\t\tst.yL = i;\n\t\t\t\t\tst.xL = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(j, 0, w) {\n\t\t\t\tcin >> Rin[i][j];\n\t\t\t\tif (Rin[i][j] == 'R') {\n\t\t\t\t\tst.yR = i;\n\t\t\t\t\tst.xR = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* BFS */\n\t\tqueue<State> qu;\n\t\tqu.push(st);\n\t\thist[st.yL][st.xL][st.yR][st.xR] = true;\n\t\t//cout << st.yL << \" \" << st.xL << \" \" << st.yR << \" \" << st.xR << endl;\n\t\tbool flag = false;\n\n\t\twhile (!qu.empty()) {\n\t\t\tState q = qu.front();\n\t\t\tqu.pop();\n\n\t\t\tint yl = q.yL, xl = q.xL, yr = q.yR, xr = q.xR;\n\t\t\tif (Len[yl][xl] == '%' && Rin[yr][xr] == '%') {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (Len[yl][xl] == '%' || Rin[yr][xr] == '%') continue;\n\t\t\tfor (int k = 0; k<4; ++k) {\n\t\t\t\tint yyl = yl + dy[k], xxl = xl + dx[k];\n\t\t\t\tint yyr, xxr;\n\t\t\t\tyyr = yr + dy[k];\n\t\t\t\txxr = xr + dx[k] * (-1);\n\n\t\t\t\tif (yyl<0 || yyl >= h || xxl<0 || xxl >= w) {\n\t\t\t\t\tyyl = yl;\n\t\t\t\t\txxl = xl;\n\t\t\t\t}\n\t\t\t\telse if (Len[yyl][xxl] == '#') {\n\t\t\t\t\tyyl = yl;\n\t\t\t\t\txxl = xl;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (yyr<0 || yyr >= h || xxr<0 || xxr >= w) {\n\t\t\t\t\tyyr = yr;\n\t\t\t\t\txxr = xr;\n\t\t\t\t}\n\t\t\t\telse if (Rin[yyr][xxr] == '#') {\n\t\t\t\t\tyyr = yr;\n\t\t\t\t\txxr = xr;\n\t\t\t\t}\n\t\t\t\tif (hist[yyl][xxl][yyr][xxr]) continue;\n\t\t\t\thist[yyl][xxl][yyr][xxr] = true;\n\t\t\t\tqu.push({ yyl, xxl, yyr, xxr });\n\t\t\t\t//cout << yyl << \" \" << xxl << \" \" << yyr << \" \" << xxr << endl;\n\t\t\t}\n\t\t}\n\t\tif (flag) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t\t/*\n\t\tREP(i, 0, h) {\n\t\t\tREP(j, 0, w) {\n\t\t\t\tcout << Len[i][j];\n\t\t\t}\n\t\t\tcout << \" \";\n\t\t\tREP(j, 0, w) {\n\t\t\t\tcout << Rin[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<cmath>\n#include<utility>\n#include<functional>\n#include<map>\n#include<set>\n#include<cctype>\n\n\n#define FOR(i, a, b) for( int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for( int i=(a);i>=(b);i--)\n#define LFOR(i, a, b) for( long long int i=(a);i<=(b);i++)\n#define LRFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LLINF 1000000000000000000 //9000000000000000000\n#define PI 3.14159265358979\n#define MAXI 7500000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\n\nint dy[4] = { 0,0,1,-1 };\nint dx[4] = { 1,-1,0,0 };\n\n//int dp[50][50][50][50] = {};//ly,lx,ry,rx\n\n\nint main(void) {\n\t\n\twhile (1) {\n\n\t\tint w, h;\n\t\tint lx = -1, ly = -1, rx = -1, ry = -1;\n\t\tint lgx = -1, lgy = -1, rgx = -1, rgy = -1;\n\n\t\tvector< vector< vector< vector<int> > > > dp(50, vector< vector< vector<int > > >(50, vector< vector<int> >(50, vector<int>(50, 0))));\n\t\t\n\n\t\tpair< pair<int, int>, pair<int, int> > Pair;\n\n\t\tqueue<pair< pair<int, int>, pair<int, int > > > que;\n\n\t\tcin >> w >> h;\n\n\t\tif (w == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tvector<string> left(h), right(h);\n\n\t\tFOR(i, 0, h-1) {\n\t\t\tcin >> left[i] >> right[i];\n\t\t}\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (left[i][j] == 'L') {\n\t\t\t\t\tlx = j;\n\t\t\t\t\tly = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (right[i][j] == 'R') {\n\t\t\t\t\trx = j;\n\t\t\t\t\try = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (left[i][j] == '%') {\n\t\t\t\t\tlgx = j;\n\t\t\t\t\tlgy = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lgx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (right[i][j] == '%') {\n\t\t\t\t\trgx = j;\n\t\t\t\t\trgy = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rgx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdp[ly][lx][ry][rx] = 1;\n\n\t\t\n\t\t\n\t\tque.push(make_pair(make_pair(ly,lx),make_pair(ry,rx)));\n\n\n\t\twhile (!que.empty()) {\n\t\t\tPair = que.front();\n\t\t\t\n\t\t\tque.pop();\n\t\t\tly = Pair.first.first;\n\t\t\tlx = Pair.first.second;\n\t\t\try = Pair.second.first;\n\t\t\trx = Pair.second.second;\n\t\t\t//cout << ly << \" \" << lx << \" \" << ry << \" \" << rx << endl;\n\n\t\t\tFOR(i, 0, 3) {\n\t\t\t\t\n\t\t\t\tif (ly + dy[i] >= 0 && lx - dx[i] >= 0 && ry + dy[i] <= h - 1 && rx + dx[i] <= w - 1 && ly + dy[i] <= h - 1 && lx - dx[i] <= w - 1 && ry + dy[i] >= 0 && rx + dx[i] >= 0) {\n\t\t\t\t\tif (dp[ly + dy[i]][lx - dx[i]][ry + dy[i]][rx + dx[i]] != 1) {\n\t\t\t\t\t\tif (left[ly + dy[i]][lx - dx[i]] == '#') {\n\t\t\t\t\t\t\tif (right[ry + dy[i]][rx + dx[i]] == '#') {\n\t\t\t\t\t\t\t\t//no\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdp[ly][lx][ry + dy[i]][rx + dx[i]] = 1;\n\t\t\t\t\t\t\t\tque.push(make_pair(make_pair(ly, lx), make_pair(ry + dy[i], rx + dx[i])));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (right[ry + dy[i]][rx + dx[i]] == '#') {\n\t\t\t\t\t\t\t\tdp[ly + dy[i]][lx - dx[i]][ry][rx] = 1;\n\t\t\t\t\t\t\t\tque.push(make_pair(make_pair(ly + dy[i], lx - dx[i]), make_pair(ry, rx)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdp[ly + dy[i]][lx - dx[i]][ry + dy[i]][rx + dx[i]] = 1;\n\t\t\t\t\t\t\t\tque.push(make_pair(make_pair(ly + dy[i], lx - dx[i]), make_pair(ry + dy[i], rx + dx[i])));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (dp[lgy][lgx][rgy][rgx] == 1) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t\t\n\n\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#define N 50\n#define y1 first.first\n#define x1 first.second\n#define y2 second.first\n#define x2 second.second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\n\nvoid bfs();\n\nint w,h,sy1,sx1,sy2,sx2,gy1,gx1,gy2,gx2,ans;\nstring r1[N],r2[N];\nset<P1> visited;\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(!w&&!h) break;\n    for(int i=0;i<h;i++) cin>>r1[i]>>r2[i];\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(r1[i][j]=='L') sy1=i,sx1=j;\n\tif(r1[i][j]=='%') gy1=i,gx1=j;\n\tif(r2[i][j]=='R') sy2=i,sx2=j;\n\tif(r2[i][j]=='%') gy2=i,gx2=j;\n      }\n    ans=0;\n    bfs();\n    if(ans) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n  return 0;\n}\n\nvoid bfs(){\n  int dy[4]={0,-1,0,1},dx[4]={-1,0,1,0};\n  queue<P1> q;\n  P1 k=make_pair(make_pair(sy1,sx1),make_pair(sy2,sx2));\n  q.push(k);\n  visited.insert(k);\n  while(!q.empty()){\n    P1 t=q.front(); q.pop();\n    for(int i=0;i<4;i++){\n      int ny1=t.y1+dy[i],nx1=t.x1+dx[i];\n      int ny2=t.y2-dy[i],nx2=t.y2-dx[i];\n      if(ny1<0) ny1=0;\n      if(nx1<0) nx1=0;\n      if(h<=ny1) ny1=h;\n      if(w<=nx1) nx1=w;\n      if(ny2<0) ny2=0;\n      if(nx2<0) nx2=0;\n      if(h<=ny2) ny2=h;\n      if(w<=nx2) nx2=w;\n      if(r1[ny1][nx1]=='#') ny1=t.y1,nx1=t.x1;\n      if(r2[ny2][nx2]=='#') ny2=t.y2,nx2=t.x2;\n      P1 u=make_pair(make_pair(ny1,nx1),make_pair(ny2,nx2));\n      if(visited.find(u)!=visited.end()) continue;\n      visited.insert(u);\n      if(ny1==gy1&&nx1==gx1&&ny2==gy2&&nx2==gx2){\n\tans=1;\n\tbreak;\n      }\n    }\n    if(ans) break;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int MAX = 52;\nconst int ldy[4] = { 0,1,0,-1 };\nconst int ldx[4] = { 1,0,-1,0 };\nconst int rdy[4] = { 0,1,0,-1 };\nconst int rdx[4] = { -1,0,1,0 };\n\nchar l_grid[MAX][MAX];\nint l_visited[MAX][MAX];\nchar r_grid[MAX][MAX];\nint r_visited[MAX][MAX];\nbool goal;\n\nvoid dfs(int ly, int lx, int ry, int rx, int deep)\n{\n\tif (goal == true) {\n\n\t}\n\telse if (l_grid[ly][lx] == '%'&&r_grid[ry][rx] == '%') {\n\t\tgoal = true;\n\t}\n\telse if (l_grid[ly][lx] == '%' || r_grid[ry][rx] == '%') {\n\n\t}\n\telse {\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nly, nlx, nry, nrx;\n\t\t\tif (l_grid[ly + ldy[i]][lx + ldx[i]] == '#') {\n\t\t\t\tnly = ly;\n\t\t\t\tnlx = lx;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnly = ly + ldy[i];\n\t\t\t\tnlx = lx + ldx[i];\n\t\t\t}\n\t\t\tif (r_grid[ry + rdy[i]][rx + rdx[i]] == '#') {\n\t\t\t\tnry = ry;\n\t\t\t\tnrx = rx;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnry = ry + rdy[i];\n\t\t\t\tnrx = rx + rdx[i];\n\t\t\t}\n\n\t\t\tif (nly == ly&&nlx == lx&&nry == ry&&nrx == rx) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (l_visited[nly][nlx] != -1 && r_visited[nry][nrx] != -1 && l_visited[nly][nlx] == r_visited[nry][nrx]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tl_visited[ly][lx] = deep + 1;\n\t\t\tr_visited[ry][rx] = deep + 1;\n\n\t\t\tdfs(nly, nlx, nry, nrx, deep + 1);\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (true) {\n\t\tint W, H;\n\t\tcin >> W >> H;\n\n\t\tif (W == 0 && H == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tgoal = false;\n\n\t\tfor (int i = 0; i < MAX; i++) {\n\t\t\tfor (int j = 0; j < MAX; j++) {\n\t\t\t\tl_grid[i][j] = '#';\n\t\t\t\tl_visited[i][j] = -1;\n\t\t\t\tr_grid[i][j] = '#';\n\t\t\t\tr_visited[i][j] = -1;\n\t\t\t}\n\t\t}\n\n\t\tint ly, lx, ry, rx;\n\n\t\tfor (int y = 1; y <= H; y++) {\n\t\t\tfor (int x = 1; x <= W; x++) {\n\t\t\t\tcin >> l_grid[y][x];\n\t\t\t\t\n\t\t\t\tif (l_grid[y][x] == 'L') {\n\t\t\t\t\tly = y;\n\t\t\t\t\tlx = x;\n\t\t\t\t\tl_grid[y][x] = '.';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int x = 1; x <= W; x++) {\n\t\t\t\tcin >> r_grid[y][x];\n\n\t\t\t\tif (r_grid[y][x] == 'R') {\n\t\t\t\t\try = y;\n\t\t\t\t\trx = x;\n\t\t\t\t\tr_grid[y][x] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdfs(ly, lx, ry, rx, 0);\n\n\t\tif (goal == true) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint cases = INF;\n\tREP(_, cases)\n\t{\n\t\tREAD(int, w, h);\n\t\tif (!w) { break; }\n\t\tvector<string> lmap, rmap;\n\t\tlmap.push_back(string(w + 2, '#'));\n\t\trmap.push_back(string(w + 2, '#'));\n\t\tint lx, ly, rx, ry, Lx, Ly, Rx, Ry;\n\t\tREP(_, h)\n\t\t{\n\t\t\tREAD(string, ls, rs);\n\t\t\tlmap.push_back(\"#\" + ls + \"#\");\n\t\t\trmap.push_back(\"#\" + rs + \"#\");\n\t\t\t{ int p = ls.find_first_of('L'); if (p != ls.npos) { ly = _ + 1; lx = p + 1; } }\n\t\t\t{ int p = rs.find_first_of('R'); if (p != rs.npos) { ry = _ + 1; rx = p + 1; } }\n\t\t\t{ int p = ls.find_first_of('%'); if (p != ls.npos) { Ly = _ + 1; Lx = p + 1; } }\n\t\t\t{ int p = rs.find_first_of('%'); if (p != rs.npos) { Ry = _ + 1; Rx = p + 1; } }\n\t\t}\n\t\tlmap.push_back(string(w + 2, '#'));\n\t\trmap.push_back(string(w + 2, '#'));\n\t\tw += 2; h += 2;\n\n\t\tvevevevector<bool> visited(w, h, w, h);\n\t\tstruct status { int lx, ly, rx, ry, cost, h; };\n\t\tpriority_queue<status, vector<status>, COMPARISON_T(status)> q(COMPARISON(status, a, b, a.cost > b.cost));\n\t\tint result = INF;\n\t\tconst int dy[] = { 1, -1, 0, 0 }, dxl[] = { 0, 0, -1, 1 }, dxr[] = { 0, 0, 1, -1 };\n\t\tq.push({ lx, ly, rx, ry, 0, 0 });\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tstatus s = q.top(); q.pop();\n\t\t\tif (visited[s.lx][s.ly][s.rx][s.ry]) continue;\n\t\t\tvisited[s.lx][s.ly][s.rx][s.ry] = true;\n\t\t\tbool lok = s.lx == Lx && s.ly == Ly;\n\t\t\tbool rok = s.rx == Rx && s.ry == Ry;\n\n\t\t\tif (lok || rok) { if (lok && rok) { result = s.cost; break; } continue; }\n\t\t\t\n\t\t\tREP(i, 4)\n\t\t\t{\n\t\t\t\tint nlx = s.lx + dxl[i];\n\t\t\t\tint nly = s.ly + dy[i];\n\t\t\t\tint nrx = s.rx + dxr[i];\n\t\t\t\tint nry = s.ry + dy[i];\n\t\t\t\tif (lmap[nly][nlx] == '#') { nlx = s.lx; nly = s.ly; }\n\t\t\t\tif (rmap[nry][nrx] == '#') { nrx = s.rx; nry = s.ry; }\n\t\t\t\tq.push({ nlx, nly, nrx, nry, s.cost + 1, 0 });\n\t\t\t}\n\t\t}\n\t\tWRITE(result != INF ? \"Yes\" : \"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define fi first\n#define se second\n#define mk make_pair\nusing namespace std;\nstring s1[50],s2[50];\nint dx1[]={1,-1,0,0,},dy1[]={0,0,1,-1};\nint dx2[]={-1,1,0,0,},dy2[]={0,0,1,-1};\nint w,h,gx1,gx2,gy1,gy2;\nset<pair<pair<int,int>,pair<int,int> > >s;\nqueue<pair<pair<int,int>,pair<int,int> > >q;\nbool bfs(int x1,int y1,int x2,int y2){\n  queue<int>q;\n  q.push(x1+y1*100+x2*10000+y2*1000000);\n  while(!q.empty()){\n    int p=q.front();q.pop();\n    x1=p%100;y1=p%10000/100;\n    x2=p%1000000/10000;y2=p/1000000;\n    for(int i=0;i<4;i++){\n      int x3=x1+dx1[i],y3=y1+dy1[i];\n      int x4=x2+dx2[i],y4=y2+dy2[i];\n      if(x3>=0&&x4>=0&&y3>=0&&y4>=0)\n        if(x3<w&&x4<w&&y3<h&&y4<h){\n          if(s1[y3][x3]=='#')y3=y1,x3=x1;\n          if(s2[y4][x4]=='#')y4=y2,x4=x2;\n          if(x1==gx1&&y1==gy1&&x2==gx2&&y2==gy2)return 1;\n          if(!(x3==gx1&&y3==gy1&&(x4!=gx2||y4!=gy2)))\n          if(!((x3!=gx1||y3!=gy1)&&x4==gx2&&y4==gy2))\n          if(!s.count(mk(mk(x3,y3),mk(x4,y4)))){\n            s.insert(mk(mk(x3,y3),mk(x4,y4)));\n            q.push(x3+y3*100+x4*10000+y4*1000000);\n          }\n        }\n      }\n    }\n    return 0;\n}\nbool dfs(int x1,int y1,int x2,int y2,int d){\n  //cout<<d<<endl;cout<<1;\n    if(x1==gx1&&y1==gy1&&(x2!=gx2||y2!=gy2))return 0;\n    if((x1!=gx1||y1!=gy1)&&x2==gx2&&y2==gy2)return 0;\n    if(x1==gx1&&y1==gy1&&x2==gx2&&y2==gy2)return 1;\n    if(d<8000)for(int i=0;i<4;i++){\n    int x3=x1+dx1[i],y3=y1+dy1[i];\n    int x4=x2+dx2[i],y4=y2+dy2[i];\n    if(x3<0)x3=x1;if(x4<0)x4=x2;\n    if(y3<0)y3=y1;if(y4<0)y4=y2;\n    if(x3>=w)x3=x1;if(x4>=w)x4=x2;\n    if(y3>=h)y3=y1;if(y4>=h)y4=y2;\n        if(s1[y3][x3]=='#')y3=y1,x3=x1;\n        if(s2[y4][x4]=='#')y4=y2,x4=x2;\n        if(!s.count(mk(mk(x3,y3),mk(x4,y4)))){\n          s.insert(mk(mk(x3,y3),mk(x4,y4)));\n          if(dfs(x3,y3,x4,y4,d+1))return 1;\n        }\n    }\n    else q.push(mk(mk(x1,y1),mk(x2,y2)));\n    if(q.size()){\n        pair<pair<int,int>,pair<int,int> >pp=q.front();q.pop();\n        if(bfs(pp.fi.fi,pp.fi.se,pp.se.fi,pp.se.se))return 1;\n    }\n    return 0;\n}\nint main(){\n  int x1,y1,x2,y2;\n  while(cin>>w>>h,w){\n    s.clear();\n    r(i,h)cin>>s1[i]>>s2[i];\n    r(i,h)r(j,w){\n      if(s1[i][j]=='L')x1=j,y1=i;\n      if(s2[i][j]=='R')x2=j,y2=i;\n      if(s1[i][j]=='%')gx1=j,gy1=i;\n      if(s2[i][j]=='%')gx2=j,gy2=i;\n    }\n    s.insert(mk(mk(x1,y1),mk(x2,y2)));\n    if(dfs(x1,y1,x2,y2,0))cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n    while(!q.empty())q.pop();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint dx1[] = {0,1,0,-1};\nint dy1[] = {-1,0,1,0};\nint dx2[] = {0,-1,0,1};\nint dy2[] = {-1,0,1,0};\n\nbool visited[50][50][50][50];\n\nint w, h;\nchar ba1[50][50];\nchar ba2[50][50];\n\nbool rec(int x1,int y1, int x2, int y2) {\n  // printf(\"(%d,%d),(%d,%d)\\n\",x1,y1,x2,y2);\n  visited[x1][y1][x2][y2] = 1;\n\n  if (ba1[x1][y1] == '%' && ba2[x2][y2] == '%')\n    return 1;\n  else if (ba1[x1][y1] == '%' || ba2[x2][y2] == '%')\n    return 0;\n  REP(i,4) {\n    int xx1 = x1+dx1[i];\n    int yy1 = y1+dy1[i];\n    int xx2 = x2+dx2[i];\n    int yy2 = y2+dy2[i];\n\n    if (xx1<0||xx1>=w||yy1<0||yy1>=h || ba1[xx1][yy1] == '#') {\n      xx1 = x1;\n      yy1 = y1;\n    }\n    if (xx2<0||xx2>=w||yy2<0||yy2>=h || ba2[xx2][yy2] == '#') {\n      xx2 = x2;\n      yy2 = y2;\n    }\n    if (!visited[xx1][yy1][xx2][yy2]) {\n      if (rec(xx1,yy1,xx2,yy2))\n        return 1;\n    }\n  }\n  return 0;\n}\n\nint main() {\n  while(cin >> w>>h, w||h) {\n\n    int sx1,sy1,sx2,sy2;\n    REP(y,h) {\n      REP(x,w) {\n        cin >> ba1[x][y];\n        \n        if (ba1[x][y]=='L') {\n          sx1 = x; sy1 = y;\n        }\n      }\n      REP(x,w) {\n        cin >> ba2[x][y];\n        if (ba2[x][y]=='R') {\n          sx2 = x; sy2 = y;\n        }\n      }\n    }\n    if (rec(sx1,sy1,sx2,sy2))\n      cout << \"Yes\" << endl;\n    else\n      cout << \"No\" << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> stat;\n\nint w, h;\nbool vis[51][51][51][51];\npii ls, lg, rs, rg;\nstat start, goal;\n\nint dx[]={0, 0, 1, -1}, dy[]={1, -1, 0, 0};\n\ninline bool border(pii p){\n\treturn 0<=p.first&&p.first<w&&0<=p.second&&p.second<h;\n}\n\nstring solve(vector<string> left, vector<string> right){\n\t\n\tstart = make_pair(ls, rs);\n\tgoal = make_pair(lg, rg);\n\t\n\tqueue<stat> qu;\n\tqu.push(start);\n\t\n\tmemset(vis, 0, sizeof(vis));\n\tvis[ls.first][ls.second][rs.first][rs.second] = true;\n\t\n\twhile(!qu.empty()){\n\t\n\t\tpii lnx, rnx, lnw, rnw;\n\t\t\n\t\tstat now = qu.front();\n\t\tlnw = now.first;\n\t\trnw = now.second;\n\t\t\n\t\tqu.pop();\n\t\t\n\t\tfor(int i=0; i<4; ++i){\n\t\t\t\t\n\t\t\tlnx = make_pair(lnw.first + dx[i], \n\t\t\t\t\t\t\tlnw.second + dy[i]);\n\t\t\t\n\t\t\trnx = make_pair(rnw.first - dx[i], \n\t\t\t\t\t\t\trnw.second + dy[i]);\n\t\t\t\n\t\t\tif(!border(lnx)||left[lnx.second][lnx.first]=='#')\n\t\t\t\tlnx = lnw;\n\t\t\t\n\t\t\tif(!border(rnx)||right[rnx.second][rnx.first]=='#')\n\t\t\t\trnx = rnw;\n\t\t\t\n\t\t\tstat nx = make_pair(lnx, rnx);\n\t\t\t\n\t\t\tif(nx == now)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tif(nx == goal)\n\t\t\t\treturn \"Yes\";\n\t\t\t\n\t\t\tif(!vis[lnx.first][lnx.second][rnx.first][rnx.second]){\n\t\t\t\t\n\t\t\t\tvis[lnx.first][lnx.second][rnx.first][rnx.second] = true;\n\t\t\t\tqu.push(nx);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn \"No\";\n}\n\t\nint main(){\n\t\n\twhile(cin>>w>>h, (w||h)){\n\t\t\n\t\tvector<string> left, right;\n\t\t\n\t\tfor(int i=0; i<h; ++i){\n\t\t\t\n\t\t\tstring l, r;\n\t\t\tcin >> l >> r;\n\t\t\t\n\t\t\tleft.push_back(l);\n\t\t\tright.push_back(r);\n\t\t}\n\t\t\n\t\tfor(int y=0; y<h; ++y){\n\t\t\tfor(int x=0; x<w; ++x){\n\t\t\t\n\t\t\t\tif(left[y][x] == 'L')\n\t\t\t\t\tls = make_pair(x, y);\n\t\t\t\tif(left[y][x] == '%')\n\t\t\t\t\tlg = make_pair(x, y);\n\t\t\t\tif(right[y][x] == 'R')\n\t\t\t\t\trs = make_pair(x, y);\n\t\t\t\tif(right[y][x] == '%')\n\t\t\t\t\trg = make_pair(x, y);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout <<\tsolve(left, right) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\n\nstruct Edge{int to,from,cost;};\n\n#define debug cout\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define SS stringstream\n#define X second\n#define Y first\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,-1,1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,-1,1,0};\n\nint used[50][50][50][50],w,h;\nstring l[50],r[50];\nint v[100000][4],vi;\n\nint main() {\n\tIL{\n\t\tcin>>w>>h;\n\t\tif(w==0&&h==0)break;\n\t\trep(i,h){\n\t\t\tcin>>l[i]>>r[i];\n\t\t}\n\t\tvint start(4);\n\t\tvint goal(4);\n\t\trep(i,h)rep(j,w){\n\t\t\tif(l[i][j]=='L'){\n\t\t\t\tstart[0]=i;\n\t\t\t\tstart[1]=j;\n\t\t\t}\n\t\t\tif(r[i][j]=='R'){\n\t\t\t\tstart[2]=i;\n\t\t\t\tstart[3]=j;\n\t\t\t}\n\t\t\tif(l[i][j]=='%'){\n\t\t\t\tgoal[0]=i;\n\t\t\t\tgoal[1]=j;\n\t\t\t}\n\t\t\tif(r[i][j]=='%'){\n\t\t\t\tgoal[2]=i;\n\t\t\t\tgoal[3]=j;\n\t\t\t}\n\t\t}\n\t\tvi=0;\n\t\tv[0][0]=start[0];\n\t\tv[0][1]=start[1];\n\t\tv[0][2]=start[2];\n\t\tv[0][3]=start[3];\n\t\tmemset(used,0,sizeof(used));\n\t\tused[start[0]][start[1]][start[2]][start[3]]=1;\n\t\twhile(vi>=0){\n\t\t\tint now[4];\n\t\t\trep(i,4)now[i]=v[vi][i];\n\t\t\t--vi;\n//debug<<vi<<\" \"<<now[0]<<\" \"<<now[1]<<\" \"<<now[2]<<\" \"<<now[3]<<endl;\n\t\t\trep(i,4){\n\t\t\t\tint next[4];\n\t\t\t\tnext[0]=now[0]+dy[i];\n\t\t\t\tnext[1]=now[1]+dx[i];\n\t\t\t\tnext[2]=now[2]+dy[i];\n\t\t\t\tnext[3]=now[3]-dx[i];\n//debug<<vi<<\" \"<<now[0]<<\" \"<<now[1]<<\" \"<<now[2]<<\" \"<<now[3]<<endl;\n//debug<<vi<<\" \"<<next[0]<<\" \"<<next[1]<<\" \"<<next[2]<<\" \"<<next[3]<<endl;\n\t\t\t\tif(next[0]<0||h<=next[0]||l[next[0]][now[1]]=='#')next[0]=now[0];\n\t\t\t\tif(next[1]<0||w<=next[1]||l[now[0]][next[1]]=='#')next[1]=now[1];\n\t\t\t\tif(next[2]<0||h<=next[2]||r[next[2]][now[3]]=='#')next[2]=now[2];\n\t\t\t\tif(next[3]<0||w<=next[3]||r[now[2]][next[3]]=='#')next[3]=now[3];\n//debug<<vi<<\" \"<<next[0]<<\" \"<<next[1]<<\" \"<<next[2]<<\" \"<<next[3]<<endl;\n\t\t\t\tif(used[next[0]][next[1]][next[2]][next[3]]==1)continue;\n\t\t\t\tused[next[0]][next[1]][next[2]][next[3]]=1;\n\t\t\t\tif(l[next[0]][next[1]]=='%')continue;\n\t\t\t\tif(r[next[2]][next[3]]=='%')continue;\n\t\t\t\t++vi;\n\t\t\t\trep(j,4)v[vi][j]=next[j];\n//debug<<vi<<\" \"<<next[0]<<\" \"<<next[1]<<\" \"<<next[2]<<\" \"<<next[3]<<endl;\n\t\t\t}\n//debug<<endl;\n\t\t}\n\t\tif(used[goal[0]][goal[1]][goal[2]][goal[3]])cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nconst int kMax_N = 51;\nchar fieldL[kMax_N + 1][kMax_N + 1];\nchar fieldR[kMax_N + 1][kMax_N + 1];\nbool checked[kMax_N + 1][kMax_N + 1][kMax_N + 1][kMax_N + 1];\n\nint w, h;\n\nbool dfs(int ly, int lx, int ry, int rx) {\n  if (fieldL[ly][lx] == fieldR[ry][rx] && fieldL[ly][lx] == '%') {\n    return true;\n  }\n  if (checked[ly][lx][ry][rx]) {\n    return false;\n  }\n  \n  checked[ly][lx][ry][rx] = true;\n\n  int dyL[] = { -1, 0, 1, 0 };\n  int dxL[] = { 0, 1, 0, -1 };\n  int dyR[] = { -1, 0, 1, 0 };\n  int dxR[] = { 0, -1, 0, 1 };\n\n\n  bool ret = false;\n  for (int i = 0; i < 4; i++) {\n    int nly = ly + dyL[i];\n    int nlx = lx + dxL[i];\n    int nry = ry + dyR[i];\n    int nrx = rx + dxR[i];\n    if (nly < 0) nly = 0;\n    if (nly >= h) nly = h - 1;\n    if (nlx < 0) nlx = 0;\n    if (nlx >= w) nlx = w - 1;\n    if (nry < 0) nry = 0;\n    if (nry >= h) nry = h - 1;\n    if (nrx < 0) nrx = 0;\n    if (nrx >= w) nrx = w - 1;\n    if (fieldL[nly][nlx] == '#') {\n      nly = ly; nlx = lx;\n    }\n    if (fieldR[nry][nrx] == '#') {\n      nry = ry; nrx = rx;\n    }\n    ret |= dfs(nly, nlx, nry, nrx);\n  }\n\n  return ret;\n}\n\nint main() {\n  while (true) {\n    cin >> w >> h;\n    if (w + h == 0) {\n      break;\n    }\n    int ly, lx, ry, rx;\n    for (int i = 0; i < h; i++) {\n      string strL, strR;\n      cin >> strL >> strR;\n      for (int j = 0; j < w; j++) {\n        fieldL[i][j] = strL[j];\n        fieldR[i][j] = strR[j];\n        if (strL[j] == 'L') {\n          ly = i; lx = j;\n        }\n        if (strR[j] == 'R') {\n          ry = i; rx = j;\n        }\n      }\n    }\n\n    memset(checked, false, sizeof(checked));\n\n    if (dfs(ly, lx, ry, rx)) {\n      cout << \"Yes\" << endl;\n    } else {\n      cout << \"No\" << endl;\n    }\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<char,char> P;\n\nstruct state{\n\tP p1, p2;\n\tstate(P p1_, P p2_){ p1 = p1_; p2 = p2_; }\n};\nint w, h;\nint dx1[4] = {0,-1,1,0};\nint dy1[4] = {-1,0,0,1};\nint dx2[4] = {0,1,-1,0};\nint dy2[4] = {-1,0,0,1};\nbool flag[51][51][51][51];\nchar L[51][51];\nchar R[51][51];\n\nvoid init(){\n\tfor(int i=0 ; i < 51 ; i++ ){\n\t\tfor(int j=0 ; j < 51 ; j++ ){\n\t\t\tfor(int k=0 ; k < 51 ; k++ ){\n\t\t\t\tfor(int l=0 ; l < 51 ; l++ ){\n\t\t\t\t\tflag[i][j][k][l] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// デバッグ用\nvoid debug(){\n\tcout << \"[Left]\" << endl;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tcout << L[y][x];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n\tcout << \"[right]\" << endl;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tcout << R[y][x];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// R[y][x] == 'R' となる (x,y) を返す\nP R_search(){\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( R[y][x] == 'R' ){\n\t\t\t\tR[y][x] = '.';\n\t\t\t\treturn P(x,y);\n\t\t\t}\n\t\t}\n\t}\n\treturn P(0,0);\n}\n\n// L[y][x] == 'L' となる (x,y) を返す\nP L_search(){\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( L[y][x] == 'L' ){\n\t\t\t\tL[y][x] = '.';\n\t\t\t\treturn P(x,y);\n\t\t\t}\n\t\t}\n\t}\n\treturn P(0,0);\n}\n\nbool bfs(){\n\tP ls = L_search();\n\tP rs = R_search();\n\t\n\tqueue< pair<P,P> > q;\n\tpair<P,P> s( ls , rs );\n\tq.push( s );\n\t\n\twhile( !q.empty() ){\n\t\tpair<P,P> now = q.front(); q.pop();\n\t\tint x1 = now.first.first;\n\t\tint y1 = now.first.second;\n\t\tint x2 = now.second.first;\n\t\tint y2 = now.second.second;\n\t\tflag[y1][x1][y2][x2] = true;\n\t\tif( L[y1][x1] == '%' && R[y2][x2] == '%' ){\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\tint mx1 = x1 + dx1[i];\n\t\t\tint my1 = y1 + dy1[i];\n\t\t\tif( mx1 < 0 || my1 < 0 || mx1 >= w || my1 >= h || L[my1][mx1] == '#' ){\n\t\t\t\tmx1 = x1;\n\t\t\t\tmy1 = y1;\n\t\t\t}\n\t\t\tint mx2 = x2 + dx2[i];\n\t\t\tint my2 = y2 + dy2[i];\n\t\t\tif( mx2 < 0 || my2 < 0 || mx2 >= w || my2 >= h || R[my2][mx2] == '#' ){\n\t\t\t\tmx2 = x2;\n\t\t\t\tmy2 = y2;\n\t\t\t}\n\t\t\tP p1(mx1,my1);\n\t\t\tP p2(mx2,my2);\n\t\t\tpair<P,P> next(p1,p2);\n\t\t\tif( flag[my1][mx1][my2][mx2] ){\n\t\t\t\tcontinue;\n\t\t\t}else if( L[my1][mx1] == '%' && R[my2][mx2] != '%' ){\n\t\t\t\tflag[my1][mx1][my2][mx2] = true;\n\t\t\t}else if( L[my1][mx1] != '%' && R[my2][mx2] == '%' ){\n\t\t\t\tflag[my1][mx1][my2][mx2] = true;\n\t\t\t}else{\n\t\t\t\tq.push( next );\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\twhile( cin >> w >> h, w || h ){\n\t\tinit();\n\t\t\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tstring l, r;\n\t\t\tcin >> l >> r;\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tL[y][x] = l[x];\n\t\t\t\tR[y][x] = r[x];\n\t\t\t}\n\t\t}\n\t\t// debug();\n\t\tbool ans = bfs();\n\t\tif( ans )\n\t\t\tcout << \"Yes\" << endl;\n\t\telse\n\t\t\tcout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair<int,int> P;\nstring l[50];\nstring r[50];\nint w,h;\ndeque<pair<P,P>> q;\nbool used[50][50][50][50];//L,Rの順\nint main()\n{\n\tint dx[4]={1,0,-1,0};\n\tint dy[2][4]={{0,-1,0,1},{0,1,0,-1}};\n\twhile(1)\n\t{\n\t\tcin>>w>>h;\n\t\tif(h==0)\n\t\t\tbreak;\n\t\tfor(int i=0;i<h;i++)\n\t\t\tcin>>l[i]>>r[i];\n\t\tq.clear();\n\t\t//初期位置を突っ込む\n\t\tP p1,p2;\n\t\tfor(int i=0;i<h;i++)\n\t\t{\n\t\t\tfor(int j=0;j<w;j++)\n\t\t\t{\n\t\t\t\tif(l[i][j]=='L')\n\t\t\t\t\tp1=P(i,j);\n\t\t\t\tif(r[i][j]=='R')\n\t\t\t\t\tp2=P(i,j);\n\t\t\t}\n\t\t}\n\t\tfill(used[0][0][0],used[50][0][0],false);\n\t\tq.push_back(make_pair(p1,p2));\n\t\tused[p1.first][p1.second][p2.first][p2.second]=true;\n\t\t//BFS\n\t\tbool ans=false;\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tauto t=q.back();q.pop_back();\n\t\t\tp1=t.first; p2=t.second;\n\t\t\tif(l[p1.first][p1.second]=='%' && r[p2.first][p2.second]=='%')\n\t\t\t{\n\t\t\t\tans=true;\n\t\t\t\tbreak;\n\t\t\t}else if(l[p1.first][p1.second]=='%' || r[p2.first][p2.second]=='%'){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//上下左右探す\n\t\t\tfor(int i=0;i<4;i++)\n\t\t\t{\n\t\t\t\tint nx[2]={p1.first+dx[i],p2.first+dx[i]};\n\t\t\t\tint ny[2]={p1.second+dy[0][i],p2.second+dy[1][i]};\n\t\t\t\t//壁あるいは進行不可能なものは補正する\n\t\t\t\t//進行不能を調べる\n\t\t\t\tfor(int j=0;j<2;j++)\n\t\t\t\t{\n\t\t\t\t\tif(nx[j]<0)\n\t\t\t\t\t\tnx[j]=0;\n\t\t\t\t\telse if(nx[j]>=h)\n\t\t\t\t\t\tnx[j]=h-1;\n\t\t\t\t\tif(ny[j]<0)\n\t\t\t\t\t\tny[j]=0;\n\t\t\t\t\telse if(ny[j]>=w)\n\t\t\t\t\t\tny[j]=w-1;\n\t\t\t\t}\n\t\t\t\t//壁を調べる\n\t\t\t\tif(l[nx[0]][ny[0]]=='#')\n\t\t\t\t{\n\t\t\t\t\tnx[0]-=dx[i];\n\t\t\t\t\tny[0]-=dy[0][i];\n\t\t\t\t}\n\t\t\t\tif(r[nx[1]][ny[1]]=='#')\n\t\t\t\t{\n\t\t\t\t\tnx[1]-=dx[i];\n\t\t\t\t\tny[1]-=dy[1][i];\n\t\t\t\t}\n\t\t\t\tif(!used[nx[0]][ny[0]][nx[1]][ny[1]])\n\t\t\t\t{\n\t\t\t\t\tused[nx[0]][ny[0]][nx[1]][ny[1]]=true;\n\t\t\t\t\tq.push_front(make_pair(P(nx[0],ny[0]),P(nx[1],ny[1])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans)\n\t\t\tcout<<\"Yes\"<<endl;\n\t\telse\n\t\t\tcout<<\"No\"<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <numeric>\n#include <utility>\n#include <iterator>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <ctime>\n#include <cassert>\n\n#define INF 1000000000\n#define LINF 9000000000000000000\n#define mod 1000000007\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define REP(i,a,b) for(int i=(a);i<int(b);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<long long>vll;\ntypedef pair<int,int> pi;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint ddx[8]={-1,-1,0,1,1,1,0,-1};\nint ddy[8]={0,1,1,1,0,-1,-1,-1};\nbool debug=false;\n\n/*---------------------------------------------------*/\n\nint w,h;\nchar l_maze[55][55],r_maze[55][55];\n\nvoid D(){\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cout<<l_maze[i][j];\n    }\n    cout<<\"  \";\n    for(int j=0;j<w;j++){\n      cout<<r_maze[i][j];\n    }\n    cout<<endl;\n  }\n  cout<<endl;\n}\n\nvoid init(){\n  for(int i=0;i<55;i++){\n    for(int j=0;j<55;j++){\n      l_maze[i][j]=r_maze[i][j]='#';\n    }\n  }\n}\n\nbool dfs(int lx,int ly,int rx,int ry){\n  //D();\n  if(l_maze[ly][lx]=='%'||r_maze[ry][rx]=='%') return l_maze[ly][lx]==r_maze[ry][rx];\n  for(int i=0;i<4;i++){\n    int _lx=lx+dx[i],_ly=ly+dy[i],_rx=rx+(-dx[i]),_ry=ry+dy[i];\n    if(0<=lx&&0<=ly&&0<=rx&&0<=ry&&(l_maze[ly][lx]!='#'||r_maze[ry][rx]!='#')){\n      if(l_maze[_ly][_lx]=='#'){_lx=lx;_ly=ly;}\n      if(r_maze[_ry][_rx]=='#'){_rx=rx;_ry=ry;}\n      //cout<<lx<<\" \"<<ly<<\" || \"<<rx<<\" \"<<ry<<endl;\n      //cout<<_lx<<\" \"<<_ly<<\" || \"<<_rx<<\" \"<<_ry<<endl;\n      l_maze[ly][lx]=r_maze[ry][rx]='#';\n      if(dfs(_lx,_ly,_rx,_ry))return true;\n      l_maze[ly][lx]=r_maze[ry][rx]='.';\n    }\n  }\n  return false;\n}\n\nvoid solve(){\n  int lx,ly,rx,ry;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin>>l_maze[i][j];\n      if(l_maze[i][j]=='L'){\n\tlx=j;\n\tly=i;\n      }\n    }\n    for(int j=0;j<w;j++){\n      cin>>r_maze[i][j];\n      if(r_maze[i][j]=='R'){\n\trx=j;\n\try=i;\n      }\n    }\n  }\n  cout<<(dfs(lx,ly,rx,ry)?\"Yes\":\"No\")<<endl;\n}\n\nint main(){\n  while(cin>>w>>h){\n    if(w==0&&h==0)break;\n    init();\n    //cout<<\"hoge\"<<endl;\n    solve();\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,s,n) for(int i=s; i<n; i++)\n#define ALL(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nint w, h;\nint rooml[100][100], roomr[100][100];\nbool memo[100][100][100][100];\n\nbool dfs(int xl, int yl, int xr, int yr) {\n\tif( xl<=0 || w+1<=xl || yl<=0 || h+1<=yl || \n\t\txr<=0 || w+1<=xr || yr<=0 || h+1<=yr ) {\n\t\treturn false;\n\t}\n\n\tif( memo[xl][yl][xr][yr] ) {\n\t\treturn false;\n\t}\n\tmemo[xl][yl][xr][yr] = true;\n\tconst int dx[4] = {-1, 0, 1, 0};\n\tconst int dy[4] = {0, 1, 0, -1};\n\tbool f = false;\n\trep(i, 4) {\n\t\tint nxl = xl + dx[i];\n\t\tint nyl = yl + dy[i];\n\t\tint nxr = xr - dx[i];\n\t\tint nyr = yr + dy[i];\n\t\tint nl = rooml[nyl][nxl];\n\t\tint nr = roomr[nyr][nxr];\n\t\tif( nl==2 && nr==2 ) {\n\t\t\tf = true;\n\t\t}\n\t\telse if( nl==1 && nr==1 ) {\n\t\t\tf |= dfs(nxl, nyl, nxr, nyr);\n\t\t}\n\t\telse if( nl==1 && nr==0 ) {\n\t\t\tf |= dfs(nxl, nyl, xr, yr);\n\t\t}\n\t\telse if( nl==0 && nr==1 ) {\n\t\t\tf |= dfs(xl, yl, nxr, nyr);\n\t\t}\n\t}\n\treturn f;\n}\n\nint main() {\n\twhile(cin >> w >> h, w) {\n\t\tmemset(rooml, 0, sizeof(rooml));\n\t\tmemset(roomr, 0, sizeof(roomr));\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tint xl=1, yl=1, xr=1, yr=1;\n\t\trep(y, h) {\n\t\t\tstring sl, sr;\n\t\t\tcin >> sl >> sr;\n\t\t\trep(x, w) {\n\t\t\t\tif(sl[x] == 'L') {\n\t\t\t\t\txl = x+1;\n\t\t\t\t\tyl = y+1;\n\t\t\t\t\trooml[y+1][x+1] = 1;\n\t\t\t\t} else {\n\t\t\t\t\trooml[y+1][x+1] = (sl[x]=='%' ? 2 : (sl[x]=='.' ? 1 : 0));\n\t\t\t\t}\n\t\t\t\tif(sr[x] == 'R') {\n\t\t\t\t\txr = x+1;\n\t\t\t\t\tyr = y+1;\n\t\t\t\t\troomr[y+1][x+1] = 1;\n\t\t\t\t} else {\n\t\t\t\t\troomr[y+1][x+1] = (sr[x]=='%' ? 2 : (sr[x]=='.' ? 1 : 0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( dfs(xl, yl, xr, yr) ) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t} else {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nint main() {\n\tint W, H;\n\twhile (cin >> W >> H, W | H){\n\t\tvector<string> vsl;\n\t\tvector<string> vsr;\n\t\tREP(i, H){\n\t\t\tstring l;\n\t\t\tstring r;\n\t\t\tcin >> l >> r;\n\t\t\tvsl.push_back(l);\n\t\t\tvsr.push_back(r);\n\t\t}\n\t\tint glx;\n\t\tint gly;\n\t\tint grx;\n\t\tint gry;\n\t\tint lx;\n\t\tint ly;\n\t\tint rx;\n\t\tint ry;\n\t\tREP(i, H){\n\t\t\tREP(j, W){\n\t\t\t\tif (vsl[i][j] == 'L'){\n\t\t\t\t\tlx = j;\n\t\t\t\t\tly = i;\n\t\t\t\t}\n\t\t\t\tif (vsr[i][j] == 'R'){\n\t\t\t\t\trx = j;\n\t\t\t\t\try = i;\n\t\t\t\t}\n\t\t\t\tif (vsl[i][j] == '%'){\n\t\t\t\t\tglx = j;\n\t\t\t\t\tgly = i;\n\t\t\t\t}\n\t\t\t\tif (vsr[i][j] == '%'){\n\t\t\t\t\tgrx = j;\n\t\t\t\t\tgry = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<int> vi;\n\t\tvi.push_back(lx * 1000000 + ly * 10000 + rx * 100 + ry);\n\t\tint count = 0;\n\t\tint pcount = 1;\n\t\tbool clear = false;\n\t\twhile(1){\n\t\t\tif (vi[count] == glx * 1000000 + gly * 10000 + grx * 100 + gry){\n\t\t\t\tclear = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint lx2 = vi[count] / 1000000 % 100;\n\t\t\tint ly2 = vi[count] / 10000 % 100;\n\t\t\tint rx2 = vi[count] / 100 % 100;\n\t\t\tint ry2 = vi[count] % 100;\n\t\t\t\n\t\t\tREP(i, 4){\n\t\t\t\tint lx3 = lx2;\n\t\t\t\tint ly3 = ly2;\n\t\t\t\tint rx3 = rx2;\n\t\t\t\tint ry3 = ry2;\n\t\t\t\tif (dx[i] != 0 && lx3 + dx[i] >= 0 && lx3 + dx[i] < W && vsl[ly3 + dy[i]][lx3 + dx[i]] != '#')lx3 += dx[i];\n\t\t\t\tif (dy[i] != 0 && ly3 + dy[i] >= 0 && ly3 + dy[i] < H && vsl[ly3 + dy[i]][lx3 + dx[i]] != '#')ly3 += dy[i];\n\t\t\t\tif (dx[i] != 0 && rx3 - dx[i] >= 0 && rx3 - dx[i] < W && vsr[ry3 + dy[i]][rx3 - dx[i]] != '#')rx3 -= dx[i];\n\t\t\t\tif (dy[i] != 0 && ry3 + dy[i] >= 0 && ry3 + dy[i] < H && vsr[ry3 + dy[i]][rx3 - dx[i]] != '#')ry3 += dy[i];\n\t\t\t\tif (find(vi.begin(), vi.end(), lx3 * 1000000 + ly3 * 10000 + rx3 * 100 + ry3) == vi.end())vi.push_back(lx3 * 1000000 + ly3 * 10000 + rx3 * 100 + ry3);\n\t\t\t}\n\t\t\tif (count+1 == vi.size())break;\n\t\t\tint min = 10001;\n\t\t\tint i2=0;\n\t\t\tFOR(i,count+1,vi.size()){\n\t\t\t\tif (((vi[i] / 1000000 % 100) - glx) + ((vi[i] / 10000 % 100) - gly) + ((vi[i] / 100 % 100) - grx) + ((vi[i] % 100) - gry) < min)min = ((vi[i] / 1000000 % 100) - glx) + ((vi[i] / 10000 % 100) - gly) + ((vi[i] / 100 % 100) - grx) + ((vi[i] % 100) - gry);\n\t\t\t\ti2 = i;\n\t\t\t}\n\t\t\tswap(vi[count+1], vi[i2]);\n\t\t\tcount++;\n\t\t}\n\n\t\tif (clear)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <iomanip>\n#include <queue>\n#include <stack>\n#include <utility>\n#include <algorithm>\n#include <set>\n#include <ctime>\n#include <string>\n#include <functional>\n\nusing namespace std;\n\ntypedef vector<bool> v1;\ntypedef vector<v1> v2;\ntypedef vector<v2> v3;\ntypedef vector<v3> v4;\ntypedef vector<string> vc2;\ntypedef vector<vc2> stage;\ntypedef pair<int,int> pii;\ntypedef pair<pii,pii> p2;\n\nint solve();\n\nbool isOut( int y, int x, int H, int W ) {\n\treturn !( x >= 0 && y >= 0 && x < W && y < H );\n}\n\nint main(void) {\n\t\t\n\twhile(solve()){}\n\n\treturn 0;\n}\n\nint solve() {\n\n\tint W, H;\n\tcin >> W >> H;\n\tif(!(W|H)){ return 0; }\n\n\tv4 memo(H,v3(W,v2(H,v1(W,false))));\n\n\tstage stg( 2, vc2( H ) );\n\n\t//input\n\tfor( int i = 0; i < H; i++ ) {\n\t\tfor( int j = 0; j < 2; j++ ) {\n\t\t\tcin >> stg[j][i];\n\t\t}\n\t}\n\n\tpii start[2];\n\tchar ch[] = {'L','R'};\n\tfor( int i = 0; i < 2; i++ ) {\n\t\tfor( int j = 0; j < H; j++ ) {\n\t\t\tfor( int k = 0; k < W; k++ ) {\n\t\t\t\tif( stg[i][j][k] == ch[i] ) {\n\t\t\t\t\tstart[i].first = j;\n\t\t\t\t\tstart[i].second = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tp2 st(start[0],start[1]);\n\tqueue<p2> q;\n\tq.push(st);\n\n\tint d[4][2] = {{0,1},{1,0},{-1,0},{0,-1}};\n\n\tbool isClear = false;\n\n\twhile( q.empty() == false && isClear == false){\n\n\t\tp2 p = q.front();\n\t\tq.pop();\n\t\tfor( int i = 0; i < 4; i++ ) {\n\n\t\t\tp2 n = p;\n\t\t\tn.first.first += d[i][0];\n\t\t\tn.first.second += d[i][1];\n\t\t\tn.second.first += d[i][0];\n\t\t\tn.second.second -= d[i][1];\n\t\t\t\n\t\t\tif( isOut(n.first.first,n.first.second,H,W) == true ||\n\t\t\t\tstg[0][n.first.first][n.first.second] == '#' ) {\n\t\t\t\t\tn.first = p.first;\n\t\t\t}\n\t\t\tif( isOut(n.second.first,n.second.second,H,W) == true ||\n\t\t\t\tstg[1][n.second.first][n.second.second] == '#' ) {\n\t\t\t\t\tn.second = p.second;\n\t\t\t}\n\n\t\t\tif( memo[n.first.first][n.first.second][n.second.first][n.second.second] == false ) {\n\t\t\t\tmemo[n.first.first][n.first.second][n.second.first][n.second.second] = true;\n\t\t\t\tif( stg[0][n.first.first][n.first.second] == '%' &&\n\t\t\t\t\tstg[1][n.second.first][n.second.second] == '%' ) {\n\t\t\t\t\tisClear = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tq.push(n);\n\t\t\t}\n\n\t\t}\n\n\n\t}\n\n\tif( isClear ) {\n\t\tcout << \"Yes\" << endl;\n\t} else {\n\t\tcout << \"No\" << endl;\n\t}\n\n\treturn 1;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\n\n\nint W,H;\nstring roomL[55],roomR[55];\n\nbool range_check(int y,int x) {\n    if(!(0<=y&&y<H)) return false;\n    if(!(0<=x&&x<W)) return false;\n\n    return true;\n}\n\nbool visited[55][55][55][55];\nbool ok(P len,P rin) {\n    memset(visited,0,sizeof(visited));\n    visited[len.fr][len.sc][rin.fr][rin.sc]=true;\n    queue<PP> que;\n    que.push(PP(len,rin));\n\n    while(que.size()) {\n        PP pp=que.front(); que.pop();\n        P next_len=pp.fr;\n        P next_rin=pp.sc;\n\n        //printf(\"[debug] %d %d %d %d\\n\",next_len.fr,next_len.sc,next_rin.fr,next_rin.sc);\n\n        rep(i,4) {\n            next_len=pp.fr;\n            next_rin=pp.sc;\n\n            if(range_check(next_len.fr+dy[i],next_len.sc+dx[i]) && roomL[next_len.fr+dy[i]][next_len.sc+dx[i]]!='#') {\n                next_len.fr+=dy[i];\n                next_len.sc+=dx[i];\n            }\n            if(range_check(next_rin.fr+dy[i],next_rin.sc-dx[i]) && roomR[next_rin.fr+dy[i]][next_rin.sc-dx[i]]!='#') {\n                next_rin.fr+=dy[i];\n                next_rin.sc-=dx[i];\n            }\n\n\n\n            if((roomL[next_len.fr][next_len.sc]=='%')&&(roomR[next_rin.fr][next_rin.sc]=='%')) return true;\n            if((roomL[next_len.fr][next_len.sc]=='%')||(roomR[next_rin.fr][next_rin.sc]=='%')) continue;\n            if(visited[next_len.fr][next_len.sc][next_rin.fr][next_len.sc]) continue;\n            visited[next_len.fr][next_len.sc][next_rin.fr][next_len.sc]=true;\n            que.push(PP(next_len,next_rin));\n\n        }\n    }\n\n    return false;\n}\n\nvoid solve() {\n    rep(y,55) roomL[y]=roomR[y]=string('#',55);\n    rep(y,H) cin>>roomL[y]>>roomR[y];\n    P len,rin;\n    rep(y,H) rep(x,W) {\n        if(roomL[y][x]=='L') len=P(y,x);\n        if(roomR[y][x]=='R') rin=P(y,x);\n    }\n    if(ok(len,rin)) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n}\n\nint main() {\n    while(cin>>W>>H) {\n        if(!W) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nchar RenR[51][51],LinR[51][51];\nbool memo[51][51][51][51];\nstring ans;\nint h,w;\n//         l r d u\nint Rx[4]={0,0,1,-1};\nint Ry[4]={1,-1,0,0};\n//         r l d u\nint Lx[4]={0,0,1,-1};\nint Ly[4]={-1,1,0,0};\n\n\nvoid move(int muki,int ri,int rj,int li,int lj)\n{\n  //cout<<ri<<\" \"<<rj<<\" \"<<li<<\" \"<<lj<<endl;\n  int ra=ri+Rx[muki],rb=rj+Ry[muki];\n  if(0<=ra && 0<=rb && ra<h && rb<w){\n    if(RenR[ra][rb]!='#'){\n      ri=ra;\n      rj=rb;\n    }\n  }\n  int la=li+Lx[muki],lb=lj+Ly[muki];\n  if(0<=la && 0<=lb && la<h && lb<w){\n    if(LinR[la][lb]!='#'){\n      li=la;\n      lj=lb;\n    }\n  }\n  if(memo[ri][rj][li][lj])return;\n\n  memo[ri][rj][li][lj]=true;\n\n  if(RenR[ri][rj]=='%' && LinR[li][lj]=='%'){\n    ans=\"Yes\";\n    return;\n  }\n  if(RenR[ri][rj]=='%' || LinR[li][lj]=='%')return;\n\n  for(int k=0;k<4;k++){\n    move(k,ri,rj,li,lj);\n    if(ans==\"Yes\")break;\n  }\n  return;\n}\n\nint main()\n{\n  int ri,rj,li,lj;\n  while(1){\n    cin>>w>>h;\n    if(w+h==0)break;\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tfor(int k=0;k<h;k++){\n\t  for(int l=0;l<w;l++)memo[i][j][k][l]=false;\n\t}\n      }\n    }\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>LinR[i][j];\n\tif(LinR[i][j]=='L'){\n\t  li=i;lj=j;\n\t  LinR[i][j]='.';\n\t}\n      }\n      for(int j=0;j<w;j++){\n\tcin>>RenR[i][j];\n\tif(RenR[i][j]=='R'){\n\t  ri=i;rj=j;\n\t  RenR[i][j]='.';\n\t}\n      }\n    }\n    ans=\"No\";\n    memo[ri][rj][li][lj]=true;\n    for(int i=0;i<4;i++){\n      move(i,ri,rj,li,lj);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string.h>\n#include <set>\n#include <queue>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\tint dl[50][50][50][50], h, w, i, j, a, b, c, d, dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\n\tchar rf[50][51], lf[50][51];\n\tP rs, ls, rg, lg;\n\tqueue<P> r, l;\n\twhile(1){\n\t\tscanf(\"%d%d%*c\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tlf[i][j] = getchar();\n\t\t\t\tif(lf[i][j] == 'L'){\n\t\t\t\t\tls = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(lf[i][j] == '%'){\n\t\t\t\t\tlg = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 空白読み飛ばし\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\trf[i][j] = getchar();\n\t\t\t\tif(rf[i][j] == 'R'){\n\t\t\t\t\trs = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(rf[i][j] == '%'){\n\t\t\t\t\trg = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 改行文字読み飛ばし\n\t\t}\n\t\tr.push(rs), l.push(ls);\n\t\tmemset(dl,0,sizeof(dl));\n\t\twhile(r.size()){\n\t\t\ta = l.front().first, b = l.front().second, c = r.front().first, d = r.front().second;\n\t\t\tl.pop(), r.pop();\n\t\t\tdl[a][b][c][d] = 1;\n\t\t\tif(a == lg.first && b == lg.second && c == rg.first && d == rg.second)\n\t\t\t\tbreak;\n\t\t\tif(a == lg.first && b == lg.second || c == rg.first && d == rg.second)\n\t\t\t\tcontinue;\n\t\t\tfor(i = 0;i < 4;i++){\n\t\t\t\tif(a + dy[i] >= 0 && a + dy[i] < h && b + dx[i] >= 0 && b + dx[i] < w && lf[a + dy[i]][b + dx[i]] == '.' && c + dy[i] >= 0 && c + dy[i] < h && d - dx[i] >= 0 && d - dx[i] < w && rf[c + dy[i]][d - dx[i]] == '.' && !dl[a + dy[i]][b + dx[i]][c + dy[i]][d - dx[i]]) // 両方とも動くとき\n\t\t\t\t\tl.push(P(a + dy[i],b + dx[i])), r.push(P(c + dy[i],d - dx[i]));\n\t\t\t\telse if((a + dy[i] < 0 || a + dy[i] >= h || b + dx[i] < 0 || b + dx[i] >= w || lf[a + dy[i]][b + dx[i]] == '#') && c + dy[i] >= 0 && c + dy[i] < h && d - dx[i] >= 0 && d - dx[i] < w && rf[c + dy[i]][d - dx[i]] == '.' && !dl[a][b][c + dy[i]][d - dx[i]]) // Rinだけ動く\n\t\t\t\t\tl.push(P(a,b)), r.push(P(c + dy[i],d - dx[i]));\n\t\t\t\telse if(a + dy[i] >= 0 && a + dy[i] < h && b + dx[i] >= 0 && b + dx[i] < w && lf[a + dy[i]][b + dx[i]] == '.' && (c + dy[i] < 0 || c + dy[i] >= h || d - dx[i] < 0 || d - dx[i] >= w || rf[c + dy[i]][d - dx[i]] == '#') && !dl[a + dy[i]][b + dx[i]][c][d]) // Lenだけ動く\n\t\t\t\t\tl.push(P(a + dy[i],b + dx[i])), r.push(P(c,d));\n\t\t\t}\n\t\t}\n\t\twhile(r.size())\n\t\t\tr.pop(),l.pop();\n\t\tif(dl[lg.first][lg.second][rg.first][rg.second])\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> pii;\nstring R1[50], R2[50];\n//bool memo[50][50][50][50];\nint W, H;\nint dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\n\nvoid rec(pii p1, pii p2, map<pair<pii,pii>,bool> &memo){\n  for(int i = 0; i < 4; ++i){\n    //int x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;\n    pii p1_ = p1, p2_ = p2;\n    if(p1_.first + dx[i] < H && p1_.first + dx[i] >= 0 &&\n       p1_.second + dy[i] < W && p1_.second + dy[i] >= 0 &&\n       R1[p1_.first + dx[i]][p1_.second + dy[i]] != '#'){\n      p1_.first += dx[i];\n      p1_.second += dy[i];\n    }\n    if(p2_.first + dx[i] < H && p2_.first + dx[i] >= 0 &&\n       p2_.second - dy[i] < W && p2_.second - dy[i] >= 0 &&\n       R2[p2_.first + dx[i]][p2_.second - dy[i]] != '#'){\n      p2_.first += dx[i];\n      p2_.second -= dy[i];\n    }\n    if(!memo[make_pair(p1_,p2_)]){\n      memo[make_pair(p1_,p2_)] = true;\n      rec(p1_,p2_,memo);\n    }\n  }\n}\n\nint main(){\n  while(cin >> W >> H, W){\n    pii s1, s2, g1, g2;\n    for(int i = 0; i < H; ++i){\n      cin >> R1[i] >> R2[i];\n      for(int j = 0; j < W; ++j){\n        if(R1[i][j] == 'L'){\n          s1.first = i;\n          s1.second = j;\n        }\n        if(R2[i][j] == 'R'){\n          s2.first = i;\n          s2.second = j;\n        }\n        if(R1[i][j] == '%'){\n          g1.first = i;\n          g1.second = j;\n        }\n        if(R2[i][j] == '%'){\n          g2.first = i;\n          g2.second = j;\n        }\n      }\n    }\n    /*\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n        for(int k = 0; k < H; ++k){\n          for(int l = 0; l< W; ++l){\n            memo[i][j][k][l] = false;\n          }\n        }\n      }\n    }\n    memo[sx1][sy1][sx2][sy2] = true;\n    */\n    map<pair<pii,pii>,bool> memo;\n    rec(s1,s2,memo);\n    //if(memo[gx1][gy1][gx2][gy2]) cout << \"Yes\" << endl;\n    if(memo[make_pair(g1,g2)]) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n\nbool b[103][52][103][52] = {};\n\n\nint main() {\n\n  while( true ) {\n\n    long long int w, h;\n    cin >> w >> h;\n\n    if ( w == 0 ) break;\n\n    vector< string > map;\n\n    map.push_back( \"##############################################################################################################\" );\n\n    long long int rx, ry, lx, ly;\n\n    for ( long long int y = 1; y <= h; y++ ) {\n\n      string in_L, in_R;\n      cin >> in_L >> in_R;\n\n      string in = \"#\" + in_L + \"#\" + in_R + \"#\";\n      map.push_back( in );\n\n      for ( long long int x = 0; x < in.size(); x++ ) {\n\n\tif ( map[y][x] == 'R' ) {\n\t  rx = x;\n\t  ry = y;\n\t}\n\tif ( map[y][x] == 'L' ) {\n\t  lx = x;\n\t  ly = y;\n\t}\n\n      }\n\n    }\n\n    map.push_back( \"##############################################################################################################\" );\n\n\n    for ( long long int y = 0; y < map.size(); y++ ) {\n      for ( long long int x = 0; x < map[0].size(); x++ ) {\n\tfor ( long long int y2 = 0; y2 < map.size(); y2++ ) {\n\t  for ( long long int x2 = 0; x2 < map[0].size(); x2++ ) {\n\t    b[y][x][y2][x2] = false;\n\t  }\n\t}\n      }\n    }\n\n\n    queue< vector< long long int > > q;\n    vector< long long int > v;\n    v.push_back( rx );\n    v.push_back( ry );\n    v.push_back( lx );\n    v.push_back( ly );\n    q.push( v );\n\n    bool ans = true;\n\n    while( q.size() > 0 ) {\n\n      rx = q.front()[0];\n      ry = q.front()[1];\n      lx = q.front()[2];\n      ly = q.front()[3];\n      q.pop();\n\n      if ( b[ ry ][ rx ][ ly ][ lx ] == true ) continue;\n\n      b[ ry ][ rx ][ ly ][ lx ] = true;\n\n\n      if ( map[ry][rx] == '%' && map[ly][lx] == '%' ) {\n\tcout << \"Yes\" << endl;\n\tbreak;\n      }else if ( map[ry][rx] == '%' ) {\n\tans = false;\n\tbreak;\n      }else if ( map[ly][lx] == '%' ) {\n\tans = false;\n\tbreak;\n      }\n\n      //      cout << rx << \" \" << ry << \" \" << lx << \" \" << ly << endl;\n\n\n      v.clear();\n      if ( map[ ry ][ rx + 1 ] == '#' ) {\n\tv.push_back( rx );\n      }else {\n\tv.push_back( rx + 1 );\n      }\n      v.push_back( ry );\n      if ( map[ ly ][ lx - 1 ] == '#' ) {\n\tv.push_back( lx );\n      }else {\n\tv.push_back( lx - 1 );\n      }\n      v.push_back( ly );\n      q.push( v );\n\n      v.clear();\n      v.push_back( rx );\n      if ( map[ ry - 1 ][ rx ] == '#' ) {\n\tv.push_back( ry );\n      }else {\n\tv.push_back( ry - 1 );\n      }\n      v.push_back( lx );\n      if ( map[ ly - 1 ][ lx ] == '#' ) {\n\tv.push_back( ly );\n      }else {\n\tv.push_back( ly - 1 );\n      }\n      q.push( v );\n\n      v.clear();\n      if ( map[ ry ][ rx - 1 ] == '#' ) {\n\tv.push_back( rx );\n      }else {\n\tv.push_back( rx - 1 );\n      }\n      v.push_back( ry );\n      if ( map[ ly ][ lx + 1 ] == '#' ) {\n\tv.push_back( lx );\n      }else {\n\tv.push_back( lx + 1 );\n      }\n      v.push_back( ly );\n      q.push( v );\n\n      v.clear();\n      v.push_back( rx );\n      if ( map[ ry + 1 ][ rx ] == '#' ) {\n\tv.push_back( ry );\n      }else {\n\tv.push_back( ry + 1 );\n      }\n      v.push_back( lx );\n      if ( map[ ly + 1 ][ lx ] == '#' ) {\n\tv.push_back( ly );\n      }else {\n\tv.push_back( ly + 1 );\n      }\n      q.push( v );\n\n    }\n\n    if ( ans == false ) {\n      cout << \"No\" << endl;\n    }\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing psi=pair<string,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define MOD (1e9+7)\nvoid get(){}template<class H,class...T>void get(H&h,T&...t){cin>>h;get(t...);}\ntemplate<class T>void geti(T&a){for(auto&_:a)cin>>_;}\ntemplate<class T>void getii(T&a){for(auto&_:a)geti(_);}\nvoid put(string d){}template<class H,class...T>void put(string d,H&h,T&...t){cout<<h;if(sizeof...(t))cout<<d;put(d,t...);}\ntemplate<class T>void puti(T&a,string d=\" \"){bool f=1;for(auto&_:a)cout<<(exchange(f,0)?\"\":d)<<_;cout<<endl;}\ntemplate<class T>void putii(T&a,string d=\" \"){for(auto&_:a)puti(_,d);}\n#define dcl(...) ll __VA_ARGS__;get(__VA_ARGS__)\n#define dclt(t,...) t __VA_ARGS__;get(__VA_ARGS__)\n \n#define fs first\n#define sc second\n \nint main(){\n    int w,h;\n    while(cin>>w>>h,w){\n        vector<vvi> f(2,vvi(h+2,vi(w+2,1)));\n        pair<pii,pii> curr;\n        pair<pii,pii> stat;\n        for(int i=1;i<=h;i++){\n            rep(p,2){\n                for(int j=1;j<=w;j++){\n                    char c; cin>>c;\n                    if(c=='.'){\n                        f[p][i][j]=0;\n                    }else if(c=='%'){\n                        f[p][i][j]=0;\n                        if(p==0){\n                            stat.first={i,j};\n                        }else{\n                            stat.second={i,w+1-j};\n                        }\n                    }else if(c=='L'){\n                        f[p][i][j]=0;\n                        curr.first={i,j};\n                    }else if(c=='R'){\n                        f[p][i][j]=0;\n                        curr.second={i,w+1-j};\n                    }\n                }\n            }\n            reverse(all(f[1][i]));\n        }\n        //putii(f[0],\"\");\n        //cout<<endl;\n        //putii(f[1],\"\");\n        //cout<<\"=======\"<<endl;\n         \n        /*幅優先\n            ・どちらか片方だけ動き、動いた先がゴールでない場合\n            ・両方動き、かつ少なくともどちらかがそのマスを訪れたことがない場合\n            だけ、探索する\n        */\n        set<pair<pii,pii>> isVisited;\n \n        queue<pair<pii,pii>> que;\n        que.push(curr);\n        int y[]={-1,0,1,0};\n        int x[]={0,1,0,-1};\n        auto step=[f](pii &pos,int lr, int y, int x){\n            if(f[lr][pos.fs+y][pos.sc+x]!=1){\n                pos.fs+=y;\n                pos.sc+=x;\n                return true;\n            }\n            return false;\n        };\n        bool ok=false;\n        while(!que.empty()){\n            auto c=que.front();\n            que.pop();\n            //cout<<c[0][0]<<\",\"<<c[0][1]<<\"  \"<<c[1][0]<<\",\"<<c[1][1]<<endl;\n            if(isVisited.find(c)!=isVisited.end()){\n                continue;\n            }\n            isVisited.insert(c);\n            rep(v,4){\n                auto next=c;\n                bool l=step(next.fs,0,y[v],x[v]);\n                bool r=step(next.sc,1,y[v],x[v]);\n                if(next==stat){\n                    ok=true;\n                    goto fin;\n                }\n \n                if(next.fs!=stat.fs and next.sc!=stat.sc and isVisited.find(next)==isVisited.end()){\n                    if( l or r ){\n                        //cout<<\" o \"<<next[0][0]<<\",\"<<next[0][1]<<\"  \"<<next[1][0]<<\",\"<<next[1][1]<<endl;\n                        que.push(next);\n                    }else{\n                        //cout<<\" x \"<<next[0][0]<<\",\"<<next[0][1]<<\"  \"<<next[1][0]<<\",\"<<next[1][1]<<endl;\n                    }\n                }\n            }\n        }\n        fin:;\n        if(ok){\n            cout<<\"Yes\"<<endl;\n        }else{\n            cout<<\"No\"<<endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing psi=pair<string,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define MOD (1e9+7)\nvoid get(){}template<class H,class...T>void get(H&h,T&...t){cin>>h;get(t...);}\ntemplate<class T>void geti(T&a){for(auto&_:a)cin>>_;}\ntemplate<class T>void getii(T&a){for(auto&_:a)geti(_);}\nvoid put(string d){}template<class H,class...T>void put(string d,H&h,T&...t){cout<<h;if(sizeof...(t))cout<<d;put(d,t...);}\ntemplate<class T>void puti(T&a,string d=\" \"){bool f=1;for(auto&_:a)cout<<(exchange(f,0)?\"\":d)<<_;cout<<endl;}\ntemplate<class T>void putii(T&a,string d=\" \"){for(auto&_:a)puti(_,d);}\n#define dcl(...) ll __VA_ARGS__;get(__VA_ARGS__)\n#define dclt(t,...) t __VA_ARGS__;get(__VA_ARGS__)\n\nint main(){\n\tint w,h;\n\twhile(cin>>w>>h,w){\n\t\tvector<vvi> f(2,vvi(h+2,vi(w+2,1)));\n\t\tvvi curr(2,vi(2));\n\t\tvvi stat(2,vi(2));\n\t\tfor(int i=1;i<=h;i++){\n\t\t\trep(p,2){\n\t\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\t\tchar c; cin>>c;\n\t\t\t\t\tif(c=='.'){\n\t\t\t\t\t\tf[p][i][j]=0;\n\t\t\t\t\t}else if(c=='%'){\n\t\t\t\t\t\tf[p][i][j]=0;\n\t\t\t\t\t\tstat[p]={i,j};\n\t\t\t\t\t}else if(c=='L'){\n\t\t\t\t\t\tf[p][i][j]=0;\n\t\t\t\t\t\tcurr[0]={i,j};\n\t\t\t\t\t}else if(c=='R'){\n\t\t\t\t\t\tf[p][i][j]=0;\n\t\t\t\t\t\tcurr[1]={i,w+1-j};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treverse(all(f[1][i]));\n\t\t}\n\t\tstat[1][1]=w+1-stat[1][1];\n\t\t//putii(f[0],\"\");\n\t\t//cout<<endl;\n\t\t//putii(f[1],\"\");\n\t\t//cout<<\"=======\"<<endl;\n\t\t\n\t\t/*幅優先\n\t\t\t・どちらか片方だけ動き、動いた先がゴールでない場合\n\t\t\t・両方動き、かつ少なくともどちらかがそのマスを訪れたことがない場合\n\t\t\tだけ、探索する\n\t\t*/\n\t\tset<vvi> isVisited;\n\t\t//isVisited.insert(curr);\n\n\t\tqueue<vvi> que;\n\t\tque.push(curr);\n\t\tint y[]={-1,0,1,0};\n\t\tint x[]={0,1,0,-1};\n\t\tauto step=[f](vi &pos,int lr, int y, int x){\n\t\t\tif(f[lr][pos[0]+y][pos[1]+x]!=1){\n\t\t\t\tpos[0]+=y;\n\t\t\t\tpos[1]+=x;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tbool ok=false;\n\t\twhile(!que.empty()){\n\t\t\tauto c=que.front();\n\t\t\tque.pop();\n\t\t\t//cout<<c[0][0]<<\",\"<<c[0][1]<<\"  \"<<c[1][0]<<\",\"<<c[1][1]<<endl;\n\t\t\tif(isVisited.find(c)!=isVisited.end()){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tisVisited.insert(c);\n\t\t\trep(v,4){\n\t\t\t\tauto next=c;\n\t\t\t\tbool l=step(next[0],0,y[v],x[v]);\n\t\t\t\tbool r=step(next[1],1,y[v],x[v]);\n\t\t\t\tif(next==stat){\n\t\t\t\t\tok=true;\n\t\t\t\t\tgoto fin;\n\t\t\t\t}\n\n\t\t\t\tif(isVisited.find(next)==isVisited.end()){\n\t\t\t\t\tif( (!l and r and next[1]!=stat[1])\n\t\t\t\t\t\tor (l and !r and next[0]!=stat[0])\n\t\t\t\t\t\tor ( l and r and !(next[0]!=stat[0] xor next[1]!=stat[1]) )){\n\t\t\t\t\t\t//cout<<\" o \"<<next[0][0]<<\",\"<<next[0][1]<<\"  \"<<next[1][0]<<\",\"<<next[1][1]<<endl;\n\t\t\t\t\t\tque.push(next);\n\t\t\t\t\t}else{\n\t\t\t\t\t\t//cout<<\" x \"<<next[0][0]<<\",\"<<next[0][1]<<\"  \"<<next[1][0]<<\",\"<<next[1][1]<<endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfin:;\n\t\tif(ok){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t}else{\n\t\t\tcout<<\"No\"<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// Header {{{\n// includes {{{\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <unistd.h>\n#include <vector>\n// }}}\nusing namespace std;\n// consts {{{\nstatic const int INF = 1e9;\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n// }}}\n// typedefs {{{\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<ULL> VULL;\ntypedef vector<VULL> VVULL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\ntypedef complex<char> P;\n#define PQ(type) priority_queue<type>\n// priority queue reverse\n#define PQR(type) priority_queue< type, vector<type>, greater<type> >\n// }}}\n// macros & inline functions {{{\n// syntax sugars {{{\n#define FOR(i, b, e) for (typeof(e) i = (b); i < (e); ++i)\n#define FORI(i, b, e) for (typeof(e) i = (b); i <= (e); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(i, n) FORI(i, 0, n)\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n#define ASSIGN_MAX(var, val) ((var) = max((var), (val)))\n#define ASSIGN_MIN(var, val) ((var) = min((var), (val)))\n// }}}\n// conversion {{{\ninline int toInt(string s) { int v; istringstream sin(s); sin>>v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout<<x; return sout.str(); }\n// }}}\n// array and STL {{{\n#define ARRSIZE(a) ( sizeof(a) / sizeof(a[0]) )\n#define ZERO(a, v) ( assert(v == 0 || v == -1), memset(a, v, sizeof(a)) )\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define SIZE(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c, it) for(typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define REACH(c, it) for(typeof((c).rbegin()) it=(c).rbegin(); it!=(c).rend(); ++it)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n// }}}\n// bit manipulation {{{\n// singed integers are not for bitwise operations, specifically arithmetic shifts ('>>', and maybe not good for '<<' too)\n#define IS_UNSIGNED(n) (!numeric_limits<typeof(n)>::is_signed)\n#define BIT(n) (assert(IS_UNSIGNED(n)), assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(IS_UNSIGNED(n)), assert(m < 64), ((ULL)(n) >> (m) & 1))\ninline int BITS_COUNT(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int MSB(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c-1; }\ninline int MAKE_MASK(ULL upper, ULL lower) { assert(lower < 64 && upper < 64 && lower <= upper); return (BIT(upper) - 1) ^ (BIT(lower) - 1); }\n// }}}\n// for readable code {{{\n#define EVEN(n) (n % 2 == 0)\n#define ODD(n) (!EVEN(n))\n// }}}\n// debug {{{\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n#define dprt(fmt, ...) if (opt_debug) { fprintf(stderr, fmt, ##__VA_ARGS__); }\n#define darr(a) if (opt_debug) { copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr_range(a, f, t) if (opt_debug) { copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define dvec(v) if (opt_debug) { copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr2(a) if (opt_debug) { FOR(__i, 0, (arrsz(a))){ darr( (a)[__i] ); } }\n#define WAIT() if (opt_debug) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#define dump(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl; }\n// dump vector elements in [s, e)\n#define dumpv(v, s, e) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #v << \" = \"; FOR(__i, s, e) { cerr << v[__i] << \"\\t\"; } cerr << endl; }\n#define dumpl(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << endl << (x) << endl; }\n#define dumpf() if (opt_debug) { cerr << __PRETTY_FUNCTION__ << endl; }\n#define where() if (opt_debug) { cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl; }\n#define dumpb(bit, digits) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #bit << \" = \"; for(int __i = digits - 1; __i >= 0; __i--) { cerr << static_cast<bool>(bit & (1 << __i)); if (__i % 4 == 0) { cerr << \" \"; } } cerr << endl; }\n\n// ostreams {{{\n// complex\ntemplate<typename T> ostream& operator<<(ostream& s, const complex<T>& d) {return s << \"(\" << d.real() << \", \" << d.imag() << \")\";}\n\n// pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n// vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i]; if (i < len - 1) s << \"\\t\";\n\t}\n\treturn s;\n}\n\n// 2 dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i] << endl;\n\t}\n\treturn s;\n}\n\n// map\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const map<T1, T2>& m) {\n\ts << \"{\" << endl;\n\tfor (typeof(m.begin()) itr = m.begin(); itr != m.end(); ++itr) {\n\t\ts << \"\\t\" << (*itr).first << \" : \" << (*itr).second << endl;\n\t}\n\ts << \"}\" << endl;\n\treturn s;\n}\n// }}}\n// }}}\n// }}}\n// time {{{\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\n// }}}\n// string manipulation {{{\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\ninline string join(VS s, string j) { string t; REP(i, s.size()) { t += s[i] + j; } return t; }\n// }}}\n// geometry {{{\n#define Y real()\n#define X imag()\n// }}}\n// 2 dimentional array {{{\nenum { UP, RIGHT, DOWN, LEFT, UP_RIGHT, DOWN_RIGHT, DOWN_LEFT, UP_LEFT };\nP dydx4[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\nP dydx8[8] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(-1, 1), P(1, 1), P(1, -1), P(-1, -1) };\nbool in_field(int H, int W, P p) {\n\treturn (0 <= p.Y && p.Y < H) && (0 <= p.X && p.X < W);\n}\n// }}}\n// input and output {{{\ninline void input(string filename) {\n\tfreopen(filename.c_str(), \"r\", stdin);\n}\ninline void output(string filename) {\n\tfreopen(filename.c_str(), \"w\", stdout);\n}\n// }}}\n// }}}\n\nbool opt_debug = false;\n\nint main(int argc, char** argv) {\n\tstd::ios_base::sync_with_stdio(false);\n\t// set options {{{\n\tint __c;\n\twhile ( (__c = getopt(argc, argv, \"d\")) != -1 ) {\n\t\tswitch (__c) {\n\t\t\tcase 'd':\n\t\t\t\topt_debug = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tabort();\n\t\t}\n\t}\n\t// }}}\n\n\t// opt_debug = true;\n\t// input(\"./inputs/0.txt\");\n\t// output(\"./outputs/0.txt\");\n\n\tint W, H;\n\twhile (cin >> W >> H, W | H) {\n\t\tVVC room_l(H, VC(W));\n\t\tVVC room_r(H, VC(W));\n\t\tP len, rin;\n\t\tREP (i, H) {\n\t\t\tREP (j, W) {\n\t\t\t\tcin >> room_l[i][j];\n\t\t\t\tif (room_l[i][j] == 'L') {\n\t\t\t\t\tlen = P(i, j);\n\t\t\t\t\troom_l[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP (j, W) {\n\t\t\t\tcin >> room_r[i][j];\n\t\t\t\tif (room_r[i][j] == 'R') {\n\t\t\t\t\trin = P(i, j);\n\t\t\t\t\troom_r[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttypedef pair<P, P> PPP;\n\t\tqueue<PPP> q;\n\t\tq.push(MP(len, rin));\n\t\tP dydx_l[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\n\t\tP dydx_r[4] = { P(-1, 0), P(0, -1), P(1, 0), P(0, 1) };\n\t\ttypedef pair< pair<char, char>, pair<char, char> > PPIIPII;\n\t\tset< PPIIPII > pushed;\n\t\tbool ok = false;\n\t\twhile (!q.empty()) {\n\t\t\tPPP t = q.front(); q.pop();\n\t\t\tPPIIPII key = MP( MP(t.F.Y, t.F.X), MP(t.S.Y, t.S.X) );\n\t\t\tlen = t.F; rin = t.S;\n\t\t\tif (room_l[len.Y][len.X] == '%' && room_r[rin.Y][rin.X] == '%') {\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (room_l[len.Y][len.X] == '%' || room_r[rin.Y][rin.X] == '%') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tREP (d, 4) {\n\t\t\t\tP n_len = len + dydx_l[d];\n\t\t\t\tP n_rin = rin + dydx_r[d];\n\t\t\t\tif (!in_field(H, W, n_len) || room_l[n_len.Y][n_len.X] == '#') {\n\t\t\t\t\tn_len -= dydx_l[d];\n\t\t\t\t}\n\t\t\t\tif (!in_field(H, W, n_rin) || room_r[n_rin.Y][n_rin.X] == '#') {\n\t\t\t\t\tn_rin -= dydx_r[d];\n\t\t\t\t}\n\n\t\t\t\tPPIIPII _key = MP( MP(n_len.Y, n_len.X), MP(n_rin.Y, n_rin.X) );\n\t\t\t\tif (!EXIST(pushed, _key)) {\n\t\t\t\t\tq.push(MP(n_len, n_rin));\n\t\t\t\t\tpushed.insert(_key);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ok) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t} else {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\n#include <stack>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\ntypedef vector<string> vs;\ntypedef vector<int> vi;\n\n#define rep(i,b) loop(i,0,b)\n#define loop(i,a,b) for(int i=(a); i<int(b); i++)\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nint h,w;\ninline bool in(int x, int y){\n    return 0<=x && 0<=y && x<w && y<h;\n}\n\nbool solve(vs const& g1, vs const& g2){\n    int sx1, sy1, sx2, sy2;\n    rep(i,h)rep(j,w){\n        if(g1[i][j]=='L'){\n            sx1=j;sy1=i;\n        }\n        if(g2[i][j]=='R'){\n            sx2=j;sy2=i;\n        }\n    }\n    queue<vi> q;\n    static bool vis[64][64][64][64];\n    memset(vis,0,sizeof(vis));\n    q.push(vi{sx1,sy1,sx2,sy2});\n\n    while(q.size()){\n        vi s=q.front();q.pop();\n        int x1=s[0],y1=s[1],x2=s[2],y2=s[3];\n        if(vis[x1][y1][x2][y2])continue;\n        vis[x1][y1][x2][y2]=true;\n        if(g1[y1][x1]=='%' && g2[y2][x2]=='%') return true;\n        if((g1[y1][x1]=='%')^(g2[y2][x2]=='%')) continue;\n\n        rep(d,4){\n            int nx1=x1+dx[d],ny1=y1+dy[d];\n            int nx2,ny2;\n            if(d&1){\n                nx2=x2+dx[d],ny2=y2+dy[d];\n            }else{\n                nx2=x2-dx[d],ny2=y2-dy[d];\n            }\n            if(!in(nx1,ny1) || g1[ny1][nx1]=='#')nx1=x1,ny1=y1;\n            if(!in(nx2,ny2) || g2[ny2][nx2]=='#')nx2=x2,ny2=y2;\n            q.push(vi{nx1,ny1,nx2,ny2});\n        }\n    }\n    return false;    \n}\n\nint main(){\n    while(cin>>w>>h && w|h){\n        vs g1(h), g2(h);\n        rep(i,h) cin>>g1[i]>>g2[i];\n        vs ans{\"No\",\"Yes\"};\n        cout << ans[solve(g1,g2)] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nbool used[55][55][55][55];\nint n,m;\nstring s[55],t[55];\nint d[]={0,1,0,-1,0};\nmain()\n{\n\twhile(cin>>m>>n,m)\n\t{\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tcin>>s[i]>>t[i];\n\t\t\treverse(t[i].begin(),t[i].end());\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<n;k++)for(int l=0;l<m;l++)used[i][j][k][l]=0;\n\t\t\t}\n\t\t}\n\t\tqueue<pair<pair<int,int>,pair<int,int> > >P;\n\t\tpair<int,int>Ss,St;\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<m;j++)\n\t\t{\n\t\t\tif(s[i][j]=='L')Ss={i,j};\n\t\t\tif(t[i][j]=='R')St={i,j};\n\t\t}\n\t\tused[Ss.first][Ss.second][St.first][St.second]=1;\n\t\tP.push(make_pair(Ss,St));\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<m;j++)\n\t\t{\n\t\t\tif(s[i][j]=='%')Ss={i,j};\n\t\t\tif(t[i][j]=='%')St={i,j};\n\t\t}\n\t\tbool flag=1;\n\t\twhile(flag&&!P.empty())\n\t\t{\n\t\t\tpair<int,int>a=P.front().first,b=P.front().second;\n\t\t\tP.pop();\n\t\t\tfor(int r=0;r<4;r++)\n\t\t\t{\n\t\t\t\tpair<int,int>A=a,B=b;\n\t\t\t\tif(d[r])\n\t\t\t\t{\n\t\t\t\t\tint tx=A.first+d[r];\n\t\t\t\t\tif(tx>=0&&tx<n&&s[tx][A.second]!='#')A.first=tx;\n\t\t\t\t\ttx=B.first+d[r];\n\t\t\t\t\tif(tx>=0&&tx<n&&t[tx][B.second]!='#')B.first=tx;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tint ty=A.second+d[r+1];\n\t\t\t\t\tif(ty>=0&&ty<m&&s[A.first][ty]!='#')A.second=ty;\n\t\t\t\t\tty=B.second+d[r+1];\n\t\t\t\t\tif(ty>=0&&ty<m&&t[B.first][ty]!='#')B.second=ty;\n\t\t\t\t}\n\t\t\t\tif(used[A.first][A.second][B.first][B.second])continue;\n\t\t\t\tused[A.first][A.second][B.first][B.second]=1;\n\t\t\t\tif(A==Ss||B==St)\n\t\t\t\t{\n\t\t\t\t\tif(A==Ss&&B==St)\n\t\t\t\t\t{\n\t\t\t\t\t\tcout<<\"Yes\"<<endl;\n\t\t\t\t\t\tflag=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse P.push(make_pair(A,B));\n\t\t\t}\n\t\t}\n\t\tif(flag)cout<<(used[Ss.first][Ss.second][St.first][St.second]?\"Yes\":\"No\")<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> Coor;\ntypedef pair<Coor, Coor> Pair;\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {-1, 0, 1, 0};\n\nint H;\nint W;\nint sty[2];\nint stx[2];\nint y[2];\nint x[2];\nchar field[2][50][50];\nbool dp[50][50][50][50];\n\nbool WithinRange(int y, int x) {\n  if (y < 0 || H <= y) return false;\n  if (x < 0 || W <= x) return false;\n  return true;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &W, &H);\n    if (W == 0 && H == 0) return 0;\n\n    for (int i=0; i<H; i++) {\n      for (int j=0; j<W; j++) {\n        scanf(\" %c\", &field[0][i][j]);\n        if (field[0][i][j] == '%') {\n          sty[0] = i;\n          stx[0] = j;\n        } else if (field[0][i][j] == 'L') {\n          y[0] = i;\n          x[0] = j;\n        } else assert(field[0][i][j] == '.' || field[0][i][j] == '#');\n      }\n\n      for (int j=W-1; j>=0; j--) {\n        scanf(\" %c\", &field[1][i][j]);\n        if (field[1][i][j] == '%') {\n          sty[1] = i;\n          stx[1] = j;\n        } else if (field[1][i][j] == 'R') {\n          y[1] = i;\n          x[1] = j;\n        } else assert(field[1][i][j] == '.' || field[1][i][j] == '#');\n      }\n    }\n\n    for (int i=0; i<H; i++) {\n      for (int j=0; j<W; j++) {\n        for (int k=0; k<H; k++) {\n          for (int l=0; l<W; l++) {\n            dp[i][j][k][l] = false;\n          }\n        }\n      }\n    }\n\n    dp[y[0]][x[0]][y[1]][x[1]] = true;\n    queue<Pair> q;\n    q.push(Pair(Coor(y[0], x[0]), Coor(y[1], x[1])));\n    while (!q.empty()) {\n      Pair p = q.front(); q.pop();\n      Coor c1 = p.first;\n      int y1 = c1.first;\n      int x1 = c1.second;\n      Coor c2 = p.second;\n      int y2 = c2.first;\n      int x2 = c2.second;\n\n      for (int i=0; i<4; i++) {\n        int newy1 = y1 + dy[i];\n        int newx1 = x1 + dx[i];\n        if (!WithinRange(newy1, newx1) || field[0][newy1][newx1] == '#') {\n          newy1 -= dy[i];\n          newx1 -= dx[i];\n        }\n\n        int newy2 = y2 + dy[i];\n        int newx2 = x2 + dx[i];\n        if (!WithinRange(newy2, newx2) || field[1][newy2][newx2] == '#') {\n          newy2 -= dy[i];\n          newx2 -= dx[i];\n        }\n\n        if (dp[newy1][newx1][newy2][newx2]) continue;\n        dp[newy1][newx1][newy2][newx2] = true;\n        q.push(Pair(Coor(newy1, newx1), Coor(newy2, newx2)));\n      }\n    }\n\n    if (dp[sty[0]][stx[0]][sty[1]][stx[1]]) puts(\"Yes\");\n    else puts(\"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//深さ優先探索で行けるんじゃないか？\n\n\nint di[4] = {0, -1, 0, 1};\nint dj[4] = {1, 0, -1, 0};\n\nint si_L, si_R, sj_L, sj_R, gi_L, gi_R, gj_L, gj_R;  //スタートとゴールの座標\n\n\nint main(){\n\n    while(1){\n\n    //入力\n    int W, H; cin >> W >> H;\n    if(W == 0) break;\n\n    vector<vector<bool> > Room_L(H + 2, vector<bool> (W + 2, false));\n    vector<vector<bool> > Room_R(H + 2, vector<bool> (W + 2, false));\n\n    for(int i = 1; i <= H; i++){\n        //L\n        for(int j = 1; j <= W; j++){\n            char input; cin >> input;\n            if(input == '#') continue;\n            else{\n                Room_L[i][j] = true;\n\n                if(input == '%'){\n                    gi_L = i;\n                    gj_L = j;\n                }\n\n                if(input == 'L'){\n                    si_L = i;\n                    sj_L = j;\n                }\n            }\n        }\n\n        //R\n        for(int j = 1; j <= W; j++){\n            char input; cin >> input;\n            if(input == '#') continue;\n            else{\n                Room_R[i][j] = true;\n\n                if(input == '%'){\n                    gi_R = i;\n                    gj_R = j;\n                }\n\n                if(input == 'R'){\n                    si_R = i;\n                    sj_R = j;\n                }\n            }\n        }\n    }\n\n\n    //幅優先をする\n    set<pair<pair<int, int>, pair<int, int> > > s;\n    queue<pair<pair<int, int>, pair<int, int> > > wait;                      //左の座標　右の座標\n    wait.push({ {si_L, sj_L}, {si_R, sj_R} });\n    s.insert({ {si_L, sj_L}, {si_R, sj_R} });\n    \n    bool can = false;\n\n    while(!wait.empty()){    //キュー画空になるまで\n        \n\n        //キューの先頭要素を取り出す\n        int nowi_L = wait.front().first.first;\n        int nowj_L = wait.front().first.second;\n        int nowi_R = wait.front().second.first;\n        int nowj_R = wait.front().second.second;\n        //cout << nowi_L << \" \" << nowj_L << \"  \" << nowi_R << \" \" << nowj_R << endl;\n        wait.pop();\n\n        //四方向を探索\n        for(int k = 0; k < 4; k++){\n            int nexti_L = nowi_L + di[k];\n            int nextj_L = nowj_L + dj[k];\n            int nexti_R = nowi_R + di[k];\n            int nextj_R = nowj_R - dj[k];\n            //cout << \" \" << nexti_L << \" \" << nextj_L << \"  \" << nexti_R << \" \" << nextj_R << endl;\n                \n\n            int L = Room_L[nexti_L][nextj_L];\n            int R = Room_R[nexti_R][nextj_R];\n            //cout << \" \" << L << \" \" << R << endl;\n            \n\n            //その方向に進めるなら\n            if(nexti_L == gi_L && nextj_L == gj_L && nexti_R == gi_R && nextj_R == gj_R){\n                can = true;\n                break;\n            }else if((nexti_L == gi_L && nextj_L == gj_L) || (nexti_R == gi_R && nextj_R == gj_R)){\n                continue;\n            }else if(R && L && s.find({{nexti_L, nextj_L}, {nexti_R, nextj_R}}) == s.end()){\n                wait.push({{nexti_L, nextj_L}, {nexti_R, nextj_R}});\n                s.insert({{nexti_L, nextj_L}, {nexti_R, nextj_R}});\n            }else if(R && !L && s.find({{nowi_L, nowj_L}, {nexti_R, nextj_R}}) == s.end()){\n                wait.push({{nowi_L, nowj_L}, {nexti_R, nextj_R}});\n                s.insert({{nowi_L, nowj_L}, {nexti_R, nextj_R}});\n            }else if(!R && L && s.find({{nexti_L, nextj_L}, {nowi_R, nowj_R}}) == s.end()){\n                wait.push({{nexti_L, nextj_L}, {nowi_R, nowj_R}});\n                s.insert({{nexti_L, nextj_L}, {nowi_R, nowj_R}});\n            }\n        }\n    }\n\n    if(can) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <memory.h>\n\nusing namespace std;\n\nint maxw,maxh;\nint lsx,lsy;\nint rsx,rsy;\n\nconst int dx[] = {1,0,-1,0};\nconst int ddx[] = {-1,0,1,0};\nconst int dy[] = {0,1,0,-1};\nconst int ddy[] = {0,1,0,-1};\n\nbool dfs(char ffieldl[55][55],char ffieldr[55][55],int lx,int ly,int rx,int ry)\n{\n\tchar fieldl[55][55];\n\tchar fieldr[55][55];\n\tmemcpy(fieldl,ffieldl,sizeof(fieldl));\n\tmemcpy(fieldr,ffieldr,sizeof(fieldr));\n\tfieldl[ly][lx]=0;\n\tfieldr[ry][rx]=0;\n\tfor(int i=0;i<4;++i){\n\t\tint tolx=lx,toly=ly;\n\t\tint torx=rx,tory=ry;\n\t\tbool f=false;\n\t\tif(fieldl[ly+dy[i]][lx+dx[i]] == '%' && fieldr[ry+ddy[i]][rx+ddx[i]] == '%')\n\t\t\treturn true;\n\t\telse if(fieldl[ly+dy[i]][lx+dx[i]] == '%' || fieldr[ry+ddy[i]][rx+ddx[i]] == '%')\n\t\t\tcontinue;\n\t\tif(fieldl[ly+dy[i]][lx+dx[i]] == '.'){\n\t\t\ttolx = lx+dx[i];\n\t\t\ttoly = ly+dy[i];\n\t\t\tf=true;\n\t\t}\n\t\tif(fieldr[ry+ddy[i]][rx+ddx[i]] == '.'){\n\t\t\ttorx = rx+ddx[i];\n\t\t\ttory = ry+ddy[i];\n\t\t\tf=true;\n\t\t}\n\t\tif(!f)\n\t\t\tcontinue;\n\t\tif(dfs(fieldl,fieldr,tolx,toly,torx,tory))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main(void)\n{\n\twhile(1)\n\t{\n\t\t\n\t\tchar fieldl[55][55];\n\t\tchar fieldr[55][55];\n\t\tmemset(fieldl,0,sizeof(fieldl));\n\t\tmemset(fieldr,0,sizeof(fieldr));\n\t\tcin >> maxw >> maxh;\n\t\tif(maxw==0&&maxh==0)\n\t\t\treturn 0;\n\t\tfor(int y=1;y<=maxh;++y){\n\t\t\tfor(int x=1;x<=maxw;++x){\n\t\t\t\tcin >> fieldl[y][x];\n\t\t\t\tif(fieldl[y][x] == 'L'){\n\t\t\t\t\tlsy = y;lsx = x;\n\t\t\t\t}\n\t\t\t\tif(fieldl[y][x] == 'R'){\n\t\t\t\t\trsy = y;rsx = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int x=1;x<=maxw;++x){\n\t\t\t\tcin >> fieldr[y][x];\n\t\t\t\tif(fieldr[y][x] == 'L'){\n\t\t\t\t\tlsy = y;lsx = x;\n\t\t\t\t}\n\t\t\t\tif(fieldr[y][x] == 'R'){\n\t\t\t\t\trsy = y;rsx = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dfs(fieldl,fieldr,lsx,lsy,rsx,rsy))\n\t\t\tcout << \"Yes\" << endl;\n\t\telse\n\t\t\tcout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\nstring ml[50], mr[50];\nbool fm[50][50][50][50];\nconst int dx[] = { 0,1,0,-1 };\nconst int dy[] = { 1,0,-1,0 };\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h, w) {\n\t\tfill((bool*)fm, (bool*)fm + 2500 * 2500, 0);\n\t\tvector<pair<pii,pii>> que;\n\t\tpii r, l, gl, gr;\n\t\tpair<pii, pii> g;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tcin >> ml[i] >> mr[i];\n\t\t\tint a = ml[i].find('L');\n\t\t\tif (a != string::npos)l = make_pair(i, a);\n\t\t\ta = ml[i].find('%');\n\t\t\tif (a != string::npos)gl = make_pair(i, a);\n\t\t\ta = mr[i].find('R');\n\t\t\tif (a != string::npos)r = make_pair(i, a);\n\t\t\ta = mr[i].find('%');\n\t\t\tif (a != string::npos)gr = make_pair(i, a);\n\t\t}\n\t\tg = make_pair(gl, gr);\n\t\tque.push_back(make_pair(l, r));\n\t\tbool f = 0;\n\t\twhile (!que.empty()&&!f) {\n\t\t\tauto top = que.back();\n\t\t\tque.pop_back();\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tauto n = top;\n\t\t\t\tn.first.first += dx[i];\n\t\t\t\tn.first.second += dy[i];\n\t\t\t\tn.second.first -= dx[i];\n\t\t\t\tn.second.second += dy[i];\n\t\t\t\tif (n.first.first < 0 || n.first.first >= w)n.first.first = top.first.first;\n\t\t\t\tif (n.first.second < 0 || n.first.second >= h)n.first.second = top.first.second;\n\t\t\t\tif (n.second.first < 0 || n.second.first >= w)n.second.first = top.second.first;\n\t\t\t\tif (n.second.second < 0 || n.second.second >= h)n.second.second = top.second.second;\n\t\t\t\tif (ml[n.first.second][n.first.first] == '#')n.first = top.first;\n\t\t\t\tif (mr[n.second.second][n.second.first] == '#')n.second = top.second;\n\t\t\t\tif (ml[n.first.second][n.first.first] == '%'&&mr[n.second.second][n.second.first] == '%') {\n\t\t\t\t\tf = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (ml[n.first.second][n.first.first] == '%'^mr[n.second.second][n.second.first] == '%')continue;\n\t\t\t\tbool a = 1;\n\t\t\t\tswap(fm[n.first.first][n.first.second][n.second.first][n.second.second], a);\n\t\t\t\tif (a)continue;\n\t\t\t\tque.push_back(n);\n\t\t\t}\n\t\t}\n\t\tcout << (f ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <tuple>\n\n#define REP(i, a, b) for (int i = int(a); i < int(b); i++)\n#define dump(val) cerr << __LINE__ << \":\\t\" << #val << \" = \" << (val) << endl\n\nusing namespace std;\n\ntypedef long long int lli;\ntypedef tuple<int,int,int,int> Point;\n\nint main() {\n    int W, H;\n    while (cin >> W >> H, W + H) {\n        vector<vector<char>> L(H + 2, vector<char>(W + 2, '#')), R(H + 2, vector<char>(W + 2, '#'));\n        int xl, yl, xr, yr;\n        REP (i, 1, H + 1) {\n            REP (j, 1, W + 1) {\n                cin >> L[i][j];\n                if (L[i][j] == 'L') {\n                    yl = i;\n                    xl = j;\n                }\n            }\n            REP (j, 1, W + 1) {\n                cin >> R[i][j];\n                if (R[i][j] == 'R') {\n                    yr = i;\n                    xr = j;\n                }\n            }\n        }\n\n        // used[yl][xl][yr][xr]\n        vector<vector<vector<vector<bool>>>> used(H + 2, vector<vector<vector<bool>>>(W + 2, vector<vector<bool>>(H + 2, vector<bool>(W + 2, false))));\n        queue<Point> q;\n        int dx[4] = {0, 1, 0, -1};\n        int dy[4] = {1, 0, -1, 0};\n        q.emplace(yl, xl, yr, xr);\n        bool ans = false;\n        while (q.size()) {\n            Point p = q.front();\n            q.pop();\n            yl = get<0>(p);\n            xl = get<1>(p);\n            yr = get<2>(p);\n            xr = get<3>(p);\n            if (used[yl][xl][yr][xr]) continue;\n            used[yl][xl][yr][xr] = true;\n\n            if (L[yl][xl] == '%' && R[yr][xr] == '%') {\n                ans = true;\n                break;\n            }\n            if (L[yl][xl] == '%' || R[yr][xr] == '%') continue;\n            REP (k, 0, 4) {\n                int nyl = yl + dy[k];\n                int nxl = xl + dx[k];\n                int nyr = yr + dy[k];\n                int nxr = xr - dx[k];\n\n                if (L[nyl][nxl] == '#') {\n                    nyl = yl;\n                    nxl = xl;\n                }\n                if (R[nyr][nxr] == '#') {\n                    nyr = yr;\n                    nxr = xr;                    \n                }\n\n                q.emplace(nyl, nxl, nyr, nxr);\n            }\n        }\n        cout << (ans ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int>;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\nll w,h;\n\nvector<string> l,r;\n\n/* bool search(int lx,int ly,int rx,int ry){                                       */\n/*   if(!value(lx,ly,w,h) || !value(rx,ry,w,h) || f[lx][ly][rx][ry]) return false; */\n/*   (f[lx][ly][rx][ry]) = true;                                                   */\n/*   bool res = false;                                                             */\n/*   rep(i,4){                                                                     */\n/*     int nlx = lx + dx[i],nly = ly + dy[i],nrx = rx - dx[i],nry = ry + dy[i];    */\n/*     cout << nlx << ' ' << nly << ' ' << nrx << ' ' << nry << endl;              */\n/*     if(value(nlx,nly,w,h) && value(nrx,nry,w,h) ){                              */\n/*       if( l[nly][nlx] == '.' && r[nry][nrx] == '.')                             */\n/*         res |= search(nlx,nly,nrx,nry);                                         */\n/*     }                                                                           */\n/*     if(value(nlx,nly,w,h) && value(nrx,nry,w,h) ){                              */\n/*       if( l[nly][nlx] == '.' && r[nry][nrx] == '#')                             */\n/*         res |= search(nlx,nly,rx,ry);                                           */\n/*     }                                                                           */\n/*     if(value(nlx,nly,w,h) && value(nrx,nry,w,h) ){                              */\n/*       if( l[nly][nlx] == '#' && r[nry][nrx] == '.')                             */\n/*         res |= search(lx,ly,nrx,nry);                                           */\n/*     }                                                                           */\n/*     if(value(nlx,nly,w,h) && value(nrx,nry,w,h) ){                              */\n/*       if( l[nly][nlx] == '%' && r[nry][nrx] == '%')                             */\n/*         return true;                                                            */\n/*     }                                                                           */\n/*   }                                                                             */\n/*   return res;                                                                   */\n/* }                                                                               */\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll lx,ly,rx,ry;\n  while(cin >> w >> h &&  w + h ){\n    l.resize(h),r.resize(h);\n    rep(i,h){\n      cin >> l[i] >> r[i];\n      rep(j,w){\n        if(l[i][j] == 'L'){\n          ly = i;\n          lx = j;\n        }\n        if(r[i][j] == 'R'){\n          ry = i;\n          rx = j;\n        }\n      }\n    }\n    auto make = [](int lx,int ly,int rx,int ry){return mp(mp(lx,ly),mp(rx,ry));};\n    bool ans = false;\n    queue<pair<pii,pii>> q;\n    q.push(make(lx,ly,rx,ry));\n    bool f[51][51][51][51] ={};\n    f[lx][ly][rx][ry] = true;\n    while(q.size()){\n      pii lp = q.front().fi,rp = q.front().se;\n      q.pop();\n      lx = lp.fi,ly = lp.se,rx = rp.fi,ry = rp.se;\n      f[lx][ly][rx][ry] = true;\n      rep(i,4){\n        int nlx = lx + dx[i],nly = ly + dy[i],nrx = rx - dx[i],nry = ry + dy[i];\n        /* cout << nlx << ' ' << nly << ' ' << nrx << ' ' << nry << endl; */\n        if(value(nlx,nly,w,h) && value(nrx,nry,w,h) ){\n          if( l[nly][nlx] == '.' && r[nry][nrx] == '.' && !f[nlx][nly][nrx][nry]){\n            q.push(make(nlx,nly,nrx,nry));\n          }\n        }\n        if(value(nlx,nly,w,h) && value(nrx,nry,w,h) && !f[nlx][nly][rx][ry]){\n          if( l[nly][nlx] == '.' && r[nry][nrx] == '#'){\n            q.push(make(nlx,nly,rx,ry));\n          }\n        }\n        if(value(nlx,nly,w,h) && value(nrx,nry,w,h) && !f[lx][ly][nrx][nry]){\n          if( l[nly][nlx] == '#' && r[nry][nrx] == '.'){\n            q.push(make(lx,ly,nrx,nry));\n          }\n        }\n        if(value(nlx,nly,w,h) && value(nrx,nry,w,h) ){\n          if( l[nly][nlx] == '%' && r[nry][nrx] == '%'){\n            ans = true;\n            while(q.size()){\n              q.pop();\n            }\n          }\n        }\n      } \n    }\n    std::cout << (ans ? \"Yes\" : \"No\") << std::endl; \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int OfLen = 0;\nconst int OfRin = 1;\n\nstruct Point {\n  int x, y;\n  Point(){}\n  Point(int x, int y):x(x), y(y){}\n};\n\nstruct TPoint {\n  Point Len, Rin;\n  TPoint(){}\n  TPoint(Point Len, Point Rin):Len(Len), Rin(Rin){}\n};\n\nbool isInRoom(Point p, string room[55], int w, int h)\n{\n  if(0 <= p.x && p.x < w && 0 <= p.y && p.y < h && room[p.y][p.x] != '#') return true;\n  return false;\n}\n\nbool isOpenGate(int w, int h, string room[2][55], TPoint twinspos)\n{\n  static int dx[] = {0, 1, 0, -1};\n  static int dy[] = {1, 0, -1, 0};\n\n  bool route[2][55][55] = {{{false}}};\n  route[OfLen][twinspos.Len.y][twinspos.Len.x] = true;\n  route[OfRin][twinspos.Rin.y][twinspos.Rin.x] = true;\n\n  queue<TPoint> que;\n  que.push(twinspos);  \n\n  while(!que.empty()) {\n    TPoint tp = que.front(); que.pop();\n    Point len = tp.Len, rin = tp.Rin;\n\n    route[OfLen][len.y][len.x] = true;\n    route[OfRin][rin.y][rin.x] = true;\n\n    if(room[OfLen][len.y][len.x] == '%' && room[OfRin][rin.y][rin.x] == '%') return true;\n\n    for(int i = 0; i < 4; i++) {\n      Point nextLen = len, nextRin = rin;\n\n      Point lenIfMove = Point(len.x + dx[i], len.y + dy[i]);\n      if(isInRoom(lenIfMove, room[OfLen], w, h)) nextLen = lenIfMove;\n      \n      Point rinIfMove = Point(rin.x - dx[i], rin.y + dy[i]);\n      if(isInRoom(rinIfMove, room[OfRin], w, h)) nextRin = rinIfMove;\n\n      if(route[OfLen][nextLen.y][nextLen.x] && route[OfRin][nextRin.y][nextRin.x]) continue;\n\n      que.push(TPoint(nextLen, nextRin));\n    }\n  }\n  return false;\n}\n  \n\nint main()\n{\n  int W, H;\n  while(cin >> W >> H, W || H) {\n    string room[2][55];\n    TPoint twinspos;\n    for(int i = 0; i < H; i++) {\n      cin >> room[OfLen][i] >> room[OfRin][i];\n      for(int j = 0; j < W; j++) {\n\tif(room[OfLen][i][j] == 'L') twinspos.Len = Point(j, i);\n\tif(room[OfRin][i][j] == 'R') twinspos.Rin = Point(j, i);\n      }\n    }\n    cout << (isOpenGate(W, H, room, twinspos) ? \"Yes\":\"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <array>\n#include <queue>\n#include <array>\n#include <stack>\n\nenum PassageType{\n\tFREE, WALL, SEARCHED, GOAL,\n};\n\nstruct Point {\n\tPoint() { x = 0; y = 0; };\n\tPoint(int x, int y) {\n\t\tthis->x = x;\n\t\tthis->y = y;\n\t};\n\tint x, y;\n};\n\nint main() {\n\tint w, h;\n\n\twhile (std::cin >> w >> h && w && h) {\n\t\tstd::array<std::vector<std::vector<int>>, 2> room;\n\t\tPoint start[2];\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tstd::array<std::string, 2> str;\n\t\t\tfor (int j = 0; j < str.size(); j++) {\n\t\t\t\tstd::cin >> str[j];\n\t\t\t\troom[j].push_back(std::vector<int>());\n\t\t\t\tfor (int k = 0; k < str[j].size(); k++) {\n\t\t\t\t\tint type = 0;\n\t\t\t\t\tif (str[j][k] == '.') type = FREE;\n\t\t\t\t\telse if (str[j][k] == '#') type = WALL;\n\t\t\t\t\telse if (str[j][k] == '%') type = GOAL;\n\t\t\t\t\telse if (str[j][k] == 'L' || str[j][k] == 'R') {\n\t\t\t\t\t\tstart[j].x = k;\n\t\t\t\t\t\tstart[j].y = i;\n\t\t\t\t\t\ttype = SEARCHED;\n\t\t\t\t\t}\n\t\t\t\t\troom[j].back().push_back(type);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstd::stack<std::pair<Point, Point>> s;\n\t\ts.push(std::make_pair(start[0], start[1]));\n\t\tint dx[] = {1, 0, -1, 0};\n\t\tint dy[] = {0, 1, 0, -1};\n\n\t\tbool isOk = false;\n\t\twhile (!s.empty() && !isOk) {\n\t\t\tauto node = s.top(); s.pop();\n\n\t\t\t//?¬???????????????´????????¢???\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tauto next = node;\n\t\t\t\tnext.first.x += dx[i];\n\t\t\t\tnext.first.y += dy[i];\n\t\t\t\tnext.second.x -= dx[i];\n\t\t\t\tnext.second.y += dy[i];\n\n\t\t\t\t//??´????£???£\n\t\t\t\tnext.first.x = std::min(std::max(0, next.first.x), w - 1);\n\t\t\t\tnext.first.y = std::min(std::max(0, next.first.y), h - 1);\n\t\t\t\tnext.second.x = std::min(std::max(0, next.second.x), w - 1);\n\t\t\t\tnext.second.y = std::min(std::max(0, next.second.y), h - 1);\n\n\t\t\t\t//??????????????´????????????OK\n\t\t\t\tif (room[0][next.first.y][next.first.x] == GOAL && room[1][next.second.y][next.second.x] == GOAL) {\n\t\t\t\t\tisOk = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint r[2] = {room[0][next.first.y][next.first.x], room[1][next.second.y][next.second.x] };\n\t\t\t\t\t//?£???????????????????????????????\n\t\t\t\t\tif (r[0] == WALL) {\n\t\t\t\t\t\tnext.first = node.first;\n\t\t\t\t\t\tr[0] = room[0][next.first.y][next.first.x];\n\t\t\t\t\t}\n\t\t\t\t\tif (r[1] == WALL) {\n\t\t\t\t\t\tnext.second = node.second;\n\t\t\t\t\t\tr[1] = room[1][next.second.y][next.second.x];\n\t\t\t\t\t}\n\t\t\t\t\tif ((r[0] == FREE || r[0] == SEARCHED) && (r[1] == FREE || r[1] == SEARCHED) && !(r[0] == SEARCHED && r[1] == SEARCHED)) {\n\t\t\t\t\t\ts.push(next);\n\t\t\t\t\t\troom[0][next.first.y][next.first.x] = SEARCHED;\n\t\t\t\t\t\troom[1][next.second.y][next.second.x] = SEARCHED;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstd::cout << (isOk ? \"Yes\" : \"No\") << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<queue>\n#define MAX 10\nusing namespace std;\nstruct Point{int x,y;};\nstruct P{\n  Point l,r;\n  int cost;\n};\nint main(){\n  int w,h;\n  while(cin>>w>>h,w||h){\n    int i,j,k;\n    int inf = 1<<20;\n    int d[MAX+1][MAX+1][MAX+1][MAX+1];\n    fill(d[0][0][0],d[MAX][MAX][MAX],inf);\n    string sr[60],sl[60];\n    for(i=0;i<h;i++){\n      cin >> sl[i] >> sr[i];\n    }\n    Point pr,pl,br,bl;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(sl[i][j]=='L'){\n\t  pl.x=j;pl.y=i;\n\t}\n\tif(sr[i][j]=='R'){\n\t  pr.x=j;pr.y=i;\n\t}\n      }\n    }\n    //cout << pl.x << \":\" << pl.y << endl;\n    //cout << pr.x << \":\" << pr.y << endl;\n    d[pl.x][pl.y][pr.x][pr.y]=0;\n    P p,b;\n    p.r=pr;\n    p.l=pl;\n    p.cost=d[pl.x][pl.y][pr.x][pr.y];\n    queue<P> q;\n    q.push(p);\n    bool f = false;\n    while(!q.empty()){\n      p=q.front();q.pop();\n      pl=p.l;pr=p.r;\n      if(p.cost>d[pl.x][pl.y][pr.x][pr.y]) continue;\n      d[pl.x][pl.y][pr.x][pr.y]=p.cost;\n      //cout << pl.x<<\":\"<<pl.y<<\":\"<<pr.x<<\":\"<<pr.y<<\"/\"<<p.cost<<endl;\n      if(sl[pl.y][pl.x]=='%'&&sr[pr.y][pr.x]=='%'){\n\tf=true;\n\tbreak;\n      }else if(sl[pl.y][pl.x]=='%') continue;\n      else if(sr[pr.y][pr.x]=='%') continue;\n      \n      p.cost++;\n      int lx[]={1,-1,0,0};int ly[]={0,0,1,-1};\n      int rx[]={-1,1,0,0};int ry[]={0,0,1,-1};\n      for(i=0;i<4;i++){\n\tbl=pl;br=pr;\n\tbl.x+=lx[i];bl.y+=ly[i];\n\tbr.x+=rx[i];br.y+=ry[i];\n\n\t//cout << bl.x<<\":\"<<bl.y<<\":\"<<br.x<<\":\"<<br.y<<\"/\"<<p.cost<<endl;\n\t\n\tif(bl.x<0) bl.x=0;\n\telse if(bl.x>=w) bl.x=w-1;\n\tif(bl.y<0) bl.y=0;\n\telse if(bl.y>=h) bl.y=h-1;\n\n\tif(br.x<0) br.x=0;\n\telse if(br.x>=w) br.x=w-1;\n\tif(br.y<0) br.y=0;\n\telse if(br.y>=h) br.y=h-1;\n\n\tif(sl[bl.y][bl.x]=='#'){\n\t  bl.x-=lx[i];bl.y-=ly[i];\n\t}\n\tif(sr[br.y][br.x]=='#'){\n\t  br.x-=rx[i];br.y-=ry[i];\n\t}\n\tp.r=br;p.l=bl;\n\tq.push(p);\n      }\n    }\n    if(f) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint w, h;\nstring l[51], r[51];\nint ldx[4] = {1, 0, -1, 0};\nint ldy[4] = {0, 1, 0, -1};\nint rdx[4] = {1, 0, -1, 0};\nint rdy[4] = {0, -1, 0, 1};\nint lsx, lsy, rsx, rsy, lgx, lgy, rgx, rgy;\nbool lischecked[51][51], rischecked[51][51];\n\nbool solve(int lx, int ly, int rx, int ry){\n    queue<int> rxqu, ryqu, lxqu, lyqu;\n    rxqu.push(rx);\n    ryqu.push(ry);\n    lxqu.push(lx);\n    lyqu.push(ly);\n    while(!rxqu.empty()){\n        lx = lxqu.front();\n        ly = lyqu.front();\n        rx = rxqu.front();\n        ry = ryqu.front();\n        lxqu.pop();\n        lyqu.pop();\n        rxqu.pop();\n        ryqu.pop();\n        if(lx == lgx && ly == lgy && rx == rgx && ry == rgy) return true;\n        if((lx == lgx && ly == lgy) || (rx == rgx && ry == rgy)) continue;\n        for(int i = 0; i < 4; i++){\n            int nlx = lx + ldx[i], nly = ly + ldy[i];\n            int nrx = rx + rdx[i], nry = ry + rdy[i];\n            if((nlx < 0 || nly < 0 || nlx >= h || nly >= w) && (nrx < 0 || nry < 0 || nrx >= h || nry >= w)) continue;\n            if(nlx < 0 || nlx >= h || nly < 0 || nly >= w){\n                nlx = lx;\n                nly = ly;\n            }\n            if(nrx < 0 || nrx >= h || nry < 0 || nry >= w){\n                nrx = rx;\n                nry = ry;\n            }\n            if((l[nlx][nly] == '#' && r[nrx][nry] == '#') || (lischecked[nlx][nly] && rischecked[nrx][nry])) continue;\n            if(l[nlx][nly] == '#'){\n                nlx = lx;\n                nly = ly;\n            }\n            if(r[nrx][nry] == '#'){\n                nrx = rx;\n                nry = ry;\n            }\n            lischecked[nlx][nly] = true;\n            rischecked[nrx][nry] = true;\n            rxqu.push(nrx);\n            ryqu.push(nry);\n            lxqu.push(nlx);\n            lyqu.push(nly);\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    while(1){\n        cin >> w >> h;\n        if(w == 0 && h == 0) break;\n        for(int i = 0; i < h; i++){\n            cin >> l[i] >> r[i];\n        }\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                lischecked[i][j] = false;\n                rischecked[i][j] = false;\n                if(l[i][j] == 'L'){\n                    lsx = i;\n                    lsy = j;\n                }\n                if(l[i][j] == '%'){\n                    lgx = i;\n                    lgy = j;\n                }\n                if(r[i][j] == 'R'){\n                    rsx = i;\n                    rsy = j;\n                }\n                if(r[i][j] == '%'){\n                    rgx = i;\n                    rgy = j;\n                }\n            }\n        }\n        lischecked[lsx][lsy] = true;\n        rischecked[rsx][rsy] = true;\n        if(solve(lsx, lsy, rsx, rsy)) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> pii;\nint W, H;\nint dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\n\nvoid rec(pii &p1, pii &p2, map<pair<pii,pii>,bool> &memo, vector<string> &R1, vector<string> &R2, pii &g1, pii &g2){\n  for(int i = 0; i < 4; ++i){\n    //int x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;\n    pii p1_ = p1, p2_ = p2;\n    if(p1_.first + dx[i] < H && p1_.first + dx[i] >= 0 &&\n       p1_.second + dy[i] < W && p1_.second + dy[i] >= 0 &&\n       R1[p1_.first + dx[i]][p1_.second + dy[i]] != '#'){\n      p1_.first += dx[i];\n      p1_.second += dy[i];\n    }\n    if(p2_.first + dx[i] < H && p2_.first + dx[i] >= 0 &&\n       p2_.second - dy[i] < W && p2_.second - dy[i] >= 0 &&\n       R2[p2_.first + dx[i]][p2_.second - dy[i]] != '#'){\n      p2_.first += dx[i];\n      p2_.second -= dy[i];\n    }\n    if((!memo[make_pair(g1,g2)]) && (!memo[make_pair(p1_,p2_)])){\n      memo[make_pair(p1_,p2_)] = true;\n      rec(p1_,p2_,memo,R1,R2,g1,g2);\n    }\n  }\n}\n\nint main(){\n  while(cin >> W >> H, W){\n    pii s1, s2, g1, g2;\n    vector<string> R1(H), R2(H);\n    for(int i = 0; i < H; ++i){\n      cin >> R1[i] >> R2[i];\n      for(int j = 0; j < W; ++j){\n        if(R1[i][j] == 'L'){\n          s1.first = i;\n          s1.second = j;\n        }\n        if(R2[i][j] == 'R'){\n          s2.first = i;\n          s2.second = j;\n        }\n        if(R1[i][j] == '%'){\n          g1.first = i;\n          g1.second = j;\n        }\n        if(R2[i][j] == '%'){\n          g2.first = i;\n          g2.second = j;\n        }\n      }\n    }\n    map<pair<pii,pii>,bool> memo;\n    rec(s1,s2,memo,R1,R2,g1,g2);\n    if(memo[make_pair(g1,g2)]) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    memo.erase(memo.begin(),memo.end());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<tuple>\n#include<string>\nusing namespace std;\n\n#define MAX_N 60\n#define INF 1<<30\n\nint dist[MAX_N][MAX_N][MAX_N][MAX_N];\nint dy1[4] = { 0,1,0,-1 };\nint dy2[4] = { 0,1,0,-1 };\nint dx1[4] = { 1,0,-1,0 };\nint dx2[4] = { -1,0,1,0 };\nint H, W, map1[MAX_N][MAX_N], map2[MAX_N][MAX_N];\nint Lsy, Lsx, Lgy, Lgx;\nint Rsy, Rsx, Rgy, Rgx;\nstring S, T;\nqueue<tuple<int, int, int, int>>Q;\n\nvoid _memset() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tfor (int k = 0; k < MAX_N; k++) {\n\t\t\t\tfor (int l = 0; l < MAX_N; l++) {\n\t\t\t\t\tdist[i][j][k][l] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tmap1[i][j] = 1;\n\t\t\tmap2[i][j] = 1;\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\t_memset();\n\t\tcin >> H >> W;\n\t\tif (H == 0 && W == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tcin >> S >> T;\n\t\t\tfor (int j = 0; j < S.size(); j++) {\n\t\t\t\tif (S[j] == '%') {\n\t\t\t\t\tLsx = j + 1; Lsy = i;\n\t\t\t\t\tmap1[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\tif (S[j] == '#') {\n\t\t\t\t\tmap1[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (S[j] == '.') {\n\t\t\t\t\tmap1[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (S[j] = 'L') {\n\t\t\t\t\tLgy = i; Lgx = j + 1;\n\t\t\t\t\tmap1[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < T.size(); j++) {\n\t\t\t\tif (T[j] == '%') {\n\t\t\t\t\tRsx = j + 1; Rsy = i;\n\t\t\t\t\tmap2[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\tif (S[j] == '#') {\n\t\t\t\t\tmap2[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (S[j] == '.') {\n\t\t\t\t\tmap2[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (S[j] = 'L') {\n\t\t\t\t\tRgy = i; Rgx = j + 1;\n\t\t\t\t\tmap2[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQ.push(make_tuple(Lsy, Lsx, Rsy, Rsx));\n\t\tdist[Lsy][Lsx][Rsy][Rsx] = 0;\n\n\t\twhile (!Q.empty()) {\n\t\t\ttuple<int, int, int, int>tup = Q.front(); Q.pop();\n\t\t\tint ay = get<0>(tup);\n\t\t\tint ax = get<1>(tup);\n\t\t\tint by = get<2>(tup);\n\t\t\tint bx = get<3>(tup);\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint ey = ay + dy1[i], ex = ax + dx1[i];\n\t\t\t\tint fy = by + dy2[i], fx = bx + dx2[i];\n\t\t\t\tif (map1[ey][ex] == 1) {\n\t\t\t\t\tey = ay; ex = ax;\n\t\t\t\t}\n\t\t\t\tif (map2[fy][fx] == 1) {\n\t\t\t\t\tfy = by; fx = bx;\n\t\t\t\t}\n\t\t\t\tif (dist[ey][ex][fy][fx] == INF) {\n\t\t\t\t\tdist[ey][ex][fy][fx] = 0;\n\t\t\t\t\tQ.push(make_tuple(ey, ex, fy, fx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[Lgy][Lgx][Rgy][Rgx] == INF) {\n\t\t\tcout << \"no\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"yes\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stack>\n#include <cstring>\n#include <string>\n#include <queue>\n#include <cmath>\n\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define all(v) (v).begin(), (v).end()\n#define rev(v) (v).rbegin(), (v).rend()\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int, int> P;\ntypedef long long ll;\n\n\nstruct state{\n\tint lx, ly, rx, ry;\n\tint dist;\n\tstate(int lx, int ly, int rx, int ry, int d):lx(lx), ly(ly), rx(rx), ry(ry), dist(d){}\n};\n\nint dx[] = {0, 0, -1, 1};\nint dy[] = {1, -1, 0, 0};\n\nint dist[50][50][50][50]; // Lx, Ly, Rx, Ry\n\nint main(){\n\t//freopen(\"test.txt\", \"r\", stdin);\n\tint w, h;\n\twhile(cin >> w >> h, w|h){\n\t\tvector<string> L(h), R(h);\n\t\trep(i, h){\n\t\t\tcin >> L[i] >> R[i];\n\t\t\treverse(all(R[i]));\n\t\t}\n\t\tP ls, rs, lg, rg;\n\t\trep(i, h){\n\t\t\trep(j, w){\n\t\t\t\tif(L[i][j] == 'L') ls = MP(j, i);\n\t\t\t\tif(L[i][j] == '%') lg = MP(j, i);\n\t\t\t\tif(R[i][j] == 'R') rs = MP(j, i);\n\t\t\t\tif(R[i][j] == '%') rg = MP(j, i);\n\t\t\t}\n\t\t}\n\n\t\tmemset(dist, -1, sizeof(dist));\n\n\t\tqueue<state> q;\n\t\tq.push(state(ls.X, ls.Y, rs.X, rs.Y, 0));\n\t\tdist[ls.X][ls.Y][rs.X][rs.Y] = 0;\n\n\t\twhile(!q.empty()){\n\t\t\tstate s = q.front();\n\t\t\tq.pop();\n\n\t\t\tif(s.lx == lg.X && s.ly == lg.Y && s.rx == rg.X && s.ry == rg.Y){\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trep(i, 4){\n\t\t\t\tint lx = s.lx+dx[i];\n\t\t\t\tint ly = s.ly+dy[i];\n\t\t\t\tint rx = s.rx+dx[i];\n\t\t\t\tint ry = s.ry+dy[i];\n\t\t\t\tif(lx < 0 || lx >= w) lx = s.lx;\n\t\t\t\tif(ly < 0 || ly >= h) ly = s.ly;\n\t\t\t\tif(rx < 0 || rx >= w) rx = s.rx;\n\t\t\t\tif(ry < 0 || ry >= h) ry = s.ry;\n\t\t\t\tif(L[ly][lx] == '#') lx = s.lx, ly = s.ly;\n\t\t\t\tif(R[ry][rx] == '#') rx = s.rx, ry = s.ry;\n\t\t\t\tif(L[ly][lx] == '%' || R[ry][rx] == '%'){\n\t\t\t\t\tif(L[ly][lx] != R[ry][rx]) continue;\n\t\t\t\t}\n\t\t\t\tif(dist[lx][ly][rx][ly] != -1) continue;\n\t\t\t\tdist[lx][ly][rx][ly] = s.dist + 1;\n\t\t\t\tq.push(state(lx, ly, rx, ry, s.dist+1));\n\t\t\t}\n\t\t}\n\n\t\tcout << (dist[lg.X][lg.Y][rg.X][rg.Y]!=-1?\"Yes\":\"No\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP(a, b) make_pair(a, b)\n#define Y first\n#define X second\n#define L first\n#define R second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef pair<pi, pi> pipi;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint W, H;\nint dy[] = {0,-1,0,1}, dx[] = {-1,0,1,0};\nchar len[64][64], rin[64][64];\n\nint main(){\n  while(scanf(\"%d%d\", &W, &H) && W){\n    rep(i, H) scanf(\"%s%s\", len[i], rin[i]);\n\n    int ly, lx, ry, rx;\n    rep(i, H) rep(j, W){\n      if(len[i][j] == 'L'){ ly = i, lx = j; len[i][j] = '.';}\n      if(rin[i][j] == 'R'){ ry = i, rx = j; rin[i][j] = '.';}\n    }\n\n    pipi p = MP(MP(ly, lx), MP(ry, rx));\n    queue<pipi>q;\n    map<pipi, int>m;\n    q.push(p);\n    m[p] = 1;\n\n    while(!q.empty()){\n      pipi now = q.front(); q.pop();\n      rep(d, 4){\n\tint nly, nlx, nry, nrx;\n\tif(d%2){\n\t  nly = now.L.Y + dy[d], nlx = now.L.X;\n\t  if(nly < 0 || nly >= H || len[nly][nlx] == '#') nly = now.L.Y; \n\t  nry = now.R.Y + dy[d], nrx = now.R.X;\n\t  if(nry < 0 || nry >= H || rin[nry][nrx] == '#') nry = now.R.Y; \n\t}else{\n\t  nly = now.L.Y, nlx = now.L.X + dx[d];\n\t  if(nlx < 0 || nlx >= W || len[nly][nlx] == '#') nlx = now.L.X; \t    \n\t  nry = now.R.Y, nrx = now.R.X + -1*dx[d];\n\t  if(nrx < 0 || nrx >= W || rin[nry][nrx] == '#') nrx = now.R.X;\n\t}\n\n\t  //\t  pipi next = MP(MP(nly, nlx), MP(nry, nrx));\n\tif(len[nly][nlx] == '%' && rin[nry][nrx] == '%'){\n\t  puts(\"Yes\"); goto e;\n\t}else if(len[nly][nlx] == '%' || rin[nry][nrx] == '%'){\n\t  continue;\n\t}\n\n\tif(m.count(MP(MP(nly, nlx), MP(nry, nrx))) != 0) continue;\n\t//\t  printf(\"%d %d %d %d\\n\", next.L.Y, next.L.X, next.R.Y, next.R.X);\n\tm[MP(MP(nly, nlx), MP(nry, nrx))] = 1;\n\tq.push(MP(MP(nly, nlx), MP(nry, nrx)));\n      }\n    }\n    puts(\"No\");\n  e:;\n    m.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<queue>\n#define MAX 60\nusing namespace std;\nstruct Point{int x,y;};\nstruct P{\n  Point l,r;\n  int cost;\n};\nint main(){\n  int w,h;\n  while(cin>>w>>h,w||h){\n    int i,j,k;\n    int inf = 1<<20;\n    int d[MAX+1][MAX+1][MAX+1][MAX+1];\n    fill(d[0][0][0],d[MAX][MAX][MAX],inf);\n    \n    string sr[60],sl[60];\n    for(i=0;i<h;i++){\n      cin >> sl[i] >> sr[i];\n    }\n    /*\n    Point pr,pl,br,bl;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(sl[i][j]=='L'){\n\t  pl.x=j;pl.y=i;\n\t}\n\tif(sr[i][j]=='R'){\n\t  pr.x=j;pr.y=i;\n\t}\n      }\n    }\n    //cout << pl.x << \":\" << pl.y << endl;\n    //cout << pr.x << \":\" << pr.y << endl;\n    d[pl.x][pl.y][pr.x][pr.y]=0;\n    P p,b;\n    p.r=pr;\n    p.l=pl;\n    p.cost=d[pl.x][pl.y][pr.x][pr.y];\n    queue<P> q;\n    q.push(p);\n    bool f = false;\n    while(!q.empty()){\n      p=q.front();q.pop();\n      pl=p.l;pr=p.r;\n      if(p.cost>d[pl.x][pl.y][pr.x][pr.y]) continue;\n      d[pl.x][pl.y][pr.x][pr.y]=p.cost;\n      //cout << pl.x<<\":\"<<pl.y<<\":\"<<pr.x<<\":\"<<pr.y<<\"/\"<<p.cost<<endl;\n      if(sl[pl.y][pl.x]=='%'&&sr[pr.y][pr.x]=='%'){\n\tf=true;\n\tbreak;\n      }else if(sl[pl.y][pl.x]=='%') continue;\n      else if(sr[pr.y][pr.x]=='%') continue;\n      \n      p.cost++;\n      int lx[]={1,-1,0,0};int ly[]={0,0,1,-1};\n      int rx[]={-1,1,0,0};int ry[]={0,0,1,-1};\n      for(i=0;i<4;i++){\n\tbl=pl;br=pr;\n\tbl.x+=lx[i];bl.y+=ly[i];\n\tbr.x+=rx[i];br.y+=ry[i];\n\n\t//cout << bl.x<<\":\"<<bl.y<<\":\"<<br.x<<\":\"<<br.y<<\"/\"<<p.cost<<endl;\n\t\n\tif(bl.x<0) bl.x=0;\n\telse if(bl.x>=w) bl.x=w-1;\n\tif(bl.y<0) bl.y=0;\n\telse if(bl.y>=h) bl.y=h-1;\n\n\tif(br.x<0) br.x=0;\n\telse if(br.x>=w) br.x=w-1;\n\tif(br.y<0) br.y=0;\n\telse if(br.y>=h) br.y=h-1;\n\n\tif(sl[bl.y][bl.x]=='#'){\n\t  bl.x-=lx[i];bl.y-=ly[i];\n\t}\n\tif(sr[br.y][br.x]=='#'){\n\t  br.x-=rx[i];br.y-=ry[i];\n\t}\n\tp.r=br;p.l=bl;\n\tq.push(p);\n      }\n    }\n    if(f) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    */\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nbool memo[50][50][50][50], R1[50][50], R2[50][50];\nint W, H;\nint dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\nint sx1, sy1, sx2, sy2, gx1, gx2, gy1, gy2; \n\nvoid rec(int x1, int y1, int x2, int y2){\n  for(int i = 0; i < 4; ++i){\n    int x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;\n    if(x1 + dx[i] < H && x1 + dx[i] >= 0 &&\n       y1 + dy[i] < W && y1 + dy[i] >= 0 &&\n       R1[x1 + dx[i]][y1 + dy[i]]){\n      x1_ += dx[i];\n      y1_ += dy[i];\n    }\n    if(x2 + dx[i] < H && x2 + dx[i] >= 0 &&\n       y2 - dy[i] < W && y2 - dy[i] >= 0 &&\n       R2[x2 + dx[i]][y2 - dy[i]]){\n      x2_ += dx[i];\n      y2_ -= dy[i];\n    }\n    if((x1_ == gx1 && y1_ == gy1) || (x2_ == gx2 && y2_ == gy2)){\n      memo[x1_][y1_][x2_][y2_] = true;\n    }else if(!memo[x1_][y1_][x2_][y2_]){\n      memo[x1_][y1_][x2_][y2_] = true;\n      rec(x1_,y1_,x2_,y2_);\n    }\n  }\n}\n \nint main(){\n  while(cin >> W >> H, W){\n    string r1, r2;\n    for(int i = 0; i < H; ++i){\n      cin >> r1 >> r2;\n      for(int j = 0; j < W; ++j){\n        if(r1[j] == 'L'){\n          sx1 = i;\n          sy1 = j;\n        }\n        if(r2[j] == 'R'){\n          sx2 = i;\n          sy2 = j;\n        }\n        if(r1[j] == '%'){\n          gx1 = i;\n          gy1 = j;\n        }\n        if(r2[j] == '%'){\n          gx2 = i;\n          gy2 = j;\n        }\n        if(r1[j] != '#') R1[i][j] = true;\n        else R1[i][j] = false;\n        if(r2[j] != '#') R2[i][j] = true;\n        else R2[i][j] = false;\n      }\n    }\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n        for(int k = 0; k < H; ++k){\n          for(int l = 0; l< W; ++l){\n            memo[i][j][k][l] = false;\n          }\n        }\n      }\n    }\n    memo[sx1][sy1][sx2][sy2] = true;\n    rec(sx1,sy1,sx2,sy2);\n    if(memo[gx1][gy1][gx2][gy2]) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint lsx, lsy, ltx, lty, rsx, rsy, rtx, rty;\nbool dfs(vector<vector<vvi>> &dp, int lx, int ly, int rx, int ry) {\n\tif (dp[ly][lx][ry][rx] != -1)return dp[ly][lx][ry][rx];\n\treturn true;\n}\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint w, h;\n\twhile (cin >> w >> h, w) {\n\t\tvector<string> l(h), r(h);\n\t\tREP(i, h) cin >> l[i] >> r[i];\n\n\t\tREP(i, h) {\n\t\t\tREP(j, h) {\n\t\t\t\tif (l[i][j] == '%') {\n\t\t\t\t\tltx = j; lty = i;\n\t\t\t\t}\n\t\t\t\tif (l[i][j] == 'L') {\n\t\t\t\t\tlsx = j; lsy = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tREP(i, h) {\n\t\t\tREP(j, h) {\n\t\t\t\tif (r[i][j] == '%') {\n\t\t\t\t\trtx = j; rty = i;\n\t\t\t\t}\n\t\t\t\tif (r[i][j] == 'R') {\n\t\t\t\t\trsx = j; rsy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<vector<vvi>> dp(h, vector<vvi>(w, vvi(h, vi(w, -1))));\n\t\tqueue<pair<pii, pii>> q;\n\t\tvector<vector<vvi>> b(h, vector<vvi>(w, vvi(h, vi(w, 0))));\n\t\tq.push(pair<pii, pii>(pii(lsx, lsy), pii(rsx, rsy)));\n\t\tb[lsy][lsx][rsy][rsx] = 1;\n\t\twhile (!q.empty()) {\n\t\t\tauto a = q.front(); q.pop();\n\t\t\tint lx = a.first.first, ly = a.first.second, rx = a.second.first, ry = a.second.second;\n\t\t\tif (lx == ltx&&ly == lty&&rx == rtx&&ry == rty) {\n\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\tgoto a;\n\t\t\t}\n\n\t\t\tREP(i, 4) {\n\t\t\t\tint lnx = lx + dx[i * 2], lny = ly + dy[i * 2], rnx = rx + dx[(i + 2 * (i % 2 == 0)) * 2 % 8], rny = ry + dy[(i + 2 * (i % 2 == 0)) * 2 % 8];\n\t\t\t\tif (lnx < 0 || lnx >= w || lny < 0 || lny >= h || l[lny][lnx] == '#') {\n\t\t\t\t\tlny = ly; lnx = lx;\n\t\t\t\t}\n\t\t\t\tif (rnx < 0 || rnx >= w || rny < 0 || rny >= h || r[rny][rnx] == '#') {\n\t\t\t\t\trny = ry; rnx = rx;\n\t\t\t\t}\n\t\t\t\tif ((lnx!=lx||lny!=ly||rnx!=rx||rny!=ry)&& b[lny][lnx][rny][rnx]!=1) {\n\t\t\t\t\tassert(b[lny][lnx][rny][rnx] == 0);\n\t\t\t\t\tq.push(pair<pii, pii>(pii(lnx, lny), pii(rnx, rny)));\n\t\t\t\t\tb[lny][lnx][rny][rnx] = 1;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << \"No\" << endl;\n\n\ta:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst double EPS = 1e-9;\n\nint main(){\n    while(true){\n        int W,H;\n        cin >> W >> H;\n        if(W == 0 and H == 0) break;\n        vector<vector<string> > field(2,vector<string>(H+2,string(W+2,'#')));\n\n        for(int i=1;i<=H;i++){\n            for(int j=0;j<2;j++){\n                cin >> field[j][i];\n                field[j][i] = '#' + field[j][i] + '#';\n            }\n        }\n        pair<pii,pii> start;\n        pair<pii,pii> goal;\n        for(int i=0;i<2;i++){\n            for(int j=1;j<=H;j++){\n                for(int k=1;k<=W;k++){\n                    if(field[i][j][k] == 'L'){\n                        start.first = make_pair(j,k);\n                    }else if(field[i][j][k] == 'R'){\n                        start.second = make_pair(j,k);\n                    }else if(field[i][j][k] == '%'){\n                        if(i == 0){\n                            goal.first = make_pair(j,k);\n                        }else{\n                            goal.second = make_pair(j,k);\n                        }\n                    }\n                }\n            }\n        }\n        stack<pair<pii,pii> > sta;\n        sta.push(start);\n        bool used[H+2][W+2][H+2][W+2];\n        for(int i=0;i<H+2;i++){\n            for(int j=0;j<W+2;j++){\n                for(int k=0;k<H+2;k++){\n                    for(int l=0;l<W+2;l++){\n                        used[i][j][k][l] = false;\n                    }\n                }\n            }\n        }\n        bool ok = false;\n        while(not sta.empty()){\n            pair<pii,pii> now = sta.top();\n            sta.pop();\n            if(used[now.first.first][now.first.second][now.second.first][now.second.second]){\n                continue;\n            }\n            used[now.first.first][now.first.second][now.second.first][now.second.second] = true;\n            if(now == goal){\n                ok = true;\n                break;\n            }\n            if(now.first == goal.first){\n                continue;\n            }\n            if(now.second == goal.second){\n                continue;\n            }\n            for(int i=0;i<4;i++){\n                pair<pii,pii> next = now;\n                next.first.first += dy[i];\n                next.first.second += dx[i];\n                next.second.first += dy[i];\n                next.second.second -= dx[i];\n                if(field[0][next.first.first][next.first.second] == '#'){\n                    next.first = now.first;\n                }\n                if(field[1][next.second.first][next.second.second] == '#'){\n                    next.second = now.second;\n                }\n                sta.push(next);\n            }\n        }\n        if(ok){\n            cout << \"Yes\" << endl;\n        }else{\n            cout << \"No\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst double EPS = 1e-9;\n\nint main(){\n    while(true){\n        int W,H;\n        cin >> W >> H;\n        if(W == 0 and H == 0) break;\n        vector<vector<string> > field(2,vector<string>(H+2));\n        field[0][0] = string(W+2,'#');\n        field[1][0] = string(W+2,'#');\n        field[0][H+1] = string(W+2,'#');\n        field[1][H+1] = string(W+2,'#');\n\n        for(int i=1;i<=H;i++){\n            for(int j=0;j<2;j++){\n                cin >> field[j][i];\n                field[j][i] = '#' + field[j][i] + '#';\n                if(j == 1) reverse(all(field[j][i]));\n            }\n        }\n        pair<pii,pii> start;\n        pair<pii,pii> goal;\n        for(int i=0;i<2;i++){\n            for(int j=1;j<=H;j++){\n                for(int k=1;k<=W;k++){\n                    if(field[i][j][k] == 'L'){\n                        start.first = make_pair(j,k);\n                    }else if(field[i][j][k] == 'R'){\n                        start.second = make_pair(j,k);\n                    }\n                    if(field[i][j][k] == '%'){\n                        if(i == 0){\n                            goal.first = make_pair(j,k);\n                        }else{\n                            goal.second = make_pair(j,k);\n                        }\n                    }\n                }\n            }\n        }\n        stack<pair<pii,pii> > sta;\n        sta.push(start);\n        bool used[H+2][W+2][H+2][W+2];\n        for(int i=0;i<H+2;i++){\n            for(int j=0;j<W+2;j++){\n                for(int k=0;k<H+2;k++){\n                    for(int l=0;l<W+2;l++){\n                        used[i][j][k][l] = false;\n                    }}}}\n        bool ok = false;\n        while(not sta.empty()){\n            pair<pii,pii> now = sta.top();\n            sta.pop();\n            if(used[now.first.first][now.first.second][now.second.first][now.second.second]){\n                continue;\n            }\n            used[now.first.first][now.first.second][now.second.first][now.second.second] = true;\n            if(now == goal){\n                ok = true;\n                break;\n            }\n            for(int i=0;i<4;i++){\n                pair<pii,pii> next = now;\n                next.first.first += dx[i];\n                next.first.second += dy[i];\n                next.second.first += dx[i];\n                next.second.second += dy[i];\n                if(field[0][next.first.first][next.first.second] == '#'){\n                    next.first = now.first;\n                }\n                if(field[1][next.second.first][next.second.second] == '#'){\n                    next.second = now.second;\n                }\n                sta.push(next);\n            }\n        }\n        if(ok){\n            cout << \"Yes\" << endl;\n        }else{\n            cout << \"No\" << endl;\n        }\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n\nP lg, rg;\nint dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0}, h, w;\nbool f[50][50][50][50];\nchar lf[50][51],rf[50][51]; \n\nint range(int a,int b){\n\treturn a >= 0 && a < h && b >= 0 && b < w;\n}\n\nbool dfs(int ly,int lx,int ry,int rx){\n\tint i;\n\tif(lg.first == ly && lg.second == lx || rg.first == ry && rg.second == rx){\n\t\tif(lg.first == ly && lg.second == lx && rg.first == ry && rg.second == rx)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tfor(i = 0;i < 4;i++){\n\t\tif(range(ly + dy[i],lx + dx[i]) && range(ry + dy[i],rx - dx[i])){\n\t\t\tif(lf[ly + dy[i]][lx + dx[i]] != '#' && rf[ry + dy[i]][rx - dx[i]] != '#' && f[ly + dy[i]][lx + dx[i]][ry + dy[i]][rx - dx[i]]){\n\t\t\t\tf[ly + dy[i]][lx + dx[i]][ry + dy[i]][rx - dx[i]] = 0;\n\t\t\t\tif(dfs(ly + dy[i],lx + dx[i],ry + dy[i],rx - dx[i])) return 1;\n\t\t\t}\n\t\t\telse if(lf[ly + dy[i]][lx + dx[i]] != '#' && rf[ry + dy[i]][rx - dx[i]] == '#' && f[ly + dy[i]][lx + dx[i]][ry][rx]){\n\t\t\t\tf[ly + dy[i]][lx + dx[i]][ry][rx] = 0;\n\t\t\t\tif(dfs(ly + dy[i],lx + dx[i],ry,rx)) return 1;\n\t\t\t}\n\t\t\telse if(lf[ly + dy[i]][lx + dx[i]] == '#' && rf[ry + dy[i]][rx - dx[i]] != '#' && f[ly][lx][ry + dy[i]][rx - dx[i]]){\n\t\t\t\tf[ly][lx][ry + dy[i]][rx - dx[i]] = 0;\n\t\t\t\tif(dfs(ly,lx,ry + dy[i],rx - dx[i])) return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(void){\n\tint i, j;\n\tP rs, ls;\n\twhile(1){\n\t\tscanf(\"%d%d%*c\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tlf[i][j] = getchar();\n\t\t\t\tif(lf[i][j] == 'L'){\n\t\t\t\t\tls = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(lf[i][j] == '%'){\n\t\t\t\t\tlg = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 空白読み飛ばし\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\trf[i][j] = getchar();\n\t\t\t\tif(rf[i][j] == 'R'){\n\t\t\t\t\trs = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(rf[i][j] == '%'){\n\t\t\t\t\trg = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 改行文字読み飛ばし\n\t\t}\n\t\tmemset(f,-1,sizeof(f));\n\t\tf[ls.first][ls.second][rs.first][rs.second] = 0;\n\t\tif(dfs(ls.first,ls.second,rs.first,rs.second))\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\nconst ld eps=1e-8;\nint d1[4] = { 1,0,-1,0 };\nint d2[4] = { 0,1,0,-1 };\nint d3[4] = { 0,-1,0,1 };\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h, w) {\n\t\tchar fi1[52][52]; char fi2[52][52];\n\t\trep(i, 52) {\n\t\t\trep(j, 52) {\n\t\t\t\tfi1[i][j] = fi2[i][j] = '#';\n\t\t\t}\n\t\t}\n\t\tstring s, t;\n\t\tP s1, s2, g1, g2;\n\t\trep1(i, h) {\n\t\t\tcin >> s >> t;\n\t\t\trep1(j, w) {\n\t\t\t\tfi1[i][j] = s[j - 1];\n\t\t\t\tif (fi1[i][j] == '%') {\n\t\t\t\t\tg1 = { i,j };\n\t\t\t\t}\n\t\t\t\telse if (fi1[i][j] == 'L') {\n\t\t\t\t\ts1 = { i,j };\n\t\t\t\t}\n\t\t\t}\n\t\t\trep1(j, w) {\n\t\t\t\tfi2[i][j] = t[j - 1];\n\t\t\t\tif (fi2[i][j] == '%') {\n\t\t\t\t\tg2 = { i,j };\n\t\t\t\t}\n\t\t\t\telse if (fi2[i][j] == 'R') {\n\t\t\t\t\ts2 = { i,j };\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint used[52][52][52][52] = {};\n\t\tvector<pair<P, P>> v;\n\t\tbool f = false;\n\t\tv.push_back({ s1, s2 });\n\t\tused[s1.first][s1.second][s2.first][s2.second] = 1;\n\t\twhile (!v.empty()) {\n\t\t\tP n1 = v[0].first; P n2 = v[0].second; v.erase(v.begin());\n\t\t\tif (n1 == g1 && n2 == g2) {\n\t\t\t\tf = true; break;\n\t\t\t}\n\t\t\telse if (n1 == g1 || n2 == g2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trep(i, 4) {\n\t\t\t\tP nex1 = { n1.first + d1[i],n1.second + d2[i] };\n\t\t\t\tP nex2 = { n2.first + d1[i],n2.second + d3[i] };\n\t\t\t\tif (fi1[nex1.first][nex1.second] == '#') {\n\t\t\t\t\tnex1 = n1;\n\t\t\t\t}\n\t\t\t\tif (fi2[nex2.first][nex2.second] == '#') {\n\t\t\t\t\tnex2 = n2;\n\t\t\t\t}\n\t\t\t\tif (used[nex1.first][nex1.second][nex2.first][nex2.second] == 0) {\n\t\t\t\t\tused[nex1.first][nex1.second][nex2.first][nex2.second] = 1;\n\t\t\t\t\tv.push_back({ nex1,nex2 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (f) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"tune=native\")\n#pragma GCC target (\"avx\")\n\n#include <bits/stdc++.h>\n\n// 汎用マクロ\n#define ALL_OF(x) (x).begin(), (x).end()\n#define REP(i,n) for (long long i=0, i##_len=(n); i<i##_len; i++)\n#define RANGE(i,is,ie) for (long long i=(is), i##_end=(ie); i<=i##_end; i++)\n#define DSRNG(i,is,ie) for (long long i=(is), i##_end=(ie); i>=i##_end; i--)\n#define UNIQUE(v) { sort((v).begin(), (v).end()); (v).erase(unique((v).begin(), (v).end()), (v).end()); }\ntemplate<class T> bool chmax(T &a, const T &b) {if (a < b) {a = b; return 1;} return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) {if (a > b) {a = b; return 1;} return 0; }\n#define INF 0x7FFFFFFF\n#define LINF 0x7FFFFFFFFFFFFFFFLL\n#define Yes(q) (q ? \"Yes\" : \"No\")\n#define YES(q) (q ? \"YES\" : \"NO\")\n#define DUMP(q) cerr << \"[DEBUG] \" #q \": \" << (q) << \" at \" __FILE__ \":\" << __LINE__ << endl\n#define DUMPALL(q) cerr << \"[DEBUG] \" #q \": [\"; REP(dumpall_i, (q).size()) { cerr << q[dumpall_i] << (dumpall_i == (q).size() - 1 ? \"\" : \", \"); } cerr << \"] at \" __FILE__ \":\" << __LINE__ << endl\n\n// gcc拡張マクロ\n#define gcd __gcd\n#define popcount __builtin_popcount\n#define popcountll __builtin_popcountll\n\n// エイリアス\nusing  ll = long long;\nusing ull = unsigned long long;\nusing  ld = long double;\nusing namespace std;\n\n// モジュール\n\n\n// 処理内容\nint main() {\n    \n    ll w, h;\n    while (cin >> w >> h, w && h) {\n\n        vector<string> rl(h), rr(h);\n        REP(i, h) cin >> rl[i] >> rr[i];\n        ll lsy, lsx, rsy, rsx;\n        ll lgy, lgx, rgy, rgx;\n        REP(i, h) REP(j, w) {\n            if (rl[i][j] == '%') {\n                lsy = i;\n                lsx = j;\n            } else if (rl[i][j] == 'L') {\n                lgy = i;\n                lgx = j;\n            }\n            if (rr[i][j] == '%') {\n                rsy = i;\n                rsx = j;\n            } else if (rr[i][j] == 'R') {\n                rgy = i;\n                rgx = j;\n            }\n        }\n\n        // {ly, lx, ry, rx}\n        deque<tuple<ll,ll,ll,ll>> q;\n        vector<vector<vector<vector<bool>>>> visited(h, vector<vector<vector<bool>>>(w, vector<vector<bool>>(h, vector<bool>(w, false))));\n        q.emplace_back(lsy, lsx, rsy, rsx);\n        visited[lsy][lsx][rsy][rsx] = true;\n        while (!q.empty()) {\n\n            ll ly = get<0>(q.front());\n            ll lx = get<1>(q.front());\n            ll ry = get<2>(q.front());\n            ll rx = get<3>(q.front());\n            q.pop_front();\n\n            // Lin and Ren go upward\n            if (ly > 0 && ry > 0) {\n                ll ly2 = rl[ly - 1][lx] != '#' ? ly - 1 : ly;\n                ll lx2 = lx;\n                ll ry2 = rr[ry - 1][lx] != '#' ? ry - 1 : ry;\n                ll rx2 = rx;\n                if (!visited[ly2][lx2][ry2][rx2]) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n                if (ry < h-1) if (rr[rx][ry+1] == '#') {\n                    ll ry2 = ry;\n                    if (!visited[ly2][lx2][ry2][rx2]) {\n                        q.emplace_back(ly2, lx2, ry2, rx2);\n                        visited[ly2][lx2][ry2][rx2] = true;\n                    }\n                }\n                if (ly < h-1) if (rl[rx][ry+1] == '#') {\n                    ll ly2 = ly;\n                    if (!visited[ly2][lx2][ry2][rx2]) {\n                        q.emplace_back(ly2, lx2, ry2, rx2);\n                        visited[ly2][lx2][ry2][rx2] = true;\n                    }\n                }\n            }\n\n            // Lin and Ren go downward\n            if (ly < h-1 && ry < h-1) {\n                ll ly2 = rl[ly + 1][lx] != '#' ? ly + 1 : ly;\n                ll lx2 = lx;\n                ll ry2 = rr[ry + 1][lx] != '#' ? ry + 1 : ry;\n                ll rx2 = rx;\n                if (!visited[ly2][lx2][ry2][rx2]) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n                if (ry > 0) if (rr[rx][ry-1] == '#') {\n                    ll ry2 = ry;\n                    if (!visited[ly2][lx2][ry2][rx2]) {\n                        q.emplace_back(ly2, lx2, ry2, rx2);\n                        visited[ly2][lx2][ry2][rx2] = true;\n                    }\n                }\n                if (ly > 0) if (rl[rx][ry-1] == '#') {\n                    ll ly2 = ly;\n                    if (!visited[ly2][lx2][ry2][rx2]) {\n                        q.emplace_back(ly2, lx2, ry2, rx2);\n                        visited[ly2][lx2][ry2][rx2] = true;\n                    }\n                }\n            }\n\n            // Lin goes left and Ren goes right\n            if (lx > 0 && rx < w-1) {\n                ll ly2 = ly;\n                ll lx2 = rl[ly][lx - 1] != '#' ? lx - 1 : lx;\n                ll ry2 = ry;\n                ll rx2 = rr[ry][rx + 1] != '#' ? rx + 1 : rx;\n                if (!visited[ly2][lx2][ry2][rx2]) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n                if (lx < w-1) if (rl[ly][lx+1] == '#') {\n                    ll lx2 = lx;\n                    if (!visited[ly2][lx2][ry2][rx2]) {\n                        q.emplace_back(ly2, lx2, ry2, rx2);\n                        visited[ly2][lx2][ry2][rx2] = true;\n                    }\n                }\n                if (rx > 0) if (rr[ry][rx-1] == '#') {\n                    ll rx2 = rx;\n                    if (!visited[ly2][lx2][ry2][rx2]) {\n                        q.emplace_back(ly2, lx2, ry2, rx2);\n                        visited[ly2][lx2][ry2][rx2] = true;\n                    }\n                }\n            }\n\n            // Lin goes right and Ren goes left\n            if (lx < w-1 && rx > 0) {\n                ll ly2 = ly;\n                ll lx2 = rl[ly][lx + 1] != '#' ? lx + 1 : lx;\n                ll ry2 = ry;\n                ll rx2 = rr[ry][rx - 1] != '#' ? rx - 1 : rx;\n                if (!visited[ly2][lx2][ry2][rx2]) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n                if (lx > 0) if (rl[ly][lx-1] == '#') {\n                    ll lx2 = lx;\n                    if (!visited[ly2][lx2][ry2][rx2]) {\n                        q.emplace_back(ly2, lx2, ry2, rx2);\n                        visited[ly2][lx2][ry2][rx2] = true;\n                    }\n                }\n                if (rx < w-1) if (rr[ry][rx+1] == '#') {\n                    ll rx2 = rx;\n                    if (!visited[ly2][lx2][ry2][rx2]) {\n                        q.emplace_back(ly2, lx2, ry2, rx2);\n                        visited[ly2][lx2][ry2][rx2] = true;\n                    }\n                }\n            }\n\n        }\n\n        std::cout << Yes(visited[lgy][lgx][rgy][rgx]) << endl;\n\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<VVB> V3B;\ntypedef vector<V3B> V4B;\ntypedef vector<PII> VPII;\n\n#define Y first\n#define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst int DX[2][4]={{1,0,-1,0}, {-1, 0, 1, 0}};\nconst int DY[2][4]={{0,-1,0,1}, {0, -1, 0, 1}};\n\nint W, H;\nVVS tss;\n\nPII find_start(VS &ts, char c) {\n\tfor (int y = 0; y < H; y++) {\n\t\tfor (int x = 0; x < W; x++) {\n\t\t\tif (ts[y][x] == c) {\n\t\t\t\treturn MP(y, x);\n\t\t\t}\n\t\t}\n\t}\n\texit(1);\n}\n\nbool solve() {\n\tqueue<vector<PII>> qs;\n\tV4B dones(H, V3B(W, VVB(H, VB(W))));\n\n\tqs.push({find_start(tss[0], 'L'), find_start(tss[1], 'R')});\n\n\twhile (qs.size()) {\n\t\tauto q = qs.front();\n\t\tPII a = q[0];\n\t\tPII b = q[1];\n\t\tqs.pop();\n\n\t\tif (dones[a.Y][a.X][b.Y][b.X]) { continue; }\n\t\telse { dones[a.Y][a.X][b.Y][b.X] = true; }\n\n\t\tbool g1 = tss[0][a.Y][a.X] == '%';\n\t\tbool g2 = tss[1][b.Y][b.X] == '%';\n\t\tif (g1 && g2) { // ????????°???\n\t\t\treturn true;\n\t\t} else if (g1 ^ g2) { // ????????°???\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (int di = 0; di < 4; di++) {\n\t\t\tVPII ns(2);\n\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\tint x = q[i].X + DX[i][di];\n\t\t\t\tint y = q[i].Y + DY[i][di];\n\n\t\t\t\tif (!RANGE(x, y, W, H) || tss[i][y][x] == '#') {\n\t\t\t\t\tx = q[i].X;\n\t\t\t\t\ty = q[i].Y;\n\t\t\t\t}\n\n\t\t\t\tns[i].X = x;\n\t\t\t\tns[i].Y = y;\n\t\t\t}\n\n\t\t\tqs.push(ns);\n\t\t}\n\t}\n\n\treturn false;\n\n}\n\nint main(void) {\n\twhile (cin >> W >> H, W) {\n\t\ttss = VVS(2, VS(H));\n\n\t\tfor (int y = 0; y < H; y++) {\n\t\t\tcin >> tss[0][y] >> tss[1][y];\n\t\t}\n\n\t\tcout << (solve() ? \"Yes\" : \"No\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nbool d[55][55][55][55];\n\nint main() {\n    int n, m;\n    while (cin >> n >> m, n || m) {\n        vector<string> G1(m), G2(m);\n        queue<P> que1, que2;\n        for (int i = 0; i < 55; i++)\n            for (int j = 0; j < 55; j++)\n                for (int l = 0; l < 55; l++)\n                    for (int k = 0; k < 55; k++)\n                        d[i][j][k][l] = true;\n        for (int i = 0; i < m; i++) {\n            cin >> G1[i] >> G2[i];\n            for (int j = 0; j < n; j++) {\n                if (G1[i][j] == 'L') que1.push(P(i, j));\n                if (G2[i][j] == 'R') que2.push(P(i, j));\n            }\n        }\n\n        d[que1.front().first][que1.front().second][que2.front().first][que2.front().second] = false;\n\n        bool res = false;\n        while (1) {\n            if (!que1.size() || !que2.size()) break;\n            P p1 = que1.front(); que1.pop();\n            P p2 = que2.front(); que2.pop();\n            if (G1[p1.first][p1.second] == '%' && G2[p2.first][p2.second] == '%') {\n                res = true;\n                break;\n            }\n\n            int x1 = p1.first;\n            int x2 = p2.first;\n            int y2 = p2.second;\n            int y1 = p1.second;\n            for (int i = 0; i < 4; i++) {\n                int nx1 = x1 + dx[i];\n                int ny1 = y1 + dy[i];\n                int nx2 = x2 + dx[i];\n                int ny2 = y2 - dy[i];\n\n                if ( nx1 < 0 || nx1 >= m || ny1 < 0 || ny1 >= n || G1[nx1][ny1] == '#') nx1 = x1, ny1 = y1;\n                if ( nx2 < 0 || nx2 >= m || ny2 < 0 || ny2 >= n || G2[nx2][ny2] == '#') nx2 = x2, ny2 = y2;\n\n                if (d[nx1][ny1][nx2][ny2]) {\n                    d[nx1][ny1][nx2][ny2] = false;\n                    que1.push(P(nx1, ny1));\n                    que2.push(P(nx2, ny2));\n                }\n            }\n        }\n\n        cout << (res ? \"Yes\" : \"No\") << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> P;\n\nstruct state{\n    int ly, lx, ry, rx;\n};\nint w, h;\nbool contain(int y, int x){\n    return (0 <= y && y < h && 0 <= x && x < w);\n}\nint dy[4] = {1, -1, 0, 0};\nint dx[4] = {0, 0, 1, -1};\nbool f[51][51][51][51];\n\nsigned main(){\n    while(1){\n        cin >> w >> h;\n        if(w + h == 0) break;\n        vector<string> s(h), t(h);\n        bool ans = false;\n        int lsy, lsx, lgy, lgx, rsy, rsx, rgy, rgx;\n        rep(i, 0, h){\n            cin >> s[i] >> t[i];\n            rep(j, 0, w){\n                if(s[i][j] == 'L'){ lsy = i; lsx = j;}\n                if(s[i][j] == '%'){ lgy = i; lgx = j;}\n                if(t[i][j] == 'R'){ rsy = i; rsx = j;}\n                if(t[i][j] == '%'){ rgy = i; rgx = j;}\n            }\n        }\n        queue<state> q;\n        q.push((state){lsy, lsx, rsy, rsx});\n        rep(i, 0, 51) rep(j, 0, 51) rep(k, 0, 51) rep(l, 0, 51) f[i][j][k][l] = false;\n        f[lsy][lsx][rsy][rsx] = true;\n        while(!q.empty()){\n            state p = q.front(); q.pop();\n            // cout << p.ly << \" \" << p.lx << \" \" << p.ry << \" \" << p.rx << endl;\n            rep(i, 0, 4){\n                int nly = p.ly + dy[i];\n                int nlx = p.lx + dx[i];\n                int nry = p.ry + dy[i];\n                int nrx = p.rx - dx[i];\n                if(!contain(nly, nlx) || s[nly][nlx] == '#'){ nly = p.ly; nlx = p.lx;}\n                if(!contain(nry, nrx) || t[nry][nrx] == '#'){ nry = p.ry; nrx = p.rx;}\n                if(f[nly][nlx][nry][nrx]) continue;\n                f[nly][nlx][nry][nrx] = true;\n                if(s[nly][nlx] == '%' && t[nry][nrx] == '%'){ ans = true; break;}\n                else if(s[nly][nlx] == '%' || t[nry][nrx] == '%') continue;\n                q.push((state){nly, nlx, nry, nrx});\n            }\n            if(ans == true) break;\n        }\n        cout << (ans ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <utility>\n#include <cstring>\n\nusing namespace std;\n\nconst int dx[] = { -1, 0, 1, 0 };\nconst int dy[] = { 0, -1, 0, 1 };\n\nint memo[52][52][52][52];\n\nint recur(const vector<string> &field, int W, int H, int rx, int ry, int lx, int ly){\n\tif(memo[rx - W - 1][ry][lx][ly]){ return 0; }\n\tmemo[rx - W - 1][ry][lx][ly] = 1;\n\tif(rx == lx && ry == ly){ return 0; }\n\tif(field[ry][rx] == '%' && field[ly][lx] == '%'){ return 1; }\n\tint answer = 0;\n\tfor(int i = 0; answer == 0 && i < 4; ++i){\n\t\tint nrx = rx + dx[i], nry = ry + dy[i];\n\t\tint nlx = lx - dx[i], nly = ly + dy[i];\n\t\tif(field[nry][nrx] == '#'){ nrx -= dx[i]; nry -= dy[i]; }\n\t\tif(field[nly][nlx] == '#'){ nlx += dx[i]; nly -= dy[i]; }\n\t\tanswer = recur(field, W, H, nrx, nry, nlx, nly);\n\t}\n\treturn answer;\n}\n\nint main(){\n\twhile(true){\n\t\tint W, H;\n\t\tcin >> W >> H;\n\t\tif(W == 0 && H == 0){ break; }\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tvector<string> field(H + 2);\n\t\tfield[0] = field[H + 1] = string(W * 2 + 3, '#');\n\t\tint rx, ry, lx, ly;\n\t\tfor(int i = 1; i <= H; ++i){\n\t\t\tstring l1, l2;\n\t\t\tcin >> l1 >> l2;\n\t\t\tstring line = \"#\" + l1 + \"#\" + l2 + \"#\";\n\t\t\tfor(int j = 0; j < line.size(); ++j){\n\t\t\t\tif(line[j] == 'R'){\n\t\t\t\t\trx = j; ry = i;\n\t\t\t\t}else if(line[j] == 'L'){\n\t\t\t\t\tlx = j; ly = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfield[i] = line;\n\t\t}\n\t\tcout << (recur(field, W, H, rx, ry, lx, ly) ? \"Yes\" : \"No\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct P{\n\tint x;\n\tint y;\n};\n\nstruct St{\n\tP ln;\n\tP rn;\n};\n\nint xdir[4] = {0, 1, 0, -1}, ydir[4] = {1, 0, -1, 0};\n\nbool bfs(char la[51][51], char ra[51][51], int w, int h, P len, P rin)\n{\n\tbool f = false, vis[51][51][51][51];\n\tfill(&vis[0][0][0][0], &vis[50][50][50][50], true);\n\tSt s, t;\n\tP l, r, u, v;\n\tqueue<St> que;\n\ts.ln = len;\n\ts.rn = rin;\n\tque.push(s);\n\tvis[len.y][len.x][rin.y][rin.x] = false;\n\twhile(!que.empty()){\n\t\ts = que.front();\n\t\tque.pop();\n\t\tl = s.ln;\n\t\tr = s.rn;\n\t\tif(la[l.y][l.x] == '%' && ra[r.y][r.x] == '%'){\n\t\t\tf = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tu.y = l.y+ydir[i];\n\t\t\tu.x = l.x+xdir[i];\n\t\t\tv.y = r.y+ydir[i];\n\t\t\tv.x = r.x-xdir[i];\n\t\t\tif(u.y < 0 || u.y >= h || u.x < 0 || u.x >= w){\n\t\t\t\tu.y = l.y;\n\t\t\t\tu.x = l.x;\n\t\t\t}\n\t\t\tif(la[u.y][u.x] == '#'){\n\t\t\t\tu.y = l.y;\n\t\t\t\tu.x = l.x;\n\t\t\t}\n\t\t\tif(v.y < 0 || v.y >= h || v.x < 0 || v.x >= w){\n\t\t\t\tv.y = r.y;\n\t\t\t\tv.x = r.x;\n\t\t\t}\n\t\t\tif(ra[v.y][v.x] == '#'){\n\t\t\t\tv.y = r.y;\n\t\t\t\tv.x = r.x;\n\t\t\t}\n\t\t\tif(vis[u.y][u.x][v.y][v.x]){\n\t\t\t\tvis[u.y][u.x][v.y][v.x] = false;\n\t\t\t\tt.ln = u;\n\t\t\t\tt.rn = v;\n\t\t\t\tque.push(t);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn f;\n}\n\nint main()\n{\n\tint w, h;\n\tchar ra[51][51], la[51][51];\n\tP rin, len;\n\t\n\twhile(cin>>w>>h && (w+h)){\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> la[i][j];\n\t\t\t\tif(la[i][j] == 'L'){\n\t\t\t\t\tlen.y = i;\n\t\t\t\t\tlen.x = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> ra[i][j];\n\t\t\t\tif(ra[i][j] == 'R'){\n\t\t\t\t\trin.y = i;\n\t\t\t\t\trin.x = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(bfs(la, ra, w, h, len, rin)){\n\t\t\tcout << \"Yes\"<< endl;\n\t\t} else {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <tuple>\n#include <string>\n#include <cstring>\n#include <iostream>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nconst int dx1[4] = { 0, 1, 0, -1 };\nconst int dy1[4] = { -1, 0, 1, 0 };\nconst int dx2[4] = { 0, -1, 0, 1 };\nconst int dy2[4] = { -1, 0, 1, 0 };\n\nint H, W; string L[50], R[50];\n\nbool used[50][50][50][50];\n\nbool over(int x, int y)\n{\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\nbool solve(int x1, int y1, int x2, int y2)\n{\n\tqueue<tuple<int, int, int, int> > que;\n\n\tque.push(make_tuple(y1, x1, y2, x2));\n\n\tused[y1][x1][y2][x2] = true;\n\n\twhile (!que.empty())\n\t{\n\t\tint ly = get<0>(que.front());\n\t\tint lx = get<1>(que.front());\n\t\tint ry = get<2>(que.front());\n\t\tint rx = get<3>(que.front());\n\n\t\tque.pop();\n\n\t\tif (L[ly][lx] == '%' && R[ry][rx] == '%') return true;\n\n\t\tif (L[ly][lx] == '%') continue;\n\t\tif (R[ry][rx] == '%') continue;\n\n\t\tbool ok = false;\n\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\tint ltx = lx + dx1[i];\n\t\t\tint lty = ly + dy1[i];\n\t\t\tint rtx = rx + dx2[i];\n\t\t\tint rty = ry + dy2[i];\n\n\t\t\tif (over(ltx, lty) && over(rtx, rty))\n\t\t\t{\n\t\t\t\tif (L[lty][ltx] == '#')\n\t\t\t\t{\n\t\t\t\t\tltx -= dx1[i];\n\t\t\t\t\tlty -= dy1[i];\n\t\t\t\t}\n\n\t\t\t\tif (R[rty][rtx] == '#')\n\t\t\t\t{\n\t\t\t\t\trtx -= dx2[i];\n\t\t\t\t\trty -= dy2[i];\n\t\t\t\t}\n\n\t\t\t\tif (!used[lty][ltx][rty][rtx])\n\t\t\t\t{\n\t\t\t\t\tused[lty][ltx][rty][rtx] = true;\n\n\t\t\t\t\tque.push(make_tuple(lty, ltx, rty, rtx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &W);\n\t\tscanf(\"%d\", &H);\n\n\t\tif (W == 0 && H == 0) break;\n\n\t\tfor (int i = 0; i < H; i++) cin >> L[i] >> R[i];\n\n\t\tint lx, ly, rx, ry;\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (L[i][j] == 'L')\n\t\t\t\t{\n\t\t\t\t\tlx = j;\n\t\t\t\t\tly = i;\n\t\t\t\t}\n\n\t\t\t\tif (R[i][j] == 'R')\n\t\t\t\t{\n\t\t\t\t\trx = j;\n\t\t\t\t\try = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(used, false, sizeof(used));\n\n\t\tprintf(\"%s\\n\", solve(lx, ly, rx, ry) ? \"Yes\" : \"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\ntemplate <class T, class U, class V>\ninline T clamp(const T& x, const U& lo, const V& hi) { return x < lo ? lo : x > hi ? hi : x; }\n\nbool solve(int W, int H, const vector<string>& RoomL, const vector<string>& RoomR) {\n    int sxL, syL, sxR, syR;\n    rep(i, H) rep(j, W) {\n        if (RoomL[i][j] == 'L') sxL = i, syL = j;\n        if (RoomR[i][j] == 'R') sxR = i, syR = j;\n    }\n    bool vis[W][H][W][H];\n    memset(vis, 0, W * H * W * H);\n    vis[sxL][syL][sxR][syR] = true;\n    queue<tuple<int, int, int, int>> Q;\n    for (Q.emplace(sxL, syL, sxR, syR); !Q.empty();) {\n        int xL, yL, xR, yR; tie(xL, yL, xR, yR) = Q.front(); Q.pop();\n        rep(k, 4) {\n            int nxL = clamp(xL + dx[k], 0, H - 1), nyL = clamp(yL + dy[k], 0, W - 1),\n                nxR = clamp(xR + dx[k], 0, H - 1), nyR = clamp(yR - dy[k], 0, W - 1);\n            if (RoomL[nxL][nyL] == '#' and RoomR[nxR][nyR] == '#') continue;\n            if (RoomL[nxL][nyL] == '#') nxL -= dx[k], nyL -= dy[k];\n            if (RoomR[nxR][nyR] == '#') nxR -= dx[k], nyR += dy[k];\n            if (RoomL[nxL][nyL] == '%' and RoomR[nxR][nyR] == '%') return true;\n            if (RoomL[nxL][nyL] == '%' or RoomR[nxR][nyR] == '%' or vis[nxL][nyL][nxR][nyR]) continue;\n            vis[nxL][nyL][nxR][nyR] = true;\n            Q.emplace(nxL, nyL, nxR, nyR);\n        }\n    }\n    return false;\n}\n\nint main() {\n    for (int W, H; cin >> W >> H, W | H;) {\n        vector<string> RoomL(H), RoomR(H);\n        rep(i, H) cin >> RoomL[i] >> RoomR[i];\n        cout << (solve(W, H, RoomL, RoomR) ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nint dx[4] = {1, 0,-1, 0};\nint dy[4] = {0, 1, 0,-1};\nstruct info{\n\tint lx, ly, rx, ry;\n\tinfo(int lx, int ly, int rx, int ry):\n\t\tlx(lx), ly(ly), rx(rx), ry(ry){}\n};\n\nint main(){\n\twhile(1){\n\t\tint w,h;\n\t\tcin >> w >> h;\n\t\tif(w==0) break;\n\t\t\n\t\tvector<vector<char> > l(h+2, vector<char>(w+2, '#'));\n\t\tvector<vector<char> > r(h+2, vector<char>(w+2, '#'));\n\t\tvector<vector<bool> > used(h*w, vector<bool>(h*w, false));\n\t\tint lx,ly, rx,ry;\n\t\tfor(int i=1; i<=h; i++){\n\t\t\tfor(int j=1; j<=w; j++){\n\t\t\t\tcin >> l[i][j];\n\t\t\t\tif(l[i][j]=='L'){\n\t\t\t\t\tlx = j;\n\t\t\t\t\tly = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=1; j<=w; j++){\n\t\t\t\tcin >> r[i][j];\n\t\t\t\tif(r[i][j]=='R'){\n\t\t\t\t\trx = j;\n\t\t\t\t\try = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<info> search;\n\t\tsearch.push(info(lx, ly, rx, ry));\n\t\tbool success = false;\n\t\twhile(!search.empty()){\n\t\t\tint lx = search.front().lx;\n\t\t\tint ly = search.front().ly;\n\t\t\tint rx = search.front().rx;\n\t\t\tint ry = search.front().ry;\n\t\t\tsearch.pop();\n\t\t\tif(used[(ly-1)*w+(lx-1)][(ry-1)*w+(rx-1)]) continue;\n\t\t\tused[(ly-1)*w+(lx-1)][(ry-1)*w+(rx-1)] = true;\n\t\t\tif(l[ly][lx]=='%'){\n\t\t\t\tif(r[ry][rx]=='%'){\n\t\t\t\t\tsuccess = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}else if(r[ry][rx]=='%'){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\tint nlx = lx+dx[i], nly = ly+dy[i];\n\t\t\t\tint nrx, nry;\n\t\t\t\tif(i%2==0){\n\t\t\t\t\tnrx = rx+dx[(i+2)%4];\n\t\t\t\t\tnry = ry+dy[(i+2)%4];\n\t\t\t\t}else{\n\t\t\t\t\tnrx = rx+dx[i];\n\t\t\t\t\tnry = ry+dy[i];\n\t\t\t\t}\n\t\t\t\tint uc=0;\n\t\t\t\tif(l[nly][nlx]=='#'){\n\t\t\t\t\tnlx = lx;\n\t\t\t\t\tnly = ly;\n\t\t\t\t\tuc++;\n\t\t\t\t}\n\t\t\t\tif(r[nry][nrx]=='#'){\n\t\t\t\t\tnrx = rx;\n\t\t\t\t\tnry = ry;\n\t\t\t\t\tuc++;\n\t\t\t\t}\n\t\t\t\tif(uc==2) continue;\n\t\t\t\tsearch.push(info(nlx, nly, nrx, nry));\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(success){\n\t\t\tcout << \"Yes\" << endl;\n\t\t}else{\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*** ???????????? ***/\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, a, n) for(int i=a; i<n; i++)\n\nstruct State{\n\tint xL, yL, xR, yR;\n};\n\nint main(){\n\tint w, h;\n\t\n\tint dx[4]={0, 1, 0, -1}; // ????????????\n\tint dy[4]={-1, 0, 1, 0};\n\t\n\twhile(cin>>w>>h, w||h){\n\t\tState st;\n\t\tchar Len[51][51];\n\t\tchar Rin[51][51];\n\t\tbool hist[51][51][51][51]={false};\n\t\t\n\t\tREP(i, 0, h){\n\t\t\tREP(j, 0, w){\n\t\t\t\tcin >> Len[i][j];\n\t\t\t\tif(Len[i][j]=='L'){\n\t\t\t\t\tst.yL=i;\n\t\t\t\t\tst.xL=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(j, 0, w){\n\t\t\t\tcin >> Rin[i][j];\n\t\t\t\tif(Rin[i][j]=='R'){\n\t\t\t\t\tst.yR=i;\n\t\t\t\t\tst.xR=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqueue<State> qu;\n\t\tqu.push(st);\n\t\thist[st.yL][st.xL][st.yR][st.xR]=true;\n\t\tbool flag=false;\n\t\t\n\t\twhile(!qu.empty()){\n\t\t\t//pair<int, int> q=qu.front();\n\t\t\tState q=qu.front();\n\t\t\tqu.pop();\n\t\t\t\n\t\t\tint yl=q.yL, xl=q.xL, yr=q.yR, xr=q.xR;\n\t\t\tif(Len[yl][xl]=='%' && Rin[yr][xr]=='%'){\n\t\t\t\tflag=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//int y=q.first, x=q.second;\n\t\t\tfor(int k=0; k<4; ++k){\n\t\t\t\tint yyl=yl+dy[k], xxl=xl+dx[k];\n\t\t\t\tint yyr=yyl, xxr=xxl;\n\t\t\t\tif(k%2==1){\n\t\t\t\t\tyyr=yr+dy[k]*(-1);\n\t\t\t\t\txxr=xr+dx[k]*(-1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(yyl<0 || yyl>=h || xxl<0 || xxl>=w || Len[yyl][xxl]=='#'){\n\t\t\t\t\tyyl=yl;\n\t\t\t\t\txxl=xl;\n\t\t\t\t}\n\t\t\t\tif(yyr<0 || yyr>=h || xxr<0 || xxr>=w || Rin[yyr][xxr]=='#'){\n\t\t\t\t\tyyr=yr;\n\t\t\t\t\txxr=xr;\n\t\t\t\t}\n\t\t\t\tif(hist[yyl][xxl][yyr][xxr]) continue;\n\t\t\t\thist[yyl][xxl][yyr][xxr]=true;\n\t\t\t\tqu.push({yyl, xxl, yyr, xxr});\n\t\t\t}\n\t\t}\n\t\tif(flag) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <utility>\n#include <cstring>\n\nusing namespace std;\n\nconst int dx[] = { -1, 0, 1, 0 };\nconst int dy[] = { 0, -1, 0, 1 };\n\nint memo[52][103][52][103];\n\nint recur(const vector<string> &field, int rx, int ry, int lx, int ly){\n\tif(memo[rx][ry][lx][ly]){ return 0; }\n\tmemo[rx][ry][lx][ly] = 1;\n\tif(rx == lx && ry == ly){ return 0; }\n\tif(field[ry][rx] == '%' && field[ly][lx] == '%'){ return 1; }\n\tint answer = 0;\n\tfor(int i = 0; answer == 0 && i < 4; ++i){\n\t\tint nrx = rx + dx[i], nry = ry + dy[i];\n\t\tint nlx = lx - dx[i], nly = ly + dy[i];\n\t\tif(field[nry][nrx] == '#'){ nrx -= dx[i]; nry -= dy[i]; }\n\t\tif(field[nly][nlx] == '#'){ nlx += dx[i]; nly -= dy[i]; }\n\t\tanswer = recur(field, nrx, nry, nlx, nly);\n\t}\n\treturn answer;\n}\n\nint main(){\n\twhile(true){\n\t\tint W, H;\n\t\tcin >> W >> H;\n\t\tif(W == 0 && H == 0){ break; }\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tvector<string> field(H + 2);\n\t\tfield[0] = field[H + 1] = string(W * 2 + 3, '#');\n\t\tint rx, ry, lx, ly;\n\t\tfor(int i = 1; i <= H; ++i){\n\t\t\tstring l1, l2;\n\t\t\tcin >> l1 >> l2;\n\t\t\tstring line = \"#\" + l1 + \"#\" + l2 + \"#\";\n\t\t\tfor(int j = 0; j < line.size(); ++j){\n\t\t\t\tif(line[j] == 'R'){\n\t\t\t\t\trx = j; ry = i;\n\t\t\t\t}else if(line[j] == 'L'){\n\t\t\t\t\tlx = j; ly = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfield[i] = line;\n\t\t}\n\t\tcout << (recur(field, rx, ry, lx, ly) ? \"Yes\" : \"No\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\nchar fieldL[51][51];\nchar fieldR[51][51];\n\nbool isArrival[51][51][51][51];\nint h,w;\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\n\nvoid bfs(int slx,int sly,int srx,int sry){\n\tqueue<pair<int,int> > *prvL=new queue<pair<int,int> >();\n\tqueue<pair<int,int> > *nxtL=new queue<pair<int,int> >();\n\tqueue<pair<int,int> > *prvR=new queue<pair<int,int> >();\n\tqueue<pair<int,int> > *nxtR=new queue<pair<int,int> >();\n\tprvL->push(make_pair(sly,slx));\n\tprvR->push(make_pair(sry,srx));\n\twhile(prvL->size()){\n\t\twhile(prvL->size()){\n\t\t\tpair<int,int> pl=prvL->front();prvL->pop();\n\t\t\tpair<int,int> pr=prvR->front();prvR->pop();\n\t\t\tint ly=pl.first;int lx=pl.second;\n\t\t\tint ry=pr.first;int rx=pr.second;\n\t\t\tif(isArrival[ly][lx][ry][rx])\n\t\t\t\tcontinue;\n\t\t\tisArrival[ly][lx][ry][rx]=true;\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint nly=max(0,min(h-1,ly+dy[i]));\n\t\t\t\tint nlx=max(0,min(h-1,lx+dx[i]));\n\t\t\t\tint nry=max(0,min(h-1,ry+dy[i]));\n\t\t\t\tint nrx=max(0,min(h-1,rx-dx[i]));\n\t\t\t\tif(fieldL[nly][nlx]=='#'){\n\t\t\t\t\tnly=ly;\n\t\t\t\t\tnlx=lx;\n\t\t\t\t}\n\t\t\t\tif(fieldL[nry][nrx]=='#'){\n\t\t\t\t\tnry=ry;\n\t\t\t\t\tnrx=rx;\n\t\t\t\t}\n\t\t\t\tif(!isArrival[nly][nlx][nry][nrx]){\n\t\t\t\t\tprvL->push(make_pair(nly,nlx));\n\t\t\t\t\tprvR->push(make_pair(nry,nrx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(prvL,nxtL);\n\t\tswap(prvR,nxtR);\n\t}\n\tdelete prvL,prvR,nxtL,nxtR;\n}\n\nint main(){\n\n\n\twhile(cin>>w>>h&&!(w==0&&h==0)){\n\tmemset(isArrival,0,sizeof(isArrival));\n\tint sly,slx,srx,sry;\n\tint fly,flx,frx,fry;\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tcin>>fieldL[i][j];\n\t\t\tif(fieldL[i][j]=='L'){\n\t\t\t\tfieldL[i][j]='.';\n\t\t\t\tsly=i;\n\t\t\t\tslx=j;\n\t\t\t}\n\t\t\telse if(fieldL[i][j]=='%'){\n\t\t\t\tfieldL[i][j]='.';\n\t\t\t\tfly=i;\n\t\t\t\tflx=j;\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tcin>>fieldR[i][j];\n\t\t\tif(fieldR[i][j]=='R'){\n\t\t\t\tfieldR[i][j]='.';\n\t\t\t\tsry=i;\n\t\t\t\tsrx=j;\n\t\t\t}\n\t\t\telse if(fieldR[i][j]=='%'){\n\t\t\t\tfieldL[i][j]='.';\n\t\t\t\tfry=i;\n\t\t\t\tfrx=j;\n\t\t\t}\n\t\t}\n\t}\n\tbfs(slx,sly,srx,sry);\n\tif(isArrival[fly][flx][fry][frx])\n\t\tcout<<\"Yes\"<<endl;\n\telse\n\t\tcout<<\"No\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <array>\n#include <algorithm>\n#include <utility>\n\n#define X first\n#define Y second\n\nusing namespace std;\n\narray<array<bool, 50>, 50> g_room[2]; // [Y][X]\narray<array<bool, 50>, 50> g_standed[2][2]; // ずれている時用\npair<int, int> g_goal[2];\npair<int, int> g_startpos[2];\n\nbool g_state;\n\nint dx1[4] = { 0, 1, 0, -1 };\nint dy1[4] = { 1, 0, -1, 0 };\n\nint dx2[4] = { 0, -1, 0, 1 };\nint dy2[4] = { 1, 0, -1, 0 };\n\n\nbool solution(pair<int, int> u1, pair<int, int> u2) {\n\tif (g_goal[0] == u1 && g_goal[1] == u2) return true;\n\tif (g_goal[0] == u1 || g_goal[1] == u2) return false;\n\t\n\tfor (int i = 0; i < 4; ++i) {\n\t\tauto nu2 = make_pair(u2.X + dx2[i], u2.Y + dy2[i]);\n\t\tauto nu1 = make_pair(u1.X + dx1[i], u1.Y + dy1[i]);\n\n\t\tif (g_room[0][nu1.Y][nu1.X] && g_room[1][nu2.Y][nu2.X]) {\n\t\t\tcontinue;\n\t\t} else if (g_room[0][nu1.Y][nu1.X]) {\n\t\t\tif (g_standed[!g_state][1][nu2.Y][nu2.X]) continue;\n\t\t\tg_state = !g_state;\n\t\t\tg_standed[g_state][1][nu2.Y][nu2.X] = true;\n\t\t\tif (solution(u1, nu2)) return true;\n\t\t\tg_standed[g_state][1][nu2.Y][nu2.X] = false;\n\t\t} else if (g_room[1][nu2.Y][nu2.X]) {\n\t\t\tif (g_standed[!g_state][0][nu1.Y][nu1.X]) continue;\n\t\t\tg_state = !g_state;\n\t\t\tg_standed[g_state][0][nu1.Y][nu1.X] = true;\n\t\t\tif (solution(nu1, u2)) return true;\n\t\t\tg_standed[g_state][0][nu1.Y][nu1.X] = false;\n\t\t} else {\n\t\t\tif (g_standed[g_state][0][nu1.Y][nu1.X]) continue;\n\t\t\tg_standed[g_state][0][nu1.Y][nu1.X] = true;\n\t\t\tg_standed[g_state][1][nu2.Y][nu2.X] = true;\n\t\t\tif (solution(nu1, nu2)) return true;\n\t\t\tg_standed[g_state][0][nu1.Y][nu1.X] = false;\n\t\t\tg_standed[g_state][1][nu2.Y][nu2.X] = false;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\twhile (true) {\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tif (w == 0) break;\n\n\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\tfor_each(g_room[i].begin(), g_room[i].end(), [](array<bool, 50> & line) {\n\t\t\t\tline.fill(false);\n\t\t\t});\n\t\t}\n\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\tfor_each(g_standed[i][j].begin(), g_standed[i][j].end(), [](array<bool, 50> & line) {\n\t\t\t\t\tline.fill(false);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < h + 1; ++i) {\n\t\t\tg_room[0][i][0] = true;\n\t\t\tg_room[0][i][w + 1] = true;\n\t\t\tg_room[1][i][0] = true;\n\t\t\tg_room[1][i][w + 1] = true;\n\t\t}\n\n\t\tfor (int j = 0; j < w + 1; ++j) {\n\t\t\tg_room[0][0][j] = true;\n\t\t\tg_room[0][h + 1][j] = true;\n\t\t\tg_room[1][0][j] = true;\n\t\t\tg_room[1][h + 1][j] = true;\n\t\t}\n\n\t\tfor (int i = 1; i < h + 1; ++i) {\n\t\t\tfor (int user = 0; user < 2; ++user) {\n\t\t\t\tfor (int j = 1; j < w+1; ++j) {\n\t\t\t\t\tchar c;\n\t\t\t\t\tcin >> c;\n\t\t\t\t\tif (c == '#') {\n\t\t\t\t\t\tg_room[user][i][j] = true;\n\t\t\t\t\t} else if (c == '%') {\n\t\t\t\t\t\tg_goal[user].X = j;\n\t\t\t\t\t\tg_goal[user].Y = i;\n\t\t\t\t\t} else if (c == 'L' || c == 'R') {\n\t\t\t\t\t\tg_startpos[user].X = j;\n\t\t\t\t\t\tg_startpos[user].Y = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (solution(g_startpos[0], g_startpos[1])) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t} else {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <stack>\n#include <queue>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n\nusing namespace std;\n\nint ldx[] = {1,0,-1,0}, ldy[] = {0,1,0,-1};\nint rdx[] = {-1,0,1,0}, rdy[] = {0,1,0,-1};\n\nint H, W;\nint slx, sly, srx, sry;\nstring rooml[55], roomr[55];\nbool flag;\n\nbool ls[55][55][55][55];\n/*\nvoid dfs(int lx, int ly, int rx, int ry){\n\t//cout<<lx<<\" \"<<ly<<\": \"<<rx<<\" \"<<ry<<endl;\n\tif(flag) return;\n\n\tif(rooml[ly][lx] == '%' && roomr[ry][rx] == '%') {\n\t\tflag = true;\n\t\treturn;\n\t}else if(rooml[ly][lx] == '%' || roomr[ry][rx] == '%') return;\n\n\tif(ls[lx][ly][rx][ry]) return;\n\tls[lx][ly][rx][ry] = true;\n\n\tREP(k,0,4){\n\t\tint nlx = lx + ldx[k], nly = ly + ldy[k];\n\t\tif(!CH(nly,0,H) || !CH(nlx,0,W)){\n\t\t\tnlx = lx;\n\t\t\tnly = ly;\n\t\t}else if(rooml[nly][nlx]=='#'){\n\t\t\tnlx = lx;\n\t\t\tnly = ly;\n\t\t}\n\n\t\tint nrx = rx + rdx[k], nry = ry + rdy[k];\n\t\tif(!CH(nry,0,H) || !CH(nrx,0,W)){\n\t\t\tnrx = rx;\n\t\t\tnry = ry;\n\t\t}else if(roomr[nry][nrx]=='#'){\n\t\t\tnrx = rx;\n\t\t\tnry = ry;\n\t\t}\n\t\tif(ls[nlx][nly][nrx][nry]) continue;\n\t\tdfs(nlx, nly, nrx, nry);\n\t}\n\treturn;\n}\n*/\n\nbool bfs(){\n\tqueue <int> lxq;\n\tqueue <int> lyq;\n\tqueue <int> rxq;\n\tqueue <int> ryq;\n\n\tlxq.push(slx);\n\tlyq.push(sly);\n\trxq.push(srx);\n\tryq.push(sry);\n\n\twhile(!lxq.empty()){\n\t\tint lx = lxq.front();\n\t\tint ly = lyq.front();\n\t\tint rx = rxq.front();\n\t\tint ry = ryq.front();\n\t\tlxq.pop(); lyq.pop(); rxq.pop(); ryq.pop();\n\t\tif(rooml[ly][lx] == '%' && roomr[ry][rx] == '%') {\n\t\t\t//flag = true;\n\t\t\treturn true;\n\t\t}else if(rooml[ly][lx] == '%' || roomr[ry][rx] == '%') continue;\n\n\t\tif(ls[lx][ly][rx][ry]) continue;\n\t\tls[lx][ly][rx][ry] = true;\n\n\t\tREP(k,0,4){\n\t\t\tint nlx = lx + ldx[k], nly = ly + ldy[k];\n\t\t\tif(!CH(nly,0,H) || !CH(nlx,0,W)){\n\t\t\t\tnlx = lx;\n\t\t\t\tnly = ly;\n\t\t\t}else if(rooml[nly][nlx]=='#'){\n\t\t\t\tnlx = lx;\n\t\t\t\tnly = ly;\n\t\t\t}\n\n\t\t\tint nrx = rx + rdx[k], nry = ry + rdy[k];\n\t\t\tif(!CH(nry,0,H) || !CH(nrx,0,W)){\n\t\t\t\tnrx = rx;\n\t\t\t\tnry = ry;\n\t\t\t}else if(roomr[nry][nrx]=='#'){\n\t\t\t\tnrx = rx;\n\t\t\t\tnry = ry;\n\t\t\t}\n\t\t\tif(ls[nlx][nly][nrx][nry]) continue;\n\t\t\t//dfs(nlx, nly, nrx, nry);\n\t\t\tlxq.push(nlx); lyq.push(nly); rxq.push(nrx); ryq.push(nry);\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\n\twhile(1){\n\t\tcin>>W>>H;\n\t\tif(W==0 && H==0) break;\n\t\tREP(i,0,H){\n\t\t\tcin>>rooml[i]>>roomr[i];\n\t\t}\n\n\t\tREP(i,0,H){\n\t\t\tREP(j,0,W){\n\t\t\t\tif(rooml[i][j] == 'L'){\n\t\t\t\t\tslx = j;\n\t\t\t\t\tsly = i;\n\t\t\t\t}\n\t\t\t\tif(roomr[i][j] == 'R'){\n\t\t\t\t\tsrx = j;\n\t\t\t\t\tsry = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tflag = false;\n\t\tREP(i,0,55)REP(j,0,55)REP(k,0,55)REP(l,0,55) ls[i][j][k][l] = false;\n\t\t/*\n\t\tdfs(slx, sly, srx, sry);\n\t\tif(flag) cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t\t*/\n\t\tif(bfs())cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<tuple>\n#include<string>\nusing namespace std;\n\n#define MAX_N 63\n#define INF 1<<30\n\nint dist[MAX_N][MAX_N][MAX_N][MAX_N];\nint dy1[4] = { 0,1,0,-1 };\nint dy2[4] = { 0,1,0,-1 };\nint dx1[4] = { 1,0,-1,0 };\nint dx2[4] = { -1,0,1,0 };\nint H, W, map1[MAX_N][MAX_N], map2[MAX_N][MAX_N];\nint Lsy, Lsx, Lgy, Lgx;\nint Rsy, Rsx, Rgy, Rgx;\nstring S, T;\nqueue<tuple<int, int, int, int>>Q;\n\nvoid _memset() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tfor (int k = 0; k < MAX_N; k++) {\n\t\t\t\tfor (int l = 0; l < MAX_N; l++) {\n\t\t\t\t\tdist[i][j][k][l] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tmap1[i][j] = 1;\n\t\t\tmap2[i][j] = 1;\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\t//memset.\n\t\t_memset();\n\n\t\t//cin.\n\t\tcin >> W >> H;\n\t\tif (H == 0 && W == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tcin >> S >> T;\n\t\t\tfor (int j = 0; j < S.size(); j++) {\n\t\t\t\tif (S[j] == 'L') {\n\t\t\t\t\tLsx = j + 1; Lsy = i;\n\t\t\t\t\tmap1[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\tif (S[j] == '#') {\n\t\t\t\t\tmap1[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (S[j] == '.') {\n\t\t\t\t\tmap1[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\tif (S[j] == '%') {\n\t\t\t\t\tLgy = i; Lgx = j + 1;\n\t\t\t\t\tmap1[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < T.size(); j++) {\n\t\t\t\tif (T[j] == 'R') {\n\t\t\t\t\tRsx = j + 1; Rsy = i;\n\t\t\t\t\tmap2[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\tif (T[j] == '#') {\n\t\t\t\t\tmap2[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (T[j] == '.') {\n\t\t\t\t\tmap2[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\tif (T[j] == '%') {\n\t\t\t\t\tRgy = i; Rgx = j + 1;\n\t\t\t\t\tmap2[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//bfs.\n\t\tQ.push(make_tuple(Lsy, Lsx, Rsy, Rsx));\n\t\tdist[Lsy][Lsx][Rsy][Rsx] = 0;\n\n\t\twhile (!Q.empty()) {\n\t\t\ttuple<int, int, int, int>tup = Q.front(); Q.pop();\n\t\t\tbool Q1, Q2;\n\t\t\tint ay = get<0>(tup);\n\t\t\tint ax = get<1>(tup);\n\t\t\tint by = get<2>(tup);\n\t\t\tint bx = get<3>(tup);\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint ey = ay + dy1[i], ex = ax + dx1[i];\n\t\t\t\tint fy = by + dy2[i], fx = bx + dx2[i];\n\t\t\t\tif (map1[ey][ex] == 1) {\n\t\t\t\t\tey = ay; ex = ax;\n\t\t\t\t}\n\t\t\t\tif (map2[fy][fx] == 1) {\n\t\t\t\t\tfy = by; fx = bx;\n\t\t\t\t}\n\t\t\t\tif (ey == Lgy && ex == Lgx) {\n\t\t\t\t\tQ1 = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tQ1 = false;\n\t\t\t\t}\n\t\t\t\tif (fy == Rgy && fx == Rgx) {\n\t\t\t\t\tQ2 = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tQ2 = false;\n\t\t\t\t}\n\t\t\t\tif (Q1 == true && Q2 == false) {\n\t\t\t\t\tgoto G;\n\t\t\t\t}\n\t\t\t\tif (Q1 == false && Q2 == true) {\n\t\t\t\t\tgoto G;\n\t\t\t\t}\n\t\t\t\tif (dist[ey][ex][fy][fx] == INF) {\n\t\t\t\t\tdist[ey][ex][fy][fx] = dist[ay][ax][by][bx] + 1;\n\t\t\t\t\tQ.push(make_tuple(ey, ex, fy, fx));\n\t\t\t\t}\n\t\t\tG:;\n\t\t\t}\n\t\t}\n\n\t\t//hantei.\n\t\tif (dist[Lgy][Lgx][Rgy][Rgx] == INF) {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\nconst int size = 51;\nint n, m;\nbool OL[size][size];\nbool OR[size][size];\n\ntypedef vector <string> VS;\n\nvoid init() {\n    for ( int i = 0; i < size; i++ ) {\n        for ( int j = 0; j < size; j++ ) {\n            OL[i][j] = false;\n            OR[i][j] = false;\n        }\n    }\n}\n\n/*\n. : ©RÉÚ®Å«éZ\n# : ÇÌ éZiiüÅ«È¢j\n% : ÚIn\nR : Rin ÌúÊu\nL : Len ÌúÊu\n*/\n\ntypedef pair <int, int> PII;\ntypedef pair <PII, PII> Node;\ntypedef queue <Node> Queue;\n\nint srL, scL, srR, scR;\nint grL, gcL, grR, gcR;\nconst int dr[4] = { 0, 0, 1, -1 };\nconst int dc[4] = { 1, -1, 0, 0 };\nbool used[size][size][size][size];\n\nbool bad( int r, int c ) {\n    return r < 0 || r >= m || c < 0 || c >= n;\n}\n\nbool solve() {\n    Queue Q;\n    Node start( PII( srL, scL ), PII( srR, scR ) );\n    Q.push( start );\n\n    for ( int i = 0; i < m; i++ ) {\n        for ( int j = 0; j < n; j++ ) {\n            for ( int k = 0; k < m; k++ ) {\n                for ( int l = 0; l < n; l++ ) {\n                    used[i][j][k][l] = false;\n                }\n            }\n        }\n    }\n\n    while ( !Q.empty() ) {\n        Node node = Q.front();\n        Q.pop();\n\n        int rL = node.first.first;\n        int cL = node.first.second;\n        int rR = node.second.first;\n        int cR = node.second.second;\n\n        bool flagL = rL == grL && cL == gcL;\n        bool flagR = rR == grR && cR == gcR;\n        if ( flagL && flagR ) {\n            return true;\n        }\n        else if ( flagL || flagR ) {\n            continue;\n        }\n\n        for ( int k = 0; k < 4; k++ ) {\n            int nrL = rL + dr[k];\n            int ncL = cL + dc[k];\n            int nrR = rR + dr[k];\n            int ncR = cR - dc[k];\n\n            if ( bad( nrL, ncL ) || OL[nrL][ncL] ) {\n                nrL = rL;\n                ncL = cL;\n            }\n            if ( bad( nrR, ncR ) || OR[nrR][ncR] ) {\n                nrR = rR;\n                ncR = cR;\n            }\n\n            if ( used[nrL][ncL][nrR][ncR] ) continue;\n            used[nrL][ncL][nrR][ncR] = true;\n            Node next_node( PII( nrL, ncL ), PII( nrR, ncR ) );\n            Q.push( next_node );\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n\n        init();\n\n        VS inputL(m), inputR(m);\n        for ( int i = 0; i < m; i++ ) {\n            cin >> inputL[i] >> inputR[i];\n        }\n\n        for ( int i = 0; i < m; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                if ( inputL[i][j] == '#' ) OL[i][j] = true;\n                if ( inputR[i][j] == '#' ) OR[i][j] = true;\n            }\n        }\n\n        for ( int i = 0; i < m; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                if ( inputL[i][j] == 'L' ) {\n                    srL = i;\n                    scL = j;\n                }\n                if ( inputR[i][j] == 'R' ) {\n                    srR = i;\n                    scR = j;\n                }\n                if ( inputL[i][j] == '%' ) {\n                    grL = i;\n                    gcL = j;\n                }\n                if ( inputR[i][j] == '%' ) {\n                    grR = i;\n                    gcR = j;\n                }\n            }\n        }\n\n        cout << ( solve() ? \"Yes\" : \"No\" ) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n// #define int ll\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#ifdef int\nconst ll INF = (1LL<<60);\n#else\nconst int INF = (1LL<<30);\n#endif\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[2][4] = {{0, 1, 0, -1}, {0, -1, 0, 1}}, dy[2][4] = {{1, 0, -1, 0}, {1, 0, -1, 0}};\n\nstring s1[55], s2[55];\nint d[55][55][55][55];\nsigned main(void)\n{\n  while(true) {\n    int w, h;\n    cin >> w >> h;\n    if(!w && !h) break;\n    REP(i, h) cin >> s1[i] >> s2[i];\n\n    int srx, sry, slx, sly, grx, gry, glx, gly;\n    REP(i, h) REP(j, w) {\n      if(s1[i][j] == 'L') {\n        srx = j, sry = i;\n      }\n      if(s1[i][j] == '%') {\n        grx = j, gry = i;\n      }\n      if(s2[i][j] == 'R') {\n        slx = j, sly = i;\n      }\n      if(s2[i][j] == '%') {\n        glx = j, gly = i;\n      }\n    }\n    // cout << srx << \" \" << sry << \" \" << grx << \" \" << gry << endl;\n    // cout << slx << \" \" << sly << \" \" << glx << \" \" << gly << endl;\n\n    queue<VI> que;\n    que.push({srx, sry, slx, sly});\n    memset(d, 0x3f, sizeof(d));\n    d[sry][srx][sly][slx] = 0;\n    while(que.size()) {\n      VI v = que.front(); que.pop();\n      int rx = v[0], ry = v[1], lx = v[2], ly = v[3];\n      // cout << rx << \" \" << ry << \" \" << lx << \" \" << ly << endl;\n      if(s1[ry][rx] == '%' && s2[ly][lx] == '%') break;\n      else if(s1[ry][rx] == '%' || s2[ly][lx] == '%') continue;\n      REP(i, 4) {\n        int nrx = rx + dx[0][i], nry = ry + dy[0][i], nlx = lx + dx[1][i], nly = ly + dy[1][i];\n        if(IN(0, w, nrx) && IN(0, h, nry) && IN(0, w, nlx) && IN(0, h, nly)) {\n          if(s1[nry][nrx] != '#' && s2[nly][nlx] != '#') {\n            if(d[nry][nrx][nly][nlx] == 0x3f3f3f3f) {\n              d[nry][nrx][nly][nlx] = d[ry][rx][ly][lx] + 1;\n              que.push({nrx, nry, nlx, nly});\n            }\n          } else if(s1[nry][nrx] != '#') {\n            if(d[nry][nrx][ly][lx] == 0x3f3f3f3f) {\n              d[nry][nrx][ly][lx] = d[ry][rx][ly][lx] + 1;\n              que.push({nrx, nry, lx, ly});\n            }\n          } else if(s2[nly][nlx] != '#') {\n            if(d[ry][rx][nly][nlx] == 0x3f3f3f3f) {\n              d[ry][rx][nly][nlx] = d[ry][rx][ly][lx] + 1;\n              que.push({rx, ry, nlx, nly});\n            }\n          }\n        }\n      }\n    }\n\n    if(d[gry][grx][gly][glx] == 0x3f3f3f3f) cout << \"No\" << endl;\n    else cout << \"Yes\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <utility>\n#include <cstring>\nusing namespace std;\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nint main() {\n  while(true) {\n    int W, H; cin >> W >> H;\n    if(W == 0 && H == 0) {\n      break;\n    }\n    char F[H][W+1], G[H][W+1];\n    REP(i,H) {\n      cin >> F[i] >> G[i];\n    }\n    PP start;\n    PP goal;\n    REP(i,H) {\n      REP(j,W) {\n        if(F[i][j] == 'L') start.first = P(i,j);\n        if(G[i][j] == 'R') start.second = P(i,j);\n        if(F[i][j] == '%') goal.first = P(i,j);\n        if(G[i][j] == '%') goal.second = P(i,j);\n      }\n    }\n    queue<PP> Q;\n    Q.push(start);\n    bool vis[H][W][H][W];\n    memset(vis, 0, sizeof(vis));\n    vis[start.first.first][start.first.second][start.second.first][start.second.second] = true;\n    while(!Q.empty()) {\n      PP p = Q.front(); Q.pop();\n      if(p == goal) break;\n      for(int i = 0; i < 4; ++i) {\n        const int dx[4] = { 1, 0, -1, 0 };\n        const int dy[4] = { 0, -1, 0, 1 };\n        int ly = p.first.first + dy[i];\n        int lx = p.first.second + dx[i];\n        int ry = p.second.first + dy[i];\n        int rx = p.second.second - dx[i];\n        if(F[ly][lx] == '#') {\n          ly = p.first.first;\n          lx = p.first.second;\n        }\n        if(ly < 0 || ly >= H || lx < 0 || lx >= W) {\n          ly = p.first.first;\n          lx = p.first.second;\n        }\n        if(G[ly][lx] == '#') {\n          ry = p.second.first;\n          rx = p.second.second;\n        }\n        if(ry < 0 || ry >= H || rx < 0 || rx >= W) {\n          ry = p.second.first;\n          rx = p.second.second;\n        }\n        if(!vis[ly][lx][ry][rx]) {\n          vis[ly][lx][ry][rx] = true;\n          Q.push(PP(P(ly,lx),P(ry,rx)));\n        }\n      }\n    }\n    if(vis[goal.first.first][goal.first.second][goal.second.first][goal.second.second]) {\n      cout << \"Yes\" << endl;\n    }\n    else {\n      cout << \"No\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx_r[] = {0,1,0,-1};\nstatic const int ty_r[] = {-1,0,1,0};\n\nstatic const int tx_l[] = {0,-1,0,1};\nstatic const int ty_l[] = {-1,0,1,0};\n\nbool Rin_visited[50][50];\nbool Len_visited[50][50];\nchar stage_Len[50][50];\nchar stage_Rin[50][50];\n\nbool can_reach;\nint W,H;\n\nvoid Rin_dfs(int Rin_x,int Rin_y,int Len_x,int Len_y){\n  for(int i=0;i<4;i++){\n    int Rin_dx = Rin_x + tx_r[i];\n    int Rin_dy = Rin_y + ty_r[i];\n\n    int Len_dx = Len_x + tx_l[i];\n    int Len_dy = Len_y + ty_l[i];\n    if(Rin_dx < 0 || Rin_dx >= W || Rin_dy < 0 || Rin_dy >= H){\n\tcontinue;\n    }\n    if(Len_dx < 0 || Len_dx >= W || Len_dy < 0 || Len_dy >= H){\n\tcontinue;\n    }\n    if(stage_Rin[Rin_dy][Rin_dx] == '#'){\n      continue;\n    }\n    if(stage_Len[Len_dy][Len_dx] == '#'){\n      Len_dy = Len_y;\n      Len_dx = Len_x;\n    }\n\n    if(Rin_visited[Rin_dy][Rin_dx]){\n      continue;\n    }\n\n\n    if(stage_Len[Len_dy][Len_dx] == '%'\n       && stage_Rin[Rin_dy][Rin_dx] == '%'){\n      can_reach = true;\n      return;\n    }\n\n    if(stage_Len[Len_dy][Len_dx] != '%'\n       && stage_Rin[Rin_dy][Rin_dx] != '%'){\n      Rin_visited[Rin_dy][Rin_dx] = true;\n      Rin_dfs(Rin_dx,Rin_dy,Len_dx,Len_dy);\n    }\n  }\n}\n\nvoid Len_dfs(int Rin_x,int Rin_y,int Len_x,int Len_y){\n  for(int i=0;i<4;i++){\n    int Rin_dx = Rin_x + tx_r[i];\n    int Rin_dy = Rin_y + ty_r[i];\n\n    int Len_dx = Len_x + tx_l[i];\n    int Len_dy = Len_y + ty_l[i];\n    if(Rin_dx < 0 || Rin_dx >= W || Rin_dy < 0 || Rin_dy >= H){\n\tcontinue;\n    }\n    if(Len_dx < 0 || Len_dx >= W || Len_dy < 0 || Len_dy >= H){\n\tcontinue;\n    }\n    if(stage_Rin[Rin_dy][Rin_dx] == '#'){\n      Rin_dy = Rin_y;\n      Rin_dx = Rin_x;\n    }\n    if(stage_Len[Len_dy][Len_dx] == '#'){\n      continue;\n    }\n\n    if(Len_visited[Len_dy][Len_dx]){\n      continue;\n    }\n\n    Len_visited[Len_dy][Len_dx] = true;\n    if(stage_Len[Len_dy][Len_dx] == '%'\n       && stage_Rin[Rin_dy][Rin_dx] == '%'){\n      can_reach = true;\n      return;\n    }\n\n    if(stage_Len[Len_dy][Len_dx] != '%'\n       && stage_Rin[Rin_dy][Rin_dx] != '%'){\n      Len_visited[Len_dy][Len_dx] = true;\n      Len_dfs(Rin_dx,Rin_dy,Len_dx,Len_dy);\n    }\n  }\n}\n\nint main(){\n\n  while(~scanf(\"%d %d\",&W,&H)){\n    if(W==0 && H==0) break;\n\n    memset(Len_visited,false,sizeof(Len_visited));\n    memset(Rin_visited,false,sizeof(Rin_visited));\n    can_reach = false;\n    \n    int Rin_start_x = 0;\n    int Rin_start_y = 0;\n    int Len_start_x = 0;\n    int Len_start_y = 0;\n \n    for(int y=0;y<H;y++){\n      string str_Len,str_Rin;\n      cin >> str_Len >> str_Rin;\n      \n      // cout << str_Len << endl;\n      // cout << str_Rin << endl;\n\n      for(int x=0;x<W;x++){\n\tstage_Len[y][x] = str_Len[x];\n\tstage_Rin[y][x] = str_Rin[x];\n\n\tif(str_Len[x] == 'L'){\n\t  Len_start_x = x;\n\t  Len_start_y = y;\n\t}\n\tif(str_Rin[x] == 'R'){\n\t  Rin_start_x = x;\n\t  Rin_start_y = y;\n\t}\n      }\n    }\n\n    Len_dfs(Rin_start_x,Rin_start_y,Len_start_x,Len_start_y);\n    Rin_dfs(Rin_start_x,Rin_start_y,Len_start_x,Len_start_y);\n    printf(\"%s\\n\",can_reach ? \"Yes\" : \"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> P;\n\nstruct state{\n    int ly, lx, ry, rx;\n};\nint w, h;\nbool contain(int y, int x){\n    return (0 <= y && y < h && 0 <= x && x < w);\n}\nint dy[4] = {1, -1, 0, 0};\nint dx[4] = {0, 0, 1, -1};\nbool f[51][51][51][51];\n\nsigned main(){\n    while(1){\n        cin >> w >> h;\n        if(w + h == 0) break;\n        vector<string> s(h), t(h);\n        bool ans = false;\n        int lsy, lsx, lgy, lgx, rsy, rsx, rgy, rgx;\n        rep(i, 0, h){\n            cin >> s[i] >> t[i];\n            rep(j, 0, w){\n                if(s[i][j] == 'L'){ lsy = i; lsx = j;}\n                if(s[i][j] == '%'){ lgy = i; lgx = j;}\n                if(t[i][j] == 'R'){ rsy = i; rsx = j;}\n                if(t[i][j] == '%'){ rgy = i; rgx = j;}\n            }\n        }\n        queue<state> q;\n        q.push((state){lsy, lsx, rsy, rsx});\n        rep(i, 0, 51) rep(j, 0, 51) rep(k, 0, 51) rep(l, 0, 51) f[i][j][k][l] = false;\n        f[lsy][lsx][rsy][rsx] = true;\n        while(!q.empty()){\n            state p = q.front(); q.pop();\n            // cout << p.ly << \" \" << p.lx << \" \" << p.ry << \" \" << p.rx << endl;\n            rep(i, 0, 4){\n                int nly = p.ly + dy[i];\n                int nlx = p.lx + dx[i];\n                int nry = p.ry + dy[i];\n                int nrx = p.rx - dx[i];\n                if(!contain(nly, nlx) || s[nly][nlx] == '#'){ nly = p.ly; nlx = p.lx;}\n                if(!contain(nry, nrx) || t[nry][nrx] == '#'){ nry = p.ry; nrx = p.rx;}\n                if(f[nly][nlx][nry][nrx]) continue;\n                f[nly][nlx][nry][nrx] = true;\n                if(s[nly][nlx] == '%' && t[nry][nrx] == '%'){ ans = true; break;}\n                else if(s[nly][nlx] == '%' || t[nry][nrx] == '%') continue;\n                q.push((state){nly, nlx, nry, nrx});\n            }\n            if(ans == true) break;\n        }\n        cout << (ans ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\nusing namespace std;\nstring s1[50],s2[50];\nint dx1[]={1,-1,0,0,},dy1[]={0,0,1,-1};\nint dx2[]={-1,1,0,0,},dy2[]={0,0,1,-1};\nint w,h,gx1,gx2,gy1,gy2;\nunordered_set<int>s;\nbool bfs(int x1,int y1,int x2,int y2){\n  queue<int>q;\n  q.push(x1+y1*100+x2*10000+y2*1000000);\n  while(!q.empty()){\n    int p=q.front();q.pop();\n    x1=p%100;y1=p%10000/100;\n    x2=p%1000000/10000;y2=p/1000000;\n    if(x1==gx1&&y1==gy1&&x2==gx2&&y2==gy2){\n      return 1;\n    }\n    for(int i=0;i<4;i++){\n      int x3=x1+dx1[i],y3=y1+dy1[i];\n      int x4=x2+dx2[i],y4=y2+dy2[i];\n      if(x3>=0&&x4>=0&&y3>=0&&y4>=0)\n        if(x3<w&&x4<w&&y3<h&&y4<h){\n          if(s1[y3][x3]=='#')y3=y1,x3=x1;\n          if(s2[y4][x4]=='#')y4=y2,x4=x2;\n          if(!(x3==gx1&&y3==gy1&&(x4!=gx2||y4!=gy2)))\n          if(!((x3!=gx1||y3!=gy1)&&x4==gx2&&y4==gy2))\n          if(!s.count(x3+y3*100+x4*10000+y4*1000000)){\n            s.insert(x3+y3*100+x4*10000+y4*1000000);\n            q.push(x3+y3*100+x4*10000+y4*1000000);\n          }\n        }\n      }\n    }\n    return 0;\n}\nint main(){\n  int x1,y1,x2,y2;\n  while(cin>>w>>h,w){\n    s.clear();\n    r(i,h)cin>>s1[i]>>s2[i];\n    r(i,h)r(j,w){\n      if(s1[i][j]=='L')x1=j,y1=i;\n      if(s2[i][j]=='R')x2=j,y2=i;\n      if(s1[i][j]=='%')gx1=j,gy1=i;\n      if(s2[i][j]=='%')gx2=j,gy2=i;\n    }\n    s.insert(x1+y1*100+x2*10000+y2*1000000);\n    if(bfs(x1,y1,x2,y2))cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<queue>\n#define MAX 60\nusing namespace std;\nstruct Point{int x,y;};\nstruct P{\n  Point l,r;\n  int cost;\n};\nint main(){\n  int w,h;\n  while(cin>>w>>h,w||h){\n    int i,j,k;\n    int inf = 1<<20;\n    int d[MAX+1][MAX+1][MAX+1][MAX+1];\n    //fill(d[0][0][0],d[MAX][MAX][MAX],inf);\n    string sr[60],sl[60];\n    for(i=0;i<h;i++){\n      cin >> sl[i] >> sr[i];\n    }\n    Point pr,pl,br,bl;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(sl[i][j]=='L'){\n\t  pl.x=j;pl.y=i;\n\t}\n\tif(sr[i][j]=='R'){\n\t  pr.x=j;pr.y=i;\n\t}\n      }\n    }\n    //cout << pl.x << \":\" << pl.y << endl;\n    //cout << pr.x << \":\" << pr.y << endl;\n    d[pl.x][pl.y][pr.x][pr.y]=0;\n    P p,b;\n    p.r=pr;\n    p.l=pl;\n    p.cost=d[pl.x][pl.y][pr.x][pr.y];\n    queue<P> q;\n    q.push(p);\n    bool f = false;\n    while(!q.empty()){\n      p=q.front();q.pop();\n      pl=p.l;pr=p.r;\n      if(p.cost>d[pl.x][pl.y][pr.x][pr.y]) continue;\n      d[pl.x][pl.y][pr.x][pr.y]=p.cost;\n      //cout << pl.x<<\":\"<<pl.y<<\":\"<<pr.x<<\":\"<<pr.y<<\"/\"<<p.cost<<endl;\n      if(sl[pl.y][pl.x]=='%'&&sr[pr.y][pr.x]=='%'){\n\tf=true;\n\tbreak;\n      }else if(sl[pl.y][pl.x]=='%') continue;\n      else if(sr[pr.y][pr.x]=='%') continue;\n      \n      p.cost++;\n      int lx[]={1,-1,0,0};int ly[]={0,0,1,-1};\n      int rx[]={-1,1,0,0};int ry[]={0,0,1,-1};\n      for(i=0;i<4;i++){\n\tbl=pl;br=pr;\n\tbl.x+=lx[i];bl.y+=ly[i];\n\tbr.x+=rx[i];br.y+=ry[i];\n\n\t//cout << bl.x<<\":\"<<bl.y<<\":\"<<br.x<<\":\"<<br.y<<\"/\"<<p.cost<<endl;\n\t\n\tif(bl.x<0) bl.x=0;\n\telse if(bl.x>=w) bl.x=w-1;\n\tif(bl.y<0) bl.y=0;\n\telse if(bl.y>=h) bl.y=h-1;\n\n\tif(br.x<0) br.x=0;\n\telse if(br.x>=w) br.x=w-1;\n\tif(br.y<0) br.y=0;\n\telse if(br.y>=h) br.y=h-1;\n\n\tif(sl[bl.y][bl.x]=='#'){\n\t  bl.x-=lx[i];bl.y-=ly[i];\n\t}\n\tif(sr[br.y][br.x]=='#'){\n\t  br.x-=rx[i];br.y-=ry[i];\n\t}\n\tp.r=br;p.l=bl;\n\tq.push(p);\n      }\n    }\n    if(f) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nconst int INF = 1 << 29;\n\nstruct position {\n    int h, w;\n    position() {}\n    position(int a, int b): h(a), w(b) {}\n};\n\nstruct state {\n    position left, right;\n    int cost;\n    state() {}\n    state(position l, position r, int c): left(l), right(r), cost(c) { }\n};\n\nconst int dh[4] = {1, 0, -1, 0};\nconst int dw[4] = {0, 1, 0, -1};\n\nint W, H;\nstring rooml[55], roomr[55];\n\nint memo[55][55][55][55];\n\nint get_memo(position left, position right) {\n    return memo[left.h][left.w][right.h][right.w];\n}\n\nvoid update_memo(position left, position right, int value) {\n    memo[left.h][left.w][right.h][right.w] = value;\n}\n\nposition move(position p, int dir) {\n    return position(p.h+dh[dir], p.w+dw[dir]);\n}\n\nbool solve() {\n    cin >> W >> H;\n    if (W+H==0) { return false; }\n    for (int j = 0; j < H; ++j) {\n        cin >> rooml[j] >> roomr[j];\n    }\n\n    position sl, sr, gl, gr;\n\n    for (int j = 0; j < H; ++j) {\n        for (int k = 0; k < W; ++k) {\n            if (rooml[j][k] == 'L') { sl.h = j; sl.w = k; }\n            if (roomr[j][k] == 'R') { sr.h = j; sr.w = k; }\n\n            if (rooml[j][k] == '%') { gl.h = j; gl.w = k; }\n            if (roomr[j][k] == '%') { gr.h = j; gr.w = k; }\n        }\n    }\n\n    for (int j = 0; j < H; ++j) {\n        for (int k = 0; k < W; ++k) {\n            for (int l = 0; l < H; ++l) { fill(memo[j][k][l], memo[j][k][l]+W, INF); }\n        }\n    }\n\n    queue<state> que;\n    que.emplace(sl, sr, 0);\n    update_memo(sl, sr, 0);\n\n    int result = INF;\n    while (!que.empty()) {\n        state st = que.front(); que.pop();\n\n        if (get_memo(st.left, st.right) < st.cost) { continue; }\n\n        if ((rooml[st.left.h][st.left.w] == '%') != (roomr[st.right.h][st.right.w] == '%')) {\n            continue;\n        }\n\n        if ((rooml[st.left.h][st.left.w] == '%') && (roomr[st.right.h][st.right.w] == '%')) {\n            result = st.cost;\n            break;\n        }\n\n        for (int d = 0; d < 4; ++d) {\n            position nexl = move(st.left, d);\n            position nexr = move(st.right, (4-d)%4);\n\n            if (nexl.h < 0 || nexl.h >= H || nexl.w < 0 || nexl.w >= W) { nexl = st.left; }\n            if (nexr.h < 0 || nexr.h >= H || nexr.w < 0 || nexr.w >= W) { nexr = st.right; }\n\n            if (rooml[nexl.h][nexl.w] == '#') { nexl = st.left; }\n            if (roomr[nexr.h][nexr.w] == '#') { nexr = st.right; }\n\n            if (get_memo(nexl, nexr) > st.cost+1) {\n                update_memo(nexl, nexr, st.cost+1);\n                que.emplace(nexl, nexr, st.cost+1);\n            }\n        }\n    }\n\n    cout << (result == INF ? \"No\" : \"Yes\") << endl;\n\n    return true;\n}\n\nint main() {\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<utility>\n#include<queue>\nusing namespace std;\ntypedef struct P{int rh,rw,lh,lw,d;}P;\nstruct Order{bool operator ()(P const&a, P const&b) const{return a.d>b.d;}};\n\nint W,H,i,j,rh,rw,lh,lw,f;\nint rm[4][2]={{0,1},{0,-1},{1,0},{-1,0}};\nint lm[4][2]={{0,-1},{0,1},{1,0},{-1,0}};\nbool dp[55][55][55][55][205];\nchar M[110][110]={0},t;\n\nint main()\n{\n\tfor(;scanf(\"%d%d\\n\",&W,&H),W;)\n\t{\n\t\tmemset(M,0,sizeof(M));\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(i=1;i<=H;i++)\n\t\t\tfor(j=1;j<=2*W+2;j++)\n\t\t\t{\n\t\t\t\tt=getchar();\n\t\t\t\tif(t=='R'){rh=i;rw=j;t='.';}\n\t\t\t\tif(t=='L'){lh=i;lw=j;t='.';}\n\t\t\t\tM[i][j]=t;\n\t\t\t}\n\t\tpriority_queue<P,vector<P>,Order>Q;\n\t\tP p={rh,rw,lh,lw,0};\n\t\tQ.push(p);\n\t\tfor(f=0;!Q.empty();)\n\t\t{\n\t\t\tp=Q.top();Q.pop();\n\t\t\tif(M[p.rh][p.rw]=='%'&&M[p.lh][p.lw]=='%'){f=1;break;}\n\t\t\tif(M[p.rh][p.rw]=='%'||M[p.lh][p.lw]=='%'||p.d==105)continue;\n\t\t\tfor(i=0;i<4;i++)\n\t\t\t{\n\t\t\t\tP ins={p.rh,p.rw,p.lh,p.lw,p.d+1};\n\t\t\t\tif(M[p.rh+rm[i][0]][p.rw+rm[i][1]]=='.'||M[p.rh+rm[i][0]][p.rw+rm[i][1]]=='%'){ins.rh+=rm[i][0];ins.rw+=rm[i][1];}\n\t\t\t\tif(M[p.lh+lm[i][0]][p.lw+lm[i][1]]=='.'||M[p.lh+lm[i][0]][p.lw+lm[i][1]]=='%'){ins.lh+=lm[i][0];ins.lw+=lm[i][1];}\n\t\t\t\tif(!dp[ins.rh][ins.rw][ins.lh][ins.lw-W-1][ins.d])\n\t\t\t\t{\n\t\t\t\t\tdp[ins.rh][ins.rw][ins.lh][ins.lw-W-1][ins.d]=1;\n\t\t\t\t\tQ.push(ins);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(f?\"YES\":\"NO\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#define N 52\n#define y1 first.first\n#define x1 first.second\n#define y2 second.first\n#define x2 second.second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\n\nvoid bfs();\n\nint w,h,sy1,sx1,sy2,sx2,gy1,gx1,gy2,gx2,ans;\nstring r1[N],r2[N];\nset<P1> visited;\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(!w&&!h) break;\n    for(int i=0;i<h;i++) cin>>r1[i]>>r2[i];\n    for(int i=0;i<h;i++) cout<<r1[i]<<endl;\n    for(int i=0;i<h;i++) cout<<r2[i]<<endl;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(r1[i][j]=='L') sy1=i,sx1=j;\n\tif(r1[i][j]=='%') gy1=i,gx1=j;\n\tif(r2[i][j]=='R') sy2=i,sx2=j;\n\tif(r2[i][j]=='%') gy2=i,gx2=j;\n      }\n    ans=0;\n    bfs();\n    if(ans) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n    set.clear();\n  }\n  return 0;\n}\n\nvoid bfs(){\n  int dy[4]={0,-1,0,1},dx[4]={-1,0,1,0};\n  queue<P1> q;\n  P1 k=make_pair((P)(sy1,sx1),(P)(sy2,sx2));\n  q.push(k);\n  visited.insert(k);\n  while(!q.empty()){\n    P1 t=q.front(); q.pop();\n    for(int i=0;i<4;i++){\n      int ny1=t.y1+dy[i],nx1=t.x1+dx[i];\n      int ny2=t.y2-dy[i],nx2=t.y2-dx[i];\n      if(ny1<0) ny1=0;\n      if(nx1<0) nx1=0;\n      if(h<=ny1) ny1=h-1;\n      if(w<=nx1) nx1=w-1;\n      if(ny2<0) ny2=0;\n      if(nx2<0) nx2=0;\n      if(h<=ny2) ny2=h-1;\n      if(w<=nx2) nx2=w-1;\n      if(r1[ny1][nx1]=='#') ny1=t.y1,nx1=t.x1;\n      if(r2[ny2][nx2]=='#') ny2=t.y2,nx2=t.x2;\n      P1 u=make_pair((P)(ny1,nx1),(P)(ny2,nx2));\n      if(visited.find(u)!=visited.end()) continue;\n      visited.insert(u);\n      q.push(u);\n      if(ny1==gy1&&nx1==gx1&&ny2==gy2&&nx2==gx2){\n\tans=1;\n\tbreak;\n      }\n    }\n    if(ans) break;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <queue>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\nconst int dy[] = {1, 0, -1, 0};\nconst int dx[] = {0, 1, 0, -1};\nconst int MAX_N = 60;\nstruct Info\n{\n    P left, right;\n};\nstring Rfield[MAX_N];\nstring Lfield[MAX_N];\nint h, w, lsy, lsx, rsy, rsx;\nbool range_check(int y, int x)\n{\n    if(y >= h || x >= w || x < 0 || y < 0) return false;\n    else return true;\n}\nbool bfs()\n{\n    Lfield[lsy][lsx] = '$';\n    Rfield[rsy][rsx] = '$';\n    queue<Info> que;\n    que.push({P(lsy, lsx), P(rsy, rsx)});\n    while(!que.empty())\n    {\n        Info p = que.front();\n        que.pop();\n        for(int i = 0; i < 4; i++)\n        {\n            int ly = p.left.first + dy[i];\n            int lx = p.left.second + dx[i];\n            int ry = p.right.first + dy[i];\n            int rx = p.right.second + dx[(i + 2) % 4];\n            if(!(range_check(ly, lx) || range_check(ry, rx))) continue;\n            if(Lfield[ly][lx] == '$' || Rfield[ry][rx] == '$') continue;\n            if(Lfield[ly][lx] == '#' && Rfield[ry][rx] == '#') continue;\n            if(Lfield[ly][lx] == '%' && Rfield[ry][rx] == '%') return true;\n            if(Lfield[ly][lx] == '%' || Rfield[ry][rx] == '%') continue;\n            if(Lfield[ly][lx] == '.') Lfield[ly][lx] = '$';\n            if(Rfield[ry][rx] == '.') Rfield[ry][rx] = '$';\n            P np = {ly, lx}, nq = {ry, rx};\n            if(Lfield[ly][lx] == '#') np = {p.left.first, p.left.second};\n            if(Rfield[ry][rx] == '#') nq = {p.right.first, p.right.second};\n            que.push({np, nq});\n        }\n        //for(int i = 0; i < h; i++) cout << Rfield[i] << endl;\n    }\n    return false;\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> w >> h, w | h)\n    {\n        for(int i = 0; i < h; i++)\n        {\n            cin >> Lfield[i] >> Rfield[i];\n            for(int j = 0; j < w; j++)\n            {\n                if(Lfield[i][j] == 'L') rsy = i, rsx = j;\n                if(Rfield[i][j] == 'R') lsy = i, lsx = j;\n            }\n        }\n        cout << (bfs() ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define pb push_back\n#define fi first\n#define sc second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nint w, h;\nP as, ae, bs, be;\nstring a[50], b[50];\nbool use[50][50][50][50];\nint daw[4] = {1,0,-1,0},dah[4]={0,1,0,-1};\nint dbw[4] = {-1,0,1,0},dbh[4]={0,1,0,-1};\n\nvoid solve(int pp, int qq, int rr, int ss){\n\tqueue<PP> que;\n\tque.push(PP(P(pp,qq),P(rr,ss)));\n\twhile(!que.empty()){\n\t\tPP qu = que.front(); que.pop();\n\t\tint p = qu.fi.fi, q = qu.fi.sc, r = qu.sc.fi, s = qu.sc.sc;\n\t\trep(i,4){\n\t\t\tint dp = p+dah[i],dq = q+daw[i];\n\t\t\tint dr = r+dbh[i],ds = s+dbw[i];\n\t\t\tif(0>dp||dp>=h||0>dq||dq>=w||a[dp][dq]=='#'){\n\t\t\t\tdp = p;\n\t\t\t\tdq = q;\n\t\t\t}\n\t\t\tif(0>dr||dr>=h||0>ds||ds>=w||b[dr][ds]=='#'){\n\t\t\t\tdr = r;\n\t\t\t\tds = s;\n\t\t\t}\n\t\t\tif(use[dp][dq][dr][ds]) continue;\n\t\t\tif(ae == P(dp,dq) && be != P(dr,ds)) continue;\n\t\t\tif(ae != P(dp,dq) && be == P(dr,ds)) continue;\n\t\t\tuse[dp][dq][dr][ds] = true;\n\t\t\tque.push(PP(P(dp,dq),P(dr,ds)));\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(scanf(\"%d%d\",&w,&h),w||h){\n\t\tmemset(use,0,sizeof(use));\n\t\trep(i,h) cin >> a[i] >> b[i];\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tif(a[i][j] == 'L') as = P(i,j);\n\t\t\t\tif(b[i][j] == 'R') bs = P(i,j);\n\t\t\t\tif(a[i][j] == '%') ae = P(i,j);\n\t\t\t\tif(b[i][j] == '%') be = P(i,j);\n\t\t\t}\n\t\t}\n\t\tint d = 0;\n\t\tuse[as.fi][as.sc][bs.fi][bs.sc] = true;\n\t\tsolve(as.fi,as.sc,bs.fi,bs.sc);\n\t\tif(use[ae.fi][ae.sc][be.fi][be.sc]) puts(\"Yes\");\n\t\telse puts(\"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\ntypedef pair<pi,pi> P;\n\nconst int INF=12345678;\n\nint w,h;\nint d[50][50][50][50];\n\ninline bool in(int x, int y)\n{\n    return (0<=x&&x<w && 0<=y&&y<h);\n}\n\nint main()\n{\n    int dx[]={1,-1,0,0}, dy[]={0,0,1,-1};\n\n    while(cin >>w >>h,w|h)\n    {\n        vector<string> l(h),r(h);\n        rep(i,h) cin >>l[i] >>r[i];\n\n        pi len,rin;\n        pi gl,gr;\n        rep(i,h)rep(j,w)\n        {\n            if(l[i][j]=='L') len=pi(j,i);\n            if(r[i][j]=='R') rin=pi(j,i);\n            if(l[i][j]=='%') gl=pi(j,i);\n            if(r[i][j]=='%') gr=pi(j,i);\n        }\n\n        //len(x,y),rin(x,y)\n        rep(a1,50)rep(a2,50)rep(a3,50)rep(a4,50) d[a1][a2][a3][a4]=INF;\n        d[len.fi][len.se][rin.fi][rin.se]=0;\n\n        queue<P> que;\n        que.push(P(len,rin));\n        while(!que.empty())\n        {\n            P now=que.front();\n            que.pop();\n\n            pi nl=now.fi, nr=now.se;\n\n            rep(i,4)\n            {\n                int nlx=nl.fi+dx[i], nly=nl.se+dy[i];\n                int nrx=nr.fi-dx[i], nry=nr.se+dy[i];\n\n                if(!in(nlx,nly) || (in(nlx,nly)&&l[nly][nlx]=='#'))\n                {\n                    //not move\n                    nlx=nl.fi;\n                    nly=nl.se;\n                }\n\n                if(!in(nrx,nry) || (in(nrx,nry)&&r[nry][nrx]=='#'))\n                {\n                    //not move\n                    nrx=nr.fi;\n                    nry=nr.se;\n                }\n\n                if(l[nly][nlx]=='%' && r[nry][nrx]!='%') continue;\n                if(l[nly][nlx]!='%' && r[nry][nrx]=='%') continue;\n\n                if(d[nlx][nly][nrx][nry]>d[nl.fi][nl.se][nr.fi][nr.se]+1)\n                {\n                    d[nlx][nly][nrx][nry]=d[nl.fi][nl.se][nr.fi][nr.se]+1;\n                    que.push(P(pi(nlx,nly),pi(nrx,nry)));\n                }\n            }\n        }\n\n        puts((d[gl.fi][gl.se][gr.fi][gr.se]<INF)?\"Yes\":\"No\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dy[4]={1,0,-1,0};\nint dx[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\n\n\nint W,H;\nstring roomL[55],roomR[55];\n\nbool range_check(int y,int x) {\n    if(!(0<=y&&y<H)) return false;\n    if(!(0<=x&&x<W)) return false;\n\n    return true;\n}\n\nbool visited[55][55][55][55];\nbool ok(P len,P rin) {\n    memset(visited,0,sizeof(visited));\n    visited[len.fr][len.sc][rin.fr][rin.sc]=true;\n    queue<PP> que;\n    que.push(PP(len,rin));\n\n    while(que.size()) {\n        PP pp=que.front(); que.pop();\n        P next_len=pp.fr;\n        P next_rin=pp.sc;\n\n        //printf(\"[debug] %d %d %d %d\\n\",next_len.fr,next_len.sc,next_rin.fr,next_rin.sc);\n\n        rep(i,4) {\n            next_len=pp.fr;\n            next_rin=pp.sc;\n            next_len.fr+=dy[i];\n            next_len.sc+=dx[i];\n            next_rin.fr+=dy[i];\n            next_rin.sc-=dx[i];\n            \n            if(!range_check(next_len.fr,next_len.sc) || roomL[next_len.fr][next_len.sc]=='#') {\n                next_len=pp.fr;\n            }\n\n            if(!range_check(next_rin.fr,next_rin.sc) || roomR[next_rin.fr][next_rin.sc]=='#') {\n                next_rin=pp.sc;\n            }\n\n\n\n            if((roomL[next_len.fr][next_len.sc]=='%')&&(roomR[next_rin.fr][next_rin.sc]=='%')) return true;\n            if((roomL[next_len.fr][next_len.sc]=='%')||(roomR[next_rin.fr][next_rin.sc]=='%')) continue;\n            if(visited[next_len.fr][next_len.sc][next_rin.fr][next_len.sc]) continue;\n            visited[next_len.fr][next_len.sc][next_rin.fr][next_len.sc]=true;\n            que.push(PP(next_len,next_rin));\n\n        }\n    }\n\n    return false;\n}\n\nvoid solve() {\n    rep(y,55) roomL[y]=roomR[y]=string('#',55);\n    rep(y,H) cin>>roomL[y]>>roomR[y];\n    P len,rin;\n    rep(y,H) rep(x,W) {\n        if(roomL[y][x]=='L') len=P(y,x);\n        if(roomR[y][x]=='R') rin=P(y,x);\n    }\n    if(ok(len,rin)) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n}\n\nint main() {\n    while(cin>>W>>H) {\n        if(!W) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "fffff\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <tuple>\n#include <string>\n#include <cstring>\n#include <iostream>\n\nusing namespace std;\n\nconst int dx1[4] = { 0, 1, 0, -1 };\nconst int dy1[4] = { -1, 0, 1, 0 };\nconst int dx2[4] = { 0, -1, 0, 1 };\nconst int dy2[4] = { -1, 0, 1, 0 };\n\nint H, W; string L[50], R[50];\n\nbool used[50][50][50][50];\n\nbool over(int x, int y)\n{\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\nbool solve(int lx, int ly, int rx, int ry)\n{\n\tused[ly][lx][ry][rx] = true;\n\n\tif (L[ly][lx] == '%' && R[ry][rx] == '%') return true;\n\n\tif (L[ly][lx] == '%') return false;\n\tif (R[ry][rx] == '%') return false;\n\n\tbool ok = false;\n\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint ltx = lx + dx1[i];\n\t\tint lty = ly + dy1[i];\n\t\tint rtx = rx + dx2[i];\n\t\tint rty = ry + dx2[i];\n\n\t\tif (!over(ltx, lty) && !over(rtx, rty))\n\t\t{\n\t\t\tif (L[lty][ltx] != '#' && R[rty][rtx] != '#')\n\t\t\t{\n\t\t\t\tif (!used[lty][ltx][rty][rtx])\n\t\t\t\t{\n\t\t\t\t\tok |= solve(ltx, lty, rtx, rty);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ok;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &W);\n\t\tscanf(\"%d\", &H);\n\n\t\tfor (int i = 0; i < H; i++) cin >> L[i] >> R[i];\n\n\t\tint lx, ly, rx, ry;\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (L[i][j] == 'L')\n\t\t\t\t{\n\t\t\t\t\tlx = j;\n\t\t\t\t\tly = i;\n\t\t\t\t}\n\n\t\t\t\tif (R[i][j] == 'R')\n\t\t\t\t{\n\t\t\t\t\trx = j;\n\t\t\t\t\try = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(used, false, sizeof(used));\n\n\t\tprintf(\"%s\\n\", solve(lx, ly, rx, ry) ? \"Yes\" : \"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nstruct Data{int x[2],y[2];};\nData start,goal;\n\nint W,H;\nstring room[2][50];\n\nint dx[2][4]={{0,1,0,-1}, {0,-1,0,1}};\nint dy[2][4]={{-1,0,1,0}, {-1,0,1,0}};\nbool operator==(Data a, Data b){\n  return a.x[0]==b.x[0] && a.x[1]==b.x[1] && a.y[0]==b.y[0] && a.y[1]==b.y[1];\n}\nbool over(Data a){\n  return a.x[0]<0 || W<=a.x[0] || a.y[0]<0 || H<=a.y[0] ||\n         a.x[1]<0 || W<=a.x[1] || a.y[1]<0 || H<=a.y[1];\n}\n\nbool bfs()\n{\n  queue<Data>q;\n  q.push(start);\n  bool visited[50][50][50][50]={false};\n\n  while(!q.empty()){\n    Data now=q.front();\n    q.pop();\n\n    visited[now.x[0]][now.y[0]][now.x[1]][now.y[1]]=true;\n\n    if(now==goal)return true;\n    if(now.x[0]==goal.x[0] && now.y[0]==goal.y[0])continue;\n    if(now.x[1]==goal.x[1] && now.y[1]==goal.y[1])continue;\n\n    for(int i=0;i<4;i++){\n      Data next=now;\n      for(int j=0;j<2;j++){\n\tnext.x[j]+=dx[j][i];\n\tnext.y[j]+=dy[j][i];\n\tif(over(next)){\n\t  next.x[j]=now.x[j];\n\t  next.y[j]=now.y[j];\n\t}\n\tif(room[j][next.y[j]][next.x[j]]=='#'){\n\t  next.x[j]=now.x[j];\n\t  next.y[j]=now.y[j];\n\t}\n      }\n      if(visited[next.x[0]][next.y[0]][next.x[1]][next.y[1]])continue;\n      q.push(next);\n    }\n  }\n\n  return false;\n}\n\nint main()\n{\n  while(cin>>W>>H,W|H){\n    for(int i=0;i<H;i++){\n      cin>>room[0][i]>>room[1][i];\n      for(int j=0;j<W;j++){\n\tif(room[0][i][j]=='L'){\n\t  start.x[0]=j;\n\t  start.y[0]=i;\n\t}\n\tif(room[1][i][j]=='R'){\n\t  start.x[1]=j;\n\t  start.y[1]=i;\n\t}\n\tif(room[0][i][j]=='%'){\n\t  goal.x[0]=j;\n\t  goal.y[0]=i;\n\t}\n\tif(room[1][i][j]=='%'){\n\t  goal.x[1]=j;\n\t  goal.y[1]=i;\n\t}\n      }\n    }\n\n    puts(bfs()?\"Yes\":\"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// Header {{{\n// includes {{{\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <unistd.h>\n#include <vector>\n// }}}\nusing namespace std;\n// consts {{{\nstatic const int INF = 1e9;\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n// }}}\n// typedefs {{{\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<ULL> VULL;\ntypedef vector<VULL> VVULL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\n// typedef complex<char> P;\ntypedef PII P;\n#define PQ(type) priority_queue<type>\n// priority queue reverse\n#define PQR(type) priority_queue< type, vector<type>, greater<type> >\n// }}}\n// macros & inline functions {{{\n// syntax sugars {{{\n#define FOR(i, b, e) for (typeof(e) i = (b); i < (e); ++i)\n#define FORI(i, b, e) for (typeof(e) i = (b); i <= (e); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(i, n) FORI(i, 0, n)\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n#define ASSIGN_MAX(var, val) ((var) = max((var), (val)))\n#define ASSIGN_MIN(var, val) ((var) = min((var), (val)))\n// }}}\n// conversion {{{\ninline int toInt(string s) { int v; istringstream sin(s); sin>>v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout<<x; return sout.str(); }\n// }}}\n// array and STL {{{\n#define ARRSIZE(a) ( sizeof(a) / sizeof(a[0]) )\n#define ZERO(a, v) ( assert(v == 0 || v == -1), memset(a, v, sizeof(a)) )\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define SIZE(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c, it) for(typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define REACH(c, it) for(typeof((c).rbegin()) it=(c).rbegin(); it!=(c).rend(); ++it)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n// }}}\n// bit manipulation {{{\n// singed integers are not for bitwise operations, specifically arithmetic shifts ('>>', and maybe not good for '<<' too)\n#define IS_UNSIGNED(n) (!numeric_limits<typeof(n)>::is_signed)\n#define BIT(n) (assert(IS_UNSIGNED(n)), assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(IS_UNSIGNED(n)), assert(m < 64), ((ULL)(n) >> (m) & 1))\ninline int BITS_COUNT(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int MSB(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c-1; }\ninline int MAKE_MASK(ULL upper, ULL lower) { assert(lower < 64 && upper < 64 && lower <= upper); return (BIT(upper) - 1) ^ (BIT(lower) - 1); }\n// }}}\n// for readable code {{{\n#define EVEN(n) (n % 2 == 0)\n#define ODD(n) (!EVEN(n))\n// }}}\n// debug {{{\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n#define dprt(fmt, ...) if (opt_debug) { fprintf(stderr, fmt, ##__VA_ARGS__); }\n#define darr(a) if (opt_debug) { copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr_range(a, f, t) if (opt_debug) { copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define dvec(v) if (opt_debug) { copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr2(a) if (opt_debug) { FOR(__i, 0, (arrsz(a))){ darr( (a)[__i] ); } }\n#define WAIT() if (opt_debug) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#define dump(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl; }\n// dump vector elements in [s, e)\n#define dumpv(v, s, e) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #v << \" = \"; FOR(__i, s, e) { cerr << v[__i] << \"\\t\"; } cerr << endl; }\n#define dumpl(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << endl << (x) << endl; }\n#define dumpf() if (opt_debug) { cerr << __PRETTY_FUNCTION__ << endl; }\n#define where() if (opt_debug) { cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl; }\n#define dumpb(bit, digits) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #bit << \" = \"; for(int __i = digits - 1; __i >= 0; __i--) { cerr << static_cast<bool>(bit & (1 << __i)); if (__i % 4 == 0) { cerr << \" \"; } } cerr << endl; }\n\n// ostreams {{{\n// complex\ntemplate<typename T> ostream& operator<<(ostream& s, const complex<T>& d) {return s << \"(\" << d.real() << \", \" << d.imag() << \")\";}\n\n// pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n// vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i]; if (i < len - 1) s << \"\\t\";\n\t}\n\treturn s;\n}\n\n// 2 dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i] << endl;\n\t}\n\treturn s;\n}\n\n// map\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const map<T1, T2>& m) {\n\ts << \"{\" << endl;\n\tfor (typeof(m.begin()) itr = m.begin(); itr != m.end(); ++itr) {\n\t\ts << \"\\t\" << (*itr).first << \" : \" << (*itr).second << endl;\n\t}\n\ts << \"}\" << endl;\n\treturn s;\n}\n// }}}\n// }}}\n// }}}\n// time {{{\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\n// }}}\n// string manipulation {{{\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\ninline string join(VS s, string j) { string t; REP(i, s.size()) { t += s[i] + j; } return t; }\n// }}}\n// geometry {{{\n#define Y first\n#define X second\n// }}}\n// 2 dimentional array {{{\nenum { UP, RIGHT, DOWN, LEFT, UP_RIGHT, DOWN_RIGHT, DOWN_LEFT, UP_LEFT };\nP dydx4[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\nP dydx8[8] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(-1, 1), P(1, 1), P(1, -1), P(-1, -1) };\nbool in_field(int H, int W, P p) {\n\treturn (0 <= p.Y && p.Y < H) && (0 <= p.X && p.X < W);\n}\n// }}}\n// input and output {{{\ninline void input(string filename) {\n\tfreopen(filename.c_str(), \"r\", stdin);\n}\ninline void output(string filename) {\n\tfreopen(filename.c_str(), \"w\", stdout);\n}\n// }}}\n// }}}\n\nbool opt_debug = false;\n\nint main(int argc, char** argv) {\n\tstd::ios_base::sync_with_stdio(false);\n\t// set options {{{\n\tint __c;\n\twhile ( (__c = getopt(argc, argv, \"d\")) != -1 ) {\n\t\tswitch (__c) {\n\t\t\tcase 'd':\n\t\t\t\topt_debug = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tabort();\n\t\t}\n\t}\n\t// }}}\n\n\t// opt_debug = true;\n\t// input(\"./inputs/0.txt\");\n\t// output(\"./outputs/0.txt\");\n\n\tint W, H;\n\twhile (cin >> W >> H, W | H) {\n\t\tVVC room_l(H, VC(W));\n\t\tVVC room_r(H, VC(W));\n\t\tP len, rin;\n\t\tREP (i, H) {\n\t\t\tREP (j, W) {\n\t\t\t\tcin >> room_l[i][j];\n\t\t\t\tif (room_l[i][j] == 'L') {\n\t\t\t\t\tlen = P(i, j);\n\t\t\t\t\troom_l[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP (j, W) {\n\t\t\t\tcin >> room_r[i][j];\n\t\t\t\tif (room_r[i][j] == 'R') {\n\t\t\t\t\trin = P(i, j);\n\t\t\t\t\troom_r[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttypedef pair<P, P> PPP;\n\t\tqueue<PPP> q;\n\t\tq.push(MP(len, rin));\n\t\tP dydx_l[4] = { MP(-1, 0), MP(0, 1), MP(1, 0), MP(0, -1) };\n\t\tP dydx_r[4] = { MP(-1, 0), MP(0, -1), MP(1, 0), MP(0, 1) };\n\t\ttypedef pair< pair<char, char>, pair<char, char> > PPIIPII;\n\t\tbool pushed[50][50][50][50] = { 0 };\n\t\tbool ok = false;\n\t\twhile (!q.empty()) {\n\t\t\tPPP t = q.front(); q.pop();\n\t\t\tPPIIPII key = MP( MP(t.F.Y, t.F.X), MP(t.S.Y, t.S.X) );\n\t\t\tlen = t.F; rin = t.S;\n\t\t\tif (room_l[len.Y][len.X] == '%' && room_r[rin.Y][rin.X] == '%') {\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (room_l[len.Y][len.X] == '%' || room_r[rin.Y][rin.X] == '%') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tREP (d, 4) {\n\t\t\t\tP n_len = MP(len.Y + dydx_l[d].Y, len.X + dydx_l[d].X);\n\t\t\t\tP n_rin = MP(rin.Y + dydx_r[d].Y, rin.X + dydx_r[d].X);\n\t\t\t\tif (!in_field(H, W, n_len) || room_l[n_len.Y][n_len.X] == '#') {\n\t\t\t\t\tn_len = len;\n\t\t\t\t}\n\t\t\t\tif (!in_field(H, W, n_rin) || room_r[n_rin.Y][n_rin.X] == '#') {\n\t\t\t\t\tn_rin = rin;\n\t\t\t\t}\n\n\t\t\t\tPPIIPII _key = MP( n_len, n_rin );\n\t\t\t\tif (!pushed[n_len.Y][n_len.X][n_rin.Y][n_rin.X]) {\n\t\t\t\t\tq.push(MP(n_len, n_rin));\n\t\t\t\t\tpushed[n_len.Y][n_len.X][n_rin.Y][n_rin.X] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ok) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t} else {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define M 52\n#include<cstring>\nusing namespace std;\nbool flag;\nint dx[]={1,-1,0,0},dy[]={0,0,-1,1},w,h;\nchar r[M][M],l[M][M];\nbool dp[M][M][M][M];\nvoid func(int ly,int lx,int ry,int rx){\n\t//cout<<ly<<' '<<lx<<' '<<ry<<' '<<rx<<endl;\n\tif(dp[ly][lx][ry][rx]!=0)\n\treturn;\n\tdp[ly][lx][ry][rx]=1;\n\tif(l[ly][lx]=='%'&&r[ry][rx]=='%'){\n\t\tflag=true;\n\t\treturn;\n\t}else if(l[ly][lx]=='%')\n\treturn;\n\telse if(r[ry][rx]=='%')\n\treturn;\n\tint nrx,nry,nlx,nly;\n\tfor(int i=0;i<4;i++){\n\t\tnrx=dx[i]+rx;\n\t\tnry=dy[i]+ry;\n\t\tnlx=-dx[i]+lx;\n\t\tnly=dy[i]+ly;\n\t\tif(!(nrx>=0&&nrx<w&&nry>=0&&nry<h)||r[nry][nrx]=='#'){\n\t\t\tnrx=rx;nry=ry;\n\t\t}\n\t\tif(!(nlx>=0&&nlx<w&&nly>=0&&nly<h)||l[nly][nlx]=='#'){\n\t\t\tnlx=lx;nly=ly;\n\t\t}\n\t\tif(dp[nly][nlx][nry][nrx]==0)\n\t\tfunc(nly,nlx,nry,nrx);\n\t}\n}\nint main(){\n\tint a,b,c,d;\n\twhile(cin>>w>>h,h||w){\n\t\tfor(int i=0;i<h;i++)\n\t\t\tcin>>l[i]>>r[i];\n\t\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++)\n\t\tif(l[i][j]=='L')\n\t\ta=i,b=j;\n\t\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++)\n\t\tif(r[i][j]=='R')\n\t\tc=i,d=j;\n\t\tmemset(dp,sizeof(dp),0);\n\t\tflag=false;\n\t\tfunc(a,b,c,d);\n\t\tputs(flag?\"Yes\":\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<cmath>\n#include<utility>\n#include<functional>\n#include<map>\n#include<set>\n#include<cctype>\n\n\n#define FOR(i, a, b) for( int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for( int i=(a);i>=(b);i--)\n#define LFOR(i, a, b) for( long long int i=(a);i<=(b);i++)\n#define LRFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LLINF 1000000000000000000 //9000000000000000000\n#define PI 3.14159265358979\n#define MAXI 7500000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\n\nint dy[4] = { 0,0,1,-1 };\nint dx[4] = { 1,-1,0,0 };\n\n//int dp[50][50][50][50] = {};//ly,lx,ry,rx\n\n\nint main(void) {\n\t\n\twhile (1) {\n\t\tbool flag = false;\n\t\tint w, h;\n\t\tint lx = -1, ly = -1, rx = -1, ry = -1;\n\t\tint lgx = -1, lgy = -1, rgx = -1, rgy = -1;\n\n\t\tvector< vector< vector< vector<int> > > > dp(50, vector< vector< vector<int > > >(50, vector< vector<int> >(50, vector<int>(50, 0))));\n\t\t\n\n\t\tpair< pair<int, int>, pair<int, int> > Pair;\n\n\t\tqueue<pair< pair<int, int>, pair<int, int > > > que;\n\n\t\tcin >> w >> h;\n\n\t\tif (w == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tvector<string> left(h), right(h);\n\n\t\tFOR(i, 0, h-1) {\n\t\t\tcin >> left[i] >> right[i];\n\t\t}\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (left[i][j] == 'L') {\n\t\t\t\t\tlx = j;\n\t\t\t\t\tly = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (right[i][j] == 'R') {\n\t\t\t\t\trx = j;\n\t\t\t\t\try = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (left[i][j] == '%') {\n\t\t\t\t\tlgx = j;\n\t\t\t\t\tlgy = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lgx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (right[i][j] == '%') {\n\t\t\t\t\trgx = j;\n\t\t\t\t\trgy = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rgx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdp[ly][lx][ry][rx] = 1;\n\n\t\t\n\t\t\n\t\tque.push(make_pair(make_pair(ly,lx),make_pair(ry,rx)));\n\n\n\t\twhile (!que.empty()) {\n\t\t\tPair = que.front();\n\t\t\t\n\t\t\tque.pop();\n\t\t\tly = Pair.first.first;\n\t\t\tlx = Pair.first.second;\n\t\t\try = Pair.second.first;\n\t\t\trx = Pair.second.second;\n\t\t\t//cout << ly << \" \" << lx << \" \" << ry << \" \" << rx << endl;\n\n\t\t\tFOR(i, 0, 3) {\n\t\t\t\t\n\t\t\t\tif (ly + dy[i] >= 0 && lx - dx[i] >= 0 && ry + dy[i] <= h - 1 && rx + dx[i] <= w - 1 && ly + dy[i] <= h - 1 && lx - dx[i] <= w - 1 && ry + dy[i] >= 0 && rx + dx[i] >= 0) {\n\t\t\t\t\t\tif (left[ly + dy[i]][lx - dx[i]] == '#') {\n\t\t\t\t\t\t\tif (right[ry + dy[i]][rx + dx[i]] == '#') {\n\t\t\t\t\t\t\t\t//no\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (dp[ly][lx][ry + dy[i]][rx + dx[i]] != 1) {\n\t\t\t\t\t\t\t\t\tdp[ly][lx][ry + dy[i]][rx + dx[i]] = 1;\n\t\t\t\t\t\t\t\t\tque.push(make_pair(make_pair(ly, lx), make_pair(ry + dy[i], rx + dx[i])));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (right[ry + dy[i]][rx + dx[i]] == '#') {\n\t\t\t\t\t\t\t\tif (dp[ly + dy[i]][lx - dx[i]][ry][rx] != 1) {\n\t\t\t\t\t\t\t\t\tdp[ly + dy[i]][lx - dx[i]][ry][rx] = 1;\n\t\t\t\t\t\t\t\t\tque.push(make_pair(make_pair(ly + dy[i], lx - dx[i]), make_pair(ry, rx)));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (dp[ly + dy[i]][lx - dx[i]][ry + dy[i]][rx + dx[i]] != 1) {\n\t\t\t\t\t\t\t\t\tdp[ly + dy[i]][lx - dx[i]][ry + dy[i]][rx + dx[i]] = 1;\n\t\t\t\t\t\t\t\t\tque.push(make_pair(make_pair(ly + dy[i], lx - dx[i]), make_pair(ry + dy[i], rx + dx[i])));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dp[lgy][lgx][rgy][rgx] == 1) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (dp[lgy][lgx][rgy][rgx] == 1||flag==true) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t\t\n\n\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int MAX = 55;\nchar rm[MAX][MAX], lm[MAX][MAX];\nint w, h;\n\nstruct Point{\n    int x,y;\n    bool operator == ( const Point &right ) const {\n        if(right.x == x && right.y == y) return 1;\n        else return 0;\n    }\n    bool operator < ( const Point &right ) const {\n        if(x < right.x) return 1;\n        else if(x == right.x && y < right.y) return 1;\n        else return 0;\n    }\n};\nbool u[MAX][MAX][MAX][MAX];\nPoint rg, lg;\nbool ans;\n\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\nvoid dfs(Point rp, Point lp){\n    u[rp.y][rp.x][lp.y][lp.x] = true;\n    if(rg == rp && lg == lp) ans = true;\n    rep(i,4){\n        int lnx = lp.x + dx[i];\n        int lny = lp.y + dy[i];\n        int rnx = rp.x + dx[i] * -1;\n        int rny = rp.y + dy[i];\n        if( (lny < 0 || lny >= h || lnx < 0 || lnx >= w) || lm[lny][lnx] == '#'){\n            lnx = lp.x;\n            lny = lp.y;\n        }\n        if( (rny < 0 || rny >= h || rnx < 0 || rnx >= w) || rm[rny][rnx] == '#'){\n            rnx = rp.x;\n            rny = rp.y;\n        }\n        if(u[rny][rnx][lny][lnx]) continue;\n        dfs(Point{rnx,rny}, Point{lnx,lny});\n    }\n}\n\nint main(){\n    while(cin >> w >> h, w){\n        ans = false;\n        Point rp, lp;\n        rep(i,h){\n            rep(j,w * 2){\n                if(j < w){\n                    cin >> lm[i][j];\n                    if(lm[i][j] == 'L'){\n                        lp = Point{j,i};\n                    }\n                    if(lm[i][j] == '%'){\n                        lg = Point{j,i};\n                    }\n                }else{\n                    cin >> rm[i][j - w];\n                    if(rm[i][j - w] == 'R'){\n                        rp = Point{j - w,i};\n                    }\n                    if(rm[i][j - w] == '%'){\n                        rg = Point{j - w,i};\n                    }\n                }\n            }\n        }\n        dfs(rp,lp);\n        cout << (ans ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct data {\n  int x[2], y[2];\n};\n\nint h, w;\nint d[4] = {0, 1, 0, -1};\nstring s[2][55];\nbool ch[55][55][55][55] = {0};\nqueue<data> qu;\n\nvoid chset();\nbool solve();\nbool chover(data now);\n\nint main() {\n  while(1) {\n    cin >> w >> h;\n    if(w + h == 0) break;\n    for(int i = 0; i < h; ++i)\n      for(int j = 0; j < 2; ++j) cin >> s[j][i];\n    for(int i = 0; i < 2; ++i) chset();\n    if(solve())\n      cout << \"Yes\" << endl;\n    else\n      cout << \"No\" << endl;\n    while(qu.size() > 0) qu.pop();\n  }\n  return 0;\n}\n\nvoid chset() {\n  for(int i = 0; i < h; ++i)\n    for(int j = 0; j < w; ++j)\n      for(int k = 0; k < h; ++k)\n        for(int l = 0; l < w; ++l) ch[i][j][k][l] = 0;\n}\nbool solve() {\n  data fi;\n  for(int i = 0; i < h; ++i)\n    for(int j = 0; j < w; ++j)\n      for(int k = 0; k < 2; ++k)\n        if(s[k][i][j] == 'L' || s[k][i][j] == 'R') {\n          fi.x[k] = i;\n          fi.y[k] = j;\n          s[k][i][j] = '.';\n        }\n  qu.push(fi);\n  ch[fi.x[0]][fi.y[0]][fi.x[1]][fi.y[1]] = 1;\n  while(qu.size() > 0) {\n    data now = qu.front();\n    qu.pop();\n    for(int i = 0; i < 4; ++i) {\n      data nextp = now;\n      int cnt = 0;\n      for(int j = 0; j < 2; ++j) {\n        nextp.x[j] += d[i];\n        nextp.y[j] += d[1 ^ i] * (1 - 2 * j);\n      }\n      for(int j = 0; j < 2; ++j)\n        if(nextp.x[j] < 0 || nextp.y[j] < 0 ||\n           nextp.x[j] >= h || nextp.y[j] >= w ||\n           s[j][nextp.x[j]][nextp.y[j]] == '#') {\n          nextp.x[j] -= d[i];\n          nextp.y[j] -= d[1 ^ i] * (1 - 2 * j);\n        }\n        else if(s[j][nextp.x[j]][nextp.y[j]] == '%')\n          ++cnt;\n      if(cnt == 2)\n        return 1;\n      else if(cnt != 0)\n        continue;\n      if(!ch[nextp.x[0]][nextp.y[0]][nextp.x[1]]\n            [nextp.y[1]]) {\n        ch[nextp.x[0]][nextp.y[0]][nextp.x[1]][nextp.y[1]] =\n            1;\n        qu.push(nextp);\n      }\n    }\n  }\n\n  return 0;\n}\n\nbool chover(data now) {\n  for(int i = 0; i < 2; ++i)\n    if(now.x[i] < 0 || now.x[i] >= h || now.y[i] < 0 ||\n       now.y[i] >= w)\n      return 0;\n  return 1;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"tune=native\")\n#pragma GCC target (\"avx\")\n\n#include <bits/stdc++.h>\n\n// 汎用マクロ\n#define ALL_OF(x) (x).begin(), (x).end()\n#define REP(i,n) for (long long i=0, i##_len=(n); i<i##_len; i++)\n#define RANGE(i,is,ie) for (long long i=(is), i##_end=(ie); i<=i##_end; i++)\n#define DSRNG(i,is,ie) for (long long i=(is), i##_end=(ie); i>=i##_end; i--)\n#define UNIQUE(v) { sort((v).begin(), (v).end()); (v).erase(unique((v).begin(), (v).end()), (v).end()); }\ntemplate<class T> bool chmax(T &a, const T &b) {if (a < b) {a = b; return 1;} return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) {if (a > b) {a = b; return 1;} return 0; }\n#define INF 0x7FFFFFFF\n#define LINF 0x7FFFFFFFFFFFFFFFLL\n#define Yes(q) (q ? \"Yes\" : \"No\")\n#define YES(q) (q ? \"YES\" : \"NO\")\n#define DUMP(q) cerr << \"[DEBUG] \" #q \": \" << (q) << \" at \" __FILE__ \":\" << __LINE__ << endl\n#define DUMPALL(q) cerr << \"[DEBUG] \" #q \": [\"; REP(dumpall_i, (q).size()) { cerr << q[dumpall_i] << (dumpall_i == (q).size() - 1 ? \"\" : \", \"); } cerr << \"] at \" __FILE__ \":\" << __LINE__ << endl\n\n// gcc拡張マクロ\n#define gcd __gcd\n#define popcount __builtin_popcount\n#define popcountll __builtin_popcountll\n\n// エイリアス\nusing  ll = long long;\nusing ull = unsigned long long;\nusing  ld = long double;\nusing namespace std;\n\n// モジュール\n\n\n// 処理内容\nint main() {\n    \n    ll w, h;\n    while (cin >> w >> h, w && h) {\n\n        vector<string> rl(h), rr(h);\n        REP(i, h) cin >> rl[i] >> rr[i];\n        ll lsy, lsx, rsy, rsx;\n        ll lgy, lgx, rgy, rgx;\n        REP(i, h) REP(j, w) {\n            if (rl[i][j] == '%') {\n                lgy = i;\n                lgx = j;\n            } else if (rl[i][j] == 'L') {\n                lsy = i;\n                lsx = j;\n            }\n            if (rr[i][j] == '%') {\n                rgy = i;\n                rgx = j;\n            } else if (rr[i][j] == 'R') {\n                rsy = i;\n                rsx = j;\n            }\n        }\n\n        // {ly, lx, ry, rx}\n        deque<tuple<ll,ll,ll,ll>> q;\n        vector<vector<vector<vector<bool>>>> visited(h, vector<vector<vector<bool>>>(w, vector<vector<bool>>(h, vector<bool>(w, false))));\n        q.emplace_back(lsy, lsx, rsy, rsx);\n        visited[lsy][lsx][rsy][rsx] = true;\n        while (!q.empty()) {\n\n            ll ly = get<0>(q.front());\n            ll lx = get<1>(q.front());\n            ll ry = get<2>(q.front());\n            ll rx = get<3>(q.front());\n            q.pop_front();\n\n            // Lin and Ren go upward\n            if (ly > 0 && ry > 0) {\n                ll ly2 = rl[ly - 1][lx] != '#' ? ly - 1 : ly;\n                ll lx2 = lx;\n                ll ry2 = rr[ry - 1][lx] != '#' ? ry - 1 : ry;\n                ll rx2 = rx;\n                bool lgoaled = ly2 == lgy && lx2 == lgx;\n                bool rgoaled = ry2 == rgy && rx2 == rgx;\n                if (lgoaled == rgoaled && !visited[ly2][lx2][ry2][rx2]) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n            }\n\n            // Lin and Ren go downward\n            if (ly < h-1 && ry < h-1) {\n                ll ly2 = rl[ly + 1][lx] != '#' ? ly + 1 : ly;\n                ll lx2 = lx;\n                ll ry2 = rr[ry + 1][lx] != '#' ? ry + 1 : ry;\n                ll rx2 = rx;\n                bool lgoaled = ly2 == lgy && lx2 == lgx;\n                bool rgoaled = ry2 == rgy && rx2 == rgx;\n                if (lgoaled == rgoaled && !visited[ly2][lx2][ry2][rx2]) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n            }\n\n            // Lin goes left and Ren goes right\n            if (lx > 0 && rx < w-1) {\n                ll ly2 = ly;\n                ll lx2 = rl[ly][lx - 1] != '#' ? lx - 1 : lx;\n                ll ry2 = ry;\n                ll rx2 = rr[ry][rx + 1] != '#' ? rx + 1 : rx;\n                bool lgoaled = ly2 == lgy && lx2 == lgx;\n                bool rgoaled = ry2 == rgy && rx2 == rgx;\n                if (lgoaled == rgoaled && !visited[ly2][lx2][ry2][rx2]) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n            }\n\n            // Lin goes right and Ren goes left\n            if (lx < w-1 && rx > 0) {\n                ll ly2 = ly;\n                ll lx2 = rl[ly][lx + 1] != '#' ? lx + 1 : lx;\n                ll ry2 = ry;\n                ll rx2 = rr[ry][rx - 1] != '#' ? rx - 1 : rx;\n                bool lgoaled = ly2 == lgy && lx2 == lgx;\n                bool rgoaled = ry2 == rgy && rx2 == rgx;\n                if (lgoaled == rgoaled && !visited[ly2][lx2][ry2][rx2]) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n            }\n\n        }\n\n        std::cout << Yes(visited[lgy][lgx][rgy][rgx]) << endl;\n\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return n ? __builtin_popcount(n) : 0; }\ntemplate <> int popcount(int n) { return n ? __builtin_popcount(n) : 0; }\ntemplate <> int popcount(unsigned long long n) { return n ? __builtin_popcountll(n) : 0; }\ntemplate <> int popcount(long long n) { return n ? __builtin_popcountll(n) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\n\n\nint w, h;\nchar l[64][64], r[64][64];\nbool solve()\n{\n\tint lx, ly, rx, ry;\n\tfor (int y = 0; y < h; ++y)\n\t{\n\t\tfor (int x = 0; x < w; ++x)\n\t\t{\n\t\t\tif (l[y][x] == 'L')\n\t\t\t\tlx = x, ly = y;\n\t\t\tif (r[y][x] == 'R')\n\t\t\t\trx = x, ry = y;\n\t\t}\n\t}\n\n\tstatic bool visit[64][64][64][64];\n\tCL(visit, 0);\n\n\ttypedef pair<pint, pint> P;\n\tqueue<P> q;\n\tvisit[ly][lx][ry][rx] = true;\n\tq.push(P(pint(lx, ly), pint(rx, ry)));\n\twhile (!q.empty())\n\t{\n\t\tP t = q.front(); q.pop();\n\t\tint lx = t.first.first, ly = t.first.second;\n\t\tint rx = t.second.first, ry = t.second.second;\n\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint nx, ny, mx, my;\n\t\t\tint x = dx[i], y = dy[i];\n\n\t\t\tnx = lx + x, ny = ly + y;\n\t\t\tif (!valid_pos(nx, ny, w, h) || l[ny][nx] == '#')\n\t\t\t\tnx = lx, ny = ly;\n\n\t\t\tif (i == 1 || i == 3)\n\t\t\t\tx *= -1;\n\t\t\tmx = rx + x, my = ry + y;\n\t\t\tif (!valid_pos(mx, my, w, h) || r[my][mx] == '#')\n\t\t\t\tmx = rx, my = ry;\n\n\t\t\tif (valid_pos(nx, ny, w, h) && valid_pos(mx, my, w, h)\n\t\t\t\t&& !visit[ny][nx][my][mx])\n\t\t\t{\n\t\t\t\tvisit[ny][nx][my][mx] = true;\n\t\t\t\tif (l[ny][nx] == '%' && r[my][mx] == '%')\n\t\t\t\t\treturn true;\n\t\t\t\telse if (l[ny][nx] != '%' && r[my][mx] != '%')\n\t\t\t\t\tq.push(P(pint(nx, ny), pint(mx, my)));\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\twhile (scanf(\"%d%d\", &w, &h), w)\n\t{\n\t\tfor (int i = 0; i < h; ++i)\n\t\t\tscanf(\"%s%s\", l[i], r[i]);\n\t\tputs(solve() ? \"Yes\" : \"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <tuple>\n#include <string>\n#include <cstring>\n#include <iostream>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nconst int dx1[4] = { 0, 1, 0, -1 };\nconst int dy1[4] = { -1, 0, 1, 0 };\nconst int dx2[4] = { 0, -1, 0, 1 };\nconst int dy2[4] = { -1, 0, 1, 0 };\n\nint H, W; string L[50], R[50];\n\nbool used[50][50][50][50];\n\nbool over(int x, int y)\n{\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\nbool solve(int x1, int y1, int x2, int y2)\n{\n\tqueue<tuple<int, int, int, int> > que;\n\n\tque.push(make_tuple(y1, x1, y2, x2));\n\n\tused[y1][x1][y2][x2] = true;\n\n\twhile (!que.empty())\n\t{\n\t\tint ly = get<0>(que.front());\n\t\tint lx = get<1>(que.front());\n\t\tint ry = get<2>(que.front());\n\t\tint rx = get<3>(que.front());\n\n\t\tque.pop();\n\n\t\tif (L[ly][lx] == '%' && R[ry][rx] == '%') return true;\n\n\t\tif (L[ly][lx] == '%') continue;\n\t\tif (R[ry][rx] == '%') continue;\n\n\t\tbool ok = false;\n\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\tint ltx = lx + dx1[i];\n\t\t\tint lty = ly + dy1[i];\n\t\t\tint rtx = rx + dx2[i];\n\t\t\tint rty = ry + dy2[i];\n\n\t\t\tif (over(ltx, lty) && over(rtx, rty))\n\t\t\t{\n\t\t\t\tif (L[lty][ltx] == '#')\n\t\t\t\t{\n\t\t\t\t\tltx -= dx1[i];\n\t\t\t\t\tlty -= dy1[i];\n\t\t\t\t}\n\n\t\t\t\tif (R[rty][rtx] == '#')\n\t\t\t\t{\n\t\t\t\t\trtx -= dx2[i];\n\t\t\t\t\trty -= dy2[i];\n\t\t\t\t}\n\n\t\t\t\tif (!used[lty][ltx][rty][rtx])\n\t\t\t\t{\n\t\t\t\t\tused[lty][ltx][rty][rtx] = true;\n\n\t\t\t\t\tque.push(make_tuple(lty, ltx, rty, rtx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &W);\n\t\tscanf(\"%d\", &H);\n\n\t\tif (W == 0 && H == 0) break;\n\n\t\tfor (int i = 0; i < 50; i++) L[i] = \"\";\n\t\tfor (int i = 0; i < 50; i++) R[i] = \"\";\n\n\t\tfor (int i = 0; i < H; i++) cin >> L[i] >> R[i];\n\n\t\tint lx, ly, rx, ry;\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (L[i][j] == 'L')\n\t\t\t\t{\n\t\t\t\t\tlx = j;\n\t\t\t\t\tly = i;\n\t\t\t\t}\n\n\t\t\t\tif (R[i][j] == 'R')\n\t\t\t\t{\n\t\t\t\t\trx = j;\n\t\t\t\t\try = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(used, false, sizeof(used));\n\n\t\tprintf(\"%s\\n\", solve(lx, ly, rx, ry) ? \"Yes\" : \"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\n#define LX zahyou[0][0]\n#define LY zahyou[0][1]\n#define RX zahyou[1][0]\n#define RY zahyou[1][1]\n#define RROOM room[0][LY][LX]\n#define LROOM room[1][RY][RX]\n#define DINU for(int i = 0; i < 2; i++){temp[i][0] = zahyou[i][0]; temp[i][1] = zahyou[i][1];}\n\nint W, H;\n\n\nint foo(char room[2][60][60], int zahyou[2][2]) {\n\tint temp[2][2];\n\tif ((LX < 1 || LX > W) || (RX < 1 || RX > W) || (LY < 1 || LY > H) || (LY < 0 || LY > H)) return 0;\n\tif (RROOM == 'X' && LROOM == 'X') return 0;\n\tif (RROOM == '%' && LROOM == '%') return 1;\n\tif (RROOM == '%' || LROOM == '%')return 0;\n\t RROOM = 'X'; LROOM = 'X';\n\n\n\tDINU\n\n\tif (room[0][LY + 1][LX] != '#') temp[0][1] = LY + 1;\n\tif (room[1][RY + 1][RX] != '#') temp[1][1] = RY + 1;\n\tif (foo(room, temp))return 1;\n\n\tDINU\n\n\tif (room[0][LY - 1][LX] != '#') temp[0][1] = LY - 1;\n\tif (room[1][RY - 1][RX] != '#') temp[1][1] = RY - 1;\n\tif (foo(room, temp))return 1;\n\n\tDINU\n\n\tif (room[0][LY][LX + 1] != '#') temp[0][0] = LX + 1;\n\tif (room[1][RY][RX - 1] != '#') temp[1][0] = RX - 1;\n\tif (foo(room, temp))return 1;\n\n\tDINU\n\n\tif (room[0][LY][LX - 1] != '#') temp[0][0] = LX - 1;\n\tif (room[1][RY][RX + 1] != '#') temp[1][0] = RX + 1;\n\tif (foo(room, temp))return 1;\n\n\n\treturn 0;\n}\n\n\n\nint main() {\n\tstring temp1, temp2;\n\n\tint zahyou[2][2];\n\n\twhile (1) {\n\t\tchar room[2][60][60] = {};\n\t\tcin >> W >> H;\n\t\tif (W == 0 && H == 0) break;\n\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tcin >> temp1>>temp2;\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\troom[0][i][j] = temp1[j-1];\n\t\t\t\tif (room[0][i][j] == 'L') {\n\t\t\t\t\tLX = j;\n\t\t\t\t\tLY = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\troom[1][i][j] = temp2[j-1];\n\t\t\t\tif (room[1][i][j] == 'R') {\n\t\t\t\t\tRX = j;\n\t\t\t\t\tRY = i;\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t}\n\n\t\tif (foo(room, zahyou)) cout << \"Yes\" << endl;\n\t\telse cout <<\"No\"<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n\n#define F first\n#define S second\n\nusing namespace std;\n\nconst int MAX = 51;\ntypedef pair<int,int> P;\nchar M[2][MAX][MAX];\nbool come[MAX][MAX][MAX][MAX];\nint W,H;\nP s1,s2;\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\nbool ans;\n\nvoid init(){\n  memset(come,false,sizeof(come));\n  ans = false;\n}\n\nvoid print(){\n  for(int x = 0; x < 2; x++){\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++) cout << M[x][i][j];\n      cout << endl;\n    }\n    cout << endl<< endl;\n  }\n}\n\nvoid input(){\n  for(int i = 0; i < H; i++)\n    for(int x = 0; x < 2; x++)\n      for(int j = 0; j < W; j++){\n\tcin >> M[x][i][j];\n\tif(M[x][i][j] == 'L' && !x) s1 = P(i,j);\n\tif(M[x][i][j] == 'R' && x) s2 = P(i,j);\n\t}\n}\n\nbool isInside(int x, int y){return 0<=x&&x<W&&0<=y&&y<H;}\n\nvoid rec(int x1, int y1, int x2, int y2){\n\n  if(come[x1][y1][x2][y2]) return;\n  come[x1][y1][x2][y2] = true;\n  //cout << x1 <<  \" \" << y1 << \" \" << x2 << \" \" << y2 <<endl;\n  if(M[0][y1][x1] == '%' && M[1][y2][x2] == '%') {\n    ans = true;\n    return;\n  }\n  if(M[0][y1][x1] == '%' || M[1][y2][x2] == '%') return;\n  \n  bool tmp = false;\n\n  for(int i = 0; i < 4; i++){\n    int nx1 = x1+dx[i];\n    int ny1 = y1+dy[i];\n    int nx2 = x2-dx[i];\n    int ny2 = y2+dy[i];\n    if(!isInside(nx1,ny1) || M[0][ny1][nx1] == '#'){\n      nx1 = x1;\n      ny1 = y1;\n    }\n    if(!isInside(nx2,ny2) || M[1][ny2][nx2] == '#'){\n      nx2 = x2;\n      ny2 = y2;\n    }\n    \n    if(!come[nx1][ny1][nx2][ny2]) rec(nx1,ny1,nx2,ny2);\n  }\n} \n\nvoid solve(){\n  rec(s1.S,s1.F,s2.S,s2.F);\n  if(ans) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n}\n\nint main(){\n  while(cin >> W >> H && W+H){\n    init();\n    input();\n    //   print();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 51\n\nstruct State{\n  int x1,y1,x2,y2;\n  State(int x1, int y1, int x2, int y2) : x1(x1), y1(y1), x2(x2), y2(y2) {}\n};\n\nint H, W;\nchar f1[MAX][MAX], f2[MAX][MAX];\nbool vis[MAX][MAX][MAX][MAX];\nconst int lx[] = {0,-1,1,0};\nconst int ly[] = {-1,0,0,1};\nconst int rx[] = {0,1,-1,0};\nconst int ry[] = {-1,0,0,1};\n\nbool inField(int y, int x){\n  return 0 <= y && y < H && 0 <= x && x < W;\n}\n\nbool bfs(int Lx, int Ly, int Rx, int Ry){\n  memset(vis, false, sizeof(vis));\n  queue<State> Q;\n  Q.push(State(Lx, Ly, Rx, Ry));\n\n  while(!Q.empty()){\n    State s = Q.front(); Q.pop();\n\n    if(f1[s.y1][s.x1] == '%' && f2[s.y2][s.x2] == '%'){\n      return true;\n    }\n\n    for(int i = 0 ; i < 4 ; i++){\n      int nlx = s.x1 + lx[i], nly = s.y1 + ly[i];\n      int nrx = s.x2 + rx[i], nry = s.y2 + ry[i];\n\n      if(!inField(nly, nlx) || f1[nly][nlx] == '#'){\n        nlx = s.x1;\n        nly = s.y1;\n      }\n      if(!inField(nry, nrx) || f2[nry][nrx] == '#'){\n        nrx = s.x2;\n        nry = s.y2;\n      }\n\n      if((f1[nly][nlx] == '%' && f2[nry][nrx] != '%') ||\n         (f1[nly][nlx] != '%' && f2[nry][nrx] == '%')) continue;\n\n      if(vis[nly][nlx][nry][nrx]) continue;\n      vis[nly][nlx][nry][nrx] = true;\n      Q.push(State(nlx, nly, nrx, nry));\n    }\n  }\n\n  return false;\n}\n\nint main(){\n  while(cin >> W >> H, (W | H)){\n    string str;\n    int Lx, Ly, Rx, Ry;\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < 2 ; j++){\n        cin >> str;\n        for(int k = 0 ; k < W ; k++){\n          if(j % 2 == 0){\n            f1[i][k] = str[k];\n            if(f1[i][k] == 'L'){\n              Lx = k;\n              Ly = i;\n            }\n          }else{\n            f2[i][k] = str[k];\n            if(f2[i][k] == 'R'){\n              Rx = k;\n              Ry = i;\n            }\n          }\n        }\n      }\n    }\n    cout << (bfs(Lx, Ly, Rx, Ry) ? \"Yes\" : \"No\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\nusing namespace std;\nbool bfs();\ntypedef pair<int,int> P;\nint w,h;\nchar mapL[111][111];\nchar mapR[111][111];\nint sxL,syL,gxL,gyL;\nint sxR,syR,gxR,gyR;\nbool flag;\nint dx[]={0,0,-1,1,0,0};\nint dy[]={-1,1,0,0,1,-1};\nint d[111][111];\n\nint main(){\n  cin >> w >> h;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin >> mapL[i][j];\n      if(mapL[i][j] == '%') gxL = j,gyL = i;\n      if(mapL[i][j] == 'L') sxL = j,syL = i;\n    }\n    for(int j=0;j<w;j++){\n      cin >> mapR[i][j];\n      if(mapR[i][j] == '%') gxR = j,gyR = i;\n      if(mapR[i][j] == 'R') sxR = j,syR = i;\n    }\n  }\n  cout << sxL << \" \" << syL << endl;\n  flag = bfs();\n  if(flag == true) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n}  \n\nbool bfs(){\n  queue <P> queL;\n  queue <P> queR;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      d[i][j] = -1;\n    }\n  }\n  queL.push(P(sxL,syL));\n  queR.push(P(sxR,syR));\n  d[sxL][syL] = 0;\n  d[sxR][syR] = 0;\n  while(queL.size() != 0 && queR.size() != 0){\n    P pL,pR;\n    pL = queL.front(); queL.pop();\n    pR = queR.front(); queR.pop();\n    cout << pL.first << \" \" << pL.second << \" \" << pR.first << \" \" << pR.second << endl;\n    if(pL.first == gxL && pL.second == gyL && pR.first == gxR && pR.second == gyR) return true;\n    for(int i=0;i<4;i++){\n      bool flag_next=false;\n      bool flagL=false;\n      bool flagR=false;\n      int nxL = pL.first + dx[i];\n      int nyL = pL.second + dy[i];\n      int nxR = pR.first + dx[5-i];\n      int nyR = pR.second + dy[5-i];\n      if(mapL[nxL][nyL] == '%' && mapR[nxR][nyR] == '%') flag_next = true;\n      else if(mapL[nxL][nyL] != '%' && mapR[nxR][nyR] != '%') flag_next = true;\n      if(nxL >= 0 && nxL < w && nyL >= 0 && nyL < h && mapL[nxL][nyL] != '#') flagL=true;\n      if(nxR >= 0 && nxR < w && nyR >= 0 && nyR < h && mapL[nxR][nyR] != '#') flagR=true;\n      if(flag_next == true && (flagL == true || flagR == true) && d[nxL][nyL] == -1 && d[nxR][nyR] == -1){\n\tif(flagL == true && flagR != true){\n\t  queL.push(P(nxL,nyL));\n\t  d[nxL][nyL]=0;\n\t  queR.push(P(pR.first,pR.second));\n\t} else if(flagL != true && flagR == true){\n\t  queR.push(P(nxR,nyR));\n\t  d[nxR][nyR]=0;\n\t  queL.push(P(pL.first,pL.second));\n\t} else {\n\t  queL.push(P(nxL,nyL));\n\t  d[nxL][nyL]=0;\n\t  queR.push(P(nxR,nyR));\n\t  d[nxR][nyR]=0;\n\t}\n      }\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct State{\n  int x1, y1, x2, y2;\n  State(int x1, int y1, int x2, int y2): x1(x1), y1(y1), x2(x2), y2(y2){}\n};\n\nconst int MAX = 55;\n\nconst int dx1[] = {1, 0, -1, 0};\nconst int dy1[] = {0, 1, 0, -1};\nconst int dx2[] = {-1, 0, 1, 0};\nconst int dy2[] = {0, 1, 0, -1};\n\nint H, W;\nchar grid[2][MAX][MAX];\nbool used[MAX][MAX][MAX][MAX];\nint sx1, sy1, sx2, sy2;\nint gx1, gy1, gx2, gy2;\n\nbool isValid(int x, int y){\n  return 0 <= x && x < W && 0 <= y && y < H;\n}\n\nbool solve(){\n  queue<State> que;\n  que.push(State(sx1, sy1, sx2, sy2));\n  \n  while(!que.empty()){\n    State q = que.front(); que.pop();\n\n    if(used[q.y1][q.x1][q.y2][q.x2]) continue;\n    used[q.y1][q.x1][q.y2][q.x2] = true;\n    \n    for(int i = 0 ; i < 4 ; i++){\n      int nx1 = q.x1 + dx1[i], ny1 = q.y1 + dy1[i];\n      int nx2 = q.x2 + dx2[i], ny2 = q.y2 + dy2[i];      \n      \n      if(!isValid(nx1, ny1) || !isValid(nx2, ny2)) continue;\n      if(grid[0][ny1][nx1] == '#' && grid[1][ny2][nx2] == '#') continue;      \n      \n      if(grid[0][ny1][nx1] == '#') nx1 = q.x1, ny1 = q.y1;\n      if(grid[1][ny2][nx2] == '#') nx2 = q.x2, ny2 = q.y2;\n      \n      que.push(State(nx1, ny1, nx2, ny2));\n    }\n  }\n  return used[gy1][gx1][gy2][gx2];\n}\n\nvoid init(){\n  memset(used, false, sizeof(used));\n  memset(grid, '.', sizeof(grid));\n}\n\nint main(){\n  while(cin >> W >> H, H|W){  \n    init();\n    \n    for(int i = 0 ; i < H ; i++)\n      for(int j = 0 ; j < 2 ; j++) cin >> grid[j][i];\n\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n\tif(grid[0][i][j] == 'L') sx1 = j, sy1 = i;\n\tif(grid[0][i][j] == '%') gx1 = j, gy1 = i;\n      }\n    }\n    \n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n\tif(grid[1][i][j] == 'R') sx2 = j, sy2 = i;\n\tif(grid[1][i][j] == '%') gx2 = j, gy2 = i;\n      }\n    }    \n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\n\nclass state{\npublic:\n\tint rx,ry,lx,ly;\n\tstate(int lx,int ly,int rx,int ry):lx(lx),ly(ly),rx(rx),ry(ry){}\n};\n\nint w,h;\n\nbool in(int x,int y)\n{\n\tif(x<0 || x>=w || y<0 || y>=h) return false;\n\treturn true;\n}\n\nbool done[50][50][50][50];\n\t\t\n\n\nint main(){\n\twhile(cin>>w>>h && w!=0){\n\t\tvector<string> L(h),R(h);\n\t\tint flx,fly,frx,fry;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>L[i]>>R[i];\n\t\t\tfor(int k=0;k<L[i].size();k++){\n\t\t\t\tif(L[i][k]=='L'){flx=k;fly=i;}\n\t\t\t\tif(R[i][k]=='R'){frx=k;fry=i;}\n\t\t\t}\n\t\t}\n\t\tmemset(done,false,sizeof(done));\n\t\tqueue<state> Q;\n\t\tQ.push(state(flx,fly,frx,fry));\n\t\twhile(!Q.empty()){\n\t\t\tstate t=Q.front(); Q.pop();\n\t\t\tif(L[t.ly][t.lx]=='%' && R[t.ry][t.rx]=='%'){cout<<\"Yes\"<<endl; break;}\n\t\t\tif(done[t.lx][t.ly][t.rx][t.ry]) continue;\n\t\t\tdone[t.lx][t.ly][t.rx][t.ry]=true;\n\n\t\t\tfor(int r=0;r<4;r++){\n\t\t\t\tint nlx=t.lx+dx[r],nly=t.ly-dy[r];\n\t\t\t\tif(!in(nlx,nly) || L[nly][nlx]=='#'){nlx=t.lx;nly=t.ly;}\n\n\t\t\t\tint nrx=t.rx+dx[(r+2)%4],nry=t.ry+dy[(r+2)%4];\n\t\t\t\tif(!in(nrx,nry) || R[nry][nrx]=='#'){nrx=t.rx;nry=t.ry;}\n\t\t\t\tQ.push(state(nlx,nly,nrx,nry));\n\t\t\t}\n\t\t}\n\t\tcout<<\"No\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\n\ntemplate<class T>\ninline bool chmax(T &a, const T &b) {\n    if(a<b) {\n        a=b;\n        return true;\n    }\n\n    return false;\n}\ntemplate<class T>\ninline bool chmin(T &a, const T &b) {\n    if(a>b) {\n        a=b;\n        return true;\n    }\n\n    return false;\n}\n\nint W,H;\nstring roomL[51],roomR[51];\n\nbool range_check(int y,int x) {\n    if(y<0||x<0) return false;\n    if(H<=y||W<=x) return false;\n\n    return true;\n}\n\nbool ok(P len,P rin) {\n    bool visited[51][51][51][51]={};\n    visited[len.fr][len.sc][rin.fr][rin.sc]=true;\n    queue<PP> que;\n    que.push(PP(len,rin));\n\n    while(que.size()) {\n        PP pp=que.front(); que.pop();\n        P next_len=pp.fr;\n        P next_rin=pp.sc;\n\n        //printf(\"[debug] %d %d %d %d\\n\",next_len.fr,next_len.sc,next_rin.fr,next_rin.sc);\n\n        rep(i,4) {\n            next_len=pp.fr;\n            next_rin=pp.sc;\n\n            if(range_check(next_len.fr+dy[i],next_len.sc+dx[i]) && roomL[next_len.fr+dy[i]][next_len.sc+dx[i]]!='#') {\n                next_len.fr+=dy[i];\n                next_len.sc+=dx[i];\n            }\n            if(range_check(next_rin.fr+dy[i],next_rin.sc-dx[i]) && roomR[next_rin.fr+dy[i]][next_rin.sc-dx[i]]!='#') {\n                next_rin.fr+=dy[i];\n                next_rin.sc-=dx[i];\n            }\n\n            chmax(next_len.fr,0);\n            chmin(next_len.fr,H-1);\n            chmax(next_len.sc,0);\n            chmin(next_len.sc,W-1);\n            chmax(next_rin.fr,0);\n            chmin(next_rin.fr,H-1);\n            chmax(next_rin.sc,0);\n            chmin(next_rin.sc,W-1);\n\n            if(roomL[next_len.fr][next_len.sc]=='%' && roomR[next_rin.fr][next_rin.sc]=='%') {\n                return true;\n            }\n            if(roomL[next_len.fr][next_len.sc]=='%' || roomR[next_rin.fr][next_rin.sc]=='%') {\n                continue;\n            }\n\n            if(!visited[next_len.fr][next_len.sc][next_rin.fr][next_len.sc]) {\n                visited[next_len.fr][next_len.sc][next_rin.fr][next_len.sc]=true;\n                que.push(PP(next_len,next_rin));\n            }\n        }\n    }\n\n    return false;\n}\n\nvoid solve() {\n    rep(y,H) cin>>roomL[y]>>roomR[y];\n    P len,rin;\n    rep(y,H) rep(x,W) {\n        if(roomL[y][x]=='L') len=P(y,x);\n        if(roomR[y][x]=='R') rin=P(y,x);\n    }\n    if(ok(len,rin)) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n}\n\nint main() {\n    while(cin>>W>>H) {\n        if(!W) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct P {\n\tint x, y;\n\tP(int x, int y) : x(x), y(y) {}\n};\n\nint dx[] = { 1, 0, -1, 0 };\nint dy[] = { 0, 1, 0, -1 };\n\nint mp[50][50][50][50];\n\nint main()\n{\n\tint W, H, lsx, lsy, rsx, rsy, lgx, lgy, rgx, rgy;\n\twhile (cin >> W >> H, W | H) {\n\t\tvector<string> Rl(H), Rr(H);\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tcin >> Rl[i] >> Rr[i];\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (Rl[i][j] == 'L') {\n\t\t\t\t\tlsx = i;\n\t\t\t\t\tlsy = j;\n\t\t\t\t}\n\t\t\t\telse if (Rl[i][j] == '%') {\n\t\t\t\t\tlgx = i;\n\t\t\t\t\tlgy = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (Rr[i][j] == 'R') {\n\t\t\t\t\trsx = i;\n\t\t\t\t\trsy = j;\n\t\t\t\t}\n\t\t\t\telse if (Rr[i][j] == '%') {\n\t\t\t\t\trgx = i;\n\t\t\t\t\trgy = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<pair<P, P>> q;\n\t\tq.push(pair<P, P>(P(lsx, lsy), P(rsx, rsy)));\n\t\tmp[lsx][lsy][rsx][rsy] = 1;\n\t\twhile (!q.empty()) {\n\t\t\tauto p = q.front(); q.pop();\n\t\t\tint lx = p.first.x, ly = p.first.y, rx = p.second.x, ry = p.second.y;\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint ltx = lx + dx[i], lty = ly - dy[i], rtx = rx + dx[i], rty = ry + dy[i];\n\t\t\t\tif (ltx >= 0 && ltx < H && lty >= 0 && lty < W && Rl[ltx][lty] != '#' && rtx >= 0 && rtx < H && rty >= 0 && rty < W && Rr[rtx][rty] != '#') {\n\t\t\t\t\tif ((Rl[ltx][lty] == '%') == (Rr[rtx][rty] == '%') && mp[ltx][lty][rtx][rty] == 0) {\n\t\t\t\t\t\tmp[ltx][lty][rtx][rty] = 1;\n\t\t\t\t\t\tq.push(pair<P, P>(P(ltx, lty), P(rtx, rty)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (ltx >= 0 && ltx < H && lty >= 0 && lty < W && Rl[ltx][lty] != '#') {\n\t\t\t\t\tif (Rl[ltx][lty] != '%' && mp[ltx][lty][rx][ry] == 0) {\n\t\t\t\t\t\tmp[ltx][lty][rx][ry] = 1;\n\t\t\t\t\t\tq.push(pair<P, P>(P(ltx, lty), P(rx, ry)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (rtx >= 0 && rtx < H && rty >= 0 && rty < W && Rr[rtx][rty] != '#') {\n\t\t\t\t\tif (Rr[rtx][rty] != '%' && mp[lx][ly][rtx][rty] == 0) {\n\t\t\t\t\t\tmp[lx][ly][rtx][rty] = 1;\n\t\t\t\t\t\tq.push(pair<P, P>(P(lx, ly), P(rtx, rty)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (mp[lgx][lgy][rgx][rgy] ? \"Yes\" : \"No\") << endl;\n\t\tfor (int i = 0; i < 50; i++) {\n\t\t\tfor (int j = 0; j < 50; j++) {\n\t\t\t\tfor (int k = 0; k < 50; k++) {\n\t\t\t\t\tfor (int l = 0; l < 50; l++) {\n\t\t\t\t\t\tmp[i][j][k][l] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<cstdio>\nusing namespace std;\n\nstruct Data{int x[2],y[2];};\nData start,goal;\n\nint W,H;\nvector< vector<string> >room(2);\n\nint dx[2][4]={{0,1,0,-1}, {0,-1,0,1}};\nint dy[2][4]={{-1,0,1,0}, {-1,0,1,0}};\n\nbool operator<(Data a, Data b){\n  return a.x[0]!=b.x[0]?a.x[0]<b.x[0]:(a.y[0]!=b.y[0]?a.y[0]<b.y[0]:(\n           a.x[1]!=b.x[1]?a.x[1]<b.x[1]:a.y[1]<b.y[1]\n         ));\n}\nbool operator==(Data a, Data b){\n  return a.x[0]==b.x[0] && a.x[1]==b.x[1] && a.y[0]==b.y[0] && a.y[1]==b.y[1];\n}\nbool over(Data a){\n  return a.x[0]<0 || W<=a.x[0] || a.y[0]<0 || H<=a.y[0] ||\n         a.x[1]<0 || W<=a.x[1] || a.y[1]<0 || H<=a.y[1];\n}\n\nbool bfs()\n{\n  queue<Data>q;\n  q.push(start);\n  map<Data,bool>visited;\n\n  while(!q.empty()){\n    Data now=q.front();\n    q.pop();\n\n    visited[now]=true;\n\n    if(now==goal)return true;\n    if(now.x[0]==goal.x[0] && now.y[0]==goal.y[0])continue;\n    if(now.x[1]==goal.x[1] && now.y[1]==goal.y[1])continue;\n\n    for(int i=0;i<4;i++){\n      Data next=now;\n      for(int j=0;j<2;j++){\n\tnext.x[j]+=dx[j][i];\n\tnext.y[j]+=dy[j][i];\n\tif(over(next)){\n\t  next.x[j]=now.x[j];\n\t  next.y[j]=now.y[j];\n\t}\n\tif(room[j][next.y[j]][next.x[j]]=='#'){\n\t  next.x[j]=now.x[j];\n\t  next.y[j]=now.y[j];\n\t}\n      }\n      if(visited.count(next))continue;\n      q.push(next);\n    }\n  }\n\n  return false;\n}\n\nint main()\n{\n  while(cin>>W>>H,W|H){\n    room[0].resize(H);\n    room[1].resize(H);\n    for(int i=0;i<H;i++){\n      cin>>room[0][i]>>room[1][i];\n      for(int j=0;j<W;j++){\n\tif(room[0][i][j]=='L'){\n\t  start.x[0]=j;\n\t  start.y[0]=i;\n\t}\n\tif(room[1][i][j]=='R'){\n\t  start.x[1]=j;\n\t  start.y[1]=i;\n\t}\n\tif(room[0][i][j]=='%'){\n\t  goal.x[0]=j;\n\t  goal.y[0]=i;\n\t}\n\tif(room[1][i][j]=='%'){\n\t  goal.x[1]=j;\n\t  goal.y[1]=i;\n\t}\n      }\n    }\n\n    puts(bfs()?\"Yes\":\"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<ctime>\n#include<climits>\n#include<queue>\n#include<fstream>\n#include<deque>\n#include<iomanip>\n#include<list>\n#include<stack>\n#include<sstream>\n#include<string>\n#include<cctype>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<cstring>\n#include<iomanip>\n#include<map>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS 1e-10\n#define F first\n#define S second\n#define all(n) n.begin(),n.end()\n#define pb push_back\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define INF (1<<27)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nconst P dx[4] = {P(0,0),P(0,0),P(1,-1),P(-1,1)};\nconst P dy[4] = {P(1,1),P(-1,-1),P(0,0),P(0,0)};\n\n\nint H,W;\nchar L_cmap[55][55],R_cmap[55][55];\nbool L_used[55][55],R_used[55][55];\nP Ls,Rs,Lg,Rg;\nbool fin;\n\nvoid dfs(PP pp){\n  if(fin)return;\n      if(pp.F == Lg && pp.S == Rg){\n\tcout << \"Yes\" << endl;\n\tfin = true;\n\treturn;\n      }\n      //cout << \"pp.F = \" << pp.F.F << \",\" << pp.F.S << \" pp.S = \" << pp.S.F << \",\" << pp.S.S << endl;\n      rep(i,4){\n\tint L_nx = pp.F.F + dx[i].F,L_ny = pp.F.S + dy[i].F;\n\tint R_nx = pp.S.F + dx[i].S ,R_ny = pp.S.S + dy[i].S;\n\t//cout << \"First next L = \" << L_nx << \",\" << L_ny << \" Pre next R = \" << R_nx << \",\" << R_ny << endl;\n\n\n \tif(!(0<=L_nx && L_nx <W && 0<= R_nx && R_nx <W && 0<= L_ny && L_ny <H && 0<= R_ny && R_ny < H))continue;\n\tif(L_cmap[L_ny][L_nx] != '#' && L_used[L_ny][L_nx])continue;\n\tif(R_cmap[R_ny][R_nx] != '#' && R_used[R_ny][R_nx])continue;\n\tif(L_cmap[L_ny][L_nx] == '#' && R_cmap[R_ny][R_nx] == '#')continue;\n\n\t//cout << \"next L = \" << L_nx << \",\" << L_ny << \" Pre next R = \" << R_nx << \",\" << R_ny << endl;\n\tif(L_cmap[L_ny][L_nx] == '#')L_nx = pp.F.F,L_ny = pp.F.S;\n\tif(R_cmap[R_ny][R_nx] == '#')R_nx = pp.S.F,R_ny = pp.S.S;\n\t\n\tR_used[R_ny][R_nx] = L_used[L_ny][L_nx] = true;\n\t//que.push(insert(L_nx,L_ny,R_nx,R_ny));\n\tif(fin)return;\n\tdfs(insert(L_nx,L_ny,R_nx,R_ny));\n\tif(fin)return;\n\tR_used[R_ny][R_nx] = L_used[L_ny][L_nx] = false;\n      }\n      return;\n}\n   \n\n\nint main(){\n  //clock_t start,end;\n  //start = clock();\n  while(cin >> W >> H && H+W){\n    fin = false;\n    rep(i,H){\n      string s;\n      cin >> s;\n      rep(j,W){\n\tL_cmap[i][j] = s[j],L_used[i][j] = false;\n\tif(s[j] == 'L')\n\t  Ls = P(j,i);\n\tif(s[j] == '%')\n\t  Lg = P(j,i);\n      }\n      cin >> s;\n      rep(j,W){\n\tR_cmap[i][j] = s[j],R_used[i][j] = false;\n\tif(s[j] == 'R')\n\t  Rs = P(j,i);\n\tif(s[j] == '%')\n\t  Rg = P(j,i);\n      }\n    }\n    //cout<< \"Ls = \" << Ls.F << \" \" << Ls.S << \", Lg = \" << Lg.F << \" \" << Lg.S << \", Rs = \" << Rs.F << \" \" << Rs.S << \", Rg = \" << Rg.F << \" \" << Rg.S << endl; \n    //rep(i,4){\n    //rep(j,51)rep(k,51)R_used[j][k] = L_used[j][k] = false;\n      //if(!(0<= Ls.F+dx[i].F && Ls.F+dx[i].F < W && 0<= Ls.S+dy[i].F && Ls.S+dy[i].F < H  && 0<= Rs.F+dx[i].S && Rs.F+dx[i].S < W  && 0<= Rs.S+dy[i].S && Rs.S+dy[i].S < H))continue;\n      //cout << Ls.F+dx[i].F << \" \" << Ls.S+dy[i].F<< \" \"<< Rs.F+dx[i].S<< \" \" << Rs.S+dy[i].S << endl;\n      //dfs(insert(Ls.F+dx[i].F,Ls.S+dy[i].F,Rs.F+dx[i].S,Rs.S+dy[i].S));\n      //cout << \"----------\" << endl;\n      //}    \n    L_used[Ls.S][Ls.F] = true,R_used[Rs.S][Rs.F] = true;\n    dfs(insert(Ls.F,Ls.S,Rs.F,Rs.S));\n\n    if(!fin)cout << \"No\" << endl;\n\n  }\n  //end = clock();\n  //cout << setiosflags(ios::fixed) << setprecision(10) << (double)(end-start)/CLOCKS_PER_SEC << endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstring>\n#include<queue>\n#include<tuple>\n#include<stack>\n#include<cstdio>\n#include<iomanip>\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<string> vs;\nDef inf = sizeof(Def) == sizeof(ll) ?2e18:1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint d[52][52][52][52];\ntypedef tuple<int,int,int,int>tp;\nvs a,b;\nint n,m;\nint f(int x1,int y1,int x2,int y2){\n  //    cout<<x1<<\" \"<<y1<<\" \"<<x2<<\" \"<<y2<<endl;\n\n  priority_queue<tp>q;\n  q.push(tp{x1,y1,x2,y2});\n  while(!q.empty()){ \n    int x1,y1,x2,y2;\n    tie(x1,y1,x2,y2)=q.top();\n    q.pop();\n    rep(i,4){\n  \n      int nx1=x1+dx[i];\n      int ny1=y1+dy[i];\n      int nx2=x2+dx[i];\n      int ny2=y2+dy[(2+i)%4];\n      if(nx1<0||ny1<0||nx1>=n||ny1>=m){\n\tnx1-=dx[i];\n\tny1-=dy[(i)%4];\n      }\n      if(nx2<0||ny2<0||nx2>=n||ny2>=m){\n\tnx2-=dx[i];\n\tny2-=dy[(i+2)%4];\n      }\n      if(a[nx1][ny1]=='#'){\n\tnx1-=dx[i];\n\tny1-=dy[i];\n      }\n      if(b[nx2][ny2]=='#'){\n\tnx2-=dx[i];\n\tny2-=dy[(i+2)%4];\n      }\n      bool A=a[nx1][ny1]=='%';\n      bool B=b[nx2][ny2]=='%';\n      if(A!=B)continue;\n      if(d[nx1][ny1][nx2][ny2])continue;\n      // cout<<nx1<<\" \"<<ny1<<\" \"<<nx2<<\" \"<<ny2<<endl;\n      d[nx1][ny1][nx2][ny2]=1;\n      q.push(tp{nx1,ny1,nx2,ny2});//f(nx1,ny1,nx2,ny2);\n    }\n  }\n}\nint main(){\n  while(cin>>m>>n,n){\n    rep(i,52)rep(j,52)rep(k,52)rep(l,52)\n      d[i][j][k][l]=0;\n    a=b=vs(n);\n    rep(i,n)cin>>a[i]>>b[i];\n    rep(i,n)rep(j,m)rep(k,n)rep(l,m)if(a[i][j]=='L'&&b[k][l]=='R'){\n      d[i][j][k][l]=1;\n      f(i,j,k,l);\n    }\n    rep(i,n)rep(j,m)rep(k,n)rep(l,m)if(a[i][j]=='%'&&b[k][l]=='%'){\n      if(d[i][j][k][l])cout<<\"Yes\"<<endl;\n      else cout<<\"No\"<<endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\nint main(void){\n\tint dl[50][50][50][50], h, w, i, j, k, a, b, c, d, dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\n\tchar rf[50][51], lf[50][51];\n\tpair<int,int> rs, ls, rg, lg;\n\tqueue<pair<int,int> > r, l;\n\twhile(1){\n\t\tscanf(\"%d%d%*c\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tlf[i][j] = getchar();\n\t\t\t\tif(lf[i][j] == 'L'){\n\t\t\t\t\tls = pair<int,int>(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(lf[i][j] == '%'){\n\t\t\t\t\tlg = pair<int,int>(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 空白読み飛ばし\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\trf[i][j] = getchar();\n\t\t\t\tif(rf[i][j] == 'R'){\n\t\t\t\t\trs = pair<int,int>(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(rf[i][j] == '%'){\n\t\t\t\t\trg = pair<int,int>(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 改行文字読み飛ばし\n\t\t}\n\t\tr.push(rs), l.push(ls);\n\t\tmemset(dl,0,sizeof(dl));\n\t\twhile(r.size()){\n\t\t\ta = l.front().first, b = l.front().second, c = r.front().first, d = r.front().second;\n\t\t\tl.pop(), r.pop();\n\t\t\tdl[a][b][c][d] = 1;\n\t\t\tfor(i = 0;i < 4;i++){\n\t\t\t\tif(a + dy[i] >= 0 && a + dy[i] < h && b + dx[i] >= 0 && b + dx[i] < w && lf[a + dy[i]][b + dx[i]] == '.' && c + dy[i] >= 0 && c + dy[i] < h && d - dx[i] >= 0 && d - dx[i] < w && rf[c + dy[i]][d - dx[i]] == '.' && !dl[a + dy[i]][b + dx[i]][c + dy[i]][d - dx[i]]) // 両方とも動くとき\n\t\t\t\t\tl.push(pair<int,int>(a + dy[i],b + dx[i])), r.push(pair<int,int>(c + dy[i],d - dx[i]));\n\t\t\t\telse if((a + dy[i] < 0 || a + dy[i] >= h || b + dx[i] < 0 || b + dx[i] >= w || lf[a + dy[i]][b + dx[i]] == '#') && c + dy[i] >= 0 && c + dy[i] < h && d - dx[i] >= 0 && d - dx[i] < w && rf[c + dy[i]][d - dx[i]] == '.' && !dl[a][b][c + dy[i]][d - dx[i]]) // Rinだけ動く\n\t\t\t\t\tl.push(pair<int,int>(a,b)), r.push(pair<int,int>(c + dy[i],d - dx[i]));\n\t\t\t\telse if(a + dy[i] >= 0 && a + dy[i] < h && b + dx[i] >= 0 && b + dx[i] < w && lf[a + dy[i]][b + dx[i]] == '.' && (c + dy[i] < 0 || c + dy[i] >= h || d - dx[i] < 0 || d - dx[i] >= w || rf[c + dy[i]][d - dx[i]] == '#') && !dl[a + dy[i]][b + dx[i]][c][d]) // Lenだけ動く\n\t\t\t\t\tl.push(pair<int,int>(a + dy[i],b + dx[i])), r.push(pair<int,int>(c,d));\n\t\t\t}\n\t\t}\n\t\tif(dl[lg.first][lg.second][rg.first][rg.second])\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing Coor = pair<int, int>;\nusing Pair = pair<Coor, Coor>;\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {-1, 0, 1, 0};\n\nint H;\nint W;\nint sty[2];\nint stx[2];\nint y[2];\nint x[2];\nchar field[2][50][50];\nbool dp[50][50][50][50];\n\nbool WithinRange(int y, int x) {\n  if (y < 0 || H <= y) return false;\n  if (x < 0 || W <= x) return false;\n  return true;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &W, &H);\n    if (W == 0 && H == 0) return 0;\n\n    for (int i=0; i<H; i++) {\n      for (int j=0; j<W; j++) {\n        scanf(\" %c\", &field[0][i][j]);\n        if (field[0][i][j] == '%') {\n          sty[0] = i;\n          stx[0] = j;\n        } else if (field[0][i][j] == 'L') {\n          y[0] = i;\n          x[0] = j;\n        } else assert(field[0][i][j] == '.' || field[0][i][j] == '#');\n      }\n\n      for (int j=W-1; j>=0; j--) {\n        scanf(\" %c\", &field[1][i][j]);\n        if (field[1][i][j] == '%') {\n          sty[1] = i;\n          stx[1] = j;\n        } else if (field[1][i][j] == 'R') {\n          y[1] = i;\n          x[1] = j;\n        } else assert(field[1][i][j] == '.' || field[1][i][j] == '#');\n      }\n    }\n\n    for (int i=0; i<H; i++) {\n      for (int j=0; j<W; j++) {\n        for (int k=0; k<H; k++) {\n          for (int l=0; l<W; l++) {\n            dp[i][j][k][l] = false;\n          }\n        }\n      }\n    }\n\n    dp[y[0]][x[0]][y[1]][x[1]] = true;\n    queue<Pair> q;\n    q.push(Pair(Coor(y[0], x[0]), Coor(y[1], x[1])));\n    while (!q.empty()) {\n      Pair p = q.front(); q.pop();\n      Coor c1 = p.first;\n      int y1 = c1.first;\n      int x1 = c1.second;\n      Coor c2 = p.second;\n      int y2 = c2.first;\n      int x2 = c2.second;\n\n      for (int i=0; i<4; i++) {\n        int newy1 = y1 + dy[i];\n        int newx1 = x1 + dx[i];\n        if (!WithinRange(newy1, newx1) || field[0][newy1][newx1] == '#') {\n          newy1 -= dy[i];\n          newx1 -= dx[i];\n        }\n\n        int newy2 = y2 + dy[i];\n        int newx2 = x2 + dx[i];\n        if (!WithinRange(newy2, newx2) || field[1][newy2][newx2] == '#') {\n          newy2 -= dy[i];\n          newx2 -= dx[i];\n        }\n\n        if (dp[newy1][newx1][newy2][newx2]) continue;\n        dp[newy1][newx1][newy2][newx2] = true;\n        q.push(Pair(Coor(newy1, newx1), Coor(newy2, newx2)));\n      }\n    }\n\n    if (dp[sty[0]][stx[0]][sty[1]][stx[1]]) puts(\"Yes\");\n    else puts(\"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define WRAP(x,y,w,h) (0<=x && x<w && 0<=y && y<h)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h, w) {\n\t\tvector<string> cell1(h);\n\t\tvector<string> cell2(h);\n\t\tint slx, sly, srx, sry;\n\t\tint glx, gly, grx, gry;\n\t\tREP(i, h) {\n\t\t\tcin >> cell1[i] >> cell2[i];\n\t\t\tREP(j, w / 2)\n\t\t\t\tswap(cell2[i][j], cell2[i][w - 1 - j]);\n\t\t\tREP(j, w) {\n\t\t\t\tif (cell1[i][j] == 'L') {\n\t\t\t\t\tsly = i;\n\t\t\t\t\tslx = j;\n\t\t\t\t}\n\t\t\t\tif (cell1[i][j] == '%') {\n\t\t\t\t\tgly = i;\n\t\t\t\t\tglx = j;\n\t\t\t\t}\n\t\t\t\tif (cell2[i][j] == 'R') {\n\t\t\t\t\tsry = i;\n\t\t\t\t\tsrx = j;\n\t\t\t\t}\n\t\t\t\tif (cell2[i][j] == '%') {\n\t\t\t\t\tgry = i;\n\t\t\t\t\tgrx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool G[50][50][50][50] = { false };\n\t\tG[sly][slx][sry][srx] = true;\n\t\t//set<pair<pair<char,char>, pair<char, char>>> G;\n\t\t//G.insert({ {sly,slx},{sry,srx} });\n\t\tqueue<pair<pair<char, char>, pair<char, char>>> Q;\n\t\tQ.push({ { sly,slx },{ sry,srx } });\n\t\t//bool G2[50][50][50][50] = { false };\n\t\t//G2[gly][glx][gry][grx] = true;\n\t\t//set<pair<pair<char, char>, pair<char, char>>> G2;\n\t\t//G2.insert({ { gly,glx },{ gry,grx } });\n\t\t//queue<pair<pair<char, char>, pair<char, char>>> Q2;\n\t\t//Q2.push({ { gly,glx },{ sry,grx } });\n\t\tstring clear = \"No\";\n\t\twhile (!Q.empty()) {\n\t\t\tpair<pair<char, char>, pair<char, char>> q;\n\t\t\tq = Q.front();Q.pop();\n\n\t\t\tif (G[q.first.first][q.first.second][q.second.first][q.second.second]) {\n\t\t\t\tclear = \"Yes\";\n\t\t\t\tgoto ANS;\n\t\t\t}\n\t\t\tREP(i, 4) {\n\t\t\t\tint nly = q.first.first + dy[i];\n\t\t\t\tint nlx = q.first.second + dx[i];\n\t\t\t\tint nry = q.second.first + dy[i];\n\t\t\t\tint nrx = q.second.second + dx[i];\n\t\t\t\tif (!WRAP(nlx, nly, w, h) || cell1[nly][nlx] == '#') {\n\t\t\t\t\tnly = q.first.first;\n\t\t\t\t\tnlx = q.first.second;\n\t\t\t\t}\n\t\t\t\tif (!WRAP(nrx, nry, w, h) || cell2[nry][nrx] == '#') {\n\t\t\t\t\tnry = q.second.first;\n\t\t\t\t\tnrx = q.second.second;\n\t\t\t\t}\n\t\t\t\tbool b1 = (nly == gly&&nlx == glx);\n\t\t\t\tbool b2 = (nry == gry&&nrx == grx);\n\t\t\t\tif (b1 != b2)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!G[nly][nlx][nry][nrx]) {\n\t\t\t\t\tG[nly][nlx][nry][nrx] = true;\n\t\t\t\t\tQ.push({ { nly,nlx },{ nry,nrx } });\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\tANS:\n\t\tcout << clear << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//????????????????????????\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> ver;\ntypedef pair<int, ver> piv;\nint dx[2][4] = {{1, 0, -1, 0},\n                {-1, 0, 1, 0}};\nint dy[] = {0, 1, 0, -1};\nint dp[51][51][51][51];\n\nbool range(pii p, int w, int h){\n  if(0 <= p.first  && p.first  < w &&\n     0 <= p.second && p.second < h)return true;\n  return false;\n}\nint main(int argc, char *argv[]){\n  int w, h;\n  while(cin >> w >> h, w){\n    vector<string> grid1(h), grid2(h);\n    pii s[2], g[2];\n    for (int i = 0; i < h; i++) {\n      cin >> grid1[i] >> grid2[i];\n      for (int j = 0; j < w; j++) {\n        if(grid1[i][j] == 'L')s[0].first = j, s[0].second = i;\n        if(grid1[i][j] == '%')g[0].first = j, g[0].second = i;\n        if(grid2[i][j] == 'R')s[1].first = j, s[1].second = i;\n        if(grid2[i][j] == '%')g[1].first = j, g[1].second = i;\n      }\n    }\n    for (int i = 0; i < h; i++) \n      for (int j = 0; j < w; j++) \n        for (int k = 0; k < h; k++) \n          for (int l = 0; l < w; l++) \n            dp[i][j][k][l] = 1e9;\n    \n    dp[s[0].second][s[0].first][s[1].second][s[1].first] = 0;\n    queue<piv> que;\n    que.push(piv(0, ver(s[0], s[1])));\n    while(!que.empty()){\n      pii u = que.front().second.first;\n      pii v = que.front().second.second;\n      int c = que.front().first;\n      que.pop();\n      if(u == g[0] && v == g[1])break;\n      for (int i = 0; i < 4; i++) {\n        pii a = u, b = v;\n        a.first  += dx[0][i];\n        a.second += dy[i];\n        b.first  += dx[1][i];\n        b.second += dy[i];\n        if(!range(a, w, h) || grid1[a.second][a.first] == '#')\n          a = u;\n        if(!range(b, w, h) || grid2[b.second][b.first] == '#')\n          b = v;\n        if(a != g[0] || b != g[1]){\n          if(a == g[0] || b == g[1])continue;\n        }\n        if(dp[a.second][a.first][b.second][b.first] > c + 1){\n          dp[a.second][a.first][b.second][b.first] = c + 1;\n          que.push(piv(c + 1, ver(a, b)));\n        }\n      }\n    }\n\n    if(dp[g[0].second][g[0].first][g[1].second][g[1].first]\n       != 1e9)\n      std::cout << \"Yes\" << std::endl;\n    else\n      std::cout << \"No\" << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\nusing namespace std;\nstruct po{int lx,ly,rx,ry;};\nint w,h;\nstring mp[2][51];\nbool ans,memo[51][51][51][51],visited[51][51][51][51];\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\n\nvoid saiki(int lx,int ly,int rx,int ry){\n\n  if(ans)return;\n  if(mp[0][ly][lx]=='%'&&mp[1][ry][rx]=='%')ans=1;\n  if(memo[lx][ly][rx][ry]||mp[0][ly][lx]=='%'||mp[1][ry][rx]=='%')return;\n  memo[lx][ly][rx][ry]=1;\n  for(int i=0;i<4;i++){\n    int flg=0;\n    int nlx=lx+dx[i],nly=ly+dy[i];\n    int nrx=rx-dx[i],nry=ry+dy[i];\n    if(nlx<0||nly<0||nlx>=w||nly>=h||mp[0][nly][nlx]=='#')nlx=lx,nly=ly,flg++;\n    if(nrx<0||nry<0||nrx>=w||nry>=h||mp[1][nry][nrx]=='#')nrx=rx,nry=ry,flg++;\n    if(flg==2)continue;\n    saiki(nlx,nly,nrx,nry);\n  }\n}\n\nbool bfs(int a,int b,int c,int d){\n  queue <po> Q;\n  Q.push((po){a,b,c,d});\n  while(!Q.empty()){\n    po t=Q.front();Q.pop();\n    //cout << t.lx<<\" \"<<t.ly<<\" \"<<t.rx<<\" \"<<t.ry<<endl;\n    if(mp[0][t.ly][t.lx]=='%'&&mp[1][t.ry][t.rx]=='%')return true;\n    if(visited[t.lx][t.ly][t.rx][t.ry]||mp[0][t.ly][t.lx]=='%'||mp[1][t.ry][t.rx]=='%')continue;\n    visited[t.lx][t.ly][t.rx][t.ry]=1;\n    for(int i=0;i<4;i++){\n      int flg=0;\n      int nlx=t.lx+dx[i],nly=t.ly+dy[i];\n      int nrx=t.rx-dx[i],nry=t.ry+dy[i];\n      if(nlx<0||nly<0||nlx>=w||nly>=h||mp[0][nly][nlx]=='#')nlx=t.lx,nly=t.ly,flg++;\n      if(nrx<0||nry<0||nrx>=w||nry>=h||mp[1][nry][nrx]=='#')nrx=t.rx,nry=t.ry,flg++;\n      if(flg==2||visited[nlx][nly][nrx][nry])continue;\n      Q.push((po){nlx,nly,nrx,nry});\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(1){\n    cin >>w>>h;\n    if(!w&&!h)break;\n    for(int i=0;i<h;i++)cin>>mp[0][i]>>mp[1][i];\n    int lx,ly,rx,ry;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(mp[0][i][j]=='L')lx=j,ly=i;\n\tif(mp[1][i][j]=='R')rx=j,ry=i;\n      }\n    memset(memo,0,sizeof(memo));\n    memset(visited,0,sizeof(visited));\n    ans=0;\n    // saiki(lx,ly,rx,ry);\n    if(bfs(lx,ly,rx,ry))cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <memory.h>\n#include <queue>\n\nusing namespace std;\n\nint maxw,maxh;\nint lsx,lsy;\nint rsx,rsy;\n\nconst int dxl[] = {1,0,-1,0};\nconst int dxr[] = {-1,0,1,0};\nconst int dyl[] = {0,1,0,-1};\nconst int dyr[] = {0,1,0,-1};\n\ntypedef pair<int,int> PP;\ntypedef pair< PP,PP > P;\n\nbool visited[55][55][55][55] = {};\n\nint main(void)\n{\n\twhile(1)\n\t{\n\t\tchar fieldl[55][55];\n\t\tchar fieldr[55][55];\n\t\tmemset(visited,0,sizeof(visited));\n\t\tmemset(fieldl,0,sizeof(fieldl));\n\t\tmemset(fieldr,0,sizeof(fieldr));\n\t\tcin >> maxw >> maxh;\n\t\tif(maxw==0&&maxh==0)\n\t\t\treturn 0;\n\t\tfor(int y=1;y<=maxh;++y){\n\t\t\tfor(int x=1;x<=maxw;++x){\n\t\t\t\tcin >> fieldl[y][x];\n\t\t\t\tif(fieldl[y][x] == 'L'){\n\t\t\t\t\tlsy = y;lsx = x;\n\t\t\t\t\tfieldl[y][x] = '.';\n\t\t\t\t}\n\t\t\t\tif(fieldl[y][x] == 'R'){\n\t\t\t\t\trsy = y;rsx = x;\n\t\t\t\t\tfieldl[y][x] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int x=1;x<=maxw;++x){\n\t\t\t\tcin >> fieldr[y][x];\n\t\t\t\tif(fieldr[y][x] == 'L'){\n\t\t\t\t\tlsy = y;lsx = x;\n\t\t\t\t\tfieldr[y][x] = '.';\n\t\t\t\t}\n\t\t\t\tif(fieldr[y][x] == 'R'){\n\t\t\t\t\trsy = y;rsx = x;\n\t\t\t\t\tfieldr[y][x] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqueue<P> q;\n\t\tbool isGoal = false;\n\t\tq.push(P(PP(lsy,lsx),PP(rsy,rsx)));\n\t\tvisited[lsy][lsx][rsy][rsx] = true;\n\t\twhile(!q.empty()){\n\t\t\tP p = q.front();q.pop();\n\t\t\tfor(int i=0;i<4;++i){\n\t\t\t\tbool f=false;\n\t\t\t\tPP tol = PP(p.first.first+dyl[i],p.first.second+dxl[i]);//y,x\n\t\t\t\tPP tor = PP(p.second.first+dyr[i],p.second.second+dxr[i]);//y,x\n\t\t\t\tif(visited[tol.first][tol.second][tor.first][tor.second])\n\t\t\t\t\tcontinue;\n\t\t\t\tif(fieldl[tol.first][tol.second] == '%' && fieldr[tor.first][tor.second] == '%'){\n\t\t\t\t\tisGoal = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(fieldl[tol.first][tol.second] == '%' || fieldr[tor.first][tor.second] == '%')\n\t\t\t\t\tcontinue;\n\t\t\t\tPP l = PP(p.first.first,p.first.second);\n\t\t\t\tPP r = PP(p.second.first,p.second.second);\n\t\t\t\tif(fieldl[tol.first][tol.second] == '.'){\n\t\t\t\t\tl = tol;\n\t\t\t\t\tf=true;\n\t\t\t\t}\n\t\t\t\tif(fieldr[tor.first][tor.second] == '.'){\n\t\t\t\t\tr = tor;\n\t\t\t\t\tf=true;\n\t\t\t\t}\n\t\t\t\tif(!f)\n\t\t\t\t\tcontinue;\n\t\t\t\tvisited[l.first][l.second][r.first][r.second] = true;\n\t\t\t\tq.push(P(l,r));\n\t\t\t}\n\t\t\tif(isGoal)\n\t\t\t\tbreak;\n\t\t}\n\t\t(isGoal?cout<<\"Yes\"<<endl:cout<<\"No\"<<endl);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) for(auto x : v){cout << x << \" \";} cout << endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(vv) for(auto v : vv){for(auto&& x : v){cout << x << \" \";}cout << endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\ntypedef vector<vector<int>> Graph;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nconst int MAX_H = 52;\nconst int MAX_W = 52;\nbool dp[MAX_H][MAX_W][MAX_H][MAX_W];\nvector<vector<string>> s;\nint H, W;\nvector<int> sx(2), sy(2), gx(2), gy(2);\n\n// N, E, S, W\n// kagamiawase\nconst int dx[2][4] = {\n    {-1,  0,  1,  0},\n    {-1,  0,  1,  0}\n};\nconst int dy[2][4] = {\n    { 0,  1,  0, -1},\n    { 0, -1,  0,  1}\n};\n\nvoid dfs(int x0, int y0, int x1, int y1) {\n    // cout << x0 << \" \" << y0 << \" \" << x1 << \" \" << y1 << endl;\n    // if (x0 == gx[0] && y0 == gy[0] && x1 == gx[1] && y1 == gy[1]) return true;\n    if (dp[x0][y0][x1][y1]) return;\n\n    dp[x0][y0][x1][y1] = true;\n\n    // bool ret = false;\n    rep(k, 4) {\n        int nx0 = x0 + dx[0][k];\n        int ny0 = y0 + dy[0][k];\n        int nx1 = x1 + dx[1][k];\n        int ny1 = y1 + dy[1][k];\n\n        if (s[0][nx0][ny0] == '.' && s[1][nx1][ny1] == '.') {\n            dfs(nx0, ny0, nx1, ny1);\n        } else if (s[0][nx0][ny0] == '.') {\n            dfs(nx0, ny0, x1, y1);\n        } else if (s[1][nx1][ny1] == '.') {\n            dfs(x0, y0, nx1, ny1);\n        }\n    }\n    // return dp[x0][y0][x1][y1] = ret;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    while (cin >> W >> H, W) {\n        H += 2;\n        W += 2;\n\n        s.clear(); s.resize(2, vector<string>(H, string(W, '#')));\n        rep2(i, 1, H - 1) {\n            rep(b, 2) {\n                cin >> s[b][i];\n                s[b][i] = \"#\" + s[b][i] + \"#\";\n            }\n        }\n\n        rep(b, 2) {\n            rep(i, H) {\n                rep(j, W) {\n                    if (s[b][i][j] == (b ? 'R' : 'L')) {\n                        sx[b] = i, sy[b] = j;\n                        s[b][i][j] = '.';\n                    }\n                    if (s[b][i][j] == '%') {\n                        gx[b] = i, gy[b] = j;\n                        s[b][i][j] = '.';\n                    }\n                }\n            }\n        }\n\n        // rep(b, 2) {\n        //     printVS(s[b]);\n        //     cout << endl;\n        // }\n\n        rep(x0, H) rep(y0, W) rep(x1, H) rep(y1, W) dp[x0][y0][x1][y1] = false;\n\n        // cout << (dfs(sx[0], sy[0], sx[1], sy[1]) ? \"Yes\" : \"No\") << endl;\n        dfs(sx[0], sy[0], sx[1], sy[1]);\n        cout << (dp[gx[0]][gy[0]][gx[1]][gy[1]] ? \"Yes\" : \"No\") << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint mx[4]={0,1,0,-1};\nint my[4]={1,0,-1,0};\n\nbool memo[50][50][50][50];\n\nint w,h;\n\nbool dfs(pair<int,int>nowL, pair<int,int>nowR, vector<string> &sl,vector<string> &sr){\n    //cout<<nowL.first<<nowL.second<<nowR.first<<nowR.second<<endl;\n    if(memo[nowL.first][nowL.second][nowR.first][nowR.second]){\n        return 0;\n    }else{\n        memo[nowL.first][nowL.second][nowR.first][nowR.second]=1;\n    }\n    if(sl[nowL.first][nowL.second]=='%' && sr[nowR.first][nowR.second]=='%'){\n        return 1;\n    }\n    if(sl[nowL.first][nowL.second]=='%'){\n        return 0;\n    }\n    if(sr[nowR.first][nowR.second]=='%'){\n        return 0;\n    }\n    for(int i=0;i<4;++i){\n        pair<int,int>nextL,nextR;\n        nextL.first=nowL.first+my[i];\n        nextL.second=nowL.second+mx[i];\n        nextR.first=nowR.first+my[i];\n        nextR.second=nowR.second-mx[i];\n        //------------------------------------\n        if(nextL.first<0 || nextL.first>=h){\n            nextL=nowL;\n        }\n        if(nextL.second<0 || nextL.second>=w){\n            nextL=nowL;\n        }\n        if(sl[nextL.first][nextL.second]=='#'){\n            nextL=nowL;\n        }\n        //-------------------------------------\n        if(nextR.first<0 || nextR.first>=h){\n            nextR=nowR;\n        }\n        if(nextR.second<0 || nextR.second>=w){\n            nextR=nowR;\n        }\n        if(sr[nextR.first][nextR.second]=='#'){\n            nextR=nowR;\n        }\n        if(dfs(nextL,nextR,sl,sr))return 1;\n    }\n    return 0;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    while(cin>>w>>h,w){\n        for(int i=0;i<50;++i){\n            for(int j=0;j<50;++j){\n                for(int k=0;k<50;++k){\n                    for(int l=0;l<50;++l){\n                        memo[i][j][k][l]=0;\n                    }\n                }\n            }\n        }\n        vector<string> sl(h),sr(h);\n        pair<int,int>startL,startR;\n        for(int i=0;i<h;++i){\n            cin>>sl[i]>>sr[i];\n            for(int j=0;j<w;++j){\n                if(sl[i][j]=='L'){\n                    startL={i,j};\n                }\n                if(sr[i][j]=='R'){\n                    startR={i,j};\n                }\n            }\n        }\n        if(dfs(startL,startR,sl,sr))cout<<\"Yes\"<<endl;\n        else cout<<\"No\"<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <set>\n#include <queue>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\tint h, w, i, j, a, b, c, d, dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\n\tchar rf[50][51], lf[50][51];\n\tset<pair<P,P> > s; \n\tP rs, ls, rg, lg;\n\tqueue<P> r, l;\n\twhile(1){\n\t\tscanf(\"%d%d%*c\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tlf[i][j] = getchar();\n\t\t\t\tif(lf[i][j] == 'L'){\n\t\t\t\t\tls = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(lf[i][j] == '%'){\n\t\t\t\t\tlg = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 空白読み飛ばし\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\trf[i][j] = getchar();\n\t\t\t\tif(rf[i][j] == 'R'){\n\t\t\t\t\trs = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(rf[i][j] == '%'){\n\t\t\t\t\trg = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 改行文字読み飛ばし\n\t\t}\n\t\tr.push(rs), l.push(ls);\n\t\ts.insert(pair<P,P>(ls,rs));\n\t\twhile(r.size()){\n\t\t\ta = l.front().first, b = l.front().second, c = r.front().first, d = r.front().second;\n\t\t\tl.pop(), r.pop();\n\t\t\tif(a == lg.first && b == lg.second && c == rg.first && d == rg.second)\n\t\t\t\tbreak;\n\t\t\tif(a == lg.first && b == lg.second || c == rg.first && d == rg.second)\n\t\t\t\tcontinue;\n\t\t\tfor(i = 0;i < 4;i++){\n\t\t\t\tif(a + dy[i] >= 0 && a + dy[i] < h && b + dx[i] >= 0 && b + dx[i] < w && lf[a + dy[i]][b + dx[i]] == '.' && c + dy[i] >= 0 && c + dy[i] < h && d - dx[i] >= 0 && d - dx[i] < w && rf[c + dy[i]][d - dx[i]] == '.' && s.find(pair<P,P>(P(a + dy[i],b + dx[i]),P(c + dy[i],d - dx[i]))) == s.end()){ // 両方とも動くとき\n\t\t\t\t\tl.push(P(a + dy[i],b + dx[i])), r.push(P(c + dy[i],d - dx[i]));\n\t\t\t\t\ts.insert(pair<P,P>(P(a + dy[i],b + dx[i]),P(c + dy[i],d - dx[i])));\n\t\t\t\t}\n\t\t\t\telse if(a + dy[i] >= 0 && a + dy[i] < h && b + dx[i] >= 0 && b + dx[i] < w && lf[a + dy[i]][b + dx[i]] == '#' && c + dy[i] >= 0 && c + dy[i] < h && d - dx[i] >= 0 && d - dx[i] < w && rf[c + dy[i]][d - dx[i]] == '.' && s.find(pair<P,P>(P(a,b),P(c + dy[i],d - dx[i]))) == s.end()){// Rinだけ動く\n\t\t\t\t\tl.push(P(a,b)), r.push(P(c + dy[i],d - dx[i]));\n\t\t\t\t\ts.insert(pair<P,P>(P(a,b),P(c + dy[i],d - dx[i])));\n\t\t\t\t}\n\t\t\t\telse if(a + dy[i] >= 0 && a + dy[i] < h && b + dx[i] >= 0 && b + dx[i] < w && lf[a + dy[i]][b + dx[i]] == '.' && c + dy[i] >= 0 && c + dy[i] < h && d - dx[i] >= 0 && d - dx[i] < w && rf[c + dy[i]][d - dx[i]] == '#' && s.find(pair<P,P>(P(a + dy[i],b + dx[i]),P(c,d))) == s.end()){ // Lenだけ動く\n\t\t\t\t\tl.push(P(a + dy[i],b + dx[i])), r.push(P(c,d));\n\t\t\t\t\ts.insert(pair<P,P>(P(a + dy[i],b + dx[i]),P(c,d)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(r.size())\n\t\t\tr.pop(),l.pop();\n\t\tif(s.find(pair<P,P>(P(lg.first,lg.second),P(rg.first,rg.second))) != s.end())\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t\ts.erase(s.begin(),s.end());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<set>\n#include<queue>\n#include<cmath>\nusing namespace std;\ntypedef vector<int> vi;\nconst int inf=1e9;\nint w,h;\nint ldx[]={-1,0,1,0};\nint ldy[]={0,1,0,-1};\nint rdx[]={1,0,-1,0};\nint rdy[]={0,1,0,-1};\nbool rinvis[55][55];\nbool renvis[55][55];\nbool vis[55][55][55][55];\nstring rin[55];\nstring ren[55];\nbool treasure;\nint rinsx,rinsy,ringx,ringy,rensx,rensy,rengx,rengy;\nstruct P\n{\n  int ly,lx,ry,rx;\n  P(int ly,int lx,int ry,int rx):ly(ly),lx(lx),ry(ry),rx(rx){};\n};\nvoid bfs(int lx,int ly,int rx,int ry)\n{\n  vis[ly][lx][ry][rx]=true;\n  // renvis[ly][lx]=true;\n  //rinvis[ry][rx]=true;\n  queue<P> q;\n  q.push(P(ly,lx,ry,rx));\n  while(!q.empty())\n    {\n      P now=q.front();q.pop();\n      int rennx,renny,rinnx,rinny;\n      bool rengoal=false;\n      bool ringoal=false;\n      for(int k=0;k<4;k++)\n\t{\n\t  rennx=now.lx+ldx[k];\n\t  renny=now.ly+ldy[k];\n\t  rinnx=now.rx+rdx[k];\n\t  rinny=now.ry+rdy[k];\n\t  if(rennx>=w || renny>=h || rennx<0 || renny<0 || rinnx>=w || rinny>=h || rinnx<0 || rinny<0) continue;\n\t  //if(renvis[renny][rennx] || rinvis[rinny][rinnx]) continue;\n\t  if(ren[renny][rennx]=='#')\n\t    {\n\t      rennx=now.lx;\n\t      renny=now.ly;\n\t    }\n\t  if(rin[rinny][rinnx]=='#')\n\t    {\n\t      rinnx=now.rx;\n\t      rinny=now.ry;\n\t    }\n\t  if(vis[renny][rennx][rinny][rinnx])continue;\n\t  if(ren[renny][rennx]=='%') rengoal=true;\n\t  else rengoal=false;\n\t  if(rin[rinny][rinnx]=='%') ringoal=true;\n\t  else ringoal=false;\n\t  if(rengoal^ringoal) continue;\n\t  if(ren[renny][rennx]=='%' && rin[rinny][rinnx]=='%')\n\t    {\n\t      treasure=true;\n\t      return;\n\t    }\n\t  q.push(P(renny,rennx,rinny,rinnx));\n\t  vis[renny][rennx][rinny][rinnx]=true;\n\t}\n    }\n}\n\nint main()\n{\n  while(cin >> w >> h && w)\n    {\n      treasure=false;\n      memset(vis,false,sizeof(vis));\n      //memset(renvis,false,sizeof(renvis));\n      //memset(rinvis,false,sizeof(rinvis));\n      for(int i=0;i<h;i++)\n\t{\n\t  cin >> ren[i] >> rin[i];\n\t}\n      for(int i=0;i<h;i++)\n\t{\n\t  for(int j=0;j<h;j++)\n\t    {\n\t      if(ren[i][j]=='L')\n\t\t{\n\t\t  rensy=i;\n\t\t  rensx=j;\n\t\t}\n\t      if(ren[i][j]=='%')\n\t\t{\n\t\t  rengy=i;\n\t\t  rengx=j;\n\t\t}\n\t      if(rin[i][j]=='R')\n\t\t{\n\t\t  rinsy=i;\n\t\t  rinsx=j;\n\t\t}\n\t      if(rin[i][j]=='%')\n\t\t{\n\t\t  ringy=i;\n\t\t  ringx=j;\n\t\t}\n\t    }\n\t}\n      bfs(rensx,rensy,rinsx,rinsy);\n      if(treasure)\n\t{\n\t  cout << \"Yes\" << endl;\n\t}\n      else\n\t{\n\t  cout << \"No\" << endl;\n\t}\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s); sin>>v; return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\n\ntypedef pair<pii,pii> pp;\nint dx[]={-1,0,1,0},dy[]={0,-1,0,1};\nint main(){\n\tint h,w;\n\twhile(cin>>w>>h,h|w){\n\t\tvs lfield(h);\n\t\tvs rfield(h);\n\t\tpii rs,ls,rg,lg;\n\t\tREP(i,h){\n\t\t\tcin>>lfield[i];\n\t\t\tcin>>rfield[i];\n\t\t\tREP(j,w){\n\t\t\t\tswitch(lfield[i][j]){\n\t\t\t\tcase 'L':\n\t\t\t\t\tls=make_pair(i,j);break;\n\t\t\t\tcase '%':\n\t\t\t\t\tlg=make_pair(i,j);break;\n\t\t\t\t}\n\t\t\t\tswitch(rfield[i][j]){\n\t\t\t\tcase 'R':\n\t\t\t\t\trs=make_pair(i,j);break;\n\t\t\t\tcase '%':\n\t\t\t\t\trg=make_pair(i,j);break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstatic int visited[50][50][50][50]={};\n\t\tREP(i,50)REP(j,50)REP(k,50)REP(l,50){\n\t\t\tvisited[i][j][k][l]=0;\n\t\t}\n\t\tvisited[ls.first][ls.second][rs.first][rs.second]=1;\n\t\tqueue<pp> q;\n\t\tq.push(make_pair(ls,rs));\n\t\twhile(!q.empty()){\n\t\t\tpp p=q.front();q.pop();\n\t\t\tpii lp=p.first;\n\t\t\tpii rp=p.second;\n\t\t\tREP(d,4){\n\t\t\t\tint ly=lp.first+dy[d];\n\t\t\t\tint lx=lp.second+dx[d];\n\t\t\t\tint ry=rp.first+dy[d];\n\t\t\t\tint rx=rp.second+dx[(d+2)%4];\n\t\t\t\tif(ly<0||lx<0||ly>=h||lx>=w||lfield[ly][lx]=='#'){\n\t\t\t\t\tly=lp.first;\n\t\t\t\t\tlx=lp.second;\n\t\t\t\t}\n\t\t\t\tif(ry<0||rx<0||ry>=h||rx>=w||rfield[ry][rx]=='#'){\n\t\t\t\t\try=rp.first;\n\t\t\t\t\trx=rp.second;\n\t\t\t\t}\n\t\t\t\tif(!visited[ly][lx][ry][rx]){\n\t\t\t\t\tif(!(ly==lg.first&&lx==lg.second&&!(ry==rg.first&&rx==rg.second))&&!(ry==rg.first&&rx==rg.second&&!(ly==lg.first&&lx==lg.second))){\n\t\t\t\t\t\tvisited[ly][lx][ry][rx]=1;\n\t\t\t\t\t\tq.push(make_pair(make_pair(ly,lx),make_pair(ry,rx)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<(visited[lg.first][lg.second][rg.first][rg.second]?\"Yes\":\"No\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, k, n) for (int i = (int)(k); i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rREP(i, k, n) for (int i = (int)(n)-1; i >= k; i--)\n\n#define debug(x) cerr << #x << \": \" << x << endl;\n\n#define fi first\n#define se second\n\n#define vi vector<int>\n#define pii pair<int, int>\n#define pb push_back\n#define mp make_pair\n\n#define pcnt __builtin_popcount\n\ntypedef long long ll;\n\nconst int    inf = 100100100;\nconst int    MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\nconst int    dx[4] = { 0, 1, 0, -1 };\nconst int    dy[4] = { 1, 0, -1, 0 };\n\nstruct POINT {\n    int lx;\n    int ly;\n    int rx;\n    int ry;\n};\n\nbool ul[55][55] = {};\nbool ur[55][55] = {};\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n//    ifstream in(\"./input.txt\");\n//    cin.rdbuf(in.rdbuf());\n    int    w, h;\n    string ML[55], MR[55];\n    int slx,sly,srx,sry;\n    while (cin >> w >> h, w) {\n        rep(y, h) cin >> ML[y] >> MR[y];\n        rep(y,h) rep(x,w){\n            if(ML[y][x] == 'L') slx = x,sly = y;\n            if(MR[y][x] == 'R') srx = x,sry = y;\n        }\n        queue<POINT> que;\n        que.push(POINT{slx, sly, srx, sry});\n\n        bool flag = false;\n        while (!que.empty()) {\n            POINT p = que.front();\n            que.pop();\n            if (ul[p.lx][p.ly] && ur[p.rx][p.ry]) continue;\n            rep(i, 4) {\n                int nlx = p.lx + dx[i];\n                int nly = p.ly + dy[i];\n                int nrx = p.rx + dx[(i + 2) % 4];\n                int nry = p.ry + dy[i];\n                bool left_do = true;\n                bool right_do = true;\n                if (nlx < 0 || w <= nlx) left_do = false;\n                if (nly < 0 || h <= nly) left_do = false;\n                if (ML[nly][nlx] == '#') left_do = false;\n                if (nrx < 0 || w <= nrx) right_do = false;\n                if (nry < 0 || h <= nry) right_do = false;\n                if (MR[nry][nrx] == '#') right_do = false;\n                if (ML[nly][nlx] == '%' && MR[nry][nrx] == '%') {\n                    flag = true;\n                    while (!que.empty()) que.pop();\n                    break;\n                } else if (ML[nly][nlx] == '%' || MR[nry][nrx] == '%') {\n                    continue;\n                }\n                if (!left_do && !right_do) continue;\n                if (!left_do) nlx = p.lx, nly = p.ly;\n                if (!right_do) nrx = p.rx, nry = p.ry;\n                que.push(POINT{nlx, nly, nrx, nry});\n            }\n            ul[p.lx][p.ly] = true;\n            ur[p.rx][p.ry] = true;\n        }\n        if (flag)\n            cout << \"Yes\" << endl;\n        else\n            cout << \"No\" << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define WRAP(x,y,w,h) (0<=x && x<w && 0<=y && y<h)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nbool G[50][50][50][50];\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h, w) {\n\t\tvector<string> cell1(h);\n\t\tvector<string> cell2(h);\n\t\tint slx, sly, srx, sry;\n\t\tint glx, gly, grx, gry;\n\t\tREP(i, h) {\n\t\t\tcin >> cell1[i] >> cell2[i];\n\t\t\tREP(j, w / 2)\n\t\t\t\tswap(cell2[i][j], cell2[i][w - 1 - j]);\n\t\t\tREP(j, w) {\n\t\t\t\tif (cell1[i][j] == 'L') {\n\t\t\t\t\tsly = i;\n\t\t\t\t\tslx = j;\n\t\t\t\t}\n\t\t\t\tif (cell1[i][j] == '%') {\n\t\t\t\t\tgly = i;\n\t\t\t\t\tglx = j;\n\t\t\t\t}\n\t\t\t\tif (cell2[i][j] == 'R') {\n\t\t\t\t\tsry = i;\n\t\t\t\t\tsrx = j;\n\t\t\t\t}\n\t\t\t\tif (cell2[i][j] == '%') {\n\t\t\t\t\tgry = i;\n\t\t\t\t\tgrx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, 50)\n\t\t\tREP(j, 50)\n\t\t\tREP(k, 50)\n\t\t\tREP(l, 50)\n\t\t\tG[i][j][k][l] = false;\n\t\tG[sly][slx][sry][srx] = true;\n\t\t//set<pair<pair<char,char>, pair<char, char>>> G;\n\t\t//G.insert({ {sly,slx},{sry,srx} });\n\t\tqueue<pair<pair<char, char>, pair<char, char>>> Q;\n\t\tQ.push({ { sly,slx },{ sry,srx } });\n\t\t//bool G2[50][50][50][50] = { false };\n\t\t//G2[gly][glx][gry][grx] = true;\n\t\t//set<pair<pair<char, char>, pair<char, char>>> G2;\n\t\t//G2.insert({ { gly,glx },{ gry,grx } });\n\t\t//queue<pair<pair<char, char>, pair<char, char>>> Q2;\n\t\t//Q2.push({ { gly,glx },{ sry,grx } });\n\t\tstring clear = \"No\";\n\t\twhile (!Q.empty()) {\n\t\t\tpair<pair<char, char>, pair<char, char>> q;\n\t\t\tq = Q.front();Q.pop();\n\t\t\tif (q.first.first==gly&&\n\t\t\t\tq.first.second==glx&&\n\t\t\t\tq.second.first==gry&&\n\t\t\t\tq.second.second==grx) {\n\t\t\t\tclear = \"Yes\";\n\t\t\t\tgoto ANS;\n\t\t\t}\n\t\t\tREP(i, 4) {\n\t\t\t\tint nly = q.first.first + dy[i];\n\t\t\t\tint nlx = q.first.second + dx[i];\n\t\t\t\tint nry = q.second.first + dy[i];\n\t\t\t\tint nrx = q.second.second + dx[i];\n\t\t\t\tif (!WRAP(nlx, nly, w, h) || cell1[nly][nlx] == '#') {\n\t\t\t\t\tnly = q.first.first;\n\t\t\t\t\tnlx = q.first.second;\n\t\t\t\t}\n\t\t\t\tif (!WRAP(nrx, nry, w, h) || cell2[nry][nrx] == '#') {\n\t\t\t\t\tnry = q.second.first;\n\t\t\t\t\tnrx = q.second.second;\n\t\t\t\t}\n\t\t\t\tbool b1 = (nly == gly&&nlx == glx);\n\t\t\t\tbool b2 = (nry == gry&&nrx == grx);\n\t\t\t\tif (b1 != b2)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!G[nly][nlx][nry][nrx]) {\n\t\t\t\t\tG[nly][nlx][nry][nrx] = true;\n\t\t\t\t\tQ.push({ { nly,nlx },{ nry,nrx } });\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\tANS:\n\t\tcout << clear << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntypedef double weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\ntypedef vector<vector<edge>> Graph;\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\n\n\nint main()\n{\n\tint h, w;\n\twhile (cin >> w >> h, w)\n\t{\n\t\tvs fld1(h), fld2(h);\n\t\tREP(i, h) cin >> fld1[i] >> fld2[i];\n\t\tpii sa, sb, ga, gb;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld1[i][j] == 'L') sa = pii(i, j);\n\t\t\tif (fld2[i][j] == 'R') sb = pii(i, j);\n\t\t\tif (fld1[i][j] == '%') ga = pii(i, j);\n\t\t\tif (fld2[i][j] == '%') gb = pii(i, j);\n\t\t}\n\t\ttypedef pair<pii, pii> data;\n\t\tset<data> st;\n\t\tqueue<data> que;\n\t\tque.push(data(sa, sb));\n\t\tdata goal = data(ga, gb);\n\t\twhile (que.size())\n\t\t{\n\t\t\tdata tmp = que.front();\n\t\t\tque.pop();\n\t\t\tst.insert(tmp);\n\t\t\tif (tmp == goal) break;\n\t\t\tint lx = tmp.first.first, ly = tmp.first.second;\n\t\t\tint rx = tmp.second.first, ry = tmp.second.second;\n\t\t\tREP(i, 4)\n\t\t\t{\n\t\t\t\tint lnx = lx + dx[i], lny = ly + dy[i];\n\t\t\t\tint rnx = rx + dx[i], rny = ry - dy[i];\n\t\t\t\tif (!valid(lnx, lny, h, w) || fld1[lnx][lny]=='#')\n\t\t\t\t{\n\t\t\t\t\tlnx = lx, lny = ly;\n\t\t\t\t}\t\t\t\t\n\t\t\t\tif (!valid(rnx, rny, h, w) || fld2[rnx][rny] == '#')\n\t\t\t\t{\n\t\t\t\t\trnx = rx, rny = ry;\n\t\t\t\t}\n\t\t\t\tpii nl(lnx, lny), nr(rnx, rny);\n\t\t\t\tdata next = data(nl, nr);\n\t\t\t\tif (next != goal && (nl == ga || nr == gb)) continue;\n\t\t\t\tif (st.find(next) != st.end()) continue;\n\t\t\t\tque.push(next);\n\t\t\t}\n\t\t}\n\t\tif (st.find(goal) == st.end()) puts(\"No\");\n\t\telse puts(\"Yes\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx_r[] = {0,1,0,-1};\nstatic const int ty_r[] = {-1,0,1,0};\n\nstatic const int tx_l[] = {0,-1,0,1};\nstatic const int ty_l[] = {-1,0,1,0};\n\nbool visited[50][50][50][50];\nchar stage_Len[50][50];\nchar stage_Rin[50][50];\n\nbool can_reach;\nint W,H;\n\nvoid dfs(int Rin_x,int Rin_y,int Len_x,int Len_y){\n  for(int i=0;i<4;i++){\n    int Rin_dx = Rin_x + tx_r[i];\n    int Rin_dy = Rin_y + ty_r[i];\n\n    int Len_dx = Len_x + tx_l[i];\n    int Len_dy = Len_y + ty_l[i];\n    if(Rin_dx < 0 || Rin_dx >= W || Rin_dy < 0 || Rin_dy >= H){\n\tcontinue;\n    }\n    if(Len_dx < 0 || Len_dx >= W || Len_dy < 0 || Len_dy >= H){\n\tcontinue;\n    }\n    if(stage_Rin[Rin_dy][Rin_dx] == '#'){\n      Rin_dy = Rin_y;\n      Rin_dx = Rin_x;\n    }\n    if(stage_Len[Len_dy][Len_dx] == '#'){\n      Len_dy = Len_y;\n      Len_dx = Len_x;\n    }\n\n    if(visited[Rin_dx][Rin_dy][Len_dx][Len_dy]){\n      continue;\n    }\n\n    if(stage_Len[Len_dy][Len_dx] == '%'\n       && stage_Rin[Rin_dy][Rin_dx] == '%'){\n      can_reach = true;\n      return;\n    }\n\n    if(stage_Len[Len_dy][Len_dx] != '%'\n       && stage_Rin[Rin_dy][Rin_dx] != '%'){\n      visited[Rin_dx][Rin_dy][Len_dx][Len_dy] = true;\n      dfs(Rin_dx,Rin_dy,Len_dx,Len_dy);\n    }\n  }\n}\n\nint main(){\n\n  while(~scanf(\"%d %d\",&W,&H)){\n    if(W==0 && H==0) break;\n\n    memset(visited,false,sizeof(visited));\n    can_reach = false;\n    \n    int Rin_start_x = 0;\n    int Rin_start_y = 0;\n    int Len_start_x = 0;\n    int Len_start_y = 0;\n \n    for(int y=0;y<H;y++){\n      string str_Len,str_Rin;\n      cin >> str_Len >> str_Rin;\n      \n      // cout << str_Len << endl;\n      // cout << str_Rin << endl;\n\n      for(int x=0;x<W;x++){\n\tstage_Len[y][x] = str_Len[x];\n\tstage_Rin[y][x] = str_Rin[x];\n\n\tif(str_Len[x] == 'L'){\n\t  Len_start_x = x;\n\t  Len_start_y = y;\n\t}\n\tif(str_Rin[x] == 'R'){\n\t  Rin_start_x = x;\n\t  Rin_start_y = y;\n\t}\n      }\n    }\n\n    dfs(Rin_start_x,Rin_start_y,Len_start_x,Len_start_y);\n    printf(\"%s\\n\",can_reach ? \"Yes\" : \"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <stack>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\ntypedef vector<string> vs;\ntypedef vector<int> vi;\n\n#define rep(i,b) loop(i,0,b)\n#define loop(i,a,b) for(int i=(a); i<int(b); i++)\n#define all(c) (c).begin(), (c).end()\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nint h,w;\ninline bool in(int x, int y){\n    return 0<=x && 0<=y && x<w && y<h;\n}\n\nvi id{0,1,2,3};\nbool solve(vs const& g1, vs const& g2){\n    int sx1, sy1, sx2, sy2;\n    rep(i,h)rep(j,w){\n        if(g1[i][j]=='L'){\n            sx1=j;sy1=i;\n        }\n        if(g2[i][j]=='R'){\n            sx2=j;sy2=i;\n        }\n    }\n    queue<vi> q;\n    static bool vis[64][64][64][64];\n    memset(vis,0,sizeof(vis));\n    q.push(vi{sx1,sy1,sx2,sy2});\n    while(q.size()){\n        vi s=q.front();q.pop();\n        int x1=s[0],y1=s[1],x2=s[2],y2=s[3];\n        if(vis[x1][y1][x2][y2])continue;\n        vis[x1][y1][x2][y2]=true;\n        if(g1[y1][x1]=='%' && g2[y2][x2]=='%') return true;\n        if(g1[y1][x1]=='%' || g2[y2][x2]=='%') continue;\n\n        random_shuffle(all(id));\n        rep(i,4){\n            int d=id[i];\n            int nx1=x1+dx[d],ny1=y1+dy[d];\n            int nx2,ny2;\n            if(d&1){\n                nx2=x2+dx[d],ny2=y2+dy[d];\n            }else{\n                nx2=x2-dx[d],ny2=y2-dy[d];\n            }\n            if(!in(nx1,ny1) || g1[ny1][nx1]=='#')nx1=x1,ny1=y1;\n            if(!in(nx2,ny2) || g2[ny2][nx2]=='#')nx2=x2,ny2=y2;\n            q.push(vi{nx1,ny1,nx2,ny2});\n        }\n    }\n    return false;    \n}\n\nint main(){\n    while(cin>>w>>h && w|h){\n        vs g1(h), g2(h);\n        rep(i,h) cin>>g1[i]>>g2[i];\n        vs ans{\"No\",\"Yes\"};\n        cout << ans[solve(g1,g2)] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": " #include<bits/stdc++.h>\n using namespace std;\n#define INF 1000000000\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\ntypedef long long LL;\nint H,W;\nint A[100][100];\nint B[100][100];\nint sax,say,tax,tay;\nint sbx,sby,tbx,tby;\nbool used[51][51][51][51];\ntypedef pair<int,int>P;\ntypedef pair<P,P>PP;\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\n\nP move(P now,int x,int y){\n  if(now.first+x<0){\n     return now;\n  }\n  if(now.first+x>=W){\n     return now;\n  }\n  if(now.second+y<0){\n     return now;\n  }\n  if(now.second+y>=H){\n     return now;\n  }\n  if(A[now.first+x][now.second]!=1){\n     now.first+=x;\n  }\n  if(A[now.first][now.second+y]!=1){\n     now.second+=y;\n  }\n  return now;\n}\n\nP move2(P now,int x,int y){\n  if(now.first+x<0){\n     return now;\n  }\n  if(now.first+x>=W){\n     return now;\n  }\n  if(now.second+y<0){\n     return now;\n  }\n  if(now.second+y>=H){\n     return now;\n  }\n  if(B[now.first+x][now.second]!=1){\n     now.first+=x;\n  }\n  if(B[now.first][now.second+y]!=1){\n     now.second+=y;\n  }\n  return now;\n}\n\n\nint main(){\n    int c=0;\n    while(cin>>W>>H,W){\n       //c++;\n       //if(c>=2)break;\n       //vector<int>\n       REP(i,H){\n           string s;\n           cin>>s;\n           REP(j,W){\n              if(s[j]=='L'){\n                 sax=j;\n                 say=i;\n              }\n              if(s[j]=='%'){\n                 tax=j;\n                 tay=i;\n              }\n              A[j][i]=0;\n              if(s[j]=='#'){\n                 A[j][i]=1;\n              }\n           }\n           cin>>s;\n           REP(j,W){\n              if(s[j]=='R'){\n                 sbx=j;\n                 sby=i;\n              }\n              if(s[j]=='%'){\n                 tbx=j;\n                 tby=i;\n              }\n              B[j][i]=0;\n              if(s[j]=='#'){\n                 B[j][i]=1;\n              }\n           }\n       }\n       //cout<<\"input_ok\"<<endl;\n       //cout<<tax<<\" \"<<tay<<\" \"<<tbx<<\" \"<<tby<<endl;\n       //????????????bfs\n       REP(i,50){\n           REP(j,50){\n               REP(k,50){\n                   REP(l,50){\n                       used[i][j][k][l]=false;\n                   }\n               }\n           }\n       }\n\n       used[sax][say][sbx][sby]=true;\n       vector<PP>v;\n       v.push_back(PP(P(sax,say),P(sbx,sby)));\n       int now=0;\n       while(now<v.size()){\n          //cout<<\"now\"<<now;\n          P l=v[now].first;\n          P r=v[now].second;\n          used[l.first][l.second][r.first][r.second]=true;\n          //cout<<l.first<<\" \"<<l.second<<\" \"<<r.first<<\" \"<<r.second<<endl;\n          REP(i,4){\n              P ll=move(l,dx[i],dy[i]);\n              P rr=move2(r,-dx[i],dy[i]);\n              if(used[ll.first][ll.second][rr.first][rr.second]==false){\n                    used[ll.first][ll.second][rr.first][rr.second]=true;\n              /*if(now>=50*50*50*50){\n              cout<<c<<\"ok\"<<ll.first<<\" \"<<ll.second<<\" \"<<rr.first<<\" \"<<rr.second<<endl;\n              }*/\n                 if((ll.first==tax)&&(ll.second==tay)){\n                    used[ll.first][ll.second][rr.first][rr.second]=true;\n                    continue;\n                 }\n                 if((rr.first==tbx)&&(rr.second==tby)){\n                    used[ll.first][ll.second][rr.first][rr.second]=true;\n                    continue;\n                 }\n                   v.push_back(PP(ll,rr));\n              }\n          }\n          now++;\n       }\n       \n       //cout<<endl;\n       if(used[tax][tay][tbx][tby]==true){\n          cout<<\"Yes\"<<endl;\n       }else{\n          cout<<\"No\"<<endl;\n       }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <string.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int>;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\nll w,h;\n\nvector<string> l,r;\n\n/* bool search(int lx,int ly,int rx,int ry){                                       */\n/*   if(!value(lx,ly,w,h) || !value(rx,ry,w,h) || f[lx][ly][rx][ry]) return false; */\n/*   (f[lx][ly][rx][ry]) = true;                                                   */\n/*   bool res = false;                                                             */\n/*   rep(i,4){                                                                     */\n/*     int nlx = lx + dx[i],nly = ly + dy[i],nrx = rx - dx[i],nry = ry + dy[i];    */\n/*     cout << nlx << ' ' << nly << ' ' << nrx << ' ' << nry << endl;              */\n/*     if(value(nlx,nly,w,h) && value(nrx,nry,w,h) ){                              */\n/*       if( l[nly][nlx] == '.' && r[nry][nrx] == '.')                             */\n/*         res |= search(nlx,nly,nrx,nry);                                         */\n/*     }                                                                           */\n/*     if(value(nlx,nly,w,h) && value(nrx,nry,w,h) ){                              */\n/*       if( l[nly][nlx] == '.' && r[nry][nrx] == '#')                             */\n/*         res |= search(nlx,nly,rx,ry);                                           */\n/*     }                                                                           */\n/*     if(value(nlx,nly,w,h) && value(nrx,nry,w,h) ){                              */\n/*       if( l[nly][nlx] == '#' && r[nry][nrx] == '.')                             */\n/*         res |= search(lx,ly,nrx,nry);                                           */\n/*     }                                                                           */\n/*     if(value(nlx,nly,w,h) && value(nrx,nry,w,h) ){                              */\n/*       if( l[nly][nlx] == '%' && r[nry][nrx] == '%')                             */\n/*         return true;                                                            */\n/*     }                                                                           */\n/*   }                                                                             */\n/*   return res;                                                                   */\n/* }                                                                               */\n\nbool f[51][51][51][51] ={};\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll lx,ly,rx,ry;\n  while(cin >> w >> h &&  w + h ){\n    l.resize(h),r.resize(h);\n    rep(i,h){\n      cin >> l[i] >> r[i];\n      rep(j,w){\n        if(l[i][j] == 'L'){\n          ly = i;\n          lx = j;\n        }\n        if(r[i][j] == 'R'){\n          ry = i;\n          rx = j;\n        }\n      }\n    }\n    auto make = [](int lx,int ly,int rx,int ry){return mp(mp(lx,ly),mp(rx,ry));};\n    bool ans = false;\n    queue<pair<pii,pii>> q;\n    q.push(make(lx,ly,rx,ry));\n    memset(f,0,51*51*51*51);\n    f[lx][ly][rx][ry] = true;\n    while(q.size()){\n      pii lp = q.front().fi,rp = q.front().se;\n      q.pop();\n      lx = lp.fi,ly = lp.se,rx = rp.fi,ry = rp.se;\n      f[lx][ly][rx][ry] = true;\n      rep(i,4){\n        int nlx = lx + dx[i],nly = ly + dy[i],nrx = rx - dx[i],nry = ry + dy[i];\n        /* cout << nlx << ' ' << nly << ' ' << nrx << ' ' << nry << endl; */\n        if(value(nlx,nly,w,h) && value(nrx,nry,w,h) ){\n          if( l[nly][nlx] == '.' && r[nry][nrx] == '.' && !f[nlx][nly][nrx][nry]){\n            q.push(make(nlx,nly,nrx,nry));\n          }\n        }\n        if(value(nlx,nly,w,h) && value(nrx,nry,w,h) && !f[nlx][nly][rx][ry]){\n          if( l[nly][nlx] == '.' && r[nry][nrx] == '#'){\n            q.push(make(nlx,nly,rx,ry));\n          }\n        }\n        if(value(nlx,nly,w,h) && value(nrx,nry,w,h) && !f[lx][ly][nrx][nry]){\n          if( l[nly][nlx] == '#' && r[nry][nrx] == '.'){\n            q.push(make(lx,ly,nrx,nry));\n          }\n        }\n        if(value(nlx,nly,w,h) && value(nrx,nry,w,h) ){\n          if( l[nly][nlx] == '%' && r[nry][nrx] == '%'){\n            ans = true;\n            while(q.size()){\n              q.pop();\n            }\n          }\n        }\n      } \n    }\n    std::cout << (ans ? \"Yes\" : \"No\") << std::endl; \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#define N 52\n#define y1 first.first\n#define x1 first.second\n#define y2 second.first\n#define x2 second.second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\n\nvoid bfs();\n\nint w,h,sy1,sx1,sy2,sx2,gy1,gx1,gy2,gx2,ans;\nstring r1[N],r2[N];\nset<P1> visited;\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(!w&&!h) break;\n    for(int i=0;i<h;i++) cin>>r1[i]>>r2[i];\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(r1[i][j]=='L') sy1=i,sx1=j;\n\tif(r1[i][j]=='%') gy1=i,gx1=j;\n\tif(r2[i][j]=='R') sy2=i,sx2=j;\n\tif(r2[i][j]=='%') gy2=i,gx2=j;\n      }\n    ans=0;\n    bfs();\n    if(ans) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n  return 0;\n}\n\nvoid bfs(){\n  int dy[4]={0,-1,0,1},dx[4]={-1,0,1,0};\n  queue<P1> q;\n  P1 k=make_pair(make_pair(sy1,sx1),make_pair(sy2,sx2));\n  q.push(k);\n  visited.insert(k);\n  while(!q.empty()){\n    P1 t=q.front(); q.pop();\n    for(int i=0;i<4;i++){\n      int ny1=t.y1+dy[i],nx1=t.x1+dx[i];\n      int ny2=t.y2-dy[i],nx2=t.y2-dx[i];\n      if(ny1<0) ny1=0;\n      if(nx1<0) nx1=0;\n      if(h<=ny1) ny1=h;\n      if(w<=nx1) nx1=w;\n      if(ny2<0) ny2=0;\n      if(nx2<0) nx2=0;\n      if(h<=ny2) ny2=h;\n      if(w<=nx2) nx2=w;\n      if(r1[ny1][nx1]=='#') ny1=t.y1,nx1=t.x1;\n      if(r2[ny2][nx2]=='#') ny2=t.y2,nx2=t.x2;\n      P1 u=make_pair(make_pair(ny1,nx1),make_pair(ny2,nx2));\n      if(visited.find(u)!=visited.end()) continue;\n      visited.insert(u);\n      if(ny1==gy1&&nx1==gx1&&ny2==gy2&&nx2==gx2){\n\tans=1;\n\tbreak;\n      }\n    }\n    if(ans) break;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppa pair<int,int>\n                                        #define ppap pair<int,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-12)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                  #define VI vector<int>\n                                        using namespace std;\n                                        \n                                  class pas{\n                                    \tpublic:\n                                    \tint x,y;\n                                    \tpas(int x=0,int y=0):x(x),y(y) {}\n                                    \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                    \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                    \tpas operator * (int a) {return pas(x*a,y*a);}\n                                    \tpas operator / (int a) {return pas(x/a,y/a);}\n                                    //\tdouble absv() {return sqrt(norm());}\n                                    \tint norm() {return x*x+y*y;}\n                                    \tbool operator < (const pas &p) const{\n                                   \t\treturn x != p.x ? x<p.x: y<p.y;\n                                   \t}\n                                  //\t\tbool operator < (const pas &p) const{\n                                    //\t\treturn y != p.y ? y<p.y: x<p.x;\n                                    //\t}\n                                    \tbool operator == (const pas &p) const{\n                                    \t\treturn x==p.x && y==p.y;\n                                    \t}\n                                    };\n\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                        \nstruct star{\nSegment se[5];\n};\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(b.p1),(b.p2))&&parareru((a.p2),(a.p1),(b.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n            double segment_len(Segment a){\n            \t\n            \treturn (a.p1-a.p2).absv();\n            }\n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n\t\t\tpair<Point,Point> circle_intersection(Point c1,double r1,Point c2,double r2){\n\t\t\t\tdouble d=(c1-c2).absv();\n\t\t\t\tdouble h=(r1*r1-r2*r2+d*d)/2.0/d;\n\t\t\t\tdouble l=sqrt(r1*r1-h*h);\n\t\t\t//\tcout<<d<<\" \"<<h<<\" \"<<l<<endl;\n\t\t\t\tPoint asi=c1+(c2-c1)*h/((c2-c1).absv());\n\t\t\t\tVector r1r2=(c2-c1)/((c2-c1).absv());\n\t\t\t\tVector sui={r1r2.y,-r1r2.x};\n\t\t\t//\tcout<<sui.x<<\" \"<<sui.y<<endl;\n\t\t\t\tpair<Point,Point> z=mp(asi+sui*l,asi-sui*l);\n\t\t\t\tif(z.first.x>z.second.x) swap(z.first,z.second);\n\t\t\t\treturn z;\n\t\t\t}\ndouble dist(star s1,star s2){\n\tdouble ans=10000000000.0;\n\t\n\tfor(int i=0;i<5;i++)for(int j=0;j<5;j++){\n\t\tif( is_intersected_ls(s1.se[i],s2.se[j])) {\n\t\t\t\n//\t\t\tcout<<s1.se[i].p1.x<<\" \"<<s1.se[i].p1.y<<endl;\n//\t\t\tcout<<s1.se[i].p2.x<<\" \"<<s1.se[i].p2.y<<endl;\n//\t\t\tcout<<s2.se[j].p1.x<<\" \"<<s2.se[j].p1.y<<endl;\n//\t\t\tcout<<s2.se[j].p2.x<<\" \"<<s2.se[j].p2.y<<endl;\n\t\treturn 0.0;\n\t\t}\n\t\tans=min(ans,segment_dis(s1.se[i],s2.se[j]));\n//\t\tcout<<\"   \"<<i<<\" \"<<j<<\" \"<<segment_dis(s1.se[i],s2.se[j])<<endl;\n\t}\n\treturn ans;\n}\nint gcd(int x,int y){\n\tif(x<y) return gcd(y,x);\n\tif(x==y) return x;\n\tif(x%y==0) return y;\n\treturn gcd(y,x%y);\n}\n class pa2{\n                                            public:\n                                            int x,y;\n                                            pa2(int x=0,int y=0):x(x),y(y) {}\n                                            pa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            pa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            bool operator < (const pa2 &p) const{\n                                                return x != p.x ? x<p.x: y<p.y;\n                                            }\n\t\t\t\t\t\t\t\t\t\t \t bool operator > (const pa2 &p) const{\n                                                return x != p.x ? x>p.x: y>p.y;\n                                            }\n                                            bool operator == (const pa2 &p) const{\n                                                return abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            }\n                                            bool operator != (const pa2 &p) const{\n                                                return !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            }\n                                                 \n                                         \n                                        };\n                                        \nint a[60][60];\nint b[60][60];\nint memo[60][60][60][60];\npriority_queue<pair<pa2,pa2>,vector<pair<pa2,pa2> > ,greater<pair<pa2,pa2> >> pq;\n     signed main(){\nint h,w;\n     \twhile(1){\n     \tcin>>w>>h;\n     \t\tif(h==0) return 0;\n     \t\tpa2 ag,bg,as,bs;\n     \t//\tcout<<w<<\" \"<<h<<endl;\n     \t\twhile(pq.size()>0)pq.pop();\n     \t\t\tfor(int i=0;i<60;i++)for(int j=0;j<60;j++)a[i][j]=1,b[i][j]=1;\n     \t\t\tfor(int i=0;i<60;i++)for(int j=0;j<60;j++)for(int k=0;k<60;k++)for(int l=0;l<60;l++)memo[i][j][k][l]=0;\n     \t\tfor(int i=1;i<=h;i++){\n     \t\t\tstring s;\n     \t\tcin>>s;\n     \t\t\ts=\"2\"+s;\n     \t\t\t\n     \t\t\tfor(int j=1;j<=w;j++){\n     \t\t\t\tif(s[j]=='.') a[i][j]=0;\n     \t\t\t\tif(s[j]=='#') a[i][j]=1;\n     \t\t\t\tif(s[j]=='%') {\n     \t\t\t\t\tag={i,j};\n     \t\t\t\t\ta[i][j]=0;\n     \t\t\t\t}\n     \t\t\t\tif(s[j]=='L') {\n     \t\t\t\t\tas={i,j};\n     \t\t\t\t\ta[i][j]=0;\n     \t\t\t\t}\n     \t\t\t\t\n     \t\t\t}\n     \t\tcin>>s;\n     \t\t\ts=\"2\"+s;\n     \t\t\tfor(int j=1;j<=w;j++){\n     \t\t\t\tif(s[j]=='.') b[i][j]=0;\n     \t\t\t\tif(s[j]=='#') b[i][j]=1;\n     \t\t\t\tif(s[j]=='%') {\n     \t\t\t\t\tbg={i,j};\n     \t\t\t\t\tb[i][j]=0;\n     \t\t\t\t}\n     \t\t\t\tif(s[j]=='R') {\n     \t\t\t\t\tbs={i,j};\n     \t\t\t\t\tb[i][j]=0;\n     \t\t\t\t}\n     \t\t\t\t\n     \t\t\t}\n     \t\t}\n     \t\t\n     \t\n     \t\t\n     \t\tpq.push(mp(as,bs));\n     \t\t\n     \t\twhile(pq.size()>0){\n     \t\t\tauto z=pq.top();\n     \t\t//\tcout<<z.first.x<<\" \"<<z.first.y<<\" \"<<z.second.x<<\" \"<<z.second.y<<endl;\n     \t\t\tpq.pop();\n     \t\t\tif(a[z.first.x][z.first.y]==1 || b[z.second.x][z.second.y]==1) continue;\n     \t\t\tif(memo[z.first.x][z.first.y][z.second.x][z.second.y]) continue;\n     \t\t\tmemo[z.first.x][z.first.y][z.second.x][z.second.y]=1;\n     \t\t\tint st=0;\n     \t\t\t\n     \t\t\tif(ag==z.first)st++;\n     \t\t\tif(bg==z.second)st++;\n     \t\t\tif(st==1) continue;\n     \t\t\tif(st==2){\n     \t\t\t\tcout<<\"Yes\"<<endl;\n     \t\t\tgoto lll;\n     \t\t\tbreak;\n     \t\t\t}\n     \t\t\tpq.push(mp((pa2){z.first.x+(a[z.first.x+1][z.first.y]==1?0:1),z.first.y},(pa2){z.second.x+(b[z.second.x+1][z.second.y]==1?0:1),z.second.y}));\n     \t\t\tpq.push(mp((pa2){z.first.x-(a[z.first.x-1][z.first.y]==1?0:1),z.first.y},(pa2){z.second.x-(b[z.second.x-1][z.second.y]==1?0:1),z.second.y}));\n     \t\t\tpq.push(mp((pa2){z.first.x,z.first.y+(a[z.first.x][z.first.y+1]==1?0:1)},(pa2){z.second.x,z.second.y-(b[z.second.x][z.second.y-1]==1?0:1)}));\n     \t\t\tpq.push(mp((pa2){z.first.x,z.first.y-(a[z.first.x][z.first.y-1]==1?0:1)},(pa2){z.second.x,z.second.y+(b[z.second.x][z.second.y+1]==1?0:1)}));\n     \t\t\t\n     \t\t}\n     \t\tcout<<\"No\"<<endl;\n     \t\tlll:;\n     \t\t\n     \t\n     \t\n     \t\n     \t}\n \n   \n           \treturn 0;\n           }\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> stat;\n\nint w, h;\npii ls, lg, rs, rg;\nstat start, goal;\n\nint dx[]={0, 0, 1, -1}, dy[]={1, -1, 0, 0};\n\nbool border(pii p){\n\t\n\treturn 0<=p.first&&p.first<w&&0<=p.second&&p.second<h;\n}\n\nstring solve(const vector<string> &left, const vector<string> &right){\n\t\n\tstart = make_pair(ls, rs);\n\tgoal = make_pair(lg, rg);\n\t\n\tset<stat> vis;\n\tqueue<stat> qu;\n\t\n\tvis.insert(start);\n\tqu.push(start);\n\t\n\twhile(!qu.empty()){\n\t\n\t\tpii lnx, rnx;\n\t\tstat now = qu.front();\n\t\tqu.pop();\n\t\t\n\t\tfor(int i=0; i<4; ++i){\n\t\t\t\t\n\t\t\tlnx = make_pair(now.first.first + dx[i], \n\t\t\t\t\t\t\tnow.first.second + dy[i]);\n\t\t\t\n\t\t\trnx = make_pair(now.second.first - dx[i], \n\t\t\t\t\t\t\tnow.second.second + dy[i]);\n\t\t\t\n\t\t\tif(!border(lnx)||left[lnx.second][lnx.first]=='#')\n\t\t\t\tlnx = now.first;\n\t\t\t\t\n\t\t\tif(!border(rnx)||right[rnx.second][rnx.first]=='#')\n\t\t\t\trnx = now.second;\n\t\t\t\n\t\t\tstat nx = make_pair(lnx, rnx);\n\t\t\t\n\t\t\tif(nx == goal)\n\t\t\t\treturn \"Yes\";\n\t\t\t\n\t\t\tif(!vis.count(nx)){\n\t\t\t\t\n\t\t\t\tvis.insert(nx);\n\t\t\t\tqu.push(nx);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn \"No\";\n}\n\t\nint main(){\n\t\n\twhile(cin>>w>>h, (w||h)){\n\t\t\n\t\tvector<string> left, right;\n\t\t\n\t\tfor(int i=0; i<h; ++i){\n\t\t\t\n\t\t\tstring l, r;\n\t\t\tcin >> l >> r;\n\t\t\t\n\t\t\tleft.push_back(l);\n\t\t\tright.push_back(r);\n\t\t}\n\t\t\n\t\tfor(int y=0; y<h; ++y){\n\t\t\tfor(int x=0; x<w; ++x){\n\t\t\t\n\t\t\t\tif(left[y][x] == 'L')\n\t\t\t\t\tls = make_pair(x, y);\n\t\t\t\tif(left[y][x] == '%')\n\t\t\t\t\tlg = make_pair(x, y);\n\t\t\t\tif(right[y][x] == 'R')\n\t\t\t\t\trs = make_pair(x, y);\n\t\t\t\tif(right[y][x] == '%')\n\t\t\t\t\trg = make_pair(x, y);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout <<\tsolve(left, right) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <utility>\n#include <cstring>\n\nusing namespace std;\n\nconst int dx[] = { -1, 0, 1, 0 };\nconst int dy[] = { 0, -1, 0, 1 };\n\nvector<string> field;\nint W, H;\nunsigned char memo[52][52][52][52];\n\nstruct State {\n\tint rx, ry, lx, ly;\n\tint index;\n};\n\nint main(){\n\twhile(true){\n\t\tcin >> W >> H;\n\t\tif(W == 0 && H == 0){ break; }\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tfield.resize(H + 2);\n\t\tfield[0] = field[H + 1] = string(W * 2 + 3, '#');\n\t\tState init = { 0 };\n\t\tfor(int i = 1; i <= H; ++i){\n\t\t\tstring l1, l2;\n\t\t\tcin >> l1 >> l2;\n\t\t\tstring line = \"#\" + l1 + \"#\" + l2 + \"#\";\n\t\t\tfor(int j = 0; j < line.size(); ++j){\n\t\t\t\tif(line[j] == 'R'){\n\t\t\t\t\tinit.rx = j; init.ry = i;\n\t\t\t\t}else if(line[j] == 'L'){\n\t\t\t\t\tinit.lx = j; init.ly = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfield[i] = line;\n\t\t}\n\t\tstack<State> stk;\n\t\tstk.push(init);\n\t\tbool ok = false;\n\t\twhile(!stk.empty()){\n\t\t\tState cur = stk.top();\n\t\t\tstk.pop();\n\t\t\tint rx = cur.rx, ry = cur.ry, lx = cur.lx, ly = cur.ly;\n\t\t\tif(cur.index == 0){\n\t\t\t\tif(memo[rx - W - 1][ry][lx][ly]){ continue; }\n\t\t\t\tmemo[rx - W - 1][ry][lx][ly] = 1;\n\t\t\t\tif(field[ry][rx] == '%' && field[ly][lx] == '%'){\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(field[ry][rx] == '%' || field[ly][lx] == '%'){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint nrx = rx + dx[cur.index], nry = ry + dy[cur.index];\n\t\t\tint nlx = lx - dx[cur.index], nly = ly + dy[cur.index];\n\t\t\tif(field[nry][nrx] == '#'){\n\t\t\t\tnrx -= dx[cur.index];\n\t\t\t\tnry -= dy[cur.index];\n\t\t\t}\n\t\t\tif(field[nly][nlx] == '#'){\n\t\t\t\tnlx += dx[cur.index];\n\t\t\t\tnly -= dy[cur.index];\n\t\t\t}\n\t\t\tif(cur.index != 3){\n\t\t\t\t++cur.index;\n\t\t\t\tstk.push(cur);\n\t\t\t}\n\t\t\tState next = { nrx, nry, nlx, nly, 0 };\n\t\t\tstk.push(next);\n\t\t}\n\t\tcout << (ok ? \"Yes\" : \"No\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint w, h; \nstruct Pos {\n  int x;\n  int y;\n  bool operator==(Pos that) {\n    return x == that.x && y == that.y;\n  }\n  Pos operator+(Pos that) {\n    return {x+that.x, y+that.y};\n  }\n\n  Pos (int xx, int yy) {\n    x = xx; y = yy;\n  }\n};\n\nbool inner(Pos p) {\n  return 0 <= p.x && p.x < w\n      && 0 <= p.y && p.y < h;\n}\n\nPos search_charactor(vector<string> &map, char charactor) {\n  for (int i=0; i<map.size(); i++)\n    for (int l=0; l<map[i].size(); l++)\n      if (map[i][l] == charactor) {\n        map[i][l] = '.';\n        return {l, i};\n      }\n}\n\ntemplate <typename T>\nusing V=vector<T>;\n\nint main(){\n  while (cin >> w >> h, w+h != 0) {\n    vector<string> rooml, roomr;\n    rooml.reserve(h); roomr.reserve(h);\n    for (int i=0; i<h; i++) {\n      string l, r;\n      cin >> l >> r; \n      reverse(r.begin(), r.end());\n      rooml.push_back(l);\n      roomr.push_back(r);\n    }\n    Pos len_pos = search_charactor(rooml, 'L');\n    Pos rin_pos = search_charactor(roomr, 'R');\n    Pos len_goal = search_charactor(rooml, '%');\n    Pos rin_goal = search_charactor(roomr, '%');\n\n    queue<pair<Pos, Pos>> q;\n    q.push(make_pair(len_pos, rin_pos));\n    // cout<<\"goal: (\"<<len_goal.x<<\", \"<<len_goal.y<<\") \"<<\"(\"<<rin_goal.x<<\", \"<<rin_goal.y<<\")\"<<endl;\n    // for (int i=0; i<rooml.size(); i++) {\n    //   cout << rooml[i] << \" \" << roomr[i] << endl;\n    // }\n\n    V<V<V<V<bool>>>> already(h, V<V<V<bool>>>(w, V<V<bool>>(h, V<bool>(w, false))));\n    bool f = true;\n    while (!q.empty()) {\n      Pos len = q.front().first;\n      Pos rin = q.front().second; \n      q.pop();\n      // cout<<\"(\"<<len.x<<\", \"<<len.y<<\") \"<<\"(\"<<rin.x<<\", \"<<rin.y<<\")\"<<endl;\n\n      if (len==len_goal && rin==rin_goal) {\n        cout << \"Yes\" << endl;\n        f = false;\n        break;\n      }\n\n      for (Pos np: {Pos(0,1), Pos(0,-1), Pos(1,0), Pos(-1,0)}) {\n        Pos l = (inner(np+len) && rooml[np.y+len.y][np.x+len.x] == '.') ? len + np : len;\n        Pos r = (inner(np+rin) && roomr[np.y+rin.y][np.x+rin.x] == '.') ? rin + np : rin;\n        if (!already[l.y][l.x][r.y][r.x] && inner(l) && inner(r) \n          && rooml[l.y][l.x] == '.' && roomr[r.y][r.x] == '.'\n          && (l==len_goal xor r==rin_goal)) {\n          q.push(make_pair(l, r));\n          already[l.y][l.x][r.y][r.x] = true;\n        }\n      }\n    }\n    if (f) cout << \"No\" << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\n#include <stack>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\ntypedef vector<string> vs;\ntypedef vector<int> vi;\n\n#define rep(i,b) loop(i,0,b)\n#define loop(i,a,b) for(int i=(a); i<int(b); i++)\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nint h,w;\ninline bool in(int x, int y){\n    return 0<=x && 0<=y && x<w && y<h;\n}\n\nbool solve(vs const& g1, vs const& g2){\n    int sx1, sy1, sx2, sy2;\n    rep(i,h)rep(j,w){\n        if(g1[i][j]=='L'){\n            sx1=j;sy1=i;\n        }\n        if(g2[i][j]=='R'){\n            sx2=j;sy2=i;\n        }\n    }\n    queue<vi> q;\n    static bool vis[64][64][64][64];\n    memset(vis,0,sizeof(vis));\n    q.push(vi{sx1,sy1,sx2,sy2});\n\n    while(q.size()){\n        vi s=q.front();q.pop();\n        int x1=s[0],y1=s[1],x2=s[2],y2=s[3];\n        if(vis[x1][y1][x2][y2])continue;\n        vis[x1][y1][x2][y2]=true;\n        if(g1[y1][x1]=='%' && g2[y2][x2]=='%') return true;\n        if((g1[y1][x1]=='%')^(g2[y2][x2]=='%')) continue;\n\n        rep(d,4){\n            int nx1=x1+dx[d],ny1=y1+dy[d];\n            int nx2,ny2;\n            if(d&1){\n                nx2=x2+dx[d],ny2=y2+dy[d];\n            }else{\n                nx2=x2-dx[d],ny2=y2-dy[d];\n            }\n            if(!in(nx1,ny1) || g1[ny1][nx1]=='#')nx1=x1,ny1=y1;\n            if(!in(nx2,ny2) || g2[ny2][nx2]=='#')nx2=x2,ny2=y2;\n            q.push(vi{nx1,ny1,nx2,ny2});\n        }\n    }\n    return false;    \n}\n\nint main(){\n    while(cin>>w>>h && w|h){\n        vs g1(h), g2(h);\n        rep(i,h) cin>>g1[i]>>g2[i];\n        vs ans{\"NO\",\"YES\"};\n        cout << ans[solve(g1,g2)] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<char,char> P;\n\nstruct state{\n\tP p1, p2;\n\tstate(P p1_, P p2_){ p1 = p1_; p2 = p2_; }\n};\nint w, h;\nint dx1[4] = {0,-1,1,0};\nint dy1[4] = {-1,0,0,1};\nint dx2[4] = {0,1,-1,0};\nint dy2[4] = {-1,0,0,1};\nbool flag[51][51][51][51];\nchar L[51][51];\nchar R[51][51];\n\nvoid init(){\n\tfor(int i=0 ; i < 51 ; i++ ){\n\t\tfor(int j=0 ; j < 51 ; j++ ){\n\t\t\tfor(int k=0 ; k < 51 ; k++ ){\n\t\t\t\tfor(int l=0 ; l < 51 ; l++ ){\n\t\t\t\t\tflag[i][j][k][l] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// デバッグ用\ntemplate <class T>\nvoid debug(T v, string s){\n\tcout << s << endl;\n\tfor(int y=0 ; y < v.size() ; y++ ){\n\t\tcout << v[y] << endl;\n\t}\n\tcout << endl;\n}\n\n// vs から vs[y][x] == c となる (x,y) を返す\nP search(vector<string>& vs, char c){\n\tfor(int y=0 ; y < vs.size() ; y++ ){\n\t\tfor(int x=0 ; x < vs[y].size() ; x++ ){\n\t\t\tif( vs[y][x] == c ){\n\t\t\t\tvs[y][x] = '.';\n\t\t\t\treturn P(x,y);\n\t\t\t}\n\t\t}\n\t}\n\treturn P(0,0);\n}\n\nbool bfs(vector<string>& L, vector<string>& R){\n\tP ls = search( L , 'L' );\n\tP rs = search( R , 'R' );\n\t//debug( L , \"[Left]\" );\n\t//debug( R , \"[right]\" );\n\t\n\tqueue< pair<P,P> > q;\n\tpair<P,P> s( ls , rs );\n\tq.push( s );\n\t\n\twhile( !q.empty() ){\n\t\tpair<P,P> now = q.front(); q.pop();\n\t\tint x1 = now.first.first;\n\t\tint y1 = now.first.second;\n\t\tint x2 = now.second.first;\n\t\tint y2 = now.second.second;\n\t\tflag[y1][x1][y2][x2] = true;\n\t\tif( L[y1][x1] == '%' && R[y2][x2] == '%' ){\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\tint mx1 = x1 + dx1[i];\n\t\t\tint my1 = y1 + dy1[i];\n\t\t\tif( mx1 < 0 || my1 < 0 || mx1 >= w || my1 >= h || L[my1][mx1] == '#' ){\n\t\t\t\tmx1 = x1;\n\t\t\t\tmy1 = y1;\n\t\t\t}\n\t\t\tint mx2 = x2 + dx2[i];\n\t\t\tint my2 = y2 + dy2[i];\n\t\t\tif( mx2 < 0 || my2 < 0 || mx2 >= w || my2 >= h || R[my2][mx2] == '#' ){\n\t\t\t\tmx2 = x2;\n\t\t\t\tmy2 = y2;\n\t\t\t}\n\t\t\tP p1(mx1,my1);\n\t\t\tP p2(mx2,my2);\n\t\t\tpair<P,P> next(p1,p2);\n\t\t\tif( flag[my1][mx1][my2][mx2] ){\n\t\t\t\tcontinue;\n\t\t\t}else if( L[my1][mx1] == '%' && R[my2][mx2] != '%' ){\n\t\t\t\tflag[my1][mx1][my2][mx2] = true;\n\t\t\t}else if( L[my1][mx1] != '%' && R[my2][mx2] == '%' ){\n\t\t\t\tflag[my1][mx1][my2][mx2] = true;\n\t\t\t}else{\n\t\t\t\tq.push( next );\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\twhile( cin >> w >> h, w || h ){\n\t\t/*init();\n\t\tvector<string> L(h), R(h);\n\t\t\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tcin >> L[y];\n\t\t\tcin >> R[y];\n\t\t}\n\t\tbool ans = bfs( L , R );\n\t\tif( ans )\n\t\t\tcout << \"Yes\" << endl;\n\t\telse\n\t\t\tcout << \"No\" << endl;*/\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define HMAX 30\n#define WMAX 30\nusing namespace std;\n\ntypedef pair <int,int> pii;\n#define X first\n#define Y second\n\nint w,h;\nint dl[8]={0,1,0,-1,1,0,-1,0};\nint dr[8]={0,-1,0,1,1,0,-1,0};\nchar lmap[WMAX][HMAX];\nchar rmap[WMAX][HMAX];\n\nvoid dfs_aux(bool *flag, const pii l, const pii r){\n  if(*flag)\n    return;\n  \n  if(lmap[l.X][l.Y]=='%' && rmap[r.X][r.Y]=='%'){\n    *flag = true;\n    return;\n  }\n\n  rep(i,4){\n    char ltmp=lmap[l.X][l.Y],rtmp=rmap[r.X][r.Y];\n\n    pii nl=l,nr=r;\n\n    if(0<=l.X+dl[i] && l.X+dl[i]<w && 0<=l.Y+dl[i+4] && l.Y+dl[i+4]<h)\n      if(lmap[l.X+dl[i]][l.Y+dl[i+4]]!='#'){\n\tnl.X += dl[i];\n\tnl.Y += dl[i+4];\n\tlmap[l.X][l.Y]='#';\n      }\n    \n    if(0<=r.X+dr[i] && r.X+dr[i]<w && 0<=r.Y+dr[i+4] && r.Y+dr[i+4]<h)\n      if(rmap[r.X+dr[i]][r.Y+dr[i+4]]!='#'){\n\tnr.X += dr[i];\n\tnr.Y += dr[i+4];\n\trmap[r.X][r.Y]='#';\n      }\n    \n    if(l==nl && r==nr){\n      lmap[l.X][l.Y] = ltmp;\n      rmap[r.X][r.Y] = rtmp;\n      continue;\n    }\n    \n    dfs_aux(flag,nl,nr);\n    \n    lmap[l.X][l.Y] = ltmp;\n    rmap[r.X][r.Y] = rtmp;\n  }\n  if(*flag)\n    return;\n}\n\nbool dfs(pii l, pii r){\n  bool flag = false;\n  dfs_aux(&flag,l,r);\n  return flag;\n}\n\nint main(){\n  for(;;){\n    scanf(\"%d %d\",&w,&h);\n    if(!(w+h)) break;\n    pii l,r;\n    rep(i,h){\n      rep(j,w){\n\tcin >> lmap[j][i];\n\tif(lmap[j][i]=='L')\n\t  l = pii(j,i);\n      }\n      rep(j,w){\n\tcin >> rmap[j][i];\n\tif(rmap[j][i]=='R')\n\t  r = pii(j,i);\n      }\n    }\n    printf(\"%s\\n\",dfs(l,r)?\"Yes\":\"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <stack>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\ntypedef vector<string> vs;\ntypedef vector<int> vi;\n\n#define rep(i,b) loop(i,0,b)\n#define loop(i,a,b) for(int i=(a); i<int(b); i++)\n#define all(c) (c).begin(), (c).end()\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nint h,w;\ninline bool in(int x, int y){\n    return 0<=x && 0<=y && x<w && y<h;\n}\n\nvi id{0,1,2,3};\nbool solve(vs const& g1, vs const& g2){\n    int sx1, sy1, sx2, sy2;\n    rep(i,h)rep(j,w){\n        if(g1[i][j]=='L'){\n            sx1=j;sy1=i;\n        }\n        if(g2[i][j]=='R'){\n            sx2=j;sy2=i;\n        }\n    }\n    queue<vi> q;\n    static bool vis[64][64][64][64];\n    memset(vis,0,sizeof(vis));\n    q.push(vi{sx1,sy1,sx2,sy2});\n    while(q.size()){\n        vi s=q.front();q.pop();\n        int x1=s[0],y1=s[1],x2=s[2],y2=s[3];\n        if(vis[x1][y1][x2][y2])continue;\n        vis[x1][y1][x2][y2]=true;\n        if(g1[y1][x1]=='%' && g2[y2][x2]=='%') return true;\n        if(g1[y1][x1]=='%' || g2[y2][x2]=='%') continue;\n\n        random_shuffle(all(id));\n        rep(i,4){\n            int d=id[i];\n            int nx1=x1+dx[d],ny1=y1+dy[d];\n            int nx2,ny2;\n            if(d&1){\n                nx2=x2+dx[d],ny2=y2+dy[d];\n            }else{\n                nx2=x2-dx[d],ny2=y2-dy[d];\n            }\n            if(!in(nx1,ny1) || g1[ny1][nx1]=='#')nx1=x1,ny1=y1;\n            if(!in(nx2,ny2) || g2[ny2][nx2]=='#')nx2=x2,ny2=y2;\n            q.push(vi{nx1,ny1,nx2,ny2});\n        }\n    }\n    return false;    \n}\n\nint main(){\n    while(cin>>w>>h && w|h){\n        vs g1(h), g2(h);\n        rep(i,h) cin>>g1[i]>>g2[i];\n        vs ans{\"No\",\"Yes\"};\n        cout << ans[solve(g1,g2)] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nint w, h;\nstring sl[50], sr[50];\nbool vis[2500][2500];\nP ls, rs, lg, rg;\nint dxl[] = {1, 0, -1, 0};\nint dxr[] = {-1, 0, 1, 0};\nint dy[] = {0, 1, 0, -1};\n\nbool range(int x, int y) {\n    return 0 <= x && x < w && 0 <= y && y < h;\n}\n\nbool dfs(P l, P r) {\n    if (l == lg && r == rg) return true;\n    else if (l == lg || r == rg) return false;\n\n    vis[l.fi * 50 + l.se][r.fi * 50 + r.se] = true;\n    bool ok = false;\n    rep(i, 4) {\n        int lx = l.se + dxl[i], ly = l.fi + dy[i];\n        if (!range(lx, ly) || (range(lx, ly) && sl[ly][lx] == '#')) lx = l.se, ly = l.fi;\n        int rx = r.se + dxr[i], ry = r.fi + dy[i];\n        if (!range(rx, ry) || (range(lx, ly) && sr[ry][rx] == '#')) rx = r.se, ry = r.fi;\n        if (!vis[ly * 50 + lx][ry * 50 + rx]) {\n            ok |= dfs(P(ly, lx), P(ry, rx));\n        }\n    }\n    return ok;\n}\n\nint main(){\n    cin.sync_with_stdio(false);\n    while(cin >> w >> h, w | h) {\n        memset(vis, 0, sizeof(vis));\n\n        rep(i, h) {\n            cin >> sl[i] >> sr[i];\n            rep(j, w) {\n                if (sl[i][j] == 'L') ls = P(i, j);\n                if (sr[i][j] == 'R') rs = P(i, j);\n                if (sl[i][j] == '%') lg = P(i, j);\n                if (sr[i][j] == '%') rg = P(i, j);\n            }\n        }\n\n        cout << (dfs(ls, rs) ? \"Yes\" : \"No\") << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <string.h>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <set>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\n#define For(i,a,n)\tfor(int i = a;i < n;i++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(n)\t\tmemset(n,0,sizeof n)\n#define all(n)\t\t(n).begin(),(n).end()\n\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\ntypedef pair<P, P> WP;\ntypedef long long ll;\n\nconst ll INF = 1e9;\nint dx[4] = { 0, 1, 0, -1 }, dy[4] = { 1, 0, -1, 0 };\nbool cheak(int x, int y, int mx, int my){\n\treturn x >= 0 && y >= 0 && x < mx &&  y < my;\n}\n\nstring s[2][51];\n\nint d[51][51][51][51];\n\nint main()\n{\n\tint w, h;\n\n\twhile (cin >> w >> h && w){\n\t\tclr(d);\n\t\tint sx[2], sy[2];\n\t\tint gx[2], gy[2];\n\t\trep(y, h){\n\t\t\tcin >> s[0][y] >> s[1][y];\n\t\t\trep(x, w){\n\t\t\t\tif (s[0][y][x] == '%')gx[0] = x, gy[0] = y;\n\t\t\t\tif (s[1][y][x] == '%')gx[1] = x, gy[1] = y;\n\t\t\t\tif (s[0][y][x] == 'L')sx[0] = x, sy[0] = y;\n\t\t\t\tif (s[1][y][x] == 'R')sx[1] = x, sy[1] = y;\n\t\t\t}\n\t\t}\n\t\td[sy[0]][sx[0]][sy[1]][sx[1]] = 1;\n\n\t\tqueue<P> q0, q1;\n\t\tq0.push(P(sy[0], sx[0]));\n\t\tq1.push(P(sy[1], sx[1]));\n\n\t\twhile (q0.size()){\n\t\t\tint ly = q0.front().first, lx = q0.front().second;\n\t\t\tint ry = q1.front().first, rx = q1.front().second;\n\t\t\tq0.pop(), q1.pop();\n\n\t\t\trep(i, 4){\n\t\t\t\tint nlx = lx + dx[i], nly = ly + dy[i];\n\t\t\t\tint nrx = rx - dx[i], nry = ry + dy[i];\n\n\t\t\t\tbool lf = (cheak(nlx, nly, w, h) && s[0][nly][nlx] != '#');\n\t\t\t\tbool rf = (cheak(nrx, nry, w, h) && s[1][nry][nrx] != '#');\n\n\t\t\t\tif ((rf || lf)){\n\t\t\t\t\tif (!lf)nlx = lx, nly = ly;\n\t\t\t\t\tif (!rf)nrx = rx, nry = ry;\n\t\t\t\t\tif (!d[nly][nlx][nry][nrx]){\n\n\t\t\t\t\t\tif (s[0][nly][nlx] == '%' || s[1][nry][nrx] == '%'){\n\t\t\t\t\t\t\tif (!(s[0][nly][nlx] == '%') || !(s[1][nry][nrx] == '%')){\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\td[nly][nlx][nry][nrx] = 1;\n\t\t\t\t\t\tq0.push(P(nly, nlx));\n\t\t\t\t\t\tq1.push(P(nry, nrx));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[gy[0]][gx[0]][gy[1]][gx[1]])cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,n1,n2) for(int i=n1;i<n2;i++)\n#define bFOR(i,n1,n2) for(int i=n1;i>=n2;i--)\n#define speed_up    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\ntypedef long long int ll;\ntypedef pair<ll,ll> Pi;\nconst int INF=(ll)(1LL<<30)-1;\nconst double INFd=100000000000.0;\nconst ll INFl=(ll)9223372036854775807;\nconst int MAX=10000;\nconst ll MOD=(ll)1e9+7;\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a, b)*b;}\nint dx[4]={0,-1,0,1},dy[4]={-1,0,1,0};\nint mdx[4]={0,1,0,-1},mdy[4]={-1,0,1,0};\n\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\nint w,h;\nchar l[55][55],r[55][55];\nint alr[55][55][55][55];\nint lsy,lsx,rsy,rsx,ley,lex,rey,rex;\n\nint main(){\n\twhile(1){\n\t\tcin>>w>>h;\n\t\tif(w==0&&h==0)break;\n\t\tREP(i,55)\n\t\t\tREP(j,55)\n\t\t\t\tREP(k,55)\n\t\t\t\t\tREP(l,55)\n\t\t\t\t\talr[i][j][k][l]=0;\n\t\tREP(i,h){\n\t\t\tREP(j,w){\n\t\t\t\tcin>>l[i][j];\n\t\t\t\tif(l[i][j]=='%'){\n\t\t\t\t\tley=i;\n\t\t\t\t\tlex=j;\n\t\t\t\t}else if(l[i][j]=='L'){\n\t\t\t\t\tlsy=i;\n\t\t\t\t\tlsx=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(j,w){\n\t\t\t\tcin>>r[i][j];\n\t\t\t\tif(r[i][j]=='%'){\n\t\t\t\t\trey=i;\n\t\t\t\t\trex=j;\n\t\t\t\t}else if(r[i][j]=='R'){\n\t\t\t\t\trsy=i;\n\t\t\t\t\trsx=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<pair<Pi,Pi>> qq;\n\t\tqq.push(pair<Pi,Pi>(Pi(lsy,lsx),Pi(rsy,rsx)));\n\t\talr[lsy][lsx][rsy][rsx]=1;\n\t\tint ans=0;\n\t\twhile(qq.size()){\n\t\t\tpair<Pi,Pi> p1=qq.front();qq.pop();\n\t\t\tint ly=p1.first.first;\n\t\t\tint lx=p1.first.second;\n\t\t\tint ry=p1.second.first;\n\t\t\tint rx=p1.second.second;\n\t\t\t//cout<<ly<<\" \"<<lx<<\" \"<<ry<<\" \"<<rx<<endl;\n\t\t\tif(ly==ley&&lx==lex&&ry==rey&&rx==rex){\n\t\t\t\tans=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif((ly==ley&&lx==lex)||(ry==rey&&rx==rex)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nly=ly+dy[i];\n\t\t\t\tint nlx=lx+dx[i];\n\t\t\t\tif(!(0<=nly&&nly<h&&0<=nlx&&nlx<w&&l[nly][nlx]!='#')){\n\t\t\t\t\tnly=ly;\n\t\t\t\t\tnlx=lx;\n\t\t\t\t}\n\t\t\t\tint nry=ry+mdy[i];\n\t\t\t\tint nrx=rx+mdx[i];\n\t\t\t\tif(!(0<=nry&&nry<h&&0<=nrx&&nrx<w&&r[nry][nrx]!='#')){\n\t\t\t\t\tnry=ry;\n\t\t\t\t\tnrx=rx;\n\t\t\t\t}\n\t\t\t\tif(!alr[nly][nlx][nry][nrx]){\n\t\t\t\t\tqq.push(pair<Pi,Pi>(Pi(nly,nlx),Pi(nry,nrx)));\n\t\t\t\t\talr[nly][nlx][nry][nrx]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans)cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n\treturn 0;\n}\n\t\t\t\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n\n#define ll long long int\n\nusing namespace std;\n\nconst int INF = (1<<30) - 1;\n\n//lh, lw, rh, rw\ntypedef tuple<int, int, int, int> State;\n\nint dh[] = {0, 1, 0, -1};\nint dw[] = {1, 0, -1, 0};\n\nint dp[50][50][50][50];\n\nbool solve(vector<string> &L, vector<string> &R){\n    int H = L.size();\n    int W = L[0].size();\n    \n    memset(dp, 0, sizeof(dp));\n    queue<State> que;\n    \n    int lh, lw, rh, rw;\n    int glh, glw, grh, grw;\n    for(int h=0; h<H; h++){\n        for(int w=0; w<W; w++){\n            if(L[h][w] == 'L'){\n                lh = h; lw = w;\n            }else if(L[h][w] == '%'){\n                glh = h; glw = w;\n            }\n        }\n    }\n    for(int h=0; h<H; h++){\n        for(int w=0; w<W; w++){\n            if(R[h][w] == 'R'){\n                rh = h; rw = w;\n            }else if(R[h][w] == '%'){\n                grh = h; grw = w;\n            }\n        }\n    }\n    auto start = State(lh, lw, rh, rw);\n    dp[lh][lw][rh][rw] = true;\n    que.push(start);\n    \n    while(!que.empty()){\n        tie(lh, lw, rh, rw) = que.front(); que.pop();\n        \n        for(int i=0; i<4; i++){\n            int nlh = lh + dh[i], nlw = lw + dw[i];\n            int nrh = rh + dh[i], nrw = rw + dw[i] * -1;\n            \n            if(nlh<0 || H<=nlh || nlw<0 || W<=nlw || L[nlh][nlw]=='#'){\n                nlh = lh; nlw = lw;\n            }\n            if(nrh<0 || H<=nrh || nrw<0 || W<=nrw || R[nrh][nrw]=='#'){\n                nrh = rh; nrw = rw;\n            }\n            \n            State next = State(nlh, nlw, nrh, nrw);\n            \n            if(nlh == glh && nlw == glw && nrh == grh && nrw == grw)\n                return true;\n            \n            if(!dp[nlh][nlw][nrh][nrw] && (nlh!=glh || nlw!=glw) && (nrh!=grh || nrw!=grw)){\n                dp[nlh][nlw][nrh][nrw] = true;\n                que.push(next);\n            }\n        }\n    }\n    return false;\n}\n\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    int H, W;\n    while(cin>>W>>H, H|W){\n        vector<string> L(H), R(H);\n        for(int i=0; i<H; i++)\n            cin >> L[i] >> R[i];\n        \n        cout << (solve(L, R) ? \"Yes\" : \"No\") << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint w, h;\nstring l[51], r[51];\nint ldx[4] = {1, 0, -1, 0};\nint ldy[4] = {0, 1, 0, -1};\nint rdx[4] = {1, 0, -1, 0};\nint rdy[4] = {0, -1, 0, 1};\nint lsx, lsy, rsx, rsy, lgx, lgy, rgx, rgy;\nbool ischecked[52][52][52][52];\n\nbool solve(int lx, int ly, int rx, int ry){\n    queue<int> rxqu, ryqu, lxqu, lyqu;\n    rxqu.push(rx);\n    ryqu.push(ry);\n    lxqu.push(lx);\n    lyqu.push(ly);\n    while(!rxqu.empty()){\n        lx = lxqu.front();\n        ly = lyqu.front();\n        rx = rxqu.front();\n        ry = ryqu.front();\n        lxqu.pop();\n        lyqu.pop();\n        rxqu.pop();\n        ryqu.pop();\n        if(lx == lgx && ly == lgy && rx == rgx && ry == rgy) return true;\n        if((lx == lgx && ly == lgy) || (rx == rgx && ry == rgy)) continue;\n        for(int i = 0; i < 4; i++){\n            int nlx = lx + ldx[i], nly = ly + ldy[i];\n            int nrx = rx + rdx[i], nry = ry + rdy[i];\n            if((nlx < 0 || nly < 0 || nlx >= h || nly >= w) && (nrx < 0 || nry < 0 || nrx >= h || nry >= w)) continue;\n            if(nlx < 0 || nlx >= h || nly < 0 || nly >= w){\n                nlx = lx;\n                nly = ly;\n            }\n            if(nrx < 0 || nrx >= h || nry < 0 || nry >= w){\n                nrx = rx;\n                nry = ry;\n            }\n            if((l[nlx][nly] == '#' && r[nrx][nry] == '#') || ischecked[nlx][nly][nrx][nry]) continue;\n            if(l[nlx][nly] == '#'){\n                nlx = lx;\n                nly = ly;\n            }\n            if(r[nrx][nry] == '#'){\n                nrx = rx;\n                nry = ry;\n            }\n            ischecked[nlx][nly][nrx][nry] = true;\n            rxqu.push(nrx);\n            ryqu.push(nry);\n            lxqu.push(nlx);\n            lyqu.push(nly);\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    while(1){\n        cin >> w >> h;\n        if(w == 0 && h == 0) break;\n        for(int i = 0; i < h; i++){\n            cin >> l[i] >> r[i];\n        }\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                for(int k = 0; k < h; k++){\n                    for(int l = 0; l < w; l++){\n                        ischecked[i][j][k][l] = false;\n                    }\n                }\n                if(l[i][j] == 'L'){\n                    lsx = i;\n                    lsy = j;\n                }\n                if(l[i][j] == '%'){\n                    lgx = i;\n                    lgy = j;\n                }\n                if(r[i][j] == 'R'){\n                    rsx = i;\n                    rsy = j;\n                }\n                if(r[i][j] == '%'){\n                    rgx = i;\n                    rgy = j;\n                }\n            }\n        }\n        ischecked[lsx][lsy][rsx][rsy] = true;\n        if(solve(lsx, lsy, rsx, rsy)) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nbool can_go;\nbool used[51][51][51][51];\nstring s0[51],s1[51];\nint h,w;\nint c_x(int x){\n  if(x<0)x=0;\n  if(x>=h)x=h-1;\n  return x;\n}\nint c_y(int y){\n  if(y<0)y=0;\n  if(y>=w)y=w-1;\n  return y;\n}\nstruct pt{\n  int x,y,rx,ry;\n  pt(int a,int b,int c,int d){\n    x=a;\n    y=b;\n    rx=c;\n    ry=d;\n  }\n};\nvoid search(int lX,int lY,int rX,int rY){\n  queue<pt> que;\n  int x,y,rx,ry;\n  que.push(pt(lX,lY,rX,rY));\n  while(!que.empty()){\n    pt tmp=que.front();\n    que.pop();\n    x=tmp.x;\n    y=tmp.y;\n    rx=tmp.rx;\n    ry=tmp.ry;\n    if(used[x][y][rx][ry]) continue;\n    if(s0[x][y]=='%'&&s1[rx][ry]=='%'){\n      can_go=true;\n      break;\n    }\n    if(s0[x][y]=='%'||s1[rx][ry]=='%'){\n      continue;\n    }\n    int X,Y,RX,RY;\n    used[x][y][rx][ry]=true;\n    if(x>0&&s0[x-1][y]=='#')X=x;\n    else X=c_x(x-1);\n    if(rx>0&&s1[rx-1][ry]=='#')RX=rx;\n    else RX=c_x(rx-1);\n    que.push(pt(X,y,RX,ry));\n\n    if(x<h-1&&s0[x+1][y]=='#')X=x;\n    else X=c_x(x+1);\n    if(rx<h-1&&s1[rx+1][ry]=='#')RX=rx;\n    else RX=c_x(rx+1);\n    que.push(pt(X,y,RX,ry));\n\n    if(y>0&&s0[x][y-1]=='#')Y=y;\n    else Y=c_y(y-1);\n    if(ry<w-1&&s1[rx][ry+1]=='#')RY=ry;\n    else RY=c_y(ry+1);\n    que.push(pt(x,Y,rx,RY));\n\n    if(y<w-1&&s0[x][y+1]=='#')Y=y;\n    else Y=c_y(y+1);\n    if(ry>0&&s1[rx][ry-1]=='#')RY=ry;\n    else RY=c_y(ry-1);\n    que.push(pt(x,Y,rx,RY));\n  }\n}\nint main(){\n  int rx,ry,lx,ly;\n  cin >> w >> h;\n  while(w!=0){\n    can_go=false;\n    for(int i=0;i<h;i++){\n      cin >> s0[i];\n      cin >> s1[i];\n      for(int j=0;j<w;j++){\n        if(s0[i][j]=='L'){\n          lx=i;\n          ly=j;\n        }\n        if(s1[i][j]=='R'){\n          rx=i;\n          ry=j;\n        }\n        for(int k=0;k<h;k++){\n          for(int l=0;l<w;l++){\n            used[i][j][k][l]=false;\n          }\n        }\n      }\n    }\n    search(lx,ly,rx,ry);\n    if(can_go) cout <<\"Yes\\n\";\n    else cout <<\"No\\n\";\n    cin >> w >> h;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\nusing namespace std;\n\nstruct state{ int lx,ly,rx,ry; };\n\nint dx[] = {0,1,0,-1},dy[] = {1,0,-1,0};\n\nbool dp[50][50][50][50];\n\nint main(){\n\tint h,w;\n\twhile(cin >> w >> h,h){\n\t\tint lx,ly,rx,ry;\n\t\tfor(int i = 0;i < 50;i++){\n\t\t\tfor(int j = 0;j < 50;j++){\n\t\t\t\tfor(int k = 0;k < 50;k++){\n\t\t\t\t\tfor(int l = 0;l < 50;l++) dp[i][j][k][l] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool flag = false;\n\t\tstring lf[50],rf[50];\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tcin >> lf[i] >> rf[i];\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(lf[i][j] == 'L'){\n\t\t\t\t\tlx = i;\n\t\t\t\t\tly = j;\n\t\t\t\t}\n\t\t\t\tif(rf[i][j] == 'R'){\n\t\t\t\t\trx = i;\n\t\t\t\t\try = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<state> que;\n\t\tque.push({lx,ly,rx,ry});\n\t\twhile(!que.empty()){\n\t\t\tstate s = que.front();que.pop();\n\t\t\tif(dp[s.lx][s.ly][s.rx][s.ry]) continue;\n\t\t\t//cout << s.lx << \" \" << s.ly << \" \" << s.rx << \" \" << s.ry << endl;\n\t\t\tif(lf[s.lx][s.ly] == '%' && rf[s.rx][s.ry] == '%') flag = true;\n\t\t\tdp[s.lx][s.ly][s.rx][s.ry] = true;\n\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\tint nlx = s.lx + dx[i],nly = s.ly + dy[i],nrx = s.rx + dx[i],nry = s.ry + dy[(i + 2) % 4];\n\t\t\t\tbool move = false;\n\t\t\t\tif(nlx >= 0 && nlx < h && nly >= 0 && nly < w && lf[nlx][nly] != '#') move = true;\n\t\t\t\telse{\n\t\t\t\t\tnlx = s.lx;\n\t\t\t\t\tnly = s.ly;\n\t\t\t\t}\n\t\t\t\tif(nrx >= 0 && nrx < h && nry >= 0 && nry < w && rf[nrx][nry] != '#') move = true;\n\t\t\t\telse{\n\t\t\t\t\tnrx = s.rx;\n\t\t\t\t\tnry = s.ry;\n\t\t\t\t}\n\t\t\t\tif((lf[nlx][nly] == '#') ^ (rf[nrx][nry] == '#')) continue;\n\t\t\t\tif(move && !dp[nlx][nly][nrx][nry]){\n\t\t\t\t\tque.push({nlx,nly,nrx,nry});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<queue>\nconst int N=52,dx[]={0,1,0,-1,0};\nchar L[N][N],R[N][N];\nstruct S{int lx,ly,rx,ry;}s,t;\nint F()\n{\n\tstatic int b[N][N][N][N];\n\tmemset(b,0,sizeof(b));\n\tstd::queue<S>q;\n\tq.push(s);\n\tchar l,r,i;\n\twhile(q.size())\n\t{\n\t\ts=q.front(),q.pop();\n\t\tif(b[s.ly][s.lx][s.ry][s.rx])continue;\n\t\tb[s.ly][s.lx][s.ry][s.rx]=1;\n\t\tl=L[s.ly][s.lx];\n\t\tr=R[s.ry][s.rx];\n\t\tif(l=='%'&&r=='%')return 1;\n\t\tif(l=='%'||r=='%')continue;\n\t\tfor(i=0;i<4;++i)\n\t\t{\n\t\t\tt=s;\n\t\t\tif(L[t.ly+=dx[i+1]][t.lx+=dx[i]]=='#')t=s;\n\t\t\tif(R[t.ry+=dx[i+1]][t.rx-=dx[i]]=='#')t.rx=s.rx, t.ry=s.ry;\n\t\t\tq.push(t);\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tint h,w,i;\n\tchar*p;\n\twhile(scanf(\"%d%d\",&w,&h),w)\n\t{\n\t\tfor(i=1;i<=h;++i)\n\t\t{\n\t\t\tscanf(\"%s%s\",L[i]+1,R[i]+1);\n\t\t\tif(p=strchr(L[i]+1,'L'))s.lx=p-L[i],s.ly=i;\n\t\t\tif(p=strchr(R[i]+1,'R'))s.rx=p-R[i],s.ry=i;\n\t\t}\n\t\tfor(i=0;i<h+2;++i)L[i][0]=L[i][w+1]=R[i][0]=R[i][w+1]='#';\n\t\tfor(i=0;i<w+2;++i)L[0][i]=L[h+1][i]=R[0][i]=R[h+1][i]='#';\n\t\tputs(F()?\"Yes\":\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nstruct Node {\n  Node(int lx, int ly, int rx, int ry) {\n    this->lx = lx;\n    this->ly = ly;\n    this->rx = rx;\n    this->ry = ry;\n  }\n\n  int val() {\n    return lx * 8000000 + ly * 40000 + rx * 200 + ry;\n  }\n\n  int lx;\n  int ly;\n  int rx;\n  int ry;\n};\n\nint main() {\n  vector<vector<char> > f(103);\n  for (int i = 0; i < f.size(); i++) {\n    f[i].resize(52);\n  }\n\n  while (true) {\n    int W, H;\n    cin >> W >> H;\n\n    if (W == 0) {\n      break;\n    }\n\n    int cw = W + 1;\n    int w = W * 2 + 3;\n    int h = H + 2;\n    for (int i = 0; i < w; i++) {\n      f[i][0] = f[i][h - 1] = '#';\n    }\n    for (int i = 0; i < h; i++) {\n      f[0][i] = f[cw][i] = f[w - 1][i] = '#';\n    }\n\n    int lx = 0, ly = 0;\n    int rx = 0, ry = 0;\n    for (int i = 1; i < h - 1; i++) {\n      for (int j = 1; j < cw; j++) {\n\tcin >> f[j][i];\n\tif (f[j][i] == 'L') {\n\t  lx = j;\n\t  ly = i;\n\t  f[j][i] = '.';\n\t}\n      }\n      for (int j = cw + 1; j < w - 1; j++) {\n\tcin >> f[j][i];\n\tif (f[j][i] == 'R') {\n\t  rx = j;\n\t  ry = i;\n\t  f[j][i] = '.';\n\t}\n      }\n    }\n    \n    set<int> s;\n    queue<Node> q;\n    q.push(Node(lx, ly, rx, ry));\n    s.insert(q.front().val());\n    while (!q.empty()) {\n      Node n = q.front();\n      /*\n      for (int i = 0; i < h; i++) {\n\tfor (int j = 0; j < w; j++) {\n\t  cout << (n.lx == j && n.ly == i ? 'L' :\n\t\t   n.rx == j && n.ry == i ? 'R' : f[j][i]);\n\t}\n\tcout << endl;\n      }\n      */\n      if (f[n.lx][n.ly] == '%' && f[n.rx][n.ry] == '%') {\n\tcout << \"Yes\" << endl;\n\tbreak;\n      }\n      q.pop();\n\n      if (f[n.lx][n.ly] == '%' || f[n.rx][n.ry] == '%') {\n\tcontinue;\n      }\n\n      Node nn(n.lx, f[n.lx][n.ly - 1] != '#' ? n.ly - 1 : n.ly,\n\t      n.rx, f[n.rx][n.ry - 1] != '#' ? n.ry - 1 : n.ry);\n\n      if (s.count(nn.val()) == 0) {\n\tq.push(nn);\n\ts.insert(nn.val());\n      }\n\n      Node we(f[n.lx - 1][n.ly] != '#' ? n.lx - 1 : n.lx, n.ly,\n\t      f[n.rx + 1][n.ry] != '#' ? n.rx + 1 : n.rx, n.ry);\n\n      if (s.count(we.val()) == 0) {\n\tq.push(we);\n\ts.insert(we.val());\n      }\n\n      Node ew(f[n.lx + 1][n.ly] != '#' ? n.lx + 1 : n.lx, n.ly,\n\t      f[n.rx - 1][n.ry] != '#' ? n.rx - 1 : n.rx, n.ry);\n\n      if (s.count(ew.val()) == 0) {\n\tq.push(ew);\n\ts.insert(ew.val());\n      }\n\n      Node ss(n.lx, f[n.lx][n.ly + 1] != '#' ? n.ly + 1 : n.ly,\n\t      n.rx, f[n.rx][n.ry + 1] != '#' ? n.ry + 1 : n.ry);\n\n      if (s.count(ss.val()) == 0) {\n\tq.push(ss);\n\ts.insert(ss.val());\n      }\n    }\n\n    if (q.empty()) {\n      cout << \"No\" << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n\n#define ll long long int\n\nusing namespace std;\n\nconst int INF = (1<<30) - 1;\n\n//lh, lw, rh, rw\ntypedef tuple<int, int, int, int> State;\n\nint dh[] = {0, 1, 0, -1};\nint dw[] = {1, 0, -1, 0};\n\nint dp[50][50][50][50];\n\nbool solve(vector<string> &L, vector<string> &R){\n    int H = L.size();\n    int W = L[0].size();\n    \n    memset(dp, 0, sizeof(dp));\n    queue<State> que;\n    \n    int lh, lw, rh, rw;\n    int glh, glw, grh, grw;\n    for(int h=0; h<H; h++){\n        for(int w=0; w<W; w++){\n            if(L[h][w] == 'L'){\n                lh = h; lw = w;\n            }else if(L[h][w] == '%'){\n                glh = h; glw = w;\n            }\n        }\n    }\n    for(int h=0; h<H; h++){\n        for(int w=0; w<W; w++){\n            if(R[h][w] == 'R'){\n                rh = h; rw = w;\n            }else if(R[h][w] == '%'){\n                grh = h; grw = w;\n            }\n        }\n    }\n    auto start = State(lh, lw, rh, rw);\n    dp[lh][lw][rh][rw] = true;\n    que.push(start);\n    \n    while(!que.empty()){\n        tie(lh, lw, rh, rw) = que.front(); que.pop();\n        \n        for(int i=0; i<4; i++){\n            int nlh = lh + dh[i], nlw = lw + dw[i];\n            int nrh = rh + dh[i], nrw = rw + dw[i] * -1;\n            \n            if(nlh<0 || H<=nlh || nlw<0 || W<=nlw || L[nlh][nlw]=='#'){\n                nlh = lh; nlw = lw;\n            }\n            if(nrh<0 || H<=nrh || nrw<0 || W<=nrw || R[nrh][nrw]=='#'){\n                nrh = rh; nrw = rw;\n            }\n            \n            State next = State(nlh, nlw, nrh, nrw);\n            \n            if(nlh == glh && nlw == glw && nrh == grh && nrw == grw)\n                return true;\n            \n            if(!dp[nlh][nlw][nrh][nrw] && (nlh!=glh || nlw!=glw) && (nrh!=grh || nrw!=grw)){\n                dp[nlh][nlw][nrh][nrw] = true;\n                que.push(next);\n            }\n        }\n    }\n    return false;\n}\n\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    int H, W;\n    while(cin>>W>>H, H|W){\n        vector<string> L(H), R(H);\n        for(int i=0; i<H; i++)\n            cin >> L[i] >> R[i];\n        \n        cout << (solve(L, R) ? \"YES\" : \"NO\") << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nconst int SZ = 51;\n\nint dx[] = {0, -1, 0, 1};\nint dy[] = {1, 0, -1, 0};\n\nint H, W;\nbool visit[SZ][SZ][SZ][SZ];\nstring LIN[SZ], REN[SZ];\n\ninline bool inside(int x, int y){\n  return 0 <= x && x < H && 0 <= y && y < W;\n}\n\nbool bfs(int lsx, int lsy, int rsx, int rsy){\n  memset(visit, false, sizeof(visit));\n  visit[lsx][lsy][rsx][rsy] = true;\n  queue<int> que_lx, que_ly, que_rx, que_ry;\n  que_lx.push(lsx);\n  que_ly.push(lsy);\n  que_rx.push(rsx);\n  que_ry.push(rsy);\n  while(!que_lx.empty()){\n\n    int lx = que_lx.front(); que_lx.pop();\n    int ly = que_ly.front(); que_ly.pop();\n    int rx = que_rx.front(); que_rx.pop();\n    int ry = que_ry.front(); que_ry.pop();\n    \n    if(LIN[lx][ly] == '%' && REN[rx][ry] == '%') return true;\n    REP(i, 4){\n      int nlx = lx + dx[i];\n      int nly = ly + dy[i];\n      int nrx = rx + dx[i];\n      int nry = ry + dy[(i+2)%4];\n      \n      if(!inside(nlx, nly) || LIN[nlx][nly] == '#') nlx = lx, nly = ly;\n      if(!inside(nrx, nry) || REN[nrx][nry] == '#') nrx = rx, nry = ry;\n      if(!visit[nlx][nly][nrx][nry]){\n        visit[nlx][nly][nrx][nry] = true;\n        que_lx.push(nlx);\n        que_ly.push(nly);\n        que_rx.push(nrx);\n        que_ry.push(nry);        \n      }\n    }\n  }\n  \n  return false;\n}\n\n\nint main(){\n  while(cin >> W >> H && H + W > 0){\n    REP(i, H) cin >> LIN[i] >> REN[i];\n    int rsx, rsy, lsx, lsy;\n    \n    REP(i, H)REP(j, W){\n      if(LIN[i][j] == 'L') lsx = i, lsy = j;\n      if(REN[i][j] == 'R') rsx = i, rsy = j;\n    }\n    cout << (bfs(lsx, lsy, rsx, rsy) ? \"Yes\" : \"No\") << endl;\n      \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstring>\n#include <iostream>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nconst int dx1[4] = { 0, 1, 0, -1 };\nconst int dy1[4] = { -1, 0, 1, 0 };\nconst int dx2[4] = { 0, -1, 0, 1 };\nconst int dy2[4] = { -1, 0, 1, 0 };\n\nint H, W; string L[50], R[50];\n\nbool used[50][50][50][50];\n\nbool over(int x, int y)\n{\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\nbool solve(int lx, int ly, int rx, int ry)\n{\n\tused[ly][lx][ry][rx] = true;\n\n\tif (L[ly][lx] == '%' && R[ry][rx] == '%') return true;\n\n\tif (L[ly][lx] == '%') return false;\n\tif (R[ry][rx] == '%') return false;\n\n\tbool ok = false;\n\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint ltx = lx + dx1[i];\n\t\tint lty = ly + dy1[i];\n\t\tint rtx = rx + dx2[i];\n\t\tint rty = ry + dx2[i];\n\n\t\tif (over(ltx, lty) && over(rtx, rty))\n\t\t{\n\t\t\tif (L[lty][ltx] != '#' && R[rty][rtx] != '#')\n\t\t\t{\n\t\t\t\tif (!used[lty][ltx][rty][rtx])\n\t\t\t\t{\n\t\t\t\t\tok |= solve(ltx, lty, rtx, rty);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ok;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &W);\n\t\tscanf(\"%d\", &H);\n\n\t\tif (W == 0 && H == 0) break;\n\n\t\tfor (int i = 0; i < H; i++) cin >> L[i] >> R[i];\n\n\t\tint lx, ly, rx, ry;\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (L[i][j] == 'L')\n\t\t\t\t{\n\t\t\t\t\tlx = j;\n\t\t\t\t\tly = i;\n\t\t\t\t}\n\n\t\t\t\tif (R[i][j] == 'R')\n\t\t\t\t{\n\t\t\t\t\trx = j;\n\t\t\t\t\try = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(used, false, sizeof(used));\n\n\t\tprintf(\"%s\\n\", solve(lx, ly, rx, ry) ? \"Yes\" : \"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Mirror Cave\n//Level: 3\n//Category: シミュレーション,幅優先探索,BFS\n//Note:\n\n/*\n * [Lの位置][Rの位置]を状態にして幅優先探索する。\n */\n#include <iostream>\n#include <string>\n#include <queue>\n \nusing namespace std;\n \nconst int dr[] = {0, -1, 0, 1};\nconst int dc[][4] = {\n    {1, 0, -1, 0},\n    {-1, 0, 1, 0}\n};\n\ninline bool in_range(int a, int x, int b) {\n    return a <= x && x < b;\n}\n\nint hash(const pair<int,int> &p) {\n    return p.first*50 + p.second;\n}\n\npair<int,int> unhash(int n) {\n    return make_pair(n/50, n%50);\n}\n\nstruct Tag {\n    pair<int,int> pos[2];\n\n    Tag() {}\n    Tag(pair<int,int> *pa) {\n        pos[0] = pa[0];\n        pos[1] = pa[1];\n    }\n\n    void get(pair<int,int> *pa) const {\n        pa[0] = pos[0];\n        pa[1] = pos[1];\n    }\n};\n\nbool solve() {\n    int W, H;\n    cin >> W >> H;\n    if(!W && !H) return false;\n\n    vector<string> field[2];\n    pair<int,int> starts[2];\n    for(int r = 0; r < H; ++r) {\n        string a, b;\n        cin >> a >> b;\n        field[0].push_back(a);\n        field[1].push_back(b);\n    }\n    for(int i = 0; i < 2; ++i) {\n        for(int r = 0; r < H; ++r) {\n            for(int c = 0; c < W; ++c) {\n                if(field[i][r][c] == \"LR\"[i]) {\n                    starts[i] = make_pair(r, c);\n                    field[i][r][c] = '.';\n                }\n            }\n        }\n    }\n\n    queue<Tag> q;\n    vector<vector<unsigned char> > memo(2500, vector<unsigned char>(2500, 0));\n    memo[hash(starts[0])][hash(starts[1])] = 1;\n    q.push(starts);\n    bool ans = false;\n    while(!q.empty()) {\n        const Tag t = q.front();\n        //cout << t.pos[0].first << ' ' << t.pos[0].second << ' ';\n        //cout << t.pos[1].first << ' ' << t.pos[1].second << endl;\n        q.pop();\n\n        for(int dir = 0; dir < 4; ++dir) {\n            pair<int,int> np[2];\n            t.get(np);\n            int goalcnt = 0;\n            for(int i = 0; i < 2; ++i) {\n                int nr = np[i].first + dr[dir];\n                int nc = np[i].second + dc[i][dir];\n                if(in_range(0, nr, H) && in_range(0, nc, W)) {\n                    switch(field[i][nr][nc]) {\n                        case '#':\n                            nr = np[i].first;\n                            nc = np[i].second;\n                            break;\n                        case '%':\n                            goalcnt++;\n                            break;\n                    }\n                } else {\n                    nr = np[i].first;\n                    nc = np[i].second;\n                }\n                np[i] = make_pair(nr, nc);\n            }\n            if(goalcnt == 2) {\n                ans = true;\n                goto end;\n            } else {\n                const int h1 = hash(np[0]);\n                const int h2 = hash(np[1]);\n                if(!memo[h1][h2]) {\n                    memo[h1][h2] = 1;\n                    q.push(Tag(np));\n                }\n            }\n        }\n    }\nend:\n    cout << (ans ? \"Yes\" : \"No\") << endl;\n    return true;\n}\n \nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n     \n    for(; solve(); ) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nint w, h;\nP sl, sr;\nstring s[1000];\nstring t[1000];\nbool f[60][60][60][60];\n\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\n\n//set<pair<P,P>>\n\nbool solve(int ly, int lx, int ry, int rx) {\n\tbool res = 0;\n\tf[ly][lx][ry][rx] = 1;\n\tREP(i, 4) {\n\t\tint nly = ly + dy[i], nry = ry + dy[i], nlx = lx + dx[i], nrx = rx + dx[i];\n\t\tif (nly >= 0 && nly < h&&nlx >= 0 && nlx < w&&nry >= 0 && nry < h&&nrx >= 0 && nrx < w) {\n\t\t\tif (f[nly][nrx][nry][nrx])continue;\n\t\t\tif (s[nly][nlx] != t[nry][nrx]) {\n\t\t\t\tif (s[nly][nlx] == '%' || t[nry][nrx] == '%')continue;\n\t\t\t\tif (s[nly][nlx] == '#')res |= solve(ly, lx, nry, nrx);\n\t\t\t\telse if (t[nry][nrx] == '#')res |= solve(nly, nlx, ry, rx);\n\t\t\t\telse res |= solve(nly, nlx, nry, nrx);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (s[nly][nlx] == '%')res |= true;\n\t\t\t\telse if (s[nly][nlx] == '.')res |= solve(nly, nlx, nry, nrx);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\twhile (cin >> w >> h&&w + h) {\n\t\tREP(i, 60)REP(j, 60)REP(k,60)REP(l,60) {\n\t\t\tf[i][j][k][l] = 0;\n\t\t}\n\t\tREP(i, h) {\n\t\t\tcin >> s[i] >> t[i];\n\t\t\treverse(ALL(t[i]));\n\t\t}\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tif (s[i][j] == 'L') {\n\t\t\t\t\tsl = { i,j };\n\t\t\t\t\ts[i][j] = '.';\n\t\t\t\t}\n\t\t\t\tif (t[i][j] == 'R') {\n\t\t\t\t\tsr = { i,j };\n\t\t\t\t\tt[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (solve(sl.first, sl.second, sr.first, sr.second))cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nint W, H;\nvoid dis(vvi &v,int x,int y,int dist){\n\tv[y][x] = dist;\n\tREP(i, 4){\n\t\tif (x + dx[i] >= 0 && x + dx[i]<W&&y + dy[i] >= 0 && y + dy[i]<H&& v[y + dy[i]][x + dx[i]] != -1 && v[y + dy[i]][x + dx[i]]>v[y][x])\n\t\tdis(v, x + dx[i], y + dy[i],dist+1);\n\t}\n}\nint main() {\n\t\n\twhile (cin >> W >> H, W | H){\n\t\tvector<string> vsl;\n\t\tvector<string> vsr;\n\t\tREP(i, H){\n\t\t\tstring l;\n\t\t\tstring r;\n\t\t\tcin >> l >> r;\n\t\t\tvsl.push_back(l);\n\t\t\tvsr.push_back(r);\n\t\t}\n\t\tvector<vector<int>> vvil(H);\n\t\tvector<vector<int>> vvir(H);\n\t\tint glx;\n\t\tint gly;\n\t\tint grx;\n\t\tint gry;\n\t\tint lx;\n\t\tint ly;\n\t\tint rx;\n\t\tint ry;\n\t\tREP(i, H){\n\t\t\tREP(j, W){\n\t\t\t\tif (vsl[i][j] == '#')vvil[i].push_back(-1);\n\t\t\t\telse vvil[i].push_back(9999);\n\t\t\n\t\t\t\tif (vsr[i][j] == '#')vvir[i].push_back(-1);\n\t\t\t\telse vvir[i].push_back(9999);\n\n\t\t\t\tif (vsl[i][j] == 'L'){\n\t\t\t\t\tlx = j;\n\t\t\t\t\tly = i;\n\t\t\t\t}\n\t\t\t\tif (vsr[i][j] == 'R'){\n\t\t\t\t\trx = j;\n\t\t\t\t\try = i;\n\t\t\t\t}\n\t\t\t\tif (vsl[i][j] == '%'){\n\t\t\t\t\tglx = j;\n\t\t\t\t\tgly = i;\n\t\t\t\t}\n\t\t\t\tif (vsr[i][j] == '%'){\n\t\t\t\t\tgrx = j;\n\t\t\t\t\tgry = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdis(vvil, glx, gly, 0);\n\t\tdis(vvir, grx, gry, 0);\n\t\t\n\t\tvector<int> vi;\n\t\tvi.push_back(lx * 1000000 + ly * 10000 + rx * 100 + ry);\n\t\tint count = 0;\n\t\tint pcount = 1;\n\t\tbool clear = false;\n\t\twhile(1){\n\t\t\t/*if (vi[count] == glx * 1000000 + gly * 10000 + grx * 100 + gry){\n\t\t\t\tclear = true;\n\t\t\t\tbreak;\n\t\t\t}*/\n\t\t\tint lx2 = vi[count] / 1000000 % 100;\n\t\t\tint ly2 = vi[count] / 10000 % 100;\n\t\t\tint rx2 = vi[count] / 100 % 100;\n\t\t\tint ry2 = vi[count] % 100;\n\t\t\t\n\t\t\tREP(i, 4){\n\t\t\t\tint lx3 = lx2;\n\t\t\t\tint ly3 = ly2;\n\t\t\t\tint rx3 = rx2;\n\t\t\t\tint ry3 = ry2;\n\t\t\t\tif (dx[i] != 0 && lx3 + dx[i] >= 0 && lx3 + dx[i] < W && vsl[ly3 + dy[i]][lx3 + dx[i]] != '#')lx3 += dx[i];\n\t\t\t\tif (dy[i] != 0 && ly3 + dy[i] >= 0 && ly3 + dy[i] < H && vsl[ly3 + dy[i]][lx3 + dx[i]] != '#')ly3 += dy[i];\n\t\t\t\tif (dx[i] != 0 && rx3 - dx[i] >= 0 && rx3 - dx[i] < W && vsr[ry3 + dy[i]][rx3 - dx[i]] != '#')rx3 -= dx[i];\n\t\t\t\tif (dy[i] != 0 && ry3 + dy[i] >= 0 && ry3 + dy[i] < H && vsr[ry3 + dy[i]][rx3 - dx[i]] != '#')ry3 += dy[i];\n\t\t\t\tif (find(vi.begin(), vi.end(), lx3 * 1000000 + ly3 * 10000 + rx3 * 100 + ry3) == vi.end() && vvil[ly3][lx3] != 0&& vvir[ry3][rx3] != 0)vi.push_back(lx3 * 1000000 + ly3 * 10000 + rx3 * 100 + ry3);\n\t\t\t\tif (lx3 == glx&&ly3 == gly&&rx3 == grx&&ry3 == gry)clear = true;\n\t\t\t}\n\t\t\tif (clear)break;\n\t\t\tif (count+1 == vi.size())break;\n\t\t\tint min = 10000;\n\t\t\tint i2=0;\n\n\t\t\tFOR(i,count+1,vi.size()){\n\t\t\t\tif (vvil[(vi[i] / 10000 % 100)][(vi[i] / 1000000 % 100)] + vvir[(vi[i] % 100)][(vi[i] / 100 % 100)] < min)min = vvil[(vi[i] / 10000 % 100)][(vi[i] / 1000000 % 100)] + vvir[(vi[i] % 100)][(vi[i] / 100 % 100)];\n\t\t\t\ti2 = i;\n\t\t\t}\n\t\t\tif (vvil[ly2][lx2] + vvir[ry2][rx2] < min)break;\n\t\t\tswap(vi[count+1], vi[i2]);\n\t\t\t\n\t\t\tcount++;\n\t\t}\n\n\t\tif (clear)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nint const dxL[] = {-1,0,1,0};\nint const dxR[] = {1,0,-1,0};\nint const dy[]  = {0,-1,0,1};\ntypedef pair<int, int> Pii;\n#define X first\n#define Y second\nint const INF = 1<<28;\nint W, H;\nchar grL[51][51], grR[51][51];\nbool used[2500][2500];\ninline bool isValid(int x, int y) {\n  if(0<=x&&x<W && 0<=y&&y<H) return true;\n  return false;\n}\n\ninline bool inF(int x, int y, int isL) {\n  if(isL) return grL[y][x]!='#';\n  return grR[y][x]!='#';\n}\ninline int toNode(int x, int y) {\n  return y*W+x;\n}\ninline void toPos(int node, int &x, int &y) {\n  x = node%W, y = node/W;\n}\nint main() {\n  \n  while(cin >> W >> H && (W|H)) {\n    int sxL, syL, sxR, syR;\n    int gxL, gyL, gxR, gyR;\n    for(int i=0; i<H; i++) {\n      for(int j=0; j<2*W; j++) {\n        if(j<W) {\n          cin >> grL[i][j];\n          if(grL[i][j] == 'L') {\n            sxL = j, syL = i;\n          }\n          if(grL[i][j] == '%') {\n            gxL = j, gyL = i;\n          }\n        }\n        else {\n          cin >> grR[i][j-W];\n          if(grR[i][j-W] == 'R') {\n            sxR = j-W, syR = i;\n          }\n          if(grR[i][j-W] == '%') {\n            gxR = j-W, gyR = i;\n          }\n        }\n      }\n    }\n    \n    queue<Pii> que;\n    que.push(make_pair(toNode(sxL, syL), toNode(sxR, syR)));\n    bool ok = false;\n    memset(used, false, sizeof used);\n    while(!que.empty()) {\n      const int nowL = que.front().first;\n      const int nowR = que.front().second; que.pop();\n      int lx, ly; toPos(nowL, lx, ly);\n      int rx, ry; toPos(nowR, rx, ry);\n\n      if(lx == gxL && ly == gyL && rx == gxR && ry == gyR) {\n        ok = true; break;\n      }\n      \n      if(lx == gxL && ly == gyL) continue;\n      if(rx == gxR && ry == gyR) continue;\n      \n      for(int i=0; i<4; i++) {\n        int nxL = lx+dxL[i], nyL = ly+dy[i];\n        int nxR = rx+dxR[i], nyR = ry+dy[i];\n\n        if(!isValid(nxL, nyL) || !inF(nxL, nyL, 1)) { nxL = lx, nyL = ly; }\n        if(!isValid(nxR, nyR) || !inF(nxR, nyR, 0)) { nxR = rx, nyR = ry; }\n        if(used[toNode(nxL, nyL)][toNode(nxR, nyR)]) continue;\n        que.push(make_pair(toNode(nxL, nyL), toNode(nxR, nyR)));\n        used[toNode(nxL, nyL)][toNode(nxR, nyR)] = true;\n      }\n    }\n    if(ok) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <set>\n#include <queue>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\tint h, w, i, j, a, b, c, d, dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\n\tchar rf[50][51], lf[50][51];\n\tset<pair<P,P> > s;\n\tP rs, ls, rg, lg;\n\tqueue<P> r, l;\n\twhile(1){\n\t\tscanf(\"%d%d%*c\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tlf[i][j] = getchar();\n\t\t\t\tif(lf[i][j] == 'L'){\n\t\t\t\t\tls = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(lf[i][j] == '%'){\n\t\t\t\t\tlg = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 空白読み飛ばし\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\trf[i][j] = getchar();\n\t\t\t\tif(rf[i][j] == 'R'){\n\t\t\t\t\trs = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(rf[i][j] == '%'){\n\t\t\t\t\trg = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 改行文字読み飛ばし\n\t\t}\n\t\tr.push(rs), l.push(ls);\n\t\twhile(r.size()){\n\t\t\ta = l.front().first, b = l.front().second, c = r.front().first, d = r.front().second;\n\t\t\tl.pop(), r.pop();\n\t\t\ts.insert(pair<P,P>(P(a,b),P(c,d)));\n\t\t\tfor(i = 0;i < 4;i++){\n\t\t\t\tif(a + dy[i] >= 0 && a + dy[i] < h && b + dx[i] >= 0 && b + dx[i] < w && lf[a + dy[i]][b + dx[i]] == '.' && c + dy[i] >= 0 && c + dy[i] < h && d - dx[i] >= 0 && d - dx[i] < w && rf[c + dy[i]][d - dx[i]] == '.' && s.find(pair<P,P>(P(a + dy[i],b + dx[i]),P(c + dy[i],d - dx[i]))) == s.end()) // 両方とも動くとき\n\t\t\t\t\tl.push(P(a + dy[i],b + dx[i])), r.push(P(c + dy[i],d - dx[i]));\n\t\t\t\telse if((a + dy[i] < 0 || a + dy[i] >= h || b + dx[i] < 0 || b + dx[i] >= w || lf[a + dy[i]][b + dx[i]] == '#') && c + dy[i] >= 0 && c + dy[i] < h && d - dx[i] >= 0 && d - dx[i] < w && rf[c + dy[i]][d - dx[i]] == '.' && s.find(pair<P,P>(P(a,b),P(c + dy[i],d - dx[i]))) == s.end()) // Rinだけ動く\n\t\t\t\t\tl.push(P(a,b)), r.push(P(c + dy[i],d - dx[i]));\n\t\t\t\telse if(a + dy[i] >= 0 && a + dy[i] < h && b + dx[i] >= 0 && b + dx[i] < w && lf[a + dy[i]][b + dx[i]] == '.' && (c + dy[i] < 0 || c + dy[i] >= h || d - dx[i] < 0 || d - dx[i] >= w || rf[c + dy[i]][d - dx[i]] == '#') && s.find(pair<P,P>(P(a + dy[i],b + dx[i]),P(c,d))) == s.end()) // Lenだけ動く\n\t\t\t\t\tl.push(P(a + dy[i],b + dx[i])), r.push(P(c,d));\n\t\t\t}\n\t\t}\n\t\tif(s.find(pair<P,P>(P(lg.first,lg.second),P(rg.first,rg.second))) != s.end())\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t\ts.erase(s.begin(),s.end());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define M 50\n#include<cstring>\nusing namespace std;\nbool flag;\nint dx[]={1,-1,0,0},dy[]={0,0,-1,1},w,h;\nchar r[M][M],l[M][M];\nbool dp[M][M][M][M];\nvoid func(int ly,int lx,int ry,int rx){\n\tif(flag)\n\treturn;\n\t//cout<<ly<<' '<<lx<<' '<<ry<<' '<<rx<<endl;\n\tif(dp[ly][lx][ry][rx]!=0)\n\treturn;\n\tdp[ly][lx][ry][rx]=1;\n\tif(l[ly][lx]=='%'&&r[ry][rx]=='%'){\n\t\tflag=true;\n\t\treturn;\n\t}else if(l[ly][lx]=='%'||r[ry][rx]=='%')\n\treturn;\n\tint nrx,nry,nlx,nly;\n\tfor(int i=0;i<4;i++){\n\t\tnrx=dx[i]+rx;\n\t\tnry=dy[i]+ry;\n\t\tnlx=-dx[i]+lx;\n\t\tnly=dy[i]+ly;\n\t\tif(!(nrx>=0&&nrx<w&&nry>=0&&nry<h)||r[nry][nrx]=='#'){\n\t\t\tnrx=rx;nry=ry;\n\t\t}\n\t\tif(!(nlx>=0&&nlx<w&&nly>=0&&nly<h)||l[nly][nlx]=='#'){\n\t\t\tnlx=lx;nly=ly;\n\t\t}\n\t\tif(dp[nly][nlx][nry][nrx]==0)\n\t\tfunc(nly,nlx,nry,nrx);\n\t}\n}\nint main(){\n\tint a,b,c,d;\n\twhile(cin>>w>>h,h||w){\n\t\tfor(int i=0;i<h;i++)\n\t\t\tcin>>l[i]>>r[i];\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(l[i][j]=='L'){\n\t\t\t\t\ta=i;b=j;\n\t\t\t\t}\n\t\t\t\tif(r[i][j]=='R'){\n\t\t\t\t\tc=i;d=j;\n\t\t\t\t}\n\t\t}\n\t\tmemset(dp,0,sizeof(dp));\n\t\tflag=false;\n\t\tfunc(a,b,c,d);\n\t\tputs(flag?\"Yes\":\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nbool memo[50][50][50][50], R1[50][50], R2[50][50];\nint W, H;\nint dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\nint sx1, sy1, sx2, sy2, gx1, gx2, gy1, gy2; \nvoid rec(int x1, int y1, int x2, int y2){\n  for(int i = 0; i < 4; ++i){\n    int x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;\n    if(x1 + dx[i] < H && x1 + dx[i] >= 0 &&\n       y1 + dy[i] < W && y1 + dy[i] >= 0 &&\n       R1[x1 + dx[i]][y1 + dy[i]]){\n      x1_ += dx[i];\n      y1_ += dy[i];\n    }\n    if(x2 + dx[i] < H && x2 + dx[i] >= 0 &&\n       y2 - dy[i] < W && y2 - dy[i] >= 0 &&\n       R2[x2 + dx[i]][y2 - dy[i]]){\n      x2_ += dx[i];\n      y2_ -= dy[i];\n    }\n    if((x1_ == gx1 && y1_ == gy1) || (x2_ == gx2 && y2_ == gy2)){\n      memo[x1_][y1_][x2_][y2_] = true;\n    }else if(!memo[x1_][y1_][x2_][y2_]){\n      memo[x1_][y1_][x2_][y2_] = true;\n      rec(x1_,y1_,x2_,y2_);\n    }\n  }\n}\n \nint main(){\n  while(cin >> W >> H, W){\n\n    string r1, r2;\n    for(int i = 0; i < H; ++i){\n      cin >> r1 >> r2;\n      for(int j = 0; j < W; ++j){\n        if(r1[j] == 'L'){\n          sx1 = i;\n          sy1 = j;\n        }\n        if(r2[j] == 'R'){\n          sx2 = i;\n          sy2 = j;\n        }\n        if(r1[j] == '%'){\n          gx1 = i;\n          gy1 = j;\n        }\n        if(r2[j] == '%'){\n          gx2 = i;\n          gy2 = j;\n        }\n        if(r1[j] != '#') R1[i][j] = true;\n        else R1[i][j] = false;\n        if(r2[j] != '#') R2[i][j] = true;\n        else R2[i][j] = false;\n      }\n    }\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n        for(int k = 0; k < H; ++k){\n          for(int l = 0; l< W; ++l){\n            memo[i][j][k][l] = false;\n          }\n        }\n      }\n    }\n    memo[sx1][sy1][sx2][sy2] = true;\n    rec(sx1,sy1,sx2,sy2);\n    if(memo[gx1][gy1][gx2][gy2]) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nstruct Node {\n  Node(int lx, int ly, int rx, int ry) {\n    this->lx = lx;\n    this->ly = ly;\n    this->rx = rx;\n    this->ry = ry;\n  }\n\n  int lx;\n  int ly;\n  int rx;\n  int ry;\n};\n\nint oneval(int lx, int ly, int rx, int ry) {\n  return lx * 1000000000 + ly * 1000000 + rx * 1000 + ry;\n}\n\nint main() {\n  vector<vector<char> > f;\n  f.resize(103);\n  for (int i = 0; i < f.size(); i++) {\n    f[i].resize(52);\n  }\n\n  while (true) {\n    int W, H;\n    cin >> W >> H;\n\n    if (W == 0) {\n      break;\n    }\n\n    int cw = W + 1;\n    int w = W * 2 + 3;\n    int h = H + 2;\n    for (int i = 0; i < w; i++) {\n      f[i][0] = f[i][h - 1] = '#';\n    }\n    for (int i = 0; i < h; i++) {\n      f[0][i] = f[cw][i] = f[w - 1][i] = '#';\n    }\n\n    int lx = 0, ly = 0;\n    int rx = 0, ry = 0;\n    for (int i = 1; i < h - 1; i++) {\n      for (int j = 1; j < cw; j++) {\n\tcin >> f[j][i];\n\tif (f[j][i] == 'L') {\n\t  lx = j;\n\t  ly = i;\n\t  f[j][i] = '.';\n\t}\n      }\n      for (int j = cw + 1; j < w - 1; j++) {\n\tcin >> f[j][i];\n\tif (f[j][i] == 'R') {\n\t  rx = j;\n\t  ry = i;\n\t  f[j][i] = '.';\n\t}\n      }\n    }\n\n    set<int> s;\n    queue<Node> q;\n    q.push(Node(lx, ly, rx, ry));\n    while (!q.empty()) {\n      Node n = q.front();\n\n      if (f[n.lx][n.ly] == '%' && f[n.rx][n.ry] == '%') {\n\tcout << \"Yes\" << endl;\n\tbreak;\n      }\n      q.pop();\n\n      int val = oneval(n.lx, n.ly, n.rx, n.ry);\n      if (s.count(val) != 0) {\n\tcontinue;\n      }\n      s.insert(val);\n\n      q.push(Node(n.lx, f[n.lx][n.ly - 1] != '#' ? n.ly - 1 : n.ly,\n\t\t  n.rx, f[n.rx][n.ry - 1] != '#' ? n.ry - 1 : n.ry));\n      q.push(Node(f[n.lx - 1][n.ly] != '#' ? n.lx - 1 : n.lx, n.ly,\n\t\t  f[n.rx + 1][n.ry] != '#' ? n.rx + 1 : n.rx, n.ry));\n      q.push(Node(f[n.lx + 1][n.ly] != '#' ? n.lx + 1 : n.lx, n.ly,\n\t\t  f[n.rx - 1][n.ry] != '#' ? n.rx - 1 : n.rx, n.ry));\n      q.push(Node(n.lx, f[n.lx][n.ly + 1] != '#' ? n.ly + 1 : n.ly,\n\t\t  n.rx, f[n.rx][n.ry + 1] != '#' ? n.ry + 1 : n.ry));\n    }\n\n    if (q.empty()) {\n      cout << \"No\" << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nconst int INF = 1 << 29;\n\nstruct position {\n    int h, w;\n    position() {}\n    position(int a, int b): h(a), w(b) {}\n};\n\nstruct state {\n    position left, right;\n    int cost;\n    state() {}\n    state(position l, position r, int c): left(l), right(r), cost(c) { }\n};\n\nconst int dh[4] = {1, 0, -1, 0};\nconst int dw[4] = {0, 1, 0, -1};\n\nint W, H;\nstring rooml[55], roomr[55];\n\nint memo[55][55][55][55];\n\nint get_memo(position left, position right) {\n    return memo[left.h][left.w][right.h][right.w];\n}\n\nvoid update_memo(position left, position right, int value) {\n    memo[left.h][left.w][right.h][right.w] = value;\n}\n\nposition move(position p, int dir) {\n    return position(p.h+dh[dir], p.w+dw[dir]);\n}\n\nbool solve() {\n    cin >> W >> H;\n    if (W+H==0) { return false; }\n    for (int j = 0; j < H; ++j) {\n        cin >> rooml[j] >> roomr[j];\n    }\n\n    position sl, sr, gl, gr;\n\n    for (int j = 0; j < H; ++j) {\n        for (int k = 0; k < W; ++k) {\n            if (rooml[j][k] == 'L') { sl.h = j; sl.w = k; }\n            if (roomr[j][k] == 'R') { sr.h = j; sr.w = k; }\n\n            if (rooml[j][k] == '%') { gl.h = j; gl.w = k; }\n            if (roomr[j][k] == '%') { gr.h = j; gr.w = k; }\n        }\n    }\n\n    for (int j = 0; j < H; ++j) {\n        for (int k = 0; k < W; ++k) {\n            for (int l = 0; l < H; ++l) { fill(memo[j][k][l], memo[j][k][l]+W, INF); }\n        }\n    }\n\n    queue<state> que;\n    que.emplace(sl, sr, 0);\n    update_memo(sl, sr, 0);\n\n    int result = INF;\n    while (!que.empty()) {\n        state st = que.front(); que.pop();\n\n        if (get_memo(st.left, st.right) < st.cost) { continue; }\n\n        if ((rooml[st.left.h][st.left.w] == '%') != (roomr[st.right.h][st.right.w] == '%')) {\n            continue;\n        }\n\n        if ((rooml[st.left.h][st.left.w] == '%') && (roomr[st.right.h][st.right.w] == '%')) {\n            result = st.cost;\n            break;\n        }\n\n        for (int d = 0; d < 4; ++d) {\n            position nexl = move(st.left, d);\n            position nexr = move(st.right, (4-d)%4);\n\n            if (nexl.h < 0 || nexl.h >= H || nexl.w < 0 || nexl.w >= W) { nexl = st.left; }\n            if (nexr.h < 0 || nexr.h >= H || nexr.w < 0 || nexr.w >= W) { nexr = st.right; }\n\n            if (rooml[nexl.h][nexl.w] == '#') { nexl = st.left; }\n            if (roomr[nexr.h][nexr.w] == '#') { nexr = st.right; }\n\n            if (get_memo(nexl, nexr) > st.cost+1) {\n                update_memo(nexl, nexr, st.cost+1);\n                que.emplace(nexl, nexr, st.cost+1);\n            }\n        }\n    }\n\n    cout << (result == INF ? \"No\" : \"Yes\") << endl;\n\n    return true;\n}\n\nint main() {\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nstruct state { int ly, lx, ry, rx, t; };\n\nint W, H, SLY, SLX, SRY, SRX;\nchar S[2][50][50];\nbool visited[50][50][50][50];\nint dd[5] = { 0, 1, 0, -1, 0 };\n\nbool isin(int y, int x) {\n  return 0 <= y && y < H && 0 <= x && x < W;\n}\n\nint main(void) {\n  while(cin >> W >> H, W || H) {\n    REP(i, 0, H) {\n      cin >> S[0][i];\n      cin >> S[1][i];\n      REP(j, 0, W) if(S[0][i][j] == 'L') SLY = i, SLX = j;\n      REP(j, 0, W) if(S[1][i][j] == 'R') SRY = i, SRX = j;\n    }\n\n    REP(i, 0, 50) REP(j, 0, 50) REP(k, 0, 50) REP(l, 0, 50) visited[i][j][k][l] = false;\n\n    queue<state> q;\n    q.push((state) { SLY, SLX, SRY, SRX, 0 });\n\n    int ans = -1;\n    while(q.size()) {\n      state c = q.front();\n      q.pop();\n\n      if(visited[c.ly][c.lx][c.ry][c.rx]) continue;\n      visited[c.ly][c.lx][c.ry][c.rx] = true;\n\n      if(S[0][c.ly][c.lx] == '%' && S[1][c.ry][c.rx] == '%') {\n        ans = c.t;\n        break;\n      }\n\n      REP(i, 0, 4) {\n        state n = (state) { c.ly + dd[i], c.lx + dd[i + 1], c.ry + dd[i], c.rx - dd[i + 1], c.t + 1 };\n        if(isin(n.ly, n.lx) && isin(n.ry, n.rx)) {\n          if(S[0][n.ly][n.lx] != '#' && S[1][n.ry][n.rx] != '#') {\n            q.push(n);\n          }\n          if(S[0][n.ly][n.lx] != '#' && S[1][n.ry][n.rx] == '#') {\n            q.push((state) { n.ly, n.lx, c.ry, c.rx, n.t });\n          }\n          if(S[0][n.ly][n.lx] == '#' && S[1][n.ry][n.rx] != '#') {\n            q.push((state) { c.ly, c.lx, n.ry, n.rx, n.t });\n          }\n        }\n      }\n    }\n\n    if(ans == -1) cout << \"No\" << endl;\n    else cout << \"Yes\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\nint main() {\n\tfor (;;) {\n\t\tint W, H; cin >> W >> H;\n\t\tif (W == 0 && H == 0) break;\n\t\tvector< vector<string> > a(2, vector<string>(H + 2, string(W + 2, '#')));\n\t\tfor (int y = 1; y <= H; y++) {\n\t\t\tstring s1, s2; cin >> s1 >> s2;\n\t\t\ta[0][y] = '#' + s1 + '#';\n\t\t\ta[1][y] = '#' + s2 + '#';\n\t\t}\n\t\tvector<int> xs(2), ys(2), xt(2), yt(2);\n\t\tfor (int k = 0; k < 2; k++)\n\t\t\tfor (int y = 1; y <= H; y++)\n\t\t\t\tfor (int x = 1; x <= W; x++){\n\t\t\t\t\tchar& c = a[k][y][x];\n\t\t\t\t\tif (c == 'L' || c == 'R') {\n\t\t\t\t\t\tc = '.';\n\t\t\t\t\t\txs[k] = x; ys[k] = y;\n\t\t\t\t\t}\n\t\t\t\t\telse if (c == '%') {\n\t\t\t\t\t\tc = '.';\n\t\t\t\t\t\txt[k] = x; yt[k] = y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tvector< vector<bool> > vis(6000, vector<bool>(6000));\n\t\tstack< vector<int> > stx, sty;\n\t\tstx.push(xs); sty.push(ys);\n\t\twhile (!stx.empty()) {\n\t\t\tvector<int> x = stx.top(); stx.pop();\n\t\t\tvector<int> y = sty.top(); sty.pop();\n\t\t\tvector<int> z(2);\n\t\t\tfor (int k = 0; k < 2; k++)\n\t\t\t\tz[k] = y[k] * 100 + x[k];\n\t\t\tvis[z[0]][z[1]] = true;\n\t\t\tif (x[0] == xt[0] && y[0] == yt[0]) continue;\n\t\t\tif (x[1] == xt[1] && y[1] == yt[1]) continue;\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tvector<int> _x = x, _y = y, _z(2);\n\t\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\t\t_x[k] += (k ? dx[i] : -dx[i]);\n\t\t\t\t\t_y[k] += dy[i];\n\t\t\t\t\tif (a[k][_y[k]][_x[k]] == '#') {\n\t\t\t\t\t\t_x[k] = x[k]; _y[k] = y[k];\n\t\t\t\t\t}\n\t\t\t\t\t_z[k] = _y[k] * 100 + _x[k];\n\t\t\t\t}\n\t\t\t\tif (!vis[_z[0]][_z[1]]) {\n\t\t\t\t\tvis[_z[0]][_z[1]] = true;\n\t\t\t\t\tstx.push(_x);\n\t\t\t\t\tsty.push(_y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> zt(2);\n\t\tfor (int k = 0; k < 2; k++)\n\t\t\tzt[k] = yt[k] * 100 + xt[k];\n\t\tcout << (vis[zt[0]][zt[1]] ? \"Yes\" : \"No\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\nusing namespace std;\nstring s1[50],s2[50];\nint dx1[]={1,-1,0,0,},dy1[]={0,0,1,-1};\nint dx2[]={-1,1,0,0,},dy2[]={0,0,1,-1};\nint w,h,gx1,gx2,gy1,gy2;\nset<pair<pair<int,int>,pair<int,int> > >s;\nbool dfs(int x1,int y1,int x2,int y2){\n  if(x1==gx1&&y1==gy1&&(x2!=gx2||y2!=gy2))return 0;\n  if((x1!=gx1||y1!=gy1)&&x2==gx2&&y2==gy2)return 0;\n  if(x1==gx1&&y1==gy1&&x2==gx2&&y2==gy2)return 1;\n  for(int i=0;i<4;i++){\n    int x3=x1+dx1[i],y3=y1+dy1[i];\n    int x4=x2+dx2[i],y4=y2+dy2[i];\n    if(x3>=0&&x4>=0&&y3>=0&&y4>=0)\n      if(x3<w&&x4<w&&y3<h&&y4<h){\n        if(s1[y3][x3]=='#')y3=y1,x3=x1;\n        if(s2[y4][x4]=='#')y4=y2,x4=x2;\n        if(!s.count(mk(mk(x3,y3),mk(x4,y4)))){\n          s.insert(mk(mk(x3,y3),mk(x4,y4)));\n          if(dfs(x3,y3,x4,y4))return 1;\n        }\n      }\n    }\n    return 0;\n}\nint main(){\n  int x1,y1,x2,y2;\n  while(cin>>w>>h,w){\n    s.clear();\n    r(i,h)cin>>s1[i]>>s2[i];\n    r(i,h)r(j,w){\n      if(s1[i][j]=='L')x1=j,y1=i;\n      if(s2[i][j]=='R')x2=j,y2=i;\n      if(s1[i][j]=='%')gx1=j,gy1=i;\n      if(s2[i][j]=='%')gx2=j,gy2=i;\n    }\n    s.insert(mk(mk(x1,y1),mk(x2,y2)));\n    if(dfs(x1,y1,x2,y2))cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nstruct Data\n{\n\tint lx,ly,rx,ry;\n};\n\nconst int  dy[] = { 0, 0,+1,-1};\nconst int ldx[] = {+1,-1, 0, 0};\nconst int rdx[] = {-1,+1, 0, 0};\n\nint main()\n{\n\tint W,H;\n\twhile(cin>>W>>H, W||H)\n\t{\n\t\tchar L[50][51];\n\t\tchar R[50][51];\n\t\tfor(int y=0; y<H; y++)\n\t\t{\n\t\t\tcin>>L[y]>>R[y];\n\t\t}\n\n\n\t\tData s;\n\t\tfor(int y=0; y<H; y++)\n\t\tfor(int x=0; x<W; x++)\n\t\t{\t\n\t\t\tif(L[y][x]=='L') { s.lx=x; s.ly=y; }\n\t\t\tif(R[y][x]=='R') { s.rx=x; s.ry=y; }\n\t\t}\n\n\t\tqueue<Data> q;\n\t\tq.push(s);\n\n\t\tbool v[50][50][50][50]={0};\n\t\tv[s.ly][s.lx][s.ry][s.rx]=1;\n\n\t\tbool ans=false;\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tData t=q.front(); q.pop();\n\n\t\t\tif(L[t.ly][t.lx]=='%' && R[t.ry][t.rx]=='%')\n\t\t\t{\n\t\t\t\tans=true; break;\n\t\t\t}\n\t\t\tif(L[t.ly][t.lx]=='%' || R[t.ry][t.rx]=='%')\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor(int i=0; i<4; i++)\n\t\t\t{\n\t\t\t\tData n;\n\t\t\t\tn.ly = t.ly +  dy[i];\n\t\t\t\tn.lx = t.lx + ldx[i];\n\t\t\t\tn.ry = t.ry +  dy[i];\n\t\t\t\tn.rx = t.rx + rdx[i];\n\t\t\t\tif(L[n.ly][n.lx]=='#')\n\t\t\t\t{\n\t\t\t\t\tn.ly = t.ly;\n\t\t\t\t\tn.lx = t.lx;\n\t\t\t\t}\n\t\t\t\tif(R[n.ry][n.rx]=='#')\n\t\t\t\t{\n\t\t\t\t\tn.ry = t.ry;\n\t\t\t\t\tn.rx = t.rx;\n\t\t\t\t}\n\n\t\t\t\tif(0<=n.lx && n.lx<W && 0<=n.ly && n.ly<H\n\t\t\t\t&& 0<=n.rx && n.rx<W && 0<=n.ry && n.ry<H)\n\t\t\t\t{\n\t\t\t\t\tif(v[n.ly][n.lx][n.ry][n.rx]) continue;\n\t\t\t\t\tv[n.ly][n.lx][n.ry][n.rx]=1;\n\t\t\t\t\tq.push(n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << (ans?\"Yes\":\"No\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define pb push_back\n#define fi first\n#define sc second\nusing namespace std;\ntypedef pair<int,int> P;\n\nint w, h;\nstring a[50], b[50];\nbool use[50][50][50][50];\nint daw[4] = {1,0,-1,0},dah[4]={0,1,0,-1};\nint dbw[4] = {-1,0,1,0},dbh[4]={0,1,0,-1};\n\nvoid dfs(int p, int q, int r, int s){\n\trep(i,4){\n\t\tint dp = p+dah[i],dq = q+daw[i];\n\t\tint dr = r+dbh[i],ds = s+dbw[i];\n\t\tif(0>dp||dp>=h||0>dq||dq>=w||a[dp][dq]=='#'){\n\t\t\tdp = p;\n\t\t\tdq = q;\n\t\t}\n\t\tif(0>dr||dr>=h||0>ds||ds>=h||a[dr][ds]=='#'){\n\t\t\tdr = r;\n\t\t\tds = s;\n\t\t}\n\t\tif(use[dp][dq][dr][ds]) continue;\n\t\tuse[dp][dq][dr][ds] = true;\n\t\tdfs(dp,dq,dr,ds);\n\t}\n}\n\nint main(){\n\twhile(scanf(\"%d%d\",&w,&h),w||h){\n\t\tmemset(use,0,sizeof(use));\n\t\trep(i,50) a[i].clear();\n\t\trep(i,50) b[i].clear();\n\t\tP as, ae, bs, be;\n\t\trep(i,h) cin >> a[i] >> b[i];\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tif(a[i][j] == '%') as = P(i,j);\n\t\t\t\tif(b[i][j] == '%') bs = P(i,j);\n\t\t\t\tif(a[i][j] == 'L') ae = P(i,j);\n\t\t\t\tif(b[i][j] == 'R') be = P(i,j);\n\t\t\t}\n\t\t}\n\t\tuse[as.fi][as.sc][bs.fi][bs.sc] = true;\n\t\tdfs(as.fi,as.sc,bs.fi,bs.sc);\n\t\tif(use[ae.fi][ae.sc][be.fi][be.sc]) puts(\"Yes\");\n\t\telse puts(\"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXH = 50;\nconst int MAXW = 50;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\n\nint W, H, li, lj, ri, rj;\nstring L[MAXH], R[MAXH];\nbool vis[MAXH][MAXW][MAXH][MAXW];\n\nstruct State {\n  int a, b, c, d;\n};\n\nbool bfs() {\n  memset(vis, 0, sizeof(vis));\n  queue<State> que;\n  vis[li][lj][ri][rj] = true;\n  que.push((State){li, lj, ri, rj});\n  while(que.size()) {\n    const State s = que.front(); que.pop();\n    for(int k = 0; k < 4; ++k) {\n      int na = s.a + di[k];\n      int nb = s.b + dj[k];\n      int nc = s.c + di[k];\n      int nd = s.d - dj[k];\n      if(na < 0 || na >= H) na = s.a;\n      if(nb < 0 || nb >= W) nb = s.b;\n      if(nc < 0 || nc >= H) nc = s.c;\n      if(nd < 0 || nd >= W) nd = s.d;\n      if(L[na][nb] == '#') na = s.a, nb = s.b;\n      if(R[nc][nd] == '#') nc = s.c, nd = s.d;\n      if(L[na][nb] == '%' && R[nc][nd] == '%') return true;\n      if(L[na][nb] == '%' || R[nc][nd] == '%') continue;\n      if(vis[na][nb][nc][nd]) continue;\n      vis[na][nb][nc][nd] = true;\n      que.push((State){na, nb, nc, nd});\n    }\n  }\n  return false;\n}\n\nint main() {\n  while(cin >> W >> H && (W|H)) {\n    for(int i = 0; i < H; ++i) {\n      cin >> L[i] >> R[i];\n      int l = L[i].find('L');\n      int r = R[i].find('R');\n      if(l != string::npos) {\n        li = i; lj = l;\n      }\n      if(r != string::npos) {\n        ri = i; rj = r;\n      }\n    }\n    cout << (bfs() ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int, int> T;\n\nconst ll MOD=1e9+7;\nconst ll INF=1e18;\nconst double pi=acos(-1);\nconst double eps=1e-10;\n\nint dx[]={1, 0, -1, 0};\nint dy[]={0, -1, 0, 1};\n\nint main(){\n    while(1){\n        int w, h; cin>>w>>h;\n        if(w == 0) return 0;\n\n        int lsy, lsx, rsy, rsx;\n        int lgy, lgx, rgy, rgx;\n        vector<string> s1(h), s2(h);\n        for(int i=0; i<h; i++){\n            cin>>s1[i]>>s2[i];\n            reverse(s2[i].begin(), s2[i].end());\n\n            for(int j=0; j<w; j++){\n                if(s1[i][j] == '%'){\n                    s1[i][j] = '.';\n                    lgy = i;\n                    lgx = j;\n                }\n                if(s2[i][j] == '%'){\n                    s2[i][j] = '.';\n                    rgy = i;\n                    rgx = j;\n                }\n                if(s1[i][j] == 'L'){\n                    s1[i][j] = '.';\n                    lsy = i;\n                    lsx = j;\n                }\n                if(s2[i][j] == 'R'){\n                    s2[i][j] = '.';\n                    rsy = i;\n                    rsx = j;\n                }\n            }\n        }\n\n        bool valid=false;\n        queue<T> que;\n        que.push(T(lsy, lsx, rsy, rsx));\n        map<int, bool> visited;\n        visited[lsy*h+lsx+rsy*h*10000+rsx*10000] = true;\n        while(que.size()){\n            int lcy, lcx, rcy, rcx;\n            tie(lcy, lcx, rcy, rcx) = que.front();\n            que.pop();\n            //cout << lcy << \" \" << lcx << \" \" << rcy << \" \" << rcx << endl;\n\n            if(lcy == lgy && lcx == lgx && rcy == rgy && rcx == rgx){\n                cout << \"Yes\" << endl;\n                valid = true;\n                break;\n            }\n\n            for(int i=0; i<4; i++){\n                int lny = lcy + dy[i];\n                int lnx = lcx + dx[i];\n                int rny = rcy + dy[i];\n                int rnx = rcx + dx[i];\n\n                if(0 <= lny && lny < h && 0 <= lnx && lnx < w){\n                    if(s1[lny][lnx] == '.'){\n                        if(rny < 0 || h <= rny || rnx < 0 || w <= rnx){\n                            if(!visited[lny*h+lnx+rcy*h*10000+rcx*10000]){\n                                visited[lny*h+lnx+rcy*h*10000+rcx*10000] = true;\n                                que.push(T(lny, lnx, rcy, rcx));\n                            }\n                        }\n                        else if(s2[rny][rnx] == '#'){\n                            if(!visited[lny*h+lnx+rcy*h*10000+rcx*10000]){\n                                visited[lny*h+lnx+rcy*h*10000+rcx*10000] = true;\n                                que.push(T(lny, lnx, rcy, rcx));\n                            }\n                        }\n                        else{\n                            if(!visited[lny*h+lnx+rny*h*10000+rnx*10000]){\n                                visited[lny*h+lnx+rny*h*10000+rnx*10000] = true;\n                                que.push(T(lny, lnx, rny, rnx));\n                            }\n                        }\n                    }\n                }\n\n                if(0 <= rny && rny < h && 0 <= rnx && rnx < w){\n                    if(s2[rny][rnx] == '.'){\n                        if(lny < 0 || h <= lny || lnx < 0 || w <= lnx){\n                            if(!visited[lcy*h+lcx+rny*h*10000+rnx*10000]){\n                                visited[lcy*h+lcx+rny*h*10000+rnx*10000] = true;\n                                que.push(T(lcy, lcx, rny, rnx));\n                            }\n                        }\n                        else if(s1[lny][lnx] == '#'){\n                            if(!visited[lcy*h+lcx+rny*h*10000+rnx*10000]){\n                                visited[lcy*h+lcx+rny*h*10000+rnx*10000] = true;\n                                que.push(T(lcy, lcx, rny, rnx));\n                            }\n                        }\n                        else{\n                            if(!visited[lny*h+lnx+rny*h*10000+rnx*10000]){\n                                visited[lny*h+lnx+rny*h*10000+rnx*10000] = true;\n                                que.push(T(lny, lnx, rny, rnx));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if(!valid) cout << \"No\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint range(int a,int b,int h, int w){\n\treturn a >= 0 && a < h && b >= 0 && b < w;\n}\n\nP lg, rg;\nint f[50][50][50][50], dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0}, h, w;\nchar lf[50][51],rf[50][51]; \n\nint dfs(P l,P r){\n\tint i, ly, lx, ry, rx;\n\tly = l.first, lx = l.second, ry = r.first, rx = r.second;\n\tif(lg.first == ly && lg.second == lx || rg.first == ry && rg.second == rx){\n\t\tif(lg.first == ly && lg.second == lx && rg.first == ry && rg.second == rx)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tfor(i = 0;i < 4;i++){\n\t\tif(range(ly + dy[i],lx + dx[i],h,w) && range(ry + dy[i],rx - dx[i],h,w)){\n\t\t\tif(lf[ly + dy[i]][lx + dx[i]] != '#' && rf[ry + dy[i]][rx - dx[i]] != '#' && f[ly + dy[i]][lx + dx[i]][ry + dy[i]][rx - dx[i]]){\n\t\t\t\tf[ly + dy[i]][lx + dx[i]][ry + dy[i]][rx - dx[i]] = 0;\n\t\t\t\tif(dfs(P(ly + dy[i],lx + dx[i]),P(ry + dy[i],rx - dx[i]))) return 1;\n\t\t\t}\n\t\t\telse if(lf[ly + dy[i]][lx + dx[i]] != '#' && rf[ry + dy[i]][rx - dx[i]] == '#' && f[ly + dy[i]][lx + dx[i]][ry][rx]){\n\t\t\t\tf[ly + dy[i]][lx + dx[i]][ry][rx] = 0;\n\t\t\t\tif(dfs(P(ly + dy[i],lx + dx[i]),P(ry,rx))) return 1;\n\t\t\t}\n\t\t\telse if(lf[ly + dy[i]][lx + dx[i]] == '#' && rf[ry + dy[i]][rx - dx[i]] != '#' && f[ly][lx][ry + dy[i]][rx - dx[i]]){\n\t\t\t\tf[ly][lx][ry + dy[i]][rx - dx[i]] = 0;\n\t\t\t\tif(dfs(P(ly,lx),P(ry + dy[i],rx - dx[i]))) return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(void){\n\tint i, j;\n\tP rs, ls;\n\twhile(1){\n\t\tscanf(\"%d%d%*c\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tlf[i][j] = getchar();\n\t\t\t\tif(lf[i][j] == 'L'){\n\t\t\t\t\tls = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(lf[i][j] == '%'){\n\t\t\t\t\tlg = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 空白読み飛ばし\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\trf[i][j] = getchar();\n\t\t\t\tif(rf[i][j] == 'R'){\n\t\t\t\t\trs = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(rf[i][j] == '%'){\n\t\t\t\t\trg = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 改行文字読み飛ばし\n\t\t}\n\n\t\tmemset(f,-1,sizeof(f));\n\t\tf[ls.first][ls.second][rs.first][rs.second] = 0;\n\t\tprintf(\"%d %d %d %d\\n\",ls.second,ls.first,rs.second,rs.first);\n\t\tif(dfs(ls,rs))\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n// #define USE_LLONG_AS_INT\n#ifdef USE_LLONG_AS_INT\n#define int long long\n#define inf (1ll<<60)\n#else\n#define inf (1<<30)\n#endif\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,a,b) for(int i=a;i<=b;i++)\n#define rev(i,n) for(int i=(n)-1;i>=0;i--)\n#define vi vector<int>\n#define vvi vector<vi>\n#define pb push_back\n#define pi pair<int,int>\n#define vp vector<pair<int,int>>\n#define mp make_pair\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define MEMSET(a) memset(a,0,sizeof(a))\n#define Yes(f) cout<<(f?\"Yes\":\"No\")<<endl\n#define yes(f) cout<<(f?\"yes\":\"no\")<<endl\n#define YES(f) cout<<(f?\"YES\":\"NO\")<<endl\n#define SORT(v) sort(all(v))\n#define RSORT(v) sort(all(v), greater<int>())\n\nusing namespace std;\n\nconst int mod=1e9+7;\nconst string sp=\" \";\n\nvoid run();\n\nvoid init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(12);\n}\n\nsigned main(){\n    init();\n    run();\n    return 0;\n}\n\nint w,h;\nchar rl[50][50],rr[50][50];\nint syl,sxl,syr,sxr;\nbool used[50][50][50][50];\n\nbool bfs(){\n    int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n    queue<pi> ql,qr;\n    memset(used,false,sizeof(used));\n    ql.push({syl,sxl}),qr.push({syr,sxr});\n    used[syl][sxl][syr][sxr]=true;\n    while(!ql.empty()){\n        pi l=ql.front(),r=qr.front();\n        ql.pop(),qr.pop();\n        int yl=l.fi,xl=l.se,yr=r.fi,xr=r.se;\n        if(rl[yl][xl]=='%'&&rr[yr][xr]=='%'){\n            return true;\n        }\n        if(rl[yl][xl]!='%'&&rr[yr][xr]!='%'){\n            rep(i,4){\n                int nyl=min(h-1,max(0,yl+dy[i]));\n                int nxl=min(w-1,max(0,xl+dx[i]));\n                int nyr=min(h-1,max(0,yr+dy[i]));\n                int nxr=min(w-1,max(0,xr-dx[i]));\n                if(rl[nyl][nxl]=='#')nyl=yl,nxl=xl;\n                if(rr[nyr][nxr]=='#')nyr=yr,nxr=xr;\n                if(!used[nyl][nxl][nyr][nxr]){\n                    used[nyl][nxl][nyr][nxr]=true;\n                    ql.push({nyl,nxl}),qr.push({nyr,nxr});\n                }\n            }\n        }\n    }\n    return false;\n}\n\nvoid run(){\n    cin>>w>>h;\n    if(!w)return;\n    rep(i,h){\n        rep(j,w)cin>>rl[i][j];\n        rep(j,w)cin>>rr[i][j];\n    }\n    rep(i,h){\n        rep(j,w){\n            if(rl[i][j]=='L')sxl=j,syl=i;\n            if(rr[i][j]=='R')sxr=j,syr=i;\n        }\n    }\n    Yes(bfs());\n    run();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nusing lint = long long;\nusing ldouble = long double;\n\nconst int dx[4] = {-1, 0, 0, 1}, dy[4] = {0, -1, 1, 0};\n\nint H, W;\nvector<string> L, R;\nvector<vector<vector<vector<int>>>> dp;\n// -1 : 未探索\n// 0  : 到達不可\n// 1  : 到達可\n// 2  : 探索中\n\nbool dfs(int lx, int ly, int rx, int ry) {\n    auto& ret = dp[lx][ly][rx][ry];\n    if (ret >= 0) return ret == 1;\n\n    bool l = (L[lx][ly] == '%');\n    bool r = (R[rx][ry] == '%');\n    if (l && r) return (ret = 1) == 1;\n    if (l || r) return (ret = 0) == 1;\n\n    ret = 2;\n    for (int i = 0; i < 4; ++i) {\n        int lnx = lx + dx[i];\n        int lny = ly + dy[i];\n        if (lnx < 0 || H <= lnx || lny < 0 || W <= lny ||\n            L[lnx][lny] == '#') lnx = lx, lny = ly;\n\n        int rnx = rx + dx[i];\n        int rny = ry + dy[i];\n        if (rnx < 0 || H <= rnx || rny < 0 || W <= rny ||\n            R[rnx][rny] == '#') rnx = rx, rny = ry;\n\n        if (dfs(lnx, lny, rnx, rny)) return (ret = 1) == 1;\n    }\n    return (ret = 0) == 1;\n}\n\nbool solve() {\n    cin >> W >> H;\n    if (W == 0) return false;\n\n    L.resize(H);\n    R.resize(H);\n    for (int x = 0; x < H; ++x) {\n        cin >> L[x] >> R[x];\n        reverse(R[x].begin(), R[x].end());\n    }\n\n    int lsx, lsy, rsx, rsy;\n    for (int x = 0; x < H; ++x) {\n        for (int y = 0; y < W; ++y) {\n            if (L[x][y] == 'L') lsx = x, lsy = y;\n            if (R[x][y] == 'R') rsx = x, rsy = y;\n        }\n    }\n\n    dp.resize(H);\n    for (auto& v1 : dp) {\n        v1.resize(W);\n        for (auto& v2 : v1) {\n            v2.resize(H);\n            for (auto& v3 : v2) {\n                v3.assign(W, -1);\n            }\n        }\n    }\n\n    cout << (dfs(lsx, lsy, rsx, rsy) ? \"Yes\" : \"No\") << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint w,h;\nvector<string> l;\nvector<string> r;\nvector<vector<int> >mal;\nvector<vector<int> >mar;\nint main(){\n  while(1){\n    cin >> w >> h;\n    if(w==0&&h==0)break;\n    l=vector<string> (h);\n    r=vector<string> (h);\n    mal=vector<vector<int> >(h,vector<int>(w,-1));\n    mar=vector<vector<int> >(h,vector<int>(w,-1));\n    for(int i=0;i<h;i++){\n      cin >> l[i] >> r[i];\n    }\n    pair<int,int>ls;\n    pair<int,int>rs;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(l[i][j]=='L')ls={i,j};\n\tif(r[i][j]=='R')rs={i,j};\n      }\n    }\n    queue<int> qxl;\n    queue<int> qxr;\n    queue<int> qyl;\n    queue<int> qyr;\n    qyl.push(ls.first);\n    qxl.push(ls.second);\n    qyr.push(rs.first);\n    qxr.push(rs.second);\n    int ans=0;\n    while(!qxl.empty()){\n      int dxl[4]={-1,0,1,0};\n      int dy[4]={0,-1,0,1};\n      int dxr[4]={1,0,-1,0};\n      int pyl=qyl.front();\n      int pxl=qxl.front();\n      int pyr=qyr.front();\n      int pxr=qxr.front();\n      //cout << pyl << \" \" << pxl << endl; \n      qyl.pop();\n      qxl.pop();\n      qyr.pop();\n      qxr.pop();\n\n      if(l[pyl][pxl]=='#'||mal[pyl][pxl]==1)continue;\n      if(r[pyr][pxr]=='#'||mar[pyr][pxr]==1)continue;\n      mal[pyl][pxl]=1;\n      mar[pyr][pxr]=1;\n      if(l[pyl][pxl]==r[pyr][pxr]&&r[pyr][pxr]=='%'){ans=1;break;}\n      \n      for(int i=0;i<4;i++){\n\tif(pxl+dxl[i]<0||pxl+dxl[i]>=w)continue;\n\tif(pyl+dy[i]<0||pyl+dy[i]>=h)continue;\n\tif(pxr+dxr[i]<0||pxr+dxr[i]>=w)continue;\n\tif(pyr+dy[i]<0||pyr+dy[i]>=h)continue;\n\tqyl.push(pyl+dy[i]);\n\tqxl.push(pxl+dxl[i]);\n\tqyr.push(pyr+dy[i]);\n\tqxr.push(pxr+dxr[i]);\n      }\n    }\n    if(ans)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nstring ba[2][50];\nbool visited[50][50][50][50];\ntypedef pair<int,int> pii;\ntypedef pair<pii,pii> P;\n\nint main()  {\n    int h,w;\n    while(cin>>w>>h,h||w) {\n        //cout << h << \" \" << w << endl;\n        pii s[2];\n        for (int i=0; i<h; ++i) {\n            cin >> ba[0][i] >> ba[1][i];\n            for (int j=0; j<2; ++j) {\n                for (int k=0; k<w; ++k) {\n                    if (ba[j][i][k] == 'L' || ba[j][i][k] == 'R') {\n                        s[j] = pii(i,k);\n                    }\n                }\n            }\n        }\n        queue<P> Q;\n        Q.push(P(s[0], s[1]));\n        memset(visited,0,sizeof(visited));\n        const int dy[2][4] = {\n            {-1,0,1,0},\n            {-1,0,1,0}\n        };\n        const int dx[2][4] = {\n            {0,1,0,-1},\n            {0,-1,0,1}\n        };\n        bool ans = 0;\n        while(!Q.empty()) {\n            P p = Q.front(); Q.pop();\n            int y[2];\n            int x[2];\n            y[0] = p.first.first;\n            x[0] = p.first.second;\n            y[1] = p.second.first;\n            x[1] = p.second.second;\n           \n            if (visited[y[0]][x[0]][y[1]][x[1]]) continue;\n            visited[y[0]][x[0]][y[1]][x[1]] = 1;\n            //printf(\"(%d,%d) (%d,%d)\\n\",x[0],y[0],x[1],y[1]);\n            int c = 0;\n            for (int i=0; i<2; ++i) {\n                if (ba[i][y[i]][x[i]] == '%') c |= 1<<i;\n            }\n            if (c) {\n                if (c == 3) {\n                    ans = 1;\n                    break;\n                } else {\n                    continue;\n                }\n            }\n            for (int k=0; k<4; ++k) {\n                int yy[2], xx[2];\n                for (int i=0; i<2; ++i) {\n                    yy[i] = y[i] + dy[i][k];\n                    xx[i] = x[i] + dx[i][k];\n                    if (yy[i]<0||yy[i]>=h||xx[i]<0||xx[i]>=w || \n                        ba[i][yy[i]][xx[i]] == '#') {\n                        yy[i] = y[i];\n                        xx[i] = x[i];\n                    }\n                }\n                Q.push(P(pii(yy[0],xx[0]),pii(yy[1],xx[1])));\n            }\n        } \n        cout <<(ans?\"Yes\":\"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n\nusing namespace std;\n\nint ldx[] = {1,0,-1,0}, ldy[] = {0,1,0,-1};\nint rdx[] = {-1,0,1,0}, rdy[] = {0,1,0,-1};\n\nint H, W;\nstring rooml[55], roomr[55];\nbool flag;\n\nbool ls[55][55][55][55];\n\nvoid dfs(int lx, int ly, int rx, int ry){\n\t//cout<<lx<<\" \"<<ly<<\": \"<<rx<<\" \"<<ry<<endl;\n\tif(flag) return;\n\n\tif(rooml[ly][lx] == '%' && roomr[ry][rx] == '%') {\n\t\tflag = true;\n\t\treturn;\n\t}else if(rooml[ly][lx] == '%' || roomr[ry][rx] == '%') return;\n\n\tif(ls[lx][ly][rx][ry]) return;\n\tls[lx][ly][rx][ry] = true;\n\n\tREP(k,0,4){\n\t\tint nlx = lx + ldx[k], nly = ly + ldy[k];\n\t\tif(!CH(nly,0,H) || !CH(nlx,0,W)){\n\t\t\tnlx = lx;\n\t\t\tnly = ly;\n\t\t}else if(rooml[nly][nlx]=='#'){\n\t\t\tnlx = lx;\n\t\t\tnly = ly;\n\t\t}\n\n\t\tint nrx = rx + rdx[k], nry = ry + rdy[k];\n\t\tif(!CH(nry,0,H) || !CH(nrx,0,W)){\n\t\t\tnrx = rx;\n\t\t\tnry = ry;\n\t\t}else if(roomr[nry][nrx]=='#'){\n\t\t\tnrx = rx;\n\t\t\tnry = ry;\n\t\t}\n\t\tdfs(nlx, nly, nrx, nry);\n\t}\n\treturn;\n}\n\nint main() {\n\n\twhile(1){\n\t\tcin>>W>>H;\n\t\tif(W==0 && H==0) break;\n\t\tREP(i,0,H){\n\t\t\tcin>>rooml[i]>>roomr[i];\n\t\t}\n\n\t\tint slx, sly, srx, sry;\n\t\tREP(i,0,H){\n\t\t\tREP(j,0,W){\n\t\t\t\tif(rooml[i][j] == 'L'){\n\t\t\t\t\tslx = j;\n\t\t\t\t\tsly = i;\n\t\t\t\t}\n\t\t\t\tif(roomr[i][j] == 'R'){\n\t\t\t\t\tsrx = j;\n\t\t\t\t\tsry = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tflag = false;\n\t\tREP(i,0,55)REP(j,0,55)REP(k,0,55)REP(l,0,55) ls[i][j][k][l] = false;\n\t\tdfs(slx, sly, srx, sry);\n\n\t\tif(flag) cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nstruct pos {\n    int x, y;\n};\n\nusing P = pair<pos, pos>;\n\nint main() {\n    int W, H;\n    while(cin >> W >> H, W) {\n        vector<string> v1(H), v2(H);\n        for(int i=0; i<H; ++i) {\n            cin >> v1[i] >> v2[i];\n        }\n\n        pos lg, rg;\n        queue<P> que;\n        vector<vector<vector<vector<int>>>> d(50, vector<vector<vector<int>>>(50, vector<vector<int>>(50, vector<int>(50, -1))));\n        {\n            pos L, R;\n            for(int i=0; i<H; ++i) {\n                for(int j=0; j<W; ++j) {\n                    if(v1[i][j] == 'L') {\n                        L.x = j; L.y = i;\n                    } else if(v1[i][j] == '%') {\n                        lg.x = j; lg.y = i;\n                    }\n                    if(v2[i][j] == 'R') {\n                        R.x = j; R.y = i;\n                    } else if(v2[i][j] == '%') {\n                        rg.x = j; rg.y = i;\n                    }\n                }\n            }\n            auto p = make_pair(L, R);\n            que.push(p);\n            d[L.x][L.y][R.x][R.y] = 0;\n            \n        }\n        while(!que.empty()) {\n            P p = que.front(); que.pop();\n            pos& l = p.first; pos& r = p.second;\n            //cout << \"l: \" << l.x << \" \" << l.y << \"     R: \" << r.x << \" \" << r.y << endl;\n            int dx[4] = {0, 1, 0, -1},\n                dy[4] = {1, 0, -1, 0};\n            for(int i=0; i<4; ++i) {\n                pos nl{l.x - dx[i], l.y + dy[i]};\n                pos nr{r.x + dx[i], r.y + dy[i]};\n                if(nl.x < 0 || W <= nl.x || nl.y < 0 || H <= nl.y || v1[nl.y][nl.x] == '#') {\n                    nl.x += dx[i];\n                    nl.y -= dy[i];\n                }\n                if(nr.x < 0 || W <= nr.x || nr.y < 0 || H <= nr.y || v2[nr.y][nr.x] == '#') {\n                    nr.x -= dx[i];\n                    nr.y -= dy[i];\n                }\n                auto np = make_pair(nl, nr);\n                if(d[nl.x][nl.y][nr.x][nr.y] != -1) {\n                    continue;\n                }\n                if(v1[nl.y][nl.x] != '%' && v2[nr.y][nr.x] != '%') {\n                    que.push(np);\n                }\n                d[nl.x][nl.y][nr.x][nr.y] = d[l.x][l.y][r.x][r.y] + 1;\n                //cout << \"nl: \" << nl.x << \" \" << nl.y << \"    nR: \" << nr.x << \" \" << nr.y << endl;\n            }\n        }\n        //cout << lg.x << \" \" << lg.y << \" \" << rg.x << \" \" << rg.y << endl;\n        if(d[lg.x][lg.y][rg.x][rg.y] != -1) {\n            cout << \"Yes\" << endl;\n        } else {\n            cout << \"No\" << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n\n#define F first\n#define S second\n\nusing namespace std;\n\nconst int MAX = 100;\ntypedef pair<int,int> P;\nchar M[2][MAX][MAX];\nbool come[MAX][MAX][MAX][MAX];\nint W,H;\nP s1,s2;\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\n\nvoid init(){\n  memset(come,false,sizeof(come));\n}\n\nvoid print(){\n  for(int x = 0; x < 2; x++){\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++) cout << M[x][i][j];\n      cout << endl;\n    }\n    cout << endl<< endl;\n  }\n}\n\nvoid input(){\n  for(int i = 0; i < H; i++)\n    for(int x = 0; x < 2; x++)\n      for(int j = 0; j < W; j++){\n\tcin >> M[x][i][j];\n\tif(M[x][i][j] == 'L' && !x) s1 = P(i,j);\n\tif(M[x][i][j] == 'R' && x) s2 = P(i,j);\n\t}\n}\n\nbool isInside(int x, int y){return 0<=x&&x<W&&0<=y&&y<H;}\n\nbool rec(int x1, int y1, int x2, int y2){\n\n  if(come[x1][y1][x2][y2]) return false;\n  come[x1][y1][x2][y2] = true;\n  //cout << x1 <<  \" \" << y1 << \" \" << x2 << \" \" << y2 <<endl;\n  if(M[0][y1][x1] == '%' && M[1][y2][x2] == '%') return true;\n  if(M[0][y1][x1] == '%' || M[1][y2][x2] == '%') return false;\n  \n  bool tmp = false;\n\n  for(int i = 0; i < 4; i++){\n    int nx1 = x1+dx[i];\n    int ny1 = y1+dy[i];\n    int nx2 = x2-dx[i];\n    int ny2 = y2+dy[i];\n    if(!isInside(nx1,ny1) || M[0][ny1][nx1] == '#'){\n      nx1 = x1;\n      ny1 = y1;\n    }\n    if(!isInside(nx2,ny2) || M[1][ny2][nx2] == '#'){\n      nx2 = x2;\n      ny2 = y2;\n    }\n    \n    if(!come[nx1][ny1][nx2][ny2]) tmp =(tmp||rec(nx1,ny1,nx2,ny2));\n  }\n  return tmp;\n} \n\nvoid solve(){\n  if(rec(s1.S,s1.F,s2.S,s2.F)) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n}\n\nint main(){\n  while(cin >> W >> H && W+H){\n    init();\n    input();\n    //   print();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<string>\nusing namespace std;\nint main(){\n  int w,h;\n  while(cin>>w>>h,w||h){\n    int i,j,k;\n    int inf = 1<<20;\n    int d[50][50][50][50];\n    //memset(d,inf,sizeof(d));\n    string sr[60],sl[60];\n    for(i=0;i<h;i++){\n      cin >> sr[i] >> sl[i];\n    }\n    for(i=0;i<h;i++){\n      cout << sr[i] << endl;\n    }\n    for(i=0;i<h;i++){\n      cout << sl[i] << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\ntemplate<typename T>\nvoid O(T t){\n  cout << t << endl;\n}\n\nconst ll mod = 1e9+7;\nconstexpr ll inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\nll w,h;\n\nbool search(int lx,int ly,int rx,int ry,vector<string> &l,vector<string> &r){\n  bool res = false;\n  /* rep(i,h){                    */\n  /*   rep(j,w){                  */\n  /*     if(i == ly  && j == lx){ */\n  /*       cout << \"*\" ;          */\n  /*     }                        */\n  /*     else                     */\n  /*       std::cout << l[i][j];  */\n  /*   }                          */\n  /*   cout << endl;              */\n  /* }                            */\n  /* rep(i,h){                    */\n  /*   rep(j,w){                  */\n  /*     if(i == ry  && j == rx){ */\n  /*       cout << \"*\" ;          */\n  /*     }                        */\n  /*     else                     */\n  /*       std::cout << r[i][j];  */\n  /*   }                          */\n  /*   cout << endl;              */\n  /* }                            */\n  /* std::cout << std::endl;      */\n  rep(i,4){\n    int nlx = lx + dx[i],nly = ly + dy[i],nrx = rx - dx[i],nry = ry + dy[i];\n    if(value(nlx,nly,w,h) && l[nly][nlx] == '.' && value(nrx,nry,w,h) && r[nry][nrx] == '.'){\n      l[ly][lx] = '#';\n      r[ry][rx] = '#';\n      res |= search(nlx,nly,nrx,nry,l,r);\n      l[nly][nlx] = '.';\n      r[nry][nrx] = '.';\n    }\n    if(value(nlx,nly,w,h) && l[nly][nlx] == '.' && value(nrx,nry,w,h) && r[nry][nrx] == '#'){\n      l[ly][lx] = '#';\n      res |= search(nlx,nly,rx,ry,l,r);\n      l[nly][nlx] = '.';\n    }\n    if(value(nlx,nly,w,h) && l[nly][nlx] == '#' && value(nrx,nry,w,h) && r[nry][nrx] == '.'){\n      r[ry][rx] = '#';\n      res |= search(lx,ly,nrx,nry,l,r);\n      r[nry][nrx] = '.';\n    }\n    if(value(nlx,nly,w,h) && l[nly][nlx] == '%' && value(nrx,nry,w,h) && r[nry][nrx] == '%'){\n      return true;\n    }\n  } \n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll lx,ly,rx,ry;\n  while(cin >> w >> h &&  w + h ){\n    vector<string> l(h),r(h);\n    rep(i,h){\n      cin >> l[i] >> r[i];\n      rep(j,w){\n        if(l[i][j] == 'L'){\n          ly = i;\n          lx = j;\n        }\n        if(r[i][j] == 'R'){\n          ry = i;\n          rx = j;\n        }\n      }\n    }\n    bool f = search(lx,ly,rx,ry,l,r);\n    std::cout << (f ? \"Yes\" : \"No\") << std::endl; \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define rep(i,n) REP(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n#define DBG(X) cout<<\" \"<<#X<<\" : \"<<X<<endl\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\n\nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\nconst ll LINF = 1e18;\n\nstruct Input\n{\n\tint n;char c;char str[10010];string s;ll l;double d;\n\tint nextInt(){scanf(\"%d\", &n);return n;}\n\tll nextLong(){scanf(\"%lld\", &l);return l;}\n\tdouble nextDouble(){scanf(\"%lf\", &d);return d;}\n\tchar nextChar(){scanf(\"%c\", &c);return c;}\n\tstring next(){scanf(\"%s\", str);return string(str);}\n\tstring nextLine(){getline(cin, s);return s;}\n};\nInput in;\n\nvector<vector<string> > s(2, vector<string>(51));\nmap<pair<pii, pii>, int> m;\n\nint dx[][4]={\n\t{-1,0,1,0},\n\t{1,0,-1,0}\n};\nint dy[]={0,-1,0,1};\n\nbool isOutOfRange(pii p, int w, int h){\n\treturn p.fi < 0 || p.fi >= h || p.se < 0 || p.se >= w;\n}\n\nint main(){\n\twhile(1){\n\t\tint w = in.nextInt(), h = in.nextInt();\n\t\tif(w == 0 && h == 0) break;\n\t\trep(i, h) s[0][i] = in.next(), s[1][i] = in.next();\n\t\tm.clear();\n\t\tpii p[2];\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(s[0][i][j] == 'L') p[0] = {i, j};\n\t\t\t\tif(s[1][i][j] == 'R') p[1] = {i, j};\n\t\t\t}\n\t\t}\n\t\tbool f = false;\n\t\tqueue<pair<pii, pii> > q;\n\t\tq.push({p[0], p[1]});\n\t\tpair<int,int> t[2];\n\t\twhile(!q.empty()){\n\t\t\tp[0] = q.front().fi;\n\t\t\tp[1] = q.front().se;\n\t\t\tq.pop();\n\t\t\t//cout<<p[0].fi<<\" \"<<p[0].se<<\" \"<<p[1].fi<<\" \"<<p[1].se<<endl;\n\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\tfor(int i = 0; i < 2; i++){\n\t\t\t\t\tt[i] = p[i];\n\t\t\t\t\tt[i].fi += dy[j];\n\t\t\t\t\tt[i].se += dx[i][j];\n\t\t\t\t\tif(isOutOfRange(t[i], w, h) || s[i][t[i].fi][t[i].se] == '#') t[i] = p[i];\n\t\t\t\t}\n\t\t\t\tif(m[{t[0], t[1]}] == 0){\n\t\t\t\t\tm[{t[0], t[1]}] = 1;\n\t\t\t\t\tq.push({t[0], t[1]});\n\t\t\t\t\tif(s[0][t[0].fi][t[0].se] == '%' && s[1][t[1].fi][t[1].se] == '%'){\n\t\t\t\t\t\tf = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\", f?\"Yes\" : \"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\n\nstruct Edge{int to,from,cost;};\n\n#define debug cout\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define SS stringstream\n#define X second\n#define Y first\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,-1,1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,-1,1,0};\n\nint used[50][50][50][50],w,h;\nstring l[50],r[50];\nint v[1000000][4],vi,vs;\n\nint main() {\n\tIL{\n\t\tcin>>w>>h;\n\t\tif(w==0&&h==0)break;\n\t\trep(i,h){\n\t\t\tcin>>l[i]>>r[i];\n\t\t}\n\t\tvint start(4);\n\t\tvint goal(4);\n\t\trep(i,h)rep(j,w){\n\t\t\tif(l[i][j]=='L'){\n\t\t\t\tstart[0]=i;\n\t\t\t\tstart[1]=j;\n\t\t\t}\n\t\t\tif(r[i][j]=='R'){\n\t\t\t\tstart[2]=i;\n\t\t\t\tstart[3]=j;\n\t\t\t}\n\t\t\tif(l[i][j]=='%'){\n\t\t\t\tgoal[0]=i;\n\t\t\t\tgoal[1]=j;\n\t\t\t}\n\t\t\tif(r[i][j]=='%'){\n\t\t\t\tgoal[2]=i;\n\t\t\t\tgoal[3]=j;\n\t\t\t}\n\t\t}\n\t\tvi=0;vs=1;\n\t\tv[0][0]=start[0];\n\t\tv[0][1]=start[1];\n\t\tv[0][2]=start[2];\n\t\tv[0][3]=start[3];\n\t\tmemset(used,0,sizeof(used));\n\t\tused[start[0]][start[1]][start[2]][start[3]]=1;\n\t\twhile(vi<vs){\n\t\t\tint *now=v[vi++];\n\t\t\trep(i,4){\n\t\t\t\tint next[4];\n\t\t\t\tnext[0]=now[0]+dy[i];\n\t\t\t\tnext[1]=now[1]+dx[i];\n\t\t\t\tnext[2]=now[2]+dy[i];\n\t\t\t\tnext[3]=now[3]-dx[i];\n\t\t\t\tif(next[0]<0||h<=next[0]||l[next[0]][now[1]]=='#')next[0]=now[0];\n\t\t\t\tif(next[1]<0||w<=next[1]||l[now[0]][next[1]]=='#')next[1]=now[1];\n\t\t\t\tif(next[2]<0||h<=next[2]||r[next[2]][now[3]]=='#')next[2]=now[2];\n\t\t\t\tif(next[3]<0||w<=next[3]||r[now[2]][next[3]]=='#')next[3]=now[3];\n\t\t\t\tif(used[next[0]][next[1]][next[2]][next[3]]==1)continue;\n\t\t\t\tused[next[0]][next[1]][next[2]][next[3]]=1;\n\t\t\t\tif(l[next[0]][next[1]]=='%')continue;\n\t\t\t\tif(r[next[2]][next[3]]=='%')continue;\n\t\t\t\trep(j,4)v[vs][j]=next[j];\n\t\t\t\t++vs;\n\t\t\t}\n\t\t}\n\t\tif(used[goal[0]][goal[1]][goal[2]][goal[3]])cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<queue>\n#define MAX 50\nusing namespace std;\nstruct Point{int x,y;};\nstruct P{\n  Point l,r;\n  int cost;\n};\nint main(){\n  int w,h;\n  while(cin>>w>>h,w||h){\n    int i,j,k;\n    int inf = 1<<20;\n    int d[MAX+1][MAX+1][MAX+1][MAX+1];\n    fill(d[0][0][0],d[MAX][MAX][MAX],inf);\n    string sr[60],sl[60];\n    for(i=0;i<h;i++){\n      cin >> sl[i] >> sr[i];\n    }\n    Point pr,pl,br,bl;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(sl[i][j]=='L'){\n\t  pl.x=j;pl.y=i;\n\t}\n\tif(sr[i][j]=='R'){\n\t  pr.x=j;pr.y=i;\n\t}\n      }\n    }\n    //cout << pl.x << \":\" << pl.y << endl;\n    //cout << pr.x << \":\" << pr.y << endl;\n    d[pl.x][pl.y][pr.x][pr.y]=0;\n    P p,b;\n    p.r=pr;\n    p.l=pl;\n    p.cost=d[pl.x][pl.y][pr.x][pr.y];\n    queue<P> q;\n    q.push(p);\n    bool f = false;\n    while(!q.empty()){\n      p=q.front();q.pop();\n      pl=p.l;pr=p.r;\n      if(p.cost>d[pl.x][pl.y][pr.x][pr.y]) continue;\n      d[pl.x][pl.y][pr.x][pr.y]=p.cost;\n      //cout << pl.x<<\":\"<<pl.y<<\":\"<<pr.x<<\":\"<<pr.y<<\"/\"<<p.cost<<endl;\n      if(sl[pl.y][pl.x]=='%'&&sr[pr.y][pr.x]=='%'){\n\tf=true;\n\tbreak;\n      }else if(sl[pl.y][pl.x]=='%') continue;\n      else if(sr[pr.y][pr.x]=='%') continue;\n      \n      p.cost++;\n      int lx[]={1,-1,0,0};int ly[]={0,0,1,-1};\n      int rx[]={-1,1,0,0};int ry[]={0,0,1,-1};\n      for(i=0;i<4;i++){\n\tbl=pl;br=pr;\n\tbl.x+=lx[i];bl.y+=ly[i];\n\tbr.x+=rx[i];br.y+=ry[i];\n\n\t//cout << bl.x<<\":\"<<bl.y<<\":\"<<br.x<<\":\"<<br.y<<\"/\"<<p.cost<<endl;\n\t\n\tif(bl.x<0) bl.x=0;\n\telse if(bl.x>=w) bl.x=w-1;\n\tif(bl.y<0) bl.y=0;\n\telse if(bl.y>=h) bl.y=h-1;\n\n\tif(br.x<0) br.x=0;\n\telse if(br.x>=w) br.x=w-1;\n\tif(br.y<0) br.y=0;\n\telse if(br.y>=h) br.y=h-1;\n\n\tif(sl[bl.y][bl.x]=='#'){\n\t  bl.x-=lx[i];bl.y-=ly[i];\n\t}\n\tif(sr[br.y][br.x]=='#'){\n\t  br.x-=rx[i];br.y-=ry[i];\n\t}\n\tp.r=br;p.l=bl;\n\tq.push(p);\n      }\n    }\n    if(f) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<math.h>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  int h, w;\n  while(cin >> w >> h && h != 0){\n    vector< vector<char> > L(h);\n    vector< vector<char> > R(h);\n    pair<int, int> ls;\n    pair<int, int> rs;\n    char a;\n    for(int i = 0; i < h ; i++){\n      for(int j = 0; j < w ; j++){\n        cin >> a;\n        L[i].push_back(a);\n        if(a == 'L') ls = make_pair(i, j);\n      }\n      for(int j = 0; j < w ; j++){\n        cin >> a;\n        R[i].push_back(a);\n        if(a == 'R') rs = make_pair(i, j);\n      }\n    }\n\n    int flag = 0;\n    vector< pair<int, int> > move;\n    move.push_back(make_pair(0,1));\n    move.push_back(make_pair(1,0));\n    move.push_back(make_pair(0,-1));\n    move.push_back(make_pair(-1,0));\n    int nodes[50][50][50][50] = {{{{0}}}};\n    nodes[ls.first][ls.second][rs.first][rs.second] = 1;\n    queue< pair< pair<int, int> , pair<int, int> > > q;\n    q.push(make_pair(ls, rs));\n    while(!q.empty()){\n      pair<pair<int, int>, pair<int, int> > k = q.front();\n      q.pop();\n      int lv = k.first.first;\n      int lh = k.first.second;\n      int rv = k.second.first;\n      int rh = k.second.second;\n      for(int i = 0; i < 4; i++){\n        pair<int, int> m = move[i];\n        int mv = m.first;\n        int mh = m.second;\n        int a,b,c,d;\n        if(lv + mv >= 0 && lv + mv < h) a = lv + mv;\n        else a = lv;\n        if(lh + mh >= 0 && lh + mh < w) b = lh + mh;\n        else b = lh;\n        if(rv + mv >= 0 && rv + mv < h) c = rv + mv;\n        else c = rv;\n        if(rh - mh >= 0 && rh - mh < w) d = rh - mh;\n        else d = rh;\n        if(L[a][b] == '%' && R[c][d] == '%') flag = 1;\n        else if(L[a][b] == '%' || R[c][d] == '%') continue;\n        if(L[a][b] == '#'){\n          a = lv;\n          b = lh;\n        }\n        if(R[c][d] == '#'){\n          c = rv;\n          d = rh;\n        }\n        if(nodes[a][b][c][d] != 1){\n          q.push(make_pair(make_pair(a,b), make_pair(c,d)));\n          nodes[a][b][c][d] = 1;\n        }\n      }\n    }\n    if(flag == 1) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<cstring>\nusing namespace std;\n\nstruct Pos{int x,y;};\nstruct Pair{Pos LIN,REN;};\nbool same(Pos a,Pos b){return a.x==b.x && a.y==b.y;}\nbool same(Pair a,Pair b){return same(a.LIN,b.LIN) && same(a.REN,b.REN);}\nbool operator<(Pos a,Pos b){return a.x!=b.x?a.x<b.x:a.y<b.y;}\nbool operator!=(Pos a,Pos b){return a.x!=b.x || a.y!=b.y;}\nbool operator<(Pair a,Pair b){return a.LIN!=b.LIN?a.LIN<b.LIN:a.REN<b.REN;}\n\nPair start,goal;\n\nint W,H;\nchar RoomL[52][52],RoomR[52][52];\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n\nbool bfs()\n{\n  map<Pair,bool>visited;\n  queue<Pair>q;\n  q.push(start);\n  Pair now,next;\n  while(!q.empty()){\n    now=q.front();\n    q.pop();\n    if(same(now,goal))return true;\n    if(same(now.LIN,goal.LIN))continue;\n    if(same(now.REN,goal.REN))continue;\n    visited[now]=true;\n    for(int i=0;i<4;i++){\n      next=now;\n      next.LIN.x+=dx[i];\n      next.LIN.y+=dy[i];\n      next.REN.x+=-dx[i];\n      next.REN.y+=dy[i];\n      if(RoomL[next.LIN.y][next.LIN.x]=='#')next.LIN=now.LIN;\n      if(RoomR[next.REN.y][next.REN.x]=='#')next.REN=now.REN;\n      if(visited.count(next))continue;\n      q.push(next);\n    }\n  }\n  return false;\n}\n\nint main()\n{\n  string l,r;\n  while(cin>>W>>H,W|H){\n    memset(RoomL,'#',sizeof(RoomL));\n    memset(RoomR,'#',sizeof(RoomR));\n    for(int i=1;i<=H;i++){\n      cin>>l>>r;\n      for(int j=1;j<=W;j++){\n\tRoomL[i][j]=l[j-1];\n\tRoomR[i][j]=r[j-1];\n\tif(RoomL[i][j]=='L'){\n\t  start.LIN.x=j;\n\t  start.LIN.y=i;\n\t}\n\tif(RoomL[i][j]=='%'){\n\t  goal.LIN.x=j;\n\t  goal.LIN.y=i;\n\t}\n\tif(RoomR[i][j]=='R'){\n\t  start.REN.x=j;\n\t  start.REN.y=i;\n\t}\n\tif(RoomR[i][j]=='%'){\n\t  goal.REN.x=j;\n\t  goal.REN.y=i;\n\t}\n      }\n    }\n    puts(bfs()?\"Yes\":\"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\n\n\nint w,h;\nchar L[53][53], R[53][53];\nchar memo[53][53][53][53];\nstruct state{\n\tint lx,ly,rx,ry;\n};\nint dl[4][2]={{0,1},{1,0},{-1,0},{0,-1}};\nint dr[4][2]={{0,-1},{1,0},{-1,0},{0,1}};\nbool dfs(state s){\n\tif(memo[s.ly][s.lx][s.ry][s.rx]) return false;\n\tif(L[s.ly][s.lx]=='%' && R[s.ry][s.rx]=='%') return true;\n\tif(L[s.ly][s.lx]=='%' || R[s.ry][s.rx]=='%') return false;\n\tmemo[s.ly][s.lx][s.ry][s.rx] = 1;\n\tfor(int i=0;i<4;i++){\n\t\tstate t = s;\n\t\tif(L[t.ly+dl[i][0]][t.lx+dl[i][1]] != '#'){\n\t\t\tt.ly += dl[i][0];\n\t\t\tt.lx += dl[i][1];\n\t\t}\n\t\tif(R[t.ry+dr[i][0]][t.rx+dr[i][1]] != '#'){\n\t\t\tt.ry += dr[i][0];\n\t\t\tt.rx += dr[i][1];\n\t\t}\n\t\tif(dfs(t)) return true;\n\t}\n\treturn false;\n}\n\nmain(){\n\tint i,j;\n\twhile(cin >> w >> h, w){\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tfor(i=0;i<53;i++)for(j=0;j<53;j++)L[i][j]=R[i][j]='#';\n\t\tint ans;\n\t\tstate s;\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tcin >> L[i][j];\n\t\t\t\tif(L[i][j] == 'L'){\n\t\t\t\t\ts.lx=j;s.ly=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tcin >> R[i][j];\n\t\t\t\tif(R[i][j] == 'R'){\n\t\t\t\t\ts.rx=j;s.ry=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (dfs(s)?\"Yes\":\"No\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n#define REP(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\nstruct data{\n    int ly,lx,ry,rx;\n    data(int ly,int lx,int ry,int rx):ly(ly),lx(lx),ry(ry),rx(rx){}\n};\n\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\nconst int INF=1e9;\n\nint H,W;\nchar L[50][50],R[50][50];\nint dp[50][50][50][50];\nint sly,slx,sry,srx;\nint gly,glx,gry,grx;\nbool ok(int y,int x,bool isL){\n    if(isL)return !(y<0||y>=H||x<0||x>=W||L[y][x]=='#');\n    return !(y<0||y>=H||x<0||x>=W||R[y][x]=='#');\n}\n\nvoid solve(){\n    queue<data>q;\n    REP(i,50)REP(j,50)REP(k,50)REP(l,50)dp[i][j][k][l]=INF;\n    dp[sly][slx][sry][srx]=0;\n    q.push(data(sly,slx,sry,srx));\n    while(q.size()){\n        data d=q.front();q.pop();\n        REP(i,4){\n            int nly=d.ly+dy[i],nlx=d.lx+dx[i];\n            int nry=d.ry+dy[i],nrx=d.rx-dx[i];\n            if(!ok(nly,nlx,true)){\n                nly=d.ly;nlx=d.lx;\n            }\n            if(!ok(nry,nrx,false)){\n                nry=d.ry;nrx=d.rx;\n            }\n            if(dp[nly][nlx][nry][nrx]!=INF)continue;\n            dp[nly][nlx][nry][nrx]=dp[nly][nlx][nry][nrx]+1;\n            if((gly==nly&&glx==nlx)&&!(gry==nry&&grx==nrx))continue;\n            if(!(gly==nly&&glx==nlx)&&(gry==nry&&grx==nrx))continue;\n            q.push(data(nly,nlx,nry,nrx));\n        }\n    }\n    if(dp[gly][glx][gry][grx]!=INF)cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n}\n\nint main(){\n    while(1){\n        cin>>W>>H;\n        if(W==0&&H==0)break;\n        REP(i,H){\n            REP(j,W)cin>>L[i][j];\n            REP(j,W)cin>>R[i][j];\n        }\n        REP(i,H){\n            REP(j,W){\n                if(L[i][j]=='L'){\n                    sly=i;slx=j;\n                }\n                if(L[i][j]=='%'){\n                    gly=i;glx=j;\n                }\n                if(R[i][j]=='R'){\n                    sry=i;srx=j;\n                }\n                if(R[i][j]=='%'){\n                    gry=i;grx=j;\n                }\n            }\n        }\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nconst int N = 52;\nchar l[N][N], r[N][N];\nint dp[N][N][N][N];\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (int W, H; cin >> W >> H&&H;) {\n\t\tmemset(l, 0, sizeof(l));\n\t\tmemset(r, 0, sizeof(r));\n\t\tmemset(dp, 0x3f, sizeof(dp));\n\t\tint sli, slj, sri, srj;\n\t\tint gli, glj, gri, grj;\n\t\trep(i, 0, H) {\n\t\t\trrep(j, 0, W) {\n\t\t\t\tcin >> l[i][j];\n\t\t\t\tif (l[i][j] == 'L') {\n\t\t\t\t\tsli = i, slj = j;\n\t\t\t\t}\n\t\t\t\tif (l[i][j] == '%') {\n\t\t\t\t\tgli = i, glj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j, 0, W) {\n\t\t\t\tcin >> r[i][j];\n\t\t\t\tif (r[i][j] == 'R') {\n\t\t\t\t\tsri = i, srj = j;\n\t\t\t\t}\n\t\t\t\tif (r[i][j] == '%') {\n\t\t\t\t\tgri = i, grj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tusing T = tuple<int, int, int, int, int>;\n\t\tqueue<T> q;\n\t\tq.emplace(sli, slj, sri, srj, 0);\n\t\tauto inrange = [&](int i, int j) { return i >= 0 && i < H && j >= 0 && j < W; };\n\t\twhile (q.size()) {\n\t\t\tint li, lj, ri, rj, c;\n\t\t\ttie(li, lj, ri, rj, c) = q.front(); q.pop();\n\t\t\tif (dp[li][lj][ri][rj] != INF)continue;\n\t\t\tdp[li][lj][ri][rj] = c;\n\t\t\tstatic const int di[] = { 1,0,-1,0 };\n\t\t\tstatic const int dj[] = { 0,1,0,-1 };\n\t\t\trep(k, 0, 4) {\n\t\t\t\tint nli = li + di[k],\n\t\t\t\t\tnlj = lj + dj[k],\n\t\t\t\t\tnri = ri + di[k],\n\t\t\t\t\tnrj = rj + dj[k];\n\t\t\t\tif (!inrange(nli, nlj) && !inrange(nri, nrj))continue;\n\t\t\t\tif (!inrange(nli, nlj))nli -= di[k], nlj -= dj[k];\n\t\t\t\tif (!inrange(nri, nrj))nri -= di[k], nrj -= dj[k];\n\t\t\t\tif (l[nli][nlj] == '#'&&r[nri][nrj] == '#')continue;\n\t\t\t\tif (l[nli][nlj] == '#')nli -= di[k], nlj -= dj[k];\n\t\t\t\tif (r[nri][nrj] == '#')nri -= di[k], nrj -= dj[k];\n\t\t\t\tif (dp[nli][nlj][nri][nrj] != INF)continue;\n\t\t\t\tq.emplace(nli, nlj, nri, nrj, c + 1);\n\t\t\t}\n\t\t}\n\t\tif (dp[gli][glj][gri][grj] != INF) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <queue>\n#include <set>\nusing namespace std;\n\n#define N 64\n\nchar Rin[N][N],Len[N][N];\nchar memo[N][N][N][N];\nint W,H,xr,xl,yl,yr;\nconst int dx[] = {0,1,0,-1};\nconst int dy[] = {-1,0,1,0};\n\nint main()\n{\t// LenRin\n\t//puts(\"test0\");\n\twhile(cin>>W>>H,W||H){\n\t\tcin.ignore();\n\t\t//puts(\"test1\");\n\t\tmemset(Rin,'#',sizeof(Rin));\n\t\tmemset(Len,'#',sizeof(Len));\n\t\tmemset(memo,0,sizeof(memo));\n\t\tfor(int i=0;i<H;i++)scanf(\"%s %s\",Len[i],Rin[i]);\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tif(Len[i][j]=='L')\n\t\t\t\t\txl=j,yl=i;\n\t\t\t\tif(Rin[i][j]=='R')\n\t\t\t\t\txr=j,yr=i;\n\t\t\t}\n\t\t}\n\t\tmemo[yl][xl][yr][xr] = 1;\n\t\t//printf(\"start:(%d,%d),(%d,%d)\\n\",yl,xl,yr,xr);\n\t\tqueue<pair<int,int> > rin,len;\n\t\trin.push(make_pair(xr,yr));\n\t\tlen.push(make_pair(xl,yl));\n\t\tint flag = 0;\n\t\twhile(!rin.empty() && !flag){\n\t\t\txr = rin.front().first;\n\t\t\tyr = rin.front().second;\n\t\t\txl = len.front().first;\n\t\t\tyl = len.front().second;\n\t\t\t\n\t\t\trin.pop(); len.pop();\n\t\t\t\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tint txR = xr + dx[k];\n\t\t\t\tint tyR = yr + dy[k];\n\t\t\t\tint txL = xl + dx[k]*-1;\n\t\t\t\tint tyL = yl + dy[k];\n\t\t\t\tif( txR<0 || tyR<0 || txR>=W || tyR>=H || Rin[tyR][txR]=='#')\n\t\t\t\t\ttxR = xr, tyR = yr;\n\t\t\t\tif( txL<0 || tyL<0 || txL>=W || tyL>=H || Len[tyL][txL]=='#')\n\t\t\t\t\ttxL = xl, tyL = yl;\n\t\t\t\tif( memo[tyL][txL][tyR][txR]==1)continue;\n\t\t\t\tif( Rin[tyR][txR]=='%' && Len[tyL][txL]=='%'){\n\t\t\t\t\tflag=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif( Rin[tyR][txR]=='%' || Len[tyL][txL]=='%')\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tmemo[tyL][txL][tyR][txR] = 1;\n\t\t\t\t\n\t\t\t\trin.push(make_pair(txR,tyR));\n\t\t\t\tlen.push(make_pair(txL,tyL));\n\t\t\t\t//printf(\"(%d,%d) (%d,%d)\\n\",tyL,txL,tyR,txR);\n\t\t\t}\n\t\t}\n\t\tputs(flag?\"Yes\":\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\nbool used[51][51][51][51];\nint roomL[51][51], roomR[51][51];\n\nint s_to_i(char c) {\n  switch (c) {\n  case '#':\n    return -1;\n  case '.':\n    return 0;\n  case 'L':\n  case 'R':\n    return 1;\n  case '%':\n    return 2;\n  }\n}\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while (true) {\n    int R, C;\n    cin >> C >> R;\n    if (R == 0 && C == 0) break;\n    REP(i, R) {\n      string rowL, rowR;\n      cin >> rowL >> rowR;\n      REP(j, C) {\n\troomL[i][j] = s_to_i(rowL[j]);\n\troomR[i][j] = s_to_i(rowR[j]);\n      }\n    }\t  \n\n    int slr = 0, slc = 0, elr = 0, elc = 0, srr = 0, src = 0, err = 0, erc = 0;\n    REP(r, R) REP(c, C) {\n      if (roomL[r][c] == 1) slr = r, slc = c;\n      else if (roomL[r][c] == 2) elr = r, elc = c;\n      if (roomR[r][c] == 1) srr = r, src = c;\n      else if (roomR[r][c] == 2) err = r, erc = c;\n    }\n    //cout << slr << ' ' << slc << ' ' << elr << ' ' << elc << ' ' << srr << ' ' << src << ' ' << err << ' ' << erc << endl;\n    REP(i, R) REP(j, C) REP(k, R) REP(l, C) used[i][j][k][l] = false;\n    \n    queue<P> que;\n    que.push(P(slr * C + slc, srr * C + src));\n\n    bool flag = false;\n    while (!que.empty()) {\n      P p = que.front(); que.pop();\n      int lr = p.first / C, lc = p.first % C, rr = p.second / C, rc = p.second % C;\n      //cout << lr << ' ' << lc << ' ' << rr << ' ' << rc << endl;\n      if (lr == elr && lc == elc && rr == err && rc == erc) {\n\tflag = true;\n\tbreak;\n      } else if (used[lr][lc][rr][rc] || (lr == elr && lc == elc) || (rr == err && rc == erc)) {\n\tcontinue;\n      }\n\n      used[lr][lc][rr][rc] = true;\n      REP(i, 4) {\n\tint nlr = lr + dr[i], nlc = lc + dc[i], nrr = rr + dr[(i+2*(i&1))%4], nrc = rc + dc[(i+2*(i&1))%4];\n\tif (nlr < 0 || nlr >= R || nlc < 0 || nlc >= C || roomL[nlr][nlc] == -1) nlr = lr, nlc = lc;\n\tif (nrr < 0 || nrr >= R || nrc < 0 || nrc >= C || roomR[nrr][nrc] == -1) nrr = rr, nrc = rc;\n\tif (!used[nlr][nlc][nrr][nrc]) que.push(P(nlr * C + nlc, nrr * C + nrc));\n      }\n    }\n    cout << (flag ? \"Yes\" : \"No\") << endl;    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\nconst ld eps=1e-8;\nint d1[4] = { 1,0,-1,0 };\nint d2[4] = { 0,1,0,-1 };\nint d3[4] = { 0,-1,0,1 };\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h, w) {\n\t\tchar fi1[52][52]; char fi2[52][52];\n\t\trep(i, 52) {\n\t\t\trep(j, 52) {\n\t\t\t\tfi1[i][j] = fi2[i][j] = '#';\n\t\t\t}\n\t\t}\n\t\tstring s, t;\n\t\tP s1, s2, g1, g2;\n\t\trep1(i, h) {\n\t\t\tcin >> s >> t;\n\t\t\trep1(j, w) {\n\t\t\t\tfi1[i][j] = s[j - 1];\n\t\t\t\tif (fi1[i][j] == '%') {\n\t\t\t\t\tg1 = { i,j };\n\t\t\t\t}\n\t\t\t\telse if (fi1[i][j] == 'L') {\n\t\t\t\t\ts1 = { i,j };\n\t\t\t\t}\n\t\t\t}\n\t\t\trep1(j, w) {\n\t\t\t\tfi2[i][j] = t[j - 1];\n\t\t\t\tif (fi2[i][j] == '%') {\n\t\t\t\t\tg2 = { i,j };\n\t\t\t\t}\n\t\t\t\telse if (fi2[i][j] == 'R') {\n\t\t\t\t\ts2 = { i,j };\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint used[52][52][52][52] = {};\n\t\tqueue<pair<P, P>> v;\n\t\tbool f = false;\n\t\tv.push({ s1, s2 });\n\t\tused[s1.first][s1.second][s2.first][s2.second] = 1;\n\t\twhile (!v.empty()) {\n\t\t\tpair<P, P> now = v.front();\n\t\t\tP n1 = now.first; P n2 = now.second; v.pop();\n\t\t\tif (n1 == g1 && n2 == g2) {\n\t\t\t\tf = true; break;\n\t\t\t}\n\t\t\telse if (n1 == g1 || n2 == g2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trep(i, 4) {\n\t\t\t\tP nex1 = { n1.first + d1[i],n1.second + d2[i] };\n\t\t\t\tP nex2 = { n2.first + d1[i],n2.second + d3[i] };\n\t\t\t\tif (fi1[nex1.first][nex1.second] == '#') {\n\t\t\t\t\tnex1 = n1;\n\t\t\t\t}\n\t\t\t\tif (fi2[nex2.first][nex2.second] == '#') {\n\t\t\t\t\tnex2 = n2;\n\t\t\t\t}\n\t\t\t\tif (!used[nex1.first][nex1.second][nex2.first][nex2.second]) {\n\t\t\t\t\tused[nex1.first][nex1.second][nex2.first][nex2.second] = 1;\n\t\t\t\t\tv.push({ nex1,nex2 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (f) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nconst int N = 50;\n\nclass State{\npublic:\n  int ly, lx, ry, rx;\n};\n\nint h, w;\n\nbool visited[N][N][N][N];\nchar data[2][N][N];\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nbool bfs(int sly, int slx, int sry, int srx){\n  State u, v;\n  u.ly = sly;\n  u.lx = slx;\n  u.ry = sry;\n  u.rx = srx;\n  queue<State> Q;\n  Q.push(u);\n  while(!Q.empty()){\n    u = Q.front(); Q.pop();\n  //cout << ly << ' ' << lx << ' ' << ry << ' ' << rx << endl;\n    if(data[0][u.ly][u.lx] == '%' && data[1][u.ry][u.rx] == '%') return true;\n    else if(data[0][u.ly][u.lx] == '%' || data[1][u.ry][u.rx] == '%') continue;\n    for(int i=0;i<4;i++){\n      int lty = u.ly + dy[i];\n      int ltx = u.lx + dx[i];\n      int rty = u.ry + dy[i];\n      int rtx = u.rx - dx[i];\n      //cout << \"       \" << lty << ' ' << ltx << ' ' << rty << ' ' << rtx << endl;\n      if(lty<0 || lty>=h){\n\tlty = u.ly;\n\tltx = u.lx;\n      }\n      if(ltx<0 || ltx>=w){\n\tlty = u.ly;\n\tltx = u.lx;\n      }\n      if(rty<0 || rty>=h){\n\trty = u.ry;\n\trtx = u.rx;\n      }\n      if(rtx<0 || rtx>=w){\n\trty = u.ry;\n\trtx = u.rx;\n      }\n      if(data[0][lty][ltx] == '#'){\n\tlty = u.ly;\n\tltx = u.lx;\n      }\n      if(data[1][rty][rtx] == '#'){\n\trty = u.ry;\n\trtx = u.rx;\n      }\n      if(visited[lty][ltx][rty][rtx]) continue;\n      visited[lty][ltx][rty][rtx] = true;\n      v.ly = lty;\n      v.lx = ltx;\n      v.ry = rty;\n      v.rx = rtx;\n      Q.push(v);\n    }\n  }\n  return false;\n}\n\nmain(){\n  int slx, sly, srx, sry;\n  while(cin >> w >> h){\n    if(h == 0 && w == 0) break;\n    fill(visited[0][0][0], visited[N][0][0], false);\n    for(int i=0;i<h;i++){\n      for(int k=0;k<2;k++){\n\tfor(int j=0;j<w;j++){\n\t  cin >> data[k][i][j];\n\t  if(data[k][i][j] == 'L'){\n\t    slx = j;\n\t    sly = i;\n\t    data[k][i][j] = '.';\n\t  }else if(data[k][i][j] == 'R'){\n\t    srx = j;\n\t    sry = i;\n\t    data[k][i][j] = '.';\n\t  }\n\t}\n      }\n    }\n    if(bfs(sly, slx, sry, srx)) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define reps(i,s,n) for(int i=s; i<n; i++)\n#define all(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\nstruct node {\n\tpii lp;\n\tpii rp;\n\tnode( pii l, pii r ) {\n\t\tlp = l;\n\t\trp = r;\n\t}\n};\n\nbool visit[55][55][55][55] = {};\n\nint main() {\n\tint w, h;\n\twhile( cin >> w >> h, w||h ) {\n\t\tw+=1;\n\t\th+=1;\n\t\tstring fl[h+1], fr[h+1];\n\t\trep(y,h+1) {\n\t\t\tfl[y] = '#';\n\t\t\tfr[y] = '#';\n\t\t}\n\t\trep(x,w) {\n\t\t\tfl[0] += '#';\n\t\t\tfl[h] += '#';\n\t\t\tfr[0] += '#';\n\t\t\tfr[h] += '#';\n\t\t}\n\t\tint lx, ly, rx, ry;\n\t\tfor(int y=1; y<h; y++) {\n\t\t\tstring in;\n\t\t\tcin >> in;\n\t\t\tfl[y] += in + '#';\n\t\t\tcin >> in;\n\t\t\tfr[y] += in + '#';\n\t\t\treverse( fr[y].begin(), fr[y].end() );\n\t\t\tfor(int x=1; x<=w; x++) {\n\t\t\t\tif( fl[y][x] == 'L' ) {\n\t\t\t\t\tfl[y][x] = '.';\n\t\t\t\t\tlx = x; ly = y;\n\t\t\t\t}\n\t\t\t\tif( fr[y][x] == 'R' ) {\n\t\t\t\t\tfr[y][x] = '.';\n\t\t\t\t\trx = x; ry = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ok = false;\n\t\tqueue<node> que;\n\t\tque.push(node(pii(lx, ly), pii(rx, ry)));\n\t\tmemset( visit, 0, sizeof(visit) );\n\t\twhile( !que.empty() ) {\n\t\t\tnode nd = que.front();\n\t\t\tque.pop();\n\t\t\tif( visit[nd.lp.first][nd.lp.second][nd.rp.first][nd.rp.second] ) continue;\n\t\t\tvisit[nd.lp.first][nd.lp.second][nd.rp.first][nd.rp.second] = true;\n\t\t\tif( fl[nd.lp.second][nd.lp.first]=='%' && fr[nd.rp.second][nd.rp.first]=='%' ) {\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif( fl[nd.lp.second][nd.lp.first]=='%' || fr[nd.rp.second][nd.rp.first]=='%' )\n\t\t\t\tcontinue;\n\t\t\tint dx[4] = {-1, 0, 1, 0};\n\t\t\tint dy[4] = {0, -1, 0, 1};\n\t\t\trep(i, 4) {\n\t\t\t\tint nlx = nd.lp.first  + dx[i];\n\t\t\t\tint nly = nd.lp.second + dy[i];\n\t\t\t\tint nrx = nd.rp.first  + dx[i];\n\t\t\t\tint nry = nd.rp.second + dy[i];\n\t\t\t\tif( !visit[nlx][nrx][nly][nry] ) {\n\t\t\t\t\tint wall = 0;\n\t\t\t\t\tif( fl[nly][nlx] == '#' ) {\n\t\t\t\t\t\tnly-=dy[i];  nlx-=dx[i];\n\t\t\t\t\t\twall++;\n\t\t\t\t\t}\n\t\t\t\t\tif( fr[nry][nrx] == '#' ) {\n\t\t\t\t\t\tnry-=dy[i];  nrx-=dx[i];\n\t\t\t\t\t\twall++;\n\t\t\t\t\t}\n\t\t\t\t\tif( wall < 2 ) {\n\t\t\t\t\t\tque.push( node(pii(nlx, nly), pii(nrx, nry)) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (ok ? \"Yes\" : \"No\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint w, h;\nstring l[51], r[51];\nint ldx[4] = {1, 0, -1, 0};\nint ldy[4] = {0, 1, 0, -1};\nint rdx[4] = {1, 0, -1, 0};\nint rdy[4] = {0, -1, 0, 1};\nint lsx, lsy, rsx, rsy, lgx, lgy, rgx, rgy;\nbool lischecked[52][52], rischecked[52][52];\n\nbool solve(int lx, int ly, int rx, int ry){\n    queue<int> rxqu, ryqu, lxqu, lyqu;\n    rxqu.push(rx);\n    ryqu.push(ry);\n    lxqu.push(lx);\n    lyqu.push(ly);\n    while(!rxqu.empty()){\n        lx = lxqu.front();\n        ly = lyqu.front();\n        rx = rxqu.front();\n        ry = ryqu.front();\n        lxqu.pop();\n        lyqu.pop();\n        rxqu.pop();\n        ryqu.pop();\n        if(lx == lgx && ly == lgy && rx == rgx && ry == rgy) return true;\n        if((lx == lgx && ly == lgy) || (rx == rgx && ry == rgy)) continue;\n        for(int i = 0; i < 4; i++){\n            int nlx = lx + ldx[i], nly = ly + ldy[i];\n            int nrx = rx + rdx[i], nry = ry + rdy[i];\n            if((nlx < 0 || nly < 0 || nlx >= h || nly >= w) && (nrx < 0 || nry < 0 || nrx >= h || nry >= w)) continue;\n            if(nlx < 0 || nlx >= h || nly < 0 || nly >= w){\n                nlx = lx;\n                nly = ly;\n            }\n            if(nrx < 0 || nrx >= h || nry < 0 || nry >= w){\n                nrx = rx;\n                nry = ry;\n            }\n            if((l[nlx][nly] == '#' && r[nrx][nry] == '#') || (lischecked[nlx][nly] && rischecked[nrx][nry])) continue;\n            if(l[nlx][nly] == '#'){\n                nlx = lx;\n                nly = ly;\n            }\n            if(r[nrx][nry] == '#'){\n                nrx = rx;\n                nry = ry;\n            }\n            lischecked[nlx][nly] = true;\n            rischecked[nrx][nry] = true;\n            rxqu.push(nrx);\n            ryqu.push(nry);\n            lxqu.push(nlx);\n            lyqu.push(nly);\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    while(1){\n        cin >> w >> h;\n        if(w == 0 && h == 0) break;\n        for(int i = 0; i < h; i++){\n            cin >> l[i] >> r[i];\n        }\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                lischecked[i][j] = false;\n                rischecked[i][j] = false;\n                if(l[i][j] == 'L'){\n                    lsx = i;\n                    lsy = j;\n                }\n                if(l[i][j] == '%'){\n                    lgx = i;\n                    lgy = j;\n                }\n                if(r[i][j] == 'R'){\n                    rsx = i;\n                    rsy = j;\n                }\n                if(r[i][j] == '%'){\n                    rgx = i;\n                    rgy = j;\n                }\n            }\n        }\n        lischecked[lsx][lsy] = true;\n        rischecked[rsx][rsy] = true;\n        if(solve(lsx, lsy, rsx, rsy)) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\nusing namespace std;\nstring s1[50],s2[50];\nint dx1[]={1,-1,0,0,},dy1[]={0,0,1,-1};\nint dx2[]={-1,1,0,0,},dy2[]={0,0,1,-1};\nint w,h,gx1,gx2,gy1,gy2;\nset<pair<pair<int,int>,pair<int,int> > >s;\nbool dfs(int x1,int y1,int x2,int y2){\n  if(x1==gx1&&y1==gy1&&x2==gx2&&y2==gy2)return 1;\n  for(int i=0;i<4;i++){\n    int x3=x1+dx1[i],y3=y1+dy1[i];\n    int x4=x2+dx2[i],y4=y2+dy2[i];\n    if(x3>=0&&x4>=0&&y3>=0&&y4>=0)\n      if(x3<w&&x4<w&&y3<h&&y4<h){\n        if(s1[y3][x3]=='#')y3=y1,x3=x1;\n        if(s2[y4][x4]=='#')y4=y2,x4=x2;\n        if(!s.count(mk(mk(x3,y3),mk(x4,y4)))){\n          s.insert(mk(mk(x3,y3),mk(x4,y4)));\n          if(dfs(x3,y3,x4,y4))return 1;\n        }\n      }\n    }\n    return 0;\n}\nint main(){\n  int x1,y1,x2,y2;\n  while(cin>>w>>h,w){\n    s.clear();\n    r(i,h)cin>>s1[i]>>s2[i];\n    r(i,h)r(j,w){\n      if(s1[i][j]=='L')x1=j,y1=i;\n      if(s2[i][j]=='R')x2=j,y2=i;\n      if(s1[i][j]=='%')gx1=j,gy1=i;\n      if(s2[i][j]=='%')gx2=j,gy2=i;\n    }\n    s.insert(mk(mk(x1,y1),mk(x2,y2)));\n    if(dfs(x1,y1,x2,y2))cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2153&lang=jp\ntypedef long long ll;\ntypedef vector<vector<char>> vvc;\ntypedef vector<char> vc;\ntypedef vector<vector<int>> vvi;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nint dlx[4] = {1, 0, -1, 0};\nint dly[4] = { 0,1,0,-1 };\nint drx[4] = { 1,0,-1,0 };\nint dry[4] = { 0,-1,0,1 };\n\nbool LRf[55][55][55][55];\n\nint W, H;\nbool bfs(pii l,pii r,vvc& L,vvc& R){\n\tmemset(LRf, false, sizeof(LRf));\n\tqueue<pair<pii, pii>> q;\n\tq.push({ l,r });\n\twhile (!q.empty()) {\n\t\tauto pp = q.front(); q.pop();\n\t\tl = pp.first; r = pp.second;\n\t\tif (LRf[l.first][l.second][r.first][r.second] == true) continue;\n\t\tLRf[l.first][l.second][r.first][r.second] = true;\n\n\t\tif (L[l.first][l.second] == '%' && R[r.first][r.second] == '%') return true;\n\t\tif (L[l.first][l.second] == '%' || R[r.first][r.second] == '%') continue;\n\n\t\tfor (int i = 0; i < 4;i++) {\n\t\t\tint lx = l.first + dlx[i], ly = l.second + dly[i];\n\t\t\tint rx = r.first + drx[i], ry = r.second + dry[i];\n\t\t\tif (L[lx][ly] == '#' && R[rx][ry] == '#')continue;\n\t\t\tif (L[lx][ly] == '#') {\n\t\t\t\tif (LRf[l.first][l.second][rx][ry]) continue;\n\t\t\t\tq.push({ {l.first,l.second},{rx,ry} });\n\t\t\t}\n\t\t\telse if(R[rx][ry] == '#'){\n\t\t\t\tif (LRf[lx][ly][r.first][r.second]) continue;\n\t\t\t\tq.push({ {lx,ly},{r.first,r.second} });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (LRf[lx][ly][rx][ry]) continue;\n\t\t\t\tq.push({ {lx,ly},{rx,ry} });\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\twhile (cin >> W >> H) {\n\t\tif ((W | H) == 0)break;\n\t\tvvc L(H + 2, vc(W + 2, '#'));\n\t\tvvc R(H + 2, vc(W + 2, '#'));\n\t\tpii ls, rs;\n\t\tfor (int i = 1; i <= H;i++) {\n\t\t\tfor (int j = 1;j <= W;j++) {\n\t\t\t\tcin >> L[i][j];\n\t\t\t\tif (L[i][j] == 'L') ls = { i,j };\n\t\t\t}\n\t\t\tfor (int j = 1;j <= W;j++) {\n\t\t\t\tcin >> R[i][j];\n\t\t\t\tif (R[i][j] == 'R') rs = { i,j };\n\t\t\t}\n\t\t}\n\n\t\tif (bfs(ls, rs, L, R)) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t\telse cout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": " #include<bits/stdc++.h>\n using namespace std;\n#define INF 1000000000\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\ntypedef long long LL;\nint H,W;\nint A[51][51];\nint B[51][51];\nint sax,say,tax,tay;\nint sbx,sby,tbx,tby;\nbool used[51][51][51][51];\ntypedef pair<int,int>P;\ntypedef pair<P,P>PP;\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\n\nP move(P now,int x,int y){\n  if(now.first+x<0){\n     return now;\n  }\n  if(now.first+x>=W){\n     return now;\n  }\n  if(now.second+y<0){\n     return now;\n  }\n  if(now.second+y>=H){\n     return now;\n  }\n  if(A[now.first+x][now.second]!=1){\n     now.first+=x;\n  }\n  if(A[now.first][now.second+y]!=1){\n     now.second+=y;\n  }\n  return now;\n}\n\nP move2(P now,int x,int y){\n  if(now.first+x<0){\n     return now;\n  }\n  if(now.first+x>=W){\n     return now;\n  }\n  if(now.second+y<0){\n     return now;\n  }\n  if(now.second+y>=H){\n     return now;\n  }\n  if(B[now.first+x][now.second]!=1){\n     now.first+=x;\n  }\n  if(B[now.first][now.second+y]!=1){\n     now.second+=y;\n  }\n  return now;\n}\n\n\nint main(){\n    int c=0;\n    while(cin>>W>>H,W){\n       //c++;\n       //if(c>=2)break;\n       //vector<int>\n       REP(i,H){\n           string s;\n           cin>>s;\n           REP(j,W){\n              if(s[j]=='L'){\n                 sax=j;\n                 say=i;\n              }\n              if(s[j]=='%'){\n                 tax=j;\n                 tay=i;\n              }\n              A[j][i]=0;\n              if(s[j]=='#'){\n                 A[j][i]=1;\n              }\n           }\n           cin>>s;\n           REP(j,W){\n              if(s[j]=='R'){\n                 sbx=j;\n                 sby=i;\n              }\n              if(s[j]=='%'){\n                 tbx=j;\n                 tby=i;\n              }\n              B[j][i]=0;\n              if(s[j]=='#'){\n                 B[j][i]=1;\n              }\n           }\n       }\n       //cout<<\"input_ok\"<<endl;\n       //cout<<tax<<\" \"<<tay<<\" \"<<tbx<<\" \"<<tby<<endl;\n       //????????????bfs\n       REP(i,50){\n           REP(j,50){\n               REP(k,50){\n                   REP(l,50){\n                       used[i][j][k][l]=false;\n                   }\n               }\n           }\n       }\n\n       used[sax][say][sbx][sby]=true;\n       queue<PP>v;\n       //vector<PP>v;\n       v.push(PP(P(sax,say),P(sbx,sby)));\n       int now=0;\n       while(!v.empty()){\n          //P l=v[now].first;\n          //P r=v[now].second;\n          P l=v.front().first;\n          P r=v.front().second;v.pop();\n          used[l.first][l.second][r.first][r.second]=true;\n          //cout<<l.first<<\" \"<<l.second<<\" \"<<r.first<<\" \"<<r.second<<endl;\n          REP(i,4){\n              P ll=move(l,dx[i],dy[i]);\n              P rr=move2(r,-dx[i],dy[i]);\n              if(used[ll.first][ll.second][rr.first][rr.second]==false){\n                    used[ll.first][ll.second][rr.first][rr.second]=true;\n              /*if(now>=50*50*50*50){\n              cout<<c<<\"ok\"<<ll.first<<\" \"<<ll.second<<\" \"<<rr.first<<\" \"<<rr.second<<endl;\n              }*/\n                 if((ll.first==tax)&&(ll.second==tay)){\n                    used[ll.first][ll.second][rr.first][rr.second]=true;\n                    continue;\n                 }\n                 if((rr.first==tbx)&&(rr.second==tby)){\n                    used[ll.first][ll.second][rr.first][rr.second]=true;\n                    continue;\n                 }\n                   v.push(PP(ll,rr));\n              }\n          }\n          now++;\n       }\n       \n       //cout<<endl;\n       if(used[tax][tay][tbx][tby]==true){\n          cout<<\"Yes\"<<endl;\n       }else{\n          cout<<\"No\"<<endl;\n       }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\n\n\nint W,H;\nstring roomL[55],roomR[55];\n\nbool range_check(int y,int x) {\n    if(!(0<=y&&y<H)) return false;\n    if(!(0<=x&&x<W)) return false;\n\n    return true;\n}\n\nbool visited[55][55][55][55];\nbool ok(P len,P rin) {\n    memset(visited,0,sizeof(visited));\n    visited[len.fr][len.sc][rin.fr][rin.sc]=true;\n    queue<PP> que;\n    que.push(PP(len,rin));\n\n    while(que.size()) {\n        PP pp=que.front(); que.pop();\n        P next_len=pp.fr;\n        P next_rin=pp.sc;\n\n        //printf(\"[debug] %d %d %d %d\\n\",next_len.fr,next_len.sc,next_rin.fr,next_rin.sc);\n\n        if(roomL[next_len.fr][next_len.sc]=='%' && roomR[next_rin.fr][next_rin.sc]=='%') {\n            return true;\n        }\n\n        rep(i,4) {\n            next_len=pp.fr;\n            next_rin=pp.sc;\n\n            if(range_check(next_len.fr+dy[i],next_len.sc+dx[i]) && roomL[next_len.fr+dy[i]][next_len.sc+dx[i]]!='#') {\n                next_len.fr+=dy[i];\n                next_len.sc+=dx[i];\n            }\n            if(range_check(next_rin.fr+dy[i],next_rin.sc-dx[i]) && roomR[next_rin.fr+dy[i]][next_rin.sc-dx[i]]!='#') {\n                next_rin.fr+=dy[i];\n                next_rin.sc-=dx[i];\n            }\n\n            if(!visited[next_len.fr][next_len.sc][next_rin.fr][next_len.sc]) {\n                if(!(roomL[next_len.fr][next_len.sc]=='%')^(roomR[next_rin.fr][next_rin.sc]=='%')) {\n                    visited[next_len.fr][next_len.sc][next_rin.fr][next_len.sc]=true;\n                    que.push(PP(next_len,next_rin));\n                }\n            }\n        }\n    }\n\n    return false;\n}\n\nvoid solve() {\n    rep(y,55) roomL[y]=roomR[y]=string('#',55);\n    rep(y,H) cin>>roomL[y]>>roomR[y];\n    P len,rin;\n    rep(y,H) rep(x,W) {\n        if(roomL[y][x]=='L') len=P(y,x);\n        if(roomR[y][x]=='R') rin=P(y,x);\n    }\n    if(ok(len,rin)) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n}\n\nint main() {\n    while(cin>>W>>H) {\n        if(!W) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\nvoid dfs(vector<int> x, vector<int> y, vector<int>& xt, vector<int>& yt, vector< vector<string> >& a, vector< vector<bool> >& vis) {\n\tvector<int> z(2);\n\tfor (int k = 0; k < 2; k++)\n\t\tz[k] = y[k] * 100 + x[k];\n\tvis[z[0]][z[1]] = true;\n\tif (x[0] == xt[0] && y[0] == yt[0]) return;\n\tif (x[1] == xt[1] && y[1] == yt[1]) return;\n\tfor (int i = 0; i < 4; i++) {\n\t\tvector<int> _x = x, _y = y, _z(2);\n\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t_x[k] += (k ? dx[i] : -dx[i]);\n\t\t\t_y[k] += dy[i];\n\t\t\tif (a[k][_y[k]][_x[k]] == '#') {\n\t\t\t\t_x[k] = x[k]; _y[k] = y[k];\n\t\t\t}\n\t\t\t_z[k] = _y[k] * 100 + _x[k];\n\t\t}\n\t\tif (!vis[_z[0]][_z[1]]) dfs(_x, _y, xt, yt, a, vis);\n\t}\n}\n\nint main() {\n\tfor (;;) {\n\t\tint W, H; cin >> W >> H;\n\t\tif (W == 0 && H == 0) break;\n\t\tvector< vector<string> > a(2, vector<string>(H + 2, string(W + 2, '#')));\n\t\tfor (int y = 1; y <= H; y++) {\n\t\t\tstring s1, s2; cin >> s1 >> s2;\n\t\t\ta[0][y] = '#' + s1 + '#';\n\t\t\ta[1][y] = '#' + s2 + '#';\n\t\t}\n\t\tvector<int> xs(2), ys(2), xt(2), yt(2);\n\t\tfor (int k = 0; k < 2; k++)\n\t\t\tfor (int y = 1; y <= H; y++)\n\t\t\t\tfor (int x = 1; x <= W; x++){\n\t\t\t\t\tchar& c = a[k][y][x];\n\t\t\t\t\tif (c == 'L' || c == 'R') {\n\t\t\t\t\t\tc = '.';\n\t\t\t\t\t\txs[k] = x; ys[k] = y;\n\t\t\t\t\t}\n\t\t\t\t\telse if (c == '%') {\n\t\t\t\t\t\tc = '.';\n\t\t\t\t\t\txt[k] = x; yt[k] = y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tvector< vector<bool> > vis(6000, vector<bool>(6000));\n\t\tdfs(xs, ys, xt, yt, a, vis);\n\t\tvector<int> zt(2);\n\t\tfor (int k = 0; k < 2; k++)\n\t\t\tzt[k] = yt[k] * 100 + xt[k];\n\t\tcout << (vis[zt[0]][zt[1]] ? \"Yes\" : \"No\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <utility>\n#include <cstring>\n\nusing namespace std;\n\nconst int dx[] = { -1, 0, 1, 0 };\nconst int dy[] = { 0, -1, 0, 1 };\n\nvector<string> field;\nint W, H;\nunsigned char memo[52][52][52][52];\n\nstruct State {\n\tint rx, ry, lx, ly;\n\tint index;\n};\n\nint recur(int rx, int ry, int lx, int ly){\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> W >> H;\n\t\tif(W == 0 && H == 0){ break; }\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tfield.resize(H + 2);\n\t\tfield[0] = field[H + 1] = string(W * 2 + 3, '#');\n\t\tState init = { 0 };\n\t\tfor(int i = 1; i <= H; ++i){\n\t\t\tstring l1, l2;\n\t\t\tcin >> l1 >> l2;\n\t\t\tstring line = \"#\" + l1 + \"#\" + l2 + \"#\";\n\t\t\tfor(int j = 0; j < line.size(); ++j){\n\t\t\t\tif(line[j] == 'R'){\n\t\t\t\t\tinit.rx = j; init.ry = i;\n\t\t\t\t}else if(line[j] == 'L'){\n\t\t\t\t\tinit.lx = j; init.ly = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfield[i] = line;\n\t\t}\n\t\tstack<State> stk;\n\t\tstk.push(init);\n\t\tbool ok = false;\n\t\twhile(!stk.empty()){\n\t\t\tState cur = stk.top();\n\t\t\tstk.pop();\n\t\t\tint rx = cur.rx, ry = cur.ry, lx = cur.lx, ly = cur.ly;\n\t\t\tif(cur.index == 0){\n\t\t\t\tif(memo[rx - W - 1][ry][lx][ly]){ continue; }\n\t\t\t\tmemo[rx - W - 1][ry][lx][ly] = 1;\n\t\t\t\tif(rx == lx && ry == ly){ continue; }\n\t\t\t\tif(field[ry][rx] == '%' && field[ly][lx] == '%'){ ok = true; break; }\n\t\t\t}\n\t\t\tint nrx = rx + dx[cur.index], nry = ry + dy[cur.index];\n\t\t\tint nlx = lx - dx[cur.index], nly = ly + dy[cur.index];\n\t\t\tif(field[nry][nrx] == '#'){ nrx -= dx[cur.index]; nry -= dy[cur.index]; }\n\t\t\tif(field[nly][nlx] == '#'){ nlx += dx[cur.index]; nly -= dy[cur.index]; }\n\t\t\tif(cur.index != 3){\n\t\t\t\t++cur.index;\n\t\t\t\tstk.push(cur);\n\t\t\t}\n\t\t\tState next = { nrx, nry, nlx, nly, 0 };\n\t\t\tstk.push(next);\n\t\t}\n\t\tcout << (ok ? \"Yes\" : \"No\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nint w, h;\nP sl, sr;\nstring s[1000];\nstring t[1000];\nbool f[50][50][50][50];\n\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\n\n//set<pair<P,P>>\n\nbool solve(int ly, int lx, int ry, int rx) {\n\tbool res = 0;\n\tf[ly][lx][ry][rx] = 1;\n\tREP(i, 4) {\n\t\tint nly = ly + dy[i], nry = ry + dy[i], nlx = lx + dx[i], nrx = rx + dx[i];\n\t\tif (nly >= 0 && nly < h&&nlx >= 0 && nlx < w&&nry >= 0 && nry < h&&nrx >= 0 && nrx < w) {\n\t\t\tif (f[nly][nrx][nry][nrx])continue;\n\t\t\tif (s[nly][nlx] != t[nry][nrx]) {\n\t\t\t\tif (s[nly][nlx] == '%' || t[nry][nrx] == '%')continue;\n\t\t\t\tif (s[nly][nlx] == '#')res |= solve(ly, lx, nry, nrx);\n\t\t\t\telse if (t[nry][nrx] == '#')res |= solve(nly, nlx, ry, rx);\n\t\t\t\telse res |= solve(nly, nlx, nry, nrx);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (s[nly][nlx] == '%')res |= true;\n\t\t\t\telse if (s[nly][nlx] == '.')res |= solve(nly, nlx, nry, nrx);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\twhile (cin >> w >> h&&w + h) {\n\t\tREP(i, 100)REP(j, 100)REP(k,100)REP(l,100) {\n\t\t\tf[i][j][k][l] = 0;\n\t\t}\n\t\tREP(i, h) {\n\t\t\tcin >> s[i] >> t[i];\n\t\t\treverse(ALL(t[i]));\n\t\t}\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tif (s[i][j] == 'L') {\n\t\t\t\t\tsl = { i,j };\n\t\t\t\t\ts[i][j] = '.';\n\t\t\t\t}\n\t\t\t\tif (t[i][j] == 'R') {\n\t\t\t\t\tsr = { i,j };\n\t\t\t\t\ts[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (solve(sl.first, sl.second, sr.first, sr.second))cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nstruct POINT\n{\n\tint x, y;\n\tbool operator<(const POINT &t)const{\n\t\tif (x == t.x) return y < t.y;\n\t\treturn x < t.x;\n\t}\n\tbool operator==(const POINT &t)const{\n\t\treturn x == t.x && y == t.y;\n\t}\n};\n\nstruct P\n{\n\tPOINT l, r;\n\tbool operator<(const P &t)const{\n\t\tif (l == t.l) return r < t.r;\n\t\treturn l < t.l;\n\t}\n};\n\nchar g1[64][64], g2[64][64];\n\nint main()\n{\n\tint w, h;\n\twhile (scanf(\"%d %d\", &w, &h), w + h){\n\t\tmemset(g1, '#', sizeof(g1));\n\t\tmemset(g2, '#', sizeof(g2));\n\t\t\n\t\tPOINT L, R;\n\t\tfor (int i = 1; i <= h; i++){\n\t\t\tfor (int j = 1; j <= w; j++){\n\t\t\t\tscanf(\" %c\", &g1[i][j]);\n\t\t\t\tif (g1[i][j] == 'L'){\n\t\t\t\t\tL = {i, j};\n\t\t\t\t\tg1[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = w; j >= 1; j--){\n\t\t\t\tscanf(\" %c\", &g2[i][j]);\n\t\t\t\tif (g2[i][j] == 'R'){\n\t\t\t\t\tR = {i, j};\n\t\t\t\t\tg2[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<P> que;\n\t\tstatic bool done[51][51][51][51] = {{{{false}}}};\n\t\t//memset(done, 0, sizeof(done));\n\t\tbool res = false;\n\t\tfor (que.push({L, R}); !que.empty(); que.pop()){\n\t\t\tP p = que.front();\n\t\t\t\n\t\t\t//printf(\"%d %d %d %d\\n\", p.l.x, p.l.y, p.r.x, p.r.y);\n\t\t\t\n\t\t\tif (done[p.l.x][p.l.y][p.r.x][p.r.y]) continue;\n\t\t\tdone[p.l.x][p.l.y][p.r.x][p.r.y] = true;\n\t\t\t\n\t\t\tif (g1[p.l.x][p.l.y] == '%' && g2[p.r.x][p.r.y] == '%'){\n\t\t\t\tres = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (g1[p.l.x][p.l.y] == '%' || g2[p.r.x][p.r.y] == '%'){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\t\tint ltx = p.l.x + dx[dir];\n\t\t\t\tint lty = p.l.y + dy[dir];\n\t\t\t\tint rtx = p.r.x + dx[dir];\n\t\t\t\tint rty = p.r.y + dy[dir];\n\t\t\t\t\n\t\t\t\tif (g1[ltx][lty] == '#'){\n\t\t\t\t\tltx = p.l.x;\n\t\t\t\t\tlty = p.l.y;\n\t\t\t\t}\n\t\t\t\tif (g2[rtx][rty] == '#'){\n\t\t\t\t\trtx = p.r.x;\n\t\t\t\t\trty = p.r.y;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tque.push({{ltx, lty}, {rtx, rty}});\n\t\t\t}\n\t\t}\n\t\tprintf(res ? \"Yes\\n\" : \"No\\n\");\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint w, h;\nstring l[51], r[51];\nint ldx[4] = {1, 0, -1, 0};\nint ldy[4] = {0, 1, 0, -1};\nint rdx[4] = {1, 0, -1, 0};\nint rdy[4] = {0, -1, 0, 1};\nint lsx, lsy, rsx, rsy, lgx, lgy, rgx, rgy;\nbool lischecked[51][51], rischecked[51][51];\n\nbool solve(int lx, int ly, int rx, int ry){\n    if(lx == lgx && ly == lgy && rx == rgx && ry == rgy) return true;\n    if((lx == lgx && ly == lgy) || (rx == rgx && ry == rgy)) return false;\n    for(int i = 0; i < 4; i++){\n        int nlx = lx + ldx[i], nly = ly + ldy[i];\n        int nrx = rx + rdx[i], nry = ry + rdy[i];\n        if((nlx < 0 || nly < 0 || nlx >= h || nly >= w) && (nrx < 0 || nry < 0 || nrx >= h || nry >= w)) continue;\n        if((l[nlx][nly] == '#' && r[nrx][nry] == '#') || (lischecked[nlx][nly] && rischecked[nrx][nry])) continue;\n        if(nlx < 0 || nlx >= h || nly < 0 || nly >= w){\n            nlx = lx;\n            nly = ly;\n        }\n        if(nrx < 0 || nrx >= h || nry < 0 || nry >= w){\n            nrx = rx;\n            nry = ry;\n        }\n        if(l[nlx][nly] == '#'){\n            nlx = lx;\n            nly = ly;\n        }\n        if(r[nrx][nry] == '#'){\n            nrx = rx;\n            nry = ry;\n        }\n        lischecked[nlx][nly] = true;\n        rischecked[nrx][nry] = true;\n        if(solve(nlx, nly, nrx, nry)) return true;\n        lischecked[nlx][nly] = false;\n        rischecked[nrx][nry] = false;\n    }\n    return false;\n}\n\nint main()\n{\n    while(1){\n        cin >> w >> h;\n        if(w == 0 && h == 0) break;\n        for(int i = 0; i < h; i++){\n            cin >> l[i] >> r[i];\n        }\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                lischecked[i][j] = false;\n                rischecked[i][j] = false;\n                if(l[i][j] == 'L'){\n                    lsx = i;\n                    lsy = j;\n                }\n                if(l[i][j] == '%'){\n                    lgx = i;\n                    lgy = j;\n                }\n                if(r[i][j] == 'R'){\n                    rsx = i;\n                    rsy = j;\n                }\n                if(r[i][j] == '%'){\n                    rgx = i;\n                    rgy = j;\n                }\n            }\n        }\n        lischecked[lsx][lsy] = true;\n        rischecked[rsx][rsy] = true;\n        if(solve(lsx, lsy, rsx, rsy)) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define F first\n#define S second\n\ntypedef pair<int,int> pii;\n\nvector<string> va,vb;\nint H,W;\nint dp[55][55][55][55];\nint aay[]={0,1,0,-1};\nint aax[]={1,0,-1,0};\nint bby[]={0,1,0,-1};\nint bbx[]={-1,0,1,0};\nqueue<pair<pii,pii>> q;\nbool check(int a,int b){\n\tif(0<=a&&a<H&&0<=b&&b<W) return true;\n\treturn false;\n}\nint dfs(int a,int b,int c,int d){\n\tif(dp[a][b][c][d]>=0) return dp[a][b][c][d];\n\tint ret=0;\n\t// cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<endl;\n\tdp[a][b][c][d]=0;\n\tif(va[a][b]=='%'&&vb[c][d]=='%'){\n\t\treturn dp[a][b][c][d]=1;\n\t}\n\tif(va[a][b]=='%'||vb[c][d]=='%'){\n\t\treturn dp[a][b][c][d]=0;\n\t}\n\trep(i,4){\n\t\tint aa=a+aay[i];\n\t\tint bb=b+aax[i];\n\t\tint cc=c+bby[i];\n\t\tint dd=d+bbx[i];\n\t\tif(!check(aa,bb)){\n\t\t\taa=a;\n\t\t\tbb=b;\n\t\t}\n\t\tif(!check(cc,dd)){\n\t\t\tcc=c;\n\t\t\tdd=d;\n\t\t}\n\t\tif(va[aa][bb]=='#'){\n\t\t\taa=a;\n\t\t\tbb=b;\n\t\t}\n\t\tif(vb[cc][dd]=='#'){\n\t\t\tcc=c;\n\t\t\tdd=d;\n\t\t}\n\t\tif(dfs(aa,bb,cc,dd)==1) ret=1;\n\t}\n\treturn dp[a][b][c][d]=ret;\n}\nint main(){\n\twhile(cin>>W>>H){\n\t\tif(W==0&&H==0) break;\n\t\tpii L,R;\n\t\tva=vector<string>(H);\n\t\tvb=vector<string>(H);\n\t\trep(i,H) cin>>va[i]>>vb[i];\n\t\trep(i,H){\n\t\t\trep(j,W){\n\t\t\t\tif(va[i][j]=='L'){\n\t\t\t\t\tva[i][j]='.';\n\t\t\t\t\tL=pii(i,j);\n\t\t\t\t}\n\t\t\t\tif(vb[i][j]=='R'){\n\t\t\t\t\tvb[i][j]='.';\n\t\t\t\t\tR=pii(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,55){\n\t\t\trep(j,55){\n\t\t\t\trep(k,55){\n\t\t\t\t\trep(l,55){\n\t\t\t\t\t\tdp[i][j][k][l]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool f=false;\n\t\tqueue<pair<pii,pii>> q;\n\t\tq.push(make_pair(L,R));\n\t\tdp[L.F][L.S][R.F][R.S]=1;\n\t\tint a,b,c,d;\n\t\twhile(q.size()){\n\t\t\tpair<pii,pii> top=q.front();\n\t\t\tq.pop();\n\t\t\ta=top.F.F;\n\t\t\tb=top.F.S;\n\t\t\tc=top.S.F;\n\t\t\td=top.S.S;\n\t\t\tif(va[a][b]=='%'&&vb[c][d]=='%'){\n\t\t\t\tf=true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(va[a][b]=='%'||vb[c][d]=='%'){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<endl;\n\t\t\trep(i,4){\n\t\t\t\tint aa=a+aay[i];\n\t\t\t\tint bb=b+aax[i];\n\t\t\t\tint cc=c+bby[i];\n\t\t\t\tint dd=d+bbx[i];\n\t\t\t\tif(!check(aa,bb)){\n\t\t\t\t\taa=a;\n\t\t\t\t\tbb=b;\n\t\t\t\t}\n\t\t\t\tif(!check(cc,dd)){\n\t\t\t\t\tcc=c;\n\t\t\t\t\tdd=d;\n\t\t\t\t}\n\t\t\t\tif(va[aa][bb]=='#'){\n\t\t\t\t\taa=a;\n\t\t\t\t\tbb=b;\n\t\t\t\t}\n\t\t\t\tif(vb[cc][dd]=='#'){\n\t\t\t\t\tcc=c;\n\t\t\t\t\tdd=d;\n\t\t\t\t}\n\t\t\t\tif(dp[aa][bb][cc][dd]>=0) continue;\n\t\t\t\telse{\n\t\t\t\t\tdp[aa][bb][cc][dd]=1;\n\t\t\t\t\tq.push(make_pair(pii(aa,bb),pii(cc,dd)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(f) cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,s,n) for(int i=s; i<n; i++)\n#define ALL(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nint w, h;\nint rooml[60][60], roomr[60][60];\nbool memo[60][60][60][60];\n\nbool dfs(int xl, int yl, int xr, int yr) {\n\tif( memo[xl][yl][xr][yr] ) {\n\t\treturn false;\n\t}\n\tmemo[xl][yl][xr][yr] = true;\n\tconst int dx[4] = {-1, 0, 1, 0};\n\tconst int dy[4] = {0, 1, 0, -1};\n\trep(i, 4) {\n\t\tint nxl = xl + dx[i];\n\t\tint nyl = yl + dy[i];\n\t\tint nxr = xr - dx[i];\n\t\tint nyr = yr + dy[i];\n\t\tint nl = rooml[nyl][nxl];\n\t\tint nr = roomr[nyr][nxr];\n\t\tif( nl==2 && nr==2 ) {\n\t\t\treturn true;\n\t\t}\n\t\telse if( nl==1 && nr==1 ) {\n\t\t\tbool f = dfs(nxl, nyl, nxr, nyr);\n\t\t\tif(f) return true;\n\t\t}\n\t\telse if( nl==1 && nr==0 ) {\n\t\t\tbool f = dfs(nxl, nyl, xr, yr);\n\t\t\tif(f) return true;\n\t\t}\n\t\telse if( nl==0 && nr==1 ) {\n\t\t\tbool f = dfs(xl, yl, nxr, nyr);\n\t\t\tif(f) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\twhile(cin >> w >> h, w||h) {\n\t\tmemset(rooml, 0, sizeof(rooml));\n\t\tmemset(roomr, 0, sizeof(roomr));\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tint xl, yl, xr, yr;\n\t\trep(y, h) {\n\t\t\tstring sl, sr;\n\t\t\tcin >> sl >> sr;\n\t\t\trep(x, w) {\n\t\t\t\tif(sl[x] == 'L') {\n\t\t\t\t\txl = x+1;\n\t\t\t\t\tyl = y+1;\n\t\t\t\t\trooml[y+1][x+1] = 1;\n\t\t\t\t} else {\n\t\t\t\t\trooml[y+1][x+1] = (sl[x]=='%' ? 2 : (sl[x]=='.' ? 1 : 0));\n\t\t\t\t}\n\t\t\t\tif(sr[x] == 'R') {\n\t\t\t\t\txr = x+1;\n\t\t\t\t\tyr = y+1;\n\t\t\t\t\troomr[y+1][x+1] = 1;\n\t\t\t\t} else {\n\t\t\t\t\troomr[y+1][x+1] = (sr[x]=='%' ? 2 : (sr[x]=='.' ? 1 : 0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( dfs(xl, yl, xr, yr) ) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t} else {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\nusing namespace std;\n\nstruct Data{int x[2],y[2];};\nData start,goal;\n\nint W,H;\nvector< vector<string> >room(2);\n\nint dx[2][4]={{0,1,0,-1}, {0,-1,0,1}};\nint dy[2][4]={{-1,0,1,0}, {-1,0,1,0}};\n\nbool operator<(Data a, Data b){\n  return a.x[0]!=b.x[0]?a.x[0]<b.x[0]:(a.y[0]!=b.y[0]?a.y[0]<b.y[0]:(\n           a.x[1]!=b.x[1]?a.x[1]<b.x[1]:a.y[1]<b.y[1]\n         ));\n}\nbool operator==(Data a, Data b){\n  return a.x[0]==b.x[0] && a.x[1]==b.x[1] && a.y[0]==b.y[0] && a.y[1]==b.y[1];\n}\nbool over(Data a){\n  return a.x[0]<0 || W<=a.x[0] || a.y[0]<0 || H<=a.y[0] ||\n         a.x[1]<0 || W<=a.x[1] || a.y[1]<0 || H<=a.y[1];\n}\n\nbool bfs()\n{\n  queue<Data>q;\n  q.push(start);\n  map<Data,bool>visited;\n\n  while(!q.empty()){\n    Data now=q.front();\n    q.pop();\n\n    visited[now]=true;\n\n    if(now==goal)return true;\n    if(now.x[0]==goal.x[0] && now.y[0]==goal.y[0])continue;\n    if(now.x[1]==goal.x[1] && now.y[1]==goal.y[1])continue;\n\n    for(int i=0;i<4;i++){\n      Data next=now;\n      for(int j=0;j<2;j++){\n\tnext.x[j]+=dx[j][i];\n\tnext.y[j]+=dy[j][i];\n\tif(over(next)){\n\t  next.x[j]=now.x[j];\n\t  next.y[j]=now.y[j];\n\t}\n\tif(room[j][next.y[j]][next.x[j]]=='#'){\n\t  next.x[j]=now.x[j];\n\t  next.y[j]=now.y[j];\n\t}\n      }\n      if(visited.count(next))continue;\n      q.push(next);\n    }\n  }\n\n  return false;\n}\n\nint main()\n{\n  while(cin>>W>>H,W|H){\n    room[0].resize(H);\n    room[1].resize(H);\n    for(int i=0;i<H;i++){\n      cin>>room[0][i]>>room[1][i];\n      for(int j=0;j<W;j++){\n\tif(room[0][i][j]=='L'){\n\t  start.x[0]=j;\n\t  start.y[0]=i;\n\t}\n\tif(room[1][i][j]=='R'){\n\t  start.x[1]=j;\n\t  start.y[1]=i;\n\t}\n\tif(room[0][i][j]=='%'){\n\t  goal.x[0]=j;\n\t  goal.y[0]=i;\n\t}\n\tif(room[1][i][j]=='%'){\n\t  goal.x[1]=j;\n\t  goal.y[1]=i;\n\t}\n      }\n    }\n\n    puts(bfs()?\"Yes\":\"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstring>\n#include<queue>\n#include<tuple>\n#include<stack>\n#include<cstdio>\n#include<iomanip>\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<string> vs;\nDef inf = sizeof(Def) == sizeof(ll) ?2e18:1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint d[52][52][52][52];\ntypedef tuple<int,int,int,int>tp;\nvs a,b;\nint n,m;\nint f(int x1,int y1,int x2,int y2){\n  //    cout<<x1<<\" \"<<y1<<\" \"<<x2<<\" \"<<y2<<endl;\n\n  priority_queue<tp>q;\n  q.push(tp{x1,y1,x2,y2});\n  while(!q.empty()){ \n      int x1,y1,x2,y2;\n      tie(x1,y1,x2,y2)=q.top();\n      q.pop();\n   rep(i,4){\n      //   if(d[x1][y1][x2][y2])continue;\n      //  cout<<x1<<\" \"<<y1<<\" \"<<x2<<\" \"<<y2<<endl;\n      int nx1=x1+dx[i];\n      int ny1=y1+dy[i];\n      int nx2=x2+dx[i];\n      int ny2=y2+dy[(2+i)%4];\n      if(nx1<0||ny1<0||nx1>=n||ny1>=m){\n\tnx1-=dx[i];\n\tny1-=dy[(i)%4];\n      }\n      if(nx2<0||ny2<0||nx2>=n||ny2>=m){\n\tnx2-=dx[i];\n\tny2-=dy[(i+2)%4];\n      }\n      if(a[nx1][ny1]=='#'){\n\tnx1-=dx[i];\n\tny1-=dy[i];\n      }\n      if(b[nx2][ny2]=='#'){\n\tnx2-=dx[i];\n\tny2-=dy[(i+2)%4];\n      }\n      if(d[nx1][ny1][nx2][ny2])continue;\n      // cout<<nx1<<\" \"<<ny1<<\" \"<<nx2<<\" \"<<ny2<<endl;\n      d[nx1][ny1][nx2][ny2]=1;\n      q.push(tp{nx1,ny1,nx2,ny2});//f(nx1,ny1,nx2,ny2);\n    }\n  }\n}\nint main(){\n  while(cin>>m>>n,n){\n    rep(i,52)rep(j,52)rep(k,52)rep(l,52)\n      d[i][j][k][l]=0;\n    a=b=vs(n);\n    rep(i,n)cin>>a[i]>>b[i];\n    rep(i,n)rep(j,m)rep(k,n)rep(l,m)if(a[i][j]=='L'&&b[k][l]=='R'){\n      d[i][j][k][l]=1;\n      f(i,j,k,l);\n    }\n    rep(i,n)rep(j,m)rep(k,n)rep(l,m)if(a[i][j]=='%'&&b[k][l]=='%'){\n      if(d[i][j][k][l])cout<<\"YES\"<<endl;\n      else cout<<\"NO\"<<endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<pair<int, int>, pair<int, int>> PPIIII;\n\nint dx[] = { 1,0,-1,0 };\nint dy[] = { 0,1,0,-1 };\n\nvoid solve( int W, int H ) {\n\tpair<int, int> startR, startL, goalR, goalL;\n\tvector<vector<vector<vector<bool>>>>dp( H + 2, vector<vector<vector<bool>>>( W + 2, vector<vector<bool>>( H + 2, vector<bool>( W + 2, 0 ) ) ) );\n\tvector<vector<vector<char>>>mapd( 2, vector<vector<char>>( H + 2, vector<char>( W + 2, '#' ) ) );\n\tfor( size_t i = 1; i <= H; i++ ) {\n\t\tfor( size_t j = 1; j <= W; j++ ) {\n\t\t\tcin >> mapd[0][i][j];\n\t\t\tif( mapd[0][i][j] == 'L' ) {\n\t\t\t\tstartL = make_pair( i, j );\n\t\t\t} else if( mapd[0][i][j] == '%' ) {\n\t\t\t\tgoalL = make_pair( i, j );\n\t\t\t}\n\t\t}\n\t\tfor( int j = W; j >= 1; j-- ) {\n\t\t\tcin >> mapd[1][i][j];\n\t\t\tif( mapd[1][i][j] == 'R' ) {\n\t\t\t\tstartR = make_pair( i, j );\n\t\t\t} else if( mapd[1][i][j] == '%' ) {\n\t\t\t\tgoalR = make_pair( i, j );\n\t\t\t}\n\t\t}\n\t}\n\tdp[startL.first][startL.second][startR.first][startR.second] = 1;\n\n\n\tqueue<PPIIII>que;\n\tbool f = true;\n\tque.push( make_pair( startL, startR ) );\n\twhile( que.size() ) {\n\t\tauto now = que.front(); que.pop();\n\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\tauto next = now;\n\t\t\tnext.first.first += dx[i];\n\t\t\tnext.first.second += dy[i];\n\t\t\tnext.second.first += dx[i];\n\t\t\tnext.second.second += dy[i];\n\t\t\tif( mapd[0][next.first.first][next.first.second] == '#' ) {\n\t\t\t\tnext.first = now.first;\n\t\t\t}\n\t\t\tif( mapd[1][next.second.first][next.second.second] == '#' ) {\n\t\t\t\tnext.second = now.second;\n\t\t\t}\n\n\t\t\tif( 0 < next.first.first&&next.first.first < H + 1 &&\n\t\t\t\t0 < next.first.second&&next.first.second < W + 1 &&\n\t\t\t\t0 < next.second.first&&next.second.first < H + 1 &&\n\t\t\t\t0 < next.second.second&&next.second.second < W + 1 ) {\n\t\t\t\tif( dp[next.first.first][next.first.second][next.second.first][next.second.second] == 0 ) {\n\t\t\t\t\tif( goalL == next.first&&goalR == next.second ) {\n\t\t\t\t\t\tif( now.first != next.first&&now.second != next.second ) {\n\t\t\t\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif( f ) {\n\t\t\t\t\t\t\tf = 0;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdp[next.first.first][next.first.second][next.second.first][next.second.second] = 1;\n\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"No\" << endl;\n\treturn;\n}\n\nint main() {\n\tint W, H;\n\twhile( cin >> W >> H, W&&H ) {\n\t\tsolve( W, H );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing psi=pair<string,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define MOD (1e9+7)\nvoid get(){}template<class H,class...T>void get(H&h,T&...t){cin>>h;get(t...);}\ntemplate<class T>void geti(T&a){for(auto&_:a)cin>>_;}\ntemplate<class T>void getii(T&a){for(auto&_:a)geti(_);}\nvoid put(string d){}template<class H,class...T>void put(string d,H&h,T&...t){cout<<h;if(sizeof...(t))cout<<d;put(d,t...);}\ntemplate<class T>void puti(T&a,string d=\" \"){bool f=1;for(auto&_:a)cout<<(exchange(f,0)?\"\":d)<<_;cout<<endl;}\ntemplate<class T>void putii(T&a,string d=\" \"){for(auto&_:a)puti(_,d);}\n#define dcl(...) ll __VA_ARGS__;get(__VA_ARGS__)\n#define dclt(t,...) t __VA_ARGS__;get(__VA_ARGS__)\n  \n#define fs first\n#define sc second\n  \nint main(){\n    int w,h;\n    while(cin>>w>>h,w){\n        vector<vvi> tf(2,vvi(h+2,vi(w+2,1)));\n\t\tvvi f(h+2,vi(2*w+3,1));\n        pair<pii,pii> curr;\n        pair<pii,pii> stat;\n        for(int i=1;i<=h;i++){\n            rep(p,2){\n                for(int j=1;j<=w;j++){\n                    char c; cin>>c;\n                    if(c=='.'){\n                        tf[p][i][j]=0;\n                    }else if(c=='%'){\n                        tf[p][i][j]=0;\n                        if(p==0){\n                            stat.first={i,j};\n                        }else{\n                            stat.second={i,2*w+2-j};\n                        }\n                    }else if(c=='L'){\n                        tf[p][i][j]=0;\n                        curr.first={i,j};\n                    }else if(c=='R'){\n                        tf[p][i][j]=0;\n                        curr.second={i,2*w+2-j};\n                    }\n                }\n            }\n            reverse(all(tf[1][i]));\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tf[i][j]=tf[0][i][j];\n\t\t\t\tf[i][j+w+1]=tf[1][i][j];\n\t\t\t}\n        }\n\t\t\n        //putii(f[0],\"\");\n        //cout<<endl;\n        //putii(f[1],\"\");\n        //cout<<\"=======\"<<endl;\n          \n        /*幅優先\n            ・どちらか片方だけ動き、動いた先がゴールでない場合\n            ・両方動き、かつ少なくともどちらかがそのマスを訪れたことがない場合\n            だけ、探索する\n        */\n        set<pair<pii,pii>> isVisited;\n  \n        queue<pair<pii,pii>> que;\n        que.push(curr);\n        int y[]={-1,0,1,0};\n        int x[]={0,1,0,-1};\n        auto step=[f](pii &pos, int y, int x){\n            if(f[pos.fs+y][pos.sc+x]!=1){\n                pos.fs+=y;\n                pos.sc+=x;\n                return true;\n            }\n            return false;\n        };\n        bool ok=false;\n        while(!que.empty()){\n            auto c=que.front();\n            que.pop();\n            //cout<<c[0][0]<<\",\"<<c[0][1]<<\"  \"<<c[1][0]<<\",\"<<c[1][1]<<endl;\n            if(isVisited.find(c)!=isVisited.end()){\n                continue;\n            }\n            isVisited.insert(c);\n            rep(v,4){\n                auto next=c;\n                bool l=step(next.fs,y[v],x[v]);\n                bool r=step(next.sc,y[v],x[v]);\n                if(next==stat){\n                    ok=true;\n                    goto fin;\n                }\n  \n                if(next.fs!=stat.fs and next.sc!=stat.sc and isVisited.find(next)==isVisited.end()){\n                    if( l or r ){\n                        //cout<<\" o \"<<next[0][0]<<\",\"<<next[0][1]<<\"  \"<<next[1][0]<<\",\"<<next[1][1]<<endl;\n                        que.push(next);\n                    }else{\n                        //cout<<\" x \"<<next[0][0]<<\",\"<<next[0][1]<<\"  \"<<next[1][0]<<\",\"<<next[1][1]<<endl;\n                    }\n                }\n            }\n        }\n        fin:;\n        if(ok){\n            cout<<\"Yes\"<<endl;\n        }else{\n            cout<<\"No\"<<endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nint W, H;\nvoid dis(vvi &v,int x,int y,int dist){\n\tv[y][x] = dist;\n\tREP(i, 4){\n\t\tif (x + dx[i] >= 0 && x + dx[i]<W&&y + dy[i] >= 0 && y + dy[i]<H&& v[y + dy[i]][x + dx[i]] != -1 && v[y + dy[i]][x + dx[i]]>v[y][x])\n\t\tdis(v, x + dx[i], y + dy[i],dist+1);\n\t}\n}\nint main() {\n\t\n\twhile (cin >> W >> H, W | H){\n\t\tvector<string> vsl;\n\t\tvector<string> vsr;\n\t\tREP(i, H){\n\t\t\tstring l;\n\t\t\tstring r;\n\t\t\tcin >> l >> r;\n\t\t\tvsl.push_back(l);\n\t\t\tvsr.push_back(r);\n\t\t}\n\t\tvector<vector<int>> vvil(H);\n\t\tvector<vector<int>> vvir(H);\n\t\tint glx;\n\t\tint gly;\n\t\tint grx;\n\t\tint gry;\n\t\tint lx;\n\t\tint ly;\n\t\tint rx;\n\t\tint ry;\n\t\tREP(i, H){\n\t\t\tREP(j, W){\n\t\t\t\tif (vsl[i][j] == '#')vvil[i].push_back(-1);\n\t\t\t\telse vvil[i].push_back(9999);\n\t\t\n\t\t\t\tif (vsr[i][j] == '#')vvir[i].push_back(-1);\n\t\t\t\telse vvir[i].push_back(9999);\n\n\t\t\t\tif (vsl[i][j] == 'L'){\n\t\t\t\t\tlx = j;\n\t\t\t\t\tly = i;\n\t\t\t\t}\n\t\t\t\tif (vsr[i][j] == 'R'){\n\t\t\t\t\trx = j;\n\t\t\t\t\try = i;\n\t\t\t\t}\n\t\t\t\tif (vsl[i][j] == '%'){\n\t\t\t\t\tglx = j;\n\t\t\t\t\tgly = i;\n\t\t\t\t}\n\t\t\t\tif (vsr[i][j] == '%'){\n\t\t\t\t\tgrx = j;\n\t\t\t\t\tgry = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdis(vvil, glx, gly, 0);\n\t\tdis(vvir, grx, gry, 0);\n\t\t\n\t\tvector<int> vi;\n\t\tvi.push_back(lx * 1000000 + ly * 10000 + rx * 100 + ry);\n\t\tint count = 0;\n\t\tint pcount = 1;\n\t\tbool clear = false;\n\t\twhile(1){\n\t\t\t/*if (vi[count] == glx * 1000000 + gly * 10000 + grx * 100 + gry){\n\t\t\t\tclear = true;\n\t\t\t\tbreak;\n\t\t\t}*/\n\t\t\tint lx2 = vi[count] / 1000000 % 100;\n\t\t\tint ly2 = vi[count] / 10000 % 100;\n\t\t\tint rx2 = vi[count] / 100 % 100;\n\t\t\tint ry2 = vi[count] % 100;\n\t\t\t\n\t\t\tREP(i, 4){\n\t\t\t\tint lx3 = lx2;\n\t\t\t\tint ly3 = ly2;\n\t\t\t\tint rx3 = rx2;\n\t\t\t\tint ry3 = ry2;\n\t\t\t\tif (dx[i] != 0 && lx3 + dx[i] >= 0 && lx3 + dx[i] < W && vsl[ly3 + dy[i]][lx3 + dx[i]] != '#')lx3 += dx[i];\n\t\t\t\tif (dy[i] != 0 && ly3 + dy[i] >= 0 && ly3 + dy[i] < H && vsl[ly3 + dy[i]][lx3 + dx[i]] != '#')ly3 += dy[i];\n\t\t\t\tif (dx[i] != 0 && rx3 - dx[i] >= 0 && rx3 - dx[i] < W && vsr[ry3 + dy[i]][rx3 - dx[i]] != '#')rx3 -= dx[i];\n\t\t\t\tif (dy[i] != 0 && ry3 + dy[i] >= 0 && ry3 + dy[i] < H && vsr[ry3 + dy[i]][rx3 - dx[i]] != '#')ry3 += dy[i];\n\t\t\t\tif (find(vi.begin(), vi.end(), lx3 * 1000000 + ly3 * 10000 + rx3 * 100 + ry3) == vi.end() && vvil[ly3][lx3] != 0&& vvir[ry3][rx3] != 0)vi.push_back(lx3 * 1000000 + ly3 * 10000 + rx3 * 100 + ry3);\n\t\t\t\tif (lx3 == glx&&ly3 == gly&&rx3 == grx&&ry3 == gry)clear = true;\n\t\t\t}\n\t\t\tif (clear)break;\n\t\t\tif (count+1 == vi.size())break;\n\t\t\tint min = 10000;\n\t\t\tint i2=0;\n\n\t\t\tFOR(i,count+1,vi.size()){\n\t\t\t\tif (vvil[(vi[i] / 10000 % 100)][(vi[i] / 1000000 % 100)] + vvir[(vi[i] % 100)][(vi[i] / 100 % 100)] < min)min = vvil[(vi[i] / 10000 % 100)][(vi[i] / 1000000 % 100)] + vvir[(vi[i] % 100)][(vi[i] / 100 % 100)];\n\t\t\t\ti2 = i;\n\t\t\t}\n\t\t\tif (vvil[ly2][lx2] + vvir[ry2][rx2] < min)break;\n\t\t\tswap(vi[count+1], vi[i2]);\n\t\t\t\n\t\t\tcount++;\n\t\t}\n\n\t\tif (clear)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> node;\nint ldx[4]={1,0,-1,0};\nint rdx[4]={-1,0,1,0};\nint dy[4]={0,1,0,-1};\n\nchar l[52][52];\nchar r[52][52];\n\nint main(void){\n\tint w,h;\n\twhile(cin >> w >> h,w|h){\n\t\tset<node> sets;\n\t\tint plx,ply,prx,pry;\n\t\tint slx,sly,srx,sry;\n\t\tfor(int x=0;x<=w+1;x++){\n\t\t\tl[x][0]=r[x][0]='#';\n\t\t\tl[x][h+1]=r[x][h+1]='#';\n\t\t}\n\t\tfor(int y=0;y<=h+1;y++){\n\t\t\tl[0][y]=r[0][y]='#';\n\t\t\tl[w+1][y]=r[w+1][y]='#';\n\t\t}\n\t\tfor(int y=1;y<=h;y++){\n\t\t\tfor(int x=1;x<=w;x++){\n\t\t\t\tcin >> l[x][y];\n\t\t\t\tif(l[x][y]=='%')\n\t\t\t\t\tplx=x,ply=y;\n\t\t\t\tif(l[x][y]=='L')\n\t\t\t\t\tslx=x,sly=y;\n\t\t\t}\n\t\t\tfor(int x=1;x<=w;x++){\n\t\t\t\tcin >> r[x][y];\n\t\t\t\tif(r[x][y]=='%')\n\t\t\t\t\tprx=x,pry=y;\n\t\t\t\tif(r[x][y]=='R')\n\t\t\t\t\tsrx=x,sry=y;\n\t\t\t}\n\t\t}\n\t\t/*for(int y=0;y<=h+1;y++){\n\t\t\tfor(int x=0;x<=w+1;x++){\n\t\t\t\tcout << l[x][y];\n\t\t\t}\n\t\t\tcout <<\" \" ;\n\t\t\tfor(int x=0;x<=w+1;x++){\n\t\t\t\tcout<< r[x][y];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tqueue<node> q;\n\t\tnode s,g;\n\t\ts=node(P(slx,sly),P(srx,sry));\n\t\tg=node(P(plx,ply),P(prx,pry));\n\t\tq.push(s);\n\t\tsets.insert(s);\n\t\twhile(!q.empty()){\n\t\t\tnode cur=q.front();q.pop();\n\t\t\t//cout << cur.F.F << \" \"<< cur.F.S << \" \"<< cur.S.F << \" \"<< cur.S.S << endl;\n\t\t\tif(cur==g)\n\t\t\t\tbreak;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint lnx=cur.F.F+ldx[i],lny=cur.F.S+dy[i],rnx=cur.S.F+rdx[i],rny=cur.S.S+dy[i];\n\t\t\t\tif(l[lnx][lny]=='#'&&r[rnx][rny]=='#')\n\t\t\t\t\tcontinue;\n\t\t\t\tif(l[lnx][lny]=='#')\n\t\t\t\t\tlnx=cur.F.F,lny=cur.F.S;\n\t\t\t\tif(r[rnx][rny]=='#')\n\t\t\t\t\trnx=cur.S.F,rny=cur.S.S;\n\t\t\t\tnode c=node(P(lnx,lny),P(rnx,rny));\n\t\t\t\tif(sets.find(c)==sets.end())\n\t\t\t\t\tsets.insert(c),q.push(c);\n\t\t\t}\n\t\t}\n\t\tif(sets.find(g)!=sets.end())\n\t\t\tcout << \"Yes\" << endl;\n\t\telse\n\t\t\tcout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nconst int N = 50 + 1;\nchar l[N][N];\nchar r[N][N];\n\nint r_di[] = {0, 0, -1, +1};\nint r_dj[] = {-1, +1, 0, 0};\nint l_di[] = {0, 0, -1, +1};\nint l_dj[] = {+1, -1, 0, 0};\n\nbool vis[N][N][N][N];\n\ntypedef pair< pair<int, int>, pair<int, int> > P;\n\ninline\nbool& ref(P p)\n{\n  pair<int, int> a = p.first;\n  pair<int, int> b = p.second;\n  return vis[a.first][a.second][b.first][b.second];\n}\n\nint main(void)\n{\n  int h, w;\n  while (cin >> w >> h && (h | w)) {\n    fill(&vis[0][0][0][0], &vis[N - 1][N - 1][N - 1][N - 1] + 1, false);\n    pair<int, int> pr, pl;\n    pair<int, int> qr, ql;\n    pr = pl = qr = ql = make_pair(-1, -1);\n    for (int i = 0; i < h; ++i) {\n      string s, t;\n      cin >> s >> t;\n      for (int j = 0; j < s.size(); ++j) {\n\tl[i][j] = s[j];\n\tif (s[j] == 'L') pl = make_pair(i, j);\n\tif (s[j] == '%') ql = make_pair(i, j);\n      }\n      for (int j = 0; j < t.size(); ++j) {\n\tr[i][j] = t[j];\n\tif (t[j] == 'R') pr = make_pair(i, j);\n\tif (t[j] == '%') qr = make_pair(i, j);\n      }\n    }\n    queue<P> q;\n    P ini = make_pair(pl, pr);\n    ref(ini) = true;\n    for (q.push(ini); q.size(); q.pop()) {\n      P p = q.front();\n      pair<int, int> pl = p.first;\n      pair<int, int> pr = p.second;\n      for (int d = 0; d < 4; ++d) {\n\tint pr_i = pr.first + r_di[d];\n\tint pr_j = pr.second + r_dj[d];\n\tint pl_i = pl.first + l_di[d];\n\tint pl_j = pl.second + l_dj[d];\n\tif (pr_i < 0 || h <= pr_i) pr_i = pr.first, pr_j = pr.second;\n\tif (pr_j < 0 || w <= pr_j) pr_i = pr.first, pr_j = pr.second;\n\tif (r[pr_i][pr_j] == '#')  pr_i = pr.first, pr_j = pr.second;\n\tif (pl_i < 0 || h <= pl_i) pl_i = pl.first, pl_j = pl.second;\n\tif (pl_j < 0 || w <= pl_j) pl_i = pl.first, pl_j = pl.second;\n\tif (l[pl_i][pl_j] == '#')  pl_i = pl.first, pl_j = pl.second;\n\tP next = make_pair(make_pair(pl_i, pl_j), make_pair(pr_i, pr_j));\n\tif (ref(next)) continue;\n\tref(next) = true;\n\tq.push(next);\n      }\n    }\n    cout << (ref(make_pair(ql, qr)) ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nint w, h;\nstring sl[50], sr[50];\nbool vis[250][250];\nP ls, rs, lg, rg;\nint dxl[] = {1, 0, -1, 0};\nint dxr[] = {-1, 0, 1, 0};\nint dy[] = {0, 1, 0, -1};\n\nbool range(int x, int y) {\n    return 0 <= x && x < w && 0 <= y && y < h;\n}\n\nbool dfs(P l, P r) {\n    if (l == lg && r == rg) return true;\n    else if (l == lg || r == rg) return false;\n\n    vis[l.fi * 50 + l.se][r.fi * 50 + r.se] = true;\n    bool ok = false;\n    rep(i, 4) {\n        int lx = l.se + dxl[i], ly = l.fi + dy[i];\n        if (!range(lx, ly) || (range(lx, ly) && sl[ly][lx] == '#')) lx = l.se, ly = l.fi;\n        int rx = r.se + dxr[i], ry = r.fi + dy[i];\n        if (!range(rx, ry) || (range(lx, ly) && sr[ry][rx] == '#')) rx = r.se, ry = r.fi;\n        if (!vis[ly * 50 + lx][ry * 50 + rx]) {\n            ok |= dfs(P(ly, lx), P(ry, rx));\n        }\n    }\n    return ok;\n}\n\nint main(){\n    cin.sync_with_stdio(false);\n    while(cin >> w >> h, w | h) {\n        memset(vis, 0, sizeof(vis));\n\n        rep(i, h) {\n            cin >> sl[i] >> sr[i];\n            rep(j, w) {\n                if (sl[i][j] == 'L') ls = P(i, j);\n                if (sr[i][j] == 'R') rs = P(i, j);\n                if (sl[i][j] == '%') lg = P(i, j);\n                if (sr[i][j] == '%') rg = P(i, j);\n            }\n        }\n\n        cout << (dfs(ls, rs) ? \"Yes\" : \"No\") << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst double EPS = 1e-9;\n\nint main(){\n    while(true){\n        int W,H;\n        cin >> W >> H;\n        if(W == 0 and H == 0) break;\n        vector<vector<string> > field(2,vector<string>(H+2));\n        field[0][0] = string(W+2,'#');\n        field[1][0] = string(W+2,'#');\n        field[0][H+1] = string(W+2,'#');\n        field[1][H+1] = string(W+2,'#');\n\n        for(int i=1;i<=H;i++){\n            for(int j=0;j<2;j++){\n                cin >> field[j][i];\n                field[j][i] = '#' + field[j][i] + '#';\n                if(j == 1) reverse(all(field[j][i]));\n            }\n        }\n//        for(int i=0;i<H+2;i++){\n//            cerr << field[0][i] << \" \" << field[1][i] << endl;\n//        }\n        pair<pii,pii> start;\n        pair<pii,pii> goal;\n        for(int i=0;i<2;i++){\n            for(int j=1;j<=H;j++){\n                for(int k=1;k<=W;k++){\n                    if(field[i][j][k] == 'L'){\n                        start.first = make_pair(j,k);\n                    }else if(field[i][j][k] == 'R'){\n                        start.second = make_pair(j,k);\n                    }else if(field[i][j][k] == '%'){\n                        if(i == 0){\n                            goal.first = make_pair(j,k);\n                        }else{\n                            goal.second = make_pair(j,k);\n                        }\n                    }\n                }\n            }\n        }\n        stack<pair<pii,pii> > sta;\n        sta.push(start);\n        bool used[H+2][W+2][H+2][W+2];\n        for(int i=0;i<H+2;i++){\n            for(int j=0;j<W+2;j++){\n                for(int k=0;k<H+2;k++){\n                    for(int l=0;l<W+2;l++){\n                        used[i][j][k][l] = false;\n                    }\n                }\n            }\n        }\n        for(int i=0;i<H+2;i++){\n            for(int j=0;j<W+2;j++){\n                for(int k=0;k<H+2;k++){\n                    for(int l=0;l<W+2;l++){\n                        if(used[i][j][k][l]) cerr << \"nyan\" << endl;\n                    }\n                }\n            }\n        }\n        bool ok = false;\n        while(not sta.empty()){\n            pair<pii,pii> now = sta.top();\n            sta.pop();\n            if(used[now.first.first][now.first.second][now.second.first][now.second.second]){\n                continue;\n            }\n            used[now.first.first][now.first.second][now.second.first][now.second.second] = true;\n            if(now == goal){\n                ok = true;\n                break;\n            }\n            for(int i=0;i<4;i++){\n                pair<pii,pii> next = now;\n                next.first.first += dy[i];\n                next.first.second += dx[i];\n                next.second.first += dy[i];\n                next.second.second += dx[i];\n                if(field[0][next.first.first][next.first.second] == '#'){\n                    next.first = now.first;\n                }\n                if(field[1][next.second.first][next.second.second] == '#'){\n                    next.second = now.second;\n                }\n                sta.push(next);\n            }\n        }\n        if(ok){\n            cout << \"Yes\" << endl;\n        }else{\n            cout << \"No\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp make_pair\n#define pb push_back\n#define F first\n#define S second\n\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nbool app[50][50][50][50];\nchar lr[53][53],rr[53][53];\nstring ans;\nint rsx,rsy,lsx,lsy,clx,cly,crx,cry,nrx,nlx,nry,nly;\n\nPI tp;\n\nmain(){\n  int w,h;\n  while(cin>>w>>h,w|h){\n    memset(app,0,6250000);\n    rep(i,h){\n      scanf(\" %s %s \",lr[i],rr[i]);\n      rep(j,w){\n        if(lr[i][j]=='L')lsx=i,lsy=j;\n        if(rr[i][j]=='R')rsx=i,rsy=j;\n      }\n    }\n\n    ans=\"No\";\n    queue<pair<PI,PI> > Q;\n    Q.push(mp(mp(lsx,lsy),mp(rsx,rsy)));\n\n    while(!Q.empty()){\n      tp=Q.front().F;\n      clx=tp.F,cly=tp.S;\n      tp=Q.front().S;Q.pop();\n      crx=tp.F,cry=tp.S;\n      if(lr[clx][cly]=='%' && rr[crx][cry]=='%'){\n        ans=\"Yes\";\n        break;\n      }\n      if(lr[clx][cly]=='%' || rr[crx][cry]=='%')continue;\n      app[clx][cly][crx][cry]=true;\n\n      rep(i,4){\n        nrx=crx+dx[i],nlx=clx+dx[i],nry=cry+dy[i],nly=cly-dy[i];\n        if(nrx<0 || nry<0 || nrx>=h || nry>=w || rr[nrx][nry]=='#')nrx=crx,nry=cry;\n        if(nlx<0 || nly<0 || nlx>=h || nly>=w || lr[nlx][nly]=='#')nlx=clx,nly=cly;\n        if(app[nlx][nly][nrx][nry])continue;\n        app[nlx][nly][nrx][nry]=true;\n        Q.push(mp(mp(nlx,nly),mp(nrx,nry)));\n      }\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n\nusing namespace std;\n\nint ldx[] = {1,0,-1,0}, ldy[] = {0,1,0,-1};\nint rdx[] = {-1,0,1,0}, rdy[] = {0,1,0,-1};\n\nint H, W;\nstring rooml[50], roomr[50];\nbool flag;\n\nint ls[50][50][50][50];\nint rs[50][50][50][50];\n\nvoid dfs(int lx, int ly, int rx, int ry){\n\tif(flag) return;\n\tif(ls[lx][ly][rx][ry]) return;\n\tls[lx][ly][rx][ry] = true;\n\tif(rooml[ly][lx] == '%' && roomr[ry][rx] == '%') {\n\t\tflag = true;\n\t\treturn;\n\t}\n\t//test\n\t//cout<<\"check1 end.\"<<endl;\n\tREP(k,0,4){\n\t\tint nlx = lx + ldx[k], nly = ly + ldy[k];\n\n\t\tif(!CH(nly,0,H) || !CH(nlx,0,W)) continue;\n\t\tif(rooml[nly][nlx] == '#') continue;\n\t\tint nrx = rx + rdx[k], nry = ry + rdy[k];\n\t\tif(CH(nry,0,H) && CH(nrx,0,W)\n\t\t\t\t&& roomr[nry][nrx]!='#'){\n\t\t\t\t\tdfs(nlx, nly, nrx, nry);\n\t\t}else{\n\t\t\t\t\tdfs(nlx, nly, rx, ry);\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\n\twhile(1){\n\t\tcin>>W>>H;\n\t\tif(W==0 && H==0) break;\n\t\tREP(i,0,H){\n\t\t\tcin>>rooml[i]>>roomr[i];\n\t\t}\n\n\t\tint slx, sly, srx, sry;\n\t\tREP(i,0,H){\n\t\t\tREP(j,0,W){\n\t\t\t\tif(rooml[i][j] == 'L'){\n\t\t\t\t\tslx = j;\n\t\t\t\t\tsly = i;\n\t\t\t\t}\n\t\t\t\tif(roomr[i][j] == 'R'){\n\t\t\t\t\tsrx = j;\n\t\t\t\t\tsry = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tflag = false;\n\t\tREP(i,0,50)REP(j,0,50)REP(k,0,50)REP(l,0,50) ls[i][j][k][l] = false;\n\t\tdfs(slx, slx, srx, sry);\n\n\t\tif(flag) cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> node;\nint ldx[4]={1,0,-1,0};\nint rdx[4]={-1,0,1,0};\nint dy[4]={0,1,0,-1};\n\nchar l[52][52];\nchar r[52][52];\n\nint main(void){\n\tint w,h;\n\twhile(cin >> w >> h,w|h){\n\t\tset<node> sets;\n\t\tint plx,ply,prx,pry;\n\t\tint slx,sly,srx,sry;\n\t\tfor(int x=0;x<=w+1;x++){\n\t\t\tl[x][0]=r[x][0]='#';\n\t\t\tl[x][h+1]=r[x][h+1]='#';\n\t\t}\n\t\tfor(int y=0;y<=h+1;y++){\n\t\t\tl[0][y]=r[0][y]='#';\n\t\t\tl[w+1][y]=r[w+1][y]='#';\n\t\t}\n\t\tfor(int y=1;y<=h;y++){\n\t\t\tfor(int x=1;x<=w;x++){\n\t\t\t\tcin >> l[x][y];\n\t\t\t\tif(l[x][y]=='%')\n\t\t\t\t\tplx=x,ply=y;\n\t\t\t\tif(l[x][y]=='L')\n\t\t\t\t\tslx=x,sly=y;\n\t\t\t}\n\t\t\tfor(int x=1;x<=w;x++){\n\t\t\t\tcin >> r[x][y];\n\t\t\t\tif(r[x][y]=='%')\n\t\t\t\t\tprx=x,pry=y;\n\t\t\t\tif(r[x][y]=='R')\n\t\t\t\t\tsrx=x,sry=y;\n\t\t\t}\n\t\t}\n\t\t/*for(int y=0;y<=h+1;y++){\n\t\t\tfor(int x=0;x<=w+1;x++){\n\t\t\t\tcout << l[x][y];\n\t\t\t}\n\t\t\tcout <<\" \" ;\n\t\t\tfor(int x=0;x<=w+1;x++){\n\t\t\t\tcout<< r[x][y];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tqueue<node> q;\n\t\tnode s,g;\n\t\ts=node(P(slx,sly),P(srx,sry));\n\t\tg=node(P(plx,ply),P(prx,pry));\n\t\tq.push(s);\n\t\tsets.insert(s);\n\t\twhile(!q.empty()){\n\t\t\tnode cur=q.front();q.pop();\n\t\t\t//cout << cur.F.F << \" \"<< cur.F.S << \" \"<< cur.S.F << \" \"<< cur.S.S << endl;\n\t\t\tif(cur == g)\n\t\t\t\tbreak;\n\t\t\tif((cur.F.F==plx&&cur.F.S==ply)||(cur.S.F==prx&&cur.F.S==pry))\n\t\t\t\tcontinue;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint lnx=cur.F.F+ldx[i],lny=cur.F.S+dy[i],rnx=cur.S.F+rdx[i],rny=cur.S.S+dy[i];\n\t\t\t\tif(l[lnx][lny]=='#'&&r[rnx][rny]=='#')\n\t\t\t\t\tcontinue;\n\t\t\t\tif(l[lnx][lny]=='#')\n\t\t\t\t\tlnx=cur.F.F,lny=cur.F.S;\n\t\t\t\tif(r[rnx][rny]=='#')\n\t\t\t\t\trnx=cur.S.F,rny=cur.S.S;\n\t\t\t\tnode c=node(P(lnx,lny),P(rnx,rny));\n\t\t\t\tif(sets.find(c)==sets.end())\n\t\t\t\t\tsets.insert(c),q.push(c);\n\t\t\t}\n\t\t}\n\t\tif(sets.find(g)!=sets.end())\n\t\t\tcout << \"Yes\" << endl;\n\t\telse\n\t\t\tcout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <memory.h>\n#include <queue>\n\nusing namespace std;\n\nint maxw,maxh;\nint lsx,lsy;\nint rsx,rsy;\n\nconst int dxl[] = {1,0,-1,0};\nconst int dxr[] = {-1,0,1,0};\nconst int dyl[] = {0,1,0,-1};\nconst int dyr[] = {0,1,0,-1};\n\ntypedef pair<int,int> PP;\ntypedef pair< PP,PP > P;\n\nbool visited[55][55][55][55] = {};\n\nint main(void)\n{\n\twhile(1)\n\t{\n\t\tchar fieldl[55][55];\n\t\tchar fieldr[55][55];\n\t\tmemset(visited,0,sizeof(visited));\n\t\tmemset(fieldl,0,sizeof(fieldl));\n\t\tmemset(fieldr,0,sizeof(fieldr));\n\t\tcin >> maxw >> maxh;\n\t\tif(maxw==0&&maxh==0)\n\t\t\treturn 0;\n\t\tfor(int y=1;y<=maxh;++y){\n\t\t\tfor(int x=1;x<=maxw;++x){\n\t\t\t\tcin >> fieldl[y][x];\n\t\t\t\tif(fieldl[y][x] == 'L'){\n\t\t\t\t\tlsy = y;lsx = x;\n\t\t\t\t}\n\t\t\t\tif(fieldl[y][x] == 'R'){\n\t\t\t\t\trsy = y;rsx = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int x=1;x<=maxw;++x){\n\t\t\t\tcin >> fieldr[y][x];\n\t\t\t\tif(fieldr[y][x] == 'L'){\n\t\t\t\t\tlsy = y;lsx = x;\n\t\t\t\t}\n\t\t\t\tif(fieldr[y][x] == 'R'){\n\t\t\t\t\trsy = y;rsx = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqueue<P> q;\n\t\tbool isGoal = false;\n\t\tq.push(P(PP(lsy,lsx),PP(rsy,rsx)));\n\t\tvisited[lsy][lsx][rsy][rsx] = true;\n\t\twhile(!q.empty()){\n\t\t\tP p = q.front();q.pop();\n\t\t\tvisited[p.first.first][p.first.second][p.second.first][p.second.second];\n\t\t\tfor(int i=0;i<4;++i){\n\t\t\t\tbool f=false;\n\t\t\t\tPP tol = PP(p.first.first+dyl[i],p.first.second+dxl[i]);//y,x\n\t\t\t\tPP tor = PP(p.second.first+dyr[i],p.second.second+dxr[i]);//y,x\n\t\t\t\tif(visited[tol.first][tol.second][tor.first][tor.second])\n\t\t\t\t\tcontinue;\n\t\t\t\tif(fieldl[tol.first][tol.second] == '%' && fieldr[tor.first][tor.second] == '%'){\n\t\t\t\t\tisGoal = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(fieldl[tol.first][tol.second] == '%' || fieldr[tor.first][tor.second] == '%')\n\t\t\t\t\tcontinue;\n\t\t\t\tPP l = PP(p.first.first,p.first.second);\n\t\t\t\tPP r = PP(p.second.first,p.second.second);\n\t\t\t\tif(fieldl[tol.first][tol.second] == '.'){\n\t\t\t\t\tl = tol;\n\t\t\t\t\tf=true;\n\t\t\t\t}\n\t\t\t\tif(fieldr[tor.first][tor.second] == '.'){\n\t\t\t\t\tr = tor;\n\t\t\t\t\tf=true;\n\t\t\t\t}\n\t\t\t\tif(!f)\n\t\t\t\t\tcontinue;\n\t\t\t\tq.push(P(l,r));\n\t\t\t}\n\t\t\tif(isGoal)\n\t\t\t\tbreak;\n\t\t}\n\t\t(isGoal?cout<<\"Yes\"<<endl:cout<<\"No\"<<endl);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define M 52\n#include<cstring>\nusing namespace std;\ntypedef pair<int,int> P;\nbool flag;\nint dx[]={1,-1,0,0},dy[]={0,0,-1,1},w,h;\nchar r[M][M],l[M][M];\nbool dp[M][M][M][M];\n\nvoid bfs(int a,int b,int c,int d){\n\tqueue<P> rr,ll;\n\tll.push(P(a,b));\n\trr.push(P(c,d));\n\twhile(!ll.empty()&&!flag){\n\t\tP p=ll.front(),q=rr.front();\n\t\tll.pop();rr.pop();\n\t\tint ly=p.first,lx=p.second,ry=q.first,rx=q.second;\n\t\tif(dp[ly][lx][ry][rx]!=0)\n\t\t\tcontinue;\n\t\tdp[ly][lx][ry][rx]=1;\n\t\tif(l[ly][lx]=='%'&&r[ry][rx]=='%'){\n\t\t\tflag=true;\n\t\t\tbreak;\n\t\t}else if(l[ly][lx]=='%'||r[ry][rx]=='%')\n\t\t\tcontinue;\n\t\tint nrx,nry,nlx,nly;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tnrx=dx[i]+rx;\n\t\t\tnry=dy[i]+ry;\n\t\t\tnlx=-dx[i]+lx;\n\t\t\tnly=dy[i]+ly;\n\t\t\tif(!(nrx>=0&&nrx<w&&nry>=0&&nry<h)||r[nry][nrx]=='#'){\n\t\t\t\tnrx=rx;nry=ry;\n\t\t\t}\n\t\t\tif(!(nlx>=0&&nlx<w&&nly>=0&&nly<h)||l[nly][nlx]=='#'){\n\t\t\t\tnlx=lx;nly=ly;\n\t\t\t}\n\t\t\tif(dp[nly][nlx][nry][nrx]==0){\n\t\t\t\tll.push(P(nly,nlx));\n\t\t\t\trr.push(P(nry,nrx));\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tint a,b,c,d;\n\twhile(cin>>w>>h,h||w){\n\t\tfor(int i=0;i<h;i++)\n\t\t\tcin>>l[i]>>r[i];\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(l[i][j]=='L'){\n\t\t\t\t\ta=i;b=j;\n\t\t\t\t}\n\t\t\t\tif(r[i][j]=='R'){\n\t\t\t\t\tc=i;d=j;\n\t\t\t\t}\n\t\t}\n\t\tmemset(dp,0,sizeof(dp));\n\t\tflag=false;\n\t\tbfs(a,b,c,d);\n\t\tputs(flag?\"Yes\":\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\nusing namespace std;\nstring s1[50],s2[50];\nint dx1[]={1,-1,0,0,},dy1[]={0,0,1,-1};\nint dx2[]={-1,1,0,0,},dy2[]={0,0,1,-1};\nint w,h,gx1,gx2,gy1,gy2;\nbool vis[51][51][51][51];\nbool bfs(int x1,int y1,int x2,int y2){\n  queue<int>q;\n  q.push(x1+y1*100+x2*10000+y2*1000000);\n  while(!q.empty()){\n    int p=q.front();q.pop();\n    x1=p%100;y1=p%10000/100;\n    x2=p%1000000/10000;y2=p/1000000;\n    for(int i=0;i<4;i++){\n      int x3=x1+dx1[i],y3=y1+dy1[i];\n      int x4=x2+dx2[i],y4=y2+dy2[i];\n      if(x3<0)x3=x1;if(x4<0)x4=x2;\n      if(y3<0)y3=y1;if(y4<0)y4=y2;\n      if(x3>=w)x3=x1;if(x4>=w)x4=x2;\n      if(y3>=h)y3=y1;if(y4>=h)y4=y2;\n          if(s1[y3][x3]=='#')y3=y1,x3=x1;\n          if(s2[y4][x4]=='#')y4=y2,x4=x2;\n          if(x1==gx1&&y1==gy1&&x2==gx2&&y2==gy2)return 1;\n          if(!(x3==gx1&&y3==gy1&&(x4!=gx2||y4!=gy2)))\n          if(!((x3!=gx1||y3!=gy1)&&x4==gx2&&y4==gy2))\n          if(!vis[x3][y3][x4][y4]){\n            vis[x3][y3][x4][y4]=1;\n            q.push(x3+y3*100+x4*10000+y4*1000000);\n          }\n        }\n    }\n    return 0;\n}\nint main(){\n  int x1,y1,x2,y2;\n  while(cin>>w>>h,w){\n    r(i,h)cin>>s1[i]>>s2[i];\n    r(i,h)r(j,w){\n      if(s1[i][j]=='L')x1=j,y1=i;\n      if(s2[i][j]=='R')x2=j,y2=i;\n      if(s1[i][j]=='%')gx1=j,gy1=i;\n      if(s2[i][j]=='%')gx2=j,gy2=i;\n    }\n    r(i,51)r(j,51)r(k,51)r(l,51)vis[l][k][j][i]=0;\n    vis[x1][y1][x2][y2]=1;\n    if(bfs(x1,y1,x2,y2))cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define lp(i,n) for(int i=0;i<n;i++)\nchar a[52][52],b[52][52];\nset<tuple<int,int,int,int>> dp;\nint ans;\n\nvoid calc(int lx,int ly,int rx,int ry){\n\tif(ans==1) return;\n\tif(a[lx][ly]=='%'&&b[rx][ry]=='%'){\n\t\tans=1;\n\t\treturn;\n\t}\n\telse if(a[lx][ly]=='%'||b[rx][ry]=='%') return;\n\ttuple<int,int,int,int> now;\n\tnow=make_tuple(lx,ly,rx,ry);\n\tif(dp.find(now)!=dp.end()) return;\n\tdp.insert(now);\n\tint nxl=lx,nyl=ly,nxr=rx,nyr=ry;\n\tif(a[lx+1][ly]!='#') nxl++;\n\tif(b[rx-1][ry]!='#') nxr--;\n\tcalc(nxl,nyl,nxr,nyr);\n\tnxl=lx;nyl=ly;nxr=rx;nyr=ry;\n\tif(a[lx-1][ly]!='#') nxl--;\n\tif(b[rx+1][ry]!='#') nxr++;\n\tcalc(nxl,nyl,nxr,nyr);\n\tnxl=lx;nyl=ly;nxr=rx;nyr=ry;\n\tif(a[lx][ly+1]!='#') nyl++;\n\tif(b[rx][ry+1]!='#') nyr++;\n\tcalc(nxl,nyl,nxr,nyr);\n\tnxl=lx;nyl=ly;nxr=rx;nyr=ry;\n\tif(a[lx][ly-1]!='#') nyl--;\n\tif(b[rx][ry-1]!='#') nyr--;\n\tcalc(nxl,nyl,nxr,nyr);\n\treturn;\n}\n\nint main(){\n\twhile(1){\n\t\tint w,h;\n\t\tcin>>w>>h;\n\t\tint stxl,styl,stxr,styr;\n\t\tif(w==0&&h==0) break;\n\t\tlp(i,52){\n\t\t\tlp(j,52){\n\t\t\t\ta[i][j]='#';\n\t\t\t\tb[i][j]='#';\n\t\t\t}\n\t\t}\n\t\tlp(i,h+1){\n\t\t\tif(i==0) continue;\n\t\t\tlp(j,w+1){\n\t\t\t\tif(j==0) continue;\n\t\t\t\tcin>>a[j][i];\n\t\t\t\tif(a[j][i]=='L'){\n\t\t\t\t\tstxl=j;\n\t\t\t\t\tstyl=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlp(j,w+1){\n\t\t\t\tif(j==0) continue;\n\t\t\t\tcin>>b[j][i];\n\t\t\t\tif(b[j][i]=='R'){\n\t\t\t\t\tstxr=j;\n\t\t\t\t\tstyr=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp.clear();\n\t\tans=0;\n\t\tcalc(stxl,styl,stxr,styr);\n\t\tif(ans==0) cout<<\"No\"<<endl;\n\t\telse cout<<\"Yes\"<<endl;\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define p(S) cout<<(S)<<endl\n#define F first\n#define S second\n#define ck(a,b) (0<=(a)&&(a)<b)\nusing namespace std;\n\nint mcrdx[]={1,0,-1,0};\nint mcldx[]={-1,0,1,0};\nint mcdy[]={0,1,0,-1};\nchar fL[51][51],fR[51][51];\nint mcH,mcW;\nbool mcok[51][51][51][51];\nbool goal;\nvoid mcdfs(pair<int,int> r,pair<int,int> l){\n\tif(mcok[r.F][r.S][l.F][l.S]) return ;\n\tif(fR[r.S][r.F]=='%'&&fL[l.S][l.F]=='%') {\n\t\tgoal=true;\n\t\tmemset(mcok,true,sizeof(mcok));\n\t\treturn ;\n\t}else if(fR[r.S][r.F]=='%'||fL[l.S][l.F]=='%'){\n\t\tmcok[r.F][r.S][l.F][l.S]=true;\n\t\treturn;\n\t}\n\tmcok[r.F][r.S][l.F][l.S]=true;\n\tREP(i,0,4){\n\t\tpair<int,int> nr={r.F+mcrdx[i],r.S+mcdy[i]},nl={l.F+mcldx[i],l.S+mcdy[i]};\n\t\tbool okr=true,okl=true;\n\t\tif(!ck(nr.F,mcW)||!ck(nr.S,mcH)||fR[nr.S][nr.F]=='#'){\n\t\t\tokr=false;\n\t\t}\n\t\tif(!ck(nl.F,mcW)||!ck(nl.S,mcH)||fL[nl.S][nl.F]=='#'){\n\t\t\tokl=false;\n\t\t}\n\t\tif(!okr&&!okl)  continue;\n//\t\tcout<<nr.F<<\" \"<<nr.S<<\" \"<<nl.F<<\" \"<<nl.S<<endl;\n\t\tif(okr&&!okl)\tmcdfs(nr,l);\n\t\tif(!okr&&okl)\tmcdfs(r,nl);\n\t\tif(okr&&okl)\tmcdfs(nr,nl);\n\t}\n\n\treturn ;\n}\nint main(){\n\n\twhile(cin>>mcW>>mcH,mcW){\n\t\tpair<int,int> Rin,Len;\n\t\tmemset(mcok,false,sizeof(mcok));\n\t\tREP(i,0,mcH) {\n\t\t\tREP(j,0,mcW){\n\t\t\t\tcin>>fL[i][j];\n\t\t\t\tif(fL[i][j]=='L')\tLen={j,i};\n\t\t\t}\n\t\t\tREP(j,0,mcW){\n\t\t\t\tcin>>fR[i][j];\n\t\t\t\tif(fR[i][j]=='R')\tRin={j,i};\n\t\t\t}\n\t\t}\n\t\tgoal=false;\n\t\tmcdfs(Rin,Len);\n\t\tp(goal?\"Yes\":\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int GOAL = 1;\nconst int WAY = 0;\nconst int WALL = -1;\n\nconst int dx[4] = {-1, 1, 0, 0};\nconst int dy[4] = {0, 0, -1, 1};\n\nstruct state {\n\tint l_x, l_y, r_x, r_y;\n\tstate(int l_x, int l_y, int r_x, int r_y):l_x(l_x), l_y(l_y), r_x(r_x), r_y(r_y) {}\n};\n\nint w, h;\nbool visited[52][52][52][52];\nvector<vector<int> > l_map, r_map;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> w >> h, w) {\n\t\tl_map.clear();\n\t\tl_map.resize(h + 2, vector<int>(w + 2, WALL));\n\n\t\tr_map.clear();\n\t\tr_map.resize(h + 2, vector<int>(w + 2, WALL));\n\n\t\tint l_sx, l_sy, r_sx, r_sy;\n\t\tfor(int i = 1; i <= h; ++i) {\n\t\t\tstring l, r;\n\t\t\tcin >> l >> r;\n\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tswitch(l[j]) {\n\t\t\t\tcase '%':\n\t\t\t\t\tl_map[i][j + 1] = GOAL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tl_map[i][j + 1] = WALL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\tl_sx = j + 1;\n\t\t\t\t\tl_sy = i;\n\t\t\t\tdefault:\n\t\t\t\t\tl_map[i][j + 1] = WAY;\n\t\t\t\t}\n\n\t\t\t\tswitch(r[j]) {\n\t\t\t\tcase '%':\n\t\t\t\t\tr_map[i][j + 1] = GOAL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tr_map[i][j + 1] = WALL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tr_sx = j + 1;\n\t\t\t\t\tr_sy = i;\n\t\t\t\tdefault:\n\t\t\t\t\tr_map[i][j + 1] = WAY;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstack<state> sta;\n\t\tsta.push(state(l_sx, l_sy, r_sx, r_sy));\n\t\tbool reachable = false;\n\t\tmemset(visited, false, sizeof(visited));\n\n\t\twhile(!sta.empty()) {\n\t\t\tconst state& s = sta.top();\n\t\t\tint l_x = s.l_x, l_y = s.l_y, r_x = s.r_x, r_y = s.r_y;\n\t\t\tsta.pop();\n\n\t\t\tvisited[l_x][l_y][r_x][r_y] = true;\n\t\t\t\n\t\t\tif(l_map[l_y][l_x] == GOAL && r_map[r_y][r_x] == GOAL) {\n\t\t\t\treachable = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < 4; ++i) {\n\t\t\t\tint l_nx = l_x + dx[i], l_ny = l_y + dy[i], r_nx = r_x - dx[i], r_ny = r_y + dy[i];\n\t\t\t\tif(l_map[l_ny][l_nx] == WALL) {\n\t\t\t\t\tl_nx = l_x;\n\t\t\t\t\tl_ny = r_y;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(r_map[r_ny][r_nx] == WALL) {\n\t\t\t\t\tr_nx = r_x;\n\t\t\t\t\tr_ny = r_y;\n\t\t\t\t}\n\n\t\t\t\tif(!visited[l_nx][l_ny][r_nx][r_ny])\n\t\t\t\t\tsta.push(state(l_nx, l_ny, r_nx, r_ny));\n\t\t\t}\n\t\t}\n\n\t\tcout << (reachable ? \"Yes\" : \"No\") << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#define N 50\n#define y1 first.first\n#define x1 first.second\n#define y2 second.first\n#define x2 second.second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\n\nvoid bfs();\n\nint w,h,sy1,sx1,sy2,sx2,gy1,gx1,gy2,gx2,ans;\nstring r1[N],r2[N];\nset<P1> visited;\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(!w&&!h) break;\n    for(int i=0;i<h;i++) cin>>r1[i]>>r2[i];\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(r1[i][j]=='L') sy1=i,sx1=j;\n\tif(r1[i][j]=='%') gy1=i,gx1=j;\n\tif(r2[i][j]=='R') sy2=i,sx2=j;\n\tif(r2[i][j]=='%') gy2=i,gx2=j;\n      }\n    ans=0;\n    bfs();\n    if(ans) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n  return 0;\n}\n\nvoid bfs(){\n  int dy[4]={0,-1,0,1},dx[4]={-1,0,1,0};\n  queue<P1> q;\n  P1 k=(P1){sy1,sx1,sy2,sx2};\n  q.push(k);\n  visited.insert(k);\n  while(!q.empty()){\n    P1 t=q.front(); q.pop();\n    for(int i=0;i<4;i++){\n      int ny1=t.y1+dy[i],nx1=t.x1+dx[i];\n      int ny2=t.y2-dy[i],nx2=t.y2-dx[i];\n      if(ny1<0) ny1=0;\n      if(nx1<0) nx1=0;\n      if(h<=ny1) ny1=h;\n      if(w<=nx1) nx1=w;\n      if(ny2<0) ny2=0;\n      if(nx2<0) nx2=0;\n      if(h<=ny2) ny2=h;\n      if(w<=nx2) nx2=w;\n      if(r1[ny1][nx1]=='#') ny1=t.y1,nx1=t.x1;\n      if(r2[ny2][nx2]=='#') ny2=t.y2,nx2=t.x2;\n      P1 u=(P1){ny1,nx1,ny2,nx2};\n      if(visited.find(u)!=visited.end()) continue;\n      visited.insert(u);\n      if(ny1==gy1&&nx1==gx1&&ny2==gy2&&nx2==gx2){\n\tans=1;\n\tbreak;\n      }\n    }\n    if(ans) break;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\n# define max_n 50\n\nstruct points {\n    int sx,sy,tx,ty;\n};\n\nvoid print(points p){\n    cout << p.sx << \" \" << p.sy << \" \" << p.tx << \" \" << p.ty << endl;\n}\n\nint main(void) {\n    int i,j;\n    int h,w;\n    while(cin >> w >> h, h){\n        vs s(h),t(h);\n        rep(i,h) cin >> s[i] >> t[i];\n\n        points p;\n        rep(i,h)rep(j,w){\n            if(s[i][j] == 'L'){\n                p.sx = i;\n                p.sy = j;\n            }\n            if(t[i][j] == 'R'){\n                p.tx = i;\n                p.ty = j;\n            }\n        }\n\n        queue<points> q;\n        q.push(p);\n\n        bool used[50][50][50][50]={};\n        used[p.sx][p.sy][p.tx][p.ty] = true;\n\n        int dx[4] = {1,0,-1,0};\n        int dy[4] = {0,1,0,-1};\n\n        bool ans = false;\n\n        while(q.size()){\n            points p = q.front();\n            q.pop();\n\n            if(s[p.sx][p.sy] == '%' && t[p.tx][p.ty] == '%'){\n                ans = true;\n                break;\n            }\n            if(s[p.sx][p.sy] == '%' || t[p.tx][p.ty] == '%') continue;\n\n            rep(i,4){\n                points pp;\n\n                pp.sx = p.sx + dx[i];\n                pp.sy = p.sy + dy[i];\n                if(pp.sx < 0 || pp.sx >= h || pp.sy < 0 || pp.sy >= w || s[pp.sx][pp.sy] == '#'){\n                    pp.sx = p.sx;\n                    pp.sy = p.sy;\n                }\n\n                pp.tx = p.tx + dx[i];\n                pp.ty = p.ty + dy[(i+2)%4];\n                if(pp.tx < 0 || pp.tx >= h || pp.ty < 0 || pp.ty >= w || t[pp.tx][pp.ty] == '#'){\n                    pp.tx = p.tx;\n                    pp.ty = p.ty;\n                }\n\n                if(used[pp.sx][pp.sy][pp.tx][pp.ty])continue;\n\n                used[pp.sx][pp.sy][pp.tx][pp.ty] = true;\n                q.push(pp);\n\n            }\n        }\n\n        if(ans){\n            cout << \"Yes\" << endl;\n        }else{\n            cout << \"No\" << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<pair<int, int>, pair<int, int>> PPIIII;\n\nint dx[] = { 1,0,-1,0 };\nint dy[] = { 0,1,0,-1 };\n\nvoid solve( int W, int H ) {\n\tpair<int, int> startR, startL, goalR, goalL;\n\tvector<vector<vector<vector<bool>>>>dp( H + 2, vector<vector<vector<bool>>>( W + 2, vector<vector<bool>>( H + 2, vector<bool>( W + 2, 0 ) ) ) );\n\tvector<vector<vector<char>>>mapd( 2, vector<vector<char>>( H + 2, vector<char>( W + 2, '#' ) ) );\n\tfor( size_t i = 1; i <= H; i++ ) {\n\t\tfor( size_t j = 1; j <= W; j++ ) {\n\t\t\tcin >> mapd[0][i][j];\n\t\t\tif( mapd[0][i][j] == 'L' ) {\n\t\t\t\tstartL = make_pair( i, j );\n\t\t\t} else if( mapd[0][i][j] == '%' ) {\n\t\t\t\tgoalL = make_pair( i, j );\n\t\t\t}\n\t\t}\n\t\tfor( int j = W; j >= 1; j-- ) {\n\t\t\tcin >> mapd[1][i][j];\n\t\t\tif( mapd[1][i][j] == 'R' ) {\n\t\t\t\tstartR = make_pair( i, j );\n\t\t\t} else if( mapd[1][i][j] == '%' ) {\n\t\t\t\tgoalR = make_pair( i, j );\n\t\t\t}\n\t\t}\n\t}\n\tdp[startL.first][startL.second][startR.first][startR.second] = 1;\n\n\n\tqueue<PPIIII>que;\n\tbool f = true;\n\tque.push( make_pair( startL, startR ) );\n\twhile( que.size() ) {\n\t\tauto now = que.front(); que.pop();\n\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\tauto next = now;\n\t\t\tnext.first.first += dx[i];\n\t\t\tnext.first.second += dy[i];\n\t\t\tnext.second.first += dx[i];\n\t\t\tnext.second.second += dy[i];\n\t\t\tif( mapd[0][next.first.first][next.first.second] == '#' ) {\n\t\t\t\tnext.first = now.first;\n\t\t\t}\n\t\t\tif( mapd[1][next.second.first][next.second.second] == '#' ) {\n\t\t\t\tnext.second = now.second;\n\t\t\t}\n\t\t\tif( now.first == next.first&&now.second == next.second ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif( goalL == next.first&&goalR == next.second&& now.first != next.first&&now.second != next.second ) {\n\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif( 0 < next.first.first&&next.first.first < H + 2 &&\n\t\t\t\t0 < next.first.second&&next.first.second < W + 2 &&\n\t\t\t\t0 < next.second.first&&next.second.first < H + 2 &&\n\t\t\t\t0 < next.second.second&&next.second.second < W + 2 ) {\n\t\t\t\tif( dp[next.first.first][next.first.second][next.second.first][next.second.second] == 0 ) {\n\t\t\t\t\tif( goalL == next.first&&goalR == next.second ) {\n\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdp[next.first.first][next.first.second][next.second.first][next.second.second] = 1;\n\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"No\" << endl;\n\treturn;\n}\n\nint main() {\n\tint W, H;\n\twhile( cin >> W >> H, W&&H ) {\n\t\tsolve( W, H );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ndouble EPS=1e-10;\ndouble EQ(double a,double b){\n\treturn abs(a-b)<EPS;\n}\n\nbool used[51][51][51][51];\nint W,H;\nchar field[2][101][101];\nint sy[2],sx[2],gy[2],gx[2];\n\nconst int dy[]={-1,0,1,0};\nconst int dx[]={0,-1,0,1};\n\ntypedef pair<pii,pii> ppi;\n\nbool bfs(){\n\tqueue<ppi> q;\n\tq.push(make_pair(pii(sy[0],sx[0]),pii(sy[1],sx[1])));\n\tused[sy[0]][sx[0]][sy[1]][sx[1]]=true;\n\twhile(q.size()){\n\t\tppi p=q.front();q.pop();\n\t\tint cy1=p.first.first;\n\t\tint cx1=p.first.second;\n\t\tint cy2=p.second.first;\n\t\tint cx2=p.second.second;\n\t\t//if(cy1>=0&&cx1>=0&&cy1<H&&cx1<W)\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(i==0||i==2){\n\t\t\t\tint ny1=cy1+dy[i];\n\t\t\t\tint nx1=cx1+dx[i];\n\t\t\t\tif(!(ny1>=0&&nx1>=0&&ny1<H&&nx1<W)||field[0][ny1][nx1]=='#'){\n\t\t\t\t\tny1=cy1;\n\t\t\t\t\tnx1=cx1;\n\t\t\t\t}\n\t\t\t\tint ny2=cy2+dy[i];\n\t\t\t\tint nx2=cx2+dx[i];\n\t\t\t\tif(!(ny2>=0&&nx2>=0&&ny2<H&&nx2<W)||field[1][ny2][nx2]=='#'){\n\t\t\t\t\tny2=cy2;\n\t\t\t\t\tnx2=cx2;\n\t\t\t\t}\n\t\t\t\tif(!used[ny1][nx1][ny2][nx2]){\n\t\t\t\t\tif(!((ny2==gy[1]&&nx2==gx[1])^(ny1==gy[0]&&nx1==gx[0]))){\n\t\t\t\t\t\tused[ny1][nx1][ny2][nx2]=true;\n\t\t\t\t\t\tq.push(make_pair(pii(ny1,nx1),pii(ny2,nx2)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint ny1=cy1+dy[i];\n\t\t\t\tint nx1=cx1+dx[i];\n\t\t\t\tif(!(ny1>=0&&nx1>=0&&ny1<H&&nx1<W)||field[0][ny1][nx1]=='#'){\n\t\t\t\t\tny1=cy1;\n\t\t\t\t\tnx1=cx1;\n\t\t\t\t}\n\t\t\t\tint ny2=cy2-dy[i];\n\t\t\t\tint nx2=cx2-dx[i];\n\t\t\t\tif(!(ny2>=0&&nx2>=0&&ny2<H&&nx2<W)||field[1][ny2][nx2]=='#'){\n\t\t\t\t\tny2=cy2;\n\t\t\t\t\tnx2=cx2;\n\t\t\t\t}\n\t\t\t\tif(!used[ny1][nx1][ny2][nx2]){\n\t\t\t\t\tif(!( (ny2==gy[1]&&nx2==gx[1])^(ny1==gy[0]&&nx1==gx[0]) )){\n\t\t\t\t\t\tused[ny1][nx1][ny2][nx2]=true;\n\t\t\t\t\t\tq.push(make_pair(pii(ny1,nx1),pii(ny2,nx2)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn used[gy[0]][gx[0]][gy[1]][gx[1]];\n}\n\nvoid solve(){\n\twhile(cin>>W>>H&&(H|W)){\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<2*W;j++){\n\t\t\t\tif(j<W){\n\t\t\t\t\tcin>>field[0][i][j];\n\t\t\t\t\tif(field[0][i][j]=='L'){\n\t\t\t\t\t\tfield[0][i][j]='.';\n\t\t\t\t\t\tsy[0]=i;\n\t\t\t\t\t\tsx[0]=j;\n\t\t\t\t\t}\n\t\t\t\t\telse if(field[0][i][j]=='%'){\n\t\t\t\t\t\tgy[0]=i;\n\t\t\t\t\t\tgx[0]=j;\n\t\t\t\t\t\tfield[0][i][j]='.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcin>>field[1][i][j%W];\n\t\t\t\t\tif(field[1][i][j%W]=='R'){\n\t\t\t\t\t\tfield[1][i][j%W]='.';\n\t\t\t\t\t\tsy[1]=i;\n\t\t\t\t\t\tsx[1]=j%W;\n\t\t\t\t\t}\n\t\t\t\t\telse if(field[1][i][j%W]=='%'){\n\t\t\t\t\t\tgy[1]=i;\n\t\t\t\t\t\tgx[1]=j%W;\n\t\t\t\t\t\tfield[1][i][j%W]='.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemset(used,0,sizeof(used));\n\t\tif(bfs()){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t}\n\t\telse cout<<\"No\"<<endl;\n\t}\n}\nint main(){\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<cmath>\n#include<utility>\n#include<functional>\n#include<map>\n#include<set>\n#include<cctype>\n\n\n#define FOR(i, a, b) for( int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for( int i=(a);i>=(b);i--)\n#define LFOR(i, a, b) for( long long int i=(a);i<=(b);i++)\n#define LRFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LLINF 1000000000000000000 //9000000000000000000\n#define PI 3.14159265358979\n#define MAXI 7500000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\n\nint dy[4] = { 0,0,1,-1 };\nint dx[4] = { 1,-1,0,0 };\n\n//int dp[50][50][50][50] = {};//ly,lx,ry,rx\n\n\nint main(void) {\n\t\n\twhile (1) {\n\n\t\tstruct Pos{\n\t\tpublic:\n\t\t\tint leftx, lefty, rightx, righty;\n\t\t};\n\n\t\tint w, h;\n\t\tint lx = -1, ly = -1, rx = -1, ry = -1;\n\t\tint lgx = -1, lgy = -1, rgx = -1, rgy = -1;\n\n\t\tvector< vector< vector< vector<int> > > > dp(50, vector< vector< vector<int > > >(50, vector< vector<int> >(50, vector<int>(50, 0))));\n\t\t\n\n\t\tqueue< Pos > que;\n\t\tPos now;\n\n\t\tcin >> w >> h;\n\n\t\tif (w == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tvector<string> left(h), right(h);\n\n\t\tFOR(i, 0, h-1) {\n\t\t\tcin >> left[i] >> right[i];\n\t\t}\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (left[i][j] == 'L') {\n\t\t\t\t\tlx = j;\n\t\t\t\t\tly = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (right[i][j] == 'R') {\n\t\t\t\t\trx = j;\n\t\t\t\t\try = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (left[i][j] == '%') {\n\t\t\t\t\tlgx = j;\n\t\t\t\t\tlgy = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lgx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (right[i][j] == '%') {\n\t\t\t\t\trgx = j;\n\t\t\t\t\trgy = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rgx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdp[ly][lx][ry][rx] = 1;\n\n\t\tnow.lefty = ly;\n\t\tnow.leftx = lx;\n\t\tnow.righty = ry;\n\t\tnow.rightx = rx;\n\t\t\n\t\tque.push(now);\n\n\n\t\t/*while (!que.empty()) {\n\t\t\tnow = que.front();\n\t\t\t\n\t\t\tque.pop();\n\t\t\tly = now.lefty;\n\t\t\tlx = now.leftx;\n\t\t\try = now.righty;\n\t\t\trx = now.rightx;\n\t\t\t//cout << ly << \" \" << lx << \" \" << ry << \" \" << rx << endl;\n\n\t\t\tFOR(i, 0, 3) {\n\t\t\t\t\n\t\t\t\tif (ly + dy[i] >= 0 && lx - dx[i] >= 0 && ry + dy[i] <= h - 1 && rx + dx[i] <= w - 1 && ly + dy[i] <= h - 1 && lx - dx[i] <= w - 1 && ry + dy[i] >= 0 && rx + dx[i] >= 0) {\n\t\t\t\t\tif (dp[ly + dy[i]][lx - dx[i]][ry + dy[i]][rx + dx[i]] != 1) {\n\t\t\t\t\t\tif (left[ly + dy[i]][lx - dx[i]] == '#') {\n\t\t\t\t\t\t\tif (right[ry + dy[i]][rx + dx[i]] == '#') {\n\t\t\t\t\t\t\t\t//no\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdp[ly][lx][ry + dy[i]][rx + dx[i]] = 1;\n\t\t\t\t\t\t\t\tnow.lefty = ly;\n\t\t\t\t\t\t\t\tnow.leftx = lx;\n\t\t\t\t\t\t\t\tnow.righty = ry + dy[i];\n\t\t\t\t\t\t\t\tnow.rightx = rx + dx[i];\n\t\t\t\t\t\t\t\tque.push(now);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (right[ry + dy[i]][rx + dx[i]] == '#') {\n\t\t\t\t\t\t\t\tdp[ly + dy[i]][lx - dx[i]][ry][rx] = 1;\n\t\t\t\t\t\t\t\tnow.lefty = ly + dy[i];\n\t\t\t\t\t\t\t\tnow.leftx = lx - dx[i];\n\t\t\t\t\t\t\t\tnow.righty = ry;\n\t\t\t\t\t\t\t\tnow.rightx = rx;\n\t\t\t\t\t\t\t\tque.push(now);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdp[ly + dy[i]][lx - dx[i]][ry + dy[i]][rx + dx[i]] = 1;\n\t\t\t\t\t\t\t\tnow.lefty = ly + dy[i];\n\t\t\t\t\t\t\t\tnow.leftx = lx - dx[i];\n\t\t\t\t\t\t\t\tnow.righty = ry + dy[i];\n\t\t\t\t\t\t\t\tnow.rightx = rx + dx[i];\n\t\t\t\t\t\t\t\tque.push(now);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\n\t\tif (dp[lgy][lgx][rgy][rgx] == 1) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t\t\n\n\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2153&lang=jp\ntypedef long long ll;\ntypedef vector<vector<char>> vvc;\ntypedef vector<char> vc;\ntypedef vector<vector<int>> vvi;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nint dlx[4] = {1, 0, -1, 0};\nint dly[4] = { 0,1,0,-1 };\nint drx[4] = { 1,0,-1,0 };\nint dry[4] = { 0,-1,0,1 };\n\nchar L[55][55];\nchar R[55][55];\n\nint W, H;\nbool dfs(pii l,pii r,vvi Lf,vvi Rf){\n\tLf[l.first][l.second] = 1;\n\tRf[r.first][r.second] = 1;\n\tfor (int i = 0; i < 4;i++) {\n\t\tint lx = l.first + dlx[i], ly = l.second + dly[i];\n\t\tint rx = r.first + drx[i], ry = r.second + dry[i];\n\t\tif (Lf[lx][ly] == 1 && Rf[rx][ry] == 1) continue;\n\t\tif (L[lx][ly] == '%' && R[rx][ry] == '%') return true;\n\t\tif (L[lx][ly] == '#' && R[rx][ry] == '#')continue;\n\t\tif (L[lx][ly] == '.' && R[rx][ry] == '.') {\n\t\t\tif (dfs({ lx,ly }, { rx,ry }, Lf, Rf)) return true;\n\t\t}\n\t\telse if(L[lx][ly] == '.' && R[rx][ry] == '#'){\n\t\t\tif (dfs({ lx,ly }, { r.first,r.second }, Lf, Rf))return true;\n\t\t}\n\t\telse if (L[lx][ly] == '#' && R[rx][ry] == '.') {\n\t\t\tif (dfs({ l.first,l.second }, { rx,ry }, Lf, Rf))return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\twhile (cin >> W >> H) {\n\t\tif ((W | H) == 0)break;\n\t\tvvi Lf(H + 2, vi(W + 2, 0));\n\t\tvvi Rf(H + 2, vi(W + 2, 0));\n\n\t\tfor (int i = 0; i < 55;i++) for (int j = 0; j < 55;j++) L[i][j] = R[i][j] = '#';\n\n\t\tpii ls, rs;\n\t\tfor (int i = 1; i <= H;i++) {\n\t\t\tfor (int j = 1;j <= W;j++) {\n\t\t\t\tcin >> L[i][j];\n\t\t\t\tif (L[i][j] == 'L') ls = { i,j };\n\t\t\t}\n\t\t\tfor (int j = 1;j <= W;j++) {\n\t\t\t\tcin >> R[i][j];\n\t\t\t\tif (R[i][j] == 'R') rs = { i,j };\n\t\t\t}\n\t\t}\n\n\t\tif (dfs(ls, rs, Lf, Rf)) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t\telse cout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <ctime>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <stack>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\ntypedef vector<string> vs;\ntypedef vector<int> vi;\n\n#define rep(i,b) loop(i,0,b)\n#define loop(i,a,b) for(int i=(a); i<int(b); i++)\n#define all(c) (c).begin(), (c).end()\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nint h,w;\ninline bool in(int x, int y){\n    return 0<=x && 0<=y && x<w && y<h;\n}\n\nvi id{0,1,2,3};\nbool solve(vs const& g1, vs const& g2){\n    int sx1, sy1, sx2, sy2;\n    rep(i,h)rep(j,w){\n        if(g1[i][j]=='L'){\n            sx1=j;sy1=i;\n        }\n        if(g2[i][j]=='R'){\n            sx2=j;sy2=i;\n        }\n    }\n    queue<vi> q;\n    static bool vis[64][64][64][64];\n    memset(vis,0,sizeof(vis));\n    q.push(vi{sx1,sy1,sx2,sy2});\n    while(q.size()){\n        vi s=q.front();q.pop();\n        int x1=s[0],y1=s[1],x2=s[2],y2=s[3];\n        if(vis[x1][y1][x2][y2])continue;\n        vis[x1][y1][x2][y2]=true;\n        if(g1[y1][x1]=='%' && g2[y2][x2]=='%') return true;\n        if(g1[y1][x1]=='%' || g2[y2][x2]=='%') continue;\n\n        random_shuffle(all(id));\n        rep(i,4){\n            int d=id[i];\n            int nx1=x1+dx[d],ny1=y1+dy[d];\n            int nx2,ny2;\n            if(d&1){\n                nx2=x2+dx[d],ny2=y2+dy[d];\n            }else{\n                nx2=x2-dx[d],ny2=y2-dy[d];\n            }\n            if(!in(nx1,ny1) || g1[ny1][nx1]=='#')nx1=x1,ny1=y1;\n            if(!in(nx2,ny2) || g2[ny2][nx2]=='#')nx2=x2,ny2=y2;\n            q.push(vi{nx1,ny1,nx2,ny2});\n        }\n    }\n    return false;    \n}\n\nint main(){\n    srand(time(0));\n    while(cin>>w>>h && w|h){\n        vs g1(h), g2(h);\n        rep(i,h) cin>>g1[i]>>g2[i];\n        vs ans{\"No\",\"Yes\"};\n        cout << ans[solve(g1,g2)] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<math.h>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  int h, w;\n  while(cin >> w >> h && h != 0){\n    vector< vector<char> > L(h);\n    vector< vector<char> > R(h);\n    pair<int, int> ls;\n    pair<int, int> rs;\n    char a;\n    for(int i = 0; i < h ; i++){\n      for(int j = 0; j < w ; j++){\n        cin >> a;\n        L[i].push_back(a);\n        if(a == 'L') ls = make_pair(i, j);\n      }\n      for(int j = 0; j < w ; j++){\n        cin >> a;\n        R[i].push_back(a);\n        if(a == 'R') rs = make_pair(i, j);\n      }\n    }\n\n    int flag = 0;\n    vector< pair<int, int> > move;\n    move.push_back(make_pair(0,1));\n    move.push_back(make_pair(1,0));\n    move.push_back(make_pair(0,-1));\n    move.push_back(make_pair(-1,0));\n    int nodes[50][50][50][50] = {{{{0}}}};\n    nodes[ls.first][ls.second][rs.first][rs.second] = 1;\n    queue< pair< pair<int, int> , pair<int, int> > > q;\n    q.push(make_pair(ls, rs));\n    while(!q.empty()){\n      pair<pair<int, int>, pair<int, int> > k = q.front();\n      q.pop();\n      int lv = k.first.first;\n      int lh = k.first.second;\n      int rv = k.second.first;\n      int rh = k.second.second;\n      for(int i = 0; i < 4; i++){\n        pair<int, int> m = move[i];\n        int mv = m.first;\n        int mh = m.second;\n        int a,b,c,d;\n        if(lv + mv >= 0 && lv + mv < h) a = lv + mv;\n        else a = lv;\n        if(lh + mh >= 0 && lh + mh < w) b = lh + mh;\n        else b = lh;\n        if(rv + mv >= 0 && rv + mv < h) c = rv + mv;\n        else c = rv;\n        if(rh - mh >= 0 && rh - mh < w) d = rh - mh;\n        else d = rh;\n        if(L[a][b] == '%' && R[c][d] == '%') flag = 1;\n        else if(L[a][b] == '%' || R[c][d] == '%') continue;\n        if(L[a][b] == '#'){\n          a = lv;\n          b = lh;\n        }\n        if(R[c][d] == '#'){\n          c = rv;\n          d = rh;\n        }\n        if(nodes[a][b][c][d] != 1){\n          q.push(make_pair(make_pair(a,b), make_pair(c,d)));\n          nodes[a][b][c][d] = 1;\n        }\n      }\n    }\n    if(flag == 1) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <string>\n#include <vector>\n#include <set>\n#include <cstring>\nusing namespace std;\n\ntypedef pair<pair<int,int>,pair<int,int> > pii;\n#define REP(i,n) for(int i=0; i<n; ++i)\n\nbool state[50][50][50][50];\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\n\nint main() {\n    int w,h;\n    while(cin>>w>>h, w|h) {\n        vector<string> left(h),right(h);\n        REP(i,h) cin>>left[i]>>right[i];\n\n        int lx,ly,rx,ry;\n        int glx,gly,grx,gry;\n        REP(i,h) REP(j,w) {\n            if(left[i][j] == 'L') lx = j, ly = i, left[i][j] = '.';\n            if(left[i][j] == '%') glx = j, gly = i, left[i][j] = '.';\n        }\n        REP(i,h) REP(j,w) {\n            if(right[i][j] == 'R') rx = j, ry = i, right[i][j] = '.';\n            if(right[i][j] == '%') grx = j, gry = i, right[i][j] = '.';\n        }\n\n        memset(state, false, sizeof(state));\n        queue<pii> Q;\n        Q.push(make_pair(make_pair(lx,ly),make_pair(rx,ry)));\n        while(!Q.empty()) {\n            pii now = Q.front(); Q.pop();\n            if(now.first.first == glx && now.first.second == gly\n               && now.second.first == grx && now.second.second == gry) {\n                goto SUCCESS;\n            }\n            int lx = now.first.first, ly = now.first.second;\n            int rx = now.second.first, ry = now.second.second;\n            if(state[lx][ly][rx][ry]) continue;\n            state[lx][ly][rx][ry] = true;\n            for(int i=0; i<4; ++i) {\n                int nlx = lx + dx[i],nly = ly + dy[i];\n                int nrx = rx + dx[(i+2)%4],nry = ry + dy[i];\n                if(nlx < 0 || nlx >= w || nrx < 0 || nrx >= w) continue;\n                if(nry < 0 || nry >= h || nly < 0 || nly >= h) continue;\n                if(left[nly][nlx] == '#') {\n                    nly = ly;\n                    nlx = lx;\n                }\n                if(right[nry][nrx] == '#') {\n                    nry = ry;\n                    nrx = rx;\n                }\n                Q.push(make_pair(make_pair(nlx,nly),make_pair(nrx,nry)));\n            }\n        }\n\n        goto BAD;\n    SUCCESS:\n        cout<<\"Yes\"<<endl;\n        continue;\n    BAD:\n        cout<<\"No\"<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nbool d[55][55][55][55];\n\nint main() {\n    int n, m;\n    while (cin >> n >> m, n || m) {\n        vector<string> G1(m), G2(m);\n        queue<P> que1, que2;\n        for (int i = 0; i < 55; i++)\n            for (int j = 0; j < 55; j++)\n                for (int l = 0; l < 55; l++)\n                    for (int k = 0; k < 55; k++)\n                        d[i][j][k][l] = true;\n        for (int i = 0; i < m; i++) {\n            cin >> G1[i] >> G2[i];\n            for (int j = 0; j < n; j++) {\n                if (G1[i][j] == 'L') que1.push(P(i, j));\n                if (G2[i][j] == 'R') que2.push(P(i, j));\n            }\n        }\n\n        d[que1.front().first][que1.front().second][que2.front().first][que2.front().second] = false;\n\n        bool res = false;\n        while (1) {\n            if (!que1.size() || !que2.size()) break;\n            P p1 = que1.front(); que1.pop();\n            P p2 = que2.front(); que2.pop();\n\n            int x1 = p1.first;\n            int y1 = p1.second;\n            int x2 = p2.first;\n            int y2 = p2.second;\n            for (int i = 0; i < 4; i++) {\n                int nx1 = x1 + dx[i];\n                int ny1 = y1 + dy[i];\n                int nx2 = x2 + dx[i];\n                int ny2 = y2 - dy[i];\n\n                if ( nx1 < 0 || nx1 >= m || ny1 < 0 || ny1 >= n || G1[nx1][ny1] == '#') nx1 = x1, ny1 = y1;\n                if ( nx2 < 0 || nx2 >= m || ny2 < 0 || ny2 >= n || G2[nx2][ny2] == '#') nx2 = x2, ny2 = y2;\n\n                if (G1[nx1][ny1] == '%' && G2[nx2][ny2] == '%') {\n                    res = true;\n                    break;\n                }\n                if (G1[nx1][ny1] == '%' || G2[nx2][ny2] == '%') continue;\n                if (d[nx1][ny1][nx2][ny2]) {\n                    d[nx1][ny1][nx2][ny2] = false;\n                    que1.push(P(nx1, ny1));\n                    que2.push(P(nx2, ny2));\n                }\n            }\n        }\n\n        cout << (res ? \"Yes\" : \"No\") << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_W 10\n#define MAX_H 10\n//深さ優先探索で行けるんじゃないか？\n\nbool C[51][51][51][51];\nint di[4] = {0, -1, 0, 1};\nint dj[4] = {1, 0, -1, 0};\nvector<vector<bool> > Room_L(MAX_H + 2, vector<bool> (MAX_W + 2, false));\nvector<vector<bool> > Room_R(MAX_H + 2, vector<bool> (MAX_W + 2, false));\nint si_L, si_R, sj_L, sj_R, gi_L, gi_R, gj_L, gj_R;  //スタートとゴールの座標\n\n\nint main(){\n\n    \n    //cout << \"ok\" << endl;\n    while(1){\n        \n        //入力\n        //cout << \"ol\" << endl;\n        int W, H; cin >> W >> H;\n        if(W == 0) break;\n        \n        for(int i = 0; i <= H + 1; i++){\n            for(int j = 0; j <= W + 1; j++){\n                Room_L[i][j] = Room_R[i][j] = false;\n            }\n        }\n\n        memset(C, 0, sizeof(C));\n\n        for(int i = 1; i <= H; i++){\n            //L\n            for(int j = 1; j <= W; j++){\n                char input; cin >> input;\n                if(input == '#') continue;\n                else{\n                    Room_L[i][j] = true;\n\n                    if(input == '%'){\n                        gi_L = i;\n                        gj_L = j;\n                    }\n\n                    if(input == 'L'){\n                        si_L = i;\n                        sj_L = j;\n                    }\n                }\n            }\n\n            //R\n            for(int j = 1; j <= W; j++){\n                char input; cin >> input;\n                if(input == '#') continue;\n                else{\n                    Room_R[i][j] = true;\n\n                    if(input == '%'){\n                        gi_R = i;\n                        gj_R = j;\n                    }\n\n                    if(input == 'R'){\n                        si_R = i;\n                        sj_R = j;\n                    }\n                }\n            }\n        }\n\n        \n\n\n        //幅優先をする\n        //set<pair<pair<int, int>, pair<int, int> > > s;\n        \n        queue<pair<pair<int, int>, pair<int, int> > > wait;                      //左の座標　右の座標\n        wait.push({ {si_L, sj_L}, {si_R, sj_R} });\n        //s.insert({ {si_L, sj_L}, {si_R, sj_R} });\n        C[si_L][sj_L][si_R][sj_R] = true;\n        \n        bool can = false;\n\n        while(!wait.empty()){    //キュー画空になるまで\n\n\n            //キューの先頭要素を取り出す\n            int nowi_L = wait.front().first.first;\n            int nowj_L = wait.front().first.second;\n            int nowi_R = wait.front().second.first;\n            int nowj_R = wait.front().second.second;\n            //cout << nowi_L << \" \" << nowj_L << \"  \" << nowi_R << \" \" << nowj_R << endl;\n            wait.pop();\n\n            //四方向を探索\n            for(int k = 0; k < 4; k++){\n                int nexti_L = nowi_L + di[k];\n                int nextj_L = nowj_L + dj[k];\n                int nexti_R = nowi_R + di[k];\n                int nextj_R = nowj_R - dj[k];\n                //cout << \" \" << nexti_L << \" \" << nextj_L << \"  \" << nexti_R << \" \" << nextj_R << endl;\n\n\n                bool L = Room_L[nexti_L][nextj_L];\n                bool R = Room_R[nexti_R][nextj_R];\n                //cout << \" \" << L << \" \" << R << endl;\n                \n\n                //その方向に進めるなら\n                if(nexti_L == gi_L && nextj_L == gj_L && nexti_R == gi_R && nextj_R == gj_R){\n                    can = true;\n                    break;\n                }else if((nexti_L == gi_L && nextj_L == gj_L) || (nexti_R == gi_R && nextj_R == gj_R)){\n                    continue;\n                }else if(R && L && !C[nexti_L][nextj_L][nexti_R][nextj_R]){\n                    wait.push({{nexti_L, nextj_L}, {nexti_R, nextj_R}});\n                    C[nexti_L][nextj_L][nexti_R][nextj_R] = true;\n                }else if(R && !L &&  !C[nowi_L][nowj_L][nexti_R][nextj_R]){\n                    wait.push({{nowi_L, nowj_L}, {nexti_R, nextj_R}});\n                    C[nowi_L][nowj_L][nexti_R][nextj_R] = true;\n                }else if(!R && L && !C[nexti_L][nextj_L][nowi_R][nowj_R]){\n                    wait.push({{nexti_L, nextj_L}, {nowi_R, nowj_R}});\n                    C[nexti_L][nextj_L][nowi_R][nowj_R] = true;\n                }\n            }\n        }\n\n        if(can) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    \n    \n    }\n\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define p(S) cout<<(S)<<endl\n#define F first\n#define S second\n#define ck(a,b) (0<=(a)&&(a)<b)\nusing namespace std;\n\nint mcrdx[]={1,0,-1,0};\nint mcldx[]={-1,0,1,0};\nint mcdy[]={0,1,0,-1};\nchar fL[51][51],fR[51][51];\nint mcH,mcW;\nbool mcok[51][51][51][51];\nstring mcdfs(pair<int,int> sr,pair<int,int> sl){\n\tstack<pair<pair<int,int>,pair<int,int>>> st;\n\tst.push({sr,sl});\n\twhile(!st.empty()){\n\t\tpair<int,int> r=st.top().F,l=st.top().S;\n\t\tst.pop();\n\t\tif(fR[r.S][r.F]=='%'&&fL[l.S][l.F]=='%') {\n\t\t\treturn \"Yes\";\n\t\t}else if(fR[r.S][r.F]=='%'||fL[l.S][l.F]=='%'){\n\t\t\tcontinue;\n\t\t}\n\t\tREP(i,0,4){\n\t\t\tpair<int,int> nr={r.F+mcrdx[i],r.S+mcdy[i]},nl={l.F+mcldx[i],l.S+mcdy[i]};\n\t\t\tif(!ck(nr.F,mcW)||!ck(nr.S,mcH)) nr=r;\n\t\t\telse if(fR[nr.S][nr.F]=='#')\tnr=r;\n\t\t\tif(!ck(nl.F,mcW)||!ck(nl.S,mcH)) nl=l;\n\t\t\telse if(fL[nl.S][nl.F]=='#')\tnl=l;\n\n\t\t\t//\tcout<<nr.F<<\" \"<<nr.S<<\" \"<<nl.F<<\" \"<<nl.S<<\" \"<<endl;\n\t\t\tif(!mcok[nr.F][nr.S][nl.F][nl.S]){\n\t\t\t\tmcok[nr.F][nr.S][nl.F][nl.S]=true;\n\t\t\t\tst.push({nr,nl});\n\t\t\t}\n\t\t}\n\t}\n\treturn \"No\";\n}\nint main(){\n\n\twhile(cin>>mcW>>mcH,mcW){\n\t\tpair<int,int> Rin,Len;\n\t\tmemset(mcok,false,sizeof(mcok));\n\t\tREP(i,0,mcH) {\n\t\t\tREP(j,0,mcW){\n\t\t\t\tcin>>fL[i][j];\n\t\t\t\tif(fL[i][j]=='L')\tLen={j,i};\n\t\t\t}\n\t\t\tREP(j,0,mcW){\n\t\t\t\tcin>>fR[i][j];\n\t\t\t\tif(fR[i][j]=='R')\tRin={j,i};\n\t\t\t}\n\t\t}\n\n\t\tp(mcdfs(Rin,Len));\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define mem(a) memset(a,0,sizeof(a))\n#define pb(a) push_back(a)\n#define in(a) insert(a)\n#define R cin>>\n#define F first\n#define S second\n#define Y typename\n#define ll long long\n#define GM(_1,_2,_3,N,...)N\n#define pr(...) GM(__VA_ARGS__,pr3,pr2,pr1)(__VA_ARGS__)\ntemplate<Y T>void pr1(T a){cout<<a<<'\\n';}\ntemplate<Y T,Y T2>void pr2(T a,T2 b){cout<<a<<' '<<b<<'\\n';}\ntemplate<Y T,Y T2,Y T3>void pr3(T a,T2 b,T3 c){cout<<a<<' '<<b<<' '<<c<<'\\n';}\ntemplate<Y T>void PR(T a,int n){rep(i,n){if(i)cout<<' ';cout<<a[i];}cout<<'\\n';}\nbool check(int n,int m,int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint d[51][51][51][51];\n\nvoid Main() {\n  int n,m;\n  while(cin >> m >> n && n) {\n    string s[n],t[n];\n    rep(i,n) cin >> s[i] >> t[i];\n    int sx1,sy1,sx2,sy2;\n    rep(i,n) {\n      rep(j,m) {\n\tif(s[i][j]=='L') sx1=i,sy1=j;\n\tif(t[i][j]=='R') sx2=i,sy2=j;\n      }\n    }\n    mem(d);\n    queue<P2> que;\n    que.push(P2(P(sx1,sy1),P(sx2,sy2)));\n    d[sx1][sy1][sx2][sy2]=1;\n    bool ck=0;\n    while(!que.empty()) {\n      P2 p=que.front();que.pop();\n      int nx1=p.F.F,ny1=p.F.S,nx2=p.S.F,ny2=p.S.S;\n      if(s[nx1][ny1]=='%' && t[nx2][ny2]=='%') {ck=1;break;}\n      if(s[nx1][ny1]=='%' || t[nx2][ny2]=='%') continue;\n      rep(i,4) {\n\tint x1=nx1+dx[i],y1=ny1+dy[i],x2=nx2+dx[i],y2=ny2+dy[i];\n\tif(i%2) {x2+=dx[(i+2)%4]*2;y2+=dy[(i+2)%4]*2;}\n\tif(!check(n,m,x1,y1) || s[x1][y1]=='#') x1=nx1,y1=ny1;\n\tif(!check(n,m,x2,y2) || t[x2][y2]=='#') x2=nx2,y2=ny2;\n\tif(d[x1][y1][x2][y2]) continue;\n\td[x1][y1][x2][y2]=1;\n\tque.push(P2(P(x1,y1),P(x2,y2)));\n      }\n    }\n    if(ck) pr(\"Yes\");\n    else pr(\"No\");\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(0);cin.tie(0);Main();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": " #include<bits/stdc++.h>\n using namespace std;\n#define INF 1000000000\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\ntypedef long long LL;\nint H,W;\nint A[100][100];\nint B[100][100];\nint sax,say,tax,tay;\nint sbx,sby,tbx,tby;\nbool used[61][61][61][61];\ntypedef pair<int,int>P;\ntypedef pair<P,P>PP;\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\n\nP move(P now,int x,int y){\n  if(now.first+x<0){\n     return now;\n  }\n  if(now.first+x>=W){\n     return now;\n  }\n  if(now.second+y<0){\n     return now;\n  }\n  if(now.second+y>=H){\n     return now;\n  }\n  if(A[now.first+x][now.second]!=1){\n     now.first+=x;\n  }\n  if(A[now.first][now.second+y]!=1){\n     now.second+=y;\n  }\n  return now;\n}\n\nP move2(P now,int x,int y){\n  if(now.first+x<0){\n     return now;\n  }\n  if(now.first+x>=W){\n     return now;\n  }\n  if(now.second+y<0){\n     return now;\n  }\n  if(now.second+y>=H){\n     return now;\n  }\n  if(B[now.first+x][now.second]!=1){\n     now.first+=x;\n  }\n  if(B[now.first][now.second+y]!=1){\n     now.second+=y;\n  }\n  return now;\n}\n\n\nint main(){\n    int c=0;\n    while(cin>>W>>H,W){\n       //c++;\n       //if(c>=2)break;\n       //vector<int>\n       REP(i,H){\n           string s;\n           cin>>s;\n           REP(j,W){\n              if(s[j]=='L'){\n                 sax=j;\n                 say=i;\n              }\n              if(s[j]=='%'){\n                 tax=j;\n                 tay=i;\n              }\n              A[j][i]=0;\n              if(s[j]=='#'){\n                 A[j][i]=1;\n              }\n           }\n           cin>>s;\n           REP(j,W){\n              if(s[j]=='R'){\n                 sbx=j;\n                 sby=i;\n              }\n              if(s[j]=='%'){\n                 tbx=j;\n                 tby=i;\n              }\n              B[j][i]=0;\n              if(s[j]=='#'){\n                 B[j][i]=1;\n              }\n           }\n       }\n       //cout<<\"input_ok\"<<endl;\n       //cout<<tax<<\" \"<<tay<<\" \"<<tbx<<\" \"<<tby<<endl;\n       //????????????bfs\n       REP(i,60){\n           REP(j,60){\n               REP(k,60){\n                   REP(l,60){\n                       used[i][j][k][l]=false;\n                   }\n               }\n           }\n       }\n\n       used[sax][say][sbx][sby]=true;\n       vector<PP>v;\n       v.push_back(PP(P(sax,say),P(sbx,sby)));\n       int now=0;\n       while(now<v.size()){\n          //cout<<\"now\"<<now;\n          P l=v[now].first;\n          P r=v[now].second;\n          used[l.first][l.second][r.first][r.second]=true;\n          //cout<<l.first<<\" \"<<l.second<<\" \"<<r.first<<\" \"<<r.second<<endl;\n          REP(i,4){\n              P ll=move(l,dx[i],dy[i]);\n              P rr=move2(r,-dx[i],dy[i]);\n              if(used[ll.first][ll.second][rr.first][rr.second]==false){\n                    used[ll.first][ll.second][rr.first][rr.second]=true;\n              /*if(now>=50*50*50*50){\n              cout<<c<<\"ok\"<<ll.first<<\" \"<<ll.second<<\" \"<<rr.first<<\" \"<<rr.second<<endl;\n              }*/\n                 if((ll.first==tax)&&(ll.second==tay)){\n                    used[ll.first][ll.second][rr.first][rr.second]=true;\n                    continue;\n                 }\n                 if((rr.first==tbx)&&(rr.second==tby)){\n                    used[ll.first][ll.second][rr.first][rr.second]=true;\n                    continue;\n                 }\n                   v.push_back(PP(ll,rr));\n              }\n          }\n          now++;\n       }\n       \n       //cout<<endl;\n       if(used[tax][tay][tbx][tby]==true){\n          cout<<\"Yes\"<<endl;\n       }else{\n          cout<<\"No\"<<endl;\n       }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Header {{{\n// includes {{{\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <unistd.h>\n#include <vector>\n// }}}\nusing namespace std;\n// consts {{{\nstatic const int INF = 1e9;\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n// }}}\n// typedefs {{{\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<ULL> VULL;\ntypedef vector<VULL> VVULL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\n// typedef complex<char> P;\ntypedef PII P;\n#define PQ(type) priority_queue<type>\n// priority queue reverse\n#define PQR(type) priority_queue< type, vector<type>, greater<type> >\n// }}}\n// macros & inline functions {{{\n// syntax sugars {{{\n#define FOR(i, b, e) for (typeof(e) i = (b); i < (e); ++i)\n#define FORI(i, b, e) for (typeof(e) i = (b); i <= (e); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(i, n) FORI(i, 0, n)\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n#define ASSIGN_MAX(var, val) ((var) = max((var), (val)))\n#define ASSIGN_MIN(var, val) ((var) = min((var), (val)))\n// }}}\n// conversion {{{\ninline int toInt(string s) { int v; istringstream sin(s); sin>>v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout<<x; return sout.str(); }\n// }}}\n// array and STL {{{\n#define ARRSIZE(a) ( sizeof(a) / sizeof(a[0]) )\n#define ZERO(a, v) ( assert(v == 0 || v == -1), memset(a, v, sizeof(a)) )\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define SIZE(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c, it) for(typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define REACH(c, it) for(typeof((c).rbegin()) it=(c).rbegin(); it!=(c).rend(); ++it)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n// }}}\n// bit manipulation {{{\n// singed integers are not for bitwise operations, specifically arithmetic shifts ('>>', and maybe not good for '<<' too)\n#define IS_UNSIGNED(n) (!numeric_limits<typeof(n)>::is_signed)\n#define BIT(n) (assert(IS_UNSIGNED(n)), assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(IS_UNSIGNED(n)), assert(m < 64), ((ULL)(n) >> (m) & 1))\ninline int BITS_COUNT(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int MSB(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c-1; }\ninline int MAKE_MASK(ULL upper, ULL lower) { assert(lower < 64 && upper < 64 && lower <= upper); return (BIT(upper) - 1) ^ (BIT(lower) - 1); }\n// }}}\n// for readable code {{{\n#define EVEN(n) (n % 2 == 0)\n#define ODD(n) (!EVEN(n))\n// }}}\n// debug {{{\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n#define dprt(fmt, ...) if (opt_debug) { fprintf(stderr, fmt, ##__VA_ARGS__); }\n#define darr(a) if (opt_debug) { copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr_range(a, f, t) if (opt_debug) { copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define dvec(v) if (opt_debug) { copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr2(a) if (opt_debug) { FOR(__i, 0, (arrsz(a))){ darr( (a)[__i] ); } }\n#define WAIT() if (opt_debug) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#define dump(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl; }\n// dump vector elements in [s, e)\n#define dumpv(v, s, e) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #v << \" = \"; FOR(__i, s, e) { cerr << v[__i] << \"\\t\"; } cerr << endl; }\n#define dumpl(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << endl << (x) << endl; }\n#define dumpf() if (opt_debug) { cerr << __PRETTY_FUNCTION__ << endl; }\n#define where() if (opt_debug) { cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl; }\n#define dumpb(bit, digits) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #bit << \" = \"; for(int __i = digits - 1; __i >= 0; __i--) { cerr << static_cast<bool>(bit & (1 << __i)); if (__i % 4 == 0) { cerr << \" \"; } } cerr << endl; }\n\n// ostreams {{{\n// complex\ntemplate<typename T> ostream& operator<<(ostream& s, const complex<T>& d) {return s << \"(\" << d.real() << \", \" << d.imag() << \")\";}\n\n// pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n// vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i]; if (i < len - 1) s << \"\\t\";\n\t}\n\treturn s;\n}\n\n// 2 dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i] << endl;\n\t}\n\treturn s;\n}\n\n// map\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const map<T1, T2>& m) {\n\ts << \"{\" << endl;\n\tfor (typeof(m.begin()) itr = m.begin(); itr != m.end(); ++itr) {\n\t\ts << \"\\t\" << (*itr).first << \" : \" << (*itr).second << endl;\n\t}\n\ts << \"}\" << endl;\n\treturn s;\n}\n// }}}\n// }}}\n// }}}\n// time {{{\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\n// }}}\n// string manipulation {{{\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\ninline string join(VS s, string j) { string t; REP(i, s.size()) { t += s[i] + j; } return t; }\n// }}}\n// geometry {{{\n#define Y first\n#define X second\n// }}}\n// 2 dimentional array {{{\nenum { UP, RIGHT, DOWN, LEFT, UP_RIGHT, DOWN_RIGHT, DOWN_LEFT, UP_LEFT };\nP dydx4[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\nP dydx8[8] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(-1, 1), P(1, 1), P(1, -1), P(-1, -1) };\nbool in_field(int H, int W, P p) {\n\treturn (0 <= p.Y && p.Y < H) && (0 <= p.X && p.X < W);\n}\n// }}}\n// input and output {{{\ninline void input(string filename) {\n\tfreopen(filename.c_str(), \"r\", stdin);\n}\ninline void output(string filename) {\n\tfreopen(filename.c_str(), \"w\", stdout);\n}\n// }}}\n// }}}\n\nbool opt_debug = false;\n\nint main(int argc, char** argv) {\n\tstd::ios_base::sync_with_stdio(false);\n\t// set options {{{\n\tint __c;\n\twhile ( (__c = getopt(argc, argv, \"d\")) != -1 ) {\n\t\tswitch (__c) {\n\t\t\tcase 'd':\n\t\t\t\topt_debug = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tabort();\n\t\t}\n\t}\n\t// }}}\n\n\t// opt_debug = true;\n\t// input(\"./inputs/0.txt\");\n\t// output(\"./outputs/0.txt\");\n\n\tint W, H;\n\twhile (cin >> W >> H, W | H) {\n\t\tVVC room_l(H, VC(W));\n\t\tVVC room_r(H, VC(W));\n\t\tP len, rin;\n\t\tREP (i, H) {\n\t\t\tREP (j, W) {\n\t\t\t\tcin >> room_l[i][j];\n\t\t\t\tif (room_l[i][j] == 'L') {\n\t\t\t\t\tlen = P(i, j);\n\t\t\t\t\troom_l[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP (j, W) {\n\t\t\t\tcin >> room_r[i][j];\n\t\t\t\tif (room_r[i][j] == 'R') {\n\t\t\t\t\trin = P(i, j);\n\t\t\t\t\troom_r[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttypedef pair<P, P> PPP;\n\t\tqueue<PPP> q;\n\t\tq.push(MP(len, rin));\n\t\tP dydx_l[4] = { MP(-1, 0), MP(0, 1), MP(1, 0), MP(0, -1) };\n\t\tP dydx_r[4] = { MP(-1, 0), MP(0, -1), MP(1, 0), MP(0, 1) };\n\t\ttypedef pair< pair<char, char>, pair<char, char> > PPIIPII;\n\t\tset< PPIIPII > pushed;\n\t\tbool ok = false;\n\t\twhile (!q.empty()) {\n\t\t\tPPP t = q.front(); q.pop();\n\t\t\tPPIIPII key = MP( MP(t.F.Y, t.F.X), MP(t.S.Y, t.S.X) );\n\t\t\tlen = t.F; rin = t.S;\n\t\t\tif (room_l[len.Y][len.X] == '%' && room_r[rin.Y][rin.X] == '%') {\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (room_l[len.Y][len.X] == '%' || room_r[rin.Y][rin.X] == '%') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tREP (d, 4) {\n\t\t\t\tP n_len = MP(len.Y + dydx_l[d].Y, len.X + dydx_l[d].X);\n\t\t\t\tP n_rin = MP(rin.Y + dydx_r[d].Y, rin.X + dydx_r[d].X);\n\t\t\t\tif (!in_field(H, W, n_len) || room_l[n_len.Y][n_len.X] == '#') {\n\t\t\t\t\tn_len = len;\n\t\t\t\t}\n\t\t\t\tif (!in_field(H, W, n_rin) || room_r[n_rin.Y][n_rin.X] == '#') {\n\t\t\t\t\tn_rin = rin;\n\t\t\t\t}\n\n\t\t\t\tPPIIPII _key = MP( n_len, n_rin );\n\t\t\t\tif (!EXIST(pushed, _key)) {\n\t\t\t\t\tq.push(MP(n_len, n_rin));\n\t\t\t\t\tpushed.insert(_key);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ok) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t} else {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr8,pr7,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\n#define prArr(a) {cerr<<(#a)<<\"={\";int i=0;for(auto t:(a))cerr<<(i++?\", \":\"\")<<t;cerr<<\"}\"<<endl;}\nusing namespace std;\nusing Int = long long;\nusing _int = int;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = (1LL<<60)+1e9; // ~ 1.15 * 1e18\nconst Int mod = (1e9)+7;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\nusing P = pair<Int,Int>;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\ntemplate<class T1, class T2> ostream& operator<<(ostream& o,pair<T1,T2> p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\ntemplate<class T1, class T2, class T3> ostream& operator<<(ostream& o,tuple<T1,T2,T3> t){\n  return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class T1, class T2> istream& operator>>(istream& i,pair<T1,T2> &p){return i>>p.first>>p.second;}\ntemplate<class T> ostream& operator<<(ostream& o,vector<T> a){Int i=0;for(T t:a)o<<(i++?\" \":\"\")<<t;return o;}\ntemplate<class T> istream& operator>>(istream& i,vector<T> &a){for(T &t:a)i>>t;return i;}\n//INSERT ABOVE HERE\n\nInt D[51][51][51][51];\nsigned main(){\n  srand((unsigned)time(NULL));\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(1){\n    Int W, H;\n    cin>>W>>H;\n    if(W == 0 && H == 0) break;\n    vector<string> mp1(H), mp2(H);\n    for(Int i=0;i<H;i++) cin>>mp1[i]>>mp2[i];\n\n    Int sy1, sx1, sy2, sx2;\n    for(Int i=0;i<H;i++)\n      for(Int j=0;j<W;j++){\n        if(mp1[i][j] == 'L') tie(sy1, sx1) = P(i, j);\n        if(mp2[i][j] == 'R') tie(sy2, sx2) = P(i, j);\n      }\n\n    for(Int i=0;i<H;i++)\n      for(Int j=0;j<W;j++)\n        for(Int s=0;s<H;s++)\n          for(Int t=0;t<W;t++) D[i][j][s][t] = INF;\n\n    using T = tuple<Int, Int, Int, Int>;\n    queue<T> Q;\n    Q.emplace(sy1, sx1, sy2, sx2);\n    D[sy1][sx1][sy2][sx2] = 0;\n\n    string ans = \"No\";\n    while(!Q.empty()){\n      Int y1, x1, y2, x2;\n      tie(y1, x1, y2, x2) = Q.front(); Q.pop();\n      Int cost = D[y1][x1][y2][x2];\n\n      if(mp1[y1][x1] == '%' && mp2[y2][x2] == '%'){ans = \"Yes\"; break;}\n      if(mp1[y1][x1] == '%' || mp2[y2][x2] == '%') continue;\n      const Int dx[] = {0, 1, 0, -1};\n      const Int dy[] = {-1, 0, 1, 0};\n      for(Int i=0;i<4;i++){\n        Int ny1 = y1 + dy[i];\n        Int nx1 = x1 + dx[i];\n        Int ny2 = y2 + (i%2 == 0? dy[i]:dy[(i+2)%4]);\n        Int nx2 = x2 + (i%2 == 0? dx[i]:dx[(i+2)%4]);\n        Int ncost = cost + 1;\n        if(ny1 < 0 || ny1 >= H || nx1 < 0 || nx1 >= W || mp1[ny1][nx1] == '#') tie(ny1, nx1) = P(y1, x1);\n        if(ny2 < 0 || ny2 >= H || nx2 < 0 || nx2 >= W || mp2[ny2][nx2] == '#') tie(ny2, nx2) = P(y2, x2);\n        if(D[ny1][nx1][ny2][nx2] <= ncost) continue;\n        D[ny1][nx1][ny2][nx2] = ncost;\n        Q.emplace(ny1, nx1, ny2, nx2);\n      }\n    }\n    cout<<ans<<endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <sstream>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cstring>\n \nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nint w,h;\nint sxl,syl,sxr,syr;\nstring L[100],R[100];\n\nconst int dx[]={0,1,0,-1};\nconst int dy[]={-1,0,1,0};\n\nint vis[60][60][60][60];\n\nbool solve(int xl,int yl,int xr, int yr)\n{\n\t//cout<<xl<<\" \"<<yl<<\" \"<<xr<<\" \"<<yr<<endl;\n\t\n\tif(L[yl][xl]=='%' && R[yr][xr]=='%') return true;\n\tif(L[yl][xl]=='%' && R[yr][xr]!='%') return false;\n\tif(L[yl][xl]!='%' && R[yr][xr]=='%') return false;\n\t\n\tif(vis[yl][xl][yr][xr]==1) return false;\n\t\n\tvis[yl][xl][yr][xr]=1;\n\t\n\tfor(int i=0;i<4;i++){\n\t\tint nxl=xl+dx[i], nyl=yl+dy[i];\n\t\tint nxr=xr-dx[i], nyr=yr+dy[i];\n\n\t\tif(nxl<0 || w<=nxl || nyl<0 || h<=nyl ||\n\t\t   nxr<0 || w<=nxr || nyr<0 || h<=nyr ) continue;\n\t\t\n\t\tif(L[nyl][nxl]=='#'){\n\t\t\tnxl-=dx[i]; nyl-=dy[i];\n\t\t}\n\t\tif(R[nyr][nxr]=='#'){\n\t\t\tnxr+=dx[i]; nyr-=dy[i];\n\t\t}\n\t\t\n\n\t\t   \n\t\tif(solve(nxl,nyl,nxr,nyr)) return true;;\n\t\t\n\t}\n\t\n\treturn false;\n\n}\n\nint main()\n{\n\t\n\twhile(cin>>w>>h,w){\t\t\n\n\t\tmemset(vis,-1,sizeof(int)*60*60*60*60);\n\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>L[i]>>R[i];\n\t\t}\n\t\t\n\t\t\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(L[i][j]=='L'){sxl=j,syl=i;}\n\t\t\t\tif(R[i][j]=='R'){sxr=j,syr=i;}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(solve(sxl,syl,sxr,syr)) cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t\t\n\t}\n\t\t\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\nbool used[51][51][51][51];\nstring roomL[51], roomR[51];\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while (true) {\n    int R, C;\n    cin >> C >> R;\n    if (R == 0 && C == 0) break;\n    REP(i, R) cin >> roomL[i] >> roomR[i];\n\n    int slr = 0, slc = 0, elr = 0, elc = 0, srr = 0, src = 0, err = 0, erc = 0;\n    REP(r, R) REP(c, C) {\n      if (roomL[r][c] == 'L') slr = r, slc = c;\n      else if (roomR[r][c] == 'R') srr = r, src = c;\n      else if (roomL[r][c] == '%') elr = r, elc = c;\n      else if (roomR[r][c] == '%') err = r, erc = c;\n    }\n    //cout << slr << ' ' << slc << ' ' << elr << ' ' << elc << ' ' << srr << ' ' << src << ' ' << err << ' ' << erc << endl;\n    REP(i, R) REP(j, C) REP(k, R) REP(l, C) used[i][j][k][l] = false;\n    \n    queue<P> que;\n    que.push(P(slr * C + slc, srr * C + src));\n\n    bool flag = false;\n    while (!que.empty()) {\n      P p = que.front(); que.pop();\n      int lr = p.first / C, lc = p.first % C, rr = p.second / C, rc = p.second % C;\n      //cout << lr << ' ' << lc << ' ' << rr << ' ' << rc << endl;\n      if (lr == elr && lc == elc && rr == err && rc == erc) {\n\tflag = true;\n\tbreak;\n      } else if (used[lr][lc][rr][rc] || (lr == elr && lc == elc) || (rr == err && rc == erc)) {\n\tcontinue;\n      }\n\n      used[lr][lc][rr][rc] = true;\n      REP(i, 4) {\n\tint nlr = lr + dr[i], nlc = lc + dc[i], nrr = rr + dr[(i+2*(i&1))%4], nrc = rc + dc[(i+2*(i&1))%4];\n\tif (nlr < 0 || nlr >= R || nlc < 0 || nlc >= C || roomL[nlr][nlc] == '#') nlr = lr, nlc = lc;\n\tif (nrr < 0 || nrr >= R || nrc < 0 || nrc >= C || roomR[nrr][nrc] == '#') nrr = rr, nrc = rc;\n\tif (!used[nlr][nlc][nrr][nrc]) que.push(P(nlr * C + nlc, nrr * C + nrc));\n      }\n    }\n    cout << (flag ? \"Yes\" : \"No\") << endl;    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = {-1,0,1,0}; const int dy[] = {0,1,0,-1};\n\nconst int MAX_W = 52;\nconst int MAX_H = 52;\n\nchar fieldL[MAX_H][MAX_W];\nchar fieldR[MAX_H][MAX_W];\nbool G[52][52][52][52];\n\nint main() {\n\tint w, h;\n\twhile(cin >> w >> h, w|h){\n\t\tfill_n((char *)fieldL, MAX_W * MAX_H, '#');\n\t\tfill_n((char *)fieldR, MAX_W * MAX_H, '#');\n\t\tfill_n((bool *)G, MAX_W * MAX_H * MAX_W * MAX_H, false);\n\n\t\tpii ls, rs, lg, rg;\n\t\tREP(y, h){\n\t\t\tchar c;\n\t\t\tREP(x, w){\n\t\t\t\tcin >> c;\n\t\t\t\tswitch(c){\n\t\t\t\tcase '%':\n\t\t\t\t\tc = '.';\n\t\t\t\t\tlg.first = x + 1;\n\t\t\t\t\tlg.second = y + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\tc = '.';\n\t\t\t\t\tls.first = x + 1;\n\t\t\t\t\tls.second = y + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfieldL[y + 1][x + 1] = c;\n\t\t\t}\n\t\t\tREP(x, w){\n\t\t\t\tcin >> c;\n\t\t\t\tswitch(c){\n\t\t\t\tcase '%':\n\t\t\t\t\tc = '.';\n\t\t\t\t\trg.first = x + 1;\n\t\t\t\t\trg.second = y + 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tc = '.';\n\t\t\t\t\trs.first = x + 1;\n\t\t\t\t\trs.second = y + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfieldR[y + 1][x + 1] = c;\n\t\t\t}\n\t\t}\n\n\n//\t\tLOG(\"%d %d ,, %d %d\\n\", ls.first, ls.second , rs.first, rs.second);\n\n\t\tqueue<pair<pii, pii>> que;\n\t\tque.push({ls, rs});\n\t\tbool res = false;\n\t\twhile(!que.empty()){\n\t\t\tpii L = que.front().first;\n\t\t\tpii R = que.front().second;\n\t\t\tque.pop();\n\n\t\t\t/*\n\t\t\tLOG(\"%d %d |||| %d %d\\n\", L.first, L.second , R.first, R.second);\n\t\t\tREP(y, h + 2){\n\t\t\t\tREP(x, w + 2){\n\t\t\t\t\tif(L.first == x && L.second == y)\n\t\t\t\t\t\tLOG(\"L\");\n\t\t\t\t\telse\n\t\t\t\t\t\tLOG(\"%c\", fieldL[y][x]);\n\n\t\t\t\t}\n\t\t\t\tLOG(\" \");\n\n\t\t\t\tREP(x, w + 2){\n\t\t\t\t\tif(R.first == x && R.second == y)\n\t\t\t\t\t\tLOG(\"R\");\n\t\t\t\t\telse\n\t\t\t\t\t\tLOG(\"%c\", fieldR[y][x]);\n\t\t\t\t}\n\t\t\t\tLOG(\"\\n\");\n\t\t\t}\n\t\t\tLOG(\"------\\n\");\n\t\t\t*/\n\n\t\t\tif(L == lg){\n\t\t\t\tif(R == rg){\n\t\t\t\t\tres = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}else if(R == rg) continue;\n\n\t\t\tREP(i, 4){\n\t\t\t\tpii nextL = {L.first + dx[i], L.second + dy[i]};\n\t\t\t\tpii nextR = {R.first - dx[i], R.second + dy[i]};\n\t\t\t\tif(fieldL[nextL.second][nextL.first] == '#'){\n\t\t\t\t\tnextL = L;\n\t\t\t\t}\n\t\t\t\tif(fieldR[nextR.second][nextR.first] == '#'){\n\t\t\t\t\tnextR = R;\n\t\t\t\t}\n\n\t\t\t\t//\t\t\t\tLOG(\"%c %c   %d %d  <<<--- %d %d\\n\", fieldL[nextL.second][nextL.first],fieldR[nextR.second][nextR.first], nextR.first, nextR.second, R.first, R.second);\n\t\t\t\tif(!G[nextL.first][nextL.second][nextR.first][nextR.second]){\n\t\t\t\t\tG[nextL.first][nextL.second][nextR.first][nextR.second] = true;\n\t\t\t\t\tque.push({nextL, nextR});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << (res ? \"Yes\" : \"No\") << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\nusing namespace std;\n\nstruct state{ int lx,ly,rx,ry; };\n\nint dx[] = {0,1,0,-1},dy[] = {1,0,-1,0};\n\nint main(){\n\tint h,w;\n\twhile(cin >> w >> h,h){\n\t\tint lx,ly,rx,ry;\n\t\tbool dp[50][50][50][50] = {},flag = false;\n\t\tstring lf[50],rf[50];\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tcin >> lf[i] >> rf[i];\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(lf[i][j] == 'L'){\n\t\t\t\t\tlx = i;\n\t\t\t\t\tly = j;\n\t\t\t\t}\n\t\t\t\tif(rf[i][j] == 'R'){\n\t\t\t\t\trx = i;\n\t\t\t\t\try = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<state> que;\n\t\tque.push({lx,ly,rx,ry});\n\t\twhile(!que.empty()){\n\t\t\tstate s = que.front();que.pop();\n\t\t\tif(dp[s.lx][s.ly][s.rx][s.ry]) continue;\n\t\t\t//cout << s.lx << \" \" << s.ly << \" \" << s.rx << \" \" << s.ry << endl;\n\t\t\tif(lf[s.lx][s.ly] == '%' && rf[s.rx][s.ry] == '%') flag = true;\n\t\t\tdp[s.lx][s.ly][s.rx][s.ry] = true;\n\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\tint nlx = s.lx + dx[i],nly = s.ly + dy[i],nrx = s.rx + dx[i],nry = s.ry + dy[(i + 2) % 4];\n\t\t\t\tbool move = false;\n\t\t\t\tif(nlx >= 0 && nlx < h && nly >= 0 && nly < w && lf[nlx][nly] != '#') move = true;\n\t\t\t\telse{\n\t\t\t\t\tnlx = s.lx;\n\t\t\t\t\tnly = s.ly;\n\t\t\t\t}\n\t\t\t\tif(nrx >= 0 && nrx < h && nry >= 0 && nry < w && rf[nrx][nry] != '#') move = true;\n\t\t\t\telse{\n\t\t\t\t\tnrx = s.rx;\n\t\t\t\t\tnry = s.ry;\n\t\t\t\t}\n\t\t\t\tif(move && !dp[nlx][nly][nrx][nry]){\n\t\t\t\t\tque.push({nlx,nly,nrx,nry});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s); sin>>v; return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\n\ntypedef pair<pii,pii> pp;\nint dx[]={-1,0,1,0},dy[]={0,-1,0,1};\nint main(){\n\tint h,w;\n\twhile(cin>>w>>h,h|w){\n\t\tvs lfield(h);\n\t\tvs rfield(h);\n\t\tpii rs,ls,rg,lg;\n\t\tREP(i,h){\n\t\t\tcin>>lfield[i];\n\t\t\tcin>>rfield[i];\n\t\t\tREP(j,w){\n\t\t\t\tswitch(lfield[i][j]){\n\t\t\t\tcase 'L':\n\t\t\t\t\tls=make_pair(i,j);break;\n\t\t\t\tcase '%':\n\t\t\t\t\tlg=make_pair(i,j);break;\n\t\t\t\t}\n\t\t\t\tswitch(rfield[i][j]){\n\t\t\t\tcase 'R':\n\t\t\t\t\trs=make_pair(i,j);break;\n\t\t\t\tcase '%':\n\t\t\t\t\trg=make_pair(i,j);break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstatic int visited[50][50][50][50]={};\n\t\tREP(i,50)REP(j,50)REP(k,50)REP(l,50){\n\t\t\tvisited[i][j][k][l]=0;\n\t\t}\n\t\tvisited[ls.first][ls.second][rs.first][rs.second]=1;\n\t\tqueue<pp> q;\n\t\tq.push(make_pair(ls,rs));\n\t\twhile(!q.empty()){\n\t\t\tpp p=q.front();q.pop();\n\t\t\tpii lp=p.first;\n\t\t\tpii rp=p.second;\n\t\t\tREP(d,4){\n\t\t\t\tint ly=lp.first+dy[d];\n\t\t\t\tint lx=lp.second+dx[d];\n\t\t\t\tint ry=rp.first+dy[d];\n\t\t\t\tint rx=rp.second+dx[(d+2)%4];\n\t\t\t\tif(ly<0||lx<0||ly>=h||lx>=w||lfield[ly][lx]=='#'){\n\t\t\t\t\tly=lp.first;\n\t\t\t\t\tlx=lp.second;\n\t\t\t\t}\n\t\t\t\tif(ry<0||rx<0||ry>=h||rx>=w||rfield[ry][rx]=='#'){\n\t\t\t\t\try=rp.first;\n\t\t\t\t\trx=rp.second;\n\t\t\t\t}\n\t\t\t\tif(!visited[ly][lx][ry][rx]){\n\t\t\t\t\tvisited[ly][lx][ry][rx]=1;\n\t\t\t\t\tq.push(make_pair(make_pair(ly,lx),make_pair(ry,rx)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<(visited[lg.first][lg.second][rg.first][rg.second]?\"Yes\":\"No\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _overload3(_1, _2, _3, name, ...) name\n#define _rep(i, n) repi(i, 0, n)\n#define repi(i, a, b) for (int i = (a); i < (b); ++i)\n#define rep(...) _overload3(__VA_ARGS__, repi, _rep, )(__VA_ARGS__)\n#define ALL(x) x.begin(), x.end()\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\nrandom_device rnd;\nmt19937 mt(rnd());\nusing ll = long long;\nusing lld = long double;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<ll>;\nusing VVL = vector<VL>;\nusing PII = pair<int, int>;\nconst int IINF = 1 << 30;\nconst ll INF = 1ll << 60;\nconst ll MOD = 1000000007;\n\nvector<vector<bool>> visited;\nvector<string> gl, gr;\nint w, h;\n\nbool is_valid(int y, int x)\n{\n\n    return 0 <= y && y < h && 0 <= x && x < w;\n}\n\nint depth = 0;\n\nbool bfs(int ly, int lx, int ry, int rx)\n{\n\n    int dx[4] = {0, 0, 1, -1};\n    int dy[4] = {1, -1, 0, 0};\n\n    deque<pair<pair<int, int>, pair<int, int>>> que;\n    que.push_back({{ly, lx}, {ry, rx}});\n    visited[ly * 50 + lx][ry * 50 + rx] = true;\n    while (!que.empty())\n    {\n        //cerr << que.size() << endl;\n        ly = que.front().first.first;\n        lx = que.front().first.second;\n        ry = que.front().second.first;\n        rx = que.front().second.second;\n        que.pop_front();\n\n        if (gl[ly][lx] == '%' && gr[ry][rx] == '%')\n        {\n            return true;\n        }\n\n        if (gl[ly][lx] == '%' || gr[ry][rx] == '%')\n        {\n            continue;\n        }\n\n        rep(i, 4)\n        {\n            int nry = ry + dy[i];\n            int nrx = rx + dx[i];\n\n            if (is_valid(nry, nrx) == false || gr[nry][nrx] == '#')\n            {\n                nry = ry;\n                nrx = rx;\n            }\n\n            int nly = ly + dy[i];\n            int nlx = lx - dx[i];\n\n            if (is_valid(nly, nlx) == false || gl[nly][nlx] == '#')\n            {\n                nly = ly;\n                nlx = lx;\n            }\n\n            if (visited[nly * 50 + nlx][nry * 50 + nrx])\n                continue;\n            visited[nly * 50 + nlx][nry * 50 + nrx] = true;\n            //cerr << depth << endl;\n            que.push_back({{nly, nlx}, {nry, nrx}});\n        }\n    }\n\n    return false;\n}\n\nvoid solve()\n{\n    visited = vector<vector<bool>>(2500, vector<bool>(2500, false));\n    gl = vector<string>(h);\n    gr = vector<string>(h);\n\n    rep(i, h)\n    {\n        cin >> gl[i] >> gr[i];\n    }\n    int rx, ry, lx, ly;\n\n    rep(i, h) rep(j, w)\n    {\n        if (gl[i][j] == 'L')\n        {\n            ly = i;\n            lx = j;\n            gl[i][j] = '.';\n        }\n    }\n    rep(i, h) rep(j, w)\n    {\n        if (gr[i][j] == 'R')\n        {\n            ry = i;\n            rx = j;\n            gr[i][j] = '.';\n        }\n    }\n    if (bfs(ly, lx, ry, rx))\n    {\n\n        cout << \"Yes\" << endl;\n    }\n    else\n    {\n        cout << \"No\" << endl;\n    }\n}\n\nint main()\n{\n    while (cin >> w >> h, w)\n    {\n        solve();\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define WRAP(x,y,w,h) (0<=x && x<w && 0<=y && y<h)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h, w) {\n\t\tvector<string> cell1(h);\n\t\tvector<string> cell2(h);\n\t\tint slx, sly, srx, sry;\n\t\tint glx, gly, grx, gry;\n\t\tREP(i, h) {\n\t\t\tcin >> cell1[i] >> cell2[i];\n\t\t\tREP(j, w / 2)\n\t\t\t\tswap(cell2[i][j], cell2[i][w - 1 - j]);\n\t\t\tREP(j, w) {\n\t\t\t\tif (cell1[i][j] == 'L') {\n\t\t\t\t\tsly = i;\n\t\t\t\t\tslx = j;\n\t\t\t\t}\n\t\t\t\tif (cell1[i][j] == '%') {\n\t\t\t\t\tgly = i;\n\t\t\t\t\tglx = j;\n\t\t\t\t}\n\t\t\t\tif (cell2[i][j] == 'R') {\n\t\t\t\t\tsry = i;\n\t\t\t\t\tsrx = j;\n\t\t\t\t}\n\t\t\t\tif (cell2[i][j] == '%') {\n\t\t\t\t\tgry = i;\n\t\t\t\t\tgrx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tset<pair<pii, pii>> G;\n\t\tG.insert({ {sly,slx},{sry,srx} });\n\t\tqueue<pair<pii, pii>> Q;\n\t\tQ.push({ { sly,slx },{ sry,srx } });\n\t\tstring clear = \"No\";\n\t\twhile (!Q.empty()) {\n\t\t\tpair<pii, pii> q = Q.front();Q.pop();\n\t\t\tif (q.first.first == gly&&\n\t\t\t\tq.first.second == glx&&\n\t\t\t\tq.second.first == gry&&\n\t\t\t\tq.second.second == grx) {\n\t\t\t\tclear = \"Yes\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tREP(i, 4) {\n\t\t\t\tint nly = q.first.first + dy[i];\n\t\t\t\tint nlx = q.first.second + dx[i];\n\t\t\t\tint nry = q.second.first + dy[i];\n\t\t\t\tint nrx = q.second.second + dx[i];\n\t\t\t\tif (!WRAP(nlx, nly, w, h) || cell1[nly][nlx] == '#') {\n\t\t\t\t\tnly = q.first.first;\n\t\t\t\t\tnlx = q.first.second;\n\t\t\t\t}\n\t\t\t\tif (!WRAP(nrx, nry, w, h) || cell2[nry][nrx] == '#') {\n\t\t\t\t\tnry = q.second.first;\n\t\t\t\t\tnrx = q.second.second;\n\t\t\t\t}\n\t\t\t\tif (G.find({ {nly,nlx},{nry,nrx} }) == G.end()) {\n\t\t\t\t\tG.insert({ { nly,nlx }, { nry,nrx } });\n\t\t\t\t\tQ.push({ { nly,nlx },{ nry,nrx } });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << clear << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_W 50\n#define MAX_H 50\n//深さ優先探索で行けるんじゃないか？\n\n\nint di[4] = {0, -1, 0, 1};\nint dj[4] = {1, 0, -1, 0};\nvector<vector<bool> > Room_L(MAX_H + 2, vector<bool> (MAX_W + 2, false));\nvector<vector<bool> > Room_R(MAX_H + 2, vector<bool> (MAX_W + 2, false));\nint si_L, si_R, sj_L, sj_R, gi_L, gi_R, gj_L, gj_R;  //スタートとゴールの座標\n\n\nint main(){\n\n    //cout << \"ok\" << endl;\n    while(1){\n\n        //入力\n        //cout << \"ol\" << endl;\n        int W, H; cin >> W >> H;\n        if(W == 0) break;\n\n        for(int i = 0; i <= H + 1; i++){\n            for(int j = 0; j <= W + 1; j++){\n                Room_L[i][j] = Room_R[i][j] = false;\n            }\n        }\n\n        for(int i = 1; i <= H; i++){\n            //L\n            for(int j = 1; j <= W; j++){\n                char input; cin >> input;\n                if(input == '#') continue;\n                else{\n                    Room_L[i][j] = true;\n\n                    if(input == '%'){\n                        gi_L = i;\n                        gj_L = j;\n                    }\n\n                    if(input == 'L'){\n                        si_L = i;\n                        sj_L = j;\n                    }\n                }\n            }\n\n            //R\n            for(int j = 1; j <= W; j++){\n                char input; cin >> input;\n                if(input == '#') continue;\n                else{\n                    Room_R[i][j] = true;\n\n                    if(input == '%'){\n                        gi_R = i;\n                        gj_R = j;\n                    }\n\n                    if(input == 'R'){\n                        si_R = i;\n                        sj_R = j;\n                    }\n                }\n            }\n        }\n\n\n        //幅優先をする\n        //set<pair<pair<int, int>, pair<int, int> > > s;\n        bool C[51][51][51][51] = {};\n        queue<pair<pair<int, int>, pair<int, int> > > wait;                      //左の座標　右の座標\n        wait.push({ {si_L, sj_L}, {si_R, sj_R} });\n        //s.insert({ {si_L, sj_L}, {si_R, sj_R} });\n        C[si_L][sj_L][si_R][sj_R] = true;\n        \n        bool can = false;\n\n        while(!wait.empty()){    //キュー画空になるまで\n\n\n            //キューの先頭要素を取り出す\n            int nowi_L = wait.front().first.first;\n            int nowj_L = wait.front().first.second;\n            int nowi_R = wait.front().second.first;\n            int nowj_R = wait.front().second.second;\n            //cout << nowi_L << \" \" << nowj_L << \"  \" << nowi_R << \" \" << nowj_R << endl;\n            wait.pop();\n\n            //四方向を探索\n            for(int k = 0; k < 4; k++){\n                int nexti_L = nowi_L + di[k];\n                int nextj_L = nowj_L + dj[k];\n                int nexti_R = nowi_R + di[k];\n                int nextj_R = nowj_R - dj[k];\n                //cout << \" \" << nexti_L << \" \" << nextj_L << \"  \" << nexti_R << \" \" << nextj_R << endl;\n\n\n                int L = Room_L[nexti_L][nextj_L];\n                int R = Room_R[nexti_R][nextj_R];\n                //cout << \" \" << L << \" \" << R << endl;\n                \n\n                //その方向に進めるなら\n                if(nexti_L == gi_L && nextj_L == gj_L && nexti_R == gi_R && nextj_R == gj_R){\n                    can = true;\n                    break;\n                }else if((nexti_L == gi_L && nextj_L == gj_L) || (nexti_R == gi_R && nextj_R == gj_R)){\n                    continue;\n                }else if(R && L && !C[nexti_L][nextj_L][nexti_R][nextj_R]){\n                    wait.push({{nexti_L, nextj_L}, {nexti_R, nextj_R}});\n                    C[nexti_L][nextj_L][nexti_R][nextj_R] = true;\n                }else if(R && !L &&  !C[nowi_L][nowj_L][nexti_R][nextj_R]){\n                    wait.push({{nowi_L, nowj_L}, {nexti_R, nextj_R}});\n                    C[nowi_L][nowj_L][nowi_R][nowj_R] = true;\n                }else if(!R && L && !C[nexti_L][nextj_L][nowi_R][nowj_R]){\n                    wait.push({{nexti_L, nextj_L}, {nowi_R, nowj_R}});\n                    C[nexti_L][nextj_L][nowi_R][nowj_R] = true;\n                }\n            }\n        }\n\n        if(can) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\nint main() {\n\tfor (;;) {\n\t\tint W, H; cin >> W >> H;\n\t\tif (W == 0 && H == 0) break;\n\t\tvector< vector<string> > a(2, vector<string>(H + 2, string(W + 2, '#')));\n\t\tfor (int y = 1; y <= H; y++) {\n\t\t\tstring s1, s2; cin >> s1 >> s2;\n\t\t\ta[0][y] = '#' + s1 + '#';\n\t\t\ta[1][y] = '#' + s2 + '#';\n\t\t}\n\t\tvector<char> xs(2), ys(2), xt(2), yt(2);\n\t\tfor (int k = 0; k < 2; k++)\n\t\t\tfor (int y = 1; y <= H; y++)\n\t\t\t\tfor (int x = 1; x <= W; x++){\n\t\t\t\t\tchar& c = a[k][y][x];\n\t\t\t\t\tif (c == 'L' || c == 'R') {\n\t\t\t\t\t\tc = '.';\n\t\t\t\t\t\txs[k] = x; ys[k] = y;\n\t\t\t\t\t}\n\t\t\t\t\telse if (c == '%') {\n\t\t\t\t\t\tc = '.';\n\t\t\t\t\t\txt[k] = x; yt[k] = y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tvector< vector<bool> > vis(3000, vector<bool>(3000));\n\t\tstack< vector<char> > stx, sty;\n\t\tstx.push(xs); sty.push(ys);\n\t\twhile (!stx.empty()) {\n\t\t\tvector<char> x = stx.top(); stx.pop();\n\t\t\tvector<char> y = sty.top(); sty.pop();\n\t\t\tvector<char> z(2);\n\t\t\tfor (int k = 0; k < 2; k++)\n\t\t\t\tz[k] = y[k] * W + x[k];\n\t\t\tvis[z[0]][z[1]] = true;\n\t\t\tif (x[0] == xt[0] && y[0] == yt[0]) continue;\n\t\t\tif (x[1] == xt[1] && y[1] == yt[1]) continue;\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tvector<char> _x = x, _y = y, _z(2);\n\t\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\t\t_x[k] += (k ? dx[i] : -dx[i]);\n\t\t\t\t\t_y[k] += dy[i];\n\t\t\t\t\tif (a[k][_y[k]][_x[k]] == '#') {\n\t\t\t\t\t\t_x[k] = x[k]; _y[k] = y[k];\n\t\t\t\t\t}\n\t\t\t\t\t_z[k] = _y[k] * W + _x[k];\n\t\t\t\t}\n\t\t\t\tif (!vis[_z[0]][_z[1]]) {\n\t\t\t\t\tvis[_z[0]][_z[1]] = true;\n\t\t\t\t\tstx.push(_x);\n\t\t\t\t\tsty.push(_y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<char> zt(2);\n\t\tfor (int k = 0; k < 2; k++)\n\t\t\tzt[k] = yt[k] * W + xt[k];\n\t\tcout << (vis[zt[0]][zt[1]] ? \"Yes\" : \"No\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\ntemplate<typename T>\nvoid O(T t){\n  cout << t << endl;\n}\n\nconst ll mod = 1e9+7;\nconstexpr ll inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\nll w,h;\n\nbool f[51][51][51][51];\n\nbool search(int lx,int ly,int rx,int ry,vector<string> &l,vector<string> &r){\n  if(f[lx][ly][rx][ry]) return false;\n  (f[lx][ly][rx][ry]) = true;\n  bool res = false;\n  /* rep(i,h){                    */\n  /*   rep(j,w){                  */\n  /*     if(i == ly  && j == lx){ */\n  /*       cout << \"*\" ;          */\n  /*     }                        */\n  /*     else                     */\n  /*       std::cout << l[i][j];  */\n  /*   }                          */\n  /*   cout << endl;              */\n  /* }                            */\n  /* rep(i,h){                    */\n  /*   rep(j,w){                  */\n  /*     if(i == ry  && j == rx){ */\n  /*       cout << \"*\" ;          */\n  /*     }                        */\n  /*     else                     */\n  /*       std::cout << r[i][j];  */\n  /*   }                          */\n  /*   cout << endl;              */\n  /* }                            */\n  /* std::cout << std::endl;      */\n  rep(i,4){\n    int nlx = lx + dx[i],nly = ly + dy[i],nrx = rx - dx[i],nry = ry + dy[i];\n    if(value(nlx,nly,w,h) && l[nly][nlx] == '.' && value(nrx,nry,w,h) && r[nry][nrx] == '.'){\n      res |= search(nlx,nly,nrx,nry,l,r);\n    }\n    if(value(nlx,nly,w,h) && l[nly][nlx] == '.' && value(nrx,nry,w,h) && r[nry][nrx] == '#'){\n      res |= search(nlx,nly,rx,ry,l,r);\n    }\n    if(value(nlx,nly,w,h) && l[nly][nlx] == '#' && value(nrx,nry,w,h) && r[nry][nrx] == '.'){\n      res |= search(lx,ly,nrx,nry,l,r);\n    }\n    if(value(nlx,nly,w,h) && l[nly][nlx] == '%' && value(nrx,nry,w,h) && r[nry][nrx] == '%'){\n      return true;\n    }\n  } \n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll lx,ly,rx,ry;\n  while(cin >> w >> h &&  w + h ){\n    vector<string> l(h),r(h);\n    rep(i,h){\n      cin >> l[i] >> r[i];\n      rep(j,w){\n        if(l[i][j] == 'L'){\n          ly = i;\n          lx = j;\n        }\n        if(r[i][j] == 'R'){\n          ry = i;\n          rx = j;\n        }\n      }\n    }\n    bool f = search(lx,ly,rx,ry,l,r);\n    std::cout << (f ? \"Yes\" : \"No\") << std::endl; \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<cmath>\n#include<utility>\n#include<functional>\n#include<map>\n#include<set>\n#include<cctype>\n\n\n#define FOR(i, a, b) for( int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for( int i=(a);i>=(b);i--)\n#define LFOR(i, a, b) for( long long int i=(a);i<=(b);i++)\n#define LRFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LLINF 1000000000000000000 //9000000000000000000\n#define PI 3.14159265358979\n#define MAXI 7500000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\n\nint dy[4] = { 0,0,1,-1 };\nint dx[4] = { 1,-1,0,0 };\n\n//int dp[50][50][50][50] = {};//ly,lx,ry,rx\n\n\nint main(void) {\n\t\n\twhile (1) {\n\n\t\tstruct Pos{\n\t\t\tint leftx;\n\t\t\tint lefty;\n\t\t\tint rightx;\n\t\t\tint righty;\n\t\t};\n\n\t\tint w, h;\n\t\tint lx = -1, ly = -1, rx = -1, ry = -1;\n\t\tint lgx = -1, lgy = -1, rgx = -1, rgy = -1;\n\n\t\tvector< vector< vector< vector<int> > > > dp(50, vector< vector< vector<int > > >(50, vector< vector<int> >(50, vector<int>(50, 0))));\n\t\t\n\n\t\tqueue<Pos> que;\n\t\tPos now;\n\n\t\tcin >> w >> h;\n\n\t\tif (w == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tvector<string> left(h), right(h);\n\n\t\tFOR(i, 0, h-1) {\n\t\t\tcin >> left[i] >> right[i];\n\t\t}\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (left[i][j] == 'L') {\n\t\t\t\t\tlx = j;\n\t\t\t\t\tly = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (right[i][j] == 'R') {\n\t\t\t\t\trx = j;\n\t\t\t\t\try = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (left[i][j] == '%') {\n\t\t\t\t\tlgx = j;\n\t\t\t\t\tlgy = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lgx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (right[i][j] == '%') {\n\t\t\t\t\trgx = j;\n\t\t\t\t\trgy = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rgx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdp[ly][lx][ry][rx] = 1;\n\n\t\tnow.lefty = ly;\n\t\tnow.leftx = lx;\n\t\tnow.righty = ry;\n\t\tnow.rightx = rx;\n\t\t\n\t\tque.push(now);\n\n\n\t\twhile (!que.empty()) {\n\t\t\tnow = que.front();\n\t\t\t\n\t\t\tque.pop();\n\t\t\tly = now.lefty;\n\t\t\tlx = now.leftx;\n\t\t\try = now.righty;\n\t\t\trx = now.rightx;\n\t\t\t//cout << ly << \" \" << lx << \" \" << ry << \" \" << rx << endl;\n\n\t\t\tFOR(i, 0, 3) {\n\t\t\t\t\n\t\t\t\tif (ly + dy[i] >= 0 && lx - dx[i] >= 0 && ry + dy[i] <= h - 1 && rx + dx[i] <= w - 1 && ly + dy[i] <= h - 1 && lx - dx[i] <= w - 1 && ry + dy[i] >= 0 && rx + dx[i] >= 0) {\n\t\t\t\t\tif (dp[ly + dy[i]][lx - dx[i]][ry + dy[i]][rx + dx[i]] != 1) {\n\t\t\t\t\t\tif (left[ly + dy[i]][lx - dx[i]] == '#') {\n\t\t\t\t\t\t\tif (right[ry + dy[i]][rx + dx[i]] == '#') {\n\t\t\t\t\t\t\t\t//no\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdp[ly][lx][ry + dy[i]][rx + dx[i]] = 1;\n\t\t\t\t\t\t\t\tnow.lefty = ly;\n\t\t\t\t\t\t\t\tnow.leftx = lx;\n\t\t\t\t\t\t\t\tnow.righty = ry + dy[i];\n\t\t\t\t\t\t\t\tnow.rightx = rx + dx[i];\n\t\t\t\t\t\t\t\tque.push(now);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (right[ry + dy[i]][rx + dx[i]] == '#') {\n\t\t\t\t\t\t\t\tdp[ly + dy[i]][lx - dx[i]][ry][rx] = 1;\n\t\t\t\t\t\t\t\tnow.lefty = ly + dy[i];\n\t\t\t\t\t\t\t\tnow.leftx = lx - dx[i];\n\t\t\t\t\t\t\t\tnow.righty = ry;\n\t\t\t\t\t\t\t\tnow.rightx = rx;\n\t\t\t\t\t\t\t\tque.push(now);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdp[ly + dy[i]][lx - dx[i]][ry + dy[i]][rx + dx[i]] = 1;\n\t\t\t\t\t\t\t\tnow.lefty = ly + dy[i];\n\t\t\t\t\t\t\t\tnow.leftx = lx - dx[i];\n\t\t\t\t\t\t\t\tnow.righty = ry + dy[i];\n\t\t\t\t\t\t\t\tnow.rightx = rx + dx[i];\n\t\t\t\t\t\t\t\tque.push(now);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (dp[lgy][lgx][rgy][rgx] == 1) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t\t\n\n\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define M 52\n#include<cstring>\nusing namespace std;\nbool flag;\nint dx[]={1,-1,0,0},dy[]={0,0,-1,1},w,h;\nchar r[M][M],l[M][M];\nbool dp[M][M][M][M];\nvoid func(int ly,int lx,int ry,int rx){\n\tif(flag)\n\treturn;\n\t//cout<<ly<<' '<<lx<<' '<<ry<<' '<<rx<<endl;\n\tif(dp[ly][lx][ry][rx]!=0)\n\treturn;\n\tdp[ly][lx][ry][rx]=1;\n\tint nrx,nry,nlx,nly;\n\tfor(int i=0;i<4;i++){\n\t\tnrx=dx[i]+rx;\n\t\tnry=dy[i]+ry;\n\t\tnlx=-dx[i]+lx;\n\t\tnly=dy[i]+ly;\n\t\tif(!(nrx>=0&&nrx<w&&nry>=0&&nry<h)||r[nry][nrx]=='#'){\n\t\t\tnrx=rx;nry=ry;\n\t\t}\n\t\tif(!(nlx>=0&&nlx<w&&nly>=0&&nly<h)||l[nly][nlx]=='#'){\n\t\t\tnlx=lx;nly=ly;\n\t\t}\n\t\tif(l[nly][nlx]=='%'&&r[nry][nrx]=='%'){\n\t\t\tflag=true;\n\t\t\tcontinue;\n\t\t}else if(l[nly][nlx]=='%'||r[nry][nrx]=='%')\n\t\t\t\tcontinue;\n\t\tif(dp[nly][nlx][nry][nrx]==0)\n\t\tfunc(nly,nlx,nry,nrx);\n\t}\n}\nint main(){\n\tint a,b,c,d;\n\twhile(cin>>w>>h,h||w){\n\t\tfor(int i=0;i<h;i++)\n\t\t\tcin>>l[i]>>r[i];\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(l[i][j]=='L'){\n\t\t\t\t\ta=i;b=j;\n\t\t\t\t}\n\t\t\t\tif(r[i][j]=='R'){\n\t\t\t\t\tc=i;d=j;\n\t\t\t\t}\n\t\t}\n\t\tmemset(dp,0,sizeof(dp));\n\t\tflag=false;\n\t\tfunc(a,b,c,d);\n\t\tputs(flag?\"Yes\":\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint lsx, lsy, ltx, lty, rsx, rsy, rtx, rty;\nbool dfs(vector<vector<vvi>> &dp, int lx, int ly, int rx, int ry) {\n\tif (dp[ly][lx][ry][rx] != -1)return dp[ly][lx][ry][rx];\n\treturn true;\n}\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint w, h;\n\twhile (cin >> w >> h, w) {\n\t\tvector<string> l(h), r(h);\n\t\tREP(i, h) cin >> l[i] >> r[i];\n\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tif (l[i][j] == '%') {\n\t\t\t\t\tltx = j; lty = i;\n\t\t\t\t}\n\t\t\t\tif (l[i][j] == 'L') {\n\t\t\t\t\tlsx = j; lsy = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tif (r[i][j] == '%') {\n\t\t\t\t\trtx = j; rty = i;\n\t\t\t\t}\n\t\t\t\tif (r[i][j] == 'R') {\n\t\t\t\t\trsx = j; rsy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<vector<vvi>> dp(h, vector<vvi>(w, vvi(h, vi(w, -1))));\n\t\tqueue<pair<pii, pii>> q;\n\t\tvector<vector<vvi>> b(h, vector<vvi>(w, vvi(h, vi(w, 0))));\n\t\tq.push(pair<pii, pii>(pii(lsx, lsy), pii(rsx, rsy)));\n\t\tb[lsy][lsx][rsy][rsx] = 1;\n\t\twhile (!q.empty()) {\n\t\t\tauto a = q.front(); q.pop();\n\t\t\tint lx = a.first.first, ly = a.first.second, rx = a.second.first, ry = a.second.second;\n\t\t\tif (lx == ltx&&ly == lty) {\n\t\t\t\tif (rx == rtx&&ry == rty) {\n\t\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\t\tgoto a;\n\t\t\t\t}\n\t\t\t\telse continue;\n\t\t\t}\n\t\t\tb[ly][lx][ry][rx] = 1;\n\n\t\t\tREP(i, 4) {\n\t\t\t\tint lnx = lx + dx[i * 2], lny = ly + dy[i * 2], rnx = rx + dx[(i + 2 ) %4*2], rny = ry + dy[i*2];\n\t\t\t\tif (lnx < 0 || lnx >= w || lny < 0 || lny >= h ){ \n\t\t\t\t\tlny = ly; lnx = lx;\n\t\t\t\t}\n\t\t\t\telse if (l[lny][lnx] == '#') {\n\t\t\t\t\tlny = ly; lnx = lx;\n\t\t\t\t}\n\t\t\t\tif (rnx < 0 || rnx >= w || rny < 0 || rny >= h ) {\n\t\t\t\t\trny = ry; rnx = rx;\n\t\t\t\t}\n\t\t\t\telse if (r[rny][rnx] == '#') {\n\t\t\t\t\trny = ry; rnx = rx;\n\t\t\t\t}\n\t\t\t\tif ((lnx!=lx||lny!=ly||rnx!=rx||rny!=ry)&& b[lny][lnx][rny][rnx]!=1) {\n\t\t\t\t\n\t\t\t\t\tq.push(pair<pii, pii>(pii(lnx, lny), pii(rnx, rny)));\n\t\t\t\t\t\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << \"No\" << endl;\n\n\ta:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\ntypedef struct\n{\n  int x, y;\n} Point;\n\nclass State\n{\npublic:\n  Point L, R;\n  State(Point l, Point r)\n    :L(l), R(r) {}\n};\n\nint main()\n{\n  int W, H;\n  while (cin >> W >> H) {\n    if (W == 0 && H == 0)\n      break;\n\n    Point L, R;\n    vector<string> roomL(H), roomR(H);\n    for (int i = 0; i < H; ++i) {\n      cin >> roomL[i];\n      if (roomL[i].find_first_of(\"L\") != string::npos) {\n\tL.x = roomL[i].find_first_of(\"L\");\n\tL.y = i;\n\troomL[L.y][L.x] = '.';\n      }\n      cin >> roomR[i];\n      if (roomR[i].find_first_of(\"R\") != string::npos) {\n\tR.x = roomR[i].find_first_of(\"R\");\n\tR.y = i;\n\troomR[R.y][R.x] = '.';\n      }\n    }\n\n    static bool visited[50][50][50][50];\n    for (int i = 0; i < 50; ++i) {\n      for (int j = 0; j < 50; ++j) {\n\tfor (int k = 0; k < 50; ++k) {\n\t  for (int l = 0; l < 50; ++l)\n\t    visited[i][j][k][l] = false;\n\t}\n      }\n    }\n\n    bool reached = false;\n    queue<State> que;\n    que.push(State(L, R));\n    while (!que.empty()) {\n      const State st = que.front();\n      que.pop();\n\n      if (roomL[st.L.y][st.L.x] == '%' && roomR[st.R.y][st.R.x] == '%') {\n\treached = true;\n\tbreak;\n      }\n\n      if (visited[st.L.y][st.L.x][st.R.y][st.R.x] || roomL[st.L.y][st.L.x] == '%' || roomR[st.R.y][st.R.x] == '%')\n\tcontinue;\n\n      visited[st.L.y][st.L.x][st.R.y][st.R.x] = true;\n      for (int d = 0; d < 4; ++d) {\n\tL.x = st.L.x + dx[d];\n\tL.y = st.L.y + dy[d];\n\tif (L.x < 0 || L.x >= W || L.y < 0 || L.y >= H || roomL[L.y][L.x] == '#')\n\t  L = st.L;\n\n\tR.x = st.R.x - dx[d];\n\tR.y = st.R.y + dy[d];\n\tif (R.x < 0 || R.x >= W || R.y < 0 || R.y >= H || roomR[R.y][R.x] == '#')\n\t  R = st.R;\n\n\tif (visited[L.y][L.x][R.y][R.x])\n\t  continue;\n\tque.push(State(L, R));\n      }\n    }\n\n    if (reached)\n      cout << \"Yes\" << endl;\n    else\n      cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing psi=pair<string,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define MOD (1e9+7)\nvoid get(){}template<class H,class...T>void get(H&h,T&...t){cin>>h;get(t...);}\ntemplate<class T>void geti(T&a){for(auto&_:a)cin>>_;}\ntemplate<class T>void getii(T&a){for(auto&_:a)geti(_);}\nvoid put(string d){}template<class H,class...T>void put(string d,H&h,T&...t){cout<<h;if(sizeof...(t))cout<<d;put(d,t...);}\ntemplate<class T>void puti(T&a,string d=\" \"){bool f=1;for(auto&_:a)cout<<(exchange(f,0)?\"\":d)<<_;cout<<endl;}\ntemplate<class T>void putii(T&a,string d=\" \"){for(auto&_:a)puti(_,d);}\n#define dcl(...) ll __VA_ARGS__;get(__VA_ARGS__)\n#define dclt(t,...) t __VA_ARGS__;get(__VA_ARGS__)\n\nint main(){\n\tint w,h;\n\twhile(cin>>w>>h,w){\n\t\tvector<vvi> f(2,vvi(h+2,vi(w+2,1)));\n\t\tvvi curr(2,vi(2));\n\t\tvvi stat(2,vi(2));\n\t\tfor(int i=1;i<=h;i++){\n\t\t\trep(p,2){\n\t\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\t\tchar c; cin>>c;\n\t\t\t\t\tif(c=='.'){\n\t\t\t\t\t\tf[p][i][j]=0;\n\t\t\t\t\t}else if(c=='%'){\n\t\t\t\t\t\tf[p][i][j]=0;\n\t\t\t\t\t\tstat[p]={i,j};\n\t\t\t\t\t}else if(c=='L'){\n\t\t\t\t\t\tf[p][i][j]=0;\n\t\t\t\t\t\tcurr[0]={i,j};\n\t\t\t\t\t}else if(c=='R'){\n\t\t\t\t\t\tf[p][i][j]=0;\n\t\t\t\t\t\tcurr[1]={i,w+1-j};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treverse(all(f[1][i]));\n\t\t}\n\t\tstat[1][1]=w+1-stat[1][1];\n\t\t//putii(f[0],\"\");\n\t\t//cout<<endl;\n\t\t//putii(f[1],\"\");\n\t\t//cout<<\"=======\"<<endl;\n\t\t\n\t\t/*幅優先\n\t\t\t・どちらか片方だけ動き、動いた先がゴールでない場合\n\t\t\t・両方動き、かつ少なくともどちらかがそのマスを訪れたことがない場合\n\t\t\tだけ、探索する\n\t\t*/\n\t\tset<vvi> isVisited;\n\t\t//isVisited.insert(curr);\n\n\t\tstack<vvi> que;\n\t\tque.push(curr);\n\t\tint y[]={-1,0,1,0};\n\t\tint x[]={0,1,0,-1};\n\t\tauto step=[f](vi &pos,int lr, int y, int x){\n\t\t\tif(f[lr][pos[0]+y][pos[1]+x]!=1){\n\t\t\t\tpos[0]+=y;\n\t\t\t\tpos[1]+=x;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tbool ok=false;\n\t\twhile(!que.empty()){\n\t\t\tauto c=que.top();\n\t\t\tque.pop();\n\t\t\t//cout<<c[0][0]<<\",\"<<c[0][1]<<\"  \"<<c[1][0]<<\",\"<<c[1][1]<<endl;\n\t\t\tif(c==stat){\n\t\t\t\tok=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(isVisited.find(c)!=isVisited.end()){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tisVisited.insert(c);\n\t\t\trep(v,4){\n\t\t\t\tauto next=c;\n\t\t\t\tbool l=step(next[0],0,y[v],x[v]);\n\t\t\t\tbool r=step(next[1],1,y[v],x[v]);\n\t\t\t\tif(isVisited.find(next)==isVisited.end()){\n\t\t\t\t\tif( (!l and r and next[1]!=stat[1])\n\t\t\t\t\t\tor (l and !r and next[0]!=stat[0])\n\t\t\t\t\t\tor ( l and r and !(next[0]!=stat[0] xor next[1]!=stat[1]) )){\n\t\t\t\t\t\t//cout<<\" o \"<<next[0][0]<<\",\"<<next[0][1]<<\"  \"<<next[1][0]<<\",\"<<next[1][1]<<endl;\n\t\t\t\t\t\tque.push(next);\n\t\t\t\t\t}else{\n\t\t\t\t\t\t//cout<<\" x \"<<next[0][0]<<\",\"<<next[0][1]<<\"  \"<<next[1][0]<<\",\"<<next[1][1]<<endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t}else{\n\t\t\tcout<<\"No\"<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\nstring ml[50], mr[50];\nbool fm[50][50][50][50];\nconst int dx[] = { 0,1,0,-1 };\nconst int dy[] = { 1,0,-1,0 };\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h, w) {\n\t\tfill((bool*)fm, (bool*)fm + 2500 * 2500, 0);\n\t\tvector<pair<pii,pii>> que;\n\t\tpii r, l, gl, gr;\n\t\tpair<pii, pii> g;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tcin >> ml[i] >> mr[i];\n\t\t\tint a = ml[i].find('L');\n\t\t\tif (a != string::npos)l = make_pair(a, i);\n\t\t\ta = ml[i].find('%');\n\t\t\tif (a != string::npos)gl = make_pair(a, i);\n\t\t\ta = mr[i].find('R');\n\t\t\tif (a != string::npos)r = make_pair(a, i);\n\t\t\ta = mr[i].find('%');\n\t\t\tif (a != string::npos)gr = make_pair(a, i);\n\t\t}\n\t\tg = make_pair(gl, gr);\n\t\tque.push_back(make_pair(l, r));\n\t\tbool f = 0;\n\t\twhile (!que.empty()&&!f) {\n\t\t\tauto top = que.back();\n\t\t\tque.pop_back();\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tauto n = top;\n\t\t\t\tn.first.first += dx[i];\n\t\t\t\tn.first.second += dy[i];\n\t\t\t\tn.second.first -= dx[i];\n\t\t\t\tn.second.second += dy[i];\n\t\t\t\tif (n.first.first < 0 || n.first.first >= w)n.first.first = top.first.first;\n\t\t\t\tif (n.first.second < 0 || n.first.second >= h)n.first.second = top.first.second;\n\t\t\t\tif (n.second.first < 0 || n.second.first >= w)n.second.first = top.second.first;\n\t\t\t\tif (n.second.second < 0 || n.second.second >= h)n.second.second = top.second.second;\n\t\t\t\tif (ml[n.first.second][n.first.first] == '#')n.first = top.first;\n\t\t\t\tif (mr[n.second.second][n.second.first] == '#')n.second = top.second;\n\t\t\t\tif (ml[n.first.second][n.first.first] == '%'&&mr[n.second.second][n.second.first] == '%') {\n\t\t\t\t\tf = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (ml[n.first.second][n.first.first] == '%'^mr[n.second.second][n.second.first] == '%')continue;\n\t\t\t\tbool a = 1;\n\t\t\t\tswap(fm[n.first.first][n.first.second][n.second.first][n.second.second], a);\n\t\t\t\tif (a)continue;\n\t\t\t\tque.push_back(n);\n\t\t\t}\n\t\t}\n\t\tcout << (f ? \"YES\" : \"NO\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\n\nstruct Edge{int to,from,cost;};\n\n#define debug cout\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define SS stringstream\n#define X second\n#define Y first\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,-1,1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,-1,1,0};\n\nint used[50][50][50][50],w,h;\nstring l[50],r[50];\nint v[100000][4],vi,vs;\n\nint main() {\n\tIL{\n\t\tcin>>w>>h;\n\t\tif(w==0&&h==0)break;\n\t\trep(i,h){\n\t\t\tcin>>l[i]>>r[i];\n\t\t}\n\t\tvint start(4);\n\t\tvint goal(4);\n\t\trep(i,h)rep(j,w){\n\t\t\tif(l[i][j]=='L'){\n\t\t\t\tstart[0]=i;\n\t\t\t\tstart[1]=j;\n\t\t\t}\n\t\t\tif(r[i][j]=='R'){\n\t\t\t\tstart[2]=i;\n\t\t\t\tstart[3]=j;\n\t\t\t}\n\t\t\tif(l[i][j]=='%'){\n\t\t\t\tgoal[0]=i;\n\t\t\t\tgoal[1]=j;\n\t\t\t}\n\t\t\tif(r[i][j]=='%'){\n\t\t\t\tgoal[2]=i;\n\t\t\t\tgoal[3]=j;\n\t\t\t}\n\t\t}\n\t\tvi=0;vs=1;\n\t\tv[0][0]=start[0];\n\t\tv[0][1]=start[1];\n\t\tv[0][2]=start[2];\n\t\tv[0][3]=start[3];\n\t\tmemset(used,0,sizeof(used));\n\t\tused[start[0]][start[1]][start[2]][start[3]]=1;\n\t\twhile(vi<vs){\n\t\t\tint *now=v[vi++];\n//debug<<now[0]<<\" \"<<now[1]<<\" \"<<now[2]<<\" \"<<now[3]<<endl;\n\t\t\trep(i,4){\n//PUTLINE\n\t\t\t\tint next[4];\n\t\t\t\tnext[0]=now[0]+dy[i];\n\t\t\t\tnext[1]=now[1]+dx[i];\n\t\t\t\tnext[2]=now[2]+dy[i];\n\t\t\t\tnext[3]=now[3]-dx[i];\n//debug<<now[0]<<\" \"<<now[1]<<\" \"<<now[2]<<\" \"<<now[3]<<endl;\n//debug<<next[0]<<\" \"<<next[1]<<\" \"<<next[2]<<\" \"<<next[3]<<endl;\n\t\t\t\tif(next[0]<0||h<=next[0]||l[next[0]][now[1]]=='#')next[0]=now[0];\n\t\t\t\tif(next[1]<0||w<=next[1]||l[now[0]][next[1]]=='#')next[1]=now[1];\n\t\t\t\tif(next[2]<0||h<=next[2]||r[next[2]][now[3]]=='#')next[2]=now[2];\n\t\t\t\tif(next[3]<0||w<=next[3]||r[now[2]][next[3]]=='#')next[3]=now[3];\n//debug<<next[0]<<\" \"<<next[1]<<\" \"<<next[2]<<\" \"<<next[3]<<endl;\n//debug<<endl;\n\t\t\t\tif(used[next[0]][next[1]][next[2]][next[3]]==1)continue;\n//PUTLINE\n\t\t\t\tused[next[0]][next[1]][next[2]][next[3]]=1;\n\t\t\t\tif(l[next[0]][next[1]]=='%')continue;\n\t\t\t\tif(r[next[2]][next[3]]=='%')continue;\n//PUTLINE\n\t\t\t\trep(j,4)v[vs][j]=next[j];\n\t\t\t\t++vs;\n\t\t\t}\n\t\t}\n//debug<<goal[0]<<\" \"<<goal[1]<<\" \"<<goal[2]<<\" \"<<goal[3]<<endl;\n\t\tif(used[goal[0]][goal[1]][goal[2]][goal[3]])cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/2\n\n#define MAX_N 1000\n\nstruct state{\n\tint lw,lh,rw,rh;\n};\n\nint w,h;\nstring bl[55],br[55];\nint slw,slh,srw,srh;\nint glw,glh,grw,grh;\n\nbool vis[55][55][55][55];\n\nint dl[4][2]={{0,1},{1,0},{-1,0},{0,-1}};\nint dr[4][2]={{0,1},{-1,0},{1,0},{0,-1}};\n\nint main(){\n\tcin.sync_with_stdio(false);\n\twhile(1){\n\t\tcin>>w>>h;\n\t\tif(w==0)break;\n\t\trep(i,h)cin>>bl[i]>>br[i];\n\t\trep(i,h)rep(j,w){\n\t\t\tif(bl[i][j]=='L'){\n\t\t\t\tslw=j; slh=i;\n\t\t\t}\n\t\t\tif(br[i][j]=='R'){\n\t\t\t\tsrw=j; srh=i;\n\t\t\t}\n\t\t\tif(bl[i][j]=='%'){\n\t\t\t\tglw=j; glh=i;\n\t\t\t}\n\t\t\tif(br[i][j]=='%'){\n\t\t\t\tgrw=j; grh=i;\n\t\t\t}\n\t\t}\n\t\tbool ok=false;\n\t\tqueue<state> que;\n\t\tque.push((state){slw,slh,srw,srh});\n\t\tmemset(vis,0,sizeof(vis));\n\t\twhile(!que.empty()){\n\t\t\tstate ns=que.front(); que.pop();\n\t\t\tint w1=ns.lw,h1=ns.lh,w2=ns.rw,h2=ns.rh;\n\t\t\tif(vis[w1][h1][w2][h2])continue;\n\t\t\tvis[w1][h1][w2][h2]=true;\n\t\t\tif(w1==glw&&h1==glh&&w2==grw&&h2==grh){\n\t\t\t\tok=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif((w1==glw&&h1==glh)||(w2==grw&&h2==grh))continue;\n\t\t\trep(di,4){\n\t\t\t\tint nw1=w1+dl[di][0],nh1=h1+dl[di][1];\n\t\t\t\tif(nw1<0||nw1>=w||nh1<0||nh1>=h||bl[nh1][nw1]=='#'){\n\t\t\t\t\tnw1=w1;nh1=h1;\n\t\t\t\t}\n\t\t\t\tint nw2=w2+dr[di][0],nh2=h2+dr[di][1];\n\t\t\t\tif(nw2<0||nw2>=w||nh2<0||nh2>=h||br[nh2][nw2]=='#'){\n\t\t\t\t\tnw2=w2; nh2=h2;\n\t\t\t\t}\n\t\t\t\tque.push((state){nw1,nh1,nw2,nh2});\n\t\t\t}\n\t\t}\n\t\tif(ok)cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nconst int INF = 1 << 29;\n\nstruct position {\n    int h, w;\n    position() {}\n    position(int a, int b): h(a), w(b) {}\n};\n\nstruct state {\n    position left, right;\n    int cost;\n    state() {}\n    state(position l, position r, int c): left(l), right(r), cost(c) { }\n};\n\nconst int dh[4] = {1, 0, -1, 0};\nconst int dw[4] = {0, 1, 0, -1};\n\nint W, H;\nstring rooml[55], roomr[55];\n\nint memo[55][55][55][55];\n\nint get_memo(position left, position right) {\n    return memo[left.h][left.w][right.h][right.w];\n}\n\nvoid update_memo(position left, position right, int value) {\n    memo[left.h][left.w][right.h][right.w] = value;\n}\n\nposition move(position p, int dir) {\n    return position(p.h+dh[dir], p.w+dw[dir]);\n}\n\nbool solve() {\n    cin >> W >> H;\n    if (W+H==0) { return false; }\n    for (int j = 0; j < H; ++j) {\n        cin >> rooml[j] >> roomr[j];\n    }\n\n    position sl, sr, gl, gr;\n\n    for (int j = 0; j < H; ++j) {\n        for (int k = 0; k < W; ++k) {\n            if (rooml[j][k] == 'L') { sl.h = j; sl.w = k; }\n            if (roomr[j][k] == 'R') { sr.h = j; sr.w = k; }\n\n            if (rooml[j][k] == '%') { gl.h = j; gl.w = k; }\n            if (roomr[j][k] == '%') { gr.h = j; gr.w = k; }\n        }\n    }\n\n    queue<state> que;\n    que.emplace(sl, sr, 0);\n\n    for (int j = 0; j < H; ++j) {\n        for (int k = 0; k < W; ++k) {\n            for (int l = 0; l < H; ++l) { fill(memo[j][k][l], memo[j][k][l]+W, INF); }\n        }\n    }\n\n    int result = INF;\n    while (!que.empty()) {\n        state st = que.front(); que.pop();\n        if (get_memo(st.left, st.right) < st.cost) { continue; }\n\n        if ((rooml[st.left.h][st.left.w] == '%') != (roomr[st.right.h][st.right.w] == '%')) {\n            continue;\n        }\n\n        if ((rooml[st.left.h][st.left.w] == '%') && (roomr[st.right.h][st.right.w] == '%')) {\n            result = st.cost;\n            break;\n        }\n\n        for (int d = 0; d < 4; ++d) {\n            position nexl = move(st.left, d);\n            position nexr = move(st.right, (4-d)%4);\n\n            if (nexl.h < 0 || nexl.h >= H || nexl.w < 0 || nexl.w > W) { continue; }\n            if (nexr.h < 0 || nexr.h >= H || nexr.w < 0 || nexr.w > W) { continue; }\n\n            if (rooml[nexl.h][nexl.w] == '#') { nexl = st.left; }\n            if (roomr[nexr.h][nexr.w] == '#') { nexr = st.right; }\n\n            if (get_memo(nexl, nexr) > st.cost+1) {\n                update_memo(nexl, nexr, st.cost+1);\n                que.emplace(nexl, nexr, st.cost+1);\n            }\n        }\n    }\n\n    cout << (result == INF ? \"No\" : \"Yes\") << endl;\n\n    return true;\n}\n\nint main() {\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <queue>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\nconst int dy[] = {1, 0, -1, 0};\nconst int dx[] = {0, 1, 0, -1};\nconst int MAX_N = 60;\nstruct Info\n{\n    P left, right;\n};\nstring Rfield[MAX_N];\nstring Lfield[MAX_N];\nint h, w, lsy, lsx, rsy, rsx;\nbool range_check(int y, int x)\n{\n    if(y >= h || x >= w || x < 0 || y < 0) return false;\n    else return true;\n}\nbool bfs()\n{\n    Lfield[lsy][lsx] = '$';\n    Rfield[rsy][rsx] = '$';\n    queue<Info> que;\n    que.push({P(lsy, lsx), P(rsy, rsx)});\n    while(!que.empty())\n    {\n        Info p = que.front();\n        que.pop();\n        for(int i = 0; i < 4; i++)\n        {\n            int ly = p.left.first + dy[i];\n            int lx = p.left.second + dx[i];\n            int ry = p.right.first + dy[i];\n            int rx = p.right.second - dx[i];\n            if(!range_check(ly, lx)) continue;\n            if(!range_check(ry, rx)) continue;\n            if(Lfield[ly][lx] == '$' || Rfield[ry][rx] == '$') continue;\n            if(Lfield[ly][lx] == '#' && Rfield[ry][rx] == '#') continue;\n            if(Lfield[ly][lx] == '%' && Rfield[ry][rx] == '%') return true;\n            if(Lfield[ly][lx] == '%' || Rfield[ry][rx] == '%') continue;\n            if(Lfield[ly][lx] == '.') Lfield[ly][lx] = '$';\n            if(Rfield[ry][rx] == '.') Rfield[ry][rx] = '$';\n            P np = {ly, lx}, nq = {ry, rx};\n            if(Lfield[ly][lx] == '#') np = {p.left.first, p.left.second};\n            if(Rfield[ry][rx] == '#') nq = {p.right.first, p.right.second};\n            que.push({np, nq});\n        }\n    }\n    return false;\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> w >> h, w | h)\n    {\n        for(int i = 0; i < h; i++)\n        {\n            cin >> Lfield[i] >> Rfield[i];\n            for(int j = 0; j < w; j++)\n            {\n                if(Lfield[i][j] == 'L') rsy = i, rsx = j;\n                if(Rfield[i][j] == 'R') lsy = i, lsx = j;\n            }\n        }\n        cout << (bfs() ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint mx[4]={0,1,0,-1};\nint my[4]={1,0,-1,0};\n\nbool memo[50][50][50][50];\n\nint w,h;\n\nbool dfs(pair<int,int>nowL, pair<int,int>nowR, vector<string> &sl,vector<string> &sr){\n    //cout<<nowL.first<<nowL.second<<nowR.first<<nowR.second<<endl;\n    if(memo[nowL.first][nowL.second][nowR.first][nowR.second]){\n        return 0;\n    }else{\n        memo[nowL.first][nowL.second][nowR.first][nowR.second]=1;\n    }\n    if(sl[nowL.first][nowL.second]=='%' && sr[nowR.first][nowR.second]=='%'){\n        return 1;\n    }\n    for(int i=0;i<4;++i){\n        pair<int,int>nextL,nextR;\n        nextL.first=nowL.first+my[i];\n        nextL.second=nowL.second+mx[i];\n        nextR.first=nowR.first+my[i];\n        nextR.second=nowR.second-mx[i];\n        //------------------------------------\n        if(nextL.first<0 || nextL.first>=h){\n            nextL=nowL;\n        }\n        if(nextL.second<0 || nextL.second>=w){\n            nextL=nowL;\n        }\n        if(sl[nextL.first][nextL.second]=='#'){\n            nextL=nowL;\n        }\n        //-------------------------------------\n        if(nextR.first<0 || nextR.first>=h){\n            nextR=nowR;\n        }\n        if(nextR.second<0 || nextR.second>=w){\n            nextR=nowR;\n        }\n        if(sr[nextR.first][nextR.second]=='#'){\n            nextR=nowR;\n        }\n        if(dfs(nextL,nextR,sl,sr))return 1;\n    }\n    return 0;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    while(cin>>w>>h,w){\n        for(int i=0;i<50;++i){\n            for(int j=0;j<50;++j){\n                for(int k=0;k<50;++k){\n                    for(int l=0;l<50;++l){\n                        memo[i][j][k][l]=0;\n                    }\n                }\n            }\n        }\n        vector<string> sl(h),sr(h);\n        pair<int,int>startL,startR;\n        for(int i=0;i<h;++i){\n            cin>>sl[i]>>sr[i];\n            for(int j=0;j<w;++j){\n                if(sl[i][j]=='L'){\n                    startL={i,j};\n                }\n                if(sr[i][j]=='R'){\n                    startR={i,j};\n                }\n            }\n        }\n        if(dfs(startL,startR,sl,sr))cout<<\"Yes\"<<endl;\n        else cout<<\"No\"<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max() / 32 * 15 + 208;\n\narray<array<array<array<int, 50>, 50>, 50>, 50> visited{};\n\nint main() {\n    int h, w;\n    while(cin >> w >> h, h){\n        vector<vector<int>> v(h+2, vector<int>(w+2, 0));\n        auto u = v;\n        for(auto &&i: visited) for(auto &&j: i) for(auto &&k: j) fill(k.begin(),k.end(), 0);\n        int sy1, sx1, sy2, sx2, gy1, gx1, gy2, gx2;\n        for (int i = 0; i < h; ++i) {\n            string s, t;\n            cin >> s >> t;\n            for (int j = 0; j < w; ++j) {\n                v[i+1][j+1] = (s[j] != '#');\n                u[i+1][j+1] = (t[j] != '#');\n                if(s[j] == 'L') sy1 = i, sx1 = j;\n                if(t[j] == 'R') sy2 = i, sx2 = j;\n                if(s[j] == '%') gy1 = i, gx1 = j;\n                if(t[j] == '%') gy2 = i, gx2 = j;\n            }\n        }\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                for (int k = 0; k < h; ++k) {\n                    for (int l = 0; l < w; ++l) {\n                        if((i != gy1 || j != gx1) && (k == gy2 && l == gx2)) visited[i][j][k][l] = 1;\n                        if((i == gy1 && j == gx1) && (k != gy2 || l != gx2)) visited[i][j][k][l] = 1;\n                    }\n                }\n            }\n        }\n        using tup = array<int, 4>;\n        queue<tup> s;\n        s.emplace(tup{sy1, sx1, sy2, sx2});\n        visited[sy1][sx1][sy2][sx2] = 1;\n        tup di = {-1, 1, 0, 0}, dj = {0, 0, 1, -1};\n        while(!s.empty()){\n            auto x = s.front(); s.pop();\n            for (int k = 0; k < 4; ++k) {\n                tup to(x);\n                if(v[to[0]+di[k]+1][to[1]+dj[k]+1]){\n                    to[0] += di[k];\n                    to[1] += dj[k];\n                }\n                if(u[to[2]+di[k]+1][to[3]-dj[k]+1]){\n                    to[2] += di[k];\n                    to[3] -= dj[k];\n                }\n                if(!visited[to[0]][to[1]][to[2]][to[3]]) {\n                    visited[to[0]][to[1]][to[2]][to[3]] = 1;\n                    s.emplace(to);\n                }\n\n            }\n        }\n        puts(visited[gy1][gx1][gy2][gx2] ? \"Yes\" : \"No\");\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nbool memo[50][50][50][50], R1[50][50], R2[50][50];\nchar W, H;\nint dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\nchar sx1, sy1, sx2, sy2, gx1, gx2, gy1, gy2; \nvoid rec(char x1, char y1, char x2, char y2){\n  for(int i = 0; i < 4; ++i){\n    int x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;\n    if(x1 + dx[i] < H && x1 + dx[i] >= 0 &&\n       y1 + dy[i] < W && y1 + dy[i] >= 0 &&\n       R1[x1 + dx[i]][y1 + dy[i]]){\n      x1_ += dx[i];\n      y1_ += dy[i];\n    }\n    if(x2 + dx[i] < H && x2 + dx[i] >= 0 &&\n       y2 - dy[i] < W && y2 - dy[i] >= 0 &&\n       R2[x2 + dx[i]][y2 - dy[i]]){\n      x2_ += dx[i];\n      y2_ -= dy[i];\n    }\n    if((x1_ == gx1 && y1_ == gy1) || (x2_ == gx2 && y2_ == gy2)){\n      memo[x1_][y1_][x2_][y2_] = true;\n    }else if(!memo[x1_][y1_][x2_][y2_]){\n      memo[x1_][y1_][x2_][y2_] = true;\n      rec(x1_,y1_,x2_,y2_);\n    }\n  }\n}\n \nint main(){\n  while(cin >> W >> H, W){\n\n    string r1, r2;\n    for(int i = 0; i < H; ++i){\n      cin >> r1 >> r2;\n      for(int j = 0; j < W; ++j){\n        if(r1[j] == 'L'){\n          sx1 = i;\n          sy1 = j;\n        }\n        if(r2[j] == 'R'){\n          sx2 = i;\n          sy2 = j;\n        }\n        if(r1[j] == '%'){\n          gx1 = i;\n          gy1 = j;\n        }\n        if(r2[j] == '%'){\n          gx2 = i;\n          gy2 = j;\n        }\n        if(r1[j] != '#') R1[i][j] = true;\n        else R1[i][j] = false;\n        if(r2[j] != '#') R2[i][j] = true;\n        else R2[i][j] = false;\n      }\n    }\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n        for(int k = 0; k < H; ++k){\n          for(int l = 0; l< W; ++l){\n            memo[i][j][k][l] = false;\n          }\n        }\n      }\n    }\n    memo[sx1][sy1][sx2][sy2] = true;\n    rec(sx1,sy1,sx2,sy2);\n    if(memo[gx1][gy1][gx2][gy2]) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<char,char> P;\n\nstruct state{\n\tP p1, p2;\n\tstate(P p1_, P p2_){ p1 = p1_; p2 = p2_; }\n};\nint w, h;\nint dx1[4] = {0,-1,1,0};\nint dy1[4] = {-1,0,0,1};\nint dx2[4] = {0,1,-1,0};\nint dy2[4] = {-1,0,0,1};\nbool flag[51][51][51][51];\n\nvoid init(){\n\tfor(int i=0 ; i < 51 ; i++ ){\n\t\tfor(int j=0 ; j < 51 ; j++ ){\n\t\t\tfor(int k=0 ; k < 51 ; k++ ){\n\t\t\t\tfor(int l=0 ; l < 51 ; l++ ){\n\t\t\t\t\tflag[i][j][k][l] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// デバッグ用\ntemplate <class T>\nvoid debug(T v, string s){\n\tcout << s << endl;\n\tfor(int y=0 ; y < v.size() ; y++ ){\n\t\tcout << v[y] << endl;\n\t}\n\tcout << endl;\n}\n\n// vs から vs[y][x] == c となる (x,y) を返す\nP search(vector<string>& vs, char c){\n\tfor(int y=0 ; y < vs.size() ; y++ ){\n\t\tfor(int x=0 ; x < vs[y].size() ; x++ ){\n\t\t\tif( vs[y][x] == c ){\n\t\t\t\tvs[y][x] = '.';\n\t\t\t\treturn P(x,y);\n\t\t\t}\n\t\t}\n\t}\n\treturn P(0,0);\n}\n\nbool bfs(vector<string>& L, vector<string>& R){\n\tP ls = search( L , 'L' );\n\tP rs = search( R , 'R' );\n\t//debug( L , \"[Left]\" );\n\t//debug( R , \"[right]\" );\n\t\n\tqueue< pair<P,P> > q;\n\tpair<P,P> s( ls , rs );\n\tq.push( s );\n\t\n\twhile( !q.empty() ){\n\t\tpair<P,P> now = q.front(); q.pop();\n\t\tint x1 = now.first.first;\n\t\tint y1 = now.first.second;\n\t\tint x2 = now.second.first;\n\t\tint y2 = now.second.second;\n\t\tflag[y1][x1][y2][x2] = true;\n\t\tif( L[y1][x1] == '%' && R[y2][x2] == '%' ){\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\tint mx1 = x1 + dx1[i];\n\t\t\tint my1 = y1 + dy1[i];\n\t\t\tif( mx1 < 0 || my1 < 0 || mx1 >= w || my1 >= h || L[my1][mx1] == '#' ){\n\t\t\t\tmx1 = x1;\n\t\t\t\tmy1 = y1;\n\t\t\t}\n\t\t\tint mx2 = x2 + dx2[i];\n\t\t\tint my2 = y2 + dy2[i];\n\t\t\tif( mx2 < 0 || my2 < 0 || mx2 >= w || my2 >= h || R[my2][mx2] == '#' ){\n\t\t\t\tmx2 = x2;\n\t\t\t\tmy2 = y2;\n\t\t\t}\n\t\t\tP p1(mx1,my1);\n\t\t\tP p2(mx2,my2);\n\t\t\tpair<P,P> next(p1,p2);\n\t\t\tif( flag[my1][mx1][my2][mx2] ){\n\t\t\t\tcontinue;\n\t\t\t}else if( L[my1][mx1] == '%' && R[my2][mx2] != '%' ){\n\t\t\t\tflag[my1][mx1][my2][mx2] = true;\n\t\t\t}else if( L[my1][mx1] != '%' && R[my2][mx2] == '%' ){\n\t\t\t\tflag[my1][mx1][my2][mx2] = true;\n\t\t\t}else{\n\t\t\t\tq.push( next );\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\twhile( cin >> w >> h, w || h ){\n\t\tinit();\n\t\tvector<string> L(h), R(h);\n\t\t\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tcin >> L[y];\n\t\t\tcin >> R[y];\n\t\t}\n\t\tbool ans = bfs( L , R );\n\t\tif( ans )\n\t\t\tcout << \"Yes\" << endl;\n\t\telse\n\t\t\tcout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define F first\n#define S second\n\ntypedef pair<int,int> pii;\n\nvector<string> va,vb;\nint H,W;\nint dp[55][55][55][55];\nint aay[]={0,1,0,-1};\nint aax[]={1,0,-1,0};\nint bby[]={0,1,0,-1};\nint bbx[]={-1,0,1,0};\nqueue<pair<pii,pii>> q;\nbool check(int a,int b){\n\tif(0<=a&&a<H&&0<=b&&b<W) return true;\n\treturn false;\n}\nint dfs(int a,int b,int c,int d){\n\tif(dp[a][b][c][d]>=0) return dp[a][b][c][d];\n\tint ret=0;\n\t// cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<endl;\n\tdp[a][b][c][d]=0;\n\tif(va[a][b]=='%'&&vb[c][d]=='%'){\n\t\treturn dp[a][b][c][d]=1;\n\t}\n\tif(va[a][b]=='%'||vb[c][d]=='%'){\n\t\treturn dp[a][b][c][d]=0;\n\t}\n\trep(i,4){\n\t\tint aa=a+aay[i];\n\t\tint bb=b+aax[i];\n\t\tint cc=c+bby[i];\n\t\tint dd=d+bbx[i];\n\t\tif(!check(aa,bb)){\n\t\t\taa=a;\n\t\t\tbb=b;\n\t\t}\n\t\tif(!check(cc,dd)){\n\t\t\tcc=c;\n\t\t\tdd=d;\n\t\t}\n\t\tif(va[aa][bb]=='#'){\n\t\t\taa=a;\n\t\t\tbb=b;\n\t\t}\n\t\tif(vb[cc][dd]=='#'){\n\t\t\tcc=c;\n\t\t\tdd=d;\n\t\t}\n\t\tif(dfs(aa,bb,cc,dd)==1) ret=1;\n\t}\n\treturn dp[a][b][c][d]=ret;\n}\nint main(){\n\twhile(cin>>W>>H){\n\t\tif(W==0&&H==0) break;\n\t\tpii L,R;\n\t\tva=vector<string>(H);\n\t\tvb=vector<string>(H);\n\t\trep(i,H) cin>>va[i]>>vb[i];\n\t\trep(i,H){\n\t\t\trep(j,W){\n\t\t\t\tif(va[i][j]=='L'){\n\t\t\t\t\tva[i][j]='.';\n\t\t\t\t\tL=pii(i,j);\n\t\t\t\t}\n\t\t\t\tif(vb[i][j]=='R'){\n\t\t\t\t\tvb[i][j]='.';\n\t\t\t\t\tR=pii(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,55){\n\t\t\trep(j,55){\n\t\t\t\trep(k,55){\n\t\t\t\t\trep(l,55){\n\t\t\t\t\t\tdp[i][j][k][l]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool f=false;\n\t\tqueue<pair<pii,pii>> q;\n\t\tq.push(make_pair(L,R));\n\t\tdp[L.F][L.S][R.F][R.S]=1;\n\t\tint a,b,c,d;\n\t\twhile(q.size()){\n\t\t\tpair<pii,pii> top=q.front();\n\t\t\tq.pop();\n\t\t\ta=top.F.F;\n\t\t\tb=top.F.S;\n\t\t\tc=top.S.F;\n\t\t\td=top.S.S;\n\t\t\tif(va[a][b]=='%'&&vb[c][d]=='%'){\n\t\t\t\tf=true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(va[a][b]=='%'||vb[c][d]=='%'){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<endl;\n\t\t\trep(i,4){\n\t\t\t\tint aa=a+aay[i];\n\t\t\t\tint bb=b+aax[i];\n\t\t\t\tint cc=c+bby[i];\n\t\t\t\tint dd=d+bbx[i];\n\t\t\t\tif(!check(aa,bb)){\n\t\t\t\t\taa=a;\n\t\t\t\t\tbb=b;\n\t\t\t\t}\n\t\t\t\tif(!check(cc,dd)){\n\t\t\t\t\tcc=c;\n\t\t\t\t\tdd=d;\n\t\t\t\t}\n\t\t\t\tif(va[aa][bb]=='#'){\n\t\t\t\t\taa=a;\n\t\t\t\t\tbb=b;\n\t\t\t\t}\n\t\t\t\tif(vb[cc][dd]=='#'){\n\t\t\t\t\tcc=c;\n\t\t\t\t\tdd=d;\n\t\t\t\t}\n\t\t\t\tif(dp[aa][bb][cc][dd]>=0) continue;\n\t\t\t\telse{\n\t\t\t\t\tdp[aa][bb][cc][dd]=1;\n\t\t\t\t\tq.push(make_pair(pii(aa,bb),pii(cc,dd)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(f) cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nint W, H;\nstruct pos\n{\n\tint x, y, dis;\n};\nint main() {\n\n\twhile (cin >> W >> H, W | H){\n\t\tvector<string> vsl;\n\t\tvector<string> vsr;\n\t\tREP(i, H){\n\t\t\tstring l;\n\t\t\tstring r;\n\t\t\tcin >> l >> r;\n\t\t\tvsl.push_back(l);\n\t\t\tvsr.push_back(r);\n\t\t}\n\t\tvector<vector<int>> vvil(H);\n\t\tvector<vector<int>> vvir(H);\n\t\tint glx;\n\t\tint gly;\n\t\tint grx;\n\t\tint gry;\n\t\tint lx;\n\t\tint ly;\n\t\tint rx;\n\t\tint ry;\n\t\tREP(i, H){\n\t\t\tREP(j, W){\n\t\t\t\tif (vsl[i][j] == '#')vvil[i].push_back(-1);\n\t\t\t\telse vvil[i].push_back(9999);\n\n\t\t\t\tif (vsr[i][j] == '#')vvir[i].push_back(-1);\n\t\t\t\telse vvir[i].push_back(9999);\n\n\t\t\t\tif (vsl[i][j] == 'L'){\n\t\t\t\t\tlx = j;\n\t\t\t\t\tly = i;\n\t\t\t\t}\n\t\t\t\tif (vsr[i][j] == 'R'){\n\t\t\t\t\trx = j;\n\t\t\t\t\try = i;\n\t\t\t\t}\n\t\t\t\tif (vsl[i][j] == '%'){\n\t\t\t\t\tglx = j;\n\t\t\t\t\tgly = i;\n\t\t\t\t}\n\t\t\t\tif (vsr[i][j] == '%'){\n\t\t\t\t\tgrx = j;\n\t\t\t\t\tgry = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<pos> vp;\n\t\tvp.push_back({ glx, gly, 0 });\n\t\twhile (!vp.empty()){\n\t\t\tpos p = vp[0];\n\t\t\tvp.erase(vp.begin());\n\t\t\tREP(i, 4){\n\t\t\t\tif (p.x + dx[i] >= 0 && p.x + dx[i] < W&&p.y + dy[i] >= 0 && p.y + dy[i] < H&& vvil[p.y + dy[i]][p.x + dx[i]] != -1 && vvil[p.y + dy[i]][p.x + dx[i]] == 9999){\n\t\t\t\t\tvp.push_back({ p.x + dx[i], p.y + dy[i], p.dis + 1 });\n\t\t\t\t\tvvil[p.y + dy[i]][p.x + dx[i]] = p.dis + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvp.push_back({ grx, gry, 0 });\n\t\twhile (!vp.empty()){\n\t\t\tpos p = vp[0];\n\t\t\tvp.erase(vp.begin());\n\t\t\tREP(i, 4){\n\t\t\t\tif (p.x + dx[i] >= 0 && p.x + dx[i] < W&&p.y + dy[i] >= 0 && p.y + dy[i] < H&& vvir[p.y + dy[i]][p.x + dx[i]] != -1 && vvir[p.y + dy[i]][p.x + dx[i]] == 9999){\n\t\t\t\t\tvp.push_back({ p.x + dx[i], p.y + dy[i], p.dis + 1 });\n\t\t\t\t\tvvir[p.y + dy[i]][p.x + dx[i]] = p.dis + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<int> vi;\n\t\tvi.push_back(lx * 1000000 + ly * 10000 + rx * 100 + ry);\n\t\tint count = 0;\n\t\tint pcount = 1;\n\t\tbool clear = false;\n\t\twhile (1){\n\t\t\t/*if (vi[count] == glx * 1000000 + gly * 10000 + grx * 100 + gry){\n\t\t\t\tclear = true;\n\t\t\t\tbreak;\n\t\t\t\t}*/\n\t\t\tint lx2 = vi[count] / 1000000 % 100;\n\t\t\tint ly2 = vi[count] / 10000 % 100;\n\t\t\tint rx2 = vi[count] / 100 % 100;\n\t\t\tint ry2 = vi[count] % 100;\n\n\t\t\tREP(i, 4){\n\t\t\t\tint lx3 = lx2;\n\t\t\t\tint ly3 = ly2;\n\t\t\t\tint rx3 = rx2;\n\t\t\t\tint ry3 = ry2;\n\t\t\t\tif (dx[i] != 0 && lx3 + dx[i] >= 0 && lx3 + dx[i] < W && vsl[ly3 + dy[i]][lx3 + dx[i]] != '#')lx3 += dx[i];\n\t\t\t\tif (dy[i] != 0 && ly3 + dy[i] >= 0 && ly3 + dy[i] < H && vsl[ly3 + dy[i]][lx3 + dx[i]] != '#')ly3 += dy[i];\n\t\t\t\tif (dx[i] != 0 && rx3 - dx[i] >= 0 && rx3 - dx[i] < W && vsr[ry3 + dy[i]][rx3 - dx[i]] != '#')rx3 -= dx[i];\n\t\t\t\tif (dy[i] != 0 && ry3 + dy[i] >= 0 && ry3 + dy[i] < H && vsr[ry3 + dy[i]][rx3 - dx[i]] != '#')ry3 += dy[i];\n\t\t\t\tif (find(vi.begin(), vi.end(), lx3 * 1000000 + ly3 * 10000 + rx3 * 100 + ry3) == vi.end() && vvil[ly3][lx3] != 0 && vvir[ry3][rx3] != 0)vi.push_back(lx3 * 1000000 + ly3 * 10000 + rx3 * 100 + ry3);\n\t\t\t\tif (lx3 == glx&&ly3 == gly&&rx3 == grx&&ry3 == gry)clear = true;\n\t\t\t}\n\t\t\tif (clear)break;\n\t\t\tif (count + 1 == vi.size())break;\n\t\t\tint min = 10000;\n\t\t\tint i2 = 0;\n\n\t\t\tFOR(i, count + 1, vi.size()){\n\t\t\t\tif (vvil[(vi[i] / 10000 % 100)][(vi[i] / 1000000 % 100)] + vvir[(vi[i] % 100)][(vi[i] / 100 % 100)] < min){\n\t\t\t\t\tmin = vvil[(vi[i] / 10000 % 100)][(vi[i] / 1000000 % 100)] + vvir[(vi[i] % 100)][(vi[i] / 100 % 100)];\n\t\t\t\t\ti2 = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (vvil[ly2][lx2] + vvir[ry2][rx2] < min)break;\n\t\t\tswap(vi[count + 1], vi[i2]);\n\n\t\t\tcount++;\n\t\t}\n\n\t\tif (clear)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\nint const dxL[] = {-1,0,1,0};\nint const dxR[] = {1,0,-1,0};\nint const dy[]  = {0,-1,0,1};\ntypedef pair<int, int> Pii;\n#define X first\n#define Y second\nint const INF = 1<<28;\nint W, H;\nchar grL[51][51], grR[51][51];\nint dist[255][255];\ninline bool inF(int x, int y, int isL) {\n  if(0<=x&&x<W && 0<=y&&y<H) {\n    if(isL) return grL[y][x]!='#';\n    else return grR[y][x]!='#';\n  }\n  return false;\n}\ninline int toNode(int x, int y) {\n  return y*W+x;\n}\ninline void toPos(int node, int &x, int &y) {\n  x = node%W, y = node/W;\n}\nint main() {\n  \n  while(cin >> W >> H && (W|H)) {\n    int sxL, syL, sxR, syR;\n    int gxL, gyL, gxR, gyR;\n    for(int i=0; i<H; i++) {\n      for(int j=0; j<2*W; j++) {\n        if(j<W) {\n          cin >> grL[i][j];\n          if(grL[i][j] == 'L') {\n            sxL = j, syL = i;\n          }\n          if(grL[i][j] == '%') {\n            gxL = j, gyL = i;\n          }\n        }\n        else {\n          cin >> grR[i][j-W];\n          if(grR[i][j-W] == 'R') {\n            sxR = j-W, syR = i;\n          }\n          if(grR[i][j-W] == '%') {\n            gxR = j-W, gyR = i;\n          }\n        }\n      }\n    }\n    \n    queue<int> qCost;\n    queue<int> qL, qR;\n    qCost.push(0);\n    qL.push(toNode(sxL, syL)); qR.push(toNode(sxR, syR));\n    bool ok = false;\n    fill(dist[0], dist[0]+255*255, INF);\n    dist[toNode(sxL, syL)][toNode(sxR, syR)] = 0;\n    bool flag = false;\n    while(!qL.empty()) {\n      int nowL = qL.front(); qL.pop();\n      int nowR = qR.front(); qR.pop();\n      int lx, ly; toPos(nowL, lx, ly);\n      int rx, ry; toPos(nowR, rx, ry);\n      int cost = qCost.front(); qCost.pop();\n      if(flag && dist[nowL][nowR] != INF) continue;\n      flag = true;\n      if(lx == gxL && ly == gyL && rx == gxR && ry == gyR) {\n        ok = true; break;\n      }\n      if(lx == gxL && ly == gyL) {\n        continue;\n      }\n      if(rx == gxR && ry == gyR) {\n        continue;\n      }\n      for(int i=0; i<4; i++) {\n        int nxL = lx+dxL[i], nyL = ly+dy[i];\n        int nxR = rx+dxR[i], nyR = ry+dy[i];\n        if(!inF(nxL, nyL, 1) && !inF(nxR, nyR, 0)) continue;\n        if(!inF(nxL, nyL, 1)) { nxL = lx, nyL = ly; }\n        if(!inF(nxR, nyR, 0)) { nxR = rx, nyR = ry; }\n        if(dist[toNode(nxL, nyL)][toNode(nxR, nyR)] != INF) continue;\n        qCost.push(cost+1);\n        qL.push(toNode(nxL, nyL));\n        qR.push(toNode(nxR, nyR));\n        dist[nowL][nowR] = cost+1;\n      }\n    }\n    if(ok) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<algorithm>\n\n#define fs first\n#define sc second\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint main(){\n  int w,h;\n  string room[2][50];\n  int ry,rx,ly,lx;\n\n  while(cin >> w >> h && (w||h)){\n    int ay[2],ax[2];\n\n    for(int i=0;i<h;i++){\n      for(int k=0;k<2;k++){\n\tcin >> room[k][i];\n\tfor(int j=0;j<w;j++){\n\t  if(room[k][i][j] == 'L'){\n\t    ly = i; lx = j;\n\t    room[k][i][j] == '.';\n\t  }\n\t  if(room[k][i][j] == 'R'){\n\t    ry = i; rx = j;\n\t    room[k][i][j] = '.';\n\t  }\n\t  if(room[k][i][j] == '%'){\n\t    ay[k] = i; ax[k] = j;\n\t  }\n\t}\n      }\n    }\n\n    bool visit[50][50][50][50];\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tfor(int k=0;k<h;k++)\n\t  for(int l=0;l<w;l++)visit[i][j][k][l] = false;\n\n    queue<P2> q;\n    q.push(P2(P(ly,lx),P(ry,rx)));\n\n    while(q.size()){\n      P2 p = q.front();q.pop();\n      ly = p.fs.fs; lx = p.fs.sc; ry = p.sc.fs; rx = p.sc.sc;\n\n      if(visit[ly][lx][ry][rx])continue;\n      visit[ly][lx][ry][rx] = true;\n\n      if(room[0][ly][lx] == '%' && room[1][ry][rx] == '%')break;\n\n      int ldy[] = {-1,0,1,0}, ldx[] = {0,-1,0,1};\n      int rdy[] = {-1,0,1,0}, rdx[] = {0,1,0,-1};\n\n      for(int i=0;i<4;i++){\n\tint lsy = ly + ldy[i], lsx = lx + ldx[i];\n\tint rsy = ry + rdy[i], rsx = rx + rdx[i];\n\tif(lsy < 0 || h-1 < lsy)lsy = ly;\n\tif(lsx < 0 || w-1 < lsx)lsx = lx;\n\tif(room[0][lsy][lsx] == '#'){\n\t  lsy = ly;\n\t  lsx = lx;\n\t}\n\tif(rsy < 0 || h-1 < rsy)rsy = ry;\n\tif(rsx < 0 || w-1 < rsx)rsx = rx;\n\tif(room[1][rsy][rsx] == '#'){\n\t  rsy = ry;\n\t  rsx = rx;\n\t}\n\n\tif( (room[0][ly][lx] == '%') != (room[1][ry][rx] == '%'))continue;\n\n\tq.push(P2(P(lsy,lsx),P(rsy,rsx)));\n      }\n    }\n\n    if(visit[ay[0]][ax[0]][ay[1]][ax[1]])cout << \"Yes\\n\";\n    else cout << \"No\\n\";\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) for(auto x : v){cout << x << \" \";} cout << endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(vv) for(auto v : vv){for(auto&& x : v){cout << x << \" \";}cout << endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\ntypedef vector<vector<int>> Graph;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nint a[2500][2500];\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    cout << 123 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\nbool vis[50][50][50][50];\n\nvoid move(int& x, int& y, int dir, vector<string>& a) {\n\tint H = a.size(), W = a[0].length();\n\tx += dx[dir]; y += dy[dir];\n\tif (x >= 0 && x < W && y >= 0 && y < H && a[y][x] != '#')\n\t\treturn;\n\tx -= dx[dir]; y -= dy[dir];\n}\n\nint main() {\n\tfor (;;) {\n\t\tint W, H; cin >> W >> H;\n\t\tif (W == 0 && H == 0) break;\n\t\tvector<string> al(H), ar(H);\n\t\tint xsl, ysl, xtl, ytl, xsr, ysr, xtr, ytr;\n\t\tfor (int y = 0; y < H; y++) {\n\t\t\tcin >> al[y] >> ar[y];\n\t\t\treverse(ar[y].begin(), ar[y].end());\n\t\t\tfor (int x = 0; x < W; x++) {\n\t\t\t\tif (al[y][x] == 'L') {\n\t\t\t\t\txsl = x; ysl = y;\n\t\t\t\t}\n\t\t\t\tif (al[y][x] == '%') {\n\t\t\t\t\txtl = x; ytl = y;\n\t\t\t\t}\n\t\t\t\tif (ar[y][x] == 'R') {\n\t\t\t\t\txsr = x; ysr = y;\n\t\t\t\t}\n\t\t\t\tif (ar[y][x] == '%') {\n\t\t\t\t\txtr = x; ytr = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int yl = 0; yl < H; yl++)\n\t\t\tfor (int xl = 0; xl < W; xl++)\n\t\t\t\tfor (int yr = 0; yr < H; yr++)\n\t\t\t\t\tfor (int xr = 0; xr < W; xr++)\n\t\t\t\t\t\tvis[xl][yl][xr][yr] = false;\n\t\tvis[xsl][ysl][xsr][ysr] = true;\n\t\tstack<int> XL, YL, XR, YR;\n\t\tXL.push(xsl); YL.push(ysl); XR.push(xsr); YR.push(ysr);\n\t\twhile (!XL.empty()) {\n\t\t\tint xl = XL.top(); XL.pop();\n\t\t\tint yl = YL.top(); YL.pop();\n\t\t\tint xr = XR.top(); XR.pop();\n\t\t\tint yr = YR.top(); YR.pop();\n\t\t\tfor (int dir = 0; dir < 4; dir++) {\n\t\t\t\tint _xl = xl, _yl = yl, _xr = xr, _yr = yr;\n\t\t\t\tmove(_xl, _yl, dir, al);\n\t\t\t\tmove(_xr, _yr, dir, ar);\n\t\t\t\tif (vis[_xl][_yl][_xr][_yr]) continue;\n\t\t\t\tvis[_xl][_yl][_xr][_yr] = true;\n\t\t\t\tif ((_xl == xtl && _yl == ytl) || (_xr == xtr && _yr == ytr)) continue;\n\t\t\t\tXL.push(_xl); YL.push(_yl); XR.push(_xr); YR.push(_yr);\n\t\t\t}\n\t\t}\n\t\tcout << (vis[xtl][ytl][xtr][ytr] ? \"Yes\" : \"No\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nstring ans;\nint h,w;\n//         l r d u\nint Rx[4]={0,0,1,-1};\nint Ry[4]={1,-1,0,0};\n//         r l d u\nint Lx[4]={0,0,1,-1};\nint Ly[4]={-1,1,0,0};\n\nchar RenR[51][51],LinR[51][51];\nbool memo[51][51][51][51];\n\nvoid move(int muki,int ri,int rj,int li,int lj)\n{\n  //  cout<<ri<<\" \"<<rj<<\" \"<<li<<\" \"<<lj<<endl;\n  int ra=ri+Rx[muki],rb=rj+Ry[muki];\n  if(0<=ra && 0<=rb && ra<h && rb<w){\n    if(RenR[ra][rb]!='#'){\n      ri=ra;\n      rj=rb;\n    }\n  }\n  int la=li+Lx[muki],lb=lj+Ly[muki];\n  if(0<=la && 0<=lb && la<h && lb<w){\n    if(LinR[la][lb]!='#'){\n      li=la;\n      lj=lb;\n    }\n  }\n  if(memo[ri][rj][li][lj])return;\n  memo[ri][rj][li][lj]=true;\n  if(RenR[ri][rj]=='%' && LinR[li][lj]=='%'){\n    ans=\"Yes\";\n    return;\n  }\n  if(RenR[ri][rj]=='%' || LinR[li][lj]=='%')return;\n\n  for(int k=0;k<4;k++)move(k,ri,rj,li,lj);\n}\n\nint main()\n{\n  int ri,rj,li,lj;\n  while(1){\n    cin>>w>>h;\n    if(w+h==0)break;\n    for(int i=0;i<50;i++){\n      for(int j=0;j<50;j++){\n\tfor(int k=0;k<50;k++){\n\t  for(int l=0;l<50;l++)memo[i][j][k][l]=false;\n\t}\n      }\n      }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>LinR[i][j];\n\tif(LinR[i][j]=='L'){\n\t  li=i;lj=j;\n\t  LinR[i][j]='.';\n\t}\n      }\n      for(int j=0;j<w;j++){\n\tcin>>RenR[i][j];\n\tif(RenR[i][j]=='R'){\n\t  ri=i;rj=j;\n\t  RenR[i][j]='.';\n\t}\n      }\n    }\n    ans=\"No\";\n    memo[ri][rj][li][lj]=true;\n    for(int i=0;i<4;i++)move(i,ri,rj,li,lj);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define pb push_back\n#define fi first\n#define sc second\nusing namespace std;\ntypedef pair<int,int> P;\n\nint w, h;\nP as, ae, bs, be;\nstring a[50], b[50];\nbool use[50][50][50][50];\nint daw[4] = {1,0,-1,0},dah[4]={0,1,0,-1};\nint dbw[4] = {-1,0,1,0},dbh[4]={0,1,0,-1};\n\nvoid dfs(int p, int q, int r, int s, int d){\n\tif(d > 100) return;\n\trep(i,4){\n\t\tint dp = p+dah[i],dq = q+daw[i];\n\t\tint dr = r+dbh[i],ds = s+dbw[i];\n\t\tif(0>dp||dp>=h||0>dq||dq>=w||a[dp][dq]=='#'){\n\t\t\tdp = p;\n\t\t\tdq = q;\n\t\t}\n\t\tif(0>dr||dr>=h||0>ds||ds>=w||b[dr][ds]=='#'){\n\t\t\tdr = r;\n\t\t\tds = s;\n\t\t}\n\t\tif(use[dp][dq][dr][ds]) continue;\n\t\tif(ae == P(dp,dq) && be != P(dr,ds)) continue;\n\t\tif(ae != P(dp,dq) && be == P(dr,ds)) continue;\n\t\tuse[dp][dq][dr][ds] = true;\n\t\tdfs(dp,dq,dr,ds,d+1);\n\t}\n}\n\nint main(){\n\twhile(scanf(\"%d%d\",&w,&h),w||h){\n\t\tmemset(use,0,sizeof(use));\n\t\trep(i,h) cin >> a[i] >> b[i];\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tif(a[i][j] == 'L') as = P(i,j);\n\t\t\t\tif(b[i][j] == 'R') bs = P(i,j);\n\t\t\t\tif(a[i][j] == '%') ae = P(i,j);\n\t\t\t\tif(b[i][j] == '%') be = P(i,j);\n\t\t\t}\n\t\t}\n\t\tint d = 0;\n\t\tuse[as.fi][as.sc][bs.fi][bs.sc] = true;\n\t\tdfs(as.fi,as.sc,bs.fi,bs.sc,d);\n\t\tif(use[ae.fi][ae.sc][be.fi][be.sc]) puts(\"Yes\");\n\t\telse puts(\"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<map>\nusing namespace std;\nint dx[4] = {0,0,1,-1};\nint dy[4] = {1,-1,0,0};\nint main(){\n  int W,H;\n  while(cin >>W>>H,W||H){\n    int roomL[60][60],roomR[60][60];\n    int RSX,RSY,LSX,LSY,RGX,RGY,LGX,LGY;\n    for(int i=0; i<60; i++) for(int j=0; j<60; j++) roomL[i][j] = roomR[i][j] = -1;\n    for(int i=0; i<H; i++){\n      string s;\n      cin >>s;\n      for(int j=0; j<W; j++){\n\tif(s[j] == '%'){LGX = j+5; LGY = i+5;}\n\tif(s[j] == '#') roomL[j+5][i+5] = -1;\n\tif(s[j] == '.') roomL[j+5][i+5] = 0;\n\tif(s[j] == 'L'){LSX = j+5; LSY = i+5;}\n      }\n      cin >>s;\n      for(int j=0; j<W; j++){\n\tif(s[j] == '%'){RGX = j+5; RGY = i+5;}\n\tif(s[j] == '#') roomR[j+5][i+5] = -1;\n\tif(s[j] == '.') roomR[j+5][i+5] = 0;\n\tif(s[j] == 'R'){RSX = j+5; RSY = i+5;}\n      }\n    }\n    set<pair<pair<int,int>,pair<int,int> > > log;\n    log.insert(make_pair(make_pair(LSX,LSY),make_pair(RSX,RSY)));\n    set<pair<pair<int,int>,pair<int,int> > > next;\n    for(int i=0; i<500; i++){\n      for(set<pair<pair<int,int>,pair<int,int> > >::iterator it = log.begin(); it!=log.end(); it++){\n\tint lx,ly,rx,ry,lnx,lny,rnx,rny;\n\tlx = (it->first).first;\n\tly = (it->first).second;\n\trx = (it->second).first;\n\try = (it->second).second;\n\tfor(int i=0; i<4; i++){\n\t  if(rx+dx[i] == RGX && ry+dy[i] == RGY){\n\t    if(lx-dx[i] == LGX && ly+dy[i] == LGY){cout <<\"Yes\"<<endl;goto flag;}\n\t    continue;\n\t  }\n\t  if(lx-dx[i] == LGX && ly+dy[i] == LGY) continue;\n\t  if(roomR[rx+dx[i]][ry+dy[i]] == -1){rnx = rx;rny = ry;}\n\t  else if(roomR[rx+dx[i]][ry+dy[i]] == 0){rnx = rx+dx[i];rny = ry+dy[i];}\n\t  if(roomL[lx-dx[i]][ly+dy[i]] == -1){lnx = lx;lny = ly;}\n\t  else if(roomL[lx-dx[i]][ly+dy[i]] == 0){lnx = lx-dx[i];lny = ly+dy[i];}\n\t  next.insert(make_pair(make_pair(lnx,lny),make_pair(rnx,rny)));\n\t}\n      }\n      log = next;\n    }\n    cout <<\"No\"<<endl;\n  flag:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\nint const dxL[] = {-1,0,1,0};\nint const dxR[] = {1,0,-1,0};\nint const dy[]  = {0,-1,0,1};\ntypedef pair<int, int> Pii;\n#define X first\n#define Y second\nint const INF = 1<<28;\nint W, H;\nchar grL[51][51], grR[51][51];\nbool used[2500][2500];\ninline bool isValid(int x, int y) {\n  if(0<=x&&x<W && 0<=y&&y<H) return true;\n  return false;\n}\n\ninline bool inF(int x, int y, int isL) {\n  if(isL) return grL[y][x]!='#';\n  return grR[y][x]!='#';\n}\ninline int toNode(int x, int y) {\n  return y*W+x;\n}\ninline void toPos(int node, int &x, int &y) {\n  x = node%W, y = node/W;\n}\nint main() {\n  \n  while(cin >> W >> H && (W|H)) {\n    int sxL, syL, sxR, syR;\n    int gxL, gyL, gxR, gyR;\n    for(int i=0; i<H; i++) {\n      for(int j=0; j<2*W; j++) {\n        if(j<W) {\n          cin >> grL[i][j];\n          if(grL[i][j] == 'L') {\n            sxL = j, syL = i;\n          }\n          if(grL[i][j] == '%') {\n            gxL = j, gyL = i;\n          }\n        }\n        else {\n          cin >> grR[i][j-W];\n          if(grR[i][j-W] == 'R') {\n            sxR = j-W, syR = i;\n          }\n          if(grR[i][j-W] == '%') {\n            gxR = j-W, gyR = i;\n          }\n        }\n      }\n    }\n    \n    queue<int> qL, qR;\n    qL.push(toNode(sxL, syL)); qR.push(toNode(sxR, syR));\n    bool ok = false;\n    memset(used, false, sizeof used);\n    while(!qL.empty()) {\n      const int nowL = qL.front(); qL.pop();\n      const int nowR = qR.front(); qR.pop();\n      int lx, ly; toPos(nowL, lx, ly);\n      int rx, ry; toPos(nowR, rx, ry);\n\n      if(lx == gxL && ly == gyL && rx == gxR && ry == gyR) {\n        ok = true; break;\n      }\n      if(lx == gxL && ly == gyL) {\n        continue;\n      }\n      if(rx == gxR && ry == gyR) {\n        continue;\n      }\n      for(int i=0; i<4; i++) {\n        int nxL = lx+dxL[i], nyL = ly+dy[i];\n        int nxR = rx+dxR[i], nyR = ry+dy[i];\n\n        if((!isValid(nxL, nyL)) || (!isValid(nxR, nyR))) continue;\n\n        if((!inF(nxL, nyL, 1)) && (!inF(nxR, nyR, 0))) continue;\n        if(!inF(nxL, nyL, 1)) { nxL = lx, nyL = ly; }\n        if(!inF(nxR, nyR, 0)) { nxR = rx, nyR = ry; }\n        if(used[toNode(nxL, nyL)][toNode(nxR, nyR)]) continue;\n        qL.push(toNode(nxL, nyL));\n        qR.push(toNode(nxR, nyR));\n        used[toNode(nxL, nyL)][toNode(nxR, nyR)] = true;\n      }\n    }\n    if(ok) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define WRAP(x,y,w,h) (0<=x && x<w && 0<=y && y<h)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h, w) {\n\t\tvector<string> cell1(h);\n\t\tvector<string> cell2(h);\n\t\tint slx, sly, srx, sry;\n\t\tint glx, gly, grx, gry;\n\t\tREP(i, h) {\n\t\t\tcin >> cell1[i] >> cell2[i];\n\t\t\tREP(j, w / 2)\n\t\t\t\tswap(cell2[i][j], cell2[i][w - 1 - j]);\n\t\t\tREP(j, w) {\n\t\t\t\tif (cell1[i][j] == 'L') {\n\t\t\t\t\tsly = i;\n\t\t\t\t\tslx = j;\n\t\t\t\t}\n\t\t\t\tif (cell1[i][j] == '%') {\n\t\t\t\t\tgly = i;\n\t\t\t\t\tglx = j;\n\t\t\t\t}\n\t\t\t\tif (cell2[i][j] == 'R') {\n\t\t\t\t\tsry = i;\n\t\t\t\t\tsrx = j;\n\t\t\t\t}\n\t\t\t\tif (cell2[i][j] == '%') {\n\t\t\t\t\tgry = i;\n\t\t\t\t\tgrx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tset<pair<pair<char, char>, pair<char, char>>> G;\n\t\tG.insert({ {sly,slx},{sry,srx} });\n\t\tqueue<pair<pair<char, char>, pair<char, char>>> Q;\n\t\tQ.push({ { sly,slx },{ sry,srx } });\n\t\tstring clear = \"No\";\n\t\twhile (!Q.empty()) {\n\t\t\tpair<pair<char, char>, pair<char, char>> q;\n\t\t\t\tq = Q.front();Q.pop();\n\t\t\tif (q.first.first==gly&&\n\t\t\t\tq.first.second == glx&&\n\t\t\t\tq.second.first == gry&&\n\t\t\t\tq.second.first == grx) {\n\t\t\t\tclear = \"Yes\";\n\t\t\t\tgoto ANS;\n\t\t\t}\n\t\t\tREP(i, 4) {\n\t\t\t\tint nly = q.first.first + dy[i];\n\t\t\t\tint nlx = q.first.second + dx[i];\n\t\t\t\tint nry = q.second.first + dy[i];\n\t\t\t\tint nrx = q.second.second + dx[i];\n\t\t\t\tif (!WRAP(nlx, nly, w, h) || cell1[nly][nlx] == '#') {\n\t\t\t\t\tnly = q.first.first;\n\t\t\t\t\tnlx = q.first.second;\n\t\t\t\t}\n\t\t\t\tif (!WRAP(nrx, nry, w, h) || cell2[nry][nrx] == '#') {\n\t\t\t\t\tnry = q.second.first;\n\t\t\t\t\tnrx = q.second.second;\n\t\t\t\t}\n\t\t\t\tbool b1 = (nly == gly&&nlx == glx);\n\t\t\t\tbool b2 = (nry == gry&&nrx == grx);\n\t\t\t\tif (b1 != b2)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (G.find({ {nly,nlx },{nry, nrx} }) == G.end()) {\n\t\t\t\t\tG.insert({ { nly,nlx },{ nry, nrx } });\n\t\t\t\t\tQ.push({ { nly,nlx },{ nry,nrx } });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tANS:\n\t\tcout << clear << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp make_pair\n#define pb push_back\n#define F first\n#define S second\n\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nbool app[50][50][50][50];\n\nmain(){\n  int w,h;\n  while(cin>>w>>h,w|h){\n    memset(app,0,6250000);\n    string lr[h],rr[h];\n    rep(i,h){\n      cin>>lr[i]>>rr[i];\n    }\n\n    string ans=\"No\";\n    int rsx,rsy,lsx,lsy;\n    rep(i,h)rep(j,w){\n      if(lr[i][j]=='L')lsx=i,lsy=j;\n      if(rr[i][j]=='R')rsx=i,rsy=j;\n    }\n\n    queue<pair<PI,PI> > Q;\n    Q.push(mp(mp(lsx,lsy),mp(rsx,rsy)));\n\n    while(!Q.empty()){\n      PI tp=Q.front().F;\n      int clx,cly,crx,cry;\n      clx=tp.F,cly=tp.S;\n      tp=Q.front().S;Q.pop();\n      crx=tp.F,cry=tp.S;\n      if(lr[clx][cly]=='%' && rr[crx][cry]=='%'){\n        ans=\"Yes\";\n        break;\n      }\n      if(lr[clx][cly]=='%' || rr[crx][cry]=='%')continue;\n      \n      app[clx][cly][crx][cry]=true;\n\n      rep(i,4){\n        int nrx=crx+dx[i],nlx=clx+dx[i],nry=cry+dy[i],nly=cly-dy[i];\n        if(nrx<0 || nry<0 || nrx>=h || nry>=w || rr[nrx][nry]=='#')nrx=crx,nry=cry;\n        if(nlx<0 || nly<0 || nlx>=h || nly>=w || lr[nlx][nly]=='#')nlx=clx,nly=cly;\n        if(app[nlx][nly][nrx][nry])continue;\n        app[nlx][nly][nrx][nry]=true;\n        Q.push(mp(mp(nlx,nly),mp(nrx,nry)));\n      }\n/*      \n      rep(i,h){\n        rep(j,w){\n          if(clx==i && cly==j)cout<<'L';\n          else if(lr[i][j]=='L')cout<<'.';\n          else cout<<lr[i][j];\n        }\n        cout<<\" \";\n        rep(j,w){\n          if(crx==i && cry==j)cout<<'R';\n          else if(rr[i][j]=='R')cout<<'.';\n          else cout<<rr[i][j];\n        }\n        cout<<endl;\n      }\n      cout<<endl;\n*/\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\nbool used[51][51][51][51];\nint roomL[51][51], roomR[51][51];\n\ninline int s_to_i(char c) {\n  switch (c) {\n  case '#':\n    return -1;\n  case '.':\n    return 0;\n  case 'L':\n  case 'R':\n    return 1;\n  case '%':\n    return 2;\n  }\n}\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while (true) {\n    int R, C;\n    cin >> C >> R;\n    if (R == 0 && C == 0) break;\n    REP(i, R) {\n      string rowL, rowR;\n      cin >> rowL >> rowR;\n      REP(j, C) {\n\troomL[i][j] = s_to_i(rowL[j]);\n\troomR[i][j] = s_to_i(rowR[j]);\n      }\n    }\t  \n\n    int slr = 0, slc = 0, elr = 0, elc = 0, srr = 0, src = 0, err = 0, erc = 0;\n    REP(r, R) REP(c, C) {\n      if (roomL[r][c] == 1) slr = r, slc = c;\n      else if (roomL[r][c] == 2) elr = r, elc = c;\n      if (roomR[r][c] == 1) srr = r, src = c;\n      else if (roomR[r][c] == 2) err = r, erc = c;\n    }\n    //cout << slr << ' ' << slc << ' ' << elr << ' ' << elc << ' ' << srr << ' ' << src << ' ' << err << ' ' << erc << endl;\n    REP(i, R) REP(j, C) REP(k, R) REP(l, C) used[i][j][k][l] = false;\n    \n    queue<P> que;\n    que.push(P(slr * C + slc, srr * C + src));\n\n    bool flag = false;\n    while (!que.empty()) {\n      P p = que.front(); que.pop();\n      int lr = p.first / C, lc = p.first % C, rr = p.second / C, rc = p.second % C;\n      //cout << lr << ' ' << lc << ' ' << rr << ' ' << rc << endl;\n      if (lr == elr && lc == elc && rr == err && rc == erc) {\n\tflag = true;\n\tbreak;\n      } else if (used[lr][lc][rr][rc] || (lr == elr && lc == elc) || (rr == err && rc == erc)) {\n\tcontinue;\n      }\n\n      used[lr][lc][rr][rc] = true;\n      REP(i, 4) {\n\tint nlr = lr + dr[i], nlc = lc + dc[i], nrr = rr + dr[(i+2*(i&1))%4], nrc = rc + dc[(i+2*(i&1))%4];\n\tif (nlr < 0 || nlr >= R || nlc < 0 || nlc >= C || roomL[nlr][nlc] == -1) nlr = lr, nlc = lc;\n\tif (nrr < 0 || nrr >= R || nrc < 0 || nrc >= C || roomR[nrr][nrc] == -1) nrr = rr, nrc = rc;\n\tif (!used[nlr][nlc][nrr][nrc]) que.push(P(nlr * C + nlc, nrr * C + nrc));\n      }\n    }\n    cout << (flag ? \"Yes\" : \"No\") << endl;    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Mirror Cave\n//Level: 3\n//Category: シミュレーション,幅優先探索,BFS\n//Note:\n\n/*\n * [Lの位置][Rの位置]を状態にして幅優先探索する。\n */\n#include <iostream>\n#include <string>\n#include <queue>\n \nusing namespace std;\n \nconst int dr[] = {0, -1, 0, 1};\nconst int dc[][4] = {\n    {1, 0, -1, 0},\n    {-1, 0, 1, 0}\n};\n\ninline bool in_range(int a, int x, int b) {\n    return a <= x && x < b;\n}\n\nint hash(const pair<int,int> &p) {\n    return p.first*50 + p.second;\n}\n\npair<int,int> unhash(int n) {\n    return make_pair(n/50, n%50);\n}\n\nstruct Tag {\n    pair<int,int> pos[2];\n\n    Tag() {}\n    Tag(pair<int,int> *pa) {\n        pos[0] = pa[0];\n        pos[1] = pa[1];\n    }\n\n    void get(pair<int,int> *pa) const {\n        pa[0] = pos[0];\n        pa[1] = pos[1];\n    }\n};\n\nbool solve() {\n    int W, H;\n    cin >> W >> H;\n    if(!W && !H) return false;\n\n    vector<string> field[2];\n    pair<int,int> starts[2];\n    for(int r = 0; r < H; ++r) {\n        string a, b;\n        cin >> a >> b;\n        field[0].push_back(a);\n        field[1].push_back(b);\n    }\n    for(int i = 0; i < 2; ++i) {\n        for(int r = 0; r < H; ++r) {\n            for(int c = 0; c < W; ++c) {\n                if(field[i][r][c] == \"LR\"[i]) {\n                    starts[i] = make_pair(r, c);\n                    field[i][r][c] = '.';\n                }\n            }\n        }\n    }\n\n    queue<Tag> q;\n    vector<vector<unsigned char> > memo(2500, vector<unsigned char>(2500, 0));\n    memo[hash(starts[0])][hash(starts[1])] = 1;\n    q.push(starts);\n    bool ans = false;\n    while(!q.empty()) {\n        const Tag t = q.front();\n        //cout << t.pos[0].first << ' ' << t.pos[0].second << ' ';\n        //cout << t.pos[1].first << ' ' << t.pos[1].second << endl;\n        q.pop();\n\n        for(int dir = 0; dir < 4; ++dir) {\n            pair<int,int> np[2];\n            t.get(np);\n            int goalcnt = 0;\n            for(int i = 0; i < 2; ++i) {\n                int nr = np[i].first + dr[dir];\n                int nc = np[i].second + dc[i][dir];\n                if(in_range(0, nr, H) && in_range(0, nc, W)) {\n                    switch(field[i][nr][nc]) {\n                        case '#':\n                            nr = np[i].first;\n                            nc = np[i].second;\n                            break;\n                        case '%':\n                            goalcnt++;\n                            break;\n                    }\n                } else {\n                    nr = np[i].first;\n                    nc = np[i].second;\n                }\n                np[i] = make_pair(nr, nc);\n            }\n            if(goalcnt == 2) {\n                ans = true;\n                goto end;\n            } else if(goalcnt == 0) {\n                const int h1 = hash(np[0]);\n                const int h2 = hash(np[1]);\n                if(!memo[h1][h2]) {\n                    memo[h1][h2] = 1;\n                    q.push(Tag(np));\n                }\n            }\n        }\n    }\nend:\n    cout << (ans ? \"Yes\" : \"No\") << endl;\n    return true;\n}\n \nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n     \n    for(; solve(); ) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\nint const dxL[] = {-1,0,1,0};\nint const dxR[] = {1,0,-1,0};\nint const dy[]  = {0,-1,0,1};\ntypedef pair<int, int> Pii;\n#define X first\n#define Y second\nint const INF = 1<<28;\nint W, H;\nchar grL[51][51], grR[51][51];\nint dist[300][300];\ninline bool isValid(int x, int y) {\n  if(0<=x&&x<W && 0<=y&&y<H) return true;\n  else return false;\n}\n\ninline bool inF(int x, int y, int isL) {\n  if(isL) return grL[y][x]!='#';\n  return grR[y][x]!='#';\n}\ninline int toNode(int x, int y) {\n  return y*W+x;\n}\ninline void toPos(int node, int &x, int &y) {\n  x = node%W, y = node/W;\n}\nint main() {\n  \n  while(cin >> W >> H && (W|H)) {\n    int sxL, syL, sxR, syR;\n    int gxL, gyL, gxR, gyR;\n    for(int i=0; i<H; i++) {\n      for(int j=0; j<2*W; j++) {\n        if(j<W) {\n          cin >> grL[i][j];\n          if(grL[i][j] == 'L') {\n            sxL = j, syL = i;\n          }\n          if(grL[i][j] == '%') {\n            gxL = j, gyL = i;\n          }\n        }\n        else {\n          cin >> grR[i][j-W];\n          if(grR[i][j-W] == 'R') {\n            sxR = j-W, syR = i;\n          }\n          if(grR[i][j-W] == '%') {\n            gxR = j-W, gyR = i;\n          }\n        }\n      }\n    }\n    \n    queue<int> qL, qR;\n    qL.push(toNode(sxL, syL)); qR.push(toNode(sxR, syR));\n    bool ok = false;\n    fill(dist[0], dist[0]+300*300, INF);\n    dist[toNode(sxL, syL)][toNode(sxR, syR)] = 0;\n    while(!qL.empty()) {\n      int nowL = qL.front(); qL.pop();\n      int nowR = qR.front(); qR.pop();\n      int lx, ly; toPos(nowL, lx, ly);\n      int rx, ry; toPos(nowR, rx, ry);\n      if(lx == gxL && ly == gyL && rx == gxR && ry == gyR) {\n        ok = true; break;\n      }\n      if(lx == gxL && ly == gyL) {\n        continue;\n      }\n      if(rx == gxR && ry == gyR) {\n        continue;\n      }\n      for(int i=0; i<4; i++) {\n        int nxL = lx+dxL[i], nyL = ly+dy[i];\n        int nxR = rx+dxR[i], nyR = ry+dy[i];\n        if(!isValid(nxL, nyL) || !isValid(nxR, nyR)) continue;\n        if(!inF(nxL, nyL, 1) && !inF(nxR, nyR, 0)) continue;\n        if(!inF(nxL, nyL, 1)) { nxL = lx, nyL = ly; }\n        if(!inF(nxR, nyR, 0)) { nxR = rx, nyR = ry; }\n        if(dist[toNode(nxL, nyL)][toNode(nxR, nyR)] != INF) continue;\n        qL.push(toNode(nxL, nyL));\n        qR.push(toNode(nxR, nyR));\n        dist[toNode(nxL, nyL)][toNode(nxR, nyR)] = dist[nowL][nowR]+1;\n      }\n    }\n    if(ok) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint range(int a,int b,int h, int w){\n\treturn a >= 0 && a < h && b >= 0 && b < w;\n}\n\nP lg, rg;\nint dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0}, h, w;\nint f[50][50][50][51];\nchar lf[50][51],rf[50][51]; \n\nint dfs(int ly,int lx,int ry,int rx){\n\tint i;\n\tif(lg.first == ly && lg.second == lx || rg.first == ry && rg.second == rx){\n\t\tif(lg.first == ly && lg.second == lx && rg.first == ry && rg.second == rx)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tfor(i = 0;i < 4;i++){\n\t\tif(range(ly + dy[i],lx + dx[i],h,w) && range(ry + dy[i],rx - dx[i],h,w)){\n\t\t\tif(lf[ly + dy[i]][lx + dx[i]] != '#' && rf[ry + dy[i]][rx - dx[i]] != '#' && f[ly + dy[i]][lx + dx[i]][ry + dy[i]][rx - dx[i]]){\n\t\t\t\tf[ly + dy[i]][lx + dx[i]][ry + dy[i]][rx - dx[i]] = 0;\n\t\t\t\tif(dfs(ly + dy[i],lx + dx[i],ry + dy[i],rx - dx[i])) return 1;\n\t\t\t}\n\t\t\telse if(lf[ly + dy[i]][lx + dx[i]] != '#' && rf[ry + dy[i]][rx - dx[i]] == '#' && f[ly + dy[i]][lx + dx[i]][ry][rx]){\n\t\t\t\tf[ly + dy[i]][lx + dx[i]][ry][rx] = 0;\n\t\t\t\tif(dfs(ly + dy[i],lx + dx[i],ry,rx)) return 1;\n\t\t\t}\n\t\t\telse if(lf[ly + dy[i]][lx + dx[i]] == '#' && rf[ry + dy[i]][rx - dx[i]] != '#' && f[ly][lx][ry + dy[i]][rx - dx[i]]){\n\t\t\t\tf[ly][lx][ry + dy[i]][rx - dx[i]] = 0;\n\t\t\t\tif(dfs(ly,lx,ry + dy[i],rx - dx[i])) return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(void){\n\tint i, j;\n\tP rs, ls;\n\twhile(1){\n\t\tscanf(\"%d%d%*c\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tlf[i][j] = getchar();\n\t\t\t\tif(lf[i][j] == 'L'){\n\t\t\t\t\tls = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(lf[i][j] == '%'){\n\t\t\t\t\tlg = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 空白読み飛ばし\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\trf[i][j] = getchar();\n\t\t\t\tif(rf[i][j] == 'R'){\n\t\t\t\t\trs = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(rf[i][j] == '%'){\n\t\t\t\t\trg = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 改行文字読み飛ばし\n\t\t}\n\t\tmemset(f,-1,sizeof(f));\n\t\tf[ls.first][ls.second][rs.first][rs.second] = 0;\n\t\tprintf(\"%d %d %d %d\\n\",ls.second,ls.first,rs.second,rs.first);\n\t\tif(dfs(ls.first,ls.second,rs.first,rs.second))\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> stat;\n\nint w, h;\nbool vis[51][51][51][51];\npii ls, lg, rs, rg;\nstat start, goal;\n\nint dx[]={0, 0, 1, -1}, dy[]={1, -1, 0, 0};\n\nbool border(pii p){\n\t\n\treturn 0<=p.first&&p.first<w&&0<=p.second&&p.second<h;\n}\n\nstring solve(const vector<string> &left, const vector<string> &right){\n\t\n\tstart = make_pair(ls, rs);\n\tgoal = make_pair(lg, rg);\n\t\n\tqueue<stat> qu;\n\tmemset(vis, 0, sizeof(vis));\n\t\n\tvis[ls.first][ls.second][ls.first][ls.second] = true;\n\tqu.push(start);\n\t\n\twhile(!qu.empty()){\n\t\n\t\tpii lnx, rnx, lnw, rnw;\n\t\tstat now = qu.front();\n\t\tlnw = now.first;\n\t\trnw = now.second;\n\t\tqu.pop();\n\t\t\n\t\tfor(int i=0; i<4; ++i){\n\t\t\t\t\n\t\t\tlnx = make_pair(lnw.first + dx[i], \n\t\t\t\t\t\t\tlnw.second + dy[i]);\n\t\t\t\n\t\t\trnx = make_pair(rnw.first - dx[i], \n\t\t\t\t\t\t\trnw.second + dy[i]);\n\t\t\t\n\t\t\tif(!border(lnx)||left[lnx.second][lnx.first]=='#')\n\t\t\t\tlnx = lnw;\n\t\t\t\n\t\t\tif(!border(rnx)||right[rnx.second][rnx.first]=='#')\n\t\t\t\trnx = rnw;\n\t\t\t\n\t\t\tstat nx = make_pair(lnx, rnx);\n\t\t\t\n\t\t\tif(nx == goal)\n\t\t\t\treturn \"Yes\";\n\t\t\t\n\t\t\tif(!vis[lnx.first][lnx.second][rnx.first][rnx.second]){\n\t\t\t\t\n\t\t\t\tvis[lnx.first][lnx.second][rnx.first][rnx.second] = true;\n\t\t\t\tqu.push(nx);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn \"No\";\n}\n\t\nint main(){\n\t\n\twhile(cin>>w>>h, (w||h)){\n\t\t\n\t\tvector<string> left, right;\n\t\t\n\t\tfor(int i=0; i<h; ++i){\n\t\t\t\n\t\t\tstring l, r;\n\t\t\tcin >> l >> r;\n\t\t\t\n\t\t\tleft.push_back(l);\n\t\t\tright.push_back(r);\n\t\t}\n\t\t\n\t\tfor(int y=0; y<h; ++y){\n\t\t\tfor(int x=0; x<w; ++x){\n\t\t\t\n\t\t\t\tif(left[y][x] == 'L')\n\t\t\t\t\tls = make_pair(x, y);\n\t\t\t\tif(left[y][x] == '%')\n\t\t\t\t\tlg = make_pair(x, y);\n\t\t\t\tif(right[y][x] == 'R')\n\t\t\t\t\trs = make_pair(x, y);\n\t\t\t\tif(right[y][x] == '%')\n\t\t\t\t\trg = make_pair(x, y);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout <<\tsolve(left, right) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\nchar fieldL[51][51];\nchar fieldR[51][51];\n\nbool isArrival[51][51][51][51];\nint h,w;\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\n\nvoid bfs(int slx,int sly,int srx,int sry){\n\tqueue<pair<int,int> > *prvL=new queue<pair<int,int> >();\n\tqueue<pair<int,int> > *nxtL=new queue<pair<int,int> >();\n\tqueue<pair<int,int> > *prvR=new queue<pair<int,int> >();\n\tqueue<pair<int,int> > *nxtR=new queue<pair<int,int> >();\n\tprvL->push(make_pair(sly,slx));\n\tprvR->push(make_pair(sry,srx));\n\twhile(prvL->size()){\n\t\twhile(prvL->size()){\n\t\t\tpair<int,int> pl=prvL->front();prvL->pop();\n\t\t\tpair<int,int> pr=prvR->front();prvR->pop();\n\t\t\tint ly=pl.first;int lx=pl.second;\n\t\t\tint ry=pr.first;int rx=pr.second;\n\t\t\tif(isArrival[ly][lx][ry][rx])\n\t\t\t\tcontinue;\n\t\t\tisArrival[ly][lx][ry][rx]=true;\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint nly=max(0,min(h-1,ly+dy[i]));\n\t\t\t\tint nlx=max(0,min(w-1,lx+dx[i]));\n\t\t\t\tint nry=max(0,min(h-1,ry+dy[i]));\n\t\t\t\tint nrx=max(0,min(w-1,rx-dx[i]));\n\t\t\t\tif(fieldL[nly][nlx]=='#'){\n\t\t\t\t\tnly=ly;\n\t\t\t\t\tnlx=lx;\n\t\t\t\t}\n\t\t\t\tif(fieldR[nry][nrx]=='#'){\n\t\t\t\t\tnry=ry;\n\t\t\t\t\tnrx=rx;\n\t\t\t\t}\n\t\t\t\tif(!isArrival[nly][nlx][nry][nrx]){\n\t\t\t\t\tnxtL->push(make_pair(nly,nlx));\n\t\t\t\t\tnxtR->push(make_pair(nry,nrx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(prvL,nxtL);\n\t\tswap(prvR,nxtR);\n\t}\n\tdelete prvL,prvR,nxtL,nxtR;\n}\n\nint main(){\n\twhile(cin>>w>>h&&!(w==0&&h==0)){\n\t\tmemset(isArrival,0,sizeof(isArrival));\n\t\tint sly,slx,srx,sry;\n\t\tint fly,flx,frx,fry;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>fieldL[i][j];\n\t\t\t\tif(fieldL[i][j]=='L'){\n\t\t\t\t\tfieldL[i][j]='.';\n\t\t\t\t\tsly=i;\n\t\t\t\t\tslx=j;\n\t\t\t\t}\n\t\t\t\telse if(fieldL[i][j]=='%'){\n\t\t\t\t\tfieldL[i][j]='.';\n\t\t\t\t\tfly=i;\n\t\t\t\t\tflx=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>fieldR[i][j];\n\t\t\t\tif(fieldR[i][j]=='R'){\n\t\t\t\t\tfieldR[i][j]='.';\n\t\t\t\t\tsry=i;\n\t\t\t\t\tsrx=j;\n\t\t\t\t}\n\t\t\t\telse if(fieldR[i][j]=='%'){\n\t\t\t\t\tfieldR[i][j]='.';\n\t\t\t\t\tfry=i;\n\t\t\t\t\tfrx=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbfs(slx,sly,srx,sry);\n\t\tif(isArrival[fly][flx][fry][frx])\n\t\t\tcout<<\"Yes\"<<endl;\n\t\telse\n\t\t\tcout<<\"No\"<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define abs(a) max((a),-(a))\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define repe(i,n) rep(i,(n)+1)\n#define per(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define pere(i,n) rep(i,(n)+1)\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define RET return 0\n#define MOD 1000000007\n#define INF 1000000000000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nbool ok[50][50][50][50];\nint main(){\n  while(1){\n    int h,w;\n    cin >> w >> h;\n    if(h==0) return 0;\n    vector<string> l(h),r(h);\n    for(int i=0;i<h;i++) cin >> l[i] >> r[i];\n    for(int i=0;i<h;i++) reverse(all(r[i]));\n    int lsx,lsy,lgx,lgy,rsx,rsy,rgx,rgy;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        if(l[i][j]=='L'){\n          lsy=i,lsx=j;\n          l[i][j]='.';\n        }else if(l[i][j]=='%'){\n          lgy=i,lgx=j;\n          l[i][j]='.';\n        }\n        if(r[i][j]=='R'){\n          rsy=i,rsx=j;\n          l[i][j]='.';\n        }else if(r[i][j]=='%'){\n          rgy=i,rgx=j;\n          r[i][j]='.';\n        }\n      }\n    }\n    queue<pair<pair<int,int>,pair<int,int>>> bfs;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        for(int k=0;k<h;k++){\n          for(int l=0;l<w;l++){\n            ok[i][j][k][l]=false;\n          }\n        }\n      }\n    }\n    bfs.push({{lsx,lsy},{rsx,rsy}});\n    ok[lsy][lsx][rsy][rsx]=true;\n    vector<int> vx={1,0,-1,0},vy={0,-1,0,1};\n    int lnx,lny,rnx,rny;\n    pair<pair<int,int>,pair<int,int>> now;\n    while(!bfs.empty()){\n      now=bfs.front();\n      bfs.pop();\n      for(int i=0;i<4;i++){\n        lnx=now.first.first+vx[i];\n        lny=now.first.second+vy[i];\n        rnx=now.second.first+vx[i];\n        rny=now.second.second+vy[i];\n        if(0<=lnx&&lnx<w&&0<=lny&&lny<h){\n          if(l[lny][lnx]=='#'){\n            lnx=now.first.first;\n            lny=now.first.second;\n          }\n        }else{\n          lnx=now.first.first;\n          lny=now.first.second;\n        }\n        if(0<=rnx&&rnx<w&&0<=rny&&rny<h){\n          if(r[rny][rnx]=='#'){\n            rnx=now.second.first;\n            rny=now.second.second;\n          }\n        }else{\n          rnx=now.second.first;\n          rny=now.second.second;\n        }\n        if(!ok[lny][lnx][rny][rnx]){\n          ok[lny][lnx][rny][rnx]=true;\n          if((!(lnx==lgx&&lny==lgy))&&(!(rnx==rgx&&rny==rgy))) bfs.push({{lnx,lny},{rnx,rny}});\n        }\n      }\n    }\n    if(ok[lgy][lgx][rgy][rgx]) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nstruct Data{int x[2],y[2];};\nData start,goal;\n\nint W,H;\nchar room[2][50][50];\n\nint dx[2][4]={{0,1,0,-1}, {0,-1,0,1}};\nint dy[2][4]={{-1,0,1,0}, {-1,0,1,0}};\nbool operator==(Data a, Data b){\n  return a.x[0]==b.x[0] && a.x[1]==b.x[1] && a.y[0]==b.y[0] && a.y[1]==b.y[1];\n}\nbool over(Data a){\n  return a.x[0]<0 || W<=a.x[0] || a.y[0]<0 || H<=a.y[0] ||\n         a.x[1]<0 || W<=a.x[1] || a.y[1]<0 || H<=a.y[1];\n}\n\nbool bfs()\n{\n  queue<Data>q;\n  q.push(start);\n  bool visited[50][50][50][50]={false};\n\n  while(!q.empty()){\n    Data now=q.front();\n    q.pop();\n\n    visited[now.x[0]][now.y[0]][now.x[1]][now.y[1]]=true;\n\n    if(now==goal)return true;\n    if(now.x[0]==goal.x[0] && now.y[0]==goal.y[0])continue;\n    if(now.x[1]==goal.x[1] && now.y[1]==goal.y[1])continue;\n\n    for(int i=0;i<4;i++){\n      Data next=now;\n      for(int j=0;j<2;j++){\n\tnext.x[j]+=dx[j][i];\n\tnext.y[j]+=dy[j][i];\n\tif(over(next) || room[j][next.y[j]][next.x[j]]=='#'){\n\t  next.x[j]=now.x[j];\n\t  next.y[j]=now.y[j];\n\t}\n      }\n      if(visited[next.x[0]][next.y[0]][next.x[1]][next.y[1]])continue;\n      q.push(next);\n    }\n  }\n\n  return false;\n}\n\nint main()\n{\n  while(cin>>W>>H,W|H){\n    for(int i=0;i<H;i++){\n      cin>>room[0][i]>>room[1][i];\n      for(int j=0;j<W;j++){\n\tif(room[0][i][j]=='L'){\n\t  start.x[0]=j;\n\t  start.y[0]=i;\n\t}\n\tif(room[1][i][j]=='R'){\n\t  start.x[1]=j;\n\t  start.y[1]=i;\n\t}\n\tif(room[0][i][j]=='%'){\n\t  goal.x[0]=j;\n\t  goal.y[0]=i;\n\t}\n\tif(room[1][i][j]=='%'){\n\t  goal.x[1]=j;\n\t  goal.y[1]=i;\n\t}\n      }\n    }\n\n    puts(bfs()?\"Yes\":\"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\n#define LX zahyou[0][0]\n#define LY zahyou[0][1]\n#define RX zahyou[1][0]\n#define RY zahyou[1][1]\n#define RROOM room[0][LY][LX]\n#define LROOM room[1][RY][RX]\n#define DINU for(int i = 0; i < 2; i++){temp[i][0] = zahyou[i][0]; temp[i][1] = zahyou[i][1];}\n\nint W, H;\n\n\nint foo(char room[2][60][60], int zahyou[2][2]) {\n\tint temp[2][2];\n\tif ((LX < 1 || LX > W) || (RX < 1 || RX > W) || (LY < 1 || LY > H) || (RY < 1 || RY > H)) return 0;\n\tif (RROOM == 'X' && LROOM == 'X') return 0;\n\tif (RROOM == '%' && LROOM == '%') return 1;\n\tif (RROOM == '%' || LROOM == '%')return 0;\n\t RROOM = 'X'; LROOM = 'X';\n\n\n\tDINU\n\n\tif (room[0][LY + 1][LX] != '#') temp[0][1] = LY + 1;\n\tif (room[1][RY + 1][RX] != '#') temp[1][1] = RY + 1;\n\tif (foo(room, temp))return 1;\n\n\tDINU\n\n\tif (room[0][LY - 1][LX] != '#') temp[0][1] = LY - 1;\n\tif (room[1][RY - 1][RX] != '#') temp[1][1] = RY - 1;\n\tif (foo(room, temp))return 1;\n\n\tDINU\n\n\tif (room[0][LY][LX + 1] != '#') temp[0][0] = LX + 1;\n\tif (room[1][RY][RX - 1] != '#') temp[1][0] = RX - 1;\n\tif (foo(room, temp))return 1;\n\n\tDINU\n\n\tif (room[0][LY][LX - 1] != '#') temp[0][0] = LX - 1;\n\tif (room[1][RY][RX + 1] != '#') temp[1][0] = RX + 1;\n\tif (foo(room, temp))return 1;\n\n\n\treturn 0;\n}\n\n\n\nint main() {\n\tstring temp1, temp2;\n\tint zahyou[2][2];\n\n\twhile (1) {\n\t\tchar room[2][60][60] = {};\n\t\tcin >> W >> H;\n\t\tif (W == 0 && H == 0) break;\n\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tcin >> temp1>>temp2;\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\troom[0][i][j] = temp1[j-1];\n\t\t\t\tif (room[0][i][j] == 'L') {\n\t\t\t\t\tLX = j;\n\t\t\t\t\tLY = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\troom[1][i][j] = temp2[j-1];\n\t\t\t\tif (room[1][i][j] == 'R') {\n\t\t\t\t\tRX = j;\n\t\t\t\t\tRY = i;\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t}\n\n\t\tif (foo(room, zahyou)) cout << \"Yes\" << endl;\n\t\telse cout <<\"No\"<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\nusing namespace std;\nstring s1[50],s2[50];\nint dx1[]={1,-1,0,0,},dy1[]={0,0,1,-1};\nint dx2[]={-1,1,0,0,},dy2[]={0,0,1,-1};\nint w,h,gx1,gx2,gy1,gy2;\nunordered_set<int>s;\nbool bfs(int x1,int y1,int x2,int y2){\n  queue<int>q;\n  q.push(x1+y1*100+x2*10000+y2*1000000);\n  while(!q.empty()){\n    int p=q.front();q.pop();\n    x1=p%100;y1=p%10000/100;\n    x2=p%1000000/10000;y2=p/1000000;\n    for(int i=0;i<4;i++){\n      int x3=x1+dx1[i],y3=y1+dy1[i];\n      int x4=x2+dx2[i],y4=y2+dy2[i];\n      if(x3>=0&&x4>=0&&y3>=0&&y4>=0)\n        if(x3<w&&x4<w&&y3<h&&y4<h){\n          if(s1[y3][x3]=='#')y3=y1,x3=x1;\n          if(s2[y4][x4]=='#')y4=y2,x4=x2;\n          if(x1==gx1&&y1==gy1&&x2==gx2&&y2==gy2)return 1;\n          if(!(x3==gx1&&y3==gy1&&(x4!=gx2||y4!=gy2)))\n          if(!((x3!=gx1||y3!=gy1)&&x4==gx2&&y4==gy2))\n          if(!s.count(x3+y3*100+x4*10000+y4*1000000)){\n            s.insert(x3+y3*100+x4*10000+y4*1000000);\n            q.push(x3+y3*100+x4*10000+y4*1000000);\n          }\n        }\n      }\n    }\n    return 0;\n}\nint main(){\n  int x1,y1,x2,y2;\n  while(cin>>w>>h,w){\n    s.clear();\n    r(i,h)cin>>s1[i]>>s2[i];\n    r(i,h)r(j,w){\n      if(s1[i][j]=='L')x1=j,y1=i;\n      if(s2[i][j]=='R')x2=j,y2=i;\n      if(s1[i][j]=='%')gx1=j,gy1=i;\n      if(s2[i][j]=='%')gx2=j,gy2=i;\n    }\n    s.insert(x1+y1*100+x2*10000+y2*1000000);\n    if(bfs(x1,y1,x2,y2))cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <map>\n#include <algorithm>\n#define fr first\n#define sc second\nusing namespace std;\n\n// first:x, second:y\ntypedef pair<int, int> iP;\ntypedef pair<iP, iP> iiiP;\n\niP sR, sL;\nint h, w, used[50][50][50][50];\nint dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\nchar mapR[51][51], mapL[51][51];\nbool judge;\n\nvoid bfs(){\n  queue <iiiP> que;\n  que.push(iiiP(sL, sR));\n  used[sL.fr][sL.sc][sR.fr][sR.sc] = 1;\n  while(!que.empty()){\n    iiiP p = que.front(); que.pop();\n    for(int i = 0; i < 4; i++){\n      int Lnx = min(w-1, max(0, p.fr.fr + dx[i]));\n      int Lny = min(h-1, max(0, p.fr.sc + dy[i]));\n      int Rnx = min(w-1, max(0, p.sc.fr - dx[i]));\n      int Rny = min(h-1, max(0, p.sc.sc + dy[i]));\n      \n      if(mapL[Lny][Lnx] == '%' && mapR[Rny][Rnx] == '%'){ judge = true; break; }\n      if(mapL[Lny][Lnx] == '#') Lnx = p.fr.fr, Lny = p.fr.sc;\n      if(mapR[Rny][Rnx] == '#') Rnx = p.sc.fr, Rny = p.sc.sc;\n      if(!used[Lny][Lnx][Rny][Rnx]){\n\tque.push(iiiP(iP(Lnx, Lny), iP(Rnx, Rny)));\n\tused[Lny][Lnx][Rny][Rnx] = 1;\n      }\n    }\n  }\n}\n\nint main(){\n  \n  while(cin >> w >> h, w){\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n\tcin >> mapL[i][j];\n\tif(mapL[i][j] == 'L'){\n\t  mapL[i][j] = '.'; sL.fr = j, sL.sc = i;\n\t}\n      }\n      \n      for(int j = 0; j < w; j++){\n\tcin >> mapR[i][j];\n\tif(mapR[i][j] == 'R'){\n\t  mapR[i][j] = '.'; sR.fr = j, sR.sc = i;\n\t}\n      }\n    }\n\n    judge = false;\n    memset(used, 0, sizeof(used));\n    bfs();\n    if(judge) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n\n\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<n;++i)\n#define FOR(i, a, b) for(int i=a;i<b;++i)\n#define RREP(i, n) for(int i=n-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=b-1;i>=a;--i)\n\n#define all(x) begin(x),end(x)\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> p) {\n    os << p.first << \":\" << p.second;\n    return os;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<class T1, class T2>\nostream &operator<<(ostream &os, const map<T1, T2> &mp) {\n    os << \"[\";\n    for (auto it = mp.begin(); it != mp.end(); ++it) {\n        if (it != mp.begin()) {\n            os << \", \";\n        }\n        os << *it;\n    }\n    return os << \"]\";\n}\n\n// edit\n\nvoid inner(int L, int &M, int R) {\n    if (L > M) M = L;\n    if (R < M) M = R;\n}\n\nbool solve() {\n    int H, W;\n    cin >> W >> H;\n    if (W == 0 && H == 0) return false;\n\n    vector<string> fieldL(H), fieldR(H);\n\n    REP(i, H) {\n        cin >> fieldL[i] >> fieldR[i];\n    }\n\n    int sLh, sLw, sRh, sRw;\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (fieldL[i][j] == 'L') {\n                sLh = i;\n                sLw = j;\n            }\n\n            if (fieldR[i][j] == 'R') {\n                sRh = i;\n                sRw = j;\n            }\n        }\n    }\n\n    using tup = tuple<int, int, int, int>;\n    queue<tup> que;\n    que.push(tup(sLh, sLw, sRh, sRw));\n\n    bool used[50][50][50][50] = {};\n    used[sLh][sLw][sRh][sRw] = true;\n\n    while (!que.empty()) {\n        int dh[] = {0, -1, 0, 1};\n        int dLw[] = {1, 0, -1, 0};\n        int dRw[] = {-1, 0, 1, 0};\n        int Lh, Lw, Rh, Rw;\n        tie(Lh, Lw, Rh, Rw) = que.front();\n        que.pop();\n        if (fieldL[Lh][Lw] == '%' && fieldR[Rh][Rw] == '%') {\n            cout << \"Yes\" << endl;\n            return true;\n        } else if (fieldL[Lh][Lw] == '%' || fieldR[Rh][Rw] == '%') {\n            continue;\n        }\n\n        for (int k = 0; k < 4; ++k) {\n            int nLh = Lh + dh[k];\n            int nLw = Lw + dLw[k];\n            int nRh = Rh + dh[k];\n            int nRw = Rw + dRw[k];\n            inner(0, nLh, H - 1);\n            inner(0, nLw, W - 1);\n            inner(0, nRh, H - 1);\n            inner(0, nRw, W - 1);\n            if (fieldL[nLh][nLw] == '#') {\n                nLh = Lh;\n                nLw = Lw;\n            }\n            if (fieldR[nRh][nRw] == '#') {\n                nRh = Rh;\n                nRw = Rw;\n            }\n            if (!used[nLh][nLw][nRh][nRw]) {\n                used[nLh][nLw][nRh][nRw] = true;\n                que.push(tup(nLh, nLw, nRh, nRw));\n            }\n        }\n    }\n\n    cout << \"No\" << endl;\n    return true;\n}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n//    std::ifstream in(\"input.txt\");\n//    std::cin.rdbuf(in.rdbuf());\n\n    while (solve());\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint W, H;\nbool memo[51][51][51][51];\nstring grid1[51];\nstring grid2[51];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nstruct S{\n  int x1, y1, x2, y2;\n  S(int x1, int y1, int x2, int y2) :\n    x1(x1), y1(y1), x2(x2), y2(y2) {}\n};\nbool valid1(int x, int y){\n  return (x >= 0 && y >= 0 && x < W && y < H && grid1[y][x] != '#');\n}\nbool valid2(int x, int y){\n  return (x >= 0 && y >= 0 && x < W && y < H && grid2[y][x] != '#');\n}\nint main(){\n  while(cin>>W>>H && W){\n    REP(i, H)cin>> grid1[i] >> grid2[i];\n    memset(memo, 0, sizeof(memo));\n    int x1 = -1, y1 = -1, x2 = -1, y2 = -1;\n    REP(y, H)REP(x, W){\n      if(grid1[y][x] == 'L'){\n        x1 = x; y1 = y;\n      }\n      if(grid2[y][x] == 'R'){\n        x2 = x; y2 = y;\n      }\n    }\n    assert(x1 != -1 && y1 != -1 && x2 != -1 && y2 != -1);\n    queue<S> que;\n    que.push(S(x1, y1, x2, y2));\n    bool ans = false;\n    while(!que.empty()){\n      S s = que.front(); que.pop();\n      if(memo[s.x1][s.y1][s.x2][s.y2]) continue;\n      memo[s.x1][s.y1][s.x2][s.y2] = true;\n      if(grid1[s.y1][s.x1] == '%' && grid2[s.y2][s.x2] == '%') {\n        ans = true;\n        break;\n      }\n      if(grid1[s.y1][s.x1] == '%' || grid2[s.y2][s.x2] == '%'){\n        continue;\n      }\n      REP(r, 4){\n        int nx1 = s.x1, ny1 = s.y1, nx2 = s.x2, ny2 = s.y2;\n        if(valid1(s.x1 + dx[r], s.y1 + dy[r])){\n          nx1 += dx[r]; ny1 += dy[r];\n        }\n        if(valid2(s.x2 - dx[r], s.y2 + dy[r])){\n          nx2 += -dx[r]; ny2 += dy[r];\n        }\n        if(!memo[nx1][ny1][nx2][ny2]) que.push(S(nx1, ny1, nx2, ny2));\n      }\n    }\n    if(ans) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <fstream>\n#include <stack>\n#include <cstring>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, k, n) for (int i = (int)(k); i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rREP(i, k, n) for (int i = (int)(n)-1; i >= k; i--)\n\n#define debug(x) cerr << #x << \": \" << x << endl;\n\n#define fi first\n#define se second\n\n#define vi vector<int>\n#define pii pair<int, int>\n#define pb push_back\n#define mp make_pair\n\n#define pcnt __builtin_popcount\n\ntypedef long long ll;\n\nconst int    inf = 100100100;\n\n\nconst int    dx[4] = { 0, 1, 0, -1 };\nconst int    dy[4] = { 1, 0, -1, 0 };\n\nstruct POINT {\n    int lx;\n    int ly;\n    int rx;\n    int ry;\n};\n\nbool u[55][55][55][55] = {};\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n//    ifstream in(\"in.txt\");\n//    cin.rdbuf(in.rdbuf());\n    int  w, h;\n    char ML[55][55], MR[55][55];\n    int slx,sly,srx,sry;\n    while (cin >> w >> h, w) {\n        memset(u,0,sizeof(u));\n        memset(ML,0,sizeof(ML));\n        memset(MR,0,sizeof(MR));\n\n        rep(y, h) {\n            string sml,smr;\n            cin >> sml >> smr;\n            sml.copy(ML[y],sml.size()+1);\n            smr.copy(MR[y],smr.size()+1);\n\n        }\n        rep(y, h) rep(x,w){\n                if(ML[y][x] == 'L') ML[y][x] = '.',slx = x,sly = y;\n                if(MR[y][x] == 'R') MR[y][x] = '.',srx = x,sry = y;\n            }\n        stack<POINT> st;\n        st.push(POINT{slx, sly, srx, sry});\n\n        bool flag = false;\n        while (!st.empty()) {\n            POINT p = st.top();\n            st.pop();\n\n            rep(i, 4) {\n                int nlx = p.lx + dx[i];\n                int nly = p.ly + dy[i];\n                int nrx = p.rx + dx[(i + 2) % 4];\n                int nry = p.ry + dy[i];\n                bool left_do = true;\n                bool right_do = true;\n                if (nlx < 0 || w <= nlx) left_do = false;\n                if (nly < 0 || h <= nly) left_do = false;\n                if (ML[nly][nlx] == '#') left_do = false;\n                if (nrx < 0 || w <= nrx) right_do = false;\n                if (nry < 0 || h <= nry) right_do = false;\n                if (MR[nry][nrx] == '#') right_do = false;\n                if (ML[nly][nlx] == '%' && MR[nry][nrx] == '%') {\n                    flag = true;\n                    while (!st.empty()) st.pop();\n                    break;\n                } else if (ML[nly][nlx] == '%' || MR[nry][nrx] == '%') {\n                    continue;\n                }\n                if (!left_do && !right_do) continue;\n                if (!left_do) nlx = p.lx, nly = p.ly;\n                if (!right_do) nrx = p.rx, nry = p.ry;\n                if(!u[nlx][nly][nrx][nry]) {\n                    u[nlx][nly][nrx][nry] = true;\n                    st.push(POINT{nlx, nly, nrx, nry});\n                }\n            }\n\n        }\n        if (flag)\n            cout << \"Yes\" << endl;\n        else\n            cout << \"No\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define WRAP(x,y,w,h) (0<=x && x<w && 0<=y && y<h)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h, w) {\n\t\tvector<string> cell1(h);\n\t\tvector<string> cell2(h);\n\t\tint slx, sly, srx, sry;\n\t\tint glx, gly, grx, gry;\n\t\tREP(i, h) {\n\t\t\tcin >> cell1[i] >> cell2[i];\n\t\t\tREP(j, w / 2)\n\t\t\t\tswap(cell2[i][j], cell2[i][w - 1 - j]);\n\t\t\tREP(j, w) {\n\t\t\t\tif (cell1[i][j] == 'L') {\n\t\t\t\t\tsly = i;\n\t\t\t\t\tslx = j;\n\t\t\t\t}\n\t\t\t\tif (cell1[i][j] == '%') {\n\t\t\t\t\tgly = i;\n\t\t\t\t\tglx = j;\n\t\t\t\t}\n\t\t\t\tif (cell2[i][j] == 'R') {\n\t\t\t\t\tsry = i;\n\t\t\t\t\tsrx = j;\n\t\t\t\t}\n\t\t\t\tif (cell2[i][j] == '%') {\n\t\t\t\t\tgry = i;\n\t\t\t\t\tgrx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tset<pair<pair<char,char>, pair<char, char>>> G;\n\t\tG.insert({ {sly,slx},{sry,srx} });\n\t\tqueue<pair<pair<char, char>, pair<char, char>>> Q;\n\t\tQ.push({ { sly,slx },{ sry,srx } });\n\t\tset<pair<pair<char, char>, pair<char, char>>> G2;\n\t\tG2.insert({ { gly,glx },{ gry,grx } });\n\t\tqueue<pair<pair<char, char>, pair<char, char>>> Q2;\n\t\tQ2.push({ { gly,glx },{ sry,grx } });\n\t\tstring clear = \"No\";\n\t\twhile (!Q.empty() && !Q2.empty()) {\n\t\t\tREP(j, 2) {\n\t\t\t\tpair<pair<char, char>, pair<char, char>> q;\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tq = Q.front();Q.pop();\n\t\t\t\t}\n\t\t\t\tif (j == 1) {\n\t\t\t\t\tq = Q2.front();Q2.pop();\n\t\t\t\t}\n\t\t\t\tif ((j == 0 && G2.find(q) != G2.end()) || (j == 1 && G.find(q) != G.end())) {\n\t\t\t\t\tclear = \"Yes\";\n\t\t\t\t\tgoto ANS;\n\t\t\t\t}\n\t\t\t\tREP(i, 4) {\n\t\t\t\t\tint nly = q.first.first + dy[i];\n\t\t\t\t\tint nlx = q.first.second + dx[i];\n\t\t\t\t\tint nry = q.second.first + dy[i];\n\t\t\t\t\tint nrx = q.second.second + dx[i];\n\t\t\t\t\tif (!WRAP(nlx, nly, w, h) || cell1[nly][nlx] == '#') {\n\t\t\t\t\t\tnly = q.first.first;\n\t\t\t\t\t\tnlx = q.first.second;\n\t\t\t\t\t}\n\t\t\t\t\tif (!WRAP(nrx, nry, w, h) || cell2[nry][nrx] == '#') {\n\t\t\t\t\t\tnry = q.second.first;\n\t\t\t\t\t\tnrx = q.second.second;\n\t\t\t\t\t}\n\t\t\t\t\tbool b1 = (nly == gly&&nlx == glx);\n\t\t\t\t\tbool b2 = (nry == gry&&nrx == grx);\n\t\t\t\t\tif (b1 != b2)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (j == 0) {\n\t\t\t\t\t\tif (G.find({ {nly,nlx},{nry,nrx} }) == G.end()) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tG.insert({ { nly,nlx }, { nry,nrx } });\n\t\t\t\t\t\t\tQ.push({ { nly,nlx },{ nry,nrx } });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (G2.find({ { nly,nlx },{ nry,nrx } }) == G2.end()) {\n\t\t\t\t\t\t\tG2.insert({ { nly,nlx },{ nry,nrx } });\n\t\t\t\t\t\t\tQ2.push({ { nly,nlx },{ nry,nrx } });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tANS:\n\t\tcout << clear << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nbool dis[52][52][52][52];\n\ntypedef pair<pair<int, int>, pair<int, int> > status;\n#define LEFT first\n#define RIGHT second\n#define X first\n#define Y second\n\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nint main() {\n  int w, h;\n  while (true) {\n    vector<string> left, right;\n    cin >> w >> h;\n    if (w == 0 && h == 0) break;\n    string block;\n    rep (i, w + 2) block += '#';\n    left.push_back(block);\n    right.push_back(block);\n    rep (i, h) {\n      string str;\n      cin >> str;\n      left.push_back(\"#\" + str + \"#\");\n      cin >> str;\n      right.push_back(\"#\" + str + \"#\");\n    }\n    left.push_back(block);\n    right.push_back(block);\n    memset(dis, 0, sizeof(dis));\n    queue<status> que;\n    int lx, ly, rx, ry;\n    rep (i, left.size()) rep (j, left[0].size()) {\n      if (left[i][j] == 'L') {\n\tlx = j;\n\tly = i;\n      }\n      if (right[i][j] == 'R') {\n\trx = j;\n\try = i;\n      }\n    }\n    status s;\n    s.LEFT.X = lx;\n    s.LEFT.Y = ly;\n    s.RIGHT.X = rx;\n    s.RIGHT.Y = ry;\n    que.push(s);\n    while (!que.empty()) {\n      status now = que.front();\n      que.pop();\n      if (dis[now.LEFT.X][now.LEFT.Y][now.RIGHT.X][now.RIGHT.Y]) {\n\tcontinue;\n      }\n      dis[now.LEFT.X][now.LEFT.Y][now.RIGHT.X][now.RIGHT.Y] = true;\n      rep (i, 4) {\n\tstatus next = now;\n\tnext.LEFT.X += dx[i];\n\tnext.LEFT.Y += dy[i];\n\tnext.RIGHT.X -= dx[i];\n\tnext.RIGHT.Y += dy[i];\n\tif (left[next.LEFT.Y][next.LEFT.X] == '#') {\n\t  next.LEFT.X -= dx[i];\n\t  next.LEFT.Y -= dy[i];\n\t}\n\tif (right[next.RIGHT.Y][next.RIGHT.X] == '#') {\n\t  next.RIGHT.X += dx[i];\n\t  next.RIGHT.Y -= dy[i];\n\t}\n\tif (left[next.LEFT.Y][next.LEFT.X] == '%' && right[next.RIGHT.Y][next.RIGHT.X] == '%') goto aaa;\n\tque.push(next);\n      }\n    }\n    cout << \"No\" << endl;\n    continue;\n  aaa:;\n    cout << \"Yes\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<pair<int, int>, pair<int, int>> PPIIII;\n\nint dx[] = { 1,0,-1,0 };\nint dy[] = { 0,1,0,-1 };\n\nvoid solve( int W, int H ) {\n\tpair<int, int> startR, startL, goalR, goalL;\n\tvector<vector<vector<vector<bool>>>>dp( H + 2, vector<vector<vector<bool>>>( W + 2, vector<vector<bool>>( H + 2, vector<bool>( W + 2, 0 ) ) ) );\n\tvector<vector<vector<char>>>mapd( 2, vector<vector<char>>( H + 2, vector<char>( W + 2, '#' ) ) );\n\tfor( size_t i = 1; i <= H; i++ ) {\n\t\tfor( size_t j = 1; j <= W; j++ ) {\n\t\t\tcin >> mapd[0][i][j];\n\t\t\tif( mapd[0][i][j] == 'L' ) {\n\t\t\t\tstartL = make_pair( i, j );\n\t\t\t} else if( mapd[0][i][j] == '%' ) {\n\t\t\t\tgoalL = make_pair( i, j );\n\t\t\t}\n\t\t}\n\t\tfor( int j = W; j >= 1; j-- ) {\n\t\t\tcin >> mapd[1][i][j];\n\t\t\tif( mapd[1][i][j] == 'R' ) {\n\t\t\t\tstartR = make_pair( i,  j  );\n\t\t\t} else if( mapd[1][i][j] == '%' ) {\n\t\t\t\tgoalR = make_pair( i,  j  );\n\t\t\t}\n\t\t}\n\t}\n\tdp[startL.first][startL.second][startR.first][startR.second] = 1;\n\t\n\n\tqueue<PPIIII>que;\n\tque.push( make_pair( startL, startR ) );\n\twhile( que.size() ) {\n\t\tauto now = que.front(); que.pop();\n\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\tauto next = now;\n\t\t\tnext.first.first += dx[i];\n\t\t\tnext.first.second += dy[i];\n\t\t\tnext.second.first += dx[i];\n\t\t\tnext.second.second += dy[i];\n\t\t\tif( mapd[0][next.first.first][next.first.second] == '#' ) {\n\t\t\t\tnext.first = now.first;\n\t\t\t}\n\t\t\tif( mapd[1][next.second.first][next.second.second] == '#' ) {\n\t\t\t\tnext.second = now.second;\n\t\t\t}\n\n\t\t\tif( 0 < next.first.first&&next.first.first < H + 2 &&\n\t\t\t\t0 < next.first.second&&next.first.second < W + 2 &&\n\t\t\t\t0 < next.second.first&&next.second.first < H + 2 &&\n\t\t\t\t0 < next.second.second&&next.second.second < W + 2 ) {\n\t\t\t\tif( dp[next.first.first][next.first.second][next.second.first][next.second.second] == 0 ) {\n\t\t\t\t\tif( goalL == next.first&&goalR == next.second ) {\n\t\t\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdp[next.first.first][next.first.second][next.second.first][next.second.second] = 1;\n\t\t\t\t\tque.push( next );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"No\" << endl;\n\treturn;\n}\n\nint main() {\n\tint W, H;\n\twhile( cin >> W >> H, W&&H ) {\n\t\tsolve( W, H );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint w, h; \nstruct Pos {\n  int x;\n  int y;\n  bool operator==(Pos that) {\n    return x == that.x && y == that.y;\n  }\n  Pos operator+(Pos that) {\n    return {x+that.x, y+that.y};\n  }\n\n  Pos (int xx, int yy) {\n    x = xx; y = yy;\n  }\n};\n\nbool inner(Pos p) {\n  return 0 <= p.x && p.x < w\n      && 0 <= p.y && p.y < h;\n}\n\nPos search_charactor(vector<string> &map, char charactor) {\n  for (int i=0; i<map.size(); i++)\n    for (int l=0; l<map[i].size(); l++)\n      if (map[i][l] == charactor) {\n        map[i][l] = '.';\n        return {l, i};\n      }\n}\n\ntemplate <typename T>\nusing V=vector<T>;\n\nint main(){\n  while (cin >> w >> h, w+h != 0) {\n    vector<string> rooml, roomr;\n    rooml.reserve(h); roomr.reserve(h);\n    for (int i=0; i<h; i++) {\n      string l, r;\n      cin >> l >> r; \n      reverse(r.begin(), r.end());\n      rooml.push_back(l);\n      roomr.push_back(r);\n    }\n    Pos len_pos = search_charactor(rooml, 'L');\n    Pos rin_pos = search_charactor(roomr, 'R');\n    Pos len_goal = search_charactor(rooml, '%');\n    Pos rin_goal = search_charactor(roomr, '%');\n\n    queue<pair<Pos, Pos>> q;\n    q.push(make_pair(len_pos, rin_pos));\n    // cout<<\"goal: (\"<<len_goal.x<<\", \"<<len_goal.y<<\") \"<<\"(\"<<rin_goal.x<<\", \"<<rin_goal.y<<\")\"<<endl;\n    // for (int i=0; i<rooml.size(); i++) {\n    //   cout << rooml[i] << \" \" << roomr[i] << endl;\n    // }\n\n    V<V<V<V<bool>>>> already(h, V<V<V<bool>>>(w, V<V<bool>>(h, V<bool>(w, false))));\n    bool f = true;\n    while (!q.empty()) {\n      Pos len = q.front().first;\n      Pos rin = q.front().second; \n      q.pop();\n      // cout<<\"(\"<<len.x<<\", \"<<len.y<<\") \"<<\"(\"<<rin.x<<\", \"<<rin.y<<\")\"<<endl;\n\n      if (len==len_goal && rin==rin_goal) {\n        cout << \"Yes\" << endl;\n        f = false;\n        break;\n      }\n\n      for (Pos np: {Pos(0,1), Pos(0,-1), Pos(1,0), Pos(-1,0)}) {\n        Pos l = (inner(np+len) && rooml[np.y+len.y][np.x+len.x] == '.') ? len + np : len;\n        Pos r = (inner(np+rin) && roomr[np.y+rin.y][np.x+rin.x] == '.') ? rin + np : rin;\n        if (!already[l.y][l.x][r.y][r.x] && inner(l) && inner(r) \n          && rooml[l.y][l.x] == '.' && roomr[r.y][r.x] == '.') {\n          q.push(make_pair(l, r));\n          already[l.y][l.x][r.y][r.x] = true;\n        }\n      }\n    }\n    if (f) cout << \"No\" << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\n\n\nint W,H;\nstring roomL[55],roomR[55];\n\nbool range_check(int y,int x) {\n    if(!(0<=y&&y<H)) return false;\n    if(!(0<=x&&x<W)) return false;\n\n    return true;\n}\n\nbool visited[55][55][55][55];\nbool ok(P len,P rin) {\n    memset(visited,0,sizeof(visited));\n    visited[len.fr][len.sc][rin.fr][rin.sc]=true;\n    queue<PP> que;\n    que.push(PP(len,rin));\n\n    while(que.size()) {\n        PP pp=que.front(); que.pop();\n        P next_len=pp.fr;\n        P next_rin=pp.sc;\n\n        //printf(\"[debug] %d %d %d %d\\n\",next_len.fr,next_len.sc,next_rin.fr,next_rin.sc);\n\n        if(roomL[next_len.fr][next_len.sc]=='%' && roomR[next_rin.fr][next_rin.sc]=='%') {\n            return true;\n        }\n\n        rep(i,4) {\n            next_len=pp.fr;\n            next_rin=pp.sc;\n\n            if(range_check(next_len.fr+dy[i],next_len.sc+dx[i]) && roomL[next_len.fr+dy[i]][next_len.sc+dx[i]]!='#') {\n                next_len.fr+=dy[i];\n                next_len.sc+=dx[i];\n            }\n            if(range_check(next_rin.fr+dy[i],next_rin.sc-dx[i]) && roomR[next_rin.fr+dy[i]][next_rin.sc-dx[i]]!='#') {\n                next_rin.fr+=dy[i];\n                next_rin.sc-=dx[i];\n            }\n\n            if(!visited[next_len.fr][next_len.sc][next_rin.fr][next_len.sc]) {\n                if(!(roomL[next_len.fr][next_len.sc]=='%')^(roomR[next_rin.fr][next_rin.sc]=='%')) {\n                    visited[next_len.fr][next_len.sc][next_rin.fr][next_len.sc]=true;\n                    que.push(PP(next_len,next_rin));\n                }\n            }\n        }\n    }\n\n    return false;\n}\n\nvoid solve() {\n    rep(y,55) roomL[y]=roomR[y]=string('#',55);\n    rep(y,H) cin>>roomL[y]>>roomR[y];\n    P len,rin;\n    rep(y,H) rep(x,W) {\n        if(roomL[y][x]=='L') len=P(y,x);\n        if(roomR[y][x]=='R') rin=P(y,x);\n    }\n    if(ok(len,rin)) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n}\n\nint main() {\n    while(cin>>W>>H) {\n        if(!W) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// SampleMC1.cpp : ??????????????? ??¢????????±????????§????????¨????????? ?????????????????????????????????\n//\n\n#include \"stdafx.h\"\n#include<iostream>\n#include<queue>\nusing namespace std;\n#define REP(i, a, n) for(int i=a; i<n; i++)\n\nbool hist[51][51][51][51];\n\nstruct State {\n\tint xL, yL, xR, yR;\n};\n\nint main() {\n\tint w, h;\n\n\tint dx[4] = { 0, 1, 0, -1 }; // ????????????\n\tint dy[4] = { -1, 0, 1, 0 };\n\n\twhile (cin >> w >> h, w || h) {\n\t\tState st;\n\t\tchar Len[51][51];\n\t\tchar Rin[51][51];\n\t\t//bool hist[51][51][51][51] = { false };\n\t\thist[51][51][51][51] = { false };\n\n\t\t/* crate maze */\n\t\tREP(i, 0, h) {\n\t\t\tREP(j, 0, w) {\n\t\t\t\tcin >> Len[i][j];\n\t\t\t\tif (Len[i][j] == 'L') {\n\t\t\t\t\tst.yL = i;\n\t\t\t\t\tst.xL = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(j, 0, w) {\n\t\t\t\tcin >> Rin[i][j];\n\t\t\t\tif (Rin[i][j] == 'R') {\n\t\t\t\t\tst.yR = i;\n\t\t\t\t\tst.xR = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* BFS */\n\t\tqueue<State> qu;\n\t\tqu.push(st);\n\t\thist[st.yL][st.xL][st.yR][st.xR] = true;\n\t\tbool flag = false;\n\n\t\twhile (!qu.empty()) {\n\t\t\tState q = qu.front();\n\t\t\tqu.pop();\n\n\t\t\tint yl = q.yL, xl = q.xL, yr = q.yR, xr = q.xR;\n\t\t\tif (Len[yl][xl] == '%' && Rin[yr][xr] == '%') {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (Len[yl][xl] == '%' || Rin[yr][xr] == '%') continue;\n\t\t\tfor (int k = 0; k<4; ++k) {\n\t\t\t\tint yyl = yl + dy[k], xxl = xl + dx[k];\n\t\t\t\tint yyr, xxr;\n\t\t\t\tyyr = yr + dy[k];\n\t\t\t\txxr = xr + dx[k] * (-1);\n\n\t\t\t\tif (yyl<0 || yyl >= h || xxl<0 || xxl >= w || Len[yyl][xxl] == '#') {\n\t\t\t\t\tyyl = yl;\n\t\t\t\t\txxl = xl;\n\t\t\t\t}\n\t\t\t\tif (yyr<0 || yyr >= h || xxr<0 || xxr >= w || Rin[yyr][xxr] == '#') {\n\t\t\t\t\tyyr = yr;\n\t\t\t\t\txxr = xr;\n\t\t\t\t}\n\t\t\t\tif (hist[yyl][xxl][yyr][xxr]) continue;\n\t\t\t\thist[yyl][xxl][yyr][xxr] = true;\n\t\t\t\tqu.push({ yyl, xxl, yyr, xxr });\n\t\t\t\t//cout << yyl << \" \" << xxl << \" \" << yyr << \" \" << xxr << endl;\n\t\t\t}\n\t\t}\n\t\tif (flag) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\n\t}\n\tint in;\n\tcin >> in;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\nusing namespace std;\nstring s1[50],s2[50];\nint dx1[]={1,-1,0,0,},dy1[]={0,0,1,-1};\nint dx2[]={-1,1,0,0,},dy2[]={0,0,1,-1};\nint w,h,gx1,gx2,gy1,gy2;\nset<pair<pair<int,int>,pair<int,int> > >s;\nbool bfs(int x1,int y1,int x2,int y2){\n  queue<pair<pair<int,int>,pair<int,int> > >q;\n  q.push(mk(mk(x1,y2),mk(x2,y2)));\n  while(!q.empty()){\n    pair<pair<int,int>,pair<int,int> >p=q.front();q.pop();\n    x1=p.first.first;y1=p.first.second;\n    x2=p.second.first;y2=p.second.second;\n    if(x1==gx1&&y1==gy1&&(x2!=gx2||y2!=gy2))continue;\n    if((x1!=gx1||y1!=gy1)&&x2==gx2&&y2==gy2)continue;\n    if(x1==gx1&&y1==gy1&&x2==gx2&&y2==gy2)return 1;\n    for(int i=0;i<4;i++){\n      int x3=x1+dx1[i],y3=y1+dy1[i];\n      int x4=x2+dx2[i],y4=y2+dy2[i];\n      if(x3>=0&&x4>=0&&y3>=0&&y4>=0)\n        if(x3<w&&x4<w&&y3<h&&y4<h){\n          if(s1[y3][x3]=='#')y3=y1,x3=x1;\n          if(s2[y4][x4]=='#')y4=y2,x4=x2;\n          if(!s.count(mk(mk(x3,y3),mk(x4,y4)))){\n            s.insert(mk(mk(x3,y3),mk(x4,y4)));\n            q.push(mk(mk(x3,y3),mk(x4,y4)));\n          }\n        }\n      }\n    }\n    return 0;\n}\nint main(){\n  int x1,y1,x2,y2;\n  while(cin>>w>>h,w){\n    s.clear();\n    r(i,h)cin>>s1[i]>>s2[i];\n    r(i,h)r(j,w){\n      if(s1[i][j]=='L')x1=j,y1=i;\n      if(s2[i][j]=='R')x2=j,y2=i;\n      if(s1[i][j]=='%')gx1=j,gy1=i;\n      if(s2[i][j]=='%')gx2=j,gy2=i;\n    }\n    s.insert(mk(mk(x1,y1),mk(x2,y2)));\n    if(bfs(x1,y1,x2,y2))cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"tune=native\")\n#pragma GCC target (\"avx\")\n\n#include <bits/stdc++.h>\n\n// 汎用マクロ\n#define ALL_OF(x) (x).begin(), (x).end()\n#define REP(i,n) for (long long i=0, i##_len=(n); i<i##_len; i++)\n#define RANGE(i,is,ie) for (long long i=(is), i##_end=(ie); i<=i##_end; i++)\n#define DSRNG(i,is,ie) for (long long i=(is), i##_end=(ie); i>=i##_end; i--)\n#define UNIQUE(v) { sort((v).begin(), (v).end()); (v).erase(unique((v).begin(), (v).end()), (v).end()); }\ntemplate<class T> bool chmax(T &a, const T &b) {if (a < b) {a = b; return 1;} return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) {if (a > b) {a = b; return 1;} return 0; }\n#define INF 0x7FFFFFFF\n#define LINF 0x7FFFFFFFFFFFFFFFLL\n#define Yes(q) (q ? \"Yes\" : \"No\")\n#define YES(q) (q ? \"YES\" : \"NO\")\n#define DUMP(q) cerr << \"[DEBUG] \" #q \": \" << (q) << \" at \" __FILE__ \":\" << __LINE__ << endl\n#define DUMPALL(q) cerr << \"[DEBUG] \" #q \": [\"; REP(dumpall_i, (q).size()) { cerr << q[dumpall_i] << (dumpall_i == (q).size() - 1 ? \"\" : \", \"); } cerr << \"] at \" __FILE__ \":\" << __LINE__ << endl\n\n// gcc拡張マクロ\n#define gcd __gcd\n#define popcount __builtin_popcount\n#define popcountll __builtin_popcountll\n\n// エイリアス\nusing  ll = long long;\nusing ull = unsigned long long;\nusing  ld = long double;\nusing namespace std;\n\n// モジュール\n\n\n// 処理内容\nint main() {\n    \n    ll w, h;\n    while (cin >> w >> h, w && h) {\n\n        vector<string> rl(h), rr(h);\n        REP(i, h) cin >> rl[i] >> rr[i];\n        ll lsy, lsx, rsy, rsx;\n        ll lgy, lgx, rgy, rgx;\n        REP(i, h) REP(j, w) {\n            if (rl[i][j] == '%') {\n                lgy = i;\n                lgx = j;\n            } else if (rl[i][j] == 'L') {\n                lsy = i;\n                lsx = j;\n            }\n            if (rr[i][j] == '%') {\n                rgy = i;\n                rgx = j;\n            } else if (rr[i][j] == 'R') {\n                rsy = i;\n                rsx = j;\n            }\n        }\n\n        // {ly, lx, ry, rx}\n        deque<tuple<ll,ll,ll,ll>> q;\n        vector<vector<vector<vector<bool>>>> visited(h, vector<vector<vector<bool>>>(w, vector<vector<bool>>(h, vector<bool>(w, false))));\n        q.emplace_back(lsy, lsx, rsy, rsx);\n        visited[lsy][lsx][rsy][rsx] = true;\n        while (!q.empty()) {\n\n            ll ly = get<0>(q.front());\n            ll lx = get<1>(q.front());\n            ll ry = get<2>(q.front());\n            ll rx = get<3>(q.front());\n            q.pop_front();\n\n            // Lin and Ren go upward\n            if (ly > 0 && ry > 0) {\n                ll ly2 = rl[ly - 1][lx] != '#' ? ly - 1 : ly;\n                ll lx2 = lx;\n                ll ry2 = rr[ry - 1][lx] != '#' ? ry - 1 : ry;\n                ll rx2 = rx;\n                if (!visited[ly2][lx2][ry2][rx2]) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n            }\n\n            // Lin and Ren go downward\n            if (ly < h-1 && ry < h-1) {\n                ll ly2 = rl[ly + 1][lx] != '#' ? ly + 1 : ly;\n                ll lx2 = lx;\n                ll ry2 = rr[ry + 1][lx] != '#' ? ry + 1 : ry;\n                ll rx2 = rx;\n                if (!visited[ly2][lx2][ry2][rx2]) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n            }\n\n            // Lin goes left and Ren goes right\n            if (lx > 0 && rx < w-1) {\n                ll ly2 = ly;\n                ll lx2 = rl[ly][lx - 1] != '#' ? lx - 1 : lx;\n                ll ry2 = ry;\n                ll rx2 = rr[ry][rx + 1] != '#' ? rx + 1 : rx;\n                if (!visited[ly2][lx2][ry2][rx2]) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n            }\n\n            // Lin goes right and Ren goes left\n            if (lx < w-1 && rx > 0) {\n                ll ly2 = ly;\n                ll lx2 = rl[ly][lx + 1] != '#' ? lx + 1 : lx;\n                ll ry2 = ry;\n                ll rx2 = rr[ry][rx - 1] != '#' ? rx - 1 : rx;\n                if (!visited[ly2][lx2][ry2][rx2]) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n            }\n\n        }\n\n        std::cout << Yes(visited[lgy][lgx][rgy][rgx]) << endl;\n\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "//????????????????????????\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> ver;\ntypedef pair<int, ver> piv;\nint dx[2][4] = {{1, 0, -1, 0},\n                {-1, 0, 1, 0}};\nint dy[] = {0, 1, 0, -1};\n\nbool range(pii p, int w, int h){\n  if(0 <= p.first  && p.first  < w &&\n     0 <= p.second && p.second < h)return true;\n  return false;\n}\nint main(int argc, char *argv[]){\n  int w, h;\n  while(cin >> w >> h, w){\n    vector<string> grid1(h), grid2(h);\n    int sx[2], sy[2], gx[2], gy[2];\n    for (int i = 0; i < h; i++) {\n      cin >> grid1[i] >> grid2[i];\n      for (int j = 0; j < w; j++) {\n        if(grid1[i][j] == 'L')sx[0] = j, sy[0] = i;\n        if(grid1[i][j] == '%')gx[0] = j, gy[0] = i;\n        if(grid2[i][j] == 'R')sx[1] = j, sy[1] = i;\n        if(grid2[i][j] == '%')gx[1] = j, gy[1] = i;\n      }\n    }\n    int dp[h][w][h][w];\n    for (int i = 0; i < h; i++) \n      for (int j = 0; j < w; j++) \n        for (int k = 0; k < h; k++) \n          for (int l = 0; l < w; l++) \n            dp[i][j][k][l] = 1e9;\n    dp[sy[0]][sx[0]][sy[1]][sx[1]] = 0;\n    queue<piv> que;\n    que.push(piv(0, ver(pii(sx[0], sy[0]), pii(sx[1], sy[1]))));\n    int cnt = 0;\n    while(!que.empty()){\n      pii u = que.front().second.first;\n      pii v = que.front().second.second;\n      int c = que.front().first;\n      que.pop();\n      for (int i = 0; i < 4; i++) {\n        pii a = u, b = v;\n        a.first  += dx[0][i];\n        a.second += dy[i];\n        b.first  += dx[1][i];\n        b.second += dy[i];\n        if(!range(a, w, h) || grid1[a.second][a.first] == '#')\n          a = u;\n        if(!range(b, w, h) || grid2[b.second][b.first] == '#')\n          b = v;\n        if(dp[a.second][a.first][b.second][b.first] > c + 1){\n          dp[a.second][a.first][b.second][b.first] = c + 1;\n          que.push(piv(c + 1, ver(a, b)));\n        }\n      }\n    }\n    if(dp[gy[0]][gx[0]][gy[1]][gx[1]] != 1e9)\n      std::cout << \"Yes\" << std::endl;\n    else\n      std::cout << \"No\" << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,s,n) for(int i=s; i<n; i++)\n#define ALL(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nint w, h;\nint rooml[60][60], roomr[60][60];\nbool memo[60][60][60][60];\n\nbool dfs(int xl, int yl, int xr, int yr) {\n\tif( memo[xl][yl][xr][yr] ) {\n\t\treturn false;\n\t}\n\tmemo[xl][yl][xr][yr] = true;\n\tconst int dx[4] = {-1, 0, 1, 0};\n\tconst int dy[4] = {0, 1, 0, -1};\n\tbool f = false;\n\trep(i, 4) {\n\t\tint nxl = xl + dx[i];\n\t\tint nyl = yl + dy[i];\n\t\tint nxr = xr - dx[i];\n\t\tint nyr = yr + dy[i];\n\t\tint nl = rooml[nyl][nxl];\n\t\tint nr = roomr[nyr][nxr];\n\t\tif( nl==2 && nr==2 ) {\n\t\t\tf = true;\n\t\t}\n\t\telse if( nl==1 && nr==1 ) {\n\t\t\tf |= dfs(nxl, nyl, nxr, nyr);\n\t\t}\n\t\telse if( nl==1 && nr==0 ) {\n\t\t\tf |= dfs(nxl, nyl, xr, yr);\n\t\t}\n\t\telse if( nl==0 && nr==1 ) {\n\t\t\tf |= dfs(xl, yl, nxr, nyr);\n\t\t}\n\t}\n\treturn f;\n}\n\nint main() {\n\twhile(cin >> w >> h, w) {\n\t\tmemset(rooml, 0, sizeof(rooml));\n\t\tmemset(roomr, 0, sizeof(roomr));\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tint xl=1, yl=1, xr=1, yr=1;\n\t\trep(y, h) {\n\t\t\tstring sl, sr;\n\t\t\tcin >> sl >> sr;\n\t\t\trep(x, w) {\n\t\t\t\tif(sl[x] == 'L') {\n\t\t\t\t\txl = x+1;\n\t\t\t\t\tyl = y+1;\n\t\t\t\t\trooml[y+1][x+1] = 1;\n\t\t\t\t} else {\n\t\t\t\t\trooml[y+1][x+1] = (sl[x]=='%' ? 2 : (sl[x]=='.' ? 1 : 0));\n\t\t\t\t}\n\t\t\t\tif(sr[x] == 'R') {\n\t\t\t\t\txr = x+1;\n\t\t\t\t\tyr = y+1;\n\t\t\t\t\troomr[y+1][x+1] = 1;\n\t\t\t\t} else {\n\t\t\t\t\troomr[y+1][x+1] = (sr[x]=='%' ? 2 : (sr[x]=='.' ? 1 : 0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( dfs(xl, yl, xr, yr) ) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t} else {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> node;\nint ldx[4]={1,0,-1,0};\nint rdx[4]={-1,0,1,0};\nint dy[4]={0,1,0,-1};\n\nchar l[52][52];\nchar r[52][52];\nbool sets [52][52][52][52];\nint main(void){\n\tint w,h;\n\twhile(cin >> w >> h,w|h){\n\t\tfor(int x1=0;x1<=w+1;x1++)\n\t\t\tfor(int y1=0;y1<=h+1;y1++)\n\t\t\t\tfor(int x2=0;x2<=w+1;x2++)\n\t\t\t\t\tfor(int y2=0;y2<=h+1;y2++)\n\t\t\t\t\t\tsets[x1][y1][x2][y2]=false;\n\t\tint plx,ply,prx,pry;\n\t\tint slx,sly,srx,sry;\n\t\tfor(int x=0;x<=w+1;x++){\n\t\t\tl[x][0]=r[x][0]='#';\n\t\t\tl[x][h+1]=r[x][h+1]='#';\n\t\t}\n\t\tfor(int y=0;y<=h+1;y++){\n\t\t\tl[0][y]=r[0][y]='#';\n\t\t\tl[w+1][y]=r[w+1][y]='#';\n\t\t}\n\t\tfor(int y=1;y<=h;y++){\n\t\t\tfor(int x=1;x<=w;x++){\n\t\t\t\tcin >> l[x][y];\n\t\t\t\tif(l[x][y]=='%')\n\t\t\t\t\tplx=x,ply=y;\n\t\t\t\tif(l[x][y]=='L')\n\t\t\t\t\tslx=x,sly=y;\n\t\t\t}\n\t\t\tfor(int x=1;x<=w;x++){\n\t\t\t\tcin >> r[x][y];\n\t\t\t\tif(r[x][y]=='%')\n\t\t\t\t\tprx=x,pry=y;\n\t\t\t\tif(r[x][y]=='R')\n\t\t\t\t\tsrx=x,sry=y;\n\t\t\t}\n\t\t}\n\t\t/*for(int y=0;y<=h+1;y++){\n\t\t\tfor(int x=0;x<=w+1;x++){\n\t\t\t\tcout << l[x][y];\n\t\t\t}\n\t\t\tcout <<\" \" ;\n\t\t\tfor(int x=0;x<=w+1;x++){\n\t\t\t\tcout<< r[x][y];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tqueue<node> q;\n\t\tnode s,g;\n\t\ts=node(P(slx,sly),P(srx,sry));\n\t\tg=node(P(plx,ply),P(prx,pry));\n\t\tq.push(s);\n\t\tsets[slx][sly][srx][sry]=true;\n\t\twhile(!q.empty()){\n\t\t\tnode cur=q.front();q.pop();\n\t\t\t//cout << cur.F.F << \" \"<< cur.F.S << \" \"<< cur.S.F << \" \"<< cur.S.S << endl;\n\t\t\tif(cur == g)\n\t\t\t\tbreak;\n\t\t\tif((cur.F.F==plx&&cur.F.S==ply)||(cur.S.F==prx&&cur.F.S==pry))\n\t\t\t\tcontinue;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint lnx=cur.F.F+ldx[i],lny=cur.F.S+dy[i],rnx=cur.S.F+rdx[i],rny=cur.S.S+dy[i];\n\t\t\t\tif(l[lnx][lny]=='#'&&r[rnx][rny]=='#')\n\t\t\t\t\tcontinue;\n\t\t\t\tif(l[lnx][lny]=='#')\n\t\t\t\t\tlnx=cur.F.F,lny=cur.F.S;\n\t\t\t\tif(r[rnx][rny]=='#')\n\t\t\t\t\trnx=cur.S.F,rny=cur.S.S;\n\t\t\t\tnode c=node(P(lnx,lny),P(rnx,rny));\n\t\t\t\tif(!sets[lnx][lny][rnx][rny])\n\t\t\t\t\tsets[lnx][lny][rnx][rny]=true,q.push(c);\n\t\t\t}\n\t\t}\n\t\tif(sets[plx][ply][prx][pry])\n\t\t\tcout << \"Yes\" << endl;\n\t\telse\n\t\t\tcout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define MOD 1000000007\n#define PB(a) push_back(a);\n#define rep(i, a) for (int i = 0; i < a; i++)\n#define reps(i, a, b) for (int i = a; i < b; i++)\nusing  ll = long long;\n\nstruct zahyo {\n\tint lx;\n\tint ly;\n\tint rx;\n\tint ry;\n};\n\nqueue<zahyo> q;\nint lx, ly, rx, ry;\nint px1, px2, py1, py2;\nint w, h;\nint cost[52][52][52][52];\nint m[2][52][52];\n#define INF 1000000000\n\nvoid init()\n{\n\trep(i, 52) rep(j, 52) rep(k, 52) rep(l, 52) {\n\t\tcost[i][j][k][l] = INF;\n\t}\n\trep(i, 52) rep(j, 52) {\n\t\tm[0][i][j] = 0;\n\t\tm[1][i][j] = 0;\n\t}\n\t\t\n}\n\nbool mypush(int lx, int ly, int rx, int ry)\n{\n\tif (cost[ly][lx][ry][rx] != INF) return false;\n\tif (!(px1 == lx && py1 == ly && px2 == rx && py2 == ry)) {\n\t\tif (px1 == lx && py1 == ly) return false;\n\t\tif (px2 == rx && py2 == ry) return false;\n\t}\n\tzahyo z;\n\tz.lx = lx;\n\tz.ly = ly;\n\tz.rx = rx;\n\tz.ry = ry;\n\tq.push(z);\n\treturn true;\n}\n\nsigned main()\n{\n\twhile (true) {\n\t\tcin >> w >> h;\n\t\tif (w == 0) break;\n\t\tinit();\n\t\trep(i, h) {\n\t\t\tstring s[2];\n\t\t\tcin >> s[0] >> s[1];\n\t\t\trep(cnt, 2) rep(j, w) {\n\t\t\tif (s[cnt][j] == 'L') {\n\t\t\t\t\tlx = j+1;\n\t\t\t\t\tly = i+1;\n\t\t\t\t}\n\t\t\t\tif (s[cnt][j] == 'R') {\n\t\t\t\t\trx = j+1;\n\t\t\t\t\try = i+1;\n\t\t\t\t}\n\t\t\t\tif (s[cnt][j] == '#') {\n\t\t\t\t\tm[cnt][i+1][j+1] = 0;\n\t\t\t\t} else {\n\t\t\t\t\tm[cnt][i+1][j+1] = 1;\n\t\t\t\t}\n\t\t\t\tif (s[cnt][j] == '%') {\n\t\t\t\t\tif (cnt == 0) {\n\t\t\t\t\t\tpx1 = j+1;\n\t\t\t\t\t\tpy1 = i+1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpx2 = j+1;\n\t\t\t\t\t\tpy2 = i+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcost[ly][lx][ry][rx] = 1;\n\t\tzahyo ztmp;\n\t\tztmp.lx = lx;\n\t\tztmp.ly = ly;\n\t\tztmp.rx = rx;\n\t\tztmp.ry = ry;\n\t\tq.push(ztmp);\n\t\tint dlx[] = {0, 1, 0, -1};\n\t\tint dly[] = {-1, 0, 1, 0};\n\t\tint drx[] = {0, -1, 0, 1};\n\t\tint dry[] = {-1, 0, 1, 0};\n\t\twhile (!q.empty()) {\n\t\t\tzahyo z = q.front();\n\t\t\tq.pop();\n\t\t\trep(i, 4) {\n\t\t\t\tint nlx, nly, nrx, nry;\n\t\t\t\tint lxt, lyt, rxt, ryt;\n\t\t\t\tnlx = lxt = z.lx;\n\t\t\t\tnly = lyt = z.ly;\n\t\t\t\tnrx = rxt = z.rx;\n\t\t\t\tnry = ryt = z.ry;\n\t\t\t\tif (dlx[i]) {\n\t\t\t\t\tif (m[0][lyt][dlx[i]+lxt] == 1) nlx = dlx[i]+lxt;\n\t\t\t\t\tif (m[1][ryt][drx[i]+rxt] == 1) nrx = drx[i]+rxt;\n\t\t\t\t} else {\n\t\t\t\t\tif (m[0][lyt+dly[i]][lxt] == 1) nly = dly[i]+lyt;\n\t\t\t\t\tif (m[1][ryt+dry[i]][rxt] == 1) nry = dry[i]+ryt;\n\t\t\t\t}\n\t\t\t\tif (mypush(nlx, nly, nrx, nry)) {\n\t\t\t\t\tcost[nly][nlx][nry][nrx] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cost[py1][px1][py2][px2] == 1) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t} else {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int, int> T;\n\nconst ll MOD=1e9+7;\nconst ll INF=1e18;\nconst double pi=acos(-1);\nconst double eps=1e-10;\n\nint dx[]={1, 0, -1, 0};\nint dy[]={0, -1, 0, 1};\n\nint main(){\n    while(1){\n        int w, h; cin>>w>>h;\n        if(w == 0) return 0;\n\n        int lsy, lsx, rsy, rsx;\n        int lgy, lgx, rgy, rgx;\n        vector<string> s1(h), s2(h);\n        for(int i=0; i<h; i++){\n            cin>>s1[i]>>s2[i];\n            reverse(s2[i].begin(), s2[i].end());\n\n            for(int j=0; j<w; j++){\n                if(s1[i][j] == '%'){\n                    s1[i][j] = '.';\n                    lgy = i;\n                    lgx = j;\n                }\n                if(s2[i][j] == '%'){\n                    s2[i][j] = '.';\n                    rgy = i;\n                    rgx = j;\n                }\n                if(s1[i][j] == 'L'){\n                    s1[i][j] = '.';\n                    lsy = i;\n                    lsx = j;\n                }\n                if(s2[i][j] == 'R'){\n                    s2[i][j] = '.';\n                    rsy = i;\n                    rsx = j;\n                }\n            }\n        }\n\n        bool valid=false;\n        queue<T> que;\n        que.push(T(lsy, lsx, rsy, rsx));\n        map<ll, bool> visited;\n        visited[lsy+lsx*10000+rsy*100000000+rsx*1000000000000] = true;\n        while(que.size()){\n            int lcy, lcx, rcy, rcx;\n            tie(lcy, lcx, rcy, rcx) = que.front();\n            que.pop();\n            //cout << lcy << \" \" << lcx << \" \" << rcy << \" \" << rcx << endl;\n\n            if(lcy == lgy && lcx == lgx && rcy == rgy && rcx == rgx){\n                cout << \"Yes\" << endl;\n                valid = true;\n                break;\n            }\n\n            for(int i=0; i<4; i++){\n                int lny = lcy + dy[i];\n                int lnx = lcx + dx[i];\n                int rny = rcy + dy[i];\n                int rnx = rcx + dx[i];\n\n                if((lny == lgy && lnx == lgx) && !(rny == rgy && rnx == rgx)) continue;\n                if(!(lny == lgy && lnx == lgx) && (rny == rgy && rnx == rgx)) continue;\n\n                if(0 <= lny && lny < h && 0 <= lnx && lnx < w){\n                    if(s1[lny][lnx] == '.'){\n                        if(rny < 0 || h <= rny || rnx < 0 || w <= rnx){\n                            if(!visited[lny+lnx*10000+rcy*100000000+rcx*1000000000000]){\n                                visited[lny+lnx*10000+rcy*100000000+rcx*1000000000000] = true;\n                                que.push(T(lny, lnx, rcy, rcx));\n                            }\n                        }\n                        else if(s2[rny][rnx] == '#'){\n                            if(!visited[lny+lnx*10000+rcy*100000000+rcx*1000000000000]){\n                                visited[lny+lnx*10000+rcy*100000000+rcx*1000000000000] = true;\n                                que.push(T(lny, lnx, rcy, rcx));\n                            }\n                        }\n                        else{\n                            if(!visited[lny+lnx*10000+rny*100000000+rnx*1000000000000]){\n                                visited[lny+lnx*10000+rny*100000000+rnx*1000000000000] = true;\n                                que.push(T(lny, lnx, rny, rnx));\n                            }\n                        }\n                    }\n                }\n\n                if(0 <= rny && rny < h && 0 <= rnx && rnx < w){\n                    if(s2[rny][rnx] == '.'){\n                        if(lny < 0 || h <= lny || lnx < 0 || w <= lnx){\n                            if(!visited[lcy+lcx*10000+rny*100000000+rnx*1000000000000]){\n                                visited[lcy+lcx*10000+rny*100000000+rnx*1000000000000] = true;\n                                que.push(T(lcy, lcx, rny, rnx));\n                            }\n                        }\n                        else if(s1[lny][lnx] == '#'){\n                            if(!visited[lcy+lcx*10000+rny*100000000+rnx*1000000000000]){\n                                visited[lcy+lcx*10000+rny*100000000+rnx*1000000000000] = true;\n                                que.push(T(lcy, lcx, rny, rnx));\n                            }\n                        }\n                        else{\n                            if(!visited[lny+lnx*10000+rny*100000000+rnx*1000000000000]){\n                                visited[lny+lnx*10000+rny*100000000+rnx*1000000000000] = true;\n                                que.push(T(lny, lnx, rny, rnx));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if(!valid) cout << \"No\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\nusing namespace std;\nstring s1[30],s2[30];\nint dx1[]={1,-1,0,0,},dy1[]={0,0,1,-1};\nint dx2[]={-1,1,0,0,},dy2[]={0,0,1,-1};\nint w,h,gx1,gx2,gy1,gy2;\nset<pair<pair<int,int>,pair<int,int> > >s;\nbool dfs(int x1,int y1,int x2,int y2){\n  if(x1==gx1&&y1==gy1&&x2==gx2&&y2==gy2)return 1;\n  for(int i=0;i<4;i++){\n    int x3=x1+dx1[i],y3=y1+dy1[i];\n    int x4=x2+dx2[i],y4=y2+dy2[i];\n    if(x3>=0&&x4>=0&&y3>=0&&y4>=0)\n      if(x3<w&&x4<w&&y3<h&&y4<h){\n        if(s1[y3][x3]=='#')y3=y1,x3=x1;\n        if(s2[y4][x4]=='#')y4=y2,x4=x2;\n        if(!s.count(mk(mk(x3,y3),mk(x4,y4)))){\n          s.insert(mk(mk(x3,y3),mk(x4,y4)));\n          if(dfs(x3,y3,x4,y4))return 1;\n        }\n      }\n    }\n    return 0;\n}\nint main(){\n  int x1,y1,x2,y2;\n  while(cin>>w>>h,w){\n    s.clear();\n    r(i,h)cin>>s1[i]>>s2[i];\n    r(i,h)r(j,w){\n      if(s1[i][j]=='L')x1=j,y1=i;\n      if(s2[i][j]=='R')x2=j,y2=i;\n      if(s1[i][j]=='%')gx1=j,gy1=i;\n      if(s2[i][j]=='%')gx2=j,gy2=i;\n    }\n    s.insert(mk(mk(x1,y1),mk(x2,y2)));\n    if(dfs(x1,y1,x2,y2))cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\nbool used[51][51][51][51];\nstring roomL[51], roomR[51];\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while (true) {\n    int R, C;\n    cin >> C >> R;\n    if (R == 0 && C == 0) break;\n    REP(i, R) cin >> roomL[i] >> roomR[i];\n\n    int slr = 0, slc = 0, elr = 0, elc = 0, srr = 0, src = 0, err = 0, erc = 0;\n    REP(r, R) REP(c, C) {\n      if (roomL[r][c] == 'L') slr = r, slc = c;\n      if (roomR[r][c] == 'R') srr = r, src = c;\n      if (roomL[r][c] == '%') elr = r, elc = c;\n      if (roomR[r][c] == '%') err = r, erc = c;\n    }\n    //cout << slr << ' ' << slc << ' ' << elr << ' ' << elc << ' ' << srr << ' ' << src << ' ' << err << ' ' << erc << endl;\n    REP(i, R) REP(j, C) REP(k, R) REP(l, C) used[i][j][k][l] = false;\n    \n    queue<P> que;\n    que.push(P(slr * C + slc, srr * C + src));\n\n    bool flag = false;\n    while (!que.empty()) {\n      P p = que.front(); que.pop();\n      int lr = p.first / C, lc = p.first % C, rr = p.second / C, rc = p.second % C;\n      //cout << lr << ' ' << lc << ' ' << rr << ' ' << rc << endl;\n      if (lr == elr && lc == elc && rr == err && rc == erc) {\n\tflag = true;\n\tbreak;\n      } else if (used[lr][lc][rr][rc] || (lr == elr && lc == elc) || (rr == err && rc == erc)) {\n\tcontinue;\n      }\n\n      used[lr][lc][rr][rc] = true;\n      REP(i, 4) {\n\tint nlr = lr + dr[i], nlc = lc + dc[i], nrr = rr + dr[(i+2*(i&1))%4], nrc = rc + dc[(i+2*(i&1))%4];\n\tif (nlr < 0 || nlr >= R || nlc < 0 || nlc >= C || roomL[nlr][nlc] == '#') nlr = lr, nlc = lc;\n\tif (nrr < 0 || nrr >= R || nrc < 0 || nrc >= C || roomR[nrr][nrc] == '#') nrr = rr, nrc = rc;\n\tque.push(P(nlr * C + nlc, nrr * C + nrc));\n      }\n    }\n    cout << (flag ? \"Yes\" : \"No\") << endl;    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define lp(i,n) for(int i=0;i<n;i++)\nchar a[52][52],b[52][52];\nset<tuple<int,int,int,int>> dp;\nint ans;\n\nvoid calc(int lx,int ly,int rx,int ry){\n\tif(ans==1) return;\n\tif(a[lx][ly]=='%'&&b[rx][ry]=='%'){\n\t\tans=1;\n\t\treturn;\n\t}\n\telse if(a[lx][ly]=='%'||b[rx][ry]=='%') return;\n\ttuple<int,int,int,int> now;\n\tnow=make_tuple(lx,ly,rx,ry);\n\tdecltype(dp)::iterator it =dp.find(now);\n\tif(it!=dp.end()) return;\n\tdp.insert(now);\n\tint nxl=lx,nyl=ly,nxr=rx,nyr=ry;\n\tif(a[lx+1][ly]!='#') nxl++;\n\tif(b[rx-1][ry]!='#') nxr--;\n\tcalc(nxl,nyl,nxr,nyr);\n\tnxl=lx;nyl=ly;nxr=rx;nyr=ry;\n\tif(a[lx-1][ly]!='#') nxl--;\n\tif(b[rx+1][ry]!='#') nxr++;\n\tcalc(nxl,nyl,nxr,nyr);\n\tnxl=lx;nyl=ly;nxr=rx;nyr=ry;\n\tif(a[lx][ly+1]!='#') nyl++;\n\tif(b[rx][ry+1]!='#') nyr++;\n\tcalc(nxl,nyl,nxr,nyr);\n\tnxl=lx;nyl=ly;nxr=rx;nyr=ry;\n\tif(a[lx][ly-1]!='#') nyl--;\n\tif(b[rx][ry-1]!='#') nyr--;\n\tcalc(nxl,nyl,nxr,nyr);\n\treturn;\n}\n\nint main(){\n\twhile(1){\n\t\tint w,h;\n\t\tcin>>w>>h;\n\t\tint stxl,styl,stxr,styr;\n\t\tif(w==0&&h==0) break;\n\t\tlp(i,52){\n\t\t\tlp(j,52){\n\t\t\t\ta[i][j]='#';\n\t\t\t\tb[i][j]='#';\n\t\t\t}\n\t\t}\n\t\tlp(i,h+1){\n\t\t\tif(i==0) continue;\n\t\t\tlp(j,w+1){\n\t\t\t\tif(j==0) continue;\n\t\t\t\tcin>>a[j][i];\n\t\t\t\tif(a[j][i]=='L'){\n\t\t\t\t\tstxl=j;\n\t\t\t\t\tstyl=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlp(j,w+1){\n\t\t\t\tif(j==0) continue;\n\t\t\t\tcin>>b[j][i];\n\t\t\t\tif(b[j][i]=='R'){\n\t\t\t\t\tstxr=j;\n\t\t\t\t\tstyr=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp.clear();\n\t\tans=0;\n\t\tcalc(stxl,styl,stxr,styr);\n\t\tif(ans==0) cout<<\"No\"<<endl;\n\t\telse cout<<\"Yes\"<<endl;\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int MAX = 55;\nchar rm[MAX][MAX], lm[MAX][MAX];\nint w, h;\n\nstruct Point{\n    int x,y;\n    bool operator == ( const Point &right ) const {\n        if(right.x == x && right.y == y) return 1;\n        else return 0;\n    }\n    bool operator < ( const Point &right ) const {\n        if(x < right.x) return 1;\n        else if(x == right.x && y < right.y) return 1;\n        else return 0;\n    }\n};\nbool u[MAX][MAX][MAX][MAX];\nPoint rg, lg;\nbool ans;\n\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\nvoid dfs(Point rp, Point lp){\n    u[rp.y][rp.x][lp.y][lp.x] = true;\n    if(rg == rp && lg == lp) ans = true;\n    rep(i,4){\n        int lnx = lp.x + dx[i];\n        int lny = lp.y + dy[i];\n        int rnx = rp.x + dx[i] * -1;\n        int rny = rp.y + dy[i];\n        if( (lny < 0 || lny >= h || lnx < 0 || lnx >= w) || lm[lny][lnx] == '#'){\n            lnx = lp.x;\n            lny = lp.y;\n        }\n        if( (rny < 0 || rny >= h || rnx < 0 || rnx >= w) || rm[rny][rnx] == '#'){\n            rnx = rp.x;\n            rny = rp.y;\n        }\n        if(u[rny][rnx][lny][lnx]) continue;\n        dfs(Point{rnx,rny}, Point{lnx,lny});\n    }\n}\n\nint main(){\n    while(cin >> w >> h, w){\n        ans = false;\n        Point rp, lp;\n        memset(u, 0, sizeof(u));\n        rep(i,h){\n            rep(j,w * 2){\n                if(j < w){\n                    cin >> lm[i][j];\n                    if(lm[i][j] == 'L'){\n                        lp = Point{j,i};\n                    }\n                    if(lm[i][j] == '%'){\n                        lg = Point{j,i};\n                    }\n                }else{\n                    cin >> rm[i][j - w];\n                    if(rm[i][j - w] == 'R'){\n                        rp = Point{j - w,i};\n                    }\n                    if(rm[i][j - w] == '%'){\n                        rg = Point{j - w,i};\n                    }\n                }\n            }\n        }\n        dfs(rp,lp);\n        cout << (ans ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define pb push_back\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nconst P dx[4] = {P(0,0),P(0,0),P(-1,1),P(1,-1)};\nconst P dy[4] = {P(1,1),P(-1,-1),P(0,0),P(0,0)};\nint main(){\n  int H,W;\n  while(cin >> W >> H && H+W){\n    char L_cmap[H][W],R_cmap[H][W];\n    bool bmap[H][W][H][W];\n    P Ls,Rs,Lg,Rg;\n    rep(i,H)\n      rep(j,W)\n        rep(k,H)\n          rep(l,W)\n            bmap[i][j][k][l] = false;\n\n    rep(i,H){\n      string s;\n      cin >> s;\n      rep(j,W){\n\tL_cmap[i][j] = s[j];\n\tif(s[j] == 'L')Ls = P(j,i);\n\tif(s[j] == '%')Lg = P(j,i);\n      }\n      cin >> s;\n      rep(j,W){\n\tR_cmap[i][j] = s[j];\n\tif(s[j] == 'R')Rs = P(j,i);\n\tif(s[j] == '%')Rg = P(j,i);\n      }\n    }\n\n    queue<PP> que;\n    que.push(PP(Ls,Rs));\n    bmap[Ls.F][Ls.S][Rs.F][Rs.S] = true;\n    bool fin = false;\n    while(!que.empty())\n      {\n\tPP pp = que.front(); que.pop();\n\tif(pp.F == Lg && pp.S == Rg){\n\t  fin = true;\n\t  cout << \"Yes\" << endl;\n\t  break;\n\t}\n\tif(pp.F == Lg || pp.S == Rg)continue;\n\n\trep(i,4){\n\t  int L_nx = pp.F.F+dx[i].F,L_ny = pp.F.S+dy[i].F;\n\t  int R_nx = pp.S.F+dx[i].S,R_ny = pp.S.S+dy[i].S;\n\t  if(!(0<= L_nx & L_nx < W && 0<= L_ny && L_ny < H) || L_cmap[L_ny][L_nx] == '#'){\n\t    L_nx = pp.F.F,L_ny = pp.F.S;\n\t  }\n\t  if(!(0<= R_nx & R_nx < W && 0<= R_ny && R_ny < H) || R_cmap[R_ny][R_nx] == '#'){\n\t    R_nx = pp.S.F,R_ny = pp.S.S;\n\t  }\n\t  if(bmap[L_nx][L_ny][R_nx][R_ny])continue;\n\t  bmap[L_nx][L_ny][R_nx][R_ny] = true;\n\t  que.push(insert(L_nx,L_ny,R_nx,R_ny));\n\t}\n      }\n    if(!fin)cout << \"No\" << endl;\n    \n  }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define fi first\n#define se second\n#define mk make_pair\nusing namespace std;\nstring s1[50],s2[50];\nint dx1[]={1,-1,0,0,},dy1[]={0,0,1,-1};\nint dx2[]={-1,1,0,0,},dy2[]={0,0,1,-1};\nint w,h,gx1,gx2,gy1,gy2;\nunordered_set<pair<pair<int,int>,pair<int,int> > >s;\nqueue<pair<pair<int,int>,pair<int,int> > >q;\nbool bfs(int x1,int y1,int x2,int y2){\n  queue<int>q;\n  q.push(x1+y1*100+x2*10000+y2*1000000);\n  while(!q.empty()){\n    int p=q.front();q.pop();\n    x1=p%100;y1=p%10000/100;\n    x2=p%1000000/10000;y2=p/1000000;\n    for(int i=0;i<4;i++){\n      int x3=x1+dx1[i],y3=y1+dy1[i];\n      int x4=x2+dx2[i],y4=y2+dy2[i];\n      if(x3>=0&&x4>=0&&y3>=0&&y4>=0)\n        if(x3<w&&x4<w&&y3<h&&y4<h){\n          if(s1[y3][x3]=='#')y3=y1,x3=x1;\n          if(s2[y4][x4]=='#')y4=y2,x4=x2;\n          if(x1==gx1&&y1==gy1&&x2==gx2&&y2==gy2)return 1;\n          if(!(x3==gx1&&y3==gy1&&(x4!=gx2||y4!=gy2)))\n          if(!((x3!=gx1||y3!=gy1)&&x4==gx2&&y4==gy2))\n          if(!s.count(mk(mk(x3,y3),mk(x4,y4)))){\n            s.insert(mk(mk(x3,y3),mk(x4,y4)));\n            q.push(x3+y3*100+x4*10000+y4*1000000);\n          }\n        }\n      }\n    }\n    return 0;\n}\nbool dfs(int x1,int y1,int x2,int y2,int d){\n  //cout<<d<<endl;cout<<1;\n    if(x1==gx1&&y1==gy1&&(x2!=gx2||y2!=gy2))return 0;\n    if((x1!=gx1||y1!=gy1)&&x2==gx2&&y2==gy2)return 0;\n    if(x1==gx1&&y1==gy1&&x2==gx2&&y2==gy2)return 1;\n    if(d<8000)for(int i=0;i<4;i++){\n    int x3=x1+dx1[i],y3=y1+dy1[i];\n    int x4=x2+dx2[i],y4=y2+dy2[i];\n    if(x3<0)x3=x1;if(x4<0)x4=x2;\n    if(y3<0)y3=y1;if(y4<0)y4=y2;\n    if(x3>=w)x3=x1;if(x4>=w)x4=x2;\n    if(y3>=h)y3=y1;if(y4>=h)y4=y2;\n        if(s1[y3][x3]=='#')y3=y1,x3=x1;\n        if(s2[y4][x4]=='#')y4=y2,x4=x2;\n        if(!s.count(mk(mk(x3,y3),mk(x4,y4)))){\n          s.insert(mk(mk(x3,y3),mk(x4,y4)));\n          if(dfs(x3,y3,x4,y4,d+1))return 1;\n        }\n    }\n    else q.push(mk(mk(x1,y1),mk(x2,y2)));\n    if(q.size()){\n        pair<pair<int,int>,pair<int,int> >pp=q.front();q.pop();\n        if(bfs(pp.fi.fi,pp.fi.se,pp.se.fi,pp.se.se))return 1;\n    }\n    return 0;\n}\nint main(){\n  int x1,y1,x2,y2;\n  while(cin>>w>>h,w){\n    s.clear();\n    r(i,h)cin>>s1[i]>>s2[i];\n    r(i,h)r(j,w){\n      if(s1[i][j]=='L')x1=j,y1=i;\n      if(s2[i][j]=='R')x2=j,y2=i;\n      if(s1[i][j]=='%')gx1=j,gy1=i;\n      if(s2[i][j]=='%')gx2=j,gy2=i;\n    }\n    s.insert(mk(mk(x1,y1),mk(x2,y2)));\n    if(dfs(x1,y1,x2,y2,0))cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n    while(!q.empty())q.pop();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<ctime>\n#include<climits>\n#include<queue>\n#include<fstream>\n#include<deque>\n#include<iomanip>\n#include<list>\n#include<stack>\n#include<sstream>\n#include<string>\n#include<cctype>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<cstring>\n#include<map>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS 1e-10\n#define F first\n#define S second\n#define all(n) n.begin(),n.end()\n#define pb push_back\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define INF (1<<27)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nconst P dx[4] = {P(0,0),P(0,0),P(1,-1),P(-1,1)};\nconst P dy[4] = {P(1,1),P(-1,-1),P(0,0),P(0,0)};\n\n\nint H,W;\nchar L_cmap[51][51],R_cmap[51][51];\nbool L_used[51][51],R_used[51][51];\nP Ls,Rs,Lg,Rg;\nbool fin;\n\nvoid dfs(PP pp){\n  //cout << \"L = \" << pp.F.F << \",\" << pp.F.S << \" next R = \" << pp.S.F << \",\" << pp.S.S << endl;\n  // queue<PP> que;\n  //que.push(PP(Ls,Rs));\n   \n\n    //PP pp = que.front(); que.pop();\n      if(pp.F == Lg && pp.S == Rg){\n\tcout << \"Yes\" << endl;\n\tfin = true;\n\treturn;\n      }\n      //cout << \"pp.F = \" << pp.F.F << \",\" << pp.F.S << \" pp.S = \" << pp.S.F << \",\" << pp.S.S << endl;\n      rep(i,4){\n\tint L_nx = pp.F.F + dx[i].F,L_ny = pp.F.S + dy[i].F;\n\tint R_nx = pp.S.F + dx[i].S ,R_ny = pp.S.S + dy[i].S;\n\t//cout << \"First next L = \" << L_nx << \",\" << L_ny << \" Pre next R = \" << R_nx << \",\" << R_ny << endl;\n\n\n \tif(!(0<=L_nx && L_nx <W && 0<= R_nx && R_nx <W && 0<= L_ny && L_ny <H && 0<= R_ny && R_ny < H))continue;\n\tif(L_cmap[L_ny][L_nx] != '#' && L_used[L_ny][L_nx])continue;\n\tif(R_cmap[R_ny][R_nx] != '#' && R_used[R_ny][R_nx])continue;\n\tif(L_cmap[L_ny][L_nx] == '#' && R_cmap[R_ny][R_nx] == '#')continue;\n\n\t//cout << \"next L = \" << L_nx << \",\" << L_ny << \" Pre next R = \" << R_nx << \",\" << R_ny << endl;\n\tif(L_cmap[L_ny][L_nx] == '#')L_nx = pp.F.F,L_ny = pp.F.S;\n\tif(R_cmap[R_ny][R_nx] == '#')R_nx = pp.S.F,R_ny = pp.S.S;\n\t\n\tR_used[R_ny][R_nx] = L_used[L_ny][L_nx] = true;\n\t//que.push(insert(L_nx,L_ny,R_nx,R_ny));\n\tdfs(insert(L_nx,L_ny,R_nx,R_ny));\n\tR_used[R_ny][R_nx] = L_used[L_ny][L_nx] = false;\n\n      }\n      \n}\n   \n\n\nint main(){\n\n  while(cin >> W >> H && H+W){\n    fin = false;\n    rep(i,H){\n      string s;\n      cin >> s;\n      rep(j,W){\n\tL_cmap[i][j] = s[j],L_used[i][j] = false;\n\tif(s[j] == 'L')\n\t  Ls = P(j,i);\n\tif(s[j] == '%')\n\t  Lg = P(j,i);\n      }\n      cin >> s;\n      rep(j,W){\n\tR_cmap[i][j] = s[j],R_used[i][j] = false;\n\tif(s[j] == 'R')\n\t  Rs = P(j,i);\n\tif(s[j] == '%')\n\t  Rg = P(j,i);\n      }\n    }\n    //cout<< \"Ls = \" << Ls.F << \" \" << Ls.S << \", Lg = \" << Lg.F << \" \" << Lg.S << \", Rs = \" << Rs.F << \" \" << Rs.S << \", Rg = \" << Rg.F << \" \" << Rg.S << endl; \n    //rep(i,4){\n    //rep(j,51)rep(k,51)R_used[j][k] = L_used[j][k] = false;\n      //if(!(0<= Ls.F+dx[i].F && Ls.F+dx[i].F < W && 0<= Ls.S+dy[i].F && Ls.S+dy[i].F < H  && 0<= Rs.F+dx[i].S && Rs.F+dx[i].S < W  && 0<= Rs.S+dy[i].S && Rs.S+dy[i].S < H))continue;\n      //cout << Ls.F+dx[i].F << \" \" << Ls.S+dy[i].F<< \" \"<< Rs.F+dx[i].S<< \" \" << Rs.S+dy[i].S << endl;\n      //dfs(insert(Ls.F+dx[i].F,Ls.S+dy[i].F,Rs.F+dx[i].S,Rs.S+dy[i].S));\n      //cout << \"----------\" << endl;\n      //}    \n    L_used[Ls.S][Ls.F] = true,R_used[Rs.S][Rs.F] = true;\n    dfs(insert(Ls.F,Ls.S,Rs.F,Rs.S));\n\n    if(!fin)cout << \"No\" << endl;\n\n  }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include<bits/stdc++.h>\n using namespace std;\n#define INF 1000000000\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\ntypedef long long LL;\nint H,W;\nint A[100][100];\nint B[100][100];\nint sax,say,tax,tay;\nint sbx,sby,tbx,tby;\nbool used[61][61][61][61];\ntypedef pair<int,int>P;\ntypedef pair<P,P>PP;\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\n\nP move(P now,int x,int y){\n  if(now.first+x<0){\n     return now;\n  }\n  if(now.first+x>=W){\n     return now;\n  }\n  if(now.second+y<0){\n     return now;\n  }\n  if(now.second+y>=H){\n     return now;\n  }\n  if(A[now.first+x][now.second]!=1){\n     now.first+=x;\n  }\n  if(A[now.first][now.second+y]!=1){\n     now.second+=y;\n  }\n  return now;\n}\n\nP move2(P now,int x,int y){\n  if(now.first+x<0){\n     return now;\n  }\n  if(now.first+x>=W){\n     return now;\n  }\n  if(now.second+y<0){\n     return now;\n  }\n  if(now.second+y>=H){\n     return now;\n  }\n  if(B[now.first+x][now.second]!=1){\n     now.first+=x;\n  }\n  if(B[now.first][now.second+y]!=1){\n     now.second+=y;\n  }\n  return now;\n}\n\n\nint main(){\n    while(cin>>W>>H,W){\n       //vector<int>\n       REP(i,H){\n           string s;\n           cin>>s;\n           REP(j,W){\n              if(s[j]=='%'){\n                 sax=j;\n                 say=i;\n              }\n              if(s[j]=='L'){\n                 tax=j;\n                 tay=i;\n              }\n              A[i][j]=0;\n              if(s[j]=='#'){\n                 A[j][i]=1;\n              }\n           }\n           cin>>s;\n           REP(j,W){\n              if(s[j]=='%'){\n                 sbx=j;\n                 sby=i;\n              }\n              if(s[j]=='L'){\n                 tbx=j;\n                 tby=i;\n              }\n              B[i][j]=0;\n              if(s[j]=='#'){\n                 B[j][i]=1;\n              }\n           }\n       }\n       //????????????bfs\n       REP(i,61){\n           REP(j,61){\n               REP(k,61){\n                   REP(l,61){\n                       used[i][j][k][l]=false;\n                   }\n               }\n           }\n       }\n\n       used[sax][say][sbx][sby]=true;\n       vector<PP>v;\n       v.push_back(PP(P(sax,say),P(sbx,sby)));\n       int now=0;\n       while(now!=v.size()){\n          P l=v[now].first;\n          P r=v[now].second;\n          used[l.first][l.second][r.first][r.second]=true;\n          //cout<<l.first<<\" \"<<l.second<<\" \"<<r.first<<\" \"<<r.second<<endl;\n          REP(i,4){\n              P ll=move(l,dx[i],dy[i]);\n              P rr=move2(r,-dx[i],dy[i]);\n              if(used[ll.first][ll.second][rr.first][rr.second]==false){\n                 if(ll.first==tax&&ll.second==tbx){\n                    used[ll.first][ll.second][rr.first][rr.second]=true;\n                 }\n                 if(rr.first==tax&&rr.second==tbx){\n                    used[ll.first][ll.second][rr.first][rr.second]=true;\n                 }\n                   v.push_back(PP(ll,rr));\n              }\n          }\n          now++;\n       }\n\n       if(used[tax][tay][tbx][tby]==true){\n          cout<<\"Yes\"<<endl;\n       }else{\n          cout<<\"No\"<<endl;\n       }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nstruct state{\n\tP p1, p2;\n\tstate(P p1_, P p2_){ p1 = p1_; p2 = p2_; }\n};\nint w, h;\nint dx1[4] = {0,-1,1,0};\nint dy1[4] = {-1,0,0,1};\nint dx2[4] = {0,1,-1,0};\nint dy2[4] = {-1,0,0,1};\n\n// デバッグ用\ntemplate <class T>\nvoid debug(T v, string s){\n\tcout << s << endl;\n\tfor(int y=0 ; y < v.size() ; y++ ){\n\t\tcout << v[y] << endl;\n\t}\n\tcout << endl;\n}\n\n// vs から vs[y][x] == c となる (x,y) を返す\nP search(vector<string>& vs, char c){\n\tfor(int y=0 ; y < vs.size() ; y++ ){\n\t\tfor(int x=0 ; x < vs[y].size() ; x++ ){\n\t\t\tif( vs[y][x] == c ){\n\t\t\t\tvs[y][x] = '.';\n\t\t\t\treturn P(x,y);\n\t\t\t}\n\t\t}\n\t}\n\treturn P(0,0);\n}\n\nbool bfs(vector<string> L, vector<string>& R){\n\tP ls = search( L , 'L' );\n\tP rs = search( R , 'R' );\n\t//debug( L , \"[Left]\" );\n\t//debug( R , \"[right]\" );\n\t\n\tqueue< pair<P,P> > q;\n\tpair<P,P> s( ls , rs );\n\tq.push( s );\n\tmap<pair<P,P>,bool> memo;\n\twhile( !q.empty() ){\n\t\tpair<P,P> now = q.front(); q.pop();\n\t\tmemo[now] = true;\n\t\tint x1 = now.first.first;\n\t\tint y1 = now.first.second;\n\t\tint x2 = now.second.first;\n\t\tint y2 = now.second.second;\n\t\tif( L[y1][x1] == '%' && R[y2][x2] == '%' ){\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\tint mx1 = x1 + dx1[i];\n\t\t\tint my1 = y1 + dy1[i];\n\t\t\tif( mx1 < 0 || my1 < 0 || mx1 >= w || my1 >= h || L[my1][mx1] == '#' ){\n\t\t\t\tmx1 = x1;\n\t\t\t\tmy1 = y1;\n\t\t\t}\n\t\t\tint mx2 = x2 + dx2[i];\n\t\t\tint my2 = y2 + dy2[i];\n\t\t\tif( mx2 < 0 || my2 < 0 || mx2 >= w || my2 >= h || R[my2][mx2] == '#' ){\n\t\t\t\tmx2 = x2;\n\t\t\t\tmy2 = y2;\n\t\t\t}\n\t\t\tP p1(mx1,my1);\n\t\t\tP p2(mx2,my2);\n\t\t\tpair<P,P> next(p1,p2);\n\t\t\tif( memo.count( next ) ){\n\t\t\t\tcontinue;\n\t\t\t}else if( L[my1][mx1] == '%' && R[my2][mx2] != '%' ){\n\t\t\t\tmemo[next] = true;\n\t\t\t}else if( L[my1][mx1] != '%' && R[my2][mx2] == '%' ){\n\t\t\t\tmemo[next] = true;\n\t\t\t}else{\n\t\t\t\tq.push( next );\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\twhile( cin >> w >> h, w || h ){\n\t\tvector<string> L(h), R(h);\n\t\t\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tcin >> L[y];\n\t\t\tcin >> R[y];\n\t\t}\n\t\tbool ans = bfs( L , R );\n\t\tif( ans )\n\t\t\tcout << \"Yes\" << endl;\n\t\telse\n\t\t\tcout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dh[]={1,0,-1,0};\nint dw[]={0,1,0,-1};\nint w,h;\nbool isrange(int x,int y){return 0<=x && x<h && 0<=y && y<w;};\nint main(){\n    \n    while(cin>>w>>h,w){\n        vector<string> rl(h),rr(h);\n        for(int i=0;i<h;i++){\n            cin>>rl[i]>>rr[i];\n        }\n        pair<int,int> lp;\n        pair<int,int> rp;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(rl[i][j]=='L') lp={i,j};\n                if(rr[i][j]=='R') rp={i,j};\n            }\n        }\n        stack<pair<pair<int,int>,pair<int,int>>> que;\n        que.push({lp,rp});\n        set<pair<pair<int,int>,pair<int,int>>> dp;\n        dp.insert({lp,rp});\n        \n        auto move=[&rl,&rr](int x,int dx,int y,int dy,bool isr){\n            if(!isrange(x+dx,y+dy)){\n                return make_pair(min(max(x+dx,0),h-1),min(max(y+dy,0),w-1));\n            }\n            if(isr){\n                if(rr[x+dx][y+dy]=='#') return make_pair(x,y);\n                else return make_pair(x+dx,y+dy);\n            }\n            else{\n                if(rl[x+dx][y+dy]=='#') return make_pair(x,y);\n                else return make_pair(x+dx,y+dy);\n            }\n        };\n        while(!que.empty()){\n            auto p=que.top();\n            que.pop();\n            for(int i=0;i<4;i++){\n                auto tol=move(p.first.first,dh[i],p.first.second,dw[i],0);\n                auto tor=move(p.second.first,dh[i],p.second.second,dw[(i+2)%2],1);\n                pair<pair<int,int>,pair<int,int>> tost={tol,tor};\n                if(dp.count(tost)) continue;\n                dp.insert(tost);\n                que.push(tost);\n            }\n        }\n        pair<int,int> obl;\n        pair<int,int> obr;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(rl[i][j]=='%') obl={i,j};\n                if(rr[i][j]=='%') obr={i,j};\n            }\n        }\n        if(dp.count({obl,obr})) cout<<\"Yes\"<<endl;\n        else cout<<\"No\"<<endl;\n    }\n\n\n\n    return 0;\n}   "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n\n#define F first\n#define S second\n\nusing namespace std;\n\nconst int MAX = 55;\ntypedef pair<int,int> P;\nchar M[2][MAX][MAX];\nbool come[MAX][MAX][MAX][MAX];\nint W,H;\nP s1,s2;\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\n\nvoid init(){\n  memset(come,false,sizeof(come));\n}\n\nvoid print(){\n  for(int x = 0; x < 2; x++){\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++) cout << M[x][i][j];\n      cout << endl;\n    }\n    cout << endl<< endl;\n  }\n}\n\nvoid input(){\n  for(int i = 0; i < H; i++)\n    for(int x = 0; x < 2; x++)\n      for(int j = 0; j < W; j++){\n\tcin >> M[x][i][j];\n\tif(M[x][i][j] == 'L' && !x) s1 = P(i,j);\n\tif(M[x][i][j] == 'R' && x) s2 = P(i,j);\n\t}\n}\n\nbool isInside(int x, int y){return 0<=x&&x<W&&0<=y&&y<H;}\n\nbool rec(int x1, int y1, int x2, int y2){\n\n  if(come[x1][y1][x2][y2]) return false;\n  come[x1][y1][x2][y2] = true;\n  //cout << x1 <<  \" \" << y1 << \" \" << x2 << \" \" << y2 <<endl;\n  if(M[0][y1][x1] == '%' && M[1][y2][x2] == '%') return true;\n  if(M[0][y1][x1] == '%' || M[1][y2][x2] == '%') return false;\n  \n  bool tmp = false;\n\n  for(int i = 0; i < 4; i++){\n    int nx1 = x1+dx[i];\n    int ny1 = y1+dy[i];\n    int nx2 = x2-dx[i];\n    int ny2 = y2+dy[i];\n    if(!isInside(nx1,ny1) || M[0][ny1][nx1] == '#'){\n      nx1 = x1;\n      ny1 = y1;\n    }\n    if(!isInside(nx2,ny2) || M[1][ny2][nx2] == '#'){\n      nx2 = x2;\n      ny2 = y2;\n    }\n    \n    if(!come[nx1][ny1][nx2][ny2]) tmp =(tmp||rec(nx1,ny1,nx2,ny2));\n  }\n  return tmp;\n} \n\nvoid solve(){\n  if(rec(s1.S,s1.F,s2.S,s2.F)) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n}\n\nint main(){\n  while(cin >> W >> H && W+H){\n    init();\n    input();\n    //   print();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nconst int SZ = 51;\n\nint dx[] = {0, -1, 0, 1};\nint dy[] = {1, 0, -1, 0};\n\nint H, W;\nbool visit[SZ][SZ][SZ][SZ];\nstring LIN[SZ], REN[SZ];\n\ninline bool inside(int x, int y){\n  return 0 <= x && x < H && 0 <= y && y < W;\n}\n\nbool bfs(int lsx, int lsy, int rsx, int rsy){\n  memset(visit, false, sizeof(visit));\n  visit[lsx][lsy][rsx][rsy] = true;\n  queue<int> que_lx, que_ly, que_rx, que_ry;\n  que_lx.push(lsx);\n  que_ly.push(lsy);\n  que_rx.push(rsx);\n  que_ry.push(rsy);\n  while(!que_lx.empty()){\n\n    int lx = que_lx.front(); que_lx.pop();\n    int ly = que_ly.front(); que_ly.pop();\n    int rx = que_rx.front(); que_rx.pop();\n    int ry = que_ry.front(); que_ry.pop();\n    \n    if(LIN[lx][ly] == '%' && REN[rx][ry] == '%') return true;\n    REP(i, 4){\n      int nlx = lx + dx[i];\n      int nly = ly + dy[i];\n      int nrx = rx + dx[i];\n      int nry = ry + dy[(i+2)%4];\n      \n      if(!inside(nlx, nly) || LIN[nlx][nly] == '#') nlx = lx, nly = ly;\n      if(!inside(nrx, nry) || REN[nrx][nry] == '#') nrx = rx, nry = ry;\n      if(!visit[nlx][nly][nrx][nry]){\n        visit[nlx][nly][nrx][nry] = true;\n        que_lx.push(nlx);\n        que_ly.push(nly);\n        que_rx.push(nrx);\n        que_ry.push(nry);        \n      }\n    }\n  }\n  \n  return false;\n}\n\n\nint main(){\n  while(cin >> W >> H && H + W > 0){\n    REP(i, H) cin >> LIN[i] >> REN[i];\n    int rsx, rsy, lsx, lsy;\n    \n    REP(i, H)REP(j, W){\n      if(LIN[i][j] == 'L') lsx = i, lsy = j;\n      if(REN[i][j] == 'R') rsx = i, rsy = j;\n    }\n    cout << (bfs(lsx, lsy, rsx, rsy) ? \"Yes\" : \"No\") << endl;\n      \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\n\ntemplate<class T>\ninline bool chmax(T &a, const T &b) {\n    if(a<b) {\n        a=b;\n        return true;\n    }\n\n    return false;\n}\ntemplate<class T>\ninline bool chmin(T &a, const T &b) {\n    if(a>b) {\n        a=b;\n        return true;\n    }\n\n    return false;\n}\n\nint W,H;\nstring roomL[51],roomR[51];\n\nbool ok(P len,P rin) {\n    bool visited[51][51][51][51]={};\n    visited[len.fr][len.sc][rin.fr][rin.sc]=true;\n    queue<PP> que;\n    que.push(PP(len,rin));\n\n    while(que.size()) {\n        PP pp=que.front(); que.pop();\n        P next_len=pp.fr;\n        P next_rin=pp.sc;\n\n        //printf(\"[debug] %d %d %d %d\\n\",next_len.fr,next_len.sc,next_rin.fr,next_rin.sc);\n\n        if(roomL[next_len.fr][next_len.sc]=='%' && roomR[next_rin.fr][next_rin.sc]=='%') {\n            return true;\n        }\n        if(roomL[next_len.fr][next_len.sc]=='%' || roomR[next_rin.fr][next_rin.sc]=='%') {\n            visited[next_len.fr][next_len.sc][next_rin.fr][next_rin.sc]=false;\n            continue;\n        }\n        rep(i,4) {\n            next_len=pp.fr;\n            next_rin=pp.sc;\n\n            next_len.fr+=dy[i];\n            next_len.sc+=dx[i];\n            next_rin.fr+=dy[i];\n            next_rin.sc-=dx[i];\n\n            chmax(next_len.fr,0);\n            chmin(next_len.fr,H-1);\n            chmax(next_len.sc,0);\n            chmin(next_len.sc,W-1);\n            chmax(next_rin.fr,0);\n            chmin(next_rin.fr,H-1);\n            chmax(next_rin.sc,0);\n            chmin(next_rin.sc,W-1);\n\n            if(roomL[next_len.fr][next_len.sc]=='#') {\n                next_len.fr-=dy[i];\n                next_len.sc-=dx[i];\n            }\n            if(roomR[next_rin.fr][next_rin.sc]=='#') {\n                next_rin.fr-=dy[i];\n                next_rin.sc+=dx[i];\n            }\n\n            if(!visited[next_len.fr][next_len.sc][next_rin.fr][next_len.sc]) {\n                visited[next_len.fr][next_len.sc][next_rin.fr][next_len.sc]=true;\n                que.push(PP(next_len,next_rin));\n            }\n        }\n    }\n\n    return false;\n}\n\nvoid solve() {\n    rep(y,H) cin>>roomL[y]>>roomR[y];\n    P len,rin;\n    rep(y,H) rep(x,W) {\n        if(roomL[y][x]=='L') len=P(y,x);\n        if(roomR[y][x]=='R') rin=P(y,x);\n    }\n    if(ok(len,rin)) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n}\n\nint main() {\n    while(cin>>W>>H) {\n        if(!W) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_W 50\n#define MAX_H 50\n//深さ優先探索で行けるんじゃないか？\n\n\nint di[4] = {0, -1, 0, 1};\nint dj[4] = {1, 0, -1, 0};\nvector<vector<bool> > Room_L(MAX_H + 2, vector<bool> (MAX_W + 2, false));\nvector<vector<bool> > Room_R(MAX_H + 2, vector<bool> (MAX_W + 2, false));\nint si_L, si_R, sj_L, sj_R, gi_L, gi_R, gj_L, gj_R;  //スタートとゴールの座標\n\n\nint main(){\n\n    while(1){\n\n        //入力\n        int W, H; cin >> W >> H;\n        if(W == 0) break;\n\n        for(int i = 0; i <= H + 1; i++){\n            for(int j = 0; j <= W + 1; j++){\n                Room_L[i][j] = Room_R[i][j] = false;\n            }\n        }\n\n        for(int i = 1; i <= H; i++){\n            //L\n            for(int j = 1; j <= W; j++){\n                char input; cin >> input;\n                if(input == '#') continue;\n                else{\n                    Room_L[i][j] = true;\n\n                    if(input == '%'){\n                        gi_L = i;\n                        gj_L = j;\n                    }\n\n                    if(input == 'L'){\n                        si_L = i;\n                        sj_L = j;\n                    }\n                }\n            }\n\n            //R\n            for(int j = 1; j <= W; j++){\n                char input; cin >> input;\n                if(input == '#') continue;\n                else{\n                    Room_R[i][j] = true;\n\n                    if(input == '%'){\n                        gi_R = i;\n                        gj_R = j;\n                    }\n\n                    if(input == 'R'){\n                        si_R = i;\n                        sj_R = j;\n                    }\n                }\n            }\n        }\n\n\n            //幅優先をする\n        set<pair<pair<int, int>, pair<int, int> > > s;\n        queue<pair<pair<int, int>, pair<int, int> > > wait;                      //左の座標　右の座標\n        wait.push({ {si_L, sj_L}, {si_R, sj_R} });\n        s.insert({ {si_L, sj_L}, {si_R, sj_R} });\n        \n        bool can = false;\n\n        while(!wait.empty()){    //キュー画空になるまで\n\n\n            //キューの先頭要素を取り出す\n            int nowi_L = wait.front().first.first;\n            int nowj_L = wait.front().first.second;\n            int nowi_R = wait.front().second.first;\n            int nowj_R = wait.front().second.second;\n            //cout << nowi_L << \" \" << nowj_L << \"  \" << nowi_R << \" \" << nowj_R << endl;\n            wait.pop();\n\n            //四方向を探索\n            for(int k = 0; k < 4; k++){\n                int nexti_L = nowi_L + di[k];\n                int nextj_L = nowj_L + dj[k];\n                int nexti_R = nowi_R + di[k];\n                int nextj_R = nowj_R - dj[k];\n                //cout << \" \" << nexti_L << \" \" << nextj_L << \"  \" << nexti_R << \" \" << nextj_R << endl;\n\n\n                int L = Room_L[nexti_L][nextj_L];\n                int R = Room_R[nexti_R][nextj_R];\n                //cout << \" \" << L << \" \" << R << endl;\n                \n\n                //その方向に進めるなら\n                    if(nexti_L == gi_L && nextj_L == gj_L && nexti_R == gi_R && nextj_R == gj_R){\n                    can = true;\n                    break;\n                }else if((nexti_L == gi_L && nextj_L == gj_L) || (nexti_R == gi_R && nextj_R == gj_R)){\n                    continue;\n                }else if(R && L && s.find({{nexti_L, nextj_L}, {nexti_R, nextj_R}}) == s.end()){\n                    wait.push({{nexti_L, nextj_L}, {nexti_R, nextj_R}});\n                    s.insert({{nexti_L, nextj_L}, {nexti_R, nextj_R}});\n                }else if(R && !L && s.find({{nowi_L, nowj_L}, {nexti_R, nextj_R}}) == s.end()){\n                    wait.push({{nowi_L, nowj_L}, {nexti_R, nextj_R}});\n                    s.insert({{nowi_L, nowj_L}, {nexti_R, nextj_R}});\n                }else if(!R && L && s.find({{nexti_L, nextj_L}, {nowi_R, nowj_R}}) == s.end()){\n                    wait.push({{nexti_L, nextj_L}, {nowi_R, nowj_R}});\n                    s.insert({{nexti_L, nextj_L}, {nowi_R, nowj_R}});\n                }\n            }\n        }\n\n        if(can) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n        }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dh[]={1,0,-1,0};\nint dw[]={0,1,0,-1};\nint w,h;\nbool isrange(int x,int y){return 0<=x && x<h && 0<=y && y<w;};\nint main(){\n    \n    while(cin>>w>>h,w){\n        vector<string> rl(h),rr(h);\n        for(int i=0;i<h;i++){\n            cin>>rl[i]>>rr[i];\n        }\n        pair<int,int> lp;\n        pair<int,int> rp;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(rl[i][j]=='L') lp={i,j};\n                if(rr[i][j]=='R') rp={i,j};\n            }\n        }\n        queue<pair<pair<int,int>,pair<int,int>>> que;\n        que.push({lp,rp});\n        set<pair<pair<int,int>,pair<int,int>>> dp;\n        dp.insert({lp,rp});\n        \n        auto move=[&rl,&rr](int x,int dx,int y,int dy,bool isr){\n            if(!isrange(x+dx,y+dy)){\n                return make_pair(min(max(x+dx,0),h-1),min(max(y+dy,0),w-1));\n            }\n            if(isr){\n                if(rr[x+dx][y+dy]=='#') return make_pair(x,y);\n                else return make_pair(x+dx,y+dy);\n            }\n            else{\n                if(rl[x+dx][y+dy]=='#') return make_pair(x,y);\n                else return make_pair(x+dx,y+dy);\n            }\n        };\n        while(!que.empty()){\n            auto p=que.front();\n            que.pop();\n            for(int i=0;i<4;i++){\n                auto tol=move(p.first.first,dh[i],p.first.second,dw[i],0);\n                auto tor=move(p.second.first,dh[i],p.second.second,dw[(i+2)%2],1);\n                pair<pair<int,int>,pair<int,int>> tost={tol,tor};\n                if(dp.count({tol,tor})) continue;\n                dp.insert(tost);\n                que.push(tost);\n            }\n        }\n        pair<int,int> obl;\n        pair<int,int> obr;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(rl[i][j]=='%') obl={i,j};\n                if(rr[i][j]=='%') obr={i,j};\n            }\n        }\n        if(dp.count({obl,obr})) cout<<\"Yes\"<<endl;\n        else cout<<\"No\"<<endl;\n    }\n\n\n\n    return 0;\n}   "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <array>\n#include <queue>\n#include <array>\n#include <stack>\n\nenum PassageType{\n\tFREE, WALL, SEARCHED, GOAL,\n};\n\nbool isSearched[50][50][50][50] = {false};\n\nstruct Point {\n\tPoint() { x = 0; y = 0; };\n\tPoint(int x, int y) {\n\t\tthis->x = x;\n\t\tthis->y = y;\n\t};\n\tint x, y;\n};\n\nint main() {\n\tint w, h;\n\n\twhile (std::cin >> w >> h && w && h) {\n\t\tstd::memset(isSearched, false, sizeof(bool) * 50 * 50 * 50 * 50);\n\t\tstd::array<std::vector<std::vector<int>>, 2> room;\n\t\tPoint start[2];\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tstd::array<std::string, 2> str;\n\t\t\tfor (int j = 0; j < str.size(); j++) {\n\t\t\t\tstd::cin >> str[j];\n\t\t\t\troom[j].push_back(std::vector<int>());\n\t\t\t\tfor (int k = 0; k < str[j].size(); k++) {\n\t\t\t\t\tint type = 0;\n\t\t\t\t\tif (str[j][k] == '.') type = FREE;\n\t\t\t\t\telse if (str[j][k] == '#') type = WALL;\n\t\t\t\t\telse if (str[j][k] == '%') type = GOAL;\n\t\t\t\t\telse if (str[j][k] == 'L' || str[j][k] == 'R') {\n\t\t\t\t\t\tstart[j].x = k;\n\t\t\t\t\t\tstart[j].y = i;\n\t\t\t\t\t\ttype = SEARCHED;\n\t\t\t\t\t}\n\t\t\t\t\troom[j].back().push_back(type);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstd::stack<std::pair<Point, Point>> s;\n\t\ts.push(std::make_pair(start[0], start[1]));\n\t\tint dx[] = {1, 0, -1, 0};\n\t\tint dy[] = {0, 1, 0, -1};\n\n\t\tbool isOk = false;\n\t\twhile (!s.empty() && !isOk) {\n\t\t\tauto node = s.top(); s.pop();\n\n\t\t\t//?¬???????????????´????????¢???\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tauto next = node;\n\t\t\t\tnext.first.x += dx[i];\n\t\t\t\tnext.first.y += dy[i];\n\t\t\t\tnext.second.x -= dx[i];\n\t\t\t\tnext.second.y += dy[i];\n\n\t\t\t\t//??´????£???£\n\t\t\t\tnext.first.x = std::min(std::max(0, next.first.x), w - 1);\n\t\t\t\tnext.first.y = std::min(std::max(0, next.first.y), h - 1);\n\t\t\t\tnext.second.x = std::min(std::max(0, next.second.x), w - 1);\n\t\t\t\tnext.second.y = std::min(std::max(0, next.second.y), h - 1);\n\n\t\t\t\t//??????????????´????????????OK\n\t\t\t\tif (room[0][next.first.y][next.first.x] == GOAL && room[1][next.second.y][next.second.x] == GOAL) {\n\t\t\t\t\tisOk = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint r[2] = {room[0][next.first.y][next.first.x], room[1][next.second.y][next.second.x] };\n\t\t\t\t\t//?£???????????????????????????????\n\t\t\t\t\tif (room[0][next.first.y][next.first.x] == WALL) {\n\t\t\t\t\t\tnext.first = node.first;\n\t\t\t\t\t}\n\t\t\t\t\tif (room[1][next.second.y][next.second.x] == WALL) {\n\t\t\t\t\t\tnext.second = node.second;\n\t\t\t\t\t}\n\t\t\t\t\tif (!isSearched[next.first.y][next.first.x][next.second.y][next.second.x]) {\n\t\t\t\t\t\ts.push(next);\n\t\t\t\t\t\tisSearched[next.first.y][next.first.x][next.second.y][next.second.x] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstd::cout << (isOk ? \"Yes\" : \"No\") << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <complex>\nusing namespace std;\ntypedef complex<int> P;\n\nint main()\n{\n  int W, H;\n  while (cin >> W >> H && W != 0) {\n    vector<string> roomL(H), roomR(H);\n    P startL, startR;\n    for (int i = 0; i < H; i++) {\n      cin >> roomL[i] >> roomR[i];\n      for (int j = 0; j < W; j++) {\n        if (roomL[i][j] == 'L') {\n          roomL[i][j] = '.';\n          startL = P(i, j);\n        }\n        if (roomR[i][j] == 'R') {\n          roomR[i][j] = '.';\n          startR = P(i, j);\n        }\n      }\n    }\n\n    queue<pair<P,P> > q;\n    q.push(make_pair(startL, startR));\n    vector<vector<bool> > visited(W*H, vector<bool>(W*H, false));\n    visited[startL.real()*W + startL.imag()][startR.real()*W + startR.imag()] = true;\n    while (!q.empty()) {\n      const pair<P, P> p = q.front();\n      q.pop();\n      if (roomL[p.first.real()][p.first.imag()] == '%'\n          && roomR[p.second.real()][p.second.imag()] == '%') {\n        cout << \"Yes\" << endl;\n        goto NEXT;\n      }\n\n      for (int d = 0; d < 4; d++) {\n        static const P dir[] = {P(-1,0), P(1,0), P(0,-1), P(0,1)};\n        P nextL = p.first + dir[d];\n        P nextR = p.second + P(dir[d].real(), dir[d].imag() == -1 ? 1 : (dir[d].imag() == 1 ? -1 : 0));\n        if (0 <= nextL.real() && nextL.real() < H\n            && 0 <= nextL.imag() && nextL.imag() < W\n            && 0 <= nextR.real() && nextR.real() < H\n            && 0 <= nextR.imag() && nextR.imag() < W) {\n          if (roomL[nextL.real()][nextL.imag()] == '#') {\n            nextL = p.first;\n          }\n          if (roomR[nextR.real()][nextR.imag()] == '#') {\n            nextR = p.second;\n          }\n          if (!visited[nextL.real()*W + nextL.imag()][nextR.real()*W + nextR.imag()]) {\n            q.push(make_pair(nextL, nextR));\n            visited[nextL.real()*W + nextL.imag()][nextR.real()*W + nextR.imag()] = true;\n          }\n        }\n      }\n    }\n    cout << \"No\" << endl;\nNEXT:\n    ;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < n; i++ )\n#define M 50\nconst int di[4] = {0, -1, 0, 1};\nconst int dj[4] = {1, 0, -1, 0};\nchar L[M][M], R[M][M];\n\nint W, H, lg, rg;\n\nbool check(int y, int x){\n    return 0 <= y && 0 <= x && y < H && x < W;\n}\nbool dfs(int lp, int rp){\n    bool V[M*M][M*M];\n    rep(i, W*H) rep(j, W*H) V[i][j] = false;\n    stack<pair<int, int> > S;\n    S.push(make_pair(lp, rp));\n    pair<int, int> u, v;\n    while(!S.empty()){\n\tu = S.top(); S.pop();\n\tlp = u.first; rp = u.second;\n\tif ( lp == lg && rp == rg ) return true;\n\tif ( lp == lg || rp == rg ) continue;\n\tint lny, lnx, rny, rnx;\n\trep(d, 4){\n\t    lny = lp/W + di[d];\n\t    lnx = lp%W + dj[d];\n\t    rny = rp/W + ((d%2==1)?di[d]:di[(d+2)%4]);\n\t    rnx = rp%W + ((d%2==1)?dj[d]:dj[(d+2)%4]);\n\t    if ( !(check(lny, lnx) && L[lny][lnx] != '#')) { lny = lp/W; lnx = lp%W; }\n\t    if ( !(check(rny, rnx) && R[rny][rnx] != '#')) { rny = rp/W; rnx = rp%W; }\n\t    int l = lny*W+lnx;\n\t    int r = rny*W+rnx;\n\t    if ( !V[l][r] ) { V[l][r] = true; S.push(make_pair(l, r));}\n\t}\n    }\n    return false;\n}\n\nmain(){\n    int lp, rp;\n    while( cin >> W >> H && W ){\n\trep(i, H) {\n\t    rep(j, W) {\n\t\tcin >> L[i][j];\n\t\tif ( L[i][j] == 'L' ) lp = i*W+j;\n\t\tif ( L[i][j] == '%' ) lg = i*W+j;\n\t    }\n\t    rep(j, W) {\n\t\tcin >> R[i][j];\n\t\tif ( R[i][j] == 'R' ) rp = i*W+j;\n\t\tif ( R[i][j] == '%' ) rg = i*W+j;\n\t    }\n\t}\n\tif ( dfs(lp, rp) ) cout << \"Yes\" << endl;\n\telse cout << \"No\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_W = 52;\nconst int MAX_H = 52;\nconst int MAX_WH = MAX_W * MAX_H;\n\n/* typedef */\n\nstruct Stat {\n  int lpos, rpos;\n  Stat() {};\n  Stat(int _lp, int _rp): lpos(_lp), rpos(_rp) {}\n};\n\n/* global variables */\n\nbool lflds[MAX_WH], rflds[MAX_WH], used[MAX_WH][MAX_WH];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int w, h, w2;\n  int lspos, rspos, lgpos, rgpos;\n  \n  for (;;) {\n    cin >> w >> h;\n    if (w == 0) break;\n\n    w2 = w + 2;\n    memset(lflds, false, sizeof(lflds));\n    memset(rflds, false, sizeof(rflds));\n\n    for (int y = 1; y <= h; y++) {\n      string lline, rline;\n      cin >> lline >> rline;\n\n      for (int x = 1; x <= w; x++) {\n\tint pos = y * w2 + x;\n\n\tswitch (lline[x - 1]) {\n\tcase '.': lflds[pos] = true; break;\n\tcase 'L': lspos = pos; lflds[pos] = true; break;\n\tcase '%': lgpos = pos; lflds[pos] = true; break;\n\t}\n\n      \tswitch (rline[x - 1]) {\n\tcase '.': rflds[pos] = true; break;\n\tcase 'R': rspos = pos; rflds[pos] = true; break;\n\tcase '%': rgpos = pos; rflds[pos] = true; break;\n\t}\n      }\n    }\n    //printf(\"lspos(%d,%d), rspos(%d,%d)\\n\",\n    //lspos % w2, lspos / w2, rspos % w2, rspos / w2);\n    //printf(\"lgpos(%d,%d), rgpos(%d,%d)\\n\",\n    //lgpos % w2, lgpos / w2, rgpos % w2, rgpos / w2);\n\n    int ldpos[] = { 1, -w2, -1, w2};\n    int rdpos[] = {-1, -w2,  1, w2};\n\n    queue<Stat> q;\n    q.push(Stat(lspos, rspos));\n\n    memset(used, false, sizeof(used));\n    used[lspos][rspos] = true;\n\n    bool ok = false;\n    \n    while (! q.empty()) {\n      Stat u = q.front(); q.pop();\n      //printf(\"L(%d,%d), R(%d,%d)\\n\",\n      //u.lpos % w2, u.lpos / w2, u.rpos % w2, u.rpos / w2);\n      \n      if (u.lpos == lgpos && u.rpos == rgpos) {\n\tok = true;\n\tbreak;\n      }\n      if (u.lpos == lgpos || u.rpos == rgpos) continue;\n\n      for (int di = 0; di < 4; di++) {\n\tint vlpos = u.lpos + ldpos[di];\n\tif (! lflds[vlpos]) vlpos = u.lpos;\n\n\tint vrpos = u.rpos + rdpos[di];\n\tif (! rflds[vrpos]) vrpos = u.rpos;\n\n\tif (! used[vlpos][vrpos]) {\n\t  used[vlpos][vrpos] = true;\n\t  q.push(Stat(vlpos, vrpos));\n\t}\n      }\n    }\n\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP(a, b) make_pair(a, b)\n#define Y first\n#define X second\n#define L first\n#define R second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef pair<pi, pi> pipi;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint W, H, used[52][52][52][52];\nint dy[] = {0,-1,0,1}, dx[] = {-1,0,1,0};\nchar len[52][52], rin[52][52];\n\nstruct P{\n  int rx, ry, lx, ly;\n  P(int ly, int lx, int ry, int rx):ly(ly),lx(lx),ry(ry),rx(rx){};\n};\n\nint main(){\n  while(scanf(\"%d%d\", &W, &H) && W){\n    rep(i, H) scanf(\"%s%s\", len[i], rin[i]);\n\n    int ly, lx, ry, rx;\n    rep(i, H) rep(j, W){\n      if(len[i][j] == 'L'){ ly = i, lx = j; len[i][j] = '.';}\n      if(rin[i][j] == 'R'){ ry = i, rx = j; rin[i][j] = '.';}\n    }\n\n    memset(used, 0, sizeof(used));\n    queue<P>q;\n    q.push(P(ly, lx, ry, rx));\n    used[ly][lx][ry][rx] = 1;\n\n    while(!q.empty()){\n      P now = q.front(); q.pop();\n      rep(d, 4){\n\tint nly, nlx, nry, nrx;\n\tif(d%2){\n\t  nly = now.ly + dy[d], nlx = now.lx;\n\t  if(nly < 0 || nly >= H || len[nly][nlx] == '#') nly = now.ly; \n\t  nry = now.ry + dy[d], nrx = now.rx;\n\t  if(nry < 0 || nry >= H || rin[nry][nrx] == '#') nry = now.ry; \n\t}else{\n\t  nly = now.ly, nlx = now.lx + dx[d];\n\t  if(nlx < 0 || nlx >= W || len[nly][nlx] == '#') nlx = now.lx; \t    \n\t  nry = now.ry, nrx = now.rx + -1*dx[d];\n\t  if(nrx < 0 || nrx >= W || rin[nry][nrx] == '#') nrx = now.rx;\n\t}\n\n\t  //\t  pipi next = MP(MP(nly, nlx), MP(nry, nrx));\n\tif(len[nly][nlx] == '%' && rin[nry][nrx] == '%'){\n\t  puts(\"Yes\"); goto e;\n\t}\n\tif(len[nly][nlx] == '%' || rin[nry][nrx] == '%') continue;\n       \n\tif(used[nly][nlx][nry][nrx] != 0) continue;\n\t//\t  printf(\"%d %d %d %d\\n\", next.L.Y, next.L.X, next.R.Y, next.R.X);\n\tq.push(P(nly, nlx, nry, nrx));\n\tused[nly][nlx][nry][nrx] = 1;\n      }\n    }\n    puts(\"No\");\n  e:;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,s,n) for(int i=s; i<n; i++)\n#define ALL(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nint w, h;\nbool wl[55][55], wr[55][55];\nbool memo[55][55][55][55];\nint gxl, gyl, gxr, gyr;\n\nbool dfs(int xl, int yl, int xr, int yr) {\n\tif( memo[xl][yl][xr][yr] ) {\n\t\treturn false;\n\t}\n//\tcout << \"dfs \" << xl << \" \" << yl << \" \" << xr << \" \" << yr << endl;\n\tmemo[xl][yl][xr][yr] = true;\n\tif(xl==gxl && yl==gyl && xr==gxr && yr==gyr) {\n\t\treturn true;\n\t}\n\tint dx[4] = {-1, 0, 1, 0};\n\tint dy[4] = {0, 1, 0, -1};\n\tbool f = false;\n\trep(i, 4) {\n\t\tint nxl = xl + dx[i];\n\t\tint nyl = yl + dy[i];\n\t\tint nxr = xr - dx[i];\n\t\tint nyr = yr + dy[i];\n\t\tbool nl = wl[nyl][nxl];\n\t\tbool nr = wr[nyr][nxr];\n\t\tif( !nl && !nr && !memo[nxl][nyl][nxr][nyr] ) {\n\t\t\tf |= dfs(nxl, nyl, nxr, nyr);\n\t\t}\n\t\telse if( !nl && nr && !memo[nxl][nyl][xr][yr] ) {\n\t\t\tf |= dfs(nxl, nyl, xr, yr);\n\t\t}\n\t\telse if( nl && !nr && !memo[xl][yl][nxr][nyr] ) {\n\t\t\tf |= dfs(xl, yl, nxr, nyr);\n\t\t}\n\t}\n\treturn f;\n}\n\nint main() {\n\twhile(cin >> w >> h, w) {\n\t\trep(i,55) rep(j,55) wl[i][j] = wr[i][j] = true;\n\t\trep(i,55) rep(j,55) rep(k,55) rep(l,55) memo[i][j][k][l]=false;\n\t\tint xl=1, yl=1, xr=1, yr=1;\n\t\trep(y, h) {\n\t\t\tstring sl, sr;\n\t\t\tcin >> sl >> sr;\n\t\t\trep(x, w) {\n\t\t\t\tif(sl[x] == 'L') {\n\t\t\t\t\txl = x+1;\n\t\t\t\t\tyl = y+1;\n\t\t\t\t\twl[y+1][x+1] = false;\n\t\t\t\t} else if(sl[x] == '%') {\n\t\t\t\t\tgxl = x+1;\n\t\t\t\t\tgyl = y+1;\n\t\t\t\t\twl[y+1][x+1] = false;\n\t\t\t\t} else {\n\t\t\t\t\twl[y+1][x+1] = (sl[x]=='#');\n\t\t\t\t}\n\t\t\t\tif(sr[x] == 'R') {\n\t\t\t\t\txr = x+1;\n\t\t\t\t\tyr = y+1;\n\t\t\t\t\twr[y+1][x+1] = false;\n\t\t\t\t} else if(sr[x] == '%') {\n\t\t\t\t\tgxr = x+1;\n\t\t\t\t\tgyr = y+1;\n\t\t\t\t\twr[y+1][x+1] = false;\n\t\t\t\t} else {\n\t\t\t\t\twr[y+1][x+1] = (sr[x]=='#');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( dfs(xl, yl, xr, yr) ) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t} else {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//50\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nchar g[2][50][50];\nbool p[50][50][50][50];\nint w,h;\n    \nbool dfs(int x,int y,int xx,int yy,int r){\n  if(r==0)return false;\n  if(p[x][y][xx][yy]++||(g[0][y][x]=='%'^g[1][yy][xx]=='%'))return false;\n  if(g[0][y][x]=='%'&&g[1][yy][xx]=='%')return true;\n  for(int i=0;i<4;i++){\n    int dy[]={0,1,0,-1};\n    int dx[][4]={{1,0,-1,0},{-1,0,1,0}};\n    int nx[2],ny[2];\n    nx[0]=x+dx[0][i];\n    ny[0]=y+dy[i];\n    nx[1]=xx+dx[1][i];\n    ny[1]=yy+dy[i];\n    for(int j=0;j<2;j++){\n      if(nx[j]<0||w<=nx[j]||ny[j]<0||h<=ny[j]||g[j][ny[j]][nx[j]]=='#'){\n\tnx[j]-=dx[j][i];\n\tny[j]-=dy[i];\n      }\n    }\n    if(dfs(nx[0],ny[0],nx[1],ny[1],r-1))return true;\n  }\n  return false;\n}\n\nint main(){\n  while(cin>>w>>h,w|h){\n    int px[2],py[2];\n    for(int y=0;y<h;y++){\n      for(int i=0;i<2;i++){\n\tfor(int x=0;x<w;x++){\n\t  cin>>g[i][y][x];\n\t  if(g[i][y][x]=='R'||g[i][y][x]=='L'){\n\t    px[i]=x;\n\t    py[i]=y;\n\t  }\n\t}\n      }\n    }\n    fill(p[0][0][0],p[50][0][0],false);\n    cout<<(dfs(px[0],py[0],px[1],py[1],10000)?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nconst int N = 50;\n\nint h, w;\n\nbool visited[N][N][N][N];\nchar data[2][N][N];\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nbool dfs(int ly, int lx, int ry, int rx){\n  //cout << ly << ' ' << lx << ' ' << ry << ' ' << rx << endl;\n  if(data[0][ly][lx] == '%' && data[1][ry][rx] == '%') return true;\n  else if(data[0][ly][lx] == '%' || data[1][ry][rx] == '%') return false;\n  visited[ly][lx][ry][rx] = true;\n  for(int i=0;i<4;i++){\n    int lty = ly + dy[i];\n    int ltx = lx + dx[i];\n    int rty = ry + dy[i];\n    int rtx = rx - dx[i];\n    //cout << \"       \" << lty << ' ' << ltx << ' ' << rty << ' ' << rtx << endl;\n    if(lty<0 || lty>=h) continue;\n    if(ltx<0 || ltx>=w) continue;\n    if(rty<0 || rty>=h) continue;\n    if(rtx<0 || rtx>=w) continue;\n    if(data[0][lty][ltx] == '#'){\n      lty = ly;\n      ltx = lx;\n    }\n    if(data[1][rty][rtx] == '#'){\n      rty = ry;\n      rtx = rx;\n    }\n    if(visited[lty][ltx][rty][rtx]) continue;\n    if(dfs(lty, ltx, rty, rtx)) return true;\n  }\n  return false;\n}\n\nmain(){\n  int slx, sly, srx, sry;\n  while(cin >> w >> h){\n    if(h == 0 && w == 0) break;\n    for(int i=0;i<h;i++){\n      for(int k=0;k<2;k++){\n\tfor(int j=0;j<w;j++){\n\t  cin >> data[k][i][j];\n\t  if(data[k][i][j] == 'L'){\n\t    slx = j;\n\t    sly = i;\n\t    data[k][i][j] = '.';\n\t  }else if(data[k][i][j] == 'R'){\n\t    srx = j;\n\t    sry = i;\n\t    data[k][i][j] = '.';\n\t  }\n\t}\n      }\n    }\n    if(dfs(sly, slx, sry, srx)) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MAX 51\n#include<cstring>\nusing namespace std;\n\nbool f=false,visited[MAX][MAX][MAX][MAX];\nint w,h;\nchar L[MAX][MAX],R[MAX][MAX];\n\nint ldy[]={0,-1,0,1};\nint ldx[]={1,0,-1,0};\nint rdy[]={0,-1,0,1};\nint rdx[]={-1,0,1,0};\n\nvoid dfs(int ly,int lx, int ry, int rx){\n  visited[ly][lx][ry][rx] = true;\n\n  int nly,nlx,nry,nrx;\n  for(int i=0; i<4; i++){\n    nly = ly + ldy[i];\n    nlx = lx + ldx[i];\n    nry = ry + rdy[i];\n    nrx = rx + rdx[i];\n\n    if(!visited[nly][nlx][nry][nrx] &&\n       0<=nly && nly<h && 0<=nlx && nlx<w && 0<=nry && nry<h && 0<=nrx && nrx<w){\n      if(L[nly][nlx]=='%' && R[nry][nrx]=='%'){\n\tf = true;\n\treturn ;\n      }\n      //if(L[nly][nlx]=='%' || R[nry][nrx]=='%') visited[nly][nlx][nry][nrx] = true;\n      if(L[nly][nlx]=='#' && R[nry][nrx]=='.') dfs(ly,lx,nry,nrx);\n      if(L[nly][nlx]=='.' && R[nry][nrx]=='#') dfs(nly,nlx,ry,rx);\n      if(L[nly][nlx]=='.' && R[nry][nrx]=='.')  dfs(nly,nlx,nry,nrx);\n    }\n    if((nlx<0 || w<=nlx) && (0<=nrx && nrx<w) && R[nry][nrx]=='.')    dfs(ly,lx,nry,nrx);\n    if((nrx<0 || w<=nrx) && (0<=nlx && nlx<w) && L[nly][nlx]=='.')    dfs(nly,nlx,ry,rx);\n    if((nry<0 || w<=nry) && (0<=nly && nly<w) && L[nly][nlx]=='.')    dfs(nly,nlx,ry,rx);\n    if((nly<0 || w<=nly) && (0<=nry && nry<w) && R[nly][nlx]=='.')    dfs(ly,lx,nry,nrx);\n      \n  }\n}\n\n\nint main(){\n\n  while(cin >> w >> h ,w|h){\n    cin.ignore();\n\n    for(int i=0; i<h; i++){\n      string str;\n      getline(cin,str);\n      bool first=true;\n      int cnt = 0;\n      for(int j=0; j<str.size(); j++){\n\tif(str[j]==' '){\n\t  first = false;\n\t  continue;\n\t}\n\tif(first) L[i][j] = str[j];\n\telse R[i][cnt++] = str[j];\n      }\n    }\n    int sly,slx,sry,srx;\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tif(L[i][j]=='L'){\n\t  sly = i;\n\t  slx = j;\n\t}\n\tif(R[i][j]=='R'){\n\t  sry = i;\n\t  srx = j;\n\t}\n      }\n    }\n\n    f = false;\n    memset(visited,false,sizeof(visited));\n    visited[sly][slx][sry][srx]=true;\n    dfs(sly,slx,sry,srx);\n    if(f) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp make_pair\n#define pb push_back\n#define F first\n#define S second\n\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nmain(){\n  int w,h;\n  while(cin>>w>>h,w|h){\n    string lr[h],rr[h];\n    rep(i,h){\n      cin>>lr[i]>>rr[i];\n    }\n\n    string ans=\"No\";\n    int rsx,rsy,lsx,lsy;\n    rep(i,h)rep(j,w){\n      if(lr[i][j]=='L')lsx=i,lsy=j;\n      if(rr[i][j]=='R')rsx=i,rsy=j;\n    }\n\n    queue<pair<PI,PI> > Q;\n    set<pair<PI,PI> > app;\n    app.insert(mp(mp(lsx,lsy),mp(rsx,rsy)));\n    Q.push(mp(mp(lsx,lsy),mp(rsx,rsy)));\n\n    while(!Q.empty()){\n      PI tp=Q.front().F;\n      int clx,cly,crx,cry;\n      clx=tp.F,cly=tp.S;\n      tp=Q.front().S;Q.pop();\n      crx=tp.F,cry=tp.S;\n      if(lr[clx][cly]=='%' && rr[crx][cry]=='%'){\n        ans=\"Yes\";\n        break;\n      }\n      if(lr[clx][cly]=='%' || rr[crx][cry]=='%')continue;\n\n      rep(i,4){\n        int nrx=crx+dx[i],nlx=clx+dx[i],nry=cry+dy[i],nly=cly-dy[i];\n        if(nrx<0 || nry<0 || nrx>=h || nry>=w)nrx=crx,nry=cry;\n        if(nlx<0 || nly<0 || nlx>=h || nly>=w)nlx=clx,nly=cly;\n        if(lr[nlx][nly]=='#'){\n          nlx=clx;\n          nly=cly;\n        }\n        if(rr[nrx][nry]=='#'){\n          nrx=crx;\n          nry=cry;\n        }\n        if(app.count(mp(mp(nlx,nly),mp(nrx,nry))))continue;\n        app.insert(mp(mp(nlx,nly),mp(nrx,nry)));\n        Q.push(mp(mp(nlx,nly),mp(nrx,nry)));\n      }\n/*      \n      rep(i,h){\n        rep(j,w){\n          if(clx==i && cly==j)cout<<'L';\n          else if(lr[i][j]=='L')cout<<'.';\n          else cout<<lr[i][j];\n        }\n        cout<<\" \";\n        rep(j,w){\n          if(crx==i && cry==j)cout<<'R';\n          else if(rr[i][j]=='R')cout<<'.';\n          else cout<<rr[i][j];\n        }\n        cout<<endl;\n      }\n      cout<<endl;\n*/\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nint w,h;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nvector<bool> reach[50][50][50];\nvector<string> lroom,rroom;\nbool flag;\nqueue<tuple<int,int,int,int> > sa;\n// h w h w\nbool outrange(int v,int l,int r){\n  return v<l || r<=v;\n}\nvoid bfs(tuple<int,int,int,int> pos){\n  int ly,lx,ry,rx;\n  tie(ly,lx,ry,rx)=pos;\n  if(lroom[ly][lx]=='%' && rroom[ry][rx]=='%'){\n    flag=true;\n    return;\n  }\n  if(lroom[ly][lx]=='%' || rroom[ry][rx]=='%') return;\n  if(reach[ly][lx][ry][rx]) return;\n  reach[ly][lx][ry][rx]=true;\n  REP(i,4){\n    int nly=ly+dy[i],nlx=lx+dx[i],nry=ry+dy[i],nrx=rx-dx[i];\n    if(outrange(nly,0,h) ||\n       outrange(nlx,0,w) ||\n       lroom[nly][nlx] == '#')\n      nly=ly,nlx=lx;\n    if(outrange(nry,0,h) ||\n       outrange(nrx,0,w) ||\n       rroom[nry][nrx] == '#')\n      nry=ry,nrx=rx;\n    sa.push(make_tuple(nly,nlx,nry,nrx));\n  }\n}\nint main(void)\n{\n  for(;;){\n    cin >> w >> h;\n    if(!w && !h) return 0;\n    REP(i,h) REP(j,w) REP(k,h) reach[i][j][k].assign(w,false);\n    lroom.resize(h);\n    rroom.resize(h);\n    REP(i,h) cin >> lroom[i] >> rroom[i];\n    while(!sa.empty()) sa.pop();\n    flag=false;\n    int ly,lx,ry,rx;\n    REP(i,h) REP(j,w) if(lroom[i][j]=='L') ly=i,lx=j;\n    REP(i,h) REP(j,w) if(rroom[i][j]=='R') ry=i,rx=j;\n    sa.push(make_tuple(ly,lx,ry,rx));\n    while(!sa.empty()){\n      auto pos=sa.front();\n      sa.pop();\n      bfs(pos);\n    }\n\n    if(flag) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n\nbool b[103][52][103][52] = {};\n\n\nint main() {\n\n  while( true ) {\n\n    long long int w, h;\n    cin >> w >> h;\n\n    if ( w == 0 ) break;\n\n    vector< string > map;\n\n    map.push_back( \"##############################################################################################################\" );\n\n    long long int rx, ry, lx, ly;\n\n    for ( long long int y = 1; y <= h; y++ ) {\n\n      string in_L, in_R;\n      cin >> in_L >> in_R;\n\n      string in = \"#\" + in_L + \"#\" + in_R + \"#\";\n      map.push_back( in );\n\n      for ( long long int x = 0; x < in.size(); x++ ) {\n\n\tif ( map[y][x] == 'R' ) {\n\t  rx = x;\n\t  ry = y;\n\t}\n\tif ( map[y][x] == 'L' ) {\n\t  lx = x;\n\t  ly = y;\n\t}\n\n      }\n\n    }\n\n    map.push_back( \"##############################################################################################################\" );\n\n\n    for ( long long int y = 0; y < map.size(); y++ ) {\n      for ( long long int x = 0; x < map[0].size(); x++ ) {\n\tfor ( long long int y2 = 0; y2 < map.size(); y2++ ) {\n\t  for ( long long int x2 = 0; x2 < map[0].size(); x2++ ) {\n\t    b[x][y][x2][y2] = false;\n\t  }\n\t}\n      }\n    }\n\n\n    queue< vector< long long int > > q;\n    vector< long long int > v;\n    v.push_back( rx );\n    v.push_back( ry );\n    v.push_back( lx );\n    v.push_back( ly );\n    q.push( v );\n\n\n    while( q.size() > 0 ) {\n\n      rx = q.front()[0];\n      ry = q.front()[1];\n      lx = q.front()[2];\n      ly = q.front()[3];\n      q.pop();\n\n      if ( b[ rx ][ ry ][ lx ][ ly ] == true ) continue;\n\n      b[ rx ][ ry ][ lx ][ ly ] = true;\n\n\n      if ( map[ry][rx] == '%' && map[ly][lx] == '%' ) {\n\tcout << \"Yes\" << endl;\n\treturn 0;\n      }else if ( map[ry][rx] == '%' ) {\n\tcout << \"No\" << endl;\n\treturn 0;\n      }else if ( map[ly][lx] == '%' ) {\n\tcout << \"No\" << endl;\n\treturn 0;\n      }\n\n      //      cout << rx << \" \" << ry << \" \" << lx << \" \" << ly << endl;\n\n\n      v.clear();\n      if ( map[ ry ][ rx + 1 ] == '#' ) {\n\tv.push_back( rx );\n      }else {\n\tv.push_back( rx + 1 );\n      }\n      v.push_back( ry );\n      if ( map[ ly ][ lx - 1 ] == '#' ) {\n\tv.push_back( lx );\n      }else {\n\tv.push_back( lx - 1 );\n      }\n      v.push_back( ly );\n      q.push( v );\n\n      v.clear();\n      v.push_back( rx );\n      if ( map[ ry - 1 ][ rx ] == '#' ) {\n\tv.push_back( ry );\n      }else {\n\tv.push_back( ry - 1 );\n      }\n      v.push_back( lx );\n      if ( map[ ly - 1 ][ lx ] == '#' ) {\n\tv.push_back( ly );\n      }else {\n\tv.push_back( ly - 1 );\n      }\n      q.push( v );\n\n      v.clear();\n      if ( map[ ry ][ rx - 1 ] == '#' ) {\n\tv.push_back( rx );\n      }else {\n\tv.push_back( rx - 1 );\n      }\n      v.push_back( ry );\n      if ( map[ ly ][ lx + 1 ] == '#' ) {\n\tv.push_back( lx );\n      }else {\n\tv.push_back( lx + 1 );\n      }\n      v.push_back( ly );\n      q.push( v );\n\n      v.clear();\n      v.push_back( rx );\n      if ( map[ ry + 1 ][ rx ] == '#' ) {\n\tv.push_back( ry );\n      }else {\n\tv.push_back( ry + 1 );\n      }\n      v.push_back( lx );\n      if ( map[ ly + 1 ][ lx ] == '#' ) {\n\tv.push_back( ly );\n      }else {\n\tv.push_back( ly + 1 );\n      }\n      q.push( v );\n\n    }\n\n    cout << \"No\" << endl;\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<queue>\nusing namespace std;\n#define REP(i, a, n) for(int i=a; i<n; i++)\n\nbool hist[51][51][51][51];\n\nstruct State {\n\tint xL, yL, xR, yR;\n};\n\nint main() {\n\tint w, h;\n\n\tint dx[4] = { 0, 1, 0, -1 }; // ????????????\n\tint dy[4] = { -1, 0, 1, 0 };\n\n\twhile (cin >> w >> h, w || h) {\n\t\tState st;\n\t\tchar Len[51][51];\n\t\tchar Rin[51][51];\n\t\t//bool hist[51][51][51][51] = { false };\n\t\thist[51][51][51][51] = { false };\n\n\t\t/* crate maze */\n\t\tREP(i, 0, h) {\n\t\t\tREP(j, 0, w) {\n\t\t\t\tcin >> Len[i][j];\n\t\t\t\tif (Len[i][j] == 'L') {\n\t\t\t\t\tst.yL = i;\n\t\t\t\t\tst.xL = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(j, 0, w) {\n\t\t\t\tcin >> Rin[i][j];\n\t\t\t\tif (Rin[i][j] == 'R') {\n\t\t\t\t\tst.yR = i;\n\t\t\t\t\tst.xR = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* BFS */\n\t\tqueue<State> qu;\n\t\tqu.push(st);\n\t\thist[st.yL][st.xL][st.yR][st.xR] = true;\n\t\tbool flag = false;\n\n\t\twhile (!qu.empty()) {\n\t\t\tState q = qu.front();\n\t\t\tqu.pop();\n\n\t\t\tint yl = q.yL, xl = q.xL, yr = q.yR, xr = q.xR;\n\t\t\tif (Len[yl][xl] == '%' && Rin[yr][xr] == '%') {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (Len[yl][xl] == '%' || Rin[yr][xr] == '%') continue;\n\t\t\tfor (int k = 0; k<4; ++k) {\n\t\t\t\tint yyl = yl + dy[k], xxl = xl + dx[k];\n\t\t\t\tint yyr, xxr;\n\t\t\t\tyyr = yr + dy[k];\n\t\t\t\txxr = xr + dx[k] * (-1);\n\n\t\t\t\tif (yyl<0 || yyl >= h || xxl<0 || xxl >= w) {\n\t\t\t\t\tyyl = yl;\n\t\t\t\t\txxl = xl;\n\t\t\t\t}\n\t\t\t\telse if (Len[yyl][xxl] == '#') {\n\t\t\t\t\tyyl = yl;\n\t\t\t\t\txxl = xl;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (yyr<0 || yyr >= h || xxr<0 || xxr >= w) {\n\t\t\t\t\tyyr = yr;\n\t\t\t\t\txxr = xr;\n\t\t\t\t}\n\t\t\t\telse if (Rin[yyr][xxr] == '#') {\n\t\t\t\t\tyyr = yr;\n\t\t\t\t\txxr = xr;\n\t\t\t\t}\n\t\t\t\tif (hist[yyl][xxl][yyr][xxr]) continue;\n\t\t\t\thist[yyl][xxl][yyr][xxr] = true;\n\t\t\t\tqu.push({ yyl, xxl, yyr, xxr });\n\t\t\t\t//cout << yyl << \" \" << xxl << \" \" << yyr << \" \" << xxr << endl;\n\t\t\t}\n\t\t}\n\t\tif (flag) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t\t/*\n\t\tREP(i, 0, h) {\n\t\t\tREP(j, 0, w) {\n\t\t\t\tcout << Len[i][j];\n\t\t\t}\n\t\t\tcout << \" \";\n\t\t\tREP(j, 0, w) {\n\t\t\t\tcout << Rin[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"tune=native\")\n#pragma GCC target (\"avx\")\n\n#include <bits/stdc++.h>\n\n// 汎用マクロ\n#define ALL_OF(x) (x).begin(), (x).end()\n#define REP(i,n) for (long long i=0, i##_len=(n); i<i##_len; i++)\n#define RANGE(i,is,ie) for (long long i=(is), i##_end=(ie); i<=i##_end; i++)\n#define DSRNG(i,is,ie) for (long long i=(is), i##_end=(ie); i>=i##_end; i--)\n#define UNIQUE(v) { sort((v).begin(), (v).end()); (v).erase(unique((v).begin(), (v).end()), (v).end()); }\ntemplate<class T> bool chmax(T &a, const T &b) {if (a < b) {a = b; return 1;} return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) {if (a > b) {a = b; return 1;} return 0; }\n#define INF 0x7FFFFFFF\n#define LINF 0x7FFFFFFFFFFFFFFFLL\n#define Yes(q) (q ? \"Yes\" : \"No\")\n#define YES(q) (q ? \"YES\" : \"NO\")\n#define DUMP(q) cerr << \"[DEBUG] \" #q \": \" << (q) << \" at \" __FILE__ \":\" << __LINE__ << endl\n#define DUMPALL(q) cerr << \"[DEBUG] \" #q \": [\"; REP(dumpall_i, (q).size()) { cerr << q[dumpall_i] << (dumpall_i == (q).size() - 1 ? \"\" : \", \"); } cerr << \"] at \" __FILE__ \":\" << __LINE__ << endl\n\n// gcc拡張マクロ\n#define gcd __gcd\n#define popcount __builtin_popcount\n#define popcountll __builtin_popcountll\n\n// エイリアス\nusing  ll = long long;\nusing ull = unsigned long long;\nusing  ld = long double;\nusing namespace std;\n\n// モジュール\n\n\n// 処理内容\nint main() {\n    \n    ll w, h;\n    while (cin >> w >> h, w && h) {\n\n        vector<string> rl(h), rr(h);\n        REP(i, h) cin >> rl[i] >> rr[i];\n        ll lsy, lsx, rsy, rsx;\n        ll lgy, lgx, rgy, rgx;\n        REP(i, h) REP(j, w) {\n            if (rl[i][j] == '%') {\n                lsy = i;\n                lsx = j;\n            } else if (rl[i][j] == 'L') {\n                lgy = i;\n                lgx = j;\n            }\n            if (rr[i][j] == '%') {\n                rsy = i;\n                rsx = j;\n            } else if (rr[i][j] == 'R') {\n                rgy = i;\n                rgx = j;\n            }\n        }\n\n        // {ly, lx, ry, rx}\n        deque<tuple<ll,ll,ll,ll>> q;\n        vector<vector<vector<vector<bool>>>> visited(h, vector<vector<vector<bool>>>(w, vector<vector<bool>>(h, vector<bool>(w, false))));\n        q.emplace_back(lsy, lsx, rsy, rsx);\n        visited[lsy][lsx][rsy][rsx] = true;\n        while (!q.empty()) {\n\n            ll ly = get<0>(q.front());\n            ll lx = get<1>(q.front());\n            ll ry = get<2>(q.front());\n            ll rx = get<3>(q.front());\n            q.pop_front();\n\n            // Lin and Ren go upward\n            if (ly > 0 && ry > 0) {\n                ll ly2 = rl[ly - 1][lx] != '#' ? ly - 1 : ly;\n                ll lx2 = lx;\n                ll ry2 = rr[ry - 1][lx] != '#' ? ry - 1 : ry;\n                ll rx2 = rx;\n                if (!visited[ly2][lx2][ry2][rx2]) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n                if (ly < h-1) if (rl[ly+1][lx] == '#') {\n                    ll ly2 = ly;\n                    if (!visited[ly2][lx2][ry2][rx2]) {\n                        q.emplace_back(ly2, lx2, ry2, rx2);\n                        visited[ly2][lx2][ry2][rx2] = true;\n                    }\n                }\n                if (ry < h-1) if (rr[ry+1][rx] == '#') {\n                    ll ry2 = ry;\n                    if (!visited[ly2][lx2][ry2][rx2]) {\n                        q.emplace_back(ly2, lx2, ry2, rx2);\n                        visited[ly2][lx2][ry2][rx2] = true;\n                    }\n                }\n            }\n\n            // Lin and Ren go downward\n            if (ly < h-1 && ry < h-1) {\n                ll ly2 = rl[ly + 1][lx] != '#' ? ly + 1 : ly;\n                ll lx2 = lx;\n                ll ry2 = rr[ry + 1][lx] != '#' ? ry + 1 : ry;\n                ll rx2 = rx;\n                if (!visited[ly2][lx2][ry2][rx2]) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n                if (ly > 0) if (rl[ly-1][lx] == '#') {\n                    ll ly2 = ly;\n                    if (!visited[ly2][lx2][ry2][rx2]) {\n                        q.emplace_back(ly2, lx2, ry2, rx2);\n                        visited[ly2][lx2][ry2][rx2] = true;\n                    }\n                }\n                if (ry > 0) if (rr[ry-1][rx] == '#') {\n                    ll ry2 = ry;\n                    if (!visited[ly2][lx2][ry2][rx2]) {\n                        q.emplace_back(ly2, lx2, ry2, rx2);\n                        visited[ly2][lx2][ry2][rx2] = true;\n                    }\n                }\n            }\n\n            // Lin goes left and Ren goes right\n            if (lx > 0 && rx < w-1) {\n                ll ly2 = ly;\n                ll lx2 = rl[ly][lx - 1] != '#' ? lx - 1 : lx;\n                ll ry2 = ry;\n                ll rx2 = rr[ry][rx + 1] != '#' ? rx + 1 : rx;\n                if (!visited[ly2][lx2][ry2][rx2]) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n                if (lx < w-1) if (rl[ly][lx+1] == '#') {\n                    ll lx2 = lx;\n                    if (!visited[ly2][lx2][ry2][rx2]) {\n                        q.emplace_back(ly2, lx2, ry2, rx2);\n                        visited[ly2][lx2][ry2][rx2] = true;\n                    }\n                }\n                if (rx > 0) if (rr[ry][rx-1] == '#') {\n                    ll rx2 = rx;\n                    if (!visited[ly2][lx2][ry2][rx2]) {\n                        q.emplace_back(ly2, lx2, ry2, rx2);\n                        visited[ly2][lx2][ry2][rx2] = true;\n                    }\n                }\n            }\n\n            // Lin goes right and Ren goes left\n            if (lx < w-1 && rx > 0) {\n                ll ly2 = ly;\n                ll lx2 = rl[ly][lx + 1] != '#' ? lx + 1 : lx;\n                ll ry2 = ry;\n                ll rx2 = rr[ry][rx - 1] != '#' ? rx - 1 : rx;\n                if (!visited[ly2][lx2][ry2][rx2]) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n                if (lx > 0) if (rl[ly][lx-1] == '#') {\n                    ll lx2 = lx;\n                    if (!visited[ly2][lx2][ry2][rx2]) {\n                        q.emplace_back(ly2, lx2, ry2, rx2);\n                        visited[ly2][lx2][ry2][rx2] = true;\n                    }\n                }\n                if (rx < w-1) if (rr[ry][rx+1] == '#') {\n                    ll rx2 = rx;\n                    if (!visited[ly2][lx2][ry2][rx2]) {\n                        q.emplace_back(ly2, lx2, ry2, rx2);\n                        visited[ly2][lx2][ry2][rx2] = true;\n                    }\n                }\n            }\n\n        }\n\n        std::cout << Yes(visited[lgy][lgx][rgy][rgx]) << endl;\n\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct state{\n  int lx, ly, rx, ry, step;\n};\nint w, h;\nchar rmap[51][51], lmap[51][51];\nqueue<state> quu;\nint lx, ly, rx, ry;\nint d[51][51][51][51];\nint xmj[4] = {0, 0, 1, -1}, ymj[4] = {1, -1, 0, 0};\nint a[2], b[2];\n\nvoid wide(int lx, int ly, int rx, int ry){\n\n  memset(d,0,sizeof(d));\n  quu.push((state){lx,ly,rx,ry,1});\n\n  while(!quu.empty()){\n\n    state st;\n    st = quu.front();\n    quu.pop();\n    // cout << st.lx << \" \" << st.ly << \" \" << st.rx << \" \" << st.ry << endl;\n    for(int i = 0; i < 2; i++){\n      int lnx = st.lx + xmj[i], lny = st.ly + ymj[i];\n      int rnx = st.rx + xmj[i], rny = st.ry + ymj[i];\n\n      if (lnx >= 0 && lnx < w && lny >= 0 && lny < h && rnx >= 0 && rnx < w && rny >= 0 && rny < h && (rmap[rny][rnx] != '#' || lmap[lny][lnx] != '#') && d[lny][lnx][rny][rnx] == 0){\n\tif(rmap[rny][rnx] == '#'){\n\t  quu.push((state){lnx,lny,st.lx,st.ly,st.step+1});\n\t  d[lny][lnx][st.ry][st.rx] = 1;\n\t}else\tif(lmap[lny][lnx] == '#'){\n\t  quu.push((state){st.lx,st.ly,rnx,rny,st.step+1});\n\t  d[st.ly][st.lx][rny][rnx] = 1;\n\t}else {\n\t  quu.push((state){lnx,lny,rnx,rny,st.step+1});\n\t  d[lny][lnx][rny][rnx] = 1;\n\t} \n      }\n    }\n    for(int i = 2; i < 4; i++){\n      int lnx = st.lx - xmj[i], lny = st.ly + ymj[i];\n      int rnx = st.rx + xmj[i], rny = st.ry + ymj[i];\n      if (lnx >= 0 && lnx < w && lny >= 0 && lny < h && rnx >= 0 && rnx < w && rny >= 0 && rny < h && (rmap[rny][rnx] != '#' || lmap[lny][lnx] != '#') && d[lny][lnx][rny][rnx] == 0){\n\tif(rmap[rny][rnx] == '#'){\n\t  quu.push((state){lnx,lny,st.lx,st.ly,st.step+1});\n\t  d[lny][lnx][st.ry][st.rx] = 1;\n\t}else if(lmap[lny][lnx] == '#'){\n\t  quu.push((state){st.lx,st.ly,rnx,rny,st.step+1});\n\t  d[st.ly][st.lx][rny][rnx] = 1;\n\t}else {\n\t  quu.push((state){lnx,lny,rnx,rny,st.step+1});\n\t  d[lny][lnx][rny][rnx] = 1;\n\t} \n\n      }\n    }\n  }\n  \n  if(d[a[0]][a[1]][b[0]][b[1]]) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n\n\n\n}\n\nint main(){\n\n\n  while(cin >> w >> h && (w || h)){\n\n    for(int i = 0; i < h*2; i++){\n      if(i % 2 == 0){\n\tfor(int j = 0; j < w; j++){\n\t  cin >> lmap[i/2][j];\t  \n\t  if(lmap[i/2][j] == 'L'){\n\t    lx = j;\n\t    ly = i/2;\n\t  }\n\t  if(lmap[i/2][j] == '%'){\n\t    a[0] = i/2;\n\t    a[1] = j;\n\t    //   cout << a[1] << \" \" << a[0] << endl; \n\t  }\n\t}\n      }else {\n\tfor(int j = 0; j < w; j++){\n\t  cin >> rmap[(i-1)/2][j];\n\t  if(rmap[(i-1)/2][j] == 'R'){\n\t    rx = j;\n\t    ry = (i-1)/2;\n\t  }\n\t    if(rmap[(i-1)/2][j] == '%'){\n\t      b[0] = (i-1)/2;\n\t      b[1] = j;\n\t      //      cout << b[1] << \" \" << b[0] << endl; \n\t    }\n\t    //  cout << rx << \" \" << ry << endl;\n\t  \n\t  // cout << i;\n\t}\n      }\n    }\n    wide(lx,ly,rx,ry);\n     \n  }\n    \n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> node;\nint ldx[4]={1,0,-1,0};\nint rdx[4]={-1,0,1,0};\nint dy[4]={0,1,0,-1};\n\nchar l[52][52];\nchar r[52][52];\nbool sets [52][52][52][52];\nint main(void){\n\tint w,h;\n\twhile(cin >> w >> h,w|h){\n\t\tfor(int x1=0;x1<=w+1;x1++)\n\t\t\tfor(int y1=0;y1<=h+1;y1++)\n\t\t\t\tfor(int x2=0;x2<=w+1;x2++)\n\t\t\t\t\tfor(int y2=0;y2<=h+1;y2++)\n\t\t\t\t\t\tsets[x1][y1][x2][y2]=false;\n\t\tint plx,ply,prx,pry;\n\t\tint slx,sly,srx,sry;\n\t\tfor(int x=0;x<=w+1;x++){\n\t\t\tl[x][0]=r[x][0]='#';\n\t\t\tl[x][h+1]=r[x][h+1]='#';\n\t\t}\n\t\tfor(int y=0;y<=h+1;y++){\n\t\t\tl[0][y]=r[0][y]='#';\n\t\t\tl[w+1][y]=r[w+1][y]='#';\n\t\t}\n\t\tfor(int y=1;y<=h;y++){\n\t\t\tfor(int x=1;x<=w;x++){\n\t\t\t\tcin >> l[x][y];\n\t\t\t\tif(l[x][y]=='%')\n\t\t\t\t\tplx=x,ply=y;\n\t\t\t\tif(l[x][y]=='L')\n\t\t\t\t\tslx=x,sly=y;\n\t\t\t}\n\t\t\tfor(int x=1;x<=w;x++){\n\t\t\t\tcin >> r[x][y];\n\t\t\t\tif(r[x][y]=='%')\n\t\t\t\t\tprx=x,pry=y;\n\t\t\t\tif(r[x][y]=='R')\n\t\t\t\t\tsrx=x,sry=y;\n\t\t\t}\n\t\t}\n\t\t/*for(int y=0;y<=h+1;y++){\n\t\t\tfor(int x=0;x<=w+1;x++){\n\t\t\t\tcout << l[x][y];\n\t\t\t}\n\t\t\tcout <<\" \" ;\n\t\t\tfor(int x=0;x<=w+1;x++){\n\t\t\t\tcout<< r[x][y];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tqueue<node> q;\n\t\tnode s,g;\n\t\ts=node(P(slx,sly),P(srx,sry));\n\t\tg=node(P(plx,ply),P(prx,pry));\n\t\tq.push(s);\n\t\tsets[slx][sly][srx][sry]=true;\n\t\twhile(!q.empty()){\n\t\t\tnode cur=q.front();q.pop();\n\t\t//\tcout << cur.F.F << \" \"<< cur.F.S << \" \"<< cur.S.F << \" \"<< cur.S.S << endl;\n\t\t\tif(cur == g)\n\t\t\t\tbreak;\n\t\t\tif((cur.F.F==plx&&cur.F.S==ply)||(cur.S.F==prx&&cur.S.S==pry))\n\t\t\t\tcontinue;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint lnx=cur.F.F+ldx[i],lny=cur.F.S+dy[i],rnx=cur.S.F+rdx[i],rny=cur.S.S+dy[i];\n\t\t\t\tif(l[lnx][lny]=='#'&&r[rnx][rny]=='#')\n\t\t\t\t\tcontinue;\n\t\t\t\tif(l[lnx][lny]=='#')\n\t\t\t\t\tlnx=cur.F.F,lny=cur.F.S;\n\t\t\t\tif(r[rnx][rny]=='#')\n\t\t\t\t\trnx=cur.S.F,rny=cur.S.S;\n\t\t\t\tbool lok=false,rok=false;\n\t\t\t\tif(l[lnx][lny]=='%')\n\t\t\t\t\tlok=true;\n\t\t\t\tif(r[rnx][rny]=='%')\n\t\t\t\t\trok=true;\n\t\t\t//\tcout << lok << rok << (lok^rok) << endl;\n\t\t\t\tnode c=node(P(lnx,lny),P(rnx,rny));\n\t\t\t//\tif(i==1|| i==3)\n\t\t\t\t//\tcout << lnx << \" \" << lny << \" \" << rnx << \" \" << rny << endl;\n\t\t\t\tif(!sets[lnx][lny][rnx][rny]&&!(lok^rok))\n\t\t\t\t\tsets[lnx][lny][rnx][rny]=true,q.push(c);\n\t\t\t}\n\t\t}\n\t\tif(sets[plx][ply][prx][pry])\n\t\t\tcout << \"Yes\" << endl;\n\t\telse\n\t\t\tcout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<pair<int, int>, pair<int, int>> PPIIII;\n\nint dx[] = { 1,0,-1,0 };\nint dy[] = { 0,1,0,-1 };\n\nvoid solve( int W, int H ) {\n\tpair<int, int> startR, startL, goalR, goalL;\n\tvector<vector<vector<vector<bool>>>>dp( H + 2, vector<vector<vector<bool>>>( W + 2, vector<vector<bool>>( H + 2, vector<bool>( W + 2, 0 ) ) ) );\n\tvector<vector<vector<char>>>mapd( 2, vector<vector<char>>( H + 2, vector<char>( W + 2, '#' ) ) );\n\tfor( size_t i = 1; i <= H; i++ ) {\n\t\tfor( size_t j = 1; j <= W; j++ ) {\n\t\t\tcin >> mapd[0][i][j];\n\t\t\tif( mapd[0][i][j] == 'L' ) {\n\t\t\t\tstartL = make_pair( i, j );\n\t\t\t} else if( mapd[0][i][j] == '%' ) {\n\t\t\t\tgoalL = make_pair( i, j );\n\t\t\t}\n\t\t}\n\t\tfor( int j = W; j >= 1; j-- ) {\n\t\t\tcin >> mapd[1][i][j];\n\t\t\tif( mapd[1][i][j] == 'R' ) {\n\t\t\t\tstartR = make_pair( i, j );\n\t\t\t} else if( mapd[1][i][j] == '%' ) {\n\t\t\t\tgoalR = make_pair( i, j );\n\t\t\t}\n\t\t}\n\t}\n\tdp[startL.first][startL.second][startR.first][startR.second] = 1;\n\n\n\tqueue<PPIIII>que;\n\tque.push( make_pair( startL, startR ) );\n\twhile( que.size() ) {\n\t\tauto now = que.front(); que.pop();\n\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\tauto next = now;\n\t\t\tnext.first.first += dx[i];\n\t\t\tnext.first.second += dy[i];\n\t\t\tnext.second.first += dx[i];\n\t\t\tnext.second.second += dy[i];\n\t\t\tif( mapd[0][next.first.first][next.first.second] == '#' ) {\n\t\t\t\tnext.first = now.first;\n\t\t\t}\n\t\t\tif( mapd[1][next.second.first][next.second.second] == '#' ) {\n\t\t\t\tnext.second = now.second;\n\t\t\t}\n\n\t\t\tif( 0 < next.first.first&&next.first.first < H + 2 &&\n\t\t\t\t0 < next.first.second&&next.first.second < W + 2 &&\n\t\t\t\t0 < next.second.first&&next.second.first < H + 2 &&\n\t\t\t\t0 < next.second.second&&next.second.second < W + 2 ) {\n\t\t\t\tif( dp[next.first.first][next.first.second][next.second.first][next.second.second] == 0 ) {\n\t\t\t\t\tif( goalL == next.first&&goalR == next.second &&dx[i] != 0 && dy[0] != 0 ) {\n\t\t\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdp[next.first.first][next.first.second][next.second.first][next.second.second] = 1;\n\t\t\t\t\tque.push( next );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"No\" << endl;\n\treturn;\n}\n\nint main() {\n\tint W, H;\n\twhile( cin >> W >> H, W&&H ) {\n\t\tsolve( W, H );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint W, H;\nbool memo[51][51][51][51];\nstring grid1[51];\nstring grid2[51];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nstruct S{\n  int x1, y1, x2, y2;\n  S(int x1, int y1, int x2, int y2) :\n    x1(x1), y1(y1), x2(x2), y2(y2) {}\n};\nbool valid1(int x, int y){\n  return (x >= 0 && y >= 0 && x < W && y < H && grid1[y][x] != '#');\n}\nbool valid2(int x, int y){\n  return (x >= 0 && y >= 0 && x < W && y < H && grid2[y][x] != '#');\n}\nint main(){\n  while(cin>>W>>H && W){\n    REP(i, H)cin>> grid1[i] >> grid2[i];\n    memset(memo, 0, sizeof(memo));\n    int x1, y1, x2, y2;\n    REP(y, H)REP(x, W){\n      if(grid1[y][x] == 'L'){\n        x1 = x; y1 = y;\n      }\n      if(grid2[y][x] == 'R'){\n        x2 = x; y2 = y;\n      }\n    }\n    //printf(\"%d %d %d %d\\n\", x1, y1, x2, y2);\n    queue<S> que;\n    que.push(S(x1, y1, x2, y2));\n    bool ans = false;\n    while(!que.empty()){\n      S s = que.front(); que.pop();\n      if(memo[s.x1][s.y1][s.x2][s.y2]) continue;\n      memo[s.x1][s.y1][s.x2][s.y2] = true;\n      if(grid1[s.y1][s.x1] == '%' && grid2[s.y2][s.x2] == '%') {\n        ans = true;\n        break;\n      }\n      REP(r, 4){\n        int nx1 = s.x1, ny1 = s.y1, nx2 = s.x2, ny2 = s.y2;\n        if(valid1(s.x1 + dx[r], s.y1 + dy[r])){\n          nx1 += dx[r]; ny1 += dy[r];\n        }\n        if(valid2(s.x2 - dx[r], s.y2 + dy[r])){\n          nx2 += -dx[r]; ny2 += dy[r];\n        }\n        if(!memo[nx1][ny1][nx2][ny2]) que.push(S(nx1, ny1, nx2, ny2));\n      }\n    }\n    if(ans) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\nusing namespace std;\nstring s1[50],s2[50];\nint dx1[]={1,-1,0,0,},dy1[]={0,0,1,-1};\nint dx2[]={-1,1,0,0,},dy2[]={0,0,1,-1};\nint w,h,gx1,gx2,gy1,gy2;\nunordered_set<int>s;\nbool bfs(int x1,int y1,int x2,int y2){\n  queue<int>q;\n  q.push(x1+y1*100+x2*10000+y2*1000000);\n  while(!q.empty()){\n    int p=q.front();q.pop();\n    x1=p%100;y1=p%10000/100;\n    x2=p%1000000/10000;y2=p/1000000;\n    if(x1==gx1&&y1==gy1&&x2==gx2&&y2==gy2){\n      return 1;\n    }\n    for(int i=0;i<4;i++){\n      int x3=x1+dx1[i],y3=y1+dy1[i];\n      int x4=x2+dx2[i],y4=y2+dy2[i];\n      if(x3>=0&&x4>=0&&y3>=0&&y4>=0)\n        if(x3<w&&x4<w&&y3<h&&y4<h){\n          if(s1[y3][x3]=='#')y3=y1,x3=x1;\n          if(s2[y4][x4]=='#')y4=y2,x4=x2;\n          if(!(x3==gx1&&y3==gy1&&(x4!=gx2||y4!=gy2)))\n          if(!((x3!=gx1||y3!=gy1)&&x4==gx2&&y4==gy42))\n          if(!s.count(x3+y3*100+x4*10000+y4*1000000)){\n            s.insert(x3+y3*100+x4*10000+y4*1000000);\n            q.push(x3+y3*100+x4*10000+y4*1000000);\n          }\n        }\n      }\n    }\n    return 0;\n}\nint main(){\n  int x1,y1,x2,y2;\n  while(cin>>w>>h,w){\n    s.clear();\n    r(i,h)cin>>s1[i]>>s2[i];\n    r(i,h)r(j,w){\n      if(s1[i][j]=='L')x1=j,y1=i;\n      if(s2[i][j]=='R')x2=j,y2=i;\n      if(s1[i][j]=='%')gx1=j,gy1=i;\n      if(s2[i][j]=='%')gx2=j,gy2=i;\n    }\n    s.insert(x1+y1*100+x2*10000+y2*1000000);\n    if(bfs(x1,y1,x2,y2))cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nchar fieldl[55][55];\nchar fieldr[55][55];\nint maxw,maxh;\nint lsx,lsy;\nint rsx,rsy;\n\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\n\nbool dfs(int lx,int ly,int rx,int ry)\n{\n\tfieldl[ly][lx]=0;\n\tfieldr[ry][rx]=0;\n\tfor(int i=0;i<4;++i){\n\t\tint tolx=lx,toly=ly;\n\t\tint torx=rx,tory=ry;\n\t\tbool f=false;\n\t\tif(fieldl[ly+dy[i]][lx+dx[i]] == '%' && fieldr[ry+dy[i]][rx+dx[i]] == '%')\n\t\t\treturn true;\n\t\telse if(fieldl[ly+dy[i]][lx+dx[i]] == '%' || fieldr[ry+dy[i]][rx+dx[i]] == '%')\n\t\t\tcontinue;\n\t\tif(fieldl[ly+dy[i]][lx+dx[i]] == '.'){\n\t\t\ttolx = lx+dx[i];\n\t\t\ttoly = ly+dy[i];\n\t\t\tf=true;\n\t\t}\n\t\tif(fieldr[ry+dy[i]][rx+dx[i]] == '.'){\n\t\t\ttorx = rx+dx[i];\n\t\t\ttory = ry+dy[i];\n\t\t\tf=true;\n\t\t}\n\t\tif(!f)\n\t\t\tcontinue;\n\t\tif(dfs(tolx,toly,torx,tory))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main(void)\n{\n\twhile(1)\n\t{\n\t\tmemset(fieldl,0,sizeof(fieldl));\n\t\tmemset(fieldr,0,sizeof(fieldr));\n\t\tcin >> maxw >> maxh;\n\t\tif(maxw==0&&maxh==0)\n\t\t\treturn 0;\n\t\tfor(int y=1;y<=maxh;++y){\n\t\t\tfor(int x=1;x<=maxw;++x){\n\t\t\t\tcin >> fieldl[y][x];\n\t\t\t\tif(fieldl[y][x] == 'L'){\n\t\t\t\t\tlsy = y;lsx = x;\n\t\t\t\t}\n\t\t\t\tif(fieldl[y][x] == 'R'){\n\t\t\t\t\trsy = y;rsx = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int x=1;x<=maxw;++x){\n\t\t\t\tcin >> fieldr[y][x];\n\t\t\t\tif(fieldr[y][x] == 'L'){\n\t\t\t\t\tlsy = y;lsx = x;\n\t\t\t\t}\n\t\t\t\tif(fieldr[y][x] == 'R'){\n\t\t\t\t\trsy = y;rsx = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dfs(lsx,lsy,rsx,rsy))\n\t\t\tcout << \"Yes\" << endl;\n\t\telse\n\t\t\tcout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define lp(i,n) for(int i=0;i<n;i++)\nchar a[52][52],b[52][52];\nset<tuple<int,int,int,int>> dp;\nint ans;\n\nvoid calc(int lx,int ly,int rx,int ry){\n\tif(ans==1) return;\n\tif(a[lx][ly]=='%'&&b[rx][ry]=='%'){\n\t\tans=1;\n\t\treturn;\n\t}\n\telse if(a[lx][ly]=='%'||b[rx][ry]=='%') return;\n\ttuple<int,int,int,int> now;\n\tnow=make_tuple(lx,ly,rx,ry);\n\tif(dp.find(now)!=dp.end()) return;\n\tdp.insert(now);\n\tint nxl=lx,nyl=ly,nxr=rx,nyr=ry;\n\tif(a[lx+1][ly]!='#') nxl++;\n\tif(b[rx-1][ry]!='#') nxr--;\n\tcalc(nxl,nyl,nxr,nyr);\n\tnxl=lx;nyl=ly;nxr=rx;nyr=ry;\n\tif(a[lx-1][ly]!='#') nxl--;\n\tif(b[rx+1][ry]!='#') nxr++;\n\tcalc(nxl,nyl,nxr,nyr);\n\tnxl=lx;nyl=ly;nxr=rx;nyr=ry;\n\tif(a[lx][ly+1]!='#') nyl++;\n\tif(b[rx][ry+1]!='#') nyr++;\n\tcalc(nxl,nyl,nxr,nyr);\n\tnxl=lx;nyl=ly;nxr=rx;nyr=ry;\n\tif(a[lx][ly-1]!='#') nyl--;\n\tif(b[rx][ry-1]!='#') nyr--;\n\tcalc(nxl,nyl,nxr,nyr);\n\treturn;\n}\n\nint main(){\n\twhile(1){\n\t\tint w,h;\n\t\tcin>>w>>h;\n\t\tint stxl,styl,stxr,styr;\n\t\tif(w==0&&h==0) break;\n\t\tlp(i,52){\n\t\t\tlp(j,52){\n\t\t\t\ta[i][j]='#';\n\t\t\t\tb[i][j]='#';\n\t\t\t}\n\t\t}\n\t\tlp(i,h+1){\n\t\t\tif(i==0) continue;\n\t\t\tlp(j,w+1){\n\t\t\t\tif(j==0) continue;\n\t\t\t\tcin>>a[j][i];\n\t\t\t\tif(a[j][i]=='L'){\n\t\t\t\t\tstxl=j;\n\t\t\t\t\tstyl=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlp(j,w+1){\n\t\t\t\tif(j==0) continue;\n\t\t\t\tcin>>b[j][i];\n\t\t\t\tif(b[j][i]=='R'){\n\t\t\t\t\tstxr=j;\n\t\t\t\t\tstyr=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp.clear();\n\t\tans=0;\n\t\tcalc(stxl,styl,stxr,styr);\n\t\tif(ans==0) cout<<\"No\"<<endl;\n\t\telse cout<<\"Yes\"<<endl;\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nint w, h;\nP sl, sr;\nstring s[1000];\nstring t[1000];\nbool f[60][60][60][60];\n\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\n\n//set<pair<P,P>>\n\nbool solve(int ly, int lx, int ry, int rx) {\n\tbool res = 0;\n\tf[ly][lx][ry][rx] = 1;\n\tREP(i, 4) {\n\t\tint nly = ly + dy[i], nry = ry + dy[i], nlx = lx + dx[i], nrx = rx + dx[i];\n\t\tif (nly >= 0 && nly < h&&nlx >= 0 && nlx < w&&nry >= 0 && nry < h&&nrx >= 0 && nrx < w) {\n\t\t\tif (f[nly][nrx][nry][nrx])continue;\n\t\t\tif (s[nly][nlx] != t[nry][nrx]) {\n\t\t\t\tif (s[nly][nlx] == '%' || t[nry][nrx] == '%')continue;\n\t\t\t\tif (s[nly][nlx] == '#')res |= solve(ly, lx, nry, nrx);\n\t\t\t\telse if (t[nry][nrx] == '#')res |= solve(nly, nlx, ry, rx);\n\t\t\t\telse res |= solve(nly, nlx, nry, nrx);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (s[nly][nlx] == '%')res |= true;\n\t\t\t\telse if (s[nly][nlx] == '.')res |= solve(nly, nlx, nry, nrx);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\twhile (cin >> w >> h&&w + h) {\n\t\tREP(i, 60)REP(j, 60)REP(k,60)REP(l,60) {\n\t\t\tf[i][j][k][l] = 0;\n\t\t}\n\t\tREP(i, h) {\n\t\t\tcin >> s[i] >> t[i];\n\t\t\treverse(ALL(t[i]));\n\t\t}\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tif (s[i][j] == 'L') {\n\t\t\t\t\tsl = { i,j };\n\t\t\t\t\ts[i][j] = '.';\n\t\t\t\t}\n\t\t\t\tif (t[i][j] == 'R') {\n\t\t\t\t\tsr = { i,j };\n\t\t\t\t\ts[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (solve(sl.first, sl.second, sr.first, sr.second))cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int MAX = 52;\nconst int ldy[4] = { 0,1,0,-1 };\nconst int ldx[4] = { 1,0,-1,0 };\nconst int rdy[4] = { 0,1,0,-1 };\nconst int rdx[4] = { -1,0,1,0 };\n\nchar l_grid[MAX][MAX];\nint l_visited[MAX][MAX];\nchar r_grid[MAX][MAX];\nint r_visited[MAX][MAX];\nbool goal;\n\nvoid dfs(int ly, int lx, int ry, int rx, int deep)\n{\n\tif (goal == true) {\n\t\treturn;\n\t}\n\n\tif (l_grid[ly][lx] == '%'&&r_grid[ry][rx] == '%') {\n\t\tgoal = true;\n\t\treturn;\n\t}\n\telse if (l_grid[ly][lx] == '%' || r_grid[ry][rx] == '%') {\n\t\treturn;\n\t}\n\n\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nly, nlx, nry, nrx;\n\t\tif (l_grid[ly + ldy[i]][lx + ldx[i]] == '#') {\n\t\t\tnly = ly;\n\t\t\tnlx = lx;\n\t\t}\n\t\telse {\n\t\t\tnly = ly + ldy[i];\n\t\t\tnlx = lx + ldx[i];\n\t\t}\n\t\tif (r_grid[ry + rdy[i]][rx + rdx[i]] == '#') {\n\t\t\tnry = ry;\n\t\t\tnrx = rx;\n\t\t}\n\t\telse {\n\t\t\tnry = ry + rdy[i];\n\t\t\tnrx = rx + rdx[i];\n\t\t}\n\n\t\tif (nly == ly&&nlx == lx&&nry == ry&&nrx == rx) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (l_visited[nly][nlx] != -1 && r_visited[nry][nrx] != -1 && l_visited[nly][nlx] == r_visited[nry][nrx]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tl_visited[ly][lx] = deep + 1;\n\t\tr_visited[ry][rx] = deep + 1;\n\t\t\n\t\tdfs(nly, nlx, nry, nrx, deep + 1);\n\t}\n}\n\nint main()\n{\n\twhile (true) {\n\t\tint W, H;\n\t\tcin >> W >> H;\n\n\t\tif (W == 0 && H == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tgoal = false;\n\n\t\tfor (int i = 0; i < MAX; i++) {\n\t\t\tfor (int j = 0; j < MAX; j++) {\n\t\t\t\tl_grid[i][j] = '#';\n\t\t\t\tl_visited[i][j] = -1;\n\t\t\t\tr_grid[i][j] = '#';\n\t\t\t\tr_visited[i][j] = -1;\n\t\t\t}\n\t\t}\n\n\t\tint ly, lx, ry, rx;\n\n\t\tfor (int y = 1; y <= H; y++) {\n\t\t\tfor (int x = 1; x <= W; x++) {\n\t\t\t\tcin >> l_grid[y][x];\n\t\t\t\t\n\t\t\t\tif (l_grid[y][x] == 'L') {\n\t\t\t\t\tly = y;\n\t\t\t\t\tlx = x;\n\t\t\t\t\tl_grid[y][x] = '.';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int x = 1; x <= W; x++) {\n\t\t\t\tcin >> r_grid[y][x];\n\n\t\t\t\tif (r_grid[y][x] == 'R') {\n\t\t\t\t\try = y;\n\t\t\t\t\trx = x;\n\t\t\t\t\tr_grid[y][x] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdfs(ly, lx, ry, rx, 0);\n\n\t\tif (goal == true) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,s,n) for(int i=s; i<n; i++)\n#define ALL(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nint w, h;\nbool wl[55][55], wr[55][55];\nbool memo[55][55][55][55];\nint gxl, gyl, gxr, gyr;\n\nbool dfs(int xl, int yl, int xr, int yr) {\n\tif( memo[xl][yl][xr][yr] ) {\n\t\treturn false;\n\t}\n//\tcout << \"dfs \" << xl << \" \" << yl << \" \" << xr << \" \" << yr << endl;\n\tmemo[xl][yl][xr][yr] = true;\n\tif(xl==gxl && yl==gyl && xr==gxr && yr==gyr) {\n\t\treturn true;\n\t}\n\tint dx[4] = {-1, 0, 1, 0};\n\tint dy[4] = {0, 1, 0, -1};\n\tbool f = false;\n\trep(i, 4) {\n\t\tint nxl = xl + dx[i];\n\t\tint nyl = yl + dy[i];\n\t\tint nxr = xr - dx[i];\n\t\tint nyr = yr + dy[i];\n\t\tbool nl = wl[nyl][nxl];\n\t\tbool nr = wr[nyr][nxr];\n\t\tif( !nl && !nr ) {\n\t\t\tf |= dfs(nxl, nyl, nxr, nyr);\n\t\t}\n\t\telse if( !nl && nr ) {\n\t\t\tf |= dfs(nxl, nyl, xr, yr);\n\t\t}\n\t\telse if( nl && !nr ) {\n\t\t\tf |= dfs(xl, yl, nxr, nyr);\n\t\t}\n\t}\n\treturn f;\n}\n\nint main() {\n\twhile(cin >> w >> h, w) {\n\t\trep(i,55) rep(j,55) wl[i][j] = wr[i][j] = true;\n\t\trep(i,55) rep(j,55) rep(k,55) rep(l,55) memo[i][j][k][l]=false;\n\t\tint xl=1, yl=1, xr=1, yr=1;\n\t\trep(y, h) {\n\t\t\tstring sl, sr;\n\t\t\tcin >> sl >> sr;\n\t\t\trep(x, w) {\n\t\t\t\tif(sl[x] == 'L') {\n\t\t\t\t\txl = x+1;\n\t\t\t\t\tyl = y+1;\n\t\t\t\t\twl[y+1][x+1] = false;\n\t\t\t\t} else if(sl[x] == '%') {\n\t\t\t\t\tgxl = x+1;\n\t\t\t\t\tgyl = y+1;\n\t\t\t\t\twl[y+1][x+1] = false;\n\t\t\t\t} else {\n\t\t\t\t\twl[y+1][x+1] = (sl[x]=='#');\n\t\t\t\t}\n\t\t\t\tif(sr[x] == 'R') {\n\t\t\t\t\txr = x+1;\n\t\t\t\t\tyr = y+1;\n\t\t\t\t\twr[y+1][x+1] = false;\n\t\t\t\t} else if(sr[x] == '%') {\n\t\t\t\t\tgxr = x+1;\n\t\t\t\t\tgyr = y+1;\n\t\t\t\t\twr[y+1][x+1] = false;\n\t\t\t\t} else {\n\t\t\t\t\twr[y+1][x+1] = (sr[x]=='#');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( dfs(xl, yl, xr, yr) ) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t} else {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> Coor;\ntypedef pair<Coor, Coor> Pair;\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {-1, 0, 1, 0};\n\nint H;\nint W;\nint sty[2];\nint stx[2];\nint y[2];\nint x[2];\nchar field[2][50][50];\nbool dp[50][50][50][50];\n\nbool WithinRange(int y, int x) {\n  if (y < 0 || H <= y) return false;\n  if (x < 0 || W <= x) return false;\n  return true;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &W, &H);\n    if (W == 0 && H == 0) return 0;\n\n    for (int i=0; i<H; i++) {\n      for (int j=0; j<W; j++) {\n        scanf(\" %c\", &field[0][i][j]);\n        if (field[0][i][j] == '%') {\n          sty[0] = i;\n          stx[0] = j;\n        } else if (field[0][i][j] == 'L') {\n          y[0] = i;\n          x[0] = j;\n        } else assert(field[0][i][j] == '.' || field[0][i][j] == '#');\n      }\n\n      for (int j=W-1; j>=0; j--) {\n        scanf(\" %c\", &field[1][i][j]);\n        if (field[1][i][j] == '%') {\n          sty[1] = i;\n          stx[1] = j;\n        } else if (field[1][i][j] == 'R') {\n          y[1] = i;\n          x[1] = j;\n        } else assert(field[1][i][j] == '.' || field[1][i][j] == '#');\n      }\n    }\n\n    for (int i=0; i<H; i++) {\n      for (int j=0; j<W; j++) {\n        for (int k=0; k<H; k++) {\n          for (int l=0; l<W; l++) {\n            dp[i][j][k][l] = false;\n          }\n        }\n      }\n    }\n\n    dp[y[0]][x[0]][y[1]][x[1]] = true;\n    queue<Pair> q;\n    q.push(Pair(Coor(y[0], x[0]), Coor(y[1], x[1])));\n    while (!q.empty()) {\n      Pair p = q.front(); q.pop();\n      Coor c1 = p.first;\n      int y1 = c1.first;\n      int x1 = c1.second;\n      Coor c2 = p.second;\n      int y2 = c2.first;\n      int x2 = c2.second;\n\n      for (int i=0; i<4; i++) {\n        int newy1 = y1 + dy[i];\n        int newx1 = x1 + dx[i];\n        if (!WithinRange(newy1, newx1) || field[0][newy1][newx1] == '#') {\n          newy1 = y1;\n          newx1 = x1;\n        }\n\n        int newy2 = y2 + dy[i];\n        int newx2 = x2 + dx[i];\n        if (!WithinRange(newy2, newx2) || field[1][newy2][newx2] == '#') {\n          newy2 = y2;\n          newx2 = x2;\n        }\n\n        if (dp[newy1][newx1][newy2][newx2]) continue;\n        dp[newy1][newx1][newy2][newx2] = true;\n        if (newy1 == sty[0] && newx1 == stx[0]) {\n          if (newy2 == sty[1] && newx2 == stx[1]) break;\n          continue;\n        }\n        if (newy2 == sty[1] && newx2 == stx[1]) continue;\n        q.push(Pair(Coor(newy1, newx1), Coor(newy2, newx2)));\n      }\n    }\n\n    if (dp[sty[0]][stx[0]][sty[1]][stx[1]]) puts(\"Yes\");\n    else puts(\"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\nusing namespace std;\nstruct po{int lx,ly,rx,ry;};\nint w,h;\nstring mp[2][51];\nbool visited[51][51][51][51];\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\n\nbool bfs(int lx,int ly,int rx,int ry){\n  queue <po> Q;\n  Q.push((po){lx,ly,rx,ry});\n  while(!Q.empty()){\n    po t=Q.front();Q.pop();\n    int cnt=(mp[0][t.ly][t.lx]=='%')+(mp[1][t.ry][t.rx]=='%');\n    if(cnt==2)return true;\n    if(visited[t.lx][t.ly][t.rx][t.ry]||cnt==1)continue;\n    visited[t.lx][t.ly][t.rx][t.ry]=1;\n    for(int i=0;i<4;i++){\n      int flg=0;\n      int nlx=t.lx+dx[i],nly=t.ly+dy[i];\n      int nrx=t.rx-dx[i],nry=t.ry+dy[i];\n      if(nlx<0||nly<0||nlx>=w||nly>=h||mp[0][nly][nlx]=='#')nlx=t.lx,nly=t.ly,flg++;\n      if(nrx<0||nry<0||nrx>=w||nry>=h||mp[1][nry][nrx]=='#')nrx=t.rx,nry=t.ry,flg++;\n      if(flg==2||visited[nlx][nly][nrx][nry])continue;\n      Q.push((po){nlx,nly,nrx,nry});\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(1){\n    cin >>w>>h;\n    if(!w&&!h)break;\n    for(int i=0;i<h;i++)cin>>mp[0][i]>>mp[1][i];\n    int lx,ly,rx,ry;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(mp[0][i][j]=='L')lx=j,ly=i;\n\tif(mp[1][i][j]=='R')rx=j,ry=i;\n      }\n\n    memset(visited,0,sizeof(visited));\n    if(bfs(lx,ly,rx,ry))cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nstruct Data{int x[2],y[2];};\nData start,goal;\n\nint W,H;\nchar room[2][51][51];\n\nint dx[2][4]={{0,1,0,-1}, {0,-1,0,1}};\nint dy[2][4]={{-1,0,1,0}, {-1,0,1,0}};\nbool operator==(Data a, Data b){\n  return a.x[0]==b.x[0] && a.x[1]==b.x[1] && a.y[0]==b.y[0] && a.y[1]==b.y[1];\n}\nbool over(Data a){\n  return a.x[0]<0 || W<=a.x[0] || a.y[0]<0 || H<=a.y[0] ||\n         a.x[1]<0 || W<=a.x[1] || a.y[1]<0 || H<=a.y[1];\n}\n\nbool bfs()\n{\n  queue<Data>q;\n  q.push(start);\n  bool visited[51][51][51][51]={false};\n  Data now,next;\n\n  while(!q.empty()){\n    now=q.front();\n    q.pop();\n\n    visited[now.x[0]][now.y[0]][now.x[1]][now.y[1]]=true;\n\n    if(now==goal)return true;\n    if(now.x[0]==goal.x[0] && now.y[0]==goal.y[0])continue;\n    if(now.x[1]==goal.x[1] && now.y[1]==goal.y[1])continue;\n\n    for(int i=0;i<4;i++){\n      next=now;\n      for(int j=0;j<2;j++){\n\tnext.x[j]+=dx[j][i];\n\tnext.y[j]+=dy[j][i];\n\tif(over(next) || room[j][next.y[j]][next.x[j]]=='#'){\n\t  next.x[j]=now.x[j];\n\t  next.y[j]=now.y[j];\n\t}\n      }\n      if(visited[next.x[0]][next.y[0]][next.x[1]][next.y[1]])continue;\n      q.push(next);\n    }\n  }\n\n  return false;\n}\n\nint main()\n{\n  while(cin>>W>>H,W|H){\n    for(int i=0;i<H;i++){\n      cin>>room[0][i]>>room[1][i];\n      for(int j=0;j<W;j++){\n\tif(room[0][i][j]=='L'){\n\t  start.x[0]=j;\n\t  start.y[0]=i;\n\t}\n\tif(room[1][i][j]=='R'){\n\t  start.x[1]=j;\n\t  start.y[1]=i;\n\t}\n\tif(room[0][i][j]=='%'){\n\t  goal.x[0]=j;\n\t  goal.y[0]=i;\n\t}\n\tif(room[1][i][j]=='%'){\n\t  goal.x[1]=j;\n\t  goal.y[1]=i;\n\t}\n      }\n    }\n\n    puts(bfs()?\"Yes\":\"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define lp(i,n) for(int i=0;i<n;i++)\nchar a[52][52],b[52][52];\nset<tuple<int,int,int,int>> dp;\nint ans;\n\nvoid calc(int lx,int ly,int rx,int ry){\n  queue<tuple<int,int,int,int>> Q;\n  Q.push(make_tuple(lx,ly,rx,ry));\n  while(!Q.empty()){\n    lx=get<0>(Q.front());\n    ly=get<1>(Q.front());\n    rx=get<2>(Q.front());\n    ry=get<3>(Q.front());\n    Q.pop();\n    if(a[lx][ly]=='%'&&b[rx][ry]=='%'){\n      ans=1;\n      return;\n    }\n    else if(a[lx][ly]=='%'||b[rx][ry]=='%') continue;\n    tuple<int,int,int,int> now;\n    now=make_tuple(lx,ly,rx,ry);\n    decltype(dp)::iterator it =dp.find(now);\n    if(it!=dp.end()) continue;\n    dp.insert(now);\n    int nxl=lx,nyl=ly,nxr=rx,nyr=ry;\n    if(a[lx+1][ly]!='#') nxl++;\n    if(b[rx-1][ry]!='#') nxr--;   \n    Q.push(make_tuple(nxl,nyl,nxr,nyr));\n    nxl=lx;nyl=ly;nxr=rx;nyr=ry;\n    if(a[lx-1][ly]!='#') nxl--;\n    if(b[rx+1][ry]!='#') nxr++;\n    Q.push(make_tuple(nxl,nyl,nxr,nyr));\n    nxl=lx;nyl=ly;nxr=rx;nyr=ry;\n    if(a[lx][ly+1]!='#') nyl++;\n    if(b[rx][ry+1]!='#') nyr++;\n    Q.push(make_tuple(nxl,nyl,nxr,nyr));\n    nxl=lx;nyl=ly;nxr=rx;nyr=ry;\n    if(a[lx][ly-1]!='#') nyl--;\n    if(b[rx][ry-1]!='#') nyr--; \n    Q.push(make_tuple(nxl,nyl,nxr,nyr));\n  }\n  return;\n}\n\nint main(){\n  while(1){\n    int w,h;\n    cin>>w>>h;\n    int stxl,styl,stxr,styr;\n    if(w==0&&h==0) break;\n    lp(i,52){\n      lp(j,52){\n\ta[i][j]='#';\n\tb[i][j]='#';\n      }\n    }\n    lp(i,h+1){\n      if(i==0) continue;\n      lp(j,w+1){\n\tif(j==0) continue;\n\tcin>>a[j][i];\n\tif(a[j][i]=='L'){\n\t  stxl=j;\n\t  styl=i;\n\t}\n      }\n      lp(j,w+1){\n\tif(j==0) continue;\n\tcin>>b[j][i];\n\tif(b[j][i]=='R'){\n\t  stxr=j;\n\t  styr=i;\n\t}\n      }\n    }\n    dp.clear();\n    ans=0;\n    calc(stxl,styl,stxr,styr);\n    if(ans==0) cout<<\"No\"<<endl;\n    else cout<<\"Yes\"<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <memory.h>\n\nusing namespace std;\n\nint maxw,maxh;\nint lsx,lsy;\nint rsx,rsy;\n\nconst int dx[] = {1,0,-1,0};\nconst int ddx[] = {-1,0,1,0};\nconst int dy[] = {0,1,0,-1};\nconst int ddy[] = {0,1,0,-1};\n\nbool dfs(char ffieldl[55][55],char ffieldr[55][55],int lx,int ly,int rx,int ry)\n{\n\tchar fieldl[55][55];\n\tchar fieldr[55][55];\n\tmemcpy(fieldl,ffieldl,sizeof(fieldl));\n\tmemcpy(fieldr,ffieldr,sizeof(fieldr));\n\tfieldl[ly][lx]=0;\n\tfieldr[ry][rx]=0;\n\tfor(int i=0;i<4;++i){\n\t\tint tolx=lx,toly=ly;\n\t\tint torx=rx,tory=ry;\n\t\tbool f=false;\n\t\tif(fieldl[ly+dy[i]][lx+dx[i]] == '%' && fieldr[ry+ddy[i]][rx+ddx[i]] == '%')\n\t\t\treturn true;\n\t\telse if(fieldl[ly+dy[i]][lx+dx[i]] == '%' || fieldr[ry+ddy[i]][rx+ddx[i]] == '%')\n\t\t\tcontinue;\n\t\tif(fieldl[ly+dy[i]][lx+dx[i]] == '.'){\n\t\t\ttolx = lx+dx[i];\n\t\t\ttoly = ly+dy[i];\n\t\t\tf=true;\n\t\t}\n\t\tif(fieldr[ry+ddy[i]][rx+ddx[i]] == '.'){\n\t\t\ttorx = rx+ddx[i];\n\t\t\ttory = ry+ddy[i];\n\t\t\tf=true;\n\t\t}\n\t\tif(!f)\n\t\t\tcontinue;\n\t\tif(dfs(fieldl,fieldr,tolx,toly,torx,tory))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main(void)\n{\n\twhile(1)\n\t{\n\t\t\n\t\tchar fieldl[55][55];\n\t\tchar fieldr[55][55];\n\t\tmemset(fieldl,0,sizeof(fieldl));\n\t\tmemset(fieldr,0,sizeof(fieldr));\n\t\tcin >> maxw >> maxh;\n\t\tif(maxw==0&&maxh==0)\n\t\t\treturn 0;\n\t\tfor(int y=1;y<=maxh;++y){\n\t\t\tfor(int x=1;x<=maxw;++x){\n\t\t\t\tcin >> fieldl[y][x];\n\t\t\t\tif(fieldl[y][x] == 'L'){\n\t\t\t\t\tlsy = y;lsx = x;\n\t\t\t\t}\n\t\t\t\tif(fieldl[y][x] == 'R'){\n\t\t\t\t\trsy = y;rsx = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int x=1;x<=maxw;++x){\n\t\t\t\tcin >> fieldr[y][x];\n\t\t\t\tif(fieldr[y][x] == 'L'){\n\t\t\t\t\tlsy = y;lsx = x;\n\t\t\t\t}\n\t\t\t\tif(fieldr[y][x] == 'R'){\n\t\t\t\t\trsy = y;rsx = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dfs(fieldl,fieldr,lsx,lsy,rsx,rsy))\n\t\t\tcout << \"Yes\" << endl;\n\t\telse\n\t\t\tcout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#define MAX 51\n#include<cstring>\nusing namespace std;\n\nbool f=false,visited[MAX][MAX][MAX][MAX];\nint w,h;\nchar L[MAX][MAX],R[MAX][MAX];\n\nint ldy[]={0,-1,0,1};\nint ldx[]={1,0,-1,0};\nint rdy[]={0,-1,0,1};\nint rdx[]={-1,0,1,0};\n\nvoid dfs(int ly,int lx, int ry, int rx){\n  visited[ly][lx][ry][rx] = true;\n  //  cout << ly << ' ' << lx  << \" --\" << ry <<' ' << rx <<endl;\n\n  int nly,nlx,nry,nrx;\n  for(int i=0; i<4; i++){\n    nly = ly + ldy[i];\n    nlx = lx + ldx[i];\n    nry = ry + rdy[i];\n    nrx = rx + rdx[i];\n\n    if(!visited[nly][nlx][nry][nrx] &&\n       0<=nly && nly<h && 0<=nlx && nlx<w && 0<=nry && nry<h && 0<=nrx && nrx<w){\n      if(L[nly][nlx]=='%' && R[nry][nrx]=='%'){\n\t//cout << L[nly][nlx] << ' ' << R[nry][nrx]<< endl;\n\t//cout << nly << ' ' << nlx  << \" --\" << nry <<' ' << nrx <<endl;\n\tf = true;\n\treturn ;\n      }\n      if(L[nly][nlx]=='#' && R[nry][nrx]=='.') dfs(ly,lx,nry,nrx);\n      if(L[nly][nlx]=='.' && R[nry][nrx]=='#') dfs(nly,nlx,ry,rx);\n      if(L[nly][nlx]='.' && R[nry][nrx]=='.'){\n\tdfs(nly,nlx,nry,nrx);\n      }\n    }\n  }\n}\n\n\nint main(){\n\n  while(cin >> w >> h ,w|h){\n    cin.ignore();\n\n    for(int i=0; i<h; i++){\n      string str;\n      getline(cin,str);\n      bool first=true;\n      int cnt = 0;\n      for(int j=0; j<str.size(); j++){\n\tif(str[j]==' '){\n\t  first = false;\n\t  continue;\n\t}\n\tif(first) L[i][j] = str[j];\n\telse R[i][cnt++] = str[j];\n      }\n    }\n    int sly,slx,sry,srx;\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tif(L[i][j]=='L'){\n\t  sly = i;\n\t  slx = j;\n\t}\n\tif(R[i][j]=='R'){\n\t  sry = i;\n\t  srx = j;\n\t}\n      }\n    }\n\n    f = false;\n    memset(visited,false,sizeof(visited));\n    visited[sly][slx][sry][srx]=true;\n    dfs(sly,slx,sry,srx);\n    if(f) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <tuple>\nusing namespace std;\n\ntypedef tuple<int,int,int,int> T;\n\nbool isChecked[50][50][50][50];\nbool mapL[50][50];//true:????????? false:????????????\nbool mapR[50][50];\n\nint main(){\n    int W,H;\n    while(cin>>W>>H,W){\n        int SRx,SRy,SLx,SLy,GRx,GRy,GLx,GLy;\n        fill(mapL[0],mapL[50],false);\n        fill(mapR[0],mapR[50],false);\n        for(int i=0;i<H;i++){\n            string strL, strR;\n            cin>>strL>>strR;\n            for(int j=0;j<W;j++){\n                char cL,cR;\n                cL=strL[j];\n                switch(cL){\n                    case '.':\n                        mapL[i][j]=true;\n                        break;\n                    case '#':\n                        break;\n                    case '%':\n                        mapL[i][j]=true;\n                        GLy=i; GLx=j;\n                        break;\n                    case 'L':\n                        mapL[i][j]=true;\n                        SLy=i; SLx=j;\n                        break;\n                }\n                cR=strR[W-1-j];\n                switch(cR){\n                    case '.':\n                        mapR[i][j]=true;\n                        break;\n                    case '#':\n                        break;\n                    case '%':\n                        mapR[i][j]=true;\n                        GRy=i; GRx=j;\n                        break;\n                    case 'R':\n                        mapR[i][j]=true;\n                        SRy=i; SRx=j;\n                        break;\n                }\n            }\n        }\n        fill(isChecked[0][0][0],isChecked[50][0][0],false);\n        isChecked[SLx][SLy][SRx][SRy]=true;\n        queue<T> que;\n        que.emplace(SLx,SLy,SRx,SRy);\n        bool ans=false;\n        while(!que.empty()){\n            T t = que.front(); que.pop();\n            int Lx=get<0>(t), Ly=get<1>(t), Rx=get<2>(t), Ry=get<3>(t);\n            if(Lx==GLx&&Ly==GLy&&Rx==GRx&&Ry==GRy){\n                ans=true;\n                while(!que.empty())que.pop();\n                break;\n            }else if((Lx==GLx&&Ly==GLy)||(Rx==GRx&&Ry==GRy)){\n                continue;\n            }\n            int d[5]={-1,0,1,0,-1};\n            for(int i=0;i<4;i++){\n                int nLx,nLy,nRx,nRy;\n                int dx=d[i],dy=d[i+1];\n                if(Lx+dx<0||Lx+dx>=W||Ly+dy<0||Ly+dy>=H){\n                    nLx=Lx, nLy=Ly;\n                }else if(mapL[Ly+dy][Lx+dx]){\n                    nLx=Lx+dx, nLy=Ly+dy;\n                }else{\n                    nLx=Lx, nLy=Ly;\n                }\n                if(Rx+dx<0||Rx+dx>=W||Ry+dy<0||Ry+dy>=H){\n                    nRx=Rx, nRy=Ry;\n                }else if(mapR[Ry+dy][Rx+dx]){\n                    nRx=Rx+dx, nRy=Ry+dy;\n                }else{\n                    nRx=Rx, nRy=Ry;\n                }\n                if(nLx==Lx&&nLy==Ly&&nRx==Rx&&nRy==Ry){\n                    continue;\n                }else if(!isChecked[nLx][nLy][nRx][nRy]){\n                    isChecked[nLx][nLy][nRx][nRy]=true;\n                    que.emplace(nLx,nLy,nRx,nRy);\n                }\n            }\n        }\n\n        if(ans){\n            cout<<\"Yes\"<<endl;\n        }else{\n            cout<<\"No\"<<endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\n#include <stack>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\ntypedef vector<string> vs;\ntypedef vector<int> vi;\n\n#define rep(i,b) loop(i,0,b)\n#define loop(i,a,b) for(int i=(a); i<int(b); i++)\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nint h,w;\ninline bool in(int x, int y){\n    return 0<=x && 0<=y && x<w && y<h;\n}\n\nbool solve(vs& g1, vs& g2){\n    int sx1, sy1, sx2, sy2;\n    rep(i,h)rep(j,w){\n        if(g1[i][j]=='L'){\n            sx1=j;sy1=i;\n        }\n        if(g2[i][j]=='R'){\n            sx2=j;sy2=i;\n        }\n    }\n    queue<vi> q;\n    static bool vis[64][64][64][64];\n    memset(vis,0,sizeof(vis));\n    q.push(vi{sx1,sy1,sx2,sy2});\n\n    while(q.size()){\n        vi s=q.front();q.pop();\n        int x1=s[0],y1=s[1],x2=s[2],y2=s[3];\n        if(vis[x1][y1][x2][y2])continue;\n        vis[x1][y1][x2][y2]=true;\n        if(g1[y1][x1]=='%' && g2[y2][x2]=='%') return true;\n\n        rep(d,4){\n            int nx1=x1+dx[d],ny1=y1+dy[d];\n            int nx2,ny2;\n            if(d&1){\n                nx2=x2+dx[d],ny2=y2+dy[d];\n            }else{\n                nx2=x2-dx[d],ny2=y2-dy[d];\n            }\n            if(!in(nx1,ny1) || g1[ny1][nx1]=='#')nx1=x1,ny1=y1;\n            if(!in(nx2,ny2) || g2[ny2][nx2]=='#')nx2=x2,ny2=y2;\n            q.push(vi{nx1,ny1,nx2,ny2});\n        }\n    }\n    return false;    \n}\n\nint main(){\n    while(cin>>w>>h && w|h){\n        vs g1(h), g2(h);\n        rep(i,h) cin>>g1[i]>>g2[i];\n        vs ans{\"NO\",\"YES\"};\n        cout << ans[solve(g1,g2)] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nint w,h;\nstring r1[50],r2[50];\n\nbool ch(){\n  bool u[50][50][50][50]={};\n  int lx,ly,rx,ry,ax,ay,bx,by;\n  int dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(r1[i][j]=='L')lx=j,ly=i;\n      if(r2[i][j]=='R')rx=j,ry=i;\n      if(r1[i][j]=='%')ax=j,ay=i;\n      if(r2[i][j]=='%')bx=j,by=i;\n    }\n  queue<PP> q;\n  q.push(PP(P(lx,ly),P(rx,ry)));\n  while(!q.empty()){\n    PP p=q.front();\n    q.pop();\n    lx=p.first.first;\n    ly=p.first.second;\n    rx=p.second.first;\n    ry=p.second.second;\n    if(lx==ax&&ly==ay&&rx==bx&&ry==by)return 1;\n    if(u[lx][ly][rx][ry]||(lx==ax&&ly==ay)||(rx==bx&&ry==by))continue;\n    u[lx][ly][rx][ry]=1;\n    for(int i=0;i<4;i++){\n      int nlx=lx+dx[i];\n      int nly=ly+dy[i];\n      int nrx=rx-dx[i];\n      int nry=ry+dy[i];\n      if(nlx<0||w<=nlx||nly<0||h<=nly||r1[nly][nlx]=='#')nlx=lx,nly=ly;\n      if(nrx<0||w<=nrx||nry<0||h<=nry||r2[nry][nrx]=='#')nrx=rx,nry=ry;\n      q.push(PP(P(nlx,nly),P(nrx,nry)));\n    }\n  }\n  return 0;\n}\n\nint main(){\n  while(cin>>w>>h,w){\n    for(int i=0;i<h;i++)cin>>r1[i]>>r2[i];\n    cout<<(ch()?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <array>\n#include <queue>\n#include <array>\n#include <stack>\n#include <cstring>\n\nenum PassageType{\n\tFREE, WALL, SEARCHED, GOAL,\n};\n\nbool isSearched[50][50][50][50] = {false};\n\nstruct Point {\n\tPoint() { x = 0; y = 0; };\n\tPoint(char x, char y) {\n\t\tthis->x = x;\n\t\tthis->y = y;\n\t};\n\tchar x, y;\n};\n\nint main() {\n\tchar w, h;\n\n\twhile (std::cin >> w >> h && w && h) {\n\t\tstd::memset(isSearched, false, sizeof(bool) * 50 * 50 * 50 * 50);\n\t\tstd::array<std::vector<std::vector<int>>, 2> room;\n\t\tPoint start[2];\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tstd::array<std::string, 2> str;\n\t\t\tfor (int j = 0; j < str.size(); j++) {\n\t\t\t\tstd::cin >> str[j];\n\t\t\t\troom[j].push_back(std::vector<int>());\n\t\t\t\tfor (int k = 0; k < str[j].size(); k++) {\n\t\t\t\t\tint type = 0;\n\t\t\t\t\tif (str[j][k] == '.') type = FREE;\n\t\t\t\t\telse if (str[j][k] == '#') type = WALL;\n\t\t\t\t\telse if (str[j][k] == '%') type = GOAL;\n\t\t\t\t\telse if (str[j][k] == 'L' || str[j][k] == 'R') {\n\t\t\t\t\t\tstart[j].x = k;\n\t\t\t\t\t\tstart[j].y = i;\n\t\t\t\t\t\ttype = SEARCHED;\n\t\t\t\t\t}\n\t\t\t\t\troom[j].back().push_back(type);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstd::stack<std::pair<Point, Point>> s;\n\t\ts.push(std::make_pair(start[0], start[1]));\n\t\tint dx[] = {1, 0, -1, 0};\n\t\tint dy[] = {0, 1, 0, -1};\n\n\t\tbool isOk = false;\n\t\twhile (!s.empty() && !isOk) {\n\t\t\tauto node = s.top(); s.pop();\n\n\t\t\t//?¬???????????????´????????¢???\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tauto next = node;\n\t\t\t\tnext.first.x += dx[i];\n\t\t\t\tnext.first.y += dy[i];\n\t\t\t\tnext.second.x -= dx[i];\n\t\t\t\tnext.second.y += dy[i];\n\n\t\t\t\t//??´????£???£\n\t\t\t\tnext.first.x = std::min(std::max((char)0, next.first.x), (char)(w - 1));\n\t\t\t\tnext.first.y = std::min(std::max((char)0, next.first.y), (char)(h- 1));\n\t\t\t\tnext.second.x = std::min(std::max((char)0, next.second.x), (char)(w - 1));\n\t\t\t\tnext.second.y = std::min(std::max((char)0, next.second.y), (char)(h - 1));\n\n\t\t\t\t//??????????????´????????????OK\n\t\t\t\tif (room[0][next.first.y][next.first.x] == GOAL && room[1][next.second.y][next.second.x] == GOAL) {\n\t\t\t\t\tisOk = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t//?£???????????????????????????????\n\t\t\t\t\tif (room[0][next.first.y][next.first.x] == WALL) {\n\t\t\t\t\t\tnext.first = node.first;\n\t\t\t\t\t}\n\t\t\t\t\tif (room[1][next.second.y][next.second.x] == WALL) {\n\t\t\t\t\t\tnext.second = node.second;\n\t\t\t\t\t}\n\t\t\t\t\tif (!isSearched[next.first.y][next.first.x][next.second.y][next.second.x] && room[0][next.first.y][next.first.x] != GOAL && room[1][next.second.y][next.second.x] != GOAL) {\n\t\t\t\t\t\ts.push(next);\n\t\t\t\t\t\tisSearched[next.first.y][next.first.x][next.second.y][next.second.x] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstd::cout << (isOk ? \"Yes\" : \"No\") << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e9\n#define rep(i,n) for(int i=0;i<n;i++)\n\nstruct C{\n\tint tx,ty,kx,ky;\n\tC(int tx,int ty,int kx,int ky):\n\ttx(tx),ty(ty),kx(kx),ky(ky) {}\n};\n\nint X,Y,sxl,syl,gxl,gyl,sxr,syr,gxr,gyr,dx[]={1,0,-1,0},dy[]={0,1,0,-1},d[51][51][51][51];\nchar l[51][51],r[51][51];\n\nint bfs(int tx,int ty,int kx,int ky){\n\tqueue<C> q;\n\trep(i,X)rep(j,Y)rep(k,X)rep(l,Y)d[i][j][k][l]=INF;\n\tq.push(C(tx,ty,kx,ky));\n\td[tx][ty][kx][ky]=0;\n\twhile(!q.empty()){\n\t\tC c=q.front();q.pop();\n\t\tif(c.tx==gxl&&c.ty==gyl&&c.kx==gxr&&c.ky==gyr)return d[c.tx][c.ty][c.kx][c.ky];\n\t\trep(i,4){\n\t\t\tint ntx=c.tx+dx[i],nty=c.ty+dy[i],nkx=c.kx-dx[i],nky=c.ky+dy[i];\n\t\t\tif(c.tx==gxl&&c.ty==gyl^c.kx==gxr&&c.ky==gyr)break;\n\t\t\tif(ntx<0||ntx>=X||nty<0||nty>=Y||l[nty][ntx]=='#'){ntx=c.tx;nty=c.ty;}\n\t\t\tif(nkx<0||nkx>=X||nky<0||nky>=Y||r[nky][nkx]=='#'){nkx=c.kx;nky=c.ky;}\n\t\t\tif(d[ntx][nty][nkx][nky]==INF){\n\t\t\t\tq.push(C(ntx,nty,nkx,nky));\n\t\t\t\td[ntx][nty][nkx][nky]=d[c.tx][c.ty][c.kx][c.ky]+1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\twhile(cin>>X>>Y&&X){\n\t\trep(i,Y){\n\t\t\trep(j,X){\n\t\t\t\tcin>>l[i][j];\n\t\t\t\tif(l[i][j]=='%'){gxl=j;gyl=i;}\n\t\t\t\tif(l[i][j]=='L'){sxl=j;syl=i;}\n\t\t\t}\n\t\t\trep(j,X){\n\t\t\t\tcin>>r[i][j];\n\t\t\t\tif(r[i][j]=='%'){gxr=j;gyr=i;}\n\t\t\t\tif(r[i][j]=='R'){sxr=j;syr=i;}\n\t\t\t}\n\t\t}\n\t\tint ans=bfs(sxl,syl,sxr,syr);\n\t\tcout<<(bfs(sxl,syl,sxr,syr)?\"Yes\":\"No\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp make_pair\n#define pb push_back\n#define F first\n#define S second\n\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nbool app[50][50][50][50];\n\nmain(){\n  int w,h;\n  while(cin>>w>>h,w|h){\n    memset(app,0,sizeof(app));\n    string lr[h],rr[h];\n    rep(i,h){\n      cin>>lr[i]>>rr[i];\n    }\n\n    string ans=\"No\";\n    int rsx,rsy,lsx,lsy;\n    rep(i,h)rep(j,w){\n      if(lr[i][j]=='L')lsx=i,lsy=j;\n      if(rr[i][j]=='R')rsx=i,rsy=j;\n    }\n\n    queue<pair<PI,PI> > Q;\n    Q.push(mp(mp(lsx,lsy),mp(rsx,rsy)));\n\n    while(!Q.empty()){\n      pair<PI,PI> tp=Q.front();Q.pop();\n      int clx=tp.F.F,cly=tp.F.S,crx=tp.S.F,cry=tp.S.S;\n\n      if(lr[clx][cly]=='%' && rr[crx][cry]=='%'){\n        ans=\"Yes\";\n        break;\n      }\n      app[clx][cly][crx][cry]=true;\n\n      if(lr[clx][cly]=='%' || rr[crx][cry]=='%')continue;\n      \n\n      rep(i,4){\n        int nrx=crx+dx[i],nlx=clx+dx[i],nry=cry+dy[i],nly=cly-dy[i];\n        if(nrx<0 || nry<0 || nrx>=h || nry>=w || lr[nrx][nry]=='#')nrx=crx,nry=cry;\n        if(nlx<0 || nly<0 || nlx>=h || nly>=w || rr[nlx][nly]=='#')nlx=clx,nly=cly;\n        if(app[nlx][nly][nrx][nry])continue;\n        Q.push(mp(mp(nlx,nly),mp(nrx,nry)));\n      }\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define p(S) cout<<(S)<<endl\n#define F first\n#define S second\n#define ck(a,b) (0<=(a)&&(a)<b)\nusing namespace std;\n\nint mcrdx[]={1,0,-1,0};\nint mcldx[]={-1,0,1,0};\nint mcdy[]={0,1,0,-1};\nchar fL[51][51],fR[51][51];\nint mcH,mcW;\nbool mcok[51][51][51][51];\nbool goal;\nvoid mcdfs(pair<int,int> r,pair<int,int> l){\n\tif(mcok[r.F][r.S][l.F][l.S]) return;\n\tmcok[r.F][r.S][l.F][l.S]=true;\n\tif(fR[r.S][r.F]=='%'&&fL[l.S][l.F]=='%') {\n\t\tgoal=true;\n\t\tmemset(mcok,true,sizeof(mcok));\n\t\treturn;\n\t}else if(fR[r.S][r.F]=='%'||fL[l.S][l.F]=='%'){\n\t\treturn;\n\t}\n\tREP(i,0,4){\n\t\tpair<int,int> nr={r.F+mcrdx[i],r.S+mcdy[i]},nl={l.F+mcldx[i],l.S+mcdy[i]};\n\t\tbool okr=true,okl=true;\n\t\tif(!ck(nr.F,mcW)||!ck(nr.S,mcH)) okr=false;\n\t\telse if(fR[nr.S][nr.F]=='#')\tokr=false;\n\t\tif(!ck(nl.F,mcW)||!ck(nl.S,mcH)) okl=false;\n\t\telse if(fL[nl.S][nl.F]=='#')\tokl=false;\n\n\t\tif(!okr&&!okl)  continue;\n\t//cout<<nr.F<<\" \"<<nr.S<<\" \"<<nl.F<<\" \"<<nl.S<<\" \"<<endl;\n\t\tif(okr&&!okl)\tmcdfs(nr,l);\n\t\telse if(!okr&&okl)\tmcdfs(r,nl);\n\t\telse if(okr&&okl)\tmcdfs(nr,nl);\n\t}\n\n\treturn ;\n}\nint main(){\n\n\twhile(cin>>mcW>>mcH,mcW){\n\t\tpair<int,int> Rin,Len;\n\t\tmemset(mcok,false,sizeof(mcok));\n\t\tREP(i,0,mcH) {\n\t\t\tREP(j,0,mcW){\n\t\t\t\tcin>>fL[i][j];\n\t\t\t\tif(fL[i][j]=='L')\tLen={j,i};\n\t\t\t}\n\t\t\tREP(j,0,mcW){\n\t\t\t\tcin>>fR[i][j];\n\t\t\t\tif(fR[i][j]=='R')\tRin={j,i};\n\t\t\t}\n\t\t}\n\t\tgoal=false;\n\t\tmcdfs(Rin,Len);\n\t\tp(goal?\"Yes\":\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint dx[]={1,-1,0,0};\nint dy[]={0,0,1,-1};\nchar L[50][51];\nchar R[50][51];\nstruct wolf{\n\tint ax,ay,bx,by;\n};\nint bfs[50][50][50][50];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<b;i++){\n\t\t\tscanf(\"%s%s\",L[i],R[i]);\n\t\t}\n\t\tfor(int i=0;i<b;i++)\n\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\tfor(int k=0;k<b;k++)\n\t\t\t\t\tfor(int l=0;l<a;l++)\n\t\t\t\t\t\tbfs[i][j][k][l]=0;\n\t\tqueue<wolf>Q;\n\t\twolf S;\n\t\tfor(int i=0;i<b;i++)\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(L[i][j]=='L'){\n\t\t\t\t\tS.ax=i;\n\t\t\t\t\tS.ay=j;\n\t\t\t\t}\n\t\t\t\tif(R[i][j]=='R'){\n\t\t\t\t\tS.bx=i;\n\t\t\t\t\tS.by=j;\n\t\t\t\t}\n\t\t\t}\n\t\tbfs[S.ax][S.ay][S.bx][S.by]=1;\n\t\tQ.push(S);\n\t\twhile(Q.size()){\n\t\t\twolf at=Q.front();\n\t\t\tQ.pop();\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\twolf to=at;\n\t\t\t\tto.ax+=dx[i];\n\t\t\t\tto.ay+=dy[i];\n\t\t\t\tto.bx+=dx[i];\n\t\t\t\tto.by-=dy[i];\n\t\t\t\t//printf(\"%d %d %d %d\\n\",to.ax,to.ay,to.bx,to.by);\n\t\t\t\tbool okL=true;\n\t\t\t\tbool okR=true;\n\t\t\t\tif(0>to.ax||b<=to.ax)okL=false;\n\t\t\t\tif(0>to.bx||b<=to.bx)okR=false;\n\t\t\t\tif(0>to.ay||a<=to.ay)okL=false;\n\t\t\t\tif(0>to.by||a<=to.by)okR=false;\n\t\t\t\tif(okL&&L[to.ax][to.ay]=='#')okL=false;\n\t\t\t\tif(okR&&R[to.bx][to.by]=='#')okR=false;\n\t\t\t\tif(!okL){\n\t\t\t\t\tto.ax-=dx[i];\n\t\t\t\t\tto.ay-=dy[i];\n\t\t\t\t}\n\t\t\t\tif(!okR){\n\t\t\t\t\tto.bx-=dx[i];\n\t\t\t\t\tto.by+=dy[i];\n\t\t\t\t}\n\t\t\t\t//printf(\"%d %d %d %d\\n\\n\",to.ax,to.ay,to.bx,to.by);\n\t\t\t\tif(!bfs[to.ax][to.ay][to.bx][to.by]&&((L[to.ax][to.ay]=='%'&&R[to.bx][to.by]=='%')||(L[to.ax][to.ay]!='%'&&R[to.bx][to.by]!='%'))){\n\t\t\t\t\tbfs[to.ax][to.ay][to.bx][to.by]=1;\n\t\t\t\t\tQ.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twolf G;\n\t\tfor(int i=0;i<b;i++)\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(L[i][j]=='%'){\n\t\t\t\t\tG.ax=i;\n\t\t\t\t\tG.ay=j;\n\t\t\t\t}\n\t\t\t\tif(R[i][j]=='%'){\n\t\t\t\t\tG.bx=i;\n\t\t\t\t\tG.by=j;\n\t\t\t\t}\n\t\t\t}\n\t\tif(bfs[G.ax][G.ay][G.bx][G.by])printf(\"Yes\\n\");\n\t\telse printf(\"No\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<cmath>\n#include<utility>\n#include<functional>\n#include<map>\n#include<set>\n#include<cctype>\n\n\n#define FOR(i, a, b) for( int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for( int i=(a);i>=(b);i--)\n#define LFOR(i, a, b) for( long long int i=(a);i<=(b);i++)\n#define LRFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LLINF 1000000000000000000 //9000000000000000000\n#define PI 3.14159265358979\n#define MAXI 7500000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\n\nint dy[4] = { 0,0,1,-1 };\nint dx[4] = { 1,-1,0,0 };\n\n//int dp[50][50][50][50] = {};//ly,lx,ry,rx\n\n\nint main(void) {\n\t\n\twhile (1) {\n\n\t\ttypedef struct {\n\t\tpublic:\n\t\t\tint leftx;\n\t\t\tint lefty;\n\t\t\tint rightx;\n\t\t\tint righty;\n\t\t}Pos;\n\n\t\tint w, h;\n\t\tint lx = -1, ly = -1, rx = -1, ry = -1;\n\t\tint lgx = -1, lgy = -1, rgx = -1, rgy = -1;\n\n\t\tvector< vector< vector< vector<int> > > > dp(50, vector< vector< vector<int > > >(50, vector< vector<int> >(50, vector<int>(50, 0))));\n\t\t\n\n\t\tqueue< Pos > que;\n\t\tPos now;\n\n\t\tcin >> w >> h;\n\n\t\tif (w == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tvector<string> left(h), right(h);\n\n\t\tFOR(i, 0, h-1) {\n\t\t\tcin >> left[i] >> right[i];\n\t\t}\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (left[i][j] == 'L') {\n\t\t\t\t\tlx = j;\n\t\t\t\t\tly = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (right[i][j] == 'R') {\n\t\t\t\t\trx = j;\n\t\t\t\t\try = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (left[i][j] == '%') {\n\t\t\t\t\tlgx = j;\n\t\t\t\t\tlgy = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lgx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (right[i][j] == '%') {\n\t\t\t\t\trgx = j;\n\t\t\t\t\trgy = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rgx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*dp[ly][lx][ry][rx] = 1;\n\n\t\tnow.lefty = ly;\n\t\tnow.leftx = lx;\n\t\tnow.righty = ry;\n\t\tnow.rightx = rx;\n\t\t\n\t\tque.push(now);\n\n\n\t\twhile (!que.empty()) {\n\t\t\tnow = que.front();\n\t\t\t\n\t\t\tque.pop();\n\t\t\tly = now.lefty;\n\t\t\tlx = now.leftx;\n\t\t\try = now.righty;\n\t\t\trx = now.rightx;\n\t\t\t//cout << ly << \" \" << lx << \" \" << ry << \" \" << rx << endl;\n\n\t\t\tFOR(i, 0, 3) {\n\t\t\t\t\n\t\t\t\tif (ly + dy[i] >= 0 && lx - dx[i] >= 0 && ry + dy[i] <= h - 1 && rx + dx[i] <= w - 1 && ly + dy[i] <= h - 1 && lx - dx[i] <= w - 1 && ry + dy[i] >= 0 && rx + dx[i] >= 0) {\n\t\t\t\t\tif (dp[ly + dy[i]][lx - dx[i]][ry + dy[i]][rx + dx[i]] != 1) {\n\t\t\t\t\t\tif (left[ly + dy[i]][lx - dx[i]] == '#') {\n\t\t\t\t\t\t\tif (right[ry + dy[i]][rx + dx[i]] == '#') {\n\t\t\t\t\t\t\t\t//no\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdp[ly][lx][ry + dy[i]][rx + dx[i]] = 1;\n\t\t\t\t\t\t\t\tnow.lefty = ly;\n\t\t\t\t\t\t\t\tnow.leftx = lx;\n\t\t\t\t\t\t\t\tnow.righty = ry + dy[i];\n\t\t\t\t\t\t\t\tnow.rightx = rx + dx[i];\n\t\t\t\t\t\t\t\tque.push(now);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (right[ry + dy[i]][rx + dx[i]] == '#') {\n\t\t\t\t\t\t\t\tdp[ly + dy[i]][lx - dx[i]][ry][rx] = 1;\n\t\t\t\t\t\t\t\tnow.lefty = ly + dy[i];\n\t\t\t\t\t\t\t\tnow.leftx = lx - dx[i];\n\t\t\t\t\t\t\t\tnow.righty = ry;\n\t\t\t\t\t\t\t\tnow.rightx = rx;\n\t\t\t\t\t\t\t\tque.push(now);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdp[ly + dy[i]][lx - dx[i]][ry + dy[i]][rx + dx[i]] = 1;\n\t\t\t\t\t\t\t\tnow.lefty = ly + dy[i];\n\t\t\t\t\t\t\t\tnow.leftx = lx - dx[i];\n\t\t\t\t\t\t\t\tnow.righty = ry + dy[i];\n\t\t\t\t\t\t\t\tnow.rightx = rx + dx[i];\n\t\t\t\t\t\t\t\tque.push(now);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\n\t\tif (dp[lgy][lgx][rgy][rgx] == 1) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t\t\n\n\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *   @FileName\ta.cpp\n *   @Author\tkanpurin\n *   @Created\t2020.07.13 02:11:35\n**/\n\n#include \"bits/stdc++.h\" \nusing namespace std; \ntypedef long long ll;\n\nint main() {\n    while (true) {\n        int w, h;\n        cin >> w >> h;\n        if (w == 0) {\n            break;\n        }\n        vector<string> s(h),t(h);\n        pair<int,int> s_goal,t_goal,s_start,t_start;\n        for (int i = 0; i < h; i++) {\n            cin >> s[i] >> t[i];\n            for (int j = 0; j < w; j++) {\n                if (s[i][j] == '%') s_goal = {i,j};\n                if (t[i][j] == '%') t_goal = {i,j};\n                if (s[i][j] == 'L') s_start = {i,j};\n                if (t[i][j] == 'R') t_start = {i,j};\n            }\n        }\n        vector<vector<vector<vector<int>>>> dist(h,vector<vector<vector<int>>>(w,vector<vector<int>>(h,vector<int>(w,-1))));\n        queue<tuple<int,int,int,int>> que;\n        que.push(make_tuple(s_start.first,s_start.second,t_start.first,t_start.second));\n        const int dx[] = {0,1,0,-1}, dy[] = {1,0,-1,0};\n        bool ok = false;\n        while(!que.empty()) {\n            auto p = que.front(); que.pop();\n            int sx = get<0>(p);\n            int sy = get<1>(p);\n            int tx = get<2>(p);\n            int ty = get<3>(p);\n            if (sx == s_goal.first && sy == s_goal.second && tx == t_goal.first && ty == t_goal.second) {\n                ok = true;\n                puts(\"Yes\");\n                break;\n            }\n            else if ((sx == s_goal.first && sy == s_goal.second) || (tx == t_goal.first && ty == t_goal.second)) {\n                continue;\n            }\n            for (int i = 0; i < 4; i++) {\n                int x1 = sx + dx[i];\n                int y1 = sy + dy[i];\n                int x2 = tx + dx[i];\n                int y2 = ty - dy[i];\n                if (x1 >= 0 && x1 < h && y1 >= 0 && y1 < w && s[x1][y1] != '#') {\n                }\n                else {\n                    x1 = sx, y1 = sy;\n                }\n                if (x2 >= 0 && x2 < h && y2 >= 0 && y2 < w && t[x2][y2] != '#') {\n                }\n                else {\n                    x2 = tx, y2 = ty;\n                }\n                if (dist[x1][y1][x2][y2] == -1) {\n                    que.push(make_tuple(x1,y1,x2,y2));\n                    dist[x1][y1][x2][y2] = 0;\n                }\n            }\n        }\n        if (!ok) {\n            puts(\"No\");\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct State{\n  int x1, y1, x2, y2;\n  State(int x1, int y1, int x2, int y2): x1(x1), y1(y1), x2(x2), y2(y2){}\n};\n\nconst int MAX = 55;\n\nconst int dx1[] = {1, 0, -1, 0};\nconst int dx2[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nint H, W;\nchar grid[2][MAX][MAX];\nbool used[MAX][MAX][MAX][MAX];\nint sx1, sy1, sx2, sy2;\nint gx1, gy1, gx2, gy2;\n\nbool isValid(int x, int y){\n  return 0 <= x && x < W && 0 <= y && y < H;\n}\n\nbool solve(){\n  queue<State> que;\n  que.push(State(sx1, sy1, sx2, sy2));\n  \n  while(!que.empty()){\n    State q = que.front(); que.pop();\n\n    if(used[q.y1][q.x1][q.y2][q.x2]) continue;\n    used[q.y1][q.x1][q.y2][q.x2] = true;\n    \n    for(int i = 0 ; i < 4 ; i++){\n      int nx1 = q.x1 + dx1[i], ny1 = q.y1 + dy[i];\n      int nx2 = q.x2 + dx2[i], ny2 = q.y2 + dy[i];      \n      \n      if(!isValid(nx1, ny1)) nx1 = q.x1, ny1 = q.y1;\n      if(!isValid(nx2, ny2)) nx2 = q.x2, ny2 = q.y2;\n      if(grid[0][ny1][nx1] == '#' && grid[1][ny2][nx2] == '#') continue;      \n      if(grid[0][ny1][nx1] == '%' && grid[1][ny2][nx2] != '%') continue;      \n      if(grid[0][ny1][nx1] != '%' && grid[1][ny2][nx2] == '%') continue;      \n      \n      if(grid[0][ny1][nx1] == '#') nx1 = q.x1, ny1 = q.y1;\n      if(grid[1][ny2][nx2] == '#') nx2 = q.x2, ny2 = q.y2;\n      \n      que.push(State(nx1, ny1, nx2, ny2));\n    }\n  }\n  return used[gy1][gx1][gy2][gx2];\n}\n\nvoid init(){\n  memset(used, false, sizeof(used));\n  memset(grid, '.', sizeof(grid));\n}\n\nint main(){\n  while(cin >> W >> H, H|W){  \n    init();\n    \n    for(int i = 0 ; i < H ; i++)\n      for(int j = 0 ; j < 2 ; j++) cin >> grid[j][i];\n\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n\tif(grid[0][i][j] == 'L') sx1 = j, sy1 = i;\n\tif(grid[0][i][j] == '%') gx1 = j, gy1 = i;\n      }\n    }\n    \n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n\tif(grid[1][i][j] == 'R') sx2 = j, sy2 = i;\n\tif(grid[1][i][j] == '%') gx2 = j, gy2 = i;\n      }\n    }    \n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <array>\n#include <queue>\n#include <array>\n#include <stack>\n#include <cstring>\n\nenum PassageType{\n\tFREE, WALL, SEARCHED, GOAL,\n};\n\nbool isSearched[50][50][50][50] = {false};\n\nstruct Point {\n\tPoint() { x = 0; y = 0; };\n\tPoint(char x, char y) {\n\t\tthis->x = x;\n\t\tthis->y = y;\n\t};\n\tchar x, y;\n};\n\nint main() {\n\tint w, h;\n\n\twhile (std::cin >> w >> h && w && h) {\n\t\tstd::memset(isSearched, false, sizeof(bool) * 50 * 50 * 50 * 50);\n\t\tstd::array<std::vector<std::vector<int>>, 2> room;\n\t\tPoint start[2];\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tstd::array<std::string, 2> str;\n\t\t\tfor (int j = 0; j < str.size(); j++) {\n\t\t\t\tstd::cin >> str[j];\n\t\t\t\troom[j].push_back(std::vector<int>());\n\t\t\t\tfor (int k = 0; k < str[j].size(); k++) {\n\t\t\t\t\tint type = 0;\n\t\t\t\t\tif (str[j][k] == '.') type = FREE;\n\t\t\t\t\telse if (str[j][k] == '#') type = WALL;\n\t\t\t\t\telse if (str[j][k] == '%') type = GOAL;\n\t\t\t\t\telse if (str[j][k] == 'L' || str[j][k] == 'R') {\n\t\t\t\t\t\tstart[j].x = k;\n\t\t\t\t\t\tstart[j].y = i;\n\t\t\t\t\t\ttype = SEARCHED;\n\t\t\t\t\t}\n\t\t\t\t\troom[j].back().push_back(type);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstd::stack<std::pair<Point, Point>> s;\n\t\ts.push(std::make_pair(start[0], start[1]));\n\t\tint dx[] = {1, 0, -1, 0};\n\t\tint dy[] = {0, 1, 0, -1};\n\n\t\tbool isOk = false;\n\t\twhile (!s.empty() && !isOk) {\n\t\t\tauto node = s.top(); s.pop();\n\n\t\t\t//?¬???????????????´????????¢???\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tauto next = node;\n\t\t\t\tnext.first.x += dx[i];\n\t\t\t\tnext.first.y += dy[i];\n\t\t\t\tnext.second.x -= dx[i];\n\t\t\t\tnext.second.y += dy[i];\n\n\t\t\t\t//??´????£???£\n\t\t\t\tnext.first.x = std::min(std::max((char)0, next.first.x), (char)(w - 1));\n\t\t\t\tnext.first.y = std::min(std::max((char)0, next.first.y), (char)(h - 1));\n\t\t\t\tnext.second.x = std::min(std::max((char)0, next.second.x), (char)(w - 1));\n\t\t\t\tnext.second.y = std::min(std::max((char)0, next.second.y), (char)(h - 1));\n\t\t\t\t//??????????????´????????????OK\n\t\t\t\tif (room[0][next.first.y][next.first.x] == GOAL && room[1][next.second.y][next.second.x] == GOAL) {\n\t\t\t\t\tisOk = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t//?£???????????????????????????????\n\t\t\t\t\tif (room[0][next.first.y][next.first.x] == WALL) {\n\t\t\t\t\t\tnext.first = node.first;\n\t\t\t\t\t}\n\t\t\t\t\tif (room[1][next.second.y][next.second.x] == WALL) {\n\t\t\t\t\t\tnext.second = node.second;\n\t\t\t\t\t}\n\t\t\t\t\tif (!isSearched[next.first.y][next.first.x][next.second.y][next.second.x] && room[0][next.first.y][next.first.x] != GOAL && room[1][next.second.y][next.second.x] != GOAL) {\n\t\t\t\t\t\ts.push(next);\n\t\t\t\t\t\tisSearched[next.first.y][next.first.x][next.second.y][next.second.x] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstd::cout << (isOk ? \"Yes\" : \"No\") << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nstruct Data\n{\n\tint lx,ly,rx,ry;\n};\n\nconst int  dy[] = { 0, 0,+1,-1};\nconst int ldx[] = {+1,-1, 0, 0};\nconst int rdx[] = {-1,+1, 0, 0};\n\nint main()\n{\n\tint W,H;\n\twhile(cin>>W>>H, W||H)\n\t{\n\t\tchar L[50][51];\n\t\tchar R[50][51];\n\t\tfor(int y=0; y<H; y++)\n\t\t{\n\t\t\tcin>>L[y]>>R[y];\n\t\t}\n\n\n\t\tData s;\n\t\tfor(int y=0; y<H; y++)\n\t\tfor(int x=0; x<W; x++)\n\t\t{\t\n\t\t\tif(L[y][x]=='L') { s.lx=x; s.ly=y; }\n\t\t\tif(R[y][x]=='R') { s.rx=x; s.ry=y; }\n\t\t}\n\n\t\tqueue<Data> q;\n\t\tq.push(s);\n\n\t\tbool v[50][50][50][50]={0};\n\t\tv[s.ly][s.lx][s.ry][s.rx]=1;\n\n\t\tbool ans=false;\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tData t=q.front(); q.pop();\n\n\t\t\tif(L[t.ly][t.lx]=='%' && R[t.ry][t.rx]=='%')\n\t\t\t{\n\t\t\t\tans=true; break;\n\t\t\t}\n\t\t\tif(L[t.ly][t.lx]=='%' || R[t.ry][t.rx]=='%')\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor(int i=0; i<4; i++)\n\t\t\t{\n\t\t\t\tData n;\n\t\t\t\tn.ly = t.ly +  dy[i];\n\t\t\t\tn.lx = t.lx + ldx[i];\n\t\t\t\tn.ry = t.ry +  dy[i];\n\t\t\t\tn.rx = t.rx + rdx[i];\n\n\t\t\t\tif(n.lx<0 || W<=n.lx || n.ly<0 || H<=n.ly)\n\t\t\t\t{\n\t\t\t\t\tn.ly = t.ly;\n\t\t\t\t\tn.lx = t.lx;\n\t\t\t\t}\n\t\t\t\tif(n.rx<0 || W<=n.rx || n.ry<0 || H<=n.ry)\n\t\t\t\t{\n\t\t\t\t\tn.ry = t.ry;\n\t\t\t\t\tn.rx = t.rx;\n\t\t\t\t}\n\t\t\t\tif(L[n.ly][n.lx]=='#')\n\t\t\t\t{\n\t\t\t\t\tn.ly = t.ly;\n\t\t\t\t\tn.lx = t.lx;\n\t\t\t\t}\n\t\t\t\tif(R[n.ry][n.rx]=='#')\n\t\t\t\t{\n\t\t\t\t\tn.ry = t.ry;\n\t\t\t\t\tn.rx = t.rx;\n\t\t\t\t}\n\n\t\t\t\tif(v[n.ly][n.lx][n.ry][n.rx]) continue;\n\t\t\t\tv[n.ly][n.lx][n.ry][n.rx]=1;\n\t\t\t\tq.push(n);\n\t\t\t}\n\t\t}\n\n\t\tcout << (ans?\"Yes\":\"No\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint w, h;\nstring l[52], r[52];\nint ldx[4] = {1, 0, -1, 0};\nint ldy[4] = {0, 1, 0, -1};\nint rdx[4] = {1, 0, -1, 0};\nint rdy[4] = {0, -1, 0, 1};\nint lsx, lsy, rsx, rsy, lgx, lgy, rgx, rgy;\nbool lischecked[52][52], rischecked[52][52];\n\nbool solve(int lx, int ly, int rx, int ry){\n    if(lx == lgx && ly == lgy && rx == rgx && ry == rgy) return true;\n    if((lx == lgx && ly == lgy) || (rx == rgx && ry == rgy)) return false;\n    for(int i = 0; i < 4; i++){\n        int nlx = lx + ldx[i], nly = ly + ldy[i];\n        int nrx = rx + rdx[i], nry = ry + rdy[i];\n        if((nlx < 0 || nly < 0 || nlx >= h || nly >= w) && (nrx < 0 || nry < 0 || nrx >= h || nry >= w)) continue;\n        if((l[nlx][nly] == '#' && r[nrx][nry] == '#') || (lischecked[nlx][nly] && rischecked[nrx][nry])) continue;\n        if(nlx < 0 || nlx >= h || nly < 0 || nly >= w || l[nlx][nly] == '#'){\n            nlx = lx;\n            nly = ly;\n        }\n        if(nrx < 0 || nrx >= h || nry < 0 || nry >= w || r[nrx][nry] == '#'){\n            nrx = rx;\n            nry = ry;\n        }\n        lischecked[nlx][nly] = true;\n        rischecked[nrx][nry] = true;\n        if(solve(nlx, nly, nrx, nry)) return true;\n        lischecked[nlx][nly] = false;\n        rischecked[nrx][nry] = false;\n    }\n    return false;\n}\n\nint main()\n{\n    while(1){\n        cin >> w >> h;\n        cout << \"jo\" << endl;\n        if(w == 0 && h == 0) break;\n        for(int i = 0; i < h; i++){\n            cin >> l[i] >> r[i];\n        }\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                lischecked[i][j] = false;\n                rischecked[i][j] = false;\n                if(l[i][j] == 'L'){\n                    lsx = i;\n                    lsy = j;\n                }\n                if(l[i][j] == '%'){\n                    lgx = i;\n                    lgy = j;\n                }\n                if(r[i][j] == 'R'){\n                    rsx = i;\n                    rsy = j;\n                }\n                if(r[i][j] == '%'){\n                    rgx = i;\n                    rgy = j;\n                }\n            }\n        }\n        lischecked[lsx][lsy] = true;\n        rischecked[rsx][rsy] = true;\n        if(solve(lsx, lsy, rsx, rsy)) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntypedef double weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\ntypedef vector<vector<edge>> Graph;\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\n\n\nint main()\n{\n\tint h, w;\n\twhile (cin >> w >> h, w)\n\t{\n\t\tvs fld1(h), fld2(h);\n\t\tREP(i, h) cin >> fld1[i] >> fld2[i];\n\t\tpii sa, sb, ga, gb;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld1[i][j] == 'L') sa = pii(i, j);\n\t\t\tif (fld2[i][j] == 'R') sb = pii(i, j);\n\t\t\tif (fld1[i][j] == '%') ga = pii(i, j);\n\t\t\tif (fld2[i][j] == '%') gb = pii(i, j);\n\t\t}\n\t\ttypedef pair<pii, pii> data;\n\t\tset<data> st;\n\t\tqueue<data> que;\n\t\tque.push(data(sa, sb));\n\t\tdata goal = data(ga, gb);\n\t\twhile (que.size())\n\t\t{\n\t\t\tdata tmp = que.front();\n\t\t\tque.pop();\n\t\t\tint lx = tmp.first.first, ly = tmp.first.second;\n\t\t\tint rx = tmp.second.first, ry = tmp.second.second;\n\t\t\tREP(i, 4)\n\t\t\t{\n\t\t\t\tint lnx = lx + dx[i], lny = ly + dy[i];\n\t\t\t\tint rnx = rx + dx[i], rny = ry - dy[i];\n\t\t\t\tif (!valid(lnx, lny, h, w) || fld1[lnx][lny]=='#')\n\t\t\t\t{\n\t\t\t\t\tlnx = lx, lny = ly;\n\t\t\t\t}\t\t\t\t\n\t\t\t\tif (!valid(rnx, rny, h, w) || fld2[rnx][rny] == '#')\n\t\t\t\t{\n\t\t\t\t\trnx = rx, rny = ry;\n\t\t\t\t}\n\t\t\t\tpii nl(lnx, lny), nr(rnx, rny);\n\t\t\t\tdata next = data(nl, nr);\n\t\t\t\tif (next != goal && (nl == ga || nr == gb)) continue;\n\t\t\t\tif (st.find(next) != st.end()) continue;\n\t\t\t\tst.insert(next);\n\t\t\t\tif (next == goal) break;\n\t\t\t\tque.push(next);\n\t\t\t}\n\t\t}\n\t\tif (st.find(goal) == st.end()) puts(\"No\");\n\t\telse puts(\"Yes\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <sstream>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cstring>\n \nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nint w,h;\nint sxl,syl,sxr,syr;\nstring L[100],R[100];\n\nconst int dx[]={0,1,0,-1};\nconst int dy[]={-1,0,1,0};\n\nint vis[50][50][50][50];\n\nbool solve(int xl,int yl,int xr, int yr)\n{\n\n\n\tif(vis[yl][xl][yr][xr]==1) return false;\n\t\t\n\tif(L[yl][xl]=='%' && R[yr][xr]=='%') return true;\n\tif(L[yl][xl]=='%' && R[yr][xr]!='%') return false;\n\tif(L[yl][xl]!='%' && R[yr][xr]=='%') return false;\n\t\n\n\t\n\tvis[yl][xl][yr][xr]=1;\n\t\n\tfor(int i=0;i<4;i++){\n\t\tint nxl=xl+dx[i], nyl=yl+dy[i];\n\t\tint nxr=xr-dx[i], nyr=yr+dy[i];\n\n\t\tif(nxl<0 || w<=nxl || nyl<0 || h<=nyl ||\n\t\t   nxr<0 || w<=nxr || nyr<0 || h<=nyr ) continue;\n\t\t\n\t\tif(L[nyl][nxl]=='#'){\n\t\t\tnxl-=dx[i]; nyl-=dy[i];\n\t\t}\n\t\tif(R[nyr][nxr]=='#'){\n\t\t\tnxr+=dx[i]; nyr-=dy[i];\n\t\t}\n\n\t\tif(nxl<0 || w<=nxl || nyl<0 || h<=nyl ||\n\t\t   nxr<0 || w<=nxr || nyr<0 || h<=nyr ) continue;\n\t\t\n\t\tif(solve(nxl,nyl,nxr,nyr)) return true;\n\t\t\n\t}\n\t\n\treturn false;\n\n}\n\nint main()\n{\n\t\n\twhile(cin>>w>>h,w){\t\t\n\n\t\tmemset(vis,-1,sizeof(int)*50*50*50*50);\n\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>L[i]>>R[i];\n\t\t}\n\t\t\n\t\t\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(L[i][j]=='L'){sxl=j,syl=i;}\n\t\t\t\tif(R[i][j]=='R'){sxr=j,syr=i;}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(solve(sxl,syl,sxr,syr)) cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t\t\n\t}\n\t\t\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\nbool used[51][51][51][51];\nstring roomL[51], roomR[51];\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while (true) {\n    int R, C;\n    cin >> C >> R;\n    if (R == 0 && C == 0) break;\n    REP(i, R) cin >> roomL[i] >> roomR[i];\n\n    int slr = 0, slc = 0, elr = 0, elc = 0, srr = 0, src = 0, err = 0, erc = 0;\n    REP(r, R) REP(c, C) {\n      if (roomL[r][c] == 'L') slr = r, slc = c;\n      if (roomR[r][c] == 'R') srr = r, src = c;\n      if (roomL[r][c] == '%') elr = r, elc = c;\n      if (roomR[r][c] == '%') err = r, erc = c;\n    }\n    //cout << slr << ' ' << slc << ' ' << elr << ' ' << elc << ' ' << srr << ' ' << src << ' ' << err << ' ' << erc << endl;\n    REP(i, R) REP(j, C) REP(k, R) REP(l, C) used[i][j][k][l] = false;\n    \n    queue<P> que;\n    que.push(P(slr * C + slc, srr * C + src));\n\n    bool flag = false;\n    while (!que.empty()) {\n      P p = que.front(); que.pop();\n      int lr = p.first / C, lc = p.first % C, rr = p.second / C, rc = p.second % C;\n      //cout << lr << ' ' << lc << ' ' << rr << ' ' << rc << endl;\n      if (lr == elr && lc == elc && rr == err && rc == erc) {\n\tflag = true;\n\tbreak;\n      } else if (used[lr][lc][rr][rc] || (lr == elr && lc == elc) || (rr == err && rc == erc)) {\n\tcontinue;\n      }\n\n      used[lr][lc][rr][rc] = true;\n      REP(i, 4) {\n\tint nlr = lr + dr[i], nlc = lc + dc[i], nrr = rr + dr[(i+2*(i&1))%4], nrc = rc + dc[(i+2*(i&1))%4];\n\tif (nlr < 0 || nlr >= R || nlc < 0 || nlc >= C || roomL[nlr][nlc] == '#') nlr = lr, nlc = lc;\n\tif (nrr < 0 || nrr >= R || nrc < 0 || nrc >= C || roomR[nrr][nrc] == '#') nrr = rr, nrc = rc;\n\tif (!used[nlr][nlc][nrr][nrc]) que.push(P(nlr * C + nlc, nrr * C + nrc));\n      }\n    }\n    cout << (flag ? \"Yes\" : \"No\") << endl;    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <fstream>\n#include <stack>\n#include <cstring>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, k, n) for (int i = (int)(k); i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rREP(i, k, n) for (int i = (int)(n)-1; i >= k; i--)\n\n#define debug(x) cerr << #x << \": \" << x << endl;\n\n#define fi first\n#define se second\n\n#define vi vector<int>\n#define pii pair<int, int>\n#define pb push_back\n#define mp make_pair\n\n#define pcnt __builtin_popcount\n\ntypedef long long ll;\n\nconst int    inf = 100100100;\n\n\nconst int    dx[4] = { 0, 1, 0, -1 };\nconst int    dy[4] = { 1, 0, -1, 0 };\n\nstruct POINT {\n    int lx;\n    int ly;\n    int rx;\n    int ry;\n};\n\nbool u[55][55][55][55] = {};\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n//    ifstream in(\"in.txt\");\n//    cin.rdbuf(in.rdbuf());\n    int  w, h;\n    char ML[55][55], MR[55][55];\n    int slx,sly,srx,sry;\n    while (cin >> w >> h, w) {\n        memset(u,0,sizeof(u));\n        memset(ML,0,sizeof(ML));\n        memset(MR,0,sizeof(MR));\n\n        rep(y, h) {\n            string sml,smr;\n            cin >> sml >> smr;\n            sml.copy(ML[y],sml.size()+1);\n            smr.copy(MR[y],smr.size()+1);\n\n        }\n        rep(y, h) rep(x,w){\n                if(ML[y][x] == 'L') ML[y][x] = '.',slx = x,sly = y;\n                if(MR[y][x] == 'R') ML[y][x] = '.',srx = x,sry = y;\n            }\n        stack<POINT> st;\n        st.push(POINT{slx, sly, srx, sry});\n\n        bool flag = false;\n        while (!st.empty()) {\n            POINT p = st.top();\n            st.pop();\n\n            rep(i, 4) {\n                int nlx = p.lx + dx[i];\n                int nly = p.ly + dy[i];\n                int nrx = p.rx + dx[(i + 2) % 4];\n                int nry = p.ry + dy[i];\n                bool left_do = true;\n                bool right_do = true;\n                if (nlx < 0 || w <= nlx) left_do = false;\n                if (nly < 0 || h <= nly) left_do = false;\n                if (ML[nly][nlx] == '#') left_do = false;\n                if (nrx < 0 || w <= nrx) right_do = false;\n                if (nry < 0 || h <= nry) right_do = false;\n                if (MR[nry][nrx] == '#') right_do = false;\n                if (ML[nly][nlx] == '%' && MR[nry][nrx] == '%') {\n                    flag = true;\n                    while (!st.empty()) st.pop();\n                    break;\n                } else if (ML[nly][nlx] == '%' || MR[nry][nrx] == '%') {\n                    continue;\n                }\n                if (!left_do && !right_do) continue;\n                if (!left_do) nlx = p.lx, nly = p.ly;\n                if (!right_do) nrx = p.rx, nry = p.ry;\n                if(!u[nlx][nly][nrx][nry]) {\n                    u[nlx][nly][nrx][nry] = true;\n                    st.push(POINT{nlx, nly, nrx, nry});\n                }\n            }\n\n        }\n        if (flag)\n            cout << \"Yes\" << endl;\n        else\n            cout << \"No\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <set>\n#include <queue>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\tint h, w, i, j, a, b, c, d, dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\n\tchar rf[50][51], lf[50][51];\n\tset<pair<P,P> > s;\n\tP rs, ls, rg, lg;\n\tqueue<P> r, l;\n\tset<pair<P,P> >::iterator iti;\n\twhile(1){\n\t\tscanf(\"%d%d%*c\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tlf[i][j] = getchar();\n\t\t\t\tif(lf[i][j] == 'L'){\n\t\t\t\t\tls = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(lf[i][j] == '%'){\n\t\t\t\t\tlg = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 空白読み飛ばし\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\trf[i][j] = getchar();\n\t\t\t\tif(rf[i][j] == 'R'){\n\t\t\t\t\trs = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(rf[i][j] == '%'){\n\t\t\t\t\trg = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 改行文字読み飛ばし\n\t\t}\n\t\tr.push(rs), l.push(ls);\n\t\twhile(r.size()){\n\t\t\ta = l.front().first, b = l.front().second, c = r.front().first, d = r.front().second;\n\t\t\tl.pop(), r.pop();\n\t\t\ts.insert(pair<P,P>(P(a,b),P(c,d)));\n\t\t\tfor(i = 0;i < 4;i++){\n\t\t\t\tif(a + dy[i] >= 0 && a + dy[i] < h && b + dx[i] >= 0 && b + dx[i] < w && lf[a + dy[i]][b + dx[i]] == '.' && c + dy[i] >= 0 && c + dy[i] < h && d - dx[i] >= 0 && d - dx[i] < w && rf[c + dy[i]][d - dx[i]] == '.' && s.find(pair<P,P>(P(a + dy[i],b + dx[i]),P(c + dy[i],d - dx[i]))) == s.end()) // 両方とも動くとき\n\t\t\t\t\tl.push(P(a + dy[i],b + dx[i])), r.push(P(c + dy[i],d - dx[i]));\n\t\t\t\telse if((a + dy[i] < 0 || a + dy[i] >= h || b + dx[i] < 0 || b + dx[i] >= w || lf[a + dy[i]][b + dx[i]] == '#') && c + dy[i] >= 0 && c + dy[i] < h && d - dx[i] >= 0 && d - dx[i] < w && rf[c + dy[i]][d - dx[i]] == '.' && s.find(pair<P,P>(P(a,b),P(c + dy[i],d - dx[i]))) == s.end()) // Rinだけ動く\n\t\t\t\t\tl.push(P(a,b)), r.push(P(c + dy[i],d - dx[i]));\n\t\t\t\telse if(a + dy[i] >= 0 && a + dy[i] < h && b + dx[i] >= 0 && b + dx[i] < w && lf[a + dy[i]][b + dx[i]] == '.' && (c + dy[i] < 0 || c + dy[i] >= h || d - dx[i] < 0 || d - dx[i] >= w || rf[c + dy[i]][d - dx[i]] == '#') && s.find(pair<P,P>(P(a + dy[i],b + dx[i]),P(c,d))) == s.end()) // Lenだけ動く\n\t\t\t\t\tl.push(P(a + dy[i],b + dx[i])), r.push(P(c,d));\n\t\t\t}\n\t\t}\n\t\tif(s.find(pair<P,P>(P(lg.first,lg.second),P(rg.first,rg.second))) != s.end())\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t\tfor(iti = s.begin();iti != s.end();iti = s.erase(iti));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst double EPS = 1e-9;\n\nint main(){\n    while(true){\n        int W,H;\n        cin >> W >> H;\n        if(W == 0 and H == 0) break;\n        vector<vector<string> > field(2,vector<string>(H+2));\n        field[0][0] = string(W+2,'#');\n        field[1][0] = string(W+2,'#');\n        field[0][H+1] = string(W+2,'#');\n        field[1][H+1] = string(W+2,'#');\n\n        for(int i=1;i<=H;i++){\n            for(int j=0;j<2;j++){\n                cin >> field[j][i];\n                field[j][i] = '#' + field[j][i] + '#';\n                if(j == 1) reverse(all(field[j][i]));\n            }\n        }\n        pair<pii,pii> start;\n        pair<pii,pii> goal;\n        for(int i=0;i<2;i++){\n            for(int j=1;j<=H;j++){\n                for(int k=1;k<=W;k++){\n                    if(field[i][j][k] == 'L'){\n                        start.first = make_pair(j,k);\n                    }else if(field[i][j][k] == 'R'){\n                        start.second = make_pair(j,k);\n                    }\n                    if(field[i][j][k] == '%'){\n                        if(i == 0){\n                            goal.first = make_pair(j,k);\n                        }else{\n                            goal.second = make_pair(j,k);\n                        }\n                    }\n                }\n            }\n        }\n        stack<pair<pii,pii> > sta;\n        sta.push(start);\n        set<pair<pii,pii> > used;\n        bool ok = false;\n        while(not sta.empty()){\n            pair<pii,pii> now = sta.top();\n            sta.pop();\n            if(used.find(now) != used.end()){\n                continue;\n            }\n            used.insert(now);\n            if(now == goal){\n                ok = true;\n                break;\n            }\n            for(int i=0;i<4;i++){\n                pair<pii,pii> next = now;\n                next.first.first += dx[i];\n                next.first.second += dy[i];\n                next.second.first += dx[i];\n                next.second.second += dy[i];\n                if(field[0][next.first.first][next.first.second] == '#'){\n                    next.first = now.first;\n                }\n                if(field[1][next.second.first][next.second.second] == '#'){\n                    next.second = now.second;\n                }\n                sta.push(next);\n            }\n        }\n        if(ok){\n            cout << \"Yes\" << endl;\n        }else{\n            cout << \"No\" << endl;\n        }\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<sstream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<climits>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = j; i < k; i++)\n#define P pair<int, int>\n#define PP pair<P, P>\nconst int INF = INT_MAX / 2;\nconst int MAX_H = 51;\nconst int MAX_W = 51;\n\nbool closed[MAX_H][MAX_W][MAX_H][MAX_W];\n\nbool canMove(int y, int x, vector< vector<char> > m){\n    if(m[y][x] == '#') return false;\n    else return true;\n}\n\nint main(){\n    int w, h;\n    while(cin >>w >>h && (w || h) ){\n\n        int srx, sry, slx, sly;\n        int grx, gry, glx, gly;\n        vector< vector<char> > l_map(h + 2, vector<char>(w + 2, '*') ), r_map(h + 2, vector<char>(w + 2, '*') );\n\n        //start of input\n        REP(i, l_map.size()){\n            l_map[i][0] = '#';\n            r_map[i][0] = '#';\n            l_map[i][w + 1] = '#';\n            r_map[i][w + 1] = '#';\n        }\n        REP(i, l_map[0].size()){\n            l_map[0][i] = '#';\n            r_map[0][i] = '#';\n            l_map[h + 1][i] = '#';\n            r_map[h + 1][i] = '#';\n        }\n\n        FOR(i, 1, h + 1){\n            FOR(j, 1, w + 1){\n                cin >>l_map[i][j];\n                if(l_map[i][j] == 'L'){\n                    sly = i;\n                    slx = j;\n                }\n                if(l_map[i][j] == '%'){\n                    gly = i;\n                    glx = j;\n                }\n            }\n            FOR(j, 1, w + 1){\n                cin >>r_map[i][j];\n                if(r_map[i][j] == 'R'){\n                    sry = i;\n                    srx = j;\n                }\n                if(r_map[i][j] == '%'){\n                    gry = i;\n                    grx = j;\n                }\n            }\n        }\n        //end of input\n\n        queue<PP> open;\n        open.push( PP( P(sry, srx), P(sly, slx) ) );\n        memset(closed, false, sizeof(closed));\n\n        bool ans = false;\n        int my[] = {0, 0, 1, -1};\n        int mx[] = {1, -1, 0, 0};\n\n        while(!open.empty()){\n            PP now = open.front();\n            open.pop();\n            int ry = now.first.first, rx = now.first.second, ly = now.second.first, lx = now.second.second;\n\n            if(ry == gry && rx == grx && ly == gly && lx == glx){\n                ans = true;\n                break;\n            }\n            closed[ry][rx][ly][lx] = true;\n\n            REP(i, 4){\n                int n_ry = ry + my[i];\n                int n_rx = rx + mx[i];\n                int n_ly = ly + my[i];\n                int n_lx = lx + (mx[i] * -1);\n\n                if(!canMove(n_ry, n_rx, r_map) && !canMove(n_ly, n_lx, l_map)){\n                    continue;\n                } else if(!canMove(n_ry, n_rx, r_map)){\n                    n_ry = ry;\n                    n_rx = rx;\n                }\n                else if(!canMove(n_ly, n_lx, l_map)){\n                    n_ly = ly;\n                    n_lx = lx;\n                }\n                if(closed[n_ry][n_rx][n_ly][n_lx]) continue;\n                open.push( PP( P(n_ry, n_rx), P(n_ly, n_lx) ) );\n            }\n        }\n\n        cout <<((ans)? \"Yes\" : \"No\") <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint dx1[] = {0,1,0,-1};\nint dy1[] = {-1,0,1,0};\nint dx2[] = {0,-1,0,1};\nint dy2[] = {-1,0,1,0};\n\nbool visited[50][50][50][50];\n\nint w, h;\nchar ba1[50][50];\nchar ba2[50][50];\n\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> P;\n\nbool solve(int x1,int y1, int x2, int y2) {\n//  printf(\"(%d,%d),(%d,%d)\\n\",x1,y1,x2,y2);\n\n  queue<P> Q;\n  Q.push(P(pii(x1,y1), pii(x2,y2)));\n  while(!Q.empty()) {\n    pii p1 = Q.front().first;\n    pii p2 = Q.front().second;\n    int x1 = p1.first;\n    int y1 = p1.second;\n    int x2 = p2.first;\n    int y2 = p2.second;\n    Q.pop();\n    if (visited[x1][y1][x2][y2]) continue;\n    \n    visited[x1][y1][x2][y2] = 1;\n    \n    if (ba1[x1][y1] == '%' && ba2[x2][y2] == '%')\n      return 1;\n    else if (ba1[x1][y1] == '%' || ba2[x2][y2] == '%')\n      continue;\n    REP(i,4) {\n      int xx1 = x1+dx1[i];\n      int yy1 = y1+dy1[i];\n      int xx2 = x2+dx2[i];\n      int yy2 = y2+dy2[i];\n\n      if (xx1<0||xx1>=w||yy1<0||yy1>=h || ba1[xx1][yy1] == '#') {\n        xx1 = x1;\n        yy1 = y1;\n      }\n      if (xx2<0||xx2>=w||yy2<0||yy2>=h || ba2[xx2][yy2] == '#') {\n        xx2 = x2;\n        yy2 = y2;\n      }\n      if (!visited[xx1][yy1][xx2][yy2]) {\n        Q.push(P(pii(xx1,yy1),pii(xx2,yy2)));\n      }\n    }\n  }\n  return 0;\n}\n\nint main() {\n  while(cin >> w>>h, w||h) {\n\n    int sx1,sy1,sx2,sy2;\n    \n    REP(y,h) {\n      REP(x,w) {\n        cin >> ba1[x][y];\n        \n        if (ba1[x][y]=='L') {\n          sx1 = x; sy1 = y;\n        }\n      }\n      REP(x,w) {\n        cin >> ba2[x][y];\n        if (ba2[x][y]=='R') {\n          sx2 = x; sy2 = y;\n        }\n      }\n    }\n    memset(visited, 0, sizeof(visited));\n    if (solve(sx1,sy1,sx2,sy2))\n      cout << \"Yes\" << endl;\n    else\n      cout << \"No\" << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx_r[] = {0,1,0,-1};\nstatic const int ty_r[] = {-1,0,1,0};\n\nstatic const int tx_l[] = {0,-1,0,1};\nstatic const int ty_l[] = {-1,0,1,0};\n\nclass PosInfo {\npublic:\n  int Rin_x;\n  int Rin_y;\n  int Len_x;\n  int Len_y;\n  PosInfo(int a,int b,int c,int d) : Rin_x(a),Rin_y(b),Len_x(c),Len_y(d) {}\n};\n\nbool visited[51][51][51][51];\nchar stage_Len[51][51];\nchar stage_Rin[51][51];\n\nbool can_reach;\nint W,H;\n\nint main(){\n\n  while(~scanf(\"%d %d\",&W,&H)){\n    if(W==0 && H==0) break;\n\n    for(int y=0;y<H;y++){\n      for(int x=0;x<W;x++){\n\tfor(int y2=0;y2<H;y2++){\n\t  for(int x2=0;x2<W;x2++){\n\t    visited[x][y][x2][y2] = false;\n\t  }\n\t}\n      }\n    }\n\n    can_reach = false;\n    \n    int Rin_start_x = 0;\n    int Rin_start_y = 0;\n    int Len_start_x = 0;\n    int Len_start_y = 0;\n \n    for(int y=0;y<H;y++){\n      string str_Len,str_Rin;\n      cin >> str_Len >> str_Rin;\n      \n      // cout << str_Len << endl;\n      // cout << str_Rin << endl;\n\n      for(int x=0;x<W;x++){\n\tstage_Len[y][x] = str_Len[x];\n\tstage_Rin[y][x] = str_Rin[x];\n\n\tif(str_Len[x] == 'L'){\n\t  Len_start_x = x;\n\t  Len_start_y = y;\n\t}\n\tif(str_Rin[x] == 'R'){\n\t  Rin_start_x = x;\n\t  Rin_start_y = y;\n\t}\n      }\n    }\n    \n    queue<PosInfo> que;\n    que.push(PosInfo(Rin_start_x,Rin_start_y,Len_start_x,Len_start_y));\n    visited[Rin_start_x][Rin_start_y][Len_start_x][Len_start_y] = true;\n    \n    while(!que.empty()){\n      PosInfo pi = que.front();\n      que.pop();\n\n      for(int i=0;i<4;i++){\n\tint Rin_dx = pi.Rin_x + tx_r[i];\n\tint Rin_dy = pi.Rin_y + ty_r[i];\n\n\tint Len_dx = pi.Len_x + tx_l[i];\n\tint Len_dy = pi.Len_y + ty_l[i];\n\n\tif(Rin_dx < 0 || Rin_dx >= W || Rin_dy < 0 || Rin_dy >= H){\n\t  Rin_dy = pi.Rin_y;\n\t  Rin_dx = pi.Rin_x;\n\t}\n\telse if(stage_Rin[Rin_dy][Rin_dx] == '#'){\n\t  Rin_dy = pi.Rin_y;\n\t  Rin_dx = pi.Rin_x;\n\t}\n\n\tif(Len_dx < 0 || Len_dx >= W || Len_dy < 0 || Len_dy >= H){\n\t  Len_dy = pi.Len_y;\n\t  Len_dx = pi.Len_x;\n\t}\n\telse if(stage_Len[Len_dy][Len_dx] == '#'){\n\t  Len_dy = pi.Len_y;\n\t  Len_dx = pi.Len_x;\n\t}\n\n\tif(visited[Rin_dx][Rin_dy][Len_dx][Len_dy]){\n\t  continue;\n\t}\n\n\tif(stage_Len[Len_dy][Len_dx] == '%'\n\t   && stage_Rin[Rin_dy][Rin_dx] == '%'){\n\t  can_reach = true;\n\t  break;\n\t}\n\n\tif(stage_Len[Len_dy][Len_dx] != '%'\n\t   && stage_Rin[Rin_dy][Rin_dx] != '%'){\n\t  visited[Rin_dx][Rin_dy][Len_dx][Len_dy] = true;\n\t  que.push(PosInfo(Rin_dx,Rin_dy,Len_dx,Len_dy));\n\t}\n      }\n    }\n\n    printf(\"%s\\n\",can_reach ? \"Yes\" : \"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <fstream>\n#include <stack>\n#include <cstring>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, k, n) for (int i = (int)(k); i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rREP(i, k, n) for (int i = (int)(n)-1; i >= k; i--)\n\n#define debug(x) cerr << #x << \": \" << x << endl;\n\n#define fi first\n#define se second\n\n#define vi vector<int>\n#define pii pair<int, int>\n#define pb push_back\n#define mp make_pair\n\n#define pcnt __builtin_popcount\n\ntypedef long long ll;\n\nconst int    inf = 100100100;\n\n\nconst int    dx[4] = { 0, 1, 0, -1 };\nconst int    dy[4] = { 1, 0, -1, 0 };\n\nstruct POINT {\n    int lx;\n    int ly;\n    int rx;\n    int ry;\n};\n\nbool u[55][55][55][55] = {};\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    ifstream in(\"in.txt\");\n    cin.rdbuf(in.rdbuf());\n    int  w, h;\n    char ML[55][55], MR[55][55];\n    int slx,sly,srx,sry;\n    while (cin >> w >> h, w) {\n        memset(u,0,sizeof(u));\n        memset(ML,0,sizeof(ML));\n        memset(MR,0,sizeof(MR));\n\n        rep(y, h) {\n            string sml,smr;\n            cin >> sml >> smr;\n            sml.copy(ML[y],sml.size()+1);\n            smr.copy(MR[y],smr.size()+1);\n\n        }\n        rep(y, h) rep(x,w){\n                if(ML[y][x] == 'L') ML[y][x] = '.',slx = x,sly = y;\n                if(MR[y][x] == 'R') ML[y][x] = '.',srx = x,sry = y;\n            }\n        stack<POINT> st;\n        st.push(POINT{slx, sly, srx, sry});\n\n        bool flag = false;\n        while (!st.empty()) {\n            POINT p = st.top();\n            st.pop();\n\n            rep(i, 4) {\n                int nlx = p.lx + dx[i];\n                int nly = p.ly + dy[i];\n                int nrx = p.rx + dx[(i + 2) % 4];\n                int nry = p.ry + dy[i];\n                bool left_do = true;\n                bool right_do = true;\n                if (nlx < 0 || w <= nlx) left_do = false;\n                if (nly < 0 || h <= nly) left_do = false;\n                if (ML[nly][nlx] == '#') left_do = false;\n                if (nrx < 0 || w <= nrx) right_do = false;\n                if (nry < 0 || h <= nry) right_do = false;\n                if (MR[nry][nrx] == '#') right_do = false;\n                if (ML[nly][nlx] == '%' && MR[nry][nrx] == '%') {\n                    flag = true;\n                    while (!st.empty()) st.pop();\n                    break;\n                } else if (ML[nly][nlx] == '%' || MR[nry][nrx] == '%') {\n                    continue;\n                }\n                if (!left_do && !right_do) continue;\n                if (!left_do) nlx = p.lx, nly = p.ly;\n                if (!right_do) nrx = p.rx, nry = p.ry;\n                if(!u[nlx][nly][nrx][nry]) {\n                    u[nlx][nly][nrx][nry] = true;\n                    st.push(POINT{nlx, nly, nrx, nry});\n                }\n            }\n\n        }\n        if (flag)\n            cout << \"Yes\" << endl;\n        else\n            cout << \"No\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> pii;\nint W, H;\nint dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\n\nvoid rec(pii &p1, pii &p2, map<pair<pii,pii>,bool> &memo, vector<string> &R1, vector<string> &R2, pii &g1, pii &g2){\n  for(int i = 0; i < 4; ++i){\n    //int x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;\n    pii p1_ = p1, p2_ = p2;\n    if(p1_.first + dx[i] < H && p1_.first + dx[i] >= 0 &&\n       p1_.second + dy[i] < W && p1_.second + dy[i] >= 0 &&\n       R1[p1_.first + dx[i]][p1_.second + dy[i]] != '#'){\n      p1_.first += dx[i];\n      p1_.second += dy[i];\n    }\n    if(p2_.first + dx[i] < H && p2_.first + dx[i] >= 0 &&\n       p2_.second - dy[i] < W && p2_.second - dy[i] >= 0 &&\n       R2[p2_.first + dx[i]][p2_.second - dy[i]] != '#'){\n      p2_.first += dx[i];\n      p2_.second -= dy[i];\n    }\n    if(p1_ == g1 || p2_ == g2){\n      memo[make_pair(p1_,p2_)] = true;\n    }else if((!memo[make_pair(g1,g2)]) && (!memo[make_pair(p1_,p2_)])){\n      memo[make_pair(p1_,p2_)] = true;\n      rec(p1_,p2_,memo,R1,R2,g1,g2);\n    }\n  }\n}\n\nint main(){\n  while(cin >> W >> H, W){\n    pii s1, s2, g1, g2;\n    vector<string> R1(H), R2(H);\n    for(int i = 0; i < H; ++i){\n      cin >> R1[i] >> R2[i];\n      for(int j = 0; j < W; ++j){\n        if(R1[i][j] == 'L'){\n          s1.first = i;\n          s1.second = j;\n        }\n        if(R2[i][j] == 'R'){\n          s2.first = i;\n          s2.second = j;\n        }\n        if(R1[i][j] == '%'){\n          g1.first = i;\n          g1.second = j;\n        }\n        if(R2[i][j] == '%'){\n          g2.first = i;\n          g2.second = j;\n        }\n      }\n    }\n    map<pair<pii,pii>,bool> memo;\n    rec(s1,s2,memo,R1,R2,g1,g2);\n    if(memo[make_pair(g1,g2)]) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    memo.erase(memo.begin(),memo.end());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#pragma warning(disable:4996)\nusing namespace std;\n\nbool memo[52][52][52][52];\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\n\nlong long int powint(long long int a, long long int b) {\n  assert(b >= 0);\n  if (b == 0)return 1;\n  if (b == 1)return a;\n  long long int ans = 1;\n  long long int aa = powint(a, b / 2);\n  ans *= aa*aa;\n  if (b % 2)ans *= a;\n  return ans;\n}\n\nstruct aa {\n  int ly;\n  int lx;\n  int ry;\n  int rx;\n};\n\nint main() {\n  while (1) {\n    memset(memo, false, sizeof(memo));\n    int W, H; cin >> W >> H;\n    if (!W)break;\n    vector<vector<int>>lmap(H + 2, vector<int>(W + 2, 1));\n    vector<vector<int>>rmap(H + 2, vector<int>(W + 2, 1));\n\n    int lsx, lsy, rsx, rsy;\n    for (int i = 0; i < H; ++i) {\n      string st; cin >> st;\n      for (int j = 0; j < W; ++j) {\n        if (st[j] == '.') {\n          lmap[i+1][j + 1] = 0;\n        }\n        else if (st[j] == 'L') {\n          lsx = j + 1; lsy = i + 1;\n          lmap[i + 1][j + 1] = 0;\n        }\n        else if (st[j] == '%') {\n\n          lmap[i + 1][j + 1] = 2;\n        }\n      }\n       cin >> st;\n      for (int j = 0; j < W; ++j) {\n        if (st[j] == '.') {\n          rmap[i + 1][j + 1] = 0;\n        }\n        else if (st[j] == 'R') {\n          rsx = j + 1; rsy = i + 1;\n          rmap[i + 1][j + 1] = 0;\n        }\n        else if (st[j] == '%') {\n\n          rmap[i + 1][j + 1] = 2;\n        }\n      }\n    }\n\n    memo[lsy][lsx][rsy][rsx] = true;\n    vector<aa>que;\n    que.push_back(aa{ lsy,lsx,rsy,rsx });\n    bool ok = false;\n    while (que.size()) {\n      aa atop(que.back());\n      que.pop_back();\n      \n      for (int i = 0; i < 4; ++i) {\n        const int lway = i;\n         int rway = i;\n        if (i == 0)rway = 2;\n        if (i == 2)rway = 0;\n        int nlx,nly,nrx,nry;\n        if (lmap[atop.ly + dy[lway]][atop.lx + dx[lway]]!=1) {\n          nlx = atop.lx + dx[lway];\n          nly = atop.ly + dy[lway];\n        }\n        else {\n          nlx = atop.lx;\n          nly = atop.ly;\n        }\n        if (rmap[atop.ry + dy[rway]][atop.rx + dx[rway]]!=1) {\n          nrx = atop.rx + dx[rway];\n          nry = atop.ry + dy[rway];\n        }else {\n          nrx = atop.rx;\n          nry = atop.ry;\n        }\n        if (!memo[nly][nlx][nry][nrx]) {\n          memo[nly][nlx][nry][nrx] = true;\n          if (lmap[nly][nlx] == 2 && rmap[nry][nrx] == 2) {\n            ok = true;\n            break;\n          }\n          else if (lmap[nly][nlx]==2||rmap[nry][nrx]==2) {\n\n          }\n          else {\n\n            que.push_back(aa{ nly,nlx,nry,nrx });\n          }\n        }\n      }\n      if (ok)break;\n    }\n    if (ok) {\n      cout << \"Yes\" << endl;\n    }\n    else {\n      cout << \"No\" << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stack>\n#include <cstring>\n#include <string>\n#include <queue>\n#include <cmath>\n\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define all(v) (v).begin(), (v).end()\n#define rev(v) (v).rbegin(), (v).rend()\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int, int> P;\ntypedef long long ll;\n\n\nstruct state{\n\tint lx, ly, rx, ry;\n\tint dist;\n\tstate(int lx, int ly, int rx, int ry, int d):lx(lx), ly(ly), rx(rx), ry(ry), dist(d){}\n};\n\nint dx[] = {0, 0, -1, 1};\nint dy[] = {1, -1, 0, 0};\n\nint dist[50][50][50][50]; // Lx, Ly, Rx, Ry\n\nint main(){\n\t//freopen(\"test.txt\", \"r\", stdin);\n\tint w, h;\n\twhile(cin >> w >> h, w|h){\n\t\tvector<string> L(h), R(h);\n\t\trep(i, h){\n\t\t\tcin >> L[i] >> R[i];\n\t\t\treverse(all(R[i]));\n\t\t}\n\t\tP ls, rs, lg, rg;\n\t\trep(i, h){\n\t\t\trep(j, w){\n\t\t\t\tif(L[i][j] == 'L') ls = MP(j, i);\n\t\t\t\tif(L[i][j] == '%') lg = MP(j, i);\n\t\t\t\tif(R[i][j] == 'R') rs = MP(j, i);\n\t\t\t\tif(R[i][j] == '%') rg = MP(j, i);\n\t\t\t}\n\t\t}\n\n\t\tmemset(dist, -1, sizeof(dist));\n\n\t\tqueue<state> q;\n\t\tq.push(state(ls.X, ls.Y, rs.X, rs.Y, 0));\n\t\tdist[ls.X][ls.Y][rs.X][rs.Y] = 0;\n\n\t\twhile(!q.empty()){\n\t\t\tstate s = q.front();\n\t\t\tq.pop();\n\n\t\t\tif(s.lx == lg.X && s.ly == lg.Y && s.rx == rg.X && s.ry == rg.Y){\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trep(i, 4){\n\t\t\t\tint lx = s.lx+dx[i];\n\t\t\t\tint ly = s.ly+dy[i];\n\t\t\t\tint rx = s.rx+dx[i];\n\t\t\t\tint ry = s.ry+dy[i];\n\t\t\t\tif(lx < 0 || lx >= w) lx = s.lx;\n\t\t\t\tif(ly < 0 || ly >= h) ly = s.ly;\n\t\t\t\tif(rx < 0 || rx >= w) rx = s.rx;\n\t\t\t\tif(ry < 0 || ry >= h) ry = s.ry;\n\t\t\t\tif(L[ly][lx] == '#') lx = s.lx, ly = s.ly;\n\t\t\t\tif(R[ry][rx] == '#') rx = s.rx, ry = s.ry;\n\t\t\t\tif(L[ly][lx] == '%' || R[ry][rx] == '%'){\n\t\t\t\t\tif(L[ly][lx] != R[ry][rx]) continue;\n\t\t\t\t}\n\t\t\t\tif(dist[lx][ly][rx][ry] != -1) continue;\n\t\t\t\tdist[lx][ly][rx][ry] = s.dist + 1;\n\t\t\t\tq.push(state(lx, ly, rx, ry, s.dist+1));\n\t\t\t}\n\t\t}\n\n\t\tcout << (dist[lg.X][lg.Y][rg.X][rg.Y]!=-1?\"Yes\":\"No\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct state{\n  int lx, ly, rx, ry, step;\n};\nint w, h;\nchar rmap[51][51], lmap[51][51];\nqueue<state> quu;\nint lx, ly, rx, ry;\nint d[51][51][51][51];\nint xmj[4] = {0, 0, 1, -1}, ymj[4] = {1, -1, 0, 0};\nint a[2], b[2];\n\nvoid lmove(int *x, int *y, int i){\n\n  int lnx = *x - xmj[i], lny = *y + ymj[i];\n\n  if(lnx < 0 || lnx >= w || lny < 0 || lny >= h) return;\n\n  if(lmap[lny][lnx] == '#') return;\n\n  *x = lnx;\n  *y = lny;\n\n\n}\n\nvoid rmove(int *x, int *y, int i){\n\n  int rnx = *x + xmj[i], rny = *y + ymj[i];\n\n  if(rnx < 0 || rnx >= w || rny < 0 || rny >= h) return;\n\n  if(rmap[rny][rnx] == '#') return;\n\n  *x = rnx;\n  *y = rny;\n\n\n}\n\nvoid wide(int lx, int ly, int rx, int ry){\n\n  memset(d,0,sizeof(d));\n  quu.push((state){lx,ly,rx,ry,1});\n  d[ly][lx][ry][ry] = 1;\n  while(!quu.empty()){\n\n    state st;\n    st = quu.front();\n    quu.pop();\n    // cout << st.lx << \" \" << st.ly << \" \" << st.rx << \" \" << st.ry << endl;\n    for(int i = 0; i < 4; i++){\n      int lnx = st.lx, lny = st.ly;\n      int rnx = st.rx, rny = st.ry;\n\n      lmove(&lnx,&lny,i);\n      rmove(&rnx,&rny,i);\n\n      if(rmap[rny][rnx] == '%' && lmap[lny][lnx] != '%') continue;\n      if(rmap[rny][rnx] != '%' && lmap[lny][lnx] == '%') continue;\n\n      if( d[lny][lnx][rny][rnx] == 0){\n\tquu.push((state){lnx,lny,rnx,rny,st.step+1});\n\td[lny][lnx][rny][rnx] = 1;\n      }\n      \n    }\n   \n  }\n  \n  if(d[a[0]][a[1]][b[0]][b[1]]) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n\n\n\n}\n\nint main(){\n\n\n  while(cin >> w >> h && (w || h)){\n\n    for(int i = 0; i < h*2; i++){\n      if(i % 2 == 0){\n\tfor(int j = 0; j < w; j++){\n\t  cin >> lmap[i/2][j];\t  \n\t  if(lmap[i/2][j] == 'L'){\n\t    lx = j;\n\t    ly = i/2;\n\t  }\n\t  if(lmap[i/2][j] == '%'){\n\t    a[0] = i/2;\n\t    a[1] = j;\n\t    //   cout << a[1] << \" \" << a[0] << endl; \n\t  }\n\t}\n      }else {\n\tfor(int j = 0; j < w; j++){\n\t  cin >> rmap[(i-1)/2][j];\n\t  if(rmap[(i-1)/2][j] == 'R'){\n\t    rx = j;\n\t    ry = (i-1)/2;\n\t  }\n\t  if(rmap[(i-1)/2][j] == '%'){\n\t    b[0] = (i-1)/2;\n\t    b[1] = j;\n\t    //      cout << b[1] << \" \" << b[0] << endl; \n\t  }\n\t  //  cout << rx << \" \" << ry << endl;\n\t  \n\t  // cout << i;\n\t}\n      }\n    }\n    wide(lx,ly,rx,ry);\n     \n  }\n    \n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<queue>\n#define MAX 60\nusing namespace std;\nstruct Point{int x,y;};\nstruct P{\n  Point l,r;\n  int cost;\n};\nint main(){\n  int w,h;\n  while(cin>>w>>h,w||h){\n    int i,j,k;\n    int inf = 1<<20;\n    int d[MAX+1][MAX+1][MAX+1][MAX+1];\n    fill(d[0][0][0],d[MAX][MAX][MAX],inf);\n    string sr[60],sl[60];\n    for(i=0;i<h;i++){\n      cin >> sl[i] >> sr[i];\n    }\n    Point pr,pl,br,bl;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(sl[i][j]=='L'){\n\t  pl.x=j;pl.y=i;\n\t}\n\tif(sr[i][j]=='R'){\n\t  pr.x=j;pr.y=i;\n\t}\n      }\n    }\n    //cout << pl.x << \":\" << pl.y << endl;\n    //cout << pr.x << \":\" << pr.y << endl;\n    d[pl.x][pl.y][pr.x][pr.y]=0;\n    P p,b;\n    p.r=pr;\n    p.l=pl;\n    p.cost=d[pl.x][pl.y][pr.x][pr.y];\n    queue<P> q;\n    q.push(p);\n    bool f = false;\n    while(!q.empty()){\n      p=q.front();q.pop();\n      pl=p.l;pr=p.r;\n      if(p.cost>d[pl.x][pl.y][pr.x][pr.y]) continue;\n      d[pl.x][pl.y][pr.x][pr.y]=p.cost;\n      //cout << pl.x<<\":\"<<pl.y<<\":\"<<pr.x<<\":\"<<pr.y<<\"/\"<<p.cost<<endl;\n      if(sl[pl.y][pl.x]=='%'&&sr[pr.y][pr.x]=='%'){\n\tf=true;\n\tbreak;\n      }else if(sl[pl.y][pl.x]=='%') continue;\n      else if(sr[pr.y][pr.x]=='%') continue;\n      \n      p.cost++;\n      int lx[]={1,-1,0,0};int ly[]={0,0,1,-1};\n      int rx[]={-1,1,0,0};int ry[]={0,0,1,-1};\n      for(i=0;i<4;i++){\n\tbl=pl;br=pr;\n\tbl.x+=lx[i];bl.y+=ly[i];\n\tbr.x+=rx[i];br.y+=ry[i];\n\n\t//cout << bl.x<<\":\"<<bl.y<<\":\"<<br.x<<\":\"<<br.y<<\"/\"<<p.cost<<endl;\n\t\n\tif(bl.x<0) bl.x=0;\n\telse if(bl.x>=w) bl.x=w-1;\n\tif(bl.y<0) bl.y=0;\n\telse if(bl.y>=h) bl.y=h-1;\n\n\tif(br.x<0) br.x=0;\n\telse if(br.x>=w) br.x=w-1;\n\tif(br.y<0) br.y=0;\n\telse if(br.y>=h) br.y=h-1;\n\n\tif(sl[bl.y][bl.x]=='#'){\n\t  bl.x-=lx[i];bl.y-=ly[i];\n\t}\n\tif(sr[br.y][br.x]=='#'){\n\t  br.x-=rx[i];br.y-=ry[i];\n\t}\n\tp.r=br;p.l=bl;\n\tq.push(p);\n      }\n    }\n    if(f) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct Point {\n  int x1, y1, x2, y2;\n  Point() {;}\n  Point(int x1, int y1, int x2, int y2) : x1(x1), y1(y1), x2(x2), y2(y2) {;}\n};\n\nint w, h;\nbool in(int x, int y) { return x >= 0 && x < w && y >= 0 && y < h; }\n  \nchar field[2][100][100];\nbool visit[60][60][60][60];\nint dx[4] = { 1, 0, -1, 0 };\nint dy[4] = { 0, 1, 0, -1 };\n\nint main() {\n  while (scanf(\"%d %d\", &w, &h), w|h) {\n    MEMSET(visit, false);\n    int sx1, sy1, sx2, sy2;\n    REP(y, h) {\n      scanf(\"%s %s\", field[0][y], field[1][y]);\n      REP(x, w) {\n        if (field[0][y][x] == 'L') { sx1 = x; sy1 = y; }\n        if (field[1][y][x] == 'R') { sx2 = x; sy2 = y; }\n      }\n    }\n    queue<Point> que;\n    que.push(Point(sx1, sy1, sx2, sy2));\n    while (!que.empty()) {\n      Point p = que.front();\n      que.pop();\n      REP(dir, 4) {\n        int nx1 = p.x1 + dx[dir];\n        int ny1 = p.y1 + dy[dir];\n        int nx2 = p.x2 - dx[dir];\n        int ny2 = p.y2 + dy[dir];\n        if (field[0][ny1][nx1] == '#' || !in(nx1, ny1)) { nx1 -= dx[dir]; ny1 -= dy[dir]; }\n        if (field[1][ny2][nx2] == '#' || !in(nx2, ny2)) { nx2 += dx[dir]; ny2 -= dy[dir]; }\n        if (field[0][ny1][nx1] == '%' && field[1][ny2][nx2] == '%') { \n          puts(\"Yes\");\n          goto next;\n        }\n        if (field[0][ny1][nx1] == '%' || field[1][ny2][nx2] == '%') { \n          continue;\n        }\n        if (visit[ny1][nx1][ny2][nx2]) { continue; }\n        visit[ny1][nx1][ny2][nx2] = true;\n        que.push(Point(nx1, ny1, nx2, ny2));\n      }\n    }\n    puts(\"No\");\nnext:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\n\ntemplate<class T>\ninline bool chmax(T &a, const T &b) {\n    if(a<b) {\n        a=b;\n        return true;\n    }\n\n    return false;\n}\ntemplate<class T>\ninline bool chmin(T &a, const T &b) {\n    if(a>b) {\n        a=b;\n        return true;\n    }\n\n    return false;\n}\n\nint W,H;\nstring roomL[51],roomR[51];\n\nbool range_check(int y,int x) {\n    if(y<0||x<0) return false;\n    if(H<=y||W<=x) return false;\n\n    return true;\n}\n\nbool ok(P len,P rin) {\n    bool visited[51][51][51][51]={};\n    visited[len.fr][len.sc][rin.fr][rin.sc]=true;\n    queue<PP> que;\n    que.push(PP(len,rin));\n\n    while(que.size()) {\n        PP pp=que.front(); que.pop();\n        P next_len=pp.fr;\n        P next_rin=pp.sc;\n\n        //printf(\"[debug] %d %d %d %d\\n\",next_len.fr,next_len.sc,next_rin.fr,next_rin.sc);\n\n        if(roomL[next_len.fr][next_len.sc]=='%' && roomR[next_rin.fr][next_rin.sc]=='%') {\n            return true;\n        }\n        if(roomL[next_len.fr][next_len.sc]=='%' || roomR[next_rin.fr][next_rin.sc]=='%') {\n            visited[next_len.fr][next_len.sc][next_rin.fr][next_rin.sc]=false;\n            continue;\n        }\n        rep(i,4) {\n            next_len=pp.fr;\n            next_rin=pp.sc;\n\n            if(range_check(next_len.fr+dy[i],next_len.sc+dx[i]) && roomL[next_len.fr+dy[i]][next_len.sc+dx[i]]!='#') {\n                next_len.fr+=dy[i];\n                next_len.sc+=dx[i];\n            }\n            if(range_check(next_rin.fr+dy[i],next_rin.sc-dx[i]) && roomR[next_rin.fr+dy[i]][next_rin.sc-dx[i]]!='#') {\n                next_rin.fr+=dy[i];\n                next_rin.sc-=dx[i];\n            }\n\n            chmax(next_len.fr,0);\n            chmin(next_len.fr,H-1);\n            chmax(next_len.sc,0);\n            chmin(next_len.sc,W-1);\n            chmax(next_rin.fr,0);\n            chmin(next_rin.fr,H-1);\n            chmax(next_rin.sc,0);\n            chmin(next_rin.sc,W-1);\n\n\n            if(!visited[next_len.fr][next_len.sc][next_rin.fr][next_len.sc]) {\n                visited[next_len.fr][next_len.sc][next_rin.fr][next_len.sc]=true;\n                que.push(PP(next_len,next_rin));\n            }\n        }\n    }\n\n    return false;\n}\n\nvoid solve() {\n    rep(y,H) cin>>roomL[y]>>roomR[y];\n    P len,rin;\n    rep(y,H) rep(x,W) {\n        if(roomL[y][x]=='L') len=P(y,x);\n        if(roomR[y][x]=='R') rin=P(y,x);\n    }\n    if(ok(len,rin)) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n}\n\nint main() {\n    while(cin>>W>>H) {\n        if(!W) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy1[] = {0, 1, 0, -1};\nconst int dy2[] = {0, -1, 0, 1};\nint d[55][55][55][55];\n\nint main() {\n    int n, m;\n    while (cin >> n >> m, n || m) {\n        vector<string> G1(m), G2(m);\n        queue<P> que1, que2;\n        for (int i = 0; i < 55; i++)\n            for (int j = 0; j < 55; j++)\n                for (int l = 0; l < 55; l++)\n                    for (int k = 0; k < 55; k++)\n                        d[i][j][k][l] = true;\n        for (int i = 0; i < m; i++) {\n            cin >> G1[i] >> G2[i];\n            for (int j = 0; j < n; j++) {\n                if (G1[i][j] == 'L') que1.push(P(i, j));\n                if (G2[i][j] == 'R') que2.push(P(i, j));\n            }\n        }\n\n        d[que1.front().first][que1.front().second][que2.front().first][que2.front().second] = false;\n\n        bool res = false;\n        while (1) {\n            if (!que1.size() || !que2.size()) break;\n            P p1 = que1.front(); que1.pop();\n            P p2 = que2.front(); que2.pop();\n            if (G1[p1.first][p1.second] == '%' && G2[p2.first][p2.second] == '%') {\n                res = true;\n                break;\n            }\n\n            int x1 = p1.first;\n            int x2 = p2.first;\n            int y2 = p2.second;\n            int y1 = p1.second;\n            for (int i = 0; i < 4; i++) {\n                int nx1 = x1 + dx[i];\n                int ny1 = y1 + dy1[i];\n                int nx2 = x2 + dx[i];\n                int ny2 = y2 + dy2[i];\n\n                if ( nx1 < 0 || nx1 >= m || ny1 < 0 || ny1 >= n || G1[nx1][ny1] == '#') nx1 = x1, ny1 = y1;\n                if ( nx2 < 0 || nx2 >= m || ny2 < 0 || ny2 >= n || G2[nx2][ny2] == '#') nx2 = x2, ny2 = y2;\n\n                if (d[nx1][ny1][nx2][ny2]) {\n                    d[nx1][ny1][nx2][ny2] = false;\n                    que1.push(P(nx1, ny1));\n                    que2.push(P(nx2, ny2));\n                }\n            }\n        }\n\n        cout << (res ? \"Yes\" : \"No\") << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <sstream>\n\nusing namespace std;\n\nstruct pos{\n\tint x1;\n\tint y1;\n\tint x2;\n\tint y2;\n};\n\nint W, H;\nbool memo[60][60][60][60];\n\nstring field1[60], field2[60];\n\nbool check1(int x, int y){\n\tif(x < 0 || y < 0 || x >= W || y >= H){\n\t\treturn true;\n\t}else if(field1[y][x] == '#'){\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool check2(int x, int y){\n\tif(x < 0 || y < 0 || x >= W || y >= H){\n\t\treturn true;\n\t}else if(field2[y][x] == '#'){\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main(){\n\t\n\twhile(true){\n\t\t\n\t\tcin >> W >> H;\n\t\tif(W == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tcin >> field1[i] >> field2[i];\n\t\t}\n\t\t\n\t\t\n\t\tfor(int i = 0; i <= 50; i++){\n\t\t\tfor(int j = 0; j <= 50; j++){\n\t\t\t\tfor(int k = 0; k <= 50; k++){\n\t\t\t\t\tfor(int l = 0; l <= 50; l++){\n\t\t\t\t\t\tmemo[i][j][k][l] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ini_x1, ini_x2, ini_y1, ini_y2;\n\t\tint goal_x1, goal_x2, goal_y1, goal_y2;\n\t\t\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\tif(field1[i][j] == 'L'){\n\t\t\t\t\tini_x1 = j;\n\t\t\t\t\tini_y1 = i;\n\t\t\t\t}\n\t\t\t\tif(field2[i][j] == 'R'){\n\t\t\t\t\tini_x2 = j;\n\t\t\t\t\tini_y2 = i;\n\t\t\t\t}\n\t\t\t\tif(field1[i][j] == '%'){\n\t\t\t\t\tgoal_x1 = j;\n\t\t\t\t\tgoal_y1 = i;\n\t\t\t\t}\n\t\t\t\tif(field2[i][j] == '%'){\n\t\t\t\t\tgoal_x2 = j;\n\t\t\t\t\tgoal_y2 = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<pos> que;\n\t\tpos pos_first;\n\t\tpos_first.x1 = ini_x1;\n\t\tpos_first.y1 = ini_y1;\n\t\tpos_first.x2 = ini_x2;\n\t\tpos_first.y2 = ini_y2;\n\t\tque.push(pos_first);\n\t\t\n\t\tint dx_[4] = {1, 0, -1, 0};\n\t\tint dy_[4] = {0, 1, 0, -1};\n\t\t\n\t\twhile(!que.empty()){\n\t\t\t\n\t\t\tpos p = que.front();\n\t\t\tque.pop();\n\t\t\t\n\t\t\t//cout << p.x1 << \" \" << p.y1 << \" \" << p.x2 << \" \" << p.y2 << endl;\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint dx1 = dx_[i];\n\t\t\t\tint dy1 = dy_[i];\n\t\t\t\tint dx2 = -dx1;\n\t\t\t\tint dy2 = dy1;\n\t\t\t\tif(check1(p.x1 + dx1, p.y1 + dy1)){\n\t\t\t\t\tdx1 = 0;\n\t\t\t\t\tdy1 = 0;\n\t\t\t\t}\n\t\t\t\tif(check2(p.x2 + dx2, p.y2 + dy2)){\n\t\t\t\t\tdx2 = 0;\n\t\t\t\t\tdy2 = 0;\n\t\t\t\t}\n\t\t\t\tpos pp;\n\t\t\t\tpp.x1 = p.x1 + dx1;\n\t\t\t\tpp.y1 = p.y1 + dy1;\n\t\t\t\tpp.x2 = p.x2 + dx2;\n\t\t\t\tpp.y2 = p.y2 + dy2;\n\t\t\t\tif(memo[pp.x1][pp.y1][pp.x2][pp.y2]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmemo[pp.x1][pp.y1][pp.x2][pp.y2] = true;\n\t\t\t\tque.push(pp);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(memo[goal_x1][goal_y1][goal_x2][goal_y2]){\n\t\t\tcout << \"Yes\" << endl;\n\t\t}else{\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define pii pair<int, int>\nusing namespace std;\n\nint di[] = {-1, 0, 1, 0};\nint dj[] = {0, -1, 0, 1};\n\nstruct Info {\n    int li, lj, ri, rj;\n    Info(int i, int j, int k, int l) : li(i), lj(j), ri(k), rj(l) {}\n};\n\nint used[55][55][55][55];\n\nint main() {\n    int w, h;\n    while (cin >> w >> h, w | h) {\n        string L[h], R[h];\n        for (int i = 0; i < h; i++) cin >> L[i] >> R[i];\n        int yl, xl, yr, xr;\n        int yt, xt, yk, xk;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (L[i][j] == '%') {\n                    L[i][j] == '.';\n                    yl = i, xl = j;\n                } else if (L[i][j] == 'L') {\n                    yt = i, xt = j;\n                }\n                if (R[i][j] == '%') {\n                    yr = i, xr = j;\n                    R[i][j] == '.';\n                } else if (R[i][j] == 'R') {\n                    yk = i, xk = j;\n                }\n            }\n        }\n        queue<Info> q;\n        q.push(Info(yt, xt, yk, xk));\n        memset(used, 0, sizeof(used));\n        bool flag = false;\n        used[yt][xt][yk][yt] = 1;\n        while (!q.empty()) {\n            int li = q.front().li;\n            int lj = q.front().lj;\n            int ri = q.front().ri;\n            int rj = q.front().rj;\n            q.pop();\n            if (li == yl && lj == xl || ri == yr && rj == xr) {\n                if (li == yl && lj == xl && ri == yr && rj == xr){\n                    flag = true;\n                    break;\n                }\n                continue;\n            }\n            for (int i = 0; i < 4; i++) {\n                int nli = li + di[i];\n                int nlj = lj + dj[i];\n                int nri = ri + di[i];\n                int nrj = rj - dj[i];\n                if (nli < 0 || nlj < 0 || nli >= h || nlj >= w || L[nli][nlj] == '#') {\n                    nli = li, nlj = lj;\n                }\n                if (nri < 0 || nrj < 0 || nri >= h || nrj >= w || R[nri][nrj] == '#') {\n                    nri = ri, nrj = rj;\n                }\n                if (!used[nli][nlj][nri][nrj]) {\n                    used[nli][nlj][nri][nrj] = 1;\n                    q.push(Info(nli, nlj, nri, nrj));\n                }\n            }\n        }\n        if (flag) {\n            cout << \"Yes\" << endl;\n        } else {\n            cout << \"No\" << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<ctime>\n#include<climits>\n#include<queue>\n#include<fstream>\n#include<deque>\n#include<iomanip>\n#include<list>\n#include<stack>\n#include<sstream>\n#include<string>\n#include<cctype>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<cstring>\n#include<iomanip>\n#include<map>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS 1e-10\n#define F first\n#define S second\n#define all(n) n.begin(),n.end()\n#define pb push_back\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define INF (1<<27)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nconst P dx[4] = {P(0,0),P(0,0),P(1,-1),P(-1,1)};\nconst P dy[4] = {P(1,1),P(-1,-1),P(0,0),P(0,0)};\nconst int idx[4] = {0,1,0,-1};\nconst int idy[4] = {1,0,-1,0};\n\nint H,W;\nchar L_cmap[65][65],R_cmap[65][65];\n//stinrg L_cmap[65],R_cmap[65];\nbool L_used[65][65],R_used[65][65];\nP Ls,Rs,Lg,Rg;\nbool fin;\n//vector<string> L_cmap,R_cmap;\n\nvoid dfs(PP pp){\n\n  //cout << \"here\" << endl;\n  if(fin)return;\n      if(pp.F == Lg && pp.S == Rg){\n\tcout << \"Yes\" << endl;\n\tfin = true;\n\treturn;\n      }\n      //cout << \"pp.F = \" << pp.F.F << \",\" << pp.F.S << \" pp.S = \" << pp.S.F << \",\" << pp.S.S << endl;\n      rep(i,4){\n\tint L_nx = pp.F.F + dx[i].F,L_ny = pp.F.S + dy[i].F;\n\tint R_nx = pp.S.F + dx[i].S,R_ny = pp.S.S + dy[i].S;\n\t//cout << \"First next L = \" << L_nx << \",\" << L_ny << \" Pre next R = \" << R_nx << \",\" << R_ny << endl;\n\n\n \t//if(!(0<=L_nx && L_nx <W && 0<= R_nx && R_nx <W && 0<= L_ny && L_ny <H && 0<= R_ny && R_ny < H))continue;\n\tif(!(0<= L_nx))L_nx = 0;\n\tif(!(L_nx < W))L_nx = W-1;\n\tif(!(0<= R_nx))R_nx = 0;\n\tif(!(R_nx < W))R_nx = W-1;\n\n\tif(!(0<= L_ny))L_ny = 0;\n\tif(!(L_ny < H))L_ny = H-1;\n\tif(!(0<= R_ny))R_ny = 0;\n\tif(!(R_ny < H))R_ny = H-1;\n\n\tif(L_cmap[L_ny][L_nx] != '#' && L_used[L_ny][L_nx])continue;\n\tif(R_cmap[R_ny][R_nx] != '#' && R_used[R_ny][R_nx])continue;\n\tif(L_cmap[L_ny][L_nx] == '#' && R_cmap[R_ny][R_nx] == '#')continue;\n\n\t//cout << \"next L = \" << L_nx << \",\" << L_ny << \" Pre next R = \" << R_nx << \",\" << R_ny << endl;\n\tif(L_cmap[L_ny][L_nx] == '#')L_nx = pp.F.F,L_ny = pp.F.S;\n\tif(R_cmap[R_ny][R_nx] == '#')R_nx = pp.S.F,R_ny = pp.S.S;\n\t\n\tR_used[R_ny][R_nx] = L_used[L_ny][L_nx] = true;\n\t//que.push(insert(L_nx,L_ny,R_nx,R_ny));\n\tif(fin)return;\n\tdfs(insert(L_nx,L_ny,R_nx,R_ny));\n\tif(fin)return;\n\tR_used[R_ny][R_nx] = L_used[L_ny][L_nx] = false;\n      }\n      return;\n}\n   \n\n\nint main(){\n  //clock_t start,end;\n  //start = clock();\n  while(true){\n    cin >> W >> H;\n    if(W+H == 0)break;\n    //L_cmap.clear(),R_cmap.clear();\n    fin = false;\n    int index=0;\n    rep(i,H){\n      string s;\n      cin >> s;\n      //if(i == 0 || s != L_cmap[index])\n      rep(j,W){\n\tL_cmap[i][j] = s[j],L_used[i][j] = false;\n\tif(s[j] == 'L')\n\t  Ls = P(j,i);\n\tif(s[j] == '%')\n\t  Lg = P(j,i);\n      }\n      cin >> s;\n      rep(j,W){\n\tR_cmap[i][j] = s[j],R_used[i][j] = false;\n\tif(s[j] == 'R')\n\t  Rs = P(j,i);\n\tif(s[j] == '%')\n\t  Rg = P(j,i);\n      }\n    }\n    \n    bool L_ok,R_ok;\n    L_ok = R_ok = false;\n    queue<P> que;\n    que.push(Ls);    \n    L_used[Ls.S][Ls.F] = true;\n    while(!que.empty()){\n      P pi = que.front(); que.pop();\n      if(pi == Lg){\n\tL_ok = true;\n\tbreak;\n      }\n      rep(i,4){\n\tint nx = pi.F+idx[i],ny = pi.S+idy[i];\n\tif(!(0<=nx && nx < W && 0<= ny && ny < H) || L_cmap[ny][nx] == '#' || L_used[ny][nx])continue;\n\tL_used[ny][nx] = true;\n\tque.push(P(nx,ny));\n      }\n    }\n    if(!L_ok){\n      cout << \"No\" << endl;\n      continue;\n    }\n    queue<P> R_que;\n    R_que.push(Rs);\n    R_used[Rs.S][Rs.F] = true;\n    while(!R_que.empty()){\n      P pi = R_que.front(); R_que.pop();\n      //cout << \"pi = \" << pi.F << \",\" << pi.S << endl;\n      if(pi == Rg){\n\tR_ok = true;\n\tbreak;\n      }\n      rep(i,4){\n\tint nx = pi.F+idx[i],ny = pi.S+idy[i];\n\tif(!(0<=nx && nx < W && 0<= ny && ny < H) || R_cmap[ny][nx] == '#' || R_used[ny][nx])continue;\n\tR_used[ny][nx] = true;\n\tR_que.push(P(nx,ny));\n      }\n    }\n\n\n    if(!L_ok || !R_ok){\n      //cout << L_ok << \" \" << R_ok << endl;\n      cout << \"No\" << endl;\n      continue;\n    }\n    \n    rep(i,H)rep(j,W)L_used[i][j] = R_used[i][j] = false;\n    L_used[Ls.S][Ls.F] = true,R_used[Rs.S][Rs.F] = true;\n    dfs(insert(Ls.F,Ls.S,Rs.F,Rs.S));\n\n    if(!fin)cout << \"No\" << endl;\n\n  }\n  //end = clock();\n  //cout << setiosflags(ios::fixed) << setprecision(10) << (double)(end-start)/CLOCKS_PER_SEC << endl;\nreturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n //cout<< \"Ls = \" << Ls.F << \" \" << Ls.S << \", Lg = \" << Lg.F << \" \" << Lg.S << \", Rs = \" << Rs.F << \" \" << Rs.S << \", Rg = \" << Rg.F << \" \" << Rg.S << endl; \n    //rep(i,4){\n    //rep(j,51)rep(k,51)R_used[j][k] = L_used[j][k] = false;\n      //if(!(0<= Ls.F+dx[i].F && Ls.F+dx[i].F < W && 0<= Ls.S+dy[i].F && Ls.S+dy[i].F < H  && 0<= Rs.F+dx[i].S && Rs.F+dx[i].S < W  && 0<= Rs.S+dy[i].S && Rs.S+dy[i].S < H))continue;\n      //cout << Ls.F+dx[i].F << \" \" << Ls.S+dy[i].F<< \" \"<< Rs.F+dx[i].S<< \" \" << Rs.S+dy[i].S << endl;\n      //dfs(insert(Ls.F+dx[i].F,Ls.S+dy[i].F,Rs.F+dx[i].S,Rs.S+dy[i].S));\n      //cout << \"----------\" << endl;\n      //}    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <memory.h>\n#include <queue>\n\nusing namespace std;\n\nint maxw,maxh;\nint lsx,lsy;\nint rsx,rsy;\n\nconst int dxl[] = {1,0,-1,0};\nconst int dxr[] = {-1,0,1,0};\nconst int dyl[] = {0,1,0,-1};\nconst int dyr[] = {0,1,0,-1};\n\ntypedef pair<int,int> PP;\ntypedef pair< PP,PP > P;\n\nbool visited[55][55][55][55] = {};\n\nint main(void)\n{\n\twhile(1)\n\t{\n\t\tchar fieldl[55][55];\n\t\tchar fieldr[55][55];\n\t\tmemset(visited,0,sizeof(visited));\n\t\tmemset(fieldl,0,sizeof(fieldl));\n\t\tmemset(fieldr,0,sizeof(fieldr));\n\t\tcin >> maxw >> maxh;\n\t\tif(maxw==0&&maxh==0)\n\t\t\treturn 0;\n\t\tfor(int y=1;y<=maxh;++y){\n\t\t\tfor(int x=1;x<=maxw;++x){\n\t\t\t\tcin >> fieldl[y][x];\n\t\t\t\tif(fieldl[y][x] == 'L'){\n\t\t\t\t\tlsy = y;lsx = x;\n\t\t\t\t\tfieldl[y][x] = '.';\n\t\t\t\t}\n\t\t\t\tif(fieldl[y][x] == 'R'){\n\t\t\t\t\trsy = y;rsx = x;\n\t\t\t\t\tfieldl[y][x] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int x=1;x<=maxw;++x){\n\t\t\t\tcin >> fieldr[y][x];\n\t\t\t\tif(fieldr[y][x] == 'L'){\n\t\t\t\t\tlsy = y;lsx = x;\n\t\t\t\t\tfieldr[y][x] = '.';\n\t\t\t\t}\n\t\t\t\tif(fieldr[y][x] == 'R'){\n\t\t\t\t\trsy = y;rsx = x;\n\t\t\t\t\tfieldr[y][x] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqueue<P> q;\n\t\tbool isGoal = false;\n\t\tq.push(P(PP(lsy,lsx),PP(rsy,rsx)));\n\t\tvisited[lsy][lsx][rsy][rsx] = true;\n\t\twhile(!q.empty()){\n\t\t\tP p = q.front();q.pop();\n\t\t\tfor(int i=0;i<4;++i){\n\t\t\t\tbool f=false;\n\t\t\t\tPP tol = PP(p.first.first+dyl[i],p.first.second+dxl[i]);//y,x\n\t\t\t\tPP tor = PP(p.second.first+dyr[i],p.second.second+dxr[i]);//y,x\n\t\t\t\tif(visited[tol.first][tol.second][tor.first][tor.second])\n\t\t\t\t\tcontinue;\n\t\t\t\tif(fieldl[tol.first][tol.second] == '%' && fieldr[tor.first][tor.second] == '%'){\n\t\t\t\t\tisGoal = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(fieldl[tol.first][tol.second] == '%' || fieldr[tor.first][tor.second] == '%')\n\t\t\t\t\tcontinue;\n\t\t\t\tPP l = PP(p.first.first,p.first.second);\n\t\t\t\tPP r = PP(p.second.first,p.second.second);\n\t\t\t\tif(fieldl[tol.first][tol.second] == '.'){\n\t\t\t\t\tl = tol;\n\t\t\t\t\tf=true;\n\t\t\t\t}\n\t\t\t\tif(fieldr[tor.first][tor.second] == '.'){\n\t\t\t\t\tr = tor;\n\t\t\t\t\tf=true;\n\t\t\t\t}\n\t\t\t\tif(!f)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(visited[l.first][l.second][r.first][r.second])\n\t\t\t\t\tcontinue;\n\t\t\t\tvisited[l.first][l.second][r.first][r.second] = true;\n\t\t\t\tq.push(P(l,r));\n\t\t\t}\n\t\t\tif(isGoal)\n\t\t\t\tbreak;\n\t\t}\n\t\t(isGoal?cout<<\"Yes\"<<endl:cout<<\"No\"<<endl);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\n\n\nint w,h;\nchar L[53][53], R[53][53];\nstruct state{\n\tint lx,ly,rx,ry;\n};\nint dl[4][2]={{0,1},{1,0},{-1,0},{0,-1}};\nint dr[4][2]={{0,-1},{1,0},{-1,0},{0,1}};\nbool dfs(state s){\n\tif(L[s.ly][s.lx]=='%' && R[s.ry][s.rx]=='%') return true;\n\tif(L[s.ly][s.lx]=='%' || R[s.ry][s.rx]=='%') return false;\n\tif(L[s.ly][s.lx]=='#' || R[s.ry][s.rx]=='#') return false;\n\tfor(int i=0;i<4;i++){\n\t\tstate t = s;\n\t\tL[s.ly][s.lx] = '.';\n\t\tR[s.ry][s.rx] = '.';\n\t\tif(L[t.ly+dl[i][0]][t.lx+dl[i][1]] == '#' && R[t.ry+dr[i][0]][t.rx+dr[i][1]] == '#') continue;\n\t\tif(L[t.ly+dl[i][0]][t.lx+dl[i][1]] != '#'){\n\t\t\tL[s.ly][s.lx] = '#';\n\t\t\tt.ly += dl[i][0];\n\t\t\tt.lx += dl[i][1];\n\t\t}\n\t\tif(R[t.ry+dr[i][0]][t.rx+dr[i][1]] != '#'){\n\t\t\tR[s.ry][s.rx] = '#';\n\t\t\tt.ry += dr[i][0];\n\t\t\tt.rx += dr[i][1];\n\t\t}\n\t\tif(dfs(t)) return true;\n\t}\n\tL[s.ly][s.lx] = '.';\n\tR[s.ry][s.rx] = '.';\n\treturn false;\n}\n\nmain(){\n\tint i,j;\n\twhile(cin >> w >> h, w){\n\t\tfor(i=0;i<53;i++)for(j=0;j<53;j++)L[i][j]=R[i][j]='#';\n\t\tint ans;\n\t\tstate s;\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tcin >> L[i][j];\n\t\t\t\tif(L[i][j] == 'L'){\n\t\t\t\t\ts.lx=j;s.ly=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tcin >> R[i][j];\n\t\t\t\tif(R[i][j] == 'R'){\n\t\t\t\t\ts.rx=j;s.ry=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (dfs(s)?\"Yes\":\"No\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <memory.h>\n#include <queue>\n\nusing namespace std;\n\nint maxw,maxh;\nint lsx,lsy;\nint rsx,rsy;\n\nconst int dxl[] = {1,0,-1,0};\nconst int dxr[] = {-1,0,1,0};\nconst int dyl[] = {0,1,0,-1};\nconst int dyr[] = {0,1,0,-1};\n\ntypedef pair<int,int> PP;\ntypedef pair< PP,PP > P;\n\nbool visited[55][55][55][55] = {};\n\nint main(void)\n{\n\twhile(1)\n\t{\n\t\tchar fieldl[55][55];\n\t\tchar fieldr[55][55];\n\t\tmemset(visited,0,sizeof(visited));\n\t\tmemset(fieldl,0,sizeof(fieldl));\n\t\tmemset(fieldr,0,sizeof(fieldr));\n\t\tcin >> maxw >> maxh;\n\t\tif(maxw==0&&maxh==0)\n\t\t\treturn 0;\n\t\tfor(int y=1;y<=maxh;++y){\n\t\t\tfor(int x=1;x<=maxw;++x){\n\t\t\t\tcin >> fieldl[y][x];\n\t\t\t\tif(fieldl[y][x] == 'L'){\n\t\t\t\t\tlsy = y;lsx = x;\n\t\t\t\t\tfieldl[y][x] = '.';\n\t\t\t\t}\n\t\t\t\tif(fieldl[y][x] == 'R'){\n\t\t\t\t\trsy = y;rsx = x;\n\t\t\t\t\tfieldl[y][x] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int x=1;x<=maxw;++x){\n\t\t\t\tcin >> fieldr[y][x];\n\t\t\t\tif(fieldr[y][x] == 'L'){\n\t\t\t\t\tlsy = y;lsx = x;\n\t\t\t\t\tfieldr[y][x] = '.';\n\t\t\t\t}\n\t\t\t\tif(fieldr[y][x] == 'R'){\n\t\t\t\t\trsy = y;rsx = x;\n\t\t\t\t\tfieldr[y][x] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqueue<P> q;\n\t\tbool isGoal = false;\n\t\tq.push(P(PP(lsy,lsx),PP(rsy,rsx)));\n\t\tvisited[lsy][lsx][rsy][rsx] = true;\n\t\twhile(!q.empty()){\n\t\t\tP p = q.front();q.pop();\n\t\t\tfor(int i=0;i<4;++i){\n\t\t\t\tbool f=false;\n\t\t\t\tPP tol = PP(p.first.first+dyl[i],p.first.second+dxl[i]);//y,x\n\t\t\t\tPP tor = PP(p.second.first+dyr[i],p.second.second+dxr[i]);//y,x\n\t\t\t\tif(visited[tol.first][tol.second][tor.first][tor.second])\n\t\t\t\t\tcontinue;\n\t\t\t\tif(fieldl[tol.first][tol.second] == '%' && fieldr[tor.first][tor.second] == '%'){\n\t\t\t\t\tisGoal = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(fieldl[tol.first][tol.second] == '%' || fieldr[tor.first][tor.second] == '%')\n\t\t\t\t\tcontinue;\n\t\t\t\tPP l = PP(p.first.first,p.first.second);\n\t\t\t\tPP r = PP(p.second.first,p.second.second);\n\t\t\t\tif(fieldl[tol.first][tol.second] == '.'){\n\t\t\t\t\tl = tol;\n\t\t\t\t\tf=true;\n\t\t\t\t}\n\t\t\t\tif(fieldr[tor.first][tor.second] == '.'){\n\t\t\t\t\tr = tor;\n\t\t\t\t\tf=true;\n\t\t\t\t}\n\t\t\t\tif(!f)\n\t\t\t\t\tcontinue;\n\t\t\t\tvisited[l.first][l.second][r.first][r.second] = true;\n\t\t\t\tif(visited[l.first][l.second][r.first][r.second])\n\t\t\t\t\tcontinue;\n\t\t\t\tq.push(P(l,r));\n\t\t\t}\n\t\t\tif(isGoal)\n\t\t\t\tbreak;\n\t\t}\n\t\t(isGoal?cout<<\"Yes\"<<endl:cout<<\"No\"<<endl);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint w, h;\nstring l[51], r[51];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint lsx, lsy, rsx, rsy, lgx, lgy, rgx, rgy;\nbool ischecked[52][52][52][52];\n\nbool solve(int lx, int ly, int rx, int ry){\n    if(lx == lgx && ly == lgy && rx == rgx && ry == rgy) return true;\n    if((lx == lgx && ly == lgy) || (rx == rgx && ry == rgy)) return false;\n    for(int i = 0; i < 4; i++){\n        int nlx = lx + dx[i], nly = ly + dy[i];\n        int nrx = rx + dx[i], nry = ry - dy[i];\n        if((nlx < 0 || nly < 0 || nlx >= h || nly >= w) && (nrx < 0 || nry < 0 || nrx >= h || nry >= w)) continue;\n        if(nlx < 0 || nlx >= h || nly < 0 || nly >= w){\n            nlx = lx;\n            nly = ly;\n        }\n        if(nrx < 0 || nrx >= h || nry < 0 || nry >= w){\n            nrx = rx;\n            nry = ry;\n        }\n        if((l[nlx][nly] == '#' && r[nrx][nry] == '#') || ischecked[nlx][nly][nrx][nry]) continue;\n        if(l[nlx][nly] == '#'){\n            nlx = lx;\n            nly = ly;\n        }\n        if(r[nrx][nry] == '#'){\n            nrx = rx;\n            nry = ry;\n        }\n        ischecked[nlx][nly][nrx][nry] = true;\n        if(solve(nlx, nly, nrx, nry)) return true;\n        ischecked[nlx][nly][nrx][nry] = false;\n    }\n    return false;\n}\n\nint main()\n{\n    while(1){\n        cin >> w >> h;\n        if(w == 0 && h == 0) break;\n        for(int i = 0; i < h; i++){\n            cin >> l[i] >> r[i];\n        }\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                for(int k = 0; k < h; k++){\n                    for(int l = 0; l < w; l++){\n                        ischecked[i][j][k][l] = false;\n                    }\n                }\n                if(l[i][j] == 'L'){\n                    lsx = i;\n                    lsy = j;\n                }\n                if(l[i][j] == '%'){\n                    lgx = i;\n                    lgy = j;\n                }\n                if(r[i][j] == 'R'){\n                    rsx = i;\n                    rsy = j;\n                }\n                if(r[i][j] == '%'){\n                    rgx = i;\n                    rgy = j;\n                }\n            }\n        }\n        ischecked[lsx][lsy][rsx][rsy] = true;\n        if(solve(lsx, lsy, rsx, rsy)) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <typeinfo>\n#include <numeric>\n#include <functional>\n#include <unordered_map>\n#include <bitset>\n#include <stack>\n#include <assert.h>\n#include <unordered_set>\n#include <random>\n\n\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define REP(i, n) for(ll i = 0; i < n; i++)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint main(){\n    ll h, w;\n    cin >> w >> h;\n    while(h || w){\n        vector<string> s1(h), s2(h);\n        ll sy1, sx1, sy2, sx2;\n        REP(i, h){\n            cin >> s1[i] >> s2[i];\n            REP(j, w){\n                if(s1[i][j] == 'L'){\n                    sy1 = i;\n                    sx1 = j;\n                }\n                if(s2[i][j] == 'R'){\n                    sy2 = i;\n                    sx2 = j;\n                }\n            }\n        }\n        bool memo[50][50][50][50] = {};\n        const ll dy[4] = {-1, 0, 1, 0};\n        const ll dx[4] = {0, 1, 0, -1};\n        queue<pair<pair<ll, ll>, pair<ll, ll>>> que;\n        que.push({{sy1, sx1}, {sy2, sx2}});\n        bool ok = false;\n        while(!que.empty()){\n            auto tmp = que.front(); que.pop();\n            ll y1 = tmp.first.first, x1 = tmp.first.second;\n            ll y2 = tmp.second.first, x2 = tmp.second.second;\n            if(memo[y1][x1][y2][x2]) continue;\n            memo[y1][x1][y2][x2] = true;\n            if(s1[y1][x1] == '%' && s2[y2][x2] == '%'){\n                ok = true;\n                break;\n            }\n            else if(s1[y1][x1] == '%' || s2[y2][x2] == '%'){\n                continue;\n            }\n            REP(i, 4){\n                ll yy1 = y1 + dy[i], xx1 = x1 + dx[i];\n                ll yy2 = y2 + dy[i], xx2 = x2 - dx[i];\n                if(yy1 < 0 || yy1 >= h || xx1 < 0 || xx1 >= w || s1[yy1][xx1] == '#'){\n                    yy1 -= dy[i];\n                    xx1 -= dx[i];\n                }\n                if(yy2 < 0 || yy2 >= h || xx2 < 0 || xx2 >= w || s2[yy2][xx2] == '#'){\n                    yy2 -= dy[i];\n                    xx2 += dx[i];\n                }\n                que.push({{yy1, xx1}, {yy2, xx2}});\n            }\n        }\n        cout << ((ok)? \"Yes\" : \"No\") << endl;\n        \n        cin >> w >> h;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string>\n#include<map>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\ntypedef pair<pair<int, int>, pair<int, int> > ppp;\n\nint w, h;\nbool gone[50][50][50][50];\nint rf[50][50];\nint lf[50][50];\n\nint dw[4] = {0, 1, 0, -1};\nint dh[4] = {-1, 0, 1, 0};\n\nint main(){\n    map<char, int> m;\n    m.insert(make_pair('.', 0));\n    m.insert(make_pair('#', 1));\n    m.insert(make_pair('%', 2));\n    m.insert(make_pair('R', 0));\n    m.insert(make_pair('L', 0));\n    \n    while(1){\n        cin >> w >> h;\n        if(w == 0) break;\n\n        queue<ppp> que;\n        ppp p;\n        REP(i, h){\n            string s;\n            cin >> s;\n            REP(j, w){\n                lf[i][j] = m.at(s[j]);\n                if(s[j] == 'L'){\n                    p.second = make_pair(i, j);\n                }\n            }\n            cin >> s;\n            REP(j, w){\n                rf[i][j] = m.at(s[j]);\n                if(s[j] == 'R'){\n                    p.first = make_pair(i, j);\n                }\n            }\n        }\n\n        que.push(p);\n\n        REP(i, h) REP(j, w) REP(k, h) REP(l, w) gone[i][j][k][l] = false;\n        gone[p.first.first][p.first.second][p.second.first][p.second.second] = true;\n\n        bool flag = false;\n        while(!que.empty()){\n            ppp p = que.front();\n            que.pop();\n\n            int rh = p.first.first;\n            int rw = p.first.second;\n            int lh = p.second.first;\n            int lw = p.second.second;\n\n            REP(i, 4){\n                int nrh = rh + dh[i];\n                int nrw = rw + dw[i];\n                int nlh = lh + dh[i];\n                int nlw = lw - dw[i];\n                if(rf[nrh][nrw]==1 || nrh<0 || nrh>=h || nrw<0 || nrw>=w){\n                    nrh = rh; nrw = rw;\n                }\n                if(lf[nlh][nlw]==1 || nlh<0 || nlh>=h || nlw<0 || nlw>=w){\n                    nlh = lh; nlw = lw;\n                }\n                if((rf[nrh][nrw]==2 && lf[nlh][nlw]!=2) || (rf[nrh][nrw]!=2 && lf[nlh][nlw]==2)){\n                    continue;\n                }\n                if(rf[nrh][nrw]==2 && lf[nlh][nlw]==2){\n                    flag = true;\n                    queue<ppp> empty;\n                    swap(que, empty);\n                    break;\n                }\n                if(!gone[nrh][nrw][nlh][nlw]){\n                    gone[nrh][nrw][nlh][nlw] = true;\n                    que.push(make_pair(make_pair(nrh, nrw), make_pair(nlh, nlw)));\n                }\n            }\n        }\n\n        if(flag){\n            cout << \"Yes\" << endl;\n        } else {\n            cout << \"No\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nint w, h;\nP sl, sr;\nstring s[1000];\nstring t[1000];\nbool f[100][100][100][100];\n\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\n\n//set<pair<P,P>>\n\nbool solve(int ly, int lx, int ry, int rx) {\n\tbool res = 0;\n\tf[ly][lx][ry][rx] = 1;\n\tREP(i, 4) {\n\t\tint nly = ly + dy[i], nry = ry + dy[i], nlx = lx + dx[i], nrx = rx + dx[i];\n\t\tif (nly >= 0 && nly < h&&nlx >= 0 && nlx < w&&nry >= 0 && nry < h&&nrx >= 0 && nrx < w) {\n\t\t\tif (f[nly][nrx][nry][nrx])continue;\n\t\t\tif (s[nly][nlx] != t[nry][nrx]) {\n\t\t\t\tif (s[nly][nlx] == '%' || t[nry][nrx] == '%')continue;\n\t\t\t\tif (s[nly][nlx] == '#')res |= solve(ly, lx, nry, nrx);\n\t\t\t\telse if (t[nry][nrx] == '#')res |= solve(nly, nlx, ry, rx);\n\t\t\t\telse res |= solve(nly, nlx, nry, nrx);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (s[nly][nlx] == '%')res |= true;\n\t\t\t\telse if (s[nly][nlx] == '.')res |= solve(nly, nlx, nry, nrx);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\twhile (cin >> w >> h&&w + h) {\n\t\tREP(i, 100)REP(j, 100)REP(k,100)REP(l,100) {\n\t\t\tf[i][j][k][l] = 0;\n\t\t}\n\t\tREP(i, h) {\n\t\t\tcin >> s[i] >> t[i];\n\t\t\treverse(ALL(t[i]));\n\t\t}\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tif (s[i][j] == 'L') {\n\t\t\t\t\tsl = { i,j };\n\t\t\t\t\ts[i][j] = '.';\n\t\t\t\t}\n\t\t\t\tif (t[i][j] == 'R') {\n\t\t\t\t\tsr = { i,j };\n\t\t\t\t\ts[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (solve(sl.first, sl.second, sr.first, sr.second))cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"tune=native\")\n#pragma GCC target (\"avx\")\n\n#include <bits/stdc++.h>\n\n// 汎用マクロ\n#define ALL_OF(x) (x).begin(), (x).end()\n#define REP(i,n) for (long long i=0, i##_len=(n); i<i##_len; i++)\n#define RANGE(i,is,ie) for (long long i=(is), i##_end=(ie); i<=i##_end; i++)\n#define DSRNG(i,is,ie) for (long long i=(is), i##_end=(ie); i>=i##_end; i--)\n#define UNIQUE(v) { sort((v).begin(), (v).end()); (v).erase(unique((v).begin(), (v).end()), (v).end()); }\ntemplate<class T> bool chmax(T &a, const T &b) {if (a < b) {a = b; return 1;} return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) {if (a > b) {a = b; return 1;} return 0; }\n#define INF 0x7FFFFFFF\n#define LINF 0x7FFFFFFFFFFFFFFFLL\n#define Yes(q) (q ? \"Yes\" : \"No\")\n#define YES(q) (q ? \"YES\" : \"NO\")\n#define DUMP(q) cerr << \"[DEBUG] \" #q \": \" << (q) << \" at \" __FILE__ \":\" << __LINE__ << endl\n#define DUMPALL(q) cerr << \"[DEBUG] \" #q \": [\"; REP(dumpall_i, (q).size()) { cerr << q[dumpall_i] << (dumpall_i == (q).size() - 1 ? \"\" : \", \"); } cerr << \"] at \" __FILE__ \":\" << __LINE__ << endl\n\n// gcc拡張マクロ\n#define gcd __gcd\n#define popcount __builtin_popcount\n#define popcountll __builtin_popcountll\n\n// エイリアス\nusing  ll = long long;\nusing ull = unsigned long long;\nusing  ld = long double;\nusing namespace std;\n\n// モジュール\n\n\n// 処理内容\nint main() {\n    \n    ll w, h;\n    while (cin >> w >> h, w && h) {\n\n        vector<string> rl(h), rr(h);\n        REP(i, h) cin >> rl[i] >> rr[i];\n        ll lsy, lsx, rsy, rsx;\n        ll lgy, lgx, rgy, rgx;\n        REP(i, h) REP(j, w) {\n            if (rl[i][j] == '%') {\n                lsy = i;\n                lsx = j;\n            } else if (rl[i][j] == 'L') {\n                lgy = i;\n                lgx = j;\n            }\n            if (rr[i][j] == '%') {\n                rsy = i;\n                rsx = j;\n            } else if (rr[i][j] == 'R') {\n                rgy = i;\n                rgx = j;\n            }\n        }\n\n        // {ly, lx, ry, rx}\n        deque<tuple<ll,ll,ll,ll>> q;\n        vector<vector<vector<vector<bool>>>> visited(h, vector<vector<vector<bool>>>(w, vector<vector<bool>>(h, vector<bool>(w, false))));\n        q.emplace_back(lsy, lsx, rsy, rsx);\n        visited[lsy][lsx][rsy][rsx] = true;\n        while (!q.empty()) {\n\n            ll ly = get<0>(q.front());\n            ll lx = get<1>(q.front());\n            ll ry = get<2>(q.front());\n            ll rx = get<3>(q.front());\n            q.pop_front();\n\n            // Lin and Ren go upward\n            if (ly > 0 && ry > 0) {\n                ll ly2 = rl[ly - 1][lx] != '#' ? ly - 1 : ly;\n                ll lx2 = lx;\n                ll ry2 = rr[ry - 1][lx] != '#' ? ry - 1 : ry;\n                ll rx2 = rx;\n                if (!visited[ly2][lx2][ry2][rx2]) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n                if (ly < h-1) if (rl[lx][ly+1] == '#') {\n                    ll ly2 = ly;\n                    if (!visited[ly2][lx2][ry2][rx2]) {\n                        q.emplace_back(ly2, lx2, ry2, rx2);\n                        visited[ly2][lx2][ry2][rx2] = true;\n                    }\n                }\n                if (ry < h-1) if (rr[rx][ry+1] == '#') {\n                    ll ry2 = ry;\n                    if (!visited[ly2][lx2][ry2][rx2]) {\n                        q.emplace_back(ly2, lx2, ry2, rx2);\n                        visited[ly2][lx2][ry2][rx2] = true;\n                    }\n                }\n            }\n\n            // Lin and Ren go downward\n            if (ly < h-1 && ry < h-1) {\n                ll ly2 = rl[ly + 1][lx] != '#' ? ly + 1 : ly;\n                ll lx2 = lx;\n                ll ry2 = rr[ry + 1][lx] != '#' ? ry + 1 : ry;\n                ll rx2 = rx;\n                if (!visited[ly2][lx2][ry2][rx2]) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n                if (ly > 0) if (rl[lx][ly-1] == '#') {\n                    ll ly2 = ly;\n                    if (!visited[ly2][lx2][ry2][rx2]) {\n                        q.emplace_back(ly2, lx2, ry2, rx2);\n                        visited[ly2][lx2][ry2][rx2] = true;\n                    }\n                }\n                if (ry > 0) if (rr[rx][ry-1] == '#') {\n                    ll ry2 = ry;\n                    if (!visited[ly2][lx2][ry2][rx2]) {\n                        q.emplace_back(ly2, lx2, ry2, rx2);\n                        visited[ly2][lx2][ry2][rx2] = true;\n                    }\n                }\n            }\n\n            // Lin goes left and Ren goes right\n            if (lx > 0 && rx < w-1) {\n                ll ly2 = ly;\n                ll lx2 = rl[ly][lx - 1] != '#' ? lx - 1 : lx;\n                ll ry2 = ry;\n                ll rx2 = rr[ry][rx + 1] != '#' ? rx + 1 : rx;\n                if (!visited[ly2][lx2][ry2][rx2]) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n                if (lx < w-1) if (rl[ly][lx+1] == '#') {\n                    ll lx2 = lx;\n                    if (!visited[ly2][lx2][ry2][rx2]) {\n                        q.emplace_back(ly2, lx2, ry2, rx2);\n                        visited[ly2][lx2][ry2][rx2] = true;\n                    }\n                }\n                if (rx > 0) if (rr[ry][rx-1] == '#') {\n                    ll rx2 = rx;\n                    if (!visited[ly2][lx2][ry2][rx2]) {\n                        q.emplace_back(ly2, lx2, ry2, rx2);\n                        visited[ly2][lx2][ry2][rx2] = true;\n                    }\n                }\n            }\n\n            // Lin goes right and Ren goes left\n            if (lx < w-1 && rx > 0) {\n                ll ly2 = ly;\n                ll lx2 = rl[ly][lx + 1] != '#' ? lx + 1 : lx;\n                ll ry2 = ry;\n                ll rx2 = rr[ry][rx - 1] != '#' ? rx - 1 : rx;\n                if (!visited[ly2][lx2][ry2][rx2]) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n                if (lx > 0) if (rl[ly][lx-1] == '#') {\n                    ll lx2 = lx;\n                    if (!visited[ly2][lx2][ry2][rx2]) {\n                        q.emplace_back(ly2, lx2, ry2, rx2);\n                        visited[ly2][lx2][ry2][rx2] = true;\n                    }\n                }\n                if (rx < w-1) if (rr[ry][rx+1] == '#') {\n                    ll rx2 = rx;\n                    if (!visited[ly2][lx2][ry2][rx2]) {\n                        q.emplace_back(ly2, lx2, ry2, rx2);\n                        visited[ly2][lx2][ry2][rx2] = true;\n                    }\n                }\n            }\n\n        }\n\n        std::cout << Yes(visited[lgy][lgx][rgy][rgx]) << endl;\n\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<char,char> P;\n\nstruct state{\n\tP p1, p2;\n\tstate(P p1_, P p2_){ p1 = p1_; p2 = p2_; }\n};\nint w, h;\nint dx1[4] = {0,-1,1,0};\nint dy1[4] = {-1,0,0,1};\nint dx2[4] = {0,1,-1,0};\nint dy2[4] = {-1,0,0,1};\nbool flag[51][51][51][51];\nchar L[51][51];\nchar R[51][51];\n\nvoid init(){\n\tfor(int i=0 ; i < 51 ; i++ ){\n\t\tfor(int j=0 ; j < 51 ; j++ ){\n\t\t\tfor(int k=0 ; k < 51 ; k++ ){\n\t\t\t\tfor(int l=0 ; l < 51 ; l++ ){\n\t\t\t\t\tflag[i][j][k][l] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// デバッグ用\nvoid debug(){\n\tcout << \"[Left]\" << endl;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tcout << L[y][x];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n\tcout << \"[right]\" << endl;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tcout << R[y][x];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// R[y][x] == 'R' となる (x,y) を返す\nP R_search(){\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( R[y][x] == 'R' ){\n\t\t\t\tR[y][x] = '.';\n\t\t\t\treturn P(x,y);\n\t\t\t}\n\t\t}\n\t}\n\treturn P(0,0);\n}\n\n// L[y][x] == 'L' となる (x,y) を返す\nP L_search(){\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( L[y][x] == 'L' ){\n\t\t\t\tL[y][x] = '.';\n\t\t\t\treturn P(x,y);\n\t\t\t}\n\t\t}\n\t}\n\treturn P(0,0);\n}\n\nbool bfs(){\n\tP ls = L_search();\n\tP rs = R_search();\n\t\n\tqueue< pair<P,P> > q;\n\tpair<P,P> s( ls , rs );\n\tq.push( s );\n\t\n\twhile( !q.empty() && q.size() < 1000000 ){\n\t\tpair<P,P> now = q.front(); q.pop();\n\t\tint x1 = now.first.first;\n\t\tint y1 = now.first.second;\n\t\tint x2 = now.second.first;\n\t\tint y2 = now.second.second;\n\t\t\n\t\tif( L[y1][x1] == '%' && R[y2][x2] == '%' ){\n\t\t\treturn true;\n\t\t}else if( L[y1][x1] == '%' && R[y2][x2] != '%' ){\n\t\t\tcontinue;\n\t\t}else if( L[y1][x1] != '%' && R[y2][x2] == '%' ){\n\t\t\tcontinue;\n\t\t}\n\t\tflag[y1][x1][y2][x2] = true;\n\t\t\n\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\tint mx1 = x1 + dx1[i];\n\t\t\tint my1 = y1 + dy1[i];\n\t\t\tif( mx1 < 0 || my1 < 0 || mx1 >= w || my1 >= h || L[my1][mx1] == '#' ){\n\t\t\t\tmx1 = x1;\n\t\t\t\tmy1 = y1;\n\t\t\t}\n\t\t\tint mx2 = x2 + dx2[i];\n\t\t\tint my2 = y2 + dy2[i];\n\t\t\tif( mx2 < 0 || my2 < 0 || mx2 >= w || my2 >= h || R[my2][mx2] == '#' ){\n\t\t\t\tmx2 = x2;\n\t\t\t\tmy2 = y2;\n\t\t\t}\n\t\t\tP p1(mx1,my1);\n\t\t\tP p2(mx2,my2);\n\t\t\tpair<P,P> next(p1,p2);\n\t\t\tif( !flag[my1][mx1][my2][mx2] ){\n\t\t\t\tq.push( next );\n\t\t\t\tflag[my1][mx1][my2][mx2] = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\twhile( cin >> w >> h, w || h ){\n\t\tinit();\n\t\t\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tstring l, r;\n\t\t\tcin >> l >> r;\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tL[y][x] = l[x];\n\t\t\t\tR[y][x] = r[x];\n\t\t\t}\n\t\t}\n\t\t// debug();\n\t\tbool ans = bfs();\n\t\tif( ans )\n\t\t\tcout << \"Yes\" << endl;\n\t\telse\n\t\t\tcout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define\tmp\tmake_pair\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint main(){\n\tfor(int w,h;scanf(\"%d%d\",&w,&h),w;){\n\t\tint lx,ly,rx,ry;\n\t\tstatic char room[2][50][51];\n\t\tfor(int i=0;i<h;i++){\n\t\t\tscanf(\"%s%s\",room[0][i],room[1][i]);\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(room[0][i][j]=='L')\tlx=j,ly=i,room[0][i][j]='.';\n\t\t\t\tif(room[1][i][j]=='R')\trx=j,ry=i,room[1][i][j]='.';\n\t\t\t}\n\t\t}\n\n\t\tstatic bool visited[50][50][50][50];\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tfor(int k=0;k<h;k++)for(int l=0;l<w;l++)\tvisited[i][j][k][l]=false;\n\t\t}\n\t\tbool ok=false;\n\t\tvisited[ly][lx][ry][rx]=true;\n\t\tqueue< pair<pii,pii> > qu;\tqu.push(mp(mp(ly,lx),mp(ry,rx)));\n\t\twhile(!qu.empty()){\n\t\t\tpair<pii,pii> a=qu.front();\tqu.pop();\n\t\t\tpii len=a.first,rin=a.second;\n\t\t\tbool bl=room[0][len.first][len.second]=='%';\n\t\t\tbool br=room[1][rin.first][rin.second]=='%';\n\t\t\tif(bl && br){ ok=true; break; }\n\t\t\tif(bl || br)\tcontinue;\n\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint ly=len.first,lx=len.second;\n\t\t\t\tint ry=rin.first,rx=rin.second;\n\t\t\t\tint lyy=ly+dy[i],lxx=lx+dx[i];\n\t\t\t\tint ryy=ry+dy[i],rxx=rx-dx[i];\n\t\t\t\tif(0<=lyy && lyy<h && 0<=lxx && lxx<w && room[0][lyy][lxx]!='#')\tly=lyy,lx=lxx;\n\t\t\t\tif(0<=ryy && ryy<h && 0<=rxx && rxx<w && room[1][ryy][rxx]!='#')\try=ryy,rx=rxx;\n\t\t\t\tif(!visited[ly][lx][ry][rx]){\n\t\t\t\t\tqu.push(mp(mp(ly,lx),mp(ry,rx)));\n\t\t\t\t\tvisited[ly][lx][ry][rx]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tputs(ok?\"Yes\":\"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define int long long\n#define FOR(i, m, n) for (int i = (m); i < (n); i++)\n#define all(x) x.begin(), x.end()\nusing pii = pair<int, int>;\n\nchar A[55][55], B[55][55];\nbool vis[55][55][55][55];\nconstexpr int dx[4] = {0, 0, -1, 1}, dy[4] = {1, -1, 0, 0};\nbool solve() {\n    int W, H;\n    cin >> W >> H;\n    if (W == 0) return false;\n    int sxa, sya, sxb, syb, gxa, gya, gxb, gyb;\n    REP(i, H) {\n        REP(j, W) {\n            cin >> A[i][j];\n            if (A[i][j] == 'L') {\n                sxa = i;\n                sya = j;\n            }\n            if (A[i][j] == '%') {\n                gxa = i;\n                gya = j;\n            }\n        }\n        REP(j, W) {\n            cin >> B[i][j];\n            if (B[i][j] == 'R') {\n                sxb = i, syb = j;\n            }\n            if (B[i][j] == '%') {\n                gxb = i, gyb = j;\n            }\n        }\n    }\n    REP(ia, H) REP(ja, W) REP(ib, H) REP(jb, W) { vis[ia][ja][ib][jb] = false; }\n    using arr4 = array<int, 4>;\n    queue<arr4> que;\n    que.push({sxa, sya, sxb, syb});\n    while (!que.empty()) {\n        arr4 arr = que.front();\n        que.pop();\n        int i = arr[0], j = arr[1], x = arr[2], y = arr[3];\n        vis[i][j][x][y] = true;\n        // Aが動く\n        REP(k, 4) {\n            int ni = i + dx[k], nj = j + dy[k];\n            int nx = x + dx[k], ny = y - dy[k];\n            if (ni < 0 || ni >= H || nj < 0 || nj >= W || A[ni][nj] == '#') continue;\n            if (nx < 0 || nx >= H || ny < 0 || ny >= W || B[nx][ny] == '#') {\n                nx = x, ny = y;\n            }\n            if ((A[ni][nj] == '%' && B[nx][ny] != '%') || (A[ni][nj] != '%' && B[nx][ny] == '%')) continue;\n            if (vis[ni][nj][nx][ny]) continue;\n            vis[ni][nj][nx][ny] = true;\n            que.push({ni, nj, nx, ny});\n        }\n\n        // Bが動く\n        REP(k, 4) {\n            int ni = i + dx[k], nj = j + dy[k];\n            int nx = x + dx[k], ny = y - dy[k];\n            if (ni < 0 || ni >= H || nj < 0 || nj >= W || A[ni][nj] == '#') {\n                ni = i, nj = j;\n            };\n            if (nx < 0 || nx >= H || ny < 0 || ny >= W || B[nx][ny] == '#') continue;\n            if ((A[ni][nj] == '%' && B[nx][ny] != '%') || (A[ni][nj] != '%' && B[nx][ny] == '%')) continue;\n            if (vis[ni][nj][nx][ny]) continue;\n            vis[ni][nj][nx][ny] = true;\n            que.push({ni, nj, nx, ny});\n        }\n    }\n    if (vis[gxa][gya][gxb][gyb])\n        cout << \"Yes\" << endl;\n    else\n        cout << \"No\" << endl;\n    return true;\n}\n\nsigned main() {\n    while (solve())\n        ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\nchar fieldL[51][51];\nchar fieldR[51][51];\nbool isArrival[51][51][51][51];\nint h,w;\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\nint fly,flx,frx,fry;\nvoid bfs(int slx,int sly,int srx,int sry){\n\tqueue<pair<int,int> > *prvL=new queue<pair<int,int> >();\n\tqueue<pair<int,int> > *nxtL=new queue<pair<int,int> >();\n\tqueue<pair<int,int> > *prvR=new queue<pair<int,int> >();\n\tqueue<pair<int,int> > *nxtR=new queue<pair<int,int> >();\n\tprvL->push(make_pair(sly,slx));\n\tprvR->push(make_pair(sry,srx));\n\twhile(prvL->size()){\n\t\twhile(prvL->size()){\n\t\t\tpair<int,int> pl=prvL->front();prvL->pop();\n\t\t\tpair<int,int> pr=prvR->front();prvR->pop();\n\t\t\tint ly=pl.first;int lx=pl.second;\n\t\t\tint ry=pr.first;int rx=pr.second;\n\t\t\tif(isArrival[ly][lx][ry][rx])\n\t\t\t\tcontinue;\n\t\t\tisArrival[ly][lx][ry][rx]=true;\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint nly=max(0,min(h-1,ly+dy[i]));\n\t\t\t\tint nlx=max(0,min(w-1,lx+dx[i]));\n\t\t\t\tint nry=max(0,min(h-1,ry+dy[i]));\n\t\t\t\tint nrx=max(0,min(w-1,rx-dx[i]));\n\t\t\t\tif(fieldL[nly][nlx]=='#'){\n\t\t\t\t\tnly=ly;\n\t\t\t\t\tnlx=lx;\n\t\t\t\t}\n\t\t\t\tif(fieldR[nry][nrx]=='#'){\n\t\t\t\t\tnry=ry;\n\t\t\t\t\tnrx=rx;\n\t\t\t\t}\n\t\t\t\tif((nly==fly&&nlx==flx)&&!(nry==fry&&nrx==frx)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if(!(nly==fly&&nlx==flx)&&(nry==fry&&nrx==frx)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if((nly==fly&&nlx==flx)&&(nry==fry&&nrx==frx)){\n\t\t\t\t\tisArrival[nly][nlx][nry][nrx]=true;\n\t\t\t\t\tdelete prvL,prvR,nxtL,nxtR;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif(!isArrival[nly][nlx][nry][nrx]){\n\t\t\t\t\tnxtL->push(make_pair(nly,nlx));\n\t\t\t\t\tnxtR->push(make_pair(nry,nrx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(prvL,nxtL);\n\t\tswap(prvR,nxtR);\n\t}\n\tdelete prvL,prvR,nxtL,nxtR;\n}\n\nint main(){\n\twhile(cin>>w>>h&&!(w==0&&h==0)){\n\t\tmemset(isArrival,0,sizeof(isArrival));\n\t\tint sly,slx,srx,sry;\n\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>fieldL[i][j];\n\t\t\t\tif(fieldL[i][j]=='L'){\n\t\t\t\t\tfieldL[i][j]='.';\n\t\t\t\t\tsly=i;\n\t\t\t\t\tslx=j;\n\t\t\t\t}\n\t\t\t\telse if(fieldL[i][j]=='%'){\n\t\t\t\t\tfieldL[i][j]='.';\n\t\t\t\t\tfly=i;\n\t\t\t\t\tflx=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>fieldR[i][j];\n\t\t\t\tif(fieldR[i][j]=='R'){\n\t\t\t\t\tfieldR[i][j]='.';\n\t\t\t\t\tsry=i;\n\t\t\t\t\tsrx=j;\n\t\t\t\t}\n\t\t\t\telse if(fieldR[i][j]=='%'){\n\t\t\t\t\tfieldR[i][j]='.';\n\t\t\t\t\tfry=i;\n\t\t\t\t\tfrx=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbfs(slx,sly,srx,sry);\n\t\tif(isArrival[fly][flx][fry][frx])\n\t\t\tcout<<\"Yes\"<<endl;\n\t\telse\n\t\t\tcout<<\"No\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 51\n\nstruct State{\n  int x1,y1,x2,y2;\n  State(int x1, int y1, int x2, int y2) : x1(x1), y1(y1), x2(x2), y2(y2) {}\n};\n\nint H, W;\nchar f1[MAX][MAX], f2[MAX][MAX];\nbool vis[MAX][MAX][MAX][MAX];\nconst int lx[] = {0,-1,1,0};\nconst int ly[] = {-1,0,0,1};\nconst int rx[] = {0,1,-1,0};\nconst int ry[] = {-1,0,0,1};\n\nbool inField(int y, int x){\n  return 0 <= y && y < H && 0 <= x && x < W;\n}\n\nbool bfs(int Lx, int Ly, int Rx, int Ry){\n  memset(vis, false, sizeof(vis));\n  queue<State> Q;\n  Q.push(State(Lx, Ly, Rx, Ry));\n\n  while(!Q.empty()){\n    State s = Q.front(); Q.pop();\n\n    if(f1[s.y1][s.x1] == '%' && f2[s.y2][s.x2] == '%'){\n      return true;\n    }\n\n    for(int i = 0 ; i < 4 ; i++){\n      int nlx = s.x1 + lx[i], nly = s.y1 + ly[i];\n      int nrx = s.x2 + rx[i], nry = s.y2 + ry[i];\n\n      if(!inField(nly, nlx) || f1[nly][nlx] == '#'){\n        nlx = s.x1;\n        nly = s.y1;\n      }\n      if(!inField(nry, nrx) || f2[nry][nrx] == '#'){\n        nrx = s.x2;\n        nry = s.y2;\n      }\n\n      if(vis[nly][nlx][nry][nrx]) continue;\n      vis[nly][nlx][nry][nrx] = true;\n      Q.push(State(nlx, nly, nrx, nry));\n    }\n  }\n\n  return false;\n}\n\nint main(){\n  while(cin >> W >> H, (W | H)){\n    string str;\n    int Lx, Ly, Rx, Ry;\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < 2 ; j++){\n        cin >> str;\n        for(int k = 0 ; k < W ; k++){\n          if(j % 2 == 0){\n            f1[i][k] = str[k];\n            if(f1[i][k] == 'L'){\n              Lx = k;\n              Ly = i;\n            }\n          }else{\n            f2[i][k] = str[k];\n            if(f2[i][k] == 'R'){\n              Rx = k;\n              Ry = i;\n            }\n          }\n        }\n      }\n    }\n    cout << (bfs(Lx, Ly, Rx, Ry) ? \"Yes\" : \"No\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nchar RenR[51][51],LinR[51][51];\nbool memo[51][51][51][51];\nstring ans;\nint h,w;\n//         l r d u\nint Rx[4]={0,0,1,-1};\nint Ry[4]={1,-1,0,0};\n//         r l d u\nint Lx[4]={0,0,1,-1};\nint Ly[4]={-1,1,0,0};\n\n\nvoid move(int muki,int ri,int rj,int li,int lj)\n{\n  //cout<<ri<<\" \"<<rj<<\" \"<<li<<\" \"<<lj<<endl;\n  int ra=ri+Rx[muki],rb=rj+Ry[muki];\n  if(0<=ra && 0<=rb && ra<h && rb<w){\n    if(RenR[ra][rb]!='#'){\n      ri=ra;\n      rj=rb;\n    }\n  }\n  int la=li+Lx[muki],lb=lj+Ly[muki];\n  if(0<=la && 0<=lb && la<h && lb<w){\n    if(LinR[la][lb]!='#'){\n      li=la;\n      lj=lb;\n    }\n  }\n  if(memo[ri][rj][li][lj])return;\n\n  memo[ri][rj][li][lj]=true;\n\n  if(RenR[ri][rj]=='%' && LinR[li][lj]=='%'){\n    ans=\"Yes\";\n    return;\n  }\n  if(RenR[ri][rj]=='%' || LinR[li][lj]=='%')return;\n\n  for(int k=0;k<4;k++){\n    move(k,ri,rj,li,lj);\n  }\n}\n\nint main()\n{\n  int ri,rj,li,lj;\n  while(1){\n    cin>>w>>h;\n    if(w+h==0)break;\n\n    for(int i=0;i<50;i++){\n      for(int j=0;j<50;j++){\n\tfor(int k=0;k<50;k++){\n\t  for(int l=0;l<50;l++)memo[i][j][k][l]=false;\n\t}\n      }\n    }\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>LinR[i][j];\n\tif(LinR[i][j]=='L'){\n\t  li=i;lj=j;\n\t  LinR[i][j]='.';\n\t}\n      }\n      for(int j=0;j<w;j++){\n\tcin>>RenR[i][j];\n\tif(RenR[i][j]=='R'){\n\t  ri=i;rj=j;\n\t  RenR[i][j]='.';\n\t}\n      }\n    }\n    ans=\"No\";\n    memo[ri][rj][li][lj]=true;\n    for(int i=0;i<4;i++){\n      move(i,ri,rj,li,lj);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <array>\n#include <queue>\n#include <array>\n#include <stack>\n#include <cstring>\n\nenum PassageType{\n\tFREE, WALL, SEARCHED, GOAL,\n};\n\nbool isSearched[50][50][50][50] = {false};\n\nstruct Point {\n\tPoint() { x = 0; y = 0; };\n\tPoint(int x, int y) {\n\t\tthis->x = x;\n\t\tthis->y = y;\n\t};\n\tint x, y;\n};\n\nint main() {\n\tint w, h;\n\n\twhile (std::cin >> w >> h && w && h) {\n\t\tstd::memset(isSearched, false, sizeof(bool) * 50 * 50 * 50 * 50);\n\t\tstd::array<std::vector<std::vector<int>>, 2> room;\n\t\tPoint start[2];\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tstd::array<std::string, 2> str;\n\t\t\tfor (int j = 0; j < str.size(); j++) {\n\t\t\t\tstd::cin >> str[j];\n\t\t\t\troom[j].push_back(std::vector<int>());\n\t\t\t\tfor (int k = 0; k < str[j].size(); k++) {\n\t\t\t\t\tint type = 0;\n\t\t\t\t\tif (str[j][k] == '.') type = FREE;\n\t\t\t\t\telse if (str[j][k] == '#') type = WALL;\n\t\t\t\t\telse if (str[j][k] == '%') type = GOAL;\n\t\t\t\t\telse if (str[j][k] == 'L' || str[j][k] == 'R') {\n\t\t\t\t\t\tstart[j].x = k;\n\t\t\t\t\t\tstart[j].y = i;\n\t\t\t\t\t\ttype = SEARCHED;\n\t\t\t\t\t}\n\t\t\t\t\troom[j].back().push_back(type);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstd::stack<std::pair<Point, Point>> s;\n\t\ts.push(std::make_pair(start[0], start[1]));\n\t\tint dx[] = {1, 0, -1, 0};\n\t\tint dy[] = {0, 1, 0, -1};\n\n\t\tbool isOk = false;\n\t\twhile (!s.empty() && !isOk) {\n\t\t\tauto node = s.top(); s.pop();\n\n\t\t\t//?¬???????????????´????????¢???\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tauto next = node;\n\t\t\t\tnext.first.x += dx[i];\n\t\t\t\tnext.first.y += dy[i];\n\t\t\t\tnext.second.x -= dx[i];\n\t\t\t\tnext.second.y += dy[i];\n\n\t\t\t\t//??´????£???£\n\t\t\t\tnext.first.x = std::min(std::max(0, next.first.x), w - 1);\n\t\t\t\tnext.first.y = std::min(std::max(0, next.first.y), h - 1);\n\t\t\t\tnext.second.x = std::min(std::max(0, next.second.x), w - 1);\n\t\t\t\tnext.second.y = std::min(std::max(0, next.second.y), h - 1);\n\n\t\t\t\t//??????????????´????????????OK\n\t\t\t\tif (room[0][next.first.y][next.first.x] == GOAL && room[1][next.second.y][next.second.x] == GOAL) {\n\t\t\t\t\tisOk = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint r[2] = {room[0][next.first.y][next.first.x], room[1][next.second.y][next.second.x] };\n\t\t\t\t\t//?£???????????????????????????????\n\t\t\t\t\tif (room[0][next.first.y][next.first.x] == WALL) {\n\t\t\t\t\t\tnext.first = node.first;\n\t\t\t\t\t}\n\t\t\t\t\tif (room[1][next.second.y][next.second.x] == WALL) {\n\t\t\t\t\t\tnext.second = node.second;\n\t\t\t\t\t}\n\t\t\t\t\tif (!isSearched[next.first.y][next.first.x][next.second.y][next.second.x]) {\n\t\t\t\t\t\ts.push(next);\n\t\t\t\t\t\tisSearched[next.first.y][next.first.x][next.second.y][next.second.x] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstd::cout << (isOk ? \"Yes\" : \"No\") << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\nint w,h;\nstring mp[2][51];\nbool ans,memo[51][51][51][51];\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\n\nvoid saiki(int lx,int ly,int rx,int ry){\n  if(ans)return;\n  if(mp[0][ly][lx]=='%'&&mp[1][ry][rx]=='%')ans=1;\n  if(memo[lx][ly][rx][ry]||mp[0][ly][lx]=='%'||mp[1][ry][rx]=='%')return;\n  memo[lx][ly][rx][ry]=1;\n  for(int i=0;i<4;i++){\n    int flg=0;\n    int nlx=lx+dx[i],nly=ly+dy[i];\n    int nrx=rx-dx[i],nry=ry+dy[i];\n    if(nlx<0||nly<0||nlx>=w||nly>=h||mp[0][nly][nlx]=='#')nlx=lx,nly=ly,flg++;\n    if(nrx<0||nry<0||nrx>=w||nry>=h||mp[1][nry][nrx]=='#')nrx=rx,nry=ry,flg++;\n    if(flg==2)continue;\n    saiki(nlx,nly,nrx,nry);\n  }\n}\n\nint main(){\n  while(1){\n  cin >>w>>h;\n  if(!w&&!h)break;\n  for(int i=0;i<h;i++)cin>>mp[0][i]>>mp[1][i];\n  int lx,ly,rx,ry;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(mp[0][i][j]=='L')lx=j,ly=i;\n      if(mp[1][i][j]=='R')rx=j,ry=i;\n    }\n  memset(memo,0,sizeof(memo));\n  ans=0;\n  saiki(lx,ly,rx,ry);\n  if(ans)cout<<\"Yes\"<<endl;\n  else cout<<\"No\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nusing ll=long long;\nusing vi=vector<int>;\nusing vl=vector<long long>;\nusing pii=pair<int,int>;\nusing pll=pair<long long,long long>;\n#define ITR(i,c) for(auto i=begin(c);i!=end(c);++i)\n#define FORE(x,c) for(auto &x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define REPW(i,n) for(i=0;i<(int)(n);++i)\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)   // c++14\n#define SZ(c) ((int)c.size())\n#define EXIST(c,x) (c.find(x)!=end(c))\n#define OUTOFRANGE(y,x,h,w) (y<0||x<0||y>=h||x>=w)\n#define dump(...)\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\n#define INF (1001001001)\n#define INFLL (1001001001001001001ll)\ntemplate<class T> ostream& operator << (ostream &os,const vector<T> &v) {\n    ITR(i,v) os << *i << (i==end(v)-1 ? \"\" : \" \"); return os; }\ntemplate<class T> istream& operator >> (istream &is,vector<T> &v) {\n    ITR(i,v) is >> * i; return is; }\ntemplate<class T> istream& operator >> (istream &is, pair<T,T> &p) {\n        is >> p.first >> p.second; return is; }\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return 1;}return 0;}\n//------------------------------------------------------------------------------\nstruct before_main_function {\n    before_main_function() {\n        #ifdef int\n            #undef INF\n            #define INF INFLL\n            #define stoi stoll\n        #endif\n        cin.tie(0);ios::sync_with_stdio(false);\n        cout<<setprecision(15)<<fixed;\n    }\n} before_main_function;\n//------------------------------------------------------------------------------\n\nint W,H,asx,asy,bsx,bsy,agx,agy,bgx,bgy;\nbool dp[50][50][50][50];\nchar a[50][50],b[50][50];\nvoid solve() {\n    REP(i,50) REP(j,50) REP(k,50) REP(l,50) dp[i][j][k][l]=false;\n\n    REP(i,H) {\n        REP(j,W) cin>>a[i][j];\n        REP(j,W) cin>>b[i][W-j-1];\n        REP(j,W) {\n            if(a[i][j]=='L') asy=i,asx=j;\n            if(b[i][j]=='R') bsy=i,bsx=j;\n            if(a[i][j]=='%') agy=i,agx=j;\n            if(b[i][j]=='%') bgy=i,bgx=j;\n        }\n    }\n\n    queue<pair<pii,pii>> q;\n    q.push({{asy,asx},{bsy,bsx}});\n    dp[asy][asx][bsy][bsx]=true;\n    while(!q.empty()) {\n        int y1=q.front().first.first;\n        int x1=q.front().first.second;\n        int y2=q.front().second.first;\n        int x2=q.front().second.second;\n        q.pop();\n\n        if(y1==agy && x1==agx && y2==bgy && x2==bgx) {\n            cout<<\"Yes\"<<endl;\n            return;\n        }\n\n        REP(d,4) {\n            int ny1=y1+DY[d];\n            int nx1=x1+DX[d];\n            int ny2=y2+DY[d];\n            int nx2=x2+DX[d];\n            if(OUTOFRANGE(ny1,nx1,H,W) || a[ny1][nx1]=='#') {\n                ny1=y1;\n                nx1=x1;\n            }\n            if(OUTOFRANGE(ny2,nx2,H,W) || b[ny2][nx2]=='#') {\n                ny2=y2;\n                nx2=x2;\n            }\n            if(dp[ny1][nx1][ny2][nx2]) continue;\n            dp[ny1][nx1][ny2][nx2]=true;\n            q.push({{ny1,nx1},{ny2,nx2}});\n        }\n    }\n    cout<<\"No\"<<endl;\n}\nsigned main() {\n    while(1!=2) {\n        cin>>W>>H;\n        if(W+H==0) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> stat;\n\nint w, h;\nbool vis[51][51][51][51];\npii ls, lg, rs, rg;\nstat start, goal;\n\nint dx[]={0, 0, 1, -1}, dy[]={1, -1, 0, 0};\n\ninline bool border(pii p){\n\treturn 0<=p.first&&p.first<w&&0<=p.second&&p.second<h;\n}\n\nstring solve(vector<string> left, vector<string> right){\n\t\n\tstart = make_pair(ls, rs);\n\tgoal = make_pair(lg, rg);\n\t\n\tqueue<stat> qu;\n\tqu.push(start);\n\t\n\tmemset(vis, 0, sizeof(vis));\n\tvis[ls.first][ls.second][rs.first][rs.second] = true;\n\t\n\twhile(!qu.empty()){\n\t\n\t\tpii lnx, rnx, lnw, rnw;\n\t\t\n\t\tstat now = qu.front(), nxt;\n\t\tlnw = now.first;\n\t\trnw = now.second;\n\t\t\n\t\tqu.pop();\n\t\t\n\t\tfor(int i=0; i<4; ++i){\n\t\t\t\n\t\t\tlnx = make_pair(lnw.first + dx[i], lnw.second + dy[i]);\n\t\t\trnx = make_pair(rnw.first - dx[i], rnw.second + dy[i]);\n\t\t\t\n\t\t\tif(!border(lnx)||left[lnx.second][lnx.first]=='#')\n\t\t\t\tlnx = lnw;\n\t\t\t\n\t\t\tif(!border(rnx)||right[rnx.second][rnx.first]=='#')\n\t\t\t\trnx = rnw;\n\t\t\t\n\t\t\tnxt = make_pair(lnx, rnx);\n\t\t\t\n\t\t\tif(nxt == goal)\n\t\t\t\treturn \"Yes\";\n\t\t\t\n\t\t\tif(!vis[lnx.first][lnx.second][rnx.first][rnx.second]){\n\t\t\t\t\n\t\t\t\tvis[lnx.first][lnx.second][rnx.first][rnx.second] = true;\n\t\t\t\tqu.push(nxt);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn \"No\";\n}\n\t\nint main(){\n\t\n\twhile(cin>>w>>h, (w||h)){\n\t\t\n\t\tvector<string> left, right;\n\t\t\n\t\tfor(int i=0; i<h; ++i){\n\t\t\t\n\t\t\tstring l, r;\n\t\t\tcin >> l >> r;\n\t\t\t\n\t\t\tleft.push_back(l);\n\t\t\tright.push_back(r);\n\t\t}\n\t\t\n\t\tfor(int y=0; y<h; ++y){\n\t\t\tfor(int x=0; x<w; ++x){\n\t\t\t\n\t\t\t\tif(left[y][x] == 'L')\n\t\t\t\t\tls = make_pair(x, y);\n\t\t\t\tif(left[y][x] == '%')\n\t\t\t\t\tlg = make_pair(x, y);\n\t\t\t\tif(right[y][x] == 'R')\n\t\t\t\t\trs = make_pair(x, y);\n\t\t\t\tif(right[y][x] == '%')\n\t\t\t\t\trg = make_pair(x, y);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout <<\tsolve(left, right) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//50\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nchar g[2][50][50];\nbool p[50][50][50][50];\nint w,h;\n    \nbool dfs(int x,int y,int xx,int yy,int r){\n  if(r==0)return false;\n  if(p[x][y][xx][yy]++||(g[0][y][x]=='%'^g[1][yy][xx]=='%'))return false;\n  if(g[0][y][x]=='%'&&g[1][yy][xx]=='%')return true;\n  for(int i=0;i<4;i++){\n    int dy[]={0,1,0,-1};\n    int dx[][4]={{1,0,-1,0},{-1,0,1,0}};\n    int nx[2],ny[2];\n    nx[0]=x+dx[0][i];\n    ny[0]=y+dy[i];\n    nx[1]=xx+dx[1][i];\n    ny[1]=yy+dy[i];\n    for(int j=0;j<2;j++){\n      if(nx[j]<0||w<=nx[j]||ny[j]<0||h<=ny[j]||g[j][ny[j]][nx[j]]=='#'){\n\tnx[j]-=dx[j][i];\n\tny[j]-=dy[i];\n      }\n    }\n    if(dfs(nx[0],ny[0],nx[1],ny[1],r-1))return true;\n  }\n  return false;\n}\n\nint main(){\n  while(cin>>w>>h,w|h){\n    int px[2],py[2];\n    for(int y=0;y<h;y++){\n      for(int i=0;i<2;i++){\n\tfor(int x=0;x<w;x++){\n\t  cin>>g[i][y][x];\n\t  if(g[i][y][x]=='R'||g[i][y][x]=='L'){\n\t    px[i]=x;\n\t    py[i]=y;\n\t  }\n\t}\n      }\n    }\n    fill(p[0][0][0],p[50][0][0],false);\n    cout<<(dfs(px[0],py[0],px[1],py[1],20000)?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> mp;\ntypedef pair<mp,mp> mmp;\nll inf =  1e9;\n\nint dx[2][4] = { {1,-1,0,0} , {1,-1,0,0} };\nint dy[2][4] = { {0,0,1,-1} , {0,0,-1,1} };\n\nint main(){\nwhile(1){\n    int w,h;\n    cin>>w>>h;\n    if(w==0)break;\n    vector<vector<bool> >  mtl( h+2,vector<bool>(w+2,false) ) ;\n    vector<vector<bool> >  mtr( h+2,vector<bool>(w+2,false) ) ;\n    vector<mp> s(2),g(2);\n    for(int i=1;i<=h;i++){\n\tstring st;\n\tcin>>st;\n\tfor(int j=1;j<=w;j++){\n\t    char tmp = st[j-1];\n\t    if( tmp =='.'){\n\t\tmtl[i][j] = true;\n\t    }\n\t    if( tmp =='%'){\n\t\tmtl[i][j] = true;\n\t\tg[0] =  mp(i,j) ;\n\t    }\n\t    if( tmp =='L'){\n\t\tmtl[i][j] = true;\n\t\ts[0] = mp(i,j) ;\n\t    }\n\t}\n\n\tcin>>st;\n\tfor(int j=1;j<=w;j++){\n\t    char tmp = st[j-1];\n\t    if( tmp =='.'){\n\t\tmtr[i][j] = true;\n\t    }\n\t    if( tmp =='%'){\n\t\tmtr[i][j] = true;\n\t\tg[1] = mp(i,j) ;\n\t    }\n\t    if( tmp =='R'){\n\t\tmtr[i][j] = true;\n\t\ts[1] = mp(i,j) ;\n\t    }\n\t}\n    }\n    mmp goal1 = mmp( g[0] , g[1] );\n    set<mmp> state;\n    state.insert(mmp(s[0],s[1]) );\n    queue< mmp > q;\n    bool f = true;\n    q.push( mmp( s[0], s[1] ) );\n    while( !q.empty() ){\n\tmmp now = q.front();\n\tq.pop();\n\tif( now == goal1  ){\n\t    cout<<\"Yes\"<<endl;\n\t    f = false;\n\t    break;\n\t}\n\tmp len = now.first;\n\tmp rin = now.second;\n\t//cout<<len.first<<' '<<len.second<<' '<<rin.first<<' '<<rin.second<<endl;\n\tfor(int i=0;i<4;i++){\n\t    mp nlen = mp(len.first + dx[0][i] , len.second + dy[0][i]);\n\t    mp nrin = mp(rin.first + dx[1][i] , rin.second + dy[1][i]);\n\t    if( !( mtl[nlen.first][nlen.second] || mtr[nrin.first][nrin.second] ) )continue;\n\t    if( !mtl[nlen.first][nlen.second] ) nlen = len;\n\t    if( !mtr[nrin.first][nrin.second] ) nrin = rin;\n\t    if( state.find( mmp( nlen ,nrin ) ) != state.end() )continue;\n\t    if( mmp( nlen ,nrin ) != goal1 && (nlen == g[0] || nrin == g[1] ) )continue;\n\t    state.insert( mmp( nlen , nrin ) );\n\t    q.push( mmp( nlen , nrin ) );\n\t}\n    }\n    if( f){\n\tcout<<\"No\"<<endl;\n    }\n    /*for(int i=1;i<=h;i++){\n\tfor(int j=1;j<=w;j++){\n\t    if( mtr[i][j] )cout<<\".\";\n\t    else cout<<\"#\";\n\t}\n\tcout<<endl;\n    }*/\n}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> pii;\nint W, H;\nint dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\n\nvoid rec(pii &p1, pii &p2, map<pair<pii,pii>,bool> &memo, vector<string> &R1, vector<string> &R2){\n  for(int i = 0; i < 4; ++i){\n    //int x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;\n    pii p1_ = p1, p2_ = p2;\n    if(p1_.first + dx[i] < H && p1_.first + dx[i] >= 0 &&\n       p1_.second + dy[i] < W && p1_.second + dy[i] >= 0 &&\n       R1[p1_.first + dx[i]][p1_.second + dy[i]] != '#'){\n      p1_.first += dx[i];\n      p1_.second += dy[i];\n    }\n    if(p2_.first + dx[i] < H && p2_.first + dx[i] >= 0 &&\n       p2_.second - dy[i] < W && p2_.second - dy[i] >= 0 &&\n       R2[p2_.first + dx[i]][p2_.second - dy[i]] != '#'){\n      p2_.first += dx[i];\n      p2_.second -= dy[i];\n    }\n    if(!memo[make_pair(p1_,p2_)]){\n      memo[make_pair(p1_,p2_)] = true;\n      rec(p1_,p2_,memo,R1,R2);\n    }\n  }\n}\n\nint main(){\n  while(cin >> W >> H, W){\n    pii s1, s2, g1, g2;\n    vector<string> R1(H), R2(H);\n    for(int i = 0; i < H; ++i){\n      cin >> R1[i] >> R2[i];\n      for(int j = 0; j < W; ++j){\n        if(R1[i][j] == 'L'){\n          s1.first = i;\n          s1.second = j;\n        }\n        if(R2[i][j] == 'R'){\n          s2.first = i;\n          s2.second = j;\n        }\n        if(R1[i][j] == '%'){\n          g1.first = i;\n          g1.second = j;\n        }\n        if(R2[i][j] == '%'){\n          g2.first = i;\n          g2.second = j;\n        }\n      }\n    }\n    map<pair<pii,pii>,bool> memo;\n    rec(s1,s2,memo,R1,R2);\n    //if(memo[gx1][gy1][gx2][gy2]) cout << \"Yes\" << endl;\n    if(memo[make_pair(g1,g2)]) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nstring R1[50], R2[50];\nbool memo[50][50][50][50];\nint W, H;\nint dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\n\nvoid rec(int x1, int y1, int x2, int y2){\n  for(int i = 0; i < 4; ++i){\n    int x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;\n    if(x1 + dx[i] < H && x1 + dx[i] >= 0 &&\n       y1 + dy[i] < W && y1 + dy[i] >= 0 &&\n       R1[x1 + dx[i]][y1 + dy[i]] != '#'){\n      x1_ += dx[i];\n      y1_ += dy[i];\n    }\n    if(x2 + dx[i] < H && x2 + dx[i] >= 0 &&\n       y2 - dy[i] < W && y2 - dy[i] >= 0 &&\n       R2[x2 + dx[i]][y2 - dy[i]] != '#'){\n      x2_ += dx[i];\n      y2_ -= dy[i];\n    }\n    if(!memo[x1_][y1_][x2_][y2_]){\n      memo[x1_][y1_][x2_][y2_] = true;\n      rec(x1_,y1_,x2_,y2_);\n    }\n  }\n}\n\nint main(){\n  while(cin >> W >> H, W){\n    int sx1, sy1, sx2, sy2, gx1, gx2, gy1, gy2;\n    for(int i = 0; i < H; ++i){\n      cin >> R1[i] >> R2[i];\n      for(int j = 0; j < W; ++j){\n        if(R1[i][j] == 'L'){\n          sx1 = i;\n          sy1 = j;\n        }\n        if(R2[i][j] == 'R'){\n          sx2 = i;\n          sy2 = j;\n        }\n        if(R1[i][j] == '%'){\n          gx1 = i;\n          gy1 = j;\n        }\n        if(R2[i][j] == '%'){\n          gx2 = i;\n          gy2 = j;\n        }\n      }\n    }\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n        for(int k = 0; k < H; ++k){\n          for(int l = 0; l< W; ++l){\n            memo[i][j][k][l] = false;\n          }\n        }\n      }\n    }\n    memo[sx1][sy1][sx2][sy2] = true;\n    rec(sx1,sy1,sx2,sy2);\n    if(memo[gx1][gy1][gx2][gy2]) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <queue>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nP ls, rs, lg, rg;\nint dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0}, h, w;\nbool f[50][50][50][50];\nchar lf[50][51],rf[50][51]; \n\nint range(int a,int b){\n\treturn a >= 0 && a < h && b >= 0 && b < w;\n}\n\nbool bfs(){\n\tint i, lx, ly, rx, ry;\n\tqueue<PP> que;\n\tque.push(PP(P(ls.first,ls.second),P(rs.first,rs.second)));\n\twhile(que.size()){\n\t\tlx = que.front().first.second,ly = que.front().first.first,rx = que.front().second.second, ry = que.front().second.first;\n\t\tque.pop();\n\t\tif(lg.first == ly && lg.second == lx || rg.first == ry && rg.second == rx){\n\t\t\tif(lg.first == ly && lg.second == lx && rg.first == ry && rg.second == rx)\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\t\tfor(i = 0;i < 4;i++){\n\t\t\tif(range(ly + dy[i],lx + dx[i]) && range(ry + dy[i],rx - dx[i])){\n\t\t\t\tif(lf[ly + dy[i]][lx + dx[i]] != '#' && rf[ry + dy[i]][rx - dx[i]] != '#' && f[ly + dy[i]][lx + dx[i]][ry + dy[i]][rx - dx[i]]){\n\t\t\t\t\tf[ly + dy[i]][lx + dx[i]][ry + dy[i]][rx - dx[i]] = 0;\n\t\t\t\t\tque.push(PP(P(ly + dy[i],lx + dx[i]),P(ry + dy[i],rx - dx[i])));\n\t\t\t\t}\n\t\t\t\telse if(lf[ly + dy[i]][lx + dx[i]] != '#' && rf[ry + dy[i]][rx - dx[i]] == '#' && f[ly + dy[i]][lx + dx[i]][ry][rx]){\n\t\t\t\t\tf[ly + dy[i]][lx + dx[i]][ry][rx] = 0;\n\t\t\t\t\tque.push(PP(P(ly + dy[i],lx + dx[i]),P(ry,rx)));\n\t\t\t\t}\n\t\t\t\telse if(lf[ly + dy[i]][lx + dx[i]] == '#' && rf[ry + dy[i]][rx - dx[i]] != '#' && f[ly][lx][ry + dy[i]][rx - dx[i]]){\n\t\t\t\t\tf[ly][lx][ry + dy[i]][rx - dx[i]] = 0;\n\t\t\t\t\tque.push(PP(P(ly,lx),P(ry + dy[i],rx - dx[i])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(void){\n\tint i, j;\n\twhile(1){\n\t\tscanf(\"%d%d%*c\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tlf[i][j] = getchar();\n\t\t\t\tif(lf[i][j] == 'L'){\n\t\t\t\t\tls = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(lf[i][j] == '%'){\n\t\t\t\t\tlg = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 空白読み飛ばし\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\trf[i][j] = getchar();\n\t\t\t\tif(rf[i][j] == 'R'){\n\t\t\t\t\trs = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(rf[i][j] == '%'){\n\t\t\t\t\trg = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 改行文字読み飛ばし\n\t\t}\n\t\tmemset(f,-1,sizeof(f));\n\t\tf[ls.first][ls.second][rs.first][rs.second] = 0;\n\t\tif(bfs())\n\t\t\tprintf(\"Yes\\n\");\n\t\telse\n\t\t\tprintf(\"No\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\n//[int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }; int dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\n/*--------------------template--------------------*/\nint n;\nint hs(int x, int y) { return x*n + y; }\nint main()\n{\n\tint w, h;\n\twhile (cin >> w >> h, w)\n\t{\n\t\tvs fldl(h), fldr(h);\n\t\tREP(i, h) cin >> fldl[i] >> fldr[i];\n\t\tn = w*h;\n\t\tint rx, ry, lx, ly;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fldl[i][j] == 'L')\n\t\t\t{\n\t\t\t\tfldl[i][j] = '.';\n\t\t\t\tlx = i, ly = j;\n\t\t\t}\n\t\t\tif (fldr[i][j] == 'R')\n\t\t\t{\n\t\t\t\tfldr[i][j] = '.';\n\t\t\t\trx = i, ry = j;\n\t\t\t}\n\t\t}\n\t\tset<int> st;\n\t\tqueue<int> que;\n\t\tst.insert(hs(place(lx, ly, w), place(rx, ry, w)));\n\t\tque.push(hs(place(lx, ly, w), place(rx, ry, w)));\n\t\tbool ans = false;\n\t\twhile (que.size())\n\t\t{\n\t\t\tint tmp = que.front();\n\t\t\tque.pop();\n\t\t\tint tl = tmp / n, tr = tmp%n;\n\t\t\tint lx = tl / w, ly = tl%w;\n\t\t\tint rx = tr / w, ry = tr%w;\n\t\t\tif (fldl[lx][ly] == '%'&&fldr[rx][ry] == '%')\n\t\t\t{\n\t\t\t\tans = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tREP(i, 4)\n\t\t\t{\n\t\t\t\tint lnx, lny, rnx, rny;\n\t\t\t\tif (valid(lx + dx[i], ly + dy[i], h, w) && fldl[lx + dx[i]][ly + dy[i]] != '#')\n\t\t\t\t{\n\t\t\t\t\tlnx = lx + dx[i], lny = ly + dy[i];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlnx = lx, lny = ly;\n\t\t\t\t}\n\t\t\t\tif (valid(rx + dx[i], ry - dy[i], h, w) && fldr[rx + dx[i]][ry - dy[i]] != '#')\n\t\t\t\t{\n\t\t\t\t\trnx = rx + dx[i], rny = ry - dy[i];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\trnx = rx, rny = ry;\n\t\t\t\t}\n\t\t\t\tint next = hs(place(lnx, lny, w), place(rnx, rny, w));\n\t\t\t\tif (st.find(next) == st.end())\n\t\t\t\t{\n\t\t\t\t\tst.insert(next);\n\t\t\t\t\tque.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(ans ? \"Yes\" : \"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nconst int kMax_N = 51;\nchar fieldL[kMax_N + 1][kMax_N + 1];\nchar fieldR[kMax_N + 1][kMax_N + 1];\nbool checked[kMax_N + 1][kMax_N + 1][kMax_N + 1][kMax_N + 1];\n\n\nconst int dyL[] = { -1, 0, 1, 0 };\nconst int dxL[] = { 0, 1, 0, -1 };\nconst int dyR[] = { -1, 0, 1, 0 };\nconst int dxR[] = { 0, -1, 0, 1 };\n\nint w, h;\n\n\nstruct Search {\n  int ly, lx;\n  int ry, rx;\n  Search() = default;\n  Search(int a, int b, int c, int d):\n    ly(a), lx(b), ry(c), rx(d) { }\n};\nint main() {\n  while (true) {\n    cin >> w >> h;\n    if (w + h == 0) {\n      break;\n    }\n    int ly, lx, ry, rx;\n    for (int i = 0; i < h; i++) {\n      string strL, strR;\n      cin >> strL >> strR;\n      for (int j = 0; j < w; j++) {\n        fieldL[i][j] = strL[j];\n        fieldR[i][j] = strR[j];\n        if (strL[j] == 'L') {\n          ly = i; lx = j;\n        }\n        if (strR[j] == 'R') {\n          ry = i; rx = j;\n        }\n      }\n    }\n\n    memset(checked, false, sizeof(checked));\n\n    queue<Search> que;\n    que.emplace(ly, lx, ry, rx);\n    bool ok = false;\n    while (!que.empty()) {\n      Search s = que.front(); que.pop();\n      if (fieldL[s.ly][s.lx] == fieldR[s.ry][s.rx] && fieldL[s.ly][s.lx] == '%') {\n        ok = true;\n        break;\n      }\n      if (fieldL[s.ly][s.lx] == '%') {\n        continue;\n      }\n      if (fieldR[s.ry][s.rx] == '%') {\n        continue;\n      }\n      if (checked[s.ly][s.lx][s.ry][s.rx]) {\n        continue;\n      }\n      checked[s.ly][s.lx][s.ry][s.rx] = true;\n      for (int i = 0; i < 4; i++) {\n        int nly = s.ly + dyL[i];\n        int nlx = s.lx + dxL[i];\n        int nry = s.ry + dyR[i];\n        int nrx = s.rx + dxR[i];\n        if (nly < 0) nly = 0;\n        if (nly >= h) nly = h - 1;\n        if (nlx < 0) nlx = 0;\n        if (nlx >= w) nlx = w - 1;\n        if (nry < 0) nry = 0;\n        if (nry >= h) nry = h - 1;\n        if (nrx < 0) nrx = 0;\n        if (nrx >= w) nrx = w - 1;\n        if (fieldL[nly][nlx] == '#') {\n          nly = s.ly; nlx = s.lx;\n        }\n        if (fieldR[nry][nrx] == '#') {\n          nry = s.ry; nrx = s.rx;\n        }\n        que.emplace(nly, nlx, nry, nrx);\n      }\n    }\n    if (ok) {\n      cout << \"Yes\" << endl;\n    } else {\n      cout << \"No\" << endl;\n    }\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <set>\n#include <queue>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\tint dl[50][50][50][50], h, w, i, j, a, b, c, d, dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\n\tchar rf[50][51], lf[50][51];\n\tP rs, ls, rg, lg;\n\tqueue<P> r, l;\n\twhile(1){\n\t\tscanf(\"%d%d%*c\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tlf[i][j] = getchar();\n\t\t\t\tif(lf[i][j] == 'L'){\n\t\t\t\t\tls = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(lf[i][j] == '%'){\n\t\t\t\t\tlg = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 空白読み飛ばし\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\trf[i][j] = getchar();\n\t\t\t\tif(rf[i][j] == 'R'){\n\t\t\t\t\trs = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(rf[i][j] == '%'){\n\t\t\t\t\trg = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 改行文字読み飛ばし\n\t\t}\n\t\tr.push(rs), l.push(ls);\n\t\tmemset(dl,0,sizeof(dl));\n\t\twhile(r.size()){\n\t\t\ta = l.front().first, b = l.front().second, c = r.front().first, d = r.front().second;\n\t\t\tl.pop(), r.pop();\n\t\t\tdl[a][b][c][d] = 1;\n\t\t\tif(a == lg.first && b == lg.second && c == rg.first && d == rg.second)\n\t\t\t\tbreak;\n\t\t\tif(a == lg.first && b == lg.second || c == rg.first && d == rg.second)\n\t\t\t\tcontinue;\n\t\t\tfor(i = 0;i < 4;i++){\n\t\t\t\tif(a + dy[i] >= 0 && a + dy[i] < h && b + dx[i] >= 0 && b + dx[i] < w && lf[a + dy[i]][b + dx[i]] == '.' && c + dy[i] >= 0 && c + dy[i] < h && d - dx[i] >= 0 && d - dx[i] < w && rf[c + dy[i]][d - dx[i]] == '.' && !dl[a + dy[i]][b + dx[i]][c + dy[i]][d - dx[i]]) // 両方とも動くとき\n\t\t\t\t\tl.push(P(a + dy[i],b + dx[i])), r.push(P(c + dy[i],d - dx[i]));\n\t\t\t\telse if(a + dy[i] >= 0 && a + dy[i] < h && b + dx[i] >= 0 && b + dx[i] < w && lf[a + dy[i]][b + dx[i]] == '#' && c + dy[i] >= 0 && c + dy[i] < h && d - dx[i] >= 0 && d - dx[i] < w && rf[c + dy[i]][d - dx[i]] == '.' && !dl[a][b][c + dy[i]][d - dx[i]]) // Rinだけ動く\n\t\t\t\t\tl.push(P(a,b)), r.push(P(c + dy[i],d - dx[i]));\n\t\t\t\telse if(a + dy[i] >= 0 && a + dy[i] < h && b + dx[i] >= 0 && b + dx[i] < w && lf[a + dy[i]][b + dx[i]] == '.' && c + dy[i] >= 0 && c + dy[i] < h && d - dx[i] >= 0 && d - dx[i] < w && rf[c + dy[i]][d - dx[i]] == '#' && !dl[a + dy[i]][b + dx[i]][c][d]) // Lenだけ動く\n\t\t\t\t\tl.push(P(a + dy[i],b + dx[i])), r.push(P(c,d));\n\t\t\t}\n\t\t}\n\t\twhile(r.size())\n\t\t\tr.pop(),l.pop();\n\t\tif(dl[lg.first][lg.second][rg.first][rg.second])\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\nstruct po{int lx,ly,rx,ry;};\nint w,h;\nstring mp[2][51];\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\n\nbool bfs(int lx,int ly,int rx,int ry){\n  bool visited[50][50][50][50]={};\n  queue <po> Q;\n  Q.push((po){lx,ly,rx,ry});\n  while(!Q.empty()){\n    po t=Q.front();Q.pop();\n    lx=t.lx, ly=t.ly;\n    rx=t.rx, ry=t.ry;\n    if(visited[lx][ly][rx][ry])continue;\n    int cnt=(mp[0][ly][lx]=='%')+(mp[1][ry][rx]=='%');\n    if(cnt==2)return true;\n    if(cnt)continue;\n    visited[lx][ly][rx][ry]=1;\n    for(int i=0;i<4;i++){\n      int flg=0;\n      int nlx=lx+dx[i],nly=ly+dy[i];\n      int nrx=rx-dx[i],nry=ry+dy[i];\n      if(nlx<0||nly<0||nlx>=w||nly>=h||mp[0][nly][nlx]=='#')nlx=lx,nly=ly,flg++;\n      if(nrx<0||nry<0||nrx>=w||nry>=h||mp[1][nry][nrx]=='#')nrx=rx,nry=ry,flg++;\n      if(flg==2||visited[nlx][nly][nrx][nry])continue;\n      Q.push((po){nlx,nly,nrx,nry});\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(1){\n    cin >>w>>h;\n    if(!w&&!h)break;\n    for(int i=0;i<h;i++)cin>>mp[0][i]>>mp[1][i];\n    int lx,ly,rx,ry;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(mp[0][i][j]=='L')lx=j,ly=i;\n\tif(mp[1][i][j]=='R')rx=j,ry=i;\n      }\n\n    if(bfs(lx,ly,rx,ry))cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//50\n#include<iostream>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nchar g[2][50][50];\nbool p[50][50][50][50];\nint w,h;\n\nstruct S{\n  int x[2],y[2];\n};\n\nint main(){\n  while(cin>>w>>h,w|h){\n    int px[2],py[2];\n    for(int y=0;y<h;y++){\n      for(int i=0;i<2;i++){\n\tfor(int x=0;x<w;x++){\n\t  cin>>g[i][y][x];\n\t  if(g[i][y][x]=='R'||g[i][y][x]=='L'){\n\t    px[i]=x;\n\t    py[i]=y;\n\t  }\n\t}\n      }\n    }\n    fill(p[0][0][0],p[50][0][0],false);\n    queue<S> que;\n    S is={{px[0],px[1]},{py[0],py[1]}};\n    que.push(is);\n    while(!que.empty()){\n      S c=que.front();\n      int x=c.x[0],y=c.y[0],xx=c.x[1],yy=c.y[1];\n      if(g[0][y][x]=='%'&&g[1][yy][xx]=='%')break;\n      que.pop();\n      if(p[x][y][xx][yy]++||(g[0][y][x]=='%'^g[1][yy][xx]=='%'))continue;\n      for(int i=0;i<4;i++){\n\tint dy[]={0,1,0,-1};\n\tint dx[][4]={{1,0,-1,0},{-1,0,1,0}};\n\tint nx[2],ny[2];\n\tnx[0]=x+dx[0][i];\n\tny[0]=y+dy[i];\n\tnx[1]=xx+dx[1][i];\n\tny[1]=yy+dy[i];\n\tfor(int j=0;j<2;j++){\n\t  if(nx[j]<0||w<=nx[j]||ny[j]<0||h<=ny[j]||g[j][ny[j]][nx[j]]=='#'){\n\t    nx[j]-=dx[j][i];\n\t    ny[j]-=dy[i];\n\t  }\n\t}\n\tS n={{nx[0],nx[1]},{ny[0],ny[1]}};\n\tque.push(n);\n      }\n    }\n    cout<<(!que.empty()?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#define N 52\n#define y1 first.first\n#define x1 first.second\n#define y2 second.first\n#define x2 second.second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\n\nvoid bfs();\n\nint w,h,sy1,sx1,sy2,sx2,gy1,gx1,gy2,gx2,ans;\nstring r1[N],r2[N];\nbool visited[N][N][N][N];\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(!w&&!h) break;\n    for(int i=0;i<h;i++) cin>>r1[i]>>r2[i];\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tfor(int k=0;k<h;k++)\n\t  for(int l=0;l<h;l++) visited[i][j][k][l]=false;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(r1[i][j]=='L') sy1=i,sx1=j;\n\tif(r1[i][j]=='%') gy1=i,gx1=j;\n\tif(r2[i][j]=='R') sy2=i,sx2=j;\n\tif(r2[i][j]=='%') gy2=i,gx2=j;\n      }\n    ans=0;\n    bfs();\n    if(ans) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n  return 0;\n}\n\nvoid bfs(){\n  int dy[4]={0,-1,0,1},dx[4]={-1,0,1,0};\n  queue<P1> q;\n  P1 k=make_pair(P(sy1,sx1),P(sy2,sx2));\n  q.push(k);\n  visited[sy1][sx1][sy2][sx2]=true;\n  while(!q.empty()){\n    P1 t=q.front(); q.pop();\n    for(int i=0;i<4;i++){\n      int ny1=t.y1+dy[i],nx1=t.x1+dx[i];\n      int ny2=t.y2+dy[i],nx2=t.x2-dx[i];\n      if(ny1<0) ny1=0;\n      if(nx1<0) nx1=0;\n      if(h<=ny1) ny1=h-1;\n      if(w<=nx1) nx1=w-1;\n      if(ny2<0) ny2=0;\n      if(nx2<0) nx2=0;\n      if(h<=ny2) ny2=h-1;\n      if(w<=nx2) nx2=w-1;\n      if(r1[ny1][nx1]=='#') ny1=t.y1,nx1=t.x1;\n      if(r2[ny2][nx2]=='#') ny2=t.y2,nx2=t.x2;\n      P1 u=make_pair(P(ny1,nx1),P(ny2,nx2));\n      if(visited[ny1][nx1][ny2][nx2]) continue;\n      visited[ny1][nx1][ny2][nx2]=true;\n      q.push(u);\n      if(ny1==gy1&&nx1==gx1&&ny2==gy2&&nx2==gx2){\n\tans=1;\n\treturn ;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n#define IN(x, w) 0 <= (x) && (x) <(w) \n\n#define X first\n#define Y second\n#define R first\n#define L second\n\ntypedef pair<pii, pii> State;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint dx[] = { 1, 0,-1, 0};\nint dy[] = { 0, 1, 0,-1};\n\nbool used[51][51][51][51] = { false };\n\nint main(void){\n    string res;\n    for(int w, h; cin >> w >> h, w; cout << res << endl){\n        res = \"No\";\n        pair<vs, vs> cave = mp(vs(h), vs(h));\n\n        State s;\n        rep(y, h){\n            cin >> cave.L[y];\n            cin >> cave.R[y];\n            rep(x, w){\n                if(cave.L[y][x] == 'L') s.L = mp(x, y), cave.L[y][x] = '.';\n                if(cave.R[y][x] == 'R') s.R = mp(x, y), cave.R[y][x] = '.';\n            }\n        }\n        \n        rep(i, 51)rep(j, 51)rep(k, 51)rep(l, 51) used[i][j][k][l] = false;\n\n        queue<State> q;\n        q.push(s);\n\n        while(!q.empty()){\n            State cur = q.front(); q.pop();\n\n            if(cave.L[cur.L.Y][cur.L.X] == '%' || cave.R[cur.R.Y][cur.R.X] == '%'){\n                if(cave.L[cur.L.Y][cur.L.X] == '%' && cave.R[cur.R.Y][cur.R.X] == '%'){\n                    res = \"Yes\";\n                    break;\n                }\n                continue;\n            }\n\n            rep(i, 4){\n                State next = cur;\n\n                if(IN(next.L.X + dx[i], w) && cave.L[next.L.Y][next.L.X + dx[i]] != '#') next.L.X += dx[i];\n                if(IN(next.L.Y + dy[i], h) && cave.L[next.L.Y + dy[i]][next.L.X] != '#') next.L.Y += dy[i];\n                if(IN(next.R.X - dx[i], w) && cave.R[next.R.Y][next.R.X - dx[i]] != '#') next.R.X -= dx[i];\n                if(IN(next.R.Y + dy[i], h) && cave.R[next.R.Y + dy[i]][next.R.X] != '#') next.R.Y += dy[i];\n\n                if(!used[next.L.X][next.L.Y][next.R.X][next.R.Y]){\n                    q.push(next);\n                    used[next.L.X][next.L.Y][next.R.X][next.R.Y] = true;\n                }\n            }\n        }\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint H,W;\nint**** min_Count;\nint diff_row[4]= {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nstruct Info{\n\tInfo(int arg_L_row,int arg_L_col,int arg_R_row,int arg_R_col,int arg_count){\n\t\tL_row = arg_L_row;\n\t\tL_col = arg_L_col;\n\t\tR_row = arg_R_row;\n\t\tR_col = arg_R_col;\n\t\tcount = arg_count;\n\t}\n\tint L_row,L_col,R_row,R_col,count;\n};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int a = 0; a < H; a++){\n\t\tfor(int b = 0; b < W; b++){\n\t\t\tfor(int c = 0; c < H; c++){\n\t\t\t\tfor(int d = 0; d < W; d++)min_Count[a][b][c][d] = BIG_NUM;\n\t\t\t}\n\t\t}\n\t}\n\n\tchar L_map[H][W+1],R_map[H][W+1];\n\n\tint L_start_row,L_start_col,R_start_row,R_start_col;\n\n\tfor(int i = 0; i < H; i++){\n\t\tscanf(\"%s %s\",L_map[i],R_map[i]);\n\t\tfor(int k = 0; k < W; k++){\n\t\t\tif(L_map[i][k] == 'L'){\n\t\t\t\tL_start_row = i;\n\t\t\t\tL_start_col = k;\n\t\t\t\tL_map[i][k] = '.';\n\t\t\t}\n\t\t\tif(R_map[i][k] == 'R'){\n\t\t\t\tR_start_row = i;\n\t\t\t\tR_start_col = k;\n\t\t\t\tR_map[i][k] = '.';\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<Info> Q;\n\tQ.push(Info(L_start_row,L_start_col,R_start_row,R_start_col,0));\n\tmin_Count[L_start_row][L_start_col][R_start_row][R_start_col] = 0;\n\n\tbool FLG = false;\n\n\tint next_L_row,next_L_col,next_R_row,next_R_col;\n\n\twhile(!Q.empty()){\n\n\t\tif(L_map[Q.front().L_row][Q.front().L_col] == '%' && R_map[Q.front().R_row][Q.front().R_col] == '%'){\n\t\t\tFLG = true;\n\t\t\tbreak;\n\t\t}else if(Q.front().count > min_Count[Q.front().L_row][Q.front().L_col][Q.front().R_row][Q.front().R_col]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tnext_L_row = Q.front().L_row + diff_row[i];\n\t\t\t\tnext_L_col = Q.front().L_col + diff_col[i];\n\t\t\t\tnext_R_row = Q.front().R_row + diff_row[i];\n\t\t\t\tnext_R_col = Q.front().R_col - diff_col[i];\n\n\t\t\t\tif(rangeCheck(next_L_row,next_L_col) == false || L_map[next_L_row][next_L_col] == '#'){\n\t\t\t\t\tnext_L_row = Q.front().L_row;\n\t\t\t\t\tnext_L_col = Q.front().L_col;\n\t\t\t\t}\n\t\t\t\tif(rangeCheck(next_R_row,next_R_col) == false || R_map[next_R_row][next_R_col] == '#'){\n\t\t\t\t\tnext_R_row = Q.front().R_row;\n\t\t\t\t\tnext_R_col = Q.front().R_col;\n\t\t\t\t}\n\n\t\t\t\tif(min_Count[next_L_row][next_L_col][next_R_row][next_R_col] > Q.front().count+1){\n\t\t\t\t\tif((L_map[next_L_row][next_L_col] == '%' && R_map[next_R_row][next_R_col] != '%') ||\n\t\t\t\t\t\t\t(L_map[next_L_row][next_L_col] != '%' && R_map[next_R_row][next_R_col] == '%')){\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmin_Count[next_L_row][next_L_col][next_R_row][next_R_col] = Q.front().count+1;\n\t\t\t\t\t\tQ.push(Info(next_L_row,next_L_col,next_R_row,next_R_col,Q.front().count+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tif(FLG){\n\t\tprintf(\"Yes\\n\");\n\t}else{\n\t\tprintf(\"No\\n\");\n\t}\n}\n\nint main(){\n\n\tmin_Count = new int***[50];;\n\tfor(int i = 0; i < 50; i++){\n\t\tmin_Count[i] = new int**[50];\n\t\tfor(int k = 0; k < 50; k++){\n\t\t\tmin_Count[i][k] = new int*[50];\n\t\t\tfor(int a = 0; a < 50; a++){\n\t\t\t\tmin_Count[i][k][a] = new int[50];\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// テ・ツ淞コテヲツ慊ャテ」ツδ?」ツδウテ」ツδ療」ツδャテ」ツδシテ」ツδ?\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[2][4] = { {0, 0, 1, -1}, {0, 0, 1, -1} };\nint dy[2][4] = { {1, -1, 0, 0}, {-1, 1, 0, 0} };\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nconst int S = 51;\n// ax, ay, bx, by\nbool visited[S][S][S][S];\nint W, H;\n\nstruct Elem {\n    int ax, ay, bx, by;\n};\n\npii search_p(vector<string> &vs, char target) {\n    rep(i,0,H) rep(j,0,W) {\n        if(vs[i][j] == target) return make_pair(i, j);\n    }\n}\n\nvoid move_p(vector<string> &vs, int &x, int &y, int dir, int mode) {\n    int nx = x + dx[mode][dir];\n    int ny = y + dy[mode][dir];\n    if(nx < 0 || nx >= H || ny < 0 || ny >= W) return;\n    if(vs[nx][ny] == '#') return;\n    x = nx;\n    y = ny;\n}\n\nsigned main() {\n    while(cin >> W >> H, W || H) {\n        memset(visited, false, sizeof(visited));\n\n        vector<string> lboard(H), rboard(H);\n        rep(i,0,H) cin >> lboard[i] >> rboard[i];\n        pii init_a = search_p(lboard, 'L');\n        pii init_b = search_p(rboard, 'R');\n        int a = init_a.first, b = init_a.second;\n        int x = init_b.first, y = init_b.second;\n\n        queue<Elem> que;\n        que.push(Elem{a, b, x, y});\n        visited[a][b][x][y] = true;\n        while(!que.empty()) {\n            Elem cur = que.front(); que.pop();\n            rep(k,0,4) {\n                Elem nxt = cur;\n                move_p(lboard, nxt.ax, nxt.ay, k, 0);\n                move_p(rboard, nxt.bx, nxt.by, k, 1);\n                if(visited[nxt.ax][nxt.ay][nxt.bx][nxt.by]) continue;\n                visited[nxt.ax][nxt.ay][nxt.bx][nxt.by] = true;\n                que.push(nxt);\n            }\n        }\n\n        pii goal_a = search_p(lboard, '%');\n        pii goal_b = search_p(rboard, '%');\n        a = goal_a.first, b = goal_a.second;\n        x = goal_b.first, y = goal_b.second;\n        if(!visited[a][b][x][y]) cout << \"No\" << endl;\n        else cout << \"Yes\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<pair<int, int>, pair<int, int>> PPIIII;\n\nint dx[] = { 1,0,-1,0 };\nint dy[] = { 0,1,0,-1 };\n\nvoid solve( int W, int H ) {\n\tpair<int, int> startR, startL, goalR, goalL;\n\tvector<vector<vector<vector<bool>>>>dp( H + 2, vector<vector<vector<bool>>>( W + 2, vector<vector<bool>>( H + 2, vector<bool>( W + 2, 0 ) ) ) );\n\tvector<vector<vector<char>>>mapd( 2, vector<vector<char>>( H + 2, vector<char>( W + 2, '#' ) ) );\n\tfor( size_t i = 1; i <= H; i++ ) {\n\t\tfor( size_t j = 1; j <= W; j++ ) {\n\t\t\tcin >> mapd[0][i][j];\n\t\t\tif( mapd[0][i][j] == 'L' ) {\n\t\t\t\tstartL = make_pair( i, j );\n\t\t\t} else if( mapd[0][i][j] == '%' ) {\n\t\t\t\tgoalL = make_pair( i, j );\n\t\t\t}\n\t\t}\n\t\tfor( int j = W; j >= 1; j-- ) {\n\t\t\tcin >> mapd[1][i][j];\n\t\t\tif( mapd[1][i][j] == 'R' ) {\n\t\t\t\tstartR = make_pair( i, j );\n\t\t\t} else if( mapd[1][i][j] == '%' ) {\n\t\t\t\tgoalR = make_pair( i, j );\n\t\t\t}\n\t\t}\n\t}\n\tdp[startL.first][startL.second][startR.first][startR.second] = 1;\n\n\n\tqueue<PPIIII>que;\n\tque.push( make_pair( startL, startR ) );\n\twhile( que.size() ) {\n\t\tauto now = que.front(); que.pop();\n\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\tauto next = now;\n\t\t\tnext.first.first += dx[i];\n\t\t\tnext.first.second += dy[i];\n\t\t\tnext.second.first += dx[i];\n\t\t\tnext.second.second += dy[i];\n\t\t\tif( mapd[0][next.first.first][next.first.second] == '#' ) {\n\t\t\t\tnext.first = now.first;\n\t\t\t}\n\t\t\tif( mapd[1][next.second.first][next.second.second] == '#' ) {\n\t\t\t\tnext.second = now.second;\n\t\t\t}\n\n\t\t\tif( 0 < next.first.first&&next.first.first < H + 2 &&\n\t\t\t\t0 < next.first.second&&next.first.second < W + 2 &&\n\t\t\t\t0 < next.second.first&&next.second.first < H + 2 &&\n\t\t\t\t0 < next.second.second&&next.second.second < W + 2 ) {\n\t\t\t\tif( dp[next.first.first][next.first.second][next.second.first][next.second.second] == 0 ) {\n\t\t\t\t\tif( goalL == next.first&&goalR == next.second &&dx[i] != 0 && dy[0] != 0 ) {\n\t\t\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif( !(goalL == next.first&&goalR == next.second) ) {\n\t\t\t\t\t\tdp[next.first.first][next.first.second][next.second.first][next.second.second] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tque.push( next );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"No\" << endl;\n\treturn;\n}\n\nint main() {\n\tint W, H;\n\twhile( cin >> W >> H, W&&H ) {\n\t\tsolve( W, H );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// C++11\n#include \"bits/stdc++.h\"\n#include <sys/time.h>\n#include <emmintrin.h>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <random>\n#include <bitset>\n\nusing namespace std;\n\ninline long long GetTSC() {\n  long long lo, hi;\n  asm volatile (\"rdtsc\": \"=a\"(lo), \"=d\"(hi));\n  return lo + (hi << 32);\n}\ninline double GetSeconds() {\n  return GetTSC() / 2.8e9;\n}\n\nconst long inf = pow(10,15);\nint di[] = {-1,0,1,0};\nint dj[] = {0,1,0,-1};\ntuple<int, int>q[50*50*50*50];\n\nvoid solve(){\n  double starttime = GetSeconds();\n  while(1){\n    int w,h;\n    cin >> w >> h;\n    // cerr << w << \", \" << h << endl;\n    if(w==0 && h==0) break;\n    int lp,ls,rp,rs;\n    bool lb[2500] = {};\n    bool rb[2500] = {};\n    bool f[2500][2500] = {};\n    for(int i=0; i<h; i++){\n      string s;\n      cin >> s;\n      for(int j=0; j<w; j++){\n        if(s[j]=='#') lb[i*w+j] = 1;\n        if(s[j]=='%') lp = i*w+j;\n        if(s[j]=='L') ls = i*w+j;\n      }\n      cin >> s;\n      for(int j=0; j<w; j++){\n        if(s[j]=='#') rb[i*w+j] = 1;\n        if(s[j]=='%') rp = i*w+j;\n        if(s[j]=='R') rs = i*w+j;\n      }\n    }\n    f[ls][rs] = 1;\n    int qi = 0;\n    int qe = 1;\n    q[0] = make_tuple(ls,rs);\n    bool ff = 0;\n    while(qi<qe){\n      int lt = get<0>(q[qi]);\n      int rt = get<1>(q[qi]);\n      int li = lt / w;\n      int lj = lt % w;\n      int ri = rt / w;\n      int rj = rt % w;\n      qi++;\n      // cerr << \"qie: \" << qi << \", \" << qe << \", lij: \" << li << \", \" << lj << \", rij: \" << ri << \", \" << rj << endl;\n      for(int i=0; i<4; i++){\n        int nli = li + di[i];\n        int nlj = lj + dj[i];\n        int nri = ri + di[i];\n        int nrj = rj - dj[i];\n        if(nli < 0 || nli >= h || nlj < 0 || nlj >= w || lb[nli*w+nlj]){\n          nli = li;\n          nlj = lj;\n        }\n        if(nri < 0 || nri >= h || nrj < 0 || nrj >= w || rb[nri*w+nrj]){\n          nri = ri;\n          nrj = rj;\n        }\n        int nlt = nli*w+nlj;\n        int nrt = nri*w+nrj;\n        if(nlt == lp && nrt == rp){\n          ff = 1;\n          break;\n        }\n        if(nlt == lp || nrt == rp) continue;\n        if(f[nlt][nrt]) continue;\n        f[nlt][nrt] = 1;\n        q[qe++] = make_tuple(nlt,nrt);\n      }\n      if(ff) break;\n    }\n    if(ff){\n      cout << \"Yes\" << endl;\n    }else{\n      cout << \"No\" << endl;\n    }\n  }\n  cerr << \"time: \" << GetSeconds() - starttime << endl;\n\n  return;\n}\n\nint main() {\n  solve();\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct P{\n\tint x;\n\tint y;\n};\n\nstruct St{\n\tP ln;\n\tP rn;\n};\n\nint xdir[4] = {0, 1, 0, -1}, ydir[4] = {1, 0, -1, 0};\n\nbool bfs(char la[51][51], char ra[51][51], int w, int h, P len, P rin)\n{\n\tbool f = false, vis[51][51][51][51];\n\tfill(&vis[0][0][0][0], &vis[50][50][50][50], true);\n\tSt s, t;\n\tP l, r, u, v;\n\tqueue<St> que;\n\ts.ln = len;\n\ts.rn = rin;\n\tque.push(s);\n\tvis[len.y][len.x][rin.y][rin.x] = false;\n\twhile(!que.empty()){\n\t\ts = que.front();\n\t\tque.pop();\n\t\tl = s.ln;\n\t\tr = s.rn;\n\t\tif(la[l.y][l.x] == '%' && ra[r.y][r.x] == '%'){\n\t\t\tf = true;\n\t\t\tbreak;\n\t\t}\n\t\tif(la[l.y][l.x] == '%' || ra[r.y][r.x] == '%'){\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tu.y = l.y+ydir[i];\n\t\t\tu.x = l.x+xdir[i];\n\t\t\tv.y = r.y+ydir[i];\n\t\t\tv.x = r.x-xdir[i];\n\t\t\tif(u.y < 0 || u.y >= h || u.x < 0 || u.x >= w){\n\t\t\t\tu.y = l.y;\n\t\t\t\tu.x = l.x;\n\t\t\t}\n\t\t\tif(la[u.y][u.x] == '#'){\n\t\t\t\tu.y = l.y;\n\t\t\t\tu.x = l.x;\n\t\t\t}\n\t\t\tif(v.y < 0 || v.y >= h || v.x < 0 || v.x >= w){\n\t\t\t\tv.y = r.y;\n\t\t\t\tv.x = r.x;\n\t\t\t}\n\t\t\tif(ra[v.y][v.x] == '#'){\n\t\t\t\tv.y = r.y;\n\t\t\t\tv.x = r.x;\n\t\t\t}\n\t\t\tif(vis[u.y][u.x][v.y][v.x]){\n\t\t\t\tvis[u.y][u.x][v.y][v.x] = false;\n\t\t\t\tt.ln = u;\n\t\t\t\tt.rn = v;\n\t\t\t\tque.push(t);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn f;\n}\n\nint main()\n{\n\tint w, h;\n\tchar ra[51][51], la[51][51];\n\tP rin, len;\n\t\n\twhile(cin>>w>>h && (w+h)){\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> la[i][j];\n\t\t\t\tif(la[i][j] == 'L'){\n\t\t\t\t\tlen.y = i;\n\t\t\t\t\tlen.x = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin >> ra[i][j];\n\t\t\t\tif(ra[i][j] == 'R'){\n\t\t\t\t\trin.y = i;\n\t\t\t\t\trin.x = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(bfs(la, ra, w, h, len, rin)){\n\t\t\tcout << \"Yes\"<< endl;\n\t\t} else {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\nvoid dfs(vector<int> x, vector<int> y, vector<int>& xt, vector<int>& yt, vector< vector<string> >& a, vector< vector<bool> >& vis) {\n\tvector<int> z(2);\n\tfor (int k = 0; k < 2; k++)\n\t\tz[k] = y[k] * 100 + x[k];\n\tvis[z[0]][z[1]] = true;\n\tif (x[0] == xt[0] && y[0] == yt[0]) return;\n\tif (x[1] == xt[1] && y[1] == yt[1]) return;\n\tfor (int i = 0; i < 4; i++) {\n\t\tvector<int> _x = x, _y = y, _z(2);\n\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t_x[k] += (k ? dx[i] : -dx[i]);\n\t\t\t_y[k] += dy[i];\n\t\t\tif (a[k][_y[k]][_x[k]] == '#') {\n\t\t\t\t_x[k] = x[k]; _y[k] = y[k];\n\t\t\t}\n\t\t\t_z[k] = _y[k] * 100 + _x[k];\n\t\t}\n\t\tif (!vis[_z[0]][_z[1]]) dfs(_x, _y, xt, yt, a, vis);\n\t}\n}\n\nint main() {\n\tfor (;;) {\n\t\tint W, H; cin >> W >> H;\n\t\tif (W == 0 && H == 0) break;\n\t\tvector< vector<string> > a(2, vector<string>(H + 2, string(W + 2, '#')));\n\t\tfor (int y = 1; y <= H; y++) {\n\t\t\tstring s1, s2; cin >> s1 >> s2;\n\t\t\ta[0][y] = '#' + s1 + '#';\n\t\t\ta[1][y] = '#' + s2 + '#';\n\t\t}\n\t\tvector<int> xs(2), ys(2), xt(2), yt(2);\n\t\tfor (int k = 0; k < 2; k++)\n\t\t\tfor (int y = 1; y <= H; y++)\n\t\t\t\tfor (int x = 1; x <= W; x++){\n\t\t\t\t\tchar& c = a[k][y][x];\n\t\t\t\t\tif (c == 'L' || c == 'R') {\n\t\t\t\t\t\tc = '.';\n\t\t\t\t\t\txs[k] = x; ys[k] = y;\n\t\t\t\t\t}\n\t\t\t\t\telse if (c == '%') {\n\t\t\t\t\t\tc = '.';\n\t\t\t\t\t\txt[k] = x; yt[k] = y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tvector< vector<bool> > vis(6000, vector<bool>(6000));\n\t\tstack< vector<int> > stx, sty;\n\t\twhile (!stx.empty()) {\n\t\t\tvector<int> x = stx.top(); stx.pop();\n\t\t\tvector<int> y = sty.top(); sty.pop();\n\t\t\tvector<int> z(2);\n\t\t\tfor (int k = 0; k < 2; k++)\n\t\t\t\tz[k] = y[k] * 100 + x[k];\n\t\t\tvis[z[0]][z[1]] = true;\n\t\t\tif (x[0] == xt[0] && y[0] == yt[0]) continue;\n\t\t\tif (x[1] == xt[1] && y[1] == yt[1]) continue;\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tvector<int> _x = x, _y = y, _z(2);\n\t\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\t\t_x[k] += (k ? dx[i] : -dx[i]);\n\t\t\t\t\t_y[k] += dy[i];\n\t\t\t\t\tif (a[k][_y[k]][_x[k]] == '#') {\n\t\t\t\t\t\t_x[k] = x[k]; _y[k] = y[k];\n\t\t\t\t\t}\n\t\t\t\t\t_z[k] = _y[k] * 100 + _x[k];\n\t\t\t\t}\n\t\t\t\tif (!vis[_z[0]][_z[1]]) {\n\t\t\t\t\tvis[_z[0]][_z[1]] = true;\n\t\t\t\t\tstx.push(_x);\n\t\t\t\t\tsty.push(_y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(xs, ys, xt, yt, a, vis);\n\t\tvector<int> zt(2);\n\t\tfor (int k = 0; k < 2; k++)\n\t\t\tzt[k] = yt[k] * 100 + xt[k];\n\t\tcout << (vis[zt[0]][zt[1]] ? \"Yes\" : \"No\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#define N 50\nusing namespace std;\n\nvoid bfs();\n\ntypedef struct dat{\n  int y1,x1,y2,x2;\n} d;\n\nint w,h,sy1,sx1,sy2,sx2,gy1,gx1,gy2,gx2,ans;\nstring r1[N],r2[N];\nset<d> visited;\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(!w&&!h) break;\n    for(int i=0;i<h;i++) cin>>r1[i]>>r2[i];\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(r1[i][j]=='L') sy1=i,sx1=j;\n\tif(r1[i][j]=='%') gy1=i,gx1=j;\n\tif(r2[i][j]=='R') sy2=i,sx2=j;\n\tif(r2[i][j]=='%') gy2=i,gx2=j;\n      }\n    ans=0;\n    bfs();\n    if(ans) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n  return 0;\n}\n\nvoid bfs(){\n  int dy[4]={0,-1,0,1},dx[4]={-1,0,1,0};\n  queue<d> q;\n  d k=(d){sy1,sx1,sy2,sx2};\n  q.push(k);\n  visited.insert(k);\n  while(!q.empty()){\n    d t=q.front(); q.pop();\n    for(int i=0;i<4;i++){\n      int ny1=t.y1+dy[i],nx1=t.x1+dx[i];\n      int ny2=t.y2-dy[i],nx2=t.y2-dx[i];\n      if(ny1<0) ny1=0;\n      if(nx1<0) nx1=0;\n      if(h<=ny1) ny1=h;\n      if(w<=nx1) nx1=w;\n      if(ny2<0) ny2=0;\n      if(nx2<0) nx2=0;\n      if(h<=ny2) ny2=h;\n      if(w<=nx2) nx2=w;\n      if(r1[ny1][nx1]=='#') ny1=t.y1,nx1=t.x1;\n      if(r2[ny2][nx2]=='#') ny2=t.y2,nx2=t.x2;\n      d u=(d){ny1,nx1,ny2,nx2};\n      if(visited.find(u)!=visited.end()) continue;\n      visited.insert(u);\n      if(ny1==gy1&&nx1==gx1&&ny2==gy2&&nx2==gx2){\n\tans=1;\n\tbreak;\n      }\n    }\n    if(ans) break;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n \n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n \nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\n \n \nint W,H;\nstring roomL[55],roomR[55];\n \nbool range_check(int y,int x) {\n    if(!(0<=y&&y<H)) return false;\n    if(!(0<=x&&x<W)) return false;\n \n    return true;\n}\n \nbool visited[55][55][55][55];\nbool ok(P len,P rin) {\n    memset(visited,0,sizeof(visited));\n    visited[len.fr][len.sc][rin.fr][rin.sc]=true;\n    queue<PP> que;\n    que.push(PP(len,rin));\n \n    while(que.size()) {\n        PP pp=que.front(); que.pop();\n        P next_len=pp.fr;\n        P next_rin=pp.sc;\n \n        //printf(\"[debug] %d %d %d %d\\n\",next_len.fr,next_len.sc,next_rin.fr,next_rin.sc);\n \n        if(roomL[next_len.fr][next_len.sc]=='%' && roomR[next_rin.fr][next_rin.sc]=='%') {\n            return true;\n        }\n        if(roomL[next_len.fr][next_len.sc]=='%' || roomR[next_rin.fr][next_rin.sc]=='%') {\n            //visited[next_len.fr][next_len.sc][next_rin.fr][next_rin.sc]=false;\n            continue;\n        }\n        rep(i,4) {\n            next_len=pp.fr;\n            next_rin=pp.sc;\n \n            if(range_check(next_len.fr+dy[i],next_len.sc+dx[i]) && roomL[next_len.fr+dy[i]][next_len.sc+dx[i]]!='#') {\n                next_len.fr+=dy[i];\n                next_len.sc+=dx[i];\n            }\n            if(range_check(next_rin.fr+dy[i],next_rin.sc-dx[i]) && roomR[next_rin.fr+dy[i]][next_rin.sc-dx[i]]!='#') {\n                next_rin.fr+=dy[i];\n                next_rin.sc-=dx[i];\n            }\n \n            if(!visited[next_len.fr][next_len.sc][next_rin.fr][next_rin.sc]) {\n                visited[next_len.fr][next_len.sc][next_rin.fr][next_rin.sc]=true;\n                que.push(PP(next_len,next_rin));\n            }\n        }\n    }\n \n    return false;\n}\n \nvoid solve() {\n    rep(y,55) roomL[y]=roomR[y]=string('#',55);\n    rep(y,H) cin>>roomL[y]>>roomR[y];\n    P len,rin;\n    rep(y,H) rep(x,W) {\n        if(roomL[y][x]=='L') len=P(y,x);\n        if(roomR[y][x]=='R') rin=P(y,x);\n    }\n    if(ok(len,rin)) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n}\n \nint main() {\n    while(cin>>W>>H) {\n        if(!W) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\n//[int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }; int dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\n/*--------------------template--------------------*/\nint n;\nint hs(int x, int y) { return x*n + y; }\nvector<bool> st;\nint main()\n{\n\tint w, h;\n\twhile (cin >> w >> h, w)\n\t{\n\t\tvs fldl(h), fldr(h);\n\t\tREP(i, h) cin >> fldl[i] >> fldr[i];\n\t\tn = w*h;\n\t\tst.clear();\n\t\tst.resize(n*n);\n\t\tint rx, ry, lx, ly;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fldl[i][j] == 'L')\n\t\t\t{\n\t\t\t\tfldl[i][j] = '.';\n\t\t\t\tlx = i, ly = j;\n\t\t\t}\n\t\t\tif (fldr[i][j] == 'R')\n\t\t\t{\n\t\t\t\tfldr[i][j] = '.';\n\t\t\t\trx = i, ry = j;\n\t\t\t}\n\t\t}\n\t\tqueue<int> que;\n\t\tst[hs(place(lx, ly, w), place(rx, ry, w))] = true;\n\t\tque.push(hs(place(lx, ly, w), place(rx, ry, w)));\n\t\tbool ans = false;\n\t\twhile (que.size())\n\t\t{\n\t\t\tint tmp = que.front();\n\t\t\tque.pop();\n\t\t\tint tl = tmp / n, tr = tmp%n;\n\t\t\tint lx = tl / w, ly = tl%w;\n\t\t\tint rx = tr / w, ry = tr%w;\n\t\t\tif (fldl[lx][ly] == '%'&&fldr[rx][ry] == '%')\n\t\t\t{\n\t\t\t\tans = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tREP(i, 4)\n\t\t\t{\n\t\t\t\tint lnx, lny, rnx, rny;\n\t\t\t\tif (valid(lx + dx[i], ly + dy[i], h, w) && fldl[lx + dx[i]][ly + dy[i]] != '#')\n\t\t\t\t{\n\t\t\t\t\tlnx = lx + dx[i], lny = ly + dy[i];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlnx = lx, lny = ly;\n\t\t\t\t}\n\t\t\t\tif (valid(rx + dx[i], ry - dy[i], h, w) && fldr[rx + dx[i]][ry - dy[i]] != '#')\n\t\t\t\t{\n\t\t\t\t\trnx = rx + dx[i], rny = ry - dy[i];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\trnx = rx, rny = ry;\n\t\t\t\t}\n\t\t\t\tint next = hs(place(lnx, lny, w), place(rnx, rny, w));\n\t\t\t\tif (!st[next])\n\t\t\t\t{\n\t\t\t\t\tst[next] = true;\n\t\t\t\t\tque.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(ans ? \"Yes\" : \"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pp pair<int,int>\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n#define ll long long\n#define ld long double\n#define all(a) (a).begin(),(a).end()\n#define mk make_pair\nll MOD=1000000007;\nint inf=1000001000;\nll INF=100000000000000000;\n\nint m[55][55][55][55];\n\nint main() {\n    while (true){\n        memset(m, 0, sizeof(m));\n    int w,h;\n    cin >> w >> h;\n    if (w==0 && h==0) break;\n    vector<vector<int>> a(w+2,vector<int>(h+2,1)),b(w+2,vector<int>(h+2,1));\n    queue<pair<pp,pp>> q;\n    pair<pp,pp> v;\n    rep(i,h){\n        string s,ss;\n        cin >> s >> ss;\n        rep(j,w){\n            if (s[j]=='.') a[1+j][1+i]=0;\n            if (ss[w-1-j]=='.') b[1+j][1+i]=0;\n            if (s[j]=='L') {\n                a[1+j][1+i]=0;\n                v.first.first=1+j;\n                v.first.second=1+i;\n            }\n            if (ss[w-1-j]=='R') {\n                b[1+j][1+i]=0;\n                v.second.first=1+j;\n                v.second.second=1+i;\n            }\n            if (s[j]=='%') a[1+j][1+i]=2;\n            if (ss[w-1-j]=='%') b[1+j][1+i]=2;\n        }}\n        q.push(v);\n        m[v.first.first][v.first.second][v.second.first][v.second.second]=1;\n        vector<int> dx={0,0,1,-1},dy={1,-1,0,0};\n        bool u=true;\n        while(!q.empty()){\n            int d=q.front().first.first,f=q.front().first.second,g=q.front().second.first,h=q.front().second.second;\n            q.pop();\n            rep(i,4){\n                int x1=d,x2=g,y1=f,y2=h;\n                if (a[d+dx[i]][f+dy[i]]!=1) {x1=d+dx[i];y1=f+dy[i];}\n                if (b[g+dx[i]][h+dy[i]]!=1) {x2=g+dx[i];y2=h+dy[i];}\n                v.first.first=x1;v.first.second=y1;v.second.first=x2;v.second.second=y2;\n                if (m[x1][y1][x2][y2]==1) continue;\n                m[x1][y1][x2][y2]=1;\n                if (a[x1][y1]==2 && b[x2][y2]==2){\n                    cout << \"Yes\" << endl;\n                    u=false;\n                }\n                else if (a[x1][y1]==2 || b[x2][y2]==2) continue;\n                q.push(v);\n            }\n    }\n    if (u) cout << \"No\" << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define F first\n#define S second\n\ntypedef pair<int,int> pii;\n\nvector<string> va,vb;\nint H,W;\nint dp[55][55][55][55];\nint aay[]={0,1,0,-1};\nint aax[]={1,0,-1,0};\nint bby[]={0,-1,0,1};\nint bbx[]={1,0,-1,0};\nbool check(int a,int b){\n\tif(0<=a&&a<H&&0<=b&&b<W) return true;\n\treturn false;\n}\nint dfs(int a,int b,int c,int d){\n\tif(dp[a][b][c][d]>=0) return dp[a][b][c][d];\n\tint ret=0;\n\t// cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<endl;\n\tdp[a][b][c][d]=0;\n\tif(va[a][b]=='%'&&vb[c][d]=='%'){\n\t\treturn dp[a][b][c][d]=1;\n\t}\n\tif(va[a][b]=='%'||vb[c][d]=='%'){\n\t\treturn dp[a][b][c][d]=0;\n\t}\n\trep(i,4){\n\t\tint aa=a+aax[i];\n\t\tint bb=b+aay[i];\n\t\tint cc=c+bbx[i];\n\t\tint dd=d+bby[i];\n\t\tif(!check(aa,bb)){\n\t\t\taa=a;\n\t\t\tbb=b;\n\t\t}\n\t\tif(!check(cc,dd)){\n\t\t\tcc=c;\n\t\t\tdd=d;\n\t\t}\n\t\tif(va[aa][bb]=='#'){\n\t\t\taa=a;\n\t\t\tbb=b;\n\t\t}\n\t\tif(vb[cc][dd]=='#'){\n\t\t\tcc=c;\n\t\t\tdd=d;\n\t\t}\n\t\tif(dfs(aa,bb,cc,dd)==1) ret=1;\n\t}\n\treturn dp[a][b][c][d]=ret;\n}\nint main(){\n\twhile(cin>>W>>H){\n\t\tif(W==0&&H==0) break;\n\t\tpii L,R;\n\t\tva=vector<string>(H);\n\t\tvb=vector<string>(H);\n\t\trep(i,H) cin>>va[i]>>vb[i];\n\t\trep(i,H){\n\t\t\trep(j,W){\n\t\t\t\tif(va[i][j]=='L'){\n\t\t\t\t\tva[i][j]='.';\n\t\t\t\t\tL=pii(i,j);\n\t\t\t\t}\n\t\t\t\tif(vb[i][j]=='R'){\n\t\t\t\t\tvb[i][j]='.';\n\t\t\t\t\tR=pii(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,55){\n\t\t\trep(j,55){\n\t\t\t\trep(k,55){\n\t\t\t\t\trep(l,55){\n\t\t\t\t\t\tdp[i][j][k][l]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dfs(L.first,L.second,R.first,R.second)) cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stdio.h>\n#include <queue>\n#include <string.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\nstruct Point { int xl, yl, xr, yr; };\n\nconst int MAX_W = 50 + 3;\nbool visited[MAX_W][MAX_W][MAX_W][MAX_W];  // xl, yl, xr, yr\n\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\n\nint main() {\n  int w,h;\n\n  while(cin >> w >> h, w||h) {\n    memset(visited, 0, sizeof(visited));\n\n    vector<string> roomL, roomR;\n    rep(i,2*h) {\n      string s;\n      cin >> s;\n      (i % 2 == 0 ? roomL : roomR).push_back( \"#\" + s + \"#\" );\n    }\n    string longWall(w+2, '#');\n    roomL.push_back(longWall);\n    roomL.insert(roomL.begin(), longWall);\n    roomR.push_back(longWall);\n    roomR.insert(roomR.begin(), longWall);\n\n    w += 2;\n    h += 2;\n    Point start;\n    rep(y,h) rep(x,w)  if (roomL[y][x] == 'L') {\n      start.xl = x;\n      start.yl = y;\n    }\n    rep(y,h) rep(x,w)  if (roomR[y][x] == 'R') {\n      start.xr = x;\n      start.yr = y;\n    }\n\n    queue<Point> que;\n    que.push(start);\n    while(!que.empty()) {\n      Point p = que.front();\n      que.pop();\n\n      // cout << p.xl << \" \" << p.yl << \" \" << p.xr << \" \" << p.yr << endl;\n      if (roomL[p.yl][p.xl] == '%' ^  roomR[p.yr][p.xr] == '%') continue;\n      if (roomL[p.yl][p.xl] == '%' && roomR[p.yr][p.xr] == '%') goto yes;\n\n      rep(i,4) {\n        int nxl = p.xl + dx[i];\n        int nyl = p.yl + dy[i];\n        int nxr = p.xr - dx[i];  // reflect\n        int nyr = p.yr + dy[i];\n\n        if (roomL[nyl][nxl] == '#') nxl = p.xl, nyl = p.yl;\n        if (roomR[nyr][nxr] == '#') nxr = p.xr, nyr = p.yr;\n        if (visited[nxl][nyl][nxr][nyr]) continue;\n\n        visited[nxl][nyl][nxr][nyr] = true;\n        que.push((Point){ nxl, nyl, nxr, nyr });\n      }\n    }\n\n    cout << \"No\" << endl;\n    continue;\n    yes:\n    cout << \"Yes\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint lsx, lsy, ltx, lty, rsx, rsy, rtx, rty;\nbool dfs(vector<vector<vvi>> &dp, int lx, int ly, int rx, int ry) {\n\tif (dp[ly][lx][ry][rx] != -1)return dp[ly][lx][ry][rx];\n\treturn true;\n}\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint w, h;\n\twhile (cin >> w >> h, w) {\n\t\tvector<string> l(h), r(h);\n\t\tREP(i, h) cin >> l[i] >> r[i];\n\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tif (l[i][j] == '%') {\n\t\t\t\t\tltx = j; lty = i;\n\t\t\t\t}\n\t\t\t\tif (l[i][j] == 'L') {\n\t\t\t\t\tlsx = j; lsy = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tif (r[i][j] == '%') {\n\t\t\t\t\trtx = j; rty = i;\n\t\t\t\t}\n\t\t\t\tif (r[i][j] == 'R') {\n\t\t\t\t\trsx = j; rsy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<vector<vvi>> dp(h, vector<vvi>(w, vvi(h, vi(w, -1))));\n\t\tqueue<pair<pii, pii>> q;\n\t\tvector<vector<vvi>> b(h, vector<vvi>(w, vvi(h, vi(w, 0))));\n\t\tq.push(pair<pii, pii>(pii(lsx, lsy), pii(rsx, rsy)));\n\t\tb[lsy][lsx][rsy][rsx] = 1;\n\t\twhile (!q.empty()) {\n\t\t\tauto a = q.front(); q.pop();\n\t\t\tint lx = a.first.first, ly = a.first.second, rx = a.second.first, ry = a.second.second;\n\t\t\tif (lx == ltx&&ly == lty&&rx == rtx&&ry == rty) {\n\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\tgoto a;\n\t\t\t}\n\n\t\t\tREP(i, 4) {\n\t\t\t\tint lnx = lx + dx[i * 2], lny = ly + dy[i * 2], rnx = rx + dx[(i + 2 * (i % 2 == 0)) * 2 % 8], rny = ry + dy[(i + 2 * (i % 2 == 0)) * 2 % 8];\n\t\t\t\tif (lnx < 0 || lnx >= w || lny < 0 || lny >= h ){ \n\t\t\t\t\tlny = ly; lnx = lx;\n\t\t\t\t}\n\t\t\t\telse if (l[lny][lnx] == '#') {\n\t\t\t\t\tlny = ly; lnx = lx;\n\t\t\t\t}\n\t\t\t\tif (rnx < 0 || rnx >= w || rny < 0 || rny >= h ) {\n\t\t\t\t\trny = ry; rnx = rx;\n\t\t\t\t}\n\t\t\t\telse if (r[rny][rnx] == '#') {\n\t\t\t\t\trny = ry; rnx = rx;\n\t\t\t\t}\n\t\t\t\tif ((lnx!=lx||lny!=ly||rnx!=rx||rny!=ry)&& b[lny][lnx][rny][rnx]!=1) {\n\t\t\t\t\n\t\t\t\t\tq.push(pair<pii, pii>(pii(lnx, lny), pii(rnx, rny)));\n\t\t\t\t\tb[lny][lnx][rny][rnx] = 1;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << \"No\" << endl;\n\n\ta:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"tune=native\")\n#pragma GCC target (\"avx\")\n\n#include <bits/stdc++.h>\n\n// 汎用マクロ\n#define ALL_OF(x) (x).begin(), (x).end()\n#define REP(i,n) for (long long i=0, i##_len=(n); i<i##_len; i++)\n#define RANGE(i,is,ie) for (long long i=(is), i##_end=(ie); i<=i##_end; i++)\n#define DSRNG(i,is,ie) for (long long i=(is), i##_end=(ie); i>=i##_end; i--)\n#define UNIQUE(v) { sort((v).begin(), (v).end()); (v).erase(unique((v).begin(), (v).end()), (v).end()); }\ntemplate<class T> bool chmax(T &a, const T &b) {if (a < b) {a = b; return 1;} return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) {if (a > b) {a = b; return 1;} return 0; }\n#define INF 0x7FFFFFFF\n#define LINF 0x7FFFFFFFFFFFFFFFLL\n#define Yes(q) (q ? \"Yes\" : \"No\")\n#define YES(q) (q ? \"YES\" : \"NO\")\n#define DUMP(q) cerr << \"[DEBUG] \" #q \": \" << (q) << \" at \" __FILE__ \":\" << __LINE__ << endl\n#define DUMPALL(q) cerr << \"[DEBUG] \" #q \": [\"; REP(dumpall_i, (q).size()) { cerr << q[dumpall_i] << (dumpall_i == (q).size() - 1 ? \"\" : \", \"); } cerr << \"] at \" __FILE__ \":\" << __LINE__ << endl\n\n// gcc拡張マクロ\n#define gcd __gcd\n#define popcount __builtin_popcount\n#define popcountll __builtin_popcountll\n\n// エイリアス\nusing  ll = long long;\nusing ull = unsigned long long;\nusing  ld = long double;\nusing namespace std;\n\n// モジュール\n\n\n// 処理内容\nint main() {\n    \n    ll w, h;\n    while (cin >> w >> h, w && h) {\n\n        vector<string> rl(h), rr(h);\n        REP(i, h) cin >> rl[i] >> rr[i];\n        ll lsy, lsx, rsy, rsx;\n        ll lgy, lgx, rgy, rgx;\n        REP(i, h) REP(j, w) {\n            if (rl[i][j] == '%') {\n                lsy = i;\n                lsx = j;\n            } else if (rl[i][j] == 'L') {\n                lgy = i;\n                lgx = j;\n            }\n            if (rr[i][j] == '%') {\n                rsy = i;\n                rsx = j;\n            } else if (rr[i][j] == 'R') {\n                rgy = i;\n                rgx = j;\n            }\n        }\n\n        // {ly, lx, ry, rx}\n        deque<tuple<ll,ll,ll,ll>> q;\n        vector<vector<vector<vector<bool>>>> visited(h, vector<vector<vector<bool>>>(w, vector<vector<bool>>(h, vector<bool>(w, false))));\n        q.emplace_back(lsy, lsx, rsy, rsx);\n        visited[lsy][lsx][rsy][rsx] = true;\n        while (!q.empty()) {\n\n            ll ly = get<0>(q.front());\n            ll lx = get<1>(q.front());\n            ll ry = get<2>(q.front());\n            ll rx = get<3>(q.front());\n            q.pop_front();\n\n            // Lin and Ren go upward\n            if (ly > 0 && ry > 0) {\n                ll ly2 = rl[ly - 1][lx] != '#' ? ly - 1 : ly;\n                ll lx2 = lx;\n                ll ry2 = rr[ry - 1][lx] != '#' ? ry - 1 : ry;\n                ll rx2 = rx;\n                if (!visited[ly2][lx2][ry2][rx2]) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n                if (ly < h-1) if (rl[ly+1][lx] == '#') {\n                    ll ly2 = ly;\n                    if (!visited[ly2][lx2][ry2][rx2]) {\n                        q.emplace_back(ly2, lx2, ry2, rx2);\n                        visited[ly2][lx2][ry2][rx2] = true;\n                    }\n                }\n                if (ry < h-1) if (rr[ry+1][rx] == '#') {\n                    ll ry2 = ry;\n                    if (!visited[ly2][lx2][ry2][rx2]) {\n                        q.emplace_back(ly2, lx2, ry2, rx2);\n                        visited[ly2][lx2][ry2][rx2] = true;\n                    }\n                }\n            }\n\n            // Lin and Ren go downward\n            if (ly < h-1 && ry < h-1) {\n                ll ly2 = rl[ly + 1][lx] != '#' ? ly + 1 : ly;\n                ll lx2 = lx;\n                ll ry2 = rr[ry + 1][lx] != '#' ? ry + 1 : ry;\n                ll rx2 = rx;\n                if (!visited[ly2][lx2][ry2][rx2]) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n                if (ly > 0) if (rl[ly-1][lx] == '#') {\n                    ll ly2 = ly;\n                    if (!visited[ly2][lx2][ry2][rx2]) {\n                        q.emplace_back(ly2, lx2, ry2, rx2);\n                        visited[ly2][lx2][ry2][rx2] = true;\n                    }\n                }\n                if (ry > 0) if (rr[ry-1][rx] == '#') {\n                    ll ry2 = ry;\n                    if (!visited[ly2][lx2][ry2][rx2]) {\n                        q.emplace_back(ly2, lx2, ry2, rx2);\n                        visited[ly2][lx2][ry2][rx2] = true;\n                    }\n                }\n            }\n\n            // Lin goes left and Ren goes right\n            if (lx > 0 && rx < w-1) {\n                ll ly2 = ly;\n                ll lx2 = rl[ly][lx - 1] != '#' ? lx - 1 : lx;\n                ll ry2 = ry;\n                ll rx2 = rr[ry][rx + 1] != '#' ? rx + 1 : rx;\n                if (!visited[ly2][lx2][ry2][rx2]) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n                if (lx < w-1) if (rl[ly][lx+1] == '#') {\n                    ll lx2 = lx;\n                    if (!visited[ly2][lx2][ry2][rx2]) {\n                        q.emplace_back(ly2, lx2, ry2, rx2);\n                        visited[ly2][lx2][ry2][rx2] = true;\n                    }\n                }\n                if (rx > 0) if (rr[ry][rx-1] == '#') {\n                    ll rx2 = rx;\n                    if (!visited[ly2][lx2][ry2][rx2]) {\n                        q.emplace_back(ly2, lx2, ry2, rx2);\n                        visited[ly2][lx2][ry2][rx2] = true;\n                    }\n                }\n            }\n\n            // Lin goes right and Ren goes left\n            if (lx < w-1 && rx > 0) {\n                ll ly2 = ly;\n                ll lx2 = rl[ly][lx + 1] != '#' ? lx + 1 : lx;\n                ll ry2 = ry;\n                ll rx2 = rr[ry][rx - 1] != '#' ? rx - 1 : rx;\n                if (!visited[ly2][lx2][ry2][rx2]) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n                if (lx > 0) if (rl[ly][lx-1] == '#') {\n                    ll lx2 = lx;\n                    if (!visited[ly2][lx2][ry2][rx2]) {\n                        q.emplace_back(ly2, lx2, ry2, rx2);\n                        visited[ly2][lx2][ry2][rx2] = true;\n                    }\n                }\n                if (rx < w-1) if (rr[ry][rx+1] == '#') {\n                    ll rx2 = rx;\n                    if (!visited[ly2][lx2][ry2][rx2]) {\n                        q.emplace_back(ly2, lx2, ry2, rx2);\n                        visited[ly2][lx2][ry2][rx2] = true;\n                    }\n                }\n            }\n\n        }\n\n        std::cout << Yes(visited[lgy][lgx][rgy][rgx]) << endl;\n\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\nchar fieldL[51][51];\nchar fieldR[51][51];\n\nbool isArrival[51][51][51][51];\nint h,w;\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\n\nvoid bfs(int slx,int sly,int srx,int sry){\n\tqueue<pair<int,int> > *prvL=new queue<pair<int,int> >();\n\tqueue<pair<int,int> > *nxtL=new queue<pair<int,int> >();\n\tqueue<pair<int,int> > *prvR=new queue<pair<int,int> >();\n\tqueue<pair<int,int> > *nxtR=new queue<pair<int,int> >();\n\tprvL->push(make_pair(sly,slx));\n\tprvR->push(make_pair(sry,srx));\n\twhile(prvL->size()){\n\t\twhile(prvL->size()){\n\t\t\tpair<int,int> pl=prvL->front();prvL->pop();\n\t\t\tpair<int,int> pr=prvR->front();prvR->pop();\n\t\t\tint ly=pl.first;int lx=pl.second;\n\t\t\tint ry=pr.first;int rx=pr.second;\n\t\t\tif(isArrival[ly][lx][ry][rx])\n\t\t\t\tcontinue;\n\t\t\tisArrival[ly][lx][ry][rx]=true;\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint nly=max(0,min(h-1,ly+dy[i]));\n\t\t\t\tint nlx=max(0,min(h-1,lx+dx[i]));\n\t\t\t\tint nry=max(0,min(h-1,ry+dy[i]));\n\t\t\t\tint nrx=max(0,min(h-1,rx-dx[i]));\n\t\t\t\tif(fieldL[nly][nlx]=='#'){\n\t\t\t\t\tnly=ly;\n\t\t\t\t\tnlx=lx;\n\t\t\t\t}\n\t\t\t\tif(fieldL[nry][nrx]=='#'){\n\t\t\t\t\tnry=ry;\n\t\t\t\t\tnrx=rx;\n\t\t\t\t}\n\t\t\t\tif(!isArrival[nly][nlx][nry][nrx]){\n\t\t\t\t\tnxtL->push(make_pair(nly,nlx));\n\t\t\t\t\tnxtR->push(make_pair(nry,nrx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(prvL,nxtL);\n\t\tswap(prvR,nxtR);\n\t}\n\tdelete prvL,prvR,nxtL,nxtR;\n}\n\nint main(){\n\twhile(cin>>w>>h&&!(w==0&&h==0)){\n\t\tmemset(isArrival,0,sizeof(isArrival));\n\t\tint sly,slx,srx,sry;\n\t\tint fly,flx,frx,fry;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>fieldL[i][j];\n\t\t\t\tif(fieldL[i][j]=='L'){\n\t\t\t\t\tfieldL[i][j]='.';\n\t\t\t\t\tsly=i;\n\t\t\t\t\tslx=j;\n\t\t\t\t}\n\t\t\t\telse if(fieldL[i][j]=='%'){\n\t\t\t\t\tfieldL[i][j]='.';\n\t\t\t\t\tfly=i;\n\t\t\t\t\tflx=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>fieldR[i][j];\n\t\t\t\tif(fieldR[i][j]=='R'){\n\t\t\t\t\tfieldR[i][j]='.';\n\t\t\t\t\tsry=i;\n\t\t\t\t\tsrx=j;\n\t\t\t\t}\n\t\t\t\telse if(fieldR[i][j]=='%'){\n\t\t\t\t\tfieldR[i][j]='.';\n\t\t\t\t\tfry=i;\n\t\t\t\t\tfrx=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbfs(slx,sly,srx,sry);\n\t\tif(isArrival[fly][flx][fry][frx])\n\t\t\tcout<<\"Yes\"<<endl;\n\t\telse\n\t\t\tcout<<\"No\"<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<cmath>\n#include<utility>\n#include<functional>\n#include<map>\n#include<set>\n#include<cctype>\n\n\n#define FOR(i, a, b) for( int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for( int i=(a);i>=(b);i--)\n#define LFOR(i, a, b) for( long long int i=(a);i<=(b);i++)\n#define LRFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LLINF 1000000000000000000 //9000000000000000000\n#define PI 3.14159265358979\n#define MAXI 7500000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\n\nint dy[4] = { 0,0,1,-1 };\nint dx[4] = { 1,-1,0,0 };\n\n//int dp[50][50][50][50] = {};//ly,lx,ry,rx\n\n\nint main(void) {\n\t\n\twhile (1) {\n\n\t\tstruct Pos{\n\t\t\tint leftx;\n\t\t\tint lefty;\n\t\t\tint rightx;\n\t\t\tint righty;\n\t\t};\n\n\t\tint w, h;\n\t\tint lx = -1, ly = -1, rx = -1, ry = -1;\n\t\tint lgx = -1, lgy = -1, rgx = -1, rgy = -1;\n\n\t\tvector< vector< vector< vector<int> > > > dp(50, vector< vector< vector<int > > >(50, vector< vector<int> >(50, vector<int>(50, 0))));\n\t\t\n\n\t\tqueue< Pos > que;\n\t\tPos now;\n\n\t\tcin >> w >> h;\n\n\t\tif (w == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tvector<string> left(h), right(h);\n\n\t\tFOR(i, 0, h-1) {\n\t\t\tcin >> left[i] >> right[i];\n\t\t}\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (left[i][j] == 'L') {\n\t\t\t\t\tlx = j;\n\t\t\t\t\tly = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (right[i][j] == 'R') {\n\t\t\t\t\trx = j;\n\t\t\t\t\try = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (left[i][j] == '%') {\n\t\t\t\t\tlgx = j;\n\t\t\t\t\tlgy = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lgx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (right[i][j] == '%') {\n\t\t\t\t\trgx = j;\n\t\t\t\t\trgy = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rgx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdp[ly][lx][ry][rx] = 1;\n\n\t\tnow.lefty = ly;\n\t\tnow.leftx = lx;\n\t\tnow.righty = ry;\n\t\tnow.rightx = rx;\n\t\t\n\t\tque.push(now);\n\n\n\t\twhile (!que.empty()) {\n\t\t\tnow = que.front();\n\t\t\t\n\t\t\tque.pop();\n\t\t\tly = now.lefty;\n\t\t\tlx = now.leftx;\n\t\t\try = now.righty;\n\t\t\trx = now.rightx;\n\t\t\t//cout << ly << \" \" << lx << \" \" << ry << \" \" << rx << endl;\n\n\t\t\tFOR(i, 0, 3) {\n\t\t\t\t\n\t\t\t\tif (ly + dy[i] >= 0 && lx - dx[i] >= 0 && ry + dy[i] <= h - 1 && rx + dx[i] <= w - 1 && ly + dy[i] <= h - 1 && lx - dx[i] <= w - 1 && ry + dy[i] >= 0 && rx + dx[i] >= 0) {\n\t\t\t\t\tif (dp[ly + dy[i]][lx - dx[i]][ry + dy[i]][rx + dx[i]] != 1) {\n\t\t\t\t\t\tif (left[ly + dy[i]][lx - dx[i]] == '#') {\n\t\t\t\t\t\t\tif (right[ry + dy[i]][rx + dx[i]] == '#') {\n\t\t\t\t\t\t\t\t//no\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdp[ly][lx][ry + dy[i]][rx + dx[i]] = 1;\n\t\t\t\t\t\t\t\tnow.lefty = ly;\n\t\t\t\t\t\t\t\tnow.leftx = lx;\n\t\t\t\t\t\t\t\tnow.righty = ry + dy[i];\n\t\t\t\t\t\t\t\tnow.rightx = rx + dx[i];\n\t\t\t\t\t\t\t\tque.push(now);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (right[ry + dy[i]][rx + dx[i]] == '#') {\n\t\t\t\t\t\t\t\tdp[ly + dy[i]][lx - dx[i]][ry][rx] = 1;\n\t\t\t\t\t\t\t\tnow.lefty = ly + dy[i];\n\t\t\t\t\t\t\t\tnow.leftx = lx - dx[i];\n\t\t\t\t\t\t\t\tnow.righty = ry;\n\t\t\t\t\t\t\t\tnow.rightx = rx;\n\t\t\t\t\t\t\t\tque.push(now);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdp[ly + dy[i]][lx - dx[i]][ry + dy[i]][rx + dx[i]] = 1;\n\t\t\t\t\t\t\t\tnow.lefty = ly + dy[i];\n\t\t\t\t\t\t\t\tnow.leftx = lx - dx[i];\n\t\t\t\t\t\t\t\tnow.righty = ry + dy[i];\n\t\t\t\t\t\t\t\tnow.rightx = rx + dx[i];\n\t\t\t\t\t\t\t\tque.push(now);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (dp[lgy][lgx][rgy][rgx] == 1) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t\t\n\n\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<tuple>\n#include<string>\nusing namespace std;\n\n#define MAX_N 60\n#define INF 1<<30\n\nint dist[MAX_N][MAX_N][MAX_N][MAX_N];\nint dy1[4] = { 0,1,0,-1 };\nint dy2[4] = { 0,1,0,-1 };\nint dx1[4] = { 1,0,-1,0 };\nint dx2[4] = { -1,0,1,0 };\nint H, W, map1[MAX_N][MAX_N], map2[MAX_N][MAX_N];\nint Lsy, Lsx, Lgy, Lgx;\nint Rsy, Rsx, Rgy, Rgx;\nstring S, T;\nqueue<tuple<int, int, int, int>>Q;\n\nvoid _memset() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tfor (int k = 0; k < MAX_N; k++) {\n\t\t\t\tfor (int l = 0; l < MAX_N; l++) {\n\t\t\t\t\tdist[i][j][k][l] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tmap1[i][j] = 1;\n\t\t\tmap2[i][j] = 1;\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\t_memset();\n\t\tcin >> W >> H;\n\t\tif (H == 0 && W == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tcin >> S >> T;\n\t\t\tfor (int j = 0; j < S.size(); j++) {\n\t\t\t\tif (S[j] == '%') {\n\t\t\t\t\tLsx = j + 1; Lsy = i;\n\t\t\t\t\tmap1[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\tif (S[j] == '#') {\n\t\t\t\t\tmap1[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (S[j] == '.') {\n\t\t\t\t\tmap1[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\tif (S[j] == 'L') {\n\t\t\t\t\tLgy = i; Lgx = j + 1;\n\t\t\t\t\tmap1[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < T.size(); j++) {\n\t\t\t\tif (T[j] == '%') {\n\t\t\t\t\tRsx = j + 1; Rsy = i;\n\t\t\t\t\tmap2[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\tif (T[j] == '#') {\n\t\t\t\t\tmap2[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (T[j] == '.') {\n\t\t\t\t\tmap2[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\tif (T[j] == 'R') {\n\t\t\t\t\tRgy = i; Rgx = j + 1;\n\t\t\t\t\tmap2[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQ.push(make_tuple(Lsy, Lsx, Rsy, Rsx));\n\t\tdist[Lsy][Lsx][Rsy][Rsx] = 0;\n\n\t\twhile (!Q.empty()) {\n\t\t\ttuple<int, int, int, int>tup = Q.front(); Q.pop();\n\t\t\tint ay = get<0>(tup);\n\t\t\tint ax = get<1>(tup);\n\t\t\tint by = get<2>(tup);\n\t\t\tint bx = get<3>(tup);\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint ey = ay + dy1[i], ex = ax + dx1[i];\n\t\t\t\tint fy = by + dy2[i], fx = bx + dx2[i];\n\t\t\t\tif (map1[ey][ex] == 1) {\n\t\t\t\t\tey = ay; ex = ax;\n\t\t\t\t}\n\t\t\t\tif (map2[fy][fx] == 1) {\n\t\t\t\t\tfy = by; fx = bx;\n\t\t\t\t}\n\t\t\t\tif (dist[ey][ex][fy][fx] == INF) {\n\t\t\t\t\tdist[ey][ex][fy][fx] = dist[ay][ax][by][bx] + 1;\n\t\t\t\t\tQ.push(make_tuple(ey, ex, fy, fx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[Lgy][Lgx][Rgy][Rgx] == INF) {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<ctime>\n#include<climits>\n#include<queue>\n#include<fstream>\n#include<deque>\n#include<iomanip>\n#include<list>\n#include<stack>\n#include<sstream>\n#include<string>\n#include<cctype>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<cstring>\n#include<iomanip>\n#include<map>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS 1e-10\n#define F first\n#define S second\n#define all(n) n.begin(),n.end()\n#define pb push_back\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define INF (1<<27)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nconst P dx[4] = {P(0,0),P(0,0),P(1,-1),P(-1,1)};\nconst P dy[4] = {P(1,1),P(-1,-1),P(0,0),P(0,0)};\n\n\nint H,W;\nchar L_cmap[65][65],R_cmap[65][65];\nbool L_used[65][65],R_used[65][65];\nP Ls,Rs,Lg,Rg;\nbool fin;\n\nvoid dfs(PP pp){\n  if(fin)return;\n      if(pp.F == Lg && pp.S == Rg){\n\tcout << \"Yes\" << endl;\n\tfin = true;\n\treturn;\n      }\n      //cout << \"pp.F = \" << pp.F.F << \",\" << pp.F.S << \" pp.S = \" << pp.S.F << \",\" << pp.S.S << endl;\n      rep(i,4){\n\tint L_nx = pp.F.F + dx[i].F,L_ny = pp.F.S + dy[i].F;\n\tint R_nx = pp.S.F + dx[i].S,R_ny = pp.S.S + dy[i].S;\n\t//cout << \"First next L = \" << L_nx << \",\" << L_ny << \" Pre next R = \" << R_nx << \",\" << R_ny << endl;\n\n\n \tif(!(0<=L_nx && L_nx <W && 0<= R_nx && R_nx <W && 0<= L_ny && L_ny <H && 0<= R_ny && R_ny < H))continue;\n\tif(L_cmap[L_ny][L_nx] != '#' && L_used[L_ny][L_nx])continue;\n\tif(R_cmap[R_ny][R_nx] != '#' && R_used[R_ny][R_nx])continue;\n\tif(L_cmap[L_ny][L_nx] == '#' && R_cmap[R_ny][R_nx] == '#')continue;\n\n\t//cout << \"next L = \" << L_nx << \",\" << L_ny << \" Pre next R = \" << R_nx << \",\" << R_ny << endl;\n\tif(L_cmap[L_ny][L_nx] == '#')L_nx = pp.F.F,L_ny = pp.F.S;\n\tif(R_cmap[R_ny][R_nx] == '#')R_nx = pp.S.F,R_ny = pp.S.S;\n\t\n\tR_used[R_ny][R_nx] = L_used[L_ny][L_nx] = true;\n\t//que.push(insert(L_nx,L_ny,R_nx,R_ny));\n\tif(fin)return;\n\tdfs(insert(L_nx,L_ny,R_nx,R_ny));\n\tif(fin)return;\n\tR_used[R_ny][R_nx] = L_used[L_ny][L_nx] = false;\n      }\n      return;\n}\n   \n\n\nint main(){\n  //clock_t start,end;\n  //start = clock();\n  while(true){\n    cin >> W >> H;\n    if(W+H == 0)break;\n    fin = false;\n    rep(i,H){\n      string s;\n      cin >> s;\n      rep(j,W){\n\tL_cmap[i][j] = s[j],L_used[i][j] = false;\n\tif(s[j] == 'L')\n\t  Ls = P(j,i);\n\tif(s[j] == '%')\n\t  Lg = P(j,i);\n      }\n      cin >> s;\n      rep(j,W){\n\tR_cmap[i][j] = s[j],R_used[i][j] = false;\n\tif(s[j] == 'R')\n\t  Rs = P(j,i);\n\tif(s[j] == '%')\n\t  Rg = P(j,i);\n      }\n    }\n   \n    L_used[Ls.S][Ls.F] = true,R_used[Rs.S][Rs.F] = true;\n    dfs(insert(Ls.F,Ls.S,Rs.F,Rs.S));\n\n    if(!fin)cout << \"No\" << endl;\n\n  }\n  //end = clock();\n  //cout << setiosflags(ios::fixed) << setprecision(10) << (double)(end-start)/CLOCKS_PER_SEC << endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstring>\n#include <iostream>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nconst int dx1[4] = { 0, 1, 0, -1 };\nconst int dy1[4] = { -1, 0, 1, 0 };\nconst int dx2[4] = { 0, -1, 0, 1 };\nconst int dy2[4] = { -1, 0, 1, 0 };\n\nint H, W; string L[50], R[50];\n\nbool used[50][50][50][50];\n\nbool over(int x, int y)\n{\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\nbool solve(int lx, int ly, int rx, int ry)\n{\n\tused[ly][lx][ry][rx] = true;\n\n\tif (L[ly][lx] == '%' && R[ry][rx] == '%') return true;\n\n\tif (L[ly][lx] == '%') return false;\n\tif (R[ry][rx] == '%') return false;\n\n\tbool ok = false;\n\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint ltx = lx + dx1[i];\n\t\tint lty = ly + dy1[i];\n\t\tint rtx = rx + dx2[i];\n\t\tint rty = ry + dy2[i];\n\n\t\tif (over(ltx, lty) && over(rtx, rty))\n\t\t{\n\t\t\tif (L[lty][ltx] == '#')\n\t\t\t{\n\t\t\t\tltx -= dx1[i];\n\t\t\t\tlty -= dy1[i];\n\t\t\t}\n\n\t\t\tif (R[rty][rtx] == '#') \n\t\t\t{\n\t\t\t\trtx -= dx2[i];\n\t\t\t\trty -= dy2[i];\n\t\t\t}\n\n\t\t\tif (!used[lty][ltx][rty][rtx])\n\t\t\t{\n\t\t\t\tok |= solve(ltx, lty, rtx, rty);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ok;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &W);\n\t\tscanf(\"%d\", &H);\n\n\t\tif (W == 0 && H == 0) break;\n\n\t\tfor (int i = 0; i < H; i++) cin >> L[i] >> R[i];\n\n\t\tint lx, ly, rx, ry;\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (L[i][j] == 'L')\n\t\t\t\t{\n\t\t\t\t\tlx = j;\n\t\t\t\t\tly = i;\n\t\t\t\t}\n\n\t\t\t\tif (R[i][j] == 'R')\n\t\t\t\t{\n\t\t\t\t\trx = j;\n\t\t\t\t\try = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(used, false, sizeof(used));\n\n\t\tprintf(\"%s\\n\", solve(lx, ly, rx, ry) ? \"Yes\" : \"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\ntypedef tuple<int, int, int, int> tiiii;\n\nint dx_l[4] = { 1, -1, 0, 0 };\nint dy_l[4] = { 0, 0, 1, -1 };\nint dx_r[4] = { -1, 1, 0, 0 };\nint dy_r[4] = { 0, 0, 1, -1 };\n\nstring solve(int W, int H)\n{\n\tchar room_l[50][50];\n\tchar room_r[50][50];\n\n\trep(y, 0, H)\n\t{\n\t\tstring l, r;\n\t\tcin >> l >> r;\n\t\trep(x, 0, W) room_l[y][x] = l[x];\n\t\trep(x, 0, W) room_r[y][x] = r[x];\n\t}\n\n\tint slx, sly, srx, sry;\n\n\trep(y, 0, H) rep(x, 0, W)\n\t{\n\t\tif (room_l[y][x] == 'L')\n\t\t{\n\t\t\tslx = x;\n\t\t\tsly = y;\n\t\t}\n\t\tif (room_r[y][x] == 'R')\n\t\t{\n\t\t\tsrx = x;\n\t\t\tsry = y;\n\t\t}\n\t}\n\n\tvector<bool> done(50 * 50 * 50 * 50, false);\n\tstack<tiiii> _stack;\n\t_stack.push(make_tuple(slx, sly, srx, sry));\n\tdone[slx*50*50*50+sly*50*50+srx*50+sry] = true;\n\twhile (!_stack.empty())\n\t{\n\t\ttiiii t = _stack.top();\n\t\t_stack.pop();\n\n\t\tint lx = get<0>(t);\n\t\tint ly = get<1>(t);\n\t\tint rx = get<2>(t);\n\t\tint ry = get<3>(t);\n\n\t\trep(i, 0, 4)\n\t\t{\n\t\t\tint lxx = lx + dx_l[i];\n\t\t\tint lyy = ly + dy_l[i];\n\t\t\tint rxx = rx + dx_r[i];\n\t\t\tint ryy = ry + dy_r[i];\n\t\t\t\n\t\t\tif (lxx < 0 || W <= lxx) lxx = lx;\n\t\t\tif (lyy < 0 || H <= lyy) lyy = ly;\n\t\t\tif (rxx < 0 || W <= rxx) rxx = rx;\n\t\t\tif (ryy < 0 || H <= ryy) ryy = ry;\n\n\t\t\tif (room_l[lyy][lxx] == '%' && room_r[ryy][rxx] != '%') continue;\n\t\t\tif (room_l[lyy][lxx] != '%' && room_r[ryy][rxx] == '%') continue;\n\t\t\tif (room_l[lyy][lxx] == '%' && room_r[ryy][rxx] == '%') return \"Yes\";\n\n\t\t\tif (room_l[lyy][lxx] == '#')\n\t\t\t{\n\t\t\t\tlxx = lx;\n\t\t\t\tlyy = ly;\n\t\t\t}\n\n\t\t\tif (room_r[ryy][rxx] == '#')\n\t\t\t{\n\t\t\t\trxx = rx;\n\t\t\t\tryy = ry;\n\t\t\t}\n\n\t\t\tif (!done[lxx * 50 * 50 * 50 + lyy * 50 * 50 + rxx * 50 + ryy])\n\t\t\t{\n\t\t\t\tdone[lxx * 50 * 50 * 50 + lyy * 50 * 50 + rxx * 50 + ryy] = true;\n\t\t\t\t_stack.push(make_tuple(lxx, lyy, rxx, ryy));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"No\";\n}\n\nint main()\n{\n\twhile (1)\n\t{\n\t\tint W, H;\n\t\tcin >> W >> H;\n\t\tif (W == 0) return 0;\n\n\t\tcout << solve(W, H) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define pb push_back\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nconst P dx[4] = {P(0,0),P(0,0),P(-1,1),P(1,-1)};\nconst P dy[4] = {P(1,1),P(-1,-1),P(0,0),P(0,0)};\nbool bmap[55][55][55][55];\nchar L_cmap[51][51],R_cmap[51][51];\nint main(){\n  int H,W;\n  while(cin >> W >> H && H+W){\n   \n    P Ls,Rs,Lg,Rg;\n    rep(i,55)\n      rep(j,55)\n        rep(k,55)\n          rep(l,55)\n            bmap[i][j][k][l] = false;\n   \n    rep(i,H){\n      string s;\n      cin >> s;\n      rep(j,W){\n\tL_cmap[i][j] = s[j];\n\tif(s[j] == 'L')Ls = P(j,i);\n\tif(s[j] == '%')Lg = P(j,i);\n      }\n      s.clear();\n      cin >> s;\n      rep(j,W){\n\tR_cmap[i][j] = s[j];\n\tif(s[j] == 'R')Rs = P(j,i);\n\tif(s[j] == '%')Rg = P(j,i);\n      }\n    }\n  \n    queue<PP> que;\n    que.push(PP(Ls,Rs));\n    bmap[Ls.F][Ls.S][Rs.F][Rs.S] = true;\n    bool fin = false;\n    while(!que.empty())\n      {\n\tPP pp = que.front(); que.pop();\n\tif(pp.F == Lg && pp.S == Rg){\n\t  fin = true;\n\t  cout << \"Yes\" << endl;\n\t  break;\n\t}\n\tif(pp.F == Lg || pp.S == Rg)continue;\n\n\trep(i,4){\n\t  int L_nx = pp.F.F+dx[i].F,L_ny = pp.F.S+dy[i].F;\n\t  int R_nx = pp.S.F+dx[i].S,R_ny = pp.S.S+dy[i].S;\n\t  if(!(0<= L_nx & L_nx < W && 0<= L_ny && L_ny < H) || L_cmap[L_ny][L_nx] == '#'){\n\t    L_nx = pp.F.F,L_ny = pp.F.S;\n\t  }\n\t  if(!(0<= R_nx & R_nx < W && 0<= R_ny && R_ny < H) || R_cmap[R_ny][R_nx] == '#'){\n\t    R_nx = pp.S.F,R_ny = pp.S.S;\n\t  }\n\t  if(bmap[L_nx][L_ny][R_nx][R_ny])continue;\n\t  bmap[L_nx][L_ny][R_nx][R_ny] = true;\n\t \n\t  que.push(insert(L_nx,L_ny,R_nx,R_ny));\n\t}\n      }\n    if(!fin)cout << \"No\" << endl;\n    \n  }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\nusing namespace std;\n\nstruct Data{int x[2],y[2];};\nData start,goal;\n\nint W,H;\nvector< vector<string> >room(2);\n\nint dx[2][4]={{0,1,0,-1}, {0,-1,0,1}};\nint dy[2][4]={{-1,0,1,0}, {-1,0,1,0}};\n\nbool operator<(Data a, Data b){\n  return a.x[0]!=b.x[0]?a.x[0]<b.x[0]:(a.y[0]!=b.y[0]?a.y[0]<b.y[0]:(\n           a.x[1]!=b.x[1]?a.x[1]<b.x[1]:a.y[1]<b.y[1]\n         ));\n}\nbool operator==(Data a, Data b){\n  return a.x[0]==b.x[0] && a.x[1]==b.x[1] && a.y[0]==b.y[0] && a.y[1]==b.y[1];\n}\nbool over(Data a){\n  return a.x[0]<0 || W<=a.x[0] || a.y[0]<0 || H<=a.y[0] ||\n         a.x[1]<0 || W<=a.x[1] || a.y[1]<0 || H<=a.y[1];\n}\n\nbool bfs()\n{\n  queue<Data>q;\n  q.push(start);\n  map<Data,bool>visited;\n\n  while(!q.empty()){\n    Data now=q.front();\n    q.pop();\n\n    visited[now]=true;\n\n    if(now==goal)return true;\n    if(now.x[0]==goal.x[0] && now.y[0]==goal.y[0])continue;\n    if(now.x[1]==goal.x[1] && now.y[1]==goal.y[1])continue;\n\n    for(int i=0;i<4;i++){\n      Data next=now;\n      for(int j=0;j<2;j++){\n\tnext.x[j]+=dx[j][i];\n\tnext.y[j]+=dy[j][i];\n\tif(over(next)){\n\t  next.x[j]=now.x[j];\n\t  next.y[j]=now.y[j];\n\t}\n\tif(room[j][next.y[j]][next.x[j]]=='#'){\n\t  next.x[j]=now.x[j];\n\t  next.y[j]=now.y[j];\n\t}\n      }\n      if(visited.count(next))continue;\n      q.push(next);\n    }\n  }\n\n  return false;\n}\n\nint main()\n{\n  while(cin>>W>>H,W|H){\n    room[0].resize(H);\n    room[1].resize(H);\n    for(int i=0;i<H;i++){\n      cin>>room[0][i]>>room[1][i];\n      for(int j=0;j<W;j++){\n\tif(room[0][i][j]=='L'){\n\t  start.x[0]=j;\n\t  start.y[0]=i;\n\t}\n\tif(room[1][i][j]=='R'){\n\t  start.x[1]=j;\n\t  start.y[1]=i;\n\t}\n\tif(room[0][i][j]=='%'){\n\t  goal.x[0]=j;\n\t  goal.y[0]=i;\n\t}\n\tif(room[1][i][j]=='%'){\n\t  goal.x[1]=j;\n\t  goal.y[1]=i;\n\t}\n      }\n    }\n\n    puts(bfs()?\"Yes\":\"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> Point;\ntypedef pair<Point, Point> State;\n\nconst int N = 50;\n\nint w, h;\nchar room[2][N][N];\nbool vis[N][N][N][N];\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = {0, 1, 0, -1};\n\nvoid check(int& y, int& x){\n  if(y < 0) y = 0;\n  if(y >= h) y = h-1;\n  if(x < 0) x = 0;\n  if(x >= w) x = w-1;\n}\n\nbool bfs(Point l, Point r){\n  queue<State> q;\n  State u;\n  vis[l.first][l.second][r.first][r.second] = true;\n  q.push(State(l, r));\n  while(!q.empty()){\n    u = q.front(); q.pop();\n    l = u.first;\n    r = u.second;\n    if(room[0][l.first][l.second] == '%' && room[1][r.first][r.second] == '%'){\n      return true;\n    }else if(room[0][l.first][l.second] == '%' || room[1][r.first][r.second] == '%'){\n      continue;\n    }else{\n      for(int i=0;i<4;i++){\n        Point nl = Point(l.first + dy[i], l.second + dx[i]);\n        Point nr = Point(r.first + dy[i], r.second - dx[i]);\n        check(nl.first, nl.second);\n        check(nr.first, nr.second);\n        if(room[0][nl.first][nl.second] == '#') nl = l;\n        if(room[1][nr.first][nr.second] == '#') nr = r;\n        if(vis[nl.first][nl.second][nr.first][nr.second]) continue;\n        vis[nl.first][nl.second][nr.first][nr.second] = true;\n        q.push(State(nl, nr));\n      }\n    }\n  }\n  return false;\n}\n\nmain(){\n  Point l, r;\n  while(cin >> w >> h && (w|h)){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> room[0][i][j];\n        if(room[0][i][j] == 'L'){\n          l = Point(i, j);\n          room[0][i][j] = '.';\n        }\n      }\n      for(int j=0;j<w;j++){\n        cin >> room[1][i][j];\n        if(room[1][i][j] == 'R'){\n          r = Point(i, j);\n          room[1][i][j] = '.';\n        }\n      }      \n    }\n    fill(vis[0][0][0], vis[N][0][0], false);\n    cout << (bfs(l, r) ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<cmath>\n#include<utility>\n#include<functional>\n#include<map>\n#include<set>\n#include<cctype>\n\n\n#define FOR(i, a, b) for( int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for( int i=(a);i>=(b);i--)\n#define LFOR(i, a, b) for( long long int i=(a);i<=(b);i++)\n#define LRFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LLINF 1000000000000000000 //9000000000000000000\n#define PI 3.14159265358979\n#define MAXI 7500000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\n\nint dy[4] = { 0,0,1,-1 };\nint dx[4] = { 1,-1,0,0 };\n\n//int dp[50][50][50][50] = {};//ly,lx,ry,rx\n\n\nint main(void) {\n\t\n\twhile (1) {\n\n\t\tint w, h;\n\t\tint lx = -1, ly = -1, rx = -1, ry = -1;\n\t\tint lgx = -1, lgy = -1, rgx = -1, rgy = -1;\n\n\t\tvector< vector< vector< vector<int> > > > dp(50, vector< vector< vector<int > > >(50, vector< vector<int> >(50, vector<int>(50, 0))));\n\t\t\n\n\t\tpair< pair<int, int>, pair<int, int>> Pair;\n\n\t\tqueue<pair< pair<int, int>, pair<int, int > > > que;\n\n\t\tcin >> w >> h;\n\n\t\tif (w == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tvector<string> left(h), right(h);\n\n\t\tFOR(i, 0, h-1) {\n\t\t\tcin >> left[i] >> right[i];\n\t\t}\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (left[i][j] == 'L') {\n\t\t\t\t\tlx = j;\n\t\t\t\t\tly = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (right[i][j] == 'R') {\n\t\t\t\t\trx = j;\n\t\t\t\t\try = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (left[i][j] == '%') {\n\t\t\t\t\tlgx = j;\n\t\t\t\t\tlgy = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lgx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (right[i][j] == '%') {\n\t\t\t\t\trgx = j;\n\t\t\t\t\trgy = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rgx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdp[ly][lx][ry][rx] = 1;\n\n\t\t\n\t\t\n\t\tque.push(make_pair(make_pair(ly,lx),make_pair(ry,rx)));\n\n\n\t\twhile (!que.empty()) {\n\t\t\tPair = que.front();\n\t\t\t\n\t\t\tque.pop();\n\t\t\tly = Pair.first.first;\n\t\t\tlx = Pair.first.second;\n\t\t\try = Pair.second.first;\n\t\t\trx = Pair.second.second;\n\t\t\t//cout << ly << \" \" << lx << \" \" << ry << \" \" << rx << endl;\n\n\t\t\tFOR(i, 0, 3) {\n\t\t\t\t\n\t\t\t\tif (ly + dy[i] >= 0 && lx - dx[i] >= 0 && ry + dy[i] <= h - 1 && rx + dx[i] <= w - 1 && ly + dy[i] <= h - 1 && lx - dx[i] <= w - 1 && ry + dy[i] >= 0 && rx + dx[i] >= 0) {\n\t\t\t\t\tif (dp[ly + dy[i]][lx - dx[i]][ry + dy[i]][rx + dx[i]] != 1) {\n\t\t\t\t\t\tif (left[ly + dy[i]][lx - dx[i]] == '#') {\n\t\t\t\t\t\t\tif (right[ry + dy[i]][rx + dx[i]] == '#') {\n\t\t\t\t\t\t\t\t//no\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdp[ly][lx][ry + dy[i]][rx + dx[i]] = 1;\n\t\t\t\t\t\t\t\tque.push(make_pair(make_pair(ly, lx), make_pair(ry + dy[i], rx + dx[i])));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (right[ry + dy[i]][rx + dx[i]] == '#') {\n\t\t\t\t\t\t\t\tdp[ly + dy[i]][lx - dx[i]][ry][rx] = 1;\n\t\t\t\t\t\t\t\tque.push(make_pair(make_pair(ly + dy[i], lx - dx[i]), make_pair(ry, rx)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdp[ly + dy[i]][lx - dx[i]][ry + dy[i]][rx + dx[i]] = 1;\n\t\t\t\t\t\t\t\tque.push(make_pair(make_pair(ly + dy[i], lx - dx[i]), make_pair(ry + dy[i], rx + dx[i])));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (dp[lgy][lgx][rgy][rgx] == 1) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t\t\n\n\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=998244353,MAX=53,INF=1<<30;\nvector<int> dh={0,1,0,-1},dw={1,0,-1,0};\nbool seen[MAX][MAX][MAX][MAX],can[MAX][MAX][2];\n\nint sh1,sw1,sh2,sw2,gh1,gw1,gh2,gw2;\n\nint H,W;\n\nstruct point{\n    int hh1;\n    int ww1;\n    int hh2;\n    int ww2;\n};\n\nvoid DFS(int h11,int w11,int h22,int w22){\n    stack<point> ST;\n    ST.push(point{h11,w11,h22,w22});\n    seen[h11][w11][h22][w22]=1;\n    \n    while(!ST.empty()){\n        point p=ST.top();ST.pop();\n        int h1=p.hh1,w1=p.ww1,h2=p.hh2,w2=p.ww2;\n        \n        for(int k=0;k<4;k++){\n            int toh1,tow1,toh2,tow2;\n            toh1=h1+dh[k];\n            tow1=w1+dw[k];\n            toh2=h2+dh[k];\n            tow2=w2-dw[k];\n            \n            if(toh1<0||toh1>=H||tow1<0||tow1>=W||can[toh1][tow1][0]==0){\n                toh1=h1;\n                tow1=w1;\n            }\n            \n            if(toh2<0||toh2>=H||tow2<0||tow2>=W||can[toh2][tow2][1]==0){\n                toh2=h2;\n                tow2=w2;\n            }\n            \n            if(h1==toh1&&h2==toh2&&w1==tow1&&w2==tow2) continue;\n            \n            if(toh1==gh1&&tow1==gw1){\n                if(toh2!=gh2||tow2!=gw2) continue;\n            }\n            \n            if(toh2==gh2&&tow2==gw2){\n                if(toh1!=gh1||tow1!=gw1) continue;\n            }\n            \n            if(seen[toh1][tow1][toh2][tow2]==0){\n                seen[toh1][tow1][toh2][tow2]=1;\n                ST.push(point{toh1,tow1,toh2,tow2});\n                //break;\n            }\n        }\n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        cin>>W>>H;\n        if(H+W==0) break;\n        memset(seen,0,sizeof(seen));\n        memset(can,0,sizeof(can));\n        //int sh1,sw1,sh2,sw2,gh1,gw1,gh2,gw2;\n        \n        for(int i=0;i<H;i++){\n            string S,T;cin>>S>>T;\n            for(int j=0;j<W;j++){\n                if(S[j]!='#') can[i][j][0]=1;\n                if(S[j]=='L'){\n                    sh1=i;\n                    sw1=j;\n                }\n                if(S[j]=='%'){\n                    gh1=i;\n                    gw1=j;\n                }\n            }\n            for(int j=0;j<W;j++){\n                if(T[j]!='#') can[i][j][1]=1;\n                if(T[j]=='R'){\n                    sh2=i;\n                    sw2=j;\n                }\n                if(T[j]=='%'){\n                    gh2=i;\n                    gw2=j;\n                }\n            }\n        }\n        \n        DFS(sh1,sw1,sh2,sw2);\n        \n        if(seen[gh1][gw1][gh2][gw2]) cout<<\"Yes\"<<endl;\n        else cout<<\"No\"<<endl;\n    }\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// テ・ツ淞コテヲツ慊ャテ」ツδ?」ツδウテ」ツδ療」ツδャテ」ツδシテ」ツδ?\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nconst int S = 51;\n// ax, ay, bx, by\nbool visited[S][S][S][S];\nint W, H;\n\nstruct Elem {\n    int ax, ay, bx, by;\n};\n\npii search_p(const vector<string> &vs, char target) {\n    rep(i,0,H) rep(j,0,W) {\n        if(vs[i][j] == target) return make_pair(i, j);\n    }\n    return make_pair(-1, -1);\n}\n\nvoid move_p(const vector<string> &vs, int &x, int &y, int dir, int mode) {\n    int nx = max(0LL, min(H-1, x + dx[dir]));\n    int ny = max(0LL, min(W-1, y + dy[dir] * mode));\n    if(vs[nx][ny] == '#') return;\n    x = nx;\n    y = ny;\n}\n\nsigned main() {\n    while(cin >> W >> H, W || H) {\n        memset(visited, false, sizeof(visited));\n\n        vector<string> lboard(H), rboard(H);\n        rep(i,0,H) cin >> lboard[i] >> rboard[i];\n        pii init_a = search_p(lboard, 'L');\n        pii init_b = search_p(rboard, 'R');\n        int a = init_a.first, b = init_a.second;\n        int x = init_b.first, y = init_b.second;\n\n        pii goal_a = search_p(lboard, '%');\n        pii goal_b = search_p(rboard, '%');\n        int A = goal_a.first, B = goal_a.second;\n        int X = goal_b.first, Y = goal_b.second;\n\n        queue<Elem> que;\n        que.push(Elem{a, b, x, y});\n        visited[a][b][x][y] = true;\n        while(!que.empty()) {\n            Elem cur = que.front(); que.pop();\n            rep(k,0,4) {\n                Elem nxt = cur;\n                move_p(lboard, nxt.ax, nxt.ay, k, -1);\n                move_p(rboard, nxt.bx, nxt.by, k, 1);\n                if(visited[nxt.ax][nxt.ay][nxt.bx][nxt.by]) continue;\n                bool p = make_pair(nxt.ax, nxt.ay) == goal_a;\n                bool q = make_pair(nxt.bx, nxt.by) == goal_b;\n                if(p ^ q) continue;\n                visited[nxt.ax][nxt.ay][nxt.bx][nxt.by] = true;\n                que.push(nxt);\n            }\n        }\n\n        if(!visited[A][B][X][Y]) cout << \"No\" << endl;\n        else cout << \"Yes\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n#include<queue>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\nint W, H;\t\t\t\nconst int MAX = 51;\nbool is_visit[MAX][MAX][MAX][MAX];\t\t\t\nint dx[4] = {0, 1, -1, 0};\nint dy[4] = {1, 0, 0, -1};\n\nstruct Point { \n\tint x, y; \n\tPoint(int x_ = 0, int y_ = 0): x(x_), y(y_) {}\n\tPoint operator+(const Point &p) const { return Point(x + p.x, y + p.y); }\n\tbool operator==(const Point &p) const { return (x == p.x && y == p.y); }\n};\n\nstruct state {\n\tPoint len, rin;\n\tstate(Point len_, Point rin_): len(len_), rin(rin_) {}\n};\n\nbool can_move(Point p, vector<vector<char>> &room) {\n\tif(p.x < 0 || p.x >= W || p.y < 0 || p.y >= H) return false; \n\tif(room[p.y][p.x] == '#') return false;\t\n\treturn true;\n}\n\nint main() {\n\twhile(cin >> W >> H && W) {\n\t\tvector<vector<char>> l_room(H, vector<char>(W, '.'));\t\n\t\tvector<vector<char>> r_room(H, vector<char>(W, '.'));\t\n\t\tfill_n((bool *)is_visit, MAX*MAX*MAX*MAX, false);\n\n\t\tPoint s_len, g_len, s_rin, g_rin;\n\t\trep(y, H) {\n\t\t\trep(x, W){\n\t\t\t\tcin >> l_room[y][x];\n\t\t\t\tif(l_room[y][x] == 'L')\ts_len = {x, y};\n\t\t\t\telse if(l_room[y][x] == '%') g_len = {x, y};\n\t\t\t}\n\t\t\trep(x, W) {\n\t\t\t\tcin >> r_room[y][x];\n\t\t\t\tif(r_room[y][x] == 'R')\ts_rin = {x, y};\n\t\t\t\telse if(r_room[y][x] == '%') g_rin = {x, y};\n\t\t\t}\t\n\t\t}\n\n\t\t// ????????????????¨??????????\t\n\t\tqueue<state> que;\n\t\tque.push(state(s_len, s_rin));\n\t\tis_visit[s_len.x][s_len.y][s_rin.x][s_rin.y] = true;\n\n\t\tbool is_clear = false;\n\t\twhile(!que.empty()) {\n\t\t\tstate st = que.front(); que.pop();\n\t\t\tPoint len = st.len;\t\t\n\t\t\tPoint rin = st.rin;\t\t\n\t\t\trep(i, 4) {\n\t\t\t\t// ?¬??????????????±??????????\t\n\t\t\t\tPoint l = len + Point(dx[i], dy[i]);\t\n\t\t\t\tPoint r = rin + Point(dx[i]*-1, dy[i]);\t\n\t\t\t\tif(!can_move(l, l_room)) l = len;\t\n\t\t\t\tif(!can_move(r, r_room)) r = rin;\t\n\t\t\t\n\t\t\t\t// ?¬???????????????¢????¨??????????????¢??????????\n\t\t\t\tif(is_visit[l.x][l.y][r.x][r.y]) continue;\n\t\t\t\tif(l == g_len && r == g_rin) { is_clear = true; goto end; }\n\t\t\t\t\n\t\t\t\t// ?????¨?????¶???????¨??????????????????? \t\n\t\t\t\tis_visit[l.x][l.y][r.x][r.y] = true;\n\t\t\t\tif(l == g_len || r == g_rin) continue; // ????????????????????????\n\t\t\t\tque.push(state(l, r));\n\t\t\t}\n\t\t}\nend:\t\n\t\tcout << (is_clear ? \"Yes\" : \"No\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <sstream>\n\nusing namespace std;\n\nstruct pos{\n\tint x1;\n\tint y1;\n\tint x2;\n\tint y2;\n};\n\nint W, H;\nbool memo[60][60][60][60];\n\nstring field1[60], field2[60];\n\nbool check1(int x, int y){\n\tif(x < 0 || y < 0 || x >= W || y >= H){\n\t\treturn true;\n\t}else if(field1[y][x] == '#'){\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool check2(int x, int y){\n\tif(x < 0 || y < 0 || x >= W || y >= H){\n\t\treturn true;\n\t}else if(field2[y][x] == '#'){\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main(){\n\t\n\twhile(true){\n\t\t\n\t\tcin >> W >> H;\n\t\tif(W == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tcin >> field1[i] >> field2[i];\n\t\t}\n\t\t\n\t\tfor(int i = 0; i <= 50; i++){\n\t\t\tfor(int j = 0; j <= 50; j++){\n\t\t\t\tfor(int k = 0; k <= 50; k++){\n\t\t\t\t\tfor(int l = 0; l <= 50; l++){\n\t\t\t\t\t\tmemo[i][j][k][l] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ini_x1, ini_x2, ini_y1, ini_y2;\n\t\tint goal_x1, goal_x2, goal_y1, goal_y2;\n\t\t\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\tif(field1[i][j] == 'L'){\n\t\t\t\t\tini_x1 = j;\n\t\t\t\t\tini_y1 = i;\n\t\t\t\t}\n\t\t\t\tif(field2[i][j] == 'R'){\n\t\t\t\t\tini_x2 = j;\n\t\t\t\t\tini_y2 = i;\n\t\t\t\t}\n\t\t\t\tif(field1[i][j] == '%'){\n\t\t\t\t\tgoal_x1 = j;\n\t\t\t\t\tgoal_y1 = i;\n\t\t\t\t}\n\t\t\t\tif(field2[i][j] == '%'){\n\t\t\t\t\tgoal_x2 = j;\n\t\t\t\t\tgoal_y2 = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<pos> que;\n\t\tpos pos_first;\n\t\tpos_first.x1 = ini_x1;\n\t\tpos_first.y1 = ini_y1;\n\t\tpos_first.x2 = ini_x2;\n\t\tpos_first.y2 = ini_y2;\n\t\tque.push(pos_first);\n\t\t\n\t\tmemo[ini_x1][ini_y1][ini_x2][ini_y2] = true;\n\t\t\n\t\tint dx_[4] = {1, 0, -1, 0};\n\t\tint dy_[4] = {0, 1, 0, -1};\n\t\t\n\t\tbool flag = false;\n\t\t\n\t\twhile(!que.empty()){\n\t\t\t\n\t\t\tpos p = que.front();\n\t\t\tque.pop();\n\t\t\t\n\t\t\t//cout << p.x1 << \" \" << p.y1 << \" \" << p.x2 << \" \" << p.y2 << endl;\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint dx1 = dx_[i];\n\t\t\t\tint dy1 = dy_[i];\n\t\t\t\tint dx2 = -dx1;\n\t\t\t\tint dy2 = dy1;\n\t\t\t\tif(check1(p.x1 + dx1, p.y1 + dy1)){\n\t\t\t\t\tdx1 = 0;\n\t\t\t\t\tdy1 = 0;\n\t\t\t\t}\n\t\t\t\tif(check2(p.x2 + dx2, p.y2 + dy2)){\n\t\t\t\t\tdx2 = 0;\n\t\t\t\t\tdy2 = 0;\n\t\t\t\t}\n\t\t\t\tpos pp;\n\t\t\t\tpp.x1 = p.x1 + dx1;\n\t\t\t\tpp.y1 = p.y1 + dy1;\n\t\t\t\tpp.x2 = p.x2 + dx2;\n\t\t\t\tpp.y2 = p.y2 + dy2;\n\t\t\t\tif(memo[pp.x1][pp.y1][pp.x2][pp.y2]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif((pp.x1 == goal_x1 && pp.y1 == goal_y1) || (pp.x2 == goal_x2 && pp.y2 == goal_y2)){\n\t\t\t\t\tif((pp.x1 == goal_x1 && pp.y1 == goal_y1) && (pp.x2 == goal_x2 && pp.y2 == goal_y2)){\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmemo[pp.x1][pp.y1][pp.x2][pp.y2] = true;\n\t\t\t\tque.push(pp);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(flag){\n\t\t\tcout << \"Yes\" << endl;\n\t\t}else{\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> P;\n\nstruct state{\n    int ly, lx, ry, rx;\n};\nint w, h;\nbool contain(int y, int x){\n    return (0 <= y && y < h && 0 <= x && x < w);\n}\nint dy[4] = {1, -1, 0, 0};\nint dx[4] = {0, 0, 1, -1};\nbool f[51][51][51][51];\n\nsigned main(){\n    while(1){\n        cin >> w >> h;\n        if(w + h == 0) break;\n        vector<string> s(h), t(h);\n        bool ans = false;\n        int lsy, lsx, lgy, lgx, rsy, rsx, rgy, rgx;\n        rep(i, 0, h){\n            cin >> s[i] >> t[i];\n            rep(j, 0, w){\n                if(s[i][j] == 'L'){ lsy = i; lsx = j;}\n                if(s[i][j] == '%'){ lgy = i; lgx = j;}\n                if(t[i][j] == 'R'){ rsy = i; rsx = j;}\n                if(t[i][j] == '%'){ rgy = i; rgx = j;}\n            }\n        }\n        queue<state> q;\n        q.push((state){lsy, lsx, rsy, rsx});\n        rep(i, 0, 51) rep(j, 0, 5) rep(k, 0, 51) rep(l, 0, 51) f[i][j][k][l] = false;\n        f[lsy][lsx][rsy][rsx] = true;\n        while(!q.empty()){\n            state p = q.front(); q.pop();\n            // cout << p.ly << \" \" << p.lx << \" \" << p.ry << \" \" << p.rx << endl;\n            rep(i, 0, 4){\n                int nly = p.ly + dy[i];\n                int nlx = p.lx + dx[i];\n                int nry = p.ry + dy[i];\n                int nrx = p.rx - dx[i];\n                if(!contain(nly, nlx) || s[nly][nlx] == '#'){ nly = p.ly; nlx = p.lx;}\n                if(!contain(nry, nrx) || t[nry][nrx] == '#'){ nry = p.ry; nrx = p.rx;}\n                if(f[nly][nlx][nry][nrx]) continue;\n                f[nly][nlx][nry][nrx] = true;\n                if(s[nly][nlx] == '%' && t[nry][nrx] == '%'){ ans = true; break;}\n                else if(s[nly][nlx] == '%' || t[nry][nrx] == '%') continue;\n                q.push((state){nly, nlx, nry, nrx});\n            }\n            if(ans == true) break;\n        }\n        cout << (ans ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define M 52\n#include<cstring>\nusing namespace std;\nbool flag;\nint dx[]={1,-1,0,0},dy[]={0,0,-1,1},w,h;\nchar r[M][M],l[M][M];\nint dp[M][M][M][M];\nvoid func(int ly,int lx,int ry,int rx){\n\tif(flag)\n\treturn;\n\t//cout<<ly<<' '<<lx<<' '<<ry<<' '<<rx<<endl;\n\tif(dp[ly][lx][ry][rx]!=0)\n\treturn;\n\tdp[ly][lx][ry][rx]=1;\n\tif(l[ly][lx]=='%'&&r[ry][rx]=='%'){\n\t\tflag=true;\n\t\treturn;\n\t}else if(l[ly][lx]=='%'||r[ry][rx]=='%')\n\treturn;\n\tint nrx,nry,nlx,nly;\n\tfor(int i=0;i<4;i++){\n\t\tnrx=dx[i]+rx;\n\t\tnry=dy[i]+ry;\n\t\tnlx=-dx[i]+lx;\n\t\tnly=dy[i]+ly;\n\t\tif(!(nrx>=0&&nrx<w&&nry>=0&&nry<h)||r[nry][nrx]=='#'){\n\t\t\tnrx=rx;nry=ry;\n\t\t}\n\t\tif(!(nlx>=0&&nlx<w&&nly>=0&&nly<h)||l[nly][nlx]=='#'){\n\t\t\tnlx=lx;nly=ly;\n\t\t}\n\t\tif(dp[nly][nlx][nry][nrx]==0)\n\t\tfunc(nly,nlx,nry,nrx);\n\t}\n}\nint main(){\n\tint a,b,c,d;\n\twhile(cin>>w>>h,h||w){\n\t\tfor(int i=0;i<h;i++)\n\t\t\tcin>>l[i]>>r[i];\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(l[i][j]=='L'){\n\t\t\t\t\ta=i;b=j;\n\t\t\t\t}\n\t\t\t\tif(r[i][j]=='R'){\n\t\t\t\t\tc=i;d=j;\n\t\t\t\t}\n\t\t}\n\t\tmemset(dp,0,sizeof(dp));\n\t\tflag=false;\n\t\tfunc(a,b,c,d);\n\t\tputs(flag?\"Yes\":\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint ans;\nint h,w;\nstring ma1[55];\nstring ma2[55];\nint dp[55][55][55][55];\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\n\nvoid dfs(int lx,int ly,int rx,int ry){\n  //cout<<lx<<\" \"<<ly<<\" \"<<rx<<\" \"<<ry<<endl;\n  if(dp[lx][ly][rx][ry])return;\n  if(ma1[lx][ly]=='%'&&ma2[rx][ry]=='%'){\n    ans=1;\n    return;\n  }\n  dp[lx][ly][rx][ry]=1;\n  for(int i=0;i<4;i++){\n    int nlx=lx+dx[i];\n    int nly=ly+dy[i];\n    int nrx=rx+dx[i];\n    int nry=ry-dy[i];\n    if(nlx==h||nlx<0)nlx=lx;\n    if(nly==w||nly<0)nly=ly;\n    if(ma1[nlx][nly]=='#')nlx=lx,nly=ly;\n    if(nrx==h||nrx<0)nrx=rx;\n    if(nry==w||nry<0)nry=ry;\n    if(ma2[nrx][nry]=='#')nrx=rx,nry=ry;\n    dfs(nlx,nly,nrx,nry);\n  }\n  return;\n}\n\nint main(){\n  while(cin>>w>>h,w){\n    ans=0;\n    memset(dp,0,sizeof(dp));\n    int sl[2],sr[2];\n    for(int i=0;i<h;i++){\n      cin>>ma1[i]>>ma2[i];\n      for(int j=0;j<w;j++){\n\tif(ma1[i][j]=='L')sl[0]=i,sl[1]=j;\n\tif(ma2[i][j]=='R')sr[0]=i,sr[1]=j;\n      }\n    }\n    dfs(sl[0],sl[1],sr[0],sr[1]);\n    if(ans)cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct data{\n    int ly,lx,ry,rx;\n    data(int ly,int lx,int ry,int rx)\n        :ly(ly),lx(lx),ry(ry),rx(rx){}\n};\n\nconst int dlx[]={-1,0,1,0},dly[]={0,-1,0,1};\nconst int drx[]={1,0,-1,0},dry[]={0,-1,0,1};\n\nconst int INF=1001001001;\nint H,W;\nchar L[51][51],R[51][51];\nint dist[50][50][50][50];\nint sly,slx,sry,srx;\nint gly,glx,gry,grx;\nbool ok(int y,int x,int isL){\n    if(isL)return !(y<0||y>=H||x<0||x>=W||L[y][x]=='#');\n    return !(y<0||y>=H||x<0||x>=W||R[y][x]=='#');\n}\n\nvoid solve(){\n    queue<data>que;\n    fill_n(***dist,50*50*50*50,INF);\n    dist[sly][slx][sry][srx]=0;\n    que.push(data(sly,slx,sry,srx));\n\n    while(que.size()){\n        data d=que.front();que.pop();\n\n        for(int i=0;i<4;i++){\n            int nly=d.ly+dly[i],nlx=d.lx+dlx[i];\n            int nry=d.ry+dry[i],nrx=d.rx+drx[i];\n            if(!ok(nly,nlx,true)){\n                nly=d.ly;nlx=d.lx;\n            }\n            if(!ok(nry,nrx,false)){\n                nry=d.ry;nrx=d.rx;\n            }\n\n            if(dist[nly][nlx][nry][nrx]!=INF)continue;\n            dist[nly][nlx][nry][nrx]=dist[d.ly][d.lx][d.ry][d.rx]+1;\n            que.push(data(nly,nlx,nry,nrx));\n        }\n    }\n\n    if(dist[gly][glx][gry][grx]!=INF)cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n}\n\nint main(){\n    while(cin>>W>>H,W||H){\n        for(int i=0;i<H;i++)cin>>L[i]>>R[i];\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                if(L[i][j]=='L'){\n                    sly=i;slx=j;\n                }\n                if(L[i][j]=='%'){\n                    gly=i;glx=j;\n                }\n                if(R[i][j]=='R'){\n                    sry=i;srx=j;\n                }\n                if(R[i][j]=='%'){\n                    gry=i;grx=j;\n                }\n            }\n        }\n\n        solve();\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint dx[]{ 1,0,-1,0 }, dy[]{ 0,1,0,-1 };\nchar f[2][50][51];\nbool used[50][50][50][50];\nstruct st {\n\tint rx, ry, lx, ly;\n};\nint main() {\n\tint w, h;\n\twhile (scanf(\"%d%d\", &w, &h), w) {\n\t\tmemset(used, 0, sizeof(used));\n\t\tst in;\n\t\trep(i, h * 2) {\n\t\t\tscanf(\"%s\", f[i % 2][i / 2]);\n\t\t\trep(j, w) {\n\t\t\t\tif (f[i % 2][i / 2][j] == 'R')in.rx = i / 2, in.ry = j, f[i % 2][i / 2][j] = '.';\n\t\t\t\tif (f[i % 2][i / 2][j] == 'L')in.lx = i / 2, in.ly = j, f[i % 2][i / 2][j] = '.';\n\t\t\t}\n\t\t}\n\t\tqueue<st>que;\n\t\tque.push(in);\n\t\tused[in.rx][in.ry][in.lx][in.ly] = true;\n\t\twhile (!que.empty()) {\n\t\t\tst s = que.front(); que.pop();\n\t\t\tif (f[1][s.rx][s.ry] == '%'&&f[0][s.lx][s.ly] == '%') {\n\t\t\t\tputs(\"Yes\"); goto g;\n\t\t\t}\n\t\t\trep(i, 4) {\n\t\t\t\tint nrx = s.rx + dx[i], nry = s.ry + dy[i], nlx = s.lx + dx[i], nly = s.ly + dy[(i + 2) % 4];\n\t\t\t\tif (nrx < 0 || nrx >= h || nry < 0 || nry >= w || f[1][nrx][nry] == '#')nrx = s.rx, nry = s.ry;\n\t\t\t\tif (nlx < 0 || nlx >= h || nly < 0 || nly >= w || f[0][nlx][nly] == '#')nlx = s.lx, nly = s.ly;\n\t\t\t\tif (!used[nrx][nry][nlx][nly]) {\n\t\t\t\t\tused[nrx][nry][nlx][nly] = true;\n\t\t\t\t\tque.push({ nrx,nry,nlx,nly });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(\"No\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// tsukasa_diary's programing contest code template\n#include <bits/stdc++.h>\nusing namespace std;\n// define\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n// typedef\ntypedef long long lint;\ntypedef double Double;\ntypedef pair<int, int> pii;\n//\ntypedef vector< int > Array;\ntypedef vector< Array > Matrix;\ntypedef vector< Double > DArray;\ntypedef vector< DArray > DMatrix;\ntypedef vector< string > SArray;\ntypedef vector< pii > PArray;\n// popcount\ninline int POPCNT(int _x) { return __builtin_popcount(_x); }\ninline int POPCNT(lint _x) { return __builtin_popcountll(_x); }\n// inf\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\n// eps\nDouble EPS = 1e-9;\n// in range\ninline bool in_range(int _v, int _mx, int _mi) { return _mi <= _v && _v < _mx; }\ninline bool in_range(Double _v, Double _mi, Double _mx) { return -EPS < _v - _mi && _v - _mx < EPS; }\ninline bool in_range(int _x, int _y, int _W, int _H) { return 0 <= _x && _x < _W && 0 <= _y && _y < _H; }\n// neighbor clockwise\nconst int DX[4] = {0,1,0,-1}, DY[4] = {-1,0,1,0};\nconst int DX_[8] = {0,1,1,1,0,-1,-1,-1}, DY_[8] = {-1,-1,0,1,1,1,0,-1};\n\nint W, H;\nint srx, sry, slx, sly;\nstring roomL[55], roomR[55];\n\nbool visit[55][55][55][55];\n\nbool rec(int lx, int ly, int rx, int ry) {\n\tif (visit[ly][lx][ry][rx]) return false;\n\tvisit[ly][lx][ry][rx] = true;\n\tif (roomL[ly][lx] == '%' && roomR[ry][rx] == '%') return true;\n\t\n\tfor_(d,0,4) {\n\t\tint nlx = lx + DX[d], nly = ly + DY[d];\n\t\tint nrx = rx, nry = ry;\n\t\tif (d != 0 && d != 2) nrx += DX[(d + 2) % 4], nry += DY[(d + 2) % 4];\n\t\telse nrx += DX[d], nry += DY[d];\n\n\t\tif (!in_range(nlx, nly, W, H)) {\n\t\t\tnlx = lx;\n\t\t\tnly = ly;\n\t\t} else if (roomL[nly][nlx] == '#') {\n\t\t\tnlx = lx;\n\t\t\tnly = ly;\n\t\t}\n\t\t\n\t\tif (!in_range(nrx, nry, W, H)) {\n\t\t\tnrx = rx;\n\t\t\tnry = ry;\n\t\t} else if (roomR[nry][nrx] == '#') {\n\t\t\tnrx = rx;\n\t\t\tnry = ry;\n\t\t}\n\t\t\n\t\tif (rec(nlx, nly, nrx, nry)) return true;\n\t}\n\t\n\treturn false;\n}\n\nvoid solve() {\n\tminit(visit, 0);\n\t\n\tif (rec(slx, sly, srx, sry)) {\n\t\tcout << \"YES\" << endl;\n\t} else {\n\t\tcout << \"NO\" << endl;\n\t}\n}\n\nint main() {\n\twhile (cin >> W >> H, W) {\n\t\tfor_(i,0,H) {\n\t\t\tcin >> roomL[i] >> roomR[i];\n\t\t\tfor_(j,0,W) {\n\t\t\t\tif (roomL[i][j] == 'L') slx = j, sly = i;\n\t\t\t\tif (roomR[i][j] == 'R') srx = j, sry = i;\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define pb push_back\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nconst P dx[4] = {P(0,0),P(0,0),P(-1,1),P(1,-1)};\nconst P dy[4] = {P(1,1),P(-1,-1),P(0,0),P(0,0)};\nbool bmap[55][55][55][55];\nchar L_cmap[51][51],R_cmap[51][51];\nint main(){\n  int H,W;\n  while(cin >> W >> H && H+W){\n   \n    P Ls,Rs,Lg,Rg;\n    rep(i,55)\n      rep(j,55)\n        rep(k,55)\n          rep(l,55)\n            bmap[i][j][k][l] = false;\n   \n    rep(i,H){\n      string s;\n      cin >> s;\n      rep(j,W){\n\tL_cmap[i][j] = s[j];\n\tif(s[j] == 'L')Ls = P(j,i);\n\tif(s[j] == '%')Lg = P(j,i);\n      }\n      s.clear();\n      cin >> s;\n      rep(j,W){\n\tR_cmap[i][j] = s[j];\n\tif(s[j] == 'R')Rs = P(j,i);\n\tif(s[j] == '%')Rg = P(j,i);\n      }\n    }\n  \n    queue<PP> que;\n    que.push(PP(Ls,Rs));\n    bmap[Ls.F][Ls.S][Rs.F][Rs.S] = true;\n    bool fin = false;\n    while(!que.empty())\n      {\n\tPP pp = que.front(); que.pop();\n\tif(pp.F == Lg && pp.S == Rg){\n\t  fin = true;\n\t  cout << \"Yes\" << endl;\n\t  break;\n\t}\n\tif(pp.F == Lg || pp.S == Rg)continue;\n\n\trep(i,4){\n\t  int L_nx = pp.F.F+dx[i].F,L_ny = pp.F.S+dy[i].F;\n\t  int R_nx = pp.S.F+dx[i].S,R_ny = pp.S.S+dy[i].S;\n\t  if(!(0<= L_nx & L_nx < W && 0<= L_ny && L_ny < H) || L_cmap[L_ny][L_nx] == '#'){\n\t    L_nx = pp.F.F,L_ny = pp.F.S;\n\t  }\n\t  if(!(0<= R_nx & R_nx < W && 0<= R_ny && R_ny < H) || R_cmap[R_ny][R_nx] == '#'){\n\t    R_nx = pp.S.F,R_ny = pp.S.S;\n\t  }\n\t  if(bmap[L_nx][L_ny][R_nx][R_ny])continue;\n\t  bmap[L_nx][L_ny][R_nx][R_ny] = true;\n\t \n\t  que.push(insert(L_nx,L_ny,R_nx,R_ny));\n\t}\n      }\n    if(!fin)cout << \"No\" << endl;\n    \n  }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP(a, b) make_pair(a, b)\n#define Y first\n#define X second\n#define L first\n#define R second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef pair<pi, pi> pipi;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint W, H;\nint dy[] = {0,-1,0,1}, dx[] = {-1,0,1,0};\nchar len[64][64], rin[64][64];\n\nint main(){\n  while(scanf(\"%d%d\", &W, &H) && W){\n    rep(i, H) scanf(\"%s%s\", len[i], rin[i]);\n\n    int ly, lx, ry, rx;\n    rep(i, H) rep(j, W){\n      if(len[i][j] == 'L'){ ly = i, lx = j; len[i][j] = '.';}\n      if(rin[i][j] == 'R'){ ry = i, rx = j; rin[i][j] = '.';}\n    }\n\n    pipi p = MP(MP(ly, lx), MP(ry, rx));\n    queue<pipi>q;\n    map<pipi, int>m;\n    q.push(p);\n    m[p] = 1;\n\n    while(!q.empty()){\n      int qsize = (int)q.size();\n      rep(i, qsize){\n\tpipi now = q.front(); q.pop();\n\trep(d, 4){\n\t  int nly, nlx, nry, nrx;\n\t  if(d%2){\n\t    nly = now.L.Y + dy[d], nlx = now.L.X;\n\t    if(nly < 0 || nly >= H || len[nly][nlx] == '#') nly = now.L.Y; \n\t    nry = now.R.Y + dy[d], nrx = now.R.X;\n\t    if(nry < 0 || nry >= H || rin[nry][nrx] == '#') nry = now.R.Y; \n\t  }else{\n\t    nly = now.L.Y, nlx = now.L.X + dx[d];\n\t    if(nlx < 0 || nlx >= W || len[nly][nlx] == '#') nlx = now.L.X; \t    \n\t    nry = now.R.Y, nrx = now.R.X + -1*dx[d];\n\t    if(nrx < 0 || nrx >= W || rin[nry][nrx] == '#') nrx = now.R.X;\n\t  }\n\n\t  pipi next = MP(MP(nly, nlx), MP(nry, nrx));\n\t  if(len[nly][nlx] == '%' && rin[nry][nrx] == '%'){\n\t    puts(\"Yes\"); goto e;\n\t  }else if(len[nly][nlx] == '%' || rin[nry][nrx] == '%'){\n\t    continue;\n\t  }\n\n\t  if(m.count(next) != 0) continue;\n\t  m[next] = 1;\n\t  q.push(next);\n\t}\n      }\n    }\n    puts(\"No\");\n  e:;\n    m.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Header {{{\n// includes {{{\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <unistd.h>\n#include <vector>\n// }}}\nusing namespace std;\n// consts {{{\nstatic const int INF = 1e9;\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n// }}}\n// typedefs {{{\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<ULL> VULL;\ntypedef vector<VULL> VVULL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\ntypedef complex<char> P;\n#define PQ(type) priority_queue<type>\n// priority queue reverse\n#define PQR(type) priority_queue< type, vector<type>, greater<type> >\n// }}}\n// macros & inline functions {{{\n// syntax sugars {{{\n#define FOR(i, b, e) for (typeof(e) i = (b); i < (e); ++i)\n#define FORI(i, b, e) for (typeof(e) i = (b); i <= (e); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(i, n) FORI(i, 0, n)\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n#define ASSIGN_MAX(var, val) ((var) = max((var), (val)))\n#define ASSIGN_MIN(var, val) ((var) = min((var), (val)))\n// }}}\n// conversion {{{\ninline int toInt(string s) { int v; istringstream sin(s); sin>>v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout<<x; return sout.str(); }\n// }}}\n// array and STL {{{\n#define ARRSIZE(a) ( sizeof(a) / sizeof(a[0]) )\n#define ZERO(a, v) ( assert(v == 0 || v == -1), memset(a, v, sizeof(a)) )\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define SIZE(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c, it) for(typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define REACH(c, it) for(typeof((c).rbegin()) it=(c).rbegin(); it!=(c).rend(); ++it)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n// }}}\n// bit manipulation {{{\n// singed integers are not for bitwise operations, specifically arithmetic shifts ('>>', and maybe not good for '<<' too)\n#define IS_UNSIGNED(n) (!numeric_limits<typeof(n)>::is_signed)\n#define BIT(n) (assert(IS_UNSIGNED(n)), assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(IS_UNSIGNED(n)), assert(m < 64), ((ULL)(n) >> (m) & 1))\ninline int BITS_COUNT(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int MSB(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c-1; }\ninline int MAKE_MASK(ULL upper, ULL lower) { assert(lower < 64 && upper < 64 && lower <= upper); return (BIT(upper) - 1) ^ (BIT(lower) - 1); }\n// }}}\n// for readable code {{{\n#define EVEN(n) (n % 2 == 0)\n#define ODD(n) (!EVEN(n))\n// }}}\n// debug {{{\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n#define dprt(fmt, ...) if (opt_debug) { fprintf(stderr, fmt, ##__VA_ARGS__); }\n#define darr(a) if (opt_debug) { copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr_range(a, f, t) if (opt_debug) { copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define dvec(v) if (opt_debug) { copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr2(a) if (opt_debug) { FOR(__i, 0, (arrsz(a))){ darr( (a)[__i] ); } }\n#define WAIT() if (opt_debug) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#define dump(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl; }\n// dump vector elements in [s, e)\n#define dumpv(v, s, e) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #v << \" = \"; FOR(__i, s, e) { cerr << v[__i] << \"\\t\"; } cerr << endl; }\n#define dumpl(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << endl << (x) << endl; }\n#define dumpf() if (opt_debug) { cerr << __PRETTY_FUNCTION__ << endl; }\n#define where() if (opt_debug) { cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl; }\n#define dumpb(bit, digits) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #bit << \" = \"; for(int __i = digits - 1; __i >= 0; __i--) { cerr << static_cast<bool>(bit & (1 << __i)); if (__i % 4 == 0) { cerr << \" \"; } } cerr << endl; }\n\n// ostreams {{{\n// complex\ntemplate<typename T> ostream& operator<<(ostream& s, const complex<T>& d) {return s << \"(\" << d.real() << \", \" << d.imag() << \")\";}\n\n// pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n// vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i]; if (i < len - 1) s << \"\\t\";\n\t}\n\treturn s;\n}\n\n// 2 dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i] << endl;\n\t}\n\treturn s;\n}\n\n// map\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const map<T1, T2>& m) {\n\ts << \"{\" << endl;\n\tfor (typeof(m.begin()) itr = m.begin(); itr != m.end(); ++itr) {\n\t\ts << \"\\t\" << (*itr).first << \" : \" << (*itr).second << endl;\n\t}\n\ts << \"}\" << endl;\n\treturn s;\n}\n// }}}\n// }}}\n// }}}\n// time {{{\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\n// }}}\n// string manipulation {{{\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\ninline string join(VS s, string j) { string t; REP(i, s.size()) { t += s[i] + j; } return t; }\n// }}}\n// geometry {{{\n#define Y real()\n#define X imag()\n// }}}\n// 2 dimentional array {{{\nenum { UP, RIGHT, DOWN, LEFT, UP_RIGHT, DOWN_RIGHT, DOWN_LEFT, UP_LEFT };\nP dydx4[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\nP dydx8[8] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(-1, 1), P(1, 1), P(1, -1), P(-1, -1) };\nbool in_field(int H, int W, P p) {\n\treturn (0 <= p.Y && p.Y < H) && (0 <= p.X && p.X < W);\n}\n// }}}\n// input and output {{{\ninline void input(string filename) {\n\tfreopen(filename.c_str(), \"r\", stdin);\n}\ninline void output(string filename) {\n\tfreopen(filename.c_str(), \"w\", stdout);\n}\n// }}}\n// }}}\n\nint W, H;\nbool opt_debug = false;\ntypedef pair<P, P> PPP;\nP dydx_l[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\nP dydx_r[4] = { P(-1, 0), P(0, -1), P(1, 0), P(0, 1) };\ntypedef pair< pair<char, char>, pair<char, char> > PPIIPII;\nmap< PPIIPII, bool > memo;\n\nbool dfs(VVC &room_l, VVC &room_r, P len, P rin) {\n\tPPIIPII key = MP( MP(len.Y, len.X), MP(rin.Y, rin.X) );\n\tif (EXIST(memo, key)) { return memo[key]; }\n\tmemo[key] = false; // HACK: avoid loop\n\n\tbool ok = false;\n\tif (room_l[len.Y][len.X] == '%' && room_r[rin.Y][rin.X] == '%') {\n\t\treturn memo[key] = true;\n\t}\n\tif (room_l[len.Y][len.X] == '%' || room_r[rin.Y][rin.X] == '%') {\n\t\treturn memo[key] = false;\n\t}\n\tREP (d, 4) {\n\t\tP n_len = len + dydx_l[d];\n\t\tP n_rin = rin + dydx_r[d];\n\t\tif (!in_field(H, W, n_len) || room_l[n_len.Y][n_len.X] == '#') {\n\t\t\tn_len -= dydx_l[d];\n\t\t}\n\t\tif (!in_field(H, W, n_rin) || room_r[n_rin.Y][n_rin.X] == '#') {\n\t\t\tn_rin -= dydx_r[d];\n\t\t}\n\t\tif (len == n_len && rin == n_rin) { continue; }\n\t\tok = ok || dfs(room_l, room_r, n_len, n_rin);\n\t\tif (ok) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn memo[key] = ok;\n}\n\nint main(int argc, char** argv) {\n\tstd::ios_base::sync_with_stdio(false);\n\t// set options {{{\n\tint __c;\n\twhile ( (__c = getopt(argc, argv, \"d\")) != -1 ) {\n\t\tswitch (__c) {\n\t\t\tcase 'd':\n\t\t\t\topt_debug = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tabort();\n\t\t}\n\t}\n\t// }}}\n\n\t// opt_debug = true;\n\t// input(\"./inputs/0.txt\");\n\t// output(\"./outputs/0.txt\");\n\n\twhile (cin >> W >> H, W | H) {\n\t\tmemo.clear();\n\t\tVVC room_l(H, VC(W));\n\t\tVVC room_r(H, VC(W));\n\t\tP len, rin;\n\t\tREP (i, H) {\n\t\t\tREP (j, W) {\n\t\t\t\tcin >> room_l[i][j];\n\t\t\t\tif (room_l[i][j] == 'L') {\n\t\t\t\t\tlen = P(i, j);\n\t\t\t\t\troom_l[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP (j, W) {\n\t\t\t\tcin >> room_r[i][j];\n\t\t\t\tif (room_r[i][j] == 'R') {\n\t\t\t\t\trin = P(i, j);\n\t\t\t\t\troom_r[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool ok = dfs(room_l, room_r, len, rin);\n\t\tif (ok) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t} else {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <string.h>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <set>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\n#define For(i,a,n)\tfor(int i = a;i < n;i++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(n)\t\tmemset(n,0,sizeof n)\n#define all(n)\t\t(n).begin(),(n).end()\n\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\ntypedef pair<P, P> WP;\ntypedef long long ll;\n\nconst ll INF = 1e9;\nint dx[4] = { 0, 1, 0, -1 }, dy[4] = { 1, 0, -1, 0 };\nbool cheak(int x, int y, int mx, int my){\n\treturn x >= 0 && y >= 0 && x < mx &&  y < my;\n}\n\nstring s[2][51];\n\nint d[51][51][51][51];\n\nint main()\n{\n\tint w, h;\n\n\twhile (cin >> w >> h && w){\n\t\tclr(d);\n\t\tint sx[2], sy[2];\n\t\tint gx[2], gy[2];\n\t\trep(y, h){\n\t\t\tcin >> s[0][y] >> s[1][y];\n\t\t\trep(x, w){\n\t\t\t\tif (s[0][y][x] == '%')gx[0] = x, gy[0] = y;\n\t\t\t\tif (s[1][y][x] == '%')gx[1] = x, gy[1] = y;\n\t\t\t\tif (s[0][y][x] == 'L')sx[0] = x, sy[0] = y;\n\t\t\t\tif (s[1][y][x] == 'R')sx[1] = x, sy[1] = y;\n\t\t\t}\n\t\t}\n\t\td[sy[0]][sx[0]][sy[1]][sx[1]] = 1;\n\n\t\tqueue<P> q0, q1;\n\t\tq0.push(P(sy[0], sx[0]));\n\t\tq1.push(P(sy[1], sx[1]));\n\n\t\twhile (q0.size()){\n\t\t\tint ly = q0.front().first, lx = q0.front().second;\n\t\t\tint ry = q1.front().first, rx = q1.front().second;\n\t\t\tq0.pop(), q1.pop();\n\n\t\t\trep(i, 4){\n\t\t\t\tint nlx = lx + dx[i], nly = ly + dy[i];\n\t\t\t\tint nrx = rx - dx[i], nry = ry + dy[i];\n\n\t\t\t\tbool lf = (cheak(nlx, nly, w, h) && s[0][nly][nlx] != '#');\n\t\t\t\tbool rf = (cheak(nrx, nry, w, h) && s[1][nry][nrx] != '#');\n\n\t\t\t\tif ((rf || lf)){\n\t\t\t\t\tif (!lf)nlx = lx, nly = ly;\n\t\t\t\t\tif (!rf)nrx = rx, nry = ry;\n\t\t\t\t\tif (!d[nly][nlx][nry][nrx]){\n\n\t\t\t\t\t\tif (s[0][nly][nlx] == '%' || s[1][nry][nrx] == '%'){\n\t\t\t\t\t\t\tif (!(s[0][nly][nlx] == '%') || !(s[1][nry][nrx] == '%')){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\td[nly][nlx][nry][nrx] = 1;\n\t\t\t\t\t\tq0.push(P(nly, nlx));\n\t\t\t\t\t\tq1.push(P(nry, nrx));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[gy[0]][gx[0]][gy[1]][gx[1]])cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define pb push_back\n#define fi first\n#define sc second\nusing namespace std;\ntypedef pair<int,int> P;\n\nint w, h;\nstring a[50], b[50];\nbool use[50][50][50][50];\nint daw[4] = {1,0,-1,0},dah[4]={0,1,0,-1};\nint dbw[4] = {-1,0,1,0},dbh[4]={0,1,0,-1};\n\nvoid dfs(int p, int q, int r, int s){\n\trep(i,4){\n\t\tint dp = p+dah[i],dq = q+daw[i];\n\t\tint dr = r+dbh[i],ds = s+dbw[i];\n\t\tif(0>dp||dp>=h||0>dq||dq>=w||a[dp][dq]=='#'){\n\t\t\tdp = p;\n\t\t\tdq = q;\n\t\t}\n\t\tif(0>dr||dr>=h||0>ds||ds>=w||a[dr][ds]=='#'){\n\t\t\tdr = r;\n\t\t\tds = s;\n\t\t}\n\t\tif(use[dp][dq][dr][ds]) continue;\n\t\tuse[dp][dq][dr][ds] = true;\n\t\tdfs(dp,dq,dr,ds);\n\t}\n}\n\nint main(){\n\twhile(scanf(\"%d%d\",&w,&h),w||h){\n\t\tmemset(use,0,sizeof(use));\n\t\trep(i,50) a[i].clear();\n\t\trep(i,50) b[i].clear();\n\t\tP as, ae, bs, be;\n\t\trep(i,h) cin >> a[i] >> b[i];\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tif(a[i][j] == '%') as = P(i,j);\n\t\t\t\tif(b[i][j] == '%') bs = P(i,j);\n\t\t\t\tif(a[i][j] == 'L') ae = P(i,j);\n\t\t\t\tif(b[i][j] == 'R') be = P(i,j);\n\t\t\t}\n\t\t}\n\t\tuse[as.fi][as.sc][bs.fi][bs.sc] = true;\n\t\tdfs(as.fi,as.sc,bs.fi,bs.sc);\n\t\tif(use[ae.fi][ae.sc][be.fi][be.sc]) puts(\"Yes\");\n\t\telse puts(\"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint mx[4]={0,1,0,-1};\nint my[4]={1,0,-1,0};\n\nbool memo[50][50][50][50];\n\nint w,h;\n\nbool dfs(pair<int,int>nowL, pair<int,int>nowR, vector<string> &sl,vector<string> &sr){\n    //cout<<nowL.first<<nowL.second<<nowR.first<<nowR.second<<endl;\n    if(memo[nowL.first][nowL.second][nowR.first][nowR.second]){\n        return 0;\n    }else{\n        memo[nowL.first][nowL.second][nowR.first][nowR.second]=1;\n    }\n    if(sl[nowL.first][nowL.second]=='%' && sr[nowR.first][nowR.second]=='%'){\n        return 1;\n    }\n    for(int i=0;i<4;++i){\n        pair<int,int>nextL,nextR;\n        nextL.first=nowL.first+my[i];\n        nextL.second=nowL.second+mx[i];\n        nextR.first=nowR.first+my[i];\n        nextR.second=nowR.second-mx[i];\n        //------------------------------------\n        if(nextL.first<0 || nextL.first>=h){\n            nextL=nowL;\n        }\n        if(nextL.second<0 || nextL.second>=w){\n            nextL=nowL;\n        }\n        if(sl[nextL.first][nextL.second]=='#'){\n            nextL=nowL;\n        }\n        //-------------------------------------\n        if(nextR.first<0 || nextR.first>=h){\n            nextR=nowR;\n        }\n        if(nextR.second<0 || nextR.second>=w){\n            nextR=nowR;\n        }\n        if(sr[nextR.first][nextR.second]=='#'){\n            nextR=nowR;\n        }\n        if(dfs(nextL,nextR,sl,sr))return 1;\n    }\n    return 0;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    while(cin>>w>>h,w){\n        for(int i=0;i<50;++i){\n            for(int j=0;j<50;++j){\n                for(int k=0;k<50;++k){\n                    for(int l=0;l<50;++l){\n                        memo[i][j][k][l]=0;\n                    }\n                }\n            }\n        }\n        vector<string> sl(h),sr(h);\n        pair<int,int>startL,startR;\n        for(int i=0;i<h;++i){\n            cin>>sl[i]>>sr[i];\n            for(int j=0;j<w;++j){\n                if(sl[i][j]=='L'){\n                    startL={i,j};\n                }\n                if(sr[i][j]=='R'){\n                    startR={i,j};\n                }\n            }\n        }\n        if(dfs(startL,startR,sl,sr))cout<<\"Yes\"<<endl;\n        else cout<<\"No\"<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing Coor = pair<int, int>;\nusing Pair = pair<Coor, Coor>;\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {-1, 0, 1, 0};\n\nint H;\nint W;\nint sty[2];\nint stx[2];\nint y[2];\nint x[2];\nchar field[2][50][50];\nbool dp[50][50][50][50];\n\nbool WithinRange(int y, int x) {\n  if (y < 0 || H <= y) return false;\n  if (x < 0 || W <= x) return false;\n  return true;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &W, &H);\n    if (W == 0 && H == 0) return 0;\n\n    for (int i=0; i<H; i++) {\n      for (int j=0; j<W; j++) {\n        scanf(\" %c\", &field[0][i][j]);\n        if (field[0][i][j] == '%') {\n          sty[0] = i;\n          stx[0] = j;\n        } else if (field[0][i][j] == 'L') {\n          y[0] = i;\n          x[0] = j;\n        } else assert(field[0][i][j] == '.' || field[0][i][j] == '#');\n      }\n\n      for (int j=W-1; j>=0; j--) {\n        scanf(\" %c\", &field[1][i][j]);\n        if (field[1][i][j] == '%') {\n          sty[1] = i;\n          stx[1] = j;\n        } else if (field[1][i][j] == 'R') {\n          y[1] = i;\n          x[1] = j;\n        } else assert(field[1][i][j] == '.' || field[1][i][j] == '#');\n      }\n    }\n\n    for (int i=0; i<H; i++) {\n      for (int j=0; j<W; j++) {\n        for (int k=0; k<H; k++) {\n          for (int l=0; l<W; l++) {\n            dp[i][j][k][l] = false;\n          }\n        }\n      }\n    }\n\n    dp[y[0]][x[0]][y[1]][x[1]] = true;\n    queue<Pair> q;\n    q.push(Pair(Coor(y[0], x[0]), Coor(y[1], x[1])));\n    while (!q.empty()) {\n      Pair p = q.front(); q.pop();\n      Coor c1 = p.first;\n      int y1 = c1.first;\n      int x1 = c1.second;\n      Coor c2 = p.second;\n      int y2 = c2.first;\n      int x2 = c2.second;\n\n      for (int i=0; i<4; i++) {\n        int newy1 = y1 + dy[i];\n        int newx1 = x1 + dx[i];\n        if (!WithinRange(newy1, newx1) || field[0][newy1][newx1] == '#') {\n          newy1 -= dy[i];\n          newx1 -= dx[i];\n        }\n\n        int newy2 = y2 + dy[i];\n        int newx2 = x2 + dx[i];\n        if (!WithinRange(newy2, newx2) || field[1][newy2][newx2] == '#') {\n          newy2 -= dy[i];\n          newx2 -= dx[i];\n        }\n\n        if (dp[newy1][newx1][newy2][newx2]) continue;\n        dp[newy1][newx1][newy2][newx2] = true;\n        q.push(Pair(Coor(newy1, newx1), Coor(newy2, newx2)));\n      }\n    }\n\n    if (dp[sty[0]][stx[0]][sty[1]][stx[1]]) puts(\"Yes\");\n    else puts(\"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MAX 51\n#include<cstring>\nusing namespace std;\n\nbool f=false,visited[MAX][MAX][MAX][MAX];\nint w,h;\nchar L[MAX][MAX],R[MAX][MAX];\n\nint ldy[]={0,-1,0,1};\nint ldx[]={1,0,-1,0};\nint rdy[]={0,-1,0,1};\nint rdx[]={-1,0,1,0};\n\nvoid dfs(int ly,int lx, int ry, int rx){\n  visited[ly][lx][ry][rx] = true;\n\n  int nly,nlx,nry,nrx;\n  for(int i=0; i<4; i++){\n    nly = ly + ldy[i];\n    nlx = lx + ldx[i];\n    nry = ry + rdy[i];\n    nrx = rx + rdx[i];\n\n    if(!visited[nly][nlx][nry][nrx] &&\n       0<=nly && nly<h && 0<=nlx && nlx<w && 0<=nry && nry<h && 0<=nrx && nrx<w){\n      if(L[nly][nlx]=='%' && R[nry][nrx]=='%'){\n\tf = true;\n\treturn ;\n      }\n      //if(L[nly][nlx]=='%' || R[nry][nrx]=='%') visited[nly][nlx][nry][nrx] = true;\n      if(L[nly][nlx]=='#' && R[nry][nrx]=='.') dfs(ly,lx,nry,nrx);\n      if(L[nly][nlx]=='.' && R[nry][nrx]=='#') dfs(nly,nlx,ry,rx);\n      if(L[nly][nlx]=='.' && R[nry][nrx]=='.')  dfs(nly,nlx,nry,nrx);\n    }\n    if((nlx<0 || w<=nlx) && (0<=nrx && nrx<w) && R[nry][nrx]=='.' && !visited[ly][lx][nry][nrx])    dfs(ly,lx,nry,nrx);\n    if((nrx<0 || w<=nrx) && (0<=nlx && nlx<w) && L[nly][nlx]=='.'&& !visited[nly][nlx][ry][rx])    dfs(nly,nlx,ry,rx);\n    if((nry<0 || h<=nry) && (0<=nly && nly<h) && L[nly][nlx]=='.'&& !visited[nly][nlx][ry][rx])    dfs(nly,nlx,ry,rx);\n    if((nly<0 || h<=nly) && (0<=nry && nry<h) && R[nry][nrx]=='.'&& !visited[ly][lx][nry][nrx])    dfs(ly,lx,nry,nrx);\n      \n  }\n}\n\n\nint main(){\n\n  while(cin >> w >> h ,w|h){\n    cin.ignore();\n\n    for(int i=0; i<h; i++){\n      string str;\n      getline(cin,str);\n      bool first=true;\n      int cnt = 0;\n      for(int j=0; j<str.size(); j++){\n\tif(str[j]==' '){\n\t  first = false;\n\t  continue;\n\t}\n\tif(first) L[i][j] = str[j];\n\telse R[i][cnt++] = str[j];\n      }\n    }\n    int sly,slx,sry,srx;\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tif(L[i][j]=='L'){\n\t  sly = i;\n\t  slx = j;\n\t}\n\tif(R[i][j]=='R'){\n\t  sry = i;\n\t  srx = j;\n\t}\n      }\n    }\n\n    f = false;\n    memset(visited,false,sizeof(visited));\n    // visited[sly][slx][sry][srx]=true;\n    dfs(sly,slx,sry,srx);\n    if(f) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <fstream>\n \nusing namespace std;\n \n#define INF 100000000\n#define EPS 1e-9\n#define PI acos(-1)\n \ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define MAX_W 50\n#define MAX_H 50\n\nint W, H;\nstring L[MAX_H], R[MAX_H];\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nint dp[MAX_H][MAX_W][MAX_H][MAX_W];\n\nvector<string> ans_list;\n\n\n\nint main(){\n  \n  while(true){\n    \n    cin >> W >> H;\n    if(W == 0)\n      break;\n    \n    int lsx, lsy, rsx, rsy, lgx, lgy, rgx, rgy;\n    \n    for(int i = 0; i < H; i++){\n      cin >> L[i] >> R[i];\n      for(int j = 0; j < W; j++){\n\tif(L[i][j] =='L'){\n\t  lsx = j;\n\t  lsy = i;\n\t}\n\tif(R[i][j] == 'R'){\n\t  rsx = j;\n\t  rsy = i;\n\t}\n\tif(L[i][j] == '%'){\n\t  lgx = j;\n\t  lgy = i;\n\t}\n\tif(R[i][j] == '%'){\n\t  rgx = j;\n\t  rgy = i;\n\t}\n      }\n      \n    }\n    \n\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n\tfor(int k = 0; k < H; k++){\n\t  for(int l = 0; l < W; l++){\n\t    dp[i][j][k][l] = INF;\n\t  }\n\t}\n      }\n    }\n\n    dp[lsy][lsx][rsy][rsx] = 0;\n    \n    queue<P> que1, que2;\n    que1.push(P(lsx, lsy));\n    que2.push(P(rsx, rsy));\n    \n    bool flag = false;\n    \n    \n\n    while(que1.size()){\n      P p1 = que1.front();\n      P p2 = que2.front();\n      que1.pop();\n      que2.pop();\n      int lx = p1.first;\n      int ly = p1.second;\n      int rx = p2.first;\n      int ry = p2.second;\n      \n      if(lx == lgx && ly == lgy && rx == rgx && ry == rgy){\n\tflag = true;\n\tbreak;\n      }\n      \n      for(int i = 0; i < 4; i++){\n\tint lnx = lx + dx[i];\n\tint lny = ly + dy[i];\n\tint rnx = rx + dx[(i+2)%4];\n\tint rny = ry + dy[i];\n\t\n\t//両方とも壁がない場合\n\tif( lnx >= 0 && lnx < W && lny >= 0 && lny < H && \n\t    rnx >= 0 && rnx < W && rny >= 0 && rny < H &&\n\t    L[lny][lnx] != '#' && R[rny][rnx] != '#' && \n\t    dp[lny][lnx][rny][rnx] == INF){\n\t  dp[lny][lnx][rny][rnx] = dp[ly][lx][ry][rx] + 1;\n\t  que1.push(P(lnx, lny));\n\t  que2.push(P(rnx, rny));\n\t}\n\t//左の迷路が壁の場合\n\telse if(((lnx == -1 || lnx == W || lny == -1 || lny == H) && \n\t\t rnx >= 0 && rnx < W && rny >= 0 && rny < H && \n\t\t R[rny][rnx] != '#' && dp[ly][lx][rny][rnx] == INF) \n\t\t||\n\t\t(lnx >= 0 && lnx < W && lny >= 0 && lny < H &&\n\t\t rnx >= 0 && rnx < W && rny >= 0 && rny < H &&\n\t\t L[lny][lnx] == '#' && R[rny][rnx] != '#' && \n\t\t dp[ly][lx][rny][rnx] == INF)){\n\t  dp[ly][lx][rny][rnx] = dp[ly][lx][ry][rx] + 1;\n\t  que1.push(P(lx, ly));\n\t  que2.push(P(rnx, rny));\n\t}\n\t//右が壁の場合\n\telse if(((rnx == -1 || rnx == W || rny == -1 || rny == H) && \n\t\t lnx >= 0 && lnx < W && lny >= 0 && lny < H && \n\t\t L[lny][lnx] != '#' && dp[lny][lnx][ry][rx] == INF) \n\t\t||\n\t\t(lnx >= 0 && lnx < W && lny >= 0 && lny < H &&\n\t\t rnx >= 0 && rnx < W && rny >= 0 && rny < H &&\n\t\t L[lny][lnx] != '#' && R[rny][rnx] == '#' && \n\t\t dp[lny][lnx][ry][rx] == INF)){\n\t  dp[lny][lnx][ry][rx] = dp[ly][lx][ry][rx] + 1;\n\t  que1.push(P(lnx, lny));\n\t  que2.push(P(rx, ry));\n\t}\n      }\n    }\n    \n    if(flag){\n      ans_list.push_back(\"Yes\");\n    }\n    else{\n      ans_list.push_back(\"No\");\n    }\n    \n    \n\n  }\n  \n  for(int i = 0; i < ans_list.size(); i++){\n    cout << ans_list[i] << endl;\n  }\n  \n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\n//#define DEBUG_MODE\n#ifdef DEBUG_MODE\n#define dump(x) cout << #x << \" : \" << x << endl\n#define LINE cout << \"line : \" << __LINE__ << endl\n#define dumpV(v) cout << #v << \" : [\"; for(auto& t : v) cout << t << \", \"; cout<<\"]\" << endl;\n#define STOP assert(false);\n#else\n#define dump(x) ;\n#define LINE \t;\n#define dumpV(v);\n#define STOP \t;\n#endif\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fi<<\", \"<<a.se<<')';\n    return out;\n  }\n}\n\n\nint dx[] = {0, -1, 0, 1};\nint dy[] = {-1, 0, 1, 0};\nauto isOutOfRange = [](int h, int w, int H, int W) {\n\treturn h < 0 || h >= H || w < 0 || w >= W;\n};\n\nint merge(int y, int x) {return y * 50 + x;}\nint getX(int yx) {return yx % 50;}\nint getY(int yx) {return yx / 50;}\n\nbool used[2510][2510];\n\nint main(){\n\tint H, W;\n\twhile(cin >> W >> H) {\n\t\tif(H == 0 && W == 0) break;\n\t\trep(i, 2510) rep(j, 2510) used[i][j] = false;\n\t\tvector<string> sl(H), sr(H);\n\t\trep(i, H) cin >> sl[i] >> sr[i];\n\t\tint sxl, syl, gxl, gyl;\n\t\tint sxr, syr, gxr, gyr;\n\t\trep(i, H) rep(j, W) {\n\t\t\tif(sl[i][j] == 'L') syl = i, sxl = j;\n\t\t\tif(sl[i][j] == '%') gyl = i, gxl = j;\n\t\t\tif(sr[i][j] == 'R') syr = i, sxr = j;\n\t\t\tif(sr[i][j] == '%') gyr = i, gxr = j;\n\t\t}\n\t\tint startL = merge(syl, sxl), goalL = merge(gyl, gxl), startR = merge(syr, sxr), goalR = merge(gyr, gxr);\n\t\tqueue<pii> q;\n\t\tpii p;\n\t\tq.push({startL, startR});\n\t\tused[startL][startR] = true;\n\t\tbool f = false;\n\t\twhile(!q.empty()) {\n\t\t\tp = q.front(); q.pop();\n\t\t\tint xl = getX(p.fi), yl = getY(p.fi);\n\t\t\tint xr = getX(p.se), yr = getY(p.se);\n\n\t\t\tpii l = {xl, yl}, r = {xr, yr};\n\t\t\tdump(l);\n\t\t\tdump(r);\n\n\t\t\trep(i, 4) {\n\t\t\t\tint nxl = xl + dx[i], nyl = yl + dy[i];\n\t\t\t\tint nxr = xr + dx[(i+2)%4], nyr = yr + dy[i];\n\t\t\t\tif(isOutOfRange(nyl, nxl, H, W) || sl[nyl][nxl] == '#') nyl = yl, nxl = xl;\n\t\t\t\tif(isOutOfRange(nyr, nxr, H, W) || sr[nyr][nxr] == '#') nyr = yr, nxr = xr;\n\t\t\t\tint nxtL = merge(nyl, nxl), nxtR = merge(nyr, nxr);\n\t\t\t\tif(nxtL == goalL && nxtR == goalR) {\n\t\t\t\t\tf = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(nxtL == goalL || nxtR == goalR || used[nxtL][nxtR]) continue;\n\t\t\t\tq.push({nxtL, nxtR});\n\t\t\t\tused[nxtL][nxtR] = true;\n\t\t\t}\n\t\t\tif(f) break;\n\t\t}\n\t\tcout << (f ? \"Yes\" : \"No\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nint w, h;\nint sly, slx, sry, srx;\nstring s[1000];\nstring t[1000];\nbool f[60][60][60][60];\n\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\n\nbool is_area(int y, int x) {\n\treturn y >= 0 && y < h&&x >= 0 && x < w;\n}\n\nbool solve() {\n\tbool res = false;\n\tqueue<pair<P, P>> que;\n\tque.push({ { sly,slx },{ sry,srx } });\n\twhile (!que.empty()) {\n\t\tpair<P, P> pp = que.front();\n\t\tque.pop();\n\t\tint ly = pp.first.first, lx = pp.first.second,\n\t\t\try = pp.second.first, rx = pp.second.second;\n\t\tif (f[ly][lx][ry][rx])continue;\n\t\tf[ly][lx][ry][rx] = 1;\n\t\trep(i, 4) {\n\t\t\tint nly = ly + dy[i], nry = ry + dy[i],\n\t\t\t\tnlx = lx + dx[i], nrx = rx + dx[i];\n\t\t\tif (is_area(nly, nlx) && is_area(nry, nrx)) {\n\t\t\t\tif (s[nly][nlx] != t[nry][nrx]) {\n\t\t\t\t\tif (s[nly][nlx] == '%' || t[nry][nrx] == '%')continue;\n\t\t\t\t\tif (s[nly][nlx] == '#') {\n\t\t\t\t\t\tif (!f[ly][lx][nry][nrx]) {\n\t\t\t\t\t\t\tque.push({ { ly, lx },{ nry, nrx } });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (t[nry][nrx] == '#') {\n\t\t\t\t\t\tif (!f[nly][nlx][ry][rx]) {\n\t\t\t\t\t\t\tque.push({ { nly, nlx },{ ry, rx } });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (s[nly][nlx] == '%')res = true;\n\t\t\t\t\telse if (s[nly][nlx] == '.') {\n\t\t\t\t\t\tif (!f[nly][nlx][nry][nrx]) {\n\t\t\t\t\t\t\tque.push({ { nly, nlx },{ nry, nrx } });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\twhile (cin >> w >> h&&w + h) {\n\t\trep(i, 60)rep(j, 60)rep(k, 60)rep(l, 60) {\n\t\t\tf[i][j][k][l] = 0;\n\t\t}\n\t\trep(i, h) {\n\t\t\tcin >> s[i] >> t[i];\n\t\t\treverse(ALL(t[i]));\n\t\t}\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\tif (s[i][j] == 'L') {\n\t\t\t\t\tsly = i, slx = j;\n\t\t\t\t\ts[i][j] = '.';\n\t\t\t\t}\n\t\t\t\tif (t[i][j] == 'R') {\n\t\t\t\t\tsry = i, srx = j;\n\t\t\t\t\tt[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (solve())cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// tsukasa_diary's programing contest code template\n#include <bits/stdc++.h>\nusing namespace std;\n// define\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n// typedef\ntypedef long long lint;\ntypedef double Double;\ntypedef pair<int, int> pii;\n//\ntypedef vector< int > Array;\ntypedef vector< Array > Matrix;\ntypedef vector< Double > DArray;\ntypedef vector< DArray > DMatrix;\ntypedef vector< string > SArray;\ntypedef vector< pii > PArray;\n// popcount\ninline int POPCNT(int _x) { return __builtin_popcount(_x); }\ninline int POPCNT(lint _x) { return __builtin_popcountll(_x); }\n// inf\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\n// eps\nDouble EPS = 1e-9;\n// in range\ninline bool in_range(int _v, int _mx, int _mi) { return _mi <= _v && _v < _mx; }\ninline bool in_range(Double _v, Double _mi, Double _mx) { return -EPS < _v - _mi && _v - _mx < EPS; }\ninline bool in_range(int _x, int _y, int _W, int _H) { return 0 <= _x && _x < _W && 0 <= _y && _y < _H; }\n// neighbor clockwise\nconst int DX[4] = {0,1,0,-1}, DY[4] = {-1,0,1,0};\nconst int DX_[8] = {0,1,1,1,0,-1,-1,-1}, DY_[8] = {-1,-1,0,1,1,1,0,-1};\n\nstruct State {\n\tint lx, ly, rx, ry;\n\tState(int _lx, int _ly, int _rx, int _ry) : lx(_lx), ly(_ly), rx(_rx), ry(_ry) {}\n};\n\nint W, H;\nint srx, sry, slx, sly;\nstring roomL[55], roomR[55];\n\nbool visit[55][55][55][55];\n\nvoid solve() {\n\tminit(visit, 0);\n\t\n\tbool flag = false;\n\t\n\tqueue< State > q;\n\tq.push(State(slx, sly, srx, sry));\n\t\n\twhile (!q.empty()) {\n\t\tState s = q.front(); q.pop();\n\t\tint lx = s.lx, ly = s.ly, rx = s.rx, ry = s.ry;\n\t\t\n\t\tif (visit[ly][lx][ry][rx]) continue;\n\t\tvisit[ly][lx][ry][rx] = true;\n\t\t\n\t\tchar cL = roomL[ly][lx], cR = roomR[ry][rx];\n\t\t\n\t\tif ((cL == '%' && cR != '%') || (cL != '%' && cR == '%')) continue;\n\t\tif (cL == '%' && cR == '%') {\n\t\t\tflag = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor_(d,0,4) {\n\t\t\tint nlx = lx + DX[d], nly = ly + DY[d];\n\t\t\tint nrx = rx, nry = ry;\n\t\t\tif (d != 0 && d != 2) nrx += DX[(d + 2) % 4], nry += DY[(d + 2) % 4];\n\t\t\telse nrx += DX[d], nry += DY[d];\n\t\n\t\t\tif (!in_range(nlx, nly, W, H)) {\n\t\t\t\tnlx = lx;\n\t\t\t\tnly = ly;\n\t\t\t} else if (roomL[nly][nlx] == '#') {\n\t\t\t\tnlx = lx;\n\t\t\t\tnly = ly;\n\t\t\t}\n\t\t\t\n\t\t\tif (!in_range(nrx, nry, W, H)) {\n\t\t\t\tnrx = rx;\n\t\t\t\tnry = ry;\n\t\t\t} else if (roomR[nry][nrx] == '#') {\n\t\t\t\tnrx = rx;\n\t\t\t\tnry = ry;\n\t\t\t}\n\n\t\t\tq.push(State(nlx, nly, nrx, nry));\n\t\t}\n\t}\n\t\n\tif (flag) {\n\t\tcout << \"Yes\" << endl;\n\t} else {\n\t\tcout << \"No\" << endl;\n\t}\n}\n\nint main() {\n\twhile (cin >> W >> H, W) {\n\t\tfor_(i,0,H) {\n\t\t\tcin >> roomL[i] >> roomR[i];\n\t\t\tfor_(j,0,W) {\n\t\t\t\tif (roomL[i][j] == 'L') slx = j, sly = i;\n\t\t\t\tif (roomR[i][j] == 'R') srx = j, sry = i;\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\nusing namespace std;\nstring s1[50],s2[50];\nint dx1[]={1,-1,0,0,},dy1[]={0,0,1,-1};\nint dx2[]={-1,1,0,0,},dy2[]={0,0,1,-1};\nint w,h,gx1,gx2,gy1,gy2;\nset<int>s;\nbool bfs(int x1,int y1,int x2,int y2){\n  queue<pair<int,int> >q;\n  q.push(mk(x1*100+y1,x2*100+y2));\n  while(!q.empty()){\n    pair<int,int>p=q.front();q.pop();\n    x1=p.first/100;y1=p.first%100;\n    x2=p.second/100;y2=p.second%100;\n    if(x1==gx1&&y1==gy1&&(x2!=gx2||y2!=gy2))continue;\n    if((x1!=gx1||y1!=gy1)&&x2==gx2&&y2==gy2)continue;\n    if(x1==gx1&&y1==gy1&&x2==gx2&&y2==gy2)return 1;\n    for(int i=0;i<4;i++){\n      int x3=x1+dx1[i],y3=y1+dy1[i];\n      int x4=x2+dx2[i],y4=y2+dy2[i];\n      if(x3>=0&&x4>=0&&y3>=0&&y4>=0)\n        if(x3<w&&x4<w&&y3<h&&y4<h){\n          if(s1[y3][x3]=='#')y3=y1,x3=x1;\n          if(s2[y4][x4]=='#')y4=y2,x4=x2;\n          if(!s.count(x3+y3*100+x4*10000+y4*1000000)){\n            s.insert(x3+y3*100+x4*10000+y4*1000000);\n            q.push(mk(x3*100+y3,x4*100+y4));\n          }\n        }\n      }\n    }\n    return 0;\n}\nint main(){\n  int x1,y1,x2,y2;\n  while(cin>>w>>h,w){\n    s.clear();\n    r(i,h)cin>>s1[i]>>s2[i];\n    r(i,h)r(j,w){\n      if(s1[i][j]=='L')x1=j,y1=i;\n      if(s2[i][j]=='R')x2=j,y2=i;\n      if(s1[i][j]=='%')gx1=j,gy1=i;\n      if(s2[i][j]=='%')gx2=j,gy2=i;\n    }\n    s.insert(x1+y1*100+x2*10000+y2*1000000);\n    if(bfs(x1,y1,x2,y2))cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\n\n\nint W,H;\nstring roomL[55],roomR[55];\n\nbool range_check(int y,int x) {\n\n    return 0<=y&&y<H && 0<=x&&x<W;\n}\n\nbool visited[55][55][55][55];\nbool ok(P len,P rin) {\n    memset(visited,0,sizeof(visited));\n    visited[len.fr][len.sc][rin.fr][rin.sc]=true;\n    queue<PP> que;\n    que.push(PP(len,rin));\n\n    while(que.size()) {\n        PP pp=que.front(); que.pop();\n        P next_len=pp.fr;\n        P next_rin=pp.sc;\n\n        //printf(\"[debug] %d %d %d %d\\n\",next_len.fr,next_len.sc,next_rin.fr,next_rin.sc);\n\n        rep(i,4) {\n            next_len=pp.fr;\n            next_rin=pp.sc;\n            next_len.fr+=dy[i];\n            next_len.sc+=dx[i];\n            next_rin.fr+=dy[i];\n            next_rin.sc-=dx[i];\n            \n            if(!range_check(next_len.fr,next_len.sc) || roomL[next_len.fr][next_len.sc]=='#') {\n                next_len=pp.fr;\n            }\n\n            if(!range_check(next_rin.fr,next_rin.sc) || roomR[next_rin.fr][next_rin.sc]=='#') {\n                next_rin=pp.sc;\n            }\n\n            if((roomL[next_len.fr][next_len.sc]=='%')&&(roomR[next_rin.fr][next_rin.sc]=='%')) return true;\n            if((roomL[next_len.fr][next_len.sc]=='%')||(roomR[next_rin.fr][next_rin.sc]=='%')) continue;\n            if(visited[next_len.fr][next_len.sc][next_rin.fr][next_rin.sc]) continue;\n\n            visited[next_len.fr][next_len.sc][next_rin.fr][next_rin.sc]=true;\n            que.push(PP(next_len,next_rin));\n\n        }\n    }\n\n    return false;\n}\n\nvoid solve() {\n    rep(y,H) cin>>roomL[y]>>roomR[y];\n    P len,rin;\n    rep(y,H) rep(x,W) {\n        if(roomL[y][x]=='L') len=P(y,x);\n        if(roomR[y][x]=='R') rin=P(y,x);\n    }\n    if(ok(len,rin)) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n}\n\nint main() {\n    while(cin>>W>>H) {\n        if(!W) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define M 52\n#include<cstring>\nusing namespace std;\nbool flag;\nint dx[]={1,-1,0,0},dy[]={0,0,-1,1},w,h;\nchar r[M][M],l[M][M];\nint dp[M][M][M][M];\nvoid func(int ly,int lx,int ry,int rx){\n\t//cout<<ly<<' '<<lx<<' '<<ry<<' '<<rx<<endl;\n\tif(dp[ly][lx][ry][rx]!=0)\n\treturn;\n\tdp[ly][lx][ry][rx]=1;\n\tif(l[ly][lx]=='%'&&r[ry][rx]=='%'){\n\t\tflag=true;\n\t\treturn;\n\t}else if(l[ly][lx]=='%')\n\treturn;\n\telse if(r[ry][rx]=='%')\n\treturn;\n\tint nrx,nry,nlx,nly;\n\tfor(int i=0;i<4;i++){\n\t\tnrx=dx[i]+rx;\n\t\tnry=dy[i]+ry;\n\t\tnlx=-dx[i]+lx;\n\t\tnly=dy[i]+ly;\n\t\tif(!(nrx>=0&&nrx<w&&nry>=0&&nry<h)||r[nry][nrx]=='#'){\n\t\t\tnrx=rx;nry=ry;\n\t\t}\n\t\tif(!(nlx>=0&&nlx<w&&nly>=0&&nly<h)||l[nly][nlx]=='#'){\n\t\t\tnlx=lx;nly=ly;\n\t\t}\n\t\tif(dp[nly][nlx][nry][nrx]==0)\n\t\tfunc(nly,nlx,nry,nrx);\n\t}\n}\nint main(){\n\tint a,b,c,d;\n\twhile(cin>>w>>h,h||w){\n\t\tfor(int i=0;i<h;i++)\n\t\t\tcin>>l[i]>>r[i];\n\t\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++)\n\t\tif(l[i][j]=='L'){\n\t\ta=i;b=j;\n//\t\tcout<<a<<b<<endl;\n\t\t}\n\t\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++)\n\t\tif(r[i][j]=='R'){\n\t\tc=i;d=j;\n\t\t}\n\t\tmemset(dp,sizeof(dp),0);\n\t\tflag=false;\n\t\tfunc(a,b,c,d);\n\t\tputs(flag?\"Yes\":\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,s,n) for(int i=s; i<n; i++)\n#define ALL(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nint w, h;\nint rooml[60][60], roomr[60][60];\nbool memo[60][60][60][60];\n\nbool dfs(int xl, int yl, int xr, int yr) {\n\tif( memo[xl][yl][xr][yr] ) {\n\t\treturn false;\n\t}\n\tmemo[xl][yl][xr][yr] = true;\n\tconst int dx[4] = {-1, 0, 1, 0};\n\tconst int dy[4] = {0, 1, 0, -1};\n\trep(i, 4) {\n\t\tint nxl = xl + dx[i];\n\t\tint nyl = yl + dy[i];\n\t\tint nxr = xr - dx[i];\n\t\tint nyr = yr + dy[i];\n\t\tint nl = rooml[nyl][nxl];\n\t\tint nr = roomr[nyr][nxr];\n\t\tif( nl==2 && nr==2 ) {\n\t\t\treturn true;\n\t\t}\n\t\telse if( nl==1 && nr==1 ) {\n\t\t\tbool f = dfs(nxl, nyl, nxr, nyr);\n\t\t\tif(f) return true;\n\t\t}\n\t\telse if( nl==1 && nr==0 ) {\n\t\t\tbool f = dfs(nxl, nyl, xr, yr);\n\t\t\tif(f) return true;\n\t\t}\n\t\telse if( nl==0 && nr==1 ) {\n\t\t\tbool f = dfs(xl, yl, nxr, nyr);\n\t\t\tif(f) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\twhile(cin >> w >> h, w||h) {\n\t\tmemset(rooml, 0, sizeof(rooml));\n\t\tmemset(roomr, 0, sizeof(roomr));\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tint xl=1, yl=1, xr=1, yr=1;\n\t\trep(y, h) {\n\t\t\tstring sl, sr;\n\t\t\tcin >> sl >> sr;\n\t\t\trep(x, w) {\n\t\t\t\tif(sl[x] == 'L') {\n\t\t\t\t\txl = x+1;\n\t\t\t\t\tyl = y+1;\n\t\t\t\t\trooml[y+1][x+1] = 1;\n\t\t\t\t} else {\n\t\t\t\t\trooml[y+1][x+1] = (sl[x]=='%' ? 2 : (sl[x]=='.' ? 1 : 0));\n\t\t\t\t}\n\t\t\t\tif(sr[x] == 'R') {\n\t\t\t\t\txr = x+1;\n\t\t\t\t\tyr = y+1;\n\t\t\t\t\troomr[y+1][x+1] = 1;\n\t\t\t\t} else {\n\t\t\t\t\troomr[y+1][x+1] = (sr[x]=='%' ? 2 : (sr[x]=='.' ? 1 : 0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( dfs(xl, yl, xr, yr) ) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t} else {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<cmath>\n#include<utility>\n#include<functional>\n#include<map>\n#include<set>\n#include<cctype>\n\n\n#define FOR(i, a, b) for( int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for( int i=(a);i>=(b);i--)\n#define LFOR(i, a, b) for( long long int i=(a);i<=(b);i++)\n#define LRFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LLINF 1000000000000000000 //9000000000000000000\n#define PI 3.14159265358979\n#define MAXI 7500000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\n\nint dy[4] = { 0,0,1,-1 };\nint dx[4] = { 1,-1,0,0 };\n\n//int dp[50][50][50][50] = {};//ly,lx,ry,rx\n\n\nint main(void) {\n\t\n\t//while (1) {\n\n\t\ttypedef struct {\n\t\tpublic:\n\t\t\tint leftx;\n\t\t\tint lefty;\n\t\t\tint rightx;\n\t\t\tint righty;\n\t\t}Pos;\n\n\t\tint w, h;\n\t\tint lx = -1, ly = -1, rx = -1, ry = -1;\n\t\tint lgx = -1, lgy = -1, rgx = -1, rgy = -1;\n\n\t\tvector< vector< vector< vector<int> > > > dp(50, vector< vector< vector<int > > >(50, vector< vector<int> >(50, vector<int>(50, 0))));\n\t\t\n\n\t\tqueue< Pos > que;\n\t\tPos now;\n\n\t\tcin >> w >> h;\n\n\t\tif (w == 0) {\n\t\t\t//break;\n\t\t}\n\n\t\tvector<string> left(h), right(h);\n\n\t\tFOR(i, 0, h-1) {\n\t\t\tcin >> left[i] >> right[i];\n\t\t}\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (left[i][j] == 'L') {\n\t\t\t\t\tlx = j;\n\t\t\t\t\tly = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (right[i][j] == 'R') {\n\t\t\t\t\trx = j;\n\t\t\t\t\try = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (left[i][j] == '%') {\n\t\t\t\t\tlgx = j;\n\t\t\t\t\tlgy = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lgx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (right[i][j] == '%') {\n\t\t\t\t\trgx = j;\n\t\t\t\t\trgy = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rgx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*dp[ly][lx][ry][rx] = 1;\n\n\t\tnow.lefty = ly;\n\t\tnow.leftx = lx;\n\t\tnow.righty = ry;\n\t\tnow.rightx = rx;\n\t\t\n\t\tque.push(now);\n\n\n\t\twhile (!que.empty()) {\n\t\t\tnow = que.front();\n\t\t\t\n\t\t\tque.pop();\n\t\t\tly = now.lefty;\n\t\t\tlx = now.leftx;\n\t\t\try = now.righty;\n\t\t\trx = now.rightx;\n\t\t\t//cout << ly << \" \" << lx << \" \" << ry << \" \" << rx << endl;\n\n\t\t\tFOR(i, 0, 3) {\n\t\t\t\t\n\t\t\t\tif (ly + dy[i] >= 0 && lx - dx[i] >= 0 && ry + dy[i] <= h - 1 && rx + dx[i] <= w - 1 && ly + dy[i] <= h - 1 && lx - dx[i] <= w - 1 && ry + dy[i] >= 0 && rx + dx[i] >= 0) {\n\t\t\t\t\tif (dp[ly + dy[i]][lx - dx[i]][ry + dy[i]][rx + dx[i]] != 1) {\n\t\t\t\t\t\tif (left[ly + dy[i]][lx - dx[i]] == '#') {\n\t\t\t\t\t\t\tif (right[ry + dy[i]][rx + dx[i]] == '#') {\n\t\t\t\t\t\t\t\t//no\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdp[ly][lx][ry + dy[i]][rx + dx[i]] = 1;\n\t\t\t\t\t\t\t\tnow.lefty = ly;\n\t\t\t\t\t\t\t\tnow.leftx = lx;\n\t\t\t\t\t\t\t\tnow.righty = ry + dy[i];\n\t\t\t\t\t\t\t\tnow.rightx = rx + dx[i];\n\t\t\t\t\t\t\t\tque.push(now);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (right[ry + dy[i]][rx + dx[i]] == '#') {\n\t\t\t\t\t\t\t\tdp[ly + dy[i]][lx - dx[i]][ry][rx] = 1;\n\t\t\t\t\t\t\t\tnow.lefty = ly + dy[i];\n\t\t\t\t\t\t\t\tnow.leftx = lx - dx[i];\n\t\t\t\t\t\t\t\tnow.righty = ry;\n\t\t\t\t\t\t\t\tnow.rightx = rx;\n\t\t\t\t\t\t\t\tque.push(now);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdp[ly + dy[i]][lx - dx[i]][ry + dy[i]][rx + dx[i]] = 1;\n\t\t\t\t\t\t\t\tnow.lefty = ly + dy[i];\n\t\t\t\t\t\t\t\tnow.leftx = lx - dx[i];\n\t\t\t\t\t\t\t\tnow.righty = ry + dy[i];\n\t\t\t\t\t\t\t\tnow.rightx = rx + dx[i];\n\t\t\t\t\t\t\t\tque.push(now);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\n\t\tif (dp[lgy][lgx][rgy][rgx] == 1) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t\t\n\n\n\t//}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <array>\n#include <queue>\n#include <array>\n#include <stack>\n\nenum PassageType{\n\tFREE, WALL, SEARCHED, GOAL,\n};\n\nbool isSearched[50][50][50][50] = {false};\n\nstruct Point {\n\tPoint() { x = 0; y = 0; };\n\tPoint(int x, int y) {\n\t\tthis->x = x;\n\t\tthis->y = y;\n\t};\n\tint x, y;\n};\n\nint main() {\n\tint w, h;\n\n\twhile (std::cin >> w >> h && w && h) {\n\t\tmemset(isSearched, false, sizeof(bool) * 50 * 50 * 50 * 50);\n\t\tstd::array<std::vector<std::vector<int>>, 2> room;\n\t\tPoint start[2];\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tstd::array<std::string, 2> str;\n\t\t\tfor (int j = 0; j < str.size(); j++) {\n\t\t\t\tstd::cin >> str[j];\n\t\t\t\troom[j].push_back(std::vector<int>());\n\t\t\t\tfor (int k = 0; k < str[j].size(); k++) {\n\t\t\t\t\tint type = 0;\n\t\t\t\t\tif (str[j][k] == '.') type = FREE;\n\t\t\t\t\telse if (str[j][k] == '#') type = WALL;\n\t\t\t\t\telse if (str[j][k] == '%') type = GOAL;\n\t\t\t\t\telse if (str[j][k] == 'L' || str[j][k] == 'R') {\n\t\t\t\t\t\tstart[j].x = k;\n\t\t\t\t\t\tstart[j].y = i;\n\t\t\t\t\t\ttype = SEARCHED;\n\t\t\t\t\t}\n\t\t\t\t\troom[j].back().push_back(type);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstd::stack<std::pair<Point, Point>> s;\n\t\ts.push(std::make_pair(start[0], start[1]));\n\t\tint dx[] = {1, 0, -1, 0};\n\t\tint dy[] = {0, 1, 0, -1};\n\n\t\tbool isOk = false;\n\t\twhile (!s.empty() && !isOk) {\n\t\t\tauto node = s.top(); s.pop();\n\n\t\t\t//?¬???????????????´????????¢???\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tauto next = node;\n\t\t\t\tnext.first.x += dx[i];\n\t\t\t\tnext.first.y += dy[i];\n\t\t\t\tnext.second.x -= dx[i];\n\t\t\t\tnext.second.y += dy[i];\n\n\t\t\t\t//??´????£???£\n\t\t\t\tnext.first.x = std::min(std::max(0, next.first.x), w - 1);\n\t\t\t\tnext.first.y = std::min(std::max(0, next.first.y), h - 1);\n\t\t\t\tnext.second.x = std::min(std::max(0, next.second.x), w - 1);\n\t\t\t\tnext.second.y = std::min(std::max(0, next.second.y), h - 1);\n\n\t\t\t\t//??????????????´????????????OK\n\t\t\t\tif (room[0][next.first.y][next.first.x] == GOAL && room[1][next.second.y][next.second.x] == GOAL) {\n\t\t\t\t\tisOk = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint r[2] = {room[0][next.first.y][next.first.x], room[1][next.second.y][next.second.x] };\n\t\t\t\t\t//?£???????????????????????????????\n\t\t\t\t\tif (room[0][next.first.y][next.first.x] == WALL) {\n\t\t\t\t\t\tnext.first = node.first;\n\t\t\t\t\t}\n\t\t\t\t\tif (room[1][next.second.y][next.second.x] == WALL) {\n\t\t\t\t\t\tnext.second = node.second;\n\t\t\t\t\t}\n\t\t\t\t\tif (!isSearched[next.first.y][next.first.x][next.second.y][next.second.x]) {\n\t\t\t\t\t\ts.push(next);\n\t\t\t\t\t\tisSearched[next.first.y][next.first.x][next.second.y][next.second.x] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstd::cout << (isOk ? \"Yes\" : \"No\") << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <sstream>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cstring>\n \nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nint w,h;\nint sxl,syl,sxr,syr;\nstring L[100],R[100];\n\nconst int dx[]={0,1,0,-1};\nconst int dy[]={-1,0,1,0};\n\nint vis[50][50][50][50];\n\nbool solve(int xl,int yl,int xr, int yr)\n{\n\tcout<<xl<<\" \"<<yl<<\" \"<<xr<<\" \"<<yr<<endl;\n\n\tif(vis[yl][xl][yr][xr]==1) return false;\n\t\t\n\tif(L[yl][xl]=='%' && R[yr][xr]=='%') return true;\n\tif(L[yl][xl]=='%' && R[yr][xr]!='%') return false;\n\tif(L[yl][xl]!='%' && R[yr][xr]=='%') return false;\n\t\n\n\t\n\tvis[yl][xl][yr][xr]=1;\n\t\n\tfor(int i=0;i<4;i++){\n\t\tint nxl=xl+dx[i], nyl=yl+dy[i];\n\t\tint nxr=xr-dx[i], nyr=yr+dy[i];\n\n\t\tif(nxl<0 || w<=nxl || nyl<0 || h<=nyl ||\n\t\t   nxr<0 || w<=nxr || nyr<0 || h<=nyr ) continue;\n\t\t\n\t\tif(L[nyl][nxl]=='#'){\n\t\t\tnxl-=dx[i]; nyl-=dy[i];\n\t\t}\n\t\tif(R[nyr][nxr]=='#'){\n\t\t\tnxr+=dx[i]; nyr-=dy[i];\n\t\t}\n\t\t\n\t\tif(solve(nxl,nyl,nxr,nyr)) return true;\n\t\t\n\t}\n\t\n\treturn false;\n\n}\n\nint main()\n{\n\t\n\twhile(cin>>w>>h,w){\t\t\n\n\t\tmemset(vis,-1,sizeof(int)*50*50*50*50);\n\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>L[i]>>R[i];\n\t\t}\n\t\t\n\t\t\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(L[i][j]=='L'){sxl=j,syl=i;}\n\t\t\t\tif(R[i][j]=='R'){sxr=j,syr=i;}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(solve(sxl,syl,sxr,syr)) cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t\t\n\t}\n\t\t\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cstring>\nusing namespace std;\nstruct P{\n  int rx,ry,lx,ly;\n  P(){}\n  P(int rx,int ry,int lx,int ly):rx(rx),ry(ry),lx(lx),ly(ly){};\n};\nint w,h,dx[]={0,1,-1,0},dy[]={1,0,0,-1};\nbool used[50][50][50][50];\nchar Rin[50][50],Len[50][50];\nbool bfs(int,int,int,int);\nint main(){\n  int rx,ry,lx,ly;\n  while(cin >> w >> h && w||h){\n    memset(used,false,sizeof(used));\n    for(int i=0;i<h;i++){\n      cin >> Len[i] >> Rin[i];\n      for(int j=0;j<w;j++){\n        if(Rin[i][j] == 'R') rx=i,ry=j;\n        if(Len[i][j] == 'L') lx=i,ly=j;\n      }\n    }\n    cout << (bfs(rx,ry,lx,ly)?\"Yes\":\"No\") << endl;\n  }\n}\nbool bfs(int rx,int ry,int lx,int ly){\n  queue<P> que;\n  que.push(P(rx,ry,lx,ly));\n  while(!que.empty()){\n    P p = que.front();\n    que.pop();\n    if(Rin[p.rx][p.ry] == '%' && Len[p.lx][p.ly] == '%') return true;\n    if(Rin[p.rx][p.ry] == '%'||Len[p.lx][p.ly] == '%') continue;\n    used[p.rx][p.ry][p.lx][p.ly] = true;\n    for(int i=0;i<4;i++){\n      int nrx = p.rx + dx[i],nry = p.ry + dy[i];\n      int nlx = p.lx + dx[i],nly = p.ly - dy[i];\n      if(nrx<0 || nry<0 || nrx>=h || nry>=w || Rin[nrx][nry]=='#')\n        nrx = p.rx,nry = p.ry;\n      if(nlx<0 || nly<0 || nlx>=h || nly>=w || Len[nlx][nly]=='#')\n        nlx = p.lx,nly = p.ly;\n      if(used[nrx][nry][nlx][nly]) continue;\n      que.push(P(nrx,nry,nlx,nly));\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dh[]={1,0,-1,0};\nint dw[]={0,1,0,-1};\nint w,h;\n\nvoid insert(vector<vector<vector<vector<bool>>>> &dp,pair<pair<int,int>,pair<int,int>> p){\n    auto x=p.first;\n    auto y=p.second;\n    dp[x.first][x.second][y.first][y.second]=true;\n}\n\nbool count(vector<vector<vector<vector<bool>>>> &dp,pair<pair<int,int>,pair<int,int>> p){\n    auto x=p.first;\n    auto y=p.second;\n    return dp[x.first][x.second][y.first][y.second];\n}\n\nbool isrange(int x,int y){return 0<=x && x<h && 0<=y && y<w;};\nint main(){\n    \n    while(cin>>w>>h,w){\n        vector<string> rl(h),rr(h);\n        for(int i=0;i<h;i++){\n            cin>>rl[i]>>rr[i];\n        }\n        pair<int,int> lp;\n        pair<int,int> rp;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(rl[i][j]=='L') lp={i,j};\n                if(rr[i][j]=='R') rp={i,j};\n            }\n        }\n        stack<pair<pair<int,int>,pair<int,int>>> que;\n        que.push({lp,rp});\n        vector<vector<vector<vector<bool>>>> dp(h,vector<vector<vector<bool>>>(w,vector<vector<bool>>(h,vector<bool>(w,0))));\n        insert(dp,{lp,rp});\n        auto move=[&rl,&rr](int x,int dx,int y,int dy,bool isr){\n            if(!isrange(x+dx,y+dy)){\n                return make_pair(x,y);\n            }\n            if(isr){\n                if(rr[x+dx][y+dy]=='#') return make_pair(x,y);\n                else return make_pair(x+dx,y+dy);\n            }\n            else{\n                if(rl[x+dx][y+dy]=='#') return make_pair(x,y);\n                else return make_pair(x+dx,y+dy);\n            }\n        };\n        pair<int,int> obl;\n        pair<int,int> obr;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(rl[i][j]=='%') obl={i,j};\n                if(rr[i][j]=='%') obr={i,j};\n            }\n        }\n        while(!que.empty()){\n            auto p=que.top();\n            que.pop();\n            for(int i=0;i<4;i++){\n                auto tol=move(p.first.first,dh[i],p.first.second,dw[i],0);\n                auto tor=move(p.second.first,dh[i],p.second.second,dw[(i+2)%2],1);\n                pair<pair<int,int>,pair<int,int>> tost={tol,tor};\n                if(count(dp,tost)) continue;\n                if(tol==obl && tor!=obr || tol!=obl && tor==obr) continue;\n                insert(dp,tost);\n                que.push(tost);\n            }\n        }\n        \n        if(count(dp,{obl,obr})) cout<<\"Yes\"<<endl;\n        else cout<<\"No\"<<endl;\n    }\n    return 0;\n}   "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 50;\n\nint h, w;\n\nbool visited[N][N][N][N];\nchar data[2][N][N];\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nbool dfs(int ly, int lx, int ry, int rx){\n  //cout << ly << ' ' << lx << ' ' << ry << ' ' << rx << endl;\n  if(data[0][ly][lx] == '%' && data[1][ry][rx] == '%') return true;\n  else if(data[0][ly][lx] == '%' || data[1][ry][rx] == '%') return false;\n  visited[ly][lx][ry][rx] = true;\n  for(int i=0;i<4;i++){\n    int lty = ly + dy[i];\n    int ltx = lx + dx[i];\n    int rty = ry + dy[i];\n    int rtx = rx - dx[i];\n    //cout << \"       \" << lty << ' ' << ltx << ' ' << rty << ' ' << rtx << endl;\n    if(lty<0 || lty>=h){\n      lty = ly;\n      ltx = lx;\n    }\n    if(ltx<0 || ltx>=w){\n      lty = ly;\n      ltx = lx;\n    }\n    if(rty<0 || rty>=h){\n      rty = ry;\n      rtx = rx;\n    }\n    if(rtx<0 || rtx>=w){\n      rty = ry;\n      rtx = rx;\n    }\n    if(data[0][lty][ltx] == '#'){\n      lty = ly;\n      ltx = lx;\n    }\n    if(data[1][rty][rtx] == '#'){\n      rty = ry;\n      rtx = rx;\n    }\n    if(visited[lty][ltx][rty][rtx]) continue;\n    if(dfs(lty, ltx, rty, rtx)) return true;\n  }\n  return false;\n}\n\nmain(){\n  int slx, sly, srx, sry;\n  while(cin >> w >> h){\n    if(h == 0 && w == 0) break;\n    fill(visited[0][0][0], visited[N][0][0], false);\n    for(int i=0;i<h;i++){\n      for(int k=0;k<2;k++){\n\tfor(int j=0;j<w;j++){\n\t  cin >> data[k][i][j];\n\t  if(data[k][i][j] == 'L'){\n\t    slx = j;\n\t    sly = i;\n\t    data[k][i][j] = '.';\n\t  }else if(data[k][i][j] == 'R'){\n\t    srx = j;\n\t    sry = i;\n\t    data[k][i][j] = '.';\n\t  }\n\t}\n      }\n    }\n    if(dfs(sly, slx, sry, srx)) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint w,h;\nvector<string> l;\nvector<string> r;\nvector<vector<int> >mal;\nvector<vector<int> >mar;\nint main(){\n  while(1){\n    cin >> w >> h;\n    if(w==0&&h==0)break;\n    l=vector<string> (h);\n    r=vector<string> (h);\n    mal=vector<vector<int> >(h,vector<int>(w,-1));\n    mar=vector<vector<int> >(h,vector<int>(w,-1));\n    for(int i=0;i<h;i++){\n      cin >> l[i] >> r[i];\n    }\n    pair<int,int>ls;\n    pair<int,int>rs;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(l[i][j]=='L')ls={i,j};\n\tif(r[i][j]=='R')rs={i,j};\n      }\n    }\n    queue<int> qxl;\n    queue<int> qxr;\n    queue<int> qyl;\n    queue<int> qyr;\n    qyl.push(ls.first);\n    qxl.push(ls.second);\n    qyr.push(rs.first);\n    qxr.push(rs.second);\n    int ans=0;\n    while(!qxl.empty()){\n      int dxl[4]={-1,0,1,0};\n      int dy[4]={0,-1,0,1};\n      int dxr[4]={1,0,-1,0};\n      int pyl=qyl.front();\n      int pxl=qxl.front();\n      int pyr=qyr.front();\n      int pxr=qxr.front();\n      //cout << pyl << \" \" << pxl << endl; \n      qyl.pop();\n      qxl.pop();\n      qyr.pop();\n      qxr.pop();\n\n      if(l[pyl][pxl]=='#'||mal[pyl][pxl]==1)continue;\n      if(r[pyr][pxr]=='#'||mar[pyr][pxr]==1)continue;\n      mal[pyl][pxl]=1;\n      mar[pyr][pxr]=1;\n      if(l[pyl][pxl]==r[pyr][pxr]&&r[pyr][pxr]=='%'){ans=1;break;}\n      \n      for(int i=0;i<4;i++){\n\tif(pxl+dxl[i]<0||pxl+dxl[i]>=w)continue;\n\tif(pyl+dy[i]<0||pyl+dy[i]>=h)continue;\n\tif(pxr+dxr[i]<0||pxr+dxr[i]>=w)continue;\n\tif(pyr+dy[i]<0||pyr+dy[i]>=h)continue;\n\tqyl.push(pyl+dy[i]);\n\tqxl.push(pxl+dxl[i]);\n\tqyr.push(pyr+dy[i]);\n\tqxr.push(pxr+dxr[i]);\n      }\n    }\n    if(ans)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\n\n\nint W,H;\nstring roomL[55],roomR[55];\n\nbool range_check(int y,int x) {\n    if(!(0<=y&&y<H)) return false;\n    if(!(0<=x&&x<W)) return false;\n\n    return true;\n}\n\nbool visited[55][55][55][55];\nbool ok(P len,P rin) {\n    memset(visited,0,sizeof(visited));\n    visited[len.fr][len.sc][rin.fr][rin.sc]=true;\n    queue<PP> que;\n    que.push(PP(len,rin));\n\n    while(que.size()) {\n        PP pp=que.front(); que.pop();\n        P next_len=pp.fr;\n        P next_rin=pp.sc;\n\n        //printf(\"[debug] %d %d %d %d\\n\",next_len.fr,next_len.sc,next_rin.fr,next_rin.sc);\n\n        rep(i,4) {\n            next_len=pp.fr;\n            next_rin=pp.sc;\n            next_len.fr+=dy[i];\n            next_len.sc+=dx[i];\n            next_rin.fr+=dy[i];\n            next_rin.sc-=dx[i];\n            \n            if(!range_check(next_len.fr,next_len.sc) || roomL[next_len.fr][next_len.sc]=='#') {\n                next_len=pp.fr;\n            }\n\n            if(!range_check(next_rin.fr,next_rin.sc) || roomR[next_rin.fr][next_rin.sc]=='#') {\n                next_rin=pp.sc;\n            }\n\n\n\n            if((roomL[next_len.fr][next_len.sc]=='%')&&(roomR[next_rin.fr][next_rin.sc]=='%')) return true;\n            if((roomL[next_len.fr][next_len.sc]=='%')||(roomR[next_rin.fr][next_rin.sc]=='%')) continue;\n            if(visited[next_len.fr][next_len.sc][next_rin.fr][next_len.sc]) continue;\n            visited[next_len.fr][next_len.sc][next_rin.fr][next_len.sc]=true;\n            que.push(PP(next_len,next_rin));\n\n        }\n    }\n\n    return false;\n}\n\nvoid solve() {\n    rep(y,55) roomL[y]=roomR[y]=string('#',55);\n    rep(y,H) cin>>roomL[y]>>roomR[y];\n    P len,rin;\n    rep(y,H) rep(x,W) {\n        if(roomL[y][x]=='L') len=P(y,x);\n        if(roomR[y][x]=='R') rin=P(y,x);\n    }\n    if(ok(len,rin)) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n}\n\nint main() {\n    while(cin>>W>>H) {\n        if(!W) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\nint main() {\n\tfor (;;) {\n\t\tint W, H; cin >> W >> H;\n\t\tif (W == 0 && H == 0) break;\n\t\tvector< vector<string> > a(2, vector<string>(H + 2, string(W + 2, '#')));\n\t\tfor (int y = 1; y <= H; y++) {\n\t\t\tstring s1, s2; cin >> s1 >> s2;\n\t\t\ta[0][y] = '#' + s1 + '#';\n\t\t\ta[1][y] = '#' + s2 + '#';\n\t\t}\n\t\tvector<char> xs(2), ys(2), xt(2), yt(2);\n\t\tfor (int k = 0; k < 2; k++)\n\t\t\tfor (int y = 1; y <= H; y++)\n\t\t\t\tfor (int x = 1; x <= W; x++){\n\t\t\t\t\tchar& c = a[k][y][x];\n\t\t\t\t\tif (c == 'L' || c == 'R') {\n\t\t\t\t\t\tc = '.';\n\t\t\t\t\t\txs[k] = x; ys[k] = y;\n\t\t\t\t\t}\n\t\t\t\t\telse if (c == '%') {\n\t\t\t\t\t\tc = '.';\n\t\t\t\t\t\txt[k] = x; yt[k] = y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tvector< vector<bool> > vis(3000, vector<bool>(3000));\n\t\tstack< vector<char> > stx, sty;\n\t\tstx.push(xs); sty.push(ys);\n\t\twhile (!stx.empty()) {\n\t\t\tvector<char> x = stx.top(); stx.pop();\n\t\t\tvector<char> y = sty.top(); sty.pop();\n\t\t\tvector<int> z(2);\n\t\t\tfor (int k = 0; k < 2; k++)\n\t\t\t\tz[k] = y[k] * W + x[k];\n\t\t\tvis[z[0]][z[1]] = true;\n\t\t\tif (x[0] == xt[0] && y[0] == yt[0]) continue;\n\t\t\tif (x[1] == xt[1] && y[1] == yt[1]) continue;\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tvector<char> _x = x, _y = y;\n\t\t\t\tvector<int> _z(2);\n\t\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\t\t_x[k] += (k ? dx[i] : -dx[i]);\n\t\t\t\t\t_y[k] += dy[i];\n\t\t\t\t\tif (a[k][_y[k]][_x[k]] == '#') {\n\t\t\t\t\t\t_x[k] = x[k]; _y[k] = y[k];\n\t\t\t\t\t}\n\t\t\t\t\t_z[k] = _y[k] * W + _x[k];\n\t\t\t\t}\n\t\t\t\tif (!vis[_z[0]][_z[1]]) {\n\t\t\t\t\tvis[_z[0]][_z[1]] = true;\n\t\t\t\t\tstx.push(_x);\n\t\t\t\t\tsty.push(_y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> zt(2);\n\t\tfor (int k = 0; k < 2; k++)\n\t\t\tzt[k] = yt[k] * W + xt[k];\n\t\tcout << (vis[zt[0]][zt[1]] ? \"Yes\" : \"No\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nstruct State {int i, j;};\n\nbool visited[52][52][52][52];\nchar lm[52][52], rm[52][52];\nint W, H;\nconst int di[] = {0, -1, 0, 1};\nconst int ldj[] = {-1, 0, 1, 0};\nconst int rdj[] = {1, 0, -1, 0};\n\nint main() {\n  while (scanf(\"%d%d\", &W, &H), W) {\n    rep(i,H) scanf(\"%s%s\", lm[i], rm[i]);\n    int sli, slj, sri, srj;\n    rep(i,H) {\n      rep(j,W) {\n        if (lm[i][j] == 'L') {sli = i, slj = j; lm[i][j] = '.';}\n        if (rm[i][j] == 'R') {sri = i, srj = j; rm[i][j] = '.';}\n      }\n    }\n\n    memset(visited, 0, sizeof visited);\n    queue<State> LQ, RQ;\n    LQ.push((State){sli, slj}); RQ.push((State){sri, srj});\n    bool ok = false;\n    while (!LQ.empty()) {\n      State ls = LQ.front(), rs = RQ.front(); LQ.pop(); RQ.pop();\n      if (visited[ls.i][ls.j][rs.i][rs.j]) continue;\n      visited[ls.i][ls.j][rs.i][rs.j] = true;\n      rep(i,4) {\n        State nls = ls, nrs = rs;\n        nls.i += di[i]; nls.j += ldj[i];\n        nrs.i += di[i]; nrs.j += rdj[i];\n\n        if (0 > nls.i || 0 > nls.j || nls.i >= H || nls.j >= W ||\n            lm[nls.i][nls.j] == '#') nls = ls;\n        if (0 > nrs.i || 0 > nrs.j || nrs.i >= H || nrs.j >= W ||\n            rm[nrs.i][nrs.j] == '#') nrs = rs;\n\n        if (lm[nls.i][nls.j] == '%' && rm[nrs.i][nrs.j] == '%') ok = true;\n        if (lm[nls.i][nls.j] == '%' || rm[nrs.i][nrs.j] == '%') continue;\n        if (visited[nls.i][nls.j][nrs.i][nrs.j]) continue;\n        LQ.push(nls); RQ.push(nrs);\n      }\n    }\n    printf(\"%s\\n\", ok ? \"Yes\" : \"No\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n\n#define MAX_W 50\n#define MAX_H 50\n\nusing namespace std;\n\nstruct State {\n  int lx, ly, rx, ry;\n  State (int lx, int ly, int rx, int ry): lx(lx), ly(ly), rx(rx), ry(ry) {;}\n};\n\nint W, H;\nint dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};\nchar rooml[MAX_H + 2][MAX_W + 2], roomr[MAX_H + 2][MAX_W + 2];\n\nvoid Solve(int sx[2], int sy[2])\n{\n  queue<State> que;\n\n  que.push(State(sx[0], sy[0], sx[1], sy[1]));\n\n  bool visit[MAX_H + 2][MAX_W + 2][MAX_H + 2][MAX_W + 2];\n\n  memset(visit, false, sizeof(visit));\n\n  string res = \"No\";\n  while (!que.empty()) {\n    State s = que.front(); que.pop();\n    if (visit[s.ly][s.lx][s.ry][s.rx])\n      continue;\n\n    visit[s.ly][s.lx][s.ry][s.rx] = true;\n    if (rooml[s.ly][s.lx] == '%' && roomr[s.ry][s.rx] == '%') {\n      res = \"Yes\";\n      break;\n    }\n\n    for (int k = 0; k < 4; k++) {\n      int nlx = s.lx + dx[k], nly = s.ly + dy[k],\n          nrx = s.rx - dx[k], nry = s.ry + dy[k];\n      char cl = rooml[nly][nlx], cr = roomr[nry][nrx];\n      if ((cl != '%' && cr == '%') || (cl == '%' && cr != '%')) {\n        continue;\n      }\n\n      if (cl == '#') {\n        nlx = s.lx; nly = s.ly;  \n      }\n\n      if (cr == '#') {\n        nrx = s.rx; nry = s.ry;\n      }\n\n      que.push(State(nlx, nly, nrx, nry));\n    }\n  }\n\n  cout << res << endl;\n}\n\nint main()\n{\n  while (cin >> W >> H && W && H) {\n    int sx[2], sy[2];\n    memset(rooml, '#', sizeof(rooml));\n    memset(roomr, '#', sizeof(roomr));\n\n    for (int i = 1; i <= H; i++) {\n      for (int j = 1; j <= W; j++) {\n        cin >> rooml[i][j];\n        if (rooml[i][j] == 'L') {\n          sy[0] = i; sx[0] = j;\n          rooml[i][j] == '.';\n        }\n      }\n\n\n      for (int j = 1; j <= W; j++) {\n        cin >> roomr[i][j];\n        if (roomr[i][j] == 'R') {\n          sy[1] = i; sx[1] = j;\n          roomr[i][j] == '.';\n        }\n      }\n    }\n\n    Solve(sx, sy);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nclass Solve {\nprivate:\n\tusing vb = std::vector<bool>;\n\tusing vc = std::vector<char>;\n\n\tusing i4 = std::array<int, 4>;\n\n\tint W, H;\n\tint dir4[4][2]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}}, digit[4];\n\tstd::vector<vc> Room[2];\n\n\tbool is_reachable()\n\t{\n\t\tdigit[0] = digit[2] = H + 2;\n\t\tdigit[1] = digit[3] = W + 2;\n\t\tfor (int i{}; i < 2; i++) Room[i].resize(H + 2, vc(W + 2));\n\t\tstd::fill(Room[0][0].begin(), Room[0][0].end(), '#');\n\t\tstd::fill(Room[1][0].begin(), Room[1][0].end(), '#');\n\t\tstd::fill(Room[0][H + 1].begin(), Room[0][H + 1].end(), '#');\n\t\tstd::fill(Room[1][H + 1].begin(), Room[1][H + 1].end(), '#');\n\n\t\ti4 start, goal;\n\t\tfor (int h_i{1}; h_i <= H; h_i++)\n\t\t{\n\t\t\tRoom[0][h_i][0] = Room[0][h_i][W + 1] = Room[1][h_i][0] = Room[1][h_i][W + 1] = '#';\n\t\t\tfor (int w_i{1}; w_i <= W; w_i++)\n\t\t\t{\n\t\t\t\tscanf(\" %c\", &Room[0][h_i][w_i]);\n\t\t\t\tswitch (Room[0][h_i][w_i])\n\t\t\t\t{\n\t\t\t\tcase 'L':\n\t\t\t\t\tstart[0] = h_i;\n\t\t\t\t\tstart[1] = w_i;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '%':\n\t\t\t\t\tgoal[0] = h_i;\n\t\t\t\t\tgoal[1] = w_i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int w_i{W}; w_i >= 1; w_i--)\n\t\t\t{\n\t\t\t\tscanf(\" %c\", &Room[1][h_i][w_i]);\n\t\t\t\tswitch (Room[1][h_i][w_i])\n\t\t\t\t{\n\t\t\t\tcase 'R':\n\t\t\t\t\tstart[2] = h_i;\n\t\t\t\t\tstart[3] = w_i;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '%':\n\t\t\t\t\tgoal[2] = h_i;\n\t\t\t\t\tgoal[3] = w_i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvb visited((H + 2) * (W + 2) * (H + 2) * (W + 2));\n\t\tstd::queue<i4> nexts;\n\t\tvisited[calcHash(start)] = true;\n\t\tnexts.push(start);\n\t\twhile (!nexts.empty())\n\t\t{\n\t\t\tauto now{nexts.front()};\n\t\t\tnexts.pop();\n\t\t\tfor (int i{}; i < 4; i++)\n\t\t\t{\n\t\t\t\ti4 next{calcNext(now, i)};\n\t\t\t\tint hash{calcHash(next)};\n\t\t\t\tif (visited[hash]) continue;\n\t\t\t\tif (next == goal)\n\t\t\t\t\treturn true;\n\t\t\t\tif ((next[0] == goal[0] && next[1] == goal[1]) || (next[2] == goal[2] && next[3] == goal[3]))\n\t\t\t\t\tcontinue;\n\t\t\t\tvisited[hash] = true;\n\t\t\t\tnexts.push(next);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\ti4 calcNext(i4 now, int dir)\n\t{\n\t\tif (Room[0][now[0] + dir4[dir][0]][now[1] + dir4[dir][1]] != '#')\n\t\t{\n\t\t\tnow[0] += dir4[dir][0];\n\t\t\tnow[1] += dir4[dir][1];\n\t\t}\n\t\tif (Room[1][now[2] + dir4[dir][0]][now[3] + dir4[dir][1]] != '#')\n\t\t{\n\t\t\tnow[2] += dir4[dir][0];\n\t\t\tnow[3] += dir4[dir][1];\n\t\t}\n\t\treturn now;\n\t}\n\n\tint calcHash(i4 place)\n\t{\n\t\tint ret{};\n\t\tfor (int i{}; i < 4; i++)\n\t\t\tret = digit[i] * ret + place[i];\n\t\treturn ret;\n\t}\n\npublic:\n\tbool is_last_query{};\n\tSolve()\n\t{\n\t\tscanf(\"%d%d\", &W, &H);\n\t\tif (W == 0 && H == 0)\n\t\t{\n\t\t\tis_last_query = true;\n\t\t\treturn;\n\t\t}\n\t\tif (is_reachable()) puts(\"Yes\");\n\t\telse puts(\"No\");\n\t}\n};\n\nint main()\n{\n\twhile (!Solve().is_last_query);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\n\n\nint W,H;\nstring roomL[55],roomR[55];\n\nbool range_check(int y,int x) {\n    if(y<0||x<0) return false;\n    if(H<=y||W<=x) return false;\n\n    return true;\n}\n\nbool ok(P len,P rin) {\n    bool visited[55][55][55][55]={};\n    visited[len.fr][len.sc][rin.fr][rin.sc]=true;\n    queue<PP> que;\n    que.push(PP(len,rin));\n\n    while(que.size()) {\n        PP pp=que.front(); que.pop();\n        P next_len=pp.fr;\n        P next_rin=pp.sc;\n\n        //printf(\"[debug] %d %d %d %d\\n\",next_len.fr,next_len.sc,next_rin.fr,next_rin.sc);\n\n        if(roomL[next_len.fr][next_len.sc]=='%' && roomR[next_rin.fr][next_rin.sc]=='%') {\n            return true;\n        }\n        if(roomL[next_len.fr][next_len.sc]=='%' || roomR[next_rin.fr][next_rin.sc]=='%') {\n            visited[next_len.fr][next_len.sc][next_rin.fr][next_rin.sc]=false;\n            continue;\n        }\n        rep(i,4) {\n            next_len=pp.fr;\n            next_rin=pp.sc;\n\n            if(range_check(next_len.fr+dy[i],next_len.sc+dx[i]) && roomL[next_len.fr+dy[i]][next_len.sc+dx[i]]!='#') {\n                next_len.fr+=dy[i];\n                next_len.sc+=dx[i];\n            }\n            if(range_check(next_rin.fr+dy[i],next_rin.sc-dx[i]) && roomR[next_rin.fr+dy[i]][next_rin.sc-dx[i]]!='#') {\n                next_rin.fr+=dy[i];\n                next_rin.sc-=dx[i];\n            }\n\n            if(!visited[next_len.fr][next_len.sc][next_rin.fr][next_len.sc]) {\n                visited[next_len.fr][next_len.sc][next_rin.fr][next_len.sc]=true;\n                que.push(PP(next_len,next_rin));\n            }\n        }\n    }\n\n    return false;\n}\n\nvoid solve() {\n    rep(y,H) cin>>roomL[y]>>roomR[y];\n    P len,rin;\n    rep(y,H) rep(x,W) {\n        if(roomL[y][x]=='L') len=P(y,x);\n        if(roomR[y][x]=='R') rin=P(y,x);\n    }\n    if(ok(len,rin)) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n}\n\nint main() {\n    while(cin>>W>>H) {\n        if(!W) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\nusing namespace std;\nstring s1[50],s2[50];\nint dx1[]={1,-1,0,0,},dy1[]={0,0,1,-1};\nint dx2[]={-1,1,0,0,},dy2[]={0,0,1,-1};\nint w,h,gx1,gx2,gy1,gy2;\nunordered_set<int>s;\nbool bfs(int x1,int y1,int x2,int y2){\n  queue<int>q;\n  q.push(x1+y1*100+x2*10000+y2*1000000);\n  while(!q.empty()){\n    int p=q.front();q.pop();\n    x1=p%100;y1=p%10000/100;\n    x2=p%1000000/10000;y2=p/1000000;\n    if(x1==gx1&&y1==gy1&&x2==gx2&&y2==gy2){\n      while(!q.empty())q.pop();\n      return 1;\n    }\n    for(int i=0;i<4;i++){\n      int x3=x1+dx1[i],y3=y1+dy1[i];\n      int x4=x2+dx2[i],y4=y2+dy2[i];\n      if(x3>=0&&x4>=0&&y3>=0&&y4>=0)\n        if(x3<w&&x4<w&&y3<h&&y4<h){\n          if(s1[y3][x3]=='#')y3=y1,x3=x1;\n          if(s2[y4][x4]=='#')y4=y2,x4=x2;\n          if(!(x1==gx1&&y1==gy1&&(x2!=gx2||y2!=gy2)))\n          if(!((x1!=gx1||y1!=gy1)&&x2==gx2&&y2==gy2))\n          if(!s.count(x3+y3*100+x4*10000+y4*1000000)){\n            s.insert(x3+y3*100+x4*10000+y4*1000000);\n            q.push(x3+y3*100+x4*10000+y4*1000000);\n          }\n        }\n      }\n    }\n    return 0;\n}\nint main(){\n  int x1,y1,x2,y2;\n  while(cin>>w>>h,w){\n    s.clear();\n    r(i,h)cin>>s1[i]>>s2[i];\n    r(i,h)r(j,w){\n      if(s1[i][j]=='L')x1=j,y1=i;\n      if(s2[i][j]=='R')x2=j,y2=i;\n      if(s1[i][j]=='%')gx1=j,gy1=i;\n      if(s2[i][j]=='%')gx2=j,gy2=i;\n    }\n    s.insert(x1+y1*100+x2*10000+y2*1000000);\n    if(bfs(x1,y1,x2,y2))cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\nusing namespace std;\n\nstruct Pos{int x,y;};\nstruct Pair{Pos LIN,REN;};\nbool same(Pos a,Pos b){return a.x==b.x && a.y==b.y;}\nbool same(Pair a,Pair b){return same(a.LIN,b.LIN) && same(a.REN,b.REN);}\n\nint main()\n{\nPair start,goal;\n\nint W,H;\nchar RoomL[52][52],RoomR[52][52];\nbool visited[52][52][52][52];\n\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n  string l,r;\n  while(cin>>W>>H,W|H){\n    memset(RoomL,'#',sizeof(RoomL));\n    memset(RoomR,'#',sizeof(RoomR));\n    for(int i=1;i<=H;i++){\n      cin>>l>>r;\n      for(int j=1;j<=W;j++){\n\tRoomL[i][j]=l[j-1];\n\tRoomR[i][j]=r[j-1];\n\tif(RoomL[i][j]=='L'){\n\t  start.LIN.x=j;\n\t  start.LIN.y=i;\n\t}\n\tif(RoomL[i][j]=='%'){\n\t  goal.LIN.x=j;\n\t  goal.LIN.y=i;\n\t}\n\tif(RoomR[i][j]=='R'){\n\t  start.REN.x=j;\n\t  start.REN.y=i;\n\t}\n\tif(RoomR[i][j]=='%'){\n\t  goal.REN.x=j;\n\t  goal.REN.y=i;\n\t}\n      }\n    }\nbool f=false;\n  memset(visited,0,sizeof(visited));\n  queue<Pair>q;\n  q.push(start);\n  Pair now,next;\n  while(!q.empty()){\n    now=q.front();\n    q.pop();\n    if(same(now,goal)){f=true;break;}\n    if(same(now.LIN,goal.LIN))continue;\n    if(same(now.REN,goal.REN))continue;\n    visited[now.LIN.y][now.LIN.x][now.REN.y][now.REN.x]=true;\n    for(int i=0;i<4;i++){\n      next=now;\n      next.LIN.x+=dx[i];\n      next.LIN.y+=dy[i];\n      next.REN.x+=-dx[i];\n      next.REN.y+=dy[i];\n      if(RoomL[next.LIN.y][next.LIN.x]=='#')next.LIN=now.LIN;\n      if(RoomR[next.REN.y][next.REN.x]=='#')next.REN=now.REN;\n      if(visited[next.LIN.y][next.LIN.x][next.REN.y][next.REN.x])continue;\n      q.push(next);\n    }\n  }\n    puts(f?\"Yes\":\"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<queue>\n#define MAX 60\nusing namespace std;\nstruct Point{int x,y;};\nstruct P{\n  Point l,r;\n  int cost;\n  bool operator<(const P &a)const{\n    return (l.x==a.l.x?\n\t    (l.y==a.l.y?\n\t     (r.x==a.r.x?\n\t      (r.y<a.r.y):r.x<a.r.x)\n\t     :l.y<a.l.y)\n\t    :l.x<a.l.x);\n  }\n};\nint main(){\n  int w,h;\n  while(cin>>w>>h,w||h){\n    int i,j,k;\n    int inf = 1<<20;\n    \n    bool d[MAX+1][MAX+1][MAX+1][MAX+1];\n    fill(d[0][0][0],d[MAX][MAX][MAX],0);\n    \n    map<P,int> m;\n    string sr[60],sl[60];\n    for(i=0;i<h;i++){\n      cin >> sl[i] >> sr[i];\n    }\n    \n    Point pr,pl,br,bl;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(sl[i][j]=='L'){\n\t  pl.x=j;pl.y=i;\n\t}\n\tif(sr[i][j]=='R'){\n\t  pr.x=j;pr.y=i;\n\t}\n      }\n    }\n    //cout << pl.x << \":\" << pl.y << endl;\n    //cout << pr.x << \":\" << pr.y << endl;\n    //d[pl.x][pl.y][pr.x][pr.y]=\n    P p,b;\n    p.r=pr;\n    p.l=pl;\n    p.cost=0;\n    //m[p]=p.cost;\n    queue<P> q;\n    q.push(p);\n    bool f = false;\n    while(!q.empty()){\n      p=q.front();q.pop();\n      pl=p.l;pr=p.r;\n      /*\n      if(m.find(p)!=m.end())\n\tif(p.cost>m[p]) continue;\n      m[p]=p.cost;\n      */\n      if(d[pl.x][pl.y][pr.x][pr.y]) continue;\n      d[pl.x][pl.y][pr.x][pr.y]=true;\n      \n      //cout << pl.x<<\":\"<<pl.y<<\":\"<<pr.x<<\":\"<<pr.y<<\"/\"<<p.cost<<endl;\n      if(sl[pl.y][pl.x]=='%'&&sr[pr.y][pr.x]=='%'){\n\tf=true;\n\tbreak;\n      }else if(sl[pl.y][pl.x]=='%') continue;\n      else if(sr[pr.y][pr.x]=='%') continue;\n      \n      p.cost++;\n      int lx[]={1,-1,0,0};int ly[]={0,0,1,-1};\n      int rx[]={-1,1,0,0};int ry[]={0,0,1,-1};\n      for(i=0;i<4;i++){\n\tbl=pl;br=pr;\n\tbl.x+=lx[i];bl.y+=ly[i];\n\tbr.x+=rx[i];br.y+=ry[i];\n\n\t//cout << bl.x<<\":\"<<bl.y<<\":\"<<br.x<<\":\"<<br.y<<\"/\"<<p.cost<<endl;\n\t\n\tif(bl.x<0) bl.x=0;\n\telse if(bl.x>=w) bl.x=w-1;\n\tif(bl.y<0) bl.y=0;\n\telse if(bl.y>=h) bl.y=h-1;\n\n\tif(br.x<0) br.x=0;\n\telse if(br.x>=w) br.x=w-1;\n\tif(br.y<0) br.y=0;\n\telse if(br.y>=h) br.y=h-1;\n\n\tif(sl[bl.y][bl.x]=='#'){\n\t  bl.x-=lx[i];bl.y-=ly[i];\n\t}\n\tif(sr[br.y][br.x]=='#'){\n\t  br.x-=rx[i];br.y-=ry[i];\n\t}\n\tp.r=br;p.l=bl;\n\tq.push(p);\n\t//m[p]=p.cost;\n      }\n    }\n    if(f) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_W 50\n#define MAX_H 50\n//深さ優先探索で行けるんじゃないか？\n\n\nint di[4] = {0, -1, 0, 1};\nint dj[4] = {1, 0, -1, 0};\nvector<vector<bool> > Room_L(MAX_H + 2, vector<bool> (MAX_W + 2, false));\nvector<vector<bool> > Room_R(MAX_H + 2, vector<bool> (MAX_W + 2, false));\nint si_L, si_R, sj_L, sj_R, gi_L, gi_R, gj_L, gj_R;  //スタートとゴールの座標\n\n\nint main(){\n\n    //cout << \"ok\" << endl;\n    while(1){\n        \n        Room_L = vector<vector<bool> > (MAX_H + 2, vector<bool> (MAX_W + 2, false));\n        Room_R = vector<vector<bool> > (MAX_H + 2, vector<bool> (MAX_W + 2, false));\n\n        //入力\n        //cout << \"ol\" << endl;\n        int W, H; cin >> W >> H;\n        if(W == 0) break;\n\n        for(int i = 0; i <= H + 1; i++){\n            for(int j = 0; j <= W + 1; j++){\n                Room_L[i][j] = Room_R[i][j] = false;\n            }\n        }\n\n        for(int i = 1; i <= H; i++){\n            //L\n            for(int j = 1; j <= W; j++){\n                char input; cin >> input;\n                if(input == '#') continue;\n                else{\n                    Room_L[i][j] = true;\n\n                    if(input == '%'){\n                        gi_L = i;\n                        gj_L = j;\n                    }\n\n                    if(input == 'L'){\n                        si_L = i;\n                        sj_L = j;\n                    }\n                }\n            }\n\n            //R\n            for(int j = 1; j <= W; j++){\n                char input; cin >> input;\n                if(input == '#') continue;\n                else{\n                    Room_R[i][j] = true;\n\n                    if(input == '%'){\n                        gi_R = i;\n                        gj_R = j;\n                    }\n\n                    if(input == 'R'){\n                        si_R = i;\n                        sj_R = j;\n                    }\n                }\n            }\n        }\n\n\n        //幅優先をする\n        //set<pair<pair<int, int>, pair<int, int> > > s;\n        bool C[51][51][51][51] = {};\n        queue<pair<pair<int, int>, pair<int, int> > > wait;                      //左の座標　右の座標\n        wait.push({ {si_L, sj_L}, {si_R, sj_R} });\n        //s.insert({ {si_L, sj_L}, {si_R, sj_R} });\n        C[si_L][sj_L][si_R][sj_R] = true;\n        \n        bool can = false;\n\n        while(!wait.empty()){    //キュー画空になるまで\n\n\n            //キューの先頭要素を取り出す\n            int nowi_L = wait.front().first.first;\n            int nowj_L = wait.front().first.second;\n            int nowi_R = wait.front().second.first;\n            int nowj_R = wait.front().second.second;\n            //cout << nowi_L << \" \" << nowj_L << \"  \" << nowi_R << \" \" << nowj_R << endl;\n            wait.pop();\n\n            //四方向を探索\n            for(int k = 0; k < 4; k++){\n                int nexti_L = nowi_L + di[k];\n                int nextj_L = nowj_L + dj[k];\n                int nexti_R = nowi_R + di[k];\n                int nextj_R = nowj_R - dj[k];\n                //cout << \" \" << nexti_L << \" \" << nextj_L << \"  \" << nexti_R << \" \" << nextj_R << endl;\n\n\n                int L = Room_L[nexti_L][nextj_L];\n                int R = Room_R[nexti_R][nextj_R];\n                //cout << \" \" << L << \" \" << R << endl;\n                \n\n                //その方向に進めるなら\n                if(nexti_L == gi_L && nextj_L == gj_L && nexti_R == gi_R && nextj_R == gj_R){\n                    can = true;\n                    break;\n                }else if((nexti_L == gi_L && nextj_L == gj_L) || (nexti_R == gi_R && nextj_R == gj_R)){\n                    continue;\n                }else if(R && L && !C[nexti_L][nextj_L][nexti_R][nextj_R]){\n                    wait.push({{nexti_L, nextj_L}, {nexti_R, nextj_R}});\n                    C[nexti_L][nextj_L][nexti_R][nextj_R] = true;\n                }else if(R && !L &&  !C[nowi_L][nowj_L][nexti_R][nextj_R]){\n                    wait.push({{nowi_L, nowj_L}, {nexti_R, nextj_R}});\n                    C[nowi_L][nowj_L][nowi_R][nowj_R] = true;\n                }else if(!R && L && !C[nexti_L][nextj_L][nowi_R][nowj_R]){\n                    wait.push({{nexti_L, nextj_L}, {nowi_R, nowj_R}});\n                    C[nexti_L][nextj_L][nowi_R][nowj_R] = true;\n                }\n            }\n        }\n\n        if(can) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\nusing namespace std;\nstruct po{int lx,ly,rx,ry;};\nint w,h;\nstring mp[2][51];\nbool visited[51][51][51][51];\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\n\nbool bfs(int lx,int ly,int rx,int ry){\n  queue <po> Q;\n  Q.push((po){lx,ly,rx,ry});\n  while(!Q.empty()){\n    po t=Q.front();Q.pop();\n    int cnt=(mp[0][t.ly][t.lx]=='%')+(mp[1][t.ry][t.rx]=='%');\n    if(cnt==2)return true;\n    if(visited[t.lx][t.ly][t.rx][t.ry]||cnt==1)continue;\n    visited[t.lx][t.ly][t.rx][t.ry]=1;\n    for(int i=0;i<4;i++){\n      int flg=0;\n      int nlx=t.lx+dx[i],nly=t.ly+dy[i];\n      int nrx=t.rx-dx[i],nry=t.ry+dy[i];\n      if(nlx<0||nly<0||nlx>=w||nly>=h||mp[0][nly][nlx]=='#')nlx=t.lx,nly=t.ly,flg++;\n      if(nrx<0||nry<0||nrx>=w||nry>=h||mp[1][nry][nrx]=='#')nrx=t.rx,nry=t.ry,flg++;\n      if(flg==2)continue;\n      Q.push((po){nlx,nly,nrx,nry});\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(1){\n    cin >>w>>h;\n    if(!w&&!h)break;\n    for(int i=0;i<h;i++)cin>>mp[0][i]>>mp[1][i];\n    int lx,ly,rx,ry;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(mp[0][i][j]=='L')lx=j,ly=i;\n\tif(mp[1][i][j]=='R')rx=j,ry=i;\n      }\n\n    memset(visited,0,sizeof(visited));\n    if(bfs(lx,ly,rx,ry))cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,s,n) for(int i=s; i<n; i++)\n#define ALL(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nint w, h;\nbool wl[55][55], wr[55][55];\nbool memo[55][55][55][55];\nint gxl, gyl, gxr, gyr;\n\nbool dfs(int xl, int yl, int xr, int yr) {\n\tif( memo[xl][yl][xr][yr] ) {\n\t\treturn false;\n\t}\n//\tcout << \"dfs \" << xl << \" \" << yl << \" \" << xr << \" \" << yr << endl;\n\tmemo[xl][yl][xr][yr] = true;\n\tif(xl==gxl && yl==gyl && xr==gxr && yr==gyr) {\n\t\treturn true;\n\t}\n\tint dx[4] = {-1, 0, 1, 0};\n\tint dy[4] = {0, 1, 0, -1};\n\tbool f = false;\n\trep(i, 4) {\n\t\tint nxl = xl + dx[i];\n\t\tint nyl = yl + dy[i];\n\t\tint nxr = xr - dx[i];\n\t\tint nyr = yr + dy[i];\n\t\tbool nl = wl[nyl][nxl];\n\t\tbool nr = wr[nyr][nxr];\n\t\tif( !nl && !nr ) {\n\t\t\tf |= dfs(nxl, nyl, nxr, nyr);\n\t\t}\n\t\telse if( !nl && nr ) {\n\t\t\tf |= dfs(nxl, nyl, xr, yr);\n\t\t}\n\t\telse if( nl && !nr ) {\n\t\t\tf |= dfs(xl, yl, nxr, nyr);\n\t\t}\n\t}\n\treturn f;\n}\n\nint main() {\n\twhile(cin >> w >> h, w) {\n\t\tmemset(wl, 0, sizeof(wl));\n\t\tmemset(wr, 0, sizeof(wr));\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tint xl=1, yl=1, xr=1, yr=1;\n\t\trep(y, h) {\n\t\t\tstring sl, sr;\n\t\t\tcin >> sl >> sr;\n\t\t\trep(x, w) {\n\t\t\t\tif(sl[x] == 'L') {\n\t\t\t\t\txl = x+1;\n\t\t\t\t\tyl = y+1;\n\t\t\t\t\twl[y+1][x+1] = false;\n\t\t\t\t} else if(sl[x] == '%') {\n\t\t\t\t\tgxl = x+1;\n\t\t\t\t\tgyl = y+1;\n\t\t\t\t\twl[y+1][x+1] = false;\n\t\t\t\t} else {\n\t\t\t\t\twl[y+1][x+1] = (sl[x]=='#');\n\t\t\t\t}\n\t\t\t\tif(sr[x] == 'R') {\n\t\t\t\t\txr = x+1;\n\t\t\t\t\tyr = y+1;\n\t\t\t\t\twr[y+1][x+1] = false;\n\t\t\t\t} else if(sr[x] == '%') {\n\t\t\t\t\tgxr = x+1;\n\t\t\t\t\tgyr = y+1;\n\t\t\t\t\twr[y+1][x+1] = false;\n\t\t\t\t} else {\n\t\t\t\t\twr[y+1][x+1] = (sr[x]=='#');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int y=0; y<=h+1; y++) {\n\t\t\twr[y][0] = true;\n\t\t\twr[y][w+1] = true;\n\t\t\twl[y][0] = true;\n\t\t\twl[y][w+1] = true;\n\t\t}\n\t\tfor(int x=0; x<=w+1; x++) {\n\t\t\twr[0][x] = true;\n\t\t\twr[h+1][x] = true;\n\t\t\twl[0][x] = true;\n\t\t\twl[h+1][x] = true;\n\t\t}\n\t\tif( dfs(xl, yl, xr, yr) ) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t} else {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<tuple>\n#include<string>\nusing namespace std;\n\n#define MAX_N 60\n#define INF 1<<30\n\nint dist[MAX_N][MAX_N][MAX_N][MAX_N];\nint dy1[4] = { 0,1,0,-1 };\nint dy2[4] = { 0,1,0,-1 };\nint dx1[4] = { 1,0,-1,0 };\nint dx2[4] = { -1,0,1,0 };\nint H, W, map1[MAX_N][MAX_N], map2[MAX_N][MAX_N];\nint Lsy, Lsx, Lgy, Lgx;\nint Rsy, Rsx, Rgy, Rgx;\nstring S, T;\nqueue<tuple<int, int, int, int>>Q;\n\nvoid _memset() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tfor (int k = 0; k < MAX_N; k++) {\n\t\t\t\tfor (int l = 0; l < MAX_N; l++) {\n\t\t\t\t\tdist[i][j][k][l] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tmap1[i][j] = 1;\n\t\t\tmap2[i][j] = 1;\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\t_memset();\n\t\tcin >> W >> H;\n\t\tif (H == 0 && W == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tcin >> S >> T;\n\t\t\tfor (int j = 0; j < S.size(); j++) {\n\t\t\t\tif (S[j] == '%') {\n\t\t\t\t\tLsx = j + 1; Lsy = i;\n\t\t\t\t\tmap1[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\tif (S[j] == '#') {\n\t\t\t\t\tmap1[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (S[j] == '.') {\n\t\t\t\t\tmap1[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (S[j] == 'L') {\n\t\t\t\t\tLgy = i; Lgx = j + 1;\n\t\t\t\t\tmap1[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < T.size(); j++) {\n\t\t\t\tif (T[j] == '%') {\n\t\t\t\t\tRsx = j + 1; Rsy = i;\n\t\t\t\t\tmap2[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\tif (T[j] == '#') {\n\t\t\t\t\tmap2[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (T[j] == '.') {\n\t\t\t\t\tmap2[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (T[j] == 'R') {\n\t\t\t\t\tRgy = i; Rgx = j + 1;\n\t\t\t\t\tmap2[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQ.push(make_tuple(Lsy, Lsx, Rsy, Rsx));\n\t\tdist[Lsy][Lsx][Rsy][Rsx] = 0;\n\n\t\twhile (!Q.empty()) {\n\t\t\ttuple<int, int, int, int>tup = Q.front(); Q.pop();\n\t\t\tint ay = get<0>(tup);\n\t\t\tint ax = get<1>(tup);\n\t\t\tint by = get<2>(tup);\n\t\t\tint bx = get<3>(tup);\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint ey = ay + dy1[i], ex = ax + dx1[i];\n\t\t\t\tint fy = by + dy2[i], fx = bx + dx2[i];\n\t\t\t\tif (map1[ey][ex] == 1) {\n\t\t\t\t\tey = ay; ex = ax;\n\t\t\t\t}\n\t\t\t\tif (map2[fy][fx] == 1) {\n\t\t\t\t\tfy = by; fx = bx;\n\t\t\t\t}\n\t\t\t\tif (dist[ey][ex][fy][fx] == INF) {\n\t\t\t\t\tdist[ey][ex][fy][fx] = dist[ay][ax][by][bx] + 1;\n\t\t\t\t\tQ.push(make_tuple(ey, ex, fy, fx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[Lgy][Lgx][Rgy][Rgx] == INF) {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing psi=pair<string,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define MOD (1e9+7)\nvoid get(){}template<class H,class...T>void get(H&h,T&...t){cin>>h;get(t...);}\ntemplate<class T>void geti(T&a){for(auto&_:a)cin>>_;}\ntemplate<class T>void getii(T&a){for(auto&_:a)geti(_);}\nvoid put(string d){}template<class H,class...T>void put(string d,H&h,T&...t){cout<<h;if(sizeof...(t))cout<<d;put(d,t...);}\ntemplate<class T>void puti(T&a,string d=\" \"){bool f=1;for(auto&_:a)cout<<(exchange(f,0)?\"\":d)<<_;cout<<endl;}\ntemplate<class T>void putii(T&a,string d=\" \"){for(auto&_:a)puti(_,d);}\n#define dcl(...) ll __VA_ARGS__;get(__VA_ARGS__)\n#define dclt(t,...) t __VA_ARGS__;get(__VA_ARGS__)\n\n#define fs first\n#define sc second\n\nint main(){\n\tint w,h;\n\twhile(cin>>w>>h,w){\n\t\tvector<vvi> f(2,vvi(h+2,vi(w+2,1)));\n\t\tpair<pii,pii> curr;\n\t\tpair<pii,pii> stat;\n\t\tfor(int i=1;i<=h;i++){\n\t\t\trep(p,2){\n\t\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\t\tchar c; cin>>c;\n\t\t\t\t\tif(c=='.'){\n\t\t\t\t\t\tf[p][i][j]=0;\n\t\t\t\t\t}else if(c=='%'){\n\t\t\t\t\t\tf[p][i][j]=0;\n\t\t\t\t\t\tif(p==0){\n\t\t\t\t\t\t\tstat.first={i,j};\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tstat.second={i,w+1-j};\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(c=='L'){\n\t\t\t\t\t\tf[p][i][j]=0;\n\t\t\t\t\t\tcurr.first={i,j};\n\t\t\t\t\t}else if(c=='R'){\n\t\t\t\t\t\tf[p][i][j]=0;\n\t\t\t\t\t\tcurr.second={i,w+1-j};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treverse(all(f[1][i]));\n\t\t}\n\t\t//putii(f[0],\"\");\n\t\t//cout<<endl;\n\t\t//putii(f[1],\"\");\n\t\t//cout<<\"=======\"<<endl;\n\t\t\n\t\t/*幅優先\n\t\t\t・どちらか片方だけ動き、動いた先がゴールでない場合\n\t\t\t・両方動き、かつ少なくともどちらかがそのマスを訪れたことがない場合\n\t\t\tだけ、探索する\n\t\t*/\n\t\tset<pair<pii,pii>> isVisited;\n\n\t\tqueue<pair<pii,pii>> que;\n\t\tque.push(curr);\n\t\tint y[]={-1,0,1,0};\n\t\tint x[]={0,1,0,-1};\n\t\tauto step=[f](pii &pos,int lr, int y, int x){\n\t\t\tif(f[lr][pos.fs+y][pos.sc+x]!=1){\n\t\t\t\tpos.fs+=y;\n\t\t\t\tpos.sc+=x;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tbool ok=false;\n\t\twhile(!que.empty()){\n\t\t\tauto c=que.front();\n\t\t\tque.pop();\n\t\t\t//cout<<c[0][0]<<\",\"<<c[0][1]<<\"  \"<<c[1][0]<<\",\"<<c[1][1]<<endl;\n\t\t\tif(isVisited.find(c)!=isVisited.end()){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tisVisited.insert(c);\n\t\t\trep(v,4){\n\t\t\t\tauto next=c;\n\t\t\t\tbool l=step(next.fs,0,y[v],x[v]);\n\t\t\t\tbool r=step(next.sc,1,y[v],x[v]);\n\t\t\t\tif(next==stat){\n\t\t\t\t\tok=true;\n\t\t\t\t\tgoto fin;\n\t\t\t\t}\n\n\t\t\t\tif(isVisited.find(next)==isVisited.end()){\n\t\t\t\t\tif( (!l and r and next.sc!=stat.sc)\n\t\t\t\t\t\tor (l and !r and next.fs!=stat.fs)\n\t\t\t\t\t\tor ( l and r and (next.fs!=stat.fs and next.sc!=stat.sc) )){\n\t\t\t\t\t\t//cout<<\" o \"<<next[0][0]<<\",\"<<next[0][1]<<\"  \"<<next[1][0]<<\",\"<<next[1][1]<<endl;\n\t\t\t\t\t\tque.push(next);\n\t\t\t\t\t}else{\n\t\t\t\t\t\t//cout<<\" x \"<<next[0][0]<<\",\"<<next[0][1]<<\"  \"<<next[1][0]<<\",\"<<next[1][1]<<endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfin:;\n\t\tif(ok){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t}else{\n\t\t\tcout<<\"No\"<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstdio>\n#include <string.h>\nusing namespace std;\nbool flag[52][52][52][52]={};\nint Rv[]={0,1,0,-1};\nint Lv[]={0,-1,0,1};\nint Yv[]={1,0,-1,0};\nint main(){\n\tint W,H;\n\twhile(cin>>W>>H,W){\n\t\tchar Len[52][52],Rin[52][52];\n\t\tmemset(flag,0,sizeof(flag));\n\t\tfor(int i=0;i<52;i++)for(int j=0;j<52;j++)Len[i][j]=Rin[i][j]='#';\n\t\tqueue<int>LxQ;\n\t\tqueue<int>LyQ;\n\t\tqueue<int>RxQ;\n\t\tqueue<int>RyQ;\n\t\t\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tfor(int j=1;j<=W;j++){\n\t\t\t\tcin>>Len[j][i];\n\t\t\t\tif(Len[j][i]=='L')LxQ.push(j),LyQ.push(i);\n\t\t\t}\n\t\t\tfor(int j=1;j<=W;j++){\n\t\t\t\tcin>>Rin[j][i];\n\t\t\t\tif(Rin[j][i]=='R')RxQ.push(j),RyQ.push(i);\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\t\n\t\twhile(LxQ.empty()==0){\n\t\t\tint Lx,Ly,Rx,Ry;\n\t\t\tLx=LxQ.front();\n\t\t\tLy=LyQ.front();\n\t\t\tRx=RxQ.front();\n\t\t\tRy=RyQ.front();\n\t\t\t\n\t\t\tif(Len[Lx][Ly]=='%'&&Rin[Rx][Ry]=='%'){\n\t\t\t\tans=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(Len[Lx][Ly]=='%'||Rin[Rx][Ry]=='%'){\n\t\t\t\t\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tLx=LxQ.front();\n\t\t\t\t\tLy=LyQ.front();\n\t\t\t\t\tRx=RxQ.front();\n\t\t\t\t\tRy=RyQ.front();\n\t\t\t\t\tif(Len[Lx+Lv[i]][Ly+Yv[i]]!='#')Lx+=Lv[i],Ly+=Yv[i];\n\t\t\t\t\tif(Rin[Rx+Rv[i]][Ry+Yv[i]]!='#')Rx+=Rv[i],Ry+=Yv[i];\n\t\t\t\t\tif(flag[Lx][Ly][Rx][Ry]==0){\n\t\t\t\t\t\tflag[Lx][Ly][Rx][Ry]=1;\n\t\t\t\t\t\tLxQ.push(Lx);\n\t\t\t\t\t\tLyQ.push(Ly);\n\t\t\t\t\t\tRxQ.push(Rx);\n\t\t\t\t\t\tRyQ.push(Ry);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tLxQ.pop();\n\t\t\tLyQ.pop();\n\t\t\tRxQ.pop();\n\t\t\tRyQ.pop();\n\t\t}\n\t\t\n\t\tif(ans)cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct Point {\n  int x1, y1, x2, y2;\n  Point() {;}\n  Point(int x1, int y1, int x2, int y2) : x1(x1), y1(y1), x2(x2), y2(y2) {;}\n};\n\nint w, h;\nbool in(int x, int y) { return x >= 0 && x < w && y >= 0 && y < h; }\n  \nchar field[2][100][100];\nbool visit[60][60][60][60];\nint dx[4] = { 1, 0, -1, 0 };\nint dy[4] = { 0, 1, 0, -1 };\n\nint main() {\n  while (scanf(\"%d %d\", &w, &h), w|h) {\n    MEMSET(visit, false);\n    int sx1, sy1, sx2, sy2;\n    REP(y, h) {\n      scanf(\"%s %s\", field[0][y], field[1][y]);\n      REP(x, w) {\n        if (field[0][y][x] == 'L') { sx1 = x; sy1 = y; }\n        if (field[1][y][x] == 'R') { sx2 = x; sy2 = y; }\n      }\n    }\n    queue<Point> que;\n    que.push(Point(sx1, sy1, sx2, sy2));\n    while (!que.empty()) {\n      Point p = que.front();\n      que.pop();\n      REP(dir, 4) {\n        int nx1 = p.x1 + dx[dir];\n        int ny1 = p.y1 + dy[dir];\n        int nx2 = p.x2 - dx[dir];\n        int ny2 = p.y2 + dy[dir];\n        if (!in(nx1, ny1) || !in(nx2, ny2)) { continue; }\n        if (field[0][ny1][nx1] == '#') { nx1 -= dx[dir]; ny1 -= dy[dir]; }\n        if (field[1][ny2][nx2] == '#') { nx2 += dx[dir]; ny2 -= dy[dir]; }\n        if (field[0][p.y1][p.x1] == '%' && field[1][p.y2][p.x2] == '%') { \n          puts(\"Yes\");\n          goto next;\n        }\n        if (field[0][p.y1][p.x1] == '%' || field[1][p.y2][p.x2] == '%') { \n          continue;\n        }\n        if (visit[ny1][nx1][ny2][nx2]) { continue; }\n        visit[ny1][nx1][ny2][nx2] = true;\n        que.push(Point(nx1, ny1, nx2, ny2));\n      }\n    }\n    puts(\"No\");\nnext:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <string.h>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <set>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\n#define For(i,a,n)\tfor(int i = a;i < n;i++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(n)\t\tmemset(n,0,sizeof n)\n#define all(n)\t\t(n).begin(),(n).end()\n\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\ntypedef pair<P, P> WP;\ntypedef long long ll;\n\nconst ll INF = 1e9;\nint dx[4] = { 0, 1, 0, -1 }, dy[4] = { 1, 0, -1, 0 };\nbool cheak(int x, int y, int mx, int my){\n\treturn x >= 0 && y >= 0 && x < mx &&  y < my;\n}\n\nstring s[2][51];\n\nint d[51][51][51][51];\n\nint main()\n{\n\tint w, h;\n\n\twhile (cin >> w >> h && w){\n\t\tclr(d);\n\t\tint sx[2], sy[2];\n\t\tint gx[2], gy[2];\n\t\trep(y, h){\n\t\t\tcin >> s[0][y] >> s[1][y];\n\t\t\trep(x, w){\n\t\t\t\tif (s[0][y][x] == '%')gx[0] = x, gy[0] = y;\n\t\t\t\tif (s[1][y][x] == '%')gx[1] = x, gy[1] = y;\n\t\t\t\tif (s[0][y][x] == 'L')sx[0] = x, sy[0] = y;\n\t\t\t\tif (s[1][y][x] == 'R')sx[1] = x, sy[1] = y;\n\t\t\t}\n\t\t}\n\t\td[sy[0]][sx[0]][sy[1]][sx[1]] = 1;\n\n\t\tqueue<P> q0, q1;\n\t\tq0.push(P(sy[0], sx[0]));\n\t\tq1.push(P(sy[1], sx[1]));\n\n\t\twhile (q0.size()){\n\t\t\tint ly = q0.front().first, lx = q0.front().second;\n\t\t\tint ry = q1.front().first, rx = q1.front().second;\n\t\t\tq0.pop(), q1.pop();\n\n\t\t\trep(i, 4){\n\t\t\t\tint nlx = lx + dx[i], nly = ly + dy[i];\n\t\t\t\tint nrx = rx - dx[i], nry = ry + dy[i];\n\n\t\t\t\tbool lf = (cheak(nlx, nly, w, h) && s[0][nly][nlx] != '#');\n\t\t\t\tbool rf = (cheak(nrx, nry, w, h) && s[1][nry][nrx] != '#');\n\n\t\t\t\tif ((rf || lf)){\n\t\t\t\t\tif (!lf)nlx = lx, nly = ly;\n\t\t\t\t\tif (!rf)nrx = rx, nry = ry;\n\t\t\t\t\tif (!d[nly][nlx][nry][nrx]){\n\n\t\t\t\t\t\tif (s[0][nlx][nly] == '%' || s[1][nrx][nry] == '%'){\n\t\t\t\t\t\t\tif (!s[0][nlx][nly] == '%' || !s[1][nrx][nry] == '%'){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\td[nly][nlx][nry][nrx] = 1;\n\t\t\t\t\t\tq0.push(P(nly, nlx));\n\t\t\t\t\t\tq1.push(P(nry, nrx));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[gy[0]][gx[0]][gy[1]][gx[1]])cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nint W, H;\nstruct pos\n{\n\tint x, y, dis;\n};\nint main() {\n\n\twhile (cin >> W >> H, W | H){\n\t\tvector<string> vsl;\n\t\tvector<string> vsr;\n\t\tREP(i, H){\n\t\t\tstring l;\n\t\t\tstring r;\n\t\t\tcin >> l >> r;\n\t\t\tvsl.push_back(l);\n\t\t\tvsr.push_back(r);\n\t\t}\n\t\tvector<vector<int>> vvil(H);\n\t\tvector<vector<int>> vvir(H);\n\t\tint glx;\n\t\tint gly;\n\t\tint grx;\n\t\tint gry;\n\t\tint lx;\n\t\tint ly;\n\t\tint rx;\n\t\tint ry;\n\t\tREP(i, H){\n\t\t\tREP(j, W){\n\t\t\t\tif (vsl[i][j] == '#')vvil[i].push_back(-1);\n\t\t\t\telse vvil[i].push_back(9999);\n\n\t\t\t\tif (vsr[i][j] == '#')vvir[i].push_back(-1);\n\t\t\t\telse vvir[i].push_back(9999);\n\n\t\t\t\tif (vsl[i][j] == 'L'){\n\t\t\t\t\tlx = j;\n\t\t\t\t\tly = i;\n\t\t\t\t}\n\t\t\t\tif (vsr[i][j] == 'R'){\n\t\t\t\t\trx = j;\n\t\t\t\t\try = i;\n\t\t\t\t}\n\t\t\t\tif (vsl[i][j] == '%'){\n\t\t\t\t\tglx = j;\n\t\t\t\t\tgly = i;\n\t\t\t\t}\n\t\t\t\tif (vsr[i][j] == '%'){\n\t\t\t\t\tgrx = j;\n\t\t\t\t\tgry = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<pos> vp;\n\t\tvp.push_back({ glx, gly, 0 });\n\t\twhile (!vp.empty()){\n\t\t\tpos p = vp[0];\n\t\t\tvp.erase(vp.begin());\n\t\t\tREP(i, 4){\n\t\t\t\tif (p.x + dx[i] >= 0 && p.x + dx[i] < W&&p.y + dy[i] >= 0 && p.y + dy[i] < H&& vvil[p.y + dy[i]][p.x + dx[i]] != -1 && vvil[p.y + dy[i]][p.x + dx[i]] == 9999){\n\t\t\t\t\tvp.push_back({ p.x + dx[i], p.y + dy[i], p.dis + 1 });\n\t\t\t\t\tvvil[p.y + dy[i]][p.x + dx[i]] = p.dis + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvp.push_back({ grx, gry, 0 });\n\t\twhile (!vp.empty()){\n\t\t\tpos p = vp[0];\n\t\t\tvp.erase(vp.begin());\n\t\t\tREP(i, 4){\n\t\t\t\tif (p.x + dx[i] >= 0 && p.x + dx[i] < W&&p.y + dy[i] >= 0 && p.y + dy[i] < H&& vvir[p.y + dy[i]][p.x + dx[i]] != -1 && vvir[p.y + dy[i]][p.x + dx[i]] == 9999){\n\t\t\t\t\tvp.push_back({ p.x + dx[i], p.y + dy[i], p.dis + 1 });\n\t\t\t\t\tvvir[p.y + dy[i]][p.x + dx[i]] = p.dis + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<int> vi;\n\t\tvi.push_back(lx * 1000000 + ly * 10000 + rx * 100 + ry);\n\t\tint count = 0;\n\t\tint pcount = 1;\n\t\tbool clear = false;\n\t\twhile (1){\n\t\t\t/*if (vi[count] == glx * 1000000 + gly * 10000 + grx * 100 + gry){\n\t\t\t\tclear = true;\n\t\t\t\tbreak;\n\t\t\t\t}*/\n\t\t\tint lx2 = vi[count] / 1000000 % 100;\n\t\t\tint ly2 = vi[count] / 10000 % 100;\n\t\t\tint rx2 = vi[count] / 100 % 100;\n\t\t\tint ry2 = vi[count] % 100;\n\n\t\t\tREP(i, 4){\n\t\t\t\tint lx3 = lx2;\n\t\t\t\tint ly3 = ly2;\n\t\t\t\tint rx3 = rx2;\n\t\t\t\tint ry3 = ry2;\n\t\t\t\tif (dx[i] != 0 && lx3 + dx[i] >= 0 && lx3 + dx[i] < W && vsl[ly3 + dy[i]][lx3 + dx[i]] != '#')lx3 += dx[i];\n\t\t\t\tif (dy[i] != 0 && ly3 + dy[i] >= 0 && ly3 + dy[i] < H && vsl[ly3 + dy[i]][lx3 + dx[i]] != '#')ly3 += dy[i];\n\t\t\t\tif (dx[i] != 0 && rx3 - dx[i] >= 0 && rx3 - dx[i] < W && vsr[ry3 + dy[i]][rx3 - dx[i]] != '#')rx3 -= dx[i];\n\t\t\t\tif (dy[i] != 0 && ry3 + dy[i] >= 0 && ry3 + dy[i] < H && vsr[ry3 + dy[i]][rx3 - dx[i]] != '#')ry3 += dy[i];\n\t\t\t\tif (find(vi.begin(), vi.end(), lx3 * 1000000 + ly3 * 10000 + rx3 * 100 + ry3) == vi.end() && vvil[ly3][lx3] != 0 && vvir[ry3][rx3] != 0)vi.push_back(lx3 * 1000000 + ly3 * 10000 + rx3 * 100 + ry3);\n\t\t\t\tif (lx3 == glx&&ly3 == gly&&rx3 == grx&&ry3 == gry)clear = true;\n\t\t\t}\n\t\t\tif (clear)break;\n\t\t\tif (count + 1 == vi.size())break;\n\t\t\tint min = 10000;\n\t\t\tint i2 = 0;\n\n\t\t\tFOR(i, count + 1, vi.size()){\n\t\t\t\tif (vvil[(vi[i] / 10000 % 100)][(vi[i] / 1000000 % 100)] + vvir[(vi[i] % 100)][(vi[i] / 100 % 100)] < min){\n\t\t\t\t\tmin = vvil[(vi[i] / 10000 % 100)][(vi[i] / 1000000 % 100)] + vvir[(vi[i] % 100)][(vi[i] / 100 % 100)];\n\t\t\t\t\ti2 = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (vvil[ly2][lx2] + vvir[ry2][rx2] < min)break;\n\t\t\tswap(vi[count + 1], vi[i2]);\n\n\t\t\tcount++;\n\t\t}\n\n\t\tif (clear)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nchar fieldL[51][51];\nchar fieldR[51][51];\nbool checked[51][51][51][51];\n\nint w, h;\n\nbool dfs(int ly, int lx, int ry, int rx) {\n  if (fieldL[ly][lx] == fieldR[ry][rx] && fieldL[ly][lx] == '%') {\n    return true;\n  }\n  if (checked[ly][lx][ry][rx]) {\n    return false;\n  }\n  \n  checked[ly][lx][ry][rx] = true;\n\n  int dyL[] = { -1, 0, 1, 0 };\n  int dxL[] = { 0, 1, 0, -1 };\n  int dyR[] = { -1, 0, 1, 0 };\n  int dxR[] = { 0, -1, 0, 1 };\n\n\n  bool ret = false;\n  for (int i = 0; i < 4; i++) {\n    int nly = ly + dyL[i];\n    int nlx = lx + dxL[i];\n    int nry = ry + dyR[i];\n    int nrx = rx + dxR[i];\n    if (nly < 0) nly = 0;\n    if (nly >= h) nly = h - 1;\n    if (nlx < 0) nlx = 0;\n    if (nlx >= w) nlx = w - 1;\n    if (nry < 0) nry = 0;\n    if (nry >= h) nry = h - 1;\n    if (nrx < 0) nrx = 0;\n    if (nrx >= w) nrx = w - 1;\n    if (fieldL[nly][nlx] == '#') {\n      nly = ly; nlx = lx;\n    }\n    if (fieldR[nry][nrx] == '#') {\n      nry = ry; nrx = rx;\n    }\n    ret |= dfs(nly, nlx, nry, nrx);\n  }\n\n  return ret;\n}\n\nint main() {\n  while (true) {\n    cin >> w >> h;\n    if (w + h == 0) {\n      break;\n    }\n    int ly, lx, ry, rx;\n    for (int i = 0; i < h; i++) {\n      string strL, strR;\n      cin >> strL >> strR;\n      for (int j = 0; j < w; j++) {\n        fieldL[i][j] = strL[j];\n        fieldR[i][j] = strR[j];\n        if (strL[j] == 'L') {\n          ly = i; lx = j;\n        }\n        if (strR[j] == 'R') {\n          ry = i; rx = j;\n        }\n      }\n    }\n\n    memset(checked, false, sizeof(checked));\n\n    if (dfs(ly, lx, ry, rx)) {\n      cout << \"Yes\" << endl;\n    } else {\n      cout << \"No\" << endl;\n    }\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <utility>\n#include <cstring>\nusing namespace std;\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nint main() {\n  while(true) {\n    int W, H; cin >> W >> H;\n    if(W == 0 && H == 0) {\n      break;\n    }\n    char F[H][W+1], G[H][W+1];\n    REP(i,H) {\n      cin >> F[i] >> G[i];\n    }\n    PP start;\n    PP goal;\n    REP(i,H) {\n      REP(j,W) {\n        if(F[i][j] == 'L') start.first = P(i,j);\n        if(G[i][j] == 'R') start.second = P(i,j);\n        if(F[i][j] == '%') goal.first = P(i,j);\n        if(G[i][j] == '%') goal.second = P(i,j);\n      }\n    }\n    queue<PP> Q;\n    Q.push(start);\n    bool vis[H][W][H][W];\n    memset(vis, 0, sizeof(vis));\n    vis[start.first.first][start.first.second][start.second.first][start.second.second] = true;\n    while(!Q.empty()) {\n      PP p = Q.front(); Q.pop();\n      if(p == goal) break;\n      for(int i = 0; i < 4; ++i) {\n        const int dx[4] = { 1, 0, -1, 0 };\n        const int dy[4] = { 0, -1, 0, 1 };\n        int ly = p.first.first + dy[i];\n        int lx = p.first.second + dx[i];\n        int ry = p.second.first + dy[i];\n        int rx = p.second.second - dx[i];\n        if(ly < 0 || ly >= H || lx < 0 || lx >= W) {\n          ly = p.first.first;\n          lx = p.first.second;\n        }\n        if(F[ly][lx] == '#') {\n          ly = p.first.first;\n          lx = p.first.second;\n        }\n        if(ry < 0 || ry >= H || rx < 0 || rx >= W) {\n          ry = p.second.first;\n          rx = p.second.second;\n        }\n        if(G[ly][lx] == '#') {\n          ry = p.second.first;\n          rx = p.second.second;\n        }\n        if(!vis[ly][lx][ry][rx]) {\n          vis[ly][lx][ry][rx] = true;\n          Q.push(PP(P(ly,lx),P(ry,rx)));\n        }\n      }\n    }\n    if(vis[goal.first.first][goal.first.second][goal.second.first][goal.second.second]) {\n      cout << \"Yes\" << endl;\n    }\n    else {\n      cout << \"No\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long double EPS = 1e-10;\nconst long long INF = 1e18;\nconst long double PI = acos(-1.0L);\nint H, W;\nbool dp[50][150][50][150];\nstring field[50];\nint dh[2][4];\nint dw[2][4];\nint sh[2];\nint sw[2];\nint newh[2], neww[2];\nvoid solve() {\n    sh[0] = -1;\n    sw[0] = -1;\n    W = 2 * W + 1;\n    for(int h = 0; h < H; h++) {\n        cin >> field[h];\n        string s;\n        cin >> s;\n        field[h] = field[h] + \"#\" + s;\n    }\n    for(int h1 = 0; h1 < H; h1++) {\n        for(int w1 = 0; w1 < W; w1++) {\n            if(field[h1][w1] == 'L') {\n                sh[0] = h1;\n                sw[0] = w1;\n            }\n            if(field[h1][w1] == 'R') {\n                sh[1] = h1;\n                sw[1] = w1;\n            }\n            for(int h2 = 0; h2 < H; h2++) {\n                for(int w2 = 0; w2 < W; w2++) {\n                    dp[h1][w1][h2][w2] = false;\n                }\n            }\n        }\n    }\n    queue<vector<i_i>> que;\n    que.push({{sh[0], sw[0]}, {sh[1], sw[1]}});\n    string ans = \"No\";\n    while(!que.empty()) {\n        auto tmp = que.front();\n        que.pop();\n        //cerr << tmp[0].first << \" \" << tmp[0].second << \" \" << tmp[1].first << \" \" << \" \" << tmp[1].second << endl;\n        for(int k = 0; k < 4; k++) {\n            newh[0] = tmp[0].first + dh[0][k];\n            newh[1] = tmp[1].first + dh[1][k];\n            neww[0] = tmp[0].second + dw[0][k];\n            neww[1] = tmp[1].second + dw[1][k];\n            for(int j = 0; j < 2; j++) {\n                if(newh[j] < 0 or newh[j] >= H or field[newh[j]][neww[j]] == '#') {\n                    newh[j] -= dh[j][k];\n                }\n                if(neww[j] < 0 or neww[j] >= W or field[newh[j]][neww[j]] == '#') {\n                    neww[j] -= dw[j][k];\n                }\n            }\n            //cerr << newh[0] << \" \" << neww[0] << \" \" << newh[1] << \" \" << neww[1] << endl;\n            if(dp[newh[0]][neww[0]][newh[1]][neww[1]]) continue;\n            char grid[2];\n            for(int k = 0; k < 2; k++) {\n                grid[k] = field[newh[k]][neww[k]];\n            }\n            //cerr << grid[0] << \" \" << grid[1] << endl;\n            if(grid[0] == '%' and grid[1] == '%') ans = \"Yes\";\n            if(grid[0] == '%' or grid[1] == '%') continue;\n            dp[newh[0]][neww[0]][newh[1]][neww[1]] = true;\n            que.push({{newh[0], neww[0]}, {newh[1], neww[1]}});\n        }\n    }\n    cout << ans << endl;\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    dh[0][0] = 1;\n    dh[0][1] = -1;\n    dh[1][0] = 1;\n    dh[1][1] = -1;\n    dw[0][2] = 1;\n    dw[0][3] = -1;\n    dw[1][2] = -1;\n    dw[1][3] = 1;\n    while(cin >> W >> H) {\n        if(H == 0) break;\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nusing ll=long long;\nusing vi=vector<int>;\nusing vl=vector<long long>;\nusing pii=pair<int,int>;\nusing pll=pair<long long,long long>;\n#define ITR(i,c) for(auto i=begin(c);i!=end(c);++i)\n#define FORE(x,c) for(auto &x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define REPW(i,n) for(i=0;i<(int)(n);++i)\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)   // c++14\n#define SZ(c) ((int)c.size())\n#define EXIST(c,x) (c.find(x)!=end(c))\n#define OUTOFRANGE(y,x,h,w) (y<0||x<0||y>=h||x>=w)\n#define dump(...)\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\n#define INF (1001001001)\n#define INFLL (1001001001001001001ll)\ntemplate<class T> ostream& operator << (ostream &os,const vector<T> &v) {\n    ITR(i,v) os << *i << (i==end(v)-1 ? \"\" : \" \"); return os; }\ntemplate<class T> istream& operator >> (istream &is,vector<T> &v) {\n    ITR(i,v) is >> * i; return is; }\ntemplate<class T> istream& operator >> (istream &is, pair<T,T> &p) {\n        is >> p.first >> p.second; return is; }\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return 1;}return 0;}\n//------------------------------------------------------------------------------\nstruct before_main_function {\n    before_main_function() {\n        #ifdef int\n            #undef INF\n            #define INF INFLL\n            #define stoi stoll\n        #endif\n        cin.tie(0);ios::sync_with_stdio(false);\n        cout<<setprecision(15)<<fixed;\n    }\n} before_main_function;\n//------------------------------------------------------------------------------\n\nint W,H,asx,asy,bsx,bsy,agx,agy,bgx,bgy;\nbool dp[50][50][50][50];\nchar a[50][50],b[50][50];\nvoid solve() {\n    REP(i,50) REP(j,50) REP(k,50) REP(l,50) dp[i][j][k][l]=false;\n\n    REP(i,H) {\n        REP(j,W) cin>>a[i][j];\n        REP(j,W) cin>>b[i][W-j-1];\n        REP(j,W) {\n            if(a[i][j]=='L') asy=i,asx=j;\n            if(b[i][j]=='R') bsy=i,bsx=j;\n            if(a[i][j]=='%') agy=i,agx=j;\n            if(b[i][j]=='%') bgy=i,bgx=j;\n        }\n    }\n\n    queue<pair<pii,pii>> q;\n    q.push({{asy,asx},{bsy,bsx}});\n    dp[asy][asx][bsy][bsx]=true;\n    while(!q.empty()) {\n        int y1=q.front().first.first;\n        int x1=q.front().first.second;\n        int y2=q.front().second.first;\n        int x2=q.front().second.second;\n        q.pop();\n\n        if(y1==agy && x1==agx && y2==bgy && x2==bgx) {\n            cout<<\"Yes\"<<endl;\n            return;\n        }\n\n        REP(d,4) {\n            int ny1=y1+DY[d];\n            int nx1=x1+DX[d];\n            int ny2=y2+DY[d];\n            int nx2=x2+DX[d];\n            if(OUTOFRANGE(ny1,nx1,H,W) || a[ny1][nx1]=='#') {\n                ny1=y1;\n                nx1=x1;\n            }\n            if(OUTOFRANGE(ny2,nx2,H,W) || b[ny2][nx2]=='#') {\n                ny2=y2;\n                nx2=x2;\n            }\n            if(dp[ny1][nx1][ny2][nx2]) continue;\n            if((ny1==agy && nx1==agx) && !(ny2==bgy && nx2==bgx)) continue;\n            if(!(ny1==agy && nx1==agx) && (ny2==bgy && nx2==bgx)) continue;\n            dp[ny1][nx1][ny2][nx2]=true;\n            q.push({{ny1,nx1},{ny2,nx2}});\n        }\n    }\n    cout<<\"No\"<<endl;\n}\nsigned main() {\n    while(1!=2) {\n        cin>>W>>H;\n        if(W+H==0) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint ans;\nint h,w;\nstring ma1[55];\nstring ma2[55];\nint dp[55][55][55][55];\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\n\nvoid dfs(int lx,int ly,int rx,int ry){\n  if(ans)return;\n  //cout<<lx<<\" \"<<ly<<\" \"<<rx<<\" \"<<ry<<endl;\n  if(dp[lx][ly][rx][ry])return;\n  if(ma1[lx][ly]=='%'&&ma2[rx][ry]=='%'){\n    ans=1;\n    return;\n  }\n  dp[lx][ly][rx][ry]=1;\n  for(int i=0;i<4;i++){\n    int nlx=lx+dx[i];\n    int nly=ly+dy[i];\n    int nrx=rx+dx[i];\n    int nry=ry-dy[i];\n    if(nlx==h||nlx<0)nlx=lx;\n    if(nly==w||nly<0)nly=ly;\n    if(ma1[nlx][nly]=='#')nlx=lx,nly=ly;\n    if(nrx==h||nrx<0)nrx=rx;\n    if(nry==w||nry<0)nry=ry;\n    if(ma2[nrx][nry]=='#')nrx=rx,nry=ry;\n    dfs(nlx,nly,nrx,nry);\n  }\n  return;\n}\n\nint main(){\n  while(cin>>w>>h,w+h){\n    ans=0;\n    memset(dp,0,sizeof(dp));\n    int sl[2],sr[2];\n    for(int i=0;i<h;i++){\n      cin>>ma1[i]>>ma2[i];\n      for(int j=0;j<w;j++){\n\tif(ma1[i][j]=='L')sl[0]=i,sl[1]=j;\n\tif(ma2[i][j]=='R')sr[0]=i,sr[1]=j;\n      }\n    }\n    dfs(sl[0],sl[1],sr[0],sr[1]);\n    if(ans)cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,s,n) for(int i=s; i<n; i++)\n#define ALL(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nint w, h;\nint rooml[60][60], roomr[60][60];\nbool memo[60][60][60][60];\n\nbool dfs(int xl, int yl, int xr, int yr) {\n\tif( xl<=0 || w+1<=xl || yl<=0 || h+1<=yl || \n\t\txr<=0 || w+1<=xr || yr<=0 || h+1<=yr ) {\n\t\treturn false;\n\t}\n\n\tif( memo[xl][yl][xr][yr] ) {\n\t\treturn false;\n\t}\n\tmemo[xl][yl][xr][yr] = true;\n\tconst int dx[4] = {-1, 0, 1, 0};\n\tconst int dy[4] = {0, 1, 0, -1};\n\tbool f = false;\n\trep(i, 4) {\n\t\tint nxl = xl + dx[i];\n\t\tint nyl = yl + dy[i];\n\t\tint nxr = xr - dx[i];\n\t\tint nyr = yr + dy[i];\n\t\tint nl = rooml[nyl][nxl];\n\t\tint nr = roomr[nyr][nxr];\n\t\tif( nl==2 && nr==2 ) {\n\t\t\tf = true;\n\t\t}\n\t\telse if( nl==1 && nr==1 ) {\n\t\t\tf |= dfs(nxl, nyl, nxr, nyr);\n\t\t}\n\t\telse if( nl==1 && nr==0 ) {\n\t\t\tf |= dfs(nxl, nyl, xr, yr);\n\t\t}\n\t\telse if( nl==0 && nr==1 ) {\n\t\t\tf |= dfs(xl, yl, nxr, nyr);\n\t\t}\n\t}\n\treturn f;\n}\n\nint main() {\n\twhile(cin >> w >> h, w) {\n\t\tcout << \"start init\" << endl;\n\t\tmemset(rooml, 0, sizeof(rooml));\n\t\tmemset(roomr, 0, sizeof(roomr));\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tcout << \"start input\" << endl;\n\t\tint xl=1, yl=1, xr=1, yr=1;\n\t\trep(y, h) {\n\t\t\tstring sl, sr;\n\t\t\tcin >> sl >> sr;\n\t\t\trep(x, w) {\n\t\t\t\tif(sl[x] == 'L') {\n\t\t\t\t\txl = x+1;\n\t\t\t\t\tyl = y+1;\n\t\t\t\t\trooml[y+1][x+1] = 1;\n\t\t\t\t} else {\n\t\t\t\t\trooml[y+1][x+1] = (sl[x]=='%' ? 2 : (sl[x]=='.' ? 1 : 0));\n\t\t\t\t}\n\t\t\t\tif(sr[x] == 'R') {\n\t\t\t\t\txr = x+1;\n\t\t\t\t\tyr = y+1;\n\t\t\t\t\troomr[y+1][x+1] = 1;\n\t\t\t\t} else {\n\t\t\t\t\troomr[y+1][x+1] = (sr[x]=='%' ? 2 : (sr[x]=='.' ? 1 : 0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << \"start dfs\" << endl;\n\t\tif( dfs(xl, yl, xr, yr) ) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t} else {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <string.h>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <set>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\n#define For(i,a,n)\tfor(int i = a;i < n;i++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(n)\t\tmemset(n,0,sizeof n)\n#define all(n)\t\t(n).begin(),(n).end()\n\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\ntypedef pair<P, P> WP;\ntypedef long long ll;\n\nconst ll INF = 1e9;\nint dx[4] = { 0, 1, 0, -1 }, dy[4] = { 1, 0, -1, 0 };\nbool cheak(int x, int y, int mx, int my){\n\treturn x >= 0 && y >= 0 && x < mx &&  y < my;\n}\n\nstring s[2][51];\n\nint d[51][51][51][51];\n\nint main()\n{\n\tint w, h;\n\n\twhile (cin >> w >> h && w){\n\t\tclr(d);\n\t\tint sx[2], sy[2];\n\t\tint gx[2], gy[2];\n\t\trep(y, h){\n\t\t\tcin >> s[0][y] >> s[1][y];\n\t\t\trep(x, w){\n\t\t\t\tif (s[0][y][x] == '%')gx[0] = x, gy[0] = y;\n\t\t\t\tif (s[1][y][x] == '%')gx[1] = x, gy[1] = y;\n\t\t\t\tif (s[0][y][x] == 'L')sx[0] = x, sy[0] = y;\n\t\t\t\tif (s[1][y][x] == 'R')sx[1] = x, sy[1] = y;\n\t\t\t}\n\t\t}\n\t\td[sy[0]][sx[0]][sy[1]][sx[1]] = 1;\n\n\t\tqueue<P> q0, q1;\n\t\tq0.push(P(sy[0], sx[0]));\n\t\tq1.push(P(sy[1], sx[1]));\n\n\t\twhile (q0.size()){\n\t\t\tint ly = q0.front().first, lx = q0.front().second;\n\t\t\tint ry = q1.front().first, rx = q1.front().second;\n\t\t\tq0.pop(), q1.pop();\n\n\t\t\trep(i, 4){\n\t\t\t\tint nlx = lx + dx[i], nly = ly + dy[i];\n\t\t\t\tint nrx = rx - dx[i], nry = ry + dy[i];\n\n\t\t\t\tbool lf = (cheak(nlx, nly, w, h) && s[0][nly][nlx] != '#');\n\t\t\t\tbool rf = (cheak(nrx, nry, w, h) && s[1][nry][nrx] != '#');\n\n\t\t\t\tif ((rf || lf)){\n\t\t\t\t\tif (!lf)nlx = lx, nly = ly;\n\t\t\t\t\tif (!rf)nrx = rx, nry = ry;\n\t\t\t\t\tif (!d[nly][nlx][nry][nrx]){\n\n\t\t\t\t\t\td[nly][nlx][nry][nrx] = 1;\n\t\t\t\t\t\tq0.push(P(nly, nlx));\n\t\t\t\t\t\tq1.push(P(nry, nrx));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[gy[0]][gx[0]][gy[1]][gx[1]])cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2153&lang=jp\ntypedef long long ll;\ntypedef vector<vector<char>> vvc;\ntypedef vector<char> vc;\ntypedef vector<vector<int>> vvi;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nint dlx[4] = {1, 0, -1, 0};\nint dly[4] = { 0,1,0,-1 };\nint drx[4] = { 1,0,-1,0 };\nint dry[4] = { 0,-1,0,1 };\n\nint W, H;\nbool dfs(pii l,pii r,vvi Lf,vvi Rf,vvc& L,vvc& R){\n\tLf[l.first][l.second] = 1;\n\tRf[r.first][r.second] = 1;\n\n\tfor (int i = 0; i < 4;i++) {\n\t\tint lx = l.first + dlx[i], ly = l.second + dly[i];\n\t\tint rx = r.first + drx[i], ry = r.second + dry[i];\n\t\tif (Lf[lx][ly] == 1 && Rf[rx][ry] == 1) continue;\n\t\tif (L[lx][ly] == '%' && R[rx][ry] == '%') return true;\n\t\tif (L[lx][ly] == '.' && R[rx][ry] == '.') {\n\t\t\tif (dfs({ lx,ly }, { rx,ry }, Lf, Rf, L, R)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\twhile (cin >> W >> H) {\n\t\tvvc L(H + 2, vc(W + 2, '#'));\n\t\tvvc R(H + 2, vc(W + 2, '#'));\n\t\tvvi Lf(H + 2, vi(W + 2, 0));\n\t\tvvi Rf(H + 2, vi(W + 2, 0));\n\t\tpii ls, rs;\n\t\tfor (int i = 1; i <= H;i++) {\n\t\t\tfor (int j = 1;j <= W;j++) {\n\t\t\t\tcin >> L[i][j];\n\t\t\t\tif (L[i][j] == 'L') ls = { i,j };\n\t\t\t}\n\t\t\tfor (int j = 1;j <= W;j++) {\n\t\t\t\tcin >> R[i][j];\n\t\t\t\tif (R[i][j] == 'R') rs = { i,j };\n\t\t\t}\n\t\t}\n\n\t\tif (dfs(ls, rs, Lf, Rf, L, R)) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t\telse cout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\n\n\nint W,H;\nstring roomL[55],roomR[55];\n\nbool range_check(int y,int x) {\n    if(!(0<=y&&y<H)) return false;\n    if(!(0<=x&&x<W)) return false;\n\n    return true;\n}\n\nbool visited[55][55][55][55];\nbool ok(P len,P rin) {\n    memset(visited,0,sizeof(visited));\n    visited[len.fr][len.sc][rin.fr][rin.sc]=true;\n    queue<PP> que;\n    que.push(PP(len,rin));\n\n    while(que.size()) {\n        PP pp=que.front(); que.pop();\n        P next_len=pp.fr;\n        P next_rin=pp.sc;\n\n        //printf(\"[debug] %d %d %d %d\\n\",next_len.fr,next_len.sc,next_rin.fr,next_rin.sc);\n\n        if(roomL[next_len.fr][next_len.sc]=='%' && roomR[next_rin.fr][next_rin.sc]=='%') {\n            return true;\n        }\n        if(roomL[next_len.fr][next_len.sc]=='%' || roomR[next_rin.fr][next_rin.sc]=='%') {\n            //visited[next_len.fr][next_len.sc][next_rin.fr][next_rin.sc]=false;\n            continue;\n        }\n        rep(i,4) {\n            next_len=pp.fr;\n            next_rin=pp.sc;\n\n            if(range_check(next_len.fr+dy[i],next_len.sc+dx[i]) && roomL[next_len.fr+dy[i]][next_len.sc+dx[i]]!='#') {\n                next_len.fr+=dy[i];\n                next_len.sc+=dx[i];\n            }\n            if(range_check(next_rin.fr+dy[i],next_rin.sc-dx[i]) && roomR[next_rin.fr+dy[i]][next_rin.sc-dx[i]]!='#') {\n                next_rin.fr+=dy[i];\n                next_rin.sc-=dx[i];\n            }\n\n            if(!visited[next_len.fr][next_len.sc][next_rin.fr][next_len.sc]) {\n                visited[next_len.fr][next_len.sc][next_rin.fr][next_len.sc]=true;\n                que.push(PP(next_len,next_rin));\n            }\n        }\n    }\n\n    return false;\n}\n\nvoid solve() {\n    rep(y,55) roomL[y]=roomR[y]=string('#',55);\n    rep(y,H) cin>>roomL[y]>>roomR[y];\n    P len,rin;\n    rep(y,H) rep(x,W) {\n        if(roomL[y][x]=='L') len=P(y,x);\n        if(roomR[y][x]=='R') rin=P(y,x);\n    }\n    if(ok(len,rin)) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n}\n\nint main() {\n    while(cin>>W>>H) {\n        if(!W) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={1,0,-1,0,-1,0,1,0};\nconst int dy[]={0,1,0,-1,0,1,0,-1};\nconst int INF = 1<<30;\nconst double EPS = 1e-8;\n#define PB push_back\n#define mk make_pair\n#define fr first\n#define sc second\n#define reps(i,j,k) for(int i = (j); i < (k); ++i)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\n#define lengthof(x) (sizeof(x) / sizeof(*(x)))\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> Pii;\ntypedef pair<int,vi > P;\ntypedef long long ll;\nbool memo[52][52][52][52];\nchar stageL[52][52];\nchar stageR[52][52];\nstruct data{\n    Pii l;\n    Pii r;\n    data(){}\n    data(Pii _l ,Pii _r){\n        l = _l;\n        r = _r;\n    }\n};\nint W,H;\n\nbool canMove(int y,int x,char type){\n    bool f = false;\n    if(type == 'L'){\n        f = stageL[y][x] != '#';\n    }\n    else if(type == 'R'){\n        f = stageR[y][x] != '#';\n    }\n    return f & (y >= 0 && y < H && x >= 0 && x < W);\n}\n\nint main(){\n    \n    while(scanf(\"%d%d\",&W,&H),W){\n        memset(memo,0,sizeof(memo));\n        memset(stageL,0,sizeof(stageL));\n        memset(stageR,0,sizeof(stageR));\n        Pii Lstart,Rstart;\n        Pii Lgoal,Rgoal;\n        rep(i,H){\n            scanf(\"%s\",stageL[i]);\n            scanf(\"%s\",stageR[i]);\n            rep(j,W){\n                if(stageL[i][j] == 'L'){\n                    Lstart = Pii(i,j);\n                }\n                if(stageL[i][j] == '%'){\n                    Lgoal = Pii(i,j);\n                }\n                if(stageR[i][j] == 'R'){\n                    Rstart = Pii(i,j);\n                }\n                if(stageR[i][j] == '%'){\n                    Rgoal = Pii(i,j);\n                }\n            }\n        }\n\n        queue < data > Q;\n        Q.push(data(Lstart,Rstart));\n\n        int ans = 0;\n\n        while( !Q.empty() ){\n            data e = Q.front();Q.pop();\n            if(memo[e.l.fr][e.l.sc][e.r.fr][e.r.sc])continue;\n            memo[e.l.fr][e.l.sc][e.r.fr][e.r.sc] = true;\n\n            if(Lgoal == e.l && Rgoal == e.r){\n                ans = 1;\n                break;\n            }\n\n            rep(i,4){\n                int nLy = e.l.fr + dy[i];\n                int nLx = e.l.sc + dx[i];\n                int nRy = e.r.fr + dy[i+4];\n                int nRx = e.r.sc + dx[i+4];\n\n                if(canMove(nLy,nLx,'L') && canMove(nRy,nRx,'R')){\n                    Q.push(data(Pii(nLy,nLx),Pii(nRy,nRx)));\n                }\n                else if(!canMove(nLy,nLx,'L') && canMove(nRy,nRx,'R')){\n                    Q.push(data(e.l,Pii(nRy,nRx)));\n                }\n                else if(canMove(nLy,nLx,'L') && !canMove(nRy,nRx,'R')){\n                    Q.push(data(Pii(nLy,nLx),e.r));\n                }\n\n            }\n\n        }\n\n        ans ? puts(\"Yes\") : puts(\"No\");\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint lsx, lsy, ltx, lty, rsx, rsy, rtx, rty;\nbool dfs(vector<vector<vvi>> &dp, int lx, int ly, int rx, int ry) {\n\tif (dp[ly][lx][ry][rx] != -1)return dp[ly][lx][ry][rx];\n\treturn true;\n}\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint w, h;\n\twhile (cin >> w >> h, w) {\n\t\tvector<string> l(h), r(h);\n\t\tREP(i, h) cin >> l[i] >> r[i];\n\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tif (l[i][j] == '%') {\n\t\t\t\t\tltx = j; lty = i;\n\t\t\t\t}\n\t\t\t\tif (l[i][j] == 'L') {\n\t\t\t\t\tlsx = j; lsy = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tif (r[i][j] == '%') {\n\t\t\t\t\trtx = j; rty = i;\n\t\t\t\t}\n\t\t\t\tif (r[i][j] == 'R') {\n\t\t\t\t\trsx = j; rsy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<vector<vvi>> dp(h, vector<vvi>(w, vvi(h, vi(w, -1))));\n\t\tqueue<pair<pii, pii>> q;\n\t\tvector<vector<vvi>> b(h, vector<vvi>(w, vvi(h, vi(w, 0))));\n\t\tq.push(pair<pii, pii>(pii(lsx, lsy), pii(rsx, rsy)));\n\t\tb[lsy][lsx][rsy][rsx] = 1;\n\t\twhile (!q.empty()) {\n\t\t\tauto a = q.front(); q.pop();\n\t\t\tint lx = a.first.first, ly = a.first.second, rx = a.second.first, ry = a.second.second;\n\t\t\tif (lx == ltx&&ly == lty) {\n\t\t\t\tif (rx == rtx&&ry == rty) {\n\t\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\t\tgoto a;\n\t\t\t\t}\n\t\t\t\telse continue;\n\t\t\t}\n\n\t\t\tREP(i, 4) {\n\t\t\t\tint lnx = lx + dx[i * 2], lny = ly + dy[i * 2], rnx = rx + dx[(i + 2 * (i % 2 == 0)) * 2 % 8], rny = ry + dy[(i + 2 * (i % 2 == 0)) * 2 % 8];\n\t\t\t\tif (lnx < 0 || lnx >= w || lny < 0 || lny >= h ){ \n\t\t\t\t\tlny = ly; lnx = lx;\n\t\t\t\t}\n\t\t\t\telse if (l[lny][lnx] == '#') {\n\t\t\t\t\tlny = ly; lnx = lx;\n\t\t\t\t}\n\t\t\t\tif (rnx < 0 || rnx >= w || rny < 0 || rny >= h ) {\n\t\t\t\t\trny = ry; rnx = rx;\n\t\t\t\t}\n\t\t\t\telse if (r[rny][rnx] == '#') {\n\t\t\t\t\trny = ry; rnx = rx;\n\t\t\t\t}\n\t\t\t\tif ((lnx!=lx||lny!=ly||rnx!=rx||rny!=ry)&& b[lny][lnx][rny][rnx]!=1) {\n\t\t\t\t\n\t\t\t\t\tq.push(pair<pii, pii>(pii(lnx, lny), pii(rnx, rny)));\n\t\t\t\t\tb[lny][lnx][rny][rnx] = 1;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << \"No\" << endl;\n\n\ta:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<tuple>\n#include<string>\nusing namespace std;\n\n#define MAX_N 60\n#define INF 1<<30\n\nint dist[MAX_N][MAX_N][MAX_N][MAX_N];\nint dy1[4] = { 0,1,0,-1 };\nint dy2[4] = { 0,1,0,-1 };\nint dx1[4] = { 1,0,-1,0 };\nint dx2[4] = { -1,0,1,0 };\nint H, W, map1[MAX_N][MAX_N], map2[MAX_N][MAX_N];\nint Lsy, Lsx, Lgy, Lgx;\nint Rsy, Rsx, Rgy, Rgx;\nstring S, T;\nqueue<tuple<int, int, int, int>>Q;\n\nvoid _memset() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tfor (int k = 0; k < MAX_N; k++) {\n\t\t\t\tfor (int l = 0; l < MAX_N; l++) {\n\t\t\t\t\tdist[i][j][k][l] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tmap1[i][j] = 1;\n\t\t\tmap2[i][j] = 1;\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\t_memset();\n\t\tcin >> W >> H;\n\t\tif (H == 0 && W == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tcin >> S >> T;\n\t\t\tfor (int j = 0; j < S.size(); j++) {\n\t\t\t\tif (S[j] == '%') {\n\t\t\t\t\tLsx = j + 1; Lsy = i;\n\t\t\t\t\tmap1[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\tif (S[j] == '#') {\n\t\t\t\t\tmap1[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (S[j] == '.') {\n\t\t\t\t\tmap1[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (S[j] == 'L') {\n\t\t\t\t\tLgy = i; Lgx = j + 1;\n\t\t\t\t\tmap1[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < T.size(); j++) {\n\t\t\t\tif (T[j] == '%') {\n\t\t\t\t\tRsx = j + 1; Rsy = i;\n\t\t\t\t\tmap2[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\tif (T[j] == '#') {\n\t\t\t\t\tmap2[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (T[j] == '.') {\n\t\t\t\t\tmap2[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (T[j] == 'R') {\n\t\t\t\t\tRgy = i; Rgx = j + 1;\n\t\t\t\t\tmap2[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQ.push(make_tuple(Lsy, Lsx, Rsy, Rsx));\n\t\tdist[Lsy][Lsx][Rsy][Rsx] = 0;\n\n\t\twhile (!Q.empty()) {\n\t\t\ttuple<int, int, int, int>tup = Q.front(); Q.pop();\n\t\t\tint ay = get<0>(tup);\n\t\t\tint ax = get<1>(tup);\n\t\t\tint by = get<2>(tup);\n\t\t\tint bx = get<3>(tup);\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint ey = ay + dy1[i], ex = ax + dx1[i];\n\t\t\t\tint fy = by + dy2[i], fx = bx + dx2[i];\n\t\t\t\tif (map1[ey][ex] == 1) {\n\t\t\t\t\tey = ay; ex = ax;\n\t\t\t\t}\n\t\t\t\tif (map2[fy][fx] == 1) {\n\t\t\t\t\tfy = by; fx = bx;\n\t\t\t\t}\n\t\t\t\tif (dist[ey][ex][fy][fx] == INF) {\n\t\t\t\t\tdist[ey][ex][fy][fx] = 0;\n\t\t\t\t\tQ.push(make_tuple(ey, ex, fy, fx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[Lgy][Lgx][Rgy][Rgx] == INF) {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\nusing namespace std;\nstring s1[50],s2[50];\nint dx1[]={1,-1,0,0,},dy1[]={0,0,1,-1};\nint dx2[]={-1,1,0,0,},dy2[]={0,0,1,-1};\nint w,h,gx1,gx2,gy1,gy2;\nunordered_set<int>s;\nbool bfs(int x1,int y1,int x2,int y2){\n  queue<int>q;\n  q.push(x1+y1*100+x2*10000+y2*1000000);\n  while(!q.empty()){\n    int p=q.front();q.pop();\n    x1=p%100;y1=p%10000/100;\n    x2=p%1000000/10000;y2=p/1000000;\n    if(x1==gx1&&y1==gy1&&(x2!=gx2||y2!=gy2))continue;\n    if((x1!=gx1||y1!=gy1)&&x2==gx2&&y2==gy2)continue;\n    if(x1==gx1&&y1==gy1&&x2==gx2&&y2==gy2){\n      while(!q.empty())q.pop();\n      return 1;\n    }\n    for(int i=0;i<4;i++){\n      int x3=x1+dx1[i],y3=y1+dy1[i];\n      int x4=x2+dx2[i],y4=y2+dy2[i];\n      if(x3>=0&&x4>=0&&y3>=0&&y4>=0)\n        if(x3<w&&x4<w&&y3<h&&y4<h){\n          if(s1[y3][x3]=='#')y3=y1,x3=x1;\n          if(s2[y4][x4]=='#')y4=y2,x4=x2;\n          if(!s.count(x3+y3*100+x4*10000+y4*1000000)){\n            s.insert(x3+y3*100+x4*10000+y4*1000000);\n            q.push(x3+y3*100+x4*10000+y4*1000000);\n          }\n        }\n      }\n    }\n    return 0;\n}\nint main(){\n  int x1,y1,x2,y2;\n  while(cin>>w>>h,w){\n    s.clear();\n    r(i,h)cin>>s1[i]>>s2[i];\n    r(i,h)r(j,w){\n      if(s1[i][j]=='L')x1=j,y1=i;\n      if(s2[i][j]=='R')x2=j,y2=i;\n      if(s1[i][j]=='%')gx1=j,gy1=i;\n      if(s2[i][j]=='%')gx2=j,gy2=i;\n    }\n    s.insert(x1+y1*100+x2*10000+y2*1000000);\n    if(bfs(x1,y1,x2,y2))cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<tuple>\n#include<queue>\n\nusing namespace std;\ntypedef long long ll;\n\nint H, W;\nint filedL[50][50];\nint filedR[50][50];\nbool used[50][50][50][50];\ntuple<int, int> Lstart, Rstart;\n\nint vx1[4] = { 0,1,0,-1 }, vx2[4] = { 0,1,0,-1 };\nint vy1[4] = { 1,0,-1,0 }, vy2[4] = { -1,0,1,0 };\n\nint main() {\n\twhile (1) {\n\t\tcin >> W >> H;\n\n\t\tif (W == 0 && H == 0)break;\n\n\t\tfor (int i = 0; i < H; i++)for (int j = 0; j < W; j++)\n\t\t\tfor (int k = 0; k < H; k++)for (int l = 0; l < W; l++)used[i][j][k][l] = false;\n\n\t\tfor (int i = 0; i < H; i++)for (int j = 0; j < W; j++)filedL[i][j] = 0, filedR[i][j] = 0;\n\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < 2 * W; j++) {\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tif (j < W) {\n\t\t\t\t\tif (c == '.')filedL[i][j] = 0;\n\t\t\t\t\telse if (c == '#')filedL[i][j] = 1;\n\t\t\t\t\telse if (c == '%')filedL[i][j] = 2;\n\t\t\t\t\telse if (c == 'L')get<0>(Lstart) = i, get<1>(Lstart) = j;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t\n\t\t\t\t\tif (c == '.')filedR[i][j - W] = 0;\n\t\t\t\t\telse if (c == '#')filedR[i][j - W] = 1;\n\t\t\t\t\telse if (c == '%')filedR[i][j - W] = 2;\n\t\t\t\t\telse if (c == 'R')get<0>(Rstart) = i, get<1>(Rstart) = j - W;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//bfsを行う\n\t\tqueue <tuple<int, int, int, int>> qu;\n\t\t//最初の座標を挿入\n\t\tqu.push(make_tuple(get<0>(Lstart), get<1>(Lstart), get<0>(Rstart), get<1>(Rstart)));\n\t\tused[get<0>(Lstart)][get<1>(Lstart)][get<0>(Rstart)][get<1>(Rstart)] = true;\n\n\t\twhile (qu.size()) {\n\t\t\tauto pos = qu.front(); qu.pop();\n\t\t\tint X1 = get<0>(pos), Y1 = get<1>(pos), X2 = get<2>(pos), Y2 = get<3>(pos);\n\n\t\t\t//cout << X1 << \" \" << Y1 << \" \" << X2 << \" \" << Y2 << endl;\n\n\t\t\t//同時にゴールできてるかどうか\n\t\t\tif (filedL[X1][Y1] == 2 && filedR[X2][Y2] == 2) {\n\t\t\t\t//ゴールに到達\n\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\tgoto nextroop;\n\t\t\t}\n\n\t\t\t//四方向へと探索を進める\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint NX1 = X1 + vx1[i], NY1 = Y1 + vy1[i], NX2 = X2 + vx2[i], NY2 = Y2 + vy2[i];\n\n\t\t\t\t//範囲外オーバーあるかどうかを判断\n\t\t\t\tif (NX1 < 0)NX1 = 0;\n\t\t\t\tif (NX1 >= H)NX1 = H - 1;\n\t\t\t\tif (NY1 < 0)NY1 = 0;\n\t\t\t\tif (NY1 >= W)NY1 = W - 1;\n\t\t\t\tif (NX2 < 0)NX2 = 0;\n\t\t\t\tif (NX2 >= H)NX2 = H - 1;\n\t\t\t\tif (NY2 < 0)NY2 = 0;\n\t\t\t\tif (NY2 >= W)NY2 = W - 1;\n\t\t\t\t//壁に当たってるかどうかを判断　これは上のと被らないはず\n\t\t\t\t//行先が壁ならば動かない\n\t\t\t\tif (filedL[NX1][NY1] == 1) {\n\t\t\t\t\tNX1 = X1, NY1 = Y1;\n\t\t\t\t}\n\t\t\t\tif (filedR[NX2][NY2] == 1) {\n\t\t\t\t\tNX2 = X2, NY2 = Y2;\n\t\t\t\t}\n\t\t\t\t//二人の行先がどちらもすでに探索済みの場所ならば行かない。これはそもそも動いてないパターンも弾くことができる\n\t\t\t\tif (used[NX1][NY1][NX2][NY2])continue;\n\t\t\t\t//片方でも先にゴールならばアウト\n\t\t\t\tif ((filedL[NX1][NY1] == 2 && filedR[NX2][NY2] != 2) ||\n\t\t\t\t\tfiledL[NX1][NY1] != 2 && filedR[NX2][NY2] == 2) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t//その行き先をまたキューに入れる。\n\n\t\t\t\tused[NX1][NY1][NX2][NY2] = true;\n\t\t\t\tqu.push(make_tuple(NX1, NY1, NX2, NY2));\n\n\t\t\t}\n\t\t}\n\n\t\tcout << \"No\" << endl;\n\n\tnextroop:;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<queue>\n#define MAX 50\nusing namespace std;\nstruct Point{int x,y;};\nstruct P{\n  Point l,r;\n  int cost;\n  bool operator<(const P &a)const{\n    return (l.x==a.l.x?\n\t    (l.y==a.l.y?\n\t     (r.x==a.r.x?\n\t      (r.y<a.r.y):r.x<a.r.x)\n\t     :l.y<a.l.y)\n\t    :l.x<a.l.x);\n  }\n};\nint main(){\n  int w,h;\n  while(cin>>w>>h,w||h){\n    int i,j,k;\n    int inf = 1<<20;\n    \n    bool d[MAX+1][MAX+1][MAX+1][MAX+1];\n    //fill(d[0][0][0],d[MAX][MAX][MAX],0);\n    \n    //map<P,int> m;\n    string sr[60],sl[60];\n    for(i=0;i<h;i++){\n      cin >> sl[i] >> sr[i];\n    }\n    \n    Point pr,pl,br,bl;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(sl[i][j]=='L'){\n\t  pl.x=j;pl.y=i;\n\t}\n\tif(sr[i][j]=='R'){\n\t  pr.x=j;pr.y=i;\n\t}\n      }\n    }\n    //cout << pl.x << \":\" << pl.y << endl;\n    //cout << pr.x << \":\" << pr.y << endl;\n    //d[pl.x][pl.y][pr.x][pr.y]=\n    P p,b;\n    p.r=pr;\n    p.l=pl;\n    p.cost=0;\n    //m[p]=p.cost;\n    queue<P> q;\n    q.push(p);\n    bool f = false;\n    while(!q.empty()){\n      p=q.front();q.pop();\n      pl=p.l;pr=p.r;\n      /*\n      if(m.find(p)!=m.end())\n\tif(p.cost>m[p]) continue;\n      m[p]=p.cost;\n      */\n      if(d[pl.x][pl.y][pr.x][pr.y]) continue;\n      d[pl.x][pl.y][pr.x][pr.y]=true;\n      \n      //cout << pl.x<<\":\"<<pl.y<<\":\"<<pr.x<<\":\"<<pr.y<<\"/\"<<p.cost<<endl;\n      if(sl[pl.y][pl.x]=='%'&&sr[pr.y][pr.x]=='%'){\n\tf=true;\n\tbreak;\n      }else if(sl[pl.y][pl.x]=='%') continue;\n      else if(sr[pr.y][pr.x]=='%') continue;\n      \n      p.cost++;\n      int lx[]={1,-1,0,0};int ly[]={0,0,1,-1};\n      int rx[]={-1,1,0,0};int ry[]={0,0,1,-1};\n      for(i=0;i<4;i++){\n\tbl=pl;br=pr;\n\tbl.x+=lx[i];bl.y+=ly[i];\n\tbr.x+=rx[i];br.y+=ry[i];\n\n\t//cout << bl.x<<\":\"<<bl.y<<\":\"<<br.x<<\":\"<<br.y<<\"/\"<<p.cost<<endl;\n\t\n\tif(bl.x<0) bl.x=0;\n\telse if(bl.x>=w) bl.x=w-1;\n\tif(bl.y<0) bl.y=0;\n\telse if(bl.y>=h) bl.y=h-1;\n\n\tif(br.x<0) br.x=0;\n\telse if(br.x>=w) br.x=w-1;\n\tif(br.y<0) br.y=0;\n\telse if(br.y>=h) br.y=h-1;\n\n\tif(sl[bl.y][bl.x]=='#'){\n\t  bl.x-=lx[i];bl.y-=ly[i];\n\t}\n\tif(sr[br.y][br.x]=='#'){\n\t  br.x-=rx[i];br.y-=ry[i];\n\t}\n\tp.r=br;p.l=bl;\n\tq.push(p);\n\t//m[p]=p.cost;\n      }\n    }\n    if(f) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <tuple>\n#include <queue>\n\nusing namespace std;\n\nusing lint = long long;\nusing ldouble = long double;\n\nconst int dx[4] = {-1, 0, 0, 1}, dy[4] = {0, -1, 1, 0};\n\nint H, W, rsx, rsy, rgx, rgy;\nvector<string> L, R;\nvector<vector<vector<vector<int>>>> dp;\n// -1 : 未探索\n// 0  : 到達不可\n// 1  : 到達可\n// 2  : 探索中\n\nbool dfs(int lx, int ly, int rx, int ry) {\n    auto& ret = dp[lx][ly][rx][ry];\n    if (ret >= 0) return ret == 1;\n\n    bool l = (L[lx][ly] == '%');\n    bool r = (R[rx][ry] == '%');\n    if (l && r) return (ret = 1) == 1;\n    if (l || r) return (ret = 0) == 1;\n\n    ret = 2;\n    for (int i = 0; i < 4; ++i) {\n        int lnx = lx + dx[i];\n        int lny = ly + dy[i];\n        if (lnx < 0 || H <= lnx || lny < 0 || W <= lny ||\n            L[lnx][lny] == '#') lnx = lx, lny = ly;\n\n        int rnx = rx + dx[i];\n        int rny = ry + dy[i];\n        if (rnx < 0 || H <= rnx || rny < 0 || W <= rny ||\n            R[rnx][rny] == '#') rnx = rx, rny = ry;\n\n        if (dfs(lnx, lny, rnx, rny)) return (ret = 1) == 1;\n    }\n    return (ret = 0) == 1;\n}\n\nbool solve() {\n    cin >> W >> H;\n    if (W == 0) return false;\n\n    L.resize(H);\n    R.resize(H);\n    for (int x = 0; x < H; ++x) {\n        cin >> L[x] >> R[x];\n        reverse(R[x].begin(), R[x].end());\n    }\n\n    int lsx, lsy, lgx, lgy;\n    for (int x = 0; x < H; ++x) {\n        for (int y = 0; y < W; ++y) {\n            if (L[x][y] == 'L') lsx = x, lsy = y;\n            if (L[x][y] == '%') lgx = x, lgy = y;\n\n            if (R[x][y] == 'R') rsx = x, rsy = y;\n            if (R[x][y] == '%') rgx = x, rgy = y;\n        }\n    }\n\n    dp.resize(H);\n    for (auto& v1 : dp) {\n        v1.resize(W);\n        for (auto& v2 : v1) {\n            v2.resize(H);\n            for (auto& v3 : v2) {\n                v3.assign(W, -1);\n            }\n        }\n    }\n\n    cout << (dfs(lsx, lsy, rsx, rsy) ? \"Yes\" : \"No\") << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\n\n\nint W,H;\nstring roomL[55],roomR[55];\n\nbool range_check(int y,int x) {\n    if(y<0||x<0) return false;\n    if(H<=y||W<=x) return false;\n\n    return true;\n}\n\nbool visited[55][55][55][55];\nbool ok(P len,P rin) {\n    memset(visited,0,sizeof(visited));\n    visited[len.fr][len.sc][rin.fr][rin.sc]=true;\n    queue<PP> que;\n    que.push(PP(len,rin));\n\n    while(que.size()) {\n        PP pp=que.front(); que.pop();\n        P next_len=pp.fr;\n        P next_rin=pp.sc;\n\n        //printf(\"[debug] %d %d %d %d\\n\",next_len.fr,next_len.sc,next_rin.fr,next_rin.sc);\n\n        if(roomL[next_len.fr][next_len.sc]=='%' && roomR[next_rin.fr][next_rin.sc]=='%') {\n            return true;\n        }\n        if(roomL[next_len.fr][next_len.sc]=='%' || roomR[next_rin.fr][next_rin.sc]=='%') {\n            //visited[next_len.fr][next_len.sc][next_rin.fr][next_rin.sc]=false;\n            continue;\n        }\n        rep(i,4) {\n            next_len=pp.fr;\n            next_rin=pp.sc;\n\n            if(range_check(next_len.fr+dy[i],next_len.sc+dx[i]) && roomL[next_len.fr+dy[i]][next_len.sc+dx[i]]!='#') {\n                next_len.fr+=dy[i];\n                next_len.sc+=dx[i];\n            }\n            if(range_check(next_rin.fr+dy[i],next_rin.sc-dx[i]) && roomR[next_rin.fr+dy[i]][next_rin.sc-dx[i]]!='#') {\n                next_rin.fr+=dy[i];\n                next_rin.sc-=dx[i];\n            }\n\n            if(!visited[next_len.fr][next_len.sc][next_rin.fr][next_len.sc]) {\n                visited[next_len.fr][next_len.sc][next_rin.fr][next_len.sc]=true;\n                que.push(PP(next_len,next_rin));\n            }\n        }\n    }\n\n    return false;\n}\n\nvoid solve() {\n    rep(y,H) cin>>roomL[y]>>roomR[y];\n    P len,rin;\n    rep(y,H) rep(x,W) {\n        if(roomL[y][x]=='L') len=P(y,x);\n        if(roomR[y][x]=='R') rin=P(y,x);\n    }\n    if(ok(len,rin)) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n}\n\nint main() {\n    while(cin>>W>>H) {\n        if(!W) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, k, n) for (int i = (int)(k); i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rREP(i, k, n) for (int i = (int)(n)-1; i >= k; i--)\n\n#define debug(x) cerr << #x << \": \" << x << endl;\n\n#define fi first\n#define se second\n\n#define vi vector<int>\n#define pii pair<int, int>\n#define pb push_back\n#define mp make_pair\n\n#define pcnt __builtin_popcount\n\ntypedef long long ll;\n\nconst int    inf = 100100100;\nconst int    MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\nconst int    dx[4] = {0, 1, 0, -1};\nconst int    dy[4] = {1, 0, -1, 0};\n\nstruct POINT {\n    int lx;\n    int ly;\n    int rx;\n    int ry;\n};\n\nbool u[55][55][55][55] = {};\nint  main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    int    w, h;\n    string ML[55], MR[55];\n    int    slx, sly, srx, sry;\n    while (cin >> w >> h, w) {\n        rep(y, h) cin >> ML[y] >> MR[y];\n        rep(y, h) rep(x, w) {\n            if (ML[y][x] == 'L') slx = x, sly = y;\n            if (MR[y][x] == 'R') srx = x, sry = y;\n        }\n        queue<POINT> que;\n        que.push(POINT{slx, sly, srx, sry});\n\n        bool flag = false;\n        while (!que.empty()) {\n            POINT p = que.front();\n            que.pop();\n            if (u[p.lx][p.ly][p.rx][p.ry]) continue;\n            rep(i, 4) {\n                int  nlx = p.lx + dx[i];\n                int  nly = p.ly + dy[i];\n                int  nrx = p.rx + dx[(i + 2) % 4];\n                int  nry = p.ry + dy[i];\n                bool left_do = true;\n                bool right_do = true;\n                if (nlx < 0 || w <= nlx) left_do = false;\n                if (nly < 0 || h <= nly) left_do = false;\n                if (ML[nly][nlx] == '#') left_do = false;\n                if (nrx < 0 || w <= nrx) right_do = false;\n                if (nry < 0 || h <= nry) right_do = false;\n                if (MR[nry][nrx] == '#') right_do = false;\n                if (ML[nly][nlx] == '%' && MR[nry][nrx] == '%') {\n                    flag = true;\n                    while (!que.empty()) que.pop();\n                    break;\n                } else if (ML[nly][nlx] == '%' || MR[nry][nrx] == '%') {\n                    continue;\n                }\n                if (!left_do && !right_do) continue;\n                if (!left_do) nlx = p.lx, nly = p.ly;\n                if (!right_do) nrx = p.rx, nry = p.ry;\n                que.push(POINT{nlx, nly, nrx, nry});\n            }\n            u[p.lx][p.ly][p.rx][p.ry] = true;\n        }\n        if (flag)\n            cout << \"Yes\" << endl;\n        else\n            cout << \"No\" << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n#define REP(i, a, n) for(int i=a; i<n; i++)\n\nbool hist[51][51][51][51];\n\nstruct State {\n\tint xL, yL, xR, yR;\n};\n\nint main() {\n\tint w, h;\n\n\tint dx[4] = { 0, 1, 0, -1 }; // ????????????\n\tint dy[4] = { -1, 0, 1, 0 };\n\n\twhile (cin >> w >> h, w || h) {\n\t\tState st;\n\t\tchar Len[51][51];\n\t\tchar Rin[51][51];\n\t\t//bool hist[51][51][51][51] = { false };\n\t\thist[51][51][51][51] = { false };\n\n\t\t/* crate maze */\n\t\tREP(i, 0, h) {\n\t\t\tREP(j, 0, w) {\n\t\t\t\tcin >> Len[i][j];\n\t\t\t\tif (Len[i][j] == 'L') {\n\t\t\t\t\tst.yL = i;\n\t\t\t\t\tst.xL = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(j, 0, w) {\n\t\t\t\tcin >> Rin[i][j];\n\t\t\t\tif (Rin[i][j] == 'R') {\n\t\t\t\t\tst.yR = i;\n\t\t\t\t\tst.xR = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* BFS */\n\t\tqueue<State> qu;\n\t\tqu.push(st);\n\t\thist[st.yL][st.xL][st.yR][st.xR] = true;\n\t\tbool flag = false;\n\n\t\twhile (!qu.empty()) {\n\t\t\tState q = qu.front();\n\t\t\tqu.pop();\n\n\t\t\tint yl = q.yL, xl = q.xL, yr = q.yR, xr = q.xR;\n\t\t\tif (Len[yl][xl] == '%' && Rin[yr][xr] == '%') {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (Len[yl][xl] == '%' || Rin[yr][xr] == '%') continue;\n\t\t\tfor (int k = 0; k<4; ++k) {\n\t\t\t\tint yyl = yl + dy[k], xxl = xl + dx[k];\n\t\t\t\tint yyr, xxr;\n\t\t\t\tyyr = yr + dy[k];\n\t\t\t\txxr = xr + dx[k] * (-1);\n\n\t\t\t\tif (yyl<0 || yyl >= h || xxl<0 || xxl >= w || Len[yyl][xxl] == '#') {\n\t\t\t\t\tyyl = yl;\n\t\t\t\t\txxl = xl;\n\t\t\t\t}\n\t\t\t\tif (yyr<0 || yyr >= h || xxr<0 || xxr >= w || Rin[yyr][xxr] == '#') {\n\t\t\t\t\tyyr = yr;\n\t\t\t\t\txxr = xr;\n\t\t\t\t}\n\t\t\t\tif (hist[yyl][xxl][yyr][xxr]) continue;\n\t\t\t\thist[yyl][xxl][yyr][xxr] = true;\n\t\t\t\tqu.push({ yyl, xxl, yyr, xxr });\n\t\t\t\t//cout << yyl << \" \" << xxl << \" \" << yyr << \" \" << xxr << endl;\n\t\t\t}\n\t\t}\n\t\tif (flag) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t\t/*\n\t\tREP(i, 0, h) {\n\t\t\tREP(j, 0, w) {\n\t\t\t\tcout << Len[i][j];\n\t\t\t}\n\t\t\tcout << \" \";\n\t\t\tREP(j, 0, w) {\n\t\t\t\tcout << Rin[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\n\t}\n\tint in;\n\tcin >> in;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst double EPS = 1e-9;\n\nint main(){\n    while(true){\n        int W,H;\n        cin >> W >> H;\n        if(W == 0 and H == 0) break;\n        vector<vector<string> > field(2,vector<string>(H+2,string(W+2,'#')));\n\n        for(int i=1;i<=H;i++){\n            for(int j=0;j<2;j++){\n                cin >> field[j][i];\n                field[j][i] = '#' + field[j][i] + '#';\n            }\n        }\n//        for(int i=0;i<H+2;i++){\n//            cerr << field[0][i] << \" \" << field[1][i] << endl;\n//        }\n        pair<pii,pii> start;\n        pair<pii,pii> goal;\n        for(int i=0;i<2;i++){\n            for(int j=1;j<=H;j++){\n                for(int k=1;k<=W;k++){\n                    if(field[i][j][k] == 'L'){\n                        start.first = make_pair(j,k);\n                    }else if(field[i][j][k] == 'R'){\n                        start.second = make_pair(j,k);\n                    }else if(field[i][j][k] == '%'){\n                        if(i == 0){\n                            goal.first = make_pair(j,k);\n                        }else{\n                            goal.second = make_pair(j,k);\n                        }\n                    }\n                }\n            }\n        }\n        stack<pair<pii,pii> > sta;\n        sta.push(start);\n        bool used[H+2][W+2][H+2][W+2];\n        for(int i=0;i<H+2;i++){\n            for(int j=0;j<W+2;j++){\n                for(int k=0;k<H+2;k++){\n                    for(int l=0;l<W+2;l++){\n                        used[i][j][k][l] = false;\n                    }\n                }\n            }\n        }\n        bool ok = false;\n        while(not sta.empty()){\n            pair<pii,pii> now = sta.top();\n            sta.pop();\n            if(used[now.first.first][now.first.second][now.second.first][now.second.second]){\n                continue;\n            }\n            used[now.first.first][now.first.second][now.second.first][now.second.second] = true;\n            if(now == goal){\n                ok = true;\n                break;\n            }\n            for(int i=0;i<4;i++){\n                pair<pii,pii> next = now;\n                next.first.first += dy[i];\n                next.first.second += dx[i];\n                next.second.first += dy[i];\n                next.second.second -= dx[i];\n                if(field[0][next.first.first][next.first.second] == '#'){\n                    next.first = now.first;\n                }\n                if(field[1][next.second.first][next.second.second] == '#'){\n                    next.second = now.second;\n                }\n                sta.push(next);\n            }\n        }\n        if(ok){\n            cout << \"Yes\" << endl;\n        }else{\n            cout << \"No\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint w, h;\nstring l[52], r[52];\nint ldx[4] = {1, 0, -1, 0};\nint ldy[4] = {0, 1, 0, -1};\nint rdx[4] = {1, 0, -1, 0};\nint rdy[4] = {0, -1, 0, 1};\nint lsx, lsy, rsx, rsy, lgx, lgy, rgx, rgy;\nbool lischecked[52][52], rischecked[52][52];\n\nbool solve(int lx, int ly, int rx, int ry){\n    if(lx == lgx && ly == lgy && rx == rgx && ry == rgy) return true;\n    if((lx == lgx && ly == lgy) || (rx == rgx && ry == rgy)) return false;\n    for(int i = 0; i < 4; i++){\n        int nlx = lx + ldx[i], nly = ly + ldy[i];\n        int nrx = rx + rdx[i], nry = ry + rdy[i];\n        if((nlx < 0 || nly < 0 || nlx >= h || nly >= w) && (nrx < 0 || nry < 0 || nrx >= h || nry >= w)) continue;\n        if((l[nlx][nly] == '#' && r[nrx][nry] == '#') || (lischecked[nlx][nly] && rischecked[nrx][nry])) continue;\n        if(nlx < 0 || nlx >= h || nly < 0 || nly >= w || l[nlx][nly] == '#'){\n            nlx = lx;\n            nly = ly;\n        }\n        if(nrx < 0 || nrx >= h || nry < 0 || nry >= w || r[nrx][nry] == '#'){\n            nrx = rx;\n            nry = ry;\n        }\n        lischecked[nlx][nly] = true;\n        rischecked[nrx][nry] = true;\n        if(solve(nlx, nly, nrx, nry)) return true;\n        lischecked[nlx][nly] = false;\n        rischecked[nrx][nry] = false;\n    }\n    return false;\n}\n\nint main()\n{\n    while(1){\n        cin >> w >> h;\n        if(w == 0 && h == 0) break;\n        for(int i = 0; i < h; i++){\n            cin >> l[i] >> r[i];\n        }\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                lischecked[i][j] = false;\n                rischecked[i][j] = false;\n                if(l[i][j] == 'L'){\n                    lsx = i;\n                    lsy = j;\n                }\n                if(l[i][j] == '%'){\n                    lgx = i;\n                    lgy = j;\n                }\n                if(r[i][j] == 'R'){\n                    rsx = i;\n                    rsy = j;\n                }\n                if(r[i][j] == '%'){\n                    rgx = i;\n                    rgy = j;\n                }\n            }\n        }\n        lischecked[lsx][lsy] = true;\n        rischecked[rsx][rsy] = true;\n        if(solve(lsx, lsy, rsx, rsy)) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<vvvi> vvvvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct State{\n\tint li,lj,ri,rj;\n\tState(){}\n\tState(int li,int lj,int ri,int rj):li(li),lj(lj),ri(ri),rj(rj){}\n};\nint main()\n{\n\tfor(int w,h;cin>>w>>h,w|h;){\n\t\tvs lgrid(h),rgrid(h);\n\t\trep(i,h) cin>>lgrid[i]>>rgrid[i];\n\t\t\n\t\tqueue<State> q;\n\t\t{\n\t\t\tint li,lj,ri,rj;\n\t\t\trep(i,h) rep(j,w){\n\t\t\t\tif(lgrid[i][j]=='L')\n\t\t\t\t\tli=i,lj=j,lgrid[i][j]='.';\n\t\t\t\tif(rgrid[i][j]=='R')\n\t\t\t\t\tri=i,rj=j,rgrid[i][j]='.';\n\t\t\t}\n\t\t\tq.emplace(li,lj,ri,rj);\n\t\t}\n\t\t\n\t\tbool res=false;\n\t\tvvvvi vis(h,vvvi(w,vvi(h,vi(w))));\n\t\twhile(!q.empty()){\n\t\t\tState c=q.front(); q.pop();\n\t\t\t\n\t\t\tif(vis[c.li][c.lj][c.ri][c.rj]) continue;\n\t\t\tvis[c.li][c.lj][c.ri][c.rj]=1;\n\t\t\t\n\t\t\tif(lgrid[c.li][c.lj]=='%' && rgrid[c.ri][c.rj]=='%'){\n\t\t\t\tres=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(lgrid[c.li][c.lj]=='%' || rgrid[c.ri][c.rj]=='%')\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tint di[]={-1,1,0,0},dj[]={0,0,-1,1};\n\t\t\trep(k,4){\n\t\t\t\tint nli=c.li+di[k],nlj=c.lj+dj[k];\n\t\t\t\tif(nli<0 || h<=nli || nlj<0 || w<=nlj || lgrid[nli][nlj]=='#')\n\t\t\t\t\tnli=c.li,nlj=c.lj;\n\t\t\t\tint nri=c.ri+di[k],nrj=c.rj-dj[k];\n\t\t\t\tif(nri<0 || h<=nri || nrj<0 || w<=nrj || rgrid[nri][nrj]=='#')\n\t\t\t\t\tnri=c.ri,nrj=c.rj;\n\t\t\t\tq.emplace(nli,nlj,nri,nrj);\n\t\t\t}\n\t\t}\n\t\tcout<<(res?\"Yes\":\"No\")<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Header {{{\n// includes {{{\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <unistd.h>\n#include <vector>\n// }}}\nusing namespace std;\n// consts {{{\nstatic const int INF = 1e9;\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n// }}}\n// typedefs {{{\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<ULL> VULL;\ntypedef vector<VULL> VVULL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\ntypedef complex<char> P;\n#define PQ(type) priority_queue<type>\n// priority queue reverse\n#define PQR(type) priority_queue< type, vector<type>, greater<type> >\n// }}}\n// macros & inline functions {{{\n// syntax sugars {{{\n#define FOR(i, b, e) for (typeof(e) i = (b); i < (e); ++i)\n#define FORI(i, b, e) for (typeof(e) i = (b); i <= (e); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(i, n) FORI(i, 0, n)\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n#define ASSIGN_MAX(var, val) ((var) = max((var), (val)))\n#define ASSIGN_MIN(var, val) ((var) = min((var), (val)))\n// }}}\n// conversion {{{\ninline int toInt(string s) { int v; istringstream sin(s); sin>>v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout<<x; return sout.str(); }\n// }}}\n// array and STL {{{\n#define ARRSIZE(a) ( sizeof(a) / sizeof(a[0]) )\n#define ZERO(a, v) ( assert(v == 0 || v == -1), memset(a, v, sizeof(a)) )\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define SIZE(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c, it) for(typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define REACH(c, it) for(typeof((c).rbegin()) it=(c).rbegin(); it!=(c).rend(); ++it)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n// }}}\n// bit manipulation {{{\n// singed integers are not for bitwise operations, specifically arithmetic shifts ('>>', and maybe not good for '<<' too)\n#define IS_UNSIGNED(n) (!numeric_limits<typeof(n)>::is_signed)\n#define BIT(n) (assert(IS_UNSIGNED(n)), assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(IS_UNSIGNED(n)), assert(m < 64), ((ULL)(n) >> (m) & 1))\ninline int BITS_COUNT(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int MSB(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c-1; }\ninline int MAKE_MASK(ULL upper, ULL lower) { assert(lower < 64 && upper < 64 && lower <= upper); return (BIT(upper) - 1) ^ (BIT(lower) - 1); }\n// }}}\n// for readable code {{{\n#define EVEN(n) (n % 2 == 0)\n#define ODD(n) (!EVEN(n))\n// }}}\n// debug {{{\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n#define dprt(fmt, ...) if (opt_debug) { fprintf(stderr, fmt, ##__VA_ARGS__); }\n#define darr(a) if (opt_debug) { copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr_range(a, f, t) if (opt_debug) { copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define dvec(v) if (opt_debug) { copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr2(a) if (opt_debug) { FOR(__i, 0, (arrsz(a))){ darr( (a)[__i] ); } }\n#define WAIT() if (opt_debug) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#define dump(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl; }\n// dump vector elements in [s, e)\n#define dumpv(v, s, e) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #v << \" = \"; FOR(__i, s, e) { cerr << v[__i] << \"\\t\"; } cerr << endl; }\n#define dumpl(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << endl << (x) << endl; }\n#define dumpf() if (opt_debug) { cerr << __PRETTY_FUNCTION__ << endl; }\n#define where() if (opt_debug) { cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl; }\n#define dumpb(bit, digits) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #bit << \" = \"; for(int __i = digits - 1; __i >= 0; __i--) { cerr << static_cast<bool>(bit & (1 << __i)); if (__i % 4 == 0) { cerr << \" \"; } } cerr << endl; }\n\n// ostreams {{{\n// complex\ntemplate<typename T> ostream& operator<<(ostream& s, const complex<T>& d) {return s << \"(\" << d.real() << \", \" << d.imag() << \")\";}\n\n// pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n// vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i]; if (i < len - 1) s << \"\\t\";\n\t}\n\treturn s;\n}\n\n// 2 dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i] << endl;\n\t}\n\treturn s;\n}\n\n// map\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const map<T1, T2>& m) {\n\ts << \"{\" << endl;\n\tfor (typeof(m.begin()) itr = m.begin(); itr != m.end(); ++itr) {\n\t\ts << \"\\t\" << (*itr).first << \" : \" << (*itr).second << endl;\n\t}\n\ts << \"}\" << endl;\n\treturn s;\n}\n// }}}\n// }}}\n// }}}\n// time {{{\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\n// }}}\n// string manipulation {{{\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\ninline string join(VS s, string j) { string t; REP(i, s.size()) { t += s[i] + j; } return t; }\n// }}}\n// geometry {{{\n#define Y real()\n#define X imag()\n// }}}\n// 2 dimentional array {{{\nenum { UP, RIGHT, DOWN, LEFT, UP_RIGHT, DOWN_RIGHT, DOWN_LEFT, UP_LEFT };\nP dydx4[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\nP dydx8[8] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(-1, 1), P(1, 1), P(1, -1), P(-1, -1) };\nbool in_field(int H, int W, P p) {\n\treturn (0 <= p.Y && p.Y < H) && (0 <= p.X && p.X < W);\n}\n// }}}\n// input and output {{{\ninline void input(string filename) {\n\tfreopen(filename.c_str(), \"r\", stdin);\n}\ninline void output(string filename) {\n\tfreopen(filename.c_str(), \"w\", stdout);\n}\n// }}}\n// }}}\n\nbool opt_debug = false;\n\nint main(int argc, char** argv) {\n\tstd::ios_base::sync_with_stdio(false);\n\t// set options {{{\n\tint __c;\n\twhile ( (__c = getopt(argc, argv, \"d\")) != -1 ) {\n\t\tswitch (__c) {\n\t\t\tcase 'd':\n\t\t\t\topt_debug = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tabort();\n\t\t}\n\t}\n\t// }}}\n\n\t// opt_debug = true;\n\t// input(\"./inputs/0.txt\");\n\t// output(\"./outputs/0.txt\");\n\n\tint W, H;\n\twhile (cin >> W >> H, W | H) {\n\t\tVVC room_l(H, VC(W));\n\t\tVVC room_r(H, VC(W));\n\t\tP len, rin;\n\t\tREP (i, H) {\n\t\t\tREP (j, W) {\n\t\t\t\tcin >> room_l[i][j];\n\t\t\t\tif (room_l[i][j] == 'L') {\n\t\t\t\t\tlen = P(i, j);\n\t\t\t\t\troom_l[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP (j, W) {\n\t\t\t\tcin >> room_r[i][j];\n\t\t\t\tif (room_r[i][j] == 'R') {\n\t\t\t\t\trin = P(i, j);\n\t\t\t\t\troom_r[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttypedef pair<P, P> PPP;\n\t\tqueue<PPP> q;\n\t\tq.push(MP(len, rin));\n\t\tP dydx_l[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\n\t\tP dydx_r[4] = { P(-1, 0), P(0, -1), P(1, 0), P(0, 1) };\n\t\ttypedef pair< pair<char, char>, pair<char, char> > PPIIPII;\n\t\tset< PPIIPII > visited;\n\t\tbool ok = false;\n\t\twhile (!q.empty()) {\n\t\t\tPPP t = q.front(); q.pop();\n\t\t\tPPIIPII key = MP( MP(t.F.Y, t.F.X), MP(t.S.Y, t.S.X) );\n\t\t\tif (EXIST(visited, key)) { continue; }\n\t\t\tvisited.insert(key);\n\t\t\tlen = t.F; rin = t.S;\n\t\t\tif (room_l[len.Y][len.X] == '%' && room_r[rin.Y][rin.X] == '%') {\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (room_l[len.Y][len.X] == '%' || room_r[rin.Y][rin.X] == '%') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tREP (d, 4) {\n\t\t\t\tP n_len = len + dydx_l[d];\n\t\t\t\tP n_rin = rin + dydx_r[d];\n\t\t\t\tif (!in_field(H, W, n_len) || room_l[n_len.Y][n_len.X] == '#') {\n\t\t\t\t\tn_len -= dydx_l[d];\n\t\t\t\t}\n\t\t\t\tif (!in_field(H, W, n_rin) || room_r[n_rin.Y][n_rin.X] == '#') {\n\t\t\t\t\tn_rin -= dydx_r[d];\n\t\t\t\t}\n\n\t\t\t\tPPIIPII _key = MP( MP(n_len.Y, n_len.X), MP(n_rin.Y, n_rin.X) );\n\t\t\t\tif (!EXIST(visited, _key)) {\n\t\t\t\t\tq.push(MP(n_len, n_rin));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ok) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t} else {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<tuple>\n#include<string>\nusing namespace std;\n\n#define MAX_N 60\n#define INF 1<<30\n\nint dist[MAX_N][MAX_N][MAX_N][MAX_N];\nint dy1[4] = { 0,1,0,-1 };\nint dy2[4] = { 0,1,0,-1 };\nint dx1[4] = { 1,0,-1,0 };\nint dx2[4] = { -1,0,1,0 };\nint H, W, map1[MAX_N][MAX_N], map2[MAX_N][MAX_N];\nint Lsy, Lsx, Lgy, Lgx;\nint Rsy, Rsx, Rgy, Rgx;\nstring S, T;\nqueue<tuple<int, int, int, int>>Q;\n\nvoid _memset() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tfor (int k = 0; k < MAX_N; k++) {\n\t\t\t\tfor (int l = 0; l < MAX_N; l++) {\n\t\t\t\t\tdist[i][j][k][l] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tmap1[i][j] = 1;\n\t\t\tmap2[i][j] = 1;\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\t_memset();\n\t\tcin >> W >> H;\n\t\tif (H == 0 && W == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tcin >> S >> T;\n\t\t\tfor (int j = 0; j < S.size(); j++) {\n\t\t\t\tif (S[j] == '%') {\n\t\t\t\t\tLsx = j + 1; Lsy = i;\n\t\t\t\t\tmap1[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\tif (S[j] == '#') {\n\t\t\t\t\tmap1[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (S[j] == '.') {\n\t\t\t\t\tmap1[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\tif (S[j] == 'L') {\n\t\t\t\t\tLgy = i; Lgx = j + 1;\n\t\t\t\t\tmap1[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < T.size(); j++) {\n\t\t\t\tif (T[j] == '%') {\n\t\t\t\t\tRsx = j + 1; Rsy = i;\n\t\t\t\t\tmap2[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\tif (T[j] == '#') {\n\t\t\t\t\tmap2[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (T[j] == '.') {\n\t\t\t\t\tmap2[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\tif (T[j] == 'R') {\n\t\t\t\t\tRgy = i; Rgx = j + 1;\n\t\t\t\t\tmap2[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQ.push(make_tuple(Lsy, Lsx, Rsy, Rsx));\n\t\tdist[Lsy][Lsx][Rsy][Rsx] = 0;\n\n\t\twhile (!Q.empty()) {\n\t\t\ttuple<int, int, int, int>tup = Q.front(); Q.pop();\n\t\t\tint ay = get<0>(tup);\n\t\t\tint ax = get<1>(tup);\n\t\t\tint by = get<2>(tup);\n\t\t\tint bx = get<3>(tup);\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint ey = ay + dy1[i], ex = ax + dx1[i];\n\t\t\t\tint fy = by + dy2[i], fx = bx + dx2[i];\n\t\t\t\tif (map1[ey][ex] == 1) {\n\t\t\t\t\tey = ay; ex = ax;\n\t\t\t\t}\n\t\t\t\tif (map2[fy][fx] == 1) {\n\t\t\t\t\tfy = by; fx = bx;\n\t\t\t\t}\n\t\t\t\tif (dist[ey][ex][fy][fx] == INF) {\n\t\t\t\t\tdist[ey][ex][fy][fx] = dist[ay][ax][by][bx] + 1;\n\t\t\t\t\tQ.push(make_tuple(ey, ex, fy, fx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[Lgy][Lgx][Rgy][Rgx] == INF) {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint lsx, lsy, ltx, lty, rsx, rsy, rtx, rty;\nbool dfs(vector<vector<vvi>> &dp, int lx, int ly, int rx, int ry) {\n\tif (dp[ly][lx][ry][rx] != -1)return dp[ly][lx][ry][rx];\n\treturn true;\n}\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint w, h;\n\twhile (cin >> w >> h, w) {\n\t\tvector<string> l(h), r(h);\n\t\tREP(i, h) cin >> l[i] >> r[i];\n\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tif (l[i][j] == '%') {\n\t\t\t\t\tltx = j; lty = i;\n\t\t\t\t}\n\t\t\t\tif (l[i][j] == 'L') {\n\t\t\t\t\tlsx = j; lsy = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tif (r[i][j] == '%') {\n\t\t\t\t\trtx = j; rty = i;\n\t\t\t\t}\n\t\t\t\tif (r[i][j] == 'R') {\n\t\t\t\t\trsx = j; rsy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<pair<pii, pii>> q;\n\t\tvector<vector<vvi>> b(h, vector<vvi>(w, vvi(h, vi(w, 0))));\n\t\tq.push(pair<pii, pii>(pii(lsx, lsy), pii(rsx, rsy)));\n\t\tb[lsy][lsx][rsy][rsx] = 1;\n\t\twhile (!q.empty()) {\n\t\t\tauto a = q.front(); q.pop();\n\t\t\tint lx = a.first.first, ly = a.first.second, rx = a.second.first, ry = a.second.second;\n\t\t\tif (lx == ltx&&ly == lty) {\n\t\t\t\tif (rx == rtx&&ry == rty) {\n\t\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\t\tgoto a;\n\t\t\t\t}\n\t\t\t\telse continue;\n\t\t\t}\n\t\t\telse if (rx == rtx&&ry == rty)continue;\n\n\t\t\tREP(i, 4) {\n\t\t\t\tint lnx = lx + dx[i * 2], lny = ly + dy[i * 2], rnx = rx + dx[(i + 2 ) %4*2], rny = ry + dy[i*2];\n\t\t\t\tif (lnx < 0 || lnx >= w || lny < 0 || lny >= h ){ \n\t\t\t\t\tlny = ly; lnx = lx;\n\t\t\t\t}\n\t\t\t\telse if (l[lny][lnx] == '#') {\n\t\t\t\t\tlny = ly; lnx = lx;\n\t\t\t\t}\n\t\t\t\tif (rnx < 0 || rnx >= w || rny < 0 || rny >= h ) {\n\t\t\t\t\trny = ry; rnx = rx;\n\t\t\t\t}\n\t\t\t\telse if (r[rny][rnx] == '#') {\n\t\t\t\t\trny = ry; rnx = rx;\n\t\t\t\t}\n\t\t\t\tif ((lnx!=lx||lny!=ly||rnx!=rx||rny!=ry)&& b[lny][lnx][rny][rnx]!=1) {\n\t\t\t\t\n\t\t\t\t\tq.push(pair<pii, pii>(pii(lnx, lny), pii(rnx, rny)));\n\t\t\t\t\tb[lny][lnx][rny][rnx] = 1;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << \"No\" << endl;\n\n\ta:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<stack>\n#include<string.h>\nusing namespace std;\n#define REP(i, a, n) for(int i=a; i<n; i++)\n\nbool hist[51][51][51][51];\n\nstruct State {\n\tint xL, yL, xR, yR;\n};\n\nint main() {\n\tint w, h;\n\n\tint dx[4] = { 0, 1, 0, -1 }; // ????????????\n\tint dy[4] = { -1, 0, 1, 0 };\n\n\twhile (cin >> w >> h, w || h) {\n\t\tState st;\n\t\tchar Len[51][51];\n\t\tchar Rin[51][51];\n\t\tmemset(hist, false, sizeof hist);\n\n\t\t/* crate maze */\n\t\tREP(i, 0, h) {\n\t\t\tREP(j, 0, w) {\n\t\t\t\tcin >> Len[i][j];\n\t\t\t\tif (Len[i][j] == 'L') {\n\t\t\t\t\tst.yL = i;\n\t\t\t\t\tst.xL = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(j, 0, w) {\n\t\t\t\tcin >> Rin[i][j];\n\t\t\t\tif (Rin[i][j] == 'R') {\n\t\t\t\t\tst.yR = i;\n\t\t\t\t\tst.xR = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* BFS */\n\t\tstack<State> stk;\n\t\tstk.push(st);\n\t\t\n\t\thist[st.yL][st.xL][st.yR][st.xR] = true;\n\t\tbool flag = {};\n\n\t\twhile (!stk.empty()) {\n\t\t\tState sk = stk.top();\n\t\t\tstk.pop();\n\n\t\t\tint yl = sk.yL, xl = sk.xL, yr = sk.yR, xr = sk.xR;\n\t\t\tif (Len[yl][xl] == '%' && Rin[yr][xr] == '%') {\n\t\t\t\tflag = true;\n\t\t\t\t//cout << yl << \" \" << xl << \" \" << yr << \" \" << xr << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (Len[yl][xl] == '%' || Rin[yr][xr] == '%') continue;\n\t\t\tfor (int k = 0; k<4; ++k) {\n\t\t\t\tint yyl = yl + dy[k], xxl = xl + dx[k];\n\t\t\t\tint yyr, xxr;\n\t\t\t\tyyr = yr + dy[k];\n\t\t\t\txxr = xr + dx[k] * (-1);\n\n\t\t\t\tif (yyl<0 || yyl >= h || xxl<0 || xxl >= w) {\n\t\t\t\t\tyyl = yl;\n\t\t\t\t\txxl = xl;\n\t\t\t\t}\n\t\t\t\telse if (Len[yyl][xxl] == '#') {\n\t\t\t\t\tyyl = yl;\n\t\t\t\t\txxl = xl;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (yyr<0 || yyr >= h || xxr<0 || xxr >= w) {\n\t\t\t\t\tyyr = yr;\n\t\t\t\t\txxr = xr;\n\t\t\t\t}\n\t\t\t\telse if (Rin[yyr][xxr] == '#') {\n\t\t\t\t\tyyr = yr;\n\t\t\t\t\txxr = xr;\n\t\t\t\t}\n\t\t\t\tif (hist[yyl][xxl][yyr][xxr]) continue;\n\t\t\t\thist[yyl][xxl][yyr][xxr] = true;\n\t\t\t\tstk.push({ yyl, xxl, yyr, xxr });\n\t\t\t}\n\t\t}\n\t\tif (flag) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2153&lang=jp\ntypedef long long ll;\ntypedef vector<vector<char>> vvc;\ntypedef vector<char> vc;\ntypedef vector<vector<int>> vvi;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nint dlx[4] = {1, 0, -1, 0};\nint dly[4] = { 0,1,0,-1 };\nint drx[4] = { 1,0,-1,0 };\nint dry[4] = { 0,-1,0,1 };\n\nint W, H;\nbool bfs(pii l,pii r,vvi& Lf,vvi& Rf,vvc& L,vvc& R){\n\tqueue<pair<pii, pii>> q;\n\tq.push({ l,r });\n\twhile (!q.empty()) {\n\t\tauto pp = q.front(); q.pop();\n\t\tl = pp.first; r = pp.second;\n\t\tLf[l.first][l.second] = Rf[r.first][r.second] = 1;\n\n\t\t//cout << l.first << \" \" << l.second << \" / \" << r.first << \" \" << r.second << endl;\n\n\t\tfor (int i = 0; i < 4;i++) {\n\t\t\tint lx = l.first + dlx[i], ly = l.second + dly[i];\n\t\t\tint rx = r.first + drx[i], ry = r.second + dry[i];\n\t\t\tif (Lf[lx][ly] == 1 && Rf[rx][ry] == 1) continue;\n\t\t\tif (L[lx][ly] == '%' && R[rx][ry] == '%') return true;\n\t\t\tif (L[lx][ly] == '#' && R[rx][ry] == '#')continue;\n\t\t\tif (L[lx][ly] == '.' && R[rx][ry] == '.') {\n\t\t\t\tq.push({ { lx,ly }, { rx,ry } });\n\t\t\t}\n\t\t\telse if (L[lx][ly] == '.' && R[rx][ry] == '#') {\n\t\t\t\tq.push({ {lx,ly},{r.first,r.second} });\n\t\t\t}\n\t\t\telse if (L[lx][ly] == '#' && R[rx][ry] == '.') {\n\t\t\t\tq.push({ {l.first,l.second},{rx,ry} });\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\twhile (cin >> W >> H) {\n\t\tif ((W | H) == 0)break;\n\t\tvvc L(H + 2, vc(W + 2, '#'));\n\t\tvvc R(H + 2, vc(W + 2, '#'));\n\t\tvvi Lf(H + 2, vi(W + 2, 0));\n\t\tvvi Rf(H + 2, vi(W + 2, 0));\n\t\tpii ls, rs;\n\t\tfor (int i = 1; i <= H;i++) {\n\t\t\tfor (int j = 1;j <= W;j++) {\n\t\t\t\tcin >> L[i][j];\n\t\t\t\tif (L[i][j] == 'L') ls = { i,j };\n\t\t\t}\n\t\t\tfor (int j = 1;j <= W;j++) {\n\t\t\t\tcin >> R[i][j];\n\t\t\t\tif (R[i][j] == 'R') rs = { i,j };\n\t\t\t}\n\t\t}\n\n\t\tif (bfs(ls, rs, Lf, Rf, L, R)) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t\telse cout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\ntemplate <class T, class U, class V>\ninline T clamp(const T& x, const U& lo, const V& hi) { return x < lo ? lo : x > hi ? hi : x; }\n\nbool solve(int W, int H, const vector<string>& RoomL, const vector<string>& RoomR) {\n    int sxL, syL, sxR, syR;\n    rep(i, H) rep(j, W) {\n        if (RoomL[i][j] == 'L') sxL = i, syL = j;\n        if (RoomR[i][j] == 'R') sxR = i, syR = j;\n    }\n    bool vis[H][W][H][W]; memset(vis, 0, W * H * W * H); vis[sxL][syL][sxR][syR] = true;\n    queue<tuple<int, int, int, int>> Q;\n    for (Q.emplace(sxL, syL, sxR, syR); !Q.empty();) {\n        int xL, yL, xR, yR; tie(xL, yL, xR, yR) = Q.front(); Q.pop();\n        rep(k, 4) {\n            int nxL = clamp(xL + dx[k], 0, H - 1), nyL = clamp(yL + dy[k], 0, W - 1),\n                nxR = clamp(xR + dx[k], 0, H - 1), nyR = clamp(yR - dy[k], 0, W - 1);\n            if (RoomL[nxL][nyL] == '#' and RoomR[nxR][nyR] == '#') continue;\n            if (RoomL[nxL][nyL] == '#') nxL -= dx[k], nyL -= dy[k];\n            if (RoomR[nxR][nyR] == '#') nxR -= dx[k], nyR += dy[k];\n            if (RoomL[nxL][nyL] == '%' and RoomR[nxR][nyR] == '%') return true;\n            if (RoomL[nxL][nyL] == '%' or RoomR[nxR][nyR] == '%' or vis[nxL][nyL][nxR][nyR]) continue;\n            vis[nxL][nyL][nxR][nyR] = true;\n            Q.emplace(nxL, nyL, nxR, nyR);\n        }\n    }\n    return false;\n}\n\nint main() {\n    for (int W, H; cin >> W >> H, W | H;) {\n        vector<string> RoomL(H), RoomR(H);\n        rep(i, H) cin >> RoomL[i] >> RoomR[i];\n        cout << (solve(W, H, RoomL, RoomR) ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nbool dis[52][52][52][52];\n\ntypedef pair<pair<int, int>, pair<int, int> > status;\n#define LEFT first\n#define RIGHT second\n#define X first\n#define Y second\n\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nint main() {\n  int w, h;\n  while (true) {\n    vector<string> left, right;\n    cin >> w >> h;\n    if (w == 0 && h == 0) break;\n    string block;\n    rep (i, w + 2) block += '#';\n    left.push_back(block);\n    right.push_back(block);\n    rep (i, h) {\n      string str;\n      cin >> str;\n      left.push_back(\"#\" + str + \"#\");\n      cin >> str;\n      right.push_back(\"#\" + str + \"#\");\n    }\n    left.push_back(block);\n    right.push_back(block);\n    memset(dis, 0, sizeof(dis));\n    queue<status> que;\n    int lx, ly, rx, ry;\n    rep (i, left.size()) rep (j, left[0].size()) {\n      if (left[i][j] == 'L') {\n\tlx = j;\n\tly = i;\n      }\n      if (right[i][j] == 'R') {\n\trx = j;\n\try = i;\n      }\n    }\n    status s;\n    s.LEFT.X = lx;\n    s.LEFT.Y = ly;\n    s.RIGHT.X = rx;\n    s.RIGHT.Y = ry;\n    que.push(s);\n    while (!que.empty()) {\n      status now = que.front();\n      que.pop();\n      if (dis[now.LEFT.X][now.LEFT.Y][now.RIGHT.X][now.RIGHT.Y]) {\n\tcontinue;\n      }\n      dis[now.LEFT.X][now.LEFT.Y][now.RIGHT.X][now.RIGHT.Y] = true;\n      rep (i, 4) {\n\tstatus next = now;\n\tnext.LEFT.X += dx[i];\n\tnext.LEFT.Y += dy[i];\n\tnext.RIGHT.X -= dx[i];\n\tnext.RIGHT.Y += dy[i];\n\tif (left[next.LEFT.Y][next.LEFT.X] == '#') {\n\t  next.LEFT.X -= dx[i];\n\t  next.LEFT.Y -= dy[i];\n\t}\n\tif (right[next.RIGHT.Y][next.RIGHT.X] == '#') {\n\t  next.RIGHT.X += dx[i];\n\t  next.RIGHT.Y -= dy[i];\n\t}\n\tif (left[next.LEFT.Y][next.LEFT.X] == '%' && right[next.RIGHT.Y][next.RIGHT.X] == '%') goto aaa;\n\tif (left[next.LEFT.Y][next.LEFT.X] == '%') continue;\n\tif (right[next.RIGHT.Y][next.RIGHT.X] == '%') continue;\n\tque.push(next);\n      }\n    }\n    cout << \"No\" << endl;\n    continue;\n  aaa:;\n    cout << \"Yes\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"tune=native\")\n#pragma GCC target (\"avx\")\n\n#include <bits/stdc++.h>\n\n// 汎用マクロ\n#define ALL_OF(x) (x).begin(), (x).end()\n#define REP(i,n) for (long long i=0, i##_len=(n); i<i##_len; i++)\n#define RANGE(i,is,ie) for (long long i=(is), i##_end=(ie); i<=i##_end; i++)\n#define DSRNG(i,is,ie) for (long long i=(is), i##_end=(ie); i>=i##_end; i--)\n#define UNIQUE(v) { sort((v).begin(), (v).end()); (v).erase(unique((v).begin(), (v).end()), (v).end()); }\ntemplate<class T> bool chmax(T &a, const T &b) {if (a < b) {a = b; return 1;} return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) {if (a > b) {a = b; return 1;} return 0; }\n#define INF 0x7FFFFFFF\n#define LINF 0x7FFFFFFFFFFFFFFFLL\n#define Yes(q) (q ? \"Yes\" : \"No\")\n#define YES(q) (q ? \"YES\" : \"NO\")\n#define DUMP(q) cerr << \"[DEBUG] \" #q \": \" << (q) << \" at \" __FILE__ \":\" << __LINE__ << endl\n#define DUMPALL(q) cerr << \"[DEBUG] \" #q \": [\"; REP(dumpall_i, (q).size()) { cerr << q[dumpall_i] << (dumpall_i == (q).size() - 1 ? \"\" : \", \"); } cerr << \"] at \" __FILE__ \":\" << __LINE__ << endl\n\n// gcc拡張マクロ\n#define gcd __gcd\n#define popcount __builtin_popcount\n#define popcountll __builtin_popcountll\n\n// エイリアス\nusing  ll = long long;\nusing ull = unsigned long long;\nusing  ld = long double;\nusing namespace std;\n\n// モジュール\n\n\n// 処理内容\nint main() {\n    \n    ll w, h;\n    while (cin >> w >> h, w && h) {\n\n        vector<string> rl(h), rr(h);\n        REP(i, h) {\n            cin >> rl[i] >> rr[i];\n            rl[i] = \"#\" + rl[i] + \"#\";\n            rr[i] = \"#\" + rr[i] + \"#\";\n        }\n        string wall(w + 2, '#');\n        rl.insert(rl.begin(), wall);\n        rr.insert(rr.begin(), wall);\n        rl.emplace_back(wall);\n        rr.emplace_back(wall);\n        w += 2;\n        h += 2;\n\n        ll lsy, lsx, rsy, rsx;\n        ll lgy, lgx, rgy, rgx;\n        REP(i, h) REP(j, w) {\n            if (rl[i][j] == '%') {\n                lgy = i;\n                lgx = j;\n            } else if (rl[i][j] == 'L') {\n                lsy = i;\n                lsx = j;\n            }\n            if (rr[i][j] == '%') {\n                rgy = i;\n                rgx = j;\n            } else if (rr[i][j] == 'R') {\n                rsy = i;\n                rsx = j;\n            }\n        }\n\n        // {ly, lx, ry, rx}\n        deque<tuple<ll,ll,ll,ll>> q;\n        vector<vector<vector<vector<bool>>>> visited(h, vector<vector<vector<bool>>>(w, vector<vector<bool>>(h, vector<bool>(w, false))));\n        q.emplace_back(lsy, lsx, rsy, rsx);\n        visited[lsy][lsx][rsy][rsx] = true;\n        while (!q.empty()) {\n\n            ll ly = get<0>(q.front());\n            ll lx = get<1>(q.front());\n            ll ry = get<2>(q.front());\n            ll rx = get<3>(q.front());\n            q.pop_front();\n            if (ly == lgy && lx == lgx && ry == rgy && rx == rgx) {\n                break;\n            }\n\n            // Lin and Ren go upward\n            if (ly > 0 && ry > 0) {\n                ll ly2 = rl[ly - 1][lx] != '#' ? ly - 1 : ly;\n                ll lx2 = lx;\n                ll ry2 = rr[ry - 1][rx] != '#' ? ry - 1 : ry;\n                ll rx2 = rx;\n                bool is_locked = (ly2 == lgy && lx2 == lgx) != (ry2 == rgy && rx2 == rgx);\n                bool is_blocked = rl[ly2][lx2] == '#' || rr[ry2][rx2] == '#';\n                if (!visited[ly2][lx2][ry2][rx2] && !is_locked && !is_blocked) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n            }\n\n            // Lin and Ren go downward\n            if (ly < h-1 && ry < h-1) {\n                ll ly2 = rl[ly + 1][lx] != '#' ? ly + 1 : ly;\n                ll lx2 = lx;\n                ll ry2 = rr[ry + 1][rx] != '#' ? ry + 1 : ry;\n                ll rx2 = rx;\n                bool is_locked = (ly2 == lgy && lx2 == lgx) != (ry2 == rgy && rx2 == rgx);\n                bool is_blocked = rl[ly2][lx2] == '#' || rr[ry2][rx2] == '#';\n                if (!visited[ly2][lx2][ry2][rx2] && !is_locked && !is_blocked) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n            }\n\n            // Lin goes left and Ren goes right\n            if (lx > 0 && rx < w-1) {\n                ll ly2 = ly;\n                ll lx2 = rl[ly][lx - 1] != '#' ? lx - 1 : lx;\n                ll ry2 = ry;\n                ll rx2 = rr[ry][rx + 1] != '#' ? rx + 1 : rx;\n                bool is_locked = (ly2 == lgy && lx2 == lgx) != (ry2 == rgy && rx2 == rgx);\n                bool is_blocked = rl[ly2][lx2] == '#' || rr[ry2][rx2] == '#';\n                if (!visited[ly2][lx2][ry2][rx2] && !is_locked && !is_blocked) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n            }\n\n            // Lin goes right and Ren goes left\n            if (lx < w-1 && rx > 0) {\n                ll ly2 = ly;\n                ll lx2 = rl[ly][lx + 1] != '#' ? lx + 1 : lx;\n                ll ry2 = ry;\n                ll rx2 = rr[ry][rx - 1] != '#' ? rx - 1 : rx;\n                bool is_locked = (ly2 == lgy && lx2 == lgx) != (ry2 == rgy && rx2 == rgx);\n                bool is_blocked = rl[ly2][lx2] == '#' || rr[ry2][rx2] == '#';\n                if (!visited[ly2][lx2][ry2][rx2] && !is_locked && !is_blocked) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n            }\n\n        }\n\n        std::cout << Yes(visited[lgy][lgx][rgy][rgx]) << endl;\n\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\n\nint main(){\n    int w,h;\n    while(cin>>w>>h&&(w||h)){\n        vector<string> l(h),r(h);\n        rep(i,h){\n            cin>>l[i]>>r[i];\n        }\n        bool res = false;\n        pii ls,rs,lg,rg;\n        rep(i,h) rep(j,w){\n            if(l[i][j]=='L')ls = pii(i,j);\n            if(l[i][j]=='%')lg = pii(i,j);\n            if(r[i][j]=='R')rs = pii(i,j);\n            if(r[i][j]=='%')rg = pii(i,j);\n        }\n\n        bool used[50][50][50][50]={};\n        queue<pair<pii,pii>> que;\n        que.push(make_pair(ls,rs));\n        \n        while(que.size()){\n            pair<pii,pii> q = que.front();\n            \n            int dy1[]={1,-1,0,0};\n            int dx1[]={0,0,1,-1};\n            int dy2[]={1,-1,0,0};\n            int dx2[]={0,0,-1,1};\n            int ly = q.first .first, lx = q.first .second;\n            int ry = q.second.first, rx = q.second.second;\n            que.pop();\n            rep(i,4){\n                int ddly = ly+dy1[i], ddlx = lx+dx1[i];\n                int ddry = ry+dy2[i], ddrx = rx+dx2[i];\n                pii left,right;\n                if( ddlx>=0 && ddly>=0 && ddlx<w && ddly<h && l[ddly][ddlx]!='#') left = pii(ddly,ddlx);\n                else left = pii(ly,lx);\n\n                if( ddrx>=0 && ddry>=0 && ddrx<w && ddry<h && r[ddry][ddrx]!='#') right = pii(ddry,ddrx);\n                else right = pii(ry,rx);\n                if(left==lg&&right==rg)res = true;\n                if(left==lg||right==rg)continue;\n                if( used[left.first][left.second][right.first][right.second] )continue;\n                used[left.first][left.second][right.first][right.second]=true;\n                que.push(make_pair(left,right));\n            }\n        }\n        if(res)cout<<\"Yes\"<<endl;\n        else cout<<\"No\"<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<queue>\n#define MAX 50\nusing namespace std;\nstruct Point{int x,y;};\nstruct P{\n  Point l,r;\n  int cost;\n};\nint main(){\n  int w,h;\n  while(cin>>w>>h,w||h){\n    int i,j,k;\n    int inf = 1<<20;\n    int d[MAX+1][MAX+1][MAX+1][MAX+1];\n    fill(d[0][0][0],d[MAX][MAX][MAX],inf);\n    \n    string sr[60],sl[60];\n    for(i=0;i<h;i++){\n      cin >> sl[i] >> sr[i];\n    }\n    /*\n    Point pr,pl,br,bl;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(sl[i][j]=='L'){\n\t  pl.x=j;pl.y=i;\n\t}\n\tif(sr[i][j]=='R'){\n\t  pr.x=j;pr.y=i;\n\t}\n      }\n    }\n    //cout << pl.x << \":\" << pl.y << endl;\n    //cout << pr.x << \":\" << pr.y << endl;\n    d[pl.x][pl.y][pr.x][pr.y]=0;\n    P p,b;\n    p.r=pr;\n    p.l=pl;\n    p.cost=d[pl.x][pl.y][pr.x][pr.y];\n    queue<P> q;\n    q.push(p);\n    bool f = false;\n    while(!q.empty()){\n      p=q.front();q.pop();\n      pl=p.l;pr=p.r;\n      if(p.cost>d[pl.x][pl.y][pr.x][pr.y]) continue;\n      d[pl.x][pl.y][pr.x][pr.y]=p.cost;\n      //cout << pl.x<<\":\"<<pl.y<<\":\"<<pr.x<<\":\"<<pr.y<<\"/\"<<p.cost<<endl;\n      if(sl[pl.y][pl.x]=='%'&&sr[pr.y][pr.x]=='%'){\n\tf=true;\n\tbreak;\n      }else if(sl[pl.y][pl.x]=='%') continue;\n      else if(sr[pr.y][pr.x]=='%') continue;\n      \n      p.cost++;\n      int lx[]={1,-1,0,0};int ly[]={0,0,1,-1};\n      int rx[]={-1,1,0,0};int ry[]={0,0,1,-1};\n      for(i=0;i<4;i++){\n\tbl=pl;br=pr;\n\tbl.x+=lx[i];bl.y+=ly[i];\n\tbr.x+=rx[i];br.y+=ry[i];\n\n\t//cout << bl.x<<\":\"<<bl.y<<\":\"<<br.x<<\":\"<<br.y<<\"/\"<<p.cost<<endl;\n\t\n\tif(bl.x<0) bl.x=0;\n\telse if(bl.x>=w) bl.x=w-1;\n\tif(bl.y<0) bl.y=0;\n\telse if(bl.y>=h) bl.y=h-1;\n\n\tif(br.x<0) br.x=0;\n\telse if(br.x>=w) br.x=w-1;\n\tif(br.y<0) br.y=0;\n\telse if(br.y>=h) br.y=h-1;\n\n\tif(sl[bl.y][bl.x]=='#'){\n\t  bl.x-=lx[i];bl.y-=ly[i];\n\t}\n\tif(sr[br.y][br.x]=='#'){\n\t  br.x-=rx[i];br.y-=ry[i];\n\t}\n\tp.r=br;p.l=bl;\n\tq.push(p);\n      }\n    }\n    if(f) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    */\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <math.h>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 100000000;\ntypedef double D;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={-1, 0, 1, 0}, dy[4]={0, -1, 0, 1};\nusing namespace std;\n//typedef pair<int, int> P;\ntypedef struct P{\n\tint x, y;\n\tP (){}\n\tP(int x_, int y_){x = x_; y=y_;}\n} P;\nstruct State {\n\tP l, r;\n\tState(){}\n\tState (P L_, P R_) {l = L_; r = R_;}\n};\n\n/** Problem2153 : Mirror Cave **/\nint main()\n{\n\tint W, H;\n\twhile (cin>>W>>H, W||H) {\n\t\tState start;\n\t\tbool visL[W+2][H+2], visR[W+2][H+2];\n\t\tchar boardL[W+2][H+2], boardR[W+2][H+2];\n\t\t\n\t\trep(i, W+2) {\n\t\t\tboardL[i][0] = '#';\n\t\t\tboardL[i][H+1] = '#';\n\t\t\tboardR[i][0] = '#';\n\t\t\tboardR[i][H+1] = '#';\n\t\t}\n\t\trep(i, H) {\n\t\t\tboardL[0][i+1] = '#'; boardL[W+1][i+1] = '#';\n\t\t\trep(j, W) {\n\t\t\t\tchar c; cin>>c;\n\t\t\t\tboardL[j+1][i+1] = c;\n\t\t\t\tif (c=='L')\n\t\t\t\t\tstart.l = P(j+1, i+1);\n\t\t\t}\n\t\t\t\n\t\t\tboardR[0][i+1] = '#'; boardR[W+1][i+1] = '#';\n\t\t\trep(j, W) {\n\t\t\t\tchar c; cin>>c;\n\t\t\t\tboardR[j+1][i+1] = c;\n\t\t\t\tif (c=='R')\n\t\t\t\t\tstart.r = P(j+1, i+1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfill(visL[0], visL[0]+(W+2)*(H+2), false);\n\t\tfill(visR[0], visR[0]+(W+2)*(H+2), false);\n\t\t\n\t\tqueue<State> Q;\n\t\tQ.push(start);\n\t\tvisL[start.l.x][start.l.y]=true;\n\t\tvisR[start.r.x][start.r.y]=true;\n\t\t\n\t\twhile (Q.size()) {\n\t\t\tState s = Q.front(); Q.pop();\n\t\t\t/**\n\t\t\tcerr << s.l.x << \" \" << s.l.y << \" \" << s.r.x << \" \" << s.r.y << endl;\n\t\t\t\n\t\t\trep(y, H+2) {\n\t\t\t\trep(x, W+2) {\n\t\t\t\t\tif (x == s.l.x && y == s.l.y)\n\t\t\t\t\t\tcerr << \"X\" << \" \" ;\n\t\t\t\t\telse\n\t\t\t\t\t\tcerr << boardL[x][y] << \" \";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcerr << \"| \";\n\t\t\t\t\n\t\t\t\trep(x, W+2) {\n\t\t\t\t\tif (x == s.r.x && y == s.r.y)\n\t\t\t\t\t\tcerr << \"X\" << \" \" ;\n\t\t\t\t\telse\n\t\t\t\t\t\tcerr << boardR[x][y] << \" \";\n\t\t\t\t}\n\t\t\t\tcerr << endl;\n\t\t\t}\n\t\t\tcerr << endl; **/\n\t\t\t\n\t\t\t\n\t\t\tif (boardL[s.l.x][s.l.y]=='%' && boardR[s.r.x][s.r.y]=='%') {\n\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\tgoto end;\n\t\t\t} else if ((boardL[s.l.x][s.l.y]=='%') != (boardR[s.r.x][s.r.y]=='%')) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\trep(i, 4) {\n\t\t\t\tState ns = State(P(s.l.x+dx[i], s.l.y+dy[i]), P(s.r.x-dx[i], s.r.y+dy[i]));\n\t\t\t\tif (boardL[ns.l.x][ns.l.y] == '#')\n\t\t\t\t\tns.l = s.l;\n\t\t\t\tif (boardR[ns.r.x][ns.r.y] == '#')\n\t\t\t\t\tns.r = s.r;\n\t\t\t\t\n\t\t\t\tif (!visL[ns.l.x][ns.l.y] || !visR[ns.r.x][ns.r.y]) {\n\t\t\t\t\tQ.push(ns);\n\t\t\t\t\tvisL[ns.l.x][ns.l.y] = true;\n\t\t\t\t\tvisR[ns.r.x][ns.r.y] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << \"No\" << endl;\n\tend:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nbool vis[50][50][50][50];\nint H,W,dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nstring sl[50],sr[50];\nbool okl(int x,int y){\n\treturn 0<=x&&x<H&&0<=y&&y<W&&sl[x][y]!='#';\n}\nbool okr(int x,int y){\n\treturn 0<=x&&x<H&&0<=y&&y<W&&sr[x][y]!='#';\n}\nvoid bfs(int slx,int sly,int srx,int sry){\n\tqueue<PP> que;\n\tque.push(PP(P(slx,sly),P(srx,sry)));\n\tvis[slx][sly][srx][sry]=1;\n\twhile(!que.empty()){\n\t\tPP pp=que.front();\n\t\tque.pop();\n\t\tint lx=pp.fs.fs,ly=pp.fs.sc,rx=pp.sc.fs,ry=pp.sc.sc;\n\t\tif(sl[lx][ly]=='%'||sr[rx][ry]=='%') continue;\n\t\trep(di,4){\n\t\t\tint lnx=lx+dx[di],lny=ly+dy[di],rnx=rx+dx[di],rny=ry+dy[di];\n\t\t\tif(!okl(lnx,lny)) lnx=lx,lny=ly;\n\t\t\tif(!okr(rnx,rny)) rnx=rx,rny=ry;\n\t\t\tif(vis[lnx][lny][rnx][rny]) continue;\n\t\t\tvis[lnx][lny][rnx][rny]=1;\n\t\t\tque.push(PP(P(lnx,lny),P(rnx,rny)));\n\t\t}\n\t}\n\t\n}\nint main(){\n\twhile(true){\n\t\tcin>>W>>H;\n\t\tif(H==0) break;\n\t\trep(i,H){\n\t\t\tcin>>sl[i]>>sr[i];\n\t\t\treverse(all(sr[i]));\n\t\t}\n\t\tint lx,ly,rx,ry,ax,ay,bx,by;\n\t\trep(i,H) rep(j,W) if(sl[i][j]=='L') lx=i,ly=j;\n\t\trep(i,H) rep(j,W) if(sr[i][j]=='R') rx=i,ry=j;\n\t\trep(i,H) rep(j,W) if(sl[i][j]=='%') ax=i,ay=j;\n\t\trep(i,H) rep(j,W) if(sr[i][j]=='%') bx=i,by=j;\n\t\trep(i,H) rep(j,W) rep(k,H) rep(h,W) vis[i][j][k][h]=0;\n\t\tbfs(lx,ly,rx,ry);\n\t\tif(vis[ax][ay][bx][by]) puts(\"Yes\");\n\t\telse puts(\"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <math.h>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 100000000;\ntypedef double D;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={-1, 0, 1, 0}, dy[4]={0, -1, 0, 1};\nusing namespace std;\n//typedef pair<int, int> P;\n\n/** Problem2153 : Mirror Cave **/\n \ntypedef struct P{\n\tint x, y;\n\tP (){}\n\tP(int x_, int y_){x = x_; y=y_;}\n} P;\nstruct State {\n\tP l, r;\n\tState(){}\n\tState (P L_, P R_) {l = L_; r = R_;}\n};\n\n\nint main()\n{\n\tint W, H;\n\twhile (cin>>W>>H, W||H) {\n\t\tState start;\n\t\tbool vis[52][52][52][52] = {false};\n\t\tchar boardL[W+2][H+2], boardR[W+2][H+2];\n\t\t\n\t\trep(i, W+2) {\n\t\t\tboardL[i][0] = '#';\n\t\t\tboardL[i][H+1] = '#';\n\t\t\tboardR[i][0] = '#';\n\t\t\tboardR[i][H+1] = '#';\n\t\t}\n\t\trep(i, H) {\n\t\t\tboardL[0][i+1] = '#'; boardL[W+1][i+1] = '#';\n\t\t\trep(j, W) {\n\t\t\t\tchar c; cin>>c;\n\t\t\t\tboardL[j+1][i+1] = c;\n\t\t\t\tif (c=='L')\n\t\t\t\t\tstart.l = P(j+1, i+1);\n\t\t\t}\n\t\t\t\n\t\t\tboardR[0][i+1] = '#'; boardR[W+1][i+1] = '#';\n\t\t\trep(j, W) {\n\t\t\t\tchar c; cin>>c;\n\t\t\t\tboardR[j+1][i+1] = c;\n\t\t\t\tif (c=='R')\n\t\t\t\t\tstart.r = P(j+1, i+1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<State> Q;\n\t\tQ.push(start);\n\t\tvis[start.l.x][start.l.y][start.r.x][start.r.y]=true;\n\t\tbool flg=false;\n\t\t\n\t\twhile (Q.size()) {\n\t\t\tState s = Q.front(); Q.pop();\n\t\t\t\n\t\t\tif (boardL[s.l.x][s.l.y]=='%' && boardR[s.r.x][s.r.y]=='%') {\n\t\t\t\tflg = true;\n\t\t\t\tbreak;\n\t\t\t} else if ((boardL[s.l.x][s.l.y]=='%') != (boardR[s.r.x][s.r.y]=='%')) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\trep(i, 4) {\n\t\t\t\tState ns = State(P(s.l.x+dx[i], s.l.y+dy[i]), P(s.r.x-dx[i], s.r.y+dy[i]));\n\t\t\t\tif (boardL[ns.l.x][ns.l.y] == '#')\n\t\t\t\t\tns.l = s.l;\n\t\t\t\tif (boardR[ns.r.x][ns.r.y] == '#')\n\t\t\t\t\tns.r = s.r;\n\t\t\t\t\n\t\t\t\tif (!vis[ns.l.x][ns.l.y][ns.r.x][ns.r.y]) {\n\t\t\t\t\tQ.push(ns);\n\t\t\t\t\tvis[ns.l.x][ns.l.y][ns.r.x][ns.r.y] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (flg?\"Yes\":\"No\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct state{\n  int lx, ly, rx, ry, step;\n};\nint w, h;\nchar rmap[51][51], lmap[51][51];\nqueue<state> quu;\nint lx, ly, rx, ry;\nint d[51][51][51][51];\nint xmj[4] = {0, 0, 1, -1}, ymj[4] = {1, -1, 0, 0};\nint a[2], b[2];\n\nvoid lmove(int *x, int *y, int i){\n\n  int lnx = *x - xmj[i], lny = *y + ymj[i];\n\n  if(lnx < 0 || lnx >= w || lny < 0 || lny >= h) return;\n\n  if(lmap[lny][lnx] == '#') return;\n\n  *x = lnx;\n  *y = lny;\n\n\n}\n\nvoid rmove(int *x, int *y, int i){\n\n  int rnx = *x + xmj[i], rny = *y + ymj[i];\n\n  if(rnx < 0 || rnx >= w || rny < 0 || rny >= h) return;\n\n  if(rmap[rny][rnx] == '#') return;\n\n  *x = rnx;\n  *y = rny;\n\n\n}\n\nvoid wide(int lx, int ly, int rx, int ry){\n\n  memset(d,0,sizeof(d));\n  quu.push((state){lx,ly,rx,ry,1});\n  d[ly][lx][ry][ry] = 1;\n  while(!quu.empty()){\n\n    state st;\n    st = quu.front();\n    quu.pop();\n    // cout << st.lx << \" \" << st.ly << \" \" << st.rx << \" \" << st.ry << endl;\n    for(int i = 0; i < 4; i++){\n      int lnx = st.lx, lny = st.ly;\n      int rnx = st.rx, rny = st.ry;\n\n      lmove(&lnx,&lny,i);\n      rmove(&rnx,&rny,i);\n\n      if(rmap[rny][rnx] == '%' && lmap[lny][lnx] != '%') continue;\n      if(rmap[rny][rnx] != '%' && lmap[lny][lnx] == '%') continue;\n\n      if( d[lny][lnx][rny][rnx] == 0){\n\tquu.push((state){lnx,lny,rnx,rny,st.step+1});\n\td[lny][lnx][rny][rnx] = 1;\n      }\n      \n    }\n   \n  }\n  \n  if(d[a[0]][a[1]][b[0]][b[1]]) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n\n\n\n}\n\nint main(){\n\n\n  while(cin >> w >> h && (w || h)){\n\n    for(int i = 0; i < h*2; i++){\n      if(i % 2 == 0){\n\tfor(int j = 0; j < w; j++){\n\t  cin >> lmap[i/2][j];\t  \n\t  if(lmap[i/2][j] == 'L'){\n\t    lx = j;\n\t    ly = i/2;\n\t  }\n\t  if(lmap[i/2][j] == '%'){\n\t    a[0] = i/2;\n\t    a[1] = j;\n\t    //   cout << a[1] << \" \" << a[0] << endl; \n\t  }\n\t}\n      }else {\n\tfor(int j = 0; j < w; j++){\n\t  cin >> rmap[(i-1)/2][j];\n\t  if(rmap[(i-1)/2][j] == 'R'){\n\t    rx = j;\n\t    ry = (i-1)/2;\n\t  }\n\t  if(rmap[(i-1)/2][j] == '%'){\n\t    b[0] = (i-1)/2;\n\t    b[1] = j;\n\t    //      cout << b[1] << \" \" << b[0] << endl; \n\t  }\n\t  //  cout << rx << \" \" << ry << endl;\n\t  \n\t  // cout << i;\n\t}\n      }\n    }\n    wide(lx,ly,rx,ry);\n     \n  }\n    \n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<queue>\n#define MAX 60\nusing namespace std;\nstruct Point{int x,y;};\nstruct P{\n  Point l,r;\n  int cost;\n  bool operator<(const P &a)const{\n    return (l.x==a.l.x?\n\t    (l.y==a.l.y?\n\t     (r.x==a.r.x?\n\t      (r.y<a.r.y):r.x<a.r.x)\n\t     :l.y<a.l.y)\n\t    :l.x<a.l.x);\n  }\n};\nint main(){\n  int w,h;\n  while(cin>>w>>h,w||h){\n    int i,j,k;\n    int inf = 1<<20;\n    /*\n    int d[MAX+1][MAX+1][MAX+1][MAX+1];\n    fill(d[0][0][0],d[MAX][MAX][MAX],inf);\n    */\n    map<P,int> m;\n    string sr[60],sl[60];\n    for(i=0;i<h;i++){\n      cin >> sl[i] >> sr[i];\n    }\n    \n    Point pr,pl,br,bl;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(sl[i][j]=='L'){\n\t  pl.x=j;pl.y=i;\n\t}\n\tif(sr[i][j]=='R'){\n\t  pr.x=j;pr.y=i;\n\t}\n      }\n    }\n    //cout << pl.x << \":\" << pl.y << endl;\n    //cout << pr.x << \":\" << pr.y << endl;\n    //d[pl.x][pl.y][pr.x][pr.y]=0\n    P p,b;\n    p.r=pr;\n    p.l=pl;\n    p.cost=0;\n    m[p]=p.cost;\n    queue<P> q;\n    q.push(p);\n    bool f = false;\n    while(!q.empty()){\n      p=q.front();q.pop();\n      pl=p.l;pr=p.r;\n      if(m.find(p)!=m.end())\n\tif(p.cost>m[p]) continue;\n      m[p]=p.cost;\n      //cout << pl.x<<\":\"<<pl.y<<\":\"<<pr.x<<\":\"<<pr.y<<\"/\"<<p.cost<<endl;\n      if(sl[pl.y][pl.x]=='%'&&sr[pr.y][pr.x]=='%'){\n\tf=true;\n\tbreak;\n      }else if(sl[pl.y][pl.x]=='%') continue;\n      else if(sr[pr.y][pr.x]=='%') continue;\n      \n      p.cost++;\n      int lx[]={1,-1,0,0};int ly[]={0,0,1,-1};\n      int rx[]={-1,1,0,0};int ry[]={0,0,1,-1};\n      for(i=0;i<4;i++){\n\tbl=pl;br=pr;\n\tbl.x+=lx[i];bl.y+=ly[i];\n\tbr.x+=rx[i];br.y+=ry[i];\n\n\t//cout << bl.x<<\":\"<<bl.y<<\":\"<<br.x<<\":\"<<br.y<<\"/\"<<p.cost<<endl;\n\t\n\tif(bl.x<0) bl.x=0;\n\telse if(bl.x>=w) bl.x=w-1;\n\tif(bl.y<0) bl.y=0;\n\telse if(bl.y>=h) bl.y=h-1;\n\n\tif(br.x<0) br.x=0;\n\telse if(br.x>=w) br.x=w-1;\n\tif(br.y<0) br.y=0;\n\telse if(br.y>=h) br.y=h-1;\n\n\tif(sl[bl.y][bl.x]=='#'){\n\t  bl.x-=lx[i];bl.y-=ly[i];\n\t}\n\tif(sr[br.y][br.x]=='#'){\n\t  br.x-=rx[i];br.y-=ry[i];\n\t}\n\tp.r=br;p.l=bl;\n\tq.push(p);\n\t//m[p]=p.cost;\n      }\n    }\n    if(f) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define fi first\n#define se second\n#define mk make_pair\nusing namespace std;\nstring s1[50],s2[50];\nint dx1[]={1,-1,0,0,},dy1[]={0,0,1,-1};\nint dx2[]={-1,1,0,0,},dy2[]={0,0,1,-1};\nint w,h,gx1,gx2,gy1,gy2;\nset<pair<pair<int,int>,pair<int,int> > >s;\nqueue<pair<pair<int,int>,pair<int,int> > >q;\nbool bfs(int x1,int y1,int x2,int y2){\n  queue<int>q;\n  q.push(x1+y1*100+x2*10000+y2*1000000);\n  while(!q.empty()){\n    int p=q.front();q.pop();\n    x1=p%100;y1=p%10000/100;\n    x2=p%1000000/10000;y2=p/1000000;\n    for(int i=0;i<4;i++){\n      int x3=x1+dx1[i],y3=y1+dy1[i];\n      int x4=x2+dx2[i],y4=y2+dy2[i];\n      if(x3>=0&&x4>=0&&y3>=0&&y4>=0)\n        if(x3<w&&x4<w&&y3<h&&y4<h){\n          if(s1[y3][x3]=='#')y3=y1,x3=x1;\n          if(s2[y4][x4]=='#')y4=y2,x4=x2;\n          if(x1==gx1&&y1==gy1&&x2==gx2&&y2==gy2)return 1;\n          if(!(x3==gx1&&y3==gy1&&(x4!=gx2||y4!=gy2)))\n          if(!((x3!=gx1||y3!=gy1)&&x4==gx2&&y4==gy2))\n          if(!s.count(mk(mk(x3,y3),mk(x4,y4)))){\n            s.insert(mk(mk(x3,y3),mk(x4,y4)));\n            q.push(x3+y3*100+x4*10000+y4*1000000);\n          }\n        }\n      }\n    }\n    return 0;\n}\nbool dfs(int x1,int y1,int x2,int y2,int d){\n  //cout<<d<<endl;\n    if(x1==gx1&&y1==gy1&&(x2!=gx2||y2!=gy2))return 0;\n    if((x1!=gx1||y1!=gy1)&&x2==gx2&&y2==gy2)return 0;\n    if(x1==gx1&&y1==gy1&&x2==gx2&&y2==gy2)return 1;\n    if(d<9000)for(int i=0;i<4;i++){\n    int x3=x1+dx1[i],y3=y1+dy1[i];\n    int x4=x2+dx2[i],y4=y2+dy2[i];\n    if(x3>=0&&x4>=0&&y3>=0&&y4>=0)\n      if(x3<w&&x4<w&&y3<h&&y4<h){\n        if(s1[y3][x3]=='#')y3=y1,x3=x1;\n        if(s2[y4][x4]=='#')y4=y2,x4=x2;\n        if(!s.count(mk(mk(x3,y3),mk(x4,y4)))){\n          s.insert(mk(mk(x3,y3),mk(x4,y4)));\n          if(dfs(x3,y3,x4,y4,d+1))return 1;\n        }\n      }\n    }\n    else q.push(mk(mk(x1,y1),mk(x2,y2)));\n    if(d==0&&q.size()){\n      while(!q.empty()){\n        pair<pair<int,int>,pair<int,int> >pp=q.front();q.pop();\n        if(bfs(pp.fi.fi,pp.fi.se,pp.se.fi,pp.se.se))return 1;\n      }\n    }\n    return 0;\n}\nint main(){\n  int x1,y1,x2,y2;\n  while(cin>>w>>h,w){\n    s.clear();\n    r(i,h)cin>>s1[i]>>s2[i];\n    r(i,h)r(j,w){\n      if(s1[i][j]=='L')x1=j,y1=i;\n      if(s2[i][j]=='R')x2=j,y2=i;\n      if(s1[i][j]=='%')gx1=j,gy1=i;\n      if(s2[i][j]=='%')gx2=j,gy2=i;\n    }\n    s.insert(mk(mk(x1,y1),mk(x2,y2)));\n    if(dfs(x1,y1,x2,y2,0))cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n    while(!q.empty())q.pop();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<numeric>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define rp(i,c) rep(i,(c).size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e12,EPS=1e-9;\n\nint dy[]={-1,0,1,0},dx[]={0,-1,0,1};\nint w,h;\nchar cl[50][51],cr[50][51];\nbool v[2500][2500];\n\nint main()\n{\n\twhile(scanf(\"%d%d\",&w,&h),w)\n\t{\n\t\trep(i,h)scanf(\"%s%s\",cl[i],cr[i]);\n\t\tint ly,lx,ry,rx;\n\t\trep(i,h)rep(j,w)\n\t\t{\n\t\t\tif(cl[i][j]=='L')ly=i,lx=j;\n\t\t\tif(cr[i][j]=='R')ry=i,rx=j;\n\t\t}\n\t\trep(i,h*w)rep(j,h*w)v[i][j]=0;\n\t\tqueue<int> Q;\n\t\tQ.push(ly*w+lx); Q.push(ry*w+rx);\n\t\twhile(!Q.empty())\n\t\t{\n\t\t\tly=Q.front()/w; lx=Q.front()%w; Q.pop();\n\t\t\try=Q.front()/w; rx=Q.front()%w; Q.pop();\n\t\t\tif(cl[ly][lx]=='%'&&cr[ry][rx]=='%')\n\t\t\t{\n\t\t\t\tputs(\"Yes\"); goto END;\n\t\t\t}\n\t\t\t\n\t\t\trep(d,4)\n\t\t\t{\n\t\t\t\tint lly=ly+dy[d],llx=lx+dx[d],rry=ry+dy[d],rrx=rx-dx[d];\n\t\t\t\tif(lly<0||lly>=h||llx<0||llx>=w||cl[lly][llx]=='#')lly=ly,llx=lx;\n\t\t\t\tif(rry<0||rry>=h||rrx<0||rrx>=w||cr[rry][rrx]=='#')rry=ry,rrx=rx;\n\t\t\t\t\n\t\t\t\tif(v[lly*w+llx][rry*w+rrx])continue;\n\t\t\t\tif((cl[lly][llx]=='%')^cr[rry][rrx]=='%')continue;\n\t\t\t\tv[lly*w+llx][rry*w+rrx]=1;\n\t\t\t\tQ.push(lly*w+llx); Q.push(rry*w+rrx);\n\t\t\t}\n\t\t}\n\t\tputs(\"No\"); END:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nint w, h;\nstring sl[50], sr[50];\nbool vis[2500][2500];\nP ls, rs, lg, rg;\nint dxl[] = {1, 0, -1, 0};\nint dxr[] = {-1, 0, 1, 0};\nint dy[] = {0, 1, 0, -1};\n\nbool range(int x, int y) {\n    return 0 <= x && x < w && 0 <= y && y < h;\n}\n\nbool dfs(P l, P r) {\n    if (l == lg && r == rg) return true;\n    else if (l == lg || r == rg) return false;\n\n    vis[l.fi * 50 + l.se][r.fi * 50 + r.se] = true;\n    bool ok = false;\n    rep(i, 4) {\n        int lx = l.se + dxl[i], ly = l.fi + dy[i];\n        if (!range(lx, ly) || (range(lx, ly) && sl[ly][lx] == '#')) lx = l.se, ly = l.fi;\n        int rx = r.se + dxr[i], ry = r.fi + dy[i];\n        if (!range(rx, ry) || (range(lx, ly) && sr[ry][rx] == '#')) rx = r.se, ry = r.fi;\n        if (!vis[ly * 50 + lx][ry * 50 + rx]) {\n            ok |= dfs(P(ly, lx), P(ry, rx));\n        }\n    }\n    return ok;\n}\n\nint main(){\n    cin.sync_with_stdio(false);\n    while(cin >> w >> h, w | h) {\n        memset(vis, 0, sizeof(vis));\n\n        rep(i, h) {\n            cin >> sl[i] >> sr[i];\n            rep(j, w) {\n                if (sl[i][j] == 'L') ls = P(i, j);\n                if (sr[i][j] == 'R') rs = P(i, j);\n                if (sl[i][j] == '%') lg = P(i, j);\n                if (sr[i][j] == '%') rg = P(i, j);\n            }\n        }\n\n        cout << (dfs(ls, rs) ? \"Yes\" : \"No\") << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> stat;\n\nint w, h;\nbool vis[51][51][51][51];\npii ls, lg, rs, rg;\nstat start, goal;\n\nint dx[]={0, 0, 1, -1}, dy[]={1, -1, 0, 0};\n\nbool border(pii p){\n\t\n\treturn 0<=p.first&&p.first<w&&0<=p.second&&p.second<h;\n}\n\nstring solve(const vector<string> &left, const vector<string> &right){\n\t\n\tstart = make_pair(ls, rs);\n\tgoal = make_pair(lg, rg);\n\t\n\tqueue<stat> qu;\n\tmemset(vis, 0, sizeof(vis));\n\t\n\tvis[ls.first][ls.second][rs.first][rs.second] = true;\n\tqu.push(start);\n\t\n\twhile(!qu.empty()){\n\t\n\t\tpii lnx, rnx, lnw, rnw;\n\t\tstat now = qu.front();\n\t\tlnw = now.first;\n\t\trnw = now.second;\n\t\tqu.pop();\n\t\t\n\t\tfor(int i=0; i<4; ++i){\n\t\t\t\t\n\t\t\tlnx = make_pair(lnw.first + dx[i], \n\t\t\t\t\t\t\tlnw.second + dy[i]);\n\t\t\t\n\t\t\trnx = make_pair(rnw.first - dx[i], \n\t\t\t\t\t\t\trnw.second + dy[i]);\n\t\t\t\n\t\t\tif(!border(lnx)||left[lnx.second][lnx.first]=='#')\n\t\t\t\tlnx = lnw;\n\t\t\t\n\t\t\tif(!border(rnx)||right[rnx.second][rnx.first]=='#')\n\t\t\t\trnx = rnw;\n\t\t\t\n\t\t\tstat nx = make_pair(lnx, rnx);\n\t\t\t\n\t\t\tif(nx == goal)\n\t\t\t\treturn \"Yes\";\n\t\t\t\n\t\t\tif(!vis[lnx.first][lnx.second][rnx.first][rnx.second]){\n\t\t\t\t\n\t\t\t\tvis[lnx.first][lnx.second][rnx.first][rnx.second] = true;\n\t\t\t\tqu.push(nx);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn \"No\";\n}\n\t\nint main(){\n\t\n\twhile(cin>>w>>h, (w||h)){\n\t\t\n\t\tvector<string> left, right;\n\t\t\n\t\tfor(int i=0; i<h; ++i){\n\t\t\t\n\t\t\tstring l, r;\n\t\t\tcin >> l >> r;\n\t\t\t\n\t\t\tleft.push_back(l);\n\t\t\tright.push_back(r);\n\t\t}\n\t\t\n\t\tfor(int y=0; y<h; ++y){\n\t\t\tfor(int x=0; x<w; ++x){\n\t\t\t\n\t\t\t\tif(left[y][x] == 'L')\n\t\t\t\t\tls = make_pair(x, y);\n\t\t\t\tif(left[y][x] == '%')\n\t\t\t\t\tlg = make_pair(x, y);\n\t\t\t\tif(right[y][x] == 'R')\n\t\t\t\t\trs = make_pair(x, y);\n\t\t\t\tif(right[y][x] == '%')\n\t\t\t\t\trg = make_pair(x, y);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout <<\tsolve(left, right) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint w, h;\nchar l[52][52], r[52][52];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint lsx, lsy, rsx, rsy, lgx, lgy, rgx, rgy;\nbool ischecked[52][52][52][52];\n\nbool solve(int lx, int ly, int rx, int ry){\n    // cout << lx << \" \" << ly << \" \" << rx << \" \" << ry << endl;\n    // ischecked[lx][ly][rx][ry] = true;\n    // if(lx == lgx && ly == lgy && rx == rgx && ry == rgy) return true;\n    // if((lx == lgx && ly == lgy) || (rx == rgx && ry == rgy)) return false;\n    queue<int> rxqu, ryqu, lxqu, lyqu;\n    rxqu.push(rx);\n    ryqu.push(ry);\n    lxqu.push(lx);\n    lyqu.push(ly);\n    while(!rxqu.empty()){\n        lx = lxqu.front();\n        ly = lyqu.front();\n        rx = rxqu.front();\n        ry = ryqu.front();\n        lxqu.pop();\n        lyqu.pop();\n        rxqu.pop();\n        ryqu.pop();\n        if(ischecked[lx][ly][rx][ry]) continue;\n        ischecked[lx][ly][rx][ry] = true;\n        for(int i = 0; i < 4; i++){\n            int nlx = lx + dx[i], nly = ly + dy[i];\n            int nrx = rx + dx[i], nry = ry - dy[i];\n            if(nlx < 0 || nlx >= h || nly < 0 || nly >= w){\n                nlx = lx;\n                nly = ly;\n            }\n            if(nrx < 0 || nrx >= h || nry < 0 || nry >= w){\n                nrx = rx;\n                nry = ry;\n            }\n            if(l[nlx][nly] == '#'){\n                nlx = lx;\n                nly = ly;\n            }\n            if(r[nrx][nry] == '#'){\n                nrx = rx;\n                nry = ry;\n            }\n            if((nrx == rx && nry == ry && nlx == lx && nly == ly )|| ischecked[nlx][nly][nrx][nry]) continue;\n            rxqu.push(nrx);\n            ryqu.push(nry);\n            lxqu.push(nlx);\n            lyqu.push(nly);\n            // ischecked[nlx][nly][nrx][nry] = false;\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    while(1){\n        cin >> w >> h;\n        if(w == 0 && h == 0) break;\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin >> l[i][j];\n            }\n            for(int j = 0; j < w; j++){\n                cin >> r[i][j];\n            }\n        }\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                for(int k = 0; k < h; k++){\n                    for(int l = 0; l < w; l++){\n                        ischecked[i][j][k][l] = false;\n                    }\n                }\n                if(l[i][j] == 'L'){\n                    lsx = i;\n                    lsy = j;\n                }\n                if(l[i][j] == '%'){\n                    lgx = i;\n                    lgy = j;\n                }\n                if(r[i][j] == 'R'){\n                    rsx = i;\n                    rsy = j;\n                }\n                if(r[i][j] == '%'){\n                    rgx = i;\n                    rgy = j;\n                }\n            }\n        }\n        // ischecked[lsx][lsy][rsx][rsy] = true;\n        if(solve(lsx, lsy, rsx, rsy)) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nstring RenR[50],LinR[50];\nbool memo[50][50][50][50];\nstring ans;\nint h,w;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nclass S{\npublic:\n    int rx,ry,lx,ly;\n    S(int lx,int ly,int rx,int ry):lx(lx),ly(ly),rx(rx),ry(ry){}\n}; \n\nint main()\n{\n  int ri,rj,li,lj;\n  while(1){\n    cin>>w>>h;\n    if(w+h==0)break;\n\n    for(int i=0;i<50;i++){\n      for(int j=0;j<50;j++){\n\tfor(int k=0;k<50;k++){\n\t  for(int l=0;l<50;l++)memo[i][j][k][l]=false;\n\t}\n      }\n    }\n\n    for(int i=0;i<h;i++){\n      cin>>LinR[i];\n      for(int j=0;j<w;j++){\n\tif(LinR[i][j]=='L'){\n\t  li=i;lj=j;\n\t  break;\n\t}\n      }\n      cin>>RenR[i];\n      for(int j=0;j<w;j++){\n\tif(RenR[i][j]=='R'){\n\t  ri=i;rj=j;\n\t  break;\n\t}\n      }\n    }\n    queue<S> Q;\n    Q.push(S(lj,li,rj,ri));\n    ans=\"No\";\n    while(!Q.empty()){\n      S s=Q.front();Q.pop();\n      if(RenR[s.ry][s.rx]=='%' && LinR[s.ly][s.lx]=='%'){\n        ans=\"Yes\";\n\tbreak;\n      }\n      if(RenR[s.ry][s.rx]=='%' || LinR[s.ly][s.lx]=='%')continue;\n      if(memo[s.lx][s.ly][s.rx][s.ry])continue;\n      memo[s.lx][s.ly][s.rx][s.ry]=true;\n\n      for(int k=0;k<4;k++){\n\tint rx=s.rx+dx[k],ry=s.ry-dy[k];\n        if(rx<0 || ry<0 || rx>=w || ry>=h){\n\t  rx=s.rx;\n\t  ry=s.ry;\n\t}\n        if(RenR[ry][rx]=='#'){\n\t  rx=s.rx;\n\t  ry=s.ry;\n\t}\n\tint lx=s.lx+dx[(k+2)%4],ly=s.ly+dy[(k+2)%4];\n        if(lx<0 || ly<0 || lx>=w || ly>=h){\n\t  lx=s.lx;\n\t  ly=s.ly;\n\t}\n\tif(LinR[ly][lx]=='#'){\n\t  lx=s.lx;\n\t  ly=s.ly;\n\t}\n\tQ.push(S(lx,ly,rx,ry));\n      }\n    }\n    cout<<ans<<endl;\t\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int lim = 51;\ntypedef pair<int, int> P;\n\nstruct Point{\n    int ly, lx, ry, rx;\n};\n\nint W, H;\nbool isIn(int y, int x){\n    return (0 <= y && y < H && 0 <= x && x < W);\n}\n\nchar R[lim][lim], L[lim][lim];\nbool visited[lim][lim][lim][lim];\n\nbool solve(){\n    Point start;\n    for(int y=0; y<H; y++){\n        for(int x=0; x<W; x++){\n            cin >> L[y][x];\n            if(L[y][x] == 'L')start.ly = y, start.lx = x;\n        }\n        for(int x=0; x<W; x++){\n            cin >> R[y][x];\n            if(R[y][x] == 'R') start.ry = y, start.rx = x;\n        }\n    }\n\n    for(int i=0; i<lim; i++)for(int j=0; j<lim; j++)for(int k=0; k<lim; k++)for(int l=0; l<lim; l++) visited[i][j][k][l] = false;\n\n    queue<Point> que;\n    que.push(start);\n\n    while(que.size()){\n        Point c = que.front();\n        que.pop();\n        if(visited[c.ly][c.lx][c.ry][c.rx]) continue;\n        visited[c.ly][c.lx][c.ry][c.rx] = true;\n\n        bool flag1 = (L[c.ly][c.lx] == '%');\n        bool flag2 = (R[c.ry][c.rx] == '%');\n        if(flag1 & flag2) return true;\n        else if(flag1 || flag2) continue;\n\n        P dL[4] = {P(1, 0), P(-1, 0), P(0, 1), P(0, -1)};\n        P dR[4] = {P(1, 0), P(-1, 0), P(0, -1), P(0, 1)};\n        for(int i=0; i<4; i++){\n            Point n = Point{c.ly + dL[i].first, c.lx + dL[i].second, c.ry + dR[i].first, c.rx + dR[i].second};\n            bool ok1 = (isIn(n.ly, n.lx) && L[n.ly][n.lx] != '#');\n            bool ok2 = (isIn(n.ry, n.rx) && R[n.ry][n.rx] != '#');\n\n            if(ok1 && ok2) que.push(n);\n            else if(!ok1 && ok2) que.push(Point{c.ly, c.lx, n.ry, n.rx});\n            else if(ok1 && !ok2) que.push(Point{n.ly, n.lx, c.ry, c.rx});\n        }\n    }\n    return false;\n}\n\n\nint main(){\n    while(true){\n        cin >> W >> H;\n        if(W == 0 && H == 0) return 0;\n        if(solve()) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define pb push_back\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nconst P dx[4] = {P(0,0),P(0,0),P(-1,1),P(1,-1)};\nconst P dy[4] = {P(1,1),P(-1,-1),P(0,0),P(0,0)};\nint main(){\n  int H,W;\n  while(cin >> W >> H && H+W){\n    char L_cmap[H+1][W+1],R_cmap[H+1][W+1];\n    bool bmap[H+1][W+1][H+1][W+1];\n    P Ls,Rs,Lg,Rg;\n    rep(i,H)\n      rep(j,W)\n        rep(k,H)\n          rep(l,W)\n            bmap[i][j][k][l] = false;\n\n    rep(i,H){\n      string s;\n      cin >> s;\n      rep(j,W){\n\tL_cmap[i][j] = s[j];\n\tif(s[j] == 'L')Ls = P(j,i);\n\tif(s[j] == '%')Lg = P(j,i);\n      }\n      cin >> s;\n      rep(j,W){\n\tR_cmap[i][j] = s[j];\n\tif(s[j] == 'R')Rs = P(j,i);\n\tif(s[j] == '%')Rg = P(j,i);\n      }\n    }\n\n    queue<PP> que;\n    que.push(PP(Ls,Rs));\n    bmap[Ls.F][Ls.S][Rs.F][Rs.S] = true;\n    bool fin = false;\n    while(!que.empty())\n      {\n\tPP pp = que.front(); que.pop();\n\tif(pp.F == Lg && pp.S == Rg){\n\t  fin = true;\n\t  cout << \"Yes\" << endl;\n\t  break;\n\t}\n\tif(pp.F == Lg || pp.S == Rg)continue;\n\n\trep(i,4){\n\t  int L_nx = pp.F.F+dx[i].F,L_ny = pp.F.S+dy[i].F;\n\t  int R_nx = pp.S.F+dx[i].S,R_ny = pp.S.S+dy[i].S;\n\t  if(!(0<= L_nx & L_nx < W && 0<= L_ny && L_ny < H) || L_cmap[L_ny][L_nx] == '#'){\n\t    L_nx = pp.F.F,L_ny = pp.F.S;\n\t  }\n\t  if(!(0<= R_nx & R_nx < W && 0<= R_ny && R_ny < H) || R_cmap[R_ny][R_nx] == '#'){\n\t    R_nx = pp.S.F,R_ny = pp.S.S;\n\t  }\n\t  if(bmap[L_nx][L_ny][R_nx][R_ny])continue;\n\t  bmap[L_nx][L_ny][R_nx][R_ny] = true;\n\t  que.push(insert(L_nx,L_ny,R_nx,R_ny));\n\t}\n      }\n    if(!fin)cout << \"No\" << endl;\n    \n  }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <memory.h>\n#include <queue>\n\nusing namespace std;\n\nint maxw,maxh;\nint lsx,lsy;\nint rsx,rsy;\n\nconst int dxl[] = {1,0,-1,0};\nconst int dxr[] = {-1,0,1,0};\nconst int dyl[] = {0,1,0,-1};\nconst int dyr[] = {0,1,0,-1};\n\ntypedef pair<int,int> PP;\ntypedef pair< PP,PP > P;\n\nbool visited[55][55][55][55] = {};\n\nint main(void)\n{\n\twhile(1)\n\t{\n\t\tchar fieldl[55][55];\n\t\tchar fieldr[55][55];\n\t\tmemset(visited,0,sizeof(visited));\n\t\tmemset(fieldl,0,sizeof(fieldl));\n\t\tmemset(fieldr,0,sizeof(fieldr));\n\t\tcin >> maxw >> maxh;\n\t\tif(maxw==0&&maxh==0)\n\t\t\treturn 0;\n\t\tfor(int y=1;y<=maxh;++y){\n\t\t\tfor(int x=1;x<=maxw;++x){\n\t\t\t\tcin >> fieldl[y][x];\n\t\t\t\tif(fieldl[y][x] == 'L'){\n\t\t\t\t\tlsy = y;lsx = x;\n\t\t\t\t\tfieldl[y][x] = '.';\n\t\t\t\t}\n\t\t\t\tif(fieldl[y][x] == 'R'){\n\t\t\t\t\trsy = y;rsx = x;\n\t\t\t\t\tfieldl[y][x] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int x=1;x<=maxw;++x){\n\t\t\t\tcin >> fieldr[y][x];\n\t\t\t\tif(fieldr[y][x] == 'L'){\n\t\t\t\t\tlsy = y;lsx = x;\n\t\t\t\t\tfieldr[y][x] = '.';\n\t\t\t\t}\n\t\t\t\tif(fieldr[y][x] == 'R'){\n\t\t\t\t\trsy = y;rsx = x;\n\t\t\t\t\tfieldr[y][x] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqueue<P> q;\n\t\tbool isGoal = false;\n\t\tq.push(P(PP(lsy,lsx),PP(rsy,rsx)));\n\t\tvisited[lsy][lsx][rsy][rsx] = true;\n\t\twhile(!q.empty()){\n\t\t\tP p = q.front();q.pop();\n\t\t\tvisited[p.first.first][p.first.second][p.second.first][p.second.second] = true;\n\t\t\tfor(int i=0;i<4;++i){\n\t\t\t\tbool f=false;\n\t\t\t\tPP tol = PP(p.first.first+dyl[i],p.first.second+dxl[i]);//y,x\n\t\t\t\tPP tor = PP(p.second.first+dyr[i],p.second.second+dxr[i]);//y,x\n\t\t\t\tif(visited[tol.first][tol.second][tor.first][tor.second])\n\t\t\t\t\tcontinue;\n\t\t\t\tif(fieldl[tol.first][tol.second] == '%' && fieldr[tor.first][tor.second] == '%'){\n\t\t\t\t\tisGoal = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(fieldl[tol.first][tol.second] == '%' || fieldr[tor.first][tor.second] == '%')\n\t\t\t\t\tcontinue;\n\t\t\t\tPP l = PP(p.first.first,p.first.second);\n\t\t\t\tPP r = PP(p.second.first,p.second.second);\n\t\t\t\tif(fieldl[tol.first][tol.second] == '.'){\n\t\t\t\t\tl = tol;\n\t\t\t\t\tf=true;\n\t\t\t\t}\n\t\t\t\tif(fieldr[tor.first][tor.second] == '.'){\n\t\t\t\t\tr = tor;\n\t\t\t\t\tf=true;\n\t\t\t\t}\n\t\t\t\tif(!f)\n\t\t\t\t\tcontinue;\n\t\t\t\tq.push(P(l,r));\n\t\t\t}\n\t\t\tif(isGoal)\n\t\t\t\tbreak;\n\t\t}\n\t\t(isGoal?cout<<\"Yes\"<<endl:cout<<\"No\"<<endl);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<ctime>\n#include<climits>\n#include<queue>\n#include<fstream>\n#include<deque>\n#include<iomanip>\n#include<list>\n#include<stack>\n#include<sstream>\n#include<string>\n#include<cctype>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<cstring>\n#include<iomanip>\n#include<map>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS 1e-10\n#define F first\n#define S second\n#define all(n) n.begin(),n.end()\n#define pb push_back\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define INF (1<<27)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nconst P dx[4] = {P(0,0),P(0,0),P(1,-1),P(-1,1)};\nconst P dy[4] = {P(1,1),P(-1,-1),P(0,0),P(0,0)};\n\n\nint H,W;\nchar L_cmap[55][55],R_cmap[55][55];\nbool L_used[55][55],R_used[55][55];\nP Ls,Rs,Lg,Rg;\nbool fin;\n\nvoid dfs(PP pp){\n  if(fin)return;\n      if(pp.F == Lg && pp.S == Rg){\n\tcout << \"Yes\" << endl;\n\tfin = true;\n\treturn;\n      }\n      //cout << \"pp.F = \" << pp.F.F << \",\" << pp.F.S << \" pp.S = \" << pp.S.F << \",\" << pp.S.S << endl;\n      rep(i,4){\n\tint L_nx = pp.F.F + dx[i].F,L_ny = pp.F.S + dy[i].F;\n\tint R_nx = pp.S.F + dx[i].S ,R_ny = pp.S.S + dy[i].S;\n\t//cout << \"First next L = \" << L_nx << \",\" << L_ny << \" Pre next R = \" << R_nx << \",\" << R_ny << endl;\n\n\n \tif(!(0<=L_nx && L_nx <W && 0<= R_nx && R_nx <W && 0<= L_ny && L_ny <H && 0<= R_ny && R_ny < H))continue;\n\tif(L_cmap[L_ny][L_nx] != '#' && L_used[L_ny][L_nx])continue;\n\tif(R_cmap[R_ny][R_nx] != '#' && R_used[R_ny][R_nx])continue;\n\tif(L_cmap[L_ny][L_nx] == '#' && R_cmap[R_ny][R_nx] == '#')continue;\n\n\t//cout << \"next L = \" << L_nx << \",\" << L_ny << \" Pre next R = \" << R_nx << \",\" << R_ny << endl;\n\tif(L_cmap[L_ny][L_nx] == '#')L_nx = pp.F.F,L_ny = pp.F.S;\n\tif(R_cmap[R_ny][R_nx] == '#')R_nx = pp.S.F,R_ny = pp.S.S;\n\t\n\tR_used[R_ny][R_nx] = L_used[L_ny][L_nx] = true;\n\t//que.push(insert(L_nx,L_ny,R_nx,R_ny));\n\tdfs(insert(L_nx,L_ny,R_nx,R_ny));\n\tR_used[R_ny][R_nx] = L_used[L_ny][L_nx] = false;\n      }\n      \n}\n   \n\n\nint main(){\n  clock_t start,end;\n  //start = clock();\n  while(cin >> W >> H && H+W){\n    fin = false;\n    rep(i,H){\n      string s;\n      cin >> s;\n      rep(j,W){\n\tL_cmap[i][j] = s[j],L_used[i][j] = false;\n\tif(s[j] == 'L')\n\t  Ls = P(j,i);\n\tif(s[j] == '%')\n\t  Lg = P(j,i);\n      }\n      cin >> s;\n      rep(j,W){\n\tR_cmap[i][j] = s[j],R_used[i][j] = false;\n\tif(s[j] == 'R')\n\t  Rs = P(j,i);\n\tif(s[j] == '%')\n\t  Rg = P(j,i);\n      }\n    }\n    //cout<< \"Ls = \" << Ls.F << \" \" << Ls.S << \", Lg = \" << Lg.F << \" \" << Lg.S << \", Rs = \" << Rs.F << \" \" << Rs.S << \", Rg = \" << Rg.F << \" \" << Rg.S << endl; \n    //rep(i,4){\n    //rep(j,51)rep(k,51)R_used[j][k] = L_used[j][k] = false;\n      //if(!(0<= Ls.F+dx[i].F && Ls.F+dx[i].F < W && 0<= Ls.S+dy[i].F && Ls.S+dy[i].F < H  && 0<= Rs.F+dx[i].S && Rs.F+dx[i].S < W  && 0<= Rs.S+dy[i].S && Rs.S+dy[i].S < H))continue;\n      //cout << Ls.F+dx[i].F << \" \" << Ls.S+dy[i].F<< \" \"<< Rs.F+dx[i].S<< \" \" << Rs.S+dy[i].S << endl;\n      //dfs(insert(Ls.F+dx[i].F,Ls.S+dy[i].F,Rs.F+dx[i].S,Rs.S+dy[i].S));\n      //cout << \"----------\" << endl;\n      //}    \n    L_used[Ls.S][Ls.F] = true,R_used[Rs.S][Rs.F] = true;\n    dfs(insert(Ls.F,Ls.S,Rs.F,Rs.S));\n\n    if(!fin)cout << \"No\" << endl;\n\n  }\n  //end = clock();\n  //cout << setiosflags(ios::fixed) << setprecision(10) << (double)(end-start)/CLOCKS_PER_SEC << endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, k, n) for (int i = (int)(k); i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rREP(i, k, n) for (int i = (int)(n)-1; i >= k; i--)\n\n#define debug(x) cerr << #x << \": \" << x << endl;\n\n#define fi first\n#define se second\n\n#define vi vector<int>\n#define pii pair<int, int>\n#define pb push_back\n#define mp make_pair\n\n#define pcnt __builtin_popcount\n\ntypedef long long ll;\n\nconst int    inf = 100100100;\nconst int    MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\nconst int    dx[4] = { 0, 1, 0, -1 };\nconst int    dy[4] = { 1, 0, -1, 0 };\n\nstruct POINT {\n    int lx;\n    int ly;\n    int rx;\n    int ry;\n};\n\nbool ul[55][55] = {};\nbool ur[55][55] = {};\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n//    ifstream in(\"./input.txt\");\n//    cin.rdbuf(in.rdbuf());\n    int    w, h;\n    string ML[55], MR[55];\n    int slx,sly,srx,sry;\n    while (cin >> w >> h, w) {\n        memset(ul,0,sizeof(ul));\n        memset(ur,0,sizeof(ur));\n        rep(y, h) cin >> ML[y] >> MR[y];\n        rep(y,h) rep(x,w){\n            if(ML[y][x] == 'L') slx = x,sly = y;\n            if(MR[y][x] == 'R') srx = x,sry = y;\n        }\n        queue<POINT> que;\n        que.push(POINT{slx, sly, srx, sry});\n\n        bool flag = false;\n        while (!que.empty()) {\n            POINT p = que.front();\n            que.pop();\n            if (ul[p.lx][p.ly] && ur[p.rx][p.ry]) continue;\n            rep(i, 4) {\n                int nlx = p.lx + dx[i];\n                int nly = p.ly + dy[i];\n                int nrx = p.rx + dx[(i + 2) % 4];\n                int nry = p.ry + dy[i];\n                bool left_do = true;\n                bool right_do = true;\n                if (nlx < 0 || w <= nlx) left_do = false;\n                if (nly < 0 || h <= nly) left_do = false;\n                if (ML[nly][nlx] == '#') left_do = false;\n                if (nrx < 0 || w <= nrx) right_do = false;\n                if (nry < 0 || h <= nry) right_do = false;\n                if (MR[nry][nrx] == '#') right_do = false;\n                if (ML[nly][nlx] == '%' && MR[nry][nrx] == '%') {\n                    flag = true;\n                    while (!que.empty()) que.pop();\n                    break;\n                } else if (ML[nly][nlx] == '%' || MR[nry][nrx] == '%') {\n                    continue;\n                }\n                if (!left_do && !right_do) continue;\n                if (!left_do) nlx = p.lx, nly = p.ly;\n                if (!right_do) nrx = p.rx, nry = p.ry;\n                que.push(POINT{nlx, nly, nrx, nry});\n            }\n            ul[p.lx][p.ly] = true;\n            ur[p.rx][p.ry] = true;\n        }\n        if (flag)\n            cout << \"Yes\" << endl;\n        else\n            cout << \"No\" << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define abs(a) max((a),-(a))\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define repe(i,n) rep(i,(n)+1)\n#define per(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define pere(i,n) rep(i,(n)+1)\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define RET return 0\n#define MOD 1000000007\n#define INF 1000000000000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nbool ok[50][50][50][50];\nint main(){\n  while(1){\n    int h,w;\n    cin >> w >> h;\n    if(h==0) return 0;\n    vector<string> l(h),r(h);\n    for(int i=0;i<h;i++) cin >> l[i] >> r[i];\n    for(int i=0;i<h;i++) reverse(all(r[i]));\n    int lsx,lsy,lgx,lgy,rsx,rsy,rgx,rgy;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        if(l[i][j]=='L'){\n          lsy=i,lsx=j;\n          l[i][j]='.';\n        }else if(l[i][j]=='%'){\n          lgy=i,lgx=j;\n          l[i][j]='.';\n        }\n        if(r[i][j]=='R'){\n          rsy=i,rsx=j;\n          r[i][j]='.';\n        }else if(r[i][j]=='%'){\n          rgy=i,rgx=j;\n          r[i][j]='.';\n        }\n      }\n    }\n    queue<pair<pair<int,int>,pair<int,int>>> bfs;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        for(int k=0;k<h;k++){\n          for(int l=0;l<w;l++){\n            ok[i][j][k][l]=false;\n          }\n        }\n      }\n    }\n    bfs.push({{lsx,lsy},{rsx,rsy}});\n    ok[lsy][lsx][rsy][rsx]=true;\n    vector<int> vx={1,0,-1,0},vy={0,-1,0,1};\n    int lnx,lny,rnx,rny;\n    pair<pair<int,int>,pair<int,int>> now;\n    while(!bfs.empty()){\n      now=bfs.front();\n      bfs.pop();\n      // cout << now.first.first SP now.first.second SP now.second.first SP now.second.second << endl;\n      for(int i=0;i<4;i++){\n        lnx=now.first.first+vx[i];\n        lny=now.first.second+vy[i];\n        rnx=now.second.first+vx[i];\n        rny=now.second.second+vy[i];\n        if(0<=lnx&&lnx<w&&0<=lny&&lny<h){\n          if(l[lny][lnx]=='#'){\n            lnx=now.first.first;\n            lny=now.first.second;\n          }\n        }else{\n          lnx=now.first.first;\n          lny=now.first.second;\n        }\n        if(0<=rnx&&rnx<w&&0<=rny&&rny<h){\n          if(r[rny][rnx]=='#'){\n            rnx=now.second.first;\n            rny=now.second.second;\n          }\n        }else{\n          rnx=now.second.first;\n          rny=now.second.second;\n        }\n        if(!ok[lny][lnx][rny][rnx]){\n          ok[lny][lnx][rny][rnx]=true;\n          if((!(lnx==lgx&&lny==lgy))&&(!(rnx==rgx&&rny==rgy))) bfs.push({{lnx,lny},{rnx,rny}});\n        }\n      }\n    }\n    if(ok[lgy][lgx][rgy][rgx]) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) for(auto x : v){cout << x << \" \";} cout << endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(vv) for(auto v : vv){for(auto&& x : v){cout << x << \" \";}cout << endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\n// typedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\ntypedef vector<vector<int>> Graph;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\ntypedef tuple<int, int, int, int> TUPLE;\n\nconst int MAX_H = 52;\nconst int MAX_W = 52;\nbool done[MAX_H][MAX_W][MAX_H][MAX_W];\nvector<vector<string>> s;\nint H, W;\nvector<int> sx(2), sy(2), gx(2), gy(2);\n\n// N, E, S, W\n// kagamiawase\nconst int dx[2][4] = {\n    {-1,  0,  1,  0},\n    {-1,  0,  1,  0}\n};\nconst int dy[2][4] = {\n    { 0,  1,  0, -1},\n    { 0, -1,  0,  1}\n};\n\nbool bfs() {\n    queue<TUPLE> que;\n    que.emplace(sx[0], sy[0], sx[1], sy[1]);\n    done[sx[0]][sy[0]][sx[1]][sy[1]] = true;\n    while (!que.empty()) {\n        int x0, y0, x1, y1;\n        tie(x0, y0, x1, y1) = que.front(); que.pop();\n        if (x0 == gx[0] && y0 == gy[0] && x1 == gx[1] && y1 == gy[1]) return true;\n        rep(k, 4) {\n            int nx0 = x0 + dx[0][k];\n            int ny0 = y0 + dy[0][k];\n            int nx1 = x1 + dx[1][k];\n            int ny1 = y1 + dy[1][k];\n\n            if (!done[nx0][ny0][nx1][ny1] && s[0][nx0][ny0] == '.' && s[1][nx1][ny1] == '.') {\n                que.emplace(nx0, ny0, nx1, ny1);\n                done[nx0][ny0][nx1][ny1] = true;\n            } else if (!done[nx0][ny0][x1][y1] && s[0][nx0][ny0] == '.' && s[1][nx1][ny1] == '#') {\n                que.emplace(nx0, ny0, x1, y1);\n                done[nx0][ny0][x1][y1] = true;\n            } else if (!done[x0][y0][nx1][ny1] && s[0][nx0][ny0] == '#' && s[1][nx1][ny1] == '.') {\n                que.emplace(x0, y0, nx1, ny1);\n                done[x0][y0][nx1][ny1] = true;\n            }\n        }\n    }\n    return false;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int t = 0;\n    while (cin >> W >> H, W) {\n        // cout << \"t = \" << t++ << endl;\n\n        H += 2;\n        W += 2;\n\n        s.clear(); s.resize(2, vector<string>(H, string(W, '#')));\n        rep2(i, 1, H - 1) {\n            rep(b, 2) {\n                cin >> s[b][i];\n                s[b][i] = \"#\" + s[b][i] + \"#\";\n            }\n        }\n\n        rep(b, 2) {\n            rep(i, H) {\n                rep(j, W) {\n                    if (s[b][i][j] == (b ? 'R' : 'L')) {\n                        sx[b] = i, sy[b] = j;\n                        s[b][i][j] = '.';\n                    }\n                    if (s[b][i][j] == '%') {\n                        gx[b] = i, gy[b] = j;\n                        s[b][i][j] = '.';\n                    }\n                }\n            }\n        }\n\n        // if (t - 1 != 13) continue;\n\n\n        // cout << \"H = \" << H << \", W = \" << W << endl;\n        // rep(b, 2) {\n        //     printVS(s[b]);\n        //     cout << endl;\n        // }\n\n        rep(x0, H) rep(y0, W) rep(x1, H) rep(y1, W) done[x0][y0][x1][y1] = false;\n        cout << (bfs() ? \"Yes\" : \"No\") << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nint w,h;\nstring r1[50],r2[50];\n\nbool ch(){\n  bool u[50][50][50][50]={};\n  int lx,ly,rx,ry,ax,ay,bx,by;\n  int dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      if(r1[i][j]=='L')lx=j,ly=i;\n      if(r2[i][j]=='R')rx=j,ry=i;\n      if(r1[i][j]=='%')ax=j,ay=i;\n      if(r2[i][j]=='%')bx=j,by=i;\n    }\n  queue<PP> q;\n  q.push(PP(P(lx,ly),P(rx,ry)));\n  while(!q.empty()){\n    PP p=q.front();\n    q.pop();\n    lx=p.first.first;\n    ly=p.first.second;\n    rx=p.second.first;\n    ry=p.second.second;\n    if(u[lx][ly][rx][ry])continue;\n    u[lx][ly][rx][ry]=1;\n    for(int i=0;i<4;i++){\n      int nlx=lx+dx[i];\n      int nly=ly+dy[i];\n      int nrx=rx-dx[i];\n      int nry=ry+dy[i];\n      if(nlx<0||w<=nlx||nly<0||h<=nly||r1[nly][nlx]=='#')nlx=lx,nly=ly;\n      if(nrx<0||w<=nrx||nry<0||h<=nry||r2[nry][nrx]=='#')nrx=rx,nry=ry;\n      q.push(PP(P(nlx,nly),P(nrx,nry)));\n    }\n  }\n  return u[ax][ay][bx][by];\n}\n\nint main(){\n  while(cin>>w>>h,w ){\n    for(int i=0;i<h;i++)cin>>r1[i]>>r2[i];\n    cout<<(ch()?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n\nusing namespace std;\nint const dxL[] = {-1,0,1,0};\nint const dxR[] = {1,0,-1,0};\nint const dy[]  = {0,-1,0,1};\ntypedef pair<int, int> Pii;\n#define X first\n#define Y second\nint W, H;\nchar grL[51][51], grR[51][51];\ninline bool inF(int x, int y, int isL) {\n  if(0<=x&&x<W && 0<=y&&y<H) {\n    if(isL) return grL[y][x]!='#';\n    else return grR[y][x]!='#';\n  }\n  return false;\n}\ninline int toNode(int x, int y) {\n  return y*W+x;\n}\ninline void toPos(int node, int &x, int &y) {\n  x = node%W, y = node/W;\n}\nint main() {\n  \n  while(cin >> W >> H && (W|H)) {\n    int sxL, syL, sxR, syR;\n    int gxL, gyL, gxR, gyR;\n    for(int i=0; i<H; i++) {\n      for(int j=0; j<2*W; j++) {\n        if(j<W) {\n          cin >> grL[i][j];\n          if(grL[i][j] == 'L') {\n            sxL = j, syL = i;\n          }\n          if(grL[i][j] == '%') {\n            gxL = j, gyL = i;\n          }\n        }\n        else {\n          cin >> grR[i][j-W];\n          if(grR[i][j-W] == 'R') {\n            sxR = j-W, syR = i;\n          }\n          if(grR[i][j-W] == '%') {\n            gxR = j-W, gyR = i;\n          }\n        }\n      }\n    }\n    \n    map<pair<int, int>, int > mp;\n    queue<int> qCost;\n    queue<int> qL, qR;\n    qCost.push(0);\n    qL.push(toNode(sxL, syL)); qR.push(toNode(sxR, syR));\n    bool ok = false;\n    while(!qL.empty()) {\n      int nowL = qL.front(); qL.pop();\n      int nowR = qR.front(); qR.pop();\n      int lx, ly; toPos(nowL, lx, ly);\n      int rx, ry; toPos(nowR, rx, ry);\n      int cost = qCost.front(); qCost.pop();\n      if(mp.find(make_pair(nowL, nowR)) != mp.end()) continue;\n      mp[make_pair(nowL, nowR)] = cost;\n      if(lx == gxL && ly == gyL && rx == gxR && ry == gyR) {\n        ok = true; break;\n      }\n      if(lx == gxL && ly == gyL) {\n        continue;\n      }\n      if(rx == gxR && ry == gyR) {\n        continue;\n      }\n      for(int i=0; i<4; i++) {\n        int nxL = lx+dxL[i], nyL = ly+dy[i];\n        int nxR = rx+dxR[i], nyR = ry+dy[i];\n        if(!inF(nxL, nyL, 1) && !inF(nxR, nyR, 0)) continue;\n        if(!inF(nxL, nyL, 1)) { nxL = lx, nyL = ly; }\n        if(!inF(nxR, nyR, 0)) { nxR = rx, nyR = ry; }\n        if(mp.find(make_pair(toNode(nxL, nyL), toNode(nxR, nyR))) != mp.end()) continue;\n        qCost.push(cost+1);\n        qL.push(toNode(nxL, nyL));\n        qR.push(toNode(nxR, nyR));\n      }\n    }\n    if(ok) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nstruct POINT\n{\n\tint x, y;\n\tbool operator<(const POINT &t)const{\n\t\tif (x == t.x) return y < t.y;\n\t\treturn x < t.x;\n\t}\n\tbool operator==(const POINT &t)const{\n\t\treturn x == t.x && y == t.y;\n\t}\n};\n\nstruct P\n{\n\tPOINT l, r;\n\tbool operator<(const P &t)const{\n\t\tif (l == t.l) return r < t.r;\n\t\treturn l < t.l;\n\t}\n};\n\nchar g1[64][64], g2[64][64];\n\nint main()\n{\n\tint w, h;\n\twhile (scanf(\"%d %d\", &w, &h), w + h){\n\t\tmemset(g1, '#', sizeof(g1));\n\t\tmemset(g2, '#', sizeof(g2));\n\t\t\n\t\tPOINT L, R;\n\t\tfor (int i = 1; i <= h; i++){\n\t\t\tfor (int j = 1; j <= w; j++){\n\t\t\t\tscanf(\" %c\", &g1[i][j]);\n\t\t\t\tif (g1[i][j] == 'L'){\n\t\t\t\t\tL = {i, j};\n\t\t\t\t\tg1[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = w; j >= 1; j--){\n\t\t\t\tscanf(\" %c\", &g2[i][j]);\n\t\t\t\tif (g2[i][j] == 'R'){\n\t\t\t\t\tR = {i, j};\n\t\t\t\t\tg2[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<P> que;\n\t\tstatic bool done[51][51][51][51] = {false};\n\t\tbool res = false;\n\t\tfor (que.push({L, R}); !que.empty(); que.pop()){\n\t\t\tP p = que.front();\n\t\t\t\n\t\t\t//printf(\"%d %d %d %d\\n\", p.l.x, p.l.y, p.r.x, p.r.y);\n\t\t\t\n\t\t\tif (done[p.l.x][p.l.y][p.r.x][p.r.y]) continue;\n\t\t\tdone[p.l.x][p.l.y][p.r.x][p.r.y] = true;\n\t\t\t\n\t\t\tif (g1[p.l.x][p.l.y] == '%' && g2[p.r.x][p.r.y] == '%'){\n\t\t\t\tres = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (g1[p.l.x][p.l.y] == '%' || g2[p.r.x][p.r.y] == '%'){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\t\tint ltx = p.l.x + dx[dir];\n\t\t\t\tint lty = p.l.y + dy[dir];\n\t\t\t\tint rtx = p.r.x + dx[dir];\n\t\t\t\tint rty = p.r.y + dy[dir];\n\t\t\t\t\n\t\t\t\tif (g1[ltx][lty] == '#'){\n\t\t\t\t\tltx = p.l.x;\n\t\t\t\t\tlty = p.l.y;\n\t\t\t\t}\n\t\t\t\tif (g2[rtx][rty] == '#'){\n\t\t\t\t\trtx = p.r.x;\n\t\t\t\t\trty = p.r.y;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tque.push({{ltx, lty}, {rtx, rty}});\n\t\t\t}\n\t\t}\n\t\tprintf(res ? \"Yes\\n\" : \"No\\n\");\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#define N 52\n#define y1 first.first\n#define x1 first.second\n#define y2 second.first\n#define x2 second.second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\n\nvoid bfs();\n\nint w,h,sy1,sx1,sy2,sx2,gy1,gx1,gy2,gx2,ans;\nstring r1[N],r2[N];\nbool visited[N][N][N][N];\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(!w&&!h) break;\n    for(int i=0;i<h;i++) cin>>r1[i]>>r2[i];\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tfor(int k=0;k<h;k++)\n\t  for(int l=0;l<w;l++) visited[i][j][k][l]=false;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(r1[i][j]=='L') sy1=i,sx1=j;\n\tif(r1[i][j]=='%') gy1=i,gx1=j;\n\tif(r2[i][j]=='R') sy2=i,sx2=j;\n\tif(r2[i][j]=='%') gy2=i,gx2=j;\n      }\n    ans=0;\n    bfs();\n    if(ans) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n  return 0;\n}\n\nvoid bfs(){\n  int dy[4]={0,-1,0,1},dx[4]={-1,0,1,0};\n  queue<P1> q;\n  P1 k=make_pair(P(sy1,sx1),P(sy2,sx2));\n  q.push(k);\n  visited[sy1][sx1][sy2][sx2]=true;\n  while(!q.empty()){\n    P1 t=q.front(); q.pop();\n    for(int i=0;i<4;i++){\n      int ny1=t.y1+dy[i],nx1=t.x1+dx[i];\n      int ny2=t.y2+dy[i],nx2=t.x2-dx[i];\n      if(ny1<0) ny1=0;\n      if(nx1<0) nx1=0;\n      if(h<=ny1) ny1=h-1;\n      if(w<=nx1) nx1=w-1;\n      if(ny2<0) ny2=0;\n      if(nx2<0) nx2=0;\n      if(h<=ny2) ny2=h-1;\n      if(w<=nx2) nx2=w-1;\n      if(r1[ny1][nx1]=='#') ny1=t.y1,nx1=t.x1;\n      if(r2[ny2][nx2]=='#') ny2=t.y2,nx2=t.x2;\n      P1 u=make_pair(P(ny1,nx1),P(ny2,nx2));\n      if(visited[ny1][nx1][ny2][nx2]) continue;\n      visited[ny1][nx1][ny2][nx2]=true;\n      q.push(u);\n      if(ny1==gy1&&nx1==gx1&&ny2==gy2&&nx2==gx2){\n\tans=1;\n\treturn ;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\nusing namespace std;\nstruct po{int lx,ly,rx,ry;};\nint w,h;\nstring mp[2][51];\nbool visited[51][51][51][51];\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\n\nbool bfs(int lx,int ly,int rx,int ry){\n  queue <po> Q;\n  Q.push((po){lx,ly,rx,ry});\n  while(!Q.empty()){\n    po t=Q.front();Q.pop();\n    if(mp[0][t.ly][t.lx]=='%'&&mp[1][t.ry][t.rx]=='%')return true;\n    if(visited[t.lx][t.ly][t.rx][t.ry]||mp[0][t.ly][t.lx]=='%'||mp[1][t.ry][t.rx]=='%')continue;\n    visited[t.lx][t.ly][t.rx][t.ry]=1;\n    for(int i=0;i<4;i++){\n      int flg=0;\n      int nlx=t.lx+dx[i],nly=t.ly+dy[i];\n      int nrx=t.rx-dx[i],nry=t.ry+dy[i];\n      if(nlx<0||nly<0||nlx>=w||nly>=h||mp[0][nly][nlx]=='#')nlx=t.lx,nly=t.ly,flg++;\n      if(nrx<0||nry<0||nrx>=w||nry>=h||mp[1][nry][nrx]=='#')nrx=t.rx,nry=t.ry,flg++;\n      if(flg==2||visited[nlx][nly][nrx][nry])continue;\n      Q.push((po){nlx,nly,nrx,nry});\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(1){\n    cin >>w>>h;\n    if(!w&&!h)break;\n    for(int i=0;i<h;i++)cin>>mp[0][i]>>mp[1][i];\n    int lx,ly,rx,ry;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(mp[0][i][j]=='L')lx=j,ly=i;\n\tif(mp[1][i][j]=='R')rx=j,ry=i;\n      }\n\n    memset(visited,0,sizeof(visited));\n    if(bfs(lx,ly,rx,ry))cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int, int> T;\n\nconst ll MOD=1e9+7;\nconst ll INF=1e18;\nconst double pi=acos(-1);\nconst double eps=1e-10;\n\nint dx[]={1, 0, -1, 0};\nint dy[]={0, -1, 0, 1};\n\nint main(){\n    while(1){\n        int w, h; cin>>w>>h;\n        if(w == 0) return 0;\n\n        int lsy, lsx, rsy, rsx;\n        int lgy, lgx, rgy, rgx;\n        vector<string> s1(h), s2(h);\n        for(int i=0; i<h; i++){\n            cin>>s1[i]>>s2[i];\n            reverse(s2[i].begin(), s2[i].end());\n\n            for(int j=0; j<w; j++){\n                if(s1[i][j] == '%'){\n                    s1[i][j] = '.';\n                    lgy = i;\n                    lgx = j;\n                }\n                if(s2[i][j] == '%'){\n                    s2[i][j] = '.';\n                    rgy = i;\n                    rgx = j;\n                }\n                if(s1[i][j] == 'L'){\n                    s1[i][j] = '.';\n                    lsy = i;\n                    lsx = j;\n                }\n                if(s2[i][j] == 'R'){\n                    s2[i][j] = '.';\n                    rsy = i;\n                    rsx = j;\n                }\n            }\n        }\n\n        bool valid=false;\n        queue<T> que;\n        que.push(T(lsy, lsx, rsy, rsx));\n        map<int, bool> visited;\n        visited[(lsy * h + lsx) + (3000 + rsy * h + rsx)] = true;\n        while(que.size()){\n            int lcy, lcx, rcy, rcx;\n            tie(lcy, lcx, rcy, rcx) = que.front();\n            que.pop();\n            //cout << lcy << \" \" << lcx << \" \" << rcy << \" \" << rcx << endl;\n\n            if(lcy == lgy && lcx == lgx && rcy == rgy && rcx == rgx){\n                cout << \"Yes\" << endl;\n                valid = true;\n                break;\n            }\n\n            for(int i=0; i<4; i++){\n                int lny = lcy + dy[i];\n                int lnx = lcx + dx[i];\n                int rny = rcy + dy[i];\n                int rnx = rcx + dx[i];\n\n                if(0 <= lny && lny < h && 0 <= lnx && lnx < w){\n                    if(s1[lny][lnx] == '.'){\n                        if(rny < 0 || h <= rny || rnx < 0 || w <= rnx){\n                            if(!visited[lny*h+lnx+3000+rcy*h+rcx]){\n                                visited[lny*h+lnx+3000+rcy*h+rcx] = true;\n                                que.push(T(lny, lnx, rcy, rcx));\n                            }\n                        }\n                        else if(s2[rny][rnx] == '#'){\n                            if(!visited[lny*h+lnx+3000+rcy*h+rcx]){\n                                visited[lny*h+lnx+3000+rcy*h+rcx] = true;\n                                que.push(T(lny, lnx, rcy, rcx));\n                            }\n                        }\n                        else{\n                            if(!visited[lny*h+lnx+3000+rny*h+rnx]){\n                                visited[lny*h+lnx+3000+rny*h+rnx] = true;\n                                que.push(T(lny, lnx, rny, rnx));\n                            }\n                        }\n                    }\n                }\n\n                if(0 <= rny && rny < h && 0 <= rnx && rnx < w){\n                    if(s2[rny][rnx] == '.'){\n                        if(lny < 0 || h <= lny || lnx < 0 || w <= lnx){\n                            if(!visited[lcy*h+lcx+3000+rny*h+rnx]){\n                                visited[lcy*h+lcx+3000+rny*h+rnx] = true;\n                                que.push(T(lcy, lcx, rny, rnx));\n                            }\n                        }\n                        else if(s1[lny][lnx] == '#'){\n                            if(!visited[lcy*h+lcx+3000+rny*h+rnx]){\n                                visited[lcy*h+lcx+3000+rny*h+rnx] = true;\n                                que.push(T(lcy, lcx, rny, rnx));\n                            }\n                        }\n                        else{\n                            if(!visited[lny*h+lnx+3000+rny*h+rnx]){\n                                visited[lny*h+lnx+3000+rny*h+rnx] = true;\n                                que.push(T(lny, lnx, rny, rnx));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if(!valid) cout << \"No\" << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\nbool vis[3000][3000];\n\nint main() {\n\tfor (;;) {\n\t\tint W, H; cin >> W >> H;\n\t\tif (W == 0 && H == 0) break;\n\t\tvector< vector<string> > a(2, vector<string>(H + 2, string(W + 2, '#')));\n\t\tfor (int y = 1; y <= H; y++) {\n\t\t\tstring s1, s2; cin >> s1 >> s2;\n\t\t\ta[0][y] = '#' + s1 + '#';\n\t\t\ta[1][y] = '#' + s2 + '#';\n\t\t}\n\t\tvector<char> xs(2), ys(2), xt(2), yt(2);\n\t\tfor (int k = 0; k < 2; k++)\n\t\t\tfor (int y = 1; y <= H; y++)\n\t\t\t\tfor (int x = 1; x <= W; x++){\n\t\t\t\t\tchar& c = a[k][y][x];\n\t\t\t\t\tif (c == 'L' || c == 'R') {\n\t\t\t\t\t\tc = '.';\n\t\t\t\t\t\txs[k] = x; ys[k] = y;\n\t\t\t\t\t}\n\t\t\t\t\telse if (c == '%') {\n\t\t\t\t\t\tc = '.';\n\t\t\t\t\t\txt[k] = x; yt[k] = y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tfill(vis[0], vis[0] + 9000000, false);\n\t\tstack< vector<char> > stx, sty;\n\t\tstx.push(xs); sty.push(ys);\n\t\twhile (!stx.empty()) {\n\t\t\tvector<char> x = stx.top(); stx.pop();\n\t\t\tvector<char> y = sty.top(); sty.pop();\n\t\t\tvector<int> z(2);\n\t\t\tfor (int k = 0; k < 2; k++)\n\t\t\t\tz[k] = y[k] * (W + 2) + x[k];\n\t\t\tvis[z[0]][z[1]] = true;\n\t\t\tif (x[0] == xt[0] && y[0] == yt[0]) continue;\n\t\t\tif (x[1] == xt[1] && y[1] == yt[1]) continue;\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tvector<char> _x = x, _y = y;\n\t\t\t\tvector<int> _z(2);\n\t\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\t\t_x[k] += (k ? dx[i] : -dx[i]);\n\t\t\t\t\t_y[k] += dy[i];\n\t\t\t\t\tif (a[k][_y[k]][_x[k]] == '#') {\n\t\t\t\t\t\t_x[k] = x[k]; _y[k] = y[k];\n\t\t\t\t\t}\n\t\t\t\t\t_z[k] = _y[k] * (W + 2) + _x[k];\n\t\t\t\t}\n\t\t\t\tif (!vis[_z[0]][_z[1]]) {\n\t\t\t\t\tvis[_z[0]][_z[1]] = true;\n\t\t\t\t\tstx.push(_x);\n\t\t\t\t\tsty.push(_y);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << stx.size() << endl;\n\t\t}\n\t\tvector<int> zt(2);\n\t\tfor (int k = 0; k < 2; k++)\n\t\t\tzt[k] = yt[k] * (W + 2) + xt[k];\n\t\tcout << (vis[zt[0]][zt[1]] ? \"Yes\" : \"No\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<tuple>\n#include<string>\nusing namespace std;\n\n#define MAX_N 70\n#define INF 1<<30\n\nint dist[MAX_N][MAX_N][MAX_N][MAX_N];\nint dy1[4] = { 0,1,0,-1 };\nint dy2[4] = { 0,1,0,-1 };\nint dx1[4] = { 1,0,-1,0 };\nint dx2[4] = { -1,0,1,0 };\nint H, W, map1[MAX_N][MAX_N], map2[MAX_N][MAX_N];\nint Lsy, Lsx, Lgy, Lgx;\nint Rsy, Rsx, Rgy, Rgx;\nstring S, T;\nqueue<tuple<int, int, int, int>>Q;\n\nvoid _memset() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tfor (int k = 0; k < MAX_N; k++) {\n\t\t\t\tfor (int l = 0; l < MAX_N; l++) {\n\t\t\t\t\tdist[i][j][k][l] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tmap1[i][j] = 1;\n\t\t\tmap2[i][j] = 1;\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\t//memset.\n\t\t_memset();\n\n\t\t//cin.\n\t\tcin >> W >> H;\n\t\tif (H == 0 && W == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tcin >> S >> T;\n\t\t\tfor (int j = 0; j < S.size(); j++) {\n\t\t\t\tif (S[j] == 'L') {\n\t\t\t\t\tLsx = j + 1; Lsy = i;\n\t\t\t\t\tmap1[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\tif (S[j] == '#') {\n\t\t\t\t\tmap1[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (S[j] == '.') {\n\t\t\t\t\tmap1[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\tif (S[j] == '%') {\n\t\t\t\t\tLgy = i; Lgx = j + 1;\n\t\t\t\t\tmap1[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < T.size(); j++) {\n\t\t\t\tif (T[j] == 'R') {\n\t\t\t\t\tRsx = j + 1; Rsy = i;\n\t\t\t\t\tmap2[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\tif (T[j] == '#') {\n\t\t\t\t\tmap2[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (T[j] == '.') {\n\t\t\t\t\tmap2[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\tif (T[j] == '%') {\n\t\t\t\t\tRgy = i; Rgx = j + 1;\n\t\t\t\t\tmap2[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//bfs.\n\t\tQ.push(make_tuple(Lsy, Lsx, Rsy, Rsx));\n\t\tdist[Lsy][Lsx][Rsy][Rsx] = 0;\n\n\t\twhile (!Q.empty()) {\n\t\t\ttuple<int, int, int, int>tup = Q.front(); Q.pop();\n\t\t\tbool Q1, Q2;\n\t\t\tint ay = get<0>(tup);\n\t\t\tint ax = get<1>(tup);\n\t\t\tint by = get<2>(tup);\n\t\t\tint bx = get<3>(tup);\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint ey = ay + dy1[i], ex = ax + dx1[i];\n\t\t\t\tint fy = by + dy2[i], fx = bx + dx2[i];\n\t\t\t\tif (map1[ey][ex] == 1) {\n\t\t\t\t\tey = ay; ex = ax;\n\t\t\t\t}\n\t\t\t\tif (map2[fy][fx] == 1) {\n\t\t\t\t\tfy = by; fx = bx;\n\t\t\t\t}\n\t\t\t\tif (ey == Lgy && ex == Lgx) {\n\t\t\t\t\tQ1 = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tQ1 = false;\n\t\t\t\t}\n\t\t\t\tif (fy == Rgy && fx == Rgx) {\n\t\t\t\t\tQ2 = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tQ2 = false;\n\t\t\t\t}\n\t\t\t\tif (Q1 == true && Q2 == false) {\n\t\t\t\t\tgoto G;\n\t\t\t\t}\n\t\t\t\tif (Q1 == false && Q2 == true) {\n\t\t\t\t\tgoto G;\n\t\t\t\t}\n\t\t\t\tif (dist[ey][ex][fy][fx] == INF) {\n\t\t\t\t\tdist[ey][ex][fy][fx] = dist[ay][ax][by][bx] + 1;\n\t\t\t\t\tQ.push(make_tuple(ey, ex, fy, fx));\n\t\t\t\t}\n\t\t\tG:;\n\t\t\t}\n\t\t}\n\n\t\t//hantei.\n\t\tif (dist[Lgy][Lgx][Rgy][Rgx] == INF) {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define fi first\n#define se second\n#define mk make_pair\nusing namespace std;\nstring s1[50],s2[50];\nint dx1[]={1,-1,0,0,},dy1[]={0,0,1,-1};\nint dx2[]={-1,1,0,0,},dy2[]={0,0,1,-1};\nint w,h,gx1,gx2,gy1,gy2;\nset<pair<pair<int,int>,pair<int,int> > >s;\nqueue<pair<pair<int,int>,pair<int,int> > >q;\nbool bfs(int x1,int y1,int x2,int y2){\n  queue<int>q;\n  q.push(x1+y1*100+x2*10000+y2*1000000);\n  while(!q.empty()){\n    int p=q.front();q.pop();\n    x1=p%100;y1=p%10000/100;\n    x2=p%1000000/10000;y2=p/1000000;\n    for(int i=0;i<4;i++){\n      int x3=x1+dx1[i],y3=y1+dy1[i];\n      int x4=x2+dx2[i],y4=y2+dy2[i];\n      if(x3>=0&&x4>=0&&y3>=0&&y4>=0)\n        if(x3<w&&x4<w&&y3<h&&y4<h){\n          if(s1[y3][x3]=='#')y3=y1,x3=x1;\n          if(s2[y4][x4]=='#')y4=y2,x4=x2;\n          if(x1==gx1&&y1==gy1&&x2==gx2&&y2==gy2)return 1;\n          if(!(x3==gx1&&y3==gy1&&(x4!=gx2||y4!=gy2)))\n          if(!((x3!=gx1||y3!=gy1)&&x4==gx2&&y4==gy2))\n          if(!s.count(mk(mk(x3,y3),mk(x4,y4)))){\n            s.insert(mk(mk(x3,y3),mk(x4,y4)));\n            q.push(x3+y3*100+x4*10000+y4*1000000);\n          }\n        }\n      }\n    }\n    return 0;\n}\nbool dfs(int x1,int y1,int x2,int y2,int d){\n  //cout<<d<<endl;cout<<1;\n    if(x1==gx1&&y1==gy1&&(x2!=gx2||y2!=gy2))return 0;\n    if((x1!=gx1||y1!=gy1)&&x2==gx2&&y2==gy2)return 0;\n    if(x1==gx1&&y1==gy1&&x2==gx2&&y2==gy2)return 1;\n    if(d<5000)for(int i=0;i<4;i++){\n    int x3=x1+dx1[i],y3=y1+dy1[i];\n    int x4=x2+dx2[i],y4=y2+dy2[i];\n    if(x3<0)x3=x1;if(x4<0)x4=x2;\n    if(y3<0)y3=y1;if(y4<0)y4=y2;\n    if(x3>=w)x3=x1;if(x4>=w)x4=x2;\n    if(y3>=h)y3=y1;if(y4>=h)y4=y2;\n        if(s1[y3][x3]=='#')y3=y1,x3=x1;\n        if(s2[y4][x4]=='#')y4=y2,x4=x2;\n        if(!s.count(mk(mk(x3,y3),mk(x4,y4)))){\n          s.insert(mk(mk(x3,y3),mk(x4,y4)));\n          if(dfs(x3,y3,x4,y4,d+1))return 1;\n        }\n    }\n    else q.push(mk(mk(x1,y1),mk(x2,y2)));\n    if(q.size()){\n        pair<pair<int,int>,pair<int,int> >pp=q.front();q.pop();\n        if(bfs(pp.fi.fi,pp.fi.se,pp.se.fi,pp.se.se))return 1;\n    }\n    return 0;\n}\nint main(){\n  int x1,y1,x2,y2;\n  while(cin>>w>>h,w){\n    s.clear();\n    r(i,h)cin>>s1[i]>>s2[i];\n    r(i,h)r(j,w){\n      if(s1[i][j]=='L')x1=j,y1=i;\n      if(s2[i][j]=='R')x2=j,y2=i;\n      if(s1[i][j]=='%')gx1=j,gy1=i;\n      if(s2[i][j]=='%')gx2=j,gy2=i;\n    }\n    s.insert(mk(mk(x1,y1),mk(x2,y2)));\n    if(dfs(x1,y1,x2,y2,0))cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n    while(!q.empty())q.pop();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,s,n) for(int i=s; i<n; i++)\n#define ALL(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nint w, h;\nint rooml[55][55], roomr[55][55];\nbool memo[55][55][55][55];\n\nbool dfs(int xl, int yl, int xr, int yr) {\n\tif( memo[xl][yl][xr][yr] ) {\n\t\treturn false;\n\t}\n\tmemo[xl][yl][xr][yr] = true;\n\tconst int dx[4] = {-1, 0, 1, 0};\n\tconst int dy[4] = {0, 1, 0, -1};\n\trep(i, 4) {\n\t\tint nxl = xl + dx[i];\n\t\tint nyl = yl + dy[i];\n\t\tint nxr = xr + dx[i]*-1;\n\t\tint nyr = yr + dy[i];\n\t\tint nl = rooml[nyl][nxl];\n\t\tint nr = roomr[nyr][nxr];\n\t\tif( nl==2 && nr==2 ) {\n\t\t\treturn true;\n\t\t}\n\t\telse if( nl==1 && nr==1 ) {\n\t\t\tbool f = dfs(nxl, nyl, nxr, nyr);\n\t\t\tif(f) return true;\n\t\t}\n\t\telse if( nl==1 && nr==0 ) {\n\t\t\tbool f = dfs(nxl, nyl, xr, yr);\n\t\t\tif(f) return true;\n\t\t}\n\t\telse if( nl==0 && nr==1 ) {\n\t\t\tbool f = dfs(xl, yl, nxr, nyr);\n\t\t\tif(f) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\twhile(cin >> w >> h, w||h) {\n\t\tmemset(rooml, 0, sizeof(rooml));\n\t\tmemset(roomr, 0, sizeof(roomr));\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tint xl, yl, xr, yr;\n\t\trep(y, h) {\n\t\t\tstring sl, sr;\n\t\t\tcin >> sl >> sr;\n\t\t\trep(x, w) {\n\t\t\t\tif(sl[x] == 'L') {\n\t\t\t\t\txl = x+1;\n\t\t\t\t\tyl = y+1;\n\t\t\t\t\trooml[y+1][x+1] = 1;\n\t\t\t\t} else {\n\t\t\t\t\trooml[y+1][x+1] = (sl[x]=='%' ? 2 : (sl[x]=='.' ? 1 : 0));\n\t\t\t\t}\n\t\t\t\tif(sr[x] == 'R') {\n\t\t\t\t\txr = x+1;\n\t\t\t\t\tyr = y+1;\n\t\t\t\t\troomr[y+1][x+1] = 1;\n\t\t\t\t} else {\n\t\t\t\t\troomr[y+1][x+1] = (sr[x]=='%' ? 2 : (sr[x]=='.' ? 1 : 0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( dfs(xl, yl, xr, yr) ) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t} else {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nint W, H;\nchar RoomL[50][50];\nchar RoomR[50][50];\n\nconst int dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};\n\nstruct P {\n    int lx, ly, rx, ry;\n};\n\nbool is_reachable(int x, int y, char room[50][50]) {\n    bool G[50][50] = {0};\n    queue<pii> que;\n    que.push({x, y});\n    while (!que.empty()) {\n        pii p = que.front(); que.pop();\n        int x = p.first, y = p.second;\n        REP(i, 4) {\n            int sx = x + dx[i], sy = y + dy[i];\n            if (0 <= sx && sx < W && 0 <= sy && sy < H) {\n                switch (room[sy][sx]) {\n                case '%':\n                    return true;\n                case '#':\n                    break;\n                default:\n                    if (!G[sy][sx]) {\n                        G[sy][sx] = true;\n                        que.push({sx, sy});\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    while (cin >> W >> H, W|H) {\n        fill_n((char *)RoomL, 50*50, '#');\n        fill_n((char *)RoomR, 50*50, '#');\n\n        int lx, ly, rx, ry;\n        int lgx, lgy, rgx, rgy;\n        REP(y, H) {\n            REP(x, W) {\n                cin >> RoomL[y][x];\n                switch (RoomL[y][x]) {\n                case 'L':\n                    lx = x;\n                    ly = y;\n                    RoomL[y][x] = '.';\n                    break;\n                case '%':\n                    lgx = x;\n                    lgy = y;\n                    break;\n                }\n            }\n            REP(x, W) {\n                cin >> RoomR[y][x];\n                switch (RoomR[y][x]) {\n                case 'R':\n                    rx = x;\n                    ry = y;\n                    RoomR[y][x] = '.';\n                    break;\n                case '%':\n                    rgx = x;\n                    rgy = y;\n                    break;\n                }\n            }\n        }\n\n        if (!(is_reachable(lx, ly, RoomL) && is_reachable(rx, ry, RoomR))) {\n            cout << \"No\" << endl;\n            break;\n        }\n\n        set<pair<pii,pii>> G;\n\n        queue<P> que;\n        que.push({lx, ly, rx, ry});\n        G.insert({{lx, ly}, {rx, ry}});\n        while (!que.empty()) {\n            P p = que.front(); que.pop();\n            if (p.lx == lgx && p.ly == lgy && p.rx == rgx && p.ry == rgy) {\n                cout << \"Yes\" << endl;\n                goto END;\n            }\n\n            REP(i, 4) {\n                int lsx = p.lx - dx[i], lsy = p.ly + dy[i];\n                int rsx = p.rx + dx[i], rsy = p.ry + dy[i];\n                if (!(0 <= lsx && lsx < W && 0 <= lsy && lsy < H) || RoomL[lsy][lsx] == '#') {\n                    lsx = p.lx;\n                    lsy = p.lx;\n                }\n                if (!(0 <= rsx && rsx < W && 0 <= rsy && rsy < H) || RoomR[rsy][rsx] == '#') {\n                    rsx = p.rx;\n                    rsy = p.rx;\n                }\n                if (RoomR[rsy][rsx] == '%' || RoomL[lsy][lsx] == '%') {\n                    if (RoomR[rsy][rsx] == '%' && RoomL[lsy][lsx] == '%') {\n                    } else {\n                        continue;\n                    }\n                }\n                if (G.insert({{lsx, lsy}, {rsx, rsy}}).second) {\n//                    LOG(\"-----\\n%d %d # %d %d\\n-----\\n\", lsx, lsy, rsx, rsy);\n//                    REP(y, H) {\n//                        REP(x, W) {\n//                            if (lsx == x && lsy == y) {\n//                                printf(\"L\");\n//                            } else {\n//                                printf(\"%c\", RoomL[y][x]);\n//                            }\n//                        }\n//                        printf(\"\\n\");\n//                    }\n//                    REP(y, H) {\n//                        REP(x, W) {\n//                            if (rsx == x && rsy == y) {\n//                                printf(\"R\");\n//                            } else {\n//                                printf(\"%c\", RoomR[y][x]);\n//                            }\n//                        }\n//                        printf(\"\\n\");\n//                    }\n\n                    que.push({lsx, lsy, rsx, rsy});\n                }\n            }\n        }\n        cout << \"No\" << endl;\n    END: {}\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<string>\nusing namespace std;\nint main(){\n  int w,h;\n  while(cin>>w>>h,w||h){\n    int i,j,k;\n    int inf = 1<<20;\n    int d[50][50][50][50];\n    memset(d,inf,sizeof(d));\n    string sr[60],sl[60];\n    for(i=0;i<h;i++){\n      cin >> sr[i] >> sl[i];\n    }\n    for(i=0;i<h;i++){\n      cout << sr[i] << endl;\n    }\n    for(i=0;i<h;i++){\n      cout << sl[i] << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//50\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nchar g[2][50][50];\nbool p[50][50][50][50];\nint w,h;\n    \nbool dfs(int x,int y,int xx,int yy,int r){\n  if(r==0)return false;\n  if(p[x][y][xx][yy]++||(g[0][y][x]=='%'^g[1][yy][xx]=='%'))return false;\n  if(g[0][y][x]=='%'&&g[1][yy][xx]=='%')return true;\n  for(int i=0;i<4;i++){\n    int dy[]={0,1,0,-1};\n    int dx[][4]={{1,0,-1,0},{-1,0,1,0}};\n    int nx[2],ny[2];\n    nx[0]=x+dx[0][i];\n    ny[0]=y+dy[i];\n    nx[1]=xx+dx[1][i];\n    ny[1]=yy+dy[i];\n    for(int j=0;j<2;j++){\n      if(nx[j]<0||w<=nx[j]||ny[j]<0||h<=ny[j]||g[j][ny[j]][nx[j]]=='#'){\n\tnx[j]-=dx[j][i];\n\tny[j]-=dy[i];\n      }\n    }\n    if(dfs(nx[0],ny[0],nx[1],ny[1],r-1))return true;\n  }\n  return false;\n}\n\nint main(){\n  while(cin>>w>>h,w|h){\n    int px[2],py[2];\n    for(int y=0;y<h;y++){\n      for(int i=0;i<2;i++){\n\tfor(int x=0;x<w;x++){\n\t  cin>>g[i][y][x];\n\t  if(g[i][y][x]=='R'||g[i][y][x]=='L'){\n\t    px[i]=x;\n\t    py[i]=y;\n\t  }\n\t}\n      }\n    }\n    fill(p[0][0][0],p[50][0][0],false);\n    cout<<(dfs(px[0],py[0],px[1],py[1],1000)?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int OfLen = 0;\nconst int OfRin = 1;\n\nstruct Point {\n  int x, y;\n  Point(){}\n  Point(int x, int y):x(x), y(y){}\n};\n\nstruct TPoint {\n  Point Len, Rin;\n  TPoint(){}\n  TPoint(Point Len, Point Rin):Len(Len), Rin(Rin){}\n};\n\nint W, H;\nstring room[2][55];\n\nbool isInRoom(int whose, Point p)\n{\n  if(0 <= p.x && p.x < W && 0 <= p.y && p.y < H && room[whose][p.y][p.x] != '#') return true;\n  return false;\n}\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nbool route[2][55][55];\n\nbool isOpenGate(TPoint twinspos)\n{\n  memset(route, false, sizeof(route));\n\n  queue<TPoint> que;\n  que.push(twinspos);  \n\n  while(!que.empty()) {\n    TPoint tp = que.front(); que.pop();\n    Point len = tp.Len, rin = tp.Rin;\n\n    if(route[OfLen][len.y][len.x] && route[OfRin][rin.y][rin.x]) continue;\n\n    route[OfLen][len.y][len.x] = true;\n    route[OfRin][rin.y][rin.x] = true;\n\n    if(room[OfLen][len.y][len.x] == '%' && room[OfRin][rin.y][rin.x] == '%') return true;\n    if(room[OfLen][len.y][len.x] == '%' || room[OfRin][rin.y][rin.x] == '%') continue;\n\n    for(int i = 0; i < 4; i++) {\n      Point nextLen = len, nextRin = rin;\n\n      Point IfLenMove = Point(len.x + dx[i], len.y + dy[i]);\n      if(isInRoom(OfLen, IfLenMove)) nextLen = IfLenMove;\n      \n      Point IfRinMove = Point(rin.x - dx[i], rin.y + dy[i]);\n      if(isInRoom(OfRin, IfRinMove)) nextRin = IfRinMove;\n\n      if(route[OfLen][nextLen.y][nextLen.x] && route[OfRin][nextRin.y][nextRin.x]) continue;\n\n      que.push(TPoint(nextLen, nextRin));\n    }\n  }\n  return false;\n}\n  \n\nint main()\n{\n  while(cin >> W >> H, W || H) {\n    TPoint twinspos;\n    for(int i = 0; i < H; i++) {\n      cin >> room[OfLen][i] >> room[OfRin][i];\n      for(int j = 0; j < W; j++) {\n\tif(room[OfLen][i][j] == 'L') twinspos.Len = Point(j, i);\n\tif(room[OfRin][i][j] == 'R') twinspos.Rin = Point(j, i);\n      }\n    }\n    cout << (isOpenGate(twinspos) ? \"Yes\":\"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <set>\n#include <queue>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint range(int a,int b,int h, int w){\n\treturn a >= 0 && a < h && b >= 0 && b < w;\n}\n\nint main(void){\n\tint dl[50][50][50][50], h, w, i, j, a, b, c, d, dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\n\tchar rf[50][51], lf[50][51];\n\tP rs, ls, rg, lg;\n\tqueue<P> r, l;\n\twhile(1){\n\t\tscanf(\"%d%d%*c\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tlf[i][j] = getchar();\n\t\t\t\tif(lf[i][j] == 'L'){\n\t\t\t\t\tls = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(lf[i][j] == '%'){\n\t\t\t\t\tlg = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 空白読み飛ばし\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\trf[i][j] = getchar();\n\t\t\t\tif(rf[i][j] == 'R'){\n\t\t\t\t\trs = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(rf[i][j] == '%'){\n\t\t\t\t\trg = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 改行文字読み飛ばし\n\t\t}\n\t\tmemset(dl,0,sizeof(dl));\n\t\tr.push(rs), l.push(ls);\n\t\tdl[ls.first][ls.second][rs.first][rs.second] = 1;\n\t\twhile(r.size()){\n\t\t\ta = l.front().first, b = l.front().second, c = r.front().first, d = r.front().second;\n\t\t\tl.pop(), r.pop();\n\t\t\tif(a == lg.first && b == lg.second && c == rg.first && d == rg.second)\n\t\t\t\tbreak;\n\t\t\tif(a == lg.first && b == lg.second || c == rg.first && d == rg.second)\n\t\t\t\tcontinue;\n\t\t\tfor(i = 0;i < 4;i++){\n\t\t\t\tif(range(a + dy[i],b + dx[i],h,w) && range(c + dy[i],d - dx[i],h,w)){ // 両方とも動くとき\n\t\t\t\t\tif(lf[a + dy[i]][b + dx[i]] == '.'  && rf[c + dy[i]][d - dx[i]] == '.' && !dl[a + dy[i]][b + dx[i]][c + dy[i]][d - dx[i]]){\n\t\t\t\t\t\tl.push(P(a + dy[i],b + dx[i])), r.push(P(c + dy[i],d - dx[i]));\n\t\t\t\t\t\tdl[a + dy[i]][b + dx[i]][c + dy[i]][d - dx[i]] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(lf[a + dy[i]][b + dx[i]] == '#' && rf[c + dy[i]][d - dx[i]] == '.' && !dl[a][b][c + dy[i]][d - dx[i]]){// Rinだけ動く\n\t\t\t\t\t\tl.push(P(a,b)), r.push(P(c + dy[i],d - dx[i]));\n\t\t\t\t\t\tdl[a][b][c + dy[i]][d - dx[i]] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(lf[a + dy[i]][b + dx[i]] == '.' && rf[c + dy[i]][d - dx[i]] == '#' && !dl[a + dy[i]][b + dx[i]][c][d]){ // Lenだけ動く\n\t\t\t\t\t\tl.push(P(a + dy[i],b + dx[i])), r.push(P(c,d));\n\t\t\t\t\t\tdl[a + dy[i]][b + dx[i]][c][d] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(r.size())\n\t\t\tr.pop(),l.pop();\n\t\tif(dl[lg.first][lg.second][rg.first][rg.second])\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <stack>\nusing namespace std;\ntypedef pair<char,char> pcc;\nint W, H;\nint dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\npcc s1, s2, g1, g2;\nbool R1[50][50], R2[50][50], memo[50][50][50][50];\n\nbool dfs(pcc p1, pcc p2){\n  stack< pair<pcc,pcc> > st;\n  st.push(make_pair(p1,p2));\n  while(!st.empty()){\n    p1 = st.top().first, p2 = st.top().second;\n    st.pop();\n    for(int i = 0; i < 4; ++i){\n      //int x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;\n      pcc p1_ = p1, p2_ = p2;\n      if(p1_.first + dx[i] < H && p1_.first + dx[i] >= 0 &&\n         p1_.second + dy[i] < W && p1_.second + dy[i] >= 0 &&\n         R1[p1_.first + dx[i]][p1_.second + dy[i]]){\n        p1_.first += dx[i];\n        p1_.second += dy[i];\n      }\n      if(p2_.first + dx[i] < H && p2_.first + dx[i] >= 0 &&\n         p2_.second - dy[i] < W && p2_.second - dy[i] >= 0 &&\n         R2[p2_.first + dx[i]][p2_.second - dy[i]]){\n        p2_.first += dx[i];\n        p2_.second -= dy[i];\n      }\n      if(p1_ == g1 || p2_ == g2){\n        memo[p1_.first][p1_.second][p2_.first][p2_.second] = true;\n      }else if((!memo[p1_.first][p1_.second][p2_.first][p2_.second]) && (!memo[p1_.first][p1_.second][p2_.first][p2_.second])){\n        memo[p1_.first][p1_.second][p2_.first][p2_.second] = true;\n        st.push(make_pair(p1_,p2_));\n      }\n    }\n  }\n  return memo[g1.first][g1.second][g2.first][g2.second];\n}\n\nint main(){\n  while(cin >> W >> H, W){\n    string r1,r2;\n    for(int i = 0; i < H; ++i){\n      cin >> r1 >> r2;\n      for(int j = 0; j < W; ++j){\n        if(r1[j] == 'L'){\n          s1.first = i;\n          s1.second = j;\n        }\n        if(r2[j] == 'R'){\n          s2.first = i;\n          s2.second = j;\n        }\n        if(r1[j] == '%'){\n          g1.first = i;\n          g1.second = j;\n        }\n        if(r2[j] == '%'){\n          g2.first = i;\n          g2.second = j;\n        }\n        if(r1[j] != '#') R1[i][j] = true;\n        else R1[i][j] = false;\n        if(r2[j] != '#') R2[i][j] = true;\n        else R2[i][j] = false;\n      }\n    }\n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n        for(int k = 0; k < H; ++k){\n          for(int l = 0; l < W; ++l){\n            memo[i][j][k][l] = false;\n          }\n        }\n      }\n    }\n\n    if(dfs(s1,s2)) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_W 50\n#define MAX_H 50\n//深さ優先探索で行けるんじゃないか？\n\nbool C[52][52][52][52];\nint di[4] = {0, -1, 0, 1};\nint dj[4] = {1, 0, -1, 0};\nvector<vector<bool> > Room_L(MAX_H + 2, vector<bool> (MAX_W + 2, false));\nvector<vector<bool> > Room_R(MAX_H + 2, vector<bool> (MAX_W + 2, false));\nint si_L, si_R, sj_L, sj_R, gi_L, gi_R, gj_L, gj_R;  //スタートとゴールの座標\n\nbool Err(int n){\n    return n < 1 || 50 < n;\n}\n\nint main(){\n\n    //cout << \"ok\" << endl;\n    while(1){\n        \n        //入力\n        //cout << \"ol\" << endl;\n        int W, H; cin >> W >> H;\n        //cout << H << \" \" << W << endl;\n        if(W == 0) break;\n        \n        //cout << \"u\" << endl;\n\n        for(int i = 0; i <= H + 1; i++){\n            for(int j = 0; j <= W + 1; j++){\n                Room_L[i][j] = Room_R[i][j] = false;\n            }\n        }\n\n        //cout << \"d\" << endl;\n\n        memset(C, 0, sizeof(C));\n\n        //cout << \"37\" << endl;\n        for(int i = 1; i <= H; i++){\n            //L\n            for(int j = 1; j <= W; j++){\n                char input; cin >> input;\n                if(input == '#') continue;\n                else{\n                    Room_L[i][j] = true;\n\n                    if(input == '%'){\n                        gi_L = i;\n                        gj_L = j;\n                    }\n\n                    if(input == 'L'){\n                        si_L = i;\n                        sj_L = j;\n                    }\n                }\n            }\n\n            //cout << \"58\" << endl;\n            //R\n            for(int j = 1; j <= W; j++){\n                char input; cin >> input;\n                if(input == '#') continue;\n                else{\n                    Room_R[i][j] = true;\n\n                    if(input == '%'){\n                        gi_R = i;\n                        gj_R = j;\n                    }\n\n                    if(input == 'R'){\n                        si_R = i;\n                        sj_R = j;\n                    }\n                }\n            }\n        }\n\n        //cout << \"79\" << endl;\n\n        //幅優先をする\n        //set<pair<pair<int, int>, pair<int, int> > > s;\n        \n        queue<pair<pair<int, int>, pair<int, int> > > wait;                      //左の座標　右の座標\n        wait.push({ {si_L, sj_L}, {si_R, sj_R} });\n        //s.insert({ {si_L, sj_L}, {si_R, sj_R} });\n        C[si_L][sj_L][si_R][sj_R] = true;\n        \n        bool can = false;\n        int A = 0;\n\n        //cout << H << \" \" << W << endl;\n        while(!wait.empty()){    //キュー画空になるまで\n\n        //if(W == 50 && H == 50 && A < 100000) cout << A << endl;\n            //キューの先頭要素を取り出す\n            int nowi_L = wait.front().first.first;\n            int nowj_L = wait.front().first.second;\n            int nowi_R = wait.front().second.first;\n            int nowj_R = wait.front().second.second;\n            if(Err(nowi_L) || Err(nowi_R) || Err(nowj_L) || Err(nowj_R) ) cout << nowi_L << \" \" << nowj_L << \"  \" << nowi_R << \" \" << nowj_R << endl;\n            wait.pop();\n            A++;\n            //四方向を探索\n            for(int k = 0; k < 4; k++){\n                int nexti_L = nowi_L + di[k];\n                int nextj_L = nowj_L + dj[k];\n                int nexti_R = nowi_R + di[k];\n                int nextj_R = nowj_R - dj[k];\n                //cout << \" \" << nexti_L << \" \" << nextj_L << \"  \" << nexti_R << \" \" << nextj_R << endl;\n\n\n                bool L = Room_L[nexti_L][nextj_L];\n                bool R = Room_R[nexti_R][nextj_R];\n                //cout << \" \" << L << \" \" << R << endl;\n                \n\n                //その方向に進めるなら\n                if(nexti_L == gi_L && nextj_L == gj_L && nexti_R == gi_R && nextj_R == gj_R){\n                    can = true;\n                    break;\n                }else if((nexti_L == gi_L && nextj_L == gj_L) || (nexti_R == gi_R && nextj_R == gj_R)){\n                    continue;\n                }else if(L && R && !C[nexti_L][nextj_L][nexti_R][nextj_R]){\n                    wait.push({{nexti_L, nextj_L}, {nexti_R, nextj_R}});\n                    C[nexti_L][nextj_L][nexti_R][nextj_R] = true;\n                }else if(!L && R && !C[nowi_L][nowj_L][nexti_R][nextj_R]){\n                    wait.push({{nowi_L, nowj_L}, {nexti_R, nextj_R}});\n                    C[nowi_L][nowj_L][nexti_R][nextj_R] = true;\n                }else if(L && !R && !C[nexti_L][nextj_L][nowi_R][nowj_R]){\n                    wait.push({{nexti_L, nextj_L}, {nowi_R, nowj_R}});\n                    C[nexti_L][nextj_L][nowi_R][nowj_R] = true;\n                }\n            }\n        }\n\n        if(can) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    \n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing P=pair<int,int>;\nusing S=pair<P,P>;\n\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vvvvi=vector<vvvi>;\n\nint main(){\n    int w,h;\n    while(cin>>w>>h,h){\n        vector<string> l(h+2,\"\"),r(h+2,\"\");\n        for(int i=0;i<w+2;i++){\n            l[0]+=\"#\";\n            l[h+1]+=\"#\";\n            r[0]+=\"#\";\n            r[h+1]+=\"#\";\n        }\n        for(int i=0;i<h;i++){\n            cin>>l[i+1]>>r[i+1];\n            l[i+1]=\"#\"+l[i+1]+\"#\";\n            r[i+1]=\"#\"+r[i+1]+\"#\";\n        }\n        h+=2;\n        w+=2;\n\n        int lh,lw;\n        int rh,rw;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(l[i][j]=='L'){\n                    lh=i,lw=j;\n                }\n                if(r[i][j]=='R'){\n                    rh=i,rw=j;\n                }\n            }\n        }\n\n        P iniL={lh,lw},iniR={rh,rw};\n        S ini={iniL,iniR};\n\n        vvvvi dp(h,vvvi(w,vvi(h,vi(w,false))));\n        queue<S> que;\n\n        que.push(ini);\n        bool isok=false;\n\n        int dh[]={0,1,0,-1};\n        int dw[]={1,0,-1,0};\n        while(!que.empty()){\n            auto state=que.front();\n            que.pop();\n            P lp=state.first,rp=state.second;\n            if(dp[lp.first][lp.second][rp.first][rp.second]) continue;\n            dp[lp.first][lp.second][rp.first][rp.second]=true;\n            int isL=(l[lp.first][lp.second]=='%');\n            int isR=(r[rp.first][rp.second]=='%');\n            if(isL+isR==2){\n                isok=true;\n                break;\n            }\n            if(isL+isR==1) continue;\n            \n            for(int i=0;i<4;i++){\n                P toL={lp.first+dh[i],lp.second+dw[i]};\n                if(l[toL.first][toL.second]=='#') toL=lp;\n                P toR={rp.first+dh[i],rp.second-dw[i]};\n                if(r[toR.first][toR.second]=='#') toR=rp;\n                que.push({toL,toR});\n            }\n        }\n        \n        cout<<(isok ? \"Yes\" : \"No\")<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <fstream>\n#include <stack>\n#include <cstring>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, k, n) for (int i = (int)(k); i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rREP(i, k, n) for (int i = (int)(n)-1; i >= k; i--)\n\n#define debug(x) cerr << #x << \": \" << x << endl;\n\n#define fi first\n#define se second\n\n#define vi vector<int>\n#define pii pair<int, int>\n#define pb push_back\n#define mp make_pair\n\n#define pcnt __builtin_popcount\n\ntypedef long long ll;\n\nconst int    inf = 100100100;\nconst int    MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\nconst int    dx[4] = { 0, 1, 0, -1 };\nconst int    dy[4] = { 1, 0, -1, 0 };\n\nstruct POINT {\n    int lx;\n    int ly;\n    int rx;\n    int ry;\n};\n\nbool u[55][55][55][55] = {};\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n//    ifstream in(\"./input.txt\");\n//    cin.rdbuf(in.rdbuf());\n    int    w, h;\n    string ML[55], MR[55];\n    int slx,sly,srx,sry;\n    while (cin >> w >> h, w) {\n        memset(u,0,sizeof(u));\n        rep(y, h) cin >> ML[y] >> MR[y];\n        rep(y, h) rep(x,w){\n                if(ML[y][x] == 'L') ML[y][x] = '.',slx = x,sly = y;\n                if(MR[y][x] == 'R') ML[y][x] = '.',srx = x,sry = y;\n            }\n        stack<POINT> st;\n        st.push(POINT{slx, sly, srx, sry});\n\n        bool flag = false;\n        while (!st.empty()) {\n            POINT p = st.top();\n            st.pop();\n            if (u[p.lx][p.ly][p.rx][p.ry]) continue;\n            rep(i, 4) {\n                int nlx = p.lx + dx[i];\n                int nly = p.ly + dy[i];\n                int nrx = p.rx + dx[(i + 2) % 4];\n                int nry = p.ry + dy[i];\n                bool left_do = true;\n                bool right_do = true;\n                if (nlx < 0 || w <= nlx) left_do = false;\n                if (nly < 0 || h <= nly) left_do = false;\n                if (ML[nly][nlx] == '#') left_do = false;\n                if (nrx < 0 || w <= nrx) right_do = false;\n                if (nry < 0 || h <= nry) right_do = false;\n                if (MR[nry][nrx] == '#') right_do = false;\n                if (ML[nly][nlx] == '%' && MR[nry][nrx] == '%') {\n                    flag = true;\n                    while (!st.empty()) st.pop();\n                    break;\n                } else if (ML[nly][nlx] == '%' || MR[nry][nrx] == '%') {\n                    continue;\n                }\n                if (!left_do && !right_do) continue;\n                if (!left_do) nlx = p.lx, nly = p.ly;\n                if (!right_do) nrx = p.rx, nry = p.ry;\n                if(!u[p.lx][p.ly][p.rx][p.ry]) st.emplace(POINT{nlx, nly, nrx, nry});\n            }\n            u[p.lx][p.ly][p.rx][p.ry] = true;\n        }\n        if (flag)\n            cout << \"Yes\" << endl;\n        else\n            cout << \"No\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <deque>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <unordered_set>\n# include <unordered_map>\n# include <climits>\n# include <complex>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define MP make_pair\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define STRING(x) string x;cin>>x;\n# define STR(x) STRING(x);\n# define DOUBLE(x) double x;cin>>x;\n# define DBL(x) DOUBLE(x); \n# define ALL(x) begin(x),end(x)\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\":\"<<x<<endl\n# define INIT(a) memset(a,-1,sizeof a)\n# define CLR(a) memset(a,0,sizeof a)\n# define EPS 1e-12\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#endif\ntypedef long long lint;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<int> vi;\ntypedef vector<lint> vl;\ntypedef vector<string> vs;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\n//const int M = 1000000007;\ntemplate<class T> void debug(T a) { for ( auto i : a )cout << i << endl; }\n\n# define DEP(a) a.first,a.second\n\nint main()\n{\n\twhile ( true )\n\t{\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tif ( !w )break;\n\t\tint a[2][60][60];\n\t\tpii start[2];\n\t\tINIT(a);\n\t\tFORI(i,1, h+1)\n\t\t{\n\t\t\tFOR(j, 2)\n\t\t\t{\n\t\t\t\tstring s; cin >> s;\n\t\t\t\tFOR(k, s.size())\n\t\t\t\t{\n\t\t\t\t\ta[j][i][k + 1] = 0;\n\t\t\t\t\tif ( s[k] == '%' )\n\t\t\t\t\t{\n\t\t\t\t\t\ta[j][i][k + 1] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif ( s[k] == 'L' || s[k] == 'R' )\n\t\t\t\t\t{\n\t\t\t\t\t\tstart[j] = MP(i, k + 1);\n\t\t\t\t\t}\n\t\t\t\t\tif ( s[k] == '#' )\n\t\t\t\t\t{\n\t\t\t\t\t\ta[j][i][k + 1] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstruct P\n\t\t{\n\t\t\tint x[2], y[2];\n\t\t\tP(int lx, int ly, int rx, int ry)  { x[0] = lx; x[1] = rx; y[0] = ly; y[1] = ry; }\n\t\t};\n\n\t\tbool flag[60][60][60][60] = {};\n\n\t\tqueue<P> que;\n\t\tque.emplace(DEP(start[0]), DEP(start[1]));\n\t\tbool yes = false;\n\n\t\twhile ( !que.empty() )\n\t\t{\n\t\t\tP now = que.front(); que.pop();\n\t\t\tint l, r;\n\t\t\tl = a[0][now.x[0]][now.y[0]];\n\t\t\tr = a[1][now.x[1]][now.y[1]];\n\t\t\tif ( (l&&!r) || (!l&&r) )continue;\n\t\t\tif ( l&&r )\n\t\t\t{\n\t\t\t\tyes = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tFOR(i, 4)\n\t\t\t{\n\t\t\t\tP next = now;\n\t\t\t\tnext.x[0] += dx[i];\n\t\t\t\tnext.y[0] += dy[i];\n\n\t\t\t\tnext.x[1] += dx[i];\n\t\t\t\tnext.y[1] -= dy[i];\n\n\t\t\t\tauto check = [&a] (int x, int y, int d)->bool { return a[d][x][y] == -1; };\n\n\t\t\t\tif ( check(next.x[0], next.y[0], 0) )\n\t\t\t\t{\n\t\t\t\t\tnext.x[0] -= dx[i];\n\t\t\t\t\tnext.y[0] -= dy[i];\n\t\t\t\t}\n\n\t\t\t\tif ( check(next.x[1], next.y[1], 1) )\n\t\t\t\t{\n\t\t\t\t\tnext.x[1] -= dx[i];\n\t\t\t\t\tnext.y[1] += dy[i];\n\t\t\t\t}\n\n\t\t\t\tbool *f = &flag[next.x[0]][next.y[0]][next.x[1]][next.y[1]];\n\t\t\t\tif ( !*f )\n\t\t\t\t{\n\t\t\t\t\t*f = true;\n\t\t\t\t\tque.push(next);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tcout << (yes?\"Yes\" : \"No\") << endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//????????????????????????\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> ver;\ntypedef pair<int, ver> piv;\nint dx[2][4] = {{1, 0, -1, 0},\n                {-1, 0, 1, 0}};\nint dy[] = {0, 1, 0, -1};\n\nbool range(pii p, int w, int h){\n  if(0 <= p.first  && p.first  < w &&\n     0 <= p.second && p.second < h)return true;\n  return false;\n}\nint main(int argc, char *argv[]){\n  int w, h;\n  while(cin >> w >> h, w){\n    vector<string> grid1(h), grid2(h);\n    int sx[2], sy[2], gx[2], gy[2];\n    for (int i = 0; i < h; i++) {\n      cin >> grid1[i] >> grid2[i];\n      for (int j = 0; j < w; j++) {\n        if(grid1[i][j] == 'L')sx[0] = j, sy[0] = i;\n        if(grid1[i][j] == '%')gx[0] = j, gy[0] = i;\n        if(grid2[i][j] == 'R')sx[1] = j, sy[1] = i;\n        if(grid2[i][j] == '%')gx[1] = j, gy[1] = i;\n      }\n    }\n    int dp[h][w][h][w];\n    for (int i = 0; i < h; i++) \n      for (int j = 0; j < w; j++) \n        for (int k = 0; k < h; k++) \n          for (int l = 0; l < w; l++) \n            dp[i][j][k][l] = 1e9;\n    dp[sy[0]][sx[0]][sy[1]][sx[1]] = 0;\n    queue<piv> que;\n    que.push(piv(0, ver(pii(sx[0], sy[0]), pii(sx[1], sy[1]))));\n    while(!que.empty()){\n      pii u = que.front().second.first;\n      pii v = que.front().second.second;\n      int c = que.front().first;\n      que.pop();\n      for (int i = 0; i < 4; i++) {\n        pii a = u, b = v;\n        a.first  += dx[0][i];\n        a.second += dy[i];\n        b.first  += dx[1][i];\n        b.second += dy[i];\n        if(!range(a, w, h))\n          a = u;          \n        if(grid1[a.second][a.first] == '#')\n          a = u;\n        if(!range(b, w, h))\n          b = v;\n        if(grid2[b.second][b.first] == '#')\n          b = v;\n        if(dp[a.second][a.first][b.second][b.first] > c + 1){\n          dp[a.second][a.first][b.second][b.first] = c + 1;\n          que.push(piv(c + 1, ver(a, b)));\n        }\n      }\n    }\n    if(dp[gy[0]][gx[0]][gy[1]][gx[1]] != 1e9)\n      std::cout << \"Yes\" << std::endl;\n    else\n      std::cout << \"No\" << std::endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi acos(-1.0)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nstruct dat{\n\tint i1, j1, i2, j2;\n};\n\nbool isin(int i, int j, int h, int w){\n\treturn i >= 0 && j >= 0 && i < h && j < w;\n}\n\nint main(){\n\tint w, h;\n\twhile (cin >> w >> h && w){\n\t\tvector<string> s1(h), s2(h);\n\t\tREP(i,h) cin >> s1[i] >> s2[i];\n\t\tREP(i,h) reverse(s2[i].begin(), s2[i].end());\n\t\tint si1, sj1, si2, sj2;\n\t\tREP(i,h) REP(j,w){\n\t\t\tif (s1[i][j] == 'L') si1 = i, sj1 = j;\n\t\t\tif (s2[i][j] == 'R') si2 = i, sj2 = j;\n\t\t}\n\n\t\tdat p;\n\t\tp.i1 = si1;\n\t\tp.j1 = sj1;\n\t\tp.i2 = si2;\n\t\tp.j2 = sj2;\n\t\tqueue<dat> que;\n\t\tque.push(p);\n\n\t\tbool f[50][50][50][50] = {};\n\t\tf[si1][sj1][si2][sj2] = 1;\n\n\t\tint dx[] = {1, -1, 0, 0}, dy[] = {0, 0, 1, -1};\n\t\tbool clear = 0;\n\t\twhile (!que.empty() && !clear){\n\t\t\tdat p = que.front();\n\t\t\tque.pop();\n\t\t\tREP(k,4){\n\t\t\t\tint i1 = p.i1 + dx[k], j1 = p.j1 + dy[k];\n\t\t\t\tint i2 = p.i2 + dx[k], j2 = p.j2 + dy[k];\n\t\t\t\tif (!isin(i1,j1,h,w) || s1[i1][j1] == '#'){\n\t\t\t\t\ti1 = p.i1;\n\t\t\t\t\tj1 = p.j1;\n\t\t\t\t}\n\t\t\t\tif (!isin(i2,j2,h,w) || s2[i2][j2] == '#'){\n\t\t\t\t\ti2 = p.i2;\n\t\t\t\t\tj2 = p.j2;\n\t\t\t\t}\n\t\t\t\tif (f[i1][j1][i2][j2]) continue;\n\t\t\t\tf[i1][j1][i2][j2] = 1;\n\t\t\t\tif (s1[i1][j1] == '%' && s2[i2][j2] == '%') clear = 1;\n\t\t\t\telse if (s1[i1][j1] == '%' || s2[i2][j2] == '%') continue;\n\t\t\t\tdat q;\n\t\t\t\tq.i1 = i1;\n\t\t\t\tq.j1 = j1;\n\t\t\t\tq.i2 = i2;\n\t\t\t\tq.j2 = j2;\n\t\t\t\tque.push(q);\n\t\t\t}\n\t\t}\n\t\tcout << (clear ? \"Yes\" : \"No\") << endl;\n\t}\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing psi=pair<string,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define MOD (1e9+7)\nvoid get(){}template<class H,class...T>void get(H&h,T&...t){cin>>h;get(t...);}\ntemplate<class T>void geti(T&a){for(auto&_:a)cin>>_;}\ntemplate<class T>void getii(T&a){for(auto&_:a)geti(_);}\nvoid put(string d){}template<class H,class...T>void put(string d,H&h,T&...t){cout<<h;if(sizeof...(t))cout<<d;put(d,t...);}\ntemplate<class T>void puti(T&a,string d=\" \"){bool f=1;for(auto&_:a)cout<<(exchange(f,0)?\"\":d)<<_;cout<<endl;}\ntemplate<class T>void putii(T&a,string d=\" \"){for(auto&_:a)puti(_,d);}\n#define dcl(...) ll __VA_ARGS__;get(__VA_ARGS__)\n#define dclt(t,...) t __VA_ARGS__;get(__VA_ARGS__)\n\nint main(){\n\tint w,h;\n\twhile(cin>>w>>h,w){\n\t\tvector<vvi> f(2,vvi(h+2,vi(w+2,1)));\n\t\tvvi curr(2,vi(2));\n\t\tvvi stat(2,vi(2));\n\t\tfor(int i=1;i<=h;i++){\n\t\t\trep(p,2){\n\t\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\t\tchar c; cin>>c;\n\t\t\t\t\tif(c=='.'){\n\t\t\t\t\t\tf[p][i][j]=0;\n\t\t\t\t\t}else if(c=='%'){\n\t\t\t\t\t\tf[p][i][j]=0;\n\t\t\t\t\t\tstat[p]={i,j};\n\t\t\t\t\t}else if(c=='L'){\n\t\t\t\t\t\tf[p][i][j]=0;\n\t\t\t\t\t\tcurr[0]={i,j};\n\t\t\t\t\t}else if(c=='R'){\n\t\t\t\t\t\tf[p][i][j]=0;\n\t\t\t\t\t\tcurr[1]={i,w+1-j};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treverse(all(f[1][i]));\n\t\t}\n\t\tstat[1][1]=w+1-stat[1][1];\n\t\t//putii(f[0],\"\");\n\t\t//cout<<endl;\n\t\t//putii(f[1],\"\");\n\t\t//cout<<\"=======\"<<endl;\n\t\t\n\t\t/*幅優先\n\t\t\t・どちらか片方だけ動き、動いた先がゴールでない場合\n\t\t\t・両方動き、かつ少なくともどちらかがそのマスを訪れたことがない場合\n\t\t\tだけ、探索する\n\t\t*/\n\t\tset<vvi> isVisited;\n\t\t//isVisited.insert(curr);\n\n\t\tqueue<vvi> que;\n\t\tque.push(curr);\n\t\tint y[]={-1,0,1,0};\n\t\tint x[]={0,1,0,-1};\n\t\tauto step=[f](vi &pos,int lr, int y, int x){\n\t\t\tif(f[lr][pos[0]+y][pos[1]+x]!=1){\n\t\t\t\tpos[0]+=y;\n\t\t\t\tpos[1]+=x;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tbool ok=false;\n\t\twhile(!que.empty()){\n\t\t\tauto c=que.front();\n\t\t\tque.pop();\n\t\t\t//cout<<c[0][0]<<\",\"<<c[0][1]<<\"  \"<<c[1][0]<<\",\"<<c[1][1]<<endl;\n\t\t\tif(c==stat){\n\t\t\t\tok=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(isVisited.find(c)!=isVisited.end()){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tisVisited.insert(c);\n\t\t\trep(v,4){\n\t\t\t\tauto next=c;\n\t\t\t\tbool l=step(next[0],0,y[v],x[v]);\n\t\t\t\tbool r=step(next[1],1,y[v],x[v]);\n\t\t\t\tif(isVisited.find(next)==isVisited.end()){\n\t\t\t\t\tif( (!l and r and next[1]!=stat[1])\n\t\t\t\t\t\tor (l and !r and next[0]!=stat[0])\n\t\t\t\t\t\tor ( l and r and !(next[0]!=stat[0] xor next[1]!=stat[1]) )){\n\t\t\t\t\t\t//cout<<\" o \"<<next[0][0]<<\",\"<<next[0][1]<<\"  \"<<next[1][0]<<\",\"<<next[1][1]<<endl;\n\t\t\t\t\t\tque.push(next);\n\t\t\t\t\t}else{\n\t\t\t\t\t\t//cout<<\" x \"<<next[0][0]<<\",\"<<next[0][1]<<\"  \"<<next[1][0]<<\",\"<<next[1][1]<<endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t}else{\n\t\t\tcout<<\"No\"<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int GOAL = 1;\nconst int WAY = 0;\nconst int WALL = -1;\n\nconst int dx[4] = {-1, 1, 0, 0};\nconst int dy[4] = {0, 0, -1, 1};\n\nstruct state {\n\tint l_x, l_y, r_x, r_y;\n\tstate(int l_x, int l_y, int r_x, int r_y):l_x(l_x), l_y(l_y), r_x(r_x), r_y(r_y) {}\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int w, h; cin >> w >> h, w;) {\n\t\tvector<vector<int> > l_map(h + 2, vector<int>(w + 2, WALL));\n\t\tvector<vector<int> > r_map(h + 2, vector<int>(w + 2, WALL));\n\n\t\tint l_sx, l_sy, r_sx, r_sy;\n\t\tfor(int i = 1; i <= h; ++i) {\n\t\t\tstring l, r;\n\t\t\tcin >> l >> r;\n\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tswitch(l[j]) {\n\t\t\t\tcase '%':\n\t\t\t\t\tl_map[i][j + 1] = GOAL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tl_map[i][j + 1] = WALL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\tl_sx = j + 1;\n\t\t\t\t\tl_sy = i;\n\t\t\t\tdefault:\n\t\t\t\t\tl_map[i][j + 1] = WAY;\n\t\t\t\t}\n\n\t\t\t\tswitch(r[j]) {\n\t\t\t\tcase '%':\n\t\t\t\t\tr_map[i][j + 1] = GOAL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tr_map[i][j + 1] = WALL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tr_sx = j + 1;\n\t\t\t\t\tr_sy = i;\n\t\t\t\tdefault:\n\t\t\t\t\tr_map[i][j + 1] = WAY;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstack<state> sta;\n\t\tsta.push(state(l_sx, l_sy, r_sx, r_sy));\n\t\tbool reachable = false;\n\t\tbool visited[52][52][52][52] = {};\n\n\t\twhile(!sta.empty()) {\n\t\t\tconst state& s = sta.top();\n\t\t\tint l_x = s.l_x, l_y = s.l_y, r_x = s.r_x, r_y = s.r_y;\n\t\t\tsta.pop();\n\n\t\t\tvisited[l_x][l_y][r_x][r_y] = true;\n\n\t\t\tif(l_map[l_y][l_x] == GOAL && r_map[r_y][r_x] == GOAL) {\n\t\t\t\treachable = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(l_map[l_y][l_x] == GOAL || r_map[r_y][r_x] == GOAL)\n\t\t\t\tcontinue;\n\n\t\t\t\t\t\t\n\t\t\tfor(int i = 0; i < 4; ++i) {\n\t\t\t\tint l_nx = l_x + dx[i], l_ny = l_y + dy[i], r_nx = r_x - dx[i], r_ny = r_y + dy[i];\n\t\t\t\tif(l_map[l_ny][l_nx] == WALL) {\n\t\t\t\t\tl_nx = l_x;\n\t\t\t\t\tl_ny = l_y;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(r_map[r_ny][r_nx] == WALL) {\n\t\t\t\t\tr_nx = r_x;\n\t\t\t\t\tr_ny = r_y;\n\t\t\t\t}\n\n\t\t\t\tif(!visited[l_nx][l_ny][r_nx][r_ny])\n\t\t\t\t\tsta.push(state(l_nx, l_ny, r_nx, r_ny));\n\t\t\t}\n\t\t}\n\n\t\tcout << (reachable ? \"Yes\" : \"No\") << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <queue>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nP ls, rs, lg, rg;\nint dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0}, h, w;\nbool f[52][52][52][52];\nchar lf[52][53],rf[52][53]; \n\nint range(int a,int b){\n\treturn a >= 0 && a < h && b >= 0 && b < w;\n}\n\nint bfs(){\n\tint i, lx, ly, rx, ry;\n\tqueue<PP> que;\n\tque.push(PP(ls,rs));\n\twhile(que.size()){\n\t\tlx = que.front().first.second,ly = que.front().first.first,rx = que.front().second.second, ry = que.front().second.first;\n\t\tque.pop();\n\t\tif(lg.first == ly && lg.second == lx || rg.first == ry && rg.second == rx){\n\t\t\tif(lg.first == ly && lg.second == lx && rg.first == ry && rg.second == rx)\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\t\tfor(i = 0;i < 4;i++){\n\t\t\t\tif(lf[ly + dy[i]][lx + dx[i]] != '#' && rf[ry + dy[i]][rx - dx[i]] != '#' && f[ly + dy[i]][lx + dx[i]][ry + dy[i]][rx - dx[i]]){\n\t\t\t\t\tf[ly + dy[i]][lx + dx[i]][ry + dy[i]][rx - dx[i]] = 0;\n\t\t\t\t\tque.push(PP(P(ly + dy[i],lx + dx[i]),P(ry + dy[i],rx - dx[i])));\n\t\t\t\t}\n\t\t\t\telse if(lf[ly + dy[i]][lx + dx[i]] != '#' && rf[ry + dy[i]][rx - dx[i]] == '#' && f[ly + dy[i]][lx + dx[i]][ry][rx]){\n\t\t\t\t\tf[ly + dy[i]][lx + dx[i]][ry][rx] = 0;\n\t\t\t\t\tque.push(PP(P(ly + dy[i],lx + dx[i]),P(ry,rx)));\n\t\t\t\t}//\n\t\t\t\telse if(lf[ly + dy[i]][lx + dx[i]] == '#' && rf[ry + dy[i]][rx - dx[i]] != '#' && f[ly][lx][ry + dy[i]][rx - dx[i]]){\n\t\t\t\t\tf[ly][lx][ry + dy[i]][rx - dx[i]] = 0;\n\t\t\t\t\tque.push(PP(P(ly,lx),P(ry + dy[i],rx - dx[i])));\n\t\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(void){\n\tint i, j;\n\twhile(1){\n\t\tscanf(\"%d%d%*c\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tlf[i + 1][j + 1] = getchar();\n\t\t\t\tif(lf[i + 1][j + 1] == 'L'){\n\t\t\t\t\tls = P(i + 1,j + 1);\n\t\t\t\t\tlf[i + 1][j + 1] = '.';\n\t\t\t\t}\n\t\t\t\telse if(lf[i + 1][j + 1] == '%'){\n\t\t\t\t\tlg = P(i + 1,j + 1);\n\t\t\t\t\tlf[i + 1][j + 1] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 空白読み飛ばし\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\trf[i + 1][j + 1] = getchar();\n\t\t\t\tif(rf[i + 1][j + 1] == 'R'){\n\t\t\t\t\trs = P(i + 1,j + 1);\n\t\t\t\t\trf[i + 1][j + 1] = '.';\n\t\t\t\t}\n\t\t\t\telse if(rf[i + 1][j + 1] == '%'){\n\t\t\t\t\trg = P(i + 1,j + 1);\n\t\t\t\t\trf[i + 1][j + 1] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 改行文字読み飛ばし\n\t\t}\n\t\tfor(i = 0;i < h + 2;i++){\n\t\t\tlf[i][0] = rf[i][0] = '#';\n\t\t\tlf[i][w + 1] = rf[i][w + 1] = '#';\n\t\t}\n\t\tfor(i = 0;i < w + 2;i++){\n\t\t\tlf[0][i] = rf[0][i] = '#';\n\t\t\tlf[h + 1][i] = rf[h + 1][i] = '#';\n\t\t}\n\t\tmemset(f,-1,sizeof(f));\n\t\tf[ls.first][ls.second][rs.first][rs.second] = 0;\n\t\tif(bfs())\n\t\t\tprintf(\"Yes\\n\");\n\t\telse\n\t\t\tprintf(\"No\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\nint const dxL[] = {-1,0,1,0};\nint const dxR[] = {1,0,-1,0};\nint const dy[]  = {0,-1,0,1};\ntypedef pair<int, int> Pii;\n#define X first\n#define Y second\nint const INF = 1<<28;\nint W, H;\nchar grL[51][51], grR[51][51];\nint dist[300][300];\ninline bool inF(int x, int y, int isL) {\n  if(0<=x&&x<W && 0<=y&&y<H) {\n    if(isL) return grL[y][x]!='#';\n    else return grR[y][x]!='#';\n  }\n  return false;\n}\ninline int toNode(int x, int y) {\n  return y*W+x;\n}\ninline void toPos(int node, int &x, int &y) {\n  x = node%W, y = node/W;\n}\nint main() {\n  \n  while(cin >> W >> H && (W|H)) {\n    int sxL, syL, sxR, syR;\n    int gxL, gyL, gxR, gyR;\n    for(int i=0; i<H; i++) {\n      for(int j=0; j<2*W; j++) {\n        if(j<W) {\n          cin >> grL[i][j];\n          if(grL[i][j] == 'L') {\n            sxL = j, syL = i;\n          }\n          if(grL[i][j] == '%') {\n            gxL = j, gyL = i;\n          }\n        }\n        else {\n          cin >> grR[i][j-W];\n          if(grR[i][j-W] == 'R') {\n            sxR = j-W, syR = i;\n          }\n          if(grR[i][j-W] == '%') {\n            gxR = j-W, gyR = i;\n          }\n        }\n      }\n    }\n    \n    queue<int> qCost;\n    queue<int> qL, qR;\n    qL.push(toNode(sxL, syL)); qR.push(toNode(sxR, syR));\n    bool ok = false;\n    fill(dist[0], dist[0]+300*300, INF);\n    dist[toNode(sxL, syL)][toNode(sxR, syR)] = 0;\n    while(!qL.empty()) {\n      int nowL = qL.front(); qL.pop();\n      int nowR = qR.front(); qR.pop();\n      if(nowL < 0) return 0;\n      if(nowR < 0) return 0;\n      int lx, ly; toPos(nowL, lx, ly);\n      int rx, ry; toPos(nowR, rx, ry);\n      if(lx == gxL && ly == gyL && rx == gxR && ry == gyR) {\n        ok = true; break;\n      }\n      if(lx == gxL && ly == gyL) {\n        continue;\n      }\n      if(rx == gxR && ry == gyR) {\n        continue;\n      }\n      for(int i=0; i<4; i++) {\n        int nxL = lx+dxL[i], nyL = ly+dy[i];\n        int nxR = rx+dxR[i], nyR = ry+dy[i];\n        if(!inF(nxL, nyL, 1) && !inF(nxR, nyR, 0)) continue;\n        if(!inF(nxL, nyL, 1)) { nxL = lx, nyL = ly; }\n        if(!inF(nxR, nyR, 0)) { nxR = rx, nyR = ry; }\n        if(dist[toNode(nxL, nyL)][toNode(nxR, nyR)] != INF) continue;\n        qL.push(toNode(nxL, nyL));\n        qR.push(toNode(nxR, nyR));\n        dist[toNode(nxL, nyL)][toNode(nxR, nyR)] = dist[nowL][nowR]+1;\n      }\n    }\n    if(ok) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct data{\n    int ly,lx,ry,rx;\n    data(int ly,int lx,int ry,int rx)\n        :ly(ly),lx(lx),ry(ry),rx(rx){}\n};\n\nconst int dlx[]={-1,0,1,0},dly[]={0,-1,0,1};\nconst int drx[]={1,0,-1,0},dry[]={0,-1,0,1};\n\nconst int INF=1001001001;\nint H,W;\nchar L[51][51],R[51][51];\nint dist[50][50][50][50];\nint sly,slx,sry,srx;\nint gly,glx,gry,grx;\nbool ok(int y,int x,int isL){\n    if(isL)return !(y<0||y>=H||x<0||x>=W||L[y][x]=='#');\n    return !(y<0||y>=H||x<0||x>=W||R[y][x]=='#');\n}\n\nvoid solve(){\n    queue<data>que;\n    fill_n(***dist,50*50*50*50,INF);\n    dist[sly][slx][sry][srx]=0;\n    que.push(data(sly,slx,sry,srx));\n\n    while(que.size()){\n        data d=que.front();que.pop();\n\n        for(int i=0;i<4;i++){\n            int nly=d.ly+dly[i],nlx=d.lx+dlx[i];\n            int nry=d.ry+dry[i],nrx=d.rx+drx[i];\n            if(!ok(nly,nlx,true)){\n                nly=d.ly;nlx=d.lx;\n            }\n            if(!ok(nry,nrx,false)){\n                nry=d.ry;nrx=d.rx;\n            }\n\n            if(dist[nly][nlx][nry][nrx]!=INF)continue;\n            dist[nly][nlx][nry][nrx]=dist[d.ly][d.lx][d.ry][d.rx]+1;\n            if((gly==nly&&glx==nlx)&&!(gry==nry&&grx==nrx))continue;\n            if(!(gly==nly&&glx==nlx)&&(gry==nry&&grx==nrx))continue;\n            que.push(data(nly,nlx,nry,nrx));\n        }\n    }\n\n    if(dist[gly][glx][gry][grx]!=INF)cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n}\n\nint main(){\n    while(cin>>W>>H,W||H){\n        for(int i=0;i<H;i++)cin>>L[i]>>R[i];\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                if(L[i][j]=='L'){\n                    sly=i;slx=j;\n                }\n                if(L[i][j]=='%'){\n                    gly=i;glx=j;\n                }\n                if(R[i][j]=='R'){\n                    sry=i;srx=j;\n                }\n                if(R[i][j]=='%'){\n                    gry=i;grx=j;\n                }\n            }\n        }\n\n        solve();\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<cstring>\n#include<map>\nusing namespace std;\ntypedef pair< int, int > Pi;\n\nbool used[50][50][50][50];\nchar masL[50][50], masR[50][50];\nint W, H;\nPi RinS, LenS; //スタート\nconst int dy[] = { 1, 0, -1, 0}, dx[] = { 0, 1, 0, -1};\n\nint bfs(){\n  queue< Pi > Rin, Len;\n  Rin.push(RinS);\n  Len.push(LenS);\n  used[RinS.first][RinS.second][LenS.first][LenS.second] = true;\n  while(!Rin.empty()){\n    Pi r = Rin.front(), l = Len.front();\n    Rin.pop(), Len.pop();\n    if(masL[l.first][l.second] == '%' && masR[r.first][r.second] == '%'){\n      return true;\n    }\n    if(masL[l.first][l.second] != '%' || masR[r.first][r.second] != '%'){\n      for(int i = 0; i < 4; i++){\n        int rny = min( H - 1, max( 0, r.first + dy[i]));\n        int rnx = min( W - 1, max( 0, r.second + dx[i]));\n        int lny = min( H - 1, max( 0, l.first + dy[i]));\n        int lnx = min( W - 1, max( 0, l.second - dx[i]));\n        //めんどい\n        if(masR[lny][lnx] == '#'){ //元の位置に戻す！！\n          lny = l.first, lnx = l.second;\n        }\n        if(masL[rny][rnx] == '#'){\n          rny = r.first, rnx = r.second;\n        }\n        \n        if(!used[rny][rnx][lny][lnx]){\n          used[rny][rnx][lny][lnx] = true;\n          Rin.push( Pi( rny, rnx)), Len.push( Pi( lny, lnx));\n        }\n      }\n    }\n  }\n  return false; //いけない!!\n}\nint main()\n{\n  while(cin >> W >> H, W){\n    memset( used, false, sizeof(used));\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n        cin >> masL[i][j];\n        if(masL[i][j] == 'L'){\n          LenS = Pi( i, j);\n          masL[i][j] = '.';\n        }\n      }\n      for(int j = 0; j < W; j++){\n        cin >> masR[i][j];\n        if(masR[i][j] == 'R'){\n          RinS = Pi( i, j);\n          masR[i][j] = '.';\n        }\n      }\n    }\n    bool judge = bfs();\n    if(judge) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\ntypedef vector<vvi> vvvi;\n\nint ldx[] = {0, 1, 0, -1};\nint rdx[] = {0, -1, 0, 1};\nint dy[] = {-1, 0, 1, 0};\n\nstruct state {\n\tpii l, r;\n\tstate(pii l, pii r) : l(l), r(r) {};\n};\n\nint main() {\n\tint W, H;\n\twhile(cin >> W >> H, W) {\n\t\tvs roomL(H), roomR(H);\n\t\tint lsx, lsy, rsx, rsy;\n\t\tREP(i, H) {\n\t\t\tcin >> roomL[i] >> roomR[i];\n\t\t\tif(roomL[i].find(\"L\") != string::npos) {\n\t\t\t\tlsx = roomL[i].find(\"L\");\n\t\t\t\tlsy = i;\n\t\t\t}\n\t\t\tif(roomR[i].find(\"R\") != string::npos) {\n\t\t\t\trsx = roomR[i].find(\"R\");\n\t\t\t\trsy = i;\n\t\t\t}\n\t\t}\n\n\t\tvector<vvvi> visited(H, vvvi(W, vvi(H, vi(W))));\n\t\tqueue<state> Q;\n\t\tQ.push(state(make_pair(lsy, lsx), make_pair(rsy, rsx)));\n\t\tbool goal = false;\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.front();\n\t\t\tQ.pop();\n\n\t\t\tif(roomL[st.l.first][st.l.second] == '%' && roomR[st.r.first][st.r.second] == '%') {\n\t\t\t\tgoal = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tREP(d, 4) {\n\t\t\t\tint lny = st.l.first + dy[d];\n\t\t\t\tint lnx = st.l.second + ldx[d];\n\t\t\t\tif(lny < 0 || H <= lny || lnx < 0 || W <= lnx || roomL[lny][lnx] == '#') {\n\t\t\t\t\tlny = st.l.first;\n\t\t\t\t\tlnx = st.l.second;\n\t\t\t\t}\n\t\t\t\tint rny = st.r.first + dy[d];\n\t\t\t\tint rnx = st.r.second + rdx[d];\n\t\t\t\tif(rny < 0 || H <= rny || rnx < 0 || W <= rnx || roomR[rny][rnx] == '#') {\n\t\t\t\t\trny = st.r.first;\n\t\t\t\t\trnx = st.r.second;\n\t\t\t\t}\n\n\t\t\t\tif(!visited[lny][lnx][rny][rnx]) {\n\t\t\t\t\tvisited[lny][lnx][rny][rnx] = 1;\n\t\t\t\t\tQ.push(state(make_pair(lny, lnx), make_pair(rny, rnx)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << (goal ? \"Yes\" : \"No\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n\nusing namespace std;\nint const dxL[] = {-1,0,1,0};\nint const dxR[] = {1,0,-1,0};\nint const dy[]  = {0,-1,0,1};\ntypedef pair<int, int> Pii;\n#define X first\n#define Y second\nint W, H;\nchar grL[51][51], grR[51][51];\ninline bool inF(int x, int y, int isL) {\n  if(0<=x&&x<W && 0<=y&&y<H) {\n    if(isL) return grL[y][x]!='#';\n    else return grR[y][x]!='#';\n  }\n  return false;\n}\nint main() {\n  \n  while(cin >> W >> H && (W|H)) {\n    int sxL, syL, sxR, syR;\n    int gxL, gyL, gxR, gyR;\n    for(int i=0; i<H; i++) {\n      for(int j=0; j<2*W; j++) {\n        if(j<W) {\n          cin >> grL[i][j];\n          if(grL[i][j] == 'L') {\n            sxL = j, syL = i;\n          }\n          if(grL[i][j] == '%') {\n            gxL = j, gyL = i;\n          }\n        }\n        else {\n          cin >> grR[i][j-W];\n          if(grR[i][j-W] == 'R') {\n            sxR = j-W, syR = i;\n          }\n          if(grR[i][j-W] == '%') {\n            gxR = j-W, gyR = i;\n          }\n        }\n      }\n    }\n    \n    map<pair<pair<int,int>, pair<int,int> >, int > mp;\n    queue<int> qCost;\n    queue<Pii> qL, qR;\n    qCost.push(0);\n    qL.push(make_pair(sxL, syL)); qR.push(make_pair(sxR, syR));\n    bool ok = false;\n    while(!qL.empty()) {\n      Pii nowL = qL.front(); qL.pop();\n      Pii nowR = qR.front(); qR.pop();\n      int cost = qCost.front(); qCost.pop();\n      if(mp.find(make_pair(nowL, nowR)) != mp.end()) continue;\n      mp[make_pair(nowL, nowR)] = cost;\n      if(nowL.X == gxL && nowL.Y == gyL && nowR.X == gxR && nowR.Y == gyR) {\n        ok = true; break;\n      }\n      if(nowL.X == gxL && nowL.Y == gyL) {\n        continue;\n      }\n      if(nowR.X == gxR && nowR.Y == gyR) {\n        continue;\n      }\n      for(int i=0; i<4; i++) {\n        int nxL = nowL.X+dxL[i], nyL = nowL.Y+dy[i];\n        int nxR = nowR.X+dxR[i], nyR = nowR.Y+dy[i];\n        if(!inF(nxL, nyL, 1) && !inF(nxR, nyR, 0)) continue;\n        if(!inF(nxL, nyL, 1)) { nxL = nowL.X, nyL = nowL.Y; }\n        if(!inF(nxR, nyR, 0)) { nxR = nowR.X, nyR = nowR.Y; }\n        if(mp.find(make_pair(make_pair(nxL, nyL), make_pair(nxR, nyR))) != mp.end()) continue;\n        qCost.push(cost+1);\n        qL.push(make_pair(nxL, nyL));\n        qR.push(make_pair(nxR, nyR));\n      }\n    }\n    if(ok) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<n; i++)\n\nconst int dx[2][4] = {{1, 0, -1, 0}, {1, 0, -1, 0}};\nconst int dy[2][4] = {{0, 1, 0, -1}, {0, -1, 0, 1}};\nconst int MAX_W = 55;\nconst int MAX_H = 55;\nchar maze[2][MAX_H][MAX_W+1];\nint sx[2], sy[2];\nint tx[2], ty[2];\nint h, w;\n\ninline bool check(int hx, int hy){ return 0 <= hx && hx < h && 0 <= hy && hy < w; }\n\nint main()\n{\n  while(cin >> w >> h, w){\n    rep(i, h){\n      rep(j, w) cin >> maze[0][i][j];\n      rep(j, w) cin >> maze[1][i][j];\n    }\n\n    rep(i, h) rep(j, w) if(maze[0][i][j] == 'L') sx[0] = i,  sy[0] = j;\n    rep(i, h) rep(j, w) if(maze[0][i][j] == '%') tx[0] = i,  ty[0] = j;\n    rep(i, h) rep(j, w) if(maze[1][i][j] == 'R') sx[1] = i,  sy[1] = j;\n    rep(i, h) rep(j, w) if(maze[1][i][j] == '%') tx[1] = i,  ty[1] = j;\n\n    queue<vector<int> > que;\n    vector<int> tmp(4);\n    tmp[0] = sx[0];\n    tmp[1] = sy[0];\n    tmp[2] = sx[1];\n    tmp[3] = sy[1];\n    que.push(tmp);\n    map<vector<int>, bool> used;\n    used[tmp] = true;\n    bool ok = false;\n    while(!que.empty()){\n      vector<int> h = que.front();  que.pop();\n      if(h[0] == tx[0] && h[1] == ty[0] && h[2] == tx[1] && h[3] == ty[1]){\n        ok = true;\n        break;\n      }\n      rep(k, 4){\n        int nx[2] = {h[0] + dx[0][k], h[2] + dx[1][k]};\n        int ny[2] = {h[1] + dy[0][k], h[3] + dy[1][k]};\n        if(!check(nx[0], ny[0]) && !check(nx[1], ny[1])) continue;\n        if((nx[0] == tx[0] && ny[0] == ty[0]) && (nx[1] != tx[1] || ny[1] != ty[1])) continue;\n        if((nx[0] != tx[0] || ny[0] != ty[0]) && (nx[1] == tx[1] && ny[1] == ty[1])) continue;\n        if(check(nx[0], ny[0]) && maze[0][nx[0]][ny[0]] != '#'){\n          tmp[0] = nx[0];\n          tmp[1] = ny[0];\n        }\n        else{\n          tmp[0] = h[0];\n          tmp[1] = h[1];\n        }\n        if(check(nx[1], ny[1]) && maze[1][nx[1]][ny[1]] != '#'){\n          tmp[2] = nx[1];\n          tmp[3] = ny[1];\n        }\n        else{\n          tmp[2] = h[2];\n          tmp[3] = h[3];\n        }\n        if(h != tmp && !used[tmp]){\n          used[tmp] = true;\n          que.push(tmp);\n        }\n      }\n    }\n\n    puts(ok ? \"Yes\" : \"No\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <set>\n#include <queue>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint range(int a,int b,int h, int w){\n\treturn a >= 0 && a < h && b >= 0 && b < w;\n}\n\nint main(void){\n\tint dl[50][50][50][50], h, w, i, j, a, b, c, d, dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\n\tchar rf[50][51], lf[50][51];\n\tP rs, ls, rg, lg;\n\tqueue<pair<P,P> >que;\n\twhile(1){\n\t\tscanf(\"%d%d%*c\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tlf[i][j] = getchar();\n\t\t\t\tif(lf[i][j] == 'L'){\n\t\t\t\t\tls = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(lf[i][j] == '%'){\n\t\t\t\t\tlg = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 空白読み飛ばし\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\trf[i][j] = getchar();\n\t\t\t\tif(rf[i][j] == 'R'){\n\t\t\t\t\trs = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(rf[i][j] == '%'){\n\t\t\t\t\trg = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 改行文字読み飛ばし\n\t\t}\n\t\tmemset(dl,0,sizeof(dl));\n\t\tque.push(pair<P,P>(ls,rs));\n\t\tdl[ls.first][ls.second][rs.first][rs.second] = 1;\n\t\twhile(que.size()){\n\t\t\ta = que.front().first.first, b = que.front().first.second, c = que.front().second.first, d = que.front().second.second;\n\t\t\tque.pop();\n\t\t\tif(a == lg.first && b == lg.second && c == rg.first && d == rg.second)\n\t\t\t\tbreak;\n\t\t\tif(a == lg.first && b == lg.second || c == rg.first && d == rg.second)\n\t\t\t\tcontinue;\n\t\t\tfor(i = 0;i < 4;i++){\n\t\t\t\tif(range(a + dy[i],b + dx[i],h,w) && range(c + dy[i],d - dx[i],h,w)){ // 両方とも動くとき\n\t\t\t\t\tif(lf[a + dy[i]][b + dx[i]] == '.'  && rf[c + dy[i]][d - dx[i]] == '.' && !dl[a + dy[i]][b + dx[i]][c + dy[i]][d - dx[i]]){\n\t\t\t\t\t\tque.push(pair<P,P>(P(a + dy[i],b + dx[i]),P(c + dy[i],d - dx[i])));\n\t\t\t\t\t\tdl[a + dy[i]][b + dx[i]][c + dy[i]][d - dx[i]] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(lf[a + dy[i]][b + dx[i]] == '#' && rf[c + dy[i]][d - dx[i]] == '.' && !dl[a][b][c + dy[i]][d - dx[i]]){// Rinだけ動く\n\t\t\t\t\t\tque.push(pair<P,P>(P(a,b),P(c + dy[i],d - dx[i])));\n\t\t\t\t\t\tdl[a][b][c + dy[i]][d - dx[i]] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(lf[a + dy[i]][b + dx[i]] == '.' && rf[c + dy[i]][d - dx[i]] == '#' && !dl[a + dy[i]][b + dx[i]][c][d]){ // Lenだけ動く\n\t\t\t\t\t\tque.push(pair<P,P>(P(a + dy[i],b + dx[i]),P(c,d)));\n\t\t\t\t\t\tdl[a + dy[i]][b + dx[i]][c][d] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(que.size())\n\t\t\tque.pop();\n\t\tif(dl[lg.first][lg.second][rg.first][rg.second])\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<map>\nusing namespace std;\nint dx[4] = {0,0,1,-1};\nint dy[4] = {1,-1,0,0};\nint main(){\n  int W,H;\n  while(cin >>W>>H,W||H){\n    int roomL[60][60],roomR[60][60];\n    int RSX,RSY,LSX,LSY,RGX,RGY,LGX,LGY;\n    for(int i=0; i<60; i++) for(int j=0; j<60; j++) roomL[i][j] = roomR[i][j] = -1;\n    for(int i=0; i<H; i++){\n      string s;\n      cin >>s;\n      for(int j=0; j<W; j++){\n\tif(s[j] == '%'){LGX = j+5; LGY = i+5;}\n\tif(s[j] == '#') roomL[j+5][i+5] = -1;\n\tif(s[j] == '.') roomL[j+5][i+5] = 0;\n\tif(s[j] == 'L'){LSX = j+5; LSY = i+5;}\n      }\n      cin >>s;\n      for(int j=0; j<W; j++){\n\tif(s[j] == '%'){RGX = j+5; RGY = i+5;}\n\tif(s[j] == '#') roomR[j+5][i+5] = -1;\n\tif(s[j] == '.') roomR[j+5][i+5] = 0;\n\tif(s[j] == 'R'){RSX = j+5; RSY = i+5;}\n      }\n    }\n    set<pair<pair<int,int>,pair<int,int> > > log;\n    log.insert(make_pair(make_pair(LSX,LSY),make_pair(RSX,RSY)));\n    set<pair<pair<int,int>,pair<int,int> > > next;\n    for(int i=0; i<100; i++){\n      for(set<pair<pair<int,int>,pair<int,int> > >::iterator it = log.begin(); it!=log.end(); it++){\n\tint lx,ly,rx,ry,lnx,lny,rnx,rny;\n\tlx = (it->first).first;\n\tly = (it->first).second;\n\trx = (it->second).first;\n\try = (it->second).second;\n\tfor(int i=0; i<4; i++){\n\t  if(rx+dx[i] == RGX && ry+dy[i] == RGY){\n\t    if(lx-dx[i] == LGX && ly+dy[i] == LGY){cout <<\"Yes\"<<endl;goto flag;}\n\t    continue;\n\t  }\n\t  if(lx-dx[i] == LGX && ly+dy[i] == LGY) continue;\n\t  if(roomR[rx+dx[i]][ry+dy[i]] == -1){rnx = rx;rny = ry;}\n\t  else if(roomR[rx+dx[i]][ry+dy[i]] == 0){rnx = rx+dx[i];rny = ry+dy[i];}\n\t  if(roomL[lx-dx[i]][ly+dy[i]] == -1){lnx = lx;lny = ly;}\n\t  else if(roomL[lx-dx[i]][ly+dy[i]] == 0){lnx = lx-dx[i];lny = ly+dy[i];}\n\t  next.insert(make_pair(make_pair(lnx,lny),make_pair(rnx,rny)));\n\t}\n      }\n      log = next;\n    }\n    cout <<\"No\"<<endl;\n  flag:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n\nbool b[103][52][103][52] = {};\n\n\nint main() {\n\n  while( true ) {\n\n    long long int w, h;\n    cin >> w >> h;\n\n    if ( w == 0 ) break;\n\n    vector< string > map;\n\n    map.push_back( \"##############################################################################################################\" );\n\n    long long int rx, ry, lx, ly;\n\n    for ( long long int y = 1; y <= h; y++ ) {\n\n      string in_L, in_R;\n      cin >> in_L >> in_R;\n\n      string in = \"#\" + in_L + \"#\" + in_R + \"#\";\n      map.push_back( in );\n\n      for ( long long int x = 0; x < in.size(); x++ ) {\n\n\tif ( map[y][x] == 'R' ) {\n\t  rx = x;\n\t  ry = y;\n\t}\n\tif ( map[y][x] == 'L' ) {\n\t  lx = x;\n\t  ly = y;\n\t}\n\n      }\n\n    }\n\n    map.push_back( \"##############################################################################################################\" );\n\n\n    for ( long long int y = 0; y < map.size(); y++ ) {\n      for ( long long int x = 0; x < map[0].size(); x++ ) {\n\tfor ( long long int y2 = 0; y2 < map.size(); y2++ ) {\n\t  for ( long long int x2 = 0; x2 < map[0].size(); x2++ ) {\n\t    b[y][x][y2][x2] = false;\n\t  }\n\t}\n      }\n    }\n\n\n    queue< vector< long long int > > q;\n    vector< long long int > v;\n    v.push_back( rx );\n    v.push_back( ry );\n    v.push_back( lx );\n    v.push_back( ly );\n    q.push( v );\n\n\n    while( q.size() > 0 ) {\n\n      rx = q.front()[0];\n      ry = q.front()[1];\n      lx = q.front()[2];\n      ly = q.front()[3];\n      q.pop();\n\n      if ( b[ ry ][ rx ][ ly ][ lx ] == true ) continue;\n\n      b[ ry ][ rx ][ ly ][ lx ] = true;\n\n\n      if ( map[ry][rx] == '%' && map[ly][lx] == '%' ) {\n\tcout << \"Yes\" << endl;\n\treturn 0;\n      }else if ( map[ry][rx] == '%' ) {\n\tcout << \"No\" << endl;\n\treturn 0;\n      }else if ( map[ly][lx] == '%' ) {\n\tcout << \"No\" << endl;\n\treturn 0;\n      }\n\n      //      cout << rx << \" \" << ry << \" \" << lx << \" \" << ly << endl;\n\n\n      v.clear();\n      if ( map[ ry ][ rx + 1 ] == '#' ) {\n\tv.push_back( rx );\n      }else {\n\tv.push_back( rx + 1 );\n      }\n      v.push_back( ry );\n      if ( map[ ly ][ lx - 1 ] == '#' ) {\n\tv.push_back( lx );\n      }else {\n\tv.push_back( lx - 1 );\n      }\n      v.push_back( ly );\n      q.push( v );\n\n      v.clear();\n      v.push_back( rx );\n      if ( map[ ry - 1 ][ rx ] == '#' ) {\n\tv.push_back( ry );\n      }else {\n\tv.push_back( ry - 1 );\n      }\n      v.push_back( lx );\n      if ( map[ ly - 1 ][ lx ] == '#' ) {\n\tv.push_back( ly );\n      }else {\n\tv.push_back( ly - 1 );\n      }\n      q.push( v );\n\n      v.clear();\n      if ( map[ ry ][ rx - 1 ] == '#' ) {\n\tv.push_back( rx );\n      }else {\n\tv.push_back( rx - 1 );\n      }\n      v.push_back( ry );\n      if ( map[ ly ][ lx + 1 ] == '#' ) {\n\tv.push_back( lx );\n      }else {\n\tv.push_back( lx + 1 );\n      }\n      v.push_back( ly );\n      q.push( v );\n\n      v.clear();\n      v.push_back( rx );\n      if ( map[ ry + 1 ][ rx ] == '#' ) {\n\tv.push_back( ry );\n      }else {\n\tv.push_back( ry + 1 );\n      }\n      v.push_back( lx );\n      if ( map[ ly + 1 ][ lx ] == '#' ) {\n\tv.push_back( ly );\n      }else {\n\tv.push_back( ly + 1 );\n      }\n      q.push( v );\n\n    }\n\n    cout << \"No\" << endl;\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<queue>\n#include<map>\nusing namespace std;\n\nstruct Data{int x[2],y[2];};\nData start,goal;\n\nint W,H;\nstring room[2][50];\n\nint dx[2][4]={{0,1,0,-1}, {0,-1,0,1}};\nint dy[2][4]={{-1,0,1,0}, {-1,0,1,0}};\n\nbool operator<(Data a, Data b){\n  return a.x[0]!=b.x[0]?a.x[0]<b.x[0]:(a.y[0]!=b.y[0]?a.y[0]<b.y[0]:(\n           a.x[1]!=b.x[1]?a.x[1]<b.x[1]:a.y[1]<b.y[1]\n         ));\n}\nbool operator==(Data a, Data b){\n  return a.x[0]==b.x[0] && a.x[1]==b.x[1] && a.y[0]==b.y[0] && a.y[1]==b.y[1];\n}\nbool over(Data a){\n  return a.x[0]<0 || W<=a.x[0] || a.y[0]<0 || H<=a.y[0] ||\n         a.x[1]<0 || W<=a.x[1] || a.y[1]<0 || H<=a.y[1];\n}\n\nbool bfs()\n{\n  queue<Data>q;\n  q.push(start);\n  map<Data,bool>visited;\n\n  while(!q.empty()){\n    Data now=q.front();\n    q.pop();\n\n    visited[now]=true;\n\n    if(now==goal)return true;\n    if(now.x[0]==goal.x[0] && now.y[0]==goal.y[0])continue;\n    if(now.x[1]==goal.x[1] && now.y[1]==goal.y[1])continue;\n\n    for(int i=0;i<4;i++){\n      Data next=now;\n      for(int j=0;j<2;j++){\n\tnext.x[j]+=dx[j][i];\n\tnext.y[j]+=dy[j][i];\n\tif(over(next)){\n\t  next.x[j]=now.x[j];\n\t  next.y[j]=now.y[j];\n\t}\n\tif(room[j][next.y[j]][next.x[j]]=='#'){\n\t  next.x[j]=now.x[j];\n\t  next.y[j]=now.y[j];\n\t}\n      }\n      if(visited.count(next))continue;\n      q.push(next);\n    }\n  }\n\n  return false;\n}\n\nint main()\n{\n  while(cin>>W>>H,W|H){\n    for(int i=0;i<H;i++){\n      cin>>room[0][i]>>room[1][i];\n      for(int j=0;j<W;j++){\n\tif(room[0][i][j]=='L'){\n\t  start.x[0]=j;\n\t  start.y[0]=i;\n\t}\n\tif(room[1][i][j]=='R'){\n\t  start.x[1]=j;\n\t  start.y[1]=i;\n\t}\n\tif(room[0][i][j]=='%'){\n\t  goal.x[0]=j;\n\t  goal.y[0]=i;\n\t}\n\tif(room[1][i][j]=='%'){\n\t  goal.x[1]=j;\n\t  goal.y[1]=i;\n\t}\n      }\n    }\n\n    puts(bfs()?\"Yes\":\"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing Coor = pair<int, int>;\nusing Pair = pair<Coor, Coor>;\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {-1, 0, 1, 0};\n\nint H;\nint W;\nint sty[2];\nint stx[2];\nint y[2];\nint x[2];\nchar field[2][50][50];\nbool dp[50][50][50][50];\n\nbool WithinRange(int y, int x) {\n  if (y < 0 || H <= y) return false;\n  if (x < 0 || W <= x) return false;\n  return true;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &W, &H);\n    if (W == 0 && H == 0) return 0;\n\n    for (int i=0; i<H; i++) {\n      for (int j=0; j<W; j++) {\n        scanf(\" %c\", &field[0][i][j]);\n        if (field[0][i][j] == '%') {\n          sty[0] = i;\n          stx[0] = j;\n        } else if (field[0][i][j] == 'L') {\n          y[0] = i;\n          x[0] = j;\n        } else assert(field[0][i][j] == '.' || field[0][i][j] == '#');\n      }\n\n      for (int j=W-1; j>=0; j--) {\n        scanf(\" %c\", &field[1][i][j]);\n        if (field[1][i][j] == '%') {\n          sty[1] = i;\n          stx[1] = j;\n        } else if (field[1][i][j] == 'R') {\n          y[1] = i;\n          x[1] = j;\n        } else assert(field[1][i][j] == '.' || field[1][i][j] == '#');\n      }\n    }\n\n    for (int i=0; i<H; i++) {\n      for (int j=0; j<W; j++) {\n        for (int k=0; k<H; k++) {\n          for (int l=0; l<W; l++) {\n            dp[i][j][k][l] = false;\n          }\n        }\n      }\n    }\n\n    dp[y[0]][x[0]][y[1]][x[1]] = true;\n    queue<Pair> q;\n    q.push(Pair(Coor(y[0], x[0]), Coor(y[1], x[1])));\n    while (!q.empty()) {\n      Pair p = q.front(); q.pop();\n      Coor c1 = p.first;\n      int y1 = c1.first;\n      int x1 = c1.second;\n      Coor c2 = p.second;\n      int y2 = c2.first;\n      int x2 = c2.second;\n\n      for (int i=0; i<4; i++) {\n        int newy1 = y1 + dy[i];\n        int newx1 = x1 + dx[i];\n        if (!WithinRange(newy1, newx1) || field[0][newy1][newx1] == '#') {\n          newy1 -= dy[i];\n          newx1 -= dx[i];\n        }\n\n        int newy2 = y2 + dy[i];\n        int newx2 = x2 + dx[i];\n        if (!WithinRange(newy2, newx2) || field[1][newy2][newx2] == '#') {\n          newy2 -= dy[i];\n          newx2 -= dx[i];\n        }\n\n        if (dp[newy1][newx1][newy2][newx2]) continue;\n        dp[newy1][newx1][newy2][newx2] = true;\n        q.push(Pair(Coor(newy1, newx1), Coor(newy2, newx2)));\n      }\n    }\n\n    if (dp[sty[0]][stx[0]][sty[1]][stx[1]]) puts(\"Yes\");\n    else puts(\"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<tuple>\n#include<string>\nusing namespace std;\n\n#define MAX_N 60\n#define INF 1<<30\n\nint dist[MAX_N][MAX_N][MAX_N][MAX_N];\nint dy1[4] = { 0,1,0,-1 };\nint dy2[4] = { 0,1,0,-1 };\nint dx1[4] = { 1,0,-1,0 };\nint dx2[4] = { -1,0,1,0 };\nint H, W, map1[MAX_N][MAX_N], map2[MAX_N][MAX_N];\nint Lsy, Lsx, Lgy, Lgx;\nint Rsy, Rsx, Rgy, Rgx;\nstring S, T;\nqueue<tuple<int, int, int, int>>Q;\n\nvoid _memset() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tfor (int k = 0; k < MAX_N; k++) {\n\t\t\t\tfor (int l = 0; l < MAX_N; l++) {\n\t\t\t\t\tdist[i][j][k][l] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tmap1[i][j] = 1;\n\t\t\tmap2[i][j] = 1;\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\t_memset();\n\t\tcin >> W >> H;\n\t\tif (H == 0 && W == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tcin >> S >> T;\n\t\t\tfor (int j = 0; j < S.size(); j++) {\n\t\t\t\tif (S[j] == '%') {\n\t\t\t\t\tLsx = j + 1; Lsy = i;\n\t\t\t\t\tmap1[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\tif (S[j] == '#') {\n\t\t\t\t\tmap1[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (S[j] == '.') {\n\t\t\t\t\tmap1[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (S[j] = 'L') {\n\t\t\t\t\tLgy = i; Lgx = j + 1;\n\t\t\t\t\tmap1[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < T.size(); j++) {\n\t\t\t\tif (T[j] == '%') {\n\t\t\t\t\tRsx = j + 1; Rsy = i;\n\t\t\t\t\tmap2[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\tif (T[j] == '#') {\n\t\t\t\t\tmap2[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (T[j] == '.') {\n\t\t\t\t\tmap2[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (T[j] = 'R') {\n\t\t\t\t\tRgy = i; Rgx = j + 1;\n\t\t\t\t\tmap2[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tQ.push(make_tuple(Lsy, Lsx, Rsy, Rsx));\n\t\tdist[Lsy][Lsx][Rsy][Rsx] = 0;\n\n\t\twhile (!Q.empty()) {\n\t\t\ttuple<int, int, int, int>tup = Q.front(); Q.pop();\n\t\t\tint ay = get<0>(tup);\n\t\t\tint ax = get<1>(tup);\n\t\t\tint by = get<2>(tup);\n\t\t\tint bx = get<3>(tup);\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint ey = ay + dy1[i], ex = ax + dx1[i];\n\t\t\t\tint fy = by + dy2[i], fx = bx + dx2[i];\n\t\t\t\tif (map1[ey][ex] == 1) {\n\t\t\t\t\tey = ay; ex = ax;\n\t\t\t\t}\n\t\t\t\tif (map2[fy][fx] == 1) {\n\t\t\t\t\tfy = by; fx = bx;\n\t\t\t\t}\n\t\t\t\tif (dist[ey][ex][fy][fx] == INF) {\n\t\t\t\t\tdist[ey][ex][fy][fx] = 0;\n\t\t\t\t\tQ.push(make_tuple(ey, ex, fy, fx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[Lgy][Lgx][Rgy][Rgx] == INF) {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <string>\n#include <vector>\n#include <set>\n#include <cstring>\nusing namespace std;\n\ntypedef pair<pair<int,int>,pair<int,int> > pii;\n#define REP(i,n) for(int i=0; i<n; ++i)\n\nbool state[50][50][50][50];\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\n\nint main() {\n    int w,h;\n    while(cin>>w>>h, w|h) {\n        vector<string> left(h),right(h);\n        REP(i,h) cin>>left[i]>>right[i];\n\n        int lx,ly,rx,ry;\n        int glx,gly,grx,gry;\n        REP(i,h) REP(j,w) {\n            if(left[i][j] == 'L') lx = j, ly = i, left[i][j] = '.';\n            if(left[i][j] == '%') glx = j, gly = i, left[i][j] = '.';\n        }\n        REP(i,h) REP(j,w) {\n            if(right[i][j] == 'R') rx = j, ry = i, right[i][j] = '.';\n            if(right[i][j] == '%') grx = j, gry = i, right[i][j] = '.';\n        }\n\n        memset(state, false, sizeof(state));\n        queue<pii> Q;\n        Q.push(make_pair(make_pair(lx,ly),make_pair(rx,ry)));\n        while(!Q.empty()) {\n            pii now = Q.front(); Q.pop();\n            if(now.first.first == glx && now.first.second == gly\n               && now.second.first == grx && now.second.second == gry) {\n                goto SUCCESS;\n            }\n            if(now.first.first == glx && now.first.second == gly) continue;\n            if(now.second.first == grx && now.second.second == gry) continue;\n            int lx = now.first.first, ly = now.first.second;\n            int rx = now.second.first, ry = now.second.second;\n            if(state[lx][ly][rx][ry]) continue;\n            state[lx][ly][rx][ry] = true;\n            for(int i=0; i<4; ++i) {\n                int nlx = lx + dx[i],nly = ly + dy[i];\n                int nrx = rx + dx[(i+2)%4],nry = ry + dy[i];\n                if(nlx < 0 || nlx >= w || nrx < 0 || nrx >= w) continue;\n                if(nry < 0 || nry >= h || nly < 0 || nly >= h) continue;\n                if(left[nly][nlx] == '#') {\n                    nly = ly;\n                    nlx = lx;\n                }\n                if(right[nry][nrx] == '#') {\n                    nry = ry;\n                    nrx = rx;\n                }\n                Q.push(make_pair(make_pair(nlx,nly),make_pair(nrx,nry)));\n            }\n        }\n\n        goto BAD;\n    SUCCESS:\n        cout<<\"Yes\"<<endl;\n        continue;\n    BAD:\n        cout<<\"No\"<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define M 52\n#include<cstring>\nusing namespace std;\nbool flag;\nint dx[]={1,-1,0,0},dy[]={0,0,-1,1},w,h;\nchar r[M][M],l[M][M];\nint dp[M][M][M][M];\nvoid func(int ly,int lx,int ry,int rx){\n\tif(flag)\n\treturn;\n\t//cout<<ly<<' '<<lx<<' '<<ry<<' '<<rx<<endl;\n\tif(dp[ly][lx][ry][rx]!=0)\n\treturn;\n\tdp[ly][lx][ry][rx]=1;\n\tif(l[ly][lx]=='%'&&r[ry][rx]=='%'){\n\t\tflag=true;\n\t\treturn;\n\t}else if(l[ly][lx]=='%'||r[ry][rx]=='%')\n\treturn;\n\tint nrx,nry,nlx,nly;\n\tfor(int i=0;i<4;i++){\n\t\tnrx=dx[i]+rx;\n\t\tnry=dy[i]+ry;\n\t\tnlx=-dx[i]+lx;\n\t\tnly=dy[i]+ly;\n\t\tif(!(nrx>=0&&nrx<w&&nry>=0&&nry<h)||r[nry][nrx]=='#'){\n\t\t\tnrx=rx;nry=ry;\n\t\t}\n\t\tif(!(nlx>=0&&nlx<w&&nly>=0&&nly<h)||l[nly][nlx]=='#'){\n\t\t\tnlx=lx;nly=ly;\n\t\t}\n\t\tif(dp[nly][nlx][nry][nrx]==0)\n\t\tfunc(nly,nlx,nry,nrx);\n\t}\n}\nint main(){\n\tint a,b,c,d;\n\twhile(cin>>w>>h,h||w){\n\t\tfor(int i=0;i<h;i++)\n\t\t\tcin>>l[i]>>r[i];\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(l[i][j]=='L'){\n\t\t\t\t\ta=i;b=j;\n//\t\tcout<<a<<b<<endl;\n\t\t\t\t}\n\t\t\t\tif(r[i][j]=='R'){\n\t\t\t\t\tc=i;d=j;\n\t\t\t\t}\n\t\t}\n\t\tmemset(dp,sizeof(dp),0);\n\t\tflag=false;\n\t\tfunc(a,b,c,d);\n\t\tputs(flag?\"Yes\":\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\nusing namespace std;\nstring s1[50],s2[50];\nint dx1[]={1,-1,0,0,},dy1[]={0,0,1,-1};\nint dx2[]={-1,1,0,0,},dy2[]={0,0,1,-1};\nint w,h,gx1,gx2,gy1,gy2;\nset<int>s;\nbool bfs(int x1,int y1,int x2,int y2){\n  queue<int>q;\n  q.push(x1+y1*100+x2*10000+y2*1000000);\n  while(!q.empty()){\n    int p=q.front();q.pop();\n    x1=p%100;y1=p%10000/100;\n    x2=p%1000000/10000;y2=p/1000000;\n    if(x1==gx1&&y1==gy1&&(x2!=gx2||y2!=gy2))continue;\n    if((x1!=gx1||y1!=gy1)&&x2==gx2&&y2==gy2)continue;\n    if(x1==gx1&&y1==gy1&&x2==gx2&&y2==gy2){\n      while(!q.empty())q.pop();\n      return 1;\n    }\n    for(int i=0;i<4;i++){\n      int x3=x1+dx1[i],y3=y1+dy1[i];\n      int x4=x2+dx2[i],y4=y2+dy2[i];\n      if(x3>=0&&x4>=0&&y3>=0&&y4>=0)\n        if(x3<w&&x4<w&&y3<h&&y4<h){\n          if(s1[y3][x3]=='#')y3=y1,x3=x1;\n          if(s2[y4][x4]=='#')y4=y2,x4=x2;\n          if(!s.count(x3+y3*100+x4*10000+y4*1000000)){\n            s.insert(x3+y3*100+x4*10000+y4*1000000);\n            q.push(x3+y3*100+x4*10000+y4*1000000);\n          }\n        }\n      }\n    }\n    return 0;\n}\nint main(){\n  int x1,y1,x2,y2;\n  while(cin>>w>>h,w){\n    s.clear();\n    r(i,h)cin>>s1[i]>>s2[i];\n    r(i,h)r(j,w){\n      if(s1[i][j]=='L')x1=j,y1=i;\n      if(s2[i][j]=='R')x2=j,y2=i;\n      if(s1[i][j]=='%')gx1=j,gy1=i;\n      if(s2[i][j]=='%')gx2=j,gy2=i;\n    }\n    s.insert(x1+y1*100+x2*10000+y2*1000000);\n    if(bfs(x1,y1,x2,y2))cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <sstream>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cstring>\n \nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nint w,h;\nint sxl,syl,sxr,syr;\nstring L[100],R[100];\n\nconst int dx[]={0,1,0,-1};\nconst int dy[]={-1,0,1,0};\n\nint vis[50][50][50][50];\n\nbool solve(int xl,int yl,int xr, int yr)\n{\n\n\n\tif(vis[yl][xl][yr][xr]==1) return false;\n\t\t\n\tif(L[yl][xl]=='%' && R[yr][xr]=='%') return true;\n\tif(L[yl][xl]=='%' && R[yr][xr]!='%') return false;\n\tif(L[yl][xl]!='%' && R[yr][xr]=='%') return false;\n\t\n\n\t\n\tvis[yl][xl][yr][xr]=1;\n\t\n\tfor(int i=0;i<4;i++){\n\t\tint nxl=xl+dx[i], nyl=yl+dy[i];\n\t\tint nxr=xr-dx[i], nyr=yr+dy[i];\n\n\t\tif(nxl<0 || w<=nxl || nyl<0 || h<=nyl ||\n\t\t   nxr<0 || w<=nxr || nyr<0 || h<=nyr ) continue;\n\t\t\n\t\tif(L[nyl][nxl]=='#'){\n\t\t\tnxl-=dx[i]; nyl-=dy[i];\n\t\t}\n\t\tif(R[nyr][nxr]=='#'){\n\t\t\tnxr+=dx[i]; nyr-=dy[i];\n\t\t}\n\t\t\n\t\tif(solve(nxl,nyl,nxr,nyr)) return true;\n\t\t\n\t}\n\t\n\treturn false;\n\n}\n\nint main()\n{\n\t\n\twhile(cin>>w>>h,w){\t\t\n\n\t\tmemset(vis,-1,sizeof(int)*50*50*50*50);\n\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>L[i]>>R[i];\n\t\t}\n\t\t\n\t\t\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(L[i][j]=='L'){sxl=j,syl=i;}\n\t\t\t\tif(R[i][j]=='R'){sxr=j,syr=i;}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(solve(sxl,syl,sxr,syr)) cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t\t\n\t}\n\t\t\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nstruct Data\n{\n\tint lx,ly,rx,ry;\n};\n\nconst int  dy[] = { 0, 0,+1,-1};\nconst int ldx[] = {+1,-1, 0, 0};\nconst int rdx[] = {-1,+1, 0, 0};\n\nint main()\n{\n\tint W,H;\n\twhile(cin>>W>>H, W||H)\n\t{\n\t\tchar L[50][51];\n\t\tchar R[50][51];\n\t\tfor(int y=0; y<H; y++)\n\t\t{\n\t\t\tcin>>L[y]>>R[y];\n\t\t}\n\n\n\t\tData s;\n\t\tfor(int y=0; y<H; y++)\n\t\tfor(int x=0; x<W; x++)\n\t\t{\t\n\t\t\tif(L[y][x]=='L') { s.lx=x; s.ly=y; }\n\t\t\tif(R[y][x]=='R') { s.rx=x; s.ry=y; }\n\t\t}\n\n\t\tqueue<Data> q;\n\t\tq.push(s);\n\n\t\tbool v[50][50][50][50]={0};\n\t\tv[s.ly][s.lx][s.ry][s.rx]=1;\n\n\t\tbool ans=false;\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tData t=q.front(); q.pop();\n\n\t\t\tif(L[t.ly][t.lx]=='%' && R[t.ry][t.rx]=='%')\n\t\t\t{\n\t\t\t\tans=true; break;\n\t\t\t}\n\t\t\tif(L[t.ly][t.lx]=='%' || R[t.ry][t.rx]=='%')\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor(int i=0; i<4; i++)\n\t\t\t{\n\t\t\t\tData n;\n\t\t\t\tn.ly = t.ly +  dy[i];\n\t\t\t\tn.lx = t.lx + ldx[i];\n\t\t\t\tn.ry = t.ry +  dy[i];\n\t\t\t\tn.rx = t.rx + rdx[i];\n\n\t\t\t\tif(0<=n.lx && n.lx<W && 0<=n.ly && n.ly<H\n\t\t\t\t&& 0<=n.rx && n.rx<W && 0<=n.ry && n.ry<H)\n\t\t\t\t{\n\t\t\t\t\tif(L[n.ly][n.lx]=='#')\n\t\t\t\t\t{\n\t\t\t\t\t\tn.ly = t.ly;\n\t\t\t\t\t\tn.lx = t.lx;\n\t\t\t\t\t}\n\t\t\t\t\tif(R[n.ry][n.rx]=='#')\n\t\t\t\t\t{\n\t\t\t\t\t\tn.ry = t.ry;\n\t\t\t\t\t\tn.rx = t.rx;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(v[n.ly][n.lx][n.ry][n.rx]) continue;\n\t\t\t\t\tv[n.ly][n.lx][n.ry][n.rx]=1;\n\t\t\t\t\tq.push(n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << (ans?\"Yes\":\"No\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,s,n) for(int i=s; i<n; i++)\n#define ALL(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nint w, h;\nint rooml[100][100], roomr[100][100];\nbool memo[55][55][55][55];\n\nbool dfs(int xl, int yl, int xr, int yr) {\n\tif( xl<=0 || w+1<=xl || yl<=0 || h+1<=yl || \n\t\txr<=0 || w+1<=xr || yr<=0 || h+1<=yr ) {\n\t\treturn false;\n\t}\n\n\tif( memo[xl][yl][xr][yr] ) {\n\t\treturn false;\n\t}\n\tmemo[xl][yl][xr][yr] = true;\n\tconst int dx[4] = {-1, 0, 1, 0};\n\tconst int dy[4] = {0, 1, 0, -1};\n\tbool f = false;\n\trep(i, 4) {\n\t\tint nxl = xl + dx[i];\n\t\tint nyl = yl + dy[i];\n\t\tint nxr = xr - dx[i];\n\t\tint nyr = yr + dy[i];\n\t\tint nl = rooml[nyl][nxl];\n\t\tint nr = roomr[nyr][nxr];\n\t\tif( nl==2 && nr==2 ) {\n\t\t\tf = true;\n\t\t}\n\t\telse if( nl==1 && nr==1 ) {\n\t\t\tf |= dfs(nxl, nyl, nxr, nyr);\n\t\t}\n\t\telse if( nl==1 && nr==0 ) {\n\t\t\tf |= dfs(nxl, nyl, xr, yr);\n\t\t}\n\t\telse if( nl==0 && nr==1 ) {\n\t\t\tf |= dfs(xl, yl, nxr, nyr);\n\t\t}\n\t}\n\treturn f;\n}\n\nint main() {\n\twhile(cin >> w >> h, w) {\n\t\tmemset(rooml, 0, sizeof(rooml));\n\t\tmemset(roomr, 0, sizeof(roomr));\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tint xl=1, yl=1, xr=1, yr=1;\n\t\trep(y, h) {\n\t\t\tstring sl, sr;\n\t\t\tcin >> sl >> sr;\n\t\t\trep(x, w) {\n\t\t\t\tif(sl[x] == 'L') {\n\t\t\t\t\txl = x+1;\n\t\t\t\t\tyl = y+1;\n\t\t\t\t\trooml[y+1][x+1] = 1;\n\t\t\t\t} else {\n\t\t\t\t\trooml[y+1][x+1] = (sl[x]=='%' ? 2 : (sl[x]=='.' ? 1 : 0));\n\t\t\t\t}\n\t\t\t\tif(sr[x] == 'R') {\n\t\t\t\t\txr = x+1;\n\t\t\t\t\tyr = y+1;\n\t\t\t\t\troomr[y+1][x+1] = 1;\n\t\t\t\t} else {\n\t\t\t\t\troomr[y+1][x+1] = (sr[x]=='%' ? 2 : (sr[x]=='.' ? 1 : 0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( dfs(xl, yl, xr, yr) ) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t} else {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<queue>\nusing namespace std;\n\nstruct Data{int x[2],y[2];};\nData start,goal;\n\nint W,H;\nchar room[2][52][52];\n\nint dx[2][4]={{0,1,0,-1}, {0,-1,0,1}};\nint dy[2][4]={{-1,0,1,0}, {-1,0,1,0}};\nbool operator==(Data a, Data b){\n  return a.x[0]==b.x[0] && a.x[1]==b.x[1] && a.y[0]==b.y[0] && a.y[1]==b.y[1];\n}\nbool over(Data a){\n  return a.x[0]<0 || W<=a.x[0] || a.y[0]<0 || H<=a.y[0] ||\n         a.x[1]<0 || W<=a.x[1] || a.y[1]<0 || H<=a.y[1];\n}\n\nbool bfs()\n{\n  queue<Data>q;\n  q.push(start);\n  bool visited[52][52][52][52]={false};\n  Data now,next;\n\n  while(!q.empty()){\n    now=q.front();\n    q.pop();\n\n    visited[now.x[0]][now.y[0]][now.x[1]][now.y[1]]=true;\n\n    if(now==goal)return true;\n    if(now.x[0]==goal.x[0] && now.y[0]==goal.y[0])continue;\n    if(now.x[1]==goal.x[1] && now.y[1]==goal.y[1])continue;\n\n    for(int i=0;i<4;i++){\n      next=now;\n      for(int j=0;j<2;j++){\n\tnext.x[j]+=dx[j][i];\n\tnext.y[j]+=dy[j][i];\n\tif(over(next) || room[j][next.y[j]][next.x[j]]=='#'){\n\t  next.x[j]=now.x[j];\n\t  next.y[j]=now.y[j];\n\t}\n      }\n      if(visited[next.x[0]][next.y[0]][next.x[1]][next.y[1]])continue;\n      q.push(next);\n    }\n  }\n\n  return false;\n}\n\nint main()\n{\n  while(cin>>W>>H,W|H){\n    for(int i=0;i<H;i++){\n      cin>>room[0][i]>>room[1][i];\n      for(int j=0;j<W;j++){\n\tif(room[0][i][j]=='L'){\n\t  start.x[0]=j;\n\t  start.y[0]=i;\n\t}\n\tif(room[1][i][j]=='R'){\n\t  start.x[1]=j;\n\t  start.y[1]=i;\n\t}\n\tif(room[0][i][j]=='%'){\n\t  goal.x[0]=j;\n\t  goal.y[0]=i;\n\t}\n\tif(room[1][i][j]=='%'){\n\t  goal.x[1]=j;\n\t  goal.y[1]=i;\n\t}\n      }\n    }\n\n    puts(bfs()?\"Yes\":\"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 51\n \nstruct State{\n    int x1,y1,x2,y2;\n    State(int x1, int y1, int x2, int y2) : x1(x1), y1(y1), x2(x2), y2(y2) {}\n};\n \nint H, W;\nchar f1[MAX][MAX], f2[MAX][MAX];\nbool vis[MAX][MAX][MAX][MAX];\nconst int lx[] = {0,-1,1,0};\nconst int ly[] = {-1,0,0,1};\nconst int rx[] = {0,1,-1,0};\nconst int ry[] = {-1,0,0,1};\n \nbool inField(int y, int x){\n    return 0 <= y && y < H && 0 <= x && x < W;\n}\n \nbool bfs(int Lx, int Ly, int Rx, int Ry){\n    memset(vis, false, sizeof(vis));\n    queue<State> Q;\n    Q.push(State(Lx, Ly, Rx, Ry));\n \n    while(!Q.empty()){\n\tState s = Q.front(); Q.pop();\n \n\tif(f1[s.y1][s.x1] == '%' && f2[s.y2][s.x2] == '%'){\n\t    return true;\n\t}\n\tfor(int i = 0 ; i < 4 ; i++){\n\t    int nlx = s.x1 + lx[i], nly = s.y1 + ly[i];\n\t    int nrx = s.x2 + rx[i], nry = s.y2 + ry[i];\n \n\t    if(!inField(nly, nlx) || f1[nly][nlx] == '#'){\n\t\tnlx = s.x1;\n\t\tnly = s.y1;\n\t    }\n\t    if(!inField(nry, nrx) || f2[nry][nrx] == '#'){\n\t\tnrx = s.x2;\n\t\tnry = s.y2;\n\t    }\n \n\t    if((f1[nly][nlx] == '%' && f2[nry][nrx] != '%') ||\n\t       (f1[nly][nlx] != '%' && f2[nry][nrx] == '%')) continue;\n \n\t    if(vis[nly][nlx][nry][nrx]) continue;\n\t    vis[nly][nlx][nry][nrx] = true;\n\t    Q.push(State(nlx, nly, nrx, nry));\n\t}\n    }\n \n    return false;\n}\n \nint main(){\n    while(cin >> W >> H, (W | H)){\n\tstring str;\n\tint Lx, Ly, Rx, Ry;\n\tfor(int i = 0 ; i < H ; i++){\n\t    for(int j = 0 ; j < 2 ; j++){\n\t\tcin >> str;\n\t\tfor(int k = 0 ; k < W ; k++){\n\t\t    if(j % 2 == 0){\n\t\t\tf1[i][k] = str[k];\n\t\t\tif(f1[i][k] == 'L'){\n\t\t\t    Lx = k;\n\t\t\t    Ly = i;\n\t\t\t}\n\t\t    }else{\n\t\t\tf2[i][k] = str[k];\n\t\t\tif(f2[i][k] == 'R'){\n\t\t\t    Rx = k;\n\t\t\t    Ry = i;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tcout << (bfs(Lx, Ly, Rx, Ry) ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\nbool used[2510][2510];\nint roomL[51][51], roomR[51][51];\n\ninline int s_to_i(char c) {\n  switch (c) {\n  case '#':\n    return -1;\n  case '.':\n    return 0;\n  case 'L':\n  case 'R':\n    return 1;\n  case '%':\n    return 2;\n  }\n}\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while (true) {\n    int R, C;\n    cin >> C >> R;\n    if (R == 0 && C == 0) break;\n    REP(i, R) {\n      string rowL, rowR;\n      cin >> rowL >> rowR;\n      REP(j, C) {\n\troomL[i][j] = s_to_i(rowL[j]);\n\troomR[i][j] = s_to_i(rowR[j]);\n      }\n    }\t  \n\n    int sl = 0, el = 0, sr = 0, er = 0;\n    REP(r, R) REP(c, C) {\n      if (roomL[r][c] == 1) sl = r * C + c;\n      else if (roomL[r][c] == 2) el = r * C + c;\n      if (roomR[r][c] == 1) sr = r * C + c;\n      else if (roomR[r][c] == 2) er = r * C + c;\n    }\n    //cout << slr << ' ' << slc << ' ' << elr << ' ' << elc << ' ' << srr << ' ' << src << ' ' << err << ' ' << erc << endl;\n    REP(i, R*C) REP(j, R*C) used[i][j] = false;\n    \n    queue<P> que;\n    que.push(P(sl, sr));\n\n    bool flag = false;\n    while (!que.empty()) {\n      P p = que.front(); que.pop();\n      int lr = p.first / C, lc = p.first % C, rr = p.second / C, rc = p.second % C;\n      //cout << lr << ' ' << lc << ' ' << rr << ' ' << rc << endl;\n      if (lr * C + lc == el && rr * C + rc == er) {\n\tflag = true;\n\tbreak;\n      } else if (used[p.first][p.second] || lr * C + lc == el || rr * C + rc == er) {\n\tcontinue;\n      }\n\n      used[p.first][p.second] = true;\n      REP(i, 4) {\n\tint nlr = lr + dr[i], nlc = lc + dc[i], nrr = rr + dr[(i+2*(i&1))%4], nrc = rc + dc[(i+2*(i&1))%4];\n\tif (nlr < 0 || nlr >= R || nlc < 0 || nlc >= C || roomL[nlr][nlc] == -1) nlr = lr, nlc = lc;\n\tif (nrr < 0 || nrr >= R || nrc < 0 || nrc >= C || roomR[nrr][nrc] == -1) nrr = rr, nrc = rc;\n\tif (!used[nlr * C + nlc][nrr * C + nrc]) que.push(P(nlr * C + nlc, nrr * C + nrc));\n      }\n    }\n    cout << (flag ? \"Yes\" : \"No\") << endl;    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<pair<int, int>, pair<int, int>> PPIIII;\n\nint dx[] = { 1,0,-1,0 };\nint dy[] = { 0,1,0,-1 };\n\nvoid solve( int W, int H ) {\n\tpair<int, int> startR, startL, goalR, goalL;\n\tvector<vector<vector<vector<bool>>>>dp( H + 2, vector<vector<vector<bool>>>( W + 2, vector<vector<bool>>( H + 2, vector<bool>( W + 2, 0 ) ) ) );\n\tvector<vector<vector<char>>>mapd( 2, vector<vector<char>>( H + 2, vector<char>( W + 2, '#' ) ) );\n\tfor( size_t i = 1; i <= H; i++ ) {\n\t\tfor( size_t j = 1; j <= W; j++ ) {\n\t\t\tcin >> mapd[0][i][j];\n\t\t\tif( mapd[0][i][j] == 'L' ) {\n\t\t\t\tstartL = make_pair( i, j );\n\t\t\t} else if( mapd[0][i][j] == '%' ) {\n\t\t\t\tgoalL = make_pair( i, j );\n\t\t\t}\n\t\t}\n\t\tfor( int j = W; j >= 1; j-- ) {\n\t\t\tcin >> mapd[1][i][j];\n\t\t\tif( mapd[1][i][j] == 'R' ) {\n\t\t\t\tstartR = make_pair( i, j );\n\t\t\t} else if( mapd[1][i][j] == '%' ) {\n\t\t\t\tgoalR = make_pair( i, j );\n\t\t\t}\n\t\t}\n\t}\n\tdp[startL.first][startL.second][startR.first][startR.second] = 1;\n\n\n\tqueue<PPIIII>que;\n\tbool f = true;\n\tque.push( make_pair( startL, startR ) );\n\twhile( que.size() ) {\n\t\tauto now = que.front(); que.pop();\n\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\tauto next = now;\n\t\t\tnext.first.first += dx[i];\n\t\t\tnext.first.second += dy[i];\n\t\t\tnext.second.first += dx[i];\n\t\t\tnext.second.second += dy[i];\n\t\t\tif( mapd[0][next.first.first][next.first.second] == '#' ) {\n\t\t\t\tnext.first = now.first;\n\t\t\t}\n\t\t\tif( mapd[1][next.second.first][next.second.second] == '#' ) {\n\t\t\t\tnext.second = now.second;\n\t\t\t}\n\n\t\t\tif( 0 < next.first.first&&next.first.first < H + 2 &&\n\t\t\t\t0 < next.first.second&&next.first.second < W + 2 &&\n\t\t\t\t0 < next.second.first&&next.second.first < H + 2 &&\n\t\t\t\t0 < next.second.second&&next.second.second < W + 2 ) {\n\t\t\t\tif( dp[next.first.first][next.first.second][next.second.first][next.second.second] == 0 ) {\n\t\t\t\t\tif( goalL == next.first&&goalR == next.second ) {\n\t\t\t\t\t\tif( now.first != next.first&&now.second != next.second ) {\n\t\t\t\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif( f ) {\n\t\t\t\t\t\t\tf = 0;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdp[next.first.first][next.first.second][next.second.first][next.second.second] = 1;\n\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"No\" << endl;\n\treturn;\n}\n\nint main() {\n\tint W, H;\n\twhile( cin >> W >> H, W&&H ) {\n\t\tsolve( W, H );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<utility>\n#include<queue>\nusing namespace std;\ntypedef struct P{int rh,rw,lh,lw,d;}P;\nstruct Order{bool operator ()(P const&a, P const&b) const{return a.d>b.d;}};\n\nint W,H,i,j,rh,rw,lh,lw,f;\nint rm[4][2]={{0,1},{0,-1},{1,0},{-1,0}};\nint lm[4][2]={{0,-1},{0,1},{1,0},{-1,0}};\nbool dp[55][55][55][55];\nchar M[110][110]={0},t;\n\nint main()\n{\n\tfor(;scanf(\"%d%d\\n\",&W,&H),W;)\n\t{\n\t\tmemset(M,0,sizeof(M));\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(i=1;i<=H;i++)\n\t\t\tfor(j=1;j<=2*W+2;j++)\n\t\t\t{\n\t\t\t\tt=getchar();\n\t\t\t\tif(t=='R'){rh=i;rw=j;t='.';}\n\t\t\t\tif(t=='L'){lh=i;lw=j;t='.';}\n\t\t\t\tM[i][j]=t;\n\t\t\t}\n\t\tpriority_queue<P,vector<P>,Order>Q;\n\t\tP p={rh,rw,lh,lw,0};\n\t\tQ.push(p);\n\t\tfor(f=0;!Q.empty();)\n\t\t{\n\t\t\tp=Q.top();Q.pop();\n\t\t\tif(M[p.rh][p.rw]=='%'&&M[p.lh][p.lw]=='%'){f=1;break;}\n\t\t\tif(M[p.rh][p.rw]=='%'||M[p.lh][p.lw]=='%'||p.d==150)continue;\n\t\t\tfor(i=0;i<4;i++)\n\t\t\t{\n\t\t\t\tP ins={p.rh,p.rw,p.lh,p.lw,p.d+1};\n\t\t\t\tif(M[p.rh+rm[i][0]][p.rw+rm[i][1]]=='.'||M[p.rh+rm[i][0]][p.rw+rm[i][1]]=='%'){ins.rh+=rm[i][0];ins.rw+=rm[i][1];}\n\t\t\t\tif(M[p.lh+lm[i][0]][p.lw+lm[i][1]]=='.'||M[p.lh+lm[i][0]][p.lw+lm[i][1]]=='%'){ins.lh+=lm[i][0];ins.lw+=lm[i][1];}\n\t\t\t\tif(!dp[ins.rh][ins.rw][ins.lh][ins.lw-W-1])\n\t\t\t\t{\n\t\t\t\t\tdp[ins.rh][ins.rw][ins.lh][ins.lw-W-1]=1;\n\t\t\t\t\tQ.push(ins);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(f?\"Yes\":\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define fi first\n#define se second\n#define mk make_pair\nusing namespace std;\nstring s1[50],s2[50];\nint dx1[]={1,-1,0,0,},dy1[]={0,0,1,-1};\nint dx2[]={-1,1,0,0,},dy2[]={0,0,1,-1};\nint w,h,gx1,gx2,gy1,gy2;\nunordered_set<pair<pair<int,int>,pair<int,int> > >s;\nqueue<pair<pair<int,int>,pair<int,int> > >q;\nbool bfs(int x1,int y1,int x2,int y2){\n  queue<int>q;\n  q.push(x1+y1*100+x2*10000+y2*1000000);\n  while(!q.empty()){\n    int p=q.front();q.pop();\n    x1=p%100;y1=p%10000/100;\n    x2=p%1000000/10000;y2=p/1000000;\n    for(int i=0;i<4;i++){\n      int x3=x1+dx1[i],y3=y1+dy1[i];\n      int x4=x2+dx2[i],y4=y2+dy2[i];\n      if(x3>=0&&x4>=0&&y3>=0&&y4>=0)\n        if(x3<w&&x4<w&&y3<h&&y4<h){\n          if(s1[y3][x3]=='#')y3=y1,x3=x1;\n          if(s2[y4][x4]=='#')y4=y2,x4=x2;\n          if(x1==gx1&&y1==gy1&&x2==gx2&&y2==gy2)return 1;\n          if(!(x3==gx1&&y3==gy1&&(x4!=gx2||y4!=gy2)))\n          if(!((x3!=gx1||y3!=gy1)&&x4==gx2&&y4==gy2))\n          if(!s.count(mk(mk(x3,y3),mk(x4,y4)))){\n            s.insert(mk(mk(x3,y3),mk(x4,y4)));\n            q.push(x3+y3*100+x4*10000+y4*1000000);\n          }\n        }\n      }\n    }\n    return 0;\n}\nbool dfs(int x1,int y1,int x2,int y2,int d){\n  //cout<<d<<endl;cout<<1;\n    if(x1==gx1&&y1==gy1&&(x2!=gx2||y2!=gy2))return 0;\n    if((x1!=gx1||y1!=gy1)&&x2==gx2&&y2==gy2)return 0;\n    if(x1==gx1&&y1==gy1&&x2==gx2&&y2==gy2)return 1;\n    if(d<8000)for(int i=0;i<4;i++){\n    int x3=x1+dx1[i],y3=y1+dy1[i];\n    int x4=x2+dx2[i],y4=y2+dy2[i];\n    if(x3<0)x3=x1;if(x4<0)x4=x2;\n    if(y3<0)y3=y1;if(y4<0)y4=y2;\n    if(x3>=w)x3=x1;if(x4>=w)x4=x2;\n    if(y3>=h)y3=y1;if(y4>=h)y4=y2;\n        if(s1[y3][x3]=='#')y3=y1,x3=x1;\n        if(s2[y4][x4]=='#')y4=y2,x4=x2;\n        if(!s.count(mk(mk(x3,y3),mk(x4,y4)))){\n          s.insert(mk(mk(x3,y3),mk(x4,y4)));\n          if(dfs(x3,y3,x4,y4,d+1))return 1;\n        }\n    }\n    else q.push(mk(mk(x1,y1),mk(x2,y2)));\n    if(q.size()){\n        pair<pair<int,int>,pair<int,int> >pp=q.front();q.pop();\n        if(bfs(pp.fi.fi,pp.fi.se,pp.se.fi,pp.se.se))return 1;\n    }\n    return 0;\n}\nint main(){\n  int x1,y1,x2,y2;\n  while(cin>>w>>h,w){\n    s.clear();\n    r(i,h)cin>>s1[i]>>s2[i];\n    r(i,h)r(j,w){\n      if(s1[i][j]=='L')x1=j,y1=i;\n      if(s2[i][j]=='R')x2=j,y2=i;\n      if(s1[i][j]=='%')gx1=j,gy1=i;\n      if(s2[i][j]=='%')gx2=j,gy2=i;\n    }\n    s.insert(mk(mk(x1,y1),mk(x2,y2)));\n    if(dfs(x1,y1,x2,y2,0))cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n    while(!q.empty())q.pop();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\nint main() {\n\tfor (;;) {\n\t\tint W, H; cin >> W >> H;\n\t\tif (W == 0 && H == 0) break;\n\t\tvector< vector<string> > a(2, vector<string>(H + 2, string(W + 2, '#')));\n\t\tfor (int y = 1; y <= H; y++) {\n\t\t\tstring s1, s2; cin >> s1 >> s2;\n\t\t\ta[0][y] = '#' + s1 + '#';\n\t\t\ta[1][y] = '#' + s2 + '#';\n\t\t}\n\t\tvector<char> xs(2), ys(2), xt(2), yt(2);\n\t\tfor (int k = 0; k < 2; k++)\n\t\t\tfor (int y = 1; y <= H; y++)\n\t\t\t\tfor (int x = 1; x <= W; x++){\n\t\t\t\t\tchar& c = a[k][y][x];\n\t\t\t\t\tif (c == 'L' || c == 'R') {\n\t\t\t\t\t\tc = '.';\n\t\t\t\t\t\txs[k] = x; ys[k] = y;\n\t\t\t\t\t}\n\t\t\t\t\telse if (c == '%') {\n\t\t\t\t\t\tc = '.';\n\t\t\t\t\t\txt[k] = x; yt[k] = y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tvector< vector<bool> > vis(3000, vector<bool>(3000));\n\t\tstack< vector<char> > stx, sty;\n\t\tstx.push(xs); sty.push(ys);\n\t\twhile (!stx.empty()) {\n\t\t\tvector<char> x = stx.top(); stx.pop();\n\t\t\tvector<char> y = sty.top(); sty.pop();\n\t\t\tvector<int> z(2);\n\t\t\tfor (int k = 0; k < 2; k++)\n\t\t\t\tz[k] = y[k] * (W + 2) + x[k];\n\t\t\tvis[z[0]][z[1]] = true;\n\t\t\tif (x[0] == xt[0] && y[0] == yt[0]) continue;\n\t\t\tif (x[1] == xt[1] && y[1] == yt[1]) continue;\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tvector<char> _x = x, _y = y;\n\t\t\t\tvector<int> _z(2);\n\t\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\t\t_x[k] += (k ? dx[i] : -dx[i]);\n\t\t\t\t\t_y[k] += dy[i];\n\t\t\t\t\tif (a[k][_y[k]][_x[k]] == '#') {\n\t\t\t\t\t\t_x[k] = x[k]; _y[k] = y[k];\n\t\t\t\t\t}\n\t\t\t\t\t_z[k] = _y[k] * (W + 2) + _x[k];\n\t\t\t\t}\n\t\t\t\tif (!vis[_z[0]][_z[1]]) {\n\t\t\t\t\tvis[_z[0]][_z[1]] = true;\n\t\t\t\t\tstx.push(_x);\n\t\t\t\t\tsty.push(_y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> zt(2);\n\t\tfor (int k = 0; k < 2; k++)\n\t\t\tzt[k] = yt[k] * (W + 2) + xt[k];\n\t\tcout << (vis[zt[0]][zt[1]] ? \"Yes\" : \"No\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\nbool used[51][51][51][51];\nstring roomL[51], roomR[51];\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while (true) {\n    int R, C;\n    cin >> C >> R;\n    if (R == 0 && C == 0) break;\n    REP(i, R) cin >> roomL[i] >> roomR[i];\n\n    int slr = 0, slc = 0, elr = 0, elc = 0, srr = 0, src = 0, err = 0, erc = 0;\n    REP(r, R) REP(c, C) {\n      if (roomL[r][c] == 'L') slr = r, slc = c;\n      else if (roomL[r][c] == '%') elr = r, elc = c;\n      if (roomR[r][c] == 'R') srr = r, src = c;\n      else if (roomR[r][c] == '%') err = r, erc = c;\n    }\n    //cout << slr << ' ' << slc << ' ' << elr << ' ' << elc << ' ' << srr << ' ' << src << ' ' << err << ' ' << erc << endl;\n    REP(i, R) REP(j, C) REP(k, R) REP(l, C) used[i][j][k][l] = false;\n    \n    queue<P> que;\n    que.push(P(slr * C + slc, srr * C + src));\n\n    bool flag = false;\n    while (!que.empty()) {\n      P p = que.front(); que.pop();\n      int lr = p.first / C, lc = p.first % C, rr = p.second / C, rc = p.second % C;\n      //cout << lr << ' ' << lc << ' ' << rr << ' ' << rc << endl;\n      if (lr == elr && lc == elc && rr == err && rc == erc) {\n\tflag = true;\n\tbreak;\n      } else if (used[lr][lc][rr][rc] || (lr == elr && lc == elc) || (rr == err && rc == erc)) {\n\tcontinue;\n      }\n\n      used[lr][lc][rr][rc] = true;\n      REP(i, 4) {\n\tint nlr = lr + dr[i], nlc = lc + dc[i], nrr = rr + dr[(i+2*(i&1))%4], nrc = rc + dc[(i+2*(i&1))%4];\n\tif (nlr < 0 || nlr >= R || nlc < 0 || nlc >= C || roomL[nlr][nlc] == '#') nlr = lr, nlc = lc;\n\tif (nrr < 0 || nrr >= R || nrc < 0 || nrc >= C || roomR[nrr][nrc] == '#') nrr = rr, nrc = rc;\n\tif (!used[nlr][nlc][nrr][nrc]) que.push(P(nlr * C + nlc, nrr * C + nrc));\n      }\n    }\n    cout << (flag ? \"Yes\" : \"No\") << endl;    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <set>\n#include <queue>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\tint dl[50][50][50][50], h, w, i, j, a, b, c, d, dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\n\tchar rf[50][51], lf[50][51];\n\tP rs, ls, rg, lg;\n\tqueue<P> r, l;\n\twhile(1){\n\t\tscanf(\"%d%d%*c\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tlf[i][j] = getchar();\n\t\t\t\tif(lf[i][j] == 'L'){\n\t\t\t\t\tls = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(lf[i][j] == '%'){\n\t\t\t\t\tlg = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 空白読み飛ばし\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\trf[i][j] = getchar();\n\t\t\t\tif(rf[i][j] == 'R'){\n\t\t\t\t\trs = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(rf[i][j] == '%'){\n\t\t\t\t\trg = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 改行文字読み飛ばし\n\t\t}\n\t\tr.push(rs), l.push(ls);\n\t\tmemset(dl,0,sizeof(dl));\n\t\twhile(r.size()){\n\t\t\ta = l.front().first, b = l.front().second, c = r.front().first, d = r.front().second;\n\t\t\tl.pop(), r.pop();\n\t\t\tdl[a][b][c][d] = 1;\n\t\t\tif(a == lg.first && b == lg.second && c == rg.first && d == rg.second)\n\t\t\t\tbreak;\n\t\t\tif(a == lg.first && b == lg.second || c == rg.first && d == rg.second)\n\t\t\t\tcontinue;\n\t\t\tfor(i = 0;i < 4;i++){\n\t\t\t\tif(a + dy[i] >= 0 && a + dy[i] < h && b + dx[i] >= 0 && b + dx[i] < w && lf[a + dy[i]][b + dx[i]] == '.' && c + dy[i] >= 0 && c + dy[i] < h && d - dx[i] >= 0 && d - dx[i] < w && rf[c + dy[i]][d - dx[i]] == '.' && !dl[a + dy[i]][b + dx[i]][c + dy[i]][d - dx[i]]) // 両方とも動くとき\n\t\t\t\t\tl.push(P(a + dy[i],b + dx[i])), r.push(P(c + dy[i],d - dx[i]));\n\t\t\t\telse if((a + dy[i] < 0 || a + dy[i] >= h || b + dx[i] < 0 || b + dx[i] >= w || lf[a + dy[i]][b + dx[i]] == '#') && c + dy[i] >= 0 && c + dy[i] < h && d - dx[i] >= 0 && d - dx[i] < w && rf[c + dy[i]][d - dx[i]] == '.' && !dl[a][b][c + dy[i]][d - dx[i]]) // Rinだけ動く\n\t\t\t\t\tl.push(P(a,b)), r.push(P(c + dy[i],d - dx[i]));\n\t\t\t\telse if(a + dy[i] >= 0 && a + dy[i] < h && b + dx[i] >= 0 && b + dx[i] < w && lf[a + dy[i]][b + dx[i]] == '.' && (c + dy[i] < 0 || c + dy[i] >= h || d - dx[i] < 0 || d - dx[i] >= w || rf[c + dy[i]][d - dx[i]] == '#') && !dl[a + dy[i]][b + dx[i]][c][d]) // Lenだけ動く\n\t\t\t\t\tl.push(P(a + dy[i],b + dx[i])), r.push(P(c,d));\n\t\t\t}\n\t\t}\n\t\twhile(r.size())\n\t\t\tr.pop(),l.pop();\n\t\tif(dl[lg.first][lg.second][rg.first][rg.second])\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define reps(i,s,n) for(int i=s; i<n; i++)\n#define all(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\nstruct node {\n\tpii lp;\n\tpii rp;\n\tnode( pii l, pii r ) {\n\t\tlp = l;\n\t\trp = r;\n\t}\n};\n\nbool visit[55][55][55][55] = {};\n\nint main() {\n\tint w, h;\n\twhile( cin >> w >> h, w||h ) {\n\t\tw+=1;\n\t\th+=1;\n\t\tstring fl[h+1], fr[h+1];\n\t\trep(y,h+1) {\n\t\t\tfl[y] = '#';\n\t\t\tfr[y] = '#';\n\t\t}\n\t\trep(x,w) {\n\t\t\tfl[0] += '#';\n\t\t\tfl[h] += '#';\n\t\t\tfr[0] += '#';\n\t\t\tfr[h] += '#';\n\t\t}\n\t\tint lx, ly, rx, ry;\n\t\tfor(int y=1; y<h; y++) {\n\t\t\tstring in;\n\t\t\tcin >> in;\n\t\t\tfl[y] += in + '#';\n\t\t\tcin >> in;\n\t\t\tfr[y] += in + '#';\n\t\t\treverse( fr[y].begin(), fr[y].end() );\n\t\t\tfor(int x=1; x<=w; x++) {\n\t\t\t\tif( fl[y][x] == 'L' ) {\n\t\t\t\t\tfl[y][x] = '.';\n\t\t\t\t\tlx = x; ly = y;\n\t\t\t\t}\n\t\t\t\tif( fr[y][x] == 'R' ) {\n\t\t\t\t\tfr[y][x] = '.';\n\t\t\t\t\trx = x; ry = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\n\t\tcout << endl;\n\t\trep(y,h+1) {\n\t\t\tcout << fl[y] << endl;\n\t\t}\n\t\tcout << endl;\n\t\trep(y,h+1) {\n\t\t\tcout << fr[y] << endl;\n\t\t}\n*/\n\t\tbool ok = false;\n\t\tqueue<node> que;\n\t\tque.push(node(pii(lx, ly), pii(rx, ry)));\n\t\tmemset( visit, 0, sizeof(visit) );\n\t\twhile( !que.empty() ) {\n\t\t\tnode nd = que.front();\n\t\t\tque.pop();\n\t\t\tif( visit[nd.lp.first][nd.lp.second][nd.rp.first][nd.rp.second] ) continue;\n\t\t\tvisit[nd.lp.first][nd.lp.second][nd.rp.first][nd.rp.second] = true;\n//\t\t\tcout << nd.lp.first << \" \" << nd.lp.second << \" \" << nd.rp.first << \" \" << nd.rp.second << endl;\n\t\t\tif( fl[nd.lp.second][nd.lp.first]=='%' && fr[nd.rp.second][nd.rp.first]=='%' ) {\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif( fl[nd.lp.second][nd.lp.first]=='%' || fr[nd.rp.second][nd.rp.first]=='%' )\n\t\t\t\tcontinue;\n\t\t\tint dx[4] = {-1, 0, 1, 0};\n\t\t\tint dy[4] = {0, -1, 0, 1};\n\t\t\trep(i, 4) {\n\t\t\t\tint nlx = nd.lp.first  + dx[i];\n\t\t\t\tint nly = nd.lp.second + dy[i];\n\t\t\t\tint nrx = nd.rp.first  + dx[i];\n\t\t\t\tint nry = nd.rp.second + dy[i];\n\t\t\t\tif( !visit[nlx][nly][nrx][nry] ) {\n\t\t\t\t\tint wall = 0;\n\t\t\t\t\tif( fl[nly][nlx] == '#' ) {\n\t\t\t\t\t\tnly-=dy[i];  nlx-=dx[i];\n\t\t\t\t\t\twall++;\n\t\t\t\t\t}\n\t\t\t\t\tif( fr[nry][nrx] == '#' ) {\n\t\t\t\t\t\tnry-=dy[i];  nrx-=dx[i];\n\t\t\t\t\t\twall++;\n\t\t\t\t\t}\n\t\t\t\t\tif( wall < 2 ) {\n\t\t\t\t\t\tque.push( node(pii(nlx, nly), pii(nrx, nry)) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (ok ? \"Yes\" : \"No\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <string.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int>;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\nll w,h;\n\nvector<string> l,r;\n\n/* bool search(int lx,int ly,int rx,int ry){                                       */\n/*   if(!value(lx,ly,w,h) || !value(rx,ry,w,h) || f[lx][ly][rx][ry]) return false; */\n/*   (f[lx][ly][rx][ry]) = true;                                                   */\n/*   bool res = false;                                                             */\n/*   rep(i,4){                                                                     */\n/*     int nlx = lx + dx[i],nly = ly + dy[i],nrx = rx - dx[i],nry = ry + dy[i];    */\n/*     cout << nlx << ' ' << nly << ' ' << nrx << ' ' << nry << endl;              */\n/*     if(value(nlx,nly,w,h) && value(nrx,nry,w,h) ){                              */\n/*       if( l[nly][nlx] == '.' && r[nry][nrx] == '.')                             */\n/*         res |= search(nlx,nly,nrx,nry);                                         */\n/*     }                                                                           */\n/*     if(value(nlx,nly,w,h) && value(nrx,nry,w,h) ){                              */\n/*       if( l[nly][nlx] == '.' && r[nry][nrx] == '#')                             */\n/*         res |= search(nlx,nly,rx,ry);                                           */\n/*     }                                                                           */\n/*     if(value(nlx,nly,w,h) && value(nrx,nry,w,h) ){                              */\n/*       if( l[nly][nlx] == '#' && r[nry][nrx] == '.')                             */\n/*         res |= search(lx,ly,nrx,nry);                                           */\n/*     }                                                                           */\n/*     if(value(nlx,nly,w,h) && value(nrx,nry,w,h) ){                              */\n/*       if( l[nly][nlx] == '%' && r[nry][nrx] == '%')                             */\n/*         return true;                                                            */\n/*     }                                                                           */\n/*   }                                                                             */\n/*   return res;                                                                   */\n/* }                                                                               */\n\nbool f[51][51][51][51] ={};\nqueue<pair<pii,pii>> q;\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll lx,ly,rx,ry;\n  while(cin >> w >> h &&  w + h ){\n    l.resize(h),r.resize(h);\n    rep(i,h){\n      cin >> l[i] >> r[i];\n      rep(j,w){\n        if(l[i][j] == 'L'){\n          ly = i;\n          lx = j;\n        }\n        if(r[i][j] == 'R'){\n          ry = i;\n          rx = j;\n        }\n      }\n    }\n    auto make = [](int lx,int ly,int rx,int ry){return mp(mp(lx,ly),mp(rx,ry));};\n    bool ans = false;\n    while(q.size()){\n      q.pop();\n    }\n    q.push(make(lx,ly,rx,ry));\n    memset(f,0,51*51*51*51);\n    while(q.size()){\n      pii lp = q.front().fi,rp = q.front().se;\n      q.pop();\n      lx = lp.fi,ly = lp.se,rx = rp.fi,ry = rp.se;\n      if(f[lx][ly][rx][ry]) continue;\n      f[lx][ly][rx][ry] = true;\n      /* cout << lx << ' ' << ly << ' ' << rx << ' ' << ry << endl; */\n      rep(i,4){\n        int nlx = lx + dx[i],nly = ly + dy[i],nrx = rx - dx[i],nry = ry + dy[i];\n        if(value(nlx,nly,w,h) && value(nrx,nry,w,h) ){\n          if( l[nly][nlx] == '.' && r[nry][nrx] == '.' && !f[nlx][nly][nrx][nry]){\n            q.push(make(nlx,nly,nrx,nry));\n          }\n          if( l[nly][nlx] == '.' && r[nry][nrx] == '#'&& !f[nlx][nly][rx][ry]){\n            q.push(make(nlx,nly,rx,ry));\n          }\n          if( l[nly][nlx] == '#' && r[nry][nrx] == '.'&& !f[lx][ly][nrx][nry]){\n            q.push(make(lx,ly,nrx,nry));\n          }\n          if( l[nly][nlx] == '%' && r[nry][nrx] == '%'){\n            ans = true;\n            while(q.size()){\n              q.pop();\n            }\n          }\n        }\n      } \n    }\n    std::cout << (ans ? \"Yes\" : \"No\") << std::endl; \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint room[2][100*100];\nint start[2], goal[2];\nint dz[] = {-1,1,-52,52};\nint dz_[] = {1,-1,-52,52};\n\nint toz(int x, int y){\n  return x + y * 52;\n}\nint ptoz(int z0, int z1){\n  return z0 + z1*3000;\n}\n\nbool search(){\n  vector<bool> visited(3000*3000, false);\n  queue<PII> q;\n  q.push(MP(start[0], start[1]));\n  visited[ptoz(start[0],start[1])] = true;\n\n  while(!q.empty()){\n\tPII now = q.front(); q.pop();\n\tREP(i,4){\n\t  int z0 = now.first + dz[i];\n\t  int z1 = now.second + dz_[i];\n\t  if(!room[0][z0])\n\t\tz0 -= dz[i];\n\t  if(!room[1][z1])\n\t\tz1 -= dz_[i];\n\n\t  if(z0 == goal[0]){\n\t\tif(z1 == goal[1])\n\t\t  return true;\n\t\telse continue;\n\t  }\n\t  if(z1 == goal[1])\n\t\tcontinue;\n\n\t  if(!visited[ptoz(z0,z1)]){\n\t\tvisited[ptoz(z0,z1)] = true;\n\t\tq.push(MP(z0,z1));\n\t  }\n\t}\n  }\n\n  return false;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int W, H;\n  while(cin>>W>>H, W){\n\tfill((int*)room, (int*)room+2*100*100, 0);\n\tREP(y,H){\n\t  REP(i,2){\n\t\tstring t; cin >> t;\n\t\tREP(x,W){\n\t\t  int st = 0;\n\t\t  switch(t[x]){\n\t\t  case 'R':\n\t\t  case 'L':\n\t\t\tst = 1;\n\t\t\tstart[i] = toz(x+1,y+1);\n\t\t\tbreak;\n\t\t  case '%':\n\t\t\tst = 1;\n\t\t\tgoal[i] = toz(x+1,y+1);\n\t\t\tbreak;\n\t\t  case '.':\n\t\t\tst = 1;\n\t\t\tbreak;\n\t\t  }\n\t\t  room[i][toz(x+1,y+1)] = st;\n\t\t}\n\t  }\n\t}\n\n\tcout << (search()? \"Yes\": \"No\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<queue>\n#define MAX 60\nusing namespace std;\nstruct Point{int x,y;};\nstruct P{\n  Point l,r;\n  int cost;\n  bool operator<(const P &a)const{\n    return (l.x==a.l.x?\n\t    (l.y==a.l.y?\n\t     (r.x==a.r.x?\n\t      (r.y<a.r.y):r.x<a.r.x)\n\t     :l.y<a.l.y)\n\t    :l.x<a.l.x);\n  }\n};\nint main(){\n  int w,h;\n  while(cin>>w>>h,w||h){\n    int i,j,k;\n    int inf = 1<<20;\n    /*\n    int d[MAX+1][MAX+1][MAX+1][MAX+1];\n    fill(d[0][0][0],d[MAX][MAX][MAX],inf);\n    */\n    map<P,int> m;\n    string sr[60],sl[60];\n    for(i=0;i<h;i++){\n      cin >> sl[i] >> sr[i];\n    }\n    \n    Point pr,pl,br,bl;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(sl[i][j]=='L'){\n\t  pl.x=j;pl.y=i;\n\t}\n\tif(sr[i][j]=='R'){\n\t  pr.x=j;pr.y=i;\n\t}\n      }\n    }\n    //cout << pl.x << \":\" << pl.y << endl;\n    //cout << pr.x << \":\" << pr.y << endl;\n    //d[pl.x][pl.y][pr.x][pr.y]=0\n    P p,b;\n    p.r=pr;\n    p.l=pl;\n    p.cost=0;\n    m[p]=p.cost;\n    queue<P> q;\n    q.push(p);\n    bool f = false;\n    while(!q.empty()){\n      p=q.front();q.pop();\n      pl=p.l;pr=p.r;\n      if(m.find(p)!=m.end())\n\tif(p.cost>m[p]) continue;\n      m[p]=p.cost;\n      //cout << pl.x<<\":\"<<pl.y<<\":\"<<pr.x<<\":\"<<pr.y<<\"/\"<<p.cost<<endl;\n      if(sl[pl.y][pl.x]=='%'&&sr[pr.y][pr.x]=='%'){\n\tf=true;\n\tbreak;\n      }else if(sl[pl.y][pl.x]=='%') continue;\n      else if(sr[pr.y][pr.x]=='%') continue;\n      \n      p.cost++;\n      int lx[]={1,-1,0,0};int ly[]={0,0,1,-1};\n      int rx[]={-1,1,0,0};int ry[]={0,0,1,-1};\n      for(i=0;i<4;i++){\n\tbl=pl;br=pr;\n\tbl.x+=lx[i];bl.y+=ly[i];\n\tbr.x+=rx[i];br.y+=ry[i];\n\n\t//cout << bl.x<<\":\"<<bl.y<<\":\"<<br.x<<\":\"<<br.y<<\"/\"<<p.cost<<endl;\n\t\n\tif(bl.x<0) bl.x=0;\n\telse if(bl.x>=w) bl.x=w-1;\n\tif(bl.y<0) bl.y=0;\n\telse if(bl.y>=h) bl.y=h-1;\n\n\tif(br.x<0) br.x=0;\n\telse if(br.x>=w) br.x=w-1;\n\tif(br.y<0) br.y=0;\n\telse if(br.y>=h) br.y=h-1;\n\n\tif(sl[bl.y][bl.x]=='#'){\n\t  bl.x-=lx[i];bl.y-=ly[i];\n\t}\n\tif(sr[br.y][br.x]=='#'){\n\t  br.x-=rx[i];br.y-=ry[i];\n\t}\n\tp.r=br;p.l=bl;\n\tq.push(p);\n\t//m[p]=p.cost;\n      }\n    }\n    if(f) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, P> PP;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nint w, h;\nstring sl[50], sr[50];\nbool vis[50][50][50][50];\nP ls, rs, lg, rg;\nint dxl[] = {1, 0, -1, 0};\nint dxr[] = {-1, 0, 1, 0};\nint dy[] = {0, 1, 0, -1};\n\nbool range(int x, int y) {\n    return 0 <= x && x < w && 0 <= y && y < h;\n}\n\nbool dfs(P l, P r) {\n    deque<PP> q;\n    q.pb(PP(l, r));\n    while(!q.empty()) {\n        PP p = q.back(); q.pop_back();\n\n        if (p.fi == lg && p.se == rg) return true;\n        else if (p.fi == lg || p.se == rg) continue;\n\n        vis[p.fi.fi][p.fi.se][p.se.fi][p.se.se] = true;\n        rep(i, 4) {\n            int lx = p.fi.se + dxl[i], ly = p.fi.fi + dy[i];\n            if (!range(lx, ly) || (range(lx, ly) && sl[ly][lx] == '#')) lx = p.fi.se, ly = p.fi.fi;\n            int rx = p.se.se + dxr[i], ry = p.se.fi + dy[i];\n            if (!range(rx, ry) || (range(lx, ly) && sr[ry][rx] == '#')) rx = p.se.se, ry = p.se.fi;\n            if (!vis[ly][lx][ry][rx]) {\n                q.pb(PP(P(ly, lx), P(ry, rx)));\n                vis[ly][lx][ry][rx] = true;\n            }\n        }\n    }\n    return false;\n}\n\nint main(){\n    cin.sync_with_stdio(false);\n    while(cin >> w >> h, w | h) {\n        memset(vis, 0, sizeof(vis));\n\n        rep(i, h) {\n            cin >> sl[i] >> sr[i];\n            rep(j, w) {\n                if (sl[i][j] == 'L') ls = P(i, j);\n                if (sr[i][j] == 'R') rs = P(i, j);\n                if (sl[i][j] == '%') lg = P(i, j);\n                if (sr[i][j] == '%') rg = P(i, j);\n            }\n        }\n\n        cout << (dfs(ls, rs) ? \"Yes\" : \"No\") << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nint w, h;\nP sl, sr;\nstring s[1000];\nstring t[1000];\nbool f[60][60][60][60];\n\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\n\n//set<pair<P,P>>\n\nbool solve(int ly, int lx, int ry, int rx) {\n\tbool res = 0;\n\tf[ly][lx][ry][rx] = 1;\n\tREP(i, 4) {\n\t\tint nly = ly + dy[i], nry = ry + dy[i], nlx = lx + dx[i], nrx = rx + dx[i];\n\t\tif (nly >= 0 && nly < h&&nlx >= 0 && nlx < w&&nry >= 0 && nry < h&&nrx >= 0 && nrx < w) {\n\t\t\tif (f[nly][nrx][nry][nrx])continue;\n\t\t\tif (s[nly][nlx] != t[nry][nrx]) {\n\t\t\t\tif (s[nly][nlx] == '%' || t[nry][nrx] == '%')continue;\n\t\t\t\tif (s[nly][nlx] == '#')res |= solve(ly, lx, nry, nrx);\n\t\t\t\telse if (t[nry][nrx] == '#')res |= solve(nly, nlx, ry, rx);\n\t\t\t\telse res |= solve(nly, nlx, nry, nrx);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (s[nly][nlx] == '%')res |= true;\n\t\t\t\telse if (s[nly][nlx] == '.')res |= solve(nly, nlx, nry, nrx);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\twhile (cin >> w >> h&&w + h) {\n\t\tREP(i, 100)REP(j, 100)REP(k,100)REP(l,100) {\n\t\t\tf[i][j][k][l] = 0;\n\t\t}\n\t\tREP(i, h) {\n\t\t\tcin >> s[i] >> t[i];\n\t\t\treverse(ALL(t[i]));\n\t\t}\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tif (s[i][j] == 'L') {\n\t\t\t\t\tsl = { i,j };\n\t\t\t\t\ts[i][j] = '.';\n\t\t\t\t}\n\t\t\t\tif (t[i][j] == 'R') {\n\t\t\t\t\tsr = { i,j };\n\t\t\t\t\ts[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (solve(sl.first, sl.second, sr.first, sr.second))cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\nusing namespace std;\n\nstruct State{\n  int x1, y1, x2, y2;\n  State(int x1, int y1, int x2, int y2): x1(x1), y1(y1), x2(x2), y2(y2){}\n};\n\nconst int MAX = 55;\n\nconst int dx1[] = {1, 0, -1, 0};\nconst int dy1[] = {0, 1, 0, -1};\nconst int dx2[] = {-1, 0, 1, 0};\nconst int dy2[] = {0, 1, 0, -1};\n\nint H, W;\nchar grid[2][MAX][MAX];\nbool used[MAX][MAX][MAX][MAX];\nint sx1, sy1, sx2, sy2;\nint gx1, gy1, gx2, gy2;\n\nbool isValid(int x, int y){\n  return 0 <= x && x < W && 0 <= y && y < H;\n}\n\nbool solve(){\n  queue<State> que;\n  que.push(State(sx1, sy1, sx2, sy2));\n  \n  while(!que.empty()){\n    State q = que.front(); que.pop();\n\n    if(used[q.y1][q.x1][q.y2][q.x2]) continue;\n    used[q.y1][q.x1][q.y2][q.x2] = true;\n    \n    for(int i = 0 ; i < 4 ; i++){\n      int nx1 = q.x1 + dx1[i], ny1 = q.y1 + dy1[i];\n      int nx2 = q.x2 + dx2[i], ny2 = q.y2 + dy2[i];      \n      \n      if(!isValid(nx1, ny1) || !isValid(nx2, ny2)) continue;\n      if(grid[0][ny1][nx1] == '#' && grid[1][ny2][nx2] == '#') continue;      \n      if(grid[0][ny1][nx1] == '%' && grid[1][ny2][nx2] != '%') continue;      \n      if(grid[0][ny1][nx1] != '%' && grid[1][ny2][nx2] == '%') continue;      \n\n      \n      if(grid[0][ny1][nx1] == '#') nx1 = q.x1, ny1 = q.y1;\n      if(grid[1][ny2][nx2] == '#') nx2 = q.x2, ny2 = q.y2;\n      \n      que.push(State(nx1, ny1, nx2, ny2));\n    }\n  }\n  return used[gy1][gx1][gy2][gx2];\n}\n\nvoid init(){\n  memset(used, false, sizeof(used));\n  memset(grid, '.', sizeof(grid));\n}\n\nint main(){\n  while(cin >> W >> H, H|W){  \n    init();\n    \n    for(int i = 0 ; i < H ; i++)\n      for(int j = 0 ; j < 2 ; j++) cin >> grid[j][i];\n\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n\tif(grid[0][i][j] == 'L') sx1 = j, sy1 = i;\n\tif(grid[0][i][j] == '%') gx1 = j, gy1 = i;\n      }\n    }\n    \n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n\tif(grid[1][i][j] == 'R') sx2 = j, sy2 = i;\n\tif(grid[1][i][j] == '%') gx2 = j, gy2 = i;\n      }\n    }    \n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define lli long long int\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define MOD 1000000007\n#define NUM 2520\n#define INF (1LL<<50)\n#define DEBUG 0\n#define mp(a,b) make_pair(a,b)\n\nbool flag[60][60][60][60];\n\nlli dataL[60][60];\nlli dataR[60][60];\n\nclass edge\n{\npublic:\n\tlli lx,ly;\n\tlli rx,ry;\n};\n\nvoid solve(lli h,lli w)\n{\n\tstring s;\n\tstring r;\n\n\tedge start;\n\n\tREP(i,0,60)REP(j,0,60)REP(k,0,60)REP(l,0,60)flag[i][j][k][l]=false;\n\n\tREP(i,0,h){\n\t\tcin>>s>>r;\n\t\treverse(r.begin(),r.end());\n\n\t\tif(DEBUG)cout<<s<<\" \"<<r<<endl;\n\n\t\tREP(j,0,w){\n\t\t\tif(s.at(j)=='.')dataL[i][j]=0;\n\t\t\telse if(s.at(j)=='#')dataL[i][j]=1;\n\t\t\telse if(s.at(j)=='L'){\n\t\t\t\tdataL[i][j]=0;\n\t\t\t\tstart.lx=j;\n\t\t\t\tstart.ly=i;\n\t\t\t}\n\t\t\telse dataL[i][j]=2;\n\t\t}\n\n\t\tREP(j,0,w){\n\t\t\tif(r.at(j)=='.')dataR[i][j]=0;\n\t\t\telse if(r.at(j)=='#')dataR[i][j]=1;\n\t\t\telse if(r.at(j)=='R')\n\t\t\t{\n\t\t\t\tdataR[i][j]=0;\n\t\t\t\tstart.rx=j;\n\t\t\t\tstart.ry=i;\n\t\t\t}\n\t\t\telse dataR[i][j]=2;\n\t\t}\n\t}\n\tif(DEBUG)cout<<start.ly<<\" \"<<start.lx<<\" \"<<start.ry<<\" \"<<start.rx<<endl;\n\n\tflag[start.ly][start.lx][start.ry][start.rx]=true;\n\tqueue<edge> q;\n\tq.push(start);\n\n\twhile(q.size())\n\t{\n\t\tedge top;\n\t\ttop.lx = q.front().lx;\n\t\ttop.ly = q.front().ly;\n\t\ttop.rx = q.front().rx;\n\t\ttop.ry = q.front().ry;\n\n\t\tif(DEBUG)cout<<top.ly<<\" \"<<top.lx<<\" \"<<top.ry<<\" \"<<top.rx<<endl;\n\n\t\tq.pop();\n\n\t\tlli dx[4]={-1,0,1,0};\n\t\tlli dy[4]={0,1,0,-1};\n\n\t\tREP(i,0,4){\n\t\t\tedge next;\n\t\t\tnext.lx = top.lx+dx[i];\n\t\t\tnext.ly = top.ly+dy[i];\n\t\t\tnext.rx = top.rx+dx[i];\n\t\t\tnext.ry = top.ry+dy[i];\n\n\t\t\tif(DEBUG)cout<<\"next=\"<<next.ly<<\" \"<<next.lx<<\" \"<<next.ry<<\" \"<<next.rx<<endl;\n\n\n\t\t\tif(next.lx < 0 || w <= next.lx || next.ly < 0 || h <= next.ly)\n\t\t\t{\n\t\t\t\tnext.ly = top.ly;\n\t\t\t\tnext.lx = top.lx;\n\t\t\t}\n\t\t\tif(next.rx < 0 || w <= next.rx || next.ry < 0 || h <= next.ry)\n\t\t\t{\n\t\t\t\tnext.rx = top.rx;\n\t\t\t\tnext.ry = top.ry;\n\t\t\t}\n\n\t\t\tif(dataL[next.ly][next.lx]==1)\n\t\t\t{\n\t\t\t\tnext.lx = top.lx;\n\t\t\t\tnext.ly = top.ly;\n\t\t\t}\n\t\t\tif(dataR[next.ry][next.rx]==1)\n\t\t\t{\n\t\t\t\tnext.rx = top.rx;\n\t\t\t\tnext.ry = top.ry;\n\t\t\t}\n\t\t\tif(dataL[next.ly][next.lx]==2 && dataR[next.ry][next.rx]==2)\n\t\t\t{\n\t\t\t\tcout<<\"Yes\"<<endl;\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\tif(dataL[next.ly][next.lx]==2 || dataR[next.ry][next.rx]==2)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(flag[next.ly][next.lx][next.ry][next.rx])continue;\n\t\t\tq.push(next);\n\t\t\tflag[next.ly][next.lx][next.ry][next.rx]=true;\n\t\t}\n\t}\n\n\tcout<<\"No\"<<endl;\n\treturn ;\n}\n\nint main(){\n\n\tlli w,h;\n\twhile(cin>>w>>h){\n\t\tif(w==0 && h==0)break;\n\t\tsolve(h,w);\n\t}\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,s,n) for(int i=s; i<n; i++)\n#define ALL(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nint w, h;\nbool wl[55][55], wr[55][55];\nbool memo[55][55][55][55];\nint gxl, gyl, gxr, gyr;\n\nstruct node {\n\tint xl, yl, xr, yr;\n\tnode(int lx, int ly, int rx, int ry) {\n\t\txl = lx;\n\t\tyl = ly;\n\t\txr = rx;\n\t\tyr = ry;\n\t}\n};\n/*\nbool dfs(int xl, int yl, int xr, int yr) {\n\tif( memo[xl][yl][xr][yr] ) {\n\t\treturn false;\n\t}\n//\tcout << \"dfs \" << xl << \" \" << yl << \" \" << xr << \" \" << yr << endl;\n\tmemo[xl][yl][xr][yr] = true;\n\tif(xl==gxl && yl==gyl && xr==gxr && yr==gyr) {\n\t\treturn true;\n\t}\n\tint dx[4] = {-1, 0, 1, 0};\n\tint dy[4] = {0, 1, 0, -1};\n\tbool f = false;\n\trep(i, 4) {\n\t\tint nxl = xl + dx[i];\n\t\tint nyl = yl + dy[i];\n\t\tint nxr = xr - dx[i];\n\t\tint nyr = yr + dy[i];\n\t\tbool nl = wl[nyl][nxl];\n\t\tbool nr = wr[nyr][nxr];\n\t\tif( !nl && !nr && !memo[nxl][nyl][nxr][nyr] ) {\n\t\t\tf |= dfs(nxl, nyl, nxr, nyr);\n\t\t}\n\t\telse if( !nl && nr && !memo[nxl][nyl][xr][yr] ) {\n\t\t\tf |= dfs(nxl, nyl, xr, yr);\n\t\t}\n\t\telse if( nl && !nr && !memo[xl][yl][nxr][nyr] ) {\n\t\t\tf |= dfs(xl, yl, nxr, nyr);\n\t\t}\n\t}\n\treturn f;\n}\n*/\nint main() {\n\twhile(cin >> w >> h, w) {\n\t\trep(i,55) rep(j,55) wl[i][j] = wr[i][j] = true;\n\t\trep(i,55) rep(j,55) rep(k,55) rep(l,55) memo[i][j][k][l]=false;\n\t\tint xl=1, yl=1, xr=1, yr=1;\n\t\trep(y, h) {\n\t\t\tstring sl, sr;\n\t\t\tcin >> sl >> sr;\n\t\t\trep(x, w) {\n\t\t\t\tif(sl[x] == 'L') {\n\t\t\t\t\txl = x+1;\n\t\t\t\t\tyl = y+1;\n\t\t\t\t\twl[y+1][x+1] = false;\n\t\t\t\t} else if(sl[x] == '%') {\n\t\t\t\t\tgxl = x+1;\n\t\t\t\t\tgyl = y+1;\n\t\t\t\t\twl[y+1][x+1] = false;\n\t\t\t\t} else {\n\t\t\t\t\twl[y+1][x+1] = (sl[x]=='#');\n\t\t\t\t}\n\n\t\t\t\tif(sr[x] == 'R') {\n\t\t\t\t\txr = x+1;\n\t\t\t\t\tyr = y+1;\n\t\t\t\t\twr[y+1][x+1] = false;\n\t\t\t\t} else if(sr[x] == '%') {\n\t\t\t\t\tgxr = x+1;\n\t\t\t\t\tgyr = y+1;\n\t\t\t\t\twr[y+1][x+1] = false;\n\t\t\t\t} else {\n\t\t\t\t\twr[y+1][x+1] = (sr[x]=='#');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqueue<node> que;\n\t\tque.push( node(xl, yl, xr, yr) );\n\t\tbool ok = false;\n\t\twhile(!que.empty()) {\n\t\t\tnode nd = que.front();\n\t\t\tque.pop();\n\t\t\tif( memo[nd.xl][nd.yl][nd.xr][nd.yr] ) {\n\t\t\t\tcontinue;\n\t\t\t}\n//\t\t\tcout << \"lp \" << nd.xl << \" \" << nd.yl << \" \" << nd.xr << \" \" << nd.yr << endl;\n\t\t\tmemo[nd.xl][nd.yl][nd.xr][nd.yr] = true;\n\t\t\tif(nd.xl==gxl && nd.yl==gyl && nd.xr==gxr && nd.yr==gyr) {\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint dx[4] = {-1, 0, 1, 0};\n\t\t\tint dy[4] = {0, 1, 0, -1};\n\t\t\trep(i, 4) {\n\t\t\t\tint nxl = nd.xl + dx[i];\n\t\t\t\tint nyl = nd.yl + dy[i];\n\t\t\t\tint nxr = nd.xr - dx[i];\n\t\t\t\tint nyr = nd.yr + dy[i];\n\t\t\t\tbool nl = wl[nyl][nxl];\n\t\t\t\tbool nr = wr[nyr][nxr];\n\t\t\t\tbool gl = (nxl==gxl && nyl==gyl);\n\t\t\t\tbool gr = (nxr==gxr && nyr==gyr);\n\t\t\t\tif(gl ^ gr) continue;\n\t\t\t\tif( !nl && !nr && !memo[nxl][nyl][nxr][nyr] ) {\n\t\t\t\t\tque.push( node(nxl, nyl, nxr, nyr) );\n\t\t\t\t}\n\t\t\t\telse if( !nl && nr && !memo[nxl][nyl][nd.xr][nd.yr] ) {\n\t\t\t\t\tque.push( node(nxl, nyl, nd.xr, nd.yr) );\n\t\t\t\t}\n\t\t\t\telse if( nl && !nr && !memo[nd.xl][nd.yl][nxr][nyr] ) {\n\t\t\t\t\tque.push( node(nd.xl, nd.yl, nxr, nyr) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( ok ) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t} else {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_set>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nstruct Node {\n  Node(int lx, int ly, int rx, int ry) {\n    this->lx = lx;\n    this->ly = ly;\n    this->rx = rx;\n    this->ry = ry;\n  }\n\n  int val() {\n    return lx * 8000000 + ly * 40000 + rx * 200 + ry;\n  }\n\n  int lx;\n  int ly;\n  int rx;\n  int ry;\n};\n\nint main() {\n  vector<vector<char> > f(103);\n  for (int i = 0; i < f.size(); i++) {\n    f[i].resize(52);\n  }\n\n  while (true) {\n    int W, H;\n    cin >> W >> H;\n\n    if (W == 0) {\n      break;\n    }\n\n    int cw = W + 1;\n    int w = W * 2 + 3;\n    int h = H + 2;\n    for (int i = 0; i < w; i++) {\n      f[i][0] = f[i][h - 1] = '#';\n    }\n    for (int i = 0; i < h; i++) {\n      f[0][i] = f[cw][i] = f[w - 1][i] = '#';\n    }\n\n    int lx = 0, ly = 0;\n    int rx = 0, ry = 0;\n    for (int i = 1; i < h - 1; i++) {\n      for (int j = 1; j < cw; j++) {\n\tcin >> f[j][i];\n\tif (f[j][i] == 'L') {\n\t  lx = j;\n\t  ly = i;\n\t  f[j][i] = '.';\n\t}\n      }\n      for (int j = cw + 1; j < w - 1; j++) {\n\tcin >> f[j][i];\n\tif (f[j][i] == 'R') {\n\t  rx = j;\n\t  ry = i;\n\t  f[j][i] = '.';\n\t}\n      }\n    }\n\n    unordered_set<int> s;\n    queue<Node> q;\n    q.push(Node(lx, ly, rx, ry));\n    s.emplace(q.front().val());\n    while (!q.empty()) {\n      Node n = q.front();\n\n      //cout << n.val() << endl;\n\n      if (f[n.lx][n.ly] == '%' && f[n.rx][n.ry] == '%') {\n\tcout << \"Yes\" << endl;\n\tbreak;\n      }\n      q.pop();\n\n      if (f[n.lx][n.ly] == '%' || f[n.rx][n.ry] == '%') {\n\tcontinue;\n      }\n\n      Node nn(n.lx, f[n.lx][n.ly - 1] != '#' ? n.ly - 1 : n.ly,\n\t      n.rx, f[n.rx][n.ry - 1] != '#' ? n.ry - 1 : n.ry);\n\n      if (s.count(nn.val()) == 0) {\n\tq.push(nn);\n\ts.emplace(nn.val());\n      }\n\n      Node we(f[n.lx - 1][n.ly] != '#' ? n.lx - 1 : n.lx, n.ly,\n\t      f[n.rx + 1][n.ry] != '#' ? n.rx + 1 : n.rx, n.ry);\n\n      if (s.count(we.val()) == 0) {\n\tq.push(we);\n\ts.emplace(we.val());\n      }\n\n      Node ew(f[n.lx + 1][n.ly] != '#' ? n.lx + 1 : n.lx, n.ly,\n\t      f[n.rx - 1][n.ry] != '#' ? n.rx - 1 : n.rx, n.ry);\n\n      if (s.count(ew.val()) == 0) {\n\tq.push(ew);\n\ts.emplace(ew.val());\n      }\n\n      Node ss(n.lx, f[n.lx][n.ly + 1] != '#' ? n.ly + 1 : n.ly,\n\t      n.rx, f[n.rx][n.ry + 1] != '#' ? n.ry + 1 : n.ry);\n\n      if (s.count(ss.val()) == 0) {\n\tq.push(ss);\n\ts.emplace(ss.val());\n      }\n    }\n\n    if (q.empty()) {\n      cout << \"No\" << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint h, w;\nint sax, say, sbx, sby, gax, gay, gbx, gby;\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\nbool used[55][55][55][55];\n\nbool can(int y, int x) {\n\tif(0 <= y && y < h && 0 <= x && x < w) return true;\n\treturn false;\n}\n\nint main() {\n\twhile(cin >> w >> h) {\n\t\tif(w == 0 && h == 0) break;\n\n\t\tstring A[h], B[h];\n\t\trep(i, h) cin >> A[i] >> B[i];\n\t\trep(i, h) reverse(B[i].begin(), B[i].end());\n\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\tif(A[i][j] == 'L') {\n\t\t\t\t\tsay = i;\n\t\t\t\t\tsax = j;\n\t\t\t\t\tA[i][j] = '.';\n\t\t\t\t}\n\n\t\t\t\tif(B[i][j] == 'R') {\n\t\t\t\t\tsby = i;\n\t\t\t\t\tsbx = j;\n\t\t\t\t\tB[i][j] = '.';\n\t\t\t\t}\n\n\t\t\t\tif(A[i][j] == '%') {\n\t\t\t\t\tgay = i;\n\t\t\t\t\tgax = j;\n\t\t\t\t\tA[i][j] = '.';\n\t\t\t\t}\n\n\t\t\t\tif(B[i][j] == '%') {\n\t\t\t\t\tgby = i;\n\t\t\t\t\tgbx = j;\n\t\t\t\t\tB[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqueue<pair< P, P > > que;\n\t\tque.push(mp( mp(say, sax), mp(sby, sbx) ));\n\n\t\tmemset(used, 0, sizeof(used));\n\t\tused[say][sax][sby][sbx] = true;\n\n\t\tbool flag = false;\n\n\t\twhile(que.size()) {\n\t\t\tpair<P, P> p = que.front(); que.pop();\n\n\t\t\tint ay = p.first.first, ax = p.first.second;\n\t\t\tint by = p.second.first, bx = p.second.second;\n\n\t\t\tif(ay == gay && ax == gax && by == gby && bx == gbx) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif((ay == gay && ax == gax) || (by == gby && bx == gbx)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\trep(i, 4) {\n\t\t\t\tint nay = ay + dy[i];\n\t\t\t\tint nax = ax + dx[i];\n\n\t\t\t\tint nby = by + dy[i];\n\t\t\t\tint nbx = bx + dx[i];\n\n\t\t\t\tif(!can(nay, nax) || A[nay][nax] == '#') {\n\t\t\t\t\tnay -= dy[i];\n\t\t\t\t\tnax -= dx[i];\n\t\t\t\t}\n\n\t\t\t\tif(!can(nby, nbx) || B[nby][nbx] == '#') {\n\t\t\t\t\tnby -= dy[i];\n\t\t\t\t\tnbx -= dx[i];\n\t\t\t\t}\n\n\t\t\t\tif(!used[nay][nax][nby][nbx]) {\n\t\t\t\t\tque.push(mp( mp(nay, nax), mp(nby, nbx) ));\n\t\t\t\t\tused[nay][nax][nby][nbx] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(flag) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t} else {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\nusing namespace std;\n\nstruct Data{int x[2],y[2];};\nData start,goal;\n\nint W,H;\nvector< vector<string> >room(2);\n\nint dx[2][4]={{0,1,0,-1}, {0,-1,0,1}};\nint dy[2][4]={{-1,0,1,0}, {-1,0,1,0}};\n\nbool operator<(Data a, Data b){\n  return a.x[0]!=b.x[0]?a.x[0]<b.x[0]:(a.y[0]!=b.y[0]?a.y[0]<b.y[0]:(\n           a.x[1]!=b.x[1]?a.x[1]<b.x[1]:a.y[1]<b.y[1]\n         ));\n}\nbool operator==(Data a, Data b){\n  return a.x[0]==b.x[0] && a.x[1]==b.x[1] && a.y[0]==b.y[0] && a.y[1]==b.y[1];\n}\nbool over(Data a){\n  return a.x[0]<0 || W<=a.x[0] || a.y[0]<0 || H<=a.y[0] ||\n         a.x[1]<0 || W<=a.x[1] || a.y[1]<0 || H<=a.y[1];\n}\n\nbool bfs()\n{\n  queue<Data>q;\n  q.push(start);\n  map<Data,bool>visited;\n\n  while(!q.empty()){\n    Data now=q.front();\n    q.pop();\n\n    visited[now]=true;\n\n    if(now==goal)return true;\n    if(now.x[0]==goal.x[0] && now.y[0]==goal.y[0])continue;\n    if(now.x[1]==goal.x[1] && now.y[1]==goal.y[1])continue;\n\n    for(int i=0;i<4;i++){\n      Data next=now;\n      for(int j=0;j<2;j++){\n\tnext.x[j]+=dx[j][i];\n\tnext.y[j]+=dy[j][i];\n\tif(over(next) || room[j][next.y[j]][next.x[j]]=='#'){\n\t  next.x[j]=now.x[j];\n\t  next.y[j]=now.y[j];\n\t}\n      }\n      if(visited.count(next))continue;\n      q.push(next);\n    }\n  }\n\n  return false;\n}\n\nint main()\n{\n  while(cin>>W>>H,W|H){\n    room[0].resize(H);\n    room[1].resize(H);\n    for(int i=0;i<H;i++){\n      cin>>room[0][i]>>room[1][i];\n      for(int j=0;j<W;j++){\n\tif(room[0][i][j]=='L'){\n\t  start.x[0]=j;\n\t  start.y[0]=i;\n\t}\n\tif(room[1][i][j]=='R'){\n\t  start.x[1]=j;\n\t  start.y[1]=i;\n\t}\n\tif(room[0][i][j]=='%'){\n\t  goal.x[0]=j;\n\t  goal.y[0]=i;\n\t}\n\tif(room[1][i][j]=='%'){\n\t  goal.x[1]=j;\n\t  goal.y[1]=i;\n\t}\n      }\n    }\n\n    puts(bfs()?\"Yes\":\"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <complex>\nusing namespace std;\ntypedef complex<int> P;\n\nint main()\n{\n  int W, H;\n  while (cin >> W >> H && W != 0) {\n    vector<string> roomL(H), roomR(H);\n    P startL, startR;\n    for (int i = 0; i < H; i++) {\n      cin >> roomL[i] >> roomR[i];\n      for (int j = 0; j < W; j++) {\n        if (roomL[i][j] == 'L') {\n          roomL[i][j] = '.';\n          startL = P(i, j);\n        }\n        if (roomR[i][j] == 'R') {\n          roomR[i][j] = '.';\n          startR = P(i, j);\n        }\n      }\n    }\n\n    queue<pair<P,P> > q;\n    q.push(make_pair(startL, startR));\n    vector<vector<bool> > visited(W*H, vector<bool>(W*H, false));\n    visited[startL.real()*W + startL.imag()][startR.real()*W + startR.imag()] = true;\n    while (!q.empty()) {\n      const pair<P, P> p = q.front();\n      q.pop();\n      if (roomL[p.first.real()][p.first.imag()] == '%'\n          || roomR[p.second.real()][p.second.imag()] == '%') {\n        if (roomL[p.first.real()][p.first.imag()] == '%'\n            && roomR[p.second.real()][p.second.imag()] == '%') {\n          cout << \"Yes\" << endl;\n          goto NEXT;\n        } else {\n          continue;\n        }\n      }\n\n      for (int d = 0; d < 4; d++) {\n        static const P dir[] = {P(-1,0), P(1,0), P(0,-1), P(0,1)};\n        P nextL = p.first + dir[d];\n        P nextR = p.second + P(dir[d].real(), dir[d].imag() == -1 ? 1 : (dir[d].imag() == 1 ? -1 : 0));\n        if (nextL.real() == -1 || nextL.real() == H\n            || nextL.imag() == -1 || nextL.imag() == W\n            || roomL[nextL.real()][nextL.imag()] == '#') {\n          nextL = p.first;\n        }\n        if (nextR.real() == -1 || nextR.real() == H\n            || nextR.imag() == -1 || nextR.imag() == W\n            || roomR[nextR.real()][nextR.imag()] == '#') {\n          nextR = p.second;\n        }\n        if (!visited[nextL.real()*W + nextL.imag()][nextR.real()*W + nextR.imag()]) {\n          q.push(make_pair(nextL, nextR));\n          visited[nextL.real()*W + nextL.imag()][nextR.real()*W + nextR.imag()] = true;\n        }\n      }\n    }\n    cout << \"No\" << endl;\nNEXT:\n    ;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<queue>\n#define MAX 10\nusing namespace std;\nstruct Point{int x,y;};\nstruct P{\n  Point l,r;\n  int cost;\n};\nint main(){\n  int w,h;\n  while(cin>>w>>h,w||h){\n    int i,j,k;\n    int inf = 1<<20;\n    int d[MAX+1][MAX+1][MAX+1][MAX+1];\n    fill(d[0][0][0],d[MAX][MAX][MAX],inf);\n    \n    string sr[60],sl[60];\n    for(i=0;i<h;i++){\n      cin >> sl[i] >> sr[i];\n    }\n    /*\n    Point pr,pl,br,bl;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(sl[i][j]=='L'){\n\t  pl.x=j;pl.y=i;\n\t}\n\tif(sr[i][j]=='R'){\n\t  pr.x=j;pr.y=i;\n\t}\n      }\n    }\n    //cout << pl.x << \":\" << pl.y << endl;\n    //cout << pr.x << \":\" << pr.y << endl;\n    d[pl.x][pl.y][pr.x][pr.y]=0;\n    P p,b;\n    p.r=pr;\n    p.l=pl;\n    p.cost=d[pl.x][pl.y][pr.x][pr.y];\n    queue<P> q;\n    q.push(p);\n    bool f = false;\n    while(!q.empty()){\n      p=q.front();q.pop();\n      pl=p.l;pr=p.r;\n      if(p.cost>d[pl.x][pl.y][pr.x][pr.y]) continue;\n      d[pl.x][pl.y][pr.x][pr.y]=p.cost;\n      //cout << pl.x<<\":\"<<pl.y<<\":\"<<pr.x<<\":\"<<pr.y<<\"/\"<<p.cost<<endl;\n      if(sl[pl.y][pl.x]=='%'&&sr[pr.y][pr.x]=='%'){\n\tf=true;\n\tbreak;\n      }else if(sl[pl.y][pl.x]=='%') continue;\n      else if(sr[pr.y][pr.x]=='%') continue;\n      \n      p.cost++;\n      int lx[]={1,-1,0,0};int ly[]={0,0,1,-1};\n      int rx[]={-1,1,0,0};int ry[]={0,0,1,-1};\n      for(i=0;i<4;i++){\n\tbl=pl;br=pr;\n\tbl.x+=lx[i];bl.y+=ly[i];\n\tbr.x+=rx[i];br.y+=ry[i];\n\n\t//cout << bl.x<<\":\"<<bl.y<<\":\"<<br.x<<\":\"<<br.y<<\"/\"<<p.cost<<endl;\n\t\n\tif(bl.x<0) bl.x=0;\n\telse if(bl.x>=w) bl.x=w-1;\n\tif(bl.y<0) bl.y=0;\n\telse if(bl.y>=h) bl.y=h-1;\n\n\tif(br.x<0) br.x=0;\n\telse if(br.x>=w) br.x=w-1;\n\tif(br.y<0) br.y=0;\n\telse if(br.y>=h) br.y=h-1;\n\n\tif(sl[bl.y][bl.x]=='#'){\n\t  bl.x-=lx[i];bl.y-=ly[i];\n\t}\n\tif(sr[br.y][br.x]=='#'){\n\t  br.x-=rx[i];br.y-=ry[i];\n\t}\n\tp.r=br;p.l=bl;\n\tq.push(p);\n      }\n    }\n    if(f) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    */\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 52\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\nint H,W;\nstring s,t;\nchar A[MAX][MAX];\nchar B[MAX][MAX];\nint asy,asx,aty,atx;\nint bsy,bsx,bty,btx;\nbool visited[MAX][MAX][MAX][MAX];\nstruct state{int ay,ax,by,bx;};\n\nstring solve(){\n  for(int i=0;i<MAX;i++)\n    for(int j=0;j<MAX;j++)\n      for(int k=0;k<MAX;k++)\n\tfor(int l=0;l<MAX;l++)\n\t  visited[i][j][k][l]=false;\n  queue<state> Q;\n  Q.push((state){asy,asx,bsy,bsx});\n  while(!Q.empty()){\n    state s=Q.front();Q.pop();\n    bool fa=false,fb=false;\n    if(s.ay==aty&&s.ax==atx)fa=true;\n    if(s.by==bty&&s.bx==btx)fb=true;\n    if(fa&&fb)return \"Yes\";\n    if(fa||fb)continue;\n    for(int i=0;i<4;i++){\n      state to=s;\n      to.ay+=dy[i];\n      to.ax+=dx[i];\n      if(A[to.ay][to.ax]=='#'){\n\tto.ay=s.ay;\n\tto.ax=s.ax;\n      }\n      to.by+=dy[i];\n      to.bx-=dx[i];\n      if(B[to.by][to.bx]=='#'){\n\tto.by=s.by;\n\tto.bx=s.bx;\n      }\n      if(visited[to.ay][to.ax][to.by][to.bx])continue;\n      visited[to.ay][to.ax][to.by][to.bx]=true;\n      Q.push(to);\n    }\n  }\n  return \"No\";\n}\n\nint main(){\n  while(1){\n    cin>>W>>H;\n    if(H==0&&W==0)break;\n    for(int i=0;i<MAX;i++)\n      for(int j=0;j<MAX;j++)\n\tA[i][j]=B[i][j]='#';\n    for(int i=0;i<H;i++){\n      cin>>s>>t;\n      for(int j=0;j<W;j++){\n\tA[i+1][j+1]=s[j];\n\tB[i+1][j+1]=t[j];\n\tif(s[j]=='L'){\n\t  A[i+1][j+1]='.';\n\t  asy=i+1,asx=j+1;\n\t}\n\tif(s[j]=='%'){\n\t  A[i+1][j+1]='.';\n\t  aty=i+1,atx=j+1;\n\t}\n\tif(t[j]=='R'){\n\t  B[i+1][j+1]='.';\n\t  bsy=i+1,bsx=j+1;\n\t}\n\tif(t[j]=='%'){\n\t  B[i+1][j+1]='.';\n\t  bty=i+1,btx=j+1;\n\t}\n      }\n    }\n    cout<<solve()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include<bits/stdc++.h>\n using namespace std;\n#define INF 1000000000\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\ntypedef long long LL;\nint H,W;\nint A[100][100];\nint B[100][100];\nint sax,say,tax,tay;\nint sbx,sby,tbx,tby;\nbool used[61][61][61][61];\ntypedef pair<int,int>P;\ntypedef pair<P,P>PP;\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\n\nP move(P now,int x,int y){\n  if(now.first+x<0){\n     return now;\n  }\n  if(now.first+x>=W){\n     return now;\n  }\n  if(now.second+y<0){\n     return now;\n  }\n  if(now.second+y>=H){\n     return now;\n  }\n  if(A[now.first+x][now.second]!=1){\n     now.first+=x;\n  }\n  if(A[now.first][now.second+y]!=1){\n     now.second+=y;\n  }\n  return now;\n}\n\nP move2(P now,int x,int y){\n  if(now.first+x<0){\n     return now;\n  }\n  if(now.first+x>=W){\n     return now;\n  }\n  if(now.second+y<0){\n     return now;\n  }\n  if(now.second+y>=H){\n     return now;\n  }\n  if(B[now.first+x][now.second]!=1){\n     now.first+=x;\n  }\n  if(B[now.first][now.second+y]!=1){\n     now.second+=y;\n  }\n  return now;\n}\n\n\nint main(){\n    while(cin>>W>>H,W){\n       //vector<int>\n       REP(i,H){\n           string s;\n           cin>>s;\n           REP(j,W){\n              if(s[j]=='L'){\n                 sax=j;\n                 say=i;\n              }\n              if(s[j]=='%'){\n                 tax=j;\n                 tay=i;\n              }\n              A[j][i]=0;\n              if(s[j]=='#'){\n                 A[j][i]=1;\n              }\n           }\n           cin>>s;\n           REP(j,W){\n              if(s[j]=='R'){\n                 sbx=j;\n                 sby=i;\n              }\n              if(s[j]=='%'){\n                 tbx=j;\n                 tby=i;\n              }\n              B[j][i]=0;\n              if(s[j]=='#'){\n                 B[j][i]=1;\n              }\n           }\n       }\n       //cout<<tax<<\" \"<<tay<<\" \"<<tbx<<\" \"<<tby<<endl;\n       //????????????bfs\n       REP(i,60){\n           REP(j,60){\n               REP(k,60){\n                   REP(l,60){\n                       used[i][j][k][l]=false;\n                   }\n               }\n           }\n       }\n\n       used[sax][say][sbx][sby]=true;\n       vector<PP>v;\n       v.push_back(PP(P(sax,say),P(sbx,sby)));\n       int now=0;\n       while(now!=v.size()){\n          P l=v[now].first;\n          P r=v[now].second;\n          used[l.first][l.second][r.first][r.second]=true;\n          //cout<<l.first<<\" \"<<l.second<<\" \"<<r.first<<\" \"<<r.second<<endl;\n          REP(i,4){\n              P ll=move(l,dx[i],dy[i]);\n              P rr=move2(r,-dx[i],dy[i]);\n              if(used[ll.first][ll.second][rr.first][rr.second]==false){\n              //cout<<\"ok\"<<ll.first<<\" \"<<ll.second<<\" \"<<rr.first<<\" \"<<rr.second<<endl;\n                 if((ll.first==tax)&&(ll.second==tay)){\n                    used[ll.first][ll.second][rr.first][rr.second]=true;\n                    continue;\n                 }\n                 if((rr.first==tbx)&&(rr.second==tby)){\n                    used[ll.first][ll.second][rr.first][rr.second]=true;\n                    continue;\n                 }\n                   v.push_back(PP(ll,rr));\n              }\n          }\n          now++;\n       }\n\n       if(used[tax][tay][tbx][tby]==true){\n          cout<<\"Yes\"<<endl;\n       }else{\n          cout<<\"No\"<<endl;\n       }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\nbool vis[50][50][50][50];\n\nvoid move(int& x, int& y, int dir, vector<string>& a) {\n\tint H = a.size(), W = a[0].length();\n\tx += dx[dir]; y += dy[dir];\n\tif (x >= 0 && x < W && y >= 0 && y < H && a[y][x] != '#')\n\t\treturn;\n\tx -= dx[dir]; y -= dy[dir];\n}\n\nint main() {\n\tfor (;;) {\n\t\tint W, H; cin >> W >> H;\n\t\tif (W == 0 && H == 0) break;\n\t\tvector<string> al(H), ar(H);\n\t\tint xsl, ysl, xtl, ytl, xsr, ysr, xtr, ytr;\n\t\tfor (int y = 0; y < H; y++) {\n\t\t\tcin >> al[y] >> ar[y];\n\t\t\treverse(ar[y].begin(), ar[y].end());\n\t\t\tfor (int x = 0; x < W; x++) {\n\t\t\t\tif (al[y][x] == 'L') {\n\t\t\t\t\txsl = x; ysl = y;\n\t\t\t\t}\n\t\t\t\tif (al[y][x] == '%') {\n\t\t\t\t\txtl = x; ytl = y;\n\t\t\t\t}\n\t\t\t\tif (ar[y][x] == 'R') {\n\t\t\t\t\txsr = x; ysr = y;\n\t\t\t\t}\n\t\t\t\tif (ar[y][x] == '%') {\n\t\t\t\t\txtr = x; ytr = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int yl = 0; yl < H; yl++)\n\t\t\tfor (int xl = 0; xl < W; xl++)\n\t\t\t\tfor (int yr = 0; yr < H; yr++)\n\t\t\t\t\tfor (int xr = 0; xr < W; xr++)\n\t\t\t\t\t\tvis[xl][yl][xr][yr] = false;\n\t\tvis[xsl][ysl][xsr][ysr] = true;\n\t\tqueue<int> XL, YL, XR, YR;\n\t\tXL.push(xsl); YL.push(ysl); XR.push(xsr); YR.push(ysr);\n\t\twhile (!XL.empty()) {\n\t\t\tint xl = XL.front(); XL.pop();\n\t\t\tint yl = YL.front(); YL.pop();\n\t\t\tint xr = XR.front(); XR.pop();\n\t\t\tint yr = YR.front(); YR.pop();\n\t\t\tfor (int dir = 0; dir < 4; dir++) {\n\t\t\t\tint _xl = xl, _yl = yl, _xr = xr, _yr = yr;\n\t\t\t\tmove(_xl, _yl, dir, al);\n\t\t\t\tmove(_xr, _yr, dir, ar);\n\t\t\t\tif (vis[_xl][_yl][_xr][_yr]) continue;\n\t\t\t\tvis[_xl][_yl][_xr][_yr] = true;\n\t\t\t\tif ((_xl == xtl && _yl == ytl) || (_xr == xtr && _yr == ytr)) continue;\n\t\t\t\tXL.push(_xl); YL.push(_yl); XR.push(_xr); YR.push(_yr);\n\t\t\t}\n\t\t}\n\t\tcout << (vis[xtl][ytl][xtr][ytr] ? \"Yes\" : \"No\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n#define IN(x, w) 0 <= (x) && (x) <(w) \n\n#define X first\n#define Y second\n#define R first\n#define L second\n\ntypedef pair<pii, pii> State;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint dx[] = { 1, 0,-1, 0};\nint dy[] = { 0, 1, 0,-1};\n\nint main(void){\n    string res;\n    for(int w, h; cin >> w >> h, w; cout << res << endl){\n        res = \"No\";\n        pair<vs, vs> cave = mp(vs(h), vs(h));\n\n        State s;\n        rep(y, h){\n            cin >> cave.L[y];\n            cin >> cave.R[y];\n            rep(x, w){\n                if(cave.L[y][x] == 'L') s.L = mp(x, y), cave.L[y][x] = '.';\n                if(cave.R[y][x] == 'R') s.R = mp(x, y), cave.R[y][x] = '.';\n            }\n        }\n\n        map<State, bool> used;\n\n        queue<State> q;\n        q.push(s);\n\n        while(!q.empty()){\n            State cur = q.front(); q.pop();\n\n            if(cave.L[cur.L.Y][cur.L.X] == '%' || cave.R[cur.R.Y][cur.R.X] == '%'){\n                if(cave.L[cur.L.Y][cur.L.X] == '%' && cave.R[cur.R.Y][cur.R.X] == '%'){\n                    res = \"Yes\";\n                    break;\n                }\n                continue;\n            }\n\n            rep(i, 4){\n                State next = cur;\n\n                if(IN(next.L.X + dx[i], w) && cave.L[next.L.Y][next.L.X + dx[i]] != '#') next.L.X += dx[i];\n                if(IN(next.L.Y + dy[i], h) && cave.L[next.L.Y + dy[i]][next.L.X] != '#') next.L.Y += dy[i];\n                if(IN(next.R.X - dx[i], w) && cave.R[next.R.Y][next.R.X - dx[i]] != '#') next.R.X -= dx[i];\n                if(IN(next.R.Y + dy[i], h) && cave.R[next.R.Y + dy[i]][next.R.X] != '#') next.R.Y += dy[i];\n\n                if(!used[next]){\n                    q.push(next);\n                    used[next] = true;\n                }\n            }\n        }\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nconst int kMax_N = 51;\nchar fieldL[kMax_N + 1][kMax_N + 1];\nchar fieldR[kMax_N + 1][kMax_N + 1];\nbool checked[kMax_N + 1][kMax_N + 1][kMax_N + 1][kMax_N + 1];\n\n\nconst int dyL[] = { -1, 0, 1, 0 };\nconst int dxL[] = { 0, 1, 0, -1 };\nconst int dyR[] = { -1, 0, 1, 0 };\nconst int dxR[] = { 0, -1, 0, 1 };\n\nint w, h;\n\n\nstruct Search {\n  int ly, lx;\n  int ry, rx;\n  Search() = default;\n  Search(int a, int b, int c, int d):\n    ly(a), lx(b), ry(c), rx(d) { }\n};\nint main() {\n  while (true) {\n    cin >> w >> h;\n    if (w + h == 0) {\n      break;\n    }\n    int ly, lx, ry, rx;\n    for (int i = 0; i < h; i++) {\n      string strL, strR;\n      cin >> strL >> strR;\n      for (int j = 0; j < w; j++) {\n        fieldL[i][j] = strL[j];\n        fieldR[i][j] = strR[j];\n        if (strL[j] == 'L') {\n          ly = i; lx = j;\n        }\n        if (strR[j] == 'R') {\n          ry = i; rx = j;\n        }\n      }\n    }\n\n    memset(checked, false, sizeof(checked));\n\n    queue<Search> que;\n    que.push(Search(ly, lx, ry, rx));\n    bool ok = false;\n    while (!que.empty()) {\n      Search s = que.front(); que.pop();\n      if (fieldL[s.ly][s.lx] == fieldR[s.ry][s.rx] && fieldL[s.ly][s.lx] == '%') {\n        ok = true;\n        break;\n      }\n      if (checked[s.ly][s.lx][s.ry][s.rx]) {\n        continue;\n      }\n      checked[s.ly][s.lx][s.ry][s.rx] = true;\n      for (int i = 0; i < 4; i++) {\n        int nly = s.ly + dyL[i];\n        int nlx = s.lx + dxL[i];\n        int nry = s.ry + dyR[i];\n        int nrx = s.rx + dxR[i];\n        if (nly < 0) nly = 0;\n        if (nly >= h) nly = h - 1;\n        if (nlx < 0) nlx = 0;\n        if (nlx >= w) nlx = w - 1;\n        if (nry < 0) nry = 0;\n        if (nry >= h) nry = h - 1;\n        if (nrx < 0) nrx = 0;\n        if (nrx >= w) nrx = w - 1;\n        if (fieldL[nly][nlx] == '#') {\n          nly = s.ly; nlx = s.lx;\n        }\n        if (fieldR[nry][nrx] == '#') {\n          nry = s.ry; nrx = s.rx;\n        }\n        que.push(Search(nly, nlx, nry, nrx));\n      }\n    }\n    if (ok) {\n      cout << \"Yes\" << endl;\n    } else {\n      cout << \"No\" << endl;\n    }\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// C++11\n#include \"bits/stdc++.h\"\n#include <sys/time.h>\n#include <emmintrin.h>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <random>\n#include <bitset>\n\nusing namespace std;\n\ninline long long GetTSC() {\n  long long lo, hi;\n  asm volatile (\"rdtsc\": \"=a\"(lo), \"=d\"(hi));\n  return lo + (hi << 32);\n}\ninline double GetSeconds() {\n  return GetTSC() / 2.8e9;\n}\n\nconst long inf = pow(10,15);\nint di[] = {-1,0,1,0};\nint dj[] = {0,1,0,-1};\ntuple<int, int>q[50*50*50*50];\n\nvoid solve(){\n  double starttime = GetSeconds();\n  while(1){\n    int w,h;\n    cin >> w >> h;\n    // cerr << w << \", \" << h << endl;\n    if(w==0 && h==0) break;\n    int lp,ls,rp,rs;\n    bool lb[2500] = {};\n    bool rb[2500] = {};\n    bool f[2500][2500] = {};\n    for(int i=0; i<h; i++){\n      string s;\n      cin >> s;\n      for(int j=0; j<w; j++){\n        if(s[j]=='#') lb[i*w+j] = 1;\n        if(s[j]=='%') lp = i*w+j;\n        if(s[j]=='L') ls = i*w+j;\n      }\n      cin >> s;\n      for(int j=0; j<w; j++){\n        if(s[j]=='#') rb[i*w+j] = 1;\n        if(s[j]=='%') rp = i*w+j;\n        if(s[j]=='R') rs = i*w+j;\n      }\n    }\n    f[ls][rs] = 1;\n    int qi = 0;\n    int qe = 1;\n    q[0] = make_tuple(ls,rs);\n    bool ff = 0;\n    while(qi<qe){\n      int lt = get<0>(q[qi]);\n      int rt = get<1>(q[qi]);\n      int li = lt / w;\n      int lj = lt % w;\n      int ri = rt / w;\n      int rj = rt % w;\n      qi++;\n      // cerr << \"qie: \" << qi << \", \" << qe << \", lij: \" << li << \", \" << lj << \", rij: \" << ri << \", \" << rj << endl;\n      for(int i=0; i<4; i++){\n        int nli = li + di[i];\n        int nlj = lj + dj[i];\n        int nri = ri + di[i];\n        int nrj = rj - dj[i];\n        if(nli < 0 || nli >= h || nlj < 0 || nlj >= w || lb[nli*w+nlj]){\n          nli = li;\n          nlj = lj;\n        }\n        if(nri < 0 || nri >= h || nrj < 0 || nrj >= w || rb[nri*w+nrj]){\n          nri = ri;\n          nrj = rj;\n        }\n        int nlt = nli*w+nlj;\n        int nrt = nri*w+nrj;\n        if(nlt == lp && nrt == rp){\n          ff = 1;\n          break;\n        }\n        if(nlt == lp || nrt == rp) continue;\n        if(f[nlt][nrt]) continue;\n        f[nlt][nrt] = 1;\n        q[qe++] = make_tuple(nlt,nrt);\n      }\n      if(ff) break;\n    }\n    if(ff){\n      cout << \"Yes\" << endl;\n    }else{\n      cout << \"No\" << endl;\n    }\n  }\n  cerr << \"time: \" << GetSeconds() - starttime << endl;\n\n  return;\n}\n\nint main() {\n  solve();\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? 1e9:1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){int b=0;for(auto itr :a){if(b++!=0)cout << \" \"; cout << itr;} }\nusing ll  = long long;\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\n#define int ll\nstruct P{\n    int ly,lx,ry,rx;\n};\n\nsigned main(){\n    while(cin >> W >> H ,W+H){\n        vector<string>Le(H);\n        vector<string>Re(H);\n        rep(i,H) cin >> Le[i] >> Re[i];\n        int lx,ly,rx,ry;\n        rep(i,H)rep(j,W){\n            if(Le[i][j] == 'L'){\n                lx = j; ly = i;\n            }\n            if(Re[i][j] == 'R'){\n                rx = j;ry = i;\n            }\n        }\n        auto used = vectors(H,W,H,W,false);\n        queue<P>que;\n        que.push(P{ly,lx,ry,rx});\n        bool flag = false;\n        while(!que.empty()){\n            P t = que.front();\n            que.pop();\n            if(used[t.ly][t.lx][t.ry][t.rx])continue;\n            used[t.ly][t.lx][t.ry][t.rx] = true;\n            if(Le[t.ly][t.lx] == '%' &&  Re[t.ry][t.rx] == '%'){\n                flag = true;\n                break;\n            } if(Le[t.ly][t.lx] == '%' or  Re[t.ry][t.rx] == '%'){\n                continue;\n            }\n            int nly,nlx,nry,nrx;\n            rep(k,4){\n                nly = t.ly +dy[k]; nlx = t.lx + dx[k];\n                nry = t.ry + dy[k]; nrx = t.rx -dx[k];\n                if(!valid(nlx,nly) || Le[nly][nlx] == '#'){\n                    nly = t.ly; nlx = t.lx;\n                }\n                if(!valid(nrx,nry) || Re[nry][nrx] == '#'){\n                    nrx = t.rx; nry = t.ry;\n                }\n                \n                que.push(P{nly,nlx,nry,nrx});\n            }\n        }\n        if(flag)cout << \"Yes\"<< endl;\n        else cout << \"No\" << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nstring RenR[50],LinR[50];\nbool memo[50][50][50][50];\nstring ans;\nint h,w;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nclass S{\npublic:\n    int rx,ry,lx,ly;\n    S(int lx,int ly,int rx,int ry):lx(lx),ly(ly),rx(rx),ry(ry){}\n}; \n\nint main()\n{\n  int ri,rj,li,lj;\n  while(1){\n    cin>>w>>h;\n    if(w+h==0)break;\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tfor(int k=0;k<h;k++){\n\t  for(int l=0;l<w;l++)memo[i][j][k][l]=false;\n\t}\n      }\n    }\n\n    for(int i=0;i<h;i++){\n      cin>>LinR[i];\n      for(int j=0;j<w;j++){\n\tif(LinR[i][j]=='L'){\n\t  li=i;lj=j;\n\t  break;\n\t}\n      }\n      cin>>RenR[i];\n      for(int j=0;j<w;j++){\n\tif(RenR[i][j]=='R'){\n\t  ri=i;rj=j;\n\t  break;\n\t}\n      }\n    }\n    queue<S> Q;\n    Q.push(S(lj,li,rj,ri));\n    ans=\"No\";\n    while(!Q.empty()){\n      S s=Q.front();Q.pop();\n      if(RenR[s.ry][s.rx]=='%' && LinR[s.ly][s.lx]=='%'){\n        ans=\"Yes\";\n\tbreak;\n      }\n      if(RenR[s.ry][s.rx]=='%' || LinR[s.ly][s.lx]=='%')continue;\n      if(memo[s.lx][s.ly][s.rx][s.ry])continue;\n      memo[s.lx][s.ly][s.rx][s.ry]=true;\n\n      for(int k=0;k<4;k++){\n\tint rx=s.rx+dx[k],ry=s.ry-dy[k];\n        if(rx<0 || ry<0 || rx>=w || ry>=h){\n\t  rx=s.rx;\n\t  ry=s.ry;\n\t}\n        if(RenR[ry][rx]=='#'){\n\t  rx=s.rx;\n\t  ry=s.ry;\n\t}\n\tint lx=s.lx+dx[(k+2)%4],ly=s.ly+dy[(k+2)%4];\n        if(lx<0 || ly<0 || lx>=w || ly>=h){\n\t  lx=s.lx;\n\t  ly=s.ly;\n\t}\n\tif(LinR[ly][lx]=='#'){\n\t  lx=s.lx;\n\t  ly=s.ly;\n\t}\n\tQ.push(S(lx,ly,rx,ry));\n      }\n    }\n    cout<<ans<<endl;\t\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\nint const dxL[] = {-1,0,1,0};\nint const dxR[] = {1,0,-1,0};\nint const dy[]  = {0,-1,0,1};\ntypedef pair<int, int> Pii;\n#define X first\n#define Y second\nint const INF = 1<<28;\nint W, H;\nchar grL[51][51], grR[51][51];\nint dist[300][300];\ninline bool isValid(int x, int y) {\n  if(0<=x&&x<W && 0<=y&&y<H) return true;\n  return false;\n}\n\ninline bool inF(int x, int y, int isL) {\n  if(isL) return grL[y][x]!='#';\n  return grR[y][x]!='#';\n}\ninline int toNode(int x, int y) {\n  return y*W+x;\n}\ninline void toPos(int node, int &x, int &y) {\n  x = node%W, y = node/W;\n}\nint main() {\n  \n  while(cin >> W >> H && (W|H)) {\n    int sxL, syL, sxR, syR;\n    int gxL, gyL, gxR, gyR;\n    for(int i=0; i<H; i++) {\n      for(int j=0; j<2*W; j++) {\n        if(j<W) {\n          cin >> grL[i][j];\n          if(grL[i][j] == 'L') {\n            sxL = j, syL = i;\n          }\n          if(grL[i][j] == '%') {\n            gxL = j, gyL = i;\n          }\n        }\n        else {\n          cin >> grR[i][j-W];\n          if(grR[i][j-W] == 'R') {\n            sxR = j-W, syR = i;\n          }\n          if(grR[i][j-W] == '%') {\n            gxR = j-W, gyR = i;\n          }\n        }\n      }\n    }\n    \n    queue<int> qL, qR;\n    qL.push(toNode(sxL, syL)); qR.push(toNode(sxR, syR));\n    bool ok = false;\n    fill(dist[0], dist[0]+300*300, INF);\n    dist[toNode(sxL, syL)][toNode(sxR, syR)] = 0;\n    while(!qL.empty()) {\n      int nowL = qL.front(); qL.pop();\n      int nowR = qR.front(); qR.pop();\n      int lx, ly; toPos(nowL, lx, ly);\n      int rx, ry; toPos(nowR, rx, ry);\n      if(lx == gxL && ly == gyL && rx == gxR && ry == gyR) {\n        ok = true; break;\n      }\n      if(lx == gxL && ly == gyL) {\n        continue;\n      }\n      if(rx == gxR && ry == gyR) {\n        continue;\n      }\n      for(int i=0; i<4; i++) {\n        int nxL = lx+dxL[i], nyL = ly+dy[i];\n        int nxR = rx+dxR[i], nyR = ry+dy[i];\n        if((!isValid(nxL, nyL)) || (!isValid(nxR, nyR))) continue;\n        if((!inF(nxL, nyL, 1)) && (!inF(nxR, nyR, 0))) continue;\n        if(!inF(nxL, nyL, 1)) { nxL = lx, nyL = ly; }\n        if(!inF(nxR, nyR, 0)) { nxR = rx, nyR = ry; }\n        if(dist[toNode(nxL, nyL)][toNode(nxR, nyR)] != INF) continue;\n        qL.push(toNode(nxL, nyL));\n        qR.push(toNode(nxR, nyR));\n        dist[toNode(nxL, nyL)][toNode(nxR, nyR)] = dist[nowL][nowR]+1;\n      }\n    }\n    if(ok) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\nusing namespace std;\n\nstruct state{ int lx,ly,rx,ry; };\n\nint dx[] = {0,1,0,-1},dy[] = {1,0,-1,0};\n\nint main(){\n\tint h,w;\n\twhile(cin >> w >> h,h){\n\t\tint lx,ly,rx,ry;\n\t\tbool dp[50][50][50][50] = {},flag = false;\n\t\tstring lf[50],rf[50];\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tcin >> lf[i] >> rf[i];\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(lf[i][j] == 'L'){\n\t\t\t\t\tlx = i;\n\t\t\t\t\tly = j;\n\t\t\t\t}\n\t\t\t\tif(rf[i][j] == 'R'){\n\t\t\t\t\trx = i;\n\t\t\t\t\try = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<state> que;\n\t\tque.push({lx,ly,rx,ry});\n\t\twhile(!que.empty()){\n\t\t\tstate s = que.front();que.pop();\n\t\t\tif(dp[s.lx][s.ly][s.rx][s.ry]) continue;\n\t\t\t//cout << s.lx << \" \" << s.ly << \" \" << s.rx << \" \" << s.ry << endl;\n\t\t\tif(lf[s.lx][s.ly] == '%' && rf[s.rx][s.ry] == '%') flag = true;\n\t\t\tdp[s.lx][s.ly][s.rx][s.ry] = true;\n\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\tint nlx = s.lx + dx[i],nly = s.ly + dy[i],nrx = s.rx + dx[i],nry = s.ry + dy[(i + 2) % 4];\n\t\t\t\tbool move = false;\n\t\t\t\tif(nlx >= 0 && nlx < h && nly >= 0 && nly < w && lf[nlx][nly] != '#') move = true;\n\t\t\t\telse{\n\t\t\t\t\tnlx = s.lx;\n\t\t\t\t\tnly = s.ly;\n\t\t\t\t}\n\t\t\t\tif(nrx >= 0 && nrx < h && nry >= 0 && nry < w && rf[nrx][nry] != '#') move = true;\n\t\t\t\telse{\n\t\t\t\t\tnrx = s.rx;\n\t\t\t\t\tnry = s.ry;\n\t\t\t\t}\n\t\t\t\tif((lf[nlx][nly] == '#') ^ (rf[nrx][nry] == '#')) continue;\n\t\t\t\tif(move && !dp[nlx][nly][nrx][nry]){\n\t\t\t\t\tque.push({nlx,nly,nrx,nry});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nstruct state { int ly, lx, ry, rx, t; };\n\nint W, H, SLY, SLX, SRY, SRX;\nchar S[2][50][50];\nbool visited[50][50][50][50];\nint dd[5] = { 0, 1, 0, -1, 0 };\n\nbool isin(int y, int x) {\n  return 0 <= y && y < H && 0 <= x && x < W;\n}\n\nint main(void) {\n  while(cin >> W >> H, W || H) {\n    REP(i, 0, H) {\n      cin >> S[0][i];\n      cin >> S[1][i];\n      REP(j, 0, W) if(S[0][i][j] == 'L') SLY = i, SLX = j;\n      REP(j, 0, W) if(S[1][i][j] == 'R') SRY = i, SRX = j;\n    }\n\n    REP(i, 0, 50) REP(j, 0, 50) REP(k, 0, 50) REP(l, 0, 50) visited[i][j][k][l] = false;\n\n    queue<state> q;\n    q.push((state) { SLY, SLX, SRY, SRX, 0 });\n\n    int ans = -1;\n    while(q.size()) {\n      state c = q.front();\n      q.pop();\n\n      if(visited[c.ly][c.lx][c.ry][c.rx]) continue;\n      visited[c.ly][c.lx][c.ry][c.rx] = true;\n\n      if((S[0][c.ly][c.lx] == '%') ^ (S[1][c.ry][c.rx] == '%')) continue;\n\n      if(S[0][c.ly][c.lx] == '%' && S[1][c.ry][c.rx] == '%') {\n        ans = c.t;\n        break;\n      }\n\n      REP(i, 0, 4) {\n        state n = (state) { c.ly + dd[i], c.lx + dd[i + 1], c.ry + dd[i], c.rx - dd[i + 1], c.t + 1 };\n        if(isin(n.ly, n.lx) && isin(n.ry, n.rx)) {\n          if(S[0][n.ly][n.lx] != '#' && S[1][n.ry][n.rx] != '#') {\n            q.push(n);\n          }\n          if(S[0][n.ly][n.lx] != '#' && S[1][n.ry][n.rx] == '#') {\n            q.push((state) { n.ly, n.lx, c.ry, c.rx, n.t });\n          }\n          if(S[0][n.ly][n.lx] == '#' && S[1][n.ry][n.rx] != '#') {\n            q.push((state) { c.ly, c.lx, n.ry, n.rx, n.t });\n          }\n        }\n      }\n    }\n\n    if(ans == -1) cout << \"No\" << endl;\n    else cout << \"Yes\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\nusing ll = long long;\nusing P = pair<int, int>;\nusing T = tuple<int, int, int, int>;\n\ntemplate <class T> inline T chmax(T &a, const T b) {return a = (a < b) ? b : a;}\ntemplate <class T> inline T chmin(T &a, const T b) {return a = (a > b) ? b : a;}\n\nconstexpr int MOD = 1e9 + 7;\nconstexpr int inf = 1e9;\nconstexpr long long INF = 1e18;\nconstexpr double pi = acos(-1);\nconstexpr double EPS = 1e-10;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nbool visited[50][50][50][50];\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(1){\n        int w, h; cin>>w>>h;\n        if(w == 0) break;\n\n        cin.ignore();\n        vector<string> s(h), t(h);\n        for(int i=0; i<h; i++){\n            string st;\n            getline(cin, st);\n        \n            string S = st.substr(0, w);\n            string T = st.substr(w + 1, w);\n            reverse(T.begin(), T.end());\n\n            s[i] = S, t[i] = T;\n        }\n\n        for(int i=0; i<50; i++){\n            for(int j=0; j<50; j++){\n                for(int k=0; k<50; k++){\n                    for(int l=0; l<50; l++) visited[i][j][k][l] = false;\n                }\n            }\n        }\n\n        P sl, sr;\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                if(s[i][j] == 'L'){\n                    sl = P(i, j);\n                    s[i][j] = '.';\n                }\n                if(t[i][j] == 'R'){\n                    sr = P(i, j);\n                    t[i][j] = '.';\n                }\n            }\n        }\n\n        // visited[ly][lx][ry][rx]\n        visited[sl.first][sl.second][sr.first][sr.second] = true;\n        queue<T> que;\n        que.emplace(sl.first, sl.second, sr.first, sr.second);\n\n        bool can_goal = false;\n        while(que.size()){\n            int cly, clx, cry, crx;\n            tie(cly, clx, cry, crx) = que.front(); que.pop();\n\n            if(s[cly][clx] == '%' && t[cry][crx] == '%'){\n                cout << \"Yes\" << endl;\n                can_goal = true;\n                break;\n            }\n\n            for(int i=0; i<4; i++){\n                int nly = cly + dy[i], nlx = clx + dx[i], nry = cry + dy[i], nrx = crx + dx[i];\n\n                bool L_can_move = false;\n                if(0 <= nly && nly < h && 0 <= nlx && nlx < w){\n                    if(s[nly][nlx] != '#'){\n                        L_can_move = true;\n                    }\n                }\n\n                bool R_can_move = false;\n                if(0 <= nry && nry < h && 0 <= nrx && nrx < w){\n                    if(t[nry][nrx] != '#'){\n                        R_can_move = true;\n                    }\n                }\n\n                if(L_can_move && !R_can_move){\n                    if(!visited[nly][nlx][cry][crx]){\n                        if(s[nly][nlx] == '%') continue;\n                        visited[nly][nlx][cry][crx] = true;\n                        que.emplace(nly, nlx, cry, crx);\n                    }\n                }\n                else if(!L_can_move && R_can_move){\n                    if(!visited[cly][clx][nry][nrx]){\n                        if(t[nry][nrx] == '%') continue;\n                        visited[cly][clx][nry][nrx] = true;\n                        que.emplace(cly, clx, nry, nrx);\n                    }\n                }\n                else if(L_can_move && R_can_move){\n                    if(!visited[nly][nlx][nry][nrx]){\n                        if(s[nly][nlx] == '%' && t[nry][nrx] != '%') continue;\n                        if(s[nly][nlx] != '%' && t[nry][nrx] == '%') continue;\n                        visited[nly][nlx][nry][nrx] = true;\n                        que.emplace(nly, nlx, nry, nrx);\n                    }\n                }\n            }\n        }\n\n        if(!can_goal) cout << \"No\" << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <set>\n#include <queue>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\tint h, w, i, j, a, b, c, d, dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\n\tchar rf[50][51], lf[50][51];\n\tset<pair<P,P> > s; \n\tP rs, ls, rg, lg;\n\tqueue<P> r, l;\n\twhile(1){\n\t\tscanf(\"%d%d%*c\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tlf[i][j] = getchar();\n\t\t\t\tif(lf[i][j] == 'L'){\n\t\t\t\t\tls = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(lf[i][j] == '%'){\n\t\t\t\t\tlg = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 空白読み飛ばし\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\trf[i][j] = getchar();\n\t\t\t\tif(rf[i][j] == 'R'){\n\t\t\t\t\trs = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(rf[i][j] == '%'){\n\t\t\t\t\trg = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 改行文字読み飛ばし\n\t\t}\n\t\tr.push(rs), l.push(ls);\n\t\twhile(r.size()){\n\t\t\ta = l.front().first, b = l.front().second, c = r.front().first, d = r.front().second;\n\t\t\tl.pop(), r.pop();\n\t\t\ts.insert(pair<P,P>(P(a,b),P(c,d)));\n\t\t\tif(a == lg.first && b == lg.second && c == rg.first && d == rg.second)\n\t\t\t\tbreak;\n\t\t\tif(a == lg.first && b == lg.second || c == rg.first && d == rg.second)\n\t\t\t\tcontinue;\n\t\t\tfor(i = 0;i < 4;i++){\n\t\t\t\tif(a + dy[i] >= 0 && a + dy[i] < h && b + dx[i] >= 0 && b + dx[i] < w && lf[a + dy[i]][b + dx[i]] == '.' && c + dy[i] >= 0 && c + dy[i] < h && d - dx[i] >= 0 && d - dx[i] < w && rf[c + dy[i]][d - dx[i]] == '.' && s.find(pair<P,P>(P(a + dy[i],b + dx[i]),P(c + dy[i],d - dx[i]))) == s.end()) // 両方とも動くとき\n\t\t\t\t\tl.push(P(a + dy[i],b + dx[i])), r.push(P(c + dy[i],d - dx[i]));\n\t\t\t\telse if(a + dy[i] >= 0 && a + dy[i] < h && b + dx[i] >= 0 && b + dx[i] < w && lf[a + dy[i]][b + dx[i]] == '#' && c + dy[i] >= 0 && c + dy[i] < h && d - dx[i] >= 0 && d - dx[i] < w && rf[c + dy[i]][d - dx[i]] == '.' && s.find(pair<P,P>(P(a,b),P(c + dy[i],d - dx[i]))) == s.end()) // Rinだけ動く\n\t\t\t\t\tl.push(P(a,b)), r.push(P(c + dy[i],d - dx[i]));\n\t\t\t\telse if(a + dy[i] >= 0 && a + dy[i] < h && b + dx[i] >= 0 && b + dx[i] < w && lf[a + dy[i]][b + dx[i]] == '.' && c + dy[i] >= 0 && c + dy[i] < h && d - dx[i] >= 0 && d - dx[i] < w && rf[c + dy[i]][d - dx[i]] == '#' && s.find(pair<P,P>(P(a + dy[i],b + dx[i]),P(c,d))) == s.end()) // Lenだけ動く\n\t\t\t\t\tl.push(P(a + dy[i],b + dx[i])), r.push(P(c,d));\n\t\t\t}\n\t\t}\n\t\twhile(r.size())\n\t\t\tr.pop(),l.pop();\n\t\tif(s.find(pair<P,P>(P(lg.first,lg.second),P(rg.first,rg.second))) != s.end())\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t\ts.erase(s.begin(),s.end());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nbool dp[51][110][51][110];\nint main(){\n\tint n,m;\n\tint dx[]={1,0,-1,0};\n\tint dy[]={0,1,0,-1};\n\twhile(cin>>m>>n,n+m){\n\t\tvector<string>in(n);\n\t\tgetline(cin,in[0]);\n\t\trep(i,n)getline(cin,in[i]);\n\t\tm=in[0].size();\n\t\trep(i,n)rep(j,m)if(in[i][j]==' ')in[i][j]='#';\n\t\tpair<pii,pii>w;\n\t\trep(i,n)rep(j,m)if(in[i][j]=='L')\n\t\t\tw.first=pii(i,j);\n\t\telse if(in[i][j]=='R')\n\t\t\tw.second=pii(i,j);\n\t\tqueue<pair<pii,pii> >q;\n\t\tq.push(w);\n\t\trep(i,51)rep(j,110)rep(k,51)rep(l,110)dp[i][j][k][l]=false;\n\t\tdp[w.first.first][w.first.second][w.second.first][w.second.second]=true;\n\t\twhile(!q.empty()){\n\t\t\tpair<pii,pii>r=q.front();\n\t\t\tq.pop();\n\t\t\tpii a=r.first,b=r.second;\n\t\t\trep(i,4){\n\t\t\t\tpii na=pii(a.first+dx[i],a.second+dy[i]);\n\t\t\t\tpii nb=pii(b.first+dx[i],b.second-dy[i]);\n\t\t\t\tif(na.first<0||na.second<0||na.first>=n||na.second>=m||in[na.first][na.second]=='#')\n\t\t\t\t\tna.first-=dx[i],na.second-=dy[i];\n\t\t\t\tif(nb.first<0||nb.second<0||nb.first>=n||nb.second>=m||in[nb.first][nb.second]=='#')\n\t\t\t\t\tnb.first-=dx[i],nb.second+=dy[i];\n\t\t\t\tif(in[na.first][na.second]=='%'&&in[nb.first][nb.second]=='%'){\n\t\t\t\t\tcout<<\"Yes\"<<endl;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tif(in[na.first][na.second]=='%')continue;\n\t\t\t\tif(in[nb.first][nb.second]=='%')continue;\n\t\t\t\tif(dp[na.first][na.second][nb.first][nb.second]==0){\n\t\t\t\t\tdp[na.first][na.second][nb.first][nb.second]=true;\n\t\t\t\t\tq.push(pair<pii,pii>(na,nb));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<\"No\"<<endl;\n\t\tend:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<cmath>\n#include<utility>\n#include<functional>\n#include<map>\n#include<set>\n#include<cctype>\n\n\n#define FOR(i, a, b) for( int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for( int i=(a);i>=(b);i--)\n#define LFOR(i, a, b) for( long long int i=(a);i<=(b);i++)\n#define LRFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LLINF 1000000000000000000 //9000000000000000000\n#define PI 3.14159265358979\n#define MAXI 7500000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\n\nint dy[4] = { 0,0,1,-1 };\nint dx[4] = { 1,-1,0,0 };\n\n//int dp[50][50][50][50] = {};//ly,lx,ry,rx\n\n\nint main(void) {\n\t\n\twhile (1) {\n\n\t\tstruct Pos{\n\t\tpublic:\n\t\t\tint leftx;\n\t\t\tint lefty;\n\t\t\tint rightx;\n\t\t\tint righty;\n\t\t};\n\n\t\tint w, h;\n\t\tint lx = -1, ly = -1, rx = -1, ry = -1;\n\t\tint lgx = -1, lgy = -1, rgx = -1, rgy = -1;\n\n\t\tvector< vector< vector< vector<int> > > > dp(50, vector< vector< vector<int > > >(50, vector< vector<int> >(50, vector<int>(50, 0))));\n\t\t\n\n\t\tqueue< Pos > que;\n\t\tPos now;\n\n\t\tcin >> w >> h;\n\n\t\tif (w == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tvector<string> left(h), right(h);\n\n\t\tFOR(i, 0, h-1) {\n\t\t\tcin >> left[i] >> right[i];\n\t\t}\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (left[i][j] == 'L') {\n\t\t\t\t\tlx = j;\n\t\t\t\t\tly = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (right[i][j] == 'R') {\n\t\t\t\t\trx = j;\n\t\t\t\t\try = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (left[i][j] == '%') {\n\t\t\t\t\tlgx = j;\n\t\t\t\t\tlgy = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lgx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (right[i][j] == '%') {\n\t\t\t\t\trgx = j;\n\t\t\t\t\trgy = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rgx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdp[ly][lx][ry][rx] = 1;\n\n\t\tnow.lefty = ly;\n\t\tnow.leftx = lx;\n\t\tnow.righty = ry;\n\t\tnow.rightx = rx;\n\t\t\n\t\tque.push(now);\n\n\n\t\t/*while (!que.empty()) {\n\t\t\tnow = que.front();\n\t\t\t\n\t\t\tque.pop();\n\t\t\tly = now.lefty;\n\t\t\tlx = now.leftx;\n\t\t\try = now.righty;\n\t\t\trx = now.rightx;\n\t\t\t//cout << ly << \" \" << lx << \" \" << ry << \" \" << rx << endl;\n\n\t\t\tFOR(i, 0, 3) {\n\t\t\t\t\n\t\t\t\tif (ly + dy[i] >= 0 && lx - dx[i] >= 0 && ry + dy[i] <= h - 1 && rx + dx[i] <= w - 1 && ly + dy[i] <= h - 1 && lx - dx[i] <= w - 1 && ry + dy[i] >= 0 && rx + dx[i] >= 0) {\n\t\t\t\t\tif (dp[ly + dy[i]][lx - dx[i]][ry + dy[i]][rx + dx[i]] != 1) {\n\t\t\t\t\t\tif (left[ly + dy[i]][lx - dx[i]] == '#') {\n\t\t\t\t\t\t\tif (right[ry + dy[i]][rx + dx[i]] == '#') {\n\t\t\t\t\t\t\t\t//no\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdp[ly][lx][ry + dy[i]][rx + dx[i]] = 1;\n\t\t\t\t\t\t\t\tnow.lefty = ly;\n\t\t\t\t\t\t\t\tnow.leftx = lx;\n\t\t\t\t\t\t\t\tnow.righty = ry + dy[i];\n\t\t\t\t\t\t\t\tnow.rightx = rx + dx[i];\n\t\t\t\t\t\t\t\tque.push(now);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (right[ry + dy[i]][rx + dx[i]] == '#') {\n\t\t\t\t\t\t\t\tdp[ly + dy[i]][lx - dx[i]][ry][rx] = 1;\n\t\t\t\t\t\t\t\tnow.lefty = ly + dy[i];\n\t\t\t\t\t\t\t\tnow.leftx = lx - dx[i];\n\t\t\t\t\t\t\t\tnow.righty = ry;\n\t\t\t\t\t\t\t\tnow.rightx = rx;\n\t\t\t\t\t\t\t\tque.push(now);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdp[ly + dy[i]][lx - dx[i]][ry + dy[i]][rx + dx[i]] = 1;\n\t\t\t\t\t\t\t\tnow.lefty = ly + dy[i];\n\t\t\t\t\t\t\t\tnow.leftx = lx - dx[i];\n\t\t\t\t\t\t\t\tnow.righty = ry + dy[i];\n\t\t\t\t\t\t\t\tnow.rightx = rx + dx[i];\n\t\t\t\t\t\t\t\tque.push(now);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\n\t\tif (dp[lgy][lgx][rgy][rgx] == 1) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t\t\n\n\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MAX 51\n#include<cstring>\nusing namespace std;\n\nbool f=false,visited[MAX][MAX][MAX][MAX];\nint w,h;\nchar L[MAX][MAX],R[MAX][MAX];\n\nint ldy[]={0,-1,0,1};\nint ldx[]={1,0,-1,0};\nint rdy[]={0,-1,0,1};\nint rdx[]={-1,0,1,0};\n\nvoid dfs(int ly,int lx, int ry, int rx){\n  visited[ly][lx][ry][rx] = true;\n\n  int nly,nlx,nry,nrx;\n  for(int i=0; i<4; i++){\n    nly = ly + ldy[i];\n    nlx = lx + ldx[i];\n    nry = ry + rdy[i];\n    nrx = rx + rdx[i];\n\n    if(!visited[nly][nlx][nry][nrx] &&\n       0<=nly && nly<h && 0<=nlx && nlx<w && 0<=nry && nry<h && 0<=nrx && nrx<w){\n      if(L[nly][nlx]=='%' && R[nry][nrx]=='%'){\n\tf = true;\n\treturn ;\n      }\n      //if(L[nly][nlx]=='%' || R[nry][nrx]=='%') visited[nly][nlx][nry][nrx] = true;\n      if(L[nly][nlx]=='#' && R[nry][nrx]=='.') dfs(ly,lx,nry,nrx);\n      if(L[nly][nlx]=='.' && R[nry][nrx]=='#') dfs(nly,nlx,ry,rx);\n      if(L[nly][nlx]=='.' && R[nry][nrx]=='.')  dfs(nly,nlx,nry,nrx);\n    }\n    if((nlx<0 || w<=nlx) && (0<=nrx && nrx<w) && R[nry][nrx]=='.')    dfs(ly,lx,nry,nrx);\n    if((nrx<0 || w<=nrx) && (0<=nlx && nlx<w) && L[nly][nlx]=='.')    dfs(nly,nlx,ry,rx);\n    if((nry<0 || h<=nry) && (0<=nly && nly<h) && L[nly][nlx]=='.')    dfs(nly,nlx,ry,rx);\n    if((nly<0 || h<=nly) && (0<=nry && nry<h) && R[nry][nrx]=='.')    dfs(ly,lx,nry,nrx);\n      \n  }\n}\n\n\nint main(){\n\n  while(cin >> w >> h ,w|h){\n    cin.ignore();\n\n    for(int i=0; i<h; i++){\n      string str;\n      getline(cin,str);\n      bool first=true;\n      int cnt = 0;\n      for(int j=0; j<str.size(); j++){\n\tif(str[j]==' '){\n\t  first = false;\n\t  continue;\n\t}\n\tif(first) L[i][j] = str[j];\n\telse R[i][cnt++] = str[j];\n      }\n    }\n    int sly,slx,sry,srx;\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tif(L[i][j]=='L'){\n\t  sly = i;\n\t  slx = j;\n\t}\n\tif(R[i][j]=='R'){\n\t  sry = i;\n\t  srx = j;\n\t}\n      }\n    }\n\n    f = false;\n    memset(visited,false,sizeof(visited));\n    // visited[sly][slx][sry][srx]=true;\n    dfs(sly,slx,sry,srx);\n    if(f) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\nconst int size = 51;\nint n, m;\nbool OL[size][size];\nbool OR[size][size];\n\ntypedef vector <string> VS;\n\nvoid init() {\n    for ( int i = 0; i < size; i++ ) {\n        for ( int j = 0; j < size; j++ ) {\n            OL[i][j] = false;\n            OR[i][j] = false;\n        }\n    }\n}\n\n/*\n. : ©RÉÚ®Å«éZ\n# : ÇÌ éZiiüÅ«È¢j\n% : ÚIn\nR : Rin ÌúÊu\nL : Len ÌúÊu\n*/\n\ntypedef pair <int, int> PII;\ntypedef pair <PII, PII> Node;\ntypedef queue <Node> Queue;\n\nint srL, scL, srR, scR;\nint grL, gcL, grR, gcR;\nconst int dr[4] = { 0, 0, 1, -1 };\nconst int dc[4] = { 1, -1, 0, 0 };\nbool used[size][size][size][size];\n\nbool bad( int r, int c ) {\n    return r < 0 || r >= m || c < 0 || c >= n;\n}\n\nbool solve() {\n    Queue Q;\n    Node start( PII( srL, scL ), PII( srR, scR ) );\n    Q.push( start );\n\n    for ( int i = 0; i < m; i++ ) {\n        for ( int j = 0; j < n; j++ ) {\n            for ( int k = 0; k < m; k++ ) {\n                for ( int l = 0; l < n; l++ ) {\n                    used[i][j][k][l] = false;\n                }\n            }\n        }\n    }\n\n    while ( !Q.empty() ) {\n        Node node = Q.front();\n        Q.pop();\n\n        int rL = node.first.first;\n        int cL = node.first.second;\n        int rR = node.second.first;\n        int cR = node.second.second;\n\n        if ( rL == grL && cL == gcL && rR == grR && cR == gcR ) {\n            return true;\n        }\n\n        for ( int k = 0; k < 4; k++ ) {\n            int nrL = rL + dr[k];\n            int ncL = cL + dc[k];\n            int nrR = rR + dr[k];\n            int ncR = cR - dc[k];\n\n            if ( bad( nrL, ncL ) || OL[nrL][ncL] ) {\n                nrL = rL;\n                ncL = cL;\n            }\n            if ( bad( nrR, ncR ) || OR[nrR][ncR] ) {\n                nrR = rR;\n                ncR = cR;\n            }\n\n            if ( used[nrL][ncL][nrR][ncR] ) continue;\n            used[nrL][ncL][nrR][ncR] = true;\n            Node next_node( PII( nrL, ncL ), PII( nrR, ncR ) );\n            Q.push( next_node );\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n\n        init();\n\n        VS inputL(m), inputR(m);\n        for ( int i = 0; i < m; i++ ) {\n            cin >> inputL[i] >> inputR[i];\n        }\n\n        for ( int i = 0; i < m; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                if ( inputL[i][j] == '#' ) OL[i][j] = true;\n                if ( inputR[i][j] == '#' ) OR[i][j] = true;\n            }\n        }\n\n        for ( int i = 0; i < m; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                if ( inputL[i][j] == 'L' ) {\n                    srL = i;\n                    scL = j;\n                }\n                if ( inputR[i][j] == 'R' ) {\n                    srR = i;\n                    scR = j;\n                }\n                if ( inputL[i][j] == '%' ) {\n                    grL = i;\n                    gcL = j;\n                }\n                if ( inputR[i][j] == '%' ) {\n                    grR = i;\n                    gcR = j;\n                }\n            }\n        }\n\n        cout << ( solve() ? \"Yes\" : \"No\" ) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"tune=native\")\n#pragma GCC target (\"avx\")\n\n#include <bits/stdc++.h>\n\n// 汎用マクロ\n#define ALL_OF(x) (x).begin(), (x).end()\n#define REP(i,n) for (long long i=0, i##_len=(n); i<i##_len; i++)\n#define RANGE(i,is,ie) for (long long i=(is), i##_end=(ie); i<=i##_end; i++)\n#define DSRNG(i,is,ie) for (long long i=(is), i##_end=(ie); i>=i##_end; i--)\n#define UNIQUE(v) { sort((v).begin(), (v).end()); (v).erase(unique((v).begin(), (v).end()), (v).end()); }\ntemplate<class T> bool chmax(T &a, const T &b) {if (a < b) {a = b; return 1;} return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) {if (a > b) {a = b; return 1;} return 0; }\n#define INF 0x7FFFFFFF\n#define LINF 0x7FFFFFFFFFFFFFFFLL\n#define Yes(q) (q ? \"Yes\" : \"No\")\n#define YES(q) (q ? \"YES\" : \"NO\")\n#define DUMP(q) cerr << \"[DEBUG] \" #q \": \" << (q) << \" at \" __FILE__ \":\" << __LINE__ << endl\n#define DUMPALL(q) cerr << \"[DEBUG] \" #q \": [\"; REP(dumpall_i, (q).size()) { cerr << q[dumpall_i] << (dumpall_i == (q).size() - 1 ? \"\" : \", \"); } cerr << \"] at \" __FILE__ \":\" << __LINE__ << endl\n\n// gcc拡張マクロ\n#define gcd __gcd\n#define popcount __builtin_popcount\n#define popcountll __builtin_popcountll\n\n// エイリアス\nusing  ll = long long;\nusing ull = unsigned long long;\nusing  ld = long double;\nusing namespace std;\n\n// モジュール\n\n\n// 処理内容\nint main() {\n    \n    ll w, h;\n    while (cin >> w >> h, w && h) {\n\n        vector<string> rl(h), rr(h);\n        REP(i, h) cin >> rl[i] >> rr[i];\n        ll lsy, lsx, rsy, rsx;\n        ll lgy, lgx, rgy, rgx;\n        REP(i, h) REP(j, w) {\n            if (rl[i][j] == '%') {\n                lgy = i;\n                lgx = j;\n            } else if (rl[i][j] == 'L') {\n                lsy = i;\n                lsx = j;\n            }\n            if (rr[i][j] == '%') {\n                rgy = i;\n                rgx = j;\n            } else if (rr[i][j] == 'R') {\n                rsy = i;\n                rsx = j;\n            }\n        }\n\n        // {ly, lx, ry, rx}\n        deque<tuple<ll,ll,ll,ll>> q;\n        vector<vector<vector<vector<bool>>>> visited(h, vector<vector<vector<bool>>>(w, vector<vector<bool>>(h, vector<bool>(w, false))));\n        q.emplace_back(lsy, lsx, rsy, rsx);\n        visited[lsy][lsx][rsy][rsx] = true;\n        while (!q.empty()) {\n\n            ll ly = get<0>(q.front());\n            ll lx = get<1>(q.front());\n            ll ry = get<2>(q.front());\n            ll rx = get<3>(q.front());\n            q.pop_front();\n\n            // Lin and Ren go upward\n            if (ly > 0 && ry > 0) {\n                ll ly2 = rl[ly - 1][lx] != '#' ? ly - 1 : ly;\n                ll lx2 = lx;\n                ll ry2 = rr[ry - 1][lx] != '#' ? ry - 1 : ry;\n                ll rx2 = rx;\n                bool is_locked = (ly2 == lgy && lx2 == lgx) != (ry2 == rgy && rx2 == rgx);\n                bool is_blocked = rl[ly2][lx2] == '#' || rr[ry2][rx2] == '#';\n                if (!visited[ly2][lx2][ry2][rx2] && !is_locked && !is_blocked) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n            }\n\n            // Lin and Ren go downward\n            if (ly < h-1 && ry < h-1) {\n                ll ly2 = rl[ly + 1][lx] != '#' ? ly + 1 : ly;\n                ll lx2 = lx;\n                ll ry2 = rr[ry + 1][lx] != '#' ? ry + 1 : ry;\n                ll rx2 = rx;\n                bool is_locked = (ly2 == lgy && lx2 == lgx) != (ry2 == rgy && rx2 == rgx);\n                bool is_blocked = rl[ly2][lx2] == '#' || rr[ry2][rx2] == '#';\n                if (!visited[ly2][lx2][ry2][rx2] && !is_locked && !is_blocked) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n            }\n\n            // Lin goes left and Ren goes right\n            if (lx > 0 && rx < w-1) {\n                ll ly2 = ly;\n                ll lx2 = rl[ly][lx - 1] != '#' ? lx - 1 : lx;\n                ll ry2 = ry;\n                ll rx2 = rr[ry][rx + 1] != '#' ? rx + 1 : rx;\n                bool is_locked = (ly2 == lgy && lx2 == lgx) != (ry2 == rgy && rx2 == rgx);\n                bool is_blocked = rl[ly2][lx2] == '#' || rr[ry2][rx2] == '#';\n                if (!visited[ly2][lx2][ry2][rx2] && !is_locked && !is_blocked) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n            }\n\n            // Lin goes right and Ren goes left\n            if (lx < w-1 && rx > 0) {\n                ll ly2 = ly;\n                ll lx2 = rl[ly][lx + 1] != '#' ? lx + 1 : lx;\n                ll ry2 = ry;\n                ll rx2 = rr[ry][rx - 1] != '#' ? rx - 1 : rx;\n                bool is_locked = (ly2 == lgy && lx2 == lgx) != (ry2 == rgy && rx2 == rgx);\n                bool is_blocked = rl[ly2][lx2] == '#' || rr[ry2][rx2] == '#';\n                if (!visited[ly2][lx2][ry2][rx2] && !is_locked && !is_blocked) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n            }\n\n        }\n\n        std::cout << Yes(visited[lgy][lgx][rgy][rgx]) << endl;\n\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst double EPS = 1e-9;\n\nint main(){\n    while(true){\n        int W,H;\n        cin >> W >> H;\n        if(W == 0 and H == 0) break;\n        vector<vector<string> > field(2,vector<string>(H+2));\n        field[0][0] = string(W+2,'#');\n        field[1][0] = string(W+2,'#');\n        field[0][H+1] = string(W+2,'#');\n        field[1][H+1] = string(W+2,'#');\n\n        for(int i=1;i<=H;i++){\n            for(int j=0;j<2;j++){\n                cin >> field[j][i];\n                field[j][i] = '#' + field[j][i] + '#';\n                if(j == 1) reverse(all(field[j][i]));\n            }\n        }\n//        for(int i=0;i<H+2;i++){\n//            cerr << field[0][i] << \" \" << field[1][i] << endl;\n//        }\n        pair<pii,pii> start;\n        pair<pii,pii> goal;\n        for(int i=0;i<2;i++){\n            for(int j=1;j<=H;j++){\n                for(int k=1;k<=W;k++){\n                    if(field[i][j][k] == 'L'){\n                        start.first = make_pair(j,k);\n                    }else if(field[i][j][k] == 'R'){\n                        start.second = make_pair(j,k);\n                    }\n                    if(field[i][j][k] == '%'){\n                        if(i == 0){\n                            goal.first = make_pair(j,k);\n                        }else{\n                            goal.second = make_pair(j,k);\n                        }\n                    }\n                }\n            }\n        }\n        stack<pair<pii,pii> > sta;\n        sta.push(start);\n        bool used[H+2][W+2][H+2][W+2];\n        for(int i=0;i<H+2;i++){\n            for(int j=0;j<W+2;j++){\n                for(int k=0;k<H+2;k++){\n                    for(int l=0;l<W+2;l++){\n                        used[i][j][k][l] = false;\n                    }\n                }\n            }\n        }\n        bool ok = false;\n        while(not sta.empty()){\n            pair<pii,pii> now = sta.top();\n            sta.pop();\n            if(used[now.first.first][now.first.second][now.second.first][now.second.second]){\n                continue;\n            }\n            used[now.first.first][now.first.second][now.second.first][now.second.second] = true;\n            if(now == goal){\n                ok = true;\n                break;\n            }\n            for(int i=0;i<4;i++){\n                pair<pii,pii> next = now;\n                next.first.first += dy[i];\n                next.first.second += dx[i];\n                next.second.first += dy[i];\n                next.second.second += dx[i];\n                if(field[0][next.first.first][next.first.second] == '#'){\n                    next.first = now.first;\n                }\n                if(field[1][next.second.first][next.second.second] == '#'){\n                    next.second = now.second;\n                }\n                sta.push(next);\n            }\n        }\n        if(ok){\n            cout << \"Yes\" << endl;\n        }else{\n            cout << \"No\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MAX 51\n#include<cstring>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool f=false,visited[MAX][MAX][MAX][MAX];\nint w,h;\nchar L[MAX][MAX],R[MAX][MAX];\n\nint ldy[]={0,-1,0,1};\nint ldx[]={1,0,-1,0};\nint rdy[]={0,-1,0,1};\nint rdx[]={-1,0,1,0};\n\nvoid dfs(int ly,int lx, int ry, int rx){\n  visited[ly][lx][ry][rx] = true;\n\n  int nly,nlx,nry,nrx;\n  for(int i=0; i<4; i++){\n    nly = ly + ldy[i];\n    nlx = lx + ldx[i];\n    nry = ry + rdy[i];\n    nrx = rx + rdx[i];\n\n    if(0<=nly && nly<h && 0<=nlx && nlx<w && 0<=nry && nry<h && 0<=nrx && nrx<w){\n      if(L[nly][nlx]=='%' && R[nry][nrx]=='%'){\n\tf = true;\n\treturn ;\n      }\n      //if(L[nly][nlx]=='%' || R[nry][nrx]=='%') visited[nly][nlx][nry][nrx] = true;\n      else if(L[nly][nlx]=='#' && R[nry][nrx]=='.' && !visited[ly][lx][nry][nrx]) dfs(ly,lx,nry,nrx);\n      else if(L[nly][nlx]=='.' && R[nry][nrx]=='#' && !visited[nly][nlx][ry][rx]) dfs(nly,nlx,ry,rx);\n      else if(L[nly][nlx]=='.' && R[nry][nrx]=='.' && !visited[nly][nlx][nry][nrx])  dfs(nly,nlx,nry,nrx);\n    }\n    else if((nlx<0 || w<=nlx) && (0<=nrx && nrx<w) && R[nry][nrx]=='.' && !visited[ly][lx][nry][nrx]) dfs(ly,lx,nry,nrx);\n    else if((nrx<0 || w<=nrx) && (0<=nlx && nlx<w) && L[nly][nlx]=='.' && !visited[nly][nlx][ry][rx]) dfs(nly,nlx,ry,rx);\n    else if((nry<0 || h<=nry) && (0<=nly && nly<h) && L[nly][nlx]=='.' && !visited[nly][nlx][ry][rx]) dfs(nly,nlx,ry,rx);\n    else if((nly<0 || h<=nly) && (0<=nry && nry<h) && R[nry][nrx]=='.' && !visited[ly][lx][nry][nrx]) dfs(ly,lx,nry,nrx);\n      \n  }\n  return;\n}\n\n\nint main(){\n\n  while(cin >> w >> h && w && h){\n    cin.ignore();\n\n    for(int i=0; i<h; i++){\n      string str;\n      getline(cin,str);\n      bool first=true;\n      int cnt = 0;\n      for(int j=0; j<str.size(); j++){\n\tif(str[j]==' '){\n\t  first = false;\n\t  continue;\n\t}\n\tif(first) L[i][j] = str[j];\n\telse R[i][cnt++] = str[j];\n      }\n    }\n    int sly,slx,sry,srx;\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tif(L[i][j]=='L'){\n\t  sly = i;\n\t  slx = j;\n\t}\n\tif(R[i][j]=='R'){\n\t  sry = i;\n\t  srx = j;\n\t}\n      }\n    }\n\n    f = false;\n    memset(visited,false,sizeof(visited));\n    // visited[sly][slx][sry][srx]=true;\n    dfs(sly,slx,sry,srx);\n    if(f) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define FOR(i,s,n) for(int i=s; i<n; i++)\n#define ALL(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nint w, h;\nbool wl[55][55], wr[55][55];\nbool memo[55][55][55][55];\nint gxl, gyl, gxr, gyr;\n\nstruct node {\n\tint xl, yl, xr, yr;\n\tnode(int lx, int ly, int rx, int ry) {\n\t\txl = lx;\n\t\tyl = ly;\n\t\txr = rx;\n\t\tyr = ry;\n\t}\n};\n/*\nbool dfs(int xl, int yl, int xr, int yr) {\n\tif( memo[xl][yl][xr][yr] ) {\n\t\treturn false;\n\t}\n//\tcout << \"dfs \" << xl << \" \" << yl << \" \" << xr << \" \" << yr << endl;\n\tmemo[xl][yl][xr][yr] = true;\n\tif(xl==gxl && yl==gyl && xr==gxr && yr==gyr) {\n\t\treturn true;\n\t}\n\tint dx[4] = {-1, 0, 1, 0};\n\tint dy[4] = {0, 1, 0, -1};\n\tbool f = false;\n\trep(i, 4) {\n\t\tint nxl = xl + dx[i];\n\t\tint nyl = yl + dy[i];\n\t\tint nxr = xr - dx[i];\n\t\tint nyr = yr + dy[i];\n\t\tbool nl = wl[nyl][nxl];\n\t\tbool nr = wr[nyr][nxr];\n\t\tif( !nl && !nr && !memo[nxl][nyl][nxr][nyr] ) {\n\t\t\tf |= dfs(nxl, nyl, nxr, nyr);\n\t\t}\n\t\telse if( !nl && nr && !memo[nxl][nyl][xr][yr] ) {\n\t\t\tf |= dfs(nxl, nyl, xr, yr);\n\t\t}\n\t\telse if( nl && !nr && !memo[xl][yl][nxr][nyr] ) {\n\t\t\tf |= dfs(xl, yl, nxr, nyr);\n\t\t}\n\t}\n\treturn f;\n}\n*/\nint main() {\n\twhile(cin >> w >> h, w) {\n\t\trep(i,55) rep(j,55) wl[i][j] = wr[i][j] = true;\n\t\trep(i,55) rep(j,55) rep(k,55) rep(l,55) memo[i][j][k][l]=false;\n\t\tint xl=1, yl=1, xr=1, yr=1;\n\t\trep(y, h) {\n\t\t\tstring sl, sr;\n\t\t\tcin >> sl >> sr;\n\t\t\trep(x, w) {\n\t\t\t\tif(sl[x] == 'L') {\n\t\t\t\t\txl = x+1;\n\t\t\t\t\tyl = y+1;\n\t\t\t\t\twl[y+1][x+1] = false;\n\t\t\t\t} else if(sl[x] == '%') {\n\t\t\t\t\tgxl = x+1;\n\t\t\t\t\tgyl = y+1;\n\t\t\t\t\twl[y+1][x+1] = false;\n\t\t\t\t} else {\n\t\t\t\t\twl[y+1][x+1] = (sl[x]=='#');\n\t\t\t\t}\n\t\t\t\tif(sr[x] == 'R') {\n\t\t\t\t\txr = x+1;\n\t\t\t\t\tyr = y+1;\n\t\t\t\t\twr[y+1][x+1] = false;\n\t\t\t\t} else if(sr[x] == '%') {\n\t\t\t\t\tgxr = x+1;\n\t\t\t\t\tgyr = y+1;\n\t\t\t\t\twr[y+1][x+1] = false;\n\t\t\t\t} else {\n\t\t\t\t\twr[y+1][x+1] = (sr[x]=='#');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tqueue<node> que;\n\t\tque.push( node(xl, yl, xr, yr) );\n\t\tbool ok = false;\n\t\twhile(!que.empty()) {\n\t\t\tnode nd = que.front();\n\t\t\tque.pop();\n\t\t\tif( memo[nd.xl][nd.yl][nd.xr][nd.yr] ) {\n\t\t\t\tcontinue;\n\t\t\t}\n//\t\t\tcout << \"lp \" << nd.xl << \" \" << nd.yl << \" \" << nd.xr << \" \" << nd.yr << endl;\n\t\t\tmemo[nd.xl][nd.yl][nd.xr][nd.yr] = true;\n\t\t\tif(nd.xl==gxl && nd.yl==gyl && nd.xr==gxr && nd.yr==gyr) {\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint dx[4] = {-1, 0, 1, 0};\n\t\t\tint dy[4] = {0, 1, 0, -1};\n\t\t\trep(i, 4) {\n\t\t\t\tint nxl = nd.xl + dx[i];\n\t\t\t\tint nyl = nd.yl + dy[i];\n\t\t\t\tint nxr = nd.xr - dx[i];\n\t\t\t\tint nyr = nd.yr + dy[i];\n\t\t\t\tbool nl = wl[nyl][nxl];\n\t\t\t\tbool nr = wr[nyr][nxr];\n\t\t\t\tif( !nl && !nr && !memo[nxl][nyl][nxr][nyr] ) {\n\t\t\t\t\tque.push( node(nxl, nyl, nxr, nyr) );\n\t\t\t\t}\n\t\t\t\telse if( !nl && nr && !memo[nxl][nyl][nd.xr][nd.yr] ) {\n\t\t\t\t\tque.push( node(nxl, nyl, nd.xr, nd.yr) );\n\t\t\t\t}\n\t\t\t\telse if( nl && !nr && !memo[nd.xl][nd.yl][nxr][nyr] ) {\n\t\t\t\t\tque.push( node(nd.xl, nd.yl, nxr, nyr) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( ok ) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t} else {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint w, h;\nchar l[52][52], r[52][52];\nint ldx[4] = {1, 0, -1, 0};\nint ldy[4] = {0, 1, 0, -1};\nint rdx[4] = {1, 0, -1, 0};\nint rdy[4] = {0, -1, 0, 1};\nint lsx, lsy, rsx, rsy, lgx, lgy, rgx, rgy;\nbool lischecked[52][52], rischecked[52][52];\n\nbool solve(int lx, int ly, int rx, int ry){\n    if(lx == lgx && ly == lgy && rx == rgx && ry == rgy) return true;\n    if((lx == lgx && ly == lgy) || (rx == rgx && ry == rgy)) return false;\n    for(int i = 0; i < 4; i++){\n        int nlx = lx + ldx[i], nly = ly + ldy[i];\n        int nrx = rx + rdx[i], nry = ry + rdy[i];\n        if((nlx < 0 || nly < 0 || nlx >= h || nly >= w) && (nrx < 0 || nry < 0 || nrx >= h || nry >= w)) continue;\n        if((l[nlx][nly] == '#' && r[nrx][nry] == '#') || (lischecked[nlx][nly] && rischecked[nrx][nry])) continue;\n        if(nlx < 0 || nlx >= h || nly < 0 || nly >= w || l[nlx][nly] == '#'){\n            nlx = lx;\n            nly = ly;\n        }\n        if(nrx < 0 || nrx >= h || nry < 0 || nry >= w || r[nrx][nry] == '#'){\n            nrx = rx;\n            nry = ry;\n        }\n        lischecked[nlx][nly] = true;\n        rischecked[nrx][nry] = true;\n        if(solve(nlx, nly, nrx, nry)) return true;\n        lischecked[nlx][nly] = false;\n        rischecked[nrx][nry] = false;\n    }\n    return false;\n}\n\nint main()\n{\n    while(1){\n        cin >> w >> h;\n        if(w == 0 && h == 0) break;\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin >> l[i][j];\n            }\n            for(int j = 0; j < w; j++){\n                cin >> r[i][j];\n            }\n        }\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                lischecked[i][j] = false;\n                rischecked[i][j] = false;\n                if(l[i][j] == 'L'){\n                    lsx = i;\n                    lsy = j;\n                }\n                if(l[i][j] == '%'){\n                    lgx = i;\n                    lgy = j;\n                }\n                if(r[i][j] == 'R'){\n                    rsx = i;\n                    rsy = j;\n                }\n                if(r[i][j] == '%'){\n                    rgx = i;\n                    rgy = j;\n                }\n            }\n        }\n        lischecked[lsx][lsy] = true;\n        rischecked[rsx][rsy] = true;\n        if(solve(lsx, lsy, rsx, rsy)) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <sstream>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cstring>\n \nusing namespace std;\n\nconst int dx[]={0,1,0,-1};\nconst int dy[]={-1,0,1,0};\nchar vis[50][50][50][50];\n/*\nbool solve(int xl,int yl,int xr, int yr)\n{\n\n\n\tif(vis[yl][xl][yr][xr]==1) return false;\n\t\t\n\tif(L[yl][xl]=='%' && R[yr][xr]=='%') return true;\n\tif(L[yl][xl]=='%' && R[yr][xr]!='%') return false;\n\tif(L[yl][xl]!='%' && R[yr][xr]=='%') return false;\n\t\n\n\t\n\tvis[yl][xl][yr][xr]=1;\n\t\n\tfor(int i=0;i<4;i++){\n\t\tint nxl=xl+dx[i], nyl=yl+dy[i];\n\t\tint nxr=xr-dx[i], nyr=yr+dy[i];\n\n\t\tif(nxl<0 || w<=nxl || nyl<0 || h<=nyl ||\n\t\t   nxr<0 || w<=nxr || nyr<0 || h<=nyr ) continue;\n\t\t\n\t\tif(L[nyl][nxl]=='#'){\n\t\t\tnxl-=dx[i]; nyl-=dy[i];\n\t\t}\n\t\tif(R[nyr][nxr]=='#'){\n\t\t\tnxr+=dx[i]; nyr-=dy[i];\n\t\t}\n\n\t\tif(nxl<0 || w<=nxl || nyl<0 || h<=nyl ||\n\t\t   nxr<0 || w<=nxr || nyr<0 || h<=nyr ) continue;\n\t\t\n\t\tif(solve(nxl,nyl,nxr,nyr)) return true;\n\t\t\n\t}\n\t\n\treturn false;\n\n}\n*/\nclass Pos{\npublic:\n\tpair<int,int> posL,posR;\n\tPos(int xl,int yl,int xr,int yr){\n\t\tposL=make_pair(xl,yl);\n\t\tposR=make_pair(xr,yr);\n\t}\n};\n\n\nint main()\n{\n\n\tint w,h;\n\twhile(cin>>w>>h,w){\t\t\n\n\n\t\tmemset(vis,-1,sizeof(char)*50*50*50*50);\n\n\n\t\tstring L[100],R[100];\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>L[i]>>R[i];\n\t\t}\n\t\t\n\t\tint sxl,syl,sxr,syr;\t\t\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(L[i][j]=='L'){sxl=j,syl=i;}\n\t\t\t\tif(R[i][j]=='R'){sxr=j,syr=i;}\n\t\t\t}\n\t\t}\n\n\t\tbool ok=false;\n\t\tqueue<Pos> q;\n\t\tq.push(Pos(sxl,syl,sxr,syr));\n\t\twhile(!q.empty()){\n\t\t\tPos pos=q.front(); q.pop();\n\t\t\tint xl=pos.posL.first, yl=pos.posL.second;\n\t\t\tint xr=pos.posR.first, yr=pos.posR.second;\n\n\t\t\tif(L[yl][xl]=='%' && R[yr][xr]=='%') {ok=true; break;}\n\t\t\telse if(L[yl][xl]=='%' || R[yr][xr]=='%') continue;\n\t\t\t\n\t\t\tif(vis[xl][yl][xr][yr]==1) continue;\n\t\t\t\n\t\t\tvis[xl][yl][xr][yr]=1;\n\t\t\t\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nxl=xl, nyl=yl;\n\t\t\t\tint nxr=xr, nyr=yr;\n\t\t\n\t\t\t\tif(0<=nxl+dx[i] && nxl+dx[i]<w && 0<=nyl+dy[i] && nyl+dy[i]<h && L[nyl+dy[i]][nxl+dx[i]]!='#'){nxl+=dx[i]; nyl+=dy[i];}\n\t\t\t\tif(0<=nxr-dx[i] && nxr-dx[i]<w && 0<=nyr+dy[i] && nyr+dy[i]<h && R[nyr+dy[i]][nxr-dx[i]]!='#'){nxr-=dx[i]; nyr+=dy[i];}\n\n\t\t\t\t\n\t\t\t\tq.push(Pos(nxl,nyl,nxr,nyr));\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\tif(ok) cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n\t\t\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int OfLen = 0;\nconst int OfRin = 1;\n\nstruct Point {\n  int x, y;\n  Point(){}\n  Point(int x, int y):x(x), y(y){}\n};\n\nstruct TPoint {\n  Point Len, Rin;\n  TPoint(){}\n  TPoint(Point Len, Point Rin):Len(Len), Rin(Rin){}\n};\n\nint W, H;\nstring room[2][55];\n\nbool isInRoom(int whose, Point p)\n{\n  if(0 <= p.x && p.x < W && 0 <= p.y && p.y < H && room[whose][p.y][p.x] != '#') return true;\n  return false;\n}\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nbool used[55][55][55][55];\n\nbool isOpenGate(TPoint twinspos)\n{\n  memset(used, false, sizeof(used));\n\n  queue<TPoint> que;\n  que.push(twinspos);  \n\n  while(!que.empty()) {\n    TPoint tp = que.front(); que.pop();\n    Point len = tp.Len, rin = tp.Rin;\n\n    if(used[len.x][len.y][rin.x][rin.y]) continue;\n\n    used[len.x][len.y][rin.x][rin.y] = true;\n\n    if(room[OfLen][len.y][len.x] == '%' && room[OfRin][rin.y][rin.x] == '%') return true;\n    if(room[OfLen][len.y][len.x] == '%' || room[OfRin][rin.y][rin.x] == '%') continue;\n\n    for(int i = 0; i < 4; i++) {\n      Point nextLen = len, nextRin = rin;\n\n      Point IfLenMove = Point(len.x + dx[i], len.y + dy[i]);\n      if(isInRoom(OfLen, IfLenMove)) nextLen = IfLenMove;\n      \n      Point IfRinMove = Point(rin.x - dx[i], rin.y + dy[i]);\n      if(isInRoom(OfRin, IfRinMove)) nextRin = IfRinMove;\n\n      if(used[nextLen.x][nextLen.y][nextRin.x][nextRin.y]) continue;      \n\n      que.push(TPoint(nextLen, nextRin));\n    }\n  }\n  return false;\n}\n  \n\nint main()\n{\n  while(cin >> W >> H, W || H) {\n    TPoint twinspos;\n    for(int i = 0; i < H; i++) {\n      cin >> room[OfLen][i] >> room[OfRin][i];\n      for(int j = 0; j < W; j++) {\n\tif(room[OfLen][i][j] == 'L') twinspos.Len = Point(j, i);\n\tif(room[OfRin][i][j] == 'R') twinspos.Rin = Point(j, i);\n      }\n    }\n    cout << (isOpenGate(twinspos) ? \"Yes\":\"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e9\n#define rep(i,n) for(int i=0;i<n;i++)\n\nstruct C{\n\tint tx,ty,kx,ky;\n\tC(int tx,int ty,int kx,int ky):\n\ttx(tx),ty(ty),kx(kx),ky(ky) {}\n};\n\nint X,Y,sxl,syl,gxl,gyl,sxr,syr,gxr,gyr,dx[]={1,0,-1,0},dy[]={0,1,0,-1},d[51][51][51][51];\nchar l[51][51],r[51][51];\n\nint bfs(int tx,int ty,int kx,int ky){\n\tqueue<C> q;\n\trep(i,X)rep(j,Y)rep(k,X)rep(l,Y)d[i][j][k][l]=INF;\n\tq.push(C(tx,ty,kx,ky));\n\td[tx][ty][kx][ky]=0;\n\twhile(!q.empty()){\n\t\tC c=q.front();q.pop();\n\t\tif(c.tx==gxl&&c.ty==gyl&&c.kx==gxr&&c.ky==gyr)return d[c.tx][c.ty][c.kx][c.ky];\n\t\trep(i,4){\n\t\t\tint ntx=c.tx+dx[i],nty=c.ty+dy[i],nkx=c.kx-dx[i],nky=c.ky+dy[i];\n\t\t\tif((ntx==gxl&&nty==gyl)^(nkx==gxr&&nky==gyr))continue;\n\t\t\tif(ntx<0||ntx>=X||nty<0||nty>=Y||l[nty][ntx]=='#'){ntx=c.tx;nty=c.ty;}\n\t\t\tif(nkx<0||nkx>=X||nky<0||nky>=Y||r[nky][nkx]=='#'){nkx=c.kx;nky=c.ky;}\n\t\t\tif(d[ntx][nty][nkx][nky]==INF){\n\t\t\t\tq.push(C(ntx,nty,nkx,nky));\n\t\t\t\td[ntx][nty][nkx][nky]=d[c.tx][c.ty][c.kx][c.ky]+1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\twhile(cin>>X>>Y&&X){\n\t\trep(i,Y){\n\t\t\trep(j,X){\n\t\t\t\tcin>>l[i][j];\n\t\t\t\tif(l[i][j]=='%'){gxl=j;gyl=i;}\n\t\t\t\tif(l[i][j]=='L'){sxl=j;syl=i;}\n\t\t\t}\n\t\t\trep(j,X){\n\t\t\t\tcin>>r[i][j];\n\t\t\t\tif(r[i][j]=='%'){gxr=j;gyr=i;}\n\t\t\t\tif(r[i][j]=='R'){sxr=j;syr=i;}\n\t\t\t}\n\t\t}\n\t\tint ans=bfs(sxl,syl,sxr,syr);\n\t\tcout<<(bfs(sxl,syl,sxr,syr)?\"Yes\":\"No\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <queue>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\nconst int dy[] = {1, 0, -1, 0};\nconst int dx[] = {0, 1, 0, -1};\nconst int MAX_N = 60;\nstruct Info\n{\n    P left, right;\n};\nstring Rfield[MAX_N];\nstring Lfield[MAX_N];\nbool used[MAX_N][MAX_N][MAX_N][MAX_N];\nint h, w, lsy, lsx, rsy, rsx;\nbool OutOfRange(int y, int x, string field[])\n{\n    if(y >= h || x >= w || x < 0 || y < 0 || field[y][x] == '#') return true;\n    else return false;\n}\nbool bfs()\n{\n    memset(used, false, sizeof(used));\n    queue<Info> que;\n    que.push({P(lsy, lsx), P(rsy, rsx)});\n    while(!que.empty())\n    {\n        Info p = que.front();\n        que.pop();\n        if(used[p.left.first][p.left.second][p.right.first][p.right.second]) continue;\n        used[p.left.first][p.left.second][p.right.first][p.right.second] = true;\n        if(Lfield[p.left.first][p.left.second] == '%' && Rfield[p.right.first][p.right.second] == '%') return true;\n        if(Lfield[p.left.first][p.left.second] == '%' || Rfield[p.right.first][p.right.second] == '%') continue;\n        for(int i = 0; i < 4; i++)\n        {\n            int ly = p.left.first;\n            int lx = p.left.second;\n            int ry = p.right.first;\n            int rx = p.right.second;\n            if(!OutOfRange(ly + dy[i], lx + dx[i], Lfield)) ly += dy[i], lx += dx[i];\n            if(!OutOfRange(ry + dy[i], rx - dx[i], Rfield)) ry += dy[i], rx -= dx[i];\n            P np = {ly, lx}, nq = {ry, rx};\n            if(!used[ly][lx][ry][rx]) que.push({np, nq});\n        }\n    }\n    return false;\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> w >> h, w | h)\n    {\n        for(int i = 0; i < h; i++)\n        {\n            cin >> Lfield[i] >> Rfield[i];\n            for(int j = 0; j < w; j++)\n            {\n                if(Lfield[i][j] == 'L') lsy = i, lsx = j;\n                if(Rfield[i][j] == 'R') rsy = i, rsx = j;\n            }\n        }\n        cout << (bfs() ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return n ? __builtin_popcount(n) : 0; }\ntemplate <> int popcount(int n) { return n ? __builtin_popcount(n) : 0; }\ntemplate <> int popcount(unsigned long long n) { return n ? __builtin_popcountll(n) : 0; }\ntemplate <> int popcount(long long n) { return n ? __builtin_popcountll(n) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\n\n\nint w, h;\nchar l[64][64], r[64][64];\nbool solve()\n{\n\tint lx, ly, rx, ry;\n\tfor (int y = 0; y < h; ++y)\n\t{\n\t\tfor (int x = 0; x < w; ++x)\n\t\t{\n\t\t\tif (l[y][x] == 'L')\n\t\t\t\tlx = x, ly = y;\n\t\t\tif (r[y][x] == 'R')\n\t\t\t\trx = x, ry = y;\n\t\t}\n\t}\n\n\tstatic bool visit[64][64][64][64];\n\tCL(visit, 0);\n\n\ttypedef pair<pint, pint> P;\n\tqueue<P> q;\n\tvisit[ly][lx][ry][rx] = true;\n\tq.push(P(pint(lx, ly), pint(rx, ry)));\n\twhile (!q.empty())\n\t{\n\t\tP t = q.front(); q.pop();\n\t\tint lx = t.first.first, ly = t.first.second;\n\t\tint rx = t.second.first, ry = t.second.second;\n\n\t\tfor (int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint nx, ny, mx, my;\n\t\t\tint x = dx[i], y = dy[i];\n\n\t\t\tnx = lx + x, ny = ly + y;\n\t\t\tif (!valid_pos(nx, ny, w, h) || l[ny][nx] == '#')\n\t\t\t\tnx = lx, ny = ly;\n\n\t\t\tif (i == 1 || i == 3)\n\t\t\t\tx *= -1;\n\t\t\tmx = rx + x, my = ry + y;\n\t\t\tif (!valid_pos(mx, my, w, h) || r[my][mx] == '#')\n\t\t\t\tmx = rx, my = ry;\n\n\t\t\tif (valid_pos(nx, ny, w, h) && valid_pos(mx, my, w, h)\n\t\t\t\t&& !visit[ny][nx][my][mx])\n\t\t\t{\n\t\t\t\tif (l[ny][nx] == '%' && r[my][mx] == '%')\n\t\t\t\t\treturn true;\n\n\t\t\t\tvisit[ny][nx][my][mx] = true;\n\t\t\t\tq.push(P(pint(nx, ny), pint(mx, my)));\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main()\n{\n\twhile (scanf(\"%d%d\", &w, &h), w)\n\t{\n\t\tfor (int i = 0; i < h; ++i)\n\t\t\tscanf(\"%s%s\", l[i], r[i]);\n\t\tputs(solve() ? \"Yes\" : \"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing psi=pair<string,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define MOD (1e9+7)\nvoid get(){}template<class H,class...T>void get(H&h,T&...t){cin>>h;get(t...);}\ntemplate<class T>void geti(T&a){for(auto&_:a)cin>>_;}\ntemplate<class T>void getii(T&a){for(auto&_:a)geti(_);}\nvoid put(string d){}template<class H,class...T>void put(string d,H&h,T&...t){cout<<h;if(sizeof...(t))cout<<d;put(d,t...);}\ntemplate<class T>void puti(T&a,string d=\" \"){bool f=1;for(auto&_:a)cout<<(exchange(f,0)?\"\":d)<<_;cout<<endl;}\ntemplate<class T>void putii(T&a,string d=\" \"){for(auto&_:a)puti(_,d);}\n#define dcl(...) ll __VA_ARGS__;get(__VA_ARGS__)\n#define dclt(t,...) t __VA_ARGS__;get(__VA_ARGS__)\n\nint main(){\n\tint w,h;\n\twhile(cin>>w>>h,w){\n\t\tvector<vvi> f(2,vvi(h+2,vi(w+2,1)));\n\t\tvvi curr(2,vi(2));\n\t\tvvi stat(2,vi(2));\n\t\tfor(int i=1;i<=h;i++){\n\t\t\trep(p,2){\n\t\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\t\tchar c; cin>>c;\n\t\t\t\t\tif(c=='.'){\n\t\t\t\t\t\tf[p][i][j]=0;\n\t\t\t\t\t}else if(c=='%'){\n\t\t\t\t\t\tf[p][i][j]=0;\n\t\t\t\t\t\tstat[p]={i,j};\n\t\t\t\t\t}else if(c=='L'){\n\t\t\t\t\t\tf[p][i][j]=0;\n\t\t\t\t\t\tcurr[0]={i,j};\n\t\t\t\t\t}else if(c=='R'){\n\t\t\t\t\t\tf[p][i][j]=0;\n\t\t\t\t\t\tcurr[1]={i,w+1-j};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treverse(all(f[1][i]));\n\t\t}\n\t\tstat[1][1]=w+1-stat[1][1];\n\t\t//putii(f[0],\"\");\n\t\t//cout<<endl;\n\t\t//putii(f[1],\"\");\n\t\t//cout<<\"=======\"<<endl;\n\t\t\n\t\t/*幅優先\n\t\t\t・どちらか片方だけ動き、動いた先がゴールでない場合\n\t\t\t・両方動き、かつ少なくともどちらかがそのマスを訪れたことがない場合\n\t\t\tだけ、探索する\n\t\t*/\n\t\tset<vvi> isVisited;\n\t\t//isVisited.insert(curr);\n\n\t\tstack<vvi> que;\n\t\tque.push(curr);\n\t\tint y[]={-1,0,1,0};\n\t\tint x[]={0,1,0,-1};\n\t\tauto step=[f](vi &pos,int lr, int y, int x){\n\t\t\tif(f[lr][pos[0]+y][pos[1]+x]!=1){\n\t\t\t\tpos[0]+=y;\n\t\t\t\tpos[1]+=x;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tbool ok=false;\n\t\twhile(!que.empty()){\n\t\t\tauto c=que.top();\n\t\t\tque.pop();\n\t\t\t//cout<<c[0][0]<<\",\"<<c[0][1]<<\"  \"<<c[1][0]<<\",\"<<c[1][1]<<endl;\n\t\t\tif(c==stat){\n\t\t\t\tok=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(isVisited.find(c)!=isVisited.end()){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tisVisited.insert(c);\n\t\t\trep(v,4){\n\t\t\t\tauto next=c;\n\t\t\t\tbool l=step(next[0],0,y[v],x[v]);\n\t\t\t\tbool r=step(next[1],1,y[v],x[v]);\n\t\t\t\tif(isVisited.find(next)==isVisited.end()){\n\t\t\t\t\tif( (!l and r and next[1]!=stat[1])\n\t\t\t\t\t\tor (l and !r and next[0]!=stat[0])\n\t\t\t\t\t\tor ( l and r and !(next[0]!=stat[0] xor next[1]!=stat[1]) )){\n\t\t\t\t\t\t//cout<<\" o \"<<next[0][0]<<\",\"<<next[0][1]<<\"  \"<<next[1][0]<<\",\"<<next[1][1]<<endl;\n\t\t\t\t\t\tque.push(next);\n\t\t\t\t\t}else{\n\t\t\t\t\t\t//cout<<\" x \"<<next[0][0]<<\",\"<<next[0][1]<<\"  \"<<next[1][0]<<\",\"<<next[1][1]<<endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t}else{\n\t\t\tcout<<\"No\"<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nstruct Node {\n  Node(int lx, int ly, int rx, int ry) {\n    this->lx = lx;\n    this->ly = ly;\n    this->rx = rx;\n    this->ry = ry;\n  }\n\n  int lx;\n  int ly;\n  int rx;\n  int ry;\n};\n\nbool shining(const Node &n, bool s[50][50][50][50], int W) {\n  int lX = n.lx - 1;\n  int lY = n.ly - 1;\n  int rX = n.rx - W - 2;\n  int rY = n.ry - 1;\n\n  bool ret = s[lX][lY][rX][rY];\n  s[lX][lY][rX][rY] = true;\n\n  return ret;\n}\n\nint main() {\n  vector<vector<char> > f(103);\n  for (int i = 0; i < f.size(); i++) {\n    f[i].resize(52);\n  }\n\n  while (true) {\n    int W, H;\n    cin >> W >> H;\n\n    if (W == 0) {\n      break;\n    }\n\n    int cw = W + 1;\n    int w = W * 2 + 3;\n    int h = H + 2;\n    for (int i = 0; i < w; i++) {\n      f[i][0] = f[i][h - 1] = '#';\n    }\n    for (int i = 0; i < h; i++) {\n      f[0][i] = f[cw][i] = f[w - 1][i] = '#';\n    }\n\n    int lx = 0, ly = 0;\n    int rx = 0, ry = 0;\n    for (int i = 1; i < h - 1; i++) {\n      for (int j = 1; j < cw; j++) {\n\tcin >> f[j][i];\n\tif (f[j][i] == 'L') {\n\t  lx = j;\n\t  ly = i;\n\t  f[j][i] = '.';\n\t}\n      }\n      for (int j = cw + 1; j < w - 1; j++) {\n\tcin >> f[j][i];\n\tif (f[j][i] == 'R') {\n\t  rx = j;\n\t  ry = i;\n\t  f[j][i] = '.';\n\t}\n      }\n    }\n\n    bool s[50][50][50][50];\n    for (int i = 0; i < W; i++) {\n      for (int j = 0; j < H; j++) {\n\tfor (int k = 0; k < W; k++) {\n\t  for (int l = 0; l < H; l++) {\n\t    s[i][j][k][l] = false;\n\t  }\n\t}\n      }\n    }\n\n    queue<Node> q;\n    q.push(Node(lx, ly, rx, ry));\n    shining(q.front(), s, W);\n    while (!q.empty()) {\n      Node n = q.front();\n\n      if (f[n.lx][n.ly] == '%' && f[n.rx][n.ry] == '%') {\n\tcout << \"Yes\" << endl;\n\tbreak;\n      }\n      q.pop();\n\n      if (f[n.lx][n.ly] == '%' || f[n.rx][n.ry] == '%') {\n\tcontinue;\n      }\n\n      Node nn(n.lx, f[n.lx][n.ly - 1] != '#' ? n.ly - 1 : n.ly,\n\t      n.rx, f[n.rx][n.ry - 1] != '#' ? n.ry - 1 : n.ry);\n\n      if (!shining(nn, s, W)) {\n\tq.push(nn);\n      }\n\n      Node we(f[n.lx - 1][n.ly] != '#' ? n.lx - 1 : n.lx, n.ly,\n\t      f[n.rx + 1][n.ry] != '#' ? n.rx + 1 : n.rx, n.ry);\n\n      if (!shining(we, s, W)) {\n\tq.push(we);\n      }\n\n      Node ew(f[n.lx + 1][n.ly] != '#' ? n.lx + 1 : n.lx, n.ly,\n\t      f[n.rx - 1][n.ry] != '#' ? n.rx - 1 : n.rx, n.ry);\n\n      if (!shining(ew, s, W)) {\n\tq.push(ew);\n      }\n\n      Node ss(n.lx, f[n.lx][n.ly + 1] != '#' ? n.ly + 1 : n.ly,\n\t      n.rx, f[n.rx][n.ry + 1] != '#' ? n.ry + 1 : n.ry);\n\n      if (!shining(ss, s, W)) {\n\tq.push(ss);\n      }\n    }\n\n    if (q.empty()) {\n      cout << \"No\" << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//??±???????????¢?´¢??§??????????????????????????????\n\n\nint di_L[4] = {0, -1, 0, 1};\nint di_R[4] = {0, -1, 0, 1};\nint dj_L[4] = {1, 0, -1, 0};\nint dj_R[4] = {-1, 0, 1, 0};\n\nint si_L, si_R, sj_L, sj_R, gi_L, gi_R, gj_L, gj_R;  //??????????????¨??´???????????§?¨?\n\nbool dfs(int i_L, int i_R, int j_L, int j_R, vector<vector<bool> >& Room_L, vector<vector<bool> >& Room_R){\n\n    bool flag_L, flag_R;  //??´?????????????????????????????????????????????\n\n    if(i_L == gi_L && j_L == gj_L) flag_L = true;\n    else flag_L = false;\n\n    if(i_R == gi_R && j_R == gj_R) flag_R = true;\n    else flag_R = false;\n\n    //????????????????????´??????????????????????????????true\n    //????????????????????´??????????????????????????????false\n    if(flag_L && flag_R) return true;\n    else if(!flag_L && !flag_R){}\n    else return false;\n\n    //???????????°????????¢?´¢?????????\n    Room_L[i_L][j_L] = false;\n    Room_R[i_R][j_R] = false;\n\n    //???????????¢?´¢\n    \n    for(int k = 0; k < 4; k++){\n        int ni_L = i_L + di_L[k];\n        int nj_L = j_L + dj_L[k];\n        int ni_R = i_R + di_R[k];\n        int nj_R = j_R + dj_R[k];\n\n        //???????????????????????´???\n        if(Room_L[ni_L][nj_L] && Room_R[ni_R][nj_R]){\n            bool flag = dfs(ni_L, ni_R, nj_L, nj_R, Room_L, Room_R);\n            if(flag) return true;\n        }else if(Room_L[ni_L][nj_L] && !Room_R[ni_R][nj_R]){  //L????????????????????´???\n            bool flag = dfs(ni_L, i_R, nj_L, j_R, Room_L, Room_R);\n            if(flag) return true;\n        }else if(!Room_L[ni_L][nj_L] && Room_R[ni_R][nj_R]){\n            bool flag = dfs(i_L, ni_R, j_L, nj_R, Room_L, Room_R);\n            if(flag) return true;\n        }\n    }\n    \n    return false;\n}\n\nint main(){\n\n    while(1){\n\n    //??\\???\n    int W, H; cin >> W >> H;\n    if(W == 0) break;\n\n    vector<vector<bool> > Room_L(H + 2, vector<bool> (W + 2, false));\n    vector<vector<bool> > Room_R(H + 2, vector<bool> (W + 2, false));\n\n    for(int i = 1; i <= H; i++){\n        //L\n        for(int j = 1; j <= W; j++){\n            char input; cin >> input;\n            if(input == '#') continue;\n            else{\n                Room_L[i][j] = true;\n\n                if(input == '%'){\n                    gi_L = i;\n                    gj_L = j;\n                }\n\n                if(input == 'L'){\n                    si_L = i;\n                    sj_L = j;\n                }\n            }\n        }\n\n        //R\n        for(int j = 1; j <= W; j++){\n            char input; cin >> input;\n            if(input == '#') continue;\n            else{\n                Room_R[i][j] = true;\n\n                if(input == '%'){\n                    gi_R = i;\n                    gj_R = j;\n                }\n\n                if(input == 'R'){\n                    si_R = i;\n                    sj_R = j;\n                }\n            }\n        }\n    }\n\n\n    //??±???????????¢?´¢?????????\n    bool result = dfs(si_L, si_R, sj_L, sj_R, Room_L, Room_R);\n    if(result) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define rrep(i, n) for (int i = (n) - 1; i >= 0; --i)\n#define rfor(i, m, n) for (int i = (m); i >= (n); --i)\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define range_it(a, l, r) (a).begin() + (l), (a).begin() + (r)\n\nusing namespace std;\nusing ll = long long;\t\tusing ld = long double;\nusing VB = vector<bool>;\tusing VVB = vector<VB>;\nusing VI = vector<int>;\t\tusing VVI = vector<VI>;\nusing VL = vector<ll>;\t\tusing VVL = vector<VL>;\nusing VS = vector<string>;\tusing VD = vector<ld>;\nusing PII = pair<int, int>;\tusing VP = vector<PII>;\nusing PLL = pair<ll, ll>;\tusing VPL = vector<PLL>;\ntemplate<class T>using PQ = priority_queue<T>;\ntemplate<class T>using PQS = priority_queue<T, vector<T>, greater<T>>;\nconstexpr int inf = (int)1e9;\nconstexpr ll inf_ll = (ll)1e18, MOD = 1000000007;\nconstexpr ld PI = M_PI, EPS = 1e-12;\n\n// --- input --- //\n#ifdef _WIN32\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#define fwrite_unlocked fwrite\n#define fflush_unlocked _fflush_nolock\n#endif\ninline int gc() { return getchar_unlocked(); }\ntemplate<class T>inline void InputF(T& v) { cin >> v; }\ninline void InputF(char& v) { while (isspace(v = gc())); }\ninline void InputF(bool& v) { char c; InputF(c); v = c != '0'; }\ninline void InputF(string& v) {\n\tv.clear(); char c; for (InputF(c); !isspace(c); c = gc())v += c;\n}\ninline void InputF(int& v) {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(long long& v) {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(double& v) {\n\tdouble dp = 1; bool neg = false, adp = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\tif (c == '.')adp = true;\n\t\telse if (adp)v += (c - '0') * (dp *= 0.1);\n\t\telse v = v * 10 + (c - '0');\n\t}\n\tif (neg)v = -v;\n}\ntemplate<class T, class U>inline void InputF(pair<T, U>& v) {\n\tInputF(v.first); InputF(v.second);\n}\ntemplate<class T>inline void InputF(vector<T>& v) {\n\tfor (auto& e : v)InputF(e);\n}\ntemplate<class T>inline T InputF() { T v; InputF(v); return v; }\ninline string GetLine() {\n\tstring v; char c; for (InputF(c); c != '\\n' && c != '\\0'; c = gc())v += c; return v;\n}\nstruct InputV {\n\tint n, m;\n\tInputV(int N) :n(N), m(0) {}\n\tInputV(pair<int, int> N) :n(N.first), m(N.second) {}\n\ttemplate<class T>operator vector<T>() {\n\t\tvector<T> v(n); InputF(v); return v;\n\t}\n\ttemplate<class T>operator vector<vector<T>>() {\n\t\tvector<vector<T>> v(n, vector<T>(m)); InputF(v); return v;\n\t}\n};\nstruct Input {\n\ttemplate<class T>operator T() { return InputF<T>(); }\n\tint operator--(int) { int v; InputF(v); v--; return v; }\n\tInputV operator[](int n) { return InputV(n); }\n\tInputV operator[](pair<int, int> n) { return InputV(n); }\n\tvoid operator()() {}\n\ttemplate<class H, class...T>void operator()(H&& h, T&& ...t) {\n\t\tInputF(h); operator()(forward<T>(t)...);\n\t}\n\ttemplate<class T>Input& operator,(T&& v) {\n\t\tInputF(v); return *this;\n\t}\n}in;\n#define input(T) InputF<T>()\n#define ini input(int)\n#define inl input(ll)\n#define ins input(string)\n#define inputs(T, ...) T __VA_ARGS__; in(__VA_ARGS__)\n#define INT(...) inputs(int, __VA_ARGS__)\n#define LL(...) inputs(ll, __VA_ARGS__)\n#define STR(...) inputs(string, __VA_ARGS__)\n\n// --- output --- //\nstruct BoolStr {\n\tconst char* t, * f; BoolStr(const char* _t, const char* _f) :t(_t), f(_f) {}\n}Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\"), Int(\"1\", \"0\");\nstruct DivStr {\n\tconst char* d, * l; DivStr(const char* _d, const char* _l) :d(_d), l(_l) {}\n}spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), end_line(\"\\n\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Output {\n\tBoolStr B{ Yes }; DivStr D{ spc };\n\tvoid p(int v) {\n\t\tif (v < 0)putchar_unlocked('-'), v = -v;\n\t\tchar b[10]; int i = 0;\n\t\twhile (v)b[i++] = '0' + v % 10, v /= 10;\n\t\tif (!i)b[i++] = '0';\n\t\twhile (i--)putchar_unlocked(b[i]);\n\t}\n\tvoid p(ll v) {\n\t\tif (v < 0)putchar_unlocked('-'), v = -v;\n\t\tchar b[20]; int i = 0;\n\t\twhile (v)b[i++] = '0' + v % 10, v /= 10;\n\t\tif (!i)b[i++] = '0';\n\t\twhile (i--)putchar_unlocked(b[i]);\n\t}\n\tvoid p(bool v) { p(v ? B.t : B.f); }\n\tvoid p(char v) { putchar_unlocked(v); }\n\tvoid p(const char* v) { fwrite_unlocked(v, 1, strlen(v), stdout); }\n\tvoid p(double v) { printf(\"%.20f\", v); }\n\tvoid p(ld v) { printf(\"%.20Lf\", v); }\n\ttemplate<class T> void p(const T& v) { cout << v; }\n\ttemplate<class T, class U>void p(const pair<T, U>& v) { p(v.first); p(D.d); p(v.second); }\n\ttemplate<class T>void p(const vector<T>& v) { rep(i, sz(v)) { if (i)p(D.d); p(v[i]); } }\n\ttemplate<class T>void p(const vector<vector<T>>& v) { rep(i, sz(v)) { if (i)p(D.l); p(v[i]); } }\npublic:\n\tOutput& operator()() { p(D.l); return *this; }\n\ttemplate<class H>Output& operator()(H&& h) { p(h); p(D.l); return *this; }\n\ttemplate<class H, class...T>Output& operator()(H&& h, T&& ...t) {\n\t\tp(h); p(D.d); return operator()(forward<T>(t)...);\n\t}\n\ttemplate<class...T>void exit(T&& ...t) { operator()(forward<T>(t)...); std::exit(EXIT_SUCCESS); }\n\tOutput& flush() { fflush_unlocked(stdout); return *this; }\n\tOutput& set(const BoolStr& b) { B = b; return *this; }\n\tOutput& set(const DivStr& d) { D = d; return *this; }\n\tOutput& set(const char* t, const char* f) { B = BoolStr(t, f); return *this; }\n}out;\n\n// --- step --- //\ntemplate<class T>struct Step {\n\tclass It {\n\t\tT a, b, c;\n\tpublic:\n\t\tconstexpr It() : a(T()), b(T()), c(T()) {}\n\t\tconstexpr It(T _b, T _c, T _s) : a(_b), b(_c), c(_s) {}\n\t\tconstexpr It& operator++() { --b; a += c; return *this; }\n\t\tconstexpr It operator++(int) { It tmp = *this; --b; a += c; return tmp; }\n\t\tconstexpr const T& operator*()const { return a; }\n\t\tconstexpr const T* operator->()const { return &a; }\n\t\tconstexpr bool operator==(const It& i)const { return b == i.b; }\n\t\tconstexpr bool operator!=(const It& i)const { return !(b == i.b); }\n\t\tconstexpr T start()const { return a; }\n\t\tconstexpr T count()const { return b; }\n\t\tconstexpr T step()const { return c; }\n\t};\n\tconstexpr Step(T b, T c, T s) : be(b, c, s) {}\n\tconstexpr It begin()const { return be; }\n\tconstexpr It end()const { return en; }\n\tconstexpr T start()const { return be.start(); }\n\tconstexpr T count()const { return be.count(); }\n\tconstexpr T step()const { return be.step(); }\n\tconstexpr T sum()const { return start() * count() + step() * (count() * (count() - 1) / 2); }\n\toperator vector<T>()const { return as_vector(); }\n\tvector<T> as_vector()const {\n\t\tvector<T> res; res.reserve(count()); each([&](T i) {res.push_back(i); }); return res;\n\t}\n\ttemplate<class F>void each(const F& f)const { for (T i : *this)f(i); }\n\ttemplate<class F>auto map(const F& f)const {\n\t\tvector<decay_t<result_of_t<F(T)>>> res; res.reserve(count());\n\t\teach([&](T i) {res.push_back(f(i)); }); return res;\n\t}\n\ttemplate<class F>int count_if(const F& f)const {\n\t\tint res = 0; each([&](T i) {res += static_cast<bool>(f(i)); }); return res;\n\t}\n\ttemplate<class F>vector<T> select(const F& f)const {\n\t\tvector<T> res; each([&](T i) {if (f(i))res.push_back(i); }); return res;\n\t}\n\ttemplate<class F>auto max(const F& f)const {\n\t\tauto v = map(f); return *max_element(v.begin(), v.end());\n\t}\n\ttemplate<class F>auto min(const F& f)const {\n\t\tauto v = map(f); return *min_element(v.begin(), v.end());\n\t}\n\ttemplate<class F, class U = decay_t<result_of_t<F(T)>>>auto sum(const F& f)const {\n\t\tU res = 0; each([&](T i) {res += static_cast<U>(f(i)); }); return res;\n\t}\n\tusing value_type = T;\n\tusing iterator = It;\nprivate:\n\tIt be, en;\n};\ntemplate<class T>inline constexpr auto step(T a) { return Step<T>(0, a, 1); }\ntemplate<class T>inline constexpr auto step(T a, T b) { return Step<T>(a, b - a, 1); }\ntemplate<class T>inline constexpr auto step(T a, T b, T c) { return Step<T>(a, a < b ? (b - a - 1) / c + 1 : 0, c); }\n\n// --- functions --- //\ninline namespace {\n\ttemplate<class T>inline void Sort(T& a) { sort(all(a)); }\n\ttemplate<class T>inline void RSort(T& a) { sort(rall(a)); }\n\ttemplate<class T>inline T Sorted(T a) { Sort(a); return a; }\n\ttemplate<class T>inline T RSorted(T a) { RSort(a); return a; }\n\ttemplate<class T, class F>inline void Sort(T& a, const F& f) {\n\t\tsort(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class F>inline void RSort(T& a, const F& f) {\n\t\tsort(rall(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T>inline void Reverse(T& a) { reverse(all(a)); }\n\ttemplate<class T>inline void Unique(T& a) { a.erase(unique(all(a)), a.end()); }\n\ttemplate<class T>inline void Rotate(T& a, int left) { rotate(a.begin(), a.begin() + left, a.end()); }\n\ttemplate<class T>inline T Reversed(T a) { Reverse(a); return a; }\n\ttemplate<class T>inline T Uniqued(T a) { Unique(a); return a; }\n\ttemplate<class T>inline T Rotated(T a, int left) { Rotate(a, left); return a; }\n\ttemplate<class T>inline auto Max(const T& a) { return *max_element(all(a)); }\n\ttemplate<class T>inline auto Min(const T& a) { return *min_element(all(a)); }\n\ttemplate<class T>inline int MaxPos(const T& a) { return max_element(all(a)) - a.begin(); }\n\ttemplate<class T>inline int MinPos(const T& a) { return min_element(all(a)) - a.begin(); }\n\ttemplate<class T, class F>inline auto Max(const T& a, const F& f) {\n\t\treturn *max_element(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class F>inline auto Min(const T& a, const F& f) {\n\t\treturn *min_element(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class U>inline int Count(const T& a, const U& v) { return count(all(a), v); }\n\ttemplate<class T, class F>inline int CountIf(const T& a, const F& f) { return count_if(all(a), f); }\n\ttemplate<class T, class U>inline int Find(const T& a, const U& v) { return find(all(a), v) - a.begin(); }\n\ttemplate<class T, class F>inline int FindIf(const T& a, const F& f) { return find_if(all(a), f) - a.begin(); }\n\ttemplate<class T, class U = typename T::value_type>inline U Sum(const T& a) { return accumulate(all(a), U()); }\n\ttemplate<class T, class F>inline auto Sum(const T& v, const F& f) {\n\t\treturn accumulate(next(v.begin()), v.end(), f(v.front()), [&](auto a, auto b) {return a + f(b); });\n\t}\n\ttemplate<class T, class U>inline int Lower(const T& a, const U& v) { return lower_bound(all(a), v) - a.begin(); }\n\ttemplate<class T, class U>inline int Upper(const T& a, const U& v) { return upper_bound(all(a), v) - a.begin(); }\n\ttemplate<class T, class F>inline void RemoveIf(T& a, const F& f) { a.erase(remove_if(all(a), f), a.end()); }\n\ttemplate<class F>inline auto Vector(size_t size, const F& f) {\n\t\tvector<decay_t<result_of_t<F(size_t)>>> res(size); for (size_t i = 0; i < size; ++i)res[i] = f(i); return res;\n\t}\n\ttemplate<class T>inline auto Grid(size_t h, size_t w, const T& v = T()) { return vector<vector<T>>(h, vector<T>(w, v)); }\n\ttemplate<class T>inline auto Slice(const T& v, size_t i, size_t len) {\n\t\treturn i < v.size() ? T(v.begin() + i, v.begin() + min(i + len, v.size())) : T();\n\t}\n\ttemplate<class T, class F>inline auto Each(const T& v, const F& f) { for (auto& i : v)f(i); }\n\ttemplate<class T, class F>inline auto Select(const T& v, const F& f) {\n\t\tT res; for (const auto& e : v)if (f(e))res.push_back(e); return res;\n\t}\n\ttemplate<class T, class F>inline auto Map(const T& v, const F& f) {\n\t\tvector<decay_t<result_of_t<F(typename T::value_type)>>> res(v.size());\n\t\tsize_t i = 0; for (const auto& e : v)res[i++] = f(e); return res;\n\t}\n\ttemplate<class T, class F>inline auto MapIndex(const T& v, const F& f) {\n\t\tvector<decay_t<result_of_t<F(size_t, typename T::value_type)>>> res(v.size());\n\t\tsize_t i = 0; for (auto it = v.begin(); it != v.end(); ++it, ++i)res[i] = f(i, *it); return res;\n\t}\n\ttemplate<class T, class F>inline auto TrueIndex(const T& v, const F& f) {\n\t\tvector<size_t> res; for (size_t i = 0; i < v.size(); ++i)if (f(v[i]))res.push_back(i); return res;\n\t}\n\tinline string operator*(string s, size_t n) { string ret; for (size_t i = 0; i < n; ++i)ret += s; return ret; }\n\ttemplate<class T>inline T Ceil(T n, T m) { return (n + m - 1) / m; }\n\ttemplate<class T>inline T Ceil2(T n, T m) { return Ceil(n, m) * m; }\n\ttemplate<class T>inline T Tri(T n) { return (n & 1) ? (n + 1) / 2 * n : n / 2 * (n + 1); }\n\ttemplate<class T>inline T nC2(T n) { return (n & 1) ? (n - 1) / 2 * n : n / 2 * (n - 1); }\n\ttemplate<class T>inline T Mid(const T& l, const T& r) { return l + (r - l) / 2; }\n\tinline int pop_count(int n) { return bitset<32>(n).count(); }\n\tinline int pop_count(ll n) { return bitset<64>(n).count(); }\n\ttemplate<class T>inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\n\ttemplate<class T>inline bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\n\ttemplate<class T>inline bool inRange(const T& v, const T& min, const T& max) { return min <= v && v < max; }\n\ttemplate<class T = ll>inline T BIT(int b) { return T(1) << b; }\n\ttemplate<class T>inline T Gcd(T n, T m) { return m ? Gcd(m, n % m) : n; }\n\ttemplate<class T>inline T Lcm(T n, T m) { return n / Gcd(n, m) * m; }\n\ttemplate<class T, class U = typename T::value_type>inline U Gcdv(const T& v) {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), Gcd<U>);\n\t}\n\ttemplate<class T, class U = typename T::value_type>inline U Lcmv(const T& v) {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), Lcm<U>);\n\t}\n\ttemplate<class T>inline T Pow(T a, T n) { T r = 1; while (n > 0) { if (n & 1)r *= a; a *= a; n /= 2; } return r; }\n\ttemplate<class T>inline T Powmod(T a, T n, T m = MOD) {\n\t\tT r = 1; while (n > 0) { if (n & 1)r = r * a % m, n--; else a = a * a % m, n /= 2; }return r;\n\t}\n}\n\n// --- dump --- //\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\n\n// ---------------------------------------------------------------- //\n\nstruct Point {\n\tstatic int H, W;\n\tstatic const vector<Point> d;\n\tstatic void set_range(int _H, int _W) { H = _H; W = _W; }\n\tstatic constexpr Point zero() { return { 0,0 }; }\n\tstatic constexpr Point one() { return { 1,1 }; }\n\tint x, y;\n\tconstexpr Point() :x(0), y(0) {}\n\tconstexpr Point(int _x, int _y) : x(_x), y(_y) {}\n\tconstexpr Point(const pair<int, int>& xy) : x(xy.first), y(xy.second) {}\n\tPoint(int n) :x(n% W), y(n / W) {}\n\tconstexpr Point operator+()const { return *this; }\n\tconstexpr Point operator-()const { return { -x,-y }; }\n\tconstexpr Point operator+(const Point& p)const { return Point(*this) += p; }\n\tconstexpr Point operator-(const Point& p)const { return Point(*this) -= p; }\n\tconstexpr Point operator*(const Point& p)const { return Point(*this) *= p; }\n\tconstexpr Point operator/(const Point& p)const { return Point(*this) /= p; }\n\tconstexpr Point operator%(const Point& p)const { return Point(*this) %= p; }\n\tconstexpr Point operator+(int n)const { return Point(*this) += n; }\n\tconstexpr Point operator-(int n)const { return Point(*this) -= n; }\n\tconstexpr Point operator*(int n)const { return Point(*this) *= n; }\n\tconstexpr Point operator/(int n)const { return Point(*this) /= n; }\n\tconstexpr Point operator%(int n)const { return Point(*this) %= n; }\n\tconstexpr Point& operator+=(const Point& p) { x += p.x; y += p.y; return *this; }\n\tconstexpr Point& operator-=(const Point& p) { x -= p.x; y -= p.y; return *this; }\n\tconstexpr Point& operator*=(const Point& p) { x *= p.x; y *= p.y; return *this; }\n\tconstexpr Point& operator/=(const Point& p) { x /= p.x; y /= p.y; return *this; }\n\tconstexpr Point& operator%=(const Point& p) { x %= p.x; y %= p.y; return *this; }\n\tconstexpr Point& operator+=(int n) { x += n; y += n; return *this; }\n\tconstexpr Point& operator-=(int n) { x -= n; y -= n; return *this; }\n\tconstexpr Point& operator*=(int n) { x *= n; y *= n; return *this; }\n\tconstexpr Point& operator/=(int n) { x /= n; y /= n; return *this; }\n\tconstexpr Point& operator%=(int n) { x %= n; y %= n; return *this; }\n\tconstexpr bool operator==(const Point& p)const { return x == p.x && y == p.y; }\n\tconstexpr bool operator!=(const Point& p)const { return x != p.x || y != p.y; }\n\tbool operator<(const Point& p)const { return to_i() < p.to_i(); }\n\tbool operator<=(const Point& p)const { return to_i() <= p.to_i(); }\n\tbool operator>(const Point& p)const { return to_i() > p.to_i(); }\n\tbool operator>=(const Point& p)const { return to_i() >= p.to_i(); }\n\tconstexpr int operator[](int i)const { return i == 0 ? x : i == 1 ? y : 0; }\n\tbool in_range()const { return 0 <= x && x < W && 0 <= y && y < H; }\n\tint to_i()const { return x + y * W; }\n\tconstexpr pair<int, int> to_pair()const { return { x,y }; }\n\tint dist(const Point& p)const { return std::abs(x - p.x) + std::abs(y - p.y); }\n\tPoint abs(const Point& p)const { return { std::abs(x - p.x),std::abs(y - p.y) }; }\n\tPoint abs()const { return { std::abs(x), std::abs(y) }; }\n\tPoint& swap() { std::swap(x, y); return *this; }\n\tvector<Point> adjacent4()const {\n\t\tvector<Point> v(4); for (int i = 0; i < 4; ++i)v[i] = *this + d[i]; return v;\n\t}\n\tvector<Point> adjacent8()const {\n\t\tvector<Point> v(8); for (int i = 0; i < 8; ++i)v[i] = *this + d[i]; return v;\n\t}\n\tvector<Point> adjacent6()const {\n\t\tvector<Point> v(6); for (int i = 0; i < 6; ++i)v[i] = *this + d[i]; return v;\n\t}\n\tvector<Point> adj4_in_range()const {\n\t\tvector<Point> v; for (const auto& P : adjacent4())if (P.in_range())v.push_back(P); return v;\n\t}\n\tvector<Point> adj8_in_range()const {\n\t\tvector<Point> v; for (const auto& P : adjacent8())if (P.in_range())v.push_back(P); return v;\n\t}\n\tconstexpr Point left()const { return { x - 1,y }; }\n\tconstexpr Point right()const { return { x + 1,y }; }\n\tconstexpr Point up()const { return { x,y - 1 }; }\n\tconstexpr Point down()const { return { x,y + 1 }; }\n\tconstexpr Point moved(char c)const { return Point(*this).move(c); }\n\tconstexpr Point& move(char c) {\n\t\tswitch (c) {\n\t\tcase 'L':case 'l':case'>':x--; break;\n\t\tcase 'R':case 'r':case'<':x++; break;\n\t\tcase 'U':case 'u':case'^':y--; break;\n\t\tcase 'D':case 'd':case'v':y++; break;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr Point rotate90() { return { y,-x }; }\n\tconstexpr Point rotate180() { return { -x,-y }; }\n\tconstexpr Point rotate270() { return { -y,x }; }\n};\nint Point::H, Point::W;\nconst vector<Point> Point::d{ {0,1},{1,0},{0,-1},{-1,0} };\ninline ostream& operator<<(ostream& os, const Point& p) { return  os << '(' << p.x << \", \" << p.y << ')'; }\ninline istream& operator>>(istream& is, Point& p) { return is >> p.x >> p.y; }\n\nint main() {\n\tfor (int w = in, h = in; w + h; in(w, h)) {\n\t\tint n = w * h;\n\t\tPoint::set_range(h, w);\n\t\tVS s(h), t(h);\n\t\trep(i, h)in(s[i], t[i]);\n\n\t\tauto move_point = [&](const Point& p, const Point& d, const VS& grid) {\n\t\t\tPoint p2 = p + d;\n\t\t\tif (!p2.in_range() || grid[p2.y][p2.x] == '#') {\n\t\t\t\tp2 = p;\n\t\t\t}\n\t\t\treturn p2;\n\t\t};\n\t\tauto move_pair = [&](const Point& p1, const Point& p2, const Point& d1) {\n\t\t\tPoint d2 = d1.x == 0 ? d1 : Point(-d1.x, d1.y);\n\t\t\treturn make_pair(move_point(p1, d1, s), move_point(p2, d2, t));\n\t\t};\n\n\t\tPoint L, R;\n\t\trep(i, h)rep(j, w) {\n\t\t\tif (s[i][j] == 'L') {\n\t\t\t\tL = Point(j, i);\n\t\t\t}\n\t\t\tif (t[i][j] == 'R') {\n\t\t\t\tR = Point(j, i);\n\t\t\t}\n\t\t}\n\n\t\tauto flag = Grid<bool>(n, n);\n\t\tflag[L.to_i()][R.to_i()] = true;\n\t\tqueue<pair<Point, Point>> que;\n\t\tque.emplace(L, R);\n\t\tbool ans = false;\n\n\t\twhile (!que.empty()) {\n\t\t\tPoint p1, p2;\n\t\t\ttie(p1, p2) = que.front(); que.pop();\n\n\t\t\tfor (const Point& d : Point::d) {\n\t\t\t\tPoint q1, q2;\n\t\t\t\ttie(q1, q2) = move_pair(p1, p2, d);\n\t\t\t\tbool f1 = s[q1.y][q1.x] == '%', f2 = t[q2.y][q2.x] == '%';\n\n\t\t\t\tif (f1 && f2) {\n\t\t\t\t\tdump(p1, p2);\n\t\t\t\t\tans = true; break;\n\t\t\t\t} else if (!f1 && !f2) {\n\t\t\t\t\tif (!flag[q1.to_i()][q2.to_i()]) {\n\t\t\t\t\t\tflag[q1.to_i()][q2.to_i()] = true;\n\t\t\t\t\t\tque.emplace(q1, q2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout(ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nstruct Node {\n  Node(int lx, int ly, int rx, int ry) {\n    this->lx = lx;\n    this->ly = ly;\n    this->rx = rx;\n    this->ry = ry;\n  }\n\n  int lx;\n  int ly;\n  int rx;\n  int ry;\n};\n\nint oneval(int lx, int ly, int rx, int ry) {\n  return lx * 1000000000 + ly * 1000000 + rx * 1000 + ry;\n}\n\nint main() {\n  vector<vector<char> > f;\n  f.resize(103);\n  for (int i = 0; i < f.size(); i++) {\n    f[i].resize(52);\n  }\n\n  while (true) {\n    int W, H;\n    cin >> W >> H;\n\n    if (W == 0) {\n      break;\n    }\n\n    int cw = W + 1;\n    int w = W * 2 + 3;\n    int h = H + 2;\n    for (int i = 0; i < w; i++) {\n      f[i][0] = f[i][h - 1] = '#';\n    }\n    for (int i = 0; i < h; i++) {\n      f[0][i] = f[cw][i] = f[w - 1][i] = '#';\n    }\n\n    int lx = 0, ly = 0;\n    int rx = 0, ry = 0;\n    for (int i = 1; i < h - 1; i++) {\n      for (int j = 1; j < cw; j++) {\n\tcin >> f[j][i];\n\tif (f[j][i] == 'L') {\n\t  lx = j;\n\t  ly = i;\n\t  f[j][i] = '.';\n\t}\n      }\n      for (int j = cw + 1; j < w - 1; j++) {\n\tcin >> f[j][i];\n\tif (f[j][i] == 'R') {\n\t  rx = j;\n\t  ry = i;\n\t  f[j][i] = '.';\n\t}\n      }\n    }\n\n    set<int> s;\n    queue<Node *> q;\n    q.push(new Node(lx, ly, rx, ry));\n    while (!q.empty()) {\n      Node *n = q.front();\n\n      if (f[n->lx][n->ly] == '%' && f[n->rx][n->ry] == '%') {\n\tcout << \"Yes\" << endl;\n\tbreak;\n      }\n      q.pop();\n\n      int val = oneval(n->lx, n->ly, n->rx, n->ry);\n      if (s.count(val) != 0) {\n\tdelete n;\n\tcontinue;\n      }\n      s.insert(val);\n\n      q.push(new Node(n->lx, f[n->lx][n->ly - 1] != '#' ? n->ly - 1 : n->ly,\n\t\t      n->rx, f[n->rx][n->ry - 1] != '#' ? n->ry - 1 : n->ry));\n      q.push(new Node(f[n->lx - 1][n->ly] != '#' ? n->lx - 1 : n->lx, n->ly,\n\t\t      f[n->rx + 1][n->ry] != '#' ? n->rx + 1 : n->rx, n->ry));\n      q.push(new Node(f[n->lx + 1][n->ly] != '#' ? n->lx + 1 : n->lx, n->ly,\n\t\t      f[n->rx - 1][n->ry] != '#' ? n->rx - 1 : n->rx, n->ry));\n      q.push(new Node(n->lx, f[n->lx][n->ly + 1] != '#' ? n->ly + 1 : n->ly,\n\t\t      n->rx, f[n->rx][n->ry + 1] != '#' ? n->ry + 1 : n->ry));\n\n      delete n;\n    }\n\n    if (q.empty()) {\n      cout << \"No\" << endl;\n    } else {\n      while (!q.empty()) {\n\tdelete q.front();\n\tq.pop();\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <tuple>\n#include <string>\n#include <cstring>\n#include <iostream>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nconst int dx1[4] = { 0, 1, 0, -1 };\nconst int dy1[4] = { -1, 0, 1, 0 };\nconst int dx2[4] = { 0, -1, 0, 1 };\nconst int dy2[4] = { -1, 0, 1, 0 };\n\nint H, W; string L[50], R[50];\n\nbool used[50][50][50][50];\n\nbool over(int x, int y)\n{\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\nbool solve(int x1, int y1, int x2, int y2)\n{\n\tqueue<tuple<int, int, int, int> > que;\n\n\tque.push(make_tuple(y1, x1, y2, x2));\n\n\tused[y1][x1][y2][x2] = true;\n\n\twhile (!que.empty())\n\t{\n\t\tint ly = get<0>(que.front());\n\t\tint lx = get<1>(que.front());\n\t\tint ry = get<2>(que.front());\n\t\tint rx = get<3>(que.front());\n\n\t\tif (L[ly][lx] == '%' && R[ry][rx] == '%') return true;\n\n\t\tif (L[ly][lx] == '%') continue;\n\t\tif (R[ry][rx] == '%') continue;\n\n\t\tbool ok = false;\n\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\tint ltx = lx + dx1[i];\n\t\t\tint lty = ly + dy1[i];\n\t\t\tint rtx = rx + dx2[i];\n\t\t\tint rty = ry + dy2[i];\n\n\t\t\tif (over(ltx, lty) && over(rtx, rty))\n\t\t\t{\n\t\t\t\tif (L[lty][ltx] == '#')\n\t\t\t\t{\n\t\t\t\t\tltx -= dx1[i];\n\t\t\t\t\tlty -= dy1[i];\n\t\t\t\t}\n\n\t\t\t\tif (R[rty][rtx] == '#')\n\t\t\t\t{\n\t\t\t\t\trtx -= dx2[i];\n\t\t\t\t\trty -= dy2[i];\n\t\t\t\t}\n\n\t\t\t\tif (!used[lty][ltx][rty][rtx])\n\t\t\t\t{\n\t\t\t\t\tused[lty][ltx][rty][rtx] = true;\n\n\t\t\t\t\tque.push(make_tuple(lty, ltx, rty, rtx));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &W);\n\t\tscanf(\"%d\", &H);\n\n\t\tif (W == 0 && H == 0) break;\n\n\t\tfor (int i = 0; i < H; i++) cin >> L[i] >> R[i];\n\n\t\tint lx, ly, rx, ry;\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (L[i][j] == 'L')\n\t\t\t\t{\n\t\t\t\t\tlx = j;\n\t\t\t\t\tly = i;\n\t\t\t\t}\n\n\t\t\t\tif (R[i][j] == 'R')\n\t\t\t\t{\n\t\t\t\t\trx = j;\n\t\t\t\t\try = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(used, false, sizeof(used));\n\n\t\tprintf(\"%s\\n\", solve(lx, ly, rx, ry) ? \"Yes\" : \"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<utility>\n#include<queue>\nusing namespace std;\ntypedef struct P{int rh,rw,lh,lw,d;}P;\nstruct Order{bool operator ()(P const&a, P const&b) const{return a.d>b.d;}};\n\nint W,H,i,j,rh,rw,lh,lw,f;\nint rm[4][2]={{0,1},{0,-1},{1,0},{-1,0}};\nint lm[4][2]={{0,-1},{0,1},{1,0},{-1,0}};\nbool dp[55][55][55][55];\nchar M[110][110]={0},t;\n\nint main()\n{\n\tfor(;scanf(\"%d%d\\n\",&W,&H),W;)\n\t{\n\t\tmemset(M,0,sizeof(M));\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(i=1;i<=H;i++)\n\t\t\tfor(j=1;j<=2*W+2;j++)\n\t\t\t{\n\t\t\t\tt=getchar();\n\t\t\t\tif(t=='R'){rh=i;rw=j;t='.';}\n\t\t\t\tif(t=='L'){lh=i;lw=j;t='.';}\n\t\t\t\tM[i][j]=t;\n\t\t\t}\n\t\tpriority_queue<P,vector<P>,Order>Q;\n\t\tP p={rh,rw,lh,lw,0};\n\t\tQ.push(p);\n\t\tfor(f=0;!Q.empty();)\n\t\t{\n\t\t\tp=Q.top();Q.pop();\n\t\t\tif(M[p.rh][p.rw]=='%'&&M[p.lh][p.lw]=='%'){f=1;break;}\n\t\t\tif(M[p.rh][p.rw]=='%'||M[p.lh][p.lw]=='%'||p.d==100)continue;\n\t\t\tfor(i=0;i<4;i++)\n\t\t\t{\n\t\t\t\tP ins={p.rh,p.rw,p.lh,p.lw,p.d+1};\n\t\t\t\tif(M[p.rh+rm[i][0]][p.rw+rm[i][1]]=='.'||M[p.rh+rm[i][0]][p.rw+rm[i][1]]=='%'){ins.rh+=rm[i][0];ins.rw+=rm[i][1];}\n\t\t\t\tif(M[p.lh+lm[i][0]][p.lw+lm[i][1]]=='.'||M[p.lh+lm[i][0]][p.lw+lm[i][1]]=='%'){ins.lh+=lm[i][0];ins.lw+=lm[i][1];}\n\t\t\t\tif(!dp[ins.rh][ins.rw][ins.lh][ins.lw-W-1])\n\t\t\t\t{\n\t\t\t\t\tdp[ins.rh][ins.rw][ins.lh][ins.lw-W-1]=1;\n\t\t\t\t\tQ.push(ins);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(f?\"Yes\":\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\nusing lint = long long;\nusing ldouble = long double;\n\nconst int dx[4] = {-1, 0, 0, 1}, dy[4] = {0, -1, 1, 0};\n\nbool solve() {\n    int H, W;\n    cin >> W >> H;\n    if (W == 0) return false;\n\n    vector<string> L(H), R(H);\n    for (int x = 0; x < H; ++x) {\n        cin >> L[x] >> R[x];\n        reverse(R[x].begin(), R[x].end());\n    }\n\n    int lsx, lsy, rsx, rsy;\n    for (int x = 0; x < H; ++x) {\n        for (int y = 0; y < W; ++y) {\n            if (L[x][y] == 'L') lsx = x, lsy = y;\n            if (R[x][y] == 'R') rsx = x, rsy = y;\n        }\n    }\n\n    vector<vector<vector<vector<bool>>>> visited(H);\n    for (auto& v1 : visited) {\n        v1.resize(W);\n        for (auto& v2 : v1) {\n            v2.resize(H);\n            for (auto& v3 : v2) {\n                v3.assign(W, false);\n            }\n        }\n    }\n\n    queue<tuple<int, int, int, int>> que;\n    que.emplace(lsx, lsy, rsx, rsy);\n    visited[lsx][lsy][rsx][rsy] = true;\n\n    bool judge = false;\n    while (!que.empty()) {\n        int lx, ly, rx, ry;\n        tie(lx, ly, rx, ry) = que.front();\n        que.pop();\n\n        bool l = (L[lx][ly] == '%');\n        bool r = (R[rx][ry] == '%');\n        if (l && r) {\n            judge = true;\n            break;\n        }\n        if (l || r) continue;\n\n        for (int i = 0; i < 4; ++i) {\n            int lnx = lx + dx[i];\n            int lny = ly + dy[i];\n            if (lnx < 0 || H <= lnx || lny < 0 || W <= lny ||\n                L[lnx][lny] == '#') lnx = lx, lny = ly;\n\n            int rnx = rx + dx[i];\n            int rny = ry + dy[i];\n            if (rnx < 0 || H <= rnx || rny < 0 || W <= rny ||\n                R[rnx][rny] == '#') rnx = rx, rny = ry;\n\n            if (visited[lnx][lny][rnx][rny]) continue;\n            visited[lnx][lny][rnx][rny] = true;\n            que.emplace(lnx, lny, rnx, rny);\n        }\n    }\n\n    cout << (judge ? \"Yes\" : \"No\") << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nstring ans;\nint h,w;\n//         l r d u\nint Rx[4]={0,0,1,-1};\nint Ry[4]={1,-1,0,0};\n//         r l d u\nint Lx[4]={0,0,1,-1};\nint Ly[4]={-1,1,0,0};\n\nchar RenR[50][50],LinR[50][50];\nbool memo[50][50][50][50];\n\nvoid move(int muki,int ri,int rj,int li,int lj)\n{\n  //cout<<ri<<\" \"<<rj<<\" \"<<li<<\" \"<<lj<<endl;\n  int ra=ri+Rx[muki],rb=rj+Ry[muki];\n  if(0<=ra && 0<=rb && ra<h && rb<w){\n    if(RenR[ra][rb]!='#'){\n      ri=ra;\n      rj=rb;\n    }\n  }\n  int la=li+Lx[muki],lb=lj+Ly[muki];\n  if(0<=la && 0<=lb && la<h && lb<w){\n    if(LinR[la][lb]!='#'){\n      li=la;\n      lj=lb;\n    }\n  }\n  if(memo[ri][rj][li][lj])return;\n  memo[ri][rj][li][lj]=true;\n  if(RenR[ri][rj]=='%' && LinR[li][lj]=='%'){\n    ans=\"Yes\";\n    return;\n  }\n  if(RenR[ri][rj]=='%' || LinR[li][lj]=='%')return;\n\n  for(int k=0;k<4;k++){\n    move(k,ri,rj,li,lj);\n  }\n}\n\nint main()\n{\n  int ri,rj,li,lj;\n  while(1){\n    cin>>w>>h;\n    if(w+h==0)break;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tfor(int k=0;k<h;k++){\n\t  for(int l=0;l<w;l++)memo[i][j][k][l]=false;\n\t}\n      }\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>LinR[i][j];\n\tif(LinR[i][j]=='L'){\n\t  li=i;lj=j;\n\t  LinR[i][j]='.';\n\t}\n      }\n      for(int j=0;j<w;j++){\n\tcin>>RenR[i][j];\n\tif(RenR[i][j]=='R'){\n\t  ri=i;rj=j;\n\t  RenR[i][j]='.';\n\t}\n      }\n    }\n    ans=\"No\";\n    memo[ri][rj][li][lj]=true;\n    for(int i=0;i<4;i++){\n      move(i,ri,rj,li,lj);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstring>\n#include<queue>\n#include<tuple>\n#include<stack>\n#include<cstdio>\n#include<iomanip>\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<string> vs;\nDef inf = sizeof(Def) == sizeof(ll) ?2e18:1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint d[52][52][52][52];\ntypedef tuple<int,int,int,int>tp;\nvs a,b;\nint n,m;\nint f(int x1,int y1,int x2,int y2){\n  //    cout<<x1<<\" \"<<y1<<\" \"<<x2<<\" \"<<y2<<endl;\n\n  priority_queue<tp>q;\n  q.push(tp{x1,y1,x2,y2});\n  while(!q.empty()){ \n    int x1,y1,x2,y2;\n    tie(x1,y1,x2,y2)=q.top();\n    q.pop();\n    rep(i,4){\n  \n      int nx1=x1+dx[i];\n      int ny1=y1+dy[i];\n      int nx2=x2+dx[i];\n      int ny2=y2+dy[(2+i)%4];\n      if(nx1<0||ny1<0||nx1>=n||ny1>=m){\n\tnx1-=dx[i];\n\tny1-=dy[(i)%4];\n      }\n      if(nx2<0||ny2<0||nx2>=n||ny2>=m){\n\tnx2-=dx[i];\n\tny2-=dy[(i+2)%4];\n      }\n      if(a[nx1][ny1]=='#'){\n\tnx1-=dx[i];\n\tny1-=dy[i];\n      }\n      if(b[nx2][ny2]=='#'){\n\tnx2-=dx[i];\n\tny2-=dy[(i+2)%4];\n      }\n      bool A=a[nx1][ny1]=='%';\n      bool B=b[nx2][ny2]=='%';\n      if(A&&!B||!A&&B)continue;\n      if(d[nx1][ny1][nx2][ny2])continue;\n      // cout<<nx1<<\" \"<<ny1<<\" \"<<nx2<<\" \"<<ny2<<endl;\n      d[nx1][ny1][nx2][ny2]=1;\n      q.push(tp{nx1,ny1,nx2,ny2});//f(nx1,ny1,nx2,ny2);\n    }\n  }\n}\nint main(){\n  while(cin>>m>>n,n){\n    rep(i,52)rep(j,52)rep(k,52)rep(l,52)\n      d[i][j][k][l]=0;\n    a=b=vs(n);\n    rep(i,n)cin>>a[i]>>b[i];\n    rep(i,n)rep(j,m)rep(k,n)rep(l,m)if(a[i][j]=='L'&&b[k][l]=='R'){\n      d[i][j][k][l]=1;\n      f(i,j,k,l);\n    }\n    rep(i,n)rep(j,m)rep(k,n)rep(l,m)if(a[i][j]=='%'&&b[k][l]=='%'){\n      if(d[i][j][k][l])cout<<\"YES\"<<endl;\n      else cout<<\"NO\"<<endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<pair<int, int>, pair<int, int>> PPIIII;\n\nint dx[] = { 1,0,-1,0 };\nint dy[] = { 0,1,0,-1 };\n\nvoid solve( int W, int H ) {\n\tpair<int, int> startR, startL, goalR, goalL;\n\tvector<vector<vector<vector<bool>>>>dp( H + 2, vector<vector<vector<bool>>>( W + 2, vector<vector<bool>>( H + 2, vector<bool>( W + 2, 0 ) ) ) );\n\tvector<vector<vector<char>>>mapd( 2, vector<vector<char>>( H + 2, vector<char>( W + 2, '#' ) ) );\n\tfor( size_t i = 1; i <= H; i++ ) {\n\t\tfor( size_t j = 1; j <= W; j++ ) {\n\t\t\tcin >> mapd[0][i][j];\n\t\t\tif( mapd[0][i][j] == 'L' ) {\n\t\t\t\tstartL = make_pair( i, j );\n\t\t\t} else if( mapd[0][i][j] == '%' ) {\n\t\t\t\tgoalL = make_pair( i, j );\n\t\t\t}\n\t\t}\n\t\tfor( int j = W; j >= 1; j-- ) {\n\t\t\tcin >> mapd[1][i][j];\n\t\t\tif( mapd[1][i][j] == 'R' ) {\n\t\t\t\tstartR = make_pair( i, j );\n\t\t\t} else if( mapd[1][i][j] == '%' ) {\n\t\t\t\tgoalR = make_pair( i, j );\n\t\t\t}\n\t\t}\n\t}\n\tdp[startL.first][startL.second][startR.first][startR.second] = 1;\n\n\n\tqueue<PPIIII>que;\n\tque.push( make_pair( startL, startR ) );\n\twhile( que.size() ) {\n\t\tauto now = que.front(); que.pop();\n\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\tauto next = now;\n\t\t\tnext.first.first += dx[i];\n\t\t\tnext.first.second += dy[i];\n\t\t\tnext.second.first += dx[i];\n\t\t\tnext.second.second += dy[i];\n\t\t\tif( mapd[0][next.first.first][next.first.second] == '#' ) {\n\t\t\t\tnext.first = now.first;\n\t\t\t}\n\t\t\tif( mapd[1][next.second.first][next.second.second] == '#' ) {\n\t\t\t\tnext.second = now.second;\n\t\t\t}\n\n\t\t\tif( 0 < next.first.first&&next.first.first < H + 2 &&\n\t\t\t\t0 < next.first.second&&next.first.second < W + 2 &&\n\t\t\t\t0 < next.second.first&&next.second.first < H + 2 &&\n\t\t\t\t0 < next.second.second&&next.second.second < W + 2 ) {\n\t\t\t\tif( dp[next.first.first][next.first.second][next.second.first][next.second.second] == 0 ) {\n\t\t\t\t\tif( goalL == next.first&&goalR == next.second ) {\n\t\t\t\t\t\tif( dx[i] != 0 && dy[0] != 0 ) {\n\t\t\t\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdp[next.first.first][next.first.second][next.second.first][next.second.second] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tque.push( next );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"No\" << endl;\n\treturn;\n}\n\nint main() {\n\tint W, H;\n\twhile( cin >> W >> H, W&&H ) {\n\t\tsolve( W, H );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntypedef double weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\ntypedef vector<vector<edge>> Graph;\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nbool used[51][51][51][51];\n\nint main()\n{\n\tint h, w;\n\twhile (cin >> w >> h, w)\n\t{\n\t\tvs fld1(h), fld2(h);\n\t\tREP(i, h) cin >> fld1[i] >> fld2[i];\n\t\tpii sa, sb, ga, gb;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld1[i][j] == 'L') sa = pii(i, j);\n\t\t\tif (fld2[i][j] == 'R') sb = pii(i, j);\n\t\t\tif (fld1[i][j] == '%') ga = pii(i, j);\n\t\t\tif (fld2[i][j] == '%') gb = pii(i, j);\n\t\t}\n\t\ttypedef pair<pii, pii> data;\n//\t\tset<data> st;\n\t\tqueue<data> que;\n\t\tque.push(data(sa, sb));\n\t\tdata goal = data(ga, gb);\n\t\tMS(used, false);\n\t\twhile (que.size())\n\t\t{\n\t\t\tdata tmp = que.front();\n\t\t\tque.pop();\n\t\t\tint lx = tmp.first.first, ly = tmp.first.second;\n\t\t\tint rx = tmp.second.first, ry = tmp.second.second;\n\t\t\tREP(i, 4)\n\t\t\t{\n\t\t\t\tint lnx = lx + dx[i], lny = ly + dy[i];\n\t\t\t\tint rnx = rx + dx[i], rny = ry - dy[i];\n\t\t\t\tif (!valid(lnx, lny, h, w) || fld1[lnx][lny]=='#')\n\t\t\t\t{\n\t\t\t\t\tlnx = lx, lny = ly;\n\t\t\t\t}\t\t\t\t\n\t\t\t\tif (!valid(rnx, rny, h, w) || fld2[rnx][rny] == '#')\n\t\t\t\t{\n\t\t\t\t\trnx = rx, rny = ry;\n\t\t\t\t}\n\t\t\t\tpii nl(lnx, lny), nr(rnx, rny);\n\t\t\t\tdata next = data(nl, nr);\n\t\t\t\tif (next != goal && (nl == ga || nr == gb)) continue;\n//\t\t\t\tif (st.find(next) != st.end()) continue;\n//\t\t\t\tst.insert(next);\n\t\t\t\tif (used[lnx][lny][rnx][rny]) continue;\n\t\t\t\tused[lnx][lny][rnx][rny] = true;\n\t\t\t\tif (next == goal) goto end;\n\t\t\t\tque.push(next);\n\t\t\t}\n\t\t}\n\tend:;\n//\t\tif (st.find(goal) == st.end()) puts(\"No\");\n\t\tif (used[ga.first][ga.second][gb.first][gb.second]) puts(\"Yes\");\n\t\telse puts(\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define abs(a) max((a),-(a))\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define repe(i,n) rep(i,(n)+1)\n#define per(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define pere(i,n) rep(i,(n)+1)\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define RET return 0\n#define MOD 1000000007\n#define INF 1000000000000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nbool ok[50][50][50][50];\nint main(){\n  while(1){\n    int h,w;\n    cin >> w >> h;\n    if(h==0) return 0;\n    vector<string> l(h),r(h);\n    for(int i=0;i<h;i++) cin >> l[i] >> r[i];\n    for(int i=0;i<h;i++) reverse(all(r[i]));\n    int lsx,lsy,lgx,lgy,rsx,rsy,rgx,rgy;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        if(l[i][j]=='L'){\n          lsy=i,lsx=j;\n          l[i][j]='.';\n        }else if(l[i][j]=='%'){\n          lgy=i,lgx=j;\n          l[i][j]='.';\n        }\n        if(r[i][j]=='R'){\n          rsy=i,rsx=j;\n          l[i][j]='.';\n        }else if(r[i][j]=='%'){\n          rgy=i,rgx=j;\n          r[i][j]='.';\n        }\n      }\n    }\n    queue<pair<pair<int,int>,pair<int,int>>> bfs;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        for(int k=0;k<h;k++){\n          for(int l=0;l<w;l++){\n            ok[i][j][k][l]=false;\n          }\n        }\n      }\n    }\n    bfs.push({{lsx,lsy},{rsx,rsy}});\n    ok[lsy][lsx][rsy][rsx]=true;\n    vector<int> vx={1,0,-1,0},vy={0,-1,0,1};\n    int lnx,lny,rnx,rny;\n    pair<pair<int,int>,pair<int,int>> now;\n    while(!bfs.empty()){\n      now=bfs.front();\n      bfs.pop();\n      for(int i=0;i<4;i++){\n        lnx=now.first.first+vx[i];\n        lny=now.first.second+vy[i];\n        rnx=now.second.first+vx[i];\n        rny=now.second.second+vy[i];\n        if(0<=lnx&&lnx<w&&0<=lny&&lny<h){\n          if(l[lny][lnx]=='#'){\n            lnx=now.first.first;\n            lny=now.first.second;\n          }\n        }else{\n          lnx=now.first.first;\n          lny=now.first.second;\n        }\n        if(0<=rnx&&rnx<w&&0<=rny&&rny<h){\n          if(r[rny][rnx]=='#'){\n            rnx=now.first.first;\n            rny=now.first.second;\n          }\n        }else{\n          rnx=now.first.first;\n          rny=now.first.second;\n        }\n        if(!ok[lny][lnx][rny][rnx]){\n          ok[lny][lnx][rny][rnx]=true;\n          if(!(lnx==lgx&&lny==lgy)&&!(rnx==rgx&&rny==rgy)) bfs.push({{lnx,lny},{rnx,rny}});\n        }\n      }\n    }\n    if(ok[lgy][lgx][rgy][rgx]) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nstring ans;\nint h,w;\n//         l r d u\nint Rx[4]={0,0,1,-1};\nint Ry[4]={1,-1,0,0};\n//         r l d u\nint Lx[4]={0,0,1,-1};\nint Ly[4]={-1,1,0,0};\n\nchar RenR[50][50],LinR[50][50];\nbool RenRb[50][50],LinRb[50][50];\n\nvoid move(int muki,int ri,int rj,int li,int lj)\n{\n  //  cout<<ri<<\" \"<<rj<<\" \"<<li<<\" \"<<lj<<endl;\n  int ra=ri+Rx[muki],rb=rj+Ry[muki];\n  if(0<=ra && 0<=rb && ra<h && rb<w){\n    if(RenR[ra][rb]!='#'){\n      ri=ra;\n      rj=rb;\n    }\n  }\n  int la=li+Lx[muki],lb=lj+Ly[muki];\n  if(0<=la && 0<=lb && la<h && lb<w){\n    if(LinR[la][lb]!='#'){\n      li=la;\n      lj=lb;\n    }\n  }\n  if(RenRb[ri][rj] && LinRb[li][lj])return;\n\n  RenRb[ri][rj]=true;\n  LinRb[li][lj]=true;\n  if(RenR[ri][rj]=='%' && LinR[li][lj]=='%'){\n    ans=\"Yes\";\n    return;\n  }\n  if(RenR[ri][rj]=='%' || LinR[li][lj]=='%')return;\n\n  for(int k=0;k<4;k++){\n    move(k,ri,rj,li,lj);\n  }\n  /*RenRb[ri][rj]=false;\n    LinRb[li][lj]=false;*/\n}\n\nint main()\n{\n  int ri,rj,li,lj;\n  while(1){\n    cin>>w>>h;\n    if(w+h==0)break;\n    \n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>LinR[i][j];\n\tLinRb[i][j]=false;\n\tif(LinR[i][j]=='L'){\n\t  li=i;lj=j;\n\t  LinR[i][j]='.';\n\t  LinRb[i][j]=true;\n\t}\n      }\n      for(int j=0;j<w;j++){\n\tcin>>RenR[i][j];\n\tRenRb[i][j]=false;\n\tif(RenR[i][j]=='R'){\n\t  ri=i;rj=j;\n\t  RenR[i][j]='.';\n\t  RenRb[i][j]=true;\n\t}\n      }\n    }\n\n    ans=\"No\";\n    for(int i=0;i<4;i++){\n      move(i,ri,rj,li,lj);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nstruct Node {\n  Node(int lx, int ly, int rx, int ry) {\n    this->lx = lx;\n    this->ly = ly;\n    this->rx = rx;\n    this->ry = ry;\n  }\n\n  int val() {\n    return lx * 8000000 + ly * 40000 + rx * 200 + ry;\n  }\n\n  int lx;\n  int ly;\n  int rx;\n  int ry;\n};\n\nint main() {\n  vector<vector<char> > f(103);\n  for (int i = 0; i < f.size(); i++) {\n    f[i].resize(52);\n  }\n\n  while (true) {\n    int W, H;\n    cin >> W >> H;\n\n    if (W == 0) {\n      break;\n    }\n\n    int cw = W + 1;\n    int w = W * 2 + 3;\n    int h = H + 2;\n    for (int i = 0; i < w; i++) {\n      f[i][0] = f[i][h - 1] = '#';\n    }\n    for (int i = 0; i < h; i++) {\n      f[0][i] = f[cw][i] = f[w - 1][i] = '#';\n    }\n\n    int lx = 0, ly = 0;\n    int rx = 0, ry = 0;\n    for (int i = 1; i < h - 1; i++) {\n      for (int j = 1; j < cw; j++) {\n\tcin >> f[j][i];\n\tif (f[j][i] == 'L') {\n\t  lx = j;\n\t  ly = i;\n\t  f[j][i] = '.';\n\t}\n      }\n      for (int j = cw + 1; j < w - 1; j++) {\n\tcin >> f[j][i];\n\tif (f[j][i] == 'R') {\n\t  rx = j;\n\t  ry = i;\n\t  f[j][i] = '.';\n\t}\n      }\n    }\n    \n    set<int> s;\n    queue<Node> q;\n    q.push(Node(lx, ly, rx, ry));\n    s.insert(q.front().val());\n    while (!q.empty()) {\n      Node n = q.front();\n      /*\n      for (int i = 0; i < h; i++) {\n\tfor (int j = 0; j < w; j++) {\n\t  cout << (n.lx == j && n.ly == i ? 'L' :\n\t\t   n.rx == j && n.ry == i ? 'R' : f[j][i]);\n\t}\n\tcout << endl;\n      }\n      */\n      if (f[n.lx][n.ly] == '%' && f[n.rx][n.ry] == '%') {\n\tcout << \"Yes\" << endl;\n\tbreak;\n      }\n      q.pop();\n\n      if (f[n.lx][n.ly] == '%' || f[n.rx][n.ry] == '%') {\n\tcontinue;\n      }\n\n      Node nn(n.lx, f[n.lx][n.ly - 1] != '#' ? n.ly - 1 : n.ly,\n\t      n.rx, f[n.rx][n.ry - 1] != '#' ? n.ry - 1 : n.ry);\n\n      if (s.count(nn.val()) == 0) {\n\tq.push(nn);\n\ts.insert(nn.val());\n      }\n\n      Node we(f[n.lx - 1][n.ly] != '#' ? n.lx - 1 : n.lx, n.ly,\n\t      f[n.rx + 1][n.ry] != '#' ? n.rx + 1 : n.rx, n.ry);\n\n      if (s.count(we.val()) == 0) {\n\tq.push(we);\n\ts.insert(we.val());\n      }\n\n      Node ew(f[n.lx + 1][n.ly] != '#' ? n.lx + 1 : n.lx, n.ly,\n\t      f[n.rx - 1][n.ry] != '#' ? n.rx - 1 : n.rx, n.ry);\n\n      if (s.count(ew.val()) == 0) {\n\tq.push(ew);\n\ts.insert(ew.val());\n      }\n\n      Node ss(n.lx, f[n.lx][n.ly + 1] != '#' ? n.ly + 1 : n.ly,\n\t      n.rx, f[n.rx][n.ry + 1] != '#' ? n.ry + 1 : n.ry);\n\n      if (s.count(ss.val()) == 0) {\n\tq.push(ss);\n\ts.insert(ss.val());\n      }\n    }\n\n    if (q.empty()) {\n      cout << \"No\" << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp make_pair\n#define pb push_back\n#define F first\n#define S second\n\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nbool app[50][50][50][50];\n\nmain(){\n  int w,h;\n  while(cin>>w>>h,w|h){\n    memset(app,0,6250000);\n    string lr[h],rr[h];\n    rep(i,h){\n      cin>>lr[i]>>rr[i];\n    }\n\n    string ans=\"No\";\n    int rsx,rsy,lsx,lsy;\n    rep(i,h)rep(j,w){\n      if(lr[i][j]=='L')lsx=i,lsy=j;\n      if(rr[i][j]=='R')rsx=i,rsy=j;\n    }\n\n    queue<pair<PI,PI> > Q;\n    Q.push(mp(mp(lsx,lsy),mp(rsx,rsy)));\n\n    while(!Q.empty()){\n      PI tp=Q.front().F;\n      int clx,cly,crx,cry;\n      clx=tp.F,cly=tp.S;\n      tp=Q.front().S;Q.pop();\n      crx=tp.F,cry=tp.S;\n      if(lr[clx][cly]=='%' && rr[crx][cry]=='%'){\n        ans=\"Yes\";\n        break;\n      }\n      if(lr[clx][cly]=='%' || rr[crx][cry]=='%')continue;\n      app[clx][cly][crx][cry]=true;\n\n      rep(i,4){\n        int nrx=crx+dx[i],nlx=clx+dx[i],nry=cry+dy[i],nly=cly-dy[i];\n        if(nrx<0 || nry<0 || nrx>=h || nry>=w || rr[nrx][nry]=='#')nrx=crx,nry=cry;\n        if(nlx<0 || nly<0 || nlx>=h || nly>=w || lr[nlx][nly]=='#')nlx=clx,nly=cly;\n        if(app[nlx][nly][nrx][nry])continue;\n        app[nlx][nly][nrx][nry]=true;\n        Q.push(mp(mp(nlx,nly),mp(nrx,nry)));\n      }\n/*      \n      rep(i,h){\n        rep(j,w){\n          if(clx==i && cly==j)cout<<'L';\n          else if(lr[i][j]=='L')cout<<'.';\n          else cout<<lr[i][j];\n        }\n        cout<<\" \";\n        rep(j,w){\n          if(crx==i && cry==j)cout<<'R';\n          else if(rr[i][j]=='R')cout<<'.';\n          else cout<<rr[i][j];\n        }\n        cout<<endl;\n      }\n      cout<<endl;\n*/\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/* 44 - 01*/\n\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++) \n\nint dx[] =  { 0, 0,-1, 1};\nint dy[] =  { 1,-1, 0, 0};\nint dx2[] = { 0, 0, 1,-1};\nint dy2[] = { 1,-1, 0, 0};\n\nclass NODE{\npublic:\n\tint x1;\n\tint y1;\n\tint x2;\n\tint y2;\n\tint depth;\n};\n\nbool done[52][52][52][52];\n\nint main(){\n\tint X,Y,tx,ty,kx,ky;\n\tchar data[2][52][52];\n\twhile(cin >> X >> Y , X){\n\t\trep(k,2)rep(i,52)rep(j,52)data[k][i][j] = '#';\n\t\tvector<string> vec[2];\n\t\tvec[0].resize(Y);vec[1].resize(Y);\n\t\trep(i,Y)cin >> vec[0][i] >> vec[1][i] ;\n\t\t\n\t\trep(i,Y)rep(j,X){\n\t\t\tchar c = vec[0][i][j];\n\t\t\tif(c == 'L')tx = 1+j , ty = i+1;\n\t\t\tdata[0][1+i][1+j] = c;\n\t\t}\n\t\t\n\t\trep(i,Y){\n\t\t\trep(j,X){\n\t\t\t\tchar c = vec[1][i][j];\n\t\t\t\tif(c == 'R')kx = 1+j , ky = i+1;\n\t\t\t\tdata[1][1+i][1+j] = c;\n\t\t\t}\n\t\t}\n\t\tqueue<NODE> Q;\n\t\tNODE t = {tx,ty,kx,ky,0};\n\t\t\n\t\trep(i,52)rep(j,52)rep(k,52)rep(l,52)done[i][j][k][l] = false;\n\t\t\n\t\tQ.push(t);\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.front();Q.pop();\n\t\t\t//if(q.depth >= 100)continue;\n\t\t\tif( done[q.x1][q.y1][q.x2][q.y2] )continue;\n\t\t\tdone[q.x1][q.y1][q.x2][q.y2] = true;\n\t\t\t\n\t\t\tif(data[0][q.y1][q.x1] == '%' || data[1][q.y2][q.x2] == '%'){\n\t\t\t\tif(data[0][q.y1][q.x1] == '%' && data[1][q.y2][q.x2] == '%'){\n\t\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\t\tgoto end;\t\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trep(i,4){\n\t\t\t\tNODE next;\n\t\t\t\tnext.x1 = q.x1 + dx[i];\n\t\t\t\tnext.y1 = q.y1 + dy[i];\n\t\t\t\tnext.x2 = q.x2 + dx2[i];\n\t\t\t\tnext.y2 = q.y2 + dy2[i];\n\t\t\t\tnext.depth = q.depth + 1;\n\t\t\t\tif(data[0][next.y1][next.x1] == '#'){\n\t\t\t\t\tnext.x1 = q.x1;\n\t\t\t\t\tnext.y1 = q.y1;\n\t\t\t\t}\n\t\t\t\tif(data[1][next.y2][next.x2] == '#'){\n\t\t\t\t\tnext.x2 = q.x2;\n\t\t\t\t\tnext.y2 = q.y2;\n\t\t\t\t}\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\t\tcout << \"No\" << endl;\n\t\tend:;\t\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define pb push_back\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nconst P dx[4] = {P(0,0),P(0,0),P(-1,1),P(1,-1)};\nconst P dy[4] = {P(1,1),P(-1,-1),P(0,0),P(0,0)};\nbool bmap[55][55][55][55];\nint main(){\n  int H,W;\n  while(cin >> W >> H && H+W){\n    char L_cmap[H+1][W+1],R_cmap[H+1][W+1];\n   \n    P Ls,Rs,Lg,Rg;\n    rep(i,H){\n      rep(j,W){\n        rep(k,H){\n\t  rep(l,W){\n\t    bmap[i][j][k][l] = false;\n\t  }\n\t}\n      }\n    }\n\n    rep(i,H){\n      string s;\n      cin >> s;\n      rep(j,W){\n\tL_cmap[i][j] = s[j];\n\tif(s[j] == 'L')Ls = P(j,i);\n\tif(s[j] == '%')Lg = P(j,i);\n      }\n      cin >> s;\n      rep(j,W){\n\tR_cmap[i][j] = s[j];\n\tif(s[j] == 'R')Rs = P(j,i);\n\tif(s[j] == '%')Rg = P(j,i);\n      }\n    }\n\n    queue<PP> que;\n    que.push(PP(Ls,Rs));\n    bmap[Ls.F][Ls.S][Rs.F][Rs.S] = true;\n    bool fin = false;\n    while(!que.empty())\n      {\n\tPP pp = que.front(); que.pop();\n\tif(pp.F == Lg && pp.S == Rg){\n\t  fin = true;\n\t  cout << \"Yes\" << endl;\n\t  break;\n\t}\n\tif(pp.F == Lg || pp.S == Rg)continue;\n\n\trep(i,4){\n\t  int L_nx = pp.F.F+dx[i].F,L_ny = pp.F.S+dy[i].F;\n\t  int R_nx = pp.S.F+dx[i].S,R_ny = pp.S.S+dy[i].S;\n\t  if(!(0<= L_nx & L_nx < W && 0<= L_ny && L_ny < H) || L_cmap[L_ny][L_nx] == '#'){\n\t    L_nx = pp.F.F,L_ny = pp.F.S;\n\t  }\n\t  if(!(0<= R_nx & R_nx < W && 0<= R_ny && R_ny < H) || R_cmap[R_ny][R_nx] == '#'){\n\t    R_nx = pp.S.F,R_ny = pp.S.S;\n\t  }\n\t  if(bmap[L_nx][L_ny][R_nx][R_ny])continue;\n\t  bmap[L_nx][L_ny][R_nx][R_ny] = true;\n\t \n\t  que.push(insert(L_nx,L_ny,R_nx,R_ny));\n\t}\n      }\n    if(!fin)cout << \"No\" << endl;\n    \n  }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\nconst int size = 51;\nint n, m;\nbool OL[size][size];\nbool OR[size][size];\n\ntypedef vector <string> VS;\n\nvoid init() {\n    for ( int i = 0; i < size; i++ ) {\n        for ( int j = 0; j < size; j++ ) {\n            OL[i][j] = false;\n            OR[i][j] = false;\n        }\n    }\n}\n\n/*\n. : ©RÉÚ®Å«éZ\n# : ÇÌ éZiiüÅ«È¢j\n% : ÚIn\nR : Rin ÌúÊu\nL : Len ÌúÊu\n*/\n\ntypedef pair <int, int> PII;\ntypedef pair <PII, PII> Node;\ntypedef queue <Node> Queue;\n\nint srL, scL, srR, scR;\nint grL, gcL, grR, gcR;\nconst int dr[4] = { 0, 0, 1, -1 };\nconst int dc[4] = { 1, -1, 0, 0 };\nbool used[size][size][size][size];\n\nbool bad( int r, int c ) {\n    return r < 0 || r >= m || c < 0 || c >= n;\n}\n\nbool solve() {\n    Queue Q;\n    Node start( PII( srL, scL ), PII( srR, scR ) );\n    Q.push( start );\n\n    for ( int i = 0; i < m; i++ ) {\n        for ( int j = 0; j < n; j++ ) {\n            for ( int k = 0; k < m; k++ ) {\n                for ( int l = 0; l < n; l++ ) {\n                    used[i][j][k][l] = false;\n                }\n            }\n        }\n    }\n\n    while ( !Q.empty() ) {\n        Node node = Q.front();\n        Q.pop();\n\n        int rL = node.first.first;\n        int cL = node.first.second;\n        int rR = node.second.first;\n        int cR = node.second.second;\n\n        if ( rL == grL && cL == gcL && rR == grR && cR == gcR ) {\n            return true;\n        }\n\n        for ( int k = 0; k < 4; k++ ) {\n            int nrL = rL + dr[k];\n            int ncL = cL + dc[k];\n            int nrR = rR + dr[k];\n            int ncR = cR - dc[k];\n\n            if ( bad( nrL, ncL ) || OL[nrL][ncL] ) {\n                nrL = rL;\n                ncL = cL;\n            }\n            if ( bad( nrR, ncR ) || OR[nrR][ncR] ) {\n                nrR = rR;\n                ncR = cR;\n            }\n\n            if ( used[nrL][ncL][nrR][ncR] ) continue;\n            used[nrL][ncL][nrR][ncR] = true;\n            Node next_node( PII( nrL, ncL ), PII( nrR, ncR ) );\n            Q.push( next_node );\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    while ( cin >> n >> m ) {\n        if ( n == 0 && m == 0 ) break;\n\n        init();\n\n        VS inputL(m), inputR(m);\n        for ( int i = 0; i < m; i++ ) {\n            cin >> inputL[i] >> inputR[i];\n        }\n\n        for ( int i = 0; i < m; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                if ( inputL[i][j] == '#' ) OL[i][j] = true;\n                if ( inputR[i][j] == '#' ) OR[i][j] = true;\n            }\n        }\n\n        for ( int i = 0; i < m; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                if ( inputL[i][j] == 'L' ) {\n                    srL = i;\n                    scL = j;\n                }\n                if ( inputR[i][j] == 'R' ) {\n                    srR = i;\n                    scR = j;\n                }\n                if ( inputL[i][j] == '%' ) {\n                    grL = i;\n                    gcL = j;\n                }\n                if ( inputR[i][j] == '%' ) {\n                    grR = i;\n                    gcR = j;\n                }\n            }\n        }\n\n        cout << ( solve() ? \"Yes\" : \"No\" ) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> pii;\nint W, H;\nint dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\n\nvoid rec(pii &p1, pii &p2, map<pair<pii,pii>,bool> &memo, vector<string> &R1, vector<string> &R2, pii &g1, pii &g2){\n  for(int i = 0; i < 4; ++i){\n    //int x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;\n    pii p1_ = p1, p2_ = p2;\n    if(p1_.first + dx[i] < H && p1_.first + dx[i] >= 0 &&\n       p1_.second + dy[i] < W && p1_.second + dy[i] >= 0 &&\n       R1[p1_.first + dx[i]][p1_.second + dy[i]] != '#'){\n      p1_.first += dx[i];\n      p1_.second += dy[i];\n    }\n    if(p2_.first + dx[i] < H && p2_.first + dx[i] >= 0 &&\n       p2_.second - dy[i] < W && p2_.second - dy[i] >= 0 &&\n       R2[p2_.first + dx[i]][p2_.second - dy[i]] != '#'){\n      p2_.first += dx[i];\n      p2_.second -= dy[i];\n    }\n    if((!memo[make_pair(g1,g2)]) && (!memo[make_pair(p1_,p2_)])){\n      memo[make_pair(p1_,p2_)] = true;\n      rec(p1_,p2_,memo,R1,R2,g1,g2);\n    }\n  }\n}\n\nint main(){\n  while(cin >> W >> H, W){\n    pii s1, s2, g1, g2;\n    vector<string> R1(H), R2(H);\n    for(int i = 0; i < H; ++i){\n      cin >> R1[i] >> R2[i];\n      for(int j = 0; j < W; ++j){\n        if(R1[i][j] == 'L'){\n          s1.first = i;\n          s1.second = j;\n        }\n        if(R2[i][j] == 'R'){\n          s2.first = i;\n          s2.second = j;\n        }\n        if(R1[i][j] == '%'){\n          g1.first = i;\n          g1.second = j;\n        }\n        if(R2[i][j] == '%'){\n          g2.first = i;\n          g2.second = j;\n        }\n      }\n    }\n    map<pair<pii,pii>,bool> memo;\n    rec(s1,s2,memo,R1,R2,g1,g2);\n    //if(memo[gx1][gy1][gx2][gy2]) cout << \"Yes\" << endl;\n    if(memo[make_pair(g1,g2)]) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"tune=native\")\n#pragma GCC target (\"avx\")\n\n#include <bits/stdc++.h>\n\n// 汎用マクロ\n#define ALL_OF(x) (x).begin(), (x).end()\n#define REP(i,n) for (long long i=0, i##_len=(n); i<i##_len; i++)\n#define RANGE(i,is,ie) for (long long i=(is), i##_end=(ie); i<=i##_end; i++)\n#define DSRNG(i,is,ie) for (long long i=(is), i##_end=(ie); i>=i##_end; i--)\n#define UNIQUE(v) { sort((v).begin(), (v).end()); (v).erase(unique((v).begin(), (v).end()), (v).end()); }\ntemplate<class T> bool chmax(T &a, const T &b) {if (a < b) {a = b; return 1;} return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) {if (a > b) {a = b; return 1;} return 0; }\n#define INF 0x7FFFFFFF\n#define LINF 0x7FFFFFFFFFFFFFFFLL\n#define Yes(q) (q ? \"Yes\" : \"No\")\n#define YES(q) (q ? \"YES\" : \"NO\")\n#define DUMP(q) cerr << \"[DEBUG] \" #q \": \" << (q) << \" at \" __FILE__ \":\" << __LINE__ << endl\n#define DUMPALL(q) cerr << \"[DEBUG] \" #q \": [\"; REP(dumpall_i, (q).size()) { cerr << q[dumpall_i] << (dumpall_i == (q).size() - 1 ? \"\" : \", \"); } cerr << \"] at \" __FILE__ \":\" << __LINE__ << endl\n\n// gcc拡張マクロ\n#define gcd __gcd\n#define popcount __builtin_popcount\n#define popcountll __builtin_popcountll\n\n// エイリアス\nusing  ll = long long;\nusing ull = unsigned long long;\nusing  ld = long double;\nusing namespace std;\n\n// モジュール\n\n\n// 処理内容\nint main() {\n    \n    ll w, h;\n    while (cin >> w >> h, w && h) {\n\n        vector<string> rl(h), rr(h);\n        REP(i, h) cin >> rl[i] >> rr[i];\n        ll lsy, lsx, rsy, rsx;\n        ll lgy, lgx, rgy, rgx;\n        REP(i, h) REP(j, w) {\n            if (rl[i][j] == '%') {\n                lgy = i;\n                lgx = j;\n            } else if (rl[i][j] == 'L') {\n                lsy = i;\n                lsx = j;\n            }\n            if (rr[i][j] == '%') {\n                rgy = i;\n                rgx = j;\n            } else if (rr[i][j] == 'R') {\n                rsy = i;\n                rsx = j;\n            }\n        }\n\n        // {ly, lx, ry, rx}\n        deque<tuple<ll,ll,ll,ll>> q;\n        vector<vector<vector<vector<bool>>>> visited(h, vector<vector<vector<bool>>>(w, vector<vector<bool>>(h, vector<bool>(w, false))));\n        q.emplace_back(lsy, lsx, rsy, rsx);\n        visited[lsy][lsx][rsy][rsx] = true;\n        while (!q.empty()) {\n\n            ll ly = get<0>(q.front());\n            ll lx = get<1>(q.front());\n            ll ry = get<2>(q.front());\n            ll rx = get<3>(q.front());\n            q.pop_front();\n\n            // Lin and Ren go upward\n            if (ly > 0 && ry > 0) {\n                ll ly2 = rl[ly - 1][lx] != '#' ? ly - 1 : ly;\n                ll lx2 = lx;\n                ll ry2 = rr[ry - 1][lx] != '#' ? ry - 1 : ry;\n                ll rx2 = rx;\n                bool lgoaled = ly2 == lgy && lx2 == lgx;\n                bool rgoaled = ry2 == rgy && rx2 == rgx;\n                if (lgoaled == rgoaled && !visited[ly2][lx2][ry2][rx2]) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n            }\n\n            // Lin and Ren go downward\n            if (ly < h-1 && ry < h-1) {\n                ll ly2 = rl[ly + 1][lx] != '#' ? ly + 1 : ly;\n                ll lx2 = lx;\n                ll ry2 = rr[ry + 1][lx] != '#' ? ry + 1 : ry;\n                ll rx2 = rx;\n                bool lgoaled = ly2 == lgy && lx2 == lgx;\n                bool rgoaled = ry2 == rgy && rx2 == rgx;\n                if (lgoaled == rgoaled && !visited[ly2][lx2][ry2][rx2]) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n            }\n\n            // Lin goes left and Ren goes right\n            if (lx > 0 && rx < w-1) {\n                ll ly2 = ly;\n                ll lx2 = rl[ly][lx - 1] != '#' ? lx - 1 : lx;\n                ll ry2 = ry;\n                ll rx2 = rr[ry][rx + 1] != '#' ? rx + 1 : rx;\n                bool lgoaled = ly2 == lgy && lx2 == lgx;\n                bool rgoaled = ry2 == rgy && rx2 == rgx;\n                if (lgoaled == rgoaled && !visited[ly2][lx2][ry2][rx2]) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n            }\n\n            // Lin goes right and Ren goes left\n            if (lx < w-1 && rx > 0) {\n                ll ly2 = ly;\n                ll lx2 = rl[ly][lx + 1] != '#' ? lx + 1 : lx;\n                ll ry2 = ry;\n                ll rx2 = rr[ry][rx - 1] != '#' ? rx - 1 : rx;\n                bool lgoaled = ly2 == lgy && lx2 == lgx;\n                bool rgoaled = ry2 == rgy && rx2 == rgx;\n                if (lgoaled == rgoaled && !visited[ly2][lx2][ry2][rx2]) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n            }\n\n        }\n\n        std::cout << Yes(visited[lgy][lgx][rgy][rgx]) << endl;\n\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <utility>\n#include <cstring>\n\nusing namespace std;\n\nconst int dx[] = { -1, 0, 1, 0 };\nconst int dy[] = { 0, -1, 0, 1 };\n\nvector<string> field;\nint W, H;\nunsigned char memo[52][52][52][52];\n\nint recur(int rx, int ry, int lx, int ly){\n\tif(memo[rx - W - 1][ry][lx][ly]){ return 0; }\n\tmemo[rx - W - 1][ry][lx][ly] = 1;\n\tif(rx == lx && ry == ly){ return 0; }\n\tif(field[ry][rx] == '%' && field[ly][lx] == '%'){ return 1; }\n\tint answer = 0;\n\tfor(int i = 0; answer == 0 && i < 4; ++i){\n\t\tint nrx = rx + dx[i], nry = ry + dy[i];\n\t\tint nlx = lx - dx[i], nly = ly + dy[i];\n\t\tif(field[nry][nrx] == '#'){ nrx -= dx[i]; nry -= dy[i]; }\n\t\tif(field[nly][nlx] == '#'){ nlx += dx[i]; nly -= dy[i]; }\n\t\tanswer = recur(nrx, nry, nlx, nly);\n\t}\n\treturn answer;\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> W >> H;\n\t\tif(W == 0 && H == 0){ break; }\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tfield.resize(H + 2);\n\t\tfield[0] = field[H + 1] = string(W * 2 + 3, '#');\n\t\tint rx, ry, lx, ly;\n\t\tfor(int i = 1; i <= H; ++i){\n\t\t\tstring l1, l2;\n\t\t\tcin >> l1 >> l2;\n\t\t\tstring line = \"#\" + l1 + \"#\" + l2 + \"#\";\n\t\t\tfor(int j = 0; j < line.size(); ++j){\n\t\t\t\tif(line[j] == 'R'){\n\t\t\t\t\trx = j; ry = i;\n\t\t\t\t}else if(line[j] == 'L'){\n\t\t\t\t\tlx = j; ly = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfield[i] = line;\n\t\t}\n\t\tcout << (recur(rx, ry, lx, ly) ? \"Yes\" : \"No\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nint w, h;\nint sly, slx, sry, srx;\nstring s[1000];\nstring t[1000];\nbool f[60][60][60][60];\n\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\n\n//bool solve(int ly, int lx, int ry, int rx) {\n//\tcout << ly << \" \" << lx << \" \" << ry << \" \" << rx << endl;\n//\tbool res = false;\n//\tf[ly][lx][ry][rx] = 1;\n//\tREP(i, 4) {\n//\t\tint nly = ly + dy[i], nry = ry + dy[i], nlx = lx + dx[i], nrx = rx + dx[i];\n//\t\tif (nly >= 0 && nly < h&&nlx >= 0 && nlx < w&&nry >= 0 && nry < h&&nrx >= 0 && nrx < w) {\n//\t\t\tif (s[nly][nlx] != t[nry][nrx]) {\n//\t\t\t\tif (s[nly][nlx] == '%' || t[nry][nrx] == '%')continue;\n//\t\t\t\tif (s[nly][nlx] == '#') {\n//\t\t\t\t\tif (!f[ly][lx][nry][nrx])res |= solve(ly, lx, nry, nrx);\n//\t\t\t\t}\n//\t\t\t\telse if (t[nry][nrx] == '#') {\n//\t\t\t\t\tif (!f[nly][nlx][ry][rx])res |= solve(nly, nlx, ry, rx);\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\telse {\n//\t\t\t\tif (s[nly][nlx] == '%')res = true;\n//\t\t\t\telse if (s[nly][nlx] == '.') {\n//\t\t\t\t\tif (!f[nly][nlx][nry][nrx])res |= solve(nly, nlx, nry, nrx);\n//\t\t\t\t}\n//\t\t\t}\n//\t\t}\n//\t}\n//\treturn res;\n//}\n\nbool solve() {\n\tbool res = false;\n\tqueue<pair<P, P>> que;\n\t//f[sly][slx][sry][srx] = 1;\n\tque.push({ {sly,slx},{sry,srx} });\n\twhile (que.size()) {\n\t\tpair<P, P> pp = que.front();\n\t\tque.pop();\n\t\tint ly = pp.first.first, lx = pp.first.second,\n\t\t\try = pp.second.first, rx = pp.second.second;\n\t\tif (f[ly][lx][ry][rx])continue;\n\t\tf[ly][lx][ry][rx] = 1;\n\t\tREP(i, 4) {\n\t\t\tint nly = ly + dy[i], nry = ry + dy[i], nlx = lx + dx[i], nrx = rx + dx[i];\n\t\t\tif (nly >= 0 && nly < h&&nlx >= 0 && nlx < w&&nry >= 0 && nry < h&&nrx >= 0 && nrx < w) {\n\t\t\t\tif (s[nly][nlx] != t[nry][nrx]) {\n\t\t\t\t\tif (s[nly][nlx] == '%' || t[nry][nrx] == '%')continue;\n\t\t\t\t\tif (s[nly][nlx] == '#') {\n\t\t\t\t\t\tif (!f[ly][lx][nry][nrx]) {\n\t\t\t\t\t\t\tque.push({ {ly, lx}, {nry, nrx} });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (t[nry][nrx] == '#') {\n\t\t\t\t\t\tif (!f[nly][nlx][ry][rx]) {\n\t\t\t\t\t\t\tque.push({ { nly, nlx },{ ry, rx } });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (s[nly][nlx] == '%')res = true;\n\t\t\t\t\telse if (s[nly][nlx] == '.') {\n\t\t\t\t\t\tif (!f[nly][nlx][nry][nrx]) {\n\t\t\t\t\t\t\tque.push({ { nly, nlx },{ nry, nrx } });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\twhile (cin >> w >> h&&w + h) {\n\t\tREP(i, 60)REP(j, 60)REP(k, 60)REP(l, 60) {\n\t\t\tf[i][j][k][l] = 0;\n\t\t}\n\t\tREP(i, h) {\n\t\t\tcin >> s[i] >> t[i];\n\t\t\treverse(ALL(t[i]));\n\t\t}\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tif (s[i][j] == 'L') {\n\t\t\t\t\tsly = i, slx = j;\n\t\t\t\t\ts[i][j] = '.';\n\t\t\t\t}\n\t\t\t\tif (t[i][j] == 'R') {\n\t\t\t\t\tsry = i, srx = j;\n\t\t\t\t\tt[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (solve())cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\nbool used[2510][2510];\nint roomL[51][51], roomR[51][51];\n\ninline int s_to_i(char c) {\n  switch (c) {\n  case '#':\n    return -1;\n  case '.':\n    return 0;\n  case 'L':\n  case 'R':\n    return 1;\n  case '%':\n    return 2;\n  }\n}\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while (true) {\n    int R, C;\n    cin >> C >> R;\n    if (R == 0 && C == 0) break;\n    int sl = 0, sr = 0;\n    REP(i, R) {\n      string rowL, rowR;\n      cin >> rowL >> rowR;\n      REP(j, C) {\n\troomL[i][j] = s_to_i(rowL[j]);\n\tif (roomL[i][j] == 1) sl = i * C + j;\n\troomR[i][j] = s_to_i(rowR[j]);\n\tif (roomR[i][j] == 1) sr = i * C + j;\n      }\n    }\t  \n\n    //cout << slr << ' ' << slc << ' ' << elr << ' ' << elc << ' ' << srr << ' ' << src << ' ' << err << ' ' << erc << endl;\n    REP(i, R*C) REP(j, R*C) used[i][j] = false;\n    \n    queue<P> que;\n    que.push(P(sl, sr));\n\n    bool flag = false;\n    while (!que.empty()) {\n      P p = que.front(); que.pop();\n      int l = p.first, r = p.second, lr = p.first / C, lc = p.first % C, rr = p.second / C, rc = p.second % C;\n      //cout << lr << ' ' << lc << ' ' << rr << ' ' << rc << endl;\n      if (roomL[lr][lc] == 2 && roomR[rr][rc] == 2) {\n\tflag = true;\n\tbreak;\n      } else if (used[l][r] || roomL[lr][lc] == 2 || roomR[rr][rc] == 2) {\n\tcontinue;\n      }\n\n      used[l][r] = true;\n      REP(i, 4) {\n\tint nlr = lr + dr[i], nlc = lc + dc[i], nrr = rr + dr[(i+2*(i&1))%4], nrc = rc + dc[(i+2*(i&1))%4];\n\tif (nlr < 0 || nlr >= R || nlc < 0 || nlc >= C || roomL[nlr][nlc] == -1) nlr = lr, nlc = lc;\n\tif (nrr < 0 || nrr >= R || nrc < 0 || nrc >= C || roomR[nrr][nrc] == -1) nrr = rr, nrc = rc;\n\tif (!used[nlr * C + nlc][nrr * C + nrc]) que.push(P(nlr * C + nlc, nrr * C + nrc));\n      }\n    }\n    cout << (flag ? \"Yes\" : \"No\") << endl;    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx_r[] = {0,1,0,-1};\nstatic const int ty_r[] = {-1,0,1,0};\n\nstatic const int tx_l[] = {0,-1,0,1};\nstatic const int ty_l[] = {-1,0,1,0};\n\nbool Rin_visited[50][50];\nbool Len_visited[50][50];\nchar stage_Len[50][50];\nchar stage_Rin[50][50];\n\nbool can_reach;\nint W,H;\n\nvoid Rin_dfs(int Rin_x,int Rin_y,int Len_x,int Len_y){\n  for(int i=0;i<4;i++){\n    int Rin_dx = Rin_x + tx_r[i];\n    int Rin_dy = Rin_y + ty_r[i];\n\n    int Len_dx = Len_x + tx_l[i];\n    int Len_dy = Len_y + ty_l[i];\n    if(Rin_dx < 0 || Rin_dx >= W || Rin_dy < 0 || Rin_dy >= H){\n\tcontinue;\n    }\n    if(Len_dx < 0 || Len_dx >= W || Len_dy < 0 || Len_dy >= H){\n\tcontinue;\n    }\n    if(stage_Rin[Rin_dy][Rin_dx] == '#'){\n      continue;\n    }\n    if(stage_Len[Len_dy][Len_dx] == '#'){\n      Len_dy = Len_y;\n      Len_dx = Len_x;\n    }\n\n    if(Rin_visited[Rin_dy][Rin_dx]){\n      continue;\n    }\n\n    Rin_visited[Rin_dy][Rin_dx] = true;\n    if(stage_Len[Len_dy][Len_dx] == '%'\n       && stage_Rin[Rin_dy][Rin_dx] == '%'){\n      can_reach = true;\n      return;\n    }\n\n    Rin_dfs(Rin_dx,Rin_dy,Len_dx,Len_dy);\n  }\n}\n\nvoid Len_dfs(int Rin_x,int Rin_y,int Len_x,int Len_y){\n  for(int i=0;i<4;i++){\n    int Rin_dx = Rin_x + tx_r[i];\n    int Rin_dy = Rin_y + ty_r[i];\n\n    int Len_dx = Len_x + tx_l[i];\n    int Len_dy = Len_y + ty_l[i];\n    if(Rin_dx < 0 || Rin_dx >= W || Rin_dy < 0 || Rin_dy >= H){\n\tcontinue;\n    }\n    if(Len_dx < 0 || Len_dx >= W || Len_dy < 0 || Len_dy >= H){\n\tcontinue;\n    }\n    if(stage_Rin[Rin_dy][Rin_dx] == '#'){\n      Rin_dy = Rin_y;\n      Rin_dx = Rin_x;\n    }\n    if(stage_Len[Len_dy][Len_dx] == '#'){\n      continue;\n    }\n\n    if(Len_visited[Len_dy][Len_dx]){\n      continue;\n    }\n\n    Len_visited[Len_dy][Len_dx] = true;\n    if(stage_Len[Len_dy][Len_dx] == '%'\n       && stage_Rin[Rin_dy][Rin_dx] == '%'){\n      can_reach = true;\n      return;\n    }\n\n    Len_dfs(Rin_dx,Rin_dy,Len_dx,Len_dy);\n  }\n}\n\nint main(){\n\n  while(~scanf(\"%d %d\",&W,&H)){\n    if(W==0 && H==0) break;\n\n    memset(Len_visited,false,sizeof(Len_visited));\n    memset(Rin_visited,false,sizeof(Rin_visited));\n    can_reach = false;\n    \n    int Rin_start_x = 0;\n    int Rin_start_y = 0;\n    int Len_start_x = 0;\n    int Len_start_y = 0;\n \n    for(int y=0;y<H;y++){\n      string str_Len,str_Rin;\n      cin >> str_Len >> str_Rin;\n      \n      // cout << str_Len << endl;\n      // cout << str_Rin << endl;\n\n      for(int x=0;x<W;x++){\n\tstage_Len[y][x] = str_Len[x];\n\tstage_Rin[y][x] = str_Rin[x];\n\n\tif(str_Len[x] == 'L'){\n\t  Len_start_x = x;\n\t  Len_start_y = y;\n\t}\n\tif(str_Rin[x] == 'R'){\n\t  Rin_start_x = x;\n\t  Rin_start_y = y;\n\t}\n      }\n    }\n\n    Len_dfs(Rin_start_x,Rin_start_y,Len_start_x,Len_start_y);\n    Rin_dfs(Rin_start_x,Rin_start_y,Len_start_x,Len_start_y);\n    printf(\"%s\\n\",can_reach ? \"Yes\" : \"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<queue>\n\n\n#define F first\n#define S second\n \nusing namespace std;\n\nstruct State{\n  int x1,y1,x2,y2;\n  State(){}\n  State(int a, int b, int c, int d):x1(a),y1(b),x2(c),y2(d){}\n};\n \nconst int MAX = 55;\ntypedef pair<int,int> P;\nchar M[2][MAX][MAX];\nbool come[MAX][MAX][MAX][MAX];\nint W,H;\nP s1,s2;\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\n \nvoid init(){\n  memset(come,false,sizeof(come));\n}\n \nvoid print(){\n  for(int x = 0; x < 2; x++){\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++) cout << M[x][i][j];\n      cout << endl;\n    }\n    cout << endl<< endl;\n  }\n}\n \nvoid input(){\n  for(int i = 0; i < H; i++)\n    for(int x = 0; x < 2; x++)\n      for(int j = 0; j < W; j++){\n    cin >> M[x][i][j];\n    if(M[x][i][j] == 'L' && !x) s1 = P(i,j);\n    if(M[x][i][j] == 'R' && x) s2 = P(i,j);\n    }\n}\n \nbool isInside(int x, int y){return 0<=x&&x<W&&0<=y&&y<H;}\n\n\nbool dfs(){\n\n  queue<State> Q;\n  Q.push(State(s1.S,s1.F,s2.S,s2.F));\n  \n  while(!Q.empty()){\n    State now = Q.front();\n    Q.pop();\n\n    if(come[now.x1][now.y1][now.x2][now.y2]) continue;\n    come[now.x1][now.y1][now.x2][now.y2] = true;\n    \n    // cout << now.x1 << \" \" << now.y1 << \" \" << now.x2 << \" \" << now.y2 << endl;\n    for(int i = 0; i < 4; i++){\n      int nx1 = now.x1+dx[i];\n      int ny1 = now.y1+dy[i];\n      int nx2 = now.x2-dx[i];\n      int ny2 = now.y2+dy[i];\n      if(!isInside(nx1,ny1) || M[0][ny1][nx1] == '#'){\n\tnx1 = now.x1;\n\tny1 = now.y1;\n      }\n      if(!isInside(nx2,ny2) || M[1][ny2][nx2] == '#'){\n\tnx2 = now.x2;\n\tny2 = now.y2;\n      }\n      if(M[0][ny1][nx1] == '%' && M[1][ny2][nx2] == '%') return true;\n      if(M[0][ny1][nx1] != '%' && M[1][ny2][nx2] != '%') Q.push(State(nx1,ny1,nx2,ny2));\n    }\n  }\n  return false;\n}\n\nvoid solve(){\n  if(dfs()) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n}\n \nint main(){\n  while(cin >> W >> H && W+H){\n    init();\n    input();\n    //   print();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> P;\n\nstruct state{\n    int ly, lx, ry, rx;\n};\nint w, h;\nbool contain(int y, int x){\n    return (0 <= y && y < h && 0 <= x && x < w);\n}\nint dy[4] = {1, -1, 0, 0};\nint dx[4] = {0, 0, 1, -1};\nbool f[51][51][51][51];\n\nsigned main(){\n    while(1){\n        cin >> w >> h;\n        if(w + h == 0) break;\n        vector<string> s(h), t(h);\n        bool ans = false;\n        int lsy, lsx, lgy, lgx, rsy, rsx, rgy, rgx;\n        rep(i, 0, h){\n            cin >> s[i] >> t[i];\n            rep(j, 0, w){\n                if(s[i][j] == 'L'){ lsy = i; lsx = j;}\n                if(s[i][j] == '%'){ lgy = i; lgx = j;}\n                if(t[i][j] == 'R'){ rsy = i; rsx = j;}\n                if(t[i][j] == '%'){ rgy = i; rgx = j;}\n            }\n        }\n        queue<state> q;\n        q.push((state){lsy, lsx, rsy, rsx});\n        rep(i, 0, 51) rep(j, 0, 5) rep(k, 0, 51) rep(l, 0, 51) f[i][j][k][l] = false;\n        f[lsy][lsx][rsy][rsx] = true;\n        while(!q.empty()){\n            state p = q.front(); q.pop();\n            rep(i, 0, 4){\n                int nly = p.ly + dy[i];\n                int nlx = p.lx + dx[i];\n                int nry = p.ry + dy[i];\n                int nrx = p.rx - dx[i];\n                if(!contain(nly, nlx) || s[nly][nlx] == '#'){ nly = p.ly; nlx = p.lx;}\n                if(!contain(nry, nrx) || t[nry][nrx] == '#'){ nry = p.ry; nrx = p.rx;}\n                if(f[nly][nlx][nry][nrx]) continue;\n                f[nly][nlx][nry][nrx] = true;\n                if(s[nly][nlx] == '%' && t[nry][nrx] == '%'){ ans = true; break;}\n                q.push((state){nly, nlx, nry, nrx});\n            }\n        }\n        cout << (ans ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define ck(a,b) (0<=(a)&&(a)<b)\nusing namespace std;\nint dx[]={-1,1,0,0},dy[]={0,0,-1,1};\nstruct S{\n\tint lx,ly,rx,ry;\n\tS(int a,int b,int c,int d):lx(a),ly(b),rx(c),ry(d){}\n};\nbool V[50][50][50][50];\nint main(){\n\tint w,h;\n\twhile(cin>>w>>h,w){\n\t\tint lx,ly,rx,ry;\n\t\tstring cavel[h],caver[h];\n\t\trep(i,h)cin>>cavel[i]>>caver[i];\n\t\trep(i,h)rep(j,w){\n\t\t\tif(cavel[i][j]=='L')ly=i,lx=j,cavel[i][j]='.';\n\t\t\tif(caver[i][j]=='R')ry=i,rx=j,caver[i][j]='.';\n\t\t}\n\t\tqueue<S> F; rep(i,h)rep(j,w)rep(k,h)rep(l,w)V[i][j][k][l]=0;\n\t\tF.push(S(lx,ly,rx,ry)); V[ly][lx][ry][rx]=1;\n\t\tint goal=0;\n\t\twhile(!F.empty()&&!goal){\n\t\t\tS s=F.front(); F.pop();\n\t\t\trep(d,4){\n\t\t\t\tint clx=s.lx,cly=s.ly,crx=s.rx,cry=s.ry,nlx=clx+dx[d],nly=cly+dy[d],nrx=crx-dx[d],nry=cry+dy[d];\n\t\t\t\tif(!ck(nlx,w)||!ck(nly,h)||cavel[nly][nlx]=='#')nlx=clx,nly=cly;\n\t\t\t\tif(!ck(nrx,w)||!ck(nry,h)||caver[nry][nrx]=='#')nrx=crx,nry=cry;\n\t\t\t\tif(nlx==clx&&nly==cly&&nrx==crx&&nry==cry||(cavel[nly][nlx]=='%'^caver[nry][nrx]=='%'))continue;\n\t\t\t\tif(cavel[nly][nlx]=='%'&&caver[nry][nrx]=='%'){\n\t\t\t\t\tgoal=1; goto END;\n\t\t\t\t}\n\t\t\t\tif(!V[nly][nlx][nry][nrx]){\n\t\t\t\t\tF.push(S(nlx,nly,nrx,nry));\n\t\t\t\t\tV[nly][nlx][nry][nrx]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tEND:cout<<(goal?\"Yes\":\"No\")<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint cases = INF;\n\tREP(_, cases)\n\t{\n\t\tREAD(int, w, h);\n\t\tif (!w) { break; }\n\t\tvector<string> lmap, rmap;\n\t\tlmap.push_back(string(w + 2, '#'));\n\t\trmap.push_back(string(w + 2, '#'));\n\t\tint lx, ly, rx, ry, Lx, Ly, Rx, Ry;\n\t\tREP(_, h)\n\t\t{\n\t\t\tREAD(string, ls, rs);\n\t\t\tlmap.push_back(\"#\" + ls + \"#\");\n\t\t\trmap.push_back(\"#\" + rs + \"#\");\n\t\t\t{ int p = ls.find_first_of('L'); if (p != ls.npos) { ly = _ + 1; lx = p + 1; } }\n\t\t\t{ int p = rs.find_first_of('R'); if (p != rs.npos) { ry = _ + 1; rx = p + 1; } }\n\t\t\t{ int p = ls.find_first_of('%'); if (p != ls.npos) { Ly = _ + 1; Lx = p + 1; } }\n\t\t\t{ int p = rs.find_first_of('%'); if (p != rs.npos) { Ry = _ + 1; Rx = p + 1; } }\n\t\t}\n\t\tlmap.push_back(string(w + 2, '#'));\n\t\trmap.push_back(string(w + 2, '#'));\n\t\tw += 2; h += 2;\n\n\t\tvevevevector<bool> visited(w, h, w, h);\n\t\tstruct status { int lx, ly, rx, ry, cost, h; };\n\t\tpriority_queue<status, vector<status>, COMPARISON_T(status)> q(COMPARISON(status, a, b, a.cost + a.h > b.cost + b.h));\n\t\tint result = INF;\n\t\tconst int dy[] = { 1, -1, 0, 0 }, dxl[] = { 0, 0, -1, 1 }, dxr[] = { 0, 0, 1, -1 };\n\t\tq.push({ lx, ly, rx, ry, 0, INF });\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tstatus s = q.top(); q.pop();\n\t\t\tif (visited[s.lx][s.ly][s.rx][s.ry]) continue;\n\t\t\tvisited[s.lx][s.ly][s.rx][s.ry] = true;\n\t\t\tbool lok = s.lx == Lx && s.ly == Ly;\n\t\t\tbool rok = s.rx == Rx && s.ry == Ry;\n\n\t\t\tif (lok || rok) { if (lok && rok) { result = s.cost; break; } continue; }\n\t\t\t\n\t\t\tREP(i, 4)\n\t\t\t{\n\t\t\t\tint nlx = s.lx + dxl[i];\n\t\t\t\tint nly = s.ly + dy[i];\n\t\t\t\tint nrx = s.rx + dxr[i];\n\t\t\t\tint nry = s.ry + dy[i];\n\t\t\t\tint h = abs(Lx - nlx) + abs(Ly - nly) + abs(Ry - nry) + abs(Ry - nry);\n\t\t\t\tif (lmap[nly][nlx] == '#') { nlx = s.lx; nly = s.ly; }\n\t\t\t\tif (rmap[nry][nrx] == '#') { nrx = s.rx; nry = s.ry; }\n\t\t\t\tq.push({ nlx, nly, nrx, nry, s.cost + 1, h });\n\t\t\t}\n\t\t}\n\t\tWRITE(result != INF ? \"Yes\" : \"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1e9+7;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 100010;\n\nint h, w, sxl, syl, sxr, syr, gxl, gyl, gxr, gyr;\nchar cl[55][55], cr[55][55];\nbool used[55][55][55][55];\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\n\nbool in(int x, int y){\n    return 0<=x && x<h && 0<=y && y<w;\n}\n\nbool gl(int xl, int yl){\n    return xl == gxl && yl == gyl;\n}\n\nbool gr(int xr, int yr){\n    return xr == gxr && yr == gyr;\n}\n\nvoid solve(){\n    rep(xl, h)rep(yl, w)rep(xr, h)rep(yr, w) used[xl][yl][xr][yr] = false;\n    queue<pair<pii, pii>> que;\n    que.push({{sxl, syl}, {sxr, syr}});\n    used[sxl][syl][sxr][syr] = true;\n    while(!que.empty()){\n        int xl, yl, xr, yr;\n        tie(xl, yl) = que.front().fi;\n        tie(xr, yr) = que.front().se;\n        que.pop();\n        rep(i, 4){\n            int nxl = xl + dx[i], nyl = yl + dy[i];\n            int nxr = xr + dx[i], nyr = yr - dy[i];\n            if(!in(nxl, nyl) || cl[nxl][nyl] == '#'){\n                nxl = xl; nyl = yl;\n            }\n            if(!in(nxr, nyr) || cr[nxr][nyr] == '#'){\n                nxr = xr; nyr = yr;\n            }\n            if(!used[nxl][nyl][nxr][nyr]){\n                if(gl(nxl, nyl) ^ gr(nxr, nyr)) continue;\n                que.push({{nxl, nyl}, {nxr, nyr}});\n                used[nxl][nyl][nxr][nyr] = true;\n            }\n        }\n    }\n    puts(used[gxl][gyl][gxr][gyr] ? \"Yes\" : \"No\");\n}\n\nint main(){\n    while(scanf(\"%d%d\", &w, &h) && h){\n        rep(i, h){\n            rep(j, w){\n                scanf(\" %c\", &cl[i][j]);\n                if(cl[i][j] == 'L') sxl = i, syl = j;\n                if(cl[i][j] == '%') gxl = i, gyl = j;\n            }\n            rep(j, w){\n                scanf(\" %c\", &cr[i][j]);\n                if(cr[i][j] == 'R') sxr = i, syr = j;\n                if(cr[i][j] == '%') gxr = i, gyr = j;\n            }\n        }\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<char,char> P;\n\nstruct state{\n\tP p1, p2;\n\tstate(P p1_, P p2_){ p1 = p1_; p2 = p2_; }\n};\nint w, h;\nint dx1[4] = {0,-1,1,0};\nint dy1[4] = {-1,0,0,1};\nint dx2[4] = {0,1,-1,0};\nint dy2[4] = {-1,0,0,1};\nbool flag[51][51][51][51];\nchar L[51][51];\nchar R[51][51];\n\nvoid init(){\n\tfor(int i=0 ; i < 51 ; i++ ){\n\t\tfor(int j=0 ; j < 51 ; j++ ){\n\t\t\tfor(int k=0 ; k < 51 ; k++ ){\n\t\t\t\tfor(int l=0 ; l < 51 ; l++ ){\n\t\t\t\t\tflag[i][j][k][l] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// デバッグ用\nvoid debug(){\n\tcout << \"[Left]\" << endl;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tcout << L[y][x];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n\tcout << \"[right]\" << endl;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tcout << R[y][x];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// R[y][x] == 'R' となる (x,y) を返す\nP R_search(){\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( R[y][x] == 'R' ){\n\t\t\t\tR[y][x] = '.';\n\t\t\t\treturn P(x,y);\n\t\t\t}\n\t\t}\n\t}\n\treturn P(0,0);\n}\n\n// L[y][x] == 'L' となる (x,y) を返す\nP L_search(){\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( L[y][x] == 'L' ){\n\t\t\t\tL[y][x] = '.';\n\t\t\t\treturn P(x,y);\n\t\t\t}\n\t\t}\n\t}\n\treturn P(0,0);\n}\n\nbool bfs(){\n\tP ls = L_search();\n\tP rs = R_search();\n\t\n\tqueue< pair<P,P> > q;\n\tpair<P,P> s( ls , rs );\n\tq.push( s );\n\t\n\twhile( !q.empty() && q.size() < 5000000 ){\n\t\tpair<P,P> now = q.front(); q.pop();\n\t\tint x1 = now.first.first;\n\t\tint y1 = now.first.second;\n\t\tint x2 = now.second.first;\n\t\tint y2 = now.second.second;\n\t\tflag[y1][x1][y2][x2] = true;\n\t\tif( L[y1][x1] == '%' && R[y2][x2] == '%' ){\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\tint mx1 = x1 + dx1[i];\n\t\t\tint my1 = y1 + dy1[i];\n\t\t\tif( mx1 < 0 || my1 < 0 || mx1 >= w || my1 >= h || L[my1][mx1] == '#' ){\n\t\t\t\tmx1 = x1;\n\t\t\t\tmy1 = y1;\n\t\t\t}\n\t\t\tint mx2 = x2 + dx2[i];\n\t\t\tint my2 = y2 + dy2[i];\n\t\t\tif( mx2 < 0 || my2 < 0 || mx2 >= w || my2 >= h || R[my2][mx2] == '#' ){\n\t\t\t\tmx2 = x2;\n\t\t\t\tmy2 = y2;\n\t\t\t}\n\t\t\tP p1(mx1,my1);\n\t\t\tP p2(mx2,my2);\n\t\t\tpair<P,P> next(p1,p2);\n\t\t\tif( flag[my1][mx1][my2][mx2] ){\n\t\t\t\tcontinue;\n\t\t\t}else if( L[my1][mx1] == '%' && R[my2][mx2] != '%' ){\n\t\t\t\tflag[my1][mx1][my2][mx2] = true;\n\t\t\t}else if( L[my1][mx1] != '%' && R[my2][mx2] == '%' ){\n\t\t\t\tflag[my1][mx1][my2][mx2] = true;\n\t\t\t}else{\n\t\t\t\tq.push( next );\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\twhile( cin >> w >> h, w || h ){\n\t\tinit();\n\t\t\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tstring l, r;\n\t\t\tcin >> l >> r;\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tL[y][x] = l[x];\n\t\t\t\tR[y][x] = r[x];\n\t\t\t}\n\t\t}\n\t\t// debug();\n\t\tbool ans = bfs();\n\t\tif( ans )\n\t\t\tcout << \"Yes\" << endl;\n\t\telse\n\t\t\tcout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\nbool used[51][51][51][51];\nstring roomL[51], roomR[51];\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while (true) {\n    int R, C;\n    cin >> C >> R;\n    if (R == 0 && C == 0) break;\n    REP(i, R) cin >> roomL[i] >> roomR[i];\n\n    int slr = 0, slc = 0, elr = 0, elc = 0, srr = 0, src = 0, err = 0, erc = 0;\n    REP(r, R) REP(c, C) {\n      if (roomL[r][c] == 'L') slr = r, slc = c;\n      if (roomR[r][c] == 'R') srr = r, src = c;\n      if (roomL[r][c] == '%') elr = r, elc = c;\n      if (roomR[r][c] == '%') err = r, erc = c;\n    }\n    //cout << slr << ' ' << slc << ' ' << elr << ' ' << elc << ' ' << srr << ' ' << src << ' ' << err << ' ' << erc << endl;\n    REP(i, R) REP(j, C) REP(k, R) REP(l, C) used[i][j][k][l] = false;\n    \n    queue<P> que;\n    que.push(P(slr * C + slc, srr * C + src));\n\n    bool flag = false;\n    while (!que.empty()) {\n      P p = que.front(); que.pop();\n      int lr = p.first / C, lc = p.first % C, rr = p.second / C, rc = p.second % C;\n      //cout << lr << ' ' << lc << ' ' << rr << ' ' << rc << endl;\n      if (lr == elr && lc == elc && rr == err && rc == erc) {\n\tflag = true;\n\tbreak;\n      } else if (used[lr][lc][rr][rc] || (lr == elr && lc == elc) || (rr == err && rc == erc)) {\n\tcontinue;\n      }\n\n      used[lr][lc][rr][rc] = true;\n      REP(i, 4) {\n\tint nlr = lr + dr[i], nlc = lc + dc[i], nrr = rr + dr[(i+2*(i&1))%4], nrc = rc + dc[(i+2*(i&1))%4];\n\tif (0 <= nlr && nlr < R && 0 <= nlc && nlc < C && 0 <= nrr && nrr < R && 0 <= nrc && nrc < C) {\n\t  if (roomL[nlr][nlc] == '#') {\n\t    nlr = lr, nlc = lc;\n\t  }\n\t  if (roomR[nrr][nrc] == '#') {\n\t    nrr = rr, nrc = rc;\n\t  }\n\t  que.push(P(nlr * C + nlc, nrr * C + nrc));\n\t}\n      }\n    }\n    cout << (flag ? \"Yes\" : \"No\") << endl;    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,b,e) for(int i=(b);i<(e);++i)\n#define rep(i,e) for(int i=0;i<(e);++i)\n\nint w, h, lx, ly, rx, ry, nlx, nly, nrx, nry;\nint t, lsx, lsy, rsx, rsy;\nchar l[50][50], r[50][50];\nint drx[4]={0,1,0,-1}, dy[4]={1,0,-1,0}, dlx[4]={0,-1,0,1};\n\nint main() {\n  while(true){\n    cin>>w>>h;\n    if(w==0)break;\n\n    bool visited[50][50][50][50]={};\n    bool ans = false;\n    int t, lsx, lsy, rsx, rsy;\n\n    rep(i,h){\n      rep(j,w){\n        cin>>l[i][j];\n        if(l[i][j]=='L') lsx=j, lsy=i;\n      }\n      rep(j,w){\n        cin>>r[i][j];\n        if(r[i][j]=='R') rsx=j, rsy=i;\n      }\n    }\n    //cout<<lsx<<\" \"<<lsy<<\" \"<<rsx<<\" \"<<rsy<<endl;\n\n    queue<tuple<int, int, int, int>> q;\n    q.push(make_tuple(lsx, lsy, rsx, rsy));\n    visited[lsx][lsy][rsx][rsy] = true;\n    while(q.size()){\n      tie(lx, ly, rx, ry) = q.front(); q.pop();\n      //cout<<lx<<\" \"<<ly<<\" \"<<rx<<\" \"<<ry<<endl;\n\n      rep(i,4){\n        nlx = lx+dlx[i], nly = ly+dy[i];\n        nrx = rx+drx[i], nry = ry+dy[i];\n        if(nlx<0 or nlx>=w) nlx = lx;\n        if(nrx<0 or nrx>=w) nrx = rx;\n        if(nly<0 or nly>=h) nly = ly;\n        if(nry<0 or nry>=h) nry = ry;\n        if(l[nly][nlx]=='\\%' and r[nry][nrx]=='\\%'){\n          ans = true; break;\n        }\n        else if(l[nly][nlx]=='\\%' or r[nry][nrx]=='\\%') continue;\n        else if(l[nly][nlx]=='#' and r[nry][nrx]=='#') continue;\n        else if(l[nly][nlx]=='#'){\n          nly = ly, nlx = lx;\n        }\n        else if(r[nry][nrx]=='#'){\n          nry = ry, nrx = rx;\n        }\n        if(visited[nlx][nly][nrx][nry]==false){\n          q.push(make_tuple(nlx, nly, nrx, nry));\n          visited[nlx][nly][nrx][nry] = true;\n        }\n      }\n    }\n    if (ans) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<cmath>\n#include<utility>\n#include<functional>\n#include<map>\n#include<set>\n#include<cctype>\n\n\n#define FOR(i, a, b) for( int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for( int i=(a);i>=(b);i--)\n#define LFOR(i, a, b) for( long long int i=(a);i<=(b);i++)\n#define LRFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LLINF 1000000000000000000 //9000000000000000000\n#define PI 3.14159265358979\n#define MAXI 7500000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\n\nint dy[4] = { 0,0,1,-1 };\nint dx[4] = { 1,-1,0,0 };\n\n//int dp[50][50][50][50] = {};//ly,lx,ry,rx\n\n\nint main(void) {\n\t\n\twhile (1) {\n\n\t\tstruct Pos{\n\t\t\tint leftx;\n\t\t\tint lefty;\n\t\t\tint rightx;\n\t\t\tint righty;\n\t\t};\n\n\t\tint w, h;\n\t\tint lx = -1, ly = -1, rx = -1, ry = -1;\n\t\tint lgx = -1, lgy = -1, rgx = -1, rgy = -1;\n\n\t\tvector< vector< vector< vector<int> > > > dp(50, vector< vector< vector<int > > >(50, vector< vector<int> >(50, vector<int>(50, 0))));\n\t\t\n\n\t\tqueue<Pos> que;\n\t\tPos now;\n\n\t\tcin >> w >> h;\n\n\t\tif (w == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tvector<string> left(h), right(h);\n\n\t\tFOR(i, 0, h-1) {\n\t\t\tcin >> left[i] >> right[i];\n\t\t}\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (left[i][j] == 'L') {\n\t\t\t\t\tlx = j;\n\t\t\t\t\tly = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (right[i][j] == 'R') {\n\t\t\t\t\trx = j;\n\t\t\t\t\try = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (left[i][j] == '%') {\n\t\t\t\t\tlgx = j;\n\t\t\t\t\tlgy = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lgx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (right[i][j] == '%') {\n\t\t\t\t\trgx = j;\n\t\t\t\t\trgy = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rgx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdp[ly][lx][ry][rx] = 1;\n\n\t\tnow.lefty = ly;\n\t\tnow.leftx = lx;\n\t\tnow.righty = ry;\n\t\tnow.rightx = rx;\n\t\t\n\t\tque.push(now);\n\n\n\t\twhile (!que.empty()) {\n\t\t\tnow = que.front();\n\t\t\t\n\t\t\tque.pop();\n\t\t\tly = now.lefty;\n\t\t\tlx = now.leftx;\n\t\t\try = now.righty;\n\t\t\trx = now.rightx;\n\t\t\t//cout << ly << \" \" << lx << \" \" << ry << \" \" << rx << endl;\n\n\t\t\tFOR(i, 0, 3) {\n\t\t\t\t\n\t\t\t\tif (ly + dy[i] >= 0 && lx - dx[i] >= 0 && ry + dy[i] <= h - 1 && rx + dx[i] <= w - 1 && ly + dy[i] <= h - 1 && lx - dx[i] <= w - 1 && ry + dy[i] >= 0 && rx + dx[i] >= 0) {\n\t\t\t\t\tif (dp[ly + dy[i]][lx - dx[i]][ry + dy[i]][rx + dx[i]] != 1) {\n\t\t\t\t\t\tif (left[ly + dy[i]][lx - dx[i]] == '#') {\n\t\t\t\t\t\t\tif (right[ry + dy[i]][rx + dx[i]] == '#') {\n\t\t\t\t\t\t\t\t//no\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdp[ly][lx][ry + dy[i]][rx + dx[i]] = 1;\n\t\t\t\t\t\t\t\tnow.lefty = ly;\n\t\t\t\t\t\t\t\tnow.leftx = lx;\n\t\t\t\t\t\t\t\tnow.righty = ry + dy[i];\n\t\t\t\t\t\t\t\tnow.rightx = rx + dx[i];\n\t\t\t\t\t\t\t\tque.push(now);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (right[ry + dy[i]][rx + dx[i]] == '#') {\n\t\t\t\t\t\t\t\tdp[ly + dy[i]][lx - dx[i]][ry][rx] = 1;\n\t\t\t\t\t\t\t\tnow.lefty = ly + dy[i];\n\t\t\t\t\t\t\t\tnow.leftx = lx - dx[i];\n\t\t\t\t\t\t\t\tnow.righty = ry;\n\t\t\t\t\t\t\t\tnow.rightx = rx;\n\t\t\t\t\t\t\t\tque.push(now);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdp[ly + dy[i]][lx - dx[i]][ry + dy[i]][rx + dx[i]] = 1;\n\t\t\t\t\t\t\t\tnow.lefty = ly + dy[i];\n\t\t\t\t\t\t\t\tnow.leftx = lx - dx[i];\n\t\t\t\t\t\t\t\tnow.righty = ry + dy[i];\n\t\t\t\t\t\t\t\tnow.rightx = rx + dx[i];\n\t\t\t\t\t\t\t\tque.push(now);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (dp[lgy][lgx][rgy][rgx] == 1) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t\t\n\n\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nchar ba[64][64];\nchar bb[64][64];\n\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n\nbool memo[64][64][64][64];\n\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\n\nint main(){\n  int w,h;\n  while(scanf(\"%d%d\",&w,&h), w+h){\n    int lsx, lsy, rsx, rsy;\n    int lgx, lgy, rgx, rgy;\n    memset(memo, 0, sizeof(memo));\n    REP(i,h) scanf(\"%s %s\",ba[i],bb[i]);\n    REP(i,h) REP(j,w){\n      if(ba[i][j] == 'L'){\n        lsx = j; lsy = i;\n        ba[i][j] = '.';\n      }else if(ba[i][j] == '%'){\n        lgx = j; lgy = i;\n        ba[i][j] = '.';\n      }\n      if(bb[i][j] == 'R'){\n        rsx = j; rsy = i;\n        bb[i][j] = '.';\n      }else if(bb[i][j] == '%'){\n        rgx = j; rgy = i;\n        bb[i][j] = '.';\n      }\n    }\n\n    //REP(i,h) printf(\"%s %s\\n\",ba[i],bb[i]);\n\n    typedef pair<pair<int,int>, pair<int,int> > P;\n    queue<P> q;\n    bool ans = false;\n    q.push(mp(mp(lsx,lsy),mp(rsx,rsy)));\n    while(!q.empty()){\n      P p = q.front();\n      int lx = p.f.f;\n      int ly = p.f.s;\n      int rx = p.s.f;\n      int ry = p.s.s;\n\n      //printf(\"(%d,%d) , (%d,%d)\\n\",lx,ly,rx,ry);\n      q.pop();\n\n      if(memo[lx][ly][rx][ry])\n        continue;\n      memo[lx][ly][rx][ry] = true;\n\n      if(lx == lgx && ly == lgy){\n        if(rx == rgx && ry == rgy){\n          ans = true;\n          break;\n        }else{\n          continue;\n        }\n      }\n      if(rx == rgx && ry == rgy)\n        continue;\n\n      REP(i,4){\n        int lxx = lx + dx[i];\n        int lyy = ly + dy[i];\n        int rxx = rx - dx[i];\n        int ryy = ry + dy[i];\n\n        if( ! (IN(lxx,0,w) && IN(lyy,0,h)) ){\n          lxx = lx; lyy = ly;\n        } else if(ba[lyy][lxx] == '#'){\n          lxx = lx; lyy = ly;\n        }\n\n        if( ! (IN(rxx,0,w) && IN(ryy,0,h)) ){\n          rxx = rx; ryy = ry;\n        } else if(bb[ryy][rxx] == '#'){\n          rxx = rx; ryy = ry;\n        }\n\n        if(!memo[lxx][lyy][rxx][ryy]){\n          q.push(mp(mp(lxx,lyy),mp(rxx,ryy)));\n        }\n      }\n    }\n    puts(ans?\"Yes\":\"No\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint dis[50][50][50][50];\n\ntypedef pair<pair<int, int>, pair<int, int> > status;\n#define LEFT first\n#define RIGHT second\n#define X first\n#define Y second\n\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nint main() {\n  int w, h;\n  while (true) {\n    vector<string> left, right;\n    cin >> w >> h;\n    if (w == 0 && h == 0) break;\n    rep (i, h) {\n      string str;\n      cin >> str;\n      left.push_back(str);\n      cin >> str;\n      right.push_back(str);\n    }\n    memset(dis, -1, sizeof(dis));\n    queue<status> que;\n    int lx, ly, rx, ry;\n    rep (i, h) rep (j, w) {\n      if (left[i][j] == 'L') {\n\tlx = j;\n\tly = i;\n      }\n      if (right[i][j] == 'R') {\n\trx = j;\n\try = i;\n      }\n    }\n    status s;\n    s.LEFT.X = lx;\n    s.LEFT.Y = ly;\n    s.RIGHT.X = rx;\n    s.RIGHT.Y = ry;\n    que.push(s);\n    while (!que.empty()) {\n      status now = que.front();\n      que.pop();\n      if (dis[now.LEFT.X][now.LEFT.Y][now.RIGHT.X][now.RIGHT.Y] != -1) {\n\tcontinue;\n      }\n      dis[now.LEFT.X][now.LEFT.Y][now.RIGHT.X][now.RIGHT.Y] = 1;\n      rep (i, 4) {\n\tstatus next = now;\n\tnext.LEFT.X += dx[i];\n\tnext.LEFT.Y += dy[i];\n\tnext.RIGHT.X -= dx[i];\n\tnext.RIGHT.Y += dy[i];\n\tif (next.LEFT.X < 0 || w <= next.LEFT.X || next.LEFT.Y < 0 || h <= next.LEFT.Y || left[next.LEFT.Y][next.LEFT.X] == '#') {\n\t  next.LEFT.X -= dx[i];\n\t  next.LEFT.Y -= dy[i];\n\t}\n\tif (next.RIGHT.X < 0 || w <= next.RIGHT.X || next.RIGHT.Y < 0 || h <= next.RIGHT.Y || right[next.RIGHT.Y][next.RIGHT.X] == '#') {\n\t  next.RIGHT.X += dx[i];\n\t  next.RIGHT.Y -= dy[i];\n\t}\n\tif (left[next.LEFT.Y][next.LEFT.X] == '%' && right[next.RIGHT.Y][next.RIGHT.X] == '%') goto aaa;\n\tque.push(next);\n      }\n    }\n    cout << \"No\" << endl;\n    continue;\n  aaa:;\n    cout << \"Yes\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nstruct state { int ly, lx, ry, rx, t; };\n\nint W, H, SLY, SLX, SRY, SRX;\nchar S[2][50][50];\nbool visited[50][50][50][50];\nint dd[5] = { 0, 1, 0, -1, 0 };\n\nbool isin(int y, int x) {\n  return 0 <= y && y < H && 0 <= x && x < W;\n}\n\nint main(void) {\n  while(cin >> W >> H, W || H) {\n    REP(i, 0, H) {\n      cin >> S[0][i];\n      cin >> S[1][i];\n      REP(j, 0, W) if(S[0][i][j] == 'L') SLY = i, SLX = j;\n      REP(j, 0, W) if(S[1][i][j] == 'R') SRY = i, SRX = j;\n    }\n\n    REP(i, 0, 50) REP(j, 0, 50) REP(k, 0, 50) REP(l, 0, 50) visited[i][j][k][l] = false;\n\n    queue<state> q;\n    q.push((state) { SLY, SLX, SRY, SRX, 0 });\n\n    int ans = -1;\n    while(q.size()) {\n      state c = q.front();\n      q.pop();\n\n      if(visited[c.ly][c.lx][c.ry][c.rx]) continue;\n      visited[c.ly][c.lx][c.ry][c.rx] = true;\n\n      bool f1 = S[0][c.ly][c.lx] == '%';\n      bool f2 = S[1][c.ry][c.rx] == '%';\n      if((!f1 && f2) || (f1 && !f2)) continue;\n\n      if(S[0][c.ly][c.lx] == '%' && S[1][c.ry][c.rx] == '%') {\n        ans = c.t;\n        break;\n      }\n\n      REP(i, 0, 4) {\n        state n = (state) { c.ly + dd[i], c.lx + dd[i + 1], c.ry + dd[i], c.rx - dd[i + 1], c.t + 1 };\n        if(isin(n.ly, n.lx) && isin(n.ry, n.rx)) {\n          if(S[0][n.ly][n.lx] != '#' && S[1][n.ry][n.rx] != '#') {\n            q.push(n);\n          }\n          if(S[0][n.ly][n.lx] != '#' && S[1][n.ry][n.rx] == '#') {\n            q.push((state) { n.ly, n.lx, c.ry, c.rx, n.t });\n          }\n          if(S[0][n.ly][n.lx] == '#' && S[1][n.ry][n.rx] != '#') {\n            q.push((state) { c.ly, c.lx, n.ry, n.rx, n.t });\n          }\n        }\n      }\n    }\n\n    if(ans == -1) cout << \"No\" << endl;\n    else cout << \"Yes\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<cmath>\n#include<utility>\n#include<functional>\n#include<map>\n#include<set>\n#include<cctype>\n\n\n#define FOR(i, a, b) for( int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for( int i=(a);i>=(b);i--)\n#define LFOR(i, a, b) for( long long int i=(a);i<=(b);i++)\n#define LRFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LLINF 1000000000000000000 //9000000000000000000\n#define PI 3.14159265358979\n#define MAXI 7500000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\n\nint dy[4] = { 0,0,1,-1 };\nint dx[4] = { 1,-1,0,0 };\n\n//int dp[50][50][50][50] = {};//ly,lx,ry,rx\n\n\nint main(void) {\n\t\n\twhile (1) {\n\t\tbool flag = false;\n\t\tint w, h;\n\t\tint lx = -1, ly = -1, rx = -1, ry = -1;\n\t\tint lgx = -1, lgy = -1, rgx = -1, rgy = -1;\n\n\t\tvector< vector< vector< vector<int> > > > dp(50, vector< vector< vector<int > > >(50, vector< vector<int> >(50, vector<int>(50, 0))));\n\t\t\n\n\t\tpair< pair<int, int>, pair<int, int> > Pair;\n\n\t\tqueue<pair< pair<int, int>, pair<int, int > > > que;\n\n\t\tcin >> w >> h;\n\n\t\tif (w == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tvector<string> left(h), right(h);\n\n\t\tFOR(i, 0, h-1) {\n\t\t\tcin >> left[i] >> right[i];\n\t\t}\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (left[i][j] == 'L') {\n\t\t\t\t\tlx = j;\n\t\t\t\t\tly = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (right[i][j] == 'R') {\n\t\t\t\t\trx = j;\n\t\t\t\t\try = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (left[i][j] == '%') {\n\t\t\t\t\tlgx = j;\n\t\t\t\t\tlgy = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lgx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (right[i][j] == '%') {\n\t\t\t\t\trgx = j;\n\t\t\t\t\trgy = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rgx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdp[ly][lx][ry][rx] = 1;\n\n\t\t//cout << lgy << \" \" << lgx << \" \" << rgy << \" \" << rgx << endl;\n\t\t//cout << endl;\n\n\t\t\n\t\t\n\t\tque.push(make_pair(make_pair(ly,lx),make_pair(ry,rx)));\n\n\t\tbool leftwall = false;\n\t\tbool rightwall = false;\n\n\n\t\twhile (!que.empty()) {\n\t\t\tPair = que.front();\n\t\t\t\n\t\t\tque.pop();\n\t\t\tly = Pair.first.first;\n\t\t\tlx = Pair.first.second;\n\t\t\try = Pair.second.first;\n\t\t\trx = Pair.second.second;\n\t\t\t//cout <<\"-\"<< ly << \" \" << lx << \" \" << ry << \" \" << rx << endl;\n\n\n\t\t\tFOR(i, 0, 3) {\n\t\t\t\tleftwall = false;\n\t\t\t\trightwall = false;\n\n\t\t\t\tif (ly + dy[i]<0 || ly + dy[i]>h - 1 || lx - dx[i]<0 || lx - dx[i]>w - 1) {\n\t\t\t\t\tleftwall = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (left[ly + dy[i]][lx - dx[i]] == '#') {\n\t\t\t\t\t\tleftwall = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (ry + dy[i]<0 || ry + dy[i]>h - 1 || rx + dx[i]<0 || rx + dx[i]>w - 1) {\n\t\t\t\t\trightwall = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (right[ry + dy[i]][rx + dx[i]] == '#') {\n\t\t\t\t\t\trightwall = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (leftwall == true) {\n\t\t\t\t\tif (rightwall == true) {\n\t\t\t\t\t\t//no\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (dp[ly][lx][ry + dy[i]][rx + dx[i]] != 1) {\n\t\t\t\t\t\t\tdp[ly][lx][ry + dy[i]][rx + dx[i]] = 1;\n\t\t\t\t\t\t\tif (!(ry + dy[i] == rgy && rx + dx[i] == rgx)) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tque.push(make_pair(make_pair(ly, lx), make_pair(ry + dy[i], rx + dx[i])));\n\n\t\t\t\t\t\t\t\t//cout << ly << \" \" << lx << \" \" << ry + dy[i] << \" \" << rx + dx[i] << endl;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (rightwall == true) {\n\t\t\t\t\t\tif (dp[ly + dy[i]][lx - dx[i]][ry][rx] != 1) {\n\t\t\t\t\t\t\tdp[ly + dy[i]][lx - dx[i]][ry][rx] = 1;\n\t\t\t\t\t\t\tif (!(ly + dy[i] == lgy && lx - dx[i] == lgx)) {\n\t\t\t\t\t\t\t\tque.push(make_pair(make_pair(ly + dy[i], lx - dx[i]), make_pair(ry, rx)));\n\t\t\t\t\t\t\t\t//cout << ly + dy[i] << \" \" << lx - dx[i] << \" \" << ry << \" \" << rx << endl;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (dp[ly + dy[i]][lx - dx[i]][ry + dy[i]][rx + dx[i]] != 1) {\n\t\t\t\t\t\t\tdp[ly + dy[i]][lx - dx[i]][ry + dy[i]][rx + dx[i]] = 1;\n\t\t\t\t\t\t\tif (!(ly + dy[i] == lgy && lx - dx[i] == lgx) && !(ry + dy[i] == rgy && rx + dx[i] == rgx)) {\n\t\t\t\t\t\t\t\tque.push(make_pair(make_pair(ly + dy[i], lx - dx[i]), make_pair(ry + dy[i], rx + dx[i])));\n\t\t\t\t\t\t\t\t//cout << ly + dy[i] << \" \" << lx - dx[i] << \" \" << ry + dy[i] << \" \" << rx + dx[i] << endl;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t}\n\n\t\t\t//cout << endl;\n\n\t\t\t\n\t\t\tif (dp[lgy][lgx][rgy][rgx] == 1) {\n\t\t\t\tflag = true;\n\t\t\t\t//cout << \"a\" << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (dp[lgy][lgx][rgy][rgx] == 1||flag==true) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t\t\n\n\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<set>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define ck(a,b) (0<=(a)&&(a)<b)\nusing namespace std;\nint dx[]={-1,1,0,0},dy[]={0,0,-1,1};\nstruct S{\n\tint lx,ly,rx,ry;\n\tS(int a,int b,int c,int d):lx(a),ly(b),rx(c),ry(d){}\n};\nbool operator<(const S &a,const S &b){\n\tif(a.lx!=b.lx)return a.lx<b.lx;\n\tif(a.ly!=b.ly)return a.ly<b.ly;\n\treturn a.rx!=b.rx?a.rx<b.rx:a.ry<b.ry;\n}\nint main(){\n\tint w,h;\n\twhile(cin>>w>>h,w){\n\t\tint lx,ly,rx,ry;\n\t\tstring cavel[h],caver[h];\n\t\trep(i,h)cin>>cavel[i]>>caver[i];\n\t\trep(i,h)rep(j,w){\n\t\t\tif(cavel[i][j]=='L')ly=j,lx=i,cavel[i][j]='.';\n\t\t\tif(caver[i][j]=='R')ry=j,rx=i,caver[i][j]='.';\n\t\t}\n\t\tvector<S> F; set<S> V;\n\t\tF.push_back(S(lx,ly,rx,ry)); V.insert(S(lx,ly,rx,ry));\n\t\tint goal=0;\n\t\twhile(!F.empty()&&!goal){\n\t\t\tvector<S> nF;\n\t\t\trep(i,F.size()){\n\t\t\t\trep(d,4){\n\t\t\t\t\tint clx=F[i].lx,cly=F[i].ly,crx=F[i].rx,cry=F[i].ry;\n\t\t\t\t\tint nlx=clx+dx[d],nly=cly+dy[d],nrx=crx-dx[d],nry=cry+dy[d];\n\t\t\t\t\tif(!ck(nlx,w)||!ck(nly,h)||cavel[nly][nlx]=='#')nlx=clx,nly=cly;\n\t\t\t\t\tif(!ck(nrx,w)||!ck(nry,h)||caver[nry][nrx]=='#')nrx=crx,nry=cry;\n\t\t\t\t\tif(nlx==clx&&nly==cly&&nrx==crx&&nry==cry)continue;\n\t\t\t\t\tif((cavel[nly][nlx]=='%')+(caver[nry][nrx]=='%')==1)continue;\n\t\t\t\t\tif(cavel[nly][nlx]=='%'&&caver[nry][nrx]=='%'){\n\t\t\t\t\t\tgoal=1; goto END;\n\t\t\t\t\t}\n\t\t\t\t\tif(V.find(S(nlx,nly,nrx,nry))==V.end()){\n\t\t\t\t\t\tnF.push_back(S(nlx,nly,nrx,nry));\n\t\t\t\t\t\tV.insert(S(nlx,nly,nrx,nry));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tF=nF;\n\t\t}\n\t\tEND:cout<<(goal?\"Yes\":\"No\")<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> stat;\n\nint w, h;\nbool vis[64][64][64][64];\npii ls, lg, rs, rg;\nstat start, goal;\nconst int dx[]={0, 0, 1, -1}, dy[]={1, -1, 0, 0};\n\ninline bool border(pii p){\n\t\n\treturn 0<=p.first&&p.first<w&&0<=p.second&&p.second<h;\n}\n\nstring solve(vector<string> left, vector<string> right){\n\t\n\tstart = make_pair(ls, rs);\n\tgoal = make_pair(lg, rg);\n\t\n\tqueue<stat> qu;\n\tqu.push(start);\n\t\n\tmemset(vis, 0, sizeof(vis));\n\tvis[ls.first][ls.second][rs.first][rs.second] = true;\n\t\n\twhile(!qu.empty()){\n\t\n\t\tpii lnx, rnx, lnw, rnw;\n\t\t\n\t\tstat now = qu.front(), nxt;\n\t\tlnw = now.first;\n\t\trnw = now.second;\n\t\t\n\t\tqu.pop();\n\t\t\n\t\tfor(int i=0; i<4; ++i){\n\t\t\t\n\t\t\tlnx = make_pair(lnw.first + dx[i], lnw.second + dy[i]);\n\t\t\trnx = make_pair(rnw.first - dx[i], rnw.second + dy[i]);\n\t\t\t\n\t\t\tif(!border(lnx)||left[lnx.second][lnx.first]=='#')\n\t\t\t\tlnx = lnw;\n\t\t\t\n\t\t\tif(!border(rnx)||right[rnx.second][rnx.first]=='#')\n\t\t\t\trnx = rnw;\n\t\t\t\n\t\t\tnxt = make_pair(lnx, rnx);\n\t\t\t\n\t\t\tif(nxt == goal)\n\t\t\t\treturn \"Yes\";\n\t\t\t\n\t\t\tif(!vis[lnx.first][lnx.second][rnx.first][rnx.second]){\n\t\t\t\t\n\t\t\t\tvis[lnx.first][lnx.second][rnx.first][rnx.second] = true;\n\t\t\t\tqu.push(nxt);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn \"No\";\n}\n\t\nint main(){\n\t\n\twhile(cin>>w>>h, (w||h)){\n\t\t\n\t\tvector<string> left, right;\n\t\t\n\t\tfor(int i=0; i<h; ++i){\n\t\t\t\n\t\t\tstring l, r;\n\t\t\tcin >> l >> r;\n\t\t\t\n\t\t\tleft.push_back(l);\n\t\t\tright.push_back(r);\n\t\t}\n\t\t\n\t\tfor(int y=0; y<h; ++y){\n\t\t\tfor(int x=0; x<w; ++x){\n\t\t\t\n\t\t\t\tif(left[y][x] == 'L')\n\t\t\t\t\tls = make_pair(x, y);\n\t\t\t\tif(left[y][x] == '%')\n\t\t\t\t\tlg = make_pair(x, y);\n\t\t\t\tif(right[y][x] == 'R')\n\t\t\t\t\trs = make_pair(x, y);\n\t\t\t\tif(right[y][x] == '%')\n\t\t\t\t\trg = make_pair(x, y);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout <<\tsolve(left, right) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> P;\n\nstruct state{\n    int ly, lx, ry, rx;\n};\nint w, h;\nbool contain(int y, int x){\n    return (0 <= y && y < h && 0 <= x && x < w);\n}\nint dy[4] = {1, -1, 0, 0};\nint dx[4] = {0, 0, 1, -1};\nbool f[51][51][51][51];\n\nsigned main(){\n    while(1){\n        cin >> w >> h;\n        if(w + h == 0) break;\n        vector<string> s(h), t(h);\n        bool ans = false;\n        int lsy, lsx, lgy, lgx, rsy, rsx, rgy, rgx;\n        rep(i, 0, h){\n            cin >> s[i] >> t[i];\n            rep(j, 0, w){\n                if(s[i][j] == 'L'){ lsy = i; lsx = j;}\n                if(s[i][j] == '%'){ lgy = i; lgx = j;}\n                if(t[i][j] == 'R'){ rsy = i; rsx = j;}\n                if(t[i][j] == '%'){ rgy = i; rgx = j;}\n            }\n        }\n        queue<state> q;\n        q.push((state){lsy, lsx, rsy, rsx});\n        rep(i, 0, 51) rep(j, 0, 5) rep(k, 0, 51) rep(l, 0, 51) f[i][j][k][l] = false;\n        f[lsy][lsx][rsy][rsx] = true;\n        while(!q.empty()){\n            state p = q.front(); q.pop();\n            // cout << p.ly << \" \" << p.lx << \" \" << p.ry << \" \" << p.rx << endl;\n            rep(i, 0, 4){\n                int nly = p.ly + dy[i];\n                int nlx = p.lx + dx[i];\n                int nry = p.ry + dy[i];\n                int nrx = p.rx - dx[i];\n                if(!contain(nly, nlx) || s[nly][nlx] == '#'){ nly = p.ly; nlx = p.lx;}\n                if(!contain(nry, nrx) || t[nry][nrx] == '#'){ nry = p.ry; nrx = p.rx;}\n                if(f[nly][nlx][nry][nrx]) continue;\n                f[nly][nlx][nry][nrx] = true;\n                if(s[nly][nlx] == '%' && t[nry][nrx] == '%'){ ans = true; break;}\n                else if(s[nly][nlx] == '%' || t[nry][nrx] == '%') continue;\n                q.push((state){nly, nlx, nry, nrx});\n            }\n        }\n        cout << (ans ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n#define REP(i, a, n) for(int i=a; i<n; i++)\n\nbool hist[51][51][51][51];\n\nstruct State {\n\tint xL, yL, xR, yR;\n};\n\nint main() {\n\tint w, h;\n\n\tint dx[4] = { 0, 1, 0, -1 }; // ????????????\n\tint dy[4] = { -1, 0, 1, 0 };\n\n\twhile (cin >> w >> h, w || h) {\n\t\tState st;\n\t\tchar Len[51][51];\n\t\tchar Rin[51][51];\n\t\t//bool hist[51][51][51][51] = { false };\n\t\t//hist[51][51][51][51] = { false };\n\t\tmemset(hist, false, sizeof hist);\n\n\t\t/* crate maze */\n\t\tREP(i, 0, h) {\n\t\t\tREP(j, 0, w) {\n\t\t\t\tcin >> Len[i][j];\n\t\t\t\tif (Len[i][j] == 'L') {\n\t\t\t\t\tst.yL = i;\n\t\t\t\t\tst.xL = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(j, 0, w) {\n\t\t\t\tcin >> Rin[i][j];\n\t\t\t\tif (Rin[i][j] == 'R') {\n\t\t\t\t\tst.yR = i;\n\t\t\t\t\tst.xR = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* BFS */\n\t\tqueue<State> qu;\n\t\tqu.push(st);\n\t\thist[st.yL][st.xL][st.yR][st.xR] = true;\n\t\t//cout << st.yL << \" \" << st.xL << \" \" << st.yR << \" \" << st.xR << endl;\n\t\tbool flag = false;\n\n\t\twhile (!qu.empty()) {\n\t\t\tState q = qu.front();\n\t\t\tqu.pop();\n\n\t\t\tint yl = q.yL, xl = q.xL, yr = q.yR, xr = q.xR;\n\t\t\tif (Len[yl][xl] == '%' && Rin[yr][xr] == '%') {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (Len[yl][xl] == '%' || Rin[yr][xr] == '%') continue;\n\t\t\tfor (int k = 0; k<4; ++k) {\n\t\t\t\tint yyl = yl + dy[k], xxl = xl + dx[k];\n\t\t\t\tint yyr, xxr;\n\t\t\t\tyyr = yr + dy[k];\n\t\t\t\txxr = xr + dx[k] * (-1);\n\n\t\t\t\tif (yyl<0 || yyl >= h || xxl<0 || xxl >= w) {\n\t\t\t\t\tyyl = yl;\n\t\t\t\t\txxl = xl;\n\t\t\t\t}\n\t\t\t\telse if (Len[yyl][xxl] == '#') {\n\t\t\t\t\tyyl = yl;\n\t\t\t\t\txxl = xl;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (yyr<0 || yyr >= h || xxr<0 || xxr >= w) {\n\t\t\t\t\tyyr = yr;\n\t\t\t\t\txxr = xr;\n\t\t\t\t}\n\t\t\t\telse if (Rin[yyr][xxr] == '#') {\n\t\t\t\t\tyyr = yr;\n\t\t\t\t\txxr = xr;\n\t\t\t\t}\n\t\t\t\tif (hist[yyl][xxl][yyr][xxr]) continue;\n\t\t\t\thist[yyl][xxl][yyr][xxr] = true;\n\t\t\t\tqu.push({ yyl, xxl, yyr, xxr });\n\t\t\t\t//cout << yyl << \" \" << xxl << \" \" << yyr << \" \" << xxr << endl;\n\t\t\t}\n\t\t}\n\t\tif (flag) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t\t/*\n\t\tREP(i, 0, h) {\n\t\t\tREP(j, 0, w) {\n\t\t\t\tcout << Len[i][j];\n\t\t\t}\n\t\t\tcout << \" \";\n\t\t\tREP(j, 0, w) {\n\t\t\t\tcout << Rin[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <string>\n#include <vector>\n#include <set>\nusing namespace std;\n\ntypedef pair<pair<int,int>,pair<int,int> > pii;\n#define REP(i,n) for(int i=0; i<n; ++i)\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\n\nint main() {\n    int w,h;\n    while(cin>>w>>h, w|h) {\n        vector<string> left(h),right(h);\n        REP(i,h) cin>>left[i]>>right[i];\n\n        int lx,ly,rx,ry;\n        int glx,gly,grx,gry;\n        REP(i,h) REP(j,w) {\n            if(left[i][j] == 'L') lx = j, ly = i, left[i][j] = '.';\n            if(left[i][j] == '%') glx = j, gly = i, left[i][j] = '.';\n        }\n        REP(i,h) REP(j,w) {\n            if(right[i][j] == 'R') rx = j, ry = i, right[i][j] = '.';\n            if(right[i][j] == '%') grx = j, gry = i, right[i][j] = '.';\n        }\n\n        set<pii> state;\n        queue<pii> Q;\n        Q.push(make_pair(make_pair(lx,ly),make_pair(rx,ry)));\n        while(!Q.empty()) {\n            pii now = Q.front(); Q.pop();\n            if(now.first.first == glx && now.first.second == gly\n               && now.second.first == grx && now.second.second == gry) {\n                goto SUCCESS;\n            }\n            if(state.find(now) != state.end()) continue;\n            state.insert(now);\n            int lx = now.first.first, ly = now.first.second;\n            int rx = now.second.first, ry = now.second.second;\n            for(int i=0; i<4; ++i) {\n                int nlx = lx + dx[i],nly = ly + dy[i];\n                int nrx = rx + dx[(i+2)%4],nry = ry + dy[i];\n                if(nlx < 0 || nlx >= w || nrx < 0 || nrx >= w) continue;\n                if(nry < 0 || nry >= h || nly < 0 || nly >= h) continue;\n                if(left[nly][nlx] == '#') {\n                    nly = ly;\n                    nlx = lx;\n                }\n                if(right[nry][nrx] == '#') {\n                    nry = ry;\n                    nrx = rx;\n                }\n                Q.push(make_pair(make_pair(nlx,nly),make_pair(nrx,nry)));\n            }\n        }\n\n        goto BAD;\n    SUCCESS:\n        cout<<\"Yes\"<<endl;\n        continue;\n    BAD:\n        cout<<\"No\"<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\n\ntemplate<class T>\ninline bool chmax(T &a, const T &b) {\n    if(a<b) {\n        a=b;\n        return true;\n    }\n\n    return false;\n}\ntemplate<class T>\ninline bool chmin(T &a, const T &b) {\n    if(a>b) {\n        a=b;\n        return true;\n    }\n\n    return false;\n}\n\nint W,H;\nstring roomL[51],roomR[51];\n\nbool range_check(int y,int x) {\n    if(y<0||x<0) return false;\n    if(H<=y||W<=x) return false;\n\n    return true;\n}\n\nbool ok(P len,P rin) {\n    bool visited[51][51][51][51]={};\n    visited[len.fr][len.sc][rin.fr][rin.sc]=true;\n    queue<PP> que;\n    que.push(PP(len,rin));\n\n    while(que.size()) {\n        PP pp=que.front(); que.pop();\n        P next_len=pp.fr;\n        P next_rin=pp.sc;\n\n        //printf(\"[debug] %d %d %d %d\\n\",next_len.fr,next_len.sc,next_rin.fr,next_rin.sc);\n\n        if(roomL[next_len.fr][next_len.sc]=='%' && roomR[next_rin.fr][next_rin.sc]=='%') {\n            return true;\n        }\n        if(roomL[next_len.fr][next_len.sc]=='%' || roomR[next_rin.fr][next_rin.sc]=='%') {\n            visited[next_len.fr][next_len.sc][next_rin.fr][next_rin.sc]=false;\n            continue;\n        }\n        rep(i,4) {\n            next_len=pp.fr;\n            next_rin=pp.sc;\n\n            if(range_check(next_len.fr+dy[i],next_len.sc+dx[i]) && roomL[next_len.fr+dy[i]][next_len.sc+dx[i]]!='#') {\n                next_len.fr+=dy[i];\n                next_len.sc+=dx[i];\n            }\n            if(range_check(next_rin.fr+dy[i],next_rin.sc-dx[i]) && roomR[next_rin.fr+dy[i]][next_rin.sc-dx[i]]!='#') {\n                next_rin.fr+=dy[i];\n                next_rin.sc-=dx[i];\n            }\n\n            if(!visited[next_len.fr][next_len.sc][next_rin.fr][next_len.sc]) {\n                visited[next_len.fr][next_len.sc][next_rin.fr][next_len.sc]=true;\n                que.push(PP(next_len,next_rin));\n            }\n        }\n    }\n\n    return false;\n}\n\nvoid solve() {\n    rep(y,H) cin>>roomL[y]>>roomR[y];\n    P len,rin;\n    rep(y,H) rep(x,W) {\n        if(roomL[y][x]=='L') len=P(y,x);\n        if(roomR[y][x]=='R') rin=P(y,x);\n    }\n    if(ok(len,rin)) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n}\n\nint main() {\n    while(cin>>W>>H) {\n        if(!W) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int MAX = 55;\nchar rm[MAX][MAX], lm[MAX][MAX];\nint w, h;\n\nstruct Point{\n    int x,y;\n    bool operator == ( const Point &right ) const {\n        if(right.x == x && right.y == y) return 1;\n        else return 0;\n    }\n    bool operator < ( const Point &right ) const {\n        if(x < right.x) return 1;\n        else if(x == right.x && y < right.y) return 1;\n        else return 0;\n    }\n};\nset<pair<Point,Point>> s;\nPoint rg, lg;\nbool ans;\n\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\nvoid dfs(Point rp, Point lp){\n    s.insert(make_pair(rp,lp));\n    if(rg == rp && lg == lp) ans = true;\n    rep(i,4){\n        int lnx = lp.x + dx[i];\n        int lny = lp.y + dy[i];\n        int rnx = rp.x + dx[i] * -1;\n        int rny = rp.y + dy[i];\n        if( (lny < 0 || lny >= h || lnx < 0 || lnx >= w) || lm[lny][lnx] == '#'){\n            lnx = lp.x;\n            lny = lp.y;\n        }\n        if( (rny < 0 || rny >= h || rnx < 0 || rnx >= w) || rm[rny][rnx] == '#'){\n            rnx = rp.x;\n            rny = rp.y;\n        }\n        if(s.count(make_pair(Point{rnx,rny}, Point{lnx,lny}))) continue;\n        dfs(Point{rnx,rny}, Point{lnx,lny});\n    }\n}\n\nint main(){\n    while(cin >> w >> h, w){\n        ans = false;\n        s.clear();\n        Point rp, lp;\n        rep(i,h){\n            rep(j,w * 2){\n                if(j < w){\n                    cin >> lm[i][j];\n                }else{\n                    cin >> rm[i][j - w];\n                }\n            }\n        }\n        rep(i,h){\n            rep(j,w){\n                if(lm[i][j] == 'L'){\n                    lp = Point{j,i};\n                }\n                if(lm[i][j] == '%'){\n                    lg = Point{j,i};\n                }\n            }\n        }\n        rep(i,h){\n            rep(j,w){\n                if(rm[i][j] == 'R'){\n                    rp = Point{j,i};\n                }\n                if(rm[i][j] == '%'){\n                    rg = Point{j,i};\n                }\n            }\n        }\n        dfs(rp,lp);\n        if(ans) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dh[]={1,0,-1,0};\nint dw[]={0,1,0,-1};\nint w,h;\n\nvoid insert(vector<vector<vector<vector<bool>>>> &dp,pair<pair<int,int>,pair<int,int>> p){\n    auto x=p.first;\n    auto y=p.second;\n    dp[x.first][x.second][y.first][y.second]=true;\n}\n\nbool count(vector<vector<vector<vector<bool>>>> &dp,pair<pair<int,int>,pair<int,int>> p){\n    auto x=p.first;\n    auto y=p.second;\n    return dp[x.first][x.second][y.first][y.second];\n}\n\nbool isrange(int x,int y){return 0<=x && x<h && 0<=y && y<w;};\nint main(){\n    \n    while(cin>>w>>h,w){\n        vector<string> rl(h),rr(h);\n        for(int i=0;i<h;i++){\n            cin>>rl[i]>>rr[i];\n        }\n        pair<int,int> lp;\n        pair<int,int> rp;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(rl[i][j]=='L') lp={i,j};\n                if(rr[i][j]=='R') rp={i,j};\n            }\n        }\n        stack<pair<pair<int,int>,pair<int,int>>> que;\n        que.push({lp,rp});\n        vector<vector<vector<vector<bool>>>> dp(h,vector<vector<vector<bool>>>(w,vector<vector<bool>>(h,vector<bool>(w,0))));\n        insert(dp,{lp,rp});\n        auto move=[&rl,&rr](int x,int dx,int y,int dy,bool isr){\n            if(!isrange(x+dx,y+dy)){\n                return make_pair(min(max(x+dx,0),h-1),min(max(y+dy,0),w-1));\n            }\n            if(isr){\n                if(rr[x+dx][y+dy]=='#') return make_pair(x,y);\n                else return make_pair(x+dx,y+dy);\n            }\n            else{\n                if(rl[x+dx][y+dy]=='#') return make_pair(x,y);\n                else return make_pair(x+dx,y+dy);\n            }\n        };\n        while(!que.empty()){\n            auto p=que.top();\n            que.pop();\n            for(int i=0;i<4;i++){\n                auto tol=move(p.first.first,dh[i],p.first.second,dw[i],0);\n                auto tor=move(p.second.first,dh[i],p.second.second,dw[(i+2)%2],1);\n                pair<pair<int,int>,pair<int,int>> tost={tol,tor};\n                if(count(dp,tost)) continue;\n                insert(dp,tost);\n                que.push(tost);\n            }\n        }\n        pair<int,int> obl;\n        pair<int,int> obr;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(rl[i][j]=='%') obl={i,j};\n                if(rr[i][j]=='%') obr={i,j};\n            }\n        }\n        if(count(dp,{obl,obr})) cout<<\"Yes\"<<endl;\n        else cout<<\"No\"<<endl;\n    }\n\n\n\n    return 0;\n}   "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<functional>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cassert>\n#include<ctime>\nusing namespace std;\n\n#define mind(a,b) (a>b?b:a)\n#define maxd(a,b) (a>b?a:b)\n#define absd(x) (x<0?-(x):x)\n#define pow2(x) ((x)*(x))\n#define rep(i,n) for(int i=0; i<n; ++i)\n#define repr(i,n) for(int i=n-1; i>=0; --i)\n#define repl(i,s,n) for(int i=s; i<=n; ++i)\n#define replr(i,s,n) for(int i=n; i>=s; --i)\n#define repf(i,s,n,j) for(int i=s; i<=n; i+=j)\n#define repe(e,obj) for(auto e : obj)\n\n#define SP << \" \" <<\n#define COL << \" : \" <<\n#define COM << \", \" <<\n#define ARR << \" -> \" <<\n#define PNT(STR) cout << STR << endl\n#define POS(X,Y) \"(\" << X << \", \" << Y << \")\"\n#define DEB(A) \" (\" << #A << \") \" << A\n#define DEBREP(i,n,val) for(int i=0; i<n; ++i) cout << val << \" \"; cout << endl\n#define ALL(V) (V).begin(), (V).end()\n#define INF 1000000007\n#define INFLL 1000000000000000007LL\n#define EPS 1e-9\n\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define P_TYPE int\ntypedef pair<P_TYPE, P_TYPE> P;\ntypedef pair<P, P_TYPE> PI;\ntypedef pair<P_TYPE, P> IP;\ntypedef pair<P, P> PP;\ntypedef priority_queue<P, vector<P>, greater<P> > pvqueue;\n\n#define SZ 53\nint used[SZ][SZ][SZ][SZ];\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, -1, 0, 1};\n\nchar ml[SZ][SZ], mr[SZ][SZ];\n\nint main() {\n  int w, h;\n  while(cin >> w >> h && w+h) {\n    int lx, ly, rx, ry;\n    rep(i, h) {\n      rep(j, w) {\n        cin >> ml[i][j];\n        if(ml[i][j] == 'L') {\n          lx = j; ly = i;\n        }\n      }\n      rep(j, w) {\n        cin >> mr[i][j];\n        if(mr[i][j] == 'R') {\n          rx = j; ry = i;\n        }\n      }\n    }\n    used[ly][lx][ry][rx] = 1;\n    queue<PP> que;\n    que.push(PP(P(lx, ly), P(rx, ry)));\n    bool ok = false;\n    while(!que.empty()) {\n      PP pp = que.front(); que.pop();\n      P &lp = pp.first, &rp = pp.second;\n      int lx = lp.first, ly = lp.second, rx = rp.first, ry = rp.second;\n      rep(k, 4) {\n        int x = dx[k], y = dy[k];\n        int n_lx = lx + x;\n        if(!(0 <= n_lx && n_lx < w)) n_lx = lx;\n        int n_ly = ly + y;\n        if(!(0 <= n_ly && n_ly < h)) n_ly = ly;\n        if(ml[n_ly][n_lx] == '#') {\n          n_lx = lx; n_ly = ly;\n        }\n        int n_rx = rx - x;\n        if(!(0 <= n_rx && n_rx < w)) n_rx = rx;\n        int n_ry = ry + y;\n        if(!(0 <= n_ry && n_ry < h)) n_ry = ry;\n        if(mr[n_ry][n_rx] == '#') {\n          n_rx = rx; n_ry = ry;\n        }\n        if(ml[n_ly][n_lx] == '%' || mr[n_ry][n_rx] == '%') {\n          if(ml[n_ly][n_lx] == '%' && mr[n_ry][n_rx] == '%') {\n            ok = true;\n          }\n          continue;\n        }\n        if(!used[n_ly][n_lx][n_ry][n_rx]) {\n          used[n_ly][n_lx][n_ry][n_rx] = 1;\n          que.push(PP(P(n_lx, n_ly), P(n_rx, n_ry)));\n        }\n      }\n    }\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\nconst int dy[] = {0, -1, 0, 1};\nconst int dx[] = {1, 0, -1, 0};\nint W, H;\nstring L[50], R[50];\nint dis[50][50][50][50];\nconst int INF = 1 << 30;\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while (cin >> W >> H, W) {\n        int lsy, lsx, rsy, rsx;\n        int lgy, lgx, rgy, rgx;\n        REP (i, H) {\n            cin >> L[i] >> R[i];\n            REP (j, W) {\n                if (L[i][j] == 'L') lsy = i, lsx = j;\n                if (R[i][j] == 'R') rsy = i, rsx = j;\n                if (L[i][j] == '%') lgy = i, lgx = j;\n                if (R[i][j] == '%') rgy = i, rgx = j;\n            }\n        }\n        fill_n((int*)dis, 50 * 50 * 50 * 50, INF);\n        using P = tuple<int, int, int, int>;\n        dis[lsy][lsx][rsy][rsx] = 0;\n        queue<P> que;\n        que.emplace(lsy, lsx, rsy, rsx);\n        int ans = INF;\n        while (!que.empty()) {\n            int ly, lx, ry, rx;\n            tie(ly, lx, ry, rx) = que.front(); que.pop();\n            // cout << ly << \" \" << lx << \" \" << ry << \" \" << rx << endl;\n            REP (i, 4) {\n                int nly = ly + dy[i], nlx = lx + dx[i];\n                int nry = ry + dy[i], nrx = rx - dx[i];\n                if (!(nly >= 0 && nly < H && nlx >= 0 && nlx < W) || L[nly][nlx] == '#') nly = ly, nlx = lx;\n                if (!(nry >= 0 && nry < H && nrx >= 0 && nrx < W) || R[nry][nrx] == '#') nry = ry, nrx = rx;\n                if ((L[nly][nlx] == '%') ^ (R[nry][nrx] == '%')) continue;\n                if (dis[nly][nlx][nry][nrx] > dis[ly][lx][ry][rx] + 1) {\n                    dis[nly][nlx][nry][nrx] = dis[ly][lx][ry][rx] + 1;\n                    que.emplace(nly, nlx, nry, nrx);\n                }\n            }\n            if (ans != INF) break;\n        }\n        cout << (dis[lgy][lgx][rgy][rgx] == INF ? \"No\" : \"Yes\") << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dh[]={1,0,-1,0};\nint dw[]={0,1,0,-1};\nint w,h;\n\nvoid insert(vector<vector<vector<vector<bool>>>> &dp,pair<pair<int,int>,pair<int,int>> p){\n    auto x=p.first;\n    auto y=p.second;\n    dp[x.first][x.second][y.first][y.second]=true;\n}\n\nbool count(vector<vector<vector<vector<bool>>>> &dp,pair<pair<int,int>,pair<int,int>> p){\n    auto x=p.first;\n    auto y=p.second;\n    return dp[x.first][x.second][y.first][y.second];\n}\n\nbool isrange(int x,int y){return 0<=x && x<h && 0<=y && y<w;};\nint main(){\n    \n    while(cin>>w>>h,w){\n        vector<string> rl(h),rr(h);\n        for(int i=0;i<h;i++){\n            cin>>rl[i]>>rr[i];\n        }\n        pair<int,int> lp;\n        pair<int,int> rp;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(rl[i][j]=='L') lp={i,j};\n                if(rr[i][j]=='R') rp={i,j};\n            }\n        }\n        stack<pair<pair<int,int>,pair<int,int>>> que;\n        que.push({lp,rp});\n        vector<vector<vector<vector<bool>>>> dp(h,vector<vector<vector<bool>>>(w,vector<vector<bool>>(h,vector<bool>(w,0))));\n        insert(dp,{lp,rp});\n        auto move=[&rl,&rr](int x,int dx,int y,int dy,bool isr){\n            if(!isrange(x+dx,y+dy)){\n                return make_pair(x,y);\n            }\n            if(isr){\n                if(rr[x+dx][y+dy]=='#') return make_pair(x,y);\n                else return make_pair(x+dx,y+dy);\n            }\n            else{\n                if(rl[x+dx][y+dy]=='#') return make_pair(x,y);\n                else return make_pair(x+dx,y+dy);\n            }\n        };\n        while(!que.empty()){\n            auto p=que.top();\n            que.pop();\n            for(int i=0;i<4;i++){\n                auto tol=move(p.first.first,dh[i],p.first.second,dw[i],0);\n                auto tor=move(p.second.first,dh[i],p.second.second,dw[(i+2)%2],1);\n                pair<pair<int,int>,pair<int,int>> tost={tol,tor};\n                if(count(dp,tost)) continue;\n                insert(dp,tost);\n                que.push(tost);\n            }\n        }\n        pair<int,int> obl;\n        pair<int,int> obr;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(rl[i][j]=='%') obl={i,j};\n                if(rr[i][j]=='%') obr={i,j};\n            }\n        }\n        if(count(dp,{obl,obr})) cout<<\"Yes\"<<endl;\n        else cout<<\"No\"<<endl;\n    }\n    return 0;\n}   "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint w, h; \nstruct Pos {\n  int x;\n  int y;\n  bool operator==(Pos that) {\n    return x == that.x && y == that.y;\n  }\n  Pos operator+(Pos that) {\n    return {x+that.x, y+that.y};\n  }\n\n  Pos (int xx, int yy) {\n    x = xx; y = yy;\n  }\n};\n\nbool inner(Pos p) {\n  return 0 <= p.x && p.x < w\n      && 0 <= p.y && p.y < h;\n}\n\nPos search_charactor(vector<string> &map, char charactor) {\n  for (int i=0; i<map.size(); i++)\n    for (int l=0; l<map[i].size(); l++)\n      if (map[i][l] == charactor) {\n        map[i][l] = '.';\n        return {l, i};\n      }\n}\n\ntemplate <typename T>\nusing V=vector<T>;\n\nint main(){\n  cin >> w >> h;\n  vector<string> rooml, roomr;\n  rooml.reserve(h); roomr.reserve(h);\n  for (int i=0; i<h; i++) {\n    string l, r;\n    cin >> l >> r; \n    reverse(r.begin(), r.end());\n    rooml.push_back(l);\n    roomr.push_back(r);\n  }\n  Pos len_pos = search_charactor(rooml, 'L');\n  Pos rin_pos = search_charactor(roomr, 'R');\n  Pos len_goal = search_charactor(rooml, '%');\n  Pos rin_goal = search_charactor(roomr, '%');\n\n  queue<pair<Pos, Pos>> q;\n  q.push(make_pair(len_pos, rin_pos));\n  // cout<<\"goal: (\"<<len_goal.x<<\", \"<<len_goal.y<<\") \"<<\"(\"<<rin_goal.x<<\", \"<<rin_goal.y<<\")\"<<endl;\n  // for (int i=0; i<rooml.size(); i++) {\n  //   cout << rooml[i] << \" \" << roomr[i] << endl;\n  // }\n\n  V<V<V<V<bool>>>> already(h, V<V<V<bool>>>(w, V<V<bool>>(h, V<bool>(w, false))));\n  while (!q.empty()) {\n    Pos len = q.front().first;\n    Pos rin = q.front().second; \n    q.pop();\n    // cout<<\"(\"<<len.x<<\", \"<<len.y<<\") \"<<\"(\"<<rin.x<<\", \"<<rin.y<<\")\"<<endl;\n\n    if (len==len_goal && rin==rin_goal) {\n      cout << \"Yes\" << endl;\n      return 0;\n    }\n\n    for (Pos np: {Pos(0,1), Pos(0,-1), Pos(1,0), Pos(-1,0)}) {\n      Pos l = (inner(np+len) && rooml[np.y+len.y][np.x+len.x] == '.') ? len + np : len;\n      Pos r = (inner(np+rin) && roomr[np.y+rin.y][np.x+rin.x] == '.') ? rin + np : rin;\n      if (!already[l.y][l.x][r.y][r.x] && inner(l) && inner(r) \n        && rooml[l.y][l.x] == '.' && roomr[r.y][r.x] == '.') {\n        q.push(make_pair(l, r));\n        already[l.y][l.x][r.y][r.x] = true;\n      }\n    }\n  }\n  cout << \"No\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\nusing namespace std;\nstruct po{int lx,ly,rx,ry;};\nint w,h;\nstring mp[2][51];\n\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\n\nbool bfs(int lx,int ly,int rx,int ry){\n  bool visited[51][51][51][51]={};\n  queue <po> Q;\n  Q.push((po){lx,ly,rx,ry});\n  while(!Q.empty()){\n    po t=Q.front();Q.pop();\n    lx=t.lx, ly=t.ly;\n    rx=t.rx, ry=t.ry;\n    int cnt=(mp[0][ly][lx]=='%')+(mp[1][ry][rx]=='%');\n    if(cnt==2)return true;\n    if(visited[lx][ly][rx][ry]||cnt==1)continue;\n    visited[lx][ly][rx][ry]=1;\n    for(int i=0;i<4;i++){\n      int flg=0;\n      int nlx=lx+dx[i],nly=ly+dy[i];\n      int nrx=rx-dx[i],nry=ry+dy[i];\n      if(nlx<0||nly<0||nlx>=w||nly>=h||mp[0][nly][nlx]=='#')nlx=lx,nly=ly,flg++;\n      if(nrx<0||nry<0||nrx>=w||nry>=h||mp[1][nry][nrx]=='#')nrx=rx,nry=ry,flg++;\n      if(flg==2||visited[nlx][nly][nrx][nry])continue;\n      Q.push((po){nlx,nly,nrx,nry});\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(1){\n    cin >>w>>h;\n    if(!w&&!h)break;\n    for(int i=0;i<h;i++)cin>>mp[0][i]>>mp[1][i];\n    int lx,ly,rx,ry;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(mp[0][i][j]=='L')lx=j,ly=i;\n\tif(mp[1][i][j]=='R')rx=j,ry=i;\n      }\n\n    if(bfs(lx,ly,rx,ry))cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <utility>\n#include <cstring>\nusing namespace std;\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nint main() {\n  while(true) {\n    int W, H; cin >> W >> H;\n    if(W == 0 && H == 0) {\n      break;\n    }\n    char F[H][W+1], G[H][W+1];\n    REP(i,H) {\n      cin >> F[i] >> G[i];\n    }\n    PP start;\n    PP goal;\n    REP(i,H) {\n      REP(j,W) {\n        if(F[i][j] == 'L') start.first = P(i,j);\n        if(G[i][j] == 'R') start.second = P(i,j);\n        if(F[i][j] == '%') goal.first = P(i,j);\n        if(G[i][j] == '%') goal.second = P(i,j);\n      }\n    }\n    queue<PP> Q;\n    Q.push(start);\n    bool vis[W][H][W][H];\n    memset(vis, 0, sizeof(vis));\n    vis[start.first.first][start.first.second][start.second.first][start.second.second] = true;\n    while(!Q.empty()) {\n      PP p = Q.front(); Q.pop();\n      if(p == goal) break;\n      for(int i = 0; i < 4; ++i) {\n        const int dx[4] = { 1, 0, -1, 0 };\n        const int dy[4] = { 0, -1, 0, 1 };\n        int ly = p.first.first + dy[i];\n        int lx = p.first.second + dx[i];\n        int ry = p.second.first + dy[i];\n        int rx = p.second.second - dx[i];\n        if(F[ly][lx] == '#') {\n          ly = p.first.first;\n          lx = p.first.second;\n        }\n        if(ly < 0 || ly >= H || lx < 0 || lx >= W) {\n          ly = p.first.first;\n          lx = p.first.second;\n        }\n        if(G[ly][lx] == '#') {\n          ry = p.second.first;\n          rx = p.second.second;\n        }\n        if(ry < 0 || ry >= H || rx < 0 || rx >= W) {\n          ry = p.second.first;\n          rx = p.second.second;\n        }\n        if(!vis[ly][lx][ry][rx]) {\n          vis[ly][lx][ry][rx] = true;\n          Q.push(PP(P(ly,lx),P(ry,rx)));\n        }\n      }\n    }\n    if(vis[goal.first.first][goal.first.second][goal.second.first][goal.second.second]) {\n      cout << \"Yes\" << endl;\n    }\n    else {\n      cout << \"No\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nconst int INF = 1 << 29;\n\nstruct position {\n    int h, w;\n    position() {}\n    position(int a, int b): h(a), w(b) {}\n};\n\nstruct state {\n    position left, right;\n    int cost;\n    state() {}\n    state(position l, position r, int c): left(l), right(r), cost(c) { }\n};\n\nconst int dh[4] = {1, 0, -1, 0};\nconst int dw[4] = {0, 1, 0, -1};\n\nint W, H;\nstring rooml[55], roomr[55];\n\nint memo[55][55][55][55];\n\nint get_memo(position left, position right) {\n    return memo[left.h][left.w][right.h][right.w];\n}\n\nvoid update_memo(position left, position right, int value) {\n    memo[left.h][left.w][right.h][right.w] = value;\n}\n\nposition move(position p, int dir) {\n    return position(p.h+dh[dir], p.w+dw[dir]);\n}\n\nbool solve() {\n    cin >> W >> H;\n    if (W+H==0) { return false; }\n    for (int j = 0; j < H; ++j) {\n        cin >> rooml[j] >> roomr[j];\n    }\n\n    position sl, sr, gl, gr;\n\n    for (int j = 0; j < H; ++j) {\n        for (int k = 0; k < W; ++k) {\n            if (rooml[j][k] == 'L') { sl.h = j; sl.w = k; }\n            if (roomr[j][k] == 'R') { sr.h = j; sr.w = k; }\n\n            if (rooml[j][k] == '%') { gl.h = j; gl.w = k; }\n            if (roomr[j][k] == '%') { gr.h = j; gr.w = k; }\n        }\n    }\n\n    queue<state> que;\n    que.emplace(sl, sr, 0);\n\n    for (int j = 0; j < H; ++j) {\n        for (int k = 0; k < W; ++k) {\n            for (int l = 0; l < H; ++l) { fill(memo[j][k][l], memo[j][k][l]+W, INF); }\n        }\n    }\n\n    int result = INF;\n    while (!que.empty()) {\n        state st = que.front(); que.pop();\n\n        if (get_memo(st.left, st.right) < st.cost) { continue; }\n\n        if ((rooml[st.left.h][st.left.w] == '%') != (roomr[st.right.h][st.right.w] == '%')) {\n            continue;\n        }\n\n        if ((rooml[st.left.h][st.left.w] == '%') && (roomr[st.right.h][st.right.w] == '%')) {\n            result = st.cost;\n            break;\n        }\n\n        for (int d = 0; d < 4; ++d) {\n            position nexl = move(st.left, d);\n            position nexr = move(st.right, (4-d)%4);\n\n            if (nexl.h < 0 || nexl.h >= H || nexl.w < 0 || nexl.w > W) { nexl = st.left; }\n            if (nexr.h < 0 || nexr.h >= H || nexr.w < 0 || nexr.w > W) { nexr = st.right; }\n\n            if (rooml[nexl.h][nexl.w] == '#') { nexl = st.left; }\n            if (roomr[nexr.h][nexr.w] == '#') { nexr = st.right; }\n\n            if (get_memo(nexl, nexr) > st.cost+1) {\n                update_memo(nexl, nexr, st.cost+1);\n                que.emplace(nexl, nexr, st.cost+1);\n            }\n        }\n    }\n\n    cout << (result == INF ? \"No\" : \"Yes\") << endl;\n\n    return true;\n}\n\nint main() {\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <queue>\nusing namespace std;\nconst int INF = 1000000000;\nint d[50][50][50][50];\nstring f[2][50];\n\nint dx[2][4] = {\n\t{ 1, 0, -1, 0 },\n\t{ -1, 0, 1, 0 }\n};\n\nint dy[2][4] = {\n\t{ 0, 1, 0, -1 },\n\t{ 0, 1, 0, -1 }\n};\n\nint sx[2], sy[2], gx[2], gy[2];\n\n\nstruct State {\n\tint x1, y1, x2, y2;\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint H, W;\n\twhile(cin >> W >> H, H) {\n\t\tfor(int y = 0; y < H; y++) {\n\t\t\tcin >> f[0][y] >> f[1][y];\n\t\t\tfor(int x = 0; x < W; x++) {\n\t\t\t\tif(f[0][y][x] == 'L') sx[0] = x, sy[0] = y;\n\t\t\t\tif(f[1][y][x] == 'R') sx[1] = x, sy[1] = y;\n\t\t\t\tif(f[0][y][x] == '%') gx[0] = x, gy[0] = y;\n\t\t\t\tif(f[1][y][x] == '%') gx[1] = x, gy[1] = y;\n\t\t\t}\n\t\t}\n\n\t\tfill((int*)begin(d), (int*)end(d), INF);\n\n\t\tqueue<State> q;\n\t\tq.push(State{ sx[0], sy[0], sx[1], sy[1] });\n\t\td[sx[0]][sy[0]][sx[1]][sy[1]] = 0;\n\t\twhile(!q.empty()) {\n\t\t\tState s = q.front();\n\t\t\tq.pop();\n\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\tint nx1 = s.x1 + dx[0][k], ny1 = s.y1 + dy[0][k];\n\t\t\t\tif(nx1 < 0 || W <= nx1 || ny1 < 0 || H <= ny1 || f[0][ny1][nx1] == '#') {\n\t\t\t\t\tnx1 = s.x1, ny1 = s.y1;\n\t\t\t\t}\n\t\t\t\tint nx2 = s.x2 + dx[1][k], ny2 = s.y2 + dy[1][k];\n\t\t\t\tif(nx2 < 0 || W <= nx2 || ny2 < 0 || H <= ny2 || f[1][ny2][nx2] == '#') {\n\t\t\t\t\tnx2 = s.x2, ny2 = s.y2;\n\t\t\t\t}\n\t\t\t\tif(d[s.x1][s.y1][s.x2][s.y2] + 1 < d[nx1][ny1][nx2][ny2]) {\n\t\t\t\t\td[nx1][ny1][nx2][ny2] = d[s.x1][s.y1][s.x2][s.y2] + 1;\n\t\t\t\t\tq.push(State{ nx1, ny1, nx2, ny2 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(d[gx[0]][gy[0]][gx[1]][gy[1]] == INF) {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntypedef double weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\ntypedef vector<vector<edge>> Graph;\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\n\n\nint main()\n{\n\tint h, w;\n\twhile (cin >> w >> h, w)\n\t{\n\t\tvs fld1(h), fld2(h);\n\t\tREP(i, h) cin >> fld1[i] >> fld2[i];\n\t\tpii sa, sb, ga, gb;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fld1[i][j] == 'L') sa = pii(i, j);\n\t\t\tif (fld2[i][j] == 'R') sb = pii(i, j);\n\t\t\tif (fld1[i][j] == '%') ga = pii(i, j);\n\t\t\tif (fld2[i][j] == '%') gb = pii(i, j);\n\t\t}\n\t\ttypedef pair<pii, pii> data;\n\t\tset<data> st;\n\t\tqueue<data> que;\n\t\tque.push(data(sa, sb));\n\t\tdata goal = data(ga, gb);\n\t\twhile (que.size())\n\t\t{\n\t\t\tdata tmp = que.front();\n\t\t\tque.pop();\n\t\t\tst.insert(tmp);\n\t\t\tif (tmp == goal) break;\n\t\t\tint lx = tmp.first.first, ly = tmp.first.second;\n\t\t\tint rx = tmp.second.first, ry = tmp.second.second;\n\t\t\tREP(i, 4)\n\t\t\t{\n\t\t\t\tint lnx = lx + dx[i], lny = ly + dy[i];\n\t\t\t\tint rnx = rx + dx[i], rny = ry - dy[i];\n\t\t\t\tif (!valid(lnx, lny, h, w) || fld1[lnx][lny]=='#')\n\t\t\t\t{\n\t\t\t\t\tlnx = lx, lny = ly;\n\t\t\t\t}\t\t\t\t\n\t\t\t\tif (!valid(rnx, rny, h, w) || fld2[rnx][rny] == '#')\n\t\t\t\t{\n\t\t\t\t\trnx = rx, rny = ry;\n\t\t\t\t}\n\t\t\t\tdata next = data(pii(lnx, lny), pii(rnx, rny));\n\t\t\t\tif (st.find(next) != st.end()) continue;\n\t\t\t\tque.push(next);\n\t\t\t}\n\t\t}\n\t\tif (st.find(goal) == st.end()) puts(\"No\");\n\t\telse puts(\"Yes\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\nint main() {\n\tfor (;;) {\n\t\tint W, H; cin >> W >> H;\n\t\tif (W == 0 && H == 0) break;\n\t\tvector< vector<string> > a(2, vector<string>(H + 2, string(W + 2, '#')));\n\t\tfor (int y = 1; y <= H; y++) {\n\t\t\tstring s1, s2; cin >> s1 >> s2;\n\t\t\ta[0][y] = '#' + s1 + '#';\n\t\t\ta[1][y] = '#' + s2 + '#';\n\t\t}\n\t\tvector<char> xs(2), ys(2), xt(2), yt(2);\n\t\tfor (int k = 0; k < 2; k++)\n\t\t\tfor (int y = 1; y <= H; y++)\n\t\t\t\tfor (int x = 1; x <= W; x++){\n\t\t\t\t\tchar& c = a[k][y][x];\n\t\t\t\t\tif (c == 'L' || c == 'R') {\n\t\t\t\t\t\tc = '.';\n\t\t\t\t\t\txs[k] = x; ys[k] = y;\n\t\t\t\t\t}\n\t\t\t\t\telse if (c == '%') {\n\t\t\t\t\t\tc = '.';\n\t\t\t\t\t\txt[k] = x; yt[k] = y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\tvector< vector<bool> > vis(3000, vector<bool>(3000));\n\t\tstack< vector<char> > stx, sty;\n\t\tstx.push(xs); sty.push(ys);\n\t\twhile (!stx.empty()) {\n\t\t\tvector<char> x = stx.top(); stx.pop();\n\t\t\tvector<char> y = sty.top(); sty.pop();\n\t\t\tvector<int> z(2);\n\t\t\tfor (int k = 0; k < 2; k++)\n\t\t\t\tz[k] = y[k] * W + x[k];\n\t\t\tvis[z[0]][z[1]] = true;\n\t\t\tif (x[0] == xt[0] && y[0] == yt[0]) continue;\n\t\t\tif (x[1] == xt[1] && y[1] == yt[1]) continue;\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tvector<char> _x = x, _y = y, _z(2);\n\t\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\t\t_x[k] += (k ? dx[i] : -dx[i]);\n\t\t\t\t\t_y[k] += dy[i];\n\t\t\t\t\tif (a[k][_y[k]][_x[k]] == '#') {\n\t\t\t\t\t\t_x[k] = x[k]; _y[k] = y[k];\n\t\t\t\t\t}\n\t\t\t\t\t_z[k] = _y[k] * W + _x[k];\n\t\t\t\t}\n\t\t\t\tif (!vis[_z[0]][_z[1]]) {\n\t\t\t\t\tvis[_z[0]][_z[1]] = true;\n\t\t\t\t\tstx.push(_x);\n\t\t\t\t\tsty.push(_y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> zt(2);\n\t\tfor (int k = 0; k < 2; k++)\n\t\t\tzt[k] = yt[k] * W + xt[k];\n\t\tcout << (vis[zt[0]][zt[1]] ? \"Yes\" : \"No\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <utility>\n#include <cstring>\n\nusing namespace std;\n\nconst int dx[] = { -1, 0, 1, 0 };\nconst int dy[] = { 0, -1, 0, 1 };\n\nvector<string> field;\nint W, H;\nunsigned char memo[52][52][52][52];\n\nstruct State {\n\tunsigned char rx, ry, lx, ly;\n\tunsigned char index;\n};\n\nint main(){\n\twhile(true){\n\t\tcin >> W >> H;\n\t\tif(W == 0 && H == 0){ break; }\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tfield.resize(H + 2);\n\t\tfield[0] = field[H + 1] = string(W * 2 + 3, '#');\n\t\tState init = { 0 };\n\t\tfor(int i = 1; i <= H; ++i){\n\t\t\tstring l1, l2;\n\t\t\tcin >> l1 >> l2;\n\t\t\tstring line = \"#\" + l1 + \"#\" + l2 + \"#\";\n\t\t\tfor(int j = 0; j < line.size(); ++j){\n\t\t\t\tif(line[j] == 'R'){\n\t\t\t\t\tinit.rx = j; init.ry = i;\n\t\t\t\t}else if(line[j] == 'L'){\n\t\t\t\t\tinit.lx = j; init.ly = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfield[i] = line;\n\t\t}\n\t\tstack<State> stk;\n\t\tstk.push(init);\n\t\tbool ok = false;\n\t\twhile(!stk.empty()){\n\t\t\tState cur = stk.top();\n\t\t\tstk.pop();\n\t\t\tint rx = cur.rx, ry = cur.ry, lx = cur.lx, ly = cur.ly;\n\t\t\tif(cur.index == 0){\n\t\t\t\tif(memo[rx - W - 1][ry][lx][ly]){ continue; }\n\t\t\t\tmemo[rx - W - 1][ry][lx][ly] = 1;\n\t\t\t\tif(field[ry][rx] == '%' && field[ly][lx] == '%'){\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(field[ry][rx] == '%' || field[ly][lx] == '%'){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint nrx = rx + dx[cur.index], nry = ry + dy[cur.index];\n\t\t\tint nlx = lx - dx[cur.index], nly = ly + dy[cur.index];\n\t\t\tif(field[nry][nrx] == '#'){\n\t\t\t\tnrx -= dx[cur.index];\n\t\t\t\tnry -= dy[cur.index];\n\t\t\t}\n\t\t\tif(field[nly][nlx] == '#'){\n\t\t\t\tnlx += dx[cur.index];\n\t\t\t\tnly -= dy[cur.index];\n\t\t\t}\n\t\t\tif(cur.index != 3){\n\t\t\t\t++cur.index;\n\t\t\t\tstk.push(cur);\n\t\t\t}\n\t\t\tState next = { nrx, nry, nlx, nly, 0 };\n\t\t\tstk.push(next);\n\t\t}\n\t\tcout << (ok ? \"Yes\" : \"No\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nstring RenR[51],LinR[51];\nbool memo[51][51][51][51];\nstring ans;\nint h,w;\n//         l r d u\nint Rx[4]={0,0,1,-1};\nint Ry[4]={1,-1,0,0};\n//         r l d u\nint Lx[4]={0,0,1,-1};\nint Ly[4]={-1,1,0,0};\n\n\nvoid move(int muki,int ri,int rj,int li,int lj)\n{\n  int ra=ri+Rx[muki],rb=rj+Ry[muki];\n  if(ra<0 || rb<0 || ra>=h ||rb>=w){}\n  else{\n    if(RenR[ra][rb]!='#'){\n      ri+=Rx[muki];\n      rj+=Ry[muki];\n    }\n  }\n  int la=li+Lx[muki],lb=lj+Ly[muki];\n  if(la<0 || lb<0 || la>=h || lb>=w){}\n  else {\n    if(LinR[la][lb]!='#'){\n      li+=Lx[muki];\n      lj+=Ly[muki];\n    }\n  }\n  if(memo[li][lj][ri][rj])return;\n\n  memo[li][lj][ri][rj]=true;\n\n  if(RenR[ri][rj]=='%' && LinR[li][lj]=='%'){\n    ans=\"Yes\";\n    return;\n  }\n  if(RenR[ri][rj]=='%' || LinR[li][lj]=='%')return;\n  \n  for(int k=0;k<4;k++){\n    move(k,ri,rj,li,lj);\n    if(ans==\"Yes\")break;\n  }\n  return;\n}\n\nint main()\n{\n  int ri,rj,li,lj;\n  while(1){\n    cin>>w>>h;\n    if(w+h==0)break;\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tfor(int k=0;k<h;k++){\n\t  for(int l=0;l<w;l++)memo[i][j][k][l]=false;\n\t}\n      }\n    }\n    for(int i=0;i<h;i++){\n      cin>>LinR[i];\n      for(int j=0;j<w;j++){\n\tif(LinR[i][j]=='L'){\n\t  li=i;lj=j;\n\t  break;\n\t}\n      }\n      cin>>RenR[i];\n      for(int j=0;j<w;j++){\n\tif(RenR[i][j]=='R'){\n\t  ri=i;rj=j;\n\t  break;\n\t}\n      }\n    }\n    ans=\"No\";\n    memo[li][lj][ri][rj]=true;\n    for(int i=0;i<4;i++){\n      move(i,ri,rj,li,lj);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\n\n\nint W,H;\nstring roomL[55],roomR[55];\n\nbool range_check(int y,int x) {\n    if(y<0||x<0) return false;\n    if(H<=y||W<=x) return false;\n\n    return true;\n}\n\nbool visited[55][55][55][55]={};\nbool ok(P len,P rin) {\n    memset(visited,0,sizeof(visited));\n    visited[len.fr][len.sc][rin.fr][rin.sc]=true;\n    queue<PP> que;\n    que.push(PP(len,rin));\n\n    while(que.size()) {\n        PP pp=que.front(); que.pop();\n        P next_len=pp.fr;\n        P next_rin=pp.sc;\n\n        //printf(\"[debug] %d %d %d %d\\n\",next_len.fr,next_len.sc,next_rin.fr,next_rin.sc);\n\n        if(roomL[next_len.fr][next_len.sc]=='%' && roomR[next_rin.fr][next_rin.sc]=='%') {\n            return true;\n        }\n        if(roomL[next_len.fr][next_len.sc]=='%' || roomR[next_rin.fr][next_rin.sc]=='%') {\n            visited[next_len.fr][next_len.sc][next_rin.fr][next_rin.sc]=false;\n            continue;\n        }\n        rep(i,4) {\n            next_len=pp.fr;\n            next_rin=pp.sc;\n\n            if(range_check(next_len.fr+dy[i],next_len.sc+dx[i]) && roomL[next_len.fr+dy[i]][next_len.sc+dx[i]]!='#') {\n                next_len.fr+=dy[i];\n                next_len.sc+=dx[i];\n            }\n            if(range_check(next_rin.fr+dy[i],next_rin.sc-dx[i]) && roomR[next_rin.fr+dy[i]][next_rin.sc-dx[i]]!='#') {\n                next_rin.fr+=dy[i];\n                next_rin.sc-=dx[i];\n            }\n\n            if(!visited[next_len.fr][next_len.sc][next_rin.fr][next_len.sc]) {\n                visited[next_len.fr][next_len.sc][next_rin.fr][next_len.sc]=true;\n                que.push(PP(next_len,next_rin));\n            }\n        }\n    }\n\n    return false;\n}\n\nvoid solve() {\n    rep(y,H) cin>>roomL[y]>>roomR[y];\n    P len,rin;\n    rep(y,H) rep(x,W) {\n        if(roomL[y][x]=='L') len=P(y,x);\n        if(roomR[y][x]=='R') rin=P(y,x);\n    }\n    if(ok(len,rin)) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n}\n\nint main() {\n    while(cin>>W>>H) {\n        if(!W) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<queue>\n#include<bitset>\nconst int N=52,N2=N*N,N3=N*N2,dx[]={0,1,0,-1,0};\t\nchar L[N][N],R[N][N];\nstruct S{int lx,ly,rx,ry;}s,t;\nint F()\n{\n\tstd::bitset<N3*N>b;\n\tstd::queue<S>q;\n\tq.push(s);\n\tchar l,r,i;\n\twhile(q.size())\n\t{\n\t\ts=q.front(),q.pop();\n\t\tif(b[s.ly*N3+s.lx*N2+s.ry*N+s.rx])continue;\n\t\tb[s.ly*N3+s.lx*N2+s.ry*N+s.rx]=1;\n\t\tl=L[s.ly][s.lx];\n\t\tr=R[s.ry][s.rx];\n\t\tif(l=='%'&&r=='%')return 1;\n\t\tif(l=='%'||r=='%')continue;\n\t\tfor(i=0;i<4;++i)\n\t\t{\n\t\t\tt=s;\n\t\t\tif(L[t.ly+=dx[i+1]][t.lx+=dx[i]]=='#')t=s;\n\t\t\tif(R[t.ry+=dx[i+1]][t.rx-=dx[i]]=='#')t.rx=s.rx, t.ry=s.ry;\n\t\t\tq.push(t);\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tint h,w,i;\n\tchar*p;\n\twhile(scanf(\"%d%d\",&w,&h),w)\n\t{\n\t\tfor(i=1;i<=h;++i)\n\t\t{\n\t\t\tscanf(\"%s%s\",L[i]+1,R[i]+1);\n\t\t\tif(p=strchr(L[i]+1,'L'))s.lx=p-L[i],s.ly=i;\n\t\t\tif(p=strchr(R[i]+1,'R'))s.rx=p-R[i],s.ry=i;\n\t\t}\n\t\tfor(i=0;i<h+2;++i)L[i][0]=L[i][w+1]=R[i][0]=R[i][w+1]='#';\n\t\tfor(i=0;i<w+2;++i)L[0][i]=L[h+1][i]=R[0][i]=R[h+1][i]='#';\n\t\tputs(F()?\"Yes\":\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#define rep(X,Y) for(int (X)=0;(X)<(Y);++(X))\n#define pb push_back\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<pii,pii> pi4;\n\nint dist[55][55][55][55],dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate<typename T> ostream& operator<<(ostream& os, vector<T> &v){\n  cout<<\"{\";\n  rep(i,v.size())os<<v[i]<<\",\"<<endl;cout<<\"}\"<<endl;\n  return os;\n}\ntemplate<typename T,typename S> ostream& operator<<(ostream& os, pair<T,S> &v){\n  os<<\"(\"<<v.X<<\",\"<<v.Y<<\")\";\n  return os;\n}\n\nint main(){\n  int w,h;\n  while(cin>>w>>h){\n    if(!w)break;\n  vector<string> ml(h+2),mr(h+2);\n  ml[0]=mr[0]=ml[h+1]=mr[h+1]=string(w+2,'#');\n  string tmp;\n  pii sl,dl,sr,dr;\n  rep(i,h){\n    cin>>tmp;\n    ml[i+1]=(\"#\"+tmp+\"#\");\n    cin>>tmp;\n    mr[i+1]=(\"#\"+tmp+\"#\");\n  }\n  rep(i,h+2)rep(j,w+2){\n    if(ml[i][j]=='L') sl=pii(j,i);\n    if(mr[i][j]=='R') sr=pii(j,i);\n    if(ml[i][j]=='%') dl=pii(j,i);\n    if(mr[i][j]=='%') dr=pii(j,i);\n  }\n  //cout<<ml<<mr<<sl<<sr<<dl<<dr<<endl;\n  int INF=1e9;\n  queue<pi4> que;\n  fill(dist[0][0][0],dist[0][0][0]+55*55*55*55,INF);\n  rep(i,h+2)rep(j,w+2)\n    dist[dl.Y][dl.X][i][j]=dist[i][j][dr.Y][dr.X]=-1;\n  dist[dl.Y][dl.X][dr.Y][dr.X]=INF;\n  dist[sl.Y][sl.X][sr.Y][sr.X]=0;\n  que.emplace(sl,sr);\n  while(!que.empty()){\n    pii cl=que.front().X, cr=que.front().Y;\n    que.pop();\n    //cout<<cl<<cr<<dist[cl.Y][cl.X][cr.Y][cr.X]<<endl;\n    if(cl==dl && cr==dr)break;\n    int nd=dist[cl.Y][cl.X][cr.Y][cr.X]+1;\n    rep(i,4){\n      pii nl=cl,nr=cr;\n      nl.X+=dx[i]; nl.Y+=dy[i];\n      nr.X-=dx[i]; nr.Y+=dy[i];\n      //cout<<i<<\":\"<<nl<<nr;\n      if(ml[nl.Y][nl.X]=='#') nl=cl;\n      if(mr[nr.Y][nr.X]=='#') nr=cr;\n      //cout<<i<<\":\"<<nl<<nr<<dist[nl.Y][nl.X][nr.Y][nr.X]<<endl;\n      if(dist[nl.Y][nl.X][nr.Y][nr.X]>nd){\n\tdist[nl.Y][nl.X][nr.Y][nr.X]=nd;\n\tque.emplace(nl,nr);\n      }\n    }\n  }\n  cout<<(dist[dl.Y][dl.X][dr.Y][dr.X]==INF?\"No\":\"Yes\")<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\n\n\nint w,h;\nchar L[53][53], R[53][53];\nchar memo[53][53][53][53];\nstruct state{\n\tint lx,ly,rx,ry;\n};\nint dl[4][2]={{0,1},{1,0},{-1,0},{0,-1}};\nint dr[4][2]={{0,-1},{1,0},{-1,0},{0,1}};\nbool dfs(state s){\n\tqueue<state> S;\n\tS.push(s);\n\twhile(!S.empty()){\n\t\ts = S.front();\n\t\tS.pop();\n\t\tif(L[s.ly][s.lx]=='%' && R[s.ry][s.rx]=='%') return true;\n\t\tif(L[s.ly][s.lx]=='%' || R[s.ry][s.rx]=='%') continue;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tstate t = s;\n\t\t\tif(L[t.ly+dl[i][0]][t.lx+dl[i][1]] != '#'){\n\t\t\t\tt.ly += dl[i][0];\n\t\t\t\tt.lx += dl[i][1];\n\t\t\t}\n\t\t\tif(R[t.ry+dr[i][0]][t.rx+dr[i][1]] != '#'){\n\t\t\t\tt.ry += dr[i][0];\n\t\t\t\tt.rx += dr[i][1];\n\t\t\t}\n\t\t\tif(memo[t.ly][t.lx][t.ry][t.rx]) continue;;\n\t\t\tmemo[t.ly][t.lx][t.ry][t.rx] = 1;\n\t\t\tS.push(t);\n\t\t}\n\t}\n\treturn false;\n}\n\nmain(){\n\tint i,j;\n\twhile(cin >> w >> h, w){\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tfor(i=0;i<53;i++)for(j=0;j<53;j++)L[i][j]=R[i][j]='#';\n\t\tint ans;\n\t\tstate s;\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tcin >> L[i][j];\n\t\t\t\tif(L[i][j] == 'L'){\n\t\t\t\t\ts.lx=j;s.ly=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tcin >> R[i][j];\n\t\t\t\tif(R[i][j] == 'R'){\n\t\t\t\t\ts.rx=j;s.ry=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (dfs(s)?\"Yes\":\"No\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\n#define rep(i, n)     rep2(i, 0, n)\n#define rep2(i, m, n) for (int i = (m); i < (int)(n); ++i)\n\nint w, h;\nint slx, sly, srx, sry;\nint glx, gly, grx, gry;\nbool visit[50][50][50][50];\nstring L[50], R[50];\n\nconst int dx[] = { 1, 0, -1, 0 };\nconst int dy[] = { 0, 1, 0, -1 };\n\nstruct C { int lx, ly, rx, ry; };\n\nvoid bfs(int lx, int ly, int rx, int ry)\n{\n    queue<C> que;\n    que.push((C){ lx, ly, rx, ry });\n    visit[lx][ly][rx][ry] = true;\n    \n    while (!que.empty()) {\n        C cur = que.front(); que.pop();\n        \n        rep(i, 4) {\n            lx = cur.lx + dx[i];\n            ly = cur.ly + dy[i];\n            rx = cur.rx - dx[i];\n            ry = cur.ry + dy[i];\n            if (lx < 0 || w <= lx) lx = cur.lx;\n            if (ly < 0 || h <= ly) ly = cur.ly;\n            if (rx < 0 || w <= rx) rx = cur.rx;\n            if (ry < 0 || h <= ry) ry = cur.ry;\n            if (L[ly][lx] == '#') lx = cur.lx, ly = cur.ly;\n            if (R[ry][rx] == '#') rx = cur.rx, ry = cur.ry;\n            if (visit[lx][ly][rx][ry]) continue;\n            \n            if ((lx == glx && ly == gly && (rx != grx || ry != gry))\n             || (rx == grx && ry == gry && (lx != glx || ly != gly)))\n                continue;\n            \n            que.push((C){ lx, ly, rx, ry });\n            visit[lx][ly][rx][ry] = true;\n        }\n    }\n}\n\nint main()\n{\n    while (cin >> w >> h, w && h) {\n        rep(i, h) cin >> L[i] >> R[i];\n        \n        rep(i, h) rep(j, w) {\n            if (L[i][j] == 'L') sly = i, slx = j;\n            if (R[i][j] == 'R') sry = i, srx = j;\n            if (L[i][j] == '%') gly = i, glx = j;\n            if (R[i][j] == '%') gry = i, grx = j;\n        }\n        \n        fill_n(***visit, 50*50*50*50, false);\n        bfs(slx, sly, srx, sry);\n        \n        cout << (visit[glx][gly][grx][gry] ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<string.h>\nusing namespace std;\n\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\n\nclass state{\npublic:\n\tint rx,ry,lx,ly;\n\tstate(int lx,int ly,int rx,int ry):lx(lx),ly(ly),rx(rx),ry(ry){}\n};\n\nint w,h;\n\nbool in(int x,int y)\n{\n\tif(x<0 || x>=w || y<0 || y>=h) return false;\n\treturn true;\n}\n\nbool done[50][50][50][50];\n\t\t\n\n\nint main(){\n\twhile(cin>>w>>h && w!=0){\n\t\tvector<string> L(h),R(h);\n\t\tint flx,fly,frx,fry;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>L[i]>>R[i];\n\t\t\tfor(int k=0;k<L[i].size();k++){\n\t\t\t\tif(L[i][k]=='L'){flx=k;fly=i;}\n\t\t\t\tif(R[i][k]=='R'){frx=k;fry=i;}\n\t\t\t}\n\t\t}\n\t\tmemset(done,false,sizeof(done));\n\t\tqueue<state> Q;\n\t\tQ.push(state(flx,fly,frx,fry));\n\t\tbool ok=false;\n\t\twhile(!Q.empty()){\n\t\t\tstate t=Q.front(); Q.pop();\n\t\t\tif(L[t.ly][t.lx]=='%' && R[t.ry][t.rx]=='%'){cout<<\"Yes\"<<endl;ok=true;break;}\n\t\t\tif(L[t.ly][t.lx]=='%' || R[t.ry][t.rx]=='%') continue;\n\t\t\tif(done[t.lx][t.ly][t.rx][t.ry]) continue;\n\t\t\tdone[t.lx][t.ly][t.rx][t.ry]=true;\n\n\t\t\tfor(int r=0;r<4;r++){\n\t\t\t\tint nlx=t.lx+dx[r],nly=t.ly-dy[r];\n\t\t\t\tif(!in(nlx,nly) || L[nly][nlx]=='#'){nlx=t.lx;nly=t.ly;}\n\n\t\t\t\tint nrx=t.rx+dx[(r+2)%4],nry=t.ry+dy[(r+2)%4];\n\t\t\t\tif(!in(nrx,nry) || R[nry][nrx]=='#'){nrx=t.rx;nry=t.ry;}\n\t\t\t\tQ.push(state(nlx,nly,nrx,nry));\n\t\t\t}\n\t\t}\n\t\tif(!ok)\n\t\t\tcout<<\"No\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\nusing namespace std;\n\nstruct state{ int lx,ly,rx,ry; };\n\nint dx[] = {0,1,0,-1},dy[] = {1,0,-1,0};\n\nbool dp[50][50][50][50];\n\nint main(){\n\tint h,w;\n\twhile(cin >> w >> h,h){\n\t\tint lx,ly,rx,ry;\n\t\tfor(int i = 0;i < 50;i++){\n\t\t\tfor(int j = 0;j < 50;j++){\n\t\t\t\tfor(int k = 0;k < 50;k++){\n\t\t\t\t\tfor(int l = 0;l < 50;l++) dp[i][j][k][l] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool flag = false;\n\t\tstring lf[50],rf[50];\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tcin >> lf[i] >> rf[i];\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(lf[i][j] == 'L'){\n\t\t\t\t\tlx = i;\n\t\t\t\t\tly = j;\n\t\t\t\t}\n\t\t\t\tif(rf[i][j] == 'R'){\n\t\t\t\t\trx = i;\n\t\t\t\t\try = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<state> que;\n\t\tque.push({lx,ly,rx,ry});\n\t\twhile(!que.empty()){\n\t\t\tstate s = que.front();que.pop();\n\t\t\tif(dp[s.lx][s.ly][s.rx][s.ry]) continue;\n\t\t\t//cout << s.lx << \" \" << s.ly << \" \" << s.rx << \" \" << s.ry << endl;\n\t\t\tif(lf[s.lx][s.ly] == '%' && rf[s.rx][s.ry] == '%') flag = true;\n\t\t\tdp[s.lx][s.ly][s.rx][s.ry] = true;\n\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\tint nlx = s.lx + dx[i],nly = s.ly + dy[i],nrx = s.rx + dx[i],nry = s.ry + dy[(i + 2) % 4];\n\t\t\t\tbool move = false;\n\t\t\t\tif(nlx >= 0 && nlx < h && nly >= 0 && nly < w && lf[nlx][nly] != '#') move = true;\n\t\t\t\telse{\n\t\t\t\t\tnlx = s.lx;\n\t\t\t\t\tnly = s.ly;\n\t\t\t\t}\n\t\t\t\tif(nrx >= 0 && nrx < h && nry >= 0 && nry < w && rf[nrx][nry] != '#') move = true;\n\t\t\t\telse{\n\t\t\t\t\tnrx = s.rx;\n\t\t\t\t\tnry = s.ry;\n\t\t\t\t}\n\t\t\t\tif((lf[nlx][nly] == '%') ^ (rf[nrx][nry] == '%')) continue;\n\t\t\t\tif(move && !dp[nlx][nly][nrx][nry]){\n\t\t\t\t\tque.push({nlx,nly,nrx,nry});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class F> int ppt(C const& v, F f) {\n    return partition_point(v.begin(), v.end(), f)-v.begin();\n}\n// <<<\nconstexpr int dx[] = { 1,0,-1,0 };\nconstexpr int dy[] = { 0,1,0,-1 };\n\nint32_t main() {\n    while (true) {\n        int W,H; cin >> W >> H;\n        if (W == 0 && H == 0) break;\n        vector<string> L(H),R(H);\n        rep (i,H) cin >> L[i] >> R[i], reverse(all(L[i]));\n        auto inside = [&](int i, int j) {\n            return (0 <= i && i < H &&\n                    0 <= j && j < W);\n        };\n        auto valid_L = [&](int i, int j) {\n            return inside(i,j) && L[i][j] != '#';\n        };\n        auto valid_R = [&](int i, int j) {\n            return inside(i,j) && R[i][j] != '#';\n        };\n\n        int sxL = -1, syL = -1, sxR = -1, syR = -1;\n        int gxL = -1, gyL = -1, gxR = -1, gyR = -1;\n        rep (i,H) rep (j,W) {\n            if (L[i][j] == 'L') sxL = i, syL = j;\n            if (L[i][j] == '%') gxL = i, gyL = j;\n            if (R[i][j] == 'R') sxR = i, syR = j;\n            if (R[i][j] == '%') gxR = i, gyR = j;\n        }\n\n        auto d = make_v<int,4>(H,W,H,W,INF);\n        queue<tuple<int,int,int,int>> q;\n        d[sxL][syL][sxR][syR] = 0;\n        q.emplace(sxL,syL,sxR,syR);\n        while (q.size()) {\n            auto t = q.front(); q.pop();\n            int xL = get<0>(t);\n            int yL = get<1>(t);\n            int xR = get<2>(t);\n            int yR = get<3>(t);\n            rep (dir,4) {\n                int nxL = xL+dx[dir];\n                int nyL = yL+dy[dir];\n                if (not valid_L(nxL,nyL)) nxL = xL, nyL = yL;\n                int nxR = xR+dx[dir];\n                int nyR = yR+dy[dir];\n                if (not valid_R(nxR,nyR)) nxR = xR, nyR = yR;\n                if ((L[nxL][nyL] == '%')^(R[nxR][nyR] == '%')) continue;\n                if (chmin(d[nxL][nyL][nxR][nyR], d[xL][yL][xR][yR] + 1)) {\n                    q.emplace(nxL,nyL,nxR,nyR);\n                }\n            }\n        }\n        cout << (d[gxL][gyL][gxR][gyR] < INF ? \"Yes\" : \"No\") << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <tuple>\n#include <string>\n#include <cstring>\n#include <iostream>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nconst int dx1[4] = { 0, 1, 0, -1 };\nconst int dy1[4] = { -1, 0, 1, 0 };\nconst int dx2[4] = { 0, -1, 0, 1 };\nconst int dy2[4] = { -1, 0, 1, 0 };\n\nint H, W; string L[50], R[50];\n\nbool used[50][50][50][50];\n\nbool over(int x, int y)\n{\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\nbool solve(int x1, int y1, int x2, int y2)\n{\n\tqueue<tuple<int, int, int, int> > que;\n\n\tque.push(make_tuple(y1, x1, y2, x2));\n\n\tused[y1][x1][y2][x2] = true;\n\n\twhile (!que.empty())\n\t{\n\t\tint ly = get<0>(que.front());\n\t\tint lx = get<1>(que.front());\n\t\tint ry = get<2>(que.front());\n\t\tint rx = get<3>(que.front());\n\n\t\tque.pop();\n\n\t\tif (L[ly][lx] == '%' && R[ry][rx] == '%') return true;\n\n\t\tif (L[ly][lx] == '%') continue;\n\t\tif (R[ry][rx] == '%') continue;\n\n\t\tbool ok = false;\n\n\t\tfor (int i = 0; i < 4; i++)\n\t\t{\n\t\t\tint ltx = lx + dx1[i];\n\t\t\tint lty = ly + dy1[i];\n\t\t\tint rtx = rx + dx2[i];\n\t\t\tint rty = ry + dy2[i];\n\n\t\t\tif (!over(ltx, lty))\n\t\t\t{\n\t\t\t\tltx -= dx1[i];\n\t\t\t\tlty -= dy1[i];\n\t\t\t}\n\n\t\t\tif (!over(rtx, rty))\n\t\t\t{\n\t\t\t\trtx -= dx2[i];\n\t\t\t\trty -= dy2[i];\n\t\t\t}\n\n\t\t\tif (L[lty][ltx] == '#')\n\t\t\t{\n\t\t\t\tltx -= dx1[i];\n\t\t\t\tlty -= dy1[i];\n\t\t\t}\n\n\t\t\tif (R[rty][rtx] == '#')\n\t\t\t{\n\t\t\t\trtx -= dx2[i];\n\t\t\t\trty -= dy2[i];\n\t\t\t}\n\n\t\t\tif (!used[lty][ltx][rty][rtx])\n\t\t\t{\n\t\t\t\tused[lty][ltx][rty][rtx] = true;\n\n\t\t\t\tque.push(make_tuple(lty, ltx, rty, rtx));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &W);\n\t\tscanf(\"%d\", &H);\n\n\t\tif (W == 0 && H == 0) break;\n\n\t\tfor (int i = 0; i < 50; i++) L[i] = \"\";\n\t\tfor (int i = 0; i < 50; i++) R[i] = \"\";\n\n\t\tfor (int i = 0; i < H; i++) cin >> L[i] >> R[i];\n\n\t\tint lx, ly, rx, ry;\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (L[i][j] == 'L')\n\t\t\t\t{\n\t\t\t\t\tlx = j;\n\t\t\t\t\tly = i;\n\t\t\t\t}\n\n\t\t\t\tif (R[i][j] == 'R')\n\t\t\t\t{\n\t\t\t\t\trx = j;\n\t\t\t\t\try = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(used, false, sizeof(used));\n\n\t\tprintf(\"%s\\n\", solve(lx, ly, rx, ry) ? \"Yes\" : \"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) for(auto x : v){cout << x << \" \";} cout << endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(vv) for(auto v : vv){for(auto&& x : v){cout << x << \" \";}cout << endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\ntypedef vector<vector<int>> Graph;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nint a[2500][2500];\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n\n}"
  },
  {
    "language": "C++",
    "code": "50 50\n%#................................................ ................................................#%\n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#.\n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#. \n.#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#L .#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#..#.#R\n\n\n.#.#.\n...#L\n3 2\n.L. .R#\n%.. .%.\n4 1\nL.%. %..R\n0 0"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\nstring RenR[50],LinR[50];\nbool memo[50][50][50][50];\nstring ans;\nint h,w;\n//         l r d u\nint Rx[4]={0,0,1,-1};\nint Ry[4]={1,-1,0,0};\n//         r l d u\nint Lx[4]={0,0,1,-1};\nint Ly[4]={-1,1,0,0};\n\nclass S{\npublic:\n    int rx,ry,lx,ly;\n    S(int rx,int ry,int lx,int ly):lx(lx),ly(ly),rx(rx),ry(ry){}\n}; \n\nint main()\n{\n  int ri,rj,li,lj;\n  while(1){\n    cin>>w>>h;\n    if(w+h==0)break;\n\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tfor(int k=0;k<h;k++){\n\t  for(int l=0;l<w;l++)memo[i][j][k][l]=false;\n\t}\n      }\n    }\n\n    for(int i=0;i<h;i++){\n      cin>>LinR[i];\n      for(int j=0;j<w;j++){\n\tif(LinR[i][j]=='L'){\n\t  li=i;lj=j;\n\t  break;\n\t}\n      }\n      cin>>RenR[i];\n      for(int j=0;j<w;j++){\n\tif(RenR[i][j]=='R'){\n\t  ri=i;rj=j;\n\t  break;\n\t}\n      }\n    }\n    queue<S> Q;\n    Q.push(S(ri,rj,li,lj));\n    ans=\"No\";\n    while(!Q.empty()){\n      S s=Q.front();Q.pop();\n      if(RenR[s.rx][s.ry]=='%' && LinR[s.lx][s.ly]=='%'){\n        ans=\"Yes\";\n\tbreak;\n      }\n      if(RenR[s.rx][s.ry]=='%' && LinR[s.lx][s.ly]=='%')continue;\n      if(memo[s.rx][s.ry][s.lx][s.ly])continue;\n      memo[s.rx][s.ry][s.lx][s.ly]=true;\n\n      for(int k=0;k<4;k++){\n\tint ra=s.rx+Rx[k],rb=s.ry+Ry[k];\n        if(ra<0 || rb<0 || ra>=h || rb>=w){\n\t  ra=s.rx;\n\t  rb=s.ry;\n\t}\n\telse if(RenR[ra][rb]=='#'){\n\t  ra=s.rx;\n\t  rb=s.ry;\n\t}\n\tint la=s.lx+Lx[k],lb=s.ly+Ly[k];\n        if(la<0 || lb<0 || la>=h || lb>=w){\n\t  la=s.lx;\n\t  lb=s.ly;\n\t}\n\telse if(RenR[la][lb]=='#'){\n\t  la=s.lx;\n\t  lb=s.ly;\n\t}\n\tif(!memo[ra][rb][la][lb])Q.push(S(ra,rb,la,lb));\n      }\n    }\n    cout<<ans<<endl;\t\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ll long long\n#define fi first\n#define se second\n#define pb push_back\n#define rep(i, s, n) for (int i = s; i < n; i++)\n#define rrep(i, s, n) for (int i = (n)-1; i >= (s); i--)\n#define REP(i,n) for(int i = 0;i < n; i++)\n#define all(a) a.begin(),a.end()\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\nconst long long MOD = 1000000007, INF = 1e18;\n \n#define endl '\\n'\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0)\n \ntemplate<class T>inline bool chmax(T& a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>inline bool chmin(T& a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>vector<T>\nmake_v(size_t a){return vector<T>(a);}\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n\treturn vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n \ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n \ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n\tfor(auto &e:t) fill_v(e,v);\n}\n\n/*bool operator<(const data &d)const{\n\treturn hoge;\n}*/\n\nint H,W;\nint dp[55][55][55][55];\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\nchar l[501][501],r[501][501];\n\n\nint solve(){\n\trep(i,0,H){\n\t\trep(j,0,W)cin>>l[i][j];\n\t\trep(j,0,W)cin>>r[i][j];\n\t}\n\trep(i,0,55)rep(j,0,55)rep(k,0,55)rep(l,0,55)dp[i][j][k][l] = -1;\n\tint li,lj,ri,rj;\n\trep(i,0,H)rep(j,0,W){\n\t\tif(l[i][j]=='L'){\n\t\t\tli = i;\n\t\t\tlj = j;\n\t\t}\n\t\tif(r[i][j]=='R'){\n\t\t\tri = i;\n\t\t\trj = j;\n\t\t}\n\t}\n\tstack<pair<pair<int,int>,pair<int,int>>>st;\n\tst.push({{li,lj},{ri,rj}});\n\twhile(!st.empty()){\n\t\tauto t = st.top();\n\t\tst.pop();\n\t\tint li = t.fi.fi;\n\t\tint lj = t.fi.se;\n\t\tint ri = t.se.fi;\n\t\tint rj = t.se.se;\n\t\tif(dp[li][lj][ri][rj]==1)continue;\n\t\tif(l[li][lj]=='%'&&r[ri][rj]=='%')return 1;\n\t\tif(l[li][lj]=='%'||r[ri][rj]=='%')continue;\n\t\tdp[li][lj][ri][rj] = 1;\n\t\trep(k,0,4){\n\t\t\tint nli = li + dy[k];\n\t\t\tint nlj = lj + dx[k];\n\t\t\tint nri = ri + dy[k];\n\t\t\tint nrj = rj - dx[k];\n\t\t\tif(nli<0||nli>=H||nlj<0||nlj>=W){\n\t\t\t\tnli = li;\n\t\t\t\tnlj = lj;\n\t\t\t}\n\t\t\tif(l[nli][nlj]=='#'){\n\t\t\t\tnli = li;\n\t\t\t\tnlj = lj;\n\t\t\t}\n\t\t\tif(nri<0||nri>=H||nrj<0||nrj>=W){\n\t\t\t\tnri = ri;\n\t\t\t\tnrj = rj;\n\t\t\t}\n\t\t\tif(r[nri][nrj]=='#'){\n\t\t\t\tnri = ri;\n\t\t\t\tnrj = rj;\n\t\t\t}\n\t\t\tif(dp[nli][nlj][nri][nrj]==-1){\n\t\t\t\tdp[nli][nlj][nri][nrj]=0;\n\t\t\t\tst.push({{nli,nlj},{nri,nrj}});\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n \nsigned main(){\n\tIOS();\n\tvector<int>ans;\n\twhile(cin>>W>>H,H||W){\n\t\tint t = solve();\n\t\tans.push_back(t);\n\t}\n\tfor(auto e:ans){\n\t\tif(e)cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint mx[4]={0,1,0,-1};\nint my[4]={1,0,-1,0};\n\nbool memo[50][50][50][50];\n\nint w,h;\n\nbool dfs(pair<int,int>nowL, pair<int,int>nowR, vector<string> &sl,vector<string> &sr){\n    stack<pair<pair<int,int>,pair<int,int>>>st;\n    st.push(make_pair(nowL,nowR));\n    while(!st.empty()){\n        nowL=st.top().first;\n        nowR=st.top().second;\n        //cout<<nowL.first<<nowL.second<<nowR.first<<nowR.second<<endl;\n        st.pop();\n        if(memo[nowL.first][nowL.second][nowR.first][nowR.second]){\n            continue;\n        }else{\n            memo[nowL.first][nowL.second][nowR.first][nowR.second]=1;\n        }\n        if(sl[nowL.first][nowL.second]=='%' && sr[nowR.first][nowR.second]=='%'){\n            return 1;\n        }\n        if(sl[nowL.first][nowL.second]=='%'){\n            continue;\n        }\n        if(sr[nowR.first][nowR.second]=='%'){\n            continue;\n        }\n        for(int i=0;i<4;++i){\n            pair<int,int>nextL,nextR;\n            nextL.first=nowL.first+my[i];\n            nextL.second=nowL.second+mx[i];\n            nextR.first=nowR.first+my[i];\n            nextR.second=nowR.second-mx[i];\n        //------------------------------------\n            if(nextL.first<0 || nextL.first>=h){\n                nextL=nowL;\n            }\n            if(nextL.second<0 || nextL.second>=w){\n                nextL=nowL;\n            }\n            if(sl[nextL.first][nextL.second]=='#'){\n                nextL=nowL;\n            }\n        //-------------------------------------\n            if(nextR.first<0 || nextR.first>=h){\n                nextR=nowR;\n            }\n            if(nextR.second<0 || nextR.second>=w){\n                nextR=nowR;\n            }\n            if(sr[nextR.first][nextR.second]=='#'){\n                nextR=nowR;\n            }\n            st.push(make_pair(nextL,nextR));\n        }\n    }\n    return 0;\n    //cout<<nowL.first<<nowL.second<<nowR.first<<nowR.second<<endl;\n    /*if(memo[nowL.first][nowL.second][nowR.first][nowR.second]){\n        return 0;\n    }else{\n        memo[nowL.first][nowL.second][nowR.first][nowR.second]=1;\n    }\n    if(sl[nowL.first][nowL.second]=='%' && sr[nowR.first][nowR.second]=='%'){\n        return 1;\n    }\n    if(sl[nowL.first][nowL.second]=='%'){\n        return 0;\n    }\n    if(sr[nowR.first][nowR.second]=='%'){\n        return 0;\n    }\n    for(int i=0;i<4;++i){\n        pair<int,int>nextL,nextR;\n        nextL.first=nowL.first+my[i];\n        nextL.second=nowL.second+mx[i];\n        nextR.first=nowR.first+my[i];\n        nextR.second=nowR.second-mx[i];\n        //------------------------------------\n        if(nextL.first<0 || nextL.first>=h){\n            nextL=nowL;\n        }\n        if(nextL.second<0 || nextL.second>=w){\n            nextL=nowL;\n        }\n        if(sl[nextL.first][nextL.second]=='#'){\n            nextL=nowL;\n        }\n        //-------------------------------------\n        if(nextR.first<0 || nextR.first>=h){\n            nextR=nowR;\n        }\n        if(nextR.second<0 || nextR.second>=w){\n            nextR=nowR;\n        }\n        if(sr[nextR.first][nextR.second]=='#'){\n            nextR=nowR;\n        }\n        if(dfs(nextL,nextR,sl,sr))return 1;\n    }\n    return 0;\n    */\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    while(cin>>w>>h,w){\n        for(int i=0;i<50;++i){\n            for(int j=0;j<50;++j){\n                for(int k=0;k<50;++k){\n                    for(int l=0;l<50;++l){\n                        memo[i][j][k][l]=0;\n                    }\n                }\n            }\n        }\n        vector<string> sl(h),sr(h);\n        pair<int,int>startL,startR;\n        for(int i=0;i<h;++i){\n            cin>>sl[i]>>sr[i];\n            for(int j=0;j<w;++j){\n                if(sl[i][j]=='L'){\n                    startL={i,j};\n                }\n                if(sr[i][j]=='R'){\n                    startR={i,j};\n                }\n            }\n        }\n        if(dfs(startL,startR,sl,sr))cout<<\"Yes\"<<endl;\n        else cout<<\"No\"<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <utility>\n#include <tuple>\n#include <queue>\n\nconstexpr size_t m1 = -1;\nconstexpr size_t di[] = {m1, 0, 1, 0};\nconstexpr size_t dj[] = {0, m1, 0, 1};\n\nint testcase_ends() {\n  size_t h, w;\n  scanf(\"%zu %zu\", &w, &h);\n  if (h == 0 && w == 0) return 1;\n\n  std::vector<std::string> L(h+2), R(h+2);\n  L[0] = L[h+1] = R[0] = R[h+1] = std::string(w+2, '#');\n  size_t lsi = -1;\n  size_t lsj = -1;\n  size_t rsi = -1;\n  size_t rsj = -1;\n  for (size_t i = 1; i <= h; ++i) {\n    char buf[64];\n    scanf(\"%s\", buf);\n    L[i] = \"#\";\n    L[i] += buf;\n    L[i] += '#';\n    for (size_t j = 1; j <= w; ++j) {\n      if (L[i][j] == 'L') {\n        lsi = i;\n        lsj = j;\n      }\n    }\n\n    scanf(\"%s\", buf);\n    R[i] = \"#\";\n    R[i] += buf;\n    R[i] += '#';\n    std::reverse(R[i].begin(), R[i].end());\n    for (size_t j = 1; j <= w; ++j) {\n      if (R[i][j] == 'R') {\n        rsi = i;\n        rsj = j;\n      }\n    }\n  }\n  h += 2;\n  w += 2;\n\n  std::vector<std::vector<bool>> ldp(h, std::vector<bool>(w, false));\n  auto rdp = ldp;\n  ldp[lsi][lsj] = rdp[rsi][rsj] = true;\n  using zahyo = std::pair<size_t, size_t>;\n  std::queue<std::pair<zahyo, zahyo>> q;\n  q.emplace(std::make_pair(lsi, lsj), std::make_pair(rsi, rsj));\n  while (!q.empty()) {\n    size_t li, lj, ri, rj;\n    std::tie(li, lj) = q.front().first;\n    std::tie(ri, rj) = q.front().second;\n    q.pop();\n\n    for (int k = 0; k < 4; ++k) {\n      size_t lni = li + di[k];\n      size_t lnj = lj + dj[k];\n      size_t rni = ri + di[k];\n      size_t rnj = rj + dj[k];\n\n      if (L[lni][lnj] == '#') {\n        lni = li;\n        lnj = lj;\n      }\n      if (R[rni][rnj] == '#') {\n        rni = ri;\n        rnj = rj;\n      }\n\n      if (ldp[lni][lnj] && rdp[rni][rnj]) continue;\n      if ((L[lni][lnj] == '%') ^ (R[rni][rnj] == '%')) continue;\n\n      if (L[lni][lnj] == '%' && R[rni][rnj] == '%')\n        return puts(\"Yes\"), 0;\n\n      ldp[lni][lnj] = rdp[rni][rnj] = true;\n      q.emplace(std::make_pair(lni, lnj), std::make_pair(rni, rnj));\n    }\n  }\n\n  puts(\"No\");\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<char,char> P;\n\nstruct state{\n\tP p1, p2;\n\tstate(P p1_, P p2_){ p1 = p1_; p2 = p2_; }\n};\nint w, h;\nint dx1[4] = {0,-1,1,0};\nint dy1[4] = {-1,0,0,1};\nint dx2[4] = {0,1,-1,0};\nint dy2[4] = {-1,0,0,1};\nbool flag[51][51][51][51];\nchar L[51][51];\nchar R[51][51];\n\nvoid init(){\n\tfor(int i=0 ; i < 51 ; i++ ){\n\t\tfor(int j=0 ; j < 51 ; j++ ){\n\t\t\tfor(int k=0 ; k < 51 ; k++ ){\n\t\t\t\tfor(int l=0 ; l < 51 ; l++ ){\n\t\t\t\t\tflag[i][j][k][l] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// デバッグ用\nvoid debug(){\n\tcout << \"[Left]\" << endl;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tcout << L[y][x];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n\tcout << \"[right]\" << endl;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tcout << R[y][x];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// R[y][x] == 'R' となる (x,y) を返す\nP R_search(){\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( R[y][x] == 'R' ){\n\t\t\t\tR[y][x] = '.';\n\t\t\t\treturn P(x,y);\n\t\t\t}\n\t\t}\n\t}\n\treturn P(0,0);\n}\n\n// L[y][x] == 'L' となる (x,y) を返す\nP L_search(){\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( L[y][x] == 'L' ){\n\t\t\t\tL[y][x] = '.';\n\t\t\t\treturn P(x,y);\n\t\t\t}\n\t\t}\n\t}\n\treturn P(0,0);\n}\n\nbool bfs(){\n\tP ls = L_search();\n\tP rs = R_search();\n\t\n\tqueue< pair<P,P> > q;\n\tpair<P,P> s( ls , rs );\n\tq.push( s );\n\t\n\twhile( !q.empty() && q.size() < 7000000 ){\n\t\tpair<P,P> now = q.front(); q.pop();\n\t\tint x1 = now.first.first;\n\t\tint y1 = now.first.second;\n\t\tint x2 = now.second.first;\n\t\tint y2 = now.second.second;\n\t\tflag[y1][x1][y2][x2] = true;\n\t\tif( L[y1][x1] == '%' && R[y2][x2] == '%' ){\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\tint mx1 = x1 + dx1[i];\n\t\t\tint my1 = y1 + dy1[i];\n\t\t\tif( mx1 < 0 || my1 < 0 || mx1 >= w || my1 >= h || L[my1][mx1] == '#' ){\n\t\t\t\tmx1 = x1;\n\t\t\t\tmy1 = y1;\n\t\t\t}\n\t\t\tint mx2 = x2 + dx2[i];\n\t\t\tint my2 = y2 + dy2[i];\n\t\t\tif( mx2 < 0 || my2 < 0 || mx2 >= w || my2 >= h || R[my2][mx2] == '#' ){\n\t\t\t\tmx2 = x2;\n\t\t\t\tmy2 = y2;\n\t\t\t}\n\t\t\tP p1(mx1,my1);\n\t\t\tP p2(mx2,my2);\n\t\t\tpair<P,P> next(p1,p2);\n\t\t\tif( flag[my1][mx1][my2][mx2] ){\n\t\t\t\tcontinue;\n\t\t\t}else if( L[my1][mx1] == '%' && R[my2][mx2] != '%' ){\n\t\t\t\tflag[my1][mx1][my2][mx2] = true;\n\t\t\t}else if( L[my1][mx1] != '%' && R[my2][mx2] == '%' ){\n\t\t\t\tflag[my1][mx1][my2][mx2] = true;\n\t\t\t}else{\n\t\t\t\tq.push( next );\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\twhile( cin >> w >> h, w || h ){\n\t\tinit();\n\t\t\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tstring l, r;\n\t\t\tcin >> l >> r;\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tL[y][x] = l[x];\n\t\t\t\tR[y][x] = r[x];\n\t\t\t}\n\t\t}\n\t\t// debug();\n\t\tbool ans = bfs();\n\t\tif( ans )\n\t\t\tcout << \"Yes\" << endl;\n\t\telse\n\t\t\tcout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint H,W;\nint diff_row[4]= {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nstruct Info{\n\tInfo(int arg_L_row,int arg_L_col,int arg_R_row,int arg_R_col,int arg_count){\n\t\tL_row = arg_L_row;\n\t\tL_col = arg_L_col;\n\t\tR_row = arg_R_row;\n\t\tR_col = arg_R_col;\n\t\tcount = arg_count;\n\t}\n\tint L_row,L_col,R_row,R_col,count;\n};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n\nvoid func(){\n\n\tint min_Count[H][W][H][W];\n\tfor(int a = 0; a < H; a++){\n\t\tfor(int b = 0; b < W; b++){\n\t\t\tfor(int c = 0; c < H; c++){\n\t\t\t\tfor(int d = 0; d < W; d++)min_Count[a][b][c][d] = BIG_NUM;\n\t\t\t}\n\t\t}\n\t}\n\n\tchar L_map[H][W+1],R_map[H][W+1];\n\n\tint L_start_row,L_start_col,R_start_row,R_start_col;\n\n\tfor(int i = 0; i < H; i++){\n\t\tscanf(\"%s %s\",L_map[i],R_map[i]);\n\t\tfor(int k = 0; k < W; k++){\n\t\t\tif(L_map[i][k] == 'L'){\n\t\t\t\tL_start_row = i;\n\t\t\t\tL_start_col = k;\n\t\t\t\tL_map[i][k] = '.';\n\t\t\t}\n\t\t\tif(R_map[i][k] == 'R'){\n\t\t\t\tR_start_row = i;\n\t\t\t\tR_start_col = k;\n\t\t\t\tR_map[i][k] = '.';\n\t\t\t}\n\t\t}\n\t}\n\n\tqueue<Info> Q;\n\tQ.push(Info(L_start_row,L_start_col,R_start_row,R_start_col,0));\n\tmin_Count[L_start_row][L_start_col][R_start_row][R_start_col] = 0;\n\n\tbool FLG = false;\n\n\tint next_L_row,next_L_col,next_R_row,next_R_col;\n\n\twhile(!Q.empty()){\n\n\t\tif(L_map[Q.front().L_row][Q.front().L_col] == '%' && R_map[Q.front().R_row][Q.front().R_col] == '%'){\n\t\t\tFLG = true;\n\t\t\tbreak;\n\t\t}else if(Q.front().count > min_Count[Q.front().L_row][Q.front().L_col][Q.front().R_row][Q.front().R_col]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tnext_L_row = Q.front().L_row + diff_row[i];\n\t\t\t\tnext_L_col = Q.front().L_col + diff_col[i];\n\t\t\t\tnext_R_row = Q.front().R_row + diff_row[i];\n\t\t\t\tnext_R_col = Q.front().R_col - diff_col[i];\n\n\t\t\t\tif(rangeCheck(next_L_row,next_L_col) == false || L_map[next_L_row][next_L_col] == '#'){\n\t\t\t\t\tnext_L_row = Q.front().L_row;\n\t\t\t\t\tnext_L_col = Q.front().L_col;\n\t\t\t\t}\n\t\t\t\tif(rangeCheck(next_R_row,next_R_col) == false || R_map[next_R_row][next_R_col] == '#'){\n\t\t\t\t\tnext_R_row = Q.front().R_row;\n\t\t\t\t\tnext_R_col = Q.front().R_col;\n\t\t\t\t}\n\n\t\t\t\tif(min_Count[next_L_row][next_L_col][next_R_row][next_R_col] > Q.front().count+1){\n\t\t\t\t\tif((L_map[next_L_row][next_L_col] == '%' && R_map[next_R_row][next_R_col] != '%') ||\n\t\t\t\t\t\t\t(L_map[next_L_row][next_L_col] != '%' && R_map[next_R_row][next_R_col] == '%')){\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmin_Count[next_L_row][next_L_col][next_R_row][next_R_col] = Q.front().count+1;\n\t\t\t\t\t\tQ.push(Info(next_L_row,next_L_col,next_R_row,next_R_col,Q.front().count+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tif(FLG){\n\t\tprintf(\"Yes\\n\");\n\t}else{\n\t\tprintf(\"No\\n\");\n\t}\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&W,&H);\n\t\tif(W == 0 && H == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\n\nvoid f(vs a,int &x,int &y,int &X,int &Y){\n\tfor(int i=0;i<a.size();i++){\n\t\tfor(int j=0;j<a[i].size();j++){\n\t\t\tif(isalpha(a[i][j])) x=i,y=j;\n\t\t\tif(a[i][j]=='%') X=i,Y=j;\n\t\t}\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\twhile(1){\n\t\tint h,w;\n\t\tcin>>w>>h;\n\t\tif(h==0) break;\n\t\tvs a(h),b(h);\n\t\tfor(int i=0;i<h;i++) cin>>a[i]>>b[i];\n\t\tint sx,sy,gx,gy,SX,SY,GX,GY;\n\t\tf(a,sx,sy,gx,gy);\n\t\tf(b,SX,SY,GX,GY);\n\t\tqueue<array<int,4>> q;\n\t\tq.push(array<int,4>{sx,sy,SX,SY});\n\t\tbool c[50][50][50][50];\n\t\tfor(int i=0;i<50;i++) for(int j=0;j<50;j++) for(int k=0;k<50;k++) for(int l=0;l<50;l++) c[i][j][k][l]=0;\n\t\tc[sx][sy][SX][SY]=1;\n\t\tbool flag=0;\n\t\twhile(!q.empty()){\n\t\t\tauto arr=q.front();\n\t\t\tq.pop();\n\t\t\tint x=arr[0],y=arr[1],X=arr[2],Y=arr[3];\n//\t\t\tcout<<x<<' '<<y<<' '<<X<<' '<<Y<<endl;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint cx=x+dx[i],cy=y+dy[i],CX=X+dx[i],CY=Y+dy[(i+2)%4];\n\t\t\t\tint mx=1,my=1;\n\t\t\t\tif(cx<0||cx>=h||cy<0||cy>=w||a[cx][cy]=='#') cx=x,cy=y,mx=0;\n\t\t\t\tif(CX<0||CX>=h||CY<0||CY>=w||b[CX][CY]=='#') CX=X,CY=Y,my=0;\n\t\t\t\tif(cx==gx&&cy==gy&&CX==GX&&CY==GY&&mx&&my){\n\t\t\t\t\tflag=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(cx==gx&&cy==gy||CX==GX&&CY==GY) continue;\n\t\t\t\tarray<int,4> tmp={cx,cy,CX,CY};\n\t\t\t\tif(!c[cx][cy][CX][CY]){\n\t\t\t\t\tc[cx][cy][CX][CY]=1;\n\t\t\t\t\tq.push(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag) break;\n\t\t}\n\t\tcout<<(flag?\"Yes\":\"No\")<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#define N 52\n#define y1 first.first\n#define x1 first.second\n#define y2 second.first\n#define x2 second.second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\n\nint bfs();\n\nint w,h,sy1,sx1,sy2,sx2,gy1,gx1,gy2,gx2;\nstring r1[N],r2[N];\nbool visited[N][N][N][N];\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(!w&&!h) break;\n    for(int i=0;i<h;i++) cin>>r1[i]>>r2[i];\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tfor(int k=0;k<h;k++)\n\t  for(int l=0;l<w;l++) visited[i][j][k][l]=false;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(r1[i][j]=='L') sy1=i,sx1=j;\n\tif(r1[i][j]=='%') gy1=i,gx1=j;\n\tif(r2[i][j]=='R') sy2=i,sx2=j;\n\tif(r2[i][j]=='%') gy2=i,gx2=j;\n      }\n    if(bfs()) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n  return 0;\n}\n\nint bfs(){\n  int dy[4]={0,-1,0,1},dx[4]={-1,0,1,0};\n  queue<P1> q;\n  P1 k=make_pair(P(sy1,sx1),P(sy2,sx2));\n  q.push(k);\n  visited[sy1][sx1][sy2][sx2]=true;\n  while(!q.empty()){\n    P1 t=q.front(); q.pop();\n    for(int i=0;i<4;i++){\n      int ny1=t.y1+dy[i],nx1=t.x1+dx[i];\n      int ny2=t.y2+dy[i],nx2=t.x2-dx[i];\n      if(ny1<0) ny1=0;\n      if(nx1<0) nx1=0;\n      if(h<=ny1) ny1=h-1;\n      if(w<=nx1) nx1=w-1;\n      if(ny2<0) ny2=0;\n      if(nx2<0) nx2=0;\n      if(h<=ny2) ny2=h-1;\n      if(w<=nx2) nx2=w-1;\n      if(r1[ny1][nx1]=='#') ny1=t.y1,nx1=t.x1;\n      if(r2[ny2][nx2]=='#') ny2=t.y2,nx2=t.x2;\n      P1 u=make_pair(P(ny1,nx1),P(ny2,nx2));\n      if(visited[ny1][nx1][ny2][nx2]) continue;\n      visited[ny1][nx1][ny2][nx2]=true;\n      q.push(u);\n      if(ny1==gy1&&nx1==gx1&&ny2==gy2&&nx2==gx2) return 1;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144*2LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nunsigned long xor128() {\n\tstatic unsigned long x = 123456789, y = 362436069, z = 521288629, w = time(NULL);\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid init() {\n\tiostream::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n}\n\n#define int ll\nint grid[50][50][50][50] = {};\nvoid solve(){\n\twhile (true) {\n\t\tint h, w;\n\t\tcin >> w >> h;\n\t\tif (w == 0) return;\n\t\tvector<string> inputs[2];\n\t\tREP(i, h) {\n\t\t\tREP(j, 2) {\n\t\t\t\tstring a;\n\t\t\t\tcin >> a;\n\t\t\t\tinputs[j].push_back(a);\n\t\t\t}\n\t\t}\n\t\tqueue<pair<pair<int, int>, pair<int, int>>> next;\n\t\tREP(i, h) {\n\t\t\tREP(q, w) {\n\t\t\t\tREP(j, h) {\n\t\t\t\t\tREP(t, w) {\n\t\t\t\t\t\tgrid[i][q][j][t] = 0;\n\t\t\t\t\t\tif (inputs[0][i][q] == 'L' && inputs[1][j][t] == 'R') {\n\t\t\t\t\t\t\tnext.push(mp(mp(i, q), mp(j, t)));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint cnt = 0;\n\t\t\t\t\t\tif (inputs[0][i][q] == '%') {\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (inputs[1][j][t] == '%') {\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (cnt == 1) {\n\t\t\t\t\t\t\tgrid[i][q][j][t] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (next.empty() == false) {\n\t\t\tpair<pair<int, int>, pair<int, int>> now = next.front();\n\t\t\tnext.pop();\n\t\t\tint dx[4] = { 1,-1,0,0 };\n\t\t\tint dy[4] = { 0,0,1,-1 };\n\t\t\tREP(q, 4) {\n\t\t\t\tpair<int, int> a = now.first;\n\t\t\t\tpair<int, int> b = now.second;\n\t\t\t\ta.first += dx[q];\n\t\t\t\ta.second += dy[q];\n\t\t\t\tb.first += dx[q];\n\t\t\t\tb.second += -1 * dy[q];\n\t\t\t\tif (!(a.first >= 0 && a.first < h && a.second >= 0 && a.second < w)) {\n\t\t\t\t\ta.first -= dx[q];\n\t\t\t\t\ta.second -= dy[q];\n\t\t\t\t}\n\t\t\t\tif (!(b.first >= 0 && b.first < h && b.second >= 0 && b.second < w)) {\n\t\t\t\t\tb.first -= dx[q];\n\t\t\t\t\tb.second -= -1 * dy[q];\n\t\t\t\t}\n\t\t\t\tif (inputs[0][a.first][a.second] == '#') {\n\t\t\t\t\ta.first -= dx[q];\n\t\t\t\t\ta.second -= dy[q];\n\t\t\t\t}\n\t\t\t\tif (inputs[1][b.first][b.second] == '#') {\n\t\t\t\t\tb.first -= dx[q];\n\t\t\t\t\tb.second -=  -1 * dy[q];\n\t\t\t\t}\n\t\t\t\tif (grid[a.first][a.second][b.first][b.second]) continue;\n\t\t\t\tgrid[a.first][a.second][b.first][b.second] = 1;\n\t\t\t\tnext.push(mp(a, b));\n\t\t\t}\n\t\t}\n\n\t\tREP(i, h) {\n\t\t\tREP(q, w) {\n\t\t\t\tREP(j, h) {\n\t\t\t\t\tREP(t, w) {\n\t\t\t\t\t\tif (inputs[0][i][q] == '%' && inputs[1][j][t] == '%') {\n\t\t\t\t\t\t\tif (grid[i][q][j][t] == 1) {\n\t\t\t\t\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tcout << \"No\" << endl;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgoto goi;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tgoi:;\n\t}\n}\n\n#undef int\nint main() {\n\tinit();\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <queue>\n#include <vector>\n#include <string.h>\nusing namespace std;\n\nstruct Node {\n  Node(int lx, int ly, int rx, int ry) {\n    this->lx = lx;\n    this->ly = ly;\n    this->rx = rx;\n    this->ry = ry;\n  }\n\n  int val() {\n    return lx * 8000000 + ly * 40000 + rx * 200 + ry;\n  }\n\n  int lx;\n  int ly;\n  int rx;\n  int ry;\n};\n\nbool done[52][52][52][52];\nint main() {\n  vector<vector<char> > f(103);\n  for (int i = 0; i < f.size(); i++) {\n    f[i].resize(52);\n  }\n\n  int oki = 0;\n  while (true) {\n    int W, H;\n    cin >> W >> H;\n\n    if (W == 0) {\n      break;\n    }\n\n    int cw = W + 1;\n    int w = W * 2 + 3;\n    int h = H + 2;\n    for (int i = 0; i < w; i++) {\n      f[i][0] = f[i][h - 1] = '#';\n    }\n    for (int i = 0; i < h; i++) {\n      f[0][i] = f[cw][i] = f[w - 1][i] = '#';\n    }\n\n    char lx = 0, ly = 0;\n    char rx = 0, ry = 0;\n    for (char i = 1; i < h - 1; i++) {\n      for (char j = 1; j < cw; j++) {\n  cin >> f[j][i];\n  if (f[j][i] == 'L') {\n    lx = j;\n    ly = i;\n    f[j][i] = '.';\n  }\n      }\n      for (char j = cw + 1; j < w - 1; j++) {\n  cin >> f[j][i];\n  if (f[j][i] == 'R') {\n    rx = j;\n    ry = i;\n    f[j][i] = '.';\n  }\n      }\n    }\n\n    set<int> s;\n    memset(done, 0, sizeof(done));\n    queue<Node> q;\n    q.push(Node(lx, ly, rx, ry));\n    int cnt = 0;\n    while (!q.empty()) {\n      Node n = q.front();\n\n      if (f[n.lx][n.ly] == '%' && f[n.rx][n.ry] == '%') {\n  cout << \"Yes\" << endl;\n  break;\n      }\n      q.pop();\n      ++cnt;\n      if (f[n.lx][n.ly] == '%' || f[n.rx][n.ry] == '%') {\n        continue;\n      }\n\n  //     if (s.count(n.val()) != 0) {\n  // continue;\n  //     }\n  //     s.insert(n.val());\n      // cerr << \"here\" << endl;\n      // cerr << n.lx << \", \" << n.ly << \" : \" << n.rx << \", \" << n.ry << endl;\n      if (done[n.lx][n.ly][n.rx - cw][n.ry]) {\n        continue;\n      }\n      done[n.lx][n.ly][n.rx - cw][n.ry] = true;\n\n      q.push(Node(n.lx,\n        f[n.lx][n.ly - 1] != '#' ? n.ly - 1 : n.ly,\n        n.rx,\n        f[n.rx][n.ry - 1] != '#' ? n.ry - 1 : n.ry)\n      );\n      q.push(Node(\n        f[n.lx - 1][n.ly] != '#' ? n.lx - 1 : n.lx,\n        n.ly,\n        f[n.rx + 1][n.ry] != '#' ? n.rx + 1 : n.rx,\n        n.ry)\n      );\n      q.push(Node(\n        f[n.lx + 1][n.ly] != '#' ? n.lx + 1 : n.lx,\n        n.ly,\n        f[n.rx - 1][n.ry] != '#' ? n.rx - 1 : n.rx, \n        n.ry)\n      );\n      q.push(Node(\n        n.lx,\n        f[n.lx][n.ly + 1] != '#' ? n.ly + 1 : n.ly,\n        n.rx,\n        f[n.rx][n.ry + 1] != '#' ? n.ry + 1 : n.ry)\n      );\n    }\n    oki = max(oki, cnt);\n    if (q.empty()) {\n      cout << \"No\" << endl;\n    }\n  }\n  // cerr << oki << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <tuple>\nusing namespace std;\n\ntypedef tuple<int,int,int,int> T;\n\nbool isChecked[50][50][50][50];\nbool mapL[50][50];//true:????????? false:????????????\nbool mapR[50][50];\n\nint main(){\n    int W,H;\n    while(cin>>W>>H,W){\n        int SRx,SRy,SLx,SLy,GRx,GRy,GLx,GLy;\n        fill(mapL[0],mapL[50],false);\n        fill(mapR[0],mapR[50],false);\n        for(int i=0;i<H;i++){\n            string strL, strR;\n            cin>>strL>>strR;\n            for(int j=0;j<W;j++){\n                char cL,cR;\n                cL=strL[j];\n                switch(cL){\n                    case '.':\n                        mapL[i][j]=true;\n                        break;\n                    case '#':\n                        break;\n                    case '%':\n                        mapL[i][j]=true;\n                        GLy=i; GLx=j;\n                        break;\n                    case 'L':\n                        mapL[i][j]=true;\n                        SLy=i; SLx=j;\n                        break;\n                }\n                cR=strR[W-1-j];\n                switch(cR){\n                    case '.':\n                        mapR[i][j]=true;\n                        break;\n                    case '#':\n                        break;\n                    case '%':\n                        mapR[i][j]=true;\n                        GRy=i; GRx=j;\n                        break;\n                    case 'R':\n                        mapL[i][j]=true;\n                        SRy=i; SRx=j;\n                        break;\n                }\n            }\n        }\n\n        fill(isChecked[0][0][0],isChecked[50][0][0],false);\n        isChecked[SLx][SLy][SRx][SRy]=true;\n        queue<T> que;\n        que.emplace(SLx,SLy,SRx,SRy);\n        bool ans=false;\n        while(!que.empty()){\n            T t = que.front(); que.pop();\n            int Lx=get<0>(t), Ly=get<1>(t), Rx=get<2>(t), Ry=get<3>(t);\n            isChecked[Lx][Ly][Rx][Ry]=true;\n            if(Lx==GLx&&Ly==GLy&&Rx==GRx&&Ry==GRy){\n                ans=true;\n                break;\n            }else if((Lx==GLx&&Ly==GLy)||(Rx==GRx&&Ry==GRy)){\n                continue;\n            }\n            int d[5]={-1,0,1,0,-1};\n            for(int i=0;i<4;i++){\n                int nLx,nLy,nRx,nRy;\n                int dx=d[i],dy=d[i+1];\n                if(Lx<0||Lx>W||Ly<0||Ly>H) continue;\n                if(mapL[Lx+dx][Ly+dy]){\n                    nLx=Lx+dx, nLy=Ly+dy;\n                }else{\n                    nLx=Lx, nLy=Ly;\n                }\n                if(mapR[Rx+dx][Ry+dy]){\n                    nRx=Rx+dx, nRy=Ry+dy;\n                }else{\n                    nRx=Rx, nRy=Ry;\n                }\n                if(nLx==Lx&&nLy==Ly&&nRx==Rx&&nRy==Ry){\n                    continue;\n                }else if(!isChecked[nLx][nLy][nRx][nRy]){\n                    que.emplace(nLx,nLy,nRx,nRy);\n                }\n            }\n        }\n        if(ans){\n            cout<<\"Yes\"<<endl;\n        }else{\n            cout<<\"No\"<<endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<sstream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<climits>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = j; i < k; i++)\n#define P pair<int, int>\nconst int INF = INT_MAX / 2;\nconst int MAX_H = 51;\nconst int MAX_W = 51;\n\nclass C{\n    public:\n        int rx, ry, lx, ly, step;\n        C(int _ry, int _rx, int _ly, int _lx, int _step);\n        bool operator>(const C &c) const{\n            return step > c.step;\n        }\n};\n\nC::C(int _ry, int _rx, int _ly, int _lx, int _step){\n    rx = _rx;\n    ry = _ry;\n    lx = _lx;\n    ly = _ly;\n    step = _step;\n}\n\nbool canMove(int y, int x, vector< vector<char> > m){\n    if(m[y][x] == '#') return false;\n    else return true;\n}\n\nint main(){\n    int w, h;\n    while(cin >>w >>h && (w || h) ){\n\n        int srx, sry, slx, sly;\n        int grx, gry, glx, gly;\n        vector< vector<char> > l_map(h + 2, vector<char>(w + 2, '*') ), r_map(h + 2, vector<char>(w + 2, '*') );\n        REP(i, l_map.size()){\n            l_map[i][0] = '#';\n            r_map[i][0] = '#';\n            l_map[i][w + 1] = '#';\n            r_map[i][w + 1] = '#';\n        }\n        REP(i, l_map[0].size()){\n            l_map[0][i] = '#';\n            r_map[0][i] = '#';\n            l_map[h + 1][i] = '#';\n            r_map[h + 1][i] = '#';\n        }\n\n        FOR(i, 1, h + 1){\n            FOR(j, 1, w + 1){\n                cin >>l_map[i][j];\n                if(l_map[i][j] == 'L'){\n                    sly = i;\n                    slx = j;\n                }\n                if(l_map[i][j] == '%'){\n                    gly = i;\n                    glx = j;\n                }\n            }\n            FOR(j, 1, w + 1){\n                cin >>r_map[i][j];\n                if(r_map[i][j] == 'R'){\n                    sry = i;\n                    srx = j;\n                }\n                if(r_map[i][j] == '%'){\n                    gry = i;\n                    grx = j;\n                }\n            }\n        }\n\n        priority_queue<C, vector<C>, greater<C> > open;\n        open.push( C(sry, srx, sly, slx, 0) );\n        int r_closed[MAX_H][MAX_W], l_closed[MAX_H][MAX_W];\n        memset(r_closed, -1, sizeof(r_closed));\n        memset(l_closed, -1, sizeof(l_closed));\n\n        bool ans = false;\n        int my[] = {0, 0, 1, -1};\n        int mx[] = {1, -1, 0, 0};\n\n        while(!open.empty()){\n            C now = open.top();\n            open.pop();\n\n            if(now.ry == gry && now.rx == grx && now.ly == gly && now.lx == glx){\n                ans = true;\n                break;\n            }\n            r_closed[now.ry][now.rx] = now.step;\n            l_closed[now.ly][now.lx] = now.step;\n\n\n            REP(i, 4){\n                int n_ry = now.ry + my[i];\n                int n_rx = now.rx + mx[i];\n                int n_ly = now.ly + my[i];\n                int n_lx = now.lx + (mx[i] * -1);\n\n                if(!canMove(n_ry, n_rx, r_map) && !canMove(n_ly, n_lx, l_map)){\n                    continue;\n                } else if(!canMove(n_ry, n_rx, r_map)){\n                    if(l_closed[n_ly][n_lx] != -1 && now.step + 1 > l_closed[n_ly][n_lx]) continue;\n                    n_ry = now.ry;\n                    n_rx = now.rx;\n                }\n                else if(!canMove(n_ly, n_lx, l_map)){\n                    if(r_closed[n_ry][n_rx] != -1 && now.step + 1 > r_closed[n_ry][n_rx]) continue;\n                    n_ly = now.ly;\n                    n_lx = now.lx;\n                } else{\n                    if((l_closed[n_ly][n_lx] != -1 && now.step + 1 > l_closed[n_ly][n_lx]) || (r_closed[n_ry][n_rx] != -1 && now.step + 1 > r_closed[n_ry][n_rx])) continue;\n                }\n\n                open.push( C(n_ry, n_rx, n_ly, n_lx, now.step + 1) );\n            }\n        }\n\n        cout <<((ans)? \"Yes\" : \"No\") <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#define N 52\n#define y1 first.first\n#define x1 first.second\n#define y2 second.first\n#define x2 second.second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\n\nint bfs();\n\nint w,h,sy1,sx1,sy2,sx2,gy1,gx1,gy2,gx2;\nstring r1[N],r2[N];\nbool visited[N][N][N][N];\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(!w&&!h) break;\n    for(int i=0;i<h;i++) cin>>r1[i]>>r2[i];\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tfor(int k=0;k<h;k++)\n\t  for(int l=0;l<w;l++) visited[i][j][k][l]=false;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(r1[i][j]=='L') sy1=i,sx1=j;\n\tif(r1[i][j]=='%') gy1=i,gx1=j;\n\tif(r2[i][j]=='R') sy2=i,sx2=j;\n\tif(r2[i][j]=='%') gy2=i,gx2=j;\n      }\n    if(bfs()) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n  return 0;\n}\n\nint bfs(){\n  int dy[4]={0,-1,0,1},dx[4]={-1,0,1,0};\n  queue<P1> q;\n  P1 k=make_pair(P(sy1,sx1),P(sy2,sx2));\n  q.push(k);\n  visited[sy1][sx1][sy2][sx2]=true;\n  while(!q.empty()){\n    P1 t=q.front(); q.pop();\n    for(int i=0;i<4;i++){\n      int ny1=t.y1+dy[i],nx1=t.x1+dx[i];\n      int ny2=t.y2+dy[i],nx2=t.x2-dx[i];\n      if(ny1<0) ny1=0;\n      if(nx1<0) nx1=0;\n      if(h<=ny1) ny1=h-1;\n      if(w<=nx1) nx1=w-1;\n      if(ny2<0) ny2=0;\n      if(nx2<0) nx2=0;\n      if(h<=ny2) ny2=h-1;\n      if(w<=nx2) nx2=w-1;\n      if(r1[ny1][nx1]=='#') ny1=t.y1,nx1=t.x1;\n      if(r2[ny2][nx2]=='#') ny2=t.y2,nx2=t.x2;\n      P1 u=make_pair(P(ny1,nx1),P(ny2,nx2));\n      if(ny1==gy1&&nx1==gx1&&ny2==gy2&&nx2==gx2) return 1;\n      if(visited[ny1][nx1][ny2][nx2]||(ny1==gy1&&nx1==gx1)||(ny2==gy2&&nx2==gx2)) continue;\n      visited[ny1][nx1][ny2][nx2]=true;\n      q.push(u);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define S second\n#define pb push_back\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nconst P dx[4] = {P(0,0),P(0,0),P(-1,1),P(1,-1)};\nconst P dy[4] = {P(1,1),P(-1,-1),P(0,0),P(0,0)};\nbool bmap[55][55][55][55];\nint main(){\n  int H,W;\n  while(cin >> W >> H && H+W){\n    char L_cmap[H+1][W+1],R_cmap[H+1][W+1];\n   \n    P Ls,Rs,Lg,Rg;\n    rep(i,H)\n      rep(j,W)\n        rep(k,H)\n          rep(l,W)\n            bmap[i][j][k][l] = false;\n\n    rep(i,H){\n      string s;\n      cin >> s;\n      rep(j,W){\n\tL_cmap[i][j] = s[j];\n\tif(s[j] == 'L')Ls = P(j,i);\n\tif(s[j] == '%')Lg = P(j,i);\n      }\n      cin >> s;\n      rep(j,W){\n\tR_cmap[i][j] = s[j];\n\tif(s[j] == 'R')Rs = P(j,i);\n\tif(s[j] == '%')Rg = P(j,i);\n      }\n    }\n\n    queue<PP> que;\n    que.push(PP(Ls,Rs));\n    bmap[Ls.F][Ls.S][Rs.F][Rs.S] = true;\n    bool fin = false;\n    while(!que.empty())\n      {\n\tPP pp = que.front(); que.pop();\n\tif(pp.F == Lg && pp.S == Rg){\n\t  fin = true;\n\t  cout << \"Yes\" << endl;\n\t  break;\n\t}\n\tif(pp.F == Lg || pp.S == Rg)continue;\n\n\trep(i,4){\n\t  int L_nx = pp.F.F+dx[i].F,L_ny = pp.F.S+dy[i].F;\n\t  int R_nx = pp.S.F+dx[i].S,R_ny = pp.S.S+dy[i].S;\n\t  if(!(0<= L_nx & L_nx < W && 0<= L_ny && L_ny < H) || L_cmap[L_ny][L_nx] == '#'){\n\t    L_nx = pp.F.F,L_ny = pp.F.S;\n\t  }\n\t  if(!(0<= R_nx & R_nx < W && 0<= R_ny && R_ny < H) || R_cmap[R_ny][R_nx] == '#'){\n\t    R_nx = pp.S.F,R_ny = pp.S.S;\n\t  }\n\t  if(bmap[L_nx][L_ny][R_nx][R_ny])continue;\n\t  bmap[L_nx][L_ny][R_nx][R_ny] = true;\n\t \n\t  que.push(insert(L_nx,L_ny,R_nx,R_ny));\n\t}\n      }\n    if(!fin)cout << \"No\" << endl;\n    \n  }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n// #define int ll\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#ifdef int\nconst ll INF = (1LL<<60);\n#else\nconst int INF = (1LL<<30);\n#endif\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[2][4] = {{0, 1, 0, -1}, {0, -1, 0, 1}}, dy[2][4] = {{1, 0, -1, 0}, {1, 0, -1, 0}};\n\nstring s1[55], s2[55];\nint d[55][55][55][55];\nsigned main(void)\n{\n  while(true) {\n    int w, h;\n    cin >> w >> h;\n    if(!w && !h) break;\n    REP(i, h) cin >> s1[i] >> s2[i];\n\n    int srx, sry, slx, sly, grx, gry, glx, gly;\n    REP(i, h) REP(j, w) {\n      if(s1[i][j] == 'L') {\n        srx = j, sry = i;\n      }\n      if(s1[i][j] == '%') {\n        grx = j, gry = i;\n      }\n      if(s2[i][j] == 'R') {\n        slx = j, sly = i;\n      }\n      if(s2[i][j] == '%') {\n        glx = j, gly = i;\n      }\n    }\n    // cout << srx << \" \" << sry << \" \" << grx << \" \" << gry << endl;\n    // cout << slx << \" \" << sly << \" \" << glx << \" \" << gly << endl;\n\n    queue<VI> que;\n    que.push({srx, sry, slx, sly});\n    memset(d, 0x3f, sizeof(d));\n    d[sry][srx][sly][slx] = 0;\n    while(que.size()) {\n      VI v = que.front(); que.pop();\n      int rx = v[0], ry = v[1], lx = v[2], ly = v[3];\n      // cout << rx << \" \" << ry << \" \" << lx << \" \" << ly << endl;\n      if(s1[ry][rx] == '%' && s2[ly][lx] == '%') break;\n      else if(s1[ry][rx] == '%' || s2[ly][lx] == '%') continue;\n      REP(i, 4) {\n        int nrx = rx + dx[0][i], nry = ry + dy[0][i], nlx = lx + dx[1][i], nly = ly + dy[1][i];\n        bool r = !IN(0, w, nrx) || !IN(0, h, nry) || s1[nry][nrx] == '#',\n             l = !IN(0, w, nlx) || !IN(0, h, nly) || s2[nly][nlx] == '#';\n        if(!r && !l) {\n          if(d[nry][nrx][nly][nlx] == 0x3f3f3f3f) {\n            d[nry][nrx][nly][nlx] = d[ry][rx][ly][lx] + 1;\n            que.push({nrx, nry, nlx, nly});\n          }\n        } else if(!r) {\n          if(d[nry][nrx][ly][lx] == 0x3f3f3f3f) {\n            d[nry][nrx][ly][lx] = d[ry][rx][ly][lx] + 1;\n            que.push({nrx, nry, lx, ly});\n          }\n        } else if(!l) {\n          if(d[ry][rx][nly][nlx] == 0x3f3f3f3f) {\n            d[ry][rx][nly][nlx] = d[ry][rx][ly][lx] + 1;\n            que.push({rx, ry, nlx, nly});\n          }\n        }\n      }\n    }\n\n    if(d[gry][grx][gly][glx] == 0x3f3f3f3f) cout << \"No\" << endl;\n    else cout << \"Yes\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\ntemplate<typename T>\nvoid O(T t){\n  cout << t << endl;\n}\n\nconst ll mod = 1e9+7;\nconstexpr ll inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\nll w,h;\n\nbool search(int lx,int ly,int rx,int ry,vector<string> &l,vector<string> &r){\n  bool res = false;\n  /* rep(i,h){                    */\n  /*   rep(j,w){                  */\n  /*     if(i == ly  && j == lx){ */\n  /*       cout << \"*\" ;          */\n  /*     }                        */\n  /*     else                     */\n  /*       std::cout << l[i][j];  */\n  /*   }                          */\n  /*   cout << endl;              */\n  /* }                            */\n  /* rep(i,h){                    */\n  /*   rep(j,w){                  */\n  /*     if(i == ry  && j == rx){ */\n  /*       cout << \"*\" ;          */\n  /*     }                        */\n  /*     else                     */\n  /*       std::cout << r[i][j];  */\n  /*   }                          */\n  /*   cout << endl;              */\n  /* }                            */\n  /* std::cout << std::endl;      */\n  rep(i,4){\n    int nlx = lx + dx[i],nly = ly + dy[i],nrx = rx - dx[i],nry = ry + dy[i];\n    if(value(nlx,nly,w,h) && l[nly][nlx] == '.' && value(nrx,nry,w,h) && r[nry][nrx] == '.'){\n      l[ly][lx] = '#';\n      r[ry][rx] = '#';\n      res |= search(nlx,nly,nrx,nry,l,r);\n      l[nly][nlx] = '.';\n      r[nry][nrx] = '.';\n    }\n    if(value(nlx,nly,w,h) && l[nly][nlx] == '.' && value(nrx,nry,w,h) && r[nry][nrx] == '#'){\n      l[ly][lx] = '#';\n      /* r[nry][nrx] = '#'; */\n      res |= search(nlx,nly,rx,ry,l,r);\n      l[nly][nlx] = '.';\n      /* r[nry][nrx] = '.'; */\n    }\n    if(value(nlx,nly,w,h) && l[nly][nlx] == '#' && value(nrx,nry,w,h) && r[nry][nrx] == '.'){\n      /* l[ly][lx] = '#'; */\n      r[ry][rx] = '#';\n      res |= search(nlx,nly,rx,ry,l,r);\n      /* l[nly][nlx] = '.'; */\n      r[nry][nrx] = '.';\n    }\n    if(value(nlx,nly,w,h) && l[nly][nlx] == '%' && value(nrx,nry,w,h) && r[nry][nrx] == '%'){\n      return true;\n    }\n  } \n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll lx,ly,rx,ry;\n  while(cin >> w >> h &&  w + h ){\n    vector<string> l(h),r(h);\n    rep(i,h){\n      cin >> l[i] >> r[i];\n      rep(j,w){\n        if(l[i][j] == 'L'){\n          ly = i;\n          lx = j;\n        }\n        if(r[i][j] == 'R'){\n          ry = i;\n          rx = j;\n        }\n      }\n    }\n    bool f = search(lx,ly,rx,ry,l,r);\n    std::cout << (f ? \"Yes\" : \"No\") << std::endl; \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n\nP lg, rg;\nint dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0}, h, w;\nint f[55][55][55][55];\nchar lf[50][51],rf[50][51]; \n\nint range(int a,int b){\n\treturn a >= 0 && a < h && b >= 0 && b < w;\n}\n\nint dfs(int ly,int lx,int ry,int rx){\n\tint i;\n\tif(lg.first == ly && lg.second == lx || rg.first == ry && rg.second == rx){\n\t\tif(lg.first == ly && lg.second == lx && rg.first == ry && rg.second == rx)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tfor(i = 0;i < 4;i++){\n\t\tif(range(ly + dy[i],lx + dx[i]) && range(ry + dy[i],rx - dx[i])){\n\t\t\tif(lf[ly + dy[i]][lx + dx[i]] != '#' && rf[ry + dy[i]][rx - dx[i]] != '#' && f[ly + dy[i]][lx + dx[i]][ry + dy[i]][rx - dx[i]]){\n\t\t\t\tf[ly + dy[i]][lx + dx[i]][ry + dy[i]][rx - dx[i]] = 0;\n\t\t\t\tif(dfs(ly + dy[i],lx + dx[i],ry + dy[i],rx - dx[i])) return 1;\n\t\t\t}\n\t\t\telse if(lf[ly + dy[i]][lx + dx[i]] != '#' && rf[ry + dy[i]][rx - dx[i]] == '#' && f[ly + dy[i]][lx + dx[i]][ry][rx]){\n\t\t\t\tf[ly + dy[i]][lx + dx[i]][ry][rx] = 0;\n\t\t\t\tif(dfs(ly + dy[i],lx + dx[i],ry,rx)) return 1;\n\t\t\t}\n\t\t\telse if(lf[ly + dy[i]][lx + dx[i]] == '#' && rf[ry + dy[i]][rx - dx[i]] != '#' && f[ly][lx][ry + dy[i]][rx - dx[i]]){\n\t\t\t\tf[ly][lx][ry + dy[i]][rx - dx[i]] = 0;\n\t\t\t\tif(dfs(ly,lx,ry + dy[i],rx - dx[i])) return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(void){\n\tint i, j;\n\tP rs, ls;\n\twhile(1){\n\t\tscanf(\"%d%d%*c\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tlf[i][j] = getchar();\n\t\t\t\tif(lf[i][j] == 'L'){\n\t\t\t\t\tls = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(lf[i][j] == '%'){\n\t\t\t\t\tlg = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 空白読み飛ばし\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\trf[i][j] = getchar();\n\t\t\t\tif(rf[i][j] == 'R'){\n\t\t\t\t\trs = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(rf[i][j] == '%'){\n\t\t\t\t\trg = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 改行文字読み飛ばし\n\t\t}\n\t\tmemset(f,-1,sizeof(f));\n\t\tf[ls.first][ls.second][rs.first][rs.second] = 0;\n\t\tprintf(\"%d %d %d %d\\n\",ls.second,ls.first,rs.second,rs.first);\n\t\tif(dfs(ls.first,ls.second,rs.first,rs.second))\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx_r[] = {0,1,0,-1};\nstatic const int ty_r[] = {-1,0,1,0};\n\nstatic const int tx_l[] = {0,-1,0,1};\nstatic const int ty_l[] = {-1,0,1,0};\n\nbool Rin_visited[50][50];\nbool Len_visited[50][50];\nchar stage_Len[50][50];\nchar stage_Rin[50][50];\n\nbool can_reach;\nint W,H;\n\nvoid Rin_dfs(int Rin_x,int Rin_y,int Len_x,int Len_y){\n  for(int i=0;i<4;i++){\n    int Rin_dx = Rin_x + tx_r[i];\n    int Rin_dy = Rin_y + ty_r[i];\n\n    int Len_dx = Len_x + tx_l[i];\n    int Len_dy = Len_y + ty_l[i];\n    if(Rin_dx < 0 || Rin_dx >= W || Rin_dy < 0 || Rin_dy >= H){\n\tcontinue;\n    }\n    if(Len_dx < 0 || Len_dx >= W || Len_dy < 0 || Len_dy >= H){\n      Len_dx = Len_x;\n      Len_dy = Len_y;\n    }\n    if(stage_Rin[Rin_dy][Rin_dx] == '#'){\n      continue;\n    }\n    if(stage_Len[Len_dy][Len_dx] == '#'){\n      Len_dy = Len_y;\n      Len_dx = Len_x;\n    }\n\n    if(Rin_visited[Rin_dy][Rin_dx]){\n      continue;\n    }\n\n\n    if(stage_Len[Len_dy][Len_dx] == '%'\n       && stage_Rin[Rin_dy][Rin_dx] == '%'){\n      can_reach = true;\n      return;\n    }\n\n    if(stage_Len[Len_dy][Len_dx] != '%'\n       && stage_Rin[Rin_dy][Rin_dx] != '%'){\n      Rin_visited[Rin_dy][Rin_dx] = true;\n      Rin_dfs(Rin_dx,Rin_dy,Len_dx,Len_dy);\n    }\n  }\n}\n\nvoid Len_dfs(int Rin_x,int Rin_y,int Len_x,int Len_y){\n  for(int i=0;i<4;i++){\n    int Rin_dx = Rin_x + tx_r[i];\n    int Rin_dy = Rin_y + ty_r[i];\n\n    int Len_dx = Len_x + tx_l[i];\n    int Len_dy = Len_y + ty_l[i];\n    if(Rin_dx < 0 || Rin_dx >= W || Rin_dy < 0 || Rin_dy >= H){\n      Rin_dx = Rin_x;\n      Rin_dy = Rin_y;\n    }\n    if(Len_dx < 0 || Len_dx >= W || Len_dy < 0 || Len_dy >= H){\n\tcontinue;\n    }\n    if(stage_Rin[Rin_dy][Rin_dx] == '#'){\n      Rin_dy = Rin_y;\n      Rin_dx = Rin_x;\n    }\n    if(stage_Len[Len_dy][Len_dx] == '#'){\n      continue;\n    }\n\n    if(Len_visited[Len_dy][Len_dx]){\n      continue;\n    }\n\n    Len_visited[Len_dy][Len_dx] = true;\n    if(stage_Len[Len_dy][Len_dx] == '%'\n       && stage_Rin[Rin_dy][Rin_dx] == '%'){\n      can_reach = true;\n      return;\n    }\n\n    if(stage_Len[Len_dy][Len_dx] != '%'\n       && stage_Rin[Rin_dy][Rin_dx] != '%'){\n      Len_visited[Len_dy][Len_dx] = true;\n      Len_dfs(Rin_dx,Rin_dy,Len_dx,Len_dy);\n    }\n  }\n}\n\nint main(){\n\n  while(~scanf(\"%d %d\",&W,&H)){\n    if(W==0 && H==0) break;\n\n    memset(Len_visited,false,sizeof(Len_visited));\n    memset(Rin_visited,false,sizeof(Rin_visited));\n    memset(stage_Rin,'\\0',sizeof(stage_Rin));\n    memset(stage_Len,'\\0',sizeof(stage_Len));\n\n    can_reach = false;\n    \n    int Rin_start_x = 0;\n    int Rin_start_y = 0;\n    int Len_start_x = 0;\n    int Len_start_y = 0;\n \n    for(int y=0;y<H;y++){\n      string str_Len,str_Rin;\n      cin >> str_Len >> str_Rin;\n      \n      // cout << str_Len << endl;\n      // cout << str_Rin << endl;\n\n      for(int x=0;x<W;x++){\n\tstage_Len[y][x] = str_Len[x];\n\tstage_Rin[y][x] = str_Rin[x];\n\n\tif(str_Len[x] == 'L'){\n\t  Len_start_x = x;\n\t  Len_start_y = y;\n\t}\n\tif(str_Rin[x] == 'R'){\n\t  Rin_start_x = x;\n\t  Rin_start_y = y;\n\t}\n      }\n    }\n\n    Len_dfs(Rin_start_x,Rin_start_y,Len_start_x,Len_start_y);\n    Rin_dfs(Rin_start_x,Rin_start_y,Len_start_x,Len_start_y);\n    printf(\"%s\\n\",can_reach ? \"Yes\" : \"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXH = 50;\nconst int MAXW = 50;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\n\nint W, H, li, lj, ri, rj;\nstring L[MAXH], R[MAXH];\nbool vis[MAXH][MAXW][MAXH][MAXW];\n\nint dfs(int a, int b, int c, int d) {\n  vis[a][b][c][d] = true;\n  if(L[a][b] == '%' && R[c][d] == '%') return true;\n  if(L[a][b] == '%' || R[c][d] == '%') return false;\n  for(int k = 0; k < 4; ++k) {\n    int na = a + di[k];\n    int nb = b + dj[k];\n    int nc = c + di[k];\n    int nd = d - dj[k];\n    if(na < 0 || na >= H) na = a;\n    if(nb < 0 || nb >= W) nb = b;\n    if(nc < 0 || nc >= H) nc = c;\n    if(nd < 0 || nd >= W) nd = d;\n    if(L[na][nb] == '#') na = a, nb = b;\n    if(R[nc][nd] == '#') nc = c, nd = d;\n    if(vis[na][nb][nc][nd]) continue;\n    if(dfs(na, nb, nc, nd)) return true;\n  }\n  return false;\n}\n\nint main() {\n  while(cin >> W >> H && (W|H)) {\n    for(int i = 0; i < H; ++i) {\n      cin >> L[i] >> R[i];\n      int l = L[i].find('L');\n      int r = L[i].find('R');\n      if(l != string::npos) {\n        li = i; lj = l;\n      }\n      if(r != string::npos) {\n        ri = i; rj = r;\n      }\n    }\n    memset(vis, 0, sizeof(0));\n    cout << (dfs(li, lj, ri, rj) ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, k, n) for (int i = (int)(k); i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rREP(i, k, n) for (int i = (int)(n)-1; i >= k; i--)\n\n#define debug(x) cerr << #x << \": \" << x << endl;\n\n#define fi first\n#define se second\n\n#define vi vector<int>\n#define pii pair<int, int>\n#define pb push_back\n#define mp make_pair\n\n#define pcnt __builtin_popcount\n\ntypedef long long ll;\n\nconst int    inf = 100100100;\nconst int    MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\nconst int    dx[4] = { 0, 1, 0, -1 };\nconst int    dy[4] = { 1, 0, -1, 0 };\n\nstruct POINT {\n    int lx;\n    int ly;\n    int rx;\n    int ry;\n};\n\nbool u[55][55][55][55] = {};\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    ifstream in(\"./input.txt\");\n    cin.rdbuf(in.rdbuf());\n    int    w, h;\n    string ML[55], MR[55];\n    int slx,sly,srx,sry;\n    while (cin >> w >> h, w) {\n        rep(y, h) cin >> ML[y] >> MR[y];\n        rep(y,h) rep(x,w){\n            if(ML[y][x] == 'L') slx = x,sly = y;\n            if(MR[y][x] == 'R') srx = x,sry = y;\n        }\n        queue<POINT> que;\n        que.push(POINT{slx, sly, srx, sry});\n\n        bool flag = false;\n        while (!que.empty()) {\n            POINT p = que.front();\n            que.pop();\n            if (u[p.lx][p.ly][p.rx][p.ry]) continue;\n            rep(i, 4) {\n                int nlx = p.lx + dx[i];\n                int nly = p.ly + dy[i];\n                int nrx = p.rx + dx[(i + 2) % 4];\n                int nry = p.ry + dy[i];\n                bool left_do = true;\n                bool right_do = true;\n                if (nlx < 0 || w <= nlx) left_do = false;\n                if (nly < 0 || h <= nly) left_do = false;\n                if (ML[nly][nlx] == '#') left_do = false;\n                if (nrx < 0 || w <= nrx) right_do = false;\n                if (nry < 0 || h <= nry) right_do = false;\n                if (MR[nry][nrx] == '#') right_do = false;\n                if (ML[nly][nlx] == '%' && MR[nry][nrx] == '%') {\n                    flag = true;\n                    while (!que.empty()) que.pop();\n                    break;\n                } else if (ML[nly][nlx] == '%' || MR[nry][nrx] == '%') {\n                    continue;\n                }\n                if (!left_do && !right_do) continue;\n                if (!left_do) nlx = p.lx, nly = p.ly;\n                if (!right_do) nrx = p.rx, nry = p.ry;\n                que.push(POINT{nlx, nly, nrx, nry});\n            }\n            u[p.lx][p.ly][p.rx][p.ry] = true;\n        }\n        if (flag)\n            cout << \"Yes\" << endl;\n        else\n            cout << \"No\" << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dh[]={1,0,-1,0};\nint dw[]={0,1,0,-1};\nint w,h;\n\nvoid insert(vector<vector<vector<vector<bool>>>> &dp,pair<pair<int,int>,pair<int,int>> p){\n    auto x=p.first;\n    auto y=p.second;\n    dp[x.first][x.second][y.first][y.second]=true;\n}\n\nbool count(vector<vector<vector<vector<bool>>>> &dp,pair<pair<int,int>,pair<int,int>> p){\n    auto x=p.first;\n    auto y=p.second;\n    return dp[x.first][x.second][y.first][y.second];\n}\n\nbool isrange(int x,int y){return 0<=x && x<h && 0<=y && y<w;};\nint main(){\n    \n    while(cin>>w>>h,w){\n        vector<string> rl(h),rr(h);\n        for(int i=0;i<h;i++){\n            cin>>rl[i]>>rr[i];\n        }\n        pair<int,int> lp;\n        pair<int,int> rp;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(rl[i][j]=='L') lp={i,j};\n                if(rr[i][j]=='R') rp={i,j};\n            }\n        }\n        stack<pair<pair<int,int>,pair<int,int>>> que;\n        que.push({lp,rp});\n        vector<vector<vector<vector<bool>>>> dp(h,vector<vector<vector<bool>>>(w,vector<vector<bool>>(h,vector<bool>(w,0))));\n        insert(dp,{lp,rp});\n        auto move=[&rl,&rr](int x,int dx,int y,int dy,bool isr){\n            if(!isrange(x+dx,y+dy)){\n                return make_pair(x,y);\n            }\n            if(isr){\n                if(rr[x+dx][y+dy]=='#') return make_pair(x,y);\n                else return make_pair(x+dx,y+dy);\n            }\n            else{\n                if(rl[x+dx][y+dy]=='#') return make_pair(x,y);\n                else return make_pair(x+dx,y+dy);\n            }\n        };\n        while(!que.empty()){\n            auto p=que.top();\n            que.pop();\n            for(int i=0;i<4;i++){\n                auto tol=move(p.first.first,dh[i],p.first.second,dw[i],0);\n                auto tor=move(p.second.first,dh[i],p.second.second,dw[(i+2)%2],1);\n                pair<pair<int,int>,pair<int,int>> tost={tol,tor};\n                if(count(dp,tost)) continue;\n                insert(dp,tost);\n                que.push(tost);\n            }\n        }\n        pair<int,int> obl;\n        pair<int,int> obr;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(rl[i][j]=='%') obl={i,j};\n                if(rr[i][j]=='%') obr={i,j};\n            }\n        }\n        if(count(dp,{obl,obr})) cout<<\"Yes\"<<endl;\n        else cout<<\"No\"<<endl;\n    }\n    return 0;\n}   "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing pi=pair<int,int>;\n\nint dx[]={0,1,0,-1};\nint dy[]={-1,0,1,0};\n\npair<pi,pi> susumu(pi tl,pi tr,int dir,vector<vector<char>> &l,vector<vector<char>> &r) {\n    pair<pi,pi> ret;\n    int ny,nx;\n    ny=tl.first+dy[dir];\n    nx=tl.second+dx[dir];\n    if(l[ny][nx]!='#')ret.first=pi(ny,nx);\n    else ret.first=tl;\n\n    if(dir==1||dir==3)dir=(dir+2)%4;\n    ny=tr.first+dy[dir];\n    nx=tr.second+dx[dir];\n    if(r[ny][nx]!='#')ret.second=pi(ny,nx);\n    else ret.second=tr;\n    return ret;\n}\n\nbool solve(){\n    int w,h;\n    cin>>w>>h;\n    if(w==0)return false;\n    pi tl,tr,gl,gr;\n    vector<vector<char>> l(h+2,vector<char>(w+2,'#')),r(h+2,vector<char>(w+2,'#'));\n    for (int i = 1; i <= h; ++i) {\n        char c;\n        for (int j = 1; j <= w; ++j) {\n            cin>>c;\n            l[i][j]=c;\n            if(c=='L')tl=pi(i,j);\n            if(c=='%')gl=pi(i,j);\n        }\n        for (int j = 1; j <= w; ++j) {\n            cin>>c;\n            r[i][j]=c;\n            if(c=='R')tr=pi(i,j);\n            if(c=='%')gr=pi(i,j);\n        }\n    }\n    set<pair<pi,pi>> st;\n    queue<pair<pi,pi>> q;\n    q.push(make_pair(tl,tr));\n    while(!q.empty()){\n        //cout<<q.size()<<endl;\n        auto p=q.front();\n        //cout<<p.first.first<<\" \"<<p.first.second<<\" \"<<p.second.first<<\" \"<<p.second.second<<endl;\n        q.pop();\n        if(p.first==gl&&p.second==gr){\n            cout<<\"Yes\"<<endl;\n            return true;\n        }\n        if(p.first==gl||p.second==gr)continue;\n        for (int i = 0; i < 4; ++i) {\n            auto np=susumu(p.first,p.second,i,l,r);\n            if(st.find(np)==st.end()){\n                q.push(np);\n                st.insert(np);\n            }\n        }\n    }\n    cout<<\"No\"<<endl;\n    return true;\n}\n\nint main(){\n    while(solve());\n    return 0;\n}\n\n/*\n50 50 間に合うんかこれ？\nL................................................. %.................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................. ..................................................\n.................................................% .................................................R\n */\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define pb push_back\n#define fi first\n#define sc second\nusing namespace std;\ntypedef pair<int,int> P;\n\nint w, h;\nP as, ae, bs, be;\nstring a[50], b[50];\nbool use[50][50][50][50];\nint daw[4] = {1,0,-1,0},dah[4]={0,1,0,-1};\nint dbw[4] = {-1,0,1,0},dbh[4]={0,1,0,-1};\n\nvoid dfs(int p, int q, int r, int s){\n\trep(i,4){\n\t\tint dp = p+dah[i],dq = q+daw[i];\n\t\tint dr = r+dbh[i],ds = s+dbw[i];\n\t\tif(0>dp||dp>=h||0>dq||dq>=w||a[dp][dq]=='#'){\n\t\t\tdp = p;\n\t\t\tdq = q;\n\t\t}\n\t\tif(0>dr||dr>=h||0>ds||ds>=w||b[dr][ds]=='#'){\n\t\t\tdr = r;\n\t\t\tds = s;\n\t\t}\n\t\tif(use[dp][dq][dr][ds]) continue;\n\t\tif(ae == P(dp,dq) && be != P(dr,ds)) continue;\n\t\tif(ae != P(dp,dq) && be == P(dr,ds)) continue;\n\t\tuse[dp][dq][dr][ds] = true;\n\t\tdfs(dp,dq,dr,ds);\n\t}\n}\n\nint main(){\n\twhile(scanf(\"%d%d\",&w,&h),w||h){\n\t\tmemset(use,0,sizeof(use));\n\t\trep(i,50) a[i].clear();\n\t\trep(i,50) b[i].clear();\n\t\trep(i,h) cin >> a[i] >> b[i];\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tif(a[i][j] == 'L') as = P(i,j);\n\t\t\t\tif(b[i][j] == 'R') bs = P(i,j);\n\t\t\t\tif(a[i][j] == '%') ae = P(i,j);\n\t\t\t\tif(b[i][j] == '%') be = P(i,j);\n\t\t\t}\n\t\t}\n\t\tuse[as.fi][as.sc][bs.fi][bs.sc] = true;\n\t\tdfs(as.fi,as.sc,bs.fi,bs.sc);\n\t\tif(use[ae.fi][ae.sc][be.fi][be.sc]) puts(\"Yes\");\n\t\telse puts(\"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint range(int a,int b,int h, int w){\n\treturn a >= 0 && a < h && b >= 0 && b < w;\n}\n\nP lg, rg;\nint dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0}, h, w;\nbool f[50][50][50][50];\nchar lf[50][51],rf[50][51]; \n\nint dfs(P l,P r){\n\tint i, ly, lx, ry, rx;\n\tly = l.first, lx = l.second, ry = r.first, rx = r.second;\n\tif(lg.first == ly && lg.second == lx || rg.first == ry && rg.second == rx){\n\t\tif(lg.first == ly && lg.second == lx && rg.first == ry && rg.second == rx)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tfor(i = 0;i < 4;i++){\n\t\tif(range(ly + dy[i],lx + dx[i],h,w) && range(ry + dy[i],rx - dx[i],h,w)){\n\t\t\tif(lf[ly + dy[i]][lx + dx[i]] != '#' && rf[ry + dy[i]][rx - dx[i]] != '#' && f[ly + dy[i]][lx + dx[i]][ry + dy[i]][rx - dx[i]]){\n\t\t\t\tf[ly + dy[i]][lx + dx[i]][ry + dy[i]][rx - dx[i]] = 0;\n\t\t\t\tif(dfs(P(ly + dy[i],lx + dx[i]),P(ry + dy[i],rx - dx[i]))) return 1;\n\t\t\t}\n\t\t\telse if(lf[ly + dy[i]][lx + dx[i]] != '#' && rf[ry + dy[i]][rx - dx[i]] == '#' && f[ly + dy[i]][lx + dx[i]][ry][rx]){\n\t\t\t\tf[ly + dy[i]][lx + dx[i]][ry][rx] = 0;\n\t\t\t\tif(dfs(P(ly + dy[i],lx + dx[i]),P(ry,rx))) return 1;\n\t\t\t}\n\t\t\telse if(lf[ly + dy[i]][lx + dx[i]] == '#' && rf[ry + dy[i]][rx - dx[i]] != '#' && f[ly][lx][ry + dy[i]][rx - dx[i]]){\n\t\t\t\tf[ly][lx][ry + dy[i]][rx - dx[i]] = 0;\n\t\t\t\tif(dfs(P(ly,lx),P(ry + dy[i],rx - dx[i]))) return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(void){\n\tint i, j;\n\tP rs, ls;\n\twhile(1){\n\t\tscanf(\"%d%d%*c\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tlf[i][j] = getchar();\n\t\t\t\tif(lf[i][j] == 'L'){\n\t\t\t\t\tls = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(lf[i][j] == '%'){\n\t\t\t\t\tlg = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 空白読み飛ばし\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\trf[i][j] = getchar();\n\t\t\t\tif(rf[i][j] == 'R'){\n\t\t\t\t\trs = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(rf[i][j] == '%'){\n\t\t\t\t\trg = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 改行文字読み飛ばし\n\t\t}\n\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tfor(int k = 0;k < h;k++)\n\t\t\t\t\tfor(int l = 0;l < w;l++) f[i][j][k][l] = 1;\n\t\t\t}\n\t\t}\n\t\tf[ls.first][ls.second][rs.first][rs.second] = 0;\n\t\tprintf(\"%d %d %d %d\\n\",ls.second,ls.first,rs.second,rs.first);\n\t\tif(dfs(ls,rs))\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> stat;\n\nint w, h;\npii ls, lg, rs, rg;\n\nint dx[]={0, 0, 1, -1}, dy[]={1, -1, 0, 0};\n\nbool border(pii p){\n\t\n\treturn 0<=p.first&&p.first<w&&0<=p.second&&p.second<h;\n}\n\nstring solve(vector<string> left, vector<string> right){\n\t\n\t\n\tstat start = make_pair(ls, rs), goal = make_pair(lg, rg);\n\t\n\tset<stat> vis;\n\tqueue<stat> qu;\n\t\n\tvis.insert(start);\n\tqu.push(start);\n\t\n\twhile(!qu.empty()){\n\t\n\t\tpii lnx, rnx;\n\t\tstat now = qu.front();\n\t\tqu.pop();\n\t\t\n\t\tfor(int i=0; i<4; ++i){\n\t\t\t\t\n\t\t\t\tlnx = make_pair(now.first.first + dx[i], \n\t\t\t\t\t\t\t\tnow.first.second + dy[i]);\n\t\t\t\t\n\t\t\t\trnx = make_pair(now.second.first - dx[i], \n\t\t\t\t\t\t\t\tnow.second.second + dy[i]);\n\t\t\t\t\n\t\t\t\tif(!border(lnx)||left[lnx.second][lnx.first]=='#')\n\t\t\t\t\tlnx = now.first;\n\t\t\t\t\t\n\t\t\t\tif(!border(rnx)||right[rnx.second][rnx.first]=='#')\n\t\t\t\t\trnx = now.second;\n\t\t\t\t\n\t\t\t\tstat nx = make_pair(lnx, rnx);\n\t\t\t\t\n\t\t\t\tif(nx == goal)\n\t\t\t\t\treturn \"Yes\";\n\t\t\t\t\n\t\t\t\tif(vis.count(nx)==0){\n\t\t\t\t\t\n\t\t\t\t\tvis.insert(nx);\n\t\t\t\t\tqu.push(nx);\n\t\t\t\t}\n\t\t}\n\t}\n\t\n\treturn \"No\";\n}\n\t\nint main(){\n\t\n\twhile(cin>>w>>h, (w||h)){\n\t\t\n\t\tvector<string> left, right;\n\t\t\n\t\tfor(int i=0; i<h; ++i){\n\t\t\t\n\t\t\tstring l, r;\n\t\t\tcin >> l >> r;\n\t\t\t\n\t\t\tleft.push_back(l);\n\t\t\tright.push_back(r);\n\t\t}\n\t\t\n\t\tfor(int y=0; y<h; ++y){\n\t\t\tfor(int x=0; x<w; ++x){\n\t\t\t\n\t\t\t\tif(left[y][x] == 'L')\n\t\t\t\t\tls = make_pair(x, y);\n\t\t\t\tif(left[y][x] == '%')\n\t\t\t\t\tlg = make_pair(x, y);\n\t\t\t\tif(right[y][x] == 'R')\n\t\t\t\t\trs = make_pair(x, y);\n\t\t\t\tif(right[y][x] == '%')\n\t\t\t\t\trg = make_pair(x, y);\n\t\t\t}\n\t\t}\n\t\t \n\t\tcout <<\tsolve(left, right) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MAX 51\n#include<cstring>\nusing namespace std;\n\nbool f=false,visited[MAX][MAX][MAX][MAX];\nint w,h;\nchar L[MAX][MAX],R[MAX][MAX];\n\nint ldy[]={0,-1,0,1};\nint ldx[]={1,0,-1,0};\nint rdy[]={0,-1,0,1};\nint rdx[]={-1,0,1,0};\n\nvoid dfs(int ly,int lx, int ry, int rx){\n  visited[ly][lx][ry][rx] = true;\n\n  int nly,nlx,nry,nrx;\n  for(int i=0; i<4; i++){\n    nly = ly + ldy[i];\n    nlx = lx + ldx[i];\n    nry = ry + rdy[i];\n    nrx = rx + rdx[i];\n\n    if(!visited[nly][nlx][nry][nrx] &&\n       0<=nly && nly<h && 0<=nlx && nlx<w && 0<=nry && nry<h && 0<=nrx && nrx<w){\n      if(L[nly][nlx]=='%' && R[nry][nrx]=='%'){\n\tf = true;\n\treturn ;\n      }\n      if(L[nly][nlx]=='%' || R[nry][nrx]=='%') visited[nly][nlx][nry][nrx] = true;\n      if(L[nly][nlx]=='#' && R[nry][nrx]=='.') dfs(ly,lx,nry,nrx);\n      if(L[nly][nlx]=='.' && R[nry][nrx]=='#') dfs(nly,nlx,ry,rx);\n      if(L[nly][nlx]='.' && R[nry][nrx]=='.')  dfs(nly,nlx,nry,nrx);\n    }\n    if((nlx<0 || w<=nlx) && (0<=nrx && nrx<w) && R[nry][nrx]=='.')    dfs(ly,lx,nry,nrx);\n    if((nrx<0 || w<=nrx) && (0<=nlx && nlx<w) && L[nly][nlx]=='.')    dfs(nly,nlx,ry,rx);\n    if((nry<0 || w<=nry) && (0<=nly && nly<w) && L[nly][nlx]=='.')    dfs(nly,nlx,ry,rx);\n    if((nly<0 || w<=nly) && (0<=nry && nry<w) && L[nly][nlx]=='.')    dfs(ly,lx,nry,nrx);\n      \n  }\n}\n\n\nint main(){\n\n  while(cin >> w >> h ,w|h){\n    cin.ignore();\n\n    for(int i=0; i<h; i++){\n      string str;\n      getline(cin,str);\n      bool first=true;\n      int cnt = 0;\n      for(int j=0; j<str.size(); j++){\n\tif(str[j]==' '){\n\t  first = false;\n\t  continue;\n\t}\n\tif(first) L[i][j] = str[j];\n\telse R[i][cnt++] = str[j];\n      }\n    }\n    int sly,slx,sry,srx;\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tif(L[i][j]=='L'){\n\t  sly = i;\n\t  slx = j;\n\t}\n\tif(R[i][j]=='R'){\n\t  sry = i;\n\t  srx = j;\n\t}\n      }\n    }\n\n    f = false;\n    memset(visited,false,sizeof(visited));\n    visited[sly][slx][sry][srx]=true;\n    dfs(sly,slx,sry,srx);\n    if(f) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a,exp) [&](const t & a) -> bool { return exp; }\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b,exp) [&](const t & a, const t & b) -> bool { return exp; }\n#define CONVERTER(TSrc,t,TDest,exp) [&](const TSrc &t)->TDest { return exp; }\n\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tint cases = INF;\n\tREP(_, cases)\n\t{\n\t\tREAD(int, w, h);\n\t\tif (!w) { break; }\n\t\tvector<string> lmap, rmap;\n\t\tlmap.push_back(string(w + 2, '#'));\n\t\trmap.push_back(string(w + 2, '#'));\n\t\tint lx, ly, rx, ry, Lx, Ly, Rx, Ry;\n\t\tREP(_, h)\n\t\t{\n\t\t\tREAD(string, ls, rs);\n\t\t\tlmap.push_back(\"#\" + ls + \"#\");\n\t\t\trmap.push_back(\"#\" + rs + \"#\");\n\t\t\t{ int p = ls.find_first_of('L'); if (p != ls.npos) { ly = _ + 1; lx = p + 1; } }\n\t\t\t{ int p = rs.find_first_of('R'); if (p != rs.npos) { ry = _ + 1; rx = p + 1; } }\n\t\t\t{ int p = ls.find_first_of('%'); if (p != ls.npos) { Ly = _ + 1; Lx = p + 1; } }\n\t\t\t{ int p = rs.find_first_of('%'); if (p != rs.npos) { Ry = _ + 1; Rx = p + 1; } }\n\t\t}\n\t\tlmap.push_back(string(w + 2, '#'));\n\t\trmap.push_back(string(w + 2, '#'));\n\t\tw += 2; h += 2;\n\n\t\tvevevevector<bool> visited(w, h, w, h);\n\t\tstruct status { int lx, ly, rx, ry, cost, h; };\n\t\t//priority_queue<status, vector<status>, COMPARISON_T(status)> q(COMPARISON(status, a, b, a.cost + a.h > b.cost + b.h));\n\t\tqueue<status> q;\n\t\tint result = INF;\n\t\tconst int dy[] = { 1, -1, 0, 0 }, dxl[] = { 0, 0, -1, 1 }, dxr[] = { 0, 0, 1, -1 };\n\t\tq.push({ lx, ly, rx, ry, 0, INF });\n\t\twhile (!q.empty())\n\t\t{\n\t\t\t//status s = q.top(); q.pop();\n\t\t\tstatus s = q.front(); q.pop();\n\t\t\tif (visited[s.lx][s.ly][s.rx][s.ry]) continue;\n\t\t\tvisited[s.lx][s.ly][s.rx][s.ry] = true;\n\t\t\tbool lok = s.lx == Lx && s.ly == Ly;\n\t\t\tbool rok = s.rx == Rx && s.ry == Ry;\n\n\t\t\tif (lok || rok) { if (lok && rok) { result = s.cost; break; } continue; }\n\t\t\t\n\t\t\tREP(i, 4)\n\t\t\t{\n\t\t\t\tint nlx = s.lx + dxl[i];\n\t\t\t\tint nly = s.ly + dy[i];\n\t\t\t\tint nrx = s.rx + dxr[i];\n\t\t\t\tint nry = s.ry + dy[i];\n\t\t\t\t//int h = abs(Lx - nlx) + abs(Ly - nly) + abs(Ry - nry) + abs(Ry - nry);\n\t\t\t\tif (lmap[nly][nlx] == '#') { nlx = s.lx; nly = s.ly; }\n\t\t\t\tif (rmap[nry][nrx] == '#') { nrx = s.rx; nry = s.ry; }\n\t\t\t\tq.push({ nlx, nly, nrx, nry, s.cost + 1, 0 });\n\t\t\t}\n\t\t}\n\t\tWRITE(result != INF ? \"Yes\" : \"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#include <string>\n#include <vector>\n#include <set>\n#include <cstring>\nusing namespace std;\n\ntypedef pair<pair<int,int>,pair<int,int> > pii;\n#define REP(i,n) for(int i=0; i<n; ++i)\n\nbool state[50][50][50][50];\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\n\nint main() {\n    int w,h;\n    while(cin>>w>>h, w|h) {\n        vector<string> left(h),right(h);\n        REP(i,h) cin>>left[i]>>right[i];\n\n        int lx,ly,rx,ry;\n        int glx,gly,grx,gry;\n        REP(i,h) REP(j,w) {\n            if(left[i][j] == 'L') lx = j, ly = i, left[i][j] = '.';\n            if(left[i][j] == '%') glx = j, gly = i, left[i][j] = '.';\n        }\n        REP(i,h) REP(j,w) {\n            if(right[i][j] == 'R') rx = j, ry = i, right[i][j] = '.';\n            if(right[i][j] == '%') grx = j, gry = i, right[i][j] = '.';\n        }\n\n        memset(state, false, sizeof(state));\n        queue<pii> Q;\n        Q.push(make_pair(make_pair(lx,ly),make_pair(rx,ry)));\n        while(!Q.empty()) {\n            pii now = Q.front(); Q.pop();\n            int lx = now.first.first, ly = now.first.second;\n            int rx = now.second.first, ry = now.second.second;\n            if(lx == glx && ly == gly\n               && rx == grx && ry == gry) {\n                goto SUCCESS;\n            }\n            if(lx == glx && ly == gly) continue;\n            if(rx == grx && ry == gry) continue;\n            if(state[lx][ly][rx][ry]) continue;\n            state[lx][ly][rx][ry] = true;\n            for(int i=0; i<4; ++i) {\n                int nlx = lx + dx[i],nly = ly + dy[i];\n                int nrx = rx + dx[(i+2)%4],nry = ry + dy[i];\n                nlx = min(w-1, max(0, nlx));\n                nrx = min(w-1, max(0, nrx));\n                nly = min(h-1, max(0, nly));\n                nry = min(h-1, max(0, nry));\n                if(nlx < 0 || nlx >= w || nrx < 0 || nrx >= w) continue;\n                if(nry < 0 || nry >= h || nly < 0 || nly >= h) continue;\n                if(left[nly][nlx] == '#') {\n                    nly = ly;\n                    nlx = lx;\n                }\n                if(right[nry][nrx] == '#') {\n                    nry = ry;\n                    nrx = rx;\n                }\n                Q.push(make_pair(make_pair(nlx,nly),make_pair(nrx,nry)));\n            }\n        }\n\n        goto BAD;\n    SUCCESS:\n        cout<<\"Yes\"<<endl;\n        continue;\n    BAD:\n        cout<<\"No\"<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <tuple>\n#include <queue>\n#include <vector>\n\n#define FOR(i,k,n)  for(int i = (k);i < (n);++i)\n#define REP(i,n)    FOR(i,0,n)\n\nusing namespace std;\n\nint dp[50][50][50][50];\n\nvoid search(int si, int sj, int sk, int sm, int w, int h,vector<string>& l, vector<string>& r) {\n  queue<tuple<int,int,int,int,int>> q;\n  q.push(make_tuple(0,si,sj,sk,sm));\n  int di[]={1,0,-1,0};\n  int dj[]={0,1,0,-1};\n  while(!q.empty()){\n    int i,j,k,m,d;\n    tie(d,i,j,k,m) = q.front();q.pop();\n    if(d > dp[i][j][k][m]) continue;\n    REP(n,4){\n      int ni=i+di[n];\n      int nj=j+dj[n];\n      int nk=k+di[n];\n      int nm=m-dj[n];\n      if(ni<0||nj<0||ni>=h||nj>=w){\n        ni=i;nj=j;\n      }\n      if(nk<0||nm<0||nk>=h||nm>=w){\n        nk=k;nm=m;\n      }\n      if(!(l[ni][nj] == '%' && r[nk][nm] == '%')) {\n        if(l[ni][nj] == '%' || r[nk][nm] == '%') continue;\n        if(l[ni][nj] != '.'){\n          ni=i;nj=j;\n        }\n        if(r[nk][nm] != '.'){\n          nk=k;nm=m;\n        }\n      }\n      if(dp[ni][nj][nk][nm] > dp[i][j][k][m] + 1) {\n        dp[ni][nj][nk][nm] = dp[i][j][k][m] + 1;\n        q.push(make_tuple(dp[ni][nj][nk][nm], ni,nj,nk,nm));\n      }\n    }\n  }\n}\n\nint main()\n{\n  while(1){\n    int w,h;\n    cin>>w>>h;\n    if(!w)break;\n    vector<string> l;\n    vector<string> r;\n    int si,sj,sk,sm;\n    int ti,tj,tk,tm;\n    REP(i,h){\n      string s,t;\n      cin>>s>>t;\n      l.push_back(s);\n      r.push_back(t);\n      REP(j,w){\n        if(l[i][j] == 'L'){\n          si=i;sj=j;\n        }\n        if(l[i][j] == '%'){\n          ti=i;tj=j;\n        }\n        if(r[i][j] == 'R'){\n          sk=i;sm=j;\n        }\n        if(r[i][j] == '%'){\n          tk=i;tm=j;\n        }\n      }\n    }\n    REP(i,h)REP(j,w)REP(k,h)REP(m,w)\n      dp[i][j][k][m] = 1000000000;\n    dp[si][sj][sk][sm] = 0;\n    search(si,sj,sk,sm,w,h,l,r);\n    if (dp[ti][tj][tk][tm]<1000000000) \n      cout << \"Yes\" << endl;\n    else\n      cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint W, H;\nbool reached[50][50][50][50];\nbool wall[2][50][50];\nint gx[2], gy[2];\n\ntypedef pair<int, int> P;\n\nstruct Node {\n\tint x1, y1, x2, y2;\n};\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {-1, 0, 1, 0};\n\nbool inRange(int x, int y) {\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\nbool isGoal(int id, int x, int y) {\n\treturn x == gx[id] && y == gy[id];\n}\nbool isWall(int id, int x, int y) {\n\tif ( !inRange(x, y) ) return true;\n\treturn wall[id][y][x];\n}\nP go(int id, int x, int y, int d) {\n\tint nx = x + dx[d], ny = y + dy[d];\n\tif ( isWall(id, nx, ny) ) return P(x, y);\n\treturn P(nx, ny);\n}\n\nint main() {\n\twhile ( cin >> W >> H, W || H ) {\n\t\tfill(&reached[0][0][0][0], &reached[0][0][0][0]+50*50*50*50, false);\n\t\tint sx[2], sy[2];\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\t\tstring str; cin >> str;\n\t\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\t\tswitch (str[x]) {\n\t\t\t\t\t\tcase '.': wall[i][y][x] = false; break;\n\t\t\t\t\t\tcase '#': wall[i][y][x] = true; break;\n\t\t\t\t\t\tcase '%': wall[i][y][x] = false; gx[i] = x, gy[i] = y; break;\n\t\t\t\t\t\tcase 'R':\n\t\t\t\t\t\tcase 'L': wall[i][y][x] = false; sx[i] = x, sy[i] = y; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<Node> Q; Q.push((Node){sx[0], sy[0], sx[1], sy[1]});\n\t\treached[sx[0]][sy[0]][sx[1]][sy[1]] = true;\n\t\twhile ( !Q.empty() ) {\n\t\t\tNode node = Q.front(); Q.pop();\n\t\t\tint x1 = node.x1, y1 = node.y1;\n\t\t\tint x2 = node.x2, y2 = node.y2;\n\t\t\tif ( !isGoal(0, x1, y1) && !isGoal(1, x2, y2) ) {\n\t\t\t\tfor (int d = 0; d < 4; ++d) {\n\t\t\t\t\tint d1 = d, d2 = d % 2 == 0 ? d : (d+2)%4;\n\t\t\t\t\tP p1 = go(0, x1, y1, d1);\n\t\t\t\t\tP p2 = go(1, x2, y2, d2);\n\t\t\t\t\tint nx1 = p1.first, ny1 = p1.second;\n\t\t\t\t\tint nx2 = p2.first, ny2 = p2.second;\n\t\t\t\t\tif ( !reached[nx1][ny1][nx2][ny2] ) {\n\t\t\t\t\t\treached[nx1][ny1][nx2][ny2] = true;\n\t\t\t\t\t\tQ.push((Node){nx1, ny1, nx2, ny2});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (reached[gx[0]][gy[0]][gx[1]][gy[1]]) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <map>\n#include <algorithm>\n#define fr first\n#define sc second\nusing namespace std;\n\n// first:x, second:y\ntypedef pair<int, int> iP;\ntypedef pair<iP, iP> iiiP;\n\niP sR, sL;\nint h, w, used[50][50][50][50];\nint dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\nchar mapR[51][51], mapL[51][51];\nbool judge;\n\nvoid bfs(){\n  queue <iiiP> que;\n  que.push(iiiP(sL, sR));\n  used[sL.fr][sL.sc][sR.fr][sR.sc] = 1;\n  while(!que.empty()){\n    iiiP p = que.front(); que.pop();\n    for(int i = 0; i < 4; i++){\n      int Lnx = min(w-1, max(0, p.fr.fr + dx[i]));\n      int Lny = min(h-1, max(0, p.fr.sc + dy[i]));\n      int Rnx = min(w-1, max(0, p.sc.fr - dx[i]));\n      int Rny = min(h-1, max(0, p.sc.sc + dy[i]));\n      \n      if(mapL[Lny][Lnx] == '%' && mapR[Rny][Rnx] == '%'){ judge = true; break; }\n      if(mapL[Lny][Lnx] == '#') Lnx = p.fr.fr, Lny = p.fr.sc;\n      if(mapR[Rny][Rnx] == '#') Rnx = p.sc.fr, Rny = p.sc.sc;\n      if(!used[Lny][Lnx][Rny][Rnx]){\n\tque.push(iiiP(iP(Lnx, Lny), iP(Rnx, Rny)));\n\tused[Lny][Lnx][Rny][Rnx] = 1;\n      }\n    }\n  }\n}\n\nint main(){\n  \n  while(cin >> w >> h, w){\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n\tcin >> mapL[i][j];\n\tif(mapL[i][j] == 'L') sL.fr = j, sL.sc = i;\n      }\n      \n      for(int j = 0; j < w; j++){\n\tcin >> mapR[i][j];\n\tif(mapR[i][j] == 'R') sR.fr = j, sR.sc = i;\n      }\n    }\n\n    judge = false;\n    memset(used, 0, sizeof(used));\n    bfs();\n    if(judge) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <sstream>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cstring>\n \nusing namespace std;\n\nconst int dx[]={0,1,0,-1};\nconst int dy[]={-1,0,1,0};\nchar vis[50][50][50][50];\n/*\nbool solve(int xl,int yl,int xr, int yr)\n{\n\n\n\tif(vis[yl][xl][yr][xr]==1) return false;\n\t\t\n\tif(L[yl][xl]=='%' && R[yr][xr]=='%') return true;\n\tif(L[yl][xl]=='%' && R[yr][xr]!='%') return false;\n\tif(L[yl][xl]!='%' && R[yr][xr]=='%') return false;\n\t\n\n\t\n\tvis[yl][xl][yr][xr]=1;\n\t\n\tfor(int i=0;i<4;i++){\n\t\tint nxl=xl+dx[i], nyl=yl+dy[i];\n\t\tint nxr=xr-dx[i], nyr=yr+dy[i];\n\n\t\tif(nxl<0 || w<=nxl || nyl<0 || h<=nyl ||\n\t\t   nxr<0 || w<=nxr || nyr<0 || h<=nyr ) continue;\n\t\t\n\t\tif(L[nyl][nxl]=='#'){\n\t\t\tnxl-=dx[i]; nyl-=dy[i];\n\t\t}\n\t\tif(R[nyr][nxr]=='#'){\n\t\t\tnxr+=dx[i]; nyr-=dy[i];\n\t\t}\n\n\t\tif(nxl<0 || w<=nxl || nyl<0 || h<=nyl ||\n\t\t   nxr<0 || w<=nxr || nyr<0 || h<=nyr ) continue;\n\t\t\n\t\tif(solve(nxl,nyl,nxr,nyr)) return true;\n\t\t\n\t}\n\t\n\treturn false;\n\n}\n*/\nclass Pos{\npublic:\n\tpair<int,int> posL,posR;\n\tPos(int xl,int yl,int xr,int yr){\n\t\tposL=make_pair(xl,yl);\n\t\tposR=make_pair(xr,yr);\n\t}\n};\n\n\nint main()\n{\n\n\tint w,h;\n\twhile(cin>>w>>h,w){\t\t\n\n\n\t\tmemset(vis,-1,sizeof(char)*50*50*50*50);\n\n\n\t\tstring L[100],R[100];\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>L[i]>>R[i];\n\t\t}\n\t\t\n\t\tint sxl,syl,sxr,syr;\t\t\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(L[i][j]=='L'){sxl=j,syl=i;}\n\t\t\t\tif(R[i][j]=='R'){sxr=j,syr=i;}\n\t\t\t}\n\t\t}\n\n\t\tbool ok=false;\n\t\tqueue<Pos> q;\n\t\tq.push(Pos(sxl,syl,sxr,syr));\n\t\twhile(!q.empty()){\n\t\t\tPos pos=q.front(); q.pop();\n\t\t\tint xl=pos.posL.first, yl=pos.posL.second;\n\t\t\tint xr=pos.posR.first, yr=pos.posR.second;\n\n\t\t\tif(L[yl][xl]=='%' && R[yr][xr]=='%') {ok=true; break;}\n\t\t\tif(L[yl][xl]=='%' && R[yr][xr]!='%') continue;\n\t\t\tif(L[yl][xl]!='%' && R[yr][xr]=='%') continue;\n\t\t\t\n\t\t\tif(vis[xl][yl][xr][yr]==1) continue;\n\t\t\t\n\t\t\tvis[xl][yl][xr][yr]=1;\n\t\t\t\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nxl=xl+dx[i], nyl=yl+dy[i];\n\t\t\t\tint nxr=xr-dx[i], nyr=yr+dy[i];\n\t\t\n\t\t\t\tif(nxl<0 || w<=nxl || nyl<0 || h<=nyl ||\n\t\t\t\t   nxr<0 || w<=nxr || nyr<0 || h<=nyr ) continue;\n\t\t\t\t\n\t\t\t\tif(L[nyl][nxl]=='#'){\n\t\t\t\t\tnxl-=dx[i]; nyl-=dy[i];\n\t\t\t\t}\n\t\t\t\tif(R[nyr][nxr]=='#'){\n\t\t\t\t\tnxr+=dx[i]; nyr-=dy[i];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tq.push(Pos(nxl,nyl,nxr,nyr));\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\tif(ok) cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n\t\t\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <set>\n#include <queue>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\tint h, w, i, j, a, b, c, d, dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\n\tchar rf[50][51], lf[50][51];\n\tP rs, ls, rg, lg;\n\tqueue<P> r, l;\n\twhile(1){\n\t\tscanf(\"%d%d%*c\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tset<pair<P,P> > s;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tlf[i][j] = getchar();\n\t\t\t\tif(lf[i][j] == 'L'){\n\t\t\t\t\tls = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(lf[i][j] == '%'){\n\t\t\t\t\tlg = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 空白読み飛ばし\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\trf[i][j] = getchar();\n\t\t\t\tif(rf[i][j] == 'R'){\n\t\t\t\t\trs = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(rf[i][j] == '%'){\n\t\t\t\t\trg = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 改行文字読み飛ばし\n\t\t}\n\t\tr.push(rs), l.push(ls);\n\t\twhile(r.size()){\n\t\t\ta = l.front().first, b = l.front().second, c = r.front().first, d = r.front().second;\n\t\t\tl.pop(), r.pop();\n\t\t\ts.insert(pair<P,P>(P(a,b),P(c,d)));\n\t\t\tfor(i = 0;i < 4;i++){\n\t\t\t\tif(a + dy[i] >= 0 && a + dy[i] < h && b + dx[i] >= 0 && b + dx[i] < w && lf[a + dy[i]][b + dx[i]] == '.' && c + dy[i] >= 0 && c + dy[i] < h && d - dx[i] >= 0 && d - dx[i] < w && rf[c + dy[i]][d - dx[i]] == '.' && s.find(pair<P,P>(P(a + dy[i],b + dx[i]),P(c + dy[i],d - dx[i]))) == s.end()) // 両方とも動くとき\n\t\t\t\t\tl.push(P(a + dy[i],b + dx[i])), r.push(P(c + dy[i],d - dx[i]));\n\t\t\t\telse if((a + dy[i] < 0 || a + dy[i] >= h || b + dx[i] < 0 || b + dx[i] >= w || lf[a + dy[i]][b + dx[i]] == '#') && c + dy[i] >= 0 && c + dy[i] < h && d - dx[i] >= 0 && d - dx[i] < w && rf[c + dy[i]][d - dx[i]] == '.' && s.find(pair<P,P>(P(a,b),P(c + dy[i],d - dx[i]))) == s.end()) // Rinだけ動く\n\t\t\t\t\tl.push(P(a,b)), r.push(P(c + dy[i],d - dx[i]));\n\t\t\t\telse if(a + dy[i] >= 0 && a + dy[i] < h && b + dx[i] >= 0 && b + dx[i] < w && lf[a + dy[i]][b + dx[i]] == '.' && (c + dy[i] < 0 || c + dy[i] >= h || d - dx[i] < 0 || d - dx[i] >= w || rf[c + dy[i]][d - dx[i]] == '#') && s.find(pair<P,P>(P(a + dy[i],b + dx[i]),P(c,d))) == s.end()) // Lenだけ動く\n\t\t\t\t\tl.push(P(a + dy[i],b + dx[i])), r.push(P(c,d));\n\t\t\t}\n\t\t}\n\t\tif(s.find(pair<P,P>(P(lg.first,lg.second),P(rg.first,rg.second))) != s.end())\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define M 52\n#include<cstring>\nusing namespace std;\nbool flag;\nint dx[]={1,-1,0,0},dy[]={0,0,-1,1},w,h;\nchar r[M][M],l[M][M];\nbool dp[M][M][M][M];\nvoid func(int ly,int lx,int ry,int rx){\n\tif(flag)\n\treturn;\n\t//cout<<ly<<' '<<lx<<' '<<ry<<' '<<rx<<endl;\n\tif(dp[ly][lx][ry][rx]!=0)\n\treturn;\n\tdp[ly][lx][ry][rx]=1;\n\tif(l[ly][lx]=='%'&&r[ry][rx]=='%'){\n\t\tflag=true;\n\t\treturn;\n\t}else if(l[ly][lx]=='%'||r[ry][rx]=='%')\n\treturn;\n\tint nrx,nry,nlx,nly;\n\tfor(int i=0;i<4;i++){\n\t\tnrx=dx[i]+rx;\n\t\tnry=dy[i]+ry;\n\t\tnlx=-dx[i]+lx;\n\t\tnly=dy[i]+ly;\n\t\tif(!(nrx>=0&&nrx<w&&nry>=0&&nry<h)||r[nry][nrx]=='#'){\n\t\t\tnrx=rx;nry=ry;\n\t\t}\n\t\tif(!(nlx>=0&&nlx<w&&nly>=0&&nly<h)||l[nly][nlx]=='#'){\n\t\t\tnlx=lx;nly=ly;\n\t\t}\n\t\tif(dp[nly][nlx][nry][nrx]==0)\n\t\tfunc(nly,nlx,nry,nrx);\n\t}\n}\nint main(){\n\tint a,b,c,d;\n\twhile(cin>>w>>h,h||w){\n\t\tfor(int i=0;i<h;i++)\n\t\t\tcin>>l[i]>>r[i];\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(l[i][j]=='L'){\n\t\t\t\t\ta=i;b=j;\n\t\t\t\t}\n\t\t\t\tif(r[i][j]=='R'){\n\t\t\t\t\tc=i;d=j;\n\t\t\t\t}\n\t\t}\n\t\tmemset(dp,0,sizeof(dp));\n\t\tflag=false;\n\t\tfunc(a,b,c,d);\n\t\tputs(flag?\"Yes\":\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <deque>\n#define rep(i,a) for (int i = 0; i < (a); i++)\nusing namespace std;\n\nint W, H, wl, hl, wr, hr, dw, dh;\nint nwl, nhl, nwr, nhr, wlg, hlg, wrg, hrg;\nint dws[] = {1,0,-1,0}, dhs[] = {0,1,0,-1};\nchar dummy, A[51][51], B[51][51];\nbool visited[51][51][51][51];\n\nstruct Array {\n    int wl, hl, wr, hr;\n    Array(int wl0, int hl0, int wr0, int hr0) {\n        wl = wl0, hl = hl0;\n        wr = wr0, hr = hr0;\n    }\n};\n        \n\nint main(void){\n    while (cin >> W >> H, W) {\n        rep(h, H) {\n            rep(w, W) cin >> A[h][w];\n            rep(w, W) cin >> B[h][w];\n        }\n        rep(h, H) {\n            rep(w, W) {\n                if (A[h][w] == 'L') wl  = w, hl  = h;\n                if (B[h][w] == 'R') wr  = w, hr  = h;\n                if (A[h][w] == '%') wlg = w, hlg = h;\n                if (B[h][w] == '%') wrg = w, hrg = h;\n            }\n        }\n\n        rep(i, H) rep(j, W) rep(k, H) rep(l, W) visited[i][j][k][l] = false;\n        visited[hl][wl][hr][wr] = true;\n        bool flag = false;\n        deque<Array> que;\n        que.push_back(Array(wl,hl,wr,hr));\n        while (!que.empty()) {\n            Array tmp = que.front(); que.pop_front();\n            wl = tmp.wl, hl = tmp.hl;\n            wr = tmp.wr, hr = tmp.hr;\n            if (wl == wlg && hl == hlg && wr == wrg && hr == hrg) {\n                cout << \"Yes\" << endl;\n                flag = true;\n                break;\n            }\n            \n            rep(i, 4) {\n                dw = dws[i], dh = dhs[i];\n                nwl = min(W-1,max(0,wl+dw)), nhl = min(H-1,max(0,hl+dh));\n                if (A[nhl][nwl] == '#') nwl = wl, nhl = hl;\n                nwr = min(W-1,max(0,wr-dw)), nhr = min(H-1,max(0,hr+dh));\n                if (B[nhr][nwr] == '#') nwr = wr, nhr = hr;\n                \n                if (!visited[nhl][nwl][nhr][nwr]) {\n                    if ((nwl == wlg && nhl == hlg) ^ (nwr == wrg && nhr == hrg)) continue;\n                    visited[nhl][nwl][nhr][nwr] = true;\n                    que.push_back(Array(nwl,nhl,nwr,nhr));\n                }\n            }\n        }\n        if (!flag) cout << \"No\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n\n#define F first\n#define S second\n\nusing namespace std;\n\nconst int MAX = 51;\ntypedef pair<int,int> P;\nchar M[2][MAX][MAX];\nbool come[MAX][MAX][MAX][MAX];\nint W,H;\nP s1,s2;\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\n\nvoid init(){\n  memset(come,false,sizeof(come));\n}\n\nvoid print(){\n  for(int x = 0; x < 2; x++){\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++) cout << M[x][i][j];\n      cout << endl;\n    }\n    cout << endl<< endl;\n  }\n}\n\nvoid input(){\n  for(int i = 0; i < H; i++)\n    for(int x = 0; x < 2; x++)\n      for(int j = 0; j < W; j++){\n\tcin >> M[x][i][j];\n\tif(M[x][i][j] == 'L' && !x) s1 = P(i,j);\n\tif(M[x][i][j] == 'R' && x) s2 = P(i,j);\n\t}\n}\n\nbool isInside(int x, int y){return 0<=x&&x<W&&0<=y&&y<H;}\n\nbool rec(int x1, int y1, int x2, int y2){\n\n  if(come[x1][y1][x2][y2]) return false;\n  come[x1][y1][x2][y2] = true;\n  //cout << x1 <<  \" \" << y1 << \" \" << x2 << \" \" << y2 <<endl;\n  if(M[0][y1][x1] == '%' && M[1][y2][x2] == '%') return true;\n  if(M[0][y1][x1] == '%' || M[1][y2][x2] == '%') return false;\n  \n  bool tmp = false;\n\n  for(int i = 0; i < 4; i++){\n    int nx1 = x1+dx[i];\n    int ny1 = y1+dy[i];\n    int nx2 = x2-dx[i];\n    int ny2 = y2+dy[i];\n    if(!isInside(nx1,ny1) || M[0][ny1][nx1] == '#'){\n      nx1 = x1;\n      ny1 = y1;\n    }\n    if(!isInside(nx2,ny2) || M[1][ny2][nx2] == '#'){\n      nx2 = x2;\n      ny2 = y2;\n    }\n    \n    if(!come[nx1][ny1][nx2][ny2]) tmp =(tmp||rec(nx1,ny1,nx2,ny2));\n  }\n  return tmp;\n} \n\nvoid solve(){\n  if(rec(s1.S,s1.F,s2.S,s2.F)) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n}\n\nint main(){\n  while(cin >> W >> H && W+H){\n    init();\n    input();\n    //   print();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<string>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\nint w,h;\nbool dp[51][51][51][51];\nint fie[2][51][51];\nint sx[2],sy[2];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint rev[4]={-1,1,-1,1};\n\nclass data{\npublic:\n\tint x1,y1,x2,y2;\n\tdata(){}\n\tdata(int ix1,int iy1,int ix2,int iy2){\n\t\tx1=ix1;\n\t\ty1=iy1;\n\t\tx2=ix2;\n\t\ty2=iy2;\n\t}\n};\n\nbool bfs(){\n\tmemset(dp,false,sizeof(dp));\n\tqueue<data> que;\n\tque.push(data(sx[0],sy[0],sx[1],sy[1]));\n\twhile(que.size()){\n\t\tdata q=que.front();\n\t\tque.pop();\n\t\tdp[q.x1][q.y1][q.x2][q.y2]=true;\n\t\tif(fie[0][q.x1][q.y1]+fie[1][q.x2][q.y2]==2)return true;\n\t\tif(fie[0][q.x1][q.y1]+fie[1][q.x2][q.y2]==1)continue;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx1=q.x1+dx[i],ny1=q.y1+dy[i];\n\t\t\tint nx2=q.x2+dx[i]*rev[i],ny2=q.y2+dy[i]*rev[i];\n\t\t\tif(nx1>=0 && nx1<w && ny1>=0 && ny1<h);\n\t\t\telse nx1-=dx[i],ny1-=dy[i];\n\t\t\tif(nx2>=0 && nx2<w && ny2>=0 && ny2<h);\n\t\t\telse nx2-=dx[i]*rev[i],ny2-=dy[i]*rev[i];\n\t\t\tif(fie[0][nx1][ny1]==-1){\n\t\t\t\t\tnx1-=dx[i];\n\t\t\t\t\tny1-=dy[i];\n\t\t\t\t}\n\t\t\tif(fie[1][nx2][ny2]==-1){\n\t\t\t\tnx2-=dx[i]*rev[i];\n\t\t\t\tny2-=dy[i]*rev[i];\n\t\t\t}\n\t\t\tif(!dp[nx1][ny1][nx2][ny2]){\n\t\t\t\tdp[nx1][ny1][nx2][ny2]=true;\n\t\t\t\tque.push(data(nx1,ny1,nx2,ny2));\n\t\t\t\t//printf(\"%d %d %d %d\\n\",nx1,ny1,nx2,ny2);\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w+h==0)break;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tstring str[2];\n\t\t\tcin >> str[0] >> str[1];\n\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(str[k][j]=='.')fie[k][j][i]=0;\n\t\t\t\t\tif(str[k][j]=='#')fie[k][j][i]=-1;\n\t\t\t\t\tif(str[k][j]=='%')fie[k][j][i]=1;\n\t\t\t\t\tif(str[k][j]=='R'){\n\t\t\t\t\t\tfie[k][j][i]=0;\n\t\t\t\t\t\tsx[k]=j,sy[k]=i;\n\t\t\t\t\t}\n\t\t\t\t\tif(str[k][j]=='L'){\n\t\t\t\t\t\tfie[k][j][i]=0;\n\t\t\t\t\t\tsx[k]=j,sy[k]=i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\",bfs()?\"Yes\":\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<int, int> Point;\n\nconst int N = 50;\n\nint w, h;\nchar room[2][N][N];\nbool vis[N][N][N][N];\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = {0, 1, 0, -1};\n\nvoid check(int& y, int& x){\n  if(y < 0) y = 0;\n  if(y >= h) y = h;\n  if(x < 0) x = 0;\n  if(x >= w) x = w;\n}\n\nbool dfs(Point l, Point r){\n  vis[l.first][l.second][r.first][r.second] = true;\n  if(room[0][l.first][l.second] == '%' && room[1][r.first][r.second] == '%'){\n    return true;\n  }else if(room[0][l.first][l.second] == '%' || room[1][r.first][r.second] == '%'){\n    return false;\n  }else{\n    for(int i=0;i<4;i++){\n      Point nl = Point(l.first + dy[i], l.second + dx[i]);\n      Point nr = Point(r.first + dy[i], r.second - dx[i]);\n      check(nl.first, nl.second);\n      check(nr.first, nr.second);\n      if(room[0][nl.first][nl.second] == '#') nl = l;\n      if(room[1][nr.first][nr.second] == '#') nr = r;\n      if(vis[nl.first][nl.second][nr.first][nr.second]) continue;\n      if(dfs(nl, nr)) return true;\n    }\n  }\n  return false;\n}\n\nmain(){\n  Point l, r;\n  while(cin >> w >> h && (w|h)){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> room[0][i][j];\n        if(room[0][i][j] == 'L'){\n          l = Point(i, j);\n          room[0][i][j] = '.';\n        }\n      }\n      for(int j=0;j<w;j++){\n        cin >> room[1][i][j];\n        if(room[1][i][j] == 'R'){\n          r = Point(i, j);\n          room[1][i][j] = '.';\n        }\n      }      \n    }\n    fill(vis[0][0][0], vis[N][0][0], false);\n    cout << (dfs(l, r) ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#define N 52\n#define y1 first.first\n#define x1 first.second\n#define y2 second.first\n#define x2 second.second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\n\nvoid bfs();\n\nint w,h,sy1,sx1,sy2,sx2,gy1,gx1,gy2,gx2,ans;\nstring r1[N],r2[N];\nset<P1> visited;\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(!w&&!h) break;\n    for(int i=0;i<h;i++) cin>>r1[i]>>r2[i];\n    cout<<endl;\n    for(int i=0;i<h;i++) cout<<r1[i]<<endl;\n    cout<<endl;\n    for(int i=0;i<h;i++) cout<<r2[i]<<endl;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(r1[i][j]=='L') sy1=i,sx1=j;\n\tif(r1[i][j]=='%') gy1=i,gx1=j;\n\tif(r2[i][j]=='R') sy2=i,sx2=j;\n\tif(r2[i][j]=='%') gy2=i,gx2=j;\n      }\n    ans=0;\n    bfs();\n    if(ans) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n    visited.clear();\n  }\n  return 0;\n}\n\nvoid bfs(){\n  int dy[4]={0,-1,0,1},dx[4]={-1,0,1,0};\n  queue<P1> q;\n  P1 k=make_pair(P(sy1,sx1),P(sy2,sx2));\n  q.push(k);\n  visited.insert(k);\n  while(!q.empty()){\n    P1 t=q.front(); q.pop();\n    for(int i=0;i<4;i++){\n      int ny1=t.y1+dy[i],nx1=t.x1+dx[i];\n      int ny2=t.y2-dy[i],nx2=t.y2-dx[i];\n      if(ny1<0) ny1=0;\n      if(nx1<0) nx1=0;\n      if(h<=ny1) ny1=h-1;\n      if(w<=nx1) nx1=w-1;\n      if(ny2<0) ny2=0;\n      if(nx2<0) nx2=0;\n      if(h<=ny2) ny2=h-1;\n      if(w<=nx2) nx2=w-1;\n      if(r1[ny1][nx1]=='#') ny1=t.y1,nx1=t.x1;\n      if(r2[ny2][nx2]=='#') ny2=t.y2,nx2=t.x2;\n      P1 u=make_pair(P(ny1,nx1),P(ny2,nx2));\n      if(visited.count(u)) continue;\n      visited.insert(u);\n      q.push(u);\n      if(ny1==gy1&&nx1==gx1&&ny2==gy2&&nx2==gx2){\n\tans=1;\n\treturn ;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\nint const dxL[] = {-1,0,1,0};\nint const dxR[] = {1,0,-1,0};\nint const dy[]  = {0,-1,0,1};\ntypedef pair<int, int> Pii;\n#define X first\n#define Y second\nint const INF = 1<<28;\nint W, H;\nchar grL[51][51], grR[51][51];\nint dist[2500][2500];\ninline bool isValid(int x, int y) {\n  if(0<=x&&x<W && 0<=y&&y<H) return true;\n  return false;\n}\n\ninline bool inF(int x, int y, int isL) {\n  if(isL) return grL[y][x]!='#';\n  return grR[y][x]!='#';\n}\ninline int toNode(int x, int y) {\n  return y*W+x;\n}\ninline void toPos(int node, int &x, int &y) {\n  x = node%W, y = node/W;\n}\nint main() {\n  \n  while(cin >> W >> H && (W|H)) {\n    int sxL, syL, sxR, syR;\n    int gxL, gyL, gxR, gyR;\n    for(int i=0; i<H; i++) {\n      for(int j=0; j<2*W; j++) {\n        if(j<W) {\n          cin >> grL[i][j];\n          if(grL[i][j] == 'L') {\n            sxL = j, syL = i;\n          }\n          if(grL[i][j] == '%') {\n            gxL = j, gyL = i;\n          }\n        }\n        else {\n          cin >> grR[i][j-W];\n          if(grR[i][j-W] == 'R') {\n            sxR = j-W, syR = i;\n          }\n          if(grR[i][j-W] == '%') {\n            gxR = j-W, gyR = i;\n          }\n        }\n      }\n    }\n    \n    queue<int> qL, qR;\n    qL.push(toNode(sxL, syL)); qR.push(toNode(sxR, syR));\n    bool ok = false;\n    fill(dist[0], dist[0]+2500*2500, INF);\n    dist[toNode(sxL, syL)][toNode(sxR, syR)] = 0;\n    \n    while(!qL.empty()) {\n      const int nowL = qL.front(); qL.pop();\n      const int nowR = qR.front(); qR.pop();\n      int lx, ly; toPos(nowL, lx, ly);\n      int rx, ry; toPos(nowR, rx, ry);\n\n      if(lx == gxL && ly == gyL && rx == gxR && ry == gyR) {\n        ok = true; break;\n      }\n      if(lx == gxL && ly == gyL) {\n        continue;\n      }\n      if(rx == gxR && ry == gyR) {\n        continue;\n      }\n      for(int i=0; i<4; i++) {\n        int nxL = lx+dxL[i], nyL = ly+dy[i];\n        int nxR = rx+dxR[i], nyR = ry+dy[i];\n\n        if((!isValid(nxL, nyL)) || (!isValid(nxR, nyR))) continue;\n\n        if((!inF(nxL, nyL, 1)) && (!inF(nxR, nyR, 0))) continue;\n        if(!inF(nxL, nyL, 1)) { nxL = lx, nyL = ly; }\n        if(!inF(nxR, nyR, 0)) { nxR = rx, nyR = ry; }\n        if(dist[toNode(nxL, nyL)][toNode(nxR, nyR)] != INF) continue;\n        qL.push(toNode(nxL, nyL));\n        qR.push(toNode(nxR, nyR));\n        dist[toNode(nxL, nyL)][toNode(nxR, nyR)] = dist[nowL][nowR]+1;\n        //cout << dist[toNode(nxL, nyL)][toNode(nxR, nyR)] << endl;\n      }\n    }\n    if(ok) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define ck(a,b) (0<=(a)&&(a)<b)\nusing namespace std;\nint dx[]={-1,1,0,0},dy[]={0,0,-1,1};\nstruct S{\n\tint lx,ly,rx,ry;\n\tS(int a,int b,int c,int d):lx(a),ly(b),rx(c),ry(d){}\n};\nbool V[50][50][50][50];\nint main(){\n\tint w,h;\n\twhile(cin>>w>>h,w){\n\t\tint lx,ly,rx,ry;\n\t\tstring cavel[h],caver[h];\n\t\trep(i,h)cin>>cavel[i]>>caver[i];\n\t\trep(i,h)rep(j,w){\n\t\t\tif(cavel[i][j]=='L')ly=i,lx=j,cavel[i][j]='.';\n\t\t\tif(caver[i][j]=='R')ry=i,rx=j,caver[i][j]='.';\n\t\t}\n\t\tqueue<S> F; rep(i,h)rep(j,w)rep(k,h)rep(l,w)V[i][j][k][l]=0;\n\t\tF.push_back(S(lx,ly,rx,ry)); V[ly][lx][ry][rx]=1;\n\t\tint goal=0;\n\t\twhile(!F.empty()&&!goal){\n\t\t\tqueue<S> nF;\n\t\t\trep(i,F.size())rep(d,4){\n\t\t\t\tint clx=F[i].lx,cly=F[i].ly,crx=F[i].rx,cry=F[i].ry;\n\t\t\t\tint nlx=clx+dx[d],nly=cly+dy[d],nrx=crx-dx[d],nry=cry+dy[d];\n\t\t\t\tif(!ck(nlx,w)||!ck(nly,h)||cavel[nly][nlx]=='#')nlx=clx,nly=cly;\n\t\t\t\tif(!ck(nrx,w)||!ck(nry,h)||caver[nry][nrx]=='#')nrx=crx,nry=cry;\n\t\t\t\tif(nlx==clx&&nly==cly&&nrx==crx&&nry==cry)continue;\n\t\t\t\tif(cavel[nly][nlx]=='%'^caver[nry][nrx]=='%')continue;\n\t\t\t\tif(cavel[nly][nlx]=='%'&&caver[nry][nrx]=='%'){\n\t\t\t\t\tgoal=1; goto END;\n\t\t\t\t}\n\t\t\t\tif(!V[nly][nlx][nry][nrx]){\n\t\t\t\t\tnF.push_back(S(nlx,nly,nrx,nry));\n\t\t\t\t\tV[nly][nlx][nry][nrx]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tF=nF;\n\t\t}\n\t\tEND:cout<<(goal?\"Yes\":\"No\")<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nstruct state { int ly, lx, ry, rx; };\n\nint W, H, SLY, SLX, SRY, SRX;\nchar S[2][50][50];\nbool visited[50][50][50][50];\nint dd[5] = { 0, 1, 0, -1, 0 };\n\nbool isin(int y, int x) {\n  return 0 <= y && y < H && 0 <= x && x < W;\n}\n\nint main(void) {\n  while(cin >> W >> H, W || H) {\n    REP(i, 0, H) {\n      cin >> S[0][i];\n      cin >> S[1][i];\n      REP(j, 0, W) if(S[0][i][j] == 'L') SLY = i, SLX = j;\n      REP(j, 0, W) if(S[1][i][j] == 'R') SRY = i, SRX = j;\n    }\n\n    REP(i, 0, 50) REP(j, 0, 50) REP(k, 0, 50) REP(l, 0, 50) visited[i][j][k][l] = false;\n\n    queue<state> q;\n    q.push((state) { SLY, SLX, SRY, SRX });\n\n    int ans = -1;\n    while(q.size()) {\n      state c = q.front();\n      q.pop();\n\n      if(visited[c.ly][c.lx][c.ry][c.rx]) continue;\n      visited[c.ly][c.lx][c.ry][c.rx] = true;\n\n      bool f1 = S[0][c.ly][c.lx] == '%';\n      bool f2 = S[1][c.ry][c.rx] == '%';\n      if((!f1 && f2) || (f1 && !f2)) continue;\n      if(f1 && f2) {\n        ans = 0;\n        break;\n      }\n\n      REP(i, 0, 4) {\n        state n = (state) { c.ly + dd[i], c.lx + dd[i + 1], c.ry + dd[i], c.rx - dd[i + 1] };\n        bool ok1 = isin(n.ly, n.lx) && S[0][n.ly][n.lx] != '#';\n        bool ok2 = isin(n.ry, n.rx) && S[1][n.ry][n.rx] != '#';\n        if(ok1 && ok2) q.push(n);\n        if(ok1 && !ok2) q.push((state) { n.ly, n.lx, c.ry, c.rx });\n        if(!ok1 && ok2) q.push((state) { c.ly, c.lx, n.ry, n.rx });\n      }\n    }\n\n    if(ans == -1) cout << \"No\" << endl;\n    else cout << \"Yes\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <string.h>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <set>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\n#define For(i,a,n)\tfor(int i = a;i < n;i++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(n)\t\tmemset(n,0,sizeof n)\n#define all(n)\t\t(n).begin(),(n).end()\n\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\ntypedef pair<P, P> WP;\ntypedef long long ll;\n\nconst ll INF = 1e9;\nint dx[4] = { 0, 1, 0, -1 }, dy[4] = { 1, 0, -1, 0 };\nbool cheak(int x, int y, int mx, int my){\n\treturn x >= 0 && y >= 0 && x < mx &&  y < my;\n}\n\nstring s[2][51];\n\nint d[51][51][51][51];\n\nint main()\n{\n\tint w, h;\n\n\twhile (cin >> w >> h && w){\n\t\tclr(d);\n\t\tint sx[2], sy[2];\n\t\tint gx[2], gy[2];\n\t\trep(y, h){\n\t\t\tcin >> s[0][y] >> s[1][y];\n\t\t\trep(x, w){\n\t\t\t\tif (s[0][y][x] == '%')gx[0] = x, gy[0] = y;\n\t\t\t\tif (s[1][y][x] == '%')gx[1] = x, gy[1] = y;\n\t\t\t\tif (s[0][y][x] == 'L')sx[0] = x, sy[0] = y;\n\t\t\t\tif (s[1][y][x] == 'R')sx[1] = x, sy[1] = y;\n\t\t\t}\n\t\t}\n\t\td[sy[0]][sx[0]][sy[1]][sx[1]] = 1;\n\n\t\tqueue<P> q0, q1;\n\t\tq0.push(P(sy[0], sx[0]));\n\t\tq1.push(P(sy[1], sx[1]));\n\n\t\twhile (q0.size()){\n\t\t\tint ly = q0.front().first, lx = q0.front().second;\n\t\t\tint ry = q1.front().first, rx = q1.front().second;\n\t\t\tq0.pop(), q1.pop();\n\n\t\t\trep(i, 4){\n\t\t\t\tint nlx = lx + dx[i], nly = ly + dy[i];\n\t\t\t\tint nrx = rx - dx[i], nry = ry + dy[i];\n\n\t\t\t\tbool lf = (cheak(nlx, nly, w, h) && s[0][nly][nlx] != '#');\n\t\t\t\tbool rf = (cheak(nrx, nry, w, h) && s[1][nry][nrx] != '#');\n\n\t\t\t\tif ((rf || lf)){\n\t\t\t\t\tif (!lf)nlx = lx, nly = ly;\n\t\t\t\t\tif (!rf)nrx = rx, nry = ry;\n\t\t\t\t\tif (!d[nly][nlx][nry][nrx]){\n\n\t\t\t\t\t\tif (s[0][nly][nlx] == '%' || s[1][nry][nrx] == '%'){\n\t\t\t\t\t\t\tif (!s[0][nly][nlx] == '%' || !s[1][nry][nrx] == '%'){\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\td[nly][nlx][nry][nrx] = 1;\n\t\t\t\t\t\tq0.push(P(nly, nlx));\n\t\t\t\t\t\tq1.push(P(nry, nrx));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (d[gy[0]][gx[0]][gy[1]][gx[1]])cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint lsx, lsy, ltx, lty, rsx, rsy, rtx, rty;\nbool dfs(vector<vector<vvi>> &dp, int lx, int ly, int rx, int ry) {\n\tif (dp[ly][lx][ry][rx] != -1)return dp[ly][lx][ry][rx];\n\treturn true;\n}\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint w, h;\n\twhile (cin >> w >> h, w) {\n\t\tvector<string> l(h), r(h);\n\t\tREP(i, h) cin >> l[i] >> r[i];\n\n\t\tREP(i, h) {\n\t\t\tREP(j, h) {\n\t\t\t\tif (l[i][j] == '%') {\n\t\t\t\t\tltx = j; lty = i;\n\t\t\t\t}\n\t\t\t\tif (l[i][j] == 'L') {\n\t\t\t\t\tlsx = j; lsy = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tREP(i, h) {\n\t\t\tREP(j, h) {\n\t\t\t\tif (r[i][j] == '%') {\n\t\t\t\t\trtx = j; rty = i;\n\t\t\t\t}\n\t\t\t\tif (r[i][j] == 'R') {\n\t\t\t\t\trsx = j; rsy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<vector<vvi>> dp(h, vector<vvi>(w, vvi(h, vi(w, -1))));\n\t\tqueue<pair<pii, pii>> q;\n\t\tvector<vector<vvi>> b(h, vector<vvi>(w, vvi(h, vi(w, 0))));\n\t\tq.push(pair<pii, pii>(pii(lsx, lsy), pii(rsx, rsy)));\n\t\tb[lsy][lsx][rsy][rsx] = 1;\n\t\twhile (!q.empty()) {\n\t\t\tauto a = q.front(); q.pop();\n\t\t\tint lx = a.first.first, ly = a.first.second, rx = a.second.first, ry = a.second.second;\n\t\t\tif (lx == ltx&&ly == lty&&rx == rtx&&ry == rty) {\n\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\tgoto a;\n\t\t\t}\n\n\t\t\tREP(i, 4) {\n\t\t\t\tint lnx = lx + dx[i * 2], lny = ly + dy[i * 2], rnx = rx + dx[(i + 2 * (i % 2 == 0)) * 2 % 8], rny = ry + dy[(i + 2 * (i % 2 == 0)) * 2 % 8];\n\t\t\t\tif (lnx < 0 || lnx >= w || lny < 0 || lny >= h || l[lny][lnx] == '#') {\n\t\t\t\t\tlny = ly; lnx = lx;\n\t\t\t\t}\n\t\t\t\tif (rnx < 0 || rnx >= w || rny < 0 || rny >= h || r[rny][rnx] == '#') {\n\t\t\t\t\trny = ry; rnx = rx;\n\t\t\t\t}\n\t\t\t\tif ((lnx!=lx||lny!=ly||rnx!=rx||rny!=ry)&& b[lny][lnx][rny][rnx]!=1) {\n\t\t\t\t\n\t\t\t\t\tq.push(pair<pii, pii>(pii(lnx, lny), pii(rnx, rny)));\n\t\t\t\t\tb[lny][lnx][rny][rnx] = 1;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << \"No\" << endl;\n\n\ta:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\n\nstruct Edge{int to,from,cost;};\n\n//#define debug cout\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define SS stringstream\n#define X second\n#define Y first\n//#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,-1,1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,-1,1,0};\n\nint used[50][50][50][50],w,h;\nstring l[50],r[50];\n\nbool inside(int y,int x){\n\treturn 0<=x&&x<w&&0<=y&&y<h;\n}\n\nint main() {\n\tIL{\n\t\tcin>>w>>h;\n\t\tif(w==0&&h==0)break;\n////debug<<w<<\" \"<<h<<endl;\n\t\trep(i,h){\n\t\t\tcin>>l[i]>>r[i];\n\t\t}\n\t\tqueue<vint> que;\n\t\tvint start(4);\n\t\tvint goal(4);\n\t\trep(i,h)rep(j,w){\n\t\t\tif(l[i][j]=='L'){\n\t\t\t\tstart[0]=i;\n\t\t\t\tstart[1]=j;\n\t\t\t}\n\t\t\tif(r[i][j]=='R'){\n\t\t\t\tstart[2]=i;\n\t\t\t\tstart[3]=j;\n\t\t\t}\n\t\t\tif(l[i][j]=='%'){\n\t\t\t\tgoal[0]=i;\n\t\t\t\tgoal[1]=j;\n\t\t\t}\n\t\t\tif(r[i][j]=='%'){\n\t\t\t\tgoal[2]=i;\n\t\t\t\tgoal[3]=j;\n\t\t\t}\n\t\t}\n\t\tque.push(start);\n\t\tmemset(used,0,sizeof(used));\n\t\tused[start[0]][start[1]][start[2]][start[3]]=1;\n\t\twhile(!que.empty()){\n\t\t\tvint now=que.front();\n//debug<<now[0]<<\" \"<<now[1]<<\" \"<<now[2]<<\" \"<<now[3]<<endl;\n\t\t\tque.pop();\n\t\t\trep(i,4){\n\t\t\t\tvint next;\n\t\t\t\tnext.PB(now[0]+dy[i]);\n\t\t\t\tif(next[0]<0||w<=next[0]||l[next[0]][now[1]]=='#')next[0]=now[0];\n\t\t\t\tnext.PB(now[1]+dx[i]);\n\t\t\t\tif(next[1]<0||h<=next[1]||l[now[0]][next[1]]=='#')next[1]=now[1];\n\t\t\t\tnext.PB(now[2]+dy[i]);\n\t\t\t\tif(next[2]<0||w<=next[2]||r[next[2]][now[3]]=='#')next[2]=now[2];\n\t\t\t\tnext.PB(now[3]-dx[i]);\n\t\t\t\tif(next[3]<0||h<=next[3]||r[now[2]][next[3]]=='#')next[3]=now[3];\n\t\t\t\tif(used[next[0]][next[1]][next[2]][next[3]]==1)continue;\n\t\t\t\tused[next[0]][next[1]][next[2]][next[3]]=1;\n\t\t\t\tif(goal==next){\n\t\t\t\t\tcout<<\"Yes\"<<endl;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tif(l[next[0]][next[1]]=='%')continue;\n\t\t\t\tif(r[next[2]][next[3]]=='%')continue;\n\t\t\t\tque.push(next);\n\t\t\t}\n\t\t}\n\t\tcout<<\"No\"<<endl;\n\t\tend:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_W 10\n#define MAX_H 10\n//深さ優先探索で行けるんじゃないか？\n\nbool C[52][52][52][52];\nint di[4] = {0, -1, 0, 1};\nint dj[4] = {1, 0, -1, 0};\nvector<vector<bool> > Room_L(MAX_H + 2, vector<bool> (MAX_W + 2, false));\nvector<vector<bool> > Room_R(MAX_H + 2, vector<bool> (MAX_W + 2, false));\nint si_L, si_R, sj_L, sj_R, gi_L, gi_R, gj_L, gj_R;  //スタートとゴールの座標\n\n\nint main(){\n\n    \n    //cout << \"ok\" << endl;\n    while(1){\n        \n        //入力\n        //cout << \"ol\" << endl;\n        int W, H; cin >> W >> H;\n        if(W == 0) break;\n        \n        for(int i = 0; i <= H + 1; i++){\n            for(int j = 0; j <= W + 1; j++){\n                Room_L[i][j] = Room_R[i][j] = false;\n            }\n        }\n\n        memset(C, 0, sizeof(C));\n\n        for(int i = 1; i <= H; i++){\n            //L\n            for(int j = 1; j <= W; j++){\n                char input; cin >> input;\n                if(input == '#') continue;\n                else{\n                    Room_L[i][j] = true;\n\n                    if(input == '%'){\n                        gi_L = i;\n                        gj_L = j;\n                    }\n\n                    if(input == 'L'){\n                        si_L = i;\n                        sj_L = j;\n                    }\n                }\n            }\n\n            //R\n            for(int j = 1; j <= W; j++){\n                char input; cin >> input;\n                if(input == '#') continue;\n                else{\n                    Room_R[i][j] = true;\n\n                    if(input == '%'){\n                        gi_R = i;\n                        gj_R = j;\n                    }\n\n                    if(input == 'R'){\n                        si_R = i;\n                        sj_R = j;\n                    }\n                }\n            }\n        }\n\n        //幅優先をする\n        //set<pair<pair<int, int>, pair<int, int> > > s;\n        \n        queue<pair<pair<int, int>, pair<int, int> > > wait;                      //左の座標　右の座標\n        wait.push({ {si_L, sj_L}, {si_R, sj_R} });\n        //s.insert({ {si_L, sj_L}, {si_R, sj_R} });\n        C[si_L][sj_L][si_R][sj_R] = true;\n        \n        bool can = false;\n\n        while(!wait.empty()){    //キュー画空になるまで\n\n\n            //キューの先頭要素を取り出す\n            int nowi_L = wait.front().first.first;\n            int nowj_L = wait.front().first.second;\n            int nowi_R = wait.front().second.first;\n            int nowj_R = wait.front().second.second;\n            //cout << nowi_L << \" \" << nowj_L << \"  \" << nowi_R << \" \" << nowj_R << endl;\n            wait.pop();\n\n            //四方向を探索\n            for(int k = 0; k < 4; k++){\n                int nexti_L = nowi_L + di[k];\n                int nextj_L = nowj_L + dj[k];\n                int nexti_R = nowi_R + di[k];\n                int nextj_R = nowj_R - dj[k];\n                //cout << \" \" << nexti_L << \" \" << nextj_L << \"  \" << nexti_R << \" \" << nextj_R << endl;\n\n\n                bool L = Room_L[nexti_L][nextj_L];\n                bool R = Room_R[nexti_R][nextj_R];\n                //cout << \" \" << L << \" \" << R << endl;\n                \n\n                //その方向に進めるなら\n                if(nexti_L == gi_L && nextj_L == gj_L && nexti_R == gi_R && nextj_R == gj_R){\n                    can = true;\n                    break;\n                }else if((nexti_L == gi_L && nextj_L == gj_L) || (nexti_R == gi_R && nextj_R == gj_R)){\n                    continue;\n                }else if(R && L && !C[nexti_L][nextj_L][nexti_R][nextj_R]){\n                    wait.push({{nexti_L, nextj_L}, {nexti_R, nextj_R}});\n                    C[nexti_L][nextj_L][nexti_R][nextj_R] = true;\n                }else if(R && !L && !C[nowi_L][nowj_L][nexti_R][nextj_R]){\n                    wait.push({{nowi_L, nowj_L}, {nexti_R, nextj_R}});\n                    C[nowi_L][nowj_L][nexti_R][nextj_R] = true;\n                }else if(!R && L && !C[nexti_L][nextj_L][nowi_R][nowj_R]){\n                    wait.push({{nexti_L, nextj_L}, {nowi_R, nowj_R}});\n                    C[nexti_L][nextj_L][nowi_R][nowj_R] = true;\n                }\n            }\n        }\n\n        if(can) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    \n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint W,H;\nchar fie[2][55][55];\n\nbool used[50][50][50][50];\nint dx[2][4]={\n  {0,1,0,-1},\n  {0,-1,0,1}\n};\nint dy[]={1,0,-1,0};\n\nvoid move(int &x,int &y,int id,int rl){\n  int nx = x + dx[rl][id];\n  int ny = y + dy[id];\n  if( nx < 0 || ny < 0 || nx >= W || ny >= H ) return;\n  if( fie[rl][nx][ny] == '#' ) return;\n  x = nx; y = ny;\n}\n\n\nstruct state{\n  int lx,ly,rx,ry;\n};\n\nbool solve(int lx,int ly,int rx,int ry){\n  queue<state> q;\n  q.push( (state){lx,ly,rx,ry} );\n  used[lx][ly][rx][ry] = true;\n  while( !q.empty() ){\n    state p = q.front(); q.pop();\n    lx = p.lx; ly = p.ly; rx = p.rx; ry = p.ry;\n    if( fie[0][lx][ly] == '%' && fie[1][rx][ry] == '%' ) return true;\n    if( fie[0][lx][ly] == '%' || fie[1][rx][ry] == '%' ) continue;\n    for(int i=0;i<4;i++){\n      int nlx = lx, nly = ly, nrx = rx, nry = ry;\n      move(nlx,nly,i,0);\n      move(nrx,nry,i,1);\n      if( used[nlx][nly][nrx][nry] ) continue;\n      q.push( (state){nlx,nly,nrx,nry} );\n      used[nlx][nly][nrx][nry] = true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  while( cin >> W >> H && (W||H) ){\n    int lx,ly,rx,ry;\n    memset(used,0,sizeof(used));\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tcin >> fie[0][j][i];\n\tif( fie[0][j][i] == 'L' || fie[0][j][i] == 'R' ){\n\t  lx=j; ly=i;\n\t}\n      }\n      for(int j=0;j<W;j++){\n\tcin >> fie[1][j][i];\n\tif( fie[1][j][i] == 'L' || fie[1][j][i] == 'R' ){\n\t  rx=j; ry=i;\n\t}\n      }\n    }\n    if( solve(lx,ly,rx,ry) ) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// テ・ツ淞コテヲツ慊ャテ」ツδ?」ツδウテ」ツδ療」ツδャテ」ツδシテ」ツδ?\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[2][4] = { {0, 0, 1, -1}, {0, 0, 1, -1} };\nint dy[2][4] = { {1, -1, 0, 0}, {-1, 1, 0, 0} };\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nconst int S = 60;\n// ax, ay, bx, by\nint step[S][S][S][S];\nbool visited[S][S][S][S];\nint W, H;\n\nstruct Elem {\n    int ax, ay, bx, by;\n};\n\npii search_p(vector<string> &vs, char target) {\n    rep(i,0,H) rep(j,0,W) {\n        if(vs[i][j] == target) return make_pair(i, j);\n    }\n}\n\nvoid move_p(vector<string> &vs, int &x, int &y, int dir, int mode) {\n    int nx = x + dx[mode][dir];\n    int ny = y + dy[mode][dir];\n    if(nx < 0 || nx >= H || ny < 0 || ny >= W) return;\n    if(vs[nx][ny] == '#') return;\n    x = nx;\n    y = ny;\n}\n\nsigned main() {\n    while(cin >> W >> H, W || H) {\n        rep(i,0,S) rep(j,0,S) rep(k,0,S) rep(l,0,S) step[i][j][k][l] = INF;\n        memset(visited, false, sizeof(visited));\n\n        vector<string> lboard(H), rboard(W);\n        rep(i,0,H) cin >> lboard[i] >> rboard[i];\n        pii init_a = search_p(lboard, 'L');\n        pii init_b = search_p(rboard, 'R');\n        int a = init_a.first, b = init_a.second;\n        int x = init_b.first, y = init_b.second;\n        step[a][b][x][y] = 0;\n\n        queue<Elem> que;\n        que.push(Elem{a, b, x, y});\n        visited[a][b][x][y] = true;\n        while(!que.empty()) {\n            Elem cur = que.front(); que.pop();\n            rep(k,0,4) {\n                Elem nxt = cur;\n                move_p(lboard, nxt.ax, nxt.ay, k, 0);\n                move_p(rboard, nxt.bx, nxt.by, k, 1);\n                if(visited[nxt.ax][nxt.ay][nxt.bx][nxt.by]) continue;\n                if(step[nxt.ax][nxt.ay][nxt.bx][nxt.by] > step[cur.ax][cur.ay][cur.bx][cur.by] + 1) {\n                    step[nxt.ax][nxt.ay][nxt.bx][nxt.by] = step[cur.ax][cur.ay][cur.bx][cur.by] + 1;\n                    que.push(nxt);\n                }\n            }\n        }\n\n        pii goal_a = search_p(lboard, '%');\n        pii goal_b = search_p(rboard, '%');\n        a = goal_a.first, b = goal_a.second;\n        x = goal_b.first, y = goal_b.second;\n        if(step[a][b][x][y] == INF) cout << \"No\" << endl;\n        else cout << \"Yes\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<cmath>\n#include<utility>\n#include<functional>\n#include<map>\n#include<set>\n#include<cctype>\n\n\n#define FOR(i, a, b) for( int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for( int i=(a);i>=(b);i--)\n#define LFOR(i, a, b) for( long long int i=(a);i<=(b);i++)\n#define LRFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LLINF 1000000000000000000 //9000000000000000000\n#define PI 3.14159265358979\n#define MAXI 7500000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\n\nint dy[4] = { 0,0,1,-1 };\nint dx[4] = { 1,-1,0,0 };\n\n//int dp[50][50][50][50] = {};//ly,lx,ry,rx\n\n\nint main(void) {\n\t\n\twhile (1) {\n\n\t\tstruct Pos{\n\t\tpublic:\n\t\t\tint leftx;\n\t\t\tint lefty;\n\t\t\tint rightx;\n\t\t\tint righty;\n\t\t};\n\n\t\tint w, h;\n\t\tint lx = -1, ly = -1, rx = -1, ry = -1;\n\t\tint lgx = -1, lgy = -1, rgx = -1, rgy = -1;\n\n\t\tvector< vector< vector< vector<int> > > > dp(50, vector< vector< vector<int > > >(50, vector< vector<int> >(50, vector<int>(50, 0))));\n\t\t\n\n\t\tqueue< Pos > que;\n\t\tPos now;\n\n\t\tcin >> w >> h;\n\n\t\tif (w == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tvector<string> left(h), right(h);\n\n\t\tFOR(i, 0, h-1) {\n\t\t\tcin >> left[i] >> right[i];\n\t\t}\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (left[i][j] == 'L') {\n\t\t\t\t\tlx = j;\n\t\t\t\t\tly = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (right[i][j] == 'R') {\n\t\t\t\t\trx = j;\n\t\t\t\t\try = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (left[i][j] == '%') {\n\t\t\t\t\tlgx = j;\n\t\t\t\t\tlgy = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lgx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (right[i][j] == '%') {\n\t\t\t\t\trgx = j;\n\t\t\t\t\trgy = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rgx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdp[ly][lx][ry][rx] = 1;\n\n\t\tnow.lefty = ly;\n\t\tnow.leftx = lx;\n\t\tnow.righty = ry;\n\t\tnow.rightx = rx;\n\t\t\n\t\tque.push(Pos{lx,ly,rx,ry});\n\n\n\t\t/*while (!que.empty()) {\n\t\t\tnow = que.front();\n\t\t\t\n\t\t\tque.pop();\n\t\t\tly = now.lefty;\n\t\t\tlx = now.leftx;\n\t\t\try = now.righty;\n\t\t\trx = now.rightx;\n\t\t\t//cout << ly << \" \" << lx << \" \" << ry << \" \" << rx << endl;\n\n\t\t\tFOR(i, 0, 3) {\n\t\t\t\t\n\t\t\t\tif (ly + dy[i] >= 0 && lx - dx[i] >= 0 && ry + dy[i] <= h - 1 && rx + dx[i] <= w - 1 && ly + dy[i] <= h - 1 && lx - dx[i] <= w - 1 && ry + dy[i] >= 0 && rx + dx[i] >= 0) {\n\t\t\t\t\tif (dp[ly + dy[i]][lx - dx[i]][ry + dy[i]][rx + dx[i]] != 1) {\n\t\t\t\t\t\tif (left[ly + dy[i]][lx - dx[i]] == '#') {\n\t\t\t\t\t\t\tif (right[ry + dy[i]][rx + dx[i]] == '#') {\n\t\t\t\t\t\t\t\t//no\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdp[ly][lx][ry + dy[i]][rx + dx[i]] = 1;\n\t\t\t\t\t\t\t\tnow.lefty = ly;\n\t\t\t\t\t\t\t\tnow.leftx = lx;\n\t\t\t\t\t\t\t\tnow.righty = ry + dy[i];\n\t\t\t\t\t\t\t\tnow.rightx = rx + dx[i];\n\t\t\t\t\t\t\t\tque.push(now);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (right[ry + dy[i]][rx + dx[i]] == '#') {\n\t\t\t\t\t\t\t\tdp[ly + dy[i]][lx - dx[i]][ry][rx] = 1;\n\t\t\t\t\t\t\t\tnow.lefty = ly + dy[i];\n\t\t\t\t\t\t\t\tnow.leftx = lx - dx[i];\n\t\t\t\t\t\t\t\tnow.righty = ry;\n\t\t\t\t\t\t\t\tnow.rightx = rx;\n\t\t\t\t\t\t\t\tque.push(now);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdp[ly + dy[i]][lx - dx[i]][ry + dy[i]][rx + dx[i]] = 1;\n\t\t\t\t\t\t\t\tnow.lefty = ly + dy[i];\n\t\t\t\t\t\t\t\tnow.leftx = lx - dx[i];\n\t\t\t\t\t\t\t\tnow.righty = ry + dy[i];\n\t\t\t\t\t\t\t\tnow.rightx = rx + dx[i];\n\t\t\t\t\t\t\t\tque.push(now);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\n\t\tif (dp[lgy][lgx][rgy][rgx] == 1) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t\t\n\n\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\nusing namespace std;\n\nstruct Pos{int x,y;};\nstruct Pair{Pos LIN,REN;};\nbool same(Pos a,Pos b){return a.x==b.x && a.y==b.y;}\nbool same(Pair a,Pair b){return same(a.LIN,b.LIN) && same(a.REN,b.REN);}\n\nPair start,goal;\n\nint W,H;\nchar RoomL[52][52],RoomR[52][52];\nbool visited[52][52][52][52];\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n\nbool bfs()\n{\n  memset(visited,0,sizeof(visited));\n  queue<Pair>q;\n  q.push(start);\n  Pair now,next;\n  while(!q.empty()){\n    now=q.front();\n    q.pop();\n    if(same(now,goal))return true;\n    if(same(now.LIN,goal.LIN))continue;\n    if(same(now.REN,goal.REN))continue;\n    visited[now.LIN.y][now.LIN.x][now.REN.y][now.REN.x]=true;\n    for(int i=0;i<4;i++){\n      next=now;\n      next.LIN.x+=dx[i];\n      next.LIN.y+=dy[i];\n      next.REN.x+=-dx[i];\n      next.REN.y+=dy[i];\n      if(RoomL[next.LIN.y][next.LIN.x]=='#')next.LIN=now.LIN;\n      if(RoomR[next.REN.y][next.REN.x]=='#')next.REN=now.REN;\n      if(visited[next.LIN.y][next.LIN.x][next.REN.y][next.REN.x])continue;\n      q.push(next);\n    }\n  }\n  return false;\n}\n\n\nint main()\n{\n  string l,r;\n  while(cin>>W>>H,W|H){\n    memset(RoomL,'#',sizeof(RoomL));\n    memset(RoomR,'#',sizeof(RoomR));\n    for(int i=1;i<=H;i++){\n      cin>>l>>r;\n      for(int j=1;j<=W;j++){\n\tRoomL[i][j]=l[j-1];\n\tRoomR[i][j]=r[j-1];\n\tif(RoomL[i][j]=='L'){\n\t  start.LIN.x=j;\n\t  start.LIN.y=i;\n\t}\n\tif(RoomL[i][j]=='%'){\n\t  goal.LIN.x=j;\n\t  goal.LIN.y=i;\n\t}\n\tif(RoomR[i][j]=='R'){\n\t  start.REN.x=j;\n\t  start.REN.y=i;\n\t}\n\tif(RoomR[i][j]=='%'){\n\t  goal.REN.x=j;\n\t  goal.REN.y=i;\n\t}\n      }\n    }\n    puts(bfs()?\"Yes\":\"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <fstream>\n#include <stack>\n#include <cstring>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, k, n) for (int i = (int)(k); i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rREP(i, k, n) for (int i = (int)(n)-1; i >= k; i--)\n\n#define debug(x) cerr << #x << \": \" << x << endl;\n\n#define fi first\n#define se second\n\n#define vi vector<int>\n#define pii pair<int, int>\n#define pb push_back\n#define mp make_pair\n\n#define pcnt __builtin_popcount\n\ntypedef long long ll;\n\nconst int    inf = 100100100;\n\n\nconst int    dx[4] = { 0, 1, 0, -1 };\nconst int    dy[4] = { 1, 0, -1, 0 };\n\nstruct POINT {\n    int lx;\n    int ly;\n    int rx;\n    int ry;\n};\n\nbool u[55][55][55][55] = {};\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n//    ifstream in(\"in.txt\");\n//    cin.rdbuf(in.rdbuf());\n    int  w, h;\n    char ML[55][55], MR[55][55];\n    int slx,sly,srx,sry;\n    while (cin >> w >> h, w) {\n        memset(u,0,sizeof(u));\n        memset(ML,0,sizeof(ML));\n        memset(MR,0,sizeof(MR));\n\n        rep(y, h) {\n            string sml,smr;\n            cin >> sml >> smr;\n            sml.copy(ML[y],sml.size()+1);\n            smr.copy(MR[y],smr.size()+1);\n\n        }\n        rep(y, h) rep(x,w){\n                if(ML[y][x] == 'L') ML[y][x] = '.',slx = x,sly = y;\n                if(MR[y][x] == 'R') ML[y][x] = '.',srx = x,sry = y;\n            }\n        stack<POINT> st;\n        st.push(POINT{slx, sly, srx, sry});\n\n        bool flag = false;\n        while (!st.empty()) {\n            POINT p = st.top();\n            st.pop();\n\n            rep(i, 4) {\n                int nlx = p.lx + dx[i];\n                int nly = p.ly + dy[i];\n                int nrx = p.rx + dx[(i + 2) % 4];\n                int nry = p.ry + dy[i];\n                bool left_do = true;\n                bool right_do = true;\n                if (nlx < 0 || w <= nlx) left_do = false;\n                if (nly < 0 || h <= nly) left_do = false;\n                if (ML[nly][nlx] == '#') left_do = false;\n                if (nrx < 0 || w <= nrx) right_do = false;\n                if (nry < 0 || h <= nry) right_do = false;\n                if (MR[nry][nrx] == '#') right_do = false;\n                if (ML[nly][nlx] == '%' && MR[nry][nrx] == '%') {\n                    flag = true;\n                    while (!st.empty()) st.pop();\n                    break;\n                } else if (ML[nly][nlx] == '%' || MR[nry][nrx] == '%') {\n                    continue;\n                }\n                if (!left_do && !right_do) continue;\n                if (!left_do) nlx = p.lx, nly = p.ly;\n                if (!right_do) nrx = p.rx, nry = p.ry;\n                if(!u[nlx][nly][nrx][nry]) {\n                    u[nlx][nly][nrx][nry] = true;\n                    st.push(POINT{nlx, nly, nrx, nry});\n                }\n            }\n\n        }\n        if (flag)\n            cout << \"Yes\" << endl;\n        else\n            cout << \"No\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconstexpr long long MAX = 5100000;\nconstexpr long long INF = 1LL << 60;\nconstexpr int inf = 1 << 28;\n//constexpr long long mod = 1000000007LL;\n//constexpr long long mod = 998244353LL;\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\n\nbool d[51][51][51][51];\nint dh[4] = { 1,0,-1,0 };\nint dw[4] = { 0,1,0,-1 };\nint main()\n{\n\t/*\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\t*/\n\tint kkt = 89;\n\twhile (kkt) {\n\t\tint W, H; scanf(\"%d %d\", &W, &H);\n\t\tif (W == 0 && H == 0) break;\n\t\tvector<vector<string>> vs(2, vector<string>(H)); for (int i = 0; i < H; i++) cin >> vs[0][i] >> vs[1][i];\n\t\tfor (int i = 0; i < H; i++) reverse(vs[1][i].begin(), vs[1][i].end());\n\t\tfor (int i = 0; i < H; i++) for (int j = 0; j < W; j++) for (int k = 0; k < H; k++) for (int l = 0; l < W; l++) d[i][j][k][l] = false;\n\t\tvector<queue<pair<int, int>>> vq(2);\n\t\tint gh[2], gw[2];\n\t\tfor (int k = 0; k < 2; k++) {\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tif (vs[k][i][j] == 'L' || vs[k][i][j] == 'R') {\n\t\t\t\t\t\tvq[k].emplace(i, j);\n\t\t\t\t\t}\n\t\t\t\t\tif (vs[k][i][j] == '%') gh[k] = i, gw[k] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\td[vq[0].front().first][vq[0].front().second][vq[1].front().first][vq[1].front().second] = true;\n\t\twhile (!vq[0].empty() && !vq[1].empty()) {\n\t\t\tpair<int, int> cur[2] = { vq[0].front(),vq[1].front() };\n\t\t\tvq[0].pop(); vq[1].pop();\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint nh[2] = { cur[0].first, cur[1].first };\n\t\t\t\tint nw[2] = { cur[0].second,cur[1].second };\n\t\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\t\tint th = nh[k], tw = nw[k];\n\t\t\t\t\tif (nh[k] + dh[i] >= 0 && nh[k] + dh[i] < H) th += dh[i];\n\t\t\t\t\tif (nw[k] + dw[i] >= 0 && nw[k] + dw[i] < W) tw += dw[i];\n\t\t\t\t\tif (vs[k][th][tw] == '#') continue;\n\t\t\t\t\tnh[k] = th;\n\t\t\t\t\tnw[k] = tw;\n\t\t\t\t}\n\t\t\t\tif (d[nh[0]][nw[0]][nh[1]][nw[1]]) continue;\n\t\t\t\tif (nh[0] == gh[0] && nw[0] == gw[0]) {\n\t\t\t\t\tif (nh[1] != gh[1] || nw[1] != gw[1]) continue;\n\t\t\t\t}\n\t\t\t\tif (nh[1] == gh[1] && nw[1] == gw[1]) {\n\t\t\t\t\tif (nh[0] != gh[0] || nw[0] != gw[0]) continue;\n\t\t\t\t}\n\t\t\t\td[nh[0]][nw[0]][nh[1]][nw[1]] = true;\n\t\t\t\tvq[0].emplace(nh[0], nw[0]);\n\t\t\t\tvq[1].emplace(nh[1], nw[1]);\n\t\t\t}\n\t\t}\n\t\tif (d[gh[0]][gw[0]][gh[1]][gw[1]]) puts(\"Yes\");\n\t\telse puts(\"No\");\n\t}\n\treturn 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nint W, H;\nstruct pos\n{\n\tint x, y, dis;\n};\nint main() {\n\n\twhile (cin >> W >> H, W | H){\n\t\tvector<string> vsl;\n\t\tvector<string> vsr;\n\t\tREP(i, H){\n\t\t\tstring l;\n\t\t\tstring r;\n\t\t\tcin >> l >> r;\n\t\t\tvsl.push_back(l);\n\t\t\tvsr.push_back(r);\n\t\t}\n\t\tvector<vector<int>> vvil(H);\n\t\tvector<vector<int>> vvir(H);\n\t\tint glx;\n\t\tint gly;\n\t\tint grx;\n\t\tint gry;\n\t\tint lx;\n\t\tint ly;\n\t\tint rx;\n\t\tint ry;\n\t\tREP(i, H){\n\t\t\tREP(j, W){\n\t\t\t\tif (vsl[i][j] == '#')vvil[i].push_back(-1);\n\t\t\t\telse vvil[i].push_back(9999);\n\n\t\t\t\tif (vsr[i][j] == '#')vvir[i].push_back(-1);\n\t\t\t\telse vvir[i].push_back(9999);\n\n\t\t\t\tif (vsl[i][j] == 'L'){\n\t\t\t\t\tlx = j;\n\t\t\t\t\tly = i;\n\t\t\t\t}\n\t\t\t\tif (vsr[i][j] == 'R'){\n\t\t\t\t\trx = j;\n\t\t\t\t\try = i;\n\t\t\t\t}\n\t\t\t\tif (vsl[i][j] == '%'){\n\t\t\t\t\tglx = j;\n\t\t\t\t\tgly = i;\n\t\t\t\t}\n\t\t\t\tif (vsr[i][j] == '%'){\n\t\t\t\t\tgrx = j;\n\t\t\t\t\tgry = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<pos> vp;\n\t\tvp.push_back({ glx, gly, 0 });\n\t\tvvil[gly][glx] = 0;\n\t\twhile (!vp.empty()){\n\t\t\tpos p = vp[0];\n\t\t\tvp.erase(vp.begin());\n\t\t\tREP(i, 4){\n\t\t\t\tif (p.x + dx[i] >= 0 && p.x + dx[i] < W&&p.y + dy[i] >= 0 && p.y + dy[i] < H&& vvil[p.y + dy[i]][p.x + dx[i]] != -1 && vvil[p.y + dy[i]][p.x + dx[i]] == 9999){\n\t\t\t\t\tvp.push_back({ p.x + dx[i], p.y + dy[i], p.dis + 1 });\n\t\t\t\t\tvvil[p.y + dy[i]][p.x + dx[i]] = p.dis + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvp.push_back({ grx, gry, 0 });\n\t\tvvir[gry][grx] = 0;\n\t\twhile (!vp.empty()){\n\t\t\tpos p = vp[0];\n\t\t\tvp.erase(vp.begin());\n\t\t\tREP(i, 4){\n\t\t\t\tif (p.x + dx[i] >= 0 && p.x + dx[i] < W&&p.y + dy[i] >= 0 && p.y + dy[i] < H&& vvir[p.y + dy[i]][p.x + dx[i]] != -1 && vvir[p.y + dy[i]][p.x + dx[i]] == 9999){\n\t\t\t\t\tvp.push_back({ p.x + dx[i], p.y + dy[i], p.dis + 1 });\n\t\t\t\t\tvvir[p.y + dy[i]][p.x + dx[i]] = p.dis + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<int> vi;\n\t\tvi.push_back(lx * 1000000 + ly * 10000 + rx * 100 + ry);\n\t\tint count = 0;\n\t\tint pcount = 1;\n\t\tbool clear = false;\n\t\twhile (1){\n\t\t\t/*if (vi[count] == glx * 1000000 + gly * 10000 + grx * 100 + gry){\n\t\t\t\tclear = true;\n\t\t\t\tbreak;\n\t\t\t\t}*/\n\t\t\tint lx2 = vi[count] / 1000000 % 100;\n\t\t\tint ly2 = vi[count] / 10000 % 100;\n\t\t\tint rx2 = vi[count] / 100 % 100;\n\t\t\tint ry2 = vi[count] % 100;\n\n\t\t\tREP(i, 4){\n\t\t\t\tint lx3 = lx2;\n\t\t\t\tint ly3 = ly2;\n\t\t\t\tint rx3 = rx2;\n\t\t\t\tint ry3 = ry2;\n\t\t\t\tif (dx[i] != 0 && lx3 + dx[i] >= 0 && lx3 + dx[i] < W && vsl[ly3 + dy[i]][lx3 + dx[i]] != '#')lx3 += dx[i];\n\t\t\t\tif (dy[i] != 0 && ly3 + dy[i] >= 0 && ly3 + dy[i] < H && vsl[ly3 + dy[i]][lx3 + dx[i]] != '#')ly3 += dy[i];\n\t\t\t\tif (dx[i] != 0 && rx3 - dx[i] >= 0 && rx3 - dx[i] < W && vsr[ry3 + dy[i]][rx3 - dx[i]] != '#')rx3 -= dx[i];\n\t\t\t\tif (dy[i] != 0 && ry3 + dy[i] >= 0 && ry3 + dy[i] < H && vsr[ry3 + dy[i]][rx3 - dx[i]] != '#')ry3 += dy[i];\n\t\t\t\tif (find(vi.begin(), vi.end(), lx3 * 1000000 + ly3 * 10000 + rx3 * 100 + ry3) == vi.end() && vvil[ly3][lx3] != 0 && vvir[ry3][rx3] != 0)vi.push_back(lx3 * 1000000 + ly3 * 10000 + rx3 * 100 + ry3);\n\t\t\t\tif (lx3 == glx&&ly3 == gly&&rx3 == grx&&ry3 == gry)clear = true;\n\t\t\t}\n\t\t\tif (clear)break;\n\t\t\tif (count + 1 == vi.size())break;\n\t\t\tint min = 10000;\n\t\t\tint i2 = 0;\n\n\t\t\tFOR(i, count + 1, vi.size()){\n\t\t\t\tif (vvil[(vi[i] / 10000 % 100)][(vi[i] / 1000000 % 100)] + vvir[(vi[i] % 100)][(vi[i] / 100 % 100)] < min){\n\t\t\t\t\tmin = vvil[(vi[i] / 10000 % 100)][(vi[i] / 1000000 % 100)] + vvir[(vi[i] % 100)][(vi[i] / 100 % 100)];\n\t\t\t\t\ti2 = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (vvil[ly2][lx2] + vvir[ry2][rx2] < min)break;\n\t\t\tswap(vi[count + 1], vi[i2]);\n\n\t\t\tcount++;\n\t\t}\n\n\t\tif (clear)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define F first\n#define S second\n\ntypedef pair<int,int> pii;\n\nvector<string> va,vb;\nint H,W;\nint dp[55][55][55][55];\nint aay[]={0,1,0,-1};\nint aax[]={1,0,-1,0};\nint bby[]={0,1,0,-1};\nint bbx[]={-1,0,1,0};\nbool check(int a,int b){\n\tif(0<=a&&a<H&&0<=b&&b<W) return true;\n\treturn false;\n}\nint dfs(int a,int b,int c,int d){\n\tif(dp[a][b][c][d]>=0) return dp[a][b][c][d];\n\tint ret=0;\n\t// cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<endl;\n\tdp[a][b][c][d]=0;\n\tif(va[a][b]=='%'&&vb[c][d]=='%'){\n\t\treturn dp[a][b][c][d]=1;\n\t}\n\tif(va[a][b]=='%'||vb[c][d]=='%'){\n\t\treturn dp[a][b][c][d]=0;\n\t}\n\trep(i,4){\n\t\tint aa=a+aay[i];\n\t\tint bb=b+aax[i];\n\t\tint cc=c+bby[i];\n\t\tint dd=d+bbx[i];\n\t\tif(!check(aa,bb)){\n\t\t\taa=a;\n\t\t\tbb=b;\n\t\t}\n\t\tif(!check(cc,dd)){\n\t\t\tcc=c;\n\t\t\tdd=d;\n\t\t}\n\t\tif(va[aa][bb]=='#'){\n\t\t\taa=a;\n\t\t\tbb=b;\n\t\t}\n\t\tif(vb[cc][dd]=='#'){\n\t\t\tcc=c;\n\t\t\tdd=d;\n\t\t}\n\t\tif(dfs(aa,bb,cc,dd)==1) ret=1;\n\t}\n\treturn dp[a][b][c][d]=ret;\n}\nint main(){\n\twhile(cin>>W>>H){\n\t\tif(W==0&&H==0) break;\n\t\tpii L,R;\n\t\tva=vector<string>(H);\n\t\tvb=vector<string>(H);\n\t\trep(i,H) cin>>va[i]>>vb[i];\n\t\trep(i,H){\n\t\t\trep(j,W){\n\t\t\t\tif(va[i][j]=='L'){\n\t\t\t\t\tva[i][j]='.';\n\t\t\t\t\tL=pii(i,j);\n\t\t\t\t}\n\t\t\t\tif(vb[i][j]=='R'){\n\t\t\t\t\tvb[i][j]='.';\n\t\t\t\t\tR=pii(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,55){\n\t\t\trep(j,55){\n\t\t\t\trep(k,55){\n\t\t\t\t\trep(l,55){\n\t\t\t\t\t\tdp[i][j][k][l]=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dfs(L.first,L.second,R.first,R.second)) cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cstdlib>\n#include<set>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\n\n#define REP(i,n) for(int i = 0;i < n;i++)\n#define MK make_pair\n\t\nint dp[51][51][51][51];\nchar mapl[60][60],mapr[60][60];\nint dxl[] = {1,0,-1,0},dyl[] = {0,1,0,-1};\nint dxr[] = {-1,0,1,0},dyr[] = {0,1,0,-1};\n\nstruct s\n{\n\tint lx,ly,rx,ry;\n\ts(int a,int b ,int c,int d):ly(a),lx(b),ry(c),rx(d){};\n};\n\n\nint main()\n{\n\tint w,h;\n\twhile(cin >> w >> h,w|h)\n\t{\n\t\tREP(i,h)\n\t\t{\n\t\t\tscanf(\"%s %s\",mapl[i],mapr[i]);\n\t\t}\n\t\t\n\t\tint ly,lx,ry,rx;\n\t\tREP(i,h)REP(j,w)\n\t\t{\n\t\t\tif(mapl[i][j] == 'L'){ly = i,lx = j; mapl[i][j] = '.';}\n\t\t\tif(mapr[i][j] == 'R'){ry = i,rx = j; mapr[i][j] = '.';}\n\t\t}\n\t\tmemset(dp,0,sizeof(dp));\n\t\t\n\t\tqueue<s> q;\n\t\t\n\t\tq.push(s(ly,lx,ry,rx));\n\t\tdp[ly][lx][ry][rx] = 1;\n\t\t\n\t\twhile(!q.empty())\n\t\t{\n\t\t\ts now = q.front();q.pop();\n\t\t\tREP(i,4)\n\t\t\t{\n\t\t\t\tint cly,clx,cry,crx;\n\t\t\t\tcly = now.ly + dyl[i];\n\t\t\t\tclx = now.lx + dxl[i];\n\t\t\t\tcry = now.ry + dyr[i];\n\t\t\t\tcrx = now.rx + dxr[i];\n\t\t\t\tif(cly < 0 || cly >= h || clx < 0 || clx >= w || mapl[cly][clx] == '#')\n\t\t\t\t{\n\t\t\t\t\tcly = now.ly;clx = now.lx;\n\t\t\t\t}\n\t\t\t\tif(cry < 0 || cry >= h || crx < 0 || crx >= w || mapr[cry][crx] == '#')\n\t\t\t\t{\n\t\t\t\t\tcry = now.ry;crx = now.rx;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(mapl[cly][clx] == '%' && mapr[cry][crx] == '%')\n\t\t\t\t{\n\t\t\t\t\tcout << \"Yes\" << endl; goto NEXT;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(dp[cly][clx][cry][crx] == 1)continue;\n\t\t\t\tif(mapl[cly][clx] == '%' || mapr[cry][crx] == '%')continue;\n\t\t\t\t\n\t\t\t\tq.push(s(cly,clx,cry,crx));\n\t\t\t\tdp[cly][clx][cry][crx] = 1;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tcout << \"No\" << endl;\n\t\t\n\t\tNEXT:;\n\t}\n\t\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx_r[] = {0,1,0,-1};\nstatic const int ty_r[] = {-1,0,1,0};\n\nstatic const int tx_l[] = {0,-1,0,1};\nstatic const int ty_l[] = {-1,0,1,0};\n\nbool visited[50][50][50][50];\nchar stage_Len[50][50];\nchar stage_Rin[50][50];\n\nbool can_reach;\nint W,H;\n\nvoid dfs(int Rin_x,int Rin_y,int Len_x,int Len_y){\n  for(int i=0;i<4;i++){\n    int Rin_dx = Rin_x + tx_r[i];\n    int Rin_dy = Rin_y + ty_r[i];\n\n    int Len_dx = Len_x + tx_l[i];\n    int Len_dy = Len_y + ty_l[i];\n    if(Rin_dx < 0 || Rin_dx >= W || Rin_dy < 0 || Rin_dy >= H){\n\tcontinue;\n    }\n    if(Len_dx < 0 || Len_dx >= W || Len_dy < 0 || Len_dy >= H){\n\tcontinue;\n    }\n    if(stage_Rin[Rin_dy][Rin_dx] == '#'){\n      Rin_dy = Rin_y;\n      Rin_dx = Rin_x;\n    }\n    if(stage_Len[Len_dy][Len_dx] == '#'){\n      Len_dy = Len_y;\n      Len_dx = Len_x;\n    }\n\n    if(visited[Rin_dx][Rin_dy][Len_dx][Len_dy]){\n      continue;\n    }\n\n    if(stage_Len[Len_dy][Len_dx] == '%'\n       && stage_Rin[Rin_dy][Rin_dx] == '%'){\n      can_reach = true;\n      return;\n    }\n\n    if(stage_Len[Len_dy][Len_dx] != '%'\n       && stage_Rin[Rin_dy][Rin_dx] != '%'){\n      visited[Rin_dx][Rin_dy][Len_dx][Len_dy] = true;\n      dfs(Rin_dx,Rin_dy,Len_dx,Len_dy);\n    }\n  }\n}\n\nint main(){\n\n  while(~scanf(\"%d %d\",&W,&H)){\n    if(W==0 && H==0) break;\n\n    for(int y=0;y<H;y++){\n      for(int x=0;x<W;x++){\n\tmemset(visited[x][y],false,sizeof(visited[x][y]));\n      }\n    }\n    can_reach = false;\n    \n    int Rin_start_x = 0;\n    int Rin_start_y = 0;\n    int Len_start_x = 0;\n    int Len_start_y = 0;\n \n    for(int y=0;y<H;y++){\n      string str_Len,str_Rin;\n      cin >> str_Len >> str_Rin;\n      \n      // cout << str_Len << endl;\n      // cout << str_Rin << endl;\n\n      for(int x=0;x<W;x++){\n\tstage_Len[y][x] = str_Len[x];\n\tstage_Rin[y][x] = str_Rin[x];\n\n\tif(str_Len[x] == 'L'){\n\t  Len_start_x = x;\n\t  Len_start_y = y;\n\t}\n\tif(str_Rin[x] == 'R'){\n\t  Rin_start_x = x;\n\t  Rin_start_y = y;\n\t}\n      }\n    }\n\n    dfs(Rin_start_x,Rin_start_y,Len_start_x,Len_start_y);\n    printf(\"%s\\n\",can_reach ? \"Yes\" : \"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint dis[60][60][60][60];\n\ntypedef pair<pair<int, int>, pair<int, int> > status;\n#define LEFT first\n#define RIGHT second\n#define X first\n#define Y second\n\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nint main() {\n  int w, h;\n  while (true) {\n    vector<string> left, right;\n    cin >> w >> h;\n    if (w == 0 && h == 0) break;\n    string block;\n    rep (i, w + 2) block += '#';\n    left.push_back(block);\n    right.push_back(block);\n    rep (i, h) {\n      string str;\n      cin >> str;\n      left.push_back(\"#\" + str + \"#\");\n      cin >> str;\n      right.push_back(\"#\" + str + \"#\");\n    }\n    left.push_back(block);\n    right.push_back(block);\n    memset(dis, -1, sizeof(dis));\n    queue<status> que;\n    int lx, ly, rx, ry;\n    rep (i, left.size()) rep (j, left[0].size()) {\n      if (left[i][j] == 'L') {\n\tlx = j;\n\tly = i;\n      }\n      if (right[i][j] == 'R') {\n\trx = j;\n\try = i;\n      }\n    }\n    status s;\n    s.LEFT.X = lx;\n    s.LEFT.Y = ly;\n    s.RIGHT.X = rx;\n    s.RIGHT.Y = ry;\n    que.push(s);\n    while (!que.empty()) {\n      status now = que.front();\n      que.pop();\n      if (dis[now.LEFT.X][now.LEFT.Y][now.RIGHT.X][now.RIGHT.Y] != -1) {\n\tcontinue;\n      }\n      dis[now.LEFT.X][now.LEFT.Y][now.RIGHT.X][now.RIGHT.Y] = 1;\n      rep (i, 4) {\n\tstatus next = now;\n\tnext.LEFT.X += dx[i];\n\tnext.LEFT.Y += dy[i];\n\tnext.RIGHT.X -= dx[i];\n\tnext.RIGHT.Y += dy[i];\n\tif (left[next.LEFT.Y][next.LEFT.X] == '#') {\n\t  next.LEFT.X -= dx[i];\n\t  next.LEFT.Y -= dy[i];\n\t}\n\tif (right[next.RIGHT.Y][next.RIGHT.X] == '#') {\n\t  next.RIGHT.X += dx[i];\n\t  next.RIGHT.Y -= dy[i];\n\t}\n\tif (left[next.LEFT.Y][next.LEFT.X] == '%' && right[next.RIGHT.Y][next.RIGHT.X] == '%') goto aaa;\n\tque.push(next);\n      }\n    }\n    cout << \"No\" << endl;\n    continue;\n  aaa:;\n    cout << \"Yes\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nint W, H;\nstruct pos\n{\n\tint x, y, dis;\n};\nint main() {\n\n\twhile (cin >> W >> H, W | H){\n\t\tvector<string> vsl;\n\t\tvector<string> vsr;\n\t\tREP(i, H){\n\t\t\tstring l;\n\t\t\tstring r;\n\t\t\tcin >> l >> r;\n\t\t\tvsl.push_back(l);\n\t\t\tvsr.push_back(r);\n\t\t}\n\t\tvector<vector<int>> vvil(H);\n\t\tvector<vector<int>> vvir(H);\n\t\tint glx;\n\t\tint gly;\n\t\tint grx;\n\t\tint gry;\n\t\tint lx;\n\t\tint ly;\n\t\tint rx;\n\t\tint ry;\n\t\tREP(i, H){\n\t\t\tREP(j, W){\n\t\t\t\tif (vsl[i][j] == '#')vvil[i].push_back(-1);\n\t\t\t\telse vvil[i].push_back(9999);\n\n\t\t\t\tif (vsr[i][j] == '#')vvir[i].push_back(-1);\n\t\t\t\telse vvir[i].push_back(9999);\n\n\t\t\t\tif (vsl[i][j] == 'L'){\n\t\t\t\t\tlx = j;\n\t\t\t\t\tly = i;\n\t\t\t\t}\n\t\t\t\tif (vsr[i][j] == 'R'){\n\t\t\t\t\trx = j;\n\t\t\t\t\try = i;\n\t\t\t\t}\n\t\t\t\tif (vsl[i][j] == '%'){\n\t\t\t\t\tglx = j;\n\t\t\t\t\tgly = i;\n\t\t\t\t}\n\t\t\t\tif (vsr[i][j] == '%'){\n\t\t\t\t\tgrx = j;\n\t\t\t\t\tgry = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<pos> vp;\n\t\tvp.push_back({ glx, gly, 0 });\n\t\tvvil[gly][glx] = 0;\n\t\twhile (!vp.empty()){\n\t\t\tpos p = vp[0];\n\t\t\tvp.erase(vp.begin());\n\t\t\tREP(i, 4){\n\t\t\t\tif (p.x + dx[i] >= 0 && p.x + dx[i] < W&&p.y + dy[i] >= 0 && p.y + dy[i] < H&& vvil[p.y + dy[i]][p.x + dx[i]] != -1 && vvil[p.y + dy[i]][p.x + dx[i]] == 9999){\n\t\t\t\t\tvp.push_back({ p.x + dx[i], p.y + dy[i], p.dis + 1 });\n\t\t\t\t\tvvil[p.y + dy[i]][p.x + dx[i]] = p.dis + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvp.push_back({ grx, gry, 0 });\n\t\tvvir[gry][grx] = 0;\n\t\twhile (!vp.empty()){\n\t\t\tpos p = vp[0];\n\t\t\tvp.erase(vp.begin());\n\t\t\tREP(i, 4){\n\t\t\t\tif (p.x + dx[i] >= 0 && p.x + dx[i] < W&&p.y + dy[i] >= 0 && p.y + dy[i] < H&& vvir[p.y + dy[i]][p.x + dx[i]] != -1 && vvir[p.y + dy[i]][p.x + dx[i]] == 9999){\n\t\t\t\t\tvp.push_back({ p.x + dx[i], p.y + dy[i], p.dis + 1 });\n\t\t\t\t\tvvir[p.y + dy[i]][p.x + dx[i]] = p.dis + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<int> vi;\n\t\tvi.push_back(lx * 1000000 + ly * 10000 + rx * 100 + ry);\n\t\tint count = 0;\n\t\tint pcount = 1;\n\t\tbool clear = false;\n\t\twhile (1){\n\t\t\tif (vvil[ly][lx] == 9999 || vvir[ry][rx] == 9999)break;\n\t\t\t/*if (vi[count] == glx * 1000000 + gly * 10000 + grx * 100 + gry){\n\t\t\t\tclear = true;\n\t\t\t\tbreak;\n\t\t\t\t}*/\n\t\t\tint lx2 = vi[count] / 1000000 % 100;\n\t\t\tint ly2 = vi[count] / 10000 % 100;\n\t\t\tint rx2 = vi[count] / 100 % 100;\n\t\t\tint ry2 = vi[count] % 100;\n\n\t\t\tREP(i, 4){\n\t\t\t\tint lx3 = lx2;\n\t\t\t\tint ly3 = ly2;\n\t\t\t\tint rx3 = rx2;\n\t\t\t\tint ry3 = ry2;\n\t\t\t\tif (dx[i] != 0 && lx3 + dx[i] >= 0 && lx3 + dx[i] < W && vsl[ly3 + dy[i]][lx3 + dx[i]] != '#')lx3 += dx[i];\n\t\t\t\tif (dy[i] != 0 && ly3 + dy[i] >= 0 && ly3 + dy[i] < H && vsl[ly3 + dy[i]][lx3 + dx[i]] != '#')ly3 += dy[i];\n\t\t\t\tif (dx[i] != 0 && rx3 - dx[i] >= 0 && rx3 - dx[i] < W && vsr[ry3 + dy[i]][rx3 - dx[i]] != '#')rx3 -= dx[i];\n\t\t\t\tif (dy[i] != 0 && ry3 + dy[i] >= 0 && ry3 + dy[i] < H && vsr[ry3 + dy[i]][rx3 - dx[i]] != '#')ry3 += dy[i];\n\t\t\t\tif (find(vi.begin(), vi.end(), lx3 * 1000000 + ly3 * 10000 + rx3 * 100 + ry3) == vi.end() && vvil[ly3][lx3] != 0 && vvir[ry3][rx3] != 0)vi.push_back(lx3 * 1000000 + ly3 * 10000 + rx3 * 100 + ry3);\n\t\t\t\tif (lx3 == glx&&ly3 == gly&&rx3 == grx&&ry3 == gry)clear = true;\n\t\t\t}\n\t\t\tif (clear)break;\n\t\t\tif (count + 1 == vi.size())break;\n\t\t\tint min = 10000;\n\t\t\tint i2 = 0;\n\n\t\t\tFOR(i, count + 1, vi.size()){\n\t\t\t\tif (vvil[(vi[i] / 10000 % 100)][(vi[i] / 1000000 % 100)] + vvir[(vi[i] % 100)][(vi[i] / 100 % 100)] < min){\n\t\t\t\t\tmin = vvil[(vi[i] / 10000 % 100)][(vi[i] / 1000000 % 100)] + vvir[(vi[i] % 100)][(vi[i] / 100 % 100)];\n\t\t\t\t\ti2 = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (vvil[ly2][lx2] + vvir[ry2][rx2] < min/2)break;\n\t\t\tswap(vi[count + 1], vi[i2]);\n\n\t\t\tcount++;\n\t\t}\n\n\t\tif (clear)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp make_pair\n#define pb push_back\n#define F first\n#define S second\n\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nbool app[50][50][50][50];\nchar lr[53][53],rr[53][53];\nstring ans;\n\nmain(){\n  int w,h;\n  while(cin>>w>>h,w|h){\n    memset(app,0,6250000);\n    rep(i,h)scanf(\" %s %s \",lr[i],rr[i]);\n\n    int rsx,rsy,lsx,lsy;\n    rep(i,h)rep(j,w){\n      if(lr[i][j]=='L')lsx=i,lsy=j;\n      if(rr[i][j]=='R')rsx=i,rsy=j;\n    }\n    ans=\"No\";\n    queue<pair<PI,PI> > Q;\n    Q.push(mp(mp(lsx,lsy),mp(rsx,rsy)));\n\n    while(!Q.empty()){\n      PI tp=Q.front().F;\n      int clx,cly,crx,cry;\n      clx=tp.F,cly=tp.S;\n      tp=Q.front().S;Q.pop();\n      crx=tp.F,cry=tp.S;\n      if(lr[clx][cly]=='%' && rr[crx][cry]=='%'){\n        ans=\"Yes\";\n        break;\n      }\n      if(lr[clx][cly]=='%' || rr[crx][cry]=='%')continue;\n      app[clx][cly][crx][cry]=true;\n\n      rep(i,4){\n        int nrx=crx+dx[i],nlx=clx+dx[i],nry=cry+dy[i],nly=cly-dy[i];\n        if(nrx<0 || nry<0 || nrx>=h || nry>=w || rr[nrx][nry]=='#')nrx=crx,nry=cry;\n        if(nlx<0 || nly<0 || nlx>=h || nly>=w || lr[nlx][nly]=='#')nlx=clx,nly=cly;\n        if(app[nlx][nly][nrx][nry])continue;\n        app[nlx][nly][nrx][nry]=true;\n        Q.push(mp(mp(nlx,nly),mp(nrx,nry)));\n      }\n/*      \n      rep(i,h){\n        rep(j,w){\n          if(clx==i && cly==j)cout<<'L';\n          else if(lr[i][j]=='L')cout<<'.';\n          else cout<<lr[i][j];\n        }\n        cout<<\" \";\n        rep(j,w){\n          if(crx==i && cry==j)cout<<'R';\n          else if(rr[i][j]=='R')cout<<'.';\n          else cout<<rr[i][j];\n        }\n        cout<<endl;\n      }\n      cout<<endl;\n*/\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\nusing namespace std;\n\nstruct Pos{int x,y;};\nstruct Pair{Pos LIN,REN;};\nbool same(Pos a,Pos b){return a.x==b.x && a.y==b.y;}\nbool same(Pair a,Pair b){return same(a.LIN,b.LIN) && same(a.REN,b.REN);}\n\nPair start,goal;\n\nint W,H;\nchar RoomL[52][52],RoomR[52][52];\nchar visited[52][52][52][52];\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n\nbool bfs()\n{\n  memset(visited,0,sizeof(visited));\n  queue<Pair>q;\n  q.push(start);\n  Pair now,next;\n  while(!q.empty()){\n    now=q.front();\n    q.pop();\n    if(same(now,goal))return true;\n    if(same(now.LIN,goal.LIN))continue;\n    if(same(now.REN,goal.REN))continue;\n    visited[now.LIN.y][now.LIN.x][now.REN.y][now.REN.x]=true;\n    for(int i=0;i<4;i++){\n      next=now;\n      next.LIN.x+=dx[i];\n      next.LIN.y+=dy[i];\n      next.REN.x+=-dx[i];\n      next.REN.y+=dy[i];\n      if(RoomL[next.LIN.y][next.LIN.x]=='#')next.LIN=now.LIN;\n      if(RoomR[next.REN.y][next.REN.x]=='#')next.REN=now.REN;\n      if(visited[next.LIN.y][next.LIN.x][next.REN.y][next.REN.x])continue;\n      q.push(next);\n    }\n  }\n  return false;\n}\n\n\nint main()\n{\n  string l,r;\n  while(cin>>W>>H,W|H){\n    memset(RoomL,'#',sizeof(RoomL));\n    memset(RoomR,'#',sizeof(RoomR));\n    for(int i=1;i<=H;i++){\n      cin>>l>>r;\n      for(int j=1;j<=W;j++){\n\tRoomL[i][j]=l[j-1];\n\tRoomR[i][j]=r[j-1];\n\tif(RoomL[i][j]=='L'){\n\t  start.LIN.x=j;\n\t  start.LIN.y=i;\n\t}\n\tif(RoomL[i][j]=='%'){\n\t  goal.LIN.x=j;\n\t  goal.LIN.y=i;\n\t}\n\tif(RoomR[i][j]=='R'){\n\t  start.REN.x=j;\n\t  start.REN.y=i;\n\t}\n\tif(RoomR[i][j]=='%'){\n\t  goal.REN.x=j;\n\t  goal.REN.y=i;\n\t}\n      }\n    }\n    puts(bfs()?\"Yes\":\"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define ck(a,b) (0<=(a)&&(a)<b)\nusing namespace std;\nint dx[]={-1,1,0,0},dy[]={0,0,-1,1};\nstruct S{\n\tint lx,ly,rx,ry;\n\tS(int a,int b,int c,int d):lx(a),ly(b),rx(c),ry(d){}\n};\nbool operator<(const S &a,const S &b){\n\tif(a.lx!=b.lx)return a.lx<b.lx;\n\tif(a.ly!=b.ly)return a.ly<b.ly;\n\treturn a.rx!=b.rx?a.rx<b.rx:a.ry<b.ry;\n}\nbool V[50][50][50][50];\nint main(){\n\tint w,h;\n\twhile(cin>>w>>h,w){\n\t\tint lx,ly,rx,ry;\n\t\tstring cavel[h],caver[h];\n\t\trep(i,h)cin>>cavel[i]>>caver[i];\n\t\trep(i,h)rep(j,w){\n\t\t\tif(cavel[i][j]=='L')ly=i,lx=j,cavel[i][j]='.';\n\t\t\tif(caver[i][j]=='R')ry=i,rx=j,caver[i][j]='.';\n\t\t}\n\t\tvector<S> F; rep(i,h)rep(j,w)rep(k,h)rep(l,w)V[i][j][k][l]=0;\n\t\tF.push_back(S(lx,ly,rx,ry)); V[ly][lx][ry][rx]=1;\n\t\tint goal=0;\n\t\twhile(!F.empty()&&!goal){\n\t\t\tvector<S> nF;\n\t\t\trep(i,F.size())rep(d,4){\n\t\t\t\tint clx=F[i].lx,cly=F[i].ly,crx=F[i].rx,cry=F[i].ry;\n\t\t\t\tint nlx=clx+dx[d],nly=cly+dy[d],nrx=crx-dx[d],nry=cry+dy[d];\n\t\t\t\tif(!ck(nlx,w)||!ck(nly,h)||cavel[nly][nlx]=='#')nlx=clx,nly=cly;\n\t\t\t\tif(!ck(nrx,w)||!ck(nry,h)||caver[nry][nrx]=='#')nrx=crx,nry=cry;\n\t\t\t\tif(nlx==clx&&nly==cly&&nrx==crx&&nry==cry)continue;\n\t\t\t\tif(cavel[nly][nlx]=='%'^caver[nry][nrx]=='%')continue;\n\t\t\t\tif(cavel[nly][nlx]=='%'&&caver[nry][nrx]=='%'){\n\t\t\t\t\tgoal=1; goto END;\n\t\t\t\t}\n\t\t\t\tif(!V[nly][nlx][nry][nrx]){\n\t\t\t\t\tnF.push_back(S(nlx,nly,nrx,nry));\n\t\t\t\t\tV[nly][nlx][nry][nrx]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tF=nF;\n\t\t}\n\t\tEND:cout<<(goal?\"Yes\":\"No\")<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2153&lang=jp\ntypedef long long ll;\ntypedef vector<vector<char>> vvc;\ntypedef vector<char> vc;\ntypedef vector<vector<int>> vvi;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nint dlx[4] = {1, 0, -1, 0};\nint dly[4] = { 0,1,0,-1 };\nint drx[4] = { 1,0,-1,0 };\nint dry[4] = { 0,-1,0,1 };\n\nint W, H;\nbool dfs(pii l,pii r,vvi Lf,vvi Rf,vvc& L,vvc& R){\n\tLf[l.first][l.second] = 1;\n\tRf[r.first][r.second] = 1;\n\tfor (int i = 0; i < 4;i++) {\n\t\tint lx = l.first + dlx[i], ly = l.second + dly[i];\n\t\tint rx = r.first + drx[i], ry = r.second + dry[i];\n\t\tif (Lf[lx][ly] == 1 && Rf[rx][ry] == 1) continue;\n\t\tif (L[lx][ly] == '%' && R[rx][ry] == '%') return true;\n\t\tif (L[lx][ly] == '#' && R[rx][ry] == '#')continue;\n\t\tif (L[lx][ly] == '.' && R[rx][ry] == '.') {\n\t\t\tif (dfs({ lx,ly }, { rx,ry }, Lf, Rf, L, R)) return true;\n\t\t}\n\t\telse if(L[lx][ly] == '.' && R[rx][ry] == '#'){\n\t\t\tif (dfs({ lx,ly }, { r.first,r.second }, Lf, Rf, L, R))return true;\n\t\t}\n\t\telse if (L[lx][ly] == '#' && R[rx][ry] == '.') {\n\t\t\tif (dfs({ l.first,l.second }, { rx,ry }, Lf, Rf, L, R))return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\twhile (cin >> W >> H) {\n\t\tif ((W | H) == 0)break;\n\t\tvvc L(H + 2, vc(W + 2, '#'));\n\t\tvvc R(H + 2, vc(W + 2, '#'));\n\t\tvvi Lf(H + 2, vi(W + 2, 0));\n\t\tvvi Rf(H + 2, vi(W + 2, 0));\n\t\tpii ls, rs;\n\t\tfor (int i = 1; i <= H;i++) {\n\t\t\tfor (int j = 1;j <= W;j++) {\n\t\t\t\tcin >> L[i][j];\n\t\t\t\tif (L[i][j] == 'L') ls = { i,j };\n\t\t\t}\n\t\t\tfor (int j = 1;j <= W;j++) {\n\t\t\t\tcin >> R[i][j];\n\t\t\t\tif (R[i][j] == 'R') rs = { i,j };\n\t\t\t}\n\t\t}\n\n\t\tif (dfs(ls, rs, Lf, Rf, L, R)) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t\telse cout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n\nbool b[103][52][103][52] = {};\n\n\nint main() {\n\n  while( true ) {\n\n    long long int w, h;\n    cin >> w >> h;\n\n    if ( w == 0 ) break;\n\n    vector< string > map;\n\n    map.push_back( \"##############################################################################################################\" );\n\n    long long int rx, ry, lx, ly;\n\n    for ( long long int y = 1; y <= h; y++ ) {\n\n      string in_L, in_R;\n      cin >> in_L >> in_R;\n\n      string in = \"#\" + in_L + \"#\" + in_R + \"#\";\n      map.push_back( in );\n\n      for ( long long int x = 0; x < in.size(); x++ ) {\n\n\tif ( map[y][x] == 'R' ) {\n\t  rx = x;\n\t  ry = y;\n\t}\n\tif ( map[y][x] == 'L' ) {\n\t  lx = x;\n\t  ly = y;\n\t}\n\n      }\n\n    }\n\n    map.push_back( \"##############################################################################################################\" );\n\n\n    for ( long long int y = 0; y < map.size(); y++ ) {\n      for ( long long int x = 0; x < map[1].size(); x++ ) {\n\tfor ( long long int y2 = 0; y2 < map.size(); y2++ ) {\n\t  for ( long long int x2 = 0; x2 < map[1].size(); x2++ ) {\n\t    b[x][y][x2][y2] = false;\n\t  }\n\t}\n      }\n    }\n\n\n    queue< vector< long long int > > q;\n    vector< long long int > v;\n    v.push_back( rx );\n    v.push_back( ry );\n    v.push_back( lx );\n    v.push_back( ly );\n    q.push( v );\n\n    bool ans = false;\n\n    while( q.size() > 0 ) {\n\n      rx = q.front()[0];\n      ry = q.front()[1];\n      lx = q.front()[2];\n      ly = q.front()[3];\n      q.pop();\n\n      //      cout << rx << \" \" << ry << \" \" << lx << \" \" << ly << endl;\n\n      if ( b[ rx ][ ry ][ lx ][ ly ] == true ) continue;\n\n      b[ rx ][ ry ][ lx ][ ly ] = true;\n\n\n      if ( map[ry][rx] == '%' && map[ly][lx] == '%' ) {\n\tcout << \"Yes\" << endl;\n\tans = true;\n\tbreak;\n      }else if ( map[ry][rx] == '%' ) {\n\tcontinue;\n      }else if ( map[ly][lx] == '%' ) {\n\tcontinue;\n      }\n\n\n\n      v.clear();\n      if ( map[ ry ][ rx + 1 ] == '#' ) {\n\tv.push_back( rx );\n      }else {\n\tv.push_back( rx + 1 );\n      }\n      v.push_back( ry );\n      if ( map[ ly ][ lx - 1 ] == '#' ) {\n\tv.push_back( lx );\n      }else {\n\tv.push_back( lx - 1 );\n      }\n      v.push_back( ly );\n      q.push( v );\n\n      v.clear();\n      v.push_back( rx );\n      if ( map[ ry - 1 ][ rx ] == '#' ) {\n\tv.push_back( ry );\n      }else {\n\tv.push_back( ry - 1 );\n      }\n      v.push_back( lx );\n      if ( map[ ly - 1 ][ lx ] == '#' ) {\n\tv.push_back( ly );\n      }else {\n\tv.push_back( ly - 1 );\n      }\n      q.push( v );\n\n      v.clear();\n      if ( map[ ry ][ rx - 1 ] == '#' ) {\n\tv.push_back( rx );\n      }else {\n\tv.push_back( rx - 1 );\n      }\n      v.push_back( ry );\n      if ( map[ ly ][ lx + 1 ] == '#' ) {\n\tv.push_back( lx );\n      }else {\n\tv.push_back( lx + 1 );\n      }\n      v.push_back( ly );\n      q.push( v );\n\n      v.clear();\n      v.push_back( rx );\n      if ( map[ ry + 1 ][ rx ] == '#' ) {\n\tv.push_back( ry );\n      }else {\n\tv.push_back( ry + 1 );\n      }\n      v.push_back( lx );\n      if ( map[ ly + 1 ][ lx ] == '#' ) {\n\tv.push_back( ly );\n      }else {\n\tv.push_back( ly + 1 );\n      }\n      q.push( v );\n\n    }\n\n    if ( ans == false ) {\n      cout << \"No\" << endl;\n    }\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <queue>\nusing namespace std;\nconst int INF = 10000000;\nint d[50][50][50][50];\nstring f[2][50];\n\nint dx[2][4] = {\n\t{ 1, 0, -1, 0 },\n\t{ -1, 0, 1, 0 }\n};\n\nint dy[2][4] = {\n\t{ 0, 1, 0, -1 },\n\t{ 0, 1, 0, -1 }\n};\n\nint sx[2], sy[2], gx[2], gy[2];\n\n\nstruct State {\n\tint x1, y1, x2, y2;\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint H, W;\n\twhile(cin >> W >> H, H) {\n\t\tfor(int y = 0; y < H; y++) {\n\t\t\tcin >> f[0][y] >> f[1][y];\n\t\t\tfor(int x = 0; x < W; x++) {\n\t\t\t\tif(f[0][y][x] == 'L') sx[0] = x, sy[0] = y;\n\t\t\t\tif(f[1][y][x] == 'R') sx[1] = x, sy[1] = y;\n\t\t\t\tif(f[0][y][x] == '%') gx[0] = x, gy[0] = y;\n\t\t\t\tif(f[1][y][x] == '%') gx[1] = x, gy[1] = y;\n\t\t\t}\n\t\t}\n\n\t\tfill((int*)begin(d), (int*)end(d), INF);\n\n\t\tqueue<State> q;\n\t\tq.push(State{ sx[0], sy[0], sx[1], sy[1] });\n\t\td[sx[0]][sy[0]][sx[1]][sy[1]] = 0;\n\t\twhile(!q.empty()) {\n\t\t\tState s = q.front();\n\t\t\tq.pop();\n\t\t\tfor(int k = 0; k < 4; k++) {\n\t\t\t\tint nx1 = s.x1 + dx[0][k], ny1 = s.y1 + dy[0][k];\n\t\t\t\tif(nx1 < 0 || W <= nx1 || ny1 < 0 || H <= ny1 || f[0][ny1][nx1] == '#') {\n\t\t\t\t\tnx1 = s.x1, ny1 = s.y1;\n\t\t\t\t}\n\t\t\t\tint nx2 = s.x2 + dx[1][k], ny2 = s.y2 + dy[1][k];\n\t\t\t\tif(nx2 < 0 || W <= nx2 || ny2 < 0 || H <= ny2 || f[1][ny2][nx2] == '#') {\n\t\t\t\t\tnx2 = s.x2, ny2 = s.y2;\n\t\t\t\t}\n\t\t\t\tif(d[s.x1][s.y1][s.x2][s.y2] + 1 < d[nx1][ny1][nx2][ny2]) {\n\t\t\t\t\td[nx1][ny1][nx2][ny2] = d[s.x1][s.y1][s.x2][s.y2] + 1;\n\t\t\t\t\tq.push(State{ nx1, ny1, nx2, ny2 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(d[gx[0]][gy[0]][gx[1]][gy[1]] == INF) {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint dy[] = {1, -1, 0, 0};\nint dx[] = {0, 0, 1, -1};\n\nint toHash(int y1, int x1, int y2, int x2)\n{\n    return y1 * 1000000 + x1 * 10000 + y2 * 100 + x2;\n}\n\nvoid fromHash(int hash, int& y1, int& x1, int& y2, int& x2)\n{\n    y1 = hash / 1000000 % 100;\n    x1 = hash / 10000   % 100;\n    y2 = hash / 100     % 100;\n    x2 = hash / 1       % 100;\n}\n\nint main()\n{\n    for(;;){\n        int h, w;\n        cin >> w >> h;\n        if(h == 0)\n            return 0;\n\n        int sy1, sx1, sy2, sx2;\n        vector<string> grid1(h+2, string(w+2, '#'));\n        vector<string> grid2(h+2, string(w+2, '#'));\n        for(int i=1; i<=h; ++i){\n            for(int j=1; j<=w; ++j){\n                cin >> grid1[i][j];\n                if(grid1[i][j] == 'L'){\n                    sy1 = i;\n                    sx1 = j;\n                }\n            }\n            for(int j=1; j<=w; ++j){\n                cin >>grid2[i][j];\n                if(grid2[i][j] == 'R'){\n                    sy2 = i;\n                    sx2 = j;\n                }\n            }\n        }\n\n        queue<int> q;\n        set<int> history;\n        q.push(toHash(sy1, sx1, sy2, sx2));\n        history.insert(toHash(sy1, sx1, sy2, sx2));\n\n        bool ret = false;\n        while(!q.empty()){\n            int y1, x1, y2, x2;\n            fromHash(q.front(), y1, x1, y2, x2);\n            q.pop();\n            if(grid1[y1][x1] == '%' && grid2[y2][x2] == '%'){\n                ret = true;\n                break;\n            }\n            if(grid1[y1][x1] == '%' || grid2[y2][x2] == '%')\n                continue;\n\n            for(int i=0; i<4; ++i){\n                int y3 = y1 + dy[i];\n                int x3 = x1 + dx[i];\n                int y4 = y2 + dy[i];\n                int x4 = x2 + dx[i^1];\n\n                if(grid1[y3][x3] == '#'){\n                    y3 -= dy[i];\n                    x3 -= dx[i];\n                }\n                if(grid2[y4][x4] == '#'){\n                    y4 -= dy[i];\n                    x4 -= dx[i^1];\n                }\n\n                int hash = toHash(y3, x3, y4, x4);\n                if(history.find(hash) == history.end()){\n                    q.push(hash);\n                    history.insert(hash);\n                }\n            }\n        }\n\n        if(ret)\n            cout << \"Yes\" << endl;\n        else\n            cout << \"No\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<int, int> Point;\n\nconst int N = 55;\n\nint w, h;\nchar room[2][N][N];\nbool vis[N][N][N][N];\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = {0, 1, 0, -1};\n\nvoid check(int& y, int& x){\n  if(y < 0) y = 0;\n  if(y >= h) y = h-1;\n  if(x < 0) x = 0;\n  if(x >= w) x = w-1;\n}\n\nbool dfs(Point l, Point r){\n  vis[l.first][l.second][r.first][r.second] = true;\n  if(room[0][l.first][l.second] == '%' && room[1][r.first][r.second] == '%'){\n    return true;\n  }else if(room[0][l.first][l.second] == '%' || room[1][r.first][r.second] == '%'){\n    return false;\n  }else{\n    for(int i=0;i<4;i++){\n      Point nl = Point(l.first + dy[i], l.second + dx[i]);\n      Point nr = Point(r.first + dy[i], r.second - dx[i]);\n      check(nl.first, nl.second);\n      check(nr.first, nr.second);\n      if(room[0][nl.first][nl.second] == '#') nl = l;\n      if(room[1][nr.first][nr.second] == '#') nr = r;\n      if(vis[nl.first][nl.second][nr.first][nr.second]) continue;\n      if(dfs(nl, nr)) return true;\n    }\n  }\n  return false;\n}\n\nmain(){\n  Point l, r;\n  while(cin >> w >> h && (w|h)){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> room[0][i][j];\n        if(room[0][i][j] == 'L'){\n          l = Point(i, j);\n          room[0][i][j] = '.';\n        }\n      }\n      for(int j=0;j<w;j++){\n        cin >> room[1][i][j];\n        if(room[1][i][j] == 'R'){\n          r = Point(i, j);\n          room[1][i][j] = '.';\n        }\n      }      \n    }\n    fill(vis[0][0][0], vis[N][0][0], false);\n    cout << (dfs(l, r) ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nint W, H;\nchar RoomL[52][52];\nchar RoomR[52][52];\n\nconst int dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};\n\nstruct P {\n    int lx, ly, rx, ry;\n};\n\nbool is_reachable(int x, int y, char room[52][52]) {\n    bool G[52][52] = {};\n    G[y][x] = true;\n    queue<pii> que;\n    que.push({x, y});\n    while (!que.empty()) {\n        pii p = que.front(); que.pop();\n        int x = p.first, y = p.second;\n        REP(i, 4) {\n            int sx = x + dx[i], sy = y + dy[i];\n            switch (room[sy][sx]) {\n            case '%':\n                return true;\n            case '#':\n                break;\n            default:\n                if (!G[sy][sx]) {\n                    G[sy][sx] = true;\n                    que.push({sx, sy});\n                }\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    while (cin >> W >> H, W|H) {\n        fill_n((char *)RoomL, 52*52, '#');\n        fill_n((char *)RoomR, 52*52, '#');\n\n        int lx, ly, rx, ry;\n        int lgx, lgy, rgx, rgy;\n        FOR(y, 1, H+1) {\n            FOR(x, 1, W+1) {\n                cin >> RoomL[y][x];\n                switch (RoomL[y][x]) {\n                case 'L':\n                    lx = x;\n                    ly = y;\n                    RoomL[y][x] = '.';\n                    break;\n                case '%':\n                    lgx = x;\n                    lgy = y;\n                    break;\n                }\n            }\n            FOR(x, 1, W+1) {\n                cin >> RoomR[y][x];\n                switch (RoomR[y][x]) {\n                case 'R':\n                    rx = x;\n                    ry = y;\n                    RoomR[y][x] = '.';\n                    break;\n                case '%':\n                    rgx = x;\n                    rgy = y;\n                    break;\n                }\n            }\n        }\n\n        if (!(is_reachable(lx, ly, RoomL) && is_reachable(rx, ry, RoomR))) {\n            cout << \"No\" << endl;\n            continue;\n        }\n\n        bool G[52][52][52][52] = {};\n        G[lx][ly][rx][ry] = true;\n        queue<P> que;\n        que.push({lx, ly, rx, ry});\n        while (!que.empty()) {\n            P p = que.front(); que.pop();\n            if (p.lx == lgx && p.ly == lgy && p.rx == rgx && p.ry == rgy) {\n                cout << \"Yes\" << endl;\n                goto END;\n            }\n\n            REP(i, 4) {\n                int lsx = p.lx - dx[i], lsy = p.ly + dy[i];\n                int rsx = p.rx + dx[i], rsy = p.ry + dy[i];\n                if (RoomL[lsy][lsx] == '#') {\n                    lsx = p.lx;\n                    lsy = p.ly;\n                }\n                if (RoomR[rsy][rsx] == '#') {\n                    rsx = p.rx;\n                    rsy = p.ry;\n                }\n                if (RoomR[rsy][rsx] == '%' || RoomL[lsy][lsx] == '%') {\n                    if (RoomR[rsy][rsx] == '%' && RoomL[lsy][lsx] == '%') {\n                    } else {\n                        continue;\n                    }\n                }\n                if (!G[lsx][lsy][rsx][rsy]) {\n//                    LOG(\"-----\\n%d %d # %d %d\\n-----\\n\", lsx, lsy, rsx, rsy);\n//                    REP(y, H+2) {\n//                        REP(x, W+2) {\n//                            if (lsx == x && lsy == y) {\n//                                printf(\"L\");\n//                            } else {\n//                                printf(\"%c\", RoomL[y][x]);\n//                            }\n//                        }\n//                        printf(\"\\n\");\n//                    }\n//                    REP(y, H+2) {\n//                        REP(x, W+2) {\n//                            if (rsx == x && rsy == y) {\n//                                printf(\"R\");\n//                            } else {\n//                                printf(\"%c\", RoomR[y][x]);\n//                            }\n//                        }\n//                        printf(\"\\n\");\n//                    }\n                    G[lsx][lsy][rsx][rsy] = true;\n                    que.push({lsx, lsy, rsx, rsy});\n                }\n            }\n        }\n        cout << \"No\" << endl;\n    END: {}\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<char,char> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst double EPS = 1e-9;\n\nint main(){\n    while(true){\n        int W,H;\n        cin >> W >> H;\n        if(W == 0 and H == 0) break;\n        vector<vector<string> > field(2,vector<string>(H+2,string(W+2,'#')));\n\n        for(int i=1;i<=H;i++){\n            for(int j=0;j<2;j++){\n                cin >> field[j][i];\n                field[j][i] = '#' + field[j][i] + '#';\n            }\n        }\n        pair<pii,pii> start;\n        pair<pii,pii> goal;\n        for(int i=0;i<2;i++){\n            for(int j=1;j<=H;j++){\n                for(int k=1;k<=W;k++){\n                    if(field[i][j][k] == 'L'){\n                        start.first = make_pair(j,k);\n                    }else if(field[i][j][k] == 'R'){\n                        start.second = make_pair(j,k);\n                    }else if(field[i][j][k] == '%'){\n                        if(i == 0){\n                            goal.first = make_pair(j,k);\n                        }else{\n                            goal.second = make_pair(j,k);\n                        }\n                    }\n                }\n            }\n        }\n        stack<pair<pii,pii> > sta;\n        sta.push(start);\n        bool used[H+2][W+2][H+2][W+2];\n        for(int i=0;i<H+2;i++){\n            for(int j=0;j<W+2;j++){\n                for(int k=0;k<H+2;k++){\n                    for(int l=0;l<W+2;l++){\n                        used[i][j][k][l] = false;\n                    }\n                }\n            }\n        }\n        bool ok = false;\n        while(not sta.empty()){\n            pair<pii,pii> now = sta.top();\n            sta.pop();\n            if(used[now.first.first][now.first.second][now.second.first][now.second.second]){\n                continue;\n            }\n            used[now.first.first][now.first.second][now.second.first][now.second.second] = true;\n            if(now == goal){\n                ok = true;\n                break;\n            }\n            if(now.first == goal.first){\n                continue;\n            }\n            if(now.second == goal.second){\n                continue;\n            }\n            for(int i=0;i<4;i++){\n                pair<pii,pii> next = now;\n                next.first.first += dy[i];\n                next.first.second += dx[i];\n                next.second.first += dy[i];\n                next.second.second -= dx[i];\n                if(field[0][next.first.first][next.first.second] == '#'){\n                    next.first = now.first;\n                }\n                if(field[1][next.second.first][next.second.second] == '#'){\n                    next.second = now.second;\n                }\n                sta.push(next);\n            }\n        }\n        if(ok){\n            cout << \"Yes\" << endl;\n        }else{\n            cout << \"No\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//50\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nchar g[2][50][50];\nbool p[50][50][50][50];\nint w,h;\n    \nbool dfs(int x,int y,int xx,int yy){\n  if(p[x][y][xx][yy]++||(g[0][y][x]=='%'^g[1][yy][xx]=='%'))return false;\n  if(g[0][y][x]=='%'&&g[1][yy][xx]=='%')return true;\n  for(int i=0;i<4;i++){\n    int dy[]={0,1,0,-1};\n    int dx[][4]={{1,0,-1,0},{-1,0,1,0}};\n    int nx[2],ny[2];\n    nx[0]=x+dx[0][i];\n    ny[0]=y+dy[i];\n    nx[1]=xx+dx[1][i];\n    ny[1]=yy+dy[i];\n    for(int j=0;j<2;j++){\n      if(nx[j]<0||w<=nx[j]||ny[j]<0||h<=ny[j]||g[j][ny[j]][nx[j]]=='#'){\n\tnx[j]-=dx[j][i];\n\tny[j]-=dy[i];\n      }\n    }\n    if(dfs(nx[0],ny[0],nx[1],ny[1]))return true;\n  }\n  return false;\n}\n\nint main(){\n  while(cin>>w>>h,w|h){\n    int px[2],py[2];\n    for(int y=0;y<h;y++){\n      for(int i=0;i<2;i++){\n\tfor(int x=0;x<w;x++){\n\t  cin>>g[i][y][x];\n\t  if(g[i][y][x]=='R'||g[i][y][x]=='L'){\n\t    px[i]=x;\n\t    py[i]=y;\n\t  }\n\t}\n      }\n    }\n    fill(p[0][0][0],p[50][0][0],false);\n    cout<<(dfs(px[0],py[0],px[1],py[1])?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint range(int a,int b,int h, int w){\n\treturn a >= 0 && a < h && b >= 0 && b < w;\n}\n\nP lg, rg;\nint dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0}, h, w;\nchar f[50][50][50][51];\nchar lf[50][51],rf[50][51]; \n\nint dfs(P l,P r){\n\tint i, ly, lx, ry, rx;\n\tly = l.first, lx = l.second, ry = r.first, rx = r.second;\n\tif(lg.first == ly && lg.second == lx || rg.first == ry && rg.second == rx){\n\t\tif(lg.first == ly && lg.second == lx && rg.first == ry && rg.second == rx)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tfor(i = 0;i < 4;i++){\n\t\tif(range(ly + dy[i],lx + dx[i],h,w) && range(ry + dy[i],rx - dx[i],h,w)){\n\t\t\tif(lf[ly + dy[i]][lx + dx[i]] != '#' && rf[ry + dy[i]][rx - dx[i]] != '#' && f[ly + dy[i]][lx + dx[i]][ry + dy[i]][rx - dx[i]]){\n\t\t\t\tf[ly + dy[i]][lx + dx[i]][ry + dy[i]][rx - dx[i]] = 0;\n\t\t\t\tif(dfs(P(ly + dy[i],lx + dx[i]),P(ry + dy[i],rx - dx[i]))) return 1;\n\t\t\t}\n\t\t\telse if(lf[ly + dy[i]][lx + dx[i]] != '#' && rf[ry + dy[i]][rx - dx[i]] == '#' && f[ly + dy[i]][lx + dx[i]][ry][rx]){\n\t\t\t\tf[ly + dy[i]][lx + dx[i]][ry][rx] = 0;\n\t\t\t\tif(dfs(P(ly + dy[i],lx + dx[i]),P(ry,rx))) return 1;\n\t\t\t}\n\t\t\telse if(lf[ly + dy[i]][lx + dx[i]] == '#' && rf[ry + dy[i]][rx - dx[i]] != '#' && f[ly][lx][ry + dy[i]][rx - dx[i]]){\n\t\t\t\tf[ly][lx][ry + dy[i]][rx - dx[i]] = 0;\n\t\t\t\tif(dfs(P(ly,lx),P(ry + dy[i],rx - dx[i]))) return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(void){\n\tint i, j;\n\tP rs, ls;\n\twhile(1){\n\t\tscanf(\"%d%d%*c\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tlf[i][j] = getchar();\n\t\t\t\tif(lf[i][j] == 'L'){\n\t\t\t\t\tls = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(lf[i][j] == '%'){\n\t\t\t\t\tlg = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 空白読み飛ばし\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\trf[i][j] = getchar();\n\t\t\t\tif(rf[i][j] == 'R'){\n\t\t\t\t\trs = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(rf[i][j] == '%'){\n\t\t\t\t\trg = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 改行文字読み飛ばし\n\t\t}\n\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tfor(int k = 0;k < h;k++)\n\t\t\t\t\tfor(int l = 0;l < w;l++) f[i][j][k][l] = 1;\n\t\t\t}\n\t\t}\n\t\tf[ls.first][ls.second][rs.first][rs.second] = 0;\n\t\tprintf(\"%d %d %d %d\\n\",ls.second,ls.first,rs.second,rs.first);\n\t\tif(dfs(ls,rs))\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define M 50\n#include<cstring>\nusing namespace std;\nbool flag;\nint dx[]={1,-1,0,0},dy[]={0,0,-1,1},w,h;\nchar r[M][M],l[M][M];\nint dp[M][M][M][M];\nvoid func(int ly,int lx,int ry,int rx){\n\tif(flag)\n\treturn;\n\t//cout<<ly<<' '<<lx<<' '<<ry<<' '<<rx<<endl;\n\tif(dp[ly][lx][ry][rx]!=0)\n\treturn;\n\tdp[ly][lx][ry][rx]=1;\n\tif(l[ly][lx]=='%'&&r[ry][rx]=='%'){\n\t\tflag=true;\n\t\treturn;\n\t}else if(l[ly][lx]=='%'||r[ry][rx]=='%')\n\treturn;\n\tint nrx,nry,nlx,nly;\n\tfor(int i=0;i<4;i++){\n\t\tnrx=dx[i]+rx;\n\t\tnry=dy[i]+ry;\n\t\tnlx=-dx[i]+lx;\n\t\tnly=dy[i]+ly;\n\t\tif(!(nrx>=0&&nrx<w&&nry>=0&&nry<h)||r[nry][nrx]=='#'){\n\t\t\tnrx=rx;nry=ry;\n\t\t}\n\t\tif(!(nlx>=0&&nlx<w&&nly>=0&&nly<h)||l[nly][nlx]=='#'){\n\t\t\tnlx=lx;nly=ly;\n\t\t}\n\t\tif(dp[nly][nlx][nry][nrx]==0)\n\t\tfunc(nly,nlx,nry,nrx);\n\t}\n}\nint main(){\n\tint a,b,c,d;\n\twhile(cin>>w>>h,h||w){\n\t\tfor(int i=0;i<h;i++)\n\t\t\tcin>>l[i]>>r[i];\n\t\tfor(int i=0;i<h;i++)\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(l[i][j]=='L'){\n\t\t\t\t\ta=i;b=j;\n\t\t\t\t}\n\t\t\t\tif(r[i][j]=='R'){\n\t\t\t\t\tc=i;d=j;\n\t\t\t\t}\n\t\t}\n\t\tmemset(dp,0,sizeof(dp));\n\t\tflag=false;\n\t\tfunc(a,b,c,d);\n\t\tputs(flag?\"Yes\":\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define fi first\n#define se second\n#define mk make_pair\nusing namespace std;\nstring s1[50],s2[50];\nint dx1[]={1,-1,0,0,},dy1[]={0,0,1,-1};\nint dx2[]={-1,1,0,0,},dy2[]={0,0,1,-1};\nint w,h,gx1,gx2,gy1,gy2;\nset<pair<pair<int,int>,pair<int,int> > >s;\nqueue<pair<pair<int,int>,pair<int,int> > >q;\nbool bfs(int x1,int y1,int x2,int y2){\n  queue<int>q;\n  q.push(x1+y1*100+x2*10000+y2*1000000);\n  while(!q.empty()){\n    int p=q.front();q.pop();\n    x1=p%100;y1=p%10000/100;\n    x2=p%1000000/10000;y2=p/1000000;\n    for(int i=0;i<4;i++){\n      int x3=x1+dx1[i],y3=y1+dy1[i];\n      int x4=x2+dx2[i],y4=y2+dy2[i];\n      if(x3>=0&&x4>=0&&y3>=0&&y4>=0)\n        if(x3<w&&x4<w&&y3<h&&y4<h){\n          if(s1[y3][x3]=='#')y3=y1,x3=x1;\n          if(s2[y4][x4]=='#')y4=y2,x4=x2;\n          if(x1==gx1&&y1==gy1&&x2==gx2&&y2==gy2)return 1;\n          if(!(x3==gx1&&y3==gy1&&(x4!=gx2||y4!=gy2)))\n          if(!((x3!=gx1||y3!=gy1)&&x4==gx2&&y4==gy2))\n          if(!s.count(mk(mk(x3,y3),mk(x4,y4)))){\n            s.insert(mk(mk(x3,y3),mk(x4,y4)));\n            q.push(x3+y3*100+x4*10000+y4*1000000);\n          }\n        }\n      }\n    }\n    return 0;\n}\nbool dfs(int x1,int y1,int x2,int y2,int d){\n  //cout<<d<<endl;cout<<1;\n    if(x1==gx1&&y1==gy1&&(x2!=gx2||y2!=gy2))return 0;\n    if((x1!=gx1||y1!=gy1)&&x2==gx2&&y2==gy2)return 0;\n    if(x1==gx1&&y1==gy1&&x2==gx2&&y2==gy2)return 1;\n    if(d<10000)for(int i=0;i<4;i++){\n    int x3=x1+dx1[i],y3=y1+dy1[i];\n    int x4=x2+dx2[i],y4=y2+dy2[i];\n    if(x3<0)x3=x1;if(x4<0)x4=x2;\n    if(y3<0)y3=y1;if(y4<0)y4=y2;\n    if(x3>=w)x3=x1;if(x4>=w)x4=x2;\n    if(y3>=h)y3=y1;if(y4>=h)y4=y2;\n        if(s1[y3][x3]=='#')y3=y1,x3=x1;\n        if(s2[y4][x4]=='#')y4=y2,x4=x2;\n        if(!s.count(mk(mk(x3,y3),mk(x4,y4)))){\n          s.insert(mk(mk(x3,y3),mk(x4,y4)));\n          if(dfs(x3,y3,x4,y4,d+1))return 1;\n        }\n    }\n    else q.push(mk(mk(x1,y1),mk(x2,y2)));\n    if(q.size()){\n        pair<pair<int,int>,pair<int,int> >pp=q.front();q.pop();\n        if(bfs(pp.fi.fi,pp.fi.se,pp.se.fi,pp.se.se))return 1;\n    }\n    return 0;\n}\nint main(){\n  int x1,y1,x2,y2;\n  while(cin>>w>>h,w){\n    s.clear();\n    r(i,h)cin>>s1[i]>>s2[i];\n    r(i,h)r(j,w){\n      if(s1[i][j]=='L')x1=j,y1=i;\n      if(s2[i][j]=='R')x2=j,y2=i;\n      if(s1[i][j]=='%')gx1=j,gy1=i;\n      if(s2[i][j]=='%')gx2=j,gy2=i;\n    }\n    s.insert(mk(mk(x1,y1),mk(x2,y2)));\n    if(dfs(x1,y1,x2,y2,0))cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n    while(!q.empty())q.pop();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define mk make_pair\nusing namespace std;\nstring s1[50],s2[50];\nint dx1[]={1,-1,0,0,},dy1[]={0,0,1,-1};\nint dx2[]={-1,1,0,0,},dy2[]={0,0,1,-1};\nint w,h,gx1,gx2,gy1,gy2;\nset<pair<pair<int,int>,pair<int,int> > >s;\nbool dfs(int x1,int y1,int x2,int y2){\n  if(x1==gx1&&y1==gy1&&(x2!=gx2||y2!=gy2))return 0;\n  if((x1!=gx1||y1!=gy1)&&x2==gx2&&y2==gy2)return 0;\n  if(x1==gx1&&y1==gy1&&x2==gx2&&y2==gy2)return 1;\n  for(int i=0;i<4;i++){\n    int x3=x1+dx1[i],y3=y1+dy1[i];\n    int x4=x2+dx2[i],y4=y2+dy2[i];\n    if(x3>=0&&x4>=0&&y3>=0&&y4>=0)\n      if(x3<w&&x4<w&&y3<h&&y4<h){\n        if(s1[y3][x3]=='#')y3=y1,x3=x1;\n        if(s2[y4][x4]=='#')y4=y2,x4=x2;\n        if(!s.count(mk(mk(x3,y3),mk(x4,y4)))){\n          s.insert(mk(mk(x3,y3),mk(x4,y4)));\n          if(dfs(x3,y3,x4,y4))return 1;\n        }\n      }\n    }\n    return 0;\n}\nint main(){\n  int x1,y1,x2,y2;\n  while(cin>>w>>h,w){\n    s.clear();\n    r(i,h)cin>>s1[i]>>s2[i];\n    r(i,h)r(j,w){\n      if(s1[i][j]=='L')x1=j,y1=i;\n      if(s2[i][j]=='R')x2=j,y2=i;\n      if(s1[i][j]=='%')gx1=j,gy1=i;\n      if(s2[i][j]=='%')gx2=j,gy2=i;\n    }\n    s.insert(mk(mk(x1,y1),mk(x2,y2)));\n    if(dfs(x1,y1,x2,y2))cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// Header {{{\n// includes {{{\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <unistd.h>\n#include <vector>\n// }}}\nusing namespace std;\n// consts {{{\nstatic const int INF = 1e9;\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n// }}}\n// typedefs {{{\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<ULL> VULL;\ntypedef vector<VULL> VVULL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef pair<int, int> PII;\ntypedef complex<char> P;\n#define PQ(type) priority_queue<type>\n// priority queue reverse\n#define PQR(type) priority_queue< type, vector<type>, greater<type> >\n// }}}\n// macros & inline functions {{{\n// syntax sugars {{{\n#define FOR(i, b, e) for (typeof(e) i = (b); i < (e); ++i)\n#define FORI(i, b, e) for (typeof(e) i = (b); i <= (e); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(i, n) FORI(i, 0, n)\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n#define ASSIGN_MAX(var, val) ((var) = max((var), (val)))\n#define ASSIGN_MIN(var, val) ((var) = min((var), (val)))\n// }}}\n// conversion {{{\ninline int toInt(string s) { int v; istringstream sin(s); sin>>v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout<<x; return sout.str(); }\n// }}}\n// array and STL {{{\n#define ARRSIZE(a) ( sizeof(a) / sizeof(a[0]) )\n#define ZERO(a, v) ( assert(v == 0 || v == -1), memset(a, v, sizeof(a)) )\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n#define SIZE(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c, it) for(typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define REACH(c, it) for(typeof((c).rbegin()) it=(c).rbegin(); it!=(c).rend(); ++it)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n// }}}\n// bit manipulation {{{\n// singed integers are not for bitwise operations, specifically arithmetic shifts ('>>', and maybe not good for '<<' too)\n#define IS_UNSIGNED(n) (!numeric_limits<typeof(n)>::is_signed)\n#define BIT(n) (assert(IS_UNSIGNED(n)), assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(IS_UNSIGNED(n)), assert(m < 64), ((ULL)(n) >> (m) & 1))\ninline int BITS_COUNT(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int MSB(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c-1; }\ninline int MAKE_MASK(ULL upper, ULL lower) { assert(lower < 64 && upper < 64 && lower <= upper); return (BIT(upper) - 1) ^ (BIT(lower) - 1); }\n// }}}\n// for readable code {{{\n#define EVEN(n) (n % 2 == 0)\n#define ODD(n) (!EVEN(n))\n// }}}\n// debug {{{\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n#define dprt(fmt, ...) if (opt_debug) { fprintf(stderr, fmt, ##__VA_ARGS__); }\n#define darr(a) if (opt_debug) { copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr_range(a, f, t) if (opt_debug) { copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define dvec(v) if (opt_debug) { copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl; }\n#define darr2(a) if (opt_debug) { FOR(__i, 0, (arrsz(a))){ darr( (a)[__i] ); } }\n#define WAIT() if (opt_debug) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#define dump(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl; }\n// dump vector elements in [s, e)\n#define dumpv(v, s, e) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #v << \" = \"; FOR(__i, s, e) { cerr << v[__i] << \"\\t\"; } cerr << endl; }\n#define dumpl(x) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #x << endl << (x) << endl; }\n#define dumpf() if (opt_debug) { cerr << __PRETTY_FUNCTION__ << endl; }\n#define where() if (opt_debug) { cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl; }\n#define dumpb(bit, digits) if (opt_debug) { cerr << \" [L\" << __LINE__ << \"] \" << #bit << \" = \"; for(int __i = digits - 1; __i >= 0; __i--) { cerr << static_cast<bool>(bit & (1 << __i)); if (__i % 4 == 0) { cerr << \" \"; } } cerr << endl; }\n\n// ostreams {{{\n// complex\ntemplate<typename T> ostream& operator<<(ostream& s, const complex<T>& d) {return s << \"(\" << d.real() << \", \" << d.imag() << \")\";}\n\n// pair\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n// vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i]; if (i < len - 1) s << \"\\t\";\n\t}\n\treturn s;\n}\n\n// 2 dimentional vector\ntemplate<typename T> ostream& operator<<(ostream& s, const vector< vector<T> >& d) {\n\tint len = d.size();\n\tREP (i, len) {\n\t\ts << d[i] << endl;\n\t}\n\treturn s;\n}\n\n// map\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const map<T1, T2>& m) {\n\ts << \"{\" << endl;\n\tfor (typeof(m.begin()) itr = m.begin(); itr != m.end(); ++itr) {\n\t\ts << \"\\t\" << (*itr).first << \" : \" << (*itr).second << endl;\n\t}\n\ts << \"}\" << endl;\n\treturn s;\n}\n// }}}\n// }}}\n// }}}\n// time {{{\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\n// }}}\n// string manipulation {{{\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\ninline string join(VS s, string j) { string t; REP(i, s.size()) { t += s[i] + j; } return t; }\n// }}}\n// geometry {{{\n#define Y real()\n#define X imag()\n// }}}\n// 2 dimentional array {{{\nenum { UP, RIGHT, DOWN, LEFT, UP_RIGHT, DOWN_RIGHT, DOWN_LEFT, UP_LEFT };\nP dydx4[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\nP dydx8[8] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1), P(-1, 1), P(1, 1), P(1, -1), P(-1, -1) };\nbool in_field(int H, int W, P p) {\n\treturn (0 <= p.Y && p.Y < H) && (0 <= p.X && p.X < W);\n}\n// }}}\n// input and output {{{\ninline void input(string filename) {\n\tfreopen(filename.c_str(), \"r\", stdin);\n}\ninline void output(string filename) {\n\tfreopen(filename.c_str(), \"w\", stdout);\n}\n// }}}\n// }}}\n\nbool opt_debug = false;\n\nint main(int argc, char** argv) {\n\tstd::ios_base::sync_with_stdio(false);\n\t// set options {{{\n\tint __c;\n\twhile ( (__c = getopt(argc, argv, \"d\")) != -1 ) {\n\t\tswitch (__c) {\n\t\t\tcase 'd':\n\t\t\t\topt_debug = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tabort();\n\t\t}\n\t}\n\t// }}}\n\n\t// opt_debug = true;\n\t// input(\"./inputs/0.txt\");\n\t// output(\"./outputs/0.txt\");\n\n\tint W, H;\n\twhile (cin >> W >> H, W | H) {\n\t\tVVC room_l(H, VC(W));\n\t\tVVC room_r(H, VC(W));\n\t\tP len, rin;\n\t\tREP (i, H) {\n\t\t\tREP (j, W) {\n\t\t\t\tcin >> room_l[i][j];\n\t\t\t\tif (room_l[i][j] == 'L') {\n\t\t\t\t\tlen = P(i, j);\n\t\t\t\t\troom_l[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP (j, W) {\n\t\t\t\tcin >> room_r[i][j];\n\t\t\t\tif (room_r[i][j] == 'R') {\n\t\t\t\t\trin = P(i, j);\n\t\t\t\t\troom_r[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttypedef pair<P, P> PPP;\n\t\tqueue<PPP> q;\n\t\tq.push(MP(len, rin));\n\t\tP dydx_l[4] = { P(-1, 0), P(0, 1), P(1, 0), P(0, -1) };\n\t\tP dydx_r[4] = { P(-1, 0), P(0, -1), P(1, 0), P(0, 1) };\n\t\ttypedef pair< pair<char, char>, pair<char, char> > PPIIPII;\n\t\tset< PPIIPII > visited;\n\t\tbool ok = false;\n\t\twhile (!q.empty()) {\n\t\t\tPPP t = q.front(); q.pop();\n\t\t\tPPIIPII key = MP( MP(t.F.Y, t.F.X), MP(t.S.Y, t.S.X) );\n\t\t\tif (EXIST(visited, key)) { continue; }\n\t\t\tvisited.insert(key);\n\t\t\tlen = t.F; rin = t.S;\n\t\t\tif (room_l[len.Y][len.X] == '%' && room_r[rin.Y][rin.X] == '%') {\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (room_l[len.Y][len.X] == '%' || room_r[rin.Y][rin.X] == '%') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tREP (d, 4) {\n\t\t\t\tP n_len = len + dydx_l[d];\n\t\t\t\tP n_rin = rin + dydx_r[d];\n\t\t\t\tif (!in_field(H, W, n_len) || room_l[n_len.Y][n_len.X] == '#') {\n\t\t\t\t\tn_len -= dydx_l[d];\n\t\t\t\t}\n\t\t\t\tif (!in_field(H, W, n_rin) || room_r[n_rin.Y][n_rin.X] == '#') {\n\t\t\t\t\tn_rin -= dydx_r[d];\n\t\t\t\t}\n\t\t\t\tq.push(MP(n_len, n_rin));\n\t\t\t}\n\t\t}\n\n\t\tif (ok) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t} else {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<n; i++)\n\nconst int dx[2][4] = {{1, 0, -1, 0}, {1, 0, -1, 0}};\nconst int dy[2][4] = {{0, 1, 0, -1}, {0, -1, 0, 1}};\nconst int MAX_W = 55;\nconst int MAX_H = 55;\nchar maze[2][MAX_H][MAX_W+1];\nint sx[2], sy[2];\nint tx[2], ty[2];\nint h, w;\nbool used[MAX_H][MAX_W][MAX_H][MAX_W];\n\ninline bool check(int hx, int hy){ return 0 <= hx && hx < h && 0 <= hy && hy < w; }\n\nint main()\n{\n  while(cin >> w >> h, w){\n    rep(i, h) rep(j, w) rep(k, h) rep(l, w) used[i][j][k][l] = false;\n    rep(i, h){\n      rep(j, w) cin >> maze[0][i][j];\n      rep(j, w) cin >> maze[1][i][j];\n    }\n\n    rep(i, h) rep(j, w) if(maze[0][i][j] == 'L') sx[0] = i,  sy[0] = j;\n    rep(i, h) rep(j, w) if(maze[0][i][j] == '%') tx[0] = i,  ty[0] = j;\n    rep(i, h) rep(j, w) if(maze[1][i][j] == 'R') sx[1] = i,  sy[1] = j;\n    rep(i, h) rep(j, w) if(maze[1][i][j] == '%') tx[1] = i,  ty[1] = j;\n\n    queue<vector<int> > que;\n    vector<int> tmp(4);\n    tmp[0] = sx[0];\n    tmp[1] = sy[0];\n    tmp[2] = sx[1];\n    tmp[3] = sy[1];\n    que.push(tmp);\n    //    map<vector<int>, bool> used;\n    used[tmp[0]][tmp[1]][tmp[2]][tmp[3]] = true;\n    //    used[tmp] = true;\n    bool ok = false;\n    while(!que.empty()){\n      vector<int> h = que.front();  que.pop();\n      if(h[0] == tx[0] && h[1] == ty[0] && h[2] == tx[1] && h[3] == ty[1]){\n        ok = true;\n        break;\n      }\n      rep(k, 4){\n        int nx[2] = {h[0] + dx[0][k], h[2] + dx[1][k]};\n        int ny[2] = {h[1] + dy[0][k], h[3] + dy[1][k]};\n        if(!check(nx[0], ny[0]) && !check(nx[1], ny[1])) continue;\n        if((nx[0] == tx[0] && ny[0] == ty[0]) && (nx[1] != tx[1] || ny[1] != ty[1])) continue;\n        if((nx[0] != tx[0] || ny[0] != ty[0]) && (nx[1] == tx[1] && ny[1] == ty[1])) continue;\n        if(check(nx[0], ny[0]) && maze[0][nx[0]][ny[0]] != '#'){\n          tmp[0] = nx[0];\n          tmp[1] = ny[0];\n        }\n        else{\n          tmp[0] = h[0];\n          tmp[1] = h[1];\n        }\n        if(check(nx[1], ny[1]) && maze[1][nx[1]][ny[1]] != '#'){\n          tmp[2] = nx[1];\n          tmp[3] = ny[1];\n        }\n        else{\n          tmp[2] = h[2];\n          tmp[3] = h[3];\n        }\n        if(h != tmp && !used[tmp[0]][tmp[1]][tmp[2]][tmp[3]]){\n          used[tmp[0]][tmp[1]][tmp[2]][tmp[3]] = true;\n          //          used[tmp] = true;\n          que.push(tmp);\n        }\n      }\n    }\n\n    puts(ok ? \"Yes\" : \"No\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int i,j;\n  int a[52][52],b[52][52],sx,sy,tx,ty,w,h;\n  char s;\n  bool d[52][52][52][52];\n  queue<pair<pair<int,int>,pair<int,int> > > c;\n  while(cin>>w>>h&&w+h){\n    memset(a,-1,sizeof(a));\n    memset(b,-1,sizeof(b));\n    for(i=1;i<h+1;i++){\n      for(j=1;j<w+1;j++){\n\tcin>>s;\n\tif(0){\n\t}else if(s=='#'){\n\t}else if(s=='%'){\n\t  a[j][i]=1;\n\t}else{\n\t  a[j][i]=0;\n\t  if(s=='L'){\n\t    sx=j;\n\t    sy=i;\n\t  }\n\t}\n      }\n      for(j=w;j>0;j--){\n\tcin>>s;\n\tif(0){\n\t}else if(s=='#'){\n\t}else if(s=='%'){\n\t  b[j][i]=1;\n\t}else{\n\t  b[j][i]=0;\n\t  if(s=='R'){\n\t    tx=j;\n\t    ty=i;\n\t  }\n\t}\n      }\n    }\n    memset(d,0,52*52*52*52);\n    while(c.empty()==0)\n      c.pop();\n    c.push(make_pair(make_pair(sx,sy),make_pair(tx,ty)));\n    while(c.empty()==0){\n      sx=c.front().first.first;\n      sy=c.front().first.second;\n      tx=c.front().second.first;\n      ty=c.front().second.second;\n      if(a[sx][sy]==1&&b[tx][ty]==1)\n\tbreak;\n      c.pop();\n      if(a[sx][sy]==0&&b[tx][ty]==0&&d[sx][sy][tx][ty]==0){\n\td[sx][sy][tx][ty]=1;\n\tc.push(make_pair(make_pair(sx-(a[sx-1][sy]==-1?0:1),sy),make_pair(tx-(b[tx-1][ty]==-1?0:1),ty)));\n\tc.push(make_pair(make_pair(sx+(a[sx+1][sy]==-1?0:1),sy),make_pair(tx+(b[tx+1][ty]==-1?0:1),ty)));\n\tc.push(make_pair(make_pair(sx,sy-(a[sx][sy-1]==-1?0:1)),make_pair(tx,ty-(b[tx][ty-1]==-1?0:1))));\n\tc.push(make_pair(make_pair(sx,sy+(a[sx][sy+1]==-1?0:1)),make_pair(tx,ty+(b[tx][ty+1]==-1?0:1))));\n      }\n    }\n    if(c.empty())\n      cout<<\"No\"<<endl;\n    else\n      cout<<\"Yes\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<set>\n#include<queue>\n#include<cmath>\nusing namespace std;\ntypedef vector<int> vi;\nconst int inf=1e9;\nint w,h;\nint ldx[]={-1,0,1,0};\nint ldy[]={0,1,0,-1};\nint rdx[]={1,0,-1,0};\nint rdy[]={0,1,0,-1};\nbool rinvis[55][55];\nbool renvis[55][55];\nbool vis[55][55][55][55];\nstring rin[55];\nstring ren[55];\nbool treasure;\nint rinsx,rinsy,ringx,ringy,rensx,rensy,rengx,rengy;\nstruct P\n{\n  int ly,lx,ry,rx;\n  P(int ly,int lx,int ry,int rx):ly(ly),lx(lx),ry(ry),rx(rx){};\n};\nvoid bfs(int lx,int ly,int rx,int ry)\n{\n  vis[ly][lx][ry][rx]=true;\n  // renvis[ly][lx]=true;\n  //rinvis[ry][rx]=true;\n  queue<P> q;\n  q.push(P(ly,lx,ry,rx));\n  while(!q.empty())\n    {\n      P now=q.front();q.pop();\n      int rennx,renny,rinnx,rinny;\n      bool rengoal=false;\n      bool ringoal=false;\n      for(int k=0;k<4;k++)\n\t{\n\t  rennx=now.lx+ldx[k];\n\t  renny=now.ly+ldy[k];\n\t  rinnx=now.rx+rdx[k];\n\t  rinny=now.ry+rdy[k];\n\t  if(rennx>=w || rennx<0 || renny>=h || renny<0 || ren[renny][rennx]=='#')\n\t    {\n\t      rennx=now.lx;\n\t      renny=now.ly;\n\t    }\n\t  if(rinnx>=w || rinnx<0 || rinny>=h || rinny<0 ||rin[rinny][rinnx]=='#')\n\t    {\n\t      rinnx=now.rx;\n\t      rinny=now.ry;\n\t    }\n\t  if(vis[renny][rennx][rinny][rinnx])continue;\n\t  if(ren[renny][rennx]=='%') rengoal=true;\n\t  else rengoal=false;\n\t  if(rin[rinny][rinnx]=='%') ringoal=true;\n\t  else ringoal=false;\n\t  if(rengoal && ringoal)\n\t    {\n\t      treasure=true;\n\t      return;\n\t    }\n\t  if(rengoal^ringoal) continue;\n\t  q.push(P(renny,rennx,rinny,rinnx));\n\t  vis[renny][rennx][rinny][rinnx]=true;\n\t}\n    }\n}\n\nint main()\n{\n  while(cin >> w >> h && w)\n    {\n      treasure=false;\n      memset(vis,false,sizeof(vis));\n      //memset(renvis,false,sizeof(renvis));\n      //memset(rinvis,false,sizeof(rinvis));\n      for(int i=0;i<h;i++)\n\t{\n\t  cin >> ren[i] >> rin[i];\n\t}\n      for(int i=0;i<h;i++)\n\t{\n\t  for(int j=0;j<h;j++)\n\t    {\n\t      if(ren[i][j]=='L')\n\t\t{\n\t\t  rensy=i;\n\t\t  rensx=j;\n\t\t}\n\t      if(ren[i][j]=='%')\n\t\t{\n\t\t  rengy=i;\n\t\t  rengx=j;\n\t\t}\n\t      if(rin[i][j]=='R')\n\t\t{\n\t\t  rinsy=i;\n\t\t  rinsx=j;\n\t\t}\n\t      if(rin[i][j]=='%')\n\t\t{\n\t\t  ringy=i;\n\t\t  ringx=j;\n\t\t}\n\t    }\n\t}\n      bfs(rensx,rensy,rinsx,rinsy);\n      if(treasure)\n\t{\n\t  cout << \"Yes\" << endl;\n\t}\n      else\n\t{\n\t  cout << \"No\" << endl;\n\t}\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<cmath>\n#include<utility>\n#include<functional>\n#include<map>\n#include<set>\n#include<cctype>\n\n\n#define FOR(i, a, b) for( int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for( int i=(a);i>=(b);i--)\n#define LFOR(i, a, b) for( long long int i=(a);i<=(b);i++)\n#define LRFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LLINF 1000000000000000000 //9000000000000000000\n#define PI 3.14159265358979\n#define MAXI 7500000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\n\nint dy[4] = { 0,0,1,-1 };\nint dx[4] = { 1,-1,0,0 };\n\n//int dp[50][50][50][50] = {};//ly,lx,ry,rx\n\n\nint main(void) {\n\t\n\twhile (1) {\n\n\t\tstruct Pos{\n\t\tpublic:\n\t\t\tint leftx;\n\t\t\tint lefty;\n\t\t\tint rightx;\n\t\t\tint righty;\n\t\t};\n\n\t\tint w, h;\n\t\tint lx = -1, ly = -1, rx = -1, ry = -1;\n\t\tint lgx = -1, lgy = -1, rgx = -1, rgy = -1;\n\n\t\tvector< vector< vector< vector<int> > > > dp(50, vector< vector< vector<int > > >(50, vector< vector<int> >(50, vector<int>(50, 0))));\n\t\t\n\n\t\tqueue< Pos > que;\n\t\tPos now;\n\n\t\tcin >> w >> h;\n\n\t\tif (w == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tvector<string> left(h), right(h);\n\n\t\tFOR(i, 0, h-1) {\n\t\t\tcin >> left[i] >> right[i];\n\t\t}\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (left[i][j] == 'L') {\n\t\t\t\t\tlx = j;\n\t\t\t\t\tly = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (right[i][j] == 'R') {\n\t\t\t\t\trx = j;\n\t\t\t\t\try = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (left[i][j] == '%') {\n\t\t\t\t\tlgx = j;\n\t\t\t\t\tlgy = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lgx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (right[i][j] == '%') {\n\t\t\t\t\trgx = j;\n\t\t\t\t\trgy = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rgx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdp[ly][lx][ry][rx] = 1;\n\n\t\tnow.lefty = ly;\n\t\tnow.leftx = lx;\n\t\tnow.righty = ry;\n\t\tnow.rightx = rx;\n\t\t\n\t\tque.push(now);\n\n\n\t\t/*while (!que.empty()) {\n\t\t\tnow = que.front();\n\t\t\t\n\t\t\tque.pop();\n\t\t\tly = now.lefty;\n\t\t\tlx = now.leftx;\n\t\t\try = now.righty;\n\t\t\trx = now.rightx;\n\t\t\t//cout << ly << \" \" << lx << \" \" << ry << \" \" << rx << endl;\n\n\t\t\tFOR(i, 0, 3) {\n\t\t\t\t\n\t\t\t\tif (ly + dy[i] >= 0 && lx - dx[i] >= 0 && ry + dy[i] <= h - 1 && rx + dx[i] <= w - 1 && ly + dy[i] <= h - 1 && lx - dx[i] <= w - 1 && ry + dy[i] >= 0 && rx + dx[i] >= 0) {\n\t\t\t\t\tif (dp[ly + dy[i]][lx - dx[i]][ry + dy[i]][rx + dx[i]] != 1) {\n\t\t\t\t\t\tif (left[ly + dy[i]][lx - dx[i]] == '#') {\n\t\t\t\t\t\t\tif (right[ry + dy[i]][rx + dx[i]] == '#') {\n\t\t\t\t\t\t\t\t//no\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdp[ly][lx][ry + dy[i]][rx + dx[i]] = 1;\n\t\t\t\t\t\t\t\tnow.lefty = ly;\n\t\t\t\t\t\t\t\tnow.leftx = lx;\n\t\t\t\t\t\t\t\tnow.righty = ry + dy[i];\n\t\t\t\t\t\t\t\tnow.rightx = rx + dx[i];\n\t\t\t\t\t\t\t\tque.push(now);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (right[ry + dy[i]][rx + dx[i]] == '#') {\n\t\t\t\t\t\t\t\tdp[ly + dy[i]][lx - dx[i]][ry][rx] = 1;\n\t\t\t\t\t\t\t\tnow.lefty = ly + dy[i];\n\t\t\t\t\t\t\t\tnow.leftx = lx - dx[i];\n\t\t\t\t\t\t\t\tnow.righty = ry;\n\t\t\t\t\t\t\t\tnow.rightx = rx;\n\t\t\t\t\t\t\t\tque.push(now);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdp[ly + dy[i]][lx - dx[i]][ry + dy[i]][rx + dx[i]] = 1;\n\t\t\t\t\t\t\t\tnow.lefty = ly + dy[i];\n\t\t\t\t\t\t\t\tnow.leftx = lx - dx[i];\n\t\t\t\t\t\t\t\tnow.righty = ry + dy[i];\n\t\t\t\t\t\t\t\tnow.rightx = rx + dx[i];\n\t\t\t\t\t\t\t\tque.push(now);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\n\t\tif (dp[lgy][lgx][rgy][rgx] == 1) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t\t\n\n\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<pair<int, int>, pair<int, int>> PPIIII;\n\nint dx[] = { 1,0,-1,0 };\nint dy[] = { 0,1,0,-1 };\n\nvoid solve( int W, int H ) {\n\tpair<int, int> startR, startL, goalR, goalL;\n\tvector<vector<vector<vector<bool>>>>dp( H + 2, vector<vector<vector<bool>>>( W + 2, vector<vector<bool>>( H + 2, vector<bool>( W + 2, 0 ) ) ) );\n\tvector<vector<vector<char>>>mapd( 2, vector<vector<char>>( H + 2, vector<char>( W + 2, '#' ) ) );\n\tfor( size_t i = 1; i <= H; i++ ) {\n\t\tfor( size_t j = 1; j <= W; j++ ) {\n\t\t\tcin >> mapd[0][i][j];\n\t\t\tif( mapd[0][i][j] == 'L' ) {\n\t\t\t\tstartL = make_pair( i, j );\n\t\t\t} else if( mapd[0][i][j] == '%' ) {\n\t\t\t\tgoalL = make_pair( i, j );\n\t\t\t}\n\t\t}\n\t\tfor( int j = W; j >= 1; j-- ) {\n\t\t\tcin >> mapd[1][i][j];\n\t\t\tif( mapd[1][i][j] == 'R' ) {\n\t\t\t\tstartR = make_pair( i, j );\n\t\t\t} else if( mapd[1][i][j] == '%' ) {\n\t\t\t\tgoalR = make_pair( i, j );\n\t\t\t}\n\t\t}\n\t}\n\tdp[startL.first][startL.second][startR.first][startR.second] = 1;\n\n\n\tqueue<PPIIII>que;\n\tbool f = true;\n\tque.push( make_pair( startL, startR ) );\n\twhile( que.size() ) {\n\t\tauto now = que.front(); que.pop();\n\t\tfor( size_t i = 0; i < 4; i++ ) {\n\t\t\tauto next = now;\n\t\t\tnext.first.first += dx[i];\n\t\t\tnext.first.second += dy[i];\n\t\t\tnext.second.first += dx[i];\n\t\t\tnext.second.second += dy[i];\n\t\t\tif( mapd[0][next.first.first][next.first.second] == '#' ) {\n\t\t\t\tnext.first = now.first;\n\t\t\t}\n\t\t\tif( mapd[1][next.second.first][next.second.second] == '#' ) {\n\t\t\t\tnext.second = now.second;\n\t\t\t}\n\t\t\tif( now.first == next.first&&now.second == next.second ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif( 0 < next.first.first&&next.first.first < H + 2 &&\n\t\t\t\t0 < next.first.second&&next.first.second < W + 2 &&\n\t\t\t\t0 < next.second.first&&next.second.first < H + 2 &&\n\t\t\t\t0 < next.second.second&&next.second.second < W + 2 ) {\n\t\t\t\tif( dp[next.first.first][next.first.second][next.second.first][next.second.second] == 0 ) {\n\t\t\t\t\tif( goalL == next.first&&goalR == next.second ) {\n\t\t\t\t\t\tif( now.first != next.first&&now.second != next.second ) {\n\t\t\t\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif( f ) {\n\t\t\t\t\t\t\tf = 0;\n\t\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdp[next.first.first][next.first.second][next.second.first][next.second.second] = 1;\n\t\t\t\t\t\tque.push( next );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"No\" << endl;\n\treturn;\n}\n\nint main() {\n\tint W, H;\n\twhile( cin >> W >> H, W&&H ) {\n\t\tsolve( W, H );\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<cmath>\n#include<utility>\n#include<functional>\n#include<map>\n#include<set>\n#include<cctype>\n\n\n#define FOR(i, a, b) for( int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for( int i=(a);i>=(b);i--)\n#define LFOR(i, a, b) for( long long int i=(a);i<=(b);i++)\n#define LRFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LLINF 1000000000000000000 //9000000000000000000\n#define PI 3.14159265358979\n#define MAXI 7500000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\n\nint dy[4] = { 0,0,1,-1 };\nint dx[4] = { 1,-1,0,0 };\n\n//int dp[50][50][50][50] = {};//ly,lx,ry,rx\n\n\nint main(void) {\n\t\n\twhile (1) {\n\n\t\tstruct Pos{\n\t\tpublic:\n\t\t\tint leftx;\n\t\t\tint lefty;\n\t\t\tint rightx;\n\t\t\tint righty;\n\t\t};\n\n\t\tint w, h;\n\t\tint lx = -1, ly = -1, rx = -1, ry = -1;\n\t\tint lgx = -1, lgy = -1, rgx = -1, rgy = -1;\n\n\t\tvector< vector< vector< vector<int> > > > dp(50, vector< vector< vector<int > > >(50, vector< vector<int> >(50, vector<int>(50, 0))));\n\t\t\n\n\t\tqueue< Pos > que;\n\t\tPos now;\n\n\t\tcin >> w >> h;\n\n\t\tif (w == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tvector<string> left(h), right(h);\n\n\t\tFOR(i, 0, h-1) {\n\t\t\tcin >> left[i] >> right[i];\n\t\t}\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (left[i][j] == 'L') {\n\t\t\t\t\tlx = j;\n\t\t\t\t\tly = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (right[i][j] == 'R') {\n\t\t\t\t\trx = j;\n\t\t\t\t\try = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (left[i][j] == '%') {\n\t\t\t\t\tlgx = j;\n\t\t\t\t\tlgy = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lgx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (right[i][j] == '%') {\n\t\t\t\t\trgx = j;\n\t\t\t\t\trgy = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rgx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdp[ly][lx][ry][rx] = 1;\n\n\t\tnow.lefty = ly;\n\t\tnow.leftx = lx;\n\t\tnow.righty = ry;\n\t\tnow.rightx = rx;\n\t\t\n\t\tque.push(now);\n\n\n\t\twhile (!que.empty()) {\n\t\t\tnow = que.front();\n\t\t\t\n\t\t\tque.pop();\n\t\t\tly = now.lefty;\n\t\t\tlx = now.leftx;\n\t\t\try = now.righty;\n\t\t\trx = now.rightx;\n\t\t\t//cout << ly << \" \" << lx << \" \" << ry << \" \" << rx << endl;\n\n\t\t\tFOR(i, 0, 3) {\n\t\t\t\t\n\t\t\t\tif (ly + dy[i] >= 0 && lx - dx[i] >= 0 && ry + dy[i] <= h - 1 && rx + dx[i] <= w - 1 && ly + dy[i] <= h - 1 && lx - dx[i] <= w - 1 && ry + dy[i] >= 0 && rx + dx[i] >= 0) {\n\t\t\t\t\tif (dp[ly + dy[i]][lx - dx[i]][ry + dy[i]][rx + dx[i]] != 1) {\n\t\t\t\t\t\tif (left[ly + dy[i]][lx - dx[i]] == '#') {\n\t\t\t\t\t\t\tif (right[ry + dy[i]][rx + dx[i]] == '#') {\n\t\t\t\t\t\t\t\t//no\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdp[ly][lx][ry + dy[i]][rx + dx[i]] = 1;\n\t\t\t\t\t\t\t\tnow.lefty = ly;\n\t\t\t\t\t\t\t\tnow.leftx = lx;\n\t\t\t\t\t\t\t\tnow.righty = ry + dy[i];\n\t\t\t\t\t\t\t\tnow.rightx = rx + dx[i];\n\t\t\t\t\t\t\t\tque.push(now);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (right[ry + dy[i]][rx + dx[i]] == '#') {\n\t\t\t\t\t\t\t\tdp[ly + dy[i]][lx - dx[i]][ry][rx] = 1;\n\t\t\t\t\t\t\t\tnow.lefty = ly + dy[i];\n\t\t\t\t\t\t\t\tnow.leftx = lx - dx[i];\n\t\t\t\t\t\t\t\tnow.righty = ry;\n\t\t\t\t\t\t\t\tnow.rightx = rx;\n\t\t\t\t\t\t\t\tque.push(now);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdp[ly + dy[i]][lx - dx[i]][ry + dy[i]][rx + dx[i]] = 1;\n\t\t\t\t\t\t\t\tnow.lefty = ly + dy[i];\n\t\t\t\t\t\t\t\tnow.leftx = lx - dx[i];\n\t\t\t\t\t\t\t\tnow.righty = ry + dy[i];\n\t\t\t\t\t\t\t\tnow.rightx = rx + dx[i];\n\t\t\t\t\t\t\t\tque.push(now);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (dp[lgy][lgx][rgy][rgx] == 1) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t\t\n\n\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// SampleMC1.cpp : ??????????????? ??¢????????±????????§????????¨????????? ?????????????????????????????????\n//\n\n#include \"stdafx.h\"\n#include<iostream>\n#include<queue>\n#include<stack>\n#include<string.h>\nusing namespace std;\n#define REP(i, a, n) for(int i=a; i<n; i++)\n\nbool hist[51][51][51][51];\n\nstruct State {\n\tint xL, yL, xR, yR;\n};\n\nint main() {\n\tint w, h;\n\n\tint dx[4] = { 0, 1, 0, -1 }; // ????????????\n\tint dy[4] = { -1, 0, 1, 0 };\n\n\twhile (cin >> w >> h, w || h) {\n\t\tState st;\n\t\tchar Len[51][51];\n\t\tchar Rin[51][51];\n\t\t//bool hist[51][51][51][51] = { false };\n\t\t//hist[51][51][51][51] = { false };\n\t\tmemset(hist, false, sizeof hist);\n\n\t\t/* crate maze */\n\t\tREP(i, 0, h) {\n\t\t\tREP(j, 0, w) {\n\t\t\t\tcin >> Len[i][j];\n\t\t\t\tif (Len[i][j] == 'L') {\n\t\t\t\t\tst.yL = i;\n\t\t\t\t\tst.xL = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(j, 0, w) {\n\t\t\t\tcin >> Rin[i][j];\n\t\t\t\tif (Rin[i][j] == 'R') {\n\t\t\t\t\tst.yR = i;\n\t\t\t\t\tst.xR = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* BFS */\n\t\tstack<State> stk;\n\t\tstk.push(st);\n\t\t\n\t\thist[st.yL][st.xL][st.yR][st.xR] = true;\n\t\tbool flag = {};\n\n\t\twhile (!stk.empty()) {\n\t\t\t//State q = qu.front();\n\t\t\t//qu.pop();\n\t\t\tState sk = stk.top();\n\t\t\tstk.pop();\n\n\t\t\tint yl = sk.yL, xl = sk.xL, yr = sk.yR, xr = sk.xR;\n\t\t\tif (Len[yl][xl] == '%' && Rin[yr][xr] == '%') {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (Len[yl][xl] == '%' || Rin[yr][xr] == '%') continue;\n\t\t\tfor (int k = 0; k<4; ++k) {\n\t\t\t\tint yyl = yl + dy[k], xxl = xl + dx[k];\n\t\t\t\tint yyr, xxr;\n\t\t\t\tyyr = yr + dy[k];\n\t\t\t\txxr = xr + dx[k] * (-1);\n\n\t\t\t\tif (yyl<0 || yyl >= h || xxl<0 || xxl >= w) {\n\t\t\t\t\tyyl = yl;\n\t\t\t\t\txxl = xl;\n\t\t\t\t}\n\t\t\t\telse if (Len[yyl][xxl] == '#') {\n\t\t\t\t\tyyl = yl;\n\t\t\t\t\txxl = xl;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (yyr<0 || yyr >= h || xxr<0 || xxr >= w) {\n\t\t\t\t\tyyr = yr;\n\t\t\t\t\txxr = xr;\n\t\t\t\t}\n\t\t\t\telse if (Rin[yyr][xxr] == '#') {\n\t\t\t\t\tyyr = yr;\n\t\t\t\t\txxr = xr;\n\t\t\t\t}\n\t\t\t\tif (hist[yyl][xxl][yyr][xxr]) continue;\n\t\t\t\thist[yyl][xxl][yyr][xxr] = true;\n\t\t\t\tstk.push({ yyl, xxl, yyr, xxr });\n\t\t\t\t//cout << yyl << \" \" << xxl << \" \" << yyr << \" \" << xxr << endl;\n\t\t\t}\n\t\t}\n\t\tif (flag) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <stack>\n#include <vector>\nusing namespace std;\n\nstruct Node {\n  Node(int lx, int ly, int rx, int ry) {\n    this->lx = lx;\n    this->ly = ly;\n    this->rx = rx;\n    this->ry = ry;\n  }\n\n  int lx;\n  int ly;\n  int rx;\n  int ry;\n};\n\nint oneval(int lx, int ly, int rx, int ry) {\n  return lx * 1000000000 + ly * 1000000 + rx * 1000 + ry;\n}\n\nint main() {\n  vector<vector<char> > f;\n  f.resize(103);\n  for (int i = 0; i < f.size(); i++) {\n    f[i].resize(52);\n  }\n\n  while (true) {\n    int W, H;\n    cin >> W >> H;\n\n    if (W == 0) {\n      break;\n    }\n\n    int cw = W + 1;\n    int w = W * 2 + 3;\n    int h = H + 2;\n    for (int i = 0; i < w; i++) {\n      f[i][0] = f[i][h - 1] = '#';\n    }\n    for (int i = 0; i < h; i++) {\n      f[0][i] = f[cw][i] = f[w - 1][i] = '#';\n    }\n\n    int lx = 0, ly = 0;\n    int rx = 0, ry = 0;\n    for (int i = 1; i < h - 1; i++) {\n      for (int j = 1; j < cw; j++) {\n\tcin >> f[j][i];\n\tif (f[j][i] == 'L') {\n\t  lx = j;\n\t  ly = i;\n\t  f[j][i] = '.';\n\t}\n      }\n      for (int j = cw + 1; j < w - 1; j++) {\n\tcin >> f[j][i];\n\tif (f[j][i] == 'R') {\n\t  rx = j;\n\t  ry = i;\n\t  f[j][i] = '.';\n\t}\n      }\n    }\n\n    set<int> s;\n    stack<Node> q;\n    q.push(Node(lx, ly, rx, ry));\n    while (!q.empty()) {\n      Node n = q.top();\n\n      if (f[n.lx][n.ly] == '%' && f[n.rx][n.ry] == '%') {\n\tcout << \"Yes\" << endl;\n\tbreak;\n      }\n      q.pop();\n\n      int val = oneval(n.lx, n.ly, n.rx, n.ry);\n      if (s.count(val) != 0) {\n\tcontinue;\n      }\n      s.insert(val);\n\n      q.push(Node(n.lx, f[n.lx][n.ly - 1] != '#' ? n.ly - 1 : n.ly,\n\t\t  n.rx, f[n.rx][n.ry - 1] != '#' ? n.ry - 1 : n.ry));\n      q.push(Node(f[n.lx - 1][n.ly] != '#' ? n.lx - 1 : n.lx, n.ly,\n\t\t  f[n.rx + 1][n.ry] != '#' ? n.rx + 1 : n.rx, n.ry));\n      q.push(Node(f[n.lx + 1][n.ly] != '#' ? n.lx + 1 : n.lx, n.ly,\n\t\t  f[n.rx - 1][n.ry] != '#' ? n.rx - 1 : n.rx, n.ry));\n      q.push(Node(n.lx, f[n.lx][n.ly + 1] != '#' ? n.ly + 1 : n.ly,\n\t\t  n.rx, f[n.rx][n.ry + 1] != '#' ? n.ry + 1 : n.ry));\n    }\n\n    if (q.empty()) {\n      cout << \"No\" << endl;\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n\nusing namespace std;\n\nint ldx[] = {1,0,-1,0}, ldy[] = {0,1,0,-1};\nint rdx[] = {-1,0,1,0}, rdy[] = {0,1,0,-1};\n\nint H, W;\nstring rooml[55], roomr[55];\nbool flag;\n\nbool ls[55][55][55][55];\n\nvoid dfs(int lx, int ly, int rx, int ry){\n\t//cout<<lx<<\" \"<<ly<<\": \"<<rx<<\" \"<<ry<<endl;\n\tif(flag) return;\n\n\tif(rooml[ly][lx] == '%' && roomr[ry][rx] == '%') {\n\t\tflag = true;\n\t\treturn;\n\t}else if(rooml[ly][lx] == '%' || roomr[ry][rx] == '%') return;\n\n\tif(ls[lx][ly][rx][ry]) return;\n\tls[lx][ly][rx][ry] = true;\n\n\tREP(k,0,4){\n\t\tint nlx = lx + ldx[k], nly = ly + ldy[k];\n\t\tif(!CH(nly,0,H) || !CH(nlx,0,W)){\n\t\t\tnlx = lx;\n\t\t\tnly = ly;\n\t\t}else if(rooml[nly][nlx]=='#'){\n\t\t\tnlx = lx;\n\t\t\tnly = ly;\n\t\t}\n\n\t\tint nrx = rx + rdx[k], nry = ry + rdy[k];\n\t\tif(!CH(nry,0,H) || !CH(nrx,0,W)){\n\t\t\tnrx = rx;\n\t\t\tnry = ry;\n\t\t}else if(roomr[nry][nrx]=='#'){\n\t\t\tnrx = rx;\n\t\t\tnry = ry;\n\t\t}\n\t\tdfs(nlx, nly, nrx, nry);\n\t}\n\treturn;\n}\n\nint main() {\n\n\twhile(1){\n\t\tcin>>W>>H;\n\t\tif(W==0 && H==0) break;\n\t\tREP(i,0,H){\n\t\t\tcin>>rooml[i]>>roomr[i];\n\t\t}\n\n\t\tint slx, sly, srx, sry;\n\t\tREP(i,0,H){\n\t\t\tREP(j,0,W){\n\t\t\t\tif(rooml[i][j] == 'L'){\n\t\t\t\t\tslx = j;\n\t\t\t\t\tsly = i;\n\t\t\t\t}\n\t\t\t\tif(roomr[i][j] == 'R'){\n\t\t\t\t\tsrx = j;\n\t\t\t\t\tsry = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tflag = false;\n\t\tREP(i,0,55)REP(j,0,55)REP(k,0,55)REP(l,0,55) ls[i][j][k][l] = false;\n\t\tdfs(slx, sly, srx, sry);\n\n\t\tif(flag) cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\ntypedef vector<vvi> vvvi;\n\nint ldx[] = {0, 1, 0, -1};\nint rdx[] = {0, -1, 0, 1};\nint dy[] = {-1, 0, 1, 0};\n\nstruct state {\n\tpii l, r;\n\tstate(pii l, pii r) : l(l), r(r) {};\n};\n\nint main() {\n\tint W, H;\n\twhile(cin >> W >> H, W) {\n\t\tvs roomL(H), roomR(H);\n\t\tint lsx, lsy, rsx, rsy;\n\t\tREP(i, H) {\n\t\t\tcin >> roomL[i] >> roomR[i];\n\t\t\tif(roomL[i].find(\"L\") != string::npos) {\n\t\t\t\tlsx = roomL[i].find(\"L\");\n\t\t\t\tlsy = i;\n\t\t\t}\n\t\t\tif(roomR[i].find(\"R\") != string::npos) {\n\t\t\t\trsx = roomR[i].find(\"R\");\n\t\t\t\trsy = i;\n\t\t\t}\n\t\t}\n\n\t\tvector<vvvi> visited(H, vvvi(W, vvi(H, vi(W))));\n\t\tqueue<state> Q;\n\t\tQ.push(state(make_pair(lsy, lsx), make_pair(rsy, rsx)));\n\t\tvisited[lsy][lsx][rsy][rsx] = 1;\n\t\tbool goal = false;\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.front();\n\t\t\tQ.pop();\n\n\t\t\tif(roomL[st.l.first][st.l.second] == '%' && roomR[st.r.first][st.r.second] == '%') {\n\t\t\t\tgoal = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(roomL[st.l.first][st.l.second] == '%' || roomR[st.r.first][st.r.second] == '%') {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tREP(d, 4) {\n\t\t\t\tint lny = st.l.first + dy[d];\n\t\t\t\tint lnx = st.l.second + ldx[d];\n\t\t\t\tif(lny < 0 || H <= lny || lnx < 0 || W <= lnx || roomL[lny][lnx] == '#') {\n\t\t\t\t\tlny = st.l.first;\n\t\t\t\t\tlnx = st.l.second;\n\t\t\t\t}\n\t\t\t\tint rny = st.r.first + dy[d];\n\t\t\t\tint rnx = st.r.second + rdx[d];\n\t\t\t\tif(rny < 0 || H <= rny || rnx < 0 || W <= rnx || roomR[rny][rnx] == '#') {\n\t\t\t\t\trny = st.r.first;\n\t\t\t\t\trnx = st.r.second;\n\t\t\t\t}\n\n\t\t\t\tif(!visited[lny][lnx][rny][rnx]) {\n\t\t\t\t\tvisited[lny][lnx][rny][rnx] = 1;\n\t\t\t\t\tQ.push(state(make_pair(lny, lnx), make_pair(rny, rnx)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << (goal ? \"Yes\" : \"No\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\n\n\nint w,h;\nchar L[53][53], R[53][53];\nint memo[52][52][52][52];\nstruct state{\n\tint lx,ly,rx,ry;\n};\nint dl[4][2]={{0,1},{1,0},{-1,0},{0,-1}};\nint dr[4][2]={{0,-1},{1,0},{-1,0},{0,1}};\nbool dfs(state s){\n\tif(memo[s.ly][s.lx][s.ry][s.rx]) return false;\n\tif(L[s.ly][s.lx]=='%' && R[s.ry][s.rx]=='%') return true;\n\tif(L[s.ly][s.lx]=='%' || R[s.ry][s.rx]=='%') return false;\n\tif(L[s.ly][s.lx]=='#' || R[s.ry][s.rx]=='#') return false;\n\tmemo[s.ly][s.lx][s.ry][s.rx] = 1;\n\tfor(int i=0;i<4;i++){\n\t\tstate t = s;\n\t\tif(L[t.ly+dl[i][0]][t.lx+dl[i][1]] != '#'){\n\t\t\tt.ly += dl[i][0];\n\t\t\tt.lx += dl[i][1];\n\t\t}\n\t\tif(R[t.ry+dr[i][0]][t.rx+dr[i][1]] != '#'){\n\t\t\tt.ry += dr[i][0];\n\t\t\tt.rx += dr[i][1];\n\t\t}\n\t\tif(dfs(t)) return true;\n\t}\n\tL[s.ly][s.lx] = '.';\n\tR[s.ry][s.rx] = '.';\n\treturn false;\n}\n\nmain(){\n\tint i,j;\n\twhile(cin >> w >> h, w){\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tfor(i=0;i<53;i++)for(j=0;j<53;j++)L[i][j]=R[i][j]='#';\n\t\tint ans;\n\t\tstate s;\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tcin >> L[i][j];\n\t\t\t\tif(L[i][j] == 'L'){\n\t\t\t\t\ts.lx=j;s.ly=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tcin >> R[i][j];\n\t\t\t\tif(R[i][j] == 'R'){\n\t\t\t\t\ts.rx=j;s.ry=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (dfs(s)?\"Yes\":\"No\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nint w, h;\nint sly, slx, sry, srx;\nstring s[1000];\nstring t[1000];\nbool f[60][60][60][60];\n\nint dx[] = { 0,1,0,-1 };\nint dy[] = { 1,0,-1,0 };\n\nbool is_area(int y, int x) {\n\treturn y >= 0 && y < h&&x >= 0 && x < w;\n}\n\nbool solve() {\n\tbool res = false;\n\tqueue<pair<P, P>> que;\n\tque.push({ { sly,slx },{ sry,srx } });\n\twhile (!que.empty()) {\n\t\tpair<P, P> pp = que.front();\n\t\tque.pop();\n\t\tll ly = pp.first.first, lx = pp.first.second,\n\t\t\try = pp.second.first, rx = pp.second.second;\n\t\tif (f[ly][lx][ry][rx])continue;\n\t\tf[ly][lx][ry][rx] = 1;\n\t\trep(i, 4) {\n\t\t\tll nly = min((ll)h, max((ll)0, ly + dy[i])),\n\t\t\t\tnry = min((ll)h, max((ll)0, ry + dy[i])),\n\t\t\t\tnlx = min((ll)w, max((ll)0, lx + dx[i])),\n\t\t\t\tnrx = min((ll)w, max((ll)0, rx + dx[i]));\n\t\t\tif (is_area(nly, nlx) && is_area(nry, nrx)) {\n\t\t\t\tif (s[nly][nlx] != t[nry][nrx]) {\n\t\t\t\t\tif (s[nly][nlx] == '%' || t[nry][nrx] == '%')continue;\n\t\t\t\t\tif (s[nly][nlx] == '#') {\n\t\t\t\t\t\tif (!f[ly][lx][nry][nrx]) {\n\t\t\t\t\t\t\tque.push({ { ly, lx },{ nry, nrx } });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (t[nry][nrx] == '#') {\n\t\t\t\t\t\tif (!f[nly][nlx][ry][rx]) {\n\t\t\t\t\t\t\tque.push({ { nly, nlx },{ ry, rx } });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (s[nly][nlx] == '%')res = true;\n\t\t\t\t\telse if (s[nly][nlx] == '.') {\n\t\t\t\t\t\tif (!f[nly][nlx][nry][nrx]) {\n\t\t\t\t\t\t\tque.push({ { nly, nlx },{ nry, nrx } });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\twhile (cin >> w >> h&&w + h) {\n\t\trep(i, 60)rep(j, 60)rep(k, 60)rep(l, 60) {\n\t\t\tf[i][j][k][l] = 0;\n\t\t}\n\t\trep(i, h) {\n\t\t\tcin >> s[i] >> t[i];\n\t\t\treverse(ALL(t[i]));\n\t\t}\n\t\trep(i, h) {\n\t\t\trep(j, w) {\n\t\t\t\tif (s[i][j] == 'L') {\n\t\t\t\t\tsly = i, slx = j;\n\t\t\t\t\ts[i][j] = '.';\n\t\t\t\t}\n\t\t\t\tif (t[i][j] == 'R') {\n\t\t\t\t\tsry = i, srx = j;\n\t\t\t\t\tt[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (solve())cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define int long long\n#define FOR(i, m, n) for (int i = (m); i < (n); i++)\n#define all(x) x.begin(), x.end()\nusing pii = pair<int, int>;\n\nchar A[55][55], B[55][55];\nbool vis[55][55][55][55];\nconstexpr int dx[4] = {0, 0, -1, 1}, dy[4] = {1, -1, 0, 0};\nbool solve() {\n    int W, H;\n    cin >> W >> H;\n    if (W == 0) return false;\n    int sxa, sya, sxb, syb, gxa, gya, gxb, gyb;\n    REP(i, H) {\n        REP(j, W) {\n            cin >> A[i][j];\n            if (A[i][j] == 'L') {\n                sxa = i;\n                sya = j;\n            }\n            if (A[i][j] == '%') {\n                gxa = i;\n                gya = j;\n            }\n        }\n        REP(j, W) {\n            cin >> B[i][j];\n            if (B[i][j] == 'R') {\n                sxb = i, syb = j;\n            }\n            if (B[i][j] == '%') {\n                gxb = i, gyb = j;\n            }\n        }\n    }\n    REP(ia, H) REP(ja, W) REP(ib, H) REP(jb, W) { vis[ia][ja][ib][jb] = false; }\n    using arr4 = array<int, 4>;\n    queue<arr4> que;\n    que.push({sxa, sya, sxb, syb});\n    while (!que.empty()) {\n        arr4 arr = que.front();\n        que.pop();\n        int i = arr[0], j = arr[1], x = arr[2], y = arr[3];\n        vis[i][j][x][y] = true;\n        // Aが動く\n        REP(k, 4) {\n            int ni = i + dx[k], nj = j + dy[k];\n            int nx = x + dx[k], ny = y - dy[k];\n            if (ni < 0 || ni >= H || nj < 0 || nj >= W || A[ni][nj] == '#') continue;\n            if (nx < 0 || nx >= H || ny < 0 || ny >= W || B[nx][ny] == '#') {\n                nx = x, ny = y;\n            }\n            if ((A[ni][nj] == '%' && B[nx][ny] != '%') || (A[ni][nj] != '%' && B[nx][ny] == '%')) continue;\n            if (vis[ni][nj][nx][ny]) continue;\n            vis[ni][nj][nx][ny] = true;\n            que.push({ni, nj, nx, ny});\n        }\n\n        // Bが動く\n        REP(k, 4) {\n            int ni = i + dx[k], nj = j + dy[k];\n            int nx = x + dx[k], ny = y - dy[k];\n            if (ni < 0 || ni >= H || nj < 0 || nj >= W || A[ni][nj] == '#') {\n                ni = i, nj = j;\n            };\n            if (nx < 0 || nx >= H || ny < 0 || ny >= W || B[nx][ny] == '#') continue;\n            if ((A[ni][nj] == '%' && B[nx][ny] != '%') || (A[ni][nj] != '%' && B[nx][ny] == '%')) continue;\n            if (vis[ni][nj][nx][ny]) continue;\n            vis[ni][nj][nx][ny] = true;\n            que.push({ni, nj, nx, ny});\n        }\n    }\n    if (vis[gxa][gya][gxb][gyb])\n        cout << \"Yes\" << endl;\n    else\n        cout << \"No\" << endl;\n    return true;\n}\n\nsigned main() {\n    while (solve())\n        ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n\n\nusing namespace std;\n\nchar fieldL[51][51];\nchar fieldR[51][51];\nbool checked[51][51][51][51];\n\nint w, h;\n\nbool dfs(int ly, int lx, int ry, int rx) {\n  if (fieldL[ly][lx] == fieldR[ry][rx] && fieldL[ly][lx] == '%') {\n    return true;\n  }\n  if (checked[ly][lx][ry][rx]) {\n    return false;\n  }\n  \n  checked[ly][lx][ry][rx] = true;\n\n  int dyL[] = { -1, 0, 1, 0 };\n  int dxL[] = { 0, 1, 0, -1 };\n  int dyR[] = { -1, 0, 1, 0 };\n  int dxR[] = { 0, -1, 0, 1 };\n\n\n  bool ret = false;\n  for (int i = 0; i < 4; i++) {\n    int nly = ly + dyL[i];\n    int nlx = lx + dxL[i];\n    int nry = ry + dyR[i];\n    int nrx = rx + dxR[i];\n    if (nly < 0) nly = 0;\n    if (nly >= h) nly = h - 1;\n    if (nlx < 0) nlx = 0;\n    if (nlx >= w) nlx = w - 1;\n    if (nry < 0) nry = 0;\n    if (nry >= h) nry = h - 1;\n    if (nrx < 0) nrx = 0;\n    if (nrx >= w) nrx = w - 1;\n    if (fieldL[nly][nlx] == '#') {\n      nly = ly; nlx = lx;\n    }\n    if (fieldR[nry][nrx] == '#') {\n      nry = ry; nrx = rx;\n    }\n    ret |= dfs(nly, nlx, nry, nrx);\n  }\n\n  return ret;\n}\n\nint main() {\n  while (true) {\n    cin >> w >> h;\n    if (w + h == 0) {\n      break;\n    }\n    int ly, lx, ry, rx;\n    for (int i = 0; i < h; i++) {\n      string strL, strR;\n      cin >> strL >> strR;\n      for (int j = 0; j < w; j++) {\n        fieldL[i][j] = strL[j];\n        fieldR[i][j] = strR[j];\n        if (strL[j] == 'L') {\n          ly = i; lx = j;\n        }\n        if (strR[j] == 'R') {\n          ry = i; rx = j;\n        }\n      }\n    }\n\n    memset(checked, false, sizeof(checked));\n\n    if (dfs(ly, lx, ry, rx)) {\n      cout << \"Yes\" << endl;\n    } else {\n      cout << \"No\" << endl;\n    }\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nconst int N = 52;\nchar l[N][N], r[N][N];\nint dp[N][N][N][N];\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (int W, H; cin >> W >> H&&H;) {\n\t\tmemset(l, 0, sizeof(l));\n\t\tmemset(r, 0, sizeof(r));\n\t\tmemset(dp, 0x3f, sizeof(dp));\n\t\tint sli, slj, sri, srj;\n\t\tint gli, glj, gri, grj;\n\t\trep(i, 0, H) {\n\t\t\trrep(j, 0, W) {\n\t\t\t\tcin >> l[i][j];\n\t\t\t\tif (l[i][j] == 'L') {\n\t\t\t\t\tsli = i, slj = j;\n\t\t\t\t}\n\t\t\t\tif (l[i][j] == '%') {\n\t\t\t\t\tgli = i, glj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j, 0, W) {\n\t\t\t\tcin >> r[i][j];\n\t\t\t\tif (r[i][j] == 'R') {\n\t\t\t\t\tsri = i, srj = j;\n\t\t\t\t}\n\t\t\t\tif (r[i][j] == '%') {\n\t\t\t\t\tgri = i, grj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tusing T = tuple<int, int, int, int, int>;\n\t\tqueue<T> q;\n\t\tq.emplace(sli, slj, sri, srj, 0);\n\t\tauto inrange = [&](int i, int j) { return i >= 0 && i < H && j >= 0 && j < W; };\n\t\twhile (q.size()) {\n\t\t\tint li, lj, ri, rj, c;\n\t\t\ttie(li, lj, ri, rj, c) = q.front(); q.pop();\n\t\t\tif (dp[li][lj][ri][rj] != INF)continue;\n\t\t\tif (li == gli && lj == glj && ri == gri && rj == grj) {\n\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\tdp[li][lj][ri][rj] = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (li == gli&&lj == glj) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (ri == gri&&rj == grj) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdp[li][lj][ri][rj] = c;\n\t\t\tstatic const int di[] = { 1,0,-1,0 };\n\t\t\tstatic const int dj[] = { 0,1,0,-1 };\n\t\t\trep(k, 0, 4) {\n\t\t\t\tint nli = li + di[k],\n\t\t\t\t\tnlj = lj + dj[k],\n\t\t\t\t\tnri = ri + di[k],\n\t\t\t\t\tnrj = rj + dj[k];\n\t\t\t\tif (!inrange(nli, nlj) || l[nli][nlj] == '#')nli -= di[k], nlj -= dj[k];\n\t\t\t\tif (!inrange(nri, nrj) || r[nri][nrj] == '#')nri -= di[k], nrj -= dj[k];\n\t\t\t\tif (dp[nli][nlj][nri][nrj] != INF)continue;\n\t\t\t\tq.emplace(nli, nlj, nri, nrj, c + 1);\n\t\t\t}\n\t\t}\n\t\t//rep(li, 0, H)rep(lj, 0, W)rep(ri, 0, H)rep(rj, 0, W) {\n\t\t//\tif (dp[li][lj][ri][rj] == INF)continue;\n\t\t//\tdump(li, lj, ri, rj, dp[li][lj][ri][rj]);\n\t\t//}\n\t\tif (dp[gli][glj][gri][grj] == INF) {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cmath>\nusing namespace std;\n\nchar L[52][52], R[52][52];\nint W, H, sx1, sy1, sx2, sy2, gx1, gy1, gx2, gy2;\nint dx1[4] = { 0, 0,+1,-1};\nint dy1[4] = {-1,+1, 0, 0};\nint dx2[4] = { 0, 0,-1,+1};\nint dy2[4] = {-1,+1, 0, 0};\nbool memo[52][52][52][52];\n\nstruct State{\n\tint x1, y1, x2, y2;\n\tState(int x1_, int y1_, int x2_, int y2_){\n\t\tx1 = x1_; y1 = y1_; x2 = x2_; y2 = y2_;\n\t}\n};\n\nvoid debug(int x1, int y1, int x2, int y2){\n\tcout << \"[left]\" << endl;\n\tfor(int y=0 ; y < H ; y++ ){\n\t\tfor(int x=0 ; x < W ; x++ ){\n\t\t\tif( x == x1 && y == y1 ){\n\t\t\t\tcout << \"L\";\n\t\t\t}else{\n\t\t\t\tcout << L[y][x];\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << \"[right]\" << endl;\n\tfor(int y=0 ; y < H ; y++ ){\n\t\tfor(int x=0 ; x < W ; x++ ){\n\t\t\tif( x == x2 && y == y2 ){\n\t\t\t\tcout << \"R\";\n\t\t\t}else{\n\t\t\t\tcout << R[y][x];\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\nbool bfs(){\n\tfor(int a=0 ; a < 52 ; a++ )\n\t\tfor(int b=0 ; b < 52 ; b++ )\n\t\t\tfor(int c=0 ; c < 52 ; c++ )\n\t\t\t\tfor(int d=0 ; d < 52 ; d++ )\n\t\t\t\t\tmemo[a][b][c][d] = false;\n\tqueue<State> q;\n\tq.push( State(sx1, sy1, sx2, sy2) );\n\t\n\twhile( !q.empty() ){\n\t\tint x1 = q.front().x1, y1 = q.front().y1, x2 = q.front().x2, y2 = q.front().y2;\n\t\tq.pop();\n\t\t\n\t\tif( memo[x1][y1][x2][y2] ) continue;\n\t\tmemo[x1][y1][x2][y2] = true;\n\t\t\n\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\tint mx1 = x1 + dx1[i], my1 = y1 + dy1[i];\n\t\t\tint mx2 = x2 + dx2[i], my2 = y2 + dy2[i];\n\t\t\tif( mx1 < 0 || my1 < 0 || W <= mx1 || H <= my1 || L[my1][mx1] == '#' ){\n\t\t\t\tmx1 = x1; my1 = y1;\n\t\t\t}\n\t\t\tif( mx2 < 0 || my2 < 0 || W <= mx2 || H <= my2 || R[my2][mx2] == '#' ){\n\t\t\t\tmx2 = x2; my2 = y2;\n\t\t\t}\n\t\t\tif( mx1 == gx1 && my1 == gy1 && mx2 == gx2 && my2 == gy2 ){\n\t\t\t\treturn true;\n\t\t\t}else if( mx1 == gx1 && my1 == gy1 ){\n\t\t\t}else if( mx2 == gx2 && my2 == gy2 ){\n\t\t\t}else{\n\t\t\t\tif( !memo[mx1][my1][mx2][my2] ){\n\t\t\t\t\tq.push( State(mx1, my1, mx2, my2) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\twhile( cin >> W >> H , W || H ){\n\t\tfor(int y=0 ; y < H ; y++ ){\n\t\t\tcin >> L[y] >> R[y];\n\t\t}\n\t\tfor(int y=0 ; y < H ; y++ ){\n\t\t\tfor(int x=0 ; x < W ; x++ ){\n\t\t\t\tif( L[y][x] == 'L' ){\n\t\t\t\t\tsx1 = x; sy1 = y; L[y][x] = '.';\n\t\t\t\t}\n\t\t\t\tif( R[y][x] == 'R' ){\n\t\t\t\t\tsx2 = x; sy2 = y; R[y][x] = '.';\n\t\t\t\t}\n\t\t\t\tif( L[y][x] == '%' ){\n\t\t\t\t\tgx1 = x; gy1 = y; L[y][x] = '.';\n\t\t\t\t}\n\t\t\t\tif( R[y][x] == '%' ){\n\t\t\t\t\tgx2 = x; gy2 = y; R[y][x] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (bfs()? \"Yes\" : \"No\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#include<queue>\n#define MAX 50\nusing namespace std;\nstruct Point{int x,y;};\nstruct P{\n  Point l,r;\n  int cost;\n  bool operator<(const P &a)const{\n    return (l.x==a.l.x?\n\t    (l.y==a.l.y?\n\t     (r.x==a.r.x?\n\t      (r.y<a.r.y):r.x<a.r.x)\n\t     :l.y<a.l.y)\n\t    :l.x<a.l.x);\n  }\n};\nint main(){\n  int w,h;\n  while(cin>>w>>h,w||h){\n    int i,j,k;\n    int inf = 1<<20;\n    /*\n    int d[MAX+1][MAX+1][MAX+1][MAX+1];\n    fill(d[0][0][0],d[MAX][MAX][MAX],inf);\n    */\n    map<P,int> m;\n    string sr[60],sl[60];\n    for(i=0;i<h;i++){\n      cin >> sl[i] >> sr[i];\n    }\n    \n    Point pr,pl,br,bl;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(sl[i][j]=='L'){\n\t  pl.x=j;pl.y=i;\n\t}\n\tif(sr[i][j]=='R'){\n\t  pr.x=j;pr.y=i;\n\t}\n      }\n    }\n    //cout << pl.x << \":\" << pl.y << endl;\n    //cout << pr.x << \":\" << pr.y << endl;\n    //d[pl.x][pl.y][pr.x][pr.y]=0\n    P p,b;\n    p.r=pr;\n    p.l=pl;\n    p.cost=0;\n    m[p]=p.cost;\n    queue<P> q;\n    q.push(p);\n    bool f = false;\n    while(!q.empty()){\n      p=q.front();q.pop();\n      pl=p.l;pr=p.r;\n      if(m.find(p)!=m.end())\n\tif(p.cost>m[p]) continue;\n      m[p]=p.cost;\n      //cout << pl.x<<\":\"<<pl.y<<\":\"<<pr.x<<\":\"<<pr.y<<\"/\"<<p.cost<<endl;\n      if(sl[pl.y][pl.x]=='%'&&sr[pr.y][pr.x]=='%'){\n\tf=true;\n\tbreak;\n      }else if(sl[pl.y][pl.x]=='%') continue;\n      else if(sr[pr.y][pr.x]=='%') continue;\n      \n      p.cost++;\n      int lx[]={1,-1,0,0};int ly[]={0,0,1,-1};\n      int rx[]={-1,1,0,0};int ry[]={0,0,1,-1};\n      for(i=0;i<4;i++){\n\tbl=pl;br=pr;\n\tbl.x+=lx[i];bl.y+=ly[i];\n\tbr.x+=rx[i];br.y+=ry[i];\n\n\t//cout << bl.x<<\":\"<<bl.y<<\":\"<<br.x<<\":\"<<br.y<<\"/\"<<p.cost<<endl;\n\t\n\tif(bl.x<0) bl.x=0;\n\telse if(bl.x>=w) bl.x=w-1;\n\tif(bl.y<0) bl.y=0;\n\telse if(bl.y>=h) bl.y=h-1;\n\n\tif(br.x<0) br.x=0;\n\telse if(br.x>=w) br.x=w-1;\n\tif(br.y<0) br.y=0;\n\telse if(br.y>=h) br.y=h-1;\n\n\tif(sl[bl.y][bl.x]=='#'){\n\t  bl.x-=lx[i];bl.y-=ly[i];\n\t}\n\tif(sr[br.y][br.x]=='#'){\n\t  br.x-=rx[i];br.y-=ry[i];\n\t}\n\tp.r=br;p.l=bl;\n\tq.push(p);\n\t//m[p]=p.cost;\n      }\n    }\n    if(f) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nint main() {\n\tint W, H;\n\twhile (cin >> W >> H, W | H){\n\t\tvector<string> vsl;\n\t\tvector<string> vsr;\n\t\tREP(i, H){\n\t\t\tstring l;\n\t\t\tstring r;\n\t\t\tcin >> l >> r;\n\t\t\tvsl.push_back(l);\n\t\t\tvsr.push_back(r);\n\t\t}\n\t\tint glx;\n\t\tint gly;\n\t\tint grx;\n\t\tint gry;\n\t\tint lx;\n\t\tint ly;\n\t\tint rx;\n\t\tint ry;\n\t\tREP(i, H){\n\t\t\tREP(j, W){\n\t\t\t\tif (vsl[i][j] == 'L'){\n\t\t\t\t\tlx = j;\n\t\t\t\t\tly = i;\n\t\t\t\t}\n\t\t\t\tif (vsr[i][j] == 'R'){\n\t\t\t\t\trx = j;\n\t\t\t\t\try = i;\n\t\t\t\t}\n\t\t\t\tif (vsl[i][j] == '%'){\n\t\t\t\t\tglx = j;\n\t\t\t\t\tgly = i;\n\t\t\t\t}\n\t\t\t\tif (vsr[i][j] == '%'){\n\t\t\t\t\tgrx = j;\n\t\t\t\t\tgry = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<int> vi;\n\t\tvi.push_back(lx * 1000000 + ly * 10000 + rx * 100 + ry);\n\t\tint count = 0;\n\t\tint pcount = 1;\n\t\tbool clear = false;\n\t\twhile(1){\n\t\t\tif (vi[count] == glx * 1000000 + gly * 10000 + grx * 100 + gry){\n\t\t\t\tclear = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint lx2 = vi[count] / 1000000 % 100;\n\t\t\tint ly2 = vi[count] / 10000 % 100;\n\t\t\tint rx2 = vi[count] / 100 % 100;\n\t\t\tint ry2 = vi[count] % 100;\n\n\t\t\tREP(i, 4){\n\t\t\t\tint lx3 = lx2;\n\t\t\t\tint ly3 = ly2;\n\t\t\t\tint rx3 = rx2;\n\t\t\t\tint ry3 = ry2;\n\t\t\t\tif (dx[i] != 0 && lx3 + dx[i] >= 0 && lx3 + dx[i] < W && vsl[ly3 + dy[i]][lx3 + dx[i]] != '#')lx3 += dx[i];\n\t\t\t\tif (dy[i] != 0 && ly3 + dy[i] >= 0 && ly3 + dy[i] < H && vsl[ly3 + dy[i]][lx3 + dx[i]] != '#')ly3 += dy[i];\n\t\t\t\tif (dx[i] != 0 && rx3 - dx[i] >= 0 && rx3 - dx[i] < W && vsr[ry3 + dy[i]][rx3 - dx[i]] != '#')rx3 -= dx[i];\n\t\t\t\tif (dy[i] != 0 && ry3 + dy[i] >= 0 && ry3 + dy[i] < H && vsr[ry3 + dy[i]][rx3 - dx[i]] != '#')ry3 += dy[i];\n\t\t\t\tif (find(vi.begin(), vi.end(), lx3 * 1000000 + ly3 * 10000 + rx3 * 100 + ry3) == vi.end())vi.push_back(lx3 * 1000000 + ly3 * 10000 + rx3 * 100 + ry3);\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (count == vi.size())break;\n\t\t\t\n\t\t}\n\n\t\tif (clear)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct XY {\n\tint x, y;\n\tXY() {}\n\tXY(int x, int y) : x(x), y(y) {}\n};\n\nusing P = pair<XY, XY>;\n\nbool operator<(const XY& l, const XY& r) {\n\treturn l.x < r.x || (l.x == r.x && l.y < r.y);\n}\n\nint dx[] = { 1, 0, -1, 0 };\nint dy[] = { 0, 1, 0, -1 };\n\nint W, H;\nbool isIn(const XY& p) {\n\treturn p.x >= 0 && p.x < H && p.y >= 0 && p.y < W;\n}\n\nint main()\n{\n\twhile (cin >> W >> H, W | H) {\n\t\tvector<string> Rl(H), Rr(H);\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tcin >> Rl[i] >> Rr[i];\n\t\t}\n\t\tP s, g;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (Rl[i][j] == 'L') {\n\t\t\t\t\ts.first.x = i;\n\t\t\t\t\ts.first.y = j;\n\t\t\t\t}\n\t\t\t\telse if (Rl[i][j] == '%') {\n\t\t\t\t\tg.first.x = i;\n\t\t\t\t\tg.first.y = j;\n\t\t\t\t}\n\t\t\t\tif (Rr[i][j] == 'R') {\n\t\t\t\t\ts.second.x = i;\n\t\t\t\t\ts.second.y = j;\n\t\t\t\t}\n\t\t\t\telse if (Rr[i][j] == '%') {\n\t\t\t\t\tg.second.x = i;\n\t\t\t\t\tg.second.y = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool flag = true;\n\t\tset<P> se; se.insert(s);\n\t\twhile (flag) {\n\t\t\tflag = false;\n\t\t\tauto tmp = se;\n\t\t\tfor (auto p : tmp) {\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tXY tl = p.first, tr = p.second;\n\t\t\t\t\ttl.x += dx[i]; tl.y -= dy[i]; tr.x += dx[i]; tr.y += dy[i];\n\t\t\t\t\tbool f1 = isIn(tl) && Rl[tl.x][tl.y] != '#';\n\t\t\t\t\tbool f2 = isIn(tr) && Rr[tr.x][tr.y] != '#';\n\t\t\t\t\tif (f1 && f2) {\n\t\t\t\t\t\tif ((Rl[tl.x][tl.y] == '%') == (Rr[tr.x][tr.y] == '%')) {\n\t\t\t\t\t\t\tif (!se.count(P(tl, tr))) {\n\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\tse.insert(P(tl, tr));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (f1) {\n\t\t\t\t\t\tif ((Rl[tl.x][tl.y] == '%') == (Rr[p.second.x][p.second.y] == '%')) {\n\t\t\t\t\t\t\tif (!se.count(P(tl, p.second))) {\n\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\tse.insert(P(tl, p.second));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (f2) {\n\t\t\t\t\t\tif ((Rl[p.first.x][p.first.y] == '%') == (Rr[tr.x][tr.y] == '%')) {\n\t\t\t\t\t\t\tif (!se.count(P(p.first, tr))) {\n\t\t\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\t\t\tse.insert(P(p.first, tr));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (se.count(g) ? \"Yes\" : \"No\") << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint const dxL[] = {-1,0,1,0};\nint const dxR[] = {1,0,-1,0};\nint const dy[]  = {0,-1,0,1};\ntypedef pair<int, int> Pii;\n#define X first\n#define Y second\nint const INF = 1<<28;\nint W, H;\nchar grL[51][51], grR[51][51];\nbool used[2500][2500];\ninline bool isValid(int x, int y) {\n  if(0<=x&&x<W && 0<=y&&y<H) return true;\n  return false;\n}\n\ninline bool inF(int x, int y, int isL) {\n  if(isL) return grL[y][x]!='#';\n  return grR[y][x]!='#';\n}\ninline int toNode(int x, int y) {\n  return y*W+x;\n}\ninline void toPos(int node, int &x, int &y) {\n  x = node%W, y = node/W;\n}\nint main() {\n  \n  while(cin >> W >> H && (W|H)) {\n    int sxL, syL, sxR, syR;\n    int gxL, gyL, gxR, gyR;\n    for(int i=0; i<H; i++) {\n      for(int j=0; j<2*W; j++) {\n        if(j<W) {\n          cin >> grL[i][j];\n          if(grL[i][j] == 'L') {\n            sxL = j, syL = i;\n          }\n          if(grL[i][j] == '%') {\n            gxL = j, gyL = i;\n          }\n        }\n        else {\n          cin >> grR[i][j-W];\n          if(grR[i][j-W] == 'R') {\n            sxR = j-W, syR = i;\n          }\n          if(grR[i][j-W] == '%') {\n            gxR = j-W, gyR = i;\n          }\n        }\n      }\n    }\n    \n    queue<Pii> que;\n    que.push(make_pair(toNode(sxL, syL), toNode(sxR, syR)));\n    bool ok = false;\n    memset(used, false, sizeof used);\n    while(!que.empty()) {\n      const int nowL = que.front().first;\n      const int nowR = que.front().second; que.pop();\n      int lx, ly; toPos(nowL, lx, ly);\n      int rx, ry; toPos(nowR, rx, ry);\n\n      if(lx == gxL && ly == gyL && rx == gxR && ry == gyR) {\n        ok = true; break;\n      }\n      \n      if(lx == gxL && ly == gyL) continue;\n      if(rx == gxR && ry == gyR) continue;\n      \n      for(int i=0; i<4; i++) {\n        int nxL = lx+dxL[i], nyL = ly+dy[i];\n        int nxR = rx+dxR[i], nyR = ry+dy[i];\n\n        if(!isValid(nxL, nyL) || !inF(nxL, nyL, 1)) { nxL = lx, nyL = ly; }\n        if(!isValid(nxR, nyR) || !inF(nxR, nyR, 0)) { nxR = rx, nyR = ry; }\n        if(used[toNode(nxL, nyL)][toNode(nxR, nyR)]) continue;\n        que.push(make_pair(toNode(nxL, nyL), toNode(nxR, nyR)));\n        used[toNode(nxL, nyL)][toNode(nxR, nyR)] = true;\n      }\n    }\n    if(ok) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RREP(i, n) for(int i=(int)(n)-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=(int)(b)-1;i>=(a);--i)\n#define ALL(a) a.begin(),a.end()\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n    if (a > b) { a = b; return true; }\n    return false;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const map<T1, T2> &mp) {\n    os << \"{\";\n    int a = 0;\n    for (auto &tp : mp) {\n        if (a) os << \", \";\n        a = 1;\n        os << tp;\n    }\n    return os << \"}\";\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n    os << p.first << \":\" << p.second;\n    return os;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    for (;;) {\n        int W, H; cin >> W >> H;\n        if (W == 0) break;\n        vector<string> L(H), R(H);\n        int lsi, lsj, rsi, rsj, lgi, lgj, rgi, rgj;\n        REP(i, H) {\n            cin >> L[i] >> R[i];\n            REP(j, W) {\n                if (L[i][j] == 'L') {\n                    lsi = i, lsj = j;\n                }\n                if (L[i][j] == '%') {\n                    lgi = i, lgj = j;\n                }\n                if (R[i][j] == 'R') {\n                    rsi = i, rsj = j;\n                }\n                if (R[i][j] == '%') {\n                    rgi = i, rgj = j;\n                }\n            }\n        }\n\n        queue<tuple<int,int,int,int>> que;\n        map<tuple<int,int,int,int>,int> used;\n        que.emplace(lsi, lsj, rsi, rsj);\n        used[que.front()] = 1;\n\n        const int dy[] = {1, 0, -1, 0};\n        const int ldx[] = {0, 1, 0, -1};\n        const int rdx[] = {0, -1, 0, 1};\n\n        int ans = 0;\n        while (!que.empty()) {\n            int li, lj, ri, rj;\n            tie(li, lj, ri, rj) = que.front(); que.pop();\n            int gl = li == lgi and lj == lgj;\n            int gr = ri == rgi and rj == rgj;\n            if (gl and gr) {\n                ans = 1;\n                break;\n            }\n            if (gl or gr) {\n                continue;\n            }\n            REP(k, 4) {\n                int nli = li + dy[k];\n                int nlj = lj + ldx[k];\n                int nri = ri + dy[k];\n                int nrj = rj + rdx[k];\n                if (nli < 0 or H <= nli or nlj < 0 or W <= nlj or L[nli][nlj] == '#') {\n                    nli = li, nlj = lj;\n                }\n                if (nri < 0 or H <= nri or nrj < 0 or W <= nrj or R[nri][nrj] == '#') {\n                    nri = ri, nrj = rj;\n                }\n                auto tp = make_tuple(nli, nlj, nri, nrj);\n                if (used.count(tp) == 0) {\n                    used[tp] = 1;\n                    que.push(tp);\n                }\n            }\n        }\n\n        cout << (ans ? \"Yes\" : \"No\") << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cstring>\nusing namespace std;\nstruct P{\n  int rx,ry,lx,ly;\n  P(){}\n  P(int rx,int ry,int lx,int ly):rx(rx),ry(ry),lx(lx),ly(ly){};\n};\nint w,h,dx[]={0,1,-1,0},dy[]={1,0,0,-1};\nbool used[50][50][50][50];\nchar Rin[50][50],Len[50][50];\nbool bfs(int,int,int,int);\nint main(){\n  int rx,ry,lx,ly;\n  while(cin >> w >> h && w||h){\n    memset(used,false,sizeof(used));\n    for(int i=0;i<h;i++){\n      cin >> Len[i] >> Rin[i];\n      for(int j=0;j<w;j++){\n        if(Rin[i][j] == 'R') rx=i,ry=j;\n        if(Len[i][j] == 'L') lx=i,ly=j;\n      }\n    }\n    cout << (bfs(rx,ry,lx,ly)?\"Yes\":\"No\") << endl;\n  }\n}\nbool bfs(int rx,int ry,int lx,int ly){\n  queue<P> que;\n  que.push(P(rx,ry,lx,ly));\n  while(!que.empty()){\n    P p = que.front();\n    que.pop();\n    if(used[p.rx][p.ry][p.lx][p.ly]) continue;\n    if(Rin[p.rx][p.ry] == '%' && Len[p.lx][p.ly] == '%') return true;\n    if(Rin[p.rx][p.ry] == '%'||Len[p.lx][p.ly] == '%') continue;\n    used[p.rx][p.ry][p.lx][p.ly] = true;\n    for(int i=0;i<4;i++){\n      int nrx = p.rx + dx[i],nry = p.ry + dy[i];\n      int nlx = p.lx + dx[i],nly = p.ly - dy[i];\n      if(nrx<0 || nry<0 || nrx>=h || nry>=w || Rin[nrx][nry]=='#')\n        nrx = p.rx,nry = p.ry;\n      if(nlx<0 || nly<0 || nlx>=h || nly>=w || Len[nlx][nly]=='#')\n        nlx = p.lx,nly = p.ly;\n      if(used[nrx][nry][nlx][nly]) continue;\n      que.push(P(nrx,nry,nlx,nly));\n    }\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing psi=pair<string,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define MOD (1e9+7)\nvoid get(){}template<class H,class...T>void get(H&h,T&...t){cin>>h;get(t...);}\ntemplate<class T>void geti(T&a){for(auto&_:a)cin>>_;}\ntemplate<class T>void getii(T&a){for(auto&_:a)geti(_);}\nvoid put(string d){}template<class H,class...T>void put(string d,H&h,T&...t){cout<<h;if(sizeof...(t))cout<<d;put(d,t...);}\ntemplate<class T>void puti(T&a,string d=\" \"){bool f=1;for(auto&_:a)cout<<(exchange(f,0)?\"\":d)<<_;cout<<endl;}\ntemplate<class T>void putii(T&a,string d=\" \"){for(auto&_:a)puti(_,d);}\n#define dcl(...) ll __VA_ARGS__;get(__VA_ARGS__)\n#define dclt(t,...) t __VA_ARGS__;get(__VA_ARGS__)\n\nint main(){\n\tint w,h;\n\twhile(cin>>w>>h,w){\n\t\tvector<vvi> f(2,vvi(h+2,vi(w+2,1)));\n\t\tvvi curr(2,vi(2));\n\t\tvvi stat(2,vi(2));\n\t\tfor(int i=1;i<=h;i++){\n\t\t\trep(p,2){\n\t\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\t\tchar c; cin>>c;\n\t\t\t\t\tif(c=='.'){\n\t\t\t\t\t\tf[p][i][j]=0;\n\t\t\t\t\t}else if(c=='%'){\n\t\t\t\t\t\tf[p][i][j]=0;\n\t\t\t\t\t\tstat[p]={i,j};\n\t\t\t\t\t}else if(c=='L'){\n\t\t\t\t\t\tf[p][i][j]=0;\n\t\t\t\t\t\tcurr[0]={i,j};\n\t\t\t\t\t}else if(c=='R'){\n\t\t\t\t\t\tf[p][i][j]=0;\n\t\t\t\t\t\tcurr[1]={i,w+1-j};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treverse(all(f[1][i]));\n\t\t}\n\t\tstat[1][1]=w+1-stat[1][1];\n\t\t//putii(f[0],\"\");\n\t\t//cout<<endl;\n\t\t//putii(f[1],\"\");\n\t\t//cout<<\"=======\"<<endl;\n\t\t\n\t\t/*幅優先\n\t\t\t・どちらか片方だけ動き、動いた先がゴールでない場合\n\t\t\t・両方動き、かつ少なくともどちらかがそのマスを訪れたことがない場合\n\t\t\tだけ、探索する\n\t\t*/\n\t\tauto isVisited=f;\n\t\tqueue<vvi> que;\n\t\tque.push(curr);\n\t\tint y[]={-1,0,1,0};\n\t\tint x[]={0,1,0,-1};\n\t\tauto step=[f](vi &pos,int lr, int y, int x){\n\t\t\tif(f[lr][pos[0]+y][pos[1]+x]!=1){\n\t\t\t\tpos[0]+=y;\n\t\t\t\tpos[1]+=x;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tbool ok=false;\n\t\twhile(!que.empty()){\n\t\t\tauto c=que.front();\n\t\t\tque.pop();\n\t\t\t//cout<<c[0][0]<<\",\"<<c[0][1]<<\"  \"<<c[1][0]<<\",\"<<c[1][1]<<endl;\n\t\t\tisVisited[0][c[0][0]][c[0][1]]=1;\n\t\t\tisVisited[1][c[1][0]][c[1][1]]=1;\n\t\t\tif(c==stat){\n\t\t\t\tok=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trep(v,4){\n\t\t\t\tauto next=c;\n\t\t\t\tbool l=step(next[0],0,y[v],x[v]);\n\t\t\t\tbool r=step(next[1],1,y[v],x[v]);\n\t\t\t\tif( (!l and r and next[1]!=stat[1])\n\t\t\t\t\tor (l and !r and next[0]!=stat[0])\n\t\t\t\t\tor ( l and r and !(isVisited[0][next[0][0]][next[0][1]] and isVisited[1][next[1][0]][next[1][1]]))){\n\t\t\t\t\t//cout<<\" o \"<<next[0][0]<<\",\"<<next[0][1]<<\"  \"<<next[1][0]<<\",\"<<next[1][1]<<endl;\n\t\t\t\t\tque.push(next);\n\t\t\t\t}else{\n\t\t\t\t\t//cout<<\" x \"<<next[0][0]<<\",\"<<next[0][1]<<\"  \"<<next[1][0]<<\",\"<<next[1][1]<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ok){\n\t\t\tcout<<\"Yes\"<<endl;\n\t\t}else{\n\t\t\tcout<<\"No\"<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<set>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define ck(a,b) (0<=(a)&&(a)<b)\nusing namespace std;\nint dx[]={-1,1,0,0},dy[]={0,0,-1,1};\nstruct S{\n\tint lx,ly,rx,ry;\n\tS(int a,int b,int c,int d):lx(a),ly(b),rx(c),ry(d){}\n};\nbool operator<(const S &a,const S &b){\n\tif(a.lx!=b.lx)return a.lx<b.lx;\n\tif(a.ly!=b.ly)return a.ly<b.ly;\n\treturn a.rx!=b.rx?a.rx<b.rx:a.ry<b.ry;\n}\nint main(){\n\tint w,h;\n\twhile(cin>>w>>h,w){\n\t\tint lx,ly,rx,ry;\n\t\tstring cavel[h],caver[h];\n\t\trep(i,h)cin>>cavel[i]>>caver[i];\n\t\trep(i,h)rep(j,w){\n\t\t\tif(cavel[i][j]=='L')ly=i,lx=j,cavel[i][j]='.';\n\t\t\tif(caver[i][j]=='R')ry=i,rx=j,caver[i][j]='.';\n\t\t}\n\t\tvector<S> F; set<S> V;\n\t\tF.push_back(S(lx,ly,rx,ry)); V.insert(S(lx,ly,rx,ry));\n\t\tint goal=0;\n\t\twhile(!F.empty()&&!goal){\n\t\t\tvector<S> nF;\n\t\t\trep(i,F.size())rep(d,4){\n\t\t\t\tint clx=F[i].lx,cly=F[i].ly,crx=F[i].rx,cry=F[i].ry;\n\t\t\t\tint nlx=clx+dx[d],nly=cly+dy[d],nrx=crx-dx[d],nry=cry+dy[d];\n\t\t\t\tif(!ck(nlx,w)||!ck(nly,h)||cavel[nly][nlx]=='#')nlx=clx,nly=cly;\n\t\t\t\tif(!ck(nrx,w)||!ck(nry,h)||caver[nry][nrx]=='#')nrx=crx,nry=cry;\n\t\t\t\tif(nlx==clx&&nly==cly&&nrx==crx&&nry==cry)continue;\n\t\t\t\tif(cavel[nly][nlx]=='%'^caver[nry][nrx]=='%')continue;\n\t\t\t\tif(cavel[nly][nlx]=='%'&&caver[nry][nrx]=='%'){\n\t\t\t\t\tgoal=1; goto END;\n\t\t\t\t}\n\t\t\t\tif(V.find(S(nlx,nly,nrx,nry))==V.end()){\n\t\t\t\t\tnF.push_back(S(nlx,nly,nrx,nry));\n\t\t\t\t\tV.insert(S(nlx,nly,nrx,nry));\n\t\t\t\t}\n\t\t\t}\n\t\t\tF=nF;\n\t\t}\n\t\tEND:cout<<(goal?\"Yes\":\"No\")<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\n#define LX zahyou[0][0]\n#define LY zahyou[0][1]\n#define RX zahyou[1][0]\n#define RY zahyou[1][1]\n#define RROOM room[0][LY][LX]\n#define LROOM room[1][RY][RX]\n#define DINU for(int i = 0; i < 2; i++){temp[i][0] = zahyou[i][0]; temp[i][1] = zahyou[i][1];}\n\nint W, H;\n\n\nint foo(char room[2][60][60], int zahyou[2][2]) {\n\tint temp[2][2];\n\t//if ((LX < 1 || LX > W) || (RX < 1 || RX > W) || (LY < 1 || LY > H) || (RY < 1 || RY > H)) return 0;\n\tif (RROOM == 'X' && LROOM == 'X') return 0;\n\tif (RROOM == '%' && LROOM == '%') return 1;\n\tif (RROOM == '%' || LROOM == '%') return 0;\n\t RROOM = 'X'; LROOM = 'X';\n\n\n\tDINU\n\n\tif (room[0][LY + 1][LX] != '#') temp[0][1] = LY + 1;\n\tif (room[1][RY + 1][RX] != '#') temp[1][1] = RY + 1;\n\tif (foo(room, temp))return 1;\n\n\tDINU\n\n\tif (room[0][LY - 1][LX] != '#') temp[0][1] = LY - 1;\n\tif (room[1][RY - 1][RX] != '#') temp[1][1] = RY - 1;\n\tif (foo(room, temp))return 1;\n\n\tDINU\n\n\tif (room[0][LY][LX + 1] != '#') temp[0][0] = LX + 1;\n\tif (room[1][RY][RX - 1] != '#') temp[1][0] = RX - 1;\n\tif (foo(room, temp))return 1;\n\n\tDINU\n\n\tif (room[0][LY][LX - 1] != '#') temp[0][0] = LX - 1;\n\tif (room[1][RY][RX + 1] != '#') temp[1][0] = RX + 1;\n\tif (foo(room, temp))return 1;\n\n\n\treturn 0;\n}\n\n\n\nint main() {\n\tstring temp1, temp2;\n\tint zahyou[2][2];\n\n\twhile (1) {\n\t\tchar room[2][60][60];\n\t\tfor (int i = 0; i < 60; i++)for (int j = 0; j < 60; j++) { room[0][i][j] = '#'; room[1][i][j] = '#';}\n\t\tcin >> W >> H;\n\t\tif (W == 0 && H == 0) break;\n\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tcin >> temp1>>temp2;\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\troom[0][i][j] = temp1[j-1];\n\t\t\t\tif (room[0][i][j] == 'L') {\n\t\t\t\t\tLX = j;\n\t\t\t\t\tLY = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 1; j <= W; j++) {\n\t\t\t\troom[1][i][j] = temp2[j-1];\n\t\t\t\tif (room[1][i][j] == 'R') {\n\t\t\t\t\tRX = j;\n\t\t\t\t\tRY = i;\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t}\n\n\t\tif (foo(room, zahyou)) cout << \"Yes\" << endl;\n\t\telse cout <<\"No\"<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing psi=pair<string,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define MOD (1e9+7)\nvoid get(){}template<class H,class...T>void get(H&h,T&...t){cin>>h;get(t...);}\ntemplate<class T>void geti(T&a){for(auto&_:a)cin>>_;}\ntemplate<class T>void getii(T&a){for(auto&_:a)geti(_);}\nvoid put(string d){}template<class H,class...T>void put(string d,H&h,T&...t){cout<<h;if(sizeof...(t))cout<<d;put(d,t...);}\ntemplate<class T>void puti(T&a,string d=\" \"){bool f=1;for(auto&_:a)cout<<(exchange(f,0)?\"\":d)<<_;cout<<endl;}\ntemplate<class T>void putii(T&a,string d=\" \"){for(auto&_:a)puti(_,d);}\n#define dcl(...) ll __VA_ARGS__;get(__VA_ARGS__)\n#define dclt(t,...) t __VA_ARGS__;get(__VA_ARGS__)\n  \n#define fs first\n#define sc second\n  \nint main(){\n    int w,h;\n    while(cin>>w>>h,w){\n        vector<vvi> tf(2,vvi(h+2,vi(w+2,1)));\n\t\tvvi f(h+2,vi(2*w+3,1));\n        pair<pii,pii> curr;\n        pair<pii,pii> stat;\n        for(int i=1;i<=h;i++){\n            rep(p,2){\n                for(int j=1;j<=w;j++){\n                    char c; cin>>c;\n                    if(c=='.'){\n                        tf[p][i][j]=0;\n                    }else if(c=='%'){\n                        tf[p][i][j]=0;\n                        if(p==0){\n                            stat.first={i,j};\n                        }else{\n                            stat.second={i,2*w+2-j};\n                        }\n                    }else if(c=='L'){\n                        tf[p][i][j]=0;\n                        curr.first={i,j};\n                    }else if(c=='R'){\n                        tf[p][i][j]=0;\n                        curr.second={i,2*w+2-j};\n                    }\n                }\n            }\n            reverse(all(tf[1][i]));\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tf[i][j]=tf[0][i][j];\n\t\t\t\tf[i][j+w+1]=tf[1][i][j];\n\t\t\t}\n        }\n\t\t\n        //putii(f[0],\"\");\n        //cout<<endl;\n        //putii(f[1],\"\");\n        //cout<<\"=======\"<<endl;\n          \n        /*幅優先\n            ・どちらか片方だけ動き、動いた先がゴールでない場合\n            ・両方動き、かつ少なくともどちらかがそのマスを訪れたことがない場合\n            だけ、探索する\n        */\n\t\tvector<vector<bool>> is(2600,vector<bool>(2600,false));\n  \n        queue<pair<pii,pii>> que;\n        que.push(curr);\n        int y[]={-1,0,1,0};\n        int x[]={0,1,0,-1};\n        auto step=[f](pii &pos, int y, int x){\n            if(f[pos.fs+y][pos.sc+x]!=1){\n                pos.fs+=y;\n                pos.sc+=x;\n                return true;\n            }\n            return false;\n        };\n        bool ok=false;\n        while(!que.empty()){\n            auto c=que.front();\n            que.pop();\n            //cout<<c[0][0]<<\",\"<<c[0][1]<<\"  \"<<c[1][0]<<\",\"<<c[1][1]<<endl;\n            if(is[c.fs.fs*w+c.fs.sc][c.sc.fs*w+c.sc.sc-w-1]){\n                continue;\n            }\n            is[c.fs.fs*w+c.fs.sc][c.sc.fs*w+c.sc.sc-w-1]=true;\n            rep(v,4){\n                auto next=c;\n                bool l=step(next.fs,y[v],x[v]);\n                bool r=step(next.sc,y[v],x[v]);\n                if(next==stat){\n                    ok=true;\n                    goto fin;\n                }\n  \n                if(next.fs!=stat.fs and next.sc!=stat.sc and !is[next.fs.fs*w+next.fs.sc][next.sc.fs*w+next.sc.sc-w-1]){\n                    if( l or r ){\n                        //cout<<\" o \"<<next[0][0]<<\",\"<<next[0][1]<<\"  \"<<next[1][0]<<\",\"<<next[1][1]<<endl;\n                        que.push(next);\n                    }else{\n                        //cout<<\" x \"<<next[0][0]<<\",\"<<next[0][1]<<\"  \"<<next[1][0]<<\",\"<<next[1][1]<<endl;\n                    }\n                }\n            }\n        }\n        fin:;\n        if(ok){\n            cout<<\"Yes\"<<endl;\n        }else{\n            cout<<\"No\"<<endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={1,0,-1,0,-1,0,1,0};\nconst int dy[]={0,1,0,-1,0,1,0,-1};\nconst int INF = 1<<30;\nconst double EPS = 1e-8;\n#define PB push_back\n#define mk make_pair\n#define fr first\n#define sc second\n#define reps(i,j,k) for(int i = (j); i < (k); ++i)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\n#define lengthof(x) (sizeof(x) / sizeof(*(x)))\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> Pii;\ntypedef pair<int,vi > P;\ntypedef long long ll;\nbool memo[52][52][52][52];\nchar stageL[52][52];\nchar stageR[52][52];\nstruct data{\n    Pii l;\n    Pii r;\n    data(){}\n    data(Pii _l ,Pii _r){\n        l = _l;\n        r = _r;\n    }\n};\nint W,H;\n\nbool canMove(int y,int x,char type){\n    bool f = false;\n    if(type == 'L'){\n        f = stageL[y][x] != '#';\n    }\n    else if(type == 'R'){\n        f = stageR[y][x] != '#';\n    }\n    return f & (y >= 0 && y < H && x >= 0 && x < W);\n}\n\nint main(){\n    \n    while(scanf(\"%d%d\",&W,&H),W){\n        memset(memo,0,sizeof(memo));\n        memset(stageL,0,sizeof(stageL));\n        memset(stageR,0,sizeof(stageR));\n        Pii Lstart,Rstart;\n        Pii Lgoal,Rgoal;\n        rep(i,H){\n            scanf(\"%s\",stageL[i]);\n            scanf(\"%s\",stageR[i]);\n            rep(j,W){\n                if(stageL[i][j] == 'L'){\n                    Lstart = Pii(i,j);\n                }\n                if(stageL[i][j] == '%'){\n                    Lgoal = Pii(i,j);\n                }\n                if(stageR[i][j] == 'R'){\n                    Rstart = Pii(i,j);\n                }\n                if(stageR[i][j] == '%'){\n                    Rgoal = Pii(i,j);\n                }\n            }\n        }\n\n        queue < data > Q;\n        Q.push(data(Lstart,Rstart));\n\n        int ans = 0;\n\n        while( !Q.empty() ){\n            data e = Q.front();Q.pop();\n            if(memo[e.l.fr][e.l.sc][e.r.fr][e.r.sc])continue;\n            memo[e.l.fr][e.l.sc][e.r.fr][e.r.sc] = true;\n\n            if(Lgoal == e.l && Rgoal != e.r){\n                continue;\n            }\n\n            if(Lgoal != e.l && Rgoal == e.r){\n                continue;\n            }\n\n            if(Lgoal == e.l && Rgoal == e.r){\n                ans = 1;\n                break;\n            }\n\n            rep(i,4){\n                int nLy = e.l.fr + dy[i];\n                int nLx = e.l.sc + dx[i];\n                int nRy = e.r.fr + dy[i+4];\n                int nRx = e.r.sc + dx[i+4];\n\n                if(canMove(nLy,nLx,'L') && canMove(nRy,nRx,'R')){\n                    Q.push(data(Pii(nLy,nLx),Pii(nRy,nRx)));\n                }\n                else if(!canMove(nLy,nLx,'L') && canMove(nRy,nRx,'R')){\n                    Q.push(data(e.l,Pii(nRy,nRx)));\n                }\n                else if(canMove(nLy,nLx,'L') && !canMove(nRy,nRx,'R')){\n                    Q.push(data(Pii(nLy,nLx),e.r));\n                }\n\n            }\n\n        }\n\n        ans ? puts(\"Yes\") : puts(\"No\");\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<string>\n#include<cstring>\n#define cinf(n,x,y) for(int i=0;i<(n);i++) cin >> x[i]>>y[i];\ntypedef long long int ll;\nusing namespace std;\nlong long GCD(long long a, long long b) { return b ? GCD(b, a%b) : a; }\n\nbool used[52][52][52][52];\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\nint ly,lx,rx,ry;\nint h,w;\nstring field[99],field1[99];\nbool inside(int y, int x, int H, int W) {\n    return 0 <= y && y < H && 0 <= x && x < W;\n}\nbool chk(int y,int x,string s[]){\n\treturn (s[y][x] !='#');\n}\nstruct P{\n\tint rx,ry,lx,ly;\n\tP(int ly,int lx,int ry,int rx):ly(ly),lx(lx),ry(ry),rx(rx){};\n};\nbool bfs(){\n\tqueue < P > q;\n\tq.push(P(ly,lx,ry,rx));\n\n\twhile(!q.empty()){\n\t\tP p=q.front();q.pop();\n\n\t\tif(used[p.ly][p.lx][p.ry][p.rx])continue;\n\t\tused[p.ly][p.lx][p.ry][p.rx]=true;\n\t\tif(field[p.ly][p.lx]=='%' && field1[p.ry][p.rx]=='%'){return true;}\n\t\tif(field[p.ly][p.lx]=='%'||field1[p.ry][p.rx]=='%'){continue;}\n\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nrx=p.rx;int nry=p.ry;int nlx=p.lx;int nly=p.ly;\n\t\t\tif(inside(nly+dy[i],nlx+dx[i],h,w)&&chk(nly+dy[i],nlx+dx[i],field)){nly+=dy[i],nlx+=dx[i];}\n\t\t\tif(inside(nry+dy[i],nrx-dx[i],h,w)&&chk(nry+dy[i],nrx-dx[i],field1)){nry+=dy[i],nrx-=dx[i];}\n\t\t\tif(used[nly][nlx][nry][nrx]==false){\n\t\t\t\tq.push(P(nly,nlx,nry,nrx));\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\twhile(1){\n\t\tcin >>w >>h;\n\t\tif(w==0&&h==0)break;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin >>field[i] >> field1[i];\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(field[i][j]=='L')ly=i,lx=j;\n\t\t\t\tif(field1[i][j]=='R')ry=i,rx=j;\n\t\t\t}\n\t\t}\n\tfor(int i=0;i<52;i++){\n\t\tfor(int j=0;j<52;j++){\n\t\t\tfor(int k=0;k<52;k++){\n\t\t\t\tfor(int l=0;l<52;l++){\n\t\t\t\t\tused[i][j][k][l]=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << (bfs()?\"Yes\":\"No\") << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP(a, b) make_pair(a, b)\n#define Y first\n#define X second\n#define L first\n#define R second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef pair<pi, pi> pipi;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint W, H, f;\nint dy[] = {0,-1,0,1}, dx[] = {-1,0,1,0};\nchar len[64][64], rin[64][64];\n\nint main(){\n  while(scanf(\"%d%d\", &W, &H) && W){\n    f = 0;\n    rep(i, H) scanf(\"%s%s\", len[i], rin[i]);\n\n    int ly, lx, ry, rx;\n    rep(i, H) rep(j, W){\n      if(len[i][j] == 'L'){ ly = i, lx = j; len[i][j] = '.';}\n      if(rin[i][j] == 'R'){ ry = i, rx = j; rin[i][j] = '.';}\n    }\n\n    pipi p = MP(MP(ly, lx), MP(ry, rx));\n    queue<pipi>q;\n    map<pipi, int>m;\n    q.push(p);\n    m[p] = 1;\n\n    while(!q.empty()){\n      int qsize = (int)q.size();\n      rep(i, qsize){\n\tpipi now = q.front(); q.pop();\n\trep(d, 4){\n\t  int nly, nlx, nry, nrx;\n\t  if(d%2){\n\t    nly = now.L.Y + dy[d], nlx = now.L.X;\n\t    if(nly < 0 || nly >= H || len[nly][nlx] == '#') nly = now.L.Y; \n\t    nry = now.R.Y + dy[d], nrx = now.R.X;\n\t    if(nry < 0 || nry >= H || rin[nry][nrx] == '#') nry = now.R.Y; \n\t  }else{\n\t    nly = now.L.Y, nlx = now.L.X + dx[d];\n\t    if(nlx < 0 || nlx >= W || len[nly][nlx] == '#') nlx = now.L.X; \t    \n\t    nry = now.R.Y, nrx = now.R.X + -1*dx[d];\n\t    if(nrx < 0 || nrx >= W || rin[nry][nrx] == '#') nrx = now.R.X;\n\t  }\n\n\t  pipi next = MP(MP(nly, nlx), MP(nry, nrx));\n\t  if(len[nly][nlx] == '%' && rin[nry][nrx] == '%'){\n\t    f = 1;\n\t  }else if(len[nly][nlx] == '%' || rin[nry][nrx] == '%'){\n\t    continue;\n\t  }\n\n\t  if(m.count(next)) continue;\n\t  m[next] = 1;\n\n\t  q.push(next);\n\t}\n      }\n    }\n    if(f) puts(\"Yes\");\n    else puts(\"No\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <ctime>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <stack>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\ntypedef vector<string> vs;\ntypedef vector<int> vi;\n\n#define rep(i,b) loop(i,0,b)\n#define loop(i,a,b) for(int i=(a); i<int(b); i++)\n#define all(c) (c).begin(), (c).end()\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nint h,w;\ninline bool in(int x, int y){\n    return 0<=x && 0<=y && x<w && y<h;\n}\n\nvi id{0,1,2,3};\nbool solve(vs const& g1, vs const& g2){\n    int sx1, sy1, sx2, sy2;\n    rep(i,h)rep(j,w){\n        if(g1[i][j]=='L'){\n            sx1=j;sy1=i;\n        }\n        if(g2[i][j]=='R'){\n            sx2=j;sy2=i;\n        }\n    }\n    stack<vi> q;\n    static bool vis[64][64][64][64];\n    memset(vis,0,sizeof(vis));\n    q.push(vi{sx1,sy1,sx2,sy2});\n    while(q.size()){\n        vi s=q.top();q.pop();\n        int x1=s[0],y1=s[1],x2=s[2],y2=s[3];\n        if(vis[x1][y1][x2][y2])continue;\n        vis[x1][y1][x2][y2]=true;\n        if(g1[y1][x1]=='%' && g2[y2][x2]=='%') return true;\n        if(g1[y1][x1]=='%' || g2[y2][x2]=='%') continue;\n\n        random_shuffle(all(id));\n        rep(i,4){\n            int d=id[i];\n            int nx1=x1+dx[d],ny1=y1+dy[d];\n            int nx2,ny2;\n            if(d&1){\n                nx2=x2+dx[d],ny2=y2+dy[d];\n            }else{\n                nx2=x2-dx[d],ny2=y2-dy[d];\n            }\n            if(!in(nx1,ny1) || g1[ny1][nx1]=='#')nx1=x1,ny1=y1;\n            if(!in(nx2,ny2) || g2[ny2][nx2]=='#')nx2=x2,ny2=y2;\n            q.push(vi{nx1,ny1,nx2,ny2});\n        }\n    }\n    return false;    \n}\n\nint main(){\n    srand(time(0));\n    while(cin>>w>>h && w|h){\n        vs g1(h), g2(h);\n        rep(i,h) cin>>g1[i]>>g2[i];\n        vs ans{\"No\",\"Yes\"};\n        cout << ans[solve(g1,g2)] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"tune=native\")\n#pragma GCC target (\"avx\")\n\n#include <bits/stdc++.h>\n\n// 汎用マクロ\n#define ALL_OF(x) (x).begin(), (x).end()\n#define REP(i,n) for (long long i=0, i##_len=(n); i<i##_len; i++)\n#define RANGE(i,is,ie) for (long long i=(is), i##_end=(ie); i<=i##_end; i++)\n#define DSRNG(i,is,ie) for (long long i=(is), i##_end=(ie); i>=i##_end; i--)\n#define UNIQUE(v) { sort((v).begin(), (v).end()); (v).erase(unique((v).begin(), (v).end()), (v).end()); }\ntemplate<class T> bool chmax(T &a, const T &b) {if (a < b) {a = b; return 1;} return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) {if (a > b) {a = b; return 1;} return 0; }\n#define INF 0x7FFFFFFF\n#define LINF 0x7FFFFFFFFFFFFFFFLL\n#define Yes(q) (q ? \"Yes\" : \"No\")\n#define YES(q) (q ? \"YES\" : \"NO\")\n#define DUMP(q) cerr << \"[DEBUG] \" #q \": \" << (q) << \" at \" __FILE__ \":\" << __LINE__ << endl\n#define DUMPALL(q) cerr << \"[DEBUG] \" #q \": [\"; REP(dumpall_i, (q).size()) { cerr << q[dumpall_i] << (dumpall_i == (q).size() - 1 ? \"\" : \", \"); } cerr << \"] at \" __FILE__ \":\" << __LINE__ << endl\n\n// gcc拡張マクロ\n#define gcd __gcd\n#define popcount __builtin_popcount\n#define popcountll __builtin_popcountll\n\n// エイリアス\nusing  ll = long long;\nusing ull = unsigned long long;\nusing  ld = long double;\nusing namespace std;\n\n// モジュール\n\n\n// 処理内容\nint main() {\n    \n    ll w, h;\n    while (cin >> w >> h, w && h) {\n\n        vector<string> rl(h), rr(h);\n        REP(i, h) {\n            cin >> rl[i] >> rr[i];\n            rl[i] = \"#\" + rl[i] + \"#\";\n            rr[i] = \"#\" + rr[i] + \"#\";\n        }\n        string wall(w + 2, '#');\n        rl.insert(rl.begin(), wall);\n        rr.insert(rr.begin(), wall);\n        rl.emplace_back(wall);\n        rr.emplace_back(wall);\n        w += 2;\n        h += 2;\n        REP(i, h) {\n            cout << rl[i] << \" \" << rr[i] << endl;\n        }\n\n        ll lsy, lsx, rsy, rsx;\n        ll lgy, lgx, rgy, rgx;\n        REP(i, h) REP(j, w) {\n            if (rl[i][j] == '%') {\n                lgy = i;\n                lgx = j;\n            } else if (rl[i][j] == 'L') {\n                lsy = i;\n                lsx = j;\n            }\n            if (rr[i][j] == '%') {\n                rgy = i;\n                rgx = j;\n            } else if (rr[i][j] == 'R') {\n                rsy = i;\n                rsx = j;\n            }\n        }\n\n        // {ly, lx, ry, rx}\n        deque<tuple<ll,ll,ll,ll>> q;\n        vector<vector<vector<vector<bool>>>> visited(h, vector<vector<vector<bool>>>(w, vector<vector<bool>>(h, vector<bool>(w, false))));\n        q.emplace_back(lsy, lsx, rsy, rsx);\n        visited[lsy][lsx][rsy][rsx] = true;\n        while (!q.empty()) {\n\n            ll ly = get<0>(q.front());\n            ll lx = get<1>(q.front());\n            ll ry = get<2>(q.front());\n            ll rx = get<3>(q.front());\n            q.pop_front();\n\n            // Lin and Ren go upward\n            if (ly > 0 && ry > 0) {\n                ll ly2 = rl[ly - 1][lx] != '#' ? ly - 1 : ly;\n                ll lx2 = lx;\n                ll ry2 = rr[ry - 1][lx] != '#' ? ry - 1 : ry;\n                ll rx2 = rx;\n                bool is_locked = (ly2 == lgy && lx2 == lgx) != (ry2 == rgy && rx2 == rgx);\n                bool is_blocked = rl[ly2][lx2] == '#' || rr[ry2][rx2] == '#';\n                if (!visited[ly2][lx2][ry2][rx2] && !is_locked && !is_blocked) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n            }\n\n            // Lin and Ren go downward\n            if (ly < h-1 && ry < h-1) {\n                ll ly2 = rl[ly + 1][lx] != '#' ? ly + 1 : ly;\n                ll lx2 = lx;\n                ll ry2 = rr[ry + 1][lx] != '#' ? ry + 1 : ry;\n                ll rx2 = rx;\n                bool is_locked = (ly2 == lgy && lx2 == lgx) != (ry2 == rgy && rx2 == rgx);\n                bool is_blocked = rl[ly2][lx2] == '#' || rr[ry2][rx2] == '#';\n                if (!visited[ly2][lx2][ry2][rx2] && !is_locked && !is_blocked) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n            }\n\n            // Lin goes left and Ren goes right\n            if (lx > 0 && rx < w-1) {\n                ll ly2 = ly;\n                ll lx2 = rl[ly][lx - 1] != '#' ? lx - 1 : lx;\n                ll ry2 = ry;\n                ll rx2 = rr[ry][rx + 1] != '#' ? rx + 1 : rx;\n                bool is_locked = (ly2 == lgy && lx2 == lgx) != (ry2 == rgy && rx2 == rgx);\n                bool is_blocked = rl[ly2][lx2] == '#' || rr[ry2][rx2] == '#';\n                if (!visited[ly2][lx2][ry2][rx2] && !is_locked && !is_blocked) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n            }\n\n            // Lin goes right and Ren goes left\n            if (lx < w-1 && rx > 0) {\n                ll ly2 = ly;\n                ll lx2 = rl[ly][lx + 1] != '#' ? lx + 1 : lx;\n                ll ry2 = ry;\n                ll rx2 = rr[ry][rx - 1] != '#' ? rx - 1 : rx;\n                bool is_locked = (ly2 == lgy && lx2 == lgx) != (ry2 == rgy && rx2 == rgx);\n                bool is_blocked = rl[ly2][lx2] == '#' || rr[ry2][rx2] == '#';\n                if (!visited[ly2][lx2][ry2][rx2] && !is_locked && !is_blocked) {\n                    q.emplace_back(ly2, lx2, ry2, rx2);\n                    visited[ly2][lx2][ry2][rx2] = true;\n                }\n            }\n\n        }\n\n        std::cout << Yes(visited[lgy][lgx][rgy][rgx]) << endl;\n\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> dy = {1, 0, -1, 0};\nvector<int> dx = {0, 1, 0, -1};\nint main(){\n  while (1){\n    int W, H;\n    cin >> W >> H;\n    if (W == 0 && H == 0){\n      break;\n    }\n    vector<vector<char>> A(H + 2, vector<char>(W + 2, '#'));\n    vector<vector<char>> B(H + 2, vector<char>(W + 2, '#'));\n    for (int i = 1; i <= H; i++){\n      for (int j = 1; j <= W; j++){\n        cin >> A[i][j];\n      }\n      for (int j = 1; j <= W; j++){\n        cin >> B[i][j];\n      }\n    }\n    int syl, sxl, gyl, gxl;\n    for (int i = 1; i <= H; i++){\n      for (int j = 1; j <= W; j++){\n        if (A[i][j] == 'L'){\n          syl = i;\n          sxl = j;\n        }\n        if (A[i][j] == '%'){\n          gyl = i;\n          gxl = j;\n        }\n      }\n    }\n    A[syl][sxl] = '.';\n    A[gyl][gxl] = '.';\n    int syr, sxr, gyr, gxr;\n    for (int i = 1; i <= H; i++){\n      for (int j = 1; j <= W; j++){\n        if (B[i][j] == 'R'){\n          syr = i;\n          sxr = j;\n        }\n        if (B[i][j] == '%'){\n          gyr = i;\n          gxr = j;\n        }\n      }\n    }\n    B[syr][sxr] = '.';\n    B[gyr][gxr] = '.';\n    vector<vector<vector<vector<bool>>>> used(H + 2, vector<vector<vector<bool>>>(W + 2, vector<vector<bool>>(H + 2, vector<bool>(W + 2, false))));\n    used[syl][sxl][syr][sxr] = true;\n    queue<tuple<int, int, int, int>> Q;\n    Q.push(make_tuple(syl, sxl, syr, sxr));\n    while (!Q.empty()){\n      int y1 = get<0>(Q.front());\n      int x1 = get<1>(Q.front());\n      int y2 = get<2>(Q.front());\n      int x2 = get<3>(Q.front());\n      Q.pop();\n      for (int d = 0; d < 4; d++){\n        int y3 = y1;\n        if (A[y3 + dy[d]][x1] == '.'){\n          y3 += dy[d];\n        }\n        int x3 = x1;\n        if (A[y1][x3 + dx[d]] == '.'){\n          x3 += dx[d];\n        }\n        int y4 = y2;\n        if (B[y4 + dy[d]][x2] == '.'){\n          y4 += dy[d];\n        }\n        int x4 = x2;\n        if (B[y2][x4 - dx[d]] == '.'){\n          x4 -= dx[d];\n        }\n        if (!((y3 == gyl && x3 == gxl) ^ (y4 == gyr && x4 == gxr))){\n          if (!used[y3][x3][y4][x4]){\n            used[y3][x3][y4][x4] = true;\n            Q.push(make_tuple(y3, x3, y4, x4));\n          }\n        }\n      }\n    }\n    if (used[gyl][gxl][gyr][gxr]){\n      cout << \"Yes\" << endl;\n    } else {\n      cout << \"No\" << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <queue>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\nconst int dy[] = {1, 0, -1, 0};\nconst int dx[] = {0, 1, 0, -1};\nconst int MAX_N = 60;\nstruct Info\n{\n    P left, right;\n};\nstring Rfield[MAX_N];\nstring Lfield[MAX_N];\nbool used[MAX_N][MAX_N][MAX_N][MAX_N];\nint h, w, lsy, lsx, rsy, rsx;\nbool OutOfRange(int y, int x, string field[])\n{\n    if(y >= h || x >= w || x < 0 || y < 0 || field[y][x] == '#') return true;\n    else return false;\n}\nbool bfs()\n{\n    memset(used, false, sizeof(used));\n    queue<Info> que;\n    que.push({P(lsy, lsx), P(rsy, rsx)});\n    while(!que.empty())\n    {\n        Info p = que.front();\n        que.pop();\n        if(used[p.left.first][p.left.second][p.right.first][p.right.second]) continue;\n        used[p.left.first][p.left.second][p.right.first][p.right.second] = true;\n        if(Lfield[p.left.first][p.left.second] == '%' && Rfield[p.right.first][p.right.second] == '%') return true;\n        if(Lfield[p.left.first][p.left.second] == '%' || Rfield[p.right.first][p.right.second] == '%') continue;\n        for(int i = 0; i < 4; i++)\n        {\n            int ly = p.left.first;\n            int lx = p.left.second;\n            int ry = p.right.first;\n            int rx = p.right.second;\n            if(!OutOfRange(ly + dy[i], lx + dx[i], Lfield)) ly += dy[i], lx += dx[i];\n            if(!OutOfRange(ry + dy[i], rx - dx[i], Rfield)) ry += dy[i], rx -= dx[i];\n            P np = {ly, lx}, nq = {ry, rx};\n            if(!used[ly][lx][ry][rx]) que.push({np, nq});\n        }\n    }\n    return false;\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> w >> h, w | h)\n    {\n        for(int i = 0; i < h; i++)\n        {\n            cin >> Lfield[i] >> Rfield[i];\n            for(int j = 0; j < w; j++)\n            {\n                if(Lfield[i][j] == 'L') lsy = i, lsx = j;\n                if(Rfield[i][j] == 'R') rsy = i, rsx = j;\n            }\n        }\n        cout << (bfs() ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint w, h;\nchar mapl[52][52], mapr[52][52];\n\nbool bfs(pair<int, int> sl, pair<int, int> sr, pair<int, int> gl, pair<int, int> gr) {\n\tvector<vector<vector<vector<int> > > > flag(52, vector<vector<vector<int> > >(52, vector<vector<int> >(52, vector<int>(52, 0))));\n\tqueue<pair<int, int> > quel, quer; quel.push(sl); quer.push(sr);\n\twhile (!quel.empty()) {\n\t\tpair<int, int>nowl, nowr; nowl = quel.front(); nowr = quer.front(); quel.pop(); quer.pop();\n\t\tif (nowl == gl && nowr == gr) {\n\t\t\treturn true;\n\t\t}\n\t\tif ((mapl[nowl.first][nowl.second] == '%') || (mapr[nowr.first][nowr.second] == '%')) continue;\n\t\tif (flag[nowl.first][nowl.second][nowr.first][nowr.second]) continue;\n\n\t\tflag[nowl.first][nowl.second][nowr.first][nowr.second]++;\n\n\t\tint dlx[] = { -1,0,0,1 }; int dly[] = { 0,-1,1,0 };\n\t\tint drx[] = { -1,0,0,1 }; int dry[] = { 0,1,-1,0 };\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tint xl = nowl.first + dlx[i], yl = nowl.second + dly[i], xr = nowr.first + drx[i], yr = nowr.second + dry[i];\n\t\t\tif (flag[xl][yl][xr][yr] == 0) {\n\t\t\t\tif (mapl[xl][yl] != '#' || mapr[xr][yr] != '#') {\n\t\t\t\t\tif (mapl[xl][yl] == '#') {\n\t\t\t\t\t\tquel.push(nowl); quer.push(make_pair(xr, yr));\n\t\t\t\t\t} else if (mapr[xr][yr] == '#') {\n\t\t\t\t\t\tquel.push(make_pair(xl, yl)); quer.push(nowr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tquel.push(make_pair(xl, yl)); quer.push(make_pair(xr, yr));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\twhile (cin >> w >> h && (w || h)) {\n\n\t\tfor (int i = 0; i < 52; ++i)\n\t\t\tfor (int j = 0; j < 52; ++j) { mapl[i][j] = '#'; mapr[i][j] = '#'; }\n\n\t\tpair<int, int> sl, sr, gl, gr;\n\t\tfor (int i = 1; i <= h; ++i) {\n\t\t\tfor (int j = 1; j <= w; ++j) {\n\t\t\t\tcin >> mapl[i][j];\n\t\t\t\tif (mapl[i][j] == 'L') sl = make_pair(i, j);\n\t\t\t\telse if (mapl[i][j] == '%') gl = make_pair(i, j);\n\t\t\t}\n\t\t\tfor (int j = 1; j <= w; ++j) {\n\t\t\t\tcin >> mapr[i][j];\n\t\t\t\tif (mapr[i][j] == 'R') sr = make_pair(i, j);\n\t\t\t\telse if (mapr[i][j] == '%') gr = make_pair(i, j);\n\t\t\t}\n\t\t}\n\n\t\tif (bfs(sl, sr, gl, gr)) cout << \"Yes\";\n\t\telse cout << \"No\";\n\t\tcout << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstring>\n#include<queue>\n#include<tuple>\n#include<stack>\n#include<cstdio>\n#include<iomanip>\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<string> vs;\nDef inf = sizeof(Def) == sizeof(ll) ?2e18:1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint d[52][52][52][52];\nvs a,b;\nint n,m;\nint f(int x1,int y1,int x2,int y2){\n  //    cout<<x1<<\" \"<<y1<<\" \"<<x2<<\" \"<<y2<<endl;\n  rep(i,4){\n    int nx1=x1+dx[i];\n    int ny1=y1+dy[i];\n    int nx2=x2+dx[i];\n    int ny2=y2+dy[(2+i)%4];\n    if(nx1<0||ny1<0||nx1>=n||ny1>=m){\n      nx1-=dx[i];\n      ny1-=dy[(i)%4];\n    }\n    if(nx2<0||ny2<0||nx2>=n||ny2>=m){\n      nx2-=dx[i];\n      ny2-=dy[(i+2)%4];\n    }\n    if(a[nx1][ny1]=='#'){\n      nx1-=dx[i];\n      ny1-=dy[i];\n    }\n    if(b[nx2][ny2]=='#'){\n      nx2-=dx[i];\n      ny2-=dy[(i+2)%4];\n    }\n    if(d[nx1][ny1][nx2][ny2])continue;\n    d[nx1][ny1][nx2][ny2]=1;\n    f(nx1,ny1,nx2,ny2);\n  }\n}\nint main(){\n  while(cin>>m>>n,n){\n    rep(i,52)rep(j,52)rep(k,52)rep(l,52)\n      d[i][j][k][l]=0;\n    a=b=vs(n);\n    rep(i,n)cin>>a[i]>>b[i];\n    rep(i,n)rep(j,m)rep(k,n)rep(l,m)if(a[i][j]=='L'&&b[k][l]=='R'){\n      d[i][j][k][l]=1;\n      f(i,j,k,l);\n    }\n    rep(i,n)rep(j,m)rep(k,n)rep(l,m)if(a[i][j]=='%'&&b[k][l]=='%'){\n      if(d[i][j][k][l])cout<<\"YES\"<<endl;\n      else cout<<\"NO\"<<endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#define N 52\n#define y1 first.first\n#define x1 first.second\n#define y2 second.first\n#define x2 second.second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\n\nint bfs();\n\nint w,h,sy1,sx1,sy2,sx2,gy1,gx1,gy2,gx2;\nstring r1[N],r2[N];\nbool visited[N][N][N][N];\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(!w&&!h) break;\n    for(int i=0;i<h;i++) cin>>r1[i]>>r2[i];\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tfor(int k=0;k<h;k++)\n\t  for(int l=0;l<w;l++) visited[i][j][k][l]=false;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(r1[i][j]=='L') sy1=i,sx1=j;\n\tif(r1[i][j]=='%') gy1=i,gx1=j;\n\tif(r2[i][j]=='R') sy2=i,sx2=j;\n\tif(r2[i][j]=='%') gy2=i,gx2=j;\n      }\n    if(bfs()) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n  return 0;\n}\n\nint bfs(){\n  int dy[4]={0,-1,0,1},dx[4]={-1,0,1,0};\n  queue<P1> q;\n  P1 k=make_pair(P(sy1,sx1),P(sy2,sx2));\n  q.push(k);\n  visited[sy1][sx1][sy2][sx2]=true;\n  while(!q.empty()){\n    P1 t=q.front(); q.pop();\n    for(int i=0;i<4;i++){\n      int ny1=t.y1+dy[i],nx1=t.x1+dx[i];\n      int ny2=t.y2+dy[i],nx2=t.x2-dx[i];\n      if(ny1<0) ny1=0;\n      if(nx1<0) nx1=0;\n      if(h<=ny1) ny1=h-1;\n      if(w<=nx1) nx1=w-1;\n      if(ny2<0) ny2=0;\n      if(nx2<0) nx2=0;\n      if(h<=ny2) ny2=h-1;\n      if(w<=nx2) nx2=w-1;\n      if(r1[ny1][nx1]=='#') ny1=t.y1,nx1=t.x1;\n      if(r2[ny2][nx2]=='#') ny2=t.y2,nx2=t.x2;\n      P1 u=make_pair(P(ny1,nx1),P(ny2,nx2));\n      if(visited[ny1][nx1][ny2][nx2]||(ny1==gy1&&nx1==gx1)||(ny2==gy2&&nx2==gx2)) continue;\n      visited[ny1][nx1][ny2][nx2]=true;\n      q.push(u);\n      if(ny1==gy1&&nx1==gx1&&ny2==gy2&&nx2==gx2) return 1;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <set>\n#define N 52\n#define y1 first.first\n#define x1 first.second\n#define y2 second.first\n#define x2 second.second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> P1;\n\nvoid bfs();\n\nint w,h,sy1,sx1,sy2,sx2,gy1,gx1,gy2,gx2,ans;\nstring r1[N],r2[N];\nset<P1> visited;\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(!w&&!h) break;\n    for(int i=0;i<h;i++) cin>>r1[i]>>r2[i];\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(r1[i][j]=='L') sy1=i,sx1=j;\n\tif(r1[i][j]=='%') gy1=i,gx1=j;\n\tif(r2[i][j]=='R') sy2=i,sx2=j;\n\tif(r2[i][j]=='%') gy2=i,gx2=j;\n      }\n    ans=0;\n    bfs();\n    if(ans) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n    visited.clear();\n  }\n  return 0;\n}\n\nvoid bfs(){\n  int dy[4]={0,-1,0,1},dx[4]={-1,0,1,0};\n  queue<P1> q;\n  P1 k=make_pair(P(sy1,sx1),P(sy2,sx2));\n  q.push(k);\n  visited.insert(k);\n  while(!q.empty()){\n    P1 t=q.front(); q.pop();\n    for(int i=0;i<4;i++){\n      int ny1=t.y1+dy[i],nx1=t.x1+dx[i];\n      int ny2=t.y2+dy[i],nx2=t.x2-dx[i];\n      if(ny1<0) ny1=0;\n      if(nx1<0) nx1=0;\n      if(h<=ny1) ny1=h-1;\n      if(w<=nx1) nx1=w-1;\n      if(ny2<0) ny2=0;\n      if(nx2<0) nx2=0;\n      if(h<=ny2) ny2=h-1;\n      if(w<=nx2) nx2=w-1;\n      if(r1[ny1][nx1]=='#') ny1=t.y1,nx1=t.x1;\n      if(r2[ny2][nx2]=='#') ny2=t.y2,nx2=t.x2;\n      P1 u=make_pair(P(ny1,nx1),P(ny2,nx2));\n      if(visited.count(u)) continue;\n      visited.insert(u);\n      q.push(u);\n      if(ny1==gy1&&nx1==gx1&&ny2==gy2&&nx2==gx2){\n\tans=1;\n\treturn ;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < n; i++ )\n#define M 50\nconst int di[4] = {0, -1, 0, 1};\nconst int dj[4] = {1, 0, -1, 0};\nchar L[M][M], R[M][M];\nbool V[M*M][M*M];\nint W, H, lg, rg;\n\nbool check(int y, int x){\n    return 0 <= y && 0 <= x && y < H && x < W;\n}\nbool dfs(int lp, int rp){\n    if ( V[lp][rp] ) return false;\n    V[lp][rp] = true;\n    if ( lp == lg && rp == rg ) return true;\n    if ( lp == lg || rp == rg ) return false;\n    int lny, lnx, rny, rnx;\n    rep(d, 4){\n\tlny = lp/W + di[d];\n\tlnx = lp%W + dj[d];\n\trny = rp/W + ((d%2==1)?di[d]:di[(d+2)%4]);\n\trnx = rp%W + ((d%2==1)?dj[d]:dj[(d+2)%4]);\n\tif ( !(check(lny, lnx) && L[lny][lnx] != '#')) { lny = lp/W; lnx = lp%W; }\n\tif ( !(check(rny, rnx) && R[rny][rnx] != '#')) { rny = rp/W; rnx = rp%W; }\n\tif ( dfs(lny*W+lnx, rny*W+rnx) ) return true;\n    }\n    return false;\n}\n\nmain(){\n    int lp, rp;\n    while( cin >> W >> H && W ){\n\trep(i, H) {\n\t    rep(j, W) {\n\t\tcin >> L[i][j];\n\t\tif ( L[i][j] == 'L' ) lp = i*W+j;\n\t\tif ( L[i][j] == '%' ) lg = i*W+j;\n\t    }\n\t    rep(j, W) {\n\t\tcin >> R[i][j];\n\t\tif ( R[i][j] == 'R' ) rp = i*W+j;\n\t\tif ( R[i][j] == '%' ) rg = i*W+j;\n\t    }\n\t}\n\trep(i, W*H) rep(j, W*H) V[i][j] = false;\n\tif ( dfs(lp, rp) ) cout << \"Yes\" << endl;\n\telse cout << \"No\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint W, H;\nbool memo[50][50][50][50];\nstring grid1[50];\nstring grid2[50];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nbool valid1(int x, int y){\n  return (x >= 0 && y >= 0 && x < W && y < H && grid1[y][x] != '#');\n}\nbool valid2(int x, int y){\n  return (x >= 0 && y >= 0 && x < W && y < H && grid2[y][x] != '#');\n}\nbool dfs(int x1, int y1, int x2, int y2){\n  if(memo[x1][y1][x2][y2]) return false;\n  memo[x1][y1][x2][y2] = true;\n  if(grid1[y1][x1] == '%' && grid2[y2][x2] == '%') return true;\n  REP(r, 4){\n    int nx1 = x1, ny1 = y1, nx2 = x2, ny2 = y2;\n    if(valid1(x1 + dx[r], y1 + dy[r])){\n      nx1 += dx[r]; ny1 += dy[r];\n    }\n    if(valid2(x2 - dx[r], y2 + dy[r])){\n      nx2 += -dx[r]; ny2 += dy[r];\n    }\n    if(dfs(nx1, ny1, nx2, ny2)) return true;\n  }\n  return false;\n}\nint main(){\n  while(cin>>W>>H && W){\n    REP(i, H)cin>>grid1[i] >> grid2[i];\n    memset(memo, 0, sizeof(memo));\n    int x1, y1, x2, y2;\n    REP(y, H)REP(x, W){\n      if(grid1[y][x] == 'L'){\n        x1 = x; y1 = y;\n      }\n      if(grid2[y][x] == 'R'){\n        x2 = x; y2 = y;\n      }\n    }\n    bool ans = dfs(x1, y1, x2, y2);\n    if(ans) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing Coor = pair<int, int>;\nusing Pair = pair<Coor, Coor>;\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {-1, 0, 1, 0};\n\nint H;\nint W;\nint sty[2];\nint stx[2];\nint y[2];\nint x[2];\nchar field[2][50][50];\nbool dp[50][50][50][50];\n\nbool WithinRange(int y, int x) {\n  if (y < 0 || H <= y) return false;\n  if (x < 0 || W <= x) return false;\n  return true;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &W, &H);\n    if (W == 0 && H == 0) return 0;\n\n    for (int i=0; i<H; i++) {\n      for (int j=0; j<W; j++) {\n        scanf(\" %c\", &field[0][i][j]);\n        if (field[0][i][j] == '%') {\n          sty[0] = i;\n          stx[0] = j;\n        } else if (field[0][i][j] == 'L') {\n          y[0] = i;\n          x[0] = j;\n        } else assert(field[0][i][j] == '.' || field[0][i][j] == '#');\n      }\n\n      for (int j=W-1; j>=0; j--) {\n        scanf(\" %c\", &field[1][i][j]);\n        if (field[1][i][j] == '%') {\n          sty[1] = i;\n          stx[1] = j;\n        } else if (field[1][i][j] == 'R') {\n          y[1] = i;\n          x[1] = j;\n        } else assert(field[1][i][j] == '.' || field[1][i][j] == '#');\n      }\n    }\n\n    for (int i=0; i<H; i++) {\n      for (int j=0; j<W; j++) {\n        for (int k=0; k<H; k++) {\n          for (int l=0; l<W; l++) {\n            dp[i][j][k][l] = false;\n          }\n        }\n      }\n    }\n\n    dp[y[0]][x[0]][y[1]][x[1]] = true;\n    queue<Pair> q;\n    q.push(Pair(Coor(y[0], x[0]), Coor(y[1], x[1])));\n    while (!q.empty()) {\n      Pair p = q.front(); q.pop();\n      Coor c1 = p.first;\n      int y1 = c1.first;\n      int x1 = c1.second;\n      Coor c2 = p.second;\n      int y2 = c2.first;\n      int x2 = c2.second;\n\n      for (int i=0; i<4; i++) {\n        int newy1 = y1 + dy[i];\n        int newx1 = x1 + dx[i];\n        if (!WithinRange(newy1, newx1) || field[0][newy1][newx1] == '#') {\n          newy1 -= dy[i];\n          newx1 -= dx[i];\n        }\n\n        int newy2 = y2 + dy[i];\n        int newx2 = x2 + dx[i];\n        if (!WithinRange(newy2, newx2) || field[1][newy2][newx2] == '#') {\n          newy2 -= dy[i];\n          newx2 -= dx[i];\n        }\n\n        if (dp[newy1][newx1][newy2][newx2]) continue;\n        dp[newy1][newx1][newy2][newx2] = true;\n        q.push(Pair(Coor(newy1, newx1), Coor(newy2, newx2)));\n      }\n    }\n\n    if (dp[sty[0]][stx[0]][sty[1]][stx[1]]) puts(\"Yes\");\n    else puts(\"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> Coor;\ntypedef pair<Coor, Coor> Coor;\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {-1, 0, 1, 0};\n\nint H;\nint W;\nint sty[2];\nint stx[2];\nint y[2];\nint x[2];\nchar field[2][50][50];\nbool dp[50][50][50][50];\n\nbool WithinRange(int y, int x) {\n  if (y < 0 || H <= y) return false;\n  if (x < 0 || W <= x) return false;\n  return true;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &W, &H);\n    if (W == 0 && H == 0) return 0;\n\n    for (int i=0; i<H; i++) {\n      for (int j=0; j<W; j++) {\n        scanf(\" %c\", &field[0][i][j]);\n        if (field[0][i][j] == '%') {\n          sty[0] = i;\n          stx[0] = j;\n        } else if (field[0][i][j] == 'L') {\n          y[0] = i;\n          x[0] = j;\n        } else assert(field[0][i][j] == '.' || field[0][i][j] == '#');\n      }\n\n      for (int j=W-1; j>=0; j--) {\n        scanf(\" %c\", &field[1][i][j]);\n        if (field[1][i][j] == '%') {\n          sty[1] = i;\n          stx[1] = j;\n        } else if (field[1][i][j] == 'R') {\n          y[1] = i;\n          x[1] = j;\n        } else assert(field[1][i][j] == '.' || field[1][i][j] == '#');\n      }\n    }\n\n    for (int i=0; i<H; i++) {\n      for (int j=0; j<W; j++) {\n        for (int k=0; k<H; k++) {\n          for (int l=0; l<W; l++) {\n            dp[i][j][k][l] = false;\n          }\n        }\n      }\n    }\n\n    dp[y[0]][x[0]][y[1]][x[1]] = true;\n    queue<Pair> q;\n    q.push(Pair(Coor(y[0], x[0]), Coor(y[1], x[1])));\n    while (!q.empty()) {\n      Pair p = q.front(); q.pop();\n      Coor c1 = p.first;\n      int y1 = c1.first;\n      int x1 = c1.second;\n      Coor c2 = p.second;\n      int y2 = c2.first;\n      int x2 = c2.second;\n\n      for (int i=0; i<4; i++) {\n        int newy1 = y1 + dy[i];\n        int newx1 = x1 + dx[i];\n        if (!WithinRange(newy1, newx1) || field[0][newy1][newx1] == '#') {\n          newy1 -= dy[i];\n          newx1 -= dx[i];\n        }\n\n        int newy2 = y2 + dy[i];\n        int newx2 = x2 + dx[i];\n        if (!WithinRange(newy2, newx2) || field[1][newy2][newx2] == '#') {\n          newy2 -= dy[i];\n          newx2 -= dx[i];\n        }\n\n        if (dp[newy1][newx1][newy2][newx2]) continue;\n        dp[newy1][newx1][newy2][newx2] = true;\n        q.push(Pair(Coor(newy1, newx1), Coor(newy2, newx2)));\n      }\n    }\n\n    if (dp[sty[0]][stx[0]][sty[1]][stx[1]]) puts(\"Yes\");\n    else puts(\"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <queue>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nP ls, rs, lg, rg;\nint dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0}, h, w;\nbool f[50][50][50][50];\nchar lf[50][51],rf[50][51]; \n\nint range(int a,int b){\n\treturn a >= 0 && a < h && b >= 0 && b < w;\n}\n\nbool bfs(){\n\tint i, lx, ly, rx, ry;\n\tqueue<PP> que;\n\tque.push(PP(P(ls.first,ls.second),P(rs.first,rs.second)));\n\twhile(que.size()){\n\t\tlx = que.front().first.second,ly = que.front().first.first,rx = que.front().second.second, ry = que.front().second.first;\n\t\tque.pop();\n\t\tif(lg.first == ly && lg.second == lx || rg.first == ry && rg.second == rx){\n\t\t\tif(lg.first == ly && lg.second == lx && rg.first == ry && rg.second == rx)\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\t\tfor(i = 0;i < 4;i++){\n\t\t\tif(range(ly + dy[i],lx + dx[i]) && range(ry + dy[i],rx - dx[i])){\n\t\t\t\tif(lf[ly + dy[i]][lx + dx[i]] != '#' && rf[ry + dy[i]][rx - dx[i]] != '#' && f[ly + dy[i]][lx + dx[i]][ry + dy[i]][rx - dx[i]]){\n\t\t\t\t\tf[ly + dy[i]][lx + dx[i]][ry + dy[i]][rx - dx[i]] = 0;\n\t\t\t\t\tque.push(PP(P(ly + dy[i],lx + dx[i]),P(ry + dy[i],rx - dx[i])));\n\t\t\t\t}\n\t\t\t\telse if(lf[ly + dy[i]][lx + dx[i]] != '#' && rf[ry + dy[i]][rx - dx[i]] == '#' && f[ly + dy[i]][lx + dx[i]][ry][rx]){\n\t\t\t\t\tf[ly + dy[i]][lx + dx[i]][ry][rx] = 0;\n\t\t\t\t\tque.push(PP(P(ly + dy[i],lx + dx[i]),P(ry,rx)));\n\t\t\t\t}\n\t\t\t\telse if(lf[ly + dy[i]][lx + dx[i]] == '#' && rf[ry + dy[i]][rx - dx[i]] != '#' && f[ly][lx][ry + dy[i]][rx - dx[i]]){\n\t\t\t\t\tf[ly][lx][ry + dy[i]][rx - dx[i]] = 0;\n\t\t\t\t\tque.push(PP(P(ly,lx),P(ry + dy[i],rx - dx[i])));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(void){\n\tint i, j;\n\twhile(1){\n\t\tscanf(\"%d%d%*c\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tlf[i][j] = getchar();\n\t\t\t\tif(lf[i][j] == 'L'){\n\t\t\t\t\tls = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(lf[i][j] == '%'){\n\t\t\t\t\tlg = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 空白読み飛ばし\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\trf[i][j] = getchar();\n\t\t\t\tif(rf[i][j] == 'R'){\n\t\t\t\t\trs = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(rf[i][j] == '%'){\n\t\t\t\t\trg = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 改行文字読み飛ばし\n\t\t}\n\t\tmemset(f,-1,sizeof(f));\n\t\tf[ls.first][ls.second][rs.first][rs.second] = 0;\n\t\tif(bfs())\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\nconst ld eps=1e-8;\nint d1[4] = { 1,0,-1,0 };\nint d2[4] = { 0,1,0,-1 };\nint d3[4] = { 0,-1,0,1 };\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h, w) {\n\t\tchar fi1[52][52]; char fi2[52][52];\n\t\trep(i, 52) {\n\t\t\trep(j, 52) {\n\t\t\t\tfi1[i][j] = fi2[i][j] = '#';\n\t\t\t}\n\t\t}\n\t\tstring s, t;\n\t\tP s1, s2, g1, g2;\n\t\trep1(i, h) {\n\t\t\tcin >> s >> t;\n\t\t\trep1(j, w) {\n\t\t\t\tfi1[i][j] = s[j - 1];\n\t\t\t\tif (fi1[i][j] == '%') {\n\t\t\t\t\tg1 = { i,j };\n\t\t\t\t}\n\t\t\t\telse if (fi1[i][j] == 'L') {\n\t\t\t\t\ts1 = { i,j };\n\t\t\t\t}\n\t\t\t}\n\t\t\trep1(j, w) {\n\t\t\t\tfi2[i][j] = t[j - 1];\n\t\t\t\tif (fi2[i][j] == '%') {\n\t\t\t\t\tg2 = { i,j };\n\t\t\t\t}\n\t\t\t\telse if (fi2[i][j] == 'R') {\n\t\t\t\t\ts2 = { i,j };\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmap<pair<P, P>, int> used;\n\t\tqueue<pair<P, P>> v;\n\t\tbool f = false;\n\t\tv.push({ s1, s2 });\n\t\tused[{s1, s2}] = 1;\n\t\twhile (!v.empty()) {\n\t\t\tpair<P, P> now = v.front();\n\t\t\tP n1 = now.first; P n2 = now.second; v.pop();\n\t\t\tif (n1 == g1 && n2 == g2) {\n\t\t\t\tf = true; break;\n\t\t\t}\n\t\t\telse if (n1 == g1 || n2 == g2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trep(i, 4) {\n\t\t\t\tP nex1 = { n1.first + d1[i],n1.second + d2[i] };\n\t\t\t\tP nex2 = { n2.first + d1[i],n2.second + d3[i] };\n\t\t\t\tif (fi1[nex1.first][nex1.second] == '#') {\n\t\t\t\t\tnex1 = n1;\n\t\t\t\t}\n\t\t\t\tif (fi2[nex2.first][nex2.second] == '#') {\n\t\t\t\t\tnex2 = n2;\n\t\t\t\t}\n\t\t\t\tif (used[{nex1, nex2}]!=1) {\n\t\t\t\t\tused[{nex1, nex2}] = 1;\n\t\t\t\t\tv.push({ nex1,nex2 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (f) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif // !_WIN32\n\n#include<string>\n#include<iomanip>\n#include<vector>\n#include<string>\n#include<stack>\n#include<tuple>\n#include<algorithm>\nusing namespace std;\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n\n\nconst int dr[] = {0,1,0,-1};\nconst int dc1[] = {1,0,-1,0 };\nconst int dc2[] = { -1,0,1,0 };\n\nvector<string> wrap(vector<string> in,char c) {\n\tint R = in.size();\n\tint C = in[0].size();\n\tvector<string> out(R + 2, string(C + 2, c));\n\tREP(i, R)REP(j, C)out[i + 1][j + 1] = in[i][j];\n\treturn out;\n\n}\ntypedef tuple<int, int, int, int> T;\ninline int f(int a, int b, int c, int d) {\n\treturn ((a * 55 + b) * 55 + c) * 55 + d;\n}\nint dp[55 * 55 * 55 * 55];\nint main() {\n\tint R, C;\n\twhile (cin >> C >> R, R + C) {\n\t\tvector<string> A(R), B(R);\n\t\tREP(i, R) {\n\t\t\tcin >> A[i] >> B[i];\n\t\t}\n\t\tA = wrap(A, '#');\n\t\tB = wrap(B, '#');\n\t\tint asr, asc, bsr, bsc;\n\t\tint agr, agc, bgr, bgc;\n\n\t\tR += 2;\n\t\tC += 2;\n\t\tREP(a, R)REP(b, C)REP(c, R)REP(d, C)dp[f(a,b,c,d)] = 0;\n\t\tREP(i, R)REP(j, C)if (A[i][j] == 'L') { asr = i, asc = j; }\n\t\tREP(i, R)REP(j, C)if (B[i][j] == 'R') { bsr = i, bsc = j; }\n\t\tREP(i, R)REP(j, C)if (A[i][j] == '%') { agr = i, agc = j; }\n\t\tREP(i, R)REP(j, C)if (B[i][j] == '%') { bgr = i, bgc = j; }\n\t\tstack<T> st;\n\t\tst.push(T(asr, asc, bsr, bsc));\n\t\tdp[f(asr, asc, bsr, bsc)] = 1;\n\t\twhile (st.size()) {\n\t\t\tint ar, ac, br, bc;\n\t\t\ttie(ar, ac, br, bc) = st.top();\n\t\t\tst.pop();\n\t\t\tREP(i, 4) {\n\t\t\t\tint nar = ar + dr[i];\n\t\t\t\tint nac = ac + dc1[i];\n\t\t\t\tint nbr = br + dr[i];\n\t\t\t\tint nbc = bc + dc2[i];\n\t\t\t\tif (A[nar][nac] == '#') { nar = ar, nac = ac; }\n\t\t\t\tif (B[nbr][nbc] == '#') { nbr = br, nbc = bc; }\n\t\t\t\tif (dp[f(nar, nac, nbr, nbc)])continue;\n\t\t\t\tdp[f(nar, nac, nbr, nbc)]=1;\n\t\t\t\tst.push(T(nar, nac, nbr, nbc));\n\t\t\t}\n\n\t\t}\n\t\tif (dp[f(agr, agc, bgr, bgc)])cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n\n#define REP(i,n) for(int i=0; i<(n); i++)\nusing namespace std;\n\nint vx[]={1,0,-1,0}, vy[]={0,1,0,-1};\n\nint W, H;\nchar rL[60][60], rR[60][60];\nbool check[60][60][60][60];\n\nstruct state{\n\tint ly, lx, ry, rx;\n\tstate(int y1, int x1, int y2, int x2){\n\t\tly=y1; lx=x1;\n\t\try=y2; rx=x2;\n\t}\n};\n\nint main(){\n\twhile(cin>>W>>H, W|H){\n\t\tfill( rL[0], rL[0]+60*60, '#' );\n\t\tfill( rR[0], rR[0]+60*60, '#' );\n\t\tfill( check[0][0][0], check[0][0][0]+60*60*60*60, false );\n\t\tint fLx, fLy, fRx, fRy;\n\t\tREP(i, H){\n\t\t\tint j;\n\t\t\tfor(j=1; j<=W; j++){\n\t\t\t\tcin >> rL[i][j];\n\t\t\t\tif( rL[i][j] == 'L' ){\n\t\t\t\t\tfLx = j;\n\t\t\t\t\tfLy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(j--; j>0; j--){\n\t\t\t\tcin >> rR[i][j];\n\t\t\t\tif( rR[i][j] == 'R' ){\n\t\t\t\t\tfRx = j;\n\t\t\t\t\tfRy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstack<state> st;\n\t\tst.push(state(fLy, fLx, fRy, fRx));\n\t\tbool ret = false;\n\t\twhile( !st.empty() && !ret ){\n\t\t\tint ly = st.top().ly;\n\t\t\tint lx = st.top().lx;\n\t\t\tint ry = st.top().ry;\n\t\t\tint rx = st.top().rx;\n\t\t\tst.pop();\n\t\t\tif( check[ly][lx][ry][rx] ) continue;\n\t\t\tcheck[ly][lx][ry][rx] = true;\n\t\t\tfor(int k=0; k<4&&!ret; k++){\n\t\t\t\tchar nL = rL[ ly+vy[k] ][ lx+vx[k] ];\n\t\t\t\tchar nR = rR[ ry+vy[k] ][ rx+vx[k] ];\n\t\t\t\tif( nL == '.' && nR == '.' ) \n\t\t\t\t\tst.push(state(ly+vy[k], lx+vx[k], ry+vy[k], rx+vx[k]));\n\t\t\t\telse if( nL == '.' && nR == '#' ) \n\t\t\t\t\tst.push(state( ly+vy[k], lx+vx[k], ry, rx ));\n\t\t\t\telse if( nL == '#' && nR == '.' )\n\t\t\t\t\tst.push(state( ly, lx, ry+vy[k], rx+vx[k] ));\n\t\t\t\telse if( nL == '%' && nR == '%' ) \n\t\t\t\t\tret = true;\n\t\t\t}\n\t\t}\n\t\tif(ret) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "/* 44 - 01*/\n\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++) \n\nint dx[] =  { 0, 0,-1, 1};\nint dy[] =  { 1,-1, 0, 0};\nint dx2[] = { 0, 0, 1,-1};\nint dy2[] = { 1,-1, 0, 0};\n\nclass NODE{\npublic:\n\tint x1;\n\tint y1;\n\tint x2;\n\tint y2;\n\tint depth;\n};\n\nbool done[52][52][52][52];\n\nint main(){\n\tint X,Y,tx,ty,kx,ky;\n\tchar data[2][52][52];\n\twhile(cin >> X >> Y , X){\n\t\trep(k,2)rep(i,52)rep(j,52)data[k][i][j] = '#';\n\t\tvector<string> vec[2];\n\t\tvec[0].resize(Y);vec[1].resize(Y);\n\t\trep(i,Y)cin >> vec[0][i] >> vec[1][i] ;\n\t\t\n\t\trep(i,Y)rep(j,X){\n\t\t\tchar c = vec[0][i][j];\n\t\t\tif(c == 'L')tx = 1+j , ty = i+1;\n\t\t\tdata[0][1+i][1+j] = c;\n\t\t}\n\t\t\n\t\trep(i,Y)rep(j,X){\n\t\t\tchar c = vec[1][i][j];\n\t\t\tif(c == 'R')kx = 1+j , ky = i+1;\n\t\t\tdata[1][1+i][1+j] = c;\n\t\t}\n\t\t\n\t\tqueue<NODE> Q;\n\t\tNODE t = {tx,ty,kx,ky,0};\n\t\t\n\t\trep(i,52)rep(j,52)rep(k,52)rep(l,52)done[i][j][k][l] = false;\n\t\t\n\t\tQ.push(t);\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.front();Q.pop();\n\t\t\t//if(q.depth >= 100)continue;\n\t\t\tif( done[q.x1][q.y1][q.x2][q.y2] )continue;\n\t\t\tdone[q.x1][q.y1][q.x2][q.y2] = true;\n\t\t\t\n\t\t\tif(data[0][q.y1][q.x1] == '%' && data[1][q.y2][q.x2] == '%'){\n\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\trep(i,4){\n\t\t\t\tNODE next;\n\t\t\t\tnext.x1 = q.x1 + dx[i];\n\t\t\t\tnext.y1 = q.y1 + dy[i];\n\t\t\t\tnext.x2 = q.x2 + dx2[i];\n\t\t\t\tnext.y2 = q.y2 + dy2[i];\n\t\t\t\tnext.depth = q.depth + 1;\n\t\t\t\tif(data[0][next.y1][next.x1] == '#'){\n\t\t\t\t\tnext.x1 = q.x1;\n\t\t\t\t\tnext.y1 = q.y1;\n\t\t\t\t}\n\t\t\t\tif(data[1][next.y2][next.x2] == '#'){\n\t\t\t\t\tnext.x2 = q.x2;\n\t\t\t\t\tnext.y2 = q.y2;\n\t\t\t\t}\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\t\tcout << \"No\" << endl;\n\t\tend:;\t\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint dx[]={1,-1,0,0};\nint dy[]={0,0,1,-1};\nchar L[50][51];\nchar R[50][51];\nstruct wolf{\n\tint ax,ay,bx,by;\n};\nint bfs[50][50][50][50];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<b;i++){\n\t\t\tscanf(\"%s%s\",L[i],R[i]);\n\t\t}\n\t\tfor(int i=0;i<b;i++)\n\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\tfor(int k=0;k<b;k++)\n\t\t\t\t\tfor(int l=0;l<a;l++)\n\t\t\t\t\t\tbfs[i][j][k][l]=0;\n\t\tqueue<wolf>Q;\n\t\twolf S;\n\t\tfor(int i=0;i<b;i++)\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(L[i][j]=='L'){\n\t\t\t\t\tS.ax=i;\n\t\t\t\t\tS.ay=j;\n\t\t\t\t}\n\t\t\t\tif(R[i][j]=='R'){\n\t\t\t\t\tS.bx=i;\n\t\t\t\t\tS.by=j;\n\t\t\t\t}\n\t\t\t}\n\t\tbfs[S.ax][S.ay][S.bx][S.by]=1;\n\t\tQ.push(S);\n\t\twhile(Q.size()){\n\t\t\twolf at=Q.front();\n\t\t\tQ.pop();\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\twolf to=at;\n\t\t\t\tto.ax+=dx[i];\n\t\t\t\tto.ay+=dy[i];\n\t\t\t\tto.bx+=dx[i];\n\t\t\t\tto.by-=dy[i];\n\t\t\t\tbool okL=true;\n\t\t\t\tbool okR=true;\n\t\t\t\tif(0>to.ax||b<=to.ax)okL=false;\n\t\t\t\tif(0>to.bx||b<=to.bx)okR=false;\n\t\t\t\tif(0>to.ay||a<=to.ay)okL=false;\n\t\t\t\tif(0>to.by||a<=to.by)okR=false;\n\t\t\t\tif(okL&&L[to.ax][to.ay]=='#')okL=false;\n\t\t\t\tif(okR&&R[to.by][to.by]=='#')okR=false;\n\t\t\t\tif(!okL){\n\t\t\t\t\tto.ax-=dx[i];\n\t\t\t\t\tto.ay-=dy[i];\n\t\t\t\t}\n\t\t\t\tif(!okR){\n\t\t\t\t\tto.bx-=dx[i];\n\t\t\t\t\tto.by+=dy[i];\n\t\t\t\t}\n\t\t\t\tif(!bfs[to.ax][to.ay][to.bx][to.by]&&((L[to.ax][to.ay]=='%'&&R[to.bx][to.by]=='%')||(L[to.ax][to.ay]!='%'&&R[to.bx][to.by]!='%'))){\n\t\t\t\t\tbfs[to.ax][to.ay][to.bx][to.by]=1;\n\t\t\t\t\tQ.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twolf G;\n\t\tfor(int i=0;i<b;i++)\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(L[i][j]=='%'){\n\t\t\t\t\tG.ax=i;\n\t\t\t\t\tG.ay=j;\n\t\t\t\t}\n\t\t\t\tif(R[i][j]=='%'){\n\t\t\t\t\tG.bx=i;\n\t\t\t\t\tG.by=j;\n\t\t\t\t}\n\t\t\t}\n\t\tif(!bfs[G.ax][G.ay][G.bx][G.by])printf(\"Yes\\n\");\n\t\telse printf(\"No\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int MAX = 52;\nconst int ldy[4] = { 0,1,0,-1 };\nconst int ldx[4] = { 1,0,-1,0 };\nconst int rdy[4] = { 0,1,0,-1 };\nconst int rdx[4] = { -1,0,1,0 };\n\nchar l_grid[MAX][MAX];\nint l_visited[MAX][MAX];\nchar r_grid[MAX][MAX];\nint r_visited[MAX][MAX];\nbool goal;\n\nvoid dfs(int ly, int lx, int ry, int rx, int deep)\n{\n\tif (goal == true) {\n\t\treturn;\n\t}\n\n\tif (l_grid[ly][lx] == '%'&&r_grid[ry][rx] == '%') {\n\t\tgoal = true;\n\t\treturn;\n\t}\n\telse if (l_grid[ly][lx] == '%' || r_grid[ry][rx] == '%') {\n\t\treturn;\n\t}\n\n\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nly, nlx, nry, nrx;\n\t\tif (l_grid[ly + ldy[i]][lx + ldx[i]] == '#') {\n\t\t\tnly = ly;\n\t\t\tnlx = lx;\n\t\t}\n\t\telse {\n\t\t\tnly = ly + ldy[i];\n\t\t\tnlx = lx + ldx[i];\n\t\t}\n\t\tif (r_grid[ry + rdy[i]][rx + rdx[i]] == '#') {\n\t\t\tnry = ry;\n\t\t\tnrx = rx;\n\t\t}\n\t\telse {\n\t\t\tnry = ry + rdy[i];\n\t\t\tnrx = rx + rdx[i];\n\t\t}\n\n\t\tif (nly == ly&&nlx == lx&&nry == ry&&nrx == rx) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (l_visited[nly][nlx] != -1 && r_visited[nry][nrx] != -1 && l_visited[nly][nlx] == r_visited[nry][nrx]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tl_visited[ly][lx] = deep + 1;\n\t\tr_visited[ry][rx] = deep + 1;\n\t\t\n\t\tdfs(nly, nlx, nry, nrx, deep + 1);\n\t}\n}\n\nint main()\n{\n\twhile (true) {\n\t\tint W, H;\n\t\tcin >> W >> H;\n\n\t\tif (W == 0 && H == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tgoal = false;\n\n\t\tfor (int i = 0; i < MAX; i++) {\n\t\t\tfor (int j = 0; j < MAX; j++) {\n\t\t\t\tl_grid[i][j] = '#';\n\t\t\t\tl_visited[i][j] = -1;\n\t\t\t\tr_grid[i][j] = '#';\n\t\t\t\tr_visited[i][j] = -1;\n\t\t\t}\n\t\t}\n\n\t\tint ly, lx, ry, rx;\n\n\t\tfor (int y = 1; y <= H; y++) {\n\t\t\tfor (int x = 1; x <= W; x++) {\n\t\t\t\tcin >> l_grid[y][x];\n\t\t\t\t\n\t\t\t\tif (l_grid[y][x] == 'L') {\n\t\t\t\t\tly = y;\n\t\t\t\t\tlx = x;\n\t\t\t\t\tl_grid[y][x] = '.';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int x = 1; x <= W; x++) {\n\t\t\t\tcin >> r_grid[y][x];\n\n\t\t\t\tif (r_grid[y][x] == 'R') {\n\t\t\t\t\try = y;\n\t\t\t\t\trx = x;\n\t\t\t\t\tr_grid[y][x] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdfs(ly, lx, ry, rx, 0);\n\n\t\tif (goal == true) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint ans;\nint h,w;\nstring ma1[55];\nstring ma2[55];\nint dp[55][55][55][55];\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\nstruct node{int a,b,c,d;};\nvoid bfs(int x1,int y1,int x2,int y2){\n  node n=(node){x1,y1,x2,y2};\n  queue<node> q;\n  q.push(n);\n  while(!q.empty()){\n    node t=q.front();\n    q.pop();\n    int lx=t.a;\n    int ly=t.b;\n    int rx=t.c;\n    int ry=t.d;\n    if(ans)continue;\n    if(dp[lx][ly][rx][ry])continue;\n    if(ma1[lx][ly]=='%'&&ma2[rx][ry]=='%'){\n      ans=1;\n      return;\n    }\n    if(ma1[lx][ly]=='%'||ma2[rx][ry]=='%'){\n      continue;\n    }\n    dp[lx][ly][rx][ry]=1;\n    for(int i=0;i<4;i++){\n      int nlx=lx+dx[i];\n      int nly=ly+dy[i];\n      int nrx=rx+dx[i];\n      int nry=ry-dy[i];\n      if(nlx==h||nlx<0)nlx=lx;\n      if(nly==w||nly<0)nly=ly;\n      if(ma1[nlx][nly]=='#')nlx=lx,nly=ly;\n      if(nrx==h||nrx<0)nrx=rx;\n      if(nry==w||nry<0)nry=ry;\n      if(ma2[nrx][nry]=='#')nrx=rx,nry=ry;\n      if(dp[nlx][nly][nrx][nry]==0){\n\tnode d=(node){nlx,nly,nrx,nry};\n\tq.push(d);\n      }\n    }\n  }\n  return;\n}\n\nint main(){\n  while(cin>>w>>h,w+h){\n    ans=0;\n    memset(dp,0,sizeof(dp));\n    int sl[2],sr[2];\n    for(int i=0;i<h;i++){\n      cin>>ma1[i]>>ma2[i];\n      for(int j=0;j<w;j++){\n\tif(ma1[i][j]=='L')sl[0]=i,sl[1]=j;\n\tif(ma2[i][j]=='R')sr[0]=i,sr[1]=j;\n      }\n    }\n    bfs(sl[0],sl[1],sr[0],sr[1]);\n    if(ans)cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <queue>\n#define llint long long\n\nusing namespace std;\ntypedef pair<llint, llint> P;\ntypedef pair<P, P> S;\n\nllint w, h;\nchar c[55][55], c2[55][55];\nllint sx, sy, gx, gy;\nllint sx2, sy2, gx2, gy2;\nbool used[55][55][55][55];\nllint dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\n\nvoid get(char c[55][55], llint &sx, llint &sy, llint &gx, llint &gy)\n{\n\tfor(int y = 1; y <= h; y++){\n\t\tfor(int x = 1; x <= w; x++){\n\t\t\tif(c[x][y] == '%'){\n\t\t\t\tc[x][y] = '.';\n\t\t\t\tgx = x, gy = y;\n\t\t\t}\n\t\t\telse if(c[x][y] != '.' && c[x][y] != '#'){\n\t\t\t\tc[x][y] = '.';\n\t\t\t\tsx = x, sy = y;\n\t\t\t}\n\t\t}\n\t}\n}\n\nP calc(char c[55][55], llint x, llint y, llint dir)\n{\n\tllint nx = x + dx[dir], ny = y + dy[dir];\n\tif(nx <= 0 || nx > w || ny <= 0 || ny > h) return P(x, y);\n\tif(c[nx][ny] == '#') return P(x, y);\n\treturn P(nx, ny);\n}\n\nvoid bfs()\n{\n\tqueue<S> Q;\n\tQ.push(S(P(sx, sy), P(sx2, sy2)));\n\t\n\tfor(int x = 1; x <= w; x++){\n\t\tfor(int y = 1; y <= h; y++){\n\t\t\tfor(int x2 = 1; x2 <= w; x2++){\n\t\t\t\tfor(int y2 = 1; y2 <= h; y2++){\n\t\t\t\t\tused[x][y][x2][y2] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tused[sx][sy][sx2][sy2] = true;\n\t\n\twhile(Q.size()){\n\t\tllint x = Q.front().first.first, y = Q.front().first.second;\n\t\tllint x2 = Q.front().second.first, y2 = Q.front().second.second;\n\t\tQ.pop();\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tllint mi = i;\n\t\t\tif(mi % 2 == 0) mi = (mi+2)%4;\n\t\t\tP res = calc(c, x, y, i), res2 = calc(c2, x2, y2, mi);\n\t\t\tif(res.first == -1 || res2.first == -1) continue;\n\t\t\tif(used[res.first][res.second][res2.first][res2.second]) continue;\n\t\t\tbool r = (res.first == gx && res.second == gy);\n\t\t\tbool r2 = (res2.first == gx2 && res2.second == gy2);\n\t\t\tif((r&&!r2) || (!r&&r2)) continue;\n\t\t\tused[res.first][res.second][res2.first][res2.second] = true;\n\t\t\tQ.push(S(res, res2));\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) break;\n\t\t\n\t\tstring s;\n\t\tfor(int y = 1; y <= h; y++){\n\t\t\tcin >> s;\n\t\t\tfor(int x = 1; x <= w; x++) c[x][y] = s[x-1];\n\t\t\tcin >> s;\n\t\t\tfor(int x = 1; x <= w; x++) c2[x][y] = s[x-1];\n\t\t}\n\t\tget(c, sx, sy, gx, gy);\n\t\tget(c2, sx2, sy2, gx2, gy2);\n\t\t\n\t\tbfs();\n\t\t\n\t\tif(used[gx][gy][gx2][gy2]) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t\t\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <set>\n#include <queue>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(void){\n\tint h, w, i, j, a, b, c, d, dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\n\tchar rf[50][51], lf[50][51];\n\tset<pair<P,P> > s;\n\tP rs, ls, rg, lg;\n\tqueue<P> r, l;\n\twhile(1){\n\t\tscanf(\"%d%d%*c\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tlf[i][j] = getchar();\n\t\t\t\tif(lf[i][j] == 'L'){\n\t\t\t\t\tls = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(lf[i][j] == '%'){\n\t\t\t\t\tlg = P(i,j);\n\t\t\t\t\tlf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 空白読み飛ばし\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\trf[i][j] = getchar();\n\t\t\t\tif(rf[i][j] == 'R'){\n\t\t\t\t\trs = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(rf[i][j] == '%'){\n\t\t\t\t\trg = P(i,j);\n\t\t\t\t\trf[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tgetchar(); // 改行文字読み飛ばし\n\t\t}\n\t\tr.push(rs), l.push(ls);\n\t\twhile(r.size()){\n\t\t\ta = l.front().first, b = l.front().second, c = r.front().first, d = r.front().second;\n\t\t\tl.pop(), r.pop();\n\t\t\ts.insert(pair<P,P>(P(a,b),P(c,d)));\n\t\t\tif(a == lg.first && b == lg.second && c == rg.first && d == rg.second)\n\t\t\t\tbreak;\n\t\t\tif(a == lg.first && b == lg.second || c == rg.first && d == rg.second)\n\t\t\t\tcontinue;\n\t\t\tfor(i = 0;i < 4;i++){\n\t\t\t\tif(a + dy[i] >= 0 && a + dy[i] < h && b + dx[i] >= 0 && b + dx[i] < w && lf[a + dy[i]][b + dx[i]] == '.' && c + dy[i] >= 0 && c + dy[i] < h && d - dx[i] >= 0 && d - dx[i] < w && rf[c + dy[i]][d - dx[i]] == '.' && s.find(pair<P,P>(P(a + dy[i],b + dx[i]),P(c + dy[i],d - dx[i]))) == s.end()) // 両方とも動くとき\n\t\t\t\t\tl.push(P(a + dy[i],b + dx[i])), r.push(P(c + dy[i],d - dx[i]));\n\t\t\t\telse if((a + dy[i] < 0 || a + dy[i] >= h || b + dx[i] < 0 || b + dx[i] >= w || lf[a + dy[i]][b + dx[i]] == '#') && c + dy[i] >= 0 && c + dy[i] < h && d - dx[i] >= 0 && d - dx[i] < w && rf[c + dy[i]][d - dx[i]] == '.' && s.find(pair<P,P>(P(a,b),P(c + dy[i],d - dx[i]))) == s.end()) // Rinだけ動く\n\t\t\t\t\tl.push(P(a,b)), r.push(P(c + dy[i],d - dx[i]));\n\t\t\t\telse if(a + dy[i] >= 0 && a + dy[i] < h && b + dx[i] >= 0 && b + dx[i] < w && lf[a + dy[i]][b + dx[i]] == '.' && (c + dy[i] < 0 || c + dy[i] >= h || d - dx[i] < 0 || d - dx[i] >= w || rf[c + dy[i]][d - dx[i]] == '#') && s.find(pair<P,P>(P(a + dy[i],b + dx[i]),P(c,d))) == s.end()) // Lenだけ動く\n\t\t\t\t\tl.push(P(a + dy[i],b + dx[i])), r.push(P(c,d));\n\t\t\t}\n\t\t}\n\t\twhile(r.size())\n\t\t\tr.pop(),l.pop();\n\t\tif(s.find(pair<P,P>(P(lg.first,lg.second),P(rg.first,rg.second))) != s.end())\n\t\t\tprintf(\"YES\\n\");\n\t\telse\n\t\t\tprintf(\"NO\\n\");\n\t\ts.erase(s.begin(),s.end());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<functional>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cassert>\n#include<ctime>\nusing namespace std;\n\n#define mind(a,b) (a>b?b:a)\n#define maxd(a,b) (a>b?a:b)\n#define absd(x) (x<0?-(x):x)\n#define pow2(x) ((x)*(x))\n#define rep(i,n) for(int i=0; i<n; ++i)\n#define repr(i,n) for(int i=n-1; i>=0; --i)\n#define repl(i,s,n) for(int i=s; i<=n; ++i)\n#define replr(i,s,n) for(int i=n; i>=s; --i)\n#define repf(i,s,n,j) for(int i=s; i<=n; i+=j)\n#define repe(e,obj) for(auto e : obj)\n\n#define SP << \" \" <<\n#define COL << \" : \" <<\n#define COM << \", \" <<\n#define ARR << \" -> \" <<\n#define PNT(STR) cout << STR << endl\n#define POS(X,Y) \"(\" << X << \", \" << Y << \")\"\n#define DEB(A) \" (\" << #A << \") \" << A\n#define DEBREP(i,n,val) for(int i=0; i<n; ++i) cout << val << \" \"; cout << endl\n#define ALL(V) (V).begin(), (V).end()\n#define INF 1000000007\n#define INFLL 1000000000000000007LL\n#define EPS 1e-9\n\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define P_TYPE int\ntypedef pair<P_TYPE, P_TYPE> P;\ntypedef pair<P, P_TYPE> PI;\ntypedef pair<P_TYPE, P> IP;\ntypedef pair<P, P> PP;\ntypedef priority_queue<P, vector<P>, greater<P> > pvqueue;\n\n#define SZ 53\nint used[SZ][SZ][SZ][SZ];\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, -1, 0, 1};\n\nchar ml[SZ][SZ], mr[SZ][SZ];\n\nint main() {\n  int w, h;\n  while(cin >> w >> h && w+h) {\n    int lx, ly, rx, ry;\n    rep(i, h) {\n      rep(j, w) {\n        cin >> ml[i][j];\n        if(ml[i][j] == 'L') {\n          lx = j; ly = i;\n        }\n      }\n      rep(j, w) {\n        cin >> mr[i][j];\n        if(mr[i][j] == 'R') {\n          rx = j; ry = i;\n        }\n      }\n    }\n    used[ly][lx][ry][rx] = 1;\n    rep(i, h) rep(j, w) rep(k, h) rep(l, w) used[i][j][k][l] = 0;\n    queue<PP> que;\n    que.push(PP(P(lx, ly), P(rx, ry)));\n    bool ok = false;\n    while(!que.empty()) {\n      PP pp = que.front(); que.pop();\n      P &lp = pp.first, &rp = pp.second;\n      int lx = lp.first, ly = lp.second, rx = rp.first, ry = rp.second;\n      rep(k, 4) {\n        int x = dx[k], y = dy[k];\n        int n_lx = lx + x;\n        if(!(0 <= n_lx && n_lx < w)) n_lx = lx;\n        int n_ly = ly + y;\n        if(!(0 <= n_ly && n_ly < h)) n_ly = ly;\n        if(ml[n_ly][n_lx] == '#') {\n          n_lx = lx; n_ly = ly;\n        }\n        int n_rx = rx - x;\n        if(!(0 <= n_rx && n_rx < w)) n_rx = rx;\n        int n_ry = ry + y;\n        if(!(0 <= n_ry && n_ry < h)) n_ry = ry;\n        if(mr[n_ry][n_rx] == '#') {\n          n_rx = rx; n_ry = ry;\n        }\n        if(ml[n_ly][n_lx] == '%' || mr[n_ry][n_rx] == '%') {\n          if(ml[n_ly][n_lx] == '%' && mr[n_ry][n_rx] == '%') {\n            ok = true;\n          }\n          continue;\n        }\n        if(!used[n_ly][n_lx][n_ry][n_rx]) {\n          used[n_ly][n_lx][n_ry][n_rx] = 1;\n          que.push(PP(P(n_lx, n_ly), P(n_rx, n_ry)));\n        }\n      }\n    }\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\nconst ld eps=1e-8;\nint d1[4] = { 1,0,-1,0 };\nint d2[4] = { 0,1,0,-1 };\nint d3[4] = { 0,-1,0,1 };\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h, w) {\n\t\tchar fi1[52][52]; char fi2[52][52];\n\t\trep(i, 52) {\n\t\t\trep(j, 52) {\n\t\t\t\tfi1[i][j] = fi2[i][j] = '#';\n\t\t\t}\n\t\t}\n\t\tstring s, t;\n\t\tP s1, s2, g1, g2;\n\t\trep1(i, h) {\n\t\t\tcin >> s >> t;\n\t\t\trep1(j, w) {\n\t\t\t\tfi1[i][j] = s[j - 1];\n\t\t\t\tif (fi1[i][j] == '%') {\n\t\t\t\t\tg1 = { i,j };\n\t\t\t\t}\n\t\t\t\telse if (fi1[i][j] == 'L') {\n\t\t\t\t\ts1 = { i,j };\n\t\t\t\t}\n\t\t\t}\n\t\t\trep1(j, w) {\n\t\t\t\tfi2[i][j] = t[j - 1];\n\t\t\t\tif (fi2[i][j] == '%') {\n\t\t\t\t\tg2 = { i,j };\n\t\t\t\t}\n\t\t\t\telse if (fi2[i][j] == 'R') {\n\t\t\t\t\ts2 = { i,j };\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint used[52][52][52][52] = {};\n\t\tvector<pair<P, P>> v;\n\t\tbool f = false;\n\t\tv.push_back({ s1, s2 });\n\t\tused[s1.first][s1.second][s2.first][s2.second] = 1;\n\t\twhile (!v.empty()) {\n\t\t\tP n1 = v[0].first; P n2 = v[0].second; v.erase(v.begin());\n\t\t\tif (n1 == g1 && n2 == g2) {\n\t\t\t\tf = true; break;\n\t\t\t}\n\t\t\telse if (n1 == g1 || n2 == g2) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trep(i, 4) {\n\t\t\t\tP nex1 = { n1.first + d1[i],n1.second + d2[i] };\n\t\t\t\tP nex2 = { n2.first + d1[i],n2.second + d3[i] };\n\t\t\t\tif (fi1[nex1.first][nex1.second] == '#') {\n\t\t\t\t\tnex1 = n1;\n\t\t\t\t}\n\t\t\t\tif (fi2[nex2.first][nex2.second] == '#') {\n\t\t\t\t\tnex2 = n2;\n\t\t\t\t}\n\t\t\t\tif (!used[nex1.first][nex1.second][nex2.first][nex2.second]) {\n\t\t\t\t\tused[nex1.first][nex1.second][nex2.first][nex2.second] = 1;\n\t\t\t\t\tv.push_back({ nex1,nex2 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (f) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <sstream>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cstring>\n \nusing namespace std;\n\nconst int dx[]={0,1,0,-1};\nconst int dy[]={-1,0,1,0};\nchar vis[50][50][50][50];\n/*\nbool solve(int xl,int yl,int xr, int yr)\n{\n\n\n\tif(vis[yl][xl][yr][xr]==1) return false;\n\t\t\n\tif(L[yl][xl]=='%' && R[yr][xr]=='%') return true;\n\tif(L[yl][xl]=='%' && R[yr][xr]!='%') return false;\n\tif(L[yl][xl]!='%' && R[yr][xr]=='%') return false;\n\t\n\n\t\n\tvis[yl][xl][yr][xr]=1;\n\t\n\tfor(int i=0;i<4;i++){\n\t\tint nxl=xl+dx[i], nyl=yl+dy[i];\n\t\tint nxr=xr-dx[i], nyr=yr+dy[i];\n\n\t\tif(nxl<0 || w<=nxl || nyl<0 || h<=nyl ||\n\t\t   nxr<0 || w<=nxr || nyr<0 || h<=nyr ) continue;\n\t\t\n\t\tif(L[nyl][nxl]=='#'){\n\t\t\tnxl-=dx[i]; nyl-=dy[i];\n\t\t}\n\t\tif(R[nyr][nxr]=='#'){\n\t\t\tnxr+=dx[i]; nyr-=dy[i];\n\t\t}\n\n\t\tif(nxl<0 || w<=nxl || nyl<0 || h<=nyl ||\n\t\t   nxr<0 || w<=nxr || nyr<0 || h<=nyr ) continue;\n\t\t\n\t\tif(solve(nxl,nyl,nxr,nyr)) return true;\n\t\t\n\t}\n\t\n\treturn false;\n\n}\n*/\nclass Pos{\npublic:\n\tpair<int,int> posL,posR;\n\tPos(int xl,int yl,int xr,int yr){\n\t\tposL=make_pair(xl,yl);\n\t\tposR=make_pair(xr,yr);\n\t}\n};\n\n\nint main()\n{\n\n\tint w,h;\n\twhile(cin>>w>>h,w){\t\t\n\n\n\t\tmemset(vis,-1,sizeof(char)*50*50*50*50);\n\n\n\t\tstring L[100],R[100];\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>L[i]>>R[i];\n\t\t}\n\t\t\n\t\tint sxl,syl,sxr,syr;\t\t\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(L[i][j]=='L'){sxl=j,syl=i;}\n\t\t\t\tif(R[i][j]=='R'){sxr=j,syr=i;}\n\t\t\t}\n\t\t}\n\n\t\tbool ok=false;\n\t\tqueue<Pos> q;\n\t\tq.push(Pos(sxl,syl,sxr,syr));\n\t\twhile(!q.empty()){\n\t\t\tPos pos=q.front(); q.pop();\n\t\t\tint xl=pos.posL.first, yl=pos.posL.second;\n\t\t\tint xr=pos.posR.first, yr=pos.posR.second;\n\n\t\t\tif(L[yl][xl]=='%' && R[yr][xr]=='%') {ok=true; break;}\n\t\t\telse if(L[yl][xl]=='%' || R[yr][xr]=='%') continue;\n\t\t\t\n\t\t\tif(vis[xl][yl][xr][yr]==1) continue;\n\t\t\t\n\t\t\tvis[xl][yl][xr][yr]=1;\n\t\t\t\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nxl=xl+dx[i], nyl=yl+dy[i];\n\t\t\t\tint nxr=xr-dx[i], nyr=yr+dy[i];\n\t\t\n\t\t\t\tif(nxl<0 || w<=nxl || nyl<0 || h<=nyl ||\n\t\t\t\t   nxr<0 || w<=nxr || nyr<0 || h<=nyr ) continue;\n\t\t\t\t\n\t\t\t\tif(L[nyl][nxl]=='#'){\n\t\t\t\t\tnxl-=dx[i]; nyl-=dy[i];\n\t\t\t\t}\n\t\t\t\tif(R[nyr][nxr]=='#'){\n\t\t\t\t\tnxr+=dx[i]; nyr-=dy[i];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tq.push(Pos(nxl,nyl,nxr,nyr));\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\tif(ok) cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n\t\t\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint ans;\nint h,w;\nstring ma1[55];\nstring ma2[55];\nint dp[55][55][55][55];\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\n\nvoid dfs(int lx,int ly,int rx,int ry){\n  if(ans)return;\n  //cout<<lx<<\" \"<<ly<<\" \"<<rx<<\" \"<<ry<<endl;\n  if(dp[lx][ly][rx][ry])return;\n  if(ma1[lx][ly]=='%'&&ma2[rx][ry]=='%'){\n    ans=1;\n    return;\n  }\n  dp[lx][ly][rx][ry]=1;\n  for(int i=0;i<4;i++){\n    int nlx=lx+dx[i];\n    int nly=ly+dy[i];\n    int nrx=rx+dx[i];\n    int nry=ry-dy[i];\n    if(nlx==h||nlx<0)nlx=lx;\n    if(nly==w||nly<0)nly=ly;\n    if(ma1[nlx][nly]=='#')nlx=lx,nly=ly;\n    if(nrx==h||nrx<0)nrx=rx;\n    if(nry==w||nry<0)nry=ry;\n    if(ma2[nrx][nry]=='#')nrx=rx,nry=ry;\n    if(dp[nlx][nly][nrx][nry]==0)dfs(nlx,nly,nrx,nry);\n  }\n  return;\n}\n\nint main(){\n  while(cin>>w>>h,w+h){\n    ans=0;\n    memset(dp,0,sizeof(dp));\n    int sl[2],sr[2];\n    for(int i=0;i<h;i++){\n      cin>>ma1[i]>>ma2[i];\n      for(int j=0;j<w;j++){\n\tif(ma1[i][j]=='L')sl[0]=i,sl[1]=j;\n\tif(ma2[i][j]=='R')sr[0]=i,sr[1]=j;\n      }\n    }\n    dfs(sl[0],sl[1],sr[0],sr[1]);\n    if(ans)cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define pb push_back\n#define fi first\n#define sc second\nusing namespace std;\ntypedef pair<int,int> P;\n\nint w, h;\nP as, ae, bs, be;\nstring a[50], b[50];\nbool use[50][50][50][50];\nint daw[4] = {1,0,-1,0},dah[4]={0,1,0,-1};\nint dbw[4] = {-1,0,1,0},dbh[4]={0,1,0,-1};\n\nvoid dfs(int p, int q, int r, int s){\n\trep(i,4){\n\t\tint dp = p+dah[i],dq = q+daw[i];\n\t\tint dr = r+dbh[i],ds = s+dbw[i];\n\t\tif(0>dp||dp>=h||0>dq||dq>=w||a[dp][dq]=='#'){\n\t\t\tdp = p;\n\t\t\tdq = q;\n\t\t}\n\t\tif(0>dr||dr>=h||0>ds||ds>=w||b[dr][ds]=='#'){\n\t\t\tdr = r;\n\t\t\tds = s;\n\t\t}\n\t\tif(use[dp][dq][dr][ds]) continue;\n\t\tif(ae == P(dp,dq) && be != P(dr,ds)) continue;\n\t\tif(ae != P(dp,dq) && be == P(dr,ds)) continue;\n\t\tuse[dp][dq][dr][ds] = true;\n\t\tdfs(dp,dq,dr,ds);\n\t}\n}\n\nint main(){\n\twhile(scanf(\"%d%d\",&w,&h),w||h){\n\t\tmemset(use,0,sizeof(use));\n\t\trep(i,h) cin >> a[i] >> b[i];\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tif(a[i][j] == 'L') as = P(i,j);\n\t\t\t\tif(b[i][j] == 'R') bs = P(i,j);\n\t\t\t\tif(a[i][j] == '%') ae = P(i,j);\n\t\t\t\tif(b[i][j] == '%') be = P(i,j);\n\t\t\t}\n\t\t}\n\t\tuse[as.fi][as.sc][bs.fi][bs.sc] = true;\n\t\tdfs(as.fi,as.sc,bs.fi,bs.sc);\n\t\tif(use[ae.fi][ae.sc][be.fi][be.sc]) puts(\"Yes\");\n\t\telse puts(\"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R, V, E;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint dir[] = { 0,1,0,-1,0 };\n\tcin >> W >> H;\n\tvector<string>ans;\n\twhile (H) {\n\t\tvector<string>a(H);\n\t\tvector<string>b(H);\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tcin >> a[i];\n\t\t\tcin >> b[i];\n\t\t}\n\t\tvector<vector<bool>>flag(H*W, vector<bool>(H*W));\n\t\tint asx, asy, agx, agy, bsx, bsy, bgx, bgy;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (a[i][j] == 'L') {\n\t\t\t\t\tasy = i;\n\t\t\t\t\tasx = j;\n\t\t\t\t}\n\t\t\t\tif (a[i][j] == '%') {\n\t\t\t\t\tagy = i;\n\t\t\t\t\tagx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (b[i][j] == 'R') {\n\t\t\t\t\tbsy = i;\n\t\t\t\t\tbsx = j;\n\t\t\t\t}\n\t\t\t\tif (b[i][j] == '%') {\n\t\t\t\t\tbgy = i;\n\t\t\t\t\tbgx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqueue<pair<int, int>>Q;\n\t\tflag[asy*W + asx][bsy*W + bsx] = true;\n\t\tQ.push({ asy * W + asx,bsy * W + bsx });\n\t\twhile (!Q.empty()) {\n\t\t\tauto c = Q.front();\n\t\t\tQ.pop();\n\t\t\tint ay = c.first / W;\n\t\t\tint ax = c.first % W;\n\t\t\tint by = c.second / W;\n\t\t\tint bx = c.second%W;\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint nay = ay + dir[i];\n\t\t\t\tint nax = ax + dir[i + 1];\n\t\t\t\tint nby = by + dir[i];\n\t\t\t\tint nbx = bx - dir[i + 1];\n\t\t\t\tnay = max(0, min(nay, (int)H - 1));\n\t\t\t\tnby = max(0, min(nby, (int)H - 1));\n\t\t\t\tnax = max(0, min(nax, (int)W - 1));\n\t\t\t\tnbx = max(0, min(nbx, (int)W - 1));\n\t\t\t\tif (a[nay][nax] == '#') {\n\t\t\t\t\tnay = ay;\n\t\t\t\t\tnax = ax;\n\t\t\t\t}\n\t\t\t\tif (b[nby][nbx] == '#') {\n\t\t\t\t\tnby = by;\n\t\t\t\t\tnbx = bx;\n\t\t\t\t}\n\t\t\t\tif (a[nay][nax] == '%'^b[nby][nbx] == '%')continue;\n\t\t\t\tif (flag[nay*W + nax][nby*W + nbx])continue;\n\t\t\t\tflag[nay*W + nax][nby*W + nbx] = true;\n\t\t\t\tQ.push({ nay*W + nax,nby*W + nbx });\n\t\t\t}\n\t\t}\n\t\tif (flag[agy*W + agx][bgy*W + bgx])ans.push_back(\"Yes\\n\");\n\t\telse ans.push_back(\"No\\n\");\n\t\tcin >> W >> H;\n\t}\n\tfor (auto i : ans) {\n\t\tcout << i;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n\nusing namespace std;\nint const dxL[] = {-1,0,1,0};\nint const dxR[] = {1,0,-1,0};\nint const dy[]  = {0,-1,0,1};\ntypedef pair<int, int> Pii;\n#define X first\n#define Y second\nint W, H;\nchar grL[51][51], grR[51][51];\ninline bool inF(int x, int y, int isL) {\n  if(0<=x&&x<W && 0<=y&&y<H) {\n    if(isL) return grL[y][x]!='#';\n    else return grR[y][x]!='#';\n  }\n  return false;\n}\ninline int toNode(int x, int y) {\n  return y*W+x;\n}\ninline void toPos(int node, int &x, int &y) {\n  x = node%W, y = node/W;\n}\nint main() {\n  \n  while(cin >> W >> H && (W|H)) {\n    int sxL, syL, sxR, syR;\n    int gxL, gyL, gxR, gyR;\n    for(int i=0; i<H; i++) {\n      for(int j=0; j<2*W; j++) {\n        if(j<W) {\n          cin >> grL[i][j];\n          if(grL[i][j] == 'L') {\n            sxL = j, syL = i;\n          }\n          if(grL[i][j] == '%') {\n            gxL = j, gyL = i;\n          }\n        }\n        else {\n          cin >> grR[i][j-W];\n          if(grR[i][j-W] == 'R') {\n            sxR = j-W, syR = i;\n          }\n          if(grR[i][j-W] == '%') {\n            gxR = j-W, gyR = i;\n          }\n        }\n      }\n    }\n    \n    map<pair<int, int>, int > mp;\n    queue<int> qCost;\n    queue<int> qL, qR;\n    qCost.push(0);\n    qL.push(toNode(sxL, syL)); qR.push(toNode(sxR, syR));\n    bool ok = false;\n    mp[make_pair(toNode(sxL, syL), toNode(sxR, syR))] = 0;\n    while(!qL.empty()) {\n      int nowL = qL.front(); qL.pop();\n      int nowR = qR.front(); qR.pop();\n      int lx, ly; toPos(nowL, lx, ly);\n      int rx, ry; toPos(nowR, rx, ry);\n      int cost = qCost.front(); qCost.pop();\n      if(lx == gxL && ly == gyL && rx == gxR && ry == gyR) {\n        ok = true; break;\n      }\n      if(lx == gxL && ly == gyL) {\n        continue;\n      }\n      if(rx == gxR && ry == gyR) {\n        continue;\n      }\n      for(int i=0; i<4; i++) {\n        int nxL = lx+dxL[i], nyL = ly+dy[i];\n        int nxR = rx+dxR[i], nyR = ry+dy[i];\n        if(!inF(nxL, nyL, 1) && !inF(nxR, nyR, 0)) continue;\n        if(!inF(nxL, nyL, 1)) { nxL = lx, nyL = ly; }\n        if(!inF(nxR, nyR, 0)) { nxR = rx, nyR = ry; }\n        if(mp.find(make_pair(toNode(nxL, nyL), toNode(nxR, nyR))) != mp.end()) continue;\n        qCost.push(cost+1);\n        qL.push(toNode(nxL, nyL));\n        qR.push(toNode(nxR, nyR));\n        mp[make_pair(nowL, nowR)] = cost+1;\n      }\n    }\n    if(ok) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \nint dxl[] = {0, 0, 1, -1}, dxr[] = {0, 0, 1, -1};\nint dyl[] = {1, -1, 0, 0}, dyr[] = {-1, 1, 0, 0};\nconst int INF = 1001001001;\nconst ll LONGINF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint rec[51][51][51][51];\nint solve_testcase() {\n    memset(rec, 0, sizeof(rec));\n    int W, H; cin >> W >> H;\n    if(W == 0 and H == 0) return 1;\n    \n    vector<string> bl(H), br(H);\n    int lx = -1, ly = -1, rx = -1, ry = -1;\n    int glx = -1, gly = -1, grx = -1, gry = -1;\n    for(int i=0; i<H; i++) {\n        cin >> bl[i] >> br[i];\n        for(int j=0; j<W; j++) {\n            if(bl[i][j] == 'L') lx = i, ly = j;\n            if(br[i][j] == 'R') rx = i, ry = j;\n            if(bl[i][j] == '%') glx = i, gly = j;\n            if(br[i][j] == '%') grx = i, gry = j;\n        }\n    }\n\n    queue< tuple<int, int, int, int> > que;\n    rec[lx][ly][rx][ry] = true;\n    que.emplace(lx, ly, rx, ry);\n    while(que.size()) {\n        int px, py, qx, qy; tie(px, py, qx, qy) = que.front(); que.pop();\n        if(glx == px and gly == py) continue;\n        if(grx == qx and gry == qy) continue;\n        for(int k=0; k<4; k++) {\n            int npx = px + dxl[k], npy = py + dyl[k];\n            int nqx = qx + dxr[k], nqy = qy + dyr[k];\n\n            if(npx < 0 or npx >= H or npy < 0 or npy >= W) npx = px, npy = py;\n            if(nqx < 0 or nqx >= H or nqy < 0 or nqy >= W) nqx = qx, nqy = qy;\n            if(bl[npx][npy] == '#') npx = px, npy = py;\n            if(br[nqx][nqy] == '#') nqx = qx, nqy = qy;\n\n            if(!rec[npx][npy][nqx][nqy]) {\n                rec[npx][npy][nqx][nqy] = true;\n                que.emplace(npx, npy, nqx, nqy);\n            }\n        }\n    }\n\n    cout << (rec[glx][gly][grx][gry] ? \"Yes\" : \"No\") << endl;\n    return 0;\n}\n\nint main() {\n    while(!solve_testcase());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <string.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int>;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\nll w,h;\n\nvector<string> l,r;\n\n/* bool search(int lx,int ly,int rx,int ry){                                       */\n/*   if(!value(lx,ly,w,h) || !value(rx,ry,w,h) || f[lx][ly][rx][ry]) return false; */\n/*   (f[lx][ly][rx][ry]) = true;                                                   */\n/*   bool res = false;                                                             */\n/*   rep(i,4){                                                                     */\n/*     int nlx = lx + dx[i],nly = ly + dy[i],nrx = rx - dx[i],nry = ry + dy[i];    */\n/*     cout << nlx << ' ' << nly << ' ' << nrx << ' ' << nry << endl;              */\n/*     if(value(nlx,nly,w,h) && value(nrx,nry,w,h) ){                              */\n/*       if( l[nly][nlx] == '.' && r[nry][nrx] == '.')                             */\n/*         res |= search(nlx,nly,nrx,nry);                                         */\n/*     }                                                                           */\n/*     if(value(nlx,nly,w,h) && value(nrx,nry,w,h) ){                              */\n/*       if( l[nly][nlx] == '.' && r[nry][nrx] == '#')                             */\n/*         res |= search(nlx,nly,rx,ry);                                           */\n/*     }                                                                           */\n/*     if(value(nlx,nly,w,h) && value(nrx,nry,w,h) ){                              */\n/*       if( l[nly][nlx] == '#' && r[nry][nrx] == '.')                             */\n/*         res |= search(lx,ly,nrx,nry);                                           */\n/*     }                                                                           */\n/*     if(value(nlx,nly,w,h) && value(nrx,nry,w,h) ){                              */\n/*       if( l[nly][nlx] == '%' && r[nry][nrx] == '%')                             */\n/*         return true;                                                            */\n/*     }                                                                           */\n/*   }                                                                             */\n/*   return res;                                                                   */\n/* }                                                                               */\n\nbool f[51][51][51][51] ={};\nqueue<pair<pii,pii>> q;\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll lx,ly,rx,ry;\n  while(cin >> w >> h &&  w + h ){\n    l.resize(h),r.resize(h);\n    rep(i,h){\n      cin >> l[i] >> r[i];\n      rep(j,w){\n        if(l[i][j] == 'L'){\n          ly = i;\n          lx = j;\n        }\n        if(r[i][j] == 'R'){\n          ry = i;\n          rx = j;\n        }\n      }\n    }\n    auto make = [](int lx,int ly,int rx,int ry){return mp(mp(lx,ly),mp(rx,ry));};\n    bool ans = false;\n    while(q.size()){\n      q.pop();\n    }\n    q.push(make(lx,ly,rx,ry));\n    memset(f,0,51*51*51*51);\n    while(q.size()){\n      pii lp = q.front().fi,rp = q.front().se;\n      q.pop();\n      lx = lp.fi,ly = lp.se,rx = rp.fi,ry = rp.se;\n      rep(i,4){\n        int nlx = lx + dx[i],nly = ly + dy[i],nrx = rx - dx[i],nry = ry + dy[i];\n        if(value(nlx,nly,w,h) && value(nrx,nry,w,h) ){\n          if( l[nly][nlx] == '.' && r[nry][nrx] == '.' && !f[nlx][nly][nrx][nry]){\n            f[nlx][nly][nrx][nry] = true;\n            q.push(make(nlx,nly,nrx,nry));\n          }\n          else if( l[nly][nlx] == '.' && r[nry][nrx] == '#'&& !f[nlx][nly][rx][ry]){\n            f[nlx][nly][rx][ry] = true;\n            q.push(make(nlx,nly,rx,ry));\n          }\n          else if( l[nly][nlx] == '#' && r[nry][nrx] == '.'&& !f[lx][ly][nrx][nry]){\n            f[lx][ly][nrx][nry] = true;\n            q.push(make(lx,ly,nrx,nry));\n          }\n          else if( l[nly][nlx] == '%' && r[nry][nrx] == '%'){\n            ans = true;\n            while(q.size()){\n              q.pop();\n            }\n          }\n        }\n        else{\n          if( value(nlx,nly,w,h) && l[nly][nlx] == '.' && !f[nlx][nly][rx][ry]){\n            f[nlx][nly][rx][ry] = true;\n            q.push(make(nlx,nly,rx,ry));\n          }\n          else if( value(nrx,nry,w,h) && r[nry][nrx] == '.'&& !f[lx][ly][nrx][nry]){\n            f[lx][ly][nrx][nry] = true;\n            q.push(make(lx,ly,nrx,nry));\n          }\n        }\n      } \n    }\n    std::cout << (ans ? \"Yes\" : \"No\") << std::endl; \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <vector>\nusing namespace std;\n\nvector<vector<char> > f;\nset<int> s;\nbool end;\n\nint oneval(int lx, int ly, int rx, int ry) {\n  return lx * 1000000 + ly * 10000 + rx * 100 + ry;\n}\n\nbool DFS(int lx, int ly, int rx, int ry) {\n  if (end) {\n    return false;\n  }\n\n  int val = oneval(lx, ly, rx, ry);\n  if (s.count(val) != 0) {\n    return false;\n  }\n\n  if (f[lx][ly] == '%' && f[rx][ry] == '%') {\n    end = true;\n    return true;\n  }\n\n  s.insert(val);\n  bool ret = false;\n  ret = ret || DFS(lx, f[lx][ly - 1] != '#' ? ly - 1 : ly,\n\t\t   rx, f[rx][ry - 1] != '#' ? ry - 1 : ry);\n  ret = ret || DFS(f[lx - 1][ly] != '#' ? lx - 1 : lx, ly,\n\t\t   f[rx + 1][ry] != '#' ? rx + 1 : rx, ry);\n  ret = ret || DFS(f[lx + 1][ly] != '#' ? lx + 1 : lx, ly,\n\t\t   f[rx - 1][ry] != '#' ? rx - 1 : rx, ry);\n  ret = ret || DFS(lx, f[lx][ly + 1] != '#' ? ly + 1 : ly,\n\t\t   rx, f[rx][ry + 1] != '#' ? ry + 1 : ry);\n\n  return ret;\n}\n\nint main() {\n  f.resize(103);\n  for (int i = 0; i < f.size(); i++) {\n    f[i].resize(52);\n  }\n\n  while (true) {\n    s.clear();\n    end = false;\n\n    int W, H;\n    cin >> W >> H;\n\n    if (W == 0) {\n      break;\n    }\n\n    int cw = W + 1;\n    int w = W * 2 + 3;\n    int h = H + 2;\n    for (int i = 0; i < w; i++) {\n      f[i][0] = f[i][h - 1] = '#';\n    }\n    for (int i = 0; i < h; i++) {\n      f[0][i] = f[cw][i] = f[w - 1][i] = '#';\n    }\n\n    int lx = 0, ly = 0;\n    int rx = 0, ry = 0;\n    for (int i = 1; i < h - 1; i++) {\n      for (int j = 1; j < cw; j++) {\n\tcin >> f[j][i];\n\tif (f[j][i] == 'L') {\n\t  lx = j;\n\t  ly = i;\n\t  f[j][i] = '.';\n\t}\n      }\n      for (int j = cw + 1; j < w - 1; j++) {\n\tcin >> f[j][i];\n\tif (f[j][i] == 'R') {\n\t  rx = j;\n\t  ry = i;\n\t  f[j][i] = '.';\n\t}\n      }\n    }\n\n    cout << (DFS(lx, ly, rx, ry) ? \"Yes\" : \"No\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int MAX = 52;\nconst int ldy[4] = { 0,1,0,-1 };\nconst int ldx[4] = { 1,0,-1,0 };\nconst int rdy[4] = { 0,1,0,-1 };\nconst int rdx[4] = { -1,0,1,0 };\n\nchar l_grid[MAX][MAX];\nint l_visited[MAX][MAX];\nchar r_grid[MAX][MAX];\nint r_visited[MAX][MAX];\nbool goal;\n\nvoid dfs(int ly, int lx, int ry, int rx, int deep)\n{\n\tif (goal == true) {\n\t\treturn;\n\t}\n\n\tif (l_grid[ly][lx] == '%'&&r_grid[ry][rx] == '%') {\n\t\tgoal = true;\n\t\treturn;\n\t}\n\telse if (l_grid[ly][lx] == '%' || r_grid[ry][rx] == '%') {\n\t\treturn;\n\t}\n\n\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nly, nlx, nry, nrx;\n\t\tif (l_grid[ly + ldy[i]][lx + ldx[i]] == '#') {\n\t\t\tnly = ly;\n\t\t\tnlx = lx;\n\t\t}\n\t\telse {\n\t\t\tnly = ly + ldy[i];\n\t\t\tnlx = lx + ldx[i];\n\t\t}\n\t\tif (r_grid[ry + rdy[i]][rx + rdx[i]] == '#') {\n\t\t\tnry = ry;\n\t\t\tnrx = rx;\n\t\t}\n\t\telse {\n\t\t\tnry = ry + rdy[i];\n\t\t\tnrx = rx + rdx[i];\n\t\t}\n\n\t\tif (nly == ly&&nlx == lx&&nry == ry&&nrx == rx) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (l_visited[nly][nlx] != -1 && r_visited[nry][nrx] != -1 && l_visited[nly][nlx] == r_visited[nry][nrx]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tl_visited[ly][lx] = deep + 1;\n\t\tr_visited[ry][rx] = deep + 1;\n\t\t\n\t\tdfs(nly, nlx, nry, nrx, deep + 1);\n\t}\n}\n\nint main()\n{\n\twhile (true) {\n\t\tint W, H;\n\t\tcin >> W >> H;\n\n\t\tif (W == 0 && H == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tgoal = false;\n\n\t\tfor (int i = 0; i < MAX; i++) {\n\t\t\tfor (int j = 0; j < MAX; j++) {\n\t\t\t\tl_grid[i][j] = '#';\n\t\t\t\tl_visited[i][j] = -1;\n\t\t\t\tr_grid[i][j] = '#';\n\t\t\t\tr_visited[i][j] = -1;\n\t\t\t}\n\t\t}\n\n\t\tint ly, lx, ry, rx;\n\n\t\tfor (int y = 1; y <= H; y++) {\n\t\t\tfor (int x = 1; x <= W; x++) {\n\t\t\t\tcin >> l_grid[y][x];\n\t\t\t\t\n\t\t\t\tif (l_grid[y][x] == 'L') {\n\t\t\t\t\tly = y;\n\t\t\t\t\tlx = x;\n\t\t\t\t\tl_grid[y][x] = '.';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int x = 1; x <= W; x++) {\n\t\t\t\tcin >> r_grid[y][x];\n\n\t\t\t\tif (r_grid[y][x] == 'R') {\n\t\t\t\t\try = y;\n\t\t\t\t\trx = x;\n\t\t\t\t\tr_grid[y][x] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdfs(ly, lx, ry, rx, 0);\n\n\t\tif (goal == true) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<tuple>\n#include<string>\nusing namespace std;\n\n#define MAX_N 70\n#define INF 1<<30\n\nint dist[MAX_N][MAX_N][MAX_N][MAX_N];\nint dy1[4] = { 0,1,0,-1 };\nint dy2[4] = { 0,1,0,-1 };\nint dx1[4] = { 1,0,-1,0 };\nint dx2[4] = { -1,0,1,0 };\nint H, W, map1[MAX_N][MAX_N], map2[MAX_N][MAX_N];\nint Lsy, Lsx, Lgy, Lgx;\nint Rsy, Rsx, Rgy, Rgx;\nstring S, T;\nqueue<tuple<int, int, int, int>>Q;\n\nvoid _memset() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tfor (int k = 0; k < MAX_N; k++) {\n\t\t\t\tfor (int l = 0; l < MAX_N; l++) {\n\t\t\t\t\tdist[i][j][k][l] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tmap1[i][j] = 1;\n\t\t\tmap2[i][j] = 1;\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\t//memset.\n\t\t_memset();\n\n\t\t//cin.\n\t\tcin >> W >> H;\n\t\tif (H == 0 && W == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 1; i <= H; i++) {\n\t\t\tcin >> S >> T;\n\t\t\tfor (int j = 0; j < S.size(); j++) {\n\t\t\t\tif (S[j] == 'L') {\n\t\t\t\t\tLsx = j + 1; Lsy = i;\n\t\t\t\t\tmap1[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\tif (S[j] == '#') {\n\t\t\t\t\tmap1[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (S[j] == '.') {\n\t\t\t\t\tmap1[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\tif (S[j] == '%') {\n\t\t\t\t\tLgy = i; Lgx = j + 1;\n\t\t\t\t\tmap1[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < T.size(); j++) {\n\t\t\t\tif (T[j] == 'R') {\n\t\t\t\t\tRsx = j + 1; Rsy = i;\n\t\t\t\t\tmap2[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\tif (T[j] == '#') {\n\t\t\t\t\tmap2[i][j + 1] = 1;\n\t\t\t\t}\n\t\t\t\tif (T[j] == '.') {\n\t\t\t\t\tmap2[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t\tif (T[j] == '%') {\n\t\t\t\t\tRgy = i; Rgx = j + 1;\n\t\t\t\t\tmap2[i][j + 1] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//bfs.\n\t\tQ.push(make_tuple(Lsy, Lsx, Rsy, Rsx));\n\t\tdist[Lsy][Lsx][Rsy][Rsx] = 0;\n\n\t\twhile (!Q.empty()) {\n\t\t\ttuple<int, int, int, int>tup = Q.front(); Q.pop();\n\t\t\tbool Q1, Q2;\n\t\t\tint ay = get<0>(tup);\n\t\t\tint ax = get<1>(tup);\n\t\t\tint by = get<2>(tup);\n\t\t\tint bx = get<3>(tup);\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint ey = ay + dy1[i], ex = ax + dx1[i];\n\t\t\t\tint fy = by + dy2[i], fx = bx + dx2[i];\n\t\t\t\tif (map1[ey][ex] == 1) {\n\t\t\t\t\tey = ay; ex = ax;\n\t\t\t\t}\n\t\t\t\tif (map2[fy][fx] == 1) {\n\t\t\t\t\tfy = by; fx = bx;\n\t\t\t\t}\n\t\t\t\tif (ey == Lgy && ex == Lgx) {\n\t\t\t\t\tQ1 = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tQ1 = false;\n\t\t\t\t}\n\t\t\t\tif (fy == Rgy && fx == Rgx) {\n\t\t\t\t\tQ2 = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tQ2 = false;\n\t\t\t\t}\n\t\t\t\tif (Q1 == true && Q2 == false) {\n\t\t\t\t\tgoto G;\n\t\t\t\t}\n\t\t\t\tif (Q1 == false && Q2 == true) {\n\t\t\t\t\tgoto G;\n\t\t\t\t}\n\t\t\t\tif (dist[ey][ex][fy][fx] == INF) {\n\t\t\t\t\tdist[ey][ex][fy][fx] = dist[ay][ax][by][bx] + 1;\n\t\t\t\t\tQ.push(make_tuple(ey, ex, fy, fx));\n\t\t\t\t}\n\t\t\tG:;\n\t\t\t}\n\t\t}\n\n\t\t//hantei.\n\t\tif (dist[Lgy][Lgx][Rgy][Rgx] == INF) {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n\nbool b[103][52][103][52] = {};\n\n\nint main() {\n\n  while( true ) {\n\n    long long int w, h;\n    cin >> w >> h;\n\n    if ( w == 0 ) break;\n\n    vector< string > map;\n\n    map.push_back( \"##############################################################################################################\" );\n\n    long long int rx, ry, lx, ly;\n\n    for ( long long int y = 1; y <= h; y++ ) {\n\n      string in_L, in_R;\n      cin >> in_L >> in_R;\n\n      string in = \"#\" + in_L + \"#\" + in_R + \"#\";\n      map.push_back( in );\n\n      for ( long long int x = 0; x < in.size(); x++ ) {\n\n\tif ( map[y][x] == 'R' ) {\n\t  rx = x;\n\t  ry = y;\n\t}\n\tif ( map[y][x] == 'L' ) {\n\t  lx = x;\n\t  ly = y;\n\t}\n\n      }\n\n    }\n\n    map.push_back( \"##############################################################################################################\" );\n\n\n    for ( long long int y = 0; y < map.size(); y++ ) {\n      for ( long long int x = 0; x < map[0].size(); x++ ) {\n\tfor ( long long int y2 = 0; y2 < map.size(); y2++ ) {\n\t  for ( long long int x2 = 0; x2 < map[0].size(); x2++ ) {\n\t    b[x][y][x2][y2] = false;\n\t  }\n\t}\n      }\n    }\n\n\n    queue< vector< long long int > > q;\n    vector< long long int > v;\n    v.push_back( rx );\n    v.push_back( ry );\n    v.push_back( lx );\n    v.push_back( ly );\n    q.push( v );\n\n    bool ans = false;\n\n    while( q.size() > 0 ) {\n\n      rx = q.front()[0];\n      ry = q.front()[1];\n      lx = q.front()[2];\n      ly = q.front()[3];\n      q.pop();\n\n      if ( b[ rx ][ ry ][ lx ][ ly ] == true ) continue;\n\n      b[ rx ][ ry ][ lx ][ ly ] = true;\n\n\n      if ( map[ry][rx] == '%' && map[ly][lx] == '%' ) {\n\tcout << \"Yes\" << endl;\n\tans = true;\n\tbreak;\n      }else if ( map[ry][rx] == '%' ) {\n\tcontinue;\n      }else if ( map[ly][lx] == '%' ) {\n\tcontinue;\n      }\n\n      //      cout << rx << \" \" << ry << \" \" << lx << \" \" << ly << endl;\n\n\n      v.clear();\n      if ( map[ ry ][ rx + 1 ] == '#' ) {\n\tv.push_back( rx );\n      }else {\n\tv.push_back( rx + 1 );\n      }\n      v.push_back( ry );\n      if ( map[ ly ][ lx - 1 ] == '#' ) {\n\tv.push_back( lx );\n      }else {\n\tv.push_back( lx - 1 );\n      }\n      v.push_back( ly );\n      q.push( v );\n\n      v.clear();\n      v.push_back( rx );\n      if ( map[ ry - 1 ][ rx ] == '#' ) {\n\tv.push_back( ry );\n      }else {\n\tv.push_back( ry - 1 );\n      }\n      v.push_back( lx );\n      if ( map[ ly - 1 ][ lx ] == '#' ) {\n\tv.push_back( ly );\n      }else {\n\tv.push_back( ly - 1 );\n      }\n      q.push( v );\n\n      v.clear();\n      if ( map[ ry ][ rx - 1 ] == '#' ) {\n\tv.push_back( rx );\n      }else {\n\tv.push_back( rx - 1 );\n      }\n      v.push_back( ry );\n      if ( map[ ly ][ lx + 1 ] == '#' ) {\n\tv.push_back( lx );\n      }else {\n\tv.push_back( lx + 1 );\n      }\n      v.push_back( ly );\n      q.push( v );\n\n      v.clear();\n      v.push_back( rx );\n      if ( map[ ry + 1 ][ rx ] == '#' ) {\n\tv.push_back( ry );\n      }else {\n\tv.push_back( ry + 1 );\n      }\n      v.push_back( lx );\n      if ( map[ ly + 1 ][ lx ] == '#' ) {\n\tv.push_back( ly );\n      }else {\n\tv.push_back( ly + 1 );\n      }\n      q.push( v );\n\n    }\n\n    if ( ans == false ) {\n      cout << \"No\" << endl;\n    }\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) for(auto x : v){cout << x << \" \";} cout << endl\n#define printVS(vs) for(auto x : vs){cout << x << endl;}\n#define printVV(vv) for(auto v : vv){for(auto&& x : v){cout << x << \" \";}cout << endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto p : vp) printP(p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\n// typedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\ntypedef vector<vector<int>> Graph;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\ntypedef tuple<int, int, int, int> TUPLE;\n\nconst int MAX_H = 52;\nconst int MAX_W = 52;\nbool done[MAX_H][MAX_W][MAX_H][MAX_W];\nvector<vector<string>> s;\nint H, W;\nvector<int> sx(2), sy(2), gx(2), gy(2);\n\n// N, E, S, W\n// kagamiawase\nconst int dx[2][4] = {\n    {-1,  0,  1,  0},\n    {-1,  0,  1,  0}\n};\nconst int dy[2][4] = {\n    { 0,  1,  0, -1},\n    { 0, -1,  0,  1}\n};\n\nbool bfs() {\n    queue<TUPLE> que;\n    que.emplace(sx[0], sy[0], sx[1], sy[1]);\n    done[sx[0]][sy[0]][sx[1]][sy[1]] = true;\n    while (!que.empty()) {\n        int x0, y0, x1, y1;\n        tie(x0, y0, x1, y1) = que.front(); que.pop();\n        if (x0 == gx[0] && y0 == gy[0] && x1 == gx[1] && y1 == gy[1]) return true;\n        rep(k, 4) {\n            int nx0 = x0 + dx[0][k];\n            int ny0 = y0 + dy[0][k];\n            int nx1 = x1 + dx[1][k];\n            int ny1 = y1 + dy[1][k];\n\n            if ((nx0 == gx[0] && ny0 == gy[0]) ^ (nx1 == gx[1] && ny1 == gy[1])) {\n                continue;\n            }\n\n            if (!done[nx0][ny0][nx1][ny1] && s[0][nx0][ny0] == '.' && s[1][nx1][ny1] == '.') {\n                que.emplace(nx0, ny0, nx1, ny1);\n                done[nx0][ny0][nx1][ny1] = true;\n            } else if (!done[nx0][ny0][x1][y1] && s[0][nx0][ny0] == '.' && s[1][nx1][ny1] == '#') {\n                que.emplace(nx0, ny0, x1, y1);\n                done[nx0][ny0][x1][y1] = true;\n            } else if (!done[x0][y0][nx1][ny1] && s[0][nx0][ny0] == '#' && s[1][nx1][ny1] == '.') {\n                que.emplace(x0, y0, nx1, ny1);\n                done[x0][y0][nx1][ny1] = true;\n            }\n        }\n    }\n    return false;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int t = 0;\n    while (cin >> W >> H, W) {\n        H += 2;\n        W += 2;\n\n        s.clear(); s.resize(2, vector<string>(H, string(W, '#')));\n        rep2(i, 1, H - 1) {\n            rep(b, 2) {\n                cin >> s[b][i];\n                s[b][i] = \"#\" + s[b][i] + \"#\";\n            }\n        }\n\n        rep(b, 2) {\n            rep(i, H) {\n                rep(j, W) {\n                    if (s[b][i][j] == (b ? 'R' : 'L')) {\n                        sx[b] = i, sy[b] = j;\n                        s[b][i][j] = '.';\n                    }\n                    if (s[b][i][j] == '%') {\n                        gx[b] = i, gy[b] = j;\n                        s[b][i][j] = '.';\n                    }\n                }\n            }\n        }\n\n        rep(x0, H) rep(y0, W) rep(x1, H) rep(y1, W) done[x0][y0][x1][y1] = false;\n        cout << (bfs() ? \"Yes\" : \"No\") << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconst int dr[4] = {-1, 0, 1, 0};\nconst int dc[4] = {0, 1, 0, -1};\n\nbool used[2510][2510];\nint roomL[51][51], roomR[51][51];\n\ninline int s_to_i(char c) {\n  switch (c) {\n  case '#':\n    return -1;\n  case '.':\n    return 0;\n  case 'L':\n  case 'R':\n    return 1;\n  case '%':\n    return 2;\n  }\n}\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while (true) {\n    int R, C;\n    cin >> C >> R;\n    if (R == 0 && C == 0) break;\n    REP(i, R) {\n      string rowL, rowR;\n      cin >> rowL >> rowR;\n      REP(j, C) {\n\troomL[i][j] = s_to_i(rowL[j]);\n\troomR[i][j] = s_to_i(rowR[j]);\n      }\n    }\t  \n\n    int sl = 0, el = 0, sr = 0, er = 0;\n    REP(r, R) REP(c, C) {\n      if (roomL[r][c] == 1) sl = r * C + c;\n      else if (roomL[r][c] == 2) el = r * C + c;\n      if (roomR[r][c] == 1) sr = r * C + c;\n      else if (roomR[r][c] == 2) er = r * C + c;\n    }\n    //cout << slr << ' ' << slc << ' ' << elr << ' ' << elc << ' ' << srr << ' ' << src << ' ' << err << ' ' << erc << endl;\n    REP(i, R*C) REP(j, R*C) used[i][j] = false;\n    \n    queue<P> que;\n    que.push(P(sl, sr));\n\n    bool flag = false;\n    while (!que.empty()) {\n      P p = que.front(); que.pop();\n      int l = p.first, r = p.second, lr = p.first / C, lc = p.first % C, rr = p.second / C, rc = p.second % C;\n      //cout << lr << ' ' << lc << ' ' << rr << ' ' << rc << endl;\n      if (l == el && r == er) {\n\tflag = true;\n\tbreak;\n      } else if (used[l][r] || l == el || r == er) {\n\tcontinue;\n      }\n\n      used[l][r] = true;\n      REP(i, 4) {\n\tint nlr = lr + dr[i], nlc = lc + dc[i], nrr = rr + dr[(i+2*(i&1))%4], nrc = rc + dc[(i+2*(i&1))%4];\n\tif (nlr < 0 || nlr >= R || nlc < 0 || nlc >= C || roomL[nlr][nlc] == -1) nlr = lr, nlc = lc;\n\tif (nrr < 0 || nrr >= R || nrc < 0 || nrc >= C || roomR[nrr][nrc] == -1) nrr = rr, nrc = rc;\n\tif (!used[nlr * C + nlc][nrr * C + nrc]) que.push(P(nlr * C + nlc, nrr * C + nrc));\n      }\n    }\n    cout << (flag ? \"Yes\" : \"No\") << endl;    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, k, n) for (int i = (int)(k); i < (int)(n); i++)\n#define rrep(i, n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rREP(i, k, n) for (int i = (int)(n)-1; i >= k; i--)\n\n#define debug(x) cerr << #x << \": \" << x << endl;\n\n#define fi first\n#define se second\n\n#define vi vector<int>\n#define pii pair<int, int>\n#define pb push_back\n#define mp make_pair\n\n#define pcnt __builtin_popcount\n\ntypedef long long ll;\n\nconst int    inf = 100100100;\nconst int    MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\nconst int    dx[4] = {0, 1, 0, -1};\nconst int    dy[4] = {1, 0, -1, 0};\n\nstruct POINT {\n    int lx;\n    int ly;\n    int rx;\n    int ry;\n};\n\nbool u[55][55][55][55] = {};\nint  main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    int    w, h;\n    string ML[55], MR[55];\n    int    slx, sly, srx, sry;\n    while (cin >> w >> h, w) {\n        rep(y, h) cin >> ML[y] >> MR[y];\n        rep(y, h) rep(x, w) {\n            if (ML[y][x] == 'L') slx = x, sly = y;\n            if (MR[y][x] == 'R') srx = x, sry = y;\n        }\n        queue<POINT> que;\n        que.push(POINT{slx, sly, srx, sry});\n\n        bool flag = false;\n        while (!que.empty()) {\n            POINT p = que.front();\n            que.pop();\n            if (u[p.lx][p.ly][p.rx][p.ry]) continue;\n            rep(i, 4) {\n                int  nlx = p.lx + dx[i];\n                int  nly = p.ly + dy[i];\n                int  nrx = p.rx + dx[(i + 2) % 4];\n                int  nry = p.ry + dy[i];\n                bool left_do = true;\n                bool right_do = true;\n                if (nlx < 0 || w <= nlx) left_do = false;\n                if (nly < 0 || h <= nly) left_do = false;\n                if (ML[nly][nlx] == '#') left_do = false;\n                if (nrx < 0 || w <= nrx) right_do = false;\n                if (nry < 0 || h <= nry) right_do = false;\n                if (MR[nry][nrx] == '#') right_do = false;\n                if (ML[nly][nlx] == '%' && MR[nry][nrx] == '%') {\n                    flag = true;\n                    while (!que.empty()) que.pop();\n                    break;\n                } else if (ML[nly][nlx] == '%' || MR[nry][nrx] == '%') {\n                    continue;\n                }\n                if (!left_do && !right_do) continue;\n                if (!left_do) nlx = p.lx, nly = p.ly;\n                if (!right_do) nrx = p.rx, nry = p.ry;\n                que.push(POINT{nlx, nly, nrx, nry});\n            }\n            u[p.lx][p.ly][p.rx][p.ry] = true;\n        }\n        if (flag)\n            cout << \"Yes\" << endl;\n        else\n            cout << \"No\" << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<cstring>\n#include<map>\nusing namespace std;\ntypedef pair< int, int > Pi;\n\nbool used[50][50][50][50];\nchar masL[50][50], masR[50][50];\nint W, H;\nPi RinS, LenS; //スタート\nconst int dy[] = { 1, 0, -1, 0}, dx[] = { 0, 1, 0, -1};\n\nbool isover(int y, int x){\n  return y < 0 || y >= H || x < 0 || x >= W;\n}\n\nint bfs(){\n  queue< Pi > Rin, Len;\n  Rin.push(RinS);\n  Len.push(LenS);\n  used[RinS.first][RinS.second][LenS.first][LenS.second] = true;\n  while(!Rin.empty()){\n    Pi r = Rin.front(), l = Len.front();\n    Rin.pop(), Len.pop();\n    if(masL[l.first][l.second] == '%' && masR[r.first][r.second] == '%'){\n      return true;\n    }\n    if(masL[l.first][l.second] != '%' && masR[r.first][r.second] != '%'){\n      for(int i = 0; i < 4; i++){\n        int rny = min( H - 1, max( 0, r.first + dy[i]));\n        int rnx = min( W - 1, max( 0, r.second + dx[i]));\n        int lny = min( H - 1, max( 0, l.first + dy[i]));\n        int lnx = min( W - 1, max( 0, l.second - dx[i]));\n        //めんどい\n        if(masR[lny][lnx] == '#'){ //元の位置に戻す！！\n          lny = l.first, lnx = l.second;\n        }\n        if(masL[rny][rnx] == '#'){\n          rny = r.first, rnx = r.second;\n        }\n        \n        if(!used[rny][rnx][lny][lnx]){\n          used[rny][rnx][lny][lnx] = true;\n          Rin.push( Pi( rny, rnx)), Len.push( Pi( lny, lnx));\n        }\n      }\n    }\n  }\n  return false; //いけない!!\n}\nint main()\n{\n  while(cin >> W >> H, W){\n    memset( used, false, sizeof(used));\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n        cin >> masL[i][j];\n        if(masL[i][j] == 'L'){\n          LenS = Pi( i, j);\n          masL[i][j] = '.';\n        }\n      }\n      for(int j = 0; j < W; j++){\n        cin >> masR[i][j];\n        if(masR[i][j] == 'R'){\n          RinS = Pi( i, j);\n          masR[i][j] = '.';\n        }\n      }\n    }\n    bool judge = bfs();\n    if(judge) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#include<bitset>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<cmath>\n#include<utility>\n#include<functional>\n#include<map>\n#include<set>\n#include<cctype>\n\n\n#define FOR(i, a, b) for( int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for( int i=(a);i>=(b);i--)\n#define LFOR(i, a, b) for( long long int i=(a);i<=(b);i++)\n#define LRFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LLINF 1000000000000000000 //9000000000000000000\n#define PI 3.14159265358979\n#define MAXI 7500000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\n\nint dy[4] = { 0,0,1,-1 };\nint dx[4] = { 1,-1,0,0 };\n\n//int dp[50][50][50][50] = {};//ly,lx,ry,rx\n\n\nint main(void) {\n\t\n\twhile (1) {\n\t\tbool flag = false;\n\t\tint w, h;\n\t\tint lx = -1, ly = -1, rx = -1, ry = -1;\n\t\tint lgx = -1, lgy = -1, rgx = -1, rgy = -1;\n\n\t\tvector< vector< vector< vector<int> > > > dp(50, vector< vector< vector<int > > >(50, vector< vector<int> >(50, vector<int>(50, 0))));\n\t\t\n\n\t\tpair< pair<int, int>, pair<int, int> > Pair;\n\n\t\tqueue<pair< pair<int, int>, pair<int, int > > > que;\n\n\t\tcin >> w >> h;\n\n\t\tif (w == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tvector<string> left(h), right(h);\n\n\t\tFOR(i, 0, h-1) {\n\t\t\tcin >> left[i] >> right[i];\n\t\t}\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (left[i][j] == 'L') {\n\t\t\t\t\tlx = j;\n\t\t\t\t\tly = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (right[i][j] == 'R') {\n\t\t\t\t\trx = j;\n\t\t\t\t\try = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (left[i][j] == '%') {\n\t\t\t\t\tlgx = j;\n\t\t\t\t\tlgy = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lgx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (right[i][j] == '%') {\n\t\t\t\t\trgx = j;\n\t\t\t\t\trgy = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rgx != -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdp[ly][lx][ry][rx] = 1;\n\n\t\t\n\t\t\n\t\tque.push(make_pair(make_pair(ly,lx),make_pair(ry,rx)));\n\n\n\t\twhile (!que.empty()) {\n\t\t\tPair = que.front();\n\t\t\t\n\t\t\tque.pop();\n\t\t\tly = Pair.first.first;\n\t\t\tlx = Pair.first.second;\n\t\t\try = Pair.second.first;\n\t\t\trx = Pair.second.second;\n\t\t\t//cout << ly << \" \" << lx << \" \" << ry << \" \" << rx << endl;\n\n\t\t\tFOR(i, 0, 3) {\n\t\t\t\t\n\t\t\t\tif (ly + dy[i] >= 0 && lx - dx[i] >= 0 && ry + dy[i] <= h - 1 && rx + dx[i] <= w - 1 && ly + dy[i] <= h - 1 && lx - dx[i] <= w - 1 && ry + dy[i] >= 0 && rx + dx[i] >= 0) {\n\t\t\t\t\tif (dp[ly + dy[i]][lx - dx[i]][ry + dy[i]][rx + dx[i]] != 1) {\n\t\t\t\t\t\tif (left[ly + dy[i]][lx - dx[i]] == '#') {\n\t\t\t\t\t\t\tif (right[ry + dy[i]][rx + dx[i]] == '#') {\n\t\t\t\t\t\t\t\t//no\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdp[ly][lx][ry + dy[i]][rx + dx[i]] = 1;\n\t\t\t\t\t\t\t\tque.push(make_pair(make_pair(ly, lx), make_pair(ry + dy[i], rx + dx[i])));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (right[ry + dy[i]][rx + dx[i]] == '#') {\n\t\t\t\t\t\t\t\tdp[ly + dy[i]][lx - dx[i]][ry][rx] = 1;\n\t\t\t\t\t\t\t\tque.push(make_pair(make_pair(ly + dy[i], lx - dx[i]), make_pair(ry, rx)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdp[ly + dy[i]][lx - dx[i]][ry + dy[i]][rx + dx[i]] = 1;\n\t\t\t\t\t\t\t\tque.push(make_pair(make_pair(ly + dy[i], lx - dx[i]), make_pair(ry + dy[i], rx + dx[i])));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dp[lgy][lgx][rgy][rgx] == 1) {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (dp[lgy][lgx][rgy][rgx] == 1||flag==true) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t\t\n\n\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// tsukasa_diary's programing contest code template\n#include <bits/stdc++.h>\nusing namespace std;\n// define\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n// typedef\ntypedef long long lint;\ntypedef double Double;\ntypedef pair<int, int> pii;\n//\ntypedef vector< int > Array;\ntypedef vector< Array > Matrix;\ntypedef vector< Double > DArray;\ntypedef vector< DArray > DMatrix;\ntypedef vector< string > SArray;\ntypedef vector< pii > PArray;\n// popcount\ninline int POPCNT(int _x) { return __builtin_popcount(_x); }\ninline int POPCNT(lint _x) { return __builtin_popcountll(_x); }\n// inf\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\n// eps\nDouble EPS = 1e-9;\n// in range\ninline bool in_range(int _v, int _mx, int _mi) { return _mi <= _v && _v < _mx; }\ninline bool in_range(Double _v, Double _mi, Double _mx) { return -EPS < _v - _mi && _v - _mx < EPS; }\ninline bool in_range(int _x, int _y, int _W, int _H) { return 0 <= _x && _x < _W && 0 <= _y && _y < _H; }\n// neighbor clockwise\nconst int DX[4] = {0,1,0,-1}, DY[4] = {-1,0,1,0};\nconst int DX_[8] = {0,1,1,1,0,-1,-1,-1}, DY_[8] = {-1,-1,0,1,1,1,0,-1};\n\nint W, H;\nint srx, sry, slx, sly;\nstring roomL[55], roomR[55];\n\nbool visit[55][55][55][55];\n\nbool rec(int lx, int ly, int rx, int ry) {\n\tif (visit[ly][lx][ry][rx]) return false;\n\tvisit[ly][lx][ry][rx] = true;\n\tif (roomL[ly][lx] == '%' && roomR[ry][rx] == '%') return true;\n\t\n\tfor_(d,0,4) {\n\t\tint nlx = lx + DX[d], nly = ly + DY[d];\n\t\tint nrx = rx, nry = ry;\n\t\tif (d != 0 && d != 2) nrx += DX[(d + 2) % 4], nry += DY[(d + 2) % 4];\n\t\telse nrx += DX[d], nry += DY[d];\n\n\t\tif (!in_range(nlx, nly, W, H)) {\n\t\t\tnlx = lx;\n\t\t\tnly = ly;\n\t\t} else if (roomL[nly][nlx] == '#') {\n\t\t\tnlx = lx;\n\t\t\tnly = ly;\n\t\t}\n\t\t\n\t\tif (!in_range(nrx, nry, W, H)) {\n\t\t\tnrx = rx;\n\t\t\tnry = ry;\n\t\t} else if (roomR[nry][nrx] == '#') {\n\t\t\tnrx = rx;\n\t\t\tnry = ry;\n\t\t}\n\t\t\n\t\tif (rec(nlx, nly, nrx, nry)) return true;\n\t}\n\t\n\treturn false;\n}\n\nvoid solve() {\n\tminit(visit, 0);\n\t\n\tif (rec(slx, sly, srx, sry)) {\n\t\tcout << \"Yes\" << endl;\n\t} else {\n\t\tcout << \"No\" << endl;\n\t}\n}\n\nint main() {\n\twhile (cin >> W >> H, W) {\n\t\tfor_(i,0,H) {\n\t\t\tcin >> roomL[i] >> roomR[i];\n\t\t\tfor_(j,0,W) {\n\t\t\t\tif (roomL[i][j] == 'L') slx = j, sly = i;\n\t\t\t\tif (roomR[i][j] == 'R') srx = j, sry = i;\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint dy[] = {1, -1, 0, 0};\nint dx[] = {0, 0, 1, -1};\n\nint toHash(int y1, int x1, int y2, int x2)\n{\n    return ((y1 * 52 + x1) * 52 + y2) * 52 + x2;\n}\n\nvoid fromHash(int hash, int& y1, int& x1, int& y2, int& x2)\n{\n    x2 = hash % 52;\n    hash /= 52;\n    y2 = hash % 52;\n    hash /= 52;\n    x1 = hash % 52;\n    hash /= 52;\n    y1 = hash % 52;\n}\n\nint main()\n{\n    for(;;){\n        int h, w;\n        cin >> w >> h;\n        if(h == 0)\n            return 0;\n\n        int sy1, sx1, sy2, sx2;\n        vector<string> grid1(h+2, string(w+2, '#'));\n        vector<string> grid2(h+2, string(w+2, '#'));\n        for(int i=1; i<=h; ++i){\n            for(int j=1; j<=w; ++j){\n                cin >> grid1[i][j];\n                if(grid1[i][j] == 'L'){\n                    sy1 = i;\n                    sx1 = j;\n                }\n            }\n            for(int j=1; j<=w; ++j){\n                cin >>grid2[i][j];\n                if(grid2[i][j] == 'R'){\n                    sy2 = i;\n                    sx2 = j;\n                }\n            }\n        }\n\n        queue<int> q;\n        vector<bool> history(52*52*52*52, false);\n        q.push(toHash(sy1, sx1, sy2, sx2));\n        history[toHash(sy1, sx1, sy2, sx2)] = true;\n\n        bool ret = false;\n        while(!q.empty()){\n            int y1, x1, y2, x2;\n            fromHash(q.front(), y1, x1, y2, x2);\n            q.pop();\n            if(grid1[y1][x1] == '%' && grid2[y2][x2] == '%'){\n                ret = true;\n                break;\n            }\n            if(grid1[y1][x1] == '%' || grid2[y2][x2] == '%')\n                continue;\n\n            for(int i=0; i<4; ++i){\n                int y3 = y1 + dy[i];\n                int x3 = x1 + dx[i];\n                int y4 = y2 + dy[i];\n                int x4 = x2 + dx[i^1];\n\n                if(grid1[y3][x3] == '#'){\n                    y3 -= dy[i];\n                    x3 -= dx[i];\n                }\n                if(grid2[y4][x4] == '#'){\n                    y4 -= dy[i];\n                    x4 -= dx[i^1];\n                }\n\n                int hash = toHash(y3, x3, y4, x4);\n                if(!history[hash]){\n                    q.push(hash);\n                    history[hash] = true;\n                }\n            }\n        }\n\n        if(ret)\n            cout << \"Yes\" << endl;\n        else\n            cout << \"No\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 1e9 + 7;\n\nint dx1[4] = {1, 0, -1, 0}, dy1[4] = {0, 1, 0, -1};\nint dx2[4] = {1, 0, -1, 0}, dy2[4] = {0, -1, 0, 1};\nbool visit[60][60][60][60];\nstring room1[60], room2[60];\n\nstruct Position\n{\n    int sx1, sy1, sx2, sy2;\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int w, h;\n    while (cin >> w >> h, w || h)\n    {\n        string str = \"\";\n        for (int i = 0; i <= w + 1; i++)\n            str += '#';\n        room1[0] = room2[0] = room1[h + 1] = room2[h + 1] = str;\n        for (int i = 1; i <= h; i++)\n        {\n            string s1, s2;\n            cin >> s1 >> s2;\n            room1[i] = '#' + s1 + '#';\n            room2[i] = '#' + s2 + '#';\n        }\n        int sx1 = -1, sy1 = -1, sx2 = -1, sy2 = -1;\n        for (int i = 1; i <= h; i++)\n        {\n            for (int j = 1; j <= w; j++)\n            {\n                if (room1[i][j] == 'L')\n                {\n                    sx1 = i;\n                    sy1 = j;\n                    room1[i][j] = '.';\n                }\n                if (room2[i][j] == 'R')\n                {\n                    sx2 = i;\n                    sy2 = j;\n                    room2[i][j] = '.';\n                }\n            }\n        }\n        memset(visit, 0, sizeof(visit));\n        queue<Position> que;\n        visit[sx1][sy1][sx2][sy2] = true;\n        que.push(Position{sx1, sy1, sx2, sy2});\n        bool f = false;\n        while (!que.empty())\n        {\n            if (f)\n                break;\n            Position pos = que.front();\n            que.pop();\n            for (int i = 0; i < 4; i++)\n            {\n                int nx1 = pos.sx1 + dx1[i], ny1 = pos.sy1 + dy1[i], nx2 = pos.sx2 + dx2[i], ny2 = pos.sy2 + dy2[i];\n                char c1 = room1[nx1][ny1], c2 = room2[nx2][ny2];\n                if (c1 == '#' && c2 == '#')\n                    continue;\n                if (c1 == '%' && c2 == '%')\n                {\n                    f = true;\n                    break;\n                }\n                if (c1 == '%' || c2 == '%')\n                    continue;\n                if (visit[nx1][ny1][nx2][ny2])\n                    continue;\n                if (c1 == '#')\n                {\n                    if (visit[pos.sx1][pos.sy1][nx2][ny2])\n                        continue;\n                    visit[pos.sx1][pos.sy1][nx2][ny2] = true;\n                    que.push(Position{pos.sx1, pos.sy1, nx2, ny2});\n                }\n                else if (c2 == '#')\n                {\n                    if (visit[nx1][ny1][pos.sx2][pos.sy2])\n                        continue;\n                    visit[nx1][ny1][pos.sx2][pos.sy2] = true;\n                    que.push(Position{nx1, ny1, pos.sx2, pos.sy2});\n                }\n                else\n                {\n                    if (visit[nx1][ny1][nx2][ny2])\n                        continue;\n                    visit[nx1][ny1][nx2][ny2] = true;\n                    que.push(Position{nx1, ny1, nx2, ny2});\n                }\n            }\n        }\n        if (f)\n            cout << \"Yes\" << endl;\n        else\n            cout << \"No\" << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<queue>\nusing namespace std;\n#define REP(i, a, n) for(int i=a; i<n; i++)\n\nbool hist[51][51][51][51];\n\nstruct State {\n\tint xL, yL, xR, yR;\n};\n\nint main() {\n\tint w, h;\n\n\tint dx[4] = { 0, 1, 0, -1 }; // ????????????\n\tint dy[4] = { -1, 0, 1, 0 };\n\n\twhile (cin >> w >> h, w || h) {\n\t\tState st;\n\t\tchar Len[51][51];\n\t\tchar Rin[51][51];\n\t\t//bool hist[51][51][51][51] = { false };\n\t\thist[51][51][51][51] = { false };\n\n\t\t/* crate maze */\n\t\tREP(i, 0, h) {\n\t\t\tREP(j, 0, w) {\n\t\t\t\tcin >> Len[i][j];\n\t\t\t\tif (Len[i][j] == 'L') {\n\t\t\t\t\tst.yL = i;\n\t\t\t\t\tst.xL = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(j, 0, w) {\n\t\t\t\tcin >> Rin[i][j];\n\t\t\t\tif (Rin[i][j] == 'R') {\n\t\t\t\t\tst.yR = i;\n\t\t\t\t\tst.xR = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* BFS */\n\t\tqueue<State> qu;\n\t\tqu.push(st);\n\t\thist[st.yL][st.xL][st.yR][st.xR] = true;\n\t\tbool flag = false;\n\n\t\twhile (!qu.empty()) {\n\t\t\tState q = qu.front();\n\t\t\tqu.pop();\n\n\t\t\tint yl = q.yL, xl = q.xL, yr = q.yR, xr = q.xR;\n\t\t\tif (Len[yl][xl] == '%' && Rin[yr][xr] == '%') {\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (Len[yl][xl] == '%' || Rin[yr][xr] == '%') continue;\n\t\t\tfor (int k = 0; k<4; ++k) {\n\t\t\t\tint yyl = yl + dy[k], xxl = xl + dx[k];\n\t\t\t\tint yyr, xxr;\n\t\t\t\tyyr = yr + dy[k];\n\t\t\t\txxr = xr + dx[k] * (-1);\n\n\t\t\t\tif (yyl<0 || yyl >= h || xxl<0 || xxl >= w) {\n\t\t\t\t\tyyl = yl;\n\t\t\t\t\txxl = xl;\n\t\t\t\t}\n\t\t\t\telse if (Len[yyl][xxl] == '#') {\n\t\t\t\t\tyyl = yl;\n\t\t\t\t\txxl = xl;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (yyr<0 || yyr >= h || xxr<0 || xxr >= w) {\n\t\t\t\t\tyyr = yr;\n\t\t\t\t\txxr = xr;\n\t\t\t\t}\n\t\t\t\telse if (Rin[yyr][xxr] == '#') {\n\t\t\t\t\tyyr = yr;\n\t\t\t\t\txxr = xr;\n\t\t\t\t}\n\t\t\t\tif (hist[yyl][xxl][yyr][xxr]) continue;\n\t\t\t\thist[yyl][xxl][yyr][xxr] = true;\n\t\t\t\tqu.push({ yyl, xxl, yyr, xxr });\n\t\t\t\t//cout << yyl << \" \" << xxl << \" \" << yyr << \" \" << xxr << endl;\n\t\t\t}\n\t\t}\n\t\tif (flag) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t\t/*\n\t\tREP(i, 0, h) {\n\t\t\tREP(j, 0, w) {\n\t\t\t\tcout << Len[i][j];\n\t\t\t}\n\t\t\tcout << \" \";\n\t\t\tREP(j, 0, w) {\n\t\t\t\tcout << Rin[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n\n#define ll long long int\n\nusing namespace std;\n\nconst int INF = (1<<30) - 1;\n\n//lh, lw, rh, rw\ntypedef tuple<int, int, int, int> State;\n\nint dh[] = {0, 1, 0, -1};\nint dw[] = {1, 0, -1, 0};\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    int H, W;\n    while(cin>>W>>H, H|W){\n        vector<string> L(H), R(H);\n        for(int i=0; i<H; i++)\n            cin >> L[i] >> R[i];\n        \n        set<State> dp;\n        queue<State> que;\n        \n        int lh, lw, rh, rw;\n        int glh, glw, grh, grw;\n        for(int h=0; h<H; h++)\n            for(int w=0; w<W; w++)\n                if(L[h][w] == 'L'){\n                    lh = h; lw = w;\n                }else if(L[h][w] == '%'){\n                    glh = h; glw = w;\n                }\n        for(int h=0; h<H; h++)\n            for(int w=0; w<W; w++)\n                if(R[h][w] == 'R'){\n                    rh = h; rw = w;\n                }else if(R[h][w] == '%'){\n                    grh = h; grw = w;\n                }\n        \n        auto start = State(lh, lw, rh, rw);\n        dp.insert(start);\n        que.push(start);\n        \n        while(!que.empty()){\n            tie(lh, lw, rh, rw) = que.front(); que.pop();\n            \n            for(int i=0; i<4; i++){\n                int nlh = lh + dh[i], nlw = lw + dw[i];\n                int nrh = rh + dh[i], nrw = rw + dw[i] * -1;\n                \n                if(nlh<0 || H<=nlh || nlw<0 || W<=nlw || L[nlh][nlw]=='#'){\n                    nlh = lh; nlw = lw;\n                }\n                if(nrh<0 || H<=nrh || nrw<0 || W<=nrw || R[nrh][nrw]=='#'){\n                    nrh = rh; nrw = rw;\n                }\n                \n                State next = State(nlh, nlw, nrh, nrw);\n                if(dp.count(next) == 0){\n                    dp.insert(next);\n                    que.push(next);\n                }\n            }\n        }\n        cout << (dp.count(State(glh, glw, grh, grw)) ? \"YES\" : \"NO\") << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\n//[int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }; int dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\n/*--------------------template--------------------*/\nint n;\nint hs(int x, int y) { return x*n + y; }\nvector<bool> st;\nint main()\n{\n\tint w, h;\n\twhile (cin >> w >> h, w)\n\t{\n\t\tvs fldl(h), fldr(h);\n\t\tREP(i, h) cin >> fldl[i] >> fldr[i];\n\t\tn = w*h;\n\t\tst.clear();\n\t\tst.resize(n*n);\n\t\tint rx, ry, lx, ly;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tif (fldl[i][j] == 'L')\n\t\t\t{\n\t\t\t\tfldl[i][j] = '.';\n\t\t\t\tlx = i, ly = j;\n\t\t\t}\n\t\t\tif (fldr[i][j] == 'R')\n\t\t\t{\n\t\t\t\tfldr[i][j] = '.';\n\t\t\t\trx = i, ry = j;\n\t\t\t}\n\t\t}\n\t\tqueue<int> que;\n\t\tst[hs(place(lx, ly, w), place(rx, ry, w))] = true;\n\t\tque.push(hs(place(lx, ly, w), place(rx, ry, w)));\n\t\tbool ans = false;\n\t\twhile (que.size())\n\t\t{\n\t\t\tint tmp = que.front();\n\t\t\tque.pop();\n\t\t\tint tl = tmp / n, tr = tmp%n;\n\t\t\tint lx = tl / w, ly = tl%w;\n\t\t\tint rx = tr / w, ry = tr%w;\n\t\t\tif (fldl[lx][ly] == '%' || fldr[rx][ry] == '%')\n\t\t\t{\n\t\t\t\tif (fldl[lx][ly] == '%' && fldr[rx][ry] == '%')\n\t\t\t\t{\n\t\t\t\t\tans = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse continue;\n\t\t\t}\n\t\t\tREP(i, 4)\n\t\t\t{\n\t\t\t\tint lnx, lny, rnx, rny;\n\t\t\t\tif (valid(lx + dx[i], ly + dy[i], h, w) && fldl[lx + dx[i]][ly + dy[i]] != '#')\n\t\t\t\t{\n\t\t\t\t\tlnx = lx + dx[i], lny = ly + dy[i];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlnx = lx, lny = ly;\n\t\t\t\t}\n\t\t\t\tif (valid(rx + dx[i], ry - dy[i], h, w) && fldr[rx + dx[i]][ry - dy[i]] != '#')\n\t\t\t\t{\n\t\t\t\t\trnx = rx + dx[i], rny = ry - dy[i];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\trnx = rx, rny = ry;\n\t\t\t\t}\n\t\t\t\tint next = hs(place(lnx, lny, w), place(rnx, rny, w));\n\t\t\t\tif (!st[next])\n\t\t\t\t{\n\t\t\t\t\tst[next] = true;\n\t\t\t\t\tque.push(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(ans ? \"Yes\" : \"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nstruct POINT\n{\n\tint x, y;\n\tbool operator<(const POINT &t)const{\n\t\tif (x == t.x) return y < t.y;\n\t\treturn x < t.x;\n\t}\n\tbool operator==(const POINT &t)const{\n\t\treturn x == t.x && y == t.y;\n\t}\n};\n\nstruct P\n{\n\tPOINT l, r;\n\tbool operator<(const P &t)const{\n\t\tif (l == t.l) return r < t.r;\n\t\treturn l < t.l;\n\t}\n};\n\nchar g1[64][64], g2[64][64];\n\nint main()\n{\n\tint w, h;\n\twhile (scanf(\"%d %d\", &w, &h), w + h){\n\t\tmemset(g1, '#', sizeof(g1));\n\t\tmemset(g2, '#', sizeof(g2));\n\t\t\n\t\tPOINT L, R;\n\t\tfor (int i = 1; i <= h; i++){\n\t\t\tfor (int j = 1; j <= w; j++){\n\t\t\t\tscanf(\" %c\", &g1[i][j]);\n\t\t\t\tif (g1[i][j] == 'L'){\n\t\t\t\t\tL = {i, j};\n\t\t\t\t\tg1[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = w; j >= 1; j--){\n\t\t\t\tscanf(\" %c\", &g2[i][j]);\n\t\t\t\tif (g2[i][j] == 'R'){\n\t\t\t\t\tR = {i, j};\n\t\t\t\t\tg2[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<P> que;\n\t\tset<P> done;\n\t\tbool res = false;\n\t\tfor (que.push({L, R}); !que.empty(); que.pop()){\n\t\t\tP p = que.front();\n\t\t\t\n\t\t\t//printf(\"%d %d %d %d\\n\", p.l.x, p.l.y, p.r.x, p.r.y);\n\t\t\t\n\t\t\tif (done.count(p)) continue;\n\t\t\tdone.insert(p);\n\t\t\t\n\t\t\tif (g1[p.l.x][p.l.y] == '%' && g2[p.r.x][p.r.y] == '%'){\n\t\t\t\tres = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (g1[p.l.x][p.l.y] == '%' || g2[p.r.x][p.r.y] == '%'){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\t\tint ltx = p.l.x + dx[dir];\n\t\t\t\tint lty = p.l.y + dy[dir];\n\t\t\t\tint rtx = p.r.x + dx[dir];\n\t\t\t\tint rty = p.r.y + dy[dir];\n\t\t\t\t\n\t\t\t\tif (g1[ltx][lty] == '#'){\n\t\t\t\t\tltx = p.l.x;\n\t\t\t\t\tlty = p.l.y;\n\t\t\t\t}\n\t\t\t\tif (g2[rtx][rty] == '#'){\n\t\t\t\t\trtx = p.r.x;\n\t\t\t\t\trty = p.r.y;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tque.push({{ltx, lty}, {rtx, rty}});\n\t\t\t}\n\t\t}\n\t\tprintf(res ? \"Yes\\n\" : \"No\\n\");\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint w, h; \nstruct Pos {\n  int x;\n  int y;\n  bool operator==(Pos that) {\n    return x == that.x && y == that.y;\n  }\n  Pos operator+(Pos that) {\n    return {x+that.x, y+that.y};\n  }\n\n  Pos (int xx, int yy) {\n    x = xx; y = yy;\n  }\n};\n\nbool inner(Pos p) {\n  return 0 <= p.x && p.x < w\n      && 0 <= p.y && p.y < h;\n}\n\nPos search_charactor(vector<string> &map, char charactor) {\n  for (int i=0; i<map.size(); i++)\n    for (int l=0; l<map[i].size(); l++)\n      if (map[i][l] == charactor) {\n        map[i][l] = '.';\n        return {l, i};\n      }\n}\n\nbool exnor (bool x, bool y) {\n  return !(x xor y);\n}\n\ntemplate <typename T>\nusing V=vector<T>;\n\nint main(){\n  while (cin >> w >> h, w+h != 0) {\n    vector<string> rooml, roomr;\n    rooml.reserve(h); roomr.reserve(h);\n    for (int i=0; i<h; i++) {\n      string l, r;\n      cin >> l >> r; \n      reverse(r.begin(), r.end());\n      rooml.push_back(l);\n      roomr.push_back(r);\n    }\n    Pos len_pos = search_charactor(rooml, 'L');\n    Pos rin_pos = search_charactor(roomr, 'R');\n    Pos len_goal = search_charactor(rooml, '%');\n    Pos rin_goal = search_charactor(roomr, '%');\n\n    queue<pair<Pos, Pos>> q;\n    q.push(make_pair(len_pos, rin_pos));\n    // cout<<\"goal: (\"<<len_goal.x<<\", \"<<len_goal.y<<\") \"<<\"(\"<<rin_goal.x<<\", \"<<rin_goal.y<<\")\"<<endl;\n    // for (int i=0; i<rooml.size(); i++) {\n    //   cout << rooml[i] << \" \" << roomr[i] << endl;\n    // }\n\n    V<V<V<V<bool>>>> already(h, V<V<V<bool>>>(w, V<V<bool>>(h, V<bool>(w, false))));\n    bool f = true;\n    while (!q.empty()) {\n      Pos len = q.front().first;\n      Pos rin = q.front().second; \n      q.pop();\n      // cout<<\"(\"<<len.x<<\", \"<<len.y<<\") \"<<\"(\"<<rin.x<<\", \"<<rin.y<<\")\"<<endl;\n\n      if (len==len_goal && rin==rin_goal) {\n        cout << \"Yes\" << endl;\n        f = false;\n        break;\n      }\n\n      for (Pos np: {Pos(0,1), Pos(0,-1), Pos(1,0), Pos(-1,0)}) {\n        Pos l = (inner(np+len) && rooml[np.y+len.y][np.x+len.x] == '.') ? len + np : len;\n        Pos r = (inner(np+rin) && roomr[np.y+rin.y][np.x+rin.x] == '.') ? rin + np : rin;\n        if (!already[l.y][l.x][r.y][r.x] && inner(l) && inner(r) \n          && rooml[l.y][l.x] == '.' && roomr[r.y][r.x] == '.'\n          && exnor(l==len_goal, r==rin_goal)) {\n          q.push(make_pair(l, r));\n          already[l.y][l.x][r.y][r.x] = true;\n        }\n      }\n    }\n    if (f) cout << \"No\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#define F first\n#define S second\nusing namespace std;\n\nconst int N = 50 + 1;\nchar l[N][N];\nchar r[N][N];\n\nint r_di[] = { 0,  0, -1, +1};\nint r_dj[] = {-1, +1,  0,  0};\nint l_di[] = { 0,  0, -1, +1};\nint l_dj[] = {+1, -1,  0,  0};\n\nbool vis[N][N][N][N];\n\ntypedef pair< pair<int, int>, pair<int, int> > P;\n\ninline\nbool& ref(P p)\n{\n  pair<int, int> a = p.first;\n  pair<int, int> b = p.second;\n  return vis[a.first][a.second][b.first][b.second];\n}\n\nint main(void)\n{\n  int h, w;\n  while (cin >> w >> h && (h | w)) {\n    fill(&vis[0][0][0][0], &vis[N - 1][N - 1][N - 1][N - 1] + 1, false);\n    pair<int, int> pr, pl;\n    pair<int, int> qr, ql;\n    pr = pl = qr = ql = make_pair(-1, -1);\n    for (int i = 0; i < h; ++i) {\n      string s, t;\n      cin >> s >> t;\n      for (int j = 0; j < s.size(); ++j) {\n\tl[i][j] = s[j];\n\tif (s[j] == 'L') pl = make_pair(i, j);\n\tif (s[j] == '%') ql = make_pair(i, j);\n      }\n      for (int j = 0; j < t.size(); ++j) {\n\tr[i][j] = t[j];\n\tif (t[j] == 'R') pr = make_pair(i, j);\n\tif (t[j] == '%') qr = make_pair(i, j);\n      }\n    }\n    queue<P> q;\n    P ini = make_pair(pl, pr);\n    ref(ini) = true;\n    for (q.push(ini); q.size(); q.pop()) {\n      P p = q.front();\n      pair<int, int> pl = p.first;\n      pair<int, int> pr = p.second;\n      if(l[pl.F][pl.S] == '%' && r[pr.F][pr.S] != '%')continue;\n      if(r[pr.F][pr.S] == '%' && l[pl.F][pl.S] != '%')continue;\n\n      for (int d = 0; d < 4; ++d) {\n\tint pr_i = pr.first  + r_di[d];\n\tint pr_j = pr.second + r_dj[d];\n\tint pl_i = pl.first  + l_di[d];\n\tint pl_j = pl.second + l_dj[d];\n\tif (pr_i < 0 || h <= pr_i) pr_i = pr.first, pr_j = pr.second;\n\tif (pr_j < 0 || w <= pr_j) pr_i = pr.first, pr_j = pr.second;\n\tif (r[pr_i][pr_j] == '#')  pr_i = pr.first, pr_j = pr.second;\n\tif (pl_i < 0 || h <= pl_i) pl_i = pl.first, pl_j = pl.second;\n\tif (pl_j < 0 || w <= pl_j) pl_i = pl.first, pl_j = pl.second;\n\tif (l[pl_i][pl_j] == '#')  pl_i = pl.first, pl_j = pl.second;\n\tP next = make_pair(make_pair(pl_i, pl_j), make_pair(pr_i, pr_j));\n\tif (ref(next)) continue;\n\tref(next) = true;\n\tq.push(next);\n      }\n    }\n    cout << (ref(make_pair(ql, qr)) ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int GOAL = 1;\nconst int WAY = 0;\nconst int WALL = -1;\n\nconst int dx[4] = {-1, 1, 0, 0};\nconst int dy[4] = {0, 0, -1, 1};\n\nint w, h;\nbool visited[52][52][52][52];\nvector<vector<int> > l_map, r_map;\n\nbool dfs(int l_x, int l_y, int r_x, int r_y) {\n\tvisited[l_x][l_y][r_x][r_y] = true;\n\n\tif(l_map[l_y][l_x] == GOAL && r_map[r_y][r_x] == GOAL)\n\t\treturn true;\n\n\tfor(int i = 0; i < 4; ++i) {\n\t\tint l_nx = l_x + dx[i], l_ny = l_y + dy[i], r_nx = r_x - dx[i], r_ny = r_y + dy[i];\n\t\tif(l_map[l_ny][l_nx] == WALL) {\n\t\t\tl_nx = l_x;\n\t\t\tl_ny = r_y;\n\t\t}\n\n\t\tif(r_map[r_ny][r_nx] == WALL) {\n\t\t\tr_nx = r_x;\n\t\t\tr_ny = r_y;\n\t\t}\n\n\t\tif(!visited[l_nx][l_ny][r_nx][r_ny] && dfs(l_nx, l_ny, r_nx, r_ny))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> w >> h, w) {\n\t\tl_map.clear();\n\t\tl_map.resize(h + 2, vector<int>(w + 2, WALL));\n\n\t\tr_map.clear();\n\t\tr_map.resize(h + 2, vector<int>(w + 2, WALL));\n\n\t\tint l_sx, l_sy, r_sx, r_sy;\n\t\tfor(int i = 1; i <= h; ++i) {\n\t\t\tstring l, r;\n\t\t\tcin >> l >> r;\n\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tswitch(l[j]) {\n\t\t\t\tcase '%':\n\t\t\t\t\tl_map[i][j + 1] = GOAL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tl_map[i][j + 1] = WALL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\tl_sx = j + 1;\n\t\t\t\t\tl_sy = i;\n\t\t\t\tdefault:\n\t\t\t\t\tl_map[i][j + 1] = WAY;\n\t\t\t\t}\n\n\t\t\t\tswitch(r[j]) {\n\t\t\t\tcase '%':\n\t\t\t\t\tr_map[i][j + 1] = GOAL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tr_map[i][j + 1] = WALL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tr_sx = j + 1;\n\t\t\t\t\tr_sy = i;\n\t\t\t\tdefault:\n\t\t\t\t\tr_map[i][j + 1] = WAY;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(visited, false, sizeof(visited));\n\t\tcout << (dfs(l_sx, l_sy, r_sx, r_sy) ? \"Yes\" : \"No\") << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint dx1[] = {0,1,0,-1};\nint dy1[] = {-1,0,1,0};\nint dx2[] = {0,-1,0,1};\nint dy2[] = {-1,0,1,0};\n\nbool visited[50][50][50][50];\n\nint w, h;\nchar ba1[50][50];\nchar ba2[50][50];\n\nbool rec(int x1,int y1, int x2, int y2) {\n  // printf(\"(%d,%d),(%d,%d)\\n\",x1,y1,x2,y2);\n  visited[x1][y1][x2][y2] = 1;\n\n  if (ba1[x1][y1] == '%' && ba2[x2][y2] == '%')\n    return 1;\n  else if (ba1[x1][y1] == '%' || ba2[x2][y2] == '%')\n    return 0;\n  REP(i,4) {\n    int xx1 = x1+dx1[i];\n    int yy1 = y1+dy1[i];\n    int xx2 = x2+dx2[i];\n    int yy2 = y2+dy2[i];\n\n    if (xx1<0||xx1>=w||yy1<0||yy1>=h || ba1[xx1][yy1] == '#') {\n      xx1 = x1;\n      yy1 = y1;\n    }\n    if (xx2<0||xx2>=w||yy2<0||yy2>=h || ba2[xx2][yy2] == '#') {\n      xx2 = x2;\n      yy2 = y2;\n    }\n    if (!visited[xx1][yy1][xx2][yy2]) {\n      if (rec(xx1,yy1,xx2,yy2))\n        return 1;\n    }\n  }\n  return 0;\n}\n\nint main() {\n  while(cin >> w>>h, w||h) {\n\n    int sx1,sy1,sx2,sy2;\n    \n    REP(y,h) {\n      REP(x,w) {\n        cin >> ba1[x][y];\n        \n        if (ba1[x][y]=='L') {\n          sx1 = x; sy1 = y;\n        }\n      }\n      REP(x,w) {\n        cin >> ba2[x][y];\n        if (ba2[x][y]=='R') {\n          sx2 = x; sy2 = y;\n        }\n      }\n    }\n    memset(visited, 0, sizeof(visited));\n    if (rec(sx1,sy1,sx2,sy2))\n      cout << \"Yes\" << endl;\n    else\n      cout << \"No\" << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP(a, b) make_pair(a, b)\n#define Y first\n#define X second\n#define L first\n#define R second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef pair<pi, pi> pipi;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint W, H;\nint dy[] = {0,-1,0,1}, dx[] = {-1,0,1,0};\nchar len[64][64], rin[64][64];\n\nint main(){\n  while(scanf(\"%d%d\", &W, &H) && W){\n    rep(i, H) scanf(\"%s%s\", len[i], rin[i]);\n\n    int ly, lx, ry, rx;\n    rep(i, H) rep(j, W){\n      if(len[i][j] == 'L'){ ly = i, lx = j; len[i][j] = '.';}\n      if(rin[i][j] == 'R'){ ry = i, rx = j; rin[i][j] = '.';}\n    }\n\n    pipi p = MP(MP(ly, lx), MP(ry, rx));\n    queue<pipi>q;\n    map<pipi, int>m;\n    q.push(p);\n    m[p] = 1;\n\n    while(!q.empty()){\n      int qsize = (int)q.size();\n      rep(i, qsize){\n\tpipi now = q.front(); q.pop();\n\trep(d, 4){\n\t  int nly, nlx, nry, nrx;\n\t  if(d%2){\n\t    nly = now.L.Y + dy[d], nlx = now.L.X;\n\t    if(nly < 0 || nly >= H || len[nly][nlx] == '#') nly = now.L.Y; \n\t    nry = now.R.Y + dy[d], nrx = now.R.X;\n\t    if(nry < 0 || nry >= H || rin[nry][nrx] == '#') nry = now.R.Y; \n\t  }else{\n\t    nly = now.L.Y, nlx = now.L.X + dx[d];\n\t    if(nlx < 0 || nlx >= W || len[nly][nlx] == '#') nlx = now.L.X; \t    \n\t    nry = now.R.Y, nrx = now.R.X + -1*dx[d];\n\t    if(nrx < 0 || nrx >= W || rin[nry][nrx] == '#') nrx = now.R.X;\n\t  }\n\n\t  //\t  pipi next = MP(MP(nly, nlx), MP(nry, nrx));\n\t  if(len[nly][nlx] == '%' && rin[nry][nrx] == '%'){\n\t    puts(\"Yes\"); goto e;\n\t  }else if(len[nly][nlx] == '%' || rin[nry][nrx] == '%'){\n\t    continue;\n\t  }\n\n\t  if(m.count(MP(MP(nly, nlx), MP(nry, nrx))) != 0) continue;\n\t     //\t  printf(\"%d %d %d %d\\n\", next.L.Y, next.L.X, next.R.Y, next.R.X);\n\t  m[MP(MP(nly, nlx), MP(nry, nrx))] = 1;\n\t  q.push(MP(MP(nly, nlx), MP(nry, nrx)));\n\t}\n      }\n    }\n    puts(\"No\");\n  e:;\n    m.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <iomanip>\n#include <queue>\n#include <stack>\n#include <utility>\n#include <algorithm>\n#include <set>\n#include <ctime>\n#include <string>\n#include <functional>\n\nusing namespace std;\n\ntypedef vector<bool> v1;\ntypedef vector<v1> v2;\ntypedef vector<v2> v3;\ntypedef vector<v3> v4;\ntypedef vector<string> vc2;\ntypedef vector<vc2> stage;\ntypedef pair<int,int> pii;\ntypedef pair<pii,pii> p2;\n\nint solve();\n\nbool isOut( int y, int x, int H, int W ) {\n\treturn !( x >= 0 && y >= 0 && x < W && y < H );\n}\n\nint main(void) {\n\t\t\t\n\twhile(solve()){}\n\n\treturn 0;\n}\n\nint solve() {\n\n\tint W, H;\n\tcin >> W >> H;\n\tif(!(W|H)){ return 0; }\n\n\tv4 memo(H,v3(W,v2(H,v1(W,false))));\n\n\tstage stg( 2, vc2( H ) );\n\n\t//input\n\tfor( int i = 0; i < H; i++ ) {\n\t\tfor( int j = 0; j < 2; j++ ) {\n\t\t\tcin >> stg[j][i];\n\t\t}\n\t}\n\n\tpii start[2];\n\tchar ch[] = {'L','R'};\n\tfor( int i = 0; i < 2; i++ ) {\n\t\tfor( int j = 0; j < H; j++ ) {\n\t\t\tfor( int k = 0; k < W; k++ ) {\n\t\t\t\tif( stg[i][j][k] == ch[i] ) {\n\t\t\t\t\tstart[i].first = j;\n\t\t\t\t\tstart[i].second = k;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tp2 st(start[0],start[1]);\n\tqueue<p2> q;\n\tq.push(st);\n\n\tint d[4][2] = {{0,1},{1,0},{-1,0},{0,-1}};\n\n\tbool isClear = false;\n\n\twhile( q.empty() == false && isClear == false){\n\n\t\tp2 p = q.front();\n\t\tq.pop();\n\t\tfor( int i = 0; i < 4; i++ ) {\n\n\t\t\tp2 n = p;\n\t\t\tn.first.first += d[i][0];\n\t\t\tn.first.second += d[i][1];\n\t\t\tn.second.first += d[i][0];\n\t\t\tn.second.second -= d[i][1];\n\t\t\t\n\t\t\tif( isOut(n.first.first,n.first.second,H,W) == true ||\n\t\t\t\tstg[0][n.first.first][n.first.second] == '#' ) {\n\t\t\t\t\tn.first = p.first;\n\t\t\t}\n\t\t\tif( isOut(n.second.first,n.second.second,H,W) == true ||\n\t\t\t\tstg[1][n.second.first][n.second.second] == '#' ) {\n\t\t\t\t\tn.second = p.second;\n\t\t\t}\n\t\t\tif( ( stg[0][n.first.first][n.first.second] == '%' && stg[1][n.second.first][n.second.second] != '%' ) ||\n\t\t\t\t( stg[0][n.first.first][n.first.second] != '%' && stg[1][n.second.first][n.second.second] == '%' ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif( memo[n.first.first][n.first.second][n.second.first][n.second.second] == false ) {\n\t\t\t\tmemo[n.first.first][n.first.second][n.second.first][n.second.second] = true;\n\t\t\t\tif( stg[0][n.first.first][n.first.second] == '%' &&\n\t\t\t\t\tstg[1][n.second.first][n.second.second] == '%' ) {\n\t\t\t\t\tisClear = true;\n\t\t\t\t}\n\t\t\t\tq.push(n);\n\t\t\t}\n\n\t\t}\n\n\n\t}\n\n\tif( isClear ) {\n\t\tcout << \"Yes\" << endl;\n\t} else {\n\t\tcout << \"No\" << endl;\n\t}\n\n\n\treturn 1;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <complex>\nusing namespace std;\ntypedef complex<int> P;\n\nint main()\n{\n  int W, H;\n  while (cin >> W >> H && W != 0) {\n    vector<string> roomL(H), roomR(H);\n    P startL, startR;\n    for (int i = 0; i < H; i++) {\n      cin >> roomL[i] >> roomR[i];\n      for (int j = 0; j < W; j++) {\n        if (roomL[i][j] == 'L') {\n          roomL[i][j] = '.';\n          startL = P(i, j);\n        }\n        if (roomR[i][j] == 'R') {\n          roomR[i][j] = '.';\n          startR = P(i, j);\n        }\n      }\n    }\n\n    queue<pair<P,P> > q;\n    q.push(make_pair(startL, startR));\n    vector<vector<bool> > visited(W*H, vector<bool>(W*H, false));\n    visited[startL.real()*W + startL.imag()][startR.real()*W + startR.imag()] = true;\n    while (!q.empty()) {\n      const pair<P, P> p = q.front();\n      q.pop();\n      if (roomL[p.first.real()][p.first.imag()] == '%'\n          && roomR[p.second.real()][p.second.imag()] == '%') {\n        cout << \"YES\" << endl;\n        goto NEXT;\n      }\n\n      for (int d = 0; d < 4; d++) {\n        static const P dir[] = {P(-1,0), P(1,0), P(0,-1), P(0,1)};\n        P nextL = p.first + dir[d];\n        P nextR = p.second + P(dir[d].real(), dir[d].imag() == -1 ? 1 : (dir[d].imag() == 1 ? -1 : 0));\n        if (0 <= nextL.real() && nextL.real() < H\n            && 0 <= nextL.imag() && nextL.imag() < W\n            && 0 <= nextR.real() && nextR.real() < H\n            && 0 <= nextR.imag() && nextR.imag() < W) {\n          if (roomL[nextL.real()][nextL.imag()] == '#') {\n            nextL = p.first;\n          }\n          if (roomR[nextR.real()][nextR.imag()] == '#') {\n            nextR = p.second;\n          }\n          if (!visited[nextL.real()*W + nextL.imag()][nextR.real()*W + nextR.imag()]) {\n            q.push(make_pair(nextL, nextR));\n            visited[nextL.real()*W + nextL.imag()][nextR.real()*W + nextR.imag()] = true;\n          }\n        }\n      }\n    }\n    cout << \"NO\" << endl;\nNEXT:\n    ;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<map>\nusing namespace std;\nint dx[4] = {0,0,1,-1};\nint dy[4] = {1,-1,0,0};\nint main(){\n  int W,H;\n  while(cin >>W>>H,W||H){\n    int roomL[60][60],roomR[60][60];\n    int RSX,RSY,LSX,LSY,RGX,RGY,LGX,LGY;\n    for(int i=0; i<60; i++) for(int j=0; j<60; j++) roomL[i][j] = roomR[i][j] = -1;\n    for(int i=0; i<H; i++){\n      string s;\n      cin >>s;\n      for(int j=0; j<W; j++){\n\tif(s[j] == '%'){LGX = j+5; LGY = i+5;}\n\tif(s[j] == '#') roomL[j+5][i+5] = -1;\n\tif(s[j] == '.') roomL[j+5][i+5] = 0;\n\tif(s[j] == 'L'){LSX = j+5; LSY = i+5;}\n      }\n      cin >>s;\n      for(int j=0; j<W; j++){\n\tif(s[j] == '%'){RGX = j+5; RGY = i+5;}\n\tif(s[j] == '#') roomR[j+5][i+5] = -1;\n\tif(s[j] == '.') roomR[j+5][i+5] = 0;\n\tif(s[j] == 'R'){RSX = j+5; RSY = i+5;}\n      }\n    }\n    set<pair<pair<int,int>,pair<int,int> > > log;\n    log.insert(make_pair(make_pair(LSX,LSY),make_pair(RSX,RSY)));\n    set<pair<pair<int,int>,pair<int,int> > > next;\n    for(int i=0; i<100; i++){\n      for(set<pair<pair<int,int>,pair<int,int> > >::iterator it = log.begin(); it!=log.end(); it++){\n\tint lx,ly,rx,ry,lnx,lny,rnx,rny;\n\tlx = (it->first).first;\n\tly = (it->first).second;\n\trx = (it->second).first;\n\try = (it->second).second;\n\tfor(int i=0; i<4; i++){\n\t  if(rx+dx[i] == RGX && ry+dy[i] == RGY){\n\t    if(lx-dx[i] == LGX && ly+dy[i] == LGY){cout <<\"Yes\"<<endl;goto flag;}\n\t    continue;\n\t  }\n\t  if(lx-dx[i] == LGX && ly+dy[i] == LGY) continue;\n\t  if(roomR[rx+dx[i]][ry+dy[i]] == -1){rnx = rx;rny = ry;}\n\t  else if(roomR[rx+dx[i]][ry+dy[i]] == 0){rnx = rx+dx[i];rny = ry+dy[i];}\n\t  if(roomL[lx-dx[i]][ly+dy[i]] == -1){lnx = lx;lny = ly;}\n\t  else if(roomL[lx-dx[i]][ly+dy[i]] == 0){lnx = lx-dx[i];lny = ly+dy[i];}\n\t  if(log.find(make_pair(make_pair(lnx,lny),make_pair(rnx,rny))) == log.end()){next.insert(make_pair(make_pair(lnx,lny),make_pair(rnx,rny)));}\n\t}\n      }\n      log = next;\n    }\n    cout <<\"No\"<<endl;\n  flag:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#define rep(X,Y) for(int (X)=0;(X)<(Y);++(X))\n#define pb push_back\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<pii,pii> pi4;\n\nint dist[55][55][55][55],dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate<typename T> ostream& operator<<(ostream& os, vector<T> &v){\n  cout<<\"{\";\n  rep(i,v.size())os<<v[i]<<\",\"<<endl;cout<<\"}\"<<endl;\n  return os;\n}\ntemplate<typename T,typename S> ostream& operator<<(ostream& os, pair<T,S> &v){\n  os<<\"(\"<<v.X<<\",\"<<v.Y<<\")\";\n  return os;\n}\n\nint main(){\n  int w,h;\n  while(cin>>w>>h){\n    if(!w)break;\n  vector<string> ml(h+2),mr(h+2);\n  ml[0]=mr[0]=ml[h+1]=mr[h+1]=string(w+2,'#');\n  string tmp;\n  pii sl,dl,sr,dr;\n  rep(i,h){\n    cin>>tmp;\n    ml[i+1]=(\"#\"+tmp+\"#\");\n    cin>>tmp;\n    mr[i+1]=(\"#\"+tmp+\"#\");\n  }\n  rep(i,h+2)rep(j,w+2){\n    if(ml[i][j]=='L') sl=pii(j,i);\n    if(mr[i][j]=='R') sr=pii(j,i);\n    if(ml[i][j]=='%') dl=pii(j,i);\n    if(mr[i][j]=='%') dr=pii(j,i);\n  }\n  //cout<<ml<<mr<<sl<<sr<<dl<<dr<<endl;\n  int INF=1e9;\n  queue<pi4> que;\n  fill(dist[0][0][0],dist[0][0][0]+55*55*55*55,INF);\n  rep(i,h+2)rep(j,w+2)\n    dist[dl.Y][dl.X][i][j]=dist[i][j][dr.Y][dr.X]=-1;\n  dist[dl.Y][dl.X][dr.Y][dr.X]=INF;\n  dist[sl.Y][sl.X][sr.Y][sr.X]=0;\n  que.emplace(sl,sr);\n  while(!que.empty()){\n    pii cl=que.front().X, cr=que.front().Y;\n    que.pop();\n    //cout<<cl<<cr<<dist[cl.Y][cl.X][cr.Y][cr.X]<<endl;\n    if(cl==dl && cr==dr)break;\n    int nd=dist[cl.Y][cl.X][cr.Y][cr.X]+1;\n    rep(i,4){\n      pii nl=cl,nr=cr;\n      nl.X+=dx[i]; nl.Y+=dy[i];\n      nr.X-=dx[i]; nr.Y+=dy[i];\n      //cout<<i<<\":\"<<nl<<nr;\n      if(ml[nl.Y][nl.X]=='#') nl=cl;\n      if(mr[nr.Y][nr.X]=='#') nr=cr;\n      //cout<<i<<\":\"<<nl<<nr<<dist[nl.Y][nl.X][nr.Y][nr.X]<<endl;\n      if(dist[nl.Y][nl.X][nr.Y][nr.X]>nd){\n\tdist[nl.Y][nl.X][nr.Y][nr.X]=nd;\n\tque.emplace(nl,nr);\n      }\n    }\n  }\n  cout<<(dist[dl.Y][dl.X][dr.Y][dr.X]==INF?\"NO\":\"YES\")<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <tuple>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nconst int dx1[4] = { 0, 1, 0, -1 };\nconst int dy1[4] = { -1, 0, 1, 0 };\nconst int dx2[4] = { 0, -1, 0, 1 };\nconst int dy2[4] = { -1, 0, 1, 0 };\n\nint H, W; string L[50], R[50];\n\nbool used[50][50][50][50];\n\nbool over(int x, int y)\n{\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\n\nbool solve(int lx, int ly, int rx, int ry)\n{\n\tused[ly][lx][ry][rx] = true;\n\n\tif (L[ly][lx] == '%' && R[ry][rx] == '%') return true;\n\n\tif (L[ly][lx] == '%') return false;\n\tif (R[ry][rx] == '%') return false;\n\n\tbool ok = false;\n\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint ltx = lx + dx1[i];\n\t\tint lty = ly + dy1[i];\n\t\tint rtx = rx + dx2[i];\n\t\tint rty = ry + dx2[i];\n\n\t\tif (!over(ltx, lty) && !over(rtx, rty))\n\t\t{\n\t\t\tif (L[lty][ltx] != '#' && R[rty][rtx] != '#')\n\t\t\t{\n\t\t\t\tif (!used[lty][ltx][rty][rtx])\n\t\t\t\t{\n\t\t\t\t\tok |= solve(ltx, lty, rtx, rty);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ok;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &W);\n\t\tscanf(\"%d\", &H);\n\n\t\tfor (int i = 0; i < H; i++) cin >> L[i] >> R[i];\n\n\t\tint lx, ly, rx, ry;\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (L[i][j] == 'L')\n\t\t\t\t{\n\t\t\t\t\tlx = j;\n\t\t\t\t\tly = i;\n\t\t\t\t}\n\n\t\t\t\tif (R[i][j] == 'R')\n\t\t\t\t{\n\t\t\t\t\trx = j;\n\t\t\t\t\try = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(used, false, sizeof(used));\n\n\t\tprintf(\"%s\\n\", solve(lx, ly, rx, ry) ? \"Yes\" : \"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef pair< int, int > Pi;\n\nbool used[50][50][50][50];\nchar masL[50][50], masR[50][50];\nint W, H;\nPi RinS, LenS; //スタート\nconst int dy[] = { 1, 0, -1, 0}, dx[] = { 0, 1, 0, -1};\n\nbool isover(int y, int x){\n  return y < 0 || y >= H || x < 0 || x >= W;\n}\n\nint bfs(){\n  queue< Pi > Rin, Len;\n  Rin.push(RinS);\n  Len.push(LenS);\n  used[RinS.first][RinS.second][LenS.first][LenS.second] = true;\n  while(!Rin.empty()){\n    Pi r = Rin.front(), l = Len.front();\n    if(masL[r.first][r.second] == '%' && masR[l.first][l.second] == '%'){\n      return true;\n    }\n    for(int i = 0; i < 4; i++){\n      int rny = min( H - 1, max( 0, r.first + dy[i]));\n      int rnx = min( W - 1, max( 0, r.second + dx[i]));\n      int lny = min( H - 1, max( 0, l.first + dy[i]));\n      int lnx = min( W - 1, max( 0, r.second - dx[i]));\n      //めんどい\n      if(masR[lny][lnx] == '#'){ //元の位置に戻す！！\n        rny = r.first, rnx = r.second;\n      }\n      if(masL[rny][rnx] == '#'){\n        lny = l.first, lnx = l.second;\n      }\n\n      if(!used[rny][rnx][lny][lnx]){\n        used[rny][rnx][lny][lnx] = true;\n        Rin.push( Pi( rny, rnx)), Len.push( Pi( lny, lnx));\n      }\n    }\n  }\n  return false; //いけない!!\n}\nint main()\n{\n  while(cin >> W >> H, W){\n    for(int i = 0; i < H; i++){\n      for(int j = 0; j < W; j++){\n        cin >> masL[i][j];\n        if(masL[i][j] == 'R'){\n          LenS = Pi( i, j);\n          masL[i][j] = '.';\n        }\n      }\n      for(int j = 0; j < W; j++){\n        cin >> masR[i][j];\n        if(masR[i][j] == 'L'){\n          RinS = Pi( i, j);\n          masR[i][j] = '.';\n        }\n      }\n    }\n    bool judge = bfs();\n    if(judge) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\n\ntemplate<class T>\ninline bool chmax(T &a, const T &b) {\n    if(a<b) {\n        a=b;\n        return true;\n    }\n\n    return false;\n}\ntemplate<class T>\ninline bool chmin(T &a, const T &b) {\n    if(a>b) {\n        a=b;\n        return true;\n    }\n\n    return false;\n}\n\nint W,H;\nstring roomL[51],roomR[51];\n\nbool range_check(int y,int x) {\n    if(y<0||x<0) return false;\n    if(H<=y||W<=x) return false;\n\n    return true;\n}\n\nbool ok(P len,P rin) {\n    bool visited[51][51][51][51]={};\n    visited[len.fr][len.sc][rin.fr][rin.sc]=true;\n    queue<PP> que;\n    que.push(PP(len,rin));\n\n    while(que.size()) {\n        PP pp=que.front(); que.pop();\n        P next_len=pp.fr;\n        P next_rin=pp.sc;\n\n        //printf(\"[debug] %d %d %d %d\\n\",next_len.fr,next_len.sc,next_rin.fr,next_rin.sc);\n\n        if(roomL[next_len.fr][next_len.sc]=='%' && roomR[next_rin.fr][next_rin.sc]=='%') {\n            return true;\n        }\n        if(roomL[next_len.fr][next_len.sc]=='%' || roomR[next_rin.fr][next_rin.sc]=='%') {\n            // visited[next_len.fr][next_len.sc][next_rin.fr][next_rin.sc]=false;\n            continue;\n        }\n        rep(i,4) {\n            next_len=pp.fr;\n            next_rin=pp.sc;\n\n            if(range_check(next_len.fr+dy[i],next_len.sc+dx[i]) && roomL[next_len.fr+dy[i]][next_len.sc+dx[i]]!='#') {\n                next_len.fr+=dy[i];\n                next_len.sc+=dx[i];\n            }\n            if(range_check(next_rin.fr+dy[i],next_rin.sc-dx[i]) && roomR[next_rin.fr+dy[i]][next_rin.sc-dx[i]]!='#') {\n                next_rin.fr+=dy[i];\n                next_rin.sc-=dx[i];\n            }\n\n            chmax(next_len.fr,0);\n            chmin(next_len.fr,H-1);\n            chmax(next_len.sc,0);\n            chmin(next_len.sc,W-1);\n            chmax(next_rin.fr,0);\n            chmin(next_rin.fr,H-1);\n            chmax(next_rin.sc,0);\n            chmin(next_rin.sc,W-1);\n\n\n            if(!visited[next_len.fr][next_len.sc][next_rin.fr][next_len.sc]) {\n                visited[next_len.fr][next_len.sc][next_rin.fr][next_len.sc]=true;\n                que.push(PP(next_len,next_rin));\n            }\n        }\n    }\n\n    return false;\n}\n\nvoid solve() {\n    rep(y,H) cin>>roomL[y]>>roomR[y];\n    P len,rin;\n    rep(y,H) rep(x,W) {\n        if(roomL[y][x]=='L') len=P(y,x);\n        if(roomR[y][x]=='R') rin=P(y,x);\n    }\n    if(ok(len,rin)) cout<<\"YES\"<<endl;\n    else cout<<\"NO\"<<endl;\n}\n\nint main() {\n    while(cin>>W>>H) {\n        if(!W) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint width,height;\nchar lmap[50][51];\nchar rmap[50][51];\n\nint isValid(int x1,int y1,int x2,int y2) {\n\tif(x1<0 || x1>=width || y1<0 || y1>=height)return 0;\n\tif(x2<0 || x2>=width || y2<0 || y2>=height)return 0;\n\tif(lmap[y1][x1]=='#' || rmap[y2][x2]=='#')return 0;\n\tif(lmap[y1][x1]=='%' && rmap[y2][x2]=='%')return 1;\n\tif(lmap[y1][x1]=='%' || rmap[y2][x2]=='%')return 0;\n\treturn 1;\n}\n\nint stack_num;\nchar stack[50*50*50*50][4];\nchar visited[50][50][50][50];\n\nvoid stack_push(int x1,int y1,int x2,int y2) {\n\tif(!visited[y1][x1][y2][x2]) {\n\t\tstack[stack_num][0]=x1;\n\t\tstack[stack_num][1]=y1;\n\t\tstack[stack_num][2]=x2;\n\t\tstack[stack_num][3]=y2;\n\t\tstack_num++;\n\t\tvisited[y1][x1][y2][x2]=1;\n\t}\n}\n\nint tansaku(int sx1,int sy1,int sx2,int sy2,int dx1,int dy1,int dx2,int dy2) {\n\tmemset(visited,0,sizeof(visited));\n\tvisited[sy1][sx1][sy2][sx2]=1;\n\tstack[0][0]=sx1;\n\tstack[0][1]=sy1;\n\tstack[0][2]=sx2;\n\tstack[0][3]=sy2;\n\tstack_num=1;\n\twhile(stack_num>0 && !visited[dy1][dx1][dy2][dx2]) {\n\t\tint x1,x2,y1,y2;\n\t\tint xx1,xx2,yy1,yy2;\n\t\tstack_num--;\n\t\tx1=stack[stack_num][0];y1=stack[stack_num][1];\n\t\tx2=stack[stack_num][2];y2=stack[stack_num][3];\n\n\t\tyy1=y1;yy2=y2;\n\t\tif(y1>0 && lmap[y1-1][x1]!='#')yy1--;\n\t\tif(y2>0 && rmap[y2-1][x2]!='#')yy2--;\n\t\tif(isValid(x1,yy1,x2,yy2) && (y1!=yy1 || y2!=yy2)) {\n\t\t\tstack_push(x1,yy1,x2,yy2);\n\t\t}\n\t\tyy1=y1;yy2=y2;\n\t\tif(y1+1<height && lmap[y1+1][x1]!='#')yy1++;\n\t\tif(y2+1<height && rmap[y2+1][x2]!='#')yy2++;\n\t\tif(isValid(x1,yy1,x2,yy2) && (y1!=yy1 || y2!=yy2)) {\n\t\t\tstack_push(x1,yy1,x2,yy2);\n\t\t}\n\t\txx1=x1;xx2=x2;\n\t\tif(x1>0 && lmap[y1][x1-1]!='#')xx1--;\n\t\tif(x2+1<width && rmap[y2][x2+1]!='#')xx2++;\n\t\tif(isValid(xx1,y1,xx2,y2) && (x1!=xx1 || x2!=xx2)) {\n\t\t\tstack_push(xx1,y1,xx2,y2);\n\t\t}\n\t\txx1=x1;xx2=x2;\n\t\tif(x1+1<width && lmap[y1][x1+1]!='#')xx1++;\n\t\tif(x2>0 && rmap[y2][x2-1]!='#')xx2--;\n\t\tif(isValid(xx1,y1,xx2,y2) && (x1!=xx1 || x2!=xx2)) {\n\t\t\tstack_push(xx1,y1,xx2,y2);\n\t\t}\n\t}\n\treturn visited[dy1][dx1][dy2][dx2];\n}\n\nint tansaku_wrapper(int s[4],int g[4]) {\n\treturn tansaku(s[0],s[1],s[2],s[3],g[0],g[1],g[2],g[3]);\n}\n\nint main(void) {\n\tint x,y;\n\tint start[4]={-1,-1,-1,-1};\n\tint goal[4]={-1,-1,-1,-1};\n\twhile(scanf(\"%d%d\",&width,&height)==2 && (width|height)!=0) {\n\t\tfor(y=0;y<height;y++)scanf(\"%s%s\",lmap[y],rmap[y]);\n\t\tfor(y=0;y<height;y++) {\n\t\t\tfor(x=0;x<width;x++) {\n\t\t\t\tif(lmap[y][x]=='L') {\n\t\t\t\t\tstart[0]=x;start[1]=y;\n\t\t\t\t}\n\t\t\t\tif(rmap[y][x]=='R') {\n\t\t\t\t\tstart[2]=x;start[3]=y;\n\t\t\t\t}\n\t\t\t\tif(lmap[y][x]=='%') {\n\t\t\t\t\tgoal[0]=x;goal[1]=y;\n\t\t\t\t}\n\t\t\t\tif(rmap[y][x]=='%') {\n\t\t\t\t\tgoal[2]=x;goal[3]=y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(start[0]<0 || goal[0]<0 || start[2]<0 || goal[2]<0)return 1;\n\t\tputs(tansaku_wrapper(start,goal)?\"Yes\":\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n\nint cnt;\nll w,h;\nchar s1[60][60],s2[60][60];\nint dp[60][60][60][60];\nint que[50*50*50*50+10],quecnt;\nint d4[]={0,1,0,-1,0};\n\nint f(){\n\th+=2;w+=2;\n\t{\n\t\tint li,lj,ri,rj;\n\t\trep(i,0,h)rep(j,0,w){\n\t\t\tif(s1[i][j]=='L'){\n\t\t\t\tli=i;\n\t\t\t\tlj=j;\n\t\t\t}\n\t\t\tif(s2[i][j]=='R'){\n\t\t\t\tri=i;\n\t\t\t\trj=j;\n\t\t\t}\n\t\t}\n\t\tquecnt=0;\n\t\tdp[li][lj][ri][rj]=cnt;\n\t\tque[quecnt++]=li*55*55*55+lj*55*55+ri*55+rj;\n\t}\n\trep(qqq,0,quecnt){\n\t\tint li=que[qqq]/55/55/55;\n\t\tint lj=que[qqq]/55/55%55;\n\t\tint ri=que[qqq]/55%55;\n\t\tint rj=que[qqq]%55;\n\t\trep(k,0,4){\n\t\t\tint lii=li+d4[k];\n\t\t\tint ljj=lj+d4[k+1];\n\t\t\tint rii=ri+d4[k];\n\t\t\tint rjj=rj+d4[k+1];\n\t\t\tint flag=0;\n\t\t\tif(s1[lii][ljj]=='#'){\n\t\t\t\tlii=li;\n\t\t\t\tljj=lj;\n\t\t\t\tflag++;\n\t\t\t}\n\t\t\tif(s2[rii][rjj]=='#'){\n\t\t\t\trii=ri;\n\t\t\t\trjj=rj;\n\t\t\t\tflag++;\n\t\t\t}\n\t\t\tif(flag==2)continue;\n\t\t\tif(dp[lii][ljj][rii][rjj]==cnt)continue;\n\t\t\tif(s1[lii][ljj]=='%'&&s2[rii][rjj]=='%')return 1;\n\t\t\tif(s1[lii][ljj]=='%'||s2[rii][rjj]=='%')continue;\n\t\t\tdp[lii][ljj][rii][rjj]=cnt;\n\t\t\tque[quecnt++]=lii*55*55*55+ljj*55*55+rii*55+rjj;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\twhile(scanf(\"%lld%lld\",&w,&h),w){\n\t\t++cnt;\n\t\trep(i,0,h)scanf(\" %s %s\",s1[i+1]+1,s2[i+1]+1);\n\t\trep(i,0,w+2)s1[0][i]=s1[h+1][i]=s2[0][i]=s2[h+1][i]='#';\n\t\trep(i,0,h+2)s1[i][0]=s1[i][w+1]=s2[i][0]=s2[i][w+1]='#';\n\t\trep(i,0,h)rep(j,0,w/2){\n\t\t\tchar c=s2[i+1][j+1];\n\t\t\ts2[i+1][j+1]=s2[i+1][w-j];\n\t\t\ts2[i+1][w-j]=c;\n\t\t}\n//\t\trep(i,0,h+2)puts(s1[i]);\n//\t\tputs(\"\");\n//\t\trep(i,0,h+2)puts(s2[i]);\n\t\tputs(f()?\"Yes\":\"No\");\t\t\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2153: Mirror Cave\n// 2017.11.11 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#define TM 0\n#if TM\n#include <time.h>\n#endif\n\n#define QMAX 150000\ntypedef struct { char lr, lc, rr, rc; } Q;\nQ q[QMAX+2]; int top, end;\n\nchar ml[52][52], mr[52][52];\nchar mk[52][52][52][52];\nint mvl[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\nint mvr[4][2] = {{-1,0},{0,-1},{1,0},{0,1}};\n\nint main()\n{\n\tint w, h, r, c, lr, lc, rr, rc, lr2, lc2, rr2, rc2, i, f;\n\tint slr, slc, srr, src, ans;\n#if TM\n\tclock_t start, end;\n\tstart = clock();\n#endif\n\tfor (r = 0; r <= 51; r++) ml[r][0] = mr[r][0] = '#';\n\tfor (c = 0; c <= 51; c++) ml[0][c] = mr[0][c] = '#';\n\n\twhile (scanf(\"%d%d\", &w, &h) && w > 0) {\n\t\tfor (f = 0, r = 1; r <= h; r++) {\n\t\t\tscanf(\"%s%s\", ml[r]+1, mr[r]+1);\n\t\t\tif (f < 3) for (c = 1; c <= w; c++) {\n\t\t\t\tif (ml[r][c] == 'L') slr = r, slc = c, f |= 1;\n\t\t\t\tif (mr[r][c] == 'R') srr = r, src = c, f |= 2;\n\t\t\t}\n\t\t}\n\t\tfor (r = 1; r <= h; r++) ml[r][w+1] = mr[r][w+1] = '#';\n\t\tfor (c = 1; c <= w; c++) ml[h+1][c] = mr[h+1][c] = '#';\n\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tq[0].lr = slr, q[0].lc = slc, q[0].rr = srr, q[0].rc = src, top = 0, end = 1;\n\t\tmk[slr][slc][srr][src] = 1;\n\t\tans = 0;\n\t\twhile (top != end) {\n\t\t\tlr = q[top].lr, lc = q[top].lc, rr = q[top].rr, rc = q[top].rc;\n\t\t\tif (++top == QMAX) top = 0;\n\t\t\tif (ml[lr][lc] == '%' && mr[rr][rc] == '%') { ans = 1; break; }\n\t\t\tif (ml[lr][lc] == '%' || mr[rr][rc] == '%') continue;\n\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tf = 3;\n\t\t\t\tlr2 = lr + mvl[i][0], lc2 = lc + mvl[i][1];\n\t\t\t\trr2 = rr + mvr[i][0], rc2 = rc + mvr[i][1];\n\t\t\t\tif (ml[lr2][lc2] == '#') lr2 = lr, lc2 = lc, f &= 2;\n\t\t\t\tif (mr[rr2][rc2] == '#') rr2 = rr, rc2 = rc, f &= 1;\n\t\t\t\tif (!f) continue;\n\t\t\t\tif (mk[lr2][lc2][rr2][rc2]) continue;\n\t\t\t\tmk[lr2][lc2][rr2][rc2] = 1;\n\t\t\t\tq[end].lr = lr2, q[end].lc = lc2, q[end].rr = rr2, q[end].rc = rc2;\n\t\t\t\tif (++end == QMAX) end = 0;\n\t\t\t}\n\t\t}\n\t\tputs(ans ? \"Yes\" : \"No\");\n\t}\n#if TM\n\tend = clock();\n\tprintf(\"time %lf\\n\", (double)(end-start)/CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2153: Mirror Cave\n// 2017.11.11 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#define TM 0\n#if TM\n#include <time.h>\n#endif\n\n#define QMAX 150000\ntypedef struct { char lr, lc, rr, rc; } Q;\nQ q[QMAX+2]; int top, end;\n\nchar ml[52][52], mr[52][52];\nchar mk[52][52][52][52];\nint mvl[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\nint mvr[4][2] = {{-1,0},{0,-1},{1,0},{0,1}};\n\nint main()\n{\n\tint w, h, r, c, lr, lc, rr, rc, lr2, lc2, rr2, rc2, i, f;\n\tint slr, slc, srr, src, ans;\n#if TM\n\tclock_t start, end;\n\tstart = clock();\n#endif\n\tfor (r = 0; r <= 51; r++) ml[r][0] = mr[r][0] = '#';\n\tfor (c = 0; c <= 51; c++) ml[0][c] = mr[0][c] = '#';\n\n\twhile (scanf(\"%d%d\", &w, &h) && w > 0) {\n\t\tfor (f = 0, r = 1; r <= h; r++) {\n\t\t\tscanf(\"%s%s\", ml[r]+1, mr[r]+1);\n\t\t\tif (f < 3) for (c = 1; c <= w; c++) {\n\t\t\t\tif (ml[r][c] == 'L') slr = r, slc = c, f |= 1;\n\t\t\t\tif (mr[r][c] == 'R') srr = r, src = c, f |= 2;\n\t\t\t}\n\t\t}\n\t\tfor (r = 1; r <= h; r++) ml[r][w+1] = mr[r][w+1] = '#';\n\t\tfor (c = 1; c <= w; c++) ml[h+1][c] = mr[h+1][c] = '#';\n\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tq[0].lr = slr, q[0].lc = slc, q[0].rr = srr, q[0].rc = src, top = 0, end = 1;\n\t\tmk[slr][slc][srr][src] = 1;\n\t\tans = 0;\n\t\twhile (top != end) {\n\t\t\tlr = q[top].lr, lc = q[top].lc, rr = q[top].rr, rc = q[top].rc;\n\t\t\tif (++top == QMAX) top = 0;\n\t\t\tif (ml[lr][lc] == '%' && mr[rr][rc] == '%') { ans = 1; break; }\n\t\t\tif (ml[lr][lc] == '%' || mr[rr][rc] == '%') continue;\n\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tlr2 = lr + mvl[i][0], lc2 = lc + mvl[i][1];\n\t\t\t\trr2 = rr + mvr[i][0], rc2 = rc + mvr[i][1];\n\t\t\t\tif (ml[lr2][lc2] == '#') lr2 = lr, lc2 = lc;\n\t\t\t\tif (mr[rr2][rc2] == '#') rr2 = rr, rc2 = rc;\n\t\t\t\tif (mk[lr2][lc2][rr2][rc2]) continue;\n\t\t\t\tmk[lr2][lc2][rr2][rc2] = 1;\n\t\t\t\tq[end].lr = lr2, q[end].lc = lc2, q[end].rr = rr2, q[end].rc = rc2;\n\t\t\t\tif (++end == QMAX) end = 0;\n\t\t\t}\n\t\t}\n\t\tputs(ans ? \"Yes\" : \"No\");\n\t}\n#if TM\n\tend = clock();\n\tprintf(\"time %lf\\n\", (double)(end-start)/CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#define N 100000000\n#define rep(i,n) for(int i = 0 ; i < n ; ++i)\n\ntypedef struct{\n    int rx,ry,lx,ly;\n}Point;\nPoint queue[N];\nint w,h;\n\nint chk(int y,int x,char s[99][99]){\n    return (y >= 0 && x >= 0 && y < h && x < w && s[y][x] != '#');\n}\n\nchar rin[99][99] , len[99][99];\n\nint used[52][52][52][52];\n\nint rx,ry,lx,ly;\n\nconst int dx[] = {0,-1,0,1};\nconst int dy[] = {-1,0,1,0};\n\nint head,num;\nvoid enqueue(int ly,int lx,int ry,int rx){\n    if(num<N){\n        queue[(head+num)%N].ly=ly;\n        queue[(head+num)%N].lx=lx;\n        queue[(head+num)%N].ry=ry;\n        queue[(head+num)%N].rx=rx;\n        num++;\n    }else{\n        printf(\"エラー\");\n        exit(1);\n    }\n}\nPoint dequeue(){\n    Point d={-1,-1,-1,-1};\n    if(num>0){\n        d=queue[head];\n        head=(head+1)%N;\n        num--;\n    }\n    return d;\n}\n\nint bfs(){\n    \n    memset(used,0,sizeof(used));\n    enqueue(ly,lx,ry,rx);\n    \n    while(1){\n        Point p=dequeue();\n        if(p.ly==-1) break;\n        \n        if(used[p.ly][p.lx][p.ry][p.rx])continue;\n        used[p.ly][p.lx][p.ry][p.rx] = 1;\n        \n        if(len[p.ly][p.lx] == '%' && rin[p.ry][p.rx] == '%')return 1;\n        if(len[p.ly][p.lx] == '%' || rin[p.ry][p.rx] == '%')continue;\n        \n        rep(i,4){\n            \n            int nrx = p.rx,nry = p.ry,nlx = p.lx,nly = p.ly;\n            \n            if(chk(nly+dy[i],nlx+dx[i],len))nly += dy[i],nlx += dx[i];\n            if(chk(nry+dy[i],nrx-dx[i],rin))nry += dy[i],nrx -= dx[i];\n            \n            \n            if(!used[nly][nlx][nry][nrx])\n                enqueue(nly,nlx,nry,nrx);\n        }\n    }\n    \n    return 0;\n}\n\nint main(){\n    while(1){\n        scanf(\"%d%d\",&w,&h);\n        if(w+h==0) break;\n        getchar();\n        rep(i,h) scanf(\"%s%s\",len[i],rin[i]);\n        rep(i,h){\n            rep(j,w){\n                if(len[i][j] == 'L')ly = i,lx = j;\n                if(rin[i][j] == 'R')ry = i,rx = j;\n            }\n        }\n        head=num=0;\n        printf(\"%s\\n\",(bfs() ? \"Yes\": \"No\"));\n        \n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2153: Mirror Cave\n// 2017.11.11 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#define TM 0\n#if TM\n#include <time.h>\n#endif\n\n#define QMAX 100000\ntypedef struct { char lr, lc, rr, rc; } Q;\nQ q[QMAX+2], *top, *end, *qmax = q+QMAX;\n\nchar ml[52][52], mr[52][52];\nchar mk[52][52][52][52];\nint mvl[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\nint mvr[4][2] = {{-1,0},{0,-1},{1,0},{0,1}};\n\nint main()\n{\n\tint w, h, r, c, lr, lc, rr, rc, i, f;\n\tint lr2, lc2, rr2, rc2;\n#if TM\n\tclock_t start, finish;\n\tstart = clock();\n#endif\n\tfor (r = 0; r <= 51; r++) ml[r][0] = mr[r][0] = '#';\n\tfor (c = 0; c <= 51; c++) ml[0][c] = mr[0][c] = '#';\n\n\twhile (scanf(\"%d%d\", &w, &h) && w > 0) {\n\t\tfor (f = 0, r = 1; r <= h; r++) {\n\t\t\tscanf(\"%s%s\", ml[r]+1, mr[r]+1);\n\t\t\tif (f < 3) for (c = 1; c <= w; c++) {\n\t\t\t\tif (ml[r][c] == 'L') lr = r, lc = c, f |= 1;\n\t\t\t\tif (mr[r][c] == 'R') rr = r, rc = c, f |= 2;\n\t\t\t}\n\t\t}\n\t\tfor (r = 1; r <= h; r++) ml[r][w+1] = mr[r][w+1] = '#';\n\t\tfor (c = 1; c <= w; c++) ml[h+1][c] = mr[h+1][c] = '#';\n\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tq->lr = lr, q->lc = lc, q->rr = rr, q->rc = rc, top = q, end = q+1;\n\t\tmk[lr][lc][rr][rc] = 1;\n\t\tf = 0;\n\t\twhile (top != end) {\n\t\t\tlr = top->lr, lc = top->lc, rr = top->rr, rc = top->rc;\n\t\t\tif (++top == qmax) top = q;\n\t\t\tif (ml[lr][lc] == '%' && mr[rr][rc] == '%') { f = 1; break; }\n\t\t\tif (ml[lr][lc] == '%' || mr[rr][rc] == '%') continue;\n\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tlr2 = lr + mvl[i][0], lc2 = lc + mvl[i][1];\n\t\t\t\trr2 = rr + mvr[i][0], rc2 = rc + mvr[i][1];\n\t\t\t\tif (ml[lr2][lc2] == '#') lr2 = lr, lc2 = lc;\n\t\t\t\tif (mr[rr2][rc2] == '#') rr2 = rr, rc2 = rc;\n\t\t\t\tif (mk[lr2][lc2][rr2][rc2]) continue;\n\t\t\t\tmk[lr2][lc2][rr2][rc2] = 1;\n\t\t\t\tend->lr = lr2, end->lc = lc2, end->rr = rr2, end->rc = rc2;\n\t\t\t\tif (++end == qmax) end = q;\n\t\t\t}\n\t\t}\n\t\tputs(f ? \"Yes\" : \"No\");\n\t}\n#if TM\n\tfinish = clock();\n\tprintf(\"time %lf\\n\", (double)(finish-start)/CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2153: Mirror Cave\n// 2017.11.11 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#define TM 0\n#if TM\n#include <time.h>\n#endif\n\n#define QMAX 150000\ntypedef struct { char lr, lc, rr, rc; } Q;\nQ q[QMAX+2]; int top, end;\n\nchar ml[50][51], mr[50][51];\nchar mk[50][50][50][50];\nint mvl[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\nint mvr[4][2] = {{-1,0},{0,-1},{1,0},{0,1}};\n\nint main()\n{\n\tint w, h, r, c, lr, lc, rr, rc, lr2, lc2, rr2, rc2, i, f;\n\tint slr, slc, srr, src;\n#if TM\n\tclock_t start, end;\n\tstart = clock();\n#endif\n\n\twhile (scanf(\"%d%d\", &w, &h) && w > 0) {\n\t\tfor (f = 0, r = 0; r < h; r++) {\n\t\t\tscanf(\"%s%s\", ml[r], mr[r]);\n\t\t\tif (f < 3) for (c = 0; c < w; c++) {\n\t\t\t\tif (ml[r][c] == 'L') slr = r, slc = c, f |= 1;\n\t\t\t\tif (mr[r][c] == 'R') srr = r, src = c, f |= 2;\n\t\t\t}\n\t\t}\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tq[0].lr = slr, q[0].lc = slc, q[0].rr = srr, q[0].rc = src, top = 0, end = 1;\n\t\tmk[slr][slc][srr][src] = 1;\n\t\tf = 0;\n\t\twhile (top != end) {\n\t\t\tlr = q[top].lr, lc = q[top].lc, rr = q[top].rr, rc = q[top].rc; if (++top == QMAX) top = 0;\n\t\t\tif (ml[lr][lc] == '%' && mr[rr][rc] == '%') { f = 1; break; }\n\t\t\tif (ml[lr][lc] == '%' || mr[rr][rc] == '%') continue;\n\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tlr2 = lr + mvl[i][0], lc2 = lc + mvl[i][1];\n\t\t\t\trr2 = rr + mvr[i][0], rc2 = rc + mvr[i][1];\n\t\t\t\tif (lr2 < 0 || lr2 >= h || lc2 < 0 || lc2 >= w || ml[lr2][lc2] == '#')\n\t\t\t\t\tlr2 = lr, lc2 = lc;\n\t\t\t\tif (rr2 < 0 || rr2 >= h || rc2 < 0 || rc2 >= w || mr[rr2][rc2] == '#')\n\t\t\t\t\trr2 = rr, rc2 = rc;\n\t\t\t\tif (mk[lr2][lc2][rr2][rc2]) continue;\n\t\t\t\tmk[lr2][lc2][rr2][rc2] = 1;\n\t\t\t\tq[end].lr = lr2, q[end].lc = lc2, q[end].rr = rr2, q[end].rc = rc2; if (++end == QMAX) end = 0;\n\t\t\t}\n\t\t}\n\t\tputs(f ? \"Yes\" : \"No\");\n\t}\n#if TM\n\tend = clock();\n\tprintf(\"time %lf\\n\", (double)(end-start)/CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.BitSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static int w, h;\n\tpublic static char[][][] map;\n\tpublic static final int[] dx = {1, 0, -1, 0};\n\tpublic static final int[] dy = {0, 1, 0, -1};\n\tpublic static int[] gx = new int[2];\n\tpublic static int[] gy = new int[2];\n\tpublic static int[] sx = new int[2];\n\tpublic static int[] sy = new int[2];\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = in.nextInt();\n\t\t\th = in.nextInt();\n\t\t\tif(w == 0) break;\n\t\t\tmap = new char[2][h][w];\n\t\t\tfor(int j=0; j<h; j++){\n\t\t\t\tfor(int i=0; i<2; i++){\n\t\t\t\t\tmap[i][j] = in.next().toCharArray();\n\t\t\t\t\tfor(int k=0; k<w; k++){\n\t\t\t\t\t\tif(map[i][j][k] == '%'){\n\t\t\t\t\t\t\tgx[i] = k;\n\t\t\t\t\t\t\tgy[i] = j;\n\t\t\t\t\t\t}else if(map[i][j][k] == 'L' || map[i][j][k] == 'R'){\n\t\t\t\t\t\t\tsx[i] = k;\n\t\t\t\t\t\t\tsy[i] = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tBitSet used = new BitSet(h*h*w*w);\n\t\t\tQueue<Pos> qu = new LinkedList<Pos>();\n\t\t\tqu.add(new Pos(sy[0], sx[0], sy[1], sx[1]));\n\t\t\tused.set(qu.peek().id);\n\t\t\tboolean goal = false;\n\t\t\twhile(!qu.isEmpty()){\n\t\t\t\tPos p = qu.poll();\n\t\t\t\tif(goal(p)){\n\t\t\t\t\tgoal = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tPos np = move(p, i);\n\t\t\t\t\tif(used.get(np.id)) continue;\n\t\t\t\t\tused.set(np.id);\n\t\t\t\t\tqu.add(np);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(goal?\"Yes\":\"No\");\n\t\t}\n\t}\n\t\n\tpublic static Pos move(Pos p, int dir){\n\t\tint nx1 = p.x1+dx[dir];\n\t\tint ny1 = p.y1+dy[dir];\n\t\tif(out(ny1, nx1) || map[0][ny1][nx1] == '#'){\n\t\t\tnx1 = p.x1;\n\t\t\tny1 = p.y1;\n\t\t}\n\t\tint nx2 = p.x2-dx[dir];\n\t\tint ny2 = p.y2+dy[dir];\n\t\tif(out(ny2, nx2) || map[1][ny2][nx2] == '#'){\n\t\t\tnx2 = p.x2;\n\t\t\tny2 = p.y2;\n\t\t}\n\t\treturn new Pos(nx1, ny1, nx2, ny2);\n\t}\n\t\n\tpublic static boolean out(int y, int x){\n\t\treturn x < 0 || x >= w || y < 0 || y >= h;\n\t}\n\t\n\tpublic static boolean goal(Pos p){\n\t\treturn p.x1 == gx[0] && p.y1 == gy[0] && p.x2 == gx[1] && p.y2 == gy[1];\n\t}\n\t\n\tpublic static int id(int y1, int x1, int y2, int x2){\n\t\treturn y1*h*w*w + x1*h*w + y2*w + x2;\n\t}\n}\n\nclass Pos{\n\tint x1, y1, x2, y2;\n\tint id;\n\tpublic Pos(int y1, int x1, int y2, int x2){\n\t\tthis.x1 = x1;\n\t\tthis.y1 = y1;\n\t\tthis.x2 = x2;\n\t\tthis.y2 = y2;\n\t\tid = Main.id(y1, x1, y2, x2);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tint w,h;\n\tint [] vx = {0,1,0,-1};\n\tint [] vy = {1,0,-1,0};\n\t\n\tclass C{\n\t\tint x1,y1,x2,y2;\n\n\t\tpublic C(int x1, int y1, int x2, int y2) {\n\t\t\tthis.x1 = x1;\n\t\t\tthis.y1 = y1;\n\t\t\tthis.x2 = x2;\n\t\t\tthis.y2 = y2;\n\t\t}\n\t\t\n\t}\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif((w|h) == 0) break;\n\t\t\tchar [][][]data = new char[2][h][w];\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < 2; j++){\n\t\t\t\t\tdata[j][i] = sc.next().toCharArray();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint x1 = 0,x2 = 0,y1 = 0,y2 = 0;\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tif(data[0][i][j] == 'L'){\n\t\t\t\t\t\tdata[0][i][j] = '.';\n\t\t\t\t\t\tx1 = j;\n\t\t\t\t\t\ty1 = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tif(data[1][i][j] == 'R'){\n\t\t\t\t\t\tdata[1][i][j] = '.';\n\t\t\t\t\t\tx2 = j;\n\t\t\t\t\t\ty2 = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tLinkedList<C> open = new LinkedList<C>();\n\t\t\topen.add(new C(x1, y1, x2, y2));\n\t\t\tboolean [][][][] close = new boolean[h][w][h][w];\n\t\t\tclose[y1][x1][y2][x2] = true;\n\t\t\tboolean ans = false;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tC now = open.poll();\n\t\t\t\t\n\t\t\t\tboolean flg = false;\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tint xx = now.x1 + vx[i];\n\t\t\t\t\tint yy = now.y1 + vy[i];\n\t\t\t\t\tint xx2 = now.x2 + vx[i] *  -1;\n\t\t\t\t\tint yy2 = now.y2 + vy[i];\n\t\t\t\t\tif(! isOK(xx,yy) || ! isOK(xx2, yy2)) continue;\n\t\t\t\t\tif(data[0][yy][xx] == '#'){\n\t\t\t\t\t\tyy = now.y1;\n\t\t\t\t\t\txx = now.x1;\n\t\t\t\t\t}\n\t\t\t\t\tif(data[1][yy2][xx2] == '#'){\n\t\t\t\t\t\tyy2 = now.y2;\n\t\t\t\t\t\txx2 = now.x2;\n\t\t\t\t\t}\n\t\t\t\t\tif(data[0][yy][xx] == '%' && data[1][yy2][xx2] == '%'){\n\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\tans = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(data[0][yy][xx] == '%' ||data[1][yy2][xx2] == '%'){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(close[yy][xx][yy2][xx2]) continue;\n\t\t\t\t\t\n\t\t\t\t\topen.add(new C(xx, yy, xx2, yy2));\n\t\t\t\t\tclose[yy][xx][yy2][xx2] = true;\n\t\t\t\t}\n\t\t\t\tif(flg){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\n\tprivate boolean isOK(int xx, int yy) {\n\t\tif(0 <= xx && xx < w && 0 <= yy && yy < h) return true;\n\t\treturn false;\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\t\n\tint[] vx = {-1, 0, 1, 0};\n\tint[] vy = {0, -1, 0, 1};\n\tHashSet<Integer> hash = new HashSet<Integer>();\n\tint getKey(int rx, int ry, int lx, int ly) {\n\t\treturn 1000000 * rx + 10000 * ry + 100 * lx + ly;\n\t}\n\t\n\tboolean inside(int x, int y, int n, int m) {\n\t\treturn 0 <= x && x < m && 0 <= y && y < n;\n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint m = in.nextInt(), n = in.nextInt();\n\t\t\tif (n == 0 && m == 0) break;\n\t\t\t\n\t\t\thash.clear();\n\t\t\tchar[][] rin = new char[n][];\n\t\t\tchar[][] len = new char[n][];\n\t\t\tint rsx = -1, rsy = -1, lsx = -1, lsy = -1;\n\t\t\tint rgx = -1, rgy = -1, lgx = -1, lgy = -1;\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tlen[i] = in.next().toCharArray();\n\t\t\t\trin[i] = in.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tif (rin[i][j] == '%') {\n\t\t\t\t\t\trgx = j; rgy = i;\n\t\t\t\t\t} else if (rin[i][j] == 'R') {\n\t\t\t\t\t\trsx = j; rsy = i;\n\t\t\t\t\t}\n\t\t\t\t\tif (len[i][j] == '%') {\n\t\t\t\t\t\tlgx = j; lgy = i;\n\t\t\t\t\t} else if (len[i][j] == 'L') {\n\t\t\t\t\t\tlsx = j; lsy = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\thash.add(getKey(rsx, rsy, lsx, lsy));\n\t\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\t\tq.add(getKey(rsx, rsy, lsx, lsy));\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tint next = q.poll();\n\t\t\t\tint ly = next % 100;\n\t\t\t\tnext /= 100;\n\t\t\t\tint lx = next % 100;\n\t\t\t\tnext /= 100;\n\t\t\t\tint ry = next % 100;\n\t\t\t\tnext /= 100;\n\t\t\t\tint rx = next % 100;\n\t\t\t\t\t\t\t\t\n\t\t\t\tfor (int d = 0; d < vx.length; d++) {\n\t\t\t\t\tint nrx = rx + vx[d], nry = ry + vy[d];\n\t\t\t\t\tint nlx = lx - vx[d], nly = ly + vy[d];\n\t\t\t\t\t\n\t\t\t\t\tif (inside(nlx, nly, n, m) && inside(nrx, nry, n, m)) {\n\t\t\t\t\t\tif (rin[nry][nrx] == '#') {\n\t\t\t\t\t\t\tif (len[nly][nlx] == '#') {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnry = ry;\n\t\t\t\t\t\t\t\tnrx = rx;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (len[nly][nlx] == '#') {\n\t\t\t\t\t\t\t\tnly = ly;\n\t\t\t\t\t\t\t\tnlx = lx;\n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (hash.contains(getKey(nrx, nry, nlx, nly))) continue;\n\t\t\t\t\t\thash.add(getKey(nrx, nry, nlx, nly));\n\t\t\t\t\t\tif (!((nrx == rgx && nry == rgy) || (nlx == lgx && nly == lgy))) {\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tq.add(getKey(nrx, nry, nlx, nly));\n\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(hash.contains(getKey(rgx, rgy, lgx, lgy)) ? \"Yes\" : \"No\");\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.System.*;\n\nimport java.lang.reflect.Array;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Queue;\nimport java.util.Random;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static Random rand=new Random();\n\n\tclass Pos{\n\t\tint lx,ly,rx,ry;\n\t\tpublic Pos(int _lx,int _ly,int _rx,int _ry) {\n\t\t\tlx=_lx;ly=_ly;rx=_rx;ry=_ry;\n\t\t}\n\t}\n\n\tint[] dx1=new int[]{1,0,-1,0};\n\tint[] dy1=new int[]{0,1,0,-1};\n\tint[] dx2=new int[]{-1,0,1,0};\n\tint[] dy2=new int[]{0,1,0,-1};\n\n\n\tpublic void run() {\n\t\tCase:while(true){\n\t\t\tint W=sc.nextInt(),H=sc.nextInt();\n\t\t\tif(W==0 && H==0)return;\n\t\t\tchar[][] map1=new char[H][W],map2=new char[H][W];\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tmap1[i]=sc.next().toCharArray();\n\t\t\t\tmap2[i]=sc.next().toCharArray();\n\t\t\t}\n\n\t\t\tboolean[][][][] passed=new boolean[H][W][H][W];\n\n\t\t\tint lx=-1,ly=-1,rx=-1,ry=-1;\n\t\t\tfor(int h=0;h<H;h++)for(int w=0;w<W;w++){\n\t\t\t\tif(map1[h][w]=='L'){\n\t\t\t\t\tlx=w;ly=h;\n\t\t\t\t}\n\t\t\t\tif(map2[h][w]=='R'){\n\t\t\t\t\trx=w;ry=h;\n\t\t\t\t}\n\t\t\t}\n\t\t\tQueue<Pos> que=new LinkedList<Pos>();\n\n\t\t\tque.add(new Pos(lx, ly, rx, ry));\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tPos p=que.poll();\n\t\t\t\tif(passed[p.ly][p.lx][p.ry][p.rx])continue;\n\t\t\t\tpassed[p.ly][p.lx][p.ry][p.rx]=true;\n\t\t\t\t//4方向\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint nx1=p.lx+dx1[i],ny1=p.ly+dy1[i];\n\t\t\t\t\tint nx2=p.rx+dx2[i],ny2=p.ry+dy2[i];\n\t\t\t\t\tif(0<=nx1 && nx1 <W &&\n\t\t\t\t\t0<=ny1 && ny1<H &&\n\t\t\t\t\t0<=nx2 && nx2<W &&\n\t\t\t\t\t0<=ny2 && ny2<H){\n\t\t\t\t\t\tif(map1[ny1][nx1]=='%' && map2[ny2][nx2]=='%'){\n\t\t\t\t\t\t\tln(str(true));continue Case;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(map1[ny1][nx1]=='#'){\n\t\t\t\t\t\t\tnx1=p.lx;ny1=p.ly;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(map2[ny2][nx2]=='#'){\n\t\t\t\t\t\t\tnx2=p.rx;ny2=p.ry;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tque.add(new Pos(nx1,ny1,nx2,ny2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tln(str(false));\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tstatic Scanner sc=new Scanner(in);\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(boolean o){\n\t\treturn o?\"Yes\":\"No\";\n\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\t//depth ex A[10]…1 A[10][10]…2 exception A[0]…0 A[10][0]…1 A[0][0]…0\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint w, h;\n\tboolean[][] mapl, mapr;\n\tbyte sxl, syl, sxr, syr;\n\tbyte gxl, gyl, gxr, gyr;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif( (w|h) == 0 ) break;\n\t\t\t\n\t\t\tmapl = new boolean[h+2][w+2];\n\t\t\tmapr = new boolean[h+2][w+2];\n\t\t\t\n\t\t\tfor(int i=1;i<=h;i++) {\n\t\t\t\tString l = sc.next();\n\t\t\t\tString r = sc.next();\n//\t\t\t\tdebug(l, r);\n\t\t\t\tfor(int j=1;j<=w;j++) {\n\t\t\t\t\tswitch (l.charAt(j-1)) {\n\t\t\t\t\tcase '%':\n\t\t\t\t\t\tgxl = (byte)j;\n\t\t\t\t\t\tgyl = (byte)i;\n\t\t\t\t\t\tmapl[i][j] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\tsxl = (byte)j;\n\t\t\t\t\t\tsyl = (byte)i;\n\t\t\t\t\t\tmapl[i][j] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '.':\n\t\t\t\t\t\tmapl[i][j] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault :mapl[i][j] = false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tswitch (r.charAt(j-1)) {\n\t\t\t\t\tcase '%':\n\t\t\t\t\t\tgxr = (byte)j;\n\t\t\t\t\t\tgyr = (byte)i;\n\t\t\t\t\t\tmapr[i][j] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'R':\n\t\t\t\t\t\tsxr = (byte)j;\n\t\t\t\t\t\tsyr = (byte)i;\n\t\t\t\t\t\tmapr[i][j] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '.':\n\t\t\t\t\t\tmapr[i][j] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault :mapr[i][j] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( solve() ) System.out.println(\"Yes\");\n\t\t\telse System.out.println(\"No\");\n\t\t}\n\t}\n\t\n\tbyte dx[] = {-1,0,1,0};\n\tbyte dy[] = {0,-1,0,1}; \n\t\n\tboolean solve() {\n\t\tboolean[][][][] visited = new boolean[h+2][w+2][h+2][w+2];\n\t\tLinkedList<W> que = new LinkedList<W>();\n\t\tW now = new W( new P((byte)sxl, (byte)syl), new P((byte)sxr, (byte)syr) );\n\t\tque.add(now);\n\t\tvisited[now.l.y][now.l.x][now.r.y][now.r.x] = true;\n\t\tfor(;!que.isEmpty();) {\n\t\t\tnow = que.removeFirst();\n//\t\t\tdebug(now.l.x, now.l.y, now.r.x, now.r.y);\n\t\t\tint g = isGoal(now);\n\t\t\tif( g == 1 ) return true;\n\t\t\tif( g == -1 ) continue;\n\t\t\t\n\t\t\tfor(int i=0;i<4;i++) {\n\t\t\t\tbyte nxl = (byte)(now.l.x + dx[i]);\n\t\t\t\tbyte nyl = (byte)(now.l.y + dy[i]);\n\t\t\t\tbyte nxr = (byte)(now.r.x - dx[i]);\n\t\t\t\tbyte nyr = (byte)(now.r.y + dy[i]);\n\t\t\t\tif( !mapl[nyl][nxl] ) {\n\t\t\t\t\tnxl -= dx[i];\n\t\t\t\t\tnyl -= dy[i];\n\t\t\t\t}\n\t\t\t\tif( !mapr[nyr][nxr] ) {\n\t\t\t\t\tnxr += dx[i];\n\t\t\t\t\tnyr -= dy[i];\n\t\t\t\t}\n\t\t\t\tif( visited[nyl][nxl][nyr][nxr] ) continue;\n\t\t\t\tque.add( new W( new P(nxl, nyl), new P(nxr, nyr) ) );\n\t\t\t\tvisited[nyl][nxl][nyr][nxr] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tint isGoal(W w) {\n\t\tif( w.l.equals(new P(gxl, gyl)) && w.r.equals(new P(gxr, gyr)) )\n\t\t\treturn 1;\n\t\tif( w.l.equals(new P(gxl, gyl)) ^ w.r.equals(new P(gxr, gyr)) )\n\t\t\treturn -1;\n\t\telse return 0;\n\t}\n\t\n\tclass W {\n\t\tP l, r;\n\t\tW(P l, P r) {\n\t\t\tthis.l = l;\n\t\t\tthis.r = r;\n\t\t}\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif(o instanceof W) {\n\t\t\t\tW w = (W) o;\n\t\t\t\treturn l.equals(w.l) && r.equals(w.r);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn r.hashCode() * 2500 + l.hashCode();\n\t\t}\n\t}\n\t\n\tclass P {\n\t\tbyte x, y;\n\t\tP(byte x, byte y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif(o instanceof P) {\n\t\t\t\tP p = (P)o;\n\t\t\t\treturn x == p.x && y == p.y;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn (int)x * 50 + y;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\t\n\tint[] vx = {-1, 0, 1, 0};\n\tint[] vy = {0, -1, 0, 1};\n\t\n\tQueue<Integer> q = new LinkedList<Integer>();\n\tboolean[][][][] vis = new boolean[50][50][50][50];\n\t\n\tint getKey(int rx, int ry, int lx, int ly) {\n\t\treturn 1000000 * rx + 10000 * ry + 100 * lx + ly;\n\t}\n\t\n\tboolean inside(int x, int y, int n, int m) {\n\t\treturn 0 <= x && x < m && 0 <= y && y < n;\n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint m = in.nextInt(), n = in.nextInt();\n\t\t\tif (n == 0 && m == 0) break;\n\t\t\t\n\t\t\tfor (int i = 0; i < 50; i++) for (int j = 0; j < 50; j++) for (int k = 0; k < 50; k++) {\n\t\t\t\tArrays.fill(vis[i][j][k], false);\n\t\t\t}\n\t\t\tq.clear();\n\t\t\tchar[][] rin = new char[n][];\n\t\t\tchar[][] len = new char[n][];\n\t\t\tint rsx = -1, rsy = -1, lsx = -1, lsy = -1;\n\t\t\tint rgx = -1, rgy = -1, lgx = -1, lgy = -1;\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tlen[i] = in.next().toCharArray();\n\t\t\t\trin[i] = in.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tif (rin[i][j] == '%') {\n\t\t\t\t\t\trgx = j; rgy = i;\n\t\t\t\t\t} else if (rin[i][j] == 'R') {\n\t\t\t\t\t\trsx = j; rsy = i;\n\t\t\t\t\t}\n\t\t\t\t\tif (len[i][j] == '%') {\n\t\t\t\t\t\tlgx = j; lgy = i;\n\t\t\t\t\t} else if (len[i][j] == 'L') {\n\t\t\t\t\t\tlsx = j; lsy = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvis[rsx][rsy][lsx][lsy] = true;\n\t\t\tq.add(getKey(rsx, rsy, lsx, lsy));\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tint next = q.poll();\n\t\t\t\tint ly = next % 100;\n\t\t\t\tnext /= 100;\n\t\t\t\tint lx = next % 100;\n\t\t\t\tnext /= 100;\n\t\t\t\tint ry = next % 100;\n\t\t\t\tnext /= 100;\n\t\t\t\tint rx = next % 100;\n\t\t\t\t\t\t\t\t\n\t\t\t\tfor (int d = 0; d < vx.length; d++) {\n\t\t\t\t\tint nrx = rx + vx[d], nry = ry + vy[d];\n\t\t\t\t\tint nlx = lx - vx[d], nly = ly + vy[d];\n\t\t\t\t\t\n\t\t\t\t\tif (!inside(nrx, nry, n, m) || rin[nry][nrx] == '#') {\n\t\t\t\t\t\tnrx = rx; nry = ry;\n\t\t\t\t\t}\n\t\t\t\t\tif (!inside(nlx, nly, n, m) || len[nly][nlx] == '#') {\n\t\t\t\t\t\tnlx = lx; nly = ly;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (vis[nrx][nry][nlx][nly]) continue;\n\t\t\t\t\tvis[nrx][nry][nlx][nly] = true;\n\t\t\t\t\tif (!((nrx == rgx && nry == rgy) || (nlx == lgx && nly == lgy))) {\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tq.add(getKey(nrx, nry, nlx, nly));\n\t\t\t\t\t}\t\t\t\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(vis[rgx][rgy][lgx][lgy] ? \"Yes\" : \"No\");\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.BitSet;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DY = { 1, 0, -1, 0 };\n\tstatic int[] DX = { 0, -1, 0, 1 };\n\tstatic int W, H;\n\tstatic char[][] mapL, mapR;\n\tstatic BitSet visited = new BitSet(1 << 24);\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tW = sc.nextInt();\n\t\t\tH = sc.nextInt();\n\t\t\tif (W == 0) break;\n\t\t\tmapL = new char[H][];\n\t\t\tmapR = new char[H][];\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tmapL[i] = sc.next().toCharArray();\n\t\t\t\tmapR[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tSystem.out.println(solve() ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\n\tstatic boolean solve() {\n\t\tboolean[] visited = new boolean[H * W * H * W];\n\t\tint pos = 0;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (mapL[i][j] == 'L') {\n\t\t\t\t\tpos |= (i << 18) | (j << 12);\n\t\t\t\t}\n\t\t\t\tif (mapR[i][j] == 'R') {\n\t\t\t\t\tpos |= (i << 6) | j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvisited[posToIdx(pos)] = true;\n\t\tint[] q = new int[1 << 23];\n\t\tint qs = 0;\n\t\tint qe = 1;\n\t\tq[0] = pos;\n\t\twhile (qs != qe) {\n\t\t\tint p = q[qs++];\n\t\t\tint y1 = p >> 18;\n\t\t\tint x1 = (p >> 12) & 0x3F;\n\t\t\tint y2 = (p >> 6) & 0x3F;\n\t\t\tint x2 = p & 0x3F;\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tint ny1 = y1 + DY[i];\n\t\t\t\tint nx1 = x1 + DX[i];\n\t\t\t\tint ny2 = y2 + DY[i];\n\t\t\t\tint nx2 = x2 - DX[i];\n\t\t\t\tif (ny1 < 0 || H <= ny1 || nx1 < 0 || W <= nx1 || mapL[ny1][nx1] == '#') {\n\t\t\t\t\tny1 = y1;\n\t\t\t\t\tnx1 = x1;\n\t\t\t\t}\n\t\t\t\tif (ny2 < 0 || H <= ny2 || nx2 < 0 || W <= nx2 || mapR[ny2][nx2] == '#') {\n\t\t\t\t\tny2 = y2;\n\t\t\t\t\tnx2 = x2;\n\t\t\t\t}\n\t\t\t\tboolean goalL = mapL[ny1][nx1] == '%';\n\t\t\t\tboolean goalR = mapR[ny2][nx2] == '%';\n\t\t\t\tif (goalL && goalR) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (!goalL && !goalR) {\n\t\t\t\t\tint np = (ny1 << 18) | (nx1 << 12) | (ny2 << 6) | nx2;\n\t\t\t\t\tint ni = posToIdx(np);\n\t\t\t\t\tif (!visited[ni]) {\n\t\t\t\t\t\tvisited[ni] = true;\n\t\t\t\t\t\tq[qe++] = np;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic int posToIdx(int p) {\n\t\tint y1 = p >> 18;\n\t\tint x1 = (p >> 12) & 0x3F;\n\t\tint y2 = (p >> 6) & 0x3F;\n\t\tint x2 = p & 0x3F;\n\t\treturn (y1 * W + x1) * H * W + (y2 * W + x2);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nimport javax.xml.crypto.Data;\npublic class Main{\n\tstatic int INF = 2 << 28;\n\tstatic int[] vxL = {0,0,1,-1};\n\tstatic int[] vxR = {0,0,-1,1};\n\tstatic int[] vyL = {1,-1,0,0};\n\tstatic int[] vyR = {1,-1,0,0};\n\tstatic int w;\n\tstatic int h;\n\tstatic int Lx;\n\tstatic int Ly;\n\tstatic int Rx;\n\tstatic int Ry;\n\tstatic char[][] mapL;\n\tstatic char[][] mapR;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif(w == 0 && h == 0) break;\n\t\t\tmapL = new char[h][];\n\t\t\tmapR = new char[h][];\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tmapL[i] = sc.next().toCharArray();\n\t\t\t\tmapR[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tLx = 0;\n\t\t\tLy = 0;\n\t\t\tRx = 0;\n\t\t\tRy = 0;\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(mapL[i][j] == 'L') {\n\t\t\t\t\t\tLy = i;\n\t\t\t\t\t\tLx = j;\n\t\t\t\t\t\tmapL[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t\tif(mapR[i][j] == 'R') {\n\t\t\t\t\t\tRy = i;\n\t\t\t\t\t\tRx = j;\n\t\t\t\t\t\tmapR[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean ans = BFS();\n\t\t\tif(ans) {\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t}\t\n\tstatic boolean BFS() {\n\t\tHashMap<Data,Boolean> map = new HashMap<Data,Boolean>();\n\t\tArrayDeque<Data> queue = new ArrayDeque<Data>();\n\t\tqueue.add(new Data(Lx,Ly,Rx,Ry));\n\t\twhile(!queue.isEmpty()) {\n\t\t\tData tmp = queue.poll();\n\t\t\tif(map.containsKey(map)) continue;\n\t\t\tmap.put(tmp, true);\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\t\n\t\t\t\tint Ltx = tmp.Lx + vxL[i];\n\t\t\t\tint Lty = tmp.Ly + vyL[i];\n\t\t\t\tint Rtx = tmp.Rx + vxR[i];\n\t\t\t\tint Rty = tmp.Ry + vyR[i];\n\t\t\t\t\n\t\t\t\tint  L = Rcheck(Ltx,Lty,mapL);\n\t\t\t\tint  R = Rcheck(Rtx,Rty,mapR);\n\t\t\t\t\n\t\t\t\tif(L == 2 && R == 2) return true;\n\t\t\t\tif(L == 2 && R != 2) continue;\n\t\t\t\tif(L != 2 && R == 2) continue;\n\t\t\t\tif(L == 0 && R == 0) continue;\n\t\t\t\tif(L == 0) {\n\t\t\t\t\tLtx = tmp.Lx;\n\t\t\t\t\tLty = tmp.Ly;\n\t\t\t\t}\n\t\t\t\tif(R == 0) {\n\t\t\t\t\tRtx = tmp.Rx;\n\t\t\t\t\tRty = tmp.Ry;\n\t\t\t\t}\n\t\t\t\tqueue.addLast(new Data(Ltx,Lty,Rtx,Rty));\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t\t\n\t}\n\tstatic int Rcheck(int x,int y,char[][] map) {\n\t\tif(x < 0 || y < 0 || x >= w || y >= h) return 0;\n\t\tif(map[y][x] == '#') return 0;\n\t\tif(map[y][x] == '.') return 1;\n\t\tif(map[y][x] == '%') return 2;\n\t\treturn -1;\n\t}\n\t\n\tstatic class Data {\n\t\tint Lx;\n\t\tint Ly;\n\t\tint Rx;\n\t\tint Ry;\n\t\tData(int a, int b, int c, int d) {\n\t\t\tLx = a;\n\t\t\tLy = b;\n\t\t\tRx = c;\n\t\t\tRy = d;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.BitSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\npublic class Main{\n\tpublic static final int[] dx = {1, 0, -1, 0};\n\tpublic static final int[] dy = {0, 1, 0, -1};\n\tpublic static int w, h;\n\tpublic static char[][][] map;\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = in.nextInt();\n\t\t\th = in.nextInt();\n\t\t\tif(w == 0) break;\n\t\t\tmap = new char[2][h][w];\n\t\t\tint g = 0;\n\t\t\tint s = 0;\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\tfor(int j=0; j<2; j++){\n\t\t\t\t\tchar[] line = in.next().toCharArray();\n\t\t\t\t\tif(j==0) map[j][i] = line;\n\t\t\t\t\telse{\n\t\t\t\t\t\tfor(int k=0; k<w; k++){\n\t\t\t\t\t\t\tmap[j][i][k] = line[w-1-k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0; k<w; k++){\n\t\t\t\t\t\tswitch(map[j][i][k]){\n\t\t\t\t\t\tcase 'R':\n\t\t\t\t\t\t\ts += i*w+k;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'L':\n\t\t\t\t\t\t\ts += (i*w+k)*h*w;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '%':\n\t\t\t\t\t\t\tg += id(j, i, k);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tBitSet used = new BitSet(w*w*h*h);\n\t\t\tQueue<Integer> qu = new LinkedList<Integer>();\n\t\t\tqu.add(s);\n\t\t\tused.set(s);\n\t\t\tint hw = h*w;\n\t\t\tint whw = w*h*w;\n\t\t\tboolean flag = false;\n\t\t\twhile(!qu.isEmpty()){\n\t\t\t\tint id = qu.poll();\n\t\t\t\tif(id == g){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint y0 = id/whw;\n\t\t\t\tid %= whw;\n\t\t\t\tint x0 = id/hw;\n\t\t\t\tid %= hw;\n\t\t\t\tint y1 = id/w;\n\t\t\t\tint x1 = id%w;\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tint nid = next(x0, y0, x1, y1, i);\n\t\t\t\t\tif(used.get(nid)) continue;\n\t\t\t\t\tused.set(nid);\n\t\t\t\t\tqu.add(nid);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(flag ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\t\n\tpublic static String dump(char[][] map){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tsb.append(map[i][j]+\" \");\n\t\t\t}\n\t\t\tsb.append('\\n');\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tpublic static int next(int x0, int y0, int x1, int y1, int dir){\n\t\tint nx0 = x0 + dx[dir];\n\t\tint ny0 = y0 + dy[dir];\n\t\tif(nx0 < 0 || nx0 >= w || ny0 < 0 || ny0 >= h\n\t\t\t\t|| map[0][ny0][nx0] == '#'){\n\t\t\tnx0 = x0;\n\t\t\tny0 = y0;\n\t\t}\n\t\tint nx1 = x1 + dx[dir];\n\t\tint ny1 = y1 + dy[dir];\n\t\tif(nx1 < 0 || nx1 >= w || ny1 < 0 || ny1 >= h\n\t\t\t\t|| map[1][ny1][nx1] == '#'){\n\t\t\tnx1 = x1;\n\t\t\tny1 = y1;\n\t\t}\n\t\treturn id(0, ny0, nx0) + id(1, ny1, nx1);\n\t}\n\t\n\tpublic static int id(int room, int y, int x){\n\t\treturn room==0 ? (y*w+x)*w*h : y*w+x;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nimport javax.xml.crypto.Data;\npublic class Main{\n\tstatic int INF = 2 << 28;\n\tstatic int[] vxL = {0,0,1,-1};\n\tstatic int[] vxR = {0,0,-1,1};\n\tstatic int[] vyL = {1,-1,0,0};\n\tstatic int[] vyR = {1,-1,0,0};\n\tstatic int w;\n\tstatic int h;\n\tstatic int Lx;\n\tstatic int Ly;\n\tstatic int Rx;\n\tstatic int Ry;\n\tstatic char[][] mapL;\n\tstatic char[][] mapR;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif(w == 0 && h == 0) break;\n\t\t\tmapL = new char[h][];\n\t\t\tmapR = new char[h][];\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tmapL[i] = sc.next().toCharArray();\n\t\t\t\tmapR[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tLx = 0;\n\t\t\tLy = 0;\n\t\t\tRx = 0;\n\t\t\tRy = 0;\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(mapL[i][j] == 'L') {\n\t\t\t\t\t\tLy = i;\n\t\t\t\t\t\tLx = j;\n\t\t\t\t\t\tmapL[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t\tif(mapR[i][j] == 'R') {\n\t\t\t\t\t\tRy = i;\n\t\t\t\t\t\tRx = j;\n\t\t\t\t\t\tmapR[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean ans = BFS();\n\t\t\tif(ans) {\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t}\t\n\tstatic boolean BFS() {\n\t\tHashMap<String,Boolean> map = new HashMap<String,Boolean>();\n\t\tArrayDeque<Data> queue = new ArrayDeque<Data>();\n\t\tqueue.add(new Data(Lx,Ly,Rx,Ry));\n\t\twhile(!queue.isEmpty()) {\n\t\t\tData tmp = queue.poll();\n\t\t\tString pp = tmp.Lx + \" \" + tmp.Ly + \" \" + tmp.Rx + \" \" + tmp.Ry;\n\t\t\tif(map.containsKey(pp)) continue;\n\t\t\tmap.put(pp, true);\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\t\n\t\t\t\tint Ltx = tmp.Lx + vxL[i];\n\t\t\t\tint Lty = tmp.Ly + vyL[i];\n\t\t\t\tint Rtx = tmp.Rx + vxR[i];\n\t\t\t\tint Rty = tmp.Ry + vyR[i];\n\t\t\t\t\n\t\t\t\tint  L = Rcheck(Ltx,Lty,mapL);\n\t\t\t\tint  R = Rcheck(Rtx,Rty,mapR);\n\t\t\t\t\n\t\t\t\tif(L == 2 && R == 2) return true;\n\t\t\t\tif(L == 2 && R != 2) continue;\n\t\t\t\tif(L != 2 && R == 2) continue;\n\t\t\t\tif(L == 0 && R == 0) continue;\n\t\t\t\tif(L == 0) {\n\t\t\t\t\tLtx = tmp.Lx;\n\t\t\t\t\tLty = tmp.Ly;\n\t\t\t\t}\n\t\t\t\tif(R == 0) {\n\t\t\t\t\tRtx = tmp.Rx;\n\t\t\t\t\tRty = tmp.Ry;\n\t\t\t\t}\n\t\t\t\tqueue.addLast(new Data(Ltx,Lty,Rtx,Rty));\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t\t\n\t}\n\tstatic int Rcheck(int x,int y,char[][] map) {\n\t\tif(x < 0 || y < 0 || x >= w || y >= h) return 0;\n\t\tif(map[y][x] == '#') return 0;\n\t\tif(map[y][x] == '.') return 1;\n\t\tif(map[y][x] == '%') return 2;\n\t\treturn -1;\n\t}\n\t\n\tstatic class Data {\n\t\tint Lx;\n\t\tint Ly;\n\t\tint Rx;\n\t\tint Ry;\n\t\tData(int a, int b, int c, int d) {\n\t\t\tLx = a;\n\t\t\tLy = b;\n\t\t\tRx = c;\n\t\t\tRy = d;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.LinkedList;\nimport java.util.Scanner;\npublic class Main {\n\n\tpublic static final void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tint w;\n\tint h;\n\tchar[][] map = new char[2][100*100];\n\tint sl;\n\tint sr;\n\tpublic Main() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif(w==0 && h==0)\n\t\t\t\tbreak;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tString s0 = sc.next();\n\t\t\t\tString s1 = sc.next();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tmap[0][i*w+j] = s0.charAt(j);\n\t\t\t\t\tmap[1][i*w+j] = s1.charAt(w-j-1);\n\t\t\t\t\tif(map[0][i*w+j]=='L')\n\t\t\t\t\t\tsl = i*w+j;\n\t\t\t\t\tif(map[1][i*w+j]=='R')\n\t\t\t\t\t\tsr = i*w+j;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tint[] dx = new int[]{-1, 0, 1, 0};\n\tint[] dy = new int[]{0, -1, 0, 1};\n\tprivate void solve() {\n\t\tLinkedList<int[]> queue = new LinkedList<int[]>();\n\t\t\n\t\tint[][] visited = new int[w*h][w*h];\n\t\tqueue.add(new int[]{sl, sr});\n\n\t\twhile(!queue.isEmpty()){\n\t\t\tint[] cp = queue.poll();\n\t\t\tint clp = cp[0];\n\t\t\tint crp = cp[1];\n\t\t\t\n\t\t\tif(visited[clp][crp]==1)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tvisited[clp][crp] = 1;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nlp = clp + dx[i] + dy[i]*w;\n\t\t\t\tint nrp = crp + dx[i] + dy[i]*w;\n\t\t\t\tif(nlp<0 || w*h<=nlp || nrp<0 || w*h<=nrp)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(map[0][nlp]=='#')\n\t\t\t\t\tnlp = clp;\n\t\t\t\tif(map[1][nrp]=='#')\n\t\t\t\t\tnrp = crp;\n\t\t\t\t\n\t\t\t\tif(map[0][nlp]=='%' && map[1][nrp]=='%'){\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tqueue.add(new int[]{nlp, nrp});\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"No\");\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(in);\n\t\n\tvoid run() {\n\t\tboolean[][] rooml = new boolean[50][50];\n\t\tboolean[][] roomr = new boolean[50][50];\n\t\tboolean[][][][] used = new boolean[50][50][50][50]; \n\t\tint dlx, dly, drx, dry, lx, ly, rx, ry;\n\t\tdlx = dly = drx = dry = lx = ly = rx = ry = 0;\n\t\tQueue<Integer> quelx = new LinkedList<Integer>();\n\t\tQueue<Integer> quely = new LinkedList<Integer>();\n\t\tQueue<Integer> querx = new LinkedList<Integer>();\n\t\tQueue<Integer> query = new LinkedList<Integer>();\n\t\tint[] dilx = {1, -1, 0, 0};\n\t\tint[] dily = {0, 0, 1, -1};\n\t\tint[] dirx = {1, -1, 0, 0};\n\t\tint[] diry = {0, 0, -1, 1};\n\t\twhile (true) {\n\t\t\tint w = sc.nextInt(), h = sc.nextInt();\n\t\t\tif (w == 0 && h == 0) break;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString l = sc.next(), r = sc.next();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tswitch (l.charAt(j)) {\n\t\t\t\t\tcase '.': rooml[i][j] = true; break;\n\t\t\t\t\tcase '#': rooml[i][j] = false; break;\n\t\t\t\t\tcase '%': \n\t\t\t\t\t\trooml[i][j] = true;\n\t\t\t\t\t\tdlx = i; dly = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\trooml[i][j] = true;\n\t\t\t\t\t\tlx = i;\n\t\t\t\t\t\tly = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tswitch (r.charAt(j)) {\n\t\t\t\t\tcase '.': roomr[i][j] = true; break;\n\t\t\t\t\tcase '#': roomr[i][j] = false; break;\n\t\t\t\t\tcase '%': \n\t\t\t\t\t\troomr[i][j] = true;\n\t\t\t\t\t\tdrx = i; dry = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'R':\n\t\t\t\t\t\troomr[i][j] = true;\n\t\t\t\t\t\trx = i;\n\t\t\t\t\t\try = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tquelx.clear(); quely.clear();\n\t\t\tquerx.clear(); query.clear();\n\t\t\tfor (int i = 0; i < 50; i++)\n\t\t\t\tfor (int j = 0; j < 50; j++)\n\t\t\t\t\tfor (int k = 0; k < 50; k++)\n\t\t\t\t\t\tArrays.fill(used[i][j][k], false);\n\t\t\tquelx.add(lx); quely.add(ly);\n\t\t\tquerx.add(rx); query.add(ry);\n\t\t\tused[lx][ly][rx][ry] = true;\n\t\t\tboolean flag = false;\n\t\t\twhile (!quelx.isEmpty()) {\n\t\t\t\tint telx = quelx.poll(), tely = quely.poll();\n\t\t\t\tint terx = querx.poll(), tery = query.poll();\n\t\t\t\tif (telx == dlx && tely == dly && terx == drx && tery == dry) {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (telx == dlx && tely == dly && !(terx == drx && tery == dry)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!(telx == dlx && tely == dly) && terx == drx && tery == dry) continue;\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint lX = telx + dilx[i], lY = tely + dily[i];\n\t\t\t\t\tint rX = terx + dirx[i], rY = tery + diry[i];\n\t\t\t\t\tif (!(0 <= lX && lX < h && 0 <= lY && lY < w && rooml[lX][lY])) {\n\t\t\t\t\t\tlX = telx;\n\t\t\t\t\t\tlY = tely;\n\t\t\t\t\t}\n\t\t\t\t\tif (!(0 <= rX && rX < h && 0 <= rY && rY < w && roomr[rX][rY])) {\n\t\t\t\t\t\trX = terx;\n\t\t\t\t\t\trY = tery;\n\t\t\t\t\t}\n\t\t\t\t\tif (!used[lX][lY][rX][rY]) {\n\t\t\t\t\t\tused[lX][lY][rX][rY] = true;\n\t\t\t\t\t\tquelx.add(lX); quely.add(lY);\n\t\t\t\t\t\tquerx.add(rX); query.add(rY);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (flag)\n\t\t\t\tout.println(\"Yes\");\n\t\t\telse\n\t\t\t\tout.println(\"No\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint m, n;\n\n\tint[][] al, ar;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tm=sc.nextInt();\n\t\t\tn=sc.nextInt();\n\t\t\tif((m|n)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tal=new int[n][m];\n\t\t\tar=new int[n][m];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tString sl=sc.next();\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\tal[j][i]=c2i(sl.charAt(i));\n\t\t\t\t}\n\t\t\t\tString sr=sc.next();\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\tar[j][i]=c2i(sr.charAt(i));\n\t\t\t\t}\n\t\t\t\t// debug(al[j], ar[j]);\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\t// boolean[][][][] visited=new boolean[m][n][m][n];\n\t\tHashSet<Integer> visited=new HashSet<Integer>();\n\t\tint xl0=0, yl0=0, xr0=0, yr0=0;\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tif(al[j][i]==-1){\n\t\t\t\t\txl0=i;\n\t\t\t\t\tyl0=j;\n\t\t\t\t\tal[j][i]=0;\n\t\t\t\t}\n\t\t\t\tif(ar[j][i]==-1){\n\t\t\t\t\txr0=i;\n\t\t\t\t\tyr0=j;\n\t\t\t\t\tar[j][i]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tLinkedList<P> que=new LinkedList<P>();\n\t\tque.offer(new P(xl0, yl0, xr0, yr0));\n\t\tvisited.add(hash(xl0, yl0, xr0, yr0));\n\t\tint[] dxl={0, 0, -1, 1};\n\t\tint[] dyl={-1, 1, 0, 0};\n\t\tint[] dxr={0, 0, 1, -1};\n\t\tint[] dyr={-1, 1, 0, 0};\n\t\tboolean yes=false;\n\t\tfor(; !que.isEmpty()&&!yes;){\n\t\t\tP p=que.poll();\n\t\t\t// debug(p.xl, p.yl, p.xr, p.yr);\n\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\tP q=new P(p.xl+dxl[i], p.yl+dyl[i], p.xr+dxr[i], p.yr+dyr[i]);\n\t\t\t\tif(!in(q.xl, q.yl)||al[q.yl][q.xl]==1){\n\t\t\t\t\tq.xl=p.xl;\n\t\t\t\t\tq.yl=p.yl;\n\t\t\t\t}\n\t\t\t\tif(!in(q.xr, q.yr)||ar[q.yr][q.xr]==1){\n\t\t\t\t\tq.xr=p.xr;\n\t\t\t\t\tq.yr=p.yr;\n\t\t\t\t}\n\t\t\t\t// debug(\"\\t\", q.xl, q.yl, q.xr, q.yr);\n\t\t\t\t// q.xr=max(min(q.xr, m-1), 0);\n\t\t\t\t// q.yr=max(min(q.yr, n-1), 0);\n\t\t\t\tboolean ll=al[q.yl][q.xl]==2;\n\t\t\t\tboolean rr=ar[q.yr][q.xr]==2;\n\t\t\t\tif(ll^rr){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(ll&&rr){\n\t\t\t\t\tyes=true;\n\t\t\t\t}\n\t\t\t\tint hash=hash(q.xl, q.yl, q.xr, q.yr);\n\t\t\t\t// if(!visited[q.xl][q.yl][q.xr][q.yr]){\n\t\t\t\t// visited[q.xl][q.yl][q.xr][q.yr]=true;\n\t\t\t\t// que.offer(q);\n\t\t\t\t// }\n\t\t\t\tif(!visited.contains(hash)){\n\t\t\t\t\tvisited.add(hash);\n\t\t\t\t\tque.offer(q);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintln(yes?\"Yes\":\"No\");\n\t}\n\n\tint hash(int xl, int yl, int xr, int yr){\n\t\treturn (xl*50+yl)*2500+(xr*50+yr);\n\t}\n\n\tboolean in(int x, int y){\n\t\treturn x>=0&&x<m&&y>=0&&y<n;\n\t}\n\n\tclass P{\n\t\tbyte xl, yl, xr, yr;\n\n\t\tP(int xl, int yl, int xr, int yr){\n\t\t\tthis.xl=(byte)xl;\n\t\t\tthis.yl=(byte)yl;\n\t\t\tthis.xr=(byte)xr;\n\t\t\tthis.yr=(byte)yr;\n\t\t}\n\t}\n\n\tint c2i(char c){\n\t\tswitch(c){\n\t\tcase '.':\n\t\t\treturn 0;\n\t\tcase '#':\n\t\t\treturn 1;\n\t\tcase '%':\n\t\t\treturn 2;\n\t\tcase 'L':\n\t\t\treturn -1;\n\t\tcase 'R':\n\t\t\treturn -1;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.System.*;\n\nimport java.lang.reflect.Array;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Queue;\nimport java.util.Random;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static Random rand=new Random();\n\n\tclass Pos{\n\t\tint lx,ly,rx,ry;\n\t\tpublic Pos(int _lx,int _ly,int _rx,int _ry) {\n\t\t\tlx=_lx;ly=_ly;rx=_rx;ry=_ry;\n\t\t}\n\t}\n\n\tint[] dx1=new int[]{1,0,-1,0};\n\tint[] dy1=new int[]{0,1,0,-1};\n\tint[] dx2=new int[]{-1,0,1,0};\n\tint[] dy2=new int[]{0,1,0,-1};\n\n\n\tpublic void run() {\n\t\tCase:while(true){\n\t\t\tint W=sc.nextInt(),H=sc.nextInt();\n\t\t\tif(W==0 && H==0)return;\n\t\t\tchar[][] map1=new char[H][W],map2=new char[H][W];\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tmap1[i]=sc.next().toCharArray();\n\t\t\t\tmap2[i]=sc.next().toCharArray();\n\t\t\t}\n\n\t\t\tboolean[][][][] passed=new boolean[H][W][H][W];\n\n\t\t\tint lx=-1,ly=-1,rx=-1,ry=-1;\n\t\t\tfor(int h=0;h<H;h++)for(int w=0;w<W;w++){\n\t\t\t\tif(map1[h][w]=='L'){\n\t\t\t\t\tlx=w;ly=h;\n\t\t\t\t}\n\t\t\t\tif(map2[h][w]=='R'){\n\t\t\t\t\trx=w;ry=h;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tQueue<Pos> que=new LinkedList<Pos>();\n\t\t\tque.add(new Pos(lx, ly, rx, ry));\n\t\t\tpassed[ly][lx][ry][rx]=true;\n\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tPos p=que.poll();\n\t\t\t\t//4方向\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint nx1=p.lx+dx1[i],ny1=p.ly+dy1[i];\n\t\t\t\t\tint nx2=p.rx+dx2[i],ny2=p.ry+dy2[i];\n\t\t\t\t\tif(0<=nx1 && nx1 <W &&\n\t\t\t\t\t0<=ny1 && ny1<H &&\n\t\t\t\t\t0<=nx2 && nx2<W &&\n\t\t\t\t\t0<=ny2 && ny2<H){\n\t\t\t\t\t\tif(map1[ny1][nx1]=='%' && map2[ny2][nx2]=='%'){\n\t\t\t\t\t\t\tln(str(true));continue Case;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(map1[ny1][nx1]=='#'){\n\t\t\t\t\t\t\tnx1=p.lx;ny1=p.ly;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(map2[ny2][nx2]=='#'){\n\t\t\t\t\t\t\tnx2=p.rx;ny2=p.ry;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!passed[ny1][nx1][ny2][nx2]){\n\t\t\t\t\t\t\tque.add(new Pos(nx1,ny1,nx2,ny2));\n\t\t\t\t\t\t\tpassed[ny1][nx1][ny2][nx2]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tln(str(false));\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tstatic Scanner sc=new Scanner(in);\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(boolean o){\n\t\treturn o?\"Yes\":\"No\";\n\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\t//depth ex A[10]…1 A[10][10]…2 exception A[0]…0 A[10][0]…1 A[0][0]…0\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tint INF = 1 << 28;\n\tint w, h;\n\tboolean[][] mapl, mapr;\n\tbyte sxl, syl, sxr, syr;\n\tbyte gxl, gyl, gxr, gyr;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif( (w|h) == 0 ) break;\n\t\t\t\n\t\t\tmapl = new boolean[h+2][w+2];\n\t\t\tmapr = new boolean[h+2][w+2];\n\t\t\t\n\t\t\tfor(int i=1;i<=h;i++) {\n\t\t\t\tString l = sc.next();\n\t\t\t\tString r = sc.next();\n//\t\t\t\tdebug(l, r);\n\t\t\t\tfor(int j=1;j<=w;j++) {\n\t\t\t\t\tswitch (l.charAt(j-1)) {\n\t\t\t\t\tcase '%':\n\t\t\t\t\t\tgxl = (byte)j;\n\t\t\t\t\t\tgyl = (byte)i;\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\tsxl = (byte)j;\n\t\t\t\t\t\tsyl = (byte)i;\n\t\t\t\t\tcase '.':\n\t\t\t\t\t\tmapl[i][j] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault :mapl[i][j] = false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tswitch (r.charAt(j-1)) {\n\t\t\t\t\tcase '%':\n\t\t\t\t\t\tgxr = (byte)j;\n\t\t\t\t\t\tgyr = (byte)i;\n\t\t\t\t\tcase 'R':\n\t\t\t\t\t\tsxr = (byte)j;\n\t\t\t\t\t\tsyr = (byte)i;\n\t\t\t\t\tcase '.':\n\t\t\t\t\t\tmapr[i][j] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault :mapr[i][j] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( solve() ) System.out.println(\"Yes\");\n\t\t\telse System.out.println(\"No\");\n\t\t}\n\t}\n\t\n\tbyte dx[] = {-1,0,1,0};\n\tbyte dy[] = {0,-1,0,1}; \n\t\n\tboolean solve() {\n\t\tboolean[][][][] visited = new boolean[h+2][w+2][h+2][w+2];\n\t\tLinkedList<W> que = new LinkedList<W>();\n\t\tW now = new W( new P((byte)sxl, (byte)syl), new P((byte)sxr, (byte)syr) );\n\t\tque.add(now);\n\t\tvisited[now.l.y][now.l.x][now.r.y][now.r.x] = true;\n\t\tfor(;!que.isEmpty();) {\n\t\t\tnow = que.removeFirst();\n//\t\t\tdebug(now.l.x, now.l.y, now.r.x, now.r.y);\n\t\t\tint g = isGoal(now);\n\t\t\tif( g == 1 ) return true;\n\t\t\tif( g == -1 ) continue;\n\t\t\t\n\t\t\tfor(int i=0;i<4;i++) {\n\t\t\t\tbyte nxl = (byte)(now.l.x + dx[i]);\n\t\t\t\tbyte nyl = (byte)(now.l.y + dy[i]);\n\t\t\t\tbyte nxr = (byte)(now.r.x - dx[i]);\n\t\t\t\tbyte nyr = (byte)(now.r.y + dy[i]);\n\t\t\t\tif( !mapl[nyl][nxl] ) {\n\t\t\t\t\tnxl -= dx[i];\n\t\t\t\t\tnyl -= dy[i];\n\t\t\t\t}\n\t\t\t\tif( !mapr[nyr][nxr] ) {\n\t\t\t\t\tnxr += dx[i];\n\t\t\t\t\tnyr -= dy[i];\n\t\t\t\t}\n\t\t\t\tif( visited[nyl][nxl][nyr][nxr] ) continue;\n\t\t\t\tque.add( new W( new P(nxl, nyl), new P(nxr, nyr) ) );\n\t\t\t\tvisited[nyl][nxl][nyr][nxr] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tint isGoal(W w) {\n\t\tif( w.l.equals(new P(gxl, gyl)) && w.r.equals(new P(gxr, gyr)) )\n\t\t\treturn 1;\n\t\tif( w.l.equals(new P(gxl, gyl)) ^ w.r.equals(new P(gxr, gyr)) )\n\t\t\treturn -1;\n\t\telse return 0;\n\t}\n\t\n\tclass W {\n\t\tP l, r;\n\t\tW(P l, P r) {\n\t\t\tthis.l = l;\n\t\t\tthis.r = r;\n\t\t}\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif(o instanceof W) {\n\t\t\t\tW w = (W) o;\n\t\t\t\treturn l.equals(w.l) && r.equals(w.r);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn r.hashCode() * 2500 + l.hashCode() * 2500;\n\t\t}\n\t}\n\t\n\tclass P {\n\t\tbyte x, y;\n\t\tP(byte x, byte y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif(o instanceof P) {\n\t\t\t\tP p = (P)o;\n\t\t\t\treturn x == p.x && y == p.y;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn (int)x * 50 + y;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tint w,h;\n\tint [] vx = {0,1,0,-1};\n\tint [] vy = {1,0,-1,0};\n\t\n\tclass C{\n\t\tint x1,y1,x2,y2;\n\n\t\tpublic C(int x1, int y1, int x2, int y2) {\n\t\t\tthis.x1 = x1;\n\t\t\tthis.y1 = y1;\n\t\t\tthis.x2 = x2;\n\t\t\tthis.y2 = y2;\n\t\t}\n\t\t\n\t}\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif((w|h) == 0) break;\n\t\t\tchar [][][]data = new char[2][h][w];\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < 2; j++){\n\t\t\t\t\tdata[j][i] = sc.next().toCharArray();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint x1 = 0,x2 = 0,y1 = 0,y2 = 0;\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tif(data[0][i][j] == 'L'){\n\t\t\t\t\t\tdata[0][i][j] = '.';\n\t\t\t\t\t\tx1 = j;\n\t\t\t\t\t\ty1 = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tif(data[1][i][j] == 'R'){\n\t\t\t\t\t\tdata[1][i][j] = '.';\n\t\t\t\t\t\tx2 = j;\n\t\t\t\t\t\ty2 = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tLinkedList<C> open = new LinkedList<C>();\n\t\t\topen.add(new C(x1, y1, x2, y2));\n\t\t\tboolean [][][][] close = new boolean[h][w][h][w];\n\t\t\tclose[y1][x1][y2][x2] = true;\n\t\t\tboolean ans = false;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tC now = open.poll();\n\t\t\t\t\n\t\t\t\tboolean flg = false;\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tint xx = now.x1 + vx[i];\n\t\t\t\t\tint yy = now.y1 + vy[i];\n\t\t\t\t\tint xx2 = now.x2 + vx[i] *  -1;\n\t\t\t\t\tint yy2 = now.y2 + vy[i];\n\t\t\t\t\tif(! isOK(xx,yy) || data[0][yy][xx] == '#'){\n\t\t\t\t\t\tyy = now.y1;\n\t\t\t\t\t\txx = now.x1;\n\t\t\t\t\t}\n\t\t\t\t\tif(! isOK(xx2, yy2) || data[1][yy2][xx2] == '#'){\n\t\t\t\t\t\tyy2 = now.y2;\n\t\t\t\t\t\txx2 = now.x2;\n\t\t\t\t\t}\n\t\t\t\t\tif(data[0][yy][xx] == '%' && data[1][yy2][xx2] == '%'){\n\t\t\t\t\t\tflg = true;\n\t\t\t\t\t\tans = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(data[0][yy][xx] == '%' || data[1][yy2][xx2] == '%'){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(close[yy][xx][yy2][xx2]) continue;\n\t\t\t\t\t\n\t\t\t\t\topen.add(new C(xx, yy, xx2, yy2));\n\t\t\t\t\tclose[yy][xx][yy2][xx2] = true;\n\t\t\t\t}\n\t\t\t\tif(flg){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\n\tprivate boolean isOK(int xx, int yy) {\n\t\tif(0 <= xx && xx < w && 0 <= yy && yy < h) return true;\n\t\treturn false;\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Mirror Cave\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[][] m1 = {{-1,0},{0,1},{1,0},{0,-1}}, m2 = {{-1,0},{0,-1},{1,0},{0,1}};\n\t\tfor(;;){\n\t\t\tint w = sc.nextInt(), h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tsc.nextLine();\n\t\t\tchar[][] a = new char[h][], b = new char[h][];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tString[] s = sc.nextLine().split(\" \");\n\t\t\t\ta[i] = s[0].toCharArray(); b[i] = s[1].toCharArray();\n\t\t\t}\n\t\t\tint Li = 0, Lj = 0, Ri = 0, Rj = 0, GLi = 0, GLj = 0, GRi = 0, GRj = 0;\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tif(a[i][j]=='%'){\n\t\t\t\t\ta[i][j] = '.'; GLi = i; GLj = j;\n\t\t\t\t}\n\t\t\t\tif(a[i][j]=='L'){\n\t\t\t\t\ta[i][j] = '.'; Li = i; Lj = j;\n\t\t\t\t}\n\t\t\t\tif(b[i][j]=='%'){\n\t\t\t\t\tb[i][j] = '.'; GRi = i; GRj = j;\n\t\t\t\t}\n\t\t\t\tif(b[i][j]=='R'){\n\t\t\t\t\tb[i][j] = '.'; Ri = i; Rj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean[][][][] u = new boolean[h][w][h][w];\n\t\t\tu[Li][Lj][Ri][Rj] = true;\n\t\t\tList<int[]> l = new ArrayList<int[]>();\n\t\t\tl.add(new int[]{Li, Lj, Ri, Rj});\n\t\t\tString res = \"No\";\n\t\t\twhile(!l.isEmpty()){\n\t\t\t\tList<int[]> next = new ArrayList<int[]>();\n\t\t\t\tfor(int[] v:l){\n\t\t\t\t\tint li = v[0], lj = v[1], ri = v[2], rj = v[3];\n\t\t\t\t\tif(li==GLi&&lj==GLj||ri==GRi&&rj==GRj){\n\t\t\t\t\t\tif(li==GLi&&lj==GLj&&ri==GRi&&rj==GRj){\n\t\t\t\t\t\t\tres = \"Yes\"; next.clear(); break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint nli = li+m1[k][0], nlj = lj+m1[k][1], nri = ri+m2[k][0], nrj = rj+m2[k][1];\n\t\t\t\t\t\tif(!(0<=nli&&nli<h&&0<=nlj&&nlj<w&&a[nli][nlj]=='.')){\n\t\t\t\t\t\t\tnli = li; nlj = lj;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!(0<=nri&&nri<h&&0<=nrj&&nrj<w&&b[nri][nrj]=='.')){\n\t\t\t\t\t\t\tnri = ri; nrj = rj;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!u[nli][nlj][nri][nrj]){\n\t\t\t\t\t\t\tu[nli][nlj][nri][nrj] = true; next.add(new int[]{nli, nlj, nri, nrj});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tl = next;\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n\n    private static final int[] DX = {0, 1, 0, -1}, DY = {1, 0, -1, 0};\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int w = in.nextInt(), h = in.nextInt();\n        while (w > 0) {\n            boolean[][][][] dist = new boolean[h][w][h][w];\n\n            int lsx = -1, lsy = -1, rsx = -1, rsy = -1;\n            int lgx = -1, lgy = -1, rgx = -1, rgy = -1;\n            String[] lb = new String[h], rb = new String[h];\n            for (int i = 0; i < h; i++) {\n                lb[i] = in.next();\n                rb[i] = new StringBuilder(in.next()).reverse().toString();\n                for (int j = 0; j < w; j++) {\n                    if (lb[i].charAt(j) == 'L') {\n                        lsx = j;\n                        lsy = i;\n                    } else if (lb[i].charAt(j) == '%') {\n                        lgx = j;\n                        lgy = i;\n                    }\n                    if (rb[i].charAt(j) == 'R') {\n                        rsx = j;\n                        rsy = i;\n                    } else if (rb[i].charAt(j) == '%') {\n                        rgx = j;\n                        rgy = i;\n                    }\n                }\n            }\n            if (lsx == -1 || rsx == -1) throw new RuntimeException();\n\n            Queue<Node> q = new ArrayDeque<>();\n            dist[lsy][lsx][rsy][rsx] = true;\n            q.offer(new Node(lsx, lsy, rsx, rsy));\n            while (!q.isEmpty()) {\n                Node node = q.poll();\n                for (int i = 0; i < 4; i++) {\n                    int nlx = node.lx + DX[i], nly = node.ly + DY[i];\n                    int nrx = node.rx + DX[i], nry = node.ry + DY[i];\n                    if (nlx < 0 || nly < 0 || nlx >= w || nly >= h || lb[nly].charAt(nlx) == '#') {\n                        nlx = node.lx;\n                        nly = node.ly;\n                    }\n                    if (nrx < 0 || nry < 0 || nrx >= w || nry >= h || rb[nry].charAt(nrx) == '#') {\n                        nrx = node.rx;\n                        nry = node.ry;\n                    }\n                    if ((nlx == lgx && nly == lgy) != (nrx == rgx && nry == rgy)) continue;\n                    if (dist[nly][nlx][nry][nrx]) continue;\n                    dist[nly][nlx][nry][nrx] = true;\n                    q.offer(new Node(nlx, nly, nrx, nry));\n                }\n            }\n\n            out.println(dist[lgy][lgx][rgy][rgx] ? \"Yes\" : \"No\");\n            w = in.nextInt();\n            h = in.nextInt();\n        }\n\n        out.flush();\n    }\n\n    static class Node {\n        int lx, ly;\n        int rx, ry;\n\n        Node(int lx, int ly, int rx, int ry) {\n            this.lx = lx;\n            this.ly = ly;\n            this.rx = rx;\n            this.ry = ry;\n        }\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tHashSet<Long> hash = new HashSet<Long>();\t\n\tPriorityQueue<State> pq;\n\tboolean res;\n\tchar[][] len, rin;\n\n\tint[] vx = {0, -1, 1, 0};\n\tint[] vy = {-1, 0, 0, 1};\n\t\n\tclass State implements Comparable<State> {\n\t\tint len_x, len_y, rin_x, rin_y;\n\t\t\n\t\tState(int len_x, int len_y, int rin_x, int rin_y) {\n\t\t\tthis.len_x = len_x;\n\t\t\tthis.len_y = len_y;\n\t\t\tthis.rin_x = rin_x;\n\t\t\tthis.rin_y = rin_y;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(State o) {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tpublic String toString() {\n\t\t\treturn len_x + \" \" + len_y + \" \" + rin_x + \" \" + rin_y;\n\t\t}\n\t}\n\t\n\tboolean isOk(int x, int y, int H, int W, char[][] map) {\n\t\treturn x >= 0 && x < W && y >= 0 && y < H && map[y][x] != '#';\n\t}\n\t\n\tvoid bfs(int H, int W) {\n\t\twhile (!pq.isEmpty()) {\n\t\t\tState s = pq.poll();\n\t\t\tfor (int i = 0; i < vx.length; i++) {\n\t\t\t\tint len_nx = s.len_x + vx[i];\n\t\t\t\tint len_ny = s.len_y + vy[i];\n\t\t\t\tint rin_nx = s.rin_x - vx[i];\n\t\t\t\tint rin_ny = s.rin_y + vy[i];\n\t\t\t\tif (!isOk(len_nx, len_ny, H, W, len)) {\n\t\t\t\t\tlen_nx -= vx[i];\n\t\t\t\t\tlen_ny -= vy[i];\n\t\t\t\t}\n\t\t\t\tif (!isOk(rin_nx, rin_ny, H, W, rin)) {\n\t\t\t\t\trin_nx += vx[i];\n\t\t\t\t\trin_ny -= vy[i];\n\t\t\t\t}\n\t\t\t\tlong hashValue = convert(len_nx, len_ny, rin_nx, rin_ny);\n\t\t\t\tif (!hash.contains(hashValue)) {\n\t\t\t\t\tif ((len[len_ny][len_nx] != '%' && rin[rin_ny][rin_nx] == '%') ||\n\t\t\t\t\t\t(len[len_ny][len_nx] == '%' && rin[rin_ny][rin_nx] != '%')) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tpq.add(new State(len_nx, len_ny, rin_nx, rin_ny));\n\t\t\t\t\thash.add(hashValue);\n\t\t\t\t\tif (len[len_ny][len_nx] == '%' && rin[rin_ny][rin_nx] == '%') res = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlong convert(int len_x, int len_y, int rin_x, int rin_y) {\n\t\treturn len_x * 50*50*50 + len_y * 50*50 + rin_x * 50 + rin_y;\n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint W = in.nextInt(), H = in.nextInt();\n\t\t\tif (W == 0) break;\n\t\t\thash.clear();\n\t\t\tres = false;\n\t\t\t\n\t\t\tlen = new char[H][W];\n\t\t\trin = new char[H][W];\n\t\t\t\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tlen[i] = in.next().toCharArray();\n\t\t\t\trin[i] = in.next().toCharArray();\n\t\t\t}\n\t\t\t\n\t\t\tint len_sx = 0, len_sy = 0, rin_sx = 0, rin_sy = 0;\n\t\t\t\n\t\t\tfor (int i = 0; i < H; i++) for (int j = 0; j < W; j++) {\n\t\t\t\tif (len[i][j] == 'L') {\n\t\t\t\t\tlen_sx = j;\n\t\t\t\t\tlen_sy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < H; i++) for (int j = 0; j < W; j++) {\n\t\t\t\tif (rin[i][j] == 'R') {\n\t\t\t\t\trin_sx = j;\n\t\t\t\t\trin_sy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tpq = new PriorityQueue<State>();\n\t\t\tpq.add(new State(len_sx, len_sy, rin_sx, rin_sy));\n\t\t\thash.add(convert(len_sx, len_sy, rin_sx, rin_sy));\n\t\t\t\n\t\t\tbfs(H, W);\t\n\t\t\t\n\t\t\tSystem.out.println(res ? \"Yes\" : \"No\");\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(char[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%c \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.BitSet;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DY = { 1, 0, -1, 0 };\n\tstatic int[] DX = { 0, -1, 0, 1 };\n\tstatic int W, H;\n\tstatic char[][] mapL = new char[52][52];\n\tstatic char[][] mapR = new char[52][52];\n\tstatic BitSet visited = new BitSet(1 << 24);\n\tstatic int[] q = new int[50 * 50 * 50 * 50];\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tW = sc.nextInt();\n\t\t\tH = sc.nextInt();\n\t\t\tif (W == 0) break;\n\t\t\tsc.nextLine();\n\t\t\tfor (int i = 1; i <= H; ++i) {\n\t\t\t\tString line = sc.nextLine();\n\t\t\t\tmapL[i][0] = '#';\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tmapL[i][j + 1] = line.charAt(j);\n\t\t\t\t}\n\t\t\t\tmapL[i][W + 1] = '#';\n\t\t\t\tmapR[i][0] = '#';\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tmapR[i][j + 1] = line.charAt(W + 1 + j);\n\t\t\t\t}\n\t\t\t\tmapR[i][W + 1] = '#';\n\t\t\t}\n\t\t\tfor (int i = 1; i <= W; ++i) {\n\t\t\t\tmapL[0][i] = mapL[H + 1][i] = mapR[0][i] = mapR[H + 1][i] = '#';\n\t\t\t}\n\t\t\tSystem.out.println(solve() ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\n\tstatic boolean solve() {\n\t\tboolean[] visited = new boolean[H * W * H * W];\n\t\tint pos = 0;\n\t\tfor (int i = 1; i <= H; ++i) {\n\t\t\tfor (int j = 1; j <= W; ++j) {\n\t\t\t\tif (mapL[i][j] == 'L') {\n\t\t\t\t\tpos |= (i << 18) | (j << 12);\n\t\t\t\t}\n\t\t\t\tif (mapR[i][j] == 'R') {\n\t\t\t\t\tpos |= (i << 6) | j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvisited[posToIdx(pos)] = true;\n\t\tint qs = 0;\n\t\tint qe = 1;\n\t\tq[0] = pos;\n\t\twhile (qs != qe) {\n\t\t\tint p = q[qs++];\n\t\t\tint y1 = p >> 18;\n\t\t\tint x1 = (p >> 12) & 0x3F;\n\t\t\tint y2 = (p >> 6) & 0x3F;\n\t\t\tint x2 = p & 0x3F;\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tint ny1 = y1 + DY[i];\n\t\t\t\tint nx1 = x1 + DX[i];\n\t\t\t\tint ny2 = y2 + DY[i];\n\t\t\t\tint nx2 = x2 - DX[i];\n\t\t\t\tif (mapL[ny1][nx1] == '#') {\n\t\t\t\t\tny1 = y1;\n\t\t\t\t\tnx1 = x1;\n\t\t\t\t}\n\t\t\t\tif (mapR[ny2][nx2] == '#') {\n\t\t\t\t\tny2 = y2;\n\t\t\t\t\tnx2 = x2;\n\t\t\t\t}\n\t\t\t\tboolean goalL = mapL[ny1][nx1] == '%';\n\t\t\t\tboolean goalR = mapR[ny2][nx2] == '%';\n\t\t\t\tif (goalL && goalR) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (!goalL && !goalR) {\n\t\t\t\t\tint np = (ny1 << 18) | (nx1 << 12) | (ny2 << 6) | nx2;\n\t\t\t\t\tint ni = posToIdx(np);\n\t\t\t\t\tif (!visited[ni]) {\n\t\t\t\t\t\tvisited[ni] = true;\n\t\t\t\t\t\tq[qe++] = np;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic int posToIdx(int p) {\n\t\tint y1 = p >> 18;\n\t\tint x1 = (p >> 12) & 0x3F;\n\t\tint y2 = (p >> 6) & 0x3F;\n\t\tint x2 = p & 0x3F;\n\t\treturn ((y1 - 1) * W + (x1 - 1)) * H * W + ((y2 - 1) * W + (x2 - 1));\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static final void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tint w;\n\tint h;\n\tchar[][] map = new char[2][100*100];\n\tint sl;\n\tint sr;\n\tpublic Main() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif(w==0 && h==0)\n\t\t\t\tbreak;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tString s0 = sc.next();\n\t\t\t\tString s1 = sc.next();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tmap[0][i*w+j] = s0.charAt(j);\n\t\t\t\t\tmap[1][i*w+j] = s1.charAt(w-j-1);\n\t\t\t\t\tif(map[0][i*w+j]=='L')\n\t\t\t\t\t\tsl = i*w+j;\n\t\t\t\t\tif(map[1][i*w+j]=='R')\n\t\t\t\t\t\tsr = i*w+j;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\nSystem.gc();\n\t\t}\n\t}\n\n\tint[] dx = new int[]{-1, 0, 1, 0};\n\tint[] dy = new int[]{0, -1, 0, 1};\n\tprivate void solve() {\n\t\tLinkedList<int[]> queue = new LinkedList<int[]>();\n\t\t\n\t\tint[][] visited = new int[w*h][w*h];\n\t\tqueue.add(new int[]{sl, sr});\n\n\t\twhile(!queue.isEmpty()){\n\t\t\tint[] cp = queue.poll();\n\t\t\tint clp = cp[0];\n\t\t\tint crp = cp[1];\n\t\t\t\n\t\t\tif(visited[clp][crp]==1)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tvisited[clp][crp] = 1;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nlp = clp + dx[i] + dy[i]*w;\n\t\t\t\tint nrp = crp + dx[i] + dy[i]*w;\n\t\t\t\tif(nlp<0 || w*h<=nlp || nrp<0 || w*h<=nrp)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(map[0][nlp]=='#')\n\t\t\t\t\tnlp = clp;\n\t\t\t\tif(map[1][nrp]=='#')\n\t\t\t\t\tnrp = crp;\n\t\t\t\t\n\t\t\t\tif(map[0][nlp]=='%' && map[1][nrp]=='%'){\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\tqueue.clear();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tqueue.add(new int[]{nlp, nrp});\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"No\");\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(in);\n\t\n\tclass Pos {\n\t\tint lx, ly, rx, ry;\n\t\tPos(int _lx, int _ly, int _rx, int _ry) {\n\t\t\tlx = _lx;\n\t\t\tly = _ly;\n\t\t\trx = _rx;\n\t\t\try = _ry;\n\t\t}\n\t}\n\t\n\tvoid run() {\n\t\tboolean[][] rooml = new boolean[50][50];\n\t\tboolean[][] roomr = new boolean[50][50];\n\t\tboolean[][][][] used = new boolean[50][50][50][50]; \n\t\tint dlx, dly, drx, dry, lx, ly, rx, ry;\n\t\tdlx = dly = drx = dry = lx = ly = rx = ry = 0;\n\t\tQueue<Pos> que = new LinkedList<Pos>();\n\t\tint[] dilx = {1, -1, 0, 0};\n\t\tint[] dily = {0, 0, 1, -1};\n\t\tint[] dirx = {1, -1, 0, 0};\n\t\tint[] diry = {0, 0, -1, 1};\n\t\twhile (true) {\n\t\t\tint w = sc.nextByte(), h = sc.nextByte();\n\t\t\tif (w == 0 && h == 0) break;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString l = sc.next(), r = sc.next();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tswitch (l.charAt(j)) {\n\t\t\t\t\tcase '.': rooml[i][j] = true; break;\n\t\t\t\t\tcase '#': rooml[i][j] = false; break;\n\t\t\t\t\tcase '%': \n\t\t\t\t\t\trooml[i][j] = true;\n\t\t\t\t\t\tdlx = i; dly = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\trooml[i][j] = true;\n\t\t\t\t\t\tlx = i;\n\t\t\t\t\t\tly = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tswitch (r.charAt(j)) {\n\t\t\t\t\tcase '.': roomr[i][j] = true; break;\n\t\t\t\t\tcase '#': roomr[i][j] = false; break;\n\t\t\t\t\tcase '%': \n\t\t\t\t\t\troomr[i][j] = true;\n\t\t\t\t\t\tdrx = i; dry = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'R':\n\t\t\t\t\t\troomr[i][j] = true;\n\t\t\t\t\t\trx = i;\n\t\t\t\t\t\try = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tque.clear();\n\t\t\tfor (int i = 0; i < 50; i++)\n\t\t\t\tfor (int j = 0; j < 50; j++)\n\t\t\t\t\tfor (int k = 0; k < 50; k++)\n\t\t\t\t\t\tArrays.fill(used[i][j][k], false);\n\t\t\tque.add(new Pos(lx, ly, rx, ry));\n\t\t\tused[lx][ly][rx][ry] = true;\n\t\t\tboolean flag = false;\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tPos p = que.poll();\n\t\t\t\tint telx = p.lx, tely = p.ly;\n\t\t\t\tint terx = p.rx, tery = p.ry;\n\t\t\t\tif (telx == dlx && tely == dly && terx == drx && tery == dry) {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (telx == dlx && tely == dly && !(terx == drx && tery == dry)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!(telx == dlx && tely == dly) && terx == drx && tery == dry) continue;\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint lX = telx + dilx[i], lY = tely + dily[i];\n\t\t\t\t\tint rX = terx + dirx[i], rY = tery + diry[i];\n\t\t\t\t\tif (!(0 <= lX && lX < h && 0 <= lY && lY < w && rooml[lX][lY])) {\n\t\t\t\t\t\tlX = telx;\n\t\t\t\t\t\tlY = tely;\n\t\t\t\t\t}\n\t\t\t\t\tif (!(0 <= rX && rX < h && 0 <= rY && rY < w && roomr[rX][rY])) {\n\t\t\t\t\t\trX = terx;\n\t\t\t\t\t\trY = tery;\n\t\t\t\t\t}\n\t\t\t\t\tif (!used[lX][lY][rX][rY]) {\n\t\t\t\t\t\tused[lX][lY][rX][rY] = true;\n\t\t\t\t\t\tque.add(new Pos(lX, lY, rX, rY));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (flag)\n\t\t\t\tout.println(\"Yes\");\n\t\t\telse\n\t\t\t\tout.println(\"No\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[][] field1,field2;\n\tstatic boolean[][][][] dp;\n\tstatic int sXL,sXR,sYL,sYR;\n\tstatic boolean ans;\n\tstatic int[] v1={0,1,0,-1};\n\tstatic int[] v2={1,0,-1,0};\n\tstatic int w,h;\n\tpublic static void main(String[] args) {\n\t\tScanner cin=new Scanner(System.in);\n\t\twhile(true){\n\n\t\t\tw=cin.nextInt();\n\t\t\th=cin.nextInt();\n\t\t\tif(w+h==0){\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\tans=false;\n\t\t\tfield1=new int[h][w];\n\t\t\tfield2=new int[h][w];\n\t\t\tdp=new boolean[h][w][h][w];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<2;j++){\n\t\t\t\t\tString s=cin.next();\n\t\t\t\t\tint[][] a;\n\t\t\t\t\tif(j==0){\n\t\t\t\t\t\ta=field1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\ta=field2;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<s.length();k++){\n\t\t\t\t\t\tint b=0;\n\t\t\t\t\t\tif(s.charAt(k)=='%'){\n\t\t\t\t\t\t\tb=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(s.charAt(k)=='#'){\n\t\t\t\t\t\t\tb=-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(s.charAt(k)=='L'){\n\t\t\t\t\t\t\tsXL=i;\n\t\t\t\t\t\t\tsYL=k;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(s.charAt(k)=='R'){\n\t\t\t\t\t\t\tsXR=i;\n\t\t\t\t\t\t\tsYR=k;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ta[i][k]=b;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbt(sXL,sYL,sXR,sYR);\n\t\t\tif(ans){\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t}\n\tstatic void bt(int a,int b,int c,int d){\n//\t\tSystem.out.println(a+\" \"+b+\" \"+c+\" \"+d);\n\t\tif(dp[a][b][c][d]||ans){\n\t\t\treturn ;\n\t\t}\n\t\tdp[a][b][c][d]=true;\n\t\tif(field1[a][b]==1&&field2[c][d]==1){\n\t\t\tans=true;\n\t\t}\n\t\tif(field1[a][b]==1){\n\t\t\treturn;\n\t\t}\n\t\tif(field2[c][d]==1){\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint aa=a+v1[i];\n\t\t\tint bb=b+v2[i];\n\t\t\tint cc=c+v1[i];\n\t\t\tint dd=d+-v2[i];\n//\t\t\tSystem.out.println(aa+\" \"+bb+\" \"+cc+\" \"+dd+\" \"+i);\n\t\t\tif(aa<0||aa>=h){\n\t\t\t\taa-=v1[i];\n\t\t\t}\n\t\t\tif(bb<0||bb>=w){\n\t\t\t\tbb-=v2[i];\n\t\t\t}\n\t\t\tif(cc<0||cc>=h){\n\t\t\t\tcc-=v1[i];\n\t\t\t}\n\t\t\tif(dd<0||dd>=w){\n\t\t\t\tdd-=-v2[i];\n\t\t\t}\n//\t\t\tSystem.out.println(aa+\" \"+bb+\" \"+cc+\" \"+dd+\" \"+i);\n\t\t\tif(field1[aa][bb]==-1){\n\t\t\t\taa-=v1[i];\n\t\t\t\tbb-=v2[i];\n\t\t\t}\n\t\t\tif(field2[cc][dd]==-1){\n\t\t\t\tcc-=v1[i];\n\t\t\t\tdd-=-v2[i];\n\t\t\t}\n\t\t\tbt(aa,bb,cc,dd);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.BitSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\npublic class Main{\n\tpublic static final int[] dx = {1, 0, -1, 0};\n\tpublic static final int[] dy = {0, 1, 0, -1};\n\tpublic static int w, h;\n\tpublic static char[][][] map;\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = in.nextInt();\n\t\t\th = in.nextInt();\n\t\t\tif(w == 0) break;\n\t\t\tmap = new char[2][h][w];\n\t\t\tint g = 0;\n\t\t\tint s = 0;\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\tfor(int j=0; j<2; j++){\n\t\t\t\t\tchar[] line = in.next().toCharArray();\n\t\t\t\t\tif(j==0) map[j][i] = line;\n\t\t\t\t\telse{\n\t\t\t\t\t\tfor(int k=0; k<w; k++){\n\t\t\t\t\t\t\tmap[j][i][k] = line[w-1-k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0; k<w; k++){\n\t\t\t\t\t\tswitch(map[j][i][k]){\n\t\t\t\t\t\tcase 'R':\n\t\t\t\t\t\t\ts += i*w+k;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'L':\n\t\t\t\t\t\t\ts += (i*w+k)*h*w;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '%':\n\t\t\t\t\t\t\tg += id(j, i, k);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tBitSet used = new BitSet(w*w*h*h);\n\t\t\tQueue<Integer> qu = new LinkedList<Integer>();\n\t\t\tqu.add(s);\n\t\t\tused.set(s);\n\t\t\tint hw = h*w;\n\t\t\tint whw = w*h*w;\n\t\t\tboolean flag = false;\n\t\t\twhile(!qu.isEmpty()){\n\t\t\t\tint id = qu.poll();\n\t\t\t\tif(id == g){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint y0 = id/whw;\n\t\t\t\tid %= whw;\n\t\t\t\tint x0 = id/hw;\n\t\t\t\tid %= hw;\n\t\t\t\tint y1 = id/w;\n\t\t\t\tint x1 = id%w;\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tint nid = next(x0, y0, x1, y1, i);\n\t\t\t\t\tif(used.get(nid)) continue;\n\t\t\t\t\tused.set(nid);\n\t\t\t\t\tqu.add(nid);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(flag ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\t\n\tpublic static int next(int x0, int y0, int x1, int y1, int dir){\n\t\tint nx0 = x0 + dx[dir];\n\t\tint ny0 = y0 + dy[dir];\n\t\tif(nx0 < 0 || nx0 >= w || ny0 < 0 || ny0 >= h\n\t\t\t\t|| map[0][ny0][nx0] == '#'){\n\t\t\tnx0 = x0;\n\t\t\tny0 = y0;\n\t\t}\n\t\tint nx1 = x1 + dx[dir];\n\t\tint ny1 = y1 + dy[dir];\n\t\tif(nx1 < 0 || nx1 >= w || ny1 < 0 || ny1 >= h\n\t\t\t\t|| map[1][ny1][nx1] == '#'){\n\t\t\tnx1 = x1;\n\t\t\tny1 = y1;\n\t\t}\n\t\treturn id(0, ny0, nx0) + id(1, ny1, nx1);\n\t}\n\t\n\tpublic static int id(int room, int y, int x){\n\t\treturn room==0 ? (y*w+x)*w*h : y*w+x;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static int[][] move_dir = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\t\n\tpublic static final int MAX = 50;\n\t\n\tpublic static boolean is_ok(int x, int y, int h, int w){\n\t\tif(x < 0 || x >= w || y < 0 || y >= h){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tboolean[][][][] is_visited = new boolean[MAX][MAX][MAX][MAX];\n\t\tboolean[][][] can_enter = new boolean[2][MAX][MAX];\n\t\tint[][] start_pos = new int[2][2];\n\t\tint[][] goal_pos  = new int[2][2];\n\t\t\n\t\twhile(true){\n\t\t\tfinal int W = sc.nextInt();\n\t\t\tfinal int H = sc.nextInt();\n\t\t\t\n\t\t\tif(W == 0 && H == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.gc();\n\t\t\t\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tfor(int type = 0; type < 2; type++){\n\t\t\t\t\tchar[] input = sc.next().toCharArray();\n\t\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\t\tif(input[j] == '#'){\n\t\t\t\t\t\t\tcan_enter[type][i][j] = false;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcan_enter[type][i][j] = true;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(input[j] == '%'){\n\t\t\t\t\t\t\t\tgoal_pos[type][0] = j;\n\t\t\t\t\t\t\t\tgoal_pos[type][1] = i;\n\t\t\t\t\t\t\t}else if(input[j] == 'L' || input[j] == 'R'){\n\t\t\t\t\t\t\t\tstart_pos[type][0] = j;\n\t\t\t\t\t\t\t\tstart_pos[type][1] = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tfor(int k = 0; k < H; k++){\n\t\t\t\t\t\tfor(int l = 0; l < W; l++){\n\t\t\t\t\t\t\tis_visited[i][j][k][l] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tLinkedList<Integer> len_x_queue = new LinkedList<Integer>();\n\t\t\tLinkedList<Integer> len_y_queue = new LinkedList<Integer>();\n\t\t\tLinkedList<Integer> rin_x_queue = new LinkedList<Integer>();\n\t\t\tLinkedList<Integer> rin_y_queue = new LinkedList<Integer>();\n\t\t\t//LinkedList<Integer> time_queue  = new LinkedList<Integer>();\n\t\t\tlen_x_queue.add(start_pos[0][0]);\n\t\t\tlen_y_queue.add(start_pos[0][1]);\n\t\t\trin_x_queue.add(start_pos[1][0]);\n\t\t\trin_y_queue.add(start_pos[1][1]);\n\t\t\t//time_queue.add(0);\n\t\t\tis_visited[start_pos[0][1]][start_pos[0][0]][start_pos[1][1]][start_pos[1][0]] = true;\n\t\t\t\n\t\t\tboolean found = false;\n\t\t\twhile(!len_x_queue.isEmpty()){\n\t\t\t\tfinal int len_x = len_x_queue.poll();\n\t\t\t\tfinal int len_y = len_y_queue.poll();\n\t\t\t\tfinal int rin_x = rin_x_queue.poll();\n\t\t\t\tfinal int rin_y = rin_y_queue.poll();\n\t\t\t\t//final int time  = time_queue.poll();\n\t\t\t\t\n\t\t\t\t//System.out.println(len_x + \" \" + len_y + \" \" + rin_x + \" \" + rin_y);\n\t\t\t\t\n\t\t\t\tif(goal_pos[0][0] == len_x && goal_pos[0][1] == len_y\n\t\t\t\t\t\t&& goal_pos[1][0] == rin_x && goal_pos[1][1] == rin_y){\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(goal_pos[0][0] == len_x && goal_pos[0][1] == len_y){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(goal_pos[1][0] == rin_x && goal_pos[1][1] == rin_y){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int[] move : move_dir){\n\t\t\t\t\tint n_len_x = len_x + move[0];\n\t\t\t\t\tint n_len_y = len_y + move[1];\n\t\t\t\t\tint n_rin_x = rin_x - move[0];\n\t\t\t\t\tint n_rin_y = rin_y + move[1];\n\t\t\t\t\t\n\t\t\t\t\tif(!is_ok(n_len_x, n_len_y, H, W) || !can_enter[0][n_len_y][n_len_x]){\n\t\t\t\t\t\tn_len_x = len_x;\n\t\t\t\t\t\tn_len_y = len_y;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(!is_ok(n_rin_x, n_rin_y, H, W) || !can_enter[1][n_rin_y][n_rin_x]){\n\t\t\t\t\t\tn_rin_x = rin_x;\n\t\t\t\t\t\tn_rin_y = rin_y;\n\t\t\t\t\t}\n\t\t\t\t\t//System.out.println(n_len_x + \" \" + n_len_y + \" \" + n_rin_x + \" \" + n_rin_y);\n\t\t\t\t\tif(is_visited[n_len_y][n_len_x][n_rin_y][n_rin_x]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//\n\t\t\t\t\t//System.out.println(is_visited[n_len_y][n_len_x][n_rin_y][n_rin_x]);\n\t\t\t\t\t\n\t\t\t\t\tis_visited[n_len_y][n_len_x][n_rin_y][n_rin_x] = true;\n\t\t\t\t\tlen_x_queue.add(n_len_x);\n\t\t\t\t\tlen_y_queue.add(n_len_y);\n\t\t\t\t\trin_x_queue.add(n_rin_x);\n\t\t\t\t\trin_y_queue.add(n_rin_y);\n\t\t\t\t\t//time_queue.add(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(!found){\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic int W,H;\n\t\t\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\t\twhile(true){\n\t\t\tW = in.nextInt();\n\t\t\tH = in.nextInt();\n\t\t\tif(W==0&&H==0) break;\n\t\t\tString[] left = new String[H];\n\t\t\tString[] right = new String[H];\n\t\t\tint goal = 0;\n\t\t\tint start = 0;\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tleft[i] = in.next();\n\t\t\t\tright[i] = in.next();\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tif(left[i].charAt(j)=='%'){\n\t\t\t\t\t\tgoal += (100*j + i)*10000;\n\t\t\t\t\t}else if(left[i].charAt(j)=='L'){\n\t\t\t\t\t\tstart += (100*j + i)*10000;\n\t\t\t\t\t}\n\t\t\t\t\tif(right[i].charAt(j)=='%'){\n\t\t\t\t\t\tgoal += 100*j + i;\n\t\t\t\t\t}else if(right[i].charAt(j)=='R'){\n\t\t\t\t\t\tstart += 100*j + i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean[] pos = new boolean[100000000];\n\t\t\tLinkedList<Integer> stack = new LinkedList<>();\n\t\t\tstack.push(start);\n\t\t\tpos[start] = true;\n\t\t\tString ans = \"No\";\n\t\t\twhile(!stack.isEmpty()){\n\t\t\t\tint now = stack.pop();\n\t\t\t\t//UP\n\t\t\t\tint up = now;\n\t\t\t\tif(!isWall(getLx(now),getLy(now)-1,left)){\n\t\t\t\t\tup -= 10000;\n\t\t\t\t}\n\t\t\t\tif(!isWall(getRx(now),getRy(now)-1,right)){\n\t\t\t\t\tup -= 1;\n\t\t\t\t}\n\t\t\t\tif(up==goal){\n\t\t\t\t\tans = \"Yes\"; break;\n\t\t\t\t}\n\t\t\t\tif(!isGoal(getLx(up),getLy(up),left) &&\n\t\t\t\t\t\t!isGoal(getRx(up),getRy(up),right) &&\n\t\t\t\t\t\t!pos[up]){\n\t\t\t\t\tstack.add(up); pos[up] = true;\n\t\t\t\t}\n\t\t\t\t//DOWN\n\t\t\t\tint down = now;\n\t\t\t\tif(!isWall(getLx(now),getLy(now)+1,left)){\n\t\t\t\t\tdown += 10000;\n\t\t\t\t}\n\t\t\t\tif(!isWall(getRx(now),getRy(now)+1,right)){\n\t\t\t\t\tdown += 1;\n\t\t\t\t}\n\t\t\t\tif(down==goal){\n\t\t\t\t\tans = \"Yes\"; break;\n\t\t\t\t}\n\t\t\t\tif(!isGoal(getLx(down),getLy(down),left) &&\n\t\t\t\t\t\t!isGoal(getRx(down),getRy(down),right) &&\n\t\t\t\t\t\t!pos[down]){\n\t\t\t\t\tstack.add(down); pos[down] = true;\n\t\t\t\t}\n\t\t\t\t//into\n\t\t\t\tint into = now;\n\t\t\t\tif(!isWall(getLx(now)+1,getLy(now),left)){\n\t\t\t\t\tinto += 1000000;\n\t\t\t\t}\n\t\t\t\tif(!isWall(getRx(now)-1,getRy(now),right)){\n\t\t\t\t\tinto -= 100;\n\t\t\t\t}\n\t\t\t\tif(into==goal){\n\t\t\t\t\tans = \"Yes\"; break;\n\t\t\t\t}\n\t\t\t\tif(!isGoal(getLx(into),getLy(into),left) &&\n\t\t\t\t\t\t!isGoal(getRx(into),getRy(into),right) &&\n\t\t\t\t\t\t!pos[into]){\n\t\t\t\t\tstack.add(into); pos[into] = true;\n\t\t\t\t}\n\t\t\t\t//out\n\t\t\t\tint out = now;\n\t\t\t\tif(!isWall(getLx(now)-1,getLy(now),left)){\n\t\t\t\t\tout -= 1000000;\n\t\t\t\t}\n\t\t\t\tif(!isWall(getRx(now)+1,getRy(now),right)){\n\t\t\t\t\tout += 100;\n\t\t\t\t}\n\t\t\t\tif(out==goal){\n\t\t\t\t\tans = \"Yes\"; break;\n\t\t\t\t}\n\t\t\t\tif(!isGoal(getLx(out),getLy(out),left) &&\n\t\t\t\t\t\t!isGoal(getRx(out),getRy(out),right) &&\n\t\t\t\t\t\t!pos[out]){\n\t\t\t\t\tstack.add(out); pos[out] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\tSystem.gc();\n\t\t}\t\n\t}\n\t\n\tpublic static int getLx(int pos){\n\t\treturn pos/1000000;\n\t}\n\tpublic static int getLy(int pos){\n\t\treturn pos/10000 %100;\n\t}\n\tpublic static int getRx(int pos){\n\t\treturn pos/100 % 100;\n\t}\n\tpublic static int getRy(int pos){\n\t\treturn pos%100;\n\t}\n\tpublic static boolean isWall(int x,int y,String[] map){\n\t\treturn x<0 || x>=W || y<0 || y>=H || map[y].charAt(x) == '#';\n\t}\n\tpublic static boolean isGoal(int x,int y,String[] map){\n\t\treturn !(x<0 || x>=W || y<0 || y>=H) && map[y].charAt(x) == '%';\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.BitSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static int w, h;\n\tpublic static char[][][] map;\n\tpublic static final int[] dx = {1, 0, -1, 0};\n\tpublic static final int[] dy = {0, 1, 0, -1};\n\tpublic static int[] gx = new int[2];\n\tpublic static int[] gy = new int[2];\n\tpublic static int[] sx = new int[2];\n\tpublic static int[] sy = new int[2];\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = in.nextInt();\n\t\t\th = in.nextInt();\n\t\t\tif(w == 0) break;\n\t\t\tmap = new char[2][h][w];\n\t\t\tfor(int j=0; j<h; j++){\n\t\t\t\tfor(int i=0; i<2; i++){\n\t\t\t\t\tmap[i][j] = in.next().toCharArray();\n\t\t\t\t\tfor(int k=0; k<w; k++){\n\t\t\t\t\t\tif(map[i][j][k] == '%'){\n\t\t\t\t\t\t\tgx[i] = k;\n\t\t\t\t\t\t\tgy[i] = j;\n\t\t\t\t\t\t}else if(map[i][j][k] == 'L' || map[i][j][k] == 'R'){\n\t\t\t\t\t\t\tsx[i] = k;\n\t\t\t\t\t\t\tsy[i] = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tBitSet used = new BitSet(h*h*w*w);\n\t\t\tQueue<Pos> qu = new LinkedList<Pos>();\n\t\t\tqu.add(new Pos(sy[0], sx[0], sy[1], sx[1]));\n\t\t\tused.set(qu.peek().id);\n\t\t\tboolean goal = false;\n\t\t\twhile(!qu.isEmpty()){\n\t\t\t\tPos p = qu.poll();\n\t\t\t\tif(goal(p)){\n\t\t\t\t\tgoal = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(oneGoal(p)) continue;\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tPos np = move(p, i);\n\t\t\t\t\tif(used.get(np.id)) continue;\n\t\t\t\t\tused.set(np.id);\n\t\t\t\t\tqu.add(np);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(goal?\"Yes\":\"No\");\n\t\t}\n\t}\n\t\n\tpublic static Pos move(Pos p, int dir){\n\t\tint nx1 = p.x1+dx[dir];\n\t\tint ny1 = p.y1+dy[dir];\n\t\tif(out(ny1, nx1) || map[0][ny1][nx1] == '#'){\n\t\t\tnx1 = p.x1;\n\t\t\tny1 = p.y1;\n\t\t}\n\t\tint nx2 = p.x2-dx[dir];\n\t\tint ny2 = p.y2+dy[dir];\n\t\tif(out(ny2, nx2) || map[1][ny2][nx2] == '#'){\n\t\t\tnx2 = p.x2;\n\t\t\tny2 = p.y2;\n\t\t}\n\t\treturn new Pos(nx1, ny1, nx2, ny2);\n\t}\n\t\n\tpublic static boolean out(int y, int x){\n\t\treturn x < 0 || x >= w || y < 0 || y >= h;\n\t}\n\t\n\tpublic static boolean goal(Pos p){\n\t\treturn p.x1 == gx[0] && p.y1 == gy[0] && p.x2 == gx[1] && p.y2 == gy[1];\n\t}\n\t\n\tpublic static boolean oneGoal(Pos p){\n\t\treturn p.x1 == gx[0] && p.y1 == gy[0] || p.x2 == gx[1] && p.y2 == gy[1];\n\t}\n\t\n\tpublic static int id(int y1, int x1, int y2, int x2){\n\t\treturn y1*h*w*w + x1*h*w + y2*w + x2;\n\t}\n}\n\nclass Pos{\n\tint x1, y1, x2, y2;\n\tint id;\n\tpublic Pos(int y1, int x1, int y2, int x2){\n\t\tthis.x1 = x1;\n\t\tthis.y1 = y1;\n\t\tthis.x2 = x2;\n\t\tthis.y2 = y2;\n\t\tid = Main.id(y1, x1, y2, x2);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.BitSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\npublic class Main{\n\tpublic static final int[] dx = {1, 0, -1, 0};\n\tpublic static final int[] dy = {0, 1, 0, -1};\n\tpublic static int w, h;\n\tpublic static char[][][] map;\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = in.nextInt();\n\t\t\th = in.nextInt();\n\t\t\tif(w == 0) break;\n\t\t\tmap = new char[2][h][w];\n\t\t\tint g = 0;\n\t\t\tint s = 0;\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\tfor(int j=0; j<2; j++){\n\t\t\t\t\tchar[] line = in.next().toCharArray();\n\t\t\t\t\tif(j==0) map[j][i] = line;\n\t\t\t\t\telse{\n\t\t\t\t\t\tfor(int k=0; k<w; k++){\n\t\t\t\t\t\t\tmap[j][i][k] = line[w-1-k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0; k<w; k++){\n\t\t\t\t\t\tswitch(map[j][i][k]){\n\t\t\t\t\t\tcase 'R':\n\t\t\t\t\t\t\ts += i*w+k;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'L':\n\t\t\t\t\t\t\ts += (i*w+k)*h*w;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '%':\n\t\t\t\t\t\t\tg += id(j, i, k);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tBitSet used = new BitSet(w*w*h*h);\n\t\t\tQueue<Integer> qu = new LinkedList<Integer>();\n\t\t\tqu.add(s);\n\t\t\tused.set(s);\n\t\t\tint hw = h*w;\n\t\t\tint whw = w*h*w;\n\t\t\tboolean flag = false;\n\t\t\twhile(!qu.isEmpty()){\n\t\t\t\tint id = qu.poll();\n\t\t\t\tif(id == g){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint y0 = id/whw;\n\t\t\t\tid %= whw;\n\t\t\t\tint x0 = id/hw;\n\t\t\t\tid %= hw;\n\t\t\t\tint y1 = id/w;\n\t\t\t\tint x1 = id%w;\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tint nid = next(x0, y0, x1, y1, i);\n\t\t\t\t\tif(used.get(nid)) continue;\n\t\t\t\t\tused.set(nid);\n\t\t\t\t\tqu.add(nid);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(flag ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\t\n\tpublic static String dump(char[][] map){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tsb.append(map[i][j]+\" \");\n\t\t\t}\n\t\t\tsb.append('\\n');\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tpublic static int next(int x0, int y0, int x1, int y1, int dir){\n\t\tint nx0 = x0 + dx[dir];\n\t\tint ny0 = y0 + dy[dir];\n\t\tif(nx0 < 0 || nx0 >= w || ny0 < 0 || ny0 >= h\n\t\t\t\t|| map[0][ny0][nx0] == '#'){\n\t\t\tnx0 = x0;\n\t\t\tny0 = y0;\n\t\t}\n\t\tint nx1 = x1 + dx[dir];\n\t\tint ny1 = y1 + dy[dir];\n\t\tif(nx1 < 0 || nx1 >= w || ny1 < 0 || ny1 >= h\n\t\t\t\t|| map[1][ny1][nx1] == '#'){\n\t\t\tnx1 = x1;\n\t\t\tny1 = y1;\n\t\t}\n\t\treturn id(0, ny0, nx0) + id(1, ny1, nx1);\n\t}\n\t\n\tpublic static int id(int room, int y, int x){\n\t\treturn room==0 ? (y*w+x)*w*h : y*w+x;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint w, h;\n\tboolean[][] mapl, mapr;\n\tbyte sxl, syl, sxr, syr;\n\tbyte gxl, gyl, gxr, gyr;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif( (w|h) == 0 ) break;\n\t\t\t\n\t\t\tmapl = new boolean[h+2][w+2];\n\t\t\tmapr = new boolean[h+2][w+2];\n\t\t\t\n\t\t\tfor(int i=1;i<=h;i++) {\n\t\t\t\tString l = sc.next();\n\t\t\t\tString r = sc.next();\n//\t\t\t\tdebug(l, r);\n\t\t\t\tfor(int j=1;j<=w;j++) {\n\t\t\t\t\tswitch (l.charAt(j-1)) {\n\t\t\t\t\tcase '%':\n\t\t\t\t\t\tgxl = (byte)j;\n\t\t\t\t\t\tgyl = (byte)i;\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\tsxl = (byte)j;\n\t\t\t\t\t\tsyl = (byte)i;\n\t\t\t\t\tcase '.':\n\t\t\t\t\t\tmapl[i][j] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault :mapl[i][j] = false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tswitch (r.charAt(j-1)) {\n\t\t\t\t\tcase '%':\n\t\t\t\t\t\tgxr = (byte)j;\n\t\t\t\t\t\tgyr = (byte)i;\n\t\t\t\t\tcase 'R':\n\t\t\t\t\t\tsxr = (byte)j;\n\t\t\t\t\t\tsyr = (byte)i;\n\t\t\t\t\tcase '.':\n\t\t\t\t\t\tmapr[i][j] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault :mapr[i][j] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( solve() ) System.out.println(\"Yes\");\n\t\t\telse System.out.println(\"No\");\n\t\t}\n\t}\n\t\n\tbyte dx[] = {-1,0,1,0};\n\tbyte dy[] = {0,-1,0,1}; \n\t\n\tboolean solve() {\n\t\tHashSet<W> visited = new HashSet<W>();\n\t\tLinkedList<W> que = new LinkedList<W>();\n\t\tW now = new W( new P((byte)sxl, (byte)syl), new P((byte)sxr, (byte)syr) );\n\t\tque.add(now);\n\t\tvisited.add(now);\n\t\tfor(;!que.isEmpty();) {\n\t\t\tnow = que.removeFirst();\n//\t\t\tdebug(now.l.x, now.l.y, now.r.x, now.r.y);\n\t\t\tint g = isGoal(now);\n\t\t\tif( g == 1 ) return true;\n\t\t\tif( g == -1 ) continue;\n\t\t\t\n\t\t\tfor(int i=0;i<4;i++) {\n\t\t\t\tbyte nxl = (byte)(now.l.x + dx[i]);\n\t\t\t\tbyte nyl = (byte)(now.l.y + dy[i]);\n\t\t\t\tbyte nxr = (byte)(now.r.x - dx[i]);\n\t\t\t\tbyte nyr = (byte)(now.r.y + dy[i]);\n\t\t\t\tif( !mapl[nyl][nxl] ) {\n\t\t\t\t\tnxl -= dx[i];\n\t\t\t\t\tnyl -= dy[i];\n\t\t\t\t}\n\t\t\t\tif( !mapr[nyr][nxr] ) {\n\t\t\t\t\tnxr += dx[i];\n\t\t\t\t\tnyr -= dy[i];\n\t\t\t\t}\n\t\t\t\tif( visited.contains(new W( new P(nxl, nyl), new P(nxr, nyr) )) ) continue;\n\t\t\t\tque.add( new W( new P(nxl, nyl), new P(nxr, nyr) ) );\n\t\t\t\tvisited.add( new W( new P(nxl, nyl), new P(nxr, nyr) ) );\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tint isGoal(W w) {\n\t\tif( w.l.equals(new P(gxl, gyl)) && w.r.equals(new P(gxr, gyr)) )\n\t\t\treturn 1;\n\t\tif( w.l.equals(new P(gxl, gyl)) ^ w.r.equals(new P(gxr, gyr)) )\n\t\t\treturn -1;\n\t\telse return 0;\n\t}\n\t\n\tclass W {\n\t\tP l, r;\n\t\tW(P l, P r) {\n\t\t\tthis.l = l;\n\t\t\tthis.r = r;\n\t\t}\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif(o instanceof W) {\n\t\t\t\tW w = (W) o;\n\t\t\t\treturn l.equals(w.l) && r.equals(w.r);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn r.hashCode() * 2500 + l.hashCode() * 2500;\n\t\t}\n\t}\n\t\n\tclass P {\n\t\tbyte x, y;\n\t\tP(byte x, byte y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif(o instanceof P) {\n\t\t\t\tP p = (P)o;\n\t\t\t\treturn x == p.x && y == p.y;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn x * 50 + y;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint w, h;\n\tboolean[][] mapl, mapr;\n\tint sxl, syl, sxr, syr;\n\tint gxl, gyl, gxr, gyr;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif( (w|h) == 0 ) break;\n\t\t\t\n\t\t\tmapl = new boolean[h+2][w+2];\n\t\t\tmapr = new boolean[h+2][w+2];\n\t\t\t\n\t\t\tfor(int i=1;i<=h;i++) {\n\t\t\t\tString l = sc.next();\n\t\t\t\tString r = sc.next();\n//\t\t\t\tdebug(l, r);\n\t\t\t\tfor(int j=1;j<=w;j++) {\n\t\t\t\t\tswitch (l.charAt(j-1)) {\n\t\t\t\t\tcase '%':\n\t\t\t\t\t\tgxl = j;\n\t\t\t\t\t\tgyl = i;\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\tsxl = j;\n\t\t\t\t\t\tsyl = i;\n\t\t\t\t\tcase '.':\n\t\t\t\t\t\tmapl[i][j] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault :mapl[i][j] = false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tswitch (r.charAt(j-1)) {\n\t\t\t\t\tcase '%':\n\t\t\t\t\t\tgxr = j;\n\t\t\t\t\t\tgyr = i;\n\t\t\t\t\tcase 'R':\n\t\t\t\t\t\tsxr = j;\n\t\t\t\t\t\tsyr = i;\n\t\t\t\t\tcase '.':\n\t\t\t\t\t\tmapr[i][j] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault :mapr[i][j] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( solve() ) System.out.println(\"Yes\");\n\t\t\telse System.out.println(\"No\");\n\t\t}\n\t}\n\t\n\tint dx[] = {-1,0,1,0};\n\tint dy[] = {0,-1,0,1}; \n\t\n\tboolean solve() {\n\t\tHashSet<W> visited = new HashSet<W>();\n\t\tLinkedList<W> que = new LinkedList<W>();\n\t\tW now = new W( new P(sxl, syl), new P(sxr, syr) );\n\t\tque.add(now);\n\t\tvisited.add(now);\n\t\tfor(;!que.isEmpty();) {\n\t\t\tnow = que.removeFirst();\n//\t\t\tdebug(now.l.x, now.l.y, now.r.x, now.r.y);\n\t\t\tint g = isGoal(now);\n\t\t\tif( g == 1 ) return true;\n\t\t\tif( g == -1 ) continue;\n\t\t\t\n\t\t\tfor(int i=0;i<4;i++) {\n\t\t\t\tint nxl = now.l.x + dx[i];\n\t\t\t\tint nyl = now.l.y + dy[i];\n\t\t\t\tint nxr = now.r.x - dx[i];\n\t\t\t\tint nyr = now.r.y + dy[i];\n\t\t\t\tif( !mapl[nyl][nxl] ) {\n\t\t\t\t\tnxl -= dx[i];\n\t\t\t\t\tnyl -= dy[i];\n\t\t\t\t}\n\t\t\t\tif( !mapr[nyr][nxr] ) {\n\t\t\t\t\tnxr += dx[i];\n\t\t\t\t\tnyr -= dy[i];\n\t\t\t\t}\n\t\t\t\tif( visited.contains(new W( new P(nxl, nyl), new P(nxr, nyr) )) ) continue;\n\t\t\t\tque.add( new W( new P(nxl, nyl), new P(nxr, nyr) ) );\n\t\t\t\tvisited.add( new W( new P(nxl, nyl), new P(nxr, nyr) ) );\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tint isGoal(W w) {\n\t\tif( w.l.equals(new P(gxl, gyl)) && w.r.equals(new P(gxr, gyr)) )\n\t\t\treturn 1;\n\t\tif( w.l.equals(new P(gxl, gyl)) ^ w.r.equals(new P(gxr, gyr)) )\n\t\t\treturn -1;\n\t\telse return 0;\n\t}\n\t\n\tclass W {\n\t\tP l, r;\n\t\tW(P l, P r) {\n\t\t\tthis.l = l;\n\t\t\tthis.r = r;\n\t\t}\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif(o instanceof W) {\n\t\t\t\tW w = (W) o;\n\t\t\t\treturn l.equals(w.l) && r.equals(w.r);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn r.hashCode() * 2500 + l.hashCode() * 2500;\n\t\t}\n\t}\n\t\n\tclass P {\n\t\tint x, y;\n\t\tP(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif(o instanceof P) {\n\t\t\t\tP p = (P)o;\n\t\t\t\treturn x == p.x && y == p.y;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn x * 50 + y;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DY = { 1, 0, -1, 0 };\n\tstatic int[] DX = { 0, -1, 0, 1 };\n\tstatic int W, H;\n\tstatic char[][] mapL, mapR;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tW = sc.nextInt();\n\t\t\tH = sc.nextInt();\n\t\t\tif (W == 0) break;\n\t\t\tmapL = new char[H][];\n\t\t\tmapR = new char[H][];\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tmapL[i] = sc.next().toCharArray();\n\t\t\t\tmapR[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tSystem.out.println(solve() ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\n\tstatic boolean solve() {\n\t\tboolean[] visited = new boolean[H * W * H * W];\n\t\tint pos = 0;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (mapL[i][j] == 'L') {\n\t\t\t\t\tpos |= (i << 18) | (j << 12);\n\t\t\t\t}\n\t\t\t\tif (mapR[i][j] == 'R') {\n\t\t\t\t\tpos |= (i << 6) | j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvisited[posToIdx(pos)] = true;\n\t\tQueue<Integer> q = new ArrayDeque<>();\n\t\tq.add(pos);\n\t\twhile (!q.isEmpty()) {\n\t\t\tint p = q.poll();\n\t\t\tint y1 = p >> 18;\n\t\t\tint x1 = (p >> 12) & 0x3F;\n\t\t\tint y2 = (p >> 6) & 0x3F;\n\t\t\tint x2 = p & 0x3F;\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tint ny1 = y1 + DY[i];\n\t\t\t\tint nx1 = x1 + DX[i];\n\t\t\t\tint ny2 = y2 + DY[i];\n\t\t\t\tint nx2 = x2 - DX[i];\n\t\t\t\tif (ny1 < 0 || H <= ny1 || nx1 < 0 || W <= nx1 || mapL[ny1][nx1] == '#') {\n\t\t\t\t\tny1 = y1;\n\t\t\t\t\tnx1 = x1;\n\t\t\t\t}\n\t\t\t\tif (ny2 < 0 || H <= ny2 || nx2 < 0 || W <= nx2 || mapR[ny2][nx2] == '#') {\n\t\t\t\t\tny2 = y2;\n\t\t\t\t\tnx2 = x2;\n\t\t\t\t}\n\t\t\t\tboolean goalL = mapL[ny1][nx1] == '%';\n\t\t\t\tboolean goalR = mapR[ny2][nx2] == '%';\n\t\t\t\tif (goalL && goalR) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (!goalL && !goalR) {\n\t\t\t\t\tint np = (ny1 << 18) | (nx1 << 12) | (ny2 << 6) | nx2;\n\t\t\t\t\tint ni = posToIdx(np);\n\t\t\t\t\tif (!visited[ni]) {\n\t\t\t\t\t\tvisited[ni] = true;\n\t\t\t\t\t\tq.add(np);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic int posToIdx(int p) {\n\t\tint y1 = p >> 18;\n\t\tint x1 = (p >> 12) & 0x3F;\n\t\tint y2 = (p >> 6) & 0x3F;\n\t\tint x2 = p & 0x3F;\n\t\treturn (y1 * W + x1) * H * W + (y2 * W + x2);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic char[][] squaresL;\n\tstatic char[][] squaresR;\n\tstatic boolean[][][][] isVisited;\n\t//動き方(左で言うと上下左右)\n\tstatic int[][] leftMove = {{0,1},{0,-1},{-1,0},{1,0}};\n\tstatic int[][] rightMove = {{0,1},{0,-1},{1,0},{-1,0}};\n\tstatic int H;\n\tstatic int W;\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true) {\n\n\t\t\tW = sc.nextInt();\n\t\t\tH = sc.nextInt();\n\n\t\t\tif((W|H) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tString rawL=\"\";\n\t\t\tString rawR=\"\";\n\n\t\t\tsquaresL = new char[H][W];\n\t\t\tsquaresR = new char[H][W];\n\n\t\t\tfor(int h = 0; h < H; h++) {\n\t\t\t\trawL=sc.next();\n\t\t\t\trawR=sc.next();\n\t\t\t\tfor(int w = 0; w < W; w++) {\n\t\t\t\t\tsquaresL[h][w] = rawL.charAt(w);\n\t\t\t\t\tsquaresR[h][w] = rawR.charAt(w);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint initLh =0;\n\t\t\tint initLw=0;\n\t\t\tint initRh=0;\n\t\t\tint initRw=0;\n\t\t\tfor(int h = 0; h < H; h++) {\n\t\t\t\tfor(int w = 0; w < W; w++) {\n\t\t\t\t\tif(squaresL[h][w]=='L') {\n\t\t\t\t\t\tinitLh = h;\n\t\t\t\t\t\tinitLw=w;\n\t\t\t\t\t}\n\t\t\t\t\tif(squaresR[h][w]=='R') {\n\t\t\t\t\t\tinitRh=h;\n\t\t\t\t\t\tinitRw=w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Rin Lenの場所セットを一括で管理する\n\t\t\t//左の高さ、横、右の高さ、横\n\t\t\tisVisited = new boolean[H][W][H][W];\n\t\t\tisVisited[initLh][initLw][initRh][initRw] = true;\n\n\t\t\tQueue<int[]> q = new ArrayDeque<int[]>();\n\n\t\t\t//左の高さ、横、右の高さ、横\n\t\t\tq.add(new int[]{initLh, initLw, initRh, initRw});\n\n\t\t\tint[] nowSquares;\n\n\t\t\tboolean isYes = false;\n\n\t\t\twhile(!q.isEmpty()) {\n\t\t\t\tnowSquares = (int[]) q.poll();\n\t\t\t\t//次のステップの状態を見る\n\t\t\t\tfor(int i = 0;i< 4 ; i++) {\n\t\t\t\t\tint[] nextSquares = getNext(nowSquares, i);\n\t\t\t\t\tint nextLh=nextSquares[0];\n\t\t\t\t\tint nextLw=nextSquares[1];\n\t\t\t\t\tint nextRh=nextSquares[2];\n\t\t\t\t\tint nextRw=nextSquares[3];\n\n\t\t\t\t\t//すでに訪れたことがあるなら無視\n\t\t\t\t\tif(isVisited[nextLh][nextLw][nextRh][nextRw] == true) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(squaresL[nextLh][nextLw]=='%' && squaresR[nextRh][nextRw] == '%'){\n\t\t\t\t\t\t//同時に扉につくならYesを出力\n\t\t\t\t\t\tisYes=true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}else if(squaresL[nextLh][nextLw]=='%' || squaresR[nextRh][nextRw] == '%') {\n\t\t\t\t\t\t//片方のみ先に扉につくなら無視\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else {\n\t\t\t\t\t\t//次のステップに進む場合、フラグを立ててキューに入れる\n\t\t\t\t\t\tisVisited[nextLh][nextLw][nextRh][nextRw] = true;\n\t\t\t\t\t\tq.add(nextSquares);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tif(isYes) {\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}else {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tstatic int[] getNext(int[] nowSquares, int idx) {\n\t\tint nowLh = nowSquares[0];\n\t\tint nowLw = nowSquares[1];\n\t\tint nowRh = nowSquares[2];\n\t\tint nowRw = nowSquares[3];\n\n\t\tint nextLh;\n\t\tint nextLw;\n\t\tint nextRh;\n\t\tint nextRw;\n\n\t\tif(nowLh + leftMove[idx][1] < 0 || nowLh + leftMove[idx][1] >= H\n\t\t\t\t|| nowLw + leftMove[idx][0] < 0 || nowLw + leftMove[idx][0] >= W) {\n\t\t\t//左が範囲外に出る場合\n\t\t\tnextLh = nowLh;\n\t\t\tnextLw = nowLw;\n\t\t}else {\n\t\t\t//左が範囲内へ動く場合\n\t\t\tchar nextL = squaresL[nowLh + leftMove[idx][1]][nowLw + leftMove[idx][0]];\n\n\t\t\tif(nextL =='#') {\n\t\t\t\t//行き先が壁\n\t\t\t\tnextLh = nowLh;\n\t\t\t\tnextLw = nowLw;\n\t\t\t}else {\n\t\t\t\t//移動する\n\t\t\t\tnextLh = nowLh + leftMove[idx][1];\n\t\t\t\tnextLw = nowLw + leftMove[idx][0];\n\t\t\t}\n\t\t}\n\n\t\tif(nowRh + rightMove[idx][1] < 0 || nowRh + rightMove[idx][1] >= H\n\t\t\t\t|| nowRw + rightMove[idx][0] < 0 || nowRw + rightMove[idx][0] >= W) {\n\t\t\t//右が範囲外に出る場合\n\t\t\tnextRh = nowRh;\n\t\t\tnextRw = nowRw;\n\t\t}else {\n\t\t\t//右が範囲内へ動く場合\n\t\t\tchar nextR = squaresR[nowRh + rightMove[idx][1]][nowRw + rightMove[idx][0]];\n\n\t\t\tif(nextR =='#') {\n\t\t\t\t//行き先が壁\n\t\t\t\tnextRh = nowRh;\n\t\t\t\tnextRw = nowRw;\n\t\t\t}else {\n\t\t\t\t//移動する\n\t\t\t\tnextRh = nowRh + rightMove[idx][1];\n\t\t\t\tnextRw = nowRw + rightMove[idx][0];\n\t\t\t}\n\t\t}\n\n\t\treturn new int[] {nextLh, nextLw, nextRh, nextRw};\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.Point;\n\npublic class Main{\n\tstatic int w,h;\n\tstatic Point sa,sb,ga,gb;\n\tstatic char[][] mapA, mapB;\n\tstatic boolean[][][][] memo;\n\n\tstatic int dxa[] = {0,0,1,-1};\n\tstatic int dxb[] = {0,0,-1,1};\n\tstatic int dya[] = {1,-1,0,0};\n\tstatic int dyb[] = {1,-1,0,0};\n\n\tstatic boolean solve(Point posA, Point posB){\n\t\tmemo[posA.x][posA.y][posB.x][posB.y] = true;\n\n\t\tfor(int i=0;i<4;i++){\n\t\t\tPoint na = new Point(posA.x+dxa[i], posA.y+dya[i]);\n\t\t\tPoint nb = new Point(posB.x+dxb[i], posB.y+dyb[i]);\n\n\t\t\tif(na.x<0 || na.x>=w || na.y<0 || na.y>=h || mapA[na.y][na.x]=='#') na = new Point(posA.x,posA.y);\n\t\t\tif(nb.x<0 || nb.x>=w || nb.y<0 || nb.y>=h || mapB[nb.y][nb.x]=='#') nb = new Point(posB.x,posB.y);\n\n\t\t\tif(na.equals(ga) && nb.equals(gb)) return true;\n\t\t\tif(na.equals(ga) || nb.equals(gb)) continue;\n\t\t\tif(memo[na.x][na.y][nb.x][nb.y]) continue;\n\t\t\tif(solve(na,nb)) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif(w == 0 && h == 0) break;\n\n\t\t\tmemo = new boolean[w+1][h+1][w+1][h+1];\n\t\t\tmapA = new char[h][w];\n\t\t\tmapB = new char[h][w];\n\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tmapA[i] = sc.next().toCharArray();\n\t\t\t\tmapB[i] = sc.next().toCharArray();\n\t\t\t\t\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(mapA[i][j] == 'L'){\n\t\t\t\t\t\tsa = new Point(j,i);\n\t\t\t\t\t}\n\t\t\t\t\telse if(mapA[i][j] == '%'){\n\t\t\t\t\t\tga = new Point(j,i);\n\t\t\t\t\t}\n\t\t\t\t\tif(mapB[i][j] == 'R'){\n\t\t\t\t\t\tsb = new Point(j,i);\n\t\t\t\t\t}\n\t\t\t\t\telse if(mapB[i][j] == '%'){\n\t\t\t\t\t\tgb = new Point(j,i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(solve(sa,sb) ? \"Yes\" : \"No\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.BitSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\npublic class Main{\n\tpublic static final int[] dx = {1, 0, -1, 0};\n\tpublic static final int[] dy = {0, 1, 0, -1};\n\tpublic static int w, h;\n\tpublic static char[][][] map;\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = in.nextInt();\n\t\t\th = in.nextInt();\n\t\t\tif(w == 0) break;\n\t\t\tmap = new char[2][h][w];\n\t\t\tint g = 0;\n\t\t\tint s = 0;\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\tfor(int j=0; j<2; j++){\n\t\t\t\t\tchar[] line = in.next().toCharArray();\n\t\t\t\t\tif(j==0) map[j][i] = line;\n\t\t\t\t\telse{\n\t\t\t\t\t\tfor(int k=0; k<w; k++){\n\t\t\t\t\t\t\tmap[j][i][k] = line[w-1-k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0; k<w; k++){\n\t\t\t\t\t\tswitch(map[j][i][k]){\n\t\t\t\t\t\tcase 'R':\n\t\t\t\t\t\tcase 'L':\n\t\t\t\t\t\t\ts += id(j, i, k);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '%':\n\t\t\t\t\t\t\tg += id(j, i, k);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tBitSet used = new BitSet(w*w*h*h);\n\t\t\tQueue<Integer> qu = new LinkedList<Integer>();\n\t\t\tqu.add(s);\n\t\t\tused.set(s);\n\t\t\tint hw = h*w;\n\t\t\tint whw = w*h*w;\n\t\t\tboolean flag = false;\n\t\t\twhile(!qu.isEmpty()){\n\t\t\t\tint id = qu.poll();\n\t\t\t\tif(id == g){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint y0 = id/whw;\n\t\t\t\tid %= whw;\n\t\t\t\tint x0 = id/hw;\n\t\t\t\tid %= hw;\n\t\t\t\tint y1 = id/w;\n\t\t\t\tint x1 = id%w;\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tint nid = next(x0, y0, x1, y1, i);\n\t\t\t\t\tif(used.get(nid)) continue;\n\t\t\t\t\tused.set(nid);\n\t\t\t\t\tqu.add(nid);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(flag ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\t\n\tpublic static String dump(char[][] map){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tsb.append(map[i][j]+\" \");\n\t\t\t}\n\t\t\tsb.append('\\n');\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tpublic static int next(int x0, int y0, int x1, int y1, int dir){\n\t\tint nx0 = x0 + dx[dir];\n\t\tint ny0 = y0 + dy[dir];\n\t\tif(nx0 < 0 || nx0 >= w || ny0 < 0 || ny0 >= h\n\t\t\t\t|| map[0][ny0][nx0] == '#'){\n\t\t\tnx0 = x0;\n\t\t\tny0 = y0;\n\t\t}\n\t\tint nx1 = x1 + dx[dir];\n\t\tint ny1 = y1 + dy[dir];\n\t\tif(nx1 < 0 || nx1 >= w || ny1 < 0 || ny1 >= h\n\t\t\t\t|| map[1][ny1][nx1] == '#'){\n\t\t\tnx1 = x1;\n\t\t\tny1 = y1;\n\t\t}\n\t\treturn (ny0*w+nx0)*h*w + ny1*w+nx1;\n\t}\n\t\n\tpublic static int id(int room, int y, int x){\n\t\treturn room==0 ? (y*w+x)*w*h : y*w+x;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\t\n\tint[] vx = {-1, 0, 1, 0};\n\tint[] vy = {0, -1, 0, 1};\n\tQueue<Integer> q = new LinkedList<Integer>();\n\tHashSet<Integer> hash = new HashSet<Integer>();\n\tint getKey(int rx, int ry, int lx, int ly) {\n\t\treturn 1000000 * rx + 10000 * ry + 100 * lx + ly;\n\t}\n\t\n\tboolean inside(int x, int y, int n, int m) {\n\t\treturn 0 <= x && x < m && 0 <= y && y < n;\n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint m = in.nextInt(), n = in.nextInt();\n\t\t\tif (n == 0 && m == 0) break;\n\t\t\t\n\t\t\thash.clear();\n\t\t\tq.clear();\n\t\t\tchar[][] rin = new char[n][];\n\t\t\tchar[][] len = new char[n][];\n\t\t\tint rsx = -1, rsy = -1, lsx = -1, lsy = -1;\n\t\t\tint rgx = -1, rgy = -1, lgx = -1, lgy = -1;\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tlen[i] = in.next().toCharArray();\n\t\t\t\trin[i] = in.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tif (rin[i][j] == '%') {\n\t\t\t\t\t\trgx = j; rgy = i;\n\t\t\t\t\t} else if (rin[i][j] == 'R') {\n\t\t\t\t\t\trsx = j; rsy = i;\n\t\t\t\t\t}\n\t\t\t\t\tif (len[i][j] == '%') {\n\t\t\t\t\t\tlgx = j; lgy = i;\n\t\t\t\t\t} else if (len[i][j] == 'L') {\n\t\t\t\t\t\tlsx = j; lsy = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\thash.add(getKey(rsx, rsy, lsx, lsy));\n\t\t\tq.add(getKey(rsx, rsy, lsx, lsy));\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tint next = q.poll();\n\t\t\t\tint ly = next % 100;\n\t\t\t\tnext /= 100;\n\t\t\t\tint lx = next % 100;\n\t\t\t\tnext /= 100;\n\t\t\t\tint ry = next % 100;\n\t\t\t\tnext /= 100;\n\t\t\t\tint rx = next % 100;\n\t\t\t\t\t\t\t\t\n\t\t\t\tfor (int d = 0; d < vx.length; d++) {\n\t\t\t\t\tint nrx = rx + vx[d], nry = ry + vy[d];\n\t\t\t\t\tint nlx = lx - vx[d], nly = ly + vy[d];\n\t\t\t\t\t\n\t\t\t\t\tif (!inside(nrx, nry, n, m) || rin[nry][nrx] == '#') {\n\t\t\t\t\t\tnrx = rx; nry = ry;\n\t\t\t\t\t}\n\t\t\t\t\tif (!inside(nlx, nly, n, m) || len[nly][nlx] == '#') {\n\t\t\t\t\t\tnlx = lx; nly = ly;\n\t\t\t\t\t}\n\t\t\t\t\tif (hash.contains(getKey(nrx, nry, nlx, nly))) continue;\n\t\t\t\t\thash.add(getKey(nrx, nry, nlx, nly));\n\t\t\t\t\tif (!((nrx == rgx && nry == rgy) || (nlx == lgx && nly == lgy))) {\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tq.add(getKey(nrx, nry, nlx, nly));\n\t\t\t\t\t}\t\t\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(hash.contains(getKey(rgx, rgy, lgx, lgy)) ? \"Yes\" : \"No\");\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint m, n;\n\n\tint[][] al, ar;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tm=sc.nextInt();\n\t\t\tn=sc.nextInt();\n\t\t\tif((m|n)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tal=new int[n][m];\n\t\t\tar=new int[n][m];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tString sl=sc.next();\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\tal[j][i]=c2i(sl.charAt(i));\n\t\t\t\t}\n\t\t\t\tString sr=sc.next();\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\tar[j][i]=c2i(sr.charAt(i));\n\t\t\t\t}\n\t\t\t\t// debug(al[j], ar[j]);\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tboolean[][][][] visited=new boolean[m][n][m][n];\n\t\tint xl0=0, yl0=0, xr0=0, yr0=0;\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tif(al[j][i]==-1){\n\t\t\t\t\txl0=i;\n\t\t\t\t\tyl0=j;\n\t\t\t\t\tal[j][i]=0;\n\t\t\t\t}\n\t\t\t\tif(ar[j][i]==-1){\n\t\t\t\t\txr0=i;\n\t\t\t\t\tyr0=j;\n\t\t\t\t\tar[j][i]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tLinkedList<P> que=new LinkedList<P>();\n\t\tque.offer(new P(xl0, yl0, xr0, yr0));\n\t\tint[] dxl={0, 0, -1, 1};\n\t\tint[] dyl={-1, 1, 0, 0};\n\t\tint[] dxr={0, 0, 1, -1};\n\t\tint[] dyr={-1, 1, 0, 0};\n\t\tboolean yes=false;\n\t\tfor(; !que.isEmpty()&&!yes;){\n\t\t\tP p=que.poll();\n\t\t\t// debug(p.xl, p.yl, p.xr, p.yr);\n\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\tP q=new P(p.xl+dxl[i], p.yl+dyl[i], p.xr+dxr[i], p.yr+dyr[i]);\n\t\t\t\tif(!in(q.xl, q.yl)||al[q.yl][q.xl]==1){\n\t\t\t\t\tq.xl=p.xl;\n\t\t\t\t\tq.yl=p.yl;\n\t\t\t\t}\n\t\t\t\tif(!in(q.xr, q.yr)||ar[q.yr][q.xr]==1){\n\t\t\t\t\tq.xr=p.xr;\n\t\t\t\t\tq.yr=p.yr;\n\t\t\t\t}\n\t\t\t\t// debug(\"\\t\", q.xl, q.yl, q.xr, q.yr);\n\t\t\t\t// q.xr=max(min(q.xr, m-1), 0);\n\t\t\t\t// q.yr=max(min(q.yr, n-1), 0);\n\t\t\t\tboolean ll=al[q.yl][q.xl]==2;\n\t\t\t\tboolean rr=ar[q.yr][q.xr]==2;\n\t\t\t\tif(ll^rr){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(ll&&rr){\n\t\t\t\t\tyes=true;\n\t\t\t\t}\n\t\t\t\tif(!visited[q.xl][q.yl][q.xr][q.yr]){\n\t\t\t\t\tvisited[q.xl][q.yl][q.xr][q.yr]=true;\n\t\t\t\t\tque.offer(q);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintln(yes?\"Yes\":\"No\");\n\t}\n\n\tboolean in(int x, int y){\n\t\treturn x>=0&&x<m&&y>=0&&y<n;\n\t}\n\n\tclass P{\n\t\tbyte xl, yl, xr, yr;\n\n\t\tP(int xl, int yl, int xr, int yr){\n\t\t\tthis.xl=(byte)xl;\n\t\t\tthis.yl=(byte)yl;\n\t\t\tthis.xr=(byte)xr;\n\t\t\tthis.yr=(byte)yr;\n\t\t}\n\t}\n\n\tint c2i(char c){\n\t\tswitch(c){\n\t\tcase '.':\n\t\t\treturn 0;\n\t\tcase '#':\n\t\t\treturn 1;\n\t\tcase '%':\n\t\t\treturn 2;\n\t\tcase 'L':\n\t\t\treturn -1;\n\t\tcase 'R':\n\t\t\treturn -1;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  int w, h;\n  boolean[][][][] done;\n  char[][] fieldL;\n  char[][] fieldR;\n\n  int[][] ofsL = {\n      {0, 1},\n      {0, -1},\n      {1, 0},\n      {-1, 0}\n  };\n\n  int[][] ofsR = {\n      {0, 1},\n      {0, -1},\n      {-1, 0},\n      {1, 0}\n  };\n\n  boolean dfs(int lx, int ly, int rx, int ry) {\n    if (fieldL[ly][lx] == '%' && fieldR[ry][rx] == '%') {\n      return true;\n    }\n    if (fieldL[ly][lx] == '%' || fieldR[ry][rx] == '%') {\n      return false;\n    }\n    assert (fieldL[ly][lx] != '#' && fieldR[ry][rx] != '#');\n    if (done[ly][lx][ry][rx]) {\n      return false;\n    }\n    done[ly][lx][ry][rx] = true;\n    boolean flag = false;\n    for (int i = 0; i < 4; ++i) {\n      int[] dl = ofsL[i];\n      int nlx = lx + dl[0];\n      int nly = ly + dl[1];\n      if (fieldL[nly][nlx] == '#') {\n        nlx = lx;\n        nly = ly;\n      }\n      int[] dr = ofsR[i];\n      int nrx = rx + dr[0];\n      int nry = ry + dr[1];\n      if (fieldR[nry][nrx] == '#') {\n        nrx = rx;\n        nry = ry;\n      }\n      flag |= dfs(nlx, nly, nrx, nry);\n    }\n    return flag;\n  }\n\n  void run() {\n    for (; ; ) {\n      w = ni();\n      h = ni();\n      if (w == 0) {\n        break;\n      }\n      done = new boolean[h + 2][w + 2][h + 2][w + 2];\n      fieldL = new char[h + 2][w + 2];\n      fieldR = new char[h + 2][w + 2];\n      for (int i = 0; i < h + 2; ++i) {\n        Arrays.fill(fieldL[i], '#');\n        Arrays.fill(fieldR[i], '#');\n      }\n      int lx = -1, ly = -1;\n      int rx = -1, ry = -1;\n      for (int i = 1; i <= h; ++i) {\n        String[] str = new String[2];\n        str[0] = sc.next();\n        str[1] = sc.next();\n        for (int j = 1; j <= w; ++j) {\n          fieldL[i][j] = str[0].charAt(j - 1);\n          fieldR[i][j] = str[1].charAt(j - 1);\n          if (fieldL[i][j] == 'L') {\n            lx = j;\n            ly = i;\n          }\n          if (fieldR[i][j] == 'R') {\n            rx = j;\n            ry = i;\n          }\n        }\n      }\n      System.out.println(dfs(lx, ly, rx, ry) ? \"Yes\" : \"No\");\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[][] field1,field2;\n\tstatic boolean[][][][] dp;\n\tstatic int sXL,sXR,sYL,sYR;\n\tstatic boolean ans;\n\tstatic int[] v1={0,1,0,-1};\n\tstatic int[] v2={1,0,-1,0};\n\tstatic int w,h;\n\tpublic static void main(String[] args) {\n\t\tScanner cin=new Scanner(System.in);\n\t\twhile(true){\n\n\t\t\tw=cin.nextInt();\n\t\t\th=cin.nextInt();\n\t\t\tif(w+h==0){\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\tans=false;\n\t\t\tfield1=new int[h][w];\n\t\t\tfield2=new int[h][w];\n\t\t\tdp=new boolean[h][w][h][w];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<2;j++){\n\t\t\t\t\tString s=cin.next();\n\t\t\t\t\tint[][] a;\n\t\t\t\t\tif(j==0){\n\t\t\t\t\t\ta=field1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\ta=field2;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<s.length();k++){\n\t\t\t\t\t\tint b=0;\n\t\t\t\t\t\tif(s.charAt(k)=='%'){\n\t\t\t\t\t\t\tb=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(s.charAt(k)=='#'){\n\t\t\t\t\t\t\tb=-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(s.charAt(k)=='L'){\n\t\t\t\t\t\t\tsXL=i;\n\t\t\t\t\t\t\tsYL=k;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(s.charAt(k)=='R'){\n\t\t\t\t\t\t\tsXR=i;\n\t\t\t\t\t\t\tsYR=k;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ta[i][k]=b;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQueue<int[]> q=new LinkedList<int[]>();\n\t\t\tq.add(new int[]{sXL,sYL,sXR,sYR});\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint[] poll=q.poll();\n\t\t\t\tint a=poll[0];\n\t\t\t\tint b=poll[1];\n\t\t\t\tint c=poll[2];\n\t\t\t\tint d=poll[3];\n\t\t\t\tif(dp[a][b][c][d]||ans){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdp[a][b][c][d]=true;\n\t\t\t\tif(field1[a][b]==1&&field2[c][d]==1){\n\t\t\t\t\tans=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(field1[a][b]==1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(field2[c][d]==1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint aa=a+v1[i];\n\t\t\t\t\tint bb=b+v2[i];\n\t\t\t\t\tint cc=c+v1[i];\n\t\t\t\t\tint dd=d+-v2[i];\n//\t\t\t\t\tSystem.out.println(aa+\" \"+bb+\" \"+cc+\" \"+dd+\" \"+i);\n\t\t\t\t\tif(aa<0||aa>=h){\n\t\t\t\t\t\taa-=v1[i];\n\t\t\t\t\t}\n\t\t\t\t\tif(bb<0||bb>=w){\n\t\t\t\t\t\tbb-=v2[i];\n\t\t\t\t\t}\n\t\t\t\t\tif(cc<0||cc>=h){\n\t\t\t\t\t\tcc-=v1[i];\n\t\t\t\t\t}\n\t\t\t\t\tif(dd<0||dd>=w){\n\t\t\t\t\t\tdd-=-v2[i];\n\t\t\t\t\t}\n//\t\t\t\t\tSystem.out.println(aa+\" \"+bb+\" \"+cc+\" \"+dd+\" \"+i);\n\t\t\t\t\tif(field1[aa][bb]==-1){\n\t\t\t\t\t\taa-=v1[i];\n\t\t\t\t\t\tbb-=v2[i];\n\t\t\t\t\t}\n\t\t\t\t\tif(field2[cc][dd]==-1){\n\t\t\t\t\t\tcc-=v1[i];\n\t\t\t\t\t\tdd-=-v2[i];\n\t\t\t\t\t}\n\t\t\t\t\tq.add(new int[]{aa,bb,cc,dd});\n\t\t\t\t}\n\n\t\t\t}\n//\t\t\tbt(sXL,sYL,sXR,sYR);\n\t\t\tif(ans){\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t}\n\tstatic void bt(int a,int b,int c,int d){\n\t\tif(dp[a][b][c][d]||ans){\n\t\t\treturn ;\n\t\t}\n\t\tdp[a][b][c][d]=true;\n\t\tif(field1[a][b]==1&&field2[c][d]==1){\n\t\t\tans=true;\n\t\t}\n\t\tif(field1[a][b]==1){\n\t\t\treturn;\n\t\t}\n\t\tif(field2[c][d]==1){\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint aa=a+v1[i];\n\t\t\tint bb=b+v2[i];\n\t\t\tint cc=c+v1[i];\n\t\t\tint dd=d+-v2[i];\n//\t\t\tSystem.out.println(aa+\" \"+bb+\" \"+cc+\" \"+dd+\" \"+i);\n\t\t\tif(aa<0||aa>=h){\n\t\t\t\taa-=v1[i];\n\t\t\t}\n\t\t\tif(bb<0||bb>=w){\n\t\t\t\tbb-=v2[i];\n\t\t\t}\n\t\t\tif(cc<0||cc>=h){\n\t\t\t\tcc-=v1[i];\n\t\t\t}\n\t\t\tif(dd<0||dd>=w){\n\t\t\t\tdd-=-v2[i];\n\t\t\t}\n//\t\t\tSystem.out.println(aa+\" \"+bb+\" \"+cc+\" \"+dd+\" \"+i);\n\t\t\tif(field1[aa][bb]==-1){\n\t\t\t\taa-=v1[i];\n\t\t\t\tbb-=v2[i];\n\t\t\t}\n\t\t\tif(field2[cc][dd]==-1){\n\t\t\t\tcc-=v1[i];\n\t\t\t\tdd-=-v2[i];\n\t\t\t}\n\t\t\tbt(aa,bb,cc,dd);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DY = { 1, 0, -1, 0 };\n\tstatic int[] DX = { 0, -1, 0, 1 };\n\tstatic int W, H;\n\tstatic char[][] mapL, mapR;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tW = sc.nextInt();\n\t\t\tH = sc.nextInt();\n\t\t\tif (W == 0) break;\n\t\t\tmapL = new char[H][];\n\t\t\tmapR = new char[H][];\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tmapL[i] = sc.next().toCharArray();\n\t\t\t\tmapR[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tSystem.out.println(solve() ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\n\tstatic boolean solve() {\n\t\tboolean[] visited = new boolean[H * W * H * W];\n\t\tint pos = 0;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (mapL[i][j] == 'L') {\n\t\t\t\t\tpos |= (i << 18) | (j << 12);\n\t\t\t\t}\n\t\t\t\tif (mapR[i][j] == 'R') {\n\t\t\t\t\tpos |= (i << 6) | j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvisited[posToIdx(pos)] = true;\n\t\tQueue<Integer> q = new ArrayDeque<Integer>();\n\t\tq.add(pos);\n\t\twhile (!q.isEmpty()) {\n\t\t\tint p = q.poll();\n\t\t\tint y1 = p >> 18;\n\t\t\tint x1 = (p >> 12) & 0x3F;\n\t\t\tint y2 = (p >> 6) & 0x3F;\n\t\t\tint x2 = p & 0x3F;\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tint ny1 = y1 + DY[i];\n\t\t\t\tint nx1 = x1 + DX[i];\n\t\t\t\tint ny2 = y2 + DY[i];\n\t\t\t\tint nx2 = x2 - DX[i];\n\t\t\t\tif (ny1 < 0 || H <= ny1 || nx1 < 0 || W <= nx1 || mapL[ny1][nx1] == '#') {\n\t\t\t\t\tny1 = y1;\n\t\t\t\t\tnx1 = x1;\n\t\t\t\t}\n\t\t\t\tif (ny2 < 0 || H <= ny2 || nx2 < 0 || W <= nx2 || mapR[ny2][nx2] == '#') {\n\t\t\t\t\tny2 = y2;\n\t\t\t\t\tnx2 = x2;\n\t\t\t\t}\n\t\t\t\tboolean goalL = mapL[ny1][nx1] == '%';\n\t\t\t\tboolean goalR = mapR[ny2][nx2] == '%';\n\t\t\t\tif (goalL && goalR) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (!goalL && !goalR) {\n\t\t\t\t\tint np = (ny1 << 18) | (nx1 << 12) | (ny2 << 6) | nx2;\n\t\t\t\t\tint ni = posToIdx(np);\n\t\t\t\t\tif (!visited[ni]) {\n\t\t\t\t\t\tvisited[ni] = true;\n\t\t\t\t\t\tq.add(np);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic int posToIdx(int p) {\n\t\tint y1 = p >> 18;\n\t\tint x1 = (p >> 12) & 0x3F;\n\t\tint y2 = (p >> 6) & 0x3F;\n\t\tint x2 = p & 0x3F;\n\t\treturn (y1 * W + x1) * H * W + (y2 * W + x2);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\n\npublic class Main {\n\tstatic FastScanner sc = new FastScanner(System.in);\n\tstatic int[] DY = { 1, 0, -1, 0 };\n\tstatic int[] DX = { 0, -1, 0, 1 };\n\tstatic int W, H;\n\tstatic char[][] mapL = new char[52][52];\n\tstatic char[][] mapR = new char[52][52];\n\tstatic int[] q = new int[50 * 50 * 50 * 50];\n\n\tpublic static void main(String[] args) throws Exception {\n\t\twhile (true) {\n\t\t\tW = sc.nextInt();\n\t\t\tH = sc.nextInt();\n\t\t\tif (W == 0) break;\n\t\t\tfor (int i = 1; i <= H; ++i) {\n\t\t\t\tmapL[i][0] = '#';\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tmapL[i][j + 1] = sc.nextChar();\n\t\t\t\t}\n\t\t\t\tmapL[i][W + 1] = '#';\n\t\t\t\tmapR[i][0] = '#';\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tmapR[i][j + 1] = sc.nextChar();\n\t\t\t\t}\n\t\t\t\tmapR[i][W + 1] = '#';\n\t\t\t}\n\t\t\tfor (int i = 1; i <= W; ++i) {\n\t\t\t\tmapL[0][i] = mapL[H + 1][i] = mapR[0][i] = mapR[H + 1][i] = '#';\n\t\t\t}\n\t\t\tSystem.out.println(solve() ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\n\tstatic boolean solve() {\n\t\tboolean[] visited = new boolean[H * W * H * W];\n\t\tint pos = 0;\n\t\tfor (int i = 1; i <= H; ++i) {\n\t\t\tfor (int j = 1; j <= W; ++j) {\n\t\t\t\tif (mapL[i][j] == 'L') {\n\t\t\t\t\tpos |= (i << 18) | (j << 12);\n\t\t\t\t}\n\t\t\t\tif (mapR[i][j] == 'R') {\n\t\t\t\t\tpos |= (i << 6) | j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvisited[posToIdx(pos)] = true;\n\t\tint qs = 0;\n\t\tint qe = 1;\n\t\tq[0] = pos;\n\t\twhile (qs != qe) {\n\t\t\tint p = q[qs++];\n\t\t\tint y1 = p >> 18;\n\t\t\tint x1 = (p >> 12) & 0x3F;\n\t\t\tint y2 = (p >> 6) & 0x3F;\n\t\t\tint x2 = p & 0x3F;\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tint ny1 = y1 + DY[i];\n\t\t\t\tint nx1 = x1 + DX[i];\n\t\t\t\tint ny2 = y2 + DY[i];\n\t\t\t\tint nx2 = x2 - DX[i];\n\t\t\t\tif (mapL[ny1][nx1] == '#') {\n\t\t\t\t\tny1 = y1;\n\t\t\t\t\tnx1 = x1;\n\t\t\t\t}\n\t\t\t\tif (mapR[ny2][nx2] == '#') {\n\t\t\t\t\tny2 = y2;\n\t\t\t\t\tnx2 = x2;\n\t\t\t\t}\n\t\t\t\tboolean goalL = mapL[ny1][nx1] == '%';\n\t\t\t\tboolean goalR = mapR[ny2][nx2] == '%';\n\t\t\t\tif (goalL && goalR) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (!goalL && !goalR) {\n\t\t\t\t\tint np = (ny1 << 18) | (nx1 << 12) | (ny2 << 6) | nx2;\n\t\t\t\t\tint ni = posToIdx(np);\n\t\t\t\t\tif (!visited[ni]) {\n\t\t\t\t\t\tvisited[ni] = true;\n\t\t\t\t\t\tq[qe++] = np;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic int posToIdx(int p) {\n\t\tint y1 = p >> 18;\n\t\tint x1 = (p >> 12) & 0x3F;\n\t\tint y2 = (p >> 6) & 0x3F;\n\t\tint x2 = p & 0x3F;\n\t\treturn ((y1 - 1) * W + (x1 - 1)) * H * W + ((y2 - 1) * W + (x2 - 1));\n\t}\n\n\tstatic class FastScanner {\n\t\tReader input;\n\n\t\tFastScanner() {\n\t\t\tthis(System.in);\n\t\t}\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tthis.input = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\tint sign = 1;\n\t\t\tint b = input.read();\n\t\t\twhile ((b < '0' || '9' < b) && b != '-' && b != '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tif (b == '-') {\n\t\t\t\tsign = -1;\n\t\t\t\tb = input.read();\n\t\t\t} else if (b == '+') {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\tint ret = b - '0';\n\t\t\twhile (true) {\n\t\t\t\tb = input.read();\n\t\t\t\tif (b < '0' || '9' < b) return ret * sign;\n\t\t\t\tret *= 10;\n\t\t\t\tret += b - '0';\n\t\t\t}\n\t\t}\n\n\t\tchar nextChar() throws IOException {\n\t\t\tint b = input.read();\n\t\t\twhile (Character.isWhitespace((char) b)) {\n\t\t\t\tb = input.read();\n\t\t\t}\n\t\t\treturn (char) b;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static final void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tint w;\n\tint h;\n\tchar[][] map = new char[2][100*100];\n\tint sl;\n\tint sr;\n\tpublic Main() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif(w==0 && h==0)\n\t\t\t\tbreak;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tString s0 = sc.next();\n\t\t\t\tString s1 = sc.next();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tmap[0][i*w+j] = s0.charAt(j);\n\t\t\t\t\tmap[1][i*w+j] = s1.charAt(w-j-1);\n\t\t\t\t\tif(map[0][i*w+j]=='L')\n\t\t\t\t\t\tsl = i*w+j;\n\t\t\t\t\tif(map[1][i*w+j]=='R')\n\t\t\t\t\t\tsr = i*w+j;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t\tSystem.gc();\n\t\t}\n\t}\n\n\tint[] dx = new int[]{-1, 0, 1, 0};\n\tint[] dy = new int[]{0, -1, 0, 1};\n\tprivate void solve() {\n\t\tLinkedList<int[]> queue = new LinkedList<int[]>();\n\t\t\n\t\tint[][] visited = new int[w*h][w*h];\n\t\tqueue.add(new int[]{sl, sr});\n\n\t\twhile(!queue.isEmpty()){\n\t\t\tint[] cp = queue.poll();\n\t\t\tint clp = cp[0];\n\t\t\tint crp = cp[1];\n\t\t\t\n\t\t\tif(visited[clp][crp]==1)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tvisited[clp][crp] = 1;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nlpx = clp%w +dx[i];\n\t\t\t\tint nlpy = clp/w +dy[i];\n\t\t\t\tint nrpx = crp%w +dx[i];\n\t\t\t\tint nrpy = crp/w +dy[i];\n\t\t\t\t\n\t\t\t\tif(nlpx<0 || w<=nlpx) nlpx = clp%w;\n\t\t\t\tif(nlpy<0 || h<=nlpy) nlpy = clp/w;\n\t\t\t\tif(nrpx<0 || w<=nrpx) nrpx = crp%w;\n\t\t\t\tif(nrpy<0 || h<=nrpy) nrpy = crp/w;\n\t\t\t\t\n\t\t\t\tint nlp = nlpx + nlpy*w;\n\t\t\t\tint nrp = nrpx + nrpy*w;\n\t\t\t\tif((nlp<0 || w*h<=nlp) && (nrp<0 || w*h<=nrp))\n\t\t\t\t\tcontinue;\n\t\t\t\telse if(nlp<0 || w*h<=nlp)\n\t\t\t\t\tnlp = clp;\n\t\t\t\telse if(nrp<0 || w*h<=nrp)\n\t\t\t\t\tnrp = crp;\n\t\t\t\t\n\t\t\t\tif(map[0][nlp]=='#' && map[1][nrp]=='#')\n\t\t\t\t\tcontinue;\n\t\t\t\tif(map[0][nlp]=='#')\n\t\t\t\t\tnlp = clp;\n\t\t\t\tif(map[1][nrp]=='#')\n\t\t\t\t\tnrp = crp;\n\t\t\t\t\n\t\t\t\tif(map[0][nlp]=='%' && map[1][nrp]=='%'){\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\tqueue.clear();\n\t\t\t\t\treturn;\n\t\t\t\t}else if(map[0][nlp]=='%' || map[1][nrp]=='%'){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tqueue.add(new int[]{nlp, nrp});\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"No\");\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n  int w, h;\n  boolean[][][][] done;\n  char[][] fieldL;\n  char[][] fieldR;\n  int[][] ofsL = {\n      {0, 1},\n      {0, -1},\n      {1, 0},\n      {-1, 0}\n  };\n  int[][] ofsR = {\n      {0, 1},\n      {0, -1},\n      {-1, 0},\n      {1, 0}\n  };\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  boolean dfs(byte lx, byte ly, byte rx, byte ry) {\n    if (fieldL[ly][lx] == '%' && fieldR[ry][rx] == '%') {\n      return true;\n    }\n    if (fieldL[ly][lx] == '%' || fieldR[ry][rx] == '%') {\n      return false;\n    }\n    assert (fieldL[ly][lx] != '#' && fieldR[ry][rx] != '#');\n    if (done[ly][lx][ry][rx]) {\n      return false;\n    }\n    done[ly][lx][ry][rx] = true;\n    debug(lx, ly, rx, ry);\n    boolean flag = false;\n    for (int i = 0; i < 4; ++i) {\n      int[] dl = ofsL[i];\n      byte nlx = (byte) (lx + dl[0]);\n      byte nly = (byte) (ly + dl[1]);\n      if (fieldL[nly][nlx] == '#') {\n        nlx = lx;\n        nly = ly;\n      }\n      int[] dr = ofsR[i];\n      byte nrx = (byte) (rx + dr[0]);\n      byte nry = (byte) (ry + dr[1]);\n      if (fieldR[nry][nrx] == '#') {\n        nrx = rx;\n        nry = ry;\n      }\n      flag |= dfs(nlx, nly, nrx, nry);\n    }\n    return flag;\n  }\n\n  void run() {\n    for (; ; ) {\n      w = ni();\n      h = ni();\n      if (w == 0) {\n        break;\n      }\n      done = new boolean[h + 2][w + 2][h + 2][w + 2];\n      fieldL = new char[h + 2][w + 2];\n      fieldR = new char[h + 2][w + 2];\n      for (int i = 0; i < h + 2; ++i) {\n        Arrays.fill(fieldL[i], '#');\n        Arrays.fill(fieldR[i], '#');\n      }\n      byte lx = -1, ly = -1;\n      byte rx = -1, ry = -1;\n      for (byte i = 1; i <= h; ++i) {\n        String[] str = new String[2];\n        str[0] = sc.next();\n        str[1] = sc.next();\n        for (byte j = 1; j <= w; ++j) {\n          fieldL[i][j] = str[0].charAt(j - 1);\n          fieldR[i][j] = str[1].charAt(j - 1);\n          if (fieldL[i][j] == 'L') {\n            lx = j;\n            ly = i;\n          }\n          if (fieldR[i][j] == 'R') {\n            rx = j;\n            ry = i;\n          }\n        }\n      }\n\n      Queue<Node> queue = new LinkedList<>();\n      Node atom = new Node();\n      atom.lx = lx;\n      atom.ly = ly;\n      atom.rx = rx;\n      atom.ry = ry;\n      queue.add(atom);\n      boolean flag = false;\n      while (queue.size() > 0) {\n        Node node = queue.poll();\n        if (fieldL[node.ly][node.lx] == '%' && fieldR[node.ry][node.rx] == '%') {\n          flag = true;\n          break;\n        }\n        if (fieldL[node.ly][node.lx] == '%' || fieldR[node.ry][node.rx] == '%') {\n          continue;\n        }\n        for (int i = 0; i < 4; ++i) {\n          int[] dl = ofsL[i];\n          byte nlx = (byte) (node.lx + dl[0]);\n          byte nly = (byte) (node.ly + dl[1]);\n          if (fieldL[nly][nlx] == '#') {\n            nlx = node.lx;\n            nly = node.ly;\n          }\n          int[] dr = ofsR[i];\n          byte nrx = (byte) (node.rx + dr[0]);\n          byte nry = (byte) (node.ry + dr[1]);\n          if (fieldR[nry][nrx] == '#') {\n            nrx = node.rx;\n            nry = node.ry;\n          }\n          if (done[nly][nlx][nry][nrx]) {\n            continue;\n          }\n          done[nly][nlx][nry][nrx] = true;\n          Node next = new Node();\n          next.lx = nlx;\n          next.ly = nly;\n          next.rx = nrx;\n          next.ry = nry;\n          queue.add(next);\n        }\n      }\n\n      System.out.println(flag ? \"Yes\" : \"No\");\n    }\n  }\n\n  class Node {\n    byte lx, ly, rx, ry;\n  }\n\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.BitSet;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DY = { 1, 0, -1, 0 };\n\tstatic int[] DX = { 0, -1, 0, 1 };\n\tstatic int W, H;\n\tstatic char[][] mapL, mapR;\n\tstatic BitSet visited = new BitSet(1 << 24);\n\tstatic int[] q = new int[50 * 50 * 50 * 50];\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tW = sc.nextInt();\n\t\t\tH = sc.nextInt();\n\t\t\tif (W == 0) break;\n\t\t\tmapL = new char[H][];\n\t\t\tmapR = new char[H][];\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tmapL[i] = sc.next().toCharArray();\n\t\t\t\tmapR[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tSystem.out.println(solve() ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\n\tstatic boolean solve() {\n\t\tboolean[] visited = new boolean[H * W * H * W];\n\t\tint pos = 0;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (mapL[i][j] == 'L') {\n\t\t\t\t\tpos |= (i << 18) | (j << 12);\n\t\t\t\t}\n\t\t\t\tif (mapR[i][j] == 'R') {\n\t\t\t\t\tpos |= (i << 6) | j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvisited[posToIdx(pos)] = true;\n\t\tint qs = 0;\n\t\tint qe = 1;\n\t\tq[0] = pos;\n\t\twhile (qs != qe) {\n\t\t\tint p = q[qs++];\n\t\t\tint y1 = p >> 18;\n\t\t\tint x1 = (p >> 12) & 0x3F;\n\t\t\tint y2 = (p >> 6) & 0x3F;\n\t\t\tint x2 = p & 0x3F;\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tint ny1 = y1 + DY[i];\n\t\t\t\tint nx1 = x1 + DX[i];\n\t\t\t\tint ny2 = y2 + DY[i];\n\t\t\t\tint nx2 = x2 - DX[i];\n\t\t\t\tif (ny1 < 0 || H <= ny1 || nx1 < 0 || W <= nx1 || mapL[ny1][nx1] == '#') {\n\t\t\t\t\tny1 = y1;\n\t\t\t\t\tnx1 = x1;\n\t\t\t\t}\n\t\t\t\tif (ny2 < 0 || H <= ny2 || nx2 < 0 || W <= nx2 || mapR[ny2][nx2] == '#') {\n\t\t\t\t\tny2 = y2;\n\t\t\t\t\tnx2 = x2;\n\t\t\t\t}\n\t\t\t\tboolean goalL = mapL[ny1][nx1] == '%';\n\t\t\t\tboolean goalR = mapR[ny2][nx2] == '%';\n\t\t\t\tif (goalL && goalR) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (!goalL && !goalR) {\n\t\t\t\t\tint np = (ny1 << 18) | (nx1 << 12) | (ny2 << 6) | nx2;\n\t\t\t\t\tint ni = posToIdx(np);\n\t\t\t\t\tif (!visited[ni]) {\n\t\t\t\t\t\tvisited[ni] = true;\n\t\t\t\t\t\tq[qe++] = np;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic int posToIdx(int p) {\n\t\tint y1 = p >> 18;\n\t\tint x1 = (p >> 12) & 0x3F;\n\t\tint y2 = (p >> 6) & 0x3F;\n\t\tint x2 = p & 0x3F;\n\t\treturn (y1 * W + x1) * H * W + (y2 * W + x2);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class Main {\n\tint w, h;\n\tchar[][] l, r;\n\tint[] ldx = { -1, 0, 0, 1 };\n\tint[] ldy = { 0, -1, 1, 0 };\n\tint[] rdx = { 1, 0, 0, -1 };\n\tint[] rdy = { 0, -1, 1, 0 };\n\tint slx, sly, srx, sry;\n\n\tboolean bfs() {\n\t\tQueue<Integer> lxque = new LinkedList<Integer>();\n\t\tQueue<Integer> lyque = new LinkedList<Integer>();\n\t\tQueue<Integer> rxque = new LinkedList<Integer>();\n\t\tQueue<Integer> ryque = new LinkedList<Integer>();\n\n\t\tlxque.add(slx);\n\t\tlyque.add(sly);\n\t\trxque.add(srx);\n\t\tryque.add(sry);\n\n\t\tboolean[][][][] vis = new boolean[w][h][w][h];\n\n\t\twhile (!lxque.isEmpty()) {\n\t\t\tint lx = lxque.poll();\n\t\t\tint ly = lyque.poll();\n\t\t\tint rx = rxque.poll();\n\t\t\tint ry = ryque.poll();\n\n\t\t\tif (vis[lx][ly][rx][ry]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvis[lx][ly][rx][ry] = true;\n\t\t\tif (l[ly][lx] == '%' && r[ry][rx] == '%') {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (l[ly][lx] == '%' || r[ry][rx] == '%') {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint nlx = lx + ldx[i];\n\t\t\t\tint nly = ly + ldy[i];\n\t\t\t\tint nrx = rx + rdx[i];\n\t\t\t\tint nry = ry + rdy[i];\n\n\t\t\t\tif (nlx < 0 || w <= nlx || nly < 0 || h <= nly || l[nly][nlx] == '#') {\n\t\t\t\t\tnlx -= ldx[i];\n\t\t\t\t\tnly -= ldy[i];\n\t\t\t\t}\n\t\t\t\tif (nrx < 0 || w <= nrx || nry < 0 || h <= nry || r[nry][nrx] == '#') {\n\t\t\t\t\tnrx -= rdx[i];\n\t\t\t\t\tnry -= rdy[i];\n\t\t\t\t}\n\t\t\t\tif (vis[nlx][nly][nrx][nry]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlxque.add(nlx);\n\t\t\t\tlyque.add(nly);\n\t\t\t\trxque.add(nrx);\n\t\t\t\tryque.add(nry);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\twhile (true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif ((w | h) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tl = new char[h][];\n\t\t\tr = new char[h][];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tl[i] = sc.next().toCharArray();\n\t\t\t\tr[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (l[i][j] == 'L') {\n\t\t\t\t\t\tslx = j;\n\t\t\t\t\t\tsly = i;\n\t\t\t\t\t\tl[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t\tif (r[i][j] == 'R') {\n\t\t\t\t\t\tsrx = j;\n\t\t\t\t\t\tsry = i;\n\t\t\t\t\t\tr[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(bfs());\n\t\t\tSystem.gc();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static final void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tint w;\n\tint h;\n\tchar[][] map = new char[2][100*100];\n\tint sl;\n\tint sr;\n\tpublic Main() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif(w==0 && h==0)\n\t\t\t\tbreak;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tString s0 = sc.next();\n\t\t\t\tString s1 = sc.next();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tmap[0][i*w+j] = s0.charAt(j);\n\t\t\t\t\tmap[1][i*w+j] = s1.charAt(w-j-1);\n\t\t\t\t\tif(map[0][i*w+j]=='L')\n\t\t\t\t\t\tsl = i*w+j;\n\t\t\t\t\tif(map[1][i*w+j]=='R')\n\t\t\t\t\t\tsr = i*w+j;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t\tSystem.gc();\n\t\t}\n\t}\n\n\tint[] dx = new int[]{-1, 0, 1, 0};\n\tint[] dy = new int[]{0, -1, 0, 1};\n\tprivate void solve() {\n\t\tLinkedList<int[]> queue = new LinkedList<int[]>();\n\t\t\n\t\tint[][] visited = new int[w*h][w*h];\n\t\tqueue.add(new int[]{sl, sr});\n\n\t\twhile(!queue.isEmpty()){\n\t\t\tint[] cp = queue.poll();\n\t\t\tint clp = cp[0];\n\t\t\tint crp = cp[1];\n\t\t\t\n\t\t\tif(visited[clp][crp]==1)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tvisited[clp][crp] = 1;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nlpx = clp%w +dx[i];\n\t\t\t\tint nlpy = clp/w +dy[i];\n\t\t\t\tint nrpx = crp%w +dx[i];\n\t\t\t\tint nrpy = crp/w +dy[i];\n\t\t\t\t\n\t\t\t\tif(nlpx<0 || w<=nlpx) nlpx = clp%w;\n\t\t\t\tif(nlpy<0 || h<=nlpy) nlpy = clp/w;\n\t\t\t\tif(nrpx<0 || w<=nrpx) nrpx = crp%w;\n\t\t\t\tif(nrpy<0 || h<=nrpy) nrpy = crp/w;\n\t\t\t\t\n\t\t\t\tint nlp = nlpx + nlpy*w;\n\t\t\t\tint nrp = nrpx + nrpy*w;\n\t\t\t\tif((nlp<0 || w*h<=nlp) && (nrp<0 || w*h<=nrp))\n\t\t\t\t\tcontinue;\n\t\t\t\telse if(nlp<0 || w*h<=nlp)\n\t\t\t\t\tnlp = clp;\n\t\t\t\telse if(nrp<0 || w*h<=nrp)\n\t\t\t\t\tnrp = crp;\n\t\t\t\t\n\t\t\t\tif(map[0][nlp]=='#' && map[1][nrp]=='#')\n\t\t\t\t\tcontinue;\n\t\t\t\tif(map[0][nlp]=='#')\n\t\t\t\t\tnlp = clp;\n\t\t\t\tif(map[1][nrp]=='#')\n\t\t\t\t\tnrp = crp;\n\t\t\t\t\n\t\t\t\tif(map[0][nlp]=='%' && map[1][nrp]=='%'){\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\tqueue.clear();\n\t\t\t\t\treturn;\n\t\t\t\t}else if(map[0][nlp]=='%' || map[1][nrp]=='%'){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\nif(visited[nlp][nrp]==0)\n\t\t\t\tqueue.add(new int[]{nlp, nrp});\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"No\");\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n  int w, h;\n  boolean[][][][] done;\n  char[][] fieldL;\n  char[][] fieldR;\n  int[][] ofsL = {\n      {0, 1},\n      {0, -1},\n      {1, 0},\n      {-1, 0}\n  };\n  int[][] ofsR = {\n      {0, 1},\n      {0, -1},\n      {-1, 0},\n      {1, 0}\n  };\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  boolean dfs(byte lx, byte ly, byte rx, byte ry) {\n    if (fieldL[ly][lx] == '%' && fieldR[ry][rx] == '%') {\n      return true;\n    }\n    if (fieldL[ly][lx] == '%' || fieldR[ry][rx] == '%') {\n      return false;\n    }\n    assert (fieldL[ly][lx] != '#' && fieldR[ry][rx] != '#');\n    if (done[ly][lx][ry][rx]) {\n      return false;\n    }\n    done[ly][lx][ry][rx] = true;\n    debug(lx, ly, rx, ry);\n    boolean flag = false;\n    for (int i = 0; i < 4; ++i) {\n      int[] dl = ofsL[i];\n      byte nlx = (byte) (lx + dl[0]);\n      byte nly = (byte) (ly + dl[1]);\n      if (fieldL[nly][nlx] == '#') {\n        nlx = lx;\n        nly = ly;\n      }\n      int[] dr = ofsR[i];\n      byte nrx = (byte) (rx + dr[0]);\n      byte nry = (byte) (ry + dr[1]);\n      if (fieldR[nry][nrx] == '#') {\n        nrx = rx;\n        nry = ry;\n      }\n      flag |= dfs(nlx, nly, nrx, nry);\n    }\n    return flag;\n  }\n\n  void run() {\n    for (; ; ) {\n      w = ni();\n      h = ni();\n      if (w == 0) {\n        break;\n      }\n      done = new boolean[h + 2][w + 2][h + 2][w + 2];\n      fieldL = new char[h + 2][w + 2];\n      fieldR = new char[h + 2][w + 2];\n      for (int i = 0; i < h + 2; ++i) {\n        Arrays.fill(fieldL[i], '#');\n        Arrays.fill(fieldR[i], '#');\n      }\n      byte lx = -1, ly = -1;\n      byte rx = -1, ry = -1;\n      for (byte i = 1; i <= h; ++i) {\n        String[] str = new String[2];\n        str[0] = sc.next();\n        str[1] = sc.next();\n        for (byte j = 1; j <= w; ++j) {\n          fieldL[i][j] = str[0].charAt(j - 1);\n          fieldR[i][j] = str[1].charAt(j - 1);\n          if (fieldL[i][j] == 'L') {\n            lx = j;\n            ly = i;\n          }\n          if (fieldR[i][j] == 'R') {\n            rx = j;\n            ry = i;\n          }\n        }\n      }\n\n      Queue<Node> queue = new LinkedList<>();\n      Node atom = new Node();\n      atom.lx = lx;\n      atom.ly = ly;\n      atom.rx = rx;\n      atom.ry = ry;\n      queue.add(atom);\n      boolean flag = false;\n      while (queue.size() > 0) {\n        Node node = queue.poll();\n        if (fieldL[node.ly][node.lx] == '%' && fieldR[node.ry][node.rx] == '%') {\n          flag = true;\n          break;\n        }\n        if (fieldL[node.ly][node.lx] == '%' || fieldR[node.ry][node.rx] == '%') {\n          continue;\n        }\n        for (int i = 0; i < 4; ++i) {\n          int[] dl = ofsL[i];\n          byte nlx = (byte) (node.lx + dl[0]);\n          byte nly = (byte) (node.ly + dl[1]);\n          if (fieldL[nly][nlx] == '#') {\n            nlx = node.lx;\n            nly = ly;\n          }\n          int[] dr = ofsR[i];\n          byte nrx = (byte) (node.rx + dr[0]);\n          byte nry = (byte) (node.ry + dr[1]);\n          if (fieldR[nry][nrx] == '#') {\n            nrx = rx;\n            nry = ry;\n          }\n          if (done[nly][nlx][nry][nrx]) {\n            continue;\n          }\n          done[nly][nlx][nry][nrx] = true;\n          Node next = new Node();\n          next.lx = nlx;\n          next.ly = nly;\n          next.rx = nrx;\n          next.ry = nry;\n          queue.add(next);\n        }\n      }\n\n      System.out.println(flag ? \"Yes\" : \"No\");\n    }\n  }\n\n  class Node {\n    byte lx, ly, rx, ry;\n  }\n\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Scanner;\nimport java.util.Queue;\nimport java.util.ArrayDeque;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        MirrorCave solver = new MirrorCave();\n        try {\n            int testNumber = 1;\n            while (true)\n                solver.solve(testNumber++, in, out);\n        } catch (UnknownError e) {\n            out.close();\n        }\n    }\n\n    static class MirrorCave {\n        final int[] dh = new int[]{0, -1, 0, 1};\n        final int[] dw = new int[]{-1, 0, 1, 0};\n        final int[] dh2 = new int[]{0, -1, 0, 1};\n        final int[] dw2 = new int[]{1, 0, -1, 0};\n\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int W = in.nextInt();\n            int H = in.nextInt();\n            if (W == 0) {\n                throw new UnknownError();\n            }\n            String[] L = new String[H];\n            String[] R = new String[H];\n            int lh = -1, lw = -1, rh = -1, rw = -1;\n            int glh = -1, glw = -1, grh = -1, grw = -1;\n            for (int i = 0; i < H; ++i) {\n                L[i] = in.next();\n                R[i] = in.next();\n                for (int j = 0; j < W; ++j) {\n                    if (L[i].charAt(j) == 'L') {\n                        lh = i;\n                        lw = j;\n                    }\n                    if (R[i].charAt(j) == 'R') {\n                        rh = i;\n                        rw = j;\n                    }\n                    if (L[i].charAt(j) == '%') {\n                        glh = i;\n                        glw = j;\n                    }\n                    if (R[i].charAt(j) == '%') {\n                        grh = i;\n                        grw = j;\n                    }\n                }\n            }\n            boolean[][][][] vis = new boolean[H][W][H][W];\n            for (int i = 0; i < H; ++i) {\n                for (int j = 0; j < W; ++j) {\n                    for (int k = 0; k < H; ++k) {\n                        Arrays.fill(vis[i][j][k], false);\n                    }\n                }\n            }\n            Queue<State> q = new ArrayDeque<>();\n            q.add(new State(lh, lw, rh, rw));\n            while (!q.isEmpty()) {\n                State now = q.poll();\n                if (vis[now.lh][now.lw][now.rh][now.rw]) {\n                    continue;\n                }\n                vis[now.lh][now.lw][now.rh][now.rw] = true;\n                if (now.lh == glh && now.rh == grh && now.lw == glw && now.rw == grw) {\n                    out.println(\"Yes\");\n                    return;\n                }\n                for (int i = 0; i < 4; ++i) {\n                    State next = new State(now.lh + dh[i], now.lw + dw[i], now.rh + dh2[i], now.rw + dw2[i]);\n                    if (0 <= next.lh && next.lh < H && 0 <= next.lw && next.lw < W && 0 <= next.rh && next.rh < H && 0 <= next.rw && next.rw < W) {\n                        if (L[next.lh].charAt(next.lw) == '#') {\n                            if (next.lh != now.lh) {\n                                next.lh = now.lh;\n                            }\n                            if (next.lw != now.lw) {\n                                next.lw = now.lw;\n                            }\n                        }\n                        if (R[next.rh].charAt(next.rw) == '#') {\n                            if (next.rh != now.rh) {\n                                next.rh = now.rh;\n                            }\n                            if (next.rw != now.rw) {\n                                next.rw = now.rw;\n                            }\n                        }\n                        if (vis[next.lh][next.lw][next.rh][next.rw]) {\n                            continue;\n                        }\n                        q.add(next);\n                    }\n                }\n            }\n            out.println(\"No\");\n            return;\n        }\n\n        public class State {\n            int lh;\n            int lw;\n            int rh;\n            int rw;\n\n            State(int lh, int lw, int rh, int rw) {\n                this.lh = lh;\n                this.lw = lw;\n                this.rh = rh;\n                this.rw = rw;\n            }\n\n        }\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Scanner;\nimport java.util.Queue;\nimport java.util.ArrayDeque;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        MirrorCave solver = new MirrorCave();\n        try {\n            int testNumber = 1;\n            while (true)\n                solver.solve(testNumber++, in, out);\n        } catch (UnknownError e) {\n            out.close();\n        }\n    }\n\n    static class MirrorCave {\n        final int[] dh = new int[]{0, -1, 0, 1};\n        final int[] dw = new int[]{-1, 0, 1, 0};\n        final int[] dh2 = new int[]{0, -1, 0, 1};\n        final int[] dw2 = new int[]{1, 0, -1, 0};\n\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int W = in.nextInt();\n            int H = in.nextInt();\n            if (W == 0) {\n                throw new UnknownError();\n            }\n            String[] L = new String[H + 2];\n            String[] R = new String[H + 2];\n            L[0] = R[0] = L[H + 1] = R[H + 1] = new String();\n            for (int i = 0; i < W + 2; ++i) {\n                L[0] += \"#\";\n                R[0] += \"#\";\n                R[H + 1] += \"#\";\n                L[H + 1] += \"#\";\n            }\n            int lh = -1, lw = -1, rh = -1, rw = -1;\n            int glh = -1, glw = -1, grh = -1, grw = -1;\n            for (int i = 0; i < H; ++i) {\n                L[i + 1] = \"#\" + in.next() + \"#\";\n                R[i + 1] = \"#\" + in.next() + \"#\";\n                for (int j = 0; j < L[i + 1].length(); ++j) {\n                    if (L[i + 1].charAt(j) == 'L') {\n                        lh = i + 1;\n                        lw = j;\n                    }\n                    if (R[i + 1].charAt(j) == 'R') {\n                        rh = i + 1;\n                        rw = j;\n                    }\n                    if (L[i + 1].charAt(j) == '%') {\n                        glh = i + 1;\n                        glw = j;\n                    }\n                    if (R[i + 1].charAt(j) == '%') {\n                        grh = i + 1;\n                        grw = j;\n                    }\n                }\n            }\n            boolean[][][][] vis = new boolean[H + 2][W + 2][H + 2][W + 2];\n            for (int i = 0; i < vis.length; ++i) {\n                for (int j = 0; j < vis[i].length; ++j) {\n                    for (int k = 0; k < vis[i][j].length; ++k) {\n                        Arrays.fill(vis[i][j][k], false);\n                    }\n                }\n            }\n            Queue<State> q = new ArrayDeque<>();\n            q.add(new State(lh, lw, rh, rw));\n            //for (String e : L) System.err.println(e);\n            //for (String e : R) System.err.println(e);\n            vis[lh][lw][rh][rw] = true;\n            while (!q.isEmpty()) {\n                State now = q.poll();\n                if ((now.lh == glh && now.lw == glw) ^ (now.rh == grh && now.rw == grw)) {\n                    continue;\n                }\n                if (now.lh == glh && now.rh == grh && now.lw == glw && now.rw == grw) {\n                    out.println(\"Yes\");\n                    return;\n                }\n\n                for (int i = 0; i < 4; ++i) {\n                    State next = new State(now.lh + dh[i], now.lw + dw[i], now.rh + dh2[i], now.rw + dw2[i]);\n                    if (L[next.lh].charAt(next.lw) == '#' && R[next.rh].charAt(next.rw) == '#') {\n                        continue;\n                    } else if (L[next.lh].charAt(next.lw) == '#') {\n                        next.lh = now.lh;\n                        next.lw = now.lw;\n                    } else if (R[next.rh].charAt(next.rw) == '#') {\n                        next.rh = now.rh;\n                        next.rw = now.rw;\n                    }\n                    if (!vis[next.lh][next.lw][next.rh][next.rw]) {\n                        vis[next.lh][next.lw][next.rh][next.rw] = true;\n                        q.add(next);\n                    }\n                }\n            }\n            out.println(\"No\");\n            return;\n        }\n\n        public class State {\n            int lh;\n            int lw;\n            int rh;\n            int rw;\n\n            State(int lh, int lw, int rh, int rw) {\n                this.lh = lh;\n                this.lw = lw;\n                this.rh = rh;\n                this.rw = rw;\n            }\n\n        }\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nimport javax.xml.crypto.Data;\npublic class Main{\n\tstatic int INF = 2 << 28;\n\tstatic int[] vxL = {0,0,1,-1};\n\tstatic int[] vxR = {0,0,-1,1};\n\tstatic int[] vyL = {1,-1,0,0};\n\tstatic int[] vyR = {1,-1,0,0};\n\tstatic int w;\n\tstatic int h;\n\tstatic int Lx;\n\tstatic int Ly;\n\tstatic int Rx;\n\tstatic int Ry;\n\tstatic char[][] mapL;\n\tstatic char[][] mapR;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif(w == 0 && h == 0) break;\n\t\t\tmapL = new char[h][];\n\t\t\tmapR = new char[h][];\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tmapL[i] = sc.next().toCharArray();\n\t\t\t\tmapR[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tLx = 0;\n\t\t\tLy = 0;\n\t\t\tRx = 0;\n\t\t\tRy = 0;\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(mapL[i][j] == 'L') {\n\t\t\t\t\t\tLy = i;\n\t\t\t\t\t\tLx = j;\n\t\t\t\t\t\tmapL[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t\tif(mapR[i][j] == 'R') {\n\t\t\t\t\t\tRy = i;\n\t\t\t\t\t\tRx = j;\n\t\t\t\t\t\tmapR[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean ans = BFS();\n\t\t\tif(ans) {\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t\tSystem.gc();\n\t\t}\n\t}\t\n\tstatic boolean BFS() {\n\t\tboolean[][][][] use = new boolean[w][h][w][h];\n\t\tArrayDeque<Data> queue = new ArrayDeque<Data>();\n\t\tqueue.add(new Data(Lx,Ly,Rx,Ry));\n\t\twhile(!queue.isEmpty()) {\n\t\t\tData tmp = queue.poll();\n\t\t\tif(use[tmp.Lx][tmp.Ly][tmp.Rx][tmp.Ry]) continue;\n\t\t\tuse[tmp.Lx][tmp.Ly][tmp.Rx][tmp.Ry] = true;\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\t\n\t\t\t\tint Ltx = tmp.Lx + vxL[i];\n\t\t\t\tint Lty = tmp.Ly + vyL[i];\n\t\t\t\tint Rtx = tmp.Rx + vxR[i];\n\t\t\t\tint Rty = tmp.Ry + vyR[i];\n\t\t\t\t\n\t\t\t\tint  L = Rcheck(Ltx,Lty,mapL);\n\t\t\t\tint  R = Rcheck(Rtx,Rty,mapR);\n\t\t\t\t\n\t\t\t\tif(L == 2 && R == 2) return true;\n\t\t\t\tif(L == 2 && R != 2) continue;\n\t\t\t\tif(L != 2 && R == 2) continue;\n\t\t\t\tif(L == 0 && R == 0) continue;\n\t\t\t\tif(L == 0) {\n\t\t\t\t\tLtx = tmp.Lx;\n\t\t\t\t\tLty = tmp.Ly;\n\t\t\t\t}\n\t\t\t\tif(R == 0) {\n\t\t\t\t\tRtx = tmp.Rx;\n\t\t\t\t\tRty = tmp.Ry;\n\t\t\t\t}\n\t\t\t\tqueue.addLast(new Data(Ltx,Lty,Rtx,Rty));\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t\t\n\t}\n\tstatic int Rcheck(int x,int y,char[][] map) {\n\t\tif(x < 0 || y < 0 || x >= w || y >= h) return 0;\n\t\tif(map[y][x] == '#') return 0;\n\t\tif(map[y][x] == '.') return 1;\n\t\tif(map[y][x] == '%') return 2;\n\t\treturn -1;\n\t}\n\t\n\tstatic class Data {\n\t\tint Lx;\n\t\tint Ly;\n\t\tint Rx;\n\t\tint Ry;\n\t\tData(int a, int b, int c, int d) {\n\t\t\tLx = a;\n\t\t\tLy = b;\n\t\t\tRx = c;\n\t\t\tRy = d;\n\t\t}\n\t\tpublic boolean equals(Object o) {\n\t\t\tData c = (Data)o;\n\t\t\tif(this.Lx != c.Lx) return false;\n\t\t\tif(this.Ly != c.Ly) return false;\n\t\t\tif(this.Rx != c.Rx) return false;\n\t\t\tif(this.Ry != c.Ry) return false;\n\t\t\treturn true;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic int W,H;\n\t\t\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\t\twhile(true){\n\t\t\tW = in.nextInt();\n\t\t\tH = in.nextInt();\n\t\t\tif(W==0&&H==0) break;\n\t\t\tString[] left = new String[H];\n\t\t\tString[] right = new String[H];\n\t\t\tint goal = 0;\n\t\t\tint start = 0;\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tleft[i] = in.next();\n\t\t\t\tright[i] = in.next();\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tif(left[i].charAt(j)=='%'){\n\t\t\t\t\t\tgoal += (100*j + i)*10000;\n\t\t\t\t\t}else if(left[i].charAt(j)=='L'){\n\t\t\t\t\t\tstart += (100*j + i)*10000;\n\t\t\t\t\t}\n\t\t\t\t\tif(right[i].charAt(j)=='%'){\n\t\t\t\t\t\tgoal += 100*j + i;\n\t\t\t\t\t}else if(right[i].charAt(j)=='R'){\n\t\t\t\t\t\tstart += 100*j + i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean[] pos = new boolean[100000000];\n\t\t\tLinkedList<Integer> stack = new LinkedList<>();\n\t\t\tstack.push(start);\n\t\t\tpos[start] = true;\n\t\t\tString ans = \"No\";\n\t\t\twhile(!stack.isEmpty()){\n\t\t\t\tint now = stack.pop();\n\t\t\t\t//UP\n\t\t\t\tint up = now;\n\t\t\t\tif(!isWall(getLx(now),getLy(now)-1,left)){\n\t\t\t\t\tup -= 10000;\n\t\t\t\t}\n\t\t\t\tif(!isWall(getRx(now),getRy(now)-1,right)){\n\t\t\t\t\tup -= 1;\n\t\t\t\t}\n\t\t\t\tif(up==goal){\n\t\t\t\t\tans = \"Yes\"; break;\n\t\t\t\t}\n\t\t\t\tif(!pos[up]){\n\t\t\t\t\tstack.add(up); pos[up] = true;\n\t\t\t\t}\n\t\t\t\t//DOWN\n\t\t\t\tint down = now;\n\t\t\t\tif(!isWall(getLx(now),getLy(now)+1,left)){\n\t\t\t\t\tdown += 10000;\n\t\t\t\t}\n\t\t\t\tif(!isWall(getRx(now),getRy(now)+1,right)){\n\t\t\t\t\tdown += 1;\n\t\t\t\t}\n\t\t\t\tif(down==goal){\n\t\t\t\t\tans = \"Yes\"; break;\n\t\t\t\t}\n\t\t\t\tif(!pos[down]){\n\t\t\t\t\tstack.add(down); pos[down] = true;\n\t\t\t\t}\n\t\t\t\t//into\n\t\t\t\tint into = now;\n\t\t\t\tif(!isWall(getLx(now)+1,getLy(now),left)){\n\t\t\t\t\tinto += 1000000;\n\t\t\t\t}\n\t\t\t\tif(!isWall(getRx(now)-1,getRy(now),right)){\n\t\t\t\t\tinto -= 100;\n\t\t\t\t}\n\t\t\t\tif(into==goal){\n\t\t\t\t\tans = \"Yes\"; break;\n\t\t\t\t}\n\t\t\t\tif(!pos[into]){\n\t\t\t\t\tstack.add(into); pos[into] = true;\n\t\t\t\t}\n\t\t\t\t//out\n\t\t\t\tint out = now;\n\t\t\t\tif(!isWall(getLx(now)-1,getLy(now),left)){\n\t\t\t\t\tout -= 1000000;\n\t\t\t\t}\n\t\t\t\tif(!isWall(getRx(now)+1,getRy(now),right)){\n\t\t\t\t\tout += 100;\n\t\t\t\t}\n\t\t\t\tif(out==goal){\n\t\t\t\t\tans = \"Yes\"; break;\n\t\t\t\t}\n\t\t\t\tif(!pos[out]){\n\t\t\t\t\tstack.add(out); pos[out] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\tSystem.gc();\n\t\t}\t\n\t}\n\t\n\tpublic static int getLx(int pos){\n\t\treturn pos/1000000;\n\t}\n\tpublic static int getLy(int pos){\n\t\treturn pos/10000 %100;\n\t}\n\tpublic static int getRx(int pos){\n\t\treturn pos/100 % 100;\n\t}\n\tpublic static int getRy(int pos){\n\t\treturn pos%100;\n\t}\n\tpublic static boolean isWall(int x,int y,String[] map){\n\t\treturn x<0 || x>=W || y<0 || y>=H || map[y].charAt(x) == '#';\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[][] field1,field2;\n\tstatic byte[][][][] dp;\n\tstatic int sXL,sXR,sYL,sYR;\n\tstatic boolean ans;\n\tstatic int[] v1={0,1,0,-1};\n\tstatic int[] v2={1,0,-1,0};\n\tstatic int w,h;\n\tpublic static void main(String[] args) {\n\t\tScanner cin=new Scanner(System.in);\n\t\twhile(true){\n\n\t\t\tw=cin.nextInt();\n\t\t\th=cin.nextInt();\n\t\t\tif(w+h==0){\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\tans=false;\n\t\t\tfield1=new int[h][w];\n\t\t\tfield2=new int[h][w];\n\t\t\tdp=new byte[h][w][h][w];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<2;j++){\n\t\t\t\t\tString s=cin.next();\n\t\t\t\t\tint[][] a;\n\t\t\t\t\tif(j==0){\n\t\t\t\t\t\ta=field1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\ta=field2;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<s.length();k++){\n\t\t\t\t\t\tint b=0;\n\t\t\t\t\t\tif(s.charAt(k)=='%'){\n\t\t\t\t\t\t\tb=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(s.charAt(k)=='#'){\n\t\t\t\t\t\t\tb=-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(s.charAt(k)=='L'){\n\t\t\t\t\t\t\tsXL=i;\n\t\t\t\t\t\t\tsYL=k;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(s.charAt(k)=='R'){\n\t\t\t\t\t\t\tsXR=i;\n\t\t\t\t\t\t\tsYR=k;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ta[i][k]=b;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQueue<byte[]> q=new LinkedList<byte[]>();\n\t\t\tq.add(new byte[]{(byte) sXL,(byte) sYL,(byte) sXR,(byte) sYR});\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tbyte[] poll=q.poll();\n\t\t\t\tint a=poll[0];\n\t\t\t\tint b=poll[1];\n\t\t\t\tint c=poll[2];\n\t\t\t\tint d=poll[3];\n\t\t\t\tif(dp[a][b][c][d]==1||ans){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdp[a][b][c][d]=1;\n\t\t\t\tif(field1[a][b]==1&&field2[c][d]==1){\n\t\t\t\t\tans=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(field1[a][b]==1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(field2[c][d]==1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint aa=a+v1[i];\n\t\t\t\t\tint bb=b+v2[i];\n\t\t\t\t\tint cc=c+v1[i];\n\t\t\t\t\tint dd=d+-v2[i];\n//\t\t\t\t\tSystem.out.println(aa+\" \"+bb+\" \"+cc+\" \"+dd+\" \"+i);\n\t\t\t\t\tif(aa<0||aa>=h){\n\t\t\t\t\t\taa-=v1[i];\n\t\t\t\t\t}\n\t\t\t\t\tif(bb<0||bb>=w){\n\t\t\t\t\t\tbb-=v2[i];\n\t\t\t\t\t}\n\t\t\t\t\tif(cc<0||cc>=h){\n\t\t\t\t\t\tcc-=v1[i];\n\t\t\t\t\t}\n\t\t\t\t\tif(dd<0||dd>=w){\n\t\t\t\t\t\tdd-=-v2[i];\n\t\t\t\t\t}\n//\t\t\t\t\tSystem.out.println(aa+\" \"+bb+\" \"+cc+\" \"+dd+\" \"+i);\n\t\t\t\t\tif(field1[aa][bb]==-1){\n\t\t\t\t\t\taa-=v1[i];\n\t\t\t\t\t\tbb-=v2[i];\n\t\t\t\t\t}\n\t\t\t\t\tif(field2[cc][dd]==-1){\n\t\t\t\t\t\tcc-=v1[i];\n\t\t\t\t\t\tdd-=-v2[i];\n\t\t\t\t\t}\n\t\t\t\t\tif(dp[aa][bb][cc][dd]==1)continue;\n\t\t\t\t\tq.add(new byte[]{(byte)aa,(byte)bb,(byte)cc,(byte)dd});\n\t\t\t\t}\n\n\t\t\t}\n//\t\t\tbt(sXL,sYL,sXR,sYR);\n\t\t\tif(ans){\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t}\n\tstatic void bt(int a,int b,int c,int d){\n//\t\tif(dp[a][b][c][d]||ans){\n//\t\t\treturn ;\n//\t\t}\n//\t\tdp[a][b][c][d]=true;\n\t\tif(field1[a][b]==1&&field2[c][d]==1){\n\t\t\tans=true;\n\t\t}\n\t\tif(field1[a][b]==1){\n\t\t\treturn;\n\t\t}\n\t\tif(field2[c][d]==1){\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint aa=a+v1[i];\n\t\t\tint bb=b+v2[i];\n\t\t\tint cc=c+v1[i];\n\t\t\tint dd=d+-v2[i];\n//\t\t\tSystem.out.println(aa+\" \"+bb+\" \"+cc+\" \"+dd+\" \"+i);\n\t\t\tif(aa<0||aa>=h){\n\t\t\t\taa-=v1[i];\n\t\t\t}\n\t\t\tif(bb<0||bb>=w){\n\t\t\t\tbb-=v2[i];\n\t\t\t}\n\t\t\tif(cc<0||cc>=h){\n\t\t\t\tcc-=v1[i];\n\t\t\t}\n\t\t\tif(dd<0||dd>=w){\n\t\t\t\tdd-=-v2[i];\n\t\t\t}\n//\t\t\tSystem.out.println(aa+\" \"+bb+\" \"+cc+\" \"+dd+\" \"+i);\n\t\t\tif(field1[aa][bb]==-1){\n\t\t\t\taa-=v1[i];\n\t\t\t\tbb-=v2[i];\n\t\t\t}\n\t\t\tif(field2[cc][dd]==-1){\n\t\t\t\tcc-=v1[i];\n\t\t\t\tdd-=-v2[i];\n\t\t\t}\n\t\t\tbt(aa,bb,cc,dd);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.System.*;\n\nimport java.lang.reflect.Array;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Queue;\nimport java.util.Random;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static Random rand=new Random();\n\n\tclass Pos{\n\t\tint lx,ly,rx,ry;\n\t\tpublic Pos(int _lx,int _ly,int _rx,int _ry) {\n\t\t\tlx=_lx;ly=_ly;rx=_rx;ry=_ry;\n\t\t}\n\t}\n\n\tint[] dx1=new int[]{1,0,-1,0};\n\tint[] dy1=new int[]{0,1,0,-1};\n\tint[] dx2=new int[]{-1,0,1,0};\n\tint[] dy2=new int[]{0,1,0,-1};\n\n\n\tpublic void run() {\n\t\tCase:while(true){\n\t\t\tint W=sc.nextInt(),H=sc.nextInt();\n\t\t\tif(W==0 && H==0)return;\n\t\t\tchar[][] map1=new char[H][W],map2=new char[H][W];\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tmap1[i]=sc.next().toCharArray();\n\t\t\t\tmap2[i]=sc.next().toCharArray();\n\t\t\t}\n\n\t\t\tboolean[][][][] passed=new boolean[H][W][H][W];\n\n\t\t\tint lx=-1,ly=-1,rx=-1,ry=-1;\n\t\t\tfor(int h=0;h<H;h++)for(int w=0;w<W;w++){\n\t\t\t\tif(map1[h][w]=='L'){\n\t\t\t\t\tlx=w;ly=h;\n\t\t\t\t}\n\t\t\t\tif(map2[h][w]=='R'){\n\t\t\t\t\trx=w;ry=h;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tQueue<Pos> que=new LinkedList<Pos>();\n\t\t\tque.add(new Pos(lx, ly, rx, ry));\n\t\t\tpassed[ly][lx][ry][rx]=true;\n\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tPos p=que.poll();\n\t\t\t\t//4方向\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint nx1=p.lx+dx1[i],ny1=p.ly+dy1[i];\n\t\t\t\t\tint nx2=p.rx+dx2[i],ny2=p.ry+dy2[i];\n\t\t\t\t\tif(!(0<=nx1 && nx1 <W &&0<=ny1 && ny1<H)){\n\t\t\t\t\t\tnx1=p.lx;ny1=p.ly;\n\t\t\t\t\t}\n\t\t\t\t\tif(!(0<=nx2 && nx2<W &&0<=ny2 && ny2<H)){\n\t\t\t\t\t\tnx2=p.rx;ny2=p.ry;\n\t\t\t\t\t}\n\t\t\t\t\tif(map1[ny1][nx1]=='#'){\n\t\t\t\t\t\tnx1=p.lx;ny1=p.ly;\n\t\t\t\t\t}\n\t\t\t\t\tif(map2[ny2][nx2]=='#'){\n\t\t\t\t\t\tnx2=p.rx;ny2=p.ry;\n\t\t\t\t\t}\n\t\t\t\t\tif(map1[ny1][nx1]=='%' && map2[ny2][nx2]=='%'){\n\t\t\t\t\t\tln(str(true));continue Case;\n\t\t\t\t\t}else if(map1[ny1][nx1]=='%' || map2[ny2][nx2]=='%'){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(!passed[ny1][nx1][ny2][nx2]){\n\t\t\t\t\t\tque.add(new Pos(nx1,ny1,nx2,ny2));\n\t\t\t\t\t\tpassed[ny1][nx1][ny2][nx2]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tln(str(false));\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tstatic Scanner sc=new Scanner(in);\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(boolean o){\n\t\treturn o?\"Yes\":\"No\";\n\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\t//depth ex A[10]…1 A[10][10]…2 exception A[0]…0 A[10][0]…1 A[0][0]…0\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic int W,H;\n\t\t\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\tloop : while(true){\n\t\t\tSystem.gc();\n\t\t\tW = in.nextInt();\n\t\t\tH = in.nextInt();\n\t\t\tif(W==0&&H==0) break;\n\t\t\tString[] left = new String[H];\n\t\t\tString[] right = new String[H];\n\t\t\tint goal = 0;\n\t\t\tint start = 0;\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tleft[i] = in.next();\n\t\t\t\tright[i] = in.next();\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tif(left[i].charAt(j)=='%'){\n\t\t\t\t\t\tgoal += (100*j + i)*10000;\n\t\t\t\t\t}else if(left[i].charAt(j)=='L'){\n\t\t\t\t\t\tstart += (100*j + i)*10000;\n\t\t\t\t\t}\n\t\t\t\t\tif(right[i].charAt(j)=='%'){\n\t\t\t\t\t\tgoal += 100*j + i;\n\t\t\t\t\t}else if(right[i].charAt(j)=='R'){\n\t\t\t\t\t\tstart += 100*j + i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean[] pos = new boolean[100000000];\n\t\t\tLinkedList<Integer> stack = new LinkedList<>();\n\t\t\tstack.push(start);\n\t\t\tpos[start] = true;\n\t\t\twhile(!stack.isEmpty()){\n\t\t\t\tint now = stack.pop();\n\t\t\t\t//UP\n\t\t\t\tint up = now;\n\t\t\t\tif(!isWall(getLx(now),getLy(now)-1,left)){\n\t\t\t\t\tup -= 10000;\n\t\t\t\t}\n\t\t\t\tif(!isWall(getRx(now),getRy(now)-1,right)){\n\t\t\t\t\tup -= 1;\n\t\t\t\t}\n\t\t\t\tif(up==goal){\n\t\t\t\t\tSystem.out.println(\"YES\"); continue loop;\n\t\t\t\t}\n\t\t\t\tif(!pos[up]){\n\t\t\t\t\tstack.add(up); pos[up] = true;\n\t\t\t\t}\n\t\t\t\t//DOWN\n\t\t\t\tint down = now;\n\t\t\t\tif(!isWall(getLx(now),getLy(now)+1,left)){\n\t\t\t\t\tdown += 10000;\n\t\t\t\t}\n\t\t\t\tif(!isWall(getRx(now),getRy(now)+1,right)){\n\t\t\t\t\tdown += 1;\n\t\t\t\t}\n\t\t\t\tif(down==goal){\n\t\t\t\t\tSystem.out.println(\"YES\"); continue loop;\n\t\t\t\t}\n\t\t\t\tif(!pos[down]){\n\t\t\t\t\tstack.add(down); pos[down] = true;\n\t\t\t\t}\n\t\t\t\t//into\n\t\t\t\tint into = now;\n\t\t\t\tif(!isWall(getLx(now)+1,getLy(now),left)){\n\t\t\t\t\tinto += 1000000;\n\t\t\t\t}\n\t\t\t\tif(!isWall(getRx(now)-1,getRy(now),right)){\n\t\t\t\t\tinto -= 100;\n\t\t\t\t}\n\t\t\t\tif(into==goal){\n\t\t\t\t\tSystem.out.println(\"YES\"); continue loop;\n\t\t\t\t}\n\t\t\t\tif(!pos[into]){\n\t\t\t\t\tstack.add(into); pos[into] = true;\n\t\t\t\t}\n\t\t\t\t//out\n\t\t\t\tint out = now;\n\t\t\t\tif(!isWall(getLx(now)-1,getLy(now),left)){\n\t\t\t\t\tout -= 1000000;\n\t\t\t\t}\n\t\t\t\tif(!isWall(getRx(now)+1,getRy(now),right)){\n\t\t\t\t\tout += 100;\n\t\t\t\t}\n\t\t\t\tif(out==goal){\n\t\t\t\t\tSystem.out.println(\"Yes\"); continue loop;\n\t\t\t\t}\n\t\t\t\tif(!pos[out]){\n\t\t\t\t\tstack.add(out); pos[out] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(\"No\");\n\t\t}\t\n\t}\n\t\n\tpublic static int getLx(int pos){\n\t\treturn pos/1000000;\n\t}\n\tpublic static int getLy(int pos){\n\t\treturn pos/10000 %100;\n\t}\n\tpublic static int getRx(int pos){\n\t\treturn pos/100 % 100;\n\t}\n\tpublic static int getRy(int pos){\n\t\treturn pos%100;\n\t}\n\tpublic static boolean isWall(int x,int y,String[] map){\n\t\treturn x<0 || x>=W || y<0 || y>=H || map[y].charAt(x) == '#';\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(in);\n\t\n\tvoid run() {\n\t\tboolean[][] rooml = new boolean[50][50];\n\t\tboolean[][] roomr = new boolean[50][50];\n\t\tboolean[][][][] used = new boolean[50][50][50][50]; \n\t\tbyte dlx, dly, drx, dry, lx, ly, rx, ry;\n\t\tdlx = dly = drx = dry = lx = ly = rx = ry = 0;\n\t\tQueue<Byte> quelx = new LinkedList<Byte>();\n\t\tQueue<Byte> quely = new LinkedList<Byte>();\n\t\tQueue<Byte> querx = new LinkedList<Byte>();\n\t\tQueue<Byte> query = new LinkedList<Byte>();\n\t\tbyte[] dilx = {1, -1, 0, 0};\n\t\tbyte[] dily = {0, 0, 1, -1};\n\t\tbyte[] dirx = {1, -1, 0, 0};\n\t\tbyte[] diry = {0, 0, -1, 1};\n\t\twhile (true) {\n\t\t\tbyte w = sc.nextByte(), h = sc.nextByte();\n\t\t\tif (w == 0 && h == 0) break;\n\t\t\tfor (byte i = 0; i < h; i++) {\n\t\t\t\tString l = sc.next(), r = sc.next();\n\t\t\t\tfor (byte j = 0; j < w; j++) {\n\t\t\t\t\tswitch (l.charAt(j)) {\n\t\t\t\t\tcase '.': rooml[i][j] = true; break;\n\t\t\t\t\tcase '#': rooml[i][j] = false; break;\n\t\t\t\t\tcase '%': \n\t\t\t\t\t\trooml[i][j] = true;\n\t\t\t\t\t\tdlx = i; dly = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\trooml[i][j] = true;\n\t\t\t\t\t\tlx = i;\n\t\t\t\t\t\tly = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tswitch (r.charAt(j)) {\n\t\t\t\t\tcase '.': roomr[i][j] = true; break;\n\t\t\t\t\tcase '#': roomr[i][j] = false; break;\n\t\t\t\t\tcase '%': \n\t\t\t\t\t\troomr[i][j] = true;\n\t\t\t\t\t\tdrx = i; dry = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'R':\n\t\t\t\t\t\troomr[i][j] = true;\n\t\t\t\t\t\trx = i;\n\t\t\t\t\t\try = j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tquelx.clear(); quely.clear();\n\t\t\tquerx.clear(); query.clear();\n\t\t\tfor (int i = 0; i < 50; i++)\n\t\t\t\tfor (int j = 0; j < 50; j++)\n\t\t\t\t\tfor (int k = 0; k < 50; k++)\n\t\t\t\t\t\tArrays.fill(used[i][j][k], false);\n\t\t\tquelx.add(lx); quely.add(ly);\n\t\t\tquerx.add(rx); query.add(ry);\n\t\t\tused[lx][ly][rx][ry] = true;\n\t\t\tboolean flag = false;\n\t\t\twhile (!quelx.isEmpty()) {\n\t\t\t\tbyte telx = quelx.poll(), tely = quely.poll();\n\t\t\t\tbyte terx = querx.poll(), tery = query.poll();\n\t\t\t\tif (telx == dlx && tely == dly && terx == drx && tery == dry) {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (telx == dlx && tely == dly && !(terx == drx && tery == dry)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!(telx == dlx && tely == dly) && terx == drx && tery == dry) continue;\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tbyte lX = (byte) (telx + dilx[i]), lY = (byte) (tely + dily[i]);\n\t\t\t\t\tbyte rX = (byte) (terx + dirx[i]), rY = (byte) (tery + diry[i]);\n\t\t\t\t\tif (!(0 <= lX && lX < h && 0 <= lY && lY < w && rooml[lX][lY])) {\n\t\t\t\t\t\tlX = telx;\n\t\t\t\t\t\tlY = tely;\n\t\t\t\t\t}\n\t\t\t\t\tif (!(0 <= rX && rX < h && 0 <= rY && rY < w && roomr[rX][rY])) {\n\t\t\t\t\t\trX = terx;\n\t\t\t\t\t\trY = tery;\n\t\t\t\t\t}\n\t\t\t\t\tif (!used[lX][lY][rX][rY]) {\n\t\t\t\t\t\tused[lX][lY][rX][rY] = true;\n\t\t\t\t\t\tquelx.add(lX); quely.add(lY);\n\t\t\t\t\t\tquerx.add(rX); query.add(rY);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (flag)\n\t\t\t\tout.println(\"Yes\");\n\t\t\telse\n\t\t\t\tout.println(\"No\");\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\tpublic void run() {\n\t\twhile(sc.hasNext()){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif(w == 0 && h == 0)break;\n\t\t\telse calc(w, h);\n\t\t\t\n\t\t}\n\t}\n\tpublic void calc(int w, int h){\n\t\tString[][] roomR = new String[w][h];\n\t\tString[][] roomL = new String[w][h];\n\t\tint xR = 0;\n\t\tint yR = 0;\n\t\tint xL = 0;\n\t\tint yL = 0;\n\t\tfor(int j = 0; j < h; j++){\n\t\t\tString l = sc.next();\n\t\t\tString r = sc.next();\n\t\t\tfor(int i = 0; i < w; i++){\n\t\t\t\troomR[i][j] = r.substring(i, i+1);\n\t\t\t\troomL[i][j] = l.substring(i, i+1);\n\t\t\t\tif(roomR[i][j].equals(\"R\")){\n\t\t\t\t\txR = i; yR = j;\n\t\t\t\t}\n\t\t\t\tif(roomL[i][j].equals(\"L\")){\n\t\t\t\t\txL = i; yL = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint[] moveXR = {0, -1, 0, 1};\n\t\tint[] moveY = {-1, 0, 1, 0};\n\t\tint[] moveXL = {0, 1, 0, -1};\n\t\t\n\t\tint[][][][] memo = new int[w][h][w][h];\n\t\tmemo[xR][yR][xL][yL] = 1;\n\t\t\n\t\tArrayList<int[]> list = new ArrayList<int[]>();\n\t\tlist.add(new int[]{xR, yR, xL, yL});\n\t\t\n\t\tboolean ans = false;\n\t\t\n\t\twhile(list.size() != 0){\n\t\t\tint[] now = list.get(0);\n\t\t\tlist.remove(0);\n\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\tint nXR = now[0] + moveXR[k];\n\t\t\t\tint nYR = now[1] + moveY[k];\n\t\t\t\tint nXL = now[2] + moveXL[k];\n\t\t\t\tint nYL = now[3] + moveY[k];\n\t\t\t\tif(nXR < 0) nXR = 0;\n\t\t\t\tif(nXR >= w) nXR = w - 1;\n\t\t\t\tif(nYR < 0) nYR = 0;\n\t\t\t\tif(nYR >= h) nYR = h - 1;\n\t\t\t\tif(nXL < 0) nXL = 0;\n\t\t\t\tif(nXL >= w) nXL = w - 1;\n\t\t\t\tif(nYL < 0) nYL = 0;\n\t\t\t\tif(nYL >= h) nYL = h - 1;\n\t\t\t\t\n\t\t\t\tboolean goalR = false;\n\t\t\t\tboolean goalL = false;\n\t\t\t\tif(roomR[nXR][nYR].equals(\"#\")){\n\t\t\t\t\tnXR = now[0]; nYR = now[1];\n\t\t\t\t}\n\t\t\t\telse if(roomR[nXR][nYR].equals(\"%\")){\n\t\t\t\t\tgoalR = true;\n\t\t\t\t}\n\t\t\t\tif(roomL[nXL][nYL].equals(\"#\")){\n\t\t\t\t\tnXL = now[2]; nYL = now[3];\n\t\t\t\t}\n\t\t\t\telse if(roomL[nXL][nYL].equals(\"%\")){\n\t\t\t\t\tgoalL = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(goalR && goalL){\n\t\t\t\t\tans = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if((!goalR && !goalL) && memo[nXR][nYR][nXL][nYL] != 1){\n\t\t\t\t\tmemo[nXR][nYR][nXL][nYL] = 1;\n\t\t\t\t\tlist.add(new int[]{nXR, nYR, nXL, nYL});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t}\n\t\telse{\n\t\t\tSystem.out.println(\"No\");\n\t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.BitSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static int w, h;\n\tpublic static char[][][] map = new char[50][50][2];\n\tpublic static final int[] dx = {1, 0, -1, 0};\n\tpublic static final int[] dy = {0, 1, 0, -1};\n\tpublic static int[] gx = new int[2];\n\tpublic static int[] gy = new int[2];\n\tpublic static int[] sx = new int[2];\n\tpublic static int[] sy = new int[2];\n\tpublic static BitSet used = new BitSet(50*50*50*50);\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = in.nextInt();\n\t\t\th = in.nextInt();\n\t\t\tif(w == 0) break;\n//\t\t\tmap = new char[2][h][w];\n\t\t\tfor(int j=0; j<h; j++){\n\t\t\t\tfor(int i=0; i<2; i++){\n\t\t\t\t\tmap[i][j] = in.next().toCharArray();\n\t\t\t\t\tfor(int k=0; k<w; k++){\n\t\t\t\t\t\tif(map[i][j][k] == '%'){\n\t\t\t\t\t\t\tgx[i] = k;\n\t\t\t\t\t\t\tgy[i] = j;\n\t\t\t\t\t\t}else if(map[i][j][k] == 'L' || map[i][j][k] == 'R'){\n\t\t\t\t\t\t\tsx[i] = k;\n\t\t\t\t\t\t\tsy[i] = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tused.clear();\n\t\t\tQueue<Integer> qu = new LinkedList<Integer>();\n\t\t\tqu.add(set(sy[0], sx[0], sy[1], sx[1]));\n\t\t\tused.set(id(qu.peek()));\n\t\t\tboolean goal = false;\n\t\t\twhile(!qu.isEmpty()){\n\t\t\t\tint p = qu.poll();\n\t\t\t\tint y1 = p>>18;\n\t\t\t\tint x1 = (p>>12)&mask;\n\t\t\t\tint y2 = (p>>6)&mask;\n\t\t\t\tint x2 = p&mask;\n\t\t\t\tif(goal(y1, x1, y2, x2)){\n\t\t\t\t\tgoal = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(oneGoal(y1, x1, y2, x2)) continue;\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tint np = move(y1, x1, y2, x2, i);\n\t\t\t\t\tint id = id(np);\n\t\t\t\t\tif(used.get(id)) continue;\n\t\t\t\t\tused.set(id);\n\t\t\t\t\tqu.add(np);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(goal?\"Yes\":\"No\");\n\t\t}\n\t}\n\t\n\tpublic static int set(int y1, int x1, int y2, int x2){\n\t\treturn y1<<(6+6+6) | x1<<(6+6) | y2<<6 | x2;\n\t}\n\t\n\tpublic static int move(int y1, int x1, int y2, int x2, int dir){\n\t\tint nx1 = x1+dx[dir];\n\t\tint ny1 = y1+dy[dir];\n\t\tif(out(ny1, nx1) || map[0][ny1][nx1] == '#'){\n\t\t\tnx1 = x1;\n\t\t\tny1 = y1;\n\t\t}\n\t\tint nx2 = x2-dx[dir];\n\t\tint ny2 = y2+dy[dir];\n\t\tif(out(ny2, nx2) || map[1][ny2][nx2] == '#'){\n\t\t\tnx2 = x2;\n\t\t\tny2 = y2;\n\t\t}\n\t\treturn set(ny1, nx1, ny2, nx2);\n\t}\n\t\n\tpublic static boolean out(int y, int x){\n\t\treturn x < 0 || x >= w || y < 0 || y >= h;\n\t}\n\t\n\tpublic static boolean goal(int y1, int x1, int y2, int x2){\n\t\treturn x1 == gx[0] && y1 == gy[0] && x2 == gx[1] && y2 == gy[1];\n\t}\n\t\n\tpublic static boolean oneGoal(int y1, int x1, int y2, int x2){\n\t\treturn x1 == gx[0] && y1 == gy[0] || x2 == gx[1] && y2 == gy[1];\n\t}\n\t\n\tpublic static int id(int y1, int x1, int y2, int x2){\n\t\treturn y1*h*w*w + x1*h*w + y2*w + x2;\n\t}\n\t\n\tpublic static final int mask = (1<<6)-1;\n\tpublic static int id(int hash){\n\t\treturn (hash>>18)*h*w*w + ((hash>>12)&mask)*h*w + ((hash>>6)&mask)*w + (hash&mask);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class Main {\n\tint w, h;\n\tchar[][] l, r;\n\tint[] ldx = { -1, 0, 0, 1 };\n\tint[] ldy = { 0, -1, 1, 0 };\n\tint[] rdx = { 1, 0, 0, -1 };\n\tint[] rdy = { 0, -1, 1, 0 };\n\tint slx, sly, srx, sry;\n\n\tboolean bfs() {\n\t\tQueue<Integer> lxque = new LinkedList<Integer>();\n\t\tQueue<Integer> lyque = new LinkedList<Integer>();\n\t\tQueue<Integer> rxque = new LinkedList<Integer>();\n\t\tQueue<Integer> ryque = new LinkedList<Integer>();\n\n\t\tlxque.add(slx);\n\t\tlyque.add(sly);\n\t\trxque.add(srx);\n\t\tryque.add(sry);\n\n\t\tboolean[][][][] vis = new boolean[w][h][w][h];\n\n\t\twhile (!lxque.isEmpty()) {\n\t\t\tint lx = lxque.poll();\n\t\t\tint ly = lyque.poll();\n\t\t\tint rx = rxque.poll();\n\t\t\tint ry = ryque.poll();\n\n\t\t\tif (vis[lx][ly][rx][ry]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvis[lx][ly][rx][ry] = true;\n\t\t\tif (l[ly][lx] == '%' && r[ry][rx] == '%') {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (l[ly][lx] == '%' || r[ry][rx] == '%') {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint nlx = lx + ldx[i];\n\t\t\t\tint nly = ly + ldy[i];\n\t\t\t\tint nrx = rx + rdx[i];\n\t\t\t\tint nry = ry + rdy[i];\n\n\t\t\t\tif (nlx < 0 || w <= nlx || nly < 0 || h <= nly || l[nly][nlx] == '#') {\n\t\t\t\t\tnlx -= ldx[i];\n\t\t\t\t\tnly -= ldy[i];\n\t\t\t\t}\n\t\t\t\tif (nrx < 0 || w <= nrx || nry < 0 || h <= nry || r[nry][nrx] == '#') {\n\t\t\t\t\tnrx -= rdx[i];\n\t\t\t\t\tnry -= rdy[i];\n\t\t\t\t}\n\t\t\t\tif (vis[nlx][nly][nrx][nry]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlxque.add(nlx);\n\t\t\t\tlyque.add(nly);\n\t\t\t\trxque.add(nrx);\n\t\t\t\tryque.add(nry);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\twhile (true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif ((w | h) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tl = new char[h][];\n\t\t\tr = new char[h][];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tl[i] = sc.next().toCharArray();\n\t\t\t\tr[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (l[i][j] == 'L') {\n\t\t\t\t\t\tslx = j;\n\t\t\t\t\t\tsly = i;\n\t\t\t\t\t\tl[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t\tif (r[i][j] == 'R') {\n\t\t\t\t\t\tsrx = j;\n\t\t\t\t\t\tsry = i;\n\t\t\t\t\t\tr[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(bfs() ? \"Yes\" : \"No\");\n\t\t\tSystem.gc();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.BitSet;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DY = { 1, 0, -1, 0 };\n\tstatic int[] DX = { 0, -1, 0, 1 };\n\tstatic int W, H;\n\tstatic char[][] mapL, mapR;\n\tstatic BitSet visited = new BitSet(1 << 24);\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tW = sc.nextInt();\n\t\t\tH = sc.nextInt();\n\t\t\tif (W == 0) break;\n\t\t\tmapL = new char[H][];\n\t\t\tmapR = new char[H][];\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tmapL[i] = sc.next().toCharArray();\n\t\t\t\tmapR[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tSystem.out.println(solve() ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\n\tstatic boolean solve() {\n\t\tvisited.clear();\n\t\tint pos = 0;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (mapL[i][j] == 'L') {\n\t\t\t\t\tpos |= (i << 18) | (j << 12);\n\t\t\t\t}\n\t\t\t\tif (mapR[i][j] == 'R') {\n\t\t\t\t\tpos |= (i << 6) | j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvisited.set(pos);\n\t\tQueue<Integer> q = new ArrayDeque<Integer>();\n\t\tq.add(pos);\n\t\twhile (!q.isEmpty()) {\n\t\t\tint p = q.poll();\n\t\t\tint y1 = p >> 18;\n\t\t\tint x1 = (p >> 12) & 0x3F;\n\t\t\tint y2 = (p >> 6) & 0x3F;\n\t\t\tint x2 = p & 0x3F;\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tint ny1 = y1 + DY[i];\n\t\t\t\tint nx1 = x1 + DX[i];\n\t\t\t\tint ny2 = y2 + DY[i];\n\t\t\t\tint nx2 = x2 - DX[i];\n\t\t\t\tif (ny1 < 0 || H <= ny1 || nx1 < 0 || W <= nx1 || mapL[ny1][nx1] == '#') {\n\t\t\t\t\tny1 = y1;\n\t\t\t\t\tnx1 = x1;\n\t\t\t\t}\n\t\t\t\tif (ny2 < 0 || H <= ny2 || nx2 < 0 || W <= nx2 || mapR[ny2][nx2] == '#') {\n\t\t\t\t\tny2 = y2;\n\t\t\t\t\tnx2 = x2;\n\t\t\t\t}\n\t\t\t\tboolean goalL = mapL[ny1][nx1] == '%';\n\t\t\t\tboolean goalR = mapR[ny2][nx2] == '%';\n\t\t\t\tif (goalL && goalR) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (!goalL && !goalR) {\n\t\t\t\t\tint np = (ny1 << 18) | (nx1 << 12) | (ny2 << 6) | nx2;\n\t\t\t\t\tif (!visited.get(np)) {\n\t\t\t\t\t\tvisited.set(np);\n\t\t\t\t\t\tq.add(np);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint m, n;\n\n\tint[][] al, ar;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tm=sc.nextInt();\n\t\t\tn=sc.nextInt();\n\t\t\tif((m|n)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tal=new int[n][m];\n\t\t\tar=new int[n][m];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tString sl=sc.next();\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\tal[j][i]=c2i(sl.charAt(i));\n\t\t\t\t}\n\t\t\t\tString sr=sc.next();\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\tar[j][i]=c2i(sr.charAt(i));\n\t\t\t\t}\n\t\t\t\t// debug(al[j], ar[j]);\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tboolean[][][][] visited=new boolean[50][50][50][50];\n\n\tvoid solve(){\n\t\tfor(int k=0; k<50; k++){\n\t\t\tfor(int j=0; j<50; j++){\n\t\t\t\tfor(int i=0; i<50; i++){\n\t\t\t\t\tfill(visited[k][j][i], false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// boolean[][][][] visited=new boolean[m][n][m][n];\n\t\t// HashSet<Integer> visited=new HashSet<Integer>();\n\t\tint xl0=0, yl0=0, xr0=0, yr0=0;\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tif(al[j][i]==-1){\n\t\t\t\t\txl0=i;\n\t\t\t\t\tyl0=j;\n\t\t\t\t\tal[j][i]=0;\n\t\t\t\t}\n\t\t\t\tif(ar[j][i]==-1){\n\t\t\t\t\txr0=i;\n\t\t\t\t\tyr0=j;\n\t\t\t\t\tar[j][i]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tLinkedList<Integer> que=new LinkedList<Integer>();\n\t\tque.offer(hash(xl0, yl0, xr0, yr0));\n\t\tint[] dxl={0, 0, -1, 1};\n\t\tint[] dyl={-1, 1, 0, 0};\n\t\tint[] dxr={0, 0, 1, -1};\n\t\tint[] dyr={-1, 1, 0, 0};\n\t\tboolean yes=false;\n\t\tfor(; !que.isEmpty()&&!yes;){\n\t\t\tint p=que.poll();\n\t\t\tint xl=p/50/50/50%50;\n\t\t\tint yl=p/50/50%50;\n\t\t\tint xr=p/50%50;\n\t\t\tint yr=p%50;\n\t\t\t// debug(p.xl, p.yl, p.xr, p.yr);\n\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\tint xl2=xl+dxl[i];\n\t\t\t\tint yl2=yl+dyl[i];\n\t\t\t\tint xr2=xr+dxr[i];\n\t\t\t\tint yr2=yr+dyr[i];\n\t\t\t\t// P q=new P(p.xl+dxl[i], p.yl+dyl[i], p.xr+dxr[i], p.yr+dyr[i]);\n//\t\t\t\tif(!in(q.xl, q.yl)||al[q.yl][q.xl]==1){\n//\t\t\t\t\tq.xl=p.xl;\n//\t\t\t\t\tq.yl=p.yl;\n//\t\t\t\t}\n//\t\t\t\tif(!in(q.xr, q.yr)||ar[q.yr][q.xr]==1){\n//\t\t\t\t\tq.xr=p.xr;\n//\t\t\t\t\tq.yr=p.yr;\n//\t\t\t\t}\n\t\t\t\tif(!in(xl2, yl2)||al[yl2][xl2]==1){\n\t\t\t\t\txl2=xl;\n\t\t\t\t\tyl2=yl;\n\t\t\t\t}\n\t\t\t\tif(!in(xr2, yr2)||ar[yr2][xr2]==1){\n\t\t\t\t\txr2=xr;\n\t\t\t\t\tyr2=yr;\n\t\t\t\t}\n\t\t\t\t// debug(\"\\t\", q.xl, q.yl, q.xr, q.yr);\n\t\t\t\t// q.xr=max(min(q.xr, m-1), 0);\n\t\t\t\t// q.yr=max(min(q.yr, n-1), 0);\n\t\t\t\tboolean ll=al[yl2][xl2]==2;\n\t\t\t\tboolean rr=ar[yr2][xr2]==2;\n\t\t\t\tif(ll^rr){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(ll&&rr){\n\t\t\t\t\tyes=true;\n\t\t\t\t}\n\t\t\t\tif(!visited[xl2][yl2][xr2][yr2]){\n\t\t\t\t\tvisited[xl2][yl2][xr2][yr2]=true;\n\t\t\t\t\tque.offer(hash(xl2, yl2, xr2, yr2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintln(yes?\"Yes\":\"No\");\n\t}\n\n\tint hash(int xl, int yl, int xr, int yr){\n\t\treturn (xl*50+yl)*2500+(xr*50+yr);\n\t}\n\n\tboolean in(int x, int y){\n\t\treturn x>=0&&x<m&&y>=0&&y<n;\n\t}\n\n\tclass P{\n\t\tbyte xl, yl, xr, yr;\n\n\t\tP(int xl, int yl, int xr, int yr){\n\t\t\tthis.xl=(byte)xl;\n\t\t\tthis.yl=(byte)yl;\n\t\t\tthis.xr=(byte)xr;\n\t\t\tthis.yr=(byte)yr;\n\t\t}\n\t}\n\n\tint c2i(char c){\n\t\tswitch(c){\n\t\tcase '.':\n\t\t\treturn 0;\n\t\tcase '#':\n\t\t\treturn 1;\n\t\tcase '%':\n\t\t\treturn 2;\n\t\tcase 'L':\n\t\t\treturn -1;\n\t\tcase 'R':\n\t\t\treturn -1;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.BitSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\npublic class Main{\n\tpublic static final int[] dx = {1, 0, -1, 0};\n\tpublic static final int[] dy = {0, 1, 0, -1};\n\tpublic static int w, h;\n\tpublic static char[][][] map;\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = in.nextInt();\n\t\t\th = in.nextInt();\n\t\t\tif(w == 0) break;\n\t\t\tmap = new char[2][h][w];\n\t\t\tint g = 0;\n\t\t\tint s = 0;\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\tfor(int j=0; j<2; j++){\n\t\t\t\t\tchar[] line = in.next().toCharArray();\n\t\t\t\t\tif(j==0) map[j][i] = line;\n\t\t\t\t\telse{\n\t\t\t\t\t\tfor(int k=0; k<w; k++){\n\t\t\t\t\t\t\tmap[j][i][k] = line[w-1-k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0; k<w; k++){\n\t\t\t\t\t\tswitch(map[j][i][k]){\n\t\t\t\t\t\tcase 'R':\n\t\t\t\t\t\t\ts += i*w+k;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'L':\n\t\t\t\t\t\t\ts += (i*w+k)*h*w;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '%':\n\t\t\t\t\t\t\tg += id(j, i, k);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tBitSet used = new BitSet(w*w*h*h);\n\t\t\tQueue<Integer> qu = new LinkedList<Integer>();\n\t\t\tqu.add(s);\n\t\t\tused.set(s);\n\t\t\tint hw = h*w;\n\t\t\tint whw = w*h*w;\n\t\t\tboolean flag = false;\n\t\t\twhile(!qu.isEmpty()){\n\t\t\t\tint id = qu.poll();\n\t\t\t\tif(id == g){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint y0 = id/whw;\n\t\t\t\tid %= whw;\n\t\t\t\tint x0 = id/hw;\n\t\t\t\tid %= hw;\n\t\t\t\tint y1 = id/w;\n\t\t\t\tint x1 = id%w;\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tint nid = next(x0, y0, x1, y1, i);\n\t\t\t\t\tif(used.get(nid)) continue;\n\t\t\t\t\tused.set(nid);\n\t\t\t\t\tqu.add(nid);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(flag ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\t\n\tpublic static String dump(char[][] map){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tsb.append(map[i][j]+\" \");\n\t\t\t}\n\t\t\tsb.append('\\n');\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tpublic static int next(int x0, int y0, int x1, int y1, int dir){\n\t\tint nx0 = x0 + dx[dir];\n\t\tint ny0 = y0 + dy[dir];\n\t\tif(nx0 < 0 || nx0 >= w || ny0 < 0 || ny0 >= h\n\t\t\t\t|| map[0][ny0][nx0] == '#'){\n\t\t\tnx0 = x0;\n\t\t\tny0 = y0;\n\t\t}\n\t\tint nx1 = x1 + dx[dir];\n\t\tint ny1 = y1 + dy[dir];\n\t\tif(nx1 < 0 || nx1 >= w || ny1 < 0 || ny1 >= h\n\t\t\t\t|| map[1][ny1][nx1] == '#'){\n\t\t\tnx1 = x1;\n\t\t\tny1 = y1;\n\t\t}\n\t\treturn id(0, ny0, nx0) + id(1, ny1, nx1);\n\t}\n\t\n\tpublic static int id(int room, int y, int x){\n\t\treturn room==0 ? (y*w+x)*w*h : y*w+x;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint m, n;\n\n\tint[][] al, ar;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tm=sc.nextInt();\n\t\t\tn=sc.nextInt();\n\t\t\tif((m|n)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tal=new int[n][m];\n\t\t\tar=new int[n][m];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tString sl=sc.next();\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\tal[j][i]=c2i(sl.charAt(i));\n\t\t\t\t}\n\t\t\t\tString sr=sc.next();\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\tar[j][i]=c2i(sr.charAt(i));\n\t\t\t\t}\n\t\t\t\t// debug(al[j], ar[j]);\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tboolean[][][][] visited=new boolean[50][50][50][50];\n\n\tvoid solve(){\n\t\tfor(int k=0; k<50; k++){\n\t\t\tfor(int j=0; j<50; j++){\n\t\t\t\tfor(int i=0; i<50; i++){\n\t\t\t\t\tfill(visited[k][j][i], false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// boolean[][][][] visited=new boolean[m][n][m][n];\n\t\t// HashSet<Integer> visited=new HashSet<Integer>();\n\t\tint xl0=0, yl0=0, xr0=0, yr0=0;\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tif(al[j][i]==-1){\n\t\t\t\t\txl0=i;\n\t\t\t\t\tyl0=j;\n\t\t\t\t\tal[j][i]=0;\n\t\t\t\t}\n\t\t\t\tif(ar[j][i]==-1){\n\t\t\t\t\txr0=i;\n\t\t\t\t\tyr0=j;\n\t\t\t\t\tar[j][i]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tLinkedList<P> que=new LinkedList<P>();\n\t\tque.offer(new P(xl0, yl0, xr0, yr0));\n\t\tint[] dxl={0, 0, -1, 1};\n\t\tint[] dyl={-1, 1, 0, 0};\n\t\tint[] dxr={0, 0, 1, -1};\n\t\tint[] dyr={-1, 1, 0, 0};\n\t\tboolean yes=false;\n\t\tfor(; !que.isEmpty()&&!yes;){\n\t\t\tP p=que.poll();\n\t\t\t// debug(p.xl, p.yl, p.xr, p.yr);\n\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\tP q=new P(p.xl+dxl[i], p.yl+dyl[i], p.xr+dxr[i], p.yr+dyr[i]);\n\t\t\t\tif(!in(q.xl, q.yl)||al[q.yl][q.xl]==1){\n\t\t\t\t\tq.xl=p.xl;\n\t\t\t\t\tq.yl=p.yl;\n\t\t\t\t}\n\t\t\t\tif(!in(q.xr, q.yr)||ar[q.yr][q.xr]==1){\n\t\t\t\t\tq.xr=p.xr;\n\t\t\t\t\tq.yr=p.yr;\n\t\t\t\t}\n\t\t\t\t// debug(\"\\t\", q.xl, q.yl, q.xr, q.yr);\n\t\t\t\t// q.xr=max(min(q.xr, m-1), 0);\n\t\t\t\t// q.yr=max(min(q.yr, n-1), 0);\n\t\t\t\tboolean ll=al[q.yl][q.xl]==2;\n\t\t\t\tboolean rr=ar[q.yr][q.xr]==2;\n\t\t\t\tif(ll^rr){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(ll&&rr){\n\t\t\t\t\tyes=true;\n\t\t\t\t}\n\t\t\t\tif(!visited[q.xl][q.yl][q.xr][q.yr]){\n\t\t\t\t\tvisited[q.xl][q.yl][q.xr][q.yr]=true;\n\t\t\t\t\tque.offer(q);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintln(yes?\"Yes\":\"No\");\n\t}\n\n\tint hash(int xl, int yl, int xr, int yr){\n\t\treturn (xl*50+yl)*2500+(xr*50+yr);\n\t}\n\n\tboolean in(int x, int y){\n\t\treturn x>=0&&x<m&&y>=0&&y<n;\n\t}\n\n\tclass P{\n\t\tbyte xl, yl, xr, yr;\n\n\t\tP(int xl, int yl, int xr, int yr){\n\t\t\tthis.xl=(byte)xl;\n\t\t\tthis.yl=(byte)yl;\n\t\t\tthis.xr=(byte)xr;\n\t\t\tthis.yr=(byte)yr;\n\t\t}\n\t}\n\n\tint c2i(char c){\n\t\tswitch(c){\n\t\tcase '.':\n\t\t\treturn 0;\n\t\tcase '#':\n\t\t\treturn 1;\n\t\tcase '%':\n\t\t\treturn 2;\n\t\tcase 'L':\n\t\t\treturn -1;\n\t\tcase 'R':\n\t\t\treturn -1;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif ((w | h) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tchar[][] f1 = new char[h][w];\n\t\t\tchar[][] f2 = new char[h][w];\n\t\t\tint sw1, sh1, sw2, sh2;\n\t\t\tsw1 = sh1 = sw2 = sh2 = 0;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString in1 = sc.next();\n\t\t\t\tString in2 = sc.next();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tf1[i][j] = in1.charAt(j);\n\t\t\t\t\tf2[i][j] = in2.charAt(j);\n\t\t\t\t\tif (f1[i][j] == 'L') {\n\t\t\t\t\t\tsw1 = j;\n\t\t\t\t\t\tsh1 = i;\n\t\t\t\t\t}\n\t\t\t\t\tif (f2[i][j] == 'R') {\n\t\t\t\t\t\tsw2 = j;\n\t\t\t\t\t\tsh2 = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean[][][][] visit = new boolean[h][w][h][w];\n\t\t\tboolean ok = false;\n\t\t\tvisit[sh1][sw1][sh2][sw2] = true;\n\t\t\tLinkedList<Pos> que = new LinkedList<Pos>();\n\t\t\tque.add(new Pos(sh1, sw1, sh2, sw2));\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tPos now = que.poll();\n\t\t\t\tif (f1[now.h1][now.w1] == '%' && f2[now.h2][now.w2] == '%') {\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint nh1 = now.h1 + dy[i];\n\t\t\t\t\tint nw1 = now.w1 + dx[i];\n\t\t\t\t\tint nh2 = now.h2 + dy[i];\n\t\t\t\t\tint nw2 = now.w2 + (dx[i] * -1);\n\t\t\t\t\tif (!inner(nh1, nw1, h, w) || f1[nh1][nw1] == '#') {\n\t\t\t\t\t\tnh1 = now.h1;\n\t\t\t\t\t\tnw1 = now.w1;\n\t\t\t\t\t}\n\t\t\t\t\tif (!inner(nh2, nw2, h, w) || f2[nh2][nw2] == '#') {\n\t\t\t\t\t\tnh2 = now.h2;\n\t\t\t\t\t\tnw2 = now.w2;\n\t\t\t\t\t}\n\t\t\t\t\tif ((f1[nh1][nw1] != '%' && f2[nh2][nw2] == '%')\n\t\t\t\t\t\t\t|| (f1[nh1][nw1] == '%' && f2[nh2][nw2] != '%')) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!visit[nh1][nw1][nh2][nw2]) {\n\t\t\t\t\t\tvisit[nh1][nw1][nh2][nw2] = true;\n\t\t\t\t\t\tque.add(new Pos(nh1, nw1, nh2, nw2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ok ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\n\tclass Pos {\n\t\tint w1;\n\t\tint h1;\n\t\tint w2;\n\t\tint h2;\n\n\t\tpublic Pos(int h1, int w1, int h2, int w2) {\n\t\t\tsuper();\n\t\t\tthis.h1 = h1;\n\t\t\tthis.w1 = w1;\n\t\t\tthis.h2 = h2;\n\t\t\tthis.w2 = w2;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tboolean inner(int h, int w, int limH, int limW) {\n\t\treturn 0 <= h && h < limH && 0 <= w && w < limW;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nimport javax.xml.crypto.Data;\npublic class Main{\n\tstatic int INF = 2 << 28;\n\tstatic int[] vxL = {0,0,1,-1};\n\tstatic int[] vxR = {0,0,-1,1};\n\tstatic int[] vyL = {1,-1,0,0};\n\tstatic int[] vyR = {1,-1,0,0};\n\tstatic int w;\n\tstatic int h;\n\tstatic int Lx;\n\tstatic int Ly;\n\tstatic int Rx;\n\tstatic int Ry;\n\tstatic char[][] mapL;\n\tstatic char[][] mapR;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif(w == 0 && h == 0) break;\n\t\t\tmapL = new char[h][];\n\t\t\tmapR = new char[h][];\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tmapL[i] = sc.next().toCharArray();\n\t\t\t\tmapR[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tLx = 0;\n\t\t\tLy = 0;\n\t\t\tRx = 0;\n\t\t\tRy = 0;\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(mapL[i][j] == 'L') {\n\t\t\t\t\t\tLy = i;\n\t\t\t\t\t\tLx = j;\n\t\t\t\t\t\tmapL[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t\tif(mapR[i][j] == 'R') {\n\t\t\t\t\t\tRy = i;\n\t\t\t\t\t\tRx = j;\n\t\t\t\t\t\tmapR[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean ans = BFS();\n\t\t\tif(ans) {\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t\tSystem.gc();\n\t\t}\n\t}\t\n\tstatic boolean BFS() {\n\t\tHashMap<Data,Boolean> map = new HashMap<Data,Boolean>();\n\t\tArrayDeque<Data> queue = new ArrayDeque<Data>();\n\t\tqueue.add(new Data(Lx,Ly,Rx,Ry));\n\t\twhile(!queue.isEmpty()) {\n\t\t\tData tmp = queue.poll();\n\t\t\tif(map.containsKey(tmp)) continue;\n\t\t\tmap.put(tmp, true);\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\t\n\t\t\t\tint Ltx = tmp.Lx + vxL[i];\n\t\t\t\tint Lty = tmp.Ly + vyL[i];\n\t\t\t\tint Rtx = tmp.Rx + vxR[i];\n\t\t\t\tint Rty = tmp.Ry + vyR[i];\n\t\t\t\t\n\t\t\t\tint  L = Rcheck(Ltx,Lty,mapL);\n\t\t\t\tint  R = Rcheck(Rtx,Rty,mapR);\n\t\t\t\t\n\t\t\t\tif(L == 2 && R == 2) return true;\n\t\t\t\tif(L == 2 && R != 2) continue;\n\t\t\t\tif(L != 2 && R == 2) continue;\n\t\t\t\tif(L == 0 && R == 0) continue;\n\t\t\t\tif(L == 0) {\n\t\t\t\t\tLtx = tmp.Lx;\n\t\t\t\t\tLty = tmp.Ly;\n\t\t\t\t}\n\t\t\t\tif(R == 0) {\n\t\t\t\t\tRtx = tmp.Rx;\n\t\t\t\t\tRty = tmp.Ry;\n\t\t\t\t}\n\t\t\t\tqueue.addLast(new Data(Ltx,Lty,Rtx,Rty));\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t\t\n\t}\n\tstatic int Rcheck(int x,int y,char[][] map) {\n\t\tif(x < 0 || y < 0 || x >= w || y >= h) return 0;\n\t\tif(map[y][x] == '#') return 0;\n\t\tif(map[y][x] == '.') return 1;\n\t\tif(map[y][x] == '%') return 2;\n\t\treturn -1;\n\t}\n\t\n\tstatic class Data {\n\t\tint Lx;\n\t\tint Ly;\n\t\tint Rx;\n\t\tint Ry;\n\t\tData(int a, int b, int c, int d) {\n\t\t\tLx = a;\n\t\t\tLy = b;\n\t\t\tRx = c;\n\t\t\tRy = d;\n\t\t}\n\t\tpublic boolean equals(Object o) {\n\t\t\tData c = (Data)o;\n\t\t\tif(this.Lx != c.Lx) return false;\n\t\t\tif(this.Ly != c.Ly) return false;\n\t\t\tif(this.Rx != c.Rx) return false;\n\t\t\tif(this.Ry != c.Ry) return false;\n\t\t\treturn true;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint m, n;\n\n\tint[][] al, ar;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tm=sc.nextInt();\n\t\t\tn=sc.nextInt();\n\t\t\tif((m|n)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tal=new int[n][m];\n\t\t\tar=new int[n][m];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tString sl=sc.next();\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\tal[j][i]=c2i(sl.charAt(i));\n\t\t\t\t}\n\t\t\t\tString sr=sc.next();\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\tar[j][i]=c2i(sr.charAt(i));\n\t\t\t\t}\n\t\t\t\t// debug(al[j], ar[j]);\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\tboolean[][][][] visited=new boolean[m][n][m][n];\n\t\tint xl0=0, yl0=0, xr0=0, yr0=0;\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tif(al[j][i]==-1){\n\t\t\t\t\txl0=i;\n\t\t\t\t\tyl0=j;\n\t\t\t\t\tal[j][i]=0;\n\t\t\t\t}\n\t\t\t\tif(ar[j][i]==-1){\n\t\t\t\t\txr0=i;\n\t\t\t\t\tyr0=j;\n\t\t\t\t\tar[j][i]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tLinkedList<P> que=new LinkedList<P>();\n\t\tque.offer(new P(xl0, yl0, xr0, yr0));\n\t\tint[] dxl={0, 0, -1, 1};\n\t\tint[] dyl={-1, 1, 0, 0};\n\t\tint[] dxr={0, 0, 1, -1};\n\t\tint[] dyr={-1, 1, 0, 0};\n\t\tboolean yes=false;\n\t\tfor(; !que.isEmpty()&&!yes;){\n\t\t\tP p=que.poll();\n\t\t\t// debug(p.xl, p.yl, p.xr, p.yr);\n\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\tP q=new P(p.xl+dxl[i], p.yl+dyl[i], p.xr+dxr[i], p.yr+dyr[i]);\n\t\t\t\tif(!in(q.xl, q.yl)||al[q.yl][q.xl]==1){\n\t\t\t\t\tq.xl=p.xl;\n\t\t\t\t\tq.yl=p.yl;\n\t\t\t\t}\n\t\t\t\tif(!in(q.xr, q.yr)||ar[q.yr][q.xr]==1){\n\t\t\t\t\tq.xr=p.xr;\n\t\t\t\t\tq.yr=p.yr;\n\t\t\t\t}\n\t\t\t\t// debug(\"\\t\", q.xl, q.yl, q.xr, q.yr);\n\t\t\t\t// q.xr=max(min(q.xr, m-1), 0);\n\t\t\t\t// q.yr=max(min(q.yr, n-1), 0);\n\t\t\t\tboolean ll=al[q.yl][q.xl]==2;\n\t\t\t\tboolean rr=ar[q.yr][q.xr]==2;\n\t\t\t\tif(ll^rr){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(ll&&rr){\n\t\t\t\t\tyes=true;\n\t\t\t\t}\n\t\t\t\tif(!visited[q.xl][q.yl][q.xr][q.yr]){\n\t\t\t\t\tvisited[q.xl][q.yl][q.xr][q.yr]=true;\n\t\t\t\t\tque.offer(q);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintln(yes?\"Yes\":\"No\");\n\t}\n\n\tboolean in(int x, int y){\n\t\treturn x>=0&&x<m&&y>=0&&y<n;\n\t}\n\n\tclass P{\n\t\tint xl, yl, xr, yr;\n\n\t\tP(int xl, int yl, int xr, int yr){\n\t\t\tthis.xl=xl;\n\t\t\tthis.yl=yl;\n\t\t\tthis.xr=xr;\n\t\t\tthis.yr=yr;\n\t\t}\n\t}\n\n\tint c2i(char c){\n\t\tswitch(c){\n\t\tcase '.':\n\t\t\treturn 0;\n\t\tcase '#':\n\t\t\treturn 1;\n\t\tcase '%':\n\t\t\treturn 2;\n\t\tcase 'L':\n\t\t\treturn -1;\n\t\tcase 'R':\n\t\t\treturn -1;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static final void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tint w;\n\tint h;\n\tchar[][] map;\n\tint sl;\n\tint sr;\n\tpublic Main() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif(w==0 && h==0)\n\t\t\t\tbreak;\n\t\t\tmap = new char[2][w*h];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tString s0 = sc.next();\n\t\t\t\tString s1 = sc.next();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tmap[0][i*w+j] = s0.charAt(j);\n\t\t\t\t\tmap[1][i*w+j] = s1.charAt(w-j-1);\n\t\t\t\t\tif(map[0][i*w+j]=='L')\n\t\t\t\t\t\tsl = i*w+j;\n\t\t\t\t\tif(map[1][i*w+j]=='R')\n\t\t\t\t\t\tsr = i*w+j;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tint[] dx = new int[]{-1, 0, 1, 0};\n\tint[] dy = new int[]{0, -1, 0, 1};\n\tprivate void solve() {\n\t\tLinkedList<int[]> queue = new LinkedList<int[]>();\n\t\t\n\t\tint[][] visited = new int[w*h][w*h];\n\t\tqueue.add(new int[]{sl, sr});\n\n\t\twhile(!queue.isEmpty()){\n\t\t\tint[] cp = queue.poll();\n\t\t\tint clp = cp[0];\n\t\t\tint crp = cp[1];\n\t\t\t\n\t\t\tif(visited[clp][crp]==1)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tvisited[clp][crp] = 1;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nlp = clp + dx[i] + dy[i]*w;\n\t\t\t\tint nrp = crp + dx[i] + dy[i]*w;\n\t\t\t\tif(nlp<0 || w*h<=nlp || nrp<0 || w*h<=nrp)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(map[0][nlp]=='#')\n\t\t\t\t\tnlp = clp;\n\t\t\t\tif(map[1][nrp]=='#')\n\t\t\t\t\tnrp = crp;\n\t\t\t\t\n\t\t\t\tif(map[0][nlp]=='%' && map[1][nrp]=='%'){\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tqueue.add(new int[]{nlp, nrp});\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"No\");\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nimport javax.xml.crypto.Data;\npublic class Main{\n\tstatic int INF = 2 << 28;\n\tstatic int[] vxL = {0,0,1,-1};\n\tstatic int[] vxR = {0,0,-1,1};\n\tstatic int[] vyL = {1,-1,0,0};\n\tstatic int[] vyR = {1,-1,0,0};\n\tstatic int w;\n\tstatic int h;\n\tstatic int Lx;\n\tstatic int Ly;\n\tstatic int Rx;\n\tstatic int Ry;\n\tstatic char[][] mapL;\n\tstatic char[][] mapR;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif(w == 0 && h == 0) break;\n\t\t\tmapL = new char[h][];\n\t\t\tmapR = new char[h][];\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tmapL[i] = sc.next().toCharArray();\n\t\t\t\tmapR[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tLx = 0;\n\t\t\tLy = 0;\n\t\t\tRx = 0;\n\t\t\tRy = 0;\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(mapL[i][j] == 'L') {\n\t\t\t\t\t\tLy = i;\n\t\t\t\t\t\tLx = j;\n\t\t\t\t\t\tmapL[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t\tif(mapR[i][j] == 'R') {\n\t\t\t\t\t\tRy = i;\n\t\t\t\t\t\tRx = j;\n\t\t\t\t\t\tmapR[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean ans = BFS();\n\t\t\tif(ans) {\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t}\t\n\tstatic boolean BFS() {\n\t\tboolean[][][][] use = new boolean[w][h][w][h];\n\t\tArrayDeque<Data> queue = new ArrayDeque<Data>();\n\t\tqueue.add(new Data(Lx,Ly,Rx,Ry));\n\t\twhile(!queue.isEmpty()) {\n\t\t\tData tmp = queue.poll();\n\t\t\tif(use[tmp.Lx][tmp.Ly][tmp.Rx][tmp.Ry]) continue;\n\t\t\tuse[tmp.Lx][tmp.Ly][tmp.Rx][tmp.Ry] = true;\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\t\n\t\t\t\tint Ltx = tmp.Lx + vxL[i];\n\t\t\t\tint Lty = tmp.Ly + vyL[i];\n\t\t\t\tint Rtx = tmp.Rx + vxR[i];\n\t\t\t\tint Rty = tmp.Ry + vyR[i];\n\t\t\t\t\n\t\t\t\tint  L = Rcheck(Ltx,Lty,mapL);\n\t\t\t\tint  R = Rcheck(Rtx,Rty,mapR);\n\t\t\t\t\n\t\t\t\tif(L == 2 && R == 2) return true;\n\t\t\t\tif(L == 2 && R != 2) continue;\n\t\t\t\tif(L != 2 && R == 2) continue;\n\t\t\t\tif(L == 0 && R == 0) continue;\n\t\t\t\tif(L == 0) {\n\t\t\t\t\tLtx = tmp.Lx;\n\t\t\t\t\tLty = tmp.Ly;\n\t\t\t\t}\n\t\t\t\tif(R == 0) {\n\t\t\t\t\tRtx = tmp.Rx;\n\t\t\t\t\tRty = tmp.Ry;\n\t\t\t\t}\n\t\t\t\tqueue.addLast(new Data(Ltx,Lty,Rtx,Rty));\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t\t\n\t}\n\tstatic int Rcheck(int x,int y,char[][] map) {\n\t\tif(x < 0 || y < 0 || x >= w || y >= h) return 0;\n\t\tif(map[y][x] == '#') return 0;\n\t\tif(map[y][x] == '.') return 1;\n\t\tif(map[y][x] == '%') return 2;\n\t\treturn -1;\n\t}\n\t\n\tstatic class Data {\n\t\tint Lx;\n\t\tint Ly;\n\t\tint Rx;\n\t\tint Ry;\n\t\tData(int a, int b, int c, int d) {\n\t\t\tLx = a;\n\t\t\tLy = b;\n\t\t\tRx = c;\n\t\t\tRy = d;\n\t\t}\n\t\tpublic boolean equals(Object o) {\n\t\t\tData c = (Data)o;\n\t\t\tif(this.Lx != c.Lx) return false;\n\t\t\tif(this.Ly != c.Ly) return false;\n\t\t\tif(this.Rx != c.Rx) return false;\n\t\t\tif(this.Ry != c.Ry) return false;\n\t\t\treturn true;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\tpublic void run() {\n\t\twhile(sc.hasNext()){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif(w == 0 && h == 0)break;\n\t\t\telse calc(w, h);\n\t\t\t\n\t\t}\n\t}\n\tpublic void calc(int w, int h){\n\t\tString[][] roomR = new String[w][h];\n\t\tString[][] roomL = new String[w][h];\n\t\tint xR = 0;\n\t\tint yR = 0;\n\t\tint xL = 0;\n\t\tint yL = 0;\n\t\tfor(int j = 0; j < h; j++){\n\t\t\tString l = sc.next();\n\t\t\tString r = sc.next();\n\t\t\tfor(int i = 0; i < w; i++){\n\t\t\t\troomR[i][j] = r.substring(i, i+1);\n\t\t\t\troomL[i][j] = l.substring(i, i+1);\n\t\t\t\tif(roomR[i][j].equals(\"R\")){\n\t\t\t\t\txR = i; yR = j;\n\t\t\t\t}\n\t\t\t\tif(roomL[i][j].equals(\"L\")){\n\t\t\t\t\txL = i; yL = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint[] moveXR = {0, -1, 0, 1};\n\t\tint[] moveY = {-1, 0, 1, 0};\n\t\tint[] moveXL = {0, 1, 0, -1};\n\t\t\n\t\tint[][][][] memo = new int[w][h][w][h];\n\t\tmemo[xR][yR][xL][yL] = 1;\n\t\t\n\t\tArrayList<int[]> list = new ArrayList<int[]>();\n\t\tlist.add(new int[]{xR, yR, xL, yL});\n\t\t\n\t\tboolean ans = false;\n\t\t\n\t\twhile(list.size() != 0){\n\t\t\tint[] now = list.get(0);\n\t\t\tlist.remove(0);\n\t\t\tfor(int k = 0; k < 4; k++){\n\t\t\t\tint nXR = now[0] + moveXR[k];\n\t\t\t\tint nYR = now[1] + moveY[k];\n\t\t\t\tint nXL = now[2] + moveXL[k];\n\t\t\t\tint nYL = now[3] + moveY[k];\n\t\t\t\tif(nXR < 0) nXR = 0;\n\t\t\t\tif(nXR >= w) nXR = w - 1;\n\t\t\t\tif(nYR < 0) nYR = 0;\n\t\t\t\tif(nYR >= h) nYR = h - 1;\n\t\t\t\tif(nXL < 0) nXL = 0;\n\t\t\t\tif(nXL >= w) nXL = w - 1;\n\t\t\t\tif(nYL < 0) nYL = 0;\n\t\t\t\tif(nYL >= h) nYL = h - 1;\n\t\t\t\t\n\t\t\t\tboolean goalR = false;\n\t\t\t\tboolean goalL = false;\n\t\t\t\tif(roomR[nXR][nYR].equals(\"#\")){\n\t\t\t\t\tnXR = now[0]; nYR = now[1];\n\t\t\t\t}\n\t\t\t\telse if(roomR[nXR][nYR].equals(\"%\")){\n\t\t\t\t\tgoalR = true;\n\t\t\t\t}\n\t\t\t\tif(roomL[nXL][nYL].equals(\"#\")){\n\t\t\t\t\tnXL = now[2]; nYL = now[3];\n\t\t\t\t}\n\t\t\t\telse if(roomL[nXL][nYL].equals(\"%\")){\n\t\t\t\t\tgoalL = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(goalR && goalL){\n\t\t\t\t\tans = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if((!goalR && !goalL) && memo[nXR][nYR][nXL][nYL] == 0){\n\t\t\t\t\tmemo[nXR][nYR][nXL][nYL] = 1;\n\t\t\t\t\tlist.add(new int[]{nXR, nYR, nXL, nYL});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans){\n\t\t\tSystem.out.println(\"Yes\");\n\t\t}\n\t\telse{\n\t\t\tSystem.out.println(\"No\");\n\t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nimport javax.xml.crypto.Data;\npublic class Main{\n\tstatic int INF = 2 << 28;\n\tstatic int[] vxL = {0,0,1,-1};\n\tstatic int[] vxR = {0,0,-1,1};\n\tstatic int[] vyL = {1,-1,0,0};\n\tstatic int[] vyR = {1,-1,0,0};\n\tstatic int w;\n\tstatic int h;\n\tstatic int Lx;\n\tstatic int Ly;\n\tstatic int Rx;\n\tstatic int Ry;\n\tstatic char[][] mapL;\n\tstatic char[][] mapR;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif(w == 0 && h == 0) break;\n\t\t\tmapL = new char[h][];\n\t\t\tmapR = new char[h][];\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tmapL[i] = sc.next().toCharArray();\n\t\t\t\tmapR[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tLx = 0;\n\t\t\tLy = 0;\n\t\t\tRx = 0;\n\t\t\tRy = 0;\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(mapL[i][j] == 'L') {\n\t\t\t\t\t\tLy = i;\n\t\t\t\t\t\tLx = j;\n\t\t\t\t\t\tmapL[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t\tif(mapR[i][j] == 'R') {\n\t\t\t\t\t\tRy = i;\n\t\t\t\t\t\tRx = j;\n\t\t\t\t\t\tmapR[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean ans = BFS();\n\t\t\tif(ans) {\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t}\t\n\tstatic boolean BFS() {\n\t\tHashMap<String,Boolean> map = new HashMap<String,Boolean>();\n\t\tArrayDeque<Data> queue = new ArrayDeque<Data>();\n\t\tqueue.add(new Data(Lx,Ly,Rx,Ry));\n\t\twhile(!queue.isEmpty()) {\n\t\t\tData tmp = queue.poll();\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\t\n\t\t\t\tint Ltx = tmp.Lx + vxL[i];\n\t\t\t\tint Lty = tmp.Ly + vyL[i];\n\t\t\t\tint Rtx = tmp.Rx + vxR[i];\n\t\t\t\tint Rty = tmp.Ry + vyR[i];\n\t\t\t\t\n\t\t\t\tint  L = Rcheck(Ltx,Lty,mapL);\n\t\t\t\tint  R = Rcheck(Rtx,Rty,mapR);\n\t\t\t\t\n\t\t\t\tif(L == 2 && R == 2) return true;\n\t\t\t\tif(L == 2 && R != 2) continue;\n\t\t\t\tif(L != 2 && R == 2) continue;\n\t\t\t\tif(L == 0 && R == 0) continue;\n\t\t\t\tif(L == 0) {\n\t\t\t\t\tLtx = tmp.Lx;\n\t\t\t\t\tLty = tmp.Ly;\n\t\t\t\t}\n\t\t\t\tif(R == 0) {\n\t\t\t\t\tRtx = tmp.Rx;\n\t\t\t\t\tRty = tmp.Ry;\n\t\t\t\t}\n\t\t\t\tqueue.addLast(new Data(Ltx,Lty,Rtx,Rty));\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t\t\n\t}\n\tstatic int Rcheck(int x,int y,char[][] map) {\n\t\tif(x < 0 || y < 0 || x >= w || y >= h) return 0;\n\t\tif(map[y][x] == '#') return 0;\n\t\tif(map[y][x] == '.') return 1;\n\t\tif(map[y][x] == '%') return 2;\n\t\treturn -1;\n\t}\n\t\n\tstatic class Data {\n\t\tint Lx;\n\t\tint Ly;\n\t\tint Rx;\n\t\tint Ry;\n\t\tData(int a, int b, int c, int d) {\n\t\t\tLx = a;\n\t\t\tLy = b;\n\t\t\tRx = c;\n\t\t\tRy = d;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tHashSet<Integer> hash = new HashSet<Integer>();\t\n\tPriorityQueue<State> pq;\n\tboolean res;\n\tchar[][] len, rin;\n\n\tint[] vx = {0, -1, 1, 0};\n\tint[] vy = {-1, 0, 0, 1};\n\t\n\tclass State implements Comparable<State> {\n\t\tint len_x, len_y, rin_x, rin_y;\n\t\t\n\t\tState(int len_x, int len_y, int rin_x, int rin_y) {\n\t\t\tthis.len_x = len_x;\n\t\t\tthis.len_y = len_y;\n\t\t\tthis.rin_x = rin_x;\n\t\t\tthis.rin_y = rin_y;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(State o) {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tpublic String toString() {\n\t\t\treturn len_x + \" \" + len_y + \" \" + rin_x + \" \" + rin_y;\n\t\t}\n\t}\n\t\n\tboolean isOk(int x, int y, int H, int W, char[][] map) {\n\t\treturn x >= 0 && x < W && y >= 0 && y < H && map[y][x] != '#';\n\t}\n\t\n\tvoid bfs(int H, int W) {\n\t\twhile (!pq.isEmpty()) {\n\t\t\tState s = pq.poll();\n\t\t\tfor (int i = 0; i < vx.length; i++) {\n\t\t\t\tint len_nx = s.len_x + vx[i];\n\t\t\t\tint len_ny = s.len_y + vy[i];\n\t\t\t\tint rin_nx = s.rin_x - vx[i];\n\t\t\t\tint rin_ny = s.rin_y + vy[i];\n\t\t\t\tif (!isOk(len_nx, len_ny, H, W, len)) {\n\t\t\t\t\tlen_nx -= vx[i];\n\t\t\t\t\tlen_ny -= vy[i];\n\t\t\t\t}\n\t\t\t\tif (!isOk(rin_nx, rin_ny, H, W, rin)) {\n\t\t\t\t\trin_nx += vx[i];\n\t\t\t\t\trin_ny -= vy[i];\n\t\t\t\t}\n\t\t\t\tint hashValue = convert(len_nx, len_ny, rin_nx, rin_ny);\n\t\t\t\tif (!hash.contains(hashValue)) {\n\t\t\t\t\tif ((len[len_ny][len_nx] != '%' && rin[rin_ny][rin_nx] == '%') ||\n\t\t\t\t\t\t(len[len_ny][len_nx] == '%' && rin[rin_ny][rin_nx] != '%')) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tpq.add(new State(len_nx, len_ny, rin_nx, rin_ny));\n\t\t\t\t\thash.add(hashValue);\n\t\t\t\t\tif (len[len_ny][len_nx] == '%' && rin[rin_ny][rin_nx] == '%') res = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint convert(int len_x, int len_y, int rin_x, int rin_y) {\n\t\treturn len_x * 50*50*50 + len_y * 50*50 + rin_x * 50 + rin_y;\n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint W = in.nextInt(), H = in.nextInt();\n\t\t\tif (W == 0) break;\n\t\t\thash.clear();\n\t\t\tres = false;\n\t\t\t\n\t\t\tlen = new char[H][W];\n\t\t\trin = new char[H][W];\n\t\t\t\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tlen[i] = in.next().toCharArray();\n\t\t\t\trin[i] = in.next().toCharArray();\n\t\t\t}\n\t\t\t\n\t\t\tint len_sx = 0, len_sy = 0, rin_sx = 0, rin_sy = 0;\n\t\t\t\n\t\t\tfor (int i = 0; i < H; i++) for (int j = 0; j < W; j++) {\n\t\t\t\tif (len[i][j] == 'L') {\n\t\t\t\t\tlen_sx = j;\n\t\t\t\t\tlen_sy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < H; i++) for (int j = 0; j < W; j++) {\n\t\t\t\tif (rin[i][j] == 'R') {\n\t\t\t\t\trin_sx = j;\n\t\t\t\t\trin_sy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tpq = new PriorityQueue<State>();\n\t\t\tpq.add(new State(len_sx, len_sy, rin_sx, rin_sy));\n\t\t\thash.add(convert(len_sx, len_sy, rin_sx, rin_sy));\n\t\t\t\n\t\t\tbfs(H, W);\t\n\t\t\t\n\t\t\tSystem.out.println(res ? \"Yes\" : \"No\");\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(char[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%c \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static final void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tint w;\n\tint h;\n\tchar[][] map = new char[2][100*100];\n\tint sl;\n\tint sr;\n\tpublic Main() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif(w==0 && h==0)\n\t\t\t\tbreak;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tString s0 = sc.next();\n\t\t\t\tString s1 = sc.next();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tmap[0][i*w+j] = s0.charAt(j);\n\t\t\t\t\tmap[1][i*w+j] = s1.charAt(w-j-1);\n\t\t\t\t\tif(map[0][i*w+j]=='L')\n\t\t\t\t\t\tsl = i*w+j;\n\t\t\t\t\tif(map[1][i*w+j]=='R')\n\t\t\t\t\t\tsr = i*w+j;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t\tSystem.gc();\n\t\t}\n\t}\n\n\tint[] dx = new int[]{-1, 0, 1, 0};\n\tint[] dy = new int[]{0, -1, 0, 1};\n\tprivate void solve() {\n\t\tLinkedList<int[]> queue = new LinkedList<int[]>();\n\t\t\n\t\tint[][] visited = new int[w*h][w*h];\n\t\tqueue.add(new int[]{sl, sr});\n\n\t\twhile(!queue.isEmpty()){\n\t\t\tint[] cp = queue.poll();\n\t\t\tint clp = cp[0];\n\t\t\tint crp = cp[1];\n\t\t\t\n\t\t\tif(visited[clp][crp]==1)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tvisited[clp][crp] = 1;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nlpx = clp%w +dx[i];\n\t\t\t\tint nlpy = clp/w +dy[i];\n\t\t\t\tint nrpx = crp%w +dx[i];\n\t\t\t\tint nrpy = crp/w +dy[i];\n\t\t\t\t\n\t\t\t\tif(nlpx<0 || w<=nlpx) nlpx = clp%w;\n\t\t\t\tif(nlpy<0 || h<=nlpy) nlpy = clp/w;\n\t\t\t\tif(nrpx<0 || w<=nrpx) nrpx = crp%w;\n\t\t\t\tif(nrpy<0 || h<=nrpy) nrpy = crp/w;\n\t\t\t\t\n\t\t\t\tint nlp = nlpx + nlpy*w;\n\t\t\t\tint nrp = nrpx + nrpy*w;\n\t\t\t\tif((nlp<0 || w*h<=nlp) && (nrp<0 || w*h<=nrp))\n\t\t\t\t\tcontinue;\n\t\t\t\telse if(nlp<0 || w*h<=nlp)\n\t\t\t\t\tnlp = clp;\n\t\t\t\telse if(nrp<0 || w*h<=nrp)\n\t\t\t\t\tnrp = crp;\n\t\t\t\t\n\t\t\t\tif(map[0][nlp]=='#' && map[1][nrp]=='#')\n\t\t\t\t\tcontinue;\n\t\t\t\tif(map[0][nlp]=='#')\n\t\t\t\t\tnlp = clp;\n\t\t\t\tif(map[1][nrp]=='#')\n\t\t\t\t\tnrp = crp;\n\t\t\t\t\n\t\t\t\tif(map[0][nlp]=='%' && map[1][nrp]=='%'){\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\tqueue.clear();\n\t\t\t\t\treturn;\n\t\t\t\t}else if(map[0][nlp]=='%' || map[1][nrp]=='%'){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\nif(visited[nlp][nrp]!=0)\n\t\t\t\tqueue.add(new int[]{nlp, nrp});\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"No\");\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tfinal int MOD = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif ((w | h) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tchar[][] f1 = new char[h][w];\n\t\t\tchar[][] f2 = new char[h][w];\n\t\t\tint sw1, sh1, sw2, sh2;\n\t\t\tsw1 = sh1 = sw2 = sh2 = 0;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString in1 = sc.next();\n\t\t\t\tString in2 = sc.next();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tf1[i][j] = in1.charAt(j);\n\t\t\t\t\tf2[i][j] = in2.charAt(j);\n\t\t\t\t\tif (f1[i][j] == 'L') {\n\t\t\t\t\t\tsw1 = j;\n\t\t\t\t\t\tsh1 = i;\n\t\t\t\t\t}\n\t\t\t\t\tif (f2[i][j] == 'R') {\n\t\t\t\t\t\tsw2 = j;\n\t\t\t\t\t\tsh2 = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean[][][][] visit = new boolean[h][w][h][w];\n\t\t\tboolean ok = false;\n\t\t\tvisit[sh1][sw1][sh2][sw2] = true;\n\t\t\tLinkedList<Pos> que = new LinkedList<Pos>();\n\t\t\tque.add(new Pos(sh1, sw1, sh2, sw2));\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tPos now = que.poll();\n\t\t\t\tif (f1[now.h1][now.w1] == '%' && f2[now.h2][now.w2] == '%') {\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint nh1 = now.h1 + dy[i];\n\t\t\t\t\tint nw1 = now.w1 + dx[i];\n\t\t\t\t\tint nh2 = now.h2 + dy[i];\n\t\t\t\t\tint nw2 = now.w2 + (dx[i] * -1);\n\t\t\t\t\tif (!inner(nh1, nw1, h, w) || f1[nh1][nw1] == '#') {\n\t\t\t\t\t\tnh1 = now.h1;\n\t\t\t\t\t\tnw1 = now.w1;\n\t\t\t\t\t}\n\t\t\t\t\tif (!inner(nh2, nw2, h, w) || f2[nh2][nw2] == '#') {\n\t\t\t\t\t\tnh2 = now.h2;\n\t\t\t\t\t\tnw2 = now.w2;\n\t\t\t\t\t}\n\t\t\t\t\tif ((f1[nh1][nw1] != '%' && f2[nh2][nw2] == '%')\n\t\t\t\t\t\t\t|| (f1[nh1][nw1] == '%' && f2[nh2][nw2] != '%')) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!visit[nh1][nw1][nh2][nw2]) {\n\t\t\t\t\t\tvisit[nh1][nw1][nh2][nw2] = true;\n\t\t\t\t\t\tque.add(new Pos(nh1, nw1, nh2, nw2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ok ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\n\tclass Pos {\n\t\tint w1;\n\t\tint h1;\n\t\tint w2;\n\t\tint h2;\n\n\t\tpublic Pos(int h1, int w1, int h2, int w2) {\n\t\t\tsuper();\n\t\t\tthis.h1 = h1;\n\t\t\tthis.w1 = w1;\n\t\t\tthis.h2 = h2;\n\t\t\tthis.w2 = w2;\n\t\t}\n\n\t\tvoid show() {\n\t\t\tSystem.out\n\t\t\t\t\t.println(\"now - > \" + h1 + \" \" + w1 + \" \" + h2 + \" \" + w2);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(char[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tboolean inner(int h, int w, int limH, int limW) {\n\t\treturn 0 <= h && h < limH && 0 <= w && w < limW;\n\t}\n\n\tvoid swap(int[] x, int a, int b) {\n\t\tint tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t}\n\n\t// find minimum i (a[i] >= border)\n\tint lower_bound(int a[], int border) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (border <= a[mid]) {\n\t\t\t\tr = mid;\n\t\t\t} else {\n\t\t\t\tl = mid;\n\t\t\t}\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] in = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextInt();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tint[][] nextInt2dArray(int n, int m) {\n\t\t\tint[][] in = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tchar[][] nextChar2dArray(int h, int w) {\n\t\t\tchar[][] in = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString row = sc.next();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tin[i][j] = row.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] in = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextDouble();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] in = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextLong();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\t\n\tint[] vx = {-1, 0, 1, 0};\n\tint[] vy = {0, -1, 0, 1};\n\t\n\tQueue<Integer> q = new LinkedList<Integer>();\n\tboolean[][][][] vis = new boolean[50][50][50][50];\n\t\n\tint getKey(int rx, int ry, int lx, int ly) {\n\t\treturn 1000000 * rx + 10000 * ry + 100 * lx + ly;\n\t}\n\t\n\tboolean inside(int x, int y, int n, int m) {\n\t\treturn 0 <= x && x < m && 0 <= y && y < n;\n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint m = in.nextInt(), n = in.nextInt();\n\t\t\tif (n == 0 && m == 0) break;\n\t\t\t\n\t\t\tfor (int i = 0; i < 50; i++) for (int j = 0; j < 50; j++) for (int k = 0; k < 50; k++) {\n\t\t\t\tArrays.fill(vis[i][j][k], false);\n\t\t\t}\n\t\t\tq.clear();\n\t\t\tchar[][] rin = new char[n][];\n\t\t\tchar[][] len = new char[n][];\n\t\t\tint rsx = -1, rsy = -1, lsx = -1, lsy = -1;\n\t\t\tint rgx = -1, rgy = -1, lgx = -1, lgy = -1;\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tlen[i] = in.next().toCharArray();\n\t\t\t\trin[i] = in.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tif (rin[i][j] == '%') {\n\t\t\t\t\t\trgx = j; rgy = i;\n\t\t\t\t\t} else if (rin[i][j] == 'R') {\n\t\t\t\t\t\trsx = j; rsy = i;\n\t\t\t\t\t}\n\t\t\t\t\tif (len[i][j] == '%') {\n\t\t\t\t\t\tlgx = j; lgy = i;\n\t\t\t\t\t} else if (len[i][j] == 'L') {\n\t\t\t\t\t\tlsx = j; lsy = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvis[rsx][rsy][lsx][lsy] = true;\n\t\t\tq.add(getKey(rsx, rsy, lsx, lsy));\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tint next = q.poll();\n\t\t\t\tint ly = next % 100;\n\t\t\t\tnext /= 100;\n\t\t\t\tint lx = next % 100;\n\t\t\t\tnext /= 100;\n\t\t\t\tint ry = next % 100;\n\t\t\t\tnext /= 100;\n\t\t\t\tint rx = next % 100;\n\t\t\t\t\t\t\t\t\n\t\t\t\tfor (int d = 0; d < vx.length; d++) {\n\t\t\t\t\tint nrx = rx + vx[d], nry = ry + vy[d];\n\t\t\t\t\tint nlx = lx - vx[d], nly = ly + vy[d];\n\t\t\t\t\t\n\t\t\t\t\tif (inside(nlx, nly, n, m) && inside(nrx, nry, n, m)) {\n\t\t\t\t\t\tif (rin[nry][nrx] == '#') {\n\t\t\t\t\t\t\tif (len[nly][nlx] == '#') {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnry = ry;\n\t\t\t\t\t\t\t\tnrx = rx;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (len[nly][nlx] == '#') {\n\t\t\t\t\t\t\t\tnly = ly;\n\t\t\t\t\t\t\t\tnlx = lx;\n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (vis[nrx][nry][nlx][nly]) continue;\n\t\t\t\t\t\tvis[nrx][nry][nlx][nly] = true;\n\t\t\t\t\t\tif (!((nrx == rgx && nry == rgy) || (nlx == lgx && nly == lgy))) {\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tq.add(getKey(nrx, nry, nlx, nly));\n\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(vis[rgx][rgy][lgx][lgy] ? \"Yes\" : \"No\");\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic int W,H;\n\t\t\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\tloop : while(true){\n\t\t\tW = in.nextInt();\n\t\t\tH = in.nextInt();\n\t\t\tif(W==0&&H==0) break;\n\t\t\tString[] left = new String[H];\n\t\t\tString[] right = new String[H];\n\t\t\tint goal = 0;\n\t\t\tint start = 0;\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tleft[i] = in.next();\n\t\t\t\tright[i] = in.next();\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tif(left[i].charAt(j)=='%'){\n\t\t\t\t\t\tgoal += (100*j + i)*10000;\n\t\t\t\t\t}else if(left[i].charAt(j)=='L'){\n\t\t\t\t\t\tstart += (100*j + i)*10000;\n\t\t\t\t\t}\n\t\t\t\t\tif(right[i].charAt(j)=='%'){\n\t\t\t\t\t\tgoal += 100*j + i;\n\t\t\t\t\t}else if(right[i].charAt(j)=='R'){\n\t\t\t\t\t\tstart += 100*j + i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean[] pos = new boolean[100000000];\n\t\t\tLinkedList<Integer> stack = new LinkedList<>();\n\t\t\tstack.push(start);\n\t\t\tpos[start] = true;\n\t\t\twhile(!stack.isEmpty()){\n\t\t\t\tint now = stack.pop();\n\t\t\t\t//UP\n\t\t\t\tint up = now;\n\t\t\t\tif(!isWall(getLx(now),getLy(now)-1,left)){\n\t\t\t\t\tup -= 10000;\n\t\t\t\t}\n\t\t\t\tif(!isWall(getRx(now),getRy(now)-1,right)){\n\t\t\t\t\tup -= 1;\n\t\t\t\t}\n\t\t\t\tif(up==goal){\n\t\t\t\t\tSystem.out.println(\"YES\"); continue loop;\n\t\t\t\t}\n\t\t\t\tif(!pos[up]){\n\t\t\t\t\tstack.add(up); pos[up] = true;\n\t\t\t\t}\n\t\t\t\t//DOWN\n\t\t\t\tint down = now;\n\t\t\t\tif(!isWall(getLx(now),getLy(now)+1,left)){\n\t\t\t\t\tdown += 10000;\n\t\t\t\t}\n\t\t\t\tif(!isWall(getRx(now),getRy(now)+1,right)){\n\t\t\t\t\tdown += 1;\n\t\t\t\t}\n\t\t\t\tif(down==goal){\n\t\t\t\t\tSystem.out.println(\"YES\"); continue loop;\n\t\t\t\t}\n\t\t\t\tif(!pos[down]){\n\t\t\t\t\tstack.add(down); pos[down] = true;\n\t\t\t\t}\n\t\t\t\t//into\n\t\t\t\tint into = now;\n\t\t\t\tif(!isWall(getLx(now)+1,getLy(now),left)){\n\t\t\t\t\tinto += 1000000;\n\t\t\t\t}\n\t\t\t\tif(!isWall(getRx(now)-1,getRy(now),right)){\n\t\t\t\t\tinto -= 100;\n\t\t\t\t}\n\t\t\t\tif(into==goal){\n\t\t\t\t\tSystem.out.println(\"YES\"); continue loop;\n\t\t\t\t}\n\t\t\t\tif(!pos[into]){\n\t\t\t\t\tstack.add(into); pos[into] = true;\n\t\t\t\t}\n\t\t\t\t//out\n\t\t\t\tint out = now;\n\t\t\t\tif(!isWall(getLx(now)-1,getLy(now),left)){\n\t\t\t\t\tout -= 1000000;\n\t\t\t\t}\n\t\t\t\tif(!isWall(getRx(now)+1,getRy(now),right)){\n\t\t\t\t\tout += 100;\n\t\t\t\t}\n\t\t\t\tif(out==goal){\n\t\t\t\t\tSystem.out.println(\"Yes\"); continue loop;\n\t\t\t\t}\n\t\t\t\tif(!pos[out]){\n\t\t\t\t\tstack.add(out); pos[out] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(\"No\");\n\t\t}\t\n\t}\n\t\n\tpublic static int getLx(int pos){\n\t\treturn pos/1000000;\n\t}\n\tpublic static int getLy(int pos){\n\t\treturn pos/10000 %100;\n\t}\n\tpublic static int getRx(int pos){\n\t\treturn pos/100 % 100;\n\t}\n\tpublic static int getRy(int pos){\n\t\treturn pos%100;\n\t}\n\tpublic static boolean isWall(int x,int y,String[] map){\n\t\treturn x<0 || x>=W || y<0 || y>=H || map[y].charAt(x) == '#';\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\n    int w,h;\n    char[][] l,r;\n    int lx,ly,rx,ry;\n    boolean found;\n    boolean[][][][] v;\n    int[] dx = {0,0,1,-1};\n    int[] dy = {1,-1,0,0};\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            w = sc.nextInt();\n            h = sc.nextInt();\n            if(w==0 && h==0) break;\n\n            l = new char[h][w];\n            r = new char[h][w];\n            for(int i=0; i<h; i++){\n                String s1 = sc.next();\n                String s2 = sc.next();\n                s2 = new StringBuffer(s2+\"\").reverse().toString();\n\n                l[i] = s1.toCharArray();\n                r[i] = s2.toCharArray();\n                for(int j=0; j<w; j++){\n                    if(l[i][j]=='L'){\n                        lx = j; ly = i;\n                    }\n                    if(r[i][j]=='R'){\n                        rx = j; ry = i;\n                    }\n                }\n            }\n\n            found = false;\n            v = new boolean[w][h][w][h];\n            bfs();\n\n            if(found) System.out.println(\"Yes\");\n            else System.out.println(\"No\");\n        }\n    }\n\n    void bfs(){\n        LinkedList<int[]> list = new LinkedList<int[]>();\n        list.add(new int[]{lx,ly,rx,ry});\n        \n        while(list.size()>0){\n            int[] lr = list.poll();\n            int xl = lr[0], yl = lr[1], xr = lr[2], yr = lr[3];\n\n            if(l[yl][xl]=='%' && r[yr][xr]=='%'){\n                found = true;\n                return;\n            }\n            if(l[yl][xl]=='%' || r[yr][xr]=='%') continue;\n\n            if(v[xl][yl][xr][yr]) continue;\n            v[xl][yl][xr][yr] = true;\n\n            for(int i=0; i<4; i++){\n                int nxl = xl+dx[i], nyl = yl+dy[i], nxr = xr+dx[i], nyr = yr+dy[i];\n                if(nxl<0 || nxl>=w || nyl<0 || nyl>=h || l[nyl][nxl]=='#'){\n                    nxl = xl; nyl = yl;\n                }\n                if(nxr<0 || nxr>=w || nyr<0 || nyr>=h || r[nyr][nxr]=='#'){\n                    nxr = xr; nyr = yr;\n                }\n                if(nxl==xl && nyl==yl && nxr==xr && nyr==yr) continue;\n                list.add(new int[]{nxl,nyl,nxr,nyr});\n            }\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\nimport java.util.Queue;\nimport java.util.ArrayDeque;\n\npublic class Main {\n\tpublic static boolean isValid(int W, int H, int x, int y) {\n\t\treturn 0<=x && x<H && 0<=y && y<W;\n\t}\n\n\tpublic static void walking(char[][] L, char[][] R, int H, int W, int lx, int ly, int rx, int ry) {\n\t\tint[][] vec = {{1,0,1,0},{-1,0,-1,0},{0,1,0,-1},{0,-1,0,1}};\n\t\tQueue<int[]> q = new ArrayDeque<int[]>();\n\t\tboolean[][][][] searched = new boolean[H][W][H][W];\n\t\tint[] st = {lx, ly, rx, ry};\n\t\tq.add(st);\n\t\tsearched[lx][ly][rx][ry] = true;\n\t\twhile(!q.isEmpty()) {\n\t\t\tint[] pos = q.remove();\n\t\t\t// System.out.println(\"[\"+pos[0]+\",\"+pos[1]+\",\"+pos[2]+\",\"+pos[3]+\"]\");\n\t\t\tlx = pos[0];\n\t\t\tly = pos[1];\n\t\t\trx = pos[2];\n\t\t\try = pos[3];\n\t\t\tfor(int[] d: vec) {\n\t\t\t\tint dlx = d[0];\n\t\t\t\tint dly = d[1];\n\t\t\t\tint drx = d[2];\n\t\t\t\tint dry = d[3];\n\t\t\t\tif(!isValid(W,H,lx+dlx,ly+dly)) {\n\t\t\t\t\tdlx = 0;\n\t\t\t\t\tdly = 0;\n\t\t\t\t}\n\t\t\t\tif(!isValid(W,H,rx+drx,ry+dry)) {\n\t\t\t\t\tdrx = 0;\n\t\t\t\t\tdry = 0;\n\t\t\t\t}\n\t\t\t\tif(L[lx+dlx][ly+dly]=='#') {\n\t\t\t\t\tdlx = 0;\n\t\t\t\t\tdly = 0;\n\t\t\t\t}\n\t\t\t\tif(R[rx+drx][ry+dry]=='#') {\n\t\t\t\t\tdrx = 0;\n\t\t\t\t\tdry = 0;\n\t\t\t\t}\n\t\t\t\tint[] newPos = {lx+dlx, ly+dly, rx+drx, ry+dry};\n\t\t\t\tif(searched[newPos[0]][newPos[1]][newPos[2]][newPos[3]]) continue;\n\t\t\t\tif(L[newPos[0]][newPos[1]] == '%' && R[newPos[2]][newPos[3]] == '%') {\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(L[newPos[0]][newPos[1]] != '%' && R[newPos[2]][newPos[3]] != '%') {\n\t\t\t\t\t// System.out.println(\"(\"+newPos[0]+\",\"+newPos[1]+\",\"+newPos[2]+\",\"+newPos[3]+\")\");\n\t\t\t\t\tq.add(newPos);\n\t\t\t\t\tsearched[newPos[0]][newPos[1]][newPos[2]][newPos[3]] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"No\");\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tFS r = new FS();\n\t\twhile(true) {\n\t\t\tint W = r.nextInt();\n\t\t\tint H = r.nextInt();\n\t\t\tif(W==0) break;\n\t\t\tchar[][] L = new char[H][W];\n\t\t\tchar[][] R = new char[H][W];\n\t\t\tint lx=-1;\n\t\t\tint ly=-1;\n\t\t\tint rx=-1;\n\t\t\tint ry=-1;\n\t\t\tfor(int i=0; i<H; i++) {\n\t\t\t\tString sl = r.next();\n\t\t\t\tString sr = r.next();\n\t\t\t\tfor(int j=0; j<W; j++) {\n\t\t\t\t\tL[i][j] = sl.charAt(j);\n\t\t\t\t\tR[i][j] = sr.charAt(j);\n\t\t\t\t\tif(L[i][j]=='L') {\n\t\t\t\t\t\tlx = i;\n\t\t\t\t\t\tly = j;\n\t\t\t\t\t}\n\t\t\t\t\tif(R[i][j]=='R') {\n\t\t\t\t\t\trx = i;\n\t\t\t\t\t\try = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twalking(L,R,H,W,lx,ly,rx,ry);\n\t\t}\n\t}\n\t\n\tpublic static void solver() {\n\t\t// write logic\n\t}\n\t\n\t// Read Class\n\tstatic class FS {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\n\t\tprivate int readByte() { return hasNextByte() ? buffer[ptr++] : -1;}\n\t\tprivate boolean isPrintableChar(int c) {return 33 <= c && c <= 126;}\n\t\tprivate void skipUnprintable() {while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\t\n\t\tpublic boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t\tpublic String next() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile(isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile(true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if(b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Scanner;\nimport java.util.Queue;\nimport java.util.ArrayDeque;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        MirrorCave solver = new MirrorCave();\n        try {\n            int testNumber = 1;\n            while (true)\n                solver.solve(testNumber++, in, out);\n        } catch (UnknownError e) {\n            out.close();\n        }\n    }\n\n    static class MirrorCave {\n        final int[] dh = new int[]{0, -1, 0, 1};\n        final int[] dw = new int[]{-1, 0, 1, 0};\n        final int[] dh2 = new int[]{0, -1, 0, 1};\n        final int[] dw2 = new int[]{1, 0, -1, 0};\n\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int W = in.nextInt();\n            int H = in.nextInt();\n            if (W == 0) {\n                throw new UnknownError();\n            }\n            String[] L = new String[H + 2];\n            String[] R = new String[H + 2];\n            L[0] = R[0] = L[H + 1] = R[H + 1] = new String();\n            for (int i = 0; i < W + 2; ++i) {\n                L[0] += \"#\";\n                R[0] += \"#\";\n                R[H + 1] += \"#\";\n                L[H + 1] += \"#\";\n            }\n            int lh = -1, lw = -1, rh = -1, rw = -1;\n            int glh = -1, glw = -1, grh = -1, grw = -1;\n            for (int i = 0; i < H; ++i) {\n                L[i + 1] = \"#\" + in.next() + \"#\";\n                R[i + 1] = \"#\" + in.next() + \"#\";\n                for (int j = 0; j < L[i + 1].length(); ++j) {\n                    if (L[i + 1].charAt(j) == 'L') {\n                        lh = i + 1;\n                        lw = j;\n                    }\n                    if (R[i + 1].charAt(j) == 'R') {\n                        rh = i + 1;\n                        rw = j;\n                    }\n                    if (L[i + 1].charAt(j) == '%') {\n                        glh = i + 1;\n                        glw = j;\n                    }\n                    if (R[i + 1].charAt(j) == '%') {\n                        grh = i + 1;\n                        grw = j;\n                    }\n                }\n            }\n            boolean[][][][] vis = new boolean[H + 2][W + 2][H + 2][W + 2];\n            for (int i = 0; i < vis.length; ++i) {\n                for (int j = 0; j < vis[i].length; ++j) {\n                    for (int k = 0; k < vis[i][j].length; ++k) {\n                        Arrays.fill(vis[i][j][k], false);\n                    }\n                }\n            }\n            Queue<State> q = new ArrayDeque<>();\n            q.add(new State(lh, lw, rh, rw));\n            //for (String e : L) System.err.println(e);\n            //for (String e : R) System.err.println(e);\n            vis[lh][lw][rh][rw] = true;\n            while (!q.isEmpty()) {\n                State now = q.poll();\n                for (int i = 0; i < 4; ++i) {\n                    State next = new State(now.lh + dh[i], now.lw + dw[i], now.rh + dh2[i], now.rw + dw2[i]);\n                    if (L[next.lh].charAt(next.lw) == '#' && R[next.rh].charAt(next.rw) == '#') {\n                        continue;\n                    } else if (L[next.lh].charAt(next.lw) == '#') {\n                        next.lh = now.lh;\n                        next.lw = now.lw;\n                    } else if (R[next.rh].charAt(next.rw) == '#') {\n                        next.rh = now.rh;\n                        next.rw = now.rw;\n                    }\n                    if (!vis[next.lh][next.lw][next.rh][next.rw]) {\n                        if ((next.lh == glh && next.lw == glw) ^ (next.rh == grh && next.rw == grw)) {\n                            continue;\n                        }\n                        if (next.lh == glh && next.rh == grh && next.lw == glw && next.rw == grw) {\n                            out.println(\"Yes\");\n                            System.gc();\n                            return;\n                        }\n                        vis[next.lh][next.lw][next.rh][next.rw] = true;\n                        q.add(next);\n                    }\n                }\n            }\n            out.println(\"No\");\n            System.gc();\n            return;\n        }\n\n        public class State {\n            int lh;\n            int lw;\n            int rh;\n            int rw;\n\n            State(int lh, int lw, int rh, int rw) {\n                this.lh = lh;\n                this.lw = lw;\n                this.rh = rh;\n                this.rw = rw;\n            }\n\n        }\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tHashSet<Integer> hash = new HashSet<Integer>();\t\n\tPriorityQueue<State> pq = new PriorityQueue<State>();\n\tboolean res;\n\tchar[][] len, rin;\n\n\tint[] vx = {0, -1, 1, 0};\n\tint[] vy = {-1, 0, 0, 1};\n\t\n\tclass State implements Comparable<State> {\n\t\tint len_x, len_y, rin_x, rin_y;\n\t\t\n\t\tState(int len_x, int len_y, int rin_x, int rin_y) {\n\t\t\tthis.len_x = len_x;\n\t\t\tthis.len_y = len_y;\n\t\t\tthis.rin_x = rin_x;\n\t\t\tthis.rin_y = rin_y;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(State o) {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tpublic String toString() {\n\t\t\treturn len_x + \" \" + len_y + \" \" + rin_x + \" \" + rin_y;\n\t\t}\n\t}\n\t\n\tboolean isOk(int x, int y, int H, int W, char[][] map) {\n\t\treturn x >= 0 && x < W && y >= 0 && y < H && map[y][x] != '#';\n\t}\n\t\n\tvoid bfs(int H, int W) {\n\t\twhile (!pq.isEmpty()) {\n\t\t\tState s = pq.poll();\n\t\t\tfor (int i = 0; i < vx.length; i++) {\n\t\t\t\tint len_nx = s.len_x + vx[i];\n\t\t\t\tint len_ny = s.len_y + vy[i];\n\t\t\t\tint rin_nx = s.rin_x - vx[i];\n\t\t\t\tint rin_ny = s.rin_y + vy[i];\n\t\t\t\tif (!isOk(len_nx, len_ny, H, W, len)) {\n\t\t\t\t\tlen_nx -= vx[i];\n\t\t\t\t\tlen_ny -= vy[i];\n\t\t\t\t}\n\t\t\t\tif (!isOk(rin_nx, rin_ny, H, W, rin)) {\n\t\t\t\t\trin_nx += vx[i];\n\t\t\t\t\trin_ny -= vy[i];\n\t\t\t\t}\n\t\t\t\tint hashValue = convert(len_nx, len_ny, rin_nx, rin_ny);\n\t\t\t\tif (!hash.contains(hashValue)) {\n\t\t\t\t\tif ((len[len_ny][len_nx] != '%' && rin[rin_ny][rin_nx] == '%') ||\n\t\t\t\t\t\t(len[len_ny][len_nx] == '%' && rin[rin_ny][rin_nx] != '%')) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tpq.add(new State(len_nx, len_ny, rin_nx, rin_ny));\n\t\t\t\t\thash.add(hashValue);\n\t\t\t\t\tif (len[len_ny][len_nx] == '%' && rin[rin_ny][rin_nx] == '%') res = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint convert(int len_x, int len_y, int rin_x, int rin_y) {\n\t\treturn len_x * 50*50*50 + len_y * 50*50 + rin_x * 50 + rin_y;\n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint W = in.nextInt(), H = in.nextInt();\n\t\t\tif (W == 0) break;\n\t\t\thash.clear();\n\t\t\tres = false;\n\t\t\t\n\t\t\tlen = new char[H][W];\n\t\t\trin = new char[H][W];\n\t\t\t\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tlen[i] = in.next().toCharArray();\n\t\t\t\trin[i] = in.next().toCharArray();\n\t\t\t}\n\t\t\t\n\t\t\tint len_sx = 0, len_sy = 0, rin_sx = 0, rin_sy = 0;\n\t\t\t\n\t\t\tfor (int i = 0; i < H; i++) for (int j = 0; j < W; j++) {\n\t\t\t\tif (len[i][j] == 'L') {\n\t\t\t\t\tlen_sx = j;\n\t\t\t\t\tlen_sy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < H; i++) for (int j = 0; j < W; j++) {\n\t\t\t\tif (rin[i][j] == 'R') {\n\t\t\t\t\trin_sx = j;\n\t\t\t\t\trin_sy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tpq.clear();\n\t\t\tpq.add(new State(len_sx, len_sy, rin_sx, rin_sy));\n\t\t\thash.add(convert(len_sx, len_sy, rin_sx, rin_sy));\n\t\t\t\n\t\t\tbfs(H, W);\t\n\t\t\t\n\t\t\tSystem.out.println(res ? \"Yes\" : \"No\");\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(char[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%c \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tprivate static final int[][] d = { { -1, 0 }, { 1, 0 }, { 0, 1 }, { 0, -1 } };\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint W = sc.nextInt();\n\t\t\tif (W == 0) {\n\t\t\t\tsc.close();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint H = sc.nextInt();\n\n\t\t\tchar[][] mapL = new char[H + 2][];\n\t\t\tchar[][] mapR = new char[H + 2][];\n\n\t\t\tchar[] wall = new char[W + 2];\n\t\t\tArrays.fill(wall, '#');\n\t\t\tmapL[0] = wall;\n\t\t\tmapR[0] = wall;\n\t\t\tmapL[H + 1] = wall;\n\t\t\tmapR[H + 1] = wall;\n\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tString lineL = \"#\" + sc.next() + \"#\";\n\t\t\t\tmapL[i + 1] = lineL.toCharArray();\n\t\t\t\tString lineR = \"#\" + sc.next() + \"#\";\n\t\t\t\tmapR[i + 1] = lineR.toCharArray();\n\t\t\t}\n\n\t\t\tInteger[] posi = new Integer[4];\n\t\t\tfor (int i = 0; i < mapL.length; i++) {\n\t\t\t\tfor (int j = 0; j < mapL[i].length; j++) {\n\t\t\t\t\tif (mapL[i][j] == 'L') {\n\t\t\t\t\t\tposi[0] = i;\n\t\t\t\t\t\tposi[1] = j;\n\t\t\t\t\t}\n\t\t\t\t\tif (mapR[i][j] == 'R') {\n\t\t\t\t\t\tposi[2] = i;\n\t\t\t\t\t\tposi[3] = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean[][] used = new boolean[5051][5051];\n\t\t\tDeque<Integer[]> bfs = new ArrayDeque<Integer[]>();\n\t\t\tbfs.addLast(posi);\n\t\t\tused[posi[0] * 100 + posi[1]][posi[2] * 100 + posi[3]] = true;\n\t\t\tboolean cleared = false;\n\t\t\tbfs: while (!bfs.isEmpty()) {\n\t\t\t\tInteger[] poll = bfs.pollFirst();\n\t\t\t\tint iL = poll[0];\n\t\t\t\tint jL = poll[1];\n\t\t\t\tint iR = poll[2];\n\t\t\t\tint jR = poll[3];\n\n\t\t\t\tfor (int i = 0; i < d.length; i++) {\n\t\t\t\t\tchar nextL = mapL[iL + d[i][0]][jL + d[i][1]];\n\t\t\t\t\tchar nextR = mapR[iR + d[i][0]][jR - d[i][1]];\n\n\t\t\t\t\tif (nextL == '#' && nextR == '#') {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (nextL == '%' && nextR == '%') {\n\t\t\t\t\t\t// YES\n\t\t\t\t\t\tcleared = true;\n\t\t\t\t\t\tbreak bfs;\n\t\t\t\t\t} else if ((nextL == '%' && nextR != '%') || (nextL != '%' && nextR == '%')) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (nextL == '#' && nextR == '.' && !used[iL * 100 + jL][(iR + d[i][0]) * 100 + jR - d[i][1]]) {\n\t\t\t\t\t\t\tused[iL * 100 + jL][(iR + d[i][0]) * 100 + jR - d[i][1]] = true;\n\t\t\t\t\t\t\tInteger[] push = { iL, jL, iR + d[i][0], jR - d[i][1] };\n\t\t\t\t\t\t\tbfs.addLast(push);\n\t\t\t\t\t\t} else if (nextR == '#' && nextL == '.'\n\t\t\t\t\t\t\t\t&& !used[(iL + d[i][0]) * 100 + jL + d[i][1]][iR * 100 + jR]) {\n\t\t\t\t\t\t\tused[(iL + d[i][0]) * 100 + jL + d[i][1]][iR * 100 + jR] = true;\n\t\t\t\t\t\t\tInteger[] push = { iL + d[i][0], jL + d[i][1], iR, jR };\n\t\t\t\t\t\t\tbfs.addLast(push);\n\t\t\t\t\t\t} else if (nextL == '.' && nextR == '.'\n\t\t\t\t\t\t\t\t&& !used[(iL + d[i][0]) * 100 + jL + d[i][1]][(iR + d[i][0]) * 100 + jR - d[i][1]]) {\n\t\t\t\t\t\t\tused[(iL + d[i][0]) * 100 + jL + d[i][1]][(iR + d[i][0]) * 100 + jR - d[i][1]] = true;\n\t\t\t\t\t\t\tInteger[] push = { iL + d[i][0], jL + d[i][1], iR + d[i][0], jR - d[i][1] };\n\t\t\t\t\t\t\tbfs.addLast(push);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cleared) {\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t\tSystem.gc();\n\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Scanner;\nimport java.util.Queue;\nimport java.util.ArrayDeque;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        MirrorCave solver = new MirrorCave();\n        try {\n            int testNumber = 1;\n            while (true)\n                solver.solve(testNumber++, in, out);\n        } catch (UnknownError e) {\n            out.close();\n        }\n    }\n\n    static class MirrorCave {\n        int dh = new int[]{0, -1, 0, 1};\n        int dw = new int[]{-1, 0, 1, 0};\n        int dh2 = new int[]{0, -1, 0, 1};\n        int dw2 = new int[]{1, 0, -1, 0};\n\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int W = in.nextInt();\n            int H = in.nextInt();\n            if (W == 0) {\n                throw new UnknownError();\n            }\n            String[] L = new String[H];\n            String[] R = new String[H];\n            int lh = -1, lw = -1, rh = -1, rw = -1;\n            int glh = -1, glw = -1, grh = -1, grw = -1;\n            for (int i = 0; i < H; ++i) {\n                L[i] = in.next();\n                R[i] = in.next();\n                for (int j = 0; j < W; ++j) {\n                    if (L[i].charAt(j) == 'L') {\n                        lh = i;\n                        lw = j;\n                    }\n                    if (R[i].charAt(j) == 'R') {\n                        rh = i;\n                        rw = j;\n                    }\n                    if (L[i].charAt(j) == '%') {\n                        glh = i;\n                        glw = j;\n                    }\n                    if (R[i].charAt(j) == '%') {\n                        grh = i;\n                        grw = j;\n                    }\n                }\n            }\n            boolean[][][][] vis = new boolean[H][W][H][W];\n            for (int i = 0; i < H; ++i) {\n                for (int j = 0; j < W; ++j) {\n                    for (int k = 0; k < H; ++k) {\n                        Arrays.fill(vis[i][j][k], false);\n                    }\n                }\n            }\n            Queue<State> q = new ArrayDeque<>();\n            q.add(new State(lh, lw, rh, rw));\n            while (!q.isEmpty()) {\n                State now = q.poll();\n                if (vis[now.lh][now.lw][now.rh][now.rw]) {\n                    continue;\n                }\n                vis[now.lh][now.lw][now.rh][now.rw] = true;\n                if (now.lh == glh && now.rh == grh && now.lw == glw && now.rw == grw) {\n                    out.println(\"Yes\");\n                    return;\n                }\n                for (int i = 0; i < 4; ++i) {\n                    State next = new State(now.lh + dh[i], now.lw + dw[i], now.rh + dh2[i], now.rw + dw2[i]);\n                    if (0 <= next.lh && next.lh < H && 0 <= next.lw && next.lw < W && 0 <= next.rh && next.rh < H && 0 <= next.rw && next.rw < W) {\n                        if (L[next.lh].charAt(next.lw) == '#') {\n                            if (next.lh != now.lh) {\n                                next.lh = now.lh;\n                            }\n                            if (next.lw != now.lw) {\n                                next.lw = now.lw;\n                            }\n                        }\n                        if (R[next.rh].charAt(next.rw) == '#') {\n                            if (next.rh != now.rh) {\n                                next.rh = now.rh;\n                            }\n                            if (next.rw != now.rw) {\n                                next.rw = now.rw;\n                            }\n                        }\n                        if (vis[next.lh][next.lw][next.rh][next.rw]) {\n                            continue;\n                        }\n                        q.add(next);\n                    }\n                }\n            }\n            out.println(\"No\");\n            return;\n        }\n\n        public class State {\n            int lh;\n            int lw;\n            int rh;\n            int rw;\n\n            State(int lh, int lw, int rh, int rw) {\n                this.lh = lh;\n                this.lw = lw;\n                this.rh = rh;\n                this.rw = rw;\n            }\n\n        }\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\n// Mirror Cave\n// 2013/05/12\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint m, n;\n\tint[][] al, ar;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tm=sc.nextInt();\n\t\t\tn=sc.nextInt();\n\t\t\tif((m|n)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tal=new int[n][m];\n\t\t\tar=new int[n][m];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tString sl=sc.next();\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\tal[j][i]=c2i(sl.charAt(i));\n\t\t\t\t}\n\t\t\t\tString sr=sc.next();\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\tar[j][i]=c2i(sr.charAt(i));\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tint B=50;\n\tboolean[][][][] visited=new boolean[B][B][B][B];\n\n\tvoid solve(){\n\t\tfor(int a=0; a<B; a++){\n\t\t\tfor(int b=0; b<B; b++){\n\t\t\t\tfor(int c=0; c<B; c++){\n\t\t\t\t\tfor(int d=0; d<B; d++){\n\t\t\t\t\t\tvisited[a][b][c][d]=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint xl0=0, yl0=0, xr0=0, yr0=0;\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tif(al[j][i]==-1){\n\t\t\t\t\txl0=i;\n\t\t\t\t\tyl0=j;\n\t\t\t\t\tal[j][i]=0;\n\t\t\t\t}\n\t\t\t\tif(ar[j][i]==-1){\n\t\t\t\t\txr0=i;\n\t\t\t\t\tyr0=j;\n\t\t\t\t\tar[j][i]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tLinkedList<Integer> que=new LinkedList<Integer>();\n\t\tque.offer(hash(xl0, yl0, xr0, yr0));\n\t\tint[] dxl={0, 0, -1, 1};\n\t\tint[] dyl={-1, 1, 0, 0};\n\t\tint[] dxr={0, 0, 1, -1};\n\t\tint[] dyr={-1, 1, 0, 0};\n\n\t\tboolean yes=false;\n\n\t\tfor(; !que.isEmpty()&&!yes;){\n\t\t\tint p=que.poll();\n\t\t\tint xl=p/B/B/B%B, yl=p/B/B%B, xr=p/B%B, yr=p%B;\n\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\tint xl2=xl+dxl[i], yl2=yl+dyl[i], xr2=xr+dxr[i], yr2=yr+dyr[i];\n\t\t\t\tif(!in(xl2, yl2)||al[yl2][xl2]==1){\n\t\t\t\t\txl2=xl;\n\t\t\t\t\tyl2=yl;\n\t\t\t\t}\n\t\t\t\tif(!in(xr2, yr2)||ar[yr2][xr2]==1){\n\t\t\t\t\txr2=xr;\n\t\t\t\t\tyr2=yr;\n\t\t\t\t}\n\t\t\t\tboolean ll=al[yl2][xl2]==2;\n\t\t\t\tboolean rr=ar[yr2][xr2]==2;\n\t\t\t\tif(ll^rr){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(ll&&rr){\n\t\t\t\t\tyes=true;\n\t\t\t\t}\n\t\t\t\tif(!visited[xl2][yl2][xr2][yr2]){\n\t\t\t\t\tvisited[xl2][yl2][xr2][yr2]=true;\n\t\t\t\t\tque.offer(hash(xl2, yl2, xr2, yr2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintln(yes?\"Yes\":\"No\");\n\t}\n\n\tint hash(int xl, int yl, int xr, int yr){\n\t\treturn (xl*50+yl)*2500+(xr*50+yr);\n\t}\n\n\tboolean in(int x, int y){\n\t\treturn x>=0&&x<m&&y>=0&&y<n;\n\t}\n\n\tint c2i(char c){\n\t\tswitch(c){\n\t\tcase '.':\n\t\t\treturn 0;\n\t\tcase '#':\n\t\t\treturn 1;\n\t\tcase '%':\n\t\t\treturn 2;\n\t\tcase 'L':\n\t\t\treturn -1;\n\t\tcase 'R':\n\t\t\treturn -1;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.BitSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\npublic class Main{\n\tpublic static final int[] dx = {1, 0, -1, 0};\n\tpublic static final int[] dy = {0, 1, 0, -1};\n\tpublic static int w, h;\n\tpublic static char[][][] map;\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = in.nextInt();\n\t\t\th = in.nextInt();\n\t\t\tif(w == 0) break;\n\t\t\tmap = new char[2][h][w];\n\t\t\tint g = 0;\n\t\t\tint s = 0;\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\tfor(int j=0; j<2; j++){\n\t\t\t\t\tchar[] line = in.next().toCharArray();\n\t\t\t\t\tif(j==0) map[j][i] = line;\n\t\t\t\t\telse{\n\t\t\t\t\t\tfor(int k=0; k<w; k++){\n\t\t\t\t\t\t\tmap[j][i][k] = line[w-1-k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0; k<w; k++){\n\t\t\t\t\t\tswitch(map[j][i][k]){\n\t\t\t\t\t\tcase 'R':\n\t\t\t\t\t\t\ts += i*w+k;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'L':\n\t\t\t\t\t\t\ts += (i*w+k)*h*w;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '%':\n\t\t\t\t\t\t\tg += id(j, i, k);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tBitSet used = new BitSet(w*w*h*h);\n\t\t\tQueue<Integer> qu = new LinkedList<Integer>();\n\t\t\tqu.add(s);\n\t\t\tused.set(s);\n\t\t\tint hw = h*w;\n\t\t\tint whw = w*h*w;\n\t\t\tboolean flag = false;\n\t\t\twhile(!qu.isEmpty()){\n\t\t\t\tint id = qu.poll();\n\t\t\t\tif(id == g){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint y0 = id/whw;\n\t\t\t\tid %= whw;\n\t\t\t\tint x0 = id/hw;\n\t\t\t\tid %= hw;\n\t\t\t\tint y1 = id/w;\n\t\t\t\tint x1 = id%w;\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tint nid = next(x0, y0, x1, y1, i);\n\t\t\t\t\tif(used.get(nid)) continue;\n\t\t\t\t\tused.set(nid);\n\t\t\t\t\tqu.add(nid);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(flag ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\t\n\tpublic static String dump(char[][] map){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tsb.append(map[i][j]+\" \");\n\t\t\t}\n\t\t\tsb.append('\\n');\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tpublic static int next(int x0, int y0, int x1, int y1, int dir){\n\t\tint nx0 = x0 + dx[dir];\n\t\tint ny0 = y0 + dy[dir];\n\t\tif(nx0 < 0 || nx0 >= w || ny0 < 0 || ny0 >= h\n\t\t\t\t|| map[0][ny0][nx0] == '#'){\n\t\t\tnx0 = x0;\n\t\t\tny0 = y0;\n\t\t}\n\t\tint nx1 = x1 + dx[dir];\n\t\tint ny1 = y1 + dy[dir];\n\t\tif(nx1 < 0 || nx1 >= w || ny1 < 0 || ny1 >= h\n\t\t\t\t|| map[1][ny1][nx1] == '#'){\n\t\t\tnx1 = x1;\n\t\t\tny1 = y1;\n\t\t}\n\t\treturn id(0, ny0, nx0) + id(1, ny1, nx1);\n\t}\n\t\n\tpublic static int id(int room, int y, int x){\n\t\treturn room==0 ? (y*w+x)*w*h : y*w+x;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tfinal int MOD = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif ((w | h) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tchar[][] f1 = new char[h][w];\n\t\t\tchar[][] f2 = new char[h][w];\n\t\t\tint sw1, sh1, sw2, sh2;\n\t\t\tsw1 = sh1 = sw2 = sh2 = 0;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString in1 = sc.next();\n\t\t\t\tString in2 = sc.next();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tf1[i][j] = in1.charAt(j);\n\t\t\t\t\tf2[i][j] = in2.charAt(j);\n\t\t\t\t\tif (f1[i][j] == 'L') {\n\t\t\t\t\t\tsw1 = j;\n\t\t\t\t\t\tsh1 = i;\n\t\t\t\t\t}\n\t\t\t\t\tif (f2[i][j] == 'R') {\n\t\t\t\t\t\tsw2 = j;\n\t\t\t\t\t\tsh2 = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean[][][][] visit = new boolean[h][w][h][w];\n\t\t\tboolean ok = false;\n\t\t\tvisit[sh1][sw1][sh2][sw2] = true;\n\t\t\tLinkedList<Pos> que = new LinkedList<Pos>();\n\t\t\tque.add(new Pos(sh1, sw1, sh2, sw2));\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tPos now = que.poll();\n\t\t\t\tif (f1[now.h1][now.w1] == '%' && f2[now.h2][now.w2] == '%') {\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint nh1 = now.h1 + dy[i];\n\t\t\t\t\tint nw1 = now.w1 + dx[i];\n\t\t\t\t\tint nh2 = now.h2 + dy[i];\n\t\t\t\t\tint nw2 = now.w2 + (dx[i] * -1);\n\t\t\t\t\tif (!inner(nh1, nw1, h, w) || f1[nh1][nw1] == '#') {\n\t\t\t\t\t\tnh1 = now.h1;\n\t\t\t\t\t\tnw1 = now.w1;\n\t\t\t\t\t}\n\t\t\t\t\tif (!inner(nh2, nw2, h, w) || f2[nh2][nw2] == '#') {\n\t\t\t\t\t\tnh2 = now.h2;\n\t\t\t\t\t\tnw2 = now.w2;\n\t\t\t\t\t}\n\t\t\t\t\tif (!visit[nh1][nw1][nh2][nw2]) {\n\t\t\t\t\t\tvisit[nh1][nw1][nh2][nw2] = true;\n\t\t\t\t\t\tque.add(new Pos(nh1, nw1, nh2, nw2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ok ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\n\tclass Pos {\n\t\tint w1;\n\t\tint h1;\n\t\tint w2;\n\t\tint h2;\n\n\t\tpublic Pos(int h1, int w1, int h2, int w2) {\n\t\t\tsuper();\n\t\t\tthis.h1 = h1;\n\t\t\tthis.w1 = w1;\n\t\t\tthis.h2 = h2;\n\t\t\tthis.w2 = w2;\n\t\t}\n\n\t\tvoid show() {\n\t\t\tSystem.out.println(h1 + \" \" + w1 + \" \" + h2 + \" \" + w2);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(char[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tboolean inner(int h, int w, int limH, int limW) {\n\t\treturn 0 <= h && h < limH && 0 <= w && w < limW;\n\t}\n\n\tvoid swap(int[] x, int a, int b) {\n\t\tint tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t}\n\n\t// find minimum i (a[i] >= border)\n\tint lower_bound(int a[], int border) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (border <= a[mid]) {\n\t\t\t\tr = mid;\n\t\t\t} else {\n\t\t\t\tl = mid;\n\t\t\t}\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] in = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextInt();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tint[][] nextInt2dArray(int n, int m) {\n\t\t\tint[][] in = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tchar[][] nextChar2dArray(int h, int w) {\n\t\t\tchar[][] in = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString row = sc.next();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tin[i][j] = row.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] in = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextDouble();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] in = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextLong();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tfinal int MOD = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif ((w | h) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tchar[][] f1 = new char[h][w];\n\t\t\tchar[][] f2 = new char[h][w];\n\t\t\tint sw1, sh1, sw2, sh2;\n\t\t\tsw1 = sh1 = sw2 = sh2 = 0;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString in1 = sc.next();\n\t\t\t\tString in2 = sc.next();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tf1[i][j] = in1.charAt(j);\n\t\t\t\t\tf2[i][j] = in2.charAt(j);\n\t\t\t\t\tif (f1[i][j] == 'L') {\n\t\t\t\t\t\tsw1 = j;\n\t\t\t\t\t\tsh1 = i;\n\t\t\t\t\t}\n\t\t\t\t\tif (f2[i][j] == 'R') {\n\t\t\t\t\t\tsw2 = j;\n\t\t\t\t\t\tsh2 = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean[][][][] visit = new boolean[h][w][h][w];\n\t\t\tboolean ok = false;\n\t\t\tvisit[sh1][sw1][sh2][sw2] = true;\n\t\t\tLinkedList<Pos> que = new LinkedList<Pos>();\n\t\t\tque.add(new Pos(sh1, sw1, sh2, sw2));\n\t\t\twhile (!que.isEmpty()) {\n\t\t\t\tPos now = que.poll();\n\t\t\t\tif (f1[now.h1][now.w1] == '%' && f2[now.h2][now.w2] == '%') {\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint nh1 = now.h1 + dy[i];\n\t\t\t\t\tint nw1 = now.w1 + dx[i];\n\t\t\t\t\tint nh2 = now.h2 + dy[i];\n\t\t\t\t\tint nw2 = now.w2 + (dx[i] * -1);\n\t\t\t\t\tif (!inner(nh1, nw1, h, w) || f1[nh1][nw1] == '#') {\n\t\t\t\t\t\tnh1 = now.h1;\n\t\t\t\t\t\tnw1 = now.w1;\n\t\t\t\t\t}\n\t\t\t\t\tif (!inner(nh2, nw2, h, w) || f2[nh2][nw2] == '#') {\n\t\t\t\t\t\tnh2 = now.h2;\n\t\t\t\t\t\tnw2 = now.w2;\n\t\t\t\t\t}\n\t\t\t\t\tif ((f1[nh1][nw1] != '%' && f2[nh2][nw2] == '%')\n\t\t\t\t\t\t\t|| (f1[nh1][nw1] == '%' && f2[nh2][nw2] != '%')) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!visit[nh1][nw1][nh2][nw2]) {\n\t\t\t\t\t\tvisit[nh1][nw1][nh2][nw2] = true;\n\t\t\t\t\t\tque.add(new Pos(nh1, nw1, nh2, nw2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ok ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\n\tclass Pos {\n\t\tint w1;\n\t\tint h1;\n\t\tint w2;\n\t\tint h2;\n\n\t\tpublic Pos(int h1, int w1, int h2, int w2) {\n\t\t\tsuper();\n\t\t\tthis.h1 = h1;\n\t\t\tthis.w1 = w1;\n\t\t\tthis.h2 = h2;\n\t\t\tthis.w2 = w2;\n\t\t}\n\n\t\tvoid show() {\n\t\t\tSystem.out\n\t\t\t\t\t.println(\"now - > \" + h1 + \" \" + w1 + \" \" + h2 + \" \" + w2);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew?\\Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(char[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tboolean inner(int h, int w, int limH, int limW) {\n\t\treturn 0 <= h && h < limH && 0 <= w && w < limW;\n\t}\n\n\tvoid swap(int[] x, int a, int b) {\n\t\tint tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t}\n\n\t// find minimum i (a[i] >= border)\n\tint lower_bound(int a[], int border) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (border <= a[mid]) {\n\t\t\t\tr = mid;\n\t\t\t} else {\n\t\t\t\tl = mid;\n\t\t\t}\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] in = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextInt();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tint[][] nextInt2dArray(int n, int m) {\n\t\t\tint[][] in = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tchar[][] nextChar2dArray(int h, int w) {\n\t\t\tchar[][] in = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString row = sc.next();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tin[i][j] = row.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] in = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextDouble();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] in = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextLong();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.BitSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static int w, h;\n\tpublic static char[][][] map = new char[50][50][2];\n\tpublic static final int[] dx = {1, 0, -1, 0};\n\tpublic static final int[] dy = {0, 1, 0, -1};\n\tpublic static int[] gx = new int[2];\n\tpublic static int[] gy = new int[2];\n\tpublic static int[] sx = new int[2];\n\tpublic static int[] sy = new int[2];\n\tpublic static BitSet used = new BitSet(50*50*50*50);\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = in.nextInt();\n\t\t\th = in.nextInt();\n\t\t\tif(w == 0) break;\n//\t\t\tmap = new char[2][h][w];\n\t\t\tfor(int j=0; j<h; j++){\n\t\t\t\tfor(int i=0; i<2; i++){\n\t\t\t\t\tmap[i][j] = in.next().toCharArray();\n\t\t\t\t\tfor(int k=0; k<w; k++){\n\t\t\t\t\t\tif(map[i][j][k] == '%'){\n\t\t\t\t\t\t\tgx[i] = k;\n\t\t\t\t\t\t\tgy[i] = j;\n\t\t\t\t\t\t}else if(map[i][j][k] == 'L' || map[i][j][k] == 'R'){\n\t\t\t\t\t\t\tsx[i] = k;\n\t\t\t\t\t\t\tsy[i] = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tused.clear();\n\t\t\tQueue<Pos> qu = new LinkedList<Pos>();\n\t\t\tqu.add(new Pos(sy[0], sx[0], sy[1], sx[1]));\n\t\t\tused.set(qu.peek().id);\n\t\t\tboolean goal = false;\n\t\t\twhile(!qu.isEmpty()){\n\t\t\t\tPos p = qu.poll();\n\t\t\t\tif(goal(p)){\n\t\t\t\t\tgoal = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(oneGoal(p)) continue;\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tPos np = move(p, i);\n\t\t\t\t\tif(used.get(np.id)) continue;\n\t\t\t\t\tused.set(np.id);\n\t\t\t\t\tqu.add(np);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(goal?\"Yes\":\"No\");\n\t\t}\n\t}\n\t\n\tpublic static Pos move(Pos p, int dir){\n\t\tint nx1 = p.x1+dx[dir];\n\t\tint ny1 = p.y1+dy[dir];\n\t\tif(out(ny1, nx1) || map[0][ny1][nx1] == '#'){\n\t\t\tnx1 = p.x1;\n\t\t\tny1 = p.y1;\n\t\t}\n\t\tint nx2 = p.x2-dx[dir];\n\t\tint ny2 = p.y2+dy[dir];\n\t\tif(out(ny2, nx2) || map[1][ny2][nx2] == '#'){\n\t\t\tnx2 = p.x2;\n\t\t\tny2 = p.y2;\n\t\t}\n\t\treturn new Pos(nx1, ny1, nx2, ny2);\n\t}\n\t\n\tpublic static boolean out(int y, int x){\n\t\treturn x < 0 || x >= w || y < 0 || y >= h;\n\t}\n\t\n\tpublic static boolean goal(Pos p){\n\t\treturn p.x1 == gx[0] && p.y1 == gy[0] && p.x2 == gx[1] && p.y2 == gy[1];\n\t}\n\t\n\tpublic static boolean oneGoal(Pos p){\n\t\treturn p.x1 == gx[0] && p.y1 == gy[0] || p.x2 == gx[1] && p.y2 == gy[1];\n\t}\n\t\n\tpublic static int id(int y1, int x1, int y2, int x2){\n\t\treturn y1*h*w*w + x1*h*w + y2*w + x2;\n\t}\n}\n\nclass Pos{\n\tint x1, y1, x2, y2;\n\tint id;\n\tpublic Pos(int y1, int x1, int y2, int x2){\n\t\tthis.x1 = x1;\n\t\tthis.y1 = y1;\n\t\tthis.x2 = x2;\n\t\tthis.y2 = y2;\n\t\tid = Main.id(y1, x1, y2, x2);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.lang.System.*;\n\nimport java.lang.reflect.Array;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Queue;\nimport java.util.Random;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static Random rand=new Random();\n\n\tclass Pos{\n\t\tint lx,ly,rx,ry;\n\t\tpublic Pos(int _lx,int _ly,int _rx,int _ry) {\n\t\t\tlx=_lx;ly=_ly;rx=_rx;ry=_ry;\n\t\t}\n\t}\n\n\tint[] dx1=new int[]{1,0,-1,0};\n\tint[] dy1=new int[]{0,1,0,-1};\n\tint[] dx2=new int[]{-1,0,1,0};\n\tint[] dy2=new int[]{0,1,0,-1};\n\n\n\tpublic void run() {\n\t\tCase:while(true){\n\t\t\tint W=sc.nextInt(),H=sc.nextInt();\n\n\t\t\tchar[][] map1=new char[H][W],map2=new char[H][W];\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tmap1[i]=sc.next().toCharArray();\n\t\t\t\tmap2[i]=sc.next().toCharArray();\n\t\t\t}\n\n\t\t\tboolean[][][][] passed=new boolean[H][W][H][W];\n\n\t\t\tint lx=-1,ly=-1,rx=-1,ry=-1;\n\t\t\tfor(int h=0;h<H;h++)for(int w=0;w<W;w++){\n\t\t\t\tif(map1[h][w]=='L')lx=w;ly=h;\n\t\t\t\tif(map2[h][w]=='R')rx=w;ry=h;\n\t\t\t}\n\t\t\tQueue<Pos> que=new LinkedList<Pos>();\n\n\t\t\tque.add(new Pos(lx, ly, rx, ry));\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tPos p=que.poll();\n\t\t\t\tif(passed[p.ly][p.lx][p.ry][p.rx])continue;\n\t\t\t\tpassed[p.ly][p.lx][p.ry][p.rx]=true;\n\t\t\t\t//4方向\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint nx1=p.lx+dx1[i],ny1=p.ly+dy1[i];\n\t\t\t\t\tint nx2=p.rx+dx2[i],ny2=p.ry+dy2[i];\n\t\t\t\t\tif(0<=nx1 && nx1 <W &&\n\t\t\t\t\t0<=ny1 && ny1<H &&\n\t\t\t\t\t0<=nx2 && nx2<W &&\n\t\t\t\t\t0<=ny2 && ny2<H){\n\t\t\t\t\t\tif(map1[ny1][nx1]=='%' && map2[ny2][nx2]=='%'){\n\t\t\t\t\t\t\tln(str(true));continue Case;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(map1[ny1][nx1]=='#'){\n\t\t\t\t\t\t\tnx1=p.lx;ny1=p.ly;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(map2[ny2][nx2]=='#'){\n\t\t\t\t\t\t\tnx2=p.rx;ny2=p.ry;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tque.add(new Pos(nx1,ny1,nx2,ny2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tln(str(false));\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tstatic Scanner sc=new Scanner(in);\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(boolean o){\n\t\treturn o?\"Yes\":\"No\";\n\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\t//depth ex A[10]…1 A[10][10]…2 exception A[0]…0 A[10][0]…1 A[0][0]…0\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static int[][] move_dir = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\t\n\tpublic static final int MAX = 50;\n\t\n\tpublic static boolean is_ok(int x, int y, int h, int w){\n\t\tif(x < 0 || x >= w || y < 0 || y >= h){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tboolean[][][][] is_visited = new boolean[MAX][MAX][MAX][MAX];\n\t\tboolean[][][] can_enter = new boolean[2][MAX][MAX];\n\t\tint[][] start_pos = new int[2][2];\n\t\tint[][] goal_pos  = new int[2][2];\n\t\t\n\t\twhile(true){\n\t\t\tfinal int W = sc.nextInt();\n\t\t\tfinal int H = sc.nextInt();\n\t\t\t\n\t\t\tif(W == 0 && H == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tfor(int type = 0; type < 2; type++){\n\t\t\t\t\tchar[] input = sc.next().toCharArray();\n\t\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\t\tif(input[j] == '#'){\n\t\t\t\t\t\t\tcan_enter[type][i][j] = false;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcan_enter[type][i][j] = true;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(input[j] == '%'){\n\t\t\t\t\t\t\t\tgoal_pos[type][0] = j;\n\t\t\t\t\t\t\t\tgoal_pos[type][1] = i;\n\t\t\t\t\t\t\t}else if(input[j] == 'L' || input[j] == 'R'){\n\t\t\t\t\t\t\t\tstart_pos[type][0] = j;\n\t\t\t\t\t\t\t\tstart_pos[type][1] = i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < H; i++){\n\t\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\t\tfor(int k = 0; k < H; k++){\n\t\t\t\t\t\tfor(int l = 0; l < W; l++){\n\t\t\t\t\t\t\tis_visited[i][j][k][l] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tLinkedList<Integer> len_x_queue = new LinkedList<Integer>();\n\t\t\tLinkedList<Integer> len_y_queue = new LinkedList<Integer>();\n\t\t\tLinkedList<Integer> rin_x_queue = new LinkedList<Integer>();\n\t\t\tLinkedList<Integer> rin_y_queue = new LinkedList<Integer>();\n\t\t\t//LinkedList<Integer> time_queue  = new LinkedList<Integer>();\n\t\t\tlen_x_queue.add(start_pos[0][0]);\n\t\t\tlen_y_queue.add(start_pos[0][1]);\n\t\t\trin_x_queue.add(start_pos[1][0]);\n\t\t\trin_y_queue.add(start_pos[1][1]);\n\t\t\t//time_queue.add(0);\n\t\t\tis_visited[start_pos[0][1]][start_pos[0][0]][start_pos[1][1]][start_pos[1][0]] = true;\n\t\t\t\n\t\t\tboolean found = false;\n\t\t\twhile(!len_x_queue.isEmpty()){\n\t\t\t\tfinal int len_x = len_x_queue.poll();\n\t\t\t\tfinal int len_y = len_y_queue.poll();\n\t\t\t\tfinal int rin_x = rin_x_queue.poll();\n\t\t\t\tfinal int rin_y = rin_y_queue.poll();\n\t\t\t\t//final int time  = time_queue.poll();\n\t\t\t\t\n\t\t\t\t//System.out.println(len_x + \" \" + len_y + \" \" + rin_x + \" \" + rin_y);\n\t\t\t\t\n\t\t\t\tif(goal_pos[0][0] == len_x && goal_pos[0][1] == len_y\n\t\t\t\t\t\t&& goal_pos[1][0] == rin_x && goal_pos[1][1] == rin_y){\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(goal_pos[0][0] == len_x && goal_pos[0][1] == len_y){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(goal_pos[1][0] == rin_x && goal_pos[1][1] == rin_y){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int[] move : move_dir){\n\t\t\t\t\tint n_len_x = len_x + move[0];\n\t\t\t\t\tint n_len_y = len_y + move[1];\n\t\t\t\t\tint n_rin_x = rin_x - move[0];\n\t\t\t\t\tint n_rin_y = rin_y + move[1];\n\t\t\t\t\t\n\t\t\t\t\tif(!is_ok(n_len_x, n_len_y, H, W) || !can_enter[0][n_len_y][n_len_x]){\n\t\t\t\t\t\tn_len_x = len_x;\n\t\t\t\t\t\tn_len_y = len_y;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(!is_ok(n_rin_x, n_rin_y, H, W) || !can_enter[1][n_rin_y][n_rin_x]){\n\t\t\t\t\t\tn_rin_x = rin_x;\n\t\t\t\t\t\tn_rin_y = rin_y;\n\t\t\t\t\t}\n\t\t\t\t\t//System.out.println(n_len_x + \" \" + n_len_y + \" \" + n_rin_x + \" \" + n_rin_y);\n\t\t\t\t\tif(is_visited[n_len_y][n_len_x][n_rin_y][n_rin_x]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//\n\t\t\t\t\t//System.out.println(is_visited[n_len_y][n_len_x][n_rin_y][n_rin_x]);\n\t\t\t\t\t\n\t\t\t\t\tis_visited[n_len_y][n_len_x][n_rin_y][n_rin_x] = true;\n\t\t\t\t\tlen_x_queue.add(n_len_x);\n\t\t\t\t\tlen_y_queue.add(n_len_y);\n\t\t\t\t\trin_x_queue.add(n_rin_x);\n\t\t\t\t\trin_y_queue.add(n_rin_y);\n\t\t\t\t\t//time_queue.add(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(!found){\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nimport javax.xml.crypto.Data;\npublic class Main{\n\tstatic int INF = 2 << 28;\n\tstatic int[] vxL = {0,0,1,-1};\n\tstatic int[] vxR = {0,0,-1,1};\n\tstatic int[] vyL = {1,-1,0,0};\n\tstatic int[] vyR = {1,-1,0,0};\n\tstatic int w;\n\tstatic int h;\n\tstatic int Lx;\n\tstatic int Ly;\n\tstatic int Rx;\n\tstatic int Ry;\n\tstatic char[][] mapL;\n\tstatic char[][] mapR;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif(w == 0 && h == 0) break;\n\t\t\tmapL = new char[h][];\n\t\t\tmapR = new char[h][];\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tmapL[i] = sc.next().toCharArray();\n\t\t\t\tmapR[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tLx = 0;\n\t\t\tLy = 0;\n\t\t\tRx = 0;\n\t\t\tRy = 0;\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(mapL[i][j] == 'L') {\n\t\t\t\t\t\tLy = i;\n\t\t\t\t\t\tLx = j;\n\t\t\t\t\t\tmapL[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t\tif(mapR[i][j] == 'R') {\n\t\t\t\t\t\tRy = i;\n\t\t\t\t\t\tRx = j;\n\t\t\t\t\t\tmapR[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean ans = BFS();\n\t\t\tif(ans) {\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t\tSystem.gc();\n\t\t}\n\t}\t\n\tstatic boolean BFS() {\n\t\tHashMap<String,Boolean> map = new HashMap<String,Boolean>();\n\t\tArrayDeque<Data> queue = new ArrayDeque<Data>();\n\t\tqueue.add(new Data(Lx,Ly,Rx,Ry));\n\t\twhile(!queue.isEmpty()) {\n\t\t\tData tmp = queue.poll();\n\t\t\tString t = tmp.Lx + \" \" + tmp.Ly + \" \" + tmp.Rx + \" \" + tmp.Ry;\n\t\t\tif(map.containsKey(t)) continue;\n\t\t\tmap.put(t, true);\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\t\n\t\t\t\tint Ltx = tmp.Lx + vxL[i];\n\t\t\t\tint Lty = tmp.Ly + vyL[i];\n\t\t\t\tint Rtx = tmp.Rx + vxR[i];\n\t\t\t\tint Rty = tmp.Ry + vyR[i];\n\t\t\t\t\n\t\t\t\tint  L = Rcheck(Ltx,Lty,mapL);\n\t\t\t\tint  R = Rcheck(Rtx,Rty,mapR);\n\t\t\t\t\n\t\t\t\tif(L == 2 && R == 2) return true;\n\t\t\t\tif(L == 2 && R != 2) continue;\n\t\t\t\tif(L != 2 && R == 2) continue;\n\t\t\t\tif(L == 0 && R == 0) continue;\n\t\t\t\tif(L == 0) {\n\t\t\t\t\tLtx = tmp.Lx;\n\t\t\t\t\tLty = tmp.Ly;\n\t\t\t\t}\n\t\t\t\tif(R == 0) {\n\t\t\t\t\tRtx = tmp.Rx;\n\t\t\t\t\tRty = tmp.Ry;\n\t\t\t\t}\n\t\t\t\tqueue.addLast(new Data(Ltx,Lty,Rtx,Rty));\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t\t\n\t}\n\tstatic int Rcheck(int x,int y,char[][] map) {\n\t\tif(x < 0 || y < 0 || x >= w || y >= h) return 0;\n\t\tif(map[y][x] == '#') return 0;\n\t\tif(map[y][x] == '.') return 1;\n\t\tif(map[y][x] == '%') return 2;\n\t\treturn -1;\n\t}\n\t\n\tstatic class Data {\n\t\tint Lx;\n\t\tint Ly;\n\t\tint Rx;\n\t\tint Ry;\n\t\tData(int a, int b, int c, int d) {\n\t\t\tLx = a;\n\t\t\tLy = b;\n\t\t\tRx = c;\n\t\t\tRy = d;\n\t\t}\n\t\tpublic boolean equals(Object o) {\n\t\t\tData c = (Data)o;\n\t\t\tif(this.Lx != c.Lx) return false;\n\t\t\tif(this.Ly != c.Ly) return false;\n\t\t\tif(this.Rx != c.Rx) return false;\n\t\t\tif(this.Ry != c.Ry) return false;\n\t\t\treturn true;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Scanner;\nimport java.util.Queue;\nimport java.util.ArrayDeque;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        MirrorCave solver = new MirrorCave();\n        try {\n            int testNumber = 1;\n            while (true)\n                solver.solve(testNumber++, in, out);\n        } catch (UnknownError e) {\n            out.close();\n        }\n    }\n\n    static class MirrorCave {\n        final int[] dh = new int[]{0, -1, 0, 1};\n        final int[] dw = new int[]{-1, 0, 1, 0};\n        final int[] dh2 = new int[]{0, -1, 0, 1};\n        final int[] dw2 = new int[]{1, 0, -1, 0};\n\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int W = in.nextInt();\n            int H = in.nextInt();\n            if (W == 0) {\n                throw new UnknownError();\n            }\n            String[] L = new String[H + 2];\n            String[] R = new String[H + 2];\n            L[0] = R[0] = L[H + 1] = R[H + 1] = new String();\n            for (int i = 0; i < W + 2; ++i) {\n                L[0] += \"#\";\n                R[0] += \"#\";\n                R[H + 1] += \"#\";\n                L[H + 1] += \"#\";\n            }\n            int lh = -1, lw = -1, rh = -1, rw = -1;\n            int glh = -1, glw = -1, grh = -1, grw = -1;\n            for (int i = 0; i < H; ++i) {\n                L[i + 1] = \"#\" + in.next() + \"#\";\n                R[i + 1] = \"#\" + in.next() + \"#\";\n                for (int j = 0; j < L[i + 1].length(); ++j) {\n                    if (L[i + 1].charAt(j) == 'L') {\n                        lh = i + 1;\n                        lw = j;\n                    }\n                    if (R[i + 1].charAt(j) == 'R') {\n                        rh = i + 1;\n                        rw = j;\n                    }\n                    if (L[i + 1].charAt(j) == '%') {\n                        glh = i + 1;\n                        glw = j;\n                    }\n                    if (R[i + 1].charAt(j) == '%') {\n                        grh = i + 1;\n                        grw = j;\n                    }\n                }\n            }\n            boolean[][][][] vis = new boolean[H + 2][W + 2][H + 2][W + 2];\n            for (int i = 0; i < vis.length; ++i) {\n                for (int j = 0; j < vis[i].length; ++j) {\n                    for (int k = 0; k < vis[i][j].length; ++k) {\n                        Arrays.fill(vis[i][j][k], false);\n                    }\n                }\n            }\n            Queue<State> q = new ArrayDeque<>();\n            q.add(new State(lh, lw, rh, rw));\n            //for (String e : L) System.err.println(e);\n            //for (String e : R) System.err.println(e);\n            vis[lh][lw][rh][rw] = true;\n            while (!q.isEmpty()) {\n                State now = q.poll();\n                for (int i = 0; i < 4; ++i) {\n                    State next = new State(now.lh + dh[i], now.lw + dw[i], now.rh + dh2[i], now.rw + dw2[i]);\n                    if (L[next.lh].charAt(next.lw) == '#' && R[next.rh].charAt(next.rw) == '#') {\n                        continue;\n                    } else if (L[next.lh].charAt(next.lw) == '#') {\n                        next.lh = now.lh;\n                        next.lw = now.lw;\n                    } else if (R[next.rh].charAt(next.rw) == '#') {\n                        next.rh = now.rh;\n                        next.rw = now.rw;\n                    }\n                    if (!vis[next.lh][next.lw][next.rh][next.rw]) {\n                        if ((next.lh == glh && next.lw == glw) ^ (next.rh == grh && next.rw == grw)) {\n                            continue;\n                        }\n                        if (next.lh == glh && next.rh == grh && next.lw == glw && next.rw == grw) {\n                            out.println(\"Yes\");\n                            return;\n                        }\n                        vis[next.lh][next.lw][next.rh][next.rw] = true;\n                        q.add(next);\n                    }\n                }\n            }\n            out.println(\"No\");\n            return;\n        }\n\n        public class State {\n            int lh;\n            int lw;\n            int rh;\n            int rw;\n\n            State(int lh, int lw, int rh, int rw) {\n                this.lh = lh;\n                this.lw = lw;\n                this.rh = rh;\n                this.rw = rw;\n            }\n\n        }\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\t\n\tint[] vx = {-1, 0, 1, 0};\n\tint[] vy = {0, -1, 0, 1};\n\tQueue<Integer> q = new LinkedList<Integer>();\n\tHashSet<Integer> hash = new HashSet<Integer>();\n\tint getKey(int rx, int ry, int lx, int ly) {\n\t\treturn 1000000 * rx + 10000 * ry + 100 * lx + ly;\n\t}\n\t\n\tboolean inside(int x, int y, int n, int m) {\n\t\treturn 0 <= x && x < m && 0 <= y && y < n;\n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint m = in.nextInt(), n = in.nextInt();\n\t\t\tif (n == 0 && m == 0) break;\n\t\t\t\n\t\t\thash.clear();\n\t\t\tq.clear();\n\t\t\tchar[][] rin = new char[n][];\n\t\t\tchar[][] len = new char[n][];\n\t\t\tint rsx = -1, rsy = -1, lsx = -1, lsy = -1;\n\t\t\tint rgx = -1, rgy = -1, lgx = -1, lgy = -1;\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tlen[i] = in.next().toCharArray();\n\t\t\t\trin[i] = in.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tif (rin[i][j] == '%') {\n\t\t\t\t\t\trgx = j; rgy = i;\n\t\t\t\t\t} else if (rin[i][j] == 'R') {\n\t\t\t\t\t\trsx = j; rsy = i;\n\t\t\t\t\t}\n\t\t\t\t\tif (len[i][j] == '%') {\n\t\t\t\t\t\tlgx = j; lgy = i;\n\t\t\t\t\t} else if (len[i][j] == 'L') {\n\t\t\t\t\t\tlsx = j; lsy = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\thash.add(getKey(rsx, rsy, lsx, lsy));\n\t\t\tq.add(getKey(rsx, rsy, lsx, lsy));\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tint next = q.poll();\n\t\t\t\tint ly = next % 100;\n\t\t\t\tnext /= 100;\n\t\t\t\tint lx = next % 100;\n\t\t\t\tnext /= 100;\n\t\t\t\tint ry = next % 100;\n\t\t\t\tnext /= 100;\n\t\t\t\tint rx = next % 100;\n\t\t\t\t\t\t\t\t\n\t\t\t\tfor (int d = 0; d < vx.length; d++) {\n\t\t\t\t\tint nrx = rx + vx[d], nry = ry + vy[d];\n\t\t\t\t\tint nlx = lx - vx[d], nly = ly + vy[d];\n\t\t\t\t\t\n\t\t\t\t\tif (inside(nlx, nly, n, m) && inside(nrx, nry, n, m)) {\n\t\t\t\t\t\tif (rin[nry][nrx] == '#') {\n\t\t\t\t\t\t\tif (len[nly][nlx] == '#') {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnry = ry;\n\t\t\t\t\t\t\t\tnrx = rx;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (len[nly][nlx] == '#') {\n\t\t\t\t\t\t\t\tnly = ly;\n\t\t\t\t\t\t\t\tnlx = lx;\n\t\t\t\t\t\t\t} \n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (hash.contains(getKey(nrx, nry, nlx, nly))) continue;\n\t\t\t\t\t\thash.add(getKey(nrx, nry, nlx, nly));\n\t\t\t\t\t\tif (!((nrx == rgx && nry == rgy) || (nlx == lgx && nly == lgy))) {\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tq.add(getKey(nrx, nry, nlx, nly));\n\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(hash.contains(getKey(rgx, rgy, lgx, lgy)) ? \"Yes\" : \"No\");\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int[][] field1,field2;\n\tstatic byte[][][][] dp;\n\tstatic int sXL,sXR,sYL,sYR;\n\tstatic boolean ans;\n\tstatic int[] v1={0,1,0,-1};\n\tstatic int[] v2={1,0,-1,0};\n\tstatic int w,h;\n\tpublic static void main(String[] args) {\n\t\tScanner cin=new Scanner(System.in);\n\t\twhile(true){\n\n\t\t\tw=cin.nextInt();\n\t\t\th=cin.nextInt();\n\t\t\tif(w+h==0){\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\tans=false;\n\t\t\tfield1=new int[h][w];\n\t\t\tfield2=new int[h][w];\n\t\t\tdp=new byte[h][w][h][w];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<2;j++){\n\t\t\t\t\tString s=cin.next();\n\t\t\t\t\tint[][] a;\n\t\t\t\t\tif(j==0){\n\t\t\t\t\t\ta=field1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\ta=field2;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<s.length();k++){\n\t\t\t\t\t\tint b=0;\n\t\t\t\t\t\tif(s.charAt(k)=='%'){\n\t\t\t\t\t\t\tb=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(s.charAt(k)=='#'){\n\t\t\t\t\t\t\tb=-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(s.charAt(k)=='L'){\n\t\t\t\t\t\t\tsXL=i;\n\t\t\t\t\t\t\tsYL=k;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(s.charAt(k)=='R'){\n\t\t\t\t\t\t\tsXR=i;\n\t\t\t\t\t\t\tsYR=k;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ta[i][k]=b;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQueue<byte[]> q=new LinkedList<byte[]>();\n\t\t\tq.add(new byte[]{(byte) sXL,(byte) sYL,(byte) sXR,(byte) sYR});\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tbyte[] poll=q.poll();\n\t\t\t\tint a=poll[0];\n\t\t\t\tint b=poll[1];\n\t\t\t\tint c=poll[2];\n\t\t\t\tint d=poll[3];\n\t\t\t\tif(dp[a][b][c][d]==1||ans){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdp[a][b][c][d]=1;\n\t\t\t\tif(field1[a][b]==1&&field2[c][d]==1){\n\t\t\t\t\tans=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(field1[a][b]==1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(field2[c][d]==1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint aa=a+v1[i];\n\t\t\t\t\tint bb=b+v2[i];\n\t\t\t\t\tint cc=c+v1[i];\n\t\t\t\t\tint dd=d+-v2[i];\n//\t\t\t\t\tSystem.out.println(aa+\" \"+bb+\" \"+cc+\" \"+dd+\" \"+i);\n\t\t\t\t\tif(aa<0||aa>=h){\n\t\t\t\t\t\taa-=v1[i];\n\t\t\t\t\t}\n\t\t\t\t\tif(bb<0||bb>=w){\n\t\t\t\t\t\tbb-=v2[i];\n\t\t\t\t\t}\n\t\t\t\t\tif(cc<0||cc>=h){\n\t\t\t\t\t\tcc-=v1[i];\n\t\t\t\t\t}\n\t\t\t\t\tif(dd<0||dd>=w){\n\t\t\t\t\t\tdd-=-v2[i];\n\t\t\t\t\t}\n//\t\t\t\t\tSystem.out.println(aa+\" \"+bb+\" \"+cc+\" \"+dd+\" \"+i);\n\t\t\t\t\tif(field1[aa][bb]==-1){\n\t\t\t\t\t\taa-=v1[i];\n\t\t\t\t\t\tbb-=v2[i];\n\t\t\t\t\t}\n\t\t\t\t\tif(field2[cc][dd]==-1){\n\t\t\t\t\t\tcc-=v1[i];\n\t\t\t\t\t\tdd-=-v2[i];\n\t\t\t\t\t}\n\t\t\t\t\tq.add(new byte[]{(byte)aa,(byte)bb,(byte)cc,(byte)dd});\n\t\t\t\t}\n\n\t\t\t}\n//\t\t\tbt(sXL,sYL,sXR,sYR);\n\t\t\tif(ans){\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t}\n\tstatic void bt(int a,int b,int c,int d){\n//\t\tif(dp[a][b][c][d]||ans){\n//\t\t\treturn ;\n//\t\t}\n//\t\tdp[a][b][c][d]=true;\n\t\tif(field1[a][b]==1&&field2[c][d]==1){\n\t\t\tans=true;\n\t\t}\n\t\tif(field1[a][b]==1){\n\t\t\treturn;\n\t\t}\n\t\tif(field2[c][d]==1){\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint aa=a+v1[i];\n\t\t\tint bb=b+v2[i];\n\t\t\tint cc=c+v1[i];\n\t\t\tint dd=d+-v2[i];\n//\t\t\tSystem.out.println(aa+\" \"+bb+\" \"+cc+\" \"+dd+\" \"+i);\n\t\t\tif(aa<0||aa>=h){\n\t\t\t\taa-=v1[i];\n\t\t\t}\n\t\t\tif(bb<0||bb>=w){\n\t\t\t\tbb-=v2[i];\n\t\t\t}\n\t\t\tif(cc<0||cc>=h){\n\t\t\t\tcc-=v1[i];\n\t\t\t}\n\t\t\tif(dd<0||dd>=w){\n\t\t\t\tdd-=-v2[i];\n\t\t\t}\n//\t\t\tSystem.out.println(aa+\" \"+bb+\" \"+cc+\" \"+dd+\" \"+i);\n\t\t\tif(field1[aa][bb]==-1){\n\t\t\t\taa-=v1[i];\n\t\t\t\tbb-=v2[i];\n\t\t\t}\n\t\t\tif(field2[cc][dd]==-1){\n\t\t\t\tcc-=v1[i];\n\t\t\t\tdd-=-v2[i];\n\t\t\t}\n\t\t\tbt(aa,bb,cc,dd);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static final void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tint w;\n\tint h;\n\tchar[][] map = new char[2][100*100];\n\tint sl;\n\tint sr;\n\tpublic Main() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif(w==0 && h==0)\n\t\t\t\tbreak;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tString s0 = sc.next();\n\t\t\t\tString s1 = sc.next();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tmap[0][i*w+j] = s0.charAt(j);\n\t\t\t\t\tmap[1][i*w+j] = s1.charAt(w-j-1);\n\t\t\t\t\tif(map[0][i*w+j]=='L')\n\t\t\t\t\t\tsl = i*w+j;\n\t\t\t\t\tif(map[1][i*w+j]=='R')\n\t\t\t\t\t\tsr = i*w+j;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tint[] dx = new int[]{-1, 0, 1, 0};\n\tint[] dy = new int[]{0, -1, 0, 1};\n\tprivate void solve() {\n\t\tLinkedList<int[]> queue = new LinkedList<int[]>();\n\t\t\n\t\tint[][] visited = new int[w*h][w*h];\n\t\tqueue.add(new int[]{sl, sr});\n\n\t\twhile(!queue.isEmpty()){\n\t\t\tint[] cp = queue.poll();\n\t\t\tint clp = cp[0];\n\t\t\tint crp = cp[1];\n\t\t\t\n\t\t\tif(visited[clp][crp]==1)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tvisited[clp][crp] = 1;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nlp = clp + dx[i] + dy[i]*w;\n\t\t\t\tint nrp = crp + dx[i] + dy[i]*w;\n\t\t\t\tif(nlp<0 || w*h<=nlp || nrp<0 || w*h<=nrp)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(map[0][nlp]=='#')\n\t\t\t\t\tnlp = clp;\n\t\t\t\tif(map[1][nrp]=='#')\n\t\t\t\t\tnrp = crp;\n\t\t\t\t\n\t\t\t\tif(map[0][nlp]=='%' && map[1][nrp]=='%'){\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\tqueue.clear();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tqueue.add(new int[]{nlp, nrp});\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"No\");\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Scanner;\nimport java.util.Queue;\nimport java.util.ArrayDeque;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        MirrorCave solver = new MirrorCave();\n        try {\n            int testNumber = 1;\n            while (true)\n                solver.solve(testNumber++, in, out);\n        } catch (UnknownError e) {\n            out.close();\n        }\n    }\n\n    static class MirrorCave {\n        final int[] dh = new int[]{0, -1, 0, 1};\n        final int[] dw = new int[]{-1, 0, 1, 0};\n        final int[] dh2 = new int[]{0, -1, 0, 1};\n        final int[] dw2 = new int[]{1, 0, -1, 0};\n\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int W = in.nextInt();\n            int H = in.nextInt();\n            if (W == 0) {\n                throw new UnknownError();\n            }\n            String[] L = new String[H + 2];\n            String[] R = new String[H + 2];\n            L[0] = R[0] = L[H + 1] = R[H + 1] = new String();\n            for (int i = 0; i < W + 2; ++i) {\n                L[0] += \"#\";\n                R[0] += \"#\";\n                R[H + 1] += \"#\";\n                L[H + 1] += \"#\";\n            }\n            int lh = -1, lw = -1, rh = -1, rw = -1;\n            int glh = -1, glw = -1, grh = -1, grw = -1;\n            for (int i = 0; i < H; ++i) {\n                L[i + 1] = \"#\" + in.next() + \"#\";\n                R[i + 1] = \"#\" + in.next() + \"#\";\n                for (int j = 0; j < L[i + 1].length(); ++j) {\n                    if (L[i + 1].charAt(j) == 'L') {\n                        lh = i + 1;\n                        lw = j;\n                    }\n                    if (R[i + 1].charAt(j) == 'R') {\n                        rh = i + 1;\n                        rw = j;\n                    }\n                    if (L[i + 1].charAt(j) == '%') {\n                        glh = i + 1;\n                        glw = j;\n                    }\n                    if (R[i + 1].charAt(j) == '%') {\n                        grh = i + 1;\n                        grw = j;\n                    }\n                }\n            }\n            boolean[][][][] vis = new boolean[H + 2][W + 2][H + 2][W + 2];\n            for (int i = 0; i < vis.length; ++i) {\n                for (int j = 0; j < vis[i].length; ++j) {\n                    for (int k = 0; k < vis[i][j].length; ++k) {\n                        Arrays.fill(vis[i][j][k], false);\n                    }\n                }\n            }\n            Queue<State> q = new ArrayDeque<>();\n            q.add(new State(lh, lw, rh, rw));\n            //for (String e : L) System.err.println(e);\n            //for (String e : R) System.err.println(e);\n            while (!q.isEmpty()) {\n                State now = q.poll();\n                if (vis[now.lh][now.lw][now.rh][now.rw]) {\n                    continue;\n                }\n                vis[now.lh][now.lw][now.rh][now.rw] = true;\n                if ((now.lh == glh && now.lw == glw) ^ (now.rh == grh && now.rw == grw)) {\n                    continue;\n                }\n                if (now.lh == glh && now.rh == grh && now.lw == glw && now.rw == grw) {\n                    out.println(\"Yes\");\n                    return;\n                }\n\n                for (int i = 0; i < 4; ++i) {\n                    State next = new State(now.lh + dh[i], now.lw + dw[i], now.rh + dh2[i], now.rw + dw2[i]);\n                    if (L[next.lh].charAt(next.lw) == '#' && R[next.rh].charAt(next.rw) == '#') {\n                        continue;\n                    } else if (L[next.lh].charAt(next.lw) == '#') {\n                        next.lh = now.lh;\n                        next.lw = now.lw;\n                    } else if (R[next.rh].charAt(next.rw) == '#') {\n                        next.rh = now.rh;\n                        next.rw = now.rw;\n                    }\n                    if (!vis[next.lh][next.lw][next.rh][next.rw]) {\n                        q.add(next);\n                    }\n                }\n            }\n            out.println(\"No\");\n            return;\n        }\n\n        public class State {\n            int lh;\n            int lw;\n            int rh;\n            int rw;\n\n            State(int lh, int lw, int rh, int rw) {\n                this.lh = lh;\n                this.lw = lw;\n                this.rh = rh;\n                this.rw = rw;\n            }\n\n        }\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint w, h;\n\tboolean[][] mapl, mapr;\n\tbyte sxl, syl, sxr, syr;\n\tbyte gxl, gyl, gxr, gyr;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif( (w|h) == 0 ) break;\n\t\t\t\n\t\t\tmapl = new boolean[h+2][w+2];\n\t\t\tmapr = new boolean[h+2][w+2];\n\t\t\t\n\t\t\tfor(int i=1;i<=h;i++) {\n\t\t\t\tString l = sc.next();\n\t\t\t\tString r = sc.next();\n//\t\t\t\tdebug(l, r);\n\t\t\t\tfor(int j=1;j<=w;j++) {\n\t\t\t\t\tswitch (l.charAt(j-1)) {\n\t\t\t\t\tcase '%':\n\t\t\t\t\t\tgxl = (byte)j;\n\t\t\t\t\t\tgyl = (byte)i;\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\tsxl = (byte)j;\n\t\t\t\t\t\tsyl = (byte)i;\n\t\t\t\t\tcase '.':\n\t\t\t\t\t\tmapl[i][j] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault :mapl[i][j] = false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tswitch (r.charAt(j-1)) {\n\t\t\t\t\tcase '%':\n\t\t\t\t\t\tgxr = (byte)j;\n\t\t\t\t\t\tgyr = (byte)i;\n\t\t\t\t\tcase 'R':\n\t\t\t\t\t\tsxr = (byte)j;\n\t\t\t\t\t\tsyr = (byte)i;\n\t\t\t\t\tcase '.':\n\t\t\t\t\t\tmapr[i][j] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault :mapr[i][j] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( solve() ) System.out.println(\"Yes\");\n\t\t\telse System.out.println(\"No\");\n\t\t}\n\t}\n\t\n\tbyte dx[] = {-1,0,1,0};\n\tbyte dy[] = {0,-1,0,1}; \n\t\n\tboolean solve() {\n\t\tboolean[][][][] visited = new boolean[h+2][w+2][h+2][w+2];\n\t\tLinkedList<W> que = new LinkedList<W>();\n\t\tW now = new W( new P((byte)sxl, (byte)syl), new P((byte)sxr, (byte)syr) );\n\t\tque.add(now);\n\t\tvisited[now.l.y][now.l.x][now.r.y][now.r.x] = true;\n\t\tfor(;!que.isEmpty();) {\n\t\t\tnow = que.removeFirst();\n//\t\t\tdebug(now.l.x, now.l.y, now.r.x, now.r.y);\n\t\t\tint g = isGoal(now);\n\t\t\tif( g == 1 ) return true;\n\t\t\tif( g == -1 ) continue;\n\t\t\t\n\t\t\tfor(int i=0;i<4;i++) {\n\t\t\t\tbyte nxl = (byte)(now.l.x + dx[i]);\n\t\t\t\tbyte nyl = (byte)(now.l.y + dy[i]);\n\t\t\t\tbyte nxr = (byte)(now.r.x - dx[i]);\n\t\t\t\tbyte nyr = (byte)(now.r.y + dy[i]);\n\t\t\t\tif( !mapl[nyl][nxl] ) {\n\t\t\t\t\tnxl -= dx[i];\n\t\t\t\t\tnyl -= dy[i];\n\t\t\t\t}\n\t\t\t\tif( !mapr[nyr][nxr] ) {\n\t\t\t\t\tnxr += dx[i];\n\t\t\t\t\tnyr -= dy[i];\n\t\t\t\t}\n\t\t\t\tif( visited[nyl][nxl][nyr][nxr] ) continue;\n\t\t\t\tque.add( new W( new P(nxl, nyl), new P(nxr, nyr) ) );\n\t\t\t\tvisited[nyl][nxl][nyr][nxr] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tint isGoal(W w) {\n\t\tif( w.l.equals(new P(gxl, gyl)) && w.r.equals(new P(gxr, gyr)) )\n\t\t\treturn 1;\n\t\tif( w.l.equals(new P(gxl, gyl)) ^ w.r.equals(new P(gxr, gyr)) )\n\t\t\treturn -1;\n\t\telse return 0;\n\t}\n\t\n\tclass W {\n\t\tP l, r;\n\t\tW(P l, P r) {\n\t\t\tthis.l = l;\n\t\t\tthis.r = r;\n\t\t}\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif(o instanceof W) {\n\t\t\t\tW w = (W) o;\n\t\t\t\treturn l.equals(w.l) && r.equals(w.r);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn r.hashCode() * 2500 + l.hashCode() * 2500;\n\t\t}\n\t}\n\t\n\tclass P {\n\t\tbyte x, y;\n\t\tP(byte x, byte y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif(o instanceof P) {\n\t\t\t\tP p = (P)o;\n\t\t\t\treturn x == p.x && y == p.y;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn x * 50 + y;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nimport javax.xml.crypto.Data;\npublic class Main{\n\tstatic int INF = 2 << 28;\n\tstatic int[] vxL = {0,0,1,-1};\n\tstatic int[] vxR = {0,0,-1,1};\n\tstatic int[] vyL = {1,-1,0,0};\n\tstatic int[] vyR = {1,-1,0,0};\n\tstatic int w;\n\tstatic int h;\n\tstatic int Lx;\n\tstatic int Ly;\n\tstatic int Rx;\n\tstatic int Ry;\n\tstatic char[][] mapL;\n\tstatic char[][] mapR;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif(w == 0 && h == 0) break;\n\t\t\tmapL = new char[h][];\n\t\t\tmapR = new char[h][];\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tmapL[i] = sc.next().toCharArray();\n\t\t\t\tmapR[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tLx = 0;\n\t\t\tLy = 0;\n\t\t\tRx = 0;\n\t\t\tRy = 0;\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(mapL[i][j] == 'L') {\n\t\t\t\t\t\tLy = i;\n\t\t\t\t\t\tLx = j;\n\t\t\t\t\t\tmapL[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t\tif(mapR[i][j] == 'R') {\n\t\t\t\t\t\tRy = i;\n\t\t\t\t\t\tRx = j;\n\t\t\t\t\t\tmapR[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean ans = BFS();\n\t\t\tif(ans) {\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t}\t\n\tstatic boolean BFS() {\n\t\tHashMap<Data,Boolean> map = new HashMap<Data,Boolean>();\n\t\tArrayDeque<Data> queue = new ArrayDeque<Data>();\n\t\tqueue.add(new Data(Lx,Ly,Rx,Ry));\n\t\twhile(!queue.isEmpty()) {\n\t\t\tData tmp = queue.poll();\n\t\t\tif(map.containsKey(map)) continue;\n\t\t\tmap.put(tmp, true);\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\t\n\t\t\t\tint Ltx = tmp.Lx + vxL[i];\n\t\t\t\tint Lty = tmp.Ly + vyL[i];\n\t\t\t\tint Rtx = tmp.Rx + vxR[i];\n\t\t\t\tint Rty = tmp.Ry + vyR[i];\n\t\t\t\t\n\t\t\t\tint  L = Rcheck(Ltx,Lty,mapL);\n\t\t\t\tint  R = Rcheck(Rtx,Rty,mapR);\n\t\t\t\t\n\t\t\t\tif(L == 2 && R == 2) return true;\n\t\t\t\tif(L == 2 && R != 2) continue;\n\t\t\t\tif(L != 2 && R == 2) continue;\n\t\t\t\tif(L == 0 && R == 0) continue;\n\t\t\t\tif(L == 0) {\n\t\t\t\t\tLtx = tmp.Lx;\n\t\t\t\t\tLty = tmp.Ly;\n\t\t\t\t}\n\t\t\t\tif(R == 0) {\n\t\t\t\t\tRtx = tmp.Rx;\n\t\t\t\t\tRty = tmp.Ry;\n\t\t\t\t}\n\t\t\t\tqueue.addLast(new Data(Ltx,Lty,Rtx,Rty));\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t\t\n\t}\n\tstatic int Rcheck(int x,int y,char[][] map) {\n\t\tif(x < 0 || y < 0 || x >= w || y >= h) return 0;\n\t\tif(map[y][x] == '#') return 0;\n\t\tif(map[y][x] == '.') return 1;\n\t\tif(map[y][x] == '%') return 2;\n\t\treturn -1;\n\t}\n\t\n\tstatic class Data implements Comparable<Data>{\n\t\tint Lx;\n\t\tint Ly;\n\t\tint Rx;\n\t\tint Ry;\n\t\tData(int a, int b, int c, int d) {\n\t\t\tLx = a;\n\t\t\tLy = b;\n\t\t\tRx = c;\n\t\t\tRy = d;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Data o) {\n\t\t\tif(this.Lx != o.Lx) return 1;\n\t\t\tif(this.Ly != o.Ly) return 1;\n\t\t\tif(this.Rx != o.Rx) return 1;\n\t\t\tif(this.Ry != o.Ry) return 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.BitSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\npublic class Main{\n\tpublic static final int[] dx = {1, 0, -1, 0};\n\tpublic static final int[] dy = {0, 1, 0, -1};\n\tpublic static int w, h;\n\tpublic static char[][][] map;\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = in.nextInt();\n\t\t\th = in.nextInt();\n\t\t\tif(w == 0) break;\n\t\t\tmap = new char[2][h][w];\n\t\t\tint g = 0;\n\t\t\tint s = 0;\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\tfor(int j=0; j<2; j++){\n\t\t\t\t\tchar[] line = in.next().toCharArray();\n\t\t\t\t\tif(j==0) map[j][i] = line;\n\t\t\t\t\telse{\n\t\t\t\t\t\tfor(int k=0; k<w; k++){\n\t\t\t\t\t\t\tmap[j][i][k] = line[w-1-k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0; k<w; k++){\n\t\t\t\t\t\tswitch(map[j][i][k]){\n\t\t\t\t\t\tcase 'R':\n\t\t\t\t\t\t\ts += i*w+k;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'L':\n\t\t\t\t\t\t\ts += (i*w+k)*h*w;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '%':\n\t\t\t\t\t\t\tg += id(j, i, k);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tBitSet used = new BitSet(w*w*h*h);\n\t\t\tQueue<Integer> qu = new LinkedList<Integer>();\n\t\t\tqu.add(s);\n\t\t\tused.set(s);\n\t\t\tint hw = h*w;\n\t\t\tint whw = w*h*w;\n\t\t\tboolean flag = false;\n\t\t\twhile(!qu.isEmpty()){\n\t\t\t\tint id = qu.poll();\n\t\t\t\tif(id == g){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint y0 = id/whw;\n\t\t\t\tid %= whw;\n\t\t\t\tint x0 = id/hw;\n\t\t\t\tid %= hw;\n\t\t\t\tint y1 = id/w;\n\t\t\t\tint x1 = id%w;\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tint nid = next(x0, y0, x1, y1, i);\n\t\t\t\t\tif(used.get(nid)) continue;\n\t\t\t\t\tused.set(nid);\n\t\t\t\t\tqu.add(nid);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(flag ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\t\n\tpublic static String dump(char[][] map){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tsb.append(map[i][j]+\" \");\n\t\t\t}\n\t\t\tsb.append('\\n');\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tpublic static int next(int x0, int y0, int x1, int y1, int dir){\n\t\tint nx0 = x0 + dx[dir];\n\t\tint ny0 = y0 + dy[dir];\n\t\tif(nx0 < 0 || nx0 >= w || ny0 < 0 || ny0 >= h\n\t\t\t\t|| map[0][ny0][nx0] == '#'){\n\t\t\tnx0 = x0;\n\t\t\tny0 = y0;\n\t\t}\n\t\tint nx1 = x1 + dx[dir];\n\t\tint ny1 = y1 + dy[dir];\n\t\tif(nx1 < 0 || nx1 >= w || ny1 < 0 || ny1 >= h\n\t\t\t\t|| map[1][ny1][nx1] == '#'){\n\t\t\tnx1 = x1;\n\t\t\tny1 = y1;\n\t\t}\n\t\treturn id(0, ny0, nx0) + id(1, ny1, nx1);\n\t}\n\t\n\tpublic static int id(int room, int y, int x){\n\t\treturn room==0 ? (y*w+x)*w*h : y*w+x;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static final void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tint w;\n\tint h;\n\tchar[][] map = new char[2][100*100];\n\tint sl;\n\tint sr;\n\tpublic Main() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif(w==0 && h==0)\n\t\t\t\tbreak;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tString s0 = sc.next();\n\t\t\t\tString s1 = sc.next();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tmap[0][i*w+j] = s0.charAt(j);\n\t\t\t\t\tmap[1][i*w+j] = s1.charAt(w-j-1);\n\t\t\t\t\tif(map[0][i*w+j]=='L')\n\t\t\t\t\t\tsl = i*w+j;\n\t\t\t\t\tif(map[1][i*w+j]=='R')\n\t\t\t\t\t\tsr = i*w+j;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tint[] dx = new int[]{-1, 0, 1, 0};\n\tint[] dy = new int[]{0, -1, 0, 1};\n\tprivate void solve() {\n\t\tLinkedList<int[]> queue = new LinkedList<int[]>();\n\t\t\n\t\tint[][] visited = new int[w*h][w*h];\n\t\tqueue.add(new int[]{sl, sr});\n\n\t\twhile(!queue.isEmpty()){\n\t\t\tint[] cp = queue.poll();\n\t\t\tint clp = cp[0];\n\t\t\tint crp = cp[1];\n\t\t\t\n\t\t\tif(visited[clp][crp]==1)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tvisited[clp][crp] = 1;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nlp = clp + dx[i] + dy[i]*w;\n\t\t\t\tint nrp = crp + dx[i] + dy[i]*w;\n\t\t\t\tif(nlp<0 || w*h<=nlp || nrp<0 || w*h<=nrp)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(map[0][nlp]=='#')\n\t\t\t\t\tnlp = clp;\n\t\t\t\tif(map[1][nrp]=='#')\n\t\t\t\t\tnrp = crp;\n\t\t\t\t\n\t\t\t\tif(map[0][nlp]=='%' && map[1][nrp]=='%'){\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\tqueue.clear();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcp[0] = nlp;\n\t\t\t\tcp[1] = nrp;\n\t\t\t\tqueue.add(cp);\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"No\");\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.BitSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\npublic class Main{\n\tpublic static final int[] dx = {1, 0, -1, 0};\n\tpublic static final int[] dy = {0, 1, 0, -1};\n\tpublic static int w, h;\n\tpublic static char[][][] map;\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = in.nextInt();\n\t\t\th = in.nextInt();\n\t\t\tif(w == 0) break;\n\t\t\tmap = new char[2][h][w];\n\t\t\tint g = 0;\n\t\t\tint s = 0;\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\tfor(int j=0; j<2; j++){\n\t\t\t\t\tchar[] line = in.next().toCharArray();\n\t\t\t\t\tif(j==0) map[j][i] = line;\n\t\t\t\t\telse{\n\t\t\t\t\t\tfor(int k=0; k<w; k++){\n\t\t\t\t\t\t\tmap[j][i][k] = line[w-1-k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0; k<w; k++){\n\t\t\t\t\t\tswitch(map[j][i][k]){\n\t\t\t\t\t\tcase 'R':\n\t\t\t\t\t\t\ts += i*w+k;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'L':\n\t\t\t\t\t\t\ts += (i*w+k)*h*w;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '%':\n\t\t\t\t\t\t\tg += id(j, i, k);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tBitSet used = new BitSet(w*w*h*h);\n\t\t\tQueue<Integer> qu = new LinkedList<Integer>();\n\t\t\tqu.add(s);\n\t\t\tused.set(s);\n\t\t\tint hw = h*w;\n\t\t\tint whw = w*h*w;\n\t\t\tboolean flag = false;\n\t\t\twhile(!qu.isEmpty()){\n\t\t\t\tint id = qu.poll();\n\t\t\t\tif(id == g){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint y0 = id/whw;\n\t\t\t\tid %= whw;\n\t\t\t\tint x0 = id/hw;\n\t\t\t\tid %= hw;\n\t\t\t\tint y1 = id/w;\n\t\t\t\tint x1 = id%w;\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tint nid = next(x0, y0, x1, y1, i);\n\t\t\t\t\tif(used.get(nid)) continue;\n\t\t\t\t\tused.set(nid);\n\t\t\t\t\tqu.add(nid);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(flag ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\t\n\tpublic static String dump(char[][] map){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tsb.append(map[i][j]+\" \");\n\t\t\t}\n\t\t\tsb.append('\\n');\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tpublic static int next(int x0, int y0, int x1, int y1, int dir){\n\t\tint nx0 = x0 + dx[dir];\n\t\tint ny0 = y0 + dy[dir];\n\t\tif(nx0 < 0 || nx0 >= w || ny0 < 0 || ny0 >= h\n\t\t\t\t|| map[0][ny0][nx0] == '#'){\n\t\t\tnx0 = x0;\n\t\t\tny0 = y0;\n\t\t}\n\t\tint nx1 = x1 + dx[dir];\n\t\tint ny1 = y1 + dy[dir];\n\t\tif(nx1 < 0 || nx1 >= w || ny1 < 0 || ny1 >= h\n\t\t\t\t|| map[1][ny1][nx1] == '#'){\n\t\t\tnx1 = x1;\n\t\t\tny1 = y1;\n\t\t}\n\t\treturn id(0, ny0, nx0) + id(1, ny1, nx1);\n\t}\n\t\n\tpublic static int id(int room, int y, int x){\n\t\treturn room==0 ? (y*w+x)*w*h : y*w+x;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Scanner;\nimport java.util.Queue;\nimport java.util.ArrayDeque;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        MirrorCave solver = new MirrorCave();\n        try {\n            int testNumber = 1;\n            while (true)\n                solver.solve(testNumber++, in, out);\n        } catch (UnknownError e) {\n            out.close();\n        }\n    }\n\n    static class MirrorCave {\n        final int dh = new int[]{0, -1, 0, 1};\n        final int dw = new int[]{-1, 0, 1, 0};\n        final int dh2 = new int[]{0, -1, 0, 1};\n        final int dw2 = new int[]{1, 0, -1, 0};\n\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int W = in.nextInt();\n            int H = in.nextInt();\n            if (W == 0) {\n                throw new UnknownError();\n            }\n            String[] L = new String[H];\n            String[] R = new String[H];\n            int lh = -1, lw = -1, rh = -1, rw = -1;\n            int glh = -1, glw = -1, grh = -1, grw = -1;\n            for (int i = 0; i < H; ++i) {\n                L[i] = in.next();\n                R[i] = in.next();\n                for (int j = 0; j < W; ++j) {\n                    if (L[i].charAt(j) == 'L') {\n                        lh = i;\n                        lw = j;\n                    }\n                    if (R[i].charAt(j) == 'R') {\n                        rh = i;\n                        rw = j;\n                    }\n                    if (L[i].charAt(j) == '%') {\n                        glh = i;\n                        glw = j;\n                    }\n                    if (R[i].charAt(j) == '%') {\n                        grh = i;\n                        grw = j;\n                    }\n                }\n            }\n            boolean[][][][] vis = new boolean[H][W][H][W];\n            for (int i = 0; i < H; ++i) {\n                for (int j = 0; j < W; ++j) {\n                    for (int k = 0; k < H; ++k) {\n                        Arrays.fill(vis[i][j][k], false);\n                    }\n                }\n            }\n            Queue<State> q = new ArrayDeque<>();\n            q.add(new State(lh, lw, rh, rw));\n            while (!q.isEmpty()) {\n                State now = q.poll();\n                if (vis[now.lh][now.lw][now.rh][now.rw]) {\n                    continue;\n                }\n                vis[now.lh][now.lw][now.rh][now.rw] = true;\n                if (now.lh == glh && now.rh == grh && now.lw == glw && now.rw == grw) {\n                    out.println(\"Yes\");\n                    return;\n                }\n                for (int i = 0; i < 4; ++i) {\n                    State next = new State(now.lh + dh[i], now.lw + dw[i], now.rh + dh2[i], now.rw + dw2[i]);\n                    if (0 <= next.lh && next.lh < H && 0 <= next.lw && next.lw < W && 0 <= next.rh && next.rh < H && 0 <= next.rw && next.rw < W) {\n                        if (L[next.lh].charAt(next.lw) == '#') {\n                            if (next.lh != now.lh) {\n                                next.lh = now.lh;\n                            }\n                            if (next.lw != now.lw) {\n                                next.lw = now.lw;\n                            }\n                        }\n                        if (R[next.rh].charAt(next.rw) == '#') {\n                            if (next.rh != now.rh) {\n                                next.rh = now.rh;\n                            }\n                            if (next.rw != now.rw) {\n                                next.rw = now.rw;\n                            }\n                        }\n                        if (vis[next.lh][next.lw][next.rh][next.rw]) {\n                            continue;\n                        }\n                        q.add(next);\n                    }\n                }\n            }\n            out.println(\"No\");\n            return;\n        }\n\n        public class State {\n            int lh;\n            int lw;\n            int rh;\n            int rw;\n\n            State(int lh, int lw, int rh, int rw) {\n                this.lh = lh;\n                this.lw = lw;\n                this.rh = rh;\n                this.rw = rw;\n            }\n\n        }\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tprivate static final int[][] d = { { -1, 0 }, { 1, 0 }, { 0, 1 }, { 0, -1 } };\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint W = sc.nextInt();\n\t\t\tif (W == 0) {\n\t\t\t\tsc.close();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint H = sc.nextInt();\n\n\t\t\tchar[][] mapL = new char[H + 2][];\n\t\t\tchar[][] mapR = new char[H + 2][];\n\n\t\t\tchar[] wall = new char[W + 2];\n\t\t\tArrays.fill(wall, '#');\n\t\t\tmapL[0] = wall;\n\t\t\tmapR[0] = wall;\n\t\t\tmapL[H + 1] = wall;\n\t\t\tmapR[H + 1] = wall;\n\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tString lineL = \"#\" + sc.next() + \"#\";\n\t\t\t\tmapL[i + 1] = lineL.toCharArray();\n\t\t\t\tString lineR = \"#\" + sc.next() + \"#\";\n\t\t\t\tmapR[i + 1] = lineR.toCharArray();\n\t\t\t}\n\n\t\t\tInteger[] posi = new Integer[4];\n\t\t\tfor (int i = 0; i < mapL.length; i++) {\n\t\t\t\tfor (int j = 0; j < mapL[i].length; j++) {\n\t\t\t\t\tif (mapL[i][j] == 'L') {\n\t\t\t\t\t\tposi[0] = i;\n\t\t\t\t\t\tposi[1] = j;\n\t\t\t\t\t}\n\t\t\t\t\tif (mapR[i][j] == 'R') {\n\t\t\t\t\t\tposi[2] = i;\n\t\t\t\t\t\tposi[3] = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean[][] used = new boolean[5051][5051];\n\t\t\tDeque<Integer[]> bfs = new ArrayDeque<Integer[]>();\n\t\t\tbfs.addLast(posi);\n\t\t\tused[posi[0] * 100 + posi[1]][posi[2] * 100 + posi[3]] = true;\n\t\t\tboolean cleared = false;\n\t\t\tbfs: while (!bfs.isEmpty()) {\n\t\t\t\tInteger[] poll = bfs.pollFirst();\n\t\t\t\tint iL = poll[0];\n\t\t\t\tint jL = poll[1];\n\t\t\t\tint iR = poll[2];\n\t\t\t\tint jR = poll[3];\n\n\t\t\t\tfor (int i = 0; i < d.length; i++) {\n\t\t\t\t\tchar nextL = mapL[iL + d[i][0]][jL + d[i][1]];\n\t\t\t\t\tchar nextR = mapR[iR + d[i][0]][jR - d[i][1]];\n\n\t\t\t\t\tif (nextL == '#' && nextR == '#') {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (nextL == '%' && nextR == '%') {\n\t\t\t\t\t\t// YES\n\t\t\t\t\t\tcleared = true;\n\t\t\t\t\t\tbreak bfs;\n\t\t\t\t\t} else if ((nextL == '%' && nextR != '%') || (nextL != '%' && nextR == '%')) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (nextL == '#' && nextR == '.' && !used[iL * 100 + jL][(iR + d[i][0]) * 100 + jR - d[i][1]]) {\n\t\t\t\t\t\t\tused[iL * 100 + jL][(iR + d[i][0]) * 100 + jR - d[i][1]] = true;\n\t\t\t\t\t\t\tInteger[] push = { iL, jL, iR + d[i][0], jR - d[i][1] };\n\t\t\t\t\t\t\tbfs.addLast(push);\n\t\t\t\t\t\t} else if (nextR == '#' && nextL == '.'\n\t\t\t\t\t\t\t\t&& !used[(iL + d[i][0]) * 100 + jL + d[i][1]][iR * 100 + jR]) {\n\t\t\t\t\t\t\tused[(iL + d[i][0]) * 100 + jL + d[i][1]][iR * 100 + jR] = true;\n\t\t\t\t\t\t\tInteger[] push = { iL + d[i][0], jL + d[i][1], iR, jR };\n\t\t\t\t\t\t\tbfs.addLast(push);\n\t\t\t\t\t\t} else if (nextL == '.' && nextR == '.'\n\t\t\t\t\t\t\t\t&& !used[(iL + d[i][0]) * 100 + jL + d[i][1]][(iR + d[i][0]) * 100 + jR - d[i][1]]) {\n\t\t\t\t\t\t\tused[(iL + d[i][0]) * 100 + jL + d[i][1]][(iR + d[i][0]) * 100 + jR - d[i][1]] = true;\n\t\t\t\t\t\t\tInteger[] push = { iL + d[i][0], jL + d[i][1], iR + d[i][0], jR - d[i][1] };\n\t\t\t\t\t\t\tbfs.addLast(push);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cleared) {\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t\tSystem.gc();\n\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static final void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tint w;\n\tint h;\n\tchar[][] map;\n\tint sl;\n\tint sr;\n\tpublic Main() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif(w==0 && h==0)\n\t\t\t\tbreak;\n\t\t\tmap = new char[2][w*h];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tString s0 = sc.next();\n\t\t\t\tString s1 = sc.next();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tmap[0][i*w+j] = s0.charAt(j);\n\t\t\t\t\tmap[1][i*w+j] = s1.charAt(w-j-1);\n\t\t\t\t\tif(map[0][i*w+j]=='L')\n\t\t\t\t\t\tsl = i*w+j;\n\t\t\t\t\tif(map[1][i*w+j]=='R')\n\t\t\t\t\t\tsr = i*w+j;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tint[] dx = new int[]{-1, 0, 1, 0};\n\tint[] dy = new int[]{0, -1, 0, 1};\n\tprivate void solve() {\n\t\tLinkedList<int[]> queue = new LinkedList<>();\n\t\t\n\t\tint[][] visited = new int[w*h][w*h];\n\t\tqueue.add(new int[]{sl, sr});\n\n\t\twhile(!queue.isEmpty()){\n\t\t\tint[] cp = queue.poll();\n\t\t\tint clp = cp[0];\n\t\t\tint crp = cp[1];\n\t\t\t\n\t\t\tif(visited[clp][crp]==1)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tvisited[clp][crp] = 1;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nlp = clp + dx[i] + dy[i]*w;\n\t\t\t\tint nrp = crp + dx[i] + dy[i]*w;\n\t\t\t\tif(nlp<0 || w*h<=nlp || nrp<0 || w*h<=nrp)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(map[0][nlp]=='#')\n\t\t\t\t\tnlp = clp;\n\t\t\t\tif(map[1][nrp]=='#')\n\t\t\t\t\tnrp = crp;\n\t\t\t\t\n\t\t\t\tif(map[0][nlp]=='%' && map[1][nrp]=='%'){\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tqueue.add(new int[]{nlp, nrp});\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"No\");\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.BitSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static int w, h;\n\tpublic static char[][][] map = new char[50][50][2];\n\tpublic static final int[] dx = {1, 0, -1, 0};\n\tpublic static final int[] dy = {0, 1, 0, -1};\n\tpublic static int[] gx = new int[2];\n\tpublic static int[] gy = new int[2];\n\tpublic static int[] sx = new int[2];\n\tpublic static int[] sy = new int[2];\n\tpublic static BitSet used = new BitSet(50*50*50*50);\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = in.nextInt();\n\t\t\th = in.nextInt();\n\t\t\tif(w == 0) break;\n//\t\t\tmap = new char[2][h][w];\n\t\t\tfor(int j=0; j<h; j++){\n\t\t\t\tfor(int i=0; i<2; i++){\n\t\t\t\t\tmap[i][j] = in.next().toCharArray();\n\t\t\t\t\tfor(int k=0; k<w; k++){\n\t\t\t\t\t\tif(map[i][j][k] == '%'){\n\t\t\t\t\t\t\tgx[i] = k;\n\t\t\t\t\t\t\tgy[i] = j;\n\t\t\t\t\t\t}else if(map[i][j][k] == 'L' || map[i][j][k] == 'R'){\n\t\t\t\t\t\t\tsx[i] = k;\n\t\t\t\t\t\t\tsy[i] = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tused.clear();\n\t\t\tQueue<Integer> qu = new LinkedList<Integer>();\n\t\t\tqu.add(set(sy[0], sx[0], sy[1], sx[1]));\n\t\t\tused.set(id(qu.peek()));\n\t\t\tboolean goal = false;\n\t\t\twhile(!qu.isEmpty()){\n\t\t\t\tint p = qu.poll();\n\t\t\t\tint y1 = p>>18;\n\t\t\t\tint x1 = (p>>12)&mask;\n\t\t\t\tint y2 = (p>>6)&mask;\n\t\t\t\tint x2 = p&mask;\n\t\t\t\tif(y1==4 && x1==2)\n\t\t\t\t\tSystem.err.println();\n\t\t\t\tif(goal(y1, x1, y2, x2)){\n\t\t\t\t\tgoal = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(oneGoal(y1, x1, y2, x2)) continue;\n\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\tint np = move(y1, x1, y2, x2, i);\n\t\t\t\t\tint id = id(np);\n\t\t\t\t\tif(used.get(id)) continue;\n\t\t\t\t\tused.set(id);\n\t\t\t\t\tqu.add(np);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(goal?\"Yes\":\"No\");\n\t\t}\n\t}\n\t\n\tpublic static int set(int y1, int x1, int y2, int x2){\n\t\treturn y1<<(6+6+6) | x1<<(6+6) | y2<<6 | x2;\n\t}\n\t\n\tpublic static int move(int y1, int x1, int y2, int x2, int dir){\n\t\tint nx1 = x1+dx[dir];\n\t\tint ny1 = y1+dy[dir];\n\t\tif(out(ny1, nx1) || map[0][ny1][nx1] == '#'){\n\t\t\tnx1 = x1;\n\t\t\tny1 = y1;\n\t\t}\n\t\tint nx2 = x2-dx[dir];\n\t\tint ny2 = y2+dy[dir];\n\t\tif(out(ny2, nx2) || map[1][ny2][nx2] == '#'){\n\t\t\tnx2 = x2;\n\t\t\tny2 = y2;\n\t\t}\n\t\treturn set(ny1, nx1, ny2, nx2);\n\t}\n\t\n\tpublic static boolean out(int y, int x){\n\t\treturn x < 0 || x >= w || y < 0 || y >= h;\n\t}\n\t\n\tpublic static boolean goal(int y1, int x1, int y2, int x2){\n\t\treturn x1 == gx[0] && y1 == gy[0] && x2 == gx[1] && y2 == gy[1];\n\t}\n\t\n\tpublic static boolean oneGoal(int y1, int x1, int y2, int x2){\n\t\treturn x1 == gx[0] && y1 == gy[0] || x2 == gx[1] && y2 == gy[1];\n\t}\n\t\n\tpublic static int id(int y1, int x1, int y2, int x2){\n\t\treturn y1*h*w*w + x1*h*w + y2*w + x2;\n\t}\n\t\n\tpublic static final int mask = (1<<6)-1;\n\tpublic static int id(int hash){\n\t\treturn (hash>>18)*h*w*w + ((hash>>12)&mask)*h*w + ((hash>>6)&mask)*w + (hash&mask);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class Main {\n\tint w, h;\n\tchar[][] l, r;\n\tint[] ldx = { -1, 0, 0, 1 };\n\tint[] ldy = { 0, -1, 1, 0 };\n\tint[] rdx = { 1, 0, 0, -1 };\n\tint[] rdy = { 0, -1, 1, 0 };\n\tint slx, sly, srx, sry;\n\n\tboolean bfs() {\n\t\tQueue<Integer> lxque = new LinkedList<Integer>();\n\t\tQueue<Integer> lyque = new LinkedList<Integer>();\n\t\tQueue<Integer> rxque = new LinkedList<Integer>();\n\t\tQueue<Integer> ryque = new LinkedList<Integer>();\n\n\t\tlxque.add(slx);\n\t\tlyque.add(sly);\n\t\trxque.add(srx);\n\t\tryque.add(sry);\n\n\t\tboolean[][][][] vis = new boolean[w][h][w][h];\n\n\t\twhile (!lxque.isEmpty()) {\n\t\t\tint lx = lxque.poll();\n\t\t\tint ly = lyque.poll();\n\t\t\tint rx = rxque.poll();\n\t\t\tint ry = ryque.poll();\n\n\t\t\tif (vis[lx][ly][rx][ry]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvis[lx][ly][rx][ry] = true;\n\t\t\tif (l[ly][lx] == '%' && r[ry][rx] == '%') {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (l[ly][lx] == '%' || r[ry][rx] == '%') {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//\t\t\tSystem.out.println(lx + \", \" + ly + \", \" + rx + \", \" + ry);\n\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint nlx = lx + ldx[i];\n\t\t\t\tint nly = ly + ldy[i];\n\t\t\t\tint nrx = rx + rdx[i];\n\t\t\t\tint nry = ry + rdy[i];\n\n\t\t\t\tif (nlx < 0 || w <= nlx || nly < 0 || h <= nly || l[nly][nlx] == '#') {\n\t\t\t\t\tnlx -= ldx[i];\n\t\t\t\t\tnly -= ldy[i];\n\t\t\t\t}\n\t\t\t\tif (nrx < 0 || w <= nrx || nry < 0 || h <= nry || r[nry][nrx] == '#') {\n\t\t\t\t\tnrx -= rdx[i];\n\t\t\t\t\tnry -= rdy[i];\n\t\t\t\t}\n\t\t\t\tif (vis[nlx][nly][nrx][nry]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlxque.add(nlx);\n\t\t\t\tlyque.add(nly);\n\t\t\t\trxque.add(nrx);\n\t\t\t\tryque.add(nry);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\twhile (true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif ((w | h) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tl = new char[h][];\n\t\t\tr = new char[h][];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tl[i] = sc.next().toCharArray();\n\t\t\t\tr[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (l[i][j] == 'L') {\n\t\t\t\t\t\tslx = j;\n\t\t\t\t\t\tsly = i;\n\t\t\t\t\t\tl[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t\tif (r[i][j] == 'R') {\n\t\t\t\t\t\tsrx = j;\n\t\t\t\t\t\tsry = i;\n\t\t\t\t\t\tr[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(bfs());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.math.BigInteger;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nimport javax.xml.crypto.Data;\npublic class Main{\n\tstatic int INF = 2 << 28;\n\tstatic int[] vxL = {0,0,1,-1};\n\tstatic int[] vxR = {0,0,-1,1};\n\tstatic int[] vyL = {1,-1,0,0};\n\tstatic int[] vyR = {1,-1,0,0};\n\tstatic int w;\n\tstatic int h;\n\tstatic int Lx;\n\tstatic int Ly;\n\tstatic int Rx;\n\tstatic int Ry;\n\tstatic char[][] mapL;\n\tstatic char[][] mapR;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif(w == 0 && h == 0) break;\n\t\t\tmapL = new char[h][];\n\t\t\tmapR = new char[h][];\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tmapL[i] = sc.next().toCharArray();\n\t\t\t\tmapR[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tLx = 0;\n\t\t\tLy = 0;\n\t\t\tRx = 0;\n\t\t\tRy = 0;\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(mapL[i][j] == 'L') {\n\t\t\t\t\t\tLy = i;\n\t\t\t\t\t\tLx = j;\n\t\t\t\t\t\tmapL[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t\tif(mapR[i][j] == 'R') {\n\t\t\t\t\t\tRy = i;\n\t\t\t\t\t\tRx = j;\n\t\t\t\t\t\tmapR[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean ans = BFS();\n\t\t\tif(ans) {\n\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t}\n\t\t}\n\t}\t\n\tstatic boolean BFS() {\n\t\tHashMap<Data,Boolean> map = new HashMap<Data,Boolean>();\n\t\tArrayDeque<Data> queue = new ArrayDeque<Data>();\n\t\tqueue.add(new Data(Lx,Ly,Rx,Ry));\n\t\twhile(!queue.isEmpty()) {\n\t\t\tData tmp = queue.poll();\n\t\t\tif(map.containsKey(tmp)) continue;\n\t\t\tmap.put(tmp, true);\n\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\t\n\t\t\t\tint Ltx = tmp.Lx + vxL[i];\n\t\t\t\tint Lty = tmp.Ly + vyL[i];\n\t\t\t\tint Rtx = tmp.Rx + vxR[i];\n\t\t\t\tint Rty = tmp.Ry + vyR[i];\n\t\t\t\t\n\t\t\t\tint  L = Rcheck(Ltx,Lty,mapL);\n\t\t\t\tint  R = Rcheck(Rtx,Rty,mapR);\n\t\t\t\t\n\t\t\t\tif(L == 2 && R == 2) return true;\n\t\t\t\tif(L == 2 && R != 2) continue;\n\t\t\t\tif(L != 2 && R == 2) continue;\n\t\t\t\tif(L == 0 && R == 0) continue;\n\t\t\t\tif(L == 0) {\n\t\t\t\t\tLtx = tmp.Lx;\n\t\t\t\t\tLty = tmp.Ly;\n\t\t\t\t}\n\t\t\t\tif(R == 0) {\n\t\t\t\t\tRtx = tmp.Rx;\n\t\t\t\t\tRty = tmp.Ry;\n\t\t\t\t}\n\t\t\t\tqueue.addLast(new Data(Ltx,Lty,Rtx,Rty));\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t\t\n\t}\n\tstatic int Rcheck(int x,int y,char[][] map) {\n\t\tif(x < 0 || y < 0 || x >= w || y >= h) return 0;\n\t\tif(map[y][x] == '#') return 0;\n\t\tif(map[y][x] == '.') return 1;\n\t\tif(map[y][x] == '%') return 2;\n\t\treturn -1;\n\t}\n\t\n\tstatic class Data {\n\t\tint Lx;\n\t\tint Ly;\n\t\tint Rx;\n\t\tint Ry;\n\t\tData(int a, int b, int c, int d) {\n\t\t\tLx = a;\n\t\t\tLy = b;\n\t\t\tRx = c;\n\t\t\tRy = d;\n\t\t}\n\t\tpublic boolean equals(Object o) {\n\t\t\tData c = (Data)o;\n\t\t\tif(this.Lx != c.Lx) return false;\n\t\t\tif(this.Ly != c.Ly) return false;\n\t\t\tif(this.Rx != c.Rx) return false;\n\t\t\tif(this.Ry != c.Ry) return false;\n\t\t\treturn true;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class P\n{\n\tpublic int Lx { get; set; }\n\tpublic int Ly { get; set; }\n\tpublic int rx { get; set; }\n\tpublic int ry { get; set; }\n}\n\npublic class hello\n{\n\tpublic static char[,] mapL, mapr;\n\tpublic static int w, h;\n\tpublic static int Lsx, Lsy, rsx, rsy;\n\tpublic static int Lgx, Lgy, rgx, rgy;\n\n\tpublic static void Main()\n\t{\n\t\twhile (true)\n\t\t{\n\t\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\t\tw = int.Parse(line[0]);\n\t\t\th = int.Parse(line[1]);\n\t\t\tif (w == 0 && h == 0) break;\n\t\t\tmapL = new char[h, w];\n\t\t\tmapr = new char[h, w];\n\t\t\tLsx = Lsy = rsx = rsy = 0;\n\t\t\tLgx = Lgy = rgx = rgy = 0;\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t{\n\t\t\t\tline = Console.ReadLine().Trim().Split(' ');\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t{\n\t\t\t\t\tmapL[i, j] = line[0][j];\n\t\t\t\t\tif (line[0][j] == 'L') { Lsx = i; Lsy = j; mapL[i, j] = '.'; }\n\t\t\t\t\tif (line[0][j] == '%') { Lgx = i; Lgy = j; mapL[i, j] = '.'; }\n\t\t\t\t\tmapr[i, j] = line[1][j];\n\t\t\t\t\tif (line[1][j] == 'R') { rsx = i; rsy = j; mapr[i, j] = '.'; }\n\t\t\t\t\tif (line[1][j] == '%') { rgx = i; rgy = j; mapr[i, j] = '.'; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar ans = goBfs(Lsx, Lsy, rsx, rsy);\n\t\t\tConsole.WriteLine(ans);\n\t\t}\n\t}\n\tstatic string goBfs(int Lsx, int Lsy, int rsx, int rsy)\n\t{\n\t\tvar used = new bool[h, w, h, w];\n\t\tused[Lsx, Lsy, rsx, rsy] = true;\n\t\tvar dx = new int[] { 0, 1, 0, -1 };\n\t\tvar dy = new int[] { 1, 0, -1, 0 };\n\t\tvar q = new Queue<P>();\n\t\tq.Enqueue(new P { Lx = Lsx, Ly = Lsy, rx = rsx, ry = rsy });\n\t\twhile (q.Count() > 0)\n\t\t{\n\t\t\tvar a = q.Dequeue();\n\t\t\tif (a.Lx == Lgx && a.Ly == Lgy && a.rx == rgx && a.ry == rgy) return \"Yes\";\n\t\t\tif ((a.Lx == Lgx && a.Ly == Lgy && !(a.rx == rgx && a.ry == rgy))) continue;\n\t\t\tif (!(a.Lx == Lgx && a.Ly == Lgy) && a.rx == rgx && a.ry == rgy) continue;\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tvar nLx = a.Lx + dx[i];\n\t\t\t\tvar nLy = a.Ly + dy[i];\n\t\t\t\tvar nrx = a.rx + dx[i];\n\t\t\t\tvar nry = a.ry - dy[i];\n\t\t\t\tif (!(nLx >= 0 && nLx < h && nLy >= 0 && nLy < w)) { nLx = a.Lx; nLy = a.Ly; }\n\t\t\t\tif (!(nrx >= 0 && nrx < h && nry >= 0 && nry < w)) { nrx = a.rx; nry = a.ry; }\n\t\t\t\tif (mapL[nLx, nLy] == '#') { nLx = a.Lx; nLy = a.Ly; }\n\t\t\t\tif (mapr[nrx, nry] == '#') { nrx = a.rx; nry = a.ry; }\n\t\t\t\tif (!used[nLx, nLy, nrx, nry])\n\t\t\t\t{\n\t\t\t\t\tq.Enqueue(new P { Lx = nLx, Ly = nLy, rx = nrx, ry = nry });\n\t\t\t\t\tused[nLx, nLy, nrx, nry] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn \"No\";\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing static System.Console;\nusing static System.Math;\n\nnamespace AtTest.HCPC2019_29\n{\n    class C\n    {\n        static void Main(string[] args)\n        {\n            var sw = new System.IO.StreamWriter(OpenStandardOutput()) { AutoFlush = false };\n            SetOut(sw);\n\n            Method(args);\n\n            Out.Flush();\n        }\n\n        static void Method(string[] args)\n        {\n            int[] dx = new int[4] { 1, -1, 0, 0 };\n            int[] dy = new int[4] { 0, 0, 1, -1 };\n            while (true)\n            {\n                int[] wh = ReadInts();\n                int w = wh[0];\n                int h = wh[1];\n                if (h == 0) break;\n\n                bool[,] gridL, gridR;\n                gridL = new bool[h, w];\n                gridR = new bool[h, w];\n                int[] lStart, rStart, lGoal, rGoal;\n                lStart = new int[2] { 0, 0 };\n                rStart = new int[2] { 0, 0 };\n                lGoal = new int[2] { 0, 0 };\n                rGoal = new int[2] { 0, 0 };\n                for (int i = 0; i < h; i++)\n                {\n                    string s = Read();\n                    for (int j = 0; j < w; j++)\n                    {\n                        gridL[i, j] = true;\n                        switch (s[j])\n                        {\n                            case '#':\n                                gridL[i, j] = false;\n                                break;\n                            case 'L':\n                                lStart = new int[2] { i, j };\n                                break;\n                            case '%':\n                                lGoal = new int[2] { i, j };\n                                break;\n                        }\n                        gridR[i, j] = true;\n                        switch (s[s.Length - 1 - j])\n                        {\n                            case '#':\n                                gridR[i, j] = false;\n                                break;\n                            case 'R':\n                                rStart = new int[2] { i, j };\n                                break;\n                            case '%':\n                                rGoal = new int[2] { i, j };\n                                break;\n                        }\n                    }\n                }\n\n                bool[,,,] cans = new bool[h, w, h, w];\n                Queue<int[]> queue = new Queue<int[]>();\n                queue.Enqueue(new int[4] { lStart[0], lStart[1],\n                    rStart[0], rStart[1] });\n                bool done = false;\n                while (queue.Count > 0)\n                {\n                    int[] val = queue.Dequeue();\n                    int lY = val[0];\n                    int lX = val[1];\n                    int rY = val[2];\n                    int rX = val[3];\n                    if(lY==lGoal[0]&&lX==lGoal[1]\n                        && rY == rGoal[0] && rX == rGoal[1])\n                    {\n                        WriteLine(\"Yes\");\n                        done = true;\n                        break;\n                    }\n                    if ((lY == lGoal[0] && lX == lGoal[1])\n                        || (rY == rGoal[0] && rX == rGoal[1])) continue;\n                    if (cans[lY, lX, rY, rX]) continue;\n\n                    cans[lY, lX, rY, rX] = true;\n                    for(int i = 0; i < 4; i++)\n                    {\n                        int llY = lY + dy[i];\n                        int llX = lX + dx[i];\n                        int rrY = rY + dy[i];\n                        int rrX = rX + dx[i];\n                        if (llY < 0 || llY >= h || !gridL[llY, lX]) llY = lY;\n                        if (llX < 0 || llX >= w || !gridL[lY, llX]) llX= lX;\n                        if (rrY < 0 || rrY >= h || !gridR[rrY, rX]) rrY = rY;\n                        if (rrX < 0 || rrX >= w || !gridR[rY, rrX]) rrX = rX;\n\n                        if (!cans[llY, llX, rrY, rrX])\n                        {\n                            queue.Enqueue(new int[4] { llY,llX,rrY,rrX });\n                        }\n                    }\n                }\n                if (!done) WriteLine(\"No\");\n            }\n        }\n\n        private static string Read() { return ReadLine(); }\n        private static char[] ReadChars() { return Array.ConvertAll(Read().Split(), a => a[0]); }\n        private static int ReadInt() { return int.Parse(Read()); }\n        private static long ReadLong() { return long.Parse(Read()); }\n        private static double ReadDouble() { return double.Parse(Read()); }\n        private static int[] ReadInts() { return Array.ConvertAll(Read().Split(), int.Parse); }\n        private static long[] ReadLongs() { return Array.ConvertAll(Read().Split(), long.Parse); }\n        private static double[] ReadDoubles() { return Array.ConvertAll(Read().Split(), double.Parse); }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class P\n{\n    public int xL { get; set; }\n    public int yL { get; set; }\n    public int xr { get; set; }\n    public int yr { get; set; }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var w = int.Parse(line[0]);\n            var h = int.Parse(line[1]);\n            if (w == 0 && h == 0) break;\n            var mapL = new char[h, w];\n            var mapr = new char[h, w];\n            var ps = new P();\n            var pg = new P();\n            for (int i = 0; i < h; i++)\n            {\n                var s = Console.ReadLine().Trim();\n                for (int j = 0; j < w; j++)\n                {\n                    mapL[i, j] = s[j];\n                    if (s[j] == 'L') { ps.xL = i; ps.yL = j; mapL[i, j] = '.'; }\n                    if (s[j] == '%') { pg.xL = i; pg.yL = j; mapL[i, j] = '.'; }\n                }\n                for (int j = 0; j < w; j++)\n                {\n                    mapr[i, j] = s[w + j + 1];\n                    if (s[w + j + 1] == 'R') { ps.xr = i; ps.yr = j; mapr[i, j] = '.'; }\n                    if (s[w + j + 1] == '%') { pg.xr = i; pg.yr = j; mapr[i, j] = '.'; }\n                }\n            }\n            var ret = getAns(mapL, mapr, ps, pg);\n            Console.WriteLine(ret ? \"Yes\" : \"No\");\n        }\n    }\n    public static bool getAns(char[,] mapL, char[,] mapr, P ps, P pg)\n    {\n        var dx = new int[] { 0, 1, 0, -1 };\n        var dy = new int[] { 1, 0, -1, 0 };\n        var h = mapL.GetLength(0);\n        var w = mapL.GetLength(1);\n        var used = new bool[h, w, h, w];\n        used[ps.xL, ps.yL, ps.xr, ps.yr] = true;\n        var q = new Queue<int>();\n        q.Enqueue(ps.xL);\n        q.Enqueue(ps.yL);\n        q.Enqueue(ps.xr);\n        q.Enqueue(ps.yr);\n        while (q.Count() > 0)\n        {\n            var xL = q.Dequeue();\n            var yL = q.Dequeue();\n            var xr = q.Dequeue();\n            var yr = q.Dequeue();\n            if (xL == pg.xL &&  yL == pg.yL && xr == pg.xr && yr == pg.yr) return true;\n            if ((xL == pg.xL && yL == pg.yL) || (xr == pg.xr && yr == pg.yr)) continue;\n            for (int i = 0; i < 4; i++)\n            {\n                var nxL = xL + dx[i];\n                var nyL = yL + dy[i];\n                if (!(nxL >= 0 && nxL < h && nyL >= 0 && nyL < w && mapL[nxL, nyL] == '.')) { nxL = xL; nyL = yL; }\n                var nxr = xr + dx[i];\n                var nyr = yr - dy[i];\n                if (!(nxr >= 0 && nxr < h && nyr >= 0 && nyr < w && mapr[nxr, nyr] == '.')) { nxr = xr; nyr = yr; }\n                if (!used[nxL, nyL, nxr, nyr])\n                {\n                    q.Enqueue(nxL);\n                    q.Enqueue(nyL);\n                    q.Enqueue(nxr);\n                    q.Enqueue(nyr);\n                    used[nxL, nyL, nxr, nyr] = true;\n                }\n            }\n        }\n        return false;\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class P\n{\n    public int xL { get; set; }\n    public int yL { get; set; }\n    public int xr { get; set; }\n    public int yr { get; set; }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var w = int.Parse(line[0]);\n            var h = int.Parse(line[1]);\n            if (w == 0 && h == 0) break;\n            var mapL = new char[h, w];\n            var mapr = new char[h, w];\n            var ps = new P();\n            var pg = new P();\n            for (int i = 0; i < h; i++)\n            {\n                var s = Console.ReadLine().Trim();\n                for (int j = 0; j < w; j++)\n                {\n                    mapL[i, j] = s[j];\n                    if (s[j] == 'L') { ps.xL = i; ps.yL = j; mapL[i, j] = '.'; }\n                    if (s[j] == '%') { pg.xL = i; pg.yL = j; mapL[i, j] = '.'; }\n                }\n                for (int j = 0; j < w; j++)\n                {\n                    mapr[i, j] = s[w + j + 1];\n                    if (s[w + j + 1] == 'R') { ps.xr = i; ps.yr = j; mapr[i, j] = '.'; }\n                    if (s[w + j + 1] == '%') { pg.xr = i; pg.yr = j; mapr[i, j] = '.'; }\n                }\n            }\n            var ret = getAns(mapL, mapr, ps, pg);\n            Console.WriteLine(ret ? \"Yes\" : \"No\");\n        }\n    }\n    public static bool getAns(char[,] mapL, char[,] mapr, P ps, P pg)\n    {\n        var dx = new int[] { 0, 1, 0, -1 };\n        var dyL = new int[] { 1, 0, -1, 0 };\n        var dyr = new int[] { -1, 0, 1, 0 };\n        var h = mapL.GetLength(0);\n        var w = mapL.GetLength(1);\n        var used = new bool[h, w, h, w];\n        used[ps.xL, ps.yL, ps.xr, ps.yr] = true;\n        var q = new Queue<int>();\n        q.Enqueue(ps.xL);\n        q.Enqueue(ps.yL);\n        q.Enqueue(ps.xr);\n        q.Enqueue(ps.yr);\n        while (q.Count() > 0)\n        {\n            var xL = q.Dequeue();\n            var yL = q.Dequeue();\n            var xr = q.Dequeue();\n            var yr = q.Dequeue();\n            if (xL == pg.xL &&  yL == pg.yL && xr == pg.xr && yr == pg.yr) return true;\n            if ((xL == pg.xL && yL == pg.yL) || (xr == pg.xr && yr == pg.yr)) continue;\n            for (int i = 0; i < 4; i++)\n            {\n                var nxL = xL + dx[i];\n                var nyL = yL + dyL[i];\n                if (!(nxL >= 0 && nxL < h && nyL >= 0 && nyL < w && mapL[nxL, nyL] == '.')) { nxL = xL; nyL = yL; }\n                var nxr = xr + dx[i];\n                var nyr = yr + dyr[i];\n                if (!(nxr >= 0 && nxr < h && nyr >= 0 && nyr < w && mapr[nxr, nyr] == '.')) { nxr = xr; nyr = yr; }\n                if (!used[nxL, nyL, nxr, nyr])\n                {\n                    q.Enqueue(nxL);\n                    q.Enqueue(nyL);\n                    q.Enqueue(nxr);\n                    q.Enqueue(nyr);\n                    used[nxL, nyL, nxr, nyr] = true;\n                }\n            }\n        }\n        return false;\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class P\n{\n    public int xL { get; set; }\n    public int yL { get; set; }\n    public int xr { get; set; }\n    public int yr { get; set; }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var w = int.Parse(line[0]);\n            var h = int.Parse(line[1]);\n            if (w == 0 && h == 0) break;\n            var mapL = new char[h, w];\n            var mapr = new char[h, w];\n            var ps = new P();\n            var pg = new P();\n            for (int i = 0; i < h; i++)\n            {\n                var s = Console.ReadLine().Trim();\n                for (int j = 0; j < w; j++)\n                {\n                    mapL[i, j] = s[j];\n                    mapr[i, j] = s[w + j + 1];\n                    if (s[j] == 'L') { ps.xL = i; ps.yL = j; mapL[i, j] = '.'; }\n                    if (s[j] == '%') { pg.xL = i; pg.yL = j; mapL[i, j] = '.'; }\n                    if (s[w + j + 1] == 'R') { ps.xr = i; ps.yr = j; mapr[i, j] = '.'; }\n                    if (s[w + j + 1] == '%') { pg.xr = i; pg.yr = j; mapr[i, j] = '.'; }\n                }\n            }\n            var ret = getAns(mapL, mapr, ps, pg);\n            Console.WriteLine(ret ? \"Yes\" : \"No\");\n        }\n    }\n    public static bool getAns(char[,] mapL, char[,] mapr, P ps, P pg)\n    {\n        var dx = new int[] { 0, 1, 0, -1 };\n        var dyL = new int[] { 1, 0, -1, 0 };\n        var dyr = new int[] { -1, 0, 1, 0 };\n        var h = mapL.GetLength(0);\n        var w = mapL.GetLength(1);\n        var used = new bool[h, w, h, w];\n        used[ps.xL, ps.yL, ps.xr, ps.yr] = true;\n        var q = new Queue<P>();\n        q.Enqueue(new P { xL = ps.xL, yL = ps.yL, xr = ps.xr, yr = ps.yr });\n        while (q.Count() > 0)\n        {\n            var t = q.Dequeue();\n            if (t.xL == pg.xL && t.yL == pg.yL && t.xr == pg.xr && t.yr == pg.yr) return true;\n            if ((t.xL == pg.xL && t.yL == pg.yL) || (t.xr == pg.xr && t.yr == pg.yr)) continue;\n            for (int i = 0; i < 4; i++)\n            {\n                var nxL = t.xL + dx[i];\n                var nyL = t.yL + dyL[i];\n                if (!(nxL >= 0 && nxL < h && nyL >= 0 && nyL < w && mapL[nxL, nyL] == '.')) { nxL = t.xL; nyL = t.yL; }\n                var nxr = t.xr + dx[i];\n                var nyr = t.yr + dyr[i];\n                if (!(nxr >= 0 && nxr < h && nyr >= 0 && nyr < w && mapr[nxr, nyr] == '.')) { nxr = t.xr; nyr = t.yr; }\n                if (!used[nxL, nyL, nxr, nyr])\n                {\n                    q.Enqueue(new P { xL = nxL, yL = nyL, xr = nxr, yr = nyr });\n                    used[nxL, nyL, nxr, nyr] = true;\n                }\n            }\n        }\n        return false;\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class P\n{\n    public int xL { get; set; }\n    public int yL { get; set; }\n    public int xr { get; set; }\n    public int yr { get; set; }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var w = int.Parse(line[0]);\n            var h = int.Parse(line[1]);\n            if (w == 0 && h == 0) break;\n            var mapL = new char[h, w];\n            var mapr = new char[h, w];\n            var ps = new P();\n            var pg = new P();\n            for (int i = 0; i < h; i++)\n            {\n                var s = Console.ReadLine().Trim();\n                for (int j = 0; j < w; j++)\n                {\n                    mapL[i, j] = s[j];\n                    mapr[i, j] = s[w + j + 1];\n                    if (s[j] == 'L') { ps.xL = i; ps.yL = j; mapL[i, j] = '.'; }\n                    if (s[j] == '%') { pg.xL = i; pg.yL = j; mapL[i, j] = '.'; }\n                    if (s[w + j + 1] == 'R') { ps.xr = i; ps.yr = j; mapr[i, j] = '.'; }\n                    if (s[w + j + 1] == '%') { pg.xr = i; pg.yr = j; mapr[i, j] = '.'; }\n                }\n            }\n            var ret = getAns(mapL, mapr, ps, pg);\n            Console.WriteLine(ret ? \"Yes\" : \"No\");\n        }\n    }\n    public static bool getAns(char[,] mapL, char[,] mapr, P ps, P pg)\n    {\n        var dx = new int[] { 0, 1, 0, -1 };\n        var dyL = new int[] { 1, 0, -1, 0 };\n        var dyr = new int[] { -1, 0, 1, 0 };\n        var h = mapL.GetLength(0);\n        var w = mapL.GetLength(1);\n        var used = new bool[h, w, h, w];\n        used[ps.xL, ps.yL, ps.xr, ps.yr] = true;\n        var q = new Queue<P>();\n        q.Enqueue(new P { xL = ps.xL, yL = ps.yL, xr = ps.xr, yr = ps.yr });\n        while (q.Count() > 0)\n        {\n            var t = q.Dequeue();\n            if (t.xL == pg.xL && t.yL == pg.yL && t.xr == pg.xr && t.yr == pg.yr) return true;\n            if (t.xL == pg.xL && t.yL == pg.yL && !(t.xr == pg.xr && t.yr == pg.yr)) continue;\n            if (!(t.xL == pg.xL && t.yL == pg.yL) && t.xr == pg.xr && t.yr == pg.yr) continue;\n            for (int i = 0; i < 4; i++)\n            {\n                var nxL = t.xL + dx[i];\n                var nyL = t.yL + dyL[i];\n                if (!(nxL >= 0 && nxL < h && nyL >= 0 && nyL < w && mapL[nxL, nyL] == '.')) { nxL = t.xL; nyL = t.yL; }\n                var nxr = t.xr + dx[i];\n                var nyr = t.yr + dyr[i];\n                if (!(nxr >= 0 && nxr < h && nyr >= 0 && nyr < w && mapr[nxr, nyr] == '.')) { nxr = t.xr; nyr = t.yr; }\n                if (!used[nxL, nyL, nxr, nyr])\n                {\n                    q.Enqueue(new P { xL = nxL, yL = nyL, xr = nxr, yr = nyr });\n                    used[nxL, nyL, nxr, nyr] = true;\n                }\n            }\n        }\n        return false;\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class P\n{\n    public int xL { get; set; }\n    public int yL { get; set; }\n    public int xr { get; set; }\n    public int yr { get; set; }\n}\n\npublic class Hello\n{\n    public static int[] dx = new int[] { 0, 1, 0, -1 };\n    public static int[] dyL = new int[] { 1, 0, -1, 0 };\n    public static int[] dyr = new int[] { -1, 0, 1, 0 };\n\n    public static void Main()\n    {\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var w = int.Parse(line[0]);\n            var h = int.Parse(line[1]);\n            if (w == 0 && h == 0) break;\n            var mapL = new char[h, w];\n            var mapr = new char[h, w];\n            var ps = new P();\n            var pg = new P();\n            for (int i = 0; i < h; i++)\n            {\n                var s = Console.ReadLine().Trim();\n                for (int j = 0; j < w; j++)\n                {\n                    mapL[i, j] = s[j];\n                    mapr[i, j] = s[w + j + 1];\n                    if (s[j] == 'L') { ps.xL = i; ps.yL = j; mapL[i, j] = '.'; }\n                    if (s[j] == '%') { pg.xL = i; pg.yL = j; mapL[i, j] = '.'; }\n                    if (s[w + j + 1] == 'R') { ps.xr = i; ps.yr = j; mapr[i, j] = '.'; }\n                    if (s[w + j + 1] == '%') { pg.xr = i; pg.yr = j; mapr[i, j] = '.'; }\n                }\n            }\n            var ret = getAns(mapL, mapr, ps, pg);\n            Console.WriteLine(ret ? \"Yes\":\"No\");\n        }\n    }\n    public static bool getAns(char[,] mapL, char[,] mapr, P ps, P pg)\n    {\n        var h = mapL.GetLength(0);\n        var w = mapL.GetLength(1);\n        var used = new bool[h, w, h, w];\n        used[ps.xL, ps.yL, ps.xr, ps.yr] = true;\n        var q = new Queue<P>();\n        q.Enqueue(new P { xL = ps.xL, yL = ps.yL, xr = ps.xr, yr = ps.yr });\n        while (q.Count() > 0)\n        {\n            var t = q.Dequeue();\n            if (t.xL == pg.xL && t.yL == pg.yL && t.xr == pg.xr && t.yr == pg.yr) return true;\n            if (t.xL == pg.xL && t.yL == pg.yL && !(t.xr == pg.xr && t.yr == pg.yr)) continue;\n            if (!(t.xL == pg.xL && t.yL == pg.yL) && t.xr == pg.xr && t.yr == pg.yr) continue;\n            for (int i = 0; i < 4; i++)\n            {\n                var nxL = t.xL + dx[i];\n                var nyL = t.yL + dyL[i];\n                if (!(nxL >= 0 && nxL < h && nyL >= 0 && nyL < w && mapL[nxL, nyL] == '.') ) { nxL = t.xL; nyL = t.yL; }\n                var nxr = t.xr + dx[i];\n                var nyr = t.yr + dyr[i];\n                if (!(nxr >= 0 && nxr < h && nyr >= 0 && nyr < w && mapr[nxr, nyr] == '.')) { nxr = t.xr; nyr = t.yr; }\n                 if (!used[nxL,nyL,nxr,nyr])\n                {\n                    q.Enqueue(new P { xL = nxL, yL = nyL, xr = nxr, yr = nyr });\n                    used[nxL, nyL, nxr, nyr] = true;\n                }\n            }\n        }\n        return false;\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace V2153{\n    public class Program{\n        public static void Main(string[] args){\n            var sr = new StreamReader();\n            //---------------------------------\n            var dx = new[]{0, 1, 0, -1};\n            var dy = new[]{1, 0, -1, 0};\n\n            while(true){\n                var W = sr.Next<int>();\n                var H = sr.Next<int>();\n                var C = sr.Next<string>(H * 2);\n                if(W == 0 && H == 0) break;\n\n                var lc = C.Where((_, i) => i % 2 == 0).ToArray();\n                var rc = C.Where((_, i) => i % 2 == 1).Select(s => new string(s.Reverse().ToArray())).ToArray();\n\n                var que = new Queue<int>();\n\n                var glx = 0;\n                var gly = 0;\n                for(var i = 0; i < H; i++){\n                    for(var j = 0; j < W; j++){\n                        if(lc[i][j] == '%'){\n                            glx = j;\n                            gly = i;\n                        }\n                        if(lc[i][j] == 'L'){\n                            que.Enqueue(j);\n                            que.Enqueue(i);\n                        }\n                    }\n                }\n\n                var grx = 0;\n                var gry = 0;\n                for(var i = 0; i < H; i++){\n                    for(var j = 0; j < W; j++){\n                        if(rc[i][j] == '%'){\n                            grx = j;\n                            gry = i;\n                        }\n                        if(rc[i][j] == 'R'){\n                            que.Enqueue(j);\n                            que.Enqueue(i);\n                        }\n                    }\n                }\n\n                Func<int, int, bool> isInside = (x, y) => 0 <= x && x < W && 0 <= y && y < H;\n                var dist = new bool[W, H, W, H];//lx, ly, rx, ry\n\n                while(que.Count > 0){\n                    var lx = que.Dequeue();\n                    var ly = que.Dequeue();\n                    var rx = que.Dequeue();\n                    var ry = que.Dequeue();\n\n                    for(var i = 0; i < 4; i++){\n                        var nlx = lx + dx[i];\n                        var nly = ly + dy[i];\n                        var nrx = rx + dx[i];\n                        var nry = ry + dy[i];\n\n                        if(!isInside(nlx, nly) || lc[nly][nlx] == '#'){\n                            nlx = lx;\n                            nly = ly;\n                        }\n                        if(!isInside(nrx, nry) || rc[nry][nrx] == '#'){\n                            nrx = rx;\n                            nry = ry;\n                        }\n\n                        if(!dist[nlx, nly, nrx, nry] && !((nlx == glx && nly == gly) ^ (nrx == grx && nry == gry))){\n                            dist[nlx, nly, nrx, nry] = true;\n                            que.Enqueue(nlx);\n                            que.Enqueue(nly);\n                            que.Enqueue(nrx);\n                            que.Enqueue(nry);\n                        }\n                    }\n                }\n\n                Console.WriteLine(dist[glx, gly, grx, gry] ? \"Yes\" : \"No\");\n            }\n            //---------------------------------\n        }\n    }\n\n    public class StreamReader{\n        private readonly char[] _c = {' '};\n        private int _index = -1;\n        private string[] _input = new string[0];\n        private readonly System.IO.StreamReader _sr = new System.IO.StreamReader(Console.OpenStandardInput());\n\n        public T Next<T>(){\n            if(_index == _input.Length - 1){\n                _index = -1;\n                while(true){\n                    string rl = _sr.ReadLine();\n                    if(rl == null){\n                        if(typeof(T).IsClass) return default(T);\n                        return (T)typeof(T).GetField(\"MinValue\").GetValue(null);\n                    }\n                    if(rl != \"\"){\n                        _input = rl.Split(_c, StringSplitOptions.RemoveEmptyEntries);\n                        break;\n                    }\n                }\n            }\n            return (T)Convert.ChangeType(_input[++_index], typeof(T), System.Globalization.CultureInfo.InvariantCulture);\n        }\n\n        public T[] Next<T>(int x){\n            var ret = new T[x];\n            for(var i = 0; i < x; ++i) ret[i] = Next<T>();\n            return ret;\n        }\n\n        public T[][] Next<T>(int y, int x){\n            var ret = new T[y][];\n            for(var i = 0; i < y; ++i) ret[i] = Next<T>(x);\n            return ret;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class P\n{\n\tpublic int Lx { get; set; }\n\tpublic int Ly { get; set; }\n\tpublic int rx { get; set; }\n\tpublic int ry { get; set; }\n}\n\npublic class hello\n{\n\tpublic static char[,] mapL, mapr;\n\tpublic static int w, h;\n\tpublic static int Lsx, Lsy, rsx, rsy;\n\tpublic static int Lgx, Lgy, rgx, rgy;\n\n\tpublic static void Main()\n\t{\n\t\twhile (true)\n\t\t{\n\t\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\t\tw = int.Parse(line[0]);\n\t\t\th = int.Parse(line[1]);\n\t\t\tif (w == 0 && h == 0) break;\n\t\t\tmapL = new char[h, w];\n\t\t\tmapr = new char[h, w];\n\t\t\tLsx = Lsy = rsx = rsy = 0;\n\t\t\tLgx = Lgy = rgx = rgy = 0;\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t{\n\t\t\t\tline = Console.ReadLine().Trim().Split(' ');\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t{\n\t\t\t\t\tmapL[i, j] = line[0][j];\n\t\t\t\t\tif (line[0][j] == 'L') { Lsx = i; Lsy = j; mapL[i, j] = '.'; }\n\t\t\t\t\tif (line[0][j] == '%') { Lgx = i; Lgy = j; mapL[i, j] = '.'; }\n\t\t\t\t\tmapr[i, j] = line[1][j];\n\t\t\t\t\tif (line[1][j] == 'R') { rsx = i; rsy = j; mapr[i, j] = '.'; }\n\t\t\t\t\tif (line[1][j] == '%') { rgx = i; rgy = j; mapr[i, j] = '.'; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar ans = goBfs(Lsx, Lsy, rsx, rsy);\n\t\t\tConsole.WriteLine(ans);\n\t\t}\n\t}\n\tstatic string goBfs(int Lsx, int Lsy, int rsx, int rsy)\n\t{\n\t\tvar used = new bool[h, w, h, w];\n\t\tused[Lsx, Lsy, rsx, rsy] = true;\n\t\tvar dx = new int[] { 0, 1, 0, -1 };\n\t\tvar dy = new int[] { 1, 0, -1, 0 };\n\t\tvar q = new Queue<P>();\n\t\tq.Enqueue(new P { Lx = Lsx, Ly = Lsy, rx = rsx, ry = rsy });\n\t\twhile (q.Count() > 0)\n\t\t{\n\t\t\tvar a = q.Dequeue();\n\t\t\tif (a.Lx == Lgx && a.Ly == Lgy && a.rx == rgx && a.ry == rgy) return \"Yes\";\n\t\t\tif ((a.Lx == Lgx && a.Ly == Lgy && !(a.rx == rgx && a.ry == rgy))) continue;\n\t\t\tif (!(a.Lx == Lgx && a.Ly == Lgy) && a.rx == rgx && a.ry == rgy) continue;\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tvar nLx = a.Lx + dx[i];\n\t\t\t\tvar nLy = a.Ly + dy[i];\n\t\t\t\tvar nrx = a.rx + dx[i];\n\t\t\t\tvar nry = a.ry - dy[i];\n\t\t\t\tif (!(nLx >= 0 && nLx < h && nLy >= 0 && nLy < w)) { nLx = a.Lx; nLy = a.Ly; }\n\t\t\t\tif (!(nrx >= 0 && nrx < h && nry >= 0 && nry < w)) { nrx = a.Lx; nry = a.Ly; }\n\t\t\t\tif (mapL[nLx, nLy] == '#') { nLx = a.Lx; nLy = a.Ly; }\n\t\t\t\tif (mapr[nrx, nry] == '#') { nrx = a.rx; nry = a.ry; }\n\t\t\t\tif (!used[nLx, nLy, nrx, nry])\n\t\t\t\t{\n\t\t\t\t\tq.Enqueue(new P { Lx = nLx, Ly = nLy, rx = nrx, ry = nry});\n\t\t\t\t\tused[nLx, nLy, nrx, nry] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn \"No\";\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class P\n{\n    public int xL { get; set; }\n    public int yL { get; set; }\n    public int xr { get; set; }\n    public int yr { get; set; }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var w = int.Parse(line[0]);\n            var h = int.Parse(line[1]);\n            if (w == 0 && h == 0) break;\n            var mapL = new bool[h, w];\n            var mapr = new bool[h, w];\n            var ps = new P();\n            var pg = new P();\n            for (int i = 0; i < h; i++)\n            {\n                var s = Console.ReadLine().Trim();\n                for (int j = 0; j < w; j++)\n                {\n                    if (s[j] == '.') mapL[i, j] = true;\n                    if (s[j] == 'L') { ps.xL = i; ps.yL = j; mapL[i, j] = true; }\n                    if (s[j] == '%') { pg.xL = i; pg.yL = j; mapL[i, j] = true; }\n                }\n                for (int j = 0; j < w; j++)\n                {\n                    if (s[w + j + 1] == '.') mapr[i, j] = true;\n                    if (s[w + j + 1] == 'R') { ps.xr = i; ps.yr = j; mapr[i, j] = true; }\n                    if (s[w + j + 1] == '%') { pg.xr = i; pg.yr = j; mapr[i, j] = true; }\n                }\n            }\n            var ret = getAns(mapL, mapr, ps, pg);\n            Console.WriteLine(ret ? \"Yes\" : \"No\");\n        }\n    }\n    public static bool getAns(bool[,] mapL, bool[,] mapr, P ps, P pg)\n    {\n        var dx = new int[] { 0, 1, 0, -1 };\n        var dy = new int[] { 1, 0, -1, 0 };\n        var h = mapL.GetLength(0);\n        var w = mapL.GetLength(1);\n        var used = new bool[h, w, h, w];\n        used[ps.xL, ps.yL, ps.xr, ps.yr] = true;\n        var q = new Queue<int>();\n        q.Enqueue(ps.xL);\n        q.Enqueue(ps.yL);\n        q.Enqueue(ps.xr);\n        q.Enqueue(ps.yr);\n        while (q.Count() > 0)\n        {\n            var xL = q.Dequeue();\n            var yL = q.Dequeue();\n            var xr = q.Dequeue();\n            var yr = q.Dequeue();\n            if (xL == pg.xL && yL == pg.yL && xr == pg.xr && yr == pg.yr) return true;\n            if ((xL == pg.xL && yL == pg.yL) || (xr == pg.xr && yr == pg.yr)) continue;\n            for (int i = 0; i < 4; i++)\n            {\n                var nxL = xL + dx[i];\n                var nyL = yL + dy[i];\n                if (!(nxL >= 0 && nxL < h && nyL >= 0 && nyL < w && mapL[nxL, nyL])) { nxL = xL; nyL = yL; }\n                var nxr = xr + dx[i];\n                var nyr = yr - dy[i];\n                if (!(nxr >= 0 && nxr < h && nyr >= 0 && nyr < w && mapr[nxr, nyr])) { nxr = xr; nyr = yr; }\n                if (!used[nxL, nyL, nxr, nyr])\n                {\n                    q.Enqueue(nxL);\n                    q.Enqueue(nyL);\n                    q.Enqueue(nxr);\n                    q.Enqueue(nyr);\n                    used[nxL, nyL, nxr, nyr] = true;\n                }\n            }\n        }\n        return false;\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class P\n{\n\tpublic int Lx { get; set; }\n\tpublic int Ly { get; set; }\n\tpublic int rx { get; set; }\n\tpublic int ry { get; set; }\n}\n\npublic class hello\n{\n\tpublic static char[,] mapL, mapr;\n\tpublic static int w, h;\n\tpublic static int Lsx, Lsy, rsx, rsy;\n\tpublic static int Lgx, Lgy, rgx, rgy;\n\n\tpublic static void Main()\n\t{\n\t\twhile (true)\n\t\t{\n\t\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\t\tw = int.Parse(line[0]);\n\t\t\th = int.Parse(line[1]);\n\t\t\tif (w == 0 && h == 0) break;\n\t\t\tmapL = new char[h, w];\n\t\t\tmapr = new char[h, w];\n\t\t\tLsx = Lsy = rsx = rsy = 0;\n\t\t\tLgx = Lgy = rgx = rgy = 0;\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t{\n\t\t\t\tline = Console.ReadLine().Trim().Split(' ');\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t{\n\t\t\t\t\tmapL[i, j] = line[0][j];\n\t\t\t\t\tif (line[0][j] == 'L') { Lsx = i; Lsy = j; mapL[i, j] = '.'; }\n\t\t\t\t\tif (line[0][j] == '%') { Lgx = i; Lgy = j; mapL[i, j] = '.'; }\n\t\t\t\t\tmapr[i, j] = line[1][j];\n\t\t\t\t\tif (line[1][j] == 'R') { rsx = i; rsy = j; mapr[i, j] = '.'; }\n\t\t\t\t\tif (line[1][j] == '%') { rgx = i; rgy = j; mapr[i, j] = '.'; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar ans = goBfs(Lsx, Lsy, rsx, rsy);\n\t\t\tConsole.WriteLine(ans);\n\t\t}\n\t}\n\tstatic string goBfs(int Lsx, int Lsy, int rsx, int rsy)\n\t{\n\t\tvar used = new bool[h, w, h, w];\n\t\tused[Lsx, Lsy, rsx, rsy] = true;\n\t\tvar dx = new int[] { 0, 1, 0, -1 };\n\t\tvar dy = new int[] { 1, 0, -1, 0 };\n\t\tvar q = new Queue<P>();\n\t\tq.Enqueue(new P { Lx = Lsx, Ly = Lsy, rx = rsx, ry = rsy });\n\t\twhile (q.Count() > 0)\n\t\t{\n\t\t\tvar a = q.Dequeue();\n\t\t\t//Console.WriteLine(\"Lx = {0} Ly = {1} rx = {2} ry = {3} step = {4}\",a.Lx,a.Ly,a.rx,a.ry,a.step);\n\t\t\tif (a.Lx == Lgx && a.Ly == Lgy && a.rx == rgx && a.ry == rgy) return \"Yes\";\n\t\t\tif ((a.Lx == Lgx && a.Ly == Lgy && !(a.rx == rgx && a.ry == rgy))) continue;\n\t\t\tif (!(a.Lx == Lgx && a.Ly == Lgy) && a.rx == rgx && a.ry == rgy) continue;\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tvar nLx = a.Lx + dx[i];\n\t\t\t\tvar nLy = a.Ly + dy[i];\n\t\t\t\tvar nrx = a.rx + dx[i];\n\t\t\t\tvar nry = a.ry - dy[i];\n\t\t\t\tif (!(nLx >= 0 && nLx < h && nLy >= 0 && nLy < w)) { nLx = a.Lx; nLy = a.Ly; }\n\t\t\t\tif (!(nrx >= 0 && nrx < h && nry >= 0 && nry < w)) { nrx = a.rx; nry = a.ry; }\n\t\t\t\tif (mapL[nLx, nLy] == '#') { nLx = a.Lx; nLy = a.Ly; }\n\t\t\t\tif (mapr[nrx, nry] == '#') { nrx = a.rx; nry = a.ry; }\n\t\t\t\tif (!used[nLx, nLy, nrx, nry])\n\t\t\t\t{\n\t\t\t\t\tq.Enqueue(new P { Lx = nLx, Ly = nLy, rx = nrx, ry = nry});\n\t\t\t\t\tused[nLx, nLy, nrx, nry] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn \"No\";\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class P\n{\n    public int xL { get; set; }\n    public int yL { get; set; }\n    public int xr { get; set; }\n    public int yr { get; set; }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var w = int.Parse(line[0]);\n            var h = int.Parse(line[1]);\n            if (w == 0 && h == 0) break;\n            var mapL = new char[h, w];\n            var mapr = new char[h, w];\n            var ps = new P();\n            var pg = new P();\n            for (int i = 0; i < h; i++)\n            {\n                var s = Console.ReadLine().Trim();\n                for (int j = 0; j < w; j++)\n                {\n                    mapL[i, j] = s[j];\n                    mapr[i, j] = s[w + j + 1];\n                    if (s[j] == 'L') { ps.xL = i; ps.yL = j; mapL[i, j] = '.'; }\n                    if (s[j] == '%') { pg.xL = i; pg.yL = j; mapL[i, j] = '.'; }\n                    if (s[w + j + 1] == 'R') { ps.xr = i; ps.yr = j; mapr[i, j] = '.'; }\n                    if (s[w + j + 1] == '%') { pg.xr = i; pg.yr = j; mapr[i, j] = '.'; }\n                }\n            }\n            var ret = getAns(mapL, mapr, ps, pg);\n            Console.WriteLine(ret ? \"Yes\" : \"No\");\n        }\n    }\n    public static bool getAns(char[,] mapL, char[,] mapr, P ps, P pg)\n    {\n        var dx = new int[] { 0, 1, 0, -1 };\n        var dyL = new int[] { 1, 0, -1, 0 };\n        var dyr = new int[] { -1, 0, 1, 0 };\n        var h = mapL.GetLength(0);\n        var w = mapL.GetLength(1);\n        var used = new bool[h, w, h, w];\n        used[ps.xL, ps.yL, ps.xr, ps.yr] = true;\n        var q = new Queue<int>();\n        q.Enqueue(ps.xL);\n        q.Enqueue(ps.yL);\n        q.Enqueue(ps.xr);\n        q.Enqueue(ps.yr);\n\n\n        while (q.Count() > 0)\n        {\n            var xL = q.Dequeue();\n            var yL = q.Dequeue();\n            var xr = q.Dequeue();\n            var yr = q.Dequeue();\n            if (xL == pg.xL &&  yL == pg.yL && xr == pg.xr && yr == pg.yr) return true;\n            if ((xL == pg.xL && yL == pg.yL) || (xr == pg.xr && yr == pg.yr)) continue;\n            for (int i = 0; i < 4; i++)\n            {\n                var nxL = xL + dx[i];\n                var nyL = yL + dyL[i];\n                if (!(nxL >= 0 && nxL < h && nyL >= 0 && nyL < w && mapL[nxL, nyL] == '.')) { nxL = xL; nyL = yL; }\n                var nxr = xr + dx[i];\n                var nyr = yr + dyr[i];\n                if (!(nxr >= 0 && nxr < h && nyr >= 0 && nyr < w && mapr[nxr, nyr] == '.')) { nxr = xr; nyr = yr; }\n                if (!used[nxL, nyL, nxr, nyr])\n                {\n                    q.Enqueue(nxL);\n                    q.Enqueue(nyL);\n                    q.Enqueue(nxr);\n                    q.Enqueue(nyr);\n                    used[nxL, nyL, nxr, nyr] = true;\n                }\n            }\n        }\n        return false;\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class P\n{\n\tpublic int Lx { get; set; }\n\tpublic int Ly { get; set; }\n\tpublic int rx { get; set; }\n\tpublic int ry { get; set; }\n}\n\npublic class hello\n{\n\tpublic static char[,] mapL, mapr;\n\tpublic static int w, h;\n\tpublic static int Lsx, Lsy, rsx, rsy;\n\tpublic static int Lgx, Lgy, rgx, rgy;\n\n\tpublic static void Main()\n\t{\n\t\twhile (true)\n\t\t{\n\t\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\t\tw = int.Parse(line[0]);\n\t\t\th = int.Parse(line[1]);\n\t\t\tif (w == 0 && h == 0) break;\n\t\t\tmapL = new char[h, w];\n\t\t\tmapr = new char[h, w];\n\t\t\tLsx = Lsy = rsx = rsy = 0;\n\t\t\tLgx = Lgy = rgx = rgy = 0;\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t{\n\t\t\t\tline = Console.ReadLine().Trim().Split(' ');\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t{\n\t\t\t\t\tmapL[i, j] = line[0][j];\n\t\t\t\t\tif (line[0][j] == 'L') { Lsx = i; Lsy = j; mapL[i, j] = '.'; }\n\t\t\t\t\tif (line[0][j] == '%') { Lgx = i; Lgy = j; mapL[i, j] = '.'; }\n\t\t\t\t\tmapr[i, j] = line[1][j];\n\t\t\t\t\tif (line[1][j] == 'R') { rsx = i; rsy = j; mapr[i, j] = '.'; }\n\t\t\t\t\tif (line[1][j] == '%') { rgx = i; rgy = j; mapr[i, j] = '.'; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar ans = goBfs(Lsx, Lsy, rsx, rsy);\n\t\t\tConsole.WriteLine(ans);\n\t\t}\n\t}\n\tstatic string goBfs(int Lsx, int Lsy, int rsx, int rsy)\n\t{\n\t\tvar used = new bool[h, w, h, w];\n\t\tused[Lsx, Lsy, rsx, rsy] = true;\n\t\tvar dx = new int[] { 0, 1, 0, -1 };\n\t\tvar dy = new int[] { 1, 0, -1, 0 };\n\t\tvar q = new Queue<P>();\n\t\tq.Enqueue(new P { Lx = Lsx, Ly = Lsy, rx = rsx, ry = rsy });\n\t\twhile (q.Count() > 0)\n\t\t{\n\t\t\tvar a = q.Dequeue();\n\t\t\tif (a.Lx == Lgx && a.Ly == Lgy && a.rx == rgx && a.ry == rgy) return \"Yes\";\n\t\t\tif ((a.Lx == Lgx && a.Ly == Lgy && !(a.rx == rgx && a.ry == rgy))) continue;\n\t\t\tif (!(a.Lx == Lgx && a.Ly == Lgy) && a.rx == rgx && a.ry == rgy) continue;\n\t\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tvar nLx = a.Lx + dx[i];\n\t\t\t\tvar nLy = a.Ly + dy[i];\n\t\t\t\tvar nrx = a.rx + dx[i];\n\t\t\t\tvar nry = a.ry - dy[i];\n\t\t\t\tif (nLx >= 0 && nLx < h && nLy >= 0 && nLy < w && nrx >= 0 && nrx < h && nry >= 0 && nry < w)\n\t\t\t\t{\n\t\t\t\t\tif (mapL[nLx, nLy] == '.' && mapr[nrx, nry] == '.' && !used[nLx, nLy, nrx, nry])\n\t\t\t\t\t{\n\t\t\t\t\t\tq.Enqueue(new P { Lx = nLx, Ly = nLy, rx = nrx, ry = nry });\n\t\t\t\t\t\tused[nLx, nLy, nrx, nry] = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (mapL[nLx, nLy] == '#' && mapr[nrx, nry] == '.' && !used[a.Lx, a.Ly, nrx, nry])\n\t\t\t\t\t{\n\t\t\t\t\t\tq.Enqueue(new P { Lx = a.Lx, Ly = a.Ly, rx = nrx, ry = nry});\n\t\t\t\t\t\tused[a.Lx, a.Ly, nrx, nry] = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (mapL[nLx, nLy] == '.' && mapr[nrx, nry] == '#' && !used[nLx, nLy, a.rx, a.ry])\n\t\t\t\t\t{\n\t\t\t\t\t\tq.Enqueue(new P { Lx = nLx, Ly = nLy, rx = a.rx, ry = a.ry });\n\t\t\t\t\t\tused[nLx, nLy, a.rx, a.ry] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn \"No\";\n\t}\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "loop do\n\tw, h = gets.split.map &:to_i\n\tbreak if w == 0\n\tinput = (1..h).map {gets.chomp}\n\n\tal = (0..h+1).map { [] }\n\tar = (0..h+1).map { [] } \n\tly = lx = ry = rx = nil\n\n\t(0..h+1).each do |y|\n\t\t(0..w+1).each do |x|\n\t\t\tif [0, h+1].include?(y) || [0, w+1].include?(x)\n\t\t\t\tal[y][x] = ar[y][x] = ?#\n\t\t\telse\n\t\t\t\tal[y][x] = input[y-1][x-1]\n\t\t\t\tar[y][x] = input[y-1][x-w-1]\n\t\t\t\tly, lx = y, x if al[y][x] == ?L\n\t\t\t\try, rx = y, x if ar[y][x] == ?R\n\t\t\tend\n\t\tend\n\tend\n\n\tstart = [ly, lx, ry, rx]\n\tstack = [start]\n\treached = (0..h).map{(0..w).map{(0..h).map{(0..w).map{nil}}}}\n\n\tok = false\n\tdirs = [[-1,0],[1,0],[0,-1],[0,1]]\n\tuntil stack.empty?\n\t\tly0, lx0, ry0, rx0 = stack.pop\n\t\tdirs.each do |dy, dx|\n\t\t\tly1, lx1, ry1, rx1 = ly0+dy, lx0+dx, ry0+dy, rx0-dx\n\t\t\tly1, lx1 = ly0, lx0 if al[ly1][lx1] == ?#\n\t\t\try1, rx1 = ry0, rx0 if ar[ry1][rx1] == ?#\n\n\t\t\tgl = (al[ly1][lx1] == ?%)\n\t\t\tgr = (ar[ry1][rx1] == ?%)\n\t\t\tif gl && gr\n\t\t\t\tok = true\n\t\t\t\tbreak\n\t\t\tend\n\n\t\t\tnext if gl || gr\n\n\t\t\ta = reached[ly1][lx1][ry1]\n\t\t\tnext if a[rx1]\n\t\t\ta[rx1] = 1\n\t\t\t\n\t\t\tstack << [ly1, lx1, ry1, rx1]\n\t\tend\n\t\tbreak if ok\n\tend\n\tputs ok ? 'Yes' : 'No'\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n  w, h = gets.split.map(&:to_i)\n  break if w == 0\n  fld_l = '#' * (w + 2)\n  fld_r = '#' * (w + 2)\n  pl = pr = 0\n  h.times do |i|\n    l, r = gets.split(' ')\n    pl = (w + 2) * (i + 1) + l.index('L') + 1 if l.include?('L')\n    pr = (w + 2) * (i + 1) + r.index('R') + 1 if r.include?('R')\n    fld_l += '#' + l + '#'; fld_r += '#' + r + '#'\n  end\n  fld_l += '#' * (w + 2); fld_r += '#' * (w + 2)\n  arr = []\n  arr << [pl, pr]\n  visit = []\n  visit << [pl, pr]\n  res = 0\n  until arr.empty?\n    l, r = arr.shift\n    [[-1, 0], [1, 0], [0, -1], [0, 1]].each do |y, x|\n      nxt_l = l + y * (w + 2) + x\n      nxt_r = r + y * (w + 2) - x\n      if !visit.include?([nxt_l, nxt_r])\n        if fld_l[nxt_l] == '%' && fld_r[nxt_r] == '%'\n          res = 1\n          break\n        end\n        if (fld_l[nxt_l] == '#' && fld_r[nxt_r] == '#') || (fld_l[nxt_l] == '%' || fld_r[nxt_r] == '%')\n          next\n        end\n        nxt_l = l if fld_l[nxt_l] == '#'\n        nxt_r = r if fld_r[nxt_r] == '#'\n        arr << [nxt_l, nxt_r]\n        visit << [nxt_l, nxt_r]\n      end\n    end\n  end\n  puts res == 0 ?  'No' : 'Yes'\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n\tw, h = gets.split.map &:to_i\n\tbreak if w == 0\n\tinput = (1..h).map {gets.chomp}\n\n\tal = (0..h+1).map { [] }\n\tar = (0..h+1).map { [] }\n\n\tly = lx = ry = rx = nil\n\n\t(0..h+1).each do |y|\n\t\t(0..w+1).each do |x|\n\t\t\tif [0, h+1].include?(y) || [0, w+1].include?(x)\n\t\t\t\tal[y][x] = ar[y][x] = ?#\n\t\t\telse\n\t\t\t\tal[y][x] = input[y-1][x-1]\n\t\t\t\tar[y][x] = input[y-1][x-w-1]\n\t\t\t\tly, lx = y, x if al[y][x] == ?L\n\t\t\t\try, rx = y, x if ar[y][x] == ?R\n\t\t\tend\n\t\tend\n\tend\n\n\tstart = [ly, lx, ry, rx]\n\tstack = [start]\n\treached = {start => 0}\n\n\tok = false\n\tuntil stack.empty?\n\t\tly0, lx0, ry0, rx0 = stack.pop\n\t\t[[-1,0],[1,0],[0,-1],[0,1]].each do |dy, dx|\n\t\t\tly1, lx1, ry1, rx1 = ly0+dy, lx0+dx, ry0+dy, rx0-dx\n\t\t\tly1, lx1 = ly0, lx0 if al[ly1][lx1] == ?#\n\t\t\try1, rx1 = ry0, rx0 if ar[ry1][rx1] == ?#\n\n\t\t\tif al[ly1][lx1] == ?% && ar[ry1][rx1] == ?%\n\t\t\t\tok = true\n\t\t\t\tbreak\n\t\t\tend\n\n\t\t\tnext if al[ly1][lx1] == ?% || ar[ry1][rx1] == ?%\n\n\t\t\tv = [ly1, lx1, ry1, rx1]\n\t\t\tnext if reached[v]\n\t\t\treached[v] = 1\n\t\t\t\n\t\t\tstack << v\n\t\tend\n\t\tbreak if ok\n\tend\n\tputs ok ? 'Yes' : 'No'\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n  w, h = gets.split.map(&:to_i)\n  break if w == 0\n  fld_l = '#' * (w + 2)\n  fld_r = '#' * (w + 2)\n  pl = pr = 0\n  h.times do |i|\n    l, r = gets.split(' ')\n    pl = (w + 2) * (i + 1) + l.index('L') + 1 if l.include?('L')\n    pr = (w + 2) * (i + 1) + r.index('R') + 1 if r.include?('R')\n    fld_l += '#' + l + '#'; fld_r += '#' + r + '#'\n  end\n  fld_l += '#' * (w + 2); fld_r += '#' * (w + 2)\n  arr = []\n  arr << [pl, pr]\n  visit = ((h+2)*(w+2)).times.map{ [false] * ((h+2)*(w+2)) }\n  res = 0\n  until arr.empty?\n    l, r = arr.shift\n    [[-1, 0], [1, 0], [0, -1], [0, 1]].each do |y, x|\n      nxt_l = l + y * (w + 2) + x\n      nxt_r = r + y * (w + 2) - x\n      next if fld_l[nxt_l] == '#' && fld_r[nxt_r] == '#'\n      nxt_l = l if fld_l[nxt_l] == '#'\n      nxt_r = r if fld_r[nxt_r] == '#'\n      unless visit[nxt_l][nxt_r]\n        if fld_l[nxt_l] == '%' && fld_r[nxt_r] == '%'\n          res = 1\n          break\n        end\n        if fld_l[nxt_l] == '%' || fld_r[nxt_r] == '%'\n          next\n        end\n        arr << [nxt_l, nxt_r]\n        visit[nxt_l][nxt_r] = true\n      end\n    end\n    break if res == 1\n  end\n  puts res == 0 ?  'No' : 'Yes'\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nstruct S {\n    int ly, lx;\n    int ry, rx;\n}\n \nbool used[50][50][50][50];\nvoid main() {\n    int W, H;\n    while (readf(\"%d %d\\n\", &W, &H), W || H) {\n        auto L = new char[][H],\n             R = new char[][H];\n        foreach (i; 0 .. H) {\n            string[] I = readln.chomp.split(\" \");\n            L[i] = cast(char[])I[0];\n            R[i] = cast(char[])I[1];\n        }\n        int lx, ly, rx, ry;\n        foreach (i; 0 .. H) {\n            foreach (j; 0 .. W) {\n                if (L[i][j] == 'L') {\n                    ly = i;\n                    lx = j;\n                    //L[i][j] = '.';\n                }\n                if (R[i][j] == 'R') {\n                    ry = i;\n                    rx = j;\n                    //R[i][j] = '.';\n                }\n            }\n        }\n\n        bool bfs() {\n            memset(cast(void*)used, 0, used.sizeof);\n            DList!S Q; Q.insert(S(ly, lx, ry, rx)); used[ly][lx][ry][rx] = true;\n            while (!Q.empty) {\n                static const dy = [0, 1, 0, -1],\n                             dx = [1, 0, -1, 0];\n                S c = Q.front; Q.removeFront;\n                foreach (i; 0 .. 4) {\n                    S n;\n                    n.ly = c.ly + dy[i];\n                    n.lx = c.lx + dx[i];\n                    n.ry = c.ry + dy[i];\n                    n.rx = c.rx - dx[i];\n                    if (n.ly < 0 || n.ly >= H) n.ly = c.ly;\n                    if (n.lx < 0 || n.lx >= W) n.lx = c.lx;\n                    if (L[n.ly][n.lx] == '#') n.ly = c.ly;\n                    if (L[n.ly][n.lx] == '#') n.lx = c.lx;\n                    if (n.ry < 0 || n.ry >= H) n.ry = c.ry;\n                    if (n.rx < 0 || n.rx >= W) n.rx = c.rx;\n                    if (R[n.ry][n.rx] == '#') n.ry = c.ry;\n                    if (R[n.ry][n.rx] == '#') n.rx = c.rx;\n                    if (used[n.ly][n.lx][n.ry][n.rx]) continue;\n                    used[n.ly][n.lx][n.ry][n.rx] = true;\n                    //[n.ly, n.lx, n.ry, n.rx].writeln;\n                    if (L[n.ly][n.lx] == '%' || R[n.ry][n.rx] == '%') {\n                        if (L[n.ly][n.lx] == '%' && R[n.ry][n.rx] == '%') {\n                            return true;\n                        } else {\n                            continue;\n                        }\n                    }\n                    Q.insert(n);\n                }\n            }\n            return false;\n        }\n        \n        writeln(bfs ? \"Yes\" : \"No\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nstruct S {\n    int ly, lx;\n    int ry, rx;\n}\n \nbool used[50][50][50][50];\nvoid main() {\n    int W, H;\n    while (readf(\"%d %d\\n\", &W, &H), W || H) {\n        auto L = new char[][H],\n             R = new char[][H];\n        foreach (i; 0 .. H) {\n            string[] I = readln.chomp.split(\" \");\n            L[i] = cast(char[])I[0];\n            R[i] = cast(char[])I[1];\n        }\n        int lx, ly, rx, ry;\n        foreach (i; 0 .. H) {\n            foreach (j; 0 .. W) {\n                if (L[i][j] == 'L') {\n                    ly = i;\n                    lx = j;\n                    L[i][j] = '.';\n                }\n                if (R[i][j] == 'R') {\n                    ry = i;\n                    rx = j;\n                    R[i][j] = '.';\n                }\n            }\n        }\n\n        bool bfs() {\n            memset(cast(void*)used, 0, used.sizeof);\n            DList!S Q; Q.insert(S(ly, lx, ry, rx)); used[ly][lx][ry][rx] = true;\n            while (!Q.empty) {\n                static const dy = [0, 1, 0, -1],\n                             dx = [1, 0, -1, 0];\n                S c = Q.front; Q.removeFront;\n                foreach (i; 0 .. 4) {\n                    S n;\n                    n.ly = c.ly + dy[i];\n                    n.lx = c.lx + dx[i];\n                    n.ry = c.ry + dy[i];\n                    n.rx = c.rx - dx[i];\n                    //[n.ly, n.lx, n.ry, n.rx].writeln;\n                    if (n.ly < 0 || n.ly >= H) n.ly = c.ly;\n                    if (n.lx < 0 || n.lx >= W) n.lx = c.lx;\n                    if (L[n.ly][n.lx] == '#') n.ly = c.ly;\n                    if (L[n.ly][n.lx] == '#') n.lx = c.lx;\n                    if (n.ry < 0 || n.ry >= H) n.ry = c.ry;\n                    if (n.rx < 0 || n.rx >= W) n.rx = c.rx;\n                    if (R[n.ry][n.rx] == '#') n.ry = c.ry;\n                    if (R[n.ry][n.rx] == '#') n.rx = c.rx;\n                    if (used[n.ly][n.lx][n.ry][n.rx]) continue;\n                    used[n.ly][n.lx][n.ry][n.rx] = true;\n                    if (L[n.ly][n.lx] == '%') {\n                        if (R[n.ry][n.rx] == '%') {\n                            return true;\n                        } else {\n                            continue;\n                        }\n                    }\n                    Q.insert(n);\n                }\n            }\n            return false;\n        }\n\n        writeln(bfs ? \"Yes\" : \"No\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nstruct S {\n    int ly, lx;\n    int ry, rx;\n}\n \nbool used[50][50][50][50];\nvoid main() {\n    int W, H;\n    while (readf(\"%d %d\\n\", &W, &H), W || H) {\n        auto L = new char[][H],\n             R = new char[][H];\n        foreach (i; 0 .. H) {\n            string[] I = readln.chomp.split(\" \");\n            L[i] = cast(char[])I[0];\n            R[i] = cast(char[])I[1];\n        }\n        int lx, ly, rx, ry;\n        foreach (i; 0 .. H) {\n            foreach (j; 0 .. W) {\n                if (L[i][j] == 'L') {\n                    ly = i;\n                    lx = j;\n                    L[i][j] = '.';\n                }\n                if (R[i][j] == 'R') {\n                    ry = i;\n                    rx = j;\n                    R[i][j] = '.';\n                }\n            }\n        }\n\n        bool bfs() {\n            memset(cast(void*)used, 0, used.sizeof);\n            DList!S Q; Q.insert(S(ly, lx, ry, rx)); used[ly][lx][ry][rx] = true;\n            while (!Q.empty) {\n                static const dy = [0, 1, 0, -1],\n                             dx = [1, 0, -1, 0];\n                S c = Q.front; Q.removeFront;\n                foreach (i; 0 .. 4) {\n                    S n;\n                    n.ly = c.ly + dy[i];\n                    n.lx = c.lx + dx[i];\n                    n.ry = c.ry + dy[i];\n                    n.rx = c.rx - dx[i];\n                    //[n.ly, n.lx, n.ry, n.rx].writeln;\n                    if (n.ly < 0 || n.ly >= H) n.ly = c.ly;\n                    if (n.lx < 0 || n.lx >= W) n.lx = c.lx;\n                    if (L[n.ly][n.lx] == '#') n.ly = c.ly;\n                    if (L[n.ly][n.lx] == '#') n.lx = c.lx;\n                    if (n.ry < 0 || n.ry >= H) n.ry = c.ry;\n                    if (n.rx < 0 || n.rx >= W) n.rx = c.rx;\n                    if (R[n.ry][n.rx] == '#') n.ry = c.ry;\n                    if (R[n.ry][n.rx] == '#') n.rx = c.rx;\n                    if (used[n.ly][n.lx][n.ry][n.rx]) continue;\n                    used[n.ly][n.lx][n.ry][n.rx] = true;\n                    if (L[n.ly][n.lx] == '%') {\n                        if (R[n.ry][n.rx] == '%') {\n                            return true;\n                        } else {\n                            continue;\n                        }\n                    }\n                    Q.insert(n);\n                }\n            }\n            return false;\n        }\n\n        writeln(bfs ? \"YES\" : \"NO\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nstruct S {\n    int ly, lx;\n    int ry, rx;\n}\n \nvoid main() {\n    int W, H;\n    while (readf(\"%d %d\\n\", &W, &H), W || H) {\n        auto L = new char[][H],\n             R = new char[][H];\n        foreach (i; 0 .. H) {\n            string[] I = readln.chomp.split(\" \");\n            L[i] = cast(char[])I[0];\n            R[i] = cast(char[])I[1];\n        }\n        int lx, ly, rx, ry;\n        foreach (i; 0 .. H) {\n            foreach (j; 0 .. W) {\n                if (L[i][j] == 'L') {\n                    ly = i;\n                    lx = j;\n                    L[i][j] = '.';\n                }\n                if (R[i][j] == 'R') {\n                    ry = i;\n                    rx = j;\n                    R[i][j] = '.';\n                }\n            }\n        }\n\n        bool bfs() {\n            auto used = new bool[][][][](H, W, H, W);\n            DList!S Q; Q.insert(S(ly, lx, ry, rx)); used[ly][lx][ry][rx] = true;\n            while (!Q.empty) {\n                static const dy = [0, 1, 0, -1],\n                             dx = [1, 0, -1, 0];\n                S c = Q.front; Q.removeFront;\n                foreach (i; 0 .. 4) {\n                    S n;\n                    n.ly = c.ly + dy[i];\n                    n.lx = c.lx + dx[i];\n                    n.ry = c.ry + dy[i];\n                    n.rx = c.rx - dx[i];\n                    //[n.ly, n.lx, n.ry, n.rx].writeln;\n                    if (n.ly < 0 || n.ly >= H) n.ly = c.ly;\n                    if (n.lx < 0 || n.lx >= W) n.lx = c.lx;\n                    if (L[n.ly][n.lx] == '#') n.ly = c.ly;\n                    if (L[n.ly][n.lx] == '#') n.lx = c.lx;\n                    if (n.ry < 0 || n.ry >= H) n.ry = c.ry;\n                    if (n.rx < 0 || n.rx >= W) n.rx = c.rx;\n                    if (R[n.ry][n.rx] == '#') n.ry = c.ry;\n                    if (R[n.ry][n.rx] == '#') n.rx = c.rx;\n                    if (used[n.ly][n.lx][n.ry][n.rx]) continue;\n                    used[n.ly][n.lx][n.ry][n.rx] = true;\n                    if (L[n.ly][n.lx] == '%') {\n                        if (R[n.ry][n.rx] == '%') {\n                            return true;\n                        } else {\n                            continue;\n                        }\n                    }\n                    Q.insert(n);\n                }\n            }\n            return false;\n        }\n\n        writeln(bfs ? \"YES\" : \"NO\");\n    }\n}"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nwhile True:\n    w,h=map(int,input().split(\" \"))\n    def isrange(p):\n        return 0<=p[0] and p[0]<h and 0<=p[1] and p[1]<w\n    if w==0: break\n    rl=[[str()] for i in range(h)]\n    rr=[[str()] for i in range(h)]\n    for i in range(h):\n        rl[i],rr[i]=input().split(\" \")\n    q = deque()\n    dp=[[[[False for i in range(w)] for ii in range(h)] for iii in range(w)] for iiii in range(h)]\n    for i in range(h):\n        for j in range(w):\n            if rl[i][j]==\"L\": ls=(i,j)\n            if rr[i][j]==\"R\": rs=(i,j)\n            if rl[i][j]==\"%\": gl=(i,j)\n            if rr[i][j]==\"%\": gr=(i,j)\n    q.append((ls,rs))\n    \n    dp[ls[0]][ls[1]][rs[0]][rs[1]]=True\n    dw=(-1,0,1,0)\n    dh=(0,1,0,-1)\n    cnt=0\n    while q:\n        if cnt>int(1e7): break\n        cnt+=1\n        val=q.pop()\n        lp=val[0]\n        rp=val[1]\n        for i in range(4):\n            lnp=(lp[0]+dh[i],lp[1]+dw[i])\n            rnp=(rp[0]+dh[i],rp[1]-dw[i])\n            if (not isrange(lnp)) or rl[lnp[0]][lnp[1]]==\"#\" : lnp=lp\n            if (not isrange(rnp)) or rr[rnp[0]][rnp[1]]==\"#\" : rnp=rp\n            if dp[lnp[0]][lnp[1]][rnp[0]][rnp[1]]: continue\n            dp[lnp[0]][lnp[1]][rnp[0]][rnp[1]]=True\n            q.append((lnp,rnp))\n    if dp[gl[0]][gl[1]][gr[0]][gr[1]] : print(\"Yes\")\n    else : print(\"No\")\n    dp.clear()\n    q.clear()\n    rl.clear()\n    rr.clear()"
  },
  {
    "language": "Python",
    "code": "from collections import deque\ndd = [(-1, 0), (0, -1), (1, 0), (0, 1)]\ndeq = deque()\npush = deq.append\npop = deq.popleft\nclear = deq.clear\nwhile 1:\n    w, h = map(int, raw_input().split())\n    if w==0:\n        break\n    M = [raw_input() for i in xrange(h)]\n    rx = ry = lx = ly = None\n    for i in xrange(h):\n        e = M[i]\n        for j in xrange(w):\n            if e[j+w+1] == 'R':\n                rx = j; ry = i\n            if e[j] == 'L':\n                lx = j; ly = i\n    dist = {(rx, ry, lx, ly)}\n    push((rx, ry, lx, ly))\n    ok = 0\n    while deq and not ok:\n        rx, ry, lx, ly = pop()\n        for dx, dy in dd:\n            n_rx = rx + dx\n            if not 0 <= n_rx < w: n_rx = rx\n            n_ry = ry + dy\n            if not 0 <= n_ry < h: n_ry = ry\n            rm = M[n_ry][n_rx+w+1]\n            if rm == '#':\n                n_rx = rx; n_ry = ry\n                rm = '.'\n            n_lx = lx - dx\n            if not 0 <= n_lx < w: n_lx = lx\n            n_ly = ly + dy\n            if not 0 <= n_ly < h: n_ly = ly\n            lm = M[n_ly][n_lx]\n            if lm == '#':\n                n_lx = lx; n_ly = ly\n                lm = '.'\n            if rm == '%' or lm == '%':\n                if rm == '%' and lm == '%':\n                    ok = 1\n                continue\n            n_key = (n_rx, n_ry, n_lx, n_ly)\n            if n_key not in dist:\n                dist.add(n_key)\n                push(n_key)\n    clear()\n    print \"Yes\"*ok or \"No\""
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndirect_l = ((-1, 0), (1, 0), (0, 1), (0, -1))\ndirect_r = ((1, 0), (-1, 0), (0, 1), (0, -1))\ndirects = tuple(zip(direct_l, direct_r))\n\ndef search(start_l, start_r, mp_l, mp_r):\n  que = deque()\n  que.append((start_l, start_r))\n  dic = {}\n  dic[(start_l, start_r)] = True\n  while que:\n    pl, pr = que.popleft()\n    lx, ly = pl\n    rx, ry = pr\n    for ld, rd in directs:\n      ldx, ldy = ld\n      rdx, rdy = rd\n      lnx, lny = (lx + ldx, ly + ldy) if mp_l[ly + ldy][lx + ldx] != \"#\" else (lx, ly)\n      rnx, rny = (rx + rdx, ry + rdy) if mp_r[ry + rdy][rx + rdx] != \"#\" else (rx, ry)\n      if not ((lnx, lny), (rnx, rny)) in dic:\n        dic[((lnx, lny), (rnx, rny))] = True\n        if mp_l[lny][lnx] == \"%\" and mp_r[rny][rnx] == \"%\":\n          print(\"Yes\")\n          return\n        if mp_l[lny][lnx] != \"%\" and mp_r[rny][rnx] != \"%\":\n          que.append(((lnx, lny), (rnx, rny)))\n  else:\n    print(\"No\")\n    return\n\n\nwhile True:\n  w, h = map(int, input().split())\n  if w == 0:\n    break\n\n  mp_l = [\"#\" * (w + 2)]\n  mp_r = [\"#\" * (w + 2)]\n  for _ in range(h):\n    l, r = input().split()\n    l = \"#\" + l + \"#\"\n    r = \"#\" + r + \"#\"\n    mp_l.append(l)\n    mp_r.append(r)\n  mp_l.append(\"#\" * (w + 2))\n  mp_r.append(\"#\" * (w + 2))\n  \n  for y in range(1, h + 1):\n    for x in range(1, w + 1):\n      if mp_l[y][x] == \"L\":\n        start_l = (x, y)\n      if mp_r[y][x] == \"R\":\n        start_r = (x, y)\n\n  search(start_l, start_r, mp_l, mp_r)\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque, defaultdict\n\ndef main():\n  directs = ((-1, 0, 1, 0), (1, 0, -1, 0), (0, 1, 0, 1), (0, -1, 0, -1))\n  while True:\n    w, h = map(int, input().split())\n    if w == 0:\n      break\n  \n    mp_l = [\"#\" * (w + 2)]\n    mp_r = [\"#\" * (w + 2)]\n    for _ in range(h):\n      l, r = input().split()\n      l = \"#\" + l + \"#\"\n      r = \"#\" + r + \"#\"\n      mp_l.append(l)\n      mp_r.append(r)\n    mp_l.append(\"#\" * (w + 2))\n    mp_r.append(\"#\" * (w + 2))\n    \n    for y in range(1, h + 1):\n      for x in range(1, w + 1):\n        if mp_l[y][x] == \"L\":\n          start_l = (x, y)\n        if mp_r[y][x] == \"R\":\n          start_r = (x, y)\n    \n    dic = [[[[None] * (h + 2) for _ in range(w + 2)] for _ in range(h + 2)] for _ in range(w + 2)]\n    def search():\n      que = deque()\n      app = que.append\n      pop = que.popleft\n      app((start_l[0], start_l[1], start_r[0], start_r[1]))\n      dic[start_l[0]][start_l[1]][start_r[0]][start_r[1]] = True\n      while que:\n        lx, ly, rx, ry = pop()\n        for ldx, ldy, rdx, rdy in directs:\n          ltx, lty, rtx, rty = lx + ldx, ly + ldy, rx + rdx, ry + rdy\n          if mp_l[lty][ltx] != \"#\":\n            lnx, lny = ltx, lty\n          else:\n            lnx, lny = lx, ly\n          if mp_r[rty][rtx] != \"#\":\n            rnx, rny = rtx, rty\n          else:\n            rnx, rny = rx, ry\n          tmp = dic[lnx][lny][rnx]\n          if not tmp[rny]:\n            tmp[rny] = True\n            lsym, rsym = mp_l[lny][lnx], mp_r[rny][rnx]\n            if lsym == \"%\":\n              if rsym == \"%\":\n                print(\"Yes\")\n                return\n            elif rsym != \"%\":\n              app(((lnx, lny, rnx, rny)))\n      print(\"No\")\n      return\n    search()\n \nmain()\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nwhile True:\n    w,h=map(int,input().split(\" \"))\n    def isrange(p):\n        return 0<=p[0] and p[0]<h and 0<=p[1] and p[1]<w\n    if w==0: break\n    rl=[[str()] for i in range(h)]\n    rr=[[str()] for i in range(h)]\n    for i in range(h):\n        rl[i],rr[i]=input().split(\" \")\n    q = deque()\n    dp=[[[[False for i in range(w)] for ii in range(h)] for iii in range(w)] for iiii in range(h)]\n    for i in range(h):\n        for j in range(w):\n            if rl[i][j]==\"L\": ls=(i,j)\n            if rr[i][j]==\"R\": rs=(i,j)\n            if rl[i][j]==\"%\": gl=(i,j)\n            if rr[i][j]==\"%\": gr=(i,j)\n    q.append((ls,rs))\n    \n    dp[ls[0]][ls[1]][rs[0]][rs[1]]=True\n    dw=(-1,0,1,0)\n    dh=(0,1,0,-1)\n    cnt=0\n    while q:\n        if cnt>int(1e7): break\n        cnt+=1\n        val=q.pop()\n        lp=val[0]\n        rp=val[1]\n        for i in range(4):\n            lnp=(lp[0]+dh[i],lp[1]+dw[i])\n            rnp=(rp[0]+dh[i],rp[1]-dw[i])\n            if (not isrange(lnp)) or rl[lnp[0]][lnp[1]]==\"#\" : lnp=lp\n            if (not isrange(rnp)) or rr[rnp[0]][rnp[1]]==\"#\" : rnp=rp\n            if dp[lnp[0]][lnp[1]][rnp[0]][rnp[1]]: continue\n            dp[lnp[0]][lnp[1]][rnp[0]][rnp[1]]=True\n            q.append((lnp,rnp))\n    if dp[gl[0]][gl[1]][gr[0]][gr[1]] : print(\"Yes\")\n    else : print(\"No\")\n    dp.clear()\n    q.clear()\n    rl.clear()\n    rr.clear()"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nwhile True:\n    w,h=map(int,input().split(\" \"))\n    def isrange(p):\n        return 0<=p[0] and p[0]<h and 0<=p[1] and p[1]<w\n    if w==0: break\n    rl=[[str()] for i in range(h)]\n    rr=[[str()] for i in range(h)]\n    for i in range(h):\n        rl[i],rr[i]=input().split(\" \")\n    q = deque()\n    s=set()\n    for i in range(h):\n        for j in range(w):\n            if rl[i][j]==\"L\": ls=(i,j)\n            if rr[i][j]==\"R\": rs=(i,j)\n            if rl[i][j]==\"%\": gl=(i,j)\n            if rr[i][j]==\"%\": gr=(i,j)\n    q.append((ls,rs))\n    dw=(-1,0,1,0)\n    dh=(0,1,0,-1)\n    while q:\n        val=q.pop()\n        if val in s: continue\n        s.add(val)\n        lp=val[0]\n        rp=val[1]\n        for i in range(4):\n            lnp=(lp[0]+dh[i],lp[1]+dw[i])\n            rnp=(rp[0]+dh[i],rp[1]-dw[i])\n            if (not isrange(lnp)) or rl[lnp[0]][lnp[1]]==\"#\" : lnp=lp\n            if (not isrange(rnp)) or rr[rnp[0]][rnp[1]]==\"#\" : rnp=rp\n            q.append((lnp,rnp))\n    if (gl,gr) in s : print(\"Yes\")\n    else : print(\"No\")"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 998244353\ndd = [(0,-1),(1,0),(0,1),(-1,0)]\nddn = [(0,-1),(1,-1),(1,0),(1,1),(0,1),(-1,-1),(-1,0),(-1,1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    while True:\n        w,h = LI()\n        if w == 0:\n            break\n        print(w,h)\n        la = [\"#\" * (w+2)]\n        ra = [\"#\" * (w+2)]\n        for _ in range(h):\n            l,r = LS()\n            la.append(\"#{}#\".format(l))\n            ra.append(\"#{}#\".format(r))\n        la.append(\"#\" * (w+2))\n        ra.append(\"#\" * (w+2))\n        ls = None\n        rs = None\n        lp = None\n        rp = None\n        for i in range(1,h+2):\n            for j in range(1,w+2):\n                if la[i][j] == 'L':\n                    ls = (i,j)\n                elif la[i][j] == '%':\n                    lp = (i,j)\n                if ra[i][j] == 'R':\n                    rs = (i,j)\n                elif ra[i][j] == '%':\n                    rp = (i,j)\n        lla = []\n        rra = []\n        for i in range(h+2):\n            tl = []\n            tr = []\n            for j in range(w+2):\n                if la[i][j] == '#':\n                    tl.append(None)\n                else:\n                    tl.append(1)\n                if ra[i][j] == '#':\n                    tr.append(None)\n                else:\n                    tr.append(1)\n            lla.append(tl)\n            rra.append(tr)\n\n\n        def search(s):\n            q = []\n            q.append(s)\n            v = set()\n            v.add(s)\n            qi = 0\n            while len(q) > qi:\n                u = q[qi]\n                qi += 1\n\n                for di, dj in dd:\n                    li = u[0][0]\n                    lj = u[0][1]\n                    if not lla[li+di][lj+dj] is None:\n                        li += di\n                        lj += dj\n                    ri = u[1][0]\n                    rj = u[1][1]\n                    if not rra[ri+di][rj-dj] is None:\n                        ri += di\n                        rj -= dj\n\n                    uv = ((li,lj), (ri,rj))\n                    if uv in v:\n                        continue\n                    v.add(uv)\n                    if (li,lj) == lp and (ri,rj) == rp:\n                        # print(len(q))\n                        return True\n                    if (li,lj) == lp:\n                        continue\n                    if (ri,rj) == rp:\n                        continue\n\n                    q.append(uv)\n\n            # print(len(q))\n            return False\n\n        if search((ls,rs)):\n            rr.append('Yes')\n        else:\n            rr.append('No')\n        # print(rr[-1])\n\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\ndd = [(-1, 0), (0, -1), (1, 0), (0, 1)]\nwhile 1:\n    w, h = map(int, raw_input().split())\n    if w==0:\n        break\n    M = [raw_input() for i in xrange(h)]\n    ML = [e[:w] for e in M]\n    MR = [e[w+1:] for e in M]\n    rx = ry = lx = ly = None\n    for i in xrange(h):\n        for j in xrange(w):\n            if MR[i][j] == 'R':\n                rx = j; ry = i\n            if ML[i][j] == 'L':\n                lx = j; ly = i\n    dist = {(rx, ry, lx, ly)}\n    deq = deque()\n    deq.append((rx, ry, lx, ly))\n    ok = 0\n    while deq and not ok:\n        rx, ry, lx, ly = deq.popleft()\n        for dx, dy in dd:\n            n_rx = rx + dx\n            if not 0 <= n_rx < w: n_rx = rx\n            n_ry = ry + dy\n            if not 0 <= n_ry < h: n_ry = ry\n            rm = MR[n_ry][n_rx]\n            if rm == '#':\n                n_rx = rx; n_ry = ry\n                rm = '.'\n            n_lx = lx - dx\n            if not 0 <= n_lx < w: n_lx = lx\n            n_ly = ly + dy\n            if not 0 <= n_ly < h: n_ly = ly\n            lm = ML[n_ly][n_lx]\n            if lm == '#':\n                n_lx = lx; n_ly = ly\n                lm = '.'\n            if rm == '%' or lm == '%':\n                if rm == '%' and lm == '%':\n                    ok = 1\n                continue\n            n_key = (n_rx, n_ry, n_lx, n_ly)\n            if n_key not in dist:\n                dist.add(n_key)\n                deq.append(n_key)\n    print \"Yes\"*ok or \"No\""
  },
  {
    "language": "Python",
    "code": "from collections import deque\nwhile True:\n    w,h=map(int,input().split(\" \"))\n    def isrange(p):\n        return 0<=p[0] and p[0]<h and 0<=p[1] and p[1]<w\n    if w==0: break\n    rl=[[str()] for i in range(h)]\n    rr=[[str()] for i in range(h)]\n    for i in range(h):\n        rl[i],rr[i]=input().split(\" \")\n    q = deque()\n    dp=[[[[False for i in range(w)] for ii in range(h)] for iii in range(w)] for iiii in range(h)]\n    for i in range(h):\n        for j in range(w):\n            if rl[i][j]==\"L\": ls=(i,j)\n            if rr[i][j]==\"R\": rs=(i,j)\n            if rl[i][j]==\"%\": gl=(i,j)\n            if rr[i][j]==\"%\": gr=(i,j)\n    q.append((ls,rs))\n    \n    dp[ls[0]][ls[1]][rs[0]][rs[1]]=True\n    dw=(-1,0,1,0)\n    dh=(0,1,0,-1)\n    while q:\n        val=q.pop()\n        lp=val[0]\n        rp=val[1]\n        for i in range(4):\n            lnp=(lp[0]+dh[i],lp[1]+dw[i])\n            rnp=(rp[0]+dh[i],rp[1]-dw[i])\n            if (not isrange(lnp)) or rl[lnp[0]][lnp[1]]==\"#\" : lnp=lp\n            if (not isrange(rnp)) or rr[rnp[0]][rnp[1]]==\"#\" : rnp=rp\n            if dp[lnp[0]][lnp[1]][rnp[0]][rnp[1]]: continue\n            dp[lnp[0]][lnp[1]][rnp[0]][rnp[1]]=True\n            q.append((lnp,rnp))\n    if dp[gl[0]][gl[1]][gr[0]][gr[1]] : print(\"Yes\")\n    else : print(\"No\")\n    dp.clear()\n    q.clear()\n    rl.clear()\n    rr.clear()"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nwhile True:\n    w,h=map(int,input().split(\" \"))\n    def isrange(p):\n        return 0<=p[0] and p[0]<h and 0<=p[1] and p[1]<w\n    if w==0: break\n    rl=[[str()] for i in range(h)]\n    rr=[[str()] for i in range(h)]\n    for i in range(h):\n        rl[i],rr[i]=input().split(\" \")\n    q = deque()\n    s=set()\n    for i in range(h):\n        for j in range(w):\n            if rl[i][j]==\"L\": ls=(i,j)\n            if rr[i][j]==\"R\": rs=(i,j)\n            if rl[i][j]==\"%\": gl=(i,j)\n            if rr[i][j]==\"%\": gr=(i,j)\n    q.append((ls,rs))\n    dw=(-1,0,1,0)\n    dh=(0,1,0,-1)\n    while q:\n        val=q.pop()\n        if val in s: continue\n        s.add(val)\n        lp=val[0]\n        rp=val[1]\n        for i in range(4):\n            lnp=(lp[0]+dh[i],lp[1]+dw[i])\n            rnp=(rp[0]+dh[i],rp[1]-dw[i])\n            if (not isrange(lnp)) or rl[lnp[0]][lnp[1]]==\"#\" : lnp=lp\n            if (not isrange(rnp)) or rr[rnp[0]][rnp[1]]==\"#\" : rnp=rp\n            if (lnp,rnp) in s: continue\n            s.add((lnp,rnp))\n            q.append((lnp,rnp))\n    if (gl,gr) in s : print(\"Yes\")\n    else : print(\"No\")"
  },
  {
    "language": "Python",
    "code": "from collections import deque, defaultdict\n\ndef main():\n  directs = ((-1, 0, 1, 0), (1, 0, -1, 0), (0, 1, 0, 1), (0, -1, 0, -1))\n  while True:\n    w, h = map(int, input().split())\n    if w == 0:\n      break\n  \n    mp_l = [\"#\" * (w + 2)]\n    mp_r = [\"#\" * (w + 2)]\n    for _ in range(h):\n      l, r = input().split()\n      l = \"#\" + l + \"#\"\n      r = \"#\" + r + \"#\"\n      mp_l.append(l)\n      mp_r.append(r)\n    mp_l.append(\"#\" * (w + 2))\n    mp_r.append(\"#\" * (w + 2))\n    \n    for y in range(1, h + 1):\n      for x in range(1, w + 1):\n        if mp_l[y][x] == \"L\":\n          start_l = (x, y)\n        if mp_r[y][x] == \"R\":\n          start_r = (x, y)\n    \n    dic = [[[[False] * (h + 2) for _ in range(w + 2)] for _ in range(h + 2)] for _ in range(w + 2)]\n    def search():\n      que = deque()\n      app = que.append\n      pop = que.popleft\n      app((start_l[0], start_l[1], start_r[0], start_r[1]))\n      dic[start_l[0]][start_l[1]][start_r[0]][start_r[1]] = True\n      while que:\n        lx, ly, rx, ry = pop()\n        for ldx, ldy, rdx, rdy in directs:\n          if mp_l[ly + ldy][lx + ldx] != \"#\":\n            lnx, lny = lx + ldx, ly + ldy\n          else:\n            lnx, lny = lx, ly\n          if mp_r[ry + rdy][rx + rdx] != \"#\":\n            rnx, rny = rx + rdx, ry + rdy\n          else:\n            rnx, rny = rx, ry\n          #lnx, lny = (lx + ldx, ly + ldy) if mp_l[ly + ldy][lx + ldx] != \"#\" else (lx, ly)\n          #rnx, rny = (rx + rdx, ry + rdy) if mp_r[ry + rdy][rx + rdx] != \"#\" else (rx, ry)\n          if not dic[lnx][lny][rnx][rny]:\n            dic[lnx][lny][rnx][rny] = True\n            lsym, rsym = mp_l[lny][lnx], mp_r[rny][rnx]\n            if lsym == \"%\" and rsym == \"%\":\n              print(\"Yes\")\n              return\n            if lsym != \"%\" and rsym != \"%\":\n              app(((lnx, lny, rnx, rny)))\n      else:\n        print(\"No\")\n        return\n    search()\n \nmain()\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque, defaultdict\n\ndef main():\n  directs = ((-1, 0, 1, 0), (1, 0, -1, 0), (0, 1, 0, 1), (0, -1, 0, -1))\n  while True:\n    w, h = map(int, input().split())\n    if w == 0:\n      break\n  \n    mp_l = [\"#\" * (w + 2)]\n    mp_r = [\"#\" * (w + 2)]\n    for _ in range(h):\n      l, r = input().split()\n      l = \"#\" + l + \"#\"\n      r = \"#\" + r + \"#\"\n      mp_l.append(l)\n      mp_r.append(r)\n    mp_l.append(\"#\" * (w + 2))\n    mp_r.append(\"#\" * (w + 2))\n    \n    for y in range(1, h + 1):\n      for x in range(1, w + 1):\n        if mp_l[y][x] == \"L\":\n          start_l = (x, y)\n        if mp_r[y][x] == \"R\":\n          start_r = (x, y)\n    \n    dic = [[[[False] * (h + 2) for _ in range(w + 2)] for _ in range(h + 2)] for _ in range(w + 2)]\n    def search():\n      que = deque()\n      app = que.append\n      pop = que.popleft\n      app((start_l[0], start_l[1], start_r[0], start_r[1]))\n      dic[start_l[0]][start_l[1]][start_r[0]][start_r[1]] = True\n      while que:\n        lx, ly, rx, ry = pop()\n        for ldx, ldy, rdx, rdy in directs:\n          lnx, lny = (lx + ldx, ly + ldy) if mp_l[ly + ldy][lx + ldx] != \"#\" else (lx, ly)\n          rnx, rny = (rx + rdx, ry + rdy) if mp_r[ry + rdy][rx + rdx] != \"#\" else (rx, ry)\n          if not dic[lnx][lny][rnx][rny]:\n            dic[lnx][lny][rnx][rny] = True\n            lsym, rsym = mp_l[lny][lnx], mp_r[rny][rnx]\n            if lsym == \"%\" and rsym == \"%\":\n              print(\"Yes\")\n              return\n            if lsym != \"%\" and rsym != \"%\":\n              app(((lnx, lny, rnx, rny)))\n      else:\n        print(\"No\")\n        return\n    search()\n \nmain()\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef bfs(W, H):\n    G = '%'\n    edges = '#' * (W + 2)\n    dxy = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    mapL, mapR = [edges], [edges]\n    for i in range(H):\n        l, r = input().split()\n        mapL.append('#' + l + '#')\n        mapR.append('#' + r + '#')\n        if 'L' in l:\n            lx, ly = i+1, l.index('L')+1\n        if 'R' in r:\n            rx, ry = i+1, r.index('R')+1\n    mapL.append(edges)\n    mapR.append(edges)\n    que = deque()\n    enq, deq = que.append, que.popleft\n    visited = [[[[0]*(W+2)for _ in[0]*(H+2)]for _ in[0]*(W+2)]for _ in[0]*(H+2)]\n    enq((lx, ly, rx, ry))\n    visited[lx][ly][rx][ry] = 1\n    while que:\n        lx, ly, rx, ry = deq()\n        for dx, dy in dxy:\n            llx, lly, rrx, rry = lx + dx, ly + dy, rx + dx, ry - dy\n            if mapL[llx][lly] == '#':\n                llx, lly = lx, ly\n            if mapR[rrx][rry] == '#':\n                rrx, rry = rx, ry\n            if not visited[llx][lly][rrx][rry]:\n                nextL, nextR = mapL[llx][lly], mapR[rrx][rry]\n                if nextL == G and nextR == G:\n                    return 'Yes'\n                if nextL != G and nextR != G:\n                    enq((llx, lly, rrx, rry))\n                    visited[llx][lly][rrx][rry] = 1\n    return 'No'\n\ndef main():\n    for e in iter(input, '0 0'):\n        W, H = map(int, e.split())\n        print(bfs(W, H))\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nwhile True:\n    w,h=map(int,input().split(\" \"))\n    def isrange(p):\n        return 0<=p[0] and p[0]<h and 0<=p[1] and p[1]<w\n    if w==0: break\n    rl=[[str()] for i in range(h)]\n    rr=[[str()] for i in range(h)]\n    for i in range(h):\n        rl[i],rr[i]=input().split(\" \")\n    q = deque()\n    s=set()\n    for i in range(h):\n        for j in range(w):\n            if rl[i][j]==\"L\": ls=(i,j)\n            if rr[i][j]==\"R\": rs=(i,j)\n            if rl[i][j]==\"%\": gl=(i,j)\n            if rr[i][j]==\"%\": gr=(i,j)\n    q.append((ls,rs))\n    dw=(-1,0,1,0)\n    dh=(0,1,0,-1)\n    while q:\n        val=q.pop()\n        s.add(val)\n        lp=val[0]\n        rp=val[1]\n        for i in range(4):\n            lnp=(lp[0]+dh[i],lp[1]+dw[i])\n            rnp=(rp[0]+dh[i],rp[1]-dw[i])\n            if (not isrange(lnp)) or rl[lnp[0]][lnp[1]]==\"#\" : lnp=lp\n            if (not isrange(rnp)) or rr[rnp[0]][rnp[1]]==\"#\" : rnp=rp\n            if (lnp,rnp) in s: continue\n            s.add((lnp,rnp))\n            q.append((lnp,rnp))\n    if (gl,gr) in s : print(\"Yes\")\n    else : print(\"No\")"
  },
  {
    "language": "Python",
    "code": "from collections import deque\ndwh = zip([1,0,-1,0,],[0,1,0,-1])\nwhile 1:\n    W,H = map(int,raw_input().split())\n    if W == 0: break\n    A,B = [],[]\n    for loop in xrange(H):\n        a,b = raw_input().split()\n        A.append(list(a))\n        B.append(list(b))\n\n    for h in xrange(H):\n        for w in xrange(W):\n            if A[h][w] == \"L\": wl ,hl  = w,h\n            if B[h][w] == \"R\": wr ,hr  = w,h\n            if A[h][w] == \"%\": wlg,hlg = w,h\n            if B[h][w] == \"%\": wrg,hrg = w,h\n\n    visited = [[[[False]*W for i in xrange(H)] for j in xrange(W)] for k in xrange(H)]    \n    visited[hl][wl][hr][wr] = True\n    que = deque([[wl,hl,wr,hr]])\n    while que:\n        wl,hl,wr,hr = que.popleft()\n        if (wl,hl) == (wlg,hlg) and (wr,hr) == (wrg,hrg):\n            print \"Yes\"\n            break\n        for dw,dh in dwh:\n            nwl,nhl = min(W-1,max(0,wl+dw)), min(H-1,max(0,hl+dh))\n            if A[nhl][nwl] == \"#\": nwl,nhl = wl,hl\n            nwr,nhr = min(W-1,max(0,wr-dw)), min(H-1,max(0,hr+dh))\n            if B[nhr][nwr] == \"#\": nwr,nhr = wr,hr\n            if not visited[nhl][nwl][nhr][nwr]:\n                if ((nwl,nhl) == (wlg,hlg)) + ((nwr,nhr) == (wrg,hrg)) == 1: continue\n                visited[nhl][nwl][nhr][nwr] = True\n                que.append([nwl,nhl,nwr,nhr])\n    else:\n        print \"No\""
  },
  {
    "language": "Python",
    "code": "from collections import deque\nwhile True:\n    w,h=map(int,input().split(\" \"))\n    def isrange(p):\n        return 0<=p[0] and p[0]<h and 0<=p[1] and p[1]<w\n    if w==0: break\n    rl=[[str()] for i in range(h)]\n    rr=[[str()] for i in range(h)]\n    for i in range(h):\n        rl[i],rr[i]=input().split(\" \")\n    q = deque()\n    s=set()\n    for i in range(h):\n        for j in range(w):\n            if rl[i][j]==\"L\": ls=(i,j)\n            if rr[i][j]==\"R\": rs=(i,j)\n            if rl[i][j]==\"%\": gl=(i,j)\n            if rr[i][j]==\"%\": gr=(i,j)\n    q.append((ls,rs))\n    dw=(-1,0,1,0)\n    dh=(0,1,0,-1)\n    while q:\n        val=q.pop()\n        s.add(val)\n        lp=val[0]"
  },
  {
    "language": "Python",
    "code": "import numpy"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 998244353\ndd = [(0,-1),(1,0),(0,1),(-1,0)]\nddn = [(0,-1),(1,-1),(1,0),(1,1),(0,1),(-1,-1),(-1,0),(-1,1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    while True:\n        w,h = LI()\n        if w == 0:\n            break\n        # print(w,h)\n        W = w+2\n        dd = [(0,-1),(W,0),(0,1),(-W,0)]\n        la = [\"#\" * W]\n        ra = [\"#\" * W]\n        for _ in range(h):\n            l,r = LS()\n            la.append(\"#{}#\".format(l))\n            ra.append(\"#{}#\".format(r))\n        la.append(\"#\" * W)\n        ra.append(\"#\" * W)\n        ls = None\n        rs = None\n        lp = None\n        rp = None\n        for i in range(1,h+2):\n            for j in range(1,w+2):\n                if la[i][j] == 'L':\n                    ls = i*W+j\n                elif la[i][j] == '%':\n                    lp = i*W+j\n                if ra[i][j] == 'R':\n                    rs = i*W+j\n                elif ra[i][j] == '%':\n                    rp = i*W+j\n        lla = []\n        rra = []\n        for i in range(h+2):\n            for j in range(w+2):\n                if la[i][j] == '#':\n                    lla.append(None)\n                else:\n                    lla.append(1)\n                if ra[i][j] == '#':\n                    rra.append(None)\n                else:\n                    rra.append(1)\n\n\n        def search(s):\n            q = []\n            q.append(s)\n            v = set()\n            v.add(s)\n            qi = 0\n            while len(q) > qi:\n                u = q[qi]\n                qi += 1\n\n                for di, dj in dd:\n                    lij = u[0]\n                    if not lla[lij+di+dj] is None:\n                        lij += di + dj\n                    rij = u[1]\n                    if not rra[rij+di-dj] is None:\n                        rij += di - dj\n\n                    uv = (lij,rij)\n                    if uv in v:\n                        continue\n                    v.add(uv)\n                    if lij == lp and rij == rp:\n                        # print(len(q))\n                        return True\n                    if lij == lp:\n                        continue\n                    if rij == rp:\n                        continue\n\n                    q.append(uv)\n\n            # print(len(q))\n            return False\n\n        if search((ls,rs)):\n            rr.append('Yes')\n        else:\n            rr.append('No')\n        # print(rr[-1])\n\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndirects = ((-1, 0, 1, 0), (1, 0, -1, 0), (0, 1, 0, 1), (0, -1, 0, -1))\n\ndef search(start_l, start_r, mp_l, mp_r, dic):\n  que = deque()\n  que.append((start_l[0], start_l[1], start_r[0], start_r[1]))\n  dic[start_l[0]][start_l[1]][start_r[0]][start_r[1]] = True\n  while que:\n    lx, ly, rx, ry = que.popleft()\n    for ldx, ldy, rdx, rdy in directs:\n      lnx, lny = (lx + ldx, ly + ldy) if mp_l[ly + ldy][lx + ldx] != \"#\" else (lx, ly)\n      rnx, rny = (rx + rdx, ry + rdy) if mp_r[ry + rdy][rx + rdx] != \"#\" else (rx, ry)\n      if not dic[lnx][lny][rnx][rny]:\n        dic[lnx][lny][rnx][rny] = True\n        lsym, rsym = mp_l[lny][lnx], mp_r[rny][rnx]\n        if lsym == \"%\" and rsym == \"%\":\n          print(\"Yes\")\n          return\n        if lsym != \"%\" and rsym != \"%\":\n          que.append(((lnx, lny, rnx, rny)))\n  else:\n    print(\"No\")\n    return\n\ndef main():\n  while True:\n    w, h = map(int, input().split())\n    if w == 0:\n      break\n  \n    mp_l = [\"#\" * (w + 2)]\n    mp_r = [\"#\" * (w + 2)]\n    for _ in range(h):\n      l, r = input().split()\n      l = \"#\" + l + \"#\"\n      r = \"#\" + r + \"#\"\n      mp_l.append(l)\n      mp_r.append(r)\n    mp_l.append(\"#\" * (w + 2))\n    mp_r.append(\"#\" * (w + 2))\n    \n    for y in range(1, h + 1):\n      for x in range(1, w + 1):\n        if mp_l[y][x] == \"L\":\n          start_l = (x, y)\n        if mp_r[y][x] == \"R\":\n          start_r = (x, y)\n    dic = [[[[False] * (h + 2) for _ in range(w + 2)] for _ in range(h + 2)] for _ in range(w + 2)]\n    search(start_l, start_r, mp_l, mp_r, dic)\n  \nmain()\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 998244353\ndd = [(0,-1),(1,0),(0,1),(-1,0)]\nddn = [(0,-1),(1,-1),(1,0),(1,1),(0,1),(-1,-1),(-1,0),(-1,1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    while True:\n        w,h = LI()\n        if w == 0:\n            break\n        la = [\"#\" * (w+2)]\n        ra = [\"#\" * (w+2)]\n        for _ in range(h):\n            l,r = LS()\n            la.append(\"#{}#\".format(l))\n            ra.append(\"#{}#\".format(r))\n        la.append(\"#\" * (w+2))\n        ra.append(\"#\" * (w+2))\n        ls = None\n        rs = None\n        for i in range(1,h+2):\n            for j in range(1,w+2):\n                if la[i][j] == 'L':\n                    ls = (i,j)\n                if ra[i][j] == 'R':\n                    rs = (i,j)\n\n        def search(s):\n            d = collections.defaultdict(lambda: inf)\n            d[s] = 0\n            q = []\n            heapq.heappush(q, (0, s))\n            v = collections.defaultdict(bool)\n            while len(q):\n                k, u = heapq.heappop(q)\n                if v[u]:\n                    continue\n                v[u] = True\n\n                for di, dj in dd:\n                    li = u[0][0] + di\n                    lj = u[0][1] + dj\n                    if la[li][lj] == \"#\":\n                        li -= di\n                        lj -= dj\n                    ri = u[1][0] + di\n                    rj = u[1][1] - dj\n                    if ra[ri][rj] == \"#\":\n                        ri -= di\n                        rj += dj\n                    if la[li][lj] == '%' and ra[ri][rj] == '%':\n                        return True\n                    if la[li][lj] == '%':\n                        continue\n                    if ra[ri][rj] == '%':\n                        continue\n                    uv = ((li,lj), (ri,rj))\n\n                    if v[uv]:\n                        continue\n                    vd = k + 1\n                    if d[uv] > vd:\n                        d[uv] = vd\n                        heapq.heappush(q, (vd, uv))\n\n            return False\n\n        if search((ls,rs)):\n            rr.append('Yes')\n        else:\n            rr.append('No')\n\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nprint(\" \")"
  },
  {
    "language": "Python",
    "code": "dwh = zip([1,0,-1,0,],[0,1,0,-1])\nwhile 1:\n    W,H = map(int,raw_input().split())\n    if W == 0: break\n    A,B = [],[]\n    for loop in xrange(H):\n        a,b = raw_input().split()\n        A.append(list(a))\n        B.append(list(b))\n\n    for h in xrange(H):\n        for w in xrange(W):\n            if A[h][w] == \"L\": wl ,hl  = w,h\n            if B[h][w] == \"R\": wr ,hr  = w,h\n            if A[h][w] == \"%\": wlg,hlg = w,h\n            if B[h][w] == \"%\": wrg,hrg = w,h\n\n    visited = [[[[False]*W for i in xrange(H)] for j in xrange(W)] for k in xrange(H)]    \n    visited[hl][wl][hr][wr] = True\n    que = [[wl,hl,wr,hr]]\n    while que:\n        wl,hl,wr,hr = que.pop(0)\n        if (wl,hl) == (wlg,hlg) and (wr,hr) == (wrg,hrg):\n            print \"Yes\"\n            break\n        for dw,dh in dwh:\n            nwl,nhl = min(W-1,max(0,wl+dw)), min(H-1,max(0,hl+dh))\n            if A[nhl][nwl] == \"#\": nwl,nhl = wl,hl\n            nwr,nhr = min(W-1,max(0,wr-dw)), min(H-1,max(0,hr+dh))\n            if B[nhr][nwr] == \"#\": nwr,nhr = wr,hr\n            if not visited[nhl][nwl][nhr][nwr]:\n                if ((nwl,nhl) == (wlg,hlg)) + ((nwr,nhr) == (wrg,hrg)) == 1: continue\n                visited[nhl][nwl][nhr][nwr] = True\n                que.append([nwl,nhl,nwr,nhr])\n    else:\n        print \"No\""
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    def f(w, h):\n        w2 = w+2\n        la = ['#' * w2]\n        ra = ['#' * w2]\n        ls = rs = None\n        for i in range(1,h+1):\n            lt, rt = LS()\n            if 'L' in lt:\n                ls = (i, lt.index('L') + 1)\n            if 'R' in rt:\n                rs = (i, rt.index('R') + 1)\n            la.append('#' + lt + '#')\n            ra.append('#' + rt + '#')\n        la.append('#' * w2)\n        ra.append('#' * w2)\n\n        q = collections.deque([(ls[0], ls[1], rs[0], rs[1])])\n        v = collections.defaultdict(bool)\n        v[(ls[0], ls[1], rs[0], rs[1])] = 1\n        while q:\n            ly,lx,ry,rx = q.pop()\n            for dy, dx in dd:\n                lty = ly + dy\n                ltx = lx + dx\n                rty = ry + dy\n                rtx = rx - dx\n                if la[lty][ltx] == '#':\n                    lty = ly\n                    ltx = lx\n                if ra[rty][rtx] == '#':\n                    rty = ry\n                    rtx = rx\n                if v[(lty,ltx,rty,rtx)]:\n                    continue\n                v[(lty,ltx,rty,rtx)] = 1\n                if la[lty][ltx] == '%' and ra[rty][rtx] == '%':\n                    return 'Yes'\n                if la[lty][ltx] != '%' and ra[rty][rtx] != '%':\n                    q.append((lty,ltx,rty,rtx))\n\n        return 'No'\n\n    while True:\n        w,h = LI()\n        if w == 0 and h == 0:\n            break\n        rr.append(f(w,h))\n\n    return '\\n'.join(rr)\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nwhile True:\n    w,h=map(int,input().split(\" \"))\n    def isrange(p):\n        return 0<=p[0] and p[0]<h and 0<=p[1] and p[1]<w\n    if w==0: break\n    rl=[[str()] for i in range(h)]\n    rr=[[str()] for i in range(h)]\n    for i in range(h):\n        rl[i],rr[i]=input().split(\" \")\n    q = deque()\n    dp=[[[[False for i in range(w)] for ii in range(h)] for iii in range(w)] for iiii in range(h)]\n    for i in range(h):\n        for j in range(w):\n            if rl[i][j]==\"L\": ls=(i,j)\n            if rr[i][j]==\"R\": rs=(i,j)\n            if rl[i][j]==\"%\": gl=(i,j)\n            if rr[i][j]==\"%\": gr=(i,j)\n    q.append((ls,rs))\n    \n    dp[ls[0]][ls[1]][rs[0]][rs[1]]=True\n    dw=(-1,0,1,0)\n    dh=(0,1,0,-1)\n    cnt=0\n    while q:\n        if cnt>int(1e7): break\n        cnt+=1\n        val=q.pop()\n        lp=val[0]\n        rp=val[1]\n        for i in range(4):\n            lnp=(lp[0]+dh[i],lp[1]+dw[i])\n            rnp=(rp[0]+dh[i],rp[1]-dw[i])\n            if (not isrange(lnp)) or rl[lnp[0]][lnp[1]]==\"#\" : lnp=lp\n            if (not isrange(rnp)) or rr[rnp[0]][rnp[1]]==\"#\" : rnp=rp\n            if dp[lnp[0]][lnp[1]][rnp[0]][rnp[1]]: continue\n            dp[lnp[0]][lnp[1]][rnp[0]][rnp[1]]=True\n            q.append((lnp,rnp))\n    if dp[gl[0]][gl[1]][gr[0]][gr[1]] : print(\"Yes\")\n    else : print(\"No\")\n    dp.clear()\n    q.clear()\n    rl.clear()\n    rr.clear()"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nfrom collections import deque\nwhile True:\n    w,h=map(int,input().split(\" \"))\n    def isrange(p):\n        return 0<=p[0] and p[0]<h and 0<=p[1] and p[1]<w\n    if w==0: break\n    rl=[[str()] for i in range(h)]\n    rr=[[str()] for i in range(h)]\n    for i in range(h):\n        rl[i],rr[i]=input().split(\" \")\n    q = deque()\n    dp=np.ndarray((h,w,h,w))\n    for i in range(h):\n        for j in range(w):\n            for ii in range(h):\n                for jj in range(w):\n                    dp[i][j][ii][jj]=True\n    for i in range(h):\n        for j in range(w):\n            if rl[i][j]==\"L\": ls=(i,j)\n            if rr[i][j]==\"R\": rs=(i,j)\n            if rl[i][j]==\"%\": gl=(i,j)\n            if rr[i][j]==\"%\": gr=(i,j)\n    q.append((ls,rs))\n    \n    dp[ls[0]][ls[1]][rs[0]][rs[1]]=True\n    dw=(-1,0,1,0)\n    dh=(0,1,0,-1)\n    cnt=0\n    while q:\n        if cnt>int(1e7): break\n        cnt+=1\n        val=q.pop()\n        lp=val[0]\n        rp=val[1]\n        for i in range(4):\n            lnp=(lp[0]+dh[i],lp[1]+dw[i])\n            rnp=(rp[0]+dh[i],rp[1]-dw[i])\n            if (not isrange(lnp)) or rl[lnp[0]][lnp[1]]==\"#\" : lnp=lp\n            if (not isrange(rnp)) or rr[rnp[0]][rnp[1]]==\"#\" : rnp=rp\n            if dp[lnp[0]][lnp[1]][rnp[0]][rnp[1]]: continue\n            dp[lnp[0]][lnp[1]][rnp[0]][rnp[1]]=True\n            q.append((lnp,rnp))\n    if dp[gl[0]][gl[1]][gr[0]][gr[1]] : print(\"Yes\")\n    else : print(\"No\")"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nfrom collections import deque\nwhile True:\n    w,h=map(int,input().split(\" \"))\n    def isrange(p):\n        return 0<=p[0] and p[0]<h and 0<=p[1] and p[1]<w\n    if w==0: break\n    rl=[[str()] for i in range(h)]\n    rr=[[str()] for i in range(h)]\n    for i in range(h):\n        rl[i],rr[i]=input().split(\" \")\n    q = deque()\n    dp=np.array((h,w,h,w))\n    for i in range(h):\n        for j in range(w):\n            if rl[i][j]==\"L\": ls=(i,j)\n            if rr[i][j]==\"R\": rs=(i,j)\n            if rl[i][j]==\"%\": gl=(i,j)\n            if rr[i][j]==\"%\": gr=(i,j)\n    q.append((ls,rs))\n    \n    dp[ls[0]][ls[1]][rs[0]][rs[1]]=True\n    dw=(-1,0,1,0)\n    dh=(0,1,0,-1)\n    cnt=0\n    while q:\n        if cnt>int(1e7): break\n        cnt+=1\n        val=q.pop()\n        lp=val[0]\n        rp=val[1]\n        for i in range(4):\n            lnp=(lp[0]+dh[i],lp[1]+dw[i])\n            rnp=(rp[0]+dh[i],rp[1]-dw[i])\n            if (not isrange(lnp)) or rl[lnp[0]][lnp[1]]==\"#\" : lnp=lp\n            if (not isrange(rnp)) or rr[rnp[0]][rnp[1]]==\"#\" : rnp=rp\n            if dp[lnp[0]][lnp[1]][rnp[0]][rnp[1]]: continue\n            dp[lnp[0]][lnp[1]][rnp[0]][rnp[1]]=True\n            q.append((lnp,rnp))\n    if dp[gl[0]][gl[1]][gr[0]][gr[1]] : print(\"Yes\")\n    else : print(\"No\")\n    dp.clear()\n    q.clear()\n    rl.clear()\n    rr.clear()"
  },
  {
    "language": "Python",
    "code": "from collections import deque\ndd = [(-1, 0), (0, -1), (1, 0), (0, 1)]\nwhile 1:\n    w, h = map(int, raw_input().split())\n    if w==0:\n        break\n    M = [raw_input() for i in xrange(h)]\n    ML = [e[:w] for e in M]\n    MR = [e[w+1:] for e in M]\n    for i in xrange(h):\n        for j in xrange(w):\n            if MR[i][j] == 'R':\n                rx = j; ry = i\n            elif ML[i][j] == 'L':\n                lx = j; ly = i\n    dist = {(rx, ry, lx, ly)}\n    deq = deque()\n    deq.append((rx, ry, lx, ly))\n    ok = 0\n    while deq and not ok:\n        rx, ry, lx, ly = deq.popleft()\n        for dx, dy in dd:\n            n_rx = rx + dx\n            if not 0 <= n_rx < w: n_rx = rx\n            n_ry = ry + dy\n            if not 0 <= n_ry < h: n_ry = ry\n            rm = MR[n_ry][n_rx]\n            if rm == '#':\n                n_rx = rx; n_ry = ry\n                rm = '.'\n            n_lx = lx - dx\n            if not 0 <= n_lx < w: n_lx = lx\n            n_ly = ly + dy\n            if not 0 <= n_ly < h: n_ly = ly\n            lm = ML[n_ly][n_lx]\n            if lm == '#':\n                n_lx = lx; n_ly = ly\n                lm = '.'\n            if rm == '%' or lm == '%':\n                if rm == '%' and lm == '%':\n                    ok = 1\n                continue\n            n_key = (n_rx, n_ry, n_lx, n_ly)\n            if n_key not in dist:\n                dist.add(n_key)\n                deq.append(n_key)\n    print \"Yes\"*ok or \"No\""
  },
  {
    "language": "Python",
    "code": "from collections import deque\nwhile True:\n    w,h=map(int,input().split(\" \"))\n    def isrange(p):\n        return 0<=p[0] and p[0]<h and 0<=p[1] and p[1]<w\n    if w==0: break\n    rl=[[str()] for i in range(h)]\n    rr=[[str()] for i in range(h)]\n    for i in range(h):\n        rl[i],rr[i]=input().split(\" \")\n    q = deque()\n    dp=[[[[False for i in range(w)] for ii in range(h)] for iii in range(w)] for iiii in range(h)]\n    for i in range(h):\n        for j in range(w):\n            if rl[i][j]==\"L\": ls=(i,j)\n            if rr[i][j]==\"R\": rs=(i,j)\n            if rl[i][j]==\"%\": gl=(i,j)\n            if rr[i][j]==\"%\": gr=(i,j)\n    q.append((ls,rs))\n    \n    dp[ls[0]][ls[1]][rs[0]][rs[1]]=True\n    dw=(-1,0,1,0)\n    dh=(0,1,0,-1)\n    while q:\n        val=q.pop()\n        lp=val[0]\n        rp=val[1]\n        for i in range(4):\n            lnp=(lp[0]+dh[i],lp[1]+dw[i])\n            rnp=(rp[0]+dh[i],rp[1]-dw[i])\n            if (not isrange(lnp)) or rl[lnp[0]][lnp[1]]==\"#\" : lnp=lp\n            if (not isrange(rnp)) or rr[rnp[0]][rnp[1]]==\"#\" : rnp=rp\n            if dp[lnp[0]][lnp[1]][rnp[0]][rnp[1]]: continue\n            dp[lnp[0]][lnp[1]][rnp[0]][rnp[1]]=True\n            q.append((lnp,rnp))\n    if dp[gl[0]][gl[1]][gr[0]][gr[1]] : print(\"Yes\")\n    else : print(\"No\")"
  },
  {
    "language": "Python",
    "code": "from collections import deque,defaultdict\n\nd = [(1,0),(-1,0),(0,1),(0,-1)]\n\ndef bfs(sly,slx,sry,srx):\n    bfs_map = defaultdict(lambda : 1)\n    bfs_map[(sly,slx,sry,srx)] = 0\n    q = deque()\n    q.append((sly,slx,sry,srx))\n    while q:\n        ly,lx,ry,rx = q.popleft()\n        for dy,dx in d:\n            ly_ = ly+dy\n            lx_ = lx+dx\n            ry_ = ry+dy\n            rx_ = rx-dx\n            if ly_ < 0 or h <= ly_ or lx_ < 0 or w <= lx_:\n                ly_,lx_ = ly,lx\n            elif l[ly_][lx_] == \"#\":\n                ly_,lx_ = ly,lx\n            if ry_ < 0 or h <= ry_ or rx_ < 0 or w <= rx_:\n                ry_,rx_ = ry,rx\n            elif r[ry_][rx_] == \"#\":\n                ry_,rx_ = ry,rx\n            if ly_ == gly and lx_ == glx and ry_ == gry and rx_ == grx:\n                return \"Yes\"\n            if bfs_map[(ly_,lx_,ry_,rx_)]:\n                if l[ly_][lx_] != \"%\" and r[ry_][rx_] != \"%\":\n                    q.append((ly_,lx_,ry_,rx_))\n                    bfs_map[(ly_,lx_,ry_,rx_)] = 0\n\n    return \"No\"\n\nwhile 1:\n    w,h = map(int, input().split())\n    if w == h == 0:\n        break\n    s = [input().split() for i in range(h)]\n    l = [s[i][0] for i in range(h)]\n    r = [s[i][1] for i in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if l[y][x] == \"L\":\n                sly,slx = y,x\n            elif l[y][x] == \"%\":\n                gly,glx = y,x\n    for y in range(h):\n        for x in range(w):\n            if r[y][x] == \"R\":\n                sry,srx = y,x\n            elif r[y][x] == \"%\":\n                gry,grx = y,x\n    print(bfs(sly,slx,sry,srx))\n\n"
  },
  {
    "language": "Python",
    "code": "from Queue import Queue\n\ndef isValid(W,H,x,y):\n  return 0<=x and x<H and 0<=y and y<W\n\ndef walking(L,R,start):\n  vec=[(1,0,1,0),(-1,0,-1,0),(0,1,0,-1),(0,-1,0,1)]\n  q=Queue()\n  searched={}\n  q.put(startPos)\n  searched[startPos]=True\n  while q.qsize()>0:\n    lx,ly,rx,ry=q.get()\n    for dlx,dly,drx,dry in vec:\n      if not isValid(W,H,lx+dlx,ly+dly): dlx,dly=(0,0)\n      if not isValid(W,H,rx+drx,ry+dry): drx,dry=(0,0)\n      if L[lx+dlx][ly+dly]==\"#\": dlx,dly=(0,0)\n      if R[rx+drx][ry+dry]==\"#\": drx,dry=(0,0)\n      newPos = (lx+dlx, ly+dly, rx+drx, ry+dry)\n      if newPos in searched: continue\n      if L[newPos[0]][newPos[1]]==\"%\" and R[newPos[2]][newPos[3]]==\"%\":\n        print \"Yes\"\n        return\n      elif not L[newPos[0]][newPos[1]]==\"%\" and not R[newPos[2]][newPos[3]]==\"%\":\n        q.put(newPos)\n        searched[newPos]=True\n  print \"No\"\n\nwhile True:\n  W,H=map(int,raw_input().split())\n  if W==0: break\n  L=[]\n  R=[]\n  lx=-1\n  ly=-1\n  rx=-1\n  ry=-1\n  for _ in xrange(H):\n    l,r=raw_input().split()\n    L.append(l)\n    R.append(r)\n  for i in xrange(H):\n    for j in xrange(W):\n      if L[i][j] == \"L\":\n        lx=i\n        ly=j\n      if R[i][j] == \"R\":\n        rx=i\n        ry=j\n  startPos=(lx,ly,rx,ry)\n  walking(L,R,startPos)"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nwhile True:\n    w,h=map(int,input().split(\" \"))\n    def isrange(p):\n        return 0<=p[0] and p[0]<h and 0<=p[1] and p[1]<w\n    if w==0: break\n    rl=[[str()] for i in range(h)]\n    rr=[[str()] for i in range(h)]\n    for i in range(h):\n        rl[i],rr[i]=input().split(\" \")\n    q = deque()\n    s=set()\n    for i in range(h):\n        for j in range(w):\n            if rl[i][j]==\"L\": ls=(i,j)\n            if rr[i][j]==\"R\": rs=(i,j)\n            if rl[i][j]==\"%\": gl=(i,j)\n            if rr[i][j]==\"%\": gr=(i,j)\n    q.append((ls,rs))\n    s.add((ls,rs))\n    dw=(-1,0,1,0)\n    dh=(0,1,0,-1)\n    while q:\n        val=q.pop()\n        lp=val[0]\n        rp=val[1]\n        for i in range(4):\n            lnp=(lp[0]+dh[i],lp[1]+dw[i])\n            rnp=(rp[0]+dh[i],rp[1]-dw[i])\n            if (not isrange(lnp)) or rl[lnp[0]][lnp[1]]==\"#\" : lnp=lp\n            if (not isrange(rnp)) or rr[rnp[0]][rnp[1]]==\"#\" : rnp=rp\n            if (lnp,rnp) in s: continue\n            s.add((lnp,rnp))\n            q.append((lnp,rnp))\n    if (gl,gr) in s : print(\"Yes\")\n    else : print(\"No\")"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\nfrom collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\nimport itertools\nsys.setrecursionlimit(10**5)\nstdin = sys.stdin\nbisect_left = bisect.bisect_left\nbisect_right = bisect.bisect_right\ndef LI(): return list(map(int, stdin.readline().split()))\ndef LF(): return list(map(float, stdin.readline().split()))\ndef LI_(): return list(map(lambda x: int(x)-1, stdin.readline().split()))\ndef II(): return int(stdin.readline())\ndef IF(): return float(stdin.readline())\ndef LS(): return list(map(list, stdin.readline().split()))\ndef S(): return list(stdin.readline().rstrip())\ndef IR(n): return [II() for _ in range(n)]\ndef LIR(n): return [LI() for _ in range(n)]\ndef FR(n): return [IF() for _ in range(n)]\ndef LFR(n): return [LI() for _ in range(n)]\ndef LIR_(n): return [LI_() for _ in range(n)]\ndef SR(n): return [S() for _ in range(n)]\ndef LSR(n): return [LS() for _ in range(n)]\nmod = 1000000007\ninf = float('INF')\n\n#A\ndef A():\n    return\n\n#B\ndef B():\n    return\n\n#C\ndef C():\n    return\n\n#D\ndef D():\n    return\n\n#E\ndef E():\n    move = [[1, 0], [-1, 0], [0, 1], [0, -1]]\n    while 1:\n        w, h = LI()\n        if w == h == 0:\n            break\n        check = defaultdict(lambda: True)\n        field = SR(h)\n        for i in range(h):\n            for k in range(2 * w + 1):\n                if field[i][k] == \"L\":\n                    L = [k, i]\n                if field[i][k] == \"R\":\n                    R = [k, i]\n        state = deque()\n        state.append([L, R])\n        flg = True\n        while state and flg:\n            l, r = state.pop()\n            lx, ly = l\n            rx, ry = r\n            for mx, my in move:\n                xl = lx + mx\n                yl = ly + my\n                xr = rx - mx\n                yr = ry + my\n                if not 0 <= xl < w:\n                    xl -= mx\n                if not w + 1 <= xr < 2 * w + 1:\n                    xr += mx\n                if not 0 <= yl < h:\n                    yl -= my\n                if not 0 <= yr < h:\n                    yr -= my\n                if field[yl][xl] == \"%\" and field[yr][xr] == \"%\":\n                    flg = False\n                    break\n                if field[yl][xl] == \"#\":\n                    yl -= my\n                    xl -= mx\n                if field[yr][xr] == \"#\":\n                    yr -= my\n                    xr += mx\n                if check[(xl, xr, yl, yr)] and field[yl][xl] != \"%\" and field[yr][xr] != \"%\":\n                    check[(xl, xr, yl, yr)] = False\n                    state.append([[xl, yl], [xr, yr]])\n        if not flg:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n    return\n\n#F\ndef F():\n    return\n\n#G\ndef G():\n    return\n\n#H\ndef H():\n    return\n\n#Solve\nif __name__ == '__main__':\n    E()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndirect_l = ((-1, 0), (1, 0), (0, 1), (0, -1))\ndirect_r = ((1, 0), (-1, 0), (0, 1), (0, -1))\ndirects = tuple(zip(direct_l, direct_r))\n\ndef search(start_l, start_r, mp_l, mp_r, dic):\n  que = deque()\n  que.append((start_l, start_r))\n  dic[start_l[0]][start_l[1]][start_r[0]][start_r[1]] = True\n  while que:\n    pl, pr = que.popleft()\n    lx, ly = pl\n    rx, ry = pr\n    for ld, rd in directs:\n      ldx, ldy = ld\n      rdx, rdy = rd\n      lnx, lny = (lx + ldx, ly + ldy) if mp_l[ly + ldy][lx + ldx] != \"#\" else (lx, ly)\n      rnx, rny = (rx + rdx, ry + rdy) if mp_r[ry + rdy][rx + rdx] != \"#\" else (rx, ry)\n      if not dic[lnx][lny][rnx][rny]:\n        dic[lnx][lny][rnx][rny] = True\n        if mp_l[lny][lnx] == \"%\" and mp_r[rny][rnx] == \"%\":\n          print(\"Yes\")\n          return\n        if mp_l[lny][lnx] != \"%\" and mp_r[rny][rnx] != \"%\":\n          que.append(((lnx, lny), (rnx, rny)))\n  else:\n    print(\"No\")\n    return\n\n\nwhile True:\n  w, h = map(int, input().split())\n  if w == 0:\n    break\n\n  mp_l = [\"#\" * (w + 2)]\n  mp_r = [\"#\" * (w + 2)]\n  for _ in range(h):\n    l, r = input().split()\n    l = \"#\" + l + \"#\"\n    r = \"#\" + r + \"#\"\n    mp_l.append(l)\n    mp_r.append(r)\n  mp_l.append(\"#\" * (w + 2))\n  mp_r.append(\"#\" * (w + 2))\n  \n  for y in range(1, h + 1):\n    for x in range(1, w + 1):\n      if mp_l[y][x] == \"L\":\n        start_l = (x, y)\n      if mp_r[y][x] == \"R\":\n        start_r = (x, y)\n  #dic[lx][ly][rx][ry]\n  dic = [[[[False] * (h + 2) for _ in range(w + 2)] for _ in range(h + 2)] for _ in range(w + 2)]\n  search(start_l, start_r, mp_l, mp_r, dic)\n\n"
  }
]