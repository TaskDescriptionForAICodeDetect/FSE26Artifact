[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_ROOMS 100005\n\nint n, m;\nint passages[MAX_ROOMS][2];\nint signpost[MAX_ROOMS];\nbool visited[MAX_ROOMS];\nint parent[MAX_ROOMS];\n\nint find(int x) {\n    if (parent[x] != x) {\n        parent[x] = find(parent[x]);\n    }\n    return parent[x];\n}\n\nvoid unite(int x, int y) {\n    parent[find(x)] = find(y);\n}\n\nbool solve() {\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n        visited[i] = false;\n        signpost[i] = 0;\n    }\n\n    for (int i = 0; i < m; i++) {\n        int u = passages[i][0], v = passages[i][1];\n        unite(u, v);\n    }\n\n    for (int i = 2; i <= n; i++) {\n        if (find(1) != find(i)) {\n            return false;\n        }\n    }\n\n    for (int i = 0; i < m; i++) {\n        int u = passages[i][0], v = passages[i][1];\n        if (!visited[u] && u != 1) {\n            signpost[u] = v;\n            visited[u] = true;\n        }\n    }\n\n    for (int i = 2; i <= n; i++) {\n        if (!signpost[i]) {\n            for (int j = 0; j < m; j++) {\n                int u = passages[j][0], v = passages[j][1];\n                if (u == 1 && !visited[i]) {\n                    signpost[i] = u;\n                    visited[i] = true;\n                    break;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d\", &passages[i][0], &passages[i][1]);\n    }\n\n    if (solve()) {\n        printf(\"YES\\n\");\n        for (int i = 2; i <= n; i++) {\n            printf(\"%d \", signpost[i]);\n        }\n        printf(\"\\n\");\n    } else {\n        printf(\"NO\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:32:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100000\n#define MAX_M 200000\n\ntypedef struct {\n    int to;\n    int next;\n} Edge;\n\nEdge edges[MAX_M * 2];\nint head[MAX_N + 1];\nint edge_count = 0;\nint signpost[MAX_N + 1];\nint visited[MAX_N + 1];\nint queue[MAX_N];\nint front, rear;\n\nvoid add_edge(int u, int v) {\n    edges[edge_count].to = v;\n    edges[edge_count].next = head[u];\n    head[u] = edge_count++;\n}\n\nvoid bfs(int start, int N) {\n    front = rear = 0;\n    queue[rear++] = start;\n    visited[start] = 1;\n    signpost[start] = 0;\n\n    while (front < rear) {\n        int u = queue[front++];\n        for (int i = head[u]; i != -1; i = edges[i].next) {\n            int v = edges[i].to;\n            if (!visited[v]) {\n                visited[v] = 1;\n                signpost[v] = u;\n                queue[rear++] = v;\n            }\n        }\n    }\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    memset(head, -1, sizeof(head));\n    memset(visited, 0, sizeof(visited));\n\n    for (int i = 0; i < M; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        add_edge(u, v);\n        add_edge(v, u);\n    }\n\n    bfs(1, N);\n\n    for (int i = 2; i <= N; i++) {\n        if (!visited[i]) {\n            printf(\"No\\n\");\n            return 0;\n        }\n    }\n\n    printf(\"Yes\\n\");\n    for (int i = 2; i <= N; i++) {\n        printf(\"%d\\n\", signpost[i]);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:32:40"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<vector<int>> adj(N + 1);\n    for (int i = 0; i < M; ++i) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    vector<int> parent(N + 1, -1);\n    queue<int> q;\n    q.push(1);\n    parent[1] = 0;\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int v : adj[u]) {\n            if (parent[v] == -1) {\n                parent[v] = u;\n                q.push(v);\n            }\n        }\n    }\n\n    bool possible = true;\n    for (int i = 2; i <= N; ++i) {\n        if (parent[i] == -1) {\n            possible = false;\n            break;\n        }\n    }\n\n    if (possible) {\n        cout << \"Yes\" << endl;\n        for (int i = 2; i <= N; ++i) {\n            cout << parent[i] << endl;\n        }\n    } else {\n        cout << \"No\" << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:32:55"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class CaveSignposts {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        List<List<Integer>> adj = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            adj.add(new ArrayList<>());\n        }\n        for (int i = 0; i < M; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            adj.get(u).add(v);\n            adj.get(v).add(u);\n        }\n\n        int[] parent = new int[N + 1];\n        Arrays.fill(parent, -1);\n        Queue<Integer> queue = new LinkedList<>();\n        queue.add(1);\n        parent[1] = 0;\n\n        while (!queue.isEmpty()) {\n            int u = queue.poll();\n            for (int v : adj.get(u)) {\n                if (parent[v] == -1) {\n                    parent[v] = u;\n                    queue.add(v);\n                }\n            }\n        }\n\n        boolean possible = true;\n        for (int i = 2; i <= N; i++) {\n            if (parent[i] == -1) {\n                possible = false;\n                break;\n            }\n        }\n\n        if (possible) {\n            System.out.println(\"Yes\");\n            for (int i = 2; i <= N; i++) {\n                System.out.println(parent[i]);\n            }\n        } else {\n            System.out.println(\"No\");\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:33:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class CaveSignposts {\n    public static void solve(int N, int M, List<int[]> passages) {\n        // Create adjacency list representation of the graph\n        List<List<Integer>> graph = new ArrayList<>(N + 1);\n        for (int i = 0; i < N + 1; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        // Add passages to the graph\n        for (int[] passage : passages) {\n            graph.get(passage[0]).add(passage[1]);\n            graph.get(passage[1]).add(passage[0]);\n        }\n        \n        // Track room connections\n        int[] signposts = new int[N + 1];\n        boolean[] visited = new boolean[N + 1];\n        \n        // Try to set up signposts starting from room 1\n        boolean possible = dfs(1, graph, signposts, visited, M);\n        \n        if (possible) {\n            System.out.println(\"Signpost Configuration Possible\");\n            for (int i = 2; i <= N; i++) {\n                System.out.println(\"Room \" + i + \" points to Room \" + signposts[i]);\n            }\n        } else {\n            System.out.println(\"Not Possible\");\n        }\n    }\n    \n    private static boolean dfs(int current, List<List<Integer>> graph, \n                                int[] signposts, boolean[] visited, int remainingPassages) {\n        visited[current] = true;\n        \n        for (int neighbor : graph.get(current)) {\n            if (!visited[neighbor] && remainingPassages > 0) {\n                signposts[neighbor] = current;\n                if (dfs(neighbor, graph, signposts, visited, remainingPassages - 1)) {\n                    return true;\n                }\n                signposts[neighbor] = 0;\n            }\n        }\n        \n        // Check if all rooms except Room 1 are reachable\n        int reachableRooms = 0;\n        for (int i = 2; i < visited.length; i++) {\n            if (visited[i]) reachableRooms++;\n        }\n        \n        return reachableRooms == N - 1;\n    }\n    \n    public static void main(String[] args) {\n        // Example usage\n        int N = 5;  // Number of rooms\n        int M = 6;  // Number of passages\n        List<int[]> passages = Arrays.asList(\n            new int[]{1, 2},\n            new int[]{1, 3},\n            new int[]{2, 4},\n            new int[]{3, 4},\n            new int[]{3, 5},\n            new int[]{4, 5}\n        );\n        \n        solve(N, M, passages);\n    }\n}",
    "timestamp": "2025-08-05 22:33:18"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_set>\nusing namespace std;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    \n    vector<vector<int>> graph(N + 1);\n    vector<int> degree(N + 1, 0);\n    \n    for (int i = 0; i < M; ++i) {\n        int u, v;\n        cin >> u >> v;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n        degree[u]++;\n        degree[v]++;\n    }\n    \n    vector<int> signpost(N + 1, 0);\n    vector<bool> visited(N + 1, false);\n    queue<int> q;\n    \n    q.push(1);\n    visited[1] = true;\n    \n    while (!q.empty()) {\n        int curr = q.front();\n        q.pop();\n        \n        for (int neighbor : graph[curr]) {\n            if (!visited[neighbor]) {\n                q.push(neighbor);\n                visited[neighbor] = true;\n                signpost[neighbor] = curr;\n            }\n        }\n    }\n    \n    for (int i = 2; i <= N; ++i) {\n        if (!visited[i]) {\n            cout << \"No solution\" << endl;\n            return 0;\n        }\n    }\n    \n    for (int i = 2; i <= N; ++i) {\n        cout << i << \" \" << signpost[i] << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:33:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def signposts_configuration(N, M, passages):\n    from collections import defaultdict, deque\n    \n    # Create adjacency list representation of the graph\n    graph = defaultdict(list)\n    for u, v in passages:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # (1-indexed) BFS from Room 1 to determine shortest path to all rooms\n    queue = deque([1])\n    parent = {1: None}\n    while queue:\n        room = queue.popleft()\n        for neighbor in graph[room]:\n            if neighbor not in parent:\n                parent[neighbor] = room\n                queue.append(neighbor)\n                \n    # If there's any room not reached, return \"Impossible\"\n    if len(parent) != N:\n        return \"Impossible\"\n    \n    # Generate signposts configuration\n    configuration = []\n    for room in range(2, N + 1):\n        if room in parent:\n            configuration.append(f\"Room {room} -> Room {parent[room]}\")\n    \n    return \"\\n\".join(configuration)\n\n# Example usage:\nN = 5\nM = 5\npassages = [(1, 2), (2, 3), (3, 4), (4, 5), (1, 3)]\nprint(signposts_configuration(N, M, passages))",
    "timestamp": "2025-08-13 11:18:39"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class CaveSignposts {\n    private static class Edge {\n        int from, to;\n\n        Edge(int from, int to) {\n            this.from = from;\n            this.to = to;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int N = scanner.nextInt(); // Number of rooms\n        int M = scanner.nextInt(); // Number of passages\n        \n        List<Edge>[] adjList = new List[N + 1];\n        for (int i = 1; i <= N; i++) {\n            adjList[i] = new ArrayList<>();\n        }\n        \n        for (int i = 0; i < M; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            adjList[u].add(new Edge(u, v));\n            adjList[v].add(new Edge(v, u));\n        }\n\n        int[] dist = new int[N + 1];\n        int[] parent = new int[N + 1];\n        Arrays.fill(dist, -1);\n        \n        Queue<Integer> queue = new LinkedList<>();\n        queue.add(1);\n        dist[1] = 0;\n        \n        // BFS to determine shortest path to Room 1\n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            for (Edge edge : adjList[current]) {\n                int neighbor = edge.to;\n                if (dist[neighbor] == -1) { // not visited\n                    dist[neighbor] = dist[current] + 1;\n                    parent[neighbor] = current;\n                    queue.add(neighbor);\n                }\n            }\n        }\n\n        // Output the solution\n        boolean possible = true;\n        for (int i = 2; i <= N; i++) {\n            if (dist[i] == -1) {\n                possible = false;\n                break;\n            }\n        }\n\n        if (!possible) {\n            System.out.println(\"NO\");\n        } else {\n            System.out.println(\"YES\");\n            for (int i = 2; i <= N; i++) {\n                System.out.println(parent[i]);\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-13 11:18:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_N 100005\n#define INF INT_MAX\n\ntypedef struct {\n    int to;\n    int next;\n} Edge;\n\nEdge edges[MAX_N * 2];\nint head[MAX_N];\nint dist[MAX_N];\nint queue[MAX_N];\nint pre[MAX_N];\nint edgeCount;\nint n, m;\n\nvoid addEdge(int u, int v) {\n    edges[edgeCount].to = v;\n    edges[edgeCount].next = head[u];\n    head[u] = edgeCount++;\n}\n\nvoid bfs(int start) {\n    for (int i = 1; i <= n; ++i) {\n        dist[i] = INF;\n    }\n    int front = 0;\n    int back = 0;\n    queue[back++] = start;\n    dist[start] = 0;\n\n    while (front < back) {\n        int u = queue[front++];\n        for (int i = head[u]; i != -1; i = edges[i].next) {\n            int v = edges[i].to;\n            if (dist[v] == INF) {\n                dist[v] = dist[u] + 1;\n                pre[v] = u;\n                queue[back++] = v;\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 1; i <= n; ++i) {\n        head[i] = -1;\n    }\n    edgeCount = 0;\n\n    for (int i = 0; i < m; ++i) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        addEdge(v, u);\n    }\n\n    bfs(1);\n\n    for (int i = 2; i <= n; ++i) {\n        if (dist[i] == INF) {\n            printf(\"Impossible\\n\");\n            return 0;\n        }\n    }\n\n    for (int i = 2; i <= n; ++i) {\n        printf(\"%d <- %d\\n\", i, pre[i]);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:18:50"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function placeSignposts(n, m, passages) {\n    const adjList = Array.from({ length: n + 1 }, () => []);\n    const indegree = Array(n + 1).fill(0);\n    \n    for (const [u, v] of passages) {\n        adjList[v].push(u);\n        indegree[u]++;\n    }\n    \n    const queue = [];\n    if (indegree[1] === 0) queue.push(1);\n    \n    const result = Array(n + 1).fill(-1);\n    while (queue.length) {\n        const current = queue.shift();\n        for (const next of adjList[current]) {\n            indegree[next]--;\n            if (indegree[next] === 0) {\n                result[next] = current;\n                queue.push(next);\n            }\n        }\n    }\n    \n    // Check if all rooms except Room 1 have signposts pointing to Room 1\n    for (let i = 2; i <= n; i++) {\n        if (result[i] === -1) {\n            return \"Not possible\";\n        }\n    }\n    \n    return result.slice(2);\n}\n\n// Example usage\n// const n = 4;\n// const m = 4;\n// const passages = [\n//     [2, 1],\n//     [3, 1],\n//     [4, 2],\n//     [4, 3]\n// ];\n// console.log(placeSignposts(n, m, passages));",
    "timestamp": "2025-08-13 11:18:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_signposts(N, passages):\n    # Create adjacency list representation of the graph\n    graph = [[] for _ in range(N+1)]\n    for u, v in passages:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Track visited rooms and parent rooms\n    visited = [False] * (N+1)\n    parent = [0] * (N+1)\n    \n    # BFS to find paths to Room 1\n    def bfs_paths():\n        queue = [1]\n        visited[1] = True\n        \n        while queue:\n            current = queue.pop(0)\n            \n            for neighbor in graph[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    parent[neighbor] = current\n                    queue.append(neighbor)\n        \n        return all(visited[2:])\n    \n    # Check if all rooms can reach Room 1\n    if not bfs_paths():\n        return \"No solution\"\n    \n    # Generate signpost configuration\n    signposts = {}\n    for room in range(2, N+1):\n        signposts[room] = parent[room]\n    \n    return signposts\n\n# Example usage\nN = 5\npassages = [(1,2), (1,3), (2,4), (3,5)]\nresult = solve_signposts(N, passages)\nprint(result)",
    "timestamp": "2025-08-13 11:18:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function placeCaveSignposts(N, passages) {\n    const graph = Array.from({length: N+1}, () => []);\n    const inDegree = new Array(N+1).fill(0);\n    const outDegree = new Array(N+1).fill(0);\n\n    // Build graph\n    for (const [u, v] of passages) {\n        graph[u].push(v);\n        graph[v].push(u);\n        inDegree[v]++;\n        inDegree[u]++;\n    }\n\n    // Check if path to Room 1 is possible\n    const visited = new Array(N+1).fill(false);\n    const signposts = new Array(N+1).fill(0);\n\n    function dfs(node) {\n        visited[node] = true;\n        for (const neighbor of graph[node]) {\n            if (!visited[neighbor]) {\n                if (node !== 1) {\n                    signposts[node] = neighbor;\n                }\n                dfs(neighbor);\n            }\n        }\n    }\n\n    dfs(1);\n\n    // Check if all rooms can reach Room 1\n    for (let i = 2; i <= N; i++) {\n        if (!visited[i]) return null;\n    }\n\n    return signposts.slice(2);\n}",
    "timestamp": "2025-08-13 11:19:05"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    N, M = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(N+1)]\n    for _ in range(M):\n        a, b = map(int, sys.stdin.readline().split())\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    # BFS to find the shortest path from Room 1 to all other rooms\n    parent = [0] * (N + 1)\n    visited = [False] * (N + 1)\n    q = deque()\n    q.append(1)\n    visited[1] = True\n    \n    while q:\n        u = q.popleft()\n        for v in adj[u]:\n            if not visited[v]:\n                visited[v] = True\n                parent[v] = u\n                q.append(v)\n    \n    # Check if all rooms are reachable\n    for i in range(2, N+1):\n        if not visited[i]:\n            print(\"No\")\n            return\n    \n    print(\"Yes\")\n    for i in range(2, N+1):\n        print(parent[i])\n\nif __name__ == \"__main__\":\n    solve()",
    "timestamp": "2025-08-13 11:19:12"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nlet N, M;\nlet edges = [];\nlet adjacencyList = [];\nlet parent = [];\nlet distance = [];\nlet possible = true;\n\nrl.on('line', (line) => {\n    if (!N) {\n        [N, M] = line.split(' ').map(Number);\n        adjacencyList = Array.from({ length: N + 1 }, () => []);\n    } else {\n        const [u, v] = line.split(' ').map(Number);\n        edges.push([u, v]);\n        adjacencyList[u].push(v);\n        adjacencyList[v].push(u);\n        if (edges.length === M) {\n            solve();\n            rl.close();\n        }\n    }\n});\n\nfunction solve() {\n    parent = new Array(N + 1).fill(-1);\n    distance = new Array(N + 1).fill(Infinity);\n    const queue = [];\n    queue.push(1);\n    distance[1] = 0;\n\n    while (queue.length > 0) {\n        const u = queue.shift();\n        for (const v of adjacencyList[u]) {\n            if (distance[v] === Infinity) {\n                distance[v] = distance[u] + 1;\n                parent[v] = u;\n                queue.push(v);\n            }\n        }\n    }\n\n    for (let i = 2; i <= N; i++) {\n        if (parent[i] === -1) {\n            possible = false;\n            break;\n        }\n    }\n\n    if (!possible) {\n        console.log(\"No\");\n    } else {\n        console.log(\"Yes\");\n        for (let i = 2; i <= N; i++) {\n            console.log(parent[i]);\n        }\n    }\n}",
    "timestamp": "2025-08-13 11:19:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define INF 1e9\n\nusing namespace std;\n\nbool possibleToSignpost(int N, const vector<vector<int>>& adj, vector<int>& signpost) {\n    vector<int> dist(N+1, INF);\n    queue<int> q;\n    q.push(1);\n    dist[1] = 0;\n\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (int v : adj[u]) {\n            if (dist[v] == INF) {\n                dist[v] = dist[u] + 1;\n                signpost[v] = u;\n                q.push(v);\n            }\n        }\n    }\n\n    for (int i = 2; i <= N; ++i) {\n        if (dist[i] == INF) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    \n    vector<vector<int>> adj(N+1);\n    for (int i = 0; i < M; ++i) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    \n    vector<int> signpost(N+1, -1);\n    if (possibleToSignpost(N, adj, signpost)) {\n        for (int i = 2; i <= N; ++i) {\n            cout << \"Room \" << i << \" -> Room \" << signpost[i] << endl;\n        }\n    } else {\n        cout << \"No valid configuration possible\" << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 12:03:09"
  }
]