[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MOD 1000000007\n\nlong long factorial(int n) {\n    long long result = 1;\n    for (int i = 2; i <= n; i++) {\n        result = (result * i) % MOD;\n    }\n    return result;\n}\n\nint main() {\n    int N, beef[100], green[100];\n    scanf(\"%d\", &N);\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &beef[i], &green[i]);\n    }\n\n    long long total_arrangements = 0;\n\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            int total_beef = beef[i] + beef[j];\n            int total_green = green[i] + green[j];\n            int total_pieces = total_beef + total_green;\n\n            long long arrangements = factorial(total_pieces) / \n                (factorial(beef[i]) * factorial(beef[j]) * \n                 factorial(green[i]) * factorial(green[j]) * \n                 factorial(2));\n\n            total_arrangements = (total_arrangements + arrangements) % MOD;\n        }\n    }\n\n    printf(\"%lld\\n\", total_arrangements);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:37:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000000007\n\ntypedef struct {\n    int a;\n    int b;\n} Pack;\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    Pack *packs = (Pack *)malloc(N * sizeof(Pack));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &packs[i].a, &packs[i].b);\n    }\n\n    long long total = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            int a1 = packs[i].a;\n            int b1 = packs[i].b;\n            int a2 = packs[j].a;\n            int b2 = packs[j].b;\n            long long ways = (a1 + a2) * (b1 + b2) - a1 * b1 - a2 * b2;\n            total = (total + ways) % MOD;\n        }\n    }\n\n    printf(\"%lld\\n\", total);\n    free(packs);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:38:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nstruct Pack {\n    int a, b;\n};\n\nint main() {\n    int N;\n    cin >> N;\n    vector<Pack> packs(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> packs[i].a >> packs[i].b;\n    }\n\n    map<pair<int, int>, int> freq;\n    for (int i = 0; i < N; ++i) {\n        int a = packs[i].a;\n        int b = packs[i].b;\n        int g = __gcd(a, b);\n        if (g != 0) {\n            a /= g;\n            b /= g;\n        }\n        freq[{a, b}]++;\n    }\n\n    long long total = 1;\n    for (auto it = freq.begin(); it != freq.end(); ++it) {\n        if (it->second == 0) continue;\n        auto [a, b] = it->first;\n        if (a == 0 && b == 0) continue;\n        if (a == 0) {\n            total = total * 1 % MOD;\n            continue;\n        }\n        if (b == 0) {\n            total = total * 1 % MOD;\n            continue;\n        }\n        pair<int, int> complement = {-b, a};\n        if (complement.first < 0) {\n            complement.first *= -1;\n            complement.second *= -1;\n        }\n        int g = __gcd(complement.first, complement.second);\n        if (g != 0) {\n            complement.first /= g;\n            complement.second /= g;\n        }\n        if (freq.count(complement)) {\n            int cnt = freq[complement];\n            long ways = 1;\n            ways = (ways + (1LL << it->second) - 1 + (1LL << cnt) - 1)) % MOD;\n            total = total * ways % MOD;\n            freq[complement] = 0;\n        } else {\n            total = total * (1LL << it->second) % MOD;\n        }\n    }\n\n    int zero_zero = 0;\n    if (freq.count({0, 0})) {\n        zero_zero = freq[{0, 0}];\n    }\n\n    total = (total + zero_zero - 1 + MOD) % MOD;\n\n    cout << total << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:38:27"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static final long MOD = 1000000007L;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int[] A = new int[N];\n        int[] B = new int[N];\n        \n        for (int i = 0; i < N; i++) {\n            A[i] = sc.nextInt();\n            B[i] = sc.nextInt();\n        }\n\n        long total = 0;\n        Map<String, Integer> freq = new HashMap<>();\n\n        for (int i = 0; i < N; i++) {\n            int a = A[i];\n            int b = B[i];\n            int g = gcd(a, b);\n            a /= g;\n            b /= g;\n            String key = a + \"/\" + b;\n            freq.put(key, freq.getOrDefault(key, 0) + 1);\n        }\n\n        long[] pow2 = new long[N + 1];\n        pow2[0] = 1;\n        for (int i = 1; i <= N; i++) {\n            pow2[i] = (pow2[i - 1] * 2) % MOD;\n        }\n\n        long res = 1;\n        Set<String> processed = new HashSet<>();\n\n        for (String key : freq.keySet()) {\n            if (processed.contains(key)) continue;\n            String[] parts = key.split(\"/\");\n            int a = Integer.parseInt(parts[0]);\n            int b = Integer.parseInt(parts[1]);\n            String reciprocalKey = b + \"/\" + (-a);\n            if (freq.containsKey(reciprocalKey)) {\n                long cnt1 = freq.get(key);\n                long cnt2 = freq.get(reciprocalKey);\n                res = res * (pow2[(int)cnt1] + pow2[(int)cnt2] - 1) % MOD;\n                processed.add(reciprocalKey);\n            } else {\n                res = res * pow2[freq.get(key)] % MOD;\n            }\n            processed.add(key);\n        }\n\n        res = (res - 1 + MOD) % MOD; // subtract the case where no packs are chosen\n        total = res;\n\n        // Subtract cases where only one pack is chosen (not valid since we need two different packs)\n        long singleCases = 0;\n        for (int i = 0; i < N; i++) {\n            singleCases = (singleCases + (A[i] + B[i] == 0 ? 1 : 0)) % MOD;\n        }\n        total = (total - singleCases + MOD) % MOD;\n\n        System.out.println(total);\n    }\n\n    static int gcd(int a, int b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n}",
    "timestamp": "2025-08-05 23:38:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class SkewersArrangement {\n    static final int MOD = 1000000007;\n    \n    public static long calculateArrangements(int N, int[] beef, int[] peppers) {\n        long totalArrangements = 0;\n        \n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                int totalBeef = beef[i] + beef[j];\n                int totalPeppers = peppers[i] + peppers[j];\n                \n                long beefArrangements = calculatePermutations(beef[i], beef[j]);\n                long pepperArrangements = calculatePermutations(peppers[i], peppers[j]);\n                \n                long skewersArrangements = 2;\n                \n                long currentArrangements = (beefArrangements * pepperArrangements * skewersArrangements) % MOD;\n                totalArrangements = (totalArrangements + currentArrangements) % MOD;\n            }\n        }\n        \n        return totalArrangements;\n    }\n    \n    static long calculatePermutations(int a, int b) {\n        long factorial = 1;\n        long totalIngredients = a + b;\n        \n        for (long i = 1; i <= totalIngredients; i++) {\n            factorial = (factorial * i) % MOD;\n        }\n        \n        long denominator = 1;\n        for (long i = 1; i <= a; i++) {\n            denominator = (denominator * i) % MOD;\n        }\n        \n        for (long i = 1; i <= b; i++) {\n            denominator = (denominator * i) % MOD;\n        }\n        \n        return modularDivision(factorial, denominator);\n    }\n    \n    static long modularDivision(long a, long b) {\n        return (a * modularInverse(b)) % MOD;\n    }\n    \n    static long modularInverse(long b) {\n        return modularPow(b, MOD - 2);\n    }\n    \n    static long modularPow(long base, long exponent) {\n        long result = 1;\n        base %= MOD;\n        \n        while (exponent > 0) {\n            if (exponent % 2 == 1) {\n                result = (result * base) % MOD;\n            }\n            base = (base * base) % MOD;\n            exponent /= 2;\n        }\n        \n        return result;\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        \n        int N = Integer.parseInt(br.readLine());\n        \n        int[] beef = new int[N];\n        int[] peppers = new int[N];\n        \n        StringTokenizer st = new StringTokenizer(br.readLine());\n        for (int i = 0; i < N; i++) {\n            beef[i] = Integer.parseInt(st.nextToken());\n        }\n        \n        st = new StringTokenizer(br.readLine());\n        for (int i = 0; i < N; i++) {\n            peppers[i] = Integer.parseInt(st.nextToken());\n        }\n        \n        long result = calculateArrangements(N, beef, peppers);\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 23:39:00"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    \n    vector<int> beef(N), pepper(N);\n    for(int i = 0; i < N; i++) cin >> beef[i];\n    for(int i = 0; i < N; i++) cin >> pepper[i];\n    \n    long long result = 0;\n    const int MOD = 1e9 + 7;\n    \n    for(int i = 0; i < N; i++) {\n        for(int j = i+1; j < N; j++) {\n            int totalBeef = beef[i] + beef[j];\n            int totalPepper = pepper[i] + pepper[j];\n            \n            long long arrangements = 1;\n            \n            for(int k = 1; k <= totalBeef; k++) {\n                arrangements = (arrangements * k) % MOD;\n            }\n            \n            for(int k = 1; k <= totalPepper; k++) {\n                arrangements = (arrangements * k) % MOD;\n            }\n            \n            arrangements = (arrangements * 2) % MOD;\n            result = (result + arrangements) % MOD;\n        }\n    }\n    \n    cout << result << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:39:04"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 10**9 + 7\n\ndef factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    res = 1\n    for i in range(2, n + 1):\n        res = res * i % MOD\n    return res\n\ndef mod_inv(a, p):\n    return pow(a, p - 2, p)\n\ndef count_ways(beef1, peppers1, beef2, peppers2):\n    # Choose positions for beef1 + peppers1 on skewer 1\n    total1 = beef1 + peppers1\n    # Choose positions for beef2 + peppers2 on skewer 2\n    total2 = beef2 + peppers2\n    result = (factorial(total1) * mod_inv(factorial(beef1), MOD) % MOD * mod_inv(factorial(peppers1), MOD) % MOD) % MOD\n    result = (result * factorial(total2) * mod_inv(factorial(beef2), MOD) % MOD * mod_inv(factorial(peppers2), MOD) % MOD) % MOD\n    return result\n\ndef skewer_meal(N, skewer_packs):\n    total_ways = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            b1, p1 = skewer_packs[i]\n            b2, p2 = skewer_packs[j]\n            # Ways to arrange (considering both orderings i,j and j,i)\n            total_ways += 2 * count_ways(b1, p1, b2, p2)\n            total_ways %= MOD\n    return total_ways\n\n# Example of using this function:\n# N = 3\n# skewer_packs = [(2, 1), (1, 2), (2, 2)]\n# print(skewer_meal(N, skewer_packs))  # The function call with example packs",
    "timestamp": "2025-08-13 16:30:28"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class SkewerMeal {\n\n    private static final int MOD = 1000000007;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[][] packs = new int[N][2];\n\n        for (int i = 0; i < N; i++) {\n            packs[i][0] = scanner.nextInt(); // number of beef\n            packs[i][1] = scanner.nextInt(); // number of green peppers\n        }\n\n        long totalWays = 0;\n\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                int beefSum = packs[i][0] + packs[j][0];\n                int pepperSum = packs[i][1] + packs[j][1];\n\n                // calculate combinations of forming two skewers\n                long currentWays = combinations(beefSum, beefSum / 2) * combinations(pepperSum, pepperSum / 2) % MOD;\n                totalWays = (totalWays + currentWays) % MOD;\n            }\n        }\n\n        System.out.println(totalWays);\n    }\n\n    private static long combinations(int n, int k) {\n        if (n < k) return 0;\n        if (k == 0 || n == k) return 1;\n\n        long result = 1;\n        for (int i = 0; i < k; i++) {\n            result = result * (n - i) % MOD;\n            result = result * modInverse(i + 1, MOD) % MOD;\n        }\n        return result;\n    }\n\n    private static long modInverse(long a, long m) {\n        return modPow(a, m - 2, m);\n    }\n\n    private static long modPow(long a, long b, long m) {\n        long result = 1;\n        while (b > 0) {\n            if ((b & 1) != 0) {\n                result = result * a % m;\n            }\n            a = a * a % m;\n            b >>= 1;\n        }\n        return result;\n    }\n}",
    "timestamp": "2025-08-13 16:30:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\n#define MOD 1000000007\n\ntypedef long long ll;\n\nll fact[61], invFact[61];\n\nll powMod(ll base, ll exp, ll mod) {\n    ll result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % mod;\n        }\n        base = (base * base) % mod;\n        exp /= 2;\n    }\n    return result;\n}\n\nvoid preprocess() {\n    fact[0] = 1;\n    for (int i = 1; i <= 60; ++i) {\n        fact[i] = fact[i - 1] * i % MOD;\n    }\n    invFact[60] = powMod(fact[60], MOD - 2, MOD);\n    for (int i = 59; i >= 0; --i) {\n        invFact[i] = invFact[i + 1] * (i + 1) % MOD;\n    }\n}\n\nll comb(int n, int k) {\n    if (k > n) return 0;\n    return fact[n] * invFact[k] % MOD * invFact[n - k] % MOD;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    int beef[N], pepper[N];\n\n    for (int i = 0; i < N; ++i) {\n        scanf(\"%d %d\", &beef[i], &pepper[i]);\n    }\n\n    preprocess();\n\n    ll result = 0;\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            int totalB = beef[i] + beef[j];\n            int totalP = pepper[i] + pepper[j];\n            int total = totalB + totalP + 2; // +2 for skewers\n            ll ways = comb(total, totalB) * comb(totalB, beef[i]) % MOD * comb(totalP, pepper[i]) % MOD;\n            result = (result + ways * 2) % MOD;\n        }\n    }\n\n    printf(\"%lld\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-13 16:30:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int N;\n    cin >> N;\n    \n    vector<pair<int, int>> packs(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> packs[i].first >> packs[i].second;\n    }\n    \n    int result = 0;\n    \n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            int piecesA[] = {packs[i].first, packs[i].second};\n            int piecesB[] = {packs[j].first, packs[j].second};\n            \n            do {\n                do {\n                    int totalA = piecesA[0] + piecesB[0];\n                    int totalB = piecesA[1] + piecesB[1];\n                    // Comb1: A from pack[i] + B from pack[j]\n                    result = (result + ((totalA + totalB) % MOD)) % MOD;\n                    // Comb2: A from pack[j] + B from pack[i]\n                    if (piecesA[0] != piecesB[0] || piecesA[1] != piecesB[1])\n                        result = (result + ((totalA + totalB) % MOD)) % MOD;\n                } while (next_permutation(piecesB, piecesB + 2));\n            } while (next_permutation(piecesA, piecesA + 2));\n        }\n    }\n    \n    cout << result << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 16:30:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_distinct_arrangements(N, beef_counts, green_pepper_counts):\n    MOD = 10**9 + 7\n    \n    total_arrangements = 0\n    \n    for i in range(N):\n        for j in range(i+1, N):\n            total_beef = beef_counts[i] + beef_counts[j]\n            total_green_peppers = green_pepper_counts[i] + green_pepper_counts[j]\n            \n            total_ingredients = total_beef + total_green_peppers\n            \n            # Compute factorial with modulo\n            total_factorial = 1\n            for k in range(1, total_ingredients + 1):\n                total_factorial = (total_factorial * k) % MOD\n            \n            # Compute repetition correction\n            beef_factorial = 1\n            for k in range(1, total_beef + 1):\n                beef_factorial = (beef_factorial * k) % MOD\n            \n            green_pepper_factorial = 1\n            for k in range(1, total_green_peppers + 1):\n                green_pepper_factorial = (green_pepper_factorial * k) % MOD\n            \n            # Compute arrangements\n            arrangements = total_factorial * pow(beef_factorial, MOD-2, MOD) * pow(green_pepper_factorial, MOD-2, MOD)\n            arrangements %= MOD\n            \n            total_arrangements = (total_arrangements + arrangements * 2) % MOD\n    \n    return total_arrangements\n\n# Example usage\nN = int(input())\nbeef_counts = list(map(int, input().split()))\ngreen_pepper_counts = list(map(int, input().split()))\n\nresult = count_distinct_arrangements(N, beef_counts, green_pepper_counts)\nprint(result)",
    "timestamp": "2025-08-13 16:30:55"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict\n\nMOD = 10**9 + 7\n\ndef solve():\n    N = int(sys.stdin.readline())\n    packs = []\n    for _ in range(N):\n        a, b = map(int, sys.stdin.readline().split())\n        packs.append((a, b))\n    \n    # Count the frequency of each (a, b) pair\n    freq = defaultdict(int)\n    for a, b in packs:\n        freq[(a, b)] += 1\n    \n    # Precompute factorial, inverse factorial up to 2*10^5 to compute combinations\n    max_n = 2 * 10**5 + 10\n    fact = [1] * (max_n)\n    inv_fact = [1] * (max_n)\n    \n    for i in range(1, max_n):\n        fact[i] = fact[i-1] * i % MOD\n    \n    inv_fact[max_n - 1] = pow(fact[max_n - 1], MOD-2, MOD)\n    for i in range(max_n - 2, -1, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n    \n    def comb(n, k):\n        if n < 0 or k < 0 or k > n:\n            return 0\n        return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD\n    \n    total = 0\n    \n    # First, compute the total possible pairs without any restrictions\n    total_pairs = comb(N, 2)\n    \n    # Then subtract the pairs that are invalid (same a and same b)\n    same_pairs = 0\n    for cnt in freq.values():\n        if cnt >= 2:\n            same_pairs += comb(cnt, 2)\n    \n    # Also subtract the pairs where a1 + a2 = b1 + b2\n    # To find such pairs, note that a1 - b1 = -(a2 - b2)\n    # So we can count the number of pairs with (a - b) = d and (a - b) = -d\n    diff_counts = defaultdict(int)\n    for a, b in packs:\n        d = a - b\n        diff_counts[d] += 1\n    \n    diff_pairs = 0\n    processed = set()\n    for d in diff_counts:\n        if d == 0:\n            continue\n        if -d in diff_counts and d not in processed and -d not in processed:\n            if d != -d:\n                diff_pairs += diff_counts[d] * diff_counts[-d]\n            else:\n                diff_pairs += comb(diff_counts[d], 2)\n            processed.add(d)\n            processed.add(-d)\n    \n    # The valid pairs are total_pairs - same_pairs - diff_pairs\n    valid_pairs = (total_pairs - same_pairs - diff_pairs) % MOD\n    \n    # For each valid pair, the number of arrangements is (a1 + a2 + b1 + b2)! / ( (a1 + a2)! * (b1 + b2)! )\n    # To compute this efficiently, we need to precompute the sum for all valid pairs\n    \n    # We'll use a frequency map for (a, b) and process each unique (a, b) only once\n    # Also, to avoid double counting, we'll process pairs where (a1, b1) < (a2, b2) lexicographically\n    \n    # Precompute the sum_a and sum_b for each (a, b)\n    sum_a = defaultdict(int)\n    sum_b = defaultdict(int)\n    for a, b in packs:\n        sum_a[(a, b)] += a\n        sum_b[(a, b)] += b\n    \n    # Now, for each unique (a1, b1), and (a2, b2) where (a1, b1) < (a2, b2) lex order, and (a1 - b1) != (b2 - a2)\n    # We need to compute the sum over (a1 + a2 + b1 + b2)! / ( (a1 + a2)! * (b1 + b2)! ) * cnt1 * cnt2\n    \n    # To optimize, we can precompute for each (a, b) the sum of (a + a2 + b + b2)! / ( (a + a2)! * (b + b2)! ) * cnt2 over all (a2, b2)\n    # But this is not straightforward, so we'll proceed with a more direct approach\n    \n    # We'll iterate over all unique (a1, b1) and (a2, b2) pairs where (a1, b1) < (a2, b2) lex order and (a1 - b1) != (b2 - a2)\n    # For each such pair, compute the term and multiply by cnt1 * cnt2\n    \n    res = 0\n    keys = list(freq.keys())\n    m = len(keys)\n    for i in range(m):\n        a1, b1 = keys[i]\n        cnt1 = freq[(a1, b1)]\n        for j in range(i + 1, m):\n            a2, b2 = keys[j]\n            if (a1 - b1) == -(a2 - b2):\n                continue  # these are the diff_pairs already excluded\n            cnt2 = freq[(a2, b2)]\n            total_a = a1 + a2\n            total_b = b1 + b2\n            term = fact[total_a + total_b] * inv_fact[total_a] % MOD\n            term = term * inv_fact[total_b] % MOD\n            term = term * cnt1 % MOD\n            term = term * cnt2 % MOD\n            res = (res + term) % MOD\n    \n    # Also, handle the case where the same (a, b) is chosen, but only if cnt >= 2 and (a - b) != -(a - b) => d != 0\n    for (a, b), cnt in freq.items():\n        if cnt >= 2 and (a - b) != 0:\n            total_a = 2 * a\n            total_b = 2 * b\n            term = fact[total_a + total_b] * inv_fact[total_a] % MOD\n            term = term * inv_fact[total_b] % MOD\n            term = term * comb(cnt, 2) % MOD\n            res = (res + term) % MOD\n    \n    print(res % MOD)\n\nsolve()",
    "timestamp": "2025-08-13 16:31:48"
  }
]